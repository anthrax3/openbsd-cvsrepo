head	1.21;
access;
symbols
	OPENBSD_6_1:1.21.0.2
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.20.0.4
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.18.0.4
	OPENBSD_5_8_BASE:1.18
	PERL_5_20_2:1.1.1.16
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	PERL_5_20_1:1.1.1.15
	OPENBSD_5_6:1.16.0.4
	OPENBSD_5_6_BASE:1.16
	PERL_5_18_2:1.1.1.14
	PERL:1.1.1
	OPENBSD_5_5:1.15.0.6
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.2
	OPENBSD_5_4_BASE:1.15
	PERL_5_16_3:1.1.1.13
	OPENBSD_5_3:1.14.0.10
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.8
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.6
	OPENBSD_5_0:1.14.0.4
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	PERL_5_12_2:1.1.1.12
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	PERL_5_10_1:1.1.1.11
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	PERL_5_10_0:1.1.1.10
	OPENBSD_4_4:1.10.0.10
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.8
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	PERL_5_8_8:1.1.1.9
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	PERL_5_8_6:1.1.1.8
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.21
date	2017.02.05.00.31.53;	author afresh1;	state Exp;
branches;
next	1.20;
commitid	cxJ08BvJA9Pt2PTM;

1.20
date	2016.07.03.01.07.48;	author afresh1;	state Exp;
branches;
next	1.19;
commitid	GzHqjSTnBjdF7Wcw;

1.19
date	2016.04.20.19.35.34;	author millert;	state Exp;
branches;
next	1.18;
commitid	ZEIabvJySz9djFex;

1.18
date	2015.04.25.19.14.38;	author afresh1;	state Exp;
branches;
next	1.17;
commitid	XRK22kO4se3v2i2I;

1.17
date	2014.11.17.20.56.48;	author afresh1;	state Exp;
branches;
next	1.16;
commitid	QP75iYx42Uo7mMxO;

1.16
date	2014.03.24.15.05.13;	author afresh1;	state Exp;
branches;
next	1.15;

1.15
date	2013.03.25.20.40.45;	author sthen;	state Exp;
branches;
next	1.14;

1.14
date	2010.09.24.15.06.43;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2009.11.03.14.24.09;	author jasper;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.12.18.24.21;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.29.17.35.59;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.28.19.22.59;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2005.01.15.21.30.22;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.09.18.08.56;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.22;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.19;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.34.57;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.04.23;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.10;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.49.16;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.11.49;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.11.49;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.37.53;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.08.47;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.22.21;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.51;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.36;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.45.47;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2005.01.15.21.16.36;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2006.03.28.18.47.43;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2008.09.29.17.18.10;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2009.10.12.18.10.36;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2010.09.24.14.48.34;	author millert;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2013.03.25.20.06.40;	author sthen;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.03.24.14.58.47;	author afresh1;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2014.11.17.20.52.39;	author afresh1;	state Exp;
branches;
next	1.1.1.16;
commitid	B31cAbBIXiCqnL97;

1.1.1.16
date	2015.04.25.19.10.13;	author afresh1;	state Exp;
branches;
next	;
commitid	Wpcs5S8qILgEZC7F;


desc
@@


1.21
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*    regexec.c
 */

/*
 *	One Ring to rule them all, One Ring to find them
 *
 *     [p.v of _The Lord of the Rings_, opening poem]
 *     [p.50 of _The Lord of the Rings_, I/iii: "The Shadow of the Past"]
 *     [p.254 of _The Lord of the Rings_, II/ii: "The Council of Elrond"]
 */

/* This file contains functions for executing a regular expression.  See
 * also regcomp.c which funnily enough, contains functions for compiling
 * a regular expression.
 *
 * This file is also copied at build time to ext/re/re_exec.c, where
 * it's built with -DPERL_EXT_RE_BUILD -DPERL_EXT_RE_DEBUG -DPERL_EXT.
 * This causes the main functions to be compiled under new names and with
 * debugging support added, which makes "use re 'debug'" work.
 */

/* NOTE: this is derived from Henry Spencer's regexp code, and should not
 * confused with the original package (see point 3 below).  Thanks, Henry!
 */

/* Additional note: this code is very heavily munged from Henry's version
 * in places.  In some spots I've traded clarity for efficiency, so don't
 * blame Henry for some of the lack of readability.
 */

/* The names of the functions have been changed from regcomp and
 * regexec to  pregcomp and pregexec in order to avoid conflicts
 * with the POSIX routines of the same names.
*/

#ifdef PERL_EXT_RE_BUILD
#include "re_top.h"
#endif

/*
 * pregcomp and pregexec -- regsub and regerror are not used in perl
 *
 *	Copyright (c) 1986 by University of Toronto.
 *	Written by Henry Spencer.  Not derived from licensed software.
 *
 *	Permission is granted to anyone to use this software for any
 *	purpose on any computer system, and to redistribute it freely,
 *	subject to the following restrictions:
 *
 *	1. The author is not responsible for the consequences of use of
 *		this software, no matter how awful, even if they arise
 *		from defects in it.
 *
 *	2. The origin of this software must not be misrepresented, either
 *		by explicit claim or by omission.
 *
 *	3. Altered versions must be plainly marked as such, and must not
 *		be misrepresented as being the original software.
 *
 ****    Alterations to Henry's code are...
 ****
 ****    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 ****    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
 ****    by Larry Wall and others
 ****
 ****    You may distribute under the terms of either the GNU General Public
 ****    License or the Artistic License, as specified in the README file.
 *
 * Beware that some of this code is subtly aware of the way operator
 * precedence is structured in regular expressions.  Serious changes in
 * regular-expression syntax might require a total rethink.
 */
#include "EXTERN.h"
#define PERL_IN_REGEXEC_C
#include "perl.h"

#ifdef PERL_IN_XSUB_RE
#  include "re_comp.h"
#else
#  include "regcomp.h"
#endif

#include "invlist_inline.h"
#include "unicode_constants.h"

#define B_ON_NON_UTF8_LOCALE_IS_WRONG            \
 "Use of \\b{} or \\B{} for non-UTF-8 locale is wrong.  Assuming a UTF-8 locale"

static const char utf8_locale_required[] =
      "Use of (?[ ]) for non-UTF-8 locale is wrong.  Assuming a UTF-8 locale";

#ifdef DEBUGGING
/* At least one required character in the target string is expressible only in
 * UTF-8. */
static const char* const non_utf8_target_but_utf8_required
                = "Can't match, because target string needs to be in UTF-8\n";
#endif

#define NON_UTF8_TARGET_BUT_UTF8_REQUIRED(target) STMT_START {           \
    DEBUG_EXECUTE_r(Perl_re_printf( aTHX_  "%s", non_utf8_target_but_utf8_required));\
    goto target;                                                         \
} STMT_END

#define HAS_NONLATIN1_FOLD_CLOSURE(i) _HAS_NONLATIN1_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(i)

#ifndef STATIC
#define	STATIC	static
#endif

/* Valid only if 'c', the character being looke-up, is an invariant under
 * UTF-8: it avoids the reginclass call if there are no complications: i.e., if
 * everything matchable is straight forward in the bitmap */
#define REGINCLASS(prog,p,c,u)  (ANYOF_FLAGS(p)                             \
                                ? reginclass(prog,p,c,c+1,u)                \
                                : ANYOF_BITMAP_TEST(p,*(c)))

/*
 * Forwards.
 */

#define CHR_SVLEN(sv) (utf8_target ? sv_len_utf8(sv) : SvCUR(sv))
#define CHR_DIST(a,b) (reginfo->is_utf8_target ? utf8_distance(a,b) : a - b)

#define HOPc(pos,off) \
	(char *)(reginfo->is_utf8_target \
	    ? reghop3((U8*)pos, off, \
                    (U8*)(off >= 0 ? reginfo->strend : reginfo->strbeg)) \
	    : (U8*)(pos + off))

#define HOPBACKc(pos, off) \
	(char*)(reginfo->is_utf8_target \
	    ? reghopmaybe3((U8*)pos, (SSize_t)0-off, (U8*)(reginfo->strbeg)) \
	    : (pos - off >= reginfo->strbeg)	\
		? (U8*)pos - off		\
		: NULL)

#define HOP3(pos,off,lim) (reginfo->is_utf8_target  ? reghop3((U8*)(pos), off, (U8*)(lim)) : (U8*)(pos + off))
#define HOP3c(pos,off,lim) ((char*)HOP3(pos,off,lim))

/* lim must be +ve. Returns NULL on overshoot */
#define HOPMAYBE3(pos,off,lim) \
	(reginfo->is_utf8_target                        \
	    ? reghopmaybe3((U8*)pos, off, (U8*)(lim))   \
	    : ((U8*)pos + off <= lim)                   \
		? (U8*)pos + off                        \
		: NULL)

/* like HOP3, but limits the result to <= lim even for the non-utf8 case.
 * off must be >=0; args should be vars rather than expressions */
#define HOP3lim(pos,off,lim) (reginfo->is_utf8_target \
    ? reghop3((U8*)(pos), off, (U8*)(lim)) \
    : (U8*)((pos + off) > lim ? lim : (pos + off)))

#define HOP4(pos,off,llim, rlim) (reginfo->is_utf8_target \
    ? reghop4((U8*)(pos), off, (U8*)(llim), (U8*)(rlim)) \
    : (U8*)(pos + off))
#define HOP4c(pos,off,llim, rlim) ((char*)HOP4(pos,off,llim, rlim))

#define NEXTCHR_EOS -10 /* nextchr has fallen off the end */
#define NEXTCHR_IS_EOS (nextchr < 0)

#define SET_nextchr \
    nextchr = ((locinput < reginfo->strend) ? UCHARAT(locinput) : NEXTCHR_EOS)

#define SET_locinput(p) \
    locinput = (p);  \
    SET_nextchr


#define LOAD_UTF8_CHARCLASS(swash_ptr, property_name, invlist) STMT_START {   \
        if (!swash_ptr) {                                                     \
            U8 flags = _CORE_SWASH_INIT_ACCEPT_INVLIST;                       \
            swash_ptr = _core_swash_init("utf8", property_name, &PL_sv_undef, \
                                         1, 0, invlist, &flags);              \
            assert(swash_ptr);                                                \
        }                                                                     \
    } STMT_END

/* If in debug mode, we test that a known character properly matches */
#ifdef DEBUGGING
#   define LOAD_UTF8_CHARCLASS_DEBUG_TEST(swash_ptr,                          \
                                          property_name,                      \
                                          invlist,                            \
                                          utf8_char_in_property)              \
        LOAD_UTF8_CHARCLASS(swash_ptr, property_name, invlist);               \
        assert(swash_fetch(swash_ptr, (U8 *) utf8_char_in_property, TRUE));
#else
#   define LOAD_UTF8_CHARCLASS_DEBUG_TEST(swash_ptr,                          \
                                          property_name,                      \
                                          invlist,                            \
                                          utf8_char_in_property)              \
        LOAD_UTF8_CHARCLASS(swash_ptr, property_name, invlist)
#endif

#define LOAD_UTF8_CHARCLASS_ALNUM() LOAD_UTF8_CHARCLASS_DEBUG_TEST(           \
                                        PL_utf8_swash_ptrs[_CC_WORDCHAR],     \
                                        "",                                   \
                                        PL_XPosix_ptrs[_CC_WORDCHAR],         \
                                        LATIN_SMALL_LIGATURE_LONG_S_T_UTF8);

#define PLACEHOLDER	/* Something for the preprocessor to grab onto */
/* TODO: Combine JUMPABLE and HAS_TEXT to cache OP(rn) */

/* for use after a quantifier and before an EXACT-like node -- japhy */
/* it would be nice to rework regcomp.sym to generate this stuff. sigh
 *
 * NOTE that *nothing* that affects backtracking should be in here, specifically
 * VERBS must NOT be included. JUMPABLE is used to determine  if we can ignore a
 * node that is in between two EXACT like nodes when ascertaining what the required
 * "follow" character is. This should probably be moved to regex compile time
 * although it may be done at run time beause of the REF possibility - more
 * investigation required. -- demerphq
*/
#define JUMPABLE(rn) (                                                             \
    OP(rn) == OPEN ||                                                              \
    (OP(rn) == CLOSE &&                                                            \
     !EVAL_CLOSE_PAREN_IS(cur_eval,ARG(rn)) ) ||                                   \
    OP(rn) == EVAL ||                                                              \
    OP(rn) == SUSPEND || OP(rn) == IFMATCH ||                                      \
    OP(rn) == PLUS || OP(rn) == MINMOD ||                                          \
    OP(rn) == KEEPS ||                                                             \
    (PL_regkind[OP(rn)] == CURLY && ARG1(rn) > 0)                                  \
)
#define IS_EXACT(rn) (PL_regkind[OP(rn)] == EXACT)

#define HAS_TEXT(rn) ( IS_EXACT(rn) || PL_regkind[OP(rn)] == REF )

#if 0 
/* Currently these are only used when PL_regkind[OP(rn)] == EXACT so
   we don't need this definition.  XXX These are now out-of-sync*/
#define IS_TEXT(rn)   ( OP(rn)==EXACT   || OP(rn)==REF   || OP(rn)==NREF   )
#define IS_TEXTF(rn)  ( OP(rn)==EXACTFU || OP(rn)==EXACTFU_SS || OP(rn)==EXACTFA || OP(rn)==EXACTFA_NO_TRIE || OP(rn)==EXACTF || OP(rn)==REFF  || OP(rn)==NREFF )
#define IS_TEXTFL(rn) ( OP(rn)==EXACTFL || OP(rn)==REFFL || OP(rn)==NREFFL )

#else
/* ... so we use this as its faster. */
#define IS_TEXT(rn)   ( OP(rn)==EXACT || OP(rn)==EXACTL )
#define IS_TEXTFU(rn)  ( OP(rn)==EXACTFU || OP(rn)==EXACTFLU8 || OP(rn)==EXACTFU_SS || OP(rn) == EXACTFA || OP(rn) == EXACTFA_NO_TRIE)
#define IS_TEXTF(rn)  ( OP(rn)==EXACTF  )
#define IS_TEXTFL(rn) ( OP(rn)==EXACTFL )

#endif

/*
  Search for mandatory following text node; for lookahead, the text must
  follow but for lookbehind (rn->flags != 0) we skip to the next step.
*/
#define FIND_NEXT_IMPT(rn) STMT_START {                                   \
    while (JUMPABLE(rn)) { \
	const OPCODE type = OP(rn); \
	if (type == SUSPEND || PL_regkind[type] == CURLY) \
	    rn = NEXTOPER(NEXTOPER(rn)); \
	else if (type == PLUS) \
	    rn = NEXTOPER(rn); \
	else if (type == IFMATCH) \
	    rn = (rn->flags == 0) ? NEXTOPER(NEXTOPER(rn)) : rn + ARG(rn); \
	else rn += NEXT_OFF(rn); \
    } \
} STMT_END 

#define SLAB_FIRST(s) (&(s)->states[0])
#define SLAB_LAST(s)  (&(s)->states[PERL_REGMATCH_SLAB_SLOTS-1])

static void S_setup_eval_state(pTHX_ regmatch_info *const reginfo);
static void S_cleanup_regmatch_info_aux(pTHX_ void *arg);
static regmatch_state * S_push_slab(pTHX);

#define REGCP_PAREN_ELEMS 3
#define REGCP_OTHER_ELEMS 3
#define REGCP_FRAME_ELEMS 1
/* REGCP_FRAME_ELEMS are not part of the REGCP_OTHER_ELEMS and
 * are needed for the regexp context stack bookkeeping. */

STATIC CHECKPOINT
S_regcppush(pTHX_ const regexp *rex, I32 parenfloor, U32 maxopenparen)
{
    const int retval = PL_savestack_ix;
    const int paren_elems_to_push =
                (maxopenparen - parenfloor) * REGCP_PAREN_ELEMS;
    const UV total_elems = paren_elems_to_push + REGCP_OTHER_ELEMS;
    const UV elems_shifted = total_elems << SAVE_TIGHT_SHIFT;
    I32 p;
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_REGCPPUSH;

    if (paren_elems_to_push < 0)
        Perl_croak(aTHX_ "panic: paren_elems_to_push, %i < 0, maxopenparen: %i parenfloor: %i REGCP_PAREN_ELEMS: %u",
                   (int)paren_elems_to_push, (int)maxopenparen,
                   (int)parenfloor, (unsigned)REGCP_PAREN_ELEMS);

    if ((elems_shifted >> SAVE_TIGHT_SHIFT) != total_elems)
	Perl_croak(aTHX_ "panic: paren_elems_to_push offset %"UVuf
		   " out of range (%lu-%ld)",
		   total_elems,
                   (unsigned long)maxopenparen,
                   (long)parenfloor);

    SSGROW(total_elems + REGCP_FRAME_ELEMS);
    
    DEBUG_BUFFERS_r(
	if ((int)maxopenparen > (int)parenfloor)
            Perl_re_printf( aTHX_
		"rex=0x%"UVxf" offs=0x%"UVxf": saving capture indices:\n",
		PTR2UV(rex),
		PTR2UV(rex->offs)
	    );
    );
    for (p = parenfloor+1; p <= (I32)maxopenparen;  p++) {
/* REGCP_PARENS_ELEMS are pushed per pairs of parentheses. */
	SSPUSHIV(rex->offs[p].end);
	SSPUSHIV(rex->offs[p].start);
	SSPUSHINT(rex->offs[p].start_tmp);
        DEBUG_BUFFERS_r(Perl_re_printf( aTHX_
	    "    \\%"UVuf": %"IVdf"(%"IVdf")..%"IVdf"\n",
	    (UV)p,
	    (IV)rex->offs[p].start,
	    (IV)rex->offs[p].start_tmp,
	    (IV)rex->offs[p].end
	));
    }
/* REGCP_OTHER_ELEMS are pushed in any case, parentheses or no. */
    SSPUSHINT(maxopenparen);
    SSPUSHINT(rex->lastparen);
    SSPUSHINT(rex->lastcloseparen);
    SSPUSHUV(SAVEt_REGCONTEXT | elems_shifted); /* Magic cookie. */

    return retval;
}

/* These are needed since we do not localize EVAL nodes: */
#define REGCP_SET(cp)                                           \
    DEBUG_STATE_r(                                              \
        Perl_re_exec_indentf( aTHX_                                         \
            "Setting an EVAL scope, savestack=%"IVdf",\n",      \
            depth, (IV)PL_savestack_ix                          \
        )                                                       \
    );                                                          \
    cp = PL_savestack_ix

#define REGCP_UNWIND(cp)                                        \
    DEBUG_STATE_r(                                              \
        if (cp != PL_savestack_ix)                              \
            Perl_re_exec_indentf( aTHX_                                     \
                "Clearing an EVAL scope, savestack=%"IVdf"..%"IVdf"\n",\
                depth, (IV)(cp), (IV)PL_savestack_ix            \
            )                                                   \
    );                                                          \
    regcpblow(cp)

#define UNWIND_PAREN(lp, lcp)               \
    for (n = rex->lastparen; n > lp; n--)   \
        rex->offs[n].end = -1;              \
    rex->lastparen = n;                     \
    rex->lastcloseparen = lcp;


STATIC void
S_regcppop(pTHX_ regexp *rex, U32 *maxopenparen_p)
{
    UV i;
    U32 paren;
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_REGCPPOP;

    /* Pop REGCP_OTHER_ELEMS before the parentheses loop starts. */
    i = SSPOPUV;
    assert((i & SAVE_MASK) == SAVEt_REGCONTEXT); /* Check that the magic cookie is there. */
    i >>= SAVE_TIGHT_SHIFT; /* Parentheses elements to pop. */
    rex->lastcloseparen = SSPOPINT;
    rex->lastparen = SSPOPINT;
    *maxopenparen_p = SSPOPINT;

    i -= REGCP_OTHER_ELEMS;
    /* Now restore the parentheses context. */
    DEBUG_BUFFERS_r(
	if (i || rex->lastparen + 1 <= rex->nparens)
            Perl_re_printf( aTHX_
		"rex=0x%"UVxf" offs=0x%"UVxf": restoring capture indices to:\n",
		PTR2UV(rex),
		PTR2UV(rex->offs)
	    );
    );
    paren = *maxopenparen_p;
    for ( ; i > 0; i -= REGCP_PAREN_ELEMS) {
	SSize_t tmps;
	rex->offs[paren].start_tmp = SSPOPINT;
	rex->offs[paren].start = SSPOPIV;
	tmps = SSPOPIV;
	if (paren <= rex->lastparen)
	    rex->offs[paren].end = tmps;
        DEBUG_BUFFERS_r( Perl_re_printf( aTHX_
	    "    \\%"UVuf": %"IVdf"(%"IVdf")..%"IVdf"%s\n",
	    (UV)paren,
	    (IV)rex->offs[paren].start,
	    (IV)rex->offs[paren].start_tmp,
	    (IV)rex->offs[paren].end,
	    (paren > rex->lastparen ? "(skipped)" : ""));
	);
	paren--;
    }
#if 1
    /* It would seem that the similar code in regtry()
     * already takes care of this, and in fact it is in
     * a better location to since this code can #if 0-ed out
     * but the code in regtry() is needed or otherwise tests
     * requiring null fields (pat.t#187 and split.t#{13,14}
     * (as of patchlevel 7877)  will fail.  Then again,
     * this code seems to be necessary or otherwise
     * this erroneously leaves $1 defined: "1" =~ /^(?:(\d)x)?\d$/
     * --jhi updated by dapm */
    for (i = rex->lastparen + 1; i <= rex->nparens; i++) {
	if (i > *maxopenparen_p)
	    rex->offs[i].start = -1;
	rex->offs[i].end = -1;
        DEBUG_BUFFERS_r( Perl_re_printf( aTHX_
	    "    \\%"UVuf": %s   ..-1 undeffing\n",
	    (UV)i,
	    (i > *maxopenparen_p) ? "-1" : "  "
	));
    }
#endif
}

/* restore the parens and associated vars at savestack position ix,
 * but without popping the stack */

STATIC void
S_regcp_restore(pTHX_ regexp *rex, I32 ix, U32 *maxopenparen_p)
{
    I32 tmpix = PL_savestack_ix;
    PL_savestack_ix = ix;
    regcppop(rex, maxopenparen_p);
    PL_savestack_ix = tmpix;
}

#define regcpblow(cp) LEAVE_SCOPE(cp)	/* Ignores regcppush()ed data. */

STATIC bool
S_isFOO_lc(pTHX_ const U8 classnum, const U8 character)
{
    /* Returns a boolean as to whether or not 'character' is a member of the
     * Posix character class given by 'classnum' that should be equivalent to a
     * value in the typedef '_char_class_number'.
     *
     * Ideally this could be replaced by a just an array of function pointers
     * to the C library functions that implement the macros this calls.
     * However, to compile, the precise function signatures are required, and
     * these may vary from platform to to platform.  To avoid having to figure
     * out what those all are on each platform, I (khw) am using this method,
     * which adds an extra layer of function call overhead (unless the C
     * optimizer strips it away).  But we don't particularly care about
     * performance with locales anyway. */

    switch ((_char_class_number) classnum) {
        case _CC_ENUM_ALPHANUMERIC: return isALPHANUMERIC_LC(character);
        case _CC_ENUM_ALPHA:     return isALPHA_LC(character);
        case _CC_ENUM_ASCII:     return isASCII_LC(character);
        case _CC_ENUM_BLANK:     return isBLANK_LC(character);
        case _CC_ENUM_CASED:     return isLOWER_LC(character)
                                        || isUPPER_LC(character);
        case _CC_ENUM_CNTRL:     return isCNTRL_LC(character);
        case _CC_ENUM_DIGIT:     return isDIGIT_LC(character);
        case _CC_ENUM_GRAPH:     return isGRAPH_LC(character);
        case _CC_ENUM_LOWER:     return isLOWER_LC(character);
        case _CC_ENUM_PRINT:     return isPRINT_LC(character);
        case _CC_ENUM_PUNCT:     return isPUNCT_LC(character);
        case _CC_ENUM_SPACE:     return isSPACE_LC(character);
        case _CC_ENUM_UPPER:     return isUPPER_LC(character);
        case _CC_ENUM_WORDCHAR:  return isWORDCHAR_LC(character);
        case _CC_ENUM_XDIGIT:    return isXDIGIT_LC(character);
        default:    /* VERTSPACE should never occur in locales */
            Perl_croak(aTHX_ "panic: isFOO_lc() has an unexpected character class '%d'", classnum);
    }

    NOT_REACHED; /* NOTREACHED */
    return FALSE;
}

STATIC bool
S_isFOO_utf8_lc(pTHX_ const U8 classnum, const U8* character)
{
    /* Returns a boolean as to whether or not the (well-formed) UTF-8-encoded
     * 'character' is a member of the Posix character class given by 'classnum'
     * that should be equivalent to a value in the typedef
     * '_char_class_number'.
     *
     * This just calls isFOO_lc on the code point for the character if it is in
     * the range 0-255.  Outside that range, all characters use Unicode
     * rules, ignoring any locale.  So use the Unicode function if this class
     * requires a swash, and use the Unicode macro otherwise. */

    PERL_ARGS_ASSERT_ISFOO_UTF8_LC;

    if (UTF8_IS_INVARIANT(*character)) {
        return isFOO_lc(classnum, *character);
    }
    else if (UTF8_IS_DOWNGRADEABLE_START(*character)) {
        return isFOO_lc(classnum,
                        EIGHT_BIT_UTF8_TO_NATIVE(*character, *(character + 1)));
    }

    _CHECK_AND_OUTPUT_WIDE_LOCALE_UTF8_MSG(character, character + UTF8SKIP(character));

    if (classnum < _FIRST_NON_SWASH_CC) {

        /* Initialize the swash unless done already */
        if (! PL_utf8_swash_ptrs[classnum]) {
            U8 flags = _CORE_SWASH_INIT_ACCEPT_INVLIST;
            PL_utf8_swash_ptrs[classnum] =
                    _core_swash_init("utf8",
                                     "",
                                     &PL_sv_undef, 1, 0,
                                     PL_XPosix_ptrs[classnum], &flags);
        }

        return cBOOL(swash_fetch(PL_utf8_swash_ptrs[classnum], (U8 *)
                                 character,
                                 TRUE /* is UTF */ ));
    }

    switch ((_char_class_number) classnum) {
        case _CC_ENUM_SPACE:     return is_XPERLSPACE_high(character);
        case _CC_ENUM_BLANK:     return is_HORIZWS_high(character);
        case _CC_ENUM_XDIGIT:    return is_XDIGIT_high(character);
        case _CC_ENUM_VERTSPACE: return is_VERTWS_high(character);
        default:                 break;
    }

    return FALSE; /* Things like CNTRL are always below 256 */
}

/*
 * pregexec and friends
 */

#ifndef PERL_IN_XSUB_RE
/*
 - pregexec - match a regexp against a string
 */
I32
Perl_pregexec(pTHX_ REGEXP * const prog, char* stringarg, char *strend,
	 char *strbeg, SSize_t minend, SV *screamer, U32 nosave)
/* stringarg: the point in the string at which to begin matching */
/* strend:    pointer to null at end of string */
/* strbeg:    real beginning of string */
/* minend:    end of match must be >= minend bytes after stringarg. */
/* screamer:  SV being matched: only used for utf8 flag, pos() etc; string
 *            itself is accessed via the pointers above */
/* nosave:    For optimizations. */
{
    PERL_ARGS_ASSERT_PREGEXEC;

    return
	regexec_flags(prog, stringarg, strend, strbeg, minend, screamer, NULL,
		      nosave ? 0 : REXEC_COPY_STR);
}
#endif



/* re_intuit_start():
 *
 * Based on some optimiser hints, try to find the earliest position in the
 * string where the regex could match.
 *
 *   rx:     the regex to match against
 *   sv:     the SV being matched: only used for utf8 flag; the string
 *           itself is accessed via the pointers below. Note that on
 *           something like an overloaded SV, SvPOK(sv) may be false
 *           and the string pointers may point to something unrelated to
 *           the SV itself.
 *   strbeg: real beginning of string
 *   strpos: the point in the string at which to begin matching
 *   strend: pointer to the byte following the last char of the string
 *   flags   currently unused; set to 0
 *   data:   currently unused; set to NULL
 *
 * The basic idea of re_intuit_start() is to use some known information
 * about the pattern, namely:
 *
 *   a) the longest known anchored substring (i.e. one that's at a
 *      constant offset from the beginning of the pattern; but not
 *      necessarily at a fixed offset from the beginning of the
 *      string);
 *   b) the longest floating substring (i.e. one that's not at a constant
 *      offset from the beginning of the pattern);
 *   c) Whether the pattern is anchored to the string; either
 *      an absolute anchor: /^../, or anchored to \n: /^.../m,
 *      or anchored to pos(): /\G/;
 *   d) A start class: a real or synthetic character class which
 *      represents which characters are legal at the start of the pattern;
 *
 * to either quickly reject the match, or to find the earliest position
 * within the string at which the pattern might match, thus avoiding
 * running the full NFA engine at those earlier locations, only to
 * eventually fail and retry further along.
 *
 * Returns NULL if the pattern can't match, or returns the address within
 * the string which is the earliest place the match could occur.
 *
 * The longest of the anchored and floating substrings is called 'check'
 * and is checked first. The other is called 'other' and is checked
 * second. The 'other' substring may not be present.  For example,
 *
 *    /(abc|xyz)ABC\d{0,3}DEFG/
 *
 * will have
 *
 *   check substr (float)    = "DEFG", offset 6..9 chars
 *   other substr (anchored) = "ABC",  offset 3..3 chars
 *   stclass = [ax]
 *
 * Be aware that during the course of this function, sometimes 'anchored'
 * refers to a substring being anchored relative to the start of the
 * pattern, and sometimes to the pattern itself being anchored relative to
 * the string. For example:
 *
 *   /\dabc/:   "abc" is anchored to the pattern;
 *   /^\dabc/:  "abc" is anchored to the pattern and the string;
 *   /\d+abc/:  "abc" is anchored to neither the pattern nor the string;
 *   /^\d+abc/: "abc" is anchored to neither the pattern nor the string,
 *                    but the pattern is anchored to the string.
 */

char *
Perl_re_intuit_start(pTHX_
                    REGEXP * const rx,
                    SV *sv,
                    const char * const strbeg,
                    char *strpos,
                    char *strend,
                    const U32 flags,
                    re_scream_pos_data *data)
{
    struct regexp *const prog = ReANY(rx);
    SSize_t start_shift = prog->check_offset_min;
    /* Should be nonnegative! */
    SSize_t end_shift   = 0;
    /* current lowest pos in string where the regex can start matching */
    char *rx_origin = strpos;
    SV *check;
    const bool utf8_target = (sv && SvUTF8(sv)) ? 1 : 0; /* if no sv we have to assume bytes */
    U8   other_ix = 1 - prog->substrs->check_ix;
    bool ml_anch = 0;
    char *other_last = strpos;/* latest pos 'other' substr already checked to */
    char *check_at = NULL;		/* check substr found at this pos */
    const I32 multiline = prog->extflags & RXf_PMf_MULTILINE;
    RXi_GET_DECL(prog,progi);
    regmatch_info reginfo_buf;  /* create some info to pass to find_byclass */
    regmatch_info *const reginfo = &reginfo_buf;
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_RE_INTUIT_START;
    PERL_UNUSED_ARG(flags);
    PERL_UNUSED_ARG(data);

    DEBUG_EXECUTE_r(Perl_re_printf( aTHX_
                "Intuit: trying to determine minimum start position...\n"));

    /* for now, assume that all substr offsets are positive. If at some point
     * in the future someone wants to do clever things with lookbehind and
     * -ve offsets, they'll need to fix up any code in this function
     * which uses these offsets. See the thread beginning
     * <20140113145929.GF27210@@iabyn.com>
     */
    assert(prog->substrs->data[0].min_offset >= 0);
    assert(prog->substrs->data[0].max_offset >= 0);
    assert(prog->substrs->data[1].min_offset >= 0);
    assert(prog->substrs->data[1].max_offset >= 0);
    assert(prog->substrs->data[2].min_offset >= 0);
    assert(prog->substrs->data[2].max_offset >= 0);

    /* for now, assume that if both present, that the floating substring
     * doesn't start before the anchored substring.
     * If you break this assumption (e.g. doing better optimisations
     * with lookahead/behind), then you'll need to audit the code in this
     * function carefully first
     */
    assert(
            ! (  (prog->anchored_utf8 || prog->anchored_substr)
              && (prog->float_utf8    || prog->float_substr))
           || (prog->float_min_offset >= prog->anchored_offset));

    /* byte rather than char calculation for efficiency. It fails
     * to quickly reject some cases that can't match, but will reject
     * them later after doing full char arithmetic */
    if (prog->minlen > strend - strpos) {
        DEBUG_EXECUTE_r(Perl_re_printf( aTHX_
			      "  String too short...\n"));
	goto fail;
    }

    RX_MATCH_UTF8_set(rx,utf8_target);
    reginfo->is_utf8_target = cBOOL(utf8_target);
    reginfo->info_aux = NULL;
    reginfo->strbeg = strbeg;
    reginfo->strend = strend;
    reginfo->is_utf8_pat = cBOOL(RX_UTF8(rx));
    reginfo->intuit = 1;
    /* not actually used within intuit, but zero for safety anyway */
    reginfo->poscache_maxiter = 0;

    if (utf8_target) {
	if (!prog->check_utf8 && prog->check_substr)
	    to_utf8_substr(prog);
	check = prog->check_utf8;
    } else {
	if (!prog->check_substr && prog->check_utf8) {
	    if (! to_byte_substr(prog)) {
                NON_UTF8_TARGET_BUT_UTF8_REQUIRED(fail);
            }
        }
	check = prog->check_substr;
    }

    /* dump the various substring data */
    DEBUG_OPTIMISE_MORE_r({
        int i;
        for (i=0; i<=2; i++) {
            SV *sv = (utf8_target ? prog->substrs->data[i].utf8_substr
                                  : prog->substrs->data[i].substr);
            if (!sv)
                continue;

            Perl_re_printf( aTHX_
                "  substrs[%d]: min=%"IVdf" max=%"IVdf" end shift=%"IVdf
                " useful=%"IVdf" utf8=%d [%s]\n",
                i,
                (IV)prog->substrs->data[i].min_offset,
                (IV)prog->substrs->data[i].max_offset,
                (IV)prog->substrs->data[i].end_shift,
                BmUSEFUL(sv),
                utf8_target ? 1 : 0,
                SvPEEK(sv));
        }
    });

    if (prog->intflags & PREGf_ANCH) { /* Match at \G, beg-of-str or after \n */

        /* ml_anch: check after \n?
         *
         * A note about PREGf_IMPLICIT: on an un-anchored pattern beginning
         * with /.*.../, these flags will have been added by the
         * compiler:
         *   /.*abc/, /.*abc/m:  PREGf_IMPLICIT | PREGf_ANCH_MBOL
         *   /.*abc/s:           PREGf_IMPLICIT | PREGf_ANCH_SBOL
         */
	ml_anch =      (prog->intflags & PREGf_ANCH_MBOL)
                   && !(prog->intflags & PREGf_IMPLICIT);

	if (!ml_anch && !(prog->intflags & PREGf_IMPLICIT)) {
            /* we are only allowed to match at BOS or \G */

            /* trivially reject if there's a BOS anchor and we're not at BOS.
             *
             * Note that we don't try to do a similar quick reject for
             * \G, since generally the caller will have calculated strpos
             * based on pos() and gofs, so the string is already correctly
             * anchored by definition; and handling the exceptions would
             * be too fiddly (e.g. REXEC_IGNOREPOS).
             */
            if (   strpos != strbeg
                && (prog->intflags & PREGf_ANCH_SBOL))
            {
                DEBUG_EXECUTE_r(Perl_re_printf( aTHX_
                                "  Not at start...\n"));
	        goto fail;
	    }

            /* in the presence of an anchor, the anchored (relative to the
             * start of the regex) substr must also be anchored relative
             * to strpos. So quickly reject if substr isn't found there.
             * This works for \G too, because the caller will already have
             * subtracted gofs from pos, and gofs is the offset from the
             * \G to the start of the regex. For example, in /.abc\Gdef/,
             * where substr="abcdef", pos()=3, gofs=4, offset_min=1:
             * caller will have set strpos=pos()-4; we look for the substr
             * at position pos()-4+1, which lines up with the "a" */

	    if (prog->check_offset_min == prog->check_offset_max) {
	        /* Substring at constant offset from beg-of-str... */
	        SSize_t slen = SvCUR(check);
                char *s = HOP3c(strpos, prog->check_offset_min, strend);
	    
                DEBUG_EXECUTE_r(Perl_re_printf( aTHX_
                    "  Looking for check substr at fixed offset %"IVdf"...\n",
                    (IV)prog->check_offset_min));

	        if (SvTAIL(check)) {
                    /* In this case, the regex is anchored at the end too.
                     * Unless it's a multiline match, the lengths must match
                     * exactly, give or take a \n.  NB: slen >= 1 since
                     * the last char of check is \n */
		    if (!multiline
                        && (   strend - s > slen
                            || strend - s < slen - 1
                            || (strend - s == slen && strend[-1] != '\n')))
                    {
                        DEBUG_EXECUTE_r(Perl_re_printf( aTHX_
                                            "  String too long...\n"));
                        goto fail_finish;
                    }
                    /* Now should match s[0..slen-2] */
                    slen--;
                }
                if (slen && (*SvPVX_const(check) != *s
                    || (slen > 1 && memNE(SvPVX_const(check), s, slen))))
                {
                    DEBUG_EXECUTE_r(Perl_re_printf( aTHX_
                                    "  String not equal...\n"));
                    goto fail_finish;
                }

                check_at = s;
                goto success_at_start;
	    }
	}
    }

    end_shift = prog->check_end_shift;

#ifdef DEBUGGING	/* 7/99: reports of failure (with the older version) */
    if (end_shift < 0)
	Perl_croak(aTHX_ "panic: end_shift: %"IVdf" pattern:\n%s\n ",
		   (IV)end_shift, RX_PRECOMP(prog));
#endif

  restart:
    
    /* This is the (re)entry point of the main loop in this function.
     * The goal of this loop is to:
     * 1) find the "check" substring in the region rx_origin..strend
     *    (adjusted by start_shift / end_shift). If not found, reject
     *    immediately.
     * 2) If it exists, look for the "other" substr too if defined; for
     *    example, if the check substr maps to the anchored substr, then
     *    check the floating substr, and vice-versa. If not found, go
     *    back to (1) with rx_origin suitably incremented.
     * 3) If we find an rx_origin position that doesn't contradict
     *    either of the substrings, then check the possible additional
     *    constraints on rx_origin of /^.../m or a known start class.
     *    If these fail, then depending on which constraints fail, jump
     *    back to here, or to various other re-entry points further along
     *    that skip some of the first steps.
     * 4) If we pass all those tests, update the BmUSEFUL() count on the
     *    substring. If the start position was determined to be at the
     *    beginning of the string  - so, not rejected, but not optimised,
     *    since we have to run regmatch from position 0 - decrement the
     *    BmUSEFUL() count. Otherwise increment it.
     */


    /* first, look for the 'check' substring */

    {
        U8* start_point;
        U8* end_point;

        DEBUG_OPTIMISE_MORE_r({
            Perl_re_printf( aTHX_
                "  At restart: rx_origin=%"IVdf" Check offset min: %"IVdf
                " Start shift: %"IVdf" End shift %"IVdf
                " Real end Shift: %"IVdf"\n",
                (IV)(rx_origin - strbeg),
                (IV)prog->check_offset_min,
                (IV)start_shift,
                (IV)end_shift,
                (IV)prog->check_end_shift);
        });
        
        end_point = HOP3(strend, -end_shift, strbeg);
        start_point = HOPMAYBE3(rx_origin, start_shift, end_point);
        if (!start_point)
            goto fail_finish;


        /* If the regex is absolutely anchored to either the start of the
         * string (SBOL) or to pos() (ANCH_GPOS), then
         * check_offset_max represents an upper bound on the string where
         * the substr could start. For the ANCH_GPOS case, we assume that
         * the caller of intuit will have already set strpos to
         * pos()-gofs, so in this case strpos + offset_max will still be
         * an upper bound on the substr.
         */
        if (!ml_anch
            && prog->intflags & PREGf_ANCH
            && prog->check_offset_max != SSize_t_MAX)
        {
            SSize_t len = SvCUR(check) - !!SvTAIL(check);
            const char * const anchor =
                        (prog->intflags & PREGf_ANCH_GPOS ? strpos : strbeg);

            /* do a bytes rather than chars comparison. It's conservative;
             * so it skips doing the HOP if the result can't possibly end
             * up earlier than the old value of end_point.
             */
            if ((char*)end_point - anchor > prog->check_offset_max) {
                end_point = HOP3lim((U8*)anchor,
                                prog->check_offset_max,
                                end_point -len)
                            + len;
            }
        }

	check_at = fbm_instr( start_point, end_point,
		      check, multiline ? FBMrf_MULTILINE : 0);

        DEBUG_EXECUTE_r(Perl_re_printf( aTHX_
            "  doing 'check' fbm scan, [%"IVdf"..%"IVdf"] gave %"IVdf"\n",
            (IV)((char*)start_point - strbeg),
            (IV)((char*)end_point   - strbeg),
            (IV)(check_at ? check_at - strbeg : -1)
        ));

        /* Update the count-of-usability, remove useless subpatterns,
            unshift s.  */

        DEBUG_EXECUTE_r({
            RE_PV_QUOTED_DECL(quoted, utf8_target, PERL_DEBUG_PAD_ZERO(0),
                SvPVX_const(check), RE_SV_DUMPLEN(check), 30);
            Perl_re_printf( aTHX_  "  %s %s substr %s%s%s",
                              (check_at ? "Found" : "Did not find"),
                (check == (utf8_target ? prog->anchored_utf8 : prog->anchored_substr)
                    ? "anchored" : "floating"),
                quoted,
                RE_SV_TAIL(check),
                (check_at ? " at offset " : "...\n") );
        });

        if (!check_at)
            goto fail_finish;
        /* set rx_origin to the minimum position where the regex could start
         * matching, given the constraint of the just-matched check substring.
         * But don't set it lower than previously.
         */

        if (check_at - rx_origin > prog->check_offset_max)
            rx_origin = HOP3c(check_at, -prog->check_offset_max, rx_origin);
        /* Finish the diagnostic message */
        DEBUG_EXECUTE_r(Perl_re_printf( aTHX_
            "%ld (rx_origin now %"IVdf")...\n",
            (long)(check_at - strbeg),
            (IV)(rx_origin - strbeg)
        ));
    }


    /* now look for the 'other' substring if defined */

    if (utf8_target ? prog->substrs->data[other_ix].utf8_substr
                    : prog->substrs->data[other_ix].substr)
    {
	/* Take into account the "other" substring. */
        char *last, *last1;
        char *s;
        SV* must;
        struct reg_substr_datum *other;

      do_other_substr:
        other = &prog->substrs->data[other_ix];

        /* if "other" is anchored:
         * we've previously found a floating substr starting at check_at.
         * This means that the regex origin must lie somewhere
         * between min (rx_origin): HOP3(check_at, -check_offset_max)
         * and max:                 HOP3(check_at, -check_offset_min)
         * (except that min will be >= strpos)
         * So the fixed  substr must lie somewhere between
         *  HOP3(min, anchored_offset)
         *  HOP3(max, anchored_offset) + SvCUR(substr)
         */

        /* if "other" is floating
         * Calculate last1, the absolute latest point where the
         * floating substr could start in the string, ignoring any
         * constraints from the earlier fixed match. It is calculated
         * as follows:
         *
         * strend - prog->minlen (in chars) is the absolute latest
         * position within the string where the origin of the regex
         * could appear. The latest start point for the floating
         * substr is float_min_offset(*) on from the start of the
         * regex.  last1 simply combines thee two offsets.
         *
         * (*) You might think the latest start point should be
         * float_max_offset from the regex origin, and technically
         * you'd be correct. However, consider
         *    /a\d{2,4}bcd\w/
         * Here, float min, max are 3,5 and minlen is 7.
         * This can match either
         *    /a\d\dbcd\w/
         *    /a\d\d\dbcd\w/
         *    /a\d\d\d\dbcd\w/
         * In the first case, the regex matches minlen chars; in the
         * second, minlen+1, in the third, minlen+2.
         * In the first case, the floating offset is 3 (which equals
         * float_min), in the second, 4, and in the third, 5 (which
         * equals float_max). In all cases, the floating string bcd
         * can never start more than 4 chars from the end of the
         * string, which equals minlen - float_min. As the substring
         * starts to match more than float_min from the start of the
         * regex, it makes the regex match more than minlen chars,
         * and the two cancel each other out. So we can always use
         * float_min - minlen, rather than float_max - minlen for the
         * latest position in the string.
         *
         * Note that -minlen + float_min_offset is equivalent (AFAIKT)
         * to CHR_SVLEN(must) - !!SvTAIL(must) + prog->float_end_shift
         */

        assert(prog->minlen >= other->min_offset);
        last1 = HOP3c(strend,
                        other->min_offset - prog->minlen, strbeg);

        if (other_ix) {/* i.e. if (other-is-float) */
            /* last is the latest point where the floating substr could
             * start, *given* any constraints from the earlier fixed
             * match. This constraint is that the floating string starts
             * <= float_max_offset chars from the regex origin (rx_origin).
             * If this value is less than last1, use it instead.
             */
            assert(rx_origin <= last1);
            last =
                /* this condition handles the offset==infinity case, and
                 * is a short-cut otherwise. Although it's comparing a
                 * byte offset to a char length, it does so in a safe way,
                 * since 1 char always occupies 1 or more bytes,
                 * so if a string range is  (last1 - rx_origin) bytes,
                 * it will be less than or equal to  (last1 - rx_origin)
                 * chars; meaning it errs towards doing the accurate HOP3
                 * rather than just using last1 as a short-cut */
                (last1 - rx_origin) < other->max_offset
                    ? last1
                    : (char*)HOP3lim(rx_origin, other->max_offset, last1);
        }
        else {
            assert(strpos + start_shift <= check_at);
            last = HOP4c(check_at, other->min_offset - start_shift,
                        strbeg, strend);
        }

        s = HOP3c(rx_origin, other->min_offset, strend);
        if (s < other_last)	/* These positions already checked */
            s = other_last;

        must = utf8_target ? other->utf8_substr : other->substr;
        assert(SvPOK(must));
        {
            char *from = s;
            char *to   = last + SvCUR(must) - (SvTAIL(must)!=0);

            if (from > to) {
                s = NULL;
                DEBUG_EXECUTE_r(Perl_re_printf( aTHX_
                    "  skipping 'other' fbm scan: %"IVdf" > %"IVdf"\n",
                    (IV)(from - strbeg),
                    (IV)(to   - strbeg)
                ));
            }
            else {
                s = fbm_instr(
                    (unsigned char*)from,
                    (unsigned char*)to,
                    must,
                    multiline ? FBMrf_MULTILINE : 0
                );
                DEBUG_EXECUTE_r(Perl_re_printf( aTHX_
                    "  doing 'other' fbm scan, [%"IVdf"..%"IVdf"] gave %"IVdf"\n",
                    (IV)(from - strbeg),
                    (IV)(to   - strbeg),
                    (IV)(s ? s - strbeg : -1)
                ));
            }
        }

        DEBUG_EXECUTE_r({
            RE_PV_QUOTED_DECL(quoted, utf8_target, PERL_DEBUG_PAD_ZERO(0),
                SvPVX_const(must), RE_SV_DUMPLEN(must), 30);
            Perl_re_printf( aTHX_  "  %s %s substr %s%s",
                s ? "Found" : "Contradicts",
                other_ix ? "floating" : "anchored",
                quoted, RE_SV_TAIL(must));
        });


        if (!s) {
            /* last1 is latest possible substr location. If we didn't
             * find it before there, we never will */
            if (last >= last1) {
                DEBUG_EXECUTE_r(Perl_re_printf( aTHX_
                                        "; giving up...\n"));
                goto fail_finish;
            }

            /* try to find the check substr again at a later
             * position. Maybe next time we'll find the "other" substr
             * in range too */
            other_last = HOP3c(last, 1, strend) /* highest failure */;
            rx_origin =
                other_ix /* i.e. if other-is-float */
                    ? HOP3c(rx_origin, 1, strend)
                    : HOP4c(last, 1 - other->min_offset, strbeg, strend);
            DEBUG_EXECUTE_r(Perl_re_printf( aTHX_
                "; about to retry %s at offset %ld (rx_origin now %"IVdf")...\n",
                (other_ix ? "floating" : "anchored"),
                (long)(HOP3c(check_at, 1, strend) - strbeg),
                (IV)(rx_origin - strbeg)
            ));
            goto restart;
        }
        else {
            if (other_ix) { /* if (other-is-float) */
                /* other_last is set to s, not s+1, since its possible for
                 * a floating substr to fail first time, then succeed
                 * second time at the same floating position; e.g.:
                 *     "-AB--AABZ" =~ /\wAB\d*Z/
                 * The first time round, anchored and float match at
                 * "-(AB)--AAB(Z)" then fail on the initial \w character
                 * class. Second time round, they match at "-AB--A(AB)(Z)".
                 */
                other_last = s;
            }
            else {
                rx_origin = HOP3c(s, -other->min_offset, strbeg);
                other_last = HOP3c(s, 1, strend);
            }
            DEBUG_EXECUTE_r(Perl_re_printf( aTHX_
                " at offset %ld (rx_origin now %"IVdf")...\n",
                  (long)(s - strbeg),
                (IV)(rx_origin - strbeg)
              ));

        }
    }
    else {
        DEBUG_OPTIMISE_MORE_r(
            Perl_re_printf( aTHX_
                "  Check-only match: offset min:%"IVdf" max:%"IVdf
                " check_at:%"IVdf" rx_origin:%"IVdf" rx_origin-check_at:%"IVdf
                " strend:%"IVdf"\n",
                (IV)prog->check_offset_min,
                (IV)prog->check_offset_max,
                (IV)(check_at-strbeg),
                (IV)(rx_origin-strbeg),
                (IV)(rx_origin-check_at),
                (IV)(strend-strbeg)
            )
        );
    }

  postprocess_substr_matches:

    /* handle the extra constraint of /^.../m if present */

    if (ml_anch && rx_origin != strbeg && rx_origin[-1] != '\n') {
        char *s;

        DEBUG_EXECUTE_r(Perl_re_printf( aTHX_
                        "  looking for /^/m anchor"));

        /* we have failed the constraint of a \n before rx_origin.
         * Find the next \n, if any, even if it's beyond the current
         * anchored and/or floating substrings. Whether we should be
         * scanning ahead for the next \n or the next substr is debatable.
         * On the one hand you'd expect rare substrings to appear less
         * often than \n's. On the other hand, searching for \n means
         * we're effectively flipping between check_substr and "\n" on each
         * iteration as the current "rarest" string candidate, which
         * means for example that we'll quickly reject the whole string if
         * hasn't got a \n, rather than trying every substr position
         * first
         */

        s = HOP3c(strend, - prog->minlen, strpos);
        if (s <= rx_origin ||
            ! ( rx_origin = (char *)memchr(rx_origin, '\n', s - rx_origin)))
        {
            DEBUG_EXECUTE_r(Perl_re_printf( aTHX_
                            "  Did not find /%s^%s/m...\n",
                            PL_colors[0], PL_colors[1]));
            goto fail_finish;
        }

        /* earliest possible origin is 1 char after the \n.
         * (since *rx_origin == '\n', it's safe to ++ here rather than
         * HOP(rx_origin, 1)) */
        rx_origin++;

        if (prog->substrs->check_ix == 0  /* check is anchored */
            || rx_origin >= HOP3c(check_at,  - prog->check_offset_min, strpos))
        {
            /* Position contradicts check-string; either because
             * check was anchored (and thus has no wiggle room),
             * or check was float and rx_origin is above the float range */
            DEBUG_EXECUTE_r(Perl_re_printf( aTHX_
                "  Found /%s^%s/m, about to restart lookup for check-string with rx_origin %ld...\n",
                PL_colors[0], PL_colors[1], (long)(rx_origin - strbeg)));
            goto restart;
        }

        /* if we get here, the check substr must have been float,
         * is in range, and we may or may not have had an anchored
         * "other" substr which still contradicts */
        assert(prog->substrs->check_ix); /* check is float */

        if (utf8_target ? prog->anchored_utf8 : prog->anchored_substr) {
            /* whoops, the anchored "other" substr exists, so we still
             * contradict. On the other hand, the float "check" substr
             * didn't contradict, so just retry the anchored "other"
             * substr */
            DEBUG_EXECUTE_r(Perl_re_printf( aTHX_
                "  Found /%s^%s/m, rescanning for anchored from offset %"IVdf" (rx_origin now %"IVdf")...\n",
                PL_colors[0], PL_colors[1],
                (IV)(rx_origin - strbeg + prog->anchored_offset),
                (IV)(rx_origin - strbeg)
            ));
            goto do_other_substr;
        }

        /* success: we don't contradict the found floating substring
         * (and there's no anchored substr). */
        DEBUG_EXECUTE_r(Perl_re_printf( aTHX_
            "  Found /%s^%s/m with rx_origin %ld...\n",
            PL_colors[0], PL_colors[1], (long)(rx_origin - strbeg)));
    }
    else {
        DEBUG_EXECUTE_r(Perl_re_printf( aTHX_
            "  (multiline anchor test skipped)\n"));
    }

  success_at_start:


    /* if we have a starting character class, then test that extra constraint.
     * (trie stclasses are too expensive to use here, we are better off to
     * leave it to regmatch itself) */

    if (progi->regstclass && PL_regkind[OP(progi->regstclass)]!=TRIE) {
        const U8* const str = (U8*)STRING(progi->regstclass);

        /* XXX this value could be pre-computed */
        const int cl_l = (PL_regkind[OP(progi->regstclass)] == EXACT
		    ?  (reginfo->is_utf8_pat
                        ? utf8_distance(str + STR_LEN(progi->regstclass), str)
                        : STR_LEN(progi->regstclass))
		    : 1);
	char * endpos;
        char *s;
        /* latest pos that a matching float substr constrains rx start to */
        char *rx_max_float = NULL;

        /* if the current rx_origin is anchored, either by satisfying an
         * anchored substring constraint, or a /^.../m constraint, then we
         * can reject the current origin if the start class isn't found
         * at the current position. If we have a float-only match, then
         * rx_origin is constrained to a range; so look for the start class
         * in that range. if neither, then look for the start class in the
         * whole rest of the string */

        /* XXX DAPM it's not clear what the minlen test is for, and why
         * it's not used in the floating case. Nothing in the test suite
         * causes minlen == 0 here. See <20140313134639.GS12844@@iabyn.com>.
         * Here are some old comments, which may or may not be correct:
         *
	 *   minlen == 0 is possible if regstclass is \b or \B,
	 *   and the fixed substr is ''$.
         *   Since minlen is already taken into account, rx_origin+1 is
         *   before strend; accidentally, minlen >= 1 guaranties no false
         *   positives at rx_origin + 1 even for \b or \B.  But (minlen? 1 :
         *   0) below assumes that regstclass does not come from lookahead...
	 *   If regstclass takes bytelength more than 1: If charlength==1, OK.
         *   This leaves EXACTF-ish only, which are dealt with in
         *   find_byclass().
         */

	if (prog->anchored_substr || prog->anchored_utf8 || ml_anch)
            endpos= HOP3c(rx_origin, (prog->minlen ? cl_l : 0), strend);
        else if (prog->float_substr || prog->float_utf8) {
	    rx_max_float = HOP3c(check_at, -start_shift, strbeg);
	    endpos= HOP3c(rx_max_float, cl_l, strend);
        }
        else 
            endpos= strend;
		    
        DEBUG_EXECUTE_r(Perl_re_printf( aTHX_
            "  looking for class: start_shift: %"IVdf" check_at: %"IVdf
            " rx_origin: %"IVdf" endpos: %"IVdf"\n",
              (IV)start_shift, (IV)(check_at - strbeg),
              (IV)(rx_origin - strbeg), (IV)(endpos - strbeg)));

        s = find_byclass(prog, progi->regstclass, rx_origin, endpos,
                            reginfo);
	if (!s) {
	    if (endpos == strend) {
                DEBUG_EXECUTE_r( Perl_re_printf( aTHX_
				"  Could not match STCLASS...\n") );
		goto fail;
	    }
            DEBUG_EXECUTE_r( Perl_re_printf( aTHX_
                               "  This position contradicts STCLASS...\n") );
            if ((prog->intflags & PREGf_ANCH) && !ml_anch
                        && !(prog->intflags & PREGf_IMPLICIT))
		goto fail;

	    /* Contradict one of substrings */
	    if (prog->anchored_substr || prog->anchored_utf8) {
                if (prog->substrs->check_ix == 1) { /* check is float */
                    /* Have both, check_string is floating */
                    assert(rx_origin + start_shift <= check_at);
                    if (rx_origin + start_shift != check_at) {
                        /* not at latest position float substr could match:
                         * Recheck anchored substring, but not floating.
                         * The condition above is in bytes rather than
                         * chars for efficiency. It's conservative, in
                         * that it errs on the side of doing 'goto
                         * do_other_substr'. In this case, at worst,
                         * an extra anchored search may get done, but in
                         * practice the extra fbm_instr() is likely to
                         * get skipped anyway. */
                        DEBUG_EXECUTE_r( Perl_re_printf( aTHX_
                            "  about to retry anchored at offset %ld (rx_origin now %"IVdf")...\n",
                            (long)(other_last - strbeg),
                            (IV)(rx_origin - strbeg)
                        ));
                        goto do_other_substr;
                    }
                }
            }
	    else {
                /* float-only */

                if (ml_anch) {
                    /* In the presence of ml_anch, we might be able to
                     * find another \n without breaking the current float
                     * constraint. */

                    /* strictly speaking this should be HOP3c(..., 1, ...),
                     * but since we goto a block of code that's going to
                     * search for the next \n if any, its safe here */
                    rx_origin++;
                    DEBUG_EXECUTE_r( Perl_re_printf( aTHX_
                              "  about to look for /%s^%s/m starting at rx_origin %ld...\n",
                              PL_colors[0], PL_colors[1],
                              (long)(rx_origin - strbeg)) );
                    goto postprocess_substr_matches;
                }

                /* strictly speaking this can never be true; but might
                 * be if we ever allow intuit without substrings */
                if (!(utf8_target ? prog->float_utf8 : prog->float_substr))
                    goto fail;

                rx_origin = rx_max_float;
            }

            /* at this point, any matching substrings have been
             * contradicted. Start again... */

            rx_origin = HOP3c(rx_origin, 1, strend);

            /* uses bytes rather than char calculations for efficiency.
             * It's conservative: it errs on the side of doing 'goto restart',
             * where there is code that does a proper char-based test */
            if (rx_origin + start_shift + end_shift > strend) {
                DEBUG_EXECUTE_r( Perl_re_printf( aTHX_
                                       "  Could not match STCLASS...\n") );
                goto fail;
            }
            DEBUG_EXECUTE_r( Perl_re_printf( aTHX_
                "  about to look for %s substr starting at offset %ld (rx_origin now %"IVdf")...\n",
                (prog->substrs->check_ix ? "floating" : "anchored"),
                (long)(rx_origin + start_shift - strbeg),
                (IV)(rx_origin - strbeg)
            ));
            goto restart;
	}

        /* Success !!! */

	if (rx_origin != s) {
            DEBUG_EXECUTE_r(Perl_re_printf( aTHX_
			"  By STCLASS: moving %ld --> %ld\n",
                                  (long)(rx_origin - strbeg), (long)(s - strbeg))
                   );
        }
        else {
            DEBUG_EXECUTE_r(Perl_re_printf( aTHX_
                                  "  Does not contradict STCLASS...\n");
                   );
        }
    }

    /* Decide whether using the substrings helped */

    if (rx_origin != strpos) {
	/* Fixed substring is found far enough so that the match
	   cannot start at strpos. */

        DEBUG_EXECUTE_r(Perl_re_printf( aTHX_  "  try at offset...\n"));
	++BmUSEFUL(utf8_target ? prog->check_utf8 : prog->check_substr);	/* hooray/5 */
    }
    else {
        /* The found rx_origin position does not prohibit matching at
         * strpos, so calling intuit didn't gain us anything. Decrement
         * the BmUSEFUL() count on the check substring, and if we reach
         * zero, free it.  */
	if (!(prog->intflags & PREGf_NAUGHTY)
	    && (utf8_target ? (
		prog->check_utf8		/* Could be deleted already */
		&& --BmUSEFUL(prog->check_utf8) < 0
		&& (prog->check_utf8 == prog->float_utf8)
	    ) : (
		prog->check_substr		/* Could be deleted already */
		&& --BmUSEFUL(prog->check_substr) < 0
		&& (prog->check_substr == prog->float_substr)
	    )))
	{
	    /* If flags & SOMETHING - do not do it many times on the same match */
            DEBUG_EXECUTE_r(Perl_re_printf( aTHX_  "  ... Disabling check substring...\n"));
	    /* XXX Does the destruction order has to change with utf8_target? */
	    SvREFCNT_dec(utf8_target ? prog->check_utf8 : prog->check_substr);
	    SvREFCNT_dec(utf8_target ? prog->check_substr : prog->check_utf8);
	    prog->check_substr = prog->check_utf8 = NULL;	/* disable */
	    prog->float_substr = prog->float_utf8 = NULL;	/* clear */
	    check = NULL;			/* abort */
	    /* XXXX This is a remnant of the old implementation.  It
	            looks wasteful, since now INTUIT can use many
	            other heuristics. */
	    prog->extflags &= ~RXf_USE_INTUIT;
	}
    }

    DEBUG_EXECUTE_r(Perl_re_printf( aTHX_
            "Intuit: %sSuccessfully guessed:%s match at offset %ld\n",
             PL_colors[4], PL_colors[5], (long)(rx_origin - strbeg)) );

    return rx_origin;

  fail_finish:				/* Substring not found */
    if (prog->check_substr || prog->check_utf8)		/* could be removed already */
	BmUSEFUL(utf8_target ? prog->check_utf8 : prog->check_substr) += 5; /* hooray */
  fail:
    DEBUG_EXECUTE_r(Perl_re_printf( aTHX_  "%sMatch rejected by optimizer%s\n",
			  PL_colors[4], PL_colors[5]));
    return NULL;
}


#define DECL_TRIE_TYPE(scan) \
    const enum { trie_plain, trie_utf8, trie_utf8_fold, trie_latin_utf8_fold,       \
                 trie_utf8_exactfa_fold, trie_latin_utf8_exactfa_fold,              \
                 trie_utf8l, trie_flu8 }                                            \
                    trie_type = ((scan->flags == EXACT)                             \
                                 ? (utf8_target ? trie_utf8 : trie_plain)           \
                                 : (scan->flags == EXACTL)                          \
                                    ? (utf8_target ? trie_utf8l : trie_plain)       \
                                    : (scan->flags == EXACTFA)                      \
                                      ? (utf8_target                                \
                                         ? trie_utf8_exactfa_fold                   \
                                         : trie_latin_utf8_exactfa_fold)            \
                                      : (scan->flags == EXACTFLU8                   \
                                         ? trie_flu8                                \
                                         : (utf8_target                             \
                                           ? trie_utf8_fold                         \
                                           :   trie_latin_utf8_fold)))

#define REXEC_TRIE_READ_CHAR(trie_type, trie, widecharmap, uc, uscan, len, uvc, charid, foldlen, foldbuf, uniflags) \
STMT_START {                                                                        \
    STRLEN skiplen;                                                                 \
    U8 flags = FOLD_FLAGS_FULL;                                                     \
    switch (trie_type) {                                                            \
    case trie_flu8:                                                                 \
        _CHECK_AND_WARN_PROBLEMATIC_LOCALE;                                         \
        if (utf8_target && UTF8_IS_ABOVE_LATIN1(*uc)) {                             \
            _CHECK_AND_OUTPUT_WIDE_LOCALE_UTF8_MSG(uc, uc + UTF8SKIP(uc));          \
        }                                                                           \
        goto do_trie_utf8_fold;                                                     \
    case trie_utf8_exactfa_fold:                                                    \
        flags |= FOLD_FLAGS_NOMIX_ASCII;                                            \
        /* FALLTHROUGH */                                                           \
    case trie_utf8_fold:                                                            \
      do_trie_utf8_fold:                                                            \
        if ( foldlen>0 ) {                                                          \
            uvc = utf8n_to_uvchr( (const U8*) uscan, UTF8_MAXLEN, &len, uniflags ); \
            foldlen -= len;                                                         \
            uscan += len;                                                           \
            len=0;                                                                  \
        } else {                                                                    \
            uvc = _to_utf8_fold_flags( (const U8*) uc, foldbuf, &foldlen, flags);   \
            len = UTF8SKIP(uc);                                                     \
            skiplen = UVCHR_SKIP( uvc );                                            \
            foldlen -= skiplen;                                                     \
            uscan = foldbuf + skiplen;                                              \
        }                                                                           \
        break;                                                                      \
    case trie_latin_utf8_exactfa_fold:                                              \
        flags |= FOLD_FLAGS_NOMIX_ASCII;                                            \
        /* FALLTHROUGH */                                                           \
    case trie_latin_utf8_fold:                                                      \
        if ( foldlen>0 ) {                                                          \
            uvc = utf8n_to_uvchr( (const U8*) uscan, UTF8_MAXLEN, &len, uniflags ); \
            foldlen -= len;                                                         \
            uscan += len;                                                           \
            len=0;                                                                  \
        } else {                                                                    \
            len = 1;                                                                \
            uvc = _to_fold_latin1( (U8) *uc, foldbuf, &foldlen, flags);             \
            skiplen = UVCHR_SKIP( uvc );                                            \
            foldlen -= skiplen;                                                     \
            uscan = foldbuf + skiplen;                                              \
        }                                                                           \
        break;                                                                      \
    case trie_utf8l:                                                                \
        _CHECK_AND_WARN_PROBLEMATIC_LOCALE;                                         \
        if (utf8_target && UTF8_IS_ABOVE_LATIN1(*uc)) {                             \
            _CHECK_AND_OUTPUT_WIDE_LOCALE_UTF8_MSG(uc, uc + UTF8SKIP(uc));          \
        }                                                                           \
        /* FALLTHROUGH */                                                           \
    case trie_utf8:                                                                 \
        uvc = utf8n_to_uvchr( (const U8*) uc, UTF8_MAXLEN, &len, uniflags );        \
        break;                                                                      \
    case trie_plain:                                                                \
        uvc = (UV)*uc;                                                              \
        len = 1;                                                                    \
    }                                                                               \
    if (uvc < 256) {                                                                \
        charid = trie->charmap[ uvc ];                                              \
    }                                                                               \
    else {                                                                          \
        charid = 0;                                                                 \
        if (widecharmap) {                                                          \
            SV** const svpp = hv_fetch(widecharmap,                                 \
                        (char*)&uvc, sizeof(UV), 0);                                \
            if (svpp)                                                               \
                charid = (U16)SvIV(*svpp);                                          \
        }                                                                           \
    }                                                                               \
} STMT_END

#define DUMP_EXEC_POS(li,s,doutf8,depth)                    \
    dump_exec_pos(li,s,(reginfo->strend),(reginfo->strbeg), \
                startpos, doutf8, depth)

#define REXEC_FBC_EXACTISH_SCAN(COND)                     \
STMT_START {                                              \
    while (s <= e) {                                      \
	if ( (COND)                                       \
	     && (ln == 1 || folder(s, pat_string, ln))    \
	     && (reginfo->intuit || regtry(reginfo, &s)) )\
	    goto got_it;                                  \
	s++;                                              \
    }                                                     \
} STMT_END

#define REXEC_FBC_UTF8_SCAN(CODE)                     \
STMT_START {                                          \
    while (s < strend) {                              \
	CODE                                          \
	s += UTF8SKIP(s);                             \
    }                                                 \
} STMT_END

#define REXEC_FBC_SCAN(CODE)                          \
STMT_START {                                          \
    while (s < strend) {                              \
	CODE                                          \
	s++;                                          \
    }                                                 \
} STMT_END

#define REXEC_FBC_UTF8_CLASS_SCAN(COND)                        \
REXEC_FBC_UTF8_SCAN( /* Loops while (s < strend) */            \
    if (COND) {                                                \
	if (tmp && (reginfo->intuit || regtry(reginfo, &s)))   \
	    goto got_it;                                       \
	else                                                   \
	    tmp = doevery;                                     \
    }                                                          \
    else                                                       \
	tmp = 1;                                               \
)

#define REXEC_FBC_CLASS_SCAN(COND)                             \
REXEC_FBC_SCAN( /* Loops while (s < strend) */                 \
    if (COND) {                                                \
	if (tmp && (reginfo->intuit || regtry(reginfo, &s)))   \
	    goto got_it;                                       \
	else                                                   \
	    tmp = doevery;                                     \
    }                                                          \
    else                                                       \
	tmp = 1;                                               \
)

#define REXEC_FBC_CSCAN(CONDUTF8,COND)                         \
    if (utf8_target) {                                         \
	REXEC_FBC_UTF8_CLASS_SCAN(CONDUTF8);                   \
    }                                                          \
    else {                                                     \
	REXEC_FBC_CLASS_SCAN(COND);                            \
    }

/* The three macros below are slightly different versions of the same logic.
 *
 * The first is for /a and /aa when the target string is UTF-8.  This can only
 * match ascii, but it must advance based on UTF-8.   The other two handle the
 * non-UTF-8 and the more generic UTF-8 cases.   In all three, we are looking
 * for the boundary (or non-boundary) between a word and non-word character.
 * The utf8 and non-utf8 cases have the same logic, but the details must be
 * different.  Find the "wordness" of the character just prior to this one, and
 * compare it with the wordness of this one.  If they differ, we have a
 * boundary.  At the beginning of the string, pretend that the previous
 * character was a new-line.
 *
 * All these macros uncleanly have side-effects with each other and outside
 * variables.  So far it's been too much trouble to clean-up
 *
 * TEST_NON_UTF8 is the macro or function to call to test if its byte input is
 *               a word character or not.
 * IF_SUCCESS    is code to do if it finds that we are at a boundary between
 *               word/non-word
 * IF_FAIL       is code to do if we aren't at a boundary between word/non-word
 *
 * Exactly one of the two IF_FOO parameters is a no-op, depending on whether we
 * are looking for a boundary or for a non-boundary.  If we are looking for a
 * boundary, we want IF_FAIL to be the no-op, and for IF_SUCCESS to go out and
 * see if this tentative match actually works, and if so, to quit the loop
 * here.  And vice-versa if we are looking for a non-boundary.
 *
 * 'tmp' below in the next three macros in the REXEC_FBC_SCAN and
 * REXEC_FBC_UTF8_SCAN loops is a loop invariant, a bool giving the return of
 * TEST_NON_UTF8(s-1).  To see this, note that that's what it is defined to be
 * at entry to the loop, and to get to the IF_FAIL branch, tmp must equal
 * TEST_NON_UTF8(s), and in the opposite branch, IF_SUCCESS, tmp is that
 * complement.  But in that branch we complement tmp, meaning that at the
 * bottom of the loop tmp is always going to be equal to TEST_NON_UTF8(s),
 * which means at the top of the loop in the next iteration, it is
 * TEST_NON_UTF8(s-1) */
#define FBC_UTF8_A(TEST_NON_UTF8, IF_SUCCESS, IF_FAIL)                         \
    tmp = (s != reginfo->strbeg) ? UCHARAT(s - 1) : '\n';                      \
    tmp = TEST_NON_UTF8(tmp);                                                  \
    REXEC_FBC_UTF8_SCAN( /* advances s while s < strend */                     \
        if (tmp == ! TEST_NON_UTF8((U8) *s)) {                                 \
            tmp = !tmp;                                                        \
            IF_SUCCESS; /* Is a boundary if values for s-1 and s differ */     \
        }                                                                      \
        else {                                                                 \
            IF_FAIL;                                                           \
        }                                                                      \
    );                                                                         \

/* Like FBC_UTF8_A, but TEST_UV is a macro which takes a UV as its input, and
 * TEST_UTF8 is a macro that for the same input code points returns identically
 * to TEST_UV, but takes a pointer to a UTF-8 encoded string instead */
#define FBC_UTF8(TEST_UV, TEST_UTF8, IF_SUCCESS, IF_FAIL)                      \
    if (s == reginfo->strbeg) {                                                \
        tmp = '\n';                                                            \
    }                                                                          \
    else { /* Back-up to the start of the previous character */                \
        U8 * const r = reghop3((U8*)s, -1, (U8*)reginfo->strbeg);              \
        tmp = utf8n_to_uvchr(r, (U8*) reginfo->strend - r,                     \
                                                       0, UTF8_ALLOW_DEFAULT); \
    }                                                                          \
    tmp = TEST_UV(tmp);                                                        \
    LOAD_UTF8_CHARCLASS_ALNUM();                                               \
    REXEC_FBC_UTF8_SCAN( /* advances s while s < strend */                     \
        if (tmp == ! (TEST_UTF8((U8 *) s))) {                                  \
            tmp = !tmp;                                                        \
            IF_SUCCESS;                                                        \
        }                                                                      \
        else {                                                                 \
            IF_FAIL;                                                           \
        }                                                                      \
    );

/* Like the above two macros.  UTF8_CODE is the complete code for handling
 * UTF-8.  Common to the BOUND and NBOUND cases, set-up by the FBC_BOUND, etc
 * macros below */
#define FBC_BOUND_COMMON(UTF8_CODE, TEST_NON_UTF8, IF_SUCCESS, IF_FAIL)        \
    if (utf8_target) {                                                         \
        UTF8_CODE                                                              \
    }                                                                          \
    else {  /* Not utf8 */                                                     \
	tmp = (s != reginfo->strbeg) ? UCHARAT(s - 1) : '\n';                  \
	tmp = TEST_NON_UTF8(tmp);                                              \
	REXEC_FBC_SCAN( /* advances s while s < strend */                      \
	    if (tmp == ! TEST_NON_UTF8((U8) *s)) {                             \
		IF_SUCCESS;                                                    \
		tmp = !tmp;                                                    \
	    }                                                                  \
	    else {                                                             \
		IF_FAIL;                                                       \
	    }                                                                  \
	);                                                                     \
    }                                                                          \
    /* Here, things have been set up by the previous code so that tmp is the   \
     * return of TEST_NON_UTF(s-1) or TEST_UTF8(s-1) (depending on the         \
     * utf8ness of the target).  We also have to check if this matches against \
     * the EOS, which we treat as a \n (which is the same value in both UTF-8  \
     * or non-UTF8, so can use the non-utf8 test condition even for a UTF-8    \
     * string */                                                               \
    if (tmp == ! TEST_NON_UTF8('\n')) {                                        \
        IF_SUCCESS;                                                            \
    }                                                                          \
    else {                                                                     \
        IF_FAIL;                                                               \
    }

/* This is the macro to use when we want to see if something that looks like it
 * could match, actually does, and if so exits the loop */
#define REXEC_FBC_TRYIT                            \
    if ((reginfo->intuit || regtry(reginfo, &s)))  \
        goto got_it

/* The only difference between the BOUND and NBOUND cases is that
 * REXEC_FBC_TRYIT is called when matched in BOUND, and when non-matched in
 * NBOUND.  This is accomplished by passing it as either the if or else clause,
 * with the other one being empty (PLACEHOLDER is defined as empty).
 *
 * The TEST_FOO parameters are for operating on different forms of input, but
 * all should be ones that return identically for the same underlying code
 * points */
#define FBC_BOUND(TEST_NON_UTF8, TEST_UV, TEST_UTF8)                           \
    FBC_BOUND_COMMON(                                                          \
          FBC_UTF8(TEST_UV, TEST_UTF8, REXEC_FBC_TRYIT, PLACEHOLDER),          \
          TEST_NON_UTF8, REXEC_FBC_TRYIT, PLACEHOLDER)

#define FBC_BOUND_A(TEST_NON_UTF8)                                             \
    FBC_BOUND_COMMON(                                                          \
            FBC_UTF8_A(TEST_NON_UTF8, REXEC_FBC_TRYIT, PLACEHOLDER),           \
            TEST_NON_UTF8, REXEC_FBC_TRYIT, PLACEHOLDER)

#define FBC_NBOUND(TEST_NON_UTF8, TEST_UV, TEST_UTF8)                          \
    FBC_BOUND_COMMON(                                                          \
          FBC_UTF8(TEST_UV, TEST_UTF8, PLACEHOLDER, REXEC_FBC_TRYIT),          \
          TEST_NON_UTF8, PLACEHOLDER, REXEC_FBC_TRYIT)

#define FBC_NBOUND_A(TEST_NON_UTF8)                                            \
    FBC_BOUND_COMMON(                                                          \
            FBC_UTF8_A(TEST_NON_UTF8, PLACEHOLDER, REXEC_FBC_TRYIT),           \
            TEST_NON_UTF8, PLACEHOLDER, REXEC_FBC_TRYIT)

#ifdef DEBUGGING
static IV
S_get_break_val_cp_checked(SV* const invlist, const UV cp_in) {
  IV cp_out = Perl__invlist_search(invlist, cp_in);
  assert(cp_out >= 0);
  return cp_out;
}
#  define _generic_GET_BREAK_VAL_CP_CHECKED(invlist, invmap, cp) \
	invmap[S_get_break_val_cp_checked(invlist, cp)]
#else
#  define _generic_GET_BREAK_VAL_CP_CHECKED(invlist, invmap, cp) \
	invmap[_invlist_search(invlist, cp)]
#endif

/* Takes a pointer to an inversion list, a pointer to its corresponding
 * inversion map, and a code point, and returns the code point's value
 * according to the two arrays.  It assumes that all code points have a value.
 * This is used as the base macro for macros for particular properties */
#define _generic_GET_BREAK_VAL_CP(invlist, invmap, cp)              \
	_generic_GET_BREAK_VAL_CP_CHECKED(invlist, invmap, cp)

/* Same as above, but takes begin, end ptrs to a UTF-8 encoded string instead
 * of a code point, returning the value for the first code point in the string.
 * And it takes the particular macro name that finds the desired value given a
 * code point.  Merely convert the UTF-8 to code point and call the cp macro */
#define _generic_GET_BREAK_VAL_UTF8(cp_macro, pos, strend)                     \
             (__ASSERT_(pos < strend)                                          \
                 /* Note assumes is valid UTF-8 */                             \
             (cp_macro(utf8_to_uvchr_buf((pos), (strend), NULL))))

/* Returns the GCB value for the input code point */
#define getGCB_VAL_CP(cp)                                                      \
          _generic_GET_BREAK_VAL_CP(                                           \
                                    PL_GCB_invlist,                            \
                                    _Perl_GCB_invmap,                          \
                                    (cp))

/* Returns the GCB value for the first code point in the UTF-8 encoded string
 * bounded by pos and strend */
#define getGCB_VAL_UTF8(pos, strend)                                           \
    _generic_GET_BREAK_VAL_UTF8(getGCB_VAL_CP, pos, strend)

/* Returns the LB value for the input code point */
#define getLB_VAL_CP(cp)                                                       \
          _generic_GET_BREAK_VAL_CP(                                           \
                                    PL_LB_invlist,                             \
                                    _Perl_LB_invmap,                           \
                                    (cp))

/* Returns the LB value for the first code point in the UTF-8 encoded string
 * bounded by pos and strend */
#define getLB_VAL_UTF8(pos, strend)                                            \
    _generic_GET_BREAK_VAL_UTF8(getLB_VAL_CP, pos, strend)


/* Returns the SB value for the input code point */
#define getSB_VAL_CP(cp)                                                       \
          _generic_GET_BREAK_VAL_CP(                                           \
                                    PL_SB_invlist,                             \
                                    _Perl_SB_invmap,                     \
                                    (cp))

/* Returns the SB value for the first code point in the UTF-8 encoded string
 * bounded by pos and strend */
#define getSB_VAL_UTF8(pos, strend)                                            \
    _generic_GET_BREAK_VAL_UTF8(getSB_VAL_CP, pos, strend)

/* Returns the WB value for the input code point */
#define getWB_VAL_CP(cp)                                                       \
          _generic_GET_BREAK_VAL_CP(                                           \
                                    PL_WB_invlist,                             \
                                    _Perl_WB_invmap,                         \
                                    (cp))

/* Returns the WB value for the first code point in the UTF-8 encoded string
 * bounded by pos and strend */
#define getWB_VAL_UTF8(pos, strend)                                            \
    _generic_GET_BREAK_VAL_UTF8(getWB_VAL_CP, pos, strend)

/* We know what class REx starts with.  Try to find this position... */
/* if reginfo->intuit, its a dryrun */
/* annoyingly all the vars in this routine have different names from their counterparts
   in regmatch. /grrr */
STATIC char *
S_find_byclass(pTHX_ regexp * prog, const regnode *c, char *s, 
    const char *strend, regmatch_info *reginfo)
{
    dVAR;
    const I32 doevery = (prog->intflags & PREGf_SKIP) == 0;
    char *pat_string;   /* The pattern's exactish string */
    char *pat_end;	    /* ptr to end char of pat_string */
    re_fold_t folder;	/* Function for computing non-utf8 folds */
    const U8 *fold_array;   /* array for folding ords < 256 */
    STRLEN ln;
    STRLEN lnc;
    U8 c1;
    U8 c2;
    char *e;
    I32 tmp = 1;	/* Scratch variable? */
    const bool utf8_target = reginfo->is_utf8_target;
    UV utf8_fold_flags = 0;
    const bool is_utf8_pat = reginfo->is_utf8_pat;
    bool to_complement = FALSE; /* Invert the result?  Taking the xor of this
                                   with a result inverts that result, as 0^1 =
                                   1 and 1^1 = 0 */
    _char_class_number classnum;

    RXi_GET_DECL(prog,progi);

    PERL_ARGS_ASSERT_FIND_BYCLASS;

    /* We know what class it must start with. */
    switch (OP(c)) {
    case ANYOFL:
        _CHECK_AND_WARN_PROBLEMATIC_LOCALE;

        if (ANYOFL_UTF8_LOCALE_REQD(FLAGS(c)) && ! IN_UTF8_CTYPE_LOCALE) {
            Perl_ck_warner(aTHX_ packWARN(WARN_LOCALE), utf8_locale_required);
        }

        /* FALLTHROUGH */
    case ANYOFD:
    case ANYOF:
        if (utf8_target) {
            REXEC_FBC_UTF8_CLASS_SCAN(
                      reginclass(prog, c, (U8*)s, (U8*) strend, utf8_target));
        }
        else {
            REXEC_FBC_CLASS_SCAN(REGINCLASS(prog, c, (U8*)s, 0));
        }
        break;

    case EXACTFA_NO_TRIE:   /* This node only generated for non-utf8 patterns */
        assert(! is_utf8_pat);
	/* FALLTHROUGH */
    case EXACTFA:
        if (is_utf8_pat || utf8_target) {
            utf8_fold_flags = FOLDEQ_UTF8_NOMIX_ASCII;
            goto do_exactf_utf8;
        }
        fold_array = PL_fold_latin1;    /* Latin1 folds are not affected by */
        folder = foldEQ_latin1;	        /* /a, except the sharp s one which */
        goto do_exactf_non_utf8;	/* isn't dealt with by these */

    case EXACTF:   /* This node only generated for non-utf8 patterns */
        assert(! is_utf8_pat);
        if (utf8_target) {
            utf8_fold_flags = 0;
            goto do_exactf_utf8;
        }
        fold_array = PL_fold;
        folder = foldEQ;
        goto do_exactf_non_utf8;

    case EXACTFL:
        _CHECK_AND_WARN_PROBLEMATIC_LOCALE;
        if (is_utf8_pat || utf8_target || IN_UTF8_CTYPE_LOCALE) {
            utf8_fold_flags = FOLDEQ_LOCALE;
            goto do_exactf_utf8;
        }
        fold_array = PL_fold_locale;
        folder = foldEQ_locale;
        goto do_exactf_non_utf8;

    case EXACTFU_SS:
        if (is_utf8_pat) {
            utf8_fold_flags = FOLDEQ_S2_ALREADY_FOLDED;
        }
        goto do_exactf_utf8;

    case EXACTFLU8:
            if (! utf8_target) {    /* All code points in this node require
                                       UTF-8 to express.  */
                break;
            }
            utf8_fold_flags =  FOLDEQ_LOCALE | FOLDEQ_S2_ALREADY_FOLDED
                                             | FOLDEQ_S2_FOLDS_SANE;
            goto do_exactf_utf8;

    case EXACTFU:
        if (is_utf8_pat || utf8_target) {
            utf8_fold_flags = is_utf8_pat ? FOLDEQ_S2_ALREADY_FOLDED : 0;
            goto do_exactf_utf8;
        }

        /* Any 'ss' in the pattern should have been replaced by regcomp,
         * so we don't have to worry here about this single special case
         * in the Latin1 range */
        fold_array = PL_fold_latin1;
        folder = foldEQ_latin1;

        /* FALLTHROUGH */

      do_exactf_non_utf8: /* Neither pattern nor string are UTF8, and there
                           are no glitches with fold-length differences
                           between the target string and pattern */

        /* The idea in the non-utf8 EXACTF* cases is to first find the
         * first character of the EXACTF* node and then, if necessary,
         * case-insensitively compare the full text of the node.  c1 is the
         * first character.  c2 is its fold.  This logic will not work for
         * Unicode semantics and the german sharp ss, which hence should
         * not be compiled into a node that gets here. */
        pat_string = STRING(c);
        ln  = STR_LEN(c);	/* length to match in octets/bytes */

        /* We know that we have to match at least 'ln' bytes (which is the
         * same as characters, since not utf8).  If we have to match 3
         * characters, and there are only 2 availabe, we know without
         * trying that it will fail; so don't start a match past the
         * required minimum number from the far end */
        e = HOP3c(strend, -((SSize_t)ln), s);

        if (reginfo->intuit && e < s) {
            e = s;			/* Due to minlen logic of intuit() */
        }

        c1 = *pat_string;
        c2 = fold_array[c1];
        if (c1 == c2) { /* If char and fold are the same */
            REXEC_FBC_EXACTISH_SCAN(*(U8*)s == c1);
        }
        else {
            REXEC_FBC_EXACTISH_SCAN(*(U8*)s == c1 || *(U8*)s == c2);
        }
        break;

      do_exactf_utf8:
      {
        unsigned expansion;

        /* If one of the operands is in utf8, we can't use the simpler folding
         * above, due to the fact that many different characters can have the
         * same fold, or portion of a fold, or different- length fold */
        pat_string = STRING(c);
        ln  = STR_LEN(c);	/* length to match in octets/bytes */
        pat_end = pat_string + ln;
        lnc = is_utf8_pat       /* length to match in characters */
                ? utf8_length((U8 *) pat_string, (U8 *) pat_end)
                : ln;

        /* We have 'lnc' characters to match in the pattern, but because of
         * multi-character folding, each character in the target can match
         * up to 3 characters (Unicode guarantees it will never exceed
         * this) if it is utf8-encoded; and up to 2 if not (based on the
         * fact that the Latin 1 folds are already determined, and the
         * only multi-char fold in that range is the sharp-s folding to
         * 'ss'.  Thus, a pattern character can match as little as 1/3 of a
         * string character.  Adjust lnc accordingly, rounding up, so that
         * if we need to match at least 4+1/3 chars, that really is 5. */
        expansion = (utf8_target) ? UTF8_MAX_FOLD_CHAR_EXPAND : 2;
        lnc = (lnc + expansion - 1) / expansion;

        /* As in the non-UTF8 case, if we have to match 3 characters, and
         * only 2 are left, it's guaranteed to fail, so don't start a
         * match that would require us to go beyond the end of the string
         */
        e = HOP3c(strend, -((SSize_t)lnc), s);

        if (reginfo->intuit && e < s) {
            e = s;			/* Due to minlen logic of intuit() */
        }

        /* XXX Note that we could recalculate e to stop the loop earlier,
         * as the worst case expansion above will rarely be met, and as we
         * go along we would usually find that e moves further to the left.
         * This would happen only after we reached the point in the loop
         * where if there were no expansion we should fail.  Unclear if
         * worth the expense */

        while (s <= e) {
            char *my_strend= (char *)strend;
            if (foldEQ_utf8_flags(s, &my_strend, 0,  utf8_target,
                  pat_string, NULL, ln, is_utf8_pat, utf8_fold_flags)
                && (reginfo->intuit || regtry(reginfo, &s)) )
            {
                goto got_it;
            }
            s += (utf8_target) ? UTF8SKIP(s) : 1;
        }
        break;
    }

    case BOUNDL:
        _CHECK_AND_WARN_PROBLEMATIC_LOCALE;
        if (FLAGS(c) != TRADITIONAL_BOUND) {
            if (! IN_UTF8_CTYPE_LOCALE) {
                Perl_ck_warner(aTHX_ packWARN(WARN_LOCALE),
                                                B_ON_NON_UTF8_LOCALE_IS_WRONG);
            }
            goto do_boundu;
        }

        FBC_BOUND(isWORDCHAR_LC, isWORDCHAR_LC_uvchr, isWORDCHAR_LC_utf8);
        break;

    case NBOUNDL:
        _CHECK_AND_WARN_PROBLEMATIC_LOCALE;
        if (FLAGS(c) != TRADITIONAL_BOUND) {
            if (! IN_UTF8_CTYPE_LOCALE) {
                Perl_ck_warner(aTHX_ packWARN(WARN_LOCALE),
                                                B_ON_NON_UTF8_LOCALE_IS_WRONG);
            }
            goto do_nboundu;
        }

        FBC_NBOUND(isWORDCHAR_LC, isWORDCHAR_LC_uvchr, isWORDCHAR_LC_utf8);
        break;

    case BOUND: /* regcomp.c makes sure that this only has the traditional \b
                   meaning */
        assert(FLAGS(c) == TRADITIONAL_BOUND);

        FBC_BOUND(isWORDCHAR, isWORDCHAR_uni, isWORDCHAR_utf8);
        break;

    case BOUNDA: /* regcomp.c makes sure that this only has the traditional \b
                   meaning */
        assert(FLAGS(c) == TRADITIONAL_BOUND);

        FBC_BOUND_A(isWORDCHAR_A);
        break;

    case NBOUND: /* regcomp.c makes sure that this only has the traditional \b
                   meaning */
        assert(FLAGS(c) == TRADITIONAL_BOUND);

        FBC_NBOUND(isWORDCHAR, isWORDCHAR_uni, isWORDCHAR_utf8);
        break;

    case NBOUNDA: /* regcomp.c makes sure that this only has the traditional \b
                   meaning */
        assert(FLAGS(c) == TRADITIONAL_BOUND);

        FBC_NBOUND_A(isWORDCHAR_A);
        break;

    case NBOUNDU:
        if ((bound_type) FLAGS(c) == TRADITIONAL_BOUND) {
            FBC_NBOUND(isWORDCHAR_L1, isWORDCHAR_uni, isWORDCHAR_utf8);
            break;
        }

      do_nboundu:

        to_complement = 1;
        /* FALLTHROUGH */

    case BOUNDU:
      do_boundu:
        switch((bound_type) FLAGS(c)) {
            case TRADITIONAL_BOUND:
                FBC_BOUND(isWORDCHAR_L1, isWORDCHAR_uni, isWORDCHAR_utf8);
                break;
            case GCB_BOUND:
                if (s == reginfo->strbeg) {
                    if (reginfo->intuit || regtry(reginfo, &s))
                    {
                        goto got_it;
                    }

                    /* Didn't match.  Try at the next position (if there is one) */
                    s += (utf8_target) ? UTF8SKIP(s) : 1;
                    if (UNLIKELY(s >= reginfo->strend)) {
                        break;
                    }
                }

                if (utf8_target) {
                    GCB_enum before = getGCB_VAL_UTF8(
                                               reghop3((U8*)s, -1,
                                                       (U8*)(reginfo->strbeg)),
                                               (U8*) reginfo->strend);
                    while (s < strend) {
                        GCB_enum after = getGCB_VAL_UTF8((U8*) s,
                                                        (U8*) reginfo->strend);
                        if (   (to_complement ^ isGCB(before, after))
                            && (reginfo->intuit || regtry(reginfo, &s)))
                        {
                            goto got_it;
                        }
                        before = after;
                        s += UTF8SKIP(s);
                    }
                }
                else {  /* Not utf8.  Everything is a GCB except between CR and
                           LF */
                    while (s < strend) {
                        if ((to_complement ^ (   UCHARAT(s - 1) != '\r'
                                              || UCHARAT(s) != '\n'))
                            && (reginfo->intuit || regtry(reginfo, &s)))
                        {
                            goto got_it;
                        }
                        s++;
                    }
                }

                /* And, since this is a bound, it can match after the final
                 * character in the string */
                if ((reginfo->intuit || regtry(reginfo, &s))) {
                    goto got_it;
                }
                break;

            case LB_BOUND:
                if (s == reginfo->strbeg) {
                    if (reginfo->intuit || regtry(reginfo, &s)) {
                        goto got_it;
                    }
                    s += (utf8_target) ? UTF8SKIP(s) : 1;
                    if (UNLIKELY(s >= reginfo->strend)) {
                        break;
                    }
                }

                if (utf8_target) {
                    LB_enum before = getLB_VAL_UTF8(reghop3((U8*)s,
                                                               -1,
                                                               (U8*)(reginfo->strbeg)),
                                                       (U8*) reginfo->strend);
                    while (s < strend) {
                        LB_enum after = getLB_VAL_UTF8((U8*) s, (U8*) reginfo->strend);
                        if (to_complement ^ isLB(before,
                                                 after,
                                                 (U8*) reginfo->strbeg,
                                                 (U8*) s,
                                                 (U8*) reginfo->strend,
                                                 utf8_target)
                            && (reginfo->intuit || regtry(reginfo, &s)))
                        {
                            goto got_it;
                        }
                        before = after;
                        s += UTF8SKIP(s);
                    }
                }
                else {  /* Not utf8. */
                    LB_enum before = getLB_VAL_CP((U8) *(s -1));
                    while (s < strend) {
                        LB_enum after = getLB_VAL_CP((U8) *s);
                        if (to_complement ^ isLB(before,
                                                 after,
                                                 (U8*) reginfo->strbeg,
                                                 (U8*) s,
                                                 (U8*) reginfo->strend,
                                                 utf8_target)
                            && (reginfo->intuit || regtry(reginfo, &s)))
                        {
                            goto got_it;
                        }
                        before = after;
                        s++;
                    }
                }

                if (reginfo->intuit || regtry(reginfo, &s)) {
                    goto got_it;
                }

                break;

            case SB_BOUND:
                if (s == reginfo->strbeg) {
                    if (reginfo->intuit || regtry(reginfo, &s)) {
                        goto got_it;
                    }
                    s += (utf8_target) ? UTF8SKIP(s) : 1;
                    if (UNLIKELY(s >= reginfo->strend)) {
                        break;
                    }
                }

                if (utf8_target) {
                    SB_enum before = getSB_VAL_UTF8(reghop3((U8*)s,
                                                        -1,
                                                        (U8*)(reginfo->strbeg)),
                                                      (U8*) reginfo->strend);
                    while (s < strend) {
                        SB_enum after = getSB_VAL_UTF8((U8*) s,
                                                         (U8*) reginfo->strend);
                        if ((to_complement ^ isSB(before,
                                                  after,
                                                  (U8*) reginfo->strbeg,
                                                  (U8*) s,
                                                  (U8*) reginfo->strend,
                                                  utf8_target))
                            && (reginfo->intuit || regtry(reginfo, &s)))
                        {
                            goto got_it;
                        }
                        before = after;
                        s += UTF8SKIP(s);
                    }
                }
                else {  /* Not utf8. */
                    SB_enum before = getSB_VAL_CP((U8) *(s -1));
                    while (s < strend) {
                        SB_enum after = getSB_VAL_CP((U8) *s);
                        if ((to_complement ^ isSB(before,
                                                  after,
                                                  (U8*) reginfo->strbeg,
                                                  (U8*) s,
                                                  (U8*) reginfo->strend,
                                                  utf8_target))
                            && (reginfo->intuit || regtry(reginfo, &s)))
                        {
                            goto got_it;
                        }
                        before = after;
                        s++;
                    }
                }

                /* Here are at the final position in the target string.  The SB
                 * value is always true here, so matches, depending on other
                 * constraints */
                if (reginfo->intuit || regtry(reginfo, &s)) {
                    goto got_it;
                }

                break;

            case WB_BOUND:
                if (s == reginfo->strbeg) {
                    if (reginfo->intuit || regtry(reginfo, &s)) {
                        goto got_it;
                    }
                    s += (utf8_target) ? UTF8SKIP(s) : 1;
                    if (UNLIKELY(s >= reginfo->strend)) {
                        break;
                    }
                }

                if (utf8_target) {
                    /* We are at a boundary between char_sub_0 and char_sub_1.
                     * We also keep track of the value for char_sub_-1 as we
                     * loop through the line.   Context may be needed to make a
                     * determination, and if so, this can save having to
                     * recalculate it */
                    WB_enum previous = WB_UNKNOWN;
                    WB_enum before = getWB_VAL_UTF8(
                                              reghop3((U8*)s,
                                                      -1,
                                                      (U8*)(reginfo->strbeg)),
                                              (U8*) reginfo->strend);
                    while (s < strend) {
                        WB_enum after = getWB_VAL_UTF8((U8*) s,
                                                        (U8*) reginfo->strend);
                        if ((to_complement ^ isWB(previous,
                                                  before,
                                                  after,
                                                  (U8*) reginfo->strbeg,
                                                  (U8*) s,
                                                  (U8*) reginfo->strend,
                                                  utf8_target))
                            && (reginfo->intuit || regtry(reginfo, &s)))
                        {
                            goto got_it;
                        }
                        previous = before;
                        before = after;
                        s += UTF8SKIP(s);
                    }
                }
                else {  /* Not utf8. */
                    WB_enum previous = WB_UNKNOWN;
                    WB_enum before = getWB_VAL_CP((U8) *(s -1));
                    while (s < strend) {
                        WB_enum after = getWB_VAL_CP((U8) *s);
                        if ((to_complement ^ isWB(previous,
                                                  before,
                                                  after,
                                                  (U8*) reginfo->strbeg,
                                                  (U8*) s,
                                                  (U8*) reginfo->strend,
                                                  utf8_target))
                            && (reginfo->intuit || regtry(reginfo, &s)))
                        {
                            goto got_it;
                        }
                        previous = before;
                        before = after;
                        s++;
                    }
                }

                if (reginfo->intuit || regtry(reginfo, &s)) {
                    goto got_it;
                }
        }
        break;

    case LNBREAK:
        REXEC_FBC_CSCAN(is_LNBREAK_utf8_safe(s, strend),
                        is_LNBREAK_latin1_safe(s, strend)
        );
        break;

    /* The argument to all the POSIX node types is the class number to pass to
     * _generic_isCC() to build a mask for searching in PL_charclass[] */

    case NPOSIXL:
        to_complement = 1;
        /* FALLTHROUGH */

    case POSIXL:
        _CHECK_AND_WARN_PROBLEMATIC_LOCALE;
        REXEC_FBC_CSCAN(to_complement ^ cBOOL(isFOO_utf8_lc(FLAGS(c), (U8 *) s)),
                        to_complement ^ cBOOL(isFOO_lc(FLAGS(c), *s)));
        break;

    case NPOSIXD:
        to_complement = 1;
        /* FALLTHROUGH */

    case POSIXD:
        if (utf8_target) {
            goto posix_utf8;
        }
        goto posixa;

    case NPOSIXA:
        if (utf8_target) {
            /* The complement of something that matches only ASCII matches all
             * non-ASCII, plus everything in ASCII that isn't in the class. */
            REXEC_FBC_UTF8_CLASS_SCAN(! isASCII_utf8(s)
                                      || ! _generic_isCC_A(*s, FLAGS(c)));
            break;
        }

        to_complement = 1;
        /* FALLTHROUGH */

    case POSIXA:
      posixa:
        /* Don't need to worry about utf8, as it can match only a single
         * byte invariant character. */
        REXEC_FBC_CLASS_SCAN(
                        to_complement ^ cBOOL(_generic_isCC_A(*s, FLAGS(c))));
        break;

    case NPOSIXU:
        to_complement = 1;
        /* FALLTHROUGH */

    case POSIXU:
        if (! utf8_target) {
            REXEC_FBC_CLASS_SCAN(to_complement ^ cBOOL(_generic_isCC(*s,
                                                                    FLAGS(c))));
        }
        else {

          posix_utf8:
            classnum = (_char_class_number) FLAGS(c);
            if (classnum < _FIRST_NON_SWASH_CC) {
                while (s < strend) {

                    /* We avoid loading in the swash as long as possible, but
                     * should we have to, we jump to a separate loop.  This
                     * extra 'if' statement is what keeps this code from being
                     * just a call to REXEC_FBC_UTF8_CLASS_SCAN() */
                    if (UTF8_IS_ABOVE_LATIN1(*s)) {
                        goto found_above_latin1;
                    }
                    if ((UTF8_IS_INVARIANT(*s)
                         && to_complement ^ cBOOL(_generic_isCC((U8) *s,
                                                                classnum)))
                        || (UTF8_IS_DOWNGRADEABLE_START(*s)
                            && to_complement ^ cBOOL(
                                _generic_isCC(EIGHT_BIT_UTF8_TO_NATIVE(*s,
                                                                      *(s + 1)),
                                              classnum))))
                    {
                        if (tmp && (reginfo->intuit || regtry(reginfo, &s)))
                            goto got_it;
                        else {
                            tmp = doevery;
                        }
                    }
                    else {
                        tmp = 1;
                    }
                    s += UTF8SKIP(s);
                }
            }
            else switch (classnum) {    /* These classes are implemented as
                                           macros */
                case _CC_ENUM_SPACE:
                    REXEC_FBC_UTF8_CLASS_SCAN(
                                        to_complement ^ cBOOL(isSPACE_utf8(s)));
                    break;

                case _CC_ENUM_BLANK:
                    REXEC_FBC_UTF8_CLASS_SCAN(
                                        to_complement ^ cBOOL(isBLANK_utf8(s)));
                    break;

                case _CC_ENUM_XDIGIT:
                    REXEC_FBC_UTF8_CLASS_SCAN(
                                       to_complement ^ cBOOL(isXDIGIT_utf8(s)));
                    break;

                case _CC_ENUM_VERTSPACE:
                    REXEC_FBC_UTF8_CLASS_SCAN(
                                       to_complement ^ cBOOL(isVERTWS_utf8(s)));
                    break;

                case _CC_ENUM_CNTRL:
                    REXEC_FBC_UTF8_CLASS_SCAN(
                                        to_complement ^ cBOOL(isCNTRL_utf8(s)));
                    break;

                default:
                    Perl_croak(aTHX_ "panic: find_byclass() node %d='%s' has an unexpected character class '%d'", OP(c), PL_reg_name[OP(c)], classnum);
                    NOT_REACHED; /* NOTREACHED */
            }
        }
        break;

      found_above_latin1:   /* Here we have to load a swash to get the result
                               for the current code point */
        if (! PL_utf8_swash_ptrs[classnum]) {
            U8 flags = _CORE_SWASH_INIT_ACCEPT_INVLIST;
            PL_utf8_swash_ptrs[classnum] =
                    _core_swash_init("utf8",
                                     "",
                                     &PL_sv_undef, 1, 0,
                                     PL_XPosix_ptrs[classnum], &flags);
        }

        /* This is a copy of the loop above for swash classes, though using the
         * FBC macro instead of being expanded out.  Since we've loaded the
         * swash, we don't have to check for that each time through the loop */
        REXEC_FBC_UTF8_CLASS_SCAN(
                to_complement ^ cBOOL(_generic_utf8(
                                      classnum,
                                      s,
                                      swash_fetch(PL_utf8_swash_ptrs[classnum],
                                                  (U8 *) s, TRUE))));
        break;

    case AHOCORASICKC:
    case AHOCORASICK:
        {
            DECL_TRIE_TYPE(c);
            /* what trie are we using right now */
            reg_ac_data *aho = (reg_ac_data*)progi->data->data[ ARG( c ) ];
            reg_trie_data *trie = (reg_trie_data*)progi->data->data[ aho->trie ];
            HV *widecharmap = MUTABLE_HV(progi->data->data[ aho->trie + 1 ]);

            const char *last_start = strend - trie->minlen;
#ifdef DEBUGGING
            const char *real_start = s;
#endif
            STRLEN maxlen = trie->maxlen;
            SV *sv_points;
            U8 **points; /* map of where we were in the input string
                            when reading a given char. For ASCII this
                            is unnecessary overhead as the relationship
                            is always 1:1, but for Unicode, especially
                            case folded Unicode this is not true. */
            U8 foldbuf[ UTF8_MAXBYTES_CASE + 1 ];
            U8 *bitmap=NULL;


            GET_RE_DEBUG_FLAGS_DECL;

            /* We can't just allocate points here. We need to wrap it in
             * an SV so it gets freed properly if there is a croak while
             * running the match */
            ENTER;
            SAVETMPS;
            sv_points=newSV(maxlen * sizeof(U8 *));
            SvCUR_set(sv_points,
                maxlen * sizeof(U8 *));
            SvPOK_on(sv_points);
            sv_2mortal(sv_points);
            points=(U8**)SvPV_nolen(sv_points );
            if ( trie_type != trie_utf8_fold
                 && (trie->bitmap || OP(c)==AHOCORASICKC) )
            {
                if (trie->bitmap)
                    bitmap=(U8*)trie->bitmap;
                else
                    bitmap=(U8*)ANYOF_BITMAP(c);
            }
            /* this is the Aho-Corasick algorithm modified a touch
               to include special handling for long "unknown char" sequences.
               The basic idea being that we use AC as long as we are dealing
               with a possible matching char, when we encounter an unknown char
               (and we have not encountered an accepting state) we scan forward
               until we find a legal starting char.
               AC matching is basically that of trie matching, except that when
               we encounter a failing transition, we fall back to the current
               states "fail state", and try the current char again, a process
               we repeat until we reach the root state, state 1, or a legal
               transition. If we fail on the root state then we can either
               terminate if we have reached an accepting state previously, or
               restart the entire process from the beginning if we have not.

             */
            while (s <= last_start) {
                const U32 uniflags = UTF8_ALLOW_DEFAULT;
                U8 *uc = (U8*)s;
                U16 charid = 0;
                U32 base = 1;
                U32 state = 1;
                UV uvc = 0;
                STRLEN len = 0;
                STRLEN foldlen = 0;
                U8 *uscan = (U8*)NULL;
                U8 *leftmost = NULL;
#ifdef DEBUGGING
                U32 accepted_word= 0;
#endif
                U32 pointpos = 0;

                while ( state && uc <= (U8*)strend ) {
                    int failed=0;
                    U32 word = aho->states[ state ].wordnum;

                    if( state==1 ) {
                        if ( bitmap ) {
                            DEBUG_TRIE_EXECUTE_r(
                                if ( uc <= (U8*)last_start && !BITMAP_TEST(bitmap,*uc) ) {
                                    dump_exec_pos( (char *)uc, c, strend, real_start,
                                        (char *)uc, utf8_target, 0 );
                                    Perl_re_printf( aTHX_
                                        " Scanning for legal start char...\n");
                                }
                            );
                            if (utf8_target) {
                                while ( uc <= (U8*)last_start && !BITMAP_TEST(bitmap,*uc) ) {
                                    uc += UTF8SKIP(uc);
                                }
                            } else {
                                while ( uc <= (U8*)last_start  && !BITMAP_TEST(bitmap,*uc) ) {
                                    uc++;
                                }
                            }
                            s= (char *)uc;
                        }
                        if (uc >(U8*)last_start) break;
                    }

                    if ( word ) {
                        U8 *lpos= points[ (pointpos - trie->wordinfo[word].len) % maxlen ];
                        if (!leftmost || lpos < leftmost) {
                            DEBUG_r(accepted_word=word);
                            leftmost= lpos;
                        }
                        if (base==0) break;

                    }
                    points[pointpos++ % maxlen]= uc;
                    if (foldlen || uc < (U8*)strend) {
                        REXEC_TRIE_READ_CHAR(trie_type, trie,
                                         widecharmap, uc,
                                         uscan, len, uvc, charid, foldlen,
                                         foldbuf, uniflags);
                        DEBUG_TRIE_EXECUTE_r({
                            dump_exec_pos( (char *)uc, c, strend,
                                        real_start, s, utf8_target, 0);
                            Perl_re_printf( aTHX_
                                " Charid:%3u CP:%4"UVxf" ",
                                 charid, uvc);
                        });
                    }
                    else {
                        len = 0;
                        charid = 0;
                    }


                    do {
#ifdef DEBUGGING
                        word = aho->states[ state ].wordnum;
#endif
                        base = aho->states[ state ].trans.base;

                        DEBUG_TRIE_EXECUTE_r({
                            if (failed)
                                dump_exec_pos( (char *)uc, c, strend, real_start,
                                    s,   utf8_target, 0 );
                            Perl_re_printf( aTHX_
                                "%sState: %4"UVxf", word=%"UVxf,
                                failed ? " Fail transition to " : "",
                                (UV)state, (UV)word);
                        });
                        if ( base ) {
                            U32 tmp;
                            I32 offset;
                            if (charid &&
                                 ( ((offset = base + charid
                                    - 1 - trie->uniquecharcount)) >= 0)
                                 && ((U32)offset < trie->lasttrans)
                                 && trie->trans[offset].check == state
                                 && (tmp=trie->trans[offset].next))
                            {
                                DEBUG_TRIE_EXECUTE_r(
                                    Perl_re_printf( aTHX_ " - legal\n"));
                                state = tmp;
                                break;
                            }
                            else {
                                DEBUG_TRIE_EXECUTE_r(
                                    Perl_re_printf( aTHX_ " - fail\n"));
                                failed = 1;
                                state = aho->fail[state];
                            }
                        }
                        else {
                            /* we must be accepting here */
                            DEBUG_TRIE_EXECUTE_r(
                                    Perl_re_printf( aTHX_ " - accepting\n"));
                            failed = 1;
                            break;
                        }
                    } while(state);
                    uc += len;
                    if (failed) {
                        if (leftmost)
                            break;
                        if (!state) state = 1;
                    }
                }
                if ( aho->states[ state ].wordnum ) {
                    U8 *lpos = points[ (pointpos - trie->wordinfo[aho->states[ state ].wordnum].len) % maxlen ];
                    if (!leftmost || lpos < leftmost) {
                        DEBUG_r(accepted_word=aho->states[ state ].wordnum);
                        leftmost = lpos;
                    }
                }
                if (leftmost) {
                    s = (char*)leftmost;
                    DEBUG_TRIE_EXECUTE_r({
                        Perl_re_printf( aTHX_  "Matches word #%"UVxf" at position %"IVdf". Trying full pattern...\n",
                            (UV)accepted_word, (IV)(s - real_start)
                        );
                    });
                    if (reginfo->intuit || regtry(reginfo, &s)) {
                        FREETMPS;
                        LEAVE;
                        goto got_it;
                    }
                    s = HOPc(s,1);
                    DEBUG_TRIE_EXECUTE_r({
                        Perl_re_printf( aTHX_ "Pattern failed. Looking for new start point...\n");
                    });
                } else {
                    DEBUG_TRIE_EXECUTE_r(
                        Perl_re_printf( aTHX_ "No match.\n"));
                    break;
                }
            }
            FREETMPS;
            LEAVE;
        }
        break;
    default:
        Perl_croak(aTHX_ "panic: unknown regstclass %d", (int)OP(c));
    }
    return 0;
  got_it:
    return s;
}

/* set RX_SAVED_COPY, RX_SUBBEG etc.
 * flags have same meanings as with regexec_flags() */

static void
S_reg_set_capture_string(pTHX_ REGEXP * const rx,
                            char *strbeg,
                            char *strend,
                            SV *sv,
                            U32 flags,
                            bool utf8_target)
{
    struct regexp *const prog = ReANY(rx);

    if (flags & REXEC_COPY_STR) {
#ifdef PERL_ANY_COW
        if (SvCANCOW(sv)) {
            DEBUG_C(Perl_re_printf( aTHX_
                              "Copy on write: regexp capture, type %d\n",
                                    (int) SvTYPE(sv)));
            /* Create a new COW SV to share the match string and store
             * in saved_copy, unless the current COW SV in saved_copy
             * is valid and suitable for our purpose */
            if ((   prog->saved_copy
                 && SvIsCOW(prog->saved_copy)
                 && SvPOKp(prog->saved_copy)
                 && SvIsCOW(sv)
                 && SvPOKp(sv)
                 && SvPVX(sv) == SvPVX(prog->saved_copy)))
            {
                /* just reuse saved_copy SV */
                if (RXp_MATCH_COPIED(prog)) {
                    Safefree(prog->subbeg);
                    RXp_MATCH_COPIED_off(prog);
                }
            }
            else {
                /* create new COW SV to share string */
                RX_MATCH_COPY_FREE(rx);
                prog->saved_copy = sv_setsv_cow(prog->saved_copy, sv);
            }
            prog->subbeg = (char *)SvPVX_const(prog->saved_copy);
            assert (SvPOKp(prog->saved_copy));
            prog->sublen  = strend - strbeg;
            prog->suboffset = 0;
            prog->subcoffset = 0;
        } else
#endif
        {
            SSize_t min = 0;
            SSize_t max = strend - strbeg;
            SSize_t sublen;

            if (    (flags & REXEC_COPY_SKIP_POST)
                && !(prog->extflags & RXf_PMf_KEEPCOPY) /* //p */
                && !(PL_sawampersand & SAWAMPERSAND_RIGHT)
            ) { /* don't copy $' part of string */
                U32 n = 0;
                max = -1;
                /* calculate the right-most part of the string covered
                 * by a capture. Due to lookahead, this may be to
                 * the right of $&, so we have to scan all captures */
                while (n <= prog->lastparen) {
                    if (prog->offs[n].end > max)
                        max = prog->offs[n].end;
                    n++;
                }
                if (max == -1)
                    max = (PL_sawampersand & SAWAMPERSAND_LEFT)
                            ? prog->offs[0].start
                            : 0;
                assert(max >= 0 && max <= strend - strbeg);
            }

            if (    (flags & REXEC_COPY_SKIP_PRE)
                && !(prog->extflags & RXf_PMf_KEEPCOPY) /* //p */
                && !(PL_sawampersand & SAWAMPERSAND_LEFT)
            ) { /* don't copy $` part of string */
                U32 n = 0;
                min = max;
                /* calculate the left-most part of the string covered
                 * by a capture. Due to lookbehind, this may be to
                 * the left of $&, so we have to scan all captures */
                while (min && n <= prog->lastparen) {
                    if (   prog->offs[n].start != -1
                        && prog->offs[n].start < min)
                    {
                        min = prog->offs[n].start;
                    }
                    n++;
                }
                if ((PL_sawampersand & SAWAMPERSAND_RIGHT)
                    && min >  prog->offs[0].end
                )
                    min = prog->offs[0].end;

            }

            assert(min >= 0 && min <= max && min <= strend - strbeg);
            sublen = max - min;

            if (RX_MATCH_COPIED(rx)) {
                if (sublen > prog->sublen)
                    prog->subbeg =
                            (char*)saferealloc(prog->subbeg, sublen+1);
            }
            else
                prog->subbeg = (char*)safemalloc(sublen+1);
            Copy(strbeg + min, prog->subbeg, sublen, char);
            prog->subbeg[sublen] = '\0';
            prog->suboffset = min;
            prog->sublen = sublen;
            RX_MATCH_COPIED_on(rx);
        }
        prog->subcoffset = prog->suboffset;
        if (prog->suboffset && utf8_target) {
            /* Convert byte offset to chars.
             * XXX ideally should only compute this if @@-/@@+
             * has been seen, a la PL_sawampersand ??? */

            /* If there's a direct correspondence between the
             * string which we're matching and the original SV,
             * then we can use the utf8 len cache associated with
             * the SV. In particular, it means that under //g,
             * sv_pos_b2u() will use the previously cached
             * position to speed up working out the new length of
             * subcoffset, rather than counting from the start of
             * the string each time. This stops
             *   $x = "\x{100}" x 1E6; 1 while $x =~ /(.)/g;
             * from going quadratic */
            if (SvPOKp(sv) && SvPVX(sv) == strbeg)
                prog->subcoffset = sv_pos_b2u_flags(sv, prog->subcoffset,
                                                SV_GMAGIC|SV_CONST_RETURN);
            else
                prog->subcoffset = utf8_length((U8*)strbeg,
                                    (U8*)(strbeg+prog->suboffset));
        }
    }
    else {
        RX_MATCH_COPY_FREE(rx);
        prog->subbeg = strbeg;
        prog->suboffset = 0;
        prog->subcoffset = 0;
        prog->sublen = strend - strbeg;
    }
}




/*
 - regexec_flags - match a regexp against a string
 */
I32
Perl_regexec_flags(pTHX_ REGEXP * const rx, char *stringarg, char *strend,
	      char *strbeg, SSize_t minend, SV *sv, void *data, U32 flags)
/* stringarg: the point in the string at which to begin matching */
/* strend:    pointer to null at end of string */
/* strbeg:    real beginning of string */
/* minend:    end of match must be >= minend bytes after stringarg. */
/* sv:        SV being matched: only used for utf8 flag, pos() etc; string
 *            itself is accessed via the pointers above */
/* data:      May be used for some additional optimizations.
              Currently unused. */
/* flags:     For optimizations. See REXEC_* in regexp.h */

{
    struct regexp *const prog = ReANY(rx);
    char *s;
    regnode *c;
    char *startpos;
    SSize_t minlen;		/* must match at least this many chars */
    SSize_t dontbother = 0;	/* how many characters not to try at end */
    const bool utf8_target = cBOOL(DO_UTF8(sv));
    I32 multiline;
    RXi_GET_DECL(prog,progi);
    regmatch_info reginfo_buf;  /* create some info to pass to regtry etc */
    regmatch_info *const reginfo = &reginfo_buf;
    regexp_paren_pair *swap = NULL;
    I32 oldsave;
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_REGEXEC_FLAGS;
    PERL_UNUSED_ARG(data);

    /* Be paranoid... */
    if (prog == NULL) {
	Perl_croak(aTHX_ "NULL regexp parameter");
    }

    DEBUG_EXECUTE_r(
        debug_start_match(rx, utf8_target, stringarg, strend,
        "Matching");
    );

    startpos = stringarg;

    /* set these early as they may be used by the HOP macros below */
    reginfo->strbeg = strbeg;
    reginfo->strend = strend;
    reginfo->is_utf8_target = cBOOL(utf8_target);

    if (prog->intflags & PREGf_GPOS_SEEN) {
        MAGIC *mg;

        /* set reginfo->ganch, the position where \G can match */

        reginfo->ganch =
            (flags & REXEC_IGNOREPOS)
            ? stringarg /* use start pos rather than pos() */
            : ((mg = mg_find_mglob(sv)) && mg->mg_len >= 0)
              /* Defined pos(): */
            ? strbeg + MgBYTEPOS(mg, sv, strbeg, strend-strbeg)
            : strbeg; /* pos() not defined; use start of string */

        DEBUG_GPOS_r(Perl_re_printf( aTHX_
            "GPOS ganch set to strbeg[%"IVdf"]\n", (IV)(reginfo->ganch - strbeg)));

        /* in the presence of \G, we may need to start looking earlier in
         * the string than the suggested start point of stringarg:
         * if prog->gofs is set, then that's a known, fixed minimum
         * offset, such as
         * /..\G/:   gofs = 2
         * /ab|c\G/: gofs = 1
         * or if the minimum offset isn't known, then we have to go back
         * to the start of the string, e.g. /w+\G/
         */

        if (prog->intflags & PREGf_ANCH_GPOS) {
            if (prog->gofs) {
                startpos = HOPBACKc(reginfo->ganch, prog->gofs);
                if (!startpos ||
                    ((flags & REXEC_FAIL_ON_UNDERFLOW) && startpos < stringarg))
                {
                    DEBUG_r(Perl_re_printf( aTHX_
                            "fail: ganch-gofs before earliest possible start\n"));
                    return 0;
                }
            }
            else
                startpos = reginfo->ganch;
        }
        else if (prog->gofs) {
            startpos = HOPBACKc(startpos, prog->gofs);
            if (!startpos)
                startpos = strbeg;
        }
        else if (prog->intflags & PREGf_GPOS_FLOAT)
            startpos = strbeg;
    }

    minlen = prog->minlen;
    if ((startpos + minlen) > strend || startpos < strbeg) {
        DEBUG_r(Perl_re_printf( aTHX_
                    "Regex match can't succeed, so not even tried\n"));
        return 0;
    }

    /* at the end of this function, we'll do a LEAVE_SCOPE(oldsave),
     * which will call destuctors to reset PL_regmatch_state, free higher
     * PL_regmatch_slabs, and clean up regmatch_info_aux and
     * regmatch_info_aux_eval */

    oldsave = PL_savestack_ix;

    s = startpos;

    if ((prog->extflags & RXf_USE_INTUIT)
        && !(flags & REXEC_CHECKED))
    {
	s = re_intuit_start(rx, sv, strbeg, startpos, strend,
                                    flags, NULL);
	if (!s)
	    return 0;

	if (prog->extflags & RXf_CHECK_ALL) {
            /* we can match based purely on the result of INTUIT.
             * Set up captures etc just for $& and $-[0]
             * (an intuit-only match wont have $1,$2,..) */
            assert(!prog->nparens);

            /* s/// doesn't like it if $& is earlier than where we asked it to
             * start searching (which can happen on something like /.\G/) */
            if (       (flags & REXEC_FAIL_ON_UNDERFLOW)
                    && (s < stringarg))
            {
                /* this should only be possible under \G */
                assert(prog->intflags & PREGf_GPOS_SEEN);
                DEBUG_EXECUTE_r(Perl_re_printf( aTHX_
                    "matched, but failing for REXEC_FAIL_ON_UNDERFLOW\n"));
                goto phooey;
            }

            /* match via INTUIT shouldn't have any captures.
             * Let @@-, @@+, $^N know */
            prog->lastparen = prog->lastcloseparen = 0;
            RX_MATCH_UTF8_set(rx, utf8_target);
            prog->offs[0].start = s - strbeg;
            prog->offs[0].end = utf8_target
                ? (char*)utf8_hop((U8*)s, prog->minlenret) - strbeg
                : s - strbeg + prog->minlenret;
            if ( !(flags & REXEC_NOT_FIRST) )
                S_reg_set_capture_string(aTHX_ rx,
                                        strbeg, strend,
                                        sv, flags, utf8_target);

	    return 1;
        }
    }

    multiline = prog->extflags & RXf_PMf_MULTILINE;
    
    if (strend - s < (minlen+(prog->check_offset_min<0?prog->check_offset_min:0))) {
        DEBUG_EXECUTE_r(Perl_re_printf( aTHX_
			      "String too short [regexec_flags]...\n"));
	goto phooey;
    }
    
    /* Check validity of program. */
    if (UCHARAT(progi->program) != REG_MAGIC) {
	Perl_croak(aTHX_ "corrupted regexp program");
    }

    RX_MATCH_TAINTED_off(rx);
    RX_MATCH_UTF8_set(rx, utf8_target);

    reginfo->prog = rx;	 /* Yes, sorry that this is confusing.  */
    reginfo->intuit = 0;
    reginfo->is_utf8_pat = cBOOL(RX_UTF8(rx));
    reginfo->warned = FALSE;
    reginfo->sv = sv;
    reginfo->poscache_maxiter = 0; /* not yet started a countdown */
    /* see how far we have to get to not match where we matched before */
    reginfo->till = stringarg + minend;

    if (prog->extflags & RXf_EVAL_SEEN && SvPADTMP(sv)) {
        /* SAVEFREESV, not sv_mortalcopy, as this SV must last until after
           S_cleanup_regmatch_info_aux has executed (registered by
           SAVEDESTRUCTOR_X below).  S_cleanup_regmatch_info_aux modifies
           magic belonging to this SV.
           Not newSVsv, either, as it does not COW.
        */
        reginfo->sv = newSV(0);
        SvSetSV_nosteal(reginfo->sv, sv);
        SAVEFREESV(reginfo->sv);
    }

    /* reserve next 2 or 3 slots in PL_regmatch_state:
     * slot N+0: may currently be in use: skip it
     * slot N+1: use for regmatch_info_aux struct
     * slot N+2: use for regmatch_info_aux_eval struct if we have (?{})'s
     * slot N+3: ready for use by regmatch()
     */

    {
        regmatch_state *old_regmatch_state;
        regmatch_slab  *old_regmatch_slab;
        int i, max = (prog->extflags & RXf_EVAL_SEEN) ? 2 : 1;

        /* on first ever match, allocate first slab */
        if (!PL_regmatch_slab) {
            Newx(PL_regmatch_slab, 1, regmatch_slab);
            PL_regmatch_slab->prev = NULL;
            PL_regmatch_slab->next = NULL;
            PL_regmatch_state = SLAB_FIRST(PL_regmatch_slab);
        }

        old_regmatch_state = PL_regmatch_state;
        old_regmatch_slab  = PL_regmatch_slab;

        for (i=0; i <= max; i++) {
            if (i == 1)
                reginfo->info_aux = &(PL_regmatch_state->u.info_aux);
            else if (i ==2)
                reginfo->info_aux_eval =
                reginfo->info_aux->info_aux_eval =
                            &(PL_regmatch_state->u.info_aux_eval);

            if (++PL_regmatch_state >  SLAB_LAST(PL_regmatch_slab))
                PL_regmatch_state = S_push_slab(aTHX);
        }

        /* note initial PL_regmatch_state position; at end of match we'll
         * pop back to there and free any higher slabs */

        reginfo->info_aux->old_regmatch_state = old_regmatch_state;
        reginfo->info_aux->old_regmatch_slab  = old_regmatch_slab;
        reginfo->info_aux->poscache = NULL;

        SAVEDESTRUCTOR_X(S_cleanup_regmatch_info_aux, reginfo->info_aux);

        if ((prog->extflags & RXf_EVAL_SEEN))
            S_setup_eval_state(aTHX_ reginfo);
        else
            reginfo->info_aux_eval = reginfo->info_aux->info_aux_eval = NULL;
    }

    /* If there is a "must appear" string, look for it. */

    if (PL_curpm && (PM_GETRE(PL_curpm) == rx)) {
        /* We have to be careful. If the previous successful match
           was from this regex we don't want a subsequent partially
           successful match to clobber the old results.
           So when we detect this possibility we add a swap buffer
           to the re, and switch the buffer each match. If we fail,
           we switch it back; otherwise we leave it swapped.
        */
        swap = prog->offs;
        /* do we need a save destructor here for eval dies? */
        Newxz(prog->offs, (prog->nparens + 1), regexp_paren_pair);
        DEBUG_BUFFERS_r(Perl_re_printf( aTHX_
	    "rex=0x%"UVxf" saving  offs: orig=0x%"UVxf" new=0x%"UVxf"\n",
	    PTR2UV(prog),
	    PTR2UV(swap),
	    PTR2UV(prog->offs)
	));
    }

    if (prog->recurse_locinput)
        Zero(prog->recurse_locinput,prog->nparens + 1, char *);

    /* Simplest case: anchored match need be tried only once, or with
     * MBOL, only at the beginning of each line.
     *
     * Note that /.*.../ sets PREGf_IMPLICIT|MBOL, while /.*.../s sets
     * PREGf_IMPLICIT|SBOL. The idea is that with /.*.../s, if it doesn't
     * match at the start of the string then it won't match anywhere else
     * either; while with /.*.../, if it doesn't match at the beginning,
     * the earliest it could match is at the start of the next line */

    if (prog->intflags & (PREGf_ANCH & ~PREGf_ANCH_GPOS)) {
        char *end;

	if (regtry(reginfo, &s))
	    goto got_it;

        if (!(prog->intflags & PREGf_ANCH_MBOL))
            goto phooey;

        /* didn't match at start, try at other newline positions */

        if (minlen)
            dontbother = minlen - 1;
        end = HOP3c(strend, -dontbother, strbeg) - 1;

        /* skip to next newline */

        while (s <= end) { /* note it could be possible to match at the end of the string */
            /* NB: newlines are the same in unicode as they are in latin */
            if (*s++ != '\n')
                continue;
            if (prog->check_substr || prog->check_utf8) {
            /* note that with PREGf_IMPLICIT, intuit can only fail
             * or return the start position, so it's of limited utility.
             * Nevertheless, I made the decision that the potential for
             * quick fail was still worth it - DAPM */
                s = re_intuit_start(rx, sv, strbeg, s, strend, flags, NULL);
                if (!s)
                    goto phooey;
            }
            if (regtry(reginfo, &s))
                goto got_it;
        }
        goto phooey;
    } /* end anchored search */

    if (prog->intflags & PREGf_ANCH_GPOS)
    {
        /* PREGf_ANCH_GPOS should never be true if PREGf_GPOS_SEEN is not true */
        assert(prog->intflags & PREGf_GPOS_SEEN);
        /* For anchored \G, the only position it can match from is
         * (ganch-gofs); we already set startpos to this above; if intuit
         * moved us on from there, we can't possibly succeed */
        assert(startpos == HOPBACKc(reginfo->ganch, prog->gofs));
	if (s == startpos && regtry(reginfo, &s))
	    goto got_it;
	goto phooey;
    }

    /* Messy cases:  unanchored match. */
    if ((prog->anchored_substr || prog->anchored_utf8) && prog->intflags & PREGf_SKIP) {
	/* we have /x+whatever/ */
	/* it must be a one character string (XXXX Except is_utf8_pat?) */
	char ch;
#ifdef DEBUGGING
	int did_match = 0;
#endif
	if (utf8_target) {
            if (! prog->anchored_utf8) {
                to_utf8_substr(prog);
            }
            ch = SvPVX_const(prog->anchored_utf8)[0];
	    REXEC_FBC_SCAN(
		if (*s == ch) {
		    DEBUG_EXECUTE_r( did_match = 1 );
		    if (regtry(reginfo, &s)) goto got_it;
		    s += UTF8SKIP(s);
		    while (s < strend && *s == ch)
			s += UTF8SKIP(s);
		}
	    );

	}
	else {
            if (! prog->anchored_substr) {
                if (! to_byte_substr(prog)) {
                    NON_UTF8_TARGET_BUT_UTF8_REQUIRED(phooey);
                }
            }
            ch = SvPVX_const(prog->anchored_substr)[0];
	    REXEC_FBC_SCAN(
		if (*s == ch) {
		    DEBUG_EXECUTE_r( did_match = 1 );
		    if (regtry(reginfo, &s)) goto got_it;
		    s++;
		    while (s < strend && *s == ch)
			s++;
		}
	    );
	}
	DEBUG_EXECUTE_r(if (!did_match)
                Perl_re_printf( aTHX_
                                  "Did not find anchored character...\n")
               );
    }
    else if (prog->anchored_substr != NULL
	      || prog->anchored_utf8 != NULL
	      || ((prog->float_substr != NULL || prog->float_utf8 != NULL)
		  && prog->float_max_offset < strend - s)) {
	SV *must;
	SSize_t back_max;
	SSize_t back_min;
	char *last;
	char *last1;		/* Last position checked before */
#ifdef DEBUGGING
	int did_match = 0;
#endif
	if (prog->anchored_substr || prog->anchored_utf8) {
	    if (utf8_target) {
                if (! prog->anchored_utf8) {
                    to_utf8_substr(prog);
                }
                must = prog->anchored_utf8;
            }
            else {
                if (! prog->anchored_substr) {
                    if (! to_byte_substr(prog)) {
                        NON_UTF8_TARGET_BUT_UTF8_REQUIRED(phooey);
                    }
                }
                must = prog->anchored_substr;
            }
	    back_max = back_min = prog->anchored_offset;
	} else {
	    if (utf8_target) {
                if (! prog->float_utf8) {
                    to_utf8_substr(prog);
                }
                must = prog->float_utf8;
            }
            else {
                if (! prog->float_substr) {
                    if (! to_byte_substr(prog)) {
                        NON_UTF8_TARGET_BUT_UTF8_REQUIRED(phooey);
                    }
                }
                must = prog->float_substr;
            }
	    back_max = prog->float_max_offset;
	    back_min = prog->float_min_offset;
	}
	    
        if (back_min<0) {
	    last = strend;
	} else {
            last = HOP3c(strend,	/* Cannot start after this */
        	  -(SSize_t)(CHR_SVLEN(must)
        		 - (SvTAIL(must) != 0) + back_min), strbeg);
        }
	if (s > reginfo->strbeg)
	    last1 = HOPc(s, -1);
	else
	    last1 = s - 1;	/* bogus */

	/* XXXX check_substr already used to find "s", can optimize if
	   check_substr==must. */
	dontbother = 0;
	strend = HOPc(strend, -dontbother);
	while ( (s <= last) &&
		(s = fbm_instr((unsigned char*)HOP4c(s, back_min, strbeg,  strend),
				  (unsigned char*)strend, must,
				  multiline ? FBMrf_MULTILINE : 0)) ) {
	    DEBUG_EXECUTE_r( did_match = 1 );
	    if (HOPc(s, -back_max) > last1) {
		last1 = HOPc(s, -back_min);
		s = HOPc(s, -back_max);
	    }
	    else {
		char * const t = (last1 >= reginfo->strbeg)
                                    ? HOPc(last1, 1) : last1 + 1;

		last1 = HOPc(s, -back_min);
		s = t;
	    }
	    if (utf8_target) {
		while (s <= last1) {
		    if (regtry(reginfo, &s))
			goto got_it;
                    if (s >= last1) {
                        s++; /* to break out of outer loop */
                        break;
                    }
                    s += UTF8SKIP(s);
		}
	    }
	    else {
		while (s <= last1) {
		    if (regtry(reginfo, &s))
			goto got_it;
		    s++;
		}
	    }
	}
	DEBUG_EXECUTE_r(if (!did_match) {
            RE_PV_QUOTED_DECL(quoted, utf8_target, PERL_DEBUG_PAD_ZERO(0),
                SvPVX_const(must), RE_SV_DUMPLEN(must), 30);
            Perl_re_printf( aTHX_  "Did not find %s substr %s%s...\n",
			      ((must == prog->anchored_substr || must == prog->anchored_utf8)
			       ? "anchored" : "floating"),
                quoted, RE_SV_TAIL(must));
        });		    
	goto phooey;
    }
    else if ( (c = progi->regstclass) ) {
	if (minlen) {
	    const OPCODE op = OP(progi->regstclass);
	    /* don't bother with what can't match */
	    if (PL_regkind[op] != EXACT && PL_regkind[op] != TRIE)
	        strend = HOPc(strend, -(minlen - 1));
	}
	DEBUG_EXECUTE_r({
	    SV * const prop = sv_newmortal();
            regprop(prog, prop, c, reginfo, NULL);
	    {
		RE_PV_QUOTED_DECL(quoted,utf8_target,PERL_DEBUG_PAD_ZERO(1),
		    s,strend-s,60);
                Perl_re_printf( aTHX_
		    "Matching stclass %.*s against %s (%d bytes)\n",
		    (int)SvCUR(prop), SvPVX_const(prop),
		     quoted, (int)(strend - s));
	    }
	});
        if (find_byclass(prog, c, s, strend, reginfo))
	    goto got_it;
        DEBUG_EXECUTE_r(Perl_re_printf( aTHX_  "Contradicts stclass... [regexec_flags]\n"));
    }
    else {
	dontbother = 0;
	if (prog->float_substr != NULL || prog->float_utf8 != NULL) {
	    /* Trim the end. */
	    char *last= NULL;
	    SV* float_real;
	    STRLEN len;
	    const char *little;

	    if (utf8_target) {
                if (! prog->float_utf8) {
                    to_utf8_substr(prog);
                }
                float_real = prog->float_utf8;
            }
            else {
                if (! prog->float_substr) {
                    if (! to_byte_substr(prog)) {
                        NON_UTF8_TARGET_BUT_UTF8_REQUIRED(phooey);
                    }
                }
                float_real = prog->float_substr;
            }

            little = SvPV_const(float_real, len);
	    if (SvTAIL(float_real)) {
                    /* This means that float_real contains an artificial \n on
                     * the end due to the presence of something like this:
                     * /foo$/ where we can match both "foo" and "foo\n" at the
                     * end of the string.  So we have to compare the end of the
                     * string first against the float_real without the \n and
                     * then against the full float_real with the string.  We
                     * have to watch out for cases where the string might be
                     * smaller than the float_real or the float_real without
                     * the \n. */
		    char *checkpos= strend - len;
		    DEBUG_OPTIMISE_r(
                        Perl_re_printf( aTHX_
			    "%sChecking for float_real.%s\n",
			    PL_colors[4], PL_colors[5]));
		    if (checkpos + 1 < strbeg) {
                        /* can't match, even if we remove the trailing \n
                         * string is too short to match */
			DEBUG_EXECUTE_r(
                            Perl_re_printf( aTHX_
				"%sString shorter than required trailing substring, cannot match.%s\n",
				PL_colors[4], PL_colors[5]));
			goto phooey;
		    } else if (memEQ(checkpos + 1, little, len - 1)) {
                        /* can match, the end of the string matches without the
                         * "\n" */
			last = checkpos + 1;
		    } else if (checkpos < strbeg) {
                        /* cant match, string is too short when the "\n" is
                         * included */
			DEBUG_EXECUTE_r(
                            Perl_re_printf( aTHX_
				"%sString does not contain required trailing substring, cannot match.%s\n",
				PL_colors[4], PL_colors[5]));
			goto phooey;
		    } else if (!multiline) {
                        /* non multiline match, so compare with the "\n" at the
                         * end of the string */
			if (memEQ(checkpos, little, len)) {
			    last= checkpos;
			} else {
			    DEBUG_EXECUTE_r(
                                Perl_re_printf( aTHX_
				    "%sString does not contain required trailing substring, cannot match.%s\n",
				    PL_colors[4], PL_colors[5]));
			    goto phooey;
			}
		    } else {
                        /* multiline match, so we have to search for a place
                         * where the full string is located */
			goto find_last;
		    }
	    } else {
		  find_last:
		    if (len)
			last = rninstr(s, strend, little, little + len);
		    else
			last = strend;	/* matching "$" */
	    }
	    if (!last) {
                /* at one point this block contained a comment which was
                 * probably incorrect, which said that this was a "should not
                 * happen" case.  Even if it was true when it was written I am
                 * pretty sure it is not anymore, so I have removed the comment
                 * and replaced it with this one. Yves */
		DEBUG_EXECUTE_r(
                    Perl_re_printf( aTHX_
			"%sString does not contain required substring, cannot match.%s\n",
                        PL_colors[4], PL_colors[5]
	            ));
		goto phooey;
	    }
	    dontbother = strend - last + prog->float_min_offset;
	}
	if (minlen && (dontbother < minlen))
	    dontbother = minlen - 1;
	strend -= dontbother; 		   /* this one's always in bytes! */
	/* We don't know much -- general case. */
	if (utf8_target) {
	    for (;;) {
		if (regtry(reginfo, &s))
		    goto got_it;
		if (s >= strend)
		    break;
		s += UTF8SKIP(s);
	    };
	}
	else {
	    do {
		if (regtry(reginfo, &s))
		    goto got_it;
	    } while (s++ < strend);
	}
    }

    /* Failure. */
    goto phooey;

  got_it:
    /* s/// doesn't like it if $& is earlier than where we asked it to
     * start searching (which can happen on something like /.\G/) */
    if (       (flags & REXEC_FAIL_ON_UNDERFLOW)
            && (prog->offs[0].start < stringarg - strbeg))
    {
        /* this should only be possible under \G */
        assert(prog->intflags & PREGf_GPOS_SEEN);
        DEBUG_EXECUTE_r(Perl_re_printf( aTHX_
            "matched, but failing for REXEC_FAIL_ON_UNDERFLOW\n"));
        goto phooey;
    }

    DEBUG_BUFFERS_r(
	if (swap)
            Perl_re_printf( aTHX_
		"rex=0x%"UVxf" freeing offs: 0x%"UVxf"\n",
		PTR2UV(prog),
		PTR2UV(swap)
	    );
    );
    Safefree(swap);

    /* clean up; this will trigger destructors that will free all slabs
     * above the current one, and cleanup the regmatch_info_aux
     * and regmatch_info_aux_eval sructs */

    LEAVE_SCOPE(oldsave);

    if (RXp_PAREN_NAMES(prog)) 
        (void)hv_iterinit(RXp_PAREN_NAMES(prog));

    /* make sure $`, $&, $', and $digit will work later */
    if ( !(flags & REXEC_NOT_FIRST) )
        S_reg_set_capture_string(aTHX_ rx,
                                    strbeg, reginfo->strend,
                                    sv, flags, utf8_target);

    return 1;

  phooey:
    DEBUG_EXECUTE_r(Perl_re_printf( aTHX_  "%sMatch failed%s\n",
			  PL_colors[4], PL_colors[5]));

    /* clean up; this will trigger destructors that will free all slabs
     * above the current one, and cleanup the regmatch_info_aux
     * and regmatch_info_aux_eval sructs */

    LEAVE_SCOPE(oldsave);

    if (swap) {
        /* we failed :-( roll it back */
        DEBUG_BUFFERS_r(Perl_re_printf( aTHX_
	    "rex=0x%"UVxf" rolling back offs: freeing=0x%"UVxf" restoring=0x%"UVxf"\n",
	    PTR2UV(prog),
	    PTR2UV(prog->offs),
	    PTR2UV(swap)
	));
        Safefree(prog->offs);
        prog->offs = swap;
    }
    return 0;
}


/* Set which rex is pointed to by PL_reg_curpm, handling ref counting.
 * Do inc before dec, in case old and new rex are the same */
#define SET_reg_curpm(Re2)                          \
    if (reginfo->info_aux_eval) {                   \
	(void)ReREFCNT_inc(Re2);		    \
	ReREFCNT_dec(PM_GETRE(PL_reg_curpm));	    \
	PM_SETRE((PL_reg_curpm), (Re2));	    \
    }


/*
 - regtry - try match at specific point
 */
STATIC bool			/* 0 failure, 1 success */
S_regtry(pTHX_ regmatch_info *reginfo, char **startposp)
{
    CHECKPOINT lastcp;
    REGEXP *const rx = reginfo->prog;
    regexp *const prog = ReANY(rx);
    SSize_t result;
#ifdef DEBUGGING
    U32 depth = 0; /* used by REGCP_SET */
#endif
    RXi_GET_DECL(prog,progi);
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_REGTRY;

    reginfo->cutpoint=NULL;

    prog->offs[0].start = *startposp - reginfo->strbeg;
    prog->lastparen = 0;
    prog->lastcloseparen = 0;

    /* XXXX What this code is doing here?!!!  There should be no need
       to do this again and again, prog->lastparen should take care of
       this!  --ilya*/

    /* Tests pat.t#187 and split.t#{13,14} seem to depend on this code.
     * Actually, the code in regcppop() (which Ilya may be meaning by
     * prog->lastparen), is not needed at all by the test suite
     * (op/regexp, op/pat, op/split), but that code is needed otherwise
     * this erroneously leaves $1 defined: "1" =~ /^(?:(\d)x)?\d$/
     * Meanwhile, this code *is* needed for the
     * above-mentioned test suite tests to succeed.  The common theme
     * on those tests seems to be returning null fields from matches.
     * --jhi updated by dapm */
#if 1
    if (prog->nparens) {
	regexp_paren_pair *pp = prog->offs;
	I32 i;
	for (i = prog->nparens; i > (I32)prog->lastparen; i--) {
	    ++pp;
	    pp->start = -1;
	    pp->end = -1;
	}
    }
#endif
    REGCP_SET(lastcp);
    result = regmatch(reginfo, *startposp, progi->program + 1);
    if (result != -1) {
	prog->offs[0].end = result;
	return 1;
    }
    if (reginfo->cutpoint)
        *startposp= reginfo->cutpoint;
    REGCP_UNWIND(lastcp);
    return 0;
}


#define sayYES goto yes
#define sayNO goto no
#define sayNO_SILENT goto no_silent

/* we dont use STMT_START/END here because it leads to 
   "unreachable code" warnings, which are bogus, but distracting. */
#define CACHEsayNO \
    if (ST.cache_mask) \
       reginfo->info_aux->poscache[ST.cache_offset] |= ST.cache_mask; \
    sayNO

/* this is used to determine how far from the left messages like
   'failed...' are printed in regexec.c. It should be set such that
   messages are inline with the regop output that created them.
*/
#define REPORT_CODE_OFF 29
#define INDENT_CHARS(depth) ((int)(depth) % 20)
#ifdef DEBUGGING
int
Perl_re_exec_indentf(pTHX_ const char *fmt, U32 depth, ...)
{
    va_list ap;
    int result;
    PerlIO *f= Perl_debug_log;
    PERL_ARGS_ASSERT_RE_EXEC_INDENTF;
    va_start(ap, depth);
    PerlIO_printf(f, "%*s|%4"UVuf"| %*s", REPORT_CODE_OFF, "", (UV)depth, INDENT_CHARS(depth), "" );
    result = PerlIO_vprintf(f, fmt, ap);
    va_end(ap);
    return result;
}
#endif /* DEBUGGING */


#define CHRTEST_UNINIT -1001 /* c1/c2 haven't been calculated yet */
#define CHRTEST_VOID   -1000 /* the c1/c2 "next char" test should be skipped */
#define CHRTEST_NOT_A_CP_1 -999
#define CHRTEST_NOT_A_CP_2 -998

/* grab a new slab and return the first slot in it */

STATIC regmatch_state *
S_push_slab(pTHX)
{
#if PERL_VERSION < 9 && !defined(PERL_CORE)
    dMY_CXT;
#endif
    regmatch_slab *s = PL_regmatch_slab->next;
    if (!s) {
	Newx(s, 1, regmatch_slab);
	s->prev = PL_regmatch_slab;
	s->next = NULL;
	PL_regmatch_slab->next = s;
    }
    PL_regmatch_slab = s;
    return SLAB_FIRST(s);
}


/* push a new state then goto it */

#define PUSH_STATE_GOTO(state, node, input) \
    pushinput = input; \
    scan = node; \
    st->resume_state = state; \
    goto push_state;

/* push a new state with success backtracking, then goto it */

#define PUSH_YES_STATE_GOTO(state, node, input) \
    pushinput = input; \
    scan = node; \
    st->resume_state = state; \
    goto push_yes_state;




/*

regmatch() - main matching routine

This is basically one big switch statement in a loop. We execute an op,
set 'next' to point the next op, and continue. If we come to a point which
we may need to backtrack to on failure such as (A|B|C), we push a
backtrack state onto the backtrack stack. On failure, we pop the top
state, and re-enter the loop at the state indicated. If there are no more
states to pop, we return failure.

Sometimes we also need to backtrack on success; for example /A+/, where
after successfully matching one A, we need to go back and try to
match another one; similarly for lookahead assertions: if the assertion
completes successfully, we backtrack to the state just before the assertion
and then carry on.  In these cases, the pushed state is marked as
'backtrack on success too'. This marking is in fact done by a chain of
pointers, each pointing to the previous 'yes' state. On success, we pop to
the nearest yes state, discarding any intermediate failure-only states.
Sometimes a yes state is pushed just to force some cleanup code to be
called at the end of a successful match or submatch; e.g. (??{$re}) uses
it to free the inner regex.

Note that failure backtracking rewinds the cursor position, while
success backtracking leaves it alone.

A pattern is complete when the END op is executed, while a subpattern
such as (?=foo) is complete when the SUCCESS op is executed. Both of these
ops trigger the "pop to last yes state if any, otherwise return true"
behaviour.

A common convention in this function is to use A and B to refer to the two
subpatterns (or to the first nodes thereof) in patterns like /A*B/: so A is
the subpattern to be matched possibly multiple times, while B is the entire
rest of the pattern. Variable and state names reflect this convention.

The states in the main switch are the union of ops and failure/success of
substates associated with with that op.  For example, IFMATCH is the op
that does lookahead assertions /(?=A)B/ and so the IFMATCH state means
'execute IFMATCH'; while IFMATCH_A is a state saying that we have just
successfully matched A and IFMATCH_A_fail is a state saying that we have
just failed to match A. Resume states always come in pairs. The backtrack
state we push is marked as 'IFMATCH_A', but when that is popped, we resume
at IFMATCH_A or IFMATCH_A_fail, depending on whether we are backtracking
on success or failure.

The struct that holds a backtracking state is actually a big union, with
one variant for each major type of op. The variable st points to the
top-most backtrack struct. To make the code clearer, within each
block of code we #define ST to alias the relevant union.

Here's a concrete example of a (vastly oversimplified) IFMATCH
implementation:

    switch (state) {
    ....

#define ST st->u.ifmatch

    case IFMATCH: // we are executing the IFMATCH op, (?=A)B
	ST.foo = ...; // some state we wish to save
	...
	// push a yes backtrack state with a resume value of
	// IFMATCH_A/IFMATCH_A_fail, then continue execution at the
	// first node of A:
	PUSH_YES_STATE_GOTO(IFMATCH_A, A, newinput);
	// NOTREACHED

    case IFMATCH_A: // we have successfully executed A; now continue with B
	next = B;
	bar = ST.foo; // do something with the preserved value
	break;

    case IFMATCH_A_fail: // A failed, so the assertion failed
	...;   // do some housekeeping, then ...
	sayNO; // propagate the failure

#undef ST

    ...
    }

For any old-timers reading this who are familiar with the old recursive
approach, the code above is equivalent to:

    case IFMATCH: // we are executing the IFMATCH op, (?=A)B
    {
	int foo = ...
	...
	if (regmatch(A)) {
	    next = B;
	    bar = foo;
	    break;
	}
	...;   // do some housekeeping, then ...
	sayNO; // propagate the failure
    }

The topmost backtrack state, pointed to by st, is usually free. If you
want to claim it, populate any ST.foo fields in it with values you wish to
save, then do one of

	PUSH_STATE_GOTO(resume_state, node, newinput);
	PUSH_YES_STATE_GOTO(resume_state, node, newinput);

which sets that backtrack state's resume value to 'resume_state', pushes a
new free entry to the top of the backtrack stack, then goes to 'node'.
On backtracking, the free slot is popped, and the saved state becomes the
new free state. An ST.foo field in this new top state can be temporarily
accessed to retrieve values, but once the main loop is re-entered, it
becomes available for reuse.

Note that the depth of the backtrack stack constantly increases during the
left-to-right execution of the pattern, rather than going up and down with
the pattern nesting. For example the stack is at its maximum at Z at the
end of the pattern, rather than at X in the following:

    /(((X)+)+)+....(Y)+....Z/

The only exceptions to this are lookahead/behind assertions and the cut,
(?>A), which pop all the backtrack states associated with A before
continuing.
 
Backtrack state structs are allocated in slabs of about 4K in size.
PL_regmatch_state and st always point to the currently active state,
and PL_regmatch_slab points to the slab currently containing
PL_regmatch_state.  The first time regmatch() is called, the first slab is
allocated, and is never freed until interpreter destruction. When the slab
is full, a new one is allocated and chained to the end. At exit from
regmatch(), slabs allocated since entry are freed.

*/
 

#define DEBUG_STATE_pp(pp)                                  \
    DEBUG_STATE_r({                                         \
        DUMP_EXEC_POS(locinput, scan, utf8_target,depth);   \
        Perl_re_printf( aTHX_                                           \
            "%*s" pp " %s%s%s%s%s\n",                       \
            INDENT_CHARS(depth), "",                        \
            PL_reg_name[st->resume_state],                  \
            ((st==yes_state||st==mark_state) ? "[" : ""),   \
            ((st==yes_state) ? "Y" : ""),                   \
            ((st==mark_state) ? "M" : ""),                  \
            ((st==yes_state||st==mark_state) ? "]" : "")    \
        );                                                  \
    });


#define REG_NODE_NUM(x) ((x) ? (int)((x)-prog) : -1)

#ifdef DEBUGGING

STATIC void
S_debug_start_match(pTHX_ const REGEXP *prog, const bool utf8_target,
    const char *start, const char *end, const char *blurb)
{
    const bool utf8_pat = RX_UTF8(prog) ? 1 : 0;

    PERL_ARGS_ASSERT_DEBUG_START_MATCH;

    if (!PL_colorset)   
            reginitcolors();    
    {
        RE_PV_QUOTED_DECL(s0, utf8_pat, PERL_DEBUG_PAD_ZERO(0), 
            RX_PRECOMP_const(prog), RX_PRELEN(prog), 60);   
        
        RE_PV_QUOTED_DECL(s1, utf8_target, PERL_DEBUG_PAD_ZERO(1),
            start, end - start, 60); 
        
        Perl_re_printf( aTHX_
            "%s%s REx%s %s against %s\n", 
		       PL_colors[4], blurb, PL_colors[5], s0, s1); 
        
        if (utf8_target||utf8_pat)
            Perl_re_printf( aTHX_  "UTF-8 %s%s%s...\n",
                utf8_pat ? "pattern" : "",
                utf8_pat && utf8_target ? " and " : "",
                utf8_target ? "string" : ""
            ); 
    }
}

STATIC void
S_dump_exec_pos(pTHX_ const char *locinput, 
                      const regnode *scan, 
                      const char *loc_regeol, 
                      const char *loc_bostr, 
                      const char *loc_reg_starttry,
                      const bool utf8_target,
                      const U32 depth
                )
{
    const int docolor = *PL_colors[0] || *PL_colors[2] || *PL_colors[4];
    const int taill = (docolor ? 10 : 7); /* 3 chars for "> <" */
    int l = (loc_regeol - locinput) > taill ? taill : (loc_regeol - locinput);
    /* The part of the string before starttry has one color
       (pref0_len chars), between starttry and current
       position another one (pref_len - pref0_len chars),
       after the current position the third one.
       We assume that pref0_len <= pref_len, otherwise we
       decrease pref0_len.  */
    int pref_len = (locinput - loc_bostr) > (5 + taill) - l
	? (5 + taill) - l : locinput - loc_bostr;
    int pref0_len;

    PERL_ARGS_ASSERT_DUMP_EXEC_POS;

    while (utf8_target && UTF8_IS_CONTINUATION(*(U8*)(locinput - pref_len)))
	pref_len++;
    pref0_len = pref_len  - (locinput - loc_reg_starttry);
    if (l + pref_len < (5 + taill) && l < loc_regeol - locinput)
	l = ( loc_regeol - locinput > (5 + taill) - pref_len
	      ? (5 + taill) - pref_len : loc_regeol - locinput);
    while (utf8_target && UTF8_IS_CONTINUATION(*(U8*)(locinput + l)))
	l--;
    if (pref0_len < 0)
	pref0_len = 0;
    if (pref0_len > pref_len)
	pref0_len = pref_len;
    {
	const int is_uni = utf8_target ? 1 : 0;

	RE_PV_COLOR_DECL(s0,len0,is_uni,PERL_DEBUG_PAD(0),
	    (locinput - pref_len),pref0_len, 60, 4, 5);
	
	RE_PV_COLOR_DECL(s1,len1,is_uni,PERL_DEBUG_PAD(1),
		    (locinput - pref_len + pref0_len),
		    pref_len - pref0_len, 60, 2, 3);
	
	RE_PV_COLOR_DECL(s2,len2,is_uni,PERL_DEBUG_PAD(2),
		    locinput, loc_regeol - locinput, 10, 0, 1);

	const STRLEN tlen=len0+len1+len2;
        Perl_re_printf( aTHX_
                    "%4"IVdf" <%.*s%.*s%s%.*s>%*s|%4u| ",
		    (IV)(locinput - loc_bostr),
		    len0, s0,
		    len1, s1,
		    (docolor ? "" : "> <"),
		    len2, s2,
		    (int)(tlen > 19 ? 0 :  19 - tlen),
                    "",
                    depth);
    }
}

#endif

/* reg_check_named_buff_matched()
 * Checks to see if a named buffer has matched. The data array of 
 * buffer numbers corresponding to the buffer is expected to reside
 * in the regexp->data->data array in the slot stored in the ARG() of
 * node involved. Note that this routine doesn't actually care about the
 * name, that information is not preserved from compilation to execution.
 * Returns the index of the leftmost defined buffer with the given name
 * or 0 if non of the buffers matched.
 */
STATIC I32
S_reg_check_named_buff_matched(const regexp *rex, const regnode *scan)
{
    I32 n;
    RXi_GET_DECL(rex,rexi);
    SV *sv_dat= MUTABLE_SV(rexi->data->data[ ARG( scan ) ]);
    I32 *nums=(I32*)SvPVX(sv_dat);

    PERL_ARGS_ASSERT_REG_CHECK_NAMED_BUFF_MATCHED;

    for ( n=0; n<SvIVX(sv_dat); n++ ) {
        if ((I32)rex->lastparen >= nums[n] &&
            rex->offs[nums[n]].end != -1)
        {
            return nums[n];
        }
    }
    return 0;
}


static bool
S_setup_EXACTISH_ST_c1_c2(pTHX_ const regnode * const text_node, int *c1p,
        U8* c1_utf8, int *c2p, U8* c2_utf8, regmatch_info *reginfo)
{
    /* This function determines if there are one or two characters that match
     * the first character of the passed-in EXACTish node <text_node>, and if
     * so, returns them in the passed-in pointers.
     *
     * If it determines that no possible character in the target string can
     * match, it returns FALSE; otherwise TRUE.  (The FALSE situation occurs if
     * the first character in <text_node> requires UTF-8 to represent, and the
     * target string isn't in UTF-8.)
     *
     * If there are more than two characters that could match the beginning of
     * <text_node>, or if more context is required to determine a match or not,
     * it sets both *<c1p> and *<c2p> to CHRTEST_VOID.
     *
     * The motiviation behind this function is to allow the caller to set up
     * tight loops for matching.  If <text_node> is of type EXACT, there is
     * only one possible character that can match its first character, and so
     * the situation is quite simple.  But things get much more complicated if
     * folding is involved.  It may be that the first character of an EXACTFish
     * node doesn't participate in any possible fold, e.g., punctuation, so it
     * can be matched only by itself.  The vast majority of characters that are
     * in folds match just two things, their lower and upper-case equivalents.
     * But not all are like that; some have multiple possible matches, or match
     * sequences of more than one character.  This function sorts all that out.
     *
     * Consider the patterns A*B or A*?B where A and B are arbitrary.  In a
     * loop of trying to match A*, we know we can't exit where the thing
     * following it isn't a B.  And something can't be a B unless it is the
     * beginning of B.  By putting a quick test for that beginning in a tight
     * loop, we can rule out things that can't possibly be B without having to
     * break out of the loop, thus avoiding work.  Similarly, if A is a single
     * character, we can make a tight loop matching A*, using the outputs of
     * this function.
     *
     * If the target string to match isn't in UTF-8, and there aren't
     * complications which require CHRTEST_VOID, *<c1p> and *<c2p> are set to
     * the one or two possible octets (which are characters in this situation)
     * that can match.  In all cases, if there is only one character that can
     * match, *<c1p> and *<c2p> will be identical.
     *
     * If the target string is in UTF-8, the buffers pointed to by <c1_utf8>
     * and <c2_utf8> will contain the one or two UTF-8 sequences of bytes that
     * can match the beginning of <text_node>.  They should be declared with at
     * least length UTF8_MAXBYTES+1.  (If the target string isn't in UTF-8, it is
     * undefined what these contain.)  If one or both of the buffers are
     * invariant under UTF-8, *<c1p>, and *<c2p> will also be set to the
     * corresponding invariant.  If variant, the corresponding *<c1p> and/or
     * *<c2p> will be set to a negative number(s) that shouldn't match any code
     * point (unless inappropriately coerced to unsigned).   *<c1p> will equal
     * *<c2p> if and only if <c1_utf8> and <c2_utf8> are the same. */

    const bool utf8_target = reginfo->is_utf8_target;

    UV c1 = (UV)CHRTEST_NOT_A_CP_1;
    UV c2 = (UV)CHRTEST_NOT_A_CP_2;
    bool use_chrtest_void = FALSE;
    const bool is_utf8_pat = reginfo->is_utf8_pat;

    /* Used when we have both utf8 input and utf8 output, to avoid converting
     * to/from code points */
    bool utf8_has_been_setup = FALSE;

    dVAR;

    U8 *pat = (U8*)STRING(text_node);
    U8 folded[UTF8_MAX_FOLD_CHAR_EXPAND * UTF8_MAXBYTES_CASE + 1] = { '\0' };

    if (OP(text_node) == EXACT || OP(text_node) == EXACTL) {

        /* In an exact node, only one thing can be matched, that first
         * character.  If both the pat and the target are UTF-8, we can just
         * copy the input to the output, avoiding finding the code point of
         * that character */
        if (!is_utf8_pat) {
            c2 = c1 = *pat;
        }
        else if (utf8_target) {
            Copy(pat, c1_utf8, UTF8SKIP(pat), U8);
            Copy(pat, c2_utf8, UTF8SKIP(pat), U8);
            utf8_has_been_setup = TRUE;
        }
        else {
            c2 = c1 = valid_utf8_to_uvchr(pat, NULL);
        }
    }
    else { /* an EXACTFish node */
        U8 *pat_end = pat + STR_LEN(text_node);

        /* An EXACTFL node has at least some characters unfolded, because what
         * they match is not known until now.  So, now is the time to fold
         * the first few of them, as many as are needed to determine 'c1' and
         * 'c2' later in the routine.  If the pattern isn't UTF-8, we only need
         * to fold if in a UTF-8 locale, and then only the Sharp S; everything
         * else is 1-1 and isn't assumed to be folded.  In a UTF-8 pattern, we
         * need to fold as many characters as a single character can fold to,
         * so that later we can check if the first ones are such a multi-char
         * fold.  But, in such a pattern only locale-problematic characters
         * aren't folded, so we can skip this completely if the first character
         * in the node isn't one of the tricky ones */
        if (OP(text_node) == EXACTFL) {

            if (! is_utf8_pat) {
                if (IN_UTF8_CTYPE_LOCALE && *pat == LATIN_SMALL_LETTER_SHARP_S)
                {
                    folded[0] = folded[1] = 's';
                    pat = folded;
                    pat_end = folded + 2;
                }
            }
            else if (is_PROBLEMATIC_LOCALE_FOLDEDS_START_utf8(pat)) {
                U8 *s = pat;
                U8 *d = folded;
                int i;

                for (i = 0; i < UTF8_MAX_FOLD_CHAR_EXPAND && s < pat_end; i++) {
                    if (isASCII(*s)) {
                        *(d++) = (U8) toFOLD_LC(*s);
                        s++;
                    }
                    else {
                        STRLEN len;
                        _to_utf8_fold_flags(s,
                                            d,
                                            &len,
                                            FOLD_FLAGS_FULL | FOLD_FLAGS_LOCALE);
                        d += len;
                        s += UTF8SKIP(s);
                    }
                }

                pat = folded;
                pat_end = d;
            }
        }

        if ((is_utf8_pat && is_MULTI_CHAR_FOLD_utf8_safe(pat, pat_end))
             || (!is_utf8_pat && is_MULTI_CHAR_FOLD_latin1_safe(pat, pat_end)))
        {
            /* Multi-character folds require more context to sort out.  Also
             * PL_utf8_foldclosures used below doesn't handle them, so have to
             * be handled outside this routine */
            use_chrtest_void = TRUE;
        }
        else { /* an EXACTFish node which doesn't begin with a multi-char fold */
            c1 = is_utf8_pat ? valid_utf8_to_uvchr(pat, NULL) : *pat;
            if (c1 > 255) {
                /* Load the folds hash, if not already done */
                SV** listp;
                if (! PL_utf8_foldclosures) {
                    _load_PL_utf8_foldclosures();
                }

                /* The fold closures data structure is a hash with the keys
                 * being the UTF-8 of every character that is folded to, like
                 * 'k', and the values each an array of all code points that
                 * fold to its key.  e.g. [ 'k', 'K', KELVIN_SIGN ].
                 * Multi-character folds are not included */
                if ((! (listp = hv_fetch(PL_utf8_foldclosures,
                                        (char *) pat,
                                        UTF8SKIP(pat),
                                        FALSE))))
                {
                    /* Not found in the hash, therefore there are no folds
                    * containing it, so there is only a single character that
                    * could match */
                    c2 = c1;
                }
                else {  /* Does participate in folds */
                    AV* list = (AV*) *listp;
                    if (av_tindex_nomg(list) != 1) {

                        /* If there aren't exactly two folds to this, it is
                         * outside the scope of this function */
                        use_chrtest_void = TRUE;
                    }
                    else {  /* There are two.  Get them */
                        SV** c_p = av_fetch(list, 0, FALSE);
                        if (c_p == NULL) {
                            Perl_croak(aTHX_ "panic: invalid PL_utf8_foldclosures structure");
                        }
                        c1 = SvUV(*c_p);

                        c_p = av_fetch(list, 1, FALSE);
                        if (c_p == NULL) {
                            Perl_croak(aTHX_ "panic: invalid PL_utf8_foldclosures structure");
                        }
                        c2 = SvUV(*c_p);

                        /* Folds that cross the 255/256 boundary are forbidden
                         * if EXACTFL (and isnt a UTF8 locale), or EXACTFA and
                         * one is ASCIII.  Since the pattern character is above
                         * 255, and its only other match is below 256, the only
                         * legal match will be to itself.  We have thrown away
                         * the original, so have to compute which is the one
                         * above 255. */
                        if ((c1 < 256) != (c2 < 256)) {
                            if ((OP(text_node) == EXACTFL
                                 && ! IN_UTF8_CTYPE_LOCALE)
                                || ((OP(text_node) == EXACTFA
                                    || OP(text_node) == EXACTFA_NO_TRIE)
                                    && (isASCII(c1) || isASCII(c2))))
                            {
                                if (c1 < 256) {
                                    c1 = c2;
                                }
                                else {
                                    c2 = c1;
                                }
                            }
                        }
                    }
                }
            }
            else /* Here, c1 is <= 255 */
                if (utf8_target
                    && HAS_NONLATIN1_FOLD_CLOSURE(c1)
                    && ( ! (OP(text_node) == EXACTFL && ! IN_UTF8_CTYPE_LOCALE))
                    && ((OP(text_node) != EXACTFA
                        && OP(text_node) != EXACTFA_NO_TRIE)
                        || ! isASCII(c1)))
            {
                /* Here, there could be something above Latin1 in the target
                 * which folds to this character in the pattern.  All such
                 * cases except LATIN SMALL LETTER Y WITH DIAERESIS have more
                 * than two characters involved in their folds, so are outside
                 * the scope of this function */
                if (UNLIKELY(c1 == LATIN_SMALL_LETTER_Y_WITH_DIAERESIS)) {
                    c2 = LATIN_CAPITAL_LETTER_Y_WITH_DIAERESIS;
                }
                else {
                    use_chrtest_void = TRUE;
                }
            }
            else { /* Here nothing above Latin1 can fold to the pattern
                      character */
                switch (OP(text_node)) {

                    case EXACTFL:   /* /l rules */
                        c2 = PL_fold_locale[c1];
                        break;

                    case EXACTF:   /* This node only generated for non-utf8
                                    patterns */
                        assert(! is_utf8_pat);
                        if (! utf8_target) {    /* /d rules */
                            c2 = PL_fold[c1];
                            break;
                        }
                        /* FALLTHROUGH */
                        /* /u rules for all these.  This happens to work for
                        * EXACTFA as nothing in Latin1 folds to ASCII */
                    case EXACTFA_NO_TRIE:   /* This node only generated for
                                            non-utf8 patterns */
                        assert(! is_utf8_pat);
                        /* FALLTHROUGH */
                    case EXACTFA:
                    case EXACTFU_SS:
                    case EXACTFU:
                        c2 = PL_fold_latin1[c1];
                        break;

                    default:
                        Perl_croak(aTHX_ "panic: Unexpected op %u", OP(text_node));
                        NOT_REACHED; /* NOTREACHED */
                }
            }
        }
    }

    /* Here have figured things out.  Set up the returns */
    if (use_chrtest_void) {
        *c2p = *c1p = CHRTEST_VOID;
    }
    else if (utf8_target) {
        if (! utf8_has_been_setup) {    /* Don't have the utf8; must get it */
            uvchr_to_utf8(c1_utf8, c1);
            uvchr_to_utf8(c2_utf8, c2);
        }

        /* Invariants are stored in both the utf8 and byte outputs; Use
         * negative numbers otherwise for the byte ones.  Make sure that the
         * byte ones are the same iff the utf8 ones are the same */
        *c1p = (UTF8_IS_INVARIANT(*c1_utf8)) ? *c1_utf8 : CHRTEST_NOT_A_CP_1;
        *c2p = (UTF8_IS_INVARIANT(*c2_utf8))
                ? *c2_utf8
                : (c1 == c2)
                  ? CHRTEST_NOT_A_CP_1
                  : CHRTEST_NOT_A_CP_2;
    }
    else if (c1 > 255) {
       if (c2 > 255) {  /* both possibilities are above what a non-utf8 string
                           can represent */
           return FALSE;
       }

       *c1p = *c2p = c2;    /* c2 is the only representable value */
    }
    else {  /* c1 is representable; see about c2 */
       *c1p = c1;
       *c2p = (c2 < 256) ? c2 : c1;
    }

    return TRUE;
}

PERL_STATIC_INLINE bool
S_isGCB(const GCB_enum before, const GCB_enum after)
{
    /* returns a boolean indicating if there is a Grapheme Cluster Boundary
     * between the inputs.  See http://www.unicode.org/reports/tr29/ */

    return GCB_table[before][after];
}

/* Combining marks attach to most classes that precede them, but this defines
 * the exceptions (from TR14) */
#define LB_CM_ATTACHES_TO(prev) ( ! (   prev == LB_EDGE                 \
                                     || prev == LB_Mandatory_Break      \
                                     || prev == LB_Carriage_Return      \
                                     || prev == LB_Line_Feed            \
                                     || prev == LB_Next_Line            \
                                     || prev == LB_Space                \
                                     || prev == LB_ZWSpace))

STATIC bool
S_isLB(pTHX_ LB_enum before,
             LB_enum after,
             const U8 * const strbeg,
             const U8 * const curpos,
             const U8 * const strend,
             const bool utf8_target)
{
    U8 * temp_pos = (U8 *) curpos;
    LB_enum prev = before;

    /* Is the boundary between 'before' and 'after' line-breakable?
     * Most of this is just a table lookup of a generated table from Unicode
     * rules.  But some rules require context to decide, and so have to be
     * implemented in code */

    PERL_ARGS_ASSERT_ISLB;

    /* Rule numbers in the comments below are as of Unicode 8.0 */

  redo:
    before = prev;
    switch (LB_table[before][after]) {
        case LB_BREAKABLE:
            return TRUE;

        case LB_NOBREAK:
        case LB_NOBREAK_EVEN_WITH_SP_BETWEEN:
            return FALSE;

        case LB_SP_foo + LB_BREAKABLE:
        case LB_SP_foo + LB_NOBREAK:
        case LB_SP_foo + LB_NOBREAK_EVEN_WITH_SP_BETWEEN:

            /* When we have something following a SP, we have to look at the
             * context in order to know what to do.
             *
             * SP SP should not reach here because LB7: Do not break before
             * spaces.  (For two spaces in a row there is nothing that
             * overrides that) */
            assert(after != LB_Space);

            /* Here we have a space followed by a non-space.  Mostly this is a
             * case of LB18: "Break after spaces".  But there are complications
             * as the handling of spaces is somewhat tricky.  They are in a
             * number of rules, which have to be applied in priority order, but
             * something earlier in the string can cause a rule to be skipped
             * and a lower priority rule invoked.  A prime example is LB7 which
             * says don't break before a space.  But rule LB8 (lower priority)
             * says that the first break opportunity after a ZW is after any
             * span of spaces immediately after it.  If a ZW comes before a SP
             * in the input, rule LB8 applies, and not LB7.  Other such rules
             * involve combining marks which are rules 9 and 10, but they may
             * override higher priority rules if they come earlier in the
             * string.  Since we're doing random access into the middle of the
             * string, we have to look for rules that should get applied based
             * on both string position and priority.  Combining marks do not
             * attach to either ZW nor SP, so we don't have to consider them
             * until later.
             *
             * To check for LB8, we have to find the first non-space character
             * before this span of spaces */
            do {
                prev = backup_one_LB(strbeg, &temp_pos, utf8_target);
            }
            while (prev == LB_Space);

            /* LB8 Break before any character following a zero-width space,
             * even if one or more spaces intervene.
             *      ZW SP* ÷
             * So if we have a ZW just before this span, and to get here this
             * is the final space in the span. */
            if (prev == LB_ZWSpace) {
                return TRUE;
            }

            /* Here, not ZW SP+.  There are several rules that have higher
             * priority than LB18 and can be resolved now, as they don't depend
             * on anything earlier in the string (except ZW, which we have
             * already handled).  One of these rules is LB11 Do not break
             * before Word joiner, but we have specially encoded that in the
             * lookup table so it is caught by the single test below which
             * catches the other ones. */
            if (LB_table[LB_Space][after] - LB_SP_foo
                                            == LB_NOBREAK_EVEN_WITH_SP_BETWEEN)
            {
                return FALSE;
            }

            /* If we get here, we have to XXX consider combining marks. */
            if (prev == LB_Combining_Mark) {

                /* What happens with these depends on the character they
                 * follow.  */
                do {
                    prev = backup_one_LB(strbeg, &temp_pos, utf8_target);
                }
                while (prev == LB_Combining_Mark);

                /* Most times these attach to and inherit the characteristics
                 * of that character, but not always, and when not, they are to
                 * be treated as AL by rule LB10. */
                if (! LB_CM_ATTACHES_TO(prev)) {
                    prev = LB_Alphabetic;
                }
            }

            /* Here, we have the character preceding the span of spaces all set
             * up.  We follow LB18: "Break after spaces" unless the table shows
             * that is overriden */
            return LB_table[prev][after] != LB_NOBREAK_EVEN_WITH_SP_BETWEEN;

        case LB_CM_foo:

            /* We don't know how to treat the CM except by looking at the first
             * non-CM character preceding it */
            do {
                prev = backup_one_LB(strbeg, &temp_pos, utf8_target);
            }
            while (prev == LB_Combining_Mark);

            /* Here, 'prev' is that first earlier non-CM character.  If the CM
             * attatches to it, then it inherits the behavior of 'prev'.  If it
             * doesn't attach, it is to be treated as an AL */
            if (! LB_CM_ATTACHES_TO(prev)) {
                prev = LB_Alphabetic;
            }

            goto redo;

        case LB_HY_or_BA_then_foo + LB_BREAKABLE:
        case LB_HY_or_BA_then_foo + LB_NOBREAK:

            /* LB21a Don't break after Hebrew + Hyphen.
             * HL (HY | BA) × */

            if (backup_one_LB(strbeg, &temp_pos, utf8_target)
                                                          == LB_Hebrew_Letter)
            {
                return FALSE;
            }

            return LB_table[prev][after] - LB_HY_or_BA_then_foo == LB_BREAKABLE;

        case LB_PR_or_PO_then_OP_or_HY + LB_BREAKABLE:
        case LB_PR_or_PO_then_OP_or_HY + LB_NOBREAK:

            /* LB25a (PR | PO) × ( OP | HY )? NU */
            if (advance_one_LB(&temp_pos, strend, utf8_target) == LB_Numeric) {
                return FALSE;
            }

            return LB_table[prev][after] - LB_PR_or_PO_then_OP_or_HY
                                                                == LB_BREAKABLE;

        case LB_SY_or_IS_then_various + LB_BREAKABLE:
        case LB_SY_or_IS_then_various + LB_NOBREAK:
        {
            /* LB25d NU (SY | IS)* × (NU | SY | IS | CL | CP ) */

            LB_enum temp = prev;
            do {
                temp = backup_one_LB(strbeg, &temp_pos, utf8_target);
            }
            while (temp == LB_Break_Symbols || temp == LB_Infix_Numeric);
            if (temp == LB_Numeric) {
                return FALSE;
            }

            return LB_table[prev][after] - LB_SY_or_IS_then_various
                                                               == LB_BREAKABLE;
        }

        case LB_various_then_PO_or_PR + LB_BREAKABLE:
        case LB_various_then_PO_or_PR + LB_NOBREAK:
        {
            /* LB25e NU (SY | IS)* (CL | CP)? × (PO | PR) */

            LB_enum temp = prev;
            if (temp == LB_Close_Punctuation || temp == LB_Close_Parenthesis)
            {
                temp = backup_one_LB(strbeg, &temp_pos, utf8_target);
            }
            while (temp == LB_Break_Symbols || temp == LB_Infix_Numeric) {
                temp = backup_one_LB(strbeg, &temp_pos, utf8_target);
            }
            if (temp == LB_Numeric) {
                return FALSE;
            }
            return LB_various_then_PO_or_PR;
        }

        default:
            break;
    }

#ifdef DEBUGGING
    Perl_re_printf( aTHX_  "Unhandled LB pair: LB_table[%d, %d] = %d\n",
                                  before, after, LB_table[before][after]);
    assert(0);
#endif
    return TRUE;
}

STATIC LB_enum
S_advance_one_LB(pTHX_ U8 ** curpos, const U8 * const strend, const bool utf8_target)
{
    LB_enum lb;

    PERL_ARGS_ASSERT_ADVANCE_ONE_LB;

    if (*curpos >= strend) {
        return LB_EDGE;
    }

    if (utf8_target) {
        *curpos += UTF8SKIP(*curpos);
        if (*curpos >= strend) {
            return LB_EDGE;
        }
        lb = getLB_VAL_UTF8(*curpos, strend);
    }
    else {
        (*curpos)++;
        if (*curpos >= strend) {
            return LB_EDGE;
        }
        lb = getLB_VAL_CP(**curpos);
    }

    return lb;
}

STATIC LB_enum
S_backup_one_LB(pTHX_ const U8 * const strbeg, U8 ** curpos, const bool utf8_target)
{
    LB_enum lb;

    PERL_ARGS_ASSERT_BACKUP_ONE_LB;

    if (*curpos < strbeg) {
        return LB_EDGE;
    }

    if (utf8_target) {
        U8 * prev_char_pos = reghopmaybe3(*curpos, -1, strbeg);
        U8 * prev_prev_char_pos;

        if (! prev_char_pos) {
            return LB_EDGE;
        }

        if ((prev_prev_char_pos = reghopmaybe3((U8 *) prev_char_pos, -1, strbeg))) {
            lb = getLB_VAL_UTF8(prev_prev_char_pos, prev_char_pos);
            *curpos = prev_char_pos;
            prev_char_pos = prev_prev_char_pos;
        }
        else {
            *curpos = (U8 *) strbeg;
            return LB_EDGE;
        }
    }
    else {
        if (*curpos - 2 < strbeg) {
            *curpos = (U8 *) strbeg;
            return LB_EDGE;
        }
        (*curpos)--;
        lb = getLB_VAL_CP(*(*curpos - 1));
    }

    return lb;
}

STATIC bool
S_isSB(pTHX_ SB_enum before,
             SB_enum after,
             const U8 * const strbeg,
             const U8 * const curpos,
             const U8 * const strend,
             const bool utf8_target)
{
    /* returns a boolean indicating if there is a Sentence Boundary Break
     * between the inputs.  See http://www.unicode.org/reports/tr29/ */

    U8 * lpos = (U8 *) curpos;
    bool has_para_sep = FALSE;
    bool has_sp = FALSE;

    PERL_ARGS_ASSERT_ISSB;

    /* Break at the start and end of text.
        SB1.  sot  ÷
        SB2.  ÷  eot
      But unstated in Unicode is don't break if the text is empty */
    if (before == SB_EDGE || after == SB_EDGE) {
        return before != after;
    }

    /* SB 3: Do not break within CRLF. */
    if (before == SB_CR && after == SB_LF) {
        return FALSE;
    }

    /* Break after paragraph separators.  CR and LF are considered
     * so because Unicode views text as like word processing text where there
     * are no newlines except between paragraphs, and the word processor takes
     * care of wrapping without there being hard line-breaks in the text *./
       SB4.  Sep | CR | LF  ÷ */
    if (before == SB_Sep || before == SB_CR || before == SB_LF) {
        return TRUE;
    }

    /* Ignore Format and Extend characters, except after sot, Sep, CR, or LF.
     * (See Section 6.2, Replacing Ignore Rules.)
        SB5.  X (Extend | Format)*  →  X */
    if (after == SB_Extend || after == SB_Format) {

        /* Implied is that the these characters attach to everything
         * immediately prior to them except for those separator-type
         * characters.  And the rules earlier have already handled the case
         * when one of those immediately precedes the extend char */
        return FALSE;
    }

    if (before == SB_Extend || before == SB_Format) {
        U8 * temp_pos = lpos;
        const SB_enum backup = backup_one_SB(strbeg, &temp_pos, utf8_target);
        if (   backup != SB_EDGE
            && backup != SB_Sep
            && backup != SB_CR
            && backup != SB_LF)
        {
            before = backup;
            lpos = temp_pos;
        }

        /* Here, both 'before' and 'backup' are these types; implied is that we
         * don't break between them */
        if (backup == SB_Extend || backup == SB_Format) {
            return FALSE;
        }
    }

    /* Do not break after ambiguous terminators like period, if they are
     * immediately followed by a number or lowercase letter, if they are
     * between uppercase letters, if the first following letter (optionally
     * after certain punctuation) is lowercase, or if they are followed by
     * "continuation" punctuation such as comma, colon, or semicolon. For
     * example, a period may be an abbreviation or numeric period, and thus may
     * not mark the end of a sentence.

     * SB6. ATerm  ×  Numeric */
    if (before == SB_ATerm && after == SB_Numeric) {
        return FALSE;
    }

    /* SB7.  (Upper | Lower) ATerm  ×  Upper */
    if (before == SB_ATerm && after == SB_Upper) {
        U8 * temp_pos = lpos;
        SB_enum backup = backup_one_SB(strbeg, &temp_pos, utf8_target);
        if (backup == SB_Upper || backup == SB_Lower) {
            return FALSE;
        }
    }

    /* The remaining rules that aren't the final one, all require an STerm or
     * an ATerm after having backed up over some Close* Sp*, and in one case an
     * optional Paragraph separator, although one rule doesn't have any Sp's in it.
     * So do that backup now, setting flags if either Sp or a paragraph
     * separator are found */

    if (before == SB_Sep || before == SB_CR || before == SB_LF) {
        has_para_sep = TRUE;
        before = backup_one_SB(strbeg, &lpos, utf8_target);
    }

    if (before == SB_Sp) {
        has_sp = TRUE;
        do {
            before = backup_one_SB(strbeg, &lpos, utf8_target);
        }
        while (before == SB_Sp);
    }

    while (before == SB_Close) {
        before = backup_one_SB(strbeg, &lpos, utf8_target);
    }

    /* The next few rules apply only when the backed-up-to is an ATerm, and in
     * most cases an STerm */
    if (before == SB_STerm || before == SB_ATerm) {

        /* So, here the lhs matches
         *      (STerm | ATerm) Close* Sp* (Sep | CR | LF)?
         * and we have set flags if we found an Sp, or the optional Sep,CR,LF.
         * The rules that apply here are:
         *
         * SB8    ATerm Close* Sp*  ×  ( ¬(OLetter | Upper | Lower | Sep | CR
                                           | LF | STerm | ATerm) )* Lower
           SB8a  (STerm | ATerm) Close* Sp*  ×  (SContinue | STerm | ATerm)
           SB9   (STerm | ATerm) Close*  ×  (Close | Sp | Sep | CR | LF)
           SB10  (STerm | ATerm) Close* Sp*  ×  (Sp | Sep | CR | LF)
           SB11  (STerm | ATerm) Close* Sp* (Sep | CR | LF)?  ÷
         */

        /* And all but SB11 forbid having seen a paragraph separator */
        if (! has_para_sep) {
            if (before == SB_ATerm) {          /* SB8 */
                U8 * rpos = (U8 *) curpos;
                SB_enum later = after;

                while (    later != SB_OLetter
                        && later != SB_Upper
                        && later != SB_Lower
                        && later != SB_Sep
                        && later != SB_CR
                        && later != SB_LF
                        && later != SB_STerm
                        && later != SB_ATerm
                        && later != SB_EDGE)
                {
                    later = advance_one_SB(&rpos, strend, utf8_target);
                }
                if (later == SB_Lower) {
                    return FALSE;
                }
            }

            if (   after == SB_SContinue    /* SB8a */
                || after == SB_STerm
                || after == SB_ATerm)
            {
                return FALSE;
            }

            if (! has_sp) {     /* SB9 applies only if there was no Sp* */
                if (   after == SB_Close
                    || after == SB_Sp
                    || after == SB_Sep
                    || after == SB_CR
                    || after == SB_LF)
                {
                    return FALSE;
                }
            }

            /* SB10.  This and SB9 could probably be combined some way, but khw
             * has decided to follow the Unicode rule book precisely for
             * simplified maintenance */
            if (   after == SB_Sp
                || after == SB_Sep
                || after == SB_CR
                || after == SB_LF)
            {
                return FALSE;
            }
        }

        /* SB11.  */
        return TRUE;
    }

    /* Otherwise, do not break.
    SB12.  Any  ×  Any */

    return FALSE;
}

STATIC SB_enum
S_advance_one_SB(pTHX_ U8 ** curpos, const U8 * const strend, const bool utf8_target)
{
    SB_enum sb;

    PERL_ARGS_ASSERT_ADVANCE_ONE_SB;

    if (*curpos >= strend) {
        return SB_EDGE;
    }

    if (utf8_target) {
        do {
            *curpos += UTF8SKIP(*curpos);
            if (*curpos >= strend) {
                return SB_EDGE;
            }
            sb = getSB_VAL_UTF8(*curpos, strend);
        } while (sb == SB_Extend || sb == SB_Format);
    }
    else {
        do {
            (*curpos)++;
            if (*curpos >= strend) {
                return SB_EDGE;
            }
            sb = getSB_VAL_CP(**curpos);
        } while (sb == SB_Extend || sb == SB_Format);
    }

    return sb;
}

STATIC SB_enum
S_backup_one_SB(pTHX_ const U8 * const strbeg, U8 ** curpos, const bool utf8_target)
{
    SB_enum sb;

    PERL_ARGS_ASSERT_BACKUP_ONE_SB;

    if (*curpos < strbeg) {
        return SB_EDGE;
    }

    if (utf8_target) {
        U8 * prev_char_pos = reghopmaybe3(*curpos, -1, strbeg);
        if (! prev_char_pos) {
            return SB_EDGE;
        }

        /* Back up over Extend and Format.  curpos is always just to the right
         * of the characater whose value we are getting */
        do {
            U8 * prev_prev_char_pos;
            if ((prev_prev_char_pos = reghopmaybe3((U8 *) prev_char_pos, -1,
                                                                      strbeg)))
            {
                sb = getSB_VAL_UTF8(prev_prev_char_pos, prev_char_pos);
                *curpos = prev_char_pos;
                prev_char_pos = prev_prev_char_pos;
            }
            else {
                *curpos = (U8 *) strbeg;
                return SB_EDGE;
            }
        } while (sb == SB_Extend || sb == SB_Format);
    }
    else {
        do {
            if (*curpos - 2 < strbeg) {
                *curpos = (U8 *) strbeg;
                return SB_EDGE;
            }
            (*curpos)--;
            sb = getSB_VAL_CP(*(*curpos - 1));
        } while (sb == SB_Extend || sb == SB_Format);
    }

    return sb;
}

STATIC bool
S_isWB(pTHX_ WB_enum previous,
             WB_enum before,
             WB_enum after,
             const U8 * const strbeg,
             const U8 * const curpos,
             const U8 * const strend,
             const bool utf8_target)
{
    /*  Return a boolean as to if the boundary between 'before' and 'after' is
     *  a Unicode word break, using their published algorithm, but tailored for
     *  Perl by treating spans of white space as one unit.  Context may be
     *  needed to make this determination.  If the value for the character
     *  before 'before' is known, it is passed as 'previous'; otherwise that
     *  should be set to WB_UNKNOWN.  The other input parameters give the
     *  boundaries and current position in the matching of the string.  That
     *  is, 'curpos' marks the position where the character whose wb value is
     *  'after' begins.  See http://www.unicode.org/reports/tr29/ */

    U8 * before_pos = (U8 *) curpos;
    U8 * after_pos = (U8 *) curpos;
    WB_enum prev = before;
    WB_enum next;

    PERL_ARGS_ASSERT_ISWB;

    /* Rule numbers in the comments below are as of Unicode 8.0 */

  redo:
    before = prev;
    switch (WB_table[before][after]) {
        case WB_BREAKABLE:
            return TRUE;

        case WB_NOBREAK:
            return FALSE;

        case WB_hs_then_hs:     /* 2 horizontal spaces in a row */
            next = advance_one_WB(&after_pos, strend, utf8_target,
                                 FALSE /* Don't skip Extend nor Format */ );
            /* A space immediately preceeding an Extend or Format is attached
             * to by them, and hence gets separated from previous spaces.
             * Otherwise don't break between horizontal white space */
            return next == WB_Extend || next == WB_Format;

        /* WB4 Ignore Format and Extend characters, except when they appear at
         * the beginning of a region of text.  This code currently isn't
         * general purpose, but it works as the rules are currently and likely
         * to be laid out.  The reason it works is that when 'they appear at
         * the beginning of a region of text', the rule is to break before
         * them, just like any other character.  Therefore, the default rule
         * applies and we don't have to look in more depth.  Should this ever
         * change, we would have to have 2 'case' statements, like in the
         * rules below, and backup a single character (not spacing over the
         * extend ones) and then see if that is one of the region-end
         * characters and go from there */
        case WB_Ex_or_FO_then_foo:
            prev = backup_one_WB(&previous, strbeg, &before_pos, utf8_target);
            goto redo;

        case WB_DQ_then_HL + WB_BREAKABLE:
        case WB_DQ_then_HL + WB_NOBREAK:

            /* WB7c  Hebrew_Letter Double_Quote  ×  Hebrew_Letter */

            if (backup_one_WB(&previous, strbeg, &before_pos, utf8_target)
                                                            == WB_Hebrew_Letter)
            {
                return FALSE;
            }

             return WB_table[before][after] - WB_DQ_then_HL == WB_BREAKABLE;

        case WB_HL_then_DQ + WB_BREAKABLE:
        case WB_HL_then_DQ + WB_NOBREAK:

            /* WB7b  Hebrew_Letter  ×  Double_Quote Hebrew_Letter */

            if (advance_one_WB(&after_pos, strend, utf8_target,
                                       TRUE /* Do skip Extend and Format */ )
                                                            == WB_Hebrew_Letter)
            {
                return FALSE;
            }

            return WB_table[before][after] - WB_HL_then_DQ == WB_BREAKABLE;

        case WB_LE_or_HL_then_MB_or_ML_or_SQ + WB_NOBREAK:
        case WB_LE_or_HL_then_MB_or_ML_or_SQ + WB_BREAKABLE:

            /* WB6  (ALetter | Hebrew_Letter)  ×  (MidLetter | MidNumLet
             *       | Single_Quote) (ALetter | Hebrew_Letter) */

            next = advance_one_WB(&after_pos, strend, utf8_target,
                                       TRUE /* Do skip Extend and Format */ );

            if (next == WB_ALetter || next == WB_Hebrew_Letter)
            {
                return FALSE;
            }

            return WB_table[before][after]
                            - WB_LE_or_HL_then_MB_or_ML_or_SQ == WB_BREAKABLE;

        case WB_MB_or_ML_or_SQ_then_LE_or_HL + WB_NOBREAK:
        case WB_MB_or_ML_or_SQ_then_LE_or_HL + WB_BREAKABLE:

            /* WB7  (ALetter | Hebrew_Letter) (MidLetter | MidNumLet
             *       | Single_Quote)  ×  (ALetter | Hebrew_Letter) */

            prev = backup_one_WB(&previous, strbeg, &before_pos, utf8_target);
            if (prev == WB_ALetter || prev == WB_Hebrew_Letter)
            {
                return FALSE;
            }

            return WB_table[before][after]
                            - WB_MB_or_ML_or_SQ_then_LE_or_HL == WB_BREAKABLE;

        case WB_MB_or_MN_or_SQ_then_NU + WB_NOBREAK:
        case WB_MB_or_MN_or_SQ_then_NU + WB_BREAKABLE:

            /* WB11  Numeric (MidNum | (MidNumLet | Single_Quote))  ×  Numeric
             * */

            if (backup_one_WB(&previous, strbeg, &before_pos, utf8_target)
                                                            == WB_Numeric)
            {
                return FALSE;
            }

            return WB_table[before][after]
                                - WB_MB_or_MN_or_SQ_then_NU == WB_BREAKABLE;

        case WB_NU_then_MB_or_MN_or_SQ + WB_NOBREAK:
        case WB_NU_then_MB_or_MN_or_SQ + WB_BREAKABLE:

            /* WB12  Numeric  ×  (MidNum | MidNumLet | Single_Quote) Numeric */

            if (advance_one_WB(&after_pos, strend, utf8_target,
                                       TRUE /* Do skip Extend and Format */ )
                                                            == WB_Numeric)
            {
                return FALSE;
            }

            return WB_table[before][after]
                                - WB_NU_then_MB_or_MN_or_SQ == WB_BREAKABLE;

        default:
            break;
    }

#ifdef DEBUGGING
    Perl_re_printf( aTHX_  "Unhandled WB pair: WB_table[%d, %d] = %d\n",
                                  before, after, WB_table[before][after]);
    assert(0);
#endif
    return TRUE;
}

STATIC WB_enum
S_advance_one_WB(pTHX_ U8 ** curpos,
                       const U8 * const strend,
                       const bool utf8_target,
                       const bool skip_Extend_Format)
{
    WB_enum wb;

    PERL_ARGS_ASSERT_ADVANCE_ONE_WB;

    if (*curpos >= strend) {
        return WB_EDGE;
    }

    if (utf8_target) {

        /* Advance over Extend and Format */
        do {
            *curpos += UTF8SKIP(*curpos);
            if (*curpos >= strend) {
                return WB_EDGE;
            }
            wb = getWB_VAL_UTF8(*curpos, strend);
        } while (    skip_Extend_Format
                 && (wb == WB_Extend || wb == WB_Format));
    }
    else {
        do {
            (*curpos)++;
            if (*curpos >= strend) {
                return WB_EDGE;
            }
            wb = getWB_VAL_CP(**curpos);
        } while (    skip_Extend_Format
                 && (wb == WB_Extend || wb == WB_Format));
    }

    return wb;
}

STATIC WB_enum
S_backup_one_WB(pTHX_ WB_enum * previous, const U8 * const strbeg, U8 ** curpos, const bool utf8_target)
{
    WB_enum wb;

    PERL_ARGS_ASSERT_BACKUP_ONE_WB;

    /* If we know what the previous character's break value is, don't have
        * to look it up */
    if (*previous != WB_UNKNOWN) {
        wb = *previous;

        /* But we need to move backwards by one */
        if (utf8_target) {
            *curpos = reghopmaybe3(*curpos, -1, strbeg);
            if (! *curpos) {
                *previous = WB_EDGE;
                *curpos = (U8 *) strbeg;
            }
            else {
                *previous = WB_UNKNOWN;
            }
        }
        else {
            (*curpos)--;
            *previous = (*curpos <= strbeg) ? WB_EDGE : WB_UNKNOWN;
        }

        /* And we always back up over these two types */
        if (wb != WB_Extend && wb != WB_Format) {
            return wb;
        }
    }

    if (*curpos < strbeg) {
        return WB_EDGE;
    }

    if (utf8_target) {
        U8 * prev_char_pos = reghopmaybe3(*curpos, -1, strbeg);
        if (! prev_char_pos) {
            return WB_EDGE;
        }

        /* Back up over Extend and Format.  curpos is always just to the right
         * of the characater whose value we are getting */
        do {
            U8 * prev_prev_char_pos;
            if ((prev_prev_char_pos = reghopmaybe3((U8 *) prev_char_pos,
                                                   -1,
                                                   strbeg)))
            {
                wb = getWB_VAL_UTF8(prev_prev_char_pos, prev_char_pos);
                *curpos = prev_char_pos;
                prev_char_pos = prev_prev_char_pos;
            }
            else {
                *curpos = (U8 *) strbeg;
                return WB_EDGE;
            }
        } while (wb == WB_Extend || wb == WB_Format);
    }
    else {
        do {
            if (*curpos - 2 < strbeg) {
                *curpos = (U8 *) strbeg;
                return WB_EDGE;
            }
            (*curpos)--;
            wb = getWB_VAL_CP(*(*curpos - 1));
        } while (wb == WB_Extend || wb == WB_Format);
    }

    return wb;
}

#define EVAL_CLOSE_PAREN_IS(st,expr)                        \
(                                                           \
    (   ( st )                                         ) && \
    (   ( st )->u.eval.close_paren                     ) && \
    ( ( ( st )->u.eval.close_paren ) == ( (expr) + 1 ) )    \
)

#define EVAL_CLOSE_PAREN_IS_TRUE(st,expr)                   \
(                                                           \
    (   ( st )                                         ) && \
    (   ( st )->u.eval.close_paren                     ) && \
    (   ( expr )                                       ) && \
    ( ( ( st )->u.eval.close_paren ) == ( (expr) + 1 ) )    \
)


#define EVAL_CLOSE_PAREN_SET(st,expr) \
    (st)->u.eval.close_paren = ( (expr) + 1 )

#define EVAL_CLOSE_PAREN_CLEAR(st) \
    (st)->u.eval.close_paren = 0

/* returns -1 on failure, $+[0] on success */
STATIC SSize_t
S_regmatch(pTHX_ regmatch_info *reginfo, char *startpos, regnode *prog)
{

#if PERL_VERSION < 9 && !defined(PERL_CORE)
    dMY_CXT;
#endif
    dVAR;
    const bool utf8_target = reginfo->is_utf8_target;
    const U32 uniflags = UTF8_ALLOW_DEFAULT;
    REGEXP *rex_sv = reginfo->prog;
    regexp *rex = ReANY(rex_sv);
    RXi_GET_DECL(rex,rexi);
    /* the current state. This is a cached copy of PL_regmatch_state */
    regmatch_state *st;
    /* cache heavy used fields of st in registers */
    regnode *scan;
    regnode *next;
    U32 n = 0;	/* general value; init to avoid compiler warning */
    SSize_t ln = 0; /* len or last;  init to avoid compiler warning */
    char *locinput = startpos;
    char *pushinput; /* where to continue after a PUSH */
    I32 nextchr;   /* is always set to UCHARAT(locinput), or -1 at EOS */

    bool result = 0;	    /* return value of S_regmatch */
    int depth = 0;	    /* depth of backtrack stack */
    U32 nochange_depth = 0; /* depth of GOSUB recursion with nochange */
    const U32 max_nochange_depth =
        (3 * rex->nparens > MAX_RECURSE_EVAL_NOCHANGE_DEPTH) ?
        3 * rex->nparens : MAX_RECURSE_EVAL_NOCHANGE_DEPTH;
    regmatch_state *yes_state = NULL; /* state to pop to on success of
							    subpattern */
    /* mark_state piggy backs on the yes_state logic so that when we unwind 
       the stack on success we can update the mark_state as we go */
    regmatch_state *mark_state = NULL; /* last mark state we have seen */
    regmatch_state *cur_eval = NULL; /* most recent EVAL_AB state */
    struct regmatch_state  *cur_curlyx = NULL; /* most recent curlyx */
    U32 state_num;
    bool no_final = 0;      /* prevent failure from backtracking? */
    bool do_cutgroup = 0;   /* no_final only until next branch/trie entry */
    char *startpoint = locinput;
    SV *popmark = NULL;     /* are we looking for a mark? */
    SV *sv_commit = NULL;   /* last mark name seen in failure */
    SV *sv_yes_mark = NULL; /* last mark name we have seen 
                               during a successful match */
    U32 lastopen = 0;       /* last open we saw */
    bool has_cutgroup = RX_HAS_CUTGROUP(rex) ? 1 : 0;   
    SV* const oreplsv = GvSVn(PL_replgv);
    /* these three flags are set by various ops to signal information to
     * the very next op. They have a useful lifetime of exactly one loop
     * iteration, and are not preserved or restored by state pushes/pops
     */
    bool sw = 0;	    /* the condition value in (?(cond)a|b) */
    bool minmod = 0;	    /* the next "{n,m}" is a "{n,m}?" */
    int logical = 0;	    /* the following EVAL is:
				0: (?{...})
				1: (?(?{...})X|Y)
				2: (??{...})
			       or the following IFMATCH/UNLESSM is:
			        false: plain (?=foo)
				true:  used as a condition: (?(?=foo))
			    */
    PAD* last_pad = NULL;
    dMULTICALL;
    U8 gimme = G_SCALAR;
    CV *caller_cv = NULL;	/* who called us */
    CV *last_pushed_cv = NULL;	/* most recently called (?{}) CV */
    CHECKPOINT runops_cp;	/* savestack position before executing EVAL */
    U32 maxopenparen = 0;       /* max '(' index seen so far */
    int to_complement;  /* Invert the result? */
    _char_class_number classnum;
    bool is_utf8_pat = reginfo->is_utf8_pat;
    bool match = FALSE;

/* Solaris Studio 12.3 messes up fetching PL_charclass['\n'] */
#if (defined(__SUNPRO_C) && (__SUNPRO_C == 0x5120) && defined(__x86_64) && defined(USE_64_BIT_ALL))
#  define SOLARIS_BAD_OPTIMIZER
    const U32 *pl_charclass_dup = PL_charclass;
#  define PL_charclass pl_charclass_dup
#endif

#ifdef DEBUGGING
    GET_RE_DEBUG_FLAGS_DECL;
#endif

    /* protect against undef(*^R) */
    SAVEFREESV(SvREFCNT_inc_simple_NN(oreplsv));

    /* shut up 'may be used uninitialized' compiler warnings for dMULTICALL */
    multicall_oldcatch = 0;
    PERL_UNUSED_VAR(multicall_cop);

    PERL_ARGS_ASSERT_REGMATCH;

    DEBUG_OPTIMISE_r( DEBUG_EXECUTE_r({
            Perl_re_printf( aTHX_ "regmatch start\n");
    }));

    st = PL_regmatch_state;

    /* Note that nextchr is a byte even in UTF */
    SET_nextchr;
    scan = prog;
    while (scan != NULL) {


	next = scan + NEXT_OFF(scan);
	if (next == scan)
	    next = NULL;
	state_num = OP(scan);

      reenter_switch:
        DEBUG_EXECUTE_r(
            if (state_num <= REGNODE_MAX) {
                SV * const prop = sv_newmortal();
                regnode *rnext = regnext(scan);

                DUMP_EXEC_POS( locinput, scan, utf8_target, depth );
                regprop(rex, prop, scan, reginfo, NULL);
                Perl_re_printf( aTHX_
                    "%*s%"IVdf":%s(%"IVdf")\n",
                    INDENT_CHARS(depth), "",
                    (IV)(scan - rexi->program),
                    SvPVX_const(prop),
                    (PL_regkind[OP(scan)] == END || !rnext) ?
                        0 : (IV)(rnext - rexi->program));
            }
        );

        to_complement = 0;

        SET_nextchr;
        assert(nextchr < 256 && (nextchr >= 0 || nextchr == NEXTCHR_EOS));

	switch (state_num) {
	case SBOL: /*  /^../ and /\A../  */
	    if (locinput == reginfo->strbeg)
		break;
	    sayNO;

	case MBOL: /*  /^../m  */
	    if (locinput == reginfo->strbeg ||
		(!NEXTCHR_IS_EOS && locinput[-1] == '\n'))
	    {
		break;
	    }
	    sayNO;

	case GPOS: /*  \G  */
	    if (locinput == reginfo->ganch)
		break;
	    sayNO;

	case KEEPS: /*   \K  */
	    /* update the startpoint */
	    st->u.keeper.val = rex->offs[0].start;
	    rex->offs[0].start = locinput - reginfo->strbeg;
	    PUSH_STATE_GOTO(KEEPS_next, next, locinput);
	    NOT_REACHED; /* NOTREACHED */

	case KEEPS_next_fail:
	    /* rollback the start point change */
	    rex->offs[0].start = st->u.keeper.val;
	    sayNO_SILENT;
	    NOT_REACHED; /* NOTREACHED */

	case MEOL: /* /..$/m  */
	    if (!NEXTCHR_IS_EOS && nextchr != '\n')
		sayNO;
	    break;

	case SEOL: /* /..$/  */
	    if (!NEXTCHR_IS_EOS && nextchr != '\n')
		sayNO;
	    if (reginfo->strend - locinput > 1)
		sayNO;
	    break;

	case EOS: /*  \z  */
	    if (!NEXTCHR_IS_EOS)
		sayNO;
	    break;

	case SANY: /*  /./s  */
	    if (NEXTCHR_IS_EOS)
		sayNO;
            goto increment_locinput;

	case REG_ANY: /*  /./  */
	    if ((NEXTCHR_IS_EOS) || nextchr == '\n')
		sayNO;
            goto increment_locinput;


#undef  ST
#define ST st->u.trie
        case TRIEC: /* (ab|cd) with known charclass */
            /* In this case the charclass data is available inline so
               we can fail fast without a lot of extra overhead. 
             */
            if(!NEXTCHR_IS_EOS && !ANYOF_BITMAP_TEST(scan, nextchr)) {
                DEBUG_EXECUTE_r(
                    Perl_re_exec_indentf( aTHX_  "%sfailed to match trie start class...%s\n",
                              depth, PL_colors[4], PL_colors[5])
                );
                sayNO_SILENT;
                NOT_REACHED; /* NOTREACHED */
            }
            /* FALLTHROUGH */
	case TRIE:  /* (ab|cd)  */
	    /* the basic plan of execution of the trie is:
	     * At the beginning, run though all the states, and
	     * find the longest-matching word. Also remember the position
	     * of the shortest matching word. For example, this pattern:
	     *    1  2 3 4    5
	     *    ab|a|x|abcd|abc
	     * when matched against the string "abcde", will generate
	     * accept states for all words except 3, with the longest
	     * matching word being 4, and the shortest being 2 (with
	     * the position being after char 1 of the string).
	     *
	     * Then for each matching word, in word order (i.e. 1,2,4,5),
	     * we run the remainder of the pattern; on each try setting
	     * the current position to the character following the word,
	     * returning to try the next word on failure.
	     *
	     * We avoid having to build a list of words at runtime by
	     * using a compile-time structure, wordinfo[].prev, which
	     * gives, for each word, the previous accepting word (if any).
	     * In the case above it would contain the mappings 1->2, 2->0,
	     * 3->0, 4->5, 5->1.  We can use this table to generate, from
	     * the longest word (4 above), a list of all words, by
	     * following the list of prev pointers; this gives us the
	     * unordered list 4,5,1,2. Then given the current word we have
	     * just tried, we can go through the list and find the
	     * next-biggest word to try (so if we just failed on word 2,
	     * the next in the list is 4).
	     *
	     * Since at runtime we don't record the matching position in
	     * the string for each word, we have to work that out for
	     * each word we're about to process. The wordinfo table holds
	     * the character length of each word; given that we recorded
	     * at the start: the position of the shortest word and its
	     * length in chars, we just need to move the pointer the
	     * difference between the two char lengths. Depending on
	     * Unicode status and folding, that's cheap or expensive.
	     *
	     * This algorithm is optimised for the case where are only a
	     * small number of accept states, i.e. 0,1, or maybe 2.
	     * With lots of accepts states, and having to try all of them,
	     * it becomes quadratic on number of accept states to find all
	     * the next words.
	     */

	    {
                /* what type of TRIE am I? (utf8 makes this contextual) */
                DECL_TRIE_TYPE(scan);

                /* what trie are we using right now */
		reg_trie_data * const trie
        	    = (reg_trie_data*)rexi->data->data[ ARG( scan ) ];
		HV * widecharmap = MUTABLE_HV(rexi->data->data[ ARG( scan ) + 1 ]);
                U32 state = trie->startstate;

                if (scan->flags == EXACTL || scan->flags == EXACTFLU8) {
                    _CHECK_AND_WARN_PROBLEMATIC_LOCALE;
                    if (utf8_target
                        && UTF8_IS_ABOVE_LATIN1(nextchr)
                        && scan->flags == EXACTL)
                    {
                        /* We only output for EXACTL, as we let the folder
                         * output this message for EXACTFLU8 to avoid
                         * duplication */
                        _CHECK_AND_OUTPUT_WIDE_LOCALE_UTF8_MSG(locinput,
                                                               reginfo->strend);
                    }
                }
                if (   trie->bitmap
                    && (NEXTCHR_IS_EOS || !TRIE_BITMAP_TEST(trie, nextchr)))
                {
        	    if (trie->states[ state ].wordnum) {
        	         DEBUG_EXECUTE_r(
                            Perl_re_exec_indentf( aTHX_  "%smatched empty string...%s\n",
                                          depth, PL_colors[4], PL_colors[5])
                        );
			if (!trie->jump)
			    break;
        	    } else {
        	        DEBUG_EXECUTE_r(
                            Perl_re_exec_indentf( aTHX_  "%sfailed to match trie start class...%s\n",
                                          depth, PL_colors[4], PL_colors[5])
                        );
        	        sayNO_SILENT;
        	   }
                }

            { 
		U8 *uc = ( U8* )locinput;

		STRLEN len = 0;
		STRLEN foldlen = 0;
		U8 *uscan = (U8*)NULL;
		U8 foldbuf[ UTF8_MAXBYTES_CASE + 1 ];
		U32 charcount = 0; /* how many input chars we have matched */
		U32 accepted = 0; /* have we seen any accepting states? */

		ST.jump = trie->jump;
		ST.me = scan;
		ST.firstpos = NULL;
		ST.longfold = FALSE; /* char longer if folded => it's harder */
		ST.nextword = 0;

		/* fully traverse the TRIE; note the position of the
		   shortest accept state and the wordnum of the longest
		   accept state */

		while ( state && uc <= (U8*)(reginfo->strend) ) {
                    U32 base = trie->states[ state ].trans.base;
                    UV uvc = 0;
                    U16 charid = 0;
		    U16 wordnum;
                    wordnum = trie->states[ state ].wordnum;

		    if (wordnum) { /* it's an accept state */
			if (!accepted) {
			    accepted = 1;
			    /* record first match position */
			    if (ST.longfold) {
				ST.firstpos = (U8*)locinput;
				ST.firstchars = 0;
			    }
			    else {
				ST.firstpos = uc;
				ST.firstchars = charcount;
			    }
			}
			if (!ST.nextword || wordnum < ST.nextword)
			    ST.nextword = wordnum;
			ST.topword = wordnum;
		    }

		    DEBUG_TRIE_EXECUTE_r({
                                DUMP_EXEC_POS( (char *)uc, scan, utf8_target, depth );
                                Perl_re_exec_indentf( aTHX_
                                    "%sState: %4"UVxf" Accepted: %c ",
                                    depth, PL_colors[4],
			            (UV)state, (accepted ? 'Y' : 'N'));
		    });

		    /* read a char and goto next state */
		    if ( base && (foldlen || uc < (U8*)(reginfo->strend))) {
			I32 offset;
			REXEC_TRIE_READ_CHAR(trie_type, trie, widecharmap, uc,
					     uscan, len, uvc, charid, foldlen,
					     foldbuf, uniflags);
			charcount++;
			if (foldlen>0)
			    ST.longfold = TRUE;
			if (charid &&
			     ( ((offset =
			      base + charid - 1 - trie->uniquecharcount)) >= 0)

			     && ((U32)offset < trie->lasttrans)
			     && trie->trans[offset].check == state)
			{
			    state = trie->trans[offset].next;
			}
			else {
			    state = 0;
			}
			uc += len;

		    }
		    else {
			state = 0;
		    }
		    DEBUG_TRIE_EXECUTE_r(
                        Perl_re_printf( aTHX_
		            "Charid:%3x CP:%4"UVxf" After State: %4"UVxf"%s\n",
		            charid, uvc, (UV)state, PL_colors[5] );
		    );
		}
		if (!accepted)
		   sayNO;

		/* calculate total number of accept states */
		{
		    U16 w = ST.topword;
		    accepted = 0;
		    while (w) {
			w = trie->wordinfo[w].prev;
			accepted++;
		    }
		    ST.accepted = accepted;
		}

		DEBUG_EXECUTE_r(
                    Perl_re_exec_indentf( aTHX_  "%sgot %"IVdf" possible matches%s\n",
                        depth,
			PL_colors[4], (IV)ST.accepted, PL_colors[5] );
		);
		goto trie_first_try; /* jump into the fail handler */
	    }}
	    NOT_REACHED; /* NOTREACHED */

	case TRIE_next_fail: /* we failed - try next alternative */
        {
            U8 *uc;
            if ( ST.jump) {
                REGCP_UNWIND(ST.cp);
                UNWIND_PAREN(ST.lastparen, ST.lastcloseparen);
	    }
	    if (!--ST.accepted) {
	        DEBUG_EXECUTE_r({
                    Perl_re_exec_indentf( aTHX_  "%sTRIE failed...%s\n",
                        depth,
			PL_colors[4],
			PL_colors[5] );
		});
		sayNO_SILENT;
	    }
	    {
		/* Find next-highest word to process.  Note that this code
		 * is O(N^2) per trie run (O(N) per branch), so keep tight */
		U16 min = 0;
		U16 word;
		U16 const nextword = ST.nextword;
		reg_trie_wordinfo * const wordinfo
		    = ((reg_trie_data*)rexi->data->data[ARG(ST.me)])->wordinfo;
		for (word=ST.topword; word; word=wordinfo[word].prev) {
		    if (word > nextword && (!min || word < min))
			min = word;
		}
		ST.nextword = min;
	    }

          trie_first_try:
            if (do_cutgroup) {
                do_cutgroup = 0;
                no_final = 0;
            }

            if ( ST.jump) {
                ST.lastparen = rex->lastparen;
                ST.lastcloseparen = rex->lastcloseparen;
	        REGCP_SET(ST.cp);
            }

	    /* find start char of end of current word */
	    {
		U32 chars; /* how many chars to skip */
		reg_trie_data * const trie
		    = (reg_trie_data*)rexi->data->data[ARG(ST.me)];

		assert((trie->wordinfo[ST.nextword].len - trie->prefixlen)
			    >=  ST.firstchars);
		chars = (trie->wordinfo[ST.nextword].len - trie->prefixlen)
			    - ST.firstchars;
		uc = ST.firstpos;

		if (ST.longfold) {
		    /* the hard option - fold each char in turn and find
		     * its folded length (which may be different */
		    U8 foldbuf[UTF8_MAXBYTES_CASE + 1];
		    STRLEN foldlen;
		    STRLEN len;
		    UV uvc;
		    U8 *uscan;

		    while (chars) {
			if (utf8_target) {
			    uvc = utf8n_to_uvchr((U8*)uc, UTF8_MAXLEN, &len,
						    uniflags);
			    uc += len;
			}
			else {
			    uvc = *uc;
			    uc++;
			}
			uvc = to_uni_fold(uvc, foldbuf, &foldlen);
			uscan = foldbuf;
			while (foldlen) {
			    if (!--chars)
				break;
			    uvc = utf8n_to_uvchr(uscan, UTF8_MAXLEN, &len,
					    uniflags);
			    uscan += len;
			    foldlen -= len;
			}
		    }
		}
		else {
		    if (utf8_target)
			while (chars--)
			    uc += UTF8SKIP(uc);
		    else
			uc += chars;
		}
	    }

	    scan = ST.me + ((ST.jump && ST.jump[ST.nextword])
			    ? ST.jump[ST.nextword]
			    : NEXT_OFF(ST.me));

	    DEBUG_EXECUTE_r({
                Perl_re_exec_indentf( aTHX_  "%sTRIE matched word #%d, continuing%s\n",
                    depth,
		    PL_colors[4],
		    ST.nextword,
		    PL_colors[5]
		    );
	    });

	    if (ST.accepted > 1 || has_cutgroup) {
		PUSH_STATE_GOTO(TRIE_next, scan, (char*)uc);
		NOT_REACHED; /* NOTREACHED */
	    }
	    /* only one choice left - just continue */
	    DEBUG_EXECUTE_r({
		AV *const trie_words
		    = MUTABLE_AV(rexi->data->data[ARG(ST.me)+TRIE_WORDS_OFFSET]);
		SV ** const tmp = trie_words
                        ? av_fetch(trie_words, ST.nextword - 1, 0) : NULL;
		SV *sv= tmp ? sv_newmortal() : NULL;

                Perl_re_exec_indentf( aTHX_  "%sonly one match left, short-circuiting: #%d <%s>%s\n",
                    depth, PL_colors[4],
		    ST.nextword,
		    tmp ? pv_pretty(sv, SvPV_nolen_const(*tmp), SvCUR(*tmp), 0,
			    PL_colors[0], PL_colors[1],
			    (SvUTF8(*tmp) ? PERL_PV_ESCAPE_UNI : 0)|PERL_PV_ESCAPE_NONASCII
			) 
		    : "not compiled under -Dr",
		    PL_colors[5] );
	    });

	    locinput = (char*)uc;
	    continue; /* execute rest of RE */
            /* NOTREACHED */
        }
#undef  ST

	case EXACTL:             /*  /abc/l       */
            _CHECK_AND_WARN_PROBLEMATIC_LOCALE;

            /* Complete checking would involve going through every character
             * matched by the string to see if any is above latin1.  But the
             * comparision otherwise might very well be a fast assembly
             * language routine, and I (khw) don't think slowing things down
             * just to check for this warning is worth it.  So this just checks
             * the first character */
            if (utf8_target && UTF8_IS_ABOVE_LATIN1(*locinput)) {
                _CHECK_AND_OUTPUT_WIDE_LOCALE_UTF8_MSG(locinput, reginfo->strend);
            }
            /* FALLTHROUGH */
	case EXACT: {            /*  /abc/        */
	    char *s = STRING(scan);
	    ln = STR_LEN(scan);
	    if (utf8_target != is_utf8_pat) {
		/* The target and the pattern have differing utf8ness. */
		char *l = locinput;
		const char * const e = s + ln;

		if (utf8_target) {
                    /* The target is utf8, the pattern is not utf8.
                     * Above-Latin1 code points can't match the pattern;
                     * invariants match exactly, and the other Latin1 ones need
                     * to be downgraded to a single byte in order to do the
                     * comparison.  (If we could be confident that the target
                     * is not malformed, this could be refactored to have fewer
                     * tests by just assuming that if the first bytes match, it
                     * is an invariant, but there are tests in the test suite
                     * dealing with (??{...}) which violate this) */
		    while (s < e) {
			if (l >= reginfo->strend
                            || UTF8_IS_ABOVE_LATIN1(* (U8*) l))
                        {
                            sayNO;
                        }
                        if (UTF8_IS_INVARIANT(*(U8*)l)) {
			    if (*l != *s) {
                                sayNO;
                            }
                            l++;
                        }
                        else {
                            if (EIGHT_BIT_UTF8_TO_NATIVE(*l, *(l+1)) != * (U8*) s)
                            {
                                sayNO;
                            }
                            l += 2;
                        }
			s++;
		    }
		}
		else {
		    /* The target is not utf8, the pattern is utf8. */
		    while (s < e) {
                        if (l >= reginfo->strend
                            || UTF8_IS_ABOVE_LATIN1(* (U8*) s))
                        {
                            sayNO;
                        }
                        if (UTF8_IS_INVARIANT(*(U8*)s)) {
			    if (*s != *l) {
                                sayNO;
                            }
                            s++;
                        }
                        else {
                            if (EIGHT_BIT_UTF8_TO_NATIVE(*s, *(s+1)) != * (U8*) l)
                            {
                                sayNO;
                            }
                            s += 2;
                        }
			l++;
		    }
		}
		locinput = l;
	    }
            else {
                /* The target and the pattern have the same utf8ness. */
                /* Inline the first character, for speed. */
                if (reginfo->strend - locinput < ln
                    || UCHARAT(s) != nextchr
                    || (ln > 1 && memNE(s, locinput, ln)))
                {
                    sayNO;
                }
                locinput += ln;
            }
	    break;
	    }

	case EXACTFL: {          /*  /abc/il      */
	    re_fold_t folder;
	    const U8 * fold_array;
	    const char * s;
	    U32 fold_utf8_flags;

            _CHECK_AND_WARN_PROBLEMATIC_LOCALE;
            folder = foldEQ_locale;
            fold_array = PL_fold_locale;
	    fold_utf8_flags = FOLDEQ_LOCALE;
	    goto do_exactf;

        case EXACTFLU8:           /*  /abc/il; but all 'abc' are above 255, so
                                      is effectively /u; hence to match, target
                                      must be UTF-8. */
            if (! utf8_target) {
                sayNO;
            }
            fold_utf8_flags =  FOLDEQ_LOCALE | FOLDEQ_S1_ALREADY_FOLDED
                                             | FOLDEQ_S1_FOLDS_SANE;
	    folder = foldEQ_latin1;
	    fold_array = PL_fold_latin1;
	    goto do_exactf;

	case EXACTFU_SS:         /*  /\x{df}/iu   */
	case EXACTFU:            /*  /abc/iu      */
	    folder = foldEQ_latin1;
	    fold_array = PL_fold_latin1;
	    fold_utf8_flags = is_utf8_pat ? FOLDEQ_S1_ALREADY_FOLDED : 0;
	    goto do_exactf;

        case EXACTFA_NO_TRIE:   /* This node only generated for non-utf8
                                   patterns */
            assert(! is_utf8_pat);
            /* FALLTHROUGH */
	case EXACTFA:            /*  /abc/iaa     */
	    folder = foldEQ_latin1;
	    fold_array = PL_fold_latin1;
	    fold_utf8_flags = FOLDEQ_UTF8_NOMIX_ASCII;
	    goto do_exactf;

        case EXACTF:             /*  /abc/i    This node only generated for
                                               non-utf8 patterns */
            assert(! is_utf8_pat);
	    folder = foldEQ;
	    fold_array = PL_fold;
	    fold_utf8_flags = 0;

	  do_exactf:
	    s = STRING(scan);
	    ln = STR_LEN(scan);

	    if (utf8_target
                || is_utf8_pat
                || state_num == EXACTFU_SS
                || (state_num == EXACTFL && IN_UTF8_CTYPE_LOCALE))
            {
	      /* Either target or the pattern are utf8, or has the issue where
	       * the fold lengths may differ. */
		const char * const l = locinput;
		char *e = reginfo->strend;

		if (! foldEQ_utf8_flags(s, 0,  ln, is_utf8_pat,
			                l, &e, 0,  utf8_target, fold_utf8_flags))
		{
		    sayNO;
		}
		locinput = e;
		break;
	    }

	    /* Neither the target nor the pattern are utf8 */
	    if (UCHARAT(s) != nextchr
                && !NEXTCHR_IS_EOS
		&& UCHARAT(s) != fold_array[nextchr])
	    {
		sayNO;
	    }
	    if (reginfo->strend - locinput < ln)
		sayNO;
	    if (ln > 1 && ! folder(s, locinput, ln))
		sayNO;
	    locinput += ln;
	    break;
	}

	case NBOUNDL: /*  /\B/l  */
            to_complement = 1;
            /* FALLTHROUGH */

	case BOUNDL:  /*  /\b/l  */
        {
            bool b1, b2;
            _CHECK_AND_WARN_PROBLEMATIC_LOCALE;

            if (FLAGS(scan) != TRADITIONAL_BOUND) {
                if (! IN_UTF8_CTYPE_LOCALE) {
                    Perl_ck_warner(aTHX_ packWARN(WARN_LOCALE),
                                                B_ON_NON_UTF8_LOCALE_IS_WRONG);
                }
                goto boundu;
            }

	    if (utf8_target) {
		if (locinput == reginfo->strbeg)
		    b1 = isWORDCHAR_LC('\n');
		else {
                    b1 = isWORDCHAR_LC_utf8(reghop3((U8*)locinput, -1,
                                                        (U8*)(reginfo->strbeg)));
		}
                b2 = (NEXTCHR_IS_EOS)
                    ? isWORDCHAR_LC('\n')
                    : isWORDCHAR_LC_utf8((U8*)locinput);
	    }
	    else { /* Here the string isn't utf8 */
		b1 = (locinput == reginfo->strbeg)
                     ? isWORDCHAR_LC('\n')
                     : isWORDCHAR_LC(UCHARAT(locinput - 1));
                b2 = (NEXTCHR_IS_EOS)
                    ? isWORDCHAR_LC('\n')
                    : isWORDCHAR_LC(nextchr);
	    }
            if (to_complement ^ (b1 == b2)) {
                sayNO;
            }
	    break;
        }

	case NBOUND:  /*  /\B/   */
            to_complement = 1;
            /* FALLTHROUGH */

	case BOUND:   /*  /\b/   */
	    if (utf8_target) {
                goto bound_utf8;
            }
            goto bound_ascii_match_only;

	case NBOUNDA: /*  /\B/a  */
            to_complement = 1;
            /* FALLTHROUGH */

	case BOUNDA:  /*  /\b/a  */
        {
            bool b1, b2;

          bound_ascii_match_only:
            /* Here the string isn't utf8, or is utf8 and only ascii characters
             * are to match \w.  In the latter case looking at the byte just
             * prior to the current one may be just the final byte of a
             * multi-byte character.  This is ok.  There are two cases:
             * 1) it is a single byte character, and then the test is doing
             *    just what it's supposed to.
             * 2) it is a multi-byte character, in which case the final byte is
             *    never mistakable for ASCII, and so the test will say it is
             *    not a word character, which is the correct answer. */
            b1 = (locinput == reginfo->strbeg)
                 ? isWORDCHAR_A('\n')
                 : isWORDCHAR_A(UCHARAT(locinput - 1));
            b2 = (NEXTCHR_IS_EOS)
                ? isWORDCHAR_A('\n')
                : isWORDCHAR_A(nextchr);
            if (to_complement ^ (b1 == b2)) {
                sayNO;
            }
	    break;
        }

	case NBOUNDU: /*  /\B/u  */
            to_complement = 1;
            /* FALLTHROUGH */

	case BOUNDU:  /*  /\b/u  */

          boundu:
            if (UNLIKELY(reginfo->strbeg >= reginfo->strend)) {
                match = FALSE;
            }
            else if (utf8_target) {
              bound_utf8:
                switch((bound_type) FLAGS(scan)) {
                    case TRADITIONAL_BOUND:
                    {
                        bool b1, b2;
                        b1 = (locinput == reginfo->strbeg)
                             ? 0 /* isWORDCHAR_L1('\n') */
                             : isWORDCHAR_utf8(reghop3((U8*)locinput, -1,
                                                                (U8*)(reginfo->strbeg)));
                        b2 = (NEXTCHR_IS_EOS)
                            ? 0 /* isWORDCHAR_L1('\n') */
                            : isWORDCHAR_utf8((U8*)locinput);
                        match = cBOOL(b1 != b2);
                        break;
                    }
                    case GCB_BOUND:
                        if (locinput == reginfo->strbeg || NEXTCHR_IS_EOS) {
                            match = TRUE; /* GCB always matches at begin and
                                             end */
                        }
                        else {
                            /* Find the gcb values of previous and current
                             * chars, then see if is a break point */
                            match = isGCB(getGCB_VAL_UTF8(
                                                reghop3((U8*)locinput,
                                                        -1,
                                                        (U8*)(reginfo->strbeg)),
                                                (U8*) reginfo->strend),
                                          getGCB_VAL_UTF8((U8*) locinput,
                                                        (U8*) reginfo->strend));
                        }
                        break;

                    case LB_BOUND:
                        if (locinput == reginfo->strbeg) {
                            match = FALSE;
                        }
                        else if (NEXTCHR_IS_EOS) {
                            match = TRUE;
                        }
                        else {
                            match = isLB(getLB_VAL_UTF8(
                                                reghop3((U8*)locinput,
                                                        -1,
                                                        (U8*)(reginfo->strbeg)),
                                                (U8*) reginfo->strend),
                                          getLB_VAL_UTF8((U8*) locinput,
                                                        (U8*) reginfo->strend),
                                          (U8*) reginfo->strbeg,
                                          (U8*) locinput,
                                          (U8*) reginfo->strend,
                                          utf8_target);
                        }
                        break;

                    case SB_BOUND: /* Always matches at begin and end */
                        if (locinput == reginfo->strbeg || NEXTCHR_IS_EOS) {
                            match = TRUE;
                        }
                        else {
                            match = isSB(getSB_VAL_UTF8(
                                                reghop3((U8*)locinput,
                                                        -1,
                                                        (U8*)(reginfo->strbeg)),
                                                (U8*) reginfo->strend),
                                          getSB_VAL_UTF8((U8*) locinput,
                                                        (U8*) reginfo->strend),
                                          (U8*) reginfo->strbeg,
                                          (U8*) locinput,
                                          (U8*) reginfo->strend,
                                          utf8_target);
                        }
                        break;

                    case WB_BOUND:
                        if (locinput == reginfo->strbeg || NEXTCHR_IS_EOS) {
                            match = TRUE;
                        }
                        else {
                            match = isWB(WB_UNKNOWN,
                                         getWB_VAL_UTF8(
                                                reghop3((U8*)locinput,
                                                        -1,
                                                        (U8*)(reginfo->strbeg)),
                                                (U8*) reginfo->strend),
                                          getWB_VAL_UTF8((U8*) locinput,
                                                        (U8*) reginfo->strend),
                                          (U8*) reginfo->strbeg,
                                          (U8*) locinput,
                                          (U8*) reginfo->strend,
                                          utf8_target);
                        }
                        break;
                }
	    }
	    else {  /* Not utf8 target */
                switch((bound_type) FLAGS(scan)) {
                    case TRADITIONAL_BOUND:
                    {
                        bool b1, b2;
                        b1 = (locinput == reginfo->strbeg)
                            ? 0 /* isWORDCHAR_L1('\n') */
                            : isWORDCHAR_L1(UCHARAT(locinput - 1));
                        b2 = (NEXTCHR_IS_EOS)
                            ? 0 /* isWORDCHAR_L1('\n') */
                            : isWORDCHAR_L1(nextchr);
                        match = cBOOL(b1 != b2);
                        break;
                    }

                    case GCB_BOUND:
                        if (locinput == reginfo->strbeg || NEXTCHR_IS_EOS) {
                            match = TRUE; /* GCB always matches at begin and
                                             end */
                        }
                        else {  /* Only CR-LF combo isn't a GCB in 0-255
                                   range */
                            match =    UCHARAT(locinput - 1) != '\r'
                                    || UCHARAT(locinput) != '\n';
                        }
                        break;

                    case LB_BOUND:
                        if (locinput == reginfo->strbeg) {
                            match = FALSE;
                        }
                        else if (NEXTCHR_IS_EOS) {
                            match = TRUE;
                        }
                        else {
                            match = isLB(getLB_VAL_CP(UCHARAT(locinput -1)),
                                         getLB_VAL_CP(UCHARAT(locinput)),
                                         (U8*) reginfo->strbeg,
                                         (U8*) locinput,
                                         (U8*) reginfo->strend,
                                         utf8_target);
                        }
                        break;

                    case SB_BOUND: /* Always matches at begin and end */
                        if (locinput == reginfo->strbeg || NEXTCHR_IS_EOS) {
                            match = TRUE;
                        }
                        else {
                            match = isSB(getSB_VAL_CP(UCHARAT(locinput -1)),
                                         getSB_VAL_CP(UCHARAT(locinput)),
                                         (U8*) reginfo->strbeg,
                                         (U8*) locinput,
                                         (U8*) reginfo->strend,
                                         utf8_target);
                        }
                        break;

                    case WB_BOUND:
                        if (locinput == reginfo->strbeg || NEXTCHR_IS_EOS) {
                            match = TRUE;
                        }
                        else {
                            match = isWB(WB_UNKNOWN,
                                         getWB_VAL_CP(UCHARAT(locinput -1)),
                                         getWB_VAL_CP(UCHARAT(locinput)),
                                         (U8*) reginfo->strbeg,
                                         (U8*) locinput,
                                         (U8*) reginfo->strend,
                                         utf8_target);
                        }
                        break;
                }
	    }

            if (to_complement ^ ! match) {
                sayNO;
            }
	    break;

	case ANYOFL:  /*  /[abc]/l      */
            _CHECK_AND_WARN_PROBLEMATIC_LOCALE;

            if (ANYOFL_UTF8_LOCALE_REQD(FLAGS(scan)) && ! IN_UTF8_CTYPE_LOCALE)
            {
              Perl_ck_warner(aTHX_ packWARN(WARN_LOCALE), utf8_locale_required);
            }
            /* FALLTHROUGH */
	case ANYOFD:  /*   /[abc]/d       */
	case ANYOF:  /*   /[abc]/       */
            if (NEXTCHR_IS_EOS)
                sayNO;
	    if (utf8_target && ! UTF8_IS_INVARIANT(*locinput)) {
	        if (!reginclass(rex, scan, (U8*)locinput, (U8*)reginfo->strend,
                                                                   utf8_target))
		    sayNO;
		locinput += UTF8SKIP(locinput);
	    }
	    else {
		if (!REGINCLASS(rex, scan, (U8*)locinput, utf8_target))
		    sayNO;
		locinput++;
	    }
	    break;

        /* The argument (FLAGS) to all the POSIX node types is the class number
         * */

        case NPOSIXL:   /* \W or [:^punct:] etc. under /l */
            to_complement = 1;
            /* FALLTHROUGH */

        case POSIXL:    /* \w or [:punct:] etc. under /l */
            _CHECK_AND_WARN_PROBLEMATIC_LOCALE;
            if (NEXTCHR_IS_EOS)
                sayNO;

            /* Use isFOO_lc() for characters within Latin1.  (Note that
             * UTF8_IS_INVARIANT works even on non-UTF-8 strings, or else
             * wouldn't be invariant) */
            if (UTF8_IS_INVARIANT(nextchr) || ! utf8_target) {
                if (! (to_complement ^ cBOOL(isFOO_lc(FLAGS(scan), (U8) nextchr)))) {
                    sayNO;
                }
            }
            else if (UTF8_IS_DOWNGRADEABLE_START(nextchr)) {
                if (! (to_complement ^ cBOOL(isFOO_lc(FLAGS(scan),
                                               EIGHT_BIT_UTF8_TO_NATIVE(nextchr,
                                               *(locinput + 1))))))
                {
                    sayNO;
                }
            }
            else { /* Here, must be an above Latin-1 code point */
                _CHECK_AND_OUTPUT_WIDE_LOCALE_UTF8_MSG(locinput, reginfo->strend);
                goto utf8_posix_above_latin1;
            }

            /* Here, must be utf8 */
            locinput += UTF8SKIP(locinput);
            break;

        case NPOSIXD:   /* \W or [:^punct:] etc. under /d */
            to_complement = 1;
            /* FALLTHROUGH */

        case POSIXD:    /* \w or [:punct:] etc. under /d */
            if (utf8_target) {
                goto utf8_posix;
            }
            goto posixa;

        case NPOSIXA:   /* \W or [:^punct:] etc. under /a */

            if (NEXTCHR_IS_EOS) {
                sayNO;
            }

            /* All UTF-8 variants match */
            if (! UTF8_IS_INVARIANT(nextchr)) {
                goto increment_locinput;
            }

            to_complement = 1;
            goto join_nposixa;

        case POSIXA:    /* \w or [:punct:] etc. under /a */

          posixa:
            /* We get here through POSIXD, NPOSIXD, and NPOSIXA when not in
             * UTF-8, and also from NPOSIXA even in UTF-8 when the current
             * character is a single byte */

            if (NEXTCHR_IS_EOS) {
                sayNO;
            }

          join_nposixa:

            if (! (to_complement ^ cBOOL(_generic_isCC_A(nextchr,
                                                                FLAGS(scan)))))
            {
                sayNO;
            }

            /* Here we are either not in utf8, or we matched a utf8-invariant,
             * so the next char is the next byte */
            locinput++;
            break;

        case NPOSIXU:   /* \W or [:^punct:] etc. under /u */
            to_complement = 1;
            /* FALLTHROUGH */

        case POSIXU:    /* \w or [:punct:] etc. under /u */
          utf8_posix:
            if (NEXTCHR_IS_EOS) {
                sayNO;
            }

            /* Use _generic_isCC() for characters within Latin1.  (Note that
             * UTF8_IS_INVARIANT works even on non-UTF-8 strings, or else
             * wouldn't be invariant) */
            if (UTF8_IS_INVARIANT(nextchr) || ! utf8_target) {
                if (! (to_complement ^ cBOOL(_generic_isCC(nextchr,
                                                           FLAGS(scan)))))
                {
                    sayNO;
                }
                locinput++;
            }
            else if (UTF8_IS_DOWNGRADEABLE_START(nextchr)) {
                if (! (to_complement
                       ^ cBOOL(_generic_isCC(EIGHT_BIT_UTF8_TO_NATIVE(nextchr,
                                                               *(locinput + 1)),
                                             FLAGS(scan)))))
                {
                    sayNO;
                }
                locinput += 2;
            }
            else {  /* Handle above Latin-1 code points */
              utf8_posix_above_latin1:
                classnum = (_char_class_number) FLAGS(scan);
                if (classnum < _FIRST_NON_SWASH_CC) {

                    /* Here, uses a swash to find such code points.  Load if if
                     * not done already */
                    if (! PL_utf8_swash_ptrs[classnum]) {
                        U8 flags = _CORE_SWASH_INIT_ACCEPT_INVLIST;
                        PL_utf8_swash_ptrs[classnum]
                                = _core_swash_init("utf8",
                                        "",
                                        &PL_sv_undef, 1, 0,
                                        PL_XPosix_ptrs[classnum], &flags);
                    }
                    if (! (to_complement
                           ^ cBOOL(swash_fetch(PL_utf8_swash_ptrs[classnum],
                                               (U8 *) locinput, TRUE))))
                    {
                        sayNO;
                    }
                }
                else {  /* Here, uses macros to find above Latin-1 code points */
                    switch (classnum) {
                        case _CC_ENUM_SPACE:
                            if (! (to_complement
                                        ^ cBOOL(is_XPERLSPACE_high(locinput))))
                            {
                                sayNO;
                            }
                            break;
                        case _CC_ENUM_BLANK:
                            if (! (to_complement
                                            ^ cBOOL(is_HORIZWS_high(locinput))))
                            {
                                sayNO;
                            }
                            break;
                        case _CC_ENUM_XDIGIT:
                            if (! (to_complement
                                            ^ cBOOL(is_XDIGIT_high(locinput))))
                            {
                                sayNO;
                            }
                            break;
                        case _CC_ENUM_VERTSPACE:
                            if (! (to_complement
                                            ^ cBOOL(is_VERTWS_high(locinput))))
                            {
                                sayNO;
                            }
                            break;
                        default:    /* The rest, e.g. [:cntrl:], can't match
                                       above Latin1 */
                            if (! to_complement) {
                                sayNO;
                            }
                            break;
                    }
                }
                locinput += UTF8SKIP(locinput);
            }
            break;

	case CLUMP: /* Match \X: logical Unicode character.  This is defined as
		       a Unicode extended Grapheme Cluster */
	    if (NEXTCHR_IS_EOS)
		sayNO;
	    if  (! utf8_target) {

		/* Match either CR LF  or '.', as all the other possibilities
		 * require utf8 */
		locinput++;	    /* Match the . or CR */
		if (nextchr == '\r' /* And if it was CR, and the next is LF,
				       match the LF */
		    && locinput < reginfo->strend
		    && UCHARAT(locinput) == '\n')
                {
                    locinput++;
                }
	    }
	    else {

                /* Get the gcb type for the current character */
                GCB_enum prev_gcb = getGCB_VAL_UTF8((U8*) locinput,
                                                       (U8*) reginfo->strend);

                /* Then scan through the input until we get to the first
                 * character whose type is supposed to be a gcb with the
                 * current character.  (There is always a break at the
                 * end-of-input) */
                locinput += UTF8SKIP(locinput);
                while (locinput < reginfo->strend) {
                    GCB_enum cur_gcb = getGCB_VAL_UTF8((U8*) locinput,
                                                         (U8*) reginfo->strend);
                    if (isGCB(prev_gcb, cur_gcb)) {
                        break;
                    }

                    prev_gcb = cur_gcb;
                    locinput += UTF8SKIP(locinput);
                }


	    }
	    break;
            
	case NREFFL:  /*  /\g{name}/il  */
	{   /* The capture buffer cases.  The ones beginning with N for the
	       named buffers just convert to the equivalent numbered and
	       pretend they were called as the corresponding numbered buffer
	       op.  */
	    /* don't initialize these in the declaration, it makes C++
	       unhappy */
	    const char *s;
	    char type;
	    re_fold_t folder;
	    const U8 *fold_array;
	    UV utf8_fold_flags;

            _CHECK_AND_WARN_PROBLEMATIC_LOCALE;
	    folder = foldEQ_locale;
	    fold_array = PL_fold_locale;
	    type = REFFL;
	    utf8_fold_flags = FOLDEQ_LOCALE;
	    goto do_nref;

	case NREFFA:  /*  /\g{name}/iaa  */
	    folder = foldEQ_latin1;
	    fold_array = PL_fold_latin1;
	    type = REFFA;
	    utf8_fold_flags = FOLDEQ_UTF8_NOMIX_ASCII;
	    goto do_nref;

	case NREFFU:  /*  /\g{name}/iu  */
	    folder = foldEQ_latin1;
	    fold_array = PL_fold_latin1;
	    type = REFFU;
	    utf8_fold_flags = 0;
	    goto do_nref;

	case NREFF:  /*  /\g{name}/i  */
	    folder = foldEQ;
	    fold_array = PL_fold;
	    type = REFF;
	    utf8_fold_flags = 0;
	    goto do_nref;

	case NREF:  /*  /\g{name}/   */
	    type = REF;
	    folder = NULL;
	    fold_array = NULL;
	    utf8_fold_flags = 0;
	  do_nref:

	    /* For the named back references, find the corresponding buffer
	     * number */
	    n = reg_check_named_buff_matched(rex,scan);

            if ( ! n ) {
                sayNO;
	    }
	    goto do_nref_ref_common;

	case REFFL:  /*  /\1/il  */
            _CHECK_AND_WARN_PROBLEMATIC_LOCALE;
	    folder = foldEQ_locale;
	    fold_array = PL_fold_locale;
	    utf8_fold_flags = FOLDEQ_LOCALE;
	    goto do_ref;

	case REFFA:  /*  /\1/iaa  */
	    folder = foldEQ_latin1;
	    fold_array = PL_fold_latin1;
	    utf8_fold_flags = FOLDEQ_UTF8_NOMIX_ASCII;
	    goto do_ref;

	case REFFU:  /*  /\1/iu  */
	    folder = foldEQ_latin1;
	    fold_array = PL_fold_latin1;
	    utf8_fold_flags = 0;
	    goto do_ref;

	case REFF:  /*  /\1/i  */
	    folder = foldEQ;
	    fold_array = PL_fold;
	    utf8_fold_flags = 0;
	    goto do_ref;

        case REF:  /*  /\1/    */
	    folder = NULL;
	    fold_array = NULL;
	    utf8_fold_flags = 0;

	  do_ref:
	    type = OP(scan);
	    n = ARG(scan);  /* which paren pair */

	  do_nref_ref_common:
	    ln = rex->offs[n].start;
	    reginfo->poscache_iter = reginfo->poscache_maxiter; /* Void cache */
	    if (rex->lastparen < n || ln == -1)
		sayNO;			/* Do not match unless seen CLOSEn. */
	    if (ln == rex->offs[n].end)
		break;

	    s = reginfo->strbeg + ln;
	    if (type != REF	/* REF can do byte comparison */
		&& (utf8_target || type == REFFU || type == REFFL))
	    {
		char * limit = reginfo->strend;

		/* This call case insensitively compares the entire buffer
		    * at s, with the current input starting at locinput, but
                    * not going off the end given by reginfo->strend, and
                    * returns in <limit> upon success, how much of the
                    * current input was matched */
		if (! foldEQ_utf8_flags(s, NULL, rex->offs[n].end - ln, utf8_target,
				    locinput, &limit, 0, utf8_target, utf8_fold_flags))
		{
		    sayNO;
		}
		locinput = limit;
		break;
	    }

	    /* Not utf8:  Inline the first character, for speed. */
	    if (!NEXTCHR_IS_EOS &&
                UCHARAT(s) != nextchr &&
		(type == REF ||
		 UCHARAT(s) != fold_array[nextchr]))
		sayNO;
	    ln = rex->offs[n].end - ln;
	    if (locinput + ln > reginfo->strend)
		sayNO;
	    if (ln > 1 && (type == REF
			   ? memNE(s, locinput, ln)
			   : ! folder(s, locinput, ln)))
		sayNO;
	    locinput += ln;
	    break;
	}

	case NOTHING: /* null op; e.g. the 'nothing' following
                       * the '*' in m{(a+|b)*}' */
	    break;
	case TAIL: /* placeholder while compiling (A|B|C) */
	    break;

#undef  ST
#define ST st->u.eval
#define CUR_EVAL cur_eval->u.eval

	{
	    SV *ret;
	    REGEXP *re_sv;
            regexp *re;
            regexp_internal *rei;
            regnode *startpoint;
            U32 arg;

	case GOSUB: /*    /(...(?1))/   /(...(?&foo))/   */
            arg= (U32)ARG(scan);
            if (cur_eval && cur_eval->locinput == locinput) {
                if ( ++nochange_depth > max_nochange_depth )
                    Perl_croak(aTHX_ 
                        "Pattern subroutine nesting without pos change"
                        " exceeded limit in regex");
            } else {
                nochange_depth = 0;
            }
	    re_sv = rex_sv;
            re = rex;
            rei = rexi;
            startpoint = scan + ARG2L(scan);
            EVAL_CLOSE_PAREN_SET( st, arg );
            /* Detect infinite recursion
             *
             * A pattern like /(?R)foo/ or /(?<x>(?&y)foo)(?<y>(?&x)bar)/
             * or "a"=~/(.(?2))((?<=(?=(?1)).))/ could recurse forever.
             * So we track the position in the string we are at each time
             * we recurse and if we try to enter the same routine twice from
             * the same position we throw an error.
             */
            if ( rex->recurse_locinput[arg] == locinput ) {
                /* FIXME: we should show the regop that is failing as part
                 * of the error message. */
                Perl_croak(aTHX_ "Infinite recursion in regex");
            } else {
                ST.prev_recurse_locinput= rex->recurse_locinput[arg];
                rex->recurse_locinput[arg]= locinput;

                DEBUG_r({
                    GET_RE_DEBUG_FLAGS_DECL;
                    DEBUG_STACK_r({
                        Perl_re_exec_indentf( aTHX_
                            "entering GOSUB, prev_recurse_locinput=%p recurse_locinput[%d]=%p\n",
                            depth, ST.prev_recurse_locinput, arg, rex->recurse_locinput[arg]
                        );
                    });
                });
            }

            /* Save all the positions seen so far. */
            ST.cp = regcppush(rex, 0, maxopenparen);
            REGCP_SET(ST.lastcp);

            /* and then jump to the code we share with EVAL */
            goto eval_recurse_doit;
            /* NOTREACHED */

        case EVAL:  /*   /(?{A})B/   /(??{A})B/  and /(?(?{A})X|Y)B/   */        
            if (cur_eval && cur_eval->locinput==locinput) {
		if ( ++nochange_depth > max_nochange_depth )
                    Perl_croak(aTHX_ "EVAL without pos change exceeded limit in regex");
            } else {
                nochange_depth = 0;
            }    
	    {
		/* execute the code in the {...} */

		dSP;
		IV before;
		OP * const oop = PL_op;
		COP * const ocurcop = PL_curcop;
		OP *nop;
		CV *newcv;

		/* save *all* paren positions */
		regcppush(rex, 0, maxopenparen);
		REGCP_SET(runops_cp);

		if (!caller_cv)
		    caller_cv = find_runcv(NULL);

		n = ARG(scan);

		if (rexi->data->what[n] == 'r') { /* code from an external qr */
                    newcv = (ReANY(
                                    (REGEXP*)(rexi->data->data[n])
                            ))->qr_anoncv;
		    nop = (OP*)rexi->data->data[n+1];
		}
		else if (rexi->data->what[n] == 'l') { /* literal code */
		    newcv = caller_cv;
		    nop = (OP*)rexi->data->data[n];
		    assert(CvDEPTH(newcv));
		}
		else {
		    /* literal with own CV */
		    assert(rexi->data->what[n] == 'L');
		    newcv = rex->qr_anoncv;
		    nop = (OP*)rexi->data->data[n];
		}

		/* normally if we're about to execute code from the same
		 * CV that we used previously, we just use the existing
		 * CX stack entry. However, its possible that in the
		 * meantime we may have backtracked, popped from the save
		 * stack, and undone the SAVECOMPPAD(s) associated with
		 * PUSH_MULTICALL; in which case PL_comppad no longer
		 * points to newcv's pad. */
		if (newcv != last_pushed_cv || PL_comppad != last_pad)
		{
                    U8 flags = (CXp_SUB_RE |
                                ((newcv == caller_cv) ? CXp_SUB_RE_FAKE : 0));
		    if (last_pushed_cv) {
                        /* PUSH/POP_MULTICALL save and restore the
                         * caller's PL_comppad; if we call multiple subs
                         * using the same CX block, we have to save and
                         * unwind the varying PL_comppad's ourselves,
                         * especially restoring the right PL_comppad on
                         * backtrack - so save it on the save stack */
                        SAVECOMPPAD();
			CHANGE_MULTICALL_FLAGS(newcv, flags);
		    }
		    else {
			PUSH_MULTICALL_FLAGS(newcv, flags);
		    }
		    last_pushed_cv = newcv;
		}
		else {
                    /* these assignments are just to silence compiler
                     * warnings */
		    multicall_cop = NULL;
		}
		last_pad = PL_comppad;

		/* the initial nextstate you would normally execute
		 * at the start of an eval (which would cause error
		 * messages to come from the eval), may be optimised
		 * away from the execution path in the regex code blocks;
		 * so manually set PL_curcop to it initially */
		{
		    OP *o = cUNOPx(nop)->op_first;
		    assert(o->op_type == OP_NULL);
		    if (o->op_targ == OP_SCOPE) {
			o = cUNOPo->op_first;
		    }
		    else {
			assert(o->op_targ == OP_LEAVE);
			o = cUNOPo->op_first;
			assert(o->op_type == OP_ENTER);
			o = OpSIBLING(o);
		    }

		    if (o->op_type != OP_STUB) {
			assert(    o->op_type == OP_NEXTSTATE
				|| o->op_type == OP_DBSTATE
				|| (o->op_type == OP_NULL
				    &&  (  o->op_targ == OP_NEXTSTATE
					|| o->op_targ == OP_DBSTATE
					)
				    )
			);
			PL_curcop = (COP*)o;
		    }
		}
		nop = nop->op_next;

                DEBUG_STATE_r( Perl_re_printf( aTHX_
		    "  re EVAL PL_op=0x%"UVxf"\n", PTR2UV(nop)) );

		rex->offs[0].end = locinput - reginfo->strbeg;
                if (reginfo->info_aux_eval->pos_magic)
                    MgBYTEPOS_set(reginfo->info_aux_eval->pos_magic,
                                  reginfo->sv, reginfo->strbeg,
                                  locinput - reginfo->strbeg);

                if (sv_yes_mark) {
                    SV *sv_mrk = get_sv("REGMARK", 1);
                    sv_setsv(sv_mrk, sv_yes_mark);
                }

		/* we don't use MULTICALL here as we want to call the
		 * first op of the block of interest, rather than the
		 * first op of the sub. Also, we don't want to free
                 * the savestack frame */
		before = (IV)(SP-PL_stack_base);
		PL_op = nop;
		CALLRUNOPS(aTHX);			/* Scalar context. */
		SPAGAIN;
		if ((IV)(SP-PL_stack_base) == before)
		    ret = &PL_sv_undef;   /* protect against empty (?{}) blocks. */
		else {
		    ret = POPs;
		    PUTBACK;
		}

		/* before restoring everything, evaluate the returned
		 * value, so that 'uninit' warnings don't use the wrong
		 * PL_op or pad. Also need to process any magic vars
		 * (e.g. $1) *before* parentheses are restored */

		PL_op = NULL;

                re_sv = NULL;
		if (logical == 0)        /*   (?{})/   */
		    sv_setsv(save_scalar(PL_replgv), ret); /* $^R */
		else if (logical == 1) { /*   /(?(?{...})X|Y)/    */
		    sw = cBOOL(SvTRUE(ret));
		    logical = 0;
		}
		else {                   /*  /(??{})  */
		    /*  if its overloaded, let the regex compiler handle
		     *  it; otherwise extract regex, or stringify  */
		    if (SvGMAGICAL(ret))
			ret = sv_mortalcopy(ret);
		    if (!SvAMAGIC(ret)) {
			SV *sv = ret;
			if (SvROK(sv))
			    sv = SvRV(sv);
			if (SvTYPE(sv) == SVt_REGEXP)
			    re_sv = (REGEXP*) sv;
			else if (SvSMAGICAL(ret)) {
			    MAGIC *mg = mg_find(ret, PERL_MAGIC_qr);
			    if (mg)
				re_sv = (REGEXP *) mg->mg_obj;
			}

			/* force any undef warnings here */
			if (!re_sv && !SvPOK(ret) && !SvNIOK(ret)) {
			    ret = sv_mortalcopy(ret);
			    (void) SvPV_force_nolen(ret);
			}
		    }

		}

		/* *** Note that at this point we don't restore
		 * PL_comppad, (or pop the CxSUB) on the assumption it may
		 * be used again soon. This is safe as long as nothing
		 * in the regexp code uses the pad ! */
		PL_op = oop;
		PL_curcop = ocurcop;
		S_regcp_restore(aTHX_ rex, runops_cp, &maxopenparen);
		PL_curpm = PL_reg_curpm;

		if (logical != 2)
		    break;
	    }

		/* only /(??{})/  from now on */
		logical = 0;
		{
		    /* extract RE object from returned value; compiling if
		     * necessary */

		    if (re_sv) {
			re_sv = reg_temp_copy(NULL, re_sv);
		    }
		    else {
			U32 pm_flags = 0;

			if (SvUTF8(ret) && IN_BYTES) {
			    /* In use 'bytes': make a copy of the octet
			     * sequence, but without the flag on */
			    STRLEN len;
			    const char *const p = SvPV(ret, len);
			    ret = newSVpvn_flags(p, len, SVs_TEMP);
			}
			if (rex->intflags & PREGf_USE_RE_EVAL)
			    pm_flags |= PMf_USE_RE_EVAL;

			/* if we got here, it should be an engine which
			 * supports compiling code blocks and stuff */
			assert(rex->engine && rex->engine->op_comp);
                        assert(!(scan->flags & ~RXf_PMf_COMPILETIME));
			re_sv = rex->engine->op_comp(aTHX_ &ret, 1, NULL,
				    rex->engine, NULL, NULL,
                                    /* copy /msixn etc to inner pattern */
                                    ARG2L(scan),
                                    pm_flags);

			if (!(SvFLAGS(ret)
			      & (SVs_TEMP | SVs_GMG | SVf_ROK))
			 && (!SvPADTMP(ret) || SvREADONLY(ret))) {
			    /* This isn't a first class regexp. Instead, it's
			       caching a regexp onto an existing, Perl visible
			       scalar.  */
			    sv_magic(ret, MUTABLE_SV(re_sv), PERL_MAGIC_qr, 0, 0);
			}
		    }
		    SAVEFREESV(re_sv);
		    re = ReANY(re_sv);
		}
                RXp_MATCH_COPIED_off(re);
                re->subbeg = rex->subbeg;
                re->sublen = rex->sublen;
                re->suboffset = rex->suboffset;
                re->subcoffset = rex->subcoffset;
                re->lastparen = 0;
                re->lastcloseparen = 0;
		rei = RXi_GET(re);
                DEBUG_EXECUTE_r(
                    debug_start_match(re_sv, utf8_target, locinput,
                                    reginfo->strend, "Matching embedded");
		);		
		startpoint = rei->program + 1;
                EVAL_CLOSE_PAREN_CLEAR(st); /* ST.close_paren = 0;
                                             * close_paren only for GOSUB */
                ST.prev_recurse_locinput= NULL; /* only used for GOSUB */
                /* Save all the seen positions so far. */
                ST.cp = regcppush(rex, 0, maxopenparen);
                REGCP_SET(ST.lastcp);
                /* and set maxopenparen to 0, since we are starting a "fresh" match */
                maxopenparen = 0;
                /* run the pattern returned from (??{...}) */

              eval_recurse_doit: /* Share code with GOSUB below this line
                            * At this point we expect the stack context to be
                            * set up correctly */

                /* invalidate the S-L poscache. We're now executing a
                 * different set of WHILEM ops (and their associated
                 * indexes) against the same string, so the bits in the
                 * cache are meaningless. Setting maxiter to zero forces
                 * the cache to be invalidated and zeroed before reuse.
		 * XXX This is too dramatic a measure. Ideally we should
                 * save the old cache and restore when running the outer
                 * pattern again */
		reginfo->poscache_maxiter = 0;

                /* the new regexp might have a different is_utf8_pat than we do */
                is_utf8_pat = reginfo->is_utf8_pat = cBOOL(RX_UTF8(re_sv));

		ST.prev_rex = rex_sv;
		ST.prev_curlyx = cur_curlyx;
		rex_sv = re_sv;
		SET_reg_curpm(rex_sv);
		rex = re;
		rexi = rei;
		cur_curlyx = NULL;
		ST.B = next;
		ST.prev_eval = cur_eval;
		cur_eval = st;
		/* now continue from first node in postoned RE */
		PUSH_YES_STATE_GOTO(EVAL_AB, startpoint, locinput);
		NOT_REACHED; /* NOTREACHED */
	}

	case EVAL_AB: /* cleanup after a successful (??{A})B */
            /* note: this is called twice; first after popping B, then A */
            DEBUG_STACK_r({
                Perl_re_exec_indentf( aTHX_  "EVAL_AB cur_eval=%p prev_eval=%p\n",
                    depth, cur_eval, ST.prev_eval);
            });

#define SET_RECURSE_LOCINPUT(STR,VAL)\
            if ( cur_eval && CUR_EVAL.close_paren ) {\
                DEBUG_STACK_r({ \
                    Perl_re_exec_indentf( aTHX_  STR " GOSUB%d ce=%p recurse_locinput=%p\n",\
                        depth,    \
                        CUR_EVAL.close_paren - 1,\
                        cur_eval, \
                        VAL);     \
                });               \
                rex->recurse_locinput[CUR_EVAL.close_paren - 1] = VAL;\
            }

            SET_RECURSE_LOCINPUT("EVAL_AB[before]", CUR_EVAL.prev_recurse_locinput);

	    rex_sv = ST.prev_rex;
            is_utf8_pat = reginfo->is_utf8_pat = cBOOL(RX_UTF8(rex_sv));
	    SET_reg_curpm(rex_sv);
	    rex = ReANY(rex_sv);
	    rexi = RXi_GET(rex);
            {
                /* preserve $^R across LEAVE's. See Bug 121070. */
                SV *save_sv= GvSV(PL_replgv);
                SvREFCNT_inc(save_sv);
                regcpblow(ST.cp); /* LEAVE in disguise */
                sv_setsv(GvSV(PL_replgv), save_sv);
                SvREFCNT_dec(save_sv);
            }
	    cur_eval = ST.prev_eval;
	    cur_curlyx = ST.prev_curlyx;

	    /* Invalidate cache. See "invalidate" comment above. */
	    reginfo->poscache_maxiter = 0;
            if ( nochange_depth )
	        nochange_depth--;

            SET_RECURSE_LOCINPUT("EVAL_AB[after]", cur_eval->locinput);
	    sayYES;


	case EVAL_AB_fail: /* unsuccessfully ran A or B in (??{A})B */
	    /* note: this is called twice; first after popping B, then A */
            DEBUG_STACK_r({
                Perl_re_exec_indentf( aTHX_  "EVAL_AB_fail cur_eval=%p prev_eval=%p\n",
                    depth, cur_eval, ST.prev_eval);
            });

            SET_RECURSE_LOCINPUT("EVAL_AB_fail[before]", CUR_EVAL.prev_recurse_locinput);

	    rex_sv = ST.prev_rex;
            is_utf8_pat = reginfo->is_utf8_pat = cBOOL(RX_UTF8(rex_sv));
	    SET_reg_curpm(rex_sv);
	    rex = ReANY(rex_sv);
	    rexi = RXi_GET(rex); 

	    REGCP_UNWIND(ST.lastcp);
	    regcppop(rex, &maxopenparen);
	    cur_eval = ST.prev_eval;
	    cur_curlyx = ST.prev_curlyx;

	    /* Invalidate cache. See "invalidate" comment above. */
	    reginfo->poscache_maxiter = 0;
	    if ( nochange_depth )
	        nochange_depth--;

            SET_RECURSE_LOCINPUT("EVAL_AB_fail[after]", cur_eval->locinput);
            sayNO_SILENT;
#undef ST

	case OPEN: /*  (  */
	    n = ARG(scan);  /* which paren pair */
	    rex->offs[n].start_tmp = locinput - reginfo->strbeg;
	    if (n > maxopenparen)
		maxopenparen = n;
            DEBUG_BUFFERS_r(Perl_re_printf( aTHX_
		"rex=0x%"UVxf" offs=0x%"UVxf": \\%"UVuf": set %"IVdf" tmp; maxopenparen=%"UVuf"\n",
		PTR2UV(rex),
		PTR2UV(rex->offs),
		(UV)n,
		(IV)rex->offs[n].start_tmp,
		(UV)maxopenparen
	    ));
            lastopen = n;
	    break;

/* XXX really need to log other places start/end are set too */
#define CLOSE_CAPTURE                                                      \
    rex->offs[n].start = rex->offs[n].start_tmp;                           \
    rex->offs[n].end = locinput - reginfo->strbeg;                         \
    DEBUG_BUFFERS_r(Perl_re_printf( aTHX_                                              \
        "rex=0x%"UVxf" offs=0x%"UVxf": \\%"UVuf": set %"IVdf"..%"IVdf"\n", \
        PTR2UV(rex),                                                       \
        PTR2UV(rex->offs),                                                 \
        (UV)n,                                                             \
        (IV)rex->offs[n].start,                                            \
        (IV)rex->offs[n].end                                               \
    ))

	case CLOSE:  /*  )  */
	    n = ARG(scan);  /* which paren pair */
	    CLOSE_CAPTURE;
	    if (n > rex->lastparen)
		rex->lastparen = n;
	    rex->lastcloseparen = n;
            if ( EVAL_CLOSE_PAREN_IS( cur_eval, n ) )
	        goto fake_end;

	    break;

        case ACCEPT:  /*  (*ACCEPT)  */
            if (scan->flags)
                sv_yes_mark = MUTABLE_SV(rexi->data->data[ ARG( scan ) ]);
            if (ARG2L(scan)){
                regnode *cursor;
                for (cursor=scan;
                     cursor && OP(cursor)!=END; 
                     cursor=regnext(cursor)) 
                {
                    if ( OP(cursor)==CLOSE ){
                        n = ARG(cursor);
                        if ( n <= lastopen ) {
			    CLOSE_CAPTURE;
                            if (n > rex->lastparen)
                                rex->lastparen = n;
                            rex->lastcloseparen = n;
                            if ( n == ARG(scan) || EVAL_CLOSE_PAREN_IS(cur_eval, n) )
                                break;
                        }
                    }
                }
            }
	    goto fake_end;
	    /* NOTREACHED */

	case GROUPP:  /*  (?(1))  */
	    n = ARG(scan);  /* which paren pair */
	    sw = cBOOL(rex->lastparen >= n && rex->offs[n].end != -1);
	    break;

	case NGROUPP:  /*  (?(<name>))  */
	    /* reg_check_named_buff_matched returns 0 for no match */
	    sw = cBOOL(0 < reg_check_named_buff_matched(rex,scan));
	    break;

        case INSUBP:   /*  (?(R))  */
            n = ARG(scan);
            /* this does not need to use EVAL_CLOSE_PAREN macros, as the arg
             * of SCAN is already set up as matches a eval.close_paren */
            sw = cur_eval && (n == 0 || CUR_EVAL.close_paren == n);
            break;

        case DEFINEP:  /*  (?(DEFINE))  */
            sw = 0;
            break;

	case IFTHEN:   /*  (?(cond)A|B)  */
	    reginfo->poscache_iter = reginfo->poscache_maxiter; /* Void cache */
	    if (sw)
		next = NEXTOPER(NEXTOPER(scan));
	    else {
		next = scan + ARG(scan);
		if (OP(next) == IFTHEN) /* Fake one. */
		    next = NEXTOPER(NEXTOPER(next));
	    }
	    break;

	case LOGICAL:  /* modifier for EVAL and IFMATCH */
	    logical = scan->flags;
	    break;

/*******************************************************************

The CURLYX/WHILEM pair of ops handle the most generic case of the /A*B/
pattern, where A and B are subpatterns. (For simple A, CURLYM or
STAR/PLUS/CURLY/CURLYN are used instead.)

A*B is compiled as <CURLYX><A><WHILEM><B>

On entry to the subpattern, CURLYX is called. This pushes a CURLYX
state, which contains the current count, initialised to -1. It also sets
cur_curlyx to point to this state, with any previous value saved in the
state block.

CURLYX then jumps straight to the WHILEM op, rather than executing A,
since the pattern may possibly match zero times (i.e. it's a while {} loop
rather than a do {} while loop).

Each entry to WHILEM represents a successful match of A. The count in the
CURLYX block is incremented, another WHILEM state is pushed, and execution
passes to A or B depending on greediness and the current count.

For example, if matching against the string a1a2a3b (where the aN are
substrings that match /A/), then the match progresses as follows: (the
pushed states are interspersed with the bits of strings matched so far):

    <CURLYX cnt=-1>
    <CURLYX cnt=0><WHILEM>
    <CURLYX cnt=1><WHILEM> a1 <WHILEM>
    <CURLYX cnt=2><WHILEM> a1 <WHILEM> a2 <WHILEM>
    <CURLYX cnt=3><WHILEM> a1 <WHILEM> a2 <WHILEM> a3 <WHILEM>
    <CURLYX cnt=3><WHILEM> a1 <WHILEM> a2 <WHILEM> a3 <WHILEM> b

(Contrast this with something like CURLYM, which maintains only a single
backtrack state:

    <CURLYM cnt=0> a1
    a1 <CURLYM cnt=1> a2
    a1 a2 <CURLYM cnt=2> a3
    a1 a2 a3 <CURLYM cnt=3> b
)

Each WHILEM state block marks a point to backtrack to upon partial failure
of A or B, and also contains some minor state data related to that
iteration.  The CURLYX block, pointed to by cur_curlyx, contains the
overall state, such as the count, and pointers to the A and B ops.

This is complicated slightly by nested CURLYX/WHILEM's. Since cur_curlyx
must always point to the *current* CURLYX block, the rules are:

When executing CURLYX, save the old cur_curlyx in the CURLYX state block,
and set cur_curlyx to point the new block.

When popping the CURLYX block after a successful or unsuccessful match,
restore the previous cur_curlyx.

When WHILEM is about to execute B, save the current cur_curlyx, and set it
to the outer one saved in the CURLYX block.

When popping the WHILEM block after a successful or unsuccessful B match,
restore the previous cur_curlyx.

Here's an example for the pattern (AI* BI)*BO
I and O refer to inner and outer, C and W refer to CURLYX and WHILEM:

cur_
curlyx backtrack stack
------ ---------------
NULL   
CO     <CO prev=NULL> <WO>
CI     <CO prev=NULL> <WO> <CI prev=CO> <WI> ai 
CO     <CO prev=NULL> <WO> <CI prev=CO> <WI> ai <WI prev=CI> bi 
NULL   <CO prev=NULL> <WO> <CI prev=CO> <WI> ai <WI prev=CI> bi <WO prev=CO> bo

At this point the pattern succeeds, and we work back down the stack to
clean up, restoring as we go:

CO     <CO prev=NULL> <WO> <CI prev=CO> <WI> ai <WI prev=CI> bi 
CI     <CO prev=NULL> <WO> <CI prev=CO> <WI> ai 
CO     <CO prev=NULL> <WO>
NULL   

*******************************************************************/

#define ST st->u.curlyx

	case CURLYX:    /* start of /A*B/  (for complex A) */
	{
	    /* No need to save/restore up to this paren */
	    I32 parenfloor = scan->flags;
	    
	    assert(next); /* keep Coverity happy */
	    if (OP(PREVOPER(next)) == NOTHING) /* LONGJMP */
		next += ARG(next);

	    /* XXXX Probably it is better to teach regpush to support
	       parenfloor > maxopenparen ... */
	    if (parenfloor > (I32)rex->lastparen)
		parenfloor = rex->lastparen; /* Pessimization... */

	    ST.prev_curlyx= cur_curlyx;
	    cur_curlyx = st;
	    ST.cp = PL_savestack_ix;

	    /* these fields contain the state of the current curly.
	     * they are accessed by subsequent WHILEMs */
	    ST.parenfloor = parenfloor;
	    ST.me = scan;
	    ST.B = next;
	    ST.minmod = minmod;
	    minmod = 0;
	    ST.count = -1;	/* this will be updated by WHILEM */
	    ST.lastloc = NULL;  /* this will be updated by WHILEM */

	    PUSH_YES_STATE_GOTO(CURLYX_end, PREVOPER(next), locinput);
	    NOT_REACHED; /* NOTREACHED */
	}

	case CURLYX_end: /* just finished matching all of A*B */
	    cur_curlyx = ST.prev_curlyx;
	    sayYES;
	    NOT_REACHED; /* NOTREACHED */

	case CURLYX_end_fail: /* just failed to match all of A*B */
	    regcpblow(ST.cp);
	    cur_curlyx = ST.prev_curlyx;
	    sayNO;
	    NOT_REACHED; /* NOTREACHED */


#undef ST
#define ST st->u.whilem

	case WHILEM:     /* just matched an A in /A*B/  (for complex A) */
	{
	    /* see the discussion above about CURLYX/WHILEM */
	    I32 n;
	    int min, max;
	    regnode *A;

	    assert(cur_curlyx); /* keep Coverity happy */

	    min = ARG1(cur_curlyx->u.curlyx.me);
	    max = ARG2(cur_curlyx->u.curlyx.me);
	    A = NEXTOPER(cur_curlyx->u.curlyx.me) + EXTRA_STEP_2ARGS;
	    n = ++cur_curlyx->u.curlyx.count; /* how many A's matched */
	    ST.save_lastloc = cur_curlyx->u.curlyx.lastloc;
	    ST.cache_offset = 0;
	    ST.cache_mask = 0;
	    

            DEBUG_EXECUTE_r( Perl_re_exec_indentf( aTHX_  "whilem: matched %ld out of %d..%d\n",
                  depth, (long)n, min, max)
	    );

	    /* First just match a string of min A's. */

	    if (n < min) {
		ST.cp = regcppush(rex, cur_curlyx->u.curlyx.parenfloor,
                                    maxopenparen);
		cur_curlyx->u.curlyx.lastloc = locinput;
		REGCP_SET(ST.lastcp);

		PUSH_STATE_GOTO(WHILEM_A_pre, A, locinput);
		NOT_REACHED; /* NOTREACHED */
	    }

	    /* If degenerate A matches "", assume A done. */

	    if (locinput == cur_curlyx->u.curlyx.lastloc) {
                DEBUG_EXECUTE_r( Perl_re_exec_indentf( aTHX_  "whilem: empty match detected, trying continuation...\n",
                   depth)
		);
		goto do_whilem_B_max;
	    }

	    /* super-linear cache processing.
             *
             * The idea here is that for certain types of CURLYX/WHILEM -
             * principally those whose upper bound is infinity (and
             * excluding regexes that have things like \1 and other very
             * non-regular expresssiony things), then if a pattern like
             * /....A*.../ fails and we backtrack to the WHILEM, then we
             * make a note that this particular WHILEM op was at string
             * position 47 (say) when the rest of pattern failed. Then, if
             * we ever find ourselves back at that WHILEM, and at string
             * position 47 again, we can just fail immediately rather than
             * running the rest of the pattern again.
             *
             * This is very handy when patterns start to go
             * 'super-linear', like in (a+)*(a+)*(a+)*, where you end up
             * with a combinatorial explosion of backtracking.
             *
             * The cache is implemented as a bit array, with one bit per
             * string byte position per WHILEM op (up to 16) - so its
             * between 0.25 and 2x the string size.
             *
             * To avoid allocating a poscache buffer every time, we do an
             * initially countdown; only after we have  executed a WHILEM
             * op (string-length x #WHILEMs) times do we allocate the
             * cache.
             *
             * The top 4 bits of scan->flags byte say how many different
             * relevant CURLLYX/WHILEM op pairs there are, while the
             * bottom 4-bits is the identifying index number of this
             * WHILEM.
             */

	    if (scan->flags) {

		if (!reginfo->poscache_maxiter) {
		    /* start the countdown: Postpone detection until we
		     * know the match is not *that* much linear. */
		    reginfo->poscache_maxiter
                        =    (reginfo->strend - reginfo->strbeg + 1)
                           * (scan->flags>>4);
		    /* possible overflow for long strings and many CURLYX's */
		    if (reginfo->poscache_maxiter < 0)
			reginfo->poscache_maxiter = I32_MAX;
		    reginfo->poscache_iter = reginfo->poscache_maxiter;
		}

		if (reginfo->poscache_iter-- == 0) {
		    /* initialise cache */
		    const SSize_t size = (reginfo->poscache_maxiter + 7)/8;
                    regmatch_info_aux *const aux = reginfo->info_aux;
		    if (aux->poscache) {
			if ((SSize_t)reginfo->poscache_size < size) {
			    Renew(aux->poscache, size, char);
			    reginfo->poscache_size = size;
			}
			Zero(aux->poscache, size, char);
		    }
		    else {
			reginfo->poscache_size = size;
			Newxz(aux->poscache, size, char);
		    }
                    DEBUG_EXECUTE_r( Perl_re_printf( aTHX_
      "%swhilem: Detected a super-linear match, switching on caching%s...\n",
			      PL_colors[4], PL_colors[5])
		    );
		}

		if (reginfo->poscache_iter < 0) {
		    /* have we already failed at this position? */
		    SSize_t offset, mask;

                    reginfo->poscache_iter = -1; /* stop eventual underflow */
		    offset  = (scan->flags & 0xf) - 1
                                +   (locinput - reginfo->strbeg)
                                  * (scan->flags>>4);
		    mask    = 1 << (offset % 8);
		    offset /= 8;
		    if (reginfo->info_aux->poscache[offset] & mask) {
                        DEBUG_EXECUTE_r( Perl_re_exec_indentf( aTHX_  "whilem: (cache) already tried at this position...\n",
                            depth)
			);
			sayNO; /* cache records failure */
		    }
		    ST.cache_offset = offset;
		    ST.cache_mask   = mask;
		}
	    }

	    /* Prefer B over A for minimal matching. */

	    if (cur_curlyx->u.curlyx.minmod) {
		ST.save_curlyx = cur_curlyx;
		cur_curlyx = cur_curlyx->u.curlyx.prev_curlyx;
		ST.cp = regcppush(rex, ST.save_curlyx->u.curlyx.parenfloor,
                            maxopenparen);
		REGCP_SET(ST.lastcp);
		PUSH_YES_STATE_GOTO(WHILEM_B_min, ST.save_curlyx->u.curlyx.B,
                                    locinput);
		NOT_REACHED; /* NOTREACHED */
	    }

	    /* Prefer A over B for maximal matching. */

	    if (n < max) { /* More greed allowed? */
		ST.cp = regcppush(rex, cur_curlyx->u.curlyx.parenfloor,
                            maxopenparen);
		cur_curlyx->u.curlyx.lastloc = locinput;
		REGCP_SET(ST.lastcp);
		PUSH_STATE_GOTO(WHILEM_A_max, A, locinput);
		NOT_REACHED; /* NOTREACHED */
	    }
	    goto do_whilem_B_max;
	}
	NOT_REACHED; /* NOTREACHED */

	case WHILEM_B_min: /* just matched B in a minimal match */
	case WHILEM_B_max: /* just matched B in a maximal match */
	    cur_curlyx = ST.save_curlyx;
	    sayYES;
	    NOT_REACHED; /* NOTREACHED */

	case WHILEM_B_max_fail: /* just failed to match B in a maximal match */
	    cur_curlyx = ST.save_curlyx;
	    cur_curlyx->u.curlyx.lastloc = ST.save_lastloc;
	    cur_curlyx->u.curlyx.count--;
	    CACHEsayNO;
	    NOT_REACHED; /* NOTREACHED */

	case WHILEM_A_min_fail: /* just failed to match A in a minimal match */
	    /* FALLTHROUGH */
	case WHILEM_A_pre_fail: /* just failed to match even minimal A */
	    REGCP_UNWIND(ST.lastcp);
	    regcppop(rex, &maxopenparen);
	    cur_curlyx->u.curlyx.lastloc = ST.save_lastloc;
	    cur_curlyx->u.curlyx.count--;
	    CACHEsayNO;
	    NOT_REACHED; /* NOTREACHED */

	case WHILEM_A_max_fail: /* just failed to match A in a maximal match */
	    REGCP_UNWIND(ST.lastcp);
	    regcppop(rex, &maxopenparen); /* Restore some previous $<digit>s? */
            DEBUG_EXECUTE_r(Perl_re_exec_indentf( aTHX_  "whilem: failed, trying continuation...\n",
                depth)
	    );
	  do_whilem_B_max:
	    if (cur_curlyx->u.curlyx.count >= REG_INFTY
		&& ckWARN(WARN_REGEXP)
		&& !reginfo->warned)
	    {
                reginfo->warned	= TRUE;
		Perl_warner(aTHX_ packWARN(WARN_REGEXP),
		     "Complex regular subexpression recursion limit (%d) "
		     "exceeded",
		     REG_INFTY - 1);
	    }

	    /* now try B */
	    ST.save_curlyx = cur_curlyx;
	    cur_curlyx = cur_curlyx->u.curlyx.prev_curlyx;
	    PUSH_YES_STATE_GOTO(WHILEM_B_max, ST.save_curlyx->u.curlyx.B,
                                locinput);
	    NOT_REACHED; /* NOTREACHED */

	case WHILEM_B_min_fail: /* just failed to match B in a minimal match */
	    cur_curlyx = ST.save_curlyx;
	    REGCP_UNWIND(ST.lastcp);
	    regcppop(rex, &maxopenparen);

	    if (cur_curlyx->u.curlyx.count >= /*max*/ARG2(cur_curlyx->u.curlyx.me)) {
		/* Maximum greed exceeded */
		if (cur_curlyx->u.curlyx.count >= REG_INFTY
		    && ckWARN(WARN_REGEXP)
                    && !reginfo->warned)
		{
                    reginfo->warned	= TRUE;
		    Perl_warner(aTHX_ packWARN(WARN_REGEXP),
			"Complex regular subexpression recursion "
			"limit (%d) exceeded",
			REG_INFTY - 1);
		}
		cur_curlyx->u.curlyx.count--;
		CACHEsayNO;
	    }

            DEBUG_EXECUTE_r(Perl_re_exec_indentf( aTHX_  "trying longer...\n", depth)
	    );
	    /* Try grabbing another A and see if it helps. */
	    cur_curlyx->u.curlyx.lastloc = locinput;
	    ST.cp = regcppush(rex, cur_curlyx->u.curlyx.parenfloor,
                            maxopenparen);
	    REGCP_SET(ST.lastcp);
	    PUSH_STATE_GOTO(WHILEM_A_min,
		/*A*/ NEXTOPER(ST.save_curlyx->u.curlyx.me) + EXTRA_STEP_2ARGS,
                locinput);
	    NOT_REACHED; /* NOTREACHED */

#undef  ST
#define ST st->u.branch

	case BRANCHJ:	    /*  /(...|A|...)/ with long next pointer */
	    next = scan + ARG(scan);
	    if (next == scan)
		next = NULL;
	    scan = NEXTOPER(scan);
	    /* FALLTHROUGH */

	case BRANCH:	    /*  /(...|A|...)/ */
	    scan = NEXTOPER(scan); /* scan now points to inner node */
	    ST.lastparen = rex->lastparen;
	    ST.lastcloseparen = rex->lastcloseparen;
	    ST.next_branch = next;
	    REGCP_SET(ST.cp);

	    /* Now go into the branch */
	    if (has_cutgroup) {
	        PUSH_YES_STATE_GOTO(BRANCH_next, scan, locinput);
	    } else {
	        PUSH_STATE_GOTO(BRANCH_next, scan, locinput);
	    }
	    NOT_REACHED; /* NOTREACHED */

        case CUTGROUP:  /*  /(*THEN)/  */
            sv_yes_mark = st->u.mark.mark_name = scan->flags
                ? MUTABLE_SV(rexi->data->data[ ARG( scan ) ])
                : NULL;
            PUSH_STATE_GOTO(CUTGROUP_next, next, locinput);
            NOT_REACHED; /* NOTREACHED */

        case CUTGROUP_next_fail:
            do_cutgroup = 1;
            no_final = 1;
            if (st->u.mark.mark_name)
                sv_commit = st->u.mark.mark_name;
            sayNO;	    
            NOT_REACHED; /* NOTREACHED */

        case BRANCH_next:
            sayYES;
            NOT_REACHED; /* NOTREACHED */

	case BRANCH_next_fail: /* that branch failed; try the next, if any */
	    if (do_cutgroup) {
	        do_cutgroup = 0;
	        no_final = 0;
	    }
	    REGCP_UNWIND(ST.cp);
            UNWIND_PAREN(ST.lastparen, ST.lastcloseparen);
	    scan = ST.next_branch;
	    /* no more branches? */
	    if (!scan || (OP(scan) != BRANCH && OP(scan) != BRANCHJ)) {
	        DEBUG_EXECUTE_r({
                    Perl_re_exec_indentf( aTHX_  "%sBRANCH failed...%s\n",
                        depth,
			PL_colors[4],
			PL_colors[5] );
		});
		sayNO_SILENT;
            }
	    continue; /* execute next BRANCH[J] op */
            /* NOTREACHED */
    
	case MINMOD: /* next op will be non-greedy, e.g. A*?  */
	    minmod = 1;
	    break;

#undef  ST
#define ST st->u.curlym

	case CURLYM:	/* /A{m,n}B/ where A is fixed-length */

	    /* This is an optimisation of CURLYX that enables us to push
	     * only a single backtracking state, no matter how many matches
	     * there are in {m,n}. It relies on the pattern being constant
	     * length, with no parens to influence future backrefs
	     */

	    ST.me = scan;
	    scan = NEXTOPER(scan) + NODE_STEP_REGNODE;

	    ST.lastparen      = rex->lastparen;
	    ST.lastcloseparen = rex->lastcloseparen;

	    /* if paren positive, emulate an OPEN/CLOSE around A */
	    if (ST.me->flags) {
		U32 paren = ST.me->flags;
		if (paren > maxopenparen)
		    maxopenparen = paren;
		scan += NEXT_OFF(scan); /* Skip former OPEN. */
	    }
	    ST.A = scan;
	    ST.B = next;
	    ST.alen = 0;
	    ST.count = 0;
	    ST.minmod = minmod;
	    minmod = 0;
	    ST.c1 = CHRTEST_UNINIT;
	    REGCP_SET(ST.cp);

	    if (!(ST.minmod ? ARG1(ST.me) : ARG2(ST.me))) /* min/max */
		goto curlym_do_B;

	  curlym_do_A: /* execute the A in /A{m,n}B/  */
	    PUSH_YES_STATE_GOTO(CURLYM_A, ST.A, locinput); /* match A */
	    NOT_REACHED; /* NOTREACHED */

	case CURLYM_A: /* we've just matched an A */
	    ST.count++;
	    /* after first match, determine A's length: u.curlym.alen */
	    if (ST.count == 1) {
		if (reginfo->is_utf8_target) {
		    char *s = st->locinput;
		    while (s < locinput) {
			ST.alen++;
			s += UTF8SKIP(s);
		    }
		}
		else {
		    ST.alen = locinput - st->locinput;
		}
		if (ST.alen == 0)
		    ST.count = ST.minmod ? ARG1(ST.me) : ARG2(ST.me);
	    }
	    DEBUG_EXECUTE_r(
                Perl_re_exec_indentf( aTHX_  "CURLYM now matched %"IVdf" times, len=%"IVdf"...\n",
                          depth, (IV) ST.count, (IV)ST.alen)
	    );

            if (EVAL_CLOSE_PAREN_IS_TRUE(cur_eval,(U32)ST.me->flags))
	        goto fake_end;
	        
	    {
		I32 max = (ST.minmod ? ARG1(ST.me) : ARG2(ST.me));
		if ( max == REG_INFTY || ST.count < max )
		    goto curlym_do_A; /* try to match another A */
	    }
	    goto curlym_do_B; /* try to match B */

	case CURLYM_A_fail: /* just failed to match an A */
	    REGCP_UNWIND(ST.cp);


	    if (ST.minmod || ST.count < ARG1(ST.me) /* min*/ 
                || EVAL_CLOSE_PAREN_IS_TRUE(cur_eval,(U32)ST.me->flags))
		sayNO;

	  curlym_do_B: /* execute the B in /A{m,n}B/  */
	    if (ST.c1 == CHRTEST_UNINIT) {
		/* calculate c1 and c2 for possible match of 1st char
		 * following curly */
		ST.c1 = ST.c2 = CHRTEST_VOID;
                assert(ST.B);
		if (HAS_TEXT(ST.B) || JUMPABLE(ST.B)) {
		    regnode *text_node = ST.B;
		    if (! HAS_TEXT(text_node))
			FIND_NEXT_IMPT(text_node);
	            /* this used to be 
	                
	                (HAS_TEXT(text_node) && PL_regkind[OP(text_node)] == EXACT)
	                
	            	But the former is redundant in light of the latter.
	            	
	            	if this changes back then the macro for 
	            	IS_TEXT and friends need to change.
	             */
		    if (PL_regkind[OP(text_node)] == EXACT) {
                        if (! S_setup_EXACTISH_ST_c1_c2(aTHX_
                           text_node, &ST.c1, ST.c1_utf8, &ST.c2, ST.c2_utf8,
                           reginfo))
                        {
                            sayNO;
                        }
		    }
		}
	    }

	    DEBUG_EXECUTE_r(
                Perl_re_exec_indentf( aTHX_  "CURLYM trying tail with matches=%"IVdf"...\n",
                    depth, (IV)ST.count)
		);
	    if (! NEXTCHR_IS_EOS && ST.c1 != CHRTEST_VOID) {
                if (! UTF8_IS_INVARIANT(nextchr) && utf8_target) {
                    if (memNE(locinput, ST.c1_utf8, UTF8SKIP(locinput))
                        && memNE(locinput, ST.c2_utf8, UTF8SKIP(locinput)))
                    {
                        /* simulate B failing */
                        DEBUG_OPTIMISE_r(
                            Perl_re_exec_indentf( aTHX_  "CURLYM Fast bail next target=0x%"UVXf" c1=0x%"UVXf" c2=0x%"UVXf"\n",
                                depth,
                                valid_utf8_to_uvchr((U8 *) locinput, NULL),
                                valid_utf8_to_uvchr(ST.c1_utf8, NULL),
                                valid_utf8_to_uvchr(ST.c2_utf8, NULL))
                        );
                        state_num = CURLYM_B_fail;
                        goto reenter_switch;
                    }
                }
                else if (nextchr != ST.c1 && nextchr != ST.c2) {
                    /* simulate B failing */
                    DEBUG_OPTIMISE_r(
                        Perl_re_exec_indentf( aTHX_  "CURLYM Fast bail next target=0x%X c1=0x%X c2=0x%X\n",
                            depth,
                            (int) nextchr, ST.c1, ST.c2)
                    );
                    state_num = CURLYM_B_fail;
                    goto reenter_switch;
                }
            }

	    if (ST.me->flags) {
		/* emulate CLOSE: mark current A as captured */
		I32 paren = ST.me->flags;
		if (ST.count) {
		    rex->offs[paren].start
			= HOPc(locinput, -ST.alen) - reginfo->strbeg;
		    rex->offs[paren].end = locinput - reginfo->strbeg;
		    if ((U32)paren > rex->lastparen)
			rex->lastparen = paren;
		    rex->lastcloseparen = paren;
		}
		else
		    rex->offs[paren].end = -1;

                if (EVAL_CLOSE_PAREN_IS_TRUE(cur_eval,(U32)ST.me->flags))
		{
		    if (ST.count) 
	                goto fake_end;
	            else
	                sayNO;
	        }
	    }
	    
	    PUSH_STATE_GOTO(CURLYM_B, ST.B, locinput); /* match B */
	    NOT_REACHED; /* NOTREACHED */

	case CURLYM_B_fail: /* just failed to match a B */
	    REGCP_UNWIND(ST.cp);
            UNWIND_PAREN(ST.lastparen, ST.lastcloseparen);
	    if (ST.minmod) {
		I32 max = ARG2(ST.me);
		if (max != REG_INFTY && ST.count == max)
		    sayNO;
		goto curlym_do_A; /* try to match a further A */
	    }
	    /* backtrack one A */
	    if (ST.count == ARG1(ST.me) /* min */)
		sayNO;
	    ST.count--;
	    SET_locinput(HOPc(locinput, -ST.alen));
	    goto curlym_do_B; /* try to match B */

#undef ST
#define ST st->u.curly

#define CURLY_SETPAREN(paren, success) \
    if (paren) { \
	if (success) { \
	    rex->offs[paren].start = HOPc(locinput, -1) - reginfo->strbeg; \
	    rex->offs[paren].end = locinput - reginfo->strbeg; \
	    if (paren > rex->lastparen) \
		rex->lastparen = paren; \
	    rex->lastcloseparen = paren; \
	} \
	else { \
	    rex->offs[paren].end = -1; \
	    rex->lastparen      = ST.lastparen; \
	    rex->lastcloseparen = ST.lastcloseparen; \
	} \
    }

        case STAR:		/*  /A*B/ where A is width 1 char */
	    ST.paren = 0;
	    ST.min = 0;
	    ST.max = REG_INFTY;
	    scan = NEXTOPER(scan);
	    goto repeat;

        case PLUS:		/*  /A+B/ where A is width 1 char */
	    ST.paren = 0;
	    ST.min = 1;
	    ST.max = REG_INFTY;
	    scan = NEXTOPER(scan);
	    goto repeat;

	case CURLYN:		/*  /(A){m,n}B/ where A is width 1 char */
            ST.paren = scan->flags;	/* Which paren to set */
            ST.lastparen      = rex->lastparen;
	    ST.lastcloseparen = rex->lastcloseparen;
	    if (ST.paren > maxopenparen)
		maxopenparen = ST.paren;
	    ST.min = ARG1(scan);  /* min to match */
	    ST.max = ARG2(scan);  /* max to match */
            if (EVAL_CLOSE_PAREN_IS_TRUE(cur_eval,(U32)ST.paren))
            {
	        ST.min=1;
	        ST.max=1;
	    }
            scan = regnext(NEXTOPER(scan) + NODE_STEP_REGNODE);
	    goto repeat;

	case CURLY:		/*  /A{m,n}B/ where A is width 1 char */
	    ST.paren = 0;
	    ST.min = ARG1(scan);  /* min to match */
	    ST.max = ARG2(scan);  /* max to match */
	    scan = NEXTOPER(scan) + NODE_STEP_REGNODE;
	  repeat:
	    /*
	    * Lookahead to avoid useless match attempts
	    * when we know what character comes next.
	    *
	    * Used to only do .*x and .*?x, but now it allows
	    * for )'s, ('s and (?{ ... })'s to be in the way
	    * of the quantifier and the EXACT-like node.  -- japhy
	    */

	    assert(ST.min <= ST.max);
            if (! HAS_TEXT(next) && ! JUMPABLE(next)) {
                ST.c1 = ST.c2 = CHRTEST_VOID;
            }
            else {
		regnode *text_node = next;

		if (! HAS_TEXT(text_node)) 
		    FIND_NEXT_IMPT(text_node);

		if (! HAS_TEXT(text_node))
		    ST.c1 = ST.c2 = CHRTEST_VOID;
		else {
		    if ( PL_regkind[OP(text_node)] != EXACT ) {
			ST.c1 = ST.c2 = CHRTEST_VOID;
		    }
		    else {
                    
                    /*  Currently we only get here when 
                        
                        PL_rekind[OP(text_node)] == EXACT
                    
                        if this changes back then the macro for IS_TEXT and 
                        friends need to change. */
                        if (! S_setup_EXACTISH_ST_c1_c2(aTHX_
                           text_node, &ST.c1, ST.c1_utf8, &ST.c2, ST.c2_utf8,
                           reginfo))
                        {
                            sayNO;
                        }
                    }
		}
	    }

	    ST.A = scan;
	    ST.B = next;
	    if (minmod) {
                char *li = locinput;
		minmod = 0;
		if (ST.min &&
                        regrepeat(rex, &li, ST.A, reginfo, ST.min, depth)
                            < ST.min)
		    sayNO;
                SET_locinput(li);
		ST.count = ST.min;
		REGCP_SET(ST.cp);
		if (ST.c1 == CHRTEST_VOID)
		    goto curly_try_B_min;

		ST.oldloc = locinput;

		/* set ST.maxpos to the furthest point along the
		 * string that could possibly match */
		if  (ST.max == REG_INFTY) {
		    ST.maxpos = reginfo->strend - 1;
		    if (utf8_target)
			while (UTF8_IS_CONTINUATION(*(U8*)ST.maxpos))
			    ST.maxpos--;
		}
		else if (utf8_target) {
		    int m = ST.max - ST.min;
		    for (ST.maxpos = locinput;
			 m >0 && ST.maxpos < reginfo->strend; m--)
			ST.maxpos += UTF8SKIP(ST.maxpos);
		}
		else {
		    ST.maxpos = locinput + ST.max - ST.min;
		    if (ST.maxpos >= reginfo->strend)
			ST.maxpos = reginfo->strend - 1;
		}
		goto curly_try_B_min_known;

	    }
	    else {
                /* avoid taking address of locinput, so it can remain
                 * a register var */
                char *li = locinput;
		ST.count = regrepeat(rex, &li, ST.A, reginfo, ST.max, depth);
		if (ST.count < ST.min)
		    sayNO;
                SET_locinput(li);
		if ((ST.count > ST.min)
		    && (PL_regkind[OP(ST.B)] == EOL) && (OP(ST.B) != MEOL))
		{
		    /* A{m,n} must come at the end of the string, there's
		     * no point in backing off ... */
		    ST.min = ST.count;
		    /* ...except that $ and \Z can match before *and* after
		       newline at the end.  Consider "\n\n" =~ /\n+\Z\n/.
		       We may back off by one in this case. */
		    if (UCHARAT(locinput - 1) == '\n' && OP(ST.B) != EOS)
			ST.min--;
		}
		REGCP_SET(ST.cp);
		goto curly_try_B_max;
	    }
	    NOT_REACHED; /* NOTREACHED */

	case CURLY_B_min_known_fail:
	    /* failed to find B in a non-greedy match where c1,c2 valid */

	    REGCP_UNWIND(ST.cp);
            if (ST.paren) {
                UNWIND_PAREN(ST.lastparen, ST.lastcloseparen);
            }
	    /* Couldn't or didn't -- move forward. */
	    ST.oldloc = locinput;
	    if (utf8_target)
		locinput += UTF8SKIP(locinput);
	    else
		locinput++;
	    ST.count++;
	  curly_try_B_min_known:
	     /* find the next place where 'B' could work, then call B */
	    {
		int n;
		if (utf8_target) {
		    n = (ST.oldloc == locinput) ? 0 : 1;
		    if (ST.c1 == ST.c2) {
			/* set n to utf8_distance(oldloc, locinput) */
			while (locinput <= ST.maxpos
                              && memNE(locinput, ST.c1_utf8, UTF8SKIP(locinput)))
                        {
			    locinput += UTF8SKIP(locinput);
			    n++;
			}
		    }
		    else {
			/* set n to utf8_distance(oldloc, locinput) */
			while (locinput <= ST.maxpos
                              && memNE(locinput, ST.c1_utf8, UTF8SKIP(locinput))
                              && memNE(locinput, ST.c2_utf8, UTF8SKIP(locinput)))
                        {
			    locinput += UTF8SKIP(locinput);
			    n++;
			}
		    }
		}
		else {  /* Not utf8_target */
		    if (ST.c1 == ST.c2) {
			while (locinput <= ST.maxpos &&
			       UCHARAT(locinput) != ST.c1)
			    locinput++;
		    }
		    else {
			while (locinput <= ST.maxpos
			       && UCHARAT(locinput) != ST.c1
			       && UCHARAT(locinput) != ST.c2)
			    locinput++;
		    }
		    n = locinput - ST.oldloc;
		}
		if (locinput > ST.maxpos)
		    sayNO;
		if (n) {
                    /* In /a{m,n}b/, ST.oldloc is at "a" x m, locinput is
                     * at b; check that everything between oldloc and
                     * locinput matches */
                    char *li = ST.oldloc;
		    ST.count += n;
		    if (regrepeat(rex, &li, ST.A, reginfo, n, depth) < n)
			sayNO;
                    assert(n == REG_INFTY || locinput == li);
		}
		CURLY_SETPAREN(ST.paren, ST.count);
                if (EVAL_CLOSE_PAREN_IS_TRUE(cur_eval,(U32)ST.paren))
		    goto fake_end;
		PUSH_STATE_GOTO(CURLY_B_min_known, ST.B, locinput);
	    }
	    NOT_REACHED; /* NOTREACHED */

	case CURLY_B_min_fail:
	    /* failed to find B in a non-greedy match where c1,c2 invalid */

	    REGCP_UNWIND(ST.cp);
            if (ST.paren) {
                UNWIND_PAREN(ST.lastparen, ST.lastcloseparen);
            }
	    /* failed -- move forward one */
            {
                char *li = locinput;
                if (!regrepeat(rex, &li, ST.A, reginfo, 1, depth)) {
                    sayNO;
                }
                locinput = li;
            }
            {
		ST.count++;
		if (ST.count <= ST.max || (ST.max == REG_INFTY &&
			ST.count > 0)) /* count overflow ? */
		{
		  curly_try_B_min:
		    CURLY_SETPAREN(ST.paren, ST.count);
                    if (EVAL_CLOSE_PAREN_IS_TRUE(cur_eval,(U32)ST.paren))
                        goto fake_end;
		    PUSH_STATE_GOTO(CURLY_B_min, ST.B, locinput);
		}
	    }
            sayNO;
	    NOT_REACHED; /* NOTREACHED */

          curly_try_B_max:
	    /* a successful greedy match: now try to match B */
            if (EVAL_CLOSE_PAREN_IS_TRUE(cur_eval,(U32)ST.paren))
                goto fake_end;
	    {
		bool could_match = locinput < reginfo->strend;

		/* If it could work, try it. */
                if (ST.c1 != CHRTEST_VOID && could_match) {
                    if (! UTF8_IS_INVARIANT(UCHARAT(locinput)) && utf8_target)
                    {
                        could_match = memEQ(locinput,
                                            ST.c1_utf8,
                                            UTF8SKIP(locinput))
                                    || memEQ(locinput,
                                             ST.c2_utf8,
                                             UTF8SKIP(locinput));
                    }
                    else {
                        could_match = UCHARAT(locinput) == ST.c1
                                      || UCHARAT(locinput) == ST.c2;
                    }
                }
                if (ST.c1 == CHRTEST_VOID || could_match) {
		    CURLY_SETPAREN(ST.paren, ST.count);
		    PUSH_STATE_GOTO(CURLY_B_max, ST.B, locinput);
		    NOT_REACHED; /* NOTREACHED */
		}
	    }
	    /* FALLTHROUGH */

	case CURLY_B_max_fail:
	    /* failed to find B in a greedy match */

	    REGCP_UNWIND(ST.cp);
            if (ST.paren) {
                UNWIND_PAREN(ST.lastparen, ST.lastcloseparen);
            }
	    /*  back up. */
	    if (--ST.count < ST.min)
		sayNO;
	    locinput = HOPc(locinput, -1);
	    goto curly_try_B_max;

#undef ST

	case END: /*  last op of main pattern  */
          fake_end:
	    if (cur_eval) {
		/* we've just finished A in /(??{A})B/; now continue with B */
                SET_RECURSE_LOCINPUT("FAKE-END[before]", CUR_EVAL.prev_recurse_locinput);
		st->u.eval.prev_rex = rex_sv;		/* inner */

                /* Save *all* the positions. */
		st->u.eval.cp = regcppush(rex, 0, maxopenparen);
                rex_sv = CUR_EVAL.prev_rex;
		is_utf8_pat = reginfo->is_utf8_pat = cBOOL(RX_UTF8(rex_sv));
		SET_reg_curpm(rex_sv);
		rex = ReANY(rex_sv);
		rexi = RXi_GET(rex);

                st->u.eval.prev_curlyx = cur_curlyx;
                cur_curlyx = CUR_EVAL.prev_curlyx;

		REGCP_SET(st->u.eval.lastcp);

		/* Restore parens of the outer rex without popping the
		 * savestack */
                S_regcp_restore(aTHX_ rex, CUR_EVAL.lastcp,
                                        &maxopenparen);

		st->u.eval.prev_eval = cur_eval;
                cur_eval = CUR_EVAL.prev_eval;
		DEBUG_EXECUTE_r(
                    Perl_re_exec_indentf( aTHX_  "EVAL trying tail ... (cur_eval=%p)\n",
                                      depth, cur_eval););
                if ( nochange_depth )
	            nochange_depth--;

                SET_RECURSE_LOCINPUT("FAKE-END[after]", cur_eval->locinput);

                PUSH_YES_STATE_GOTO(EVAL_AB, st->u.eval.prev_eval->u.eval.B,
                                    locinput); /* match B */
	    }

	    if (locinput < reginfo->till) {
                DEBUG_EXECUTE_r(Perl_re_printf( aTHX_
                                      "%sMatch possible, but length=%ld is smaller than requested=%ld, failing!%s\n",
				      PL_colors[4],
				      (long)(locinput - startpos),
				      (long)(reginfo->till - startpos),
				      PL_colors[5]));
               				      
		sayNO_SILENT;		/* Cannot match: too short. */
	    }
	    sayYES;			/* Success! */

	case SUCCEED: /* successful SUSPEND/UNLESSM/IFMATCH/CURLYM */
	    DEBUG_EXECUTE_r(
            Perl_re_exec_indentf( aTHX_  "%ssubpattern success...%s\n",
                depth, PL_colors[4], PL_colors[5]));
	    sayYES;			/* Success! */

#undef  ST
#define ST st->u.ifmatch

        {
            char *newstart;

	case SUSPEND:	/* (?>A) */
	    ST.wanted = 1;
	    newstart = locinput;
	    goto do_ifmatch;	

	case UNLESSM:	/* -ve lookaround: (?!A), or with flags, (?<!A) */
	    ST.wanted = 0;
	    goto ifmatch_trivial_fail_test;

	case IFMATCH:	/* +ve lookaround: (?=A), or with flags, (?<=A) */
	    ST.wanted = 1;
	  ifmatch_trivial_fail_test:
	    if (scan->flags) {
		char * const s = HOPBACKc(locinput, scan->flags);
		if (!s) {
		    /* trivial fail */
		    if (logical) {
			logical = 0;
			sw = 1 - cBOOL(ST.wanted);
		    }
		    else if (ST.wanted)
			sayNO;
		    next = scan + ARG(scan);
		    if (next == scan)
			next = NULL;
		    break;
		}
		newstart = s;
	    }
	    else
		newstart = locinput;

	  do_ifmatch:
	    ST.me = scan;
	    ST.logical = logical;
	    logical = 0; /* XXX: reset state of logical once it has been saved into ST */
	    
	    /* execute body of (?...A) */
	    PUSH_YES_STATE_GOTO(IFMATCH_A, NEXTOPER(NEXTOPER(scan)), newstart);
	    NOT_REACHED; /* NOTREACHED */
        }

	case IFMATCH_A_fail: /* body of (?...A) failed */
	    ST.wanted = !ST.wanted;
	    /* FALLTHROUGH */

	case IFMATCH_A: /* body of (?...A) succeeded */
	    if (ST.logical) {
		sw = cBOOL(ST.wanted);
	    }
	    else if (!ST.wanted)
		sayNO;

	    if (OP(ST.me) != SUSPEND) {
                /* restore old position except for (?>...) */
		locinput = st->locinput;
	    }
	    scan = ST.me + ARG(ST.me);
	    if (scan == ST.me)
		scan = NULL;
	    continue; /* execute B */

#undef ST

	case LONGJMP: /*  alternative with many branches compiles to
                       * (BRANCHJ; EXACT ...; LONGJMP ) x N */
	    next = scan + ARG(scan);
	    if (next == scan)
		next = NULL;
	    break;

	case COMMIT:  /*  (*COMMIT)  */
	    reginfo->cutpoint = reginfo->strend;
	    /* FALLTHROUGH */

	case PRUNE:   /*  (*PRUNE)   */
            if (scan->flags)
	        sv_yes_mark = sv_commit = MUTABLE_SV(rexi->data->data[ ARG( scan ) ]);
	    PUSH_STATE_GOTO(COMMIT_next, next, locinput);
	    NOT_REACHED; /* NOTREACHED */

	case COMMIT_next_fail:
	    no_final = 1;    
	    /* FALLTHROUGH */	    
            sayNO;
            NOT_REACHED; /* NOTREACHED */

	case OPFAIL:   /* (*FAIL)  */
            if (scan->flags)
                sv_commit = MUTABLE_SV(rexi->data->data[ ARG( scan ) ]);
            if (logical) {
                /* deal with (?(?!)X|Y) properly,
                 * make sure we trigger the no branch
                 * of the trailing IFTHEN structure*/
                sw= 0;
                break;
            } else {
                sayNO;
            }
	    NOT_REACHED; /* NOTREACHED */

#define ST st->u.mark
        case MARKPOINT: /*  (*MARK:foo)  */
            ST.prev_mark = mark_state;
            ST.mark_name = sv_commit = sv_yes_mark 
                = MUTABLE_SV(rexi->data->data[ ARG( scan ) ]);
            mark_state = st;
            ST.mark_loc = locinput;
            PUSH_YES_STATE_GOTO(MARKPOINT_next, next, locinput);
            NOT_REACHED; /* NOTREACHED */

        case MARKPOINT_next:
            mark_state = ST.prev_mark;
            sayYES;
            NOT_REACHED; /* NOTREACHED */

        case MARKPOINT_next_fail:
            if (popmark && sv_eq(ST.mark_name,popmark)) 
            {
                if (ST.mark_loc > startpoint)
	            reginfo->cutpoint = HOPBACKc(ST.mark_loc, 1);
                popmark = NULL; /* we found our mark */
                sv_commit = ST.mark_name;

                DEBUG_EXECUTE_r({
                        Perl_re_exec_indentf( aTHX_  "%ssetting cutpoint to mark:%"SVf"...%s\n",
                            depth,
		            PL_colors[4], SVfARG(sv_commit), PL_colors[5]);
		});
            }
            mark_state = ST.prev_mark;
            sv_yes_mark = mark_state ? 
                mark_state->u.mark.mark_name : NULL;
            sayNO;
            NOT_REACHED; /* NOTREACHED */

        case SKIP:  /*  (*SKIP)  */
            if (!scan->flags) {
                /* (*SKIP) : if we fail we cut here*/
                ST.mark_name = NULL;
                ST.mark_loc = locinput;
                PUSH_STATE_GOTO(SKIP_next,next, locinput);
            } else {
                /* (*SKIP:NAME) : if there is a (*MARK:NAME) fail where it was, 
                   otherwise do nothing.  Meaning we need to scan 
                 */
                regmatch_state *cur = mark_state;
                SV *find = MUTABLE_SV(rexi->data->data[ ARG( scan ) ]);
                
                while (cur) {
                    if ( sv_eq( cur->u.mark.mark_name, 
                                find ) ) 
                    {
                        ST.mark_name = find;
                        PUSH_STATE_GOTO( SKIP_next, next, locinput);
                    }
                    cur = cur->u.mark.prev_mark;
                }
            }    
            /* Didn't find our (*MARK:NAME) so ignore this (*SKIP:NAME) */
            break;    

	case SKIP_next_fail:
	    if (ST.mark_name) {
	        /* (*CUT:NAME) - Set up to search for the name as we 
	           collapse the stack*/
	        popmark = ST.mark_name;	   
	    } else {
	        /* (*CUT) - No name, we cut here.*/
	        if (ST.mark_loc > startpoint)
	            reginfo->cutpoint = HOPBACKc(ST.mark_loc, 1);
	        /* but we set sv_commit to latest mark_name if there
	           is one so they can test to see how things lead to this
	           cut */    
                if (mark_state) 
                    sv_commit=mark_state->u.mark.mark_name;	            
            } 
            no_final = 1; 
            sayNO;
            NOT_REACHED; /* NOTREACHED */
#undef ST

        case LNBREAK: /* \R */
            if ((n=is_LNBREAK_safe(locinput, reginfo->strend, utf8_target))) {
                locinput += n;
            } else
                sayNO;
            break;

	default:
	    PerlIO_printf(Perl_error_log, "%"UVxf" %d\n",
			  PTR2UV(scan), OP(scan));
	    Perl_croak(aTHX_ "regexp memory corruption");

        /* this is a point to jump to in order to increment
         * locinput by one character */
          increment_locinput:
            assert(!NEXTCHR_IS_EOS);
            if (utf8_target) {
                locinput += PL_utf8skip[nextchr];
                /* locinput is allowed to go 1 char off the end, but not 2+ */
                if (locinput > reginfo->strend)
                    sayNO;
            }
            else
                locinput++;
            break;
	    
	} /* end switch */ 

        /* switch break jumps here */
	scan = next; /* prepare to execute the next op and ... */
	continue;    /* ... jump back to the top, reusing st */
        /* NOTREACHED */

      push_yes_state:
	/* push a state that backtracks on success */
	st->u.yes.prev_yes_state = yes_state;
	yes_state = st;
	/* FALLTHROUGH */
      push_state:
	/* push a new regex state, then continue at scan  */
	{
	    regmatch_state *newst;

	    DEBUG_STACK_r({
	        regmatch_state *cur = st;
	        regmatch_state *curyes = yes_state;
	        int curd = depth;
	        regmatch_slab *slab = PL_regmatch_slab;
                for (;curd > -1 && (depth-curd < 3);cur--,curd--) {
                    if (cur < SLAB_FIRST(slab)) {
                	slab = slab->prev;
                	cur = SLAB_LAST(slab);
                    }
                    Perl_re_exec_indentf( aTHX_ "#%-3d %-10s %s\n",
                        depth,
                        curd, PL_reg_name[cur->resume_state],
                        (curyes == cur) ? "yes" : ""
                    );
                    if (curyes == cur)
	                curyes = cur->u.yes.prev_yes_state;
                }
            } else 
                DEBUG_STATE_pp("push")
            );
	    depth++;
	    st->locinput = locinput;
	    newst = st+1; 
	    if (newst >  SLAB_LAST(PL_regmatch_slab))
		newst = S_push_slab(aTHX);
	    PL_regmatch_state = newst;

	    locinput = pushinput;
	    st = newst;
	    continue;
            /* NOTREACHED */
	}
    }
#ifdef SOLARIS_BAD_OPTIMIZER
#  undef PL_charclass
#endif

    /*
    * We get here only if there's trouble -- normally "case END" is
    * the terminating point.
    */
    Perl_croak(aTHX_ "corrupted regexp pointers");
    NOT_REACHED; /* NOTREACHED */

  yes:
    if (yes_state) {
	/* we have successfully completed a subexpression, but we must now
	 * pop to the state marked by yes_state and continue from there */
	assert(st != yes_state);
#ifdef DEBUGGING
	while (st != yes_state) {
	    st--;
	    if (st < SLAB_FIRST(PL_regmatch_slab)) {
		PL_regmatch_slab = PL_regmatch_slab->prev;
		st = SLAB_LAST(PL_regmatch_slab);
	    }
	    DEBUG_STATE_r({
	        if (no_final) {
	            DEBUG_STATE_pp("pop (no final)");        
	        } else {
	            DEBUG_STATE_pp("pop (yes)");
	        }
	    });
	    depth--;
	}
#else
	while (yes_state < SLAB_FIRST(PL_regmatch_slab)
	    || yes_state > SLAB_LAST(PL_regmatch_slab))
	{
	    /* not in this slab, pop slab */
	    depth -= (st - SLAB_FIRST(PL_regmatch_slab) + 1);
	    PL_regmatch_slab = PL_regmatch_slab->prev;
	    st = SLAB_LAST(PL_regmatch_slab);
	}
	depth -= (st - yes_state);
#endif
	st = yes_state;
	yes_state = st->u.yes.prev_yes_state;
	PL_regmatch_state = st;
        
        if (no_final)
            locinput= st->locinput;
	state_num = st->resume_state + no_final;
	goto reenter_switch;
    }

    DEBUG_EXECUTE_r(Perl_re_printf( aTHX_  "%sMatch successful!%s\n",
			  PL_colors[4], PL_colors[5]));

    if (reginfo->info_aux_eval) {
	/* each successfully executed (?{...}) block does the equivalent of
	 *   local $^R = do {...}
	 * When popping the save stack, all these locals would be undone;
	 * bypass this by setting the outermost saved $^R to the latest
	 * value */
        /* I dont know if this is needed or works properly now.
         * see code related to PL_replgv elsewhere in this file.
         * Yves
         */
	if (oreplsv != GvSV(PL_replgv))
	    sv_setsv(oreplsv, GvSV(PL_replgv));
    }
    result = 1;
    goto final_exit;

  no:
    DEBUG_EXECUTE_r(
        Perl_re_exec_indentf( aTHX_  "%sfailed...%s\n",
            depth,
            PL_colors[4], PL_colors[5])
	);

  no_silent:
    if (no_final) {
        if (yes_state) {
            goto yes;
        } else {
            goto final_exit;
        }
    }    
    if (depth) {
	/* there's a previous state to backtrack to */
	st--;
	if (st < SLAB_FIRST(PL_regmatch_slab)) {
	    PL_regmatch_slab = PL_regmatch_slab->prev;
	    st = SLAB_LAST(PL_regmatch_slab);
	}
	PL_regmatch_state = st;
	locinput= st->locinput;

	DEBUG_STATE_pp("pop");
	depth--;
	if (yes_state == st)
	    yes_state = st->u.yes.prev_yes_state;

	state_num = st->resume_state + 1; /* failure = success + 1 */
	goto reenter_switch;
    }
    result = 0;

  final_exit:
    if (rex->intflags & PREGf_VERBARG_SEEN) {
        SV *sv_err = get_sv("REGERROR", 1);
        SV *sv_mrk = get_sv("REGMARK", 1);
        if (result) {
            sv_commit = &PL_sv_no;
            if (!sv_yes_mark) 
                sv_yes_mark = &PL_sv_yes;
        } else {
            if (!sv_commit) 
                sv_commit = &PL_sv_yes;
            sv_yes_mark = &PL_sv_no;
        }
        assert(sv_err);
        assert(sv_mrk);
        sv_setsv(sv_err, sv_commit);
        sv_setsv(sv_mrk, sv_yes_mark);
    }


    if (last_pushed_cv) {
	dSP;
	POP_MULTICALL;
        PERL_UNUSED_VAR(SP);
    }

    assert(!result ||  locinput - reginfo->strbeg >= 0);
    return result ?  locinput - reginfo->strbeg : -1;
}

/*
 - regrepeat - repeatedly match something simple, report how many
 *
 * What 'simple' means is a node which can be the operand of a quantifier like
 * '+', or {1,3}
 *
 * startposp - pointer a pointer to the start position.  This is updated
 *             to point to the byte following the highest successful
 *             match.
 * p         - the regnode to be repeatedly matched against.
 * reginfo   - struct holding match state, such as strend
 * max       - maximum number of things to match.
 * depth     - (for debugging) backtracking depth.
 */
STATIC I32
S_regrepeat(pTHX_ regexp *prog, char **startposp, const regnode *p,
            regmatch_info *const reginfo, I32 max, int depth)
{
    char *scan;     /* Pointer to current position in target string */
    I32 c;
    char *loceol = reginfo->strend;   /* local version */
    I32 hardcount = 0;  /* How many matches so far */
    bool utf8_target = reginfo->is_utf8_target;
    unsigned int to_complement = 0;  /* Invert the result? */
    UV utf8_flags;
    _char_class_number classnum;
#ifndef DEBUGGING
    PERL_UNUSED_ARG(depth);
#endif

    PERL_ARGS_ASSERT_REGREPEAT;

    scan = *startposp;
    if (max == REG_INFTY)
	max = I32_MAX;
    else if (! utf8_target && loceol - scan > max)
	loceol = scan + max;

    /* Here, for the case of a non-UTF-8 target we have adjusted <loceol> down
     * to the maximum of how far we should go in it (leaving it set to the real
     * end, if the maximum permissible would take us beyond that).  This allows
     * us to make the loop exit condition that we haven't gone past <loceol> to
     * also mean that we haven't exceeded the max permissible count, saving a
     * test each time through the loop.  But it assumes that the OP matches a
     * single byte, which is true for most of the OPs below when applied to a
     * non-UTF-8 target.  Those relatively few OPs that don't have this
     * characteristic will have to compensate.
     *
     * There is no adjustment for UTF-8 targets, as the number of bytes per
     * character varies.  OPs will have to test both that the count is less
     * than the max permissible (using <hardcount> to keep track), and that we
     * are still within the bounds of the string (using <loceol>.  A few OPs
     * match a single byte no matter what the encoding.  They can omit the max
     * test if, for the UTF-8 case, they do the adjustment that was skipped
     * above.
     *
     * Thus, the code above sets things up for the common case; and exceptional
     * cases need extra work; the common case is to make sure <scan> doesn't
     * go past <loceol>, and for UTF-8 to also use <hardcount> to make sure the
     * count doesn't exceed the maximum permissible */

    switch (OP(p)) {
    case REG_ANY:
	if (utf8_target) {
	    while (scan < loceol && hardcount < max && *scan != '\n') {
		scan += UTF8SKIP(scan);
		hardcount++;
	    }
	} else {
	    while (scan < loceol && *scan != '\n')
		scan++;
	}
	break;
    case SANY:
        if (utf8_target) {
	    while (scan < loceol && hardcount < max) {
	        scan += UTF8SKIP(scan);
		hardcount++;
	    }
	}
	else
	    scan = loceol;
	break;
    case EXACTL:
        _CHECK_AND_WARN_PROBLEMATIC_LOCALE;
        if (utf8_target && UTF8_IS_ABOVE_LATIN1(*scan)) {
            _CHECK_AND_OUTPUT_WIDE_LOCALE_UTF8_MSG(scan, loceol);
        }
        /* FALLTHROUGH */
    case EXACT:
        assert(STR_LEN(p) == reginfo->is_utf8_pat ? UTF8SKIP(STRING(p)) : 1);

	c = (U8)*STRING(p);

        /* Can use a simple loop if the pattern char to match on is invariant
         * under UTF-8, or both target and pattern aren't UTF-8.  Note that we
         * can use UTF8_IS_INVARIANT() even if the pattern isn't UTF-8, as it's
         * true iff it doesn't matter if the argument is in UTF-8 or not */
        if (UTF8_IS_INVARIANT(c) || (! utf8_target && ! reginfo->is_utf8_pat)) {
            if (utf8_target && loceol - scan > max) {
                /* We didn't adjust <loceol> because is UTF-8, but ok to do so,
                 * since here, to match at all, 1 char == 1 byte */
                loceol = scan + max;
            }
	    while (scan < loceol && UCHARAT(scan) == c) {
		scan++;
	    }
	}
	else if (reginfo->is_utf8_pat) {
            if (utf8_target) {
                STRLEN scan_char_len;

                /* When both target and pattern are UTF-8, we have to do
                 * string EQ */
                while (hardcount < max
                       && scan < loceol
                       && (scan_char_len = UTF8SKIP(scan)) <= STR_LEN(p)
                       && memEQ(scan, STRING(p), scan_char_len))
                {
                    scan += scan_char_len;
                    hardcount++;
                }
            }
            else if (! UTF8_IS_ABOVE_LATIN1(c)) {

                /* Target isn't utf8; convert the character in the UTF-8
                 * pattern to non-UTF8, and do a simple loop */
                c = EIGHT_BIT_UTF8_TO_NATIVE(c, *(STRING(p) + 1));
                while (scan < loceol && UCHARAT(scan) == c) {
                    scan++;
                }
            } /* else pattern char is above Latin1, can't possibly match the
                 non-UTF-8 target */
        }
        else {

            /* Here, the string must be utf8; pattern isn't, and <c> is
             * different in utf8 than not, so can't compare them directly.
             * Outside the loop, find the two utf8 bytes that represent c, and
             * then look for those in sequence in the utf8 string */
	    U8 high = UTF8_TWO_BYTE_HI(c);
	    U8 low = UTF8_TWO_BYTE_LO(c);

	    while (hardcount < max
		    && scan + 1 < loceol
		    && UCHARAT(scan) == high
		    && UCHARAT(scan + 1) == low)
	    {
		scan += 2;
		hardcount++;
	    }
	}
	break;

    case EXACTFA_NO_TRIE:   /* This node only generated for non-utf8 patterns */
        assert(! reginfo->is_utf8_pat);
        /* FALLTHROUGH */
    case EXACTFA:
        utf8_flags = FOLDEQ_UTF8_NOMIX_ASCII;
	goto do_exactf;

    case EXACTFL:
        _CHECK_AND_WARN_PROBLEMATIC_LOCALE;
	utf8_flags = FOLDEQ_LOCALE;
	goto do_exactf;

    case EXACTF:   /* This node only generated for non-utf8 patterns */
        assert(! reginfo->is_utf8_pat);
        utf8_flags = 0;
        goto do_exactf;

    case EXACTFLU8:
        if (! utf8_target) {
            break;
        }
        utf8_flags =  FOLDEQ_LOCALE | FOLDEQ_S2_ALREADY_FOLDED
                                    | FOLDEQ_S2_FOLDS_SANE;
        goto do_exactf;

    case EXACTFU_SS:
    case EXACTFU:
	utf8_flags = reginfo->is_utf8_pat ? FOLDEQ_S2_ALREADY_FOLDED : 0;

      do_exactf: {
        int c1, c2;
        U8 c1_utf8[UTF8_MAXBYTES+1], c2_utf8[UTF8_MAXBYTES+1];

        assert(STR_LEN(p) == reginfo->is_utf8_pat ? UTF8SKIP(STRING(p)) : 1);

        if (S_setup_EXACTISH_ST_c1_c2(aTHX_ p, &c1, c1_utf8, &c2, c2_utf8,
                                        reginfo))
        {
            if (c1 == CHRTEST_VOID) {
                /* Use full Unicode fold matching */
                char *tmpeol = reginfo->strend;
                STRLEN pat_len = reginfo->is_utf8_pat ? UTF8SKIP(STRING(p)) : 1;
                while (hardcount < max
                        && foldEQ_utf8_flags(scan, &tmpeol, 0, utf8_target,
                                             STRING(p), NULL, pat_len,
                                             reginfo->is_utf8_pat, utf8_flags))
                {
                    scan = tmpeol;
                    tmpeol = reginfo->strend;
                    hardcount++;
                }
            }
            else if (utf8_target) {
                if (c1 == c2) {
                    while (scan < loceol
                           && hardcount < max
                           && memEQ(scan, c1_utf8, UTF8SKIP(scan)))
                    {
                        scan += UTF8SKIP(scan);
                        hardcount++;
                    }
                }
                else {
                    while (scan < loceol
                           && hardcount < max
                           && (memEQ(scan, c1_utf8, UTF8SKIP(scan))
                               || memEQ(scan, c2_utf8, UTF8SKIP(scan))))
                    {
                        scan += UTF8SKIP(scan);
                        hardcount++;
                    }
                }
            }
            else if (c1 == c2) {
                while (scan < loceol && UCHARAT(scan) == c1) {
                    scan++;
                }
            }
            else {
                while (scan < loceol &&
                    (UCHARAT(scan) == c1 || UCHARAT(scan) == c2))
                {
                    scan++;
                }
            }
	}
	break;
    }
    case ANYOFL:
        _CHECK_AND_WARN_PROBLEMATIC_LOCALE;

        if (ANYOFL_UTF8_LOCALE_REQD(FLAGS(p)) && ! IN_UTF8_CTYPE_LOCALE) {
            Perl_ck_warner(aTHX_ packWARN(WARN_LOCALE), utf8_locale_required);
        }
        /* FALLTHROUGH */
    case ANYOFD:
    case ANYOF:
	if (utf8_target) {
	    while (hardcount < max
                   && scan < loceol
		   && reginclass(prog, p, (U8*)scan, (U8*) loceol, utf8_target))
	    {
		scan += UTF8SKIP(scan);
		hardcount++;
	    }
	} else {
	    while (scan < loceol && REGINCLASS(prog, p, (U8*)scan, 0))
		scan++;
	}
	break;

    /* The argument (FLAGS) to all the POSIX node types is the class number */

    case NPOSIXL:
        to_complement = 1;
        /* FALLTHROUGH */

    case POSIXL:
        _CHECK_AND_WARN_PROBLEMATIC_LOCALE;
	if (! utf8_target) {
	    while (scan < loceol && to_complement ^ cBOOL(isFOO_lc(FLAGS(p),
                                                                   *scan)))
            {
		scan++;
            }
	} else {
	    while (hardcount < max && scan < loceol
                   && to_complement ^ cBOOL(isFOO_utf8_lc(FLAGS(p),
                                                                  (U8 *) scan)))
            {
                scan += UTF8SKIP(scan);
		hardcount++;
	    }
	}
	break;

    case POSIXD:
        if (utf8_target) {
            goto utf8_posix;
        }
        /* FALLTHROUGH */

    case POSIXA:
        if (utf8_target && loceol - scan > max) {

            /* We didn't adjust <loceol> at the beginning of this routine
             * because is UTF-8, but it is actually ok to do so, since here, to
             * match, 1 char == 1 byte. */
            loceol = scan + max;
        }
        while (scan < loceol && _generic_isCC_A((U8) *scan, FLAGS(p))) {
	    scan++;
	}
	break;

    case NPOSIXD:
        if (utf8_target) {
            to_complement = 1;
            goto utf8_posix;
        }
        /* FALLTHROUGH */

    case NPOSIXA:
        if (! utf8_target) {
            while (scan < loceol && ! _generic_isCC_A((U8) *scan, FLAGS(p))) {
                scan++;
            }
        }
        else {

            /* The complement of something that matches only ASCII matches all
             * non-ASCII, plus everything in ASCII that isn't in the class. */
	    while (hardcount < max && scan < loceol
                   && (! isASCII_utf8(scan)
                       || ! _generic_isCC_A((U8) *scan, FLAGS(p))))
            {
                scan += UTF8SKIP(scan);
		hardcount++;
	    }
        }
        break;

    case NPOSIXU:
        to_complement = 1;
        /* FALLTHROUGH */

    case POSIXU:
	if (! utf8_target) {
            while (scan < loceol && to_complement
                                ^ cBOOL(_generic_isCC((U8) *scan, FLAGS(p))))
            {
                scan++;
            }
	}
	else {
          utf8_posix:
            classnum = (_char_class_number) FLAGS(p);
            if (classnum < _FIRST_NON_SWASH_CC) {

                /* Here, a swash is needed for above-Latin1 code points.
                 * Process as many Latin1 code points using the built-in rules.
                 * Go to another loop to finish processing upon encountering
                 * the first Latin1 code point.  We could do that in this loop
                 * as well, but the other way saves having to test if the swash
                 * has been loaded every time through the loop: extra space to
                 * save a test. */
                while (hardcount < max && scan < loceol) {
                    if (UTF8_IS_INVARIANT(*scan)) {
                        if (! (to_complement ^ cBOOL(_generic_isCC((U8) *scan,
                                                                   classnum))))
                        {
                            break;
                        }
                        scan++;
                    }
                    else if (UTF8_IS_DOWNGRADEABLE_START(*scan)) {
                        if (! (to_complement
                              ^ cBOOL(_generic_isCC(EIGHT_BIT_UTF8_TO_NATIVE(*scan,
                                                                     *(scan + 1)),
                                                    classnum))))
                        {
                            break;
                        }
                        scan += 2;
                    }
                    else {
                        goto found_above_latin1;
                    }

                    hardcount++;
                }
            }
            else {
                /* For these character classes, the knowledge of how to handle
                 * every code point is compiled in to Perl via a macro.  This
                 * code is written for making the loops as tight as possible.
                 * It could be refactored to save space instead */
                switch (classnum) {
                    case _CC_ENUM_SPACE:
                        while (hardcount < max
                               && scan < loceol
                               && (to_complement ^ cBOOL(isSPACE_utf8(scan))))
                        {
                            scan += UTF8SKIP(scan);
                            hardcount++;
                        }
                        break;
                    case _CC_ENUM_BLANK:
                        while (hardcount < max
                               && scan < loceol
                               && (to_complement ^ cBOOL(isBLANK_utf8(scan))))
                        {
                            scan += UTF8SKIP(scan);
                            hardcount++;
                        }
                        break;
                    case _CC_ENUM_XDIGIT:
                        while (hardcount < max
                               && scan < loceol
                               && (to_complement ^ cBOOL(isXDIGIT_utf8(scan))))
                        {
                            scan += UTF8SKIP(scan);
                            hardcount++;
                        }
                        break;
                    case _CC_ENUM_VERTSPACE:
                        while (hardcount < max
                               && scan < loceol
                               && (to_complement ^ cBOOL(isVERTWS_utf8(scan))))
                        {
                            scan += UTF8SKIP(scan);
                            hardcount++;
                        }
                        break;
                    case _CC_ENUM_CNTRL:
                        while (hardcount < max
                               && scan < loceol
                               && (to_complement ^ cBOOL(isCNTRL_utf8(scan))))
                        {
                            scan += UTF8SKIP(scan);
                            hardcount++;
                        }
                        break;
                    default:
                        Perl_croak(aTHX_ "panic: regrepeat() node %d='%s' has an unexpected character class '%d'", OP(p), PL_reg_name[OP(p)], classnum);
                }
            }
	}
        break;

      found_above_latin1:   /* Continuation of POSIXU and NPOSIXU */

        /* Load the swash if not already present */
        if (! PL_utf8_swash_ptrs[classnum]) {
            U8 flags = _CORE_SWASH_INIT_ACCEPT_INVLIST;
            PL_utf8_swash_ptrs[classnum] = _core_swash_init(
                                        "utf8",
                                        "",
                                        &PL_sv_undef, 1, 0,
                                        PL_XPosix_ptrs[classnum], &flags);
        }

        while (hardcount < max && scan < loceol
               && to_complement ^ cBOOL(_generic_utf8(
                                       classnum,
                                       scan,
                                       swash_fetch(PL_utf8_swash_ptrs[classnum],
                                                   (U8 *) scan,
                                                   TRUE))))
        {
            scan += UTF8SKIP(scan);
            hardcount++;
        }
        break;

    case LNBREAK:
        if (utf8_target) {
	    while (hardcount < max && scan < loceol &&
                    (c=is_LNBREAK_utf8_safe(scan, loceol))) {
		scan += c;
		hardcount++;
	    }
	} else {
            /* LNBREAK can match one or two latin chars, which is ok, but we
             * have to use hardcount in this situation, and throw away the
             * adjustment to <loceol> done before the switch statement */
            loceol = reginfo->strend;
	    while (scan < loceol && (c=is_LNBREAK_latin1_safe(scan, loceol))) {
		scan+=c;
		hardcount++;
	    }
	}
	break;

    case BOUNDL:
    case NBOUNDL:
        _CHECK_AND_WARN_PROBLEMATIC_LOCALE;
        /* FALLTHROUGH */
    case BOUND:
    case BOUNDA:
    case BOUNDU:
    case EOS:
    case GPOS:
    case KEEPS:
    case NBOUND:
    case NBOUNDA:
    case NBOUNDU:
    case OPFAIL:
    case SBOL:
    case SEOL:
        /* These are all 0 width, so match right here or not at all. */
        break;

    default:
        Perl_croak(aTHX_ "panic: regrepeat() called with unrecognized node type %d='%s'", OP(p), PL_reg_name[OP(p)]);
        NOT_REACHED; /* NOTREACHED */

    }

    if (hardcount)
	c = hardcount;
    else
	c = scan - *startposp;
    *startposp = scan;

    DEBUG_r({
	GET_RE_DEBUG_FLAGS_DECL;
	DEBUG_EXECUTE_r({
	    SV * const prop = sv_newmortal();
            regprop(prog, prop, p, reginfo, NULL);
            Perl_re_exec_indentf( aTHX_  "%s can match %"IVdf" times out of %"IVdf"...\n",
                        depth, SvPVX_const(prop),(IV)c,(IV)max);
	});
    });

    return(c);
}


#if !defined(PERL_IN_XSUB_RE) || defined(PLUGGABLE_RE_EXTENSION)
/*
- regclass_swash - prepare the utf8 swash.  Wraps the shared core version to
create a copy so that changes the caller makes won't change the shared one.
If <altsvp> is non-null, will return NULL in it, for back-compat.
 */
SV *
Perl_regclass_swash(pTHX_ const regexp *prog, const regnode* node, bool doinit, SV** listsvp, SV **altsvp)
{
    PERL_ARGS_ASSERT_REGCLASS_SWASH;

    if (altsvp) {
        *altsvp = NULL;
    }

    return newSVsv(_get_regclass_nonbitmap_data(prog, node, doinit, listsvp, NULL, NULL));
}

#endif /* !defined(PERL_IN_XSUB_RE) || defined(PLUGGABLE_RE_EXTENSION) */

/*
 - reginclass - determine if a character falls into a character class
 
  n is the ANYOF-type regnode
  p is the target string
  p_end points to one byte beyond the end of the target string
  utf8_target tells whether p is in UTF-8.

  Returns true if matched; false otherwise.

  Note that this can be a synthetic start class, a combination of various
  nodes, so things you think might be mutually exclusive, such as locale,
  aren't.  It can match both locale and non-locale

 */

STATIC bool
S_reginclass(pTHX_ regexp * const prog, const regnode * const n, const U8* const p, const U8* const p_end, const bool utf8_target)
{
    dVAR;
    const char flags = ANYOF_FLAGS(n);
    bool match = FALSE;
    UV c = *p;

    PERL_ARGS_ASSERT_REGINCLASS;

    /* If c is not already the code point, get it.  Note that
     * UTF8_IS_INVARIANT() works even if not in UTF-8 */
    if (! UTF8_IS_INVARIANT(c) && utf8_target) {
        STRLEN c_len = 0;
	c = utf8n_to_uvchr(p, p_end - p, &c_len,
		(UTF8_ALLOW_DEFAULT & UTF8_ALLOW_ANYUV)
		| UTF8_ALLOW_FFFF | UTF8_CHECK_ONLY);
		/* see [perl #37836] for UTF8_ALLOW_ANYUV; [perl #38293] for
		 * UTF8_ALLOW_FFFF */
	if (c_len == (STRLEN)-1)
	    Perl_croak(aTHX_ "Malformed UTF-8 character (fatal)");
        if (c > 255 && OP(n) == ANYOFL && ! ANYOFL_UTF8_LOCALE_REQD(flags)) {
            _CHECK_AND_OUTPUT_WIDE_LOCALE_CP_MSG(c);
        }
    }

    /* If this character is potentially in the bitmap, check it */
    if (c < NUM_ANYOF_CODE_POINTS) {
	if (ANYOF_BITMAP_TEST(n, c))
	    match = TRUE;
	else if ((flags
                & ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER)
                  && OP(n) == ANYOFD
		  && ! utf8_target
		  && ! isASCII(c))
	{
	    match = TRUE;
	}
	else if (flags & ANYOF_LOCALE_FLAGS) {
	    if ((flags & ANYOFL_FOLD)
                && c < 256
		&& ANYOF_BITMAP_TEST(n, PL_fold_locale[c]))
            {
                match = TRUE;
            }
            else if (ANYOF_POSIXL_TEST_ANY_SET(n)
                     && c < 256
            ) {

                /* The data structure is arranged so bits 0, 2, 4, ... are set
                 * if the class includes the Posix character class given by
                 * bit/2; and 1, 3, 5, ... are set if the class includes the
                 * complemented Posix class given by int(bit/2).  So we loop
                 * through the bits, each time changing whether we complement
                 * the result or not.  Suppose for the sake of illustration
                 * that bits 0-3 mean respectively, \w, \W, \s, \S.  If bit 0
                 * is set, it means there is a match for this ANYOF node if the
                 * character is in the class given by the expression (0 / 2 = 0
                 * = \w).  If it is in that class, isFOO_lc() will return 1,
                 * and since 'to_complement' is 0, the result will stay TRUE,
                 * and we exit the loop.  Suppose instead that bit 0 is 0, but
                 * bit 1 is 1.  That means there is a match if the character
                 * matches \W.  We won't bother to call isFOO_lc() on bit 0,
                 * but will on bit 1.  On the second iteration 'to_complement'
                 * will be 1, so the exclusive or will reverse things, so we
                 * are testing for \W.  On the third iteration, 'to_complement'
                 * will be 0, and we would be testing for \s; the fourth
                 * iteration would test for \S, etc.
                 *
                 * Note that this code assumes that all the classes are closed
                 * under folding.  For example, if a character matches \w, then
                 * its fold does too; and vice versa.  This should be true for
                 * any well-behaved locale for all the currently defined Posix
                 * classes, except for :lower: and :upper:, which are handled
                 * by the pseudo-class :cased: which matches if either of the
                 * other two does.  To get rid of this assumption, an outer
                 * loop could be used below to iterate over both the source
                 * character, and its fold (if different) */

                int count = 0;
                int to_complement = 0;

                while (count < ANYOF_MAX) {
                    if (ANYOF_POSIXL_TEST(n, count)
                        && to_complement ^ cBOOL(isFOO_lc(count/2, (U8) c)))
                    {
                        match = TRUE;
                        break;
                    }
                    count++;
                    to_complement ^= 1;
                }
	    }
	}
    }


    /* If the bitmap didn't (or couldn't) match, and something outside the
     * bitmap could match, try that. */
    if (!match) {
	if (c >= NUM_ANYOF_CODE_POINTS
            && (flags & ANYOF_MATCHES_ALL_ABOVE_BITMAP))
        {
	    match = TRUE;	/* Everything above the bitmap matches */
	}
            /* Here doesn't match everything above the bitmap.  If there is
             * some information available beyond the bitmap, we may find a
             * match in it.  If so, this is most likely because the code point
             * is outside the bitmap range.  But rarely, it could be because of
             * some other reason.  If so, various flags are set to indicate
             * this possibility.  On ANYOFD nodes, there may be matches that
             * happen only when the target string is UTF-8; or for other node
             * types, because runtime lookup is needed, regardless of the
             * UTF-8ness of the target string.  Finally, under /il, there may
             * be some matches only possible if the locale is a UTF-8 one. */
	else if (    ARG(n) != ANYOF_ONLY_HAS_BITMAP
                 && (   c >= NUM_ANYOF_CODE_POINTS
                     || (   (flags & ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP)
                         && (   UNLIKELY(OP(n) != ANYOFD)
                             || (utf8_target && ! isASCII_uni(c)
#                               if NUM_ANYOF_CODE_POINTS > 256
                                                                 && c < 256
#                               endif
                                )))
                     || (   ANYOFL_SOME_FOLDS_ONLY_IN_UTF8_LOCALE(flags)
                         && IN_UTF8_CTYPE_LOCALE)))
        {
            SV* only_utf8_locale = NULL;
	    SV * const sw = _get_regclass_nonbitmap_data(prog, n, TRUE, 0,
                                                       &only_utf8_locale, NULL);
	    if (sw) {
                U8 utf8_buffer[2];
		U8 * utf8_p;
		if (utf8_target) {
		    utf8_p = (U8 *) p;
		} else { /* Convert to utf8 */
		    utf8_p = utf8_buffer;
                    append_utf8_from_native_byte(*p, &utf8_p);
		    utf8_p = utf8_buffer;
		}

		if (swash_fetch(sw, utf8_p, TRUE)) {
		    match = TRUE;
                }
	    }
            if (! match && only_utf8_locale && IN_UTF8_CTYPE_LOCALE) {
                match = _invlist_contains_cp(only_utf8_locale, c);
            }
	}

        if (UNICODE_IS_SUPER(c)
            && (flags
               & ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER)
            && OP(n) != ANYOFD
            && ckWARN_d(WARN_NON_UNICODE))
        {
            Perl_warner(aTHX_ packWARN(WARN_NON_UNICODE),
                "Matched non-Unicode code point 0x%04"UVXf" against Unicode property; may not be portable", c);
        }
    }

#if ANYOF_INVERT != 1
    /* Depending on compiler optimization cBOOL takes time, so if don't have to
     * use it, don't */
#   error ANYOF_INVERT needs to be set to 1, or guarded with cBOOL below,
#endif

    /* The xor complements the return if to invert: 1^1 = 0, 1^0 = 1 */
    return (flags & ANYOF_INVERT) ^ match;
}

STATIC U8 *
S_reghop3(U8 *s, SSize_t off, const U8* lim)
{
    /* return the position 'off' UTF-8 characters away from 's', forward if
     * 'off' >= 0, backwards if negative.  But don't go outside of position
     * 'lim', which better be < s  if off < 0 */

    PERL_ARGS_ASSERT_REGHOP3;

    if (off >= 0) {
	while (off-- && s < lim) {
	    /* XXX could check well-formedness here */
	    s += UTF8SKIP(s);
	}
    }
    else {
        while (off++ && s > lim) {
            s--;
            if (UTF8_IS_CONTINUED(*s)) {
                while (s > lim && UTF8_IS_CONTINUATION(*s))
                    s--;
                if (! UTF8_IS_START(*s)) {
                    Perl_croak_nocontext("Malformed UTF-8 character (fatal)");
                }
	    }
            /* XXX could check well-formedness here */
	}
    }
    return s;
}

STATIC U8 *
S_reghop4(U8 *s, SSize_t off, const U8* llim, const U8* rlim)
{
    PERL_ARGS_ASSERT_REGHOP4;

    if (off >= 0) {
        while (off-- && s < rlim) {
            /* XXX could check well-formedness here */
            s += UTF8SKIP(s);
        }
    }
    else {
        while (off++ && s > llim) {
            s--;
            if (UTF8_IS_CONTINUED(*s)) {
                while (s > llim && UTF8_IS_CONTINUATION(*s))
                    s--;
                if (! UTF8_IS_START(*s)) {
                    Perl_croak_nocontext("Malformed UTF-8 character (fatal)");
                }
            }
            /* XXX could check well-formedness here */
        }
    }
    return s;
}

/* like reghop3, but returns NULL on overrun, rather than returning last
 * char pos */

STATIC U8 *
S_reghopmaybe3(U8* s, SSize_t off, const U8* lim)
{
    PERL_ARGS_ASSERT_REGHOPMAYBE3;

    if (off >= 0) {
	while (off-- && s < lim) {
	    /* XXX could check well-formedness here */
	    s += UTF8SKIP(s);
	}
	if (off >= 0)
	    return NULL;
    }
    else {
        while (off++ && s > lim) {
            s--;
            if (UTF8_IS_CONTINUED(*s)) {
                while (s > lim && UTF8_IS_CONTINUATION(*s))
                    s--;
                if (! UTF8_IS_START(*s)) {
                    Perl_croak_nocontext("Malformed UTF-8 character (fatal)");
                }
	    }
            /* XXX could check well-formedness here */
	}
	if (off <= 0)
	    return NULL;
    }
    return s;
}


/* when executing a regex that may have (?{}), extra stuff needs setting
   up that will be visible to the called code, even before the current
   match has finished. In particular:

   * $_ is localised to the SV currently being matched;
   * pos($_) is created if necessary, ready to be updated on each call-out
     to code;
   * a fake PMOP is created that can be set to PL_curpm (normally PL_curpm
     isn't set until the current pattern is successfully finished), so that
     $1 etc of the match-so-far can be seen;
   * save the old values of subbeg etc of the current regex, and  set then
     to the current string (again, this is normally only done at the end
     of execution)
*/

static void
S_setup_eval_state(pTHX_ regmatch_info *const reginfo)
{
    MAGIC *mg;
    regexp *const rex = ReANY(reginfo->prog);
    regmatch_info_aux_eval *eval_state = reginfo->info_aux_eval;

    eval_state->rex = rex;

    if (reginfo->sv) {
        /* Make $_ available to executed code. */
        if (reginfo->sv != DEFSV) {
            SAVE_DEFSV;
            DEFSV_set(reginfo->sv);
        }

        if (!(mg = mg_find_mglob(reginfo->sv))) {
            /* prepare for quick setting of pos */
            mg = sv_magicext_mglob(reginfo->sv);
            mg->mg_len = -1;
        }
        eval_state->pos_magic = mg;
        eval_state->pos       = mg->mg_len;
        eval_state->pos_flags = mg->mg_flags;
    }
    else
        eval_state->pos_magic = NULL;

    if (!PL_reg_curpm) {
        /* PL_reg_curpm is a fake PMOP that we can attach the current
         * regex to and point PL_curpm at, so that $1 et al are visible
         * within a /(?{})/. It's just allocated once per interpreter the
         * first time its needed */
        Newxz(PL_reg_curpm, 1, PMOP);
#ifdef USE_ITHREADS
        {
            SV* const repointer = &PL_sv_undef;
            /* this regexp is also owned by the new PL_reg_curpm, which
               will try to free it.  */
            av_push(PL_regex_padav, repointer);
            PL_reg_curpm->op_pmoffset = av_tindex(PL_regex_padav);
            PL_regex_pad = AvARRAY(PL_regex_padav);
        }
#endif
    }
    SET_reg_curpm(reginfo->prog);
    eval_state->curpm = PL_curpm;
    PL_curpm = PL_reg_curpm;
    if (RXp_MATCH_COPIED(rex)) {
        /*  Here is a serious problem: we cannot rewrite subbeg,
            since it may be needed if this match fails.  Thus
            $` inside (?{}) could fail... */
        eval_state->subbeg     = rex->subbeg;
        eval_state->sublen     = rex->sublen;
        eval_state->suboffset  = rex->suboffset;
        eval_state->subcoffset = rex->subcoffset;
#ifdef PERL_ANY_COW
        eval_state->saved_copy = rex->saved_copy;
#endif
        RXp_MATCH_COPIED_off(rex);
    }
    else
        eval_state->subbeg = NULL;
    rex->subbeg = (char *)reginfo->strbeg;
    rex->suboffset = 0;
    rex->subcoffset = 0;
    rex->sublen = reginfo->strend - reginfo->strbeg;
}


/* destructor to clear up regmatch_info_aux and regmatch_info_aux_eval */

static void
S_cleanup_regmatch_info_aux(pTHX_ void *arg)
{
    regmatch_info_aux *aux = (regmatch_info_aux *) arg;
    regmatch_info_aux_eval *eval_state =  aux->info_aux_eval;
    regmatch_slab *s;

    Safefree(aux->poscache);

    if (eval_state) {

        /* undo the effects of S_setup_eval_state() */

        if (eval_state->subbeg) {
            regexp * const rex = eval_state->rex;
            rex->subbeg     = eval_state->subbeg;
            rex->sublen     = eval_state->sublen;
            rex->suboffset  = eval_state->suboffset;
            rex->subcoffset = eval_state->subcoffset;
#ifdef PERL_ANY_COW
            rex->saved_copy = eval_state->saved_copy;
#endif
            RXp_MATCH_COPIED_on(rex);
        }
        if (eval_state->pos_magic)
        {
            eval_state->pos_magic->mg_len = eval_state->pos;
            eval_state->pos_magic->mg_flags =
                 (eval_state->pos_magic->mg_flags & ~MGf_BYTES)
               | (eval_state->pos_flags & MGf_BYTES);
        }

        PL_curpm = eval_state->curpm;
    }

    PL_regmatch_state = aux->old_regmatch_state;
    PL_regmatch_slab  = aux->old_regmatch_slab;

    /* free all slabs above current one - this must be the last action
     * of this function, as aux and eval_state are allocated within
     * slabs and may be freed here */

    s = PL_regmatch_slab->next;
    if (s) {
        PL_regmatch_slab->next = NULL;
        while (s) {
            regmatch_slab * const osl = s;
            s = s->next;
            Safefree(osl);
        }
    }
}


STATIC void
S_to_utf8_substr(pTHX_ regexp *prog)
{
    /* Converts substr fields in prog from bytes to UTF-8, calling fbm_compile
     * on the converted value */

    int i = 1;

    PERL_ARGS_ASSERT_TO_UTF8_SUBSTR;

    do {
	if (prog->substrs->data[i].substr
	    && !prog->substrs->data[i].utf8_substr) {
	    SV* const sv = newSVsv(prog->substrs->data[i].substr);
	    prog->substrs->data[i].utf8_substr = sv;
	    sv_utf8_upgrade(sv);
	    if (SvVALID(prog->substrs->data[i].substr)) {
		if (SvTAIL(prog->substrs->data[i].substr)) {
		    /* Trim the trailing \n that fbm_compile added last
		       time.  */
		    SvCUR_set(sv, SvCUR(sv) - 1);
		    /* Whilst this makes the SV technically "invalid" (as its
		       buffer is no longer followed by "\0") when fbm_compile()
		       adds the "\n" back, a "\0" is restored.  */
		    fbm_compile(sv, FBMcf_TAIL);
		} else
		    fbm_compile(sv, 0);
	    }
	    if (prog->substrs->data[i].substr == prog->check_substr)
		prog->check_utf8 = sv;
	}
    } while (i--);
}

STATIC bool
S_to_byte_substr(pTHX_ regexp *prog)
{
    /* Converts substr fields in prog from UTF-8 to bytes, calling fbm_compile
     * on the converted value; returns FALSE if can't be converted. */

    int i = 1;

    PERL_ARGS_ASSERT_TO_BYTE_SUBSTR;

    do {
	if (prog->substrs->data[i].utf8_substr
	    && !prog->substrs->data[i].substr) {
	    SV* sv = newSVsv(prog->substrs->data[i].utf8_substr);
	    if (! sv_utf8_downgrade(sv, TRUE)) {
                return FALSE;
            }
            if (SvVALID(prog->substrs->data[i].utf8_substr)) {
                if (SvTAIL(prog->substrs->data[i].utf8_substr)) {
                    /* Trim the trailing \n that fbm_compile added last
                        time.  */
                    SvCUR_set(sv, SvCUR(sv) - 1);
                    fbm_compile(sv, FBMcf_TAIL);
                } else
                    fbm_compile(sv, 0);
            }
	    prog->substrs->data[i].substr = sv;
	    if (prog->substrs->data[i].utf8_substr == prog->check_utf8)
		prog->check_substr = sv;
	}
    } while (i--);

    return TRUE;
}

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
@


1.20
log
@Update to perl 5.20.3

OK bluhm@@
@
text
@d5 2
a6 2
 * 	One Ring to rule them all, One Ring to find them
 &
d83 1
a83 1
#include "inline_invlist.c"
d86 6
d99 3
a101 3
#define NON_UTF8_TARGET_BUT_UTF8_REQUIRED(target) STMT_START { \
    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "%s", non_utf8_target_but_utf8_required));\
    goto target; \
d110 6
a115 5
/* Valid only for non-utf8 strings: avoids the reginclass
 * call if there are no complications: i.e., if everything matchable is
 * straight forward in the bitmap */
#define REGINCLASS(prog,p,c)  (ANYOF_FLAGS(p) ? reginclass(prog,p,c,c+1,0)   \
					      : ANYOF_BITMAP_TEST(p,*(c)))
d132 1
a132 1
	    ? reghopmaybe3((U8*)pos, -off, (U8*)(reginfo->strbeg)) \
d199 1
a199 13
                                        LATIN_CAPITAL_LETTER_SHARP_S_UTF8);

#define LOAD_UTF8_CHARCLASS_GCB()  /* Grapheme cluster boundaries */          \
    STMT_START {                                                              \
	LOAD_UTF8_CHARCLASS_DEBUG_TEST(PL_utf8_X_regular_begin,               \
                                       "_X_regular_begin",                    \
                                       NULL,                                  \
                                       LATIN_CAPITAL_LETTER_SHARP_S_UTF8);    \
	LOAD_UTF8_CHARCLASS_DEBUG_TEST(PL_utf8_X_extend,                      \
                                       "_X_extend",                           \
                                       NULL,                                  \
                                       COMBINING_GRAVE_ACCENT_UTF8);          \
    } STMT_END
d216 2
a217 1
    (OP(rn) == CLOSE && (!cur_eval || cur_eval->u.eval.close_paren != ARG(rn))) || \
d230 1
a230 1
   we don't need this definition. */
d237 2
a238 2
#define IS_TEXT(rn)   ( OP(rn)==EXACT   )
#define IS_TEXTFU(rn)  ( OP(rn)==EXACTFU || OP(rn)==EXACTFU_SS || OP(rn) == EXACTFA || OP(rn) == EXACTFA_NO_TRIE)
a260 10
/* These constants are for finding GCB=LV and GCB=LVT in the CLUMP regnode.
 * These are for the pre-composed Hangul syllables, which are all in a
 * contiguous block and arranged there in such a way so as to facilitate
 * alorithmic determination of their characteristics.  As such, they don't need
 * a swash, but can be determined by simple arithmetic.  Almost all are
 * GCB=LVT, but every 28th one is a GCB=LV */
#define SBASE 0xAC00    /* Start of block */
#define SCount 11172    /* Length of block */
#define TCount 28

a276 1
    dVAR;
d288 3
a290 2
        Perl_croak(aTHX_ "panic: paren_elems_to_push, %i < 0, maxopenparen: %i parenfloor: %i REGCP_PAREN_ELEMS: %i",
                   paren_elems_to_push, maxopenparen, parenfloor, REGCP_PAREN_ELEMS);
d303 1
a303 1
	    PerlIO_printf(Perl_debug_log,
d314 1
a314 1
	DEBUG_BUFFERS_r(PerlIO_printf(Perl_debug_log,
d334 5
a338 3
            PerlIO_printf(Perl_debug_log,		        \
	        "  Setting an EVAL scope, savestack=%"IVdf"\n",	\
	        (IV)PL_savestack_ix));                          \
d343 6
a348 4
        if (cp != PL_savestack_ix) 		                \
    	    PerlIO_printf(Perl_debug_log,		        \
		"  Clearing an EVAL scope, savestack=%"IVdf"..%"IVdf"\n", \
	        (IV)(cp), (IV)PL_savestack_ix));                \
a360 1
    dVAR;
d379 1
a379 1
	    PerlIO_printf(Perl_debug_log,
d393 1
a393 1
	DEBUG_BUFFERS_r( PerlIO_printf(Perl_debug_log,
d417 1
a417 1
	DEBUG_BUFFERS_r( PerlIO_printf(Perl_debug_log,
a467 1
        case _CC_ENUM_PSXSPC:    return isPSXSPC_LC(character);
d477 1
a477 1
    assert(0); /* NOTREACHED */
d490 1
a490 1
     * the range 0-255.  Outside that range, all characters avoid Unicode
d501 1
a501 1
                        TWO_BYTE_UTF8_TO_NATIVE(*character, *(character + 1)));
d504 2
d524 1
a524 3
        case _CC_ENUM_SPACE:
        case _CC_ENUM_PSXSPC:    return is_XPERLSPACE_high(character);

d528 1
a528 2
        default:                 return 0;  /* Things like CNTRL are always
                                               below 256 */
d531 1
a531 2
    assert(0); /* NOTREACHED */
    return FALSE;
a636 1
    dVAR;
d659 1
a659 1
    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
d663 1
a663 1
     * in the future someone wants to do clever things with look-behind and
d690 1
a690 1
	DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
d727 1
a727 1
            PerlIO_printf(Perl_debug_log,
d765 1
a765 1
                && (prog->intflags & (PREGf_ANCH_BOL|PREGf_ANCH_SBOL)))
d767 1
a767 1
	        DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
d782 1
a782 3
	    if (prog->check_offset_min == prog->check_offset_max
                && !(prog->intflags & PREGf_CANY_SEEN))
            {
d787 1
a787 1
                DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
d801 1
a801 1
                        DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
d811 1
a811 1
                    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
d862 1
a862 1
            PerlIO_printf(Perl_debug_log,
d866 1
a866 1
                (IV)(rx_origin - strpos),
d873 4
a876 11
        if (prog->intflags & PREGf_CANY_SEEN) {
            start_point= (U8*)(rx_origin + start_shift);
            end_point= (U8*)(strend - end_shift);
            if (start_point > end_point)
                goto fail_finish;
        } else {
            end_point = HOP3(strend, -end_shift, strbeg);
	    start_point = HOPMAYBE3(rx_origin, start_shift, end_point);
            if (!start_point)
                goto fail_finish;
	}
d880 1
a880 1
         * string (BOL,SBOL) or to pos() (ANCH_GPOS), then
a906 7
	DEBUG_OPTIMISE_MORE_r({
            PerlIO_printf(Perl_debug_log, "  fbm_instr len=%d str=<%.*s>\n",
                (int)(end_point - start_point),
                (int)(end_point - start_point) > 20 ? 20 : (int)(end_point - start_point), 
                start_point);
        });

d910 7
d923 1
a923 1
            PerlIO_printf(Perl_debug_log, "  %s %s substr %s%s%s",
a933 3
        /* Finish the diagnostic message */
        DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "%ld...\n", (long)(check_at - strpos)) );

d941 6
d1050 28
a1077 6
        s = fbm_instr(
            (unsigned char*)s,
            (unsigned char*)last + SvCUR(must) - (SvTAIL(must)!=0),
            must,
            multiline ? FBMrf_MULTILINE : 0
        );
d1081 1
a1081 1
            PerlIO_printf(Perl_debug_log, "  %s %s substr %s%s",
d1092 2
a1093 2
                DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
                                        ", giving up...\n"));
a1099 5
            DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
                ", trying %s at offset %ld...\n",
                (other_ix ? "floating" : "anchored"),
                (long)(HOP3c(check_at, 1, strend) - strpos)));

d1105 6
a1113 3
            DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, " at offset %ld...\n",
                  (long)(s - strpos)));

d1129 6
d1139 1
a1139 1
            PerlIO_printf(Perl_debug_log,
d1142 1
a1142 1
                " strend-strpos:%"IVdf"\n",
d1145 2
a1146 2
                (IV)(check_at-strpos),
                (IV)(rx_origin-strpos),
d1148 1
a1148 1
                (IV)(strend-strpos)
d1160 1
a1160 1
        DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
d1169 1
a1169 1
         * we're effectively flipping been check_substr and "\n" on each
d1180 1
a1180 1
            DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
d1197 3
a1199 3
            DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
                "  Found /%s^%s/m, restarting lookup for check-string at offset %ld...\n",
                PL_colors[0], PL_colors[1], (long)(rx_origin - strpos)));
d1213 2
a1214 2
            DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
                "  Found /%s^%s/m at offset %ld, rescanning for anchored from offset %ld...\n",
d1216 3
a1218 2
                (long)(rx_origin - strpos),
                (long)(rx_origin - strpos + prog->anchored_offset)));
d1224 3
a1226 3
        DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
            "  Found /%s^%s/m at offset %ld...\n",
            PL_colors[0], PL_colors[1], (long)(rx_origin - strpos)));
d1229 1
a1229 1
        DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
d1287 1
a1287 1
        DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
d1297 1
a1297 1
		DEBUG_EXECUTE_r( PerlIO_printf(Perl_debug_log,
d1301 1
a1301 1
	    DEBUG_EXECUTE_r( PerlIO_printf(Perl_debug_log,
d1318 9
a1326 5
                         * do_other_substr', where a more accurate
                         * char-based calculation will be done */
                        DEBUG_EXECUTE_r( PerlIO_printf(Perl_debug_log,
                                  "  Looking for anchored substr starting at offset %ld...\n",
                                  (long)(other_last - strpos)) );
d1343 2
a1344 2
                    DEBUG_EXECUTE_r( PerlIO_printf(Perl_debug_log,
                              "  Looking for /%s^%s/m starting at offset %ld...\n",
d1346 1
a1346 1
                              (long)(rx_origin - strpos)) );
d1367 1
a1367 1
                DEBUG_EXECUTE_r( PerlIO_printf(Perl_debug_log,
d1371 2
a1372 2
            DEBUG_EXECUTE_r( PerlIO_printf(Perl_debug_log,
                "  Looking for %s substr starting at offset %ld...\n",
d1374 3
a1376 1
                (long)(rx_origin + start_shift - strpos)) );
d1383 1
a1383 1
            DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
d1385 1
a1385 1
                                  (long)(rx_origin - strpos), (long)(s - strpos))
d1389 1
a1389 1
            DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
d1401 1
a1401 1
        DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "  try at offset...\n"));
d1421 1
a1421 1
	    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "  ... Disabling check substring...\n"));
d1435 1
a1435 1
    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
d1437 1
a1437 1
             PL_colors[4], PL_colors[5], (long)(rx_origin - strpos)) );
d1445 1
a1445 1
    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "%sMatch rejected by optimizer%s\n",
d1452 16
a1467 7
    const enum { trie_plain, trie_utf8, trie_utf8_fold, trie_latin_utf8_fold, \
                 trie_utf8_exactfa_fold, trie_latin_utf8_exactfa_fold } \
                    trie_type = ((scan->flags == EXACT) \
                              ? (utf8_target ? trie_utf8 : trie_plain) \
                              : (scan->flags == EXACTFA) \
                                ? (utf8_target ? trie_utf8_exactfa_fold : trie_latin_utf8_exactfa_fold) \
                                : (utf8_target ? trie_utf8_fold : trie_latin_utf8_fold))
d1474 6
d1482 1
a1482 1
        /* FALL THROUGH */                                                          \
d1484 1
d1493 1
a1493 1
            skiplen = UNISKIP( uvc );                                               \
d1500 1
a1500 1
        /* FALL THROUGH */                                                          \
d1510 1
a1510 1
            skiplen = UNISKIP( uvc );                                               \
d1515 6
d1542 5
a1546 1
#define REXEC_FBC_EXACTISH_SCAN(CoNd)                     \
d1549 1
a1549 1
	if ( (CoNd)                                       \
d1557 1
a1557 1
#define REXEC_FBC_UTF8_SCAN(CoDe)                     \
d1560 1
a1560 1
	CoDe                                          \
d1565 1
a1565 1
#define REXEC_FBC_SCAN(CoDe)                          \
d1568 1
a1568 1
	CoDe                                          \
d1573 10
a1582 10
#define REXEC_FBC_UTF8_CLASS_SCAN(CoNd)               \
REXEC_FBC_UTF8_SCAN(                                  \
    if (CoNd) {                                       \
	if (tmp && (reginfo->intuit || regtry(reginfo, &s))) \
	    goto got_it;                              \
	else                                          \
	    tmp = doevery;                            \
    }                                                 \
    else                                              \
	tmp = 1;                                      \
d1585 10
a1594 10
#define REXEC_FBC_CLASS_SCAN(CoNd)                    \
REXEC_FBC_SCAN(                                       \
    if (CoNd) {                                       \
	if (tmp && (reginfo->intuit || regtry(reginfo, &s)))  \
	    goto got_it;                              \
	else                                          \
	    tmp = doevery;                            \
    }                                                 \
    else                                              \
	tmp = 1;                                      \
d1597 1
a1597 5
#define REXEC_FBC_TRYIT                       \
if ((reginfo->intuit || regtry(reginfo, &s))) \
    goto got_it

#define REXEC_FBC_CSCAN(CoNdUtF8,CoNd)                         \
d1599 1
a1599 1
	REXEC_FBC_UTF8_CLASS_SCAN(CoNdUtF8);                   \
d1602 1
a1602 1
	REXEC_FBC_CLASS_SCAN(CoNd);                            \
a1603 4
    
#define DUMP_EXEC_POS(li,s,doutf8)                          \
    dump_exec_pos(li,s,(reginfo->strend),(reginfo->strbeg), \
                startpos, doutf8)
d1605 59
a1663 21

#define UTF8_NOLOAD(TEST_NON_UTF8, IF_SUCCESS, IF_FAIL)                        \
	tmp = (s != reginfo->strbeg) ? UCHARAT(s - 1) : '\n';                  \
	tmp = TEST_NON_UTF8(tmp);                                              \
	REXEC_FBC_UTF8_SCAN(                                                   \
	    if (tmp == ! TEST_NON_UTF8((U8) *s)) {                             \
		tmp = !tmp;                                                    \
		IF_SUCCESS;                                                    \
	    }                                                                  \
	    else {                                                             \
		IF_FAIL;                                                       \
	    }                                                                  \
	);                                                                     \

#define UTF8_LOAD(TeSt1_UtF8, TeSt2_UtF8, IF_SUCCESS, IF_FAIL)                 \
	if (s == reginfo->strbeg) {                                            \
	    tmp = '\n';                                                        \
	}                                                                      \
	else {                                                                 \
	    U8 * const r = reghop3((U8*)s, -1, (U8*)reginfo->strbeg);          \
	    tmp = utf8n_to_uvchr(r, (U8*) reginfo->strend - r,                 \
d1665 12
a1676 12
	}                                                                      \
	tmp = TeSt1_UtF8;                                                      \
	LOAD_UTF8_CHARCLASS_ALNUM();                                           \
	REXEC_FBC_UTF8_SCAN(                                                   \
	    if (tmp == ! (TeSt2_UtF8)) {                                       \
		tmp = !tmp;                                                    \
		IF_SUCCESS;                                                    \
	    }                                                                  \
	    else {                                                             \
		IF_FAIL;                                                       \
	    }                                                                  \
	);                                                                     \
d1678 3
a1680 26
/* The only difference between the BOUND and NBOUND cases is that
 * REXEC_FBC_TRYIT is called when matched in BOUND, and when non-matched in
 * NBOUND.  This is accomplished by passing it in either the if or else clause,
 * with the other one being empty */
#define FBC_BOUND(TEST_NON_UTF8, TEST1_UTF8, TEST2_UTF8) \
    FBC_BOUND_COMMON(UTF8_LOAD(TEST1_UTF8, TEST2_UTF8, REXEC_FBC_TRYIT, PLACEHOLDER), TEST_NON_UTF8, REXEC_FBC_TRYIT, PLACEHOLDER)

#define FBC_BOUND_NOLOAD(TEST_NON_UTF8, TEST1_UTF8, TEST2_UTF8) \
    FBC_BOUND_COMMON(UTF8_NOLOAD(TEST_NON_UTF8, REXEC_FBC_TRYIT, PLACEHOLDER), TEST_NON_UTF8, REXEC_FBC_TRYIT, PLACEHOLDER)

#define FBC_NBOUND(TEST_NON_UTF8, TEST1_UTF8, TEST2_UTF8) \
    FBC_BOUND_COMMON(UTF8_LOAD(TEST1_UTF8, TEST2_UTF8, PLACEHOLDER, REXEC_FBC_TRYIT), TEST_NON_UTF8, PLACEHOLDER, REXEC_FBC_TRYIT)

#define FBC_NBOUND_NOLOAD(TEST_NON_UTF8, TEST1_UTF8, TEST2_UTF8) \
    FBC_BOUND_COMMON(UTF8_NOLOAD(TEST_NON_UTF8, PLACEHOLDER, REXEC_FBC_TRYIT), TEST_NON_UTF8, PLACEHOLDER, REXEC_FBC_TRYIT)


/* Common to the BOUND and NBOUND cases.  Unfortunately the UTF8 tests need to
 * be passed in completely with the variable name being tested, which isn't
 * such a clean interface, but this is easier to read than it was before.  We
 * are looking for the boundary (or non-boundary between a word and non-word
 * character.  The utf8 and non-utf8 cases have the same logic, but the details
 * must be different.  Find the "wordness" of the character just prior to this
 * one, and compare it with the wordness of this one.  If they differ, we have
 * a boundary.  At the beginning of the string, pretend that the previous
 * character was a new-line */
d1683 1
a1683 1
		UTF8_CODE                                                      \
d1688 1
a1688 1
	REXEC_FBC_SCAN(                                                        \
d1690 1
a1691 1
		IF_SUCCESS;                                                    \
d1698 125
a1822 2
    if ((!prog->minlen && tmp) && (reginfo->intuit || regtry(reginfo, &s)))    \
	goto got_it;
a1827 1

d1858 9
d1873 1
a1873 1
            REXEC_FBC_CLASS_SCAN(REGINCLASS(prog, c, (U8*)s));
a1875 8
    case CANY:
        REXEC_FBC_SCAN(
            if (tmp && (reginfo->intuit || regtry(reginfo, &s)))
                goto got_it;
            else
                tmp = doevery;
        );
        break;
d1879 1
a1879 1
	/* FALL THROUGH */
d1900 1
d1915 9
d1936 1
a1936 1
        /* FALL THROUGH */
d1938 1
a1938 1
    do_exactf_non_utf8: /* Neither pattern nor string are UTF8, and there
d1972 2
a1973 2
    do_exactf_utf8:
    {
d2027 1
d2029 10
a2038 3
        FBC_BOUND(isWORDCHAR_LC,
                  isWORDCHAR_LC_uvchr(tmp),
                  isWORDCHAR_LC_utf8((U8*)s));
d2040 1
d2042 10
a2051 3
        FBC_NBOUND(isWORDCHAR_LC,
                   isWORDCHAR_LC_uvchr(tmp),
                   isWORDCHAR_LC_utf8((U8*)s));
d2053 6
a2058 4
    case BOUND:
        FBC_BOUND(isWORDCHAR,
                  isWORDCHAR_uni(tmp),
                  cBOOL(swash_fetch(PL_utf8_swash_ptrs[_CC_WORDCHAR], (U8*)s, utf8_target)));
d2060 6
a2065 4
    case BOUNDA:
        FBC_BOUND_NOLOAD(isWORDCHAR_A,
                         isWORDCHAR_A(tmp),
                         isWORDCHAR_A((U8*)s));
d2067 6
a2072 4
    case NBOUND:
        FBC_NBOUND(isWORDCHAR,
                   isWORDCHAR_uni(tmp),
                   cBOOL(swash_fetch(PL_utf8_swash_ptrs[_CC_WORDCHAR], (U8*)s, utf8_target)));
d2074 6
a2079 4
    case NBOUNDA:
        FBC_NBOUND_NOLOAD(isWORDCHAR_A,
                          isWORDCHAR_A(tmp),
                          isWORDCHAR_A((U8*)s));
d2081 12
d2094 242
a2335 8
        FBC_BOUND(isWORDCHAR_L1,
                  isWORDCHAR_uni(tmp),
                  cBOOL(swash_fetch(PL_utf8_swash_ptrs[_CC_WORDCHAR], (U8*)s, utf8_target)));
        break;
    case NBOUNDU:
        FBC_NBOUND(isWORDCHAR_L1,
                   isWORDCHAR_uni(tmp),
                   cBOOL(swash_fetch(PL_utf8_swash_ptrs[_CC_WORDCHAR], (U8*)s, utf8_target)));
d2337 1
d2352 1
d2370 2
a2371 3
             * UTF-8 variant code points, plus everything in ASCII that isn't
             * in the class */
            REXEC_FBC_UTF8_CLASS_SCAN(! UTF8_IS_INVARIANT(*s)
d2398 1
a2398 1
      posix_utf8:
d2415 1
a2415 1
                                _generic_isCC(TWO_BYTE_UTF8_TO_NATIVE(*s,
d2433 1
a2433 5
                case _CC_ENUM_SPACE: /* XXX would require separate code if we
                                        revert the change of \v matching this */
                    /* FALL THROUGH */

                case _CC_ENUM_PSXSPC:
d2460 1
a2460 1
                    assert(0); /* NOTREACHED */
d2572 2
a2573 2
                                        (char *)uc, utf8_target );
                                    PerlIO_printf( Perl_debug_log,
d2608 2
a2609 2
                                        real_start, s, utf8_target);
                            PerlIO_printf(Perl_debug_log,
d2629 2
a2630 2
                                    s,   utf8_target );
                            PerlIO_printf( Perl_debug_log,
d2646 1
a2646 1
                                    PerlIO_printf( Perl_debug_log," - legal\n"));
d2652 1
a2652 1
                                    PerlIO_printf( Perl_debug_log," - fail\n"));
d2660 1
a2660 1
                                    PerlIO_printf( Perl_debug_log," - accepting\n"));
d2682 1
a2682 2
                        PerlIO_printf(
                            Perl_debug_log,"Matches word #%"UVxf" at position %"IVdf". Trying full pattern...\n",
d2693 1
a2693 1
                        PerlIO_printf( Perl_debug_log,"Pattern failed. Looking for new start point...\n");
d2697 1
a2697 1
                        PerlIO_printf( Perl_debug_log,"No match.\n"));
a2706 1
        break;
d2729 1
a2729 2
            if (DEBUG_C_TEST) {
                PerlIO_printf(Perl_debug_log,
d2731 1
a2731 2
                              (int) SvTYPE(sv));
            }
d2772 1
a2772 1
                 * by a capture. Due to look-ahead, this may be to
d2793 1
a2793 1
                 * by a capture. Due to look-behind, this may be to
a2878 1
    dVAR;
d2898 1
a2898 1
    if (prog == NULL || stringarg == NULL) {
a2899 1
	return 0;
d2909 5
d2922 1
a2922 1
            : (sv && (mg = mg_find_mglob(sv)) && mg->mg_len >= 0)
d2927 1
a2927 1
        DEBUG_GPOS_r(PerlIO_printf(Perl_debug_log,
d2941 9
a2949 7
            startpos  = reginfo->ganch - prog->gofs;
            if (startpos <
                ((flags & REXEC_FAIL_ON_UNDERFLOW) ? stringarg : strbeg))
            {
                DEBUG_r(PerlIO_printf(Perl_debug_log,
                        "fail: ganch-gofs before earliest possible start\n"));
                return 0;
d2951 2
d2955 2
a2956 1
            if (startpos - prog->gofs < strbeg)
a2957 2
            else
                startpos -= prog->gofs;
d2965 1
a2965 1
        DEBUG_r(PerlIO_printf(Perl_debug_log,
d3000 1
a3000 1
                DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
d3025 1
a3025 1
        DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
a3039 1
    reginfo->is_utf8_target = cBOOL(utf8_target);
a3041 1
    reginfo->strbeg  = strbeg;
a3043 1
    reginfo->strend = strend;
a3053 1
        assert(!IS_PADGV(sv));
d3122 1
a3122 1
	DEBUG_BUFFERS_r(PerlIO_printf(Perl_debug_log,
d3130 3
d3185 1
a3185 1
        assert(startpos == reginfo->ganch - prog->gofs);
d3233 1
a3233 1
		PerlIO_printf(Perl_debug_log,
d3338 1
a3338 1
            PerlIO_printf(Perl_debug_log, "Did not find %s substr %s%s...\n",
d3349 1
a3349 1
	    if (PL_regkind[op] != EXACT && op != CANY && PL_regkind[op] != TRIE)
d3354 1
a3354 1
            regprop(prog, prop, c, reginfo);
d3358 1
a3358 1
		PerlIO_printf(Perl_debug_log,
d3366 1
a3366 1
	DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "Contradicts stclass... [regexec_flags]\n"));
d3405 1
a3405 1
			PerlIO_printf(Perl_debug_log,
d3412 1
a3412 1
			    PerlIO_printf(Perl_debug_log,
d3424 1
a3424 1
			    PerlIO_printf(Perl_debug_log,
d3435 1
a3435 1
				PerlIO_printf(Perl_debug_log,
d3459 3
a3461 2
		    PerlIO_printf(Perl_debug_log,
			"String does not contain required substring, cannot match.\n"
d3491 1
a3491 1
got_it:
d3499 1
a3499 1
        DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
d3506 1
a3506 1
	    PerlIO_printf(Perl_debug_log,
d3531 2
a3532 2
phooey:
    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "%sMatch failed%s\n",
d3543 1
a3543 1
	DEBUG_BUFFERS_r(PerlIO_printf(Perl_debug_log,
d3569 1
a3569 1
STATIC I32			/* 0 failure, 1 success */
a3571 1
    dVAR;
d3576 3
d3639 2
a3640 2
   'failed...' are printed. It should be set such that messages 
   are inline with the regop output that created them.
d3642 17
a3658 1
#define REPORT_CODE_OFF 32
d3839 12
a3850 12
#define DEBUG_STATE_pp(pp)				    \
    DEBUG_STATE_r({					    \
	DUMP_EXEC_POS(locinput, scan, utf8_target);         \
	PerlIO_printf(Perl_debug_log,			    \
	    "    %*s"pp" %s%s%s%s%s\n",			    \
	    depth*2, "",				    \
	    PL_reg_name[st->resume_state],                  \
	    ((st==yes_state||st==mark_state) ? "[" : ""),   \
	    ((st==yes_state) ? "Y" : ""),                   \
	    ((st==mark_state) ? "M" : ""),                  \
	    ((st==yes_state||st==mark_state) ? "]" : "")    \
	);                                                  \
d3875 1
a3875 1
        PerlIO_printf(Perl_debug_log, 
d3880 1
a3880 1
            PerlIO_printf(Perl_debug_log, "UTF-8 %s%s%s...\n",
d3894 3
a3896 1
                      const bool utf8_target)
d3926 1
a3926 1
	const int is_uni = (utf8_target && OP(scan) != CANY) ? 1 : 0;
d3939 2
a3940 2
	PerlIO_printf(Perl_debug_log,
		    "%4"IVdf" <%.*s%.*s%s%.*s>%*s|",
d3947 2
a3948 1
		    "");
d3964 1
a3964 1
S_reg_check_named_buff_matched(pTHX_ const regexp *rex, const regnode *scan)
d4040 2
a4041 2
    UV c1 = CHRTEST_NOT_A_CP_1;
    UV c2 = CHRTEST_NOT_A_CP_2;
d4054 1
a4054 1
    if (OP(text_node) == EXACT) {
d4132 1
a4132 1
            if (c1 > 256) {
d4136 1
a4136 8
                    if (! PL_utf8_tofold) {
                        U8 dummy[UTF8_MAXBYTES_CASE+1];

                        /* Force loading this by folding an above-Latin1 char */
                        to_utf8_fold((U8*) HYPHEN_UTF8, dummy, NULL);
                        assert(PL_utf8_tofold); /* Verify that worked */
                    }
                    PL_utf8_foldclosures = _swash_inversion_hash(PL_utf8_tofold);
d4156 1
a4156 1
                    if (av_tindex(list) != 1) {
d4178 1
a4178 1
                         * 256, and its only other match is below 256, the only
d4181 1
a4181 1
                         * above 255 */
d4200 1
a4200 1
            else /* Here, c1 is < 255 */
d4241 1
a4241 1
                        /* FALL THROUGH */
d4250 1
a4250 1
                        assert(0); /* NOTREACHED */
d4292 868
d5164 1
d5183 1
a5183 1
    I32 nextchr;   /* is always set to UCHARAT(locinput) */
d5225 1
a5225 1
    I32 gimme = G_SCALAR;
d5233 8
a5250 2
    multicall_cv = NULL;
    cx = NULL;
a5251 2
    PERL_UNUSED_VAR(newsp);

d5256 1
a5256 1
	    PerlIO_printf(Perl_debug_log,"regmatch start\n");
a5265 13
        DEBUG_EXECUTE_r( {
	    SV * const prop = sv_newmortal();
	    regnode *rnext=regnext(scan);
	    DUMP_EXEC_POS( locinput, scan, utf8_target );
            regprop(rex, prop, scan, reginfo);
            
	    PerlIO_printf(Perl_debug_log,
		    "%3"IVdf":%*s%s(%"IVdf")\n",
		    (IV)(scan - rexi->program), depth*2, "",
		    SvPVX_const(prop),
		    (PL_regkind[OP(scan)] == END || !rnext) ? 
		        0 : (IV)(rnext - rexi->program));
	});
d5273 17
d5296 1
a5296 2
	case BOL:  /*  /^../   */
	case SBOL: /*  /^../s  */
d5319 2
a5320 1
	    assert(0); /*NOTREACHED*/
d5325 1
a5325 1
	    assert(0); /*NOTREACHED*/
d5332 1
a5332 3
	case EOL: /* /..$/  */
            /* FALL THROUGH */
	case SEOL: /* /..$/s  */
a5348 6
	case CANY: /*  \C  */
	    if (NEXTCHR_IS_EOS)
		sayNO;
	    locinput++;
	    break;

d5363 2
a5364 3
                    PerlIO_printf(Perl_debug_log,
                              "%*s  %sfailed to match trie start class...%s\n",
                              REPORT_CODE_OFF+depth*2, "", PL_colors[4], PL_colors[5])
d5367 1
a5367 1
                assert(0); /* NOTREACHED */
d5369 1
a5369 1
            /* FALL THROUGH */
d5425 13
d5443 2
a5444 3
                            PerlIO_printf(Perl_debug_log,
                        	          "%*s  %smatched empty string...%s\n",
                        	          REPORT_CODE_OFF+depth*2, "", PL_colors[4], PL_colors[5])
d5450 2
a5451 3
                            PerlIO_printf(Perl_debug_log,
                        	          "%*s  %sfailed to match trie start class...%s\n",
                        	          REPORT_CODE_OFF+depth*2, "", PL_colors[4], PL_colors[5])
d5503 4
a5506 4
		                DUMP_EXEC_POS( (char *)uc, scan, utf8_target );
			        PerlIO_printf( Perl_debug_log,
			            "%*s  %sState: %4"UVxf" Accepted: %c ",
			            2+depth * 2, "", PL_colors[4],
d5538 1
a5538 1
		        PerlIO_printf( Perl_debug_log,
d5558 2
a5559 3
		    PerlIO_printf( Perl_debug_log,
			"%*s  %sgot %"IVdf" possible matches%s\n",
			REPORT_CODE_OFF + depth * 2, "",
d5564 1
a5564 1
	    assert(0); /* NOTREACHED */
d5575 2
a5576 3
		    PerlIO_printf( Perl_debug_log,
			"%*s  %sTRIE failed...%s\n",
			REPORT_CODE_OFF+depth*2, "", 
d5666 2
a5667 3
		PerlIO_printf( Perl_debug_log,
		    "%*s  %sTRIE matched word #%d, continuing%s\n",
		    REPORT_CODE_OFF+depth*2, "", 
d5676 1
a5676 1
		assert(0); /* NOTREACHED */
d5682 2
a5683 2
		SV ** const tmp = av_fetch( trie_words,
		    ST.nextword-1, 0 );
d5686 2
a5687 3
		PerlIO_printf( Perl_debug_log,
		    "%*s  %sonly one match left, short-circuiting: #%d <%s>%s\n",
		    REPORT_CODE_OFF+depth*2, "", PL_colors[4],
d5699 1
a5699 1
	    assert(0); /* NOTREACHED */
d5703 13
d5747 1
a5747 1
                            if (TWO_BYTE_UTF8_TO_NATIVE(*l, *(l+1)) != * (U8*) s)
d5771 1
a5771 1
                            if (TWO_BYTE_UTF8_TO_NATIVE(*s, *(s+1)) != * (U8*) l)
d5802 1
d5808 12
d5830 1
a5830 1
            /* FALL THROUGH */
d5838 169
a6006 5
                                               non-utf8 patterns */
            assert(! is_utf8_pat);
	    folder = foldEQ;
	    fold_array = PL_fold;
	    fold_utf8_flags = 0;
d6008 21
a6028 3
	  do_exactf:
	    s = STRING(scan);
	    ln = STR_LEN(scan);
d6030 18
a6047 9
	    if (utf8_target
                || is_utf8_pat
                || state_num == EXACTFU_SS
                || (state_num == EXACTFL && IN_UTF8_CTYPE_LOCALE))
            {
	      /* Either target or the pattern are utf8, or has the issue where
	       * the fold lengths may differ. */
		const char * const l = locinput;
		char *e = reginfo->strend;
d6049 20
a6068 7
		if (! foldEQ_utf8_flags(s, 0,  ln, is_utf8_pat,
			                l, &e, 0,  utf8_target, fold_utf8_flags))
		{
		    sayNO;
		}
		locinput = e;
		break;
d6070 26
d6097 16
a6112 14
	    /* Neither the target nor the pattern are utf8 */
	    if (UCHARAT(s) != nextchr
                && !NEXTCHR_IS_EOS
		&& UCHARAT(s) != fold_array[nextchr])
	    {
		sayNO;
	    }
	    if (reginfo->strend - locinput < ln)
		sayNO;
	    if (ln > 1 && ! folder(s, locinput, ln))
		sayNO;
	    locinput += ln;
	    break;
	}
d6114 13
a6126 21
	/* XXX Could improve efficiency by separating these all out using a
	 * macro or in-line function.  At that point regcomp.c would no longer
	 * have to set the FLAGS fields of these */
	case BOUNDL:  /*  /\b/l  */
	case NBOUNDL: /*  /\B/l  */
	case BOUND:   /*  /\b/   */
	case BOUNDU:  /*  /\b/u  */
	case BOUNDA:  /*  /\b/a  */
	case NBOUND:  /*  /\B/   */
	case NBOUNDU: /*  /\B/u  */
	case NBOUNDA: /*  /\B/a  */
	    /* was last char in word? */
	    if (utf8_target
		&& FLAGS(scan) != REGEX_ASCII_RESTRICTED_CHARSET
		&& FLAGS(scan) != REGEX_ASCII_MORE_RESTRICTED_CHARSET)
	    {
		if (locinput == reginfo->strbeg)
		    ln = '\n';
		else {
		    const U8 * const r =
                            reghop3((U8*)locinput, -1, (U8*)(reginfo->strbeg));
d6128 15
a6142 17
		    ln = utf8n_to_uvchr(r, (U8*) reginfo->strend - r,
                                                                   0, uniflags);
		}
		if (FLAGS(scan) != REGEX_LOCALE_CHARSET) {
		    ln = isWORDCHAR_uni(ln);
                    if (NEXTCHR_IS_EOS)
                        n = 0;
                    else {
                        LOAD_UTF8_CHARCLASS_ALNUM();
                        n = swash_fetch(PL_utf8_swash_ptrs[_CC_WORDCHAR], (U8*)locinput,
                                                                utf8_target);
                    }
		}
		else {
		    ln = isWORDCHAR_LC_uvchr(ln);
		    n = NEXTCHR_IS_EOS ? 0 : isWORDCHAR_LC_utf8((U8*)locinput);
		}
a6143 1
	    else {
d6145 3
a6147 40
		/* Here the string isn't utf8, or is utf8 and only ascii
		 * characters are to match \w.  In the latter case looking at
		 * the byte just prior to the current one may be just the final
		 * byte of a multi-byte character.  This is ok.  There are two
		 * cases:
		 * 1) it is a single byte character, and then the test is doing
		 *	just what it's supposed to.
		 * 2) it is a multi-byte character, in which case the final
		 *	byte is never mistakable for ASCII, and so the test
		 *	will say it is not a word character, which is the
		 *	correct answer. */
		ln = (locinput != reginfo->strbeg) ?
		    UCHARAT(locinput - 1) : '\n';
		switch (FLAGS(scan)) {
		    case REGEX_UNICODE_CHARSET:
			ln = isWORDCHAR_L1(ln);
			n = NEXTCHR_IS_EOS ? 0 : isWORDCHAR_L1(nextchr);
			break;
		    case REGEX_LOCALE_CHARSET:
			ln = isWORDCHAR_LC(ln);
			n = NEXTCHR_IS_EOS ? 0 : isWORDCHAR_LC(nextchr);
			break;
		    case REGEX_DEPENDS_CHARSET:
			ln = isWORDCHAR(ln);
			n = NEXTCHR_IS_EOS ? 0 : isWORDCHAR(nextchr);
			break;
		    case REGEX_ASCII_RESTRICTED_CHARSET:
		    case REGEX_ASCII_MORE_RESTRICTED_CHARSET:
			ln = isWORDCHAR_A(ln);
			n = NEXTCHR_IS_EOS ? 0 : isWORDCHAR_A(nextchr);
			break;
		    default:
			Perl_croak(aTHX_ "panic: Unexpected FLAGS %u in op %u", FLAGS(scan), OP(scan));
			break;
		}
	    }
	    /* Note requires that all BOUNDs be lower than all NBOUNDs in
	     * regcomp.sym */
	    if (((!ln) == (!n)) == (OP(scan) < NBOUND))
		    sayNO;
d6150 10
a6159 1
	case ANYOF:  /*  /[abc]/       */
d6162 1
a6162 1
	    if (utf8_target) {
d6169 1
a6169 1
		if (!REGINCLASS(rex, scan, (U8*)locinput))
d6183 1
d6197 2
a6198 2
                                           (U8) TWO_BYTE_UTF8_TO_NATIVE(nextchr,
                                                            *(locinput + 1))))))
d6204 2
a6205 1
                goto utf8_posix_not_eos;
d6234 1
a6234 1
            /* FALLTHROUGH */
d6243 8
a6250 3
            if (NEXTCHR_IS_EOS
                || ! (to_complement ^ cBOOL(_generic_isCC_A(nextchr,
                                                            FLAGS(scan)))))
a6268 1
          utf8_posix_not_eos:
d6283 1
a6283 1
                       ^ cBOOL(_generic_isCC(TWO_BYTE_UTF8_TO_NATIVE(nextchr,
d6292 1
d6315 1
a6315 4
                        case _CC_ENUM_SPACE:    /* XXX would require separate
                                                   code if we revert the change
                                                   of \v matching this */
                        case _CC_ENUM_PSXSPC:
a6356 32
	    /* From http://www.unicode.org/reports/tr29 (5.2 version).  An
	      extended Grapheme Cluster is:

            CR LF
            | Prepend* Begin Extend*
            | .

            Begin is:           ( Special_Begin | ! Control )
            Special_Begin is:   ( Regional-Indicator+ | Hangul-syllable )
            Extend is:          ( Grapheme_Extend | Spacing_Mark )
            Control is:         [ GCB_Control | CR | LF ]
            Hangul-syllable is: ( T+ | ( L* ( L | ( LVT | ( V | LV ) V* ) T* ) ))

               If we create a 'Regular_Begin' = Begin - Special_Begin, then
               we can rewrite

                   Begin is ( Regular_Begin + Special Begin )

               It turns out that 98.4% of all Unicode code points match
               Regular_Begin.  Doing it this way eliminates a table match in
               the previous implementation for almost all Unicode code points.

	       There is a subtlety with Prepend* which showed up in testing.
	       Note that the Begin, and only the Begin is required in:
	        | Prepend* Begin Extend*
	       Also, Begin contains '! Control'.  A Prepend must be a
	       '!  Control', which means it must also be a Begin.  What it
	       comes down to is that if we match Prepend* and then find no
	       suitable Begin afterwards, that if we backtrack the last
	       Prepend, that one will be a suitable Begin.
	    */

d6374 14
a6387 24
		/* Utf8: See if is ( CR LF ); already know that locinput <
		 * reginfo->strend, so locinput+1 is in bounds */
		if ( nextchr == '\r' && locinput+1 < reginfo->strend
                     && UCHARAT(locinput + 1) == '\n')
                {
		    locinput += 2;
		}
		else {
                    STRLEN len;

		    /* In case have to backtrack to beginning, then match '.' */
		    char *starting = locinput;

		    /* In case have to backtrack the last prepend */
		    char *previous_prepend = NULL;

		    LOAD_UTF8_CHARCLASS_GCB();

                    /* Match (prepend)*   */
                    while (locinput < reginfo->strend
                           && (len = is_GCB_Prepend_utf8(locinput)))
                    {
                        previous_prepend = locinput;
                        locinput += len;
d6390 3
a6392 50
		    /* As noted above, if we matched a prepend character, but
		     * the next thing won't match, back off the last prepend we
		     * matched, as it is guaranteed to match the begin */
		    if (previous_prepend
			&& (locinput >=  reginfo->strend
			    || (! swash_fetch(PL_utf8_X_regular_begin,
					     (U8*)locinput, utf8_target)
			         && ! is_GCB_SPECIAL_BEGIN_START_utf8(locinput)))
                        )
		    {
			locinput = previous_prepend;
		    }

		    /* Note that here we know reginfo->strend > locinput, as we
		     * tested that upon input to this switch case, and if we
		     * moved locinput forward, we tested the result just above
		     * and it either passed, or we backed off so that it will
		     * now pass */
		    if (swash_fetch(PL_utf8_X_regular_begin,
                                    (U8*)locinput, utf8_target)) {
                        locinput += UTF8SKIP(locinput);
                    }
                    else if (! is_GCB_SPECIAL_BEGIN_START_utf8(locinput)) {

			/* Here did not match the required 'Begin' in the
			 * second term.  So just match the very first
			 * character, the '.' of the final term of the regex */
			locinput = starting + UTF8SKIP(starting);
                        goto exit_utf8;
		    } else {

                        /* Here is a special begin.  It can be composed of
                         * several individual characters.  One possibility is
                         * RI+ */
                        if ((len = is_GCB_RI_utf8(locinput))) {
                            locinput += len;
                            while (locinput < reginfo->strend
                                   && (len = is_GCB_RI_utf8(locinput)))
                            {
                                locinput += len;
                            }
                        } else if ((len = is_GCB_T_utf8(locinput))) {
                            /* Another possibility is T+ */
                            locinput += len;
                            while (locinput < reginfo->strend
                                && (len = is_GCB_T_utf8(locinput)))
                            {
                                locinput += len;
                            }
                        } else {
a6393 53
                            /* Here, neither RI+ nor T+; must be some other
                             * Hangul.  That means it is one of the others: L,
                             * LV, LVT or V, and matches:
                             * L* (L | LVT T* | V * V* T* | LV  V* T*) */

                            /* Match L*           */
                            while (locinput < reginfo->strend
                                   && (len = is_GCB_L_utf8(locinput)))
                            {
                                locinput += len;
                            }

                            /* Here, have exhausted L*.  If the next character
                             * is not an LV, LVT nor V, it means we had to have
                             * at least one L, so matches L+ in the original
                             * equation, we have a complete hangul syllable.
                             * Are done. */

                            if (locinput < reginfo->strend
                                && is_GCB_LV_LVT_V_utf8(locinput))
                            {
                                /* Otherwise keep going.  Must be LV, LVT or V.
                                 * See if LVT, by first ruling out V, then LV */
                                if (! is_GCB_V_utf8(locinput)
                                        /* All but every TCount one is LV */
                                    && (valid_utf8_to_uvchr((U8 *) locinput,
                                                                         NULL)
                                                                        - SBASE)
                                        % TCount != 0)
                                {
                                    locinput += UTF8SKIP(locinput);
                                } else {

                                    /* Must be  V or LV.  Take it, then match
                                     * V*     */
                                    locinput += UTF8SKIP(locinput);
                                    while (locinput < reginfo->strend
                                           && (len = is_GCB_V_utf8(locinput)))
                                    {
                                        locinput += len;
                                    }
                                }

                                /* And any of LV, LVT, or V can be followed
                                 * by T*            */
                                while (locinput < reginfo->strend
                                       && (len = is_GCB_T_utf8(locinput)))
                                {
                                    locinput += len;
                                }
                            }
                        }
                    }
a6394 10
                    /* Match any extender */
                    while (locinput < reginfo->strend
                            && swash_fetch(PL_utf8_X_extend,
                                            (U8*)locinput, utf8_target))
                    {
                        locinput += UTF8SKIP(locinput);
                    }
		}
            exit_utf8:
		if (locinput > reginfo->strend) sayNO;
d6411 1
d6456 1
a6539 3
	case BACK: /* ??? doesn't appear to be used ??? */
	    break;

d6542 2
d6550 1
a6551 1
	case GOSTART: /*  (?R)  */
d6553 2
a6554 3
	    if (cur_eval && cur_eval->locinput==locinput) {
                if (cur_eval->u.eval.close_paren == (U32)ARG(scan)) 
                    Perl_croak(aTHX_ "Infinite recursion in regex");
d6565 14
a6578 3
            if (OP(scan)==GOSUB) {
                startpoint = scan + ARG2L(scan);
                ST.close_paren = ARG(scan);
d6580 12
a6591 2
                startpoint = rei->program+1;
                ST.close_paren = 0;
d6600 1
a6600 2

            assert(0); /* NOTREACHED */
d6629 3
a6631 4
		    newcv = (ReANY(
						(REGEXP*)(rexi->data->data[n])
					    ))->qr_anoncv
					;
d6658 7
a6675 1
		    newsp = NULL;
d6694 1
a6694 1
			o = o->op_sibling;
d6711 1
a6711 1
		DEBUG_STATE_r( PerlIO_printf(Perl_debug_log, 
d6727 2
a6728 1
		 * first op of the sub */
d6821 2
a6822 2
                                    /* copy /msix etc to inner pattern */
                                    scan->flags,
d6850 3
a6852 1
               	ST.close_paren = 0; /* only used for GOSUB */
d6860 1
a6860 1
        eval_recurse_doit: /* Share code with GOSUB below this line
d6889 1
a6889 1
		assert(0); /* NOTREACHED */
d6893 20
a6912 1
	    /* note: this is called twice; first after popping B, then A */
d6933 2
d6940 7
d6957 1
d6962 3
a6964 1
	    sayNO_SILENT;
d6972 1
a6972 1
	    DEBUG_BUFFERS_r(PerlIO_printf(Perl_debug_log,
d6984 10
a6993 10
#define CLOSE_CAPTURE \
    rex->offs[n].start = rex->offs[n].start_tmp; \
    rex->offs[n].end = locinput - reginfo->strbeg; \
    DEBUG_BUFFERS_r(PerlIO_printf(Perl_debug_log, \
	"rex=0x%"UVxf" offs=0x%"UVxf": \\%"UVuf": set %"IVdf"..%"IVdf"\n", \
	PTR2UV(rex), \
	PTR2UV(rex->offs), \
	(UV)n, \
	(IV)rex->offs[n].start, \
	(IV)rex->offs[n].end \
d7002 1
a7002 1
            if (cur_eval && cur_eval->u.eval.close_paren == n) {
d7004 1
a7004 1
	    }    
d7008 3
a7010 1
            if (ARG(scan)){
d7023 1
a7023 2
                            if ( n == ARG(scan) || (cur_eval &&
                                cur_eval->u.eval.close_paren == n))
d7030 1
a7030 1
	    /*NOTREACHED*/	    
d7044 3
a7046 1
            sw = (cur_eval && (!n || cur_eval->u.eval.close_paren == n));
d7182 1
a7182 1
	    assert(0); /* NOTREACHED */
d7188 1
a7188 1
	    assert(0); /* NOTREACHED */
d7194 1
a7194 1
	    assert(0); /* NOTREACHED */
d7204 2
a7205 3
	    int min = ARG1(cur_curlyx->u.curlyx.me);
	    int max = ARG2(cur_curlyx->u.curlyx.me);
	    regnode *A = NEXTOPER(cur_curlyx->u.curlyx.me) + EXTRA_STEP_2ARGS;
d7208 4
d7218 2
a7219 3
	    DEBUG_EXECUTE_r( PerlIO_printf(Perl_debug_log,
		  "%*s  whilem: matched %ld out of %d..%d\n",
		  REPORT_CODE_OFF+depth*2, "", (long)n, min, max)
d7231 1
a7231 1
		assert(0); /* NOTREACHED */
d7237 2
a7238 3
		DEBUG_EXECUTE_r( PerlIO_printf(Perl_debug_log,
		   "%*s  whilem: empty match detected, trying continuation...\n",
		   REPORT_CODE_OFF+depth*2, "")
d7304 1
a7304 1
		    DEBUG_EXECUTE_r( PerlIO_printf(Perl_debug_log,
d7321 2
a7322 3
			DEBUG_EXECUTE_r( PerlIO_printf(Perl_debug_log,
			    "%*s  whilem: (cache) already tried at this position...\n",
			    REPORT_CODE_OFF+depth*2, "")
d7341 1
a7341 1
		assert(0); /* NOTREACHED */
d7352 1
a7352 1
		assert(0); /* NOTREACHED */
d7356 1
a7356 1
	assert(0); /* NOTREACHED */
d7362 1
a7362 1
	    assert(0); /* NOTREACHED */
d7369 1
a7369 1
	    assert(0); /* NOTREACHED */
d7372 1
a7372 1
	    /* FALL THROUGH */
d7379 1
a7379 1
	    assert(0); /* NOTREACHED */
d7384 2
a7385 3
	    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
		"%*s  whilem: failed, trying continuation...\n",
		REPORT_CODE_OFF+depth*2, "")
d7404 1
a7404 1
	    assert(0); /* NOTREACHED */
d7427 1
a7427 2
	    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
		"%*s  trying longer...\n", REPORT_CODE_OFF+depth*2, "")
d7437 1
a7437 1
	    assert(0); /* NOTREACHED */
d7447 1
a7447 1
	    /* FALL THROUGH */
d7462 1
a7462 1
	    assert(0); /* NOTREACHED */
d7465 3
a7467 2
            sv_yes_mark = st->u.mark.mark_name = scan->flags ? NULL :
                MUTABLE_SV(rexi->data->data[ ARG( scan ) ]);
d7469 1
a7469 1
            assert(0); /* NOTREACHED */
d7477 1
a7477 1
            assert(0); /* NOTREACHED */
d7481 1
a7481 1
            assert(0); /* NOTREACHED */
d7494 2
a7495 3
		    PerlIO_printf( Perl_debug_log,
			"%*s  %sBRANCH failed...%s\n",
			REPORT_CODE_OFF+depth*2, "", 
d7502 1
a7502 1
	    assert(0); /* NOTREACHED */
d7546 1
a7546 1
	    assert(0); /* NOTREACHED */
d7566 2
a7567 4
		PerlIO_printf(Perl_debug_log,
			  "%*s  CURLYM now matched %"IVdf" times, len=%"IVdf"...\n",
			  (int)(REPORT_CODE_OFF+(depth*2)), "",
			  (IV) ST.count, (IV)ST.alen)
d7570 1
a7570 2
	    if (cur_eval && cur_eval->u.eval.close_paren && 
	        cur_eval->u.eval.close_paren == (U32)ST.me->flags) 
d7583 1
d7585 1
a7585 2
	        || (cur_eval && cur_eval->u.eval.close_paren &&
	            cur_eval->u.eval.close_paren == (U32)ST.me->flags))
d7593 1
d7619 2
a7620 4
		PerlIO_printf(Perl_debug_log,
		    "%*s  CURLYM trying tail with matches=%"IVdf"...\n",
		    (int)(REPORT_CODE_OFF+(depth*2)),
		    "", (IV)ST.count)
d7629 2
a7630 3
                            PerlIO_printf(Perl_debug_log,
                                "%*s  CURLYM Fast bail next target=0x%"UVXf" c1=0x%"UVXf" c2=0x%"UVXf"\n",
                                (int)(REPORT_CODE_OFF+(depth*2)),"",
d7642 2
a7643 3
                        PerlIO_printf(Perl_debug_log,
                            "%*s  CURLYM Fast bail next target=0x%X c1=0x%X c2=0x%X\n",
                            (int)(REPORT_CODE_OFF+(depth*2)),"",
d7664 2
a7665 2
		if (cur_eval && cur_eval->u.eval.close_paren &&
		    cur_eval->u.eval.close_paren == (U32)ST.me->flags) 
d7675 1
a7675 1
	    assert(0); /* NOTREACHED */
d7734 2
a7735 2
	    if (cur_eval && cur_eval->u.eval.close_paren &&
	        cur_eval->u.eval.close_paren == (U32)ST.paren) {
d7853 1
a7853 2
	    assert(0); /* NOTREACHED */

d7922 1
a7922 2
		if (cur_eval && cur_eval->u.eval.close_paren && 
		    cur_eval->u.eval.close_paren == (U32)ST.paren) {
a7923 1
	        }
d7926 1
a7926 2
	    assert(0); /* NOTREACHED */

d7950 1
a7950 2
		    if (cur_eval && cur_eval->u.eval.close_paren &&
		        cur_eval->u.eval.close_paren == (U32)ST.paren) {
a7951 1
                    }
d7956 1
a7956 1
	    assert(0); /* NOTREACHED */
d7958 1
a7958 2

	curly_try_B_max:
d7960 1
a7960 2
            if (cur_eval && cur_eval->u.eval.close_paren &&
                cur_eval->u.eval.close_paren == (U32)ST.paren) {
a7961 1
            }
d7984 1
a7984 1
		    assert(0); /* NOTREACHED */
d7987 1
a7987 1
	    /* FALL THROUGH */
d8005 1
a8005 1
	    fake_end:
d8008 1
a8008 1

d8013 1
a8013 1
		rex_sv = cur_eval->u.eval.prev_rex;
d8018 3
a8020 1
		cur_curlyx = cur_eval->u.eval.prev_curlyx;
d8026 1
a8026 1
		S_regcp_restore(aTHX_ rex, cur_eval->u.eval.lastcp,
d8030 1
a8030 1
		cur_eval = cur_eval->u.eval.prev_eval;
d8032 2
a8033 2
		    PerlIO_printf(Perl_debug_log, "%*s  EVAL trying tail ... %"UVxf"\n",
				      REPORT_CODE_OFF+depth*2, "",PTR2UV(cur_eval)););
d8037 2
d8044 2
a8045 2
		DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
				      "%sMatch possible, but length=%ld is smaller than requested=%ld, failing!%s\n",
d8057 2
a8058 3
	    PerlIO_printf(Perl_debug_log,
		"%*s  %ssubpattern success...%s\n",
		REPORT_CODE_OFF+depth*2, "", PL_colors[4], PL_colors[5]));
d8106 1
a8106 1
	    assert(0); /* NOTREACHED */
d8111 1
a8111 1
	    /* FALL THROUGH */
d8143 1
a8143 1
	    if (!scan->flags)
d8146 1
a8146 1
	    assert(0); /* NOTREACHED */
d8151 2
d8155 12
a8166 2
	    sayNO;
	    assert(0); /* NOTREACHED */
d8176 1
a8176 1
            assert(0); /* NOTREACHED */
d8181 1
a8181 1
            assert(0); /* NOTREACHED */
d8192 2
a8193 3
                        PerlIO_printf(Perl_debug_log,
		            "%*s  %ssetting cutpoint to mark:%"SVf"...%s\n",
		            REPORT_CODE_OFF+depth*2, "", 
d8201 1
a8201 1
            assert(0); /* NOTREACHED */
d8204 1
a8204 1
            if (scan->flags) {
d8246 1
a8246 1
            assert(0); /* NOTREACHED */
d8263 1
a8263 1
        increment_locinput:
d8280 1
a8280 1
	assert(0); /* NOTREACHED */
d8286 1
a8286 1
	/* FALL THROUGH */
d8297 1
a8297 1
                for (;curd > -1;cur--,curd--) {
d8302 2
a8303 2
                    PerlIO_printf(Perl_error_log, "%*s#%-3d %-10s %s\n",
                        REPORT_CODE_OFF + 2 + depth * 2,"",
d8323 1
a8323 1
	    assert(0); /* NOTREACHED */
d8326 3
d8335 1
a8335 2
    /*NOTREACHED*/
    sayNO;
d8337 1
a8337 1
yes:
d8379 1
a8379 1
    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "%sMatch successful!%s\n",
d8398 1
a8398 1
no:
d8400 2
a8401 3
	PerlIO_printf(Perl_debug_log,
            "%*s  %sfailed...%s\n",
            REPORT_CODE_OFF+depth*2, "", 
d8405 1
a8405 1
no_silent:
d8446 2
a8480 1
    dVAR;
d8486 1
a8486 1
    int to_complement = 0;  /* Invert the result? */
d8546 4
a8549 5
    case CANY:  /* Move <scan> forward <max> bytes, unless goes off end */
        if (utf8_target && loceol - scan > max) {

            /* <loceol> hadn't been adjusted in the UTF-8 case */
            scan +=  max;
d8551 1
a8551 4
        else {
            scan = loceol;
        }
	break;
d8590 1
a8590 1
                c = TWO_BYTE_UTF8_TO_NATIVE(c, *(STRING(p) + 1));
d8619 1
a8619 1
        /* FALL THROUGH */
d8625 1
d8634 8
d8646 1
a8646 1
    do_exactf: {
d8705 8
d8723 1
a8723 1
	    while (scan < loceol && REGINCLASS(prog, p, (U8*)scan))
d8735 1
d8777 1
a8777 1
        /* FALL THROUGH */
d8788 1
a8788 2
             * UTF-8 variant code points, plus everything in ASCII that isn't
             * in the class. */
d8790 1
a8790 1
                   && (! UTF8_IS_INVARIANT(*scan)
d8812 1
a8812 1
      utf8_posix:
d8834 1
a8834 1
                              ^ cBOOL(_generic_isCC(TWO_BYTE_UTF8_TO_NATIVE(*scan,
d8855 1
a8855 5
                    case _CC_ENUM_SPACE:    /* XXX would require separate code
                                               if we revert the change of \v
                                               matching this */
                        /* FALL THROUGH */
                    case _CC_ENUM_PSXSPC:
d8951 4
a8956 1
    case BOUNDL:
a8962 1
    case NBOUNDL:
d8972 1
a8972 1
        assert(0); /* NOTREACHED */
d8986 3
a8988 4
            regprop(prog, prop, p, reginfo);
	    PerlIO_printf(Perl_debug_log,
			"%*s  %s can match %"IVdf" times out of %"IVdf"...\n",
			REPORT_CODE_OFF + depth*2, "", SvPVX_const(prop),(IV)c,(IV)max);
d9011 1
a9011 1
    return newSVsv(_get_regclass_nonbitmap_data(prog, node, doinit, listsvp, NULL));
a9013 112
SV *
Perl__get_regclass_nonbitmap_data(pTHX_ const regexp *prog,
                                        const regnode* node,
                                        bool doinit,
                                        SV** listsvp,
                                        SV** only_utf8_locale_ptr)
{
    /* For internal core use only.
     * Returns the swash for the input 'node' in the regex 'prog'.
     * If <doinit> is 'true', will attempt to create the swash if not already
     *	  done.
     * If <listsvp> is non-null, will return the printable contents of the
     *    swash.  This can be used to get debugging information even before the
     *    swash exists, by calling this function with 'doinit' set to false, in
     *    which case the components that will be used to eventually create the
     *    swash are returned  (in a printable form).
     * Tied intimately to how regcomp.c sets up the data structure */

    dVAR;
    SV *sw  = NULL;
    SV *si  = NULL;         /* Input swash initialization string */
    SV*  invlist = NULL;

    RXi_GET_DECL(prog,progi);
    const struct reg_data * const data = prog ? progi->data : NULL;

    PERL_ARGS_ASSERT__GET_REGCLASS_NONBITMAP_DATA;

    assert(ANYOF_FLAGS(node)
                        & (ANYOF_UTF8|ANYOF_NONBITMAP_NON_UTF8|ANYOF_LOC_FOLD));

    if (data && data->count) {
	const U32 n = ARG(node);

	if (data->what[n] == 's') {
	    SV * const rv = MUTABLE_SV(data->data[n]);
	    AV * const av = MUTABLE_AV(SvRV(rv));
	    SV **const ary = AvARRAY(av);
	    U8 swash_init_flags = _CORE_SWASH_INIT_ACCEPT_INVLIST;
	
	    si = *ary;	/* ary[0] = the string to initialize the swash with */

	    /* Elements 3 and 4 are either both present or both absent. [3] is
	     * any inversion list generated at compile time; [4] indicates if
	     * that inversion list has any user-defined properties in it. */
            if (av_tindex(av) >= 2) {
                if (only_utf8_locale_ptr
                    && ary[2]
                    && ary[2] != &PL_sv_undef)
                {
                    *only_utf8_locale_ptr = ary[2];
                }
                else {
                    *only_utf8_locale_ptr = NULL;
                }

                if (av_tindex(av) >= 3) {
                    invlist = ary[3];
                    if (SvUV(ary[4])) {
                        swash_init_flags |= _CORE_SWASH_INIT_USER_DEFINED_PROPERTY;
                    }
                }
                else {
                    invlist = NULL;
                }
	    }

	    /* Element [1] is reserved for the set-up swash.  If already there,
	     * return it; if not, create it and store it there */
	    if (ary[1] && SvROK(ary[1])) {
		sw = ary[1];
	    }
	    else if (doinit && ((si && si != &PL_sv_undef)
                                 || (invlist && invlist != &PL_sv_undef))) {

		sw = _core_swash_init("utf8", /* the utf8 package */
				      "", /* nameless */
				      si,
				      1, /* binary */
				      0, /* not from tr/// */
				      invlist,
				      &swash_init_flags);
		(void)av_store(av, 1, sw);
	    }
	}
    }
	
    /* If requested, return a printable version of what this swash matches */
    if (listsvp) {
	SV* matches_string = newSVpvn("", 0);

        /* The swash should be used, if possible, to get the data, as it
         * contains the resolved data.  But this function can be called at
         * compile-time, before everything gets resolved, in which case we
         * return the currently best available information, which is the string
         * that will eventually be used to do that resolving, 'si' */
	if ((! sw || (invlist = _get_swash_invlist(sw)) == NULL)
            && (si && si != &PL_sv_undef))
        {
	    sv_catsv(matches_string, si);
	}

	/* Add the inversion list to whatever we have.  This may have come from
	 * the swash, or from an input parameter */
	if (invlist) {
	    sv_catsv(matches_string, _invlist_contents(invlist));
	}
	*listsvp = matches_string;
    }

    return sw;
}
d9019 1
a9019 1
  n is the ANYOF regnode
d9053 3
d9059 1
a9059 1
    if (c < 256) {
d9062 5
a9066 3
	else if (flags & ANYOF_NON_UTF8_NON_ASCII_ALL
		&& ! utf8_target
		&& ! isASCII(c))
d9071 5
a9075 4
	    if (flags & ANYOF_LOC_FOLD) {
		 if (ANYOF_BITMAP_TEST(n, PL_fold_locale[c])) {
                    match = TRUE;
                }
d9077 3
a9079 1
	    if (! match && ANYOF_POSIXL_TEST_ANY_SET(n)) {
d9132 4
a9135 2
	if (c >= 256 && (flags & ANYOF_ABOVE_LATIN1_ALL)) {
	    match = TRUE;	/* Everything above 255 matches */
d9137 21
a9157 5
	else if ((flags & ANYOF_NONBITMAP_NON_UTF8)
		  || (utf8_target && (flags & ANYOF_UTF8))
                  || ((flags & ANYOF_LOC_FOLD)
                       && IN_UTF8_CTYPE_LOCALE
                       && ARG(n) != ANYOF_NONBITMAP_EMPTY))
d9161 1
a9161 1
                                                            &only_utf8_locale);
d9163 1
d9168 3
a9170 2
		    STRLEN len = 1;
		    utf8_p = bytes_to_utf8(p, &len);
a9175 3

		/* If we allocated a string above, free it */
		if (! utf8_target) Safefree(utf8_p);
d9183 3
a9185 1
            && (flags & ANYOF_WARN_SUPER)
a9209 2
    dVAR;

d9225 1
a9225 2
                    dTHX;
                    Perl_croak(aTHX_ "Malformed UTF-8 character (fatal)");
a9236 2
    dVAR;

d9252 1
a9252 2
                    dTHX;
                    Perl_croak(aTHX_ "Malformed UTF-8 character (fatal)");
a9266 2
    dVAR;

d9284 1
a9284 2
                    dTHX;
                    Perl_croak(aTHX_ "Malformed UTF-8 character (fatal)");
a9385 1
    dVAR;
a9476 1
    dVAR;
a9506 6
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
@


1.19
log
@Apply fix for perl bug 123562 which has been assigned CVE-2015-8853.
It can cause certain regular expressions with malformed UTF8 inputs
to go into a forever loop and consume 100% CPU.  OK afresh1@@
@
text
@d759 1
a759 1
         * A note about IMPLICIT: on an un-anchored pattern beginning
d2687 9
a2695 2
    /* Simplest case:  anchored match need be tried only once. */
    /*  [unless only anchor is BOL and multiline is set] */
d2697 3
a2699 1
	if (s == startpos && regtry(reginfo, &s))
a2700 3
        else if (multiline || (prog->intflags & (PREGf_IMPLICIT | PREGf_ANCH_MBOL))) /* XXXX SBOL? */
	{
	    char *end;
d2702 31
a2732 71
	    if (minlen)
		dontbother = minlen - 1;
	    end = HOP3c(strend, -dontbother, strbeg) - 1;
	    /* for multiline we only have to try after newlines */
	    if (prog->check_substr || prog->check_utf8) {
                /* because of the goto we can not easily reuse the macros for bifurcating the
                   unicode/non-unicode match modes here like we do elsewhere - demerphq */
                if (utf8_target) {
                    if (s == startpos)
                        goto after_try_utf8;
                    while (1) {
                        if (regtry(reginfo, &s)) {
                            goto got_it;
                        }
                      after_try_utf8:
                        if (s > end) {
                            goto phooey;
                        }
                        if (prog->extflags & RXf_USE_INTUIT) {
                            s = re_intuit_start(rx, sv, strbeg,
                                    s + UTF8SKIP(s), strend, flags, NULL);
                            if (!s) {
                                goto phooey;
                            }
                        }
                        else {
                            s += UTF8SKIP(s);
                        }
                    }
                } /* end search for check string in unicode */
                else {
                    if (s == startpos) {
                        goto after_try_latin;
                    }
                    while (1) {
                        if (regtry(reginfo, &s)) {
                            goto got_it;
                        }
                      after_try_latin:
                        if (s > end) {
                            goto phooey;
                        }
                        if (prog->extflags & RXf_USE_INTUIT) {
                            s = re_intuit_start(rx, sv, strbeg,
                                        s + 1, strend, flags, NULL);
                            if (!s) {
                                goto phooey;
                            }
                        }
                        else {
                            s++;
                        }
                    }
                } /* end search for check string in latin*/
	    } /* end search for check string */
	    else { /* search for newline */
		if (s > startpos) {
                    /*XXX: The s-- is almost definitely wrong here under unicode - demeprhq*/
		    s--;
		}
		/* We can use a more efficient search as newlines are the same in unicode as they are in latin */
		while (s <= end) { /* note it could be possible to match at the end of the string */
		    if (*s++ == '\n') {	/* don't need PL_utf8skip here */
			if (regtry(reginfo, &s))
			    goto got_it;
		    }
		}
	    } /* end search for newline */
	} /* end anchored/multiline check string search */
	goto phooey;
    } else if (prog->intflags & PREGf_ANCH_GPOS)
@


1.18
log
@Fix merge issues, remove excess files - match perl-5.20.2 dist
@
text
@d7867 4
d7897 4
d7932 4
@


1.17
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d710 1
d2589 1
a3108 2

    RX_MATCH_UTF8_set(rx, utf8_target);
@


1.16
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@a39 10
/* At least one required character in the target string is expressible only in
 * UTF-8. */
static const char* const non_utf8_target_but_utf8_required
                = "Can't match, because target string needs to be in UTF-8\n";

#define NON_UTF8_TARGET_BUT_UTF8_REQUIRED(target) STMT_START { \
    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "%s", non_utf8_target_but_utf8_required));\
    goto target; \
} STMT_END

d86 12
d104 1
a104 1
/* Valid for non-utf8 strings: avoids the reginclass
d107 1
a107 1
#define REGINCLASS(prog,p,c)  (ANYOF_FLAGS(p) ? reginclass(prog,p,c,0)   \
d115 1
a115 1
#define CHR_DIST(a,b) (PL_reg_match_utf8 ? utf8_distance(a,b) : a - b)
d118 3
a120 2
	(char *)(PL_reg_match_utf8 \
	    ? reghop3((U8*)pos, off, (U8*)(off >= 0 ? PL_regeol : PL_bostr)) \
d122 1
d124 3
a126 3
	(char*)(PL_reg_match_utf8\
	    ? reghopmaybe3((U8*)pos, -off, (U8*)PL_bostr) \
	    : (pos - off >= PL_bostr)		\
d130 1
a130 1
#define HOP3(pos,off,lim) (PL_reg_match_utf8 ? reghop3((U8*)(pos), off, (U8*)(lim)) : (U8*)(pos + off))
d133 18
d156 1
a156 1
    nextchr = ((locinput < PL_regeol) ? UCHARAT(locinput) : NEXTCHR_EOS)
d163 1
a163 1
#define LOAD_UTF8_CHARCLASS(swash_ptr, property_name) STMT_START {            \
d167 1
a167 1
                                         1, 0, NULL, &flags);                 \
d176 1
d178 1
a178 1
        LOAD_UTF8_CHARCLASS(swash_ptr, property_name);                        \
d183 1
d185 1
a185 1
        LOAD_UTF8_CHARCLASS(swash_ptr, property_name)
d190 3
a192 2
                                        swash_property_names[_CC_WORDCHAR],   \
                                        GREEK_SMALL_LETTER_IOTA_UTF8)
d198 2
a199 1
                                       GREEK_SMALL_LETTER_IOTA_UTF8);         \
d202 1
d219 2
a220 2
#define JUMPABLE(rn) (      \
    OP(rn) == OPEN ||       \
d222 5
a226 5
    OP(rn) == EVAL ||   \
    OP(rn) == SUSPEND || OP(rn) == IFMATCH || \
    OP(rn) == PLUS || OP(rn) == MINMOD || \
    OP(rn) == KEEPS || \
    (PL_regkind[OP(rn)] == CURLY && ARG1(rn) > 0) \
d236 1
a236 1
#define IS_TEXTF(rn)  ( OP(rn)==EXACTFU || OP(rn)==EXACTFU_SS || OP(rn)==EXACTFU_TRICKYFOLD || OP(rn)==EXACTFA || OP(rn)==EXACTF || OP(rn)==REFF  || OP(rn)==NREFF )
d242 1
a242 1
#define IS_TEXTFU(rn)  ( OP(rn)==EXACTFU || OP(rn)==EXACTFU_SS || OP(rn)==EXACTFU_TRICKYFOLD || OP(rn) == EXACTFA)
d252 1
a252 1
#define FIND_NEXT_IMPT(rn) STMT_START { \
d275 6
a280 1
static void restore_pos(pTHX_ void *arg);
d303 2
a304 2
	Perl_croak(aTHX_ "panic: paren_elems_to_push, %i < 0",
		   paren_elems_to_push);
d325 2
a326 2
	SSPUSHINT(rex->offs[p].end);
	SSPUSHINT(rex->offs[p].start);
d398 1
a398 1
	I32 tmps;
d400 2
a401 2
	rex->offs[paren].start = SSPOPINT;
	tmps = SSPOPINT;
d513 1
a513 1
                        TWO_BYTE_UTF8_TO_UNI(*character, *(character + 1)));
d521 5
a525 2
            PL_utf8_swash_ptrs[classnum] = _core_swash_init("utf8",
                swash_property_names[classnum], &PL_sv_undef, 1, 0, NULL, &flags);
d558 1
a558 1
	 char *strbeg, I32 minend, SV *screamer, U32 nosave)
d575 53
a627 2
/*
 * Need to implement the following flags for reg_anch:
d629 4
a632 6
 * USE_INTUIT_NOML		- Useful to call re_intuit_start() first
 * USE_INTUIT_ML
 * INTUIT_AUTORITATIVE_NOML	- Can trust a positive answer
 * INTUIT_AUTORITATIVE_ML
 * INTUIT_ONCE_NOML		- Intuit can match in one location only.
 * INTUIT_ONCE_ML
d634 5
a638 2
 * Another flag for this function: SECOND_TIME (so that float substrs
 * with giant delta may be not rechecked).
a640 36
/* Assumptions: if ANCH_GPOS, then strpos is anchored. XXXX Check GPOS logic */

/* If SCREAM, then SvPVX_const(sv) should be compatible with strpos and strend.
   Otherwise, only SvCUR(sv) is used to get strbeg. */

/* XXXX We assume that strpos is strbeg unless sv. */

/* XXXX Some places assume that there is a fixed substring.
	An update may be needed if optimizer marks as "INTUITable"
	RExen without fixed substrings.  Similarly, it is assumed that
	lengths of all the strings are no more than minlen, thus they
	cannot come from lookahead.
	(Or minlen should take into account lookahead.) 
  NOTE: Some of this comment is not correct. minlen does now take account
  of lookahead/behind. Further research is required. -- demerphq

*/

/* A failure to find a constant substring means that there is no need to make
   an expensive call to REx engine, thus we celebrate a failure.  Similarly,
   finding a substring too deep into the string means that fewer calls to
   regtry() should be needed.

   REx compiler's optimizer found 4 possible hints:
	a) Anchored substring;
	b) Fixed substring;
	c) Whether we are anchored (beginning-of-line or \G);
	d) First node (of those at offset 0) which may distinguish positions;
   We use a)b)d) and multiline-part of c), and try to find a position in the
   string which does not contradict any of them.
 */

/* Most of decisions we do here should have been done at compile time.
   The nodes of the REx which we used for the search should have been
   deleted from the finite automaton. */

d642 8
a649 2
Perl_re_intuit_start(pTHX_ REGEXP * const rx, SV *sv, char *strpos,
		     char *strend, const U32 flags, re_scream_pos_data *data)
d653 1
a653 1
    I32 start_shift = 0;
d655 3
a657 2
    I32 end_shift   = 0;
    char *s;
a658 2
    char *strbeg;
    char *t;
d660 3
a662 2
    I32 ml_anch;
    char *other_last = NULL;	/* other substr checked before this */
a663 1
    char *checked_upto = NULL;          /* how far into the string we have already checked using find_byclass*/
d666 2
a667 4
    bool is_utf8_pat;
#ifdef DEBUGGING
    const char * const i_strpos = strpos;
#endif
d674 2
a675 1
    RX_MATCH_UTF8_set(rx,utf8_target);
d677 27
a703 9
    is_utf8_pat = cBOOL(RX_UTF8(rx));

    DEBUG_EXECUTE_r( 
        debug_start_match(rx, utf8_target, strpos, strend,
            sv ? "Guessing start of match in sv for"
               : "Guessing start of match in string for");
	      );

    /* CHR_DIST() would be more correct here but it makes things slow. */
d706 1
a706 1
			      "String too short... [re_intuit_start]\n"));
d710 8
a717 14
    /* XXX we need to pass strbeg as a separate arg: the following is
     * guesswork and can be wrong... */
    if (sv && SvPOK(sv)) {
        char * p   = SvPVX(sv);
        STRLEN cur = SvCUR(sv); 
        if (p <= strpos && strpos < p + cur) {
            strbeg = p;
            assert(p <= strend && strend <= p + cur);
        }
        else
            strbeg = strend - cur;
    }
    else 
        strbeg = strpos;
a718 1
    PL_regeol = strend;
a730 22
    if (prog->extflags & RXf_ANCH) {	/* Match at beg-of-str or after \n */
	ml_anch = !( (prog->extflags & RXf_ANCH_SINGLE)
		     || ( (prog->extflags & RXf_ANCH_BOL)
			  && !multiline ) );	/* Check after \n? */

	if (!ml_anch) {
	  if ( !(prog->extflags & RXf_ANCH_GPOS) /* Checked by the caller */
		&& !(prog->intflags & PREGf_IMPLICIT) /* not a real BOL */
	       /* SvCUR is not set on references: SvRV and SvPVX_const overlap */
	       && sv && !SvROK(sv)
	       && (strpos != strbeg)) {
	      DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "Not at start...\n"));
	      goto fail;
	  }
	  if (prog->check_offset_min == prog->check_offset_max
              && !(prog->extflags & RXf_CANY_SEEN)
              && ! multiline)   /* /m can cause \n's to match that aren't
                                   accounted for in the string max length.
                                   See [perl #115242] */
          {
	    /* Substring at constant offset from beg-of-str... */
	    I32 slen;
d732 70
a801 1
	    s = HOP3c(strpos, prog->check_offset_min, strend);
d803 28
a830 2
	    if (SvTAIL(check)) {
		slen = SvCUR(check);	/* >= 1 */
d832 3
a834 35
		if ( strend - s > slen || strend - s < slen - 1
		     || (strend - s == slen && strend[-1] != '\n')) {
		    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "String too long...\n"));
		    goto fail_finish;
		}
		/* Now should match s[0..slen-2] */
		slen--;
		if (slen && (*SvPVX_const(check) != *s
			     || (slen > 1
				 && memNE(SvPVX_const(check), s, slen)))) {
		  report_neq:
		    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "String not equal...\n"));
		    goto fail_finish;
		}
	    }
	    else if (*SvPVX_const(check) != *s
		     || ((slen = SvCUR(check)) > 1
			 && memNE(SvPVX_const(check), s, slen)))
		goto report_neq;
	    check_at = s;
	    goto success_at_start;
	  }
	}
	/* Match is anchored, but substr is not anchored wrt beg-of-str. */
	s = strpos;
	start_shift = prog->check_offset_min; /* okay to underestimate on CC */
	end_shift = prog->check_end_shift;
	
	if (!ml_anch) {
	    const I32 end = prog->check_offset_max + CHR_SVLEN(check)
					 - (SvTAIL(check) != 0);
	    const I32 eshift = CHR_DIST((U8*)strend, (U8*)s) - end;

	    if (end_shift < eshift)
		end_shift = eshift;
a836 8
    else {				/* Can match at random position */
	ml_anch = 0;
	s = strpos;
	start_shift = prog->check_offset_min;  /* okay to underestimate on CC */
	end_shift = prog->check_end_shift;
	
	/* end shift should be non negative here */
    }
d838 3
a840 1
#ifdef QDEBUGGING	/* 7/99: reports of failure (with the older version) */
a846 2
    /* Find a possible match in the region s..strend by looking for
       the "check" substring in the region corrected by start/end_shift. */
d848 25
a873 2
        I32 srch_start_shift = start_shift;
        I32 srch_end_shift = end_shift;
d876 12
a887 11
        if (srch_start_shift < 0 && strbeg - s > srch_start_shift) {
	    srch_end_shift -= ((strbeg - s) - srch_start_shift); 
	    srch_start_shift = strbeg - s;
	}
    DEBUG_OPTIMISE_MORE_r({
        PerlIO_printf(Perl_debug_log, "Check offset min: %"IVdf" Start shift: %"IVdf" End shift %"IVdf" Real End Shift: %"IVdf"\n",
            (IV)prog->check_offset_min,
            (IV)srch_start_shift,
            (IV)srch_end_shift, 
            (IV)prog->check_end_shift);
    });       
d889 5
a893 3
        if (prog->extflags & RXf_CANY_SEEN) {
            start_point= (U8*)(s + srch_start_shift);
            end_point= (U8*)(strend - srch_end_shift);
d895 4
a898 2
	    start_point= HOP3(s, srch_start_shift, srch_start_shift < 0 ? strbeg : strend);
            end_point= HOP3(strend, -srch_end_shift, strbeg);
d900 30
d931 1
a931 1
            PerlIO_printf(Perl_debug_log, "fbm_instr len=%d str=<%.*s>\n", 
d937 1
a937 1
	s = fbm_instr( start_point, end_point,
d939 28
a967 2
    /* Update the count-of-usability, remove useless subpatterns,
	unshift s.  */
a968 11
    DEBUG_EXECUTE_r({
        RE_PV_QUOTED_DECL(quoted, utf8_target, PERL_DEBUG_PAD_ZERO(0),
            SvPVX_const(check), RE_SV_DUMPLEN(check), 30);
        PerlIO_printf(Perl_debug_log, "%s %s substr %s%s%s",
			  (s ? "Found" : "Did not find"),
	    (check == (utf8_target ? prog->anchored_utf8 : prog->anchored_substr)
	        ? "anchored" : "floating"),
	    quoted,
	    RE_SV_TAIL(check),
	    (s ? " at offset " : "...\n") ); 
    });
d970 1
a970 15
    if (!s)
	goto fail_finish;
    /* Finish the diagnostic message */
    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "%ld...\n", (long)(s - i_strpos)) );

    /* XXX dmq: first branch is for positive lookbehind...
       Our check string is offset from the beginning of the pattern.
       So we need to do any stclass tests offset forward from that 
       point. I think. :-(
     */
    
        
    
    check_at=s;
     
d972 2
a973 10
    /* Got a candidate.  Check MBOL anchoring, and the *other* substr.
       Start with the other substr.
       XXXX no SCREAM optimization yet - and a very coarse implementation
       XXXX /ttx+/ results in anchored="ttx", floating="x".  floating will
		*always* match.  Probably should be marked during compile...
       Probably it is right to do no SCREAM here...
     */

    if (utf8_target ? (prog->float_utf8 && prog->anchored_utf8)
                : (prog->float_substr && prog->anchored_substr)) 
d976 317
a1292 125
	/* XXXX May be hopelessly wrong for UTF... */
	if (!other_last)
	    other_last = strpos;
	if (check == (utf8_target ? prog->float_utf8 : prog->float_substr)) {
	  do_other_anchored:
	    {
		char * const last = HOP3c(s, -start_shift, strbeg);
		char *last1, *last2;
		char * const saved_s = s;
		SV* must;

		t = s - prog->check_offset_max;
		if (s - strpos > prog->check_offset_max  /* signed-corrected t > strpos */
		    && (!utf8_target
			|| ((t = (char*)reghopmaybe3((U8*)s, -(prog->check_offset_max), (U8*)strpos))
			    && t > strpos)))
		    NOOP;
		else
		    t = strpos;
		t = HOP3c(t, prog->anchored_offset, strend);
		if (t < other_last)	/* These positions already checked */
		    t = other_last;
		last2 = last1 = HOP3c(strend, -prog->minlen, strbeg);
		if (last < last1)
		    last1 = last;
                /* XXXX It is not documented what units *_offsets are in.  
                   We assume bytes, but this is clearly wrong. 
                   Meaning this code needs to be carefully reviewed for errors.
                   dmq.
                  */
 
		/* On end-of-str: see comment below. */
		must = utf8_target ? prog->anchored_utf8 : prog->anchored_substr;
		if (must == &PL_sv_undef) {
		    s = (char*)NULL;
		    DEBUG_r(must = prog->anchored_utf8);	/* for debug */
		}
		else
		    s = fbm_instr(
			(unsigned char*)t,
			HOP3(HOP3(last1, prog->anchored_offset, strend)
				+ SvCUR(must), -(SvTAIL(must)!=0), strbeg),
			must,
			multiline ? FBMrf_MULTILINE : 0
		    );
                DEBUG_EXECUTE_r({
                    RE_PV_QUOTED_DECL(quoted, utf8_target, PERL_DEBUG_PAD_ZERO(0),
                        SvPVX_const(must), RE_SV_DUMPLEN(must), 30);
                    PerlIO_printf(Perl_debug_log, "%s anchored substr %s%s",
			(s ? "Found" : "Contradicts"),
                        quoted, RE_SV_TAIL(must));
                });		    
		
			    
		if (!s) {
		    if (last1 >= last2) {
			DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
						", giving up...\n"));
			goto fail_finish;
		    }
		    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
			", trying floating at offset %ld...\n",
			(long)(HOP3c(saved_s, 1, strend) - i_strpos)));
		    other_last = HOP3c(last1, prog->anchored_offset+1, strend);
		    s = HOP3c(last, 1, strend);
		    goto restart;
		}
		else {
		    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, " at offset %ld...\n",
			  (long)(s - i_strpos)));
		    t = HOP3c(s, -prog->anchored_offset, strbeg);
		    other_last = HOP3c(s, 1, strend);
		    s = saved_s;
		    if (t == strpos)
			goto try_at_start;
		    goto try_at_offset;
		}
	    }
	}
	else {		/* Take into account the floating substring. */
	    char *last, *last1;
	    char * const saved_s = s;
	    SV* must;

	    t = HOP3c(s, -start_shift, strbeg);
	    last1 = last =
		HOP3c(strend, -prog->minlen + prog->float_min_offset, strbeg);
	    if (CHR_DIST((U8*)last, (U8*)t) > prog->float_max_offset)
		last = HOP3c(t, prog->float_max_offset, strend);
	    s = HOP3c(t, prog->float_min_offset, strend);
	    if (s < other_last)
		s = other_last;
 /* XXXX It is not documented what units *_offsets are in.  Assume bytes.  */
	    must = utf8_target ? prog->float_utf8 : prog->float_substr;
	    /* fbm_instr() takes into account exact value of end-of-str
	       if the check is SvTAIL(ed).  Since false positives are OK,
	       and end-of-str is not later than strend we are OK. */
	    if (must == &PL_sv_undef) {
		s = (char*)NULL;
		DEBUG_r(must = prog->float_utf8);	/* for debug message */
	    }
	    else
		s = fbm_instr((unsigned char*)s,
			      (unsigned char*)last + SvCUR(must)
				  - (SvTAIL(must)!=0),
			      must, multiline ? FBMrf_MULTILINE : 0);
	    DEBUG_EXECUTE_r({
	        RE_PV_QUOTED_DECL(quoted, utf8_target, PERL_DEBUG_PAD_ZERO(0),
	            SvPVX_const(must), RE_SV_DUMPLEN(must), 30);
	        PerlIO_printf(Perl_debug_log, "%s floating substr %s%s",
		    (s ? "Found" : "Contradicts"),
		    quoted, RE_SV_TAIL(must));
            });
	    if (!s) {
		if (last1 == last) {
		    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
					    ", giving up...\n"));
		    goto fail_finish;
		}
		DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
		    ", trying anchored starting at offset %ld...\n",
		    (long)(saved_s + 1 - i_strpos)));
		other_last = last;
		s = HOP3c(t, 1, strend);
		goto restart;
d1294 26
d1321 44
a1364 8
		DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, " at offset %ld...\n",
		      (long)(s - i_strpos)));
		other_last = s; /* Fix this later. --Hugo */
		s = saved_s;
		if (t == strpos)
		    goto try_at_start;
		goto try_at_offset;
	    }
d1366 14
d1382 1
a1382 14
    
    t= (char*)HOP3( s, -prog->check_offset_max, (prog->check_offset_max<0) ? strend : strpos);
        
    DEBUG_OPTIMISE_MORE_r(
        PerlIO_printf(Perl_debug_log, 
            "Check offset min:%"IVdf" max:%"IVdf" S:%"IVdf" t:%"IVdf" D:%"IVdf" end:%"IVdf"\n",
            (IV)prog->check_offset_min,
            (IV)prog->check_offset_max,
            (IV)(s-strpos),
            (IV)(t-strpos),
            (IV)(t-s),
            (IV)(strend-strpos)
        )
    );
d1384 1
a1384 5
    if (s - strpos > prog->check_offset_max  /* signed-corrected t > strpos */
        && (!utf8_target
	    || ((t = (char*)reghopmaybe3((U8*)s, -prog->check_offset_max, (U8*) ((prog->check_offset_max<0) ? strend : strpos)))
		 && t > strpos))) 
    {
d1387 2
a1388 52
      try_at_offset:
	if (ml_anch && t[-1] != '\n') {
	    /* Eventually fbm_*() should handle this, but often
	       anchored_offset is not 0, so this check will not be wasted. */
	    /* XXXX In the code below we prefer to look for "^" even in
	       presence of anchored substrings.  And we search even
	       beyond the found float position.  These pessimizations
	       are historical artefacts only.  */
	  find_anchor:
	    while (t < strend - prog->minlen) {
		if (*t == '\n') {
		    if (t < check_at - prog->check_offset_min) {
			if (utf8_target ? prog->anchored_utf8 : prog->anchored_substr) {
			    /* Since we moved from the found position,
			       we definitely contradict the found anchored
			       substr.  Due to the above check we do not
			       contradict "check" substr.
			       Thus we can arrive here only if check substr
			       is float.  Redo checking for "other"=="fixed".
			     */
			    strpos = t + 1;			
			    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "Found /%s^%s/m at offset %ld, rescanning for anchored from offset %ld...\n",
				PL_colors[0], PL_colors[1], (long)(strpos - i_strpos), (long)(strpos - i_strpos + prog->anchored_offset)));
			    goto do_other_anchored;
			}
			/* We don't contradict the found floating substring. */
			/* XXXX Why not check for STCLASS? */
			s = t + 1;
			DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "Found /%s^%s/m at offset %ld...\n",
			    PL_colors[0], PL_colors[1], (long)(s - i_strpos)));
			goto set_useful;
		    }
		    /* Position contradicts check-string */
		    /* XXXX probably better to look for check-string
		       than for "\n", so one should lower the limit for t? */
		    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "Found /%s^%s/m, restarting lookup for check-string at offset %ld...\n",
			PL_colors[0], PL_colors[1], (long)(t + 1 - i_strpos)));
		    other_last = strpos = s = t + 1;
		    goto restart;
		}
		t++;
	    }
	    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "Did not find /%s^%s/m...\n",
			PL_colors[0], PL_colors[1]));
	    goto fail_finish;
	}
	else {
	    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "Starting position does not contradict /%s^%s/m...\n",
			PL_colors[0], PL_colors[1]));
	}
	s = t;
      set_useful:
d1392 5
a1396 21
	/* The found string does not prohibit matching at strpos,
	   - no optimization of calling REx engine can be performed,
	   unless it was an MBOL and we are not after MBOL,
	   or a future STCLASS check will fail this. */
      try_at_start:
	/* Even in this situation we may use MBOL flag if strpos is offset
	   wrt the start of the string. */
	if (ml_anch && sv && !SvROK(sv)	/* See prev comment on SvROK */
	    && (strpos != strbeg) && strpos[-1] != '\n'
	    /* May be due to an implicit anchor of m{.*foo}  */
	    && !(prog->intflags & PREGf_IMPLICIT))
	{
	    t = strpos;
	    goto find_anchor;
	}
	DEBUG_EXECUTE_r( if (ml_anch)
	    PerlIO_printf(Perl_debug_log, "Position at offset %ld does not contradict /%s^%s/m...\n",
			  (long)(strpos - i_strpos), PL_colors[0], PL_colors[1]);
	);
      success_at_start:
	if (!(prog->intflags & PREGf_NAUGHTY)	/* XXXX If strpos moved? */
d1408 1
a1408 1
	    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "... Disabling check substring...\n"));
a1414 5
	    s = strpos;
	    /* XXXX If the check string was an implicit check MBOL, then we need to unset the relevant flag
		    see http://bugs.activestate.com/show_bug.cgi?id=87173 */
	    if (prog->intflags & PREGf_IMPLICIT)
		prog->extflags &= ~RXf_ANCH_MBOL;
a1418 1
	    /* XXXX What other flags might need to be cleared in this branch? */
a1419 2
	else
	    s = strpos;
d1422 5
a1426 118
    /* Last resort... */
    /* XXXX BmUSEFUL already changed, maybe multiple change is meaningful... */
    /* trie stclasses are too expensive to use here, we are better off to
       leave it to regmatch itself */
    if (progi->regstclass && PL_regkind[OP(progi->regstclass)]!=TRIE) {
	/* minlen == 0 is possible if regstclass is \b or \B,
	   and the fixed substr is ''$.
	   Since minlen is already taken into account, s+1 is before strend;
	   accidentally, minlen >= 1 guaranties no false positives at s + 1
	   even for \b or \B.  But (minlen? 1 : 0) below assumes that
	   regstclass does not come from lookahead...  */
	/* If regstclass takes bytelength more than 1: If charlength==1, OK.
	   This leaves EXACTF-ish only, which are dealt with in find_byclass().  */
        const U8* const str = (U8*)STRING(progi->regstclass);
        const int cl_l = (PL_regkind[OP(progi->regstclass)] == EXACT
		    ? CHR_DIST(str+STR_LEN(progi->regstclass), str)
		    : 1);
	char * endpos;
	if (prog->anchored_substr || prog->anchored_utf8 || ml_anch)
            endpos= HOP3c(s, (prog->minlen ? cl_l : 0), strend);
        else if (prog->float_substr || prog->float_utf8)
	    endpos= HOP3c(HOP3c(check_at, -start_shift, strbeg), cl_l, strend);
        else 
            endpos= strend;
		    
        if (checked_upto < s)
           checked_upto = s;
        DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "start_shift: %"IVdf" check_at: %"IVdf" s: %"IVdf" endpos: %"IVdf" checked_upto: %"IVdf"\n",
                                      (IV)start_shift, (IV)(check_at - strbeg), (IV)(s - strbeg), (IV)(endpos - strbeg), (IV)(checked_upto- strbeg)));

	t = s;
        s = find_byclass(prog, progi->regstclass, checked_upto, endpos,
                            NULL, is_utf8_pat);
	if (s) {
	    checked_upto = s;
	} else {
#ifdef DEBUGGING
	    const char *what = NULL;
#endif
	    if (endpos == strend) {
		DEBUG_EXECUTE_r( PerlIO_printf(Perl_debug_log,
				"Could not match STCLASS...\n") );
		goto fail;
	    }
	    DEBUG_EXECUTE_r( PerlIO_printf(Perl_debug_log,
				   "This position contradicts STCLASS...\n") );
	    if ((prog->extflags & RXf_ANCH) && !ml_anch)
		goto fail;
	    checked_upto = HOPBACKc(endpos, start_shift);
	    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "start_shift: %"IVdf" check_at: %"IVdf" endpos: %"IVdf" checked_upto: %"IVdf"\n",
                                      (IV)start_shift, (IV)(check_at - strbeg), (IV)(endpos - strbeg), (IV)(checked_upto- strbeg)));
	    /* Contradict one of substrings */
	    if (prog->anchored_substr || prog->anchored_utf8) {
		if ((utf8_target ? prog->anchored_utf8 : prog->anchored_substr) == check) {
		    DEBUG_EXECUTE_r( what = "anchored" );
		  hop_and_restart:
		    s = HOP3c(t, 1, strend);
		    if (s + start_shift + end_shift > strend) {
			/* XXXX Should be taken into account earlier? */
			DEBUG_EXECUTE_r( PerlIO_printf(Perl_debug_log,
					       "Could not match STCLASS...\n") );
			goto fail;
		    }
		    if (!check)
			goto giveup;
		    DEBUG_EXECUTE_r( PerlIO_printf(Perl_debug_log,
				"Looking for %s substr starting at offset %ld...\n",
				 what, (long)(s + start_shift - i_strpos)) );
		    goto restart;
		}
		/* Have both, check_string is floating */
		if (t + start_shift >= check_at) /* Contradicts floating=check */
		    goto retry_floating_check;
		/* Recheck anchored substring, but not floating... */
		s = check_at;
		if (!check)
		    goto giveup;
		DEBUG_EXECUTE_r( PerlIO_printf(Perl_debug_log,
			  "Looking for anchored substr starting at offset %ld...\n",
			  (long)(other_last - i_strpos)) );
		goto do_other_anchored;
	    }
	    /* Another way we could have checked stclass at the
               current position only: */
	    if (ml_anch) {
		s = t = t + 1;
		if (!check)
		    goto giveup;
		DEBUG_EXECUTE_r( PerlIO_printf(Perl_debug_log,
			  "Looking for /%s^%s/m starting at offset %ld...\n",
			  PL_colors[0], PL_colors[1], (long)(t - i_strpos)) );
		goto try_at_offset;
	    }
	    if (!(utf8_target ? prog->float_utf8 : prog->float_substr))	/* Could have been deleted */
		goto fail;
	    /* Check is floating substring. */
	  retry_floating_check:
	    t = check_at - start_shift;
	    DEBUG_EXECUTE_r( what = "floating" );
	    goto hop_and_restart;
	}
	if (t != s) {
            DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
			"By STCLASS: moving %ld --> %ld\n",
                                  (long)(t - i_strpos), (long)(s - i_strpos))
                   );
        }
        else {
            DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
                                  "Does not contradict STCLASS...\n"); 
                   );
        }
    }
  giveup:
    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "%s%s:%s match at offset %ld\n",
			  PL_colors[4], (check ? "Guessed" : "Giving up"),
			  PL_colors[5], (long)(s - i_strpos)) );
    return s;
d1437 1
d1439 2
a1440 1
    const enum { trie_plain, trie_utf8, trie_utf8_fold, trie_latin_utf8_fold } \
d1443 3
a1445 1
                              : (utf8_target ? trie_utf8_fold : trie_latin_utf8_fold))
d1448 1
a1448 1
STMT_START {                               \
d1450 1
d1452 3
d1457 1
a1457 1
            uvc = utf8n_to_uvuni( (const U8*) uscan, UTF8_MAXLEN, &len, uniflags ); \
d1462 1
a1462 1
            uvc = to_utf8_fold( (const U8*) uc, foldbuf, &foldlen );                \
d1469 3
d1474 1
a1474 1
            uvc = utf8n_to_uvuni( (const U8*) uscan, UTF8_MAXLEN, &len, uniflags ); \
d1480 1
a1480 1
            uvc = _to_fold_latin1( (U8) *uc, foldbuf, &foldlen, 1);                 \
d1487 1
a1487 1
        uvc = utf8n_to_uvuni( (const U8*) uc, UTF8_MAXLEN, &len, uniflags );        \
d1512 1
a1512 1
	     && (!reginfo || regtry(reginfo, &s)) )       \
d1537 1
a1537 1
	if (tmp && (!reginfo || regtry(reginfo, &s))) \
d1549 1
a1549 1
	if (tmp && (!reginfo || regtry(reginfo, &s)))  \
d1558 2
a1559 2
#define REXEC_FBC_TRYIT               \
if ((!reginfo || regtry(reginfo, &s))) \
d1563 1
a1563 1
    if (utf8_target) {                                             \
d1570 3
a1572 2
#define DUMP_EXEC_POS(li,s,doutf8) \
    dump_exec_pos(li,s,(PL_regeol),(PL_bostr),(PL_reg_starttry),doutf8)
d1575 2
a1576 2
#define UTF8_NOLOAD(TEST_NON_UTF8, IF_SUCCESS, IF_FAIL) \
	tmp = (s != PL_bostr) ? UCHARAT(s - 1) : '\n';                         \
d1579 1
a1579 1
	    if (tmp == ! TEST_NON_UTF8((U8) *s)) { \
d1588 2
a1589 2
#define UTF8_LOAD(TeSt1_UtF8, TeSt2_UtF8, IF_SUCCESS, IF_FAIL) \
	if (s == PL_bostr) {                                                   \
d1593 3
a1595 2
	    U8 * const r = reghop3((U8*)s, -1, (U8*)PL_bostr);                 \
	    tmp = utf8n_to_uvchr(r, UTF8SKIP(r), 0, UTF8_ALLOW_DEFAULT);       \
d1598 1
a1598 1
	LOAD_UTF8_CHARCLASS_ALNUM();                                                                \
d1600 1
a1600 1
	    if (tmp == ! (TeSt2_UtF8)) { \
d1635 1
a1635 1
#define FBC_BOUND_COMMON(UTF8_CODE, TEST_NON_UTF8, IF_SUCCESS, IF_FAIL) \
d1637 1
a1637 1
		UTF8_CODE \
d1640 1
a1640 1
	tmp = (s != PL_bostr) ? UCHARAT(s - 1) : '\n';                         \
d1652 1
a1652 1
    if ((!prog->minlen && tmp) && (!reginfo || regtry(reginfo, &s)))           \
d1656 1
a1656 1
/* if reginfo is NULL, its a dryrun */
d1662 1
a1662 1
    const char *strend, regmatch_info *reginfo, bool is_utf8_pat)
d1676 1
a1676 1
    const bool utf8_target = PL_reg_match_utf8;
d1678 1
a1690 2
    case ANYOF_SYNTHETIC:
    case ANYOF_WARN_SUPER:
d1693 1
a1693 1
                      reginclass(prog, c, (U8*)s, utf8_target));
d1701 1
a1701 1
            if (tmp && (!reginfo || regtry(reginfo, &s)))
d1708 3
d1720 2
a1721 1
    case EXACTF:
a1722 2

            /* regcomp.c already folded this if pattern is in UTF-8 */
d1731 2
a1732 2
        if (is_utf8_pat || utf8_target) {
            utf8_fold_flags = FOLDEQ_UTF8_LOCALE;
a1744 1
    case EXACTFU_TRICKYFOLD:
d1777 1
a1777 1
        e = HOP3c(strend, -((I32)ln), s);
d1779 1
a1779 1
        if (!reginfo && e < s) {
d1823 1
a1823 1
        e = HOP3c(strend, -((I32)lnc), s);
d1825 1
a1825 1
        if (!reginfo && e < s) {
d1840 1
a1840 1
                && (!reginfo || regtry(reginfo, &s)) )
a1848 1
        RXp_MATCH_TAINTED_on(prog);
d1850 1
a1850 1
                  isWORDCHAR_LC_uvchr(UNI_TO_NATIVE(tmp)),
a1853 1
        RXp_MATCH_TAINTED_on(prog);
d1855 1
a1855 1
                   isWORDCHAR_LC_uvchr(UNI_TO_NATIVE(tmp)),
a1901 1
        RXp_MATCH_TAINTED_on(prog);
d1965 2
a1966 1
                                _generic_isCC(TWO_BYTE_UTF8_TO_UNI(*s, *(s + 1)),
d1969 1
a1969 1
                        if (tmp && (!reginfo || regtry(reginfo, &s)))
d2024 4
a2027 2
                    _core_swash_init("utf8", swash_property_names[classnum],
                                     &PL_sv_undef, 1, 0, NULL, &flags);
d2241 1
a2241 1
                    if (!reginfo || regtry(reginfo, &s)) {
d2269 150
d2425 1
a2425 1
	      char *strbeg, I32 minend, SV *sv, void *data, U32 flags)
d2433 2
a2434 3
              Currently its only used, with a U32 cast, for transmitting
              the ganch offset when doing a /g match. This will change */
/* nosave:    For optimizations. */
d2441 3
a2443 6
    char *startpos = stringarg;
    I32 minlen;		/* must match at least this many chars */
    I32 dontbother = 0;	/* how many characters not to try at end */
    I32 end_shift = 0;			/* Same for the end. */		/* CC */
    I32 scream_pos = -1;		/* Internal iterator of scream. */
    char *scream_olds = NULL;
d2447 83
a2529 3
    regmatch_info reginfo;  /* create some info to pass to regtry etc */
    regexp_paren_pair *swap = NULL;
    GET_RE_DEBUG_FLAGS_DECL;
d2531 38
a2568 2
    PERL_ARGS_ASSERT_REGEXEC_FLAGS;
    PERL_UNUSED_ARG(data);
d2570 2
a2571 4
    /* Be paranoid... */
    if (prog == NULL || startpos == NULL) {
	Perl_croak(aTHX_ "NULL regexp parameter");
	return 0;
a2574 9
    reginfo.prog = rx;	 /* Yes, sorry that this is confusing.  */

    RX_MATCH_UTF8_set(rx, utf8_target);
    DEBUG_EXECUTE_r( 
        debug_start_match(rx, utf8_target, startpos, strend,
        "Matching");
    );

    minlen = prog->minlen;
d2576 1
a2576 1
    if (strend - startpos < (minlen+(prog->check_offset_min<0?prog->check_offset_min:0))) {
a2580 1

a2587 2
    PL_reg_state.re_state_eval_setup_done = FALSE;
    PL_reg_maxiter = 0;
d2589 62
a2650 6
    reginfo.is_utf8_pat = cBOOL(RX_UTF8(rx));
    reginfo.warned = FALSE;
    /* Mark beginning of line for ^ and lookbehind. */
    reginfo.bol = startpos; /* XXX not used ??? */
    PL_bostr  = strbeg;
    reginfo.sv = sv;
d2652 3
a2654 2
    /* Mark end of line for $ (and such) */
    PL_regeol = strend;
d2656 7
a2662 2
    /* see how far we have to get to not match where we matched before */
    reginfo.till = startpos+minend;
a2664 1
    s = startpos;
a2665 35
    if (prog->extflags & RXf_GPOS_SEEN) { /* Need to set reginfo->ganch */
	MAGIC *mg;
	if (flags & REXEC_IGNOREPOS){	/* Means: check only at start */
	    reginfo.ganch = startpos + prog->gofs;
	    DEBUG_GPOS_r(PerlIO_printf(Perl_debug_log,
	      "GPOS IGNOREPOS: reginfo.ganch = startpos + %"UVxf"\n",(UV)prog->gofs));
	} else if (sv && SvTYPE(sv) >= SVt_PVMG
		  && SvMAGIC(sv)
		  && (mg = mg_find(sv, PERL_MAGIC_regex_global))
		  && mg->mg_len >= 0) {
	    reginfo.ganch = strbeg + mg->mg_len;	/* Defined pos() */
	    DEBUG_GPOS_r(PerlIO_printf(Perl_debug_log,
		"GPOS MAGIC: reginfo.ganch = strbeg + %"IVdf"\n",(IV)mg->mg_len));

	    if (prog->extflags & RXf_ANCH_GPOS) {
	        if (s > reginfo.ganch)
		    goto phooey;
		s = reginfo.ganch - prog->gofs;
	        DEBUG_GPOS_r(PerlIO_printf(Perl_debug_log,
		     "GPOS ANCH_GPOS: s = ganch - %"UVxf"\n",(UV)prog->gofs));
		if (s < strbeg)
		    goto phooey;
	    }
	}
	else if (data) {
	    reginfo.ganch = strbeg + PTR2UV(data);
            DEBUG_GPOS_r(PerlIO_printf(Perl_debug_log,
		 "GPOS DATA: reginfo.ganch= strbeg + %"UVxf"\n",PTR2UV(data)));

	} else {				/* pos() not defined */
	    reginfo.ganch = strbeg;
            DEBUG_GPOS_r(PerlIO_printf(Perl_debug_log,
		 "GPOS: reginfo.ganch = strbeg\n"));
	}
    }
a2683 13
    if (!(flags & REXEC_CHECKED) && (prog->check_substr != NULL || prog->check_utf8 != NULL)) {
	re_scream_pos_data d;

	d.scream_olds = &scream_olds;
	d.scream_pos = &scream_pos;
	s = re_intuit_start(rx, sv, s, strend, flags, &d);
	if (!s) {
	    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "Not present...\n"));
	    goto phooey;	/* not present */
	}
    }


d2687 2
a2688 2
    if (prog->extflags & (RXf_ANCH & ~RXf_ANCH_GPOS)) {
	if (s == startpos && regtry(&reginfo, &startpos))
d2690 1
a2690 2
	else if (multiline || (prog->intflags & PREGf_IMPLICIT)
		 || (prog->extflags & RXf_ANCH_MBOL)) /* XXXX SBOL? */
d2705 1
a2705 1
                        if (regtry(&reginfo, &s)) {
d2713 2
a2714 1
                            s = re_intuit_start(rx, sv, s + UTF8SKIP(s), strend, flags, NULL);
d2729 1
a2729 1
                        if (regtry(&reginfo, &s)) {
d2737 2
a2738 1
                            s = re_intuit_start(rx, sv, s + 1, strend, flags, NULL);
d2757 1
a2757 1
			if (regtry(&reginfo, &s))
d2764 1
a2764 1
    } else if (RXf_GPOS_CHECK == (prog->extflags & RXf_GPOS_CHECK)) 
d2766 7
a2772 6
        /* the warning about reginfo.ganch being used without initialization
           is bogus -- we set it above, when prog->extflags & RXf_GPOS_SEEN 
           and we only enter this block when the same bit is set. */
        char *tmp_s = reginfo.ganch - prog->gofs;

	if (tmp_s >= strbeg && regtry(&reginfo, &tmp_s))
d2793 1
a2793 1
		    if (regtry(&reginfo, &s)) goto got_it;
d2811 1
a2811 1
		    if (regtry(&reginfo, &s)) goto got_it;
d2828 2
a2829 2
	I32 back_max;
	I32 back_min;
d2874 1
a2874 1
        	  -(I32)(CHR_SVLEN(must)
d2877 1
a2877 1
	if (s > PL_bostr)
d2884 1
a2884 2
	scream_pos = -1;
	dontbother = end_shift;
d2887 1
a2887 1
		(s = fbm_instr((unsigned char*)HOP3(s, back_min, (back_min<0 ? strbeg : strend)),
d2896 2
a2897 1
		char * const t = (last1 >= PL_bostr) ? HOPc(last1, 1) : last1 + 1;
d2904 1
a2904 1
		    if (regtry(&reginfo, &s))
d2915 1
a2915 1
		    if (regtry(&reginfo, &s))
d2940 1
a2940 1
	    regprop(prog, prop, c);
d2950 1
a2950 1
        if (find_byclass(prog, c, s, strend, &reginfo, reginfo.is_utf8_pat))
d3058 1
a3058 1
		if (regtry(&reginfo, &s))
d3067 1
a3067 1
		if (regtry(&reginfo, &s))
d3077 12
d3099 6
a3104 2
    if (PL_reg_state.re_state_eval_setup_done)
	restore_pos(aTHX_ prog);
d3108 2
d3111 4
a3114 115
    if ( !(flags & REXEC_NOT_FIRST) ) {
	if (flags & REXEC_COPY_STR) {
#ifdef PERL_ANY_COW
	    if (SvCANCOW(sv)) {
		if (DEBUG_C_TEST) {
		    PerlIO_printf(Perl_debug_log,
				  "Copy on write: regexp capture, type %d\n",
				  (int) SvTYPE(sv));
		}
                RX_MATCH_COPY_FREE(rx);
		prog->saved_copy = sv_setsv_cow(prog->saved_copy, sv);
		prog->subbeg = (char *)SvPVX_const(prog->saved_copy);
		assert (SvPOKp(prog->saved_copy));
                prog->sublen  = PL_regeol - strbeg;
                prog->suboffset = 0;
                prog->subcoffset = 0;
	    } else
#endif
	    {
                I32 min = 0;
                I32 max = PL_regeol - strbeg;
                I32 sublen;

                if (    (flags & REXEC_COPY_SKIP_POST)
                    && !(RX_EXTFLAGS(rx) & RXf_PMf_KEEPCOPY) /* //p */
                    && !(PL_sawampersand & SAWAMPERSAND_RIGHT)
                ) { /* don't copy $' part of string */
                    U32 n = 0;
                    max = -1;
                    /* calculate the right-most part of the string covered
                     * by a capture. Due to look-ahead, this may be to
                     * the right of $&, so we have to scan all captures */
                    while (n <= prog->lastparen) {
                        if (prog->offs[n].end > max)
                            max = prog->offs[n].end;
                        n++;
                    }
                    if (max == -1)
                        max = (PL_sawampersand & SAWAMPERSAND_LEFT)
                                ? prog->offs[0].start
                                : 0;
                    assert(max >= 0 && max <= PL_regeol - strbeg);
                }

                if (    (flags & REXEC_COPY_SKIP_PRE)
                    && !(RX_EXTFLAGS(rx) & RXf_PMf_KEEPCOPY) /* //p */
                    && !(PL_sawampersand & SAWAMPERSAND_LEFT)
                ) { /* don't copy $` part of string */
                    U32 n = 0;
                    min = max;
                    /* calculate the left-most part of the string covered
                     * by a capture. Due to look-behind, this may be to
                     * the left of $&, so we have to scan all captures */
                    while (min && n <= prog->lastparen) {
                        if (   prog->offs[n].start != -1
                            && prog->offs[n].start < min)
                        {
                            min = prog->offs[n].start;
                        }
                        n++;
                    }
                    if ((PL_sawampersand & SAWAMPERSAND_RIGHT)
                        && min >  prog->offs[0].end
                    )
                        min = prog->offs[0].end;

                }

                assert(min >= 0 && min <= max && min <= PL_regeol - strbeg);
                sublen = max - min;

                if (RX_MATCH_COPIED(rx)) {
                    if (sublen > prog->sublen)
                        prog->subbeg =
                                (char*)saferealloc(prog->subbeg, sublen+1);
                }
                else
                    prog->subbeg = (char*)safemalloc(sublen+1);
                Copy(strbeg + min, prog->subbeg, sublen, char);
                prog->subbeg[sublen] = '\0';
                prog->suboffset = min;
                prog->sublen = sublen;
                RX_MATCH_COPIED_on(rx);
	    }
            prog->subcoffset = prog->suboffset;
            if (prog->suboffset && utf8_target) {
                /* Convert byte offset to chars.
                 * XXX ideally should only compute this if @@-/@@+
                 * has been seen, a la PL_sawampersand ??? */

                /* If there's a direct correspondence between the
                 * string which we're matching and the original SV,
                 * then we can use the utf8 len cache associated with
                 * the SV. In particular, it means that under //g,
                 * sv_pos_b2u() will use the previously cached
                 * position to speed up working out the new length of
                 * subcoffset, rather than counting from the start of
                 * the string each time. This stops
                 *   $x = "\x{100}" x 1E6; 1 while $x =~ /(.)/g;
                 * from going quadratic */
                if (SvPOKp(sv) && SvPVX(sv) == strbeg)
                    sv_pos_b2u(sv, &(prog->subcoffset));
                else
                    prog->subcoffset = utf8_length((U8*)strbeg,
                                        (U8*)(strbeg+prog->suboffset));
            }
	}
	else {
            RX_MATCH_COPY_FREE(rx);
	    prog->subbeg = strbeg;
	    prog->suboffset = 0;
	    prog->subcoffset = 0;
	    prog->sublen = PL_regeol - strbeg;	/* strend may have been modified */
	}
    }
d3121 7
a3127 2
    if (PL_reg_state.re_state_eval_setup_done)
	restore_pos(aTHX_ prog);
d3143 1
a3143 1
/* Set which rex is pointed to by PL_reg_state, handling ref counting.
d3145 2
a3146 2
#define SET_reg_curpm(Re2) \
    if (PL_reg_state.re_state_eval_setup_done) {    \
d3163 1
a3163 1
    I32 result;
d3171 1
a3171 68
    if ((prog->extflags & RXf_EVAL_SEEN)
	&& !PL_reg_state.re_state_eval_setup_done)
    {
	MAGIC *mg;

	PL_reg_state.re_state_eval_setup_done = TRUE;
	if (reginfo->sv) {
	    /* Make $_ available to executed code. */
	    if (reginfo->sv != DEFSV) {
		SAVE_DEFSV;
		DEFSV_set(reginfo->sv);
	    }
	
	    if (!(SvTYPE(reginfo->sv) >= SVt_PVMG && SvMAGIC(reginfo->sv)
		  && (mg = mg_find(reginfo->sv, PERL_MAGIC_regex_global)))) {
		/* prepare for quick setting of pos */
#ifdef PERL_OLD_COPY_ON_WRITE
		if (SvIsCOW(reginfo->sv))
		    sv_force_normal_flags(reginfo->sv, 0);
#endif
		mg = sv_magicext(reginfo->sv, NULL, PERL_MAGIC_regex_global,
				 &PL_vtbl_mglob, NULL, 0);
		mg->mg_len = -1;
	    }
	    PL_reg_magic    = mg;
	    PL_reg_oldpos   = mg->mg_len;
	    SAVEDESTRUCTOR_X(restore_pos, prog);
        }
        if (!PL_reg_curpm) {
	    Newxz(PL_reg_curpm, 1, PMOP);
#ifdef USE_ITHREADS
            {
		SV* const repointer = &PL_sv_undef;
                /* this regexp is also owned by the new PL_reg_curpm, which
		   will try to free it.  */
                av_push(PL_regex_padav, repointer);
                PL_reg_curpm->op_pmoffset = av_len(PL_regex_padav);
                PL_regex_pad = AvARRAY(PL_regex_padav);
            }
#endif      
        }
	SET_reg_curpm(rx);
	PL_reg_oldcurpm = PL_curpm;
	PL_curpm = PL_reg_curpm;
	if (RXp_MATCH_COPIED(prog)) {
	    /*  Here is a serious problem: we cannot rewrite subbeg,
		since it may be needed if this match fails.  Thus
		$` inside (?{}) could fail... */
	    PL_reg_oldsaved = prog->subbeg;
	    PL_reg_oldsavedlen = prog->sublen;
	    PL_reg_oldsavedoffset = prog->suboffset;
	    PL_reg_oldsavedcoffset = prog->suboffset;
#ifdef PERL_ANY_COW
	    PL_nrs = prog->saved_copy;
#endif
	    RXp_MATCH_COPIED_off(prog);
	}
	else
	    PL_reg_oldsaved = NULL;
	prog->subbeg = PL_bostr;
	prog->suboffset = 0;
	prog->subcoffset = 0;
	prog->sublen = PL_regeol - PL_bostr; /* strend may have been modified */
    }
#ifdef DEBUGGING
    PL_reg_starttry = *startposp;
#endif
    prog->offs[0].start = *startposp - PL_bostr;
d3220 1
a3220 1
       PL_reg_poscache[ST.cache_offset] |= ST.cache_mask; \
a3234 3
#define SLAB_FIRST(s) (&(s)->states[0])
#define SLAB_LAST(s)  (&(s)->states[PERL_REGMATCH_SLAB_SLOTS-1])

d3410 1
a3410 1
	DUMP_EXEC_POS(locinput, scan, utf8_target);		    \
d3414 1
a3414 1
	    PL_reg_name[st->resume_state],                     \
a3549 17
/* free all slabs above current one  - called during LEAVE_SCOPE */

STATIC void
S_clear_backtrack_stack(pTHX_ void *p)
{
    regmatch_slab *s = PL_regmatch_slab->next;
    PERL_UNUSED_ARG(p);

    if (!s)
	return;
    PL_regmatch_slab->next = NULL;
    while (s) {
	regmatch_slab * const osl = s;
	s = s->next;
	Safefree(osl);
    }
}
d3552 1
a3552 1
        U8* c1_utf8, int *c2p, U8* c2_utf8, bool is_utf8_pat)
d3604 1
a3604 1
    const bool utf8_target = PL_reg_match_utf8;
d3609 1
d3618 1
d3638 15
a3652 47
    else /* an EXACTFish node */
         if ((is_utf8_pat
                    && is_MULTI_CHAR_FOLD_utf8_safe(pat,
                                                    pat + STR_LEN(text_node)))
             || (!is_utf8_pat
                    && is_MULTI_CHAR_FOLD_latin1_safe(pat,
                                                    pat + STR_LEN(text_node))))
    {
        /* Multi-character folds require more context to sort out.  Also
         * PL_utf8_foldclosures used below doesn't handle them, so have to be
         * handled outside this routine */
        use_chrtest_void = TRUE;
    }
    else { /* an EXACTFish node which doesn't begin with a multi-char fold */
        c1 = is_utf8_pat ? valid_utf8_to_uvchr(pat, NULL) : *pat;
        if (c1 > 256) {
            /* Load the folds hash, if not already done */
            SV** listp;
            if (! PL_utf8_foldclosures) {
                if (! PL_utf8_tofold) {
                    U8 dummy[UTF8_MAXBYTES+1];

                    /* Force loading this by folding an above-Latin1 char */
                    to_utf8_fold((U8*) HYPHEN_UTF8, dummy, NULL);
                    assert(PL_utf8_tofold); /* Verify that worked */
                }
                PL_utf8_foldclosures = _swash_inversion_hash(PL_utf8_tofold);
            }

            /* The fold closures data structure is a hash with the keys being
             * the UTF-8 of every character that is folded to, like 'k', and
             * the values each an array of all code points that fold to its
             * key.  e.g. [ 'k', 'K', KELVIN_SIGN ].  Multi-character folds are
             * not included */
            if ((! (listp = hv_fetch(PL_utf8_foldclosures,
                                     (char *) pat,
                                     UTF8SKIP(pat),
                                     FALSE))))
            {
                /* Not found in the hash, therefore there are no folds
                 * containing it, so there is only a single character that
                 * could match */
                c2 = c1;
            }
            else {  /* Does participate in folds */
                AV* list = (AV*) *listp;
                if (av_len(list) != 1) {
d3654 6
a3659 3
                    /* If there aren't exactly two folds to this, it is outside
                     * the scope of this function */
                    use_chrtest_void = TRUE;
d3661 19
a3679 31
                else {  /* There are two.  Get them */
                    SV** c_p = av_fetch(list, 0, FALSE);
                    if (c_p == NULL) {
                        Perl_croak(aTHX_ "panic: invalid PL_utf8_foldclosures structure");
                    }
                    c1 = SvUV(*c_p);

                    c_p = av_fetch(list, 1, FALSE);
                    if (c_p == NULL) {
                        Perl_croak(aTHX_ "panic: invalid PL_utf8_foldclosures structure");
                    }
                    c2 = SvUV(*c_p);

                    /* Folds that cross the 255/256 boundary are forbidden if
                     * EXACTFL, or EXACTFA and one is ASCIII.  Since the
                     * pattern character is above 256, and its only other match
                     * is below 256, the only legal match will be to itself.
                     * We have thrown away the original, so have to compute
                     * which is the one above 255 */
                    if ((c1 < 256) != (c2 < 256)) {
                        if (OP(text_node) == EXACTFL
                            || (OP(text_node) == EXACTFA
                                && (isASCII(c1) || isASCII(c2))))
                        {
                            if (c1 < 256) {
                                c1 = c2;
                            }
                            else {
                                c2 = c1;
                            }
                        }
d3682 3
d3687 3
a3689 5
        else /* Here, c1 is < 255 */
             if (utf8_target
                 && HAS_NONLATIN1_FOLD_CLOSURE(c1)
                 && OP(text_node) != EXACTFL
                 && (OP(text_node) != EXACTFA || ! isASCII(c1)))
d3691 81
a3771 7
            /* Here, there could be something above Latin1 in the target which
             * folds to this character in the pattern.  All such cases except
             * LATIN SMALL LETTER Y WITH DIAERESIS have more than two characters
             * involved in their folds, so are outside the scope of this
             * function */
            if (UNLIKELY(c1 == LATIN_SMALL_LETTER_Y_WITH_DIAERESIS)) {
                c2 = LATIN_CAPITAL_LETTER_Y_WITH_DIAERESIS;
d3773 19
a3791 2
            else {
                use_chrtest_void = TRUE;
d3793 3
a3795 3
        }
        else { /* Here nothing above Latin1 can fold to the pattern character */
            switch (OP(text_node)) {
d3797 3
a3799 3
                case EXACTFL:   /* /l rules */
                    c2 = PL_fold_locale[c1];
                    break;
d3801 18
a3818 3
                case EXACTF:
                    if (! utf8_target) {    /* /d rules */
                        c2 = PL_fold[c1];
a3819 10
                    }
                    /* FALLTHROUGH */
                    /* /u rules for all these.  This happens to work for
                     * EXACTFA as nothing in Latin1 folds to ASCII */
                case EXACTFA:
                case EXACTFU_TRICKYFOLD:
                case EXACTFU_SS:
                case EXACTFU:
                    c2 = PL_fold_latin1[c1];
                    break;
d3821 4
a3824 3
		default:
                    Perl_croak(aTHX_ "panic: Unexpected op %u", OP(text_node));
                    assert(0); /* NOTREACHED */
d3866 1
a3866 1
STATIC I32
d3873 1
a3873 1
    const bool utf8_target = PL_reg_match_utf8;
a3877 1
    I32	oldsave;
d3884 1
a3884 1
    I32 ln = 0; /* len or last;  init to avoid compiler warning */
d3912 1
a3912 1
    SV* const oreplsv = GvSV(PL_replgv);
d3942 3
a3957 7
    /* on first ever call to regmatch, allocate first slab */
    if (!PL_regmatch_slab) {
	Newx(PL_regmatch_slab, 1, regmatch_slab);
	PL_regmatch_slab->prev = NULL;
	PL_regmatch_slab->next = NULL;
	PL_regmatch_state = SLAB_FIRST(PL_regmatch_slab);
    }
d3959 1
a3959 9
    oldsave = PL_savestack_ix;
    SAVEDESTRUCTOR_X(S_clear_backtrack_stack, NULL);
    SAVEVPTR(PL_regmatch_slab);
    SAVEVPTR(PL_regmatch_state);

    /* grab next free state slot */
    st = ++PL_regmatch_state;
    if (st >  SLAB_LAST(PL_regmatch_slab))
	st = PL_regmatch_state = S_push_slab(aTHX);
d3970 1
a3970 1
	    regprop(rex, prop, scan);
d3992 3
a3994 4
	case BOL: /*  /^../  */
	    if (locinput == PL_bostr)
	    {
		/* reginfo->till = reginfo->bol; */
a3995 1
	    }
d3999 1
a3999 1
	    if (locinput == PL_bostr ||
a4005 5
	case SBOL: /*  /^../s  */
	    if (locinput == PL_bostr)
		break;
	    sayNO;

d4014 1
a4014 1
	    rex->offs[0].start = locinput - PL_bostr;
a4022 3
	case EOL: /* /..$/  */
		goto seol;

d4028 2
a4030 1
	  seol:
d4033 1
a4033 1
	    if (PL_regeol - locinput > 1)
d4171 1
a4171 1
		while ( state && uc <= (U8*)PL_regeol ) {
d4205 1
a4205 1
		    if ( base && (foldlen || uc < (U8*)PL_regeol)) {
d4328 1
a4328 1
			    uvc = utf8n_to_uvuni((U8*)uc, UTF8_MAXLEN, &len,
d4341 1
a4341 1
			    uvc = utf8n_to_uvuni(uscan, UTF8_MAXLEN, &len,
d4420 3
a4422 1
			if (l >= PL_regeol || UTF8_IS_ABOVE_LATIN1(* (U8*) l)) {
d4432 2
a4433 1
                            if (TWO_BYTE_UTF8_TO_UNI(*l, *(l+1)) != * (U8*) s) {
d4444 2
a4445 1
                        if (l >= PL_regeol || UTF8_IS_ABOVE_LATIN1(* (U8*) s))
d4456 2
a4457 1
                            if (TWO_BYTE_UTF8_TO_UNI(*s, *(s+1)) != * (U8*) l) {
d4470 1
a4470 1
                if (PL_regeol - locinput < ln
a4486 1
            RX_MATCH_TAINTED_on(reginfo->prog);
d4489 1
a4489 1
	    fold_utf8_flags = FOLDEQ_UTF8_LOCALE;
a4492 1
	case EXACTFU_TRICKYFOLD: /*  /\x{390}/iu  */
d4499 4
d4509 3
a4511 1
	case EXACTF:             /*  /abc/i       */
d4520 5
a4524 1
	    if (utf8_target || is_utf8_pat || state_num == EXACTFU_SS) {
d4528 1
a4528 1
		char *e = PL_regeol;
d4546 1
a4546 1
	    if (PL_regeol - locinput < ln)
a4558 2
            RX_MATCH_TAINTED_on(reginfo->prog);
	    /* FALL THROUGH */
d4570 1
a4570 1
		if (locinput == PL_bostr)
d4573 2
a4574 1
		    const U8 * const r = reghop3((U8*)locinput, -1, (U8*)PL_bostr);
d4576 2
a4577 1
		    ln = utf8n_to_uvchr(r, UTF8SKIP(r), 0, uniflags);
d4590 1
a4590 1
		    ln = isWORDCHAR_LC_uvchr(UNI_TO_NATIVE(ln));
d4607 1
a4607 1
		ln = (locinput != PL_bostr) ?
a4638 1
	case ANYOF_WARN_SUPER:
d4642 2
a4643 1
	        if (!reginclass(rex, scan, (U8*)locinput, utf8_target))
a4664 4
            /* The locale hasn't influenced the outcome before this, so defer
             * tainting until now */
            RX_MATCH_TAINTED_on(reginfo->prog);

d4675 1
a4675 1
                                        (U8) TWO_BYTE_UTF8_TO_UNI(nextchr,
d4756 1
a4756 1
                       ^ cBOOL(_generic_isCC(TWO_BYTE_UTF8_TO_UNI(nextchr,
d4758 1
a4758 1
                                              FLAGS(scan)))))
d4774 3
a4776 2
                                        swash_property_names[classnum],
                                        &PL_sv_undef, 1, 0, NULL, &flags);
d4873 1
a4873 1
		    && locinput < PL_regeol
d4882 2
a4883 2
		 * PL_regeol, so locinput+1 is in bounds */
		if ( nextchr == '\r' && locinput+1 < PL_regeol
d4900 1
a4900 1
                    while (locinput < PL_regeol
d4911 1
a4911 1
			&& (locinput >=  PL_regeol
d4920 1
a4920 1
		    /* Note that here we know PL_regeol > locinput, as we
d4943 1
a4943 1
                            while (locinput < PL_regeol
d4951 1
a4951 1
                            while (locinput < PL_regeol
d4964 1
a4964 1
                            while (locinput < PL_regeol
d4976 1
a4976 1
                            if (locinput < PL_regeol
d4994 1
a4994 1
                                    while (locinput < PL_regeol
d5003 1
a5003 1
                                while (locinput < PL_regeol
d5013 1
a5013 1
                    while (locinput < PL_regeol
d5021 1
a5021 1
		if (locinput > PL_regeol) sayNO;
d5032 1
a5032 1
	    char *s;
a5037 1
            RX_MATCH_TAINTED_on(reginfo->prog);
d5041 1
a5041 1
	    utf8_fold_flags = FOLDEQ_UTF8_LOCALE;
a5081 1
            RX_MATCH_TAINTED_on(reginfo->prog);
d5084 1
a5084 1
	    utf8_fold_flags = FOLDEQ_UTF8_LOCALE;
d5116 1
a5116 1
	    PL_reg_leftiter = PL_reg_maxiter;		/* Void cache */
d5122 1
a5122 1
	    s = PL_bostr + ln;
d5124 3
a5126 3
		&& (utf8_target || type == REFFU))
	    { /* XXX handle REFFL better */
		char * limit = PL_regeol;
d5130 3
a5132 3
		    * not going off the end given by PL_regeol, and returns in
		    * <limit> upon success, how much of the current input was
		    * matched */
d5149 1
a5149 1
	    if (locinput + ln > PL_regeol)
d5199 6
d5206 1
a5223 2
		char *saved_regeol = PL_regeol;
		struct re_save_state saved_state;
a5229 16
		/* To not corrupt the existing regex state while executing the
		 * eval we would normally put it on the save stack, like with
		 * save_re_context. However, re-evals have a weird scoping so we
		 * can't just add ENTER/LEAVE here. With that, things like
		 *
		 *    (?{$a=2})(a(?{local$a=$a+1}))*aak*c(?{$b=$a})
		 *
		 * would break, as they expect the localisation to be unwound
		 * only when the re-engine backtracks through the bit that
		 * localised it.
		 *
		 * What we do instead is just saving the state in a local c
		 * variable.
		 */
		Copy(&PL_reg_state, &saved_state, 1, struct re_save_state);

d5316 5
a5320 1
		rex->offs[0].end = PL_reg_magic->mg_len = locinput - PL_bostr;
d5358 2
d5366 2
a5367 2
			else if (SvSMAGICAL(sv)) {
			    MAGIC *mg = mg_find(sv, PERL_MAGIC_qr);
d5372 2
a5373 2
			/* force any magic, undef warnings here */
			if (!re_sv) {
a5380 2
		Copy(&saved_state, &PL_reg_state, 1, struct re_save_state);

a5386 1
		PL_regeol = saved_regeol;
d5388 1
d5427 2
a5428 2
			      & (SVs_TEMP | SVs_PADTMP | SVf_READONLY
				 | SVs_GMG))) {
a5433 4
			/* safe to do now that any $1 etc has been
			 * interpolated into the new pattern string and
			 * compiled */
			S_regcp_restore(aTHX_ rex, runops_cp, &maxopenparen);
d5443 2
d5447 2
a5448 2
                    debug_start_match(re_sv, utf8_target, locinput, PL_regeol,
                        "Matching embedded");
d5452 20
d5473 2
a5474 17
        eval_recurse_doit: /* Share code with GOSUB below this line */                		
		/* run the pattern returned from (??{...}) */

                /* Save *all* the positions. */
		ST.cp = regcppush(rex, 0, maxopenparen);
		REGCP_SET(ST.lastcp);
		
		re->lastparen = 0;
		re->lastcloseparen = 0;

		maxopenparen = 0;

		/* XXXX This is too dramatic a measure... */
		PL_reg_maxiter = 0;

		ST.saved_utf8_pat = is_utf8_pat;
		is_utf8_pat = cBOOL(RX_UTF8(re_sv));
a5492 1
            is_utf8_pat = ST.saved_utf8_pat;
d5494 1
d5498 8
a5505 1
	    regcpblow(ST.cp);
d5509 2
a5510 2
	    /* XXXX This is too dramatic a measure... */
	    PL_reg_maxiter = 0;
a5517 1
            is_utf8_pat = ST.saved_utf8_pat;
d5519 1
d5528 2
a5529 2
	    /* XXXX This is too dramatic a measure... */
	    PL_reg_maxiter = 0;
d5537 1
a5537 1
	    rex->offs[n].start_tmp = locinput - PL_bostr;
d5554 1
a5554 1
    rex->offs[n].end = locinput - PL_bostr; \
d5619 1
a5619 1
	    PL_reg_leftiter = PL_reg_maxiter;		/* Void cache */
d5807 31
a5837 1
	    /* super-linear cache processing */
d5841 1
a5841 1
		if (!PL_reg_maxiter) {
d5844 3
a5846 1
		    PL_reg_maxiter = (PL_regeol - PL_bostr + 1) * (scan->flags>>4);
d5848 3
a5850 3
		    if (PL_reg_maxiter < 0)
			PL_reg_maxiter = I32_MAX;
		    PL_reg_leftiter = PL_reg_maxiter;
d5853 1
a5853 1
		if (PL_reg_leftiter-- == 0) {
d5855 6
a5860 5
		    const I32 size = (PL_reg_maxiter + 7)/8;
		    if (PL_reg_poscache) {
			if ((I32)PL_reg_poscache_size < size) {
			    Renew(PL_reg_poscache, size, char);
			    PL_reg_poscache_size = size;
d5862 1
a5862 1
			Zero(PL_reg_poscache, size, char);
d5865 2
a5866 2
			PL_reg_poscache_size = size;
			Newxz(PL_reg_poscache, size, char);
d5874 1
a5874 1
		if (PL_reg_leftiter < 0) {
d5876 3
a5878 1
		    I32 offset, mask;
d5880 2
a5881 1
		  		+ (locinput - PL_bostr)  * (scan->flags>>4);
d5884 1
a5884 1
		    if (PL_reg_poscache[offset] & mask) {
d6119 1
a6119 1
		if (PL_reg_match_utf8) {
d6179 1
a6179 1
                           is_utf8_pat))
d6201 1
a6201 1
                                "%*s  CURLYM Fast bail next target=U+%"UVXf" c1=U+%"UVXf" c2=U+%"UVXf"\n",
d6215 1
a6215 1
                            "%*s  CURLYM Fast bail next target=U+%X c1=U+%X c2=U+%X\n",
d6229 2
a6230 2
			= HOPc(locinput, -ST.alen) - PL_bostr;
		    rex->offs[paren].end = locinput - PL_bostr;
d6272 2
a6273 2
	    rex->offs[paren].start = HOPc(locinput, -1) - PL_bostr; \
	    rex->offs[paren].end = locinput - PL_bostr; \
d6356 1
a6356 1
                           is_utf8_pat))
d6370 1
a6370 1
                        regrepeat(rex, &li, ST.A, ST.min, depth, is_utf8_pat)
d6384 1
a6384 1
		    ST.maxpos = PL_regeol - 1;
d6392 1
a6392 1
			 m >0 && ST.maxpos < PL_regeol; m--)
d6397 2
a6398 2
		    if (ST.maxpos >= PL_regeol)
			ST.maxpos = PL_regeol - 1;
d6407 1
a6407 2
		ST.count = regrepeat(rex, &li, ST.A, ST.max, depth,
                                        is_utf8_pat);
d6491 1
a6491 1
		    if (regrepeat(rex, &li, ST.A, n, depth, is_utf8_pat) < n)
d6515 1
a6515 1
                if (!regrepeat(rex, &li, ST.A, 1, depth, is_utf8_pat)) {
d6545 1
a6545 1
		bool could_match = locinput < PL_regeol;
a6589 2
                st->u.eval.saved_utf8_pat = is_utf8_pat;
		is_utf8_pat = cur_eval->u.eval.saved_utf8_pat;
d6596 1
d6625 2
a6626 2
				      (long)(locinput - PL_reg_starttry),
				      (long)(reginfo->till - PL_reg_starttry),
d6718 1
a6718 1
	    reginfo->cutpoint = PL_regeol;
d6818 1
a6818 1
            if ((n=is_LNBREAK_safe(locinput, PL_regeol, utf8_target))) {
d6836 1
a6836 1
                if (locinput > PL_regeol)
d6948 1
a6948 1
    if (PL_reg_state.re_state_eval_setup_done) {
d6954 4
d7024 2
a7025 5
    /* clean up; in particular, free all slabs above current one */
    LEAVE_SCOPE(oldsave);

    assert(!result ||  locinput - PL_bostr >= 0);
    return result ?  locinput - PL_bostr : -1;
d7038 1
d7044 1
a7044 1
                I32 max, int depth, bool is_utf8_pat)
d7049 1
a7049 1
    char *loceol = PL_regeol;   /* local version */
d7051 1
a7051 1
    bool utf8_target = PL_reg_match_utf8;
d7123 1
a7123 1
        assert(STR_LEN(p) == is_utf8_pat ? UTF8SKIP(STRING(p)) : 1);
d7131 1
a7131 1
        if (UTF8_IS_INVARIANT(c) || (! utf8_target && ! is_utf8_pat)) {
d7141 1
a7141 1
	else if (is_utf8_pat) {
d7160 1
a7160 1
                c = TWO_BYTE_UTF8_TO_UNI(c, *(STRING(p) + 1));
d7187 3
d7191 1
a7191 1
	utf8_flags = FOLDEQ_UTF8_NOMIX_ASCII;
d7195 1
a7195 2
        RXp_MATCH_TAINTED_on(prog);
	utf8_flags = FOLDEQ_UTF8_LOCALE;
d7198 4
a7201 3
    case EXACTF:
	    utf8_flags = 0;
	    goto do_exactf;
a7203 1
    case EXACTFU_TRICKYFOLD:
d7205 1
a7205 1
	utf8_flags = is_utf8_pat ? FOLDEQ_S2_ALREADY_FOLDED : 0;
d7211 1
a7211 1
        assert(STR_LEN(p) == is_utf8_pat ? UTF8SKIP(STRING(p)) : 1);
d7214 1
a7214 1
                                        is_utf8_pat))
d7218 2
a7219 2
                char *tmpeol = PL_regeol;
                STRLEN pat_len = is_utf8_pat ? UTF8SKIP(STRING(p)) : 1;
d7223 1
a7223 1
                                             is_utf8_pat, utf8_flags))
d7226 1
a7226 1
                    tmpeol = PL_regeol;
a7266 1
    case ANYOF_WARN_SUPER:
d7270 1
a7270 1
		   && reginclass(prog, p, (U8*)scan, utf8_target))
a7287 1
        RXp_MATCH_TAINTED_on(prog);
d7387 2
a7388 2
                              ^ cBOOL(_generic_isCC(TWO_BYTE_UTF8_TO_UNI(*scan,
                                                                   *(scan + 1)),
d7470 4
a7473 2
                                        "utf8", swash_property_names[classnum],
                                        &PL_sv_undef, 1, 0, NULL, &flags);
d7500 1
a7500 1
            loceol = PL_regeol;
d7541 1
a7541 1
	    regprop(prog, prop, p);
d7567 1
a7567 1
    return newSVsv(core_regclass_swash(prog, node, doinit, listsvp));
a7568 1
#endif
d7570 6
a7575 2
STATIC SV *
S_core_regclass_swash(pTHX_ const regexp *prog, const regnode* node, bool doinit, SV** listsvp)
d7577 3
a7579 2
    /* Returns the swash for the input 'node' in the regex 'prog'.
     * If <doinit> is true, will attempt to create the swash if not already
d7581 5
a7585 2
     * If <listsvp> is non-null, will return the swash initialization string in
     *	  it.
d7590 1
a7590 1
    SV *si  = NULL;
d7596 1
a7596 1
    PERL_ARGS_ASSERT_CORE_REGCLASS_SWASH;
d7598 2
a7599 1
    assert(ANYOF_NONBITMAP(node));
d7612 2
a7613 2
	    /* Elements 2 and 3 are either both present or both absent. [2] is
	     * any inversion list generated at compile time; [3] indicates if
d7615 19
a7633 4
	    if (av_len(av) >= 2) {
		invlist = ary[2];
		if (SvUV(ary[3])) {
                    swash_init_flags |= _CORE_SWASH_INIT_USER_DEFINED_PROPERTY;
a7635 3
	    else {
		invlist = NULL;
	    }
d7639 1
a7639 1
	    if (SvROK(ary[1])) {
d7642 2
a7643 1
	    else if (si && doinit) {
d7657 1
d7661 5
a7665 2
	/* Use the swash, if any, which has to have incorporated into it all
	 * possibilities */
a7668 2

	    /* If no swash, use the input initialization string, if available */
d7682 1
d7689 1
d7701 1
a7701 1
S_reginclass(pTHX_ regexp * const prog, const regnode * const n, const U8* const p, const bool utf8_target)
d7714 1
a7714 1
	c = utf8n_to_uvchr(p, UTF8_MAXBYTES, &c_len,
d7727 1
a7727 1
	else if (flags & ANYOF_NON_UTF8_LATIN1_ALL
d7733 7
a7739 9
	else if (flags & ANYOF_LOCALE) {
	    RXp_MATCH_TAINTED_on(prog);

	    if ((flags & ANYOF_LOC_FOLD)
		 && ANYOF_BITMAP_TEST(n, PL_fold_locale[c]))
	    {
		match = TRUE;
	    }
	    else if (ANYOF_CLASS_TEST_ANY_SET(n)) {
d7773 1
d7775 1
a7775 1
                    if (ANYOF_CLASS_TEST(n, count)
d7788 1
d7790 1
a7790 8
     * bitmap could match, try that.  Locale nodes specify completely the
     * behavior of code points in the bit map (otherwise, a utf8 target would
     * cause them to be treated as Unicode and not locale), except in
     * the very unlikely event when this node is a synthetic start class, which
     * could be a combination of locale and non-locale nodes.  So allow locale
     * to match for the synthetic start class, which will give a false
     * positive that will be resolved when the match is done again as not part
     * of the synthetic start class */
d7792 1
a7792 1
	if (utf8_target && (flags & ANYOF_UNICODE_ALL) && c >= 256) {
d7795 9
a7803 8
	else if (ANYOF_NONBITMAP(n)
		 && ((flags & ANYOF_NONBITMAP_NON_UTF8)
		     || (utf8_target
		         && (c >=256
			     || (! (flags & ANYOF_LOCALE))
			     || OP(n) == ANYOF_SYNTHETIC))))
	{
	    SV * const sw = core_regclass_swash(prog, n, TRUE, 0);
d7820 3
d7826 1
a7826 1
            && OP(n) == ANYOF_WARN_SUPER
d7830 1
a7830 1
                "Code point 0x%04"UVXf" is not Unicode, all \\p{} matches fail; all \\P{} matches succeed", c);
d7834 6
d7841 1
a7841 1
    return cBOOL(flags & ANYOF_INVERT) ^ match;
d7845 1
a7845 1
S_reghop3(U8 *s, I32 off, const U8* lim)
a7873 5
#ifdef XXX_dmq
/* there are a bunch of places where we use two reghop3's that should
   be replaced with this routine. but since thats not done yet 
   we ifdef it out - dmq
*/
d7875 1
a7875 1
S_reghop4(U8 *s, I32 off, const U8* llim, const U8* rlim)
d7899 3
a7901 1
#endif
d7904 1
a7904 1
S_reghopmaybe3(U8* s, I32 off, const U8* lim)
d7933 88
d8022 1
a8022 1
restore_pos(pTHX_ void *arg)
d8025 16
a8040 7
    regexp * const rex = (regexp *)arg;
    if (PL_reg_state.re_state_eval_setup_done) {
	if (PL_reg_oldsaved) {
	    rex->subbeg = PL_reg_oldsaved;
	    rex->sublen = PL_reg_oldsavedlen;
	    rex->suboffset = PL_reg_oldsavedoffset;
	    rex->subcoffset = PL_reg_oldsavedcoffset;
d8042 1
a8042 1
	    rex->saved_copy = PL_nrs;
d8044 29
a8072 6
	    RXp_MATCH_COPIED_on(rex);
	}
	PL_reg_magic->mg_len = PL_reg_oldpos;
	PL_reg_state.re_state_eval_setup_done = FALSE;
	PL_curpm = PL_reg_oldcurpm;
    }	
d8074 1
@


1.15
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d40 10
d93 2
a94 6
#define RF_tainted	1	/* tainted information used? e.g. locale */
#define RF_warned	2		/* warned about big count? */

#define RF_utf8		8		/* Pattern contains multibyte chars? */

#define UTF_PATTERN ((PL_reg_flags & RF_utf8) != 0)
d96 1
a96 2
#define RS_init		1		/* eval environment created */
#define RS_set		2		/* replsv value is set */
d102 1
a102 1
/* Valid for non-utf8 strings, non-ANYOFV nodes only: avoids the reginclass
d105 1
a105 1
#define REGINCLASS(prog,p,c)  (ANYOF_FLAGS(p) ? reginclass(prog,p,c,0,0)   \
d129 28
a156 5
/* these are unrolled below in the CCC_TRY_XXX defined */
#ifdef EBCDIC
    /* Often 'str' is a hard-coded utf8 string instead of utfebcdic. so just
     * skip the check on EBCDIC platforms */
#   define LOAD_UTF8_CHARCLASS(class,str) LOAD_UTF8_CHARCLASS_NO_CHECK(class)
d158 4
a161 6
#   define LOAD_UTF8_CHARCLASS(class,str) STMT_START { \
    if (!CAT2(PL_utf8_,class)) { \
	bool ok; \
	ENTER; save_re_context(); \
	ok=CAT2(is_utf8_,class)((const U8*)str); \
	assert(ok); assert(CAT2(PL_utf8_,class)); LEAVE; } } STMT_END
d164 14
a177 28
/* Doesn't do an assert to verify that is correct */
#define LOAD_UTF8_CHARCLASS_NO_CHECK(class) STMT_START { \
    if (!CAT2(PL_utf8_,class)) { \
	bool throw_away PERL_UNUSED_DECL; \
	ENTER; save_re_context(); \
	throw_away = CAT2(is_utf8_,class)((const U8*)" "); \
	LEAVE; } } STMT_END

#define LOAD_UTF8_CHARCLASS_ALNUM() LOAD_UTF8_CHARCLASS(alnum,"a")
#define LOAD_UTF8_CHARCLASS_DIGIT() LOAD_UTF8_CHARCLASS(digit,"0")
#define LOAD_UTF8_CHARCLASS_SPACE() LOAD_UTF8_CHARCLASS(space," ")

#define LOAD_UTF8_CHARCLASS_GCB()  /* Grapheme cluster boundaries */        \
	LOAD_UTF8_CHARCLASS(X_begin, " ");                                  \
	LOAD_UTF8_CHARCLASS(X_non_hangul, "A");                             \
	/* These are utf8 constants, and not utf-ebcdic constants, so the   \
	    * assert should likely and hopefully fail on an EBCDIC machine */ \
	LOAD_UTF8_CHARCLASS(X_extend, "\xcc\x80"); /* U+0300 */             \
									    \
	/* No asserts are done for these, in case called on an early        \
	    * Unicode version in which they map to nothing */               \
	LOAD_UTF8_CHARCLASS_NO_CHECK(X_prepend);/* U+0E40 "\xe0\xb9\x80" */ \
	LOAD_UTF8_CHARCLASS_NO_CHECK(X_L);	    /* U+1100 "\xe1\x84\x80" */ \
	LOAD_UTF8_CHARCLASS_NO_CHECK(X_LV);     /* U+AC00 "\xea\xb0\x80" */ \
	LOAD_UTF8_CHARCLASS_NO_CHECK(X_LVT);    /* U+AC01 "\xea\xb0\x81" */ \
	LOAD_UTF8_CHARCLASS_NO_CHECK(X_LV_LVT_V);/* U+AC01 "\xea\xb0\x81" */\
	LOAD_UTF8_CHARCLASS_NO_CHECK(X_T);      /* U+11A8 "\xe1\x86\xa8" */ \
	LOAD_UTF8_CHARCLASS_NO_CHECK(X_V)       /* U+1160 "\xe1\x85\xa0" */  
a179 109

/* The actual code for CCC_TRY, which uses several variables from the routine
 * it's callable from.  It is designed to be the bulk of a case statement.
 * FUNC is the macro or function to call on non-utf8 targets that indicate if
 *      nextchr matches the class.
 * UTF8_TEST is the whole test string to use for utf8 targets
 * LOAD is what to use to test, and if not present to load in the swash for the
 *	class
 * POS_OR_NEG is either empty or ! to complement the results of FUNC or
 *	UTF8_TEST test.
 * The logic is: Fail if we're at the end-of-string; otherwise if the target is
 * utf8 and a variant, load the swash if necessary and test using the utf8
 * test.  Advance to the next character if test is ok, otherwise fail; If not
 * utf8 or an invariant under utf8, use the non-utf8 test, and fail if it
 * fails, or advance to the next character */

#define _CCC_TRY_CODE(POS_OR_NEG, FUNC, UTF8_TEST, CLASS, STR)                \
    if (locinput >= PL_regeol) {                                              \
	sayNO;                                                                \
    }                                                                         \
    if (utf8_target && UTF8_IS_CONTINUED(nextchr)) {                          \
	LOAD_UTF8_CHARCLASS(CLASS, STR);                                      \
	if (POS_OR_NEG (UTF8_TEST)) {                                         \
	    sayNO;                                                            \
	}                                                                     \
	locinput += PL_utf8skip[nextchr];                                     \
	nextchr = UCHARAT(locinput);                                          \
	break;                                                                \
    }                                                                         \
    if (POS_OR_NEG (FUNC(nextchr))) {                                         \
	sayNO;                                                                \
    }                                                                         \
    nextchr = UCHARAT(++locinput);                                            \
    break;

/* Handle the non-locale cases for a character class and its complement.  It
 * calls _CCC_TRY_CODE with a ! to complement the test for the character class.
 * This is because that code fails when the test succeeds, so we want to have
 * the test fail so that the code succeeds.  The swash is stored in a
 * predictable PL_ place */
#define _CCC_TRY_NONLOCALE(NAME,  NNAME,  FUNC,                               \
	                   CLASS, STR)                                        \
    case NAME:                                                                \
	_CCC_TRY_CODE( !, FUNC,                                               \
		          cBOOL(swash_fetch(CAT2(PL_utf8_,CLASS),             \
			                    (U8*)locinput, TRUE)),            \
		          CLASS, STR)                                         \
    case NNAME:                                                               \
	_CCC_TRY_CODE(  PLACEHOLDER , FUNC,                                   \
		          cBOOL(swash_fetch(CAT2(PL_utf8_,CLASS),             \
			                    (U8*)locinput, TRUE)),            \
		          CLASS, STR)                                         \

/* Generate the case statements for both locale and non-locale character
 * classes in regmatch for classes that don't have special unicode semantics.
 * Locales don't use an immediate swash, but an intermediary special locale
 * function that is called on the pointer to the current place in the input
 * string.  That function will resolve to needing the same swash.  One might
 * think that because we don't know what the locale will match, we shouldn't
 * check with the swash loading function that it loaded properly; ie, that we
 * should use LOAD_UTF8_CHARCLASS_NO_CHECK for those, but what is passed to the
 * regular LOAD_UTF8_CHARCLASS is in non-locale terms, and so locale is
 * irrelevant here */
#define CCC_TRY(NAME,  NNAME,  FUNC,                                          \
	        NAMEL, NNAMEL, LCFUNC, LCFUNC_utf8,                           \
	        NAMEA, NNAMEA, FUNCA,                                         \
		CLASS, STR)                                                   \
    case NAMEL:                                                               \
	PL_reg_flags |= RF_tainted;                                           \
	_CCC_TRY_CODE( !, LCFUNC, LCFUNC_utf8((U8*)locinput), CLASS, STR)     \
    case NNAMEL:                                                              \
	PL_reg_flags |= RF_tainted;                                           \
	_CCC_TRY_CODE( PLACEHOLDER, LCFUNC, LCFUNC_utf8((U8*)locinput),       \
		       CLASS, STR)                                            \
    case NAMEA:                                                               \
	if (locinput >= PL_regeol || ! FUNCA(nextchr)) {                      \
	    sayNO;                                                            \
	}                                                                     \
	/* Matched a utf8-invariant, so don't have to worry about utf8 */     \
	nextchr = UCHARAT(++locinput);                                        \
	break;                                                                \
    case NNAMEA:                                                              \
	if (locinput >= PL_regeol || FUNCA(nextchr)) {                        \
	    sayNO;                                                            \
	}                                                                     \
	if (utf8_target) {                                                    \
	    locinput += PL_utf8skip[nextchr];                                 \
	    nextchr = UCHARAT(locinput);                                      \
	}                                                                     \
	else {                                                                \
	    nextchr = UCHARAT(++locinput);                                    \
	}                                                                     \
	break;                                                                \
    /* Generate the non-locale cases */                                       \
    _CCC_TRY_NONLOCALE(NAME, NNAME, FUNC, CLASS, STR)

/* This is like CCC_TRY, but has an extra set of parameters for generating case
 * statements to handle separate Unicode semantics nodes */
#define CCC_TRY_U(NAME,  NNAME,  FUNC,                                         \
		  NAMEL, NNAMEL, LCFUNC, LCFUNC_utf8,                          \
	          NAMEU, NNAMEU, FUNCU,                                        \
	          NAMEA, NNAMEA, FUNCA,                                        \
	          CLASS, STR)                                                  \
    CCC_TRY(NAME, NNAME, FUNC,                                                 \
	    NAMEL, NNAMEL, LCFUNC, LCFUNC_utf8,                                \
	    NAMEA, NNAMEA, FUNCA,                                              \
	    CLASS, STR)                                                        \
    _CCC_TRY_NONLOCALE(NAMEU, NNAMEU, FUNCU, CLASS, STR)

d238 9
d250 2
a251 2
#define REGCP_PAREN_ELEMS 4
#define REGCP_OTHER_ELEMS 5
d257 1
a257 1
S_regcppush(pTHX_ I32 parenfloor)
d261 2
a262 1
    const int paren_elems_to_push = (PL_regsize - parenfloor) * REGCP_PAREN_ELEMS;
d265 1
a265 1
    int p;
d268 2
d277 3
a279 1
		   total_elems, (unsigned long)PL_regsize, (long)parenfloor);
d283 9
a291 1
    for (p = PL_regsize; p > parenfloor; p--) {
d293 3
a295 4
	SSPUSHINT(PL_regoffs[p].end);
	SSPUSHINT(PL_regoffs[p].start);
	SSPUSHPTR(PL_reg_start_tmp[p]);
	SSPUSHINT(p);
d297 5
a301 4
	  "     saving \\%"UVuf" %"IVdf"(%"IVdf")..%"IVdf"\n",
		      (UV)p, (IV)PL_regoffs[p].start,
		      (IV)(PL_reg_start_tmp[p] - PL_bostr),
		      (IV)PL_regoffs[p].end
d305 3
a307 5
    SSPUSHPTR(PL_regoffs);
    SSPUSHINT(PL_regsize);
    SSPUSHINT(*PL_reglastparen);
    SSPUSHINT(*PL_reglastcloseparen);
    SSPUSHPTR(PL_reginput);
d329 9
a337 2
STATIC char *
S_regcppop(pTHX_ const regexp *rex)
d341 1
a341 1
    char *input;
d350 3
a352 5
    input = (char *) SSPOPPTR;
    *PL_reglastcloseparen = SSPOPINT;
    *PL_reglastparen = SSPOPINT;
    PL_regsize = SSPOPINT;
    PL_regoffs=(regexp_paren_pair *) SSPOPPTR;
d356 9
d367 2
a368 3
	U32 paren = (U32)SSPOPINT;
	PL_reg_start_tmp[paren] = (char *) SSPOPPTR;
	PL_regoffs[paren].start = SSPOPINT;
d370 9
a378 9
	if (paren <= *PL_reglastparen)
	    PL_regoffs[paren].end = tmps;
	DEBUG_BUFFERS_r(
	    PerlIO_printf(Perl_debug_log,
			  "     restoring \\%"UVuf" to %"IVdf"(%"IVdf")..%"IVdf"%s\n",
			  (UV)paren, (IV)PL_regoffs[paren].start,
			  (IV)(PL_reg_start_tmp[paren] - PL_bostr),
			  (IV)PL_regoffs[paren].end,
			  (paren > *PL_reglastparen ? "(no)" : ""));
d380 1
a381 7
    DEBUG_BUFFERS_r(
	if (*PL_reglastparen + 1 <= rex->nparens) {
	    PerlIO_printf(Perl_debug_log,
			  "     restoring \\%"IVdf"..\\%"IVdf" to undef\n",
			  (IV)(*PL_reglastparen + 1), (IV)rex->nparens);
	}
    );
d392 9
a400 4
    for (i = *PL_reglastparen + 1; i <= rex->nparens; i++) {
	if (i > PL_regsize)
	    PL_regoffs[i].start = -1;
	PL_regoffs[i].end = -1;
d403 12
a414 1
    return input;
d419 94
d522 1
a522 1
Perl_pregexec(pTHX_ REGEXP * const prog, char* stringarg, register char *strend,
d524 7
a530 4
/* strend: pointer to null at end of string */
/* strbeg: real beginning of string */
/* minend: end of match must be >=minend after stringarg. */
/* nosave: For optimizations. */
d574 1
a574 1
   finding a substring too deep into the string means that less calls to
d595 2
a596 2
    struct regexp *const prog = (struct regexp *)SvANY(rx);
    register I32 start_shift = 0;
d598 3
a600 3
    register I32 end_shift   = 0;
    register char *s;
    register SV *check;
d605 1
a605 1
    register char *other_last = NULL;	/* other substr checked before this */
d607 1
d610 1
d617 2
d622 2
a623 3
    if (RX_UTF8(rx)) {
	PL_reg_flags |= RF_utf8;
    }
d636 16
a651 2
                
    strbeg = (sv && SvPOK(sv)) ? strend - SvCUR(sv) : strpos;
d658 5
a662 2
	if (!prog->check_substr && prog->check_utf8)
	    to_byte_substr(prog);
a664 5
    if (check == &PL_sv_undef) {
	DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
		"Non-utf8 string cannot match utf8 check string\n"));
	goto fail;
    }
d679 6
a684 2
	  if (prog->check_offset_min == prog->check_offset_max &&
	      !(prog->extflags & RXf_CANY_SEEN)) {
d752 2
a765 36
    if ((flags & REXEC_SCREAM) && SvSCREAM(sv)) {
	I32 p = -1;			/* Internal iterator of scream. */
	I32 * const pp = data ? data->scream_pos : &p;
	const MAGIC *mg;
	bool found = FALSE;

	assert(SvMAGICAL(sv));
	mg = mg_find(sv, PERL_MAGIC_study);
	assert(mg);

	if (mg->mg_private == 1) {
	    found = ((U8 *)mg->mg_ptr)[BmRARE(check)] != (U8)~0;
	} else if (mg->mg_private == 2) {
	    found = ((U16 *)mg->mg_ptr)[BmRARE(check)] != (U16)~0;
	} else {
	    assert (mg->mg_private == 4);
	    found = ((U32 *)mg->mg_ptr)[BmRARE(check)] != (U32)~0;
	}

	if (found
	    || ( BmRARE(check) == '\n'
		 && (BmPREVIOUS(check) == SvCUR(check) - 1)
		 && SvTAIL(check) ))
	    s = screaminstr(sv, check,
			    srch_start_shift + (s - strbeg), srch_end_shift, pp, 0);
	else
	    goto fail_finish;
	/* we may be pointing at the wrong string */
	if (s && RXp_MATCH_COPIED(prog))
	    s = strbeg + (s - SvPVX_const(sv));
	if (data)
	    *data->scream_olds = s;
    }
    else {
        U8* start_point;
        U8* end_point;
a782 1
    }
d1120 5
a1124 3
        DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "start_shift: %"IVdf" check_at: %"IVdf" s: %"IVdf" endpos: %"IVdf"\n",
				      (IV)start_shift, (IV)(check_at - strbeg), (IV)(s - strbeg), (IV)(endpos - strbeg)));
	
d1126 5
a1130 2
        s = find_byclass(prog, progi->regstclass, s, endpos, NULL);
	if (!s) {
d1143 3
d1229 2
a1230 2
#define REXEC_TRIE_READ_CHAR(trie_type, trie, widecharmap, uc, uscan, len,          \
uvc, charid, foldlen, foldbuf, uniflags) STMT_START {                               \
d1295 1
a1295 1
    while (s + (uskip = UTF8SKIP(s)) <= strend) {     \
d1297 1
a1297 1
	s += uskip;                                   \
d1312 1
a1312 1
	if (tmp && (!reginfo || regtry(reginfo, &s)))  \
a1344 18
#define REXEC_FBC_CSCAN_PRELOAD(UtFpReLoAd,CoNdUtF8,CoNd)      \
    if (utf8_target) {                                             \
	UtFpReLoAd;                                            \
	REXEC_FBC_UTF8_CLASS_SCAN(CoNdUtF8);                   \
    }                                                          \
    else {                                                     \
	REXEC_FBC_CLASS_SCAN(CoNd);                            \
    }

#define REXEC_FBC_CSCAN_TAINT(CoNdUtF8,CoNd)                   \
    PL_reg_flags |= RF_tainted;                                \
    if (utf8_target) {                                             \
	REXEC_FBC_UTF8_CLASS_SCAN(CoNdUtF8);                   \
    }                                                          \
    else {                                                     \
	REXEC_FBC_CLASS_SCAN(CoNd);                            \
    }

d1435 1
a1435 1
    const char *strend, regmatch_info *reginfo)
d1437 44
a1480 16
	dVAR;
	const I32 doevery = (prog->intflags & PREGf_SKIP) == 0;
	char *pat_string;   /* The pattern's exactish string */
	char *pat_end;	    /* ptr to end char of pat_string */
	re_fold_t folder;	/* Function for computing non-utf8 folds */
	const U8 *fold_array;   /* array for folding ords < 256 */
	STRLEN ln;
	STRLEN lnc;
	register STRLEN uskip;
	U8 c1;
	U8 c2;
	char *e;
	register I32 tmp = 1;	/* Scratch variable? */
	register const bool utf8_target = PL_reg_match_utf8;
	UV utf8_fold_flags = 0;
        RXi_GET_DECL(prog,progi);
d1482 8
a1489 23
	PERL_ARGS_ASSERT_FIND_BYCLASS;
        
	/* We know what class it must start with. */
	switch (OP(c)) {
	case ANYOFV:
	case ANYOF:
	    if (utf8_target || OP(c) == ANYOFV) {
		STRLEN inclasslen = strend - s;
		REXEC_FBC_UTF8_CLASS_SCAN(
                          reginclass(prog, c, (U8*)s, &inclasslen, utf8_target));
	    }
	    else {
		REXEC_FBC_CLASS_SCAN(REGINCLASS(prog, c, (U8*)s));
	    }
	    break;
	case CANY:
	    REXEC_FBC_SCAN(
	        if (tmp && (!reginfo || regtry(reginfo, &s)))
		    goto got_it;
		else
		    tmp = doevery;
	    );
	    break;
d1491 2
a1492 8
	case EXACTFA:
	    if (UTF_PATTERN || utf8_target) {
		utf8_fold_flags = FOLDEQ_UTF8_NOMIX_ASCII;
		goto do_exactf_utf8;
	    }
	    fold_array = PL_fold_latin1;    /* Latin1 folds are not affected by */
	    folder = foldEQ_latin1;	    /* /a, except the sharp s one which */
	    goto do_exactf_non_utf8;	    /* isn't dealt with by these */
d1494 7
a1500 2
	case EXACTF:
	    if (utf8_target) {
d1502 8
a1509 7
		/* regcomp.c already folded this if pattern is in UTF-8 */
		utf8_fold_flags = 0;
		goto do_exactf_utf8;
	    }
	    fold_array = PL_fold;
	    folder = foldEQ;
	    goto do_exactf_non_utf8;
d1511 5
a1515 8
	case EXACTFL:
	    if (UTF_PATTERN || utf8_target) {
		utf8_fold_flags = FOLDEQ_UTF8_LOCALE;
		goto do_exactf_utf8;
	    }
	    fold_array = PL_fold_locale;
	    folder = foldEQ_locale;
	    goto do_exactf_non_utf8;
d1517 6
a1522 5
	case EXACTFU_SS:
	    if (UTF_PATTERN) {
		utf8_fold_flags = FOLDEQ_S2_ALREADY_FOLDED;
	    }
	    goto do_exactf_utf8;
d1524 27
a1550 6
	case EXACTFU_TRICKYFOLD:
	case EXACTFU:
	    if (UTF_PATTERN || utf8_target) {
		utf8_fold_flags = (UTF_PATTERN) ? FOLDEQ_S2_ALREADY_FOLDED : 0;
		goto do_exactf_utf8;
	    }
d1552 3
a1554 5
	    /* Any 'ss' in the pattern should have been replaced by regcomp,
	     * so we don't have to worry here about this single special case
	     * in the Latin1 range */
	    fold_array = PL_fold_latin1;
	    folder = foldEQ_latin1;
d1556 9
a1564 1
	    /* FALL THROUGH */
d1566 3
a1568 33
	do_exactf_non_utf8: /* Neither pattern nor string are UTF8, and there
			       are no glitches with fold-length differences
			       between the target string and pattern */

	    /* The idea in the non-utf8 EXACTF* cases is to first find the
	     * first character of the EXACTF* node and then, if necessary,
	     * case-insensitively compare the full text of the node.  c1 is the
	     * first character.  c2 is its fold.  This logic will not work for
	     * Unicode semantics and the german sharp ss, which hence should
	     * not be compiled into a node that gets here. */
	    pat_string = STRING(c);
	    ln  = STR_LEN(c);	/* length to match in octets/bytes */

	    /* We know that we have to match at least 'ln' bytes (which is the
	     * same as characters, since not utf8).  If we have to match 3
	     * characters, and there are only 2 availabe, we know without
	     * trying that it will fail; so don't start a match past the
	     * required minimum number from the far end */
	    e = HOP3c(strend, -((I32)ln), s);

	    if (!reginfo && e < s) {
		e = s;			/* Due to minlen logic of intuit() */
	    }

	    c1 = *pat_string;
	    c2 = fold_array[c1];
	    if (c1 == c2) { /* If char and fold are the same */
		REXEC_FBC_EXACTISH_SCAN(*(U8*)s == c1);
	    }
	    else {
		REXEC_FBC_EXACTISH_SCAN(*(U8*)s == c1 || *(U8*)s == c2);
	    }
	    break;
d1570 27
a1596 3
	do_exactf_utf8:
	{
	    unsigned expansion;
d1598 3
d1602 83
a1684 28
	    /* If one of the operands is in utf8, we can't use the simpler
	     * folding above, due to the fact that many different characters
	     * can have the same fold, or portion of a fold, or different-
	     * length fold */
	    pat_string = STRING(c);
	    ln  = STR_LEN(c);	/* length to match in octets/bytes */
	    pat_end = pat_string + ln;
	    lnc = (UTF_PATTERN) /* length to match in characters */
		    ? utf8_length((U8 *) pat_string, (U8 *) pat_end)
		    : ln;

	    /* We have 'lnc' characters to match in the pattern, but because of
	     * multi-character folding, each character in the target can match
	     * up to 3 characters (Unicode guarantees it will never exceed
	     * this) if it is utf8-encoded; and up to 2 if not (based on the
	     * fact that the Latin 1 folds are already determined, and the
	     * only multi-char fold in that range is the sharp-s folding to
	     * 'ss'.  Thus, a pattern character can match as little as 1/3 of a
	     * string character.  Adjust lnc accordingly, rounding up, so that
	     * if we need to match at least 4+1/3 chars, that really is 5. */
	    expansion = (utf8_target) ? UTF8_MAX_FOLD_CHAR_EXPAND : 2;
	    lnc = (lnc + expansion - 1) / expansion;

	    /* As in the non-UTF8 case, if we have to match 3 characters, and
	     * only 2 are left, it's guaranteed to fail, so don't start a
	     * match that would require us to go beyond the end of the string
	     */
	    e = HOP3c(strend, -((I32)lnc), s);
d1686 5
a1690 3
	    if (!reginfo && e < s) {
		e = s;			/* Due to minlen logic of intuit() */
	    }
d1692 9
a1700 240
	    /* XXX Note that we could recalculate e to stop the loop earlier,
	     * as the worst case expansion above will rarely be met, and as we
	     * go along we would usually find that e moves further to the left.
	     * This would happen only after we reached the point in the loop
	     * where if there were no expansion we should fail.  Unclear if
	     * worth the expense */

	    while (s <= e) {
		char *my_strend= (char *)strend;
		if (foldEQ_utf8_flags(s, &my_strend, 0,  utf8_target,
		      pat_string, NULL, ln, cBOOL(UTF_PATTERN), utf8_fold_flags)
		    && (!reginfo || regtry(reginfo, &s)) )
		{
		    goto got_it;
		}
		s += (utf8_target) ? UTF8SKIP(s) : 1;
	    }
	    break;
	}
	case BOUNDL:
	    PL_reg_flags |= RF_tainted;
	    FBC_BOUND(isALNUM_LC,
		      isALNUM_LC_uvchr(UNI_TO_NATIVE(tmp)),
		      isALNUM_LC_utf8((U8*)s));
	    break;
	case NBOUNDL:
	    PL_reg_flags |= RF_tainted;
	    FBC_NBOUND(isALNUM_LC,
		       isALNUM_LC_uvchr(UNI_TO_NATIVE(tmp)),
		       isALNUM_LC_utf8((U8*)s));
	    break;
	case BOUND:
	    FBC_BOUND(isWORDCHAR,
		      isALNUM_uni(tmp),
		      cBOOL(swash_fetch(PL_utf8_alnum, (U8*)s, utf8_target)));
	    break;
	case BOUNDA:
	    FBC_BOUND_NOLOAD(isWORDCHAR_A,
			     isWORDCHAR_A(tmp),
			     isWORDCHAR_A((U8*)s));
	    break;
	case NBOUND:
	    FBC_NBOUND(isWORDCHAR,
		       isALNUM_uni(tmp),
		       cBOOL(swash_fetch(PL_utf8_alnum, (U8*)s, utf8_target)));
	    break;
	case NBOUNDA:
	    FBC_NBOUND_NOLOAD(isWORDCHAR_A,
			      isWORDCHAR_A(tmp),
			      isWORDCHAR_A((U8*)s));
	    break;
	case BOUNDU:
	    FBC_BOUND(isWORDCHAR_L1,
		      isALNUM_uni(tmp),
		      cBOOL(swash_fetch(PL_utf8_alnum, (U8*)s, utf8_target)));
	    break;
	case NBOUNDU:
	    FBC_NBOUND(isWORDCHAR_L1,
		       isALNUM_uni(tmp),
		       cBOOL(swash_fetch(PL_utf8_alnum, (U8*)s, utf8_target)));
	    break;
	case ALNUML:
	    REXEC_FBC_CSCAN_TAINT(
		isALNUM_LC_utf8((U8*)s),
		isALNUM_LC(*s)
	    );
	    break;
	case ALNUMU:
	    REXEC_FBC_CSCAN_PRELOAD(
		LOAD_UTF8_CHARCLASS_ALNUM(),
		swash_fetch(PL_utf8_alnum,(U8*)s, utf8_target),
                isWORDCHAR_L1((U8) *s)
	    );
	    break;
	case ALNUM:
	    REXEC_FBC_CSCAN_PRELOAD(
		LOAD_UTF8_CHARCLASS_ALNUM(),
		swash_fetch(PL_utf8_alnum,(U8*)s, utf8_target),
                isWORDCHAR((U8) *s)
	    );
	    break;
	case ALNUMA:
	    /* Don't need to worry about utf8, as it can match only a single
	     * byte invariant character */
	    REXEC_FBC_CLASS_SCAN( isWORDCHAR_A(*s));
	    break;
	case NALNUMU:
	    REXEC_FBC_CSCAN_PRELOAD(
		LOAD_UTF8_CHARCLASS_ALNUM(),
		!swash_fetch(PL_utf8_alnum,(U8*)s, utf8_target),
                ! isWORDCHAR_L1((U8) *s)
	    );
	    break;
	case NALNUM:
	    REXEC_FBC_CSCAN_PRELOAD(
		LOAD_UTF8_CHARCLASS_ALNUM(),
		!swash_fetch(PL_utf8_alnum, (U8*)s, utf8_target),
                ! isALNUM(*s)
	    );
	    break;
	case NALNUMA:
	    REXEC_FBC_CSCAN(
		!isWORDCHAR_A(*s),
		!isWORDCHAR_A(*s)
	    );
	    break;
	case NALNUML:
	    REXEC_FBC_CSCAN_TAINT(
		!isALNUM_LC_utf8((U8*)s),
		!isALNUM_LC(*s)
	    );
	    break;
	case SPACEU:
	    REXEC_FBC_CSCAN_PRELOAD(
		LOAD_UTF8_CHARCLASS_SPACE(),
		*s == ' ' || swash_fetch(PL_utf8_space,(U8*)s, utf8_target),
                isSPACE_L1((U8) *s)
	    );
	    break;
	case SPACE:
	    REXEC_FBC_CSCAN_PRELOAD(
		LOAD_UTF8_CHARCLASS_SPACE(),
		*s == ' ' || swash_fetch(PL_utf8_space,(U8*)s, utf8_target),
                isSPACE((U8) *s)
	    );
	    break;
	case SPACEA:
	    /* Don't need to worry about utf8, as it can match only a single
	     * byte invariant character */
	    REXEC_FBC_CLASS_SCAN( isSPACE_A(*s));
	    break;
	case SPACEL:
	    REXEC_FBC_CSCAN_TAINT(
		isSPACE_LC_utf8((U8*)s),
		isSPACE_LC(*s)
	    );
	    break;
	case NSPACEU:
	    REXEC_FBC_CSCAN_PRELOAD(
		LOAD_UTF8_CHARCLASS_SPACE(),
		!( *s == ' ' || swash_fetch(PL_utf8_space,(U8*)s, utf8_target)),
                ! isSPACE_L1((U8) *s)
	    );
	    break;
	case NSPACE:
	    REXEC_FBC_CSCAN_PRELOAD(
		LOAD_UTF8_CHARCLASS_SPACE(),
		!(*s == ' ' || swash_fetch(PL_utf8_space,(U8*)s, utf8_target)),
                ! isSPACE((U8) *s)
	    );
	    break;
	case NSPACEA:
	    REXEC_FBC_CSCAN(
		!isSPACE_A(*s),
		!isSPACE_A(*s)
	    );
	    break;
	case NSPACEL:
	    REXEC_FBC_CSCAN_TAINT(
		!isSPACE_LC_utf8((U8*)s),
		!isSPACE_LC(*s)
	    );
	    break;
	case DIGIT:
	    REXEC_FBC_CSCAN_PRELOAD(
		LOAD_UTF8_CHARCLASS_DIGIT(),
		swash_fetch(PL_utf8_digit,(U8*)s, utf8_target),
		isDIGIT(*s)
	    );
	    break;
	case DIGITA:
	    /* Don't need to worry about utf8, as it can match only a single
	     * byte invariant character */
	    REXEC_FBC_CLASS_SCAN( isDIGIT_A(*s));
	    break;
	case DIGITL:
	    REXEC_FBC_CSCAN_TAINT(
		isDIGIT_LC_utf8((U8*)s),
		isDIGIT_LC(*s)
	    );
	    break;
	case NDIGIT:
	    REXEC_FBC_CSCAN_PRELOAD(
		LOAD_UTF8_CHARCLASS_DIGIT(),
		!swash_fetch(PL_utf8_digit,(U8*)s, utf8_target),
		!isDIGIT(*s)
	    );
	    break;
	case NDIGITA:
	    REXEC_FBC_CSCAN(
		!isDIGIT_A(*s),
		!isDIGIT_A(*s)
	    );
	    break;
	case NDIGITL:
	    REXEC_FBC_CSCAN_TAINT(
		!isDIGIT_LC_utf8((U8*)s),
		!isDIGIT_LC(*s)
	    );
	    break;
	case LNBREAK:
	    REXEC_FBC_CSCAN(
		is_LNBREAK_utf8(s),
		is_LNBREAK_latin1(s)
	    );
	    break;
	case VERTWS:
	    REXEC_FBC_CSCAN(
		is_VERTWS_utf8(s),
		is_VERTWS_latin1(s)
	    );
	    break;
	case NVERTWS:
	    REXEC_FBC_CSCAN(
		!is_VERTWS_utf8(s),
		!is_VERTWS_latin1(s)
	    );
	    break;
	case HORIZWS:
	    REXEC_FBC_CSCAN(
		is_HORIZWS_utf8(s),
		is_HORIZWS_latin1(s)
	    );
	    break;
	case NHORIZWS:
	    REXEC_FBC_CSCAN(
		!is_HORIZWS_utf8(s),
		!is_HORIZWS_latin1(s)
	    );	    
	    break;
	case AHOCORASICKC:
	case AHOCORASICK: 
	    {
	        DECL_TRIE_TYPE(c);
                /* what trie are we using right now */
        	reg_ac_data *aho
        	    = (reg_ac_data*)progi->data->data[ ARG( c ) ];
        	reg_trie_data *trie
		    = (reg_trie_data*)progi->data->data[ aho->trie ];
		HV *widecharmap = MUTABLE_HV(progi->data->data[ aho->trie + 1 ]);
d1702 2
a1703 13
		const char *last_start = strend - trie->minlen;
#ifdef DEBUGGING
		const char *real_start = s;
#endif
		STRLEN maxlen = trie->maxlen;
		SV *sv_points;
		U8 **points; /* map of where we were in the input string
		                when reading a given char. For ASCII this
		                is unnecessary overhead as the relationship
		                is always 1:1, but for Unicode, especially
		                case folded Unicode this is not true. */
		U8 foldbuf[ UTF8_MAXBYTES_CASE + 1 ];
		U8 *bitmap=NULL;
d1705 18
d1724 69
a1792 1
                GET_RE_DEBUG_FLAGS_DECL;
d1794 8
a1801 34
                /* We can't just allocate points here. We need to wrap it in
                 * an SV so it gets freed properly if there is a croak while
                 * running the match */
                ENTER;
	        SAVETMPS;
                sv_points=newSV(maxlen * sizeof(U8 *));
                SvCUR_set(sv_points,
                    maxlen * sizeof(U8 *));
                SvPOK_on(sv_points);
                sv_2mortal(sv_points);
                points=(U8**)SvPV_nolen(sv_points );
                if ( trie_type != trie_utf8_fold 
                     && (trie->bitmap || OP(c)==AHOCORASICKC) ) 
                {
                    if (trie->bitmap) 
                        bitmap=(U8*)trie->bitmap;
                    else
                        bitmap=(U8*)ANYOF_BITMAP(c);
                }
                /* this is the Aho-Corasick algorithm modified a touch
                   to include special handling for long "unknown char" 
                   sequences. The basic idea being that we use AC as long
                   as we are dealing with a possible matching char, when
                   we encounter an unknown char (and we have not encountered
                   an accepting state) we scan forward until we find a legal 
                   starting char. 
                   AC matching is basically that of trie matching, except
                   that when we encounter a failing transition, we fall back
                   to the current states "fail state", and try the current char 
                   again, a process we repeat until we reach the root state, 
                   state 1, or a legal transition. If we fail on the root state 
                   then we can either terminate if we have reached an accepting 
                   state previously, or restart the entire process from the beginning 
                   if we have not.
d1803 10
a1812 16
                 */
                while (s <= last_start) {
                    const U32 uniflags = UTF8_ALLOW_DEFAULT;
                    U8 *uc = (U8*)s;
                    U16 charid = 0;
                    U32 base = 1;
                    U32 state = 1;
                    UV uvc = 0;
                    STRLEN len = 0;
                    STRLEN foldlen = 0;
                    U8 *uscan = (U8*)NULL;
                    U8 *leftmost = NULL;
#ifdef DEBUGGING                    
                    U32 accepted_word= 0;
#endif
                    U32 pointpos = 0;
d1814 8
a1821 3
                    while ( state && uc <= (U8*)strend ) {
                        int failed=0;
                        U32 word = aho->states[ state ].wordnum;
d1823 89
a1911 20
                        if( state==1 ) {
                            if ( bitmap ) {
                                DEBUG_TRIE_EXECUTE_r(
                                    if ( uc <= (U8*)last_start && !BITMAP_TEST(bitmap,*uc) ) {
                                        dump_exec_pos( (char *)uc, c, strend, real_start, 
                                            (char *)uc, utf8_target );
                                        PerlIO_printf( Perl_debug_log,
                                            " Scanning for legal start char...\n");
                                    }
                                );
				if (utf8_target) {
				    while ( uc <= (U8*)last_start && !BITMAP_TEST(bitmap,*uc) ) {
					uc += UTF8SKIP(uc);
				    }
				} else {
				    while ( uc <= (U8*)last_start  && !BITMAP_TEST(bitmap,*uc) ) {
					uc++;
				    }
				}
                                s= (char *)uc;
d1913 1
a1913 1
                            if (uc >(U8*)last_start) break;
d1915 8
a1922 9
                                            
                        if ( word ) {
                            U8 *lpos= points[ (pointpos - trie->wordinfo[word].len) % maxlen ];
                            if (!leftmost || lpos < leftmost) {
                                DEBUG_r(accepted_word=word);
                                leftmost= lpos;
                            }
                            if (base==0) break;
                            
d1924 9
a1932 4
                        points[pointpos++ % maxlen]= uc;
			REXEC_TRIE_READ_CHAR(trie_type, trie, widecharmap, uc,
					     uscan, len, uvc, charid, foldlen,
					     foldbuf, uniflags);
d1934 2
a1935 2
                            dump_exec_pos( (char *)uc, c, strend, real_start, 
                                s,   utf8_target );
d1940 6
d1947 1
a1947 1
                        do {
d1949 1
a1949 1
                            word = aho->states[ state ].wordnum;
d1951 1
a1951 1
                            base = aho->states[ state ].trans.base;
d1953 23
a1975 30
                            DEBUG_TRIE_EXECUTE_r({
                                if (failed) 
                                    dump_exec_pos( (char *)uc, c, strend, real_start, 
                                        s,   utf8_target );
                                PerlIO_printf( Perl_debug_log,
                                    "%sState: %4"UVxf", word=%"UVxf,
                                    failed ? " Fail transition to " : "",
                                    (UV)state, (UV)word);
                            });
                            if ( base ) {
                                U32 tmp;
				I32 offset;
                                if (charid &&
				     ( ((offset = base + charid
					- 1 - trie->uniquecharcount)) >= 0)
                                     && ((U32)offset < trie->lasttrans)
                                     && trie->trans[offset].check == state
                                     && (tmp=trie->trans[offset].next))
                                {
                                    DEBUG_TRIE_EXECUTE_r(
                                        PerlIO_printf( Perl_debug_log," - legal\n"));
                                    state = tmp;
                                    break;
                                }
                                else {
                                    DEBUG_TRIE_EXECUTE_r(
                                        PerlIO_printf( Perl_debug_log," - fail\n"));
                                    failed = 1;
                                    state = aho->fail[state];
                                }
a1977 1
                                /* we must be accepting here */
d1979 1
a1979 1
                                        PerlIO_printf( Perl_debug_log," - accepting\n"));
d1981 1
a1981 1
                                break;
a1982 6
                        } while(state);
                        uc += len;
                        if (failed) {
                            if (leftmost)
                                break;
                            if (!state) state = 1;
d1984 13
d1998 6
a2003 6
                    if ( aho->states[ state ].wordnum ) {
                        U8 *lpos = points[ (pointpos - trie->wordinfo[aho->states[ state ].wordnum].len) % maxlen ];
                        if (!leftmost || lpos < leftmost) {
                            DEBUG_r(accepted_word=aho->states[ state ].wordnum);
                            leftmost = lpos;
                        }
d2005 13
a2017 21
                    if (leftmost) {
                        s = (char*)leftmost;
                        DEBUG_TRIE_EXECUTE_r({
                            PerlIO_printf( 
                                Perl_debug_log,"Matches word #%"UVxf" at position %"IVdf". Trying full pattern...\n",
                                (UV)accepted_word, (IV)(s - real_start)
                            );
                        });
                        if (!reginfo || regtry(reginfo, &s)) {
                            FREETMPS;
		            LEAVE;
                            goto got_it;
                        }
                        s = HOPc(s,1);
                        DEBUG_TRIE_EXECUTE_r({
                            PerlIO_printf( Perl_debug_log,"Pattern failed. Looking for new start point...\n");
                        });
                    } else {
                        DEBUG_TRIE_EXECUTE_r(
                            PerlIO_printf( Perl_debug_log,"No match.\n"));
                        break;
d2019 8
d2028 12
a2039 11
                FREETMPS;
                LEAVE;
	    }
	    break;
	default:
	    Perl_croak(aTHX_ "panic: unknown regstclass %d", (int)OP(c));
	    break;
	}
	return 0;
      got_it:
	return s;
d2047 1
a2047 1
Perl_regexec_flags(pTHX_ REGEXP * const rx, char *stringarg, register char *strend,
d2049 11
a2059 7
/* strend: pointer to null at end of string */
/* strbeg: real beginning of string */
/* minend: end of match must be >=minend after stringarg. */
/* data: May be used for some additional optimizations. 
         Currently its only used, with a U32 cast, for transmitting 
         the ganch offset when doing a /g match. This will change */
/* nosave: For optimizations. */
d2062 4
a2065 4
    struct regexp *const prog = (struct regexp *)SvANY(rx);
    /*register*/ char *s;
    register regnode *c;
    /*register*/ char *startpos = stringarg;
d2110 2
a2111 2
    PL_reg_flags = 0;
    PL_reg_eval_set = 0;
d2114 2
a2115 3
    if (RX_UTF8(rx))
	PL_reg_flags |= RF_utf8;

d2170 2
a2171 2
           to the re, and switch the buffer each match. If we fail
           we switch it back, otherwise we leave it swapped.
d2176 6
d2290 1
a2290 1
	/* it must be a one character string (XXXX Except UTF_PATTERN?) */
a2294 4
	if (!(utf8_target ? prog->anchored_utf8 : prog->anchored_substr))
	    utf8_target ? to_utf8_substr(prog) : to_byte_substr(prog);
	ch = SvPVX_const(utf8_target ? prog->anchored_utf8 : prog->anchored_substr)[0];

d2296 4
d2309 1
d2312 6
d2346 14
a2359 3
	    if (!(utf8_target ? prog->anchored_utf8 : prog->anchored_substr))
		utf8_target ? to_utf8_substr(prog) : to_byte_substr(prog);
	    must = utf8_target ? prog->anchored_utf8 : prog->anchored_substr;
d2362 14
a2375 3
	    if (!(utf8_target ? prog->float_utf8 : prog->float_substr))
		utf8_target ? to_utf8_substr(prog) : to_byte_substr(prog);
	    must = utf8_target ? prog->float_utf8 : prog->float_substr;
a2378 1
	
a2379 4
	if (must == &PL_sv_undef)
	    /* could not downgrade utf8 check substring, so must fail */
	    goto phooey;

d2398 1
a2398 4
		((flags & REXEC_SCREAM) && SvSCREAM(sv)
		 ? (s = screaminstr(sv, must, HOP3c(s, back_min, (back_min<0 ? strbeg : strend)) - strbeg,
				    end_shift, &scream_pos, 0))
		 : (s = fbm_instr((unsigned char*)HOP3(s, back_min, (back_min<0 ? strbeg : strend)),
d2400 1
a2400 4
				  multiline ? FBMrf_MULTILINE : 0))) ) {
	    /* we may be pointing at the wrong string */
	    if ((flags & REXEC_SCREAM) && RXp_MATCH_COPIED(prog))
		s = strbeg + (s - SvPVX_const(sv));
d2416 5
a2420 1
		    s += UTF8SKIP(s);
d2460 1
a2460 1
        if (find_byclass(prog, c, s, strend, &reginfo))
d2470 2
d2473 26
a2498 25
	    if (!(utf8_target ? prog->float_utf8 : prog->float_substr))
		utf8_target ? to_utf8_substr(prog) : to_byte_substr(prog);
	    float_real = utf8_target ? prog->float_utf8 : prog->float_substr;

	    if ((flags & REXEC_SCREAM) && SvSCREAM(sv)) {
		last = screaminstr(sv, float_real, s - strbeg,
				   end_shift, &scream_pos, 1); /* last one */
		if (!last)
		    last = scream_olds; /* Only one occurrence. */
		/* we may be pointing at the wrong string */
		else if (RXp_MATCH_COPIED(prog))
		    s = strbeg + (s - SvPVX_const(sv));
	    }
	    else {
		STRLEN len;
                const char * const little = SvPV_const(float_real, len);
		if (SvTAIL(float_real)) {
		    /* This means that float_real contains an artificial \n on the end
		     * due to the presence of something like this: /foo$/
		     * where we can match both "foo" and "foo\n" at the end of the string.
		     * So we have to compare the end of the string first against the float_real
		     * without the \n and then against the full float_real with the string.
		     * We have to watch out for cases where the string might be smaller
		     * than the float_real or the float_real without the \n.
		     */
d2505 2
a2506 1
			/* can't match, even if we remove the trailing \n string is too short to match */
d2513 2
a2514 1
			/* can match, the end of the string matches without the "\n" */
d2517 2
a2518 1
			/* cant match, string is too short when the "\n" is included */
d2525 2
a2526 1
			/* non multiline match, so compare with the "\n" at the end of the string */
d2537 2
a2538 1
			/* multiline match, so we have to search for a place where the full string is located */
d2541 1
a2541 1
		} else {
a2546 1
		}
d2549 5
a2553 5
		/* at one point this block contained a comment which was probably
		 * incorrect, which said that this was a "should not happen" case.
		 * Even if it was true when it was written I am pretty sure it is
		 * not anymore, so I have removed the comment and replaced it with
		 * this one. Yves */
d2587 8
a2595 1
    RX_MATCH_TAINTED_set(rx, PL_reg_flags & RF_tainted);
d2597 1
a2597 1
    if (PL_reg_eval_set)
a2603 1
	RX_MATCH_COPY_FREE(rx);
d2605 2
a2606 4
	    const I32 i = PL_regeol - startpos + (stringarg - strbeg);
#ifdef PERL_OLD_COPY_ON_WRITE
	    if ((SvIsCOW(sv)
		 || (SvFLAGS(sv) & CAN_COW_MASK) == CAN_COW_FLAGS)) {
d2612 1
d2616 3
d2622 87
a2708 5
		RX_MATCH_COPIED_on(rx);
		s = savepvn(strbeg, i);
		prog->subbeg = s;
	    }
	    prog->sublen = i;
d2711 1
d2713 2
d2724 1
a2724 1
    if (PL_reg_eval_set)
d2728 6
a2736 1

d2741 10
d2755 1
a2755 1
S_regtry(pTHX_ regmatch_info *reginfo, char **startpos)
d2760 2
a2761 1
    regexp *const prog = (struct regexp *)SvANY(rx);
d2769 3
a2771 1
    if ((prog->extflags & RXf_EVAL_SEEN) && !PL_reg_eval_set) {
d2774 1
a2774 13
	PL_reg_eval_set = RS_init;
	DEBUG_EXECUTE_r(DEBUG_s(
	    PerlIO_printf(Perl_debug_log, "  setting stack tmpbase at %"IVdf"\n",
			  (IV)(PL_stack_sp - PL_stack_base));
	    ));
	SAVESTACK_CXPOS();
	cxstack[cxstack_ix].blk_oldsp = PL_stack_sp - PL_stack_base;
	/* Otherwise OP_NEXTSTATE will free whatever on stack now.  */
	SAVETMPS;
	/* Apparently this is not needed, judging by wantarray. */
	/* SAVEI8(cxstack[cxstack_ix].blk_gimme);
	   cxstack[cxstack_ix].blk_gimme = G_SCALAR; */

d2810 1
a2810 10
#ifdef USE_ITHREADS
	/* It seems that non-ithreads works both with and without this code.
	   So for efficiency reasons it seems best not to have the code
	   compiled when it is not needed.  */
	/* This is safe against NULLs: */
	ReREFCNT_dec(PM_GETRE(PL_reg_curpm));
	/* PM_reg_curpm owns a reference to this regexp.  */
	(void)ReREFCNT_inc(rx);
#endif
	PM_SETRE(PL_reg_curpm, rx);
d2819 3
a2821 1
#ifdef PERL_OLD_COPY_ON_WRITE
d2829 2
d2833 4
a2836 5
    DEBUG_EXECUTE_r(PL_reg_starttry = *startpos);
    prog->offs[0].start = *startpos - PL_bostr;
    PL_reginput = *startpos;
    PL_reglastparen = &prog->lastparen;
    PL_reglastcloseparen = &prog->lastcloseparen;
a2838 9
    PL_regsize = 0;
    PL_regoffs = prog->offs;
    if (PL_reg_start_tmpl <= prog->nparens) {
	PL_reg_start_tmpl = prog->nparens*3/2 + 3;
        if(PL_reg_start_tmp)
            Renew(PL_reg_start_tmp, PL_reg_start_tmpl, char*);
        else
            Newx(PL_reg_start_tmp, PL_reg_start_tmpl, char*);
    }
d2841 1
a2841 1
       to do this again and again, PL_reglastparen should take care of
d2846 1
a2846 1
     * PL_reglastparen), is not needed at all by the test suite
d2855 3
a2857 3
	regexp_paren_pair *pp = PL_regoffs;
	register I32 i;
	for (i = prog->nparens; i > (I32)*PL_reglastparen; i--) {
d2865 3
a2867 2
    if (regmatch(reginfo, progi->program + 1)) {
	PL_regoffs[0].end = PL_reginput - PL_bostr;
d2871 1
a2871 1
        *startpos= reginfo->cutpoint;
d2897 2
d2925 2
a2926 1
#define PUSH_STATE_GOTO(state, node) \
d2933 2
a2934 1
#define PUSH_YES_STATE_GOTO(state, node) \
d2941 1
d3007 1
a3007 1
	PUSH_YES_STATE_GOTO(IFMATCH_A, A);
d3044 2
a3045 2
	PUSH_STATE_GOTO(resume_state, node);
	PUSH_YES_STATE_GOTO(resume_state, node);
d3208 2
a3209 2
        if ((I32)*PL_reglastparen >= nums[n] &&
            PL_regoffs[nums[n]].end != -1)
d3235 229
d3465 22
d3488 2
a3489 3
#define SETREX(Re1,Re2) \
    if (PL_reg_eval_set) PM_SETRE((PL_reg_curpm), (Re2)); \
    Re1 = (Re2)
d3491 3
a3493 2
STATIC I32			/* 0 failure, 1 success */
S_regmatch(pTHX_ regmatch_info *reginfo, regnode *prog)
d3499 1
a3499 1
    register const bool utf8_target = PL_reg_match_utf8;
d3502 1
a3502 1
    regexp *rex = (struct regexp *)SvANY(rex_sv);
d3506 1
a3506 1
    register regmatch_state *st;
d3508 7
a3514 6
    register regnode *scan;
    register regnode *next;
    register U32 n = 0;	/* general value; init to avoid compiler warning */
    register I32 ln = 0; /* len or last;  init to avoid compiler warning */
    register char *locinput = PL_reginput;
    register I32 nextchr;   /* is always set to UCHARAT(locinput) */
d3532 1
a3532 1
    char *startpoint = PL_reginput;
d3554 11
d3569 8
d3601 1
a3601 1
    nextchr = UCHARAT(locinput);
d3625 1
d3627 2
a3628 3
	assert(PL_reglastparen == &rex->lastparen);
	assert(PL_reglastcloseparen == &rex->lastcloseparen);
	assert(PL_regoffs == rex->offs);
d3631 1
a3631 1
	case BOL:
d3638 2
a3639 1
	case MBOL:
d3641 1
a3641 1
		((nextchr || locinput < PL_regeol) && locinput[-1] == '\n'))
d3646 2
a3647 1
	case SBOL:
d3651 2
a3652 1
	case GPOS:
d3657 1
a3657 1
	case KEEPS:
d3659 4
a3662 5
	    st->u.keeper.val = PL_regoffs[0].start;
	    PL_reginput = locinput;
	    PL_regoffs[0].start = locinput - PL_bostr;
	    PUSH_STATE_GOTO(KEEPS_next, next);
	    /*NOT-REACHED*/
d3665 1
a3665 1
	    PL_regoffs[0].start = st->u.keeper.val;
d3667 3
a3669 2
	    /*NOT-REACHED*/
	case EOL:
d3671 3
a3673 2
	case MEOL:
	    if ((nextchr || locinput < PL_regeol) && nextchr != '\n')
d3676 2
a3677 1
	case SEOL:
d3679 1
a3679 1
	    if ((nextchr || locinput < PL_regeol) && nextchr != '\n')
d3684 3
a3686 2
	case EOS:
	    if (PL_regeol != locinput)
d3689 3
a3691 2
	case SANY:
	    if (!nextchr && locinput >= PL_regeol)
d3693 4
a3696 11
 	    if (utf8_target) {
	        locinput += PL_utf8skip[nextchr];
		if (locinput > PL_regeol)
 		    sayNO;
 		nextchr = UCHARAT(locinput);
 	    }
 	    else
 		nextchr = UCHARAT(++locinput);
	    break;
	case CANY:
	    if (!nextchr && locinput >= PL_regeol)
d3698 1
a3698 1
	    nextchr = UCHARAT(++locinput);
d3700 3
a3702 2
	case REG_ANY:
	    if ((!nextchr && locinput >= PL_regeol) || nextchr == '\n')
d3704 2
a3705 9
	    if (utf8_target) {
		locinput += PL_utf8skip[nextchr];
		if (locinput > PL_regeol)
		    sayNO;
		nextchr = UCHARAT(locinput);
	    }
	    else
		nextchr = UCHARAT(++locinput);
	    break;
d3709 1
a3709 1
        case TRIEC:
d3713 1
a3713 1
            if(!ANYOF_BITMAP_TEST(scan, *locinput)) {
d3720 1
a3720 1
                /* NOTREACHED */
d3723 1
a3723 1
	case TRIE:
d3732 1
a3732 1
	     * matching word being 4, and the shortest being 1 (with
d3778 3
a3780 1
                if (trie->bitmap && !TRIE_BITMAP_TEST(trie,*locinput) ) {
a3808 1
		ST.B = next;
d3853 1
a3853 1
		    if ( base ) {
d3907 1
a3907 1
	    /* NOTREACHED */
d3910 2
d3914 1
a3914 3
	        for (n = *PL_reglastparen; n > ST.lastparen; n--)
		    PL_regoffs[n].end = -1;
	        *PL_reglastparen = n;
d3929 4
a3932 4
		register U16 min = 0;
		register U16 word;
		register U16 const nextword = ST.nextword;
		register reg_trie_wordinfo * const wordinfo
d3948 2
a3949 1
                ST.lastparen = *PL_reglastparen;
a3955 1
		U8 *uc = ST.firstpos;
d3963 1
a4002 1
		PL_reginput = (char *)uc;
d4005 3
a4007 3
	    scan = (ST.jump && ST.jump[ST.nextword]) 
			? ST.me + ST.jump[ST.nextword]
			: ST.B;
d4020 2
a4021 2
		PUSH_STATE_GOTO(TRIE_next, scan);
		/* NOTREACHED */
d4043 1
a4043 2
	    locinput = PL_reginput;
	    nextchr = UCHARAT(locinput);
d4045 2
a4046 1
	    /* NOTREACHED */
d4049 1
a4049 1
	case EXACT: {
d4052 1
a4052 1
	    if (utf8_target != UTF_PATTERN) {
d4058 9
a4066 1
		    /* The target is utf8, the pattern is not utf8. */
d4068 16
a4083 9
			STRLEN ulen;
			if (l >= PL_regeol)
			     sayNO;
			if (NATIVE_TO_UNI(*(U8*)s) !=
			    utf8n_to_uvuni((U8*)l, UTF8_MAXBYTES, &ulen,
					    uniflags))
			     sayNO;
			l += ulen;
			s ++;
d4089 17
a4105 9
			STRLEN ulen;
			if (l >= PL_regeol)
			    sayNO;
			if (NATIVE_TO_UNI(*((U8*)l)) !=
			    utf8n_to_uvuni((U8*)s, UTF8_MAXBYTES, &ulen,
					   uniflags))
			    sayNO;
			s += ulen;
			l ++;
a4108 2
		nextchr = UCHARAT(locinput);
		break;
d4110 11
a4120 10
	    /* The target and the pattern have the same utf8ness. */
	    /* Inline the first character, for speed. */
	    if (UCHARAT(s) != nextchr)
		sayNO;
	    if (PL_regeol - locinput < ln)
		sayNO;
	    if (ln > 1 && memNE(s, locinput, ln))
		sayNO;
	    locinput += ln;
	    nextchr = UCHARAT(locinput);
d4123 2
a4124 1
	case EXACTFL: {
d4130 3
a4132 3
	    PL_reg_flags |= RF_tainted;
	    folder = foldEQ_locale;
	    fold_array = PL_fold_locale;
d4136 3
a4138 3
	case EXACTFU_SS:
	case EXACTFU_TRICKYFOLD:
	case EXACTFU:
d4141 1
a4141 1
	    fold_utf8_flags = (UTF_PATTERN) ? FOLDEQ_S1_ALREADY_FOLDED : 0;
d4144 1
a4144 1
	case EXACTFA:
d4150 1
a4150 1
	case EXACTF:
d4159 1
a4159 1
	    if (utf8_target || UTF_PATTERN || state_num == EXACTFU_SS) {
d4165 1
a4165 1
		if (! foldEQ_utf8_flags(s, 0,  ln, cBOOL(UTF_PATTERN),
a4170 1
		nextchr = UCHARAT(locinput);
d4175 3
a4177 2
	    if (UCHARAT(s) != nextchr &&
		UCHARAT(s) != fold_array[nextchr])
a4185 1
	    nextchr = UCHARAT(locinput);
d4192 3
a4194 3
	case BOUNDL:
	case NBOUNDL:
	    PL_reg_flags |= RF_tainted;
d4196 6
a4201 6
	case BOUND:
	case BOUNDU:
	case BOUNDA:
	case NBOUND:
	case NBOUNDU:
	case NBOUNDA:
d4215 8
a4222 3
		    ln = isALNUM_uni(ln);
		    LOAD_UTF8_CHARCLASS_ALNUM();
		    n = swash_fetch(PL_utf8_alnum, (U8*)locinput, utf8_target);
d4225 2
a4226 2
		    ln = isALNUM_LC_uvchr(UNI_TO_NATIVE(ln));
		    n = isALNUM_LC_utf8((U8*)locinput);
d4247 1
a4247 1
			n = isWORDCHAR_L1(nextchr);
d4250 2
a4251 2
			ln = isALNUM_LC(ln);
			n = isALNUM_LC(nextchr);
d4254 2
a4255 2
			ln = isALNUM(ln);
			n = isALNUM(nextchr);
d4260 1
a4260 1
			n = isWORDCHAR_A(nextchr);
a4271 6
	case ANYOFV:
	case ANYOF:
	    if (utf8_target || state_num == ANYOFV) {
	        STRLEN inclasslen = PL_regeol - locinput;
		if (locinput >= PL_regeol)
		    sayNO;
d4273 6
a4278 1
	        if (!reginclass(rex, scan, (U8*)locinput, &inclasslen, utf8_target))
d4280 1
a4280 3
		locinput += inclasslen;
		nextchr = UCHARAT(locinput);
		break;
a4282 4
		if (nextchr < 0)
		    nextchr = UCHARAT(locinput);
		if (!nextchr && locinput >= PL_regeol)
		    sayNO;
d4285 1
a4285 2
		nextchr = UCHARAT(++locinput);
		break;
a4287 17
	/* Special char classes - The defines start on line 129 or so */
        CCC_TRY_U(ALNUM,  NALNUM,  isWORDCHAR,
		  ALNUML, NALNUML, isALNUM_LC, isALNUM_LC_utf8,
		  ALNUMU, NALNUMU, isWORDCHAR_L1,
		  ALNUMA, NALNUMA, isWORDCHAR_A,
		  alnum, "a");

        CCC_TRY_U(SPACE,  NSPACE,  isSPACE,
		  SPACEL, NSPACEL, isSPACE_LC, isSPACE_LC_utf8,
		  SPACEU, NSPACEU, isSPACE_L1,
		  SPACEA, NSPACEA, isSPACE_A,
		  space, " ");

        CCC_TRY(DIGIT,  NDIGIT,  isDIGIT,
		DIGITL, NDIGITL, isDIGIT_LC, isDIGIT_LC_utf8,
		DIGITA, NDIGITA, isDIGIT_A,
		digit, "0");
d4289 2
a4290 4
	case CLUMP: /* Match \X: logical Unicode character.  This is defined as
		       a Unicode extended Grapheme Cluster */
	    /* From http://www.unicode.org/reports/tr29 (5.2 version).  An
	      extended Grapheme Cluster is:
d4292 3
a4294 41
	       CR LF
	       | Prepend* Begin Extend*
	       | .

	       Begin is (Hangul-syllable | ! Control)
	       Extend is (Grapheme_Extend | Spacing_Mark)
	       Control is [ GCB_Control CR LF ]

	       The discussion below shows how the code for CLUMP is derived
	       from this regex.  Note that most of these concepts are from
	       property values of the Grapheme Cluster Boundary (GCB) property.
	       No code point can have multiple property values for a given
	       property.  Thus a code point in Prepend can't be in Control, but
	       it must be in !Control.  This is why Control above includes
	       GCB_Control plus CR plus LF.  The latter two are used in the GCB
	       property separately, and so can't be in GCB_Control, even though
	       they logically are controls.  Control is not the same as gc=cc,
	       but includes format and other characters as well.

	       The Unicode definition of Hangul-syllable is:
		   L+
		   | (L* ( ( V | LV ) V* | LVT ) T*)
		   | T+ 
		  )
	       Each of these is a value for the GCB property, and hence must be
	       disjoint, so the order they are tested is immaterial, so the
	       above can safely be changed to
		   T+
		   | L+
		   | (L* ( LVT | ( V | LV ) V*) T*)

	       The last two terms can be combined like this:
		   L* ( L
		        | (( LVT | ( V | LV ) V*) T*))

	       And refactored into this:
		   L* (L | LVT T* | V  V* T* | LV  V* T*)

	       That means that if we have seen any L's at all we can quit
	       there, but if the next character is an LVT, a V, or an LV we
	       should keep going.
d4296 3
a4298 9
	       There is a subtlety with Prepend* which showed up in testing.
	       Note that the Begin, and only the Begin is required in:
	        | Prepend* Begin Extend*
	       Also, Begin contains '! Control'.  A Prepend must be a
	       '!  Control', which means it must also be a Begin.  What it
	       comes down to is that if we match Prepend* and then find no
	       suitable Begin afterwards, that if we backtrack the last
	       Prepend, that one will be a suitable Begin.
	    */
d4300 203
a4502 1
	    if (locinput >= PL_regeol)
d4512 4
a4515 1
		    && UCHARAT(locinput) == '\n') locinput++;
d4521 3
a4523 1
		if (nextchr == '\r' && UCHARAT(locinput + 1) == '\n') {
d4527 2
d4533 1
a4533 1
		    char *previous_prepend = 0;
d4537 7
a4543 8
		    /* Match (prepend)* */
		    while (locinput < PL_regeol
			   && swash_fetch(PL_utf8_X_prepend,
					  (U8*)locinput, utf8_target))
		    {
			previous_prepend = locinput;
			locinput += UTF8SKIP(locinput);
		    }
d4550 4
a4553 2
			    || ! swash_fetch(PL_utf8_X_begin,
					     (U8*)locinput, utf8_target)))
d4563 5
a4567 1
		    if (! swash_fetch(PL_utf8_X_begin, (U8*)locinput, utf8_target)) {
d4573 1
d4576 52
a4627 6
			/* Here is the beginning of a character that can have
			 * an extender.  It is either a hangul syllable, or a
			 * non-control */
			if (swash_fetch(PL_utf8_X_non_hangul,
					(U8*)locinput, utf8_target))
			{
d4629 9
a4637 4
			    /* Here not a Hangul syllable, must be a
			     * ('!  * Control') */
			    locinput += UTF8SKIP(locinput);
			} else {
d4639 10
a4648 69
			    /* Here is a Hangul syllable.  It can be composed
			     * of several individual characters.  One
			     * possibility is T+ */
			    if (swash_fetch(PL_utf8_X_T,
					    (U8*)locinput, utf8_target))
			    {
				while (locinput < PL_regeol
					&& swash_fetch(PL_utf8_X_T,
							(U8*)locinput, utf8_target))
				{
				    locinput += UTF8SKIP(locinput);
				}
			    } else {

				/* Here, not T+, but is a Hangul.  That means
				 * it is one of the others: L, LV, LVT or V,
				 * and matches:
				 * L* (L | LVT T* | V  V* T* | LV  V* T*) */

				/* Match L*           */
				while (locinput < PL_regeol
					&& swash_fetch(PL_utf8_X_L,
							(U8*)locinput, utf8_target))
				{
				    locinput += UTF8SKIP(locinput);
				}

				/* Here, have exhausted L*.  If the next
				 * character is not an LV, LVT nor V, it means
				 * we had to have at least one L, so matches L+
				 * in the original equation, we have a complete
				 * hangul syllable.  Are done. */

				if (locinput < PL_regeol
				    && swash_fetch(PL_utf8_X_LV_LVT_V,
						    (U8*)locinput, utf8_target))
				{

				    /* Otherwise keep going.  Must be LV, LVT
				     * or V.  See if LVT */
				    if (swash_fetch(PL_utf8_X_LVT,
						    (U8*)locinput, utf8_target))
				    {
					locinput += UTF8SKIP(locinput);
				    } else {

					/* Must be  V or LV.  Take it, then
					 * match V*     */
					locinput += UTF8SKIP(locinput);
					while (locinput < PL_regeol
						&& swash_fetch(PL_utf8_X_V,
							 (U8*)locinput, utf8_target))
					{
					    locinput += UTF8SKIP(locinput);
					}
				    }

				    /* And any of LV, LVT, or V can be followed
				     * by T*            */
				    while (locinput < PL_regeol
					   && swash_fetch(PL_utf8_X_T,
							   (U8*)locinput,
							   utf8_target))
				    {
					locinput += UTF8SKIP(locinput);
				    }
				}
			    }
			}
d4650 7
a4656 8
			/* Match any extender */
			while (locinput < PL_regeol
				&& swash_fetch(PL_utf8_X_extend,
						(U8*)locinput, utf8_target))
			{
			    locinput += UTF8SKIP(locinput);
			}
		    }
d4658 1
a4660 1
	    nextchr = UCHARAT(locinput);
d4663 1
a4663 1
	case NREFFL:
d4676 1
a4676 1
	    PL_reg_flags |= RF_tainted;
d4683 1
a4683 1
	case NREFFA:
d4690 1
a4690 1
	case NREFFU:
d4697 1
a4697 1
	case NREFF:
d4704 1
a4704 1
	case NREF:
d4720 2
a4721 2
	case REFFL:
	    PL_reg_flags |= RF_tainted;
d4727 1
a4727 1
	case REFFA:
d4733 1
a4733 1
	case REFFU:
d4739 1
a4739 1
	case REFF:
d4745 1
a4745 1
        case REF:
d4755 1
a4755 1
	    ln = PL_regoffs[n].start;
d4757 1
a4757 1
	    if (*PL_reglastparen < n || ln == -1)
d4759 1
a4759 1
	    if (ln == PL_regoffs[n].end)
d4771 1
a4771 1
		    * limit upon success, how much of the current input was
d4773 1
a4773 1
		if (! foldEQ_utf8_flags(s, NULL, PL_regoffs[n].end - ln, utf8_target,
a4778 1
		nextchr = UCHARAT(locinput);
d4783 2
a4784 1
	    if (UCHARAT(s) != nextchr &&
d4788 1
a4788 1
	    ln = PL_regoffs[n].end - ln;
a4795 1
	    nextchr = UCHARAT(locinput);
d4798 3
a4800 2
	case NOTHING:
	case TAIL:
d4802 4
a4805 1
	case BACK:
d4817 1
a4817 1
	case GOSTART:
a4831 1
            (void)ReREFCNT_inc(rex_sv);
d4840 2
a4841 1
            /* NOTREACHED */
d4851 1
d4853 2
a4854 2
		SV ** const before = SP;
		OP_4tree * const oop = PL_op;
d4856 1
a4856 1
		PAD *old_comppad;
d4859 5
d4881 3
d4885 79
a4963 1
		PL_op = (OP_4tree*)rexi->data->data[n];
d4965 3
a4967 9
		    "  re_eval 0x%"UVxf"\n", PTR2UV(PL_op)) );
		/* wrap the call in two SAVECOMPPADs. This ensures that
		 * when the save stack is eventually unwound, all the
		 * accumulated SAVEt_CLEARSV's will be processed with
		 * interspersed SAVEt_COMPPAD's to ensure that lexicals
		 * are cleared in the right pad */
		SAVECOMPPAD();
		PAD_SAVE_LOCAL(old_comppad, (PAD*)rexi->data->data[n + 2]);
		PL_regoffs[0].end = PL_reg_magic->mg_len = locinput - PL_bostr;
d4974 5
d4981 1
a4981 1
		if (SP == before)
d4988 38
d5028 4
a5032 2
		SAVECOMPPAD();
		PAD_RESTORE_LOCAL(old_comppad);
d5035 3
a5037 3
		if (!logical) {
		    /* /(?{...})/ */
		    sv_setsv(save_scalar(PL_replgv), ret);
a5038 1
		}
d5040 2
a5041 1
	    if (logical == 2) { /* Postponed subexpression: /(??{...})/ */
a5045 30
		    MAGIC *mg = NULL;
		    REGEXP *rx = NULL;

		    if (SvROK(ret)) {
			SV *const sv = SvRV(ret);

			if (SvTYPE(sv) == SVt_REGEXP) {
			    rx = (REGEXP*) sv;
			} else if (SvSMAGICAL(sv)) {
			    mg = mg_find(sv, PERL_MAGIC_qr);
			    assert(mg);
			}
		    } else if (SvTYPE(ret) == SVt_REGEXP) {
			rx = (REGEXP*) ret;
		    } else if (SvSMAGICAL(ret)) {
			if (SvGMAGICAL(ret)) {
			    /* I don't believe that there is ever qr magic
			       here.  */
			    assert(!mg_find(ret, PERL_MAGIC_qr));
			    sv_unmagic(ret, PERL_MAGIC_qr);
			}
			else {
			    mg = mg_find(ret, PERL_MAGIC_qr);
			    /* testing suggests mg only ends up non-NULL for
			       scalars who were upgraded and compiled in the
			       else block below. In turn, this is only
			       triggered in the "postponed utf8 string" tests
			       in t/op/pat.t  */
			}
		    }
d5047 2
a5048 6
		    if (mg) {
			rx = (REGEXP *) mg->mg_obj; /*XXX:dmq*/
			assert(rx);
		    }
		    if (rx) {
			rx = reg_temp_copy(NULL, rx);
a5051 1
			const I32 osize = PL_regsize;
d5053 3
a5055 8
			if (DO_UTF8(ret)) {
			    assert (SvUTF8(ret));
			} else if (SvUTF8(ret)) {
			    /* Not doing UTF-8, despite what the SV says. Is
			       this only if we're trapped in use 'bytes'?  */
			    /* Make a copy of the octet sequence, but without
			       the flag on, as the compiler now honours the
			       SvUTF8 flag on ret.  */
d5060 13
a5072 1
			rx = CALLREGCOMP(ret, pm_flags);
d5079 1
a5079 1
			    sv_magic(ret, MUTABLE_SV(rx), PERL_MAGIC_qr, 0, 0);
d5081 4
a5084 1
			PL_regsize = osize;
d5086 2
a5087 2
		    re_sv = rx;
		    re = (struct regexp *)SvANY(rx);
d5092 2
a5100 8
               	/* borrowed from regtry */
                if (PL_reg_start_tmpl <= re->nparens) {
                    PL_reg_start_tmpl = re->nparens*3/2 + 3;
                    if(PL_reg_start_tmp)
                        Renew(PL_reg_start_tmp, PL_reg_start_tmpl, char*);
                    else
                        Newx(PL_reg_start_tmp, PL_reg_start_tmpl, char*);
                }               	
d5104 3
a5106 1
		ST.cp = regcppush(0);	/* Save *all* the positions. */
a5108 5
		PL_regoffs = re->offs; /* essentially NOOP on GOSUB */
		
		/* see regtry, specifically PL_reglast(?:close)?paren is a pointer! (i dont know why) :dmq */
		PL_reglastparen = &re->lastparen;
		PL_reglastcloseparen = &re->lastcloseparen;
d5112 1
a5112 2
		PL_reginput = locinput;
		PL_regsize = 0;
d5117 2
a5118 6
		ST.toggle_reg_flags = PL_reg_flags;
		if (RX_UTF8(re_sv))
		    PL_reg_flags |= RF_utf8;
		else
		    PL_reg_flags &= ~RF_utf8;
		ST.toggle_reg_flags ^= PL_reg_flags; /* diff of old and new */
d5122 2
a5123 1
		SETREX(rex_sv,re_sv);
d5131 2
a5132 7
		PUSH_YES_STATE_GOTO(EVAL_AB, startpoint);
		/* NOTREACHED */
	    }
	    /* logical is 1,   /(?(?{...})X|Y)/ */
	    sw = cBOOL(SvTRUE(ret));
	    logical = 0;
	    break;
d5137 4
a5140 4
	    PL_reg_flags ^= ST.toggle_reg_flags; 
	    ReREFCNT_dec(rex_sv);
	    SETREX(rex_sv,ST.prev_rex);
	    rex = (struct regexp *)SvANY(rex_sv);
a5145 6
	    /* rex was changed so update the pointer in PL_reglastparen and PL_reglastcloseparen */
	    PL_reglastparen = &rex->lastparen;
	    PL_reglastcloseparen = &rex->lastcloseparen;
	    /* also update PL_regoffs */
	    PL_regoffs = rex->offs;
	    
d5155 4
a5158 4
	    PL_reg_flags ^= ST.toggle_reg_flags; 
	    ReREFCNT_dec(rex_sv);
	    SETREX(rex_sv,ST.prev_rex);
	    rex = (struct regexp *)SvANY(rex_sv);
a5159 3
	    /* rex was changed so update the pointer in PL_reglastparen and PL_reglastcloseparen */
	    PL_reglastparen = &rex->lastparen;
	    PL_reglastcloseparen = &rex->lastcloseparen;
a5160 1
	    PL_reginput = locinput;
d5162 1
a5162 1
	    regcppop(rex);
d5172 1
a5172 1
	case OPEN:
d5174 11
a5184 3
	    PL_reg_start_tmp[n] = locinput;
	    if (n > PL_regsize)
		PL_regsize = n;
d5187 15
a5201 1
	case CLOSE:
d5203 4
a5206 7
	    PL_regoffs[n].start = PL_reg_start_tmp[n] - PL_bostr;
	    PL_regoffs[n].end = locinput - PL_bostr;
	    /*if (n > PL_regsize)
		PL_regsize = n;*/
	    if (n > *PL_reglastparen)
		*PL_reglastparen = n;
	    *PL_reglastcloseparen = n;
d5211 2
a5212 1
        case ACCEPT:
d5222 4
a5225 8
                            PL_regoffs[n].start
				= PL_reg_start_tmp[n] - PL_bostr;
                            PL_regoffs[n].end = locinput - PL_bostr;
                            /*if (n > PL_regsize)
                            PL_regsize = n;*/
                            if (n > *PL_reglastparen)
                                *PL_reglastparen = n;
                            *PL_reglastcloseparen = n;
d5235 2
a5236 1
	case GROUPP:
d5238 1
a5238 1
	    sw = cBOOL(*PL_reglastparen >= n && PL_regoffs[n].end != -1);
d5240 2
a5241 1
	case NGROUPP:
d5245 2
a5246 1
        case INSUBP:
d5250 2
a5251 1
        case DEFINEP:
d5254 2
a5255 1
	case IFTHEN:
d5265 2
a5266 1
	case LOGICAL:
d5365 3
a5367 3
	       parenfloor > PL_regsize... */
	    if (parenfloor > (I32)*PL_reglastparen)
		parenfloor = *PL_reglastparen; /* Pessimization... */
d5383 2
a5384 3
	    PL_reginput = locinput;
	    PUSH_YES_STATE_GOTO(CURLYX_end, PREVOPER(next));
	    /* NOTREACHED */
d5390 1
a5390 1
	    /* NOTREACHED */
d5396 1
a5396 1
	    /* NOTREACHED */
a5415 1
	    PL_reginput = locinput;
d5425 2
a5426 1
		ST.cp = regcppush(cur_curlyx->u.curlyx.parenfloor);
d5430 2
a5431 2
		PUSH_STATE_GOTO(WHILEM_A_pre, A);
		/* NOTREACHED */
d5502 2
a5503 1
		ST.cp = regcppush(ST.save_curlyx->u.curlyx.parenfloor);
d5505 3
a5507 2
		PUSH_YES_STATE_GOTO(WHILEM_B_min, ST.save_curlyx->u.curlyx.B);
		/* NOTREACHED */
d5513 2
a5514 1
		ST.cp = regcppush(cur_curlyx->u.curlyx.parenfloor);
d5517 2
a5518 2
		PUSH_STATE_GOTO(WHILEM_A_max, A);
		/* NOTREACHED */
d5522 1
a5522 1
	/* NOTREACHED */
d5528 1
a5528 1
	    /* NOTREACHED */
d5535 1
a5535 1
	    /* NOTREACHED */
d5541 1
a5541 1
	    regcppop(rex);
d5545 1
a5545 1
	    /* NOTREACHED */
d5549 1
a5549 2
	    regcppop(rex);	/* Restore some previous $<digit>s? */
	    PL_reginput = locinput;
d5557 1
a5557 1
		&& !(PL_reg_flags & RF_warned))
d5559 1
a5559 1
		PL_reg_flags |= RF_warned;
d5569 3
a5571 2
	    PUSH_YES_STATE_GOTO(WHILEM_B_max, ST.save_curlyx->u.curlyx.B);
	    /* NOTREACHED */
d5576 1
a5576 1
	    regcppop(rex);
d5582 1
a5582 1
		    && !(PL_reg_flags & RF_warned))
d5584 1
a5584 1
		    PL_reg_flags |= RF_warned;
a5597 1
	    PL_reginput = locinput;
d5599 2
a5600 1
	    ST.cp = regcppush(cur_curlyx->u.curlyx.parenfloor);
d5603 3
a5605 2
		/*A*/ NEXTOPER(ST.save_curlyx->u.curlyx.me) + EXTRA_STEP_2ARGS);
	    /* NOTREACHED */
d5619 2
a5620 1
	    ST.lastparen = *PL_reglastparen;
a5622 1
	    PL_reginput = locinput;
d5626 1
a5626 1
	        PUSH_YES_STATE_GOTO(BRANCH_next, scan);    
d5628 1
a5628 1
	        PUSH_STATE_GOTO(BRANCH_next, scan);
d5630 3
a5632 3
	    /* NOTREACHED */
        case CUTGROUP:
            PL_reginput = locinput;
d5635 3
a5637 2
            PUSH_STATE_GOTO(CUTGROUP_next,next);
            /* NOTREACHED */
d5644 2
a5645 1
            /* NOTREACHED */
d5648 2
a5649 1
            /* NOTREACHED */
d5656 1
a5656 4
	    for (n = *PL_reglastparen; n > ST.lastparen; n--)
		PL_regoffs[n].end = -1;
	    *PL_reglastparen = n;
	    /*dmq: *PL_reglastcloseparen = n; */
d5670 1
a5670 1
	    /* NOTREACHED */
d5672 1
a5672 1
	case MINMOD:
d5690 3
d5696 2
a5697 4
		if (paren > PL_regsize)
		    PL_regsize = paren;
		if (paren > *PL_reglastparen)
		    *PL_reglastparen = paren;
d5713 2
a5714 3
	    PL_reginput = locinput;
	    PUSH_YES_STATE_GOTO(CURLYM_A, ST.A); /* match A */
	    /* NOTREACHED */
a5716 3
	    locinput = st->locinput;
	    nextchr = UCHARAT(locinput);

d5721 2
a5722 2
		    char *s = locinput;
		    while (s < PL_reginput) {
d5728 1
a5728 1
		    ST.alen = PL_reginput - locinput;
a5739 2
	    locinput = PL_reginput;
	                
a5759 1
	    PL_reginput = locinput;
d5777 7
a5783 13
		    if (PL_regkind[OP(text_node)] == EXACT)
		    {
		        
			ST.c1 = (U8)*STRING(text_node);
			switch (OP(text_node)) {
			    case EXACTF: ST.c2 = PL_fold[ST.c1]; break;
			    case EXACTFA:
			    case EXACTFU_SS:
			    case EXACTFU_TRICKYFOLD:
			    case EXACTFU: ST.c2 = PL_fold_latin1[ST.c1]; break;
			    case EXACTFL: ST.c2 = PL_fold_locale[ST.c1]; break;
			    default: ST.c2 = ST.c1;
			}
d5794 30
a5823 14
	    if (ST.c1 != CHRTEST_VOID
		    && UCHARAT(PL_reginput) != ST.c1
		    && UCHARAT(PL_reginput) != ST.c2)
	    {
		/* simulate B failing */
		DEBUG_OPTIMISE_r(
		    PerlIO_printf(Perl_debug_log,
		        "%*s  CURLYM Fast bail c1=%"IVdf" c2=%"IVdf"\n",
		        (int)(REPORT_CODE_OFF+(depth*2)),"",
		        (IV)ST.c1,(IV)ST.c2
		));
		state_num = CURLYM_B_fail;
		goto reenter_switch;
	    }
d5826 1
a5826 1
		/* mark current A as captured */
d5829 6
a5834 4
		    PL_regoffs[paren].start
			= HOPc(PL_reginput, -ST.alen) - PL_bostr;
		    PL_regoffs[paren].end = PL_reginput - PL_bostr;
		    /*dmq: *PL_reglastcloseparen = paren; */
d5837 1
a5837 1
		    PL_regoffs[paren].end = -1;
d5848 2
a5849 2
	    PUSH_STATE_GOTO(CURLYM_B, ST.B); /* match B */
	    /* NOTREACHED */
d5853 1
d5864 1
a5864 1
	    locinput = HOPc(locinput, -ST.alen);
d5873 10
a5882 3
	    PL_regoffs[paren].start = HOPc(locinput, -1) - PL_bostr; \
	    PL_regoffs[paren].end = locinput - PL_bostr; \
	    *PL_reglastcloseparen = paren; \
a5883 2
	else \
	    PL_regoffs[paren].end = -1; \
d5886 1
a5886 1
	case STAR:		/*  /A*B/ where A is width 1 */
d5892 2
a5893 1
	case PLUS:		/*  /A+B/ where A is width 1 */
d5899 7
a5905 6
	case CURLYN:		/*  /(A){m,n}B/ where A is width 1 */
	    ST.paren = scan->flags;	/* Which paren to set */
	    if (ST.paren > PL_regsize)
		PL_regsize = ST.paren;
	    if (ST.paren > *PL_reglastparen)
		*PL_reglastparen = ST.paren;
d5915 2
a5916 1
	case CURLY:		/*  /A{m,n}B/ where A is width 1 */
d5931 5
a5935 4
	    if (ST.min > ST.max) /* XXX make this a compile-time check? */
		sayNO;
	    if (HAS_TEXT(next) || JUMPABLE(next)) {
		U8 *s;
a5945 1
			goto assume_ok_easy;
d5947 1
a5947 2
		    else
			s = (U8*)STRING(text_node);
d5955 7
a5961 39
		    if (!UTF_PATTERN) {
			ST.c1 = *s;
			switch (OP(text_node)) {
			    case EXACTF: ST.c2 = PL_fold[ST.c1]; break;
			    case EXACTFA:
			    case EXACTFU_SS:
			    case EXACTFU_TRICKYFOLD:
			    case EXACTFU: ST.c2 = PL_fold_latin1[ST.c1]; break;
			    case EXACTFL: ST.c2 = PL_fold_locale[ST.c1]; break;
			    default: ST.c2 = ST.c1; break;
			}
		    }
		    else { /* UTF_PATTERN */
			if (IS_TEXTFU(text_node) || IS_TEXTF(text_node)) {
			     STRLEN ulen1, ulen2;
			     U8 tmpbuf1[UTF8_MAXBYTES_CASE+1];
			     U8 tmpbuf2[UTF8_MAXBYTES_CASE+1];

			     to_utf8_lower((U8*)s, tmpbuf1, &ulen1);
			     to_utf8_upper((U8*)s, tmpbuf2, &ulen2);
#ifdef EBCDIC
			     ST.c1 = utf8n_to_uvchr(tmpbuf1, UTF8_MAXLEN, 0,
						    ckWARN(WARN_UTF8) ?
                                                    0 : UTF8_ALLOW_ANY);
			     ST.c2 = utf8n_to_uvchr(tmpbuf2, UTF8_MAXLEN, 0,
                                                    ckWARN(WARN_UTF8) ?
                                                    0 : UTF8_ALLOW_ANY);
#else
			     ST.c1 = utf8n_to_uvuni(tmpbuf1, UTF8_MAXBYTES, 0,
						    uniflags);
			     ST.c2 = utf8n_to_uvuni(tmpbuf2, UTF8_MAXBYTES, 0,
						    uniflags);
#endif
			}
			else {
			    ST.c2 = ST.c1 = utf8n_to_uvchr(s, UTF8_MAXBYTES, 0,
						     uniflags);
			}
		    }
a5963 3
	    else
		ST.c1 = ST.c2 = CHRTEST_VOID;
	assume_ok_easy:
a5966 1
	    PL_reginput = locinput;
d5968 1
d5970 3
a5972 1
		if (ST.min && regrepeat(rex, ST.A, ST.min, depth) < ST.min)
d5974 1
a5975 1
		locinput = PL_reginput;
d5993 1
a5993 1
			 m >0 && ST.maxpos + UTF8SKIP(ST.maxpos) <= PL_regeol; m--)
d6005 5
a6009 2
		ST.count = regrepeat(rex, ST.A, ST.max, depth);
		locinput = PL_reginput;
d6012 1
d6022 1
a6022 1
		    if (UCHARAT(PL_reginput - 1) == '\n' && OP(ST.B) != EOS)
d6028 1
a6028 1
	    /* NOTREACHED */
a6032 2
	    if (ST.paren && ST.count)
		PL_regoffs[ST.paren].end = -1;
a6033 1
	    PL_reginput = locinput;	/* Could be reset... */
d6035 3
a6051 1
			STRLEN len;
d6053 4
a6056 5
			while (locinput <= ST.maxpos &&
			       utf8n_to_uvchr((U8*)locinput,
					      UTF8_MAXBYTES, &len,
					      uniflags) != (UV)ST.c1) {
			    locinput += len;
d6062 5
a6066 8
			while (locinput <= ST.maxpos) {
			    STRLEN len;
			    const UV c = utf8n_to_uvchr((U8*)locinput,
						  UTF8_MAXBYTES, &len,
						  uniflags);
			    if (c == (UV)ST.c1 || c == (UV)ST.c2)
				break;
			    locinput += len;
d6071 1
a6071 1
		else {
a6086 1
		/* PL_reginput == oldloc now */
d6088 4
d6093 1
a6093 1
		    if (regrepeat(rex, ST.A, n, depth) < n)
d6095 1
a6096 1
		PL_reginput = locinput;
d6102 1
a6102 1
		PUSH_STATE_GOTO(CURLY_B_min_known, ST.B);
d6104 1
a6104 1
	    /* NOTREACHED */
a6108 2
	    if (ST.paren && ST.count)
		PL_regoffs[ST.paren].end = -1;
d6111 3
d6115 8
a6122 2
	    PL_reginput = locinput;
	    if (regrepeat(rex, ST.A, 1, depth)) {
a6123 1
		locinput = PL_reginput;
d6133 1
a6133 1
		    PUSH_STATE_GOTO(CURLY_B_min, ST.B);
d6136 2
a6137 2
	    sayNO;
	    /* NOTREACHED */
d6147 2
a6148 5
		UV c = 0;
		if (ST.c1 != CHRTEST_VOID)
		    c = utf8_target ? utf8n_to_uvchr((U8*)PL_reginput,
					   UTF8_MAXBYTES, 0, uniflags)
				: (UV) UCHARAT(PL_reginput);
d6150 16
a6165 1
		if (ST.c1 == CHRTEST_VOID || c == (UV)ST.c1 || c == (UV)ST.c2) {
d6167 2
a6168 2
		    PUSH_STATE_GOTO(CURLY_B_max, ST.B);
		    /* NOTREACHED */
d6172 1
a6174 2
	    if (ST.paren && ST.count)
		PL_regoffs[ST.paren].end = -1;
d6177 3
d6183 1
a6183 1
	    PL_reginput = locinput = HOPc(locinput, -1);
d6188 1
a6188 1
	case END:
d6192 2
a6193 4
		I32 tmpix;
		st->u.eval.toggle_reg_flags
			    = cur_eval->u.eval.toggle_reg_flags;
		PL_reg_flags ^= st->u.eval.toggle_reg_flags; 
d6196 6
a6201 2
		SETREX(rex_sv,cur_eval->u.eval.prev_rex);
		rex = (struct regexp *)SvANY(rex_sv);
a6203 6
		(void)ReREFCNT_inc(rex_sv);
		st->u.eval.cp = regcppush(0);	/* Save *all* the positions. */

		/* rex was changed so update the pointer in PL_reglastparen and PL_reglastcloseparen */
		PL_reglastparen = &rex->lastparen;
		PL_reglastcloseparen = &rex->lastcloseparen;
a6205 1
		PL_reginput = locinput;
d6209 2
a6210 4
		tmpix = PL_savestack_ix;
		PL_savestack_ix = cur_eval->u.eval.lastcp;
		regcppop(rex);
		PL_savestack_ix = tmpix;
d6220 2
a6221 2
                PUSH_YES_STATE_GOTO(EVAL_AB,
			st->u.eval.prev_eval->u.eval.B); /* match B */
a6233 1
	    PL_reginput = locinput;	/* put where regtry can find it */
a6240 1
	    PL_reginput = locinput;	/* put where regtry can find it */
d6246 3
d6251 1
a6251 1
	    PL_reginput = locinput;
d6276 1
a6276 1
		PL_reginput = s;
d6279 1
a6279 1
		PL_reginput = locinput;
d6287 3
a6289 2
	    PUSH_YES_STATE_GOTO(IFMATCH_A, NEXTOPER(NEXTOPER(scan)));
	    /* NOTREACHED */
d6302 3
a6304 5
	    if (OP(ST.me) == SUSPEND)
		locinput = PL_reginput;
	    else {
		locinput = PL_reginput = st->locinput;
		nextchr = UCHARAT(locinput);
d6313 2
a6314 1
	case LONGJMP:
d6319 2
a6320 1
	case COMMIT:
d6323 2
a6324 2
	case PRUNE:
	    PL_reginput = locinput;
d6327 3
a6329 2
	    PUSH_STATE_GOTO(COMMIT_next,next);
	    /* NOTREACHED */
d6333 2
a6334 1
	case OPFAIL:
d6336 1
a6336 1
	    /* NOTREACHED */
d6339 1
a6339 1
        case MARKPOINT:
d6344 4
a6347 3
            ST.mark_loc = PL_reginput = locinput;
            PUSH_YES_STATE_GOTO(MARKPOINT_next,next);
            /* NOTREACHED */
d6351 2
a6352 1
            /* NOTREACHED */
d6372 3
a6374 3
            /* NOTREACHED */
        case SKIP:
            PL_reginput = locinput;
d6379 1
a6379 1
                PUSH_STATE_GOTO(SKIP_next,next);    
d6392 1
a6392 1
                        PUSH_STATE_GOTO( SKIP_next, next );
d6399 1
d6417 1
a6417 1
            /* NOTREACHED */
d6419 3
a6421 2
        case LNBREAK:
            if ((n=is_LNBREAK(locinput,utf8_target))) {
a6422 1
                nextchr = UCHARAT(locinput);
a6426 25
#define CASE_CLASS(nAmE)                              \
        case nAmE:                                    \
	    if (locinput >= PL_regeol)                \
		sayNO;                                \
            if ((n=is_##nAmE(locinput,utf8_target))) {    \
                locinput += n;                        \
                nextchr = UCHARAT(locinput);          \
            } else                                    \
                sayNO;                                \
            break;                                    \
        case N##nAmE:                                 \
	    if (locinput >= PL_regeol)                \
		sayNO;                                \
            if ((n=is_##nAmE(locinput,utf8_target))) {    \
                sayNO;                                \
            } else {                                  \
                locinput += UTF8SKIP(locinput);       \
                nextchr = UCHARAT(locinput);          \
            }                                         \
            break

        CASE_CLASS(VERTWS);
        CASE_CLASS(HORIZWS);
#undef CASE_CLASS

d6431 14
d6451 1
a6451 1
	/* NOTREACHED */
d6491 1
a6491 2
	    locinput = PL_reginput;
	    nextchr = UCHARAT(locinput);
d6494 1
a6494 1
	    /* NOTREACHED */
d6542 1
a6542 1
        if (no_final) {
a6543 2
            nextchr = UCHARAT(locinput);
        }
d6551 1
a6551 1
    if (PL_reg_eval_set) {
a6587 1
	nextchr = UCHARAT(locinput);
d6616 7
d6626 2
a6627 1
    return result;
d6632 10
a6641 5
 */
/*
 * [This routine now assumes that it will only match on things of length 1.
 * That was true before, but now we assume scan - reginput is the count,
 * rather than incrementing count on every character.  [Er, except utf8.]]
d6644 2
a6645 1
S_regrepeat(pTHX_ const regexp *prog, const regnode *p, I32 max, int depth)
d6648 6
a6653 5
    register char *scan;
    register I32 c;
    register char *loceol = PL_regeol;
    register I32 hardcount = 0;
    register bool utf8_target = PL_reg_match_utf8;
d6655 1
d6662 1
a6662 1
    scan = PL_reginput;
d6665 1
a6665 1
    else if (max < loceol - scan)
d6667 24
a6693 1
	    loceol = PL_regeol;
a6704 1
	    loceol = PL_regeol;
d6713 12
a6724 11
    case CANY:
	scan = loceol;
	break;
    case EXACT:
	/* To get here, EXACTish nodes must have *byte* length == 1.  That
	 * means they match only characters in the string that can be expressed
	 * as a single byte.  For non-utf8 strings, that means a simple match.
	 * For utf8 strings, the character matched must be an invariant, or
	 * downgradable to a single byte.  The pattern's utf8ness is
	 * irrelevant, as since it's a single byte, it either isn't utf8, or if
	 * it is, it's an invariant */
a6726 1
	assert(! UTF_PATTERN || UNI_IS_INVARIANT(c));
d6728 10
a6737 1
	if (! utf8_target || UNI_IS_INVARIANT(c)) {
d6742 27
a6768 1
	else {
d6770 4
a6773 4
	    /* Here, the string is utf8, and the pattern char is different
	     * in utf8 than not, so can't compare them directly.  Outside the
	     * loop, find the two utf8 bytes that represent c, and then
	     * look for those in sequence in the utf8 string */
a6775 1
	    loceol = PL_regeol;
d6787 1
d6793 1
a6793 1
	PL_reg_flags |= RF_tainted;
d6804 1
a6804 1
	utf8_flags = (UTF_PATTERN) ? FOLDEQ_S2_ALREADY_FOLDED : 0;
d6806 3
a6808 2
	/* The comments for the EXACT case above apply as well to these fold
	 * ones */
d6810 1
a6810 3
    do_exactf:
	c = (U8)*STRING(p);
	assert(! UTF_PATTERN || UNI_IS_INVARIANT(c));
d6812 50
a6861 41
	if (utf8_target || OP(p) == EXACTFU_SS) { /* Use full Unicode fold matching */
	    char *tmpeol = loceol;
	    while (hardcount < max
		    && foldEQ_utf8_flags(scan, &tmpeol, 0, utf8_target,
				   STRING(p), NULL, 1, cBOOL(UTF_PATTERN), utf8_flags))
	    {
		scan = tmpeol;
		tmpeol = loceol;
		hardcount++;
	    }

	    /* XXX Note that the above handles properly the German sharp s in
	     * the pattern matching ss in the string.  But it doesn't handle
	     * properly cases where the string contains say 'LIGATURE ff' and
	     * the pattern is 'f+'.  This would require, say, a new function or
	     * revised interface to foldEQ_utf8(), in which the maximum number
	     * of characters to match could be passed and it would return how
	     * many actually did.  This is just one of many cases where
	     * multi-char folds don't work properly, and so the fix is being
	     * deferred */
	}
	else {
	    U8 folded;

	    /* Here, the string isn't utf8 and c is a single byte; and either
	     * the pattern isn't utf8 or c is an invariant, so its utf8ness
	     * doesn't affect c.  Can just do simple comparisons for exact or
	     * fold matching. */
	    switch (OP(p)) {
		case EXACTF: folded = PL_fold[c]; break;
		case EXACTFA:
		case EXACTFU_TRICKYFOLD:
		case EXACTFU: folded = PL_fold_latin1[c]; break;
		case EXACTFL: folded = PL_fold_locale[c]; break;
		default: Perl_croak(aTHX_ "panic: Unexpected op %u", OP(p));
	    }
	    while (scan < loceol &&
		   (UCHARAT(scan) == c || UCHARAT(scan) == folded))
	    {
		scan++;
	    }
d6864 1
a6864 1
    case ANYOFV:
d6866 2
a6867 4
	if (utf8_target || OP(p) == ANYOFV) {
	    STRLEN inclasslen;
	    loceol = PL_regeol;
	    inclasslen = loceol - scan;
d6869 2
a6870 2
		   && ((inclasslen = loceol - scan) > 0)
		   && reginclass(prog, p, (U8*)scan, &inclasslen, utf8_target))
d6872 1
a6872 1
		scan += inclasslen;
d6880 12
a6891 7
    case ALNUMU:
	if (utf8_target) {
    utf8_wordchar:
	    loceol = PL_regeol;
	    LOAD_UTF8_CHARCLASS_ALNUM();
	    while (hardcount < max && scan < loceol &&
                   swash_fetch(PL_utf8_alnum, (U8*)scan, utf8_target))
d6893 1
a6893 6
		scan += UTF8SKIP(scan);
		hardcount++;
	    }
        } else {
            while (scan < loceol && isWORDCHAR_L1((U8) *scan)) {
                scan++;
d6895 6
a6900 21
	}
	break;
    case ALNUM:
	if (utf8_target)
	    goto utf8_wordchar;
	while (scan < loceol && isALNUM((U8) *scan)) {
	    scan++;
	}
	break;
    case ALNUMA:
	while (scan < loceol && isWORDCHAR_A((U8) *scan)) {
	    scan++;
	}
	break;
    case ALNUML:
	PL_reg_flags |= RF_tainted;
	if (utf8_target) {
	    loceol = PL_regeol;
	    while (hardcount < max && scan < loceol &&
		   isALNUM_LC_utf8((U8*)scan)) {
		scan += UTF8SKIP(scan);
a6902 3
	} else {
	    while (scan < loceol && isALNUM_LC(*scan))
		scan++;
a6904 2
    case NALNUMU:
	if (utf8_target) {
d6906 8
a6913 1
    utf8_Nwordchar:
d6915 6
a6920 18
	    loceol = PL_regeol;
	    LOAD_UTF8_CHARCLASS_ALNUM();
	    while (hardcount < max && scan < loceol &&
                   ! swash_fetch(PL_utf8_alnum, (U8*)scan, utf8_target))
            {
		scan += UTF8SKIP(scan);
		hardcount++;
	    }
        } else {
            while (scan < loceol && ! isWORDCHAR_L1((U8) *scan)) {
                scan++;
            }
	}
	break;
    case NALNUM:
	if (utf8_target)
	    goto utf8_Nwordchar;
	while (scan < loceol && ! isALNUM((U8) *scan)) {
a6923 28
    case NALNUMA:
	if (utf8_target) {
	    while (scan < loceol && ! isWORDCHAR_A((U8) *scan)) {
		scan += UTF8SKIP(scan);
	    }
	}
	else {
	    while (scan < loceol && ! isWORDCHAR_A((U8) *scan)) {
		scan++;
	    }
	}
	break;
    case NALNUML:
	PL_reg_flags |= RF_tainted;
	if (utf8_target) {
	    loceol = PL_regeol;
	    while (hardcount < max && scan < loceol &&
		   !isALNUM_LC_utf8((U8*)scan)) {
		scan += UTF8SKIP(scan);
		hardcount++;
	    }
	} else {
	    while (scan < loceol && !isALNUM_LC(*scan))
		scan++;
	}
	break;
    case SPACEU:
	if (utf8_target) {
d6925 6
a6930 1
    utf8_space:
d6932 3
a6934 13
	    loceol = PL_regeol;
	    LOAD_UTF8_CHARCLASS_SPACE();
	    while (hardcount < max && scan < loceol &&
		   (*scan == ' ' ||
                    swash_fetch(PL_utf8_space,(U8*)scan, utf8_target)))
            {
		scan += UTF8SKIP(scan);
		hardcount++;
	    }
	    break;
	}
	else {
            while (scan < loceol && isSPACE_L1((U8) *scan)) {
d6937 2
a6938 5
	    break;
	}
    case SPACE:
	if (utf8_target)
	    goto utf8_space;
d6940 8
a6947 16
	while (scan < loceol && isSPACE((U8) *scan)) {
	    scan++;
	}
	break;
    case SPACEA:
	while (scan < loceol && isSPACE_A((U8) *scan)) {
	    scan++;
	}
	break;
    case SPACEL:
	PL_reg_flags |= RF_tainted;
	if (utf8_target) {
	    loceol = PL_regeol;
	    while (hardcount < max && scan < loceol &&
		   isSPACE_LC_utf8((U8*)scan)) {
		scan += UTF8SKIP(scan);
d6950 2
a6951 9
	} else {
	    while (scan < loceol && isSPACE_LC(*scan))
		scan++;
	}
	break;
    case NSPACEU:
	if (utf8_target) {

    utf8_Nspace:
d6953 8
a6960 5
	    loceol = PL_regeol;
	    LOAD_UTF8_CHARCLASS_SPACE();
	    while (hardcount < max && scan < loceol &&
		   ! (*scan == ' ' ||
                      swash_fetch(PL_utf8_space,(U8*)scan, utf8_target)))
d6962 2
a6963 4
		scan += UTF8SKIP(scan);
		hardcount++;
	    }
	    break;
d6966 95
a7060 2
            while (scan < loceol && ! isSPACE_L1((U8) *scan)) {
                scan++;
d7063 24
a7086 4
	break;
    case NSPACE:
	if (utf8_target)
	    goto utf8_Nspace;
a7087 103
	while (scan < loceol && ! isSPACE((U8) *scan)) {
	    scan++;
	}
	break;
    case NSPACEA:
	if (utf8_target) {
	    while (scan < loceol && ! isSPACE_A((U8) *scan)) {
		scan += UTF8SKIP(scan);
	    }
	}
	else {
	    while (scan < loceol && ! isSPACE_A((U8) *scan)) {
		scan++;
	    }
	}
	break;
    case NSPACEL:
	PL_reg_flags |= RF_tainted;
	if (utf8_target) {
	    loceol = PL_regeol;
	    while (hardcount < max && scan < loceol &&
		   !isSPACE_LC_utf8((U8*)scan)) {
		scan += UTF8SKIP(scan);
		hardcount++;
	    }
	} else {
	    while (scan < loceol && !isSPACE_LC(*scan))
		scan++;
	}
	break;
    case DIGIT:
	if (utf8_target) {
	    loceol = PL_regeol;
	    LOAD_UTF8_CHARCLASS_DIGIT();
	    while (hardcount < max && scan < loceol &&
		   swash_fetch(PL_utf8_digit, (U8*)scan, utf8_target)) {
		scan += UTF8SKIP(scan);
		hardcount++;
	    }
	} else {
	    while (scan < loceol && isDIGIT(*scan))
		scan++;
	}
	break;
    case DIGITA:
	while (scan < loceol && isDIGIT_A((U8) *scan)) {
	    scan++;
	}
	break;
    case DIGITL:
	PL_reg_flags |= RF_tainted;
	if (utf8_target) {
	    loceol = PL_regeol;
	    while (hardcount < max && scan < loceol &&
		   isDIGIT_LC_utf8((U8*)scan)) {
		scan += UTF8SKIP(scan);
		hardcount++;
	    }
	} else {
	    while (scan < loceol && isDIGIT_LC(*scan))
		scan++;
	}
	break;
    case NDIGIT:
	if (utf8_target) {
	    loceol = PL_regeol;
	    LOAD_UTF8_CHARCLASS_DIGIT();
	    while (hardcount < max && scan < loceol &&
		   !swash_fetch(PL_utf8_digit, (U8*)scan, utf8_target)) {
		scan += UTF8SKIP(scan);
		hardcount++;
	    }
	} else {
	    while (scan < loceol && !isDIGIT(*scan))
		scan++;
	}
	break;
    case NDIGITA:
	if (utf8_target) {
	    while (scan < loceol && ! isDIGIT_A((U8) *scan)) {
		scan += UTF8SKIP(scan);
	    }
	}
	else {
	    while (scan < loceol && ! isDIGIT_A((U8) *scan)) {
		scan++;
	    }
	}
	break;
    case NDIGITL:
	PL_reg_flags |= RF_tainted;
	if (utf8_target) {
	    loceol = PL_regeol;
	    while (hardcount < max && scan < loceol &&
		   !isDIGIT_LC_utf8((U8*)scan)) {
		scan += UTF8SKIP(scan);
		hardcount++;
	    }
	} else {
	    while (scan < loceol && !isDIGIT_LC(*scan))
		scan++;
	}
	break;
d7090 2
a7091 2
	    loceol = PL_regeol;
	    while (hardcount < max && scan < loceol && (c=is_LNBREAK_utf8(scan))) {
d7096 5
a7100 6
	    /*
	      LNBREAK can match two latin chars, which is ok,
	      because we have a null terminated string, but we
	      have to use hardcount in this situation
	    */
	    while (scan < loceol && (c=is_LNBREAK_latin1(scan)))  {
d7104 1
a7104 13
	}	
	break;
    case HORIZWS:
        if (utf8_target) {
	    loceol = PL_regeol;
	    while (hardcount < max && scan < loceol && (c=is_HORIZWS_utf8(scan))) {
		scan += c;
		hardcount++;
	    }
	} else {
	    while (scan < loceol && is_HORIZWS_latin1(scan)) 
		scan++;		
	}	
a7105 10
    case NHORIZWS:
        if (utf8_target) {
	    loceol = PL_regeol;
	    while (hardcount < max && scan < loceol && !is_HORIZWS_utf8(scan)) {
		scan += UTF8SKIP(scan);
		hardcount++;
	    }
	} else {
	    while (scan < loceol && !is_HORIZWS_latin1(scan))
		scan++;
d7107 20
a7126 28
	}	
	break;
    case VERTWS:
        if (utf8_target) {
	    loceol = PL_regeol;
	    while (hardcount < max && scan < loceol && (c=is_VERTWS_utf8(scan))) {
		scan += c;
		hardcount++;
	    }
	} else {
	    while (scan < loceol && is_VERTWS_latin1(scan)) 
		scan++;

	}	
	break;
    case NVERTWS:
        if (utf8_target) {
	    loceol = PL_regeol;
	    while (hardcount < max && scan < loceol && !is_VERTWS_utf8(scan)) {
		scan += UTF8SKIP(scan);
		hardcount++;
	    }
	} else {
	    while (scan < loceol && !is_VERTWS_latin1(scan)) 
		scan++;
          
	}	
	break;
a7127 2
    default:		/* Called on something of 0 width. */
	break;		/* So match right here or not at all. */
d7133 2
a7134 2
	c = scan - PL_reginput;
    PL_reginput = scan;
d7154 2
a7155 1
create a copy so that changes the caller makes won't change the shared one
d7158 1
a7158 1
Perl_regclass_swash(pTHX_ const regexp *prog, register const regnode* node, bool doinit, SV** listsvp, SV **altsvp)
d7161 6
a7166 1
    return newSVsv(core_regclass_swash(prog, node, doinit, listsvp, altsvp));
d7171 1
a7171 1
S_core_regclass_swash(pTHX_ const regexp *prog, register const regnode* node, bool doinit, SV** listsvp, SV **altsvp)
a7177 2
     * If <altsvp> is non-null, will return the alternates to the regular swash
     *	  in it
a7182 1
    SV *alt = NULL;
d7199 1
a7199 1
	    bool invlist_has_user_defined_property;
d7203 2
a7204 2
	    /* Elements 3 and 4 are either both present or both absent. [3] is
	     * any inversion list generated at compile time; [4] indicates if
d7206 5
a7210 3
	    if (av_len(av) >= 3) {
		invlist = ary[3];
		invlist_has_user_defined_property = cBOOL(SvUV(ary[4]));
a7213 1
		invlist_has_user_defined_property = FALSE;
a7227 2
				      FALSE, /* is error if can't find
						property */
d7229 1
a7229 1
				      invlist_has_user_defined_property);
a7231 7

	    /* Element [2] is for any multi-char folds.  Note that is a
	     * fundamentally flawed design, because can't backtrack and try
	     * again.  See [perl #89774] */
	    if (SvTYPE(ary[2]) == SVt_PVAV) {
	        alt = ary[2];
	    }
a7236 1
	SV** invlistsvp;
d7240 3
a7242 8
	if (   sw
	    && SvROK(sw)
	    && SvTYPE(SvRV(sw)) == SVt_PVHV
	    && (invlistsvp = hv_fetchs(MUTABLE_HV(SvRV(sw)), "INVLIST", FALSE)))
	{
	    invlist = *invlistsvp;
	}
	else if (si && si != &PL_sv_undef) {
d7244 1
a7244 1
	    /* If no swash, use the input nitialization string, if available */
a7255 3
    if (altsvp)
	*altsvp  = alt;

a7263 3
  lenp is pointer to the maximum number of bytes of how far to go in p
    (This is assumed wthout checking to always be at least the current
    character's size)
d7266 1
a7266 4
  Returns true if matched; false otherwise.  If lenp is not NULL, on return
  from a successful match, the value it points to will be updated to how many
  bytes in p were matched.  If there was no match, the value is undefined,
  possibly changed from the input.
d7275 1
a7275 1
S_reginclass(pTHX_ const regexp * const prog, register const regnode * const n, register const U8* const p, STRLEN* lenp, register const bool utf8_target)
a7280 2
    STRLEN c_len = 0;
    STRLEN maxlen;
d7284 4
a7287 2
    /* If c is not already the code point, get it */
    if (utf8_target && !UTF8_IS_INVARIANT(c)) {
a7295 15
    else {
	c_len = 1;
    }

    /* Use passed in max length, or one character if none passed in or less
     * than one character.  And assume will match just one character.  This is
     * overwritten later if matched more. */
    if (lenp) {
	maxlen = (*lenp > c_len) ? *lenp : c_len;
	*lenp = c_len;

    }
    else {
	maxlen = c_len;
    }
a7306 1

d7308 1
a7308 1
	    PL_reg_flags |= RF_tainted;
d7310 1
a7310 1
	    if ((flags & ANYOF_LOC_NONBITMAP_FOLD)
d7315 44
a7358 34
	    else if (ANYOF_CLASS_TEST_ANY_SET(n) &&
		     ((ANYOF_CLASS_TEST(n, ANYOF_ALNUM)   &&  isALNUM_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_NALNUM)  && !isALNUM_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_SPACE)   &&  isSPACE_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_NSPACE)  && !isSPACE_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_DIGIT)   &&  isDIGIT_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_NDIGIT)  && !isDIGIT_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_ALNUMC)  &&  isALNUMC_LC(c)) ||
		      (ANYOF_CLASS_TEST(n, ANYOF_NALNUMC) && !isALNUMC_LC(c)) ||
		      (ANYOF_CLASS_TEST(n, ANYOF_ALPHA)   &&  isALPHA_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_NALPHA)  && !isALPHA_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_ASCII)   &&  isASCII_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_NASCII)  && !isASCII_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_CNTRL)   &&  isCNTRL_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_NCNTRL)  && !isCNTRL_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_GRAPH)   &&  isGRAPH_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_NGRAPH)  && !isGRAPH_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_LOWER)   &&  isLOWER_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_NLOWER)  && !isLOWER_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_PRINT)   &&  isPRINT_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_NPRINT)  && !isPRINT_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_PUNCT)   &&  isPUNCT_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_NPUNCT)  && !isPUNCT_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_UPPER)   &&  isUPPER_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_NUPPER)  && !isUPPER_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_XDIGIT)  &&  isXDIGIT(c))    ||
		      (ANYOF_CLASS_TEST(n, ANYOF_NXDIGIT) && !isXDIGIT(c))    ||
		      (ANYOF_CLASS_TEST(n, ANYOF_PSXSPC)  &&  isPSXSPC(c))    ||
		      (ANYOF_CLASS_TEST(n, ANYOF_NPSXSPC) && !isPSXSPC(c))    ||
		      (ANYOF_CLASS_TEST(n, ANYOF_BLANK)   &&  isBLANK_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_NBLANK)  && !isBLANK_LC(c))
		     ) /* How's that for a conditional? */
	    ) {
		match = TRUE;
d7364 1
a7364 1
     * bitmap could match, try that.  Locale nodes specifiy completely the
d7381 1
a7381 1
			     || (flags & ANYOF_IS_SYNTHETIC)))))
d7383 1
a7383 3
	    AV *av;
	    SV * const sw = core_regclass_swash(prog, n, TRUE, 0, (SV**)&av);

d7388 2
a7389 16
		} else {

		    /* Not utf8.  Convert as much of the string as available up
		     * to the limit of how far the (single) character in the
		     * pattern can possibly match (no need to go further).  If
		     * the node is a straight ANYOF or not folding, it can't
		     * match more than one.  Otherwise, It can match up to how
		     * far a single char can fold to.  Since not utf8, each
		     * character is a single byte, so the max it can be in
		     * bytes is the same as the max it can be in characters */
		    STRLEN len = (OP(n) == ANYOF
				  || ! (flags & ANYOF_LOC_NONBITMAP_FOLD))
				  ? 1
				  : (maxlen < UTF8_MAX_FOLD_CHAR_EXPAND)
				    ? maxlen
				    : UTF8_MAX_FOLD_CHAR_EXPAND;
d7393 1
a7393 1
		if (swash_fetch(sw, utf8_p, TRUE))
d7395 1
a7395 133
		else if (flags & ANYOF_LOC_NONBITMAP_FOLD) {

		    /* Here, we need to test if the fold of the target string
		     * matches.  The non-multi char folds have all been moved to
                     * the compilation phase, and the multi-char folds have
                     * been stored by regcomp into 'av'; we linearly check to
                     * see if any match the target string (folded).   We know
                     * that the originals were each one character, but we don't
                     * currently know how many characters/bytes each folded to,
                     * except we do know that there are small limits imposed by
                     * Unicode.  XXX A performance enhancement would be to have
                     * regcomp.c store the max number of chars/bytes that are
                     * in an av entry, as, say the 0th element.  Even better
                     * would be to have a hash of the few characters that can
                     * start a multi-char fold to the max number of chars of
                     * those folds.
		     *
		     * If there is a match, we will need to advance (if lenp is
		     * specified) the match pointer in the target string.  But
		     * what we are comparing here isn't that string directly,
		     * but its fold, whose length may differ from the original.
		     * As we go along in constructing the fold, therefore, we
		     * create a map so that we know how many bytes in the
		     * source to advance given that we have matched a certain
		     * number of bytes in the fold.  This map is stored in
		     * 'map_fold_len_back'.  Let n mean the number of bytes in
		     * the fold of the first character that we are folding.
		     * Then map_fold_len_back[n] is set to the number of bytes
		     * in that first character.  Similarly let m be the
		     * corresponding number for the second character to be
		     * folded.  Then map_fold_len_back[n+m] is set to the
		     * number of bytes occupied by the first two source
		     * characters. ... */
		    U8 map_fold_len_back[UTF8_MAXBYTES_CASE+1] = { 0 };
		    U8 folded[UTF8_MAXBYTES_CASE+1];
		    STRLEN foldlen = 0; /* num bytes in fold of 1st char */
		    STRLEN total_foldlen = 0; /* num bytes in fold of all
						  chars */

		    if (OP(n) == ANYOF || maxlen == 1 || ! lenp || ! av) {

			/* Here, only need to fold the first char of the target
			 * string.  It the source wasn't utf8, is 1 byte long */
			to_utf8_fold(utf8_p, folded, &foldlen);
			total_foldlen = foldlen;
			map_fold_len_back[foldlen] = (utf8_target)
						     ? UTF8SKIP(utf8_p)
						     : 1;
		    }
		    else {

			/* Here, need to fold more than the first char.  Do so
			 * up to the limits */
			U8* source_ptr = utf8_p;    /* The source for the fold
						       is the regex target
						       string */
			U8* folded_ptr = folded;
			U8* e = utf8_p + maxlen;    /* Can't go beyond last
						       available byte in the
						       target string */
			U8 i;
			for (i = 0;
			     i < UTF8_MAX_FOLD_CHAR_EXPAND && source_ptr < e;
			     i++)
			{

			    /* Fold the next character */
			    U8 this_char_folded[UTF8_MAXBYTES_CASE+1];
			    STRLEN this_char_foldlen;
			    to_utf8_fold(source_ptr,
				         this_char_folded,
					 &this_char_foldlen);

			    /* Bail if it would exceed the byte limit for
			     * folding a single char. */
			    if (this_char_foldlen + folded_ptr - folded >
							    UTF8_MAXBYTES_CASE)
			    {
				break;
			    }

			    /* Add the fold of this character */
			    Copy(this_char_folded,
				 folded_ptr,
				 this_char_foldlen,
				 U8);
			    source_ptr += UTF8SKIP(source_ptr);
			    folded_ptr += this_char_foldlen;
			    total_foldlen = folded_ptr - folded;

			    /* Create map from the number of bytes in the fold
			     * back to the number of bytes in the source.  If
			     * the source isn't utf8, the byte count is just
			     * the number of characters so far */
			    map_fold_len_back[total_foldlen]
						      = (utf8_target)
							? source_ptr - utf8_p
							: i + 1;
			}
			*folded_ptr = '\0';
		    }


		    /* Do the linear search to see if the fold is in the list
		     * of multi-char folds. */
		    if (av) {
		        I32 i;
			for (i = 0; i <= av_len(av); i++) {
			    SV* const sv = *av_fetch(av, i, FALSE);
			    STRLEN len;
			    const char * const s = SvPV_const(sv, len);

			    if (len <= total_foldlen
				&& memEQ(s, (char*)folded, len)

				   /* If 0, means matched a partial char. See
				    * [perl #90536] */
				&& map_fold_len_back[len])
			    {

				/* Advance the target string ptr to account for
				 * this fold, but have to translate from the
				 * folded length to the corresponding source
				 * length. */
				if (lenp) {
				    *lenp = map_fold_len_back[len];
				}
				match = TRUE;
				break;
			    }
			}
		    }
		}
d7401 8
d7411 2
a7412 1
    return (flags & ANYOF_INVERT) ? !match : match;
d7512 1
a7512 1
    if (PL_reg_eval_set) {
d7516 3
a7518 1
#ifdef PERL_OLD_COPY_ON_WRITE
d7524 1
a7524 1
	PL_reg_eval_set = 0;
d7530 1
a7530 1
S_to_utf8_substr(pTHX_ register regexp *prog)
d7532 3
d7563 2
a7564 2
STATIC void
S_to_byte_substr(pTHX_ register regexp *prog)
d7566 3
d7578 12
a7589 14
	    if (sv_utf8_downgrade(sv, TRUE)) {
		if (SvVALID(prog->substrs->data[i].utf8_substr)) {
		    if (SvTAIL(prog->substrs->data[i].utf8_substr)) {
			/* Trim the trailing \n that fbm_compile added last
			   time.  */
			SvCUR_set(sv, SvCUR(sv) - 1);
			fbm_compile(sv, FBMcf_TAIL);
		    } else
			fbm_compile(sv, 0);
		}
	    } else {
		SvREFCNT_dec(sv);
		sv = &PL_sv_undef;
	    }
d7595 2
d7603 1
a7603 1
 * indent-tabs-mode: t
d7606 1
a7606 1
 * ex: set ts=8 sts=4 sw=4 noet:
@


1.14
log
@merge in perl 5.12.2 plus local changes
@
text
@d83 1
a83 1
#define RF_tainted	1		/* tainted information used? */
d88 1
a88 1
#define UTF ((PL_reg_flags & RF_utf8) != 0)
d97 5
a101 1
#define REGINCLASS(prog,p,c)  (ANYOF_FLAGS(p) ? reginclass(prog,p,c,0,0) : ANYOF_BITMAP_TEST(p,*(c)))
d107 1
a107 1
#define CHR_SVLEN(sv) (do_utf8 ? sv_len_utf8(sv) : SvCUR(sv))
d125 12
a136 2
#define LOAD_UTF8_CHARCLASS(class,str) STMT_START { \
    if (!CAT2(PL_utf8_,class)) { bool ok; ENTER; save_re_context(); ok=CAT2(is_utf8_,class)((const U8*)str); assert(ok); LEAVE; } } STMT_END
d140 5
a144 1
    if (!CAT2(PL_utf8_,class)) { bool ok; ENTER; save_re_context(); ok=CAT2(is_utf8_,class)((const U8*)" "); LEAVE; } } STMT_END
d167 1
a167 94
/* 
   We dont use PERL_LEGACY_UNICODE_CHARCLASS_MAPPINGS as the direct test
   so that it is possible to override the option here without having to 
   rebuild the entire core. as we are required to do if we change regcomp.h
   which is where PERL_LEGACY_UNICODE_CHARCLASS_MAPPINGS is defined.
*/
#if PERL_LEGACY_UNICODE_CHARCLASS_MAPPINGS
#define BROKEN_UNICODE_CHARCLASS_MAPPINGS
#endif

#ifdef BROKEN_UNICODE_CHARCLASS_MAPPINGS
#define LOAD_UTF8_CHARCLASS_PERL_WORD()   LOAD_UTF8_CHARCLASS_ALNUM()
#define LOAD_UTF8_CHARCLASS_PERL_SPACE()  LOAD_UTF8_CHARCLASS_SPACE()
#define LOAD_UTF8_CHARCLASS_POSIX_DIGIT() LOAD_UTF8_CHARCLASS_DIGIT()
#define RE_utf8_perl_word   PL_utf8_alnum
#define RE_utf8_perl_space  PL_utf8_space
#define RE_utf8_posix_digit PL_utf8_digit
#define perl_word  alnum
#define perl_space space
#define posix_digit digit
#else
#define LOAD_UTF8_CHARCLASS_PERL_WORD()   LOAD_UTF8_CHARCLASS(perl_word,"a")
#define LOAD_UTF8_CHARCLASS_PERL_SPACE()  LOAD_UTF8_CHARCLASS(perl_space," ")
#define LOAD_UTF8_CHARCLASS_POSIX_DIGIT() LOAD_UTF8_CHARCLASS(posix_digit,"0")
#define RE_utf8_perl_word   PL_utf8_perl_word
#define RE_utf8_perl_space  PL_utf8_perl_space
#define RE_utf8_posix_digit PL_utf8_posix_digit
#endif


#define CCC_TRY_AFF(NAME,NAMEL,CLASS,STR,LCFUNC_utf8,FUNC,LCFUNC)                          \
        case NAMEL:                                                              \
            PL_reg_flags |= RF_tainted;                                                 \
            /* FALL THROUGH */                                                          \
        case NAME:                                                                     \
            if (!nextchr)                                                               \
                sayNO;                                                                  \
            if (do_utf8 && UTF8_IS_CONTINUED(nextchr)) {                                \
                if (!CAT2(PL_utf8_,CLASS)) {                                            \
                    bool ok;                                                            \
                    ENTER;                                                              \
                    save_re_context();                                                  \
                    ok=CAT2(is_utf8_,CLASS)((const U8*)STR);                            \
                    assert(ok);                                                         \
                    LEAVE;                                                              \
                }                                                                       \
                if (!(OP(scan) == NAME                                                  \
                    ? (bool)swash_fetch(CAT2(PL_utf8_,CLASS), (U8*)locinput, do_utf8)   \
                    : LCFUNC_utf8((U8*)locinput)))                                      \
                {                                                                       \
                    sayNO;                                                              \
                }                                                                       \
                locinput += PL_utf8skip[nextchr];                                       \
                nextchr = UCHARAT(locinput);                                            \
                break;                                                                  \
            }                                                                           \
            if (!(OP(scan) == NAME ? FUNC(nextchr) : LCFUNC(nextchr)))                  \
                sayNO;                                                                  \
            nextchr = UCHARAT(++locinput);                                              \
            break

#define CCC_TRY_NEG(NAME,NAMEL,CLASS,STR,LCFUNC_utf8,FUNC,LCFUNC)                        \
        case NAMEL:                                                              \
            PL_reg_flags |= RF_tainted;                                                 \
            /* FALL THROUGH */                                                          \
        case NAME :                                                                     \
            if (!nextchr && locinput >= PL_regeol)                                      \
                sayNO;                                                                  \
            if (do_utf8 && UTF8_IS_CONTINUED(nextchr)) {                                \
                if (!CAT2(PL_utf8_,CLASS)) {                                            \
                    bool ok;                                                            \
                    ENTER;                                                              \
                    save_re_context();                                                  \
                    ok=CAT2(is_utf8_,CLASS)((const U8*)STR);                            \
                    assert(ok);                                                         \
                    LEAVE;                                                              \
                }                                                                       \
                if ((OP(scan) == NAME                                                  \
                    ? (bool)swash_fetch(CAT2(PL_utf8_,CLASS), (U8*)locinput, do_utf8)    \
                    : LCFUNC_utf8((U8*)locinput)))                                      \
                {                                                                       \
                    sayNO;                                                              \
                }                                                                       \
                locinput += PL_utf8skip[nextchr];                                       \
                nextchr = UCHARAT(locinput);                                            \
                break;                                                                  \
            }                                                                           \
            if ((OP(scan) == NAME ? FUNC(nextchr) : LCFUNC(nextchr)))                   \
                sayNO;                                                                  \
            nextchr = UCHARAT(++locinput);                                              \
            break



d169 107
d280 9
a288 1
/* it would be nice to rework regcomp.sym to generate this stuff. sigh */
d295 1
a295 1
    OP(rn) == KEEPS || (PL_regkind[OP(rn)] == VERB) || \
d306 1
a306 1
#define IS_TEXTF(rn)  ( OP(rn)==EXACTF  || OP(rn)==REFF  || OP(rn)==NREFF  )
d312 1
d338 6
a348 1
#define REGCP_PAREN_ELEMS 4
d350 2
d356 2
a357 1
	Perl_croak(aTHX_ "panic: paren_elems_to_push < 0");
d359 6
a364 2
#define REGCP_OTHER_ELEMS 7
    SSGROW(paren_elems_to_push + REGCP_OTHER_ELEMS);
d385 1
a385 5
#define REGCP_FRAME_ELEMS 2
/* REGCP_FRAME_ELEMS are part of the REGCP_OTHER_ELEMS and
 * are needed for the regexp context stack bookkeeping. */
    SSPUSHINT(paren_elems_to_push + REGCP_OTHER_ELEMS - REGCP_FRAME_ELEMS);
    SSPUSHINT(SAVEt_REGCONTEXT); /* Magic cookie. */
d410 1
a410 1
    U32 i;
d417 3
a419 3
    i = SSPOPINT;
    assert(i == SAVEt_REGCONTEXT); /* Check that the magic cookie is there. */
    i = SSPOPINT; /* Parentheses elements to pop. */
d426 1
a426 1
    
d428 1
a428 2
    for (i -= (REGCP_OTHER_ELEMS - REGCP_FRAME_ELEMS);
	 i > 0; i -= REGCP_PAREN_ELEMS) {
d538 1
a538 1
	d) First node (of those at offset 0) which may distingush positions;
d560 1
a560 1
    const bool do_utf8 = (sv && SvUTF8(sv)) ? 1 : 0; /* if no sv we have to assume bytes */
d573 1
a573 1
    RX_MATCH_UTF8_set(rx,do_utf8);
d579 1
a579 1
        debug_start_match(rx, do_utf8, strpos, strend, 
d593 1
a593 1
    if (do_utf8) {
d702 1
a702 1
    if (flags & REXEC_SCREAM) {
d705 15
d721 1
a721 1
	if (PL_screamfirst[BmRARE(check)] >= 0
d760 1
a760 1
        RE_PV_QUOTED_DECL(quoted, do_utf8, PERL_DEBUG_PAD_ZERO(0), 
d764 1
a764 1
	    (check == (do_utf8 ? prog->anchored_utf8 : prog->anchored_substr) 
d795 1
a795 1
    if (do_utf8 ? (prog->float_utf8 && prog->anchored_utf8) 
d802 1
a802 1
	if (check == (do_utf8 ? prog->float_utf8 : prog->float_substr)) {
d812 1
a812 1
		    && (!do_utf8
d831 1
a831 1
		must = do_utf8 ? prog->anchored_utf8 : prog->anchored_substr;
d845 1
a845 1
                    RE_PV_QUOTED_DECL(quoted, do_utf8, PERL_DEBUG_PAD_ZERO(0), 
d892 1
a892 1
	    must = do_utf8 ? prog->float_utf8 : prog->float_substr;
d906 1
a906 1
	        RE_PV_QUOTED_DECL(quoted, do_utf8, PERL_DEBUG_PAD_ZERO(0), 
d953 1
a953 1
        && (!do_utf8
d971 1
a971 1
			if (do_utf8 ? prog->anchored_utf8 : prog->anchored_substr) {
d1011 1
a1011 1
	++BmUSEFUL(do_utf8 ? prog->check_utf8 : prog->check_substr);	/* hooray/5 */
d1035 1
a1035 1
	    && (do_utf8 ? (
d1047 3
a1049 3
	    /* XXX Does the destruction order has to change with do_utf8? */
	    SvREFCNT_dec(do_utf8 ? prog->check_utf8 : prog->check_substr);
	    SvREFCNT_dec(do_utf8 ? prog->check_substr : prog->check_utf8);
d1054 4
d1062 1
d1080 1
a1080 1
	   This leaves EXACTF only, which is dealt with in find_byclass().  */
d1113 1
a1113 1
		if ((do_utf8 ? prog->anchored_utf8 : prog->anchored_substr) == check) {
d1153 1
a1153 1
	    if (!(do_utf8 ? prog->float_utf8 : prog->float_substr))	/* Could have been deleted */
d1155 1
a1155 1
	    /* Check is floating subtring. */
d1181 1
a1181 1
	BmUSEFUL(do_utf8 ? prog->check_utf8 : prog->check_substr) += 5; /* hooray */
d1190 55
a1244 52
		    trie_type = (scan->flags != EXACT) \
		              ? (do_utf8 ? trie_utf8_fold : (UTF ? trie_latin_utf8_fold : trie_plain)) \
                              : (do_utf8 ? trie_utf8 : trie_plain)

#define REXEC_TRIE_READ_CHAR(trie_type, trie, widecharmap, uc, uscan, len,  \
uvc, charid, foldlen, foldbuf, uniflags) STMT_START {                       \
    switch (trie_type) {                                                    \
    case trie_utf8_fold:                                                    \
	if ( foldlen>0 ) {                                                  \
	    uvc = utf8n_to_uvuni( uscan, UTF8_MAXLEN, &len, uniflags ); \
	    foldlen -= len;                                                 \
	    uscan += len;                                                   \
	    len=0;                                                          \
	} else {                                                            \
	    uvc = utf8n_to_uvuni( (U8*)uc, UTF8_MAXLEN, &len, uniflags ); \
	    uvc = to_uni_fold( uvc, foldbuf, &foldlen );                    \
	    foldlen -= UNISKIP( uvc );                                      \
	    uscan = foldbuf + UNISKIP( uvc );                               \
	}                                                                   \
	break;                                                              \
    case trie_latin_utf8_fold:                                              \
	if ( foldlen>0 ) {                                                  \
	    uvc = utf8n_to_uvuni( uscan, UTF8_MAXLEN, &len, uniflags );     \
	    foldlen -= len;                                                 \
	    uscan += len;                                                   \
	    len=0;                                                          \
	} else {                                                            \
	    len = 1;                                                        \
	    uvc = to_uni_fold( *(U8*)uc, foldbuf, &foldlen );               \
	    foldlen -= UNISKIP( uvc );                                      \
	    uscan = foldbuf + UNISKIP( uvc );                               \
	}                                                                   \
	break;                                                              \
    case trie_utf8:                                                         \
	uvc = utf8n_to_uvuni( (U8*)uc, UTF8_MAXLEN, &len, uniflags );       \
	break;                                                              \
    case trie_plain:                                                        \
	uvc = (UV)*uc;                                                      \
	len = 1;                                                            \
    }                                                                       \
    if (uvc < 256) {                                                        \
	charid = trie->charmap[ uvc ];                                      \
    }                                                                       \
    else {                                                                  \
	charid = 0;                                                         \
	if (widecharmap) {                                                  \
	    SV** const svpp = hv_fetch(widecharmap,                         \
			(char*)&uvc, sizeof(UV), 0);                        \
	    if (svpp)                                                       \
		charid = (U16)SvIV(*svpp);                                  \
	}                                                                   \
    }                                                                       \
a1246 24
#define REXEC_FBC_EXACTISH_CHECK(CoNd)                 \
{                                                      \
    char *my_strend= (char *)strend;                   \
    if ( (CoNd)                                        \
	 && (ln == len ||                              \
	     !ibcmp_utf8(s, &my_strend, 0,  do_utf8,   \
			m, NULL, ln, (bool)UTF))       \
	 && (!reginfo || regtry(reginfo, &s)) )        \
	goto got_it;                                   \
    else {                                             \
	 U8 foldbuf[UTF8_MAXBYTES_CASE+1];             \
	 uvchr_to_utf8(tmpbuf, c);                     \
	 f = to_utf8_fold(tmpbuf, foldbuf, &foldlen);  \
	 if ( f != c                                   \
	      && (f == c1 || f == c2)                  \
	      && (ln == len ||                         \
	        !ibcmp_utf8(s, &my_strend, 0,  do_utf8,\
			      m, NULL, ln, (bool)UTF)) \
	      && (!reginfo || regtry(reginfo, &s)) )   \
	      goto got_it;                             \
    }                                                  \
}                                                      \
s += len

d1251 2
a1252 4
	     && (ln == 1 || !(OP(c) == EXACTF             \
			      ? ibcmp(s, m, ln)           \
			      : ibcmp_locale(s, m, ln)))  \
	     && (!reginfo || regtry(reginfo, &s)) )        \
d1303 1
a1303 1
    if (do_utf8) {                                             \
d1308 1
a1308 2
    }                                                          \
    break
d1311 1
a1311 1
    if (do_utf8) {                                             \
d1317 1
a1317 2
    }                                                          \
    break
d1321 1
a1321 1
    if (do_utf8) {                                             \
d1326 1
a1326 2
    }                                                          \
    break
d1331 80
d1422 4
a1425 1
	char *m;
d1429 2
a1430 2
	unsigned int c1;
	unsigned int c2;
d1433 2
a1434 1
	register const bool do_utf8 = PL_reg_match_utf8;
d1441 1
d1443 4
a1446 5
	    if (do_utf8) {
		 REXEC_FBC_UTF8_CLASS_SCAN((ANYOF_FLAGS(c) & ANYOF_UNICODE) ||
			  !UTF8_IS_INVARIANT((U8)s[0]) ?
			  reginclass(prog, c, (U8*)s, 0, do_utf8) :
			  REGINCLASS(prog, c, (U8*)s));
d1449 1
a1449 17
		 while (s < strend) {
		      STRLEN skip = 1;

		      if (REGINCLASS(prog, c, (U8*)s) ||
			  (ANYOF_FOLD_SHARP_S(c, s, strend) &&
			   /* The assignment of 2 is intentional:
			    * for the folded sharp s, the skip is 2. */
			   (skip = SHARP_S_SKIP))) {
			   if (tmp && (!reginfo || regtry(reginfo, &s)))
				goto got_it;
			   else
				tmp = doevery;
		      }
		      else 
			   tmp = 1;
		      s += skip;
		 }
d1460 10
d1471 51
a1521 1
	    m   = STRING(c);
d1523 16
a1538 33
	    lnc = (I32) ln;	/* length to match in characters */
	    if (UTF) {
	        STRLEN ulen1, ulen2;
		U8 *sm = (U8 *) m;
		U8 tmpbuf1[UTF8_MAXBYTES_CASE+1];
		U8 tmpbuf2[UTF8_MAXBYTES_CASE+1];
		/* used by commented-out code below */
		/*const U32 uniflags = UTF8_ALLOW_DEFAULT;*/
		
                /* XXX: Since the node will be case folded at compile
                   time this logic is a little odd, although im not 
                   sure that its actually wrong. --dmq */
                   
		c1 = to_utf8_lower((U8*)m, tmpbuf1, &ulen1);
		c2 = to_utf8_upper((U8*)m, tmpbuf2, &ulen2);

		/* XXX: This is kinda strange. to_utf8_XYZ returns the 
                   codepoint of the first character in the converted
                   form, yet originally we did the extra step. 
                   No tests fail by commenting this code out however
                   so Ive left it out. -- dmq.
                   
		c1 = utf8n_to_uvchr(tmpbuf1, UTF8_MAXBYTES_CASE, 
				    0, uniflags);
		c2 = utf8n_to_uvchr(tmpbuf2, UTF8_MAXBYTES_CASE,
				    0, uniflags);
                */
                
		lnc = 0;
		while (sm < ((U8 *) m + ln)) {
		    lnc++;
		    sm += UTF8SKIP(sm);
		}
d1541 1
a1541 2
		c1 = *(U8*)m;
		c2 = PL_fold[c1];
d1543 34
a1576 8
	    goto do_exactf;
	case EXACTFL:
	    m   = STRING(c);
	    ln  = STR_LEN(c);
	    lnc = (I32) ln;
	    c1 = *(U8*)m;
	    c2 = PL_fold_locale[c1];
	  do_exactf:
d1579 1
a1579 1
	    if (!reginfo && e < s)
d1581 1
d1583 14
a1596 52
	    /* The idea in the EXACTF* cases is to first find the
	     * first character of the EXACTF* node and then, if
	     * necessary, case-insensitively compare the full
	     * text of the node.  The c1 and c2 are the first
	     * characters (though in Unicode it gets a bit
	     * more complicated because there are more cases
	     * than just upper and lower: one needs to use
	     * the so-called folding case for case-insensitive
	     * matching (called "loose matching" in Unicode).
	     * ibcmp_utf8() will do just that. */

	    if (do_utf8 || UTF) {
	        UV c, f;
	        U8 tmpbuf [UTF8_MAXBYTES+1];
		STRLEN len = 1;
		STRLEN foldlen;
		const U32 uniflags = UTF8_ALLOW_DEFAULT;
		if (c1 == c2) {
		    /* Upper and lower of 1st char are equal -
		     * probably not a "letter". */
		    while (s <= e) {
		        if (do_utf8) {
		            c = utf8n_to_uvchr((U8*)s, UTF8_MAXBYTES, &len,
					   uniflags);
                        } else {
                            c = *((U8*)s);
                        }					  
			REXEC_FBC_EXACTISH_CHECK(c == c1);
		    }
		}
		else {
		    while (s <= e) {
		        if (do_utf8) {
		            c = utf8n_to_uvchr((U8*)s, UTF8_MAXBYTES, &len,
					   uniflags);
                        } else {
                            c = *((U8*)s);
                        }

			/* Handle some of the three Greek sigmas cases.
			 * Note that not all the possible combinations
			 * are handled here: some of them are handled
			 * by the standard folding rules, and some of
			 * them (the character class or ANYOF cases)
			 * are handled during compiletime in
			 * regexec.c:S_regclass(). */
			if (c == (UV)UNICODE_GREEK_CAPITAL_LETTER_SIGMA ||
			    c == (UV)UNICODE_GREEK_SMALL_LETTER_FINAL_SIGMA)
			    c = (UV)UNICODE_GREEK_SMALL_LETTER_SIGMA;

			REXEC_FBC_EXACTISH_CHECK(c == c1 || c == c2);
		    }
d1598 1
a1598 7
	    }
	    else {
	        /* Neither pattern nor string are UTF8 */
		if (c1 == c2)
		    REXEC_FBC_EXACTISH_SCAN(*(U8*)s == c1);
		else
		    REXEC_FBC_EXACTISH_SCAN(*(U8*)s == c1 || *(U8*)s == c2);
d1601 1
d1604 3
a1606 35
	    /* FALL THROUGH */
	case BOUND:
	    if (do_utf8) {
		if (s == PL_bostr)
		    tmp = '\n';
		else {
		    U8 * const r = reghop3((U8*)s, -1, (U8*)PL_bostr);
		    tmp = utf8n_to_uvchr(r, UTF8SKIP(r), 0, UTF8_ALLOW_DEFAULT);
		}
		tmp = ((OP(c) == BOUND ?
			isALNUM_uni(tmp) : isALNUM_LC_uvchr(UNI_TO_NATIVE(tmp))) != 0);
		LOAD_UTF8_CHARCLASS_ALNUM();
		REXEC_FBC_UTF8_SCAN(
		    if (tmp == !(OP(c) == BOUND ?
				 (bool)swash_fetch(PL_utf8_alnum, (U8*)s, do_utf8) :
				 isALNUM_LC_utf8((U8*)s)))
		    {
			tmp = !tmp;
			REXEC_FBC_TRYIT;
		}
		);
	    }
	    else {
		tmp = (s != PL_bostr) ? UCHARAT(s - 1) : '\n';
		tmp = ((OP(c) == BOUND ? isALNUM(tmp) : isALNUM_LC(tmp)) != 0);
		REXEC_FBC_SCAN(
		    if (tmp ==
			!(OP(c) == BOUND ? isALNUM(*s) : isALNUM_LC(*s))) {
			tmp = !tmp;
			REXEC_FBC_TRYIT;
		}
		);
	    }
	    if ((!prog->minlen && tmp) && (!reginfo || regtry(reginfo, &s)))
		goto got_it;
d1610 14
a1623 1
	    /* FALL THROUGH */
d1625 18
a1642 31
	    if (do_utf8) {
		if (s == PL_bostr)
		    tmp = '\n';
		else {
		    U8 * const r = reghop3((U8*)s, -1, (U8*)PL_bostr);
		    tmp = utf8n_to_uvchr(r, UTF8SKIP(r), 0, UTF8_ALLOW_DEFAULT);
		}
		tmp = ((OP(c) == NBOUND ?
			isALNUM_uni(tmp) : isALNUM_LC_uvchr(UNI_TO_NATIVE(tmp))) != 0);
		LOAD_UTF8_CHARCLASS_ALNUM();
		REXEC_FBC_UTF8_SCAN(
		    if (tmp == !(OP(c) == NBOUND ?
				 (bool)swash_fetch(PL_utf8_alnum, (U8*)s, do_utf8) :
				 isALNUM_LC_utf8((U8*)s)))
			tmp = !tmp;
		    else REXEC_FBC_TRYIT;
		);
	    }
	    else {
		tmp = (s != PL_bostr) ? UCHARAT(s - 1) : '\n';
		tmp = ((OP(c) == NBOUND ?
			isALNUM(tmp) : isALNUM_LC(tmp)) != 0);
		REXEC_FBC_SCAN(
		    if (tmp ==
			!(OP(c) == NBOUND ? isALNUM(*s) : isALNUM_LC(*s)))
			tmp = !tmp;
		    else REXEC_FBC_TRYIT;
		);
	    }
	    if ((!prog->minlen && !tmp) && (!reginfo || regtry(reginfo, &s)))
		goto got_it;
a1643 6
	case ALNUM:
	    REXEC_FBC_CSCAN_PRELOAD(
		LOAD_UTF8_CHARCLASS_PERL_WORD(),
		swash_fetch(RE_utf8_perl_word, (U8*)s, do_utf8),
		isALNUM(*s)
	    );
d1649 27
d1678 3
a1680 3
		LOAD_UTF8_CHARCLASS_PERL_WORD(),
		!swash_fetch(RE_utf8_perl_word, (U8*)s, do_utf8),
		!isALNUM(*s)
d1682 7
d1694 8
d1704 3
a1706 3
		LOAD_UTF8_CHARCLASS_PERL_SPACE(),
		*s == ' ' || swash_fetch(RE_utf8_perl_space,(U8*)s, do_utf8),
		isSPACE(*s)
d1708 6
d1716 1
a1716 1
		*s == ' ' || isSPACE_LC_utf8((U8*)s),
d1719 8
d1729 9
a1737 3
		LOAD_UTF8_CHARCLASS_PERL_SPACE(),
		!(*s == ' ' || swash_fetch(RE_utf8_perl_space,(U8*)s, do_utf8)),
		!isSPACE(*s)
d1739 1
d1742 1
a1742 1
		!(*s == ' ' || isSPACE_LC_utf8((U8*)s)),
d1745 1
d1748 2
a1749 2
		LOAD_UTF8_CHARCLASS_POSIX_DIGIT(),
		swash_fetch(RE_utf8_posix_digit,(U8*)s, do_utf8),
d1752 6
d1763 1
d1766 2
a1767 2
		LOAD_UTF8_CHARCLASS_POSIX_DIGIT(),
		!swash_fetch(RE_utf8_posix_digit,(U8*)s, do_utf8),
d1770 7
d1782 1
d1788 1
d1794 1
d1800 1
d1806 1
d1812 1
d1902 1
a1902 1
                                            (char *)uc, do_utf8 );
d1906 10
a1915 4
                                );            
                                while ( uc <= (U8*)last_start  && !BITMAP_TEST(bitmap,*uc) ) {
                                    uc++;
                                }
d1922 1
a1922 1
                            U8 *lpos= points[ (pointpos - trie->wordlen[word-1] ) % maxlen ];
d1936 1
a1936 1
                                s,   do_utf8 );
d1951 1
a1951 1
                                        s,   do_utf8 );
d1959 1
d1961 5
a1965 7
                                     (base + charid > trie->uniquecharcount )
                                     && (base + charid - 1 - trie->uniquecharcount
                                            < trie->lasttrans)
                                     && trie->trans[base + charid - 1 -
                                            trie->uniquecharcount].check == state
                                     && (tmp=trie->trans[base + charid - 1 -
                                        trie->uniquecharcount ].next))
d1995 1
a1995 1
                        U8 *lpos = points[ (pointpos - trie->wordlen[aho->states[ state ].wordnum-1]) % maxlen ];
d2062 1
a2062 1
    const bool do_utf8 = (bool)DO_UTF8(sv);
d2081 1
a2081 1
    RX_MATCH_UTF8_set(rx, do_utf8);
d2083 1
a2083 1
        debug_start_match(rx, do_utf8, startpos, strend, 
d2200 1
a2200 1
                if (do_utf8) {
d2251 2
a2252 2
                /* We can use a more efficient search as newlines are the same in unicode as they are in latin */
		while (s < end) {
d2263 1
a2263 1
        /* the warning about reginfo.ganch being used without intialization
d2276 1
a2276 1
	/* it must be a one character string (XXXX Except UTF?) */
d2281 3
a2283 3
	if (!(do_utf8 ? prog->anchored_utf8 : prog->anchored_substr))
	    do_utf8 ? to_utf8_substr(prog) : to_byte_substr(prog);
	ch = SvPVX_const(do_utf8 ? prog->anchored_utf8 : prog->anchored_substr)[0];
d2285 1
a2285 1
	if (do_utf8) {
d2325 3
a2327 3
	    if (!(do_utf8 ? prog->anchored_utf8 : prog->anchored_substr))
		do_utf8 ? to_utf8_substr(prog) : to_byte_substr(prog);
	    must = do_utf8 ? prog->anchored_utf8 : prog->anchored_substr;
d2330 3
a2332 3
	    if (!(do_utf8 ? prog->float_utf8 : prog->float_substr))
		do_utf8 ? to_utf8_substr(prog) : to_byte_substr(prog);
	    must = do_utf8 ? prog->float_utf8 : prog->float_substr;
d2360 1
a2360 1
		((flags & REXEC_SCREAM)
d2380 1
a2380 1
	    if (do_utf8) {
d2396 1
a2396 1
            RE_PV_QUOTED_DECL(quoted, do_utf8, PERL_DEBUG_PAD_ZERO(0), 
d2416 1
a2416 1
		RE_PV_QUOTED_DECL(quoted,do_utf8,PERL_DEBUG_PAD_ZERO(1),
d2419 1
a2419 1
		    "Matching stclass %.*s against %s (%d chars)\n",
d2432 1
a2432 1
	    char *last;
d2435 3
a2437 3
	    if (!(do_utf8 ? prog->float_utf8 : prog->float_substr))
		do_utf8 ? to_utf8_substr(prog) : to_byte_substr(prog);
	    float_real = do_utf8 ? prog->float_utf8 : prog->float_substr;
d2439 1
a2439 1
	    if (flags & REXEC_SCREAM) {
a2450 1

d2452 43
a2494 6
		    if (memEQ(strend - len + 1, little, len - 1))
			last = strend - len + 1;
		    else if (!multiline)
			last = memEQ(strend - len, little, len)
			    ? strend - len : NULL;
		    else
d2496 1
d2505 6
a2510 1
	    if (last == NULL) {
d2513 3
a2515 3
			"%sCan't trim the tail, match fails (should not happen)%s\n",
	                PL_colors[4], PL_colors[5]));
		goto phooey; /* Should not happen! */
d2523 1
a2523 1
	if (do_utf8) {
d2675 1
a2675 1
	ReREFCNT_inc(rx);
a2766 3
/* Make sure there is a test for this +1 options in re_tests */
#define TRIE_INITAL_ACCEPT_BUFFLEN 4;

d2932 1
a2932 1
Bascktrack state structs are allocated in slabs of about 4K in size.
d2945 1
a2945 1
	DUMP_EXEC_POS(locinput, scan, do_utf8);		    \
d2963 1
a2963 1
S_debug_start_match(pTHX_ const REGEXP *prog, const bool do_utf8, 
d2976 1
a2976 1
        RE_PV_QUOTED_DECL(s1, do_utf8, PERL_DEBUG_PAD_ZERO(1), 
d2983 1
a2983 1
        if (do_utf8||utf8_pat) 
d2986 2
a2987 2
                utf8_pat && do_utf8 ? " and " : "",
                do_utf8 ? "string" : ""
d2998 1
a2998 1
                      const bool do_utf8)
d3015 1
a3015 1
    while (do_utf8 && UTF8_IS_CONTINUATION(*(U8*)(locinput - pref_len)))
d3021 1
a3021 1
    while (do_utf8 && UTF8_IS_CONTINUATION(*(U8*)(locinput + l)))
d3028 1
a3028 1
	const int is_uni = (do_utf8 && OP(scan) != CANY) ? 1 : 0;
d3115 1
a3115 1
    register const bool do_utf8 = PL_reg_match_utf8;
d3151 1
a3151 1
                               during a successfull match */
d3204 1
a3204 1
	    DUMP_EXEC_POS( locinput, scan, do_utf8 );
d3282 1
a3282 1
 	    if (do_utf8) {
d3299 1
a3299 1
	    if (do_utf8) {
d3315 8
a3322 10
            if (scan->flags == EXACT || !do_utf8) {
                if(!ANYOF_BITMAP_TEST(scan, *locinput)) {
                    DEBUG_EXECUTE_r(
                        PerlIO_printf(Perl_debug_log,
                    	          "%*s  %sfailed to match trie start class...%s\n",
                    	          REPORT_CODE_OFF+depth*2, "", PL_colors[4], PL_colors[5])
                    );
                    sayNO_SILENT;
                    /* NOTREACHED */
                }        	        
d3326 44
d3380 1
a3380 3
        	if (trie->bitmap && trie_type != trie_utf8_fold &&
        	    !TRIE_BITMAP_TEST(trie,*locinput)
        	) {
d3387 2
a3388 1
        	        break;
a3404 2
		STRLEN bufflen=0;
		SV *sv_accept_buff = NULL;
d3406 2
a3408 1
	    	ST.accepted = 0; /* how many accepting states we have seen */
d3412 7
a3418 4
	        /*
        	   traverse the TRIE keeping track of all accepting states
        	   we transition through until we get to a failing node.
        	*/
d3423 16
a3438 22
                    U16 charid;
                    /* We use charid to hold the wordnum as we don't use it
                       for charid until after we have done the wordnum logic. 
                       We define an alias just so that the wordnum logic reads
                       more naturally. */

#define got_wordnum charid
                    got_wordnum = trie->states[ state ].wordnum;

		    if ( got_wordnum ) {
			if ( ! ST.accepted ) {
			    ENTER;
			    SAVETMPS; /* XXX is this necessary? dmq */
			    bufflen = TRIE_INITAL_ACCEPT_BUFFLEN;
			    sv_accept_buff=newSV(bufflen *
					    sizeof(reg_trie_accepted) - 1);
			    SvCUR_set(sv_accept_buff, 0);
			    SvPOK_on(sv_accept_buff);
			    sv_2mortal(sv_accept_buff);
			    SAVETMPS;
			    ST.accept_buff =
				(reg_trie_accepted*)SvPV_nolen(sv_accept_buff );
d3440 3
a3442 15
			do {
			    if (ST.accepted >= bufflen) {
				bufflen *= 2;
				ST.accept_buff =(reg_trie_accepted*)
				    SvGROW(sv_accept_buff,
				       	bufflen * sizeof(reg_trie_accepted));
			    }
			    SvCUR_set(sv_accept_buff,SvCUR(sv_accept_buff)
				+ sizeof(reg_trie_accepted));


			    ST.accept_buff[ST.accepted].wordnum = got_wordnum;
			    ST.accept_buff[ST.accepted].endpos = uc;
			    ++ST.accepted;
		        } while (trie->nextword && (got_wordnum= trie->nextword[got_wordnum]));
a3443 1
#undef got_wordnum 
d3446 1
a3446 1
		                DUMP_EXEC_POS( (char *)uc, scan, do_utf8 );
d3448 1
a3448 1
			            "%*s  %sState: %4"UVxf" Accepted: %4"UVxf" ",
d3450 1
a3450 1
			            (UV)state, (UV)ST.accepted );
d3453 1
d3455 1
d3459 6
d3466 2
a3467 6
			if (charid &&
			     (base + charid > trie->uniquecharcount )
			     && (base + charid - 1 - trie->uniquecharcount
				    < trie->lasttrans)
			     && trie->trans[base + charid - 1 -
				    trie->uniquecharcount].check == state)
d3469 1
a3469 2
			    state = trie->trans[base + charid - 1 -
				trie->uniquecharcount ].next;
d3486 1
a3486 1
		if (!ST.accepted )
d3489 11
d3506 1
a3507 1
            goto trie_first_try; /* jump into the fail handler */
d3509 2
a3510 1
	case TRIE_next_fail: /* we failed - try next alterative */
d3517 25
d3551 1
a3551 67
            }	        
	    if ( ST.accepted == 1 ) {
		/* only one choice left - just continue */
		DEBUG_EXECUTE_r({
		    AV *const trie_words
			= MUTABLE_AV(rexi->data->data[ARG(ST.me)+TRIE_WORDS_OFFSET]);
		    SV ** const tmp = av_fetch( trie_words, 
		        ST.accept_buff[ 0 ].wordnum-1, 0 );
		    SV *sv= tmp ? sv_newmortal() : NULL;
		    
		    PerlIO_printf( Perl_debug_log,
			"%*s  %sonly one match left: #%d <%s>%s\n",
			REPORT_CODE_OFF+depth*2, "", PL_colors[4],
			ST.accept_buff[ 0 ].wordnum,
			tmp ? pv_pretty(sv, SvPV_nolen_const(*tmp), SvCUR(*tmp), 0, 
	                        PL_colors[0], PL_colors[1],
	                        (SvUTF8(*tmp) ? PERL_PV_ESCAPE_UNI : 0)
                            ) 
			: "not compiled under -Dr",
			PL_colors[5] );
		});
		PL_reginput = (char *)ST.accept_buff[ 0 ].endpos;
		/* in this case we free tmps/leave before we call regmatch
		   as we wont be using accept_buff again. */
		
		locinput = PL_reginput;
		nextchr = UCHARAT(locinput);
    		if ( !ST.jump || !ST.jump[ST.accept_buff[0].wordnum]) 
    		    scan = ST.B;
    		else
    		    scan = ST.me + ST.jump[ST.accept_buff[0].wordnum];
		if (!has_cutgroup) {
		    FREETMPS;
		    LEAVE;
                } else {
                    ST.accepted--;
                    PUSH_YES_STATE_GOTO(TRIE_next, scan);
                }
		
		continue; /* execute rest of RE */
	    }
	    
	    if ( !ST.accepted-- ) {
	        DEBUG_EXECUTE_r({
		    PerlIO_printf( Perl_debug_log,
			"%*s  %sTRIE failed...%s\n",
			REPORT_CODE_OFF+depth*2, "", 
			PL_colors[4],
			PL_colors[5] );
		});
		FREETMPS;
		LEAVE;
		sayNO_SILENT;
		/*NOTREACHED*/
	    } 

	    /*
	       There are at least two accepting states left.  Presumably
	       the number of accepting states is going to be low,
	       typically two. So we simply scan through to find the one
	       with lowest wordnum.  Once we find it, we swap the last
	       state into its place and decrement the size. We then try to
	       match the rest of the pattern at the point where the word
	       ends. If we succeed, control just continues along the
	       regex; if we fail we return here to try the next accepting
	       state
	     */
d3553 1
d3555 4
a3558 10
		U32 best = 0;
		U32 cur;
		for( cur = 1 ; cur <= ST.accepted ; cur++ ) {
		    DEBUG_TRIE_EXECUTE_r(
			PerlIO_printf( Perl_debug_log,
			    "%*s  %sgot %"IVdf" (%d) as best, looking at %"IVdf" (%d)%s\n",
			    REPORT_CODE_OFF + depth * 2, "", PL_colors[4],
			    (IV)best, ST.accept_buff[ best ].wordnum, (IV)cur,
			    ST.accept_buff[ cur ].wordnum, PL_colors[5] );
		    );
d3560 42
a3601 3
		    if (ST.accept_buff[cur].wordnum <
			    ST.accept_buff[best].wordnum)
			best = cur;
d3603 6
d3610 9
a3618 21
		DEBUG_EXECUTE_r({
		    AV *const trie_words
			= MUTABLE_AV(rexi->data->data[ARG(ST.me)+TRIE_WORDS_OFFSET]);
		    SV ** const tmp = av_fetch( trie_words, 
		        ST.accept_buff[ best ].wordnum - 1, 0 );
		    regnode *nextop=(!ST.jump || !ST.jump[ST.accept_buff[best].wordnum]) ? 
		                    ST.B : 
		                    ST.me + ST.jump[ST.accept_buff[best].wordnum];    
		    SV *sv= tmp ? sv_newmortal() : NULL;
		    
		    PerlIO_printf( Perl_debug_log, 
		        "%*s  %strying alternation #%d <%s> at node #%d %s\n",
			REPORT_CODE_OFF+depth*2, "", PL_colors[4],
			ST.accept_buff[best].wordnum,
			tmp ? pv_pretty(sv, SvPV_nolen_const(*tmp), SvCUR(*tmp), 0, 
	                        PL_colors[0], PL_colors[1],
	                        (SvUTF8(*tmp) ? PERL_PV_ESCAPE_UNI : 0)
                            ) : "not compiled under -Dr", 
			    REG_NODE_NUM(nextop),
			PL_colors[5] );
		});
d3620 3
a3622 14
		if ( best<ST.accepted ) {
		    reg_trie_accepted tmp = ST.accept_buff[ best ];
		    ST.accept_buff[ best ] = ST.accept_buff[ ST.accepted ];
		    ST.accept_buff[ ST.accepted ] = tmp;
		    best = ST.accepted;
		}
		PL_reginput = (char *)ST.accept_buff[ best ].endpos;
		if ( !ST.jump || !ST.jump[ST.accept_buff[best].wordnum]) {
		    scan = ST.B;
		} else {
		    scan = ST.me + ST.jump[ST.accept_buff[best].wordnum];
                }
                PUSH_YES_STATE_GOTO(TRIE_next, scan);    
                /* NOTREACHED */
d3624 23
a3647 7
        case TRIE_next:
	    /* we dont want to throw this away, see bug 57042*/
	    if (oreplsv != GvSV(PL_replgv))
		sv_setsv(oreplsv, GvSV(PL_replgv));
            FREETMPS;
	    LEAVE;
	    sayYES;
d3653 1
a3653 1
	    if (do_utf8 != UTF) {
d3658 1
a3658 1
		if (do_utf8) {
d3702 6
a3707 1
	case EXACTFL:
d3709 4
a3712 4
	    /* FALL THROUGH */
	case EXACTF: {
	    char * const s = STRING(scan);
	    ln = STR_LEN(scan);
d3714 26
a3739 2
	    if (do_utf8 || UTF) {
	      /* Either target or the pattern are utf8. */
d3743 4
a3746 15
		if (ibcmp_utf8(s, 0,  ln, (bool)UTF,
			       l, &e, 0,  do_utf8)) {
		     /* One more case for the sharp s:
		      * pack("U0U*", 0xDF) =~ /ss/i,
		      * the 0xC3 0x9F are the UTF-8
		      * byte sequence for the U+00DF. */

		     if (!(do_utf8 &&
		           toLOWER(s[0]) == 's' &&
			   ln >= 2 &&
			   toLOWER(s[1]) == 's' &&
			   (U8)l[0] == 0xC3 &&
			   e - l >= 2 &&
			   (U8)l[1] == 0x9F))
			  sayNO;
d3753 1
a3753 3
	    /* Neither the target and the pattern are utf8. */

	    /* Inline the first character, for speed. */
d3755 2
a3756 2
		UCHARAT(s) != ((OP(scan) == EXACTF)
			       ? PL_fold : PL_fold_locale)[nextchr])
d3758 1
d3761 1
a3761 3
	    if (ln > 1 && (OP(scan) == EXACTF
			   ? ibcmp(s, locinput, ln)
			   : ibcmp_locale(s, locinput, ln)))
d3766 5
a3770 1
	    }
d3776 2
d3779 2
d3782 4
a3785 1
	    if (do_utf8) {
d3793 1
a3793 1
		if (OP(scan) == BOUND || OP(scan) == NBOUND) {
d3796 1
a3796 1
		    n = swash_fetch(PL_utf8_alnum, (U8*)locinput, do_utf8);
d3804 12
d3818 26
a3843 11
		if (OP(scan) == BOUND || OP(scan) == NBOUND) {
		    ln = isALNUM(ln);
		    n = isALNUM(nextchr);
		}
		else {
		    ln = isALNUM_LC(ln);
		    n = isALNUM_LC(nextchr);
		}
	    }
	    if (((!ln) == (!n)) == (OP(scan) == BOUND ||
				    OP(scan) == BOUNDL))
d3846 1
d3848 1
a3848 1
	    if (do_utf8) {
d3850 2
d3853 1
a3853 3
	        if (!reginclass(rex, scan, (U8*)locinput, &inclasslen, do_utf8))
		    goto anyof_fail;
		if (locinput >= PL_regeol)
d3855 1
a3855 1
		locinput += inclasslen ? inclasslen : UTF8SKIP(locinput);
d3862 2
a3864 2
		    goto anyof_fail;
		if (!nextchr && locinput >= PL_regeol)
a3868 10
	anyof_fail:
	    /* If we might have the case of the German sharp s
	     * in a casefolding Unicode character class. */

	    if (ANYOF_FOLD_SHARP_S(scan, locinput, PL_regeol)) {
		 locinput += SHARP_S_SKIP;
		 nextchr = UCHARAT(locinput);
	    }
	    else
		 sayNO;
d3871 16
a3886 8
	CCC_TRY_AFF( ALNUM,  ALNUML, perl_word,   "a", isALNUM_LC_utf8, isALNUM, isALNUM_LC);
	CCC_TRY_NEG(NALNUM, NALNUML, perl_word,   "a", isALNUM_LC_utf8, isALNUM, isALNUM_LC);

	CCC_TRY_AFF( SPACE,  SPACEL, perl_space,  " ", isSPACE_LC_utf8, isSPACE, isSPACE_LC);
	CCC_TRY_NEG(NSPACE, NSPACEL, perl_space,  " ", isSPACE_LC_utf8, isSPACE, isSPACE_LC);

	CCC_TRY_AFF( DIGIT,  DIGITL, posix_digit, "0", isDIGIT_LC_utf8, isDIGIT, isDIGIT_LC);
	CCC_TRY_NEG(NDIGIT, NDIGITL, posix_digit, "0", isDIGIT_LC_utf8, isDIGIT, isDIGIT_LC);
d3932 1
a3932 1
	       there, but if the next character is a LVT, a V or and LV we
d3938 5
a3942 5
	       Also, Begin contains '! Control'.  A Prepend must be a '!
	       Control', which means it must be a Begin.  What it comes down to
	       is that if we match Prepend* and then find no suitable Begin
	       afterwards, that if we backtrack the last Prepend, that one will
	       be a suitable Begin.
d3947 1
a3947 1
	    if  (! do_utf8) {
d3952 2
a3953 1
		if (nextchr == '\r'
d3976 1
a3976 1
					  (U8*)locinput, do_utf8))
d3988 1
a3988 1
					     (U8*)locinput, do_utf8)))
d3998 1
a3998 1
		    if (! swash_fetch(PL_utf8_X_begin, (U8*)locinput, do_utf8)) {
d4010 1
a4010 1
					(U8*)locinput, do_utf8))
d4022 1
a4022 1
					    (U8*)locinput, do_utf8))
d4026 1
a4026 1
							(U8*)locinput, do_utf8))
d4040 1
a4040 1
							(U8*)locinput, do_utf8))
d4053 1
a4053 1
						    (U8*)locinput, do_utf8))
d4059 1
a4059 1
						    (U8*)locinput, do_utf8))
d4069 1
a4069 1
							 (U8*)locinput, do_utf8))
d4080 1
a4080 1
							   do_utf8))
d4091 1
a4091 1
						(U8*)locinput, do_utf8))
d4103 6
a4108 1
	{
d4111 4
d4116 27
a4142 1
	    /* FALL THROUGH */
d4144 8
a4151 2
	case NREFF:
	    type = OP(scan);
d4154 1
a4154 4
            if ( n ) {
                type = REF + ( type - NREF );
                goto do_ref;
            } else {
d4156 3
a4158 2
            }
            /* unreached */
d4161 23
a4183 1
	    /* FALL THROUGH */
d4185 6
a4190 1
	case REFF: 
d4192 2
a4193 2
	    type = OP(scan);
	  do_ref:  
d4202 14
a4215 23
	    if (do_utf8 && type != REF) {	/* REF can do byte comparison */
		char *l = locinput;
		const char *e = PL_bostr + PL_regoffs[n].end;
		/*
		 * Note that we can't do the "other character" lookup trick as
		 * in the 8-bit case (no pun intended) because in Unicode we
		 * have to map both upper and title case to lower case.
		 */
		if (type == REFF) {
		    while (s < e) {
			STRLEN ulen1, ulen2;
			U8 tmpbuf1[UTF8_MAXBYTES_CASE+1];
			U8 tmpbuf2[UTF8_MAXBYTES_CASE+1];

			if (l >= PL_regeol)
			    sayNO;
			toLOWER_utf8((U8*)s, tmpbuf1, &ulen1);
			toLOWER_utf8((U8*)l, tmpbuf2, &ulen2);
			if (ulen1 != ulen2 || memNE((char *)tmpbuf1, (char *)tmpbuf2, ulen1))
			    sayNO;
			s += ulen1;
			l += ulen2;
		    }
d4217 1
a4217 1
		locinput = l;
d4222 1
a4222 1
	    /* Inline the first character, for speed. */
d4225 1
a4225 2
		 (UCHARAT(s) != (type == REFF
				  ? PL_fold : PL_fold_locale)[nextchr])))
d4232 1
a4232 3
			   : (type == REFF
			      ? ibcmp(s, locinput, ln)
			      : ibcmp_locale(s, locinput, ln))))
d4293 18
a4310 1
	    
d4315 6
d4338 2
d4341 1
d4429 1
a4429 1
                    debug_start_match(re_sv, do_utf8, locinput, PL_regeol, 
d4483 1
a4483 1
	    sw = (bool)SvTRUE(ret);
d4584 1
a4584 1
	    sw = (bool)(*PL_reglastparen >= n && PL_regoffs[n].end != -1);
d4588 1
a4588 1
	    sw = (bool)(0 < reg_check_named_buff_matched(rex,scan));
d4717 1
a4717 3
	    ST.min = ARG1(scan);
	    ST.max = ARG2(scan);
	    ST.A = NEXTOPER(scan) + EXTRA_STEP_2ARGS;
d4748 4
d4761 2
a4762 4
		  "%*s  whilem: matched %ld out of %ld..%ld\n",
		  REPORT_CODE_OFF+depth*2, "", (long)n,
		  (long)cur_curlyx->u.curlyx.min,
		  (long)cur_curlyx->u.curlyx.max)
d4767 2
a4768 1
	    if (n < cur_curlyx->u.curlyx.min) {
d4770 3
a4772 1
		PUSH_STATE_GOTO(WHILEM_A_pre, cur_curlyx->u.curlyx.A);
d4852 1
a4852 1
	    if (n < cur_curlyx->u.curlyx.max) { /* More greed allowed? */
d4856 1
a4856 1
		PUSH_STATE_GOTO(WHILEM_A_max, cur_curlyx->u.curlyx.A);
d4877 2
a4880 2
	    /* FALL THROUGH */
	case WHILEM_A_pre_fail: /* just failed to match even minimal A */
d4900 3
a4902 2
		Perl_warner(aTHX_ packWARN(WARN_REGEXP), "%s limit (%d) exceeded",
		     "Complex regular subexpression recursion",
d4917 1
a4917 1
	    if (cur_curlyx->u.curlyx.count >= cur_curlyx->u.curlyx.max) {
d4925 2
a4926 2
			"%s limit (%d) exceeded",
			"Complex regular subexpression recursion",
d4941 2
a4942 1
	    PUSH_STATE_GOTO(WHILEM_A_min, ST.save_curlyx->u.curlyx.A);
d5125 9
a5133 6
			ST.c2 =
			    (IS_TEXTF(text_node))
			    ? PL_fold[ST.c1]
			    : (IS_TEXTFL(text_node))
				? PL_fold_locale[ST.c1]
				: ST.c1;
d5279 11
a5289 6
		    if (!UTF) {
			ST.c2 = ST.c1 = *s;
			if (IS_TEXTF(text_node))
			    ST.c2 = PL_fold[ST.c1];
			else if (IS_TEXTFL(text_node))
			    ST.c2 = PL_fold_locale[ST.c1];
d5291 2
a5292 2
		    else { /* UTF */
			if (IS_TEXTF(text_node)) {
d5343 1
a5343 1
		    if (do_utf8)
d5347 1
a5347 1
		else if (do_utf8) {
d5393 1
a5393 1
	    if (do_utf8)
d5402 1
a5402 1
		if (do_utf8) {
d5498 1
a5498 1
		    c = do_utf8 ? utf8n_to_uvchr((U8*)PL_reginput,
d5537 1
a5537 1
		ReREFCNT_inc(rex_sv);
d5608 1
a5608 1
			sw = 1 - (bool)ST.wanted;
d5637 1
a5637 1
		sw = (bool)ST.wanted;
a5753 21
        case FOLDCHAR:
            n = ARG(scan);
            if ( n == (U32)what_len_TRICKYFOLD(locinput,do_utf8,ln) ) {
                locinput += ln;
            } else if ( 0xDF == n && !do_utf8 && !UTF ) {
                sayNO;
            } else  {
                U8 folded[UTF8_MAXBYTES_CASE+1];
                STRLEN foldlen;
                const char * const l = locinput;
                char *e = PL_regeol;
                to_uni_fold(n, folded, &foldlen);

		if (ibcmp_utf8((const char*) folded, 0,  foldlen, 1,
                	       l, &e, 0,  do_utf8)) {
                        sayNO;
                }
                locinput = e;
            } 
            nextchr = UCHARAT(locinput);  
            break;
d5755 1
a5755 1
            if ((n=is_LNBREAK(locinput,do_utf8))) {
d5764 3
a5766 1
            if ((n=is_##nAmE(locinput,do_utf8))) {    \
d5773 3
a5775 1
            if ((n=is_##nAmE(locinput,do_utf8))) {    \
d5988 2
a5989 1
    register bool do_utf8 = PL_reg_match_utf8;
d6003 1
a6003 1
	if (do_utf8) {
d6015 1
a6015 1
        if (do_utf8) {
d6028 9
a6036 1
    case EXACT:		/* length of string is 1 */
d6038 26
a6063 2
	while (scan < loceol && UCHARAT(scan) == c)
	    scan++;
d6065 5
a6069 7
    case EXACTF:	/* length of string is 1 */
	c = (U8)*STRING(p);
	while (scan < loceol &&
	       (UCHARAT(scan) == c || UCHARAT(scan) == PL_fold[c]))
	    scan++;
	break;
    case EXACTFL:	/* length of string is 1 */
d6071 16
d6088 44
a6131 3
	while (scan < loceol &&
	       (UCHARAT(scan) == c || UCHARAT(scan) == PL_fold_locale[c]))
	    scan++;
d6133 1
d6135 2
a6136 1
	if (do_utf8) {
d6138 6
a6143 3
	    while (hardcount < max && scan < loceol &&
		   reginclass(prog, p, (U8*)scan, 0, do_utf8)) {
		scan += UTF8SKIP(scan);
d6151 3
a6153 2
    case ALNUM:
	if (do_utf8) {
d6157 2
a6158 1
		   swash_fetch(PL_utf8_alnum, (U8*)scan, do_utf8)) {
d6162 16
a6177 3
	} else {
	    while (scan < loceol && isALNUM(*scan))
		scan++;
d6182 1
a6182 1
	if (do_utf8) {
d6194 5
a6198 2
    case NALNUM:
	if (do_utf8) {
d6202 2
a6203 1
		   !swash_fetch(PL_utf8_alnum, (U8*)scan, do_utf8)) {
d6207 21
a6227 2
	} else {
	    while (scan < loceol && !isALNUM(*scan))
d6229 1
d6234 1
a6234 1
	if (do_utf8) {
d6246 5
a6250 2
    case SPACE:
	if (do_utf8) {
d6255 2
a6256 1
		    swash_fetch(PL_utf8_space,(U8*)scan, do_utf8))) {
d6260 19
a6278 3
	} else {
	    while (scan < loceol && isSPACE(*scan))
		scan++;
d6283 1
a6283 1
	if (do_utf8) {
d6286 1
a6286 1
		   (*scan == ' ' || isSPACE_LC_utf8((U8*)scan))) {
d6295 5
a6299 2
    case NSPACE:
	if (do_utf8) {
d6303 3
a6305 2
		   !(*scan == ' ' ||
		     swash_fetch(PL_utf8_space,(U8*)scan, do_utf8))) {
d6309 24
a6332 2
	} else {
	    while (scan < loceol && !isSPACE(*scan))
d6334 1
d6339 1
a6339 1
	if (do_utf8) {
d6342 1
a6342 1
		   !(*scan == ' ' || isSPACE_LC_utf8((U8*)scan))) {
d6352 1
a6352 1
	if (do_utf8) {
d6356 1
a6356 1
		   swash_fetch(PL_utf8_digit, (U8*)scan, do_utf8)) {
d6365 19
d6385 1
a6385 1
	if (do_utf8) {
d6389 1
a6389 1
		   !swash_fetch(PL_utf8_digit, (U8*)scan, do_utf8)) {
d6397 27
d6425 1
a6425 1
        if (do_utf8) {
d6444 1
a6444 1
        if (do_utf8) {
d6456 1
a6456 1
        if (do_utf8) {
d6469 1
a6469 1
        if (do_utf8) {
d6482 1
a6482 1
        if (do_utf8) {
d6522 3
a6524 3
- regclass_swash - prepare the utf8 swash
*/

d6528 17
d6549 2
d6554 3
a6556 1
    PERL_ARGS_ASSERT_REGCLASS_SWASH;
d6565 1
a6565 1
	    SV **a, **b;
d6567 1
a6567 2
	    /* See the end of regcomp.c:S_regclass() for
	     * documentation of these array elements. */
d6569 11
a6579 3
	    si = *ary;
	    a  = SvROK(ary[1]) ? &ary[1] : NULL;
	    b  = SvTYPE(ary[2]) == SVt_PVAV ? &ary[2] : NULL;
d6581 5
a6585 2
	    if (a)
		sw = *a;
d6587 10
a6596 1
		sw = swash_init("utf8", "", si, 1, 0);
d6599 7
a6605 2
	    if (b)
	        alt = *b;
d6609 27
a6635 2
    if (listsvp)
	*listsvp = si;
a6640 1
#endif
d6645 15
a6659 4
  The n is the ANYOF regnode, the p is the target string, lenp
  is pointer to the maximum length of how far to go in the p
  (if the lenp is zero, UTF8SKIP(p) is used),
  do_utf8 tells whether the target string is in UTF-8.
d6664 1
a6664 1
S_reginclass(pTHX_ const regexp *prog, register const regnode *n, register const U8* p, STRLEN* lenp, register bool do_utf8)
d6670 2
a6671 2
    STRLEN len = 0;
    STRLEN plen;
d6675 3
a6677 2
    if (do_utf8 && !UTF8_IS_INVARIANT(c)) {
	c = utf8n_to_uvchr(p, UTF8_MAXBYTES, &len,
d6682 1
a6682 1
	if (len == (STRLEN)-1) 
d6685 26
d6712 6
a6717 6
    plen = lenp ? *lenp : UNISKIP(NATIVE_TO_UNI(c));
    if (do_utf8 || (flags & ANYOF_UNICODE)) {
        if (lenp)
	    *lenp = 0;
	if (do_utf8 && !ANYOF_RUNTIME(n)) {
	    if (len != (STRLEN)-1 && c < 256 && ANYOF_BITMAP_TEST(n, c))
d6719 36
d6756 22
a6777 3
	if (!match && do_utf8 && (flags & ANYOF_UNICODE_ALL) && c >= 256)
	    match = TRUE;
	if (!match) {
d6779 2
a6780 2
	    SV * const sw = regclass_swash(prog, n, TRUE, 0, (SV**)&av);
	
d6783 1
a6783 1
		if (do_utf8) {
d6786 15
a6800 1
		    STRLEN len = 1;
d6803 2
a6804 1
		if (swash_fetch(sw, utf8_p, 1))
d6806 106
a6911 2
		else if (flags & ANYOF_FOLD) {
		    if (!match && lenp && av) {
d6917 16
a6932 2
			    if (len <= plen && memEQ(s, (char*)utf8_p, len)) {
			        *lenp = len;
a6937 8
		    if (!match) {
		        U8 tmpbuf[UTF8_MAXBYTES_CASE+1];

			STRLEN tmplen;
			to_utf8_fold(utf8_p, tmpbuf, &tmplen);
			if (swash_fetch(sw, tmpbuf, 1))
			    match = TRUE;
		    }
d6941 1
a6941 58
		if (! do_utf8) Safefree(utf8_p);
	    }
	}
	if (match && lenp && *lenp == 0)
	    *lenp = UNISKIP(NATIVE_TO_UNI(c));
    }
    if (!match && c < 256) {
	if (ANYOF_BITMAP_TEST(n, c))
	    match = TRUE;
	else if (flags & ANYOF_FOLD) {
	    U8 f;

	    if (flags & ANYOF_LOCALE) {
		PL_reg_flags |= RF_tainted;
		f = PL_fold_locale[c];
	    }
	    else
		f = PL_fold[c];
	    if (f != c && ANYOF_BITMAP_TEST(n, f))
		match = TRUE;
	}
	
	if (!match && (flags & ANYOF_CLASS)) {
	    PL_reg_flags |= RF_tainted;
	    if (
		(ANYOF_CLASS_TEST(n, ANYOF_ALNUM)   &&  isALNUM_LC(c))  ||
		(ANYOF_CLASS_TEST(n, ANYOF_NALNUM)  && !isALNUM_LC(c))  ||
		(ANYOF_CLASS_TEST(n, ANYOF_SPACE)   &&  isSPACE_LC(c))  ||
		(ANYOF_CLASS_TEST(n, ANYOF_NSPACE)  && !isSPACE_LC(c))  ||
		(ANYOF_CLASS_TEST(n, ANYOF_DIGIT)   &&  isDIGIT_LC(c))  ||
		(ANYOF_CLASS_TEST(n, ANYOF_NDIGIT)  && !isDIGIT_LC(c))  ||
		(ANYOF_CLASS_TEST(n, ANYOF_ALNUMC)  &&  isALNUMC_LC(c)) ||
		(ANYOF_CLASS_TEST(n, ANYOF_NALNUMC) && !isALNUMC_LC(c)) ||
		(ANYOF_CLASS_TEST(n, ANYOF_ALPHA)   &&  isALPHA_LC(c))  ||
		(ANYOF_CLASS_TEST(n, ANYOF_NALPHA)  && !isALPHA_LC(c))  ||
		(ANYOF_CLASS_TEST(n, ANYOF_ASCII)   &&  isASCII(c))     ||
		(ANYOF_CLASS_TEST(n, ANYOF_NASCII)  && !isASCII(c))     ||
		(ANYOF_CLASS_TEST(n, ANYOF_CNTRL)   &&  isCNTRL_LC(c))  ||
		(ANYOF_CLASS_TEST(n, ANYOF_NCNTRL)  && !isCNTRL_LC(c))  ||
		(ANYOF_CLASS_TEST(n, ANYOF_GRAPH)   &&  isGRAPH_LC(c))  ||
		(ANYOF_CLASS_TEST(n, ANYOF_NGRAPH)  && !isGRAPH_LC(c))  ||
		(ANYOF_CLASS_TEST(n, ANYOF_LOWER)   &&  isLOWER_LC(c))  ||
		(ANYOF_CLASS_TEST(n, ANYOF_NLOWER)  && !isLOWER_LC(c))  ||
		(ANYOF_CLASS_TEST(n, ANYOF_PRINT)   &&  isPRINT_LC(c))  ||
		(ANYOF_CLASS_TEST(n, ANYOF_NPRINT)  && !isPRINT_LC(c))  ||
		(ANYOF_CLASS_TEST(n, ANYOF_PUNCT)   &&  isPUNCT_LC(c))  ||
		(ANYOF_CLASS_TEST(n, ANYOF_NPUNCT)  && !isPUNCT_LC(c))  ||
		(ANYOF_CLASS_TEST(n, ANYOF_UPPER)   &&  isUPPER_LC(c))  ||
		(ANYOF_CLASS_TEST(n, ANYOF_NUPPER)  && !isUPPER_LC(c))  ||
		(ANYOF_CLASS_TEST(n, ANYOF_XDIGIT)  &&  isXDIGIT(c))    ||
		(ANYOF_CLASS_TEST(n, ANYOF_NXDIGIT) && !isXDIGIT(c))    ||
		(ANYOF_CLASS_TEST(n, ANYOF_PSXSPC)  &&  isPSXSPC(c))    ||
		(ANYOF_CLASS_TEST(n, ANYOF_NPSXSPC) && !isPSXSPC(c))    ||
		(ANYOF_CLASS_TEST(n, ANYOF_BLANK)   &&  isBLANK(c))     ||
		(ANYOF_CLASS_TEST(n, ANYOF_NBLANK)  && !isBLANK(c))
		) /* How's that for a conditional? */
	    {
		match = TRUE;
d6952 4
d7075 1
a7075 2
		const U8 flags = BmFLAGS(prog->substrs->data[i].substr);
		if (flags & FBMcf_TAIL) {
d7082 3
a7084 2
		}
		fbm_compile(sv, flags);
d7106 1
a7106 3
		    const U8 flags
			= BmFLAGS(prog->substrs->data[i].utf8_substr);
		    if (flags & FBMcf_TAIL) {
d7110 4
a7113 3
		    }
		    fbm_compile(sv, flags);
		}	    
@


1.13
log
@- apply fix from upstream git for CVE-2009-3626, which could cause perl to
crash on certain invalid UTF-8 codes.

ok millert@@ sthen@@
@
text
@d120 1
d123 5
d131 113
a243 1
#define LOAD_UTF8_CHARCLASS_MARK()  LOAD_UTF8_CHARCLASS(mark, "\xcd\x86")
d500 1
a500 1
Perl_re_intuit_start(pTHX_ REGEXP * const prog, SV *sv, char *strpos,
d504 1
d525 1
a525 1
    RX_MATCH_UTF8_set(prog,do_utf8);
d527 1
a527 1
    if (RX_UTF8(prog)) {
d531 1
a531 1
        debug_start_match(prog, do_utf8, strpos, strend, 
d984 1
d986 1
a986 2
	    if (do_utf8 ? prog->check_substr : prog->check_utf8)
		SvREFCNT_dec(do_utf8 ? prog->check_substr : prog->check_utf8);
d1542 2
a1543 2
		LOAD_UTF8_CHARCLASS_ALNUM(),
		swash_fetch(PL_utf8_alnum, (U8*)s, do_utf8),
d1553 2
a1554 2
		LOAD_UTF8_CHARCLASS_ALNUM(),
		!swash_fetch(PL_utf8_alnum, (U8*)s, do_utf8),
d1564 2
a1565 2
		LOAD_UTF8_CHARCLASS_SPACE(),
		*s == ' ' || swash_fetch(PL_utf8_space,(U8*)s, do_utf8),
d1575 2
a1576 2
		LOAD_UTF8_CHARCLASS_SPACE(),
		!(*s == ' ' || swash_fetch(PL_utf8_space,(U8*)s, do_utf8)),
d1586 2
a1587 2
		LOAD_UTF8_CHARCLASS_DIGIT(),
		swash_fetch(PL_utf8_digit,(U8*)s, do_utf8),
d1597 2
a1598 2
		LOAD_UTF8_CHARCLASS_DIGIT(),
		!swash_fetch(PL_utf8_digit,(U8*)s, do_utf8),
a1849 22
static void 
S_swap_match_buff (pTHX_ regexp *prog)
{
    regexp_paren_pair *t;

    PERL_ARGS_ASSERT_SWAP_MATCH_BUFF;

    if (!prog->swap) {
    /* We have to be careful. If the previous successful match
       was from this regex we don't want a subsequent paritally
       successful match to clobber the old results. 
       So when we detect this possibility we add a swap buffer
       to the re, and switch the buffer each match. If we fail
       we switch it back, otherwise we leave it swapped.
    */
        Newxz(prog->swap, (prog->nparens + 1), regexp_paren_pair);
    }
    t = prog->swap;
    prog->swap = prog->offs;
    prog->offs = t;
}    

d1855 1
a1855 1
Perl_regexec_flags(pTHX_ REGEXP * const prog, char *stringarg, register char *strend,
d1866 1
d1879 1
a1879 1
    bool swap_on_fail = 0;
d1892 1
a1892 1
    reginfo.prog = prog;
d1894 1
a1894 1
    RX_MATCH_UTF8_set(prog, do_utf8);
d1896 1
a1896 1
        debug_start_match(prog, do_utf8, startpos, strend, 
d1918 1
a1918 1
    if (RX_UTF8(prog))
d1937 1
a1937 2

	if (flags & REXEC_IGNOREPOS)	/* Means: check only at start */
d1939 3
a1941 1
	else if (sv && SvTYPE(sv) >= SVt_PVMG
d1946 3
d1953 4
d1961 4
a1964 1
	} else				/* pos() not defined */
d1966 3
d1970 11
a1980 4
    if (PL_curpm && (PM_GETRE(PL_curpm) == prog)) {
        swap_on_fail = 1;
        swap_match_buff(prog); /* do we need a save destructor here for
                                  eval dies? */
d1987 1
a1987 1
	s = re_intuit_start(prog, sv, s, strend, flags, &d);
d2011 51
a2061 18
		if (s == startpos)
		    goto after_try;
		while (1) {
		    if (regtry(&reginfo, &s))
			goto got_it;
		  after_try:
		    if (s > end)
			goto phooey;
		    if (prog->extflags & RXf_USE_INTUIT) {
			s = re_intuit_start(prog, sv, s + 1, strend, flags, NULL);
			if (!s)
			    goto phooey;
		    }
		    else
			s++;
		}		
	    } else {
		if (s > startpos)
d2063 2
d2070 3
a2072 3
		}		
	    }
	}
d2080 2
a2081 1
	if (regtry(&reginfo, &tmp_s))
d2315 2
a2316 1
    RX_MATCH_TAINTED_set(prog, PL_reg_flags & RF_tainted);
d2325 1
a2325 1
	RX_MATCH_COPY_FREE(prog);
d2342 1
a2342 1
		RX_MATCH_COPIED_on(prog);
d2361 1
a2361 1
    if (swap_on_fail) 
d2363 4
a2366 2
        swap_match_buff(prog);
    
d2379 2
a2380 1
    regexp *prog = reginfo->prog;
d2430 1
a2430 1
		SV* const repointer = newSViv(0);
d2433 1
a2433 1
                av_push(PL_regex_padav,repointer);
d2446 1
a2446 1
	ReREFCNT_inc(prog);
d2448 1
a2448 1
	PM_SETRE(PL_reg_curpm, prog);
d2891 2
a2892 1
    regexp *rex = reginfo->prog;
a3494 79
	case ANYOF:
	    if (do_utf8) {
	        STRLEN inclasslen = PL_regeol - locinput;

	        if (!reginclass(rex, scan, (U8*)locinput, &inclasslen, do_utf8))
		    goto anyof_fail;
		if (locinput >= PL_regeol)
		    sayNO;
		locinput += inclasslen ? inclasslen : UTF8SKIP(locinput);
		nextchr = UCHARAT(locinput);
		break;
	    }
	    else {
		if (nextchr < 0)
		    nextchr = UCHARAT(locinput);
		if (!REGINCLASS(rex, scan, (U8*)locinput))
		    goto anyof_fail;
		if (!nextchr && locinput >= PL_regeol)
		    sayNO;
		nextchr = UCHARAT(++locinput);
		break;
	    }
	anyof_fail:
	    /* If we might have the case of the German sharp s
	     * in a casefolding Unicode character class. */

	    if (ANYOF_FOLD_SHARP_S(scan, locinput, PL_regeol)) {
		 locinput += SHARP_S_SKIP;
		 nextchr = UCHARAT(locinput);
	    }
	    else
		 sayNO;
	    break;
	case ALNUML:
	    PL_reg_flags |= RF_tainted;
	    /* FALL THROUGH */
	case ALNUM:
	    if (!nextchr)
		sayNO;
	    if (do_utf8) {
		LOAD_UTF8_CHARCLASS_ALNUM();
		if (!(OP(scan) == ALNUM
		      ? (bool)swash_fetch(PL_utf8_alnum, (U8*)locinput, do_utf8)
		      : isALNUM_LC_utf8((U8*)locinput)))
		{
		    sayNO;
		}
		locinput += PL_utf8skip[nextchr];
		nextchr = UCHARAT(locinput);
		break;
	    }
	    if (!(OP(scan) == ALNUM
		  ? isALNUM(nextchr) : isALNUM_LC(nextchr)))
		sayNO;
	    nextchr = UCHARAT(++locinput);
	    break;
	case NALNUML:
	    PL_reg_flags |= RF_tainted;
	    /* FALL THROUGH */
	case NALNUM:
	    if (!nextchr && locinput >= PL_regeol)
		sayNO;
	    if (do_utf8) {
		LOAD_UTF8_CHARCLASS_ALNUM();
		if (OP(scan) == NALNUM
		    ? (bool)swash_fetch(PL_utf8_alnum, (U8*)locinput, do_utf8)
		    : isALNUM_LC_utf8((U8*)locinput))
		{
		    sayNO;
		}
		locinput += PL_utf8skip[nextchr];
		nextchr = UCHARAT(locinput);
		break;
	    }
	    if (OP(scan) == NALNUM
		? isALNUM(nextchr) : isALNUM_LC(nextchr))
		sayNO;
	    nextchr = UCHARAT(++locinput);
	    break;
d3507 1
a3507 1
		
d3536 1
a3536 6
	case SPACEL:
	    PL_reg_flags |= RF_tainted;
	    /* FALL THROUGH */
	case SPACE:
	    if (!nextchr)
		sayNO;
d3538 5
a3542 14
		if (UTF8_IS_CONTINUED(nextchr)) {
		    LOAD_UTF8_CHARCLASS_SPACE();
		    if (!(OP(scan) == SPACE
			  ? (bool)swash_fetch(PL_utf8_space, (U8*)locinput, do_utf8)
			  : isSPACE_LC_utf8((U8*)locinput)))
		    {
			sayNO;
		    }
		    locinput += PL_utf8skip[nextchr];
		    nextchr = UCHARAT(locinput);
		    break;
		}
		if (!(OP(scan) == SPACE
		      ? isSPACE(nextchr) : isSPACE_LC(nextchr)))
d3544 3
a3546 1
		nextchr = UCHARAT(++locinput);
d3549 5
a3553 2
		if (!(OP(scan) == SPACE
		      ? isSPACE(nextchr) : isSPACE_LC(nextchr)))
d3556 1
d3558 10
d3569 68
a3636 5
	case NSPACEL:
	    PL_reg_flags |= RF_tainted;
	    /* FALL THROUGH */
	case NSPACE:
	    if (!nextchr && locinput >= PL_regeol)
d3638 8
a3645 11
	    if (do_utf8) {
		LOAD_UTF8_CHARCLASS_SPACE();
		if (OP(scan) == NSPACE
		    ? (bool)swash_fetch(PL_utf8_space, (U8*)locinput, do_utf8)
		    : isSPACE_LC_utf8((U8*)locinput))
		{
		    sayNO;
		}
		locinput += PL_utf8skip[nextchr];
		nextchr = UCHARAT(locinput);
		break;
d3647 6
a3652 18
	    if (OP(scan) == NSPACE
		? isSPACE(nextchr) : isSPACE_LC(nextchr))
		sayNO;
	    nextchr = UCHARAT(++locinput);
	    break;
	case DIGITL:
	    PL_reg_flags |= RF_tainted;
	    /* FALL THROUGH */
	case DIGIT:
	    if (!nextchr)
		sayNO;
	    if (do_utf8) {
		LOAD_UTF8_CHARCLASS_DIGIT();
		if (!(OP(scan) == DIGIT
		      ? (bool)swash_fetch(PL_utf8_digit, (U8*)locinput, do_utf8)
		      : isDIGIT_LC_utf8((U8*)locinput)))
		{
		    sayNO;
d3654 132
a3785 22
		locinput += PL_utf8skip[nextchr];
		nextchr = UCHARAT(locinput);
		break;
	    }
	    if (!(OP(scan) == DIGIT
		  ? isDIGIT(nextchr) : isDIGIT_LC(nextchr)))
		sayNO;
	    nextchr = UCHARAT(++locinput);
	    break;
	case NDIGITL:
	    PL_reg_flags |= RF_tainted;
	    /* FALL THROUGH */
	case NDIGIT:
	    if (!nextchr && locinput >= PL_regeol)
		sayNO;
	    if (do_utf8) {
		LOAD_UTF8_CHARCLASS_DIGIT();
		if (OP(scan) == NDIGIT
		    ? (bool)swash_fetch(PL_utf8_digit, (U8*)locinput, do_utf8)
		    : isDIGIT_LC_utf8((U8*)locinput))
		{
		    sayNO;
d3787 1
a3787 3
		locinput += PL_utf8skip[nextchr];
		nextchr = UCHARAT(locinput);
		break;
a3788 21
	    if (OP(scan) == NDIGIT
		? isDIGIT(nextchr) : isDIGIT_LC(nextchr))
		sayNO;
	    nextchr = UCHARAT(++locinput);
	    break;
	case CLUMP:
	    if (locinput >= PL_regeol)
		sayNO;
	    if  (do_utf8) {
		LOAD_UTF8_CHARCLASS_MARK();
		if (swash_fetch(PL_utf8_mark,(U8*)locinput, do_utf8))
		    sayNO;
		locinput += PL_utf8skip[nextchr];
		while (locinput < PL_regeol &&
		       swash_fetch(PL_utf8_mark,(U8*)locinput, do_utf8))
		    locinput += UTF8SKIP(locinput);
		if (locinput > PL_regeol)
		    sayNO;
	    } 
	    else
	       locinput++;
d3884 1
d3901 1
d3904 1
a3904 1
            (void)ReREFCNT_inc(rex);
d3928 1
d3954 1
d3966 5
d3972 13
a3984 6
		    MAGIC *mg = NULL;
		    const SV *sv;
		    if(SvROK(ret) && SvSMAGICAL(sv = SvRV(ret)))
			mg = mg_find(sv, PERL_MAGIC_qr);
		    else if (SvSMAGICAL(ret)) {
			if (SvGMAGICAL(ret))
d3986 2
a3987 1
			else
d3989 6
d3998 5
a4002 1
			re = reg_temp_copy((regexp *)mg->mg_obj); /*XXX:dmq*/
d4008 13
a4020 2
			if (DO_UTF8(ret)) pm_flags |= RXf_UTF8;
			re = CALLREGCOMP(ret, pm_flags);
d4023 6
a4028 3
				| SVs_GMG)))
			    sv_magic(ret,MUTABLE_SV(ReREFCNT_inc(re)),
					PERL_MAGIC_qr,0,0);
d4031 2
d4039 1
a4039 1
                    debug_start_match(re, do_utf8, locinput, PL_regeol, 
d4073 1
a4073 1
		if (RX_UTF8(re))
d4079 1
a4079 1
		ST.prev_rex = rex;
d4081 2
a4082 1
		SETREX(rex,re);
d4101 3
a4103 2
	    ReREFCNT_dec(rex);
	    SETREX(rex,ST.prev_rex);
d4125 3
a4127 2
	    ReREFCNT_dec(rex);
	    SETREX(rex,ST.prev_rex);
d5129 3
a5131 2
		st->u.eval.prev_rex = rex;		/* inner */
		SETREX(rex,cur_eval->u.eval.prev_rex);
d5134 1
a5134 1
		ReREFCNT_inc(rex);
d5986 4
a5989 2
		(UTF8_ALLOW_DEFAULT & UTF8_ALLOW_ANYUV) | UTF8_CHECK_ONLY);
		/* see [perl #37836] for UTF8_ALLOW_ANYUV */
@


1.12
log
@Merge in perl 5.10.1
@
text
@a1008 1
    UV uvc_unfolded = 0;						    \
d1012 1
a1012 1
	    uvc_unfolded = uvc = utf8n_to_uvuni( uscan, UTF8_MAXLEN, &len, uniflags ); \
d1017 1
a1017 1
	    uvc_unfolded = uvc = utf8n_to_uvuni( (U8*)uc, UTF8_MAXLEN, &len, uniflags ); \
a1042 1
									    \
a1054 3
    if (!charid && trie_type == trie_utf8_fold && !UTF) {		    \
	charid = trie->charmap[uvc_unfolded];			    	    \
    }								    	    \
@


1.11
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d5 5
a9 1
 * "One Ring to rule them all, One Ring to find them..."
d63 2
a64 1
 ****    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007 by Larry Wall and others
d245 1
d247 1
a247 1
    GET_RE_DEBUG_FLAGS_DECL;
d323 2
d402 1
d404 1
a404 1
    GET_RE_DEBUG_FLAGS_DECL;
d408 1
a408 1
    if (prog->extflags & RXf_UTF8) {
d513 1
a513 1
		   (IV)end_shift, prog->precomp);
d548 1
a548 1
	if (s && RX_MATCH_COPIED(prog))
d1009 1
d1013 1
a1013 1
	    uvc = utf8n_to_uvuni( uscan, UTF8_MAXLEN, &len, uniflags );     \
d1018 1
a1018 1
	    uvc = utf8n_to_uvuni( (U8*)uc, UTF8_MAXLEN, &len, uniflags );   \
d1057 3
d1196 2
d1526 1
a1526 1
		HV *widecharmap = (HV*) progi->data->data[ aho->trie + 1 ];
d1737 2
a1738 1
S_swap_match_buff (pTHX_ regexp *prog) {
d1741 2
a1786 1

d1789 1
d1825 1
a1825 1
    if (prog->extflags & RXf_UTF8)
d2030 1
a2030 1
	    if ((flags & REXEC_SCREAM) && RX_MATCH_COPIED(prog))
d2108 1
a2108 1
		else if (RX_MATCH_COPIED(prog))
d2169 2
a2170 2
    if (prog->paren_names) 
        (void)hv_iterinit(prog->paren_names);
d2229 3
d2254 1
a2254 1
		DEFSV = reginfo->sv;
d2277 2
a2278 2
                /* so we know which PL_regex_padav element is PL_reg_curpm */
                SvFLAGS(repointer) |= SVf_BREAK;
d2285 9
d2297 1
a2297 1
	if (RX_MATCH_COPIED(prog)) {
d2306 1
a2306 1
	    RX_MATCH_COPIED_off(prog);
d2583 1
a2583 1
S_debug_start_match(pTHX_ const regexp *prog, const bool do_utf8, 
d2586 4
a2589 1
    const bool utf8_pat= prog->extflags & RXf_UTF8 ? 1 : 0;
d2594 1
a2594 1
            prog->precomp, prog->prelen, 60);   
d2633 2
d2685 2
a2686 1
S_reg_check_named_buff_matched(pTHX_ const regexp *rex, const regnode *scan) {
d2689 1
a2689 1
    SV *sv_dat=(SV*)rexi->data->data[ ARG( scan ) ];
d2691 3
a2736 1

a2738 1
    
a2739 1

a2741 1

a2755 1
            
a2760 1
    
a2772 1

a2773 2
               
    
a2787 1

d2792 2
d2840 5
d2954 1
a2954 1
		HV * widecharmap = (HV *)rexi->data->data[ ARG( scan ) + 1 ];
d3011 1
a3011 1
			    /* SAVETMPS; */ /* XXX is this necessary? dmq */
d3111 1
a3111 1
			= (AV *) rexi->data->data[ARG(ST.me)+TRIE_WORDS_OFFSET];
d3193 1
a3193 1
			= (AV *) rexi->data->data[ARG(ST.me)+TRIE_WORDS_OFFSET];
d3230 3
d3773 1
a3773 1
			    sv_magic(ret,(SV*)ReREFCNT_inc(re),
d3778 1
a3778 1
                RX_MATCH_COPIED_off(re);
d3804 6
a3809 2
		*PL_reglastparen = 0;
		*PL_reglastcloseparen = 0;
d3817 1
a3817 1
		if (re->extflags & RXf_UTF8)
d3850 7
d3870 4
d4318 1
a4318 1
                (SV*)rexi->data->data[ ARG( scan ) ];
d4366 1
a4366 1
	     * only a single backtracking state, no matter now many matches
d4433 5
a4437 2
	    if ( ST.count < (ST.minmod ? ARG1(ST.me) : ARG2(ST.me)) )
		goto curlym_do_A; /* try to match another A */
d4529 2
a4530 1
		if (ST.count == ARG2(ST.me) /* max */)
d4876 5
d4962 2
d5003 1
a5003 1
	        sv_yes_mark = sv_commit = (SV*)rexi->data->data[ ARG( scan ) ];
d5017 1
a5017 1
                = (SV*)rexi->data->data[ ARG( scan ) ];
d5058 1
a5058 1
                SV *find = (SV*)rexi->data->data[ ARG( scan ) ];
d5347 2
d5664 2
d5670 2
a5671 2
	    SV * const rv = (SV*)data->data[n];
	    AV * const av = (AV*)SvRV((SV*)rv);
d5722 2
d5747 8
a5754 1
		if (swash_fetch(sw, p, do_utf8))
d5763 1
a5763 2
			
			    if (len <= plen && memEQ(s, (char*)p, len)) {
d5772 1
d5774 2
a5775 3

		        to_utf8_fold(p, tmpbuf, &tmplen);
			if (swash_fetch(sw, tmpbuf, do_utf8))
d5779 3
d5850 3
d5881 3
d5908 3
d5946 1
a5946 1
	    RX_MATCH_COPIED_on(rex);
d5958 3
d5990 3
@


1.10
log
@merge in perl 5.8.8
@
text
@a15 1
 
d33 1
a33 22
/* need to replace pregcomp et al, so enable that */
#  ifndef PERL_IN_XSUB_RE
#    define PERL_IN_XSUB_RE
#  endif
/* need access to debugger hooks */
#  if defined(PERL_EXT_RE_DEBUG) && !defined(DEBUGGING)
#    define DEBUGGING
#  endif
#endif

#ifdef PERL_IN_XSUB_RE
/* We *really* need to overwrite these symbols: */
#  define Perl_regexec_flags my_regexec
#  define Perl_regdump my_regdump
#  define Perl_regprop my_regprop
#  define Perl_re_intuit_start my_re_intuit_start
/* *These* symbols are masked to allow static link. */
#  define Perl_pregexec my_pregexec
#  define Perl_reginitcolors my_reginitcolors
#  define Perl_regclass_swash my_regclass_swash

#  define PERL_NO_GET_CONTEXT
d59 1
a59 1
 ****    2000, 2001, 2002, 2003, 2004, 2005, 2006, by Larry Wall and others
d72 5
a76 1
#include "regcomp.h"
d80 2
a81 2
#define RF_evaled	4		/* Did an EVAL with setting? */
#define RF_utf8		8		/* String contains multibyte chars? */
d92 1
a92 1
#define REGINCLASS(p,c)  (ANYOF_FLAGS(p) ? reginclass(p,c,0,0) : ANYOF_BITMAP_TEST(p,*(c)))
d101 10
a110 15
#define reghop_c(pos,off) ((char*)reghop((U8*)pos, off))
#define reghopmaybe_c(pos,off) ((char*)reghopmaybe((U8*)pos, off))
#define HOP(pos,off) (PL_reg_match_utf8 ? reghop((U8*)pos, off) : (U8*)(pos + off))
#define HOPMAYBE(pos,off) (PL_reg_match_utf8 ? reghopmaybe((U8*)pos, off) : (U8*)(pos + off))
#define HOPc(pos,off) ((char*)HOP(pos,off))
#define HOPMAYBEc(pos,off) ((char*)HOPMAYBE(pos,off))

#define HOPBACK(pos, off) (		\
    (PL_reg_match_utf8)			\
	? reghopmaybe((U8*)pos, -off)	\
    : (pos - off >= PL_bostr)		\
	? (U8*)(pos - off)		\
    : (U8*)NULL				\
)
#define HOPBACKc(pos, off) (char*)HOPBACK(pos, off)
d112 1
a112 4
#define reghop3_c(pos,off,lim) ((char*)reghop3((U8*)pos, off, (U8*)lim))
#define reghopmaybe3_c(pos,off,lim) ((char*)reghopmaybe3((U8*)pos, off, (U8*)lim))
#define HOP3(pos,off,lim) (PL_reg_match_utf8 ? reghop3((U8*)pos, off, (U8*)lim) : (U8*)(pos + off))
#define HOPMAYBE3(pos,off,lim) (PL_reg_match_utf8 ? reghopmaybe3((U8*)pos, off, (U8*)lim) : (U8*)(pos + off))
a113 1
#define HOPMAYBE3c(pos,off,lim) ((char*)HOPMAYBE3(pos,off,lim))
d116 1
a116 1
    if (!CAT2(PL_utf8_,class)) { bool ok; ENTER; save_re_context(); ok=CAT2(is_utf8_,class)((U8*)str); assert(ok); LEAVE; } } STMT_END
d122 2
d125 5
a129 2
#define JUMPABLE(rn) ( \
    OP(rn) == OPEN || OP(rn) == CLOSE || OP(rn) == EVAL || \
d132 2
a133 1
    (PL_regkind[(U8)OP(rn)] == CURLY && ARG1(rn) > 0) \
d135 16
d152 1
a152 3
#define HAS_TEXT(rn) ( \
    PL_regkind[(U8)OP(rn)] == EXACT || PL_regkind[(U8)OP(rn)] == REF \
)
d159 3
a161 2
    while (JUMPABLE(rn)) \
	if (OP(rn) == SUSPEND || PL_regkind[(U8)OP(rn)] == CURLY) \
d163 1
a163 1
	else if (OP(rn) == PLUS) \
d165 1
a165 1
	else if (OP(rn) == IFMATCH) \
d168 1
d171 1
d177 1
d182 1
d187 1
a187 1
#define REGCP_OTHER_ELEMS 6
d189 1
d192 2
a193 2
	SSPUSHINT(PL_regendp[p]);
	SSPUSHINT(PL_regstartp[p]);
d196 6
d204 1
d219 14
a232 8
#  define REGCP_SET(cp)  DEBUG_r(PerlIO_printf(Perl_debug_log,		\
			     "  Setting an EVAL scope, savestack=%"IVdf"\n",	\
			     (IV)PL_savestack_ix)); cp = PL_savestack_ix

#  define REGCP_UNWIND(cp)  DEBUG_r(cp != PL_savestack_ix ?		\
				PerlIO_printf(Perl_debug_log,		\
				"  Clearing an EVAL scope, savestack=%"IVdf"..%"IVdf"\n", \
				(IV)(cp), (IV)PL_savestack_ix) : 0); regcpblow(cp)
d235 1
a235 1
S_regcppop(pTHX)
d237 2
a238 2
    I32 i;
    U32 paren = 0;
d241 2
d251 1
d253 1
d258 1
a258 1
	paren = (U32)SSPOPINT;
d260 1
a260 1
	PL_regstartp[paren] = SSPOPINT;
d263 2
a264 2
	    PL_regendp[paren] = tmps;
	DEBUG_r(
d267 1
a267 1
			  (UV)paren, (IV)PL_regstartp[paren],
d269 1
a269 1
			  (IV)PL_regendp[paren],
d273 2
a274 2
    DEBUG_r(
	if ((I32)(*PL_reglastparen + 1) <= PL_regnpar) {
d277 1
a277 1
			  (IV)(*PL_reglastparen + 1), (IV)PL_regnpar);
d288 6
a293 7
     * building DynaLoader will fail:
     * "Error: '*' not in typemap in DynaLoader.xs, line 164"
     * --jhi */
    for (paren = *PL_reglastparen + 1; (I32)paren <= PL_regnpar; paren++) {
	if ((I32)paren > PL_regsize)
	    PL_regstartp[paren] = -1;
	PL_regendp[paren] = -1;
a298 20
STATIC char *
S_regcp_set_to(pTHX_ I32 ss)
{
    const I32 tmp = PL_savestack_ix;

    PL_savestack_ix = ss;
    regcppop();
    PL_savestack_ix = tmp;
    return Nullch;
}

typedef struct re_cc_state
{
    I32 ss;
    regnode *node;
    struct re_cc_state *prev;
    CURCUR *cc;
    regexp *re;
} re_cc_state;

a300 16
#define TRYPAREN(paren, n, input) {				\
    if (paren) {						\
	if (n) {						\
	    PL_regstartp[paren] = HOPc(input, -1) - PL_bostr;	\
	    PL_regendp[paren] = input - PL_bostr;		\
	}							\
	else							\
	    PL_regendp[paren] = -1;				\
    }								\
    if (regmatch(next))						\
	sayYES;							\
    if (paren && n)						\
	PL_regendp[paren] = -1;					\
}


d305 1
d310 1
a310 1
Perl_pregexec(pTHX_ register regexp *prog, char *stringarg, register char *strend,
a320 7

STATIC void
S_cache_re(pTHX_ regexp *prog)
{
    PL_regprecomp = prog->precomp;		/* Needed for FAIL. */
#ifdef DEBUGGING
    PL_regprogram = prog->program;
a321 4
    PL_regnpar = prog->nparens;
    PL_regdata = prog->data;
    PL_reg_re = prog;
}
d349 5
a353 1
	(Or minlen should take into account lookahead.) */
d374 2
a375 2
Perl_re_intuit_start(pTHX_ regexp *prog, SV *sv, char *strpos,
		     char *strend, U32 flags, re_scream_pos_data *data)
d377 1
d385 1
a385 1
    const int do_utf8 = sv ? SvUTF8(sv) : 0;	/* if no sv we have to assume bytes */
d387 4
a390 2
    register char *other_last = Nullch;	/* other substr checked before this */
    char *check_at = Nullch;		/* check substr found at this pos */
a392 1
    SV * const dsv = PERL_DEBUG_PAD_ZERO(0);
d394 3
d399 1
a399 3
    if (prog->reganch & ROPT_UTF8) {
	DEBUG_r(PerlIO_printf(Perl_debug_log,
			      "UTF-8 regex...\n"));
d402 4
a405 22

    DEBUG_r({
	 const char *s   = PL_reg_match_utf8 ?
	                 sv_uni_display(dsv, sv, 60, UNI_DISPLAY_REGEX) :
	                 strpos;
	 const int   len = PL_reg_match_utf8 ?
	                 strlen(s) : strend - strpos;
	 if (!PL_colorset)
	      reginitcolors();
	 if (PL_reg_match_utf8)
	     DEBUG_r(PerlIO_printf(Perl_debug_log,
				   "UTF-8 target...\n"));
	 PerlIO_printf(Perl_debug_log,
		       "%sGuessing start of match, REx%s \"%s%.60s%s%s\" against \"%s%.*s%s%s\"...\n",
		       PL_colors[4],PL_colors[5],PL_colors[0],
		       prog->precomp,
		       PL_colors[1],
		       (strlen(prog->precomp) > 60 ? "..." : ""),
		       PL_colors[0],
		       (int)(len > 60 ? 60 : len),
		       s, PL_colors[1],
		       (len > 60 ? "..." : "")
a406 1
    });
d410 1
a410 1
	DEBUG_r(PerlIO_printf(Perl_debug_log,
d414 1
d426 3
a428 3
   if (check == &PL_sv_undef) {
	DEBUG_r(PerlIO_printf(Perl_debug_log,
		"Non-utf string cannot match utf check string\n"));
d431 4
a434 4
    if (prog->reganch & ROPT_ANCH) {	/* Match at beg-of-str or after \n */
	ml_anch = !( (prog->reganch & ROPT_ANCH_SINGLE)
		     || ( (prog->reganch & ROPT_ANCH_BOL)
			  && !PL_multiline ) );	/* Check after \n? */
d437 2
a438 2
	  if ( !(prog->reganch & (ROPT_ANCH_GPOS /* Checked by the caller */
				  | ROPT_IMPLICIT)) /* not a real BOL */
d442 1
a442 1
	      DEBUG_r(PerlIO_printf(Perl_debug_log, "Not at start...\n"));
d446 1
a446 1
	      !(prog->reganch & ROPT_CANY_SEEN)) {
d451 1
d457 1
a457 1
		    DEBUG_r(PerlIO_printf(Perl_debug_log, "String too long...\n"));
d466 1
a466 1
		    DEBUG_r(PerlIO_printf(Perl_debug_log, "String not equal...\n"));
d481 2
a482 2
	end_shift = prog->minlen - start_shift -
	    CHR_SVLEN(check) + (SvTAIL(check) != 0);
d495 4
a498 4
	start_shift = prog->check_offset_min; /* okay to underestimate on CC */
	/* Should be nonnegative! */
	end_shift = prog->minlen - start_shift -
	    CHR_SVLEN(check) + (SvTAIL(check) != 0);
d501 1
a501 1
#ifdef DEBUGGING	/* 7/99: reports of failure (with the older version) */
d503 2
a504 1
	Perl_croak(aTHX_ "panic: end_shift");
d510 16
d535 1
a535 1
			    start_shift + (s - strbeg), end_shift, pp, 0);
d544 16
a559 8
    else if (prog->reganch & ROPT_CANY_SEEN)
	s = fbm_instr((U8*)(s + start_shift),
		      (U8*)(strend - end_shift),
		      check, PL_multiline ? FBMrf_MULTILINE : 0);
    else
	s = fbm_instr(HOP3(s, start_shift, strend),
		      HOP3(strend, -end_shift, strbeg),
		      check, PL_multiline ? FBMrf_MULTILINE : 0);
d561 4
d568 4
a571 2
	/* FIXME - DEBUG_EXECUTE_r if that is merged to maint.  */
    DEBUG_r(PerlIO_printf(Perl_debug_log, "%s %s substr \"%s%.*s%s\"%s%s",
d573 6
a578 6
			  (check == (do_utf8 ? prog->anchored_utf8 : prog->anchored_substr) ? "anchored" : "floating"),
			  PL_colors[0],
			  (int)(SvCUR(check) - (SvTAIL(check)!=0)),
			  SvPVX_const(check),
			  PL_colors[1], (SvTAIL(check) ? "$" : ""),
			  (s ? " at offset " : "...\n") ) );
d582 2
d585 10
a594 4
    check_at = s;

    /* Finish the diagnostic message */
    DEBUG_r(PerlIO_printf(Perl_debug_log, "%ld...\n", (long)(s - i_strpos)) );
d604 3
a606 1
    if (do_utf8 ? (prog->float_utf8 && prog->anchored_utf8) : (prog->float_substr && prog->anchored_substr)) {
d616 1
a616 1
		char *s1 = s;
d622 1
a622 1
			|| ((t = reghopmaybe3_c(s, -(prog->check_offset_max), strpos))
d624 1
a624 1
		    /* EMPTY */;
d633 6
a638 1
 /* XXXX It is not documented what units *_offsets are in.  Assume bytes.  */
d651 1
a651 1
			PL_multiline ? FBMrf_MULTILINE : 0
d653 4
a656 2
		DEBUG_r(PerlIO_printf(Perl_debug_log,
			"%s anchored substr \"%s%.*s%s\"%s",
d658 4
a661 5
			PL_colors[0],
			  (int)(SvCUR(must)
			  - (SvTAIL(must)!=0)),
			  SvPVX_const(must),
			  PL_colors[1], (SvTAIL(must) ? "$" : "")));
d664 1
a664 1
			DEBUG_r(PerlIO_printf(Perl_debug_log,
d668 1
a668 1
		    DEBUG_r(PerlIO_printf(Perl_debug_log,
d670 1
a670 1
			(long)(HOP3c(s1, 1, strend) - i_strpos)));
d676 1
a676 1
		    DEBUG_r(PerlIO_printf(Perl_debug_log, " at offset %ld...\n",
d680 1
a680 1
		    s = s1;
d689 1
a689 1
	    char *s1 = s;
d713 5
a717 3
			      must, PL_multiline ? FBMrf_MULTILINE : 0);
	    /* FIXME - DEBUG_EXECUTE_r if that is merged to maint  */
	    DEBUG_r(PerlIO_printf(Perl_debug_log, "%s floating substr \"%s%.*s%s\"%s",
d719 2
a720 4
		    PL_colors[0],
		      (int)(SvCUR(must) - (SvTAIL(must)!=0)),
		      SvPVX_const(must),
		      PL_colors[1], (SvTAIL(must) ? "$" : "")));
d723 1
a723 1
		    DEBUG_r(PerlIO_printf(Perl_debug_log,
d727 1
a727 1
		DEBUG_r(PerlIO_printf(Perl_debug_log,
d729 1
a729 1
		    (long)(s1 + 1 - i_strpos)));
d735 1
a735 1
		DEBUG_r(PerlIO_printf(Perl_debug_log, " at offset %ld...\n",
d738 1
a738 1
		s = s1;
d746 15
a760 1
    t = s - prog->check_offset_max;
d763 3
a765 2
	    || ((t = reghopmaybe3_c(s, -prog->check_offset_max, strpos))
		 && t > strpos))) {
d789 2
a790 2
			    DEBUG_r(PerlIO_printf(Perl_debug_log, "Found /%s^%s/m at offset %ld, rescanning for anchored from offset %ld...\n",
				PL_colors[0],PL_colors[1], (long)(strpos - i_strpos), (long)(strpos - i_strpos + prog->anchored_offset)));
d796 2
a797 2
			DEBUG_r(PerlIO_printf(Perl_debug_log, "Found /%s^%s/m at offset %ld...\n",
			    PL_colors[0],PL_colors[1], (long)(s - i_strpos)));
d803 2
a804 2
		    DEBUG_r(PerlIO_printf(Perl_debug_log, "Found /%s^%s/m, restarting lookup for check-string at offset %ld...\n",
			PL_colors[0],PL_colors[1], (long)(t + 1 - i_strpos)));
d810 2
a811 2
	    DEBUG_r(PerlIO_printf(Perl_debug_log, "Did not find /%s^%s/m...\n",
			PL_colors[0],PL_colors[1]));
d815 2
a816 2
	    DEBUG_r(PerlIO_printf(Perl_debug_log, "Starting position does not contradict /%s^%s/m...\n",
			PL_colors[0],PL_colors[1]));
d833 1
a833 1
	    && !(prog->reganch & ROPT_IMPLICIT))
d838 1
a838 1
	DEBUG_r( if (ml_anch)
d840 1
a840 1
			(long)(strpos - i_strpos), PL_colors[0],PL_colors[1]);
d843 1
a843 1
	if (!(prog->reganch & ROPT_NAUGHTY)	/* XXXX If strpos moved? */
d855 1
a855 1
	    DEBUG_r(PerlIO_printf(Perl_debug_log, "... Disabling check substring...\n"));
d859 3
a861 3
	    prog->check_substr = prog->check_utf8 = Nullsv;	/* disable */
	    prog->float_substr = prog->float_utf8 = Nullsv;	/* clear */
	    check = Nullsv;			/* abort */
d866 1
a866 1
	    prog->reganch &= ~RE_USE_INTUIT;
d874 3
a876 1
    if (prog->regstclass) {
d885 3
a887 4
        const U8* const str = (U8*)STRING(prog->regstclass);
        const int cl_l = (PL_regkind[(U8)OP(prog->regstclass)] == EXACT
			  ? CHR_DIST((U8 *)str+STR_LEN(prog->regstclass),
				     (U8 *)str)
d889 11
a899 7
	const char * const endpos = (prog->anchored_substr || prog->anchored_utf8 || ml_anch)
		? HOP3c(s, (prog->minlen ? cl_l : 0), strend)
		: (prog->float_substr || prog->float_utf8
		   ? HOP3c(HOP3c(check_at, -start_shift, strbeg),
			   cl_l, strend)
		   : strend);

d901 1
a901 2
	cache_re(prog);
        s = find_byclass(prog, prog->regstclass, s, endpos, 1);
d904 1
a904 1
	    const char *what = 0;
d907 1
a907 1
		DEBUG_r( PerlIO_printf(Perl_debug_log,
d911 1
a911 1
	    DEBUG_r( PerlIO_printf(Perl_debug_log,
d913 1
a913 1
	    if ((prog->reganch & ROPT_ANCH) && !ml_anch)
d918 1
a918 1
		    DEBUG_r( what = "anchored" );
d923 1
a923 1
			DEBUG_r( PerlIO_printf(Perl_debug_log,
d929 1
a929 1
		    DEBUG_r( PerlIO_printf(Perl_debug_log,
d941 1
a941 1
		DEBUG_r( PerlIO_printf(Perl_debug_log,
d952 1
a952 1
		DEBUG_r( PerlIO_printf(Perl_debug_log,
d954 1
a954 1
			  PL_colors[0],PL_colors[1], (long)(t - i_strpos)) );
d962 1
a962 1
	    DEBUG_r( what = "floating" );
d966 1
a966 1
            DEBUG_r(PerlIO_printf(Perl_debug_log,
d972 1
a972 1
            DEBUG_r(PerlIO_printf(Perl_debug_log,
d978 1
a978 1
    DEBUG_r(PerlIO_printf(Perl_debug_log, "%s%s:%s match at offset %ld\n",
d987 3
a989 3
    DEBUG_r(PerlIO_printf(Perl_debug_log, "%sMatch rejected by optimizer%s\n",
			  PL_colors[4],PL_colors[5]));
    return Nullch;
d992 170
d1163 4
d1168 2
a1169 1
S_find_byclass(pTHX_ regexp * prog, regnode *c, char *s, const char *strend, I32 norun)
d1171 2
a1172 1
	const I32 doevery = (prog->reganch & ROPT_SKIP) == 0;
d1182 2
a1183 1

d1188 1
a1188 2
		 while (s + (uskip = UTF8SKIP(s)) <= strend) {
		      if ((ANYOF_FLAGS(c) & ANYOF_UNICODE) ||
d1190 2
a1191 11
			  reginclass(c, (U8*)s, 0, do_utf8) :
			  REGINCLASS(c, (U8*)s)) {
			   if (tmp && (norun || regtry(prog, s)))
				goto got_it;
			   else
				tmp = doevery;
		      }
		      else 
			   tmp = 1;
		      s += uskip;
		 }
d1197 1
a1197 1
		      if (REGINCLASS(c, (U8*)s) ||
d1202 1
a1202 1
			   if (tmp && (norun || regtry(prog, s)))
d1214 2
a1215 2
	    while (s < strend) {
	        if (tmp && (norun || regtry(prog, s)))
d1219 1
a1219 2
		s++;
	    }
d1230 16
a1245 5
		const U32 uniflags = ckWARN(WARN_UTF8) ? 0 : UTF8_ALLOW_ANY;

		to_utf8_lower((U8*)m, tmpbuf1, &ulen1);
		to_utf8_upper((U8*)m, tmpbuf2, &ulen2);

d1250 2
d1272 1
a1272 1
	    if (norun && e < s)
d1286 1
a1286 1
	    if (do_utf8) {
d1289 3
a1291 2
		STRLEN len, foldlen;
		const U32 uniflags = ckWARN(WARN_UTF8) ? 0 : UTF8_ALLOW_ANY;
d1296 2
a1297 1
		        c = utf8n_to_uvchr((U8*)s, UTF8_MAXBYTES, &len,
d1299 4
a1302 21
			if ( c == c1
			     && (ln == len ||
				 ibcmp_utf8(s, (char **)0, 0,  do_utf8,
					    m, (char **)0, ln, (bool)UTF))
			     && (norun || regtry(prog, s)) )
			    goto got_it;
			else {
			     U8 foldbuf[UTF8_MAXBYTES_CASE+1];
			     uvchr_to_utf8(tmpbuf, c);
			     f = to_utf8_fold(tmpbuf, foldbuf, &foldlen);
			     if ( f != c
				  && (f == c1 || f == c2)
				  && (ln == foldlen ||
				      !ibcmp_utf8((char *) foldbuf,
						  (char **)0, foldlen, do_utf8,
						  m,
						  (char **)0, ln, (bool)UTF))
				  && (norun || regtry(prog, s)) )
				  goto got_it;
			}
			s += len;
d1307 2
a1308 1
		      c = utf8n_to_uvchr((U8*)s, UTF8_MAXBYTES, &len,
d1310 3
d1325 1
a1325 21
			if ( (c == c1 || c == c2)
			     && (ln == len ||
				 ibcmp_utf8(s, (char **)0, 0,  do_utf8,
					    m, (char **)0, ln, (bool)UTF))
			     && (norun || regtry(prog, s)) )
			    goto got_it;
			else {
			     U8 foldbuf[UTF8_MAXBYTES_CASE+1];
			     uvchr_to_utf8(tmpbuf, c);
			     f = to_utf8_fold(tmpbuf, foldbuf, &foldlen);
			     if ( f != c
				  && (f == c1 || f == c2)
				  && (ln == foldlen ||
				      !ibcmp_utf8((char *) foldbuf,
						  (char **)0, foldlen, do_utf8,
						  m,
						  (char **)0, ln, (bool)UTF))
				  && (norun || regtry(prog, s)) )
				  goto got_it;
			}
			s += len;
d1330 1
d1332 1
a1332 9
		    while (s <= e) {
			if ( *(U8*)s == c1
			     && (ln == 1 || !(OP(c) == EXACTF
					      ? ibcmp(s, m, ln)
					      : ibcmp_locale(s, m, ln)))
			     && (norun || regtry(prog, s)) )
			    goto got_it;
			s++;
		    }
d1334 1
a1334 9
		    while (s <= e) {
			if ( (*(U8*)s == c1 || *(U8*)s == c2)
			     && (ln == 1 || !(OP(c) == EXACTF
					      ? ibcmp(s, m, ln)
					      : ibcmp_locale(s, m, ln)))
			     && (norun || regtry(prog, s)) )
			    goto got_it;
			s++;
		    }
d1345 2
a1346 3
		    U8 *r = reghop3((U8*)s, -1, (U8*)PL_bostr);
		
		    tmp = utf8n_to_uvchr(r, UTF8SKIP(r), 0, 0);
d1351 1
a1351 1
		while (s + (uskip = UTF8SKIP(s)) <= strend) {
d1353 1
a1353 1
				 swash_fetch(PL_utf8_alnum, (U8*)s, do_utf8) :
d1357 1
a1357 4
			if ((norun || regtry(prog, s)))
			    goto got_it;
		    }
		    s += uskip;
d1359 1
d1364 1
a1364 1
		while (s < strend) {
d1368 1
a1368 4
			if ((norun || regtry(prog, s)))
			    goto got_it;
		    }
		    s++;
d1370 1
d1372 1
a1372 1
	    if ((!prog->minlen && tmp) && (norun || regtry(prog, s)))
d1383 2
a1384 3
		    U8 *r = reghop3((U8*)s, -1, (U8*)PL_bostr);
		
		    tmp = utf8n_to_uvchr(r, UTF8SKIP(r), 0, 0);
d1389 1
a1389 1
		while (s + (uskip = UTF8SKIP(s)) <= strend) {
d1391 1
a1391 1
				 swash_fetch(PL_utf8_alnum, (U8*)s, do_utf8) :
d1394 2
a1395 4
		    else if ((norun || regtry(prog, s)))
			goto got_it;
		    s += uskip;
		}
d1401 1
a1401 1
		while (s < strend) {
d1405 2
a1406 4
		    else if ((norun || regtry(prog, s)))
			goto got_it;
		    s++;
		}
d1408 1
a1408 1
	    if ((!prog->minlen && !tmp) && (norun || regtry(prog, s)))
d1412 5
a1416 28
	    if (do_utf8) {
		LOAD_UTF8_CHARCLASS_ALNUM();
		while (s + (uskip = UTF8SKIP(s)) <= strend) {
		    if (swash_fetch(PL_utf8_alnum, (U8*)s, do_utf8)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
		    else
			tmp = 1;
		    s += uskip;
		}
	    }
	    else {
		while (s < strend) {
		    if (isALNUM(*s)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
		    else
			tmp = 1;
		    s++;
		}
	    }
	    break;
d1418 4
a1421 28
	    PL_reg_flags |= RF_tainted;
	    if (do_utf8) {
		while (s + (uskip = UTF8SKIP(s)) <= strend) {
		    if (isALNUM_LC_utf8((U8*)s)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
		    else
			tmp = 1;
		    s += uskip;
		}
	    }
	    else {
		while (s < strend) {
		    if (isALNUM_LC(*s)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
		    else
			tmp = 1;
		    s++;
		}
	    }
	    break;
d1423 5
a1427 28
	    if (do_utf8) {
		LOAD_UTF8_CHARCLASS_ALNUM();
		while (s + (uskip = UTF8SKIP(s)) <= strend) {
		    if (!swash_fetch(PL_utf8_alnum, (U8*)s, do_utf8)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
		    else
			tmp = 1;
		    s += uskip;
		}
	    }
	    else {
		while (s < strend) {
		    if (!isALNUM(*s)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
		    else
			tmp = 1;
		    s++;
		}
	    }
	    break;
d1429 4
a1432 28
	    PL_reg_flags |= RF_tainted;
	    if (do_utf8) {
		while (s + (uskip = UTF8SKIP(s)) <= strend) {
		    if (!isALNUM_LC_utf8((U8*)s)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
		    else
			tmp = 1;
		    s += uskip;
		}
	    }
	    else {
		while (s < strend) {
		    if (!isALNUM_LC(*s)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
		    else
			tmp = 1;
		    s++;
		}
	    }
	    break;
d1434 5
a1438 28
	    if (do_utf8) {
		LOAD_UTF8_CHARCLASS_SPACE();
		while (s + (uskip = UTF8SKIP(s)) <= strend) {
		    if (*s == ' ' || swash_fetch(PL_utf8_space,(U8*)s, do_utf8)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
		    else
			tmp = 1;
		    s += uskip;
		}
	    }
	    else {
		while (s < strend) {
		    if (isSPACE(*s)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
		    else
			tmp = 1;
		    s++;
		}
	    }
	    break;
d1440 270
a1709 26
	    PL_reg_flags |= RF_tainted;
	    if (do_utf8) {
		while (s + (uskip = UTF8SKIP(s)) <= strend) {
		    if (*s == ' ' || isSPACE_LC_utf8((U8*)s)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
		    else
			tmp = 1;
		    s += uskip;
		}
	    }
	    else {
		while (s < strend) {
		    if (isSPACE_LC(*s)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
		    else
			tmp = 1;
		    s++;
		}
d1712 2
a1713 28
	case NSPACE:
	    if (do_utf8) {
		LOAD_UTF8_CHARCLASS_SPACE();
		while (s + (uskip = UTF8SKIP(s)) <= strend) {
		    if (!(*s == ' ' || swash_fetch(PL_utf8_space,(U8*)s, do_utf8))) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
		    else
			tmp = 1;
		    s += uskip;
		}
	    }
	    else {
		while (s < strend) {
		    if (!isSPACE(*s)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
		    else
			tmp = 1;
		    s++;
		}
	    }
d1715 25
a1739 153
	case NSPACEL:
	    PL_reg_flags |= RF_tainted;
	    if (do_utf8) {
		while (s + (uskip = UTF8SKIP(s)) <= strend) {
		    if (!(*s == ' ' || isSPACE_LC_utf8((U8*)s))) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
		    else
			tmp = 1;
		    s += uskip;
		}
	    }
	    else {
		while (s < strend) {
		    if (!isSPACE_LC(*s)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
		    else
			tmp = 1;
		    s++;
		}
	    }
	    break;
	case DIGIT:
	    if (do_utf8) {
		LOAD_UTF8_CHARCLASS_DIGIT();
		while (s + (uskip = UTF8SKIP(s)) <= strend) {
		    if (swash_fetch(PL_utf8_digit,(U8*)s, do_utf8)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
		    else
			tmp = 1;
		    s += uskip;
		}
	    }
	    else {
		while (s < strend) {
		    if (isDIGIT(*s)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
		    else
			tmp = 1;
		    s++;
		}
	    }
	    break;
	case DIGITL:
	    PL_reg_flags |= RF_tainted;
	    if (do_utf8) {
		while (s + (uskip = UTF8SKIP(s)) <= strend) {
		    if (isDIGIT_LC_utf8((U8*)s)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
		    else
			tmp = 1;
		    s += uskip;
		}
	    }
	    else {
		while (s < strend) {
		    if (isDIGIT_LC(*s)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
		    else
			tmp = 1;
		    s++;
		}
	    }
	    break;
	case NDIGIT:
	    if (do_utf8) {
		LOAD_UTF8_CHARCLASS_DIGIT();
		while (s + (uskip = UTF8SKIP(s)) <= strend) {
		    if (!swash_fetch(PL_utf8_digit,(U8*)s, do_utf8)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
		    else
			tmp = 1;
		    s += uskip;
		}
	    }
	    else {
		while (s < strend) {
		    if (!isDIGIT(*s)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
		    else
			tmp = 1;
		    s++;
		}
	    }
	    break;
	case NDIGITL:
	    PL_reg_flags |= RF_tainted;
	    if (do_utf8) {
		while (s + (uskip = UTF8SKIP(s)) <= strend) {
		    if (!isDIGIT_LC_utf8((U8*)s)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
		    else
			tmp = 1;
		    s += uskip;
		}
	    }
	    else {
		while (s < strend) {
		    if (!isDIGIT_LC(*s)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
		    else
			tmp = 1;
		    s++;
		}
	    }
	    break;
	default:
	    Perl_croak(aTHX_ "panic: unknown regstclass %d", (int)OP(c));
	    break;
	}
	return 0;
      got_it:
	return s;
}
d1745 1
a1745 1
Perl_regexec_flags(pTHX_ register regexp *prog, char *stringarg, register char *strend,
d1750 3
a1752 1
/* data: May be used for some additional optimizations. */
d1755 2
a1756 1
    register char *s;
d1758 1
a1758 1
    register char *startpos = stringarg;
d1763 6
a1768 9
    char *scream_olds;
    SV* oreplsv = GvSV(PL_replgv);
    const bool do_utf8 = DO_UTF8(sv);
#ifdef DEBUGGING
    SV *dsv0 = PERL_DEBUG_PAD_ZERO(0);
    SV *dsv1 = PERL_DEBUG_PAD_ZERO(1);
#endif
    PERL_UNUSED_ARG(data);
    RX_MATCH_UTF8_set(prog,do_utf8);
d1770 1
a1770 1
    PL_regcc = 0;
d1772 1
a1772 4
    cache_re(prog);
#ifdef DEBUGGING
    PL_regnarrate = DEBUG_r_TEST;
#endif
d1780 9
d1790 3
a1792 2
    if (strend - startpos < minlen) {
        DEBUG_r(PerlIO_printf(Perl_debug_log,
d1797 1
d1799 1
a1799 1
    if (UCHARAT(prog->program) != REG_MAGIC) {
d1807 1
a1807 1
    if (prog->reganch & ROPT_UTF8)
d1811 1
a1811 1
    PL_regbol = startpos;
d1813 1
a1813 1
    PL_reg_sv = sv;
d1819 1
a1819 4
    PL_regtill = startpos+minend;

    /* We start without call_cc context.  */
    PL_reg_call_cc = 0;
d1824 1
a1824 1
    if (prog->reganch & ROPT_GPOS_SEEN) { /* Need to have PL_reg_ganch */
d1828 1
a1828 1
	    PL_reg_ganch = startpos;
d1833 3
a1835 3
	    PL_reg_ganch = strbeg + mg->mg_len;	/* Defined pos() */
	    if (prog->reganch & ROPT_ANCH_GPOS) {
	        if (s > PL_reg_ganch)
d1837 1
a1837 1
		s = PL_reg_ganch;
d1840 9
a1848 2
	else				/* pos() not defined */
	    PL_reg_ganch = strbeg;
d1850 1
a1850 2

    if (!(flags & REXEC_CHECKED) && (prog->check_substr != Nullsv || prog->check_utf8 != Nullsv)) {
d1857 1
a1857 1
	    DEBUG_r(PerlIO_printf(Perl_debug_log, "Not present...\n"));
d1862 1
a1862 23
    DEBUG_r({
	const char * const s0   = UTF
	    ? pv_uni_display(dsv0, (U8*)prog->precomp, prog->prelen, 60,
			  UNI_DISPLAY_REGEX)
	    : prog->precomp;
	const int len0 = UTF ? SvCUR(dsv0) : prog->prelen;
	const char * const s1 = do_utf8 ? sv_uni_display(dsv1, sv, 60,
					       UNI_DISPLAY_REGEX) : startpos;
	const int len1 = do_utf8 ? SvCUR(dsv1) : strend - startpos;
	 if (!PL_colorset)
	     reginitcolors();
	 PerlIO_printf(Perl_debug_log,
		       "%sMatching REx%s \"%s%*.*s%s%s\" against \"%s%.*s%s%s\"\n",
		       PL_colors[4],PL_colors[5],PL_colors[0],
		       len0, len0, s0,
		       PL_colors[1],
		       len0 > 60 ? "..." : "",
		       PL_colors[0],
		       (int)(len1 > 60 ? 60 : len1),
		       s1, PL_colors[1],
		       (len1 > 60 ? "..." : "")
	      );
    });
d1866 2
a1867 2
    if (prog->reganch & (ROPT_ANCH & ~ROPT_ANCH_GPOS)) {
	if (s == startpos && regtry(prog, startpos))
d1869 2
a1870 2
	else if (PL_multiline || (prog->reganch & ROPT_IMPLICIT)
		 || (prog->reganch & ROPT_ANCH_MBOL)) /* XXXX SBOL? */
d1882 1
a1882 1
		    if (regtry(prog, s))
d1885 1
a1885 1
		    if (s >= end)
d1887 1
a1887 1
		    if (prog->reganch & RE_USE_INTUIT) {
d1900 1
a1900 1
			if (regtry(prog, s))
d1907 7
a1913 2
    } else if (prog->reganch & ROPT_ANCH_GPOS) {
	if (regtry(prog, PL_reg_ganch))
d1919 1
a1919 1
    if ((prog->anchored_substr || prog->anchored_utf8) && prog->reganch & ROPT_SKIP) {
d1931 1
a1931 1
	    while (s < strend) {
d1933 2
a1934 2
		    DEBUG_r( did_match = 1 );
		    if (regtry(prog, s)) goto got_it;
d1939 1
a1939 2
		s += UTF8SKIP(s);
	    }
d1942 1
a1942 1
	    while (s < strend) {
d1944 2
a1945 2
		    DEBUG_r( did_match = 1 );
		    if (regtry(prog, s)) goto got_it;
d1950 1
a1950 2
		s++;
	    }
d1952 1
a1952 1
	DEBUG_r(if (!did_match)
d1957 3
a1959 3
    else if (prog->anchored_substr != Nullsv
	      || prog->anchored_utf8 != Nullsv
	      || ((prog->float_substr != Nullsv || prog->float_utf8 != Nullsv)
d1981 2
d1987 7
a1993 4
	last = HOP3c(strend,	/* Cannot start after this */
			  -(I32)(CHR_SVLEN(must)
				 - (SvTAIL(must) != 0) + back_min), strbeg);

d2006 1
a2006 1
		 ? (s = screaminstr(sv, must, HOP3c(s, back_min, strend) - strbeg,
d2008 1
a2008 1
		 : (s = fbm_instr((unsigned char*)HOP3(s, back_min, strend),
d2010 1
a2010 1
				  PL_multiline ? FBMrf_MULTILINE : 0))) ) {
d2014 1
a2014 1
	    DEBUG_r( did_match = 1 );
d2020 1
a2020 1
		char *t = (last1 >= PL_bostr) ? HOPc(last1, 1) : last1 + 1;
d2023 1
a2023 1
		s = t;		
d2027 1
a2027 1
		    if (regtry(prog, s))
d2034 1
a2034 1
		    if (regtry(prog, s))
d2040 4
a2043 3
	DEBUG_r(if (!did_match)
                    PerlIO_printf(Perl_debug_log, 
                                  "Did not find %s substr \"%s%.*s%s\"%s...\n",
d2046 2
a2047 5
			      PL_colors[0],
			      (int)(SvCUR(must) - (SvTAIL(must)!=0)),
			      SvPVX_const(must),
                                  PL_colors[1], (SvTAIL(must) ? "$" : ""))
               );
d2050 1
a2050 1
    else if ((c = prog->regstclass)) {
d2052 1
a2052 1
	    I32 op = (U8)OP(prog->regstclass);
d2054 1
a2054 1
	    if (PL_regkind[op] != EXACT && op != CANY)
d2057 11
a2067 20
	DEBUG_r({
	    SV *prop = sv_newmortal();
	    const char *s0;
	    const char *s1;
	    int len0;
	    int len1;

	    regprop(prop, c);
	    s0 = UTF ?
	      pv_uni_display(dsv0, (U8*)SvPVX_const(prop), SvCUR(prop), 60,
			     UNI_DISPLAY_REGEX) :
	      SvPVX_const(prop);
	    len0 = UTF ? SvCUR(dsv0) : SvCUR(prop);
	    s1 = UTF ?
	      sv_uni_display(dsv1, sv, 60, UNI_DISPLAY_REGEX) : s;
	    len1 = UTF ? SvCUR(dsv1) : strend - s;
	    PerlIO_printf(Perl_debug_log,
			  "Matching stclass \"%*.*s\" against \"%*.*s\"\n",
			  len0, len0, s0,
			  len1, len1, s1);
d2069 1
a2069 1
        if (find_byclass(prog, c, s, strend, 0))
d2071 1
a2071 1
	DEBUG_r(PerlIO_printf(Perl_debug_log, "Contradicts stclass...\n"));
d2075 1
a2075 1
	if (prog->float_substr != Nullsv || prog->float_utf8 != Nullsv) {
d2100 1
a2100 1
		    else if (!PL_multiline)
d2102 1
a2102 1
			    ? strend - len : Nullch;
d2114 4
a2117 3
		DEBUG_r(PerlIO_printf(Perl_debug_log,
				      "%sCan't trim the tail, match fails (should not happen)%s\n",
				      PL_colors[4],PL_colors[5]));
d2128 1
a2128 1
		if (regtry(prog, s))
d2137 1
a2137 1
		if (regtry(prog, s))
d2149 4
a2152 8
    if (PL_reg_eval_set) {
	/* Preserve the current value of $^R */
	if (oreplsv != GvSV(PL_replgv))
	    sv_setsv(oreplsv, GvSV(PL_replgv));/* So that when GvSV(replgv) is
						  restored, the value remains
						  the same. */
	restore_pos(aTHX_ 0);
    }
d2156 1
a2156 4
	if (RX_MATCH_COPIED(prog)) {
	    Safefree(prog->subbeg);
	    RX_MATCH_COPIED_off(prog);
	}
d2158 19
a2176 4
	    I32 i = PL_regeol - startpos + (stringarg - strbeg);

	    s = savepvn(strbeg, i);
	    prog->subbeg = s;
a2177 1
	    RX_MATCH_COPIED_on(prog);
d2188 2
a2189 2
    DEBUG_r(PerlIO_printf(Perl_debug_log, "%sMatch failed%s\n",
			  PL_colors[4],PL_colors[5]));
d2191 5
a2195 1
	restore_pos(aTHX_ 0);
d2199 1
d2204 1
a2204 1
S_regtry(pTHX_ regexp *prog, char *startpos)
d2206 1
a2206 3
    register I32 i;
    register I32 *sp;
    register I32 *ep;
d2208 4
d2213 1
a2213 4
#ifdef DEBUGGING
    PL_regindent = 0;	/* XXXX Not good when matches are reenterable... */
#endif
    if ((prog->reganch & ROPT_EVAL_SEEN) && !PL_reg_eval_set) {
d2217 1
a2217 1
	DEBUG_r(DEBUG_s(
d2221 1
a2221 1
	SAVEI32(cxstack[cxstack_ix].blk_oldsp);
d2229 1
a2229 1
	if (PL_reg_sv) {
d2231 3
a2233 4
	    if (PL_reg_sv != DEFSV) {
		/* SAVE_DEFSV does *not* suffice here for USE_5005THREADS */
		SAVESPTR(DEFSV);
		DEFSV = PL_reg_sv;
d2236 2
a2237 2
	    if (!(SvTYPE(PL_reg_sv) >= SVt_PVMG && SvMAGIC(PL_reg_sv)
		  && (mg = mg_find(PL_reg_sv, PERL_MAGIC_regex_global)))) {
d2239 6
a2244 3
		sv_magic(PL_reg_sv, (SV*)0,
			PERL_MAGIC_regex_global, Nullch, 0);
		mg = mg_find(PL_reg_sv, PERL_MAGIC_regex_global);
d2249 1
a2249 1
	    SAVEDESTRUCTOR_X(restore_pos, 0);
d2255 1
a2255 1
                SV* repointer = newSViv(0);
d2273 3
d2279 1
a2279 1
	    PL_reg_oldsaved = Nullch;
d2283 3
a2285 4
    prog->startp[0] = startpos - PL_bostr;
    PL_reginput = startpos;
    PL_regstartp = prog->startp;
    PL_regendp = prog->endp;
d2291 1
a2291 1
    DEBUG_r(PL_reg_starttry = startpos);
d2307 3
a2309 4
     * (op/regexp, op/pat, op/split), but that code is needed, oddly
     * enough, for building DynaLoader, or otherwise this
     * "Error: '*' not in typemap in DynaLoader.xs, line 164"
     * will happen.  Meanwhile, this code *is* needed for the
d2312 1
a2312 1
     * --jhi */
a2313 2
    sp = prog->startp;
    ep = prog->endp;
d2315 2
d2318 3
a2320 2
	    *++sp = -1;
	    *++ep = -1;
d2325 2
a2326 2
    if (regmatch(prog->program + 1)) {
	prog->endp[0] = PL_reginput - PL_bostr;
d2329 2
a2334 2
#define RE_UNWIND_BRANCH	1
#define RE_UNWIND_BRANCHJ	2
d2336 23
a2358 1
union re_unwind_t;
d2360 4
a2363 5
typedef struct {		/* XX: makes sense to enlarge it... */
    I32 type;
    I32 prev;
    CHECKPOINT lastcp;
} re_unwind_generic_t;
d2365 5
a2369 10
typedef struct {
    I32 type;
    I32 prev;
    CHECKPOINT lastcp;
    I32 lastparen;
    regnode *next;
    char *locinput;
    I32 nextchr;
#ifdef DEBUGGING
    int regindent;
d2371 11
a2381 1
} re_unwind_branch_t;
d2383 13
a2395 5
typedef union re_unwind_t {
    I32 type;
    re_unwind_generic_t generic;
    re_unwind_branch_t branch;
} re_unwind_t;
a2396 44
#define sayYES goto yes
#define sayNO goto no
#define sayNO_ANYOF goto no_anyof
#define sayYES_FINAL goto yes_final
#define sayYES_LOUD  goto yes_loud
#define sayNO_FINAL  goto no_final
#define sayNO_SILENT goto do_no
#define saySAME(x) if (x) goto yes; else goto no

#define POSCACHE_SUCCESS 0	/* caching success rather than failure */
#define POSCACHE_SEEN 1		/* we know what we're caching */
#define POSCACHE_START 2	/* the real cache: this bit maps to pos 0 */
#define CACHEsayYES STMT_START { \
    if (cache_offset | cache_bit) { \
	if (!(PL_reg_poscache[0] & (1<<POSCACHE_SEEN))) \
	    PL_reg_poscache[0] |= (1<<POSCACHE_SUCCESS) || (1<<POSCACHE_SEEN); \
        else if (!(PL_reg_poscache[0] & (1<<POSCACHE_SUCCESS))) { \
	    /* cache records failure, but this is success */ \
	    DEBUG_r( \
		PerlIO_printf(Perl_debug_log, \
		    "%*s  (remove success from failure cache)\n", \
		    REPORT_CODE_OFF+PL_regindent*2, "") \
	    ); \
	    PL_reg_poscache[cache_offset] &= ~(1<<cache_bit); \
	} \
    } \
    sayYES; \
} STMT_END
#define CACHEsayNO STMT_START { \
    if (cache_offset | cache_bit) { \
	if (!(PL_reg_poscache[0] & (1<<POSCACHE_SEEN))) \
	    PL_reg_poscache[0] |= (1<<POSCACHE_SEEN); \
        else if ((PL_reg_poscache[0] & (1<<POSCACHE_SUCCESS))) { \
	    /* cache records success, but this is failure */ \
	    DEBUG_r( \
		PerlIO_printf(Perl_debug_log, \
		    "%*s  (remove failure from success cache)\n", \
		    REPORT_CODE_OFF+PL_regindent*2, "") \
	    ); \
	    PL_reg_poscache[cache_offset] &= ~(1<<cache_bit); \
	} \
    } \
    sayNO; \
} STMT_END
a2397 1
#define REPORT_CODE_OFF 24
d2400 248
a2647 12
 - regmatch - main matching routine
 *
 * Conceptually the strategy is simple:  check to see whether the current
 * node matches, call self recursively to see whether the rest matches,
 * and then act accordingly.  In practice we make some effort to avoid
 * recursion, in particular by going through "ordinary" nodes (that don't
 * need to know whether the rest of the match failed) by a loop instead of
 * by recursion.
 */
/* [lwall] I've hoisted the register declarations to the outer block in order to
 * maybe save a little bit of pushing and popping on the stack.  It also takes
 * advantage of machines that use a register save mask on subroutine entry.
d2649 40
d2690 1
a2690 1
S_regmatch(pTHX_ regnode *prog)
d2692 2
a2693 14
    register regnode *scan;	/* Current node. */
    regnode *next;		/* Next node. */
    regnode *inner;		/* Next node in internal branch. */
    register I32 nextchr;	/* renamed nextchr - nextchar colides with
				   function of same name */
    register I32 n;		/* no or next */
    register I32 ln = 0;	/* len or last */
    register char *s = Nullch;	/* operand or save */
    register char *locinput = PL_reginput;
    register I32 c1 = 0, c2 = 0, paren;	/* case fold search, parenth */
    int minmod = 0, sw = 0, logical = 0;
    I32 unwind = 0;
#if 0
    I32 firstcp = PL_savestack_ix;
d2695 1
d2697 62
d2760 1
a2760 3
    SV *dsv0 = PERL_DEBUG_PAD_ZERO(0);
    SV *dsv1 = PERL_DEBUG_PAD_ZERO(1);
    SV *dsv2 = PERL_DEBUG_PAD_ZERO(2);
a2761 1
    U32 uniflags = ckWARN(WARN_UTF8) ? 0 : UTF8_ALLOW_ANY;
d2763 20
a2782 3
#ifdef DEBUGGING
    PL_regindent++;
#endif
d2789 12
a2800 63
        DEBUG_r( {
	    SV *prop = sv_newmortal();
	    const int docolor = *PL_colors[0];
	    const int taill = (docolor ? 10 : 7); /* 3 chars for "> <" */
	    int l = (PL_regeol - locinput) > taill ? taill : (PL_regeol - locinput);
	    /* The part of the string before starttry has one color
	       (pref0_len chars), between starttry and current
	       position another one (pref_len - pref0_len chars),
	       after the current position the third one.
	       We assume that pref0_len <= pref_len, otherwise we
	       decrease pref0_len.  */
	    int pref_len = (locinput - PL_bostr) > (5 + taill) - l
		? (5 + taill) - l : locinput - PL_bostr;
	    int pref0_len;

	    while (do_utf8 && UTF8_IS_CONTINUATION(*(U8*)(locinput - pref_len)))
		pref_len++;
	    pref0_len = pref_len  - (locinput - PL_reg_starttry);
	    if (l + pref_len < (5 + taill) && l < PL_regeol - locinput)
		l = ( PL_regeol - locinput > (5 + taill) - pref_len
		      ? (5 + taill) - pref_len : PL_regeol - locinput);
	    while (do_utf8 && UTF8_IS_CONTINUATION(*(U8*)(locinput + l)))
		l--;
	    if (pref0_len < 0)
		pref0_len = 0;
	    if (pref0_len > pref_len)
		pref0_len = pref_len;
	    regprop(prop, scan);
	    {
	      const char * const s0 =
		do_utf8 && OP(scan) != CANY ?
		pv_uni_display(dsv0, (U8*)(locinput - pref_len),
			       pref0_len, 60, UNI_DISPLAY_REGEX) :
		locinput - pref_len;
	      const int len0 = do_utf8 ? strlen(s0) : pref0_len;
	      const char * const s1 = do_utf8 && OP(scan) != CANY ?
		pv_uni_display(dsv1, (U8*)(locinput - pref_len + pref0_len),
			       pref_len - pref0_len, 60, UNI_DISPLAY_REGEX) :
		locinput - pref_len + pref0_len;
	      const int len1 = do_utf8 ? strlen(s1) : pref_len - pref0_len;
	      const char * const s2 = do_utf8 && OP(scan) != CANY ?
		pv_uni_display(dsv2, (U8*)locinput,
			       PL_regeol - locinput, 60, UNI_DISPLAY_REGEX) :
		locinput;
	      const int len2 = do_utf8 ? strlen(s2) : l;
	      PerlIO_printf(Perl_debug_log,
			    "%4"IVdf" <%s%.*s%s%s%.*s%s%s%s%.*s%s>%*s|%3"IVdf":%*s%s\n",
			    (IV)(locinput - PL_bostr),
			    PL_colors[4],
			    len0, s0,
			    PL_colors[5],
			    PL_colors[2],
			    len1, s1,
			    PL_colors[3],
			    (docolor ? "" : "> <"),
			    PL_colors[0],
			    len2, s2,
			    PL_colors[1],
			    15 - l - pref_len + 1,
			    "",
			    (IV)(scan - PL_regprogram), PL_regindent*2, "",
			    SvPVX_const(prop));
	    }
d2806 1
d2808 2
a2809 1
	switch (OP(scan)) {
d2811 1
a2811 2
	    if (locinput == PL_bostr || (PL_multiline &&
		(nextchr || locinput < PL_regeol) && locinput[-1] == '\n') )
d2813 1
a2813 1
		/* regtill = regbol; */
d2829 1
a2829 1
	    if (locinput == PL_reg_ganch)
d2832 13
a2845 3
	    if (PL_multiline)
		goto meol;
	    else
a2847 1
	  meol:
d2891 310
a3200 2
	case EXACT:
	    s = STRING(scan);
d3205 1
a3205 1
		const char *e = s + ln;
d3250 1
d3254 2
a3255 2
	case EXACTF:
	    s = STRING(scan);
d3260 1
a3260 1
		char *l = locinput;
d3269 1
d3271 1
a3271 1
			   toLOWER(s[0]) == 's' &&
d3300 1
d3305 2
a3306 2
	        if (!reginclass(scan, (U8*)locinput, &inclasslen, do_utf8))
		    sayNO_ANYOF;
d3316 2
a3317 2
		if (!REGINCLASS(scan, (U8*)locinput))
		    sayNO_ANYOF;
d3323 1
a3323 1
	no_anyof:
d3343 1
a3343 1
		      ? swash_fetch(PL_utf8_alnum, (U8*)locinput, do_utf8)
d3366 1
a3366 1
		    ? swash_fetch(PL_utf8_alnum, (U8*)locinput, do_utf8)
d3393 1
a3393 1
		    ln = utf8n_to_uvchr((U8 *)r, UTF8SKIP(r), 0, 0);
d3431 1
a3431 1
			  ? swash_fetch(PL_utf8_space, (U8*)locinput, do_utf8)
d3461 1
a3461 1
		    ? swash_fetch(PL_utf8_space, (U8*)locinput, do_utf8)
d3484 1
a3484 1
		      ? swash_fetch(PL_utf8_digit, (U8*)locinput, do_utf8)
d3507 1
a3507 1
		    ? swash_fetch(PL_utf8_digit, (U8*)locinput, do_utf8)
d3539 19
d3562 1
a3562 1
	case REFF:
d3564 3
a3566 1
	    ln = PL_regstartp[n];
d3568 1
a3568 1
	    if ((I32)*PL_reglastparen < n || ln == -1)
d3570 1
a3570 1
	    if (ln == PL_regendp[n])
d3574 1
a3574 1
	    if (do_utf8 && OP(scan) != REF) {	/* REF can do byte comparison */
d3576 1
a3576 1
		const char *e = PL_bostr + PL_regendp[n];
d3582 1
a3582 1
		if (OP(scan) == REFF) {
d3605 3
a3607 3
		(OP(scan) == REF ||
		 (UCHARAT(s) != ((OP(scan) == REFF
				  ? PL_fold : PL_fold_locale)[nextchr]))))
d3609 1
a3609 1
	    ln = PL_regendp[n] - ln;
d3612 1
a3612 1
	    if (ln > 1 && (OP(scan) == REF
d3614 1
a3614 1
			   : (OP(scan) == REFF
d3621 1
a3621 1

d3627 3
a3629 1
	case EVAL:
a3630 4
	    dSP;
	    OP_4tree *oop = PL_op;
	    COP *ocurcop = PL_curcop;
	    PAD *old_comppad;
d3632 54
a3685 7
	    struct regexp *oreg = PL_reg_re;
	
	    n = ARG(scan);
	    PL_op = (OP_4tree*)PL_regdata->data[n];
	    DEBUG_r( PerlIO_printf(Perl_debug_log, "  re_eval 0x%"UVxf"\n", PTR2UV(PL_op)) );
	    PAD_SAVE_LOCAL(old_comppad, (PAD*)PL_regdata->data[n + 2]);
	    PL_regendp[0] = PL_reg_magic->mg_len = locinput - PL_bostr;
a3686 2
	    {
		SV **before = SP;
d3695 9
d3705 5
d3711 2
a3712 12
	    PL_op = oop;
	    PAD_RESTORE_LOCAL(old_comppad);
	    PL_curcop = ocurcop;
	    if (logical) {
		if (logical == 2) {	/* Postponed subexpression. */
		    regexp *re;
		    MAGIC *mg = Null(MAGIC*);
		    re_cc_state state;
		    CHECKPOINT cp, lastcp;
                    int toggleutf;
		    register SV *sv;

d3723 1
a3723 2
			re = (regexp *)mg->mg_obj;
			(void)ReREFCNT_inc(re);
d3726 1
a3726 4
			STRLEN len;
			const char *t = SvPV_const(ret, len);
			PMOP pm;
			char * const oprecomp = PL_regprecomp;
a3727 1
			const I32 onpar = PL_regnpar;
d3729 2
a3730 3
			Zero(&pm, 1, PMOP);
                        if (DO_UTF8(ret)) pm.op_pmdynflags |= PMdf_DYN_UTF8;
			re = CALLREGCOMP(aTHX_ (char*)t, (char*)t + len, &pm);
a3735 1
			PL_regprecomp = oprecomp;
a3736 1
			PL_regnpar = onpar;
d3738 31
a3768 12
		    DEBUG_r(
			PerlIO_printf(Perl_debug_log,
				      "Entering embedded \"%s%.60s%s%s\"\n",
				      PL_colors[0],
				      re->precomp,
				      PL_colors[1],
				      (strlen(re->precomp) > 60 ? "..." : ""))
			);
		    state.node = next;
		    state.prev = PL_reg_call_cc;
		    state.cc = PL_regcc;
		    state.re = PL_reg_re;
d3770 2
a3771 45
		    PL_regcc = 0;
		
		    cp = regcppush(0);	/* Save *all* the positions. */
		    REGCP_SET(lastcp);
		    cache_re(re);
		    state.ss = PL_savestack_ix;
		    *PL_reglastparen = 0;
		    *PL_reglastcloseparen = 0;
		    PL_reg_call_cc = &state;
		    PL_reginput = locinput;
		    toggleutf = ((PL_reg_flags & RF_utf8) != 0) ^
				((re->reganch & ROPT_UTF8) != 0);
		    if (toggleutf) PL_reg_flags ^= RF_utf8;

		    /* XXXX This is too dramatic a measure... */
		    PL_reg_maxiter = 0;

		    if (regmatch(re->program + 1)) {
			/* Even though we succeeded, we need to restore
			   global variables, since we may be wrapped inside
			   SUSPEND, thus the match may be not finished yet. */

			/* XXXX Do this only if SUSPENDed? */
			PL_reg_call_cc = state.prev;
			PL_regcc = state.cc;
			PL_reg_re = state.re;
			cache_re(PL_reg_re);
			if (toggleutf) PL_reg_flags ^= RF_utf8;

			/* XXXX This is too dramatic a measure... */
			PL_reg_maxiter = 0;

			/* These are needed even if not SUSPEND. */
			ReREFCNT_dec(re);
			regcpblow(cp);
			sayYES;
		    }
		    ReREFCNT_dec(re);
		    REGCP_UNWIND(lastcp);
		    regcppop();
		    PL_reg_call_cc = state.prev;
		    PL_regcc = state.cc;
		    PL_reg_re = state.re;
		    cache_re(PL_reg_re);
		    if (toggleutf) PL_reg_flags ^= RF_utf8;
d3773 6
a3778 2
		    /* XXXX This is too dramatic a measure... */
		    PL_reg_maxiter = 0;
d3780 15
a3794 10
		    logical = 0;
		    sayNO;
		}
		sw = SvTRUE(ret);
		logical = 0;
	    }
	    else {
		sv_setsv(save_scalar(PL_replgv), ret);
		cache_re(oreg);
	    }
d3797 35
d3837 1
d3841 5
a3845 3
	    PL_regstartp[n] = PL_reg_start_tmp[n] - PL_bostr;
	    PL_regendp[n] = locinput - PL_bostr;
	    if (n > (I32)*PL_reglastparen)
d3848 31
a3878 1
	    break;
d3881 1
a3881 1
	    sw = ((I32)*PL_reglastparen >= n && PL_regendp[n] != -1);
d3883 11
d3907 1
a3908 2
 PL_regcc contains infoblock about the innermost (...)* loop, and
 a pointer to the next outer infoblock.
d3910 128
a4037 1
 Here is how Y(A)*Z is processed (if it is compiled into CURLYX/WHILEM):
a4038 1
   1) After matching X, regnode for CURLYX is processed;
d4040 21
a4060 105
   2) This regnode creates infoblock on the stack, and calls
      regmatch() recursively with the starting point at WHILEM node;

   3) Each hit of WHILEM node tries to match A and Z (in the order
      depending on the current iteration, min/max of {min,max} and
      greediness).  The information about where are nodes for "A"
      and "Z" is read from the infoblock, as is info on how many times "A"
      was already matched, and greediness.

   4) After A matches, the same WHILEM node is hit again.

   5) Each time WHILEM is hit, PL_regcc is the infoblock created by CURLYX
      of the same pair.  Thus when WHILEM tries to match Z, it temporarily
      resets PL_regcc, since this Y(A)*Z can be a part of some other loop:
      as in (Y(A)*Z)*.  If Z matches, the automaton will hit the WHILEM node
      of the external loop.

 Currently present infoblocks form a tree with a stem formed by PL_curcc
 and whatever it mentions via ->next, and additional attached trees
 corresponding to temporarily unset infoblocks as in "5" above.

 In the following picture infoblocks for outer loop of
 (Y(A)*?Z)*?T are denoted O, for inner I.  NULL starting block
 is denoted by x.  The matched string is YAAZYAZT.  Temporarily postponed
 infoblocks are drawn below the "reset" infoblock.

 In fact in the picture below we do not show failed matches for Z and T
 by WHILEM blocks.  [We illustrate minimal matches, since for them it is
 more obvious *why* one needs to *temporary* unset infoblocks.]

  Matched	REx position	InfoBlocks	Comment
  		(Y(A)*?Z)*?T	x
  		Y(A)*?Z)*?T	x <- O
  Y		(A)*?Z)*?T	x <- O
  Y		A)*?Z)*?T	x <- O <- I
  YA		)*?Z)*?T	x <- O <- I
  YA		A)*?Z)*?T	x <- O <- I
  YAA		)*?Z)*?T	x <- O <- I
  YAA		Z)*?T		x <- O		# Temporary unset I
				     I

  YAAZ		Y(A)*?Z)*?T	x <- O
				     I

  YAAZY		(A)*?Z)*?T	x <- O
				     I

  YAAZY		A)*?Z)*?T	x <- O <- I
				     I

  YAAZYA	)*?Z)*?T	x <- O <- I	
				     I

  YAAZYA	Z)*?T		x <- O		# Temporary unset I
				     I,I

  YAAZYAZ	)*?T		x <- O
				     I,I

  YAAZYAZ	T		x		# Temporary unset O
				O
				I,I

  YAAZYAZT			x
				O
				I,I
 *******************************************************************/
	case CURLYX: {
		CURCUR cc;
		CHECKPOINT cp = PL_savestack_ix;
		/* No need to save/restore up to this paren */
		I32 parenfloor = scan->flags;

		if (OP(PREVOPER(next)) == NOTHING) /* LONGJMP */
		    next += ARG(next);
		cc.oldcc = PL_regcc;
		PL_regcc = &cc;
		/* XXXX Probably it is better to teach regpush to support
		   parenfloor > PL_regsize... */
		if (parenfloor > (I32)*PL_reglastparen)
		    parenfloor = *PL_reglastparen; /* Pessimization... */
		cc.parenfloor = parenfloor;
		cc.cur = -1;
		cc.min = ARG1(scan);
		cc.max  = ARG2(scan);
		cc.scan = NEXTOPER(scan) + EXTRA_STEP_2ARGS;
		cc.next = next;
		cc.minmod = minmod;
		cc.lastloc = 0;
		PL_reginput = locinput;
		n = regmatch(PREVOPER(next));	/* start on the WHILEM */
		regcpblow(cp);
		PL_regcc = cc.oldcc;
		saySAME(n);
	    }
	    /* NOT REACHED */
	case WHILEM: {
		/*
		 * This is really hard to understand, because after we match
		 * what we're trying to match, we must make sure the rest of
		 * the REx is going to match for sure, and to do that we have
		 * to go back UP the parse tree by recursing ever deeper.  And
		 * if it fails, we have to reset our parent's current state
		 * that we can try again after backing off.
		 */
d4062 1
a4062 7
		CHECKPOINT cp, lastcp;
		CURCUR* cc = PL_regcc;
		char *lastloc = cc->lastloc; /* Detection of 0-len. */
		I32 cache_offset = 0, cache_bit = 0;
		
		n = cc->cur + 1;	/* how many we know we matched */
		PL_reginput = locinput;
d4064 5
a4068 7
		DEBUG_r(
		    PerlIO_printf(Perl_debug_log,
				  "%*s  %ld out of %ld..%ld  cc=%"UVxf"\n",
				  REPORT_CODE_OFF+PL_regindent*2, "",
				  (long)n, (long)cc->min,
				  (long)cc->max, PTR2UV(cc))
		    );
d4070 1
a4070 1
		/* If degenerate scan matches "", assume scan done. */
d4072 7
a4078 16
		if (locinput == cc->lastloc && n >= cc->min) {
		    PL_regcc = cc->oldcc;
		    if (PL_regcc)
			ln = PL_regcc->cur;
		    DEBUG_r(
			PerlIO_printf(Perl_debug_log,
			   "%*s  empty match detected, try continuation...\n",
			   REPORT_CODE_OFF+PL_regindent*2, "")
			);
		    if (regmatch(cc->next))
			sayYES;
		    if (PL_regcc)
			PL_regcc->cur = ln;
		    PL_regcc = cc;
		    sayNO;
		}
d4080 1
a4080 1
		/* First just match a string of min scans. */
d4082 1
a4082 9
		if (n < cc->min) {
		    cc->cur = n;
		    cc->lastloc = locinput;
		    if (regmatch(cc->scan))
			sayYES;
		    cc->cur = n - 1;
		    cc->lastloc = lastloc;
		    sayNO;
		}
a4083 4
		if (scan->flags) {
		    /* Check whether we already were at this position.
			Postpone detection until we know the match is not
			*that* much linear. */
d4085 2
d4088 3
d4093 1
d4095 2
a4096 1
		    const I32 size = (PL_reg_maxiter + 7 + POSCACHE_START)/8;
d4108 4
a4111 5
		    DEBUG_r(
			PerlIO_printf(Perl_debug_log,
	      "%sDetected a super-linear match, switching on caching%s...\n",
				      PL_colors[4], PL_colors[5])
			);
d4113 1
d4115 10
a4124 11
		    cache_offset = locinput - PL_bostr;

		    cache_offset = (scan->flags & 0xf) - 1 + POSCACHE_START
			    + cache_offset * (scan->flags>>4);
		    cache_bit = cache_offset % 8;
		    cache_offset /= 8;
		    if (PL_reg_poscache[cache_offset] & (1<<cache_bit)) {
		    DEBUG_r(
			PerlIO_printf(Perl_debug_log,
				      "%*s  already tried at this position...\n",
				      REPORT_CODE_OFF+PL_regindent*2, "")
d4126 1
a4126 6
			if (PL_reg_poscache[0] & (1<<POSCACHE_SUCCESS))
			    /* cache records success */
			    sayYES;
			else
			    /* cache records failure */
			    sayNO_SILENT;
d4128 2
a4129 2
		    PL_reg_poscache[cache_offset] |= (1<<cache_bit);
		}
d4131 25
d4157 5
a4161 1
		/* Prefer next over scan for minimal matching. */
d4163 6
a4168 26
		if (cc->minmod) {
		    PL_regcc = cc->oldcc;
		    if (PL_regcc)
			ln = PL_regcc->cur;
		    cp = regcppush(cc->parenfloor);
		    REGCP_SET(lastcp);
		    if (regmatch(cc->next)) {
			regcpblow(cp);
			CACHEsayYES;	/* All done. */
		    }
		    REGCP_UNWIND(lastcp);
		    regcppop();
		    if (PL_regcc)
			PL_regcc->cur = ln;
		    PL_regcc = cc;

		    if (n >= cc->max) {	/* Maximum greed exceeded? */
			if (ckWARN(WARN_REGEXP) && n >= REG_INFTY
			    && !(PL_reg_flags & RF_warned)) {
			    PL_reg_flags |= RF_warned;
			    Perl_warner(aTHX_ packWARN(WARN_REGEXP), "%s limit (%d) exceeded",
				 "Complex regular subexpression recursion",
				 REG_INFTY - 1);
			}
			CACHEsayNO;
		    }
d4170 51
a4220 41
		    DEBUG_r(
			PerlIO_printf(Perl_debug_log,
				      "%*s  trying longer...\n",
				      REPORT_CODE_OFF+PL_regindent*2, "")
			);
		    /* Try scanning more and see if it helps. */
		    PL_reginput = locinput;
		    cc->cur = n;
		    cc->lastloc = locinput;
		    cp = regcppush(cc->parenfloor);
		    REGCP_SET(lastcp);
		    if (regmatch(cc->scan)) {
			regcpblow(cp);
			CACHEsayYES;
		    }
		    REGCP_UNWIND(lastcp);
		    regcppop();
		    cc->cur = n - 1;
		    cc->lastloc = lastloc;
		    CACHEsayNO;
		}

		/* Prefer scan over next for maximal matching. */

		if (n < cc->max) {	/* More greed allowed? */
		    cp = regcppush(cc->parenfloor);
		    cc->cur = n;
		    cc->lastloc = locinput;
		    REGCP_SET(lastcp);
		    if (regmatch(cc->scan)) {
			regcpblow(cp);
			CACHEsayYES;
		    }
		    REGCP_UNWIND(lastcp);
		    regcppop();		/* Restore some previous $<digit>s? */
		    PL_reginput = locinput;
		    DEBUG_r(
			PerlIO_printf(Perl_debug_log,
				      "%*s  failed, try continuation...\n",
				      REPORT_CODE_OFF+PL_regindent*2, "")
			);
d4222 1
a4222 19
		if (ckWARN(WARN_REGEXP) && n >= REG_INFTY
			&& !(PL_reg_flags & RF_warned)) {
		    PL_reg_flags |= RF_warned;
		    Perl_warner(aTHX_ packWARN(WARN_REGEXP), "%s limit (%d) exceeded",
			 "Complex regular subexpression recursion",
			 REG_INFTY - 1);
		}

		/* Failed deeper matches of scan, so see if this one works. */
		PL_regcc = cc->oldcc;
		if (PL_regcc)
		    ln = PL_regcc->cur;
		if (regmatch(cc->next))
		    CACHEsayYES;
		if (PL_regcc)
		    PL_regcc->cur = ln;
		PL_regcc = cc;
		cc->cur = n - 1;
		cc->lastloc = lastloc;
d4225 16
a4240 2
	    /* NOT REACHED */
	case BRANCHJ:
d4244 2
a4245 29
	    inner = NEXTOPER(NEXTOPER(scan));
	    goto do_branch;
	case BRANCH:
	    inner = NEXTOPER(scan);
	  do_branch:
	    {
		c1 = OP(scan);
		if (OP(next) != c1)	/* No choice. */
		    next = inner;	/* Avoid recursion. */
		else {
		    const I32 lastparen = *PL_reglastparen;
		    I32 unwind1;
		    re_unwind_branch_t *uw;

		    /* Put unwinding data on stack */
		    unwind1 = SSNEWt(1,re_unwind_branch_t);
		    uw = SSPTRt(unwind1,re_unwind_branch_t);
		    uw->prev = unwind;
		    unwind = unwind1;
		    uw->type = ((c1 == BRANCH)
				? RE_UNWIND_BRANCH
				: RE_UNWIND_BRANCHJ);
		    uw->lastparen = lastparen;
		    uw->next = next;
		    uw->locinput = locinput;
		    uw->nextchr = nextchr;
#ifdef DEBUGGING
		    uw->regindent = ++PL_regindent;
#endif
d4247 6
a4252 1
		    REGCP_SET(uw->lastcp);
d4254 5
a4258 3
		    /* Now go into the first branch */
		    next = inner;
		}
d4260 42
a4301 1
	    break;
d4305 18
a4322 12
	case CURLYM:
	{
	    I32 l = 0;
	    CHECKPOINT lastcp;
	
	    /* We suppose that the next guy does not need
	       backtracking: in particular, it is of constant non-zero length,
	       and has no parenths to influence future backrefs. */
	    ln = ARG1(scan);  /* min to match */
	    n  = ARG2(scan);  /* max to match */
	    paren = scan->flags;
	    if (paren) {
d4325 1
a4325 1
		if (paren > (I32)*PL_reglastparen)
d4327 1
d4329 13
a4341 3
	    scan = NEXTOPER(scan) + NODE_STEP_REGNODE;
	    if (paren)
		scan += NEXT_OFF(scan); /* Skip former OPEN. */
d4343 2
a4344 7
	    if (minmod) {
		minmod = 0;
		if (ln && regrepeat_hard(scan, ln, &l) < ln)
		    sayNO;
		locinput = PL_reginput;
		if (HAS_TEXT(next) || JUMPABLE(next)) {
		    regnode *text_node = next;
d4346 3
a4348 1
		    if (! HAS_TEXT(text_node)) FIND_NEXT_IMPT(text_node);
d4350 8
a4357 13
		    if (! HAS_TEXT(text_node)) c1 = c2 = -1000;
		    else {
			if (PL_regkind[(U8)OP(text_node)] == REF) {
			    c1 = c2 = -1000;
			    goto assume_ok_MM;
			}
			else { c1 = (U8)*STRING(text_node); }
			if (OP(text_node) == EXACTF || OP(text_node) == REFF)
			    c2 = PL_fold[c1];
			else if (OP(text_node) == EXACTFL || OP(text_node) == REFFL)
			    c2 = PL_fold_locale[c1];
			else
			    c2 = c1;
d4360 51
a4410 9
		else
		    c1 = c2 = -1000;
	    assume_ok_MM:
		REGCP_SET(lastcp);
		while (n >= ln || (n == REG_INFTY && ln > 0)) { /* ln overflow ? */
		    /* If it could work, try it. */
		    if (c1 == -1000 ||
			UCHARAT(PL_reginput) == c1 ||
			UCHARAT(PL_reginput) == c2)
d4412 8
a4419 18
			if (paren) {
			    if (ln) {
				PL_regstartp[paren] =
				    HOPc(PL_reginput, -l) - PL_bostr;
				PL_regendp[paren] = PL_reginput - PL_bostr;
			    }
			    else
				PL_regendp[paren] = -1;
			}
			if (regmatch(next))
			    sayYES;
			REGCP_UNWIND(lastcp);
		    }
		    /* Couldn't or didn't -- move forward. */
		    PL_reginput = locinput;
		    if (regrepeat_hard(scan, 1, &l)) {
			ln++;
			locinput = PL_reginput;
a4420 2
		    else
			sayNO;
d4423 13
a4435 4
	    else {
		n = regrepeat_hard(scan, n, &l);
		locinput = PL_reginput;
		DEBUG_r(
d4437 59
a4495 7
				  "%*s  matched %"IVdf" times, len=%"IVdf"...\n",
				  (int)(REPORT_CODE_OFF+PL_regindent*2), "",
				  (IV) n, (IV)l)
		    );
		if (n >= ln) {
		    if (HAS_TEXT(next) || JUMPABLE(next)) {
			regnode *text_node = next;
d4497 24
a4520 51
			if (! HAS_TEXT(text_node)) FIND_NEXT_IMPT(text_node);

			if (! HAS_TEXT(text_node)) c1 = c2 = -1000;
			else {
			    if (PL_regkind[(U8)OP(text_node)] == REF) {
				c1 = c2 = -1000;
				goto assume_ok_REG;
			    }
			    else { c1 = (U8)*STRING(text_node); }

			    if (OP(text_node) == EXACTF || OP(text_node) == REFF)
				c2 = PL_fold[c1];
			    else if (OP(text_node) == EXACTFL || OP(text_node) == REFFL)
				c2 = PL_fold_locale[c1];
			    else
				c2 = c1;
			}
		    }
		    else
			c1 = c2 = -1000;
		}
	    assume_ok_REG:
		REGCP_SET(lastcp);
		while (n >= ln) {
		    /* If it could work, try it. */
		    if (c1 == -1000 ||
			UCHARAT(PL_reginput) == c1 ||
			UCHARAT(PL_reginput) == c2)
		    {
			DEBUG_r(
				PerlIO_printf(Perl_debug_log,
					      "%*s  trying tail with n=%"IVdf"...\n",
					      (int)(REPORT_CODE_OFF+PL_regindent*2), "", (IV)n)
			    );
			if (paren) {
			    if (n) {
				PL_regstartp[paren] = HOPc(PL_reginput, -l) - PL_bostr;
				PL_regendp[paren] = PL_reginput - PL_bostr;
			    }
			    else
				PL_regendp[paren] = -1;
			}
			if (regmatch(next))
			    sayYES;
			REGCP_UNWIND(lastcp);
		    }
		    /* Couldn't or didn't -- back up. */
		    n--;
		    locinput = HOPc(locinput, -l);
		    PL_reginput = locinput;
		}
a4521 11
	    sayNO;
	    break;
	}
	case CURLYN:
	    paren = scan->flags;	/* Which paren to set */
	    if (paren > PL_regsize)
		PL_regsize = paren;
	    if (paren > (I32)*PL_reglastparen)
		*PL_reglastparen = paren;
	    ln = ARG1(scan);  /* min to match */
	    n  = ARG2(scan);  /* max to match */
d4524 4
a4527 4
	case CURLY:
	    paren = 0;
	    ln = ARG1(scan);  /* min to match */
	    n  = ARG2(scan);  /* max to match */
a4528 12
	    goto repeat;
	case STAR:
	    ln = 0;
	    n = REG_INFTY;
	    scan = NEXTOPER(scan);
	    paren = 0;
	    goto repeat;
	case PLUS:
	    ln = 1;
	    n = REG_INFTY;
	    scan = NEXTOPER(scan);
	    paren = 0;
d4533 1
a4533 3
	    */

	    /*
d4539 2
d4545 2
a4546 1
		if (! HAS_TEXT(text_node)) FIND_NEXT_IMPT(text_node);
d4548 2
a4549 1
		if (! HAS_TEXT(text_node)) c1 = c2 = -1000;
d4551 2
a4552 2
		    if (PL_regkind[(U8)OP(text_node)] == REF) {
			c1 = c2 = -1000;
d4555 9
a4563 2
		    else { s = (U8*)STRING(text_node); }

d4565 5
a4569 5
			c2 = c1 = *s;
			if (OP(text_node) == EXACTF || OP(text_node) == REFF)
			    c2 = PL_fold[c1];
			else if (OP(text_node) == EXACTFL || OP(text_node) == REFFL)
			    c2 = PL_fold_locale[c1];
d4572 1
a4572 1
			if (OP(text_node) == EXACTF || OP(text_node) == REFF) {
d4579 13
a4591 5

			     c1 = utf8n_to_uvuni(tmpbuf1, UTF8_MAXBYTES, 0,
						 uniflags);
			     c2 = utf8n_to_uvuni(tmpbuf2, UTF8_MAXBYTES, 0,
						 uniflags);
d4594 1
a4594 1
			    c2 = c1 = utf8n_to_uvchr(s, UTF8_MAXBYTES, 0,
d4601 1
a4601 1
		c1 = c2 = -1000;
d4603 3
a4607 1
		CHECKPOINT lastcp;
d4609 1
a4609 1
		if (ln && regrepeat(scan, ln) < ln)
d4611 1
d4613 19
a4631 85
		REGCP_SET(lastcp);
		if (c1 != -1000) {
		    char *e; /* Should not check after this */
		    char *old = locinput;
		    int count = 0;

		    if  (n == REG_INFTY) {
			e = PL_regeol - 1;
			if (do_utf8)
			    while (UTF8_IS_CONTINUATION(*(U8*)e))
				e--;
		    }
		    else if (do_utf8) {
			int m = n - ln;
			for (e = locinput;
			     m >0 && e + UTF8SKIP(e) <= PL_regeol; m--)
			    e += UTF8SKIP(e);
		    }
		    else {
			e = locinput + n - ln;
			if (e >= PL_regeol)
			    e = PL_regeol - 1;
		    }
		    while (1) {
			/* Find place 'next' could work */
			if (!do_utf8) {
			    if (c1 == c2) {
				while (locinput <= e &&
				       UCHARAT(locinput) != c1)
				    locinput++;
			    } else {
				while (locinput <= e
				       && UCHARAT(locinput) != c1
				       && UCHARAT(locinput) != c2)
				    locinput++;
			    }
			    count = locinput - old;
			}
			else {
			    if (c1 == c2) {
				STRLEN len;
				/* count initialised to
				 * utf8_distance(old, locinput) */
				while (locinput <= e &&
				       utf8n_to_uvchr((U8*)locinput,
						      UTF8_MAXBYTES, &len,
						      uniflags) != (UV)c1) {
				    locinput += len;
				    count++;
				}
			    } else {
				STRLEN len;
				/* count initialised to
				 * utf8_distance(old, locinput) */
				while (locinput <= e) {
				    UV c = utf8n_to_uvchr((U8*)locinput,
							  UTF8_MAXBYTES, &len,
							  uniflags);
				    if (c == (UV)c1 || c == (UV)c2)
					break;
				    locinput += len;
				    count++;
				}
			    }
			}
			if (locinput > e)
			    sayNO;
			/* PL_reginput == old now */
			if (locinput != old) {
			    ln = 1;	/* Did some */
			    if (regrepeat(scan, count) < count)
				sayNO;
			}
			/* PL_reginput == locinput now */
			TRYPAREN(paren, ln, locinput);
			PL_reginput = locinput;	/* Could be reset... */
			REGCP_UNWIND(lastcp);
			/* Couldn't or didn't -- move forward. */
			old = locinput;
			if (do_utf8)
			    locinput += UTF8SKIP(locinput);
			else
			    locinput++;
			count = 1;
		    }
d4633 4
a4636 31
		else
		while (n >= ln || (n == REG_INFTY && ln > 0)) { /* ln overflow ? */
		    UV c;
		    if (c1 != -1000) {
			if (do_utf8)
			    c = utf8n_to_uvchr((U8*)PL_reginput,
					       UTF8_MAXBYTES, 0,
					       uniflags);
			else
			    c = UCHARAT(PL_reginput);
			/* If it could work, try it. */
		        if (c == (UV)c1 || c == (UV)c2)
		        {
			    TRYPAREN(paren, ln, PL_reginput);
			    REGCP_UNWIND(lastcp);
		        }
		    }
		    /* If it could work, try it. */
		    else if (c1 == -1000)
		    {
			TRYPAREN(paren, ln, PL_reginput);
			REGCP_UNWIND(lastcp);
		    }
		    /* Couldn't or didn't -- move forward. */
		    PL_reginput = locinput;
		    if (regrepeat(scan, 1)) {
			ln++;
			locinput = PL_reginput;
		    }
		    else
			sayNO;
d4638 2
d4642 1
a4642 2
		CHECKPOINT lastcp;
		n = regrepeat(scan, n);
d4644 4
a4647 3
		if (ln < n && PL_regkind[(U8)OP(next)] == EOL &&
		    ((!PL_multiline && OP(next) != MEOL) ||
			OP(next) == SEOL || OP(next) == EOS))
d4649 4
a4652 2
		    ln = n;			/* why back off? */
		    /* ...because $ and \Z can match before *and* after
d4654 52
a4705 15
		       We should back off by one in this case. */
		    if (UCHARAT(PL_reginput - 1) == '\n' && OP(next) != EOS)
			ln--;
		}
		REGCP_SET(lastcp);
		if (paren) {
		    UV c = 0;
		    while (n >= ln) {
			if (c1 != -1000) {
			    if (do_utf8)
				c = utf8n_to_uvchr((U8*)PL_reginput,
						   UTF8_MAXBYTES, 0,
						   uniflags);
			    else
				c = UCHARAT(PL_reginput);
a4706 9
			/* If it could work, try it. */
			if (c1 == -1000 || c == (UV)c1 || c == (UV)c2)
			    {
				TRYPAREN(paren, n, PL_reginput);
				REGCP_UNWIND(lastcp);
			    }
			/* Couldn't or didn't -- back up. */
			n--;
			PL_reginput = locinput = HOPc(locinput, -1);
d4710 10
a4719 19
		    UV c = 0;
		    while (n >= ln) {
			if (c1 != -1000) {
			    if (do_utf8)
				c = utf8n_to_uvchr((U8*)PL_reginput,
						   UTF8_MAXBYTES, 0,
						   uniflags);
			    else
				c = UCHARAT(PL_reginput);
			}
			/* If it could work, try it. */
			if (c1 == -1000 || c == (UV)c1 || c == (UV)c2)
			    {
				TRYPAREN(paren, n, PL_reginput);
				REGCP_UNWIND(lastcp);
			    }
			/* Couldn't or didn't -- back up. */
			n--;
			PL_reginput = locinput = HOPc(locinput, -1);
d4721 42
d4766 37
a4802 1
	    break;
d4804 31
a4834 26
	    if (PL_reg_call_cc) {
		re_cc_state *cur_call_cc = PL_reg_call_cc;
		CURCUR *cctmp = PL_regcc;
		regexp *re = PL_reg_re;
		CHECKPOINT cp, lastcp;
		
		cp = regcppush(0);	/* Save *all* the positions. */
		REGCP_SET(lastcp);
		regcp_set_to(PL_reg_call_cc->ss); /* Restore parens of
						    the caller. */
		PL_reginput = locinput;	/* Make position available to
					   the callcc. */
		cache_re(PL_reg_call_cc->re);
		PL_regcc = PL_reg_call_cc->cc;
		PL_reg_call_cc = PL_reg_call_cc->prev;
		if (regmatch(cur_call_cc->node)) {
		    PL_reg_call_cc = cur_call_cc;
		    regcpblow(cp);
		    sayYES;
		}
		REGCP_UNWIND(lastcp);
		regcppop();
		PL_reg_call_cc = cur_call_cc;
		PL_regcc = cctmp;
		PL_reg_re = re;
		cache_re(re);
d4836 2
a4837 6
		DEBUG_r(
		    PerlIO_printf(Perl_debug_log,
				  "%*s  continuation failed...\n",
				  REPORT_CODE_OFF+PL_regindent*2, "")
		    );
		sayNO_SILENT;
d4839 3
a4841 2
	    if (locinput < PL_regtill) {
		DEBUG_r(PerlIO_printf(Perl_debug_log,
d4845 1
a4845 1
				      (long)(PL_regtill - PL_reg_starttry),
d4847 2
a4848 1
		sayNO_FINAL;		/* Cannot match: too short. */
d4851 7
a4857 2
	    sayYES_FINAL;		/* Success! */
	case SUCCEED:
d4859 7
a4865 3
	    sayYES_LOUD;		/* Success! */
	case SUSPEND:
	    n = 1;
d4868 8
a4875 2
	case UNLESSM:
	    n = 0;
d4877 14
a4890 14
		s = HOPBACKc(locinput, scan->flags);
		if (!s)
		    goto say_yes;
		PL_reginput = s;
	    }
	    else
		PL_reginput = locinput;
	    goto do_ifmatch;
	case IFMATCH:
	    n = 1;
	    if (scan->flags) {
		s = HOPBACKc(locinput, scan->flags);
		if (!s)
		    goto say_no;
d4897 13
a4909 10
	    inner = NEXTOPER(NEXTOPER(scan));
	    if (regmatch(inner) != n) {
	      say_no:
		if (logical) {
		    logical = 0;
		    sw = 0;
		    goto do_longjump;
		}
		else
		    sayNO;
d4911 4
a4914 6
	  say_yes:
	    if (logical) {
		logical = 0;
		sw = 1;
	    }
	    if (OP(scan) == SUSPEND) {
d4916 2
d4920 7
a4926 1
	    /* FALL THROUGH. */
a4927 1
	  do_longjump:
d4932 144
d5080 51
a5131 2
      reenter:
	scan = next;
a5141 10
yes_loud:
    DEBUG_r(
	PerlIO_printf(Perl_debug_log,
		      "%*s  %scould match...%s\n",
		      REPORT_CODE_OFF+PL_regindent*2, "", PL_colors[4],PL_colors[5])
	);
    goto yes;
yes_final:
    DEBUG_r(PerlIO_printf(Perl_debug_log, "%sMatch successful!%s\n",
			  PL_colors[4],PL_colors[5]));
d5143 4
d5148 25
a5172 1
    PL_regindent--;
d5174 11
d5186 14
a5199 5
#if 0					/* Breaks $^R */
    if (unwind)
	regcpblow(firstcp);
#endif
    return 1;
d5202 1
a5202 1
    DEBUG_r(
d5204 3
a5206 2
		      "%*s  %sfailed...%s\n",
		      REPORT_CODE_OFF+PL_regindent*2, "",PL_colors[4],PL_colors[5])
a5207 42
    goto do_no;
no_final:
do_no:
    if (unwind) {
	re_unwind_t *uw = SSPTRt(unwind,re_unwind_t);

	switch (uw->type) {
	case RE_UNWIND_BRANCH:
	case RE_UNWIND_BRANCHJ:
	{
	    re_unwind_branch_t *uwb = &(uw->branch);
	    const I32 lastparen = uwb->lastparen;
	
	    REGCP_UNWIND(uwb->lastcp);
	    for (n = *PL_reglastparen; n > lastparen; n--)
		PL_regendp[n] = -1;
	    *PL_reglastparen = n;
	    scan = next = uwb->next;
	    if ( !scan ||
		 OP(scan) != (uwb->type == RE_UNWIND_BRANCH
			      ? BRANCH : BRANCHJ) ) {		/* Failure */
		unwind = uwb->prev;
#ifdef DEBUGGING
		PL_regindent--;
#endif
		goto do_no;
	    }
	    /* Have more choice yet.  Reuse the same uwb.  */
	    if ((n = (uwb->type == RE_UNWIND_BRANCH
		      ? NEXT_OFF(next) : ARG(next))))
		next += n;
	    else
		next = NULL;	/* XXXX Needn't unwinding in this case... */
	    uwb->next = next;
	    next = NEXTOPER(scan);
	    if (uwb->type == RE_UNWIND_BRANCHJ)
		next = NEXTOPER(next);
	    locinput = uwb->locinput;
	    nextchr = uwb->nextchr;
#ifdef DEBUGGING
	    PL_regindent = uwb->regindent;
#endif
d5209 44
a5252 7
	    goto reenter;
	}
	/* NOT REACHED */
	default:
	    Perl_croak(aTHX_ "regexp unwind memory corruption");
	}
	/* NOT REACHED */
d5254 5
a5258 4
#ifdef DEBUGGING
    PL_regindent--;
#endif
    return 0;
d5270 1
a5270 1
S_regrepeat(pTHX_ const regnode *p, I32 max)
d5272 1
d5278 3
d5286 1
a5286 1
      loceol = scan + max;
d5336 1
a5336 1
		   reginclass(p, (U8*)scan, 0, do_utf8)) {
d5341 1
a5341 1
	    while (scan < loceol && REGINCLASS(p, (U8*)scan))
a5442 1
	    break;
d5444 1
d5486 69
d5556 1
d5567 8
a5574 8
    DEBUG_r(
	{
		SV *prop = sv_newmortal();

		regprop(prop, (regnode *)p);
		PerlIO_printf(Perl_debug_log,
			      "%*s  %s can match %"IVdf" times out of %"IVdf"...\n",
			      REPORT_CODE_OFF+1, "", SvPVX_const(prop),(IV)c,(IV)max);
d5576 1
a5580 51
/*
 - regrepeat_hard - repeatedly match something, report total lenth and length
 *
 * The repeater is supposed to have constant non-zero length.
 */

STATIC I32
S_regrepeat_hard(pTHX_ regnode *p, I32 max, I32 *lp)
{
    register char *scan = Nullch;
    register char *start;
    register char *loceol = PL_regeol;
    I32 l = 0;
    I32 count = 0, res = 1;

    if (!max)
	return 0;

    start = PL_reginput;
    if (PL_reg_match_utf8) {
	while (PL_reginput < loceol && (scan = PL_reginput, res = regmatch(p))) {
	    if (!count++) {
		l = 0;
		while (start < PL_reginput) {
		    l++;
		    start += UTF8SKIP(start);
		}
		*lp = l;
		if (l == 0)
		    return max;
	    }
	    if (count == max)
		return count;
	}
    }
    else {
	while (PL_reginput < loceol && (scan = PL_reginput, res = regmatch(p))) {
	    if (!count++) {
		*lp = l = PL_reginput - start;
		if (max != REG_INFTY && l*max < loceol - scan)
		    loceol = scan + l*max;
		if (l == 0)
		    return max;
	    }
	}
    }
    if (!res)
	PL_reginput = scan;

    return count;
}
d5582 1
d5588 1
a5588 1
Perl_regclass_swash(pTHX_ register regnode* node, bool doinit, SV** listsvp, SV **altsvp)
d5590 1
d5594 2
d5597 1
a5597 1
    if (PL_regdata && PL_regdata->count) {
d5600 2
a5601 2
	if (PL_regdata->what[n] == 's') {
	    SV * const rv = (SV*)PL_regdata->data[n];
d5606 1
a5606 1
	    /* See the end of regcomp.c:S_reglass() for
d5610 2
a5611 2
	    a  = SvROK(ary[1]) ? &ary[1] : 0;
	    b  = SvTYPE(ary[2]) == SVt_PVAV ? &ary[2] : 0;
d5631 1
d5644 1
a5644 1
S_reginclass(pTHX_ register const regnode *n, register const U8* p, STRLEN* lenp, register bool do_utf8)
d5646 1
d5654 4
a5657 4
	c = utf8n_to_uvchr((U8 *)p, UTF8_MAXBYTES, &len,
			    ckWARN(WARN_UTF8) ? UTF8_CHECK_ONLY :
					UTF8_ALLOW_ANYUV|UTF8_CHECK_ONLY);
	if (len == (STRLEN)-1)
d5673 1
a5673 1
	    SV * const sw = regclass_swash((regnode *)n, TRUE, 0, (SV**)&av);
d5676 1
a5676 1
		if (swash_fetch(sw, (U8 *)p, do_utf8))
d5697 1
a5697 1
		        to_utf8_fold((U8 *)p, tmpbuf, &tmplen);
d5767 1
a5767 7
S_reghop(pTHX_ U8 *s, I32 off)
{
    return S_reghop3(aTHX_ s, off, (U8*)(off >= 0 ? PL_regeol : PL_bostr));
}

STATIC U8 *
S_reghop3(pTHX_ U8 *s, I32 off, U8* lim)
d5769 1
d5777 5
a5781 8
	while (off++) {
	    if (s > lim) {
		s--;
		if (UTF8_IS_CONTINUED(*s)) {
		    while (s > (U8*)lim && UTF8_IS_CONTINUATION(*s))
			s--;
		}
		/* XXX could check well-formedness here */
d5783 1
d5789 5
d5795 1
a5795 1
S_reghopmaybe(pTHX_ U8 *s, I32 off)
d5797 18
a5814 1
    return S_reghopmaybe3(aTHX_ s, off, (U8*)(off >= 0 ? PL_regeol : PL_bostr));
d5816 1
d5819 1
a5819 1
S_reghopmaybe3(pTHX_ U8* s, I32 off, U8* lim)
d5821 1
d5828 1
a5828 1
	    return 0;
d5831 5
a5835 8
	while (off++) {
	    if (s > lim) {
		s--;
		if (UTF8_IS_CONTINUED(*s)) {
		    while (s > (U8*)lim && UTF8_IS_CONTINUATION(*s))
			s--;
		}
		/* XXX could check well-formedness here */
d5837 1
a5837 2
	    else
		break;
d5840 1
a5840 1
	    return 0;
d5848 2
a5849 1
    PERL_UNUSED_ARG(arg);
d5852 6
a5857 3
	    PL_reg_re->subbeg = PL_reg_oldsaved;
	    PL_reg_re->sublen = PL_reg_oldsavedlen;
	    RX_MATCH_COPIED_on(PL_reg_re);
d5868 23
a5890 18
    if (prog->float_substr && !prog->float_utf8) {
	SV* sv;
	prog->float_utf8 = sv = newSVsv(prog->float_substr);
	sv_utf8_upgrade(sv);
	if (SvTAIL(prog->float_substr))
	    SvTAIL_on(sv);
	if (prog->float_substr == prog->check_substr)
	    prog->check_utf8 = sv;
    }
    if (prog->anchored_substr && !prog->anchored_utf8) {
	SV* sv;
	prog->anchored_utf8 = sv = newSVsv(prog->anchored_substr);
	sv_utf8_upgrade(sv);
	if (SvTAIL(prog->anchored_substr))
	    SvTAIL_on(sv);
	if (prog->anchored_substr == prog->check_substr)
	    prog->check_utf8 = sv;
    }
d5896 24
a5919 9
    if (prog->float_utf8 && !prog->float_substr) {
	SV* sv;
	prog->float_substr = sv = newSVsv(prog->float_utf8);
	if (sv_utf8_downgrade(sv, TRUE)) {
	    if (SvTAIL(prog->float_utf8))
		SvTAIL_on(sv);
	} else {
	    SvREFCNT_dec(sv);
	    prog->float_substr = sv = &PL_sv_undef;
d5921 1
a5921 16
	if (prog->float_utf8 == prog->check_utf8)
	    prog->check_substr = sv;
    }
    if (prog->anchored_utf8 && !prog->anchored_substr) {
	SV* sv;
	prog->anchored_substr = sv = newSVsv(prog->anchored_utf8);
	if (sv_utf8_downgrade(sv, TRUE)) {
	    if (SvTAIL(prog->anchored_utf8))
		SvTAIL_on(sv);
	} else {
	    SvREFCNT_dec(sv);
	    prog->anchored_substr = sv = &PL_sv_undef;
	}
	if (prog->anchored_utf8 == prog->check_utf8)
	    prog->check_substr = sv;
    }
@


1.9
log
@sync in-tree perl with 5.8.6
@
text
@a57 1
/*SUPPRESS 112*/
d81 1
a81 1
 ****    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
a99 1
#define RF_false	16		/* odd number of nested negatives */
d142 6
a147 1
#define LOAD_UTF8_CHARCLASS(a,b) STMT_START { if (!CAT2(PL_utf8_,a)) { ENTER; save_re_context(); (void)CAT2(is_utf8_, a)((U8*)b); LEAVE; } } STMT_END
d181 1
a181 1
    int retval = PL_savestack_ix;
d183 1
a183 1
    int paren_elems_to_push = (PL_regsize - parenfloor) * REGCP_PAREN_ELEMS;
a227 1
    I32 tmps;
d241 1
d287 1
a287 1
    I32 tmp = PL_savestack_ix;
d370 1
a370 1
/* If SCREAM, then SvPVX(sv) should be compatible with strpos and strend.
d411 1
a411 1
    int do_utf8 = sv ? SvUTF8(sv) : 0;	/* if no sv we have to assume bytes */
d416 2
a417 2
    char *i_strpos = strpos;
    SV *dsv = PERL_DEBUG_PAD_ZERO(0);
d428 1
a428 1
	 char *s   = PL_reg_match_utf8 ?
d431 1
a431 1
	 int   len = PL_reg_match_utf8 ?
d439 1
a439 1
		       "%sGuessing start of match, REx%s `%s%.60s%s%s' against `%s%.*s%s%s'...\n",
d481 1
a481 1
	       /* SvCUR is not set on references: SvRV and SvPVX overlap */
d503 1
a503 1
		if (slen && (*SvPVX(check) != *s
d505 1
a505 1
				 && memNE(SvPVX(check), s, slen)))) {
d511 1
a511 1
	    else if (*SvPVX(check) != *s
d513 1
a513 1
			 && memNE(SvPVX(check), s, slen)))
d515 1
d525 1
a525 1
	    I32 end = prog->check_offset_max + CHR_SVLEN(check)
d527 1
a527 1
	    I32 eshift = CHR_DIST((U8*)strend, (U8*)s) - end;
d552 1
a552 1
	I32 *pp = data ? data->scream_pos : &p;
d564 1
a564 1
	    s = strbeg + (s - SvPVX(sv));
d580 2
a581 1
    DEBUG_r(PerlIO_printf(Perl_debug_log, "%s %s substr `%s%.*s%s'%s%s",
d586 1
a586 1
			  SvPVX(check),
d601 1
a601 1
       XXXX /ttx+/ results in anchored=`ttx', floating=`x'.  floating will
d614 2
a615 1
		char *last = HOP3c(s, -start_shift, strbeg), *last1, *last2;
d649 1
a649 1
			"%s anchored substr `%s%.*s%s'%s",
d654 1
a654 1
			  SvPVX(must),
d708 2
a709 1
	    DEBUG_r(PerlIO_printf(Perl_debug_log, "%s floating substr `%s%.*s%s'%s",
d713 1
a713 1
		      SvPVX(must),
d862 4
a865 3
	U8* str = (U8*)STRING(prog->regstclass);
	int cl_l = (PL_regkind[(U8)OP(prog->regstclass)] == EXACT
		    ? CHR_DIST(str+STR_LEN(prog->regstclass), str)
d867 1
a867 1
	char *endpos = (prog->anchored_substr || prog->anchored_utf8 || ml_anch)
a872 1
	char *startpos = strbeg;
d876 1
a876 1
	s = find_byclass(prog, prog->regstclass, s, endpos, startpos, 1);
d879 1
a879 1
	    char *what = 0;
d969 1
a969 1
S_find_byclass(pTHX_ regexp * prog, regnode *c, char *s, char *strend, char *startpos, I32 norun)
d971 1
a971 1
	I32 doevery = (prog->reganch & ROPT_SKIP) == 0;
d980 1
a980 1
	register bool do_utf8 = PL_reg_match_utf8;
d1037 3
a1039 2
		U8 tmpbuf1[UTF8_MAXLEN_UCLC+1];
		U8 tmpbuf2[UTF8_MAXLEN_UCLC+1];
d1044 4
a1047 4
		c1 = utf8n_to_uvchr(tmpbuf1, UTF8_MAXLEN_UCLC, 
				    0, ckWARN(WARN_UTF8) ? 0 : UTF8_ALLOW_ANY);
		c2 = utf8n_to_uvchr(tmpbuf2, UTF8_MAXLEN_UCLC,
				    0, ckWARN(WARN_UTF8) ? 0 : UTF8_ALLOW_ANY);
d1084 1
a1084 2
	        U8 tmpbuf [UTF8_MAXLEN+1];
		U8 foldbuf[UTF8_MAXLEN_FOLD+1];
d1086 1
a1086 1
		
d1091 2
a1092 3
		        c = utf8n_to_uvchr((U8*)s, UTF8_MAXLEN, &len,
					   ckWARN(WARN_UTF8) ?
					   0 : UTF8_ALLOW_ANY);
d1100 1
d1118 2
a1119 3
		      c = utf8n_to_uvchr((U8*)s, UTF8_MAXLEN, &len,
					   ckWARN(WARN_UTF8) ?
					   0 : UTF8_ALLOW_ANY);
d1139 1
d1193 1
a1193 1
		LOAD_UTF8_CHARCLASS(alnum,"a");
d1236 1
a1236 1
		LOAD_UTF8_CHARCLASS(alnum,"a");
d1265 1
a1265 1
		LOAD_UTF8_CHARCLASS(alnum,"a");
d1323 1
a1323 1
		LOAD_UTF8_CHARCLASS(alnum,"a");
d1381 1
a1381 1
		LOAD_UTF8_CHARCLASS(space," ");
d1439 1
a1439 1
		LOAD_UTF8_CHARCLASS(space," ");
d1497 1
a1497 1
		LOAD_UTF8_CHARCLASS(digit,"0");
d1555 1
a1555 1
		LOAD_UTF8_CHARCLASS(digit,"0");
a1636 2
    /* I32 start_shift = 0; */		/* Offset of the start to find
					 constant substr. */		/* CC */
d1641 1
a1641 1
    bool do_utf8 = DO_UTF8(sv);
d1646 1
d1731 6
a1736 6
	 char *s0   = UTF ?
	   pv_uni_display(dsv0, (U8*)prog->precomp, prog->prelen, 60,
			  UNI_DISPLAY_REGEX) :
	   prog->precomp;
	 int   len0 = UTF ? SvCUR(dsv0) : prog->prelen;
	 char *s1   = do_utf8 ? sv_uni_display(dsv1, sv, 60,
d1738 1
a1738 1
	 int   len1 = do_utf8 ? SvCUR(dsv1) : strend - startpos;
d1742 1
a1742 1
		       "%sMatching REx%s `%s%*.*s%s%s' against `%s%.*s%s%s'\n",
d1813 1
a1813 1
	ch = SvPVX(do_utf8 ? prog->anchored_utf8 : prog->anchored_substr)[0];
a1843 1
    /*SUPPRESS 560*/
d1881 1
a1881 1
	/* XXXX check_substr already used to find `s', can optimize if
d1895 1
a1895 1
		s = strbeg + (s - SvPVX(sv));
d1924 1
a1924 1
                                  "Did not find %s substr `%s%.*s%s'%s...\n",
d1929 1
a1929 1
			      SvPVX(must),
d1943 2
a1944 2
	    char *s0;
	    char *s1;
d1950 1
a1950 1
	      pv_uni_display(dsv0, (U8*)SvPVX(prop), SvCUR(prop), 60,
d1952 1
a1952 1
	      SvPVX(prop);
d1958 1
a1958 1
			  "Matching stclass `%*.*s' against `%*.*s'\n",
d1962 1
a1962 1
  	if (find_byclass(prog, c, s, strend, startpos, 0))
d1984 1
a1984 1
		    s = strbeg + (s - SvPVX(sv));
d1988 1
a1988 1
		char *little = SvPV(float_real, len);
d2003 1
a2003 1
			last = strend;	/* matching `$' */
d2131 1
a2131 1
	    Newz(22,PL_reg_curpm, 1, PMOP);
d2174 1
a2174 1
            New(22,PL_reg_start_tmp, PL_reg_start_tmpl, char*);
d2249 36
d2319 1
a2319 1
    register bool do_utf8 = PL_reg_match_utf8;
d2325 1
d2338 2
a2339 2
	    int docolor = *PL_colors[0];
	    int taill = (docolor ? 10 : 7); /* 3 chars for "> <" */
d2365 1
a2365 1
	      char *s0 =
d2370 2
a2371 2
	      int len0 = do_utf8 ? strlen(s0) : pref0_len;
	      char *s1 = do_utf8 && OP(scan) != CANY ?
d2375 2
a2376 2
	      int len1 = do_utf8 ? strlen(s1) : pref_len - pref0_len;
	      char *s2 = do_utf8 && OP(scan) != CANY ?
d2380 1
a2380 1
	      int len2 = do_utf8 ? strlen(s2) : l;
d2397 1
a2397 1
			    SvPVX(prop));
d2485 1
a2485 2
		char *e = s + ln;
		STRLEN ulen;
d2490 1
d2494 2
a2495 3
			    utf8n_to_uvuni((U8*)l, UTF8_MAXLEN, &ulen,
					   ckWARN(WARN_UTF8) ?
					   0 : UTF8_ALLOW_ANY))
d2504 1
d2508 2
a2509 3
			    utf8n_to_uvuni((U8*)s, UTF8_MAXLEN, &ulen,
					   ckWARN(WARN_UTF8) ?
					   0 : UTF8_ALLOW_ANY))
d2618 1
a2618 1
		LOAD_UTF8_CHARCLASS(alnum,"a");
d2641 1
a2641 1
		LOAD_UTF8_CHARCLASS(alnum,"a");
d2668 1
a2668 1
		    U8 *r = reghop3((U8*)locinput, -1, (U8*)PL_bostr);
d2670 1
a2670 1
		    ln = utf8n_to_uvchr(r, UTF8SKIP(r), 0, 0);
d2674 1
a2674 1
		    LOAD_UTF8_CHARCLASS(alnum,"a");
d2706 1
a2706 1
		    LOAD_UTF8_CHARCLASS(space," ");
d2736 1
a2736 1
		LOAD_UTF8_CHARCLASS(space," ");
d2759 1
a2759 1
		LOAD_UTF8_CHARCLASS(digit,"0");
d2782 1
a2782 1
		LOAD_UTF8_CHARCLASS(digit,"0");
d2802 1
a2802 1
		LOAD_UTF8_CHARCLASS(mark,"~");
d2832 1
a2832 1
		char *e = PL_bostr + PL_regendp[n];
a2838 3
		    STRLEN ulen1, ulen2;
		    U8 tmpbuf1[UTF8_MAXLEN_UCLC+1];
		    U8 tmpbuf2[UTF8_MAXLEN_UCLC+1];
d2840 4
d2937 1
a2937 1
			char *t = SvPV(ret, len);
d2939 3
a2941 3
			char *oprecomp = PL_regprecomp;
			I32 osize = PL_regsize;
			I32 onpar = PL_regnpar;
d2945 1
a2945 1
			re = CALLREGCOMP(aTHX_ t, t + len, &pm);
d2957 1
a2957 1
				      "Entering embedded `%s%.60s%s%s'\n",
d3177 1
d3230 1
a3230 1
		    I32 size = (PL_reg_maxiter + 7)/8;
d3240 1
a3240 1
			Newz(29, PL_reg_poscache, size, char);
d3249 1
a3249 1
		    I32 o = locinput - PL_bostr, b;
d3251 5
a3255 4
		    o = (scan->flags & 0xf) - 1 + o * (scan->flags>>4);
		    b = o % 8;
		    o /= 8;
		    if (PL_reg_poscache[o] & (1<<b)) {
d3261 2
a3262 1
			if (PL_reg_flags & RF_false)
d3265 1
d3268 1
a3268 1
		    PL_reg_poscache[o] |= (1<<b);
d3282 1
a3282 1
			sayYES;	/* All done. */
d3298 1
a3298 1
			sayNO;
d3314 1
a3314 1
			sayYES;
d3320 1
a3320 1
		    sayNO;
d3332 1
a3332 1
			sayYES;
d3356 1
a3356 1
		    sayYES;
d3362 1
a3362 1
		sayNO;
d3379 1
a3379 1
		    I32 lastparen = *PL_reglastparen;
d3619 2
a3620 2
			     U8 tmpbuf1[UTF8_MAXLEN_UCLC+1];
			     U8 tmpbuf2[UTF8_MAXLEN_UCLC+1];
d3625 4
a3628 6
			     c1 = utf8n_to_uvuni(tmpbuf1, UTF8_MAXLEN, 0,
						 ckWARN(WARN_UTF8) ?
						 0 : UTF8_ALLOW_ANY);
			     c2 = utf8n_to_uvuni(tmpbuf2, UTF8_MAXLEN, 0,
						 ckWARN(WARN_UTF8) ?
						 0 : UTF8_ALLOW_ANY);
d3631 2
a3632 3
			    c2 = c1 = utf8n_to_uvchr(s, UTF8_MAXLEN, 0,
						     ckWARN(WARN_UTF8) ?
						     0 : UTF8_ALLOW_ANY);
a3685 1
			    STRLEN len;
d3687 1
d3692 2
a3693 3
						      UTF8_MAXLEN, &len,
						      ckWARN(WARN_UTF8) ?
						      0 : UTF8_ALLOW_ANY) != (UV)c1) {
d3698 1
d3703 2
a3704 3
							  UTF8_MAXLEN, &len,
							  ckWARN(WARN_UTF8) ?
							  0 : UTF8_ALLOW_ANY);
d3739 2
a3740 3
					       UTF8_MAXLEN, 0,
					       ckWARN(WARN_UTF8) ?
					       0 : UTF8_ALLOW_ANY);
d3788 2
a3789 3
						   UTF8_MAXLEN, 0,
						   ckWARN(WARN_UTF8) ?
						   0 : UTF8_ALLOW_ANY);
d3810 2
a3811 3
						   UTF8_MAXLEN, 0,
						   ckWARN(WARN_UTF8) ?
						   0 : UTF8_ALLOW_ANY);
a3891 1
	    PL_reg_flags ^= RF_false;
a3906 2
		if (n == 0)
		    PL_reg_flags ^= RF_false;
a3915 2
	    if (n == 0)
		PL_reg_flags ^= RF_false;
d3987 1
a3987 1
	    I32 lastparen = uwb->lastparen;
a4003 1
	    /*SUPPRESS 560*/
d4042 1
a4042 1
S_regrepeat(pTHX_ regnode *p, I32 max)
d4116 1
a4116 1
	    LOAD_UTF8_CHARCLASS(alnum,"a");
d4144 1
a4144 1
	    LOAD_UTF8_CHARCLASS(alnum,"a");
d4172 1
a4172 1
	    LOAD_UTF8_CHARCLASS(space," ");
d4201 1
a4201 1
	    LOAD_UTF8_CHARCLASS(space," ");
d4230 1
a4230 1
	    LOAD_UTF8_CHARCLASS(digit,"0");
d4244 1
a4244 1
	    LOAD_UTF8_CHARCLASS(digit,"0");
d4269 1
a4269 1
		regprop(prop, p);
d4272 1
a4272 1
			      REPORT_CODE_OFF+1, "", SvPVX(prop),(IV)c,(IV)max);
d4342 1
a4342 1
	U32 n = ARG(node);
d4345 3
a4347 3
	    SV *rv = (SV*)PL_regdata->data[n];
	    AV *av = (AV*)SvRV((SV*)rv);
	    SV **ary = AvARRAY(av);
d4354 1
a4354 1
	    a  = SvTYPE(ary[1]) == SVt_RV   ? &ary[1] : 0;
d4387 1
a4387 1
S_reginclass(pTHX_ register regnode *n, register U8* p, STRLEN* lenp, register bool do_utf8)
d4389 1
a4389 1
    char flags = ANYOF_FLAGS(n);
d4395 7
a4401 3
    if (do_utf8 && !UTF8_IS_INVARIANT(c))
	 c = utf8n_to_uvchr(p, UTF8_MAXLEN, &len,
			    ckWARN(WARN_UTF8) ? 0 : UTF8_ALLOW_ANY);
d4415 1
a4415 1
	    SV *sw = regclass_swash(n, TRUE, 0, (SV**)&av);
d4418 1
a4418 1
		if (swash_fetch(sw, p, do_utf8))
a4422 1
		      
d4424 1
a4424 1
			    SV* sv = *av_fetch(av, i, FALSE);
d4426 1
a4426 1
			    char *s = SvPV(sv, len);
d4436 1
a4436 1
		        U8 tmpbuf[UTF8_MAXLEN_FOLD+1];
d4439 1
a4439 1
		        to_utf8_fold(p, tmpbuf, &tmplen);
d4577 1
a4592 1
    SV* sv;
d4594 2
a4595 2
	prog->float_utf8 = sv = NEWSV(117, 0);
	SvSetSV(sv, prog->float_substr);
d4603 2
a4604 2
	prog->anchored_utf8 = sv = NEWSV(118, 0);
	SvSetSV(sv, prog->anchored_substr);
a4615 1
    SV* sv;
d4617 2
a4618 2
	prog->float_substr = sv = NEWSV(117, 0);
	SvSetSV(sv, prog->float_utf8);
d4630 2
a4631 2
	prog->anchored_substr = sv = NEWSV(118, 0);
	SvSetSV(sv, prog->anchored_utf8);
d4643 10
@


1.8
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d8 11
d968 1
d979 1
a979 1
		 while (s < strend) {
d991 1
a991 1
		      s += UTF8SKIP(s);
d1187 1
a1187 1
		while (s < strend) {
d1196 1
a1196 1
		    s += UTF8SKIP(s);
d1230 1
a1230 1
		while (s < strend) {
d1237 1
a1237 1
		    s += UTF8SKIP(s);
d1259 1
a1259 1
		while (s < strend) {
d1268 1
a1268 1
		    s += UTF8SKIP(s);
d1288 1
a1288 1
		while (s < strend) {
d1297 1
a1297 1
		    s += UTF8SKIP(s);
d1317 1
a1317 1
		while (s < strend) {
d1326 1
a1326 1
		    s += UTF8SKIP(s);
d1346 1
a1346 1
		while (s < strend) {
d1355 1
a1355 1
		    s += UTF8SKIP(s);
d1375 1
a1375 1
		while (s < strend) {
d1384 1
a1384 1
		    s += UTF8SKIP(s);
d1404 1
a1404 1
		while (s < strend) {
d1413 1
a1413 1
		    s += UTF8SKIP(s);
d1433 1
a1433 1
		while (s < strend) {
d1442 1
a1442 1
		    s += UTF8SKIP(s);
d1462 1
a1462 1
		while (s < strend) {
d1471 1
a1471 1
		    s += UTF8SKIP(s);
d1491 1
a1491 1
		while (s < strend) {
d1500 1
a1500 1
		    s += UTF8SKIP(s);
d1520 1
a1520 1
		while (s < strend) {
d1529 1
a1529 1
		    s += UTF8SKIP(s);
d1549 1
a1549 1
		while (s < strend) {
d1558 1
a1558 1
		    s += UTF8SKIP(s);
d1578 1
a1578 1
		while (s < strend) {
d1587 1
a1587 1
		    s += UTF8SKIP(s);
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d71 1
a71 1
 ****    2000, 2001, 2002, 2003, by Larry Wall and others
d3357 1
a3357 1
	       backtracking: in particular, it is of constant length,
a3375 9
		/* if we matched something zero-length we don't need to
		   backtrack - capturing parens are already defined, so
		   the caveat in the maximal case doesn't apply

		   XXXX if ln == 0, we can redo this check first time
		   through the following loop
		*/
		if (ln && l == 0)
		    n = ln;	/* don't backtrack */
d3401 1
a3401 2
		/* This may be improved if l == 0.  */
		while (n >= ln || (n == REG_INFTY && ln > 0 && l)) { /* ln overflow ? */
a3431 7
		/* if we matched something zero-length we don't need to
		   backtrack, unless the minimum count is zero and we
		   are capturing the result - in that case the capture
		   being defined or not may affect later execution
		*/
		if (n != 0 && l == 0 && !(paren && ln == 0))
		    ln = n;	/* don't backtrack */
d4236 1
a4236 1
 * The repeater is supposed to have constant length.
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d70 2
a71 1
 ****    Copyright (c) 1991-2002, Larry Wall
d90 1
d176 1
a176 1
    SSCHECK(paren_elems_to_push + REGCP_OTHER_ELEMS);
d405 1
d547 3
d604 1
a604 1
		    && (!(prog->reganch & ROPT_UTF8)
d724 1
a724 1
        && (!(prog->reganch & ROPT_UTF8)
d857 1
a857 4
	if (prog->reganch & ROPT_UTF8) {	
	    PL_regdata = prog->data;
	    PL_bostr = startpos;
	}
d956 1
d966 34
a999 19
	    while (s < strend) {
		STRLEN skip = do_utf8 ? UTF8SKIP(s) : 1;
		  
		if (do_utf8 ?
		    reginclass(c, (U8*)s, 0, do_utf8) :
		    REGINCLASS(c, (U8*)s) ||
		    (ANYOF_FOLD_SHARP_S(c, s, strend) &&
		     /* The assignment of 2 is intentional:
		      * for the sharp s, the skip is 2. */
		     (skip = SHARP_S_SKIP)
		     )) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
		    else
			tmp = doevery;
		}
		else 
		    tmp = 1;
		s += skip;
d1012 3
a1014 2
	    m = STRING(c);
	    ln = STR_LEN(c);
d1017 1
d1028 5
d1040 3
a1042 2
	    m = STRING(c);
	    ln = STR_LEN(c);
d1046 1
a1046 1
	    e = HOP3c(strend, -(I32)ln, s);
d1069 2
d1629 1
d1876 3
d1918 2
a1919 1
	if (minlen && PL_regkind[(U8)OP(prog->regstclass)] != EXACT)
d1921 3
a1923 1
	    strend = HOPc(strend, -(minlen - 1));
d1965 3
d2149 1
d2312 1
a2312 1
		do_utf8 ?
d2317 1
a2317 1
	      char *s1 = do_utf8 ?
d2322 1
a2322 1
	      char *s2 = do_utf8 ?
d2834 1
a2834 1
	    SV **ocurpad = PL_curpad;
d2836 1
d2841 1
a2841 1
	    PL_curpad = AvARRAY((AV*)PL_regdata->data[n + 2]);
d2857 1
a2857 1
	    PL_curpad = ocurpad;
d2865 2
d2868 8
a2875 2
		    if(SvROK(ret) || SvRMAGICAL(ret)) {
			SV *sv = SvROK(ret) ? SvRV(ret) : ret;
a2876 3
			if(SvMAGICAL(sv))
			    mg = mg_find(sv, PERL_MAGIC_qr);
		    }
d2890 1
d2893 2
a2894 1
			      & (SVs_TEMP | SVs_PADTMP | SVf_READONLY)))
d2924 3
d2941 1
d2958 1
d2969 1
a2969 1
	    else
d2971 2
d3205 4
a3208 1
			sayNO_SILENT;
d3394 2
a3395 13
			    I32 n, ln;
			    n = ARG(text_node);  /* which paren pair */
			    ln = PL_regstartp[n];
			    /* assume yes if we haven't seen CLOSEn */
			    if (
				(I32)*PL_reglastparen < n ||
				ln == -1 ||
				ln == PL_regendp[n]
			    ) {
				c1 = c2 = -1000;
				goto assume_ok_MM;
			    }
			    c1 = *(PL_bostr + ln);
d3465 2
a3466 13
				I32 n, ln;
				n = ARG(text_node);  /* which paren pair */
				ln = PL_regstartp[n];
				/* assume yes if we haven't seen CLOSEn */
				if (
				    (I32)*PL_reglastparen < n ||
				    ln == -1 ||
				    ln == PL_regendp[n]
				) {
				    c1 = c2 = -1000;
				    goto assume_ok_REG;
				}
				c1 = *(PL_bostr + ln);
d3563 2
a3564 13
			I32 n, ln;
			n = ARG(text_node);  /* which paren pair */
			ln = PL_regstartp[n];
			/* assume yes if we haven't seen CLOSEn */
			if (
			    (I32)*PL_reglastparen < n ||
			    ln == -1 ||
			    ln == PL_regendp[n]
			) {
			    c1 = c2 = -1000;
			    goto assume_ok_easy;
			}
			s = (U8*)PL_bostr + ln;
d3710 1
a3710 1
			    TRYPAREN(paren, n, PL_reginput);
d3717 1
a3717 1
			TRYPAREN(paren, n, PL_reginput);
d3858 1
d3874 2
d3885 2
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d41 2
a42 1
#  define Perl_reginitcolors my_reginitcolors 
d45 1
a45 1
#endif 
d70 1
a70 1
 ****    Copyright (c) 1991-2001, Larry Wall
a82 6
#ifdef PERL_IN_XSUB_RE
#  if defined(PERL_CAPI) || defined(PERL_OBJECT)
#    include "XSUB.h"
#  endif
#endif

d90 1
a90 1
#define UTF (PL_reg_flags & RF_utf8)
d99 2
d105 2
a106 9
#define REGINCLASS(p,c)  (ANYOF_FLAGS(p) ? reginclass(p,c) : ANYOF_BITMAP_TEST(p,c))
#ifdef DEBUGGING
#   define REGINCLASSUTF8(f,p)  (ARG1(f) ? reginclassutf8(f,p) : swash_fetch(*av_fetch((AV*)SvRV((SV*)PL_regdata->data[ARG2(f)]),0,FALSE),p))
#else
#   define REGINCLASSUTF8(f,p)  (ARG1(f) ? reginclassutf8(f,p) : swash_fetch((SV*)PL_regdata->data[ARG2(f)],p))
#endif

#define CHR_SVLEN(sv) (UTF ? sv_len_utf8(sv) : SvCUR(sv))
#define CHR_DIST(a,b) (UTF ? utf8_distance(a,b) : a - b)
d110 2
a111 2
#define HOP(pos,off) (UTF ? reghop((U8*)pos, off) : (U8*)(pos + off))
#define HOPMAYBE(pos,off) (UTF ? reghopmaybe((U8*)pos, off) : (U8*)(pos + off))
d115 44
a158 1
static void restore_pos(pTHXo_ void *arg);
d160 1
d170 4
a173 1
#define REGCP_OTHER_ELEMS 5
d185 1
d219 1
d235 1
a235 1
			  (UV)paren, (IV)PL_regstartp[paren], 
d237 1
a237 1
			  (IV)PL_regendp[paren], 
d242 1
a242 1
	if (*PL_reglastparen + 1 <= PL_regnpar) {
d259 2
a260 2
    for (paren = *PL_reglastparen + 1; paren <= PL_regnpar; paren++) {
	if (paren > PL_regsize)
d322 1
a322 1
	regexec_flags(prog, stringarg, strend, strbeg, minend, screamer, NULL, 
d334 2
a335 2
    PL_regdata = prog->data;    
    PL_reg_re = prog;    
d338 1
a338 1
/* 
d388 1
a388 1
    register I32 start_shift;
d390 1
a390 1
    register I32 end_shift;
d395 1
a396 1
    char *tmp;
d398 1
a398 1
    char *check_at;			/* check substr found at this pos */
d401 1
d404 29
a432 12
    DEBUG_r( if (!PL_colorset) reginitcolors() );
    DEBUG_r(PerlIO_printf(Perl_debug_log,
		      "%sGuessing start of match, REx%s `%s%.60s%s%s' against `%s%.*s%s%s'...\n",
		      PL_colors[4],PL_colors[5],PL_colors[0],
		      prog->precomp,
		      PL_colors[1],
		      (strlen(prog->precomp) > 60 ? "..." : ""),
		      PL_colors[0],
		      (int)(strend - strpos > 60 ? 60 : strend - strpos),
		      strpos, PL_colors[1],
		      (strend - strpos > 60 ? "..." : ""))
	);
d434 1
d436 2
a437 1
	DEBUG_r(PerlIO_printf(Perl_debug_log, "String too short...\n"));
d441 15
a455 1
    check = prog->check_substr;
d462 2
a463 1
	  if ( !(prog->reganch & ROPT_ANCH_GPOS) /* Checked by the caller */
d470 2
a471 1
	  if (prog->check_offset_min == prog->check_offset_max) {
d475 1
a475 2
	    PL_regeol = strend;			/* Used in HOP() */
	    s = HOPc(strpos, prog->check_offset_min);
d479 1
a479 1
		if ( strend - s > slen || strend - s < slen - 1 
d509 1
a509 1
	    I32 eshift = strend - s - end;
a529 2
    other_last = Nullch;

d540 1
a540 1
	    s = screaminstr(sv, check, 
d547 4
d552 2
a553 2
	s = fbm_instr((unsigned char*)s + start_shift,
		      (unsigned char*)strend - end_shift,
d561 1
a561 1
			  ((check == prog->anchored_substr) ? "anchored" : "floating"),
d584 1
a584 1
    if (prog->float_substr && prog->anchored_substr) {
d589 1
a589 1
	if (check == prog->float_substr) {
d592 1
a592 1
		char *last = s - start_shift, *last1, *last2;
d594 1
a595 1
		tmp = PL_bostr;
d599 1
a599 2
			|| (PL_bostr = strpos, /* Used in regcopmaybe() */
			    (t = reghopmaybe_c(s, -(prog->check_offset_max)))
d604 1
a604 1
		t += prog->anchored_offset;
d607 1
a607 2
		PL_bostr = tmp;
		last2 = last1 = strend - prog->minlen;
d612 15
a626 6
		s = fbm_instr((unsigned char*)t,
			      (unsigned char*)last1 + prog->anchored_offset
				 + SvCUR(prog->anchored_substr)
				 - (SvTAIL(prog->anchored_substr)!=0),
			      prog->anchored_substr, PL_multiline ? FBMrf_MULTILINE : 0);
		DEBUG_r(PerlIO_printf(Perl_debug_log, "%s anchored substr `%s%.*s%s'%s",
d629 4
a632 4
			  (int)(SvCUR(prog->anchored_substr)
			  - (SvTAIL(prog->anchored_substr)!=0)),
			  SvPVX(prog->anchored_substr),
			  PL_colors[1], (SvTAIL(prog->anchored_substr) ? "$" : "")));
d641 3
a643 4
			(long)(s1 + 1 - i_strpos)));
		    PL_regeol = strend;			/* Used in HOP() */
		    other_last = last1 + prog->anchored_offset + 1;
		    s = HOPc(last, 1);
d649 2
a650 2
		    t = s - prog->anchored_offset;
		    other_last = s + 1;
d659 12
a670 10
		char *last, *last1;
		char *s1 = s;

		t = s - start_shift;
		last1 = last = strend - prog->minlen + prog->float_min_offset;
		if (last - t > prog->float_max_offset)
		    last = t + prog->float_max_offset;
		s = t + prog->float_min_offset;
		if (s < other_last)
		    s = other_last;
d672 9
a680 3
		/* fbm_instr() takes into account exact value of end-of-str
		   if the check is SvTAIL(ed).  Since false positives are OK,
		   and end-of-str is not later than strend we are OK. */
d682 11
a692 16
			      (unsigned char*)last + SvCUR(prog->float_substr)
				  - (SvTAIL(prog->float_substr)!=0),
			      prog->float_substr, PL_multiline ? FBMrf_MULTILINE : 0);
		DEBUG_r(PerlIO_printf(Perl_debug_log, "%s floating substr `%s%.*s%s'%s",
			(s ? "Found" : "Contradicts"),
			PL_colors[0],
			  (int)(SvCUR(prog->float_substr)
			  - (SvTAIL(prog->float_substr)!=0)),
			  SvPVX(prog->float_substr),
			  PL_colors[1], (SvTAIL(prog->float_substr) ? "$" : "")));
		if (!s) {
		    if (last1 == last) {
			DEBUG_r(PerlIO_printf(Perl_debug_log,
						", giving up...\n"));
			goto fail_finish;
		    }
d694 2
a695 15
			", trying anchored starting at offset %ld...\n",
			(long)(s1 + 1 - i_strpos)));
		    other_last = last;
		    PL_regeol = strend;			/* Used in HOP() */
		    s = HOPc(t, 1);
		    goto restart;
		}
		else {
		    DEBUG_r(PerlIO_printf(Perl_debug_log, " at offset %ld...\n",
			  (long)(s - i_strpos)));
		    other_last = s; /* Fix this later. --Hugo */
		    s = s1;
		    if (t == strpos)
			goto try_at_start;
		    goto try_at_offset;
d697 16
a716 1
    tmp = PL_bostr;
d719 2
a720 4
	    || (PL_bostr = strpos, /* Used in regcopmaybe() */
		((t = reghopmaybe_c(s, -(prog->check_offset_max)))
		 && t > strpos)))) {
	PL_bostr = tmp;
d735 1
a735 1
			if (prog->anchored_substr) {
d743 1
a743 1
			    strpos = t + 1;			    
d775 1
a775 1
	++BmUSEFUL(prog->check_substr);	/* hooray/5 */
a777 1
	PL_bostr = tmp;
d799 9
a807 3
	    && prog->check_substr		/* Could be deleted already */
	    && --BmUSEFUL(prog->check_substr) < 0
	    && prog->check_substr == prog->float_substr)
d811 5
a815 3
	    SvREFCNT_dec(prog->check_substr);
	    prog->check_substr = Nullsv;	/* disable */
	    prog->float_substr = Nullsv;	/* clear */
d838 1
d840 1
a840 1
		    ? STR_LEN(prog->regstclass)
d842 6
a847 4
	char *endpos = (prog->anchored_substr || ml_anch)
		? s + (prog->minlen? cl_l : 0)
		: (prog->float_substr ? check_at - start_shift + cl_l
				      : strend) ;
d852 1
a852 1
	    PL_regdata = prog->data;	/* Used by REGINCLASS UTF logic */
d855 1
a855 1
        s = find_byclass(prog, prog->regstclass, s, endpos, startpos, 1);
d858 1
a858 1
	    char *what;
d870 2
a871 2
	    if (prog->anchored_substr) {
		if (prog->anchored_substr == check) {
d874 1
a874 2
		    PL_regeol = strend;	/* Used in HOP() */
		    s = HOPc(t, 1);
d892 1
a892 1
		s = check_at; 
d911 1
a911 1
	    if (!prog->float_substr)	/* Could have been deleted */
d919 2
a920 2
	DEBUG_r( if (t != s)
		     PerlIO_printf(Perl_debug_log, 
d922 8
a929 4
			(long)(t - i_strpos), (long)(s - i_strpos));
		 else
		     PerlIO_printf(Perl_debug_log, 
			"Does not contradict STCLASS...\n") );
d938 2
a939 2
    if (prog->check_substr)		/* could be removed already */
	BmUSEFUL(prog->check_substr) += 5; /* hooray */
d957 1
d961 1
a961 1
	case ANYOFUTF8:
d963 10
a972 1
		if (REGINCLASSUTF8(c, (U8*)s)) {
d978 1
a978 1
		else
d980 1
a980 1
		s += UTF8SKIP(s);
d983 1
a983 1
	case ANYOF:
d985 2
a986 6
		if (REGINCLASS(c, *(U8*)s)) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
		    else
			tmp = doevery;
		}
d988 1
a988 1
		    tmp = 1;
d995 17
a1011 2
	    c1 = *(U8*)m;
	    c2 = PL_fold[c1];
d1019 1
a1019 1
	    e = strend - ln;
d1023 44
a1066 10
	    /* Here it is NOT UTF!  */
	    if (c1 == c2) {
		while (s <= e) {
		    if ( *(U8*)s == c1
			 && (ln == 1 || !(OP(c) == EXACTF
					  ? ibcmp(s, m, ln)
					  : ibcmp_locale(s, m, ln)))
			 && (norun || regtry(prog, s)) )
			goto got_it;
		    s++;
d1068 38
a1105 9
	    } else {
		while (s <= e) {
		    if ( (*(U8*)s == c1 || *(U8*)s == c2)
			 && (ln == 1 || !(OP(c) == EXACTF
					  ? ibcmp(s, m, ln)
					  : ibcmp_locale(s, m, ln)))
			 && (norun || regtry(prog, s)) )
			goto got_it;
		    s++;
d1108 22
d1135 21
a1155 7
	    tmp = (s != startpos) ? UCHARAT(s - 1) : '\n';
	    tmp = ((OP(c) == BOUND ? isALNUM(tmp) : isALNUM_LC(tmp)) != 0);
	    while (s < strend) {
		if (tmp == !(OP(c) == BOUND ? isALNUM(*s) : isALNUM_LC(*s))) {
		    tmp = !tmp;
		    if ((norun || regtry(prog, s)))
			goto got_it;
a1156 1
		s++;
a1157 9
	    if ((!prog->minlen && tmp) && (norun || regtry(prog, s)))
		goto got_it;
	    break;
	case BOUNDLUTF8:
	    PL_reg_flags |= RF_tainted;
	    /* FALL THROUGH */
	case BOUNDUTF8:
	    if (s == startpos)
		tmp = '\n';
d1159 10
a1168 14
		U8 *r = reghop((U8*)s, -1);

		tmp = (I32)utf8_to_uv(r, s - (char*)r, 0, 0);
	    }
	    tmp = ((OP(c) == BOUNDUTF8 ?
		    isALNUM_uni(tmp) : isALNUM_LC_uni(tmp)) != 0);
	    while (s < strend) {
		if (tmp == !(OP(c) == BOUNDUTF8 ?
			     swash_fetch(PL_utf8_alnum, (U8*)s) :
			     isALNUM_LC_utf8((U8*)s)))
		{
		    tmp = !tmp;
		    if ((norun || regtry(prog, s)))
			goto got_it;
a1169 1
		s += UTF8SKIP(s);
d1178 20
a1197 8
	    tmp = (s != startpos) ? UCHARAT(s - 1) : '\n';
	    tmp = ((OP(c) == NBOUND ? isALNUM(tmp) : isALNUM_LC(tmp)) != 0);
	    while (s < strend) {
		if (tmp == !(OP(c) == NBOUND ? isALNUM(*s) : isALNUM_LC(*s)))
		    tmp = !tmp;
		else if ((norun || regtry(prog, s)))
		    goto got_it;
		s++;
a1198 9
	    if ((!prog->minlen && !tmp) && (norun || regtry(prog, s)))
		goto got_it;
	    break;
	case NBOUNDLUTF8:
	    PL_reg_flags |= RF_tainted;
	    /* FALL THROUGH */
	case NBOUNDUTF8:
	    if (s == startpos)
		tmp = '\n';
d1200 11
a1210 14
		U8 *r = reghop((U8*)s, -1);

		tmp = (I32)utf8_to_uv(r, s - (char*)r, 0, 0);
	    }
	    tmp = ((OP(c) == NBOUNDUTF8 ?
		    isALNUM_uni(tmp) : isALNUM_LC_uni(tmp)) != 0);
	    while (s < strend) {
		if (tmp == !(OP(c) == NBOUNDUTF8 ?
			     swash_fetch(PL_utf8_alnum, (U8*)s) :
			     isALNUM_LC_utf8((U8*)s)))
		    tmp = !tmp;
		else if ((norun || regtry(prog, s)))
		    goto got_it;
		s += UTF8SKIP(s);
d1216 9
a1224 4
	    while (s < strend) {
		if (isALNUM(*s)) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
d1226 2
a1227 1
			tmp = doevery;
a1228 3
		else
		    tmp = 1;
		s++;
d1230 8
a1237 6
	    break;
	case ALNUMUTF8:
	    while (s < strend) {
		if (swash_fetch(PL_utf8_alnum, (U8*)s)) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
d1239 2
a1240 1
			tmp = doevery;
a1241 3
		else
		    tmp = 1;
		s += UTF8SKIP(s);
d1246 8
a1253 4
	    while (s < strend) {
		if (isALNUM_LC(*s)) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
d1255 2
a1256 1
			tmp = doevery;
a1257 3
		else
		    tmp = 1;
		s++;
d1259 8
a1266 7
	    break;
	case ALNUMLUTF8:
	    PL_reg_flags |= RF_tainted;
	    while (s < strend) {
		if (isALNUM_LC_utf8((U8*)s)) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
d1268 2
a1269 1
			tmp = doevery;
a1270 3
		else
		    tmp = 1;
		s += UTF8SKIP(s);
d1274 9
a1282 4
	    while (s < strend) {
		if (!isALNUM(*s)) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
d1284 2
a1285 1
			tmp = doevery;
a1286 3
		else
		    tmp = 1;
		s++;
d1288 8
a1295 6
	    break;
	case NALNUMUTF8:
	    while (s < strend) {
		if (!swash_fetch(PL_utf8_alnum, (U8*)s)) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
d1297 2
a1298 1
			tmp = doevery;
a1299 3
		else
		    tmp = 1;
		s += UTF8SKIP(s);
d1304 8
a1311 4
	    while (s < strend) {
		if (!isALNUM_LC(*s)) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
d1313 2
a1314 1
			tmp = doevery;
a1315 3
		else
		    tmp = 1;
		s++;
d1317 8
a1324 7
	    break;
	case NALNUMLUTF8:
	    PL_reg_flags |= RF_tainted;
	    while (s < strend) {
		if (!isALNUM_LC_utf8((U8*)s)) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
d1326 2
a1327 1
			tmp = doevery;
a1328 3
		else
		    tmp = 1;
		s += UTF8SKIP(s);
d1332 22
a1353 4
	    while (s < strend) {
		if (isSPACE(*s)) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
d1355 2
a1356 1
			tmp = doevery;
a1357 3
		else
		    tmp = 1;
		s++;
d1360 1
a1360 14
	case SPACEUTF8:
	    while (s < strend) {
		if (*s == ' ' || swash_fetch(PL_utf8_space,(U8*)s)) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
		    else
			tmp = doevery;
		}
		else
		    tmp = 1;
		s += UTF8SKIP(s);
	    }
	    break;
	case SPACEL:
d1362 8
a1369 4
	    while (s < strend) {
		if (isSPACE_LC(*s)) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
d1371 2
a1372 1
			tmp = doevery;
a1373 3
		else
		    tmp = 1;
		s++;
d1375 8
a1382 7
	    break;
	case SPACELUTF8:
	    PL_reg_flags |= RF_tainted;
	    while (s < strend) {
		if (*s == ' ' || isSPACE_LC_utf8((U8*)s)) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
d1384 2
a1385 1
			tmp = doevery;
a1386 3
		else
		    tmp = 1;
		s += UTF8SKIP(s);
d1390 9
a1398 4
	    while (s < strend) {
		if (!isSPACE(*s)) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
d1400 2
a1401 1
			tmp = doevery;
a1402 3
		else
		    tmp = 1;
		s++;
d1404 8
a1411 6
	    break;
	case NSPACEUTF8:
	    while (s < strend) {
		if (!(*s == ' ' || swash_fetch(PL_utf8_space,(U8*)s))) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
d1413 2
a1414 1
			tmp = doevery;
a1415 3
		else
		    tmp = 1;
		s += UTF8SKIP(s);
d1420 8
a1427 4
	    while (s < strend) {
		if (!isSPACE_LC(*s)) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
d1429 2
a1430 1
			tmp = doevery;
a1431 3
		else
		    tmp = 1;
		s++;
d1433 8
a1440 7
	    break;
	case NSPACELUTF8:
	    PL_reg_flags |= RF_tainted;
	    while (s < strend) {
		if (!(*s == ' ' || isSPACE_LC_utf8((U8*)s))) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
d1442 2
a1443 1
			tmp = doevery;
a1444 3
		else
		    tmp = 1;
		s += UTF8SKIP(s);
d1448 9
a1456 4
	    while (s < strend) {
		if (isDIGIT(*s)) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
d1458 2
a1459 1
			tmp = doevery;
a1460 3
		else
		    tmp = 1;
		s++;
d1462 8
a1469 6
	    break;
	case DIGITUTF8:
	    while (s < strend) {
		if (swash_fetch(PL_utf8_digit,(U8*)s)) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
d1471 2
a1472 1
			tmp = doevery;
a1473 3
		else
		    tmp = 1;
		s += UTF8SKIP(s);
d1478 8
a1485 4
	    while (s < strend) {
		if (isDIGIT_LC(*s)) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
d1487 2
a1488 1
			tmp = doevery;
a1489 3
		else
		    tmp = 1;
		s++;
d1491 8
a1498 7
	    break;
	case DIGITLUTF8:
	    PL_reg_flags |= RF_tainted;
	    while (s < strend) {
		if (isDIGIT_LC_utf8((U8*)s)) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
d1500 2
a1501 1
			tmp = doevery;
a1502 3
		else
		    tmp = 1;
		s += UTF8SKIP(s);
d1506 9
a1514 4
	    while (s < strend) {
		if (!isDIGIT(*s)) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
d1516 2
a1517 1
			tmp = doevery;
a1518 3
		else
		    tmp = 1;
		s++;
d1520 8
a1527 6
	    break;
	case NDIGITUTF8:
	    while (s < strend) {
		if (!swash_fetch(PL_utf8_digit,(U8*)s)) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
d1529 2
a1530 1
			tmp = doevery;
a1531 3
		else
		    tmp = 1;
		s += UTF8SKIP(s);
d1536 8
a1543 4
	    while (s < strend) {
		if (!isDIGIT_LC(*s)) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
d1545 2
a1546 1
			tmp = doevery;
a1547 3
		else
		    tmp = 1;
		s++;
d1549 8
a1556 7
	    break;
	case NDIGITLUTF8:
	    PL_reg_flags |= RF_tainted;
	    while (s < strend) {
		if (!isDIGIT_LC_utf8((U8*)s)) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
d1558 2
a1559 1
			tmp = doevery;
a1560 3
		else
		    tmp = 1;
		s += UTF8SKIP(s);
d1595 5
d1605 1
a1605 1
    PL_regnarrate = PL_debug & 512;
d1615 4
a1618 8
    if (strend - startpos < minlen) goto phooey;

    if (startpos == strbeg)	/* is ^ valid at stringarg? */
	PL_regprev = '\n';
    else {
	PL_regprev = (U32)stringarg[-1];
	if (!PL_multiline && PL_regprev == '\n')
	    PL_regprev = '\0';		/* force ^ to NOT match */
d1657 2
a1658 1
		  && (mg = mg_find(sv, 'g')) && mg->mg_len >= 0) {
d1661 1
a1661 1
		if (s > PL_reg_ganch)
d1670 1
a1670 1
    if (!(flags & REXEC_CHECKED) && prog->check_substr != Nullsv) {
d1676 2
a1677 1
	if (!s)
d1679 1
d1682 23
a1704 12
    DEBUG_r( if (!PL_colorset) reginitcolors() );
    DEBUG_r(PerlIO_printf(Perl_debug_log,
		      "%sMatching REx%s `%s%.60s%s%s' against `%s%.*s%s%s'\n",
		      PL_colors[4],PL_colors[5],PL_colors[0],
		      prog->precomp,
		      PL_colors[1],
		      (strlen(prog->precomp) > 60 ? "..." : ""),
		      PL_colors[0],
		      (int)(strend - startpos > 60 ? 60 : strend - startpos),
		      startpos, PL_colors[1],
		      (strend - startpos > 60 ? "..." : ""))
	);
d1718 1
a1718 1
	    end = HOPc(strend, -dontbother) - 1;
d1720 1
a1720 1
	    if (prog->check_substr) {
d1756 1
a1756 1
    if (prog->anchored_substr && prog->reganch & ROPT_SKIP) { 
d1759 1
a1759 1
	char ch = SvPVX(prog->anchored_substr)[0];
d1763 3
d1767 1
a1767 1
	if (UTF) {
d1791 1
a1791 1
	DEBUG_r(did_match ||
d1793 2
a1794 1
			      "Did not find anchored character...\n"));
d1798 7
a1804 11
	     || (prog->float_substr != Nullsv 
		 && prog->float_max_offset < strend - s)) {
	SV *must = prog->anchored_substr 
	    ? prog->anchored_substr : prog->float_substr;
	I32 back_max = 
	    prog->anchored_substr ? prog->anchored_offset : prog->float_max_offset;
	I32 back_min = 
	    prog->anchored_substr ? prog->anchored_offset : prog->float_min_offset;
	char *last = HOPc(strend,	/* Cannot start after this */
			  -(I32)(CHR_SVLEN(must)
				 - (SvTAIL(must) != 0) + back_min));
d1809 19
d1840 2
a1841 2
		((flags & REXEC_SCREAM) 
		 ? (s = screaminstr(sv, must, HOPc(s, back_min) - strbeg,
d1843 2
a1844 2
		 : (s = fbm_instr((unsigned char*)HOP(s, back_min),
				  (unsigned char*)strend, must, 
d1857 1
a1857 1
	    if (UTF) {
d1872 4
a1875 3
	DEBUG_r(did_match ||
		PerlIO_printf(Perl_debug_log, "Did not find %s substr `%s%.*s%s'%s...\n",
			      ((must == prog->anchored_substr)
d1880 2
a1881 1
			      PL_colors[1], (SvTAIL(must) ? "$" : "")));
d1888 21
d1915 2
a1916 1
	if (prog->float_substr != Nullsv) {	/* Trim the end. */
d1918 5
d1925 1
a1925 1
		last = screaminstr(sv, prog->float_substr, s - strbeg,
d1928 1
a1928 1
		    last = scream_olds; /* Only one occurence. */
d1932 1
a1932 1
		char *little = SvPV(prog->float_substr, len);
d1934 1
a1934 1
		if (SvTAIL(prog->float_substr)) {
d1938 1
a1938 1
			last = memEQ(strend - len, little, len) 
d1944 1
a1944 1
		    if (len) 
d1962 1
a1962 1
	if (UTF) {
d1991 1
a1991 1
	restore_pos(aTHXo_ 0);
d2013 1
a2013 1
    
d2020 1
a2020 1
	restore_pos(aTHXo_ 0);
d2057 1
a2057 1
		/* SAVE_DEFSV does *not* suffice here for USE_THREADS */
d2062 2
a2063 2
	    if (!(SvTYPE(PL_reg_sv) >= SVt_PVMG && SvMAGIC(PL_reg_sv) 
		  && (mg = mg_find(PL_reg_sv, 'g')))) {
d2065 3
a2067 2
		sv_magic(PL_reg_sv, (SV*)0, 'g', Nullch, 0);
		mg = mg_find(PL_reg_sv, 'g');
d2074 1
a2074 1
	if (!PL_reg_curpm)
d2076 12
a2087 1
	PL_reg_curpm->op_pmregexp = prog;
d2108 1
d2138 1
a2138 1
	for (i = prog->nparens; i > *PL_reglastparen; i--) {
d2183 11
d2217 2
a2218 2
    register I32 ln;		/* len or last */
    register char *s;		/* operand or save */
d2220 1
a2220 1
    register I32 c1, c2, paren;	/* case fold search, parenth */
d2223 1
d2225 7
d2241 2
a2242 20
#define sayNO_L (logical ? (logical = 0, sw = 0, goto cont) : sayNO)
#if 1
#  define sayYES goto yes
#  define sayNO goto no
#  define sayYES_FINAL goto yes_final
#  define sayYES_LOUD  goto yes_loud
#  define sayNO_FINAL  goto no_final
#  define sayNO_SILENT goto do_no
#  define saySAME(x) if (x) goto yes; else goto no
#  define REPORT_CODE_OFF 24
#else
#  define sayYES return 1
#  define sayNO return 0
#  define sayYES_FINAL return 1
#  define sayYES_LOUD  return 1
#  define sayNO_FINAL  return 0
#  define sayNO_SILENT return 0
#  define saySAME(x) return x
#endif
	DEBUG_r( {
d2246 1
a2246 1
	    int l = (PL_regeol - locinput > taill ? taill : PL_regeol - locinput);
d2253 7
a2259 4
	    int pref_len = (locinput - PL_bostr > (5 + taill) - l 
			    ? (5 + taill) - l : locinput - PL_bostr);
	    int pref0_len = pref_len  - (locinput - PL_reg_starttry);

d2261 1
a2261 1
		l = ( PL_regeol - locinput > (5 + taill) - pref_len 
d2263 2
d2270 36
a2305 14
	    PerlIO_printf(Perl_debug_log, 
			  "%4"IVdf" <%s%.*s%s%s%.*s%s%s%s%.*s%s>%*s|%3"IVdf":%*s%s\n",
			  (IV)(locinput - PL_bostr), 
			  PL_colors[4], pref0_len, 
			  locinput - pref_len, PL_colors[5],
			  PL_colors[2], pref_len - pref0_len, 
			  locinput - pref_len + pref0_len, PL_colors[3],
			  (docolor ? "" : "> <"),
			  PL_colors[0], l, locinput, PL_colors[1],
			  15 - l - pref_len + 1,
			  "",
			  (IV)(scan - PL_regprogram), PL_regindent*2, "",
			  SvPVX(prop));
	} );
d2313 2
a2314 4
	    if (locinput == PL_bostr
		? PL_regprev == '\n'
		: (PL_multiline && 
		   (nextchr || locinput < PL_regeol) && locinput[-1] == '\n') )
d2321 2
a2322 3
	    if (locinput == PL_bostr
		? PL_regprev == '\n'
		: ((nextchr || locinput < PL_regeol) && locinput[-1] == '\n') )
d2356 1
a2356 8
	case SANYUTF8:
	    if (nextchr & 0x80) {
		locinput += PL_utf8skip[nextchr];
		if (locinput > PL_regeol)
		    sayNO;
		nextchr = UCHARAT(locinput);
		break;
	    }
d2359 8
a2366 1
	    nextchr = UCHARAT(++locinput);
d2368 1
a2368 1
	case SANY:
d2373 4
a2376 2
	case ANYUTF8:
	    if (nextchr & 0x80) {
a2380 1
		break;
d2382 2
a2383 8
	    if ((!nextchr && locinput >= PL_regeol) || nextchr == '\n')
		sayNO;
	    nextchr = UCHARAT(++locinput);
	    break;
	case REG_ANY:
	    if ((!nextchr && locinput >= PL_regeol) || nextchr == '\n')
		sayNO;
	    nextchr = UCHARAT(++locinput);
d2388 39
d2444 2
a2445 1
	    if (UTF) {
d2447 16
a2462 14
		char *e = s + ln;
		c1 = OP(scan) == EXACTF;
		while (s < e) {
		    if (l >= PL_regeol)
			sayNO;
		    if (utf8_to_uv((U8*)s, e - s, 0, 0) !=
			(c1 ?
			 toLOWER_utf8((U8*)l) :
			 toLOWER_LC_utf8((U8*)l)))
		    {
			sayNO;
		    }
		    s += UTF8SKIP(s);
		    l += UTF8SKIP(l);
d2464 1
a2464 1
		locinput = l;
d2469 2
a2484 8
	case ANYOFUTF8:
	    if (!REGINCLASSUTF8(scan, (U8*)locinput))
		sayNO;
	    if (locinput >= PL_regeol)
		sayNO;
	    locinput += PL_utf8skip[nextchr];
	    nextchr = UCHARAT(locinput);
	    break;
d2486 8
a2493 1
	    if (nextchr < 0)
d2495 22
a2516 5
	    if (!REGINCLASS(scan, nextchr))
		sayNO;
	    if (!nextchr && locinput >= PL_regeol)
		sayNO;
	    nextchr = UCHARAT(++locinput);
d2524 4
a2527 14
	    if (!(OP(scan) == ALNUM
		  ? isALNUM(nextchr) : isALNUM_LC(nextchr)))
		sayNO;
	    nextchr = UCHARAT(++locinput);
	    break;
	case ALNUMLUTF8:
	    PL_reg_flags |= RF_tainted;
	    /* FALL THROUGH */
	case ALNUMUTF8:
	    if (!nextchr)
		sayNO;
	    if (nextchr & 0x80) {
		if (!(OP(scan) == ALNUMUTF8
		      ? swash_fetch(PL_utf8_alnum, (U8*)locinput)
d2536 1
a2536 1
	    if (!(OP(scan) == ALNUMUTF8
d2547 4
a2550 14
	    if (OP(scan) == NALNUM
		? isALNUM(nextchr) : isALNUM_LC(nextchr))
		sayNO;
	    nextchr = UCHARAT(++locinput);
	    break;
	case NALNUMLUTF8:
	    PL_reg_flags |= RF_tainted;
	    /* FALL THROUGH */
	case NALNUMUTF8:
	    if (!nextchr && locinput >= PL_regeol)
		sayNO;
	    if (nextchr & 0x80) {
		if (OP(scan) == NALNUMUTF8
		    ? swash_fetch(PL_utf8_alnum, (U8*)locinput)
d2559 1
a2559 1
	    if (OP(scan) == NALNUMUTF8
d2571 17
a2587 4
	    ln = (locinput != PL_regbol) ? UCHARAT(locinput - 1) : PL_regprev;
	    if (OP(scan) == BOUND || OP(scan) == NBOUND) {
		ln = isALNUM(ln);
		n = isALNUM(nextchr);
d2590 10
a2599 2
		ln = isALNUM_LC(ln);
		n = isALNUM_LC(nextchr);
d2601 3
a2603 27
	    if (((!ln) == (!n)) == (OP(scan) == BOUND || OP(scan) == BOUNDL))
		sayNO;
	    break;
	case BOUNDLUTF8:
	case NBOUNDLUTF8:
	    PL_reg_flags |= RF_tainted;
	    /* FALL THROUGH */
	case BOUNDUTF8:
	case NBOUNDUTF8:
	    /* was last char in word? */
	    if (locinput == PL_regbol)
		ln = PL_regprev;
	    else {
		U8 *r = reghop((U8*)locinput, -1);

		ln = utf8_to_uv(r, s - (char*)r, 0, 0);
	    }
	    if (OP(scan) == BOUNDUTF8 || OP(scan) == NBOUNDUTF8) {
		ln = isALNUM_uni(ln);
		n = swash_fetch(PL_utf8_alnum, (U8*)locinput);
	    }
	    else {
		ln = isALNUM_LC_uni(ln);
		n = isALNUM_LC_utf8((U8*)locinput);
	    }
	    if (((!ln) == (!n)) == (OP(scan) == BOUNDUTF8 || OP(scan) == BOUNDLUTF8))
		sayNO;
d2611 21
a2631 16
	    if (!(OP(scan) == SPACE
		  ? isSPACE(nextchr) : isSPACE_LC(nextchr)))
		sayNO;
	    nextchr = UCHARAT(++locinput);
	    break;
	case SPACELUTF8:
	    PL_reg_flags |= RF_tainted;
	    /* FALL THROUGH */
	case SPACEUTF8:
	    if (!nextchr)
		sayNO;
	    if (nextchr & 0x80) {
		if (!(OP(scan) == SPACEUTF8
		      ? swash_fetch(PL_utf8_space, (U8*)locinput)
		      : isSPACE_LC_utf8((U8*)locinput)))
		{
d2633 1
a2633 4
		}
		locinput += PL_utf8skip[nextchr];
		nextchr = UCHARAT(locinput);
		break;
a2634 4
	    if (!(OP(scan) == SPACEUTF8
		  ? isSPACE(nextchr) : isSPACE_LC(nextchr)))
		sayNO;
	    nextchr = UCHARAT(++locinput);
d2642 4
a2645 14
	    if (OP(scan) == NSPACE
		? isSPACE(nextchr) : isSPACE_LC(nextchr))
		sayNO;
	    nextchr = UCHARAT(++locinput);
	    break;
	case NSPACELUTF8:
	    PL_reg_flags |= RF_tainted;
	    /* FALL THROUGH */
	case NSPACEUTF8:
	    if (!nextchr && locinput >= PL_regeol)
		sayNO;
	    if (nextchr & 0x80) {
		if (OP(scan) == NSPACEUTF8
		    ? swash_fetch(PL_utf8_space, (U8*)locinput)
d2654 1
a2654 1
	    if (OP(scan) == NSPACEUTF8
d2665 4
a2668 14
	    if (!(OP(scan) == DIGIT
		  ? isDIGIT(nextchr) : isDIGIT_LC(nextchr)))
		sayNO;
	    nextchr = UCHARAT(++locinput);
	    break;
	case DIGITLUTF8:
	    PL_reg_flags |= RF_tainted;
	    /* FALL THROUGH */
	case DIGITUTF8:
	    if (!nextchr)
		sayNO;
	    if (nextchr & 0x80) {
		if (!(OP(scan) == DIGITUTF8
		      ? swash_fetch(PL_utf8_digit, (U8*)locinput)
d2677 1
a2677 1
	    if (!(OP(scan) == DIGITUTF8
d2688 4
a2691 14
	    if (OP(scan) == NDIGIT
		? isDIGIT(nextchr) : isDIGIT_LC(nextchr))
		sayNO;
	    nextchr = UCHARAT(++locinput);
	    break;
	case NDIGITLUTF8:
	    PL_reg_flags |= RF_tainted;
	    /* FALL THROUGH */
	case NDIGITUTF8:
	    if (!nextchr && locinput >= PL_regeol)
		sayNO;
	    if (nextchr & 0x80) {
		if (OP(scan) == NDIGITUTF8
		    ? swash_fetch(PL_utf8_digit, (U8*)locinput)
d2700 1
a2700 1
	    if (OP(scan) == NDIGITUTF8
d2706 1
a2706 6
	    if (locinput >= PL_regeol || swash_fetch(PL_utf8_mark,(U8*)locinput))
		sayNO;
	    locinput += PL_utf8skip[nextchr];
	    while (locinput < PL_regeol && swash_fetch(PL_utf8_mark,(U8*)locinput))
		locinput += UTF8SKIP(locinput);
	    if (locinput > PL_regeol)
d2708 13
d2731 1
a2731 1
	    if (*PL_reglastparen < n || ln == -1)
d2737 1
a2737 1
	    if (UTF && OP(scan) != REF) {	/* REF can do byte comparison */
d2746 3
d2752 3
a2754 1
			if (toLOWER_utf8((U8*)s) != toLOWER_utf8((U8*)l))
d2756 2
a2757 12
			s += UTF8SKIP(s);
			l += UTF8SKIP(l);
		    }
		}
		else {
		    while (s < e) {
			if (l >= PL_regeol)
			    sayNO;
			if (toLOWER_LC_utf8((U8*)s) != toLOWER_LC_utf8((U8*)l))
			    sayNO;
			s += UTF8SKIP(s);
			l += UTF8SKIP(l);
d2796 1
a2796 1
	    
d2803 12
a2814 5
	    CALLRUNOPS(aTHX);			/* Scalar context. */
	    SPAGAIN;
	    ret = POPs;
	    PUTBACK;
	    
d2829 1
a2829 1
			    mg = mg_find(sv, 'r');
d2843 1
a2843 2
			pm.op_pmflags = 0;
			pm.op_pmdynflags = (UTF||DO_UTF8(ret) ? PMdf_UTF8 : 0);
d2845 1
a2845 1
			if (!(SvFLAGS(ret) 
d2847 2
a2848 1
			    sv_magic(ret,(SV*)ReREFCNT_inc(re),'r',0,0);
d2854 1
a2854 1
			PerlIO_printf(Perl_debug_log, 
d2867 1
a2867 1
		    
d2873 1
d2910 1
d2930 1
a2930 1
	    if (n > *PL_reglastparen)
d2932 1
d2936 1
a2936 1
	    sw = (*PL_reglastparen >= n && PL_regendp[n] != -1);
d2959 1
a2959 1
   2) This regnode creates infoblock on the stack, and calls 
d2980 1
a2980 1
 In the following picture infoblocks for outer loop of 
d3038 1
a3038 1
		if (parenfloor > *PL_reglastparen)
d3073 2
a3074 2
		    PerlIO_printf(Perl_debug_log, 
				  "%*s  %ld out of %ld..%ld  cc=%lx\n", 
d3076 2
a3077 2
				  (long)n, (long)cc->min, 
				  (long)cc->max, (long)cc)
d3122 1
a3122 1
			if (PL_reg_poscache_size < size) {
d3175 1
a3175 1
			if (ckWARN(WARN_REGEXP) && n >= REG_INFTY 
d3178 1
a3178 1
			    Perl_warner(aTHX_ WARN_REGEXP, "%s limit (%d) exceeded",
d3227 1
a3227 1
		if (ckWARN(WARN_REGEXP) && n >= REG_INFTY 
d3230 1
a3230 1
		    Perl_warner(aTHX_ WARN_REGEXP, "%s limit (%d) exceeded",
d3249 1
a3249 1
	case BRANCHJ: 
d3255 1
a3255 1
	case BRANCH: 
a3258 1
		CHECKPOINT lastcp;
d3297 1
a3297 1
	    
d3307 1
a3307 1
		if (paren > *PL_reglastparen)
d3318 9
a3326 6
		if (ln && l == 0 && n >= ln
		    /* In fact, this is tricky.  If paren, then the
		       fact that we did/didnot match may influence
		       future execution. */
		    && !(paren && ln == 0))
		    ln = n;
d3328 30
a3357 8
		if (PL_regkind[(U8)OP(next)] == EXACT) {
		    c1 = (U8)*STRING(next);
		    if (OP(next) == EXACTF)
			c2 = PL_fold[c1];
		    else if (OP(next) == EXACTFL)
			c2 = PL_fold_locale[c1];
		    else
			c2 = c1;
d3361 1
d3371 1
a3371 1
			    if (n) {
d3395 7
a3401 6
		if (n != 0 && l == 0
		    /* In fact, this is tricky.  If paren, then the
		       fact that we did/didnot match may influence
		       future execution. */
		    && !(paren && ln == 0))
		    ln = n;
d3410 31
a3440 8
		    if (PL_regkind[(U8)OP(next)] == EXACT) {
			c1 = (U8)*STRING(next);
			if (OP(next) == EXACTF)
			    c2 = PL_fold[c1];
			else if (OP(next) == EXACTFL)
			    c2 = PL_fold_locale[c1];
			else
			    c2 = c1;
d3445 1
d3483 1
a3483 1
	    if (paren > *PL_reglastparen)
d3511 62
a3572 8
	    if (PL_regkind[(U8)OP(next)] == EXACT) {
		c1 = (U8)*STRING(next);
		if (OP(next) == EXACTF)
		    c2 = PL_fold[c1];
		else if (OP(next) == EXACTFL)
		    c2 = PL_fold_locale[c1];
		else
		    c2 = c1;
d3576 1
d3586 1
a3586 1
		    char *e = locinput + n - ln; /* Should not check after this */
d3588 1
d3590 1
a3590 1
		    if (e >= PL_regeol || (n == REG_INFTY))
d3592 15
d3609 40
a3648 8
			if (c1 == c2) {
			    while (locinput <= e && *locinput != c1)
				locinput++;
			} else {
			    while (locinput <= e 
				   && *locinput != c1
				   && *locinput != c2)
				locinput++;			    
d3650 1
a3650 1
			if (locinput > e) 
d3655 1
a3655 2
			    if (regrepeat(scan, locinput - old) <
				 locinput - old)
d3663 6
a3668 1
			old = locinput++;
d3673 16
d3690 1
a3690 3
		    if (c1 == -1000 ||
			UCHARAT(PL_reginput) == c1 ||
			UCHARAT(PL_reginput) == c2)
d3710 3
a3712 1
		    (!PL_multiline  || OP(next) == SEOL || OP(next) == EOS)) {
d3722 1
d3724 9
d3734 1
a3734 3
			if (c1 == -1000 ||
			    UCHARAT(PL_reginput) == c1 ||
			    UCHARAT(PL_reginput) == c2)
d3745 1
d3747 9
d3757 1
a3757 3
			if (c1 == -1000 ||
			    UCHARAT(PL_reginput) == c1 ||
			    UCHARAT(PL_reginput) == c2)
d3822 1
a3822 1
	    goto do_ifmatch;	    
d3826 4
a3829 14
		if (UTF) {		/* XXXX This is absolutely
					   broken, we read before
					   start of string. */
		    s = HOPMAYBEc(locinput, -scan->flags);
		    if (!s)
			goto say_yes;
		    PL_reginput = s;
		}
		else {
		    if (locinput < PL_bostr + scan->flags) 
			goto say_yes;
		    PL_reginput = locinput - scan->flags;
		    goto do_ifmatch;
		}
d3837 4
a3840 14
		if (UTF) {		/* XXXX This is absolutely
					   broken, we read before
					   start of string. */
		    s = HOPMAYBEc(locinput, -scan->flags);
		    if (!s || s < PL_bostr)
			goto say_no;
		    PL_reginput = s;
		}
		else {
		    if (locinput < PL_bostr + scan->flags) 
			goto say_no;
		    PL_reginput = locinput - scan->flags;
		    goto do_ifmatch;
		}
d3929 1
a3929 1
	    
d3935 2
a3936 2
	    if ( !scan || 
		 OP(scan) != (uwb->type == RE_UNWIND_BRANCH 
d3990 1
d3993 3
a3995 1
    if (max != REG_INFTY && max < loceol - scan)
d3999 10
a4008 2
	while (scan < loceol && *scan != '\n')
	    scan++;
d4011 6
a4016 7
	scan = loceol;
	break;
    case ANYUTF8:
	loceol = PL_regeol;
	while (scan < loceol && *scan != '\n') {
	    scan += UTF8SKIP(scan);
	    hardcount++;
d4018 2
d4021 2
a4022 6
    case SANYUTF8:
	loceol = PL_regeol;
	while (scan < loceol) {
	    scan += UTF8SKIP(scan);
	    hardcount++;
	}
d4042 11
a4052 5
    case ANYOFUTF8:
	loceol = PL_regeol;
	while (scan < loceol && REGINCLASSUTF8(p, (U8*)scan)) {
	    scan += UTF8SKIP(scan);
	    hardcount++;
a4054 4
    case ANYOF:
	while (scan < loceol && REGINCLASS(p, *scan))
	    scan++;
	break;
d4056 11
a4066 8
	while (scan < loceol && isALNUM(*scan))
	    scan++;
	break;
    case ALNUMUTF8:
	loceol = PL_regeol;
	while (scan < loceol && swash_fetch(PL_utf8_alnum, (U8*)scan)) {
	    scan += UTF8SKIP(scan);
	    hardcount++;
d4071 10
a4080 9
	while (scan < loceol && isALNUM_LC(*scan))
	    scan++;
	break;
    case ALNUMLUTF8:
	PL_reg_flags |= RF_tainted;
	loceol = PL_regeol;
	while (scan < loceol && isALNUM_LC_utf8((U8*)scan)) {
	    scan += UTF8SKIP(scan);
	    hardcount++;
a4082 1
	break;
d4084 11
a4094 8
	while (scan < loceol && !isALNUM(*scan))
	    scan++;
	break;
    case NALNUMUTF8:
	loceol = PL_regeol;
	while (scan < loceol && !swash_fetch(PL_utf8_alnum, (U8*)scan)) {
	    scan += UTF8SKIP(scan);
	    hardcount++;
d4099 10
a4108 9
	while (scan < loceol && !isALNUM_LC(*scan))
	    scan++;
	break;
    case NALNUMLUTF8:
	PL_reg_flags |= RF_tainted;
	loceol = PL_regeol;
	while (scan < loceol && !isALNUM_LC_utf8((U8*)scan)) {
	    scan += UTF8SKIP(scan);
	    hardcount++;
d4112 12
a4123 8
	while (scan < loceol && isSPACE(*scan))
	    scan++;
	break;
    case SPACEUTF8:
	loceol = PL_regeol;
	while (scan < loceol && (*scan == ' ' || swash_fetch(PL_utf8_space,(U8*)scan))) {
	    scan += UTF8SKIP(scan);
	    hardcount++;
d4128 10
a4137 9
	while (scan < loceol && isSPACE_LC(*scan))
	    scan++;
	break;
    case SPACELUTF8:
	PL_reg_flags |= RF_tainted;
	loceol = PL_regeol;
	while (scan < loceol && (*scan == ' ' || isSPACE_LC_utf8((U8*)scan))) {
	    scan += UTF8SKIP(scan);
	    hardcount++;
d4141 13
a4153 8
	while (scan < loceol && !isSPACE(*scan))
	    scan++;
	break;
    case NSPACEUTF8:
	loceol = PL_regeol;
	while (scan < loceol && !(*scan == ' ' || swash_fetch(PL_utf8_space,(U8*)scan))) {
	    scan += UTF8SKIP(scan);
	    hardcount++;
a4154 1
	break;
d4157 10
a4166 9
	while (scan < loceol && !isSPACE_LC(*scan))
	    scan++;
	break;
    case NSPACELUTF8:
	PL_reg_flags |= RF_tainted;
	loceol = PL_regeol;
	while (scan < loceol && !(*scan == ' ' || isSPACE_LC_utf8((U8*)scan))) {
	    scan += UTF8SKIP(scan);
	    hardcount++;
d4170 11
a4180 8
	while (scan < loceol && isDIGIT(*scan))
	    scan++;
	break;
    case DIGITUTF8:
	loceol = PL_regeol;
	while (scan < loceol && swash_fetch(PL_utf8_digit,(U8*)scan)) {
	    scan += UTF8SKIP(scan);
	    hardcount++;
a4182 1
	break;
d4184 11
a4194 8
	while (scan < loceol && !isDIGIT(*scan))
	    scan++;
	break;
    case NDIGITUTF8:
	loceol = PL_regeol;
	while (scan < loceol && !swash_fetch(PL_utf8_digit,(U8*)scan)) {
	    scan += UTF8SKIP(scan);
	    hardcount++;
d4207 1
a4207 1
    DEBUG_r( 
d4212 2
a4213 2
		PerlIO_printf(Perl_debug_log, 
			      "%*s  %s can match %"IVdf" times out of %"IVdf"...\n", 
d4216 1
a4216 1
    
d4222 1
a4222 1
 * 
d4229 1
a4229 1
    register char *scan;
d4239 1
a4239 1
    if (UTF) {
d4268 1
a4268 1
    
d4273 46
d4320 6
d4329 1
a4329 1
S_reginclass(pTHX_ register regnode *p, register I32 c)
d4331 1
a4331 1
    char flags = ANYOF_FLAGS(p);
d4333 15
a4347 9

    c &= 0xFF;
    if (ANYOF_BITMAP_TEST(p, c))
	match = TRUE;
    else if (flags & ANYOF_FOLD) {
	I32 cf;
	if (flags & ANYOF_LOCALE) {
	    PL_reg_flags |= RF_tainted;
	    cf = PL_fold_locale[c];
d4349 1
a4349 3
	else
	    cf = PL_fold[c];
	if (ANYOF_BITMAP_TEST(p, cf))
d4351 36
d4388 5
d4394 8
a4401 36
    if (!match && (flags & ANYOF_CLASS)) {
	PL_reg_flags |= RF_tainted;
	if (
	    (ANYOF_CLASS_TEST(p, ANYOF_ALNUM)   &&  isALNUM_LC(c))  ||
	    (ANYOF_CLASS_TEST(p, ANYOF_NALNUM)  && !isALNUM_LC(c))  ||
	    (ANYOF_CLASS_TEST(p, ANYOF_SPACE)   &&  isSPACE_LC(c))  ||
	    (ANYOF_CLASS_TEST(p, ANYOF_NSPACE)  && !isSPACE_LC(c))  ||
	    (ANYOF_CLASS_TEST(p, ANYOF_DIGIT)   &&  isDIGIT_LC(c))  ||
	    (ANYOF_CLASS_TEST(p, ANYOF_NDIGIT)  && !isDIGIT_LC(c))  ||
	    (ANYOF_CLASS_TEST(p, ANYOF_ALNUMC)  &&  isALNUMC_LC(c)) ||
	    (ANYOF_CLASS_TEST(p, ANYOF_NALNUMC) && !isALNUMC_LC(c)) ||
	    (ANYOF_CLASS_TEST(p, ANYOF_ALPHA)   &&  isALPHA_LC(c))  ||
	    (ANYOF_CLASS_TEST(p, ANYOF_NALPHA)  && !isALPHA_LC(c))  ||
	    (ANYOF_CLASS_TEST(p, ANYOF_ASCII)   &&  isASCII(c))     ||
	    (ANYOF_CLASS_TEST(p, ANYOF_NASCII)  && !isASCII(c))     ||
	    (ANYOF_CLASS_TEST(p, ANYOF_CNTRL)   &&  isCNTRL_LC(c))  ||
	    (ANYOF_CLASS_TEST(p, ANYOF_NCNTRL)  && !isCNTRL_LC(c))  ||
	    (ANYOF_CLASS_TEST(p, ANYOF_GRAPH)   &&  isGRAPH_LC(c))  ||
	    (ANYOF_CLASS_TEST(p, ANYOF_NGRAPH)  && !isGRAPH_LC(c))  ||
	    (ANYOF_CLASS_TEST(p, ANYOF_LOWER)   &&  isLOWER_LC(c))  ||
	    (ANYOF_CLASS_TEST(p, ANYOF_NLOWER)  && !isLOWER_LC(c))  ||
	    (ANYOF_CLASS_TEST(p, ANYOF_PRINT)   &&  isPRINT_LC(c))  ||
	    (ANYOF_CLASS_TEST(p, ANYOF_NPRINT)  && !isPRINT_LC(c))  ||
	    (ANYOF_CLASS_TEST(p, ANYOF_PUNCT)   &&  isPUNCT_LC(c))  ||
	    (ANYOF_CLASS_TEST(p, ANYOF_NPUNCT)  && !isPUNCT_LC(c))  ||
	    (ANYOF_CLASS_TEST(p, ANYOF_UPPER)   &&  isUPPER_LC(c))  ||
	    (ANYOF_CLASS_TEST(p, ANYOF_NUPPER)  && !isUPPER_LC(c))  ||
	    (ANYOF_CLASS_TEST(p, ANYOF_XDIGIT)  &&  isXDIGIT(c))    ||
	    (ANYOF_CLASS_TEST(p, ANYOF_NXDIGIT) && !isXDIGIT(c))    ||
	    (ANYOF_CLASS_TEST(p, ANYOF_PSXSPC)  &&  isPSXSPC(c))    ||
	    (ANYOF_CLASS_TEST(p, ANYOF_NPSXSPC) && !isPSXSPC(c))    ||
	    (ANYOF_CLASS_TEST(p, ANYOF_BLANK)   &&  isBLANK(c))     ||
	    (ANYOF_CLASS_TEST(p, ANYOF_NBLANK)  && !isBLANK(c))
	    ) /* How's that for a conditional? */
	{
	    match = TRUE;
d4403 2
a4404 24
    }

    return (flags & ANYOF_INVERT) ? !match : match;
}

STATIC bool
S_reginclassutf8(pTHX_ regnode *f, U8 *p)
{                                           
    char flags = ARG1(f);
    bool match = FALSE;
#ifdef DEBUGGING
    SV *rv = (SV*)PL_regdata->data[ARG2(f)];
    AV *av = (AV*)SvRV((SV*)rv);
    SV *sw = *av_fetch(av, 0, FALSE);
    SV *lv = *av_fetch(av, 1, FALSE);
#else
    SV *sw = (SV*)PL_regdata->data[ARG2(f)];
#endif

    if (swash_fetch(sw, p))
	match = TRUE;
    else if (flags & ANYOF_FOLD) {
	U8 tmpbuf[UTF8_MAXLEN+1];
	if (flags & ANYOF_LOCALE) {
d4406 35
a4440 1
	    uv_to_utf8(tmpbuf, toLOWER_LC_utf8(p));
a4441 4
	else
	    uv_to_utf8(tmpbuf, toLOWER_utf8(p));
	if (swash_fetch(sw, tmpbuf))
	    match = TRUE;
a4443 2
    /* UTF8 combined with ANYOF_CLASS is ill-defined. */

d4449 7
a4455 1
{                               
d4457 2
a4458 1
	while (off-- && s < (U8*)PL_regeol)
d4460 1
d4464 1
a4464 1
	    if (s > (U8*)PL_bostr) {
d4466 2
a4467 2
		if (*s & 0x80) {
		    while (s > (U8*)PL_bostr && (*s & 0xc0) == 0x80)
d4469 2
a4470 1
		}		/* XXX could check well-formedness here */
d4478 7
a4484 1
S_reghopmaybe(pTHX_ U8* s, I32 off)
d4487 2
a4488 1
	while (off-- && s < (U8*)PL_regeol)
d4490 1
d4496 1
a4496 1
	    if (s > (U8*)PL_bostr) {
d4498 2
a4499 2
		if (*s & 0x80) {
		    while (s > (U8*)PL_bostr && (*s & 0xc0) == 0x80)
d4501 2
a4502 1
		}		/* XXX could check well-formedness here */
a4512 4
#ifdef PERL_OBJECT
#include "XSUB.h"
#endif

d4514 1
a4514 1
restore_pos(pTHXo_ void *arg)
d4526 56
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d69 1
a69 1
 ****    Copyright (c) 1991-2000, Larry Wall
d109 5
a113 1
#define REGINCLASSUTF8(f,p)  (ARG1(f) ? reginclassutf8(f,p) : swash_fetch((SV*)PL_regdata->data[ARG2(f)],p))
a130 1
    dTHR;
d132 2
a133 1
    int i = (PL_regsize - parenfloor) * 4;
d136 2
a137 1
    SSCHECK(i + 5);
d139 1
d145 1
d149 6
a154 2
    SSPUSHINT(i + 3);
    SSPUSHINT(SAVEt_REGCONTEXT);
d159 1
a159 1
#  define REGCP_SET  DEBUG_r(PerlIO_printf(Perl_debug_log,		\
d161 1
a161 1
			     (IV)PL_savestack_ix)); lastcp = PL_savestack_ix
d163 1
a163 1
#  define REGCP_UNWIND  DEBUG_r(lastcp != PL_savestack_ix ?		\
d166 1
a166 1
				(IV)lastcp, (IV)PL_savestack_ix) : 0); regcpblow(lastcp)
d171 1
a171 2
    dTHR;
    I32 i = SSPOPINT;
d175 2
a176 1
    assert(i == SAVEt_REGCONTEXT);
d178 2
d183 4
a186 1
    for (i -= 3; i > 0; i -= 4) {
d209 11
d225 1
a231 1
    dTHR;
d249 17
a265 1
#define regcpblow(cp) LEAVE_SCOPE(cp)
a289 1
    dTHR;
d354 1
d381 1
d388 9
a396 1
	if ((prog->check_offset_min == prog->check_offset_max) && !ml_anch) {
a399 5
	    if ( !(prog->reganch & ROPT_ANCH_GPOS) /* Checked by the caller */
		 && (sv && (strpos + SvCUR(sv) != strend)) ) {
		DEBUG_r(PerlIO_printf(Perl_debug_log, "Not at start...\n"));
		goto fail;
	    }
d425 1
d456 2
a460 1
	char *strbeg = SvPVX(sv);	/* XXXX Assume PV_force() on SCREAM! */
d611 1
a611 1
		    other_last = last + 1;
d619 1
a619 1
		    other_last = s + 1;
d649 1
a649 1
		    if (t < s - prog->check_offset_min) {
d651 2
a652 1
			    /* We definitely contradict the found anchored
d663 2
d670 4
a673 1
		    DEBUG_r(PerlIO_printf(Perl_debug_log, "Found /%s^%s/m, restarting at offset %ld...\n",
d675 1
a675 1
		    strpos = s = t + 1;
d684 4
d694 1
a694 1
	/* The found string does not prohibit matching at beg-of-str
d696 2
a697 1
	   unless it was an MBOL and we are not after MBOL. */
d701 2
a702 2
	if (ml_anch && sv
	    && (strpos + SvCUR(sv) != strend) && strpos[-1] != '\n'
d710 2
a711 2
	    PerlIO_printf(Perl_debug_log, "Does not contradict /%s^%s/m...\n",
			PL_colors[0],PL_colors[1]);
d720 1
d724 1
d753 1
a753 1
	char *startpos = sv && SvPOK(sv) ? strend - SvCUR(sv) : s;
d787 2
d790 1
a790 1
				"Trying %s substr starting at offset %ld...\n",
d799 2
d802 1
a802 1
			  "Trying anchored substr starting at offset %ld...\n",
d810 2
d813 2
a814 2
			  "Trying /^/m starting at offset %ld...\n",
			  (long)(t - i_strpos)) );
d833 4
a836 2
    DEBUG_r(PerlIO_printf(Perl_debug_log, "%sGuessed:%s match at offset %ld\n",
			  PL_colors[4], PL_colors[5], (long)(s - i_strpos)) );
d948 9
a956 2
	    tmp = (I32)(s != startpos) ? utf8_to_uv(reghop((U8*)s, -1), 0) : '\n';
	    tmp = ((OP(c) == BOUNDUTF8 ? isALNUM_uni(tmp) : isALNUM_LC_uni(tmp)) != 0);
d991 9
a999 2
	    tmp = (I32)(s != startpos) ? utf8_to_uv(reghop((U8*)s, -1), 0) : '\n';
	    tmp = ((OP(c) == NBOUNDUTF8 ? isALNUM_uni(tmp) : isALNUM_LC_uni(tmp)) != 0);
a1356 1
    dTHR;
d1518 4
d1525 1
d1537 1
d1546 3
d1564 3
d1585 1
d1611 8
d1627 1
d1660 6
a1665 1
	    if (last == NULL) goto phooey; /* Should not happen! */
d1727 2
a1739 1
    dTHR;
d1745 3
d1819 13
a1831 1
       this!  */
d1835 1
a1835 1
	for (i = prog->nparens; i >= 1; i--) {
d1840 2
a1841 1
    REGCP_SET;
d1846 1
a1846 1
    REGCP_UNWIND;
d1850 30
a1896 1
    dTHR;
d1908 3
d1920 1
a1920 1
#ifdef DEBUGGING
d2000 1
a2000 1
	    if (locinput == PL_regbol && PL_regprev == '\n')
d2089 4
a2092 3
		    if (utf8_to_uv((U8*)s, 0) != (c1 ?
						  toLOWER_utf8((U8*)l) :
						  toLOWER_LC_utf8((U8*)l)))
d2227 7
a2233 2
	    ln = (locinput != PL_regbol)
		? utf8_to_uv(reghop((U8*)locinput, -1), 0) : PL_regprev;
d2531 1
a2531 1
		    REGCP_SET;
d2561 1
a2561 1
		    REGCP_UNWIND;
d2688 2
d2695 5
a2699 1
		cc.parenfloor = *PL_reglastparen;
d2822 1
a2822 1
		    REGCP_SET;
d2827 1
a2827 1
		    REGCP_UNWIND;
d2854 1
a2854 1
		    REGCP_SET;
d2859 1
a2859 1
		    REGCP_UNWIND;
d2872 1
a2872 1
		    REGCP_SET;
d2877 1
a2877 1
		    REGCP_UNWIND;
d2923 21
a2943 1
		    int lastparen = *PL_reglastparen;
d2945 2
a2946 22
		    REGCP_SET;
		    do {
			PL_reginput = locinput;
			if (regmatch(inner))
			    sayYES;
			REGCP_UNWIND;
			for (n = *PL_reglastparen; n > lastparen; n--)
			    PL_regendp[n] = -1;
			*PL_reglastparen = n;
			scan = next;
			/*SUPPRESS 560*/
			if ((n = (c1 == BRANCH ? NEXT_OFF(next) : ARG(next))))
			    next += n;
			else
			    next = NULL;
			inner = NEXTOPER(scan);
			if (c1 == BRANCHJ) {
			    inner = NEXTOPER(inner);
			}
		    } while (scan != NULL && OP(scan) == c1);
		    sayNO;
		    /* NOTREACHED */
d2996 1
a2996 1
		REGCP_SET;
d3015 1
a3015 1
			REGCP_UNWIND;
d3055 1
a3055 1
		REGCP_SET;
d3077 1
a3077 1
			REGCP_UNWIND;
d3138 1
a3138 1
		REGCP_SET;
d3166 1
a3166 10
			if (paren) {
			    if (ln) {
				PL_regstartp[paren] = HOPc(locinput, -1) - PL_bostr;
				PL_regendp[paren] = locinput - PL_bostr;
			    }
			    else
				PL_regendp[paren] = -1;
			}
			if (regmatch(next))
			    sayYES;
d3168 1
a3168 1
			REGCP_UNWIND;
d3180 2
a3181 11
			if (paren) {
			    if (n) {
				PL_regstartp[paren] = HOPc(PL_reginput, -1) - PL_bostr;
				PL_regendp[paren] = PL_reginput - PL_bostr;
			    }
			    else
				PL_regendp[paren] = -1;
			}
			if (regmatch(next))
			    sayYES;
			REGCP_UNWIND;
d3206 1
a3206 1
		REGCP_SET;
d3214 2
a3215 11
				if (paren && n) {
				    if (n) {
					PL_regstartp[paren] = HOPc(PL_reginput, -1) - PL_bostr;
					PL_regendp[paren] = PL_reginput - PL_bostr;
				    }
				    else
					PL_regendp[paren] = -1;
				}
				if (regmatch(next))
				    sayYES;
				REGCP_UNWIND;
d3229 2
a3230 3
				if (regmatch(next))
				    sayYES;
				REGCP_UNWIND;
d3248 1
a3248 1
		REGCP_SET;
d3261 1
a3261 1
		REGCP_UNWIND;
d3368 1
d3394 5
d3410 49
a3475 1
    dTHR;
a3686 1
    dTHR;
a3736 1
    dTHR;
d3783 5
a3787 1
	    (ANYOF_CLASS_TEST(p, ANYOF_NXDIGIT) && !isXDIGIT(c))
a3799 1
    dTHR;
d3802 8
a3809 1
    SV *sv = (SV*)PL_regdata->data[ARG2(f)];
d3811 1
a3811 1
    if (swash_fetch(sv, p))
d3814 1
a3814 1
	U8 tmpbuf[UTF8_MAXLEN];
d3821 1
a3821 1
	if (swash_fetch(sv, tmpbuf))
a3832 1
    dTHR;
a3853 1
    dTHR;
a3884 1
    dTHR;
a3895 1

@


1.3
log
@perl5.005_03 (stock)
@
text
@d28 1
a28 1
#  ifndef DEBUGGING
d38 1
d41 3
d69 1
a69 1
 ****    Copyright (c) 1991-1999, Larry Wall
d79 1
d81 7
d93 3
a103 3
#ifndef PERL_OBJECT
typedef I32 CHECKPOINT;

d108 15
a122 10
static I32 regmatch _((regnode *prog));
static I32 regrepeat _((regnode *p, I32 max));
static I32 regrepeat_hard _((regnode *p, I32 max, I32 *lp));
static I32 regtry _((regexp *prog, char *startpos));

static bool reginclass _((char *p, I32 c));
static CHECKPOINT regcppush _((I32 parenfloor));
static char * regcppop _((void));
#endif
#define REGINCLASS(p,c)  (*(p) ? reginclass(p,c) : ANYOF_TEST(p,c))
d125 1
a125 1
regcppush(I32 parenfloor)
d134 2
a135 2
	SSPUSHPTR(PL_regendp[p]);
	SSPUSHPTR(PL_regstartp[p]);
d149 2
a150 2
			     "  Setting an EVAL scope, savestack=%i\n",	\
			     PL_savestack_ix)); lastcp = PL_savestack_ix
d154 2
a155 2
				"  Clearing an EVAL scope, savestack=%i..%i\n", \
				lastcp, PL_savestack_ix) : 0); regcpblow(lastcp)
d158 1
a158 1
regcppop(void)
d164 1
a164 1
    char *tmps;
d173 2
a174 2
	PL_regstartp[paren] = (char *) SSPOPPTR;
	tmps = (char*)SSPOPPTR;
d179 4
a182 4
			  "     restoring \\%d to %d(%d)..%d%s\n",
			  paren, PL_regstartp[paren] - PL_regbol, 
			  PL_reg_start_tmp[paren] - PL_regbol,
			  PL_regendp[paren] - PL_regbol, 
d189 2
a190 2
			  "     restoring \\%d..\\%d to undef\n",
			  *PL_reglastparen + 1, PL_regnpar);
d195 2
a196 2
	    PL_regstartp[paren] = Nullch;
	PL_regendp[paren] = Nullch;
d201 21
d232 1
a232 1
pregexec(register regexp *prog, char *stringarg, register char *strend,
d243 3
a245 12
  
/*
 - regexec_flags - match a regexp against a string
 */
I32
regexec_flags(register regexp *prog, char *stringarg, register char *strend,
	      char *strbeg, I32 minend, SV *screamer, void *data, U32 flags)
/* strend: pointer to null at end of string */
/* strbeg: real beginning of string */
/* minend: end of match must be >=minend after stringarg. */
/* data: May be used for some additional optimizations. */
/* nosave: For optimizations. */
d248 1
a248 19
    register char *s;
    register regnode *c;
    register char *startpos = stringarg;
    register I32 tmp;
    I32 minlen;		/* must match at least this many chars */
    I32 dontbother = 0;	/* how many characters not to try at end */
    CURCUR cc;
    I32 start_shift = 0;		/* Offset of the start to find
					 constant substr. */
    I32 end_shift = 0;			/* Same for the end. */
    I32 scream_pos = -1;		/* Internal iterator of scream. */
    char *scream_olds;
    SV* oreplsv = GvSV(PL_replgv);

    cc.cur = 0;
    cc.oldcc = 0;
    PL_regcc = &cc;

    PL_regprecomp = prog->precomp;		/* Needed for error messages. */
a249 1
    PL_regnarrate = PL_debug & 512;
d252 18
d271 6
a276 5
    /* Be paranoid... */
    if (prog == NULL || startpos == NULL) {
	croak("NULL regexp parameter");
	return 0;
    }
d278 20
a297 2
    minlen = prog->minlen;
    if (strend - startpos < minlen) goto phooey;
d299 21
a319 7
    if (startpos == strbeg)	/* is ^ valid at stringarg? */
	PL_regprev = '\n';
    else {
	PL_regprev = stringarg[-1];
	if (!PL_multiline && PL_regprev == '\n')
	    PL_regprev = '\0';		/* force ^ to NOT match */
    }
d321 12
a332 4
    /* Check validity of program. */
    if (UCHARAT(prog->program) != MAGIC) {
	FAIL("corrupted regexp program");
    }
d334 54
a387 3
    PL_regnpar = prog->nparens;
    PL_reg_flags = 0;
    PL_reg_eval_set = 0;
d389 8
a396 9
    /* If there is a "must appear" string, look for it. */
    s = startpos;
    if (!(flags & REXEC_CHECKED) 
	&& prog->check_substr != Nullsv &&
	!(prog->reganch & ROPT_ANCH_GPOS) &&
	(!(prog->reganch & (ROPT_ANCH_BOL | ROPT_ANCH_MBOL))
	 || (PL_multiline && prog->check_substr == prog->anchored_substr)) )
    {
	start_shift = prog->check_offset_min;
d398 2
a399 28
	end_shift = minlen - start_shift - SvCUR(prog->check_substr);
	if (screamer) {
	    if (PL_screamfirst[BmRARE(prog->check_substr)] >= 0)
		    s = screaminstr(screamer, prog->check_substr, 
				    start_shift + (stringarg - strbeg),
				    end_shift, &scream_pos, 0);
	    else
		    s = Nullch;
	    scream_olds = s;
	}
	else
	    s = fbm_instr((unsigned char*)s + start_shift,
			  (unsigned char*)strend - end_shift,
		prog->check_substr, 0);
	if (!s) {
	    ++BmUSEFUL(prog->check_substr);	/* hooray */
	    goto phooey;	/* not present */
	} else if ((s - stringarg) > prog->check_offset_max) {
	    ++BmUSEFUL(prog->check_substr);	/* hooray/2 */
	    s -= prog->check_offset_max;
	} else if (!prog->naughty 
		   && --BmUSEFUL(prog->check_substr) < 0
		   && prog->check_substr == prog->float_substr) { /* boo */
	    SvREFCNT_dec(prog->check_substr);
	    prog->check_substr = Nullsv;	/* disable */
	    prog->float_substr = Nullsv;	/* clear */
	    s = startpos;
	} else s = startpos;
d402 4
a405 3
    /* Mark beginning of line for ^ and lookbehind. */
    PL_regbol = startpos;
    PL_bostr  = strbeg;
d407 62
a468 2
    /* Mark end of line for $ (and such) */
    PL_regeol = strend;
d470 54
a523 32
    /* see how far we have to get to not match where we matched before */
    PL_regtill = startpos+minend;

    DEBUG_r(
	PerlIO_printf(Perl_debug_log, 
		      "Matching `%.60s%s' against `%.*s%s'\n",
		      prog->precomp, 
		      (strlen(prog->precomp) > 60 ? "..." : ""),
		      (strend - startpos > 60 ? 60 : strend - startpos),
		      startpos, 
		      (strend - startpos > 60 ? "..." : ""))
	);

    /* Simplest case:  anchored match need be tried only once. */
    /*  [unless only anchor is BOL and multiline is set] */
    if (prog->reganch & ROPT_ANCH) {
	if (regtry(prog, startpos))
	    goto got_it;
	else if (!(prog->reganch & ROPT_ANCH_GPOS) &&
		 (PL_multiline || (prog->reganch & ROPT_IMPLICIT)
		  || (prog->reganch & ROPT_ANCH_MBOL)))
	{
	    if (minlen)
		dontbother = minlen - 1;
	    strend -= dontbother;
	    /* for multiline we only have to try after newlines */
	    if (s > startpos)
		s--;
	    while (s < strend) {
		if (*s++ == '\n') {
		    if (s < strend && regtry(prog, s))
			goto got_it;
d527 50
a576 1
	goto phooey;
d579 89
a667 13
    /* Messy cases:  unanchored match. */
    if (prog->anchored_substr && prog->reganch & ROPT_SKIP) { 
	/* we have /x+whatever/ */
	/* it must be a one character string */
	char ch = SvPVX(prog->anchored_substr)[0];
	while (s < strend) {
	    if (*s == ch) {
		if (regtry(prog, s)) goto got_it;
		s++;
		while (s < strend && *s == ch)
		    s++;
	    }
	    s++;
d669 2
a671 13
    /*SUPPRESS 560*/
    else if (prog->anchored_substr != Nullsv
	     || (prog->float_substr != Nullsv 
		 && prog->float_max_offset < strend - s)) {
	SV *must = prog->anchored_substr 
	    ? prog->anchored_substr : prog->float_substr;
	I32 back_max = 
	    prog->anchored_substr ? prog->anchored_offset : prog->float_max_offset;
	I32 back_min = 
	    prog->anchored_substr ? prog->anchored_offset : prog->float_min_offset;
	I32 delta = back_max - back_min;
	char *last = strend - SvCUR(must) - back_min; /* Cannot start after this */
	char *last1 = s - 1;		/* Last position checked before */
d673 104
a776 16
	/* XXXX check_substr already used to find `s', can optimize if
	   check_substr==must. */
	scream_pos = -1;
	dontbother = end_shift;
	strend -= dontbother;
	while ( (s <= last) &&
		(screamer 
		 ? (s = screaminstr(screamer, must, s + back_min - strbeg,
				    end_shift, &scream_pos, 0))
		 : (s = fbm_instr((unsigned char*)s + back_min,
				  (unsigned char*)strend, must, 0))) ) {
	    if (s - back_max > last1) {
		last1 = s - back_min;
		s = s - back_max;
	    } else {
		char *t = last1 + 1;		
d778 4
a781 11
		last1 = s - back_min;
		s = t;		
	    }
	    while (s <= last1) {
		if (regtry(prog, s))
		    goto got_it;
		s++;
	    }
	}
	goto phooey;
    } else if (c = prog->regstclass) {
d783 6
a788 1
	char *Class;
a789 4
	if (minlen)
	    dontbother = minlen - 1;
	strend -= dontbother;	/* don't bother with what can't match */
	tmp = 1;
d792 13
a805 1
	    Class = (char *) OPERAND(c);
d807 2
a808 2
		if (REGINCLASS(Class, *s)) {
		    if (tmp && regtry(prog, s))
d818 39
d861 1
a861 3
	    if (minlen)
		dontbother++,strend--;
	    tmp = (s != startpos) ? UCHARAT(s - 1) : PL_regprev;
d866 1
a866 1
		    if (regtry(prog, s))
d871 21
a891 1
	    if ((minlen || tmp) && regtry(prog,s))
d898 1
a898 3
	    if (minlen)
		dontbother++,strend--;
	    tmp = (s != startpos) ? UCHARAT(s - 1) : PL_regprev;
d903 1
a903 1
		else if (regtry(prog, s))
d907 19
a925 1
	    if ((minlen || !tmp) && regtry(prog,s))
d931 1
a931 1
		    if (tmp && regtry(prog, s))
d941 1
a941 2
	case ALNUML:
	    PL_reg_flags |= RF_tainted;
d943 2
a944 2
		if (isALNUM_LC(*s)) {
		    if (tmp && regtry(prog, s))
d951 1
a951 1
		s++;
d954 2
a955 1
	case NALNUM:
d957 2
a958 2
		if (!isALNUM(*s)) {
		    if (tmp && regtry(prog, s))
d968 1
a968 1
	case NALNUML:
d971 2
a972 2
		if (!isALNUM_LC(*s)) {
		    if (tmp && regtry(prog, s))
d979 1
a979 1
		s++;
d982 1
a982 1
	case SPACE:
d984 2
a985 2
		if (isSPACE(*s)) {
		    if (tmp && regtry(prog, s))
d995 1
a995 2
	case SPACEL:
	    PL_reg_flags |= RF_tainted;
d997 2
a998 2
		if (isSPACE_LC(*s)) {
		    if (tmp && regtry(prog, s))
d1005 1
a1005 1
		s++;
d1008 2
a1009 1
	case NSPACE:
d1011 2
a1012 2
		if (!isSPACE(*s)) {
		    if (tmp && regtry(prog, s))
d1022 1
a1022 1
	case NSPACEL:
d1025 2
a1026 2
		if (!isSPACE_LC(*s)) {
		    if (tmp && regtry(prog, s))
d1033 1
a1033 1
		s++;
d1036 1
a1036 1
	case DIGIT:
d1038 2
a1039 2
		if (isDIGIT(*s)) {
		    if (tmp && regtry(prog, s))
d1049 1
a1049 1
	case NDIGIT:
d1051 2
a1052 2
		if (!isDIGIT(*s)) {
		    if (tmp && regtry(prog, s))
d1059 1
a1059 1
		s++;
d1062 193
d1256 267
a1527 1
	    I32 oldpos = scream_pos;
d1529 2
a1530 2
	    if (screamer) {
		last = screaminstr(screamer, prog->float_substr, s - strbeg,
d1532 1
a1532 1
		if (!last) {
d1534 2
a1535 2
		}
	    } else {
d1538 16
a1553 4
		if (len) 
		    last = rninstr(s, strend, little, little + len);
		else
		    last = strend;	/* matching `$' */
d1560 1
a1560 1
	strend -= dontbother;
d1562 15
a1576 4
	do {
	    if (regtry(prog, s))
		goto got_it;
	} while (s++ < strend);
a1582 2
    prog->subbeg = strbeg;
    prog->subend = PL_regeol;	/* strend may have been modified */
d1585 9
d1595 4
a1598 6
    if (strbeg != prog->subbase) {	/* second+ //g match.  */
	if (!(flags & REXEC_COPY_STR)) {
	    if (prog->subbase) {
		Safefree(prog->subbase);
		prog->subbase = Nullch;
	    }
d1600 1
a1600 1
	else {
d1602 1
d1604 7
a1610 11
	    Safefree(prog->subbase);
	    prog->subbase = s;
	    prog->subbeg = prog->subbase;
	    prog->subend = prog->subbase + i;
	    s = prog->subbase + (stringarg - strbeg);
	    for (i = 0; i <= prog->nparens; i++) {
		if (prog->endp[i]) {
		    prog->startp[i] = s + (prog->startp[i] - startpos);
		    prog->endp[i] = s + (prog->endp[i] - startpos);
		}
	    }
d1613 1
a1613 6
    /* Preserve the current value of $^R */
    if (oreplsv != GvSV(PL_replgv)) {
	sv_setsv(oreplsv, GvSV(PL_replgv));/* So that when GvSV(replgv) is
					   restored, the value remains
					   the same. */
    }
d1617 2
d1626 1
a1626 1
regtry(regexp *prog, char *startpos)
d1630 2
a1631 2
    register char **sp;
    register char **ep;
d1635 2
d1639 2
a1640 2
	    PerlIO_printf(Perl_debug_log, "  setting stack tmpbase at %i\n",
			  PL_stack_sp - PL_stack_base);
d1642 1
a1642 1
	SAVEINT(cxstack[cxstack_ix].blk_oldsp);
d1647 1
a1647 1
	/* SAVEINT(cxstack[cxstack_ix].blk_gimme);
d1649 37
d1687 1
d1694 1
d1703 3
a1707 1
    PL_regdata = prog->data;
d1709 3
a1711 3
	for (i = prog->nparens; i >= 0; i--) {
	    *sp++ = NULL;
	    *ep++ = NULL;
d1716 1
a1716 2
	prog->startp[0] = startpos;
	prog->endp[0] = PL_reginput;
d1738 1
a1738 1
regmatch(regnode *prog)
d1756 1
d1764 4
d1773 4
d1784 6
d1792 1
d1797 4
d1803 6
a1808 3
			  "%4i <%s%.*s%s%s%s%.*s%s>%*s|%3d:%*s%s\n",
			  locinput - PL_bostr, 
			  PL_colors[2], pref_len, locinput - pref_len, PL_colors[3],
d1813 1
a1813 1
			  scan - PL_regprogram, PL_regindent*2, "",
d1828 1
a1828 1
		/* PL_regtill = PL_regbol; */
d1845 1
a1845 1
	    if (locinput == PL_regbol)
d1869 12
d1886 14
a1899 2
	case ANY:
	    if (!nextchr && locinput >= PL_regeol || nextchr == '\n')
d1904 2
a1905 2
	    s = (char *) OPERAND(scan);
	    ln = UCHARAT(s++);
d1920 24
a1943 2
	    s = (char *) OPERAND(scan);
	    ln = UCHARAT(s++);
d1947 1
a1947 1
			       ? fold : fold_locale)[nextchr])
d1958 8
a1966 1
	    s = (char *) OPERAND(scan);
d1969 1
a1969 1
	    if (!REGINCLASS(s, nextchr))
d1986 22
d2019 22
d2050 123
a2172 6
		ln = isALNUM(ln);
		n = isALNUM(nextchr);
	    }
	    else {
		ln = isALNUM_LC(ln);
		n = isALNUM_LC(nextchr);
d2174 2
a2175 1
	    if (((!ln) == (!n)) == (OP(scan) == BOUND || OP(scan) == BOUNDL))
d2177 1
d2179 1
a2179 1
	case SPACEL:
d2182 1
a2182 1
	case SPACE:
d2185 2
a2186 2
	    if (!(OP(scan) == SPACE
		  ? isSPACE(nextchr) : isSPACE_LC(nextchr)))
d2190 1
a2190 1
	case NSPACEL:
d2193 2
a2194 2
	case NSPACE:
	    if (!nextchr)
d2196 13
a2208 7
	    if (OP(scan) == SPACE
		? isSPACE(nextchr) : isSPACE_LC(nextchr))
		sayNO;
	    nextchr = UCHARAT(++locinput);
	    break;
	case DIGIT:
	    if (!isDIGIT(nextchr))
d2212 2
a2213 2
	case NDIGIT:
	    if (!nextchr && locinput >= PL_regeol)
d2215 4
a2218 1
	    if (isDIGIT(nextchr))
d2220 1
a2220 1
	    nextchr = UCHARAT(++locinput);
d2228 3
a2230 2
	    s = PL_regstartp[n];
	    if (*PL_reglastparen < n || !s)
d2232 34
a2265 1
	    if (s == PL_regendp[n])
d2267 2
d2273 1
a2273 1
				  ? fold : fold_locale)[nextchr]))))
d2275 1
a2275 1
	    ln = PL_regendp[n] - s;
d2303 3
a2305 2
	    DEBUG_r( PerlIO_printf(Perl_debug_log, "  re_eval 0x%x\n", PL_op) );
	    PL_curpad = AvARRAY((AV*)PL_regdata->data[n + 1]);
d2307 1
a2307 1
	    CALLRUNOPS();			/* Scalar context. */
d2312 3
d2316 93
d2410 2
a2411 2
		sw = SvTRUE(ret);
	    } else
a2412 3
	    PL_op = oop;
	    PL_curpad = ocurpad;
	    PL_curcop = ocurcop;
d2423 2
a2424 2
	    PL_regstartp[n] = PL_reg_start_tmp[n];
	    PL_regendp[n] = locinput;
d2430 1
a2430 1
	    sw = (*PL_reglastparen >= n && PL_regendp[n] != NULL);
d2433 1
d2443 1
a2443 1
	    logical = 1;
d2445 75
d2547 1
a2547 1
		 * the RE is going to match for sure, and to do that we have
d2572 2
a2573 1
		    ln = PL_regcc->cur;
d2581 2
a2582 6
		    DEBUG_r(
			PerlIO_printf(Perl_debug_log,
				      "%*s  failed...\n",
				      REPORT_CODE_OFF+PL_regindent*2, "")
			);
		    PL_regcc->cur = ln;
d2596 37
d2635 1
a2635 1
				      "%*s  failed...\n",
d2638 4
a2641 1
		    sayNO;
d2648 2
a2649 1
		    ln = PL_regcc->cur;
d2658 2
a2659 1
		    PL_regcc->cur = ln;
d2663 1
a2663 1
			if (PL_dowarn && n >= REG_INFTY 
d2666 1
a2666 1
			    warn("%s limit (%d) exceeded",
a2687 5
		    DEBUG_r(
			PerlIO_printf(Perl_debug_log,
				      "%*s  failed...\n",
				      REPORT_CODE_OFF+PL_regindent*2, "")
			);
d2715 2
a2716 1
		if (PL_dowarn && n >= REG_INFTY && !(PL_reg_flags & RF_warned)) {
d2718 1
a2718 1
		    warn("%s limit (%d) exceeded",
d2725 2
a2726 1
		ln = PL_regcc->cur;
d2729 2
a2730 5
		DEBUG_r(
		    PerlIO_printf(Perl_debug_log, "%*s  failed...\n",
				  REPORT_CODE_OFF+PL_regindent*2, "")
		    );
		PL_regcc->cur = ln;
d2761 1
a2761 1
			    PL_regendp[n] = 0;
d2765 1
a2765 1
			if (n = (c1 == BRANCH ? NEXT_OFF(next) : ARG(next)))
d2814 2
a2815 2
		if (regkind[(U8)OP(next)] == EXACT) {
		    c1 = UCHARAT(OPERAND(next) + 1);
d2817 1
a2817 1
			c2 = fold[c1];
d2819 1
a2819 1
			c2 = fold_locale[c1];
d2822 2
a2823 1
		} else
d2835 6
a2840 4
				PL_regstartp[paren] = PL_reginput - l;
				PL_regendp[paren] = PL_reginput;
			    } else
				PL_regendp[paren] = NULL;
d2855 2
a2856 1
	    } else {
d2867 3
a2869 2
				  "%*s  matched %ld times, len=%ld...\n",
				  REPORT_CODE_OFF+PL_regindent*2, "", n, l)
d2872 2
a2873 2
		    if (regkind[(U8)OP(next)] == EXACT) {
			c1 = UCHARAT(OPERAND(next) + 1);
d2875 1
a2875 1
			    c2 = fold[c1];
d2877 1
a2877 1
			    c2 = fold_locale[c1];
d2880 2
a2881 1
		    } else
d2890 2
a2891 2
			{
			    DEBUG_r(
d2893 7
a2899 9
					      "%*s  trying tail with n=%ld...\n",
					      REPORT_CODE_OFF+PL_regindent*2, "", n)
				);
			    if (paren) {
				if (n) {
				    PL_regstartp[paren] = PL_reginput - l;
				    PL_regendp[paren] = PL_reginput;
				} else
				    PL_regendp[paren] = NULL;
d2901 2
a2902 3
			    if (regmatch(next))
				sayYES;
			    REGCP_UNWIND;
d2904 4
d2910 1
a2910 1
		    locinput -= l;
d2949 2
a2950 2
	    if (regkind[(U8)OP(next)] == EXACT) {
		c1 = UCHARAT(OPERAND(next) + 1);
d2952 1
a2952 1
		    c2 = fold[c1];
d2954 1
a2954 1
		    c2 = fold_locale[c1];
d2966 1
d2968 44
d3020 5
a3024 4
				PL_regstartp[paren] = PL_reginput - 1;
				PL_regendp[paren] = PL_reginput;
			    } else
				PL_regendp[paren] = NULL;
d3031 1
a3031 1
		    PL_reginput = locinput + ln;
d3034 3
a3036 2
			PL_reginput = locinput + ln;
		    } else
d3043 3
a3045 2
		if (ln < n && regkind[(U8)OP(next)] == EOL &&
		    (!PL_multiline  || OP(next) == SEOL))
d3047 6
d3063 5
a3067 4
					PL_regstartp[paren] = PL_reginput - 1;
					PL_regendp[paren] = PL_reginput;
				    } else
					PL_regendp[paren] = NULL;
d3075 1
a3075 1
			PL_reginput = locinput + n;
d3077 2
a3078 1
		} else {
d3091 1
a3091 1
			PL_reginput = locinput + n;
d3098 45
a3142 3
	    if (locinput < PL_regtill)
		sayNO;			/* Cannot match: too short. */
	    /* Fall through */
d3145 1
a3145 1
	    sayYES;			/* Success! */
d3152 18
a3169 2
	    if (locinput < PL_bostr + scan->flags) 
		goto say_yes;
d3173 19
a3191 2
	    if (locinput < PL_bostr + scan->flags) 
		goto say_no;
a3192 1
	    PL_reginput = locinput - scan->flags;
d3200 2
a3201 1
		} else
d3221 3
a3223 3
	    PerlIO_printf(PerlIO_stderr(), "%lx %d\n",
			  (unsigned long)scan, OP(scan));
	    FAIL("regexp memory corruption");
d3232 1
a3232 1
    FAIL("corrupted regexp pointers");
d3236 10
d3253 8
d3273 1
a3273 1
 * rather than incrementing count on every character.]
d3276 1
a3276 1
regrepeat(regnode *p, I32 max)
a3279 1
    register char *opnd;
d3282 1
a3286 1
    opnd = (char *) OPERAND(p);
d3288 1
a3288 1
    case ANY:
d3295 14
d3310 1
a3310 1
	c = UCHARAT(++opnd);
d3315 1
a3315 1
	c = UCHARAT(++opnd);
d3317 1
a3317 1
	       (UCHARAT(scan) == c || UCHARAT(scan) == fold[c]))
d3322 1
a3322 1
	c = UCHARAT(++opnd);
d3324 1
a3324 1
	       (UCHARAT(scan) == c || UCHARAT(scan) == fold_locale[c]))
d3327 7
d3335 1
a3335 1
	while (scan < loceol && REGINCLASS(opnd, *scan))
d3342 7
d3354 9
d3367 7
d3379 8
d3391 7
d3403 8
d3415 7
d3427 8
d3439 8
d3451 7
d3462 4
a3465 1
    c = scan - PL_reginput;
d3474 2
a3475 2
			      "%*s  %s can match %ld times out of %ld...\n", 
			      REPORT_CODE_OFF+1, "", SvPVX(prop),c,max);
d3488 1
a3488 1
regrepeat_hard(regnode *p, I32 max, I32 *lp)
d3501 25
a3525 7
    while (PL_reginput < loceol && (scan = PL_reginput, res = regmatch(p))) {
	if (!count++) {
	    *lp = l = PL_reginput - start;
	    if (max != REG_INFTY && l*max < loceol - scan)
		loceol = scan + l*max;
	    if (l == 0)
		return max;
d3535 1
a3535 1
 - regclass - determine if a character falls into a character class
d3539 1
a3539 1
reginclass(register char *p, register I32 c)
d3542 1
a3542 1
    char flags = *p;
d3546 1
a3546 1
    if (ANYOF_TEST(p, c))
d3552 1
a3552 1
	    cf = fold_locale[c];
d3555 2
a3556 2
	    cf = fold[c];
	if (ANYOF_TEST(p, cf))
d3560 1
a3560 1
    if (!match && (flags & ANYOF_ISA)) {
d3562 28
a3589 5

	if (((flags & ANYOF_ALNUML)  && isALNUM_LC(c))  ||
	    ((flags & ANYOF_NALNUML) && !isALNUM_LC(c)) ||
	    ((flags & ANYOF_SPACEL)  && isSPACE_LC(c))  ||
	    ((flags & ANYOF_NSPACEL) && !isSPACE_LC(c)))
d3598 80
d3679 15
@


1.2
log
@perl 5.004_04
@
text
@d22 20
d65 1
a65 1
 ****    Copyright (c) 1991-1997, Larry Wall
d78 7
d89 2
a90 4
#ifdef DEBUGGING
static I32 regnarrate = 0;
static char* regprogram = 0;
#endif
d92 3
a94 13
/* Current curly descriptor */
typedef struct curcur CURCUR;
struct curcur {
    int		parenfloor;	/* how far back to strip paren data */
    int		cur;		/* how many instances of scan we've matched */
    int		min;		/* the minimal number of scans to match */
    int		max;		/* the maximal number of scans to match */
    int		minmod;		/* whether to work our way up or down */
    char *	scan;		/* the thing to match */
    char *	next;		/* what has to match after it */
    char *	lastloc;	/* where we started matching this scan */
    CURCUR *	oldcc;		/* current curly before we started this one */
};
d96 4
a99 3
static CURCUR* regcc;

typedef I32 CHECKPOINT;
d101 1
d104 2
d107 2
a108 3
static CHECKPOINT
regcppush(parenfloor)
I32 parenfloor;
d110 3
a112 2
    int retval = savestack_ix;
    int i = (regsize - parenfloor) * 3;
d116 4
a119 3
    for (p = regsize; p > parenfloor; p--) {
	SSPUSHPTR(regendp[p]);
	SSPUSHPTR(regstartp[p]);
d122 3
a124 3
    SSPUSHINT(regsize);
    SSPUSHINT(*reglastparen);
    SSPUSHPTR(reginput);
d130 12
a141 2
static char *
regcppop()
d143 1
d151 3
a153 3
    *reglastparen = SSPOPINT;
    regsize = SSPOPINT;
    for (i -= 3; i > 0; i -= 3) {
d155 2
a156 1
	regstartp[paren] = (char *) SSPOPPTR;
d158 10
a167 2
	if (paren <= *reglastparen)
	    regendp[paren] = tmps;
d169 11
a179 4
    for (paren = *reglastparen + 1; paren <= regnpar; paren++) {
	if (paren > regsize)
	    regstartp[paren] = Nullch;
	regendp[paren] = Nullch;
d184 1
a184 31
/* After a successful match in WHILEM, we want to restore paren matches
 * that have been overwritten by a failed match attempt in the process
 * of reaching this success. We do this by restoring regstartp[i]
 * wherever regendp[i] has not changed; if OPEN is changed to modify
 * regendp[], the '== endp' test below should be changed to match.
 * This corrects the error of:
 *	0 > length [ "foobar" =~ / ( (foo) | (bar) )* /x ]->[1]
 */
static void
regcppartblow(base)
I32 base;
{
    I32 i = SSPOPINT;
    U32 paren;
    char *startp;
    char *endp;
    assert(i == SAVEt_REGCONTEXT);
    i = SSPOPINT;
    /* input, lastparen, size */
    SSPOPPTR; SSPOPINT; SSPOPINT;
    for (i -= 3; i > 0; i -= 3) {
	paren = (U32)SSPOPINT;
	startp = (char *) SSPOPPTR;
	endp = (char *) SSPOPPTR;
	if (paren <= *reglastparen && regendp[paren] == endp)
	    regstartp[paren] = startp;
    }
    assert(savestack_ix == base);
}

#define regcpblow(cp) leave_scope(cp)
d191 1
a191 1
 * Forwards.
d193 13
a205 8

static I32 regmatch _((char *prog));
static I32 regrepeat _((char *p, I32 max));
static I32 regtry _((regexp *prog, char *startpos));
static bool reginclass _((char *p, I32 c));

static bool regtainted;		/* tainted information used? */

d207 1
a207 1
 - pregexec - match a regexp against a string
d210 7
a216 8
pregexec(prog, stringarg, strend, strbeg, minend, screamer, safebase)
register regexp *prog;
char *stringarg;
register char *strend;	/* pointer to null at end of string */
char *strbeg;	/* real beginning of string */
I32 minend;	/* end of match must be at least minend after stringarg */
SV *screamer;
I32 safebase;	/* no need to remember string in subbase */
d218 1
d220 1
a220 1
    register char *c;
d223 1
a223 1
    I32 minlen = 0;		/* must match at least this many chars */
d226 6
d235 1
a235 1
    regcc = &cc;
d237 1
d239 2
a240 2
    regnarrate = debug & 512;
    regprogram = prog->program;
d249 3
d253 1
a253 1
	regprev = '\n';
d255 3
a257 3
	regprev = stringarg[-1];
	if (!multiline && regprev == '\n')
	    regprev = '\0';		/* force ^ to NOT match */
a259 1
    regprecomp = prog->precomp;
d265 3
a267 2
    regnpar = prog->nparens;
    regtainted = FALSE;
d271 2
a272 1
    if (prog->regmust != Nullsv &&
d274 2
a275 2
	(!(prog->reganch & ROPT_ANCH_BOL)
	 || (multiline && prog->regback >= 0)) )
d277 8
a284 3
	if (stringarg == strbeg && screamer) {
	    if (screamfirst[BmRARE(prog->regmust)] >= 0)
		    s = screaminstr(screamer,prog->regmust);
d287 1
d290 3
a292 2
	    s = fbm_instr((unsigned char*)s, (unsigned char*)strend,
		prog->regmust);
d294 1
a294 1
	    ++BmUSEFUL(prog->regmust);	/* hooray */
d296 9
a304 10
	}
	else if (prog->regback >= 0) {
	    s -= prog->regback;
	    if (s < startpos)
		s = startpos;
	    minlen = prog->regback + SvCUR(prog->regmust);
	}
	else if (!prog->naughty && --BmUSEFUL(prog->regmust) < 0) { /* boo */
	    SvREFCNT_dec(prog->regmust);
	    prog->regmust = Nullsv;	/* disable regmust */
d306 1
a306 5
	}
	else {
	    s = startpos;
	    minlen = SvCUR(prog->regmust);
	}
d309 3
a311 2
    /* Mark beginning of line for ^ . */
    regbol = startpos;
d314 1
a314 1
    regeol = strend;
d317 11
a327 1
    regtill = startpos+minend;
d335 2
a336 1
		 (multiline || (prog->reganch & ROPT_IMPLICIT)))
d355 9
a363 8
    if (prog->regstart) {
	if (prog->reganch & ROPT_SKIP) {  /* we have /x+whatever/ */
	    /* it must be a one character string */
	    char ch = SvPVX(prog->regstart)[0];
	    while (s < strend) {
		if (*s == ch) {
		    if (regtry(prog, s))
			goto got_it;
a364 4
		    while (s < strend && *s == ch)
			s++;
		}
		s++;
d366 1
d368 34
a401 8
	else if (SvTYPE(prog->regstart) == SVt_PVBM) {
	    /* We know what string it must start with. */
	    while ((s = fbm_instr((unsigned char*)s,
	      (unsigned char*)strend, prog->regstart)) != NULL)
	    {
		if (regtry(prog, s))
		    goto got_it;
		s++;
d403 1
a403 5
	}
	else {				/* Optimized fbm_instr: */
	    c = SvPVX(prog->regstart);
	    while ((s = ninstr(s, strend, c, c + SvCUR(prog->regstart))) != NULL)
	    {
d410 1
a410 3
    }
    /*SUPPRESS 560*/
    if (c = prog->regstclass) {
d412 1
d421 1
a421 1
	    c = OPERAND(c);
d423 1
a423 1
		if (reginclass(c, *s)) {
d435 1
a435 1
	    regtainted = TRUE;
d440 1
a440 1
	    tmp = (s != startpos) ? UCHARAT(s - 1) : regprev;
d454 1
a454 1
	    regtainted = TRUE;
d459 1
a459 1
	    tmp = (s != startpos) ? UCHARAT(s - 1) : regprev;
d485 1
a485 1
	    regtainted = TRUE;
d512 1
a512 1
	    regtainted = TRUE;
d539 1
a539 1
	    regtainted = TRUE;
d566 1
a566 1
	    regtainted = TRUE;
d608 23
a630 1
	if (minlen)
a643 1
    strend += dontbother;	/* uncheat */
d645 2
a646 2
    prog->subend = strend;
    prog->exec_tainted = regtainted;
d649 2
a650 2
    if (strbeg != prog->subbase) {
	if (safebase) {
d657 1
a657 1
	    I32 i = strend - startpos + (stringarg - strbeg);
d672 6
d687 2
a688 4
static I32			/* 0 failure, 1 success */
regtry(prog, startpos)
regexp *prog;
char *startpos;
d690 1
d694 1
d696 18
a713 4
    reginput = startpos;
    regstartp = prog->startp;
    regendp = prog->endp;
    reglastparen = &prog->lastparen;
d715 8
a722 1
    regsize = 0;
d726 1
d733 2
a734 1
    if (regmatch(prog->program + 1) && reginput >= regtill) {
d736 1
a736 1
	prog->endp[0] = reginput;
d739 2
a740 2
    else
	return 0;
d757 2
a758 3
static I32			/* 0 failure, 1 success */
regmatch(prog)
char *prog;
d760 6
a765 3
    register char *scan;	/* Current node. */
    char *next;			/* Next node. */
    register I32 nextchar;
d769 3
a771 3
    register char *locinput = reginput;
    register I32 c1, c2;	/* case fold search */
    int minmod = 0;
d773 1
a773 2
    static int regindent = 0;
    regindent++;
d776 1
a776 1
    nextchar = UCHARAT(locinput);
d779 1
d781 10
a790 4
#define sayYES goto yes
#define sayNO goto no
#define saySAME(x) if (x) goto yes; else goto no
	if (regnarrate) {
d792 9
d802 11
a812 9
	    PerlIO_printf(Perl_debug_log, "%*s%2ld%-8.8s\t<%.10s>\n",
			  regindent*2, "", (long)(scan - regprogram),
			  SvPVX(prop), locinput);
	}
#else
#define sayYES return 1
#define sayNO return 0
#define saySAME(x) return x
#endif
d814 1
a814 2
#ifdef REGALIGN
	next = scan + NEXT(scan);
a816 3
#else
	next = regnext(scan);
#endif
d820 4
a823 3
	    if (locinput == regbol
		? regprev == '\n'
		: ((nextchar || locinput < regeol) && locinput[-1] == '\n') )
d825 1
a825 1
		/* regtill = regbol; */
d830 3
a832 3
	    if (locinput == regbol
		? regprev == '\n'
		: ((nextchar || locinput < regeol) && locinput[-1] == '\n') )
d838 1
a838 1
	    if (locinput == regbol && regprev == '\n')
d842 1
a842 1
	    if (locinput == regbol)
d846 1
a846 1
	    if (multiline)
d852 1
a852 1
	    if ((nextchar || locinput < regeol) && nextchar != '\n')
d857 1
a857 1
	    if ((nextchar || locinput < regeol) && nextchar != '\n')
d859 5
a863 1
	    if (regeol - locinput > 1)
d867 1
a867 1
	    if (!nextchar && locinput >= regeol)
d869 1
a869 1
	    nextchar = UCHARAT(++locinput);
d872 1
a872 1
	    if (!nextchar && locinput >= regeol || nextchar == '\n')
d874 1
a874 1
	    nextchar = UCHARAT(++locinput);
d877 2
a878 2
	    s = OPERAND(scan);
	    ln = *s++;
d880 1
a880 1
	    if (UCHARAT(s) != nextchar)
d882 1
a882 1
	    if (regeol - locinput < ln)
d887 1
a887 1
	    nextchar = UCHARAT(locinput);
d890 1
a890 1
	    regtainted = TRUE;
d893 2
a894 2
	    s = OPERAND(scan);
	    ln = *s++;
d896 1
a896 1
	    if (UCHARAT(s) != nextchar &&
d898 1
a898 1
			       ? fold : fold_locale)[nextchar])
d900 1
a900 1
	    if (regeol - locinput < ln)
d907 1
a907 1
	    nextchar = UCHARAT(locinput);
d910 4
a913 4
	    s = OPERAND(scan);
	    if (nextchar < 0)
		nextchar = UCHARAT(locinput);
	    if (!reginclass(s, nextchar))
d915 1
a915 1
	    if (!nextchar && locinput >= regeol)
d917 1
a917 1
	    nextchar = UCHARAT(++locinput);
d920 1
a920 1
	    regtainted = TRUE;
d923 1
a923 1
	    if (!nextchar)
d926 1
a926 1
		  ? isALNUM(nextchar) : isALNUM_LC(nextchar)))
d928 1
a928 1
	    nextchar = UCHARAT(++locinput);
d931 1
a931 1
	    regtainted = TRUE;
d934 1
a934 1
	    if (!nextchar && locinput >= regeol)
d937 1
a937 1
		? isALNUM(nextchar) : isALNUM_LC(nextchar))
d939 1
a939 1
	    nextchar = UCHARAT(++locinput);
d943 1
a943 1
	    regtainted = TRUE;
d948 1
a948 1
	    ln = (locinput != regbol) ? UCHARAT(locinput - 1) : regprev;
d951 1
a951 1
		n = isALNUM(nextchar);
d955 1
a955 1
		n = isALNUM_LC(nextchar);
d961 1
a961 1
	    regtainted = TRUE;
d964 1
a964 1
	    if (!nextchar && locinput >= regeol)
d967 1
a967 1
		  ? isSPACE(nextchar) : isSPACE_LC(nextchar)))
d969 1
a969 1
	    nextchar = UCHARAT(++locinput);
d972 1
a972 1
	    regtainted = TRUE;
d975 1
a975 1
	    if (!nextchar)
d978 1
a978 1
		? isSPACE(nextchar) : isSPACE_LC(nextchar))
d980 1
a980 1
	    nextchar = UCHARAT(++locinput);
d983 1
a983 1
	    if (!isDIGIT(nextchar))
d985 1
a985 1
	    nextchar = UCHARAT(++locinput);
d988 1
a988 1
	    if (!nextchar && locinput >= regeol)
d990 1
a990 1
	    if (isDIGIT(nextchar))
d992 1
a992 1
	    nextchar = UCHARAT(++locinput);
d995 1
a995 1
	    regtainted = TRUE;
d997 1
a997 1
	case REF:
d999 5
a1003 7
	    n = ARG1(scan);  /* which paren pair */
	    s = regstartp[n];
	    if (!s)
		sayNO;
	    if (!regendp[n])
		sayNO;
	    if (s == regendp[n])
d1006 1
a1006 1
	    if (UCHARAT(s) != nextchar &&
d1009 1
a1009 1
				 ? fold : fold_locale)[nextchar]))))
d1011 2
a1012 2
	    ln = regendp[n] - s;
	    if (locinput + ln > regeol)
d1021 1
a1021 1
	    nextchar = UCHARAT(locinput);
d1025 1
d1029 28
d1058 4
a1061 4
	    n = ARG1(scan);  /* which paren pair */
	    regstartp[n] = locinput;
	    if (n > regsize)
		regsize = n;
d1064 21
a1084 4
	    n = ARG1(scan);  /* which paren pair */
	    regendp[n] = locinput;
	    if (n > *reglastparen)
		*reglastparen = n;
d1088 7
a1094 4
		CHECKPOINT cp = savestack_ix;
		cc.oldcc = regcc;
		regcc = &cc;
		cc.parenfloor = *reglastparen;
d1098 1
a1098 1
		cc.scan = NEXTOPER(scan) + 4;
d1102 1
a1102 1
		reginput = locinput;
d1105 1
a1105 1
		regcc = cc.oldcc;
d1119 4
a1122 2
		CHECKPOINT cp;
		CURCUR* cc = regcc;
d1124 1
a1124 1
		reginput = locinput;
d1126 7
a1132 5
#ifdef DEBUGGING
		if (regnarrate)
		    PerlIO_printf(Perl_debug_log, "%*s  %ld  %lx\n", regindent*2, "",
			(long)n, (long)cc);
#endif
d1137 7
a1143 2
		    regcc = cc->oldcc;
		    ln = regcc->cur;
d1146 7
a1152 2
		    regcc->cur = ln;
		    regcc = cc;
d1164 6
d1176 2
a1177 2
		    regcc = cc->oldcc;
		    ln = regcc->cur;
d1179 1
d1181 1
a1181 1
			regcppartblow(cp);
d1184 1
d1186 2
a1187 2
		    regcc->cur = ln;
		    regcc = cc;
d1189 8
a1196 1
		    if (n >= cc->max)	/* Maximum greed exceeded? */
d1198 1
d1200 5
d1206 1
a1206 1
		    reginput = locinput;
d1210 1
d1212 1
a1212 1
			regcppartblow(cp);
d1215 6
d1223 1
d1233 1
d1235 1
a1235 1
			regcppartblow(cp);
d1238 1
d1240 12
a1251 1
		    reginput = locinput;
d1255 2
a1256 2
		regcc = cc->oldcc;
		ln = regcc->cur;
d1259 6
a1264 2
		regcc->cur = ln;
		regcc = cc;
d1266 1
d1270 14
a1283 3
	case BRANCH: {
		if (OP(next) != BRANCH)	  /* No choice. */
		    next = NEXTOPER(scan);/* Avoid recursion. */
d1285 3
a1287 1
		    int lastparen = *reglastparen;
d1289 2
a1290 2
			reginput = locinput;
			if (regmatch(NEXTOPER(scan)))
d1292 5
a1296 5
			for (n = *reglastparen; n > lastparen; n--)
			    regendp[n] = 0;
			*reglastparen = n;
			    
#ifdef REGALIGN
d1298 2
a1299 2
			if (n = NEXT(scan))
			    scan += n;
d1301 6
a1306 5
			    scan = NULL;
#else
			scan = regnext(scan);
#endif
		    } while (scan != NULL && OP(scan) == BRANCH);
d1315 138
d1454 1
d1457 1
a1457 1
	    scan = NEXTOPER(scan) + 4;
d1461 1
a1461 1
	    n = 32767;
d1463 1
d1466 5
a1474 4
	    ln = 1;
	    n = 32767;
	    scan = NEXTOPER(scan);
	  repeat:
d1486 1
a1486 1
	    reginput = locinput;
d1488 1
d1492 2
a1493 1
		while (n >= ln || (n == 32767 && ln > 0)) { /* ln overflow ? */
d1496 2
a1497 2
			UCHARAT(reginput) == c1 ||
			UCHARAT(reginput) == c2)
d1499 7
d1508 1
d1510 2
a1511 2
		    /* Couldn't or didn't -- back up. */
		    reginput = locinput + ln;
d1514 2
a1515 3
			reginput = locinput + ln;
		    }
		    else
d1520 1
d1523 1
a1523 1
		    (!multiline || OP(next) == SEOL))
d1525 37
a1561 8
		while (n >= ln) {
		    /* If it could work, try it. */
		    if (c1 == -1000 ||
			UCHARAT(reginput) == c1 ||
			UCHARAT(reginput) == c2)
		    {
			if (regmatch(next))
			    sayYES;
a1562 3
		    /* Couldn't or didn't -- back up. */
		    n--;
		    reginput = locinput + n;
d1566 5
d1572 1
a1572 2
	case END:
	    reginput = locinput;	/* put where regtry can find it */
d1574 9
d1584 30
a1613 10
	    reginput = locinput;
	    scan = NEXTOPER(scan);
	    if (!regmatch(scan))
		sayNO;
	    break;
	case UNLESSM:
	    reginput = locinput;
	    scan = NEXTOPER(scan);
	    if (regmatch(scan))
		sayNO;
d1617 1
a1617 1
			  (unsigned long)scan, scan[1]);
d1633 1
a1633 1
    regindent--;
d1639 1
a1639 1
    regindent--;
d1652 2
a1653 4
static I32
regrepeat(p, max)
char *p;
I32 max;
d1655 1
d1659 1
a1659 1
    register char *loceol = regeol;
d1661 2
a1662 2
    scan = reginput;
    if (max != 32767 && max < loceol - scan)
d1664 1
a1664 1
    opnd = OPERAND(p);
d1685 1
a1685 1
	regtainted = TRUE;
d1692 1
a1692 1
	while (scan < loceol && reginclass(opnd, *scan))
d1700 1
a1700 1
	regtainted = TRUE;
d1709 1
a1709 1
	regtainted = TRUE;
d1718 1
a1718 1
	regtainted = TRUE;
d1727 1
a1727 1
	regtainted = TRUE;
d1743 2
a1744 2
    c = scan - reginput;
    reginput = scan;
d1746 10
d1760 35
d1798 2
a1799 4
static bool
reginclass(p, c)
register char *p;
register I32 c;
d1801 1
d1806 1
a1806 1
    if (p[1 + (c >> 3)] & (1 << (c & 7)))
d1811 1
a1811 1
	    regtainted = TRUE;
d1816 1
a1816 1
	if (p[1 + (cf >> 3)] & (1 << (cf & 7)))
d1821 1
a1821 1
	regtainted = TRUE;
d1832 1
a1832 1
    return match ^ ((flags & ANYOF_INVERT) != 0);
a1834 14
/*
 - regnext - dig the "next" pointer out of a node
 *
 * [Note, when REGALIGN is defined there are two places in regmatch()
 * that bypass this code for speed.]
 */
char *
regnext(p)
register char *p;
{
    register I32 offset;

    if (p == &regdummy)
	return(NULL);
a1835 3
    offset = NEXT(p);
    if (offset == 0)
	return(NULL);
a1836 9
#ifdef REGALIGN
    return(p+offset);
#else
    if (OP(p) == BACK)
	return(p-offset);
    else
	return(p+offset);
#endif
}
@


1.1
log
@Initial revision
@
text
@d45 1
a45 1
 ****    Copyright (c) 1991-1994, Larry Wall
d85 2
a86 2
CHECKPOINT regcppush _((I32 parenfloor));
char * regcppop _((void));
d88 1
a88 1
CHECKPOINT
d110 1
a110 1
char*
d137 30
d180 3
a197 1
    register I32 i;
d227 1
a228 1
    regnpar = prog->nparens;
d234 2
a235 10
    if (prog->do_folding) {
	i = strend - startpos;
	New(1101,c,i+1,char);
	Copy(startpos, c, i+1, char);
	startpos = c;
	strend = startpos + i;
	for (s = startpos; s < strend; s++)
	    if (isUPPER(*s))
		*s = toLOWER(*s);
    }
d240 2
a241 1
	(!(prog->reganch & ROPT_ANCH)
d284 1
a284 1
    /*  [unless multiline is set] */
d288 3
a290 1
	else if (multiline || (prog->reganch & ROPT_IMPLICIT)) {
d311 1
a311 1
	    i = SvPVX(prog->regstart)[0];
d313 1
a313 1
		if (*s == i) {
d317 1
a317 1
		    while (s < strend && *s == i)
d323 1
a323 1
	else if (SvPOK(prog->regstart) == 3) {
d333 1
a333 1
	else {
d357 1
a357 2
		i = UCHARAT(s);
		if (!(c[i >> 3] & (1 << (i&7)))) {
d368 3
d374 2
a375 6
	    if (s != startpos) {
		i = s[-1];
		tmp = isALNUM(i);
	    }
	    else
		tmp = isALNUM(regprev);	/* assume not alphanumeric */
d377 1
a377 2
		i = *s;
		if (tmp != isALNUM(i)) {
d387 3
d393 2
a394 6
	    if (s != startpos) {
		i = s[-1];
		tmp = isALNUM(i);
	    }
	    else
		tmp = isALNUM(regprev);	/* assume not alphanumeric */
d396 1
a396 2
		i = *s;
		if (tmp != isALNUM(i))
d407 15
a421 2
		i = *s;
		if (isALNUM(i)) {
d434 15
a448 2
		i = *s;
		if (!isALNUM(i)) {
d472 14
d499 14
d559 6
a564 9
    if ((!safebase && (prog->nparens || sawampersand)) || prog->do_folding) {
	i = strend - startpos + (stringarg - strbeg);
	if (safebase) {			/* no need for $digit later */
	    s = strbeg;
	    prog->subend = s+i;
	}
	else if (strbeg != prog->subbase) {
	    s = savepvn(strbeg,i);	/* so $digit will work later */
	    if (prog->subbase)
d566 2
a567 2
	    prog->subbeg = prog->subbase = s;
	    prog->subend = s+i;
d570 12
a581 8
	    prog->subbeg = s = prog->subbase;
	    prog->subend = s+i;
	}
	s += (stringarg - strbeg);
	for (i = 0; i <= prog->nparens; i++) {
	    if (prog->endp[i]) {
		prog->startp[i] = s + (prog->startp[i] - startpos);
		prog->endp[i] = s + (prog->endp[i] - startpos);
a583 2
	if (prog->do_folding)
	    Safefree(startpos);
a587 2
    if (prog->do_folding)
	Safefree(startpos);
d652 1
d659 1
a659 1
    nextchar = *locinput;
d667 5
a671 2
	    fprintf(stderr, "%*s%2d%-8.8s\t<%.10s>\n", regindent*2, "",
		scan - regprogram, regprop(scan), locinput);
d709 1
a709 1
	case GBOL:
d733 1
a733 1
	    nextchar = *++locinput;
d738 1
a738 1
	    nextchar = *++locinput;
d740 1
a740 1
	case EXACTLY:
d744 1
a744 1
	    if (*s != nextchar)
d748 1
a748 1
	    if (ln > 1 && bcmp(s, locinput, ln) != 0)
d751 21
a771 1
	    nextchar = *locinput;
d777 1
a777 1
	    if (s[nextchar >> 3] & (1 << (nextchar&7)))
d781 1
a781 1
	    nextchar = *++locinput;
d783 3
d789 2
a790 1
	    if (!isALNUM(nextchar))
d792 1
a792 1
	    nextchar = *++locinput;
d794 3
d800 2
a801 1
	    if (isALNUM(nextchar))
d803 1
a803 1
	    nextchar = *++locinput;
d805 5
d811 11
a821 7
	case BOUND:
	    if (locinput == regbol)	/* was last char in word? */
		ln = isALNUM(regprev);
	    else 
		ln = isALNUM(locinput[-1]);
	    n = isALNUM(nextchar); /* is next char in word? */
	    if ((ln == n) == (OP(scan) == BOUND))
d824 3
d830 2
a831 1
	    if (!isSPACE(nextchar))
d833 1
a833 1
	    nextchar = *++locinput;
d835 3
d841 2
a842 1
	    if (isSPACE(nextchar))
d844 1
a844 1
	    nextchar = *++locinput;
d849 1
a849 1
	    nextchar = *++locinput;
d856 1
a856 1
	    nextchar = *++locinput;
d858 3
d862 1
d872 4
a875 1
	    if (*s != nextchar)
d880 5
a884 1
	    if (ln > 1 && bcmp(s, locinput, ln) != 0)
d887 1
a887 1
	    nextchar = *locinput;
d936 1
d943 2
a944 2
		    fprintf(stderr, "%*s  %d  %lx\n", regindent*2, "",
			n, (long)cc);
d949 1
a949 1
		if (locinput == cc->lastloc) {
d975 3
a977 1
		    if (regmatch(cc->next))
d979 2
d991 3
a993 1
		    if (regmatch(cc->scan))
d995 2
d1004 1
a1004 1
		    regcppush(cc->parenfloor);
d1007 2
a1008 1
		    if (regmatch(cc->scan))
d1010 1
d1076 9
a1084 2
	    if (OP(next) == EXACTLY)
		nextchar = *(OPERAND(next)+1);
d1086 1
a1086 1
		nextchar = -1000;
d1094 4
a1097 1
		    if (nextchar == -1000 || *reginput == nextchar)
d1100 1
d1118 4
a1121 1
		    if (nextchar == -1000 || *reginput == nextchar)
d1124 1
d1148 2
a1149 1
	    fprintf(stderr, "%x %d\n",(unsigned)scan,scan[1]);
d1206 16
a1221 3
    case EXACTLY:		/* length of string is 1 */
	opnd++;
	while (scan < loceol && *opnd == *scan)
d1225 1
a1225 2
	c = UCHARAT(scan);
	while (scan < loceol && !(opnd[c >> 3] & (1 << (c & 7)))) {
a1226 2
	    c = UCHARAT(scan);
	}
d1232 5
d1241 5
d1250 5
d1259 5
d1280 42
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@a21 20
#ifdef PERL_EXT_RE_BUILD
/* need to replace pregcomp et al, so enable that */
#  ifndef PERL_IN_XSUB_RE
#    define PERL_IN_XSUB_RE
#  endif
/* need access to debugger hooks */
#  ifndef DEBUGGING
#    define DEBUGGING
#  endif
#endif

#ifdef PERL_IN_XSUB_RE
/* We *really* need to overwrite these symbols: */
#  define Perl_regexec_flags my_regexec
#  define Perl_regdump my_regdump
#  define Perl_regprop my_regprop
/* *These* symbols are masked to allow static link. */
#  define Perl_pregexec my_pregexec
#endif 

d45 1
a45 1
 ****    Copyright (c) 1991-1999, Larry Wall
a57 7
#define RF_tainted	1		/* tainted information used? */
#define RF_warned	2		/* warned about big count? */
#define RF_evaled	4		/* Did an EVAL with setting? */

#define RS_init		1		/* eval environment created */
#define RS_set		2		/* replsv value is set */

d62 18
a79 2
#ifndef PERL_OBJECT
typedef I32 CHECKPOINT;
d81 1
a81 3
/*
 * Forwards.
 */
d83 1
a83 4
static I32 regmatch _((regnode *prog));
static I32 regrepeat _((regnode *p, I32 max));
static I32 regrepeat_hard _((regnode *p, I32 max, I32 *lp));
static I32 regtry _((regexp *prog, char *startpos));
d85 2
a86 5
static bool reginclass _((char *p, I32 c));
static CHECKPOINT regcppush _((I32 parenfloor));
static char * regcppop _((void));
#endif
#define REGINCLASS(p,c)  (*(p) ? reginclass(p,c) : ANYOF_TEST(p,c))
d88 3
a90 2
STATIC CHECKPOINT
regcppush(I32 parenfloor)
d92 2
a93 3
    dTHR;
    int retval = PL_savestack_ix;
    int i = (PL_regsize - parenfloor) * 4;
d97 3
a99 4
    for (p = PL_regsize; p > parenfloor; p--) {
	SSPUSHPTR(PL_regendp[p]);
	SSPUSHPTR(PL_regstartp[p]);
	SSPUSHPTR(PL_reg_start_tmp[p]);
d102 3
a104 3
    SSPUSHINT(PL_regsize);
    SSPUSHINT(*PL_reglastparen);
    SSPUSHPTR(PL_reginput);
d110 2
a111 12
/* These are needed since we do not localize EVAL nodes: */
#  define REGCP_SET  DEBUG_r(PerlIO_printf(Perl_debug_log,		\
			     "  Setting an EVAL scope, savestack=%i\n",	\
			     PL_savestack_ix)); lastcp = PL_savestack_ix

#  define REGCP_UNWIND  DEBUG_r(lastcp != PL_savestack_ix ?		\
				PerlIO_printf(Perl_debug_log,		\
				"  Clearing an EVAL scope, savestack=%i..%i\n", \
				lastcp, PL_savestack_ix) : 0); regcpblow(lastcp)

STATIC char *
regcppop(void)
a112 1
    dTHR;
d120 3
a122 3
    *PL_reglastparen = SSPOPINT;
    PL_regsize = SSPOPINT;
    for (i -= 3; i > 0; i -= 4) {
d124 1
a124 2
	PL_reg_start_tmp[paren] = (char *) SSPOPPTR;
	PL_regstartp[paren] = (char *) SSPOPPTR;
d126 2
a127 10
	if (paren <= *PL_reglastparen)
	    PL_regendp[paren] = tmps;
	DEBUG_r(
	    PerlIO_printf(Perl_debug_log,
			  "     restoring \\%d to %d(%d)..%d%s\n",
			  paren, PL_regstartp[paren] - PL_regbol, 
			  PL_reg_start_tmp[paren] - PL_regbol,
			  PL_regendp[paren] - PL_regbol, 
			  (paren > *PL_reglastparen ? "(no)" : ""));
	);
d129 4
a132 11
    DEBUG_r(
	if (*PL_reglastparen + 1 <= PL_regnpar) {
	    PerlIO_printf(Perl_debug_log,
			  "     restoring \\%d..\\%d to undef\n",
			  *PL_reglastparen + 1, PL_regnpar);
	}
    );
    for (paren = *PL_reglastparen + 1; paren <= PL_regnpar; paren++) {
	if (paren > PL_regsize)
	    PL_regstartp[paren] = Nullch;
	PL_regendp[paren] = Nullch;
d137 1
a137 1
#define regcpblow(cp) LEAVE_SCOPE(cp)
d144 1
a144 1
 - pregexec - match a regexp against a string
d146 5
a150 13
I32
pregexec(register regexp *prog, char *stringarg, register char *strend,
	 char *strbeg, I32 minend, SV *screamer, U32 nosave)
/* strend: pointer to null at end of string */
/* strbeg: real beginning of string */
/* minend: end of match must be >=minend after stringarg. */
/* nosave: For optimizations. */
{
    return
	regexec_flags(prog, stringarg, strend, strbeg, minend, screamer, NULL, 
		      nosave ? 0 : REXEC_COPY_STR);
}
  
d152 1
a152 1
 - regexec_flags - match a regexp against a string
d155 8
a162 7
regexec_flags(register regexp *prog, char *stringarg, register char *strend,
	      char *strbeg, I32 minend, SV *screamer, void *data, U32 flags)
/* strend: pointer to null at end of string */
/* strbeg: real beginning of string */
/* minend: end of match must be >=minend after stringarg. */
/* data: May be used for some additional optimizations. */
/* nosave: For optimizations. */
a163 1
    dTHR;
d165 2
a166 1
    register regnode *c;
d169 1
a169 1
    I32 minlen;		/* must match at least this many chars */
a171 6
    I32 start_shift = 0;		/* Offset of the start to find
					 constant substr. */
    I32 end_shift = 0;			/* Same for the end. */
    I32 scream_pos = -1;		/* Internal iterator of scream. */
    char *scream_olds;
    SV* oreplsv = GvSV(PL_replgv);
d175 1
a175 1
    PL_regcc = &cc;
a176 1
    PL_regprecomp = prog->precomp;		/* Needed for error messages. */
d178 2
a179 2
    PL_regnarrate = PL_debug & 512;
    PL_regprogram = prog->program;
a187 3
    minlen = prog->minlen;
    if (strend - startpos < minlen) goto phooey;

d189 1
a189 1
	PL_regprev = '\n';
d191 3
a193 3
	PL_regprev = stringarg[-1];
	if (!PL_multiline && PL_regprev == '\n')
	    PL_regprev = '\0';		/* force ^ to NOT match */
d195 2
a196 1

d202 10
a211 3
    PL_regnpar = prog->nparens;
    PL_reg_flags = 0;
    PL_reg_eval_set = 0;
d215 3
a217 5
    if (!(flags & REXEC_CHECKED) 
	&& prog->check_substr != Nullsv &&
	!(prog->reganch & ROPT_ANCH_GPOS) &&
	(!(prog->reganch & (ROPT_ANCH_BOL | ROPT_ANCH_MBOL))
	 || (PL_multiline && prog->check_substr == prog->anchored_substr)) )
d219 3
a221 8
	start_shift = prog->check_offset_min;
	/* Should be nonnegative! */
	end_shift = minlen - start_shift - SvCUR(prog->check_substr);
	if (screamer) {
	    if (PL_screamfirst[BmRARE(prog->check_substr)] >= 0)
		    s = screaminstr(screamer, prog->check_substr, 
				    start_shift + (stringarg - strbeg),
				    end_shift, &scream_pos, 0);
a223 1
	    scream_olds = s;
d226 2
a227 3
	    s = fbm_instr((unsigned char*)s + start_shift,
			  (unsigned char*)strend - end_shift,
		prog->check_substr, 0);
d229 1
a229 1
	    ++BmUSEFUL(prog->check_substr);	/* hooray */
d231 10
a240 9
	} else if ((s - stringarg) > prog->check_offset_max) {
	    ++BmUSEFUL(prog->check_substr);	/* hooray/2 */
	    s -= prog->check_offset_max;
	} else if (!prog->naughty 
		   && --BmUSEFUL(prog->check_substr) < 0
		   && prog->check_substr == prog->float_substr) { /* boo */
	    SvREFCNT_dec(prog->check_substr);
	    prog->check_substr = Nullsv;	/* disable */
	    prog->float_substr = Nullsv;	/* clear */
d242 5
a246 1
	} else s = startpos;
d249 2
a250 3
    /* Mark beginning of line for ^ and lookbehind. */
    PL_regbol = startpos;
    PL_bostr  = strbeg;
d253 1
a253 1
    PL_regeol = strend;
d256 1
a256 11
    PL_regtill = startpos+minend;

    DEBUG_r(
	PerlIO_printf(Perl_debug_log, 
		      "Matching `%.60s%s' against `%.*s%s'\n",
		      prog->precomp, 
		      (strlen(prog->precomp) > 60 ? "..." : ""),
		      (strend - startpos > 60 ? 60 : strend - startpos),
		      startpos, 
		      (strend - startpos > 60 ? "..." : ""))
	);
d259 1
a259 1
    /*  [unless only anchor is BOL and multiline is set] */
d263 1
a263 4
	else if (!(prog->reganch & ROPT_ANCH_GPOS) &&
		 (PL_multiline || (prog->reganch & ROPT_IMPLICIT)
		  || (prog->reganch & ROPT_ANCH_MBOL)))
	{
d281 12
a292 7
    if (prog->anchored_substr && prog->reganch & ROPT_SKIP) { 
	/* we have /x+whatever/ */
	/* it must be a one character string */
	char ch = SvPVX(prog->anchored_substr)[0];
	while (s < strend) {
	    if (*s == ch) {
		if (regtry(prog, s)) goto got_it;
a293 2
		while (s < strend && *s == ch)
		    s++;
a294 1
	    s++;
d296 8
a303 34
    }
    /*SUPPRESS 560*/
    else if (prog->anchored_substr != Nullsv
	     || (prog->float_substr != Nullsv 
		 && prog->float_max_offset < strend - s)) {
	SV *must = prog->anchored_substr 
	    ? prog->anchored_substr : prog->float_substr;
	I32 back_max = 
	    prog->anchored_substr ? prog->anchored_offset : prog->float_max_offset;
	I32 back_min = 
	    prog->anchored_substr ? prog->anchored_offset : prog->float_min_offset;
	I32 delta = back_max - back_min;
	char *last = strend - SvCUR(must) - back_min; /* Cannot start after this */
	char *last1 = s - 1;		/* Last position checked before */

	/* XXXX check_substr already used to find `s', can optimize if
	   check_substr==must. */
	scream_pos = -1;
	dontbother = end_shift;
	strend -= dontbother;
	while ( (s <= last) &&
		(screamer 
		 ? (s = screaminstr(screamer, must, s + back_min - strbeg,
				    end_shift, &scream_pos, 0))
		 : (s = fbm_instr((unsigned char*)s + back_min,
				  (unsigned char*)strend, must, 0))) ) {
	    if (s - back_max > last1) {
		last1 = s - back_min;
		s = s - back_max;
	    } else {
		char *t = last1 + 1;		

		last1 = s - back_min;
		s = t;		
d305 5
a309 1
	    while (s <= last1) {
d316 3
a318 1
    } else if (c = prog->regstclass) {
a319 1
	char *Class;
d328 1
a328 1
	    Class = (char *) OPERAND(c);
d330 2
a331 1
		if (REGINCLASS(Class, *s)) {
a341 3
	case BOUNDL:
	    PL_reg_flags |= RF_tainted;
	    /* FALL THROUGH */
d345 6
a350 2
	    tmp = (s != startpos) ? UCHARAT(s - 1) : PL_regprev;
	    tmp = ((OP(c) == BOUND ? isALNUM(tmp) : isALNUM_LC(tmp)) != 0);
d352 2
a353 1
		if (tmp == !(OP(c) == BOUND ? isALNUM(*s) : isALNUM_LC(*s))) {
a362 3
	case NBOUNDL:
	    PL_reg_flags |= RF_tainted;
	    /* FALL THROUGH */
d366 6
a371 2
	    tmp = (s != startpos) ? UCHARAT(s - 1) : PL_regprev;
	    tmp = ((OP(c) == NBOUND ? isALNUM(tmp) : isALNUM_LC(tmp)) != 0);
d373 2
a374 1
		if (tmp == !(OP(c) == NBOUND ? isALNUM(*s) : isALNUM_LC(*s)))
d385 2
a386 15
		if (isALNUM(*s)) {
		    if (tmp && regtry(prog, s))
			goto got_it;
		    else
			tmp = doevery;
		}
		else
		    tmp = 1;
		s++;
	    }
	    break;
	case ALNUML:
	    PL_reg_flags |= RF_tainted;
	    while (s < strend) {
		if (isALNUM_LC(*s)) {
d399 2
a400 15
		if (!isALNUM(*s)) {
		    if (tmp && regtry(prog, s))
			goto got_it;
		    else
			tmp = doevery;
		}
		else
		    tmp = 1;
		s++;
	    }
	    break;
	case NALNUML:
	    PL_reg_flags |= RF_tainted;
	    while (s < strend) {
		if (!isALNUM_LC(*s)) {
a423 14
	case SPACEL:
	    PL_reg_flags |= RF_tainted;
	    while (s < strend) {
		if (isSPACE_LC(*s)) {
		    if (tmp && regtry(prog, s))
			goto got_it;
		    else
			tmp = doevery;
		}
		else
		    tmp = 1;
		s++;
	    }
	    break;
a436 14
	case NSPACEL:
	    PL_reg_flags |= RF_tainted;
	    while (s < strend) {
		if (!isSPACE_LC(*s)) {
		    if (tmp && regtry(prog, s))
			goto got_it;
		    else
			tmp = doevery;
		}
		else
		    tmp = 1;
		s++;
	    }
	    break;
d466 1
a466 23
	dontbother = 0;
	if (prog->float_substr != Nullsv) {	/* Trim the end. */
	    char *last;
	    I32 oldpos = scream_pos;

	    if (screamer) {
		last = screaminstr(screamer, prog->float_substr, s - strbeg,
				   end_shift, &scream_pos, 1); /* last one */
		if (!last) {
		    last = scream_olds; /* Only one occurence. */
		}
	    } else {
		STRLEN len;
		char *little = SvPV(prog->float_substr, len);
		if (len) 
		    last = rninstr(s, strend, little, little + len);
		else
		    last = strend;	/* matching `$' */
	    }
	    if (last == NULL) goto phooey; /* Should not happen! */
	    dontbother = strend - last + prog->float_min_offset;
	}
	if (minlen && (dontbother < minlen))
d480 1
d482 10
a491 7
    prog->subend = PL_regeol;	/* strend may have been modified */
    RX_MATCH_TAINTED_set(prog, PL_reg_flags & RF_tainted);

    /* make sure $`, $&, $', and $digit will work later */
    if (strbeg != prog->subbase) {	/* second+ //g match.  */
	if (!(flags & REXEC_COPY_STR)) {
	    if (prog->subbase) {
d493 2
a494 2
		prog->subbase = Nullch;
	    }
d497 8
a504 12
	    I32 i = PL_regeol - startpos + (stringarg - strbeg);
	    s = savepvn(strbeg, i);
	    Safefree(prog->subbase);
	    prog->subbase = s;
	    prog->subbeg = prog->subbase;
	    prog->subend = prog->subbase + i;
	    s = prog->subbase + (stringarg - strbeg);
	    for (i = 0; i <= prog->nparens; i++) {
		if (prog->endp[i]) {
		    prog->startp[i] = s + (prog->startp[i] - startpos);
		    prog->endp[i] = s + (prog->endp[i] - startpos);
		}
d507 2
a508 6
    }
    /* Preserve the current value of $^R */
    if (oreplsv != GvSV(PL_replgv)) {
	sv_setsv(oreplsv, GvSV(PL_replgv));/* So that when GvSV(replgv) is
					   restored, the value remains
					   the same. */
d513 2
d521 4
a524 2
STATIC I32			/* 0 failure, 1 success */
regtry(regexp *prog, char *startpos)
a525 1
    dTHR;
a528 1
    CHECKPOINT lastcp;
d530 4
a533 18
    if ((prog->reganch & ROPT_EVAL_SEEN) && !PL_reg_eval_set) {
	PL_reg_eval_set = RS_init;
	DEBUG_r(DEBUG_s(
	    PerlIO_printf(Perl_debug_log, "  setting stack tmpbase at %i\n",
			  PL_stack_sp - PL_stack_base);
	    ));
	SAVEINT(cxstack[cxstack_ix].blk_oldsp);
	cxstack[cxstack_ix].blk_oldsp = PL_stack_sp - PL_stack_base;
	/* Otherwise OP_NEXTSTATE will free whatever on stack now.  */
	SAVETMPS;
	/* Apparently this is not needed, judging by wantarray. */
	/* SAVEINT(cxstack[cxstack_ix].blk_gimme);
	   cxstack[cxstack_ix].blk_gimme = G_SCALAR; */
    }
    PL_reginput = startpos;
    PL_regstartp = prog->startp;
    PL_regendp = prog->endp;
    PL_reglastparen = &prog->lastparen;
d535 1
a535 8
    PL_regsize = 0;
    if (PL_reg_start_tmpl <= prog->nparens) {
	PL_reg_start_tmpl = prog->nparens*3/2 + 3;
        if(PL_reg_start_tmp)
            Renew(PL_reg_start_tmp, PL_reg_start_tmpl, char*);
        else
            New(22,PL_reg_start_tmp, PL_reg_start_tmpl, char*);
    }
a538 1
    PL_regdata = prog->data;
d545 1
a545 2
    REGCP_SET;
    if (regmatch(prog->program + 1)) {
d547 1
a547 1
	prog->endp[0] = PL_reginput;
d550 2
a551 2
    REGCP_UNWIND;
    return 0;
d568 3
a570 2
STATIC I32			/* 0 failure, 1 success */
regmatch(regnode *prog)
d572 3
a574 6
    dTHR;
    register regnode *scan;	/* Current node. */
    regnode *next;		/* Next node. */
    regnode *inner;		/* Next node in internal branch. */
    register I32 nextchr;	/* renamed nextchr - nextchar colides with
				   function of same name */
d578 2
a579 3
    register char *locinput = PL_reginput;
    register I32 c1, c2, paren;	/* case fold search, parenth */
    int minmod = 0, sw = 0, logical = 0;
d581 2
a582 1
    PL_regindent++;
d585 1
a585 1
    nextchr = UCHARAT(locinput);
a587 1
#define sayNO_L (logical ? (logical = 0, sw = 0, goto cont) : sayNO)
d589 7
a595 4
#  define sayYES goto yes
#  define sayNO goto no
#  define saySAME(x) if (x) goto yes; else goto no
#  define REPORT_CODE_OFF 24
d597 3
a599 3
#  define sayYES return 1
#  define sayNO return 0
#  define saySAME(x) return x
a600 23
	DEBUG_r( {
	    SV *prop = sv_newmortal();
	    int docolor = *PL_colors[0];
	    int taill = (docolor ? 10 : 7); /* 3 chars for "> <" */
	    int l = (PL_regeol - locinput > taill ? taill : PL_regeol - locinput);
	    int pref_len = (locinput - PL_bostr > (5 + taill) - l 
			    ? (5 + taill) - l : locinput - PL_bostr);

	    if (l + pref_len < (5 + taill) && l < PL_regeol - locinput)
		l = ( PL_regeol - locinput > (5 + taill) - pref_len 
		      ? (5 + taill) - pref_len : PL_regeol - locinput);
	    regprop(prop, scan);
	    PerlIO_printf(Perl_debug_log, 
			  "%4i <%s%.*s%s%s%s%.*s%s>%*s|%3d:%*s%s\n",
			  locinput - PL_bostr, 
			  PL_colors[2], pref_len, locinput - pref_len, PL_colors[3],
			  (docolor ? "" : "> <"),
			  PL_colors[0], l, locinput, PL_colors[1],
			  15 - l - pref_len + 1,
			  "",
			  scan - PL_regprogram, PL_regindent*2, "",
			  SvPVX(prop));
	} );
d602 2
a603 1
	next = scan + NEXT_OFF(scan);
d606 3
d612 3
a614 4
	    if (locinput == PL_bostr
		? PL_regprev == '\n'
		: (PL_multiline && 
		   (nextchr || locinput < PL_regeol) && locinput[-1] == '\n') )
d616 1
a616 1
		/* PL_regtill = PL_regbol; */
d621 3
a623 3
	    if (locinput == PL_bostr
		? PL_regprev == '\n'
		: ((nextchr || locinput < PL_regeol) && locinput[-1] == '\n') )
d629 1
a629 1
	    if (locinput == PL_regbol && PL_regprev == '\n')
d632 2
a633 2
	case GPOS:
	    if (locinput == PL_regbol)
d637 1
a637 1
	    if (PL_multiline)
d643 1
a643 1
	    if ((nextchr || locinput < PL_regeol) && nextchr != '\n')
d648 1
a648 3
	    if ((nextchr || locinput < PL_regeol) && nextchr != '\n')
		sayNO;
	    if (PL_regeol - locinput > 1)
d650 1
a650 3
	    break;
	case EOS:
	    if (PL_regeol != locinput)
d654 1
a654 1
	    if (!nextchr && locinput >= PL_regeol)
d656 1
a656 1
	    nextchr = UCHARAT(++locinput);
d659 1
a659 1
	    if (!nextchr && locinput >= PL_regeol || nextchr == '\n')
d661 1
a661 1
	    nextchr = UCHARAT(++locinput);
d663 3
a665 3
	case EXACT:
	    s = (char *) OPERAND(scan);
	    ln = UCHARAT(s++);
d667 1
a667 1
	    if (UCHARAT(s) != nextchr)
d669 1
a669 1
	    if (PL_regeol - locinput < ln)
d671 1
a671 1
	    if (ln > 1 && memNE(s, locinput, ln))
d674 1
a674 1
	    nextchr = UCHARAT(locinput);
d676 7
a682 16
	case EXACTFL:
	    PL_reg_flags |= RF_tainted;
	    /* FALL THROUGH */
	case EXACTF:
	    s = (char *) OPERAND(scan);
	    ln = UCHARAT(s++);
	    /* Inline the first character, for speed. */
	    if (UCHARAT(s) != nextchr &&
		UCHARAT(s) != ((OP(scan) == EXACTF)
			       ? fold : fold_locale)[nextchr])
		sayNO;
	    if (PL_regeol - locinput < ln)
		sayNO;
	    if (ln > 1 && (OP(scan) == EXACTF
			   ? ibcmp(s, locinput, ln)
			   : ibcmp_locale(s, locinput, ln)))
d684 1
a684 2
	    locinput += ln;
	    nextchr = UCHARAT(locinput);
a685 13
	case ANYOF:
	    s = (char *) OPERAND(scan);
	    if (nextchr < 0)
		nextchr = UCHARAT(locinput);
	    if (!REGINCLASS(s, nextchr))
		sayNO;
	    if (!nextchr && locinput >= PL_regeol)
		sayNO;
	    nextchr = UCHARAT(++locinput);
	    break;
	case ALNUML:
	    PL_reg_flags |= RF_tainted;
	    /* FALL THROUGH */
d687 1
a687 1
	    if (!nextchr)
d689 1
a689 2
	    if (!(OP(scan) == ALNUM
		  ? isALNUM(nextchr) : isALNUM_LC(nextchr)))
d691 1
a691 1
	    nextchr = UCHARAT(++locinput);
a692 3
	case NALNUML:
	    PL_reg_flags |= RF_tainted;
	    /* FALL THROUGH */
d694 1
a694 1
	    if (!nextchr && locinput >= PL_regeol)
d696 1
a696 2
	    if (OP(scan) == NALNUM
		? isALNUM(nextchr) : isALNUM_LC(nextchr))
d698 1
a698 1
	    nextchr = UCHARAT(++locinput);
d700 1
a700 4
	case BOUNDL:
	case NBOUNDL:
	    PL_reg_flags |= RF_tainted;
	    /* FALL THROUGH */
d702 6
a707 12
	case NBOUND:
	    /* was last char in word? */
	    ln = (locinput != PL_regbol) ? UCHARAT(locinput - 1) : PL_regprev;
	    if (OP(scan) == BOUND || OP(scan) == NBOUND) {
		ln = isALNUM(ln);
		n = isALNUM(nextchr);
	    }
	    else {
		ln = isALNUM_LC(ln);
		n = isALNUM_LC(nextchr);
	    }
	    if (((!ln) == (!n)) == (OP(scan) == BOUND || OP(scan) == BOUNDL))
a709 3
	case SPACEL:
	    PL_reg_flags |= RF_tainted;
	    /* FALL THROUGH */
d711 1
a711 1
	    if (!nextchr && locinput >= PL_regeol)
d713 1
a713 2
	    if (!(OP(scan) == SPACE
		  ? isSPACE(nextchr) : isSPACE_LC(nextchr)))
d715 1
a715 1
	    nextchr = UCHARAT(++locinput);
a716 3
	case NSPACEL:
	    PL_reg_flags |= RF_tainted;
	    /* FALL THROUGH */
d718 1
a718 1
	    if (!nextchr)
d720 1
a720 2
	    if (OP(scan) == SPACE
		? isSPACE(nextchr) : isSPACE_LC(nextchr))
d722 1
a722 1
	    nextchr = UCHARAT(++locinput);
d725 1
a725 1
	    if (!isDIGIT(nextchr))
d727 1
a727 1
	    nextchr = UCHARAT(++locinput);
d730 1
a730 1
	    if (!nextchr && locinput >= PL_regeol)
d732 1
a732 1
	    if (isDIGIT(nextchr))
d734 1
a734 1
	    nextchr = UCHARAT(++locinput);
d736 8
a743 10
	case REFFL:
	    PL_reg_flags |= RF_tainted;
	    /* FALL THROUGH */
        case REF:
	case REFF:
	    n = ARG(scan);  /* which paren pair */
	    s = PL_regstartp[n];
	    if (*PL_reglastparen < n || !s)
		sayNO;			/* Do not match unless seen CLOSEn. */
	    if (s == PL_regendp[n])
d746 6
a751 13
	    if (UCHARAT(s) != nextchr &&
		(OP(scan) == REF ||
		 (UCHARAT(s) != ((OP(scan) == REFF
				  ? fold : fold_locale)[nextchr]))))
		sayNO;
	    ln = PL_regendp[n] - s;
	    if (locinput + ln > PL_regeol)
		sayNO;
	    if (ln > 1 && (OP(scan) == REF
			   ? memNE(s, locinput, ln)
			   : (OP(scan) == REFF
			      ? ibcmp(s, locinput, ln)
			      : ibcmp_locale(s, locinput, ln))))
d754 1
a754 1
	    nextchr = UCHARAT(locinput);
a757 1
	case TAIL:
a760 28
	case EVAL:
	{
	    dSP;
	    OP_4tree *oop = PL_op;
	    COP *ocurcop = PL_curcop;
	    SV **ocurpad = PL_curpad;
	    SV *ret;
	    
	    n = ARG(scan);
	    PL_op = (OP_4tree*)PL_regdata->data[n];
	    DEBUG_r( PerlIO_printf(Perl_debug_log, "  re_eval 0x%x\n", PL_op) );
	    PL_curpad = AvARRAY((AV*)PL_regdata->data[n + 1]);

	    CALLRUNOPS();			/* Scalar context. */
	    SPAGAIN;
	    ret = POPs;
	    PUTBACK;
	    
	    if (logical) {
		logical = 0;
		sw = SvTRUE(ret);
	    } else
		sv_setsv(save_scalar(PL_replgv), ret);
	    PL_op = oop;
	    PL_curpad = ocurpad;
	    PL_curcop = ocurcop;
	    break;
	}
d762 4
a765 4
	    n = ARG(scan);  /* which paren pair */
	    PL_reg_start_tmp[n] = locinput;
	    if (n > PL_regsize)
		PL_regsize = n;
d768 4
a771 21
	    n = ARG(scan);  /* which paren pair */
	    PL_regstartp[n] = PL_reg_start_tmp[n];
	    PL_regendp[n] = locinput;
	    if (n > *PL_reglastparen)
		*PL_reglastparen = n;
	    break;
	case GROUPP:
	    n = ARG(scan);  /* which paren pair */
	    sw = (*PL_reglastparen >= n && PL_regendp[n] != NULL);
	    break;
	case IFTHEN:
	    if (sw)
		next = NEXTOPER(NEXTOPER(scan));
	    else {
		next = scan + ARG(scan);
		if (OP(next) == IFTHEN) /* Fake one. */
		    next = NEXTOPER(NEXTOPER(next));
	    }
	    break;
	case LOGICAL:
	    logical = 1;
d775 4
a778 7
		CHECKPOINT cp = PL_savestack_ix;

		if (OP(PREVOPER(next)) == NOTHING) /* LONGJMP */
		    next += ARG(next);
		cc.oldcc = PL_regcc;
		PL_regcc = &cc;
		cc.parenfloor = *PL_reglastparen;
d782 1
a782 1
		cc.scan = NEXTOPER(scan) + EXTRA_STEP_2ARGS;
d786 1
a786 1
		PL_reginput = locinput;
d789 1
a789 1
		PL_regcc = cc.oldcc;
d803 1
a803 4
		CHECKPOINT cp, lastcp;
		CURCUR* cc = PL_regcc;
		char *lastloc = cc->lastloc; /* Detection of 0-len. */
		
d805 1
a805 1
		PL_reginput = locinput;
d807 5
a811 7
		DEBUG_r(
		    PerlIO_printf(Perl_debug_log, 
				  "%*s  %ld out of %ld..%ld  cc=%lx\n", 
				  REPORT_CODE_OFF+PL_regindent*2, "",
				  (long)n, (long)cc->min, 
				  (long)cc->max, (long)cc)
		    );
d815 3
a817 8
		if (locinput == cc->lastloc && n >= cc->min) {
		    PL_regcc = cc->oldcc;
		    ln = PL_regcc->cur;
		    DEBUG_r(
			PerlIO_printf(Perl_debug_log,
			   "%*s  empty match detected, try continuation...\n",
			   REPORT_CODE_OFF+PL_regindent*2, "")
			);
d820 2
a821 7
		    DEBUG_r(
			PerlIO_printf(Perl_debug_log,
				      "%*s  failed...\n",
				      REPORT_CODE_OFF+PL_regindent*2, "")
			);
		    PL_regcc->cur = ln;
		    PL_regcc = cc;
a832 6
		    cc->lastloc = lastloc;
		    DEBUG_r(
			PerlIO_printf(Perl_debug_log,
				      "%*s  failed...\n",
				      REPORT_CODE_OFF+PL_regindent*2, "")
			);
d839 3
a841 6
		    PL_regcc = cc->oldcc;
		    ln = PL_regcc->cur;
		    cp = regcppush(cc->parenfloor);
		    REGCP_SET;
		    if (regmatch(cc->next)) {
			regcpblow(cp);
d843 4
a846 14
		    }
		    REGCP_UNWIND;
		    regcppop();
		    PL_regcc->cur = ln;
		    PL_regcc = cc;

		    if (n >= cc->max) {	/* Maximum greed exceeded? */
			if (PL_dowarn && n >= REG_INFTY 
			    && !(PL_reg_flags & RF_warned)) {
			    PL_reg_flags |= RF_warned;
			    warn("%s limit (%d) exceeded",
				 "Complex regular subexpression recursion",
				 REG_INFTY - 1);
			}
a847 1
		    }
a848 5
		    DEBUG_r(
			PerlIO_printf(Perl_debug_log,
				      "%*s  trying longer...\n",
				      REPORT_CODE_OFF+PL_regindent*2, "")
			);
d850 1
a850 1
		    PL_reginput = locinput;
d853 1
a853 4
		    cp = regcppush(cc->parenfloor);
		    REGCP_SET;
		    if (regmatch(cc->scan)) {
			regcpblow(cp);
a854 8
		    }
		    DEBUG_r(
			PerlIO_printf(Perl_debug_log,
				      "%*s  failed...\n",
				      REPORT_CODE_OFF+PL_regindent*2, "")
			);
		    REGCP_UNWIND;
		    regcppop();
a855 1
		    cc->lastloc = lastloc;
d862 1
a862 1
		    cp = regcppush(cc->parenfloor);
d865 1
a865 3
		    REGCP_SET;
		    if (regmatch(cc->scan)) {
			regcpblow(cp);
a866 2
		    }
		    REGCP_UNWIND;
d868 1
a868 12
		    PL_reginput = locinput;
		    DEBUG_r(
			PerlIO_printf(Perl_debug_log,
				      "%*s  failed, try continuation...\n",
				      REPORT_CODE_OFF+PL_regindent*2, "")
			);
		}
		if (PL_dowarn && n >= REG_INFTY && !(PL_reg_flags & RF_warned)) {
		    PL_reg_flags |= RF_warned;
		    warn("%s limit (%d) exceeded",
			 "Complex regular subexpression recursion",
			 REG_INFTY - 1);
d872 2
a873 2
		PL_regcc = cc->oldcc;
		ln = PL_regcc->cur;
d876 2
a877 6
		DEBUG_r(
		    PerlIO_printf(Perl_debug_log, "%*s  failed...\n",
				  REPORT_CODE_OFF+PL_regindent*2, "")
		    );
		PL_regcc->cur = ln;
		PL_regcc = cc;
a878 1
		cc->lastloc = lastloc;
d882 3
a884 14
	case BRANCHJ: 
	    next = scan + ARG(scan);
	    if (next == scan)
		next = NULL;
	    inner = NEXTOPER(NEXTOPER(scan));
	    goto do_branch;
	case BRANCH: 
	    inner = NEXTOPER(scan);
	  do_branch:
	    {
		CHECKPOINT lastcp;
		c1 = OP(scan);
		if (OP(next) != c1)	/* No choice. */
		    next = inner;	/* Avoid recursion. */
d886 1
a886 3
		    int lastparen = *PL_reglastparen;

		    REGCP_SET;
d888 2
a889 2
			PL_reginput = locinput;
			if (regmatch(inner))
d891 5
a895 5
			REGCP_UNWIND;
			for (n = *PL_reglastparen; n > lastparen; n--)
			    PL_regendp[n] = 0;
			*PL_reglastparen = n;
			scan = next;
d897 2
a898 2
			if (n = (c1 == BRANCH ? NEXT_OFF(next) : ARG(next)))
			    next += n;
d900 5
a904 6
			    next = NULL;
			inner = NEXTOPER(scan);
			if (c1 == BRANCHJ) {
			    inner = NEXTOPER(inner);
			}
		    } while (scan != NULL && OP(scan) == c1);
a912 138
	case CURLYM:
	{
	    I32 l = 0;
	    CHECKPOINT lastcp;
	    
	    /* We suppose that the next guy does not need
	       backtracking: in particular, it is of constant length,
	       and has no parenths to influence future backrefs. */
	    ln = ARG1(scan);  /* min to match */
	    n  = ARG2(scan);  /* max to match */
	    paren = scan->flags;
	    if (paren) {
		if (paren > PL_regsize)
		    PL_regsize = paren;
		if (paren > *PL_reglastparen)
		    *PL_reglastparen = paren;
	    }
	    scan = NEXTOPER(scan) + NODE_STEP_REGNODE;
	    if (paren)
		scan += NEXT_OFF(scan); /* Skip former OPEN. */
	    PL_reginput = locinput;
	    if (minmod) {
		minmod = 0;
		if (ln && regrepeat_hard(scan, ln, &l) < ln)
		    sayNO;
		if (ln && l == 0 && n >= ln
		    /* In fact, this is tricky.  If paren, then the
		       fact that we did/didnot match may influence
		       future execution. */
		    && !(paren && ln == 0))
		    ln = n;
		locinput = PL_reginput;
		if (regkind[(U8)OP(next)] == EXACT) {
		    c1 = UCHARAT(OPERAND(next) + 1);
		    if (OP(next) == EXACTF)
			c2 = fold[c1];
		    else if (OP(next) == EXACTFL)
			c2 = fold_locale[c1];
		    else
			c2 = c1;
		} else
		    c1 = c2 = -1000;
		REGCP_SET;
		/* This may be improved if l == 0.  */
		while (n >= ln || (n == REG_INFTY && ln > 0 && l)) { /* ln overflow ? */
		    /* If it could work, try it. */
		    if (c1 == -1000 ||
			UCHARAT(PL_reginput) == c1 ||
			UCHARAT(PL_reginput) == c2)
		    {
			if (paren) {
			    if (n) {
				PL_regstartp[paren] = PL_reginput - l;
				PL_regendp[paren] = PL_reginput;
			    } else
				PL_regendp[paren] = NULL;
			}
			if (regmatch(next))
			    sayYES;
			REGCP_UNWIND;
		    }
		    /* Couldn't or didn't -- move forward. */
		    PL_reginput = locinput;
		    if (regrepeat_hard(scan, 1, &l)) {
			ln++;
			locinput = PL_reginput;
		    }
		    else
			sayNO;
		}
	    } else {
		n = regrepeat_hard(scan, n, &l);
		if (n != 0 && l == 0
		    /* In fact, this is tricky.  If paren, then the
		       fact that we did/didnot match may influence
		       future execution. */
		    && !(paren && ln == 0))
		    ln = n;
		locinput = PL_reginput;
		DEBUG_r(
		    PerlIO_printf(Perl_debug_log,
				  "%*s  matched %ld times, len=%ld...\n",
				  REPORT_CODE_OFF+PL_regindent*2, "", n, l)
		    );
		if (n >= ln) {
		    if (regkind[(U8)OP(next)] == EXACT) {
			c1 = UCHARAT(OPERAND(next) + 1);
			if (OP(next) == EXACTF)
			    c2 = fold[c1];
			else if (OP(next) == EXACTFL)
			    c2 = fold_locale[c1];
			else
			    c2 = c1;
		    } else
			c1 = c2 = -1000;
		}
		REGCP_SET;
		while (n >= ln) {
		    /* If it could work, try it. */
		    if (c1 == -1000 ||
			UCHARAT(PL_reginput) == c1 ||
			UCHARAT(PL_reginput) == c2)
			{
			    DEBUG_r(
				PerlIO_printf(Perl_debug_log,
					      "%*s  trying tail with n=%ld...\n",
					      REPORT_CODE_OFF+PL_regindent*2, "", n)
				);
			    if (paren) {
				if (n) {
				    PL_regstartp[paren] = PL_reginput - l;
				    PL_regendp[paren] = PL_reginput;
				} else
				    PL_regendp[paren] = NULL;
			    }
			    if (regmatch(next))
				sayYES;
			    REGCP_UNWIND;
			}
		    /* Couldn't or didn't -- back up. */
		    n--;
		    locinput -= l;
		    PL_reginput = locinput;
		}
	    }
	    sayNO;
	    break;
	}
	case CURLYN:
	    paren = scan->flags;	/* Which paren to set */
	    if (paren > PL_regsize)
		PL_regsize = paren;
	    if (paren > *PL_reglastparen)
		*PL_reglastparen = paren;
	    ln = ARG1(scan);  /* min to match */
	    n  = ARG2(scan);  /* max to match */
            scan = regnext(NEXTOPER(scan) + NODE_STEP_REGNODE);
	    goto repeat;
a913 1
	    paren = 0;
d916 1
a916 1
	    scan = NEXTOPER(scan) + NODE_STEP_REGNODE;
d920 1
a920 1
	    n = REG_INFTY;
a921 1
	    paren = 0;
a923 5
	    ln = 1;
	    n = REG_INFTY;
	    scan = NEXTOPER(scan);
	    paren = 0;
	  repeat:
d928 6
a933 9
	    if (regkind[(U8)OP(next)] == EXACT) {
		c1 = UCHARAT(OPERAND(next) + 1);
		if (OP(next) == EXACTF)
		    c2 = fold[c1];
		else if (OP(next) == EXACTFL)
		    c2 = fold_locale[c1];
		else
		    c2 = c1;
	    }
d935 2
a936 2
		c1 = c2 = -1000;
	    PL_reginput = locinput;
a937 1
		CHECKPOINT lastcp;
d941 1
a941 2
		REGCP_SET;
		while (n >= ln || (n == REG_INFTY && ln > 0)) { /* ln overflow ? */
d943 1
a943 11
		    if (c1 == -1000 ||
			UCHARAT(PL_reginput) == c1 ||
			UCHARAT(PL_reginput) == c2)
		    {
			if (paren) {
			    if (n) {
				PL_regstartp[paren] = PL_reginput - 1;
				PL_regendp[paren] = PL_reginput;
			    } else
				PL_regendp[paren] = NULL;
			}
d946 2
a947 4
			REGCP_UNWIND;
		    }
		    /* Couldn't or didn't -- move forward. */
		    PL_reginput = locinput + ln;
d950 3
a952 2
			PL_reginput = locinput + ln;
		    } else
a956 1
		CHECKPOINT lastcp;
d959 1
a959 1
		    (!PL_multiline  || OP(next) == SEOL))
d961 8
a968 38
		REGCP_SET;
		if (paren) {
		    while (n >= ln) {
			/* If it could work, try it. */
			if (c1 == -1000 ||
			    UCHARAT(PL_reginput) == c1 ||
			    UCHARAT(PL_reginput) == c2)
			    {
				if (paren && n) {
				    if (n) {
					PL_regstartp[paren] = PL_reginput - 1;
					PL_regendp[paren] = PL_reginput;
				    } else
					PL_regendp[paren] = NULL;
				}
				if (regmatch(next))
				    sayYES;
				REGCP_UNWIND;
			    }
			/* Couldn't or didn't -- back up. */
			n--;
			PL_reginput = locinput + n;
		    }
		} else {
		    while (n >= ln) {
			/* If it could work, try it. */
			if (c1 == -1000 ||
			    UCHARAT(PL_reginput) == c1 ||
			    UCHARAT(PL_reginput) == c2)
			    {
				if (regmatch(next))
				    sayYES;
				REGCP_UNWIND;
			    }
			/* Couldn't or didn't -- back up. */
			n--;
			PL_reginput = locinput + n;
		    }
d972 1
a972 1
	    break;
d974 1
a974 5
	    if (locinput < PL_regtill)
		sayNO;			/* Cannot match: too short. */
	    /* Fall through */
	case SUCCEED:
	    PL_reginput = locinput;	/* put where regtry can find it */
d976 6
a981 4
	case SUSPEND:
	    n = 1;
	    PL_reginput = locinput;
	    goto do_ifmatch;	    
d983 4
a986 35
	    n = 0;
	    if (locinput < PL_bostr + scan->flags) 
		goto say_yes;
	    goto do_ifmatch;
	case IFMATCH:
	    n = 1;
	    if (locinput < PL_bostr + scan->flags) 
		goto say_no;
	  do_ifmatch:
	    PL_reginput = locinput - scan->flags;
	    inner = NEXTOPER(NEXTOPER(scan));
	    if (regmatch(inner) != n) {
	      say_no:
		if (logical) {
		    logical = 0;
		    sw = 0;
		    goto do_longjump;
		} else
		    sayNO;
	    }
	  say_yes:
	    if (logical) {
		logical = 0;
		sw = 1;
	    }
	    if (OP(scan) == SUSPEND) {
		locinput = PL_reginput;
		nextchr = UCHARAT(locinput);
	    }
	    /* FALL THROUGH. */
	case LONGJMP:
	  do_longjump:
	    next = scan + ARG(scan);
	    if (next == scan)
		next = NULL;
d989 1
a989 2
	    PerlIO_printf(PerlIO_stderr(), "%lx %d\n",
			  (unsigned long)scan, OP(scan));
d1005 1
a1005 1
    PL_regindent--;
d1011 1
a1011 1
    PL_regindent--;
d1024 4
a1027 2
STATIC I32
regrepeat(regnode *p, I32 max)
a1028 1
    dTHR;
d1032 1
a1032 1
    register char *loceol = PL_regeol;
d1034 2
a1035 2
    scan = PL_reginput;
    if (max != REG_INFTY && max < loceol - scan)
d1037 1
a1037 1
    opnd = (char *) OPERAND(p);
d1046 3
a1048 16
    case EXACT:		/* length of string is 1 */
	c = UCHARAT(++opnd);
	while (scan < loceol && UCHARAT(scan) == c)
	    scan++;
	break;
    case EXACTF:	/* length of string is 1 */
	c = UCHARAT(++opnd);
	while (scan < loceol &&
	       (UCHARAT(scan) == c || UCHARAT(scan) == fold[c]))
	    scan++;
	break;
    case EXACTFL:	/* length of string is 1 */
	PL_reg_flags |= RF_tainted;
	c = UCHARAT(++opnd);
	while (scan < loceol &&
	       (UCHARAT(scan) == c || UCHARAT(scan) == fold_locale[c]))
d1052 2
a1053 1
	while (scan < loceol && REGINCLASS(opnd, *scan))
d1055 2
a1061 5
    case ALNUML:
	PL_reg_flags |= RF_tainted;
	while (scan < loceol && isALNUM_LC(*scan))
	    scan++;
	break;
a1065 5
    case NALNUML:
	PL_reg_flags |= RF_tainted;
	while (scan < loceol && !isALNUM_LC(*scan))
	    scan++;
	break;
a1069 5
    case SPACEL:
	PL_reg_flags |= RF_tainted;
	while (scan < loceol && isSPACE_LC(*scan))
	    scan++;
	break;
a1073 5
    case NSPACEL:
	PL_reg_flags |= RF_tainted;
	while (scan < loceol && !isSPACE_LC(*scan))
	    scan++;
	break;
d1086 2
a1087 2
    c = scan - PL_reginput;
    PL_reginput = scan;
a1088 10
    DEBUG_r( 
	{
		SV *prop = sv_newmortal();

		regprop(prop, p);
		PerlIO_printf(Perl_debug_log, 
			      "%*s  %s can match %ld times out of %ld...\n", 
			      REPORT_CODE_OFF+1, "", SvPVX(prop),c,max);
	});
    
d1093 4
a1096 3
 - regrepeat_hard - repeatedly match something, report total lenth and length
 * 
 * The repeater is supposed to have constant length.
d1098 3
a1100 3

STATIC I32
regrepeat_hard(regnode *p, I32 max, I32 *lp)
d1102 1
a1102 6
    dTHR;
    register char *scan;
    register char *start;
    register char *loceol = PL_regeol;
    I32 l = 0;
    I32 count = 0, res = 1;
d1104 2
a1105 2
    if (!max)
	return 0;
d1107 3
a1109 15
    start = PL_reginput;
    while (PL_reginput < loceol && (scan = PL_reginput, res = regmatch(p))) {
	if (!count++) {
	    *lp = l = PL_reginput - start;
	    if (max != REG_INFTY && l*max < loceol - scan)
		loceol = scan + l*max;
	    if (l == 0)
		return max;
	}
    }
    if (!res)
	PL_reginput = scan;
    
    return count;
}
d1111 8
a1118 39
/*
 - regclass - determine if a character falls into a character class
 */

STATIC bool
reginclass(register char *p, register I32 c)
{
    dTHR;
    char flags = *p;
    bool match = FALSE;

    c &= 0xFF;
    if (ANYOF_TEST(p, c))
	match = TRUE;
    else if (flags & ANYOF_FOLD) {
	I32 cf;
	if (flags & ANYOF_LOCALE) {
	    PL_reg_flags |= RF_tainted;
	    cf = fold_locale[c];
	}
	else
	    cf = fold[c];
	if (ANYOF_TEST(p, cf))
	    match = TRUE;
    }

    if (!match && (flags & ANYOF_ISA)) {
	PL_reg_flags |= RF_tainted;

	if (((flags & ANYOF_ALNUML)  && isALNUM_LC(c))  ||
	    ((flags & ANYOF_NALNUML) && !isALNUM_LC(c)) ||
	    ((flags & ANYOF_SPACEL)  && isSPACE_LC(c))  ||
	    ((flags & ANYOF_NSPACEL) && !isSPACE_LC(c)))
	{
	    match = TRUE;
	}
    }

    return (flags & ANYOF_INVERT) ? !match : match;
a1119 3



@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d28 1
a28 1
#  if defined(PERL_EXT_RE_DEBUG) && !defined(DEBUGGING)
a37 1
#  define Perl_re_intuit_start my_re_intuit_start
a39 3
#  define Perl_reginitcolors my_reginitcolors 

#  define PERL_NO_GET_CONTEXT
d65 1
a65 1
 ****    Copyright (c) 1991-2000, Larry Wall
a74 1
#define PERL_IN_REGEXEC_C
a75 7

#ifdef PERL_IN_XSUB_RE
#  if defined(PERL_CAPI) || defined(PERL_OBJECT)
#    include "XSUB.h"
#  endif
#endif

a80 3
#define RF_utf8		8		/* String contains multibyte chars? */

#define UTF (PL_reg_flags & RF_utf8)
d89 3
d96 10
a105 15
#define REGINCLASS(p,c)  (ANYOF_FLAGS(p) ? reginclass(p,c) : ANYOF_BITMAP_TEST(p,c))
#define REGINCLASSUTF8(f,p)  (ARG1(f) ? reginclassutf8(f,p) : swash_fetch((SV*)PL_regdata->data[ARG2(f)],p))

#define CHR_SVLEN(sv) (UTF ? sv_len_utf8(sv) : SvCUR(sv))
#define CHR_DIST(a,b) (UTF ? utf8_distance(a,b) : a - b)

#define reghop_c(pos,off) ((char*)reghop((U8*)pos, off))
#define reghopmaybe_c(pos,off) ((char*)reghopmaybe((U8*)pos, off))
#define HOP(pos,off) (UTF ? reghop((U8*)pos, off) : (U8*)(pos + off))
#define HOPMAYBE(pos,off) (UTF ? reghopmaybe((U8*)pos, off) : (U8*)(pos + off))
#define HOPc(pos,off) ((char*)HOP(pos,off))
#define HOPMAYBEc(pos,off) ((char*)HOPMAYBE(pos,off))

static void restore_pos(pTHXo_ void *arg);

d108 1
a108 1
S_regcppush(pTHX_ I32 parenfloor)
d117 2
a118 2
	SSPUSHINT(PL_regendp[p]);
	SSPUSHINT(PL_regstartp[p]);
d132 2
a133 2
			     "  Setting an EVAL scope, savestack=%"IVdf"\n",	\
			     (IV)PL_savestack_ix)); lastcp = PL_savestack_ix
d137 2
a138 2
				"  Clearing an EVAL scope, savestack=%"IVdf"..%"IVdf"\n", \
				(IV)lastcp, (IV)PL_savestack_ix) : 0); regcpblow(lastcp)
d141 1
a141 1
S_regcppop(pTHX)
d147 1
a147 1
    I32 tmps;
d156 2
a157 2
	PL_regstartp[paren] = SSPOPINT;
	tmps = SSPOPINT;
d162 4
a165 4
			  "     restoring \\%"UVuf" to %"IVdf"(%"IVdf")..%"IVdf"%s\n",
			  (UV)paren, (IV)PL_regstartp[paren], 
			  (IV)(PL_reg_start_tmp[paren] - PL_bostr),
			  (IV)PL_regendp[paren], 
d172 2
a173 2
			  "     restoring \\%"IVdf"..\\%"IVdf" to undef\n",
			  (IV)(*PL_reglastparen + 1), (IV)PL_regnpar);
d178 2
a179 2
	    PL_regstartp[paren] = -1;
	PL_regendp[paren] = -1;
a183 21
STATIC char *
S_regcp_set_to(pTHX_ I32 ss)
{
    dTHR;
    I32 tmp = PL_savestack_ix;

    PL_savestack_ix = ss;
    regcppop();
    PL_savestack_ix = tmp;
    return Nullch;
}

typedef struct re_cc_state
{
    I32 ss;
    regnode *node;
    struct re_cc_state *prev;
    CURCUR *cc;
    regexp *re;
} re_cc_state;

d194 1
a194 1
Perl_pregexec(pTHX_ register regexp *prog, char *stringarg, register char *strend,
d205 12
a216 3

STATIC void
S_cache_re(pTHX_ regexp *prog)
d219 19
a237 1
    PL_regprecomp = prog->precomp;		/* Needed for FAIL. */
d239 1
a241 4
    PL_regnpar = prog->nparens;
    PL_regdata = prog->data;    
    PL_reg_re = prog;    
}
d243 5
a247 13
/* 
 * Need to implement the following flags for reg_anch:
 *
 * USE_INTUIT_NOML		- Useful to call re_intuit_start() first
 * USE_INTUIT_ML
 * INTUIT_AUTORITATIVE_NOML	- Can trust a positive answer
 * INTUIT_AUTORITATIVE_ML
 * INTUIT_ONCE_NOML		- Intuit can match in one location only.
 * INTUIT_ONCE_ML
 *
 * Another flag for this function: SECOND_TIME (so that float substrs
 * with giant delta may be not rechecked).
 */
d249 2
a250 1
/* Assumptions: if ANCH_GPOS, then strpos is anchored. XXXX Check GPOS logic */
d252 7
a258 2
/* If SCREAM, then SvPVX(sv) should be compatible with strpos and strend.
   Otherwise, only SvCUR(sv) is used to get strbeg. */
d260 4
a263 1
/* XXXX We assume that strpos is strbeg unless sv. */
d265 3
a267 20
/* XXXX Some places assume that there is a fixed substring.
	An update may be needed if optimizer marks as "INTUITable"
	RExen without fixed substrings.  Similarly, it is assumed that
	lengths of all the strings are no more than minlen, thus they
	cannot come from lookahead.
	(Or minlen should take into account lookahead.) */

/* A failure to find a constant substring means that there is no need to make
   an expensive call to REx engine, thus we celebrate a failure.  Similarly,
   finding a substring too deep into the string means that less calls to
   regtry() should be needed.

   REx compiler's optimizer found 4 possible hints:
	a) Anchored substring;
	b) Fixed substring;
	c) Whether we are anchored (beginning-of-line or \G);
	d) First node (of those at offset 0) which may distingush positions;
   We use a)b)d) and multiline-part of c), and try to find a position in the
   string which does not contradict any of them.
 */
d269 39
a307 21
/* Most of decisions we do here should have been done at compile time.
   The nodes of the REx which we used for the search should have been
   deleted from the finite automaton. */

char *
Perl_re_intuit_start(pTHX_ regexp *prog, SV *sv, char *strpos,
		     char *strend, U32 flags, re_scream_pos_data *data)
{
    register I32 start_shift;
    /* Should be nonnegative! */
    register I32 end_shift;
    register char *s;
    register SV *check;
    char *t;
    I32 ml_anch;
    char *tmp;
    register char *other_last = Nullch;	/* other substr checked before this */
    char *check_at;			/* check substr found at this pos */
#ifdef DEBUGGING
    char *i_strpos = strpos;
#endif
d309 3
a311 12
    DEBUG_r( if (!PL_colorset) reginitcolors() );
    DEBUG_r(PerlIO_printf(Perl_debug_log,
		      "%sGuessing start of match, REx%s `%s%.60s%s%s' against `%s%.*s%s%s'...\n",
		      PL_colors[4],PL_colors[5],PL_colors[0],
		      prog->precomp,
		      PL_colors[1],
		      (strlen(prog->precomp) > 60 ? "..." : ""),
		      PL_colors[0],
		      (int)(strend - strpos > 60 ? 60 : strend - strpos),
		      strpos, PL_colors[1],
		      (strend - strpos > 60 ? "..." : ""))
	);
d313 2
a314 54
    if (prog->minlen > strend - strpos) {
	DEBUG_r(PerlIO_printf(Perl_debug_log, "String too short...\n"));
	goto fail;
    }
    check = prog->check_substr;
    if (prog->reganch & ROPT_ANCH) {	/* Match at beg-of-str or after \n */
	ml_anch = !( (prog->reganch & ROPT_ANCH_SINGLE)
		     || ( (prog->reganch & ROPT_ANCH_BOL)
			  && !PL_multiline ) );	/* Check after \n? */

	if ((prog->check_offset_min == prog->check_offset_max) && !ml_anch) {
	    /* Substring at constant offset from beg-of-str... */
	    I32 slen;

	    if ( !(prog->reganch & ROPT_ANCH_GPOS) /* Checked by the caller */
		 && (sv && (strpos + SvCUR(sv) != strend)) ) {
		DEBUG_r(PerlIO_printf(Perl_debug_log, "Not at start...\n"));
		goto fail;
	    }
	    PL_regeol = strend;			/* Used in HOP() */
	    s = HOPc(strpos, prog->check_offset_min);
	    if (SvTAIL(check)) {
		slen = SvCUR(check);	/* >= 1 */

		if ( strend - s > slen || strend - s < slen - 1 
		     || (strend - s == slen && strend[-1] != '\n')) {
		    DEBUG_r(PerlIO_printf(Perl_debug_log, "String too long...\n"));
		    goto fail_finish;
		}
		/* Now should match s[0..slen-2] */
		slen--;
		if (slen && (*SvPVX(check) != *s
			     || (slen > 1
				 && memNE(SvPVX(check), s, slen)))) {
		  report_neq:
		    DEBUG_r(PerlIO_printf(Perl_debug_log, "String not equal...\n"));
		    goto fail_finish;
		}
	    }
	    else if (*SvPVX(check) != *s
		     || ((slen = SvCUR(check)) > 1
			 && memNE(SvPVX(check), s, slen)))
		goto report_neq;
	    goto success_at_start;
	}
	/* Match is anchored, but substr is not anchored wrt beg-of-str. */
	s = strpos;
	start_shift = prog->check_offset_min; /* okay to underestimate on CC */
	end_shift = prog->minlen - start_shift -
	    CHR_SVLEN(check) + (SvTAIL(check) != 0);
	if (!ml_anch) {
	    I32 end = prog->check_offset_max + CHR_SVLEN(check)
					 - (SvTAIL(check) != 0);
	    I32 eshift = strend - s - end;
d316 2
a317 12
	    if (end_shift < eshift)
		end_shift = eshift;
	}
    }
    else {				/* Can match at random position */
	ml_anch = 0;
	s = strpos;
	start_shift = prog->check_offset_min; /* okay to underestimate on CC */
	/* Should be nonnegative! */
	end_shift = prog->minlen - start_shift -
	    CHR_SVLEN(check) + (SvTAIL(check) != 0);
    }
d319 9
a327 4
#ifdef DEBUGGING	/* 7/99: reports of failure (with the older version) */
    if (end_shift < 0)
	Perl_croak(aTHX_ "panic: end_shift");
#endif
d329 19
a347 117
  restart:
    /* Find a possible match in the region s..strend by looking for
       the "check" substring in the region corrected by start/end_shift. */
    if (flags & REXEC_SCREAM) {
	char *strbeg = SvPVX(sv);	/* XXXX Assume PV_force() on SCREAM! */
	I32 p = -1;			/* Internal iterator of scream. */
	I32 *pp = data ? data->scream_pos : &p;

	if (PL_screamfirst[BmRARE(check)] >= 0
	    || ( BmRARE(check) == '\n'
		 && (BmPREVIOUS(check) == SvCUR(check) - 1)
		 && SvTAIL(check) ))
	    s = screaminstr(sv, check, 
			    start_shift + (s - strbeg), end_shift, pp, 0);
	else
	    goto fail_finish;
	if (data)
	    *data->scream_olds = s;
    }
    else
	s = fbm_instr((unsigned char*)s + start_shift,
		      (unsigned char*)strend - end_shift,
		      check, PL_multiline ? FBMrf_MULTILINE : 0);

    /* Update the count-of-usability, remove useless subpatterns,
	unshift s.  */

    DEBUG_r(PerlIO_printf(Perl_debug_log, "%s %s substr `%s%.*s%s'%s%s",
			  (s ? "Found" : "Did not find"),
			  ((check == prog->anchored_substr) ? "anchored" : "floating"),
			  PL_colors[0],
			  (int)(SvCUR(check) - (SvTAIL(check)!=0)),
			  SvPVX(check),
			  PL_colors[1], (SvTAIL(check) ? "$" : ""),
			  (s ? " at offset " : "...\n") ) );

    if (!s)
	goto fail_finish;

    check_at = s;

    /* Finish the diagnostic message */
    DEBUG_r(PerlIO_printf(Perl_debug_log, "%ld...\n", (long)(s - i_strpos)) );

    /* Got a candidate.  Check MBOL anchoring, and the *other* substr.
       Start with the other substr.
       XXXX no SCREAM optimization yet - and a very coarse implementation
       XXXX /ttx+/ results in anchored=`ttx', floating=`x'.  floating will
		*always* match.  Probably should be marked during compile...
       Probably it is right to do no SCREAM here...
     */

    if (prog->float_substr && prog->anchored_substr) {
	/* Take into account the "other" substring. */
	/* XXXX May be hopelessly wrong for UTF... */
	if (!other_last)
	    other_last = strpos;
	if (check == prog->float_substr) {
	  do_other_anchored:
	    {
		char *last = s - start_shift, *last1, *last2;
		char *s1 = s;

		tmp = PL_bostr;
		t = s - prog->check_offset_max;
		if (s - strpos > prog->check_offset_max  /* signed-corrected t > strpos */
		    && (!(prog->reganch & ROPT_UTF8)
			|| (PL_bostr = strpos, /* Used in regcopmaybe() */
			    (t = reghopmaybe_c(s, -(prog->check_offset_max)))
			    && t > strpos)))
		    /* EMPTY */;
		else
		    t = strpos;
		t += prog->anchored_offset;
		if (t < other_last)	/* These positions already checked */
		    t = other_last;
		PL_bostr = tmp;
		last2 = last1 = strend - prog->minlen;
		if (last < last1)
		    last1 = last;
 /* XXXX It is not documented what units *_offsets are in.  Assume bytes.  */
		/* On end-of-str: see comment below. */
		s = fbm_instr((unsigned char*)t,
			      (unsigned char*)last1 + prog->anchored_offset
				 + SvCUR(prog->anchored_substr)
				 - (SvTAIL(prog->anchored_substr)!=0),
			      prog->anchored_substr, PL_multiline ? FBMrf_MULTILINE : 0);
		DEBUG_r(PerlIO_printf(Perl_debug_log, "%s anchored substr `%s%.*s%s'%s",
			(s ? "Found" : "Contradicts"),
			PL_colors[0],
			  (int)(SvCUR(prog->anchored_substr)
			  - (SvTAIL(prog->anchored_substr)!=0)),
			  SvPVX(prog->anchored_substr),
			  PL_colors[1], (SvTAIL(prog->anchored_substr) ? "$" : "")));
		if (!s) {
		    if (last1 >= last2) {
			DEBUG_r(PerlIO_printf(Perl_debug_log,
						", giving up...\n"));
			goto fail_finish;
		    }
		    DEBUG_r(PerlIO_printf(Perl_debug_log,
			", trying floating at offset %ld...\n",
			(long)(s1 + 1 - i_strpos)));
		    PL_regeol = strend;			/* Used in HOP() */
		    other_last = last1 + prog->anchored_offset + 1;
		    s = HOPc(last, 1);
		    goto restart;
		}
		else {
		    DEBUG_r(PerlIO_printf(Perl_debug_log, " at offset %ld...\n",
			  (long)(s - i_strpos)));
		    t = s - prog->anchored_offset;
		    other_last = s + 1;
		    s = s1;
		    if (t == strpos)
			goto try_at_start;
		    goto try_at_offset;
d351 1
a351 50
	else {		/* Take into account the floating substring. */
		char *last, *last1;
		char *s1 = s;

		t = s - start_shift;
		last1 = last = strend - prog->minlen + prog->float_min_offset;
		if (last - t > prog->float_max_offset)
		    last = t + prog->float_max_offset;
		s = t + prog->float_min_offset;
		if (s < other_last)
		    s = other_last;
 /* XXXX It is not documented what units *_offsets are in.  Assume bytes.  */
		/* fbm_instr() takes into account exact value of end-of-str
		   if the check is SvTAIL(ed).  Since false positives are OK,
		   and end-of-str is not later than strend we are OK. */
		s = fbm_instr((unsigned char*)s,
			      (unsigned char*)last + SvCUR(prog->float_substr)
				  - (SvTAIL(prog->float_substr)!=0),
			      prog->float_substr, PL_multiline ? FBMrf_MULTILINE : 0);
		DEBUG_r(PerlIO_printf(Perl_debug_log, "%s floating substr `%s%.*s%s'%s",
			(s ? "Found" : "Contradicts"),
			PL_colors[0],
			  (int)(SvCUR(prog->float_substr)
			  - (SvTAIL(prog->float_substr)!=0)),
			  SvPVX(prog->float_substr),
			  PL_colors[1], (SvTAIL(prog->float_substr) ? "$" : "")));
		if (!s) {
		    if (last1 == last) {
			DEBUG_r(PerlIO_printf(Perl_debug_log,
						", giving up...\n"));
			goto fail_finish;
		    }
		    DEBUG_r(PerlIO_printf(Perl_debug_log,
			", trying anchored starting at offset %ld...\n",
			(long)(s1 + 1 - i_strpos)));
		    other_last = last + 1;
		    PL_regeol = strend;			/* Used in HOP() */
		    s = HOPc(t, 1);
		    goto restart;
		}
		else {
		    DEBUG_r(PerlIO_printf(Perl_debug_log, " at offset %ld...\n",
			  (long)(s - i_strpos)));
		    other_last = s + 1;
		    s = s1;
		    if (t == strpos)
			goto try_at_start;
		    goto try_at_offset;
		}
	}
d354 13
a366 49
    t = s - prog->check_offset_max;
    tmp = PL_bostr;
    if (s - strpos > prog->check_offset_max  /* signed-corrected t > strpos */
        && (!(prog->reganch & ROPT_UTF8)
	    || (PL_bostr = strpos, /* Used in regcopmaybe() */
		((t = reghopmaybe_c(s, -(prog->check_offset_max)))
		 && t > strpos)))) {
	PL_bostr = tmp;
	/* Fixed substring is found far enough so that the match
	   cannot start at strpos. */
      try_at_offset:
	if (ml_anch && t[-1] != '\n') {
	    /* Eventually fbm_*() should handle this, but often
	       anchored_offset is not 0, so this check will not be wasted. */
	    /* XXXX In the code below we prefer to look for "^" even in
	       presence of anchored substrings.  And we search even
	       beyond the found float position.  These pessimizations
	       are historical artefacts only.  */
	  find_anchor:
	    while (t < strend - prog->minlen) {
		if (*t == '\n') {
		    if (t < s - prog->check_offset_min) {
			if (prog->anchored_substr) {
			    /* We definitely contradict the found anchored
			       substr.  Due to the above check we do not
			       contradict "check" substr.
			       Thus we can arrive here only if check substr
			       is float.  Redo checking for "other"=="fixed".
			     */
			    strpos = t + 1;			    
			    DEBUG_r(PerlIO_printf(Perl_debug_log, "Found /%s^%s/m at offset %ld, rescanning for anchored from offset %ld...\n",
				PL_colors[0],PL_colors[1], (long)(strpos - i_strpos), (long)(strpos - i_strpos + prog->anchored_offset)));
			    goto do_other_anchored;
			}
			s = t + 1;
			DEBUG_r(PerlIO_printf(Perl_debug_log, "Found /%s^%s/m at offset %ld...\n",
			    PL_colors[0],PL_colors[1], (long)(s - i_strpos)));
			goto set_useful;
		    }
		    DEBUG_r(PerlIO_printf(Perl_debug_log, "Found /%s^%s/m, restarting at offset %ld...\n",
			PL_colors[0],PL_colors[1], (long)(t + 1 - i_strpos)));
		    strpos = s = t + 1;
		    goto restart;
		}
		t++;
	    }
	    DEBUG_r(PerlIO_printf(Perl_debug_log, "Did not find /%s^%s/m...\n",
			PL_colors[0],PL_colors[1]));
	    goto fail_finish;
a367 42
	s = t;
      set_useful:
	++BmUSEFUL(prog->check_substr);	/* hooray/5 */
    }
    else {
	PL_bostr = tmp;
	/* The found string does not prohibit matching at beg-of-str
	   - no optimization of calling REx engine can be performed,
	   unless it was an MBOL and we are not after MBOL. */
      try_at_start:
	/* Even in this situation we may use MBOL flag if strpos is offset
	   wrt the start of the string. */
	if (ml_anch && sv
	    && (strpos + SvCUR(sv) != strend) && strpos[-1] != '\n'
	    /* May be due to an implicit anchor of m{.*foo}  */
	    && !(prog->reganch & ROPT_IMPLICIT))
	{
	    t = strpos;
	    goto find_anchor;
	}
	DEBUG_r( if (ml_anch)
	    PerlIO_printf(Perl_debug_log, "Does not contradict /%s^%s/m...\n",
			PL_colors[0],PL_colors[1]);
	);
      success_at_start:
	if (!(prog->reganch & ROPT_NAUGHTY)	/* XXXX If strpos moved? */
	    && prog->check_substr		/* Could be deleted already */
	    && --BmUSEFUL(prog->check_substr) < 0
	    && prog->check_substr == prog->float_substr)
	{
	    /* If flags & SOMETHING - do not do it many times on the same match */
	    SvREFCNT_dec(prog->check_substr);
	    prog->check_substr = Nullsv;	/* disable */
	    prog->float_substr = Nullsv;	/* clear */
	    s = strpos;
	    /* XXXX This is a remnant of the old implementation.  It
	            looks wasteful, since now INTUIT can use many
	            other heuristics. */
	    prog->reganch &= ~RE_USE_INTUIT;
	}
	else
	    s = strpos;
d369 30
d400 8
a407 24
    /* Last resort... */
    /* XXXX BmUSEFUL already changed, maybe multiple change is meaningful... */
    if (prog->regstclass) {
	/* minlen == 0 is possible if regstclass is \b or \B,
	   and the fixed substr is ''$.
	   Since minlen is already taken into account, s+1 is before strend;
	   accidentally, minlen >= 1 guaranties no false positives at s + 1
	   even for \b or \B.  But (minlen? 1 : 0) below assumes that
	   regstclass does not come from lookahead...  */
	/* If regstclass takes bytelength more than 1: If charlength==1, OK.
	   This leaves EXACTF only, which is dealt with in find_byclass().  */
	int cl_l = (PL_regkind[(U8)OP(prog->regstclass)] == EXACT
		    ? STR_LEN(prog->regstclass)
		    : 1);
	char *endpos = (prog->anchored_substr || ml_anch)
		? s + (prog->minlen? cl_l : 0)
		: (prog->float_substr ? check_at - start_shift + cl_l
				      : strend) ;
	char *startpos = sv && SvPOK(sv) ? strend - SvCUR(sv) : s;

	t = s;
	if (prog->reganch & ROPT_UTF8) {	
	    PL_regdata = prog->data;	/* Used by REGINCLASS UTF logic */
	    PL_bostr = startpos;
d409 2
a410 84
        s = find_byclass(prog, prog->regstclass, s, endpos, startpos, 1);
	if (!s) {
#ifdef DEBUGGING
	    char *what;
#endif
	    if (endpos == strend) {
		DEBUG_r( PerlIO_printf(Perl_debug_log,
				"Could not match STCLASS...\n") );
		goto fail;
	    }
	    DEBUG_r( PerlIO_printf(Perl_debug_log,
				   "This position contradicts STCLASS...\n") );
	    if ((prog->reganch & ROPT_ANCH) && !ml_anch)
		goto fail;
	    /* Contradict one of substrings */
	    if (prog->anchored_substr) {
		if (prog->anchored_substr == check) {
		    DEBUG_r( what = "anchored" );
		  hop_and_restart:
		    PL_regeol = strend;	/* Used in HOP() */
		    s = HOPc(t, 1);
		    if (s + start_shift + end_shift > strend) {
			/* XXXX Should be taken into account earlier? */
			DEBUG_r( PerlIO_printf(Perl_debug_log,
					       "Could not match STCLASS...\n") );
			goto fail;
		    }
		    DEBUG_r( PerlIO_printf(Perl_debug_log,
				"Trying %s substr starting at offset %ld...\n",
				 what, (long)(s + start_shift - i_strpos)) );
		    goto restart;
		}
		/* Have both, check_string is floating */
		if (t + start_shift >= check_at) /* Contradicts floating=check */
		    goto retry_floating_check;
		/* Recheck anchored substring, but not floating... */
		s = check_at; 
		DEBUG_r( PerlIO_printf(Perl_debug_log,
			  "Trying anchored substr starting at offset %ld...\n",
			  (long)(other_last - i_strpos)) );
		goto do_other_anchored;
	    }
	    /* Another way we could have checked stclass at the
               current position only: */
	    if (ml_anch) {
		s = t = t + 1;
		DEBUG_r( PerlIO_printf(Perl_debug_log,
			  "Trying /^/m starting at offset %ld...\n",
			  (long)(t - i_strpos)) );
		goto try_at_offset;
	    }
	    if (!prog->float_substr)	/* Could have been deleted */
		goto fail;
	    /* Check is floating subtring. */
	  retry_floating_check:
	    t = check_at - start_shift;
	    DEBUG_r( what = "floating" );
	    goto hop_and_restart;
	}
	DEBUG_r( if (t != s)
		     PerlIO_printf(Perl_debug_log, 
			"By STCLASS: moving %ld --> %ld\n",
			(long)(t - i_strpos), (long)(s - i_strpos));
		 else
		     PerlIO_printf(Perl_debug_log, 
			"Does not contradict STCLASS...\n") );
    }
    DEBUG_r(PerlIO_printf(Perl_debug_log, "%sGuessed:%s match at offset %ld\n",
			  PL_colors[4], PL_colors[5], (long)(s - i_strpos)) );
    return s;

  fail_finish:				/* Substring not found */
    if (prog->check_substr)		/* could be removed already */
	BmUSEFUL(prog->check_substr) += 5; /* hooray */
  fail:
    DEBUG_r(PerlIO_printf(Perl_debug_log, "%sMatch rejected by optimizer%s\n",
			  PL_colors[4],PL_colors[5]));
    return Nullch;
}

/* We know what class REx starts with.  Try to find this position... */
STATIC char *
S_find_byclass(pTHX_ regexp * prog, regnode *c, char *s, char *strend, char *startpos, I32 norun)
{
d412 1
a412 6
	char *m;
	STRLEN ln;
	unsigned int c1;
	unsigned int c2;
	char *e;
	register I32 tmp = 1;	/* Scratch variable? */
d414 4
a419 13
	case ANYOFUTF8:
	    while (s < strend) {
		if (REGINCLASSUTF8(c, (U8*)s)) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
		    else
			tmp = doevery;
		}
		else
		    tmp = 1;
		s += UTF8SKIP(s);
	    }
	    break;
d421 1
d423 2
a424 2
		if (REGINCLASS(c, *(U8*)s)) {
		    if (tmp && (norun || regtry(prog, s)))
a433 39
	case EXACTF:
	    m = STRING(c);
	    ln = STR_LEN(c);
	    c1 = *(U8*)m;
	    c2 = PL_fold[c1];
	    goto do_exactf;
	case EXACTFL:
	    m = STRING(c);
	    ln = STR_LEN(c);
	    c1 = *(U8*)m;
	    c2 = PL_fold_locale[c1];
	  do_exactf:
	    e = strend - ln;

	    if (norun && e < s)
		e = s;			/* Due to minlen logic of intuit() */
	    /* Here it is NOT UTF!  */
	    if (c1 == c2) {
		while (s <= e) {
		    if ( *(U8*)s == c1
			 && (ln == 1 || !(OP(c) == EXACTF
					  ? ibcmp(s, m, ln)
					  : ibcmp_locale(s, m, ln)))
			 && (norun || regtry(prog, s)) )
			goto got_it;
		    s++;
		}
	    } else {
		while (s <= e) {
		    if ( (*(U8*)s == c1 || *(U8*)s == c2)
			 && (ln == 1 || !(OP(c) == EXACTF
					  ? ibcmp(s, m, ln)
					  : ibcmp_locale(s, m, ln)))
			 && (norun || regtry(prog, s)) )
			goto got_it;
		    s++;
		}
	    }
	    break;
d438 3
a440 1
	    tmp = (s != startpos) ? UCHARAT(s - 1) : '\n';
d445 1
a445 1
		    if ((norun || regtry(prog, s)))
d450 1
a450 21
	    if ((!prog->minlen && tmp) && (norun || regtry(prog, s)))
		goto got_it;
	    break;
	case BOUNDLUTF8:
	    PL_reg_flags |= RF_tainted;
	    /* FALL THROUGH */
	case BOUNDUTF8:
	    tmp = (I32)(s != startpos) ? utf8_to_uv(reghop((U8*)s, -1), 0) : '\n';
	    tmp = ((OP(c) == BOUNDUTF8 ? isALNUM_uni(tmp) : isALNUM_LC_uni(tmp)) != 0);
	    while (s < strend) {
		if (tmp == !(OP(c) == BOUNDUTF8 ?
			     swash_fetch(PL_utf8_alnum, (U8*)s) :
			     isALNUM_LC_utf8((U8*)s)))
		{
		    tmp = !tmp;
		    if ((norun || regtry(prog, s)))
			goto got_it;
		}
		s += UTF8SKIP(s);
	    }
	    if ((!prog->minlen && tmp) && (norun || regtry(prog, s)))
d457 3
a459 1
	    tmp = (s != startpos) ? UCHARAT(s - 1) : '\n';
d464 1
a464 1
		else if ((norun || regtry(prog, s)))
d468 1
a468 19
	    if ((!prog->minlen && !tmp) && (norun || regtry(prog, s)))
		goto got_it;
	    break;
	case NBOUNDLUTF8:
	    PL_reg_flags |= RF_tainted;
	    /* FALL THROUGH */
	case NBOUNDUTF8:
	    tmp = (I32)(s != startpos) ? utf8_to_uv(reghop((U8*)s, -1), 0) : '\n';
	    tmp = ((OP(c) == NBOUNDUTF8 ? isALNUM_uni(tmp) : isALNUM_LC_uni(tmp)) != 0);
	    while (s < strend) {
		if (tmp == !(OP(c) == NBOUNDUTF8 ?
			     swash_fetch(PL_utf8_alnum, (U8*)s) :
			     isALNUM_LC_utf8((U8*)s)))
		    tmp = !tmp;
		else if ((norun || regtry(prog, s)))
		    goto got_it;
		s += UTF8SKIP(s);
	    }
	    if ((!prog->minlen && !tmp) && (norun || regtry(prog, s)))
d474 1
a474 1
		    if (tmp && (norun || regtry(prog, s)))
a483 13
	case ALNUMUTF8:
	    while (s < strend) {
		if (swash_fetch(PL_utf8_alnum, (U8*)s)) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
		    else
			tmp = doevery;
		}
		else
		    tmp = 1;
		s += UTF8SKIP(s);
	    }
	    break;
d488 1
a488 1
		    if (tmp && (norun || regtry(prog, s)))
a497 14
	case ALNUMLUTF8:
	    PL_reg_flags |= RF_tainted;
	    while (s < strend) {
		if (isALNUM_LC_utf8((U8*)s)) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
		    else
			tmp = doevery;
		}
		else
		    tmp = 1;
		s += UTF8SKIP(s);
	    }
	    break;
d501 1
a501 1
		    if (tmp && (norun || regtry(prog, s)))
a510 13
	case NALNUMUTF8:
	    while (s < strend) {
		if (!swash_fetch(PL_utf8_alnum, (U8*)s)) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
		    else
			tmp = doevery;
		}
		else
		    tmp = 1;
		s += UTF8SKIP(s);
	    }
	    break;
d515 1
a515 388
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
		    else
			tmp = doevery;
		}
		else
		    tmp = 1;
		s++;
	    }
	    break;
	case NALNUMLUTF8:
	    PL_reg_flags |= RF_tainted;
	    while (s < strend) {
		if (!isALNUM_LC_utf8((U8*)s)) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
		    else
			tmp = doevery;
		}
		else
		    tmp = 1;
		s += UTF8SKIP(s);
	    }
	    break;
	case SPACE:
	    while (s < strend) {
		if (isSPACE(*s)) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
		    else
			tmp = doevery;
		}
		else
		    tmp = 1;
		s++;
	    }
	    break;
	case SPACEUTF8:
	    while (s < strend) {
		if (*s == ' ' || swash_fetch(PL_utf8_space,(U8*)s)) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
		    else
			tmp = doevery;
		}
		else
		    tmp = 1;
		s += UTF8SKIP(s);
	    }
	    break;
	case SPACEL:
	    PL_reg_flags |= RF_tainted;
	    while (s < strend) {
		if (isSPACE_LC(*s)) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
		    else
			tmp = doevery;
		}
		else
		    tmp = 1;
		s++;
	    }
	    break;
	case SPACELUTF8:
	    PL_reg_flags |= RF_tainted;
	    while (s < strend) {
		if (*s == ' ' || isSPACE_LC_utf8((U8*)s)) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
		    else
			tmp = doevery;
		}
		else
		    tmp = 1;
		s += UTF8SKIP(s);
	    }
	    break;
	case NSPACE:
	    while (s < strend) {
		if (!isSPACE(*s)) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
		    else
			tmp = doevery;
		}
		else
		    tmp = 1;
		s++;
	    }
	    break;
	case NSPACEUTF8:
	    while (s < strend) {
		if (!(*s == ' ' || swash_fetch(PL_utf8_space,(U8*)s))) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
		    else
			tmp = doevery;
		}
		else
		    tmp = 1;
		s += UTF8SKIP(s);
	    }
	    break;
	case NSPACEL:
	    PL_reg_flags |= RF_tainted;
	    while (s < strend) {
		if (!isSPACE_LC(*s)) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
		    else
			tmp = doevery;
		}
		else
		    tmp = 1;
		s++;
	    }
	    break;
	case NSPACELUTF8:
	    PL_reg_flags |= RF_tainted;
	    while (s < strend) {
		if (!(*s == ' ' || isSPACE_LC_utf8((U8*)s))) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
		    else
			tmp = doevery;
		}
		else
		    tmp = 1;
		s += UTF8SKIP(s);
	    }
	    break;
	case DIGIT:
	    while (s < strend) {
		if (isDIGIT(*s)) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
		    else
			tmp = doevery;
		}
		else
		    tmp = 1;
		s++;
	    }
	    break;
	case DIGITUTF8:
	    while (s < strend) {
		if (swash_fetch(PL_utf8_digit,(U8*)s)) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
		    else
			tmp = doevery;
		}
		else
		    tmp = 1;
		s += UTF8SKIP(s);
	    }
	    break;
	case DIGITL:
	    PL_reg_flags |= RF_tainted;
	    while (s < strend) {
		if (isDIGIT_LC(*s)) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
		    else
			tmp = doevery;
		}
		else
		    tmp = 1;
		s++;
	    }
	    break;
	case DIGITLUTF8:
	    PL_reg_flags |= RF_tainted;
	    while (s < strend) {
		if (isDIGIT_LC_utf8((U8*)s)) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
		    else
			tmp = doevery;
		}
		else
		    tmp = 1;
		s += UTF8SKIP(s);
	    }
	    break;
	case NDIGIT:
	    while (s < strend) {
		if (!isDIGIT(*s)) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
		    else
			tmp = doevery;
		}
		else
		    tmp = 1;
		s++;
	    }
	    break;
	case NDIGITUTF8:
	    while (s < strend) {
		if (!swash_fetch(PL_utf8_digit,(U8*)s)) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
		    else
			tmp = doevery;
		}
		else
		    tmp = 1;
		s += UTF8SKIP(s);
	    }
	    break;
	case NDIGITL:
	    PL_reg_flags |= RF_tainted;
	    while (s < strend) {
		if (!isDIGIT_LC(*s)) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
		    else
			tmp = doevery;
		}
		else
		    tmp = 1;
		s++;
	    }
	    break;
	case NDIGITLUTF8:
	    PL_reg_flags |= RF_tainted;
	    while (s < strend) {
		if (!isDIGIT_LC_utf8((U8*)s)) {
		    if (tmp && (norun || regtry(prog, s)))
			goto got_it;
		    else
			tmp = doevery;
		}
		else
		    tmp = 1;
		s += UTF8SKIP(s);
	    }
	    break;
	default:
	    Perl_croak(aTHX_ "panic: unknown regstclass %d", (int)OP(c));
	    break;
	}
	return 0;
      got_it:
	return s;
}

/*
 - regexec_flags - match a regexp against a string
 */
I32
Perl_regexec_flags(pTHX_ register regexp *prog, char *stringarg, register char *strend,
	      char *strbeg, I32 minend, SV *sv, void *data, U32 flags)
/* strend: pointer to null at end of string */
/* strbeg: real beginning of string */
/* minend: end of match must be >=minend after stringarg. */
/* data: May be used for some additional optimizations. */
/* nosave: For optimizations. */
{
    dTHR;
    register char *s;
    register regnode *c;
    register char *startpos = stringarg;
    I32 minlen;		/* must match at least this many chars */
    I32 dontbother = 0;	/* how many characters not to try at end */
    /* I32 start_shift = 0; */		/* Offset of the start to find
					 constant substr. */		/* CC */
    I32 end_shift = 0;			/* Same for the end. */		/* CC */
    I32 scream_pos = -1;		/* Internal iterator of scream. */
    char *scream_olds;
    SV* oreplsv = GvSV(PL_replgv);

    PL_regcc = 0;

    cache_re(prog);
#ifdef DEBUGGING
    PL_regnarrate = PL_debug & 512;
#endif

    /* Be paranoid... */
    if (prog == NULL || startpos == NULL) {
	Perl_croak(aTHX_ "NULL regexp parameter");
	return 0;
    }

    minlen = prog->minlen;
    if (strend - startpos < minlen) goto phooey;

    if (startpos == strbeg)	/* is ^ valid at stringarg? */
	PL_regprev = '\n';
    else {
	PL_regprev = (U32)stringarg[-1];
	if (!PL_multiline && PL_regprev == '\n')
	    PL_regprev = '\0';		/* force ^ to NOT match */
    }

    /* Check validity of program. */
    if (UCHARAT(prog->program) != REG_MAGIC) {
	Perl_croak(aTHX_ "corrupted regexp program");
    }

    PL_reg_flags = 0;
    PL_reg_eval_set = 0;
    PL_reg_maxiter = 0;

    if (prog->reganch & ROPT_UTF8)
	PL_reg_flags |= RF_utf8;

    /* Mark beginning of line for ^ and lookbehind. */
    PL_regbol = startpos;
    PL_bostr  = strbeg;
    PL_reg_sv = sv;

    /* Mark end of line for $ (and such) */
    PL_regeol = strend;

    /* see how far we have to get to not match where we matched before */
    PL_regtill = startpos+minend;

    /* We start without call_cc context.  */
    PL_reg_call_cc = 0;

    /* If there is a "must appear" string, look for it. */
    s = startpos;

    if (prog->reganch & ROPT_GPOS_SEEN) { /* Need to have PL_reg_ganch */
	MAGIC *mg;

	if (flags & REXEC_IGNOREPOS)	/* Means: check only at start */
	    PL_reg_ganch = startpos;
	else if (sv && SvTYPE(sv) >= SVt_PVMG
		  && SvMAGIC(sv)
		  && (mg = mg_find(sv, 'g')) && mg->mg_len >= 0) {
	    PL_reg_ganch = strbeg + mg->mg_len;	/* Defined pos() */
	    if (prog->reganch & ROPT_ANCH_GPOS) {
		if (s > PL_reg_ganch)
		    goto phooey;
		s = PL_reg_ganch;
	    }
	}
	else				/* pos() not defined */
	    PL_reg_ganch = strbeg;
    }

    if (!(flags & REXEC_CHECKED) && prog->check_substr != Nullsv) {
	re_scream_pos_data d;

	d.scream_olds = &scream_olds;
	d.scream_pos = &scream_pos;
	s = re_intuit_start(prog, sv, s, strend, flags, &d);
	if (!s)
	    goto phooey;	/* not present */
    }

    DEBUG_r( if (!PL_colorset) reginitcolors() );
    DEBUG_r(PerlIO_printf(Perl_debug_log,
		      "%sMatching REx%s `%s%.60s%s%s' against `%s%.*s%s%s'\n",
		      PL_colors[4],PL_colors[5],PL_colors[0],
		      prog->precomp,
		      PL_colors[1],
		      (strlen(prog->precomp) > 60 ? "..." : ""),
		      PL_colors[0],
		      (int)(strend - startpos > 60 ? 60 : strend - startpos),
		      startpos, PL_colors[1],
		      (strend - startpos > 60 ? "..." : ""))
	);

    /* Simplest case:  anchored match need be tried only once. */
    /*  [unless only anchor is BOL and multiline is set] */
    if (prog->reganch & (ROPT_ANCH & ~ROPT_ANCH_GPOS)) {
	if (s == startpos && regtry(prog, startpos))
	    goto got_it;
	else if (PL_multiline || (prog->reganch & ROPT_IMPLICIT)
		 || (prog->reganch & ROPT_ANCH_MBOL)) /* XXXX SBOL? */
	{
	    char *end;

	    if (minlen)
		dontbother = minlen - 1;
	    end = HOPc(strend, -dontbother) - 1;
	    /* for multiline we only have to try after newlines */
	    if (prog->check_substr) {
		if (s == startpos)
		    goto after_try;
		while (1) {
		    if (regtry(prog, s))
a516 8
		  after_try:
		    if (s >= end)
			goto phooey;
		    if (prog->reganch & RE_USE_INTUIT) {
			s = re_intuit_start(prog, sv, s + 1, strend, flags, NULL);
			if (!s)
			    goto phooey;
		    }
d518 5
a522 11
			s++;
		}		
	    } else {
		if (s > startpos)
		    s--;
		while (s < end) {
		    if (*s++ == '\n') {	/* don't need PL_utf8skip here */
			if (regtry(prog, s))
			    goto got_it;
		    }
		}		
d524 2
a525 14
	}
	goto phooey;
    } else if (prog->reganch & ROPT_ANCH_GPOS) {
	if (regtry(prog, PL_reg_ganch))
	    goto got_it;
	goto phooey;
    }

    /* Messy cases:  unanchored match. */
    if (prog->anchored_substr && prog->reganch & ROPT_SKIP) { 
	/* we have /x+whatever/ */
	/* it must be a one character string (XXXX Except UTF?) */
	char ch = SvPVX(prog->anchored_substr)[0];
	if (UTF) {
d527 5
a531 5
		if (*s == ch) {
		    if (regtry(prog, s)) goto got_it;
		    s += UTF8SKIP(s);
		    while (s < strend && *s == ch)
			s += UTF8SKIP(s);
d533 3
a535 1
		s += UTF8SKIP(s);
d537 3
a539 2
	}
	else {
d541 5
a545 5
		if (*s == ch) {
		    if (regtry(prog, s)) goto got_it;
		    s++;
		    while (s < strend && *s == ch)
			s++;
d547 2
d551 12
a562 37
	}
    }
    /*SUPPRESS 560*/
    else if (prog->anchored_substr != Nullsv
	     || (prog->float_substr != Nullsv 
		 && prog->float_max_offset < strend - s)) {
	SV *must = prog->anchored_substr 
	    ? prog->anchored_substr : prog->float_substr;
	I32 back_max = 
	    prog->anchored_substr ? prog->anchored_offset : prog->float_max_offset;
	I32 back_min = 
	    prog->anchored_substr ? prog->anchored_offset : prog->float_min_offset;
	char *last = HOPc(strend,	/* Cannot start after this */
			  -(I32)(CHR_SVLEN(must)
				 - (SvTAIL(must) != 0) + back_min));
	char *last1;		/* Last position checked before */

	if (s > PL_bostr)
	    last1 = HOPc(s, -1);
	else
	    last1 = s - 1;	/* bogus */

	/* XXXX check_substr already used to find `s', can optimize if
	   check_substr==must. */
	scream_pos = -1;
	dontbother = end_shift;
	strend = HOPc(strend, -dontbother);
	while ( (s <= last) &&
		((flags & REXEC_SCREAM) 
		 ? (s = screaminstr(sv, must, HOPc(s, back_min) - strbeg,
				    end_shift, &scream_pos, 0))
		 : (s = fbm_instr((unsigned char*)HOP(s, back_min),
				  (unsigned char*)strend, must, 
				  PL_multiline ? FBMrf_MULTILINE : 0))) ) {
	    if (HOPc(s, -back_max) > last1) {
		last1 = HOPc(s, -back_min);
		s = HOPc(s, -back_max);
d564 13
a576 5
	    else {
		char *t = (last1 >= PL_bostr) ? HOPc(last1, 1) : last1 + 1;

		last1 = HOPc(s, -back_min);
		s = t;		
d578 5
a582 3
	    if (UTF) {
		while (s <= last1) {
		    if (regtry(prog, s))
d584 2
a585 1
		    s += UTF8SKIP(s);
d587 3
d591 5
a595 3
	    else {
		while (s <= last1) {
		    if (regtry(prog, s))
d597 2
a598 1
		    s++;
d600 3
d604 1
a605 8
	goto phooey;
    }
    else if ((c = prog->regstclass)) {
	if (minlen && PL_regkind[(U8)OP(prog->regstclass)] != EXACT)
	    /* don't bother with what can't match */
	    strend = HOPc(strend, -(minlen - 1));
  	if (find_byclass(prog, c, s, strend, startpos, 0))
	    goto got_it;
d611 1
d613 2
a614 2
	    if (flags & REXEC_SCREAM) {
		last = screaminstr(sv, prog->float_substr, s - strbeg,
d616 1
a616 1
		if (!last)
d618 2
a619 2
	    }
	    else {
d622 4
a625 16

		if (SvTAIL(prog->float_substr)) {
		    if (memEQ(strend - len + 1, little, len - 1))
			last = strend - len + 1;
		    else if (!PL_multiline)
			last = memEQ(strend - len, little, len) 
			    ? strend - len : Nullch;
		    else
			goto find_last;
		} else {
		  find_last:
		    if (len) 
			last = rninstr(s, strend, little, little + len);
		    else
			last = strend;	/* matching `$' */
		}
d632 1
a632 1
	strend -= dontbother; 		   /* this one's always in bytes! */
d634 4
a637 15
	if (UTF) {
	    for (;;) {
		if (regtry(prog, s))
		    goto got_it;
		if (s >= strend)
		    break;
		s += UTF8SKIP(s);
	    };
	}
	else {
	    do {
		if (regtry(prog, s))
		    goto got_it;
	    } while (s++ < strend);
	}
d644 2
a647 9
    if (PL_reg_eval_set) {
	/* Preserve the current value of $^R */
	if (oreplsv != GvSV(PL_replgv))
	    sv_setsv(oreplsv, GvSV(PL_replgv));/* So that when GvSV(replgv) is
						  restored, the value remains
						  the same. */
	restore_pos(aTHXo_ 0);
    }

d649 6
a654 4
    if ( !(flags & REXEC_NOT_FIRST) ) {
	if (RX_MATCH_COPIED(prog)) {
	    Safefree(prog->subbeg);
	    RX_MATCH_COPIED_off(prog);
d656 1
a656 1
	if (flags & REXEC_COPY_STR) {
a657 1

d659 11
a669 7
	    prog->subbeg = s;
	    prog->sublen = i;
	    RX_MATCH_COPIED_on(prog);
	}
	else {
	    prog->subbeg = strbeg;
	    prog->sublen = PL_regeol - strbeg;	/* strend may have been modified */
d672 6
a677 1
    
a680 2
    if (PL_reg_eval_set)
	restore_pos(aTHXo_ 0);
d688 1
a688 1
S_regtry(pTHX_ regexp *prog, char *startpos)
d692 2
a693 2
    register I32 *sp;
    register I32 *ep;
a696 2
	MAGIC *mg;

d699 2
a700 2
	    PerlIO_printf(Perl_debug_log, "  setting stack tmpbase at %"IVdf"\n",
			  (IV)(PL_stack_sp - PL_stack_base));
d702 1
a702 1
	SAVEI32(cxstack[cxstack_ix].blk_oldsp);
d707 1
a707 1
	/* SAVEI8(cxstack[cxstack_ix].blk_gimme);
a708 37

	if (PL_reg_sv) {
	    /* Make $_ available to executed code. */
	    if (PL_reg_sv != DEFSV) {
		/* SAVE_DEFSV does *not* suffice here for USE_THREADS */
		SAVESPTR(DEFSV);
		DEFSV = PL_reg_sv;
	    }
	
	    if (!(SvTYPE(PL_reg_sv) >= SVt_PVMG && SvMAGIC(PL_reg_sv) 
		  && (mg = mg_find(PL_reg_sv, 'g')))) {
		/* prepare for quick setting of pos */
		sv_magic(PL_reg_sv, (SV*)0, 'g', Nullch, 0);
		mg = mg_find(PL_reg_sv, 'g');
		mg->mg_len = -1;
	    }
	    PL_reg_magic    = mg;
	    PL_reg_oldpos   = mg->mg_len;
	    SAVEDESTRUCTOR_X(restore_pos, 0);
        }
	if (!PL_reg_curpm)
	    Newz(22,PL_reg_curpm, 1, PMOP);
	PL_reg_curpm->op_pmregexp = prog;
	PL_reg_oldcurpm = PL_curpm;
	PL_curpm = PL_reg_curpm;
	if (RX_MATCH_COPIED(prog)) {
	    /*  Here is a serious problem: we cannot rewrite subbeg,
		since it may be needed if this match fails.  Thus
		$` inside (?{}) could fail... */
	    PL_reg_oldsaved = prog->subbeg;
	    PL_reg_oldsavedlen = prog->sublen;
	    RX_MATCH_COPIED_off(prog);
	}
	else
	    PL_reg_oldsaved = Nullch;
	prog->subbeg = PL_bostr;
	prog->sublen = PL_regeol - PL_bostr; /* strend may have been modified */
a709 1
    prog->startp[0] = startpos - PL_bostr;
a715 1
    DEBUG_r(PL_reg_starttry = startpos);
a723 3
    /* XXXX What this code is doing here?!!!  There should be no need
       to do this again and again, PL_reglastparen should take care of
       this!  */
d726 1
d728 3
a730 3
	for (i = prog->nparens; i >= 1; i--) {
	    *++sp = -1;
	    *++ep = -1;
d735 2
a736 1
	prog->endp[0] = PL_reginput - PL_bostr;
d758 1
a758 1
S_regmatch(pTHX_ regnode *prog)
a775 1
    /* Note that nextchr is a byte even in UTF */
a782 4
#  define sayYES_FINAL goto yes_final
#  define sayYES_LOUD  goto yes_loud
#  define sayNO_FINAL  goto no_final
#  define sayNO_SILENT goto do_no
a787 4
#  define sayYES_FINAL return 1
#  define sayYES_LOUD  return 1
#  define sayNO_FINAL  return 0
#  define sayNO_SILENT return 0
a794 6
	    /* The part of the string before starttry has one color
	       (pref0_len chars), between starttry and current
	       position another one (pref_len - pref0_len chars),
	       after the current position the third one.
	       We assume that pref0_len <= pref_len, otherwise we
	       decrease pref0_len.  */
a796 1
	    int pref0_len = pref_len  - (locinput - PL_reg_starttry);
a800 4
	    if (pref0_len < 0)
		pref0_len = 0;
	    if (pref0_len > pref_len)
		pref0_len = pref_len;
d803 3
a805 6
			  "%4"IVdf" <%s%.*s%s%s%.*s%s%s%s%.*s%s>%*s|%3"IVdf":%*s%s\n",
			  (IV)(locinput - PL_bostr), 
			  PL_colors[4], pref0_len, 
			  locinput - pref_len, PL_colors[5],
			  PL_colors[2], pref_len - pref0_len, 
			  locinput - pref_len + pref0_len, PL_colors[3],
d810 1
a810 1
			  (IV)(scan - PL_regprogram), PL_regindent*2, "",
d825 1
a825 1
		/* regtill = regbol; */
d842 1
a842 1
	    if (locinput == PL_reg_ganch)
a865 12
	case SANYUTF8:
	    if (nextchr & 0x80) {
		locinput += PL_utf8skip[nextchr];
		if (locinput > PL_regeol)
		    sayNO;
		nextchr = UCHARAT(locinput);
		break;
	    }
	    if (!nextchr && locinput >= PL_regeol)
		sayNO;
	    nextchr = UCHARAT(++locinput);
	    break;
d871 2
a872 14
	case ANYUTF8:
	    if (nextchr & 0x80) {
		locinput += PL_utf8skip[nextchr];
		if (locinput > PL_regeol)
		    sayNO;
		nextchr = UCHARAT(locinput);
		break;
	    }
	    if ((!nextchr && locinput >= PL_regeol) || nextchr == '\n')
		sayNO;
	    nextchr = UCHARAT(++locinput);
	    break;
	case REG_ANY:
	    if ((!nextchr && locinput >= PL_regeol) || nextchr == '\n')
d877 2
a878 2
	    s = STRING(scan);
	    ln = STR_LEN(scan);
d893 2
a894 24
	    s = STRING(scan);
	    ln = STR_LEN(scan);

	    if (UTF) {
		char *l = locinput;
		char *e = s + ln;
		c1 = OP(scan) == EXACTF;
		while (s < e) {
		    if (l >= PL_regeol)
			sayNO;
		    if (utf8_to_uv((U8*)s, 0) != (c1 ?
						  toLOWER_utf8((U8*)l) :
						  toLOWER_LC_utf8((U8*)l)))
		    {
			sayNO;
		    }
		    s += UTF8SKIP(s);
		    l += UTF8SKIP(l);
		}
		locinput = l;
		nextchr = UCHARAT(locinput);
		break;
	    }

d898 1
a898 1
			       ? PL_fold : PL_fold_locale)[nextchr])
a908 8
	case ANYOFUTF8:
	    if (!REGINCLASSUTF8(scan, (U8*)locinput))
		sayNO;
	    if (locinput >= PL_regeol)
		sayNO;
	    locinput += PL_utf8skip[nextchr];
	    nextchr = UCHARAT(locinput);
	    break;
d910 1
d913 1
a913 1
	    if (!REGINCLASS(scan, nextchr))
a929 22
	case ALNUMLUTF8:
	    PL_reg_flags |= RF_tainted;
	    /* FALL THROUGH */
	case ALNUMUTF8:
	    if (!nextchr)
		sayNO;
	    if (nextchr & 0x80) {
		if (!(OP(scan) == ALNUMUTF8
		      ? swash_fetch(PL_utf8_alnum, (U8*)locinput)
		      : isALNUM_LC_utf8((U8*)locinput)))
		{
		    sayNO;
		}
		locinput += PL_utf8skip[nextchr];
		nextchr = UCHARAT(locinput);
		break;
	    }
	    if (!(OP(scan) == ALNUMUTF8
		  ? isALNUM(nextchr) : isALNUM_LC(nextchr)))
		sayNO;
	    nextchr = UCHARAT(++locinput);
	    break;
a940 22
	case NALNUMLUTF8:
	    PL_reg_flags |= RF_tainted;
	    /* FALL THROUGH */
	case NALNUMUTF8:
	    if (!nextchr && locinput >= PL_regeol)
		sayNO;
	    if (nextchr & 0x80) {
		if (OP(scan) == NALNUMUTF8
		    ? swash_fetch(PL_utf8_alnum, (U8*)locinput)
		    : isALNUM_LC_utf8((U8*)locinput))
		{
		    sayNO;
		}
		locinput += PL_utf8skip[nextchr];
		nextchr = UCHARAT(locinput);
		break;
	    }
	    if (OP(scan) == NALNUMUTF8
		? isALNUM(nextchr) : isALNUM_LC(nextchr))
		sayNO;
	    nextchr = UCHARAT(++locinput);
	    break;
a959 20
	case BOUNDLUTF8:
	case NBOUNDLUTF8:
	    PL_reg_flags |= RF_tainted;
	    /* FALL THROUGH */
	case BOUNDUTF8:
	case NBOUNDUTF8:
	    /* was last char in word? */
	    ln = (locinput != PL_regbol)
		? utf8_to_uv(reghop((U8*)locinput, -1), 0) : PL_regprev;
	    if (OP(scan) == BOUNDUTF8 || OP(scan) == NBOUNDUTF8) {
		ln = isALNUM_uni(ln);
		n = swash_fetch(PL_utf8_alnum, (U8*)locinput);
	    }
	    else {
		ln = isALNUM_LC_uni(ln);
		n = isALNUM_LC_utf8((U8*)locinput);
	    }
	    if (((!ln) == (!n)) == (OP(scan) == BOUNDUTF8 || OP(scan) == BOUNDLUTF8))
		sayNO;
	    break;
a963 44
	    if (!nextchr)
		sayNO;
	    if (!(OP(scan) == SPACE
		  ? isSPACE(nextchr) : isSPACE_LC(nextchr)))
		sayNO;
	    nextchr = UCHARAT(++locinput);
	    break;
	case SPACELUTF8:
	    PL_reg_flags |= RF_tainted;
	    /* FALL THROUGH */
	case SPACEUTF8:
	    if (!nextchr)
		sayNO;
	    if (nextchr & 0x80) {
		if (!(OP(scan) == SPACEUTF8
		      ? swash_fetch(PL_utf8_space, (U8*)locinput)
		      : isSPACE_LC_utf8((U8*)locinput)))
		{
		    sayNO;
		}
		locinput += PL_utf8skip[nextchr];
		nextchr = UCHARAT(locinput);
		break;
	    }
	    if (!(OP(scan) == SPACEUTF8
		  ? isSPACE(nextchr) : isSPACE_LC(nextchr)))
		sayNO;
	    nextchr = UCHARAT(++locinput);
	    break;
	case NSPACEL:
	    PL_reg_flags |= RF_tainted;
	    /* FALL THROUGH */
	case NSPACE:
	    if (!nextchr && locinput >= PL_regeol)
		sayNO;
	    if (OP(scan) == NSPACE
		? isSPACE(nextchr) : isSPACE_LC(nextchr))
		sayNO;
	    nextchr = UCHARAT(++locinput);
	    break;
	case NSPACELUTF8:
	    PL_reg_flags |= RF_tainted;
	    /* FALL THROUGH */
	case NSPACEUTF8:
d966 2
a967 24
	    if (nextchr & 0x80) {
		if (OP(scan) == NSPACEUTF8
		    ? swash_fetch(PL_utf8_space, (U8*)locinput)
		    : isSPACE_LC_utf8((U8*)locinput))
		{
		    sayNO;
		}
		locinput += PL_utf8skip[nextchr];
		nextchr = UCHARAT(locinput);
		break;
	    }
	    if (OP(scan) == NSPACEUTF8
		? isSPACE(nextchr) : isSPACE_LC(nextchr))
		sayNO;
	    nextchr = UCHARAT(++locinput);
	    break;
	case DIGITL:
	    PL_reg_flags |= RF_tainted;
	    /* FALL THROUGH */
	case DIGIT:
	    if (!nextchr)
		sayNO;
	    if (!(OP(scan) == DIGIT
		  ? isDIGIT(nextchr) : isDIGIT_LC(nextchr)))
d971 1
a971 1
	case DIGITLUTF8:
d974 1
a974 1
	case DIGITUTF8:
d977 2
a978 13
	    if (nextchr & 0x80) {
		if (!(OP(scan) == DIGITUTF8
		      ? swash_fetch(PL_utf8_digit, (U8*)locinput)
		      : isDIGIT_LC_utf8((U8*)locinput)))
		{
		    sayNO;
		}
		locinput += PL_utf8skip[nextchr];
		nextchr = UCHARAT(locinput);
		break;
	    }
	    if (!(OP(scan) == DIGITUTF8
		  ? isDIGIT(nextchr) : isDIGIT_LC(nextchr)))
d982 2
a983 8
	case NDIGITL:
	    PL_reg_flags |= RF_tainted;
	    /* FALL THROUGH */
	case NDIGIT:
	    if (!nextchr && locinput >= PL_regeol)
		sayNO;
	    if (OP(scan) == NDIGIT
		? isDIGIT(nextchr) : isDIGIT_LC(nextchr))
d987 1
a987 4
	case NDIGITLUTF8:
	    PL_reg_flags |= RF_tainted;
	    /* FALL THROUGH */
	case NDIGITUTF8:
d990 1
a990 13
	    if (nextchr & 0x80) {
		if (OP(scan) == NDIGITUTF8
		    ? swash_fetch(PL_utf8_digit, (U8*)locinput)
		    : isDIGIT_LC_utf8((U8*)locinput))
		{
		    sayNO;
		}
		locinput += PL_utf8skip[nextchr];
		nextchr = UCHARAT(locinput);
		break;
	    }
	    if (OP(scan) == NDIGITUTF8
		? isDIGIT(nextchr) : isDIGIT_LC(nextchr))
a993 10
	case CLUMP:
	    if (locinput >= PL_regeol || swash_fetch(PL_utf8_mark,(U8*)locinput))
		sayNO;
	    locinput += PL_utf8skip[nextchr];
	    while (locinput < PL_regeol && swash_fetch(PL_utf8_mark,(U8*)locinput))
		locinput += UTF8SKIP(locinput);
	    if (locinput > PL_regeol)
		sayNO;
	    nextchr = UCHARAT(locinput);
	    break;
d1000 2
a1001 3
	    ln = PL_regstartp[n];
	    PL_reg_leftiter = PL_reg_maxiter;		/* Void cache */
	    if (*PL_reglastparen < n || ln == -1)
d1003 1
a1003 34
	    if (ln == PL_regendp[n])
		break;

	    s = PL_bostr + ln;
	    if (UTF && OP(scan) != REF) {	/* REF can do byte comparison */
		char *l = locinput;
		char *e = PL_bostr + PL_regendp[n];
		/*
		 * Note that we can't do the "other character" lookup trick as
		 * in the 8-bit case (no pun intended) because in Unicode we
		 * have to map both upper and title case to lower case.
		 */
		if (OP(scan) == REFF) {
		    while (s < e) {
			if (l >= PL_regeol)
			    sayNO;
			if (toLOWER_utf8((U8*)s) != toLOWER_utf8((U8*)l))
			    sayNO;
			s += UTF8SKIP(s);
			l += UTF8SKIP(l);
		    }
		}
		else {
		    while (s < e) {
			if (l >= PL_regeol)
			    sayNO;
			if (toLOWER_LC_utf8((U8*)s) != toLOWER_LC_utf8((U8*)l))
			    sayNO;
			s += UTF8SKIP(s);
			l += UTF8SKIP(l);
		    }
		}
		locinput = l;
		nextchr = UCHARAT(locinput);
a1004 2
	    }

d1009 1
a1009 1
				  ? PL_fold : PL_fold_locale)[nextchr]))))
d1011 1
a1011 1
	    ln = PL_regendp[n] - ln;
d1039 2
a1040 3
	    DEBUG_r( PerlIO_printf(Perl_debug_log, "  re_eval 0x%"UVxf"\n", PTR2UV(PL_op)) );
	    PL_curpad = AvARRAY((AV*)PL_regdata->data[n + 2]);
	    PL_regendp[0] = PL_reg_magic->mg_len = locinput - PL_bostr;
d1042 1
a1042 1
	    CALLRUNOPS(aTHX);			/* Scalar context. */
d1047 5
a1054 98
	    if (logical) {
		if (logical == 2) {	/* Postponed subexpression. */
		    regexp *re;
		    MAGIC *mg = Null(MAGIC*);
		    re_cc_state state;
		    CHECKPOINT cp, lastcp;

		    if(SvROK(ret) || SvRMAGICAL(ret)) {
			SV *sv = SvROK(ret) ? SvRV(ret) : ret;

			if(SvMAGICAL(sv))
			    mg = mg_find(sv, 'r');
		    }
		    if (mg) {
			re = (regexp *)mg->mg_obj;
			(void)ReREFCNT_inc(re);
		    }
		    else {
			STRLEN len;
			char *t = SvPV(ret, len);
			PMOP pm;
			char *oprecomp = PL_regprecomp;
			I32 osize = PL_regsize;
			I32 onpar = PL_regnpar;

			pm.op_pmflags = 0;
			pm.op_pmdynflags = (UTF||DO_UTF8(ret) ? PMdf_UTF8 : 0);
			re = CALLREGCOMP(aTHX_ t, t + len, &pm);
			if (!(SvFLAGS(ret) 
			      & (SVs_TEMP | SVs_PADTMP | SVf_READONLY)))
			    sv_magic(ret,(SV*)ReREFCNT_inc(re),'r',0,0);
			PL_regprecomp = oprecomp;
			PL_regsize = osize;
			PL_regnpar = onpar;
		    }
		    DEBUG_r(
			PerlIO_printf(Perl_debug_log, 
				      "Entering embedded `%s%.60s%s%s'\n",
				      PL_colors[0],
				      re->precomp,
				      PL_colors[1],
				      (strlen(re->precomp) > 60 ? "..." : ""))
			);
		    state.node = next;
		    state.prev = PL_reg_call_cc;
		    state.cc = PL_regcc;
		    state.re = PL_reg_re;

		    PL_regcc = 0;
		    
		    cp = regcppush(0);	/* Save *all* the positions. */
		    REGCP_SET;
		    cache_re(re);
		    state.ss = PL_savestack_ix;
		    *PL_reglastparen = 0;
		    PL_reg_call_cc = &state;
		    PL_reginput = locinput;

		    /* XXXX This is too dramatic a measure... */
		    PL_reg_maxiter = 0;

		    if (regmatch(re->program + 1)) {
			/* Even though we succeeded, we need to restore
			   global variables, since we may be wrapped inside
			   SUSPEND, thus the match may be not finished yet. */

			/* XXXX Do this only if SUSPENDed? */
			PL_reg_call_cc = state.prev;
			PL_regcc = state.cc;
			PL_reg_re = state.re;
			cache_re(PL_reg_re);

			/* XXXX This is too dramatic a measure... */
			PL_reg_maxiter = 0;

			/* These are needed even if not SUSPEND. */
			ReREFCNT_dec(re);
			regcpblow(cp);
			sayYES;
		    }
		    ReREFCNT_dec(re);
		    REGCP_UNWIND;
		    regcppop();
		    PL_reg_call_cc = state.prev;
		    PL_regcc = state.cc;
		    PL_reg_re = state.re;
		    cache_re(PL_reg_re);

		    /* XXXX This is too dramatic a measure... */
		    PL_reg_maxiter = 0;

		    sayNO;
		}
		sw = SvTRUE(ret);
		logical = 0;
	    }
	    else
		sv_setsv(save_scalar(PL_replgv), ret);
d1065 2
a1066 2
	    PL_regstartp[n] = PL_reg_start_tmp[n] - PL_bostr;
	    PL_regendp[n] = locinput - PL_bostr;
d1072 1
a1072 1
	    sw = (*PL_reglastparen >= n && PL_regendp[n] != -1);
a1074 1
	    PL_reg_leftiter = PL_reg_maxiter;		/* Void cache */
d1084 1
a1084 1
	    logical = scan->flags;
a1085 75
/*******************************************************************
 PL_regcc contains infoblock about the innermost (...)* loop, and
 a pointer to the next outer infoblock.

 Here is how Y(A)*Z is processed (if it is compiled into CURLYX/WHILEM):

   1) After matching X, regnode for CURLYX is processed;

   2) This regnode creates infoblock on the stack, and calls 
      regmatch() recursively with the starting point at WHILEM node;

   3) Each hit of WHILEM node tries to match A and Z (in the order
      depending on the current iteration, min/max of {min,max} and
      greediness).  The information about where are nodes for "A"
      and "Z" is read from the infoblock, as is info on how many times "A"
      was already matched, and greediness.

   4) After A matches, the same WHILEM node is hit again.

   5) Each time WHILEM is hit, PL_regcc is the infoblock created by CURLYX
      of the same pair.  Thus when WHILEM tries to match Z, it temporarily
      resets PL_regcc, since this Y(A)*Z can be a part of some other loop:
      as in (Y(A)*Z)*.  If Z matches, the automaton will hit the WHILEM node
      of the external loop.

 Currently present infoblocks form a tree with a stem formed by PL_curcc
 and whatever it mentions via ->next, and additional attached trees
 corresponding to temporarily unset infoblocks as in "5" above.

 In the following picture infoblocks for outer loop of 
 (Y(A)*?Z)*?T are denoted O, for inner I.  NULL starting block
 is denoted by x.  The matched string is YAAZYAZT.  Temporarily postponed
 infoblocks are drawn below the "reset" infoblock.

 In fact in the picture below we do not show failed matches for Z and T
 by WHILEM blocks.  [We illustrate minimal matches, since for them it is
 more obvious *why* one needs to *temporary* unset infoblocks.]

  Matched	REx position	InfoBlocks	Comment
  		(Y(A)*?Z)*?T	x
  		Y(A)*?Z)*?T	x <- O
  Y		(A)*?Z)*?T	x <- O
  Y		A)*?Z)*?T	x <- O <- I
  YA		)*?Z)*?T	x <- O <- I
  YA		A)*?Z)*?T	x <- O <- I
  YAA		)*?Z)*?T	x <- O <- I
  YAA		Z)*?T		x <- O		# Temporary unset I
				     I

  YAAZ		Y(A)*?Z)*?T	x <- O
				     I

  YAAZY		(A)*?Z)*?T	x <- O
				     I

  YAAZY		A)*?Z)*?T	x <- O <- I
				     I

  YAAZYA	)*?Z)*?T	x <- O <- I	
				     I

  YAAZYA	Z)*?T		x <- O		# Temporary unset I
				     I,I

  YAAZYAZ	)*?T		x <- O
				     I,I

  YAAZYAZ	T		x		# Temporary unset O
				O
				I,I

  YAAZYAZT			x
				O
				I,I
 *******************************************************************/
d1113 1
a1113 1
		 * the REx is going to match for sure, and to do that we have
d1138 1
a1138 2
		    if (PL_regcc)
			ln = PL_regcc->cur;
d1146 6
a1151 2
		    if (PL_regcc)
			PL_regcc->cur = ln;
a1164 37
		    sayNO;
		}

		if (scan->flags) {
		    /* Check whether we already were at this position.
			Postpone detection until we know the match is not
			*that* much linear. */
		if (!PL_reg_maxiter) {
		    PL_reg_maxiter = (PL_regeol - PL_bostr + 1) * (scan->flags>>4);
		    PL_reg_leftiter = PL_reg_maxiter;
		}
		if (PL_reg_leftiter-- == 0) {
		    I32 size = (PL_reg_maxiter + 7)/8;
		    if (PL_reg_poscache) {
			if (PL_reg_poscache_size < size) {
			    Renew(PL_reg_poscache, size, char);
			    PL_reg_poscache_size = size;
			}
			Zero(PL_reg_poscache, size, char);
		    }
		    else {
			PL_reg_poscache_size = size;
			Newz(29, PL_reg_poscache, size, char);
		    }
		    DEBUG_r(
			PerlIO_printf(Perl_debug_log,
	      "%sDetected a super-linear match, switching on caching%s...\n",
				      PL_colors[4], PL_colors[5])
			);
		}
		if (PL_reg_leftiter < 0) {
		    I32 o = locinput - PL_bostr, b;

		    o = (scan->flags & 0xf) - 1 + o * (scan->flags>>4);
		    b = o % 8;
		    o /= 8;
		    if (PL_reg_poscache[o] & (1<<b)) {
d1167 1
a1167 1
				      "%*s  already tried at this position...\n",
d1170 1
a1170 4
			sayNO_SILENT;
		    }
		    PL_reg_poscache[o] |= (1<<b);
		}
d1177 1
a1177 2
		    if (PL_regcc)
			ln = PL_regcc->cur;
d1186 1
a1186 2
		    if (PL_regcc)
			PL_regcc->cur = ln;
d1190 1
a1190 1
			if (ckWARN(WARN_REGEXP) && n >= REG_INFTY 
d1193 1
a1193 1
			    Perl_warner(aTHX_ WARN_REGEXP, "%s limit (%d) exceeded",
d1215 5
d1247 1
a1247 2
		if (ckWARN(WARN_REGEXP) && n >= REG_INFTY 
			&& !(PL_reg_flags & RF_warned)) {
d1249 1
a1249 1
		    Perl_warner(aTHX_ WARN_REGEXP, "%s limit (%d) exceeded",
d1256 1
a1256 2
		if (PL_regcc)
		    ln = PL_regcc->cur;
d1259 5
a1263 2
		if (PL_regcc)
		    PL_regcc->cur = ln;
d1294 1
a1294 1
			    PL_regendp[n] = -1;
d1298 1
a1298 1
			if ((n = (c1 == BRANCH ? NEXT_OFF(next) : ARG(next))))
d1347 2
a1348 2
		if (PL_regkind[(U8)OP(next)] == EXACT) {
		    c1 = (U8)*STRING(next);
d1350 1
a1350 1
			c2 = PL_fold[c1];
d1352 1
a1352 1
			c2 = PL_fold_locale[c1];
d1355 1
a1355 2
		}
		else
d1367 4
a1370 6
				PL_regstartp[paren] =
				    HOPc(PL_reginput, -l) - PL_bostr;
				PL_regendp[paren] = PL_reginput - PL_bostr;
			    }
			    else
				PL_regendp[paren] = -1;
d1385 1
a1385 2
	    }
	    else {
d1396 2
a1397 3
				  "%*s  matched %"IVdf" times, len=%"IVdf"...\n",
				  (int)(REPORT_CODE_OFF+PL_regindent*2), "",
				  (IV) n, (IV)l)
d1400 2
a1401 2
		    if (PL_regkind[(U8)OP(next)] == EXACT) {
			c1 = (U8)*STRING(next);
d1403 1
a1403 1
			    c2 = PL_fold[c1];
d1405 1
a1405 1
			    c2 = PL_fold_locale[c1];
d1408 1
a1408 2
		    }
		    else
d1417 2
a1418 2
		    {
			DEBUG_r(
d1420 9
a1428 7
					      "%*s  trying tail with n=%"IVdf"...\n",
					      (int)(REPORT_CODE_OFF+PL_regindent*2), "", (IV)n)
			    );
			if (paren) {
			    if (n) {
				PL_regstartp[paren] = HOPc(PL_reginput, -l) - PL_bostr;
				PL_regendp[paren] = PL_reginput - PL_bostr;
d1430 3
a1432 2
			    else
				PL_regendp[paren] = -1;
a1433 4
			if (regmatch(next))
			    sayYES;
			REGCP_UNWIND;
		    }
d1436 1
a1436 1
		    locinput = HOPc(locinput, -l);
d1475 2
a1476 2
	    if (PL_regkind[(U8)OP(next)] == EXACT) {
		c1 = (U8)*STRING(next);
d1478 1
a1478 1
		    c2 = PL_fold[c1];
d1480 1
a1480 1
		    c2 = PL_fold_locale[c1];
a1491 1
		locinput = PL_reginput;
a1492 44
		if (c1 != -1000) {
		    char *e = locinput + n - ln; /* Should not check after this */
		    char *old = locinput;

		    if (e >= PL_regeol || (n == REG_INFTY))
			e = PL_regeol - 1;
		    while (1) {
			/* Find place 'next' could work */
			if (c1 == c2) {
			    while (locinput <= e && *locinput != c1)
				locinput++;
			} else {
			    while (locinput <= e 
				   && *locinput != c1
				   && *locinput != c2)
				locinput++;			    
			}
			if (locinput > e) 
			    sayNO;
			/* PL_reginput == old now */
			if (locinput != old) {
			    ln = 1;	/* Did some */
			    if (regrepeat(scan, locinput - old) <
				 locinput - old)
				sayNO;
			}
			/* PL_reginput == locinput now */
			if (paren) {
			    if (ln) {
				PL_regstartp[paren] = HOPc(locinput, -1) - PL_bostr;
				PL_regendp[paren] = locinput - PL_bostr;
			    }
			    else
				PL_regendp[paren] = -1;
			}
			if (regmatch(next))
			    sayYES;
			PL_reginput = locinput;	/* Could be reset... */
			REGCP_UNWIND;
			/* Couldn't or didn't -- move forward. */
			old = locinput++;
		    }
		}
		else
d1501 4
a1504 5
				PL_regstartp[paren] = HOPc(PL_reginput, -1) - PL_bostr;
				PL_regendp[paren] = PL_reginput - PL_bostr;
			    }
			    else
				PL_regendp[paren] = -1;
d1511 1
a1511 1
		    PL_reginput = locinput;
d1514 2
a1515 3
			locinput = PL_reginput;
		    }
		    else
d1522 2
a1523 3
		locinput = PL_reginput;
		if (ln < n && PL_regkind[(U8)OP(next)] == EOL &&
		    (!PL_multiline  || OP(next) == SEOL || OP(next) == EOS)) {
a1524 6
		    /* ...because $ and \Z can match before *and* after
		       newline at the end.  Consider "\n\n" =~ /\n+\Z\n/.
		       We should back off by one in this case. */
		    if (UCHARAT(PL_reginput - 1) == '\n' && OP(next) != EOS)
			ln--;
		}
d1535 4
a1538 5
					PL_regstartp[paren] = HOPc(PL_reginput, -1) - PL_bostr;
					PL_regendp[paren] = PL_reginput - PL_bostr;
				    }
				    else
					PL_regendp[paren] = -1;
d1546 1
a1546 1
			PL_reginput = locinput = HOPc(locinput, -1);
d1548 1
a1548 2
		}
		else {
d1561 1
a1561 1
			PL_reginput = locinput = HOPc(locinput, -1);
d1568 3
a1570 45
	    if (PL_reg_call_cc) {
		re_cc_state *cur_call_cc = PL_reg_call_cc;
		CURCUR *cctmp = PL_regcc;
		regexp *re = PL_reg_re;
		CHECKPOINT cp, lastcp;
		
		cp = regcppush(0);	/* Save *all* the positions. */
		REGCP_SET;
		regcp_set_to(PL_reg_call_cc->ss); /* Restore parens of
						    the caller. */
		PL_reginput = locinput;	/* Make position available to
					   the callcc. */
		cache_re(PL_reg_call_cc->re);
		PL_regcc = PL_reg_call_cc->cc;
		PL_reg_call_cc = PL_reg_call_cc->prev;
		if (regmatch(cur_call_cc->node)) {
		    PL_reg_call_cc = cur_call_cc;
		    regcpblow(cp);
		    sayYES;
		}
		REGCP_UNWIND;
		regcppop();
		PL_reg_call_cc = cur_call_cc;
		PL_regcc = cctmp;
		PL_reg_re = re;
		cache_re(re);

		DEBUG_r(
		    PerlIO_printf(Perl_debug_log,
				  "%*s  continuation failed...\n",
				  REPORT_CODE_OFF+PL_regindent*2, "")
		    );
		sayNO_SILENT;
	    }
	    if (locinput < PL_regtill) {
		DEBUG_r(PerlIO_printf(Perl_debug_log,
				      "%sMatch possible, but length=%ld is smaller than requested=%ld, failing!%s\n",
				      PL_colors[4],
				      (long)(locinput - PL_reg_starttry),
				      (long)(PL_regtill - PL_reg_starttry),
				      PL_colors[5]));
		sayNO_FINAL;		/* Cannot match: too short. */
	    }
	    PL_reginput = locinput;	/* put where regtry can find it */
	    sayYES_FINAL;		/* Success! */
d1573 1
a1573 1
	    sayYES_LOUD;		/* Success! */
d1580 2
a1581 18
	    if (scan->flags) {
		if (UTF) {		/* XXXX This is absolutely
					   broken, we read before
					   start of string. */
		    s = HOPMAYBEc(locinput, -scan->flags);
		    if (!s)
			goto say_yes;
		    PL_reginput = s;
		}
		else {
		    if (locinput < PL_bostr + scan->flags) 
			goto say_yes;
		    PL_reginput = locinput - scan->flags;
		    goto do_ifmatch;
		}
	    }
	    else
		PL_reginput = locinput;
d1585 2
a1586 19
	    if (scan->flags) {
		if (UTF) {		/* XXXX This is absolutely
					   broken, we read before
					   start of string. */
		    s = HOPMAYBEc(locinput, -scan->flags);
		    if (!s || s < PL_bostr)
			goto say_no;
		    PL_reginput = s;
		}
		else {
		    if (locinput < PL_bostr + scan->flags) 
			goto say_no;
		    PL_reginput = locinput - scan->flags;
		    goto do_ifmatch;
		}
	    }
	    else
		PL_reginput = locinput;

d1588 1
d1596 1
a1596 2
		}
		else
d1616 3
a1618 3
	    PerlIO_printf(Perl_error_log, "%"UVxf" %d\n",
			  PTR2UV(scan), OP(scan));
	    Perl_croak(aTHX_ "regexp memory corruption");
d1627 1
a1627 1
    Perl_croak(aTHX_ "corrupted regexp pointers");
a1630 10
yes_loud:
    DEBUG_r(
	PerlIO_printf(Perl_debug_log,
		      "%*s  %scould match...%s\n",
		      REPORT_CODE_OFF+PL_regindent*2, "", PL_colors[4],PL_colors[5])
	);
    goto yes;
yes_final:
    DEBUG_r(PerlIO_printf(Perl_debug_log, "%sMatch successful!%s\n",
			  PL_colors[4],PL_colors[5]));
a1637 8
    DEBUG_r(
	PerlIO_printf(Perl_debug_log,
		      "%*s  %sfailed...%s\n",
		      REPORT_CODE_OFF+PL_regindent*2, "",PL_colors[4],PL_colors[5])
	);
    goto do_no;
no_final:
do_no:
d1650 1
a1650 1
 * rather than incrementing count on every character.  [Er, except utf8.]]
d1653 1
a1653 1
S_regrepeat(pTHX_ regnode *p, I32 max)
d1657 1
a1659 1
    register I32 hardcount = 0;
d1664 1
d1666 1
a1666 1
    case REG_ANY:
a1672 14
    case ANYUTF8:
	loceol = PL_regeol;
	while (scan < loceol && *scan != '\n') {
	    scan += UTF8SKIP(scan);
	    hardcount++;
	}
	break;
    case SANYUTF8:
	loceol = PL_regeol;
	while (scan < loceol) {
	    scan += UTF8SKIP(scan);
	    hardcount++;
	}
	break;
d1674 1
a1674 1
	c = (U8)*STRING(p);
d1679 1
a1679 1
	c = (U8)*STRING(p);
d1681 1
a1681 1
	       (UCHARAT(scan) == c || UCHARAT(scan) == PL_fold[c]))
d1686 1
a1686 1
	c = (U8)*STRING(p);
d1688 1
a1688 1
	       (UCHARAT(scan) == c || UCHARAT(scan) == PL_fold_locale[c]))
a1690 7
    case ANYOFUTF8:
	loceol = PL_regeol;
	while (scan < loceol && REGINCLASSUTF8(p, (U8*)scan)) {
	    scan += UTF8SKIP(scan);
	    hardcount++;
	}
	break;
d1692 1
a1692 1
	while (scan < loceol && REGINCLASS(p, *scan))
a1698 7
    case ALNUMUTF8:
	loceol = PL_regeol;
	while (scan < loceol && swash_fetch(PL_utf8_alnum, (U8*)scan)) {
	    scan += UTF8SKIP(scan);
	    hardcount++;
	}
	break;
a1703 9
    case ALNUMLUTF8:
	PL_reg_flags |= RF_tainted;
	loceol = PL_regeol;
	while (scan < loceol && isALNUM_LC_utf8((U8*)scan)) {
	    scan += UTF8SKIP(scan);
	    hardcount++;
	}
	break;
	break;
a1707 7
    case NALNUMUTF8:
	loceol = PL_regeol;
	while (scan < loceol && !swash_fetch(PL_utf8_alnum, (U8*)scan)) {
	    scan += UTF8SKIP(scan);
	    hardcount++;
	}
	break;
a1712 8
    case NALNUMLUTF8:
	PL_reg_flags |= RF_tainted;
	loceol = PL_regeol;
	while (scan < loceol && !isALNUM_LC_utf8((U8*)scan)) {
	    scan += UTF8SKIP(scan);
	    hardcount++;
	}
	break;
a1716 7
    case SPACEUTF8:
	loceol = PL_regeol;
	while (scan < loceol && (*scan == ' ' || swash_fetch(PL_utf8_space,(U8*)scan))) {
	    scan += UTF8SKIP(scan);
	    hardcount++;
	}
	break;
a1721 8
    case SPACELUTF8:
	PL_reg_flags |= RF_tainted;
	loceol = PL_regeol;
	while (scan < loceol && (*scan == ' ' || isSPACE_LC_utf8((U8*)scan))) {
	    scan += UTF8SKIP(scan);
	    hardcount++;
	}
	break;
a1725 7
    case NSPACEUTF8:
	loceol = PL_regeol;
	while (scan < loceol && !(*scan == ' ' || swash_fetch(PL_utf8_space,(U8*)scan))) {
	    scan += UTF8SKIP(scan);
	    hardcount++;
	}
	break;
a1730 8
    case NSPACELUTF8:
	PL_reg_flags |= RF_tainted;
	loceol = PL_regeol;
	while (scan < loceol && !(*scan == ' ' || isSPACE_LC_utf8((U8*)scan))) {
	    scan += UTF8SKIP(scan);
	    hardcount++;
	}
	break;
a1734 8
    case DIGITUTF8:
	loceol = PL_regeol;
	while (scan < loceol && swash_fetch(PL_utf8_digit,(U8*)scan)) {
	    scan += UTF8SKIP(scan);
	    hardcount++;
	}
	break;
	break;
a1738 7
    case NDIGITUTF8:
	loceol = PL_regeol;
	while (scan < loceol && !swash_fetch(PL_utf8_digit,(U8*)scan)) {
	    scan += UTF8SKIP(scan);
	    hardcount++;
	}
	break;
d1743 1
a1743 4
    if (hardcount)
	c = hardcount;
    else
	c = scan - PL_reginput;
d1752 2
a1753 2
			      "%*s  %s can match %"IVdf" times out of %"IVdf"...\n", 
			      REPORT_CODE_OFF+1, "", SvPVX(prop),(IV)c,(IV)max);
d1766 1
a1766 1
S_regrepeat_hard(pTHX_ regnode *p, I32 max, I32 *lp)
d1779 7
a1785 25
    if (UTF) {
	while (PL_reginput < loceol && (scan = PL_reginput, res = regmatch(p))) {
	    if (!count++) {
		l = 0;
		while (start < PL_reginput) {
		    l++;
		    start += UTF8SKIP(start);
		}
		*lp = l;
		if (l == 0)
		    return max;
	    }
	    if (count == max)
		return count;
	}
    }
    else {
	while (PL_reginput < loceol && (scan = PL_reginput, res = regmatch(p))) {
	    if (!count++) {
		*lp = l = PL_reginput - start;
		if (max != REG_INFTY && l*max < loceol - scan)
		    loceol = scan + l*max;
		if (l == 0)
		    return max;
	    }
d1795 1
a1795 1
 - reginclass - determine if a character falls into a character class
d1799 1
a1799 1
S_reginclass(pTHX_ register regnode *p, register I32 c)
d1802 1
a1802 1
    char flags = ANYOF_FLAGS(p);
d1806 1
a1806 1
    if (ANYOF_BITMAP_TEST(p, c))
d1812 1
a1812 1
	    cf = PL_fold_locale[c];
d1815 2
a1816 2
	    cf = PL_fold[c];
	if (ANYOF_BITMAP_TEST(p, cf))
d1820 1
a1820 1
    if (!match && (flags & ANYOF_CLASS)) {
d1822 5
a1826 28
	if (
	    (ANYOF_CLASS_TEST(p, ANYOF_ALNUM)   &&  isALNUM_LC(c))  ||
	    (ANYOF_CLASS_TEST(p, ANYOF_NALNUM)  && !isALNUM_LC(c))  ||
	    (ANYOF_CLASS_TEST(p, ANYOF_SPACE)   &&  isSPACE_LC(c))  ||
	    (ANYOF_CLASS_TEST(p, ANYOF_NSPACE)  && !isSPACE_LC(c))  ||
	    (ANYOF_CLASS_TEST(p, ANYOF_DIGIT)   &&  isDIGIT_LC(c))  ||
	    (ANYOF_CLASS_TEST(p, ANYOF_NDIGIT)  && !isDIGIT_LC(c))  ||
	    (ANYOF_CLASS_TEST(p, ANYOF_ALNUMC)  &&  isALNUMC_LC(c)) ||
	    (ANYOF_CLASS_TEST(p, ANYOF_NALNUMC) && !isALNUMC_LC(c)) ||
	    (ANYOF_CLASS_TEST(p, ANYOF_ALPHA)   &&  isALPHA_LC(c))  ||
	    (ANYOF_CLASS_TEST(p, ANYOF_NALPHA)  && !isALPHA_LC(c))  ||
	    (ANYOF_CLASS_TEST(p, ANYOF_ASCII)   &&  isASCII(c))     ||
	    (ANYOF_CLASS_TEST(p, ANYOF_NASCII)  && !isASCII(c))     ||
	    (ANYOF_CLASS_TEST(p, ANYOF_CNTRL)   &&  isCNTRL_LC(c))  ||
	    (ANYOF_CLASS_TEST(p, ANYOF_NCNTRL)  && !isCNTRL_LC(c))  ||
	    (ANYOF_CLASS_TEST(p, ANYOF_GRAPH)   &&  isGRAPH_LC(c))  ||
	    (ANYOF_CLASS_TEST(p, ANYOF_NGRAPH)  && !isGRAPH_LC(c))  ||
	    (ANYOF_CLASS_TEST(p, ANYOF_LOWER)   &&  isLOWER_LC(c))  ||
	    (ANYOF_CLASS_TEST(p, ANYOF_NLOWER)  && !isLOWER_LC(c))  ||
	    (ANYOF_CLASS_TEST(p, ANYOF_PRINT)   &&  isPRINT_LC(c))  ||
	    (ANYOF_CLASS_TEST(p, ANYOF_NPRINT)  && !isPRINT_LC(c))  ||
	    (ANYOF_CLASS_TEST(p, ANYOF_PUNCT)   &&  isPUNCT_LC(c))  ||
	    (ANYOF_CLASS_TEST(p, ANYOF_NPUNCT)  && !isPUNCT_LC(c))  ||
	    (ANYOF_CLASS_TEST(p, ANYOF_UPPER)   &&  isUPPER_LC(c))  ||
	    (ANYOF_CLASS_TEST(p, ANYOF_NUPPER)  && !isUPPER_LC(c))  ||
	    (ANYOF_CLASS_TEST(p, ANYOF_XDIGIT)  &&  isXDIGIT(c))    ||
	    (ANYOF_CLASS_TEST(p, ANYOF_NXDIGIT) && !isXDIGIT(c))
	    ) /* How's that for a conditional? */
a1834 80
STATIC bool
S_reginclassutf8(pTHX_ regnode *f, U8 *p)
{                                           
    dTHR;
    char flags = ARG1(f);
    bool match = FALSE;
    SV *sv = (SV*)PL_regdata->data[ARG2(f)];

    if (swash_fetch(sv, p))
	match = TRUE;
    else if (flags & ANYOF_FOLD) {
	U8 tmpbuf[UTF8_MAXLEN];
	if (flags & ANYOF_LOCALE) {
	    PL_reg_flags |= RF_tainted;
	    uv_to_utf8(tmpbuf, toLOWER_LC_utf8(p));
	}
	else
	    uv_to_utf8(tmpbuf, toLOWER_utf8(p));
	if (swash_fetch(sv, tmpbuf))
	    match = TRUE;
    }

    /* UTF8 combined with ANYOF_CLASS is ill-defined. */

    return (flags & ANYOF_INVERT) ? !match : match;
}

STATIC U8 *
S_reghop(pTHX_ U8 *s, I32 off)
{                               
    dTHR;
    if (off >= 0) {
	while (off-- && s < (U8*)PL_regeol)
	    s += UTF8SKIP(s);
    }
    else {
	while (off++) {
	    if (s > (U8*)PL_bostr) {
		s--;
		if (*s & 0x80) {
		    while (s > (U8*)PL_bostr && (*s & 0xc0) == 0x80)
			s--;
		}		/* XXX could check well-formedness here */
	    }
	}
    }
    return s;
}

STATIC U8 *
S_reghopmaybe(pTHX_ U8* s, I32 off)
{
    dTHR;
    if (off >= 0) {
	while (off-- && s < (U8*)PL_regeol)
	    s += UTF8SKIP(s);
	if (off >= 0)
	    return 0;
    }
    else {
	while (off++) {
	    if (s > (U8*)PL_bostr) {
		s--;
		if (*s & 0x80) {
		    while (s > (U8*)PL_bostr && (*s & 0xc0) == 0x80)
			s--;
		}		/* XXX could check well-formedness here */
	    }
	    else
		break;
	}
	if (off <= 0)
	    return 0;
    }
    return s;
}

#ifdef PERL_OBJECT
#include "XSUB.h"
#endif
a1835 15
static void
restore_pos(pTHXo_ void *arg)
{
    dTHR;
    if (PL_reg_eval_set) {
	if (PL_reg_oldsaved) {
	    PL_reg_re->subbeg = PL_reg_oldsaved;
	    PL_reg_re->sublen = PL_reg_oldsavedlen;
	    RX_MATCH_COPIED_on(PL_reg_re);
	}
	PL_reg_magic->mg_len = PL_reg_oldpos;
	PL_reg_eval_set = 0;
	PL_curpm = PL_reg_oldcurpm;
    }	
}
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d69 1
a69 1
 ****    Copyright (c) 1991-2001, Larry Wall
d109 1
a109 5
#ifdef DEBUGGING
#   define REGINCLASSUTF8(f,p)  (ARG1(f) ? reginclassutf8(f,p) : swash_fetch(*av_fetch((AV*)SvRV((SV*)PL_regdata->data[ARG2(f)]),0,FALSE),p))
#else
#   define REGINCLASSUTF8(f,p)  (ARG1(f) ? reginclassutf8(f,p) : swash_fetch((SV*)PL_regdata->data[ARG2(f)],p))
#endif
d127 1
d129 1
a129 2
#define REGCP_PAREN_ELEMS 4
    int paren_elems_to_push = (PL_regsize - parenfloor) * REGCP_PAREN_ELEMS;
d132 1
a132 2
#define REGCP_OTHER_ELEMS 5
    SSCHECK(paren_elems_to_push + REGCP_OTHER_ELEMS);
a133 1
/* REGCP_PARENS_ELEMS are pushed per pairs of parentheses. */
a138 1
/* REGCP_OTHER_ELEMS are pushed in any case, parentheses or no. */
d142 2
a143 6
#define REGCP_FRAME_ELEMS 2
/* REGCP_FRAME_ELEMS are part of the REGCP_OTHER_ELEMS and
 * are needed for the regexp context stack bookkeeping. */
    SSPUSHINT(paren_elems_to_push + REGCP_OTHER_ELEMS - REGCP_FRAME_ELEMS);
    SSPUSHINT(SAVEt_REGCONTEXT); /* Magic cookie. */

d148 1
a148 1
#  define REGCP_SET(cp)  DEBUG_r(PerlIO_printf(Perl_debug_log,		\
d150 1
a150 1
			     (IV)PL_savestack_ix)); cp = PL_savestack_ix
d152 1
a152 1
#  define REGCP_UNWIND(cp)  DEBUG_r(cp != PL_savestack_ix ?		\
d155 1
a155 1
				(IV)(cp), (IV)PL_savestack_ix) : 0); regcpblow(cp)
d160 2
a161 1
    I32 i;
d165 1
a165 2

    /* Pop REGCP_OTHER_ELEMS before the parentheses loop starts. */
a166 2
    assert(i == SAVEt_REGCONTEXT); /* Check that the magic cookie is there. */
    i = SSPOPINT; /* Parentheses elements to pop. */
d170 1
a170 4

    /* Now restore the parentheses context. */
    for (i -= (REGCP_OTHER_ELEMS - REGCP_FRAME_ELEMS);
	 i > 0; i -= REGCP_PAREN_ELEMS) {
a192 11
#if 1
    /* It would seem that the similar code in regtry()
     * already takes care of this, and in fact it is in
     * a better location to since this code can #if 0-ed out
     * but the code in regtry() is needed or otherwise tests
     * requiring null fields (pat.t#187 and split.t#{13,14}
     * (as of patchlevel 7877)  will fail.  Then again,
     * this code seems to be necessary or otherwise
     * building DynaLoader will fail:
     * "Error: '*' not in typemap in DynaLoader.xs, line 164"
     * --jhi */
a197 1
#endif
d204 1
d222 1
a222 17
#define regcpblow(cp) LEAVE_SCOPE(cp)	/* Ignores regcppush()ed data. */

#define TRYPAREN(paren, n, input) {				\
    if (paren) {						\
	if (n) {						\
	    PL_regstartp[paren] = HOPc(input, -1) - PL_bostr;	\
	    PL_regendp[paren] = input - PL_bostr;		\
	}							\
	else							\
	    PL_regendp[paren] = -1;				\
    }								\
    if (regmatch(next))						\
	sayYES;							\
    if (paren && n)						\
	PL_regendp[paren] = -1;					\
}

d247 1
a311 1
    char *strbeg;
a337 1
    strbeg = (sv && SvPOK(sv)) ? strend - SvCUR(sv) : strpos;
d344 1
a344 9
	if (!ml_anch) {
	  if ( !(prog->reganch & ROPT_ANCH_GPOS) /* Checked by the caller */
	       /* SvCUR is not set on references: SvRV and SvPVX overlap */
	       && sv && !SvROK(sv)
	       && (strpos != strbeg)) {
	      DEBUG_r(PerlIO_printf(Perl_debug_log, "Not at start...\n"));
	      goto fail;
	  }
	  if (prog->check_offset_min == prog->check_offset_max) {
d348 5
a377 1
	  }
a407 2
    other_last = Nullch;

d411 1
d562 1
a562 1
		    other_last = last;
d570 1
a570 1
		    other_last = s; /* Fix this later. --Hugo */
d600 1
a600 1
		    if (t < check_at - prog->check_offset_min) {
d602 1
a602 2
			    /* Since we moved from the found position,
			       we definitely contradict the found anchored
a612 2
			/* We don't contradict the found floating substring. */
			/* XXXX Why not check for STCLASS? */
d618 1
a618 4
		    /* Position contradicts check-string */
		    /* XXXX probably better to look for check-string
		       than for "\n", so one should lower the limit for t? */
		    DEBUG_r(PerlIO_printf(Perl_debug_log, "Found /%s^%s/m, restarting lookup for check-string at offset %ld...\n",
d620 1
a620 1
		    other_last = strpos = s = t + 1;
a628 4
	else {
	    DEBUG_r(PerlIO_printf(Perl_debug_log, "Starting position does not contradict /%s^%s/m...\n",
			PL_colors[0],PL_colors[1]));
	}
d635 1
a635 1
	/* The found string does not prohibit matching at strpos,
d637 1
a637 2
	   unless it was an MBOL and we are not after MBOL,
	   or a future STCLASS check will fail this. */
d641 2
a642 2
	if (ml_anch && sv && !SvROK(sv)	/* See prev comment on SvROK */
	    && (strpos != strbeg) && strpos[-1] != '\n'
d650 2
a651 2
	    PerlIO_printf(Perl_debug_log, "Position at offset %ld does not contradict /%s^%s/m...\n",
			(long)(strpos - i_strpos), PL_colors[0],PL_colors[1]);
a659 1
	    DEBUG_r(PerlIO_printf(Perl_debug_log, "... Disabling check substring...\n"));
a662 1
	    check = Nullsv;			/* abort */
d691 1
a691 1
	char *startpos = strbeg;
a724 2
		    if (!check)
			goto giveup;
d726 1
a726 1
				"Looking for %s substr starting at offset %ld...\n",
a734 2
		if (!check)
		    goto giveup;
d736 1
a736 1
			  "Looking for anchored substr starting at offset %ld...\n",
a743 2
		if (!check)
		    goto giveup;
d745 2
a746 2
			  "Looking for /%s^%s/m starting at offset %ld...\n",
			  PL_colors[0],PL_colors[1], (long)(t - i_strpos)) );
d765 2
a766 4
  giveup:
    DEBUG_r(PerlIO_printf(Perl_debug_log, "%s%s:%s match at offset %ld\n",
			  PL_colors[4], (check ? "Guessed" : "Giving up"),
			  PL_colors[5], (long)(s - i_strpos)) );
d878 2
a879 9
	    if (s == startpos)
		tmp = '\n';
	    else {
		U8 *r = reghop((U8*)s, -1);

		tmp = (I32)utf8_to_uv(r, s - (char*)r, 0, 0);
	    }
	    tmp = ((OP(c) == BOUNDUTF8 ?
		    isALNUM_uni(tmp) : isALNUM_LC_uni(tmp)) != 0);
d914 2
a915 9
	    if (s == startpos)
		tmp = '\n';
	    else {
		U8 *r = reghop((U8*)s, -1);

		tmp = (I32)utf8_to_uv(r, s - (char*)r, 0, 0);
	    }
	    tmp = ((OP(c) == NBOUNDUTF8 ?
		    isALNUM_uni(tmp) : isALNUM_LC_uni(tmp)) != 0);
d1273 1
a1434 4
#ifdef DEBUGGING
	int did_match = 0;
#endif

a1437 1
		    DEBUG_r( did_match = 1 );
a1448 1
		    DEBUG_r( did_match = 1 );
a1456 3
	DEBUG_r(did_match ||
		PerlIO_printf(Perl_debug_log,
			      "Did not find anchored character...\n"));
a1471 3
#ifdef DEBUGGING
	int did_match = 0;
#endif
a1489 1
	    DEBUG_r( did_match = 1 );
a1514 8
	DEBUG_r(did_match ||
		PerlIO_printf(Perl_debug_log, "Did not find %s substr `%s%.*s%s'%s...\n",
			      ((must == prog->anchored_substr)
			       ? "anchored" : "floating"),
			      PL_colors[0],
			      (int)(SvCUR(must) - (SvTAIL(must)!=0)),
			      SvPVX(must),
			      PL_colors[1], (SvTAIL(must) ? "$" : "")));
a1522 1
	DEBUG_r(PerlIO_printf(Perl_debug_log, "Contradicts stclass...\n"));
d1555 1
a1555 6
	    if (last == NULL) {
		DEBUG_r(PerlIO_printf(Perl_debug_log,
				      "%sCan't trim the tail, match fails (should not happen)%s\n",
				      PL_colors[4],PL_colors[5]));
		goto phooey; /* Should not happen! */
	    }
a1616 2
    DEBUG_r(PerlIO_printf(Perl_debug_log, "%sMatch failed%s\n",
			  PL_colors[4],PL_colors[5]));
d1628 1
a1633 3
#ifdef DEBUGGING
    PL_regindent = 0;	/* XXXX Not good when matches are reenterable... */
#endif
d1705 1
a1705 13
       this!  --ilya*/

    /* Tests pat.t#187 and split.t#{13,14} seem to depend on this code.
     * Actually, the code in regcppop() (which Ilya may be meaning by
     * PL_reglastparen), is not needed at all by the test suite
     * (op/regexp, op/pat, op/split), but that code is needed, oddly
     * enough, for building DynaLoader, or otherwise this
     * "Error: '*' not in typemap in DynaLoader.xs, line 164"
     * will happen.  Meanwhile, this code *is* needed for the
     * above-mentioned test suite tests to succeed.  The common theme
     * on those tests seems to be returning null fields from matches.
     * --jhi */
#if 1
d1709 1
a1709 1
	for (i = prog->nparens; i > *PL_reglastparen; i--) {
d1714 1
a1714 2
#endif
    REGCP_SET(lastcp);
d1719 1
a1719 1
    REGCP_UNWIND(lastcp);
a1722 30
#define RE_UNWIND_BRANCH	1
#define RE_UNWIND_BRANCHJ	2

union re_unwind_t;

typedef struct {		/* XX: makes sense to enlarge it... */
    I32 type;
    I32 prev;
    CHECKPOINT lastcp;
} re_unwind_generic_t;

typedef struct {
    I32 type;
    I32 prev;
    CHECKPOINT lastcp;
    I32 lastparen;
    regnode *next;
    char *locinput;
    I32 nextchr;
#ifdef DEBUGGING
    int regindent;
#endif
} re_unwind_branch_t;

typedef union re_unwind_t {
    I32 type;
    re_unwind_generic_t generic;
    re_unwind_branch_t branch;
} re_unwind_t;

d1740 1
a1751 3
    I32 unwind = 0;
    I32 firstcp = PL_savestack_ix;

d1761 1
a1761 1
#if 1
d1841 1
a1841 1
	    if (locinput == PL_bostr)
d1930 3
a1932 4
		    if (utf8_to_uv((U8*)s, e - s, 0, 0) !=
			(c1 ?
			 toLOWER_utf8((U8*)l) :
			 toLOWER_LC_utf8((U8*)l)))
d2067 2
a2068 7
	    if (locinput == PL_regbol)
		ln = PL_regprev;
	    else {
		U8 *r = reghop((U8*)locinput, -1);

		ln = utf8_to_uv(r, s - (char*)r, 0, 0);
	    }
d2366 1
a2366 1
		    REGCP_SET(lastcp);
d2396 1
a2396 1
		    REGCP_UNWIND(lastcp);
a2522 2
		/* No need to save/restore up to this paren */
		I32 parenfloor = scan->flags;
d2528 1
a2528 5
		/* XXXX Probably it is better to teach regpush to support
		   parenfloor > PL_regsize... */
		if (parenfloor > *PL_reglastparen)
		    parenfloor = *PL_reglastparen; /* Pessimization... */
		cc.parenfloor = parenfloor;
d2651 1
a2651 1
		    REGCP_SET(lastcp);
d2656 1
a2656 1
		    REGCP_UNWIND(lastcp);
d2683 1
a2683 1
		    REGCP_SET(lastcp);
d2688 1
a2688 1
		    REGCP_UNWIND(lastcp);
d2701 1
a2701 1
		    REGCP_SET(lastcp);
d2706 1
a2706 1
		    REGCP_UNWIND(lastcp);
d2752 1
a2752 19
		    I32 lastparen = *PL_reglastparen;
		    I32 unwind1;
		    re_unwind_branch_t *uw;

		    /* Put unwinding data on stack */
		    unwind1 = SSNEWt(1,re_unwind_branch_t);
		    uw = SSPTRt(unwind1,re_unwind_branch_t);
		    uw->prev = unwind;
		    unwind = unwind1;
		    uw->type = ((c1 == BRANCH)
				? RE_UNWIND_BRANCH
				: RE_UNWIND_BRANCHJ);
		    uw->lastparen = lastparen;
		    uw->next = next;
		    uw->locinput = locinput;
		    uw->nextchr = nextchr;
#ifdef DEBUGGING
		    uw->regindent = ++PL_regindent;
#endif
d2754 22
a2775 4
		    REGCP_SET(uw->lastcp);

		    /* Now go into the first branch */
		    next = inner;
d2825 1
a2825 1
		REGCP_SET(lastcp);
d2844 1
a2844 1
			REGCP_UNWIND(lastcp);
d2884 1
a2884 1
		REGCP_SET(lastcp);
d2906 1
a2906 1
			REGCP_UNWIND(lastcp);
d2967 1
a2967 1
		REGCP_SET(lastcp);
d2995 10
a3004 1
			TRYPAREN(paren, ln, locinput);
d3006 1
a3006 1
			REGCP_UNWIND(lastcp);
d3018 11
a3028 2
			TRYPAREN(paren, n, PL_reginput);
			REGCP_UNWIND(lastcp);
d3053 1
a3053 1
		REGCP_SET(lastcp);
d3061 11
a3071 2
				TRYPAREN(paren, n, PL_reginput);
				REGCP_UNWIND(lastcp);
d3085 3
a3087 2
				TRYPAREN(paren, n, PL_reginput);
				REGCP_UNWIND(lastcp);
d3105 1
a3105 1
		REGCP_SET(lastcp);
d3118 1
a3118 1
		REGCP_UNWIND(lastcp);
a3224 1
      reenter:
a3249 5

#if 0					/* Breaks $^R */
    if (unwind)
	regcpblow(firstcp);
#endif
a3260 49
    if (unwind) {
	re_unwind_t *uw = SSPTRt(unwind,re_unwind_t);

	switch (uw->type) {
	case RE_UNWIND_BRANCH:
	case RE_UNWIND_BRANCHJ:
	{
	    re_unwind_branch_t *uwb = &(uw->branch);
	    I32 lastparen = uwb->lastparen;
	    
	    REGCP_UNWIND(uwb->lastcp);
	    for (n = *PL_reglastparen; n > lastparen; n--)
		PL_regendp[n] = -1;
	    *PL_reglastparen = n;
	    scan = next = uwb->next;
	    if ( !scan || 
		 OP(scan) != (uwb->type == RE_UNWIND_BRANCH 
			      ? BRANCH : BRANCHJ) ) {		/* Failure */
		unwind = uwb->prev;
#ifdef DEBUGGING
		PL_regindent--;
#endif
		goto do_no;
	    }
	    /* Have more choice yet.  Reuse the same uwb.  */
	    /*SUPPRESS 560*/
	    if ((n = (uwb->type == RE_UNWIND_BRANCH
		      ? NEXT_OFF(next) : ARG(next))))
		next += n;
	    else
		next = NULL;	/* XXXX Needn't unwinding in this case... */
	    uwb->next = next;
	    next = NEXTOPER(scan);
	    if (uwb->type == RE_UNWIND_BRANCHJ)
		next = NEXTOPER(next);
	    locinput = uwb->locinput;
	    nextchr = uwb->nextchr;
#ifdef DEBUGGING
	    PL_regindent = uwb->regindent;
#endif

	    goto reenter;
	}
	/* NOT REACHED */
	default:
	    Perl_croak(aTHX_ "regexp unwind memory corruption");
	}
	/* NOT REACHED */
    }
d3278 1
d3490 1
d3541 1
d3588 1
a3588 5
	    (ANYOF_CLASS_TEST(p, ANYOF_NXDIGIT) && !isXDIGIT(c))    ||
	    (ANYOF_CLASS_TEST(p, ANYOF_PSXSPC)  &&  isPSXSPC(c))    ||
	    (ANYOF_CLASS_TEST(p, ANYOF_NPSXSPC) && !isPSXSPC(c))    ||
	    (ANYOF_CLASS_TEST(p, ANYOF_BLANK)   &&  isBLANK(c))     ||
	    (ANYOF_CLASS_TEST(p, ANYOF_NBLANK)  && !isBLANK(c))
d3601 1
d3604 1
a3604 8
#ifdef DEBUGGING
    SV *rv = (SV*)PL_regdata->data[ARG2(f)];
    AV *av = (AV*)SvRV((SV*)rv);
    SV *sw = *av_fetch(av, 0, FALSE);
    SV *lv = *av_fetch(av, 1, FALSE);
#else
    SV *sw = (SV*)PL_regdata->data[ARG2(f)];
#endif
d3606 1
a3606 1
    if (swash_fetch(sw, p))
d3609 1
a3609 1
	U8 tmpbuf[UTF8_MAXLEN+1];
d3616 1
a3616 1
	if (swash_fetch(sw, tmpbuf))
d3628 1
d3650 1
d3682 1
d3694 1
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d41 1
a41 2
#  define Perl_reginitcolors my_reginitcolors
#  define Perl_regclass_swash my_regclass_swash
d44 1
a44 1
#endif
d69 1
a69 1
 ****    Copyright (c) 1991-2002, Larry Wall
d82 6
d95 1
a95 1
#define UTF ((PL_reg_flags & RF_utf8) != 0)
a103 2
#define REGINCLASS(p,c)  (ANYOF_FLAGS(p) ? reginclass(p,c,0,0) : ANYOF_BITMAP_TEST(p,*(c)))

d108 9
a116 2
#define CHR_SVLEN(sv) (do_utf8 ? sv_len_utf8(sv) : SvCUR(sv))
#define CHR_DIST(a,b) (PL_reg_match_utf8 ? utf8_distance(a,b) : a - b)
d120 2
a121 2
#define HOP(pos,off) (PL_reg_match_utf8 ? reghop((U8*)pos, off) : (U8*)(pos + off))
#define HOPMAYBE(pos,off) (PL_reg_match_utf8 ? reghopmaybe((U8*)pos, off) : (U8*)(pos + off))
d125 1
a125 44
#define HOPBACK(pos, off) (		\
    (PL_reg_match_utf8)			\
	? reghopmaybe((U8*)pos, -off)	\
    : (pos - off >= PL_bostr)		\
	? (U8*)(pos - off)		\
    : (U8*)NULL				\
)
#define HOPBACKc(pos, off) (char*)HOPBACK(pos, off)

#define reghop3_c(pos,off,lim) ((char*)reghop3((U8*)pos, off, (U8*)lim))
#define reghopmaybe3_c(pos,off,lim) ((char*)reghopmaybe3((U8*)pos, off, (U8*)lim))
#define HOP3(pos,off,lim) (PL_reg_match_utf8 ? reghop3((U8*)pos, off, (U8*)lim) : (U8*)(pos + off))
#define HOPMAYBE3(pos,off,lim) (PL_reg_match_utf8 ? reghopmaybe3((U8*)pos, off, (U8*)lim) : (U8*)(pos + off))
#define HOP3c(pos,off,lim) ((char*)HOP3(pos,off,lim))
#define HOPMAYBE3c(pos,off,lim) ((char*)HOPMAYBE3(pos,off,lim))

#define LOAD_UTF8_CHARCLASS(a,b) STMT_START { if (!CAT2(PL_utf8_,a)) { ENTER; save_re_context(); (void)CAT2(is_utf8_, a)((U8*)b); LEAVE; } } STMT_END

/* for use after a quantifier and before an EXACT-like node -- japhy */
#define JUMPABLE(rn) ( \
    OP(rn) == OPEN || OP(rn) == CLOSE || OP(rn) == EVAL || \
    OP(rn) == SUSPEND || OP(rn) == IFMATCH || \
    OP(rn) == PLUS || OP(rn) == MINMOD || \
    (PL_regkind[(U8)OP(rn)] == CURLY && ARG1(rn) > 0) \
)

#define HAS_TEXT(rn) ( \
    PL_regkind[(U8)OP(rn)] == EXACT || PL_regkind[(U8)OP(rn)] == REF \
)

/*
  Search for mandatory following text node; for lookahead, the text must
  follow but for lookbehind (rn->flags != 0) we skip to the next step.
*/
#define FIND_NEXT_IMPT(rn) STMT_START { \
    while (JUMPABLE(rn)) \
	if (OP(rn) == SUSPEND || PL_regkind[(U8)OP(rn)] == CURLY) \
	    rn = NEXTOPER(NEXTOPER(rn)); \
	else if (OP(rn) == PLUS) \
	    rn = NEXTOPER(rn); \
	else if (OP(rn) == IFMATCH) \
	    rn = (rn->flags == 0) ? NEXTOPER(NEXTOPER(rn)) : rn + ARG(rn); \
	else rn += NEXT_OFF(rn); \
} STMT_END 
a126 1
static void restore_pos(pTHX_ void *arg);
d136 1
a136 4
    if (paren_elems_to_push < 0)
	Perl_croak(aTHX_ "panic: paren_elems_to_push < 0");

#define REGCP_OTHER_ELEMS 6
a147 1
    SSPUSHINT(*PL_reglastcloseparen);
a180 1
    *PL_reglastcloseparen = SSPOPINT;
d196 1
a196 1
			  (UV)paren, (IV)PL_regstartp[paren],
d198 1
a198 1
			  (IV)PL_regendp[paren],
d203 1
a203 1
	if ((I32)(*PL_reglastparen + 1) <= PL_regnpar) {
d220 2
a221 2
    for (paren = *PL_reglastparen + 1; (I32)paren <= PL_regnpar; paren++) {
	if ((I32)paren > PL_regsize)
d283 1
a283 1
	regexec_flags(prog, stringarg, strend, strbeg, minend, screamer, NULL,
d295 2
a296 2
    PL_regdata = prog->data;
    PL_reg_re = prog;
d299 1
a299 1
/*
d349 1
a349 1
    register I32 start_shift = 0;
d351 1
a351 1
    register I32 end_shift   = 0;
a355 1
    int do_utf8 = sv ? SvUTF8(sv) : 0;	/* if no sv we have to assume bytes */
d357 1
d359 1
a359 1
    char *check_at = Nullch;		/* check substr found at this pos */
a361 1
    SV *dsv = PERL_DEBUG_PAD_ZERO(0);
d364 12
a375 5
    if (prog->reganch & ROPT_UTF8) {
	DEBUG_r(PerlIO_printf(Perl_debug_log,
			      "UTF-8 regex...\n"));
	PL_reg_flags |= RF_utf8;
    }
a376 25
    DEBUG_r({
	 char *s   = PL_reg_match_utf8 ?
	                 sv_uni_display(dsv, sv, 60, UNI_DISPLAY_REGEX) :
	                 strpos;
	 int   len = PL_reg_match_utf8 ?
	                 strlen(s) : strend - strpos;
	 if (!PL_colorset)
	      reginitcolors();
	 if (PL_reg_match_utf8)
	     DEBUG_r(PerlIO_printf(Perl_debug_log,
				   "UTF-8 target...\n"));
	 PerlIO_printf(Perl_debug_log,
		       "%sGuessing start of match, REx%s `%s%.60s%s%s' against `%s%.*s%s%s'...\n",
		       PL_colors[4],PL_colors[5],PL_colors[0],
		       prog->precomp,
		       PL_colors[1],
		       (strlen(prog->precomp) > 60 ? "..." : ""),
		       PL_colors[0],
		       (int)(len > 60 ? 60 : len),
		       s, PL_colors[1],
		       (len > 60 ? "..." : "")
	      );
    });

    /* CHR_DIST() would be more correct here but it makes things slow. */
d378 1
a378 2
	DEBUG_r(PerlIO_printf(Perl_debug_log,
			      "String too short... [re_intuit_start]\n"));
d382 1
a382 15
    PL_regeol = strend;
    if (do_utf8) {
	if (!prog->check_utf8 && prog->check_substr)
	    to_utf8_substr(prog);
	check = prog->check_utf8;
    } else {
	if (!prog->check_substr && prog->check_utf8)
	    to_byte_substr(prog);
	check = prog->check_substr;
    }
   if (check == &PL_sv_undef) {
	DEBUG_r(PerlIO_printf(Perl_debug_log,
		"Non-utf string cannot match utf check string\n"));
	goto fail;
    }
d389 1
a389 2
	  if ( !(prog->reganch & (ROPT_ANCH_GPOS /* Checked by the caller */
				  | ROPT_IMPLICIT)) /* not a real BOL */
d396 1
a396 2
	  if (prog->check_offset_min == prog->check_offset_max &&
	      !(prog->reganch & ROPT_CANY_SEEN)) {
d400 2
a401 1
	    s = HOP3c(strpos, prog->check_offset_min, strend);
d405 1
a405 1
		if ( strend - s > slen || strend - s < slen - 1
d435 1
a435 1
	    I32 eshift = CHR_DIST((U8*)strend, (U8*)s) - end;
d456 2
d468 1
a468 1
	    s = screaminstr(sv, check,
a474 4
    else if (prog->reganch & ROPT_CANY_SEEN)
	s = fbm_instr((U8*)(s + start_shift),
		      (U8*)(strend - end_shift),
		      check, PL_multiline ? FBMrf_MULTILINE : 0);
d476 2
a477 2
	s = fbm_instr(HOP3(s, start_shift, strend),
		      HOP3(strend, -end_shift, strbeg),
d485 1
a485 1
			  (check == (do_utf8 ? prog->anchored_utf8 : prog->anchored_substr) ? "anchored" : "floating"),
d508 1
a508 1
    if (do_utf8 ? (prog->float_utf8 && prog->anchored_utf8) : (prog->float_substr && prog->anchored_substr)) {
d513 1
a513 1
	if (check == (do_utf8 ? prog->float_utf8 : prog->float_substr)) {
d516 1
a516 1
		char *last = HOP3c(s, -start_shift, strbeg), *last1, *last2;
a517 1
		SV* must;
d519 1
d523 2
a524 1
			|| ((t = reghopmaybe3_c(s, -(prog->check_offset_max), strpos))
d529 1
a529 1
		t = HOP3c(t, prog->anchored_offset, strend);
d532 2
a533 1
		last2 = last1 = HOP3c(strend, -prog->minlen, strbeg);
d538 6
a543 15
		must = do_utf8 ? prog->anchored_utf8 : prog->anchored_substr;
		if (must == &PL_sv_undef) {
		    s = (char*)NULL;
		    DEBUG_r(must = prog->anchored_utf8);	/* for debug */
		}
		else
		    s = fbm_instr(
			(unsigned char*)t,
			HOP3(HOP3(last1, prog->anchored_offset, strend)
				+ SvCUR(must), -(SvTAIL(must)!=0), strbeg),
			must,
			PL_multiline ? FBMrf_MULTILINE : 0
		    );
		DEBUG_r(PerlIO_printf(Perl_debug_log,
			"%s anchored substr `%s%.*s%s'%s",
d546 4
a549 4
			  (int)(SvCUR(must)
			  - (SvTAIL(must)!=0)),
			  SvPVX(must),
			  PL_colors[1], (SvTAIL(must) ? "$" : "")));
d558 4
a561 3
			(long)(HOP3c(s1, 1, strend) - i_strpos)));
		    other_last = HOP3c(last1, prog->anchored_offset+1, strend);
		    s = HOP3c(last, 1, strend);
d567 2
a568 2
		    t = HOP3c(s, -prog->anchored_offset, strbeg);
		    other_last = HOP3c(s, 1, strend);
d577 10
a586 12
	    char *last, *last1;
	    char *s1 = s;
	    SV* must;

	    t = HOP3c(s, -start_shift, strbeg);
	    last1 = last =
		HOP3c(strend, -prog->minlen + prog->float_min_offset, strbeg);
	    if (CHR_DIST((U8*)last, (U8*)t) > prog->float_max_offset)
		last = HOP3c(t, prog->float_max_offset, strend);
	    s = HOP3c(t, prog->float_min_offset, strend);
	    if (s < other_last)
		s = other_last;
d588 3
a590 9
	    must = do_utf8 ? prog->float_utf8 : prog->float_substr;
	    /* fbm_instr() takes into account exact value of end-of-str
	       if the check is SvTAIL(ed).  Since false positives are OK,
	       and end-of-str is not later than strend we are OK. */
	    if (must == &PL_sv_undef) {
		s = (char*)NULL;
		DEBUG_r(must = prog->float_utf8);	/* for debug message */
	    }
	    else
d592 16
a607 11
			      (unsigned char*)last + SvCUR(must)
				  - (SvTAIL(must)!=0),
			      must, PL_multiline ? FBMrf_MULTILINE : 0);
	    DEBUG_r(PerlIO_printf(Perl_debug_log, "%s floating substr `%s%.*s%s'%s",
		    (s ? "Found" : "Contradicts"),
		    PL_colors[0],
		      (int)(SvCUR(must) - (SvTAIL(must)!=0)),
		      SvPVX(must),
		      PL_colors[1], (SvTAIL(must) ? "$" : "")));
	    if (!s) {
		if (last1 == last) {
d609 15
a623 2
					    ", giving up...\n"));
		    goto fail_finish;
a624 16
		DEBUG_r(PerlIO_printf(Perl_debug_log,
		    ", trying anchored starting at offset %ld...\n",
		    (long)(s1 + 1 - i_strpos)));
		other_last = last;
		s = HOP3c(t, 1, strend);
		goto restart;
	    }
	    else {
		DEBUG_r(PerlIO_printf(Perl_debug_log, " at offset %ld...\n",
		      (long)(s - i_strpos)));
		other_last = s; /* Fix this later. --Hugo */
		s = s1;
		if (t == strpos)
		    goto try_at_start;
		goto try_at_offset;
	    }
d629 1
d632 4
a635 2
	    || ((t = reghopmaybe3_c(s, -prog->check_offset_max, strpos))
		 && t > strpos))) {
d650 1
a650 1
			if (do_utf8 ? prog->anchored_utf8 : prog->anchored_substr) {
d658 1
a658 1
			    strpos = t + 1;			
d690 1
a690 1
	++BmUSEFUL(do_utf8 ? prog->check_utf8 : prog->check_substr);	/* hooray/5 */
d693 1
d715 3
a717 9
	    && (do_utf8 ? (
		prog->check_utf8		/* Could be deleted already */
		&& --BmUSEFUL(prog->check_utf8) < 0
		&& (prog->check_utf8 == prog->float_utf8)
	    ) : (
		prog->check_substr		/* Could be deleted already */
		&& --BmUSEFUL(prog->check_substr) < 0
		&& (prog->check_substr == prog->float_substr)
	    )))
d721 3
a723 5
	    SvREFCNT_dec(do_utf8 ? prog->check_utf8 : prog->check_substr);
	    if (do_utf8 ? prog->check_substr : prog->check_utf8)
		SvREFCNT_dec(do_utf8 ? prog->check_substr : prog->check_utf8);
	    prog->check_substr = prog->check_utf8 = Nullsv;	/* disable */
	    prog->float_substr = prog->float_utf8 = Nullsv;	/* clear */
a745 1
	U8* str = (U8*)STRING(prog->regstclass);
d747 1
a747 1
		    ? CHR_DIST(str+STR_LEN(prog->regstclass), str)
d749 4
a752 6
	char *endpos = (prog->anchored_substr || prog->anchored_utf8 || ml_anch)
		? HOP3c(s, (prog->minlen ? cl_l : 0), strend)
		: (prog->float_substr || prog->float_utf8
		   ? HOP3c(HOP3c(check_at, -start_shift, strbeg),
			   cl_l, strend)
		   : strend);
d757 1
a757 1
	    PL_regdata = prog->data;
d760 1
a760 1
	s = find_byclass(prog, prog->regstclass, s, endpos, startpos, 1);
d763 1
a763 1
	    char *what = 0;
d775 2
a776 2
	    if (prog->anchored_substr || prog->anchored_utf8) {
		if ((do_utf8 ? prog->anchored_utf8 : prog->anchored_substr) == check) {
d779 2
a780 1
		    s = HOP3c(t, 1, strend);
d798 1
a798 1
		s = check_at;
d817 1
a817 1
	    if (!(do_utf8 ? prog->float_utf8 : prog->float_substr))	/* Could have been deleted */
d825 2
a826 2
	if (t != s) {
            DEBUG_r(PerlIO_printf(Perl_debug_log,
d828 4
a831 8
                                  (long)(t - i_strpos), (long)(s - i_strpos))
                   );
        }
        else {
            DEBUG_r(PerlIO_printf(Perl_debug_log,
                                  "Does not contradict STCLASS...\n"); 
                   );
        }
d840 2
a841 2
    if (prog->check_substr || prog->check_utf8)		/* could be removed already */
	BmUSEFUL(do_utf8 ? prog->check_utf8 : prog->check_substr) += 5; /* hooray */
a858 1
	register bool do_utf8 = PL_reg_match_utf8;
d862 1
a862 1
	case ANYOF:
d864 1
a864 10
		STRLEN skip = do_utf8 ? UTF8SKIP(s) : 1;
		  
		if (do_utf8 ?
		    reginclass(c, (U8*)s, 0, do_utf8) :
		    REGINCLASS(c, (U8*)s) ||
		    (ANYOF_FOLD_SHARP_S(c, s, strend) &&
		     /* The assignment of 2 is intentional:
		      * for the sharp s, the skip is 2. */
		     (skip = SHARP_S_SKIP)
		     )) {
d870 1
a870 1
		else 
d872 1
a872 1
		s += skip;
d875 1
a875 1
	case CANY:
d877 6
a882 2
	        if (tmp && (norun || regtry(prog, s)))
		    goto got_it;
d884 1
a884 1
		    tmp = doevery;
d891 2
a892 17
	    if (UTF) {
	        STRLEN ulen1, ulen2;
		U8 tmpbuf1[UTF8_MAXLEN_UCLC+1];
		U8 tmpbuf2[UTF8_MAXLEN_UCLC+1];

		to_utf8_lower((U8*)m, tmpbuf1, &ulen1);
		to_utf8_upper((U8*)m, tmpbuf2, &ulen2);

		c1 = utf8n_to_uvchr(tmpbuf1, UTF8_MAXLEN_UCLC, 
				    0, ckWARN(WARN_UTF8) ? 0 : UTF8_ALLOW_ANY);
		c2 = utf8n_to_uvchr(tmpbuf2, UTF8_MAXLEN_UCLC,
				    0, ckWARN(WARN_UTF8) ? 0 : UTF8_ALLOW_ANY);
	    }
	    else {
		c1 = *(U8*)m;
		c2 = PL_fold[c1];
	    }
d900 1
a900 1
	    e = HOP3c(strend, -(I32)ln, s);
d904 10
a913 44

	    /* The idea in the EXACTF* cases is to first find the
	     * first character of the EXACTF* node and then, if
	     * necessary, case-insensitively compare the full
	     * text of the node.  The c1 and c2 are the first
	     * characters (though in Unicode it gets a bit
	     * more complicated because there are more cases
	     * than just upper and lower: one needs to use
	     * the so-called folding case for case-insensitive
	     * matching (called "loose matching" in Unicode).
	     * ibcmp_utf8() will do just that. */

	    if (do_utf8) {
	        UV c, f;
	        U8 tmpbuf [UTF8_MAXLEN+1];
		U8 foldbuf[UTF8_MAXLEN_FOLD+1];
		STRLEN len, foldlen;
		
		if (c1 == c2) {
		    while (s <= e) {
		        c = utf8n_to_uvchr((U8*)s, UTF8_MAXLEN, &len,
					   ckWARN(WARN_UTF8) ?
					   0 : UTF8_ALLOW_ANY);
			if ( c == c1
			     && (ln == len ||
				 ibcmp_utf8(s, (char **)0, 0,  do_utf8,
					    m, (char **)0, ln, (bool)UTF))
			     && (norun || regtry(prog, s)) )
			    goto got_it;
			else {
			     uvchr_to_utf8(tmpbuf, c);
			     f = to_utf8_fold(tmpbuf, foldbuf, &foldlen);
			     if ( f != c
				  && (f == c1 || f == c2)
				  && (ln == foldlen ||
				      !ibcmp_utf8((char *) foldbuf,
						  (char **)0, foldlen, do_utf8,
						  m,
						  (char **)0, ln, (bool)UTF))
				  && (norun || regtry(prog, s)) )
				  goto got_it;
			}
			s += len;
		    }
d915 9
a923 38
		else {
		    while (s <= e) {
		      c = utf8n_to_uvchr((U8*)s, UTF8_MAXLEN, &len,
					   ckWARN(WARN_UTF8) ?
					   0 : UTF8_ALLOW_ANY);

			/* Handle some of the three Greek sigmas cases.
			 * Note that not all the possible combinations
			 * are handled here: some of them are handled
			 * by the standard folding rules, and some of
			 * them (the character class or ANYOF cases)
			 * are handled during compiletime in
			 * regexec.c:S_regclass(). */
			if (c == (UV)UNICODE_GREEK_CAPITAL_LETTER_SIGMA ||
			    c == (UV)UNICODE_GREEK_SMALL_LETTER_FINAL_SIGMA)
			    c = (UV)UNICODE_GREEK_SMALL_LETTER_SIGMA;

			if ( (c == c1 || c == c2)
			     && (ln == len ||
				 ibcmp_utf8(s, (char **)0, 0,  do_utf8,
					    m, (char **)0, ln, (bool)UTF))
			     && (norun || regtry(prog, s)) )
			    goto got_it;
			else {
			     uvchr_to_utf8(tmpbuf, c);
			     f = to_utf8_fold(tmpbuf, foldbuf, &foldlen);
			     if ( f != c
				  && (f == c1 || f == c2)
				  && (ln == foldlen ||
				      !ibcmp_utf8((char *) foldbuf,
						  (char **)0, foldlen, do_utf8,
						  m,
						  (char **)0, ln, (bool)UTF))
				  && (norun || regtry(prog, s)) )
				  goto got_it;
			}
			s += len;
		    }
a925 22
	    else {
		if (c1 == c2)
		    while (s <= e) {
			if ( *(U8*)s == c1
			     && (ln == 1 || !(OP(c) == EXACTF
					      ? ibcmp(s, m, ln)
					      : ibcmp_locale(s, m, ln)))
			     && (norun || regtry(prog, s)) )
			    goto got_it;
			s++;
		    }
		else
		    while (s <= e) {
			if ( (*(U8*)s == c1 || *(U8*)s == c2)
			     && (ln == 1 || !(OP(c) == EXACTF
					      ? ibcmp(s, m, ln)
					      : ibcmp_locale(s, m, ln)))
			     && (norun || regtry(prog, s)) )
			    goto got_it;
			s++;
		    }
	    }
d931 7
a937 21
	    if (do_utf8) {
		if (s == PL_bostr)
		    tmp = '\n';
		else {
		    U8 *r = reghop3((U8*)s, -1, (U8*)PL_bostr);
		
		    tmp = utf8n_to_uvchr(r, UTF8SKIP(r), 0, 0);
		}
		tmp = ((OP(c) == BOUND ?
			isALNUM_uni(tmp) : isALNUM_LC_uvchr(UNI_TO_NATIVE(tmp))) != 0);
		LOAD_UTF8_CHARCLASS(alnum,"a");
		while (s < strend) {
		    if (tmp == !(OP(c) == BOUND ?
				 swash_fetch(PL_utf8_alnum, (U8*)s, do_utf8) :
				 isALNUM_LC_utf8((U8*)s)))
		    {
			tmp = !tmp;
			if ((norun || regtry(prog, s)))
			    goto got_it;
		    }
		    s += UTF8SKIP(s);
d939 1
d941 9
d951 14
a964 10
		tmp = (s != PL_bostr) ? UCHARAT(s - 1) : '\n';
		tmp = ((OP(c) == BOUND ? isALNUM(tmp) : isALNUM_LC(tmp)) != 0);
		while (s < strend) {
		    if (tmp ==
			!(OP(c) == BOUND ? isALNUM(*s) : isALNUM_LC(*s))) {
			tmp = !tmp;
			if ((norun || regtry(prog, s)))
			    goto got_it;
		    }
		    s++;
d966 1
d975 8
a982 20
	    if (do_utf8) {
		if (s == PL_bostr)
		    tmp = '\n';
		else {
		    U8 *r = reghop3((U8*)s, -1, (U8*)PL_bostr);
		
		    tmp = utf8n_to_uvchr(r, UTF8SKIP(r), 0, 0);
		}
		tmp = ((OP(c) == NBOUND ?
			isALNUM_uni(tmp) : isALNUM_LC_uvchr(UNI_TO_NATIVE(tmp))) != 0);
		LOAD_UTF8_CHARCLASS(alnum,"a");
		while (s < strend) {
		    if (tmp == !(OP(c) == NBOUND ?
				 swash_fetch(PL_utf8_alnum, (U8*)s, do_utf8) :
				 isALNUM_LC_utf8((U8*)s)))
			tmp = !tmp;
		    else if ((norun || regtry(prog, s)))
			goto got_it;
		    s += UTF8SKIP(s);
		}
d984 9
d994 14
a1007 11
		tmp = (s != PL_bostr) ? UCHARAT(s - 1) : '\n';
		tmp = ((OP(c) == NBOUND ?
			isALNUM(tmp) : isALNUM_LC(tmp)) != 0);
		while (s < strend) {
		    if (tmp ==
			!(OP(c) == NBOUND ? isALNUM(*s) : isALNUM_LC(*s)))
			tmp = !tmp;
		    else if ((norun || regtry(prog, s)))
			goto got_it;
		    s++;
		}
d1013 4
a1016 9
	    if (do_utf8) {
		LOAD_UTF8_CHARCLASS(alnum,"a");
		while (s < strend) {
		    if (swash_fetch(PL_utf8_alnum, (U8*)s, do_utf8)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
d1018 1
a1018 2
			tmp = 1;
		    s += UTF8SKIP(s);
d1020 3
d1024 6
a1029 8
	    else {
		while (s < strend) {
		    if (isALNUM(*s)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
d1031 1
a1031 2
			tmp = 1;
		    s++;
d1033 3
d1040 4
a1043 8
	    if (do_utf8) {
		while (s < strend) {
		    if (isALNUM_LC_utf8((U8*)s)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
d1045 1
a1045 2
			tmp = 1;
		    s += UTF8SKIP(s);
d1047 3
d1051 7
a1057 8
	    else {
		while (s < strend) {
		    if (isALNUM_LC(*s)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
d1059 1
a1059 2
			tmp = 1;
		    s++;
d1061 3
d1067 4
a1070 9
	    if (do_utf8) {
		LOAD_UTF8_CHARCLASS(alnum,"a");
		while (s < strend) {
		    if (!swash_fetch(PL_utf8_alnum, (U8*)s, do_utf8)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
d1072 1
a1072 2
			tmp = 1;
		    s += UTF8SKIP(s);
d1074 3
d1078 6
a1083 8
	    else {
		while (s < strend) {
		    if (!isALNUM(*s)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
d1085 1
a1085 2
			tmp = 1;
		    s++;
d1087 3
d1094 4
a1097 8
	    if (do_utf8) {
		while (s < strend) {
		    if (!isALNUM_LC_utf8((U8*)s)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
d1099 1
a1099 2
			tmp = 1;
		    s += UTF8SKIP(s);
d1101 3
d1105 7
a1111 8
	    else {
		while (s < strend) {
		    if (!isALNUM_LC(*s)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
d1113 1
a1113 2
			tmp = 1;
		    s++;
d1115 3
d1121 4
a1124 9
	    if (do_utf8) {
		LOAD_UTF8_CHARCLASS(space," ");
		while (s < strend) {
		    if (*s == ' ' || swash_fetch(PL_utf8_space,(U8*)s, do_utf8)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
d1126 1
a1126 2
			tmp = 1;
		    s += UTF8SKIP(s);
d1128 3
d1132 6
a1137 8
	    else {
		while (s < strend) {
		    if (isSPACE(*s)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
d1139 1
a1139 2
			tmp = 1;
		    s++;
d1141 3
d1148 4
a1151 8
	    if (do_utf8) {
		while (s < strend) {
		    if (*s == ' ' || isSPACE_LC_utf8((U8*)s)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
d1153 1
a1153 2
			tmp = 1;
		    s += UTF8SKIP(s);
d1155 3
d1159 7
a1165 8
	    else {
		while (s < strend) {
		    if (isSPACE_LC(*s)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
d1167 1
a1167 2
			tmp = 1;
		    s++;
d1169 3
d1175 4
a1178 9
	    if (do_utf8) {
		LOAD_UTF8_CHARCLASS(space," ");
		while (s < strend) {
		    if (!(*s == ' ' || swash_fetch(PL_utf8_space,(U8*)s, do_utf8))) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
d1180 1
a1180 2
			tmp = 1;
		    s += UTF8SKIP(s);
d1182 3
d1186 6
a1191 8
	    else {
		while (s < strend) {
		    if (!isSPACE(*s)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
d1193 1
a1193 2
			tmp = 1;
		    s++;
d1195 3
d1202 4
a1205 8
	    if (do_utf8) {
		while (s < strend) {
		    if (!(*s == ' ' || isSPACE_LC_utf8((U8*)s))) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
d1207 1
a1207 2
			tmp = 1;
		    s += UTF8SKIP(s);
d1209 3
d1213 7
a1219 8
	    else {
		while (s < strend) {
		    if (!isSPACE_LC(*s)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
d1221 1
a1221 2
			tmp = 1;
		    s++;
d1223 3
d1229 4
a1232 9
	    if (do_utf8) {
		LOAD_UTF8_CHARCLASS(digit,"0");
		while (s < strend) {
		    if (swash_fetch(PL_utf8_digit,(U8*)s, do_utf8)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
d1234 1
a1234 2
			tmp = 1;
		    s += UTF8SKIP(s);
d1236 3
d1240 6
a1245 8
	    else {
		while (s < strend) {
		    if (isDIGIT(*s)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
d1247 1
a1247 2
			tmp = 1;
		    s++;
d1249 3
d1256 4
a1259 8
	    if (do_utf8) {
		while (s < strend) {
		    if (isDIGIT_LC_utf8((U8*)s)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
d1261 1
a1261 2
			tmp = 1;
		    s += UTF8SKIP(s);
d1263 3
d1267 7
a1273 8
	    else {
		while (s < strend) {
		    if (isDIGIT_LC(*s)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
d1275 1
a1275 2
			tmp = 1;
		    s++;
d1277 3
d1283 4
a1286 9
	    if (do_utf8) {
		LOAD_UTF8_CHARCLASS(digit,"0");
		while (s < strend) {
		    if (!swash_fetch(PL_utf8_digit,(U8*)s, do_utf8)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
d1288 1
a1288 2
			tmp = 1;
		    s += UTF8SKIP(s);
d1290 3
d1294 6
a1299 8
	    else {
		while (s < strend) {
		    if (!isDIGIT(*s)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
d1301 1
a1301 2
			tmp = 1;
		    s++;
d1303 3
d1310 4
a1313 8
	    if (do_utf8) {
		while (s < strend) {
		    if (!isDIGIT_LC_utf8((U8*)s)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
d1315 1
a1315 2
			tmp = 1;
		    s += UTF8SKIP(s);
d1317 3
d1321 7
a1327 8
	    else {
		while (s < strend) {
		    if (!isDIGIT_LC(*s)) {
			if (tmp && (norun || regtry(prog, s)))
			    goto got_it;
			else
			    tmp = doevery;
		    }
d1329 1
a1329 2
			tmp = 1;
		    s++;
d1331 3
a1367 5
    bool do_utf8 = DO_UTF8(sv);
#ifdef DEBUGGING
    SV *dsv0 = PERL_DEBUG_PAD_ZERO(0);
    SV *dsv1 = PERL_DEBUG_PAD_ZERO(1);
#endif
d1373 1
a1373 1
    PL_regnarrate = DEBUG_r_TEST;
d1383 8
a1390 4
    if (strend - startpos < minlen) {
        DEBUG_r(PerlIO_printf(Perl_debug_log,
			      "String too short [regexec_flags]...\n"));
	goto phooey;
d1429 1
a1429 2
		  && (mg = mg_find(sv, PERL_MAGIC_regex_global))
		  && mg->mg_len >= 0) {
d1432 1
a1432 1
	        if (s > PL_reg_ganch)
d1441 1
a1441 1
    if (!(flags & REXEC_CHECKED) && (prog->check_substr != Nullsv || prog->check_utf8 != Nullsv)) {
d1447 1
a1447 2
	if (!s) {
	    DEBUG_r(PerlIO_printf(Perl_debug_log, "Not present...\n"));
a1448 1
	}
d1451 12
a1462 23
    DEBUG_r({
	 char *s0   = UTF ?
	   pv_uni_display(dsv0, (U8*)prog->precomp, prog->prelen, 60,
			  UNI_DISPLAY_REGEX) :
	   prog->precomp;
	 int   len0 = UTF ? SvCUR(dsv0) : prog->prelen;
	 char *s1   = do_utf8 ? sv_uni_display(dsv1, sv, 60,
					       UNI_DISPLAY_REGEX) : startpos;
	 int   len1 = do_utf8 ? SvCUR(dsv1) : strend - startpos;
	 if (!PL_colorset)
	     reginitcolors();
	 PerlIO_printf(Perl_debug_log,
		       "%sMatching REx%s `%s%*.*s%s%s' against `%s%.*s%s%s'\n",
		       PL_colors[4],PL_colors[5],PL_colors[0],
		       len0, len0, s0,
		       PL_colors[1],
		       len0 > 60 ? "..." : "",
		       PL_colors[0],
		       (int)(len1 > 60 ? 60 : len1),
		       s1, PL_colors[1],
		       (len1 > 60 ? "..." : "")
	      );
    });
d1476 1
a1476 1
	    end = HOP3c(strend, -dontbother, strbeg) - 1;
d1478 1
a1478 1
	    if (prog->check_substr || prog->check_utf8) {
d1514 1
a1514 1
    if ((prog->anchored_substr || prog->anchored_utf8) && prog->reganch & ROPT_SKIP) {
d1517 1
a1517 1
	char ch;
a1520 3
	if (!(do_utf8 ? prog->anchored_utf8 : prog->anchored_substr))
	    do_utf8 ? to_utf8_substr(prog) : to_byte_substr(prog);
	ch = SvPVX(do_utf8 ? prog->anchored_utf8 : prog->anchored_substr)[0];
d1522 1
a1522 1
	if (do_utf8) {
d1546 1
a1546 1
	DEBUG_r(if (!did_match)
d1548 1
a1548 2
                                  "Did not find anchored character...\n")
               );
d1552 11
a1562 7
	      || prog->anchored_utf8 != Nullsv
	      || ((prog->float_substr != Nullsv || prog->float_utf8 != Nullsv)
		  && prog->float_max_offset < strend - s)) {
	SV *must;
	I32 back_max;
	I32 back_min;
	char *last;
a1566 19
	if (prog->anchored_substr || prog->anchored_utf8) {
	    if (!(do_utf8 ? prog->anchored_utf8 : prog->anchored_substr))
		do_utf8 ? to_utf8_substr(prog) : to_byte_substr(prog);
	    must = do_utf8 ? prog->anchored_utf8 : prog->anchored_substr;
	    back_max = back_min = prog->anchored_offset;
	} else {
	    if (!(do_utf8 ? prog->float_utf8 : prog->float_substr))
		do_utf8 ? to_utf8_substr(prog) : to_byte_substr(prog);
	    must = do_utf8 ? prog->float_utf8 : prog->float_substr;
	    back_max = prog->float_max_offset;
	    back_min = prog->float_min_offset;
	}
	if (must == &PL_sv_undef)
	    /* could not downgrade utf8 check substring, so must fail */
	    goto phooey;

	last = HOP3c(strend,	/* Cannot start after this */
			  -(I32)(CHR_SVLEN(must)
				 - (SvTAIL(must) != 0) + back_min), strbeg);
d1579 2
a1580 2
		((flags & REXEC_SCREAM)
		 ? (s = screaminstr(sv, must, HOP3c(s, back_min, strend) - strbeg,
d1582 2
a1583 2
		 : (s = fbm_instr((unsigned char*)HOP3(s, back_min, strend),
				  (unsigned char*)strend, must,
d1596 1
a1596 1
	    if (do_utf8) {
d1611 3
a1613 4
	DEBUG_r(if (!did_match)
                    PerlIO_printf(Perl_debug_log, 
                                  "Did not find %s substr `%s%.*s%s'%s...\n",
			      ((must == prog->anchored_substr || must == prog->anchored_utf8)
d1618 1
a1618 2
                                  PL_colors[1], (SvTAIL(must) ? "$" : ""))
               );
a1624 21
	DEBUG_r({
	    SV *prop = sv_newmortal();
	    char *s0;
	    char *s1;
	    int len0;
	    int len1;

	    regprop(prop, c);
	    s0 = UTF ?
	      pv_uni_display(dsv0, (U8*)SvPVX(prop), SvCUR(prop), 60,
			     UNI_DISPLAY_REGEX) :
	      SvPVX(prop);
	    len0 = UTF ? SvCUR(dsv0) : SvCUR(prop);
	    s1 = UTF ?
	      sv_uni_display(dsv1, sv, 60, UNI_DISPLAY_REGEX) : s;
	    len1 = UTF ? SvCUR(dsv1) : strend - s;
	    PerlIO_printf(Perl_debug_log,
			  "Matching stclass `%*.*s' against `%*.*s'\n",
			  len0, len0, s0,
			  len1, len1, s1);
	});
d1631 1
a1631 2
	if (prog->float_substr != Nullsv || prog->float_utf8 != Nullsv) {
	    /* Trim the end. */
a1632 5
	    SV* float_real;

	    if (!(do_utf8 ? prog->float_utf8 : prog->float_substr))
		do_utf8 ? to_utf8_substr(prog) : to_byte_substr(prog);
	    float_real = do_utf8 ? prog->float_utf8 : prog->float_substr;
d1635 1
a1635 1
		last = screaminstr(sv, float_real, s - strbeg,
d1638 1
a1638 1
		    last = scream_olds; /* Only one occurrence. */
d1642 1
a1642 1
		char *little = SvPV(float_real, len);
d1644 1
a1644 1
		if (SvTAIL(float_real)) {
d1648 1
a1648 1
			last = memEQ(strend - len, little, len)
d1654 1
a1654 1
		    if (len)
d1672 1
a1672 1
	if (do_utf8) {
d1701 1
a1701 1
	restore_pos(aTHX_ 0);
d1723 1
a1723 1

d1730 1
a1730 1
	restore_pos(aTHX_ 0);
d1767 1
a1767 1
		/* SAVE_DEFSV does *not* suffice here for USE_5005THREADS */
d1772 2
a1773 2
	    if (!(SvTYPE(PL_reg_sv) >= SVt_PVMG && SvMAGIC(PL_reg_sv)
		  && (mg = mg_find(PL_reg_sv, PERL_MAGIC_regex_global)))) {
d1775 2
a1776 3
		sv_magic(PL_reg_sv, (SV*)0,
			PERL_MAGIC_regex_global, Nullch, 0);
		mg = mg_find(PL_reg_sv, PERL_MAGIC_regex_global);
d1783 1
a1783 1
        if (!PL_reg_curpm) {
d1785 1
a1785 12
#ifdef USE_ITHREADS
            {
                SV* repointer = newSViv(0);
                /* so we know which PL_regex_padav element is PL_reg_curpm */
                SvFLAGS(repointer) |= SVf_BREAK;
                av_push(PL_regex_padav,repointer);
                PL_reg_curpm->op_pmoffset = av_len(PL_regex_padav);
                PL_regex_pad = AvARRAY(PL_regex_padav);
            }
#endif      
        }
	PM_SETRE(PL_reg_curpm, prog);
a1805 1
    PL_reglastcloseparen = &prog->lastcloseparen;
d1835 1
a1835 1
	for (i = prog->nparens; i > (I32)*PL_reglastparen; i--) {
a1879 11
#define sayYES goto yes
#define sayNO goto no
#define sayNO_ANYOF goto no_anyof
#define sayYES_FINAL goto yes_final
#define sayYES_LOUD  goto yes_loud
#define sayNO_FINAL  goto no_final
#define sayNO_SILENT goto do_no
#define saySAME(x) if (x) goto yes; else goto no

#define REPORT_CODE_OFF 24

d1903 2
a1904 2
    register I32 ln = 0;	/* len or last */
    register char *s = Nullch;	/* operand or save */
d1906 1
a1906 1
    register I32 c1 = 0, c2 = 0, paren;	/* case fold search, parenth */
a1908 1
#if 0
a1909 7
#endif
    register bool do_utf8 = PL_reg_match_utf8;
#ifdef DEBUGGING
    SV *dsv0 = PERL_DEBUG_PAD_ZERO(0);
    SV *dsv1 = PERL_DEBUG_PAD_ZERO(1);
    SV *dsv2 = PERL_DEBUG_PAD_ZERO(2);
#endif
d1919 20
a1938 2

        DEBUG_r( {
d1942 1
a1942 1
	    int l = (PL_regeol - locinput) > taill ? taill : (PL_regeol - locinput);
d1949 4
a1952 7
	    int pref_len = (locinput - PL_bostr) > (5 + taill) - l
		? (5 + taill) - l : locinput - PL_bostr;
	    int pref0_len;

	    while (do_utf8 && UTF8_IS_CONTINUATION(*(U8*)(locinput - pref_len)))
		pref_len++;
	    pref0_len = pref_len  - (locinput - PL_reg_starttry);
d1954 1
a1954 1
		l = ( PL_regeol - locinput > (5 + taill) - pref_len
a1955 2
	    while (do_utf8 && UTF8_IS_CONTINUATION(*(U8*)(locinput + l)))
		l--;
d1961 14
a1974 36
	    {
	      char *s0 =
		do_utf8 ?
		pv_uni_display(dsv0, (U8*)(locinput - pref_len),
			       pref0_len, 60, UNI_DISPLAY_REGEX) :
		locinput - pref_len;
	      int len0 = do_utf8 ? strlen(s0) : pref0_len;
	      char *s1 = do_utf8 ?
		pv_uni_display(dsv1, (U8*)(locinput - pref_len + pref0_len),
			       pref_len - pref0_len, 60, UNI_DISPLAY_REGEX) :
		locinput - pref_len + pref0_len;
	      int len1 = do_utf8 ? strlen(s1) : pref_len - pref0_len;
	      char *s2 = do_utf8 ?
		pv_uni_display(dsv2, (U8*)locinput,
			       PL_regeol - locinput, 60, UNI_DISPLAY_REGEX) :
		locinput;
	      int len2 = do_utf8 ? strlen(s2) : l;
	      PerlIO_printf(Perl_debug_log,
			    "%4"IVdf" <%s%.*s%s%s%.*s%s%s%s%.*s%s>%*s|%3"IVdf":%*s%s\n",
			    (IV)(locinput - PL_bostr),
			    PL_colors[4],
			    len0, s0,
			    PL_colors[5],
			    PL_colors[2],
			    len1, s1,
			    PL_colors[3],
			    (docolor ? "" : "> <"),
			    PL_colors[0],
			    len2, s2,
			    PL_colors[1],
			    15 - l - pref_len + 1,
			    "",
			    (IV)(scan - PL_regprogram), PL_regindent*2, "",
			    SvPVX(prop));
	    }
	});
d1982 4
a1985 2
	    if (locinput == PL_bostr || (PL_multiline &&
		(nextchr || locinput < PL_regeol) && locinput[-1] == '\n') )
d1992 3
a1994 2
	    if (locinput == PL_bostr ||
		((nextchr || locinput < PL_regeol) && locinput[-1] == '\n'))
d2028 8
a2035 1
	case SANY:
d2038 1
a2038 8
 	    if (do_utf8) {
	        locinput += PL_utf8skip[nextchr];
		if (locinput > PL_regeol)
 		    sayNO;
 		nextchr = UCHARAT(locinput);
 	    }
 	    else
 		nextchr = UCHARAT(++locinput);
d2040 1
a2040 1
	case CANY:
d2045 2
a2046 4
	case REG_ANY:
	    if ((!nextchr && locinput >= PL_regeol) || nextchr == '\n')
		sayNO;
	    if (do_utf8) {
d2051 1
d2053 8
a2060 2
	    else
		nextchr = UCHARAT(++locinput);
a2064 39
	    if (do_utf8 != UTF) {
		/* The target and the pattern have differing utf8ness. */
		char *l = locinput;
		char *e = s + ln;
		STRLEN ulen;

		if (do_utf8) {
		    /* The target is utf8, the pattern is not utf8. */
		    while (s < e) {
			if (l >= PL_regeol)
			     sayNO;
			if (NATIVE_TO_UNI(*(U8*)s) !=
			    utf8n_to_uvuni((U8*)l, UTF8_MAXLEN, &ulen,
					   ckWARN(WARN_UTF8) ?
					   0 : UTF8_ALLOW_ANY))
			     sayNO;
			l += ulen;
			s ++;
		    }
		}
		else {
		    /* The target is not utf8, the pattern is utf8. */
		    while (s < e) {
			if (l >= PL_regeol)
			    sayNO;
			if (NATIVE_TO_UNI(*((U8*)l)) !=
			    utf8n_to_uvuni((U8*)s, UTF8_MAXLEN, &ulen,
					   ckWARN(WARN_UTF8) ?
					   0 : UTF8_ALLOW_ANY))
			    sayNO;
			s += ulen;
			l ++;
		    }
		}
		locinput = l;
		nextchr = UCHARAT(locinput);
		break;
	    }
	    /* The target and the pattern have the same utf8ness. */
d2082 1
a2082 2
	    if (do_utf8 || UTF) {
	      /* Either target or the pattern are utf8. */
d2084 14
a2097 16
		char *e = PL_regeol;

		if (ibcmp_utf8(s, 0,  ln, (bool)UTF,
			       l, &e, 0,  do_utf8)) {
		     /* One more case for the sharp s:
		      * pack("U0U*", 0xDF) =~ /ss/i,
		      * the 0xC3 0x9F are the UTF-8
		      * byte sequence for the U+00DF. */
		     if (!(do_utf8 &&
			   toLOWER(s[0]) == 's' &&
			   ln >= 2 &&
			   toLOWER(s[1]) == 's' &&
			   (U8)l[0] == 0xC3 &&
			   e - l >= 2 &&
			   (U8)l[1] == 0x9F))
			  sayNO;
d2099 1
a2099 1
		locinput = e;
a2103 2
	    /* Neither the target and the pattern are utf8. */

d2118 8
d2127 1
a2127 8
	    if (do_utf8) {
	        STRLEN inclasslen = PL_regeol - locinput;

	        if (!reginclass(scan, (U8*)locinput, &inclasslen, do_utf8))
		    sayNO_ANYOF;
		if (locinput >= PL_regeol)
		    sayNO;
		locinput += inclasslen ? inclasslen : UTF8SKIP(locinput);
d2129 5
a2133 22
		break;
	    }
	    else {
		if (nextchr < 0)
		    nextchr = UCHARAT(locinput);
		if (!REGINCLASS(scan, (U8*)locinput))
		    sayNO_ANYOF;
		if (!nextchr && locinput >= PL_regeol)
		    sayNO;
		nextchr = UCHARAT(++locinput);
		break;
	    }
	no_anyof:
	    /* If we might have the case of the German sharp s
	     * in a casefolding Unicode character class. */

	    if (ANYOF_FOLD_SHARP_S(scan, locinput, PL_regeol)) {
		 locinput += SHARP_S_SKIP;
		 nextchr = UCHARAT(locinput);
	    }
	    else
		 sayNO;
d2141 14
a2154 4
	    if (do_utf8) {
		LOAD_UTF8_CHARCLASS(alnum,"a");
		if (!(OP(scan) == ALNUM
		      ? swash_fetch(PL_utf8_alnum, (U8*)locinput, do_utf8)
d2163 1
a2163 1
	    if (!(OP(scan) == ALNUM
d2174 14
a2187 4
	    if (do_utf8) {
		LOAD_UTF8_CHARCLASS(alnum,"a");
		if (OP(scan) == NALNUM
		    ? swash_fetch(PL_utf8_alnum, (U8*)locinput, do_utf8)
d2196 1
a2196 1
	    if (OP(scan) == NALNUM
d2208 29
a2236 17
	    if (do_utf8) {
		if (locinput == PL_bostr)
		    ln = '\n';
		else {
		    U8 *r = reghop3((U8*)locinput, -1, (U8*)PL_bostr);
		
		    ln = utf8n_to_uvchr(r, UTF8SKIP(r), 0, 0);
		}
		if (OP(scan) == BOUND || OP(scan) == NBOUND) {
		    ln = isALNUM_uni(ln);
		    LOAD_UTF8_CHARCLASS(alnum,"a");
		    n = swash_fetch(PL_utf8_alnum, (U8*)locinput, do_utf8);
		}
		else {
		    ln = isALNUM_LC_uvchr(UNI_TO_NATIVE(ln));
		    n = isALNUM_LC_utf8((U8*)locinput);
		}
d2239 2
a2240 10
		ln = (locinput != PL_bostr) ?
		    UCHARAT(locinput - 1) : '\n';
		if (OP(scan) == BOUND || OP(scan) == NBOUND) {
		    ln = isALNUM(ln);
		    n = isALNUM(nextchr);
		}
		else {
		    ln = isALNUM_LC(ln);
		    n = isALNUM_LC(nextchr);
		}
d2242 2
a2243 3
	    if (((!ln) == (!n)) == (OP(scan) == BOUND ||
				    OP(scan) == BOUNDL))
		    sayNO;
d2251 17
a2267 12
	    if (do_utf8) {
		if (UTF8_IS_CONTINUED(nextchr)) {
		    LOAD_UTF8_CHARCLASS(space," ");
		    if (!(OP(scan) == SPACE
			  ? swash_fetch(PL_utf8_space, (U8*)locinput, do_utf8)
			  : isSPACE_LC_utf8((U8*)locinput)))
		    {
			sayNO;
		    }
		    locinput += PL_utf8skip[nextchr];
		    nextchr = UCHARAT(locinput);
		    break;
d2269 3
a2271 10
		if (!(OP(scan) == SPACE
		      ? isSPACE(nextchr) : isSPACE_LC(nextchr)))
		    sayNO;
		nextchr = UCHARAT(++locinput);
	    }
	    else {
		if (!(OP(scan) == SPACE
		      ? isSPACE(nextchr) : isSPACE_LC(nextchr)))
		    sayNO;
		nextchr = UCHARAT(++locinput);
d2273 4
d2284 14
a2297 4
	    if (do_utf8) {
		LOAD_UTF8_CHARCLASS(space," ");
		if (OP(scan) == NSPACE
		    ? swash_fetch(PL_utf8_space, (U8*)locinput, do_utf8)
d2306 1
a2306 1
	    if (OP(scan) == NSPACE
d2317 14
a2330 4
	    if (do_utf8) {
		LOAD_UTF8_CHARCLASS(digit,"0");
		if (!(OP(scan) == DIGIT
		      ? swash_fetch(PL_utf8_digit, (U8*)locinput, do_utf8)
d2339 1
a2339 1
	    if (!(OP(scan) == DIGIT
d2350 14
a2363 4
	    if (do_utf8) {
		LOAD_UTF8_CHARCLASS(digit,"0");
		if (OP(scan) == NDIGIT
		    ? swash_fetch(PL_utf8_digit, (U8*)locinput, do_utf8)
d2372 1
a2372 1
	    if (OP(scan) == NDIGIT
d2378 6
a2383 1
	    if (locinput >= PL_regeol)
a2384 13
	    if  (do_utf8) {
		LOAD_UTF8_CHARCLASS(mark,"~");
		if (swash_fetch(PL_utf8_mark,(U8*)locinput, do_utf8))
		    sayNO;
		locinput += PL_utf8skip[nextchr];
		while (locinput < PL_regeol &&
		       swash_fetch(PL_utf8_mark,(U8*)locinput, do_utf8))
		    locinput += UTF8SKIP(locinput);
		if (locinput > PL_regeol)
		    sayNO;
	    } 
	    else
	       locinput++;
d2395 1
a2395 1
	    if ((I32)*PL_reglastparen < n || ln == -1)
d2401 1
a2401 1
	    if (do_utf8 && OP(scan) != REF) {	/* REF can do byte comparison */
a2409 3
		    STRLEN ulen1, ulen2;
		    U8 tmpbuf1[UTF8_MAXLEN_UCLC+1];
		    U8 tmpbuf2[UTF8_MAXLEN_UCLC+1];
d2413 1
a2413 3
			toLOWER_utf8((U8*)s, tmpbuf1, &ulen1);
			toLOWER_utf8((U8*)l, tmpbuf2, &ulen2);
			if (ulen1 != ulen2 || memNE((char *)tmpbuf1, (char *)tmpbuf2, ulen1))
d2415 12
a2426 2
			s += ulen1;
			l += ulen2;
d2465 1
a2465 1
	
d2472 5
a2476 12
	    {
		SV **before = SP;
		CALLRUNOPS(aTHX);			/* Scalar context. */
		SPAGAIN;
		if (SP == before)
		    ret = &PL_sv_undef;   /* protect against empty (?{}) blocks. */
		else {
		    ret = POPs;
		    PUTBACK;
		}
	    }

d2491 1
a2491 1
			    mg = mg_find(sv, PERL_MAGIC_qr);
d2505 2
a2506 1
			Zero(&pm, 1, PMOP);
d2508 1
a2508 1
			if (!(SvFLAGS(ret)
d2510 1
a2510 2
			    sv_magic(ret,(SV*)ReREFCNT_inc(re),
					PERL_MAGIC_qr,0,0);
d2516 1
a2516 1
			PerlIO_printf(Perl_debug_log,
d2529 1
a2529 1
		
a2534 1
		    *PL_reglastcloseparen = 0;
a2570 1
		    logical = 0;
d2590 1
a2590 1
	    if (n > (I32)*PL_reglastparen)
a2591 1
	    *PL_reglastcloseparen = n;
d2595 1
a2595 1
	    sw = ((I32)*PL_reglastparen >= n && PL_regendp[n] != -1);
d2618 1
a2618 1
   2) This regnode creates infoblock on the stack, and calls
d2639 1
a2639 1
 In the following picture infoblocks for outer loop of
d2697 1
a2697 1
		if (parenfloor > (I32)*PL_reglastparen)
d2732 2
a2733 2
		    PerlIO_printf(Perl_debug_log,
				  "%*s  %ld out of %ld..%ld  cc=%"UVxf"\n",
d2735 2
a2736 2
				  (long)n, (long)cc->min,
				  (long)cc->max, PTR2UV(cc))
d2781 1
a2781 1
			if ((I32)PL_reg_poscache_size < size) {
d2834 1
a2834 1
			if (ckWARN(WARN_REGEXP) && n >= REG_INFTY
d2837 1
a2837 1
			    Perl_warner(aTHX_ packWARN(WARN_REGEXP), "%s limit (%d) exceeded",
d2886 1
a2886 1
		if (ckWARN(WARN_REGEXP) && n >= REG_INFTY
d2889 1
a2889 1
		    Perl_warner(aTHX_ packWARN(WARN_REGEXP), "%s limit (%d) exceeded",
d2908 1
a2908 1
	case BRANCHJ:
d2914 1
a2914 1
	case BRANCH:
d2918 1
d2957 1
a2957 1
	
d2967 1
a2967 1
		if (paren > (I32)*PL_reglastparen)
d2978 6
a2983 9
		/* if we matched something zero-length we don't need to
		   backtrack - capturing parens are already defined, so
		   the caveat in the maximal case doesn't apply

		   XXXX if ln == 0, we can redo this check first time
		   through the following loop
		*/
		if (ln && l == 0)
		    n = ln;	/* don't backtrack */
d2985 8
a2992 30
		if (HAS_TEXT(next) || JUMPABLE(next)) {
		    regnode *text_node = next;

		    if (! HAS_TEXT(text_node)) FIND_NEXT_IMPT(text_node);

		    if (! HAS_TEXT(text_node)) c1 = c2 = -1000;
		    else {
			if (PL_regkind[(U8)OP(text_node)] == REF) {
			    I32 n, ln;
			    n = ARG(text_node);  /* which paren pair */
			    ln = PL_regstartp[n];
			    /* assume yes if we haven't seen CLOSEn */
			    if (
				(I32)*PL_reglastparen < n ||
				ln == -1 ||
				ln == PL_regendp[n]
			    ) {
				c1 = c2 = -1000;
				goto assume_ok_MM;
			    }
			    c1 = *(PL_bostr + ln);
			}
			else { c1 = (U8)*STRING(text_node); }
			if (OP(text_node) == EXACTF || OP(text_node) == REFF)
			    c2 = PL_fold[c1];
			else if (OP(text_node) == EXACTFL || OP(text_node) == REFFL)
			    c2 = PL_fold_locale[c1];
			else
			    c2 = c1;
		    }
a2995 1
	    assume_ok_MM:
d3005 1
a3005 1
			    if (ln) {
d3029 6
a3034 7
		/* if we matched something zero-length we don't need to
		   backtrack, unless the minimum count is zero and we
		   are capturing the result - in that case the capture
		   being defined or not may affect later execution
		*/
		if (n != 0 && l == 0 && !(paren && ln == 0))
		    ln = n;	/* don't backtrack */
d3043 8
a3050 31
		    if (HAS_TEXT(next) || JUMPABLE(next)) {
			regnode *text_node = next;

			if (! HAS_TEXT(text_node)) FIND_NEXT_IMPT(text_node);

			if (! HAS_TEXT(text_node)) c1 = c2 = -1000;
			else {
			    if (PL_regkind[(U8)OP(text_node)] == REF) {
				I32 n, ln;
				n = ARG(text_node);  /* which paren pair */
				ln = PL_regstartp[n];
				/* assume yes if we haven't seen CLOSEn */
				if (
				    (I32)*PL_reglastparen < n ||
				    ln == -1 ||
				    ln == PL_regendp[n]
				) {
				    c1 = c2 = -1000;
				    goto assume_ok_REG;
				}
				c1 = *(PL_bostr + ln);
			    }
			    else { c1 = (U8)*STRING(text_node); }

			    if (OP(text_node) == EXACTF || OP(text_node) == REFF)
				c2 = PL_fold[c1];
			    else if (OP(text_node) == EXACTFL || OP(text_node) == REFFL)
				c2 = PL_fold_locale[c1];
			    else
				c2 = c1;
			}
a3054 1
	    assume_ok_REG:
d3092 1
a3092 1
	    if (paren > (I32)*PL_reglastparen)
d3120 8
a3127 62

	    /*
	    * Used to only do .*x and .*?x, but now it allows
	    * for )'s, ('s and (?{ ... })'s to be in the way
	    * of the quantifier and the EXACT-like node.  -- japhy
	    */

	    if (HAS_TEXT(next) || JUMPABLE(next)) {
		U8 *s;
		regnode *text_node = next;

		if (! HAS_TEXT(text_node)) FIND_NEXT_IMPT(text_node);

		if (! HAS_TEXT(text_node)) c1 = c2 = -1000;
		else {
		    if (PL_regkind[(U8)OP(text_node)] == REF) {
			I32 n, ln;
			n = ARG(text_node);  /* which paren pair */
			ln = PL_regstartp[n];
			/* assume yes if we haven't seen CLOSEn */
			if (
			    (I32)*PL_reglastparen < n ||
			    ln == -1 ||
			    ln == PL_regendp[n]
			) {
			    c1 = c2 = -1000;
			    goto assume_ok_easy;
			}
			s = (U8*)PL_bostr + ln;
		    }
		    else { s = (U8*)STRING(text_node); }

		    if (!UTF) {
			c2 = c1 = *s;
			if (OP(text_node) == EXACTF || OP(text_node) == REFF)
			    c2 = PL_fold[c1];
			else if (OP(text_node) == EXACTFL || OP(text_node) == REFFL)
			    c2 = PL_fold_locale[c1];
		    }
		    else { /* UTF */
			if (OP(text_node) == EXACTF || OP(text_node) == REFF) {
			     STRLEN ulen1, ulen2;
			     U8 tmpbuf1[UTF8_MAXLEN_UCLC+1];
			     U8 tmpbuf2[UTF8_MAXLEN_UCLC+1];

			     to_utf8_lower((U8*)s, tmpbuf1, &ulen1);
			     to_utf8_upper((U8*)s, tmpbuf2, &ulen2);

			     c1 = utf8n_to_uvuni(tmpbuf1, UTF8_MAXLEN, 0,
						 ckWARN(WARN_UTF8) ?
						 0 : UTF8_ALLOW_ANY);
			     c2 = utf8n_to_uvuni(tmpbuf2, UTF8_MAXLEN, 0,
						 ckWARN(WARN_UTF8) ?
						 0 : UTF8_ALLOW_ANY);
			}
			else {
			    c2 = c1 = utf8n_to_uvchr(s, UTF8_MAXLEN, 0,
						     ckWARN(WARN_UTF8) ?
						     0 : UTF8_ALLOW_ANY);
			}
		    }
		}
a3130 1
	assume_ok_easy:
d3140 1
a3140 1
		    char *e; /* Should not check after this */
a3141 1
		    int count = 0;
d3143 1
a3143 1
		    if  (n == REG_INFTY) {
a3144 15
			if (do_utf8)
			    while (UTF8_IS_CONTINUATION(*(U8*)e))
				e--;
		    }
		    else if (do_utf8) {
			int m = n - ln;
			for (e = locinput;
			     m >0 && e + UTF8SKIP(e) <= PL_regeol; m--)
			    e += UTF8SKIP(e);
		    }
		    else {
			e = locinput + n - ln;
			if (e >= PL_regeol)
			    e = PL_regeol - 1;
		    }
d3147 8
a3154 40
			if (!do_utf8) {
			    if (c1 == c2) {
				while (locinput <= e &&
				       UCHARAT(locinput) != c1)
				    locinput++;
			    } else {
				while (locinput <= e
				       && UCHARAT(locinput) != c1
				       && UCHARAT(locinput) != c2)
				    locinput++;
			    }
			    count = locinput - old;
			}
			else {
			    STRLEN len;
			    if (c1 == c2) {
				/* count initialised to
				 * utf8_distance(old, locinput) */
				while (locinput <= e &&
				       utf8n_to_uvchr((U8*)locinput,
						      UTF8_MAXLEN, &len,
						      ckWARN(WARN_UTF8) ?
						      0 : UTF8_ALLOW_ANY) != (UV)c1) {
				    locinput += len;
				    count++;
				}
			    } else {
				/* count initialised to
				 * utf8_distance(old, locinput) */
				while (locinput <= e) {
				    UV c = utf8n_to_uvchr((U8*)locinput,
							  UTF8_MAXLEN, &len,
							  ckWARN(WARN_UTF8) ?
							  0 : UTF8_ALLOW_ANY);
				    if (c == (UV)c1 || c == (UV)c2)
					break;
				    locinput += len;
				    count++;
				}
			    }
d3156 1
a3156 1
			if (locinput > e)
d3161 2
a3162 1
			    if (regrepeat(scan, count) < count)
d3170 1
a3170 6
			old = locinput;
			if (do_utf8)
			    locinput += UTF8SKIP(locinput);
			else
			    locinput++;
			count = 1;
a3174 16
		    UV c;
		    if (c1 != -1000) {
			if (do_utf8)
			    c = utf8n_to_uvchr((U8*)PL_reginput,
					       UTF8_MAXLEN, 0,
					       ckWARN(WARN_UTF8) ?
					       0 : UTF8_ALLOW_ANY);
			else
			    c = UCHARAT(PL_reginput);
			/* If it could work, try it. */
		        if (c == (UV)c1 || c == (UV)c2)
		        {
			    TRYPAREN(paren, n, PL_reginput);
			    REGCP_UNWIND(lastcp);
		        }
		    }
d3176 3
a3178 1
		    else if (c1 == -1000)
d3198 1
a3198 3
		    ((!PL_multiline && OP(next) != MEOL) ||
			OP(next) == SEOL || OP(next) == EOS))
		{
a3207 1
		    UV c = 0;
a3208 9
			if (c1 != -1000) {
			    if (do_utf8)
				c = utf8n_to_uvchr((U8*)PL_reginput,
						   UTF8_MAXLEN, 0,
						   ckWARN(WARN_UTF8) ?
						   0 : UTF8_ALLOW_ANY);
			    else
				c = UCHARAT(PL_reginput);
			}
d3210 3
a3212 1
			if (c1 == -1000 || c == (UV)c1 || c == (UV)c2)
a3222 1
		    UV c = 0;
a3223 9
			if (c1 != -1000) {
			    if (do_utf8)
				c = utf8n_to_uvchr((U8*)PL_reginput,
						   UTF8_MAXLEN, 0,
						   ckWARN(WARN_UTF8) ?
						   0 : UTF8_ALLOW_ANY);
			    else
				c = UCHARAT(PL_reginput);
			}
d3225 3
a3227 1
			if (c1 == -1000 || c == (UV)c1 || c == (UV)c2)
d3292 1
a3292 1
	    goto do_ifmatch;	
d3296 14
a3309 4
		s = HOPBACKc(locinput, scan->flags);
		if (!s)
		    goto say_yes;
		PL_reginput = s;
d3317 14
a3330 4
		s = HOPBACKc(locinput, scan->flags);
		if (!s)
		    goto say_no;
		PL_reginput = s;
d3419 1
a3419 1
	
d3425 2
a3426 2
	    if ( !scan ||
		 OP(scan) != (uwb->type == RE_UNWIND_BRANCH
a3479 1
    register bool do_utf8 = PL_reg_match_utf8;
d3482 1
a3482 3
    if (max == REG_INFTY)
	max = I32_MAX;
    else if (max < loceol - scan)
d3486 2
a3487 10
	if (do_utf8) {
	    loceol = PL_regeol;
	    while (scan < loceol && hardcount < max && *scan != '\n') {
		scan += UTF8SKIP(scan);
		hardcount++;
	    }
	} else {
	    while (scan < loceol && *scan != '\n')
		scan++;
	}
d3490 7
a3496 6
        if (do_utf8) {
	    loceol = PL_regeol;
	    while (scan < loceol && hardcount < max) {
	        scan += UTF8SKIP(scan);
		hardcount++;
	    }
a3497 2
	else
	    scan = loceol;
d3499 6
a3504 2
    case CANY:
	scan = loceol;
d3524 7
d3532 2
a3533 11
	if (do_utf8) {
	    loceol = PL_regeol;
	    while (hardcount < max && scan < loceol &&
		   reginclass(p, (U8*)scan, 0, do_utf8)) {
		scan += UTF8SKIP(scan);
		hardcount++;
	    }
	} else {
	    while (scan < loceol && REGINCLASS(p, (U8*)scan))
		scan++;
	}
d3536 8
a3543 11
	if (do_utf8) {
	    loceol = PL_regeol;
	    LOAD_UTF8_CHARCLASS(alnum,"a");
	    while (hardcount < max && scan < loceol &&
		   swash_fetch(PL_utf8_alnum, (U8*)scan, do_utf8)) {
		scan += UTF8SKIP(scan);
		hardcount++;
	    }
	} else {
	    while (scan < loceol && isALNUM(*scan))
		scan++;
d3548 9
a3556 10
	if (do_utf8) {
	    loceol = PL_regeol;
	    while (hardcount < max && scan < loceol &&
		   isALNUM_LC_utf8((U8*)scan)) {
		scan += UTF8SKIP(scan);
		hardcount++;
	    }
	} else {
	    while (scan < loceol && isALNUM_LC(*scan))
		scan++;
d3559 1
d3561 8
a3568 11
	if (do_utf8) {
	    loceol = PL_regeol;
	    LOAD_UTF8_CHARCLASS(alnum,"a");
	    while (hardcount < max && scan < loceol &&
		   !swash_fetch(PL_utf8_alnum, (U8*)scan, do_utf8)) {
		scan += UTF8SKIP(scan);
		hardcount++;
	    }
	} else {
	    while (scan < loceol && !isALNUM(*scan))
		scan++;
d3573 9
a3581 10
	if (do_utf8) {
	    loceol = PL_regeol;
	    while (hardcount < max && scan < loceol &&
		   !isALNUM_LC_utf8((U8*)scan)) {
		scan += UTF8SKIP(scan);
		hardcount++;
	    }
	} else {
	    while (scan < loceol && !isALNUM_LC(*scan))
		scan++;
d3585 8
a3592 12
	if (do_utf8) {
	    loceol = PL_regeol;
	    LOAD_UTF8_CHARCLASS(space," ");
	    while (hardcount < max && scan < loceol &&
		   (*scan == ' ' ||
		    swash_fetch(PL_utf8_space,(U8*)scan, do_utf8))) {
		scan += UTF8SKIP(scan);
		hardcount++;
	    }
	} else {
	    while (scan < loceol && isSPACE(*scan))
		scan++;
d3597 9
a3605 10
	if (do_utf8) {
	    loceol = PL_regeol;
	    while (hardcount < max && scan < loceol &&
		   (*scan == ' ' || isSPACE_LC_utf8((U8*)scan))) {
		scan += UTF8SKIP(scan);
		hardcount++;
	    }
	} else {
	    while (scan < loceol && isSPACE_LC(*scan))
		scan++;
d3609 8
a3616 13
	if (do_utf8) {
	    loceol = PL_regeol;
	    LOAD_UTF8_CHARCLASS(space," ");
	    while (hardcount < max && scan < loceol &&
		   !(*scan == ' ' ||
		     swash_fetch(PL_utf8_space,(U8*)scan, do_utf8))) {
		scan += UTF8SKIP(scan);
		hardcount++;
	    }
	} else {
	    while (scan < loceol && !isSPACE(*scan))
		scan++;
	    break;
d3618 1
d3621 9
a3629 10
	if (do_utf8) {
	    loceol = PL_regeol;
	    while (hardcount < max && scan < loceol &&
		   !(*scan == ' ' || isSPACE_LC_utf8((U8*)scan))) {
		scan += UTF8SKIP(scan);
		hardcount++;
	    }
	} else {
	    while (scan < loceol && !isSPACE_LC(*scan))
		scan++;
d3633 8
a3640 11
	if (do_utf8) {
	    loceol = PL_regeol;
	    LOAD_UTF8_CHARCLASS(digit,"0");
	    while (hardcount < max && scan < loceol &&
		   swash_fetch(PL_utf8_digit, (U8*)scan, do_utf8)) {
		scan += UTF8SKIP(scan);
		hardcount++;
	    }
	} else {
	    while (scan < loceol && isDIGIT(*scan))
		scan++;
d3643 1
d3645 8
a3652 11
	if (do_utf8) {
	    loceol = PL_regeol;
	    LOAD_UTF8_CHARCLASS(digit,"0");
	    while (hardcount < max && scan < loceol &&
		   !swash_fetch(PL_utf8_digit, (U8*)scan, do_utf8)) {
		scan += UTF8SKIP(scan);
		hardcount++;
	    }
	} else {
	    while (scan < loceol && !isDIGIT(*scan))
		scan++;
d3665 1
a3665 1
    DEBUG_r(
d3670 2
a3671 2
		PerlIO_printf(Perl_debug_log,
			      "%*s  %s can match %"IVdf" times out of %"IVdf"...\n",
d3674 1
a3674 1

d3680 1
a3680 1
 *
d3687 1
a3687 1
    register char *scan = Nullch;
d3697 1
a3697 1
    if (PL_reg_match_utf8) {
d3726 1
a3726 1

d3731 2
a3732 2
- regclass_swash - prepare the utf8 swash
*/
d3734 2
a3735 2
SV *
Perl_regclass_swash(pTHX_ register regnode* node, bool doinit, SV** listsvp, SV **altsvp)
d3737 17
a3753 15
    SV *sw  = NULL;
    SV *si  = NULL;
    SV *alt = NULL;

    if (PL_regdata && PL_regdata->count) {
	U32 n = ARG(node);

	if (PL_regdata->what[n] == 's') {
	    SV *rv = (SV*)PL_regdata->data[n];
	    AV *av = (AV*)SvRV((SV*)rv);
	    SV **ary = AvARRAY(av);
	    SV **a, **b;
	
	    /* See the end of regcomp.c:S_reglass() for
	     * documentation of these array elements. */
d3755 36
a3790 12
	    si = *ary;
	    a  = SvTYPE(ary[1]) == SVt_RV   ? &ary[1] : 0;
	    b  = SvTYPE(ary[2]) == SVt_PVAV ? &ary[2] : 0;

	    if (a)
		sw = *a;
	    else if (si && doinit) {
		sw = swash_init("utf8", "", si, 1, 0);
		(void)av_store(av, 1, sw);
	    }
	    if (b)
	        alt = *b;
a3792 5
	
    if (listsvp)
	*listsvp = si;
    if (altsvp)
	*altsvp  = alt;
d3794 1
a3794 1
    return sw;
a3796 10
/*
 - reginclass - determine if a character falls into a character class
 
  The n is the ANYOF regnode, the p is the target string, lenp
  is pointer to the maximum length of how far to go in the p
  (if the lenp is zero, UTF8SKIP(p) is used),
  do_utf8 tells whether the target string is in UTF-8.

 */

d3798 3
a3800 3
S_reginclass(pTHX_ register regnode *n, register U8* p, STRLEN* lenp, register bool do_utf8)
{
    char flags = ANYOF_FLAGS(n);
d3802 16
a3817 15
    UV c = *p;
    STRLEN len = 0;
    STRLEN plen;

    if (do_utf8 && !UTF8_IS_INVARIANT(c))
	 c = utf8n_to_uvchr(p, UTF8_MAXLEN, &len,
			    ckWARN(WARN_UTF8) ? 0 : UTF8_ALLOW_ANY);

    plen = lenp ? *lenp : UNISKIP(NATIVE_TO_UNI(c));
    if (do_utf8 || (flags & ANYOF_UNICODE)) {
        if (lenp)
	    *lenp = 0;
	if (do_utf8 && !ANYOF_RUNTIME(n)) {
	    if (len != (STRLEN)-1 && c < 256 && ANYOF_BITMAP_TEST(n, c))
		match = TRUE;
d3819 3
a3821 1
	if (!match && do_utf8 && (flags & ANYOF_UNICODE_ALL) && c >= 256)
a3822 36
	if (!match) {
	    AV *av;
	    SV *sw = regclass_swash(n, TRUE, 0, (SV**)&av);
	
	    if (sw) {
		if (swash_fetch(sw, p, do_utf8))
		    match = TRUE;
		else if (flags & ANYOF_FOLD) {
		    if (!match && lenp && av) {
		        I32 i;
		      
			for (i = 0; i <= av_len(av); i++) {
			    SV* sv = *av_fetch(av, i, FALSE);
			    STRLEN len;
			    char *s = SvPV(sv, len);
			
			    if (len <= plen && memEQ(s, (char*)p, len)) {
			        *lenp = len;
				match = TRUE;
				break;
			    }
			}
		    }
		    if (!match) {
		        U8 tmpbuf[UTF8_MAXLEN_FOLD+1];
			STRLEN tmplen;

		        to_utf8_fold(p, tmpbuf, &tmplen);
			if (swash_fetch(sw, tmpbuf, do_utf8))
			    match = TRUE;
		    }
		}
	    }
	}
	if (match && lenp && *lenp == 0)
	    *lenp = UNISKIP(NATIVE_TO_UNI(c));
a3823 5
    if (!match && c < 256) {
	if (ANYOF_BITMAP_TEST(n, c))
	    match = TRUE;
	else if (flags & ANYOF_FOLD) {
	    U8 f;
d3825 1
a3825 49
	    if (flags & ANYOF_LOCALE) {
		PL_reg_flags |= RF_tainted;
		f = PL_fold_locale[c];
	    }
	    else
		f = PL_fold[c];
	    if (f != c && ANYOF_BITMAP_TEST(n, f))
		match = TRUE;
	}
	
	if (!match && (flags & ANYOF_CLASS)) {
	    PL_reg_flags |= RF_tainted;
	    if (
		(ANYOF_CLASS_TEST(n, ANYOF_ALNUM)   &&  isALNUM_LC(c))  ||
		(ANYOF_CLASS_TEST(n, ANYOF_NALNUM)  && !isALNUM_LC(c))  ||
		(ANYOF_CLASS_TEST(n, ANYOF_SPACE)   &&  isSPACE_LC(c))  ||
		(ANYOF_CLASS_TEST(n, ANYOF_NSPACE)  && !isSPACE_LC(c))  ||
		(ANYOF_CLASS_TEST(n, ANYOF_DIGIT)   &&  isDIGIT_LC(c))  ||
		(ANYOF_CLASS_TEST(n, ANYOF_NDIGIT)  && !isDIGIT_LC(c))  ||
		(ANYOF_CLASS_TEST(n, ANYOF_ALNUMC)  &&  isALNUMC_LC(c)) ||
		(ANYOF_CLASS_TEST(n, ANYOF_NALNUMC) && !isALNUMC_LC(c)) ||
		(ANYOF_CLASS_TEST(n, ANYOF_ALPHA)   &&  isALPHA_LC(c))  ||
		(ANYOF_CLASS_TEST(n, ANYOF_NALPHA)  && !isALPHA_LC(c))  ||
		(ANYOF_CLASS_TEST(n, ANYOF_ASCII)   &&  isASCII(c))     ||
		(ANYOF_CLASS_TEST(n, ANYOF_NASCII)  && !isASCII(c))     ||
		(ANYOF_CLASS_TEST(n, ANYOF_CNTRL)   &&  isCNTRL_LC(c))  ||
		(ANYOF_CLASS_TEST(n, ANYOF_NCNTRL)  && !isCNTRL_LC(c))  ||
		(ANYOF_CLASS_TEST(n, ANYOF_GRAPH)   &&  isGRAPH_LC(c))  ||
		(ANYOF_CLASS_TEST(n, ANYOF_NGRAPH)  && !isGRAPH_LC(c))  ||
		(ANYOF_CLASS_TEST(n, ANYOF_LOWER)   &&  isLOWER_LC(c))  ||
		(ANYOF_CLASS_TEST(n, ANYOF_NLOWER)  && !isLOWER_LC(c))  ||
		(ANYOF_CLASS_TEST(n, ANYOF_PRINT)   &&  isPRINT_LC(c))  ||
		(ANYOF_CLASS_TEST(n, ANYOF_NPRINT)  && !isPRINT_LC(c))  ||
		(ANYOF_CLASS_TEST(n, ANYOF_PUNCT)   &&  isPUNCT_LC(c))  ||
		(ANYOF_CLASS_TEST(n, ANYOF_NPUNCT)  && !isPUNCT_LC(c))  ||
		(ANYOF_CLASS_TEST(n, ANYOF_UPPER)   &&  isUPPER_LC(c))  ||
		(ANYOF_CLASS_TEST(n, ANYOF_NUPPER)  && !isUPPER_LC(c))  ||
		(ANYOF_CLASS_TEST(n, ANYOF_XDIGIT)  &&  isXDIGIT(c))    ||
		(ANYOF_CLASS_TEST(n, ANYOF_NXDIGIT) && !isXDIGIT(c))    ||
		(ANYOF_CLASS_TEST(n, ANYOF_PSXSPC)  &&  isPSXSPC(c))    ||
		(ANYOF_CLASS_TEST(n, ANYOF_NPSXSPC) && !isPSXSPC(c))    ||
		(ANYOF_CLASS_TEST(n, ANYOF_BLANK)   &&  isBLANK(c))     ||
		(ANYOF_CLASS_TEST(n, ANYOF_NBLANK)  && !isBLANK(c))
		) /* How's that for a conditional? */
	    {
		match = TRUE;
	    }
	}
    }
d3832 1
a3832 7
{
    return S_reghop3(aTHX_ s, off, (U8*)(off >= 0 ? PL_regeol : PL_bostr));
}

STATIC U8 *
S_reghop3(pTHX_ U8 *s, I32 off, U8* lim)
{
d3834 1
a3834 2
	while (off-- && s < lim) {
	    /* XXX could check well-formedness here */
a3835 1
	}
d3839 1
a3839 1
	    if (s > lim) {
d3841 2
a3842 2
		if (UTF8_IS_CONTINUED(*s)) {
		    while (s > (U8*)lim && UTF8_IS_CONTINUATION(*s))
d3844 1
a3844 2
		}
		/* XXX could check well-formedness here */
d3852 1
a3852 7
S_reghopmaybe(pTHX_ U8 *s, I32 off)
{
    return S_reghopmaybe3(aTHX_ s, off, (U8*)(off >= 0 ? PL_regeol : PL_bostr));
}

STATIC U8 *
S_reghopmaybe3(pTHX_ U8* s, I32 off, U8* lim)
d3855 1
a3855 2
	while (off-- && s < lim) {
	    /* XXX could check well-formedness here */
a3856 1
	}
d3862 1
a3862 1
	    if (s > lim) {
d3864 2
a3865 2
		if (UTF8_IS_CONTINUED(*s)) {
		    while (s > (U8*)lim && UTF8_IS_CONTINUATION(*s))
d3867 1
a3867 2
		}
		/* XXX could check well-formedness here */
d3878 4
d3883 1
a3883 1
restore_pos(pTHX_ void *arg)
a3894 56
}

STATIC void
S_to_utf8_substr(pTHX_ register regexp *prog)
{
    SV* sv;
    if (prog->float_substr && !prog->float_utf8) {
	prog->float_utf8 = sv = NEWSV(117, 0);
	SvSetSV(sv, prog->float_substr);
	sv_utf8_upgrade(sv);
	if (SvTAIL(prog->float_substr))
	    SvTAIL_on(sv);
	if (prog->float_substr == prog->check_substr)
	    prog->check_utf8 = sv;
    }
    if (prog->anchored_substr && !prog->anchored_utf8) {
	prog->anchored_utf8 = sv = NEWSV(118, 0);
	SvSetSV(sv, prog->anchored_substr);
	sv_utf8_upgrade(sv);
	if (SvTAIL(prog->anchored_substr))
	    SvTAIL_on(sv);
	if (prog->anchored_substr == prog->check_substr)
	    prog->check_utf8 = sv;
    }
}

STATIC void
S_to_byte_substr(pTHX_ register regexp *prog)
{
    SV* sv;
    if (prog->float_utf8 && !prog->float_substr) {
	prog->float_substr = sv = NEWSV(117, 0);
	SvSetSV(sv, prog->float_utf8);
	if (sv_utf8_downgrade(sv, TRUE)) {
	    if (SvTAIL(prog->float_utf8))
		SvTAIL_on(sv);
	} else {
	    SvREFCNT_dec(sv);
	    prog->float_substr = sv = &PL_sv_undef;
	}
	if (prog->float_utf8 == prog->check_utf8)
	    prog->check_substr = sv;
    }
    if (prog->anchored_utf8 && !prog->anchored_substr) {
	prog->anchored_substr = sv = NEWSV(118, 0);
	SvSetSV(sv, prog->anchored_utf8);
	if (sv_utf8_downgrade(sv, TRUE)) {
	    if (SvTAIL(prog->anchored_utf8))
		SvTAIL_on(sv);
	} else {
	    SvREFCNT_dec(sv);
	    prog->anchored_substr = sv = &PL_sv_undef;
	}
	if (prog->anchored_utf8 == prog->check_utf8)
	    prog->check_substr = sv;
    }
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d70 1
a70 2
 ****    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 ****    2000, 2001, 2002, 2003, by Larry Wall and others
a88 1
#define RF_false	16		/* odd number of nested negatives */
d174 1
a174 1
    SSGROW(paren_elems_to_push + REGCP_OTHER_ELEMS);
a402 1
    RX_MATCH_UTF8_set(prog,do_utf8);
a543 3
	/* we may be pointing at the wrong string */
	if (s && RX_MATCH_COPIED(prog))
	    s = strbeg + (s - SvPVX(sv));
d598 1
a598 1
		    && (!do_utf8
d718 1
a718 1
        && (!do_utf8
d851 4
a854 1
	cache_re(prog);
a952 1
	STRLEN lnc;
d962 19
a980 34
	    if (do_utf8) {
		 while (s < strend) {
		      if ((ANYOF_FLAGS(c) & ANYOF_UNICODE) ||
			  !UTF8_IS_INVARIANT((U8)s[0]) ?
			  reginclass(c, (U8*)s, 0, do_utf8) :
			  REGINCLASS(c, (U8*)s)) {
			   if (tmp && (norun || regtry(prog, s)))
				goto got_it;
			   else
				tmp = doevery;
		      }
		      else 
			   tmp = 1;
		      s += UTF8SKIP(s);
		 }
	    }
	    else {
		 while (s < strend) {
		      STRLEN skip = 1;

		      if (REGINCLASS(c, (U8*)s) ||
			  (ANYOF_FOLD_SHARP_S(c, s, strend) &&
			   /* The assignment of 2 is intentional:
			    * for the folded sharp s, the skip is 2. */
			   (skip = SHARP_S_SKIP))) {
			   if (tmp && (norun || regtry(prog, s)))
				goto got_it;
			   else
				tmp = doevery;
		      }
		      else 
			   tmp = 1;
		      s += skip;
		 }
d993 2
a994 3
	    m   = STRING(c);
	    ln  = STR_LEN(c);	/* length to match in octets/bytes */
	    lnc = (I32) ln;	/* length to match in characters */
a996 1
		U8 *sm = (U8 *) m;
a1006 5
		lnc = 0;
		while (sm < ((U8 *) m + ln)) {
		    lnc++;
		    sm += UTF8SKIP(sm);
		}
d1014 2
a1015 3
	    m   = STRING(c);
	    ln  = STR_LEN(c);
	    lnc = (I32) ln;
d1019 1
a1019 1
	    e = HOP3c(strend, -((I32)lnc), s);
a1041 2
		    /* Upper and lower of 1st char are equal -
		     * probably not a "letter". */
a1599 1
    RX_MATCH_UTF8_set(prog,do_utf8);
a1845 3
	    /* we may be pointing at the wrong string */
	    if ((flags & REXEC_SCREAM) && RX_MATCH_COPIED(prog))
		s = strbeg + (s - SvPVX(sv));
d1885 1
a1885 2
	if (minlen) {
	    I32 op = (U8)OP(prog->regstclass);
d1887 1
a1887 3
	    if (PL_regkind[op] != EXACT && op != CANY)
	        strend = HOPc(strend, -(minlen - 1));
	}
a1928 3
		/* we may be pointing at the wrong string */
		else if (RX_MATCH_COPIED(prog))
		    s = strbeg + (s - SvPVX(sv));
a2109 1
    prog->lastcloseparen = 0;
d2272 1
a2272 1
		do_utf8 && OP(scan) != CANY ?
d2277 1
a2277 1
	      char *s1 = do_utf8 && OP(scan) != CANY ?
d2282 1
a2282 1
	      char *s2 = do_utf8 && OP(scan) != CANY ?
d2794 1
a2794 1
	    PAD *old_comppad;
a2795 1
	    struct regexp *oreg = PL_reg_re;
d2800 1
a2800 1
	    PAD_SAVE_LOCAL(old_comppad, (PAD*)PL_regdata->data[n + 2]);
d2816 1
a2816 1
	    PAD_RESTORE_LOCAL(old_comppad);
a2823 2
                    int toggleutf;
		    register SV *sv;
d2825 5
a2829 7
		    if(SvROK(ret) && SvSMAGICAL(sv = SvRV(ret)))
			mg = mg_find(sv, PERL_MAGIC_qr);
		    else if (SvSMAGICAL(ret)) {
			if (SvGMAGICAL(ret))
			    sv_unmagic(ret, PERL_MAGIC_qr);
			else
			    mg = mg_find(ret, PERL_MAGIC_qr);
a2830 1

a2843 1
                        if (DO_UTF8(ret)) pm.op_pmdynflags |= PMdf_DYN_UTF8;
d2846 1
a2846 2
			      & (SVs_TEMP | SVs_PADTMP | SVf_READONLY
				| SVs_GMG)))
a2875 3
		    toggleutf = ((PL_reg_flags & RF_utf8) != 0) ^
				((re->reganch & ROPT_UTF8) != 0);
		    if (toggleutf) PL_reg_flags ^= RF_utf8;
a2889 1
			if (toggleutf) PL_reg_flags ^= RF_utf8;
a2905 1
		    if (toggleutf) PL_reg_flags ^= RF_utf8;
d2916 1
a2916 1
	    else {
a2917 2
		cache_re(oreg);
	    }
d3150 1
a3150 4
			if (PL_reg_flags & RF_false)
			    sayYES;
			else
			    sayNO_SILENT;
d3336 13
a3348 2
			    c1 = c2 = -1000;
			    goto assume_ok_MM;
d3418 13
a3430 2
				c1 = c2 = -1000;
				goto assume_ok_REG;
d3527 13
a3539 2
			c1 = c2 = -1000;
			goto assume_ok_easy;
d3685 1
a3685 1
			    TRYPAREN(paren, ln, PL_reginput);
d3692 1
a3692 1
			TRYPAREN(paren, ln, PL_reginput);
a3832 1
	    PL_reg_flags ^= RF_false;
a3847 2
		if (n == 0)
		    PL_reg_flags ^= RF_false;
a3856 2
	    if (n == 0)
		PL_reg_flags ^= RF_false;
@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@d71 1
a71 1
 ****    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
d3357 1
a3357 1
	       backtracking: in particular, it is of constant non-zero length,
d3376 9
d3410 2
a3411 1
		while (n >= ln || (n == REG_INFTY && ln > 0)) { /* ln overflow ? */
d3442 7
d4253 1
a4253 1
 * The repeater is supposed to have constant non-zero length.
@


1.1.1.8
log
@perl 5.8.6 from CPAN
@
text
@a7 11
/* This file contains functions for executing a regular expression.  See
 * also regcomp.c which funnily enough, contains functions for compiling
 * a regular expression.
 *
 * This file is also copied at build time to ext/re/re_exec.c, where
 * it's built with -DPERL_EXT_RE_BUILD -DPERL_EXT_RE_DEBUG -DPERL_EXT.
 * This causes the main functions to be compiled under new names and with
 * debugging support added, which makes "use re 'debug'" work.
 
 */

a956 1
	register STRLEN uskip;
d967 1
a967 1
		 while (s + (uskip = UTF8SKIP(s)) <= strend) {
d979 1
a979 1
		      s += uskip;
d1175 1
a1175 1
		while (s + (uskip = UTF8SKIP(s)) <= strend) {
d1184 1
a1184 1
		    s += uskip;
d1218 1
a1218 1
		while (s + (uskip = UTF8SKIP(s)) <= strend) {
d1225 1
a1225 1
		    s += uskip;
d1247 1
a1247 1
		while (s + (uskip = UTF8SKIP(s)) <= strend) {
d1256 1
a1256 1
		    s += uskip;
d1276 1
a1276 1
		while (s + (uskip = UTF8SKIP(s)) <= strend) {
d1285 1
a1285 1
		    s += uskip;
d1305 1
a1305 1
		while (s + (uskip = UTF8SKIP(s)) <= strend) {
d1314 1
a1314 1
		    s += uskip;
d1334 1
a1334 1
		while (s + (uskip = UTF8SKIP(s)) <= strend) {
d1343 1
a1343 1
		    s += uskip;
d1363 1
a1363 1
		while (s + (uskip = UTF8SKIP(s)) <= strend) {
d1372 1
a1372 1
		    s += uskip;
d1392 1
a1392 1
		while (s + (uskip = UTF8SKIP(s)) <= strend) {
d1401 1
a1401 1
		    s += uskip;
d1421 1
a1421 1
		while (s + (uskip = UTF8SKIP(s)) <= strend) {
d1430 1
a1430 1
		    s += uskip;
d1450 1
a1450 1
		while (s + (uskip = UTF8SKIP(s)) <= strend) {
d1459 1
a1459 1
		    s += uskip;
d1479 1
a1479 1
		while (s + (uskip = UTF8SKIP(s)) <= strend) {
d1488 1
a1488 1
		    s += uskip;
d1508 1
a1508 1
		while (s + (uskip = UTF8SKIP(s)) <= strend) {
d1517 1
a1517 1
		    s += uskip;
d1537 1
a1537 1
		while (s + (uskip = UTF8SKIP(s)) <= strend) {
d1546 1
a1546 1
		    s += uskip;
d1566 1
a1566 1
		while (s + (uskip = UTF8SKIP(s)) <= strend) {
d1575 1
a1575 1
		    s += uskip;
@


1.1.1.9
log
@perl 5.8.8 import
@
text
@d58 1
d82 1
a82 1
 ****    2000, 2001, 2002, 2003, 2004, 2005, 2006, by Larry Wall and others
d101 1
d144 1
a144 6
#define LOAD_UTF8_CHARCLASS(class,str) STMT_START { \
    if (!CAT2(PL_utf8_,class)) { bool ok; ENTER; save_re_context(); ok=CAT2(is_utf8_,class)((U8*)str); assert(ok); LEAVE; } } STMT_END
#define LOAD_UTF8_CHARCLASS_ALNUM() LOAD_UTF8_CHARCLASS(alnum,"a")
#define LOAD_UTF8_CHARCLASS_DIGIT() LOAD_UTF8_CHARCLASS(digit,"0")
#define LOAD_UTF8_CHARCLASS_SPACE() LOAD_UTF8_CHARCLASS(space," ")
#define LOAD_UTF8_CHARCLASS_MARK()  LOAD_UTF8_CHARCLASS(mark, "\xcd\x86")
d178 1
a178 1
    const int retval = PL_savestack_ix;
d180 1
a180 1
    const int paren_elems_to_push = (PL_regsize - parenfloor) * REGCP_PAREN_ELEMS;
d225 1
a238 1
	I32 tmps;
d284 1
a284 1
    const I32 tmp = PL_savestack_ix;
d367 1
a367 1
/* If SCREAM, then SvPVX_const(sv) should be compatible with strpos and strend.
d408 1
a408 1
    const int do_utf8 = sv ? SvUTF8(sv) : 0;	/* if no sv we have to assume bytes */
d413 2
a414 2
    const char * const i_strpos = strpos;
    SV * const dsv = PERL_DEBUG_PAD_ZERO(0);
d425 1
a425 1
	 const char *s   = PL_reg_match_utf8 ?
d428 1
a428 1
	 const int   len = PL_reg_match_utf8 ?
d436 1
a436 1
		       "%sGuessing start of match, REx%s \"%s%.60s%s%s\" against \"%s%.*s%s%s\"...\n",
d478 1
a478 1
	       /* SvCUR is not set on references: SvRV and SvPVX_const overlap */
d500 1
a500 1
		if (slen && (*SvPVX_const(check) != *s
d502 1
a502 1
				 && memNE(SvPVX_const(check), s, slen)))) {
d508 1
a508 1
	    else if (*SvPVX_const(check) != *s
d510 1
a510 1
			 && memNE(SvPVX_const(check), s, slen)))
a511 1
	    check_at = s;
d521 1
a521 1
	    const I32 end = prog->check_offset_max + CHR_SVLEN(check)
d523 1
a523 1
	    const I32 eshift = CHR_DIST((U8*)strend, (U8*)s) - end;
d548 1
a548 1
	I32 * const pp = data ? data->scream_pos : &p;
d560 1
a560 1
	    s = strbeg + (s - SvPVX_const(sv));
d576 1
a576 2
	/* FIXME - DEBUG_EXECUTE_r if that is merged to maint.  */
    DEBUG_r(PerlIO_printf(Perl_debug_log, "%s %s substr \"%s%.*s%s\"%s%s",
d581 1
a581 1
			  SvPVX_const(check),
d596 1
a596 1
       XXXX /ttx+/ results in anchored="ttx", floating="x".  floating will
d609 1
a609 2
		char * const last = HOP3c(s, -start_shift, strbeg);
		char *last1, *last2;
d643 1
a643 1
			"%s anchored substr \"%s%.*s%s\"%s",
d648 1
a648 1
			  SvPVX_const(must),
d702 1
a702 2
	    /* FIXME - DEBUG_EXECUTE_r if that is merged to maint  */
	    DEBUG_r(PerlIO_printf(Perl_debug_log, "%s floating substr \"%s%.*s%s\"%s",
d706 1
a706 1
		      SvPVX_const(must),
d855 3
a857 4
        const U8* const str = (U8*)STRING(prog->regstclass);
        const int cl_l = (PL_regkind[(U8)OP(prog->regstclass)] == EXACT
			  ? CHR_DIST((U8 *)str+STR_LEN(prog->regstclass),
				     (U8 *)str)
d859 1
a859 1
	const char * const endpos = (prog->anchored_substr || prog->anchored_utf8 || ml_anch)
d865 1
d869 1
a869 1
        s = find_byclass(prog, prog->regstclass, s, endpos, 1);
d872 1
a872 1
	    const char *what = 0;
d962 1
a962 1
S_find_byclass(pTHX_ regexp * prog, regnode *c, char *s, const char *strend, I32 norun)
d964 1
a964 1
	const I32 doevery = (prog->reganch & ROPT_SKIP) == 0;
d973 1
a973 1
	register const bool do_utf8 = PL_reg_match_utf8;
d1030 2
a1031 3
		U8 tmpbuf1[UTF8_MAXBYTES_CASE+1];
		U8 tmpbuf2[UTF8_MAXBYTES_CASE+1];
		const U32 uniflags = ckWARN(WARN_UTF8) ? 0 : UTF8_ALLOW_ANY;
d1036 4
a1039 4
		c1 = utf8n_to_uvchr(tmpbuf1, UTF8_MAXBYTES_CASE, 
				    0, uniflags);
		c2 = utf8n_to_uvchr(tmpbuf2, UTF8_MAXBYTES_CASE,
				    0, uniflags);
d1076 2
a1077 1
	        U8 tmpbuf [UTF8_MAXBYTES+1];
d1079 1
a1079 1
		const U32 uniflags = ckWARN(WARN_UTF8) ? 0 : UTF8_ALLOW_ANY;
d1084 3
a1086 2
		        c = utf8n_to_uvchr((U8*)s, UTF8_MAXBYTES, &len,
					   uniflags);
a1093 1
			     U8 foldbuf[UTF8_MAXBYTES_CASE+1];
d1111 3
a1113 2
		      c = utf8n_to_uvchr((U8*)s, UTF8_MAXBYTES, &len,
					   uniflags);
a1132 1
			     U8 foldbuf[UTF8_MAXBYTES_CASE+1];
d1186 1
a1186 1
		LOAD_UTF8_CHARCLASS_ALNUM();
d1229 1
a1229 1
		LOAD_UTF8_CHARCLASS_ALNUM();
d1258 1
a1258 1
		LOAD_UTF8_CHARCLASS_ALNUM();
d1316 1
a1316 1
		LOAD_UTF8_CHARCLASS_ALNUM();
d1374 1
a1374 1
		LOAD_UTF8_CHARCLASS_SPACE();
d1432 1
a1432 1
		LOAD_UTF8_CHARCLASS_SPACE();
d1490 1
a1490 1
		LOAD_UTF8_CHARCLASS_DIGIT();
d1548 1
a1548 1
		LOAD_UTF8_CHARCLASS_DIGIT();
d1630 2
d1636 1
a1636 1
    const bool do_utf8 = DO_UTF8(sv);
a1640 1
    PERL_UNUSED_ARG(data);
d1725 6
a1730 6
	const char * const s0   = UTF
	    ? pv_uni_display(dsv0, (U8*)prog->precomp, prog->prelen, 60,
			  UNI_DISPLAY_REGEX)
	    : prog->precomp;
	const int len0 = UTF ? SvCUR(dsv0) : prog->prelen;
	const char * const s1 = do_utf8 ? sv_uni_display(dsv1, sv, 60,
d1732 1
a1732 1
	const int len1 = do_utf8 ? SvCUR(dsv1) : strend - startpos;
d1736 1
a1736 1
		       "%sMatching REx%s \"%s%*.*s%s%s\" against \"%s%.*s%s%s\"\n",
d1807 1
a1807 1
	ch = SvPVX_const(do_utf8 ? prog->anchored_utf8 : prog->anchored_substr)[0];
d1838 1
d1876 1
a1876 1
	/* XXXX check_substr already used to find "s", can optimize if
d1890 1
a1890 1
		s = strbeg + (s - SvPVX_const(sv));
d1919 1
a1919 1
                                  "Did not find %s substr \"%s%.*s%s\"%s...\n",
d1924 1
a1924 1
			      SvPVX_const(must),
d1938 2
a1939 2
	    const char *s0;
	    const char *s1;
d1945 1
a1945 1
	      pv_uni_display(dsv0, (U8*)SvPVX_const(prop), SvCUR(prop), 60,
d1947 1
a1947 1
	      SvPVX_const(prop);
d1953 1
a1953 1
			  "Matching stclass \"%*.*s\" against \"%*.*s\"\n",
d1957 1
a1957 1
        if (find_byclass(prog, c, s, strend, 0))
d1979 1
a1979 1
		    s = strbeg + (s - SvPVX_const(sv));
d1983 1
a1983 1
                const char * const little = SvPV_const(float_real, len);
d1998 1
a1998 1
			last = strend;	/* matching "$" */
d2126 1
a2126 1
	    Newxz(PL_reg_curpm, 1, PMOP);
d2169 1
a2169 1
            Newx(PL_reg_start_tmp, PL_reg_start_tmpl, char*);
a2243 36
#define POSCACHE_SUCCESS 0	/* caching success rather than failure */
#define POSCACHE_SEEN 1		/* we know what we're caching */
#define POSCACHE_START 2	/* the real cache: this bit maps to pos 0 */
#define CACHEsayYES STMT_START { \
    if (cache_offset | cache_bit) { \
	if (!(PL_reg_poscache[0] & (1<<POSCACHE_SEEN))) \
	    PL_reg_poscache[0] |= (1<<POSCACHE_SUCCESS) || (1<<POSCACHE_SEEN); \
        else if (!(PL_reg_poscache[0] & (1<<POSCACHE_SUCCESS))) { \
	    /* cache records failure, but this is success */ \
	    DEBUG_r( \
		PerlIO_printf(Perl_debug_log, \
		    "%*s  (remove success from failure cache)\n", \
		    REPORT_CODE_OFF+PL_regindent*2, "") \
	    ); \
	    PL_reg_poscache[cache_offset] &= ~(1<<cache_bit); \
	} \
    } \
    sayYES; \
} STMT_END
#define CACHEsayNO STMT_START { \
    if (cache_offset | cache_bit) { \
	if (!(PL_reg_poscache[0] & (1<<POSCACHE_SEEN))) \
	    PL_reg_poscache[0] |= (1<<POSCACHE_SEEN); \
        else if ((PL_reg_poscache[0] & (1<<POSCACHE_SUCCESS))) { \
	    /* cache records success, but this is failure */ \
	    DEBUG_r( \
		PerlIO_printf(Perl_debug_log, \
		    "%*s  (remove failure from success cache)\n", \
		    REPORT_CODE_OFF+PL_regindent*2, "") \
	    ); \
	    PL_reg_poscache[cache_offset] &= ~(1<<cache_bit); \
	} \
    } \
    sayNO; \
} STMT_END

d2278 1
a2278 1
    register const bool do_utf8 = PL_reg_match_utf8;
a2283 1
    U32 uniflags = ckWARN(WARN_UTF8) ? 0 : UTF8_ALLOW_ANY;
d2296 2
a2297 2
	    const int docolor = *PL_colors[0];
	    const int taill = (docolor ? 10 : 7); /* 3 chars for "> <" */
d2323 1
a2323 1
	      const char * const s0 =
d2328 2
a2329 2
	      const int len0 = do_utf8 ? strlen(s0) : pref0_len;
	      const char * const s1 = do_utf8 && OP(scan) != CANY ?
d2333 2
a2334 2
	      const int len1 = do_utf8 ? strlen(s1) : pref_len - pref0_len;
	      const char * const s2 = do_utf8 && OP(scan) != CANY ?
d2338 1
a2338 1
	      const int len2 = do_utf8 ? strlen(s2) : l;
d2355 1
a2355 1
			    SvPVX_const(prop));
d2443 2
a2444 1
		const char *e = s + ln;
a2448 1
			STRLEN ulen;
d2452 3
a2454 2
			    utf8n_to_uvuni((U8*)l, UTF8_MAXBYTES, &ulen,
					    uniflags))
a2462 1
			STRLEN ulen;
d2466 3
a2468 2
			    utf8n_to_uvuni((U8*)s, UTF8_MAXBYTES, &ulen,
					   uniflags))
d2577 1
a2577 1
		LOAD_UTF8_CHARCLASS_ALNUM();
d2600 1
a2600 1
		LOAD_UTF8_CHARCLASS_ALNUM();
d2627 1
a2627 1
		    const U8 * const r = reghop3((U8*)locinput, -1, (U8*)PL_bostr);
d2629 1
a2629 1
		    ln = utf8n_to_uvchr((U8 *)r, UTF8SKIP(r), 0, 0);
d2633 1
a2633 1
		    LOAD_UTF8_CHARCLASS_ALNUM();
d2665 1
a2665 1
		    LOAD_UTF8_CHARCLASS_SPACE();
d2695 1
a2695 1
		LOAD_UTF8_CHARCLASS_SPACE();
d2718 1
a2718 1
		LOAD_UTF8_CHARCLASS_DIGIT();
d2741 1
a2741 1
		LOAD_UTF8_CHARCLASS_DIGIT();
d2761 1
a2761 1
		LOAD_UTF8_CHARCLASS_MARK();
d2791 1
a2791 1
		const char *e = PL_bostr + PL_regendp[n];
d2798 3
a2801 4
			STRLEN ulen1, ulen2;
			U8 tmpbuf1[UTF8_MAXBYTES_CASE+1];
			U8 tmpbuf2[UTF8_MAXBYTES_CASE+1];

d2895 1
a2895 1
			const char *t = SvPV_const(ret, len);
d2897 3
a2899 3
			char * const oprecomp = PL_regprecomp;
			const I32 osize = PL_regsize;
			const I32 onpar = PL_regnpar;
d2903 1
a2903 1
			re = CALLREGCOMP(aTHX_ (char*)t, (char*)t + len, &pm);
d2915 1
a2915 1
				      "Entering embedded \"%s%.60s%s%s\"\n",
a3134 1
		I32 cache_offset = 0, cache_bit = 0;
d3187 1
a3187 1
		    const I32 size = (PL_reg_maxiter + 7 + POSCACHE_START)/8;
d3197 1
a3197 1
			Newxz(PL_reg_poscache, size, char);
d3206 1
a3206 1
		    cache_offset = locinput - PL_bostr;
d3208 4
a3211 5
		    cache_offset = (scan->flags & 0xf) - 1 + POSCACHE_START
			    + cache_offset * (scan->flags>>4);
		    cache_bit = cache_offset % 8;
		    cache_offset /= 8;
		    if (PL_reg_poscache[cache_offset] & (1<<cache_bit)) {
d3217 1
a3217 2
			if (PL_reg_poscache[0] & (1<<POSCACHE_SUCCESS))
			    /* cache records success */
a3219 1
			    /* cache records failure */
d3222 1
a3222 1
		    PL_reg_poscache[cache_offset] |= (1<<cache_bit);
d3236 1
a3236 1
			CACHEsayYES;	/* All done. */
d3252 1
a3252 1
			CACHEsayNO;
d3268 1
a3268 1
			CACHEsayYES;
d3274 1
a3274 1
		    CACHEsayNO;
d3286 1
a3286 1
			CACHEsayYES;
d3310 1
a3310 1
		    CACHEsayYES;
d3316 1
a3316 1
		CACHEsayNO;
d3333 1
a3333 1
		    const I32 lastparen = *PL_reglastparen;
d3573 2
a3574 2
			     U8 tmpbuf1[UTF8_MAXBYTES_CASE+1];
			     U8 tmpbuf2[UTF8_MAXBYTES_CASE+1];
d3579 6
a3584 4
			     c1 = utf8n_to_uvuni(tmpbuf1, UTF8_MAXBYTES, 0,
						 uniflags);
			     c2 = utf8n_to_uvuni(tmpbuf2, UTF8_MAXBYTES, 0,
						 uniflags);
d3587 3
a3589 2
			    c2 = c1 = utf8n_to_uvchr(s, UTF8_MAXBYTES, 0,
						     uniflags);
d3643 1
a3644 1
				STRLEN len;
d3649 3
a3651 2
						      UTF8_MAXBYTES, &len,
						      uniflags) != (UV)c1) {
a3655 1
				STRLEN len;
d3660 3
a3662 2
							  UTF8_MAXBYTES, &len,
							  uniflags);
d3697 3
a3699 2
					       UTF8_MAXBYTES, 0,
					       uniflags);
d3747 3
a3749 2
						   UTF8_MAXBYTES, 0,
						   uniflags);
d3770 3
a3772 2
						   UTF8_MAXBYTES, 0,
						   uniflags);
d3853 1
d3869 2
d3880 2
d3953 1
a3953 1
	    const I32 lastparen = uwb->lastparen;
d3970 1
d4009 1
a4009 1
S_regrepeat(pTHX_ const regnode *p, I32 max)
d4083 1
a4083 1
	    LOAD_UTF8_CHARCLASS_ALNUM();
d4111 1
a4111 1
	    LOAD_UTF8_CHARCLASS_ALNUM();
d4139 1
a4139 1
	    LOAD_UTF8_CHARCLASS_SPACE();
d4168 1
a4168 1
	    LOAD_UTF8_CHARCLASS_SPACE();
d4197 1
a4197 1
	    LOAD_UTF8_CHARCLASS_DIGIT();
d4211 1
a4211 1
	    LOAD_UTF8_CHARCLASS_DIGIT();
d4236 1
a4236 1
		regprop(prop, (regnode *)p);
d4239 1
a4239 1
			      REPORT_CODE_OFF+1, "", SvPVX_const(prop),(IV)c,(IV)max);
d4309 1
a4309 1
	const U32 n = ARG(node);
d4312 3
a4314 3
	    SV * const rv = (SV*)PL_regdata->data[n];
	    AV * const av = (AV*)SvRV((SV*)rv);
	    SV **const ary = AvARRAY(av);
d4321 1
a4321 1
	    a  = SvROK(ary[1]) ? &ary[1] : 0;
d4354 1
a4354 1
S_reginclass(pTHX_ register const regnode *n, register const U8* p, STRLEN* lenp, register bool do_utf8)
d4356 1
a4356 1
    const char flags = ANYOF_FLAGS(n);
d4362 3
a4364 7
    if (do_utf8 && !UTF8_IS_INVARIANT(c)) {
	c = utf8n_to_uvchr((U8 *)p, UTF8_MAXBYTES, &len,
			    ckWARN(WARN_UTF8) ? UTF8_CHECK_ONLY :
					UTF8_ALLOW_ANYUV|UTF8_CHECK_ONLY);
	if (len == (STRLEN)-1)
	    Perl_croak(aTHX_ "Malformed UTF-8 character (fatal)");
    }
d4378 1
a4378 1
	    SV * const sw = regclass_swash((regnode *)n, TRUE, 0, (SV**)&av);
d4381 1
a4381 1
		if (swash_fetch(sw, (U8 *)p, do_utf8))
d4386 1
d4388 1
a4388 1
			    SV* const sv = *av_fetch(av, i, FALSE);
d4390 1
a4390 1
			    const char * const s = SvPV_const(sv, len);
d4400 1
a4400 1
		        U8 tmpbuf[UTF8_MAXBYTES_CASE+1];
d4403 1
a4403 1
		        to_utf8_fold((U8 *)p, tmpbuf, &tmplen);
a4540 1
    PERL_UNUSED_ARG(arg);
d4556 1
d4558 2
a4559 2
	SV* sv;
	prog->float_utf8 = sv = newSVsv(prog->float_substr);
d4567 2
a4568 2
	SV* sv;
	prog->anchored_utf8 = sv = newSVsv(prog->anchored_substr);
d4580 1
d4582 2
a4583 2
	SV* sv;
	prog->float_substr = sv = newSVsv(prog->float_utf8);
d4595 2
a4596 2
	SV* sv;
	prog->anchored_substr = sv = newSVsv(prog->anchored_utf8);
a4607 10

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
@


1.1.1.10
log
@import perl 5.10.0 from CPAN
@
text
@d16 1
d34 22
a55 1
#include "re_top.h"
d81 1
a81 1
 ****    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007 by Larry Wall and others
d94 1
a94 5
#ifdef PERL_IN_XSUB_RE
#  include "re_comp.h"
#else
#  include "regcomp.h"
#endif
d98 2
a99 2

#define RF_utf8		8		/* Pattern contains multibyte chars? */
d110 1
a110 1
#define REGINCLASS(prog,p,c)  (ANYOF_FLAGS(p) ? reginclass(prog,p,c,0,0) : ANYOF_BITMAP_TEST(p,*(c)))
d119 15
a133 10
#define HOPc(pos,off) \
	(char *)(PL_reg_match_utf8 \
	    ? reghop3((U8*)pos, off, (U8*)(off >= 0 ? PL_regeol : PL_bostr)) \
	    : (U8*)(pos + off))
#define HOPBACKc(pos, off) \
	(char*)(PL_reg_match_utf8\
	    ? reghopmaybe3((U8*)pos, -off, (U8*)PL_bostr) \
	    : (pos - off >= PL_bostr)		\
		? (U8*)pos - off		\
		: NULL)
d135 4
a138 1
#define HOP3(pos,off,lim) (PL_reg_match_utf8 ? reghop3((U8*)(pos), off, (U8*)(lim)) : (U8*)(pos + off))
d140 1
d143 1
a143 1
    if (!CAT2(PL_utf8_,class)) { bool ok; ENTER; save_re_context(); ok=CAT2(is_utf8_,class)((const U8*)str); assert(ok); LEAVE; } } STMT_END
a148 2
/* TODO: Combine JUMPABLE and HAS_TEXT to cache OP(rn) */

d150 2
a151 5
/* it would be nice to rework regcomp.sym to generate this stuff. sigh */
#define JUMPABLE(rn) (      \
    OP(rn) == OPEN ||       \
    (OP(rn) == CLOSE && (!cur_eval || cur_eval->u.eval.close_paren != ARG(rn))) || \
    OP(rn) == EVAL ||   \
d154 1
a154 2
    OP(rn) == KEEPS || (PL_regkind[OP(rn)] == VERB) || \
    (PL_regkind[OP(rn)] == CURLY && ARG1(rn) > 0) \
a155 1
#define IS_EXACT(rn) (PL_regkind[OP(rn)] == EXACT)
d157 3
a159 16
#define HAS_TEXT(rn) ( IS_EXACT(rn) || PL_regkind[OP(rn)] == REF )

#if 0 
/* Currently these are only used when PL_regkind[OP(rn)] == EXACT so
   we don't need this definition. */
#define IS_TEXT(rn)   ( OP(rn)==EXACT   || OP(rn)==REF   || OP(rn)==NREF   )
#define IS_TEXTF(rn)  ( OP(rn)==EXACTF  || OP(rn)==REFF  || OP(rn)==NREFF  )
#define IS_TEXTFL(rn) ( OP(rn)==EXACTFL || OP(rn)==REFFL || OP(rn)==NREFFL )

#else
/* ... so we use this as its faster. */
#define IS_TEXT(rn)   ( OP(rn)==EXACT   )
#define IS_TEXTF(rn)  ( OP(rn)==EXACTF  )
#define IS_TEXTFL(rn) ( OP(rn)==EXACTFL )

#endif
d166 2
a167 3
    while (JUMPABLE(rn)) { \
	const OPCODE type = OP(rn); \
	if (type == SUSPEND || PL_regkind[type] == CURLY) \
d169 1
a169 1
	else if (type == PLUS) \
d171 1
a171 1
	else if (type == IFMATCH) \
a173 1
    } \
a175 1

a180 1
    dVAR;
a184 1
    GET_RE_DEBUG_FLAGS_DECL;
d189 1
a189 1
#define REGCP_OTHER_ELEMS 7
a190 1
    
d193 2
a194 2
	SSPUSHINT(PL_regoffs[p].end);
	SSPUSHINT(PL_regoffs[p].start);
a196 6
	DEBUG_BUFFERS_r(PerlIO_printf(Perl_debug_log,
	  "     saving \\%"UVuf" %"IVdf"(%"IVdf")..%"IVdf"\n",
		      (UV)p, (IV)PL_regoffs[p].start,
		      (IV)(PL_reg_start_tmp[p] - PL_bostr),
		      (IV)PL_regoffs[p].end
	));
a198 1
    SSPUSHPTR(PL_regoffs);
d213 8
a220 14
#define REGCP_SET(cp)                                           \
    DEBUG_STATE_r(                                              \
            PerlIO_printf(Perl_debug_log,		        \
	        "  Setting an EVAL scope, savestack=%"IVdf"\n",	\
	        (IV)PL_savestack_ix));                          \
    cp = PL_savestack_ix

#define REGCP_UNWIND(cp)                                        \
    DEBUG_STATE_r(                                              \
        if (cp != PL_savestack_ix) 		                \
    	    PerlIO_printf(Perl_debug_log,		        \
		"  Clearing an EVAL scope, savestack=%"IVdf"..%"IVdf"\n", \
	        (IV)(cp), (IV)PL_savestack_ix));                \
    regcpblow(cp)
d223 1
a223 1
S_regcppop(pTHX_ const regexp *rex)
d225 2
a226 2
    dVAR;
    U32 i;
a228 2
    GET_RE_DEBUG_FLAGS_DECL;

a236 1
    PL_regoffs=(regexp_paren_pair *) SSPOPPTR;
a237 1
    
d242 1
a242 1
	U32 paren = (U32)SSPOPINT;
d244 1
a244 1
	PL_regoffs[paren].start = SSPOPINT;
d247 2
a248 2
	    PL_regoffs[paren].end = tmps;
	DEBUG_BUFFERS_r(
d251 1
a251 1
			  (UV)paren, (IV)PL_regoffs[paren].start,
d253 1
a253 1
			  (IV)PL_regoffs[paren].end,
d257 2
a258 2
    DEBUG_BUFFERS_r(
	if (*PL_reglastparen + 1 <= rex->nparens) {
d261 1
a261 1
			  (IV)(*PL_reglastparen + 1), (IV)rex->nparens);
d272 7
a278 6
     * this erroneously leaves $1 defined: "1" =~ /^(?:(\d)x)?\d$/
     * --jhi updated by dapm */
    for (i = *PL_reglastparen + 1; i <= rex->nparens; i++) {
	if (i > PL_regsize)
	    PL_regoffs[i].start = -1;
	PL_regoffs[i].end = -1;
d284 20
d306 16
a325 1
#ifndef PERL_IN_XSUB_RE
d330 1
a330 1
Perl_pregexec(pTHX_ REGEXP * const prog, char* stringarg, register char *strend,
d341 7
d349 4
d380 1
a380 5
	(Or minlen should take into account lookahead.) 
  NOTE: Some of this comment is not correct. minlen does now take account
  of lookahead/behind. Further research is required. -- demerphq

*/
d401 2
a402 2
Perl_re_intuit_start(pTHX_ REGEXP * const prog, SV *sv, char *strpos,
		     char *strend, const U32 flags, re_scream_pos_data *data)
a403 1
    dVAR;
d411 1
a411 1
    const bool do_utf8 = (sv && SvUTF8(sv)) ? 1 : 0; /* if no sv we have to assume bytes */
d413 2
a414 4
    register char *other_last = NULL;	/* other substr checked before this */
    char *check_at = NULL;		/* check substr found at this pos */
    const I32 multiline = prog->extflags & RXf_PMf_MULTILINE;
    RXi_GET_DECL(prog,progi);
d417 1
a418 3

    GET_RE_DEBUG_FLAGS_DECL;

d421 3
a423 1
    if (prog->extflags & RXf_UTF8) {
d426 22
a447 4
    DEBUG_EXECUTE_r( 
        debug_start_match(prog, do_utf8, strpos, strend, 
            sv ? "Guessing start of match in sv for"
               : "Guessing start of match in string for");
d449 1
d453 1
a453 1
	DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
a456 1
                
d468 3
a470 3
    if (check == &PL_sv_undef) {
	DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
		"Non-utf8 string cannot match utf8 check string\n"));
d473 4
a476 4
    if (prog->extflags & RXf_ANCH) {	/* Match at beg-of-str or after \n */
	ml_anch = !( (prog->extflags & RXf_ANCH_SINGLE)
		     || ( (prog->extflags & RXf_ANCH_BOL)
			  && !multiline ) );	/* Check after \n? */
d479 2
a480 2
	  if ( !(prog->extflags & RXf_ANCH_GPOS) /* Checked by the caller */
		&& !(prog->intflags & PREGf_IMPLICIT) /* not a real BOL */
d484 1
a484 1
	      DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "Not at start...\n"));
d488 1
a488 1
	      !(prog->extflags & RXf_CANY_SEEN)) {
a492 1
	    
d498 1
a498 1
		    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "String too long...\n"));
d507 1
a507 1
		    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "String not equal...\n"));
d522 2
a523 2
	end_shift = prog->check_end_shift;
	
d536 4
a539 4
	start_shift = prog->check_offset_min;  /* okay to underestimate on CC */
	end_shift = prog->check_end_shift;
	
	/* end shift should be non negative here */
d542 1
a542 1
#ifdef QDEBUGGING	/* 7/99: reports of failure (with the older version) */
d544 1
a544 2
	Perl_croak(aTHX_ "panic: end_shift: %"IVdf" pattern:\n%s\n ",
		   (IV)end_shift, prog->precomp);
a549 16
    
    {
        I32 srch_start_shift = start_shift;
        I32 srch_end_shift = end_shift;
        if (srch_start_shift < 0 && strbeg - s > srch_start_shift) {
	    srch_end_shift -= ((strbeg - s) - srch_start_shift); 
	    srch_start_shift = strbeg - s;
	}
    DEBUG_OPTIMISE_MORE_r({
        PerlIO_printf(Perl_debug_log, "Check offset min: %"IVdf" Start shift: %"IVdf" End shift %"IVdf" Real End Shift: %"IVdf"\n",
            (IV)prog->check_offset_min,
            (IV)srch_start_shift,
            (IV)srch_end_shift, 
            (IV)prog->check_end_shift);
    });       
        
d559 1
a559 1
			    srch_start_shift + (s - strbeg), srch_end_shift, pp, 0);
d568 8
a575 16
    else {
        U8* start_point;
        U8* end_point;
        if (prog->extflags & RXf_CANY_SEEN) {
            start_point= (U8*)(s + srch_start_shift);
            end_point= (U8*)(strend - srch_end_shift);
        } else {
	    start_point= HOP3(s, srch_start_shift, srch_start_shift < 0 ? strbeg : strend);
            end_point= HOP3(strend, -srch_end_shift, strbeg);
	}
	DEBUG_OPTIMISE_MORE_r({
            PerlIO_printf(Perl_debug_log, "fbm_instr len=%d str=<%.*s>\n", 
                (int)(end_point - start_point),
                (int)(end_point - start_point) > 20 ? 20 : (int)(end_point - start_point), 
                start_point);
        });
a576 4
	s = fbm_instr( start_point, end_point,
		      check, multiline ? FBMrf_MULTILINE : 0);
    }
    }
d580 2
a581 4
    DEBUG_EXECUTE_r({
        RE_PV_QUOTED_DECL(quoted, do_utf8, PERL_DEBUG_PAD_ZERO(0), 
            SvPVX_const(check), RE_SV_DUMPLEN(check), 30);
        PerlIO_printf(Perl_debug_log, "%s %s substr %s%s%s",
d583 6
a588 6
	    (check == (do_utf8 ? prog->anchored_utf8 : prog->anchored_substr) 
	        ? "anchored" : "floating"),
	    quoted,
	    RE_SV_TAIL(check),
	    (s ? " at offset " : "...\n") ); 
    });
d592 3
d596 1
a596 12
    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "%ld...\n", (long)(s - i_strpos)) );

    /* XXX dmq: first branch is for positive lookbehind...
       Our check string is offset from the beginning of the pattern.
       So we need to do any stclass tests offset forward from that 
       point. I think. :-(
     */
    
        
    
    check_at=s;
     
d606 1
a606 3
    if (do_utf8 ? (prog->float_utf8 && prog->anchored_utf8) 
                : (prog->float_substr && prog->anchored_substr)) 
    {
d616 1
a616 1
		char * const saved_s = s;
d622 1
a622 1
			|| ((t = (char*)reghopmaybe3((U8*)s, -(prog->check_offset_max), (U8*)strpos))
d624 1
a624 1
		    NOOP;
d633 1
a633 6
                /* XXXX It is not documented what units *_offsets are in.  
                   We assume bytes, but this is clearly wrong. 
                   Meaning this code needs to be carefully reviewed for errors.
                   dmq.
                  */
 
d646 1
a646 1
			multiline ? FBMrf_MULTILINE : 0
d648 2
a649 4
                DEBUG_EXECUTE_r({
                    RE_PV_QUOTED_DECL(quoted, do_utf8, PERL_DEBUG_PAD_ZERO(0), 
                        SvPVX_const(must), RE_SV_DUMPLEN(must), 30);
                    PerlIO_printf(Perl_debug_log, "%s anchored substr %s%s",
d651 5
a655 4
                        quoted, RE_SV_TAIL(must));
                });		    
		
			    
d658 1
a658 1
			DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
d662 1
a662 1
		    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
d664 1
a664 1
			(long)(HOP3c(saved_s, 1, strend) - i_strpos)));
d670 1
a670 1
		    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, " at offset %ld...\n",
d674 1
a674 1
		    s = saved_s;
d683 1
a683 1
	    char * const saved_s = s;
d707 3
a709 5
			      must, multiline ? FBMrf_MULTILINE : 0);
	    DEBUG_EXECUTE_r({
	        RE_PV_QUOTED_DECL(quoted, do_utf8, PERL_DEBUG_PAD_ZERO(0), 
	            SvPVX_const(must), RE_SV_DUMPLEN(must), 30);
	        PerlIO_printf(Perl_debug_log, "%s floating substr %s%s",
d711 4
a714 2
		    quoted, RE_SV_TAIL(must));
            });
d717 1
a717 1
		    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
d721 1
a721 1
		DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
d723 1
a723 1
		    (long)(saved_s + 1 - i_strpos)));
d729 1
a729 1
		DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, " at offset %ld...\n",
d732 1
a732 1
		s = saved_s;
d740 1
a740 15
    
    t= (char*)HOP3( s, -prog->check_offset_max, (prog->check_offset_max<0) ? strend : strpos);
        
    DEBUG_OPTIMISE_MORE_r(
        PerlIO_printf(Perl_debug_log, 
            "Check offset min:%"IVdf" max:%"IVdf" S:%"IVdf" t:%"IVdf" D:%"IVdf" end:%"IVdf"\n",
            (IV)prog->check_offset_min,
            (IV)prog->check_offset_max,
            (IV)(s-strpos),
            (IV)(t-strpos),
            (IV)(t-s),
            (IV)(strend-strpos)
        )
    );

d743 2
a744 3
	    || ((t = (char*)reghopmaybe3((U8*)s, -prog->check_offset_max, (U8*) ((prog->check_offset_max<0) ? strend : strpos)))
		 && t > strpos))) 
    {
d768 2
a769 2
			    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "Found /%s^%s/m at offset %ld, rescanning for anchored from offset %ld...\n",
				PL_colors[0], PL_colors[1], (long)(strpos - i_strpos), (long)(strpos - i_strpos + prog->anchored_offset)));
d775 2
a776 2
			DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "Found /%s^%s/m at offset %ld...\n",
			    PL_colors[0], PL_colors[1], (long)(s - i_strpos)));
d782 2
a783 2
		    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "Found /%s^%s/m, restarting lookup for check-string at offset %ld...\n",
			PL_colors[0], PL_colors[1], (long)(t + 1 - i_strpos)));
d789 2
a790 2
	    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "Did not find /%s^%s/m...\n",
			PL_colors[0], PL_colors[1]));
d794 2
a795 2
	    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "Starting position does not contradict /%s^%s/m...\n",
			PL_colors[0], PL_colors[1]));
d812 1
a812 1
	    && !(prog->intflags & PREGf_IMPLICIT))
d817 1
a817 1
	DEBUG_EXECUTE_r( if (ml_anch)
d819 1
a819 1
			  (long)(strpos - i_strpos), PL_colors[0], PL_colors[1]);
d822 1
a822 1
	if (!(prog->intflags & PREGf_NAUGHTY)	/* XXXX If strpos moved? */
d834 1
a834 1
	    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "... Disabling check substring...\n"));
d838 3
a840 3
	    prog->check_substr = prog->check_utf8 = NULL;	/* disable */
	    prog->float_substr = prog->float_utf8 = NULL;	/* clear */
	    check = NULL;			/* abort */
d845 1
a845 1
	    prog->extflags &= ~RXf_USE_INTUIT;
d853 1
a853 3
    /* trie stclasses are too expensive to use here, we are better off to
       leave it to regmatch itself */
    if (progi->regstclass && PL_regkind[OP(progi->regstclass)]!=TRIE) {
d862 4
a865 3
        const U8* const str = (U8*)STRING(progi->regstclass);
        const int cl_l = (PL_regkind[OP(progi->regstclass)] == EXACT
		    ? CHR_DIST(str+STR_LEN(progi->regstclass), str)
d867 7
a873 11
	char * endpos;
	if (prog->anchored_substr || prog->anchored_utf8 || ml_anch)
            endpos= HOP3c(s, (prog->minlen ? cl_l : 0), strend);
        else if (prog->float_substr || prog->float_utf8)
	    endpos= HOP3c(HOP3c(check_at, -start_shift, strbeg), cl_l, strend);
        else 
            endpos= strend;
		    
        DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "start_shift: %"IVdf" check_at: %"IVdf" s: %"IVdf" endpos: %"IVdf"\n",
				      (IV)start_shift, (IV)(check_at - strbeg), (IV)(s - strbeg), (IV)(endpos - strbeg)));
	
d875 2
a876 1
        s = find_byclass(prog, progi->regstclass, s, endpos, NULL);
d879 1
a879 1
	    const char *what = NULL;
d882 1
a882 1
		DEBUG_EXECUTE_r( PerlIO_printf(Perl_debug_log,
d886 1
a886 1
	    DEBUG_EXECUTE_r( PerlIO_printf(Perl_debug_log,
d888 1
a888 1
	    if ((prog->extflags & RXf_ANCH) && !ml_anch)
d893 1
a893 1
		    DEBUG_EXECUTE_r( what = "anchored" );
d898 1
a898 1
			DEBUG_EXECUTE_r( PerlIO_printf(Perl_debug_log,
d904 1
a904 1
		    DEBUG_EXECUTE_r( PerlIO_printf(Perl_debug_log,
d916 1
a916 1
		DEBUG_EXECUTE_r( PerlIO_printf(Perl_debug_log,
d927 1
a927 1
		DEBUG_EXECUTE_r( PerlIO_printf(Perl_debug_log,
d929 1
a929 1
			  PL_colors[0], PL_colors[1], (long)(t - i_strpos)) );
d937 1
a937 1
	    DEBUG_EXECUTE_r( what = "floating" );
d941 1
a941 1
            DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
d947 1
a947 1
            DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
d953 1
a953 1
    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "%s%s:%s match at offset %ld\n",
d962 3
a964 3
    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "%sMatch rejected by optimizer%s\n",
			  PL_colors[4], PL_colors[5]));
    return NULL;
a966 170
#define DECL_TRIE_TYPE(scan) \
    const enum { trie_plain, trie_utf8, trie_utf8_fold, trie_latin_utf8_fold } \
		    trie_type = (scan->flags != EXACT) \
		              ? (do_utf8 ? trie_utf8_fold : (UTF ? trie_latin_utf8_fold : trie_plain)) \
                              : (do_utf8 ? trie_utf8 : trie_plain)

#define REXEC_TRIE_READ_CHAR(trie_type, trie, widecharmap, uc, uscan, len,  \
uvc, charid, foldlen, foldbuf, uniflags) STMT_START {                       \
    switch (trie_type) {                                                    \
    case trie_utf8_fold:                                                    \
	if ( foldlen>0 ) {                                                  \
	    uvc = utf8n_to_uvuni( uscan, UTF8_MAXLEN, &len, uniflags );     \
	    foldlen -= len;                                                 \
	    uscan += len;                                                   \
	    len=0;                                                          \
	} else {                                                            \
	    uvc = utf8n_to_uvuni( (U8*)uc, UTF8_MAXLEN, &len, uniflags );   \
	    uvc = to_uni_fold( uvc, foldbuf, &foldlen );                    \
	    foldlen -= UNISKIP( uvc );                                      \
	    uscan = foldbuf + UNISKIP( uvc );                               \
	}                                                                   \
	break;                                                              \
    case trie_latin_utf8_fold:                                              \
	if ( foldlen>0 ) {                                                  \
	    uvc = utf8n_to_uvuni( uscan, UTF8_MAXLEN, &len, uniflags );     \
	    foldlen -= len;                                                 \
	    uscan += len;                                                   \
	    len=0;                                                          \
	} else {                                                            \
	    len = 1;                                                        \
	    uvc = to_uni_fold( *(U8*)uc, foldbuf, &foldlen );               \
	    foldlen -= UNISKIP( uvc );                                      \
	    uscan = foldbuf + UNISKIP( uvc );                               \
	}                                                                   \
	break;                                                              \
    case trie_utf8:                                                         \
	uvc = utf8n_to_uvuni( (U8*)uc, UTF8_MAXLEN, &len, uniflags );       \
	break;                                                              \
    case trie_plain:                                                        \
	uvc = (UV)*uc;                                                      \
	len = 1;                                                            \
    }                                                                       \
									    \
    if (uvc < 256) {                                                        \
	charid = trie->charmap[ uvc ];                                      \
    }                                                                       \
    else {                                                                  \
	charid = 0;                                                         \
	if (widecharmap) {                                                  \
	    SV** const svpp = hv_fetch(widecharmap,                         \
			(char*)&uvc, sizeof(UV), 0);                        \
	    if (svpp)                                                       \
		charid = (U16)SvIV(*svpp);                                  \
	}                                                                   \
    }                                                                       \
} STMT_END

#define REXEC_FBC_EXACTISH_CHECK(CoNd)                 \
{                                                      \
    char *my_strend= (char *)strend;                   \
    if ( (CoNd)                                        \
	 && (ln == len ||                              \
	     !ibcmp_utf8(s, &my_strend, 0,  do_utf8,   \
			m, NULL, ln, (bool)UTF))       \
	 && (!reginfo || regtry(reginfo, &s)) )        \
	goto got_it;                                   \
    else {                                             \
	 U8 foldbuf[UTF8_MAXBYTES_CASE+1];             \
	 uvchr_to_utf8(tmpbuf, c);                     \
	 f = to_utf8_fold(tmpbuf, foldbuf, &foldlen);  \
	 if ( f != c                                   \
	      && (f == c1 || f == c2)                  \
	      && (ln == len ||                         \
	        !ibcmp_utf8(s, &my_strend, 0,  do_utf8,\
			      m, NULL, ln, (bool)UTF)) \
	      && (!reginfo || regtry(reginfo, &s)) )   \
	      goto got_it;                             \
    }                                                  \
}                                                      \
s += len

#define REXEC_FBC_EXACTISH_SCAN(CoNd)                     \
STMT_START {                                              \
    while (s <= e) {                                      \
	if ( (CoNd)                                       \
	     && (ln == 1 || !(OP(c) == EXACTF             \
			      ? ibcmp(s, m, ln)           \
			      : ibcmp_locale(s, m, ln)))  \
	     && (!reginfo || regtry(reginfo, &s)) )        \
	    goto got_it;                                  \
	s++;                                              \
    }                                                     \
} STMT_END

#define REXEC_FBC_UTF8_SCAN(CoDe)                     \
STMT_START {                                          \
    while (s + (uskip = UTF8SKIP(s)) <= strend) {     \
	CoDe                                          \
	s += uskip;                                   \
    }                                                 \
} STMT_END

#define REXEC_FBC_SCAN(CoDe)                          \
STMT_START {                                          \
    while (s < strend) {                              \
	CoDe                                          \
	s++;                                          \
    }                                                 \
} STMT_END

#define REXEC_FBC_UTF8_CLASS_SCAN(CoNd)               \
REXEC_FBC_UTF8_SCAN(                                  \
    if (CoNd) {                                       \
	if (tmp && (!reginfo || regtry(reginfo, &s)))  \
	    goto got_it;                              \
	else                                          \
	    tmp = doevery;                            \
    }                                                 \
    else                                              \
	tmp = 1;                                      \
)

#define REXEC_FBC_CLASS_SCAN(CoNd)                    \
REXEC_FBC_SCAN(                                       \
    if (CoNd) {                                       \
	if (tmp && (!reginfo || regtry(reginfo, &s)))  \
	    goto got_it;                              \
	else                                          \
	    tmp = doevery;                            \
    }                                                 \
    else                                              \
	tmp = 1;                                      \
)

#define REXEC_FBC_TRYIT               \
if ((!reginfo || regtry(reginfo, &s))) \
    goto got_it

#define REXEC_FBC_CSCAN(CoNdUtF8,CoNd)                         \
    if (do_utf8) {                                             \
	REXEC_FBC_UTF8_CLASS_SCAN(CoNdUtF8);                   \
    }                                                          \
    else {                                                     \
	REXEC_FBC_CLASS_SCAN(CoNd);                            \
    }                                                          \
    break
    
#define REXEC_FBC_CSCAN_PRELOAD(UtFpReLoAd,CoNdUtF8,CoNd)      \
    if (do_utf8) {                                             \
	UtFpReLoAd;                                            \
	REXEC_FBC_UTF8_CLASS_SCAN(CoNdUtF8);                   \
    }                                                          \
    else {                                                     \
	REXEC_FBC_CLASS_SCAN(CoNd);                            \
    }                                                          \
    break

#define REXEC_FBC_CSCAN_TAINT(CoNdUtF8,CoNd)                   \
    PL_reg_flags |= RF_tainted;                                \
    if (do_utf8) {                                             \
	REXEC_FBC_UTF8_CLASS_SCAN(CoNdUtF8);                   \
    }                                                          \
    else {                                                     \
	REXEC_FBC_CLASS_SCAN(CoNd);                            \
    }                                                          \
    break

#define DUMP_EXEC_POS(li,s,doutf8) \
    dump_exec_pos(li,s,(PL_regeol),(PL_bostr),(PL_reg_starttry),doutf8)

a967 4
/* if reginfo is NULL, its a dryrun */
/* annoyingly all the vars in this routine have different names from their counterparts
   in regmatch. /grrr */

d969 1
a969 2
S_find_byclass(pTHX_ regexp * prog, const regnode *c, char *s, 
    const char *strend, regmatch_info *reginfo)
d971 1
a971 2
	dVAR;
	const I32 doevery = (prog->intflags & PREGf_SKIP) == 0;
d981 1
a981 2
        RXi_GET_DECL(prog,progi);
        
d986 2
a987 1
		 REXEC_FBC_UTF8_CLASS_SCAN((ANYOF_FLAGS(c) & ANYOF_UNICODE) ||
d989 11
a999 2
			  reginclass(prog, c, (U8*)s, 0, do_utf8) :
			  REGINCLASS(prog, c, (U8*)s));
d1005 1
a1005 1
		      if (REGINCLASS(prog, c, (U8*)s) ||
d1010 1
a1010 1
			   if (tmp && (!reginfo || regtry(reginfo, &s)))
d1022 2
a1023 2
	    REXEC_FBC_SCAN(
	        if (tmp && (!reginfo || regtry(reginfo, &s)))
d1027 2
a1028 1
	    );
d1039 5
a1043 16
		/* used by commented-out code below */
		/*const U32 uniflags = UTF8_ALLOW_DEFAULT;*/
		
                /* XXX: Since the node will be case folded at compile
                   time this logic is a little odd, although im not 
                   sure that its actually wrong. --dmq */
                   
		c1 = to_utf8_lower((U8*)m, tmpbuf1, &ulen1);
		c2 = to_utf8_upper((U8*)m, tmpbuf2, &ulen2);

		/* XXX: This is kinda strange. to_utf8_XYZ returns the 
                   codepoint of the first character in the converted
                   form, yet originally we did the extra step. 
                   No tests fail by commenting this code out however
                   so Ive left it out. -- dmq.
                   
a1047 2
                */
                
d1068 1
a1068 1
	    if (!reginfo && e < s)
d1082 1
a1082 1
	    if (do_utf8 || UTF) {
d1085 2
a1086 3
		STRLEN len = 1;
		STRLEN foldlen;
		const U32 uniflags = UTF8_ALLOW_DEFAULT;
d1091 1
a1091 2
		        if (do_utf8) {
		            c = utf8n_to_uvchr((U8*)s, UTF8_MAXBYTES, &len,
d1093 21
a1113 4
                        } else {
                            c = *((U8*)s);
                        }					  
			REXEC_FBC_EXACTISH_CHECK(c == c1);
d1118 1
a1118 2
		        if (do_utf8) {
		            c = utf8n_to_uvchr((U8*)s, UTF8_MAXBYTES, &len,
a1119 3
                        } else {
                            c = *((U8*)s);
                        }
d1132 21
a1152 1
			REXEC_FBC_EXACTISH_CHECK(c == c1 || c == c2);
a1156 1
	        /* Neither pattern nor string are UTF8 */
d1158 9
a1166 1
		    REXEC_FBC_EXACTISH_SCAN(*(U8*)s == c1);
d1168 9
a1176 1
		    REXEC_FBC_EXACTISH_SCAN(*(U8*)s == c1 || *(U8*)s == c2);
d1187 3
a1189 2
		    U8 * const r = reghop3((U8*)s, -1, (U8*)PL_bostr);
		    tmp = utf8n_to_uvchr(r, UTF8SKIP(r), 0, UTF8_ALLOW_DEFAULT);
d1194 1
a1194 1
		REXEC_FBC_UTF8_SCAN(
d1196 1
a1196 1
				 (bool)swash_fetch(PL_utf8_alnum, (U8*)s, do_utf8) :
d1200 4
a1203 1
			REXEC_FBC_TRYIT;
a1204 1
		);
d1209 1
a1209 1
		REXEC_FBC_SCAN(
d1213 4
a1216 1
			REXEC_FBC_TRYIT;
a1217 1
		);
d1219 1
a1219 1
	    if ((!prog->minlen && tmp) && (!reginfo || regtry(reginfo, &s)))
d1230 3
a1232 2
		    U8 * const r = reghop3((U8*)s, -1, (U8*)PL_bostr);
		    tmp = utf8n_to_uvchr(r, UTF8SKIP(r), 0, UTF8_ALLOW_DEFAULT);
d1237 1
a1237 1
		REXEC_FBC_UTF8_SCAN(
d1239 1
a1239 1
				 (bool)swash_fetch(PL_utf8_alnum, (U8*)s, do_utf8) :
d1242 4
a1245 2
		    else REXEC_FBC_TRYIT;
		);
d1251 1
a1251 1
		REXEC_FBC_SCAN(
d1255 4
a1258 2
		    else REXEC_FBC_TRYIT;
		);
d1260 1
a1260 1
	    if ((!prog->minlen && !tmp) && (!reginfo || regtry(reginfo, &s)))
d1264 28
a1291 5
	    REXEC_FBC_CSCAN_PRELOAD(
		LOAD_UTF8_CHARCLASS_ALNUM(),
		swash_fetch(PL_utf8_alnum, (U8*)s, do_utf8),
		isALNUM(*s)
	    );
d1293 28
a1320 4
	    REXEC_FBC_CSCAN_TAINT(
		isALNUM_LC_utf8((U8*)s),
		isALNUM_LC(*s)
	    );
d1322 28
a1349 5
	    REXEC_FBC_CSCAN_PRELOAD(
		LOAD_UTF8_CHARCLASS_ALNUM(),
		!swash_fetch(PL_utf8_alnum, (U8*)s, do_utf8),
		!isALNUM(*s)
	    );
d1351 28
a1378 4
	    REXEC_FBC_CSCAN_TAINT(
		!isALNUM_LC_utf8((U8*)s),
		!isALNUM_LC(*s)
	    );
d1380 28
a1407 5
	    REXEC_FBC_CSCAN_PRELOAD(
		LOAD_UTF8_CHARCLASS_SPACE(),
		*s == ' ' || swash_fetch(PL_utf8_space,(U8*)s, do_utf8),
		isSPACE(*s)
	    );
d1409 28
a1436 4
	    REXEC_FBC_CSCAN_TAINT(
		*s == ' ' || isSPACE_LC_utf8((U8*)s),
		isSPACE_LC(*s)
	    );
d1438 28
a1465 5
	    REXEC_FBC_CSCAN_PRELOAD(
		LOAD_UTF8_CHARCLASS_SPACE(),
		!(*s == ' ' || swash_fetch(PL_utf8_space,(U8*)s, do_utf8)),
		!isSPACE(*s)
	    );
d1467 28
a1494 4
	    REXEC_FBC_CSCAN_TAINT(
		!(*s == ' ' || isSPACE_LC_utf8((U8*)s)),
		!isSPACE_LC(*s)
	    );
d1496 28
a1523 5
	    REXEC_FBC_CSCAN_PRELOAD(
		LOAD_UTF8_CHARCLASS_DIGIT(),
		swash_fetch(PL_utf8_digit,(U8*)s, do_utf8),
		isDIGIT(*s)
	    );
d1525 28
a1552 4
	    REXEC_FBC_CSCAN_TAINT(
		isDIGIT_LC_utf8((U8*)s),
		isDIGIT_LC(*s)
	    );
d1554 28
a1581 5
	    REXEC_FBC_CSCAN_PRELOAD(
		LOAD_UTF8_CHARCLASS_DIGIT(),
		!swash_fetch(PL_utf8_digit,(U8*)s, do_utf8),
		!isDIGIT(*s)
	    );
d1583 26
a1608 237
	    REXEC_FBC_CSCAN_TAINT(
		!isDIGIT_LC_utf8((U8*)s),
		!isDIGIT_LC(*s)
	    );
	case LNBREAK:
	    REXEC_FBC_CSCAN(
		is_LNBREAK_utf8(s),
		is_LNBREAK_latin1(s)
	    );
	case VERTWS:
	    REXEC_FBC_CSCAN(
		is_VERTWS_utf8(s),
		is_VERTWS_latin1(s)
	    );
	case NVERTWS:
	    REXEC_FBC_CSCAN(
		!is_VERTWS_utf8(s),
		!is_VERTWS_latin1(s)
	    );
	case HORIZWS:
	    REXEC_FBC_CSCAN(
		is_HORIZWS_utf8(s),
		is_HORIZWS_latin1(s)
	    );
	case NHORIZWS:
	    REXEC_FBC_CSCAN(
		!is_HORIZWS_utf8(s),
		!is_HORIZWS_latin1(s)
	    );	    
	case AHOCORASICKC:
	case AHOCORASICK: 
	    {
	        DECL_TRIE_TYPE(c);
                /* what trie are we using right now */
        	reg_ac_data *aho
        	    = (reg_ac_data*)progi->data->data[ ARG( c ) ];
        	reg_trie_data *trie
		    = (reg_trie_data*)progi->data->data[ aho->trie ];
		HV *widecharmap = (HV*) progi->data->data[ aho->trie + 1 ];

		const char *last_start = strend - trie->minlen;
#ifdef DEBUGGING
		const char *real_start = s;
#endif
		STRLEN maxlen = trie->maxlen;
		SV *sv_points;
		U8 **points; /* map of where we were in the input string
		                when reading a given char. For ASCII this
		                is unnecessary overhead as the relationship
		                is always 1:1, but for Unicode, especially
		                case folded Unicode this is not true. */
		U8 foldbuf[ UTF8_MAXBYTES_CASE + 1 ];
		U8 *bitmap=NULL;


                GET_RE_DEBUG_FLAGS_DECL;

                /* We can't just allocate points here. We need to wrap it in
                 * an SV so it gets freed properly if there is a croak while
                 * running the match */
                ENTER;
	        SAVETMPS;
                sv_points=newSV(maxlen * sizeof(U8 *));
                SvCUR_set(sv_points,
                    maxlen * sizeof(U8 *));
                SvPOK_on(sv_points);
                sv_2mortal(sv_points);
                points=(U8**)SvPV_nolen(sv_points );
                if ( trie_type != trie_utf8_fold 
                     && (trie->bitmap || OP(c)==AHOCORASICKC) ) 
                {
                    if (trie->bitmap) 
                        bitmap=(U8*)trie->bitmap;
                    else
                        bitmap=(U8*)ANYOF_BITMAP(c);
                }
                /* this is the Aho-Corasick algorithm modified a touch
                   to include special handling for long "unknown char" 
                   sequences. The basic idea being that we use AC as long
                   as we are dealing with a possible matching char, when
                   we encounter an unknown char (and we have not encountered
                   an accepting state) we scan forward until we find a legal 
                   starting char. 
                   AC matching is basically that of trie matching, except
                   that when we encounter a failing transition, we fall back
                   to the current states "fail state", and try the current char 
                   again, a process we repeat until we reach the root state, 
                   state 1, or a legal transition. If we fail on the root state 
                   then we can either terminate if we have reached an accepting 
                   state previously, or restart the entire process from the beginning 
                   if we have not.

                 */
                while (s <= last_start) {
                    const U32 uniflags = UTF8_ALLOW_DEFAULT;
                    U8 *uc = (U8*)s;
                    U16 charid = 0;
                    U32 base = 1;
                    U32 state = 1;
                    UV uvc = 0;
                    STRLEN len = 0;
                    STRLEN foldlen = 0;
                    U8 *uscan = (U8*)NULL;
                    U8 *leftmost = NULL;
#ifdef DEBUGGING                    
                    U32 accepted_word= 0;
#endif
                    U32 pointpos = 0;

                    while ( state && uc <= (U8*)strend ) {
                        int failed=0;
                        U32 word = aho->states[ state ].wordnum;

                        if( state==1 ) {
                            if ( bitmap ) {
                                DEBUG_TRIE_EXECUTE_r(
                                    if ( uc <= (U8*)last_start && !BITMAP_TEST(bitmap,*uc) ) {
                                        dump_exec_pos( (char *)uc, c, strend, real_start, 
                                            (char *)uc, do_utf8 );
                                        PerlIO_printf( Perl_debug_log,
                                            " Scanning for legal start char...\n");
                                    }
                                );            
                                while ( uc <= (U8*)last_start  && !BITMAP_TEST(bitmap,*uc) ) {
                                    uc++;
                                }
                                s= (char *)uc;
                            }
                            if (uc >(U8*)last_start) break;
                        }
                                            
                        if ( word ) {
                            U8 *lpos= points[ (pointpos - trie->wordlen[word-1] ) % maxlen ];
                            if (!leftmost || lpos < leftmost) {
                                DEBUG_r(accepted_word=word);
                                leftmost= lpos;
                            }
                            if (base==0) break;
                            
                        }
                        points[pointpos++ % maxlen]= uc;
			REXEC_TRIE_READ_CHAR(trie_type, trie, widecharmap, uc,
					     uscan, len, uvc, charid, foldlen,
					     foldbuf, uniflags);
                        DEBUG_TRIE_EXECUTE_r({
                            dump_exec_pos( (char *)uc, c, strend, real_start, 
                                s,   do_utf8 );
                            PerlIO_printf(Perl_debug_log,
                                " Charid:%3u CP:%4"UVxf" ",
                                 charid, uvc);
                        });

                        do {
#ifdef DEBUGGING
                            word = aho->states[ state ].wordnum;
#endif
                            base = aho->states[ state ].trans.base;

                            DEBUG_TRIE_EXECUTE_r({
                                if (failed) 
                                    dump_exec_pos( (char *)uc, c, strend, real_start, 
                                        s,   do_utf8 );
                                PerlIO_printf( Perl_debug_log,
                                    "%sState: %4"UVxf", word=%"UVxf,
                                    failed ? " Fail transition to " : "",
                                    (UV)state, (UV)word);
                            });
                            if ( base ) {
                                U32 tmp;
                                if (charid &&
                                     (base + charid > trie->uniquecharcount )
                                     && (base + charid - 1 - trie->uniquecharcount
                                            < trie->lasttrans)
                                     && trie->trans[base + charid - 1 -
                                            trie->uniquecharcount].check == state
                                     && (tmp=trie->trans[base + charid - 1 -
                                        trie->uniquecharcount ].next))
                                {
                                    DEBUG_TRIE_EXECUTE_r(
                                        PerlIO_printf( Perl_debug_log," - legal\n"));
                                    state = tmp;
                                    break;
                                }
                                else {
                                    DEBUG_TRIE_EXECUTE_r(
                                        PerlIO_printf( Perl_debug_log," - fail\n"));
                                    failed = 1;
                                    state = aho->fail[state];
                                }
                            }
                            else {
                                /* we must be accepting here */
                                DEBUG_TRIE_EXECUTE_r(
                                        PerlIO_printf( Perl_debug_log," - accepting\n"));
                                failed = 1;
                                break;
                            }
                        } while(state);
                        uc += len;
                        if (failed) {
                            if (leftmost)
                                break;
                            if (!state) state = 1;
                        }
                    }
                    if ( aho->states[ state ].wordnum ) {
                        U8 *lpos = points[ (pointpos - trie->wordlen[aho->states[ state ].wordnum-1]) % maxlen ];
                        if (!leftmost || lpos < leftmost) {
                            DEBUG_r(accepted_word=aho->states[ state ].wordnum);
                            leftmost = lpos;
                        }
                    }
                    if (leftmost) {
                        s = (char*)leftmost;
                        DEBUG_TRIE_EXECUTE_r({
                            PerlIO_printf( 
                                Perl_debug_log,"Matches word #%"UVxf" at position %"IVdf". Trying full pattern...\n",
                                (UV)accepted_word, (IV)(s - real_start)
                            );
                        });
                        if (!reginfo || regtry(reginfo, &s)) {
                            FREETMPS;
		            LEAVE;
                            goto got_it;
                        }
                        s = HOPc(s,1);
                        DEBUG_TRIE_EXECUTE_r({
                            PerlIO_printf( Perl_debug_log,"Pattern failed. Looking for new start point...\n");
                        });
                    } else {
                        DEBUG_TRIE_EXECUTE_r(
                            PerlIO_printf( Perl_debug_log,"No match.\n"));
                        break;
                    }
                }
                FREETMPS;
                LEAVE;
a1619 20
static void 
S_swap_match_buff (pTHX_ regexp *prog) {
    regexp_paren_pair *t;

    if (!prog->swap) {
    /* We have to be careful. If the previous successful match
       was from this regex we don't want a subsequent paritally
       successful match to clobber the old results. 
       So when we detect this possibility we add a swap buffer
       to the re, and switch the buffer each match. If we fail
       we switch it back, otherwise we leave it swapped.
    */
        Newxz(prog->swap, (prog->nparens + 1), regexp_paren_pair);
    }
    t = prog->swap;
    prog->swap = prog->offs;
    prog->offs = t;
}    


d1624 1
a1624 1
Perl_regexec_flags(pTHX_ REGEXP * const prog, char *stringarg, register char *strend,
d1629 1
a1629 3
/* data: May be used for some additional optimizations. 
         Currently its only used, with a U32 cast, for transmitting 
         the ganch offset when doing a /g match. This will change */
d1632 1
a1632 2
    dVAR;
    /*register*/ char *s;
d1634 1
a1634 1
    /*register*/ char *startpos = stringarg;
d1639 9
a1647 6
    char *scream_olds = NULL;
    const bool do_utf8 = (bool)DO_UTF8(sv);
    I32 multiline;
    RXi_GET_DECL(prog,progi);
    regmatch_info reginfo;  /* create some info to pass to regtry etc */
    bool swap_on_fail = 0;
d1649 1
a1649 1
    GET_RE_DEBUG_FLAGS_DECL;
d1651 4
a1654 1
    PERL_UNUSED_ARG(data);
a1661 9
    multiline = prog->extflags & RXf_PMf_MULTILINE;
    reginfo.prog = prog;

    RX_MATCH_UTF8_set(prog, do_utf8);
    DEBUG_EXECUTE_r( 
        debug_start_match(prog, do_utf8, startpos, strend, 
        "Matching");
    );

d1663 2
a1664 3
    
    if (strend - startpos < (minlen+(prog->check_offset_min<0?prog->check_offset_min:0))) {
        DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
a1668 1
    
d1670 1
a1670 1
    if (UCHARAT(progi->program) != REG_MAGIC) {
d1678 1
a1678 1
    if (prog->extflags & RXf_UTF8)
d1682 1
a1682 1
    reginfo.bol = startpos; /* XXX not used ??? */
d1684 1
a1684 1
    reginfo.sv = sv;
d1690 4
a1693 1
    reginfo.till = startpos+minend;
d1698 1
a1698 1
    if (prog->extflags & RXf_GPOS_SEEN) { /* Need to set reginfo->ganch */
d1702 1
a1702 1
	    reginfo.ganch = startpos + prog->gofs;
d1707 3
a1709 3
	    reginfo.ganch = strbeg + mg->mg_len;	/* Defined pos() */
	    if (prog->extflags & RXf_ANCH_GPOS) {
	        if (s > reginfo.ganch)
d1711 1
a1711 1
		s = reginfo.ganch - prog->gofs;
d1714 2
a1715 4
	else if (data) {
	    reginfo.ganch = strbeg + PTR2UV(data);
	} else				/* pos() not defined */
	    reginfo.ganch = strbeg;
d1717 2
a1718 6
    if (PL_curpm && (PM_GETRE(PL_curpm) == prog)) {
        swap_on_fail = 1;
        swap_match_buff(prog); /* do we need a save destructor here for
                                  eval dies? */
    }
    if (!(flags & REXEC_CHECKED) && (prog->check_substr != NULL || prog->check_utf8 != NULL)) {
d1725 1
a1725 1
	    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "Not present...\n"));
d1730 23
a1752 1

d1756 2
a1757 2
    if (prog->extflags & (RXf_ANCH & ~RXf_ANCH_GPOS)) {
	if (s == startpos && regtry(&reginfo, &startpos))
d1759 2
a1760 2
	else if (multiline || (prog->intflags & PREGf_IMPLICIT)
		 || (prog->extflags & RXf_ANCH_MBOL)) /* XXXX SBOL? */
d1772 1
a1772 1
		    if (regtry(&reginfo, &s))
d1775 1
a1775 1
		    if (s > end)
d1777 1
a1777 1
		    if (prog->extflags & RXf_USE_INTUIT) {
d1790 1
a1790 1
			if (regtry(&reginfo, &s))
d1797 2
a1798 7
    } else if (RXf_GPOS_CHECK == (prog->extflags & RXf_GPOS_CHECK)) 
    {
        /* the warning about reginfo.ganch being used without intialization
           is bogus -- we set it above, when prog->extflags & RXf_GPOS_SEEN 
           and we only enter this block when the same bit is set. */
        char *tmp_s = reginfo.ganch - prog->gofs;
	if (regtry(&reginfo, &tmp_s))
d1804 1
a1804 1
    if ((prog->anchored_substr || prog->anchored_utf8) && prog->intflags & PREGf_SKIP) {
d1816 1
a1816 1
	    REXEC_FBC_SCAN(
d1818 2
a1819 2
		    DEBUG_EXECUTE_r( did_match = 1 );
		    if (regtry(&reginfo, &s)) goto got_it;
d1824 2
a1825 1
	    );
d1828 1
a1828 1
	    REXEC_FBC_SCAN(
d1830 2
a1831 2
		    DEBUG_EXECUTE_r( did_match = 1 );
		    if (regtry(&reginfo, &s)) goto got_it;
d1836 2
a1837 1
	    );
d1839 1
a1839 1
	DEBUG_EXECUTE_r(if (!did_match)
d1844 3
a1846 3
    else if (prog->anchored_substr != NULL
	      || prog->anchored_utf8 != NULL
	      || ((prog->float_substr != NULL || prog->float_utf8 != NULL)
a1867 2
	
	    
d1872 4
a1875 7
        if (back_min<0) {
	    last = strend;
	} else {
            last = HOP3c(strend,	/* Cannot start after this */
        	  -(I32)(CHR_SVLEN(must)
        		 - (SvTAIL(must) != 0) + back_min), strbeg);
        }
d1888 1
a1888 1
		 ? (s = screaminstr(sv, must, HOP3c(s, back_min, (back_min<0 ? strbeg : strend)) - strbeg,
d1890 1
a1890 1
		 : (s = fbm_instr((unsigned char*)HOP3(s, back_min, (back_min<0 ? strbeg : strend)),
d1892 1
a1892 1
				  multiline ? FBMrf_MULTILINE : 0))) ) {
d1896 1
a1896 1
	    DEBUG_EXECUTE_r( did_match = 1 );
d1902 1
a1902 1
		char * const t = (last1 >= PL_bostr) ? HOPc(last1, 1) : last1 + 1;
d1905 1
a1905 1
		s = t;
d1909 1
a1909 1
		    if (regtry(&reginfo, &s))
d1916 1
a1916 1
		    if (regtry(&reginfo, &s))
d1922 3
a1924 4
	DEBUG_EXECUTE_r(if (!did_match) {
            RE_PV_QUOTED_DECL(quoted, do_utf8, PERL_DEBUG_PAD_ZERO(0), 
                SvPVX_const(must), RE_SV_DUMPLEN(must), 30);
            PerlIO_printf(Perl_debug_log, "Did not find %s substr %s%s...\n",
d1927 5
a1931 2
                quoted, RE_SV_TAIL(must));
        });		    
d1934 1
a1934 1
    else if ( (c = progi->regstclass) ) {
d1936 1
a1936 1
	    const OPCODE op = OP(progi->regstclass);
d1938 1
a1938 1
	    if (PL_regkind[op] != EXACT && op != CANY && PL_regkind[op] != TRIE)
d1941 20
a1960 11
	DEBUG_EXECUTE_r({
	    SV * const prop = sv_newmortal();
	    regprop(prog, prop, c);
	    {
		RE_PV_QUOTED_DECL(quoted,do_utf8,PERL_DEBUG_PAD_ZERO(1),
		    s,strend-s,60);
		PerlIO_printf(Perl_debug_log,
		    "Matching stclass %.*s against %s (%d chars)\n",
		    (int)SvCUR(prop), SvPVX_const(prop),
		     quoted, (int)(strend - s));
	    }
d1962 1
a1962 1
        if (find_byclass(prog, c, s, strend, &reginfo))
d1964 1
a1964 1
	DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "Contradicts stclass... [regexec_flags]\n"));
d1968 1
a1968 1
	if (prog->float_substr != NULL || prog->float_utf8 != NULL) {
d1993 1
a1993 1
		    else if (!multiline)
d1995 1
a1995 1
			    ? strend - len : NULL;
d2007 3
a2009 4
		DEBUG_EXECUTE_r(
		    PerlIO_printf(Perl_debug_log,
			"%sCan't trim the tail, match fails (should not happen)%s\n",
	                PL_colors[4], PL_colors[5]));
d2020 1
a2020 1
		if (regtry(&reginfo, &s))
d2029 1
a2029 1
		if (regtry(&reginfo, &s))
d2041 8
a2048 4
    if (PL_reg_eval_set)
	restore_pos(aTHX_ prog);
    if (prog->paren_names) 
        (void)hv_iterinit(prog->paren_names);
d2052 4
a2055 1
	RX_MATCH_COPY_FREE(prog);
d2057 4
a2060 19
	    const I32 i = PL_regeol - startpos + (stringarg - strbeg);
#ifdef PERL_OLD_COPY_ON_WRITE
	    if ((SvIsCOW(sv)
		 || (SvFLAGS(sv) & CAN_COW_MASK) == CAN_COW_FLAGS)) {
		if (DEBUG_C_TEST) {
		    PerlIO_printf(Perl_debug_log,
				  "Copy on write: regexp capture, type %d\n",
				  (int) SvTYPE(sv));
		}
		prog->saved_copy = sv_setsv_cow(prog->saved_copy, sv);
		prog->subbeg = (char *)SvPVX_const(prog->saved_copy);
		assert (SvPOKp(prog->saved_copy));
	    } else
#endif
	    {
		RX_MATCH_COPIED_on(prog);
		s = savepvn(strbeg, i);
		prog->subbeg = s;
	    }
d2062 1
d2073 2
a2074 2
    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "%sMatch failed%s\n",
			  PL_colors[4], PL_colors[5]));
d2076 1
a2076 5
	restore_pos(aTHX_ prog);
    if (swap_on_fail) 
        /* we failed :-( roll it back */
        swap_match_buff(prog);
    
a2079 1

d2084 1
a2084 1
S_regtry(pTHX_ regmatch_info *reginfo, char **startpos)
d2086 3
a2088 1
    dVAR;
a2089 4
    regexp *prog = reginfo->prog;
    RXi_GET_DECL(prog,progi);
    GET_RE_DEBUG_FLAGS_DECL;
    reginfo->cutpoint=NULL;
d2091 4
a2094 1
    if ((prog->extflags & RXf_EVAL_SEEN) && !PL_reg_eval_set) {
d2098 1
a2098 1
	DEBUG_EXECUTE_r(DEBUG_s(
d2102 1
a2102 1
	SAVESTACK_CXPOS();
d2110 1
a2110 1
	if (reginfo->sv) {
d2112 4
a2115 3
	    if (reginfo->sv != DEFSV) {
		SAVE_DEFSV;
		DEFSV = reginfo->sv;
d2118 2
a2119 2
	    if (!(SvTYPE(reginfo->sv) >= SVt_PVMG && SvMAGIC(reginfo->sv)
		  && (mg = mg_find(reginfo->sv, PERL_MAGIC_regex_global)))) {
d2121 3
a2123 6
#ifdef PERL_OLD_COPY_ON_WRITE
		if (SvIsCOW(reginfo->sv))
		    sv_force_normal_flags(reginfo->sv, 0);
#endif
		mg = sv_magicext(reginfo->sv, NULL, PERL_MAGIC_regex_global,
				 &PL_vtbl_mglob, NULL, 0);
d2128 1
a2128 1
	    SAVEDESTRUCTOR_X(restore_pos, prog);
d2134 1
a2134 1
		SV* const repointer = newSViv(0);
a2151 3
#ifdef PERL_OLD_COPY_ON_WRITE
	    PL_nrs = prog->saved_copy;
#endif
d2155 1
a2155 1
	    PL_reg_oldsaved = NULL;
d2159 4
a2162 3
    DEBUG_EXECUTE_r(PL_reg_starttry = *startpos);
    prog->offs[0].start = *startpos - PL_bostr;
    PL_reginput = *startpos;
d2168 1
a2168 1
    PL_regoffs = prog->offs;
d2184 4
a2187 3
     * (op/regexp, op/pat, op/split), but that code is needed otherwise
     * this erroneously leaves $1 defined: "1" =~ /^(?:(\d)x)?\d$/
     * Meanwhile, this code *is* needed for the
d2190 1
a2190 1
     * --jhi updated by dapm */
d2192 2
a2194 2
	regexp_paren_pair *pp = PL_regoffs;
	register I32 i;
d2196 2
a2197 3
	    ++pp;
	    pp->start = -1;
	    pp->end = -1;
d2202 2
a2203 2
    if (regmatch(reginfo, progi->program + 1)) {
	PL_regoffs[0].end = PL_reginput - PL_bostr;
a2205 2
    if (reginfo->cutpoint)
        *startpos= reginfo->cutpoint;
d2210 2
d2213 1
a2213 3
#define sayYES goto yes
#define sayNO goto no
#define sayNO_SILENT goto no_silent
d2215 5
a2219 12
/* we dont use STMT_START/END here because it leads to 
   "unreachable code" warnings, which are bogus, but distracting. */
#define CACHEsayNO \
    if (ST.cache_mask) \
       PL_reg_poscache[ST.cache_offset] |= ST.cache_mask; \
    sayNO

/* this is used to determine how far from the left messages like
   'failed...' are printed. It should be set such that messages 
   are inline with the regop output that created them.
*/
#define REPORT_CODE_OFF 32
d2221 10
a2230 17

/* Make sure there is a test for this +1 options in re_tests */
#define TRIE_INITAL_ACCEPT_BUFFLEN 4;

#define CHRTEST_UNINIT -1001 /* c1/c2 haven't been calculated yet */
#define CHRTEST_VOID   -1000 /* the c1/c2 "next char" test should be skipped */

#define SLAB_FIRST(s) (&(s)->states[0])
#define SLAB_LAST(s)  (&(s)->states[PERL_REGMATCH_SLAB_SLOTS-1])

/* grab a new slab and return the first slot in it */

STATIC regmatch_state *
S_push_slab(pTHX)
{
#if PERL_VERSION < 9 && !defined(PERL_CORE)
    dMY_CXT;
d2232 1
a2232 10
    regmatch_slab *s = PL_regmatch_slab->next;
    if (!s) {
	Newx(s, 1, regmatch_slab);
	s->prev = PL_regmatch_slab;
	s->next = NULL;
	PL_regmatch_slab->next = s;
    }
    PL_regmatch_slab = s;
    return SLAB_FIRST(s);
}
d2234 5
d2240 44
a2283 14
/* push a new state then goto it */

#define PUSH_STATE_GOTO(state, node) \
    scan = node; \
    st->resume_state = state; \
    goto push_state;

/* push a new state with success backtracking, then goto it */

#define PUSH_YES_STATE_GOTO(state, node) \
    scan = node; \
    st->resume_state = state; \
    goto push_yes_state;

d2285 1
d2288 12
a2299 248

regmatch() - main matching routine

This is basically one big switch statement in a loop. We execute an op,
set 'next' to point the next op, and continue. If we come to a point which
we may need to backtrack to on failure such as (A|B|C), we push a
backtrack state onto the backtrack stack. On failure, we pop the top
state, and re-enter the loop at the state indicated. If there are no more
states to pop, we return failure.

Sometimes we also need to backtrack on success; for example /A+/, where
after successfully matching one A, we need to go back and try to
match another one; similarly for lookahead assertions: if the assertion
completes successfully, we backtrack to the state just before the assertion
and then carry on.  In these cases, the pushed state is marked as
'backtrack on success too'. This marking is in fact done by a chain of
pointers, each pointing to the previous 'yes' state. On success, we pop to
the nearest yes state, discarding any intermediate failure-only states.
Sometimes a yes state is pushed just to force some cleanup code to be
called at the end of a successful match or submatch; e.g. (??{$re}) uses
it to free the inner regex.

Note that failure backtracking rewinds the cursor position, while
success backtracking leaves it alone.

A pattern is complete when the END op is executed, while a subpattern
such as (?=foo) is complete when the SUCCESS op is executed. Both of these
ops trigger the "pop to last yes state if any, otherwise return true"
behaviour.

A common convention in this function is to use A and B to refer to the two
subpatterns (or to the first nodes thereof) in patterns like /A*B/: so A is
the subpattern to be matched possibly multiple times, while B is the entire
rest of the pattern. Variable and state names reflect this convention.

The states in the main switch are the union of ops and failure/success of
substates associated with with that op.  For example, IFMATCH is the op
that does lookahead assertions /(?=A)B/ and so the IFMATCH state means
'execute IFMATCH'; while IFMATCH_A is a state saying that we have just
successfully matched A and IFMATCH_A_fail is a state saying that we have
just failed to match A. Resume states always come in pairs. The backtrack
state we push is marked as 'IFMATCH_A', but when that is popped, we resume
at IFMATCH_A or IFMATCH_A_fail, depending on whether we are backtracking
on success or failure.

The struct that holds a backtracking state is actually a big union, with
one variant for each major type of op. The variable st points to the
top-most backtrack struct. To make the code clearer, within each
block of code we #define ST to alias the relevant union.

Here's a concrete example of a (vastly oversimplified) IFMATCH
implementation:

    switch (state) {
    ....

#define ST st->u.ifmatch

    case IFMATCH: // we are executing the IFMATCH op, (?=A)B
	ST.foo = ...; // some state we wish to save
	...
	// push a yes backtrack state with a resume value of
	// IFMATCH_A/IFMATCH_A_fail, then continue execution at the
	// first node of A:
	PUSH_YES_STATE_GOTO(IFMATCH_A, A);
	// NOTREACHED

    case IFMATCH_A: // we have successfully executed A; now continue with B
	next = B;
	bar = ST.foo; // do something with the preserved value
	break;

    case IFMATCH_A_fail: // A failed, so the assertion failed
	...;   // do some housekeeping, then ...
	sayNO; // propagate the failure

#undef ST

    ...
    }

For any old-timers reading this who are familiar with the old recursive
approach, the code above is equivalent to:

    case IFMATCH: // we are executing the IFMATCH op, (?=A)B
    {
	int foo = ...
	...
	if (regmatch(A)) {
	    next = B;
	    bar = foo;
	    break;
	}
	...;   // do some housekeeping, then ...
	sayNO; // propagate the failure
    }

The topmost backtrack state, pointed to by st, is usually free. If you
want to claim it, populate any ST.foo fields in it with values you wish to
save, then do one of

	PUSH_STATE_GOTO(resume_state, node);
	PUSH_YES_STATE_GOTO(resume_state, node);

which sets that backtrack state's resume value to 'resume_state', pushes a
new free entry to the top of the backtrack stack, then goes to 'node'.
On backtracking, the free slot is popped, and the saved state becomes the
new free state. An ST.foo field in this new top state can be temporarily
accessed to retrieve values, but once the main loop is re-entered, it
becomes available for reuse.

Note that the depth of the backtrack stack constantly increases during the
left-to-right execution of the pattern, rather than going up and down with
the pattern nesting. For example the stack is at its maximum at Z at the
end of the pattern, rather than at X in the following:

    /(((X)+)+)+....(Y)+....Z/

The only exceptions to this are lookahead/behind assertions and the cut,
(?>A), which pop all the backtrack states associated with A before
continuing.
 
Bascktrack state structs are allocated in slabs of about 4K in size.
PL_regmatch_state and st always point to the currently active state,
and PL_regmatch_slab points to the slab currently containing
PL_regmatch_state.  The first time regmatch() is called, the first slab is
allocated, and is never freed until interpreter destruction. When the slab
is full, a new one is allocated and chained to the end. At exit from
regmatch(), slabs allocated since entry are freed.

*/
 

#define DEBUG_STATE_pp(pp)				    \
    DEBUG_STATE_r({					    \
	DUMP_EXEC_POS(locinput, scan, do_utf8);		    \
	PerlIO_printf(Perl_debug_log,			    \
	    "    %*s"pp" %s%s%s%s%s\n",			    \
	    depth*2, "",				    \
	    PL_reg_name[st->resume_state],                     \
	    ((st==yes_state||st==mark_state) ? "[" : ""),   \
	    ((st==yes_state) ? "Y" : ""),                   \
	    ((st==mark_state) ? "M" : ""),                  \
	    ((st==yes_state||st==mark_state) ? "]" : "")    \
	);                                                  \
    });


#define REG_NODE_NUM(x) ((x) ? (int)((x)-prog) : -1)

#ifdef DEBUGGING

STATIC void
S_debug_start_match(pTHX_ const regexp *prog, const bool do_utf8, 
    const char *start, const char *end, const char *blurb)
{
    const bool utf8_pat= prog->extflags & RXf_UTF8 ? 1 : 0;
    if (!PL_colorset)   
            reginitcolors();    
    {
        RE_PV_QUOTED_DECL(s0, utf8_pat, PERL_DEBUG_PAD_ZERO(0), 
            prog->precomp, prog->prelen, 60);   
        
        RE_PV_QUOTED_DECL(s1, do_utf8, PERL_DEBUG_PAD_ZERO(1), 
            start, end - start, 60); 
        
        PerlIO_printf(Perl_debug_log, 
            "%s%s REx%s %s against %s\n", 
		       PL_colors[4], blurb, PL_colors[5], s0, s1); 
        
        if (do_utf8||utf8_pat) 
            PerlIO_printf(Perl_debug_log, "UTF-8 %s%s%s...\n",
                utf8_pat ? "pattern" : "",
                utf8_pat && do_utf8 ? " and " : "",
                do_utf8 ? "string" : ""
            ); 
    }
}

STATIC void
S_dump_exec_pos(pTHX_ const char *locinput, 
                      const regnode *scan, 
                      const char *loc_regeol, 
                      const char *loc_bostr, 
                      const char *loc_reg_starttry,
                      const bool do_utf8)
{
    const int docolor = *PL_colors[0] || *PL_colors[2] || *PL_colors[4];
    const int taill = (docolor ? 10 : 7); /* 3 chars for "> <" */
    int l = (loc_regeol - locinput) > taill ? taill : (loc_regeol - locinput);
    /* The part of the string before starttry has one color
       (pref0_len chars), between starttry and current
       position another one (pref_len - pref0_len chars),
       after the current position the third one.
       We assume that pref0_len <= pref_len, otherwise we
       decrease pref0_len.  */
    int pref_len = (locinput - loc_bostr) > (5 + taill) - l
	? (5 + taill) - l : locinput - loc_bostr;
    int pref0_len;

    while (do_utf8 && UTF8_IS_CONTINUATION(*(U8*)(locinput - pref_len)))
	pref_len++;
    pref0_len = pref_len  - (locinput - loc_reg_starttry);
    if (l + pref_len < (5 + taill) && l < loc_regeol - locinput)
	l = ( loc_regeol - locinput > (5 + taill) - pref_len
	      ? (5 + taill) - pref_len : loc_regeol - locinput);
    while (do_utf8 && UTF8_IS_CONTINUATION(*(U8*)(locinput + l)))
	l--;
    if (pref0_len < 0)
	pref0_len = 0;
    if (pref0_len > pref_len)
	pref0_len = pref_len;
    {
	const int is_uni = (do_utf8 && OP(scan) != CANY) ? 1 : 0;

	RE_PV_COLOR_DECL(s0,len0,is_uni,PERL_DEBUG_PAD(0),
	    (locinput - pref_len),pref0_len, 60, 4, 5);
	
	RE_PV_COLOR_DECL(s1,len1,is_uni,PERL_DEBUG_PAD(1),
		    (locinput - pref_len + pref0_len),
		    pref_len - pref0_len, 60, 2, 3);
	
	RE_PV_COLOR_DECL(s2,len2,is_uni,PERL_DEBUG_PAD(2),
		    locinput, loc_regeol - locinput, 10, 0, 1);

	const STRLEN tlen=len0+len1+len2;
	PerlIO_printf(Perl_debug_log,
		    "%4"IVdf" <%.*s%.*s%s%.*s>%*s|",
		    (IV)(locinput - loc_bostr),
		    len0, s0,
		    len1, s1,
		    (docolor ? "" : "> <"),
		    len2, s2,
		    (int)(tlen > 19 ? 0 :  19 - tlen),
		    "");
    }
}

#endif

/* reg_check_named_buff_matched()
 * Checks to see if a named buffer has matched. The data array of 
 * buffer numbers corresponding to the buffer is expected to reside
 * in the regexp->data->data array in the slot stored in the ARG() of
 * node involved. Note that this routine doesn't actually care about the
 * name, that information is not preserved from compilation to execution.
 * Returns the index of the leftmost defined buffer with the given name
 * or 0 if non of the buffers matched.
a2300 40
STATIC I32
S_reg_check_named_buff_matched(pTHX_ const regexp *rex, const regnode *scan) {
    I32 n;
    RXi_GET_DECL(rex,rexi);
    SV *sv_dat=(SV*)rexi->data->data[ ARG( scan ) ];
    I32 *nums=(I32*)SvPVX(sv_dat);
    for ( n=0; n<SvIVX(sv_dat); n++ ) {
        if ((I32)*PL_reglastparen >= nums[n] &&
            PL_regoffs[nums[n]].end != -1)
        {
            return nums[n];
        }
    }
    return 0;
}


/* free all slabs above current one  - called during LEAVE_SCOPE */

STATIC void
S_clear_backtrack_stack(pTHX_ void *p)
{
    regmatch_slab *s = PL_regmatch_slab->next;
    PERL_UNUSED_ARG(p);

    if (!s)
	return;
    PL_regmatch_slab->next = NULL;
    while (s) {
	regmatch_slab * const osl = s;
	s = s->next;
	Safefree(osl);
    }
}


#define SETREX(Re1,Re2) \
    if (PL_reg_eval_set) PM_SETRE((PL_reg_curpm), (Re2)); \
    Re1 = (Re2)

d2302 1
a2302 1
S_regmatch(pTHX_ regmatch_info *reginfo, regnode *prog)
d2304 14
a2317 2
#if PERL_VERSION < 9 && !defined(PERL_CORE)
    dMY_CXT;
a2318 1
    dVAR;
d2320 6
a2325 61
    const U32 uniflags = UTF8_ALLOW_DEFAULT;

    regexp *rex = reginfo->prog;
    RXi_GET_DECL(rex,rexi);
    
    I32	oldsave;

    /* the current state. This is a cached copy of PL_regmatch_state */
    register regmatch_state *st;

    /* cache heavy used fields of st in registers */
    register regnode *scan;
    register regnode *next;
    register U32 n = 0;	/* general value; init to avoid compiler warning */
    register I32 ln = 0; /* len or last;  init to avoid compiler warning */
    register char *locinput = PL_reginput;
    register I32 nextchr;   /* is always set to UCHARAT(locinput) */

    bool result = 0;	    /* return value of S_regmatch */
    int depth = 0;	    /* depth of backtrack stack */
    U32 nochange_depth = 0; /* depth of GOSUB recursion with nochange */
    const U32 max_nochange_depth =
        (3 * rex->nparens > MAX_RECURSE_EVAL_NOCHANGE_DEPTH) ?
        3 * rex->nparens : MAX_RECURSE_EVAL_NOCHANGE_DEPTH;
            
    regmatch_state *yes_state = NULL; /* state to pop to on success of
							    subpattern */
    /* mark_state piggy backs on the yes_state logic so that when we unwind 
       the stack on success we can update the mark_state as we go */
    regmatch_state *mark_state = NULL; /* last mark state we have seen */
    
    regmatch_state *cur_eval = NULL; /* most recent EVAL_AB state */
    struct regmatch_state  *cur_curlyx = NULL; /* most recent curlyx */
    U32 state_num;
    bool no_final = 0;      /* prevent failure from backtracking? */
    bool do_cutgroup = 0;   /* no_final only until next branch/trie entry */
    char *startpoint = PL_reginput;
    SV *popmark = NULL;     /* are we looking for a mark? */
    SV *sv_commit = NULL;   /* last mark name seen in failure */
    SV *sv_yes_mark = NULL; /* last mark name we have seen 
                               during a successfull match */
    U32 lastopen = 0;       /* last open we saw */
    bool has_cutgroup = RX_HAS_CUTGROUP(rex) ? 1 : 0;   

    SV* const oreplsv = GvSV(PL_replgv);
               
    
    /* these three flags are set by various ops to signal information to
     * the very next op. They have a useful lifetime of exactly one loop
     * iteration, and are not preserved or restored by state pushes/pops
     */
    bool sw = 0;	    /* the condition value in (?(cond)a|b) */
    bool minmod = 0;	    /* the next "{n,m}" is a "{n,m}?" */
    int logical = 0;	    /* the following EVAL is:
				0: (?{...})
				1: (?(?{...})X|Y)
				2: (??{...})
			       or the following IFMATCH/UNLESSM is:
			        false: plain (?=foo)
				true:  used as a condition: (?(?=foo))
			    */
d2328 1
a2328 1
    GET_RE_DEBUG_FLAGS_DECL;
a2330 21
    DEBUG_OPTIMISE_r( DEBUG_EXECUTE_r({
	    PerlIO_printf(Perl_debug_log,"regmatch start\n");
    }));
    /* on first ever call to regmatch, allocate first slab */
    if (!PL_regmatch_slab) {
	Newx(PL_regmatch_slab, 1, regmatch_slab);
	PL_regmatch_slab->prev = NULL;
	PL_regmatch_slab->next = NULL;
	PL_regmatch_state = SLAB_FIRST(PL_regmatch_slab);
    }

    oldsave = PL_savestack_ix;
    SAVEDESTRUCTOR_X(S_clear_backtrack_stack, NULL);
    SAVEVPTR(PL_regmatch_slab);
    SAVEVPTR(PL_regmatch_state);

    /* grab next free state slot */
    st = ++PL_regmatch_state;
    if (st >  SLAB_LAST(PL_regmatch_slab))
	st = PL_regmatch_state = S_push_slab(aTHX);

d2336 63
a2398 12
        DEBUG_EXECUTE_r( {
	    SV * const prop = sv_newmortal();
	    regnode *rnext=regnext(scan);
	    DUMP_EXEC_POS( locinput, scan, do_utf8 );
	    regprop(rex, prop, scan);
            
	    PerlIO_printf(Perl_debug_log,
		    "%3"IVdf":%*s%s(%"IVdf")\n",
		    (IV)(scan - rexi->program), depth*2, "",
		    SvPVX_const(prop),
		    (PL_regkind[OP(scan)] == END || !rnext) ? 
		        0 : (IV)(rnext - rexi->program));
a2403 1
	state_num = OP(scan);
d2405 1
a2405 2
      reenter_switch:
	switch (state_num) {
d2407 2
a2408 1
	    if (locinput == PL_bostr)
d2410 1
a2410 1
		/* reginfo->till = reginfo->bol; */
d2426 1
a2426 1
	    if (locinput == reginfo->ganch)
a2428 13

	case KEEPS:
	    /* update the startpoint */
	    st->u.keeper.val = PL_regoffs[0].start;
	    PL_reginput = locinput;
	    PL_regoffs[0].start = locinput - PL_bostr;
	    PUSH_STATE_GOTO(KEEPS_next, next);
	    /*NOT-REACHED*/
	case KEEPS_next_fail:
	    /* rollback the start point change */
	    PL_regoffs[0].start = st->u.keeper.val;
	    sayNO_SILENT;
	    /*NOT-REACHED*/
d2430 3
d2435 1
d2479 2
a2480 310

#undef  ST
#define ST st->u.trie
        case TRIEC:
            /* In this case the charclass data is available inline so
               we can fail fast without a lot of extra overhead. 
             */
            if (scan->flags == EXACT || !do_utf8) {
                if(!ANYOF_BITMAP_TEST(scan, *locinput)) {
                    DEBUG_EXECUTE_r(
                        PerlIO_printf(Perl_debug_log,
                    	          "%*s  %sfailed to match trie start class...%s\n",
                    	          REPORT_CODE_OFF+depth*2, "", PL_colors[4], PL_colors[5])
                    );
                    sayNO_SILENT;
                    /* NOTREACHED */
                }        	        
            }
            /* FALL THROUGH */
	case TRIE:
	    {
                /* what type of TRIE am I? (utf8 makes this contextual) */
                DECL_TRIE_TYPE(scan);

                /* what trie are we using right now */
		reg_trie_data * const trie
        	    = (reg_trie_data*)rexi->data->data[ ARG( scan ) ];
		HV * widecharmap = (HV *)rexi->data->data[ ARG( scan ) + 1 ];
                U32 state = trie->startstate;

        	if (trie->bitmap && trie_type != trie_utf8_fold &&
        	    !TRIE_BITMAP_TEST(trie,*locinput)
        	) {
        	    if (trie->states[ state ].wordnum) {
        	         DEBUG_EXECUTE_r(
                            PerlIO_printf(Perl_debug_log,
                        	          "%*s  %smatched empty string...%s\n",
                        	          REPORT_CODE_OFF+depth*2, "", PL_colors[4], PL_colors[5])
                        );
        	        break;
        	    } else {
        	        DEBUG_EXECUTE_r(
                            PerlIO_printf(Perl_debug_log,
                        	          "%*s  %sfailed to match trie start class...%s\n",
                        	          REPORT_CODE_OFF+depth*2, "", PL_colors[4], PL_colors[5])
                        );
        	        sayNO_SILENT;
        	   }
                }

            { 
		U8 *uc = ( U8* )locinput;

		STRLEN len = 0;
		STRLEN foldlen = 0;
		U8 *uscan = (U8*)NULL;
		STRLEN bufflen=0;
		SV *sv_accept_buff = NULL;
		U8 foldbuf[ UTF8_MAXBYTES_CASE + 1 ];

	    	ST.accepted = 0; /* how many accepting states we have seen */
		ST.B = next;
		ST.jump = trie->jump;
		ST.me = scan;
	        /*
        	   traverse the TRIE keeping track of all accepting states
        	   we transition through until we get to a failing node.
        	*/

		while ( state && uc <= (U8*)PL_regeol ) {
                    U32 base = trie->states[ state ].trans.base;
                    UV uvc = 0;
                    U16 charid;
                    /* We use charid to hold the wordnum as we don't use it
                       for charid until after we have done the wordnum logic. 
                       We define an alias just so that the wordnum logic reads
                       more naturally. */

#define got_wordnum charid
                    got_wordnum = trie->states[ state ].wordnum;

		    if ( got_wordnum ) {
			if ( ! ST.accepted ) {
			    ENTER;
			    /* SAVETMPS; */ /* XXX is this necessary? dmq */
			    bufflen = TRIE_INITAL_ACCEPT_BUFFLEN;
			    sv_accept_buff=newSV(bufflen *
					    sizeof(reg_trie_accepted) - 1);
			    SvCUR_set(sv_accept_buff, 0);
			    SvPOK_on(sv_accept_buff);
			    sv_2mortal(sv_accept_buff);
			    SAVETMPS;
			    ST.accept_buff =
				(reg_trie_accepted*)SvPV_nolen(sv_accept_buff );
			}
			do {
			    if (ST.accepted >= bufflen) {
				bufflen *= 2;
				ST.accept_buff =(reg_trie_accepted*)
				    SvGROW(sv_accept_buff,
				       	bufflen * sizeof(reg_trie_accepted));
			    }
			    SvCUR_set(sv_accept_buff,SvCUR(sv_accept_buff)
				+ sizeof(reg_trie_accepted));


			    ST.accept_buff[ST.accepted].wordnum = got_wordnum;
			    ST.accept_buff[ST.accepted].endpos = uc;
			    ++ST.accepted;
		        } while (trie->nextword && (got_wordnum= trie->nextword[got_wordnum]));
		    }
#undef got_wordnum 

		    DEBUG_TRIE_EXECUTE_r({
		                DUMP_EXEC_POS( (char *)uc, scan, do_utf8 );
			        PerlIO_printf( Perl_debug_log,
			            "%*s  %sState: %4"UVxf" Accepted: %4"UVxf" ",
			            2+depth * 2, "", PL_colors[4],
			            (UV)state, (UV)ST.accepted );
		    });

		    if ( base ) {
			REXEC_TRIE_READ_CHAR(trie_type, trie, widecharmap, uc,
					     uscan, len, uvc, charid, foldlen,
					     foldbuf, uniflags);

			if (charid &&
			     (base + charid > trie->uniquecharcount )
			     && (base + charid - 1 - trie->uniquecharcount
				    < trie->lasttrans)
			     && trie->trans[base + charid - 1 -
				    trie->uniquecharcount].check == state)
			{
			    state = trie->trans[base + charid - 1 -
				trie->uniquecharcount ].next;
			}
			else {
			    state = 0;
			}
			uc += len;

		    }
		    else {
			state = 0;
		    }
		    DEBUG_TRIE_EXECUTE_r(
		        PerlIO_printf( Perl_debug_log,
		            "Charid:%3x CP:%4"UVxf" After State: %4"UVxf"%s\n",
		            charid, uvc, (UV)state, PL_colors[5] );
		    );
		}
		if (!ST.accepted )
		   sayNO;

		DEBUG_EXECUTE_r(
		    PerlIO_printf( Perl_debug_log,
			"%*s  %sgot %"IVdf" possible matches%s\n",
			REPORT_CODE_OFF + depth * 2, "",
			PL_colors[4], (IV)ST.accepted, PL_colors[5] );
		);
	    }}
            goto trie_first_try; /* jump into the fail handler */
	    /* NOTREACHED */
	case TRIE_next_fail: /* we failed - try next alterative */
            if ( ST.jump) {
                REGCP_UNWIND(ST.cp);
	        for (n = *PL_reglastparen; n > ST.lastparen; n--)
		    PL_regoffs[n].end = -1;
	        *PL_reglastparen = n;
	    }
          trie_first_try:
            if (do_cutgroup) {
                do_cutgroup = 0;
                no_final = 0;
            }

            if ( ST.jump) {
                ST.lastparen = *PL_reglastparen;
	        REGCP_SET(ST.cp);
            }	        
	    if ( ST.accepted == 1 ) {
		/* only one choice left - just continue */
		DEBUG_EXECUTE_r({
		    AV *const trie_words
			= (AV *) rexi->data->data[ARG(ST.me)+TRIE_WORDS_OFFSET];
		    SV ** const tmp = av_fetch( trie_words, 
		        ST.accept_buff[ 0 ].wordnum-1, 0 );
		    SV *sv= tmp ? sv_newmortal() : NULL;
		    
		    PerlIO_printf( Perl_debug_log,
			"%*s  %sonly one match left: #%d <%s>%s\n",
			REPORT_CODE_OFF+depth*2, "", PL_colors[4],
			ST.accept_buff[ 0 ].wordnum,
			tmp ? pv_pretty(sv, SvPV_nolen_const(*tmp), SvCUR(*tmp), 0, 
	                        PL_colors[0], PL_colors[1],
	                        (SvUTF8(*tmp) ? PERL_PV_ESCAPE_UNI : 0)
                            ) 
			: "not compiled under -Dr",
			PL_colors[5] );
		});
		PL_reginput = (char *)ST.accept_buff[ 0 ].endpos;
		/* in this case we free tmps/leave before we call regmatch
		   as we wont be using accept_buff again. */
		
		locinput = PL_reginput;
		nextchr = UCHARAT(locinput);
    		if ( !ST.jump || !ST.jump[ST.accept_buff[0].wordnum]) 
    		    scan = ST.B;
    		else
    		    scan = ST.me + ST.jump[ST.accept_buff[0].wordnum];
		if (!has_cutgroup) {
		    FREETMPS;
		    LEAVE;
                } else {
                    ST.accepted--;
                    PUSH_YES_STATE_GOTO(TRIE_next, scan);
                }
		
		continue; /* execute rest of RE */
	    }
	    
	    if ( !ST.accepted-- ) {
	        DEBUG_EXECUTE_r({
		    PerlIO_printf( Perl_debug_log,
			"%*s  %sTRIE failed...%s\n",
			REPORT_CODE_OFF+depth*2, "", 
			PL_colors[4],
			PL_colors[5] );
		});
		FREETMPS;
		LEAVE;
		sayNO_SILENT;
		/*NOTREACHED*/
	    } 

	    /*
	       There are at least two accepting states left.  Presumably
	       the number of accepting states is going to be low,
	       typically two. So we simply scan through to find the one
	       with lowest wordnum.  Once we find it, we swap the last
	       state into its place and decrement the size. We then try to
	       match the rest of the pattern at the point where the word
	       ends. If we succeed, control just continues along the
	       regex; if we fail we return here to try the next accepting
	       state
	     */

	    {
		U32 best = 0;
		U32 cur;
		for( cur = 1 ; cur <= ST.accepted ; cur++ ) {
		    DEBUG_TRIE_EXECUTE_r(
			PerlIO_printf( Perl_debug_log,
			    "%*s  %sgot %"IVdf" (%d) as best, looking at %"IVdf" (%d)%s\n",
			    REPORT_CODE_OFF + depth * 2, "", PL_colors[4],
			    (IV)best, ST.accept_buff[ best ].wordnum, (IV)cur,
			    ST.accept_buff[ cur ].wordnum, PL_colors[5] );
		    );

		    if (ST.accept_buff[cur].wordnum <
			    ST.accept_buff[best].wordnum)
			best = cur;
		}

		DEBUG_EXECUTE_r({
		    AV *const trie_words
			= (AV *) rexi->data->data[ARG(ST.me)+TRIE_WORDS_OFFSET];
		    SV ** const tmp = av_fetch( trie_words, 
		        ST.accept_buff[ best ].wordnum - 1, 0 );
		    regnode *nextop=(!ST.jump || !ST.jump[ST.accept_buff[best].wordnum]) ? 
		                    ST.B : 
		                    ST.me + ST.jump[ST.accept_buff[best].wordnum];    
		    SV *sv= tmp ? sv_newmortal() : NULL;
		    
		    PerlIO_printf( Perl_debug_log, 
		        "%*s  %strying alternation #%d <%s> at node #%d %s\n",
			REPORT_CODE_OFF+depth*2, "", PL_colors[4],
			ST.accept_buff[best].wordnum,
			tmp ? pv_pretty(sv, SvPV_nolen_const(*tmp), SvCUR(*tmp), 0, 
	                        PL_colors[0], PL_colors[1],
	                        (SvUTF8(*tmp) ? PERL_PV_ESCAPE_UNI : 0)
                            ) : "not compiled under -Dr", 
			    REG_NODE_NUM(nextop),
			PL_colors[5] );
		});

		if ( best<ST.accepted ) {
		    reg_trie_accepted tmp = ST.accept_buff[ best ];
		    ST.accept_buff[ best ] = ST.accept_buff[ ST.accepted ];
		    ST.accept_buff[ ST.accepted ] = tmp;
		    best = ST.accepted;
		}
		PL_reginput = (char *)ST.accept_buff[ best ].endpos;
		if ( !ST.jump || !ST.jump[ST.accept_buff[best].wordnum]) {
		    scan = ST.B;
		} else {
		    scan = ST.me + ST.jump[ST.accept_buff[best].wordnum];
                }
                PUSH_YES_STATE_GOTO(TRIE_next, scan);    
                /* NOTREACHED */
	    }
	    /* NOTREACHED */
        case TRIE_next:
            FREETMPS;
	    LEAVE;
	    sayYES;
#undef  ST

	case EXACT: {
	    char *s = STRING(scan);
d2485 1
a2485 1
		const char * const e = s + ln;
a2529 1
	    }
d2533 2
a2534 2
	case EXACTF: {
	    char * const s = STRING(scan);
d2539 1
a2539 1
		const char * const l = locinput;
a2547 1

d2549 1
a2549 1
		           toLOWER(s[0]) == 's' &&
a2577 1
	    }
d2582 2
a2583 2
	        if (!reginclass(rex, scan, (U8*)locinput, &inclasslen, do_utf8))
		    goto anyof_fail;
d2593 2
a2594 2
		if (!REGINCLASS(rex, scan, (U8*)locinput))
		    goto anyof_fail;
d2600 1
a2600 1
	anyof_fail:
d2620 1
a2620 1
		      ? (bool)swash_fetch(PL_utf8_alnum, (U8*)locinput, do_utf8)
d2643 1
a2643 1
		    ? (bool)swash_fetch(PL_utf8_alnum, (U8*)locinput, do_utf8)
d2670 1
a2670 1
		    ln = utf8n_to_uvchr(r, UTF8SKIP(r), 0, uniflags);
d2708 1
a2708 1
			  ? (bool)swash_fetch(PL_utf8_space, (U8*)locinput, do_utf8)
d2738 1
a2738 1
		    ? (bool)swash_fetch(PL_utf8_space, (U8*)locinput, do_utf8)
d2761 1
a2761 1
		      ? (bool)swash_fetch(PL_utf8_digit, (U8*)locinput, do_utf8)
d2784 1
a2784 1
		    ? (bool)swash_fetch(PL_utf8_digit, (U8*)locinput, do_utf8)
a2815 19
            
	case NREFFL:
	{
	    char *s;
	    char type;
	    PL_reg_flags |= RF_tainted;
	    /* FALL THROUGH */
	case NREF:
	case NREFF:
	    type = OP(scan);
	    n = reg_check_named_buff_matched(rex,scan);

            if ( n ) {
                type = REF + ( type - NREF );
                goto do_ref;
            } else {
                sayNO;
            }
            /* unreached */
d2820 1
a2820 1
	case REFF: 
d2822 1
a2822 3
	    type = OP(scan);
	  do_ref:  
	    ln = PL_regoffs[n].start;
d2824 1
a2824 1
	    if (*PL_reglastparen < n || ln == -1)
d2826 1
a2826 1
	    if (ln == PL_regoffs[n].end)
d2830 1
a2830 1
	    if (do_utf8 && type != REF) {	/* REF can do byte comparison */
d2832 1
a2832 1
		const char *e = PL_bostr + PL_regoffs[n].end;
d2838 1
a2838 1
		if (type == REFF) {
d2861 3
a2863 3
		(type == REF ||
		 (UCHARAT(s) != (type == REFF
				  ? PL_fold : PL_fold_locale)[nextchr])))
d2865 1
a2865 1
	    ln = PL_regoffs[n].end - ln;
d2868 1
a2868 1
	    if (ln > 1 && (type == REF
d2870 1
a2870 1
			   : (type == REFF
d2877 1
a2877 1
	}
d2883 1
a2883 3

#undef  ST
#define ST st->u.eval
d2885 4
d2890 8
a2897 35
            regexp *re;
            regexp_internal *rei;
            regnode *startpoint;

	case GOSTART:
	case GOSUB: /*    /(...(?1))/   /(...(?&foo))/   */
	    if (cur_eval && cur_eval->locinput==locinput) {
                if (cur_eval->u.eval.close_paren == (U32)ARG(scan)) 
                    Perl_croak(aTHX_ "Infinite recursion in regex");
                if ( ++nochange_depth > max_nochange_depth )
                    Perl_croak(aTHX_ 
                        "Pattern subroutine nesting without pos change"
                        " exceeded limit in regex");
            } else {
                nochange_depth = 0;
            }
            re = rex;
            rei = rexi;
            (void)ReREFCNT_inc(rex);
            if (OP(scan)==GOSUB) {
                startpoint = scan + ARG2L(scan);
                ST.close_paren = ARG(scan);
            } else {
                startpoint = rei->program+1;
                ST.close_paren = 0;
            }
            goto eval_recurse_doit;
            /* NOTREACHED */
        case EVAL:  /*   /(?{A})B/   /(??{A})B/  and /(?(?{A})X|Y)B/   */        
            if (cur_eval && cur_eval->locinput==locinput) {
		if ( ++nochange_depth > max_nochange_depth )
                    Perl_croak(aTHX_ "EVAL without pos change exceeded limit in regex");
            } else {
                nochange_depth = 0;
            }    
d2899 1
a2899 19
		/* execute the code in the {...} */
		dSP;
		SV ** const before = SP;
		OP_4tree * const oop = PL_op;
		COP * const ocurcop = PL_curcop;
		PAD *old_comppad;
	    
		n = ARG(scan);
		PL_op = (OP_4tree*)rexi->data->data[n];
		DEBUG_STATE_r( PerlIO_printf(Perl_debug_log, 
		    "  re_eval 0x%"UVxf"\n", PTR2UV(PL_op)) );
		PAD_SAVE_LOCAL(old_comppad, (PAD*)rexi->data->data[n + 2]);
		PL_regoffs[0].end = PL_reg_magic->mg_len = locinput - PL_bostr;

                if (sv_yes_mark) {
                    SV *sv_mrk = get_sv("REGMARK", 1);
                    sv_setsv(sv_mrk, sv_yes_mark);
                }

d2908 1
d2910 11
a2920 14
		PL_op = oop;
		PAD_RESTORE_LOCAL(old_comppad);
		PL_curcop = ocurcop;
		if (!logical) {
		    /* /(?{...})/ */
		    sv_setsv(save_scalar(PL_replgv), ret);
		    break;
		}
	    }
	    if (logical == 2) { /* Postponed subexpression: /(??{...})/ */
		logical = 0;
		{
		    /* extract RE object from returned value; compiling if
		     * necessary */
a2921 2
		    MAGIC *mg = NULL;
		    const SV *sv;
d2932 2
a2933 1
			re = reg_temp_copy((regexp *)mg->mg_obj); /*XXX:dmq*/
d2936 4
a2939 1
			U32 pm_flags = 0;
d2941 1
d2943 3
a2945 2
			if (DO_UTF8(ret)) pm_flags |= RXf_UTF8;
			re = CALLREGCOMP(ret, pm_flags);
d2951 1
d2953 1
d2955 14
a2968 24
		}
                RX_MATCH_COPIED_off(re);
                re->subbeg = rex->subbeg;
                re->sublen = rex->sublen;
		rei = RXi_GET(re);
                DEBUG_EXECUTE_r(
                    debug_start_match(re, do_utf8, locinput, PL_regeol, 
                        "Matching embedded");
		);		
		startpoint = rei->program + 1;
               	ST.close_paren = 0; /* only used for GOSUB */
               	/* borrowed from regtry */
                if (PL_reg_start_tmpl <= re->nparens) {
                    PL_reg_start_tmpl = re->nparens*3/2 + 3;
                    if(PL_reg_start_tmp)
                        Renew(PL_reg_start_tmp, PL_reg_start_tmpl, char*);
                    else
                        Newx(PL_reg_start_tmp, PL_reg_start_tmpl, char*);
                }               	

        eval_recurse_doit: /* Share code with GOSUB below this line */                		
		/* run the pattern returned from (??{...}) */
		ST.cp = regcppush(0);	/* Save *all* the positions. */
		REGCP_SET(ST.lastcp);
d2970 43
a3012 6
		PL_regoffs = re->offs; /* essentially NOOP on GOSUB */
		
		*PL_reglastparen = 0;
		*PL_reglastcloseparen = 0;
		PL_reginput = locinput;
		PL_regsize = 0;
d3014 2
a3015 2
		/* XXXX This is too dramatic a measure... */
		PL_reg_maxiter = 0;
d3017 10
a3026 22
		ST.toggle_reg_flags = PL_reg_flags;
		if (re->extflags & RXf_UTF8)
		    PL_reg_flags |= RF_utf8;
		else
		    PL_reg_flags &= ~RF_utf8;
		ST.toggle_reg_flags ^= PL_reg_flags; /* diff of old and new */

		ST.prev_rex = rex;
		ST.prev_curlyx = cur_curlyx;
		SETREX(rex,re);
		rexi = rei;
		cur_curlyx = NULL;
		ST.B = next;
		ST.prev_eval = cur_eval;
		cur_eval = st;
		/* now continue from first node in postoned RE */
		PUSH_YES_STATE_GOTO(EVAL_AB, startpoint);
		/* NOTREACHED */
	    }
	    /* logical is 1,   /(?(?{...})X|Y)/ */
	    sw = (bool)SvTRUE(ret);
	    logical = 0;
a3028 35

	case EVAL_AB: /* cleanup after a successful (??{A})B */
	    /* note: this is called twice; first after popping B, then A */
	    PL_reg_flags ^= ST.toggle_reg_flags; 
	    ReREFCNT_dec(rex);
	    SETREX(rex,ST.prev_rex);
	    rexi = RXi_GET(rex);
	    regcpblow(ST.cp);
	    cur_eval = ST.prev_eval;
	    cur_curlyx = ST.prev_curlyx;
	    /* XXXX This is too dramatic a measure... */
	    PL_reg_maxiter = 0;
            if ( nochange_depth )
	        nochange_depth--;
	    sayYES;


	case EVAL_AB_fail: /* unsuccessfully ran A or B in (??{A})B */
	    /* note: this is called twice; first after popping B, then A */
	    PL_reg_flags ^= ST.toggle_reg_flags; 
	    ReREFCNT_dec(rex);
	    SETREX(rex,ST.prev_rex);
	    rexi = RXi_GET(rex); 
	    PL_reginput = locinput;
	    REGCP_UNWIND(ST.lastcp);
	    regcppop(rex);
	    cur_eval = ST.prev_eval;
	    cur_curlyx = ST.prev_curlyx;
	    /* XXXX This is too dramatic a measure... */
	    PL_reg_maxiter = 0;
	    if ( nochange_depth )
	        nochange_depth--;
	    sayNO_SILENT;
#undef ST

a3033 1
            lastopen = n;
d3037 3
a3039 5
	    PL_regoffs[n].start = PL_reg_start_tmp[n] - PL_bostr;
	    PL_regoffs[n].end = locinput - PL_bostr;
	    /*if (n > PL_regsize)
		PL_regsize = n;*/
	    if (n > *PL_reglastparen)
d3042 1
a3042 31
            if (cur_eval && cur_eval->u.eval.close_paren == n) {
	        goto fake_end;
	    }    
	    break;
        case ACCEPT:
            if (ARG(scan)){
                regnode *cursor;
                for (cursor=scan;
                     cursor && OP(cursor)!=END; 
                     cursor=regnext(cursor)) 
                {
                    if ( OP(cursor)==CLOSE ){
                        n = ARG(cursor);
                        if ( n <= lastopen ) {
                            PL_regoffs[n].start
				= PL_reg_start_tmp[n] - PL_bostr;
                            PL_regoffs[n].end = locinput - PL_bostr;
                            /*if (n > PL_regsize)
                            PL_regsize = n;*/
                            if (n > *PL_reglastparen)
                                *PL_reglastparen = n;
                            *PL_reglastcloseparen = n;
                            if ( n == ARG(scan) || (cur_eval &&
                                cur_eval->u.eval.close_paren == n))
                                break;
                        }
                    }
                }
            }
	    goto fake_end;
	    /*NOTREACHED*/	    
d3045 1
a3045 1
	    sw = (bool)(*PL_reglastparen >= n && PL_regoffs[n].end != -1);
a3046 11
	case NGROUPP:
	    /* reg_check_named_buff_matched returns 0 for no match */
	    sw = (bool)(0 < reg_check_named_buff_matched(rex,scan));
	    break;
        case INSUBP:
            n = ARG(scan);
            sw = (cur_eval && (!n || cur_eval->u.eval.close_paren == n));
            break;
        case DEFINEP:
            sw = 0;
            break;
a3059 1

d3061 2
d3064 1
a3064 38
The CURLYX/WHILEM pair of ops handle the most generic case of the /A*B/
pattern, where A and B are subpatterns. (For simple A, CURLYM or
STAR/PLUS/CURLY/CURLYN are used instead.)

A*B is compiled as <CURLYX><A><WHILEM><B>

On entry to the subpattern, CURLYX is called. This pushes a CURLYX
state, which contains the current count, initialised to -1. It also sets
cur_curlyx to point to this state, with any previous value saved in the
state block.

CURLYX then jumps straight to the WHILEM op, rather than executing A,
since the pattern may possibly match zero times (i.e. it's a while {} loop
rather than a do {} while loop).

Each entry to WHILEM represents a successful match of A. The count in the
CURLYX block is incremented, another WHILEM state is pushed, and execution
passes to A or B depending on greediness and the current count.

For example, if matching against the string a1a2a3b (where the aN are
substrings that match /A/), then the match progresses as follows: (the
pushed states are interspersed with the bits of strings matched so far):

    <CURLYX cnt=-1>
    <CURLYX cnt=0><WHILEM>
    <CURLYX cnt=1><WHILEM> a1 <WHILEM>
    <CURLYX cnt=2><WHILEM> a1 <WHILEM> a2 <WHILEM>
    <CURLYX cnt=3><WHILEM> a1 <WHILEM> a2 <WHILEM> a3 <WHILEM>
    <CURLYX cnt=3><WHILEM> a1 <WHILEM> a2 <WHILEM> a3 <WHILEM> b

(Contrast this with something like CURLYM, which maintains only a single
backtrack state:

    <CURLYM cnt=0> a1
    a1 <CURLYM cnt=1> a2
    a1 a2 <CURLYM cnt=2> a3
    a1 a2 a3 <CURLYM cnt=3> b
)
d3066 1
a3066 4
Each WHILEM state block marks a point to backtrack to upon partial failure
of A or B, and also contains some minor state data related to that
iteration.  The CURLYX block, pointed to by cur_curlyx, contains the
overall state, such as the count, and pointers to the A and B ops.
d3068 105
a3172 2
This is complicated slightly by nested CURLYX/WHILEM's. Since cur_curlyx
must always point to the *current* CURLYX block, the rules are:
d3174 7
a3180 2
When executing CURLYX, save the old cur_curlyx in the CURLYX state block,
and set cur_curlyx to point the new block.
d3182 7
a3188 2
When popping the CURLYX block after a successful or unsuccessful match,
restore the previous cur_curlyx.
d3190 1
a3190 2
When WHILEM is about to execute B, save the current cur_curlyx, and set it
to the outer one saved in the CURLYX block.
d3192 16
a3207 2
When popping the WHILEM block after a successful or unsuccessful B match,
restore the previous cur_curlyx.
d3209 1
a3209 2
Here's an example for the pattern (AI* BI)*BO
I and O refer to inner and outer, C and W refer to CURLYX and WHILEM:
d3211 9
a3219 111
cur_
curlyx backtrack stack
------ ---------------
NULL   
CO     <CO prev=NULL> <WO>
CI     <CO prev=NULL> <WO> <CI prev=CO> <WI> ai 
CO     <CO prev=NULL> <WO> <CI prev=CO> <WI> ai <WI prev=CI> bi 
NULL   <CO prev=NULL> <WO> <CI prev=CO> <WI> ai <WI prev=CI> bi <WO prev=CO> bo

At this point the pattern succeeds, and we work back down the stack to
clean up, restoring as we go:

CO     <CO prev=NULL> <WO> <CI prev=CO> <WI> ai <WI prev=CI> bi 
CI     <CO prev=NULL> <WO> <CI prev=CO> <WI> ai 
CO     <CO prev=NULL> <WO>
NULL   

*******************************************************************/

#define ST st->u.curlyx

	case CURLYX:    /* start of /A*B/  (for complex A) */
	{
	    /* No need to save/restore up to this paren */
	    I32 parenfloor = scan->flags;
	    
	    assert(next); /* keep Coverity happy */
	    if (OP(PREVOPER(next)) == NOTHING) /* LONGJMP */
		next += ARG(next);

	    /* XXXX Probably it is better to teach regpush to support
	       parenfloor > PL_regsize... */
	    if (parenfloor > (I32)*PL_reglastparen)
		parenfloor = *PL_reglastparen; /* Pessimization... */

	    ST.prev_curlyx= cur_curlyx;
	    cur_curlyx = st;
	    ST.cp = PL_savestack_ix;

	    /* these fields contain the state of the current curly.
	     * they are accessed by subsequent WHILEMs */
	    ST.parenfloor = parenfloor;
	    ST.min = ARG1(scan);
	    ST.max = ARG2(scan);
	    ST.A = NEXTOPER(scan) + EXTRA_STEP_2ARGS;
	    ST.B = next;
	    ST.minmod = minmod;
	    minmod = 0;
	    ST.count = -1;	/* this will be updated by WHILEM */
	    ST.lastloc = NULL;  /* this will be updated by WHILEM */

	    PL_reginput = locinput;
	    PUSH_YES_STATE_GOTO(CURLYX_end, PREVOPER(next));
	    /* NOTREACHED */
	}

	case CURLYX_end: /* just finished matching all of A*B */
	    cur_curlyx = ST.prev_curlyx;
	    sayYES;
	    /* NOTREACHED */

	case CURLYX_end_fail: /* just failed to match all of A*B */
	    regcpblow(ST.cp);
	    cur_curlyx = ST.prev_curlyx;
	    sayNO;
	    /* NOTREACHED */


#undef ST
#define ST st->u.whilem

	case WHILEM:     /* just matched an A in /A*B/  (for complex A) */
	{
	    /* see the discussion above about CURLYX/WHILEM */
	    I32 n;
	    assert(cur_curlyx); /* keep Coverity happy */
	    n = ++cur_curlyx->u.curlyx.count; /* how many A's matched */
	    ST.save_lastloc = cur_curlyx->u.curlyx.lastloc;
	    ST.cache_offset = 0;
	    ST.cache_mask = 0;
	    
	    PL_reginput = locinput;

	    DEBUG_EXECUTE_r( PerlIO_printf(Perl_debug_log,
		  "%*s  whilem: matched %ld out of %ld..%ld\n",
		  REPORT_CODE_OFF+depth*2, "", (long)n,
		  (long)cur_curlyx->u.curlyx.min,
		  (long)cur_curlyx->u.curlyx.max)
	    );

	    /* First just match a string of min A's. */

	    if (n < cur_curlyx->u.curlyx.min) {
		cur_curlyx->u.curlyx.lastloc = locinput;
		PUSH_STATE_GOTO(WHILEM_A_pre, cur_curlyx->u.curlyx.A);
		/* NOTREACHED */
	    }

	    /* If degenerate A matches "", assume A done. */

	    if (locinput == cur_curlyx->u.curlyx.lastloc) {
		DEBUG_EXECUTE_r( PerlIO_printf(Perl_debug_log,
		   "%*s  whilem: empty match detected, trying continuation...\n",
		   REPORT_CODE_OFF+depth*2, "")
		);
		goto do_whilem_B_max;
	    }

	    /* super-linear cache processing */

	    if (scan->flags) {
d3221 4
a3225 2
		    /* start the countdown: Postpone detection until we
		     * know the match is not *that* much linear. */
a3226 3
		    /* possible overflow for long strings and many CURLYX's */
		    if (PL_reg_maxiter < 0)
			PL_reg_maxiter = I32_MAX;
a3228 1

d3230 1
a3230 2
		    /* initialise cache */
		    const I32 size = (PL_reg_maxiter + 7)/8;
d3242 5
a3246 4
		    DEBUG_EXECUTE_r( PerlIO_printf(Perl_debug_log,
      "%swhilem: Detected a super-linear match, switching on caching%s...\n",
			      PL_colors[4], PL_colors[5])
		    );
d3248 2
d3251 9
a3259 11
		if (PL_reg_leftiter < 0) {
		    /* have we already failed at this position? */
		    I32 offset, mask;
		    offset  = (scan->flags & 0xf) - 1
		  		+ (locinput - PL_bostr)  * (scan->flags>>4);
		    mask    = 1 << (offset % 8);
		    offset /= 8;
		    if (PL_reg_poscache[offset] & mask) {
			DEBUG_EXECUTE_r( PerlIO_printf(Perl_debug_log,
			    "%*s  whilem: (cache) already tried at this position...\n",
			    REPORT_CODE_OFF+depth*2, "")
d3261 6
a3266 1
			sayNO; /* cache records failure */
d3268 2
a3269 2
		    ST.cache_offset = offset;
		    ST.cache_mask   = mask;
a3270 1
	    }
d3272 1
a3272 1
	    /* Prefer B over A for minimal matching. */
d3274 26
a3299 8
	    if (cur_curlyx->u.curlyx.minmod) {
		ST.save_curlyx = cur_curlyx;
		cur_curlyx = cur_curlyx->u.curlyx.prev_curlyx;
		ST.cp = regcppush(ST.save_curlyx->u.curlyx.parenfloor);
		REGCP_SET(ST.lastcp);
		PUSH_YES_STATE_GOTO(WHILEM_B_min, ST.save_curlyx->u.curlyx.B);
		/* NOTREACHED */
	    }
d3301 44
a3344 72
	    /* Prefer A over B for maximal matching. */

	    if (n < cur_curlyx->u.curlyx.max) { /* More greed allowed? */
		ST.cp = regcppush(cur_curlyx->u.curlyx.parenfloor);
		cur_curlyx->u.curlyx.lastloc = locinput;
		REGCP_SET(ST.lastcp);
		PUSH_STATE_GOTO(WHILEM_A_max, cur_curlyx->u.curlyx.A);
		/* NOTREACHED */
	    }
	    goto do_whilem_B_max;
	}
	/* NOTREACHED */

	case WHILEM_B_min: /* just matched B in a minimal match */
	case WHILEM_B_max: /* just matched B in a maximal match */
	    cur_curlyx = ST.save_curlyx;
	    sayYES;
	    /* NOTREACHED */

	case WHILEM_B_max_fail: /* just failed to match B in a maximal match */
	    cur_curlyx = ST.save_curlyx;
	    cur_curlyx->u.curlyx.lastloc = ST.save_lastloc;
	    cur_curlyx->u.curlyx.count--;
	    CACHEsayNO;
	    /* NOTREACHED */

	case WHILEM_A_min_fail: /* just failed to match A in a minimal match */
	    REGCP_UNWIND(ST.lastcp);
	    regcppop(rex);
	    /* FALL THROUGH */
	case WHILEM_A_pre_fail: /* just failed to match even minimal A */
	    cur_curlyx->u.curlyx.lastloc = ST.save_lastloc;
	    cur_curlyx->u.curlyx.count--;
	    CACHEsayNO;
	    /* NOTREACHED */

	case WHILEM_A_max_fail: /* just failed to match A in a maximal match */
	    REGCP_UNWIND(ST.lastcp);
	    regcppop(rex);	/* Restore some previous $<digit>s? */
	    PL_reginput = locinput;
	    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
		"%*s  whilem: failed, trying continuation...\n",
		REPORT_CODE_OFF+depth*2, "")
	    );
	  do_whilem_B_max:
	    if (cur_curlyx->u.curlyx.count >= REG_INFTY
		&& ckWARN(WARN_REGEXP)
		&& !(PL_reg_flags & RF_warned))
	    {
		PL_reg_flags |= RF_warned;
		Perl_warner(aTHX_ packWARN(WARN_REGEXP), "%s limit (%d) exceeded",
		     "Complex regular subexpression recursion",
		     REG_INFTY - 1);
	    }

	    /* now try B */
	    ST.save_curlyx = cur_curlyx;
	    cur_curlyx = cur_curlyx->u.curlyx.prev_curlyx;
	    PUSH_YES_STATE_GOTO(WHILEM_B_max, ST.save_curlyx->u.curlyx.B);
	    /* NOTREACHED */

	case WHILEM_B_min_fail: /* just failed to match B in a minimal match */
	    cur_curlyx = ST.save_curlyx;
	    REGCP_UNWIND(ST.lastcp);
	    regcppop(rex);

	    if (cur_curlyx->u.curlyx.count >= cur_curlyx->u.curlyx.max) {
		/* Maximum greed exceeded */
		if (cur_curlyx->u.curlyx.count >= REG_INFTY
		    && ckWARN(WARN_REGEXP)
		    && !(PL_reg_flags & RF_warned))
		{
d3346 16
a3361 6
		    Perl_warner(aTHX_ packWARN(WARN_REGEXP),
			"%s limit (%d) exceeded",
			"Complex regular subexpression recursion",
			REG_INFTY - 1);
		}
		cur_curlyx->u.curlyx.count--;
d3364 2
a3365 16

	    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
		"%*s  trying longer...\n", REPORT_CODE_OFF+depth*2, "")
	    );
	    /* Try grabbing another A and see if it helps. */
	    PL_reginput = locinput;
	    cur_curlyx->u.curlyx.lastloc = locinput;
	    ST.cp = regcppush(cur_curlyx->u.curlyx.parenfloor);
	    REGCP_SET(ST.lastcp);
	    PUSH_STATE_GOTO(WHILEM_A_min, ST.save_curlyx->u.curlyx.A);
	    /* NOTREACHED */

#undef  ST
#define ST st->u.branch

	case BRANCHJ:	    /*  /(...|A|...)/ with long next pointer */
d3369 29
a3397 2
	    scan = NEXTOPER(scan);
	    /* FALL THROUGH */
d3399 1
a3399 6
	case BRANCH:	    /*  /(...|A|...)/ */
	    scan = NEXTOPER(scan); /* scan now points to inner node */
	    ST.lastparen = *PL_reglastparen;
	    ST.next_branch = next;
	    REGCP_SET(ST.cp);
	    PL_reginput = locinput;
d3401 3
a3403 5
	    /* Now go into the branch */
	    if (has_cutgroup) {
	        PUSH_YES_STATE_GOTO(BRANCH_next, scan);    
	    } else {
	        PUSH_STATE_GOTO(BRANCH_next, scan);
d3405 1
a3405 42
	    /* NOTREACHED */
        case CUTGROUP:
            PL_reginput = locinput;
            sv_yes_mark = st->u.mark.mark_name = scan->flags ? NULL :
                (SV*)rexi->data->data[ ARG( scan ) ];
            PUSH_STATE_GOTO(CUTGROUP_next,next);
            /* NOTREACHED */
        case CUTGROUP_next_fail:
            do_cutgroup = 1;
            no_final = 1;
            if (st->u.mark.mark_name)
                sv_commit = st->u.mark.mark_name;
            sayNO;	    
            /* NOTREACHED */
        case BRANCH_next:
            sayYES;
            /* NOTREACHED */
	case BRANCH_next_fail: /* that branch failed; try the next, if any */
	    if (do_cutgroup) {
	        do_cutgroup = 0;
	        no_final = 0;
	    }
	    REGCP_UNWIND(ST.cp);
	    for (n = *PL_reglastparen; n > ST.lastparen; n--)
		PL_regoffs[n].end = -1;
	    *PL_reglastparen = n;
	    /*dmq: *PL_reglastcloseparen = n; */
	    scan = ST.next_branch;
	    /* no more branches? */
	    if (!scan || (OP(scan) != BRANCH && OP(scan) != BRANCHJ)) {
	        DEBUG_EXECUTE_r({
		    PerlIO_printf( Perl_debug_log,
			"%*s  %sBRANCH failed...%s\n",
			REPORT_CODE_OFF+depth*2, "", 
			PL_colors[4],
			PL_colors[5] );
		});
		sayNO_SILENT;
            }
	    continue; /* execute next BRANCH[J] op */
	    /* NOTREACHED */
    
d3409 12
a3420 18

#undef  ST
#define ST st->u.curlym

	case CURLYM:	/* /A{m,n}B/ where A is fixed-length */

	    /* This is an optimisation of CURLYX that enables us to push
	     * only a single backtracking state, no matter now many matches
	     * there are in {m,n}. It relies on the pattern being constant
	     * length, with no parens to influence future backrefs
	     */

	    ST.me = scan;
	    scan = NEXTOPER(scan) + NODE_STEP_REGNODE;

	    /* if paren positive, emulate an OPEN/CLOSE around A */
	    if (ST.me->flags) {
		U32 paren = ST.me->flags;
d3423 1
a3423 1
		if (paren > *PL_reglastparen)
d3425 3
a3428 14
	    }
	    ST.A = scan;
	    ST.B = next;
	    ST.alen = 0;
	    ST.count = 0;
	    ST.minmod = minmod;
	    minmod = 0;
	    ST.c1 = CHRTEST_UNINIT;
	    REGCP_SET(ST.cp);

	    if (!(ST.minmod ? ARG1(ST.me) : ARG2(ST.me))) /* min/max */
		goto curlym_do_B;

	  curlym_do_A: /* execute the A in /A{m,n}B/  */
d3430 7
a3436 2
	    PUSH_YES_STATE_GOTO(CURLYM_A, ST.A); /* match A */
	    /* NOTREACHED */
d3438 1
a3438 3
	case CURLYM_A: /* we've just matched an A */
	    locinput = st->locinput;
	    nextchr = UCHARAT(locinput);
d3440 13
a3452 8
	    ST.count++;
	    /* after first match, determine A's length: u.curlym.alen */
	    if (ST.count == 1) {
		if (PL_reg_match_utf8) {
		    char *s = locinput;
		    while (s < PL_reginput) {
			ST.alen++;
			s += UTF8SKIP(s);
d3455 31
a3485 2
		else {
		    ST.alen = PL_reginput - locinput;
a3486 2
		if (ST.alen == 0)
		    ST.count = ST.minmod ? ARG1(ST.me) : ARG2(ST.me);
d3488 22
a3509 24
	    DEBUG_EXECUTE_r(
		PerlIO_printf(Perl_debug_log,
			  "%*s  CURLYM now matched %"IVdf" times, len=%"IVdf"...\n",
			  (int)(REPORT_CODE_OFF+(depth*2)), "",
			  (IV) ST.count, (IV)ST.alen)
	    );

	    locinput = PL_reginput;
	                
	    if (cur_eval && cur_eval->u.eval.close_paren && 
	        cur_eval->u.eval.close_paren == (U32)ST.me->flags) 
	        goto fake_end;
	        
	    if ( ST.count < (ST.minmod ? ARG1(ST.me) : ARG2(ST.me)) )
		goto curlym_do_A; /* try to match another A */
	    goto curlym_do_B; /* try to match B */

	case CURLYM_A_fail: /* just failed to match an A */
	    REGCP_UNWIND(ST.cp);

	    if (ST.minmod || ST.count < ARG1(ST.me) /* min*/ 
	        || (cur_eval && cur_eval->u.eval.close_paren &&
	            cur_eval->u.eval.close_paren == (U32)ST.me->flags))
		sayNO;
d3511 18
a3528 20
	  curlym_do_B: /* execute the B in /A{m,n}B/  */
	    PL_reginput = locinput;
	    if (ST.c1 == CHRTEST_UNINIT) {
		/* calculate c1 and c2 for possible match of 1st char
		 * following curly */
		ST.c1 = ST.c2 = CHRTEST_VOID;
		if (HAS_TEXT(ST.B) || JUMPABLE(ST.B)) {
		    regnode *text_node = ST.B;
		    if (! HAS_TEXT(text_node))
			FIND_NEXT_IMPT(text_node);
	            /* this used to be 
	                
	                (HAS_TEXT(text_node) && PL_regkind[OP(text_node)] == EXACT)
	                
	            	But the former is redundant in light of the latter.
	            	
	            	if this changes back then the macro for 
	            	IS_TEXT and friends need to change.
	             */
		    if (PL_regkind[OP(text_node)] == EXACT)
d3530 16
a3545 8
		        
			ST.c1 = (U8)*STRING(text_node);
			ST.c2 =
			    (IS_TEXTF(text_node))
			    ? PL_fold[ST.c1]
			    : (IS_TEXTFL(text_node))
				? PL_fold_locale[ST.c1]
				: ST.c1;
d3547 4
d3553 11
a3563 99

	    DEBUG_EXECUTE_r(
		PerlIO_printf(Perl_debug_log,
		    "%*s  CURLYM trying tail with matches=%"IVdf"...\n",
		    (int)(REPORT_CODE_OFF+(depth*2)),
		    "", (IV)ST.count)
		);
	    if (ST.c1 != CHRTEST_VOID
		    && UCHARAT(PL_reginput) != ST.c1
		    && UCHARAT(PL_reginput) != ST.c2)
	    {
		/* simulate B failing */
		DEBUG_OPTIMISE_r(
		    PerlIO_printf(Perl_debug_log,
		        "%*s  CURLYM Fast bail c1=%"IVdf" c2=%"IVdf"\n",
		        (int)(REPORT_CODE_OFF+(depth*2)),"",
		        (IV)ST.c1,(IV)ST.c2
		));
		state_num = CURLYM_B_fail;
		goto reenter_switch;
	    }

	    if (ST.me->flags) {
		/* mark current A as captured */
		I32 paren = ST.me->flags;
		if (ST.count) {
		    PL_regoffs[paren].start
			= HOPc(PL_reginput, -ST.alen) - PL_bostr;
		    PL_regoffs[paren].end = PL_reginput - PL_bostr;
		    /*dmq: *PL_reglastcloseparen = paren; */
		}
		else
		    PL_regoffs[paren].end = -1;
		if (cur_eval && cur_eval->u.eval.close_paren &&
		    cur_eval->u.eval.close_paren == (U32)ST.me->flags) 
		{
		    if (ST.count) 
	                goto fake_end;
	            else
	                sayNO;
	        }
	    }
	    
	    PUSH_STATE_GOTO(CURLYM_B, ST.B); /* match B */
	    /* NOTREACHED */

	case CURLYM_B_fail: /* just failed to match a B */
	    REGCP_UNWIND(ST.cp);
	    if (ST.minmod) {
		if (ST.count == ARG2(ST.me) /* max */)
		    sayNO;
		goto curlym_do_A; /* try to match a further A */
	    }
	    /* backtrack one A */
	    if (ST.count == ARG1(ST.me) /* min */)
		sayNO;
	    ST.count--;
	    locinput = HOPc(locinput, -ST.alen);
	    goto curlym_do_B; /* try to match B */

#undef ST
#define ST st->u.curly

#define CURLY_SETPAREN(paren, success) \
    if (paren) { \
	if (success) { \
	    PL_regoffs[paren].start = HOPc(locinput, -1) - PL_bostr; \
	    PL_regoffs[paren].end = locinput - PL_bostr; \
	    *PL_reglastcloseparen = paren; \
	} \
	else \
	    PL_regoffs[paren].end = -1; \
    }

	case STAR:		/*  /A*B/ where A is width 1 */
	    ST.paren = 0;
	    ST.min = 0;
	    ST.max = REG_INFTY;
	    scan = NEXTOPER(scan);
	    goto repeat;
	case PLUS:		/*  /A+B/ where A is width 1 */
	    ST.paren = 0;
	    ST.min = 1;
	    ST.max = REG_INFTY;
	    scan = NEXTOPER(scan);
	    goto repeat;
	case CURLYN:		/*  /(A){m,n}B/ where A is width 1 */
	    ST.paren = scan->flags;	/* Which paren to set */
	    if (ST.paren > PL_regsize)
		PL_regsize = ST.paren;
	    if (ST.paren > *PL_reglastparen)
		*PL_reglastparen = ST.paren;
	    ST.min = ARG1(scan);  /* min to match */
	    ST.max = ARG2(scan);  /* max to match */
	    if (cur_eval && cur_eval->u.eval.close_paren &&
	        cur_eval->u.eval.close_paren == (U32)ST.paren) {
	        ST.min=1;
	        ST.max=1;
	    }
d3566 4
a3569 4
	case CURLY:		/*  /A{m,n}B/ where A is width 1 */
	    ST.paren = 0;
	    ST.min = ARG1(scan);  /* min to match */
	    ST.max = ARG2(scan);  /* max to match */
d3571 12
d3587 3
a3589 1
	    *
a3594 2
	    if (ST.min > ST.max) /* XXX make this a compile-time check? */
		sayNO;
d3599 1
a3599 2
		if (! HAS_TEXT(text_node)) 
		    FIND_NEXT_IMPT(text_node);
d3601 1
a3601 2
		if (! HAS_TEXT(text_node))
		    ST.c1 = ST.c2 = CHRTEST_VOID;
d3603 2
a3604 2
		    if ( PL_regkind[OP(text_node)] != EXACT ) {
			ST.c1 = ST.c2 = CHRTEST_VOID;
d3607 2
a3608 9
		    else
			s = (U8*)STRING(text_node);
                    
                    /*  Currently we only get here when 
                        
                        PL_rekind[OP(text_node)] == EXACT
                    
                        if this changes back then the macro for IS_TEXT and 
                        friends need to change. */
d3610 5
a3614 5
			ST.c2 = ST.c1 = *s;
			if (IS_TEXTF(text_node))
			    ST.c2 = PL_fold[ST.c1];
			else if (IS_TEXTFL(text_node))
			    ST.c2 = PL_fold_locale[ST.c1];
d3617 1
a3617 1
			if (IS_TEXTF(text_node)) {
d3624 5
a3628 13
#ifdef EBCDIC
			     ST.c1 = utf8n_to_uvchr(tmpbuf1, UTF8_MAXLEN, 0,
						    ckWARN(WARN_UTF8) ?
                                                    0 : UTF8_ALLOW_ANY);
			     ST.c2 = utf8n_to_uvchr(tmpbuf2, UTF8_MAXLEN, 0,
                                                    ckWARN(WARN_UTF8) ?
                                                    0 : UTF8_ALLOW_ANY);
#else
			     ST.c1 = utf8n_to_uvuni(tmpbuf1, UTF8_MAXBYTES, 0,
						    uniflags);
			     ST.c2 = utf8n_to_uvuni(tmpbuf2, UTF8_MAXBYTES, 0,
						    uniflags);
#endif
d3631 1
a3631 1
			    ST.c2 = ST.c1 = utf8n_to_uvchr(s, UTF8_MAXBYTES, 0,
d3638 1
a3638 1
		ST.c1 = ST.c2 = CHRTEST_VOID;
a3639 3

	    ST.A = scan;
	    ST.B = next;
d3642 1
d3644 1
a3644 1
		if (ST.min && regrepeat(rex, ST.A, ST.min, depth) < ST.min)
a3645 1
		ST.count = ST.min;
d3647 85
a3731 19
		REGCP_SET(ST.cp);
		if (ST.c1 == CHRTEST_VOID)
		    goto curly_try_B_min;

		ST.oldloc = locinput;

		/* set ST.maxpos to the furthest point along the
		 * string that could possibly match */
		if  (ST.max == REG_INFTY) {
		    ST.maxpos = PL_regeol - 1;
		    if (do_utf8)
			while (UTF8_IS_CONTINUATION(*(U8*)ST.maxpos))
			    ST.maxpos--;
		}
		else if (do_utf8) {
		    int m = ST.max - ST.min;
		    for (ST.maxpos = locinput;
			 m >0 && ST.maxpos + UTF8SKIP(ST.maxpos) <= PL_regeol; m--)
			ST.maxpos += UTF8SKIP(ST.maxpos);
d3733 31
a3763 4
		else {
		    ST.maxpos = locinput + ST.max - ST.min;
		    if (ST.maxpos >= PL_regeol)
			ST.maxpos = PL_regeol - 1;
a3764 2
		goto curly_try_B_min_known;

d3767 2
a3768 1
		ST.count = regrepeat(rex, ST.A, ST.max, depth);
d3770 3
a3772 4
		if (ST.count < ST.min)
		    sayNO;
		if ((ST.count > ST.min)
		    && (PL_regkind[OP(ST.B)] == EOL) && (OP(ST.B) != MEOL))
d3774 2
a3775 4
		    /* A{m,n} must come at the end of the string, there's
		     * no point in backing off ... */
		    ST.min = ST.count;
		    /* ...except that $ and \Z can match before *and* after
d3777 15
a3791 52
		       We may back off by one in this case. */
		    if (UCHARAT(PL_reginput - 1) == '\n' && OP(ST.B) != EOS)
			ST.min--;
		}
		REGCP_SET(ST.cp);
		goto curly_try_B_max;
	    }
	    /* NOTREACHED */


	case CURLY_B_min_known_fail:
	    /* failed to find B in a non-greedy match where c1,c2 valid */
	    if (ST.paren && ST.count)
		PL_regoffs[ST.paren].end = -1;

	    PL_reginput = locinput;	/* Could be reset... */
	    REGCP_UNWIND(ST.cp);
	    /* Couldn't or didn't -- move forward. */
	    ST.oldloc = locinput;
	    if (do_utf8)
		locinput += UTF8SKIP(locinput);
	    else
		locinput++;
	    ST.count++;
	  curly_try_B_min_known:
	     /* find the next place where 'B' could work, then call B */
	    {
		int n;
		if (do_utf8) {
		    n = (ST.oldloc == locinput) ? 0 : 1;
		    if (ST.c1 == ST.c2) {
			STRLEN len;
			/* set n to utf8_distance(oldloc, locinput) */
			while (locinput <= ST.maxpos &&
			       utf8n_to_uvchr((U8*)locinput,
					      UTF8_MAXBYTES, &len,
					      uniflags) != (UV)ST.c1) {
			    locinput += len;
			    n++;
			}
		    }
		    else {
			/* set n to utf8_distance(oldloc, locinput) */
			while (locinput <= ST.maxpos) {
			    STRLEN len;
			    const UV c = utf8n_to_uvchr((U8*)locinput,
						  UTF8_MAXBYTES, &len,
						  uniflags);
			    if (c == (UV)ST.c1 || c == (UV)ST.c2)
				break;
			    locinput += len;
			    n++;
d3793 9
d3805 19
a3823 10
		    if (ST.c1 == ST.c2) {
			while (locinput <= ST.maxpos &&
			       UCHARAT(locinput) != ST.c1)
			    locinput++;
		    }
		    else {
			while (locinput <= ST.maxpos
			       && UCHARAT(locinput) != ST.c1
			       && UCHARAT(locinput) != ST.c2)
			    locinput++;
a3824 42
		    n = locinput - ST.oldloc;
		}
		if (locinput > ST.maxpos)
		    sayNO;
		/* PL_reginput == oldloc now */
		if (n) {
		    ST.count += n;
		    if (regrepeat(rex, ST.A, n, depth) < n)
			sayNO;
		}
		PL_reginput = locinput;
		CURLY_SETPAREN(ST.paren, ST.count);
		if (cur_eval && cur_eval->u.eval.close_paren && 
		    cur_eval->u.eval.close_paren == (U32)ST.paren) {
		    goto fake_end;
	        }
		PUSH_STATE_GOTO(CURLY_B_min_known, ST.B);
	    }
	    /* NOTREACHED */


	case CURLY_B_min_fail:
	    /* failed to find B in a non-greedy match where c1,c2 invalid */
	    if (ST.paren && ST.count)
		PL_regoffs[ST.paren].end = -1;

	    REGCP_UNWIND(ST.cp);
	    /* failed -- move forward one */
	    PL_reginput = locinput;
	    if (regrepeat(rex, ST.A, 1, depth)) {
		ST.count++;
		locinput = PL_reginput;
		if (ST.count <= ST.max || (ST.max == REG_INFTY &&
			ST.count > 0)) /* count overflow ? */
		{
		  curly_try_B_min:
		    CURLY_SETPAREN(ST.paren, ST.count);
		    if (cur_eval && cur_eval->u.eval.close_paren &&
		        cur_eval->u.eval.close_paren == (U32)ST.paren) {
                        goto fake_end;
                    }
		    PUSH_STATE_GOTO(CURLY_B_min, ST.B);
d3828 1
a3828 37
	    /* NOTREACHED */


	curly_try_B_max:
	    /* a successful greedy match: now try to match B */
            if (cur_eval && cur_eval->u.eval.close_paren &&
                cur_eval->u.eval.close_paren == (U32)ST.paren) {
                goto fake_end;
            }
	    {
		UV c = 0;
		if (ST.c1 != CHRTEST_VOID)
		    c = do_utf8 ? utf8n_to_uvchr((U8*)PL_reginput,
					   UTF8_MAXBYTES, 0, uniflags)
				: (UV) UCHARAT(PL_reginput);
		/* If it could work, try it. */
		if (ST.c1 == CHRTEST_VOID || c == (UV)ST.c1 || c == (UV)ST.c2) {
		    CURLY_SETPAREN(ST.paren, ST.count);
		    PUSH_STATE_GOTO(CURLY_B_max, ST.B);
		    /* NOTREACHED */
		}
	    }
	    /* FALL THROUGH */
	case CURLY_B_max_fail:
	    /* failed to find B in a greedy match */
	    if (ST.paren && ST.count)
		PL_regoffs[ST.paren].end = -1;

	    REGCP_UNWIND(ST.cp);
	    /*  back up. */
	    if (--ST.count < ST.min)
		sayNO;
	    PL_reginput = locinput = HOPc(locinput, -1);
	    goto curly_try_B_max;

#undef ST

d3830 26
a3855 16
	    fake_end:
	    if (cur_eval) {
		/* we've just finished A in /(??{A})B/; now continue with B */
		I32 tmpix;
		st->u.eval.toggle_reg_flags
			    = cur_eval->u.eval.toggle_reg_flags;
		PL_reg_flags ^= st->u.eval.toggle_reg_flags; 

		st->u.eval.prev_rex = rex;		/* inner */
		SETREX(rex,cur_eval->u.eval.prev_rex);
		rexi = RXi_GET(rex);
		cur_curlyx = cur_eval->u.eval.prev_curlyx;
		ReREFCNT_inc(rex);
		st->u.eval.cp = regcppush(0);	/* Save *all* the positions. */
		REGCP_SET(st->u.eval.lastcp);
		PL_reginput = locinput;
d3857 6
a3862 17
		/* Restore parens of the outer rex without popping the
		 * savestack */
		tmpix = PL_savestack_ix;
		PL_savestack_ix = cur_eval->u.eval.lastcp;
		regcppop(rex);
		PL_savestack_ix = tmpix;

		st->u.eval.prev_eval = cur_eval;
		cur_eval = cur_eval->u.eval.prev_eval;
		DEBUG_EXECUTE_r(
		    PerlIO_printf(Perl_debug_log, "%*s  EVAL trying tail ... %"UVxf"\n",
				      REPORT_CODE_OFF+depth*2, "",PTR2UV(cur_eval)););
                if ( nochange_depth )
	            nochange_depth--;

                PUSH_YES_STATE_GOTO(EVAL_AB,
			st->u.eval.prev_eval->u.eval.B); /* match B */
d3864 2
a3865 3

	    if (locinput < reginfo->till) {
		DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
d3869 1
a3869 1
				      (long)(reginfo->till - PL_reg_starttry),
d3871 1
a3871 2
               				      
		sayNO_SILENT;		/* Cannot match: too short. */
d3874 2
a3875 7
	    sayYES;			/* Success! */

	case SUCCEED: /* successful SUSPEND/UNLESSM/IFMATCH/CURLYM */
	    DEBUG_EXECUTE_r(
	    PerlIO_printf(Perl_debug_log,
		"%*s  %ssubpattern success...%s\n",
		REPORT_CODE_OFF+depth*2, "", PL_colors[4], PL_colors[5]));
d3877 3
a3879 7
	    sayYES;			/* Success! */

#undef  ST
#define ST st->u.ifmatch

	case SUSPEND:	/* (?>A) */
	    ST.wanted = 1;
d3882 13
a3894 8

	case UNLESSM:	/* -ve lookaround: (?!A), or with flags, (?<!A) */
	    ST.wanted = 0;
	    goto ifmatch_trivial_fail_test;

	case IFMATCH:	/* +ve lookaround: (?=A), or with flags, (?<=A) */
	    ST.wanted = 1;
	  ifmatch_trivial_fail_test:
d3896 3
a3898 14
		char * const s = HOPBACKc(locinput, scan->flags);
		if (!s) {
		    /* trivial fail */
		    if (logical) {
			logical = 0;
			sw = 1 - (bool)ST.wanted;
		    }
		    else if (ST.wanted)
			sayNO;
		    next = scan + ARG(scan);
		    if (next == scan)
			next = NULL;
		    break;
		}
d3905 15
a3919 13
	    ST.me = scan;
	    ST.logical = logical;
	    /* execute body of (?...A) */
	    PUSH_YES_STATE_GOTO(IFMATCH_A, NEXTOPER(NEXTOPER(scan)));
	    /* NOTREACHED */

	case IFMATCH_A_fail: /* body of (?...A) failed */
	    ST.wanted = !ST.wanted;
	    /* FALL THROUGH */

	case IFMATCH_A: /* body of (?...A) succeeded */
	    if (ST.logical) {
		sw = (bool)ST.wanted;
d3921 1
a3921 4
	    else if (!ST.wanted)
		sayNO;

	    if (OP(ST.me) == SUSPEND)
a3922 2
	    else {
		locinput = PL_reginput = st->locinput;
d3925 1
a3925 7
	    scan = ST.me + ARG(ST.me);
	    if (scan == ST.me)
		scan = NULL;
	    continue; /* execute B */

#undef ST

d3927 1
a3931 144
	case COMMIT:
	    reginfo->cutpoint = PL_regeol;
	    /* FALLTHROUGH */
	case PRUNE:
	    PL_reginput = locinput;
	    if (!scan->flags)
	        sv_yes_mark = sv_commit = (SV*)rexi->data->data[ ARG( scan ) ];
	    PUSH_STATE_GOTO(COMMIT_next,next);
	    /* NOTREACHED */
	case COMMIT_next_fail:
	    no_final = 1;    
	    /* FALLTHROUGH */	    
	case OPFAIL:
	    sayNO;
	    /* NOTREACHED */

#define ST st->u.mark
        case MARKPOINT:
            ST.prev_mark = mark_state;
            ST.mark_name = sv_commit = sv_yes_mark 
                = (SV*)rexi->data->data[ ARG( scan ) ];
            mark_state = st;
            ST.mark_loc = PL_reginput = locinput;
            PUSH_YES_STATE_GOTO(MARKPOINT_next,next);
            /* NOTREACHED */
        case MARKPOINT_next:
            mark_state = ST.prev_mark;
            sayYES;
            /* NOTREACHED */
        case MARKPOINT_next_fail:
            if (popmark && sv_eq(ST.mark_name,popmark)) 
            {
                if (ST.mark_loc > startpoint)
	            reginfo->cutpoint = HOPBACKc(ST.mark_loc, 1);
                popmark = NULL; /* we found our mark */
                sv_commit = ST.mark_name;

                DEBUG_EXECUTE_r({
                        PerlIO_printf(Perl_debug_log,
		            "%*s  %ssetting cutpoint to mark:%"SVf"...%s\n",
		            REPORT_CODE_OFF+depth*2, "", 
		            PL_colors[4], SVfARG(sv_commit), PL_colors[5]);
		});
            }
            mark_state = ST.prev_mark;
            sv_yes_mark = mark_state ? 
                mark_state->u.mark.mark_name : NULL;
            sayNO;
            /* NOTREACHED */
        case SKIP:
            PL_reginput = locinput;
            if (scan->flags) {
                /* (*SKIP) : if we fail we cut here*/
                ST.mark_name = NULL;
                ST.mark_loc = locinput;
                PUSH_STATE_GOTO(SKIP_next,next);    
            } else {
                /* (*SKIP:NAME) : if there is a (*MARK:NAME) fail where it was, 
                   otherwise do nothing.  Meaning we need to scan 
                 */
                regmatch_state *cur = mark_state;
                SV *find = (SV*)rexi->data->data[ ARG( scan ) ];
                
                while (cur) {
                    if ( sv_eq( cur->u.mark.mark_name, 
                                find ) ) 
                    {
                        ST.mark_name = find;
                        PUSH_STATE_GOTO( SKIP_next, next );
                    }
                    cur = cur->u.mark.prev_mark;
                }
            }    
            /* Didn't find our (*MARK:NAME) so ignore this (*SKIP:NAME) */
            break;    
	case SKIP_next_fail:
	    if (ST.mark_name) {
	        /* (*CUT:NAME) - Set up to search for the name as we 
	           collapse the stack*/
	        popmark = ST.mark_name;	   
	    } else {
	        /* (*CUT) - No name, we cut here.*/
	        if (ST.mark_loc > startpoint)
	            reginfo->cutpoint = HOPBACKc(ST.mark_loc, 1);
	        /* but we set sv_commit to latest mark_name if there
	           is one so they can test to see how things lead to this
	           cut */    
                if (mark_state) 
                    sv_commit=mark_state->u.mark.mark_name;	            
            } 
            no_final = 1; 
            sayNO;
            /* NOTREACHED */
#undef ST
        case FOLDCHAR:
            n = ARG(scan);
            if ( n == (U32)what_len_TRICKYFOLD(locinput,do_utf8,ln) ) {
                locinput += ln;
            } else if ( 0xDF == n && !do_utf8 && !UTF ) {
                sayNO;
            } else  {
                U8 folded[UTF8_MAXBYTES_CASE+1];
                STRLEN foldlen;
                const char * const l = locinput;
                char *e = PL_regeol;
                to_uni_fold(n, folded, &foldlen);

		if (ibcmp_utf8((const char*) folded, 0,  foldlen, 1,
                	       l, &e, 0,  do_utf8)) {
                        sayNO;
                }
                locinput = e;
            } 
            nextchr = UCHARAT(locinput);  
            break;
        case LNBREAK:
            if ((n=is_LNBREAK(locinput,do_utf8))) {
                locinput += n;
                nextchr = UCHARAT(locinput);
            } else
                sayNO;
            break;

#define CASE_CLASS(nAmE)                              \
        case nAmE:                                    \
            if ((n=is_##nAmE(locinput,do_utf8))) {    \
                locinput += n;                        \
                nextchr = UCHARAT(locinput);          \
            } else                                    \
                sayNO;                                \
            break;                                    \
        case N##nAmE:                                 \
            if ((n=is_##nAmE(locinput,do_utf8))) {    \
                sayNO;                                \
            } else {                                  \
                locinput += UTF8SKIP(locinput);       \
                nextchr = UCHARAT(locinput);          \
            }                                         \
            break

        CASE_CLASS(VERTWS);
        CASE_CLASS(HORIZWS);
#undef CASE_CLASS

a3935 51
	    
	} /* end switch */ 

        /* switch break jumps here */
	scan = next; /* prepare to execute the next op and ... */
	continue;    /* ... jump back to the top, reusing st */
	/* NOTREACHED */

      push_yes_state:
	/* push a state that backtracks on success */
	st->u.yes.prev_yes_state = yes_state;
	yes_state = st;
	/* FALL THROUGH */
      push_state:
	/* push a new regex state, then continue at scan  */
	{
	    regmatch_state *newst;

	    DEBUG_STACK_r({
	        regmatch_state *cur = st;
	        regmatch_state *curyes = yes_state;
	        int curd = depth;
	        regmatch_slab *slab = PL_regmatch_slab;
                for (;curd > -1;cur--,curd--) {
                    if (cur < SLAB_FIRST(slab)) {
                	slab = slab->prev;
                	cur = SLAB_LAST(slab);
                    }
                    PerlIO_printf(Perl_error_log, "%*s#%-3d %-10s %s\n",
                        REPORT_CODE_OFF + 2 + depth * 2,"",
                        curd, PL_reg_name[cur->resume_state],
                        (curyes == cur) ? "yes" : ""
                    );
                    if (curyes == cur)
	                curyes = cur->u.yes.prev_yes_state;
                }
            } else 
                DEBUG_STATE_pp("push")
            );
	    depth++;
	    st->locinput = locinput;
	    newst = st+1; 
	    if (newst >  SLAB_LAST(PL_regmatch_slab))
		newst = S_push_slab(aTHX);
	    PL_regmatch_state = newst;

	    locinput = PL_reginput;
	    nextchr = UCHARAT(locinput);
	    st = newst;
	    continue;
	    /* NOTREACHED */
d3937 2
d3949 10
a3959 4
    if (yes_state) {
	/* we have successfully completed a subexpression, but we must now
	 * pop to the state marked by yes_state and continue from there */
	assert(st != yes_state);
d3961 1
a3961 25
	while (st != yes_state) {
	    st--;
	    if (st < SLAB_FIRST(PL_regmatch_slab)) {
		PL_regmatch_slab = PL_regmatch_slab->prev;
		st = SLAB_LAST(PL_regmatch_slab);
	    }
	    DEBUG_STATE_r({
	        if (no_final) {
	            DEBUG_STATE_pp("pop (no final)");        
	        } else {
	            DEBUG_STATE_pp("pop (yes)");
	        }
	    });
	    depth--;
	}
#else
	while (yes_state < SLAB_FIRST(PL_regmatch_slab)
	    || yes_state > SLAB_LAST(PL_regmatch_slab))
	{
	    /* not in this slab, pop slab */
	    depth -= (st - SLAB_FIRST(PL_regmatch_slab) + 1);
	    PL_regmatch_slab = PL_regmatch_slab->prev;
	    st = SLAB_LAST(PL_regmatch_slab);
	}
	depth -= (st - yes_state);
a3962 11
	st = yes_state;
	yes_state = st->u.yes.prev_yes_state;
	PL_regmatch_state = st;
        
        if (no_final) {
            locinput= st->locinput;
            nextchr = UCHARAT(locinput);
        }
	state_num = st->resume_state + no_final;
	goto reenter_switch;
    }
d3964 5
a3968 14
    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "%sMatch successful!%s\n",
			  PL_colors[4], PL_colors[5]));

    if (PL_reg_eval_set) {
	/* each successfully executed (?{...}) block does the equivalent of
	 *   local $^R = do {...}
	 * When popping the save stack, all these locals would be undone;
	 * bypass this by setting the outermost saved $^R to the latest
	 * value */
	if (oreplsv != GvSV(PL_replgv))
	    sv_setsv(oreplsv, GvSV(PL_replgv));
    }
    result = 1;
    goto final_exit;
d3971 1
a3971 1
    DEBUG_EXECUTE_r(
d3973 2
a3974 3
            "%*s  %sfailed...%s\n",
            REPORT_CODE_OFF+depth*2, "", 
            PL_colors[4], PL_colors[5])
d3976 42
d4019 7
a4025 44
no_silent:
    if (no_final) {
        if (yes_state) {
            goto yes;
        } else {
            goto final_exit;
        }
    }    
    if (depth) {
	/* there's a previous state to backtrack to */
	st--;
	if (st < SLAB_FIRST(PL_regmatch_slab)) {
	    PL_regmatch_slab = PL_regmatch_slab->prev;
	    st = SLAB_LAST(PL_regmatch_slab);
	}
	PL_regmatch_state = st;
	locinput= st->locinput;
	nextchr = UCHARAT(locinput);

	DEBUG_STATE_pp("pop");
	depth--;
	if (yes_state == st)
	    yes_state = st->u.yes.prev_yes_state;

	state_num = st->resume_state + 1; /* failure = success + 1 */
	goto reenter_switch;
    }
    result = 0;

  final_exit:
    if (rex->intflags & PREGf_VERBARG_SEEN) {
        SV *sv_err = get_sv("REGERROR", 1);
        SV *sv_mrk = get_sv("REGMARK", 1);
        if (result) {
            sv_commit = &PL_sv_no;
            if (!sv_yes_mark) 
                sv_yes_mark = &PL_sv_yes;
        } else {
            if (!sv_commit) 
                sv_commit = &PL_sv_yes;
            sv_yes_mark = &PL_sv_no;
        }
        sv_setsv(sv_err, sv_commit);
        sv_setsv(sv_mrk, sv_yes_mark);
d4027 4
a4030 5

    /* clean up; in particular, free all slabs above current one */
    LEAVE_SCOPE(oldsave);

    return result;
d4042 1
a4042 1
S_regrepeat(pTHX_ const regexp *prog, const regnode *p, I32 max, int depth)
a4043 1
    dVAR;
a4048 3
#ifndef DEBUGGING
    PERL_UNUSED_ARG(depth);
#endif
d4054 1
a4054 1
	loceol = scan + max;
d4104 1
a4104 1
		   reginclass(prog, p, (U8*)scan, 0, do_utf8)) {
d4109 1
a4109 1
	    while (scan < loceol && REGINCLASS(prog, p, (U8*)scan))
d4211 1
a4212 1
	break;
a4253 69
    case LNBREAK:
        if (do_utf8) {
	    loceol = PL_regeol;
	    while (hardcount < max && scan < loceol && (c=is_LNBREAK_utf8(scan))) {
		scan += c;
		hardcount++;
	    }
	} else {
	    /*
	      LNBREAK can match two latin chars, which is ok,
	      because we have a null terminated string, but we
	      have to use hardcount in this situation
	    */
	    while (scan < loceol && (c=is_LNBREAK_latin1(scan)))  {
		scan+=c;
		hardcount++;
	    }
	}	
	break;
    case HORIZWS:
        if (do_utf8) {
	    loceol = PL_regeol;
	    while (hardcount < max && scan < loceol && (c=is_HORIZWS_utf8(scan))) {
		scan += c;
		hardcount++;
	    }
	} else {
	    while (scan < loceol && is_HORIZWS_latin1(scan)) 
		scan++;		
	}	
	break;
    case NHORIZWS:
        if (do_utf8) {
	    loceol = PL_regeol;
	    while (hardcount < max && scan < loceol && !is_HORIZWS_utf8(scan)) {
		scan += UTF8SKIP(scan);
		hardcount++;
	    }
	} else {
	    while (scan < loceol && !is_HORIZWS_latin1(scan))
		scan++;

	}	
	break;
    case VERTWS:
        if (do_utf8) {
	    loceol = PL_regeol;
	    while (hardcount < max && scan < loceol && (c=is_VERTWS_utf8(scan))) {
		scan += c;
		hardcount++;
	    }
	} else {
	    while (scan < loceol && is_VERTWS_latin1(scan)) 
		scan++;

	}	
	break;
    case NVERTWS:
        if (do_utf8) {
	    loceol = PL_regeol;
	    while (hardcount < max && scan < loceol && !is_VERTWS_utf8(scan)) {
		scan += UTF8SKIP(scan);
		hardcount++;
	    }
	} else {
	    while (scan < loceol && !is_VERTWS_latin1(scan)) 
		scan++;
          
	}	
a4254 1

d4265 8
a4272 8
    DEBUG_r({
	GET_RE_DEBUG_FLAGS_DECL;
	DEBUG_EXECUTE_r({
	    SV * const prop = sv_newmortal();
	    regprop(prog, prop, p);
	    PerlIO_printf(Perl_debug_log,
			"%*s  %s can match %"IVdf" times out of %"IVdf"...\n",
			REPORT_CODE_OFF + depth*2, "", SvPVX_const(prop),(IV)c,(IV)max);
a4273 1
    });
d4278 51
a4329 1
#if !defined(PERL_IN_XSUB_RE) || defined(PLUGGABLE_RE_EXTENSION)
d4335 1
a4335 1
Perl_regclass_swash(pTHX_ const regexp *prog, register const regnode* node, bool doinit, SV** listsvp, SV **altsvp)
a4336 1
    dVAR;
a4339 2
    RXi_GET_DECL(prog,progi);
    const struct reg_data * const data = prog ? progi->data : NULL;
d4341 1
a4341 1
    if (data && data->count) {
d4344 2
a4345 2
	if (data->what[n] == 's') {
	    SV * const rv = (SV*)data->data[n];
d4350 1
a4350 1
	    /* See the end of regcomp.c:S_regclass() for
d4354 2
a4355 2
	    a  = SvROK(ary[1]) ? &ary[1] : NULL;
	    b  = SvTYPE(ary[2]) == SVt_PVAV ? &ary[2] : NULL;
a4374 1
#endif
d4387 1
a4387 1
S_reginclass(pTHX_ const regexp *prog, register const regnode *n, register const U8* p, STRLEN* lenp, register bool do_utf8)
a4388 1
    dVAR;
d4396 4
a4399 4
	c = utf8n_to_uvchr(p, UTF8_MAXBYTES, &len,
		(UTF8_ALLOW_DEFAULT & UTF8_ALLOW_ANYUV) | UTF8_CHECK_ONLY);
		/* see [perl #37836] for UTF8_ALLOW_ANYUV */
	if (len == (STRLEN)-1) 
d4415 1
a4415 1
	    SV * const sw = regclass_swash(prog, n, TRUE, 0, (SV**)&av);
d4418 1
a4418 1
		if (swash_fetch(sw, p, do_utf8))
d4439 1
a4439 1
		        to_utf8_fold(p, tmpbuf, &tmplen);
d4509 7
a4515 1
S_reghop3(U8 *s, I32 off, const U8* lim)
a4516 1
    dVAR;
d4524 8
a4531 5
        while (off++ && s > lim) {
            s--;
            if (UTF8_IS_CONTINUED(*s)) {
                while (s > lim && UTF8_IS_CONTINUATION(*s))
                    s--;
a4532 1
            /* XXX could check well-formedness here */
a4537 5
#ifdef XXX_dmq
/* there are a bunch of places where we use two reghop3's that should
   be replaced with this routine. but since thats not done yet 
   we ifdef it out - dmq
*/
d4539 1
a4539 1
S_reghop4(U8 *s, I32 off, const U8* llim, const U8* rlim)
d4541 1
a4541 18
    dVAR;
    if (off >= 0) {
        while (off-- && s < rlim) {
            /* XXX could check well-formedness here */
            s += UTF8SKIP(s);
        }
    }
    else {
        while (off++ && s > llim) {
            s--;
            if (UTF8_IS_CONTINUED(*s)) {
                while (s > llim && UTF8_IS_CONTINUATION(*s))
                    s--;
            }
            /* XXX could check well-formedness here */
        }
    }
    return s;
a4542 1
#endif
d4545 1
a4545 1
S_reghopmaybe3(U8* s, I32 off, const U8* lim)
a4546 1
    dVAR;
d4553 1
a4553 1
	    return NULL;
d4556 8
a4563 5
        while (off++ && s > lim) {
            s--;
            if (UTF8_IS_CONTINUED(*s)) {
                while (s > lim && UTF8_IS_CONTINUATION(*s))
                    s--;
d4565 2
a4566 1
            /* XXX could check well-formedness here */
d4569 1
a4569 1
	    return NULL;
d4577 1
a4577 2
    dVAR;
    regexp * const rex = (regexp *)arg;
d4580 3
a4582 6
	    rex->subbeg = PL_reg_oldsaved;
	    rex->sublen = PL_reg_oldsavedlen;
#ifdef PERL_OLD_COPY_ON_WRITE
	    rex->saved_copy = PL_nrs;
#endif
	    RX_MATCH_COPIED_on(rex);
d4593 18
a4610 23
    int i = 1;
    do {
	if (prog->substrs->data[i].substr
	    && !prog->substrs->data[i].utf8_substr) {
	    SV* const sv = newSVsv(prog->substrs->data[i].substr);
	    prog->substrs->data[i].utf8_substr = sv;
	    sv_utf8_upgrade(sv);
	    if (SvVALID(prog->substrs->data[i].substr)) {
		const U8 flags = BmFLAGS(prog->substrs->data[i].substr);
		if (flags & FBMcf_TAIL) {
		    /* Trim the trailing \n that fbm_compile added last
		       time.  */
		    SvCUR_set(sv, SvCUR(sv) - 1);
		    /* Whilst this makes the SV technically "invalid" (as its
		       buffer is no longer followed by "\0") when fbm_compile()
		       adds the "\n" back, a "\0" is restored.  */
		}
		fbm_compile(sv, flags);
	    }
	    if (prog->substrs->data[i].substr == prog->check_substr)
		prog->check_utf8 = sv;
	}
    } while (i--);
d4616 22
a4637 24
    dVAR;
    int i = 1;
    do {
	if (prog->substrs->data[i].utf8_substr
	    && !prog->substrs->data[i].substr) {
	    SV* sv = newSVsv(prog->substrs->data[i].utf8_substr);
	    if (sv_utf8_downgrade(sv, TRUE)) {
		if (SvVALID(prog->substrs->data[i].utf8_substr)) {
		    const U8 flags
			= BmFLAGS(prog->substrs->data[i].utf8_substr);
		    if (flags & FBMcf_TAIL) {
			/* Trim the trailing \n that fbm_compile added last
			   time.  */
			SvCUR_set(sv, SvCUR(sv) - 1);
		    }
		    fbm_compile(sv, flags);
		}	    
	    } else {
		SvREFCNT_dec(sv);
		sv = &PL_sv_undef;
	    }
	    prog->substrs->data[i].substr = sv;
	    if (prog->substrs->data[i].utf8_substr == prog->check_utf8)
		prog->check_substr = sv;
d4639 3
a4641 1
    } while (i--);
@


1.1.1.11
log
@import perl 5.10.1
@
text
@d5 1
a5 5
 * 	One Ring to rule them all, One Ring to find them
 &
 *     [p.v of _The Lord of the Rings_, opening poem]
 *     [p.50 of _The Lord of the Rings_, I/iii: "The Shadow of the Past"]
 *     [p.254 of _The Lord of the Rings_, II/ii: "The Council of Elrond"]
d59 1
a59 2
 ****    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
 ****    by Larry Wall and others
d240 1
a242 2
    PERL_ARGS_ASSERT_REGCPPOP;

a316 2
    PERL_ARGS_ASSERT_PREGEXEC;

d394 1
a396 2
    PERL_ARGS_ASSERT_RE_INTUIT_START;

d399 1
a399 1
    if (RX_UTF8(prog)) {
d504 1
a504 1
		   (IV)end_shift, RX_PRECOMP(prog));
d539 1
a539 1
	if (s && RXp_MATCH_COPIED(prog))
a999 1
    UV uvc_unfolded = 0;						    \
d1003 1
a1003 1
	    uvc_unfolded = uvc = utf8n_to_uvuni( uscan, UTF8_MAXLEN, &len, uniflags ); \
d1008 1
a1008 1
	    uvc_unfolded = uvc = utf8n_to_uvuni( (U8*)uc, UTF8_MAXLEN, &len, uniflags ); \
a1046 3
    if (!charid && trie_type == trie_utf8_fold && !UTF) {		    \
	charid = trie->charmap[uvc_unfolded];			    	    \
    }								    	    \
a1182 2

	PERL_ARGS_ASSERT_FIND_BYCLASS;
d1511 1
a1511 1
		HV *widecharmap = MUTABLE_HV(progi->data->data[ aho->trie + 1 ]);
d1722 1
a1722 2
S_swap_match_buff (pTHX_ regexp *prog)
{
a1724 2
    PERL_ARGS_ASSERT_SWAP_MATCH_BUFF;

d1769 1
a1771 1
    PERL_ARGS_ASSERT_REGEXEC_FLAGS;
d1807 1
a1807 1
    if (RX_UTF8(prog))
d2012 1
a2012 1
	    if ((flags & REXEC_SCREAM) && RXp_MATCH_COPIED(prog))
d2090 1
a2090 1
		else if (RXp_MATCH_COPIED(prog))
d2151 2
a2152 2
    if (RXp_PAREN_NAMES(prog)) 
        (void)hv_iterinit(RXp_PAREN_NAMES(prog));
a2210 3

    PERL_ARGS_ASSERT_REGTRY;

d2233 1
a2233 1
		DEFSV_set(reginfo->sv);
d2256 2
a2257 2
                /* this regexp is also owned by the new PL_reg_curpm, which
		   will try to free it.  */
a2263 9
#ifdef USE_ITHREADS
	/* It seems that non-ithreads works both with and without this code.
	   So for efficiency reasons it seems best not to have the code
	   compiled when it is not needed.  */
	/* This is safe against NULLs: */
	ReREFCNT_dec(PM_GETRE(PL_reg_curpm));
	/* PM_reg_curpm owns a reference to this regexp.  */
	ReREFCNT_inc(prog);
#endif
d2267 1
a2267 1
	if (RXp_MATCH_COPIED(prog)) {
d2276 1
a2276 1
	    RXp_MATCH_COPIED_off(prog);
d2553 1
a2553 1
S_debug_start_match(pTHX_ const REGEXP *prog, const bool do_utf8, 
d2556 1
a2556 4
    const bool utf8_pat = RX_UTF8(prog) ? 1 : 0;

    PERL_ARGS_ASSERT_DEBUG_START_MATCH;

d2561 1
a2561 1
            RX_PRECOMP_const(prog), RX_PRELEN(prog), 60);   
a2599 2
    PERL_ARGS_ASSERT_DUMP_EXEC_POS;

d2650 1
a2650 2
S_reg_check_named_buff_matched(pTHX_ const regexp *rex, const regnode *scan)
{
d2653 1
a2653 1
    SV *sv_dat= MUTABLE_SV(rexi->data->data[ ARG( scan ) ]);
a2654 3

    PERL_ARGS_ASSERT_REG_CHECK_NAMED_BUFF_MATCHED;

d2698 1
d2701 1
d2703 1
d2706 1
d2721 1
d2727 1
d2740 1
d2742 2
d2758 1
a2762 2
    PERL_ARGS_ASSERT_REGMATCH;

a2808 5

	assert(PL_reglastparen == &rex->lastparen);
	assert(PL_reglastcloseparen == &rex->lastcloseparen);
	assert(PL_regoffs == rex->offs);

d2918 1
a2918 1
		HV * widecharmap = MUTABLE_HV(rexi->data->data[ ARG( scan ) + 1 ]);
d2975 1
a2975 1
			    SAVETMPS; /* XXX is this necessary? dmq */
d3075 1
a3075 1
			= MUTABLE_AV(rexi->data->data[ARG(ST.me)+TRIE_WORDS_OFFSET]);
d3157 1
a3157 1
			= MUTABLE_AV(rexi->data->data[ARG(ST.me)+TRIE_WORDS_OFFSET]);
a3193 3
	    /* we dont want to throw this away, see bug 57042*/
	    if (oreplsv != GvSV(PL_replgv))
		sv_setsv(oreplsv, GvSV(PL_replgv));
d3734 1
a3734 1
			    sv_magic(ret,MUTABLE_SV(ReREFCNT_inc(re)),
d3739 1
a3739 1
                RXp_MATCH_COPIED_off(re);
d3765 2
a3766 6
		/* see regtry, specifically PL_reglast(?:close)?paren is a pointer! (i dont know why) :dmq */
		PL_reglastparen = &re->lastparen;
		PL_reglastcloseparen = &re->lastcloseparen;
		re->lastparen = 0;
		re->lastcloseparen = 0;

d3774 1
a3774 1
		if (RX_UTF8(re))
a3806 7

	    /* rex was changed so update the pointer in PL_reglastparen and PL_reglastcloseparen */
	    PL_reglastparen = &rex->lastparen;
	    PL_reglastcloseparen = &rex->lastcloseparen;
	    /* also update PL_regoffs */
	    PL_regoffs = rex->offs;
	    
a3819 4
	    /* rex was changed so update the pointer in PL_reglastparen and PL_reglastcloseparen */
	    PL_reglastparen = &rex->lastparen;
	    PL_reglastcloseparen = &rex->lastcloseparen;

d4264 1
a4264 1
                MUTABLE_SV(rexi->data->data[ ARG( scan ) ]);
d4312 1
a4312 1
	     * only a single backtracking state, no matter how many matches
d4379 2
a4380 5
	    {
		I32 max = (ST.minmod ? ARG1(ST.me) : ARG2(ST.me));
		if ( max == REG_INFTY || ST.count < max )
		    goto curlym_do_A; /* try to match another A */
	    }
d4472 1
a4472 2
		I32 max = ARG2(ST.me);
		if (max != REG_INFTY && ST.count == max)
a4817 5

		/* rex was changed so update the pointer in PL_reglastparen and PL_reglastcloseparen */
		PL_reglastparen = &rex->lastparen;
		PL_reglastcloseparen = &rex->lastcloseparen;

a4898 2
	    logical = 0; /* XXX: reset state of logical once it has been saved into ST */
	    
d4938 1
a4938 1
	        sv_yes_mark = sv_commit = MUTABLE_SV(rexi->data->data[ ARG( scan ) ]);
d4952 1
a4952 1
                = MUTABLE_SV(rexi->data->data[ ARG( scan ) ]);
d4993 1
a4993 1
                SV *find = MUTABLE_SV(rexi->data->data[ ARG( scan ) ]);
a5281 2
    PERL_ARGS_ASSERT_REGREPEAT;

a5596 2
    PERL_ARGS_ASSERT_REGCLASS_SWASH;

d5601 2
a5602 2
	    SV * const rv = MUTABLE_SV(data->data[n]);
	    AV * const av = MUTABLE_AV(SvRV(rv));
a5652 2
    PERL_ARGS_ASSERT_REGINCLASS;

d5676 1
a5676 8
		U8 * utf8_p;
		if (do_utf8) {
		    utf8_p = (U8 *) p;
		} else {
		    STRLEN len = 1;
		    utf8_p = bytes_to_utf8(p, &len);
		}
		if (swash_fetch(sw, utf8_p, 1))
d5685 2
a5686 1
			    if (len <= plen && memEQ(s, (char*)utf8_p, len)) {
d5695 1
d5697 2
a5698 3
			STRLEN tmplen;
			to_utf8_fold(utf8_p, tmpbuf, &tmplen);
			if (swash_fetch(sw, tmpbuf, 1))
a5701 3

		/* If we allocated a string above, free it */
		if (! do_utf8) Safefree(utf8_p);
a5769 3

    PERL_ARGS_ASSERT_REGHOP3;

a5797 3

    PERL_ARGS_ASSERT_REGHOP4;

a5821 3

    PERL_ARGS_ASSERT_REGHOPMAYBE3;

d5857 1
a5857 1
	    RXp_MATCH_COPIED_on(rex);
a5868 3

    PERL_ARGS_ASSERT_TO_UTF8_SUBSTR;

a5897 3

    PERL_ARGS_ASSERT_TO_BYTE_SUBSTR;

@


1.1.1.12
log
@Perl 5.12.2 from CPAN
@
text
@a119 1
/* these are unrolled below in the CCC_TRY_XXX defined */
a121 5

/* Doesn't do an assert to verify that is correct */
#define LOAD_UTF8_CHARCLASS_NO_CHECK(class) STMT_START { \
    if (!CAT2(PL_utf8_,class)) { bool ok; ENTER; save_re_context(); ok=CAT2(is_utf8_,class)((const U8*)" "); LEAVE; } } STMT_END

d125 1
a125 113

#define LOAD_UTF8_CHARCLASS_GCB()  /* Grapheme cluster boundaries */        \
	LOAD_UTF8_CHARCLASS(X_begin, " ");                                  \
	LOAD_UTF8_CHARCLASS(X_non_hangul, "A");                             \
	/* These are utf8 constants, and not utf-ebcdic constants, so the   \
	    * assert should likely and hopefully fail on an EBCDIC machine */ \
	LOAD_UTF8_CHARCLASS(X_extend, "\xcc\x80"); /* U+0300 */             \
									    \
	/* No asserts are done for these, in case called on an early        \
	    * Unicode version in which they map to nothing */               \
	LOAD_UTF8_CHARCLASS_NO_CHECK(X_prepend);/* U+0E40 "\xe0\xb9\x80" */ \
	LOAD_UTF8_CHARCLASS_NO_CHECK(X_L);	    /* U+1100 "\xe1\x84\x80" */ \
	LOAD_UTF8_CHARCLASS_NO_CHECK(X_LV);     /* U+AC00 "\xea\xb0\x80" */ \
	LOAD_UTF8_CHARCLASS_NO_CHECK(X_LVT);    /* U+AC01 "\xea\xb0\x81" */ \
	LOAD_UTF8_CHARCLASS_NO_CHECK(X_LV_LVT_V);/* U+AC01 "\xea\xb0\x81" */\
	LOAD_UTF8_CHARCLASS_NO_CHECK(X_T);      /* U+11A8 "\xe1\x86\xa8" */ \
	LOAD_UTF8_CHARCLASS_NO_CHECK(X_V)       /* U+1160 "\xe1\x85\xa0" */  

/* 
   We dont use PERL_LEGACY_UNICODE_CHARCLASS_MAPPINGS as the direct test
   so that it is possible to override the option here without having to 
   rebuild the entire core. as we are required to do if we change regcomp.h
   which is where PERL_LEGACY_UNICODE_CHARCLASS_MAPPINGS is defined.
*/
#if PERL_LEGACY_UNICODE_CHARCLASS_MAPPINGS
#define BROKEN_UNICODE_CHARCLASS_MAPPINGS
#endif

#ifdef BROKEN_UNICODE_CHARCLASS_MAPPINGS
#define LOAD_UTF8_CHARCLASS_PERL_WORD()   LOAD_UTF8_CHARCLASS_ALNUM()
#define LOAD_UTF8_CHARCLASS_PERL_SPACE()  LOAD_UTF8_CHARCLASS_SPACE()
#define LOAD_UTF8_CHARCLASS_POSIX_DIGIT() LOAD_UTF8_CHARCLASS_DIGIT()
#define RE_utf8_perl_word   PL_utf8_alnum
#define RE_utf8_perl_space  PL_utf8_space
#define RE_utf8_posix_digit PL_utf8_digit
#define perl_word  alnum
#define perl_space space
#define posix_digit digit
#else
#define LOAD_UTF8_CHARCLASS_PERL_WORD()   LOAD_UTF8_CHARCLASS(perl_word,"a")
#define LOAD_UTF8_CHARCLASS_PERL_SPACE()  LOAD_UTF8_CHARCLASS(perl_space," ")
#define LOAD_UTF8_CHARCLASS_POSIX_DIGIT() LOAD_UTF8_CHARCLASS(posix_digit,"0")
#define RE_utf8_perl_word   PL_utf8_perl_word
#define RE_utf8_perl_space  PL_utf8_perl_space
#define RE_utf8_posix_digit PL_utf8_posix_digit
#endif


#define CCC_TRY_AFF(NAME,NAMEL,CLASS,STR,LCFUNC_utf8,FUNC,LCFUNC)                          \
        case NAMEL:                                                              \
            PL_reg_flags |= RF_tainted;                                                 \
            /* FALL THROUGH */                                                          \
        case NAME:                                                                     \
            if (!nextchr)                                                               \
                sayNO;                                                                  \
            if (do_utf8 && UTF8_IS_CONTINUED(nextchr)) {                                \
                if (!CAT2(PL_utf8_,CLASS)) {                                            \
                    bool ok;                                                            \
                    ENTER;                                                              \
                    save_re_context();                                                  \
                    ok=CAT2(is_utf8_,CLASS)((const U8*)STR);                            \
                    assert(ok);                                                         \
                    LEAVE;                                                              \
                }                                                                       \
                if (!(OP(scan) == NAME                                                  \
                    ? (bool)swash_fetch(CAT2(PL_utf8_,CLASS), (U8*)locinput, do_utf8)   \
                    : LCFUNC_utf8((U8*)locinput)))                                      \
                {                                                                       \
                    sayNO;                                                              \
                }                                                                       \
                locinput += PL_utf8skip[nextchr];                                       \
                nextchr = UCHARAT(locinput);                                            \
                break;                                                                  \
            }                                                                           \
            if (!(OP(scan) == NAME ? FUNC(nextchr) : LCFUNC(nextchr)))                  \
                sayNO;                                                                  \
            nextchr = UCHARAT(++locinput);                                              \
            break

#define CCC_TRY_NEG(NAME,NAMEL,CLASS,STR,LCFUNC_utf8,FUNC,LCFUNC)                        \
        case NAMEL:                                                              \
            PL_reg_flags |= RF_tainted;                                                 \
            /* FALL THROUGH */                                                          \
        case NAME :                                                                     \
            if (!nextchr && locinput >= PL_regeol)                                      \
                sayNO;                                                                  \
            if (do_utf8 && UTF8_IS_CONTINUED(nextchr)) {                                \
                if (!CAT2(PL_utf8_,CLASS)) {                                            \
                    bool ok;                                                            \
                    ENTER;                                                              \
                    save_re_context();                                                  \
                    ok=CAT2(is_utf8_,CLASS)((const U8*)STR);                            \
                    assert(ok);                                                         \
                    LEAVE;                                                              \
                }                                                                       \
                if ((OP(scan) == NAME                                                  \
                    ? (bool)swash_fetch(CAT2(PL_utf8_,CLASS), (U8*)locinput, do_utf8)    \
                    : LCFUNC_utf8((U8*)locinput)))                                      \
                {                                                                       \
                    sayNO;                                                              \
                }                                                                       \
                locinput += PL_utf8skip[nextchr];                                       \
                nextchr = UCHARAT(locinput);                                            \
                break;                                                                  \
            }                                                                           \
            if ((OP(scan) == NAME ? FUNC(nextchr) : LCFUNC(nextchr)))                   \
                sayNO;                                                                  \
            nextchr = UCHARAT(++locinput);                                              \
            break




d382 1
a382 1
Perl_re_intuit_start(pTHX_ REGEXP * const rx, SV *sv, char *strpos,
a385 1
    struct regexp *const prog = (struct regexp *)SvANY(rx);
d406 1
a406 1
    RX_MATCH_UTF8_set(rx,do_utf8);
d408 1
a408 1
    if (RX_UTF8(rx)) {
d412 1
a412 1
        debug_start_match(rx, do_utf8, strpos, strend, 
a864 1
	    /* XXX Does the destruction order has to change with do_utf8? */
d866 2
a867 1
	    SvREFCNT_dec(do_utf8 ? prog->check_substr : prog->check_utf8);
d1009 1
d1013 1
a1013 1
	    uvc = utf8n_to_uvuni( uscan, UTF8_MAXLEN, &len, uniflags ); \
d1018 1
a1018 1
	    uvc = utf8n_to_uvuni( (U8*)uc, UTF8_MAXLEN, &len, uniflags ); \
d1044 1
d1057 3
d1428 2
a1429 2
		LOAD_UTF8_CHARCLASS_PERL_WORD(),
		swash_fetch(RE_utf8_perl_word, (U8*)s, do_utf8),
d1439 2
a1440 2
		LOAD_UTF8_CHARCLASS_PERL_WORD(),
		!swash_fetch(RE_utf8_perl_word, (U8*)s, do_utf8),
d1450 2
a1451 2
		LOAD_UTF8_CHARCLASS_PERL_SPACE(),
		*s == ' ' || swash_fetch(RE_utf8_perl_space,(U8*)s, do_utf8),
d1461 2
a1462 2
		LOAD_UTF8_CHARCLASS_PERL_SPACE(),
		!(*s == ' ' || swash_fetch(RE_utf8_perl_space,(U8*)s, do_utf8)),
d1472 2
a1473 2
		LOAD_UTF8_CHARCLASS_POSIX_DIGIT(),
		swash_fetch(RE_utf8_posix_digit,(U8*)s, do_utf8),
d1483 2
a1484 2
		LOAD_UTF8_CHARCLASS_POSIX_DIGIT(),
		!swash_fetch(RE_utf8_posix_digit,(U8*)s, do_utf8),
d1736 22
d1763 1
a1763 1
Perl_regexec_flags(pTHX_ REGEXP * const rx, char *stringarg, register char *strend,
a1773 1
    struct regexp *const prog = (struct regexp *)SvANY(rx);
d1786 1
a1786 1
    regexp_paren_pair *swap = NULL;
d1799 1
a1799 1
    reginfo.prog = rx;	 /* Yes, sorry that this is confusing.  */
d1801 1
a1801 1
    RX_MATCH_UTF8_set(rx, do_utf8);
d1803 1
a1803 1
        debug_start_match(rx, do_utf8, startpos, strend, 
d1825 1
a1825 1
    if (RX_UTF8(rx))
d1844 2
a1845 1
	if (flags & REXEC_IGNOREPOS){	/* Means: check only at start */
d1847 1
a1847 3
	    DEBUG_GPOS_r(PerlIO_printf(Perl_debug_log,
	      "GPOS IGNOREPOS: reginfo.ganch = startpos + %"UVxf"\n",(UV)prog->gofs));
	} else if (sv && SvTYPE(sv) >= SVt_PVMG
a1851 3
	    DEBUG_GPOS_r(PerlIO_printf(Perl_debug_log,
		"GPOS MAGIC: reginfo.ganch = strbeg + %"IVdf"\n",(IV)mg->mg_len));

a1855 4
	        DEBUG_GPOS_r(PerlIO_printf(Perl_debug_log,
		     "GPOS ANCH_GPOS: s = ganch - %"UVxf"\n",(UV)prog->gofs));
		if (s < strbeg)
		    goto phooey;
d1860 1
a1860 4
            DEBUG_GPOS_r(PerlIO_printf(Perl_debug_log,
		 "GPOS DATA: reginfo.ganch= strbeg + %"UVxf"\n",PTR2UV(data)));

	} else {				/* pos() not defined */
a1861 3
            DEBUG_GPOS_r(PerlIO_printf(Perl_debug_log,
		 "GPOS: reginfo.ganch = strbeg\n"));
	}
d1863 4
a1866 11
    if (PL_curpm && (PM_GETRE(PL_curpm) == rx)) {
        /* We have to be careful. If the previous successful match
           was from this regex we don't want a subsequent partially
           successful match to clobber the old results.
           So when we detect this possibility we add a swap buffer
           to the re, and switch the buffer each match. If we fail
           we switch it back, otherwise we leave it swapped.
        */
        swap = prog->offs;
        /* do we need a save destructor here for eval dies? */
        Newxz(prog->offs, (prog->nparens + 1), regexp_paren_pair);
d1873 1
a1873 1
	s = re_intuit_start(rx, sv, s, strend, flags, &d);
d1897 18
a1914 51
                /* because of the goto we can not easily reuse the macros for bifurcating the
                   unicode/non-unicode match modes here like we do elsewhere - demerphq */
                if (do_utf8) {
                    if (s == startpos)
                        goto after_try_utf8;
                    while (1) {
                        if (regtry(&reginfo, &s)) {
                            goto got_it;
                        }
                      after_try_utf8:
                        if (s > end) {
                            goto phooey;
                        }
                        if (prog->extflags & RXf_USE_INTUIT) {
                            s = re_intuit_start(rx, sv, s + UTF8SKIP(s), strend, flags, NULL);
                            if (!s) {
                                goto phooey;
                            }
                        }
                        else {
                            s += UTF8SKIP(s);
                        }
                    }
                } /* end search for check string in unicode */
                else {
                    if (s == startpos) {
                        goto after_try_latin;
                    }
                    while (1) {
                        if (regtry(&reginfo, &s)) {
                            goto got_it;
                        }
                      after_try_latin:
                        if (s > end) {
                            goto phooey;
                        }
                        if (prog->extflags & RXf_USE_INTUIT) {
                            s = re_intuit_start(rx, sv, s + 1, strend, flags, NULL);
                            if (!s) {
                                goto phooey;
                            }
                        }
                        else {
                            s++;
                        }
                    }
                } /* end search for check string in latin*/
	    } /* end search for check string */
	    else { /* search for newline */
		if (s > startpos) {
                    /*XXX: The s-- is almost definitely wrong here under unicode - demeprhq*/
a1915 2
		}
                /* We can use a more efficient search as newlines are the same in unicode as they are in latin */
d1921 3
a1923 3
		}
	    } /* end search for newline */
	} /* end anchored/multiline check string search */
d1931 1
a1931 2

	if (tmp_s >= strbeg && regtry(&reginfo, &tmp_s))
d2165 1
a2165 2
    Safefree(swap);
    RX_MATCH_TAINTED_set(rx, PL_reg_flags & RF_tainted);
d2174 1
a2174 1
	RX_MATCH_COPY_FREE(rx);
d2191 1
a2191 1
		RX_MATCH_COPIED_on(rx);
d2210 1
a2210 1
    if (swap) {
d2212 2
a2213 4
        Safefree(prog->offs);
        prog->offs = swap;
    }

d2226 1
a2226 2
    REGEXP *const rx = reginfo->prog;
    regexp *const prog = (struct regexp *)SvANY(rx);
d2276 1
a2276 1
		SV* const repointer = &PL_sv_undef;
d2279 1
a2279 1
                av_push(PL_regex_padav, repointer);
d2292 1
a2292 1
	ReREFCNT_inc(rx);
d2294 1
a2294 1
	PM_SETRE(PL_reg_curpm, rx);
d2737 1
a2737 2
    REGEXP *rex_sv = reginfo->prog;
    regexp *rex = (struct regexp *)SvANY(rex_sv);
d3340 79
d3431 1
a3431 1

d3460 6
a3465 1
	case ANYOF:
d3467 14
a3480 5
	        STRLEN inclasslen = PL_regeol - locinput;

	        if (!reginclass(rex, scan, (U8*)locinput, &inclasslen, do_utf8))
		    goto anyof_fail;
		if (locinput >= PL_regeol)
d3482 1
a3482 3
		locinput += inclasslen ? inclasslen : UTF8SKIP(locinput);
		nextchr = UCHARAT(locinput);
		break;
d3485 2
a3486 5
		if (nextchr < 0)
		    nextchr = UCHARAT(locinput);
		if (!REGINCLASS(rex, scan, (U8*)locinput))
		    goto anyof_fail;
		if (!nextchr && locinput >= PL_regeol)
d3489 18
d3509 22
a3530 7
	anyof_fail:
	    /* If we might have the case of the German sharp s
	     * in a casefolding Unicode character class. */

	    if (ANYOF_FOLD_SHARP_S(scan, locinput, PL_regeol)) {
		 locinput += SHARP_S_SKIP;
		 nextchr = UCHARAT(locinput);
d3532 4
a3535 2
	    else
		 sayNO;
d3537 5
a3541 68
	/* Special char classes - The defines start on line 129 or so */
	CCC_TRY_AFF( ALNUM,  ALNUML, perl_word,   "a", isALNUM_LC_utf8, isALNUM, isALNUM_LC);
	CCC_TRY_NEG(NALNUM, NALNUML, perl_word,   "a", isALNUM_LC_utf8, isALNUM, isALNUM_LC);

	CCC_TRY_AFF( SPACE,  SPACEL, perl_space,  " ", isSPACE_LC_utf8, isSPACE, isSPACE_LC);
	CCC_TRY_NEG(NSPACE, NSPACEL, perl_space,  " ", isSPACE_LC_utf8, isSPACE, isSPACE_LC);

	CCC_TRY_AFF( DIGIT,  DIGITL, posix_digit, "0", isDIGIT_LC_utf8, isDIGIT, isDIGIT_LC);
	CCC_TRY_NEG(NDIGIT, NDIGITL, posix_digit, "0", isDIGIT_LC_utf8, isDIGIT, isDIGIT_LC);

	case CLUMP: /* Match \X: logical Unicode character.  This is defined as
		       a Unicode extended Grapheme Cluster */
	    /* From http://www.unicode.org/reports/tr29 (5.2 version).  An
	      extended Grapheme Cluster is:

	       CR LF
	       | Prepend* Begin Extend*
	       | .

	       Begin is (Hangul-syllable | ! Control)
	       Extend is (Grapheme_Extend | Spacing_Mark)
	       Control is [ GCB_Control CR LF ]

	       The discussion below shows how the code for CLUMP is derived
	       from this regex.  Note that most of these concepts are from
	       property values of the Grapheme Cluster Boundary (GCB) property.
	       No code point can have multiple property values for a given
	       property.  Thus a code point in Prepend can't be in Control, but
	       it must be in !Control.  This is why Control above includes
	       GCB_Control plus CR plus LF.  The latter two are used in the GCB
	       property separately, and so can't be in GCB_Control, even though
	       they logically are controls.  Control is not the same as gc=cc,
	       but includes format and other characters as well.

	       The Unicode definition of Hangul-syllable is:
		   L+
		   | (L* ( ( V | LV ) V* | LVT ) T*)
		   | T+ 
		  )
	       Each of these is a value for the GCB property, and hence must be
	       disjoint, so the order they are tested is immaterial, so the
	       above can safely be changed to
		   T+
		   | L+
		   | (L* ( LVT | ( V | LV ) V*) T*)

	       The last two terms can be combined like this:
		   L* ( L
		        | (( LVT | ( V | LV ) V*) T*))

	       And refactored into this:
		   L* (L | LVT T* | V  V* T* | LV  V* T*)

	       That means that if we have seen any L's at all we can quit
	       there, but if the next character is a LVT, a V or and LV we
	       should keep going.

	       There is a subtlety with Prepend* which showed up in testing.
	       Note that the Begin, and only the Begin is required in:
	        | Prepend* Begin Extend*
	       Also, Begin contains '! Control'.  A Prepend must be a '!
	       Control', which means it must be a Begin.  What it comes down to
	       is that if we match Prepend* and then find no suitable Begin
	       afterwards, that if we backtrack the last Prepend, that one will
	       be a suitable Begin.
	    */

	    if (locinput >= PL_regeol)
d3543 7
a3549 15
	    if  (! do_utf8) {

		/* Match either CR LF  or '.', as all the other possibilities
		 * require utf8 */
		locinput++;	    /* Match the . or CR */
		if (nextchr == '\r'
		    && locinput < PL_regeol
		    && UCHARAT(locinput) == '\n') locinput++;
	    }
	    else {

		/* Utf8: See if is ( CR LF ); already know that locinput <
		 * PL_regeol, so locinput+1 is in bounds */
		if (nextchr == '\r' && UCHARAT(locinput + 1) == '\n') {
		    locinput += 2;
d3551 3
a3553 134
		else {
		    /* In case have to backtrack to beginning, then match '.' */
		    char *starting = locinput;

		    /* In case have to backtrack the last prepend */
		    char *previous_prepend = 0;

		    LOAD_UTF8_CHARCLASS_GCB();

		    /* Match (prepend)* */
		    while (locinput < PL_regeol
			   && swash_fetch(PL_utf8_X_prepend,
					  (U8*)locinput, do_utf8))
		    {
			previous_prepend = locinput;
			locinput += UTF8SKIP(locinput);
		    }

		    /* As noted above, if we matched a prepend character, but
		     * the next thing won't match, back off the last prepend we
		     * matched, as it is guaranteed to match the begin */
		    if (previous_prepend
			&& (locinput >=  PL_regeol
			    || ! swash_fetch(PL_utf8_X_begin,
					     (U8*)locinput, do_utf8)))
		    {
			locinput = previous_prepend;
		    }

		    /* Note that here we know PL_regeol > locinput, as we
		     * tested that upon input to this switch case, and if we
		     * moved locinput forward, we tested the result just above
		     * and it either passed, or we backed off so that it will
		     * now pass */
		    if (! swash_fetch(PL_utf8_X_begin, (U8*)locinput, do_utf8)) {

			/* Here did not match the required 'Begin' in the
			 * second term.  So just match the very first
			 * character, the '.' of the final term of the regex */
			locinput = starting + UTF8SKIP(starting);
		    } else {

			/* Here is the beginning of a character that can have
			 * an extender.  It is either a hangul syllable, or a
			 * non-control */
			if (swash_fetch(PL_utf8_X_non_hangul,
					(U8*)locinput, do_utf8))
			{

			    /* Here not a Hangul syllable, must be a
			     * ('!  * Control') */
			    locinput += UTF8SKIP(locinput);
			} else {

			    /* Here is a Hangul syllable.  It can be composed
			     * of several individual characters.  One
			     * possibility is T+ */
			    if (swash_fetch(PL_utf8_X_T,
					    (U8*)locinput, do_utf8))
			    {
				while (locinput < PL_regeol
					&& swash_fetch(PL_utf8_X_T,
							(U8*)locinput, do_utf8))
				{
				    locinput += UTF8SKIP(locinput);
				}
			    } else {

				/* Here, not T+, but is a Hangul.  That means
				 * it is one of the others: L, LV, LVT or V,
				 * and matches:
				 * L* (L | LVT T* | V  V* T* | LV  V* T*) */

				/* Match L*           */
				while (locinput < PL_regeol
					&& swash_fetch(PL_utf8_X_L,
							(U8*)locinput, do_utf8))
				{
				    locinput += UTF8SKIP(locinput);
				}

				/* Here, have exhausted L*.  If the next
				 * character is not an LV, LVT nor V, it means
				 * we had to have at least one L, so matches L+
				 * in the original equation, we have a complete
				 * hangul syllable.  Are done. */

				if (locinput < PL_regeol
				    && swash_fetch(PL_utf8_X_LV_LVT_V,
						    (U8*)locinput, do_utf8))
				{

				    /* Otherwise keep going.  Must be LV, LVT
				     * or V.  See if LVT */
				    if (swash_fetch(PL_utf8_X_LVT,
						    (U8*)locinput, do_utf8))
				    {
					locinput += UTF8SKIP(locinput);
				    } else {

					/* Must be  V or LV.  Take it, then
					 * match V*     */
					locinput += UTF8SKIP(locinput);
					while (locinput < PL_regeol
						&& swash_fetch(PL_utf8_X_V,
							 (U8*)locinput, do_utf8))
					{
					    locinput += UTF8SKIP(locinput);
					}
				    }

				    /* And any of LV, LVT, or V can be followed
				     * by T*            */
				    while (locinput < PL_regeol
					   && swash_fetch(PL_utf8_X_T,
							   (U8*)locinput,
							   do_utf8))
				    {
					locinput += UTF8SKIP(locinput);
				    }
				}
			    }
			}

			/* Match any extender */
			while (locinput < PL_regeol
				&& swash_fetch(PL_utf8_X_extend,
						(U8*)locinput, do_utf8))
			{
			    locinput += UTF8SKIP(locinput);
			}
		    }
		}
		if (locinput > PL_regeol) sayNO;
d3555 21
a3670 1
	    REGEXP *re_sv;
a3686 1
	    re_sv = rex_sv;
d3689 1
a3689 1
            (void)ReREFCNT_inc(rex_sv);
a3712 1
		char *saved_regeol = PL_regeol;
a3737 1
		PL_regeol = saved_regeol;
d3749 1
d3751 5
a3755 18
		    REGEXP *rx = NULL;

		    if (SvROK(ret)) {
			SV *const sv = SvRV(ret);

			if (SvTYPE(sv) == SVt_REGEXP) {
			    rx = (REGEXP*) sv;
			} else if (SvSMAGICAL(sv)) {
			    mg = mg_find(sv, PERL_MAGIC_qr);
			    assert(mg);
			}
		    } else if (SvTYPE(ret) == SVt_REGEXP) {
			rx = (REGEXP*) ret;
		    } else if (SvSMAGICAL(ret)) {
			if (SvGMAGICAL(ret)) {
			    /* I don't believe that there is ever qr magic
			       here.  */
			    assert(!mg_find(ret, PERL_MAGIC_qr));
d3757 1
a3757 2
			}
			else {
a3758 6
			    /* testing suggests mg only ends up non-NULL for
			       scalars who were upgraded and compiled in the
			       else block below. In turn, this is only
			       triggered in the "postponed utf8 string" tests
			       in t/op/pat.t  */
			}
d3762 1
a3762 5
			rx = (REGEXP *) mg->mg_obj; /*XXX:dmq*/
			assert(rx);
		    }
		    if (rx) {
			rx = reg_temp_copy(NULL, rx);
d3768 2
a3769 13
			if (DO_UTF8(ret)) {
			    assert (SvUTF8(ret));
			} else if (SvUTF8(ret)) {
			    /* Not doing UTF-8, despite what the SV says. Is
			       this only if we're trapped in use 'bytes'?  */
			    /* Make a copy of the octet sequence, but without
			       the flag on, as the compiler now honours the
			       SvUTF8 flag on ret.  */
			    STRLEN len;
			    const char *const p = SvPV(ret, len);
			    ret = newSVpvn_flags(p, len, SVs_TEMP);
			}
			rx = CALLREGCOMP(ret, pm_flags);
d3772 3
a3774 6
				 | SVs_GMG))) {
			    /* This isn't a first class regexp. Instead, it's
			       caching a regexp onto an existing, Perl visible
			       scalar.  */
			    sv_magic(ret, MUTABLE_SV(rx), PERL_MAGIC_qr, 0, 0);
			}
a3776 2
		    re_sv = rx;
		    re = (struct regexp *)SvANY(rx);
d3783 1
a3783 1
                    debug_start_match(re_sv, do_utf8, locinput, PL_regeol, 
d3817 1
a3817 1
		if (RX_UTF8(re_sv))
d3823 1
a3823 1
		ST.prev_rex = rex_sv;
d3825 1
a3825 2
		SETREX(rex_sv,re_sv);
		rex = re;
d3844 2
a3845 3
	    ReREFCNT_dec(rex_sv);
	    SETREX(rex_sv,ST.prev_rex);
	    rex = (struct regexp *)SvANY(rex_sv);
d3867 2
a3868 3
	    ReREFCNT_dec(rex_sv);
	    SETREX(rex_sv,ST.prev_rex);
	    rex = (struct regexp *)SvANY(rex_sv);
d4870 2
a4871 3
		st->u.eval.prev_rex = rex_sv;		/* inner */
		SETREX(rex_sv,cur_eval->u.eval.prev_rex);
		rex = (struct regexp *)SvANY(rex_sv);
d4874 1
a4874 1
		ReREFCNT_inc(rex_sv);
d5726 2
a5727 4
		(UTF8_ALLOW_DEFAULT & UTF8_ALLOW_ANYUV)
		| UTF8_ALLOW_FFFF | UTF8_CHECK_ONLY);
		/* see [perl #37836] for UTF8_ALLOW_ANYUV; [perl #38293] for
		 * UTF8_ALLOW_FFFF */
@


1.1.1.13
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d83 1
a83 1
#define RF_tainted	1	/* tainted information used? e.g. locale */
d88 1
a88 1
#define UTF_PATTERN ((PL_reg_flags & RF_utf8) != 0)
d97 1
a97 5
/* Valid for non-utf8 strings, non-ANYOFV nodes only: avoids the reginclass
 * call if there are no complications: i.e., if everything matchable is
 * straight forward in the bitmap */
#define REGINCLASS(prog,p,c)  (ANYOF_FLAGS(p) ? reginclass(prog,p,c,0,0)   \
					      : ANYOF_BITMAP_TEST(p,*(c)))
d103 1
a103 1
#define CHR_SVLEN(sv) (utf8_target ? sv_len_utf8(sv) : SvCUR(sv))
d121 2
a122 12
#ifdef EBCDIC
    /* Often 'str' is a hard-coded utf8 string instead of utfebcdic. so just
     * skip the check on EBCDIC platforms */
#   define LOAD_UTF8_CHARCLASS(class,str) LOAD_UTF8_CHARCLASS_NO_CHECK(class)
#else
#   define LOAD_UTF8_CHARCLASS(class,str) STMT_START { \
    if (!CAT2(PL_utf8_,class)) { \
	bool ok; \
	ENTER; save_re_context(); \
	ok=CAT2(is_utf8_,class)((const U8*)str); \
	assert(ok); assert(CAT2(PL_utf8_,class)); LEAVE; } } STMT_END
#endif
d126 1
a126 5
    if (!CAT2(PL_utf8_,class)) { \
	bool throw_away PERL_UNUSED_DECL; \
	ENTER; save_re_context(); \
	throw_away = CAT2(is_utf8_,class)((const U8*)" "); \
	LEAVE; } } STMT_END
d149 94
a242 1
#define PLACEHOLDER	/* Something for the preprocessor to grab onto */
a243 107
/* The actual code for CCC_TRY, which uses several variables from the routine
 * it's callable from.  It is designed to be the bulk of a case statement.
 * FUNC is the macro or function to call on non-utf8 targets that indicate if
 *      nextchr matches the class.
 * UTF8_TEST is the whole test string to use for utf8 targets
 * LOAD is what to use to test, and if not present to load in the swash for the
 *	class
 * POS_OR_NEG is either empty or ! to complement the results of FUNC or
 *	UTF8_TEST test.
 * The logic is: Fail if we're at the end-of-string; otherwise if the target is
 * utf8 and a variant, load the swash if necessary and test using the utf8
 * test.  Advance to the next character if test is ok, otherwise fail; If not
 * utf8 or an invariant under utf8, use the non-utf8 test, and fail if it
 * fails, or advance to the next character */

#define _CCC_TRY_CODE(POS_OR_NEG, FUNC, UTF8_TEST, CLASS, STR)                \
    if (locinput >= PL_regeol) {                                              \
	sayNO;                                                                \
    }                                                                         \
    if (utf8_target && UTF8_IS_CONTINUED(nextchr)) {                          \
	LOAD_UTF8_CHARCLASS(CLASS, STR);                                      \
	if (POS_OR_NEG (UTF8_TEST)) {                                         \
	    sayNO;                                                            \
	}                                                                     \
	locinput += PL_utf8skip[nextchr];                                     \
	nextchr = UCHARAT(locinput);                                          \
	break;                                                                \
    }                                                                         \
    if (POS_OR_NEG (FUNC(nextchr))) {                                         \
	sayNO;                                                                \
    }                                                                         \
    nextchr = UCHARAT(++locinput);                                            \
    break;

/* Handle the non-locale cases for a character class and its complement.  It
 * calls _CCC_TRY_CODE with a ! to complement the test for the character class.
 * This is because that code fails when the test succeeds, so we want to have
 * the test fail so that the code succeeds.  The swash is stored in a
 * predictable PL_ place */
#define _CCC_TRY_NONLOCALE(NAME,  NNAME,  FUNC,                               \
	                   CLASS, STR)                                        \
    case NAME:                                                                \
	_CCC_TRY_CODE( !, FUNC,                                               \
		          cBOOL(swash_fetch(CAT2(PL_utf8_,CLASS),             \
			                    (U8*)locinput, TRUE)),            \
		          CLASS, STR)                                         \
    case NNAME:                                                               \
	_CCC_TRY_CODE(  PLACEHOLDER , FUNC,                                   \
		          cBOOL(swash_fetch(CAT2(PL_utf8_,CLASS),             \
			                    (U8*)locinput, TRUE)),            \
		          CLASS, STR)                                         \

/* Generate the case statements for both locale and non-locale character
 * classes in regmatch for classes that don't have special unicode semantics.
 * Locales don't use an immediate swash, but an intermediary special locale
 * function that is called on the pointer to the current place in the input
 * string.  That function will resolve to needing the same swash.  One might
 * think that because we don't know what the locale will match, we shouldn't
 * check with the swash loading function that it loaded properly; ie, that we
 * should use LOAD_UTF8_CHARCLASS_NO_CHECK for those, but what is passed to the
 * regular LOAD_UTF8_CHARCLASS is in non-locale terms, and so locale is
 * irrelevant here */
#define CCC_TRY(NAME,  NNAME,  FUNC,                                          \
	        NAMEL, NNAMEL, LCFUNC, LCFUNC_utf8,                           \
	        NAMEA, NNAMEA, FUNCA,                                         \
		CLASS, STR)                                                   \
    case NAMEL:                                                               \
	PL_reg_flags |= RF_tainted;                                           \
	_CCC_TRY_CODE( !, LCFUNC, LCFUNC_utf8((U8*)locinput), CLASS, STR)     \
    case NNAMEL:                                                              \
	PL_reg_flags |= RF_tainted;                                           \
	_CCC_TRY_CODE( PLACEHOLDER, LCFUNC, LCFUNC_utf8((U8*)locinput),       \
		       CLASS, STR)                                            \
    case NAMEA:                                                               \
	if (locinput >= PL_regeol || ! FUNCA(nextchr)) {                      \
	    sayNO;                                                            \
	}                                                                     \
	/* Matched a utf8-invariant, so don't have to worry about utf8 */     \
	nextchr = UCHARAT(++locinput);                                        \
	break;                                                                \
    case NNAMEA:                                                              \
	if (locinput >= PL_regeol || FUNCA(nextchr)) {                        \
	    sayNO;                                                            \
	}                                                                     \
	if (utf8_target) {                                                    \
	    locinput += PL_utf8skip[nextchr];                                 \
	    nextchr = UCHARAT(locinput);                                      \
	}                                                                     \
	else {                                                                \
	    nextchr = UCHARAT(++locinput);                                    \
	}                                                                     \
	break;                                                                \
    /* Generate the non-locale cases */                                       \
    _CCC_TRY_NONLOCALE(NAME, NNAME, FUNC, CLASS, STR)

/* This is like CCC_TRY, but has an extra set of parameters for generating case
 * statements to handle separate Unicode semantics nodes */
#define CCC_TRY_U(NAME,  NNAME,  FUNC,                                         \
		  NAMEL, NNAMEL, LCFUNC, LCFUNC_utf8,                          \
	          NAMEU, NNAMEU, FUNCU,                                        \
	          NAMEA, NNAMEA, FUNCA,                                        \
	          CLASS, STR)                                                  \
    CCC_TRY(NAME, NNAME, FUNC,                                                 \
	    NAMEL, NNAMEL, LCFUNC, LCFUNC_utf8,                                \
	    NAMEA, NNAMEA, FUNCA,                                              \
	    CLASS, STR)                                                        \
    _CCC_TRY_NONLOCALE(NAMEU, NNAMEU, FUNCU, CLASS, STR)
d248 1
a248 9
/* it would be nice to rework regcomp.sym to generate this stuff. sigh
 *
 * NOTE that *nothing* that affects backtracking should be in here, specifically
 * VERBS must NOT be included. JUMPABLE is used to determine  if we can ignore a
 * node that is in between two EXACT like nodes when ascertaining what the required
 * "follow" character is. This should probably be moved to regex compile time
 * although it may be done at run time beause of the REF possibility - more
 * investigation required. -- demerphq
*/
d255 1
a255 1
    OP(rn) == KEEPS || \
d266 1
a266 1
#define IS_TEXTF(rn)  ( OP(rn)==EXACTFU || OP(rn)==EXACTFU_SS || OP(rn)==EXACTFU_TRICKYFOLD || OP(rn)==EXACTFA || OP(rn)==EXACTF || OP(rn)==REFF  || OP(rn)==NREFF )
a271 1
#define IS_TEXTFU(rn)  ( OP(rn)==EXACTFU || OP(rn)==EXACTFU_SS || OP(rn)==EXACTFU_TRICKYFOLD || OP(rn) == EXACTFA)
a296 6
#define REGCP_PAREN_ELEMS 4
#define REGCP_OTHER_ELEMS 5
#define REGCP_FRAME_ELEMS 1
/* REGCP_FRAME_ELEMS are not part of the REGCP_OTHER_ELEMS and
 * are needed for the regexp context stack bookkeeping. */

d302 1
a303 2
    const UV total_elems = paren_elems_to_push + REGCP_OTHER_ELEMS;
    const UV elems_shifted = total_elems << SAVE_TIGHT_SHIFT;
d308 1
a308 2
	Perl_croak(aTHX_ "panic: paren_elems_to_push, %i < 0",
		   paren_elems_to_push);
d310 2
a311 6
    if ((elems_shifted >> SAVE_TIGHT_SHIFT) != total_elems)
	Perl_croak(aTHX_ "panic: paren_elems_to_push offset %"UVuf
		   " out of range (%lu-%ld)",
		   total_elems, (unsigned long)PL_regsize, (long)parenfloor);

    SSGROW(total_elems + REGCP_FRAME_ELEMS);
d332 5
a336 1
    SSPUSHUV(SAVEt_REGCONTEXT | elems_shifted); /* Magic cookie. */
d361 1
a361 1
    UV i;
d368 3
a370 3
    i = SSPOPUV;
    assert((i & SAVE_MASK) == SAVEt_REGCONTEXT); /* Check that the magic cookie is there. */
    i >>= SAVE_TIGHT_SHIFT; /* Parentheses elements to pop. */
d377 1
a377 1
    i -= REGCP_OTHER_ELEMS;
d379 2
a380 1
    for ( ; i > 0; i -= REGCP_PAREN_ELEMS) {
d490 1
a490 1
	d) First node (of those at offset 0) which may distinguish positions;
d512 1
a512 1
    const bool utf8_target = (sv && SvUTF8(sv)) ? 1 : 0; /* if no sv we have to assume bytes */
d525 1
a525 1
    RX_MATCH_UTF8_set(rx,utf8_target);
d531 1
a531 1
        debug_start_match(rx, utf8_target, strpos, strend,
d545 1
a545 1
    if (utf8_target) {
d654 1
a654 1
    if ((flags & REXEC_SCREAM) && SvSCREAM(sv)) {
a656 15
	const MAGIC *mg;
	bool found = FALSE;

	assert(SvMAGICAL(sv));
	mg = mg_find(sv, PERL_MAGIC_study);
	assert(mg);

	if (mg->mg_private == 1) {
	    found = ((U8 *)mg->mg_ptr)[BmRARE(check)] != (U8)~0;
	} else if (mg->mg_private == 2) {
	    found = ((U16 *)mg->mg_ptr)[BmRARE(check)] != (U16)~0;
	} else {
	    assert (mg->mg_private == 4);
	    found = ((U32 *)mg->mg_ptr)[BmRARE(check)] != (U32)~0;
	}
d658 1
a658 1
	if (found
d697 1
a697 1
        RE_PV_QUOTED_DECL(quoted, utf8_target, PERL_DEBUG_PAD_ZERO(0),
d701 1
a701 1
	    (check == (utf8_target ? prog->anchored_utf8 : prog->anchored_substr)
d732 1
a732 1
    if (utf8_target ? (prog->float_utf8 && prog->anchored_utf8)
d739 1
a739 1
	if (check == (utf8_target ? prog->float_utf8 : prog->float_substr)) {
d749 1
a749 1
		    && (!utf8_target
d768 1
a768 1
		must = utf8_target ? prog->anchored_utf8 : prog->anchored_substr;
d782 1
a782 1
                    RE_PV_QUOTED_DECL(quoted, utf8_target, PERL_DEBUG_PAD_ZERO(0),
d829 1
a829 1
	    must = utf8_target ? prog->float_utf8 : prog->float_substr;
d843 1
a843 1
	        RE_PV_QUOTED_DECL(quoted, utf8_target, PERL_DEBUG_PAD_ZERO(0),
d890 1
a890 1
        && (!utf8_target
d908 1
a908 1
			if (utf8_target ? prog->anchored_utf8 : prog->anchored_substr) {
d948 1
a948 1
	++BmUSEFUL(utf8_target ? prog->check_utf8 : prog->check_substr);	/* hooray/5 */
d972 1
a972 1
	    && (utf8_target ? (
d984 3
a986 3
	    /* XXX Does the destruction order has to change with utf8_target? */
	    SvREFCNT_dec(utf8_target ? prog->check_utf8 : prog->check_substr);
	    SvREFCNT_dec(utf8_target ? prog->check_substr : prog->check_utf8);
a990 4
	    /* XXXX If the check string was an implicit check MBOL, then we need to unset the relevant flag
		    see http://bugs.activestate.com/show_bug.cgi?id=87173 */
	    if (prog->intflags & PREGf_IMPLICIT)
		prog->extflags &= ~RXf_ANCH_MBOL;
a994 1
	    /* XXXX What other flags might need to be cleared in this branch? */
d1012 1
a1012 1
	   This leaves EXACTF-ish only, which are dealt with in find_byclass().  */
d1045 1
a1045 1
		if ((utf8_target ? prog->anchored_utf8 : prog->anchored_substr) == check) {
d1085 1
a1085 1
	    if (!(utf8_target ? prog->float_utf8 : prog->float_substr))	/* Could have been deleted */
d1087 1
a1087 1
	    /* Check is floating substring. */
d1113 1
a1113 1
	BmUSEFUL(utf8_target ? prog->check_utf8 : prog->check_substr) += 5; /* hooray */
d1122 52
a1173 55
                    trie_type = ((scan->flags == EXACT) \
                              ? (utf8_target ? trie_utf8 : trie_plain) \
                              : (utf8_target ? trie_utf8_fold : trie_latin_utf8_fold))

#define REXEC_TRIE_READ_CHAR(trie_type, trie, widecharmap, uc, uscan, len,          \
uvc, charid, foldlen, foldbuf, uniflags) STMT_START {                               \
    STRLEN skiplen;                                                                 \
    switch (trie_type) {                                                            \
    case trie_utf8_fold:                                                            \
        if ( foldlen>0 ) {                                                          \
            uvc = utf8n_to_uvuni( (const U8*) uscan, UTF8_MAXLEN, &len, uniflags ); \
            foldlen -= len;                                                         \
            uscan += len;                                                           \
            len=0;                                                                  \
        } else {                                                                    \
            uvc = to_utf8_fold( (const U8*) uc, foldbuf, &foldlen );                \
            len = UTF8SKIP(uc);                                                     \
            skiplen = UNISKIP( uvc );                                               \
            foldlen -= skiplen;                                                     \
            uscan = foldbuf + skiplen;                                              \
        }                                                                           \
        break;                                                                      \
    case trie_latin_utf8_fold:                                                      \
        if ( foldlen>0 ) {                                                          \
            uvc = utf8n_to_uvuni( (const U8*) uscan, UTF8_MAXLEN, &len, uniflags ); \
            foldlen -= len;                                                         \
            uscan += len;                                                           \
            len=0;                                                                  \
        } else {                                                                    \
            len = 1;                                                                \
            uvc = _to_fold_latin1( (U8) *uc, foldbuf, &foldlen, 1);                 \
            skiplen = UNISKIP( uvc );                                               \
            foldlen -= skiplen;                                                     \
            uscan = foldbuf + skiplen;                                              \
        }                                                                           \
        break;                                                                      \
    case trie_utf8:                                                                 \
        uvc = utf8n_to_uvuni( (const U8*) uc, UTF8_MAXLEN, &len, uniflags );        \
        break;                                                                      \
    case trie_plain:                                                                \
        uvc = (UV)*uc;                                                              \
        len = 1;                                                                    \
    }                                                                               \
    if (uvc < 256) {                                                                \
        charid = trie->charmap[ uvc ];                                              \
    }                                                                               \
    else {                                                                          \
        charid = 0;                                                                 \
        if (widecharmap) {                                                          \
            SV** const svpp = hv_fetch(widecharmap,                                 \
                        (char*)&uvc, sizeof(UV), 0);                                \
            if (svpp)                                                               \
                charid = (U16)SvIV(*svpp);                                          \
        }                                                                           \
    }                                                                               \
d1176 24
d1204 4
a1207 2
	     && (ln == 1 || folder(s, pat_string, ln))    \
	     && (!reginfo || regtry(reginfo, &s)) )       \
d1258 1
a1258 1
    if (utf8_target) {                                             \
d1263 2
a1264 1
    }
d1267 1
a1267 1
    if (utf8_target) {                                             \
d1273 2
a1274 1
    }
d1278 1
a1278 1
    if (utf8_target) {                                             \
d1283 2
a1284 1
    }
a1288 80

#define UTF8_NOLOAD(TEST_NON_UTF8, IF_SUCCESS, IF_FAIL) \
	tmp = (s != PL_bostr) ? UCHARAT(s - 1) : '\n';                         \
	tmp = TEST_NON_UTF8(tmp);                                              \
	REXEC_FBC_UTF8_SCAN(                                                   \
	    if (tmp == ! TEST_NON_UTF8((U8) *s)) { \
		tmp = !tmp;                                                    \
		IF_SUCCESS;                                                    \
	    }                                                                  \
	    else {                                                             \
		IF_FAIL;                                                       \
	    }                                                                  \
	);                                                                     \

#define UTF8_LOAD(TeSt1_UtF8, TeSt2_UtF8, IF_SUCCESS, IF_FAIL) \
	if (s == PL_bostr) {                                                   \
	    tmp = '\n';                                                        \
	}                                                                      \
	else {                                                                 \
	    U8 * const r = reghop3((U8*)s, -1, (U8*)PL_bostr);                 \
	    tmp = utf8n_to_uvchr(r, UTF8SKIP(r), 0, UTF8_ALLOW_DEFAULT);       \
	}                                                                      \
	tmp = TeSt1_UtF8;                                                      \
	LOAD_UTF8_CHARCLASS_ALNUM();                                                                \
	REXEC_FBC_UTF8_SCAN(                                                   \
	    if (tmp == ! (TeSt2_UtF8)) { \
		tmp = !tmp;                                                    \
		IF_SUCCESS;                                                    \
	    }                                                                  \
	    else {                                                             \
		IF_FAIL;                                                       \
	    }                                                                  \
	);                                                                     \

/* The only difference between the BOUND and NBOUND cases is that
 * REXEC_FBC_TRYIT is called when matched in BOUND, and when non-matched in
 * NBOUND.  This is accomplished by passing it in either the if or else clause,
 * with the other one being empty */
#define FBC_BOUND(TEST_NON_UTF8, TEST1_UTF8, TEST2_UTF8) \
    FBC_BOUND_COMMON(UTF8_LOAD(TEST1_UTF8, TEST2_UTF8, REXEC_FBC_TRYIT, PLACEHOLDER), TEST_NON_UTF8, REXEC_FBC_TRYIT, PLACEHOLDER)

#define FBC_BOUND_NOLOAD(TEST_NON_UTF8, TEST1_UTF8, TEST2_UTF8) \
    FBC_BOUND_COMMON(UTF8_NOLOAD(TEST_NON_UTF8, REXEC_FBC_TRYIT, PLACEHOLDER), TEST_NON_UTF8, REXEC_FBC_TRYIT, PLACEHOLDER)

#define FBC_NBOUND(TEST_NON_UTF8, TEST1_UTF8, TEST2_UTF8) \
    FBC_BOUND_COMMON(UTF8_LOAD(TEST1_UTF8, TEST2_UTF8, PLACEHOLDER, REXEC_FBC_TRYIT), TEST_NON_UTF8, PLACEHOLDER, REXEC_FBC_TRYIT)

#define FBC_NBOUND_NOLOAD(TEST_NON_UTF8, TEST1_UTF8, TEST2_UTF8) \
    FBC_BOUND_COMMON(UTF8_NOLOAD(TEST_NON_UTF8, PLACEHOLDER, REXEC_FBC_TRYIT), TEST_NON_UTF8, PLACEHOLDER, REXEC_FBC_TRYIT)


/* Common to the BOUND and NBOUND cases.  Unfortunately the UTF8 tests need to
 * be passed in completely with the variable name being tested, which isn't
 * such a clean interface, but this is easier to read than it was before.  We
 * are looking for the boundary (or non-boundary between a word and non-word
 * character.  The utf8 and non-utf8 cases have the same logic, but the details
 * must be different.  Find the "wordness" of the character just prior to this
 * one, and compare it with the wordness of this one.  If they differ, we have
 * a boundary.  At the beginning of the string, pretend that the previous
 * character was a new-line */
#define FBC_BOUND_COMMON(UTF8_CODE, TEST_NON_UTF8, IF_SUCCESS, IF_FAIL) \
    if (utf8_target) {                                                         \
		UTF8_CODE \
    }                                                                          \
    else {  /* Not utf8 */                                                     \
	tmp = (s != PL_bostr) ? UCHARAT(s - 1) : '\n';                         \
	tmp = TEST_NON_UTF8(tmp);                                              \
	REXEC_FBC_SCAN(                                                        \
	    if (tmp == ! TEST_NON_UTF8((U8) *s)) {                             \
		tmp = !tmp;                                                    \
		IF_SUCCESS;                                                    \
	    }                                                                  \
	    else {                                                             \
		IF_FAIL;                                                       \
	    }                                                                  \
	);                                                                     \
    }                                                                          \
    if ((!prog->minlen && tmp) && (!reginfo || regtry(reginfo, &s)))           \
	goto got_it;

d1300 1
a1300 4
	char *pat_string;   /* The pattern's exactish string */
	char *pat_end;	    /* ptr to end char of pat_string */
	re_fold_t folder;	/* Function for computing non-utf8 folds */
	const U8 *fold_array;   /* array for folding ords < 256 */
d1304 2
a1305 2
	U8 c1;
	U8 c2;
d1308 1
a1308 2
	register const bool utf8_target = PL_reg_match_utf8;
	UV utf8_fold_flags = 0;
a1314 1
	case ANYOFV:
d1316 5
a1320 4
	    if (utf8_target || OP(c) == ANYOFV) {
		STRLEN inclasslen = strend - s;
		REXEC_FBC_UTF8_CLASS_SCAN(
                          reginclass(prog, c, (U8*)s, &inclasslen, utf8_target));
d1323 17
a1339 1
		REXEC_FBC_CLASS_SCAN(REGINCLASS(prog, c, (U8*)s));
a1349 10

	case EXACTFA:
	    if (UTF_PATTERN || utf8_target) {
		utf8_fold_flags = FOLDEQ_UTF8_NOMIX_ASCII;
		goto do_exactf_utf8;
	    }
	    fold_array = PL_fold_latin1;    /* Latin1 folds are not affected by */
	    folder = foldEQ_latin1;	    /* /a, except the sharp s one which */
	    goto do_exactf_non_utf8;	    /* isn't dealt with by these */

d1351 1
a1351 51
	    if (utf8_target) {

		/* regcomp.c already folded this if pattern is in UTF-8 */
		utf8_fold_flags = 0;
		goto do_exactf_utf8;
	    }
	    fold_array = PL_fold;
	    folder = foldEQ;
	    goto do_exactf_non_utf8;

	case EXACTFL:
	    if (UTF_PATTERN || utf8_target) {
		utf8_fold_flags = FOLDEQ_UTF8_LOCALE;
		goto do_exactf_utf8;
	    }
	    fold_array = PL_fold_locale;
	    folder = foldEQ_locale;
	    goto do_exactf_non_utf8;

	case EXACTFU_SS:
	    if (UTF_PATTERN) {
		utf8_fold_flags = FOLDEQ_S2_ALREADY_FOLDED;
	    }
	    goto do_exactf_utf8;

	case EXACTFU_TRICKYFOLD:
	case EXACTFU:
	    if (UTF_PATTERN || utf8_target) {
		utf8_fold_flags = (UTF_PATTERN) ? FOLDEQ_S2_ALREADY_FOLDED : 0;
		goto do_exactf_utf8;
	    }

	    /* Any 'ss' in the pattern should have been replaced by regcomp,
	     * so we don't have to worry here about this single special case
	     * in the Latin1 range */
	    fold_array = PL_fold_latin1;
	    folder = foldEQ_latin1;

	    /* FALL THROUGH */

	do_exactf_non_utf8: /* Neither pattern nor string are UTF8, and there
			       are no glitches with fold-length differences
			       between the target string and pattern */

	    /* The idea in the non-utf8 EXACTF* cases is to first find the
	     * first character of the EXACTF* node and then, if necessary,
	     * case-insensitively compare the full text of the node.  c1 is the
	     * first character.  c2 is its fold.  This logic will not work for
	     * Unicode semantics and the german sharp ss, which hence should
	     * not be compiled into a node that gets here. */
	    pat_string = STRING(c);
d1353 33
a1385 16

	    /* We know that we have to match at least 'ln' bytes (which is the
	     * same as characters, since not utf8).  If we have to match 3
	     * characters, and there are only 2 availabe, we know without
	     * trying that it will fail; so don't start a match past the
	     * required minimum number from the far end */
	    e = HOP3c(strend, -((I32)ln), s);

	    if (!reginfo && e < s) {
		e = s;			/* Due to minlen logic of intuit() */
	    }

	    c1 = *pat_string;
	    c2 = fold_array[c1];
	    if (c1 == c2) { /* If char and fold are the same */
		REXEC_FBC_EXACTISH_SCAN(*(U8*)s == c1);
d1388 2
a1389 1
		REXEC_FBC_EXACTISH_SCAN(*(U8*)s == c1 || *(U8*)s == c2);
d1391 9
a1399 1
	    break;
d1401 2
a1402 3
	do_exactf_utf8:
	{
	    unsigned expansion;
d1404 38
d1443 10
a1452 28
	    /* If one of the operands is in utf8, we can't use the simpler
	     * folding above, due to the fact that many different characters
	     * can have the same fold, or portion of a fold, or different-
	     * length fold */
	    pat_string = STRING(c);
	    ln  = STR_LEN(c);	/* length to match in octets/bytes */
	    pat_end = pat_string + ln;
	    lnc = (UTF_PATTERN) /* length to match in characters */
		    ? utf8_length((U8 *) pat_string, (U8 *) pat_end)
		    : ln;

	    /* We have 'lnc' characters to match in the pattern, but because of
	     * multi-character folding, each character in the target can match
	     * up to 3 characters (Unicode guarantees it will never exceed
	     * this) if it is utf8-encoded; and up to 2 if not (based on the
	     * fact that the Latin 1 folds are already determined, and the
	     * only multi-char fold in that range is the sharp-s folding to
	     * 'ss'.  Thus, a pattern character can match as little as 1/3 of a
	     * string character.  Adjust lnc accordingly, rounding up, so that
	     * if we need to match at least 4+1/3 chars, that really is 5. */
	    expansion = (utf8_target) ? UTF8_MAX_FOLD_CHAR_EXPAND : 2;
	    lnc = (lnc + expansion - 1) / expansion;

	    /* As in the non-UTF8 case, if we have to match 3 characters, and
	     * only 2 are left, it's guaranteed to fail, so don't start a
	     * match that would require us to go beyond the end of the string
	     */
	    e = HOP3c(strend, -((I32)lnc), s);
d1454 3
a1456 2
	    if (!reginfo && e < s) {
		e = s;			/* Due to minlen logic of intuit() */
d1458 6
a1463 17

	    /* XXX Note that we could recalculate e to stop the loop earlier,
	     * as the worst case expansion above will rarely be met, and as we
	     * go along we would usually find that e moves further to the left.
	     * This would happen only after we reached the point in the loop
	     * where if there were no expansion we should fail.  Unclear if
	     * worth the expense */

	    while (s <= e) {
		char *my_strend= (char *)strend;
		if (foldEQ_utf8_flags(s, &my_strend, 0,  utf8_target,
		      pat_string, NULL, ln, cBOOL(UTF_PATTERN), utf8_fold_flags)
		    && (!reginfo || regtry(reginfo, &s)) )
		{
		    goto got_it;
		}
		s += (utf8_target) ? UTF8SKIP(s) : 1;
a1465 1
	}
d1468 35
a1502 3
	    FBC_BOUND(isALNUM_LC,
		      isALNUM_LC_uvchr(UNI_TO_NATIVE(tmp)),
		      isALNUM_LC_utf8((U8*)s));
d1506 1
a1506 14
	    FBC_NBOUND(isALNUM_LC,
		       isALNUM_LC_uvchr(UNI_TO_NATIVE(tmp)),
		       isALNUM_LC_utf8((U8*)s));
	    break;
	case BOUND:
	    FBC_BOUND(isWORDCHAR,
		      isALNUM_uni(tmp),
		      cBOOL(swash_fetch(PL_utf8_alnum, (U8*)s, utf8_target)));
	    break;
	case BOUNDA:
	    FBC_BOUND_NOLOAD(isWORDCHAR_A,
			     isWORDCHAR_A(tmp),
			     isWORDCHAR_A((U8*)s));
	    break;
d1508 31
a1538 18
	    FBC_NBOUND(isWORDCHAR,
		       isALNUM_uni(tmp),
		       cBOOL(swash_fetch(PL_utf8_alnum, (U8*)s, utf8_target)));
	    break;
	case NBOUNDA:
	    FBC_NBOUND_NOLOAD(isWORDCHAR_A,
			      isWORDCHAR_A(tmp),
			      isWORDCHAR_A((U8*)s));
	    break;
	case BOUNDU:
	    FBC_BOUND(isWORDCHAR_L1,
		      isALNUM_uni(tmp),
		      cBOOL(swash_fetch(PL_utf8_alnum, (U8*)s, utf8_target)));
	    break;
	case NBOUNDU:
	    FBC_NBOUND(isWORDCHAR_L1,
		       isALNUM_uni(tmp),
		       cBOOL(swash_fetch(PL_utf8_alnum, (U8*)s, utf8_target)));
d1540 6
a1550 27
	    break;
	case ALNUMU:
	    REXEC_FBC_CSCAN_PRELOAD(
		LOAD_UTF8_CHARCLASS_ALNUM(),
		swash_fetch(PL_utf8_alnum,(U8*)s, utf8_target),
                isWORDCHAR_L1((U8) *s)
	    );
	    break;
	case ALNUM:
	    REXEC_FBC_CSCAN_PRELOAD(
		LOAD_UTF8_CHARCLASS_ALNUM(),
		swash_fetch(PL_utf8_alnum,(U8*)s, utf8_target),
                isWORDCHAR((U8) *s)
	    );
	    break;
	case ALNUMA:
	    /* Don't need to worry about utf8, as it can match only a single
	     * byte invariant character */
	    REXEC_FBC_CLASS_SCAN( isWORDCHAR_A(*s));
	    break;
	case NALNUMU:
	    REXEC_FBC_CSCAN_PRELOAD(
		LOAD_UTF8_CHARCLASS_ALNUM(),
		!swash_fetch(PL_utf8_alnum,(U8*)s, utf8_target),
                ! isWORDCHAR_L1((U8) *s)
	    );
	    break;
d1553 3
a1555 3
		LOAD_UTF8_CHARCLASS_ALNUM(),
		!swash_fetch(PL_utf8_alnum, (U8*)s, utf8_target),
                ! isALNUM(*s)
a1556 7
	    break;
	case NALNUMA:
	    REXEC_FBC_CSCAN(
		!isWORDCHAR_A(*s),
		!isWORDCHAR_A(*s)
	    );
	    break;
a1561 8
	    break;
	case SPACEU:
	    REXEC_FBC_CSCAN_PRELOAD(
		LOAD_UTF8_CHARCLASS_SPACE(),
		*s == ' ' || swash_fetch(PL_utf8_space,(U8*)s, utf8_target),
                isSPACE_L1((U8) *s)
	    );
	    break;
d1564 3
a1566 3
		LOAD_UTF8_CHARCLASS_SPACE(),
		*s == ' ' || swash_fetch(PL_utf8_space,(U8*)s, utf8_target),
                isSPACE((U8) *s)
a1567 6
	    break;
	case SPACEA:
	    /* Don't need to worry about utf8, as it can match only a single
	     * byte invariant character */
	    REXEC_FBC_CLASS_SCAN( isSPACE_A(*s));
	    break;
d1570 1
a1570 1
		isSPACE_LC_utf8((U8*)s),
a1572 8
	    break;
	case NSPACEU:
	    REXEC_FBC_CSCAN_PRELOAD(
		LOAD_UTF8_CHARCLASS_SPACE(),
		!( *s == ' ' || swash_fetch(PL_utf8_space,(U8*)s, utf8_target)),
                ! isSPACE_L1((U8) *s)
	    );
	    break;
d1575 3
a1577 9
		LOAD_UTF8_CHARCLASS_SPACE(),
		!(*s == ' ' || swash_fetch(PL_utf8_space,(U8*)s, utf8_target)),
                ! isSPACE((U8) *s)
	    );
	    break;
	case NSPACEA:
	    REXEC_FBC_CSCAN(
		!isSPACE_A(*s),
		!isSPACE_A(*s)
a1578 1
	    break;
d1581 1
a1581 1
		!isSPACE_LC_utf8((U8*)s),
a1583 1
	    break;
d1586 2
a1587 2
		LOAD_UTF8_CHARCLASS_DIGIT(),
		swash_fetch(PL_utf8_digit,(U8*)s, utf8_target),
a1589 6
	    break;
	case DIGITA:
	    /* Don't need to worry about utf8, as it can match only a single
	     * byte invariant character */
	    REXEC_FBC_CLASS_SCAN( isDIGIT_A(*s));
	    break;
a1594 1
	    break;
d1597 2
a1598 2
		LOAD_UTF8_CHARCLASS_DIGIT(),
		!swash_fetch(PL_utf8_digit,(U8*)s, utf8_target),
a1600 7
	    break;
	case NDIGITA:
	    REXEC_FBC_CSCAN(
		!isDIGIT_A(*s),
		!isDIGIT_A(*s)
	    );
	    break;
a1605 1
	    break;
a1610 1
	    break;
a1615 1
	    break;
a1620 1
	    break;
a1625 1
	    break;
a1630 1
	    break;
d1720 1
a1720 1
                                            (char *)uc, utf8_target );
d1724 4
a1727 10
                                );
				if (utf8_target) {
				    while ( uc <= (U8*)last_start && !BITMAP_TEST(bitmap,*uc) ) {
					uc += UTF8SKIP(uc);
				    }
				} else {
				    while ( uc <= (U8*)last_start  && !BITMAP_TEST(bitmap,*uc) ) {
					uc++;
				    }
				}
d1734 1
a1734 1
                            U8 *lpos= points[ (pointpos - trie->wordinfo[word].len) % maxlen ];
d1748 1
a1748 1
                                s,   utf8_target );
d1763 1
a1763 1
                                        s,   utf8_target );
a1770 1
				I32 offset;
d1772 7
a1778 5
				     ( ((offset = base + charid
					- 1 - trie->uniquecharcount)) >= 0)
                                     && ((U32)offset < trie->lasttrans)
                                     && trie->trans[offset].check == state
                                     && (tmp=trie->trans[offset].next))
d1808 1
a1808 1
                        U8 *lpos = points[ (pointpos - trie->wordinfo[aho->states[ state ].wordnum].len) % maxlen ];
d1875 1
a1875 1
    const bool utf8_target = cBOOL(DO_UTF8(sv));
d1894 1
a1894 1
    RX_MATCH_UTF8_set(rx, utf8_target);
d1896 1
a1896 1
        debug_start_match(rx, utf8_target, startpos, strend,
d2013 1
a2013 1
                if (utf8_target) {
d2064 2
a2065 2
		/* We can use a more efficient search as newlines are the same in unicode as they are in latin */
		while (s <= end) { /* note it could be possible to match at the end of the string */
d2076 1
a2076 1
        /* the warning about reginfo.ganch being used without initialization
d2089 1
a2089 1
	/* it must be a one character string (XXXX Except UTF_PATTERN?) */
d2094 3
a2096 3
	if (!(utf8_target ? prog->anchored_utf8 : prog->anchored_substr))
	    utf8_target ? to_utf8_substr(prog) : to_byte_substr(prog);
	ch = SvPVX_const(utf8_target ? prog->anchored_utf8 : prog->anchored_substr)[0];
d2098 1
a2098 1
	if (utf8_target) {
d2138 3
a2140 3
	    if (!(utf8_target ? prog->anchored_utf8 : prog->anchored_substr))
		utf8_target ? to_utf8_substr(prog) : to_byte_substr(prog);
	    must = utf8_target ? prog->anchored_utf8 : prog->anchored_substr;
d2143 3
a2145 3
	    if (!(utf8_target ? prog->float_utf8 : prog->float_substr))
		utf8_target ? to_utf8_substr(prog) : to_byte_substr(prog);
	    must = utf8_target ? prog->float_utf8 : prog->float_substr;
d2173 1
a2173 1
		((flags & REXEC_SCREAM) && SvSCREAM(sv)
d2193 1
a2193 1
	    if (utf8_target) {
d2209 1
a2209 1
            RE_PV_QUOTED_DECL(quoted, utf8_target, PERL_DEBUG_PAD_ZERO(0),
d2229 1
a2229 1
		RE_PV_QUOTED_DECL(quoted,utf8_target,PERL_DEBUG_PAD_ZERO(1),
d2232 1
a2232 1
		    "Matching stclass %.*s against %s (%d bytes)\n",
d2245 1
a2245 1
	    char *last= NULL;
d2248 3
a2250 3
	    if (!(utf8_target ? prog->float_utf8 : prog->float_substr))
		utf8_target ? to_utf8_substr(prog) : to_byte_substr(prog);
	    float_real = utf8_target ? prog->float_utf8 : prog->float_substr;
d2252 1
a2252 1
	    if ((flags & REXEC_SCREAM) && SvSCREAM(sv)) {
d2264 1
d2266 6
a2271 43
		    /* This means that float_real contains an artificial \n on the end
		     * due to the presence of something like this: /foo$/
		     * where we can match both "foo" and "foo\n" at the end of the string.
		     * So we have to compare the end of the string first against the float_real
		     * without the \n and then against the full float_real with the string.
		     * We have to watch out for cases where the string might be smaller
		     * than the float_real or the float_real without the \n.
		     */
		    char *checkpos= strend - len;
		    DEBUG_OPTIMISE_r(
			PerlIO_printf(Perl_debug_log,
			    "%sChecking for float_real.%s\n",
			    PL_colors[4], PL_colors[5]));
		    if (checkpos + 1 < strbeg) {
			/* can't match, even if we remove the trailing \n string is too short to match */
			DEBUG_EXECUTE_r(
			    PerlIO_printf(Perl_debug_log,
				"%sString shorter than required trailing substring, cannot match.%s\n",
				PL_colors[4], PL_colors[5]));
			goto phooey;
		    } else if (memEQ(checkpos + 1, little, len - 1)) {
			/* can match, the end of the string matches without the "\n" */
			last = checkpos + 1;
		    } else if (checkpos < strbeg) {
			/* cant match, string is too short when the "\n" is included */
			DEBUG_EXECUTE_r(
			    PerlIO_printf(Perl_debug_log,
				"%sString does not contain required trailing substring, cannot match.%s\n",
				PL_colors[4], PL_colors[5]));
			goto phooey;
		    } else if (!multiline) {
			/* non multiline match, so compare with the "\n" at the end of the string */
			if (memEQ(checkpos, little, len)) {
			    last= checkpos;
			} else {
			    DEBUG_EXECUTE_r(
				PerlIO_printf(Perl_debug_log,
				    "%sString does not contain required trailing substring, cannot match.%s\n",
				    PL_colors[4], PL_colors[5]));
			    goto phooey;
			}
		    } else {
			/* multiline match, so we have to search for a place where the full string is located */
a2272 1
		    }
d2281 1
a2281 6
	    if (!last) {
		/* at one point this block contained a comment which was probably
		 * incorrect, which said that this was a "should not happen" case.
		 * Even if it was true when it was written I am pretty sure it is
		 * not anymore, so I have removed the comment and replaced it with
		 * this one. Yves */
d2284 3
a2286 3
			"String does not contain required substring, cannot match.\n"
	            ));
		goto phooey;
d2294 1
a2294 1
	if (utf8_target) {
d2446 1
a2446 1
	(void)ReREFCNT_inc(rx);
d2538 3
d2706 1
a2706 1
Backtrack state structs are allocated in slabs of about 4K in size.
d2719 1
a2719 1
	DUMP_EXEC_POS(locinput, scan, utf8_target);		    \
d2737 1
a2737 1
S_debug_start_match(pTHX_ const REGEXP *prog, const bool utf8_target,
d2750 1
a2750 1
        RE_PV_QUOTED_DECL(s1, utf8_target, PERL_DEBUG_PAD_ZERO(1),
d2757 1
a2757 1
        if (utf8_target||utf8_pat)
d2760 2
a2761 2
                utf8_pat && utf8_target ? " and " : "",
                utf8_target ? "string" : ""
d2772 1
a2772 1
                      const bool utf8_target)
d2789 1
a2789 1
    while (utf8_target && UTF8_IS_CONTINUATION(*(U8*)(locinput - pref_len)))
d2795 1
a2795 1
    while (utf8_target && UTF8_IS_CONTINUATION(*(U8*)(locinput + l)))
d2802 1
a2802 1
	const int is_uni = (utf8_target && OP(scan) != CANY) ? 1 : 0;
d2889 1
a2889 1
    register const bool utf8_target = PL_reg_match_utf8;
d2925 1
a2925 1
                               during a successful match */
d2978 1
a2978 1
	    DUMP_EXEC_POS( locinput, scan, utf8_target );
d3056 1
a3056 1
 	    if (utf8_target) {
d3073 1
a3073 1
	    if (utf8_target) {
d3089 10
a3098 8
            if(!ANYOF_BITMAP_TEST(scan, *locinput)) {
                DEBUG_EXECUTE_r(
                    PerlIO_printf(Perl_debug_log,
                              "%*s  %sfailed to match trie start class...%s\n",
                              REPORT_CODE_OFF+depth*2, "", PL_colors[4], PL_colors[5])
                );
                sayNO_SILENT;
                /* NOTREACHED */
a3101 44
	    /* the basic plan of execution of the trie is:
	     * At the beginning, run though all the states, and
	     * find the longest-matching word. Also remember the position
	     * of the shortest matching word. For example, this pattern:
	     *    1  2 3 4    5
	     *    ab|a|x|abcd|abc
	     * when matched against the string "abcde", will generate
	     * accept states for all words except 3, with the longest
	     * matching word being 4, and the shortest being 1 (with
	     * the position being after char 1 of the string).
	     *
	     * Then for each matching word, in word order (i.e. 1,2,4,5),
	     * we run the remainder of the pattern; on each try setting
	     * the current position to the character following the word,
	     * returning to try the next word on failure.
	     *
	     * We avoid having to build a list of words at runtime by
	     * using a compile-time structure, wordinfo[].prev, which
	     * gives, for each word, the previous accepting word (if any).
	     * In the case above it would contain the mappings 1->2, 2->0,
	     * 3->0, 4->5, 5->1.  We can use this table to generate, from
	     * the longest word (4 above), a list of all words, by
	     * following the list of prev pointers; this gives us the
	     * unordered list 4,5,1,2. Then given the current word we have
	     * just tried, we can go through the list and find the
	     * next-biggest word to try (so if we just failed on word 2,
	     * the next in the list is 4).
	     *
	     * Since at runtime we don't record the matching position in
	     * the string for each word, we have to work that out for
	     * each word we're about to process. The wordinfo table holds
	     * the character length of each word; given that we recorded
	     * at the start: the position of the shortest word and its
	     * length in chars, we just need to move the pointer the
	     * difference between the two char lengths. Depending on
	     * Unicode status and folding, that's cheap or expensive.
	     *
	     * This algorithm is optimised for the case where are only a
	     * small number of accept states, i.e. 0,1, or maybe 2.
	     * With lots of accepts states, and having to try all of them,
	     * it becomes quadratic on number of accept states to find all
	     * the next words.
	     */

d3112 3
a3114 1
                if (trie->bitmap && !TRIE_BITMAP_TEST(trie,*locinput) ) {
d3121 1
a3121 2
			if (!trie->jump)
			    break;
d3138 2
a3140 2
		U32 charcount = 0; /* how many input chars we have matched */
		U32 accepted = 0; /* have we seen any accepting states? */
d3142 1
d3146 4
a3149 7
		ST.firstpos = NULL;
		ST.longfold = FALSE; /* char longer if folded => it's harder */
		ST.nextword = 0;

		/* fully traverse the TRIE; note the position of the
		   shortest accept state and the wordnum of the longest
		   accept state */
d3154 33
a3186 3
                    U16 charid = 0;
		    U16 wordnum;
                    wordnum = trie->states[ state ].wordnum;
d3188 4
a3191 16
		    if (wordnum) { /* it's an accept state */
			if (!accepted) {
			    accepted = 1;
			    /* record first match position */
			    if (ST.longfold) {
				ST.firstpos = (U8*)locinput;
				ST.firstchars = 0;
			    }
			    else {
				ST.firstpos = uc;
				ST.firstchars = charcount;
			    }
			}
			if (!ST.nextword || wordnum < ST.nextword)
			    ST.nextword = wordnum;
			ST.topword = wordnum;
d3193 1
d3196 1
a3196 1
		                DUMP_EXEC_POS( (char *)uc, scan, utf8_target );
d3198 1
a3198 1
			            "%*s  %sState: %4"UVxf" Accepted: %c ",
d3200 1
a3200 1
			            (UV)state, (accepted ? 'Y' : 'N'));
a3202 1
		    /* read a char and goto next state */
a3203 1
			I32 offset;
d3207 1
a3207 3
			charcount++;
			if (foldlen>0)
			    ST.longfold = TRUE;
d3209 5
a3213 5
			     ( ((offset =
			      base + charid - 1 - trie->uniquecharcount)) >= 0)

			     && ((U32)offset < trie->lasttrans)
			     && trie->trans[offset].check == state)
d3215 2
a3216 1
			    state = trie->trans[offset].next;
d3233 1
a3233 1
		if (!accepted)
a3235 11
		/* calculate total number of accept states */
		{
		    U16 w = ST.topword;
		    accepted = 0;
		    while (w) {
			w = trie->wordinfo[w].prev;
			accepted++;
		    }
		    ST.accepted = accepted;
		}

a3241 1
		goto trie_first_try; /* jump into the fail handler */
d3243 1
d3245 1
a3245 2

	case TRIE_next_fail: /* we failed - try next alternative */
d3252 52
a3303 1
	    if (!--ST.accepted) {
d3311 2
d3314 2
a3315 15
	    }
	    {
		/* Find next-highest word to process.  Note that this code
		 * is O(N^2) per trie run (O(N) per branch), so keep tight */
		register U16 min = 0;
		register U16 word;
		register U16 const nextword = ST.nextword;
		register reg_trie_wordinfo * const wordinfo
		    = ((reg_trie_data*)rexi->data->data[ARG(ST.me)])->wordinfo;
		for (word=ST.topword; word; word=wordinfo[word].prev) {
		    if (word > nextword && (!min || word < min))
			min = word;
		}
		ST.nextword = min;
	    }
d3317 11
a3327 10
          trie_first_try:
            if (do_cutgroup) {
                do_cutgroup = 0;
                no_final = 0;
            }

            if ( ST.jump) {
                ST.lastparen = *PL_reglastparen;
	        REGCP_SET(ST.cp);
            }
a3328 1
	    /* find start char of end of current word */
d3330 10
a3339 4
		U32 chars; /* how many chars to skip */
		U8 *uc = ST.firstpos;
		reg_trie_data * const trie
		    = (reg_trie_data*)rexi->data->data[ARG(ST.me)];
d3341 3
a3343 42
		assert((trie->wordinfo[ST.nextword].len - trie->prefixlen)
			    >=  ST.firstchars);
		chars = (trie->wordinfo[ST.nextword].len - trie->prefixlen)
			    - ST.firstchars;

		if (ST.longfold) {
		    /* the hard option - fold each char in turn and find
		     * its folded length (which may be different */
		    U8 foldbuf[UTF8_MAXBYTES_CASE + 1];
		    STRLEN foldlen;
		    STRLEN len;
		    UV uvc;
		    U8 *uscan;

		    while (chars) {
			if (utf8_target) {
			    uvc = utf8n_to_uvuni((U8*)uc, UTF8_MAXLEN, &len,
						    uniflags);
			    uc += len;
			}
			else {
			    uvc = *uc;
			    uc++;
			}
			uvc = to_uni_fold(uvc, foldbuf, &foldlen);
			uscan = foldbuf;
			while (foldlen) {
			    if (!--chars)
				break;
			    uvc = utf8n_to_uvuni(uscan, UTF8_MAXLEN, &len,
					    uniflags);
			    uscan += len;
			    foldlen -= len;
			}
		    }
		}
		else {
		    if (utf8_target)
			while (chars--)
			    uc += UTF8SKIP(uc);
		    else
			uc += chars;
a3344 2
		PL_reginput = (char *)uc;
	    }
d3346 21
a3366 3
	    scan = (ST.jump && ST.jump[ST.nextword]) 
			? ST.me + ST.jump[ST.nextword]
			: ST.B;
d3368 14
a3381 13
	    DEBUG_EXECUTE_r({
		PerlIO_printf( Perl_debug_log,
		    "%*s  %sTRIE matched word #%d, continuing%s\n",
		    REPORT_CODE_OFF+depth*2, "", 
		    PL_colors[4],
		    ST.nextword,
		    PL_colors[5]
		    );
	    });

	    if (ST.accepted > 1 || has_cutgroup) {
		PUSH_STATE_GOTO(TRIE_next, scan);
		/* NOTREACHED */
a3382 23
	    /* only one choice left - just continue */
	    DEBUG_EXECUTE_r({
		AV *const trie_words
		    = MUTABLE_AV(rexi->data->data[ARG(ST.me)+TRIE_WORDS_OFFSET]);
		SV ** const tmp = av_fetch( trie_words,
		    ST.nextword-1, 0 );
		SV *sv= tmp ? sv_newmortal() : NULL;

		PerlIO_printf( Perl_debug_log,
		    "%*s  %sonly one match left, short-circuiting: #%d <%s>%s\n",
		    REPORT_CODE_OFF+depth*2, "", PL_colors[4],
		    ST.nextword,
		    tmp ? pv_pretty(sv, SvPV_nolen_const(*tmp), SvCUR(*tmp), 0,
			    PL_colors[0], PL_colors[1],
			    (SvUTF8(*tmp) ? PERL_PV_ESCAPE_UNI : 0)|PERL_PV_ESCAPE_NONASCII
			) 
		    : "not compiled under -Dr",
		    PL_colors[5] );
	    });

	    locinput = PL_reginput;
	    nextchr = UCHARAT(locinput);
	    continue; /* execute rest of RE */
d3384 7
d3396 1
a3396 1
	    if (utf8_target != UTF_PATTERN) {
d3401 1
a3401 1
		if (utf8_target) {
d3445 1
a3445 6
	case EXACTFL: {
	    re_fold_t folder;
	    const U8 * fold_array;
	    const char * s;
	    U32 fold_utf8_flags;

d3447 4
a3450 4
	    folder = foldEQ_locale;
	    fold_array = PL_fold_locale;
	    fold_utf8_flags = FOLDEQ_UTF8_LOCALE;
	    goto do_exactf;
d3452 3
a3454 27
	case EXACTFU_SS:
	case EXACTFU_TRICKYFOLD:
	case EXACTFU:
	    folder = foldEQ_latin1;
	    fold_array = PL_fold_latin1;
	    fold_utf8_flags = (UTF_PATTERN) ? FOLDEQ_S1_ALREADY_FOLDED : 0;
	    goto do_exactf;

	case EXACTFA:
	    folder = foldEQ_latin1;
	    fold_array = PL_fold_latin1;
	    fold_utf8_flags = FOLDEQ_UTF8_NOMIX_ASCII;
	    goto do_exactf;

	case EXACTF:
	    folder = foldEQ;
	    fold_array = PL_fold;
	    fold_utf8_flags = 0;

	  do_exactf:
	    s = STRING(scan);
	    ln = STR_LEN(scan);

	    if (utf8_target || UTF_PATTERN || state_num == EXACTFU_SS) {
	      /* Either target or the pattern are utf8, or has the issue where
	       * the fold lengths may differ. */
		const char * const l = locinput;
d3457 15
a3471 4
		if (! foldEQ_utf8_flags(s, 0,  ln, cBOOL(UTF_PATTERN),
			                l, &e, 0,  utf8_target, fold_utf8_flags))
		{
		    sayNO;
d3478 3
a3480 1
	    /* Neither the target nor the pattern are utf8 */
d3482 2
a3483 2
		UCHARAT(s) != fold_array[nextchr])
	    {
a3484 1
	    }
d3487 3
a3489 1
	    if (ln > 1 && ! folder(s, locinput, ln))
d3494 1
a3494 5
	}

	/* XXX Could improve efficiency by separating these all out using a
	 * macro or in-line function.  At that point regcomp.c would no longer
	 * have to set the FLAGS fields of these */
a3499 2
	case BOUNDU:
	case BOUNDA:
a3500 2
	case NBOUNDU:
	case NBOUNDA:
d3502 1
a3502 4
	    if (utf8_target
		&& FLAGS(scan) != REGEX_ASCII_RESTRICTED_CHARSET
		&& FLAGS(scan) != REGEX_ASCII_MORE_RESTRICTED_CHARSET)
	    {
d3510 1
a3510 1
		if (FLAGS(scan) != REGEX_LOCALE_CHARSET) {
d3513 1
a3513 1
		    n = swash_fetch(PL_utf8_alnum, (U8*)locinput, utf8_target);
a3520 12

		/* Here the string isn't utf8, or is utf8 and only ascii
		 * characters are to match \w.  In the latter case looking at
		 * the byte just prior to the current one may be just the final
		 * byte of a multi-byte character.  This is ok.  There are two
		 * cases:
		 * 1) it is a single byte character, and then the test is doing
		 *	just what it's supposed to.
		 * 2) it is a multi-byte character, in which case the final
		 *	byte is never mistakable for ASCII, and so the test
		 *	will say it is not a word character, which is the
		 *	correct answer. */
d3523 11
a3533 26
		switch (FLAGS(scan)) {
		    case REGEX_UNICODE_CHARSET:
			ln = isWORDCHAR_L1(ln);
			n = isWORDCHAR_L1(nextchr);
			break;
		    case REGEX_LOCALE_CHARSET:
			ln = isALNUM_LC(ln);
			n = isALNUM_LC(nextchr);
			break;
		    case REGEX_DEPENDS_CHARSET:
			ln = isALNUM(ln);
			n = isALNUM(nextchr);
			break;
		    case REGEX_ASCII_RESTRICTED_CHARSET:
		    case REGEX_ASCII_MORE_RESTRICTED_CHARSET:
			ln = isWORDCHAR_A(ln);
			n = isWORDCHAR_A(nextchr);
			break;
		    default:
			Perl_croak(aTHX_ "panic: Unexpected FLAGS %u in op %u", FLAGS(scan), OP(scan));
			break;
		}
	    }
	    /* Note requires that all BOUNDs be lower than all NBOUNDs in
	     * regcomp.sym */
	    if (((!ln) == (!n)) == (OP(scan) < NBOUND))
a3535 1
	case ANYOFV:
d3537 1
a3537 1
	    if (utf8_target || state_num == ANYOFV) {
d3539 3
d3544 1
a3544 4

	        if (!reginclass(rex, scan, (U8*)locinput, &inclasslen, utf8_target))
		    sayNO;
		locinput += inclasslen;
d3551 2
a3554 2
		if (!REGINCLASS(rex, scan, (U8*)locinput))
		    sayNO;
d3558 10
d3570 8
a3577 16
        CCC_TRY_U(ALNUM,  NALNUM,  isWORDCHAR,
		  ALNUML, NALNUML, isALNUM_LC, isALNUM_LC_utf8,
		  ALNUMU, NALNUMU, isWORDCHAR_L1,
		  ALNUMA, NALNUMA, isWORDCHAR_A,
		  alnum, "a");

        CCC_TRY_U(SPACE,  NSPACE,  isSPACE,
		  SPACEL, NSPACEL, isSPACE_LC, isSPACE_LC_utf8,
		  SPACEU, NSPACEU, isSPACE_L1,
		  SPACEA, NSPACEA, isSPACE_A,
		  space, " ");

        CCC_TRY(DIGIT,  NDIGIT,  isDIGIT,
		DIGITL, NDIGITL, isDIGIT_LC, isDIGIT_LC_utf8,
		DIGITA, NDIGITA, isDIGIT_A,
		digit, "0");
d3623 1
a3623 1
	       there, but if the next character is an LVT, a V, or an LV we
d3629 5
a3633 5
	       Also, Begin contains '! Control'.  A Prepend must be a
	       '!  Control', which means it must also be a Begin.  What it
	       comes down to is that if we match Prepend* and then find no
	       suitable Begin afterwards, that if we backtrack the last
	       Prepend, that one will be a suitable Begin.
d3638 1
a3638 1
	    if  (! utf8_target) {
d3643 1
a3643 2
		if (nextchr == '\r' /* And if it was CR, and the next is LF,
				       match the LF */
d3666 1
a3666 1
					  (U8*)locinput, utf8_target))
d3678 1
a3678 1
					     (U8*)locinput, utf8_target)))
d3688 1
a3688 1
		    if (! swash_fetch(PL_utf8_X_begin, (U8*)locinput, utf8_target)) {
d3700 1
a3700 1
					(U8*)locinput, utf8_target))
d3712 1
a3712 1
					    (U8*)locinput, utf8_target))
d3716 1
a3716 1
							(U8*)locinput, utf8_target))
d3730 1
a3730 1
							(U8*)locinput, utf8_target))
d3743 1
a3743 1
						    (U8*)locinput, utf8_target))
d3749 1
a3749 1
						    (U8*)locinput, utf8_target))
d3759 1
a3759 1
							 (U8*)locinput, utf8_target))
d3770 1
a3770 1
							   utf8_target))
d3781 1
a3781 1
						(U8*)locinput, utf8_target))
d3793 1
a3793 6
	{   /* The capture buffer cases.  The ones beginning with N for the
	       named buffers just convert to the equivalent numbered and
	       pretend they were called as the corresponding numbered buffer
	       op.  */
	    /* don't initialize these in the declaration, it makes C++
	       unhappy */
a3795 4
	    re_fold_t folder;
	    const U8 *fold_array;
	    UV utf8_fold_flags;

d3797 2
a3798 20
	    folder = foldEQ_locale;
	    fold_array = PL_fold_locale;
	    type = REFFL;
	    utf8_fold_flags = FOLDEQ_UTF8_LOCALE;
	    goto do_nref;

	case NREFFA:
	    folder = foldEQ_latin1;
	    fold_array = PL_fold_latin1;
	    type = REFFA;
	    utf8_fold_flags = FOLDEQ_UTF8_NOMIX_ASCII;
	    goto do_nref;

	case NREFFU:
	    folder = foldEQ_latin1;
	    fold_array = PL_fold_latin1;
	    type = REFFU;
	    utf8_fold_flags = 0;
	    goto do_nref;

d3800 1
a3800 15
	    folder = foldEQ;
	    fold_array = PL_fold;
	    type = REFF;
	    utf8_fold_flags = 0;
	    goto do_nref;

	case NREF:
	    type = REF;
	    folder = NULL;
	    fold_array = NULL;
	    utf8_fold_flags = 0;
	  do_nref:

	    /* For the named back references, find the corresponding buffer
	     * number */
d3803 4
a3806 1
            if ( ! n ) {
d3808 2
a3809 3
	    }
	    goto do_nref_ref_common;

d3812 1
a3812 23
	    folder = foldEQ_locale;
	    fold_array = PL_fold_locale;
	    utf8_fold_flags = FOLDEQ_UTF8_LOCALE;
	    goto do_ref;

	case REFFA:
	    folder = foldEQ_latin1;
	    fold_array = PL_fold_latin1;
	    utf8_fold_flags = FOLDEQ_UTF8_NOMIX_ASCII;
	    goto do_ref;

	case REFFU:
	    folder = foldEQ_latin1;
	    fold_array = PL_fold_latin1;
	    utf8_fold_flags = 0;
	    goto do_ref;

	case REFF:
	    folder = foldEQ;
	    fold_array = PL_fold;
	    utf8_fold_flags = 0;
	    goto do_ref;

d3814 2
a3815 5
	    folder = NULL;
	    fold_array = NULL;
	    utf8_fold_flags = 0;

	  do_ref:
d3817 1
a3817 3
	    n = ARG(scan);  /* which paren pair */

	  do_nref_ref_common:
d3826 23
a3848 14
	    if (type != REF	/* REF can do byte comparison */
		&& (utf8_target || type == REFFU))
	    { /* XXX handle REFFL better */
		char * limit = PL_regeol;

		/* This call case insensitively compares the entire buffer
		    * at s, with the current input starting at locinput, but
		    * not going off the end given by PL_regeol, and returns in
		    * limit upon success, how much of the current input was
		    * matched */
		if (! foldEQ_utf8_flags(s, NULL, PL_regoffs[n].end - ln, utf8_target,
				    locinput, &limit, 0, utf8_target, utf8_fold_flags))
		{
		    sayNO;
d3850 1
a3850 1
		locinput = limit;
d3855 1
a3855 1
	    /* Not utf8:  Inline the first character, for speed. */
d3858 2
a3859 1
		 UCHARAT(s) != fold_array[nextchr]))
d3866 3
a3868 1
			   : ! folder(s, locinput, ln)))
d3929 1
a3929 18
		struct re_save_state saved_state;

		/* To not corrupt the existing regex state while executing the
		 * eval we would normally put it on the save stack, like with
		 * save_re_context. However, re-evals have a weird scoping so we
		 * can't just add ENTER/LEAVE here. With that, things like
		 *
		 *    (?{$a=2})(a(?{local$a=$a+1}))*aak*c(?{$b=$a})
		 *
		 * would break, as they expect the localisation to be unwound
		 * only when the re-engine backtracks through the bit that
		 * localised it.
		 *
		 * What we do instead is just saving the state in a local c
		 * variable.
		 */
		Copy(&PL_reg_state, &saved_state, 1, struct re_save_state);

a3933 6
		/* wrap the call in two SAVECOMPPADs. This ensures that
		 * when the save stack is eventually unwound, all the
		 * accumulated SAVEt_CLEARSV's will be processed with
		 * interspersed SAVEt_COMPPAD's to ensure that lexicals
		 * are cleared in the right pad */
		SAVECOMPPAD();
a3950 2
		Copy(&saved_state, &PL_reg_state, 1, struct re_save_state);

a3951 1
		SAVECOMPPAD();
d4039 1
a4039 1
                    debug_start_match(re_sv, utf8_target, locinput, PL_regeol,
d4093 1
a4093 1
	    sw = cBOOL(SvTRUE(ret));
d4194 1
a4194 1
	    sw = cBOOL(*PL_reglastparen >= n && PL_regoffs[n].end != -1);
d4198 1
a4198 1
	    sw = cBOOL(0 < reg_check_named_buff_matched(rex,scan));
d4327 3
a4329 1
	    ST.me = scan;
a4359 4
	    int min = ARG1(cur_curlyx->u.curlyx.me);
	    int max = ARG2(cur_curlyx->u.curlyx.me);
	    regnode *A = NEXTOPER(cur_curlyx->u.curlyx.me) + EXTRA_STEP_2ARGS;

d4369 4
a4372 2
		  "%*s  whilem: matched %ld out of %d..%d\n",
		  REPORT_CODE_OFF+depth*2, "", (long)n, min, max)
d4377 1
a4377 2
	    if (n < min) {
		ST.cp = regcppush(cur_curlyx->u.curlyx.parenfloor);
d4379 1
a4379 3
		REGCP_SET(ST.lastcp);

		PUSH_STATE_GOTO(WHILEM_A_pre, A);
d4459 1
a4459 1
	    if (n < max) { /* More greed allowed? */
d4463 1
a4463 1
		PUSH_STATE_GOTO(WHILEM_A_max, A);
d4484 2
a4487 2
	    REGCP_UNWIND(ST.lastcp);
	    regcppop(rex);
d4507 2
a4508 3
		Perl_warner(aTHX_ packWARN(WARN_REGEXP),
		     "Complex regular subexpression recursion limit (%d) "
		     "exceeded",
d4523 1
a4523 1
	    if (cur_curlyx->u.curlyx.count >= /*max*/ARG2(cur_curlyx->u.curlyx.me)) {
d4531 2
a4532 2
			"Complex regular subexpression recursion "
			"limit (%d) exceeded",
d4547 1
a4547 2
	    PUSH_STATE_GOTO(WHILEM_A_min,
		/*A*/ NEXTOPER(ST.save_curlyx->u.curlyx.me) + EXTRA_STEP_2ARGS);
d4730 6
a4735 9
			switch (OP(text_node)) {
			    case EXACTF: ST.c2 = PL_fold[ST.c1]; break;
			    case EXACTFA:
			    case EXACTFU_SS:
			    case EXACTFU_TRICKYFOLD:
			    case EXACTFU: ST.c2 = PL_fold_latin1[ST.c1]; break;
			    case EXACTFL: ST.c2 = PL_fold_locale[ST.c1]; break;
			    default: ST.c2 = ST.c1;
			}
d4881 6
a4886 11
		    if (!UTF_PATTERN) {
			ST.c1 = *s;
			switch (OP(text_node)) {
			    case EXACTF: ST.c2 = PL_fold[ST.c1]; break;
			    case EXACTFA:
			    case EXACTFU_SS:
			    case EXACTFU_TRICKYFOLD:
			    case EXACTFU: ST.c2 = PL_fold_latin1[ST.c1]; break;
			    case EXACTFL: ST.c2 = PL_fold_locale[ST.c1]; break;
			    default: ST.c2 = ST.c1; break;
			}
d4888 2
a4889 2
		    else { /* UTF_PATTERN */
			if (IS_TEXTFU(text_node) || IS_TEXTF(text_node)) {
d4940 1
a4940 1
		    if (utf8_target)
d4944 1
a4944 1
		else if (utf8_target) {
d4990 1
a4990 1
	    if (utf8_target)
d4999 1
a4999 1
		if (utf8_target) {
d5095 1
a5095 1
		    c = utf8_target ? utf8n_to_uvchr((U8*)PL_reginput,
d5134 1
a5134 1
		(void)ReREFCNT_inc(rex_sv);
d5205 1
a5205 1
			sw = 1 - cBOOL(ST.wanted);
d5234 1
a5234 1
		sw = cBOOL(ST.wanted);
d5351 21
d5373 1
a5373 1
            if ((n=is_LNBREAK(locinput,utf8_target))) {
d5382 1
a5382 3
	    if (locinput >= PL_regeol)                \
		sayNO;                                \
            if ((n=is_##nAmE(locinput,utf8_target))) {    \
d5389 1
a5389 3
	    if (locinput >= PL_regeol)                \
		sayNO;                                \
            if ((n=is_##nAmE(locinput,utf8_target))) {    \
d5602 1
a5602 2
    register bool utf8_target = PL_reg_match_utf8;
    UV utf8_flags;
d5616 1
a5616 1
	if (utf8_target) {
d5628 1
a5628 1
        if (utf8_target) {
d5641 6
a5646 9
    case EXACT:
	/* To get here, EXACTish nodes must have *byte* length == 1.  That
	 * means they match only characters in the string that can be expressed
	 * as a single byte.  For non-utf8 strings, that means a simple match.
	 * For utf8 strings, the character matched must be an invariant, or
	 * downgradable to a single byte.  The pattern's utf8ness is
	 * irrelevant, as since it's a single byte, it either isn't utf8, or if
	 * it is, it's an invariant */

d5648 3
a5650 26
	assert(! UTF_PATTERN || UNI_IS_INVARIANT(c));

	if (! utf8_target || UNI_IS_INVARIANT(c)) {
	    while (scan < loceol && UCHARAT(scan) == c) {
		scan++;
	    }
	}
	else {

	    /* Here, the string is utf8, and the pattern char is different
	     * in utf8 than not, so can't compare them directly.  Outside the
	     * loop, find the two utf8 bytes that represent c, and then
	     * look for those in sequence in the utf8 string */
	    U8 high = UTF8_TWO_BYTE_HI(c);
	    U8 low = UTF8_TWO_BYTE_LO(c);
	    loceol = PL_regeol;

	    while (hardcount < max
		    && scan + 1 < loceol
		    && UCHARAT(scan) == high
		    && UCHARAT(scan + 1) == low)
	    {
		scan += 2;
		hardcount++;
	    }
	}
d5652 1
a5652 5
    case EXACTFA:
	utf8_flags = FOLDEQ_UTF8_NOMIX_ASCII;
	goto do_exactf;

    case EXACTFL:
a5653 16
	utf8_flags = FOLDEQ_UTF8_LOCALE;
	goto do_exactf;

    case EXACTF:
	    utf8_flags = 0;
	    goto do_exactf;

    case EXACTFU_SS:
    case EXACTFU_TRICKYFOLD:
    case EXACTFU:
	utf8_flags = (UTF_PATTERN) ? FOLDEQ_S2_ALREADY_FOLDED : 0;

	/* The comments for the EXACT case above apply as well to these fold
	 * ones */

    do_exactf:
d5655 3
a5657 44
	assert(! UTF_PATTERN || UNI_IS_INVARIANT(c));

	if (utf8_target || OP(p) == EXACTFU_SS) { /* Use full Unicode fold matching */
	    char *tmpeol = loceol;
	    while (hardcount < max
		    && foldEQ_utf8_flags(scan, &tmpeol, 0, utf8_target,
				   STRING(p), NULL, 1, cBOOL(UTF_PATTERN), utf8_flags))
	    {
		scan = tmpeol;
		tmpeol = loceol;
		hardcount++;
	    }

	    /* XXX Note that the above handles properly the German sharp s in
	     * the pattern matching ss in the string.  But it doesn't handle
	     * properly cases where the string contains say 'LIGATURE ff' and
	     * the pattern is 'f+'.  This would require, say, a new function or
	     * revised interface to foldEQ_utf8(), in which the maximum number
	     * of characters to match could be passed and it would return how
	     * many actually did.  This is just one of many cases where
	     * multi-char folds don't work properly, and so the fix is being
	     * deferred */
	}
	else {
	    U8 folded;

	    /* Here, the string isn't utf8 and c is a single byte; and either
	     * the pattern isn't utf8 or c is an invariant, so its utf8ness
	     * doesn't affect c.  Can just do simple comparisons for exact or
	     * fold matching. */
	    switch (OP(p)) {
		case EXACTF: folded = PL_fold[c]; break;
		case EXACTFA:
		case EXACTFU_TRICKYFOLD:
		case EXACTFU: folded = PL_fold_latin1[c]; break;
		case EXACTFL: folded = PL_fold_locale[c]; break;
		default: Perl_croak(aTHX_ "panic: Unexpected op %u", OP(p));
	    }
	    while (scan < loceol &&
		   (UCHARAT(scan) == c || UCHARAT(scan) == folded))
	    {
		scan++;
	    }
	}
a5658 1
    case ANYOFV:
d5660 1
a5660 2
	if (utf8_target || OP(p) == ANYOFV) {
	    STRLEN inclasslen;
d5662 3
a5664 6
	    inclasslen = loceol - scan;
	    while (hardcount < max
		   && ((inclasslen = loceol - scan) > 0)
		   && reginclass(prog, p, (U8*)scan, &inclasslen, utf8_target))
	    {
		scan += inclasslen;
d5672 2
a5673 3
    case ALNUMU:
	if (utf8_target) {
    utf8_wordchar:
d5677 1
a5677 2
                   swash_fetch(PL_utf8_alnum, (U8*)scan, utf8_target))
            {
d5681 3
a5683 16
        } else {
            while (scan < loceol && isWORDCHAR_L1((U8) *scan)) {
                scan++;
            }
	}
	break;
    case ALNUM:
	if (utf8_target)
	    goto utf8_wordchar;
	while (scan < loceol && isALNUM((U8) *scan)) {
	    scan++;
	}
	break;
    case ALNUMA:
	while (scan < loceol && isWORDCHAR_A((U8) *scan)) {
	    scan++;
d5688 1
a5688 1
	if (utf8_target) {
d5700 2
a5701 5
    case NALNUMU:
	if (utf8_target) {

    utf8_Nwordchar:

d5705 1
a5705 2
                   ! swash_fetch(PL_utf8_alnum, (U8*)scan, utf8_target))
            {
d5709 2
a5710 21
        } else {
            while (scan < loceol && ! isWORDCHAR_L1((U8) *scan)) {
                scan++;
            }
	}
	break;
    case NALNUM:
	if (utf8_target)
	    goto utf8_Nwordchar;
	while (scan < loceol && ! isALNUM((U8) *scan)) {
	    scan++;
	}
	break;
    case NALNUMA:
	if (utf8_target) {
	    while (scan < loceol && ! isWORDCHAR_A((U8) *scan)) {
		scan += UTF8SKIP(scan);
	    }
	}
	else {
	    while (scan < loceol && ! isWORDCHAR_A((U8) *scan)) {
a5711 1
	    }
d5716 1
a5716 1
	if (utf8_target) {
d5728 2
a5729 5
    case SPACEU:
	if (utf8_target) {

    utf8_space:

d5734 1
a5734 2
                    swash_fetch(PL_utf8_space,(U8*)scan, utf8_target)))
            {
d5738 3
a5740 19
	    break;
	}
	else {
            while (scan < loceol && isSPACE_L1((U8) *scan)) {
                scan++;
            }
	    break;
	}
    case SPACE:
	if (utf8_target)
	    goto utf8_space;

	while (scan < loceol && isSPACE((U8) *scan)) {
	    scan++;
	}
	break;
    case SPACEA:
	while (scan < loceol && isSPACE_A((U8) *scan)) {
	    scan++;
d5745 1
a5745 1
	if (utf8_target) {
d5748 1
a5748 1
		   isSPACE_LC_utf8((U8*)scan)) {
d5757 2
a5758 5
    case NSPACEU:
	if (utf8_target) {

    utf8_Nspace:

d5762 2
a5763 3
		   ! (*scan == ' ' ||
                      swash_fetch(PL_utf8_space,(U8*)scan, utf8_target)))
            {
d5767 2
a5768 24
	    break;
	}
	else {
            while (scan < loceol && ! isSPACE_L1((U8) *scan)) {
                scan++;
            }
	}
	break;
    case NSPACE:
	if (utf8_target)
	    goto utf8_Nspace;

	while (scan < loceol && ! isSPACE((U8) *scan)) {
	    scan++;
	}
	break;
    case NSPACEA:
	if (utf8_target) {
	    while (scan < loceol && ! isSPACE_A((U8) *scan)) {
		scan += UTF8SKIP(scan);
	    }
	}
	else {
	    while (scan < loceol && ! isSPACE_A((U8) *scan)) {
a5769 1
	    }
d5774 1
a5774 1
	if (utf8_target) {
d5777 1
a5777 1
		   !isSPACE_LC_utf8((U8*)scan)) {
d5787 1
a5787 1
	if (utf8_target) {
d5791 1
a5791 1
		   swash_fetch(PL_utf8_digit, (U8*)scan, utf8_target)) {
a5799 19
    case DIGITA:
	while (scan < loceol && isDIGIT_A((U8) *scan)) {
	    scan++;
	}
	break;
    case DIGITL:
	PL_reg_flags |= RF_tainted;
	if (utf8_target) {
	    loceol = PL_regeol;
	    while (hardcount < max && scan < loceol &&
		   isDIGIT_LC_utf8((U8*)scan)) {
		scan += UTF8SKIP(scan);
		hardcount++;
	    }
	} else {
	    while (scan < loceol && isDIGIT_LC(*scan))
		scan++;
	}
	break;
d5801 1
a5801 1
	if (utf8_target) {
d5805 1
a5805 1
		   !swash_fetch(PL_utf8_digit, (U8*)scan, utf8_target)) {
a5812 27
	break;
    case NDIGITA:
	if (utf8_target) {
	    while (scan < loceol && ! isDIGIT_A((U8) *scan)) {
		scan += UTF8SKIP(scan);
	    }
	}
	else {
	    while (scan < loceol && ! isDIGIT_A((U8) *scan)) {
		scan++;
	    }
	}
	break;
    case NDIGITL:
	PL_reg_flags |= RF_tainted;
	if (utf8_target) {
	    loceol = PL_regeol;
	    while (hardcount < max && scan < loceol &&
		   !isDIGIT_LC_utf8((U8*)scan)) {
		scan += UTF8SKIP(scan);
		hardcount++;
	    }
	} else {
	    while (scan < loceol && !isDIGIT_LC(*scan))
		scan++;
	}
	break;
d5814 1
a5814 1
        if (utf8_target) {
d5833 1
a5833 1
        if (utf8_target) {
d5845 1
a5845 1
        if (utf8_target) {
d5858 1
a5858 1
        if (utf8_target) {
d5871 1
a5871 1
        if (utf8_target) {
d5911 3
a5913 3
- regclass_swash - prepare the utf8 swash.  Wraps the shared core version to
create a copy so that changes the caller makes won't change the shared one
 */
a5916 17
    PERL_ARGS_ASSERT_REGCLASS_SWASH;
    return newSVsv(core_regclass_swash(prog, node, doinit, listsvp, altsvp));
}
#endif

STATIC SV *
S_core_regclass_swash(pTHX_ const regexp *prog, register const regnode* node, bool doinit, SV** listsvp, SV **altsvp)
{
    /* Returns the swash for the input 'node' in the regex 'prog'.
     * If <doinit> is true, will attempt to create the swash if not already
     *	  done.
     * If <listsvp> is non-null, will return the swash initialization string in
     *	  it.
     * If <altsvp> is non-null, will return the alternates to the regular swash
     *	  in it
     * Tied intimately to how regcomp.c sets up the data structure */

a5920 2
    SV*  invlist = NULL;

d5924 1
a5924 3
    PERL_ARGS_ASSERT_CORE_REGCLASS_SWASH;

    assert(ANYOF_NONBITMAP(node));
d5933 1
a5933 1
	    bool invlist_has_user_defined_property;
d5935 2
a5936 1
	    si = *ary;	/* ary[0] = the string to initialize the swash with */
d5938 3
a5940 11
	    /* Elements 3 and 4 are either both present or both absent. [3] is
	     * any inversion list generated at compile time; [4] indicates if
	     * that inversion list has any user-defined properties in it. */
	    if (av_len(av) >= 3) {
		invlist = ary[3];
		invlist_has_user_defined_property = cBOOL(SvUV(ary[4]));
	    }
	    else {
		invlist = NULL;
		invlist_has_user_defined_property = FALSE;
	    }
d5942 2
a5943 5
	    /* Element [1] is reserved for the set-up swash.  If already there,
	     * return it; if not, create it and store it there */
	    if (SvROK(ary[1])) {
		sw = ary[1];
	    }
d5945 1
a5945 10

		sw = _core_swash_init("utf8", /* the utf8 package */
				      "", /* nameless */
				      si,
				      1, /* binary */
				      0, /* not from tr/// */
				      FALSE, /* is error if can't find
						property */
				      invlist,
				      invlist_has_user_defined_property);
d5948 2
a5949 7

	    /* Element [2] is for any multi-char folds.  Note that is a
	     * fundamentally flawed design, because can't backtrack and try
	     * again.  See [perl #89774] */
	    if (SvTYPE(ary[2]) == SVt_PVAV) {
	        alt = ary[2];
	    }
d5953 2
a5954 27
    if (listsvp) {
	SV* matches_string = newSVpvn("", 0);
	SV** invlistsvp;

	/* Use the swash, if any, which has to have incorporated into it all
	 * possibilities */
	if (   sw
	    && SvROK(sw)
	    && SvTYPE(SvRV(sw)) == SVt_PVHV
	    && (invlistsvp = hv_fetchs(MUTABLE_HV(SvRV(sw)), "INVLIST", FALSE)))
	{
	    invlist = *invlistsvp;
	}
	else if (si && si != &PL_sv_undef) {

	    /* If no swash, use the input nitialization string, if available */
	    sv_catsv(matches_string, si);
	}

	/* Add the inversion list to whatever we have.  This may have come from
	 * the swash, or from an input parameter */
	if (invlist) {
	    sv_catsv(matches_string, _invlist_contents(invlist));
	}
	*listsvp = matches_string;
    }

d5960 1
d5965 4
a5968 15
  n is the ANYOF regnode
  p is the target string
  lenp is pointer to the maximum number of bytes of how far to go in p
    (This is assumed wthout checking to always be at least the current
    character's size)
  utf8_target tells whether p is in UTF-8.

  Returns true if matched; false otherwise.  If lenp is not NULL, on return
  from a successful match, the value it points to will be updated to how many
  bytes in p were matched.  If there was no match, the value is undefined,
  possibly changed from the input.

  Note that this can be a synthetic start class, a combination of various
  nodes, so things you think might be mutually exclusive, such as locale,
  aren't.  It can match both locale and non-locale
d5973 1
a5973 1
S_reginclass(pTHX_ const regexp * const prog, register const regnode * const n, register const U8* const p, STRLEN* lenp, register const bool utf8_target)
d5979 2
a5980 2
    STRLEN c_len = 0;
    STRLEN maxlen;
d5984 2
a5985 3
    /* If c is not already the code point, get it */
    if (utf8_target && !UTF8_IS_INVARIANT(c)) {
	c = utf8n_to_uvchr(p, UTF8_MAXBYTES, &c_len,
d5990 1
a5990 1
	if (c_len == (STRLEN)-1)
a5992 26
    else {
	c_len = 1;
    }

    /* Use passed in max length, or one character if none passed in or less
     * than one character.  And assume will match just one character.  This is
     * overwritten later if matched more. */
    if (lenp) {
	maxlen = (*lenp > c_len) ? *lenp : c_len;
	*lenp = c_len;

    }
    else {
	maxlen = c_len;
    }

    /* If this character is potentially in the bitmap, check it */
    if (c < 256) {
	if (ANYOF_BITMAP_TEST(n, c))
	    match = TRUE;
	else if (flags & ANYOF_NON_UTF8_LATIN1_ALL
		&& ! utf8_target
		&& ! isASCII(c))
	{
	    match = TRUE;
	}
d5994 6
a5999 6
	else if (flags & ANYOF_LOCALE) {
	    PL_reg_flags |= RF_tainted;

	    if ((flags & ANYOF_LOC_NONBITMAP_FOLD)
		 && ANYOF_BITMAP_TEST(n, PL_fold_locale[c]))
	    {
a6000 36
	    }
	    else if (ANYOF_CLASS_TEST_ANY_SET(n) &&
		     ((ANYOF_CLASS_TEST(n, ANYOF_ALNUM)   &&  isALNUM_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_NALNUM)  && !isALNUM_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_SPACE)   &&  isSPACE_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_NSPACE)  && !isSPACE_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_DIGIT)   &&  isDIGIT_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_NDIGIT)  && !isDIGIT_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_ALNUMC)  &&  isALNUMC_LC(c)) ||
		      (ANYOF_CLASS_TEST(n, ANYOF_NALNUMC) && !isALNUMC_LC(c)) ||
		      (ANYOF_CLASS_TEST(n, ANYOF_ALPHA)   &&  isALPHA_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_NALPHA)  && !isALPHA_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_ASCII)   &&  isASCII_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_NASCII)  && !isASCII_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_CNTRL)   &&  isCNTRL_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_NCNTRL)  && !isCNTRL_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_GRAPH)   &&  isGRAPH_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_NGRAPH)  && !isGRAPH_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_LOWER)   &&  isLOWER_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_NLOWER)  && !isLOWER_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_PRINT)   &&  isPRINT_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_NPRINT)  && !isPRINT_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_PUNCT)   &&  isPUNCT_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_NPUNCT)  && !isPUNCT_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_UPPER)   &&  isUPPER_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_NUPPER)  && !isUPPER_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_XDIGIT)  &&  isXDIGIT(c))    ||
		      (ANYOF_CLASS_TEST(n, ANYOF_NXDIGIT) && !isXDIGIT(c))    ||
		      (ANYOF_CLASS_TEST(n, ANYOF_PSXSPC)  &&  isPSXSPC(c))    ||
		      (ANYOF_CLASS_TEST(n, ANYOF_NPSXSPC) && !isPSXSPC(c))    ||
		      (ANYOF_CLASS_TEST(n, ANYOF_BLANK)   &&  isBLANK_LC(c))  ||
		      (ANYOF_CLASS_TEST(n, ANYOF_NBLANK)  && !isBLANK_LC(c))
		     ) /* How's that for a conditional? */
	    ) {
		match = TRUE;
	    }
d6002 3
a6004 22
    }

    /* If the bitmap didn't (or couldn't) match, and something outside the
     * bitmap could match, try that.  Locale nodes specifiy completely the
     * behavior of code points in the bit map (otherwise, a utf8 target would
     * cause them to be treated as Unicode and not locale), except in
     * the very unlikely event when this node is a synthetic start class, which
     * could be a combination of locale and non-locale nodes.  So allow locale
     * to match for the synthetic start class, which will give a false
     * positive that will be resolved when the match is done again as not part
     * of the synthetic start class */
    if (!match) {
	if (utf8_target && (flags & ANYOF_UNICODE_ALL) && c >= 256) {
	    match = TRUE;	/* Everything above 255 matches */
	}
	else if (ANYOF_NONBITMAP(n)
		 && ((flags & ANYOF_NONBITMAP_NON_UTF8)
		     || (utf8_target
		         && (c >=256
			     || (! (flags & ANYOF_LOCALE))
			     || (flags & ANYOF_IS_SYNTHETIC)))))
	{
d6006 2
a6007 2
	    SV * const sw = core_regclass_swash(prog, n, TRUE, 0, (SV**)&av);

d6010 1
a6010 1
		if (utf8_target) {
d6013 1
a6013 15

		    /* Not utf8.  Convert as much of the string as available up
		     * to the limit of how far the (single) character in the
		     * pattern can possibly match (no need to go further).  If
		     * the node is a straight ANYOF or not folding, it can't
		     * match more than one.  Otherwise, It can match up to how
		     * far a single char can fold to.  Since not utf8, each
		     * character is a single byte, so the max it can be in
		     * bytes is the same as the max it can be in characters */
		    STRLEN len = (OP(n) == ANYOF
				  || ! (flags & ANYOF_LOC_NONBITMAP_FOLD))
				  ? 1
				  : (maxlen < UTF8_MAX_FOLD_CHAR_EXPAND)
				    ? maxlen
				    : UTF8_MAX_FOLD_CHAR_EXPAND;
d6016 1
a6016 2

		if (swash_fetch(sw, utf8_p, TRUE))
d6018 2
a6019 106
		else if (flags & ANYOF_LOC_NONBITMAP_FOLD) {

		    /* Here, we need to test if the fold of the target string
		     * matches.  The non-multi char folds have all been moved to
                     * the compilation phase, and the multi-char folds have
                     * been stored by regcomp into 'av'; we linearly check to
                     * see if any match the target string (folded).   We know
                     * that the originals were each one character, but we don't
                     * currently know how many characters/bytes each folded to,
                     * except we do know that there are small limits imposed by
                     * Unicode.  XXX A performance enhancement would be to have
                     * regcomp.c store the max number of chars/bytes that are
                     * in an av entry, as, say the 0th element.  Even better
                     * would be to have a hash of the few characters that can
                     * start a multi-char fold to the max number of chars of
                     * those folds.
		     *
		     * If there is a match, we will need to advance (if lenp is
		     * specified) the match pointer in the target string.  But
		     * what we are comparing here isn't that string directly,
		     * but its fold, whose length may differ from the original.
		     * As we go along in constructing the fold, therefore, we
		     * create a map so that we know how many bytes in the
		     * source to advance given that we have matched a certain
		     * number of bytes in the fold.  This map is stored in
		     * 'map_fold_len_back'.  Let n mean the number of bytes in
		     * the fold of the first character that we are folding.
		     * Then map_fold_len_back[n] is set to the number of bytes
		     * in that first character.  Similarly let m be the
		     * corresponding number for the second character to be
		     * folded.  Then map_fold_len_back[n+m] is set to the
		     * number of bytes occupied by the first two source
		     * characters. ... */
		    U8 map_fold_len_back[UTF8_MAXBYTES_CASE+1] = { 0 };
		    U8 folded[UTF8_MAXBYTES_CASE+1];
		    STRLEN foldlen = 0; /* num bytes in fold of 1st char */
		    STRLEN total_foldlen = 0; /* num bytes in fold of all
						  chars */

		    if (OP(n) == ANYOF || maxlen == 1 || ! lenp || ! av) {

			/* Here, only need to fold the first char of the target
			 * string.  It the source wasn't utf8, is 1 byte long */
			to_utf8_fold(utf8_p, folded, &foldlen);
			total_foldlen = foldlen;
			map_fold_len_back[foldlen] = (utf8_target)
						     ? UTF8SKIP(utf8_p)
						     : 1;
		    }
		    else {

			/* Here, need to fold more than the first char.  Do so
			 * up to the limits */
			U8* source_ptr = utf8_p;    /* The source for the fold
						       is the regex target
						       string */
			U8* folded_ptr = folded;
			U8* e = utf8_p + maxlen;    /* Can't go beyond last
						       available byte in the
						       target string */
			U8 i;
			for (i = 0;
			     i < UTF8_MAX_FOLD_CHAR_EXPAND && source_ptr < e;
			     i++)
			{

			    /* Fold the next character */
			    U8 this_char_folded[UTF8_MAXBYTES_CASE+1];
			    STRLEN this_char_foldlen;
			    to_utf8_fold(source_ptr,
				         this_char_folded,
					 &this_char_foldlen);

			    /* Bail if it would exceed the byte limit for
			     * folding a single char. */
			    if (this_char_foldlen + folded_ptr - folded >
							    UTF8_MAXBYTES_CASE)
			    {
				break;
			    }

			    /* Add the fold of this character */
			    Copy(this_char_folded,
				 folded_ptr,
				 this_char_foldlen,
				 U8);
			    source_ptr += UTF8SKIP(source_ptr);
			    folded_ptr += this_char_foldlen;
			    total_foldlen = folded_ptr - folded;

			    /* Create map from the number of bytes in the fold
			     * back to the number of bytes in the source.  If
			     * the source isn't utf8, the byte count is just
			     * the number of characters so far */
			    map_fold_len_back[total_foldlen]
						      = (utf8_target)
							? source_ptr - utf8_p
							: i + 1;
			}
			*folded_ptr = '\0';
		    }


		    /* Do the linear search to see if the fold is in the list
		     * of multi-char folds. */
		    if (av) {
d6025 2
a6026 16

			    if (len <= total_foldlen
				&& memEQ(s, (char*)folded, len)

				   /* If 0, means matched a partial char. See
				    * [perl #90536] */
				&& map_fold_len_back[len])
			    {

				/* Advance the target string ptr to account for
				 * this fold, but have to translate from the
				 * folded length to the corresponding source
				 * length. */
				if (lenp) {
				    *lenp = map_fold_len_back[len];
				}
d6032 8
d6043 58
a6100 1
		if (! utf8_target) Safefree(utf8_p);
a6110 4
    /* return the position 'off' UTF-8 characters away from 's', forward if
     * 'off' >= 0, backwards if negative.  But don't go outside of position
     * 'lim', which better be < s  if off < 0 */

d6230 2
a6231 1
		if (SvTAIL(prog->substrs->data[i].substr)) {
d6238 2
a6239 3
		    fbm_compile(sv, FBMcf_TAIL);
		} else
		    fbm_compile(sv, 0);
d6261 3
a6263 1
		    if (SvTAIL(prog->substrs->data[i].utf8_substr)) {
d6267 3
a6269 4
			fbm_compile(sv, FBMcf_TAIL);
		    } else
			fbm_compile(sv, 0);
		}
@


1.1.1.14
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a39 10
/* At least one required character in the target string is expressible only in
 * UTF-8. */
static const char* const non_utf8_target_but_utf8_required
                = "Can't match, because target string needs to be in UTF-8\n";

#define NON_UTF8_TARGET_BUT_UTF8_REQUIRED(target) STMT_START { \
    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "%s", non_utf8_target_but_utf8_required));\
    goto target; \
} STMT_END

d83 6
a88 2
#include "inline_invlist.c"
#include "unicode_constants.h"
d90 2
a91 1
#define HAS_NONLATIN1_FOLD_CLOSURE(i) _HAS_NONLATIN1_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(i)
d97 1
a97 1
/* Valid for non-utf8 strings: avoids the reginclass
d100 1
a100 1
#define REGINCLASS(prog,p,c)  (ANYOF_FLAGS(p) ? reginclass(prog,p,c,0)   \
d124 5
a128 28

#define NEXTCHR_EOS -10 /* nextchr has fallen off the end */
#define NEXTCHR_IS_EOS (nextchr < 0)

#define SET_nextchr \
    nextchr = ((locinput < PL_regeol) ? UCHARAT(locinput) : NEXTCHR_EOS)

#define SET_locinput(p) \
    locinput = (p);  \
    SET_nextchr


#define LOAD_UTF8_CHARCLASS(swash_ptr, property_name) STMT_START {            \
        if (!swash_ptr) {                                                     \
            U8 flags = _CORE_SWASH_INIT_ACCEPT_INVLIST;                       \
            swash_ptr = _core_swash_init("utf8", property_name, &PL_sv_undef, \
                                         1, 0, NULL, &flags);                 \
            assert(swash_ptr);                                                \
        }                                                                     \
    } STMT_END

/* If in debug mode, we test that a known character properly matches */
#ifdef DEBUGGING
#   define LOAD_UTF8_CHARCLASS_DEBUG_TEST(swash_ptr,                          \
                                          property_name,                      \
                                          utf8_char_in_property)              \
        LOAD_UTF8_CHARCLASS(swash_ptr, property_name);                        \
        assert(swash_fetch(swash_ptr, (U8 *) utf8_char_in_property, TRUE));
d130 6
a135 4
#   define LOAD_UTF8_CHARCLASS_DEBUG_TEST(swash_ptr,                          \
                                          property_name,                      \
                                          utf8_char_in_property)              \
        LOAD_UTF8_CHARCLASS(swash_ptr, property_name)
d138 28
a165 14
#define LOAD_UTF8_CHARCLASS_ALNUM() LOAD_UTF8_CHARCLASS_DEBUG_TEST(           \
                                        PL_utf8_swash_ptrs[_CC_WORDCHAR],     \
                                        swash_property_names[_CC_WORDCHAR],   \
                                        GREEK_SMALL_LETTER_IOTA_UTF8)

#define LOAD_UTF8_CHARCLASS_GCB()  /* Grapheme cluster boundaries */          \
    STMT_START {                                                              \
	LOAD_UTF8_CHARCLASS_DEBUG_TEST(PL_utf8_X_regular_begin,               \
                                       "_X_regular_begin",                    \
                                       GREEK_SMALL_LETTER_IOTA_UTF8);         \
	LOAD_UTF8_CHARCLASS_DEBUG_TEST(PL_utf8_X_extend,                      \
                                       "_X_extend",                           \
                                       COMBINING_GRAVE_ACCENT_UTF8);          \
    } STMT_END
d168 109
a334 9
/* These constants are for finding GCB=LV and GCB=LVT in the CLUMP regnode.
 * These are for the pre-composed Hangul syllables, which are all in a
 * contiguous block and arranged there in such a way so as to facilitate
 * alorithmic determination of their characteristics.  As such, they don't need
 * a swash, but can be determined by simple arithmetic.  Almost all are
 * GCB=LVT, but every 28th one is a GCB=LV */
#define SBASE 0xAC00    /* Start of block */
#define SCount 11172    /* Length of block */
#define TCount 28
d338 2
a339 2
#define REGCP_PAREN_ELEMS 3
#define REGCP_OTHER_ELEMS 3
d345 1
a345 1
S_regcppush(pTHX_ const regexp *rex, I32 parenfloor, U32 maxopenparen)
d349 1
a349 2
    const int paren_elems_to_push =
                (maxopenparen - parenfloor) * REGCP_PAREN_ELEMS;
d352 1
a352 1
    I32 p;
a354 2
    PERL_ARGS_ASSERT_REGCPPUSH;

d362 1
a362 3
		   total_elems,
                   (unsigned long)maxopenparen,
                   (long)parenfloor);
d366 1
a366 9
    DEBUG_BUFFERS_r(
	if ((int)maxopenparen > (int)parenfloor)
	    PerlIO_printf(Perl_debug_log,
		"rex=0x%"UVxf" offs=0x%"UVxf": saving capture indices:\n",
		PTR2UV(rex),
		PTR2UV(rex->offs)
	    );
    );
    for (p = parenfloor+1; p <= (I32)maxopenparen;  p++) {
d368 4
a371 3
	SSPUSHINT(rex->offs[p].end);
	SSPUSHINT(rex->offs[p].start);
	SSPUSHINT(rex->offs[p].start_tmp);
d373 4
a376 5
	    "    \\%"UVuf": %"IVdf"(%"IVdf")..%"IVdf"\n",
	    (UV)p,
	    (IV)rex->offs[p].start,
	    (IV)rex->offs[p].start_tmp,
	    (IV)rex->offs[p].end
d380 5
a384 3
    SSPUSHINT(maxopenparen);
    SSPUSHINT(rex->lastparen);
    SSPUSHINT(rex->lastcloseparen);
d406 2
a407 9
#define UNWIND_PAREN(lp, lcp)               \
    for (n = rex->lastparen; n > lp; n--)   \
        rex->offs[n].end = -1;              \
    rex->lastparen = n;                     \
    rex->lastcloseparen = lcp;


STATIC void
S_regcppop(pTHX_ regexp *rex, U32 *maxopenparen_p)
d411 1
a411 1
    U32 paren;
d420 5
a424 3
    rex->lastcloseparen = SSPOPINT;
    rex->lastparen = SSPOPINT;
    *maxopenparen_p = SSPOPINT;
a427 9
    DEBUG_BUFFERS_r(
	if (i || rex->lastparen + 1 <= rex->nparens)
	    PerlIO_printf(Perl_debug_log,
		"rex=0x%"UVxf" offs=0x%"UVxf": restoring capture indices to:\n",
		PTR2UV(rex),
		PTR2UV(rex->offs)
	    );
    );
    paren = *maxopenparen_p;
d430 3
a432 2
	rex->offs[paren].start_tmp = SSPOPINT;
	rex->offs[paren].start = SSPOPINT;
d434 9
a442 9
	if (paren <= rex->lastparen)
	    rex->offs[paren].end = tmps;
	DEBUG_BUFFERS_r( PerlIO_printf(Perl_debug_log,
	    "    \\%"UVuf": %"IVdf"(%"IVdf")..%"IVdf"%s\n",
	    (UV)paren,
	    (IV)rex->offs[paren].start,
	    (IV)rex->offs[paren].start_tmp,
	    (IV)rex->offs[paren].end,
	    (paren > rex->lastparen ? "(skipped)" : ""));
a443 1
	paren--;
d445 7
d462 4
a465 9
    for (i = rex->lastparen + 1; i <= rex->nparens; i++) {
	if (i > *maxopenparen_p)
	    rex->offs[i].start = -1;
	rex->offs[i].end = -1;
	DEBUG_BUFFERS_r( PerlIO_printf(Perl_debug_log,
	    "    \\%"UVuf": %s   ..-1 undeffing\n",
	    (UV)i,
	    (i > *maxopenparen_p) ? "-1" : "  "
	));
d468 1
a468 12
}

/* restore the parens and associated vars at savestack position ix,
 * but without popping the stack */

STATIC void
S_regcp_restore(pTHX_ regexp *rex, I32 ix, U32 *maxopenparen_p)
{
    I32 tmpix = PL_savestack_ix;
    PL_savestack_ix = ix;
    regcppop(rex, maxopenparen_p);
    PL_savestack_ix = tmpix;
a472 94
STATIC bool
S_isFOO_lc(pTHX_ const U8 classnum, const U8 character)
{
    /* Returns a boolean as to whether or not 'character' is a member of the
     * Posix character class given by 'classnum' that should be equivalent to a
     * value in the typedef '_char_class_number'.
     *
     * Ideally this could be replaced by a just an array of function pointers
     * to the C library functions that implement the macros this calls.
     * However, to compile, the precise function signatures are required, and
     * these may vary from platform to to platform.  To avoid having to figure
     * out what those all are on each platform, I (khw) am using this method,
     * which adds an extra layer of function call overhead (unless the C
     * optimizer strips it away).  But we don't particularly care about
     * performance with locales anyway. */

    switch ((_char_class_number) classnum) {
        case _CC_ENUM_ALPHANUMERIC: return isALPHANUMERIC_LC(character);
        case _CC_ENUM_ALPHA:     return isALPHA_LC(character);
        case _CC_ENUM_ASCII:     return isASCII_LC(character);
        case _CC_ENUM_BLANK:     return isBLANK_LC(character);
        case _CC_ENUM_CASED:     return isLOWER_LC(character)
                                        || isUPPER_LC(character);
        case _CC_ENUM_CNTRL:     return isCNTRL_LC(character);
        case _CC_ENUM_DIGIT:     return isDIGIT_LC(character);
        case _CC_ENUM_GRAPH:     return isGRAPH_LC(character);
        case _CC_ENUM_LOWER:     return isLOWER_LC(character);
        case _CC_ENUM_PRINT:     return isPRINT_LC(character);
        case _CC_ENUM_PSXSPC:    return isPSXSPC_LC(character);
        case _CC_ENUM_PUNCT:     return isPUNCT_LC(character);
        case _CC_ENUM_SPACE:     return isSPACE_LC(character);
        case _CC_ENUM_UPPER:     return isUPPER_LC(character);
        case _CC_ENUM_WORDCHAR:  return isWORDCHAR_LC(character);
        case _CC_ENUM_XDIGIT:    return isXDIGIT_LC(character);
        default:    /* VERTSPACE should never occur in locales */
            Perl_croak(aTHX_ "panic: isFOO_lc() has an unexpected character class '%d'", classnum);
    }

    assert(0); /* NOTREACHED */
    return FALSE;
}

STATIC bool
S_isFOO_utf8_lc(pTHX_ const U8 classnum, const U8* character)
{
    /* Returns a boolean as to whether or not the (well-formed) UTF-8-encoded
     * 'character' is a member of the Posix character class given by 'classnum'
     * that should be equivalent to a value in the typedef
     * '_char_class_number'.
     *
     * This just calls isFOO_lc on the code point for the character if it is in
     * the range 0-255.  Outside that range, all characters avoid Unicode
     * rules, ignoring any locale.  So use the Unicode function if this class
     * requires a swash, and use the Unicode macro otherwise. */

    PERL_ARGS_ASSERT_ISFOO_UTF8_LC;

    if (UTF8_IS_INVARIANT(*character)) {
        return isFOO_lc(classnum, *character);
    }
    else if (UTF8_IS_DOWNGRADEABLE_START(*character)) {
        return isFOO_lc(classnum,
                        TWO_BYTE_UTF8_TO_UNI(*character, *(character + 1)));
    }

    if (classnum < _FIRST_NON_SWASH_CC) {

        /* Initialize the swash unless done already */
        if (! PL_utf8_swash_ptrs[classnum]) {
            U8 flags = _CORE_SWASH_INIT_ACCEPT_INVLIST;
            PL_utf8_swash_ptrs[classnum] = _core_swash_init("utf8",
                swash_property_names[classnum], &PL_sv_undef, 1, 0, NULL, &flags);
        }

        return cBOOL(swash_fetch(PL_utf8_swash_ptrs[classnum], (U8 *)
                                 character,
                                 TRUE /* is UTF */ ));
    }

    switch ((_char_class_number) classnum) {
        case _CC_ENUM_SPACE:
        case _CC_ENUM_PSXSPC:    return is_XPERLSPACE_high(character);

        case _CC_ENUM_BLANK:     return is_HORIZWS_high(character);
        case _CC_ENUM_XDIGIT:    return is_XDIGIT_high(character);
        case _CC_ENUM_VERTSPACE: return is_VERTWS_high(character);
        default:                 return 0;  /* Things like CNTRL are always
                                               below 256 */
    }

    assert(0); /* NOTREACHED */
    return FALSE;
}

d482 1
a482 1
Perl_pregexec(pTHX_ REGEXP * const prog, char* stringarg, char *strend,
d484 4
a487 7
/* stringarg: the point in the string at which to begin matching */
/* strend:    pointer to null at end of string */
/* strbeg:    real beginning of string */
/* minend:    end of match must be >= minend bytes after stringarg. */
/* screamer:  SV being matched: only used for utf8 flag, pos() etc; string
 *            itself is accessed via the pointers above */
/* nosave:    For optimizations. */
d531 1
a531 1
   finding a substring too deep into the string means that fewer calls to
d552 2
a553 2
    struct regexp *const prog = ReANY(rx);
    I32 start_shift = 0;
d555 3
a557 3
    I32 end_shift   = 0;
    char *s;
    SV *check;
d562 1
a562 1
    char *other_last = NULL;	/* other substr checked before this */
a563 1
    char *checked_upto = NULL;          /* how far into the string we have already checked using find_byclass*/
a565 1
    bool is_utf8_pat;
a571 2
    PERL_UNUSED_ARG(flags);
    PERL_UNUSED_ARG(data);
d575 3
a577 2
    is_utf8_pat = cBOOL(RX_UTF8(rx));

d590 2
a591 16

    /* XXX we need to pass strbeg as a separate arg: the following is
     * guesswork and can be wrong... */
    if (sv && SvPOK(sv)) {
        char * p   = SvPVX(sv);
        STRLEN cur = SvCUR(sv); 
        if (p <= strpos && strpos < p + cur) {
            strbeg = p;
            assert(p <= strend && strend <= p + cur);
        }
        else
            strbeg = strend - cur;
    }
    else 
        strbeg = strpos;

d598 2
a599 5
	if (!prog->check_substr && prog->check_utf8) {
	    if (! to_byte_substr(prog)) {
                NON_UTF8_TARGET_BUT_UTF8_REQUIRED(fail);
            }
        }
d602 5
d621 2
a622 6
	  if (prog->check_offset_min == prog->check_offset_max
              && !(prog->extflags & RXf_CANY_SEEN)
              && ! multiline)   /* /m can cause \n's to match that aren't
                                   accounted for in the string max length.
                                   See [perl #115242] */
          {
a689 2
        U8* start_point;
        U8* end_point;
d702 36
d755 1
d1093 3
a1095 5
        if (checked_upto < s)
           checked_upto = s;
        DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "start_shift: %"IVdf" check_at: %"IVdf" s: %"IVdf" endpos: %"IVdf" checked_upto: %"IVdf"\n",
                                      (IV)start_shift, (IV)(check_at - strbeg), (IV)(s - strbeg), (IV)(endpos - strbeg), (IV)(checked_upto- strbeg)));

d1097 2
a1098 5
        s = find_byclass(prog, progi->regstclass, checked_upto, endpos,
                            NULL, is_utf8_pat);
	if (s) {
	    checked_upto = s;
	} else {
a1110 3
	    checked_upto = HOPBACKc(endpos, start_shift);
	    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "start_shift: %"IVdf" check_at: %"IVdf" endpos: %"IVdf" checked_upto: %"IVdf"\n",
                                      (IV)start_shift, (IV)(check_at - strbeg), (IV)(endpos - strbeg), (IV)(checked_upto- strbeg)));
d1194 2
a1195 2
#define REXEC_TRIE_READ_CHAR(trie_type, trie, widecharmap, uc, uscan, len, uvc, charid, foldlen, foldbuf, uniflags) \
STMT_START {                               \
d1260 1
a1260 1
    while (s < strend) {                              \
d1262 1
a1262 1
	s += UTF8SKIP(s);                             \
d1277 1
a1277 1
	if (tmp && (!reginfo || regtry(reginfo, &s))) \
d1310 18
d1418 1
a1418 1
    const char *strend, regmatch_info *reginfo, bool is_utf8_pat)
d1420 40
a1459 18
    dVAR;
    const I32 doevery = (prog->intflags & PREGf_SKIP) == 0;
    char *pat_string;   /* The pattern's exactish string */
    char *pat_end;	    /* ptr to end char of pat_string */
    re_fold_t folder;	/* Function for computing non-utf8 folds */
    const U8 *fold_array;   /* array for folding ords < 256 */
    STRLEN ln;
    STRLEN lnc;
    U8 c1;
    U8 c2;
    char *e;
    I32 tmp = 1;	/* Scratch variable? */
    const bool utf8_target = PL_reg_match_utf8;
    UV utf8_fold_flags = 0;
    bool to_complement = FALSE; /* Invert the result?  Taking the xor of this
                                   with a result inverts that result, as 0^1 =
                                   1 and 1^1 = 0 */
    _char_class_number classnum;
d1461 8
a1468 1
    RXi_GET_DECL(prog,progi);
d1470 2
a1471 1
    PERL_ARGS_ASSERT_FIND_BYCLASS;
d1473 7
a1479 21
    /* We know what class it must start with. */
    switch (OP(c)) {
    case ANYOF:
    case ANYOF_SYNTHETIC:
    case ANYOF_WARN_SUPER:
        if (utf8_target) {
            REXEC_FBC_UTF8_CLASS_SCAN(
                      reginclass(prog, c, (U8*)s, utf8_target));
        }
        else {
            REXEC_FBC_CLASS_SCAN(REGINCLASS(prog, c, (U8*)s));
        }
        break;
    case CANY:
        REXEC_FBC_SCAN(
            if (tmp && (!reginfo || regtry(reginfo, &s)))
                goto got_it;
            else
                tmp = doevery;
        );
        break;
d1481 8
a1488 8
    case EXACTFA:
        if (is_utf8_pat || utf8_target) {
            utf8_fold_flags = FOLDEQ_UTF8_NOMIX_ASCII;
            goto do_exactf_utf8;
        }
        fold_array = PL_fold_latin1;    /* Latin1 folds are not affected by */
        folder = foldEQ_latin1;	        /* /a, except the sharp s one which */
        goto do_exactf_non_utf8;	/* isn't dealt with by these */
d1490 5
a1494 2
    case EXACTF:
        if (utf8_target) {
d1496 6
a1501 7
            /* regcomp.c already folded this if pattern is in UTF-8 */
            utf8_fold_flags = 0;
            goto do_exactf_utf8;
        }
        fold_array = PL_fold;
        folder = foldEQ;
        goto do_exactf_non_utf8;
d1503 5
a1507 8
    case EXACTFL:
        if (is_utf8_pat || utf8_target) {
            utf8_fold_flags = FOLDEQ_UTF8_LOCALE;
            goto do_exactf_utf8;
        }
        fold_array = PL_fold_locale;
        folder = foldEQ_locale;
        goto do_exactf_non_utf8;
d1509 1
a1509 5
    case EXACTFU_SS:
        if (is_utf8_pat) {
            utf8_fold_flags = FOLDEQ_S2_ALREADY_FOLDED;
        }
        goto do_exactf_utf8;
d1511 33
a1543 6
    case EXACTFU_TRICKYFOLD:
    case EXACTFU:
        if (is_utf8_pat || utf8_target) {
            utf8_fold_flags = is_utf8_pat ? FOLDEQ_S2_ALREADY_FOLDED : 0;
            goto do_exactf_utf8;
        }
d1545 3
a1547 27
        /* Any 'ss' in the pattern should have been replaced by regcomp,
         * so we don't have to worry here about this single special case
         * in the Latin1 range */
        fold_array = PL_fold_latin1;
        folder = foldEQ_latin1;

        /* FALL THROUGH */

    do_exactf_non_utf8: /* Neither pattern nor string are UTF8, and there
                           are no glitches with fold-length differences
                           between the target string and pattern */

        /* The idea in the non-utf8 EXACTF* cases is to first find the
         * first character of the EXACTF* node and then, if necessary,
         * case-insensitively compare the full text of the node.  c1 is the
         * first character.  c2 is its fold.  This logic will not work for
         * Unicode semantics and the german sharp ss, which hence should
         * not be compiled into a node that gets here. */
        pat_string = STRING(c);
        ln  = STR_LEN(c);	/* length to match in octets/bytes */

        /* We know that we have to match at least 'ln' bytes (which is the
         * same as characters, since not utf8).  If we have to match 3
         * characters, and there are only 2 availabe, we know without
         * trying that it will fail; so don't start a match past the
         * required minimum number from the far end */
        e = HOP3c(strend, -((I32)ln), s);
a1548 3
        if (!reginfo && e < s) {
            e = s;			/* Due to minlen logic of intuit() */
        }
d1550 28
a1577 9
        c1 = *pat_string;
        c2 = fold_array[c1];
        if (c1 == c2) { /* If char and fold are the same */
            REXEC_FBC_EXACTISH_SCAN(*(U8*)s == c1);
        }
        else {
            REXEC_FBC_EXACTISH_SCAN(*(U8*)s == c1 || *(U8*)s == c2);
        }
        break;
d1579 3
a1581 3
    do_exactf_utf8:
    {
        unsigned expansion;
d1583 240
a1822 27
        /* If one of the operands is in utf8, we can't use the simpler folding
         * above, due to the fact that many different characters can have the
         * same fold, or portion of a fold, or different- length fold */
        pat_string = STRING(c);
        ln  = STR_LEN(c);	/* length to match in octets/bytes */
        pat_end = pat_string + ln;
        lnc = is_utf8_pat       /* length to match in characters */
                ? utf8_length((U8 *) pat_string, (U8 *) pat_end)
                : ln;

        /* We have 'lnc' characters to match in the pattern, but because of
         * multi-character folding, each character in the target can match
         * up to 3 characters (Unicode guarantees it will never exceed
         * this) if it is utf8-encoded; and up to 2 if not (based on the
         * fact that the Latin 1 folds are already determined, and the
         * only multi-char fold in that range is the sharp-s folding to
         * 'ss'.  Thus, a pattern character can match as little as 1/3 of a
         * string character.  Adjust lnc accordingly, rounding up, so that
         * if we need to match at least 4+1/3 chars, that really is 5. */
        expansion = (utf8_target) ? UTF8_MAX_FOLD_CHAR_EXPAND : 2;
        lnc = (lnc + expansion - 1) / expansion;

        /* As in the non-UTF8 case, if we have to match 3 characters, and
         * only 2 are left, it's guaranteed to fail, so don't start a
         * match that would require us to go beyond the end of the string
         */
        e = HOP3c(strend, -((I32)lnc), s);
d1824 13
a1836 3
        if (!reginfo && e < s) {
            e = s;			/* Due to minlen logic of intuit() */
        }
a1837 83
        /* XXX Note that we could recalculate e to stop the loop earlier,
         * as the worst case expansion above will rarely be met, and as we
         * go along we would usually find that e moves further to the left.
         * This would happen only after we reached the point in the loop
         * where if there were no expansion we should fail.  Unclear if
         * worth the expense */

        while (s <= e) {
            char *my_strend= (char *)strend;
            if (foldEQ_utf8_flags(s, &my_strend, 0,  utf8_target,
                  pat_string, NULL, ln, is_utf8_pat, utf8_fold_flags)
                && (!reginfo || regtry(reginfo, &s)) )
            {
                goto got_it;
            }
            s += (utf8_target) ? UTF8SKIP(s) : 1;
        }
        break;
    }
    case BOUNDL:
        RXp_MATCH_TAINTED_on(prog);
        FBC_BOUND(isWORDCHAR_LC,
                  isWORDCHAR_LC_uvchr(UNI_TO_NATIVE(tmp)),
                  isWORDCHAR_LC_utf8((U8*)s));
        break;
    case NBOUNDL:
        RXp_MATCH_TAINTED_on(prog);
        FBC_NBOUND(isWORDCHAR_LC,
                   isWORDCHAR_LC_uvchr(UNI_TO_NATIVE(tmp)),
                   isWORDCHAR_LC_utf8((U8*)s));
        break;
    case BOUND:
        FBC_BOUND(isWORDCHAR,
                  isWORDCHAR_uni(tmp),
                  cBOOL(swash_fetch(PL_utf8_swash_ptrs[_CC_WORDCHAR], (U8*)s, utf8_target)));
        break;
    case BOUNDA:
        FBC_BOUND_NOLOAD(isWORDCHAR_A,
                         isWORDCHAR_A(tmp),
                         isWORDCHAR_A((U8*)s));
        break;
    case NBOUND:
        FBC_NBOUND(isWORDCHAR,
                   isWORDCHAR_uni(tmp),
                   cBOOL(swash_fetch(PL_utf8_swash_ptrs[_CC_WORDCHAR], (U8*)s, utf8_target)));
        break;
    case NBOUNDA:
        FBC_NBOUND_NOLOAD(isWORDCHAR_A,
                          isWORDCHAR_A(tmp),
                          isWORDCHAR_A((U8*)s));
        break;
    case BOUNDU:
        FBC_BOUND(isWORDCHAR_L1,
                  isWORDCHAR_uni(tmp),
                  cBOOL(swash_fetch(PL_utf8_swash_ptrs[_CC_WORDCHAR], (U8*)s, utf8_target)));
        break;
    case NBOUNDU:
        FBC_NBOUND(isWORDCHAR_L1,
                   isWORDCHAR_uni(tmp),
                   cBOOL(swash_fetch(PL_utf8_swash_ptrs[_CC_WORDCHAR], (U8*)s, utf8_target)));
        break;
    case LNBREAK:
        REXEC_FBC_CSCAN(is_LNBREAK_utf8_safe(s, strend),
                        is_LNBREAK_latin1_safe(s, strend)
        );
        break;

    /* The argument to all the POSIX node types is the class number to pass to
     * _generic_isCC() to build a mask for searching in PL_charclass[] */

    case NPOSIXL:
        to_complement = 1;
        /* FALLTHROUGH */

    case POSIXL:
        RXp_MATCH_TAINTED_on(prog);
        REXEC_FBC_CSCAN(to_complement ^ cBOOL(isFOO_utf8_lc(FLAGS(c), (U8 *) s)),
                        to_complement ^ cBOOL(isFOO_lc(FLAGS(c), *s)));
        break;

    case NPOSIXD:
        to_complement = 1;
        /* FALLTHROUGH */
d1839 1
a1839 5
    case POSIXD:
        if (utf8_target) {
            goto posix_utf8;
        }
        goto posixa;
d1841 34
a1874 9
    case NPOSIXA:
        if (utf8_target) {
            /* The complement of something that matches only ASCII matches all
             * UTF-8 variant code points, plus everything in ASCII that isn't
             * in the class */
            REXEC_FBC_UTF8_CLASS_SCAN(! UTF8_IS_INVARIANT(*s)
                                      || ! _generic_isCC_A(*s, FLAGS(c)));
            break;
        }
d1876 16
a1891 2
        to_complement = 1;
        /* FALLTHROUGH */
d1893 3
a1895 18
    case POSIXA:
      posixa:
        /* Don't need to worry about utf8, as it can match only a single
         * byte invariant character. */
        REXEC_FBC_CLASS_SCAN(
                        to_complement ^ cBOOL(_generic_isCC_A(*s, FLAGS(c))));
        break;

    case NPOSIXU:
        to_complement = 1;
        /* FALLTHROUGH */

    case POSIXU:
        if (! utf8_target) {
            REXEC_FBC_CLASS_SCAN(to_complement ^ cBOOL(_generic_isCC(*s,
                                                                    FLAGS(c))));
        }
        else {
d1897 32
a1928 24
      posix_utf8:
            classnum = (_char_class_number) FLAGS(c);
            if (classnum < _FIRST_NON_SWASH_CC) {
                while (s < strend) {

                    /* We avoid loading in the swash as long as possible, but
                     * should we have to, we jump to a separate loop.  This
                     * extra 'if' statement is what keeps this code from being
                     * just a call to REXEC_FBC_UTF8_CLASS_SCAN() */
                    if (UTF8_IS_ABOVE_LATIN1(*s)) {
                        goto found_above_latin1;
                    }
                    if ((UTF8_IS_INVARIANT(*s)
                         && to_complement ^ cBOOL(_generic_isCC((U8) *s,
                                                                classnum)))
                        || (UTF8_IS_DOWNGRADEABLE_START(*s)
                            && to_complement ^ cBOOL(
                                _generic_isCC(TWO_BYTE_UTF8_TO_UNI(*s, *(s + 1)),
                                              classnum))))
                    {
                        if (tmp && (!reginfo || regtry(reginfo, &s)))
                            goto got_it;
                        else {
                            tmp = doevery;
d1930 11
a1940 73
                    }
                    else {
                        tmp = 1;
                    }
                    s += UTF8SKIP(s);
                }
            }
            else switch (classnum) {    /* These classes are implemented as
                                           macros */
                case _CC_ENUM_SPACE: /* XXX would require separate code if we
                                        revert the change of \v matching this */
                    /* FALL THROUGH */

                case _CC_ENUM_PSXSPC:
                    REXEC_FBC_UTF8_CLASS_SCAN(
                                        to_complement ^ cBOOL(isSPACE_utf8(s)));
                    break;

                case _CC_ENUM_BLANK:
                    REXEC_FBC_UTF8_CLASS_SCAN(
                                        to_complement ^ cBOOL(isBLANK_utf8(s)));
                    break;

                case _CC_ENUM_XDIGIT:
                    REXEC_FBC_UTF8_CLASS_SCAN(
                                       to_complement ^ cBOOL(isXDIGIT_utf8(s)));
                    break;

                case _CC_ENUM_VERTSPACE:
                    REXEC_FBC_UTF8_CLASS_SCAN(
                                       to_complement ^ cBOOL(isVERTWS_utf8(s)));
                    break;

                case _CC_ENUM_CNTRL:
                    REXEC_FBC_UTF8_CLASS_SCAN(
                                        to_complement ^ cBOOL(isCNTRL_utf8(s)));
                    break;

                default:
                    Perl_croak(aTHX_ "panic: find_byclass() node %d='%s' has an unexpected character class '%d'", OP(c), PL_reg_name[OP(c)], classnum);
                    assert(0); /* NOTREACHED */
            }
        }
        break;

      found_above_latin1:   /* Here we have to load a swash to get the result
                               for the current code point */
        if (! PL_utf8_swash_ptrs[classnum]) {
            U8 flags = _CORE_SWASH_INIT_ACCEPT_INVLIST;
            PL_utf8_swash_ptrs[classnum] =
                    _core_swash_init("utf8", swash_property_names[classnum],
                                     &PL_sv_undef, 1, 0, NULL, &flags);
        }

        /* This is a copy of the loop above for swash classes, though using the
         * FBC macro instead of being expanded out.  Since we've loaded the
         * swash, we don't have to check for that each time through the loop */
        REXEC_FBC_UTF8_CLASS_SCAN(
                to_complement ^ cBOOL(_generic_utf8(
                                      classnum,
                                      s,
                                      swash_fetch(PL_utf8_swash_ptrs[classnum],
                                                  (U8 *) s, TRUE))));
        break;

    case AHOCORASICKC:
    case AHOCORASICK:
        {
            DECL_TRIE_TYPE(c);
            /* what trie are we using right now */
            reg_ac_data *aho = (reg_ac_data*)progi->data->data[ ARG( c ) ];
            reg_trie_data *trie = (reg_trie_data*)progi->data->data[ aho->trie ];
            HV *widecharmap = MUTABLE_HV(progi->data->data[ aho->trie + 1 ]);
d1942 1
a1942 1
            const char *last_start = strend - trie->minlen;
d1944 1
a1944 1
            const char *real_start = s;
d1946 1
a1946 45
            STRLEN maxlen = trie->maxlen;
            SV *sv_points;
            U8 **points; /* map of where we were in the input string
                            when reading a given char. For ASCII this
                            is unnecessary overhead as the relationship
                            is always 1:1, but for Unicode, especially
                            case folded Unicode this is not true. */
            U8 foldbuf[ UTF8_MAXBYTES_CASE + 1 ];
            U8 *bitmap=NULL;


            GET_RE_DEBUG_FLAGS_DECL;

            /* We can't just allocate points here. We need to wrap it in
             * an SV so it gets freed properly if there is a croak while
             * running the match */
            ENTER;
            SAVETMPS;
            sv_points=newSV(maxlen * sizeof(U8 *));
            SvCUR_set(sv_points,
                maxlen * sizeof(U8 *));
            SvPOK_on(sv_points);
            sv_2mortal(sv_points);
            points=(U8**)SvPV_nolen(sv_points );
            if ( trie_type != trie_utf8_fold
                 && (trie->bitmap || OP(c)==AHOCORASICKC) )
            {
                if (trie->bitmap)
                    bitmap=(U8*)trie->bitmap;
                else
                    bitmap=(U8*)ANYOF_BITMAP(c);
            }
            /* this is the Aho-Corasick algorithm modified a touch
               to include special handling for long "unknown char" sequences.
               The basic idea being that we use AC as long as we are dealing
               with a possible matching char, when we encounter an unknown char
               (and we have not encountered an accepting state) we scan forward
               until we find a legal starting char.
               AC matching is basically that of trie matching, except that when
               we encounter a failing transition, we fall back to the current
               states "fail state", and try the current char again, a process
               we repeat until we reach the root state, state 1, or a legal
               transition. If we fail on the root state then we can either
               terminate if we have reached an accepting state previously, or
               restart the entire process from the beginning if we have not.
d1948 23
a1970 29
             */
            while (s <= last_start) {
                const U32 uniflags = UTF8_ALLOW_DEFAULT;
                U8 *uc = (U8*)s;
                U16 charid = 0;
                U32 base = 1;
                U32 state = 1;
                UV uvc = 0;
                STRLEN len = 0;
                STRLEN foldlen = 0;
                U8 *uscan = (U8*)NULL;
                U8 *leftmost = NULL;
#ifdef DEBUGGING
                U32 accepted_word= 0;
#endif
                U32 pointpos = 0;

                while ( state && uc <= (U8*)strend ) {
                    int failed=0;
                    U32 word = aho->states[ state ].wordnum;

                    if( state==1 ) {
                        if ( bitmap ) {
                            DEBUG_TRIE_EXECUTE_r(
                                if ( uc <= (U8*)last_start && !BITMAP_TEST(bitmap,*uc) ) {
                                    dump_exec_pos( (char *)uc, c, strend, real_start,
                                        (char *)uc, utf8_target );
                                    PerlIO_printf( Perl_debug_log,
                                        " Scanning for legal start char...\n");
d1972 5
a1976 8
                            );
                            if (utf8_target) {
                                while ( uc <= (U8*)last_start && !BITMAP_TEST(bitmap,*uc) ) {
                                    uc += UTF8SKIP(uc);
                                }
                            } else {
                                while ( uc <= (U8*)last_start  && !BITMAP_TEST(bitmap,*uc) ) {
                                    uc++;
d1979 13
a1991 1
                            s= (char *)uc;
a1992 1
                        if (uc >(U8*)last_start) break;
d1994 2
a1995 3

                    if ( word ) {
                        U8 *lpos= points[ (pointpos - trie->wordinfo[word].len) % maxlen ];
d1997 2
a1998 2
                            DEBUG_r(accepted_word=word);
                            leftmost= lpos;
a1999 2
                        if (base==0) break;

d2001 2
a2002 6
                    points[pointpos++ % maxlen]= uc;
                    if (foldlen || uc < (U8*)strend) {
                        REXEC_TRIE_READ_CHAR(trie_type, trie,
                                         widecharmap, uc,
                                         uscan, len, uvc, charid, foldlen,
                                         foldbuf, uniflags);
d2004 4
a2007 5
                            dump_exec_pos( (char *)uc, c, strend,
                                        real_start, s, utf8_target);
                            PerlIO_printf(Perl_debug_log,
                                " Charid:%3u CP:%4"UVxf" ",
                                 charid, uvc);
d2009 6
a2014 13
                    }
                    else {
                        len = 0;
                        charid = 0;
                    }


                    do {
#ifdef DEBUGGING
                        word = aho->states[ state ].wordnum;
#endif
                        base = aho->states[ state ].trans.base;

d2016 1
a2016 7
                            if (failed)
                                dump_exec_pos( (char *)uc, c, strend, real_start,
                                    s,   utf8_target );
                            PerlIO_printf( Perl_debug_log,
                                "%sState: %4"UVxf", word=%"UVxf,
                                failed ? " Fail transition to " : "",
                                (UV)state, (UV)word);
d2018 4
a2021 35
                        if ( base ) {
                            U32 tmp;
                            I32 offset;
                            if (charid &&
                                 ( ((offset = base + charid
                                    - 1 - trie->uniquecharcount)) >= 0)
                                 && ((U32)offset < trie->lasttrans)
                                 && trie->trans[offset].check == state
                                 && (tmp=trie->trans[offset].next))
                            {
                                DEBUG_TRIE_EXECUTE_r(
                                    PerlIO_printf( Perl_debug_log," - legal\n"));
                                state = tmp;
                                break;
                            }
                            else {
                                DEBUG_TRIE_EXECUTE_r(
                                    PerlIO_printf( Perl_debug_log," - fail\n"));
                                failed = 1;
                                state = aho->fail[state];
                            }
                        }
                        else {
                            /* we must be accepting here */
                            DEBUG_TRIE_EXECUTE_r(
                                    PerlIO_printf( Perl_debug_log," - accepting\n"));
                            failed = 1;
                            break;
                        }
                    } while(state);
                    uc += len;
                    if (failed) {
                        if (leftmost)
                            break;
                        if (!state) state = 1;
d2024 11
a2034 41
                if ( aho->states[ state ].wordnum ) {
                    U8 *lpos = points[ (pointpos - trie->wordinfo[aho->states[ state ].wordnum].len) % maxlen ];
                    if (!leftmost || lpos < leftmost) {
                        DEBUG_r(accepted_word=aho->states[ state ].wordnum);
                        leftmost = lpos;
                    }
                }
                if (leftmost) {
                    s = (char*)leftmost;
                    DEBUG_TRIE_EXECUTE_r({
                        PerlIO_printf(
                            Perl_debug_log,"Matches word #%"UVxf" at position %"IVdf". Trying full pattern...\n",
                            (UV)accepted_word, (IV)(s - real_start)
                        );
                    });
                    if (!reginfo || regtry(reginfo, &s)) {
                        FREETMPS;
                        LEAVE;
                        goto got_it;
                    }
                    s = HOPc(s,1);
                    DEBUG_TRIE_EXECUTE_r({
                        PerlIO_printf( Perl_debug_log,"Pattern failed. Looking for new start point...\n");
                    });
                } else {
                    DEBUG_TRIE_EXECUTE_r(
                        PerlIO_printf( Perl_debug_log,"No match.\n"));
                    break;
                }
            }
            FREETMPS;
            LEAVE;
        }
        break;
    default:
        Perl_croak(aTHX_ "panic: unknown regstclass %d", (int)OP(c));
        break;
    }
    return 0;
  got_it:
    return s;
d2042 1
a2042 1
Perl_regexec_flags(pTHX_ REGEXP * const rx, char *stringarg, char *strend,
d2044 7
a2050 11
/* stringarg: the point in the string at which to begin matching */
/* strend:    pointer to null at end of string */
/* strbeg:    real beginning of string */
/* minend:    end of match must be >= minend bytes after stringarg. */
/* sv:        SV being matched: only used for utf8 flag, pos() etc; string
 *            itself is accessed via the pointers above */
/* data:      May be used for some additional optimizations.
              Currently its only used, with a U32 cast, for transmitting
              the ganch offset when doing a /g match. This will change */
/* nosave:    For optimizations. */

d2053 4
a2056 4
    struct regexp *const prog = ReANY(rx);
    char *s;
    regnode *c;
    char *startpos = stringarg;
d2101 2
a2102 2
    RX_MATCH_TAINTED_off(rx);
    PL_reg_state.re_state_eval_setup_done = FALSE;
d2105 3
a2107 2
    reginfo.is_utf8_pat = cBOOL(RX_UTF8(rx));
    reginfo.warned = FALSE;
d2162 2
a2163 2
           to the re, and switch the buffer each match. If we fail,
           we switch it back; otherwise we leave it swapped.
a2167 6
	DEBUG_BUFFERS_r(PerlIO_printf(Perl_debug_log,
	    "rex=0x%"UVxf" saving  offs: orig=0x%"UVxf" new=0x%"UVxf"\n",
	    PTR2UV(prog),
	    PTR2UV(swap),
	    PTR2UV(prog->offs)
	));
d2276 1
a2276 1
	/* it must be a one character string (XXXX Except is_utf8_pat?) */
d2281 4
a2285 4
            if (! prog->anchored_utf8) {
                to_utf8_substr(prog);
            }
            ch = SvPVX_const(prog->anchored_utf8)[0];
a2294 1

a2296 6
            if (! prog->anchored_substr) {
                if (! to_byte_substr(prog)) {
                    NON_UTF8_TARGET_BUT_UTF8_REQUIRED(phooey);
                }
            }
            ch = SvPVX_const(prog->anchored_substr)[0];
d2325 3
a2327 14
	    if (utf8_target) {
                if (! prog->anchored_utf8) {
                    to_utf8_substr(prog);
                }
                must = prog->anchored_utf8;
            }
            else {
                if (! prog->anchored_substr) {
                    if (! to_byte_substr(prog)) {
                        NON_UTF8_TARGET_BUT_UTF8_REQUIRED(phooey);
                    }
                }
                must = prog->anchored_substr;
            }
d2330 3
a2332 14
	    if (utf8_target) {
                if (! prog->float_utf8) {
                    to_utf8_substr(prog);
                }
                must = prog->float_utf8;
            }
            else {
                if (! prog->float_substr) {
                    if (! to_byte_substr(prog)) {
                        NON_UTF8_TARGET_BUT_UTF8_REQUIRED(phooey);
                    }
                }
                must = prog->float_substr;
            }
d2336 1
d2338 4
d2360 4
a2363 1
		(s = fbm_instr((unsigned char*)HOP3(s, back_min, (back_min<0 ? strbeg : strend)),
d2365 4
a2368 1
				  multiline ? FBMrf_MULTILINE : 0)) ) {
d2384 1
a2384 5
                    if (s >= last1) {
                        s++; /* to break out of outer loop */
                        break;
                    }
                    s += UTF8SKIP(s);
d2424 1
a2424 1
        if (find_byclass(prog, c, s, strend, &reginfo, reginfo.is_utf8_pat))
a2433 2
	    STRLEN len;
	    const char *little;
d2435 25
a2459 26
	    if (utf8_target) {
                if (! prog->float_utf8) {
                    to_utf8_substr(prog);
                }
                float_real = prog->float_utf8;
            }
            else {
                if (! prog->float_substr) {
                    if (! to_byte_substr(prog)) {
                        NON_UTF8_TARGET_BUT_UTF8_REQUIRED(phooey);
                    }
                }
                float_real = prog->float_substr;
            }

            little = SvPV_const(float_real, len);
	    if (SvTAIL(float_real)) {
                    /* This means that float_real contains an artificial \n on
                     * the end due to the presence of something like this:
                     * /foo$/ where we can match both "foo" and "foo\n" at the
                     * end of the string.  So we have to compare the end of the
                     * string first against the float_real without the \n and
                     * then against the full float_real with the string.  We
                     * have to watch out for cases where the string might be
                     * smaller than the float_real or the float_real without
                     * the \n. */
d2466 1
a2466 2
                        /* can't match, even if we remove the trailing \n
                         * string is too short to match */
d2473 1
a2473 2
                        /* can match, the end of the string matches without the
                         * "\n" */
d2476 1
a2476 2
                        /* cant match, string is too short when the "\n" is
                         * included */
d2483 1
a2483 2
                        /* non multiline match, so compare with the "\n" at the
                         * end of the string */
d2494 1
a2494 2
                        /* multiline match, so we have to search for a place
                         * where the full string is located */
d2497 1
a2497 1
	    } else {
d2503 1
d2506 5
a2510 5
                /* at one point this block contained a comment which was
                 * probably incorrect, which said that this was a "should not
                 * happen" case.  Even if it was true when it was written I am
                 * pretty sure it is not anymore, so I have removed the comment
                 * and replaced it with this one. Yves */
a2543 8
    DEBUG_BUFFERS_r(
	if (swap)
	    PerlIO_printf(Perl_debug_log,
		"rex=0x%"UVxf" freeing offs: 0x%"UVxf"\n",
		PTR2UV(prog),
		PTR2UV(swap)
	    );
    );
d2545 1
d2547 1
a2547 1
    if (PL_reg_state.re_state_eval_setup_done)
d2554 1
d2556 4
a2559 2
#ifdef PERL_ANY_COW
	    if (SvCANCOW(sv)) {
a2564 1
                RX_MATCH_COPY_FREE(rx);
a2567 3
                prog->sublen  = PL_regeol - strbeg;
                prog->suboffset = 0;
                prog->subcoffset = 0;
d2571 5
a2575 87
                I32 min = 0;
                I32 max = PL_regeol - strbeg;
                I32 sublen;

                if (    (flags & REXEC_COPY_SKIP_POST)
                    && !(RX_EXTFLAGS(rx) & RXf_PMf_KEEPCOPY) /* //p */
                    && !(PL_sawampersand & SAWAMPERSAND_RIGHT)
                ) { /* don't copy $' part of string */
                    U32 n = 0;
                    max = -1;
                    /* calculate the right-most part of the string covered
                     * by a capture. Due to look-ahead, this may be to
                     * the right of $&, so we have to scan all captures */
                    while (n <= prog->lastparen) {
                        if (prog->offs[n].end > max)
                            max = prog->offs[n].end;
                        n++;
                    }
                    if (max == -1)
                        max = (PL_sawampersand & SAWAMPERSAND_LEFT)
                                ? prog->offs[0].start
                                : 0;
                    assert(max >= 0 && max <= PL_regeol - strbeg);
                }

                if (    (flags & REXEC_COPY_SKIP_PRE)
                    && !(RX_EXTFLAGS(rx) & RXf_PMf_KEEPCOPY) /* //p */
                    && !(PL_sawampersand & SAWAMPERSAND_LEFT)
                ) { /* don't copy $` part of string */
                    U32 n = 0;
                    min = max;
                    /* calculate the left-most part of the string covered
                     * by a capture. Due to look-behind, this may be to
                     * the left of $&, so we have to scan all captures */
                    while (min && n <= prog->lastparen) {
                        if (   prog->offs[n].start != -1
                            && prog->offs[n].start < min)
                        {
                            min = prog->offs[n].start;
                        }
                        n++;
                    }
                    if ((PL_sawampersand & SAWAMPERSAND_RIGHT)
                        && min >  prog->offs[0].end
                    )
                        min = prog->offs[0].end;

                }

                assert(min >= 0 && min <= max && min <= PL_regeol - strbeg);
                sublen = max - min;

                if (RX_MATCH_COPIED(rx)) {
                    if (sublen > prog->sublen)
                        prog->subbeg =
                                (char*)saferealloc(prog->subbeg, sublen+1);
                }
                else
                    prog->subbeg = (char*)safemalloc(sublen+1);
                Copy(strbeg + min, prog->subbeg, sublen, char);
                prog->subbeg[sublen] = '\0';
                prog->suboffset = min;
                prog->sublen = sublen;
                RX_MATCH_COPIED_on(rx);
	    }
            prog->subcoffset = prog->suboffset;
            if (prog->suboffset && utf8_target) {
                /* Convert byte offset to chars.
                 * XXX ideally should only compute this if @@-/@@+
                 * has been seen, a la PL_sawampersand ??? */

                /* If there's a direct correspondence between the
                 * string which we're matching and the original SV,
                 * then we can use the utf8 len cache associated with
                 * the SV. In particular, it means that under //g,
                 * sv_pos_b2u() will use the previously cached
                 * position to speed up working out the new length of
                 * subcoffset, rather than counting from the start of
                 * the string each time. This stops
                 *   $x = "\x{100}" x 1E6; 1 while $x =~ /(.)/g;
                 * from going quadratic */
                if (SvPOKp(sv) && SvPVX(sv) == strbeg)
                    sv_pos_b2u(sv, &(prog->subcoffset));
                else
                    prog->subcoffset = utf8_length((U8*)strbeg,
                                        (U8*)(strbeg+prog->suboffset));
            }
a2577 1
            RX_MATCH_COPY_FREE(rx);
a2578 2
	    prog->suboffset = 0;
	    prog->subcoffset = 0;
d2588 1
a2588 1
    if (PL_reg_state.re_state_eval_setup_done)
a2591 6
	DEBUG_BUFFERS_r(PerlIO_printf(Perl_debug_log,
	    "rex=0x%"UVxf" rolling back offs: freeing=0x%"UVxf" restoring=0x%"UVxf"\n",
	    PTR2UV(prog),
	    PTR2UV(prog->offs),
	    PTR2UV(swap)
	));
d2595 1
a2599 10
/* Set which rex is pointed to by PL_reg_state, handling ref counting.
 * Do inc before dec, in case old and new rex are the same */
#define SET_reg_curpm(Re2) \
    if (PL_reg_state.re_state_eval_setup_done) {    \
	(void)ReREFCNT_inc(Re2);		    \
	ReREFCNT_dec(PM_GETRE(PL_reg_curpm));	    \
	PM_SETRE((PL_reg_curpm), (Re2));	    \
    }


d2604 1
a2604 1
S_regtry(pTHX_ regmatch_info *reginfo, char **startposp)
d2609 1
a2609 2
    regexp *const prog = ReANY(rx);
    I32 result;
d2617 1
a2617 3
    if ((prog->extflags & RXf_EVAL_SEEN)
	&& !PL_reg_state.re_state_eval_setup_done)
    {
d2620 13
a2632 1
	PL_reg_state.re_state_eval_setup_done = TRUE;
d2668 10
a2677 1
	SET_reg_curpm(rx);
d2686 1
a2686 3
	    PL_reg_oldsavedoffset = prog->suboffset;
	    PL_reg_oldsavedcoffset = prog->suboffset;
#ifdef PERL_ANY_COW
a2693 2
	prog->suboffset = 0;
	prog->subcoffset = 0;
d2696 5
a2700 4
#ifdef DEBUGGING
    PL_reg_starttry = *startposp;
#endif
    prog->offs[0].start = *startposp - PL_bostr;
d2703 9
d2714 1
a2714 1
       to do this again and again, prog->lastparen should take care of
d2719 1
a2719 1
     * prog->lastparen), is not needed at all by the test suite
d2728 3
a2730 3
	regexp_paren_pair *pp = prog->offs;
	I32 i;
	for (i = prog->nparens; i > (I32)prog->lastparen; i--) {
d2738 2
a2739 3
    result = regmatch(reginfo, *startposp, progi->program + 1);
    if (result != -1) {
	prog->offs[0].end = result;
d2743 1
a2743 1
        *startposp= reginfo->cutpoint;
a2768 2
#define CHRTEST_NOT_A_CP_1 -999
#define CHRTEST_NOT_A_CP_2 -998
d2795 1
a2795 2
#define PUSH_STATE_GOTO(state, node, input) \
    pushinput = input; \
d2802 1
a2802 2
#define PUSH_YES_STATE_GOTO(state, node, input) \
    pushinput = input; \
a2808 1

d2874 1
a2874 1
	PUSH_YES_STATE_GOTO(IFMATCH_A, A, newinput);
d2911 2
a2912 2
	PUSH_STATE_GOTO(resume_state, node, newinput);
	PUSH_YES_STATE_GOTO(resume_state, node, newinput);
d3075 2
a3076 2
        if ((I32)rex->lastparen >= nums[n] &&
            rex->offs[nums[n]].end != -1)
a3101 63
static bool
S_setup_EXACTISH_ST_c1_c2(pTHX_ const regnode * const text_node, int *c1p,
        U8* c1_utf8, int *c2p, U8* c2_utf8, bool is_utf8_pat)
{
    /* This function determines if there are one or two characters that match
     * the first character of the passed-in EXACTish node <text_node>, and if
     * so, returns them in the passed-in pointers.
     *
     * If it determines that no possible character in the target string can
     * match, it returns FALSE; otherwise TRUE.  (The FALSE situation occurs if
     * the first character in <text_node> requires UTF-8 to represent, and the
     * target string isn't in UTF-8.)
     *
     * If there are more than two characters that could match the beginning of
     * <text_node>, or if more context is required to determine a match or not,
     * it sets both *<c1p> and *<c2p> to CHRTEST_VOID.
     *
     * The motiviation behind this function is to allow the caller to set up
     * tight loops for matching.  If <text_node> is of type EXACT, there is
     * only one possible character that can match its first character, and so
     * the situation is quite simple.  But things get much more complicated if
     * folding is involved.  It may be that the first character of an EXACTFish
     * node doesn't participate in any possible fold, e.g., punctuation, so it
     * can be matched only by itself.  The vast majority of characters that are
     * in folds match just two things, their lower and upper-case equivalents.
     * But not all are like that; some have multiple possible matches, or match
     * sequences of more than one character.  This function sorts all that out.
     *
     * Consider the patterns A*B or A*?B where A and B are arbitrary.  In a
     * loop of trying to match A*, we know we can't exit where the thing
     * following it isn't a B.  And something can't be a B unless it is the
     * beginning of B.  By putting a quick test for that beginning in a tight
     * loop, we can rule out things that can't possibly be B without having to
     * break out of the loop, thus avoiding work.  Similarly, if A is a single
     * character, we can make a tight loop matching A*, using the outputs of
     * this function.
     *
     * If the target string to match isn't in UTF-8, and there aren't
     * complications which require CHRTEST_VOID, *<c1p> and *<c2p> are set to
     * the one or two possible octets (which are characters in this situation)
     * that can match.  In all cases, if there is only one character that can
     * match, *<c1p> and *<c2p> will be identical.
     *
     * If the target string is in UTF-8, the buffers pointed to by <c1_utf8>
     * and <c2_utf8> will contain the one or two UTF-8 sequences of bytes that
     * can match the beginning of <text_node>.  They should be declared with at
     * least length UTF8_MAXBYTES+1.  (If the target string isn't in UTF-8, it is
     * undefined what these contain.)  If one or both of the buffers are
     * invariant under UTF-8, *<c1p>, and *<c2p> will also be set to the
     * corresponding invariant.  If variant, the corresponding *<c1p> and/or
     * *<c2p> will be set to a negative number(s) that shouldn't match any code
     * point (unless inappropriately coerced to unsigned).   *<c1p> will equal
     * *<c2p> if and only if <c1_utf8> and <c2_utf8> are the same. */

    const bool utf8_target = PL_reg_match_utf8;

    UV c1 = CHRTEST_NOT_A_CP_1;
    UV c2 = CHRTEST_NOT_A_CP_2;
    bool use_chrtest_void = FALSE;

    /* Used when we have both utf8 input and utf8 output, to avoid converting
     * to/from code points */
    bool utf8_has_been_setup = FALSE;
a3102 1
    dVAR;
d3104 3
a3106 1
    U8 *pat = (U8*)STRING(text_node);
d3108 2
a3109 191
    if (OP(text_node) == EXACT) {

        /* In an exact node, only one thing can be matched, that first
         * character.  If both the pat and the target are UTF-8, we can just
         * copy the input to the output, avoiding finding the code point of
         * that character */
        if (!is_utf8_pat) {
            c2 = c1 = *pat;
        }
        else if (utf8_target) {
            Copy(pat, c1_utf8, UTF8SKIP(pat), U8);
            Copy(pat, c2_utf8, UTF8SKIP(pat), U8);
            utf8_has_been_setup = TRUE;
        }
        else {
            c2 = c1 = valid_utf8_to_uvchr(pat, NULL);
        }
    }
    else /* an EXACTFish node */
         if ((is_utf8_pat
                    && is_MULTI_CHAR_FOLD_utf8_safe(pat,
                                                    pat + STR_LEN(text_node)))
             || (!is_utf8_pat
                    && is_MULTI_CHAR_FOLD_latin1_safe(pat,
                                                    pat + STR_LEN(text_node))))
    {
        /* Multi-character folds require more context to sort out.  Also
         * PL_utf8_foldclosures used below doesn't handle them, so have to be
         * handled outside this routine */
        use_chrtest_void = TRUE;
    }
    else { /* an EXACTFish node which doesn't begin with a multi-char fold */
        c1 = is_utf8_pat ? valid_utf8_to_uvchr(pat, NULL) : *pat;
        if (c1 > 256) {
            /* Load the folds hash, if not already done */
            SV** listp;
            if (! PL_utf8_foldclosures) {
                if (! PL_utf8_tofold) {
                    U8 dummy[UTF8_MAXBYTES+1];

                    /* Force loading this by folding an above-Latin1 char */
                    to_utf8_fold((U8*) HYPHEN_UTF8, dummy, NULL);
                    assert(PL_utf8_tofold); /* Verify that worked */
                }
                PL_utf8_foldclosures = _swash_inversion_hash(PL_utf8_tofold);
            }

            /* The fold closures data structure is a hash with the keys being
             * the UTF-8 of every character that is folded to, like 'k', and
             * the values each an array of all code points that fold to its
             * key.  e.g. [ 'k', 'K', KELVIN_SIGN ].  Multi-character folds are
             * not included */
            if ((! (listp = hv_fetch(PL_utf8_foldclosures,
                                     (char *) pat,
                                     UTF8SKIP(pat),
                                     FALSE))))
            {
                /* Not found in the hash, therefore there are no folds
                 * containing it, so there is only a single character that
                 * could match */
                c2 = c1;
            }
            else {  /* Does participate in folds */
                AV* list = (AV*) *listp;
                if (av_len(list) != 1) {

                    /* If there aren't exactly two folds to this, it is outside
                     * the scope of this function */
                    use_chrtest_void = TRUE;
                }
                else {  /* There are two.  Get them */
                    SV** c_p = av_fetch(list, 0, FALSE);
                    if (c_p == NULL) {
                        Perl_croak(aTHX_ "panic: invalid PL_utf8_foldclosures structure");
                    }
                    c1 = SvUV(*c_p);

                    c_p = av_fetch(list, 1, FALSE);
                    if (c_p == NULL) {
                        Perl_croak(aTHX_ "panic: invalid PL_utf8_foldclosures structure");
                    }
                    c2 = SvUV(*c_p);

                    /* Folds that cross the 255/256 boundary are forbidden if
                     * EXACTFL, or EXACTFA and one is ASCIII.  Since the
                     * pattern character is above 256, and its only other match
                     * is below 256, the only legal match will be to itself.
                     * We have thrown away the original, so have to compute
                     * which is the one above 255 */
                    if ((c1 < 256) != (c2 < 256)) {
                        if (OP(text_node) == EXACTFL
                            || (OP(text_node) == EXACTFA
                                && (isASCII(c1) || isASCII(c2))))
                        {
                            if (c1 < 256) {
                                c1 = c2;
                            }
                            else {
                                c2 = c1;
                            }
                        }
                    }
                }
            }
        }
        else /* Here, c1 is < 255 */
             if (utf8_target
                 && HAS_NONLATIN1_FOLD_CLOSURE(c1)
                 && OP(text_node) != EXACTFL
                 && (OP(text_node) != EXACTFA || ! isASCII(c1)))
        {
            /* Here, there could be something above Latin1 in the target which
             * folds to this character in the pattern.  All such cases except
             * LATIN SMALL LETTER Y WITH DIAERESIS have more than two characters
             * involved in their folds, so are outside the scope of this
             * function */
            if (UNLIKELY(c1 == LATIN_SMALL_LETTER_Y_WITH_DIAERESIS)) {
                c2 = LATIN_CAPITAL_LETTER_Y_WITH_DIAERESIS;
            }
            else {
                use_chrtest_void = TRUE;
            }
        }
        else { /* Here nothing above Latin1 can fold to the pattern character */
            switch (OP(text_node)) {

                case EXACTFL:   /* /l rules */
                    c2 = PL_fold_locale[c1];
                    break;

                case EXACTF:
                    if (! utf8_target) {    /* /d rules */
                        c2 = PL_fold[c1];
                        break;
                    }
                    /* FALLTHROUGH */
                    /* /u rules for all these.  This happens to work for
                     * EXACTFA as nothing in Latin1 folds to ASCII */
                case EXACTFA:
                case EXACTFU_TRICKYFOLD:
                case EXACTFU_SS:
                case EXACTFU:
                    c2 = PL_fold_latin1[c1];
                    break;

		default:
                    Perl_croak(aTHX_ "panic: Unexpected op %u", OP(text_node));
                    assert(0); /* NOTREACHED */
            }
        }
    }

    /* Here have figured things out.  Set up the returns */
    if (use_chrtest_void) {
        *c2p = *c1p = CHRTEST_VOID;
    }
    else if (utf8_target) {
        if (! utf8_has_been_setup) {    /* Don't have the utf8; must get it */
            uvchr_to_utf8(c1_utf8, c1);
            uvchr_to_utf8(c2_utf8, c2);
        }

        /* Invariants are stored in both the utf8 and byte outputs; Use
         * negative numbers otherwise for the byte ones.  Make sure that the
         * byte ones are the same iff the utf8 ones are the same */
        *c1p = (UTF8_IS_INVARIANT(*c1_utf8)) ? *c1_utf8 : CHRTEST_NOT_A_CP_1;
        *c2p = (UTF8_IS_INVARIANT(*c2_utf8))
                ? *c2_utf8
                : (c1 == c2)
                  ? CHRTEST_NOT_A_CP_1
                  : CHRTEST_NOT_A_CP_2;
    }
    else if (c1 > 255) {
       if (c2 > 255) {  /* both possibilities are above what a non-utf8 string
                           can represent */
           return FALSE;
       }

       *c1p = *c2p = c2;    /* c2 is the only representable value */
    }
    else {  /* c1 is representable; see about c2 */
       *c1p = c1;
       *c2p = (c2 < 256) ? c2 : c1;
    }

    return TRUE;
}

/* returns -1 on failure, $+[0] on success */
STATIC I32
S_regmatch(pTHX_ regmatch_info *reginfo, char *startpos, regnode *prog)
d3115 1
a3115 1
    const bool utf8_target = PL_reg_match_utf8;
d3118 1
a3118 1
    regexp *rex = ReANY(rex_sv);
d3122 1
a3122 1
    regmatch_state *st;
d3124 6
a3129 7
    regnode *scan;
    regnode *next;
    U32 n = 0;	/* general value; init to avoid compiler warning */
    I32 ln = 0; /* len or last;  init to avoid compiler warning */
    char *locinput = startpos;
    char *pushinput; /* where to continue after a PUSH */
    I32 nextchr;   /* is always set to UCHARAT(locinput) */
d3147 1
a3147 1
    char *startpoint = locinput;
a3168 11
    PAD* last_pad = NULL;
    dMULTICALL;
    I32 gimme = G_SCALAR;
    CV *caller_cv = NULL;	/* who called us */
    CV *last_pushed_cv = NULL;	/* most recently called (?{}) CV */
    CHECKPOINT runops_cp;	/* savestack position before executing EVAL */
    U32 maxopenparen = 0;       /* max '(' index seen so far */
    int to_complement;  /* Invert the result? */
    _char_class_number classnum;
    bool is_utf8_pat = reginfo->is_utf8_pat;

a3172 8
    /* shut up 'may be used uninitialized' compiler warnings for dMULTICALL */
    multicall_oldcatch = 0;
    multicall_cv = NULL;
    cx = NULL;
    PERL_UNUSED_VAR(multicall_cop);
    PERL_UNUSED_VAR(newsp);


d3197 1
a3197 1
    SET_nextchr;
a3220 1
        to_complement = 0;
d3222 3
a3224 2
        SET_nextchr;
        assert(nextchr < 256 && (nextchr >= 0 || nextchr == NEXTCHR_EOS));
d3227 1
a3227 1
	case BOL: /*  /^../  */
d3234 1
a3234 2

	case MBOL: /*  /^../m  */
d3236 1
a3236 1
		(!NEXTCHR_IS_EOS && locinput[-1] == '\n'))
d3241 1
a3241 2

	case SBOL: /*  /^../s  */
d3245 1
a3245 2

	case GPOS: /*  \G  */
d3250 1
a3250 1
	case KEEPS: /*   \K  */
d3252 5
a3256 4
	    st->u.keeper.val = rex->offs[0].start;
	    rex->offs[0].start = locinput - PL_bostr;
	    PUSH_STATE_GOTO(KEEPS_next, next, locinput);
	    assert(0); /*NOTREACHED*/
d3259 1
a3259 1
	    rex->offs[0].start = st->u.keeper.val;
d3261 2
a3262 3
	    assert(0); /*NOTREACHED*/

	case EOL: /* /..$/  */
d3264 2
a3265 3

	case MEOL: /* /..$/m  */
	    if (!NEXTCHR_IS_EOS && nextchr != '\n')
d3268 1
a3268 2

	case SEOL: /* /..$/s  */
d3270 1
a3270 1
	    if (!NEXTCHR_IS_EOS && nextchr != '\n')
d3275 2
a3276 3

	case EOS: /*  \z  */
	    if (!NEXTCHR_IS_EOS)
d3279 2
a3280 3

	case SANY: /*  /./s  */
	    if (NEXTCHR_IS_EOS)
d3282 11
a3292 4
            goto increment_locinput;

	case CANY: /*  \C  */
	    if (NEXTCHR_IS_EOS)
d3294 1
a3294 1
	    locinput++;
d3296 2
a3297 3

	case REG_ANY: /*  /./  */
	    if ((NEXTCHR_IS_EOS) || nextchr == '\n')
d3299 9
a3307 2
            goto increment_locinput;

d3311 1
a3311 1
        case TRIEC: /* (ab|cd) with known charclass */
d3315 1
a3315 1
            if(!NEXTCHR_IS_EOS && !ANYOF_BITMAP_TEST(scan, nextchr)) {
d3322 1
a3322 1
                assert(0); /* NOTREACHED */
d3325 1
a3325 1
	case TRIE:  /* (ab|cd)  */
d3334 1
a3334 1
	     * matching word being 4, and the shortest being 2 (with
d3380 1
a3380 3
                if (   trie->bitmap
                    && (NEXTCHR_IS_EOS || !TRIE_BITMAP_TEST(trie, nextchr)))
                {
d3409 1
d3454 1
a3454 1
		    if ( base && (foldlen || uc < (U8*)PL_regeol)) {
d3508 1
a3508 1
	    assert(0); /* NOTREACHED */
a3510 2
        {
            U8 *uc;
d3513 3
a3515 1
                UNWIND_PAREN(ST.lastparen, ST.lastcloseparen);
d3530 4
a3533 4
		U16 min = 0;
		U16 word;
		U16 const nextword = ST.nextword;
		reg_trie_wordinfo * const wordinfo
d3549 1
a3549 2
                ST.lastparen = rex->lastparen;
                ST.lastcloseparen = rex->lastcloseparen;
d3556 1
a3563 1
		uc = ST.firstpos;
d3603 1
d3606 3
a3608 3
	    scan = ST.me + ((ST.jump && ST.jump[ST.nextword])
			    ? ST.jump[ST.nextword]
			    : NEXT_OFF(ST.me));
d3621 2
a3622 2
		PUSH_STATE_GOTO(TRIE_next, scan, (char*)uc);
		assert(0); /* NOTREACHED */
d3644 2
a3645 1
	    locinput = (char*)uc;
d3647 1
a3647 2
	    assert(0); /* NOTREACHED */
        }
d3650 1
a3650 1
	case EXACT: {            /*  /abc/        */
d3653 1
a3653 1
	    if (utf8_target != is_utf8_pat) {
d3659 1
a3659 9
                    /* The target is utf8, the pattern is not utf8.
                     * Above-Latin1 code points can't match the pattern;
                     * invariants match exactly, and the other Latin1 ones need
                     * to be downgraded to a single byte in order to do the
                     * comparison.  (If we could be confident that the target
                     * is not malformed, this could be refactored to have fewer
                     * tests by just assuming that if the first bytes match, it
                     * is an invariant, but there are tests in the test suite
                     * dealing with (??{...}) which violate this) */
d3661 9
a3669 16
			if (l >= PL_regeol || UTF8_IS_ABOVE_LATIN1(* (U8*) l)) {
                            sayNO;
                        }
                        if (UTF8_IS_INVARIANT(*(U8*)l)) {
			    if (*l != *s) {
                                sayNO;
                            }
                            l++;
                        }
                        else {
                            if (TWO_BYTE_UTF8_TO_UNI(*l, *(l+1)) != * (U8*) s) {
                                sayNO;
                            }
                            l += 2;
                        }
			s++;
d3675 9
a3683 17
                        if (l >= PL_regeol || UTF8_IS_ABOVE_LATIN1(* (U8*) s))
                        {
                            sayNO;
                        }
                        if (UTF8_IS_INVARIANT(*(U8*)s)) {
			    if (*s != *l) {
                                sayNO;
                            }
                            s++;
                        }
                        else {
                            if (TWO_BYTE_UTF8_TO_UNI(*s, *(s+1)) != * (U8*) l) {
                                sayNO;
                            }
                            s += 2;
                        }
			l++;
d3687 2
d3690 10
a3699 11
            else {
                /* The target and the pattern have the same utf8ness. */
                /* Inline the first character, for speed. */
                if (PL_regeol - locinput < ln
                    || UCHARAT(s) != nextchr
                    || (ln > 1 && memNE(s, locinput, ln)))
                {
                    sayNO;
                }
                locinput += ln;
            }
d3702 1
a3702 2

	case EXACTFL: {          /*  /abc/il      */
d3708 3
a3710 3
            RX_MATCH_TAINTED_on(reginfo->prog);
            folder = foldEQ_locale;
            fold_array = PL_fold_locale;
d3714 3
a3716 3
	case EXACTFU_SS:         /*  /\x{df}/iu   */
	case EXACTFU_TRICKYFOLD: /*  /\x{390}/iu  */
	case EXACTFU:            /*  /abc/iu      */
d3719 1
a3719 1
	    fold_utf8_flags = is_utf8_pat ? FOLDEQ_S1_ALREADY_FOLDED : 0;
d3722 1
a3722 1
	case EXACTFA:            /*  /abc/iaa     */
d3728 1
a3728 1
	case EXACTF:             /*  /abc/i       */
d3737 1
a3737 1
	    if (utf8_target || is_utf8_pat || state_num == EXACTFU_SS) {
d3743 1
a3743 1
		if (! foldEQ_utf8_flags(s, 0,  ln, is_utf8_pat,
d3749 1
d3754 2
a3755 3
	    if (UCHARAT(s) != nextchr
                && !NEXTCHR_IS_EOS
		&& UCHARAT(s) != fold_array[nextchr])
d3764 1
d3771 3
a3773 3
	case BOUNDL:  /*  /\b/l  */
	case NBOUNDL: /*  /\B/l  */
            RX_MATCH_TAINTED_on(reginfo->prog);
d3775 6
a3780 6
	case BOUND:   /*  /\b/   */
	case BOUNDU:  /*  /\b/u  */
	case BOUNDA:  /*  /\b/a  */
	case NBOUND:  /*  /\B/   */
	case NBOUNDU: /*  /\B/u  */
	case NBOUNDA: /*  /\B/a  */
d3794 3
a3796 8
		    ln = isWORDCHAR_uni(ln);
                    if (NEXTCHR_IS_EOS)
                        n = 0;
                    else {
                        LOAD_UTF8_CHARCLASS_ALNUM();
                        n = swash_fetch(PL_utf8_swash_ptrs[_CC_WORDCHAR], (U8*)locinput,
                                                                utf8_target);
                    }
d3799 2
a3800 2
		    ln = isWORDCHAR_LC_uvchr(UNI_TO_NATIVE(ln));
		    n = NEXTCHR_IS_EOS ? 0 : isWORDCHAR_LC_utf8((U8*)locinput);
d3821 1
a3821 1
			n = NEXTCHR_IS_EOS ? 0 : isWORDCHAR_L1(nextchr);
d3824 2
a3825 2
			ln = isWORDCHAR_LC(ln);
			n = NEXTCHR_IS_EOS ? 0 : isWORDCHAR_LC(nextchr);
d3828 2
a3829 2
			ln = isWORDCHAR(ln);
			n = NEXTCHR_IS_EOS ? 0 : isWORDCHAR(nextchr);
d3834 1
a3834 1
			n = NEXTCHR_IS_EOS ? 0 : isWORDCHAR_A(nextchr);
d3846 6
d3853 1
a3853 6
	case ANYOF:  /*  /[abc]/       */
	case ANYOF_WARN_SUPER:
            if (NEXTCHR_IS_EOS)
                sayNO;
	    if (utf8_target) {
	        if (!reginclass(rex, scan, (U8*)locinput, utf8_target))
d3855 3
a3857 1
		locinput += UTF8SKIP(locinput);
d3860 4
d3866 2
a3867 1
		locinput++;
d3870 17
d3888 4
a3891 2
        /* The argument (FLAGS) to all the POSIX node types is the class number
         * */
d3893 41
a3933 3
        case NPOSIXL:   /* \W or [:^punct:] etc. under /l */
            to_complement = 1;
            /* FALLTHROUGH */
d3935 6
a3940 202
        case POSIXL:    /* \w or [:punct:] etc. under /l */
            if (NEXTCHR_IS_EOS)
                sayNO;

            /* The locale hasn't influenced the outcome before this, so defer
             * tainting until now */
            RX_MATCH_TAINTED_on(reginfo->prog);

            /* Use isFOO_lc() for characters within Latin1.  (Note that
             * UTF8_IS_INVARIANT works even on non-UTF-8 strings, or else
             * wouldn't be invariant) */
            if (UTF8_IS_INVARIANT(nextchr) || ! utf8_target) {
                if (! (to_complement ^ cBOOL(isFOO_lc(FLAGS(scan), (U8) nextchr)))) {
                    sayNO;
                }
            }
            else if (UTF8_IS_DOWNGRADEABLE_START(nextchr)) {
                if (! (to_complement ^ cBOOL(isFOO_lc(FLAGS(scan),
                                        (U8) TWO_BYTE_UTF8_TO_UNI(nextchr,
                                                            *(locinput + 1))))))
                {
                    sayNO;
                }
            }
            else { /* Here, must be an above Latin-1 code point */
                goto utf8_posix_not_eos;
            }

            /* Here, must be utf8 */
            locinput += UTF8SKIP(locinput);
            break;

        case NPOSIXD:   /* \W or [:^punct:] etc. under /d */
            to_complement = 1;
            /* FALLTHROUGH */

        case POSIXD:    /* \w or [:punct:] etc. under /d */
            if (utf8_target) {
                goto utf8_posix;
            }
            goto posixa;

        case NPOSIXA:   /* \W or [:^punct:] etc. under /a */

            if (NEXTCHR_IS_EOS) {
                sayNO;
            }

            /* All UTF-8 variants match */
            if (! UTF8_IS_INVARIANT(nextchr)) {
                goto increment_locinput;
            }

            to_complement = 1;
            /* FALLTHROUGH */

        case POSIXA:    /* \w or [:punct:] etc. under /a */

          posixa:
            /* We get here through POSIXD, NPOSIXD, and NPOSIXA when not in
             * UTF-8, and also from NPOSIXA even in UTF-8 when the current
             * character is a single byte */

            if (NEXTCHR_IS_EOS
                || ! (to_complement ^ cBOOL(_generic_isCC_A(nextchr,
                                                            FLAGS(scan)))))
            {
                sayNO;
            }

            /* Here we are either not in utf8, or we matched a utf8-invariant,
             * so the next char is the next byte */
            locinput++;
            break;

        case NPOSIXU:   /* \W or [:^punct:] etc. under /u */
            to_complement = 1;
            /* FALLTHROUGH */

        case POSIXU:    /* \w or [:punct:] etc. under /u */
          utf8_posix:
            if (NEXTCHR_IS_EOS) {
                sayNO;
            }
          utf8_posix_not_eos:

            /* Use _generic_isCC() for characters within Latin1.  (Note that
             * UTF8_IS_INVARIANT works even on non-UTF-8 strings, or else
             * wouldn't be invariant) */
            if (UTF8_IS_INVARIANT(nextchr) || ! utf8_target) {
                if (! (to_complement ^ cBOOL(_generic_isCC(nextchr,
                                                           FLAGS(scan)))))
                {
                    sayNO;
                }
                locinput++;
            }
            else if (UTF8_IS_DOWNGRADEABLE_START(nextchr)) {
                if (! (to_complement
                       ^ cBOOL(_generic_isCC(TWO_BYTE_UTF8_TO_UNI(nextchr,
                                                               *(locinput + 1)),
                                              FLAGS(scan)))))
                {
                    sayNO;
                }
                locinput += 2;
            }
            else {  /* Handle above Latin-1 code points */
                classnum = (_char_class_number) FLAGS(scan);
                if (classnum < _FIRST_NON_SWASH_CC) {

                    /* Here, uses a swash to find such code points.  Load if if
                     * not done already */
                    if (! PL_utf8_swash_ptrs[classnum]) {
                        U8 flags = _CORE_SWASH_INIT_ACCEPT_INVLIST;
                        PL_utf8_swash_ptrs[classnum]
                                = _core_swash_init("utf8",
                                        swash_property_names[classnum],
                                        &PL_sv_undef, 1, 0, NULL, &flags);
                    }
                    if (! (to_complement
                           ^ cBOOL(swash_fetch(PL_utf8_swash_ptrs[classnum],
                                               (U8 *) locinput, TRUE))))
                    {
                        sayNO;
                    }
                }
                else {  /* Here, uses macros to find above Latin-1 code points */
                    switch (classnum) {
                        case _CC_ENUM_SPACE:    /* XXX would require separate
                                                   code if we revert the change
                                                   of \v matching this */
                        case _CC_ENUM_PSXSPC:
                            if (! (to_complement
                                        ^ cBOOL(is_XPERLSPACE_high(locinput))))
                            {
                                sayNO;
                            }
                            break;
                        case _CC_ENUM_BLANK:
                            if (! (to_complement
                                            ^ cBOOL(is_HORIZWS_high(locinput))))
                            {
                                sayNO;
                            }
                            break;
                        case _CC_ENUM_XDIGIT:
                            if (! (to_complement
                                            ^ cBOOL(is_XDIGIT_high(locinput))))
                            {
                                sayNO;
                            }
                            break;
                        case _CC_ENUM_VERTSPACE:
                            if (! (to_complement
                                            ^ cBOOL(is_VERTWS_high(locinput))))
                            {
                                sayNO;
                            }
                            break;
                        default:    /* The rest, e.g. [:cntrl:], can't match
                                       above Latin1 */
                            if (! to_complement) {
                                sayNO;
                            }
                            break;
                    }
                }
                locinput += UTF8SKIP(locinput);
            }
            break;

	case CLUMP: /* Match \X: logical Unicode character.  This is defined as
		       a Unicode extended Grapheme Cluster */
	    /* From http://www.unicode.org/reports/tr29 (5.2 version).  An
	      extended Grapheme Cluster is:

            CR LF
            | Prepend* Begin Extend*
            | .

            Begin is:           ( Special_Begin | ! Control )
            Special_Begin is:   ( Regional-Indicator+ | Hangul-syllable )
            Extend is:          ( Grapheme_Extend | Spacing_Mark )
            Control is:         [ GCB_Control | CR | LF ]
            Hangul-syllable is: ( T+ | ( L* ( L | ( LVT | ( V | LV ) V* ) T* ) ))

               If we create a 'Regular_Begin' = Begin - Special_Begin, then
               we can rewrite

                   Begin is ( Regular_Begin + Special Begin )

               It turns out that 98.4% of all Unicode code points match
               Regular_Begin.  Doing it this way eliminates a table match in
               the previous implementation for almost all Unicode code points.

	       There is a subtlety with Prepend* which showed up in testing.
	       Note that the Begin, and only the Begin is required in:
	        | Prepend* Begin Extend*
	       Also, Begin contains '! Control'.  A Prepend must be a
	       '!  Control', which means it must also be a Begin.  What it
	       comes down to is that if we match Prepend* and then find no
d3945 1
a3945 1
	    if (NEXTCHR_IS_EOS)
d3955 1
a3955 4
		    && UCHARAT(locinput) == '\n')
                {
                    locinput++;
                }
d3961 1
a3961 3
		if ( nextchr == '\r' && locinput+1 < PL_regeol
                     && UCHARAT(locinput + 1) == '\n')
                {
a3964 2
                    STRLEN len;

d3969 1
a3969 1
		    char *previous_prepend = NULL;
d3973 8
a3980 7
                    /* Match (prepend)*   */
                    while (locinput < PL_regeol
                           && (len = is_GCB_Prepend_utf8(locinput)))
                    {
                        previous_prepend = locinput;
                        locinput += len;
                    }
d3987 2
a3988 4
			    || (! swash_fetch(PL_utf8_X_regular_begin,
					     (U8*)locinput, utf8_target)
			         && ! is_GCB_SPECIAL_BEGIN_START_utf8(locinput)))
                        )
d3998 1
a3998 5
		    if (swash_fetch(PL_utf8_X_regular_begin,
                                    (U8*)locinput, utf8_target)) {
                        locinput += UTF8SKIP(locinput);
                    }
                    else if (! is_GCB_SPECIAL_BEGIN_START_utf8(locinput)) {
a4003 1
                        goto exit_utf8;
d4006 6
a4011 19
                        /* Here is a special begin.  It can be composed of
                         * several individual characters.  One possibility is
                         * RI+ */
                        if ((len = is_GCB_RI_utf8(locinput))) {
                            locinput += len;
                            while (locinput < PL_regeol
                                   && (len = is_GCB_RI_utf8(locinput)))
                            {
                                locinput += len;
                            }
                        } else if ((len = is_GCB_T_utf8(locinput))) {
                            /* Another possibility is T+ */
                            locinput += len;
                            while (locinput < PL_regeol
                                && (len = is_GCB_T_utf8(locinput)))
                            {
                                locinput += len;
                            }
                        } else {
d4013 4
a4016 11
                            /* Here, neither RI+ nor T+; must be some other
                             * Hangul.  That means it is one of the others: L,
                             * LV, LVT or V, and matches:
                             * L* (L | LVT T* | V * V* T* | LV  V* T*) */

                            /* Match L*           */
                            while (locinput < PL_regeol
                                   && (len = is_GCB_L_utf8(locinput)))
                            {
                                locinput += len;
                            }
d4018 69
a4086 20
                            /* Here, have exhausted L*.  If the next character
                             * is not an LV, LVT nor V, it means we had to have
                             * at least one L, so matches L+ in the original
                             * equation, we have a complete hangul syllable.
                             * Are done. */

                            if (locinput < PL_regeol
                                && is_GCB_LV_LVT_V_utf8(locinput))
                            {
                                /* Otherwise keep going.  Must be LV, LVT or V.
                                 * See if LVT, by first ruling out V, then LV */
                                if (! is_GCB_V_utf8(locinput)
                                        /* All but every TCount one is LV */
                                    && (valid_utf8_to_uvchr((U8 *) locinput,
                                                                         NULL)
                                                                        - SBASE)
                                        % TCount != 0)
                                {
                                    locinput += UTF8SKIP(locinput);
                                } else {
d4088 8
a4095 28
                                    /* Must be  V or LV.  Take it, then match
                                     * V*     */
                                    locinput += UTF8SKIP(locinput);
                                    while (locinput < PL_regeol
                                           && (len = is_GCB_V_utf8(locinput)))
                                    {
                                        locinput += len;
                                    }
                                }

                                /* And any of LV, LVT, or V can be followed
                                 * by T*            */
                                while (locinput < PL_regeol
                                       && (len = is_GCB_T_utf8(locinput)))
                                {
                                    locinput += len;
                                }
                            }
                        }
                    }

                    /* Match any extender */
                    while (locinput < PL_regeol
                            && swash_fetch(PL_utf8_X_extend,
                                            (U8*)locinput, utf8_target))
                    {
                        locinput += UTF8SKIP(locinput);
                    }
a4096 1
            exit_utf8:
d4099 1
d4102 1
a4102 1
	case NREFFL:  /*  /\g{name}/il  */
d4115 1
a4115 1
            RX_MATCH_TAINTED_on(reginfo->prog);
d4122 1
a4122 1
	case NREFFA:  /*  /\g{name}/iaa  */
d4129 1
a4129 1
	case NREFFU:  /*  /\g{name}/iu  */
d4136 1
a4136 1
	case NREFF:  /*  /\g{name}/i  */
d4143 1
a4143 1
	case NREF:  /*  /\g{name}/   */
d4159 2
a4160 2
	case REFFL:  /*  /\1/il  */
            RX_MATCH_TAINTED_on(reginfo->prog);
d4166 1
a4166 1
	case REFFA:  /*  /\1/iaa  */
d4172 1
a4172 1
	case REFFU:  /*  /\1/iu  */
d4178 1
a4178 1
	case REFF:  /*  /\1/i  */
d4184 1
a4184 1
        case REF:  /*  /\1/    */
d4194 1
a4194 1
	    ln = rex->offs[n].start;
d4196 1
a4196 1
	    if (rex->lastparen < n || ln == -1)
d4198 1
a4198 1
	    if (ln == rex->offs[n].end)
d4210 1
a4210 1
		    * <limit> upon success, how much of the current input was
d4212 1
a4212 1
		if (! foldEQ_utf8_flags(s, NULL, rex->offs[n].end - ln, utf8_target,
d4218 1
d4223 1
a4223 2
	    if (!NEXTCHR_IS_EOS &&
                UCHARAT(s) != nextchr &&
d4227 1
a4227 1
	    ln = rex->offs[n].end - ln;
d4235 1
d4238 2
a4239 3

	case NOTHING: /* null op; e.g. the 'nothing' following
                       * the '*' in m{(a+|b)*}' */
d4241 1
a4241 4
	case TAIL: /* placeholder while compiling (A|B|C) */
	    break;

	case BACK: /* ??? doesn't appear to be used ??? */
d4253 1
a4253 1
	case GOSTART: /*  (?R)  */
d4268 1
d4277 1
a4277 2
            assert(0); /* NOTREACHED */

a4286 1

d4288 2
a4289 2
		IV before;
		OP * const oop = PL_op;
d4291 1
a4291 1
		OP *nop;
a4293 5
		CV *newcv;

		/* save *all* paren positions */
		regcppush(rex, 0, maxopenparen);
		REGCP_SET(runops_cp);
a4310 3
		if (!caller_cv)
		    caller_cv = find_runcv(NULL);

d4312 1
a4312 79

		if (rexi->data->what[n] == 'r') { /* code from an external qr */
		    newcv = (ReANY(
						(REGEXP*)(rexi->data->data[n])
					    ))->qr_anoncv
					;
		    nop = (OP*)rexi->data->data[n+1];
		}
		else if (rexi->data->what[n] == 'l') { /* literal code */
		    newcv = caller_cv;
		    nop = (OP*)rexi->data->data[n];
		    assert(CvDEPTH(newcv));
		}
		else {
		    /* literal with own CV */
		    assert(rexi->data->what[n] == 'L');
		    newcv = rex->qr_anoncv;
		    nop = (OP*)rexi->data->data[n];
		}

		/* normally if we're about to execute code from the same
		 * CV that we used previously, we just use the existing
		 * CX stack entry. However, its possible that in the
		 * meantime we may have backtracked, popped from the save
		 * stack, and undone the SAVECOMPPAD(s) associated with
		 * PUSH_MULTICALL; in which case PL_comppad no longer
		 * points to newcv's pad. */
		if (newcv != last_pushed_cv || PL_comppad != last_pad)
		{
                    U8 flags = (CXp_SUB_RE |
                                ((newcv == caller_cv) ? CXp_SUB_RE_FAKE : 0));
		    if (last_pushed_cv) {
			CHANGE_MULTICALL_FLAGS(newcv, flags);
		    }
		    else {
			PUSH_MULTICALL_FLAGS(newcv, flags);
		    }
		    last_pushed_cv = newcv;
		}
		else {
                    /* these assignments are just to silence compiler
                     * warnings */
		    multicall_cop = NULL;
		    newsp = NULL;
		}
		last_pad = PL_comppad;

		/* the initial nextstate you would normally execute
		 * at the start of an eval (which would cause error
		 * messages to come from the eval), may be optimised
		 * away from the execution path in the regex code blocks;
		 * so manually set PL_curcop to it initially */
		{
		    OP *o = cUNOPx(nop)->op_first;
		    assert(o->op_type == OP_NULL);
		    if (o->op_targ == OP_SCOPE) {
			o = cUNOPo->op_first;
		    }
		    else {
			assert(o->op_targ == OP_LEAVE);
			o = cUNOPo->op_first;
			assert(o->op_type == OP_ENTER);
			o = o->op_sibling;
		    }

		    if (o->op_type != OP_STUB) {
			assert(    o->op_type == OP_NEXTSTATE
				|| o->op_type == OP_DBSTATE
				|| (o->op_type == OP_NULL
				    &&  (  o->op_targ == OP_NEXTSTATE
					|| o->op_targ == OP_DBSTATE
					)
				    )
			);
			PL_curcop = (COP*)o;
		    }
		}
		nop = nop->op_next;

d4314 9
a4322 3
		    "  re EVAL PL_op=0x%"UVxf"\n", PTR2UV(nop)) );

		rex->offs[0].end = PL_reg_magic->mg_len = locinput - PL_bostr;
a4328 5
		/* we don't use MULTICALL here as we want to call the
		 * first op of the block of interest, rather than the
		 * first op of the sub */
		before = (IV)(SP-PL_stack_base);
		PL_op = nop;
d4331 1
a4331 1
		if ((IV)(SP-PL_stack_base) == before)
a4337 38
		/* before restoring everything, evaluate the returned
		 * value, so that 'uninit' warnings don't use the wrong
		 * PL_op or pad. Also need to process any magic vars
		 * (e.g. $1) *before* parentheses are restored */

		PL_op = NULL;

                re_sv = NULL;
		if (logical == 0)        /*   (?{})/   */
		    sv_setsv(save_scalar(PL_replgv), ret); /* $^R */
		else if (logical == 1) { /*   /(?(?{...})X|Y)/    */
		    sw = cBOOL(SvTRUE(ret));
		    logical = 0;
		}
		else {                   /*  /(??{})  */
		    /*  if its overloaded, let the regex compiler handle
		     *  it; otherwise extract regex, or stringify  */
		    if (!SvAMAGIC(ret)) {
			SV *sv = ret;
			if (SvROK(sv))
			    sv = SvRV(sv);
			if (SvTYPE(sv) == SVt_REGEXP)
			    re_sv = (REGEXP*) sv;
			else if (SvSMAGICAL(sv)) {
			    MAGIC *mg = mg_find(sv, PERL_MAGIC_qr);
			    if (mg)
				re_sv = (REGEXP *) mg->mg_obj;
			}

			/* force any magic, undef warnings here */
			if (!re_sv) {
			    ret = sv_mortalcopy(ret);
			    (void) SvPV_force_nolen(ret);
			}
		    }

		}

a4339 4
		/* *** Note that at this point we don't restore
		 * PL_comppad, (or pop the CxSUB) on the assumption it may
		 * be used again soon. This is safe as long as nothing
		 * in the regexp code uses the pad ! */
d4341 2
d4345 3
a4347 3
		S_regcp_restore(aTHX_ rex, runops_cp, &maxopenparen);

		if (logical != 2)
d4349 1
d4351 1
a4351 2

		/* only /(??{})/  from now on */
d4356 30
d4387 6
a4392 2
		    if (re_sv) {
			re_sv = reg_temp_copy(NULL, re_sv);
d4396 1
d4398 8
a4405 3
			if (SvUTF8(ret) && IN_BYTES) {
			    /* In use 'bytes': make a copy of the octet
			     * sequence, but without the flag on */
d4410 1
a4410 13
			if (rex->intflags & PREGf_USE_RE_EVAL)
			    pm_flags |= PMf_USE_RE_EVAL;

			/* if we got here, it should be an engine which
			 * supports compiling code blocks and stuff */
			assert(rex->engine && rex->engine->op_comp);
                        assert(!(scan->flags & ~RXf_PMf_COMPILETIME));
			re_sv = rex->engine->op_comp(aTHX_ &ret, 1, NULL,
				    rex->engine, NULL, NULL,
                                    /* copy /msix etc to inner pattern */
                                    scan->flags,
                                    pm_flags);

d4417 1
a4417 1
			    sv_magic(ret, MUTABLE_SV(re_sv), PERL_MAGIC_qr, 0, 0);
d4419 1
a4419 4
			/* safe to do now that any $1 etc has been
			 * interpolated into the new pattern string and
			 * compiled */
			S_regcp_restore(aTHX_ rex, runops_cp, &maxopenparen);
d4421 2
a4422 2
		    SAVEFREESV(re_sv);
		    re = ReANY(re_sv);
a4426 2
                re->suboffset = rex->suboffset;
                re->subcoffset = rex->subcoffset;
d4434 8
d4445 1
a4445 3

                /* Save *all* the positions. */
		ST.cp = regcppush(rex, 0, maxopenparen);
d4448 5
d4456 2
a4457 1
		maxopenparen = 0;
d4462 6
a4467 2
		ST.saved_utf8_pat = is_utf8_pat;
		is_utf8_pat = cBOOL(RX_UTF8(re_sv));
d4471 1
a4471 2
		rex_sv = re_sv;
		SET_reg_curpm(rex_sv);
d4479 7
a4485 2
		PUSH_YES_STATE_GOTO(EVAL_AB, startpoint, locinput);
		assert(0); /* NOTREACHED */
d4490 4
a4493 4
            is_utf8_pat = ST.saved_utf8_pat;
	    rex_sv = ST.prev_rex;
	    SET_reg_curpm(rex_sv);
	    rex = ReANY(rex_sv);
d4499 6
d4514 4
a4517 4
            is_utf8_pat = ST.saved_utf8_pat;
	    rex_sv = ST.prev_rex;
	    SET_reg_curpm(rex_sv);
	    rex = ReANY(rex_sv);
d4519 3
d4523 1
d4525 1
a4525 1
	    regcppop(rex, &maxopenparen);
d4535 1
a4535 1
	case OPEN: /*  (  */
d4537 3
a4539 11
	    rex->offs[n].start_tmp = locinput - PL_bostr;
	    if (n > maxopenparen)
		maxopenparen = n;
	    DEBUG_BUFFERS_r(PerlIO_printf(Perl_debug_log,
		"rex=0x%"UVxf" offs=0x%"UVxf": \\%"UVuf": set %"IVdf" tmp; maxopenparen=%"UVuf"\n",
		PTR2UV(rex),
		PTR2UV(rex->offs),
		(UV)n,
		(IV)rex->offs[n].start_tmp,
		(UV)maxopenparen
	    ));
d4542 1
a4542 15

/* XXX really need to log other places start/end are set too */
#define CLOSE_CAPTURE \
    rex->offs[n].start = rex->offs[n].start_tmp; \
    rex->offs[n].end = locinput - PL_bostr; \
    DEBUG_BUFFERS_r(PerlIO_printf(Perl_debug_log, \
	"rex=0x%"UVxf" offs=0x%"UVxf": \\%"UVuf": set %"IVdf"..%"IVdf"\n", \
	PTR2UV(rex), \
	PTR2UV(rex->offs), \
	(UV)n, \
	(IV)rex->offs[n].start, \
	(IV)rex->offs[n].end \
    ))

	case CLOSE:  /*  )  */
d4544 7
a4550 4
	    CLOSE_CAPTURE;
	    if (n > rex->lastparen)
		rex->lastparen = n;
	    rex->lastcloseparen = n;
d4555 1
a4555 2

        case ACCEPT:  /*  (*ACCEPT)  */
d4565 8
a4572 4
			    CLOSE_CAPTURE;
                            if (n > rex->lastparen)
                                rex->lastparen = n;
                            rex->lastcloseparen = n;
d4582 1
a4582 2

	case GROUPP:  /*  (?(1))  */
d4584 1
a4584 1
	    sw = cBOOL(rex->lastparen >= n && rex->offs[n].end != -1);
d4586 1
a4586 2

	case NGROUPP:  /*  (?(<name>))  */
d4590 1
a4590 2

        case INSUBP:   /*  (?(R))  */
d4594 1
a4594 2

        case DEFINEP:  /*  (?(DEFINE))  */
d4597 1
a4597 2

	case IFTHEN:   /*  (?(cond)A|B)  */
d4607 1
a4607 2

	case LOGICAL:  /* modifier for EVAL and IFMATCH */
d4706 3
a4708 3
	       parenfloor > maxopenparen ... */
	    if (parenfloor > (I32)rex->lastparen)
		parenfloor = rex->lastparen; /* Pessimization... */
d4724 3
a4726 2
	    PUSH_YES_STATE_GOTO(CURLYX_end, PREVOPER(next), locinput);
	    assert(0); /* NOTREACHED */
d4732 1
a4732 1
	    assert(0); /* NOTREACHED */
d4738 1
a4738 1
	    assert(0); /* NOTREACHED */
d4758 1
d4768 1
a4768 2
		ST.cp = regcppush(rex, cur_curlyx->u.curlyx.parenfloor,
                                    maxopenparen);
d4772 2
a4773 2
		PUSH_STATE_GOTO(WHILEM_A_pre, A, locinput);
		assert(0); /* NOTREACHED */
d4844 1
a4844 2
		ST.cp = regcppush(rex, ST.save_curlyx->u.curlyx.parenfloor,
                            maxopenparen);
d4846 2
a4847 3
		PUSH_YES_STATE_GOTO(WHILEM_B_min, ST.save_curlyx->u.curlyx.B,
                                    locinput);
		assert(0); /* NOTREACHED */
d4853 1
a4853 2
		ST.cp = regcppush(rex, cur_curlyx->u.curlyx.parenfloor,
                            maxopenparen);
d4856 2
a4857 2
		PUSH_STATE_GOTO(WHILEM_A_max, A, locinput);
		assert(0); /* NOTREACHED */
d4861 1
a4861 1
	assert(0); /* NOTREACHED */
d4867 1
a4867 1
	    assert(0); /* NOTREACHED */
d4874 1
a4874 1
	    assert(0); /* NOTREACHED */
d4880 1
a4880 1
	    regcppop(rex, &maxopenparen);
d4884 1
a4884 1
	    assert(0); /* NOTREACHED */
d4888 2
a4889 1
	    regcppop(rex, &maxopenparen); /* Restore some previous $<digit>s? */
d4897 1
a4897 1
		&& !reginfo->warned)
d4899 1
a4899 1
                reginfo->warned	= TRUE;
d4909 2
a4910 3
	    PUSH_YES_STATE_GOTO(WHILEM_B_max, ST.save_curlyx->u.curlyx.B,
                                locinput);
	    assert(0); /* NOTREACHED */
d4915 1
a4915 1
	    regcppop(rex, &maxopenparen);
d4921 1
a4921 1
                    && !reginfo->warned)
d4923 1
a4923 1
                    reginfo->warned	= TRUE;
d4937 1
d4939 1
a4939 2
	    ST.cp = regcppush(rex, cur_curlyx->u.curlyx.parenfloor,
                            maxopenparen);
d4942 2
a4943 3
		/*A*/ NEXTOPER(ST.save_curlyx->u.curlyx.me) + EXTRA_STEP_2ARGS,
                locinput);
	    assert(0); /* NOTREACHED */
d4957 1
a4957 2
	    ST.lastparen = rex->lastparen;
	    ST.lastcloseparen = rex->lastcloseparen;
d4960 1
d4964 1
a4964 1
	        PUSH_YES_STATE_GOTO(BRANCH_next, scan, locinput);
d4966 1
a4966 1
	        PUSH_STATE_GOTO(BRANCH_next, scan, locinput);
d4968 3
a4970 3
	    assert(0); /* NOTREACHED */

        case CUTGROUP:  /*  /(*THEN)/  */
d4973 2
a4974 3
            PUSH_STATE_GOTO(CUTGROUP_next, next, locinput);
            assert(0); /* NOTREACHED */

d4981 1
a4981 2
            assert(0); /* NOTREACHED */

d4984 1
a4984 2
            assert(0); /* NOTREACHED */

d4991 4
a4994 1
            UNWIND_PAREN(ST.lastparen, ST.lastcloseparen);
d5008 1
a5008 1
	    assert(0); /* NOTREACHED */
d5010 1
a5010 1
	case MINMOD: /* next op will be non-greedy, e.g. A*?  */
a5027 3
	    ST.lastparen      = rex->lastparen;
	    ST.lastcloseparen = rex->lastcloseparen;

d5031 4
a5034 2
		if (paren > maxopenparen)
		    maxopenparen = paren;
d5050 3
a5052 2
	    PUSH_YES_STATE_GOTO(CURLYM_A, ST.A, locinput); /* match A */
	    assert(0); /* NOTREACHED */
d5055 3
d5062 2
a5063 2
		    char *s = st->locinput;
		    while (s < locinput) {
d5069 1
a5069 1
		    ST.alen = locinput - st->locinput;
d5081 2
d5103 1
d5121 13
a5133 7
		    if (PL_regkind[OP(text_node)] == EXACT) {
                        if (! S_setup_EXACTISH_ST_c1_c2(aTHX_
                           text_node, &ST.c1, ST.c1_utf8, &ST.c2, ST.c2_utf8,
                           is_utf8_pat))
                        {
                            sayNO;
                        }
d5144 14
a5157 30
	    if (! NEXTCHR_IS_EOS && ST.c1 != CHRTEST_VOID) {
                if (! UTF8_IS_INVARIANT(nextchr) && utf8_target) {
                    if (memNE(locinput, ST.c1_utf8, UTF8SKIP(locinput))
                        && memNE(locinput, ST.c2_utf8, UTF8SKIP(locinput)))
                    {
                        /* simulate B failing */
                        DEBUG_OPTIMISE_r(
                            PerlIO_printf(Perl_debug_log,
                                "%*s  CURLYM Fast bail next target=U+%"UVXf" c1=U+%"UVXf" c2=U+%"UVXf"\n",
                                (int)(REPORT_CODE_OFF+(depth*2)),"",
                                valid_utf8_to_uvchr((U8 *) locinput, NULL),
                                valid_utf8_to_uvchr(ST.c1_utf8, NULL),
                                valid_utf8_to_uvchr(ST.c2_utf8, NULL))
                        );
                        state_num = CURLYM_B_fail;
                        goto reenter_switch;
                    }
                }
                else if (nextchr != ST.c1 && nextchr != ST.c2) {
                    /* simulate B failing */
                    DEBUG_OPTIMISE_r(
                        PerlIO_printf(Perl_debug_log,
                            "%*s  CURLYM Fast bail next target=U+%X c1=U+%X c2=U+%X\n",
                            (int)(REPORT_CODE_OFF+(depth*2)),"",
                            (int) nextchr, ST.c1, ST.c2)
                    );
                    state_num = CURLYM_B_fail;
                    goto reenter_switch;
                }
            }
d5160 1
a5160 1
		/* emulate CLOSE: mark current A as captured */
d5163 4
a5166 6
		    rex->offs[paren].start
			= HOPc(locinput, -ST.alen) - PL_bostr;
		    rex->offs[paren].end = locinput - PL_bostr;
		    if ((U32)paren > rex->lastparen)
			rex->lastparen = paren;
		    rex->lastcloseparen = paren;
d5169 1
a5169 1
		    rex->offs[paren].end = -1;
d5180 2
a5181 2
	    PUSH_STATE_GOTO(CURLYM_B, ST.B, locinput); /* match B */
	    assert(0); /* NOTREACHED */
a5184 1
            UNWIND_PAREN(ST.lastparen, ST.lastcloseparen);
d5195 1
a5195 1
	    SET_locinput(HOPc(locinput, -ST.alen));
d5204 3
a5206 10
	    rex->offs[paren].start = HOPc(locinput, -1) - PL_bostr; \
	    rex->offs[paren].end = locinput - PL_bostr; \
	    if (paren > rex->lastparen) \
		rex->lastparen = paren; \
	    rex->lastcloseparen = paren; \
	} \
	else { \
	    rex->offs[paren].end = -1; \
	    rex->lastparen      = ST.lastparen; \
	    rex->lastcloseparen = ST.lastcloseparen; \
d5208 2
d5212 1
a5212 1
        case STAR:		/*  /A*B/ where A is width 1 char */
d5218 1
a5218 2

        case PLUS:		/*  /A+B/ where A is width 1 char */
d5224 6
a5229 7

	case CURLYN:		/*  /(A){m,n}B/ where A is width 1 char */
            ST.paren = scan->flags;	/* Which paren to set */
            ST.lastparen      = rex->lastparen;
	    ST.lastcloseparen = rex->lastcloseparen;
	    if (ST.paren > maxopenparen)
		maxopenparen = ST.paren;
d5239 1
a5239 2

	case CURLY:		/*  /A{m,n}B/ where A is width 1 char */
d5254 4
a5257 5
	    assert(ST.min <= ST.max);
            if (! HAS_TEXT(next) && ! JUMPABLE(next)) {
                ST.c1 = ST.c2 = CHRTEST_VOID;
            }
            else {
d5268 1
d5270 2
a5271 1
		    else {
d5279 39
a5317 7
                        if (! S_setup_EXACTISH_ST_c1_c2(aTHX_
                           text_node, &ST.c1, ST.c1_utf8, &ST.c2, ST.c2_utf8,
                           is_utf8_pat))
                        {
                            sayNO;
                        }
                    }
d5320 3
d5326 1
a5327 1
                char *li = locinput;
d5329 1
a5329 3
		if (ST.min &&
                        regrepeat(rex, &li, ST.A, ST.min, depth, is_utf8_pat)
                            < ST.min)
a5330 1
                SET_locinput(li);
d5332 1
d5350 1
a5350 1
			 m >0 && ST.maxpos < PL_regeol; m--)
d5362 2
a5363 5
                /* avoid taking address of locinput, so it can remain
                 * a register var */
                char *li = locinput;
		ST.count = regrepeat(rex, &li, ST.A, ST.max, depth,
                                        is_utf8_pat);
a5365 1
                SET_locinput(li);
d5375 1
a5375 1
		    if (UCHARAT(locinput - 1) == '\n' && OP(ST.B) != EOS)
d5381 1
a5381 1
	    assert(0); /* NOTREACHED */
d5386 2
d5389 1
a5390 3
            if (ST.paren) {
                UNWIND_PAREN(ST.lastparen, ST.lastcloseparen);
            }
d5405 1
d5407 5
a5411 4
			while (locinput <= ST.maxpos
                              && memNE(locinput, ST.c1_utf8, UTF8SKIP(locinput)))
                        {
			    locinput += UTF8SKIP(locinput);
d5417 8
a5424 5
			while (locinput <= ST.maxpos
                              && memNE(locinput, ST.c1_utf8, UTF8SKIP(locinput))
                              && memNE(locinput, ST.c2_utf8, UTF8SKIP(locinput)))
                        {
			    locinput += UTF8SKIP(locinput);
d5429 1
a5429 1
		else {  /* Not utf8_target */
d5445 1
a5446 4
                    /* In /a{m,n}b/, ST.oldloc is at "a" x m, locinput is
                     * at b; check that everything between oldloc and
                     * locinput matches */
                    char *li = ST.oldloc;
d5448 1
a5448 1
		    if (regrepeat(rex, &li, ST.A, n, depth, is_utf8_pat) < n)
a5449 1
                    assert(n == REG_INFTY || locinput == li);
d5451 1
d5457 1
a5457 1
		PUSH_STATE_GOTO(CURLY_B_min_known, ST.B, locinput);
d5459 1
a5459 1
	    assert(0); /* NOTREACHED */
d5464 2
a5467 3
            if (ST.paren) {
                UNWIND_PAREN(ST.lastparen, ST.lastcloseparen);
            }
d5469 2
a5470 8
            {
                char *li = locinput;
                if (!regrepeat(rex, &li, ST.A, 1, depth, is_utf8_pat)) {
                    sayNO;
                }
                locinput = li;
            }
            {
d5472 1
d5482 1
a5482 1
		    PUSH_STATE_GOTO(CURLY_B_min, ST.B, locinput);
d5485 2
a5486 2
            sayNO;
	    assert(0); /* NOTREACHED */
d5496 5
a5500 2
		bool could_match = locinput < PL_regeol;

d5502 1
a5502 16
                if (ST.c1 != CHRTEST_VOID && could_match) {
                    if (! UTF8_IS_INVARIANT(UCHARAT(locinput)) && utf8_target)
                    {
                        could_match = memEQ(locinput,
                                            ST.c1_utf8,
                                            UTF8SKIP(locinput))
                                    || memEQ(locinput,
                                             ST.c2_utf8,
                                             UTF8SKIP(locinput));
                    }
                    else {
                        could_match = UCHARAT(locinput) == ST.c1
                                      || UCHARAT(locinput) == ST.c2;
                    }
                }
                if (ST.c1 == CHRTEST_VOID || could_match) {
d5504 2
a5505 2
		    PUSH_STATE_GOTO(CURLY_B_max, ST.B, locinput);
		    assert(0); /* NOTREACHED */
a5508 1

d5511 2
a5514 3
            if (ST.paren) {
                UNWIND_PAREN(ST.lastparen, ST.lastcloseparen);
            }
d5518 1
a5518 1
	    locinput = HOPc(locinput, -1);
d5523 1
a5523 1
	case END: /*  last op of main pattern  */
d5527 4
a5530 2
                st->u.eval.saved_utf8_pat = is_utf8_pat;
		is_utf8_pat = cur_eval->u.eval.saved_utf8_pat;
d5533 2
a5534 6

                /* Save *all* the positions. */
		st->u.eval.cp = regcppush(rex, 0, maxopenparen);
		rex_sv = cur_eval->u.eval.prev_rex;
		SET_reg_curpm(rex_sv);
		rex = ReANY(rex_sv);
d5537 6
d5545 1
d5549 4
a5552 2
		S_regcp_restore(aTHX_ rex, cur_eval->u.eval.lastcp,
                                        &maxopenparen);
d5562 2
a5563 2
                PUSH_YES_STATE_GOTO(EVAL_AB, st->u.eval.prev_eval->u.eval.B,
                                    locinput); /* match B */
d5576 1
d5584 1
a5589 3
        {
            char *newstart;

d5592 1
a5592 1
	    newstart = locinput;
d5617 1
a5617 1
		newstart = s;
d5620 1
a5620 1
		newstart = locinput;
d5628 2
a5629 3
	    PUSH_YES_STATE_GOTO(IFMATCH_A, NEXTOPER(NEXTOPER(scan)), newstart);
	    assert(0); /* NOTREACHED */
        }
d5642 5
a5646 3
	    if (OP(ST.me) != SUSPEND) {
                /* restore old position except for (?>...) */
		locinput = st->locinput;
d5655 1
a5655 2
	case LONGJMP: /*  alternative with many branches compiles to
                       * (BRANCHJ; EXACT ...; LONGJMP ) x N */
d5660 1
a5660 2

	case COMMIT:  /*  (*COMMIT)  */
d5663 2
a5664 2

	case PRUNE:   /*  (*PRUNE)   */
d5667 2
a5668 3
	    PUSH_STATE_GOTO(COMMIT_next, next, locinput);
	    assert(0); /* NOTREACHED */

d5672 1
a5672 2

	case OPFAIL:   /* (*FAIL)  */
d5674 1
a5674 1
	    assert(0); /* NOTREACHED */
d5677 1
a5677 1
        case MARKPOINT: /*  (*MARK:foo)  */
d5682 3
a5684 4
            ST.mark_loc = locinput;
            PUSH_YES_STATE_GOTO(MARKPOINT_next, next, locinput);
            assert(0); /* NOTREACHED */

d5688 1
a5688 2
            assert(0); /* NOTREACHED */

d5708 3
a5710 3
            assert(0); /* NOTREACHED */

        case SKIP:  /*  (*SKIP)  */
d5715 1
a5715 1
                PUSH_STATE_GOTO(SKIP_next,next, locinput);
d5728 1
a5728 1
                        PUSH_STATE_GOTO( SKIP_next, next, locinput);
a5734 1

d5752 1
a5752 1
            assert(0); /* NOTREACHED */
d5754 2
a5755 3

        case LNBREAK: /* \R */
            if ((n=is_LNBREAK_safe(locinput, PL_regeol, utf8_target))) {
d5757 1
d5762 25
a5790 14

        /* this is a point to jump to in order to increment
         * locinput by one character */
        increment_locinput:
            assert(!NEXTCHR_IS_EOS);
            if (utf8_target) {
                locinput += PL_utf8skip[nextchr];
                /* locinput is allowed to go 1 char off the end, but not 2+ */
                if (locinput > PL_regeol)
                    sayNO;
            }
            else
                locinput++;
            break;
d5797 1
a5797 1
	assert(0); /* NOTREACHED */
d5837 2
a5838 1
	    locinput = pushinput;
d5841 1
a5841 1
	    assert(0); /* NOTREACHED */
d5889 1
a5889 1
        if (no_final)
d5891 2
d5900 1
a5900 1
    if (PL_reg_state.re_state_eval_setup_done) {
d5937 1
a5965 7

    if (last_pushed_cv) {
	dSP;
	POP_MULTICALL;
        PERL_UNUSED_VAR(SP);
    }

d5969 1
a5969 2
    assert(!result ||  locinput - PL_bostr >= 0);
    return result ?  locinput - PL_bostr : -1;
d5974 5
a5978 10
 *
 * What 'simple' means is a node which can be the operand of a quantifier like
 * '+', or {1,3}
 *
 * startposp - pointer a pointer to the start position.  This is updated
 *             to point to the byte following the highest successful
 *             match.
 * p         - the regnode to be repeatedly matched against.
 * max       - maximum number of things to match.
 * depth     - (for debugging) backtracking depth.
d5981 1
a5981 2
S_regrepeat(pTHX_ regexp *prog, char **startposp, const regnode *p,
                I32 max, int depth, bool is_utf8_pat)
d5984 5
a5988 6
    char *scan;     /* Pointer to current position in target string */
    I32 c;
    char *loceol = PL_regeol;   /* local version */
    I32 hardcount = 0;  /* How many matches so far */
    bool utf8_target = PL_reg_match_utf8;
    int to_complement = 0;  /* Invert the result? */
a5989 1
    _char_class_number classnum;
d5996 1
a5996 1
    scan = *startposp;
d5999 1
a5999 1
    else if (! utf8_target && loceol - scan > max)
a6000 24

    /* Here, for the case of a non-UTF-8 target we have adjusted <loceol> down
     * to the maximum of how far we should go in it (leaving it set to the real
     * end, if the maximum permissible would take us beyond that).  This allows
     * us to make the loop exit condition that we haven't gone past <loceol> to
     * also mean that we haven't exceeded the max permissible count, saving a
     * test each time through the loop.  But it assumes that the OP matches a
     * single byte, which is true for most of the OPs below when applied to a
     * non-UTF-8 target.  Those relatively few OPs that don't have this
     * characteristic will have to compensate.
     *
     * There is no adjustment for UTF-8 targets, as the number of bytes per
     * character varies.  OPs will have to test both that the count is less
     * than the max permissible (using <hardcount> to keep track), and that we
     * are still within the bounds of the string (using <loceol>.  A few OPs
     * match a single byte no matter what the encoding.  They can omit the max
     * test if, for the UTF-8 case, they do the adjustment that was skipped
     * above.
     *
     * Thus, the code above sets things up for the common case; and exceptional
     * cases need extra work; the common case is to make sure <scan> doesn't
     * go past <loceol>, and for UTF-8 to also use <hardcount> to make sure the
     * count doesn't exceed the maximum permissible */

d6004 1
d6016 1
d6025 2
a6026 9
    case CANY:  /* Move <scan> forward <max> bytes, unless goes off end */
        if (utf8_target && loceol - scan > max) {

            /* <loceol> hadn't been adjusted in the UTF-8 case */
            scan +=  max;
        }
        else {
            scan = loceol;
        }
d6029 7
a6035 1
        assert(STR_LEN(p) == is_utf8_pat ? UTF8SKIP(STRING(p)) : 1);
d6038 1
d6040 1
a6040 10
        /* Can use a simple loop if the pattern char to match on is invariant
         * under UTF-8, or both target and pattern aren't UTF-8.  Note that we
         * can use UTF8_IS_INVARIANT() even if the pattern isn't UTF-8, as it's
         * true iff it doesn't matter if the argument is in UTF-8 or not */
        if (UTF8_IS_INVARIANT(c) || (! utf8_target && ! is_utf8_pat)) {
            if (utf8_target && loceol - scan > max) {
                /* We didn't adjust <loceol> because is UTF-8, but ok to do so,
                 * since here, to match at all, 1 char == 1 byte */
                loceol = scan + max;
            }
d6045 1
a6045 16
	else if (is_utf8_pat) {
            if (utf8_target) {
                STRLEN scan_char_len;

                /* When both target and pattern are UTF-8, we have to do
                 * string EQ */
                while (hardcount < max
                       && scan < loceol
                       && (scan_char_len = UTF8SKIP(scan)) <= STR_LEN(p)
                       && memEQ(scan, STRING(p), scan_char_len))
                {
                    scan += scan_char_len;
                    hardcount++;
                }
            }
            else if (! UTF8_IS_ABOVE_LATIN1(c)) {
d6047 4
a6050 15
                /* Target isn't utf8; convert the character in the UTF-8
                 * pattern to non-UTF8, and do a simple loop */
                c = TWO_BYTE_UTF8_TO_UNI(c, *(STRING(p) + 1));
                while (scan < loceol && UCHARAT(scan) == c) {
                    scan++;
                }
            } /* else pattern char is above Latin1, can't possibly match the
                 non-UTF-8 target */
        }
        else {

            /* Here, the string must be utf8; pattern isn't, and <c> is
             * different in utf8 than not, so can't compare them directly.
             * Outside the loop, find the two utf8 bytes that represent c, and
             * then look for those in sequence in the utf8 string */
d6053 1
a6064 1

d6070 1
a6070 1
        RXp_MATCH_TAINTED_on(prog);
d6081 8
a6088 1
	utf8_flags = is_utf8_pat ? FOLDEQ_S2_ALREADY_FOLDED : 0;
d6090 10
a6099 3
    do_exactf: {
        int c1, c2;
        U8 c1_utf8[UTF8_MAXBYTES+1], c2_utf8[UTF8_MAXBYTES+1];
d6101 12
a6112 1
        assert(STR_LEN(p) == is_utf8_pat ? UTF8SKIP(STRING(p)) : 1);
d6114 17
a6130 50
        if (S_setup_EXACTISH_ST_c1_c2(aTHX_ p, &c1, c1_utf8, &c2, c2_utf8,
                                        is_utf8_pat))
        {
            if (c1 == CHRTEST_VOID) {
                /* Use full Unicode fold matching */
                char *tmpeol = PL_regeol;
                STRLEN pat_len = is_utf8_pat ? UTF8SKIP(STRING(p)) : 1;
                while (hardcount < max
                        && foldEQ_utf8_flags(scan, &tmpeol, 0, utf8_target,
                                             STRING(p), NULL, pat_len,
                                             is_utf8_pat, utf8_flags))
                {
                    scan = tmpeol;
                    tmpeol = PL_regeol;
                    hardcount++;
                }
            }
            else if (utf8_target) {
                if (c1 == c2) {
                    while (scan < loceol
                           && hardcount < max
                           && memEQ(scan, c1_utf8, UTF8SKIP(scan)))
                    {
                        scan += UTF8SKIP(scan);
                        hardcount++;
                    }
                }
                else {
                    while (scan < loceol
                           && hardcount < max
                           && (memEQ(scan, c1_utf8, UTF8SKIP(scan))
                               || memEQ(scan, c2_utf8, UTF8SKIP(scan))))
                    {
                        scan += UTF8SKIP(scan);
                        hardcount++;
                    }
                }
            }
            else if (c1 == c2) {
                while (scan < loceol && UCHARAT(scan) == c1) {
                    scan++;
                }
            }
            else {
                while (scan < loceol &&
                    (UCHARAT(scan) == c1 || UCHARAT(scan) == c2))
                {
                    scan++;
                }
            }
d6133 1
a6133 1
    }
d6135 4
a6138 2
    case ANYOF_WARN_SUPER:
	if (utf8_target) {
d6140 2
a6141 2
                   && scan < loceol
		   && reginclass(prog, p, (U8*)scan, utf8_target))
d6143 1
a6143 1
		scan += UTF8SKIP(scan);
d6151 7
a6157 12

    /* The argument (FLAGS) to all the POSIX node types is the class number */

    case NPOSIXL:
        to_complement = 1;
        /* FALLTHROUGH */

    case POSIXL:
        RXp_MATCH_TAINTED_on(prog);
	if (! utf8_target) {
	    while (scan < loceol && to_complement ^ cBOOL(isFOO_lc(FLAGS(p),
                                                                   *scan)))
d6159 6
a6164 1
		scan++;
d6166 23
d6190 13
a6202 3
	    while (hardcount < max && scan < loceol
                   && to_complement ^ cBOOL(isFOO_utf8_lc(FLAGS(p),
                                                                  (U8 *) scan)))
d6204 1
a6204 1
                scan += UTF8SKIP(scan);
d6207 4
d6213 4
a6216 16

    case POSIXD:
        if (utf8_target) {
            goto utf8_posix;
        }
        /* FALLTHROUGH */

    case POSIXA:
        if (utf8_target && loceol - scan > max) {

            /* We didn't adjust <loceol> at the beginning of this routine
             * because is UTF-8, but it is actually ok to do so, since here, to
             * match, 1 char == 1 byte. */
            loceol = scan + max;
        }
        while (scan < loceol && _generic_isCC_A((U8) *scan, FLAGS(p))) {
d6220 28
d6249 1
a6249 6
    case NPOSIXD:
        if (utf8_target) {
            to_complement = 1;
            goto utf8_posix;
        }
        /* FALL THROUGH */
d6251 13
a6263 3
    case NPOSIXA:
        if (! utf8_target) {
            while (scan < loceol && ! _generic_isCC_A((U8) *scan, FLAGS(p))) {
d6266 5
a6270 2
        }
        else {
d6272 16
a6287 8
            /* The complement of something that matches only ASCII matches all
             * UTF-8 variant code points, plus everything in ASCII that isn't
             * in the class. */
	    while (hardcount < max && scan < loceol
                   && (! UTF8_IS_INVARIANT(*scan)
                       || ! _generic_isCC_A((U8) *scan, FLAGS(p))))
            {
                scan += UTF8SKIP(scan);
d6290 9
a6298 2
        }
        break;
d6300 5
a6304 8
    case NPOSIXU:
        to_complement = 1;
        /* FALLTHROUGH */

    case POSIXU:
	if (! utf8_target) {
            while (scan < loceol && to_complement
                                ^ cBOOL(_generic_isCC((U8) *scan, FLAGS(p))))
d6306 7
d6316 88
d6405 17
a6421 96
      utf8_posix:
            classnum = (_char_class_number) FLAGS(p);
            if (classnum < _FIRST_NON_SWASH_CC) {

                /* Here, a swash is needed for above-Latin1 code points.
                 * Process as many Latin1 code points using the built-in rules.
                 * Go to another loop to finish processing upon encountering
                 * the first Latin1 code point.  We could do that in this loop
                 * as well, but the other way saves having to test if the swash
                 * has been loaded every time through the loop: extra space to
                 * save a test. */
                while (hardcount < max && scan < loceol) {
                    if (UTF8_IS_INVARIANT(*scan)) {
                        if (! (to_complement ^ cBOOL(_generic_isCC((U8) *scan,
                                                                   classnum))))
                        {
                            break;
                        }
                        scan++;
                    }
                    else if (UTF8_IS_DOWNGRADEABLE_START(*scan)) {
                        if (! (to_complement
                              ^ cBOOL(_generic_isCC(TWO_BYTE_UTF8_TO_UNI(*scan,
                                                                   *(scan + 1)),
                                                    classnum))))
                        {
                            break;
                        }
                        scan += 2;
                    }
                    else {
                        goto found_above_latin1;
                    }

                    hardcount++;
                }
            }
            else {
                /* For these character classes, the knowledge of how to handle
                 * every code point is compiled in to Perl via a macro.  This
                 * code is written for making the loops as tight as possible.
                 * It could be refactored to save space instead */
                switch (classnum) {
                    case _CC_ENUM_SPACE:    /* XXX would require separate code
                                               if we revert the change of \v
                                               matching this */
                        /* FALL THROUGH */
                    case _CC_ENUM_PSXSPC:
                        while (hardcount < max
                               && scan < loceol
                               && (to_complement ^ cBOOL(isSPACE_utf8(scan))))
                        {
                            scan += UTF8SKIP(scan);
                            hardcount++;
                        }
                        break;
                    case _CC_ENUM_BLANK:
                        while (hardcount < max
                               && scan < loceol
                               && (to_complement ^ cBOOL(isBLANK_utf8(scan))))
                        {
                            scan += UTF8SKIP(scan);
                            hardcount++;
                        }
                        break;
                    case _CC_ENUM_XDIGIT:
                        while (hardcount < max
                               && scan < loceol
                               && (to_complement ^ cBOOL(isXDIGIT_utf8(scan))))
                        {
                            scan += UTF8SKIP(scan);
                            hardcount++;
                        }
                        break;
                    case _CC_ENUM_VERTSPACE:
                        while (hardcount < max
                               && scan < loceol
                               && (to_complement ^ cBOOL(isVERTWS_utf8(scan))))
                        {
                            scan += UTF8SKIP(scan);
                            hardcount++;
                        }
                        break;
                    case _CC_ENUM_CNTRL:
                        while (hardcount < max
                               && scan < loceol
                               && (to_complement ^ cBOOL(isCNTRL_utf8(scan))))
                        {
                            scan += UTF8SKIP(scan);
                            hardcount++;
                        }
                        break;
                    default:
                        Perl_croak(aTHX_ "panic: regrepeat() node %d='%s' has an unexpected character class '%d'", OP(p), PL_reg_name[OP(p)], classnum);
                }
            }
d6423 1
a6423 25
        break;

      found_above_latin1:   /* Continuation of POSIXU and NPOSIXU */

        /* Load the swash if not already present */
        if (! PL_utf8_swash_ptrs[classnum]) {
            U8 flags = _CORE_SWASH_INIT_ACCEPT_INVLIST;
            PL_utf8_swash_ptrs[classnum] = _core_swash_init(
                                        "utf8", swash_property_names[classnum],
                                        &PL_sv_undef, 1, 0, NULL, &flags);
        }

        while (hardcount < max && scan < loceol
               && to_complement ^ cBOOL(_generic_utf8(
                                       classnum,
                                       scan,
                                       swash_fetch(PL_utf8_swash_ptrs[classnum],
                                                   (U8 *) scan,
                                                   TRUE))))
        {
            scan += UTF8SKIP(scan);
            hardcount++;
        }
        break;

d6426 2
a6427 2
	    while (hardcount < max && scan < loceol &&
                    (c=is_LNBREAK_utf8_safe(scan, loceol))) {
d6432 6
a6437 5
            /* LNBREAK can match one or two latin chars, which is ok, but we
             * have to use hardcount in this situation, and throw away the
             * adjustment to <loceol> done before the switch statement */
            loceol = PL_regeol;
	    while (scan < loceol && (c=is_LNBREAK_latin1_safe(scan, loceol))) {
d6441 26
a6466 1
	}
d6468 10
d6479 15
a6493 20
    case BOUND:
    case BOUNDA:
    case BOUNDL:
    case BOUNDU:
    case EOS:
    case GPOS:
    case KEEPS:
    case NBOUND:
    case NBOUNDA:
    case NBOUNDL:
    case NBOUNDU:
    case OPFAIL:
    case SBOL:
    case SEOL:
        /* These are all 0 width, so match right here or not at all. */
        break;

    default:
        Perl_croak(aTHX_ "panic: regrepeat() called with unrecognized node type %d='%s'", OP(p), PL_reg_name[OP(p)]);
        assert(0); /* NOTREACHED */
d6495 2
d6502 2
a6503 2
	c = scan - *startposp;
    *startposp = scan;
d6523 1
a6523 2
create a copy so that changes the caller makes won't change the shared one.
If <altsvp> is non-null, will return NULL in it, for back-compat.
d6526 1
a6526 1
Perl_regclass_swash(pTHX_ const regexp *prog, const regnode* node, bool doinit, SV** listsvp, SV **altsvp)
d6529 1
a6529 6

    if (altsvp) {
        *altsvp = NULL;
    }

    return newSVsv(core_regclass_swash(prog, node, doinit, listsvp));
d6534 1
a6534 1
S_core_regclass_swash(pTHX_ const regexp *prog, const regnode* node, bool doinit, SV** listsvp)
d6541 2
d6548 1
d6565 1
a6565 1
	    U8 swash_init_flags = _CORE_SWASH_INIT_ACCEPT_INVLIST;
d6569 2
a6570 2
	    /* Elements 2 and 3 are either both present or both absent. [2] is
	     * any inversion list generated at compile time; [3] indicates if
d6572 3
a6574 5
	    if (av_len(av) >= 2) {
		invlist = ary[2];
		if (SvUV(ary[3])) {
                    swash_init_flags |= _CORE_SWASH_INIT_USER_DEFINED_PROPERTY;
                }
d6578 1
d6593 2
d6596 1
a6596 1
				      &swash_init_flags);
d6599 7
d6611 1
d6615 8
a6622 3
	if ((! sw || (invlist = _get_swash_invlist(sw)) == NULL)
            && (si && si != &PL_sv_undef))
        {
d6624 1
a6624 1
	    /* If no swash, use the input initialization string, if available */
d6636 3
d6647 3
d6652 4
a6655 1
  Returns true if matched; false otherwise.
d6664 1
a6664 1
S_reginclass(pTHX_ regexp * const prog, const regnode * const n, const U8* const p, const bool utf8_target)
d6670 2
d6675 2
a6676 4
    /* If c is not already the code point, get it.  Note that
     * UTF8_IS_INVARIANT() works even if not in UTF-8 */
    if (! UTF8_IS_INVARIANT(c) && utf8_target) {
        STRLEN c_len = 0;
d6685 15
d6711 1
d6713 1
a6713 1
	    RXp_MATCH_TAINTED_on(prog);
d6715 1
a6715 1
	    if ((flags & ANYOF_LOC_FOLD)
d6720 34
a6753 44
	    else if (ANYOF_CLASS_TEST_ANY_SET(n)) {

                /* The data structure is arranged so bits 0, 2, 4, ... are set
                 * if the class includes the Posix character class given by
                 * bit/2; and 1, 3, 5, ... are set if the class includes the
                 * complemented Posix class given by int(bit/2).  So we loop
                 * through the bits, each time changing whether we complement
                 * the result or not.  Suppose for the sake of illustration
                 * that bits 0-3 mean respectively, \w, \W, \s, \S.  If bit 0
                 * is set, it means there is a match for this ANYOF node if the
                 * character is in the class given by the expression (0 / 2 = 0
                 * = \w).  If it is in that class, isFOO_lc() will return 1,
                 * and since 'to_complement' is 0, the result will stay TRUE,
                 * and we exit the loop.  Suppose instead that bit 0 is 0, but
                 * bit 1 is 1.  That means there is a match if the character
                 * matches \W.  We won't bother to call isFOO_lc() on bit 0,
                 * but will on bit 1.  On the second iteration 'to_complement'
                 * will be 1, so the exclusive or will reverse things, so we
                 * are testing for \W.  On the third iteration, 'to_complement'
                 * will be 0, and we would be testing for \s; the fourth
                 * iteration would test for \S, etc.
                 *
                 * Note that this code assumes that all the classes are closed
                 * under folding.  For example, if a character matches \w, then
                 * its fold does too; and vice versa.  This should be true for
                 * any well-behaved locale for all the currently defined Posix
                 * classes, except for :lower: and :upper:, which are handled
                 * by the pseudo-class :cased: which matches if either of the
                 * other two does.  To get rid of this assumption, an outer
                 * loop could be used below to iterate over both the source
                 * character, and its fold (if different) */

                int count = 0;
                int to_complement = 0;
                while (count < ANYOF_MAX) {
                    if (ANYOF_CLASS_TEST(n, count)
                        && to_complement ^ cBOOL(isFOO_lc(count/2, (U8) c)))
                    {
                        match = TRUE;
                        break;
                    }
                    count++;
                    to_complement ^= 1;
                }
d6759 1
a6759 1
     * bitmap could match, try that.  Locale nodes specify completely the
d6776 1
a6776 1
			     || OP(n) == ANYOF_SYNTHETIC))))
d6778 3
a6780 1
	    SV * const sw = core_regclass_swash(prog, n, TRUE, 0);
d6785 16
a6800 2
		} else { /* Convert to utf8 */
		    STRLEN len = 1;
d6804 1
a6804 1
		if (swash_fetch(sw, utf8_p, TRUE)) {
d6806 133
a6938 1
                }
a6943 8

        if (UNICODE_IS_SUPER(c)
            && OP(n) == ANYOF_WARN_SUPER
            && ckWARN_d(WARN_NON_UNICODE))
        {
            Perl_warner(aTHX_ packWARN(WARN_NON_UNICODE),
                "Code point 0x%04"UVXf" is not Unicode, all \\p{} matches fail; all \\P{} matches succeed", c);
        }
d6946 1
a6946 2
    /* The xor complements the return if to invert: 1^1 = 0, 1^0 = 1 */
    return cBOOL(flags & ANYOF_INVERT) ^ match;
d7046 1
a7046 1
    if (PL_reg_state.re_state_eval_setup_done) {
d7050 1
a7050 3
	    rex->suboffset = PL_reg_oldsavedoffset;
	    rex->subcoffset = PL_reg_oldsavedcoffset;
#ifdef PERL_ANY_COW
d7056 1
a7056 1
	PL_reg_state.re_state_eval_setup_done = FALSE;
d7062 1
a7062 1
S_to_utf8_substr(pTHX_ regexp *prog)
a7063 3
    /* Converts substr fields in prog from bytes to UTF-8, calling fbm_compile
     * on the converted value */

d7092 2
a7093 2
STATIC bool
S_to_byte_substr(pTHX_ regexp *prog)
a7094 3
    /* Converts substr fields in prog from UTF-8 to bytes, calling fbm_compile
     * on the converted value; returns FALSE if can't be converted. */

d7104 14
a7117 12
	    if (! sv_utf8_downgrade(sv, TRUE)) {
                return FALSE;
            }
            if (SvVALID(prog->substrs->data[i].utf8_substr)) {
                if (SvTAIL(prog->substrs->data[i].utf8_substr)) {
                    /* Trim the trailing \n that fbm_compile added last
                        time.  */
                    SvCUR_set(sv, SvCUR(sv) - 1);
                    fbm_compile(sv, FBMcf_TAIL);
                } else
                    fbm_compile(sv, 0);
            }
a7122 2

    return TRUE;
d7129 1
a7129 1
 * indent-tabs-mode: nil
d7132 1
a7132 1
 * ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.15
log
@Import perl-5.20.1
@
text
@d40 10
a95 12
#ifdef DEBUGGING
/* At least one required character in the target string is expressible only in
 * UTF-8. */
static const char* const non_utf8_target_but_utf8_required
                = "Can't match, because target string needs to be in UTF-8\n";
#endif

#define NON_UTF8_TARGET_BUT_UTF8_REQUIRED(target) STMT_START { \
    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "%s", non_utf8_target_but_utf8_required));\
    goto target; \
} STMT_END

d102 1
a102 1
/* Valid only for non-utf8 strings: avoids the reginclass
d105 1
a105 1
#define REGINCLASS(prog,p,c)  (ANYOF_FLAGS(p) ? reginclass(prog,p,c,c+1,0)   \
d113 1
a113 1
#define CHR_DIST(a,b) (reginfo->is_utf8_target ? utf8_distance(a,b) : a - b)
d116 2
a117 3
	(char *)(reginfo->is_utf8_target \
	    ? reghop3((U8*)pos, off, \
                    (U8*)(off >= 0 ? reginfo->strend : reginfo->strbeg)) \
a118 1

d120 3
a122 3
	(char*)(reginfo->is_utf8_target \
	    ? reghopmaybe3((U8*)pos, -off, (U8*)(reginfo->strbeg)) \
	    : (pos - off >= reginfo->strbeg)	\
d126 1
a126 1
#define HOP3(pos,off,lim) (reginfo->is_utf8_target  ? reghop3((U8*)(pos), off, (U8*)(lim)) : (U8*)(pos + off))
a128 18
/* lim must be +ve. Returns NULL on overshoot */
#define HOPMAYBE3(pos,off,lim) \
	(reginfo->is_utf8_target                        \
	    ? reghopmaybe3((U8*)pos, off, (U8*)(lim))   \
	    : ((U8*)pos + off <= lim)                   \
		? (U8*)pos + off                        \
		: NULL)

/* like HOP3, but limits the result to <= lim even for the non-utf8 case.
 * off must be >=0; args should be vars rather than expressions */
#define HOP3lim(pos,off,lim) (reginfo->is_utf8_target \
    ? reghop3((U8*)(pos), off, (U8*)(lim)) \
    : (U8*)((pos + off) > lim ? lim : (pos + off)))

#define HOP4(pos,off,llim, rlim) (reginfo->is_utf8_target \
    ? reghop4((U8*)(pos), off, (U8*)(llim), (U8*)(rlim)) \
    : (U8*)(pos + off))
#define HOP4c(pos,off,llim, rlim) ((char*)HOP4(pos,off,llim, rlim))
d134 1
a134 1
    nextchr = ((locinput < reginfo->strend) ? UCHARAT(locinput) : NEXTCHR_EOS)
d141 1
a141 1
#define LOAD_UTF8_CHARCLASS(swash_ptr, property_name, invlist) STMT_START {   \
d145 1
a145 1
                                         1, 0, invlist, &flags);              \
a153 1
                                          invlist,                            \
d155 1
a155 1
        LOAD_UTF8_CHARCLASS(swash_ptr, property_name, invlist);               \
a159 1
                                          invlist,                            \
d161 1
a161 1
        LOAD_UTF8_CHARCLASS(swash_ptr, property_name, invlist)
d166 2
a167 3
                                        "",                                   \
                                        PL_XPosix_ptrs[_CC_WORDCHAR],         \
                                        LATIN_CAPITAL_LETTER_SHARP_S_UTF8);
d173 1
a173 2
                                       NULL,                                  \
                                       LATIN_CAPITAL_LETTER_SHARP_S_UTF8);    \
a175 1
                                       NULL,                                  \
d192 2
a193 2
#define JUMPABLE(rn) (                                                             \
    OP(rn) == OPEN ||                                                              \
d195 5
a199 5
    OP(rn) == EVAL ||                                                              \
    OP(rn) == SUSPEND || OP(rn) == IFMATCH ||                                      \
    OP(rn) == PLUS || OP(rn) == MINMOD ||                                          \
    OP(rn) == KEEPS ||                                                             \
    (PL_regkind[OP(rn)] == CURLY && ARG1(rn) > 0)                                  \
d209 1
a209 1
#define IS_TEXTF(rn)  ( OP(rn)==EXACTFU || OP(rn)==EXACTFU_SS || OP(rn)==EXACTFA || OP(rn)==EXACTFA_NO_TRIE || OP(rn)==EXACTF || OP(rn)==REFF  || OP(rn)==NREFF )
d215 1
a215 1
#define IS_TEXTFU(rn)  ( OP(rn)==EXACTFU || OP(rn)==EXACTFU_SS || OP(rn) == EXACTFA || OP(rn) == EXACTFA_NO_TRIE)
d225 1
a225 1
#define FIND_NEXT_IMPT(rn) STMT_START {                                   \
d248 1
a248 6
#define SLAB_FIRST(s) (&(s)->states[0])
#define SLAB_LAST(s)  (&(s)->states[PERL_REGMATCH_SLAB_SLOTS-1])

static void S_setup_eval_state(pTHX_ regmatch_info *const reginfo);
static void S_cleanup_regmatch_info_aux(pTHX_ void *arg);
static regmatch_state * S_push_slab(pTHX);
d271 2
a272 2
        Perl_croak(aTHX_ "panic: paren_elems_to_push, %i < 0, maxopenparen: %i parenfloor: %i REGCP_PAREN_ELEMS: %i",
                   paren_elems_to_push, maxopenparen, parenfloor, REGCP_PAREN_ELEMS);
d293 2
a294 2
	SSPUSHIV(rex->offs[p].end);
	SSPUSHIV(rex->offs[p].start);
d366 1
a366 1
	SSize_t tmps;
d368 2
a369 2
	rex->offs[paren].start = SSPOPIV;
	tmps = SSPOPIV;
d481 1
a481 1
                        TWO_BYTE_UTF8_TO_NATIVE(*character, *(character + 1)));
d489 2
a490 5
            PL_utf8_swash_ptrs[classnum] =
                    _core_swash_init("utf8",
                                     "",
                                     &PL_sv_undef, 1, 0,
                                     PL_XPosix_ptrs[classnum], &flags);
d523 1
a523 1
	 char *strbeg, SSize_t minend, SV *screamer, U32 nosave)
d540 15
d556 2
d559 25
a583 62
/* re_intuit_start():
 *
 * Based on some optimiser hints, try to find the earliest position in the
 * string where the regex could match.
 *
 *   rx:     the regex to match against
 *   sv:     the SV being matched: only used for utf8 flag; the string
 *           itself is accessed via the pointers below. Note that on
 *           something like an overloaded SV, SvPOK(sv) may be false
 *           and the string pointers may point to something unrelated to
 *           the SV itself.
 *   strbeg: real beginning of string
 *   strpos: the point in the string at which to begin matching
 *   strend: pointer to the byte following the last char of the string
 *   flags   currently unused; set to 0
 *   data:   currently unused; set to NULL
 *
 * The basic idea of re_intuit_start() is to use some known information
 * about the pattern, namely:
 *
 *   a) the longest known anchored substring (i.e. one that's at a
 *      constant offset from the beginning of the pattern; but not
 *      necessarily at a fixed offset from the beginning of the
 *      string);
 *   b) the longest floating substring (i.e. one that's not at a constant
 *      offset from the beginning of the pattern);
 *   c) Whether the pattern is anchored to the string; either
 *      an absolute anchor: /^../, or anchored to \n: /^.../m,
 *      or anchored to pos(): /\G/;
 *   d) A start class: a real or synthetic character class which
 *      represents which characters are legal at the start of the pattern;
 *
 * to either quickly reject the match, or to find the earliest position
 * within the string at which the pattern might match, thus avoiding
 * running the full NFA engine at those earlier locations, only to
 * eventually fail and retry further along.
 *
 * Returns NULL if the pattern can't match, or returns the address within
 * the string which is the earliest place the match could occur.
 *
 * The longest of the anchored and floating substrings is called 'check'
 * and is checked first. The other is called 'other' and is checked
 * second. The 'other' substring may not be present.  For example,
 *
 *    /(abc|xyz)ABC\d{0,3}DEFG/
 *
 * will have
 *
 *   check substr (float)    = "DEFG", offset 6..9 chars
 *   other substr (anchored) = "ABC",  offset 3..3 chars
 *   stclass = [ax]
 *
 * Be aware that during the course of this function, sometimes 'anchored'
 * refers to a substring being anchored relative to the start of the
 * pattern, and sometimes to the pattern itself being anchored relative to
 * the string. For example:
 *
 *   /\dabc/:   "abc" is anchored to the pattern;
 *   /^\dabc/:  "abc" is anchored to the pattern and the string;
 *   /\d+abc/:  "abc" is anchored to neither the pattern nor the string;
 *   /^\d+abc/: "abc" is anchored to neither the pattern nor the string,
 *                    but the pattern is anchored to the string.
d586 4
d591 2
a592 8
Perl_re_intuit_start(pTHX_
                    REGEXP * const rx,
                    SV *sv,
                    const char * const strbeg,
                    char *strpos,
                    char *strend,
                    const U32 flags,
                    re_scream_pos_data *data)
d596 1
a596 1
    SSize_t start_shift = prog->check_offset_min;
d598 2
a599 3
    SSize_t end_shift   = 0;
    /* current lowest pos in string where the regex can start matching */
    char *rx_origin = strpos;
d601 2
d604 2
a605 3
    U8   other_ix = 1 - prog->substrs->check_ix;
    bool ml_anch = 0;
    char *other_last = strpos;/* latest pos 'other' substr already checked to */
d607 1
d610 4
a613 2
    regmatch_info reginfo_buf;  /* create some info to pass to find_byclass */
    regmatch_info *const reginfo = &reginfo_buf;
d620 1
a620 2
    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
                "Intuit: trying to determine minimum start position...\n"));
d622 9
a630 27
    /* for now, assume that all substr offsets are positive. If at some point
     * in the future someone wants to do clever things with look-behind and
     * -ve offsets, they'll need to fix up any code in this function
     * which uses these offsets. See the thread beginning
     * <20140113145929.GF27210@@iabyn.com>
     */
    assert(prog->substrs->data[0].min_offset >= 0);
    assert(prog->substrs->data[0].max_offset >= 0);
    assert(prog->substrs->data[1].min_offset >= 0);
    assert(prog->substrs->data[1].max_offset >= 0);
    assert(prog->substrs->data[2].min_offset >= 0);
    assert(prog->substrs->data[2].max_offset >= 0);

    /* for now, assume that if both present, that the floating substring
     * doesn't start before the anchored substring.
     * If you break this assumption (e.g. doing better optimisations
     * with lookahead/behind), then you'll need to audit the code in this
     * function carefully first
     */
    assert(
            ! (  (prog->anchored_utf8 || prog->anchored_substr)
              && (prog->float_utf8    || prog->float_substr))
           || (prog->float_min_offset >= prog->anchored_offset));

    /* byte rather than char calculation for efficiency. It fails
     * to quickly reject some cases that can't match, but will reject
     * them later after doing full char arithmetic */
d633 1
a633 1
			      "  String too short...\n"));
d637 14
a650 8
    reginfo->is_utf8_target = cBOOL(utf8_target);
    reginfo->info_aux = NULL;
    reginfo->strbeg = strbeg;
    reginfo->strend = strend;
    reginfo->is_utf8_pat = cBOOL(RX_UTF8(rx));
    reginfo->intuit = 1;
    /* not actually used within intuit, but zero for safety anyway */
    reginfo->poscache_maxiter = 0;
d652 1
d665 22
d688 1
a688 70
    /* dump the various substring data */
    DEBUG_OPTIMISE_MORE_r({
        int i;
        for (i=0; i<=2; i++) {
            SV *sv = (utf8_target ? prog->substrs->data[i].utf8_substr
                                  : prog->substrs->data[i].substr);
            if (!sv)
                continue;

            PerlIO_printf(Perl_debug_log,
                "  substrs[%d]: min=%"IVdf" max=%"IVdf" end shift=%"IVdf
                " useful=%"IVdf" utf8=%d [%s]\n",
                i,
                (IV)prog->substrs->data[i].min_offset,
                (IV)prog->substrs->data[i].max_offset,
                (IV)prog->substrs->data[i].end_shift,
                BmUSEFUL(sv),
                utf8_target ? 1 : 0,
                SvPEEK(sv));
        }
    });

    if (prog->intflags & PREGf_ANCH) { /* Match at \G, beg-of-str or after \n */

        /* ml_anch: check after \n?
         *
         * A note about IMPLICIT: on an un-anchored pattern beginning
         * with /.*.../, these flags will have been added by the
         * compiler:
         *   /.*abc/, /.*abc/m:  PREGf_IMPLICIT | PREGf_ANCH_MBOL
         *   /.*abc/s:           PREGf_IMPLICIT | PREGf_ANCH_SBOL
         */
	ml_anch =      (prog->intflags & PREGf_ANCH_MBOL)
                   && !(prog->intflags & PREGf_IMPLICIT);

	if (!ml_anch && !(prog->intflags & PREGf_IMPLICIT)) {
            /* we are only allowed to match at BOS or \G */

            /* trivially reject if there's a BOS anchor and we're not at BOS.
             *
             * Note that we don't try to do a similar quick reject for
             * \G, since generally the caller will have calculated strpos
             * based on pos() and gofs, so the string is already correctly
             * anchored by definition; and handling the exceptions would
             * be too fiddly (e.g. REXEC_IGNOREPOS).
             */
            if (   strpos != strbeg
                && (prog->intflags & (PREGf_ANCH_BOL|PREGf_ANCH_SBOL)))
            {
	        DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
                                "  Not at start...\n"));
	        goto fail;
	    }

            /* in the presence of an anchor, the anchored (relative to the
             * start of the regex) substr must also be anchored relative
             * to strpos. So quickly reject if substr isn't found there.
             * This works for \G too, because the caller will already have
             * subtracted gofs from pos, and gofs is the offset from the
             * \G to the start of the regex. For example, in /.abc\Gdef/,
             * where substr="abcdef", pos()=3, gofs=4, offset_min=1:
             * caller will have set strpos=pos()-4; we look for the substr
             * at position pos()-4+1, which lines up with the "a" */

	    if (prog->check_offset_min == prog->check_offset_max
                && !(prog->intflags & PREGf_CANY_SEEN))
            {
	        /* Substring at constant offset from beg-of-str... */
	        SSize_t slen = SvCUR(check);
                char *s = HOP3c(strpos, prog->check_offset_min, strend);
d690 2
a691 28
                DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
                    "  Looking for check substr at fixed offset %"IVdf"...\n",
                    (IV)prog->check_offset_min));

	        if (SvTAIL(check)) {
                    /* In this case, the regex is anchored at the end too.
                     * Unless it's a multiline match, the lengths must match
                     * exactly, give or take a \n.  NB: slen >= 1 since
                     * the last char of check is \n */
		    if (!multiline
                        && (   strend - s > slen
                            || strend - s < slen - 1
                            || (strend - s == slen && strend[-1] != '\n')))
                    {
                        DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
                                            "  String too long...\n"));
                        goto fail_finish;
                    }
                    /* Now should match s[0..slen-2] */
                    slen--;
                }
                if (slen && (*SvPVX_const(check) != *s
                    || (slen > 1 && memNE(SvPVX_const(check), s, slen))))
                {
                    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
                                    "  String not equal...\n"));
                    goto fail_finish;
                }
d693 35
a727 3
                check_at = s;
                goto success_at_start;
	    }
d730 8
d739 1
a739 3
    end_shift = prog->check_end_shift;

#ifdef DEBUGGING	/* 7/99: reports of failure (with the older version) */
d746 2
a748 25
    /* This is the (re)entry point of the main loop in this function.
     * The goal of this loop is to:
     * 1) find the "check" substring in the region rx_origin..strend
     *    (adjusted by start_shift / end_shift). If not found, reject
     *    immediately.
     * 2) If it exists, look for the "other" substr too if defined; for
     *    example, if the check substr maps to the anchored substr, then
     *    check the floating substr, and vice-versa. If not found, go
     *    back to (1) with rx_origin suitably incremented.
     * 3) If we find an rx_origin position that doesn't contradict
     *    either of the substrings, then check the possible additional
     *    constraints on rx_origin of /^.../m or a known start class.
     *    If these fail, then depending on which constraints fail, jump
     *    back to here, or to various other re-entry points further along
     *    that skip some of the first steps.
     * 4) If we pass all those tests, update the BmUSEFUL() count on the
     *    substring. If the start position was determined to be at the
     *    beginning of the string  - so, not rejected, but not optimised,
     *    since we have to run regmatch from position 0 - decrement the
     *    BmUSEFUL() count. Otherwise increment it.
     */


    /* first, look for the 'check' substring */

d750 2
d754 11
a764 12

        DEBUG_OPTIMISE_MORE_r({
            PerlIO_printf(Perl_debug_log,
                "  At restart: rx_origin=%"IVdf" Check offset min: %"IVdf
                " Start shift: %"IVdf" End shift %"IVdf
                " Real end Shift: %"IVdf"\n",
                (IV)(rx_origin - strpos),
                (IV)prog->check_offset_min,
                (IV)start_shift,
                (IV)end_shift,
                (IV)prog->check_end_shift);
        });
d766 3
a768 5
        if (prog->intflags & PREGf_CANY_SEEN) {
            start_point= (U8*)(rx_origin + start_shift);
            end_point= (U8*)(strend - end_shift);
            if (start_point > end_point)
                goto fail_finish;
d770 2
a771 4
            end_point = HOP3(strend, -end_shift, strbeg);
	    start_point = HOPMAYBE3(rx_origin, start_shift, end_point);
            if (!start_point)
                goto fail_finish;
a772 30


        /* If the regex is absolutely anchored to either the start of the
         * string (BOL,SBOL) or to pos() (ANCH_GPOS), then
         * check_offset_max represents an upper bound on the string where
         * the substr could start. For the ANCH_GPOS case, we assume that
         * the caller of intuit will have already set strpos to
         * pos()-gofs, so in this case strpos + offset_max will still be
         * an upper bound on the substr.
         */
        if (!ml_anch
            && prog->intflags & PREGf_ANCH
            && prog->check_offset_max != SSize_t_MAX)
        {
            SSize_t len = SvCUR(check) - !!SvTAIL(check);
            const char * const anchor =
                        (prog->intflags & PREGf_ANCH_GPOS ? strpos : strbeg);

            /* do a bytes rather than chars comparison. It's conservative;
             * so it skips doing the HOP if the result can't possibly end
             * up earlier than the old value of end_point.
             */
            if ((char*)end_point - anchor > prog->check_offset_max) {
                end_point = HOP3lim((U8*)anchor,
                                prog->check_offset_max,
                                end_point -len)
                            + len;
            }
        }

d774 1
a774 1
            PerlIO_printf(Perl_debug_log, "  fbm_instr len=%d str=<%.*s>\n",
d780 1
a780 1
	check_at = fbm_instr( start_point, end_point,
d782 3
d786 11
a796 2
        /* Update the count-of-usability, remove useless subpatterns,
            unshift s.  */
d798 15
a812 11
        DEBUG_EXECUTE_r({
            RE_PV_QUOTED_DECL(quoted, utf8_target, PERL_DEBUG_PAD_ZERO(0),
                SvPVX_const(check), RE_SV_DUMPLEN(check), 30);
            PerlIO_printf(Perl_debug_log, "  %s %s substr %s%s%s",
                              (check_at ? "Found" : "Did not find"),
                (check == (utf8_target ? prog->anchored_utf8 : prog->anchored_substr)
                    ? "anchored" : "floating"),
                quoted,
                RE_SV_TAIL(check),
                (check_at ? " at offset " : "...\n") );
        });
d814 7
a820 16
        if (!check_at)
            goto fail_finish;
        /* Finish the diagnostic message */
        DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "%ld...\n", (long)(check_at - strpos)) );

        /* set rx_origin to the minimum position where the regex could start
         * matching, given the constraint of the just-matched check substring.
         * But don't set it lower than previously.
         */

        if (check_at - rx_origin > prog->check_offset_max)
            rx_origin = HOP3c(check_at, -prog->check_offset_max, rx_origin);
    }


    /* now look for the 'other' substring if defined */
d822 2
a823 2
    if (utf8_target ? prog->substrs->data[other_ix].utf8_substr
                    : prog->substrs->data[other_ix].substr)
d826 125
a950 317
        char *last, *last1;
        char *s;
        SV* must;
        struct reg_substr_datum *other;

      do_other_substr:
        other = &prog->substrs->data[other_ix];

        /* if "other" is anchored:
         * we've previously found a floating substr starting at check_at.
         * This means that the regex origin must lie somewhere
         * between min (rx_origin): HOP3(check_at, -check_offset_max)
         * and max:                 HOP3(check_at, -check_offset_min)
         * (except that min will be >= strpos)
         * So the fixed  substr must lie somewhere between
         *  HOP3(min, anchored_offset)
         *  HOP3(max, anchored_offset) + SvCUR(substr)
         */

        /* if "other" is floating
         * Calculate last1, the absolute latest point where the
         * floating substr could start in the string, ignoring any
         * constraints from the earlier fixed match. It is calculated
         * as follows:
         *
         * strend - prog->minlen (in chars) is the absolute latest
         * position within the string where the origin of the regex
         * could appear. The latest start point for the floating
         * substr is float_min_offset(*) on from the start of the
         * regex.  last1 simply combines thee two offsets.
         *
         * (*) You might think the latest start point should be
         * float_max_offset from the regex origin, and technically
         * you'd be correct. However, consider
         *    /a\d{2,4}bcd\w/
         * Here, float min, max are 3,5 and minlen is 7.
         * This can match either
         *    /a\d\dbcd\w/
         *    /a\d\d\dbcd\w/
         *    /a\d\d\d\dbcd\w/
         * In the first case, the regex matches minlen chars; in the
         * second, minlen+1, in the third, minlen+2.
         * In the first case, the floating offset is 3 (which equals
         * float_min), in the second, 4, and in the third, 5 (which
         * equals float_max). In all cases, the floating string bcd
         * can never start more than 4 chars from the end of the
         * string, which equals minlen - float_min. As the substring
         * starts to match more than float_min from the start of the
         * regex, it makes the regex match more than minlen chars,
         * and the two cancel each other out. So we can always use
         * float_min - minlen, rather than float_max - minlen for the
         * latest position in the string.
         *
         * Note that -minlen + float_min_offset is equivalent (AFAIKT)
         * to CHR_SVLEN(must) - !!SvTAIL(must) + prog->float_end_shift
         */

        assert(prog->minlen >= other->min_offset);
        last1 = HOP3c(strend,
                        other->min_offset - prog->minlen, strbeg);

        if (other_ix) {/* i.e. if (other-is-float) */
            /* last is the latest point where the floating substr could
             * start, *given* any constraints from the earlier fixed
             * match. This constraint is that the floating string starts
             * <= float_max_offset chars from the regex origin (rx_origin).
             * If this value is less than last1, use it instead.
             */
            assert(rx_origin <= last1);
            last =
                /* this condition handles the offset==infinity case, and
                 * is a short-cut otherwise. Although it's comparing a
                 * byte offset to a char length, it does so in a safe way,
                 * since 1 char always occupies 1 or more bytes,
                 * so if a string range is  (last1 - rx_origin) bytes,
                 * it will be less than or equal to  (last1 - rx_origin)
                 * chars; meaning it errs towards doing the accurate HOP3
                 * rather than just using last1 as a short-cut */
                (last1 - rx_origin) < other->max_offset
                    ? last1
                    : (char*)HOP3lim(rx_origin, other->max_offset, last1);
        }
        else {
            assert(strpos + start_shift <= check_at);
            last = HOP4c(check_at, other->min_offset - start_shift,
                        strbeg, strend);
        }

        s = HOP3c(rx_origin, other->min_offset, strend);
        if (s < other_last)	/* These positions already checked */
            s = other_last;

        must = utf8_target ? other->utf8_substr : other->substr;
        assert(SvPOK(must));
        s = fbm_instr(
            (unsigned char*)s,
            (unsigned char*)last + SvCUR(must) - (SvTAIL(must)!=0),
            must,
            multiline ? FBMrf_MULTILINE : 0
        );
        DEBUG_EXECUTE_r({
            RE_PV_QUOTED_DECL(quoted, utf8_target, PERL_DEBUG_PAD_ZERO(0),
                SvPVX_const(must), RE_SV_DUMPLEN(must), 30);
            PerlIO_printf(Perl_debug_log, "  %s %s substr %s%s",
                s ? "Found" : "Contradicts",
                other_ix ? "floating" : "anchored",
                quoted, RE_SV_TAIL(must));
        });


        if (!s) {
            /* last1 is latest possible substr location. If we didn't
             * find it before there, we never will */
            if (last >= last1) {
                DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
                                        ", giving up...\n"));
                goto fail_finish;
            }

            /* try to find the check substr again at a later
             * position. Maybe next time we'll find the "other" substr
             * in range too */
            DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
                ", trying %s at offset %ld...\n",
                (other_ix ? "floating" : "anchored"),
                (long)(HOP3c(check_at, 1, strend) - strpos)));

            other_last = HOP3c(last, 1, strend) /* highest failure */;
            rx_origin =
                other_ix /* i.e. if other-is-float */
                    ? HOP3c(rx_origin, 1, strend)
                    : HOP4c(last, 1 - other->min_offset, strbeg, strend);
            goto restart;
        }
        else {
            DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, " at offset %ld...\n",
                  (long)(s - strpos)));

            if (other_ix) { /* if (other-is-float) */
                /* other_last is set to s, not s+1, since its possible for
                 * a floating substr to fail first time, then succeed
                 * second time at the same floating position; e.g.:
                 *     "-AB--AABZ" =~ /\wAB\d*Z/
                 * The first time round, anchored and float match at
                 * "-(AB)--AAB(Z)" then fail on the initial \w character
                 * class. Second time round, they match at "-AB--A(AB)(Z)".
                 */
                other_last = s;
            }
            else {
                rx_origin = HOP3c(s, -other->min_offset, strbeg);
                other_last = HOP3c(s, 1, strend);
            }
        }
    }
    else {
        DEBUG_OPTIMISE_MORE_r(
            PerlIO_printf(Perl_debug_log,
                "  Check-only match: offset min:%"IVdf" max:%"IVdf
                " check_at:%"IVdf" rx_origin:%"IVdf" rx_origin-check_at:%"IVdf
                " strend-strpos:%"IVdf"\n",
                (IV)prog->check_offset_min,
                (IV)prog->check_offset_max,
                (IV)(check_at-strpos),
                (IV)(rx_origin-strpos),
                (IV)(rx_origin-check_at),
                (IV)(strend-strpos)
            )
        );
    }

  postprocess_substr_matches:

    /* handle the extra constraint of /^.../m if present */

    if (ml_anch && rx_origin != strbeg && rx_origin[-1] != '\n') {
        char *s;

        DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
                        "  looking for /^/m anchor"));

        /* we have failed the constraint of a \n before rx_origin.
         * Find the next \n, if any, even if it's beyond the current
         * anchored and/or floating substrings. Whether we should be
         * scanning ahead for the next \n or the next substr is debatable.
         * On the one hand you'd expect rare substrings to appear less
         * often than \n's. On the other hand, searching for \n means
         * we're effectively flipping been check_substr and "\n" on each
         * iteration as the current "rarest" string candidate, which
         * means for example that we'll quickly reject the whole string if
         * hasn't got a \n, rather than trying every substr position
         * first
         */

        s = HOP3c(strend, - prog->minlen, strpos);
        if (s <= rx_origin ||
            ! ( rx_origin = (char *)memchr(rx_origin, '\n', s - rx_origin)))
        {
            DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
                            "  Did not find /%s^%s/m...\n",
                            PL_colors[0], PL_colors[1]));
            goto fail_finish;
        }

        /* earliest possible origin is 1 char after the \n.
         * (since *rx_origin == '\n', it's safe to ++ here rather than
         * HOP(rx_origin, 1)) */
        rx_origin++;

        if (prog->substrs->check_ix == 0  /* check is anchored */
            || rx_origin >= HOP3c(check_at,  - prog->check_offset_min, strpos))
        {
            /* Position contradicts check-string; either because
             * check was anchored (and thus has no wiggle room),
             * or check was float and rx_origin is above the float range */
            DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
                "  Found /%s^%s/m, restarting lookup for check-string at offset %ld...\n",
                PL_colors[0], PL_colors[1], (long)(rx_origin - strpos)));
            goto restart;
        }

        /* if we get here, the check substr must have been float,
         * is in range, and we may or may not have had an anchored
         * "other" substr which still contradicts */
        assert(prog->substrs->check_ix); /* check is float */

        if (utf8_target ? prog->anchored_utf8 : prog->anchored_substr) {
            /* whoops, the anchored "other" substr exists, so we still
             * contradict. On the other hand, the float "check" substr
             * didn't contradict, so just retry the anchored "other"
             * substr */
            DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
                "  Found /%s^%s/m at offset %ld, rescanning for anchored from offset %ld...\n",
                PL_colors[0], PL_colors[1],
                (long)(rx_origin - strpos),
                (long)(rx_origin - strpos + prog->anchored_offset)));
            goto do_other_substr;
        }

        /* success: we don't contradict the found floating substring
         * (and there's no anchored substr). */
        DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
            "  Found /%s^%s/m at offset %ld...\n",
            PL_colors[0], PL_colors[1], (long)(rx_origin - strpos)));
    }
    else {
        DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
            "  (multiline anchor test skipped)\n"));
    }

  success_at_start:


    /* if we have a starting character class, then test that extra constraint.
     * (trie stclasses are too expensive to use here, we are better off to
     * leave it to regmatch itself) */

    if (progi->regstclass && PL_regkind[OP(progi->regstclass)]!=TRIE) {
        const U8* const str = (U8*)STRING(progi->regstclass);

        /* XXX this value could be pre-computed */
        const int cl_l = (PL_regkind[OP(progi->regstclass)] == EXACT
		    ?  (reginfo->is_utf8_pat
                        ? utf8_distance(str + STR_LEN(progi->regstclass), str)
                        : STR_LEN(progi->regstclass))
		    : 1);
	char * endpos;
        char *s;
        /* latest pos that a matching float substr constrains rx start to */
        char *rx_max_float = NULL;

        /* if the current rx_origin is anchored, either by satisfying an
         * anchored substring constraint, or a /^.../m constraint, then we
         * can reject the current origin if the start class isn't found
         * at the current position. If we have a float-only match, then
         * rx_origin is constrained to a range; so look for the start class
         * in that range. if neither, then look for the start class in the
         * whole rest of the string */

        /* XXX DAPM it's not clear what the minlen test is for, and why
         * it's not used in the floating case. Nothing in the test suite
         * causes minlen == 0 here. See <20140313134639.GS12844@@iabyn.com>.
         * Here are some old comments, which may or may not be correct:
         *
	 *   minlen == 0 is possible if regstclass is \b or \B,
	 *   and the fixed substr is ''$.
         *   Since minlen is already taken into account, rx_origin+1 is
         *   before strend; accidentally, minlen >= 1 guaranties no false
         *   positives at rx_origin + 1 even for \b or \B.  But (minlen? 1 :
         *   0) below assumes that regstclass does not come from lookahead...
	 *   If regstclass takes bytelength more than 1: If charlength==1, OK.
         *   This leaves EXACTF-ish only, which are dealt with in
         *   find_byclass().
         */

	if (prog->anchored_substr || prog->anchored_utf8 || ml_anch)
            endpos= HOP3c(rx_origin, (prog->minlen ? cl_l : 0), strend);
        else if (prog->float_substr || prog->float_utf8) {
	    rx_max_float = HOP3c(check_at, -start_shift, strbeg);
	    endpos= HOP3c(rx_max_float, cl_l, strend);
        }
        else 
            endpos= strend;
		    
        DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
            "  looking for class: start_shift: %"IVdf" check_at: %"IVdf
            " rx_origin: %"IVdf" endpos: %"IVdf"\n",
              (IV)start_shift, (IV)(check_at - strbeg),
              (IV)(rx_origin - strbeg), (IV)(endpos - strbeg)));

        s = find_byclass(prog, progi->regstclass, rx_origin, endpos,
                            reginfo);
	if (!s) {
	    if (endpos == strend) {
		DEBUG_EXECUTE_r( PerlIO_printf(Perl_debug_log,
				"  Could not match STCLASS...\n") );
		goto fail;
a951 26
	    DEBUG_EXECUTE_r( PerlIO_printf(Perl_debug_log,
                               "  This position contradicts STCLASS...\n") );
            if ((prog->intflags & PREGf_ANCH) && !ml_anch
                        && !(prog->intflags & PREGf_IMPLICIT))
		goto fail;

	    /* Contradict one of substrings */
	    if (prog->anchored_substr || prog->anchored_utf8) {
                if (prog->substrs->check_ix == 1) { /* check is float */
                    /* Have both, check_string is floating */
                    assert(rx_origin + start_shift <= check_at);
                    if (rx_origin + start_shift != check_at) {
                        /* not at latest position float substr could match:
                         * Recheck anchored substring, but not floating.
                         * The condition above is in bytes rather than
                         * chars for efficiency. It's conservative, in
                         * that it errs on the side of doing 'goto
                         * do_other_substr', where a more accurate
                         * char-based calculation will be done */
                        DEBUG_EXECUTE_r( PerlIO_printf(Perl_debug_log,
                                  "  Looking for anchored substr starting at offset %ld...\n",
                                  (long)(other_last - strpos)) );
                        goto do_other_substr;
                    }
                }
            }
d953 8
a960 44
                /* float-only */

                if (ml_anch) {
                    /* In the presence of ml_anch, we might be able to
                     * find another \n without breaking the current float
                     * constraint. */

                    /* strictly speaking this should be HOP3c(..., 1, ...),
                     * but since we goto a block of code that's going to
                     * search for the next \n if any, its safe here */
                    rx_origin++;
                    DEBUG_EXECUTE_r( PerlIO_printf(Perl_debug_log,
                              "  Looking for /%s^%s/m starting at offset %ld...\n",
                              PL_colors[0], PL_colors[1],
                              (long)(rx_origin - strpos)) );
                    goto postprocess_substr_matches;
                }

                /* strictly speaking this can never be true; but might
                 * be if we ever allow intuit without substrings */
                if (!(utf8_target ? prog->float_utf8 : prog->float_substr))
                    goto fail;

                rx_origin = rx_max_float;
            }

            /* at this point, any matching substrings have been
             * contradicted. Start again... */

            rx_origin = HOP3c(rx_origin, 1, strend);

            /* uses bytes rather than char calculations for efficiency.
             * It's conservative: it errs on the side of doing 'goto restart',
             * where there is code that does a proper char-based test */
            if (rx_origin + start_shift + end_shift > strend) {
                DEBUG_EXECUTE_r( PerlIO_printf(Perl_debug_log,
                                       "  Could not match STCLASS...\n") );
                goto fail;
            }
            DEBUG_EXECUTE_r( PerlIO_printf(Perl_debug_log,
                "  Looking for %s substr starting at offset %ld...\n",
                (prog->substrs->check_ix ? "floating" : "anchored"),
                (long)(rx_origin + start_shift - strpos)) );
            goto restart;
a961 14

        /* Success !!! */

	if (rx_origin != s) {
            DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
			"  By STCLASS: moving %ld --> %ld\n",
                                  (long)(rx_origin - strpos), (long)(s - strpos))
                   );
        }
        else {
            DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
                                  "  Does not contradict STCLASS...\n");
                   );
        }
d964 14
a977 1
    /* Decide whether using the substrings helped */
d979 5
a983 1
    if (rx_origin != strpos) {
d986 52
a1037 2

        DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "  try at offset...\n"));
d1041 21
a1061 5
        /* The found rx_origin position does not prohibit matching at
         * strpos, so calling intuit didn't gain us anything. Decrement
         * the BmUSEFUL() count on the check substring, and if we reach
         * zero, free it.  */
	if (!(prog->intflags & PREGf_NAUGHTY)
d1073 1
a1073 1
	    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log, "  ... Disabling check substring...\n"));
d1080 5
d1089 1
d1091 2
d1095 118
a1212 5
    DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
            "Intuit: %sSuccessfully guessed:%s match at offset %ld\n",
             PL_colors[4], PL_colors[5], (long)(rx_origin - strpos)) );

    return rx_origin;
a1222 1

d1224 1
a1224 2
    const enum { trie_plain, trie_utf8, trie_utf8_fold, trie_latin_utf8_fold, \
                 trie_utf8_exactfa_fold, trie_latin_utf8_exactfa_fold } \
d1227 1
a1227 3
                              : (scan->flags == EXACTFA) \
                                ? (utf8_target ? trie_utf8_exactfa_fold : trie_latin_utf8_exactfa_fold) \
                                : (utf8_target ? trie_utf8_fold : trie_latin_utf8_fold))
d1230 1
a1230 1
STMT_START {                                                                        \
a1231 1
    U8 flags = FOLD_FLAGS_FULL;                                                     \
a1232 3
    case trie_utf8_exactfa_fold:                                                    \
        flags |= FOLD_FLAGS_NOMIX_ASCII;                                            \
        /* FALL THROUGH */                                                          \
d1235 1
a1235 1
            uvc = utf8n_to_uvchr( (const U8*) uscan, UTF8_MAXLEN, &len, uniflags ); \
d1240 1
a1240 1
            uvc = _to_utf8_fold_flags( (const U8*) uc, foldbuf, &foldlen, flags);   \
a1246 3
    case trie_latin_utf8_exactfa_fold:                                              \
        flags |= FOLD_FLAGS_NOMIX_ASCII;                                            \
        /* FALL THROUGH */                                                          \
d1249 1
a1249 1
            uvc = utf8n_to_uvchr( (const U8*) uscan, UTF8_MAXLEN, &len, uniflags ); \
d1255 1
a1255 1
            uvc = _to_fold_latin1( (U8) *uc, foldbuf, &foldlen, flags);             \
d1262 1
a1262 1
        uvc = utf8n_to_uvchr( (const U8*) uc, UTF8_MAXLEN, &len, uniflags );        \
d1287 1
a1287 1
	     && (reginfo->intuit || regtry(reginfo, &s)) )\
d1312 1
a1312 1
	if (tmp && (reginfo->intuit || regtry(reginfo, &s))) \
d1324 1
a1324 1
	if (tmp && (reginfo->intuit || regtry(reginfo, &s)))  \
d1333 2
a1334 2
#define REXEC_FBC_TRYIT                       \
if ((reginfo->intuit || regtry(reginfo, &s))) \
d1338 1
a1338 1
    if (utf8_target) {                                         \
d1345 2
a1346 3
#define DUMP_EXEC_POS(li,s,doutf8)                          \
    dump_exec_pos(li,s,(reginfo->strend),(reginfo->strbeg), \
                startpos, doutf8)
d1349 2
a1350 2
#define UTF8_NOLOAD(TEST_NON_UTF8, IF_SUCCESS, IF_FAIL)                        \
	tmp = (s != reginfo->strbeg) ? UCHARAT(s - 1) : '\n';                  \
d1353 1
a1353 1
	    if (tmp == ! TEST_NON_UTF8((U8) *s)) {                             \
d1362 2
a1363 2
#define UTF8_LOAD(TeSt1_UtF8, TeSt2_UtF8, IF_SUCCESS, IF_FAIL)                 \
	if (s == reginfo->strbeg) {                                            \
d1367 2
a1368 3
	    U8 * const r = reghop3((U8*)s, -1, (U8*)reginfo->strbeg);          \
	    tmp = utf8n_to_uvchr(r, (U8*) reginfo->strend - r,                 \
                                                       0, UTF8_ALLOW_DEFAULT); \
d1371 1
a1371 1
	LOAD_UTF8_CHARCLASS_ALNUM();                                           \
d1373 1
a1373 1
	    if (tmp == ! (TeSt2_UtF8)) {                                       \
d1408 1
a1408 1
#define FBC_BOUND_COMMON(UTF8_CODE, TEST_NON_UTF8, IF_SUCCESS, IF_FAIL)        \
d1410 1
a1410 1
		UTF8_CODE                                                      \
d1413 1
a1413 1
	tmp = (s != reginfo->strbeg) ? UCHARAT(s - 1) : '\n';                  \
d1425 1
a1425 1
    if ((!prog->minlen && tmp) && (reginfo->intuit || regtry(reginfo, &s)))    \
d1429 1
a1429 1
/* if reginfo->intuit, its a dryrun */
d1435 1
a1435 1
    const char *strend, regmatch_info *reginfo)
d1449 1
a1449 1
    const bool utf8_target = reginfo->is_utf8_target;
a1450 1
    const bool is_utf8_pat = reginfo->is_utf8_pat;
d1463 2
d1467 1
a1467 1
                      reginclass(prog, c, (U8*)s, (U8*) strend, utf8_target));
d1475 1
a1475 1
            if (tmp && (reginfo->intuit || regtry(reginfo, &s)))
a1481 3
    case EXACTFA_NO_TRIE:   /* This node only generated for non-utf8 patterns */
        assert(! is_utf8_pat);
	/* FALL THROUGH */
d1491 1
a1491 2
    case EXACTF:   /* This node only generated for non-utf8 patterns */
        assert(! is_utf8_pat);
d1493 2
d1503 2
a1504 2
        if (is_utf8_pat || utf8_target || IN_UTF8_CTYPE_LOCALE) {
            utf8_fold_flags = FOLDEQ_LOCALE;
d1517 1
d1550 1
a1550 1
        e = HOP3c(strend, -((SSize_t)ln), s);
d1552 1
a1552 1
        if (reginfo->intuit && e < s) {
d1596 1
a1596 1
        e = HOP3c(strend, -((SSize_t)lnc), s);
d1598 1
a1598 1
        if (reginfo->intuit && e < s) {
d1613 1
a1613 1
                && (reginfo->intuit || regtry(reginfo, &s)) )
d1622 1
d1624 1
a1624 1
                  isWORDCHAR_LC_uvchr(tmp),
d1628 1
d1630 1
a1630 1
                   isWORDCHAR_LC_uvchr(tmp),
d1677 1
d1741 1
a1741 2
                                _generic_isCC(TWO_BYTE_UTF8_TO_NATIVE(*s,
                                                                      *(s + 1)),
d1744 1
a1744 1
                        if (tmp && (reginfo->intuit || regtry(reginfo, &s)))
d1799 2
a1800 4
                    _core_swash_init("utf8",
                                     "",
                                     &PL_sv_undef, 1, 0,
                                     PL_XPosix_ptrs[classnum], &flags);
d2014 1
a2014 1
                    if (reginfo->intuit || regtry(reginfo, &s)) {
a2041 150
/* set RX_SAVED_COPY, RX_SUBBEG etc.
 * flags have same meanings as with regexec_flags() */

static void
S_reg_set_capture_string(pTHX_ REGEXP * const rx,
                            char *strbeg,
                            char *strend,
                            SV *sv,
                            U32 flags,
                            bool utf8_target)
{
    struct regexp *const prog = ReANY(rx);

    if (flags & REXEC_COPY_STR) {
#ifdef PERL_ANY_COW
        if (SvCANCOW(sv)) {
            if (DEBUG_C_TEST) {
                PerlIO_printf(Perl_debug_log,
                              "Copy on write: regexp capture, type %d\n",
                              (int) SvTYPE(sv));
            }
            /* Create a new COW SV to share the match string and store
             * in saved_copy, unless the current COW SV in saved_copy
             * is valid and suitable for our purpose */
            if ((   prog->saved_copy
                 && SvIsCOW(prog->saved_copy)
                 && SvPOKp(prog->saved_copy)
                 && SvIsCOW(sv)
                 && SvPOKp(sv)
                 && SvPVX(sv) == SvPVX(prog->saved_copy)))
            {
                /* just reuse saved_copy SV */
                if (RXp_MATCH_COPIED(prog)) {
                    Safefree(prog->subbeg);
                    RXp_MATCH_COPIED_off(prog);
                }
            }
            else {
                /* create new COW SV to share string */
                RX_MATCH_COPY_FREE(rx);
                prog->saved_copy = sv_setsv_cow(prog->saved_copy, sv);
            }
            prog->subbeg = (char *)SvPVX_const(prog->saved_copy);
            assert (SvPOKp(prog->saved_copy));
            prog->sublen  = strend - strbeg;
            prog->suboffset = 0;
            prog->subcoffset = 0;
        } else
#endif
        {
            SSize_t min = 0;
            SSize_t max = strend - strbeg;
            SSize_t sublen;

            if (    (flags & REXEC_COPY_SKIP_POST)
                && !(prog->extflags & RXf_PMf_KEEPCOPY) /* //p */
                && !(PL_sawampersand & SAWAMPERSAND_RIGHT)
            ) { /* don't copy $' part of string */
                U32 n = 0;
                max = -1;
                /* calculate the right-most part of the string covered
                 * by a capture. Due to look-ahead, this may be to
                 * the right of $&, so we have to scan all captures */
                while (n <= prog->lastparen) {
                    if (prog->offs[n].end > max)
                        max = prog->offs[n].end;
                    n++;
                }
                if (max == -1)
                    max = (PL_sawampersand & SAWAMPERSAND_LEFT)
                            ? prog->offs[0].start
                            : 0;
                assert(max >= 0 && max <= strend - strbeg);
            }

            if (    (flags & REXEC_COPY_SKIP_PRE)
                && !(prog->extflags & RXf_PMf_KEEPCOPY) /* //p */
                && !(PL_sawampersand & SAWAMPERSAND_LEFT)
            ) { /* don't copy $` part of string */
                U32 n = 0;
                min = max;
                /* calculate the left-most part of the string covered
                 * by a capture. Due to look-behind, this may be to
                 * the left of $&, so we have to scan all captures */
                while (min && n <= prog->lastparen) {
                    if (   prog->offs[n].start != -1
                        && prog->offs[n].start < min)
                    {
                        min = prog->offs[n].start;
                    }
                    n++;
                }
                if ((PL_sawampersand & SAWAMPERSAND_RIGHT)
                    && min >  prog->offs[0].end
                )
                    min = prog->offs[0].end;

            }

            assert(min >= 0 && min <= max && min <= strend - strbeg);
            sublen = max - min;

            if (RX_MATCH_COPIED(rx)) {
                if (sublen > prog->sublen)
                    prog->subbeg =
                            (char*)saferealloc(prog->subbeg, sublen+1);
            }
            else
                prog->subbeg = (char*)safemalloc(sublen+1);
            Copy(strbeg + min, prog->subbeg, sublen, char);
            prog->subbeg[sublen] = '\0';
            prog->suboffset = min;
            prog->sublen = sublen;
            RX_MATCH_COPIED_on(rx);
        }
        prog->subcoffset = prog->suboffset;
        if (prog->suboffset && utf8_target) {
            /* Convert byte offset to chars.
             * XXX ideally should only compute this if @@-/@@+
             * has been seen, a la PL_sawampersand ??? */

            /* If there's a direct correspondence between the
             * string which we're matching and the original SV,
             * then we can use the utf8 len cache associated with
             * the SV. In particular, it means that under //g,
             * sv_pos_b2u() will use the previously cached
             * position to speed up working out the new length of
             * subcoffset, rather than counting from the start of
             * the string each time. This stops
             *   $x = "\x{100}" x 1E6; 1 while $x =~ /(.)/g;
             * from going quadratic */
            if (SvPOKp(sv) && SvPVX(sv) == strbeg)
                prog->subcoffset = sv_pos_b2u_flags(sv, prog->subcoffset,
                                                SV_GMAGIC|SV_CONST_RETURN);
            else
                prog->subcoffset = utf8_length((U8*)strbeg,
                                    (U8*)(strbeg+prog->suboffset));
        }
    }
    else {
        RX_MATCH_COPY_FREE(rx);
        prog->subbeg = strbeg;
        prog->suboffset = 0;
        prog->subcoffset = 0;
        prog->sublen = strend - strbeg;
    }
}



d2048 1
a2048 1
	      char *strbeg, SSize_t minend, SV *sv, void *data, U32 flags)
d2056 3
a2058 2
              Currently unused. */
/* flags:     For optimizations. See REXEC_* in regexp.h */
d2065 6
a2070 3
    char *startpos;
    SSize_t minlen;		/* must match at least this many chars */
    SSize_t dontbother = 0;	/* how many characters not to try at end */
d2074 1
a2074 2
    regmatch_info reginfo_buf;  /* create some info to pass to regtry etc */
    regmatch_info *const reginfo = &reginfo_buf;
a2075 1
    I32 oldsave;
d2078 2
a2079 77
    PERL_ARGS_ASSERT_REGEXEC_FLAGS;
    PERL_UNUSED_ARG(data);

    /* Be paranoid... */
    if (prog == NULL || stringarg == NULL) {
	Perl_croak(aTHX_ "NULL regexp parameter");
	return 0;
    }

    DEBUG_EXECUTE_r(
        debug_start_match(rx, utf8_target, stringarg, strend,
        "Matching");
    );

    startpos = stringarg;

    if (prog->intflags & PREGf_GPOS_SEEN) {
        MAGIC *mg;

        /* set reginfo->ganch, the position where \G can match */

        reginfo->ganch =
            (flags & REXEC_IGNOREPOS)
            ? stringarg /* use start pos rather than pos() */
            : (sv && (mg = mg_find_mglob(sv)) && mg->mg_len >= 0)
              /* Defined pos(): */
            ? strbeg + MgBYTEPOS(mg, sv, strbeg, strend-strbeg)
            : strbeg; /* pos() not defined; use start of string */

        DEBUG_GPOS_r(PerlIO_printf(Perl_debug_log,
            "GPOS ganch set to strbeg[%"IVdf"]\n", (IV)(reginfo->ganch - strbeg)));

        /* in the presence of \G, we may need to start looking earlier in
         * the string than the suggested start point of stringarg:
         * if prog->gofs is set, then that's a known, fixed minimum
         * offset, such as
         * /..\G/:   gofs = 2
         * /ab|c\G/: gofs = 1
         * or if the minimum offset isn't known, then we have to go back
         * to the start of the string, e.g. /w+\G/
         */

        if (prog->intflags & PREGf_ANCH_GPOS) {
            startpos  = reginfo->ganch - prog->gofs;
            if (startpos <
                ((flags & REXEC_FAIL_ON_UNDERFLOW) ? stringarg : strbeg))
            {
                DEBUG_r(PerlIO_printf(Perl_debug_log,
                        "fail: ganch-gofs before earliest possible start\n"));
                return 0;
            }
        }
        else if (prog->gofs) {
            if (startpos - prog->gofs < strbeg)
                startpos = strbeg;
            else
                startpos -= prog->gofs;
        }
        else if (prog->intflags & PREGf_GPOS_FLOAT)
            startpos = strbeg;
    }

    minlen = prog->minlen;
    if ((startpos + minlen) > strend || startpos < strbeg) {
        DEBUG_r(PerlIO_printf(Perl_debug_log,
                    "Regex match can't succeed, so not even tried\n"));
        return 0;
    }

    /* at the end of this function, we'll do a LEAVE_SCOPE(oldsave),
     * which will call destuctors to reset PL_regmatch_state, free higher
     * PL_regmatch_slabs, and clean up regmatch_info_aux and
     * regmatch_info_aux_eval */

    oldsave = PL_savestack_ix;

    s = startpos;
d2081 4
a2084 41
    if ((prog->extflags & RXf_USE_INTUIT)
        && !(flags & REXEC_CHECKED))
    {
	s = re_intuit_start(rx, sv, strbeg, startpos, strend,
                                    flags, NULL);
	if (!s)
	    return 0;

	if (prog->extflags & RXf_CHECK_ALL) {
            /* we can match based purely on the result of INTUIT.
             * Set up captures etc just for $& and $-[0]
             * (an intuit-only match wont have $1,$2,..) */
            assert(!prog->nparens);

            /* s/// doesn't like it if $& is earlier than where we asked it to
             * start searching (which can happen on something like /.\G/) */
            if (       (flags & REXEC_FAIL_ON_UNDERFLOW)
                    && (s < stringarg))
            {
                /* this should only be possible under \G */
                assert(prog->intflags & PREGf_GPOS_SEEN);
                DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
                    "matched, but failing for REXEC_FAIL_ON_UNDERFLOW\n"));
                goto phooey;
            }

            /* match via INTUIT shouldn't have any captures.
             * Let @@-, @@+, $^N know */
            prog->lastparen = prog->lastcloseparen = 0;
            RX_MATCH_UTF8_set(rx, utf8_target);
            prog->offs[0].start = s - strbeg;
            prog->offs[0].end = utf8_target
                ? (char*)utf8_hop((U8*)s, prog->minlenret) - strbeg
                : s - strbeg + prog->minlenret;
            if ( !(flags & REXEC_NOT_FIRST) )
                S_reg_set_capture_string(aTHX_ rx,
                                        strbeg, strend,
                                        sv, flags, utf8_target);

	    return 1;
        }
d2088 9
d2098 1
a2098 1
    if (strend - s < (minlen+(prog->check_offset_min<0?prog->check_offset_min:0))) {
d2103 1
d2111 2
d2114 6
a2119 11
    reginfo->prog = rx;	 /* Yes, sorry that this is confusing.  */
    reginfo->intuit = 0;
    reginfo->is_utf8_target = cBOOL(utf8_target);
    reginfo->is_utf8_pat = cBOOL(RX_UTF8(rx));
    reginfo->warned = FALSE;
    reginfo->strbeg  = strbeg;
    reginfo->sv = sv;
    reginfo->poscache_maxiter = 0; /* not yet started a countdown */
    reginfo->strend = strend;
    /* see how far we have to get to not match where we matched before */
    reginfo->till = stringarg + minend;
d2121 2
a2122 12
    if (prog->extflags & RXf_EVAL_SEEN && SvPADTMP(sv)) {
        /* SAVEFREESV, not sv_mortalcopy, as this SV must last until after
           S_cleanup_regmatch_info_aux has executed (registered by
           SAVEDESTRUCTOR_X below).  S_cleanup_regmatch_info_aux modifies
           magic belonging to this SV.
           Not newSVsv, either, as it does not COW.
        */
        assert(!IS_PADGV(sv));
        reginfo->sv = newSV(0);
        SvSetSV_nosteal(reginfo->sv, sv);
        SAVEFREESV(reginfo->sv);
    }
d2124 2
a2125 6
    /* reserve next 2 or 3 slots in PL_regmatch_state:
     * slot N+0: may currently be in use: skip it
     * slot N+1: use for regmatch_info_aux struct
     * slot N+2: use for regmatch_info_aux_eval struct if we have (?{})'s
     * slot N+3: ready for use by regmatch()
     */
d2127 2
a2128 4
    {
        regmatch_state *old_regmatch_state;
        regmatch_slab  *old_regmatch_slab;
        int i, max = (prog->extflags & RXf_EVAL_SEEN) ? 2 : 1;
d2130 34
a2163 36
        /* on first ever match, allocate first slab */
        if (!PL_regmatch_slab) {
            Newx(PL_regmatch_slab, 1, regmatch_slab);
            PL_regmatch_slab->prev = NULL;
            PL_regmatch_slab->next = NULL;
            PL_regmatch_state = SLAB_FIRST(PL_regmatch_slab);
        }

        old_regmatch_state = PL_regmatch_state;
        old_regmatch_slab  = PL_regmatch_slab;

        for (i=0; i <= max; i++) {
            if (i == 1)
                reginfo->info_aux = &(PL_regmatch_state->u.info_aux);
            else if (i ==2)
                reginfo->info_aux_eval =
                reginfo->info_aux->info_aux_eval =
                            &(PL_regmatch_state->u.info_aux_eval);

            if (++PL_regmatch_state >  SLAB_LAST(PL_regmatch_slab))
                PL_regmatch_state = S_push_slab(aTHX);
        }

        /* note initial PL_regmatch_state position; at end of match we'll
         * pop back to there and free any higher slabs */

        reginfo->info_aux->old_regmatch_state = old_regmatch_state;
        reginfo->info_aux->old_regmatch_slab  = old_regmatch_slab;
        reginfo->info_aux->poscache = NULL;

        SAVEDESTRUCTOR_X(S_cleanup_regmatch_info_aux, reginfo->info_aux);

        if ((prog->extflags & RXf_EVAL_SEEN))
            S_setup_eval_state(aTHX_ reginfo);
        else
            reginfo->info_aux_eval = reginfo->info_aux->info_aux_eval = NULL;
a2164 3

    /* If there is a "must appear" string, look for it. */

d2183 13
d2199 2
a2200 2
    if (prog->intflags & (PREGf_ANCH & ~PREGf_ANCH_GPOS)) {
	if (s == startpos && regtry(reginfo, &s))
d2202 2
a2203 1
        else if (multiline || (prog->intflags & (PREGf_IMPLICIT | PREGf_ANCH_MBOL))) /* XXXX SBOL? */
d2218 1
a2218 1
                        if (regtry(reginfo, &s)) {
d2226 1
a2226 2
                            s = re_intuit_start(rx, sv, strbeg,
                                    s + UTF8SKIP(s), strend, flags, NULL);
d2241 1
a2241 1
                        if (regtry(reginfo, &s)) {
d2249 1
a2249 2
                            s = re_intuit_start(rx, sv, strbeg,
                                        s + 1, strend, flags, NULL);
d2268 1
a2268 1
			if (regtry(reginfo, &s))
d2275 1
a2275 1
    } else if (prog->intflags & PREGf_ANCH_GPOS)
d2277 6
a2282 7
        /* PREGf_ANCH_GPOS should never be true if PREGf_GPOS_SEEN is not true */
        assert(prog->intflags & PREGf_GPOS_SEEN);
        /* For anchored \G, the only position it can match from is
         * (ganch-gofs); we already set startpos to this above; if intuit
         * moved us on from there, we can't possibly succeed */
        assert(startpos == reginfo->ganch - prog->gofs);
	if (s == startpos && regtry(reginfo, &s))
d2303 1
a2303 1
		    if (regtry(reginfo, &s)) goto got_it;
d2321 1
a2321 1
		    if (regtry(reginfo, &s)) goto got_it;
d2338 2
a2339 2
	SSize_t back_max;
	SSize_t back_min;
d2384 1
a2384 1
        	  -(SSize_t)(CHR_SVLEN(must)
d2387 1
a2387 1
	if (s > reginfo->strbeg)
d2394 2
a2395 1
	dontbother = 0;
d2398 1
a2398 1
		(s = fbm_instr((unsigned char*)HOP4c(s, back_min, strbeg,  strend),
d2407 1
a2407 2
		char * const t = (last1 >= reginfo->strbeg)
                                    ? HOPc(last1, 1) : last1 + 1;
d2414 1
a2414 1
		    if (regtry(reginfo, &s))
d2425 1
a2425 1
		    if (regtry(reginfo, &s))
d2450 1
a2450 1
            regprop(prog, prop, c, reginfo);
d2460 1
a2460 1
        if (find_byclass(prog, c, s, strend, reginfo))
d2568 1
a2568 1
		if (regtry(reginfo, &s))
d2577 1
a2577 1
		if (regtry(reginfo, &s))
a2586 12
    /* s/// doesn't like it if $& is earlier than where we asked it to
     * start searching (which can happen on something like /.\G/) */
    if (       (flags & REXEC_FAIL_ON_UNDERFLOW)
            && (prog->offs[0].start < stringarg - strbeg))
    {
        /* this should only be possible under \G */
        assert(prog->intflags & PREGf_GPOS_SEEN);
        DEBUG_EXECUTE_r(PerlIO_printf(Perl_debug_log,
            "matched, but failing for REXEC_FAIL_ON_UNDERFLOW\n"));
        goto phooey;
    }

d2597 4
a2600 3
    /* clean up; this will trigger destructors that will free all slabs
     * above the current one, and cleanup the regmatch_info_aux
     * and regmatch_info_aux_eval sructs */
d2602 66
a2667 1
    LEAVE_SCOPE(oldsave);
d2669 1
a2669 2
    if (RXp_PAREN_NAMES(prog)) 
        (void)hv_iterinit(RXp_PAREN_NAMES(prog));
d2671 2
a2672 1
    RX_MATCH_UTF8_set(rx, utf8_target);
d2674 44
a2717 5
    /* make sure $`, $&, $', and $digit will work later */
    if ( !(flags & REXEC_NOT_FIRST) )
        S_reg_set_capture_string(aTHX_ rx,
                                    strbeg, reginfo->strend,
                                    sv, flags, utf8_target);
d2724 2
a2725 7

    /* clean up; this will trigger destructors that will free all slabs
     * above the current one, and cleanup the regmatch_info_aux
     * and regmatch_info_aux_eval sructs */

    LEAVE_SCOPE(oldsave);

d2741 1
a2741 1
/* Set which rex is pointed to by PL_reg_curpm, handling ref counting.
d2743 2
a2744 2
#define SET_reg_curpm(Re2)                          \
    if (reginfo->info_aux_eval) {                   \
d2761 1
a2761 1
    SSize_t result;
d2769 68
a2836 1
    prog->offs[0].start = *startposp - reginfo->strbeg;
d2885 1
a2885 1
       reginfo->info_aux->poscache[ST.cache_offset] |= ST.cache_mask; \
d2900 3
d3078 1
a3078 1
	DUMP_EXEC_POS(locinput, scan, utf8_target);         \
d3082 1
a3082 1
	    PL_reg_name[st->resume_state],                  \
d3218 17
d3237 1
a3237 1
        U8* c1_utf8, int *c2p, U8* c2_utf8, regmatch_info *reginfo)
d3289 1
a3289 1
    const bool utf8_target = reginfo->is_utf8_target;
a3293 1
    const bool is_utf8_pat = reginfo->is_utf8_pat;
a3301 1
    U8 folded[UTF8_MAX_FOLD_CHAR_EXPAND * UTF8_MAXBYTES_CASE + 1] = { '\0' };
d3321 47
a3367 2
    else { /* an EXACTFish node */
        U8 *pat_end = pat + STR_LEN(text_node);
d3369 3
a3371 19
        /* An EXACTFL node has at least some characters unfolded, because what
         * they match is not known until now.  So, now is the time to fold
         * the first few of them, as many as are needed to determine 'c1' and
         * 'c2' later in the routine.  If the pattern isn't UTF-8, we only need
         * to fold if in a UTF-8 locale, and then only the Sharp S; everything
         * else is 1-1 and isn't assumed to be folded.  In a UTF-8 pattern, we
         * need to fold as many characters as a single character can fold to,
         * so that later we can check if the first ones are such a multi-char
         * fold.  But, in such a pattern only locale-problematic characters
         * aren't folded, so we can skip this completely if the first character
         * in the node isn't one of the tricky ones */
        if (OP(text_node) == EXACTFL) {

            if (! is_utf8_pat) {
                if (IN_UTF8_CTYPE_LOCALE && *pat == LATIN_SMALL_LETTER_SHARP_S)
                {
                    folded[0] = folded[1] = 's';
                    pat = folded;
                    pat_end = folded + 2;
d3373 31
a3403 19
            }
            else if (is_PROBLEMATIC_LOCALE_FOLDEDS_START_utf8(pat)) {
                U8 *s = pat;
                U8 *d = folded;
                int i;

                for (i = 0; i < UTF8_MAX_FOLD_CHAR_EXPAND && s < pat_end; i++) {
                    if (isASCII(*s)) {
                        *(d++) = (U8) toFOLD_LC(*s);
                        s++;
                    }
                    else {
                        STRLEN len;
                        _to_utf8_fold_flags(s,
                                            d,
                                            &len,
                                            FOLD_FLAGS_FULL | FOLD_FLAGS_LOCALE);
                        d += len;
                        s += UTF8SKIP(s);
a3405 3

                pat = folded;
                pat_end = d;
d3408 5
a3412 3

        if ((is_utf8_pat && is_MULTI_CHAR_FOLD_utf8_safe(pat, pat_end))
             || (!is_utf8_pat && is_MULTI_CHAR_FOLD_latin1_safe(pat, pat_end)))
d3414 7
a3420 81
            /* Multi-character folds require more context to sort out.  Also
             * PL_utf8_foldclosures used below doesn't handle them, so have to
             * be handled outside this routine */
            use_chrtest_void = TRUE;
        }
        else { /* an EXACTFish node which doesn't begin with a multi-char fold */
            c1 = is_utf8_pat ? valid_utf8_to_uvchr(pat, NULL) : *pat;
            if (c1 > 256) {
                /* Load the folds hash, if not already done */
                SV** listp;
                if (! PL_utf8_foldclosures) {
                    if (! PL_utf8_tofold) {
                        U8 dummy[UTF8_MAXBYTES_CASE+1];

                        /* Force loading this by folding an above-Latin1 char */
                        to_utf8_fold((U8*) HYPHEN_UTF8, dummy, NULL);
                        assert(PL_utf8_tofold); /* Verify that worked */
                    }
                    PL_utf8_foldclosures = _swash_inversion_hash(PL_utf8_tofold);
                }

                /* The fold closures data structure is a hash with the keys
                 * being the UTF-8 of every character that is folded to, like
                 * 'k', and the values each an array of all code points that
                 * fold to its key.  e.g. [ 'k', 'K', KELVIN_SIGN ].
                 * Multi-character folds are not included */
                if ((! (listp = hv_fetch(PL_utf8_foldclosures,
                                        (char *) pat,
                                        UTF8SKIP(pat),
                                        FALSE))))
                {
                    /* Not found in the hash, therefore there are no folds
                    * containing it, so there is only a single character that
                    * could match */
                    c2 = c1;
                }
                else {  /* Does participate in folds */
                    AV* list = (AV*) *listp;
                    if (av_tindex(list) != 1) {

                        /* If there aren't exactly two folds to this, it is
                         * outside the scope of this function */
                        use_chrtest_void = TRUE;
                    }
                    else {  /* There are two.  Get them */
                        SV** c_p = av_fetch(list, 0, FALSE);
                        if (c_p == NULL) {
                            Perl_croak(aTHX_ "panic: invalid PL_utf8_foldclosures structure");
                        }
                        c1 = SvUV(*c_p);

                        c_p = av_fetch(list, 1, FALSE);
                        if (c_p == NULL) {
                            Perl_croak(aTHX_ "panic: invalid PL_utf8_foldclosures structure");
                        }
                        c2 = SvUV(*c_p);

                        /* Folds that cross the 255/256 boundary are forbidden
                         * if EXACTFL (and isnt a UTF8 locale), or EXACTFA and
                         * one is ASCIII.  Since the pattern character is above
                         * 256, and its only other match is below 256, the only
                         * legal match will be to itself.  We have thrown away
                         * the original, so have to compute which is the one
                         * above 255 */
                        if ((c1 < 256) != (c2 < 256)) {
                            if ((OP(text_node) == EXACTFL
                                 && ! IN_UTF8_CTYPE_LOCALE)
                                || ((OP(text_node) == EXACTFA
                                    || OP(text_node) == EXACTFA_NO_TRIE)
                                    && (isASCII(c1) || isASCII(c2))))
                            {
                                if (c1 < 256) {
                                    c1 = c2;
                                }
                                else {
                                    c2 = c1;
                                }
                            }
                        }
                    }
                }
d3422 2
a3423 19
            else /* Here, c1 is < 255 */
                if (utf8_target
                    && HAS_NONLATIN1_FOLD_CLOSURE(c1)
                    && ( ! (OP(text_node) == EXACTFL && ! IN_UTF8_CTYPE_LOCALE))
                    && ((OP(text_node) != EXACTFA
                        && OP(text_node) != EXACTFA_NO_TRIE)
                        || ! isASCII(c1)))
            {
                /* Here, there could be something above Latin1 in the target
                 * which folds to this character in the pattern.  All such
                 * cases except LATIN SMALL LETTER Y WITH DIAERESIS have more
                 * than two characters involved in their folds, so are outside
                 * the scope of this function */
                if (UNLIKELY(c1 == LATIN_SMALL_LETTER_Y_WITH_DIAERESIS)) {
                    c2 = LATIN_CAPITAL_LETTER_Y_WITH_DIAERESIS;
                }
                else {
                    use_chrtest_void = TRUE;
                }
d3425 3
a3427 3
            else { /* Here nothing above Latin1 can fold to the pattern
                      character */
                switch (OP(text_node)) {
d3429 3
a3431 3
                    case EXACTFL:   /* /l rules */
                        c2 = PL_fold_locale[c1];
                        break;
d3433 3
a3435 18
                    case EXACTF:   /* This node only generated for non-utf8
                                    patterns */
                        assert(! is_utf8_pat);
                        if (! utf8_target) {    /* /d rules */
                            c2 = PL_fold[c1];
                            break;
                        }
                        /* FALLTHROUGH */
                        /* /u rules for all these.  This happens to work for
                        * EXACTFA as nothing in Latin1 folds to ASCII */
                    case EXACTFA_NO_TRIE:   /* This node only generated for
                                            non-utf8 patterns */
                        assert(! is_utf8_pat);
                        /* FALL THROUGH */
                    case EXACTFA:
                    case EXACTFU_SS:
                    case EXACTFU:
                        c2 = PL_fold_latin1[c1];
d3437 10
d3448 3
a3450 4
                    default:
                        Perl_croak(aTHX_ "panic: Unexpected op %u", OP(text_node));
                        assert(0); /* NOTREACHED */
                }
d3492 1
a3492 1
STATIC SSize_t
d3499 1
a3499 1
    const bool utf8_target = reginfo->is_utf8_target;
d3504 1
d3511 1
a3511 1
    SSize_t ln = 0; /* len or last;  init to avoid compiler warning */
d3539 1
a3539 1
    SV* const oreplsv = GvSVn(PL_replgv);
a3568 3
    /* protect against undef(*^R) */
    SAVEFREESV(SvREFCNT_inc_simple_NN(oreplsv));

d3582 7
d3590 9
a3598 1
    st = PL_regmatch_state;
d3609 1
a3609 1
            regprop(rex, prop, scan, reginfo);
d3631 4
a3634 3
	case BOL:  /*  /^../   */
	case SBOL: /*  /^../s  */
	    if (locinput == reginfo->strbeg)
d3636 1
d3640 1
a3640 1
	    if (locinput == reginfo->strbeg ||
d3647 5
d3660 1
a3660 1
	    rex->offs[0].start = locinput - reginfo->strbeg;
d3669 3
a3676 2
	case EOL: /* /..$/  */
            /* FALL THROUGH */
d3678 1
d3681 1
a3681 1
	    if (reginfo->strend - locinput > 1)
d3819 1
a3819 1
		while ( state && uc <= (U8*)(reginfo->strend) ) {
d3853 1
a3853 1
		    if ( base && (foldlen || uc < (U8*)(reginfo->strend))) {
d3976 1
a3976 1
			    uvc = utf8n_to_uvchr((U8*)uc, UTF8_MAXLEN, &len,
d3989 1
a3989 1
			    uvc = utf8n_to_uvchr(uscan, UTF8_MAXLEN, &len,
d4068 1
a4068 3
			if (l >= reginfo->strend
                            || UTF8_IS_ABOVE_LATIN1(* (U8*) l))
                        {
d4078 1
a4078 2
                            if (TWO_BYTE_UTF8_TO_NATIVE(*l, *(l+1)) != * (U8*) s)
                            {
d4089 1
a4089 2
                        if (l >= reginfo->strend
                            || UTF8_IS_ABOVE_LATIN1(* (U8*) s))
d4100 1
a4100 2
                            if (TWO_BYTE_UTF8_TO_NATIVE(*s, *(s+1)) != * (U8*) l)
                            {
d4113 1
a4113 1
                if (reginfo->strend - locinput < ln
d4130 1
d4133 1
a4133 1
	    fold_utf8_flags = FOLDEQ_LOCALE;
d4137 1
a4143 4
        case EXACTFA_NO_TRIE:   /* This node only generated for non-utf8
                                   patterns */
            assert(! is_utf8_pat);
            /* FALL THROUGH */
d4150 1
a4150 3
        case EXACTF:             /*  /abc/i    This node only generated for
                                               non-utf8 patterns */
            assert(! is_utf8_pat);
d4159 1
a4159 5
	    if (utf8_target
                || is_utf8_pat
                || state_num == EXACTFU_SS
                || (state_num == EXACTFL && IN_UTF8_CTYPE_LOCALE))
            {
d4163 1
a4163 1
		char *e = reginfo->strend;
d4181 1
a4181 1
	    if (reginfo->strend - locinput < ln)
d4194 2
d4207 1
a4207 1
		if (locinput == reginfo->strbeg)
d4210 1
a4210 2
		    const U8 * const r =
                            reghop3((U8*)locinput, -1, (U8*)(reginfo->strbeg));
d4212 1
a4212 2
		    ln = utf8n_to_uvchr(r, (U8*) reginfo->strend - r,
                                                                   0, uniflags);
d4225 1
a4225 1
		    ln = isWORDCHAR_LC_uvchr(ln);
d4242 1
a4242 1
		ln = (locinput != reginfo->strbeg) ?
d4274 1
d4278 1
a4278 2
	        if (!reginclass(rex, scan, (U8*)locinput, (U8*)reginfo->strend,
                                                                   utf8_target))
d4300 4
d4314 1
a4314 1
                                           (U8) TWO_BYTE_UTF8_TO_NATIVE(nextchr,
d4395 1
a4395 1
                       ^ cBOOL(_generic_isCC(TWO_BYTE_UTF8_TO_NATIVE(nextchr,
d4397 1
a4397 1
                                             FLAGS(scan)))))
d4413 2
a4414 3
                                        "",
                                        &PL_sv_undef, 1, 0,
                                        PL_XPosix_ptrs[classnum], &flags);
d4511 1
a4511 1
		    && locinput < reginfo->strend
d4520 2
a4521 2
		 * reginfo->strend, so locinput+1 is in bounds */
		if ( nextchr == '\r' && locinput+1 < reginfo->strend
d4538 1
a4538 1
                    while (locinput < reginfo->strend
d4549 1
a4549 1
			&& (locinput >=  reginfo->strend
d4558 1
a4558 1
		    /* Note that here we know reginfo->strend > locinput, as we
d4581 1
a4581 1
                            while (locinput < reginfo->strend
d4589 1
a4589 1
                            while (locinput < reginfo->strend
d4602 1
a4602 1
                            while (locinput < reginfo->strend
d4614 1
a4614 1
                            if (locinput < reginfo->strend
d4632 1
a4632 1
                                    while (locinput < reginfo->strend
d4641 1
a4641 1
                                while (locinput < reginfo->strend
d4651 1
a4651 1
                    while (locinput < reginfo->strend
d4659 1
a4659 1
		if (locinput > reginfo->strend) sayNO;
d4670 1
a4670 1
	    const char *s;
d4676 1
d4680 1
a4680 1
	    utf8_fold_flags = FOLDEQ_LOCALE;
d4721 1
d4724 1
a4724 1
	    utf8_fold_flags = FOLDEQ_LOCALE;
d4756 1
a4756 1
	    reginfo->poscache_iter = reginfo->poscache_maxiter; /* Void cache */
d4762 1
a4762 1
	    s = reginfo->strbeg + ln;
d4764 3
a4766 3
		&& (utf8_target || type == REFFU || type == REFFL))
	    {
		char * limit = reginfo->strend;
d4770 3
a4772 3
                    * not going off the end given by reginfo->strend, and
                    * returns in <limit> upon success, how much of the
                    * current input was matched */
d4789 1
a4789 1
	    if (locinput + ln > reginfo->strend)
a4838 6

            /* Save all the positions seen so far. */
            ST.cp = regcppush(rex, 0, maxopenparen);
            REGCP_SET(ST.lastcp);

            /* and then jump to the code we share with EVAL */
a4839 1

d4857 2
d4865 16
d4967 1
a4967 5
		rex->offs[0].end = locinput - reginfo->strbeg;
                if (reginfo->info_aux_eval->pos_magic)
                    MgBYTEPOS_set(reginfo->info_aux_eval->pos_magic,
                                  reginfo->sv, reginfo->strbeg,
                                  locinput - reginfo->strbeg);
a5004 2
		    if (SvGMAGICAL(ret))
			ret = sv_mortalcopy(ret);
d5011 2
a5012 2
			else if (SvSMAGICAL(ret)) {
			    MAGIC *mg = mg_find(ret, PERL_MAGIC_qr);
d5017 2
a5018 2
			/* force any undef warnings here */
			if (!re_sv && !SvPOK(ret) && !SvNIOK(ret)) {
d5026 2
d5034 1
a5035 1
		PL_curpm = PL_reg_curpm;
d5074 2
a5075 2
			      & (SVs_TEMP | SVs_GMG | SVf_ROK))
			 && (!SvPADTMP(ret) || SvREADONLY(ret))) {
d5081 4
a5093 2
                re->lastparen = 0;
                re->lastcloseparen = 0;
d5096 2
a5097 2
                    debug_start_match(re_sv, utf8_target, locinput,
                                    reginfo->strend, "Matching embedded");
a5100 20
                /* Save all the seen positions so far. */
                ST.cp = regcppush(rex, 0, maxopenparen);
                REGCP_SET(ST.lastcp);
                /* and set maxopenparen to 0, since we are starting a "fresh" match */
                maxopenparen = 0;
                /* run the pattern returned from (??{...}) */

        eval_recurse_doit: /* Share code with GOSUB below this line
                            * At this point we expect the stack context to be
                            * set up correctly */

                /* invalidate the S-L poscache. We're now executing a
                 * different set of WHILEM ops (and their associated
                 * indexes) against the same string, so the bits in the
                 * cache are meaningless. Setting maxiter to zero forces
                 * the cache to be invalidated and zeroed before reuse.
		 * XXX This is too dramatic a measure. Ideally we should
                 * save the old cache and restore when running the outer
                 * pattern again */
		reginfo->poscache_maxiter = 0;
d5102 17
a5118 2
                /* the new regexp might have a different is_utf8_pat than we do */
                is_utf8_pat = reginfo->is_utf8_pat = cBOOL(RX_UTF8(re_sv));
d5137 1
a5138 1
            is_utf8_pat = reginfo->is_utf8_pat = cBOOL(RX_UTF8(rex_sv));
d5142 1
a5142 8
            {
                /* preserve $^R across LEAVE's. See Bug 121070. */
                SV *save_sv= GvSV(PL_replgv);
                SvREFCNT_inc(save_sv);
                regcpblow(ST.cp); /* LEAVE in disguise */
                sv_setsv(GvSV(PL_replgv), save_sv);
                SvREFCNT_dec(save_sv);
            }
d5146 2
a5147 2
	    /* Invalidate cache. See "invalidate" comment above. */
	    reginfo->poscache_maxiter = 0;
d5155 1
a5156 1
            is_utf8_pat = reginfo->is_utf8_pat = cBOOL(RX_UTF8(rex_sv));
d5165 2
a5166 2
	    /* Invalidate cache. See "invalidate" comment above. */
	    reginfo->poscache_maxiter = 0;
d5174 1
a5174 1
	    rex->offs[n].start_tmp = locinput - reginfo->strbeg;
d5191 1
a5191 1
    rex->offs[n].end = locinput - reginfo->strbeg; \
d5256 1
a5256 1
	    reginfo->poscache_iter = reginfo->poscache_maxiter; /* Void cache */
d5444 1
a5444 31
	    /* super-linear cache processing.
             *
             * The idea here is that for certain types of CURLYX/WHILEM -
             * principally those whose upper bound is infinity (and
             * excluding regexes that have things like \1 and other very
             * non-regular expresssiony things), then if a pattern like
             * /....A*.../ fails and we backtrack to the WHILEM, then we
             * make a note that this particular WHILEM op was at string
             * position 47 (say) when the rest of pattern failed. Then, if
             * we ever find ourselves back at that WHILEM, and at string
             * position 47 again, we can just fail immediately rather than
             * running the rest of the pattern again.
             *
             * This is very handy when patterns start to go
             * 'super-linear', like in (a+)*(a+)*(a+)*, where you end up
             * with a combinatorial explosion of backtracking.
             *
             * The cache is implemented as a bit array, with one bit per
             * string byte position per WHILEM op (up to 16) - so its
             * between 0.25 and 2x the string size.
             *
             * To avoid allocating a poscache buffer every time, we do an
             * initially countdown; only after we have  executed a WHILEM
             * op (string-length x #WHILEMs) times do we allocate the
             * cache.
             *
             * The top 4 bits of scan->flags byte say how many different
             * relevant CURLLYX/WHILEM op pairs there are, while the
             * bottom 4-bits is the identifying index number of this
             * WHILEM.
             */
d5448 1
a5448 1
		if (!reginfo->poscache_maxiter) {
d5451 1
a5451 3
		    reginfo->poscache_maxiter
                        =    (reginfo->strend - reginfo->strbeg + 1)
                           * (scan->flags>>4);
d5453 3
a5455 3
		    if (reginfo->poscache_maxiter < 0)
			reginfo->poscache_maxiter = I32_MAX;
		    reginfo->poscache_iter = reginfo->poscache_maxiter;
d5458 1
a5458 1
		if (reginfo->poscache_iter-- == 0) {
d5460 5
a5464 6
		    const SSize_t size = (reginfo->poscache_maxiter + 7)/8;
                    regmatch_info_aux *const aux = reginfo->info_aux;
		    if (aux->poscache) {
			if ((SSize_t)reginfo->poscache_size < size) {
			    Renew(aux->poscache, size, char);
			    reginfo->poscache_size = size;
d5466 1
a5466 1
			Zero(aux->poscache, size, char);
d5469 2
a5470 2
			reginfo->poscache_size = size;
			Newxz(aux->poscache, size, char);
d5478 1
a5478 1
		if (reginfo->poscache_iter < 0) {
d5480 1
a5480 3
		    SSize_t offset, mask;

                    reginfo->poscache_iter = -1; /* stop eventual underflow */
d5482 1
a5482 2
                                +   (locinput - reginfo->strbeg)
                                  * (scan->flags>>4);
d5485 1
a5485 1
		    if (reginfo->info_aux->poscache[offset] & mask) {
d5720 1
a5720 1
		if (reginfo->is_utf8_target) {
d5780 1
a5780 1
                           reginfo))
d5802 1
a5802 1
                                "%*s  CURLYM Fast bail next target=0x%"UVXf" c1=0x%"UVXf" c2=0x%"UVXf"\n",
d5816 1
a5816 1
                            "%*s  CURLYM Fast bail next target=0x%X c1=0x%X c2=0x%X\n",
d5830 2
a5831 2
			= HOPc(locinput, -ST.alen) - reginfo->strbeg;
		    rex->offs[paren].end = locinput - reginfo->strbeg;
d5873 2
a5874 2
	    rex->offs[paren].start = HOPc(locinput, -1) - reginfo->strbeg; \
	    rex->offs[paren].end = locinput - reginfo->strbeg; \
d5957 1
a5957 1
                           reginfo))
d5971 1
a5971 1
                        regrepeat(rex, &li, ST.A, reginfo, ST.min, depth)
d5985 1
a5985 1
		    ST.maxpos = reginfo->strend - 1;
d5993 1
a5993 1
			 m >0 && ST.maxpos < reginfo->strend; m--)
d5998 2
a5999 2
		    if (ST.maxpos >= reginfo->strend)
			ST.maxpos = reginfo->strend - 1;
d6008 2
a6009 1
		ST.count = regrepeat(rex, &li, ST.A, reginfo, ST.max, depth);
d6093 1
a6093 1
		    if (regrepeat(rex, &li, ST.A, reginfo, n, depth) < n)
d6117 1
a6117 1
                if (!regrepeat(rex, &li, ST.A, reginfo, 1, depth)) {
d6147 1
a6147 1
		bool could_match = locinput < reginfo->strend;
d6192 2
a6199 1
		is_utf8_pat = reginfo->is_utf8_pat = cBOOL(RX_UTF8(rex_sv));
d6228 2
a6229 2
				      (long)(locinput - startpos),
				      (long)(reginfo->till - startpos),
d6321 1
a6321 1
	    reginfo->cutpoint = reginfo->strend;
d6421 1
a6421 1
            if ((n=is_LNBREAK_safe(locinput, reginfo->strend, utf8_target))) {
d6439 1
a6439 1
                if (locinput > reginfo->strend)
d6551 1
a6551 1
    if (reginfo->info_aux_eval) {
a6556 4
        /* I dont know if this is needed or works properly now.
         * see code related to PL_replgv elsewhere in this file.
         * Yves
         */
d6623 5
a6627 2
    assert(!result ||  locinput - reginfo->strbeg >= 0);
    return result ?  locinput - reginfo->strbeg : -1;
a6639 1
 * reginfo   - struct holding match state, such as strend
d6645 1
a6645 1
            regmatch_info *const reginfo, I32 max, int depth)
d6650 1
a6650 1
    char *loceol = reginfo->strend;   /* local version */
d6652 1
a6652 1
    bool utf8_target = reginfo->is_utf8_target;
d6724 1
a6724 1
        assert(STR_LEN(p) == reginfo->is_utf8_pat ? UTF8SKIP(STRING(p)) : 1);
d6732 1
a6732 1
        if (UTF8_IS_INVARIANT(c) || (! utf8_target && ! reginfo->is_utf8_pat)) {
d6742 1
a6742 1
	else if (reginfo->is_utf8_pat) {
d6761 1
a6761 1
                c = TWO_BYTE_UTF8_TO_NATIVE(c, *(STRING(p) + 1));
a6787 3
    case EXACTFA_NO_TRIE:   /* This node only generated for non-utf8 patterns */
        assert(! reginfo->is_utf8_pat);
        /* FALL THROUGH */
d6789 1
a6789 1
        utf8_flags = FOLDEQ_UTF8_NOMIX_ASCII;
d6793 2
a6794 1
	utf8_flags = FOLDEQ_LOCALE;
d6797 3
a6799 4
    case EXACTF:   /* This node only generated for non-utf8 patterns */
        assert(! reginfo->is_utf8_pat);
        utf8_flags = 0;
        goto do_exactf;
d6802 1
d6804 1
a6804 1
	utf8_flags = reginfo->is_utf8_pat ? FOLDEQ_S2_ALREADY_FOLDED : 0;
d6810 1
a6810 1
        assert(STR_LEN(p) == reginfo->is_utf8_pat ? UTF8SKIP(STRING(p)) : 1);
d6813 1
a6813 1
                                        reginfo))
d6817 2
a6818 2
                char *tmpeol = reginfo->strend;
                STRLEN pat_len = reginfo->is_utf8_pat ? UTF8SKIP(STRING(p)) : 1;
d6822 1
a6822 1
                                             reginfo->is_utf8_pat, utf8_flags))
d6825 1
a6825 1
                    tmpeol = reginfo->strend;
d6866 1
d6870 1
a6870 1
		   && reginclass(prog, p, (U8*)scan, (U8*) loceol, utf8_target))
d6888 1
d6988 2
a6989 2
                              ^ cBOOL(_generic_isCC(TWO_BYTE_UTF8_TO_NATIVE(*scan,
                                                                     *(scan + 1)),
d7071 2
a7072 4
                                        "utf8",
                                        "",
                                        &PL_sv_undef, 1, 0,
                                        PL_XPosix_ptrs[classnum], &flags);
d7099 1
a7099 1
            loceol = reginfo->strend;
d7140 1
a7140 1
            regprop(prog, prop, p, reginfo);
d7166 1
a7166 1
    return newSVsv(_get_regclass_nonbitmap_data(prog, node, doinit, listsvp, NULL));
d7168 1
d7170 2
a7171 6
SV *
Perl__get_regclass_nonbitmap_data(pTHX_ const regexp *prog,
                                        const regnode* node,
                                        bool doinit,
                                        SV** listsvp,
                                        SV** only_utf8_locale_ptr)
d7173 2
a7174 3
    /* For internal core use only.
     * Returns the swash for the input 'node' in the regex 'prog'.
     * If <doinit> is 'true', will attempt to create the swash if not already
d7176 2
a7177 5
     * If <listsvp> is non-null, will return the printable contents of the
     *    swash.  This can be used to get debugging information even before the
     *    swash exists, by calling this function with 'doinit' set to false, in
     *    which case the components that will be used to eventually create the
     *    swash are returned  (in a printable form).
d7182 1
a7182 1
    SV *si  = NULL;         /* Input swash initialization string */
d7188 1
a7188 1
    PERL_ARGS_ASSERT__GET_REGCLASS_NONBITMAP_DATA;
d7190 1
a7190 2
    assert(ANYOF_FLAGS(node)
                        & (ANYOF_UTF8|ANYOF_NONBITMAP_NON_UTF8|ANYOF_LOC_FOLD));
d7203 2
a7204 2
	    /* Elements 3 and 4 are either both present or both absent. [3] is
	     * any inversion list generated at compile time; [4] indicates if
d7206 4
a7209 19
            if (av_tindex(av) >= 2) {
                if (only_utf8_locale_ptr
                    && ary[2]
                    && ary[2] != &PL_sv_undef)
                {
                    *only_utf8_locale_ptr = ary[2];
                }
                else {
                    *only_utf8_locale_ptr = NULL;
                }

                if (av_tindex(av) >= 3) {
                    invlist = ary[3];
                    if (SvUV(ary[4])) {
                        swash_init_flags |= _CORE_SWASH_INIT_USER_DEFINED_PROPERTY;
                    }
                }
                else {
                    invlist = NULL;
d7211 3
d7218 1
a7218 1
	    if (ary[1] && SvROK(ary[1])) {
d7221 1
a7221 2
	    else if (doinit && ((si && si != &PL_sv_undef)
                                 || (invlist && invlist != &PL_sv_undef))) {
a7234 1
    /* If requested, return a printable version of what this swash matches */
d7238 2
a7239 5
        /* The swash should be used, if possible, to get the data, as it
         * contains the resolved data.  But this function can be called at
         * compile-time, before everything gets resolved, in which case we
         * return the currently best available information, which is the string
         * that will eventually be used to do that resolving, 'si' */
d7243 2
a7257 1
#endif /* !defined(PERL_IN_XSUB_RE) || defined(PLUGGABLE_RE_EXTENSION) */
a7263 1
  p_end points to one byte beyond the end of the target string
d7275 1
a7275 1
S_reginclass(pTHX_ regexp * const prog, const regnode * const n, const U8* const p, const U8* const p_end, const bool utf8_target)
d7288 1
a7288 1
	c = utf8n_to_uvchr(p, p_end - p, &c_len,
d7301 1
a7301 1
	else if (flags & ANYOF_NON_UTF8_NON_ASCII_ALL
d7307 9
a7315 7
	else if (flags & ANYOF_LOCALE_FLAGS) {
	    if (flags & ANYOF_LOC_FOLD) {
		 if (ANYOF_BITMAP_TEST(n, PL_fold_locale[c])) {
                    match = TRUE;
                }
            }
	    if (! match && ANYOF_POSIXL_TEST_ANY_SET(n)) {
a7348 1

d7350 1
a7350 1
                    if (ANYOF_POSIXL_TEST(n, count)
a7362 1

d7364 8
a7371 1
     * bitmap could match, try that. */
d7373 1
a7373 1
	if (c >= 256 && (flags & ANYOF_ABOVE_LATIN1_ALL)) {
d7376 8
a7383 9
	else if ((flags & ANYOF_NONBITMAP_NON_UTF8)
		  || (utf8_target && (flags & ANYOF_UTF8))
                  || ((flags & ANYOF_LOC_FOLD)
                       && IN_UTF8_CTYPE_LOCALE
                       && ARG(n) != ANYOF_NONBITMAP_EMPTY))
        {
            SV* only_utf8_locale = NULL;
	    SV * const sw = _get_regclass_nonbitmap_data(prog, n, TRUE, 0,
                                                            &only_utf8_locale);
a7399 3
            if (! match && only_utf8_locale && IN_UTF8_CTYPE_LOCALE) {
                match = _invlist_contains_cp(only_utf8_locale, c);
            }
d7403 1
a7403 1
            && (flags & ANYOF_WARN_SUPER)
d7407 1
a7407 1
                "Matched non-Unicode code point 0x%04"UVXf" against Unicode property; may not be portable", c);
a7410 6
#if ANYOF_INVERT != 1
    /* Depending on compiler optimization cBOOL takes time, so if don't have to
     * use it, don't */
#   error ANYOF_INVERT needs to be set to 1, or guarded with cBOOL below,
#endif

d7412 1
a7412 1
    return (flags & ANYOF_INVERT) ^ match;
d7416 1
a7416 1
S_reghop3(U8 *s, SSize_t off, const U8* lim)
d7445 5
d7451 1
a7451 1
S_reghop4(U8 *s, SSize_t off, const U8* llim, const U8* rlim)
d7475 1
a7475 3

/* like reghop3, but returns NULL on overrun, rather than returning last
 * char pos */
d7478 1
a7478 1
S_reghopmaybe3(U8* s, SSize_t off, const U8* lim)
a7506 88

/* when executing a regex that may have (?{}), extra stuff needs setting
   up that will be visible to the called code, even before the current
   match has finished. In particular:

   * $_ is localised to the SV currently being matched;
   * pos($_) is created if necessary, ready to be updated on each call-out
     to code;
   * a fake PMOP is created that can be set to PL_curpm (normally PL_curpm
     isn't set until the current pattern is successfully finished), so that
     $1 etc of the match-so-far can be seen;
   * save the old values of subbeg etc of the current regex, and  set then
     to the current string (again, this is normally only done at the end
     of execution)
*/

static void
S_setup_eval_state(pTHX_ regmatch_info *const reginfo)
{
    MAGIC *mg;
    regexp *const rex = ReANY(reginfo->prog);
    regmatch_info_aux_eval *eval_state = reginfo->info_aux_eval;

    eval_state->rex = rex;

    if (reginfo->sv) {
        /* Make $_ available to executed code. */
        if (reginfo->sv != DEFSV) {
            SAVE_DEFSV;
            DEFSV_set(reginfo->sv);
        }

        if (!(mg = mg_find_mglob(reginfo->sv))) {
            /* prepare for quick setting of pos */
            mg = sv_magicext_mglob(reginfo->sv);
            mg->mg_len = -1;
        }
        eval_state->pos_magic = mg;
        eval_state->pos       = mg->mg_len;
        eval_state->pos_flags = mg->mg_flags;
    }
    else
        eval_state->pos_magic = NULL;

    if (!PL_reg_curpm) {
        /* PL_reg_curpm is a fake PMOP that we can attach the current
         * regex to and point PL_curpm at, so that $1 et al are visible
         * within a /(?{})/. It's just allocated once per interpreter the
         * first time its needed */
        Newxz(PL_reg_curpm, 1, PMOP);
#ifdef USE_ITHREADS
        {
            SV* const repointer = &PL_sv_undef;
            /* this regexp is also owned by the new PL_reg_curpm, which
               will try to free it.  */
            av_push(PL_regex_padav, repointer);
            PL_reg_curpm->op_pmoffset = av_tindex(PL_regex_padav);
            PL_regex_pad = AvARRAY(PL_regex_padav);
        }
#endif
    }
    SET_reg_curpm(reginfo->prog);
    eval_state->curpm = PL_curpm;
    PL_curpm = PL_reg_curpm;
    if (RXp_MATCH_COPIED(rex)) {
        /*  Here is a serious problem: we cannot rewrite subbeg,
            since it may be needed if this match fails.  Thus
            $` inside (?{}) could fail... */
        eval_state->subbeg     = rex->subbeg;
        eval_state->sublen     = rex->sublen;
        eval_state->suboffset  = rex->suboffset;
        eval_state->subcoffset = rex->subcoffset;
#ifdef PERL_ANY_COW
        eval_state->saved_copy = rex->saved_copy;
#endif
        RXp_MATCH_COPIED_off(rex);
    }
    else
        eval_state->subbeg = NULL;
    rex->subbeg = (char *)reginfo->strbeg;
    rex->suboffset = 0;
    rex->subcoffset = 0;
    rex->sublen = reginfo->strend - reginfo->strbeg;
}


/* destructor to clear up regmatch_info_aux and regmatch_info_aux_eval */

d7508 1
a7508 1
S_cleanup_regmatch_info_aux(pTHX_ void *arg)
d7511 7
a7517 16
    regmatch_info_aux *aux = (regmatch_info_aux *) arg;
    regmatch_info_aux_eval *eval_state =  aux->info_aux_eval;
    regmatch_slab *s;

    Safefree(aux->poscache);

    if (eval_state) {

        /* undo the effects of S_setup_eval_state() */

        if (eval_state->subbeg) {
            regexp * const rex = eval_state->rex;
            rex->subbeg     = eval_state->subbeg;
            rex->sublen     = eval_state->sublen;
            rex->suboffset  = eval_state->suboffset;
            rex->subcoffset = eval_state->subcoffset;
d7519 1
a7519 1
            rex->saved_copy = eval_state->saved_copy;
d7521 6
a7526 29
            RXp_MATCH_COPIED_on(rex);
        }
        if (eval_state->pos_magic)
        {
            eval_state->pos_magic->mg_len = eval_state->pos;
            eval_state->pos_magic->mg_flags =
                 (eval_state->pos_magic->mg_flags & ~MGf_BYTES)
               | (eval_state->pos_flags & MGf_BYTES);
        }

        PL_curpm = eval_state->curpm;
    }

    PL_regmatch_state = aux->old_regmatch_state;
    PL_regmatch_slab  = aux->old_regmatch_slab;

    /* free all slabs above current one - this must be the last action
     * of this function, as aux and eval_state are allocated within
     * slabs and may be freed here */

    s = PL_regmatch_slab->next;
    if (s) {
        PL_regmatch_slab->next = NULL;
        while (s) {
            regmatch_slab * const osl = s;
            s = s->next;
            Safefree(osl);
        }
    }
a7527 1

@


1.1.1.16
log
@Import perl-5.20.2
@
text
@a709 1
    RX_MATCH_UTF8_set(rx,utf8_target);
a2587 1
    RX_MATCH_UTF8_set(rx, utf8_target);
d3107 2
@


