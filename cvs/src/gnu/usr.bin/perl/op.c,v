head	1.21;
access;
symbols
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.20.0.4
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.19.0.4
	OPENBSD_5_8_BASE:1.19
	PERL_5_20_2:1.1.1.17
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	PERL_5_20_1:1.1.1.16
	OPENBSD_5_6:1.17.0.4
	OPENBSD_5_6_BASE:1.17
	PERL_5_18_2:1.1.1.15
	PERL:1.1.1
	OPENBSD_5_5:1.16.0.6
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.2
	OPENBSD_5_4_BASE:1.16
	PERL_5_16_3:1.1.1.14
	OPENBSD_5_3:1.15.0.10
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.8
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.6
	OPENBSD_5_0:1.15.0.4
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.2
	OPENBSD_4_9_BASE:1.15
	PERL_5_12_2:1.1.1.13
	OPENBSD_4_8:1.14.0.4
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	PERL_5_10_1:1.1.1.12
	OPENBSD_4_6:1.13.0.6
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.2
	OPENBSD_4_5_BASE:1.13
	PERL_5_10_0:1.1.1.11
	OPENBSD_4_4:1.12.0.10
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.8
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.6
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.4
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.2
	OPENBSD_4_0_BASE:1.12
	PERL_5_8_8:1.1.1.10
	OPENBSD_3_9:1.11.0.2
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.10.0.4
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	PERL_5_8_6:1.1.1.9
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	PERL_5_8_5:1.1.1.8
	PERL_5_8_3:1.1.1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.21
date	2017.02.05.00.31.53;	author afresh1;	state Exp;
branches;
next	1.20;
commitid	cxJ08BvJA9Pt2PTM;

1.20
date	2016.07.03.01.07.48;	author afresh1;	state Exp;
branches;
next	1.19;
commitid	GzHqjSTnBjdF7Wcw;

1.19
date	2015.04.25.19.14.37;	author afresh1;	state Exp;
branches;
next	1.18;
commitid	XRK22kO4se3v2i2I;

1.18
date	2014.11.17.20.56.47;	author afresh1;	state Exp;
branches;
next	1.17;
commitid	QP75iYx42Uo7mMxO;

1.17
date	2014.03.24.15.05.13;	author afresh1;	state Exp;
branches;
next	1.16;

1.16
date	2013.03.25.20.40.44;	author sthen;	state Exp;
branches;
next	1.15;

1.15
date	2010.09.24.15.06.40;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.12.18.24.21;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2008.09.29.17.35.57;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2006.03.28.19.22.57;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2006.01.02.23.37.09;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.15.21.30.19;	author millert;	state Exp;
branches
	1.10.2.1
	1.10.4.1;
next	1.9;

1.9
date	2004.08.09.18.08.55;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.07.21.32.59;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.21;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.18;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.34.51;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.04.05;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.02;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.48.49;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.11.42;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.11.42;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.37.28;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.08.40;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.22.09;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.48;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.31;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.04.07.21.12.51;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.08.09.17.45.22;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2005.01.15.21.16.28;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2006.03.28.18.47.31;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2008.09.29.17.18.06;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2009.10.12.18.10.33;	author millert;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2010.09.24.14.48.26;	author millert;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2013.03.25.20.06.28;	author sthen;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2014.03.24.14.58.45;	author afresh1;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	2014.11.17.20.52.37;	author afresh1;	state Exp;
branches;
next	1.1.1.17;
commitid	B31cAbBIXiCqnL97;

1.1.1.17
date	2015.04.25.19.10.10;	author afresh1;	state Exp;
branches;
next	;
commitid	Wpcs5S8qILgEZC7F;

1.10.2.1
date	2006.01.03.05.44.49;	author brad;	state Exp;
branches;
next	;

1.10.4.1
date	2006.01.03.04.22.40;	author brad;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#line 2 "op.c"
/*    op.c
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 * 'You see: Mr. Drogo, he married poor Miss Primula Brandybuck.  She was
 *  our Mr. Bilbo's first cousin on the mother's side (her mother being the
 *  youngest of the Old Took's daughters); and Mr. Drogo was his second
 *  cousin.  So Mr. Frodo is his first *and* second cousin, once removed
 *  either way, as the saying is, if you follow me.'       --the Gaffer
 *
 *     [p.23 of _The Lord of the Rings_, I/i: "A Long-Expected Party"]
 */

/* This file contains the functions that create, manipulate and optimize
 * the OP structures that hold a compiled perl program.
 *
 * A Perl program is compiled into a tree of OPs. Each op contains
 * structural pointers (eg to its siblings and the next op in the
 * execution sequence), a pointer to the function that would execute the
 * op, plus any data specific to that op. For example, an OP_CONST op
 * points to the pp_const() function and to an SV containing the constant
 * value. When pp_const() is executed, its job is to push that SV onto the
 * stack.
 *
 * OPs are mainly created by the newFOO() functions, which are mainly
 * called from the parser (in perly.y) as the code is parsed. For example
 * the Perl code $a + $b * $c would cause the equivalent of the following
 * to be called (oversimplifying a bit):
 *
 *  newBINOP(OP_ADD, flags,
 *	newSVREF($a),
 *	newBINOP(OP_MULTIPLY, flags, newSVREF($b), newSVREF($c))
 *  )
 *
 * Note that during the build of miniperl, a temporary copy of this file
 * is made, called opmini.c.
 */

/*
Perl's compiler is essentially a 3-pass compiler with interleaved phases:

    A bottom-up pass
    A top-down pass
    An execution-order pass

The bottom-up pass is represented by all the "newOP" routines and
the ck_ routines.  The bottom-upness is actually driven by yacc.
So at the point that a ck_ routine fires, we have no idea what the
context is, either upward in the syntax tree, or either forward or
backward in the execution order.  (The bottom-up parser builds that
part of the execution order it knows about, but if you follow the "next"
links around, you'll find it's actually a closed loop through the
top level node.)

Whenever the bottom-up parser gets to a node that supplies context to
its components, it invokes that portion of the top-down pass that applies
to that part of the subtree (and marks the top node as processed, so
if a node further up supplies context, it doesn't have to take the
plunge again).  As a particular subcase of this, as the new node is
built, it takes all the closed execution loops of its subcomponents
and links them into a new closed loop for the higher level node.  But
it's still not the real execution order.

The actual execution order is not known till we get a grammar reduction
to a top-level unit like a subroutine or file that will be called by
"name" rather than via a "next" pointer.  At that point, we can call
into peep() to do that code's portion of the 3rd pass.  It has to be
recursive, but it's recursive on basic blocks, not on tree nodes.
*/

/* To implement user lexical pragmas, there needs to be a way at run time to
   get the compile time state of %^H for that block.  Storing %^H in every
   block (or even COP) would be very expensive, so a different approach is
   taken.  The (running) state of %^H is serialised into a tree of HE-like
   structs.  Stores into %^H are chained onto the current leaf as a struct
   refcounted_he * with the key and the value.  Deletes from %^H are saved
   with a value of PL_sv_placeholder.  The state of %^H at any point can be
   turned back into a regular HV by walking back up the tree from that point's
   leaf, ignoring any key you've already seen (placeholder or not), storing
   the rest into the HV structure, then removing the placeholders. Hence
   memory is only used to store the %^H deltas from the enclosing COP, rather
   than the entire %^H on each COP.

   To cause actions on %^H to write out the serialisation records, it has
   magic type 'H'. This magic (itself) does nothing, but its presence causes
   the values to gain magic type 'h', which has entries for set and clear.
   C<Perl_magic_sethint> updates C<PL_compiling.cop_hints_hash> with a store
   record, with deletes written by C<Perl_magic_clearhint>. C<SAVEHINTS>
   saves the current C<PL_compiling.cop_hints_hash> on the save stack, so that
   it will be correctly restored when any inner compiling scope is exited.
*/

#include "EXTERN.h"
#define PERL_IN_OP_C
#include "perl.h"
#include "keywords.h"
#include "feature.h"
#include "regcomp.h"

#define CALL_PEEP(o) PL_peepp(aTHX_ o)
#define CALL_RPEEP(o) PL_rpeepp(aTHX_ o)
#define CALL_OPFREEHOOK(o) if (PL_opfreehook) PL_opfreehook(aTHX_ o)

static const char array_passed_to_stat[] = "Array passed to stat will be coerced to a scalar";

/* Used to avoid recursion through the op tree in scalarvoid() and
   op_free()
*/

#define DEFERRED_OP_STEP 100
#define DEFER_OP(o) \
  STMT_START { \
    if (UNLIKELY(defer_ix == (defer_stack_alloc-1))) {    \
        defer_stack_alloc += DEFERRED_OP_STEP; \
        assert(defer_stack_alloc > 0); \
        Renew(defer_stack, defer_stack_alloc, OP *); \
    } \
    defer_stack[++defer_ix] = o; \
  } STMT_END

#define POP_DEFERRED_OP() (defer_ix >= 0 ? defer_stack[defer_ix--] : (OP *)NULL)

/* remove any leading "empty" ops from the op_next chain whose first
 * node's address is stored in op_p. Store the updated address of the
 * first node in op_p.
 */

STATIC void
S_prune_chain_head(OP** op_p)
{
    while (*op_p
        && (   (*op_p)->op_type == OP_NULL
            || (*op_p)->op_type == OP_SCOPE
            || (*op_p)->op_type == OP_SCALAR
            || (*op_p)->op_type == OP_LINESEQ)
    )
        *op_p = (*op_p)->op_next;
}


/* See the explanatory comments above struct opslab in op.h. */

#ifdef PERL_DEBUG_READONLY_OPS
#  define PERL_SLAB_SIZE 128
#  define PERL_MAX_SLAB_SIZE 4096
#  include <sys/mman.h>
#endif

#ifndef PERL_SLAB_SIZE
#  define PERL_SLAB_SIZE 64
#endif
#ifndef PERL_MAX_SLAB_SIZE
#  define PERL_MAX_SLAB_SIZE 2048
#endif

/* rounds up to nearest pointer */
#define SIZE_TO_PSIZE(x)	(((x) + sizeof(I32 *) - 1)/sizeof(I32 *))
#define DIFF(o,p)		((size_t)((I32 **)(p) - (I32**)(o)))

static OPSLAB *
S_new_slab(pTHX_ size_t sz)
{
#ifdef PERL_DEBUG_READONLY_OPS
    OPSLAB *slab = (OPSLAB *) mmap(0, sz * sizeof(I32 *),
				   PROT_READ|PROT_WRITE,
				   MAP_ANON|MAP_PRIVATE, -1, 0);
    DEBUG_m(PerlIO_printf(Perl_debug_log, "mapped %lu at %p\n",
			  (unsigned long) sz, slab));
    if (slab == MAP_FAILED) {
	perror("mmap failed");
	abort();
    }
    slab->opslab_size = (U16)sz;
#else
    OPSLAB *slab = (OPSLAB *)PerlMemShared_calloc(sz, sizeof(I32 *));
#endif
#ifndef WIN32
    /* The context is unused in non-Windows */
    PERL_UNUSED_CONTEXT;
#endif
    slab->opslab_first = (OPSLOT *)((I32 **)slab + sz - 1);
    return slab;
}

/* requires double parens and aTHX_ */
#define DEBUG_S_warn(args)					       \
    DEBUG_S( 								\
	PerlIO_printf(Perl_debug_log, "%s", SvPVx_nolen(Perl_mess args)) \
    )

void *
Perl_Slab_Alloc(pTHX_ size_t sz)
{
    OPSLAB *slab;
    OPSLAB *slab2;
    OPSLOT *slot;
    OP *o;
    size_t opsz, space;

    /* We only allocate ops from the slab during subroutine compilation.
       We find the slab via PL_compcv, hence that must be non-NULL. It could
       also be pointing to a subroutine which is now fully set up (CvROOT()
       pointing to the top of the optree for that sub), or a subroutine
       which isn't using the slab allocator. If our sanity checks aren't met,
       don't use a slab, but allocate the OP directly from the heap.  */
    if (!PL_compcv || CvROOT(PL_compcv)
     || (CvSTART(PL_compcv) && !CvSLABBED(PL_compcv)))
    {
	o = (OP*)PerlMemShared_calloc(1, sz);
        goto gotit;
    }

    /* While the subroutine is under construction, the slabs are accessed via
       CvSTART(), to avoid needing to expand PVCV by one pointer for something
       unneeded at runtime. Once a subroutine is constructed, the slabs are
       accessed via CvROOT(). So if CvSTART() is NULL, no slab has been
       allocated yet.  See the commit message for 8be227ab5eaa23f2 for more
       details.  */
    if (!CvSTART(PL_compcv)) {
	CvSTART(PL_compcv) =
	    (OP *)(slab = S_new_slab(aTHX_ PERL_SLAB_SIZE));
	CvSLABBED_on(PL_compcv);
	slab->opslab_refcnt = 2; /* one for the CV; one for the new OP */
    }
    else ++(slab = (OPSLAB *)CvSTART(PL_compcv))->opslab_refcnt;

    opsz = SIZE_TO_PSIZE(sz);
    sz = opsz + OPSLOT_HEADER_P;

    /* The slabs maintain a free list of OPs. In particular, constant folding
       will free up OPs, so it makes sense to re-use them where possible. A
       freed up slot is used in preference to a new allocation.  */
    if (slab->opslab_freed) {
	OP **too = &slab->opslab_freed;
	o = *too;
	DEBUG_S_warn((aTHX_ "found free op at %p, slab %p", (void*)o, (void*)slab));
	while (o && DIFF(OpSLOT(o), OpSLOT(o)->opslot_next) < sz) {
	    DEBUG_S_warn((aTHX_ "Alas! too small"));
	    o = *(too = &o->op_next);
	    if (o) { DEBUG_S_warn((aTHX_ "found another free op at %p", (void*)o)); }
	}
	if (o) {
	    *too = o->op_next;
	    Zero(o, opsz, I32 *);
	    o->op_slabbed = 1;
	    goto gotit;
	}
    }

#define INIT_OPSLOT \
	    slot->opslot_slab = slab;			\
	    slot->opslot_next = slab2->opslab_first;	\
	    slab2->opslab_first = slot;			\
	    o = &slot->opslot_op;			\
	    o->op_slabbed = 1

    /* The partially-filled slab is next in the chain. */
    slab2 = slab->opslab_next ? slab->opslab_next : slab;
    if ((space = DIFF(&slab2->opslab_slots, slab2->opslab_first)) < sz) {
	/* Remaining space is too small. */

	/* If we can fit a BASEOP, add it to the free chain, so as not
	   to waste it. */
	if (space >= SIZE_TO_PSIZE(sizeof(OP)) + OPSLOT_HEADER_P) {
	    slot = &slab2->opslab_slots;
	    INIT_OPSLOT;
	    o->op_type = OP_FREED;
	    o->op_next = slab->opslab_freed;
	    slab->opslab_freed = o;
	}

	/* Create a new slab.  Make this one twice as big. */
	slot = slab2->opslab_first;
	while (slot->opslot_next) slot = slot->opslot_next;
	slab2 = S_new_slab(aTHX_
			    (DIFF(slab2, slot)+1)*2 > PERL_MAX_SLAB_SIZE
					? PERL_MAX_SLAB_SIZE
					: (DIFF(slab2, slot)+1)*2);
	slab2->opslab_next = slab->opslab_next;
	slab->opslab_next = slab2;
    }
    assert(DIFF(&slab2->opslab_slots, slab2->opslab_first) >= sz);

    /* Create a new op slot */
    slot = (OPSLOT *)((I32 **)slab2->opslab_first - sz);
    assert(slot >= &slab2->opslab_slots);
    if (DIFF(&slab2->opslab_slots, slot)
	 < SIZE_TO_PSIZE(sizeof(OP)) + OPSLOT_HEADER_P)
	slot = &slab2->opslab_slots;
    INIT_OPSLOT;
    DEBUG_S_warn((aTHX_ "allocating op at %p, slab %p", (void*)o, (void*)slab));

  gotit:
#ifdef PERL_OP_PARENT
    /* moresib == 0, op_sibling == 0 implies a solitary unattached op */
    assert(!o->op_moresib);
    assert(!o->op_sibparent);
#endif

    return (void *)o;
}

#undef INIT_OPSLOT

#ifdef PERL_DEBUG_READONLY_OPS
void
Perl_Slab_to_ro(pTHX_ OPSLAB *slab)
{
    PERL_ARGS_ASSERT_SLAB_TO_RO;

    if (slab->opslab_readonly) return;
    slab->opslab_readonly = 1;
    for (; slab; slab = slab->opslab_next) {
	/*DEBUG_U(PerlIO_printf(Perl_debug_log,"mprotect ->ro %lu at %p\n",
			      (unsigned long) slab->opslab_size, slab));*/
	if (mprotect(slab, slab->opslab_size * sizeof(I32 *), PROT_READ))
	    Perl_warn(aTHX_ "mprotect for %p %lu failed with %d", slab,
			     (unsigned long)slab->opslab_size, errno);
    }
}

void
Perl_Slab_to_rw(pTHX_ OPSLAB *const slab)
{
    OPSLAB *slab2;

    PERL_ARGS_ASSERT_SLAB_TO_RW;

    if (!slab->opslab_readonly) return;
    slab2 = slab;
    for (; slab2; slab2 = slab2->opslab_next) {
	/*DEBUG_U(PerlIO_printf(Perl_debug_log,"mprotect ->rw %lu at %p\n",
			      (unsigned long) size, slab2));*/
	if (mprotect((void *)slab2, slab2->opslab_size * sizeof(I32 *),
		     PROT_READ|PROT_WRITE)) {
	    Perl_warn(aTHX_ "mprotect RW for %p %lu failed with %d", slab,
			     (unsigned long)slab2->opslab_size, errno);
	}
    }
    slab->opslab_readonly = 0;
}

#else
#  define Slab_to_rw(op)    NOOP
#endif

/* This cannot possibly be right, but it was copied from the old slab
   allocator, to which it was originally added, without explanation, in
   commit 083fcd5. */
#ifdef NETWARE
#    define PerlMemShared PerlMem
#endif

void
Perl_Slab_Free(pTHX_ void *op)
{
    OP * const o = (OP *)op;
    OPSLAB *slab;

    PERL_ARGS_ASSERT_SLAB_FREE;

    if (!o->op_slabbed) {
        if (!o->op_static)
	    PerlMemShared_free(op);
	return;
    }

    slab = OpSLAB(o);
    /* If this op is already freed, our refcount will get screwy. */
    assert(o->op_type != OP_FREED);
    o->op_type = OP_FREED;
    o->op_next = slab->opslab_freed;
    slab->opslab_freed = o;
    DEBUG_S_warn((aTHX_ "free op at %p, recorded in slab %p", (void*)o, (void*)slab));
    OpslabREFCNT_dec_padok(slab);
}

void
Perl_opslab_free_nopad(pTHX_ OPSLAB *slab)
{
    const bool havepad = !!PL_comppad;
    PERL_ARGS_ASSERT_OPSLAB_FREE_NOPAD;
    if (havepad) {
	ENTER;
	PAD_SAVE_SETNULLPAD();
    }
    opslab_free(slab);
    if (havepad) LEAVE;
}

void
Perl_opslab_free(pTHX_ OPSLAB *slab)
{
    OPSLAB *slab2;
    PERL_ARGS_ASSERT_OPSLAB_FREE;
    PERL_UNUSED_CONTEXT;
    DEBUG_S_warn((aTHX_ "freeing slab %p", (void*)slab));
    assert(slab->opslab_refcnt == 1);
    do {
	slab2 = slab->opslab_next;
#ifdef DEBUGGING
	slab->opslab_refcnt = ~(size_t)0;
#endif
#ifdef PERL_DEBUG_READONLY_OPS
	DEBUG_m(PerlIO_printf(Perl_debug_log, "Deallocate slab at %p\n",
					       (void*)slab));
	if (munmap(slab, slab->opslab_size * sizeof(I32 *))) {
	    perror("munmap failed");
	    abort();
	}
#else
	PerlMemShared_free(slab);
#endif
        slab = slab2;
    } while (slab);
}

void
Perl_opslab_force_free(pTHX_ OPSLAB *slab)
{
    OPSLAB *slab2;
    OPSLOT *slot;
#ifdef DEBUGGING
    size_t savestack_count = 0;
#endif
    PERL_ARGS_ASSERT_OPSLAB_FORCE_FREE;
    slab2 = slab;
    do {
	for (slot = slab2->opslab_first;
	     slot->opslot_next;
	     slot = slot->opslot_next) {
	    if (slot->opslot_op.op_type != OP_FREED
	     && !(slot->opslot_op.op_savefree
#ifdef DEBUGGING
		  && ++savestack_count
#endif
		 )
	    ) {
		assert(slot->opslot_op.op_slabbed);
		op_free(&slot->opslot_op);
		if (slab->opslab_refcnt == 1) goto free;
	    }
	}
    } while ((slab2 = slab2->opslab_next));
    /* > 1 because the CV still holds a reference count. */
    if (slab->opslab_refcnt > 1) { /* still referenced by the savestack */
#ifdef DEBUGGING
	assert(savestack_count == slab->opslab_refcnt-1);
#endif
	/* Remove the CV’s reference count. */
	slab->opslab_refcnt--;
	return;
    }
   free:
    opslab_free(slab);
}

#ifdef PERL_DEBUG_READONLY_OPS
OP *
Perl_op_refcnt_inc(pTHX_ OP *o)
{
    if(o) {
        OPSLAB *const slab = o->op_slabbed ? OpSLAB(o) : NULL;
        if (slab && slab->opslab_readonly) {
            Slab_to_rw(slab);
            ++o->op_targ;
            Slab_to_ro(slab);
        } else {
            ++o->op_targ;
        }
    }
    return o;

}

PADOFFSET
Perl_op_refcnt_dec(pTHX_ OP *o)
{
    PADOFFSET result;
    OPSLAB *const slab = o->op_slabbed ? OpSLAB(o) : NULL;

    PERL_ARGS_ASSERT_OP_REFCNT_DEC;

    if (slab && slab->opslab_readonly) {
        Slab_to_rw(slab);
        result = --o->op_targ;
        Slab_to_ro(slab);
    } else {
        result = --o->op_targ;
    }
    return result;
}
#endif
/*
 * In the following definition, the ", (OP*)0" is just to make the compiler
 * think the expression is of the right type: croak actually does a Siglongjmp.
 */
#define CHECKOP(type,o) \
    ((PL_op_mask && PL_op_mask[type])				\
     ? ( op_free((OP*)o),					\
	 Perl_croak(aTHX_ "'%s' trapped by operation mask", PL_op_desc[type]),	\
	 (OP*)0 )						\
     : PL_check[type](aTHX_ (OP*)o))

#define RETURN_UNLIMITED_NUMBER (PERL_INT_MAX / 2)

#define OpTYPE_set(o,type) \
    STMT_START {				\
	o->op_type = (OPCODE)type;		\
	o->op_ppaddr = PL_ppaddr[type];		\
    } STMT_END

STATIC OP *
S_no_fh_allowed(pTHX_ OP *o)
{
    PERL_ARGS_ASSERT_NO_FH_ALLOWED;

    yyerror(Perl_form(aTHX_ "Missing comma after first argument to %s function",
		 OP_DESC(o)));
    return o;
}

STATIC OP *
S_too_few_arguments_pv(pTHX_ OP *o, const char* name, U32 flags)
{
    PERL_ARGS_ASSERT_TOO_FEW_ARGUMENTS_PV;
    yyerror_pv(Perl_form(aTHX_ "Not enough arguments for %s", name), flags);
    return o;
}
 
STATIC OP *
S_too_many_arguments_pv(pTHX_ OP *o, const char *name, U32 flags)
{
    PERL_ARGS_ASSERT_TOO_MANY_ARGUMENTS_PV;

    yyerror_pv(Perl_form(aTHX_ "Too many arguments for %s", name), flags);
    return o;
}

STATIC void
S_bad_type_pv(pTHX_ I32 n, const char *t, const OP *o, const OP *kid)
{
    PERL_ARGS_ASSERT_BAD_TYPE_PV;

    yyerror_pv(Perl_form(aTHX_ "Type of arg %d to %s must be %s (not %s)",
		 (int)n, PL_op_desc[(o)->op_type], t, OP_DESC(kid)), 0);
}

/* remove flags var, its unused in all callers, move to to right end since gv
  and kid are always the same */
STATIC void
S_bad_type_gv(pTHX_ I32 n, GV *gv, const OP *kid, const char *t)
{
    SV * const namesv = cv_name((CV *)gv, NULL, 0);
    PERL_ARGS_ASSERT_BAD_TYPE_GV;
 
    yyerror_pv(Perl_form(aTHX_ "Type of arg %d to %"SVf" must be %s (not %s)",
		 (int)n, SVfARG(namesv), t, OP_DESC(kid)), SvUTF8(namesv));
}

STATIC void
S_no_bareword_allowed(pTHX_ OP *o)
{
    PERL_ARGS_ASSERT_NO_BAREWORD_ALLOWED;

    qerror(Perl_mess(aTHX_
		     "Bareword \"%"SVf"\" not allowed while \"strict subs\" in use",
		     SVfARG(cSVOPo_sv)));
    o->op_private &= ~OPpCONST_STRICT; /* prevent warning twice about the same OP */
}

/* "register" allocation */

PADOFFSET
Perl_allocmy(pTHX_ const char *const name, const STRLEN len, const U32 flags)
{
    PADOFFSET off;
    const bool is_our = (PL_parser->in_my == KEY_our);

    PERL_ARGS_ASSERT_ALLOCMY;

    if (flags & ~SVf_UTF8)
	Perl_croak(aTHX_ "panic: allocmy illegal flag bits 0x%" UVxf,
		   (UV)flags);

    /* complain about "my $<special_var>" etc etc */
    if (len &&
	!(is_our ||
	  isALPHA(name[1]) ||
	  ((flags & SVf_UTF8) && isIDFIRST_utf8((U8 *)name+1)) ||
	  (name[1] == '_' && len > 2)))
    {
	if (!(flags & SVf_UTF8 && UTF8_IS_START(name[1]))
	 && isASCII(name[1])
	 && (!isPRINT(name[1]) || strchr("\t\n\r\f", name[1]))) {
	    yyerror(Perl_form(aTHX_ "Can't use global %c^%c%.*s in \"%s\"",
			      name[0], toCTRL(name[1]), (int)(len - 2), name + 2,
			      PL_parser->in_my == KEY_state ? "state" : "my"));
	} else {
	    yyerror_pv(Perl_form(aTHX_ "Can't use global %.*s in \"%s\"", (int) len, name,
			      PL_parser->in_my == KEY_state ? "state" : "my"), flags & SVf_UTF8);
	}
    }

    /* allocate a spare slot and store the name in that slot */

    off = pad_add_name_pvn(name, len,
		       (is_our ? padadd_OUR :
		        PL_parser->in_my == KEY_state ? padadd_STATE : 0),
		    PL_parser->in_my_stash,
		    (is_our
		        /* $_ is always in main::, even with our */
			? (PL_curstash && !memEQs(name,len,"$_")
			    ? PL_curstash
			    : PL_defstash)
			: NULL
		    )
    );
    /* anon sub prototypes contains state vars should always be cloned,
     * otherwise the state var would be shared between anon subs */

    if (PL_parser->in_my == KEY_state && CvANON(PL_compcv))
	CvCLONE_on(PL_compcv);

    return off;
}

/*
=head1 Optree Manipulation Functions

=for apidoc alloccopstash

Available only under threaded builds, this function allocates an entry in
C<PL_stashpad> for the stash passed to it.

=cut
*/

#ifdef USE_ITHREADS
PADOFFSET
Perl_alloccopstash(pTHX_ HV *hv)
{
    PADOFFSET off = 0, o = 1;
    bool found_slot = FALSE;

    PERL_ARGS_ASSERT_ALLOCCOPSTASH;

    if (PL_stashpad[PL_stashpadix] == hv) return PL_stashpadix;

    for (; o < PL_stashpadmax; ++o) {
	if (PL_stashpad[o] == hv) return PL_stashpadix = o;
	if (!PL_stashpad[o] || SvTYPE(PL_stashpad[o]) != SVt_PVHV)
	    found_slot = TRUE, off = o;
    }
    if (!found_slot) {
	Renew(PL_stashpad, PL_stashpadmax + 10, HV *);
	Zero(PL_stashpad + PL_stashpadmax, 10, HV *);
	off = PL_stashpadmax;
	PL_stashpadmax += 10;
    }

    PL_stashpad[PL_stashpadix = off] = hv;
    return off;
}
#endif

/* free the body of an op without examining its contents.
 * Always use this rather than FreeOp directly */

static void
S_op_destroy(pTHX_ OP *o)
{
    FreeOp(o);
}

/* Destructor */

/*
=for apidoc Am|void|op_free|OP *o

Free an op.  Only use this when an op is no longer linked to from any
optree.

=cut
*/

void
Perl_op_free(pTHX_ OP *o)
{
    dVAR;
    OPCODE type;
    SSize_t defer_ix = -1;
    SSize_t defer_stack_alloc = 0;
    OP **defer_stack = NULL;

    do {

        /* Though ops may be freed twice, freeing the op after its slab is a
           big no-no. */
        assert(!o || !o->op_slabbed || OpSLAB(o)->opslab_refcnt != ~(size_t)0);
        /* During the forced freeing of ops after compilation failure, kidops
           may be freed before their parents. */
        if (!o || o->op_type == OP_FREED)
            continue;

        type = o->op_type;

        /* an op should only ever acquire op_private flags that we know about.
         * If this fails, you may need to fix something in regen/op_private.
         * Don't bother testing if:
         *   * the op_ppaddr doesn't match the op; someone may have
         *     overridden the op and be doing strange things with it;
         *   * we've errored, as op flags are often left in an
         *     inconsistent state then. Note that an error when
         *     compiling the main program leaves PL_parser NULL, so
         *     we can't spot faults in the main code, only
         *     evaled/required code */
#ifdef DEBUGGING
        if (   o->op_ppaddr == PL_ppaddr[o->op_type]
            && PL_parser
            && !PL_parser->error_count)
        {
            assert(!(o->op_private & ~PL_op_private_valid[type]));
        }
#endif

        if (o->op_private & OPpREFCOUNTED) {
            switch (type) {
            case OP_LEAVESUB:
            case OP_LEAVESUBLV:
            case OP_LEAVEEVAL:
            case OP_LEAVE:
            case OP_SCOPE:
            case OP_LEAVEWRITE:
                {
                PADOFFSET refcnt;
                OP_REFCNT_LOCK;
                refcnt = OpREFCNT_dec(o);
                OP_REFCNT_UNLOCK;
                if (refcnt) {
                    /* Need to find and remove any pattern match ops from the list
                       we maintain for reset().  */
                    find_and_forget_pmops(o);
                    continue;
                }
                }
                break;
            default:
                break;
            }
        }

        /* Call the op_free hook if it has been set. Do it now so that it's called
         * at the right time for refcounted ops, but still before all of the kids
         * are freed. */
        CALL_OPFREEHOOK(o);

        if (o->op_flags & OPf_KIDS) {
            OP *kid, *nextkid;
            for (kid = cUNOPo->op_first; kid; kid = nextkid) {
                nextkid = OpSIBLING(kid); /* Get before next freeing kid */
                if (!kid || kid->op_type == OP_FREED)
                    /* During the forced freeing of ops after
                       compilation failure, kidops may be freed before
                       their parents. */
                    continue;
                if (!(kid->op_flags & OPf_KIDS))
                    /* If it has no kids, just free it now */
                    op_free(kid);
                else
                    DEFER_OP(kid);
            }
        }
        if (type == OP_NULL)
            type = (OPCODE)o->op_targ;

        if (o->op_slabbed)
            Slab_to_rw(OpSLAB(o));

        /* COP* is not cleared by op_clear() so that we may track line
         * numbers etc even after null() */
        if (type == OP_NEXTSTATE || type == OP_DBSTATE) {
            cop_free((COP*)o);
        }

        op_clear(o);
        FreeOp(o);
#ifdef DEBUG_LEAKING_SCALARS
        if (PL_op == o)
            PL_op = NULL;
#endif
    } while ( (o = POP_DEFERRED_OP()) );

    Safefree(defer_stack);
}

/* S_op_clear_gv(): free a GV attached to an OP */

STATIC
#ifdef USE_ITHREADS
void S_op_clear_gv(pTHX_ OP *o, PADOFFSET *ixp)
#else
void S_op_clear_gv(pTHX_ OP *o, SV**svp)
#endif
{

    GV *gv = (o->op_type == OP_GV || o->op_type == OP_GVSV
            || o->op_type == OP_MULTIDEREF)
#ifdef USE_ITHREADS
                && PL_curpad
                ? ((GV*)PAD_SVl(*ixp)) : NULL;
#else
                ? (GV*)(*svp) : NULL;
#endif
    /* It's possible during global destruction that the GV is freed
       before the optree. Whilst the SvREFCNT_inc is happy to bump from
       0 to 1 on a freed SV, the corresponding SvREFCNT_dec from 1 to 0
       will trigger an assertion failure, because the entry to sv_clear
       checks that the scalar is not already freed.  A check of for
       !SvIS_FREED(gv) turns out to be invalid, because during global
       destruction the reference count can be forced down to zero
       (with SVf_BREAK set).  In which case raising to 1 and then
       dropping to 0 triggers cleanup before it should happen.  I
       *think* that this might actually be a general, systematic,
       weakness of the whole idea of SVf_BREAK, in that code *is*
       allowed to raise and lower references during global destruction,
       so any *valid* code that happens to do this during global
       destruction might well trigger premature cleanup.  */
    bool still_valid = gv && SvREFCNT(gv);

    if (still_valid)
        SvREFCNT_inc_simple_void(gv);
#ifdef USE_ITHREADS
    if (*ixp > 0) {
        pad_swipe(*ixp, TRUE);
        *ixp = 0;
    }
#else
    SvREFCNT_dec(*svp);
    *svp = NULL;
#endif
    if (still_valid) {
        int try_downgrade = SvREFCNT(gv) == 2;
        SvREFCNT_dec_NN(gv);
        if (try_downgrade)
            gv_try_downgrade(gv);
    }
}


void
Perl_op_clear(pTHX_ OP *o)
{

    dVAR;

    PERL_ARGS_ASSERT_OP_CLEAR;

    switch (o->op_type) {
    case OP_NULL:	/* Was holding old type, if any. */
        /* FALLTHROUGH */
    case OP_ENTERTRY:
    case OP_ENTEREVAL:	/* Was holding hints. */
	o->op_targ = 0;
	break;
    default:
	if (!(o->op_flags & OPf_REF)
	    || (PL_check[o->op_type] != Perl_ck_ftst))
	    break;
	/* FALLTHROUGH */
    case OP_GVSV:
    case OP_GV:
    case OP_AELEMFAST:
#ifdef USE_ITHREADS
            S_op_clear_gv(aTHX_ o, &(cPADOPx(o)->op_padix));
#else
            S_op_clear_gv(aTHX_ o, &(cSVOPx(o)->op_sv));
#endif
	break;
    case OP_METHOD_REDIR:
    case OP_METHOD_REDIR_SUPER:
#ifdef USE_ITHREADS
	if (cMETHOPx(o)->op_rclass_targ) {
	    pad_swipe(cMETHOPx(o)->op_rclass_targ, 1);
	    cMETHOPx(o)->op_rclass_targ = 0;
	}
#else
	SvREFCNT_dec(cMETHOPx(o)->op_rclass_sv);
	cMETHOPx(o)->op_rclass_sv = NULL;
#endif
    case OP_METHOD_NAMED:
    case OP_METHOD_SUPER:
        SvREFCNT_dec(cMETHOPx(o)->op_u.op_meth_sv);
        cMETHOPx(o)->op_u.op_meth_sv = NULL;
#ifdef USE_ITHREADS
        if (o->op_targ) {
            pad_swipe(o->op_targ, 1);
            o->op_targ = 0;
        }
#endif
        break;
    case OP_CONST:
    case OP_HINTSEVAL:
	SvREFCNT_dec(cSVOPo->op_sv);
	cSVOPo->op_sv = NULL;
#ifdef USE_ITHREADS
	/** Bug #15654
	  Even if op_clear does a pad_free for the target of the op,
	  pad_free doesn't actually remove the sv that exists in the pad;
	  instead it lives on. This results in that it could be reused as 
	  a target later on when the pad was reallocated.
	**/
        if(o->op_targ) {
          pad_swipe(o->op_targ,1);
          o->op_targ = 0;
        }
#endif
	break;
    case OP_DUMP:
    case OP_GOTO:
    case OP_NEXT:
    case OP_LAST:
    case OP_REDO:
	if (o->op_flags & (OPf_SPECIAL|OPf_STACKED|OPf_KIDS))
	    break;
	/* FALLTHROUGH */
    case OP_TRANS:
    case OP_TRANSR:
	if (o->op_private & (OPpTRANS_FROM_UTF|OPpTRANS_TO_UTF)) {
	    assert(o->op_type == OP_TRANS || o->op_type == OP_TRANSR);
#ifdef USE_ITHREADS
	    if (cPADOPo->op_padix > 0) {
		pad_swipe(cPADOPo->op_padix, TRUE);
		cPADOPo->op_padix = 0;
	    }
#else
	    SvREFCNT_dec(cSVOPo->op_sv);
	    cSVOPo->op_sv = NULL;
#endif
	}
	else {
	    PerlMemShared_free(cPVOPo->op_pv);
	    cPVOPo->op_pv = NULL;
	}
	break;
    case OP_SUBST:
	op_free(cPMOPo->op_pmreplrootu.op_pmreplroot);
	goto clear_pmop;
    case OP_PUSHRE:
#ifdef USE_ITHREADS
        if (cPMOPo->op_pmreplrootu.op_pmtargetoff) {
	    pad_swipe(cPMOPo->op_pmreplrootu.op_pmtargetoff, TRUE);
	}
#else
	SvREFCNT_dec(MUTABLE_SV(cPMOPo->op_pmreplrootu.op_pmtargetgv));
#endif
	/* FALLTHROUGH */
    case OP_MATCH:
    case OP_QR:
    clear_pmop:
	if (!(cPMOPo->op_pmflags & PMf_CODELIST_PRIVATE))
	    op_free(cPMOPo->op_code_list);
	cPMOPo->op_code_list = NULL;
	forget_pmop(cPMOPo);
	cPMOPo->op_pmreplrootu.op_pmreplroot = NULL;
        /* we use the same protection as the "SAFE" version of the PM_ macros
         * here since sv_clean_all might release some PMOPs
         * after PL_regex_padav has been cleared
         * and the clearing of PL_regex_padav needs to
         * happen before sv_clean_all
         */
#ifdef USE_ITHREADS
	if(PL_regex_pad) {        /* We could be in destruction */
	    const IV offset = (cPMOPo)->op_pmoffset;
	    ReREFCNT_dec(PM_GETRE(cPMOPo));
	    PL_regex_pad[offset] = &PL_sv_undef;
            sv_catpvn_nomg(PL_regex_pad[0], (const char *)&offset,
			   sizeof(offset));
        }
#else
	ReREFCNT_dec(PM_GETRE(cPMOPo));
	PM_SETRE(cPMOPo, NULL);
#endif

	break;

    case OP_MULTIDEREF:
        {
            UNOP_AUX_item *items = cUNOP_AUXo->op_aux;
            UV actions = items->uv;
            bool last = 0;
            bool is_hash = FALSE;

            while (!last) {
                switch (actions & MDEREF_ACTION_MASK) {

                case MDEREF_reload:
                    actions = (++items)->uv;
                    continue;

                case MDEREF_HV_padhv_helem:
                    is_hash = TRUE;
                case MDEREF_AV_padav_aelem:
                    pad_free((++items)->pad_offset);
                    goto do_elem;

                case MDEREF_HV_gvhv_helem:
                    is_hash = TRUE;
                case MDEREF_AV_gvav_aelem:
#ifdef USE_ITHREADS
                    S_op_clear_gv(aTHX_ o, &((++items)->pad_offset));
#else
                    S_op_clear_gv(aTHX_ o, &((++items)->sv));
#endif
                    goto do_elem;

                case MDEREF_HV_gvsv_vivify_rv2hv_helem:
                    is_hash = TRUE;
                case MDEREF_AV_gvsv_vivify_rv2av_aelem:
#ifdef USE_ITHREADS
                    S_op_clear_gv(aTHX_ o, &((++items)->pad_offset));
#else
                    S_op_clear_gv(aTHX_ o, &((++items)->sv));
#endif
                    goto do_vivify_rv2xv_elem;

                case MDEREF_HV_padsv_vivify_rv2hv_helem:
                    is_hash = TRUE;
                case MDEREF_AV_padsv_vivify_rv2av_aelem:
                    pad_free((++items)->pad_offset);
                    goto do_vivify_rv2xv_elem;

                case MDEREF_HV_pop_rv2hv_helem:
                case MDEREF_HV_vivify_rv2hv_helem:
                    is_hash = TRUE;
                do_vivify_rv2xv_elem:
                case MDEREF_AV_pop_rv2av_aelem:
                case MDEREF_AV_vivify_rv2av_aelem:
                do_elem:
                    switch (actions & MDEREF_INDEX_MASK) {
                    case MDEREF_INDEX_none:
                        last = 1;
                        break;
                    case MDEREF_INDEX_const:
                        if (is_hash) {
#ifdef USE_ITHREADS
                            /* see RT #15654 */
                            pad_swipe((++items)->pad_offset, 1);
#else
                            SvREFCNT_dec((++items)->sv);
#endif
                        }
                        else
                            items++;
                        break;
                    case MDEREF_INDEX_padsv:
                        pad_free((++items)->pad_offset);
                        break;
                    case MDEREF_INDEX_gvsv:
#ifdef USE_ITHREADS
                        S_op_clear_gv(aTHX_ o, &((++items)->pad_offset));
#else
                        S_op_clear_gv(aTHX_ o, &((++items)->sv));
#endif
                        break;
                    }

                    if (actions & MDEREF_FLAG_last)
                        last = 1;
                    is_hash = FALSE;

                    break;

                default:
                    assert(0);
                    last = 1;
                    break;

                } /* switch */

                actions >>= MDEREF_SHIFT;
            } /* while */

            /* start of malloc is at op_aux[-1], where the length is
             * stored */
            PerlMemShared_free(cUNOP_AUXo->op_aux - 1);
        }
        break;
    }

    if (o->op_targ > 0) {
	pad_free(o->op_targ);
	o->op_targ = 0;
    }
}

STATIC void
S_cop_free(pTHX_ COP* cop)
{
    PERL_ARGS_ASSERT_COP_FREE;

    CopFILE_free(cop);
    if (! specialWARN(cop->cop_warnings))
	PerlMemShared_free(cop->cop_warnings);
    cophh_free(CopHINTHASH_get(cop));
    if (PL_curcop == cop)
       PL_curcop = NULL;
}

STATIC void
S_forget_pmop(pTHX_ PMOP *const o
	      )
{
    HV * const pmstash = PmopSTASH(o);

    PERL_ARGS_ASSERT_FORGET_PMOP;

    if (pmstash && !SvIS_FREED(pmstash) && SvMAGICAL(pmstash)) {
	MAGIC * const mg = mg_find((const SV *)pmstash, PERL_MAGIC_symtab);
	if (mg) {
	    PMOP **const array = (PMOP**) mg->mg_ptr;
	    U32 count = mg->mg_len / sizeof(PMOP**);
	    U32 i = count;

	    while (i--) {
		if (array[i] == o) {
		    /* Found it. Move the entry at the end to overwrite it.  */
		    array[i] = array[--count];
		    mg->mg_len = count * sizeof(PMOP**);
		    /* Could realloc smaller at this point always, but probably
		       not worth it. Probably worth free()ing if we're the
		       last.  */
		    if(!count) {
			Safefree(mg->mg_ptr);
			mg->mg_ptr = NULL;
		    }
		    break;
		}
	    }
	}
    }
    if (PL_curpm == o) 
	PL_curpm = NULL;
}

STATIC void
S_find_and_forget_pmops(pTHX_ OP *o)
{
    PERL_ARGS_ASSERT_FIND_AND_FORGET_PMOPS;

    if (o->op_flags & OPf_KIDS) {
        OP *kid = cUNOPo->op_first;
	while (kid) {
	    switch (kid->op_type) {
	    case OP_SUBST:
	    case OP_PUSHRE:
	    case OP_MATCH:
	    case OP_QR:
		forget_pmop((PMOP*)kid);
	    }
	    find_and_forget_pmops(kid);
	    kid = OpSIBLING(kid);
	}
    }
}

/*
=for apidoc Am|void|op_null|OP *o

Neutralizes an op when it is no longer needed, but is still linked to from
other ops.

=cut
*/

void
Perl_op_null(pTHX_ OP *o)
{
    dVAR;

    PERL_ARGS_ASSERT_OP_NULL;

    if (o->op_type == OP_NULL)
	return;
    op_clear(o);
    o->op_targ = o->op_type;
    OpTYPE_set(o, OP_NULL);
}

void
Perl_op_refcnt_lock(pTHX)
  PERL_TSA_ACQUIRE(PL_op_mutex)
{
#ifdef USE_ITHREADS
    dVAR;
#endif
    PERL_UNUSED_CONTEXT;
    OP_REFCNT_LOCK;
}

void
Perl_op_refcnt_unlock(pTHX)
  PERL_TSA_RELEASE(PL_op_mutex)
{
#ifdef USE_ITHREADS
    dVAR;
#endif
    PERL_UNUSED_CONTEXT;
    OP_REFCNT_UNLOCK;
}


/*
=for apidoc op_sibling_splice

A general function for editing the structure of an existing chain of
op_sibling nodes.  By analogy with the perl-level C<splice()> function, allows
you to delete zero or more sequential nodes, replacing them with zero or
more different nodes.  Performs the necessary op_first/op_last
housekeeping on the parent node and op_sibling manipulation on the
children.  The last deleted node will be marked as as the last node by
updating the op_sibling/op_sibparent or op_moresib field as appropriate.

Note that op_next is not manipulated, and nodes are not freed; that is the
responsibility of the caller.  It also won't create a new list op for an
empty list etc; use higher-level functions like op_append_elem() for that.

C<parent> is the parent node of the sibling chain. It may passed as C<NULL> if
the splicing doesn't affect the first or last op in the chain.

C<start> is the node preceding the first node to be spliced.  Node(s)
following it will be deleted, and ops will be inserted after it.  If it is
C<NULL>, the first node onwards is deleted, and nodes are inserted at the
beginning.

C<del_count> is the number of nodes to delete.  If zero, no nodes are deleted.
If -1 or greater than or equal to the number of remaining kids, all
remaining kids are deleted.

C<insert> is the first of a chain of nodes to be inserted in place of the nodes.
If C<NULL>, no nodes are inserted.

The head of the chain of deleted ops is returned, or C<NULL> if no ops were
deleted.

For example:

    action                    before      after         returns
    ------                    -----       -----         -------

                              P           P
    splice(P, A, 2, X-Y-Z)    |           |             B-C
                              A-B-C-D     A-X-Y-Z-D

                              P           P
    splice(P, NULL, 1, X-Y)   |           |             A
                              A-B-C-D     X-Y-B-C-D

                              P           P
    splice(P, NULL, 3, NULL)  |           |             A-B-C
                              A-B-C-D     D

                              P           P
    splice(P, B, 0, X-Y)      |           |             NULL
                              A-B-C-D     A-B-X-Y-C-D


For lower-level direct manipulation of C<op_sibparent> and C<op_moresib>,
see C<L</OpMORESIB_set>>, C<L</OpLASTSIB_set>>, C<L</OpMAYBESIB_set>>.

=cut
*/

OP *
Perl_op_sibling_splice(OP *parent, OP *start, int del_count, OP* insert)
{
    OP *first;
    OP *rest;
    OP *last_del = NULL;
    OP *last_ins = NULL;

    if (start)
        first = OpSIBLING(start);
    else if (!parent)
        goto no_parent;
    else
        first = cLISTOPx(parent)->op_first;

    assert(del_count >= -1);

    if (del_count && first) {
        last_del = first;
        while (--del_count && OpHAS_SIBLING(last_del))
            last_del = OpSIBLING(last_del);
        rest = OpSIBLING(last_del);
        OpLASTSIB_set(last_del, NULL);
    }
    else
        rest = first;

    if (insert) {
        last_ins = insert;
        while (OpHAS_SIBLING(last_ins))
            last_ins = OpSIBLING(last_ins);
        OpMAYBESIB_set(last_ins, rest, NULL);
    }
    else
        insert = rest;

    if (start) {
        OpMAYBESIB_set(start, insert, NULL);
    }
    else {
        if (!parent)
            goto no_parent;
        cLISTOPx(parent)->op_first = insert;
        if (insert)
            parent->op_flags |= OPf_KIDS;
        else
            parent->op_flags &= ~OPf_KIDS;
    }

    if (!rest) {
        /* update op_last etc */
        U32 type;
        OP *lastop;

        if (!parent)
            goto no_parent;

        /* ought to use OP_CLASS(parent) here, but that can't handle
         * ex-foo OP_NULL ops. Also note that XopENTRYCUSTOM() can't
         * either */
        type = parent->op_type;
        if (type == OP_CUSTOM) {
            dTHX;
            type = XopENTRYCUSTOM(parent, xop_class);
        }
        else {
            if (type == OP_NULL)
                type = parent->op_targ;
            type = PL_opargs[type] & OA_CLASS_MASK;
        }

        lastop = last_ins ? last_ins : start ? start : NULL;
        if (   type == OA_BINOP
            || type == OA_LISTOP
            || type == OA_PMOP
            || type == OA_LOOP
        )
            cLISTOPx(parent)->op_last = lastop;

        if (lastop)
            OpLASTSIB_set(lastop, parent);
    }
    return last_del ? first : NULL;

  no_parent:
    Perl_croak_nocontext("panic: op_sibling_splice(): NULL parent");
}


#ifdef PERL_OP_PARENT

/*
=for apidoc op_parent

Returns the parent OP of C<o>, if it has a parent. Returns C<NULL> otherwise.
This function is only available on perls built with C<-DPERL_OP_PARENT>.

=cut
*/

OP *
Perl_op_parent(OP *o)
{
    PERL_ARGS_ASSERT_OP_PARENT;
    while (OpHAS_SIBLING(o))
        o = OpSIBLING(o);
    return o->op_sibparent;
}

#endif


/* replace the sibling following start with a new UNOP, which becomes
 * the parent of the original sibling; e.g.
 *
 *  op_sibling_newUNOP(P, A, unop-args...)
 *
 *  P              P
 *  |      becomes |
 *  A-B-C          A-U-C
 *                   |
 *                   B
 *
 * where U is the new UNOP.
 *
 * parent and start args are the same as for op_sibling_splice();
 * type and flags args are as newUNOP().
 *
 * Returns the new UNOP.
 */

STATIC OP *
S_op_sibling_newUNOP(pTHX_ OP *parent, OP *start, I32 type, I32 flags)
{
    OP *kid, *newop;

    kid = op_sibling_splice(parent, start, 1, NULL);
    newop = newUNOP(type, flags, kid);
    op_sibling_splice(parent, start, 0, newop);
    return newop;
}


/* lowest-level newLOGOP-style function - just allocates and populates
 * the struct. Higher-level stuff should be done by S_new_logop() /
 * newLOGOP(). This function exists mainly to avoid op_first assignment
 * being spread throughout this file.
 */

STATIC LOGOP *
S_alloc_LOGOP(pTHX_ I32 type, OP *first, OP* other)
{
    dVAR;
    LOGOP *logop;
    OP *kid = first;
    NewOp(1101, logop, 1, LOGOP);
    OpTYPE_set(logop, type);
    logop->op_first = first;
    logop->op_other = other;
    logop->op_flags = OPf_KIDS;
    while (kid && OpHAS_SIBLING(kid))
        kid = OpSIBLING(kid);
    if (kid)
        OpLASTSIB_set(kid, (OP*)logop);
    return logop;
}


/* Contextualizers */

/*
=for apidoc Am|OP *|op_contextualize|OP *o|I32 context

Applies a syntactic context to an op tree representing an expression.
C<o> is the op tree, and C<context> must be C<G_SCALAR>, C<G_ARRAY>,
or C<G_VOID> to specify the context to apply.  The modified op tree
is returned.

=cut
*/

OP *
Perl_op_contextualize(pTHX_ OP *o, I32 context)
{
    PERL_ARGS_ASSERT_OP_CONTEXTUALIZE;
    switch (context) {
	case G_SCALAR: return scalar(o);
	case G_ARRAY:  return list(o);
	case G_VOID:   return scalarvoid(o);
	default:
	    Perl_croak(aTHX_ "panic: op_contextualize bad context %ld",
		       (long) context);
    }
}

/*

=for apidoc Am|OP*|op_linklist|OP *o
This function is the implementation of the L</LINKLIST> macro.  It should
not be called directly.

=cut
*/

OP *
Perl_op_linklist(pTHX_ OP *o)
{
    OP *first;

    PERL_ARGS_ASSERT_OP_LINKLIST;

    if (o->op_next)
	return o->op_next;

    /* establish postfix order */
    first = cUNOPo->op_first;
    if (first) {
        OP *kid;
	o->op_next = LINKLIST(first);
	kid = first;
	for (;;) {
            OP *sibl = OpSIBLING(kid);
            if (sibl) {
                kid->op_next = LINKLIST(sibl);
                kid = sibl;
	    } else {
		kid->op_next = o;
		break;
	    }
	}
    }
    else
	o->op_next = o;

    return o->op_next;
}

static OP *
S_scalarkids(pTHX_ OP *o)
{
    if (o && o->op_flags & OPf_KIDS) {
        OP *kid;
        for (kid = cLISTOPo->op_first; kid; kid = OpSIBLING(kid))
	    scalar(kid);
    }
    return o;
}

STATIC OP *
S_scalarboolean(pTHX_ OP *o)
{
    PERL_ARGS_ASSERT_SCALARBOOLEAN;

    if (o->op_type == OP_SASSIGN && cBINOPo->op_first->op_type == OP_CONST
     && !(cBINOPo->op_first->op_flags & OPf_SPECIAL)) {
	if (ckWARN(WARN_SYNTAX)) {
	    const line_t oldline = CopLINE(PL_curcop);

	    if (PL_parser && PL_parser->copline != NOLINE) {
		/* This ensures that warnings are reported at the first line
                   of the conditional, not the last.  */
		CopLINE_set(PL_curcop, PL_parser->copline);
            }
	    Perl_warner(aTHX_ packWARN(WARN_SYNTAX), "Found = in conditional, should be ==");
	    CopLINE_set(PL_curcop, oldline);
	}
    }
    return scalar(o);
}

static SV *
S_op_varname_subscript(pTHX_ const OP *o, int subscript_type)
{
    assert(o);
    assert(o->op_type == OP_PADAV || o->op_type == OP_RV2AV ||
	   o->op_type == OP_PADHV || o->op_type == OP_RV2HV);
    {
	const char funny  = o->op_type == OP_PADAV
			 || o->op_type == OP_RV2AV ? '@@' : '%';
	if (o->op_type == OP_RV2AV || o->op_type == OP_RV2HV) {
	    GV *gv;
	    if (cUNOPo->op_first->op_type != OP_GV
	     || !(gv = cGVOPx_gv(cUNOPo->op_first)))
		return NULL;
	    return varname(gv, funny, 0, NULL, 0, subscript_type);
	}
	return
	    varname(MUTABLE_GV(PL_compcv), funny, o->op_targ, NULL, 0, subscript_type);
    }
}

static SV *
S_op_varname(pTHX_ const OP *o)
{
    return S_op_varname_subscript(aTHX_ o, 1);
}

static void
S_op_pretty(pTHX_ const OP *o, SV **retsv, const char **retpv)
{ /* or not so pretty :-) */
    if (o->op_type == OP_CONST) {
	*retsv = cSVOPo_sv;
	if (SvPOK(*retsv)) {
	    SV *sv = *retsv;
	    *retsv = sv_newmortal();
	    pv_pretty(*retsv, SvPVX_const(sv), SvCUR(sv), 32, NULL, NULL,
		      PERL_PV_PRETTY_DUMP |PERL_PV_ESCAPE_UNI_DETECT);
	}
	else if (!SvOK(*retsv))
	    *retpv = "undef";
    }
    else *retpv = "...";
}

static void
S_scalar_slice_warning(pTHX_ const OP *o)
{
    OP *kid;
    const char lbrack =
	o->op_type == OP_HSLICE ? '{' : '[';
    const char rbrack =
	o->op_type == OP_HSLICE ? '}' : ']';
    SV *name;
    SV *keysv = NULL; /* just to silence compiler warnings */
    const char *key = NULL;

    if (!(o->op_private & OPpSLICEWARNING))
	return;
    if (PL_parser && PL_parser->error_count)
	/* This warning can be nonsensical when there is a syntax error. */
	return;

    kid = cLISTOPo->op_first;
    kid = OpSIBLING(kid); /* get past pushmark */
    /* weed out false positives: any ops that can return lists */
    switch (kid->op_type) {
    case OP_BACKTICK:
    case OP_GLOB:
    case OP_READLINE:
    case OP_MATCH:
    case OP_RV2AV:
    case OP_EACH:
    case OP_VALUES:
    case OP_KEYS:
    case OP_SPLIT:
    case OP_LIST:
    case OP_SORT:
    case OP_REVERSE:
    case OP_ENTERSUB:
    case OP_CALLER:
    case OP_LSTAT:
    case OP_STAT:
    case OP_READDIR:
    case OP_SYSTEM:
    case OP_TMS:
    case OP_LOCALTIME:
    case OP_GMTIME:
    case OP_ENTEREVAL:
	return;
    }

    /* Don't warn if we have a nulled list either. */
    if (kid->op_type == OP_NULL && kid->op_targ == OP_LIST)
        return;

    assert(OpSIBLING(kid));
    name = S_op_varname(aTHX_ OpSIBLING(kid));
    if (!name) /* XS module fiddling with the op tree */
	return;
    S_op_pretty(aTHX_ kid, &keysv, &key);
    assert(SvPOK(name));
    sv_chop(name,SvPVX(name)+1);
    if (key)
       /* diag_listed_as: Scalar value @@%s[%s] better written as $%s[%s] */
	Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
		   "Scalar value @@%"SVf"%c%s%c better written as $%"SVf
		   "%c%s%c",
		    SVfARG(name), lbrack, key, rbrack, SVfARG(name),
		    lbrack, key, rbrack);
    else
       /* diag_listed_as: Scalar value @@%s[%s] better written as $%s[%s] */
	Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
		   "Scalar value @@%"SVf"%c%"SVf"%c better written as $%"
		    SVf"%c%"SVf"%c",
		    SVfARG(name), lbrack, SVfARG(keysv), rbrack,
		    SVfARG(name), lbrack, SVfARG(keysv), rbrack);
}

OP *
Perl_scalar(pTHX_ OP *o)
{
    OP *kid;

    /* assumes no premature commitment */
    if (!o || (PL_parser && PL_parser->error_count)
	 || (o->op_flags & OPf_WANT)
	 || o->op_type == OP_RETURN)
    {
	return o;
    }

    o->op_flags = (o->op_flags & ~OPf_WANT) | OPf_WANT_SCALAR;

    switch (o->op_type) {
    case OP_REPEAT:
	scalar(cBINOPo->op_first);
	if (o->op_private & OPpREPEAT_DOLIST) {
	    kid = cLISTOPx(cUNOPo->op_first)->op_first;
	    assert(kid->op_type == OP_PUSHMARK);
	    if (OpHAS_SIBLING(kid) && !OpHAS_SIBLING(OpSIBLING(kid))) {
		op_null(cLISTOPx(cUNOPo->op_first)->op_first);
		o->op_private &=~ OPpREPEAT_DOLIST;
	    }
	}
	break;
    case OP_OR:
    case OP_AND:
    case OP_COND_EXPR:
	for (kid = OpSIBLING(cUNOPo->op_first); kid; kid = OpSIBLING(kid))
	    scalar(kid);
	break;
	/* FALLTHROUGH */
    case OP_SPLIT:
    case OP_MATCH:
    case OP_QR:
    case OP_SUBST:
    case OP_NULL:
    default:
	if (o->op_flags & OPf_KIDS) {
	    for (kid = cUNOPo->op_first; kid; kid = OpSIBLING(kid))
		scalar(kid);
	}
	break;
    case OP_LEAVE:
    case OP_LEAVETRY:
	kid = cLISTOPo->op_first;
	scalar(kid);
	kid = OpSIBLING(kid);
    do_kids:
	while (kid) {
	    OP *sib = OpSIBLING(kid);
	    if (sib && kid->op_type != OP_LEAVEWHEN
	     && (  OpHAS_SIBLING(sib) || sib->op_type != OP_NULL
		|| (  sib->op_targ != OP_NEXTSTATE
		   && sib->op_targ != OP_DBSTATE  )))
		scalarvoid(kid);
	    else
		scalar(kid);
	    kid = sib;
	}
	PL_curcop = &PL_compiling;
	break;
    case OP_SCOPE:
    case OP_LINESEQ:
    case OP_LIST:
	kid = cLISTOPo->op_first;
	goto do_kids;
    case OP_SORT:
	Perl_ck_warner(aTHX_ packWARN(WARN_VOID), "Useless use of sort in scalar context");
	break;
    case OP_KVHSLICE:
    case OP_KVASLICE:
    {
	/* Warn about scalar context */
	const char lbrack = o->op_type == OP_KVHSLICE ? '{' : '[';
	const char rbrack = o->op_type == OP_KVHSLICE ? '}' : ']';
	SV *name;
	SV *keysv;
	const char *key = NULL;

	/* This warning can be nonsensical when there is a syntax error. */
	if (PL_parser && PL_parser->error_count)
	    break;

	if (!ckWARN(WARN_SYNTAX)) break;

	kid = cLISTOPo->op_first;
	kid = OpSIBLING(kid); /* get past pushmark */
	assert(OpSIBLING(kid));
	name = S_op_varname(aTHX_ OpSIBLING(kid));
	if (!name) /* XS module fiddling with the op tree */
	    break;
	S_op_pretty(aTHX_ kid, &keysv, &key);
	assert(SvPOK(name));
	sv_chop(name,SvPVX(name)+1);
	if (key)
  /* diag_listed_as: %%s[%s] in scalar context better written as $%s[%s] */
	    Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
		       "%%%"SVf"%c%s%c in scalar context better written "
		       "as $%"SVf"%c%s%c",
			SVfARG(name), lbrack, key, rbrack, SVfARG(name),
			lbrack, key, rbrack);
	else
  /* diag_listed_as: %%s[%s] in scalar context better written as $%s[%s] */
	    Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
		       "%%%"SVf"%c%"SVf"%c in scalar context better "
		       "written as $%"SVf"%c%"SVf"%c",
			SVfARG(name), lbrack, SVfARG(keysv), rbrack,
			SVfARG(name), lbrack, SVfARG(keysv), rbrack);
    }
    }
    return o;
}

OP *
Perl_scalarvoid(pTHX_ OP *arg)
{
    dVAR;
    OP *kid;
    SV* sv;
    U8 want;
    SSize_t defer_stack_alloc = 0;
    SSize_t defer_ix = -1;
    OP **defer_stack = NULL;
    OP *o = arg;

    PERL_ARGS_ASSERT_SCALARVOID;

    do {
        SV *useless_sv = NULL;
        const char* useless = NULL;

        if (o->op_type == OP_NEXTSTATE
            || o->op_type == OP_DBSTATE
            || (o->op_type == OP_NULL && (o->op_targ == OP_NEXTSTATE
                                          || o->op_targ == OP_DBSTATE)))
            PL_curcop = (COP*)o;                /* for warning below */

        /* assumes no premature commitment */
        want = o->op_flags & OPf_WANT;
        if ((want && want != OPf_WANT_SCALAR)
            || (PL_parser && PL_parser->error_count)
            || o->op_type == OP_RETURN || o->op_type == OP_REQUIRE || o->op_type == OP_LEAVEWHEN)
        {
            continue;
        }

        if ((o->op_private & OPpTARGET_MY)
            && (PL_opargs[o->op_type] & OA_TARGLEX))/* OPp share the meaning */
        {
            /* newASSIGNOP has already applied scalar context, which we
               leave, as if this op is inside SASSIGN.  */
            continue;
        }

        o->op_flags = (o->op_flags & ~OPf_WANT) | OPf_WANT_VOID;

        switch (o->op_type) {
        default:
            if (!(PL_opargs[o->op_type] & OA_FOLDCONST))
                break;
            /* FALLTHROUGH */
        case OP_REPEAT:
            if (o->op_flags & OPf_STACKED)
                break;
            if (o->op_type == OP_REPEAT)
                scalar(cBINOPo->op_first);
            goto func_ops;
        case OP_SUBSTR:
            if (o->op_private == 4)
                break;
            /* FALLTHROUGH */
        case OP_WANTARRAY:
        case OP_GV:
        case OP_SMARTMATCH:
        case OP_AV2ARYLEN:
        case OP_REF:
        case OP_REFGEN:
        case OP_SREFGEN:
        case OP_DEFINED:
        case OP_HEX:
        case OP_OCT:
        case OP_LENGTH:
        case OP_VEC:
        case OP_INDEX:
        case OP_RINDEX:
        case OP_SPRINTF:
        case OP_KVASLICE:
        case OP_KVHSLICE:
        case OP_UNPACK:
        case OP_PACK:
        case OP_JOIN:
        case OP_LSLICE:
        case OP_ANONLIST:
        case OP_ANONHASH:
        case OP_SORT:
        case OP_REVERSE:
        case OP_RANGE:
        case OP_FLIP:
        case OP_FLOP:
        case OP_CALLER:
        case OP_FILENO:
        case OP_EOF:
        case OP_TELL:
        case OP_GETSOCKNAME:
        case OP_GETPEERNAME:
        case OP_READLINK:
        case OP_TELLDIR:
        case OP_GETPPID:
        case OP_GETPGRP:
        case OP_GETPRIORITY:
        case OP_TIME:
        case OP_TMS:
        case OP_LOCALTIME:
        case OP_GMTIME:
        case OP_GHBYNAME:
        case OP_GHBYADDR:
        case OP_GHOSTENT:
        case OP_GNBYNAME:
        case OP_GNBYADDR:
        case OP_GNETENT:
        case OP_GPBYNAME:
        case OP_GPBYNUMBER:
        case OP_GPROTOENT:
        case OP_GSBYNAME:
        case OP_GSBYPORT:
        case OP_GSERVENT:
        case OP_GPWNAM:
        case OP_GPWUID:
        case OP_GGRNAM:
        case OP_GGRGID:
        case OP_GETLOGIN:
        case OP_PROTOTYPE:
        case OP_RUNCV:
        func_ops:
            useless = OP_DESC(o);
            break;

        case OP_GVSV:
        case OP_PADSV:
        case OP_PADAV:
        case OP_PADHV:
        case OP_PADANY:
        case OP_AELEM:
        case OP_AELEMFAST:
        case OP_AELEMFAST_LEX:
        case OP_ASLICE:
        case OP_HELEM:
        case OP_HSLICE:
            if (!(o->op_private & (OPpLVAL_INTRO|OPpOUR_INTRO)))
                /* Otherwise it's "Useless use of grep iterator" */
                useless = OP_DESC(o);
            break;

        case OP_SPLIT:
            kid = cLISTOPo->op_first;
            if (kid && kid->op_type == OP_PUSHRE
                && !kid->op_targ
                && !(o->op_flags & OPf_STACKED)
#ifdef USE_ITHREADS
                && !((PMOP*)kid)->op_pmreplrootu.op_pmtargetoff
#else
                && !((PMOP*)kid)->op_pmreplrootu.op_pmtargetgv
#endif
                )
                useless = OP_DESC(o);
            break;

        case OP_NOT:
            kid = cUNOPo->op_first;
            if (kid->op_type != OP_MATCH && kid->op_type != OP_SUBST &&
                kid->op_type != OP_TRANS && kid->op_type != OP_TRANSR) {
                goto func_ops;
            }
            useless = "negative pattern binding (!~)";
            break;

        case OP_SUBST:
            if (cPMOPo->op_pmflags & PMf_NONDESTRUCT)
                useless = "non-destructive substitution (s///r)";
            break;

        case OP_TRANSR:
            useless = "non-destructive transliteration (tr///r)";
            break;

        case OP_RV2GV:
        case OP_RV2SV:
        case OP_RV2AV:
        case OP_RV2HV:
            if (!(o->op_private & (OPpLVAL_INTRO|OPpOUR_INTRO)) &&
                (!OpHAS_SIBLING(o) || OpSIBLING(o)->op_type != OP_READLINE))
                useless = "a variable";
            break;

        case OP_CONST:
            sv = cSVOPo_sv;
            if (cSVOPo->op_private & OPpCONST_STRICT)
                no_bareword_allowed(o);
            else {
                if (ckWARN(WARN_VOID)) {
                    NV nv;
                    /* don't warn on optimised away booleans, eg
                     * use constant Foo, 5; Foo || print; */
                    if (cSVOPo->op_private & OPpCONST_SHORTCIRCUIT)
                        useless = NULL;
                    /* the constants 0 and 1 are permitted as they are
                       conventionally used as dummies in constructs like
                       1 while some_condition_with_side_effects;  */
                    else if (SvNIOK(sv) && ((nv = SvNV(sv)) == 0.0 || nv == 1.0))
                        useless = NULL;
                    else if (SvPOK(sv)) {
                        SV * const dsv = newSVpvs("");
                        useless_sv
                            = Perl_newSVpvf(aTHX_
                                            "a constant (%s)",
                                            pv_pretty(dsv, SvPVX_const(sv),
                                                      SvCUR(sv), 32, NULL, NULL,
                                                      PERL_PV_PRETTY_DUMP
                                                      | PERL_PV_ESCAPE_NOCLEAR
                                                      | PERL_PV_ESCAPE_UNI_DETECT));
                        SvREFCNT_dec_NN(dsv);
                    }
                    else if (SvOK(sv)) {
                        useless_sv = Perl_newSVpvf(aTHX_ "a constant (%"SVf")", SVfARG(sv));
                    }
                    else
                        useless = "a constant (undef)";
                }
            }
            op_null(o);         /* don't execute or even remember it */
            break;

        case OP_POSTINC:
            OpTYPE_set(o, OP_PREINC);  /* pre-increment is faster */
            break;

        case OP_POSTDEC:
            OpTYPE_set(o, OP_PREDEC);  /* pre-decrement is faster */
            break;

        case OP_I_POSTINC:
            OpTYPE_set(o, OP_I_PREINC);        /* pre-increment is faster */
            break;

        case OP_I_POSTDEC:
            OpTYPE_set(o, OP_I_PREDEC);        /* pre-decrement is faster */
            break;

        case OP_SASSIGN: {
            OP *rv2gv;
            UNOP *refgen, *rv2cv;
            LISTOP *exlist;

            if ((o->op_private & ~OPpASSIGN_BACKWARDS) != 2)
                break;

            rv2gv = ((BINOP *)o)->op_last;
            if (!rv2gv || rv2gv->op_type != OP_RV2GV)
                break;

            refgen = (UNOP *)((BINOP *)o)->op_first;

            if (!refgen || (refgen->op_type != OP_REFGEN
                            && refgen->op_type != OP_SREFGEN))
                break;

            exlist = (LISTOP *)refgen->op_first;
            if (!exlist || exlist->op_type != OP_NULL
                || exlist->op_targ != OP_LIST)
                break;

            if (exlist->op_first->op_type != OP_PUSHMARK
                && exlist->op_first != exlist->op_last)
                break;

            rv2cv = (UNOP*)exlist->op_last;

            if (rv2cv->op_type != OP_RV2CV)
                break;

            assert ((rv2gv->op_private & OPpDONT_INIT_GV) == 0);
            assert ((o->op_private & OPpASSIGN_CV_TO_GV) == 0);
            assert ((rv2cv->op_private & OPpMAY_RETURN_CONSTANT) == 0);

            o->op_private |= OPpASSIGN_CV_TO_GV;
            rv2gv->op_private |= OPpDONT_INIT_GV;
            rv2cv->op_private |= OPpMAY_RETURN_CONSTANT;

            break;
        }

        case OP_AASSIGN: {
            inplace_aassign(o);
            break;
        }

        case OP_OR:
        case OP_AND:
            kid = cLOGOPo->op_first;
            if (kid->op_type == OP_NOT
                && (kid->op_flags & OPf_KIDS)) {
                if (o->op_type == OP_AND) {
                    OpTYPE_set(o, OP_OR);
                } else {
                    OpTYPE_set(o, OP_AND);
                }
                op_null(kid);
            }
            /* FALLTHROUGH */

        case OP_DOR:
        case OP_COND_EXPR:
        case OP_ENTERGIVEN:
        case OP_ENTERWHEN:
            for (kid = OpSIBLING(cUNOPo->op_first); kid; kid = OpSIBLING(kid))
                if (!(kid->op_flags & OPf_KIDS))
                    scalarvoid(kid);
                else
                    DEFER_OP(kid);
        break;

        case OP_NULL:
            if (o->op_flags & OPf_STACKED)
                break;
            /* FALLTHROUGH */
        case OP_NEXTSTATE:
        case OP_DBSTATE:
        case OP_ENTERTRY:
        case OP_ENTER:
            if (!(o->op_flags & OPf_KIDS))
                break;
            /* FALLTHROUGH */
        case OP_SCOPE:
        case OP_LEAVE:
        case OP_LEAVETRY:
        case OP_LEAVELOOP:
        case OP_LINESEQ:
        case OP_LEAVEGIVEN:
        case OP_LEAVEWHEN:
        kids:
            for (kid = cLISTOPo->op_first; kid; kid = OpSIBLING(kid))
                if (!(kid->op_flags & OPf_KIDS))
                    scalarvoid(kid);
                else
                    DEFER_OP(kid);
            break;
        case OP_LIST:
            /* If the first kid after pushmark is something that the padrange
               optimisation would reject, then null the list and the pushmark.
            */
            if ((kid = cLISTOPo->op_first)->op_type == OP_PUSHMARK
                && (  !(kid = OpSIBLING(kid))
                      || (  kid->op_type != OP_PADSV
                            && kid->op_type != OP_PADAV
                            && kid->op_type != OP_PADHV)
                      || kid->op_private & ~OPpLVAL_INTRO
                      || !(kid = OpSIBLING(kid))
                      || (  kid->op_type != OP_PADSV
                            && kid->op_type != OP_PADAV
                            && kid->op_type != OP_PADHV)
                      || kid->op_private & ~OPpLVAL_INTRO)
            ) {
                op_null(cUNOPo->op_first); /* NULL the pushmark */
                op_null(o); /* NULL the list */
            }
            goto kids;
        case OP_ENTEREVAL:
            scalarkids(o);
            break;
        case OP_SCALAR:
            scalar(o);
            break;
        }

        if (useless_sv) {
            /* mortalise it, in case warnings are fatal.  */
            Perl_ck_warner(aTHX_ packWARN(WARN_VOID),
                           "Useless use of %"SVf" in void context",
                           SVfARG(sv_2mortal(useless_sv)));
        }
        else if (useless) {
            Perl_ck_warner(aTHX_ packWARN(WARN_VOID),
                           "Useless use of %s in void context",
                           useless);
        }
    } while ( (o = POP_DEFERRED_OP()) );

    Safefree(defer_stack);

    return arg;
}

static OP *
S_listkids(pTHX_ OP *o)
{
    if (o && o->op_flags & OPf_KIDS) {
        OP *kid;
	for (kid = cLISTOPo->op_first; kid; kid = OpSIBLING(kid))
	    list(kid);
    }
    return o;
}

OP *
Perl_list(pTHX_ OP *o)
{
    OP *kid;

    /* assumes no premature commitment */
    if (!o || (o->op_flags & OPf_WANT)
	 || (PL_parser && PL_parser->error_count)
	 || o->op_type == OP_RETURN)
    {
	return o;
    }

    if ((o->op_private & OPpTARGET_MY)
	&& (PL_opargs[o->op_type] & OA_TARGLEX))/* OPp share the meaning */
    {
	return o;				/* As if inside SASSIGN */
    }

    o->op_flags = (o->op_flags & ~OPf_WANT) | OPf_WANT_LIST;

    switch (o->op_type) {
    case OP_FLOP:
	list(cBINOPo->op_first);
	break;
    case OP_REPEAT:
	if (o->op_private & OPpREPEAT_DOLIST
	 && !(o->op_flags & OPf_STACKED))
	{
	    list(cBINOPo->op_first);
	    kid = cBINOPo->op_last;
	    if (kid->op_type == OP_CONST && SvIOK(kSVOP_sv)
	     && SvIVX(kSVOP_sv) == 1)
	    {
		op_null(o); /* repeat */
		op_null(cUNOPx(cBINOPo->op_first)->op_first);/* pushmark */
		/* const (rhs): */
		op_free(op_sibling_splice(o, cBINOPo->op_first, 1, NULL));
	    }
	}
	break;
    case OP_OR:
    case OP_AND:
    case OP_COND_EXPR:
	for (kid = OpSIBLING(cUNOPo->op_first); kid; kid = OpSIBLING(kid))
	    list(kid);
	break;
    default:
    case OP_MATCH:
    case OP_QR:
    case OP_SUBST:
    case OP_NULL:
	if (!(o->op_flags & OPf_KIDS))
	    break;
	if (!o->op_next && cUNOPo->op_first->op_type == OP_FLOP) {
	    list(cBINOPo->op_first);
	    return gen_constant_list(o);
	}
	listkids(o);
	break;
    case OP_LIST:
	listkids(o);
	if (cLISTOPo->op_first->op_type == OP_PUSHMARK) {
	    op_null(cUNOPo->op_first); /* NULL the pushmark */
	    op_null(o); /* NULL the list */
	}
	break;
    case OP_LEAVE:
    case OP_LEAVETRY:
	kid = cLISTOPo->op_first;
	list(kid);
	kid = OpSIBLING(kid);
    do_kids:
	while (kid) {
	    OP *sib = OpSIBLING(kid);
	    if (sib && kid->op_type != OP_LEAVEWHEN)
		scalarvoid(kid);
	    else
		list(kid);
	    kid = sib;
	}
	PL_curcop = &PL_compiling;
	break;
    case OP_SCOPE:
    case OP_LINESEQ:
	kid = cLISTOPo->op_first;
	goto do_kids;
    }
    return o;
}

static OP *
S_scalarseq(pTHX_ OP *o)
{
    if (o) {
	const OPCODE type = o->op_type;

	if (type == OP_LINESEQ || type == OP_SCOPE ||
	    type == OP_LEAVE || type == OP_LEAVETRY)
	{
     	    OP *kid, *sib;
	    for (kid = cLISTOPo->op_first; kid; kid = sib) {
		if ((sib = OpSIBLING(kid))
		 && (  OpHAS_SIBLING(sib) || sib->op_type != OP_NULL
		    || (  sib->op_targ != OP_NEXTSTATE
		       && sib->op_targ != OP_DBSTATE  )))
		{
		    scalarvoid(kid);
		}
	    }
	    PL_curcop = &PL_compiling;
	}
	o->op_flags &= ~OPf_PARENS;
	if (PL_hints & HINT_BLOCK_SCOPE)
	    o->op_flags |= OPf_PARENS;
    }
    else
	o = newOP(OP_STUB, 0);
    return o;
}

STATIC OP *
S_modkids(pTHX_ OP *o, I32 type)
{
    if (o && o->op_flags & OPf_KIDS) {
        OP *kid;
        for (kid = cLISTOPo->op_first; kid; kid = OpSIBLING(kid))
	    op_lvalue(kid, type);
    }
    return o;
}


/* for a helem/hslice/kvslice, if its a fixed hash, croak on invalid
 * const fields. Also, convert CONST keys to HEK-in-SVs.
 * rop is the op that retrieves the hash;
 * key_op is the first key
 */

STATIC void
S_check_hash_fields_and_hekify(pTHX_ UNOP *rop, SVOP *key_op)
{
    PADNAME *lexname;
    GV **fields;
    bool check_fields;

    /* find the padsv corresponding to $lex->{} or @@{$lex}{} */
    if (rop) {
        if (rop->op_first->op_type == OP_PADSV)
            /* @@$hash{qw(keys here)} */
            rop = (UNOP*)rop->op_first;
        else {
            /* @@{$hash}{qw(keys here)} */
            if (rop->op_first->op_type == OP_SCOPE
                && cLISTOPx(rop->op_first)->op_last->op_type == OP_PADSV)
                {
                    rop = (UNOP*)cLISTOPx(rop->op_first)->op_last;
                }
            else
                rop = NULL;
        }
    }

    lexname = NULL; /* just to silence compiler warnings */
    fields  = NULL; /* just to silence compiler warnings */

    check_fields =
            rop
         && (lexname = padnamelist_fetch(PL_comppad_name, rop->op_targ),
             SvPAD_TYPED(lexname))
         && (fields = (GV**)hv_fetchs(PadnameTYPE(lexname), "FIELDS", FALSE))
         && isGV(*fields) && GvHV(*fields);

    for (; key_op; key_op = (SVOP*)OpSIBLING(key_op)) {
        SV **svp, *sv;
        if (key_op->op_type != OP_CONST)
            continue;
        svp = cSVOPx_svp(key_op);

        /* make sure it's not a bareword under strict subs */
        if (key_op->op_private & OPpCONST_BARE &&
            key_op->op_private & OPpCONST_STRICT)
        {
            no_bareword_allowed((OP*)key_op);
        }

        /* Make the CONST have a shared SV */
        if (   !SvIsCOW_shared_hash(sv = *svp)
            && SvTYPE(sv) < SVt_PVMG
            && SvOK(sv)
            && !SvROK(sv))
        {
            SSize_t keylen;
            const char * const key = SvPV_const(sv, *(STRLEN*)&keylen);
            SV *nsv = newSVpvn_share(key, SvUTF8(sv) ? -keylen : keylen, 0);
            SvREFCNT_dec_NN(sv);
            *svp = nsv;
        }

        if (   check_fields
            && !hv_fetch_ent(GvHV(*fields), *svp, FALSE, 0))
        {
            Perl_croak(aTHX_ "No such class field \"%"SVf"\" "
                        "in variable %"PNf" of type %"HEKf,
                        SVfARG(*svp), PNfARG(lexname),
                        HEKfARG(HvNAME_HEK(PadnameTYPE(lexname))));
        }
    }
}


/*
=for apidoc finalize_optree

This function finalizes the optree.  Should be called directly after
the complete optree is built.  It does some additional
checking which can't be done in the normal C<ck_>xxx functions and makes
the tree thread-safe.

=cut
*/
void
Perl_finalize_optree(pTHX_ OP* o)
{
    PERL_ARGS_ASSERT_FINALIZE_OPTREE;

    ENTER;
    SAVEVPTR(PL_curcop);

    finalize_op(o);

    LEAVE;
}

#ifdef USE_ITHREADS
/* Relocate sv to the pad for thread safety.
 * Despite being a "constant", the SV is written to,
 * for reference counts, sv_upgrade() etc. */
PERL_STATIC_INLINE void
S_op_relocate_sv(pTHX_ SV** svp, PADOFFSET* targp)
{
    PADOFFSET ix;
    PERL_ARGS_ASSERT_OP_RELOCATE_SV;
    if (!*svp) return;
    ix = pad_alloc(OP_CONST, SVf_READONLY);
    SvREFCNT_dec(PAD_SVl(ix));
    PAD_SETSV(ix, *svp);
    /* XXX I don't know how this isn't readonly already. */
    if (!SvIsCOW(PAD_SVl(ix))) SvREADONLY_on(PAD_SVl(ix));
    *svp = NULL;
    *targp = ix;
}
#endif


STATIC void
S_finalize_op(pTHX_ OP* o)
{
    PERL_ARGS_ASSERT_FINALIZE_OP;


    switch (o->op_type) {
    case OP_NEXTSTATE:
    case OP_DBSTATE:
	PL_curcop = ((COP*)o);		/* for warnings */
	break;
    case OP_EXEC:
        if (OpHAS_SIBLING(o)) {
            OP *sib = OpSIBLING(o);
            if ((  sib->op_type == OP_NEXTSTATE || sib->op_type == OP_DBSTATE)
                && ckWARN(WARN_EXEC)
                && OpHAS_SIBLING(sib))
            {
		    const OPCODE type = OpSIBLING(sib)->op_type;
		    if (type != OP_EXIT && type != OP_WARN && type != OP_DIE) {
			const line_t oldline = CopLINE(PL_curcop);
			CopLINE_set(PL_curcop, CopLINE((COP*)sib));
			Perl_warner(aTHX_ packWARN(WARN_EXEC),
			    "Statement unlikely to be reached");
			Perl_warner(aTHX_ packWARN(WARN_EXEC),
			    "\t(Maybe you meant system() when you said exec()?)\n");
			CopLINE_set(PL_curcop, oldline);
		    }
	    }
        }
	break;

    case OP_GV:
	if ((o->op_private & OPpEARLY_CV) && ckWARN(WARN_PROTOTYPE)) {
	    GV * const gv = cGVOPo_gv;
	    if (SvTYPE(gv) == SVt_PVGV && GvCV(gv) && SvPVX_const(GvCV(gv))) {
		/* XXX could check prototype here instead of just carping */
		SV * const sv = sv_newmortal();
		gv_efullname3(sv, gv, NULL);
		Perl_warner(aTHX_ packWARN(WARN_PROTOTYPE),
		    "%"SVf"() called too early to check prototype",
		    SVfARG(sv));
	    }
	}
	break;

    case OP_CONST:
	if (cSVOPo->op_private & OPpCONST_STRICT)
	    no_bareword_allowed(o);
	/* FALLTHROUGH */
#ifdef USE_ITHREADS
    case OP_HINTSEVAL:
        op_relocate_sv(&cSVOPo->op_sv, &o->op_targ);
#endif
        break;

#ifdef USE_ITHREADS
    /* Relocate all the METHOP's SVs to the pad for thread safety. */
    case OP_METHOD_NAMED:
    case OP_METHOD_SUPER:
    case OP_METHOD_REDIR:
    case OP_METHOD_REDIR_SUPER:
        op_relocate_sv(&cMETHOPx(o)->op_u.op_meth_sv, &o->op_targ);
        break;
#endif

    case OP_HELEM: {
	UNOP *rop;
	SVOP *key_op;
	OP *kid;

	if ((key_op = cSVOPx(((BINOP*)o)->op_last))->op_type != OP_CONST)
	    break;

	rop = (UNOP*)((BINOP*)o)->op_first;

	goto check_keys;

    case OP_HSLICE:
	S_scalar_slice_warning(aTHX_ o);
        /* FALLTHROUGH */

    case OP_KVHSLICE:
        kid = OpSIBLING(cLISTOPo->op_first);
	if (/* I bet there's always a pushmark... */
	    OP_TYPE_ISNT_AND_WASNT_NN(kid, OP_LIST)
	    && OP_TYPE_ISNT_NN(kid, OP_CONST))
        {
	    break;
        }

	key_op = (SVOP*)(kid->op_type == OP_CONST
				? kid
				: OpSIBLING(kLISTOP->op_first));

	rop = (UNOP*)((LISTOP*)o)->op_last;

      check_keys:	
        if (o->op_private & OPpLVAL_INTRO || rop->op_type != OP_RV2HV)
            rop = NULL;
        S_check_hash_fields_and_hekify(aTHX_ rop, key_op);
	break;
    }
    case OP_ASLICE:
	S_scalar_slice_warning(aTHX_ o);
	break;

    case OP_SUBST: {
	if (cPMOPo->op_pmreplrootu.op_pmreplroot)
	    finalize_op(cPMOPo->op_pmreplrootu.op_pmreplroot);
	break;
    }
    default:
	break;
    }

    if (o->op_flags & OPf_KIDS) {
	OP *kid;

#ifdef DEBUGGING
        /* check that op_last points to the last sibling, and that
         * the last op_sibling/op_sibparent field points back to the
         * parent, and that the only ops with KIDS are those which are
         * entitled to them */
        U32 type = o->op_type;
        U32 family;
        bool has_last;

        if (type == OP_NULL) {
            type = o->op_targ;
            /* ck_glob creates a null UNOP with ex-type GLOB
             * (which is a list op. So pretend it wasn't a listop */
            if (type == OP_GLOB)
                type = OP_NULL;
        }
        family = PL_opargs[type] & OA_CLASS_MASK;

        has_last = (   family == OA_BINOP
                    || family == OA_LISTOP
                    || family == OA_PMOP
                    || family == OA_LOOP
                   );
        assert(  has_last /* has op_first and op_last, or ...
              ... has (or may have) op_first: */
              || family == OA_UNOP
              || family == OA_UNOP_AUX
              || family == OA_LOGOP
              || family == OA_BASEOP_OR_UNOP
              || family == OA_FILESTATOP
              || family == OA_LOOPEXOP
              || family == OA_METHOP
              /* I don't know why SASSIGN is tagged as OA_BASEOP - DAPM */
              || type == OP_SASSIGN
              || type == OP_CUSTOM
              || type == OP_NULL /* new_logop does this */
              );

        for (kid = cUNOPo->op_first; kid; kid = OpSIBLING(kid)) {
#  ifdef PERL_OP_PARENT
            if (!OpHAS_SIBLING(kid)) {
                if (has_last)
                    assert(kid == cLISTOPo->op_last);
                assert(kid->op_sibparent == o);
            }
#  else
            if (has_last && !OpHAS_SIBLING(kid))
                assert(kid == cLISTOPo->op_last);
#  endif
        }
#endif

	for (kid = cUNOPo->op_first; kid; kid = OpSIBLING(kid))
	    finalize_op(kid);
    }
}

/*
=for apidoc Amx|OP *|op_lvalue|OP *o|I32 type

Propagate lvalue ("modifiable") context to an op and its children.
C<type> represents the context type, roughly based on the type of op that
would do the modifying, although C<local()> is represented by C<OP_NULL>,
because it has no op type of its own (it is signalled by a flag on
the lvalue op).

This function detects things that can't be modified, such as C<$x+1>, and
generates errors for them.  For example, C<$x+1 = 2> would cause it to be
called with an op of type C<OP_ADD> and a C<type> argument of C<OP_SASSIGN>.

It also flags things that need to behave specially in an lvalue context,
such as C<$$x = 5> which might have to vivify a reference in C<$x>.

=cut
*/

static void
S_mark_padname_lvalue(pTHX_ PADNAME *pn)
{
    CV *cv = PL_compcv;
    PadnameLVALUE_on(pn);
    while (PadnameOUTER(pn) && PARENT_PAD_INDEX(pn)) {
	cv = CvOUTSIDE(cv);
        /* RT #127786: cv can be NULL due to an eval within the DB package
         * called from an anon sub - anon subs don't have CvOUTSIDE() set
         * unless they contain an eval, but calling eval within DB
         * pretends the eval was done in the caller's scope.
         */
	if (!cv)
            break;
	assert(CvPADLIST(cv));
	pn =
	   PadlistNAMESARRAY(CvPADLIST(cv))[PARENT_PAD_INDEX(pn)];
	assert(PadnameLEN(pn));
	PadnameLVALUE_on(pn);
    }
}

static bool
S_vivifies(const OPCODE type)
{
    switch(type) {
    case OP_RV2AV:     case   OP_ASLICE:
    case OP_RV2HV:     case OP_KVASLICE:
    case OP_RV2SV:     case   OP_HSLICE:
    case OP_AELEMFAST: case OP_KVHSLICE:
    case OP_HELEM:
    case OP_AELEM:
	return 1;
    }
    return 0;
}

static void
S_lvref(pTHX_ OP *o, I32 type)
{
    dVAR;
    OP *kid;
    switch (o->op_type) {
    case OP_COND_EXPR:
	for (kid = OpSIBLING(cUNOPo->op_first); kid;
	     kid = OpSIBLING(kid))
	    S_lvref(aTHX_ kid, type);
	/* FALLTHROUGH */
    case OP_PUSHMARK:
	return;
    case OP_RV2AV:
	if (cUNOPo->op_first->op_type != OP_GV) goto badref;
	o->op_flags |= OPf_STACKED;
	if (o->op_flags & OPf_PARENS) {
	    if (o->op_private & OPpLVAL_INTRO) {
		 yyerror(Perl_form(aTHX_ "Can't modify reference to "
		      "localized parenthesized array in list assignment"));
		return;
	    }
	  slurpy:
            OpTYPE_set(o, OP_LVAVREF);
	    o->op_private &= OPpLVAL_INTRO|OPpPAD_STATE;
	    o->op_flags |= OPf_MOD|OPf_REF;
	    return;
	}
	o->op_private |= OPpLVREF_AV;
	goto checkgv;
    case OP_RV2CV:
	kid = cUNOPo->op_first;
	if (kid->op_type == OP_NULL)
	    kid = cUNOPx(OpSIBLING(kUNOP->op_first))
		->op_first;
	o->op_private = OPpLVREF_CV;
	if (kid->op_type == OP_GV)
	    o->op_flags |= OPf_STACKED;
	else if (kid->op_type == OP_PADCV) {
	    o->op_targ = kid->op_targ;
	    kid->op_targ = 0;
	    op_free(cUNOPo->op_first);
	    cUNOPo->op_first = NULL;
	    o->op_flags &=~ OPf_KIDS;
	}
	else goto badref;
	break;
    case OP_RV2HV:
	if (o->op_flags & OPf_PARENS) {
	  parenhash:
	    yyerror(Perl_form(aTHX_ "Can't modify reference to "
				 "parenthesized hash in list assignment"));
		return;
	}
	o->op_private |= OPpLVREF_HV;
	/* FALLTHROUGH */
    case OP_RV2SV:
      checkgv:
	if (cUNOPo->op_first->op_type != OP_GV) goto badref;
	o->op_flags |= OPf_STACKED;
	break;
    case OP_PADHV:
	if (o->op_flags & OPf_PARENS) goto parenhash;
	o->op_private |= OPpLVREF_HV;
	/* FALLTHROUGH */
    case OP_PADSV:
	PAD_COMPNAME_GEN_set(o->op_targ, PERL_INT_MAX);
	break;
    case OP_PADAV:
	PAD_COMPNAME_GEN_set(o->op_targ, PERL_INT_MAX);
	if (o->op_flags & OPf_PARENS) goto slurpy;
	o->op_private |= OPpLVREF_AV;
	break;
    case OP_AELEM:
    case OP_HELEM:
	o->op_private |= OPpLVREF_ELEM;
	o->op_flags   |= OPf_STACKED;
	break;
    case OP_ASLICE:
    case OP_HSLICE:
        OpTYPE_set(o, OP_LVREFSLICE);
	o->op_private &= OPpLVAL_INTRO|OPpLVREF_ELEM;
	return;
    case OP_NULL:
	if (o->op_flags & OPf_SPECIAL)		/* do BLOCK */
	    goto badref;
	else if (!(o->op_flags & OPf_KIDS))
	    return;
	if (o->op_targ != OP_LIST) {
	    S_lvref(aTHX_ cBINOPo->op_first, type);
	    return;
	}
	/* FALLTHROUGH */
    case OP_LIST:
	for (kid = cLISTOPo->op_first; kid; kid = OpSIBLING(kid)) {
	    assert((kid->op_flags & OPf_WANT) != OPf_WANT_VOID);
	    S_lvref(aTHX_ kid, type);
	}
	return;
    case OP_STUB:
	if (o->op_flags & OPf_PARENS)
	    return;
	/* FALLTHROUGH */
    default:
      badref:
	/* diag_listed_as: Can't modify reference to %s in %s assignment */
	yyerror(Perl_form(aTHX_ "Can't modify reference to %s in %s",
		     o->op_type == OP_NULL && o->op_flags & OPf_SPECIAL
		      ? "do block"
		      : OP_DESC(o),
		     PL_op_desc[type]));
    }
    OpTYPE_set(o, OP_LVREF);
    o->op_private &=
	OPpLVAL_INTRO|OPpLVREF_ELEM|OPpLVREF_TYPE|OPpPAD_STATE;
    if (type == OP_ENTERLOOP)
	o->op_private |= OPpLVREF_ITER;
}

OP *
Perl_op_lvalue_flags(pTHX_ OP *o, I32 type, U32 flags)
{
    dVAR;
    OP *kid;
    /* -1 = error on localize, 0 = ignore localize, 1 = ok to localize */
    int localize = -1;

    if (!o || (PL_parser && PL_parser->error_count))
	return o;

    if ((o->op_private & OPpTARGET_MY)
	&& (PL_opargs[o->op_type] & OA_TARGLEX))/* OPp share the meaning */
    {
	return o;
    }

    assert( (o->op_flags & OPf_WANT) != OPf_WANT_VOID );

    if (type == OP_PRTF || type == OP_SPRINTF) type = OP_ENTERSUB;

    switch (o->op_type) {
    case OP_UNDEF:
	PL_modcount++;
	return o;
    case OP_STUB:
	if ((o->op_flags & OPf_PARENS))
	    break;
	goto nomod;
    case OP_ENTERSUB:
	if ((type == OP_UNDEF || type == OP_REFGEN || type == OP_LOCK) &&
	    !(o->op_flags & OPf_STACKED)) {
            OpTYPE_set(o, OP_RV2CV);		/* entersub => rv2cv */
	    assert(cUNOPo->op_first->op_type == OP_NULL);
	    op_null(((LISTOP*)cUNOPo->op_first)->op_first);/* disable pushmark */
	    break;
	}
	else {				/* lvalue subroutine call */
	    o->op_private |= OPpLVAL_INTRO;
	    PL_modcount = RETURN_UNLIMITED_NUMBER;
	    if (type == OP_GREPSTART || type == OP_ENTERSUB
	     || type == OP_REFGEN    || type == OP_LEAVESUBLV) {
		/* Potential lvalue context: */
		o->op_private |= OPpENTERSUB_INARGS;
		break;
	    }
	    else {                      /* Compile-time error message: */
		OP *kid = cUNOPo->op_first;
		CV *cv;
		GV *gv;
                SV *namesv;

		if (kid->op_type != OP_PUSHMARK) {
		    if (kid->op_type != OP_NULL || kid->op_targ != OP_LIST)
			Perl_croak(aTHX_
				"panic: unexpected lvalue entersub "
				"args: type/targ %ld:%"UVuf,
				(long)kid->op_type, (UV)kid->op_targ);
		    kid = kLISTOP->op_first;
		}
		while (OpHAS_SIBLING(kid))
		    kid = OpSIBLING(kid);
		if (!(kid->op_type == OP_NULL && kid->op_targ == OP_RV2CV)) {
		    break;	/* Postpone until runtime */
		}

		kid = kUNOP->op_first;
		if (kid->op_type == OP_NULL && kid->op_targ == OP_RV2SV)
		    kid = kUNOP->op_first;
		if (kid->op_type == OP_NULL)
		    Perl_croak(aTHX_
			       "Unexpected constant lvalue entersub "
			       "entry via type/targ %ld:%"UVuf,
			       (long)kid->op_type, (UV)kid->op_targ);
		if (kid->op_type != OP_GV) {
		    break;
		}

		gv = kGVOP_gv;
		cv = isGV(gv)
		    ? GvCV(gv)
		    : SvROK(gv) && SvTYPE(SvRV(gv)) == SVt_PVCV
			? MUTABLE_CV(SvRV(gv))
			: NULL;
		if (!cv)
		    break;
		if (CvLVALUE(cv))
		    break;
                if (flags & OP_LVALUE_NO_CROAK)
                    return NULL;

                namesv = cv_name(cv, NULL, 0);
                yyerror_pv(Perl_form(aTHX_ "Can't modify non-lvalue "
                                     "subroutine call of &%"SVf" in %s",
                                     SVfARG(namesv), PL_op_desc[type]),
                           SvUTF8(namesv));
                return o;
	    }
	}
	/* FALLTHROUGH */
    default:
      nomod:
	if (flags & OP_LVALUE_NO_CROAK) return NULL;
	/* grep, foreach, subcalls, refgen */
	if (type == OP_GREPSTART || type == OP_ENTERSUB
	 || type == OP_REFGEN    || type == OP_LEAVESUBLV)
	    break;
	yyerror(Perl_form(aTHX_ "Can't modify %s in %s",
		     (o->op_type == OP_NULL && (o->op_flags & OPf_SPECIAL)
		      ? "do block"
		      : OP_DESC(o)),
		     type ? PL_op_desc[type] : "local"));
	return o;

    case OP_PREINC:
    case OP_PREDEC:
    case OP_POW:
    case OP_MULTIPLY:
    case OP_DIVIDE:
    case OP_MODULO:
    case OP_ADD:
    case OP_SUBTRACT:
    case OP_CONCAT:
    case OP_LEFT_SHIFT:
    case OP_RIGHT_SHIFT:
    case OP_BIT_AND:
    case OP_BIT_XOR:
    case OP_BIT_OR:
    case OP_I_MULTIPLY:
    case OP_I_DIVIDE:
    case OP_I_MODULO:
    case OP_I_ADD:
    case OP_I_SUBTRACT:
	if (!(o->op_flags & OPf_STACKED))
	    goto nomod;
	PL_modcount++;
	break;

    case OP_REPEAT:
	if (o->op_flags & OPf_STACKED) {
	    PL_modcount++;
	    break;
	}
	if (!(o->op_private & OPpREPEAT_DOLIST))
	    goto nomod;
	else {
	    const I32 mods = PL_modcount;
	    modkids(cBINOPo->op_first, type);
	    if (type != OP_AASSIGN)
		goto nomod;
	    kid = cBINOPo->op_last;
	    if (kid->op_type == OP_CONST && SvIOK(kSVOP_sv)) {
		const IV iv = SvIV(kSVOP_sv);
		if (PL_modcount != RETURN_UNLIMITED_NUMBER)
		    PL_modcount =
			mods + (PL_modcount - mods) * (iv < 0 ? 0 : iv);
	    }
	    else
		PL_modcount = RETURN_UNLIMITED_NUMBER;
	}
	break;

    case OP_COND_EXPR:
	localize = 1;
	for (kid = OpSIBLING(cUNOPo->op_first); kid; kid = OpSIBLING(kid))
	    op_lvalue(kid, type);
	break;

    case OP_RV2AV:
    case OP_RV2HV:
	if (type == OP_REFGEN && o->op_flags & OPf_PARENS) {
           PL_modcount = RETURN_UNLIMITED_NUMBER;
	    return o;		/* Treat \(@@foo) like ordinary list. */
	}
	/* FALLTHROUGH */
    case OP_RV2GV:
	if (scalar_mod_type(o, type))
	    goto nomod;
	ref(cUNOPo->op_first, o->op_type);
	/* FALLTHROUGH */
    case OP_ASLICE:
    case OP_HSLICE:
	localize = 1;
	/* FALLTHROUGH */
    case OP_AASSIGN:
	/* Do not apply the lvsub flag for rv2[ah]v in scalar context.  */
	if (type == OP_LEAVESUBLV && (
		(o->op_type != OP_RV2AV && o->op_type != OP_RV2HV)
	     || (o->op_flags & OPf_WANT) != OPf_WANT_SCALAR
	   ))
	    o->op_private |= OPpMAYBE_LVSUB;
	/* FALLTHROUGH */
    case OP_NEXTSTATE:
    case OP_DBSTATE:
       PL_modcount = RETURN_UNLIMITED_NUMBER;
	break;
    case OP_KVHSLICE:
    case OP_KVASLICE:
	if (type == OP_LEAVESUBLV)
	    o->op_private |= OPpMAYBE_LVSUB;
        goto nomod;
    case OP_AV2ARYLEN:
	PL_hints |= HINT_BLOCK_SCOPE;
	if (type == OP_LEAVESUBLV)
	    o->op_private |= OPpMAYBE_LVSUB;
	PL_modcount++;
	break;
    case OP_RV2SV:
	ref(cUNOPo->op_first, o->op_type);
	localize = 1;
	/* FALLTHROUGH */
    case OP_GV:
	PL_hints |= HINT_BLOCK_SCOPE;
        /* FALLTHROUGH */
    case OP_SASSIGN:
    case OP_ANDASSIGN:
    case OP_ORASSIGN:
    case OP_DORASSIGN:
	PL_modcount++;
	break;

    case OP_AELEMFAST:
    case OP_AELEMFAST_LEX:
	localize = -1;
	PL_modcount++;
	break;

    case OP_PADAV:
    case OP_PADHV:
       PL_modcount = RETURN_UNLIMITED_NUMBER;
	if (type == OP_REFGEN && o->op_flags & OPf_PARENS)
	    return o;		/* Treat \(@@foo) like ordinary list. */
	if (scalar_mod_type(o, type))
	    goto nomod;
	if ((o->op_flags & OPf_WANT) != OPf_WANT_SCALAR
	  && type == OP_LEAVESUBLV)
	    o->op_private |= OPpMAYBE_LVSUB;
	/* FALLTHROUGH */
    case OP_PADSV:
	PL_modcount++;
	if (!type) /* local() */
	    Perl_croak(aTHX_ "Can't localize lexical variable %"PNf,
			      PNfARG(PAD_COMPNAME(o->op_targ)));
	if (!(o->op_private & OPpLVAL_INTRO)
	 || (  type != OP_SASSIGN && type != OP_AASSIGN
	    && PadnameIsSTATE(PAD_COMPNAME_SV(o->op_targ))  ))
	    S_mark_padname_lvalue(aTHX_ PAD_COMPNAME_SV(o->op_targ));
	break;

    case OP_PUSHMARK:
	localize = 0;
	break;

    case OP_KEYS:
	if (type != OP_SASSIGN && type != OP_LEAVESUBLV)
	    goto nomod;
	goto lvalue_func;
    case OP_SUBSTR:
	if (o->op_private == 4) /* don't allow 4 arg substr as lvalue */
	    goto nomod;
	/* FALLTHROUGH */
    case OP_POS:
    case OP_VEC:
      lvalue_func:
	if (type == OP_LEAVESUBLV)
	    o->op_private |= OPpMAYBE_LVSUB;
	if (o->op_flags & OPf_KIDS)
	    op_lvalue(OpSIBLING(cBINOPo->op_first), type);
	break;

    case OP_AELEM:
    case OP_HELEM:
	ref(cBINOPo->op_first, o->op_type);
	if (type == OP_ENTERSUB &&
	     !(o->op_private & (OPpLVAL_INTRO | OPpDEREF)))
	    o->op_private |= OPpLVAL_DEFER;
	if (type == OP_LEAVESUBLV)
	    o->op_private |= OPpMAYBE_LVSUB;
	localize = 1;
	PL_modcount++;
	break;

    case OP_LEAVE:
    case OP_LEAVELOOP:
	o->op_private |= OPpLVALUE;
        /* FALLTHROUGH */
    case OP_SCOPE:
    case OP_ENTER:
    case OP_LINESEQ:
	localize = 0;
	if (o->op_flags & OPf_KIDS)
	    op_lvalue(cLISTOPo->op_last, type);
	break;

    case OP_NULL:
	localize = 0;
	if (o->op_flags & OPf_SPECIAL)		/* do BLOCK */
	    goto nomod;
	else if (!(o->op_flags & OPf_KIDS))
	    break;
	if (o->op_targ != OP_LIST) {
	    op_lvalue(cBINOPo->op_first, type);
	    break;
	}
	/* FALLTHROUGH */
    case OP_LIST:
	localize = 0;
	for (kid = cLISTOPo->op_first; kid; kid = OpSIBLING(kid))
	    /* elements might be in void context because the list is
	       in scalar context or because they are attribute sub calls */
	    if ( (kid->op_flags & OPf_WANT) != OPf_WANT_VOID )
		op_lvalue(kid, type);
	break;

    case OP_COREARGS:
	return o;

    case OP_AND:
    case OP_OR:
	if (type == OP_LEAVESUBLV
	 || !S_vivifies(cLOGOPo->op_first->op_type))
	    op_lvalue(cLOGOPo->op_first, type);
	if (type == OP_LEAVESUBLV
	 || !S_vivifies(OpSIBLING(cLOGOPo->op_first)->op_type))
	    op_lvalue(OpSIBLING(cLOGOPo->op_first), type);
	goto nomod;

    case OP_SREFGEN:
	if (type != OP_AASSIGN && type != OP_SASSIGN
	 && type != OP_ENTERLOOP)
	    goto nomod;
	/* Don’t bother applying lvalue context to the ex-list.  */
	kid = cUNOPx(cUNOPo->op_first)->op_first;
	assert (!OpHAS_SIBLING(kid));
	goto kid_2lvref;
    case OP_REFGEN:
	if (type != OP_AASSIGN) goto nomod;
	kid = cUNOPo->op_first;
      kid_2lvref:
	{
	    const U8 ec = PL_parser ? PL_parser->error_count : 0;
	    S_lvref(aTHX_ kid, type);
	    if (!PL_parser || PL_parser->error_count == ec) {
		if (!FEATURE_REFALIASING_IS_ENABLED)
		    Perl_croak(aTHX_
		       "Experimental aliasing via reference not enabled");
		Perl_ck_warner_d(aTHX_
				 packWARN(WARN_EXPERIMENTAL__REFALIASING),
				"Aliasing via reference is experimental");
	    }
	}
	if (o->op_type == OP_REFGEN)
	    op_null(cUNOPx(cUNOPo->op_first)->op_first); /* pushmark */
	op_null(o);
	return o;

    case OP_SPLIT:
	kid = cLISTOPo->op_first;
	if (kid && kid->op_type == OP_PUSHRE &&
		(  kid->op_targ
		|| o->op_flags & OPf_STACKED
#ifdef USE_ITHREADS
		|| ((PMOP*)kid)->op_pmreplrootu.op_pmtargetoff
#else
		|| ((PMOP*)kid)->op_pmreplrootu.op_pmtargetgv
#endif
	)) {
	    /* This is actually @@array = split.  */
	    PL_modcount = RETURN_UNLIMITED_NUMBER;
	    break;
	}
	goto nomod;

    case OP_SCALAR:
	op_lvalue(cUNOPo->op_first, OP_ENTERSUB);
	goto nomod;
    }

    /* [20011101.069] File test operators interpret OPf_REF to mean that
       their argument is a filehandle; thus \stat(".") should not set
       it. AMS 20011102 */
    if (type == OP_REFGEN &&
        PL_check[o->op_type] == Perl_ck_ftst)
        return o;

    if (type != OP_LEAVESUBLV)
        o->op_flags |= OPf_MOD;

    if (type == OP_AASSIGN || type == OP_SASSIGN)
	o->op_flags |= OPf_SPECIAL|OPf_REF;
    else if (!type) { /* local() */
	switch (localize) {
	case 1:
	    o->op_private |= OPpLVAL_INTRO;
	    o->op_flags &= ~OPf_SPECIAL;
	    PL_hints |= HINT_BLOCK_SCOPE;
	    break;
	case 0:
	    break;
	case -1:
	    Perl_ck_warner(aTHX_ packWARN(WARN_SYNTAX),
			   "Useless localization of %s", OP_DESC(o));
	}
    }
    else if (type != OP_GREPSTART && type != OP_ENTERSUB
             && type != OP_LEAVESUBLV)
	o->op_flags |= OPf_REF;
    return o;
}

STATIC bool
S_scalar_mod_type(const OP *o, I32 type)
{
    switch (type) {
    case OP_POS:
    case OP_SASSIGN:
	if (o && o->op_type == OP_RV2GV)
	    return FALSE;
	/* FALLTHROUGH */
    case OP_PREINC:
    case OP_PREDEC:
    case OP_POSTINC:
    case OP_POSTDEC:
    case OP_I_PREINC:
    case OP_I_PREDEC:
    case OP_I_POSTINC:
    case OP_I_POSTDEC:
    case OP_POW:
    case OP_MULTIPLY:
    case OP_DIVIDE:
    case OP_MODULO:
    case OP_REPEAT:
    case OP_ADD:
    case OP_SUBTRACT:
    case OP_I_MULTIPLY:
    case OP_I_DIVIDE:
    case OP_I_MODULO:
    case OP_I_ADD:
    case OP_I_SUBTRACT:
    case OP_LEFT_SHIFT:
    case OP_RIGHT_SHIFT:
    case OP_BIT_AND:
    case OP_BIT_XOR:
    case OP_BIT_OR:
    case OP_CONCAT:
    case OP_SUBST:
    case OP_TRANS:
    case OP_TRANSR:
    case OP_READ:
    case OP_SYSREAD:
    case OP_RECV:
    case OP_ANDASSIGN:
    case OP_ORASSIGN:
    case OP_DORASSIGN:
	return TRUE;
    default:
	return FALSE;
    }
}

STATIC bool
S_is_handle_constructor(const OP *o, I32 numargs)
{
    PERL_ARGS_ASSERT_IS_HANDLE_CONSTRUCTOR;

    switch (o->op_type) {
    case OP_PIPE_OP:
    case OP_SOCKPAIR:
	if (numargs == 2)
	    return TRUE;
	/* FALLTHROUGH */
    case OP_SYSOPEN:
    case OP_OPEN:
    case OP_SELECT:		/* XXX c.f. SelectSaver.pm */
    case OP_SOCKET:
    case OP_OPEN_DIR:
    case OP_ACCEPT:
	if (numargs == 1)
	    return TRUE;
	/* FALLTHROUGH */
    default:
	return FALSE;
    }
}

static OP *
S_refkids(pTHX_ OP *o, I32 type)
{
    if (o && o->op_flags & OPf_KIDS) {
        OP *kid;
        for (kid = cLISTOPo->op_first; kid; kid = OpSIBLING(kid))
	    ref(kid, type);
    }
    return o;
}

OP *
Perl_doref(pTHX_ OP *o, I32 type, bool set_op_ref)
{
    dVAR;
    OP *kid;

    PERL_ARGS_ASSERT_DOREF;

    if (PL_parser && PL_parser->error_count)
	return o;

    switch (o->op_type) {
    case OP_ENTERSUB:
	if ((type == OP_EXISTS || type == OP_DEFINED) &&
	    !(o->op_flags & OPf_STACKED)) {
            OpTYPE_set(o, OP_RV2CV);             /* entersub => rv2cv */
	    assert(cUNOPo->op_first->op_type == OP_NULL);
	    op_null(((LISTOP*)cUNOPo->op_first)->op_first);	/* disable pushmark */
	    o->op_flags |= OPf_SPECIAL;
	}
	else if (type == OP_RV2SV || type == OP_RV2AV || type == OP_RV2HV){
	    o->op_private |= (type == OP_RV2AV ? OPpDEREF_AV
			      : type == OP_RV2HV ? OPpDEREF_HV
			      : OPpDEREF_SV);
	    o->op_flags |= OPf_MOD;
	}

	break;

    case OP_COND_EXPR:
	for (kid = OpSIBLING(cUNOPo->op_first); kid; kid = OpSIBLING(kid))
	    doref(kid, type, set_op_ref);
	break;
    case OP_RV2SV:
	if (type == OP_DEFINED)
	    o->op_flags |= OPf_SPECIAL;		/* don't create GV */
	doref(cUNOPo->op_first, o->op_type, set_op_ref);
	/* FALLTHROUGH */
    case OP_PADSV:
	if (type == OP_RV2SV || type == OP_RV2AV || type == OP_RV2HV) {
	    o->op_private |= (type == OP_RV2AV ? OPpDEREF_AV
			      : type == OP_RV2HV ? OPpDEREF_HV
			      : OPpDEREF_SV);
	    o->op_flags |= OPf_MOD;
	}
	break;

    case OP_RV2AV:
    case OP_RV2HV:
	if (set_op_ref)
	    o->op_flags |= OPf_REF;
	/* FALLTHROUGH */
    case OP_RV2GV:
	if (type == OP_DEFINED)
	    o->op_flags |= OPf_SPECIAL;		/* don't create GV */
	doref(cUNOPo->op_first, o->op_type, set_op_ref);
	break;

    case OP_PADAV:
    case OP_PADHV:
	if (set_op_ref)
	    o->op_flags |= OPf_REF;
	break;

    case OP_SCALAR:
    case OP_NULL:
	if (!(o->op_flags & OPf_KIDS) || type == OP_DEFINED)
	    break;
	doref(cBINOPo->op_first, type, set_op_ref);
	break;
    case OP_AELEM:
    case OP_HELEM:
	doref(cBINOPo->op_first, o->op_type, set_op_ref);
	if (type == OP_RV2SV || type == OP_RV2AV || type == OP_RV2HV) {
	    o->op_private |= (type == OP_RV2AV ? OPpDEREF_AV
			      : type == OP_RV2HV ? OPpDEREF_HV
			      : OPpDEREF_SV);
	    o->op_flags |= OPf_MOD;
	}
	break;

    case OP_SCOPE:
    case OP_LEAVE:
	set_op_ref = FALSE;
	/* FALLTHROUGH */
    case OP_ENTER:
    case OP_LIST:
	if (!(o->op_flags & OPf_KIDS))
	    break;
	doref(cLISTOPo->op_last, type, set_op_ref);
	break;
    default:
	break;
    }
    return scalar(o);

}

STATIC OP *
S_dup_attrlist(pTHX_ OP *o)
{
    OP *rop;

    PERL_ARGS_ASSERT_DUP_ATTRLIST;

    /* An attrlist is either a simple OP_CONST or an OP_LIST with kids,
     * where the first kid is OP_PUSHMARK and the remaining ones
     * are OP_CONST.  We need to push the OP_CONST values.
     */
    if (o->op_type == OP_CONST)
	rop = newSVOP(OP_CONST, o->op_flags, SvREFCNT_inc_NN(cSVOPo->op_sv));
    else {
	assert((o->op_type == OP_LIST) && (o->op_flags & OPf_KIDS));
	rop = NULL;
	for (o = cLISTOPo->op_first; o; o = OpSIBLING(o)) {
	    if (o->op_type == OP_CONST)
		rop = op_append_elem(OP_LIST, rop,
				  newSVOP(OP_CONST, o->op_flags,
					  SvREFCNT_inc_NN(cSVOPo->op_sv)));
	}
    }
    return rop;
}

STATIC void
S_apply_attrs(pTHX_ HV *stash, SV *target, OP *attrs)
{
    PERL_ARGS_ASSERT_APPLY_ATTRS;
    {
        SV * const stashsv = newSVhek(HvNAME_HEK(stash));

        /* fake up C<use attributes $pkg,$rv,@@attrs> */

#define ATTRSMODULE "attributes"
#define ATTRSMODULE_PM "attributes.pm"

        Perl_load_module(
          aTHX_ PERL_LOADMOD_IMPORT_OPS,
          newSVpvs(ATTRSMODULE),
          NULL,
          op_prepend_elem(OP_LIST,
                          newSVOP(OP_CONST, 0, stashsv),
                          op_prepend_elem(OP_LIST,
                                          newSVOP(OP_CONST, 0,
                                                  newRV(target)),
                                          dup_attrlist(attrs))));
    }
}

STATIC void
S_apply_attrs_my(pTHX_ HV *stash, OP *target, OP *attrs, OP **imopsp)
{
    OP *pack, *imop, *arg;
    SV *meth, *stashsv, **svp;

    PERL_ARGS_ASSERT_APPLY_ATTRS_MY;

    if (!attrs)
	return;

    assert(target->op_type == OP_PADSV ||
	   target->op_type == OP_PADHV ||
	   target->op_type == OP_PADAV);

    /* Ensure that attributes.pm is loaded. */
    /* Don't force the C<use> if we don't need it. */
    svp = hv_fetchs(GvHVn(PL_incgv), ATTRSMODULE_PM, FALSE);
    if (svp && *svp != &PL_sv_undef)
	NOOP;	/* already in %INC */
    else
	Perl_load_module(aTHX_ PERL_LOADMOD_NOIMPORT,
			       newSVpvs(ATTRSMODULE), NULL);

    /* Need package name for method call. */
    pack = newSVOP(OP_CONST, 0, newSVpvs(ATTRSMODULE));

    /* Build up the real arg-list. */
    stashsv = newSVhek(HvNAME_HEK(stash));

    arg = newOP(OP_PADSV, 0);
    arg->op_targ = target->op_targ;
    arg = op_prepend_elem(OP_LIST,
		       newSVOP(OP_CONST, 0, stashsv),
		       op_prepend_elem(OP_LIST,
				    newUNOP(OP_REFGEN, 0,
					    arg),
				    dup_attrlist(attrs)));

    /* Fake up a method call to import */
    meth = newSVpvs_share("import");
    imop = op_convert_list(OP_ENTERSUB, OPf_STACKED|OPf_SPECIAL|OPf_WANT_VOID,
		   op_append_elem(OP_LIST,
			       op_prepend_elem(OP_LIST, pack, arg),
			       newMETHOP_named(OP_METHOD_NAMED, 0, meth)));

    /* Combine the ops. */
    *imopsp = op_append_elem(OP_LIST, *imopsp, imop);
}

/*
=notfor apidoc apply_attrs_string

Attempts to apply a list of attributes specified by the C<attrstr> and
C<len> arguments to the subroutine identified by the C<cv> argument which
is expected to be associated with the package identified by the C<stashpv>
argument (see L<attributes>).  It gets this wrong, though, in that it
does not correctly identify the boundaries of the individual attribute
specifications within C<attrstr>.  This is not really intended for the
public API, but has to be listed here for systems such as AIX which
need an explicit export list for symbols.  (It's called from XS code
in support of the C<ATTRS:> keyword from F<xsubpp>.)  Patches to fix it
to respect attribute syntax properly would be welcome.

=cut
*/

void
Perl_apply_attrs_string(pTHX_ const char *stashpv, CV *cv,
                        const char *attrstr, STRLEN len)
{
    OP *attrs = NULL;

    PERL_ARGS_ASSERT_APPLY_ATTRS_STRING;

    if (!len) {
        len = strlen(attrstr);
    }

    while (len) {
        for (; isSPACE(*attrstr) && len; --len, ++attrstr) ;
        if (len) {
            const char * const sstr = attrstr;
            for (; !isSPACE(*attrstr) && len; --len, ++attrstr) ;
            attrs = op_append_elem(OP_LIST, attrs,
                                newSVOP(OP_CONST, 0,
                                        newSVpvn(sstr, attrstr-sstr)));
        }
    }

    Perl_load_module(aTHX_ PERL_LOADMOD_IMPORT_OPS,
		     newSVpvs(ATTRSMODULE),
                     NULL, op_prepend_elem(OP_LIST,
				  newSVOP(OP_CONST, 0, newSVpv(stashpv,0)),
				  op_prepend_elem(OP_LIST,
					       newSVOP(OP_CONST, 0,
						       newRV(MUTABLE_SV(cv))),
                                               attrs)));
}

STATIC void
S_move_proto_attr(pTHX_ OP **proto, OP **attrs, const GV * name)
{
    OP *new_proto = NULL;
    STRLEN pvlen;
    char *pv;
    OP *o;

    PERL_ARGS_ASSERT_MOVE_PROTO_ATTR;

    if (!*attrs)
        return;

    o = *attrs;
    if (o->op_type == OP_CONST) {
        pv = SvPV(cSVOPo_sv, pvlen);
        if (pvlen >= 10 && memEQ(pv, "prototype(", 10)) {
            SV * const tmpsv = newSVpvn_flags(pv + 10, pvlen - 11, SvUTF8(cSVOPo_sv));
            SV ** const tmpo = cSVOPx_svp(o);
            SvREFCNT_dec(cSVOPo_sv);
            *tmpo = tmpsv;
            new_proto = o;
            *attrs = NULL;
        }
    } else if (o->op_type == OP_LIST) {
        OP * lasto;
        assert(o->op_flags & OPf_KIDS);
        lasto = cLISTOPo->op_first;
        assert(lasto->op_type == OP_PUSHMARK);
        for (o = OpSIBLING(lasto); o; o = OpSIBLING(o)) {
            if (o->op_type == OP_CONST) {
                pv = SvPV(cSVOPo_sv, pvlen);
                if (pvlen >= 10 && memEQ(pv, "prototype(", 10)) {
                    SV * const tmpsv = newSVpvn_flags(pv + 10, pvlen - 11, SvUTF8(cSVOPo_sv));
                    SV ** const tmpo = cSVOPx_svp(o);
                    SvREFCNT_dec(cSVOPo_sv);
                    *tmpo = tmpsv;
                    if (new_proto && ckWARN(WARN_MISC)) {
                        STRLEN new_len;
                        const char * newp = SvPV(cSVOPo_sv, new_len);
                        Perl_warner(aTHX_ packWARN(WARN_MISC),
                            "Attribute prototype(%"UTF8f") discards earlier prototype attribute in same sub",
                            UTF8fARG(SvUTF8(cSVOPo_sv), new_len, newp));
                        op_free(new_proto);
                    }
                    else if (new_proto)
                        op_free(new_proto);
                    new_proto = o;
                    /* excise new_proto from the list */
                    op_sibling_splice(*attrs, lasto, 1, NULL);
                    o = lasto;
                    continue;
                }
            }
            lasto = o;
        }
        /* If the list is now just the PUSHMARK, scrap the whole thing; otherwise attributes.xs
           would get pulled in with no real need */
        if (!OpHAS_SIBLING(cLISTOPx(*attrs)->op_first)) {
            op_free(*attrs);
            *attrs = NULL;
        }
    }

    if (new_proto) {
        SV *svname;
        if (isGV(name)) {
            svname = sv_newmortal();
            gv_efullname3(svname, name, NULL);
        }
        else if (SvPOK(name) && *SvPVX((SV *)name) == '&')
            svname = newSVpvn_flags(SvPVX((SV *)name)+1, SvCUR(name)-1, SvUTF8(name)|SVs_TEMP);
        else
            svname = (SV *)name;
        if (ckWARN(WARN_ILLEGALPROTO))
            (void)validate_proto(svname, cSVOPx_sv(new_proto), TRUE);
        if (*proto && ckWARN(WARN_PROTOTYPE)) {
            STRLEN old_len, new_len;
            const char * oldp = SvPV(cSVOPx_sv(*proto), old_len);
            const char * newp = SvPV(cSVOPx_sv(new_proto), new_len);

            Perl_warner(aTHX_ packWARN(WARN_PROTOTYPE),
                "Prototype '%"UTF8f"' overridden by attribute 'prototype(%"UTF8f")'"
                " in %"SVf,
                UTF8fARG(SvUTF8(cSVOPx_sv(*proto)), old_len, oldp),
                UTF8fARG(SvUTF8(cSVOPx_sv(new_proto)), new_len, newp),
                SVfARG(svname));
        }
        if (*proto)
            op_free(*proto);
        *proto = new_proto;
    }
}

static void
S_cant_declare(pTHX_ OP *o)
{
    if (o->op_type == OP_NULL
     && (o->op_flags & (OPf_SPECIAL|OPf_KIDS)) == OPf_KIDS)
        o = cUNOPo->op_first;
    yyerror(Perl_form(aTHX_ "Can't declare %s in \"%s\"",
                             o->op_type == OP_NULL
                               && o->op_flags & OPf_SPECIAL
                                 ? "do block"
                                 : OP_DESC(o),
                             PL_parser->in_my == KEY_our   ? "our"   :
                             PL_parser->in_my == KEY_state ? "state" :
                                                             "my"));
}

STATIC OP *
S_my_kid(pTHX_ OP *o, OP *attrs, OP **imopsp)
{
    I32 type;
    const bool stately = PL_parser && PL_parser->in_my == KEY_state;

    PERL_ARGS_ASSERT_MY_KID;

    if (!o || (PL_parser && PL_parser->error_count))
	return o;

    type = o->op_type;

    if (type == OP_LIST) {
        OP *kid;
        for (kid = cLISTOPo->op_first; kid; kid = OpSIBLING(kid))
	    my_kid(kid, attrs, imopsp);
	return o;
    } else if (type == OP_UNDEF || type == OP_STUB) {
	return o;
    } else if (type == OP_RV2SV ||	/* "our" declaration */
	       type == OP_RV2AV ||
	       type == OP_RV2HV) { /* XXX does this let anything illegal in? */
	if (cUNOPo->op_first->op_type != OP_GV) { /* MJD 20011224 */
	    S_cant_declare(aTHX_ o);
	} else if (attrs) {
	    GV * const gv = cGVOPx_gv(cUNOPo->op_first);
	    assert(PL_parser);
	    PL_parser->in_my = FALSE;
	    PL_parser->in_my_stash = NULL;
	    apply_attrs(GvSTASH(gv),
			(type == OP_RV2SV ? GvSV(gv) :
			 type == OP_RV2AV ? MUTABLE_SV(GvAV(gv)) :
			 type == OP_RV2HV ? MUTABLE_SV(GvHV(gv)) : MUTABLE_SV(gv)),
			attrs);
	}
	o->op_private |= OPpOUR_INTRO;
	return o;
    }
    else if (type != OP_PADSV &&
	     type != OP_PADAV &&
	     type != OP_PADHV &&
	     type != OP_PUSHMARK)
    {
	S_cant_declare(aTHX_ o);
	return o;
    }
    else if (attrs && type != OP_PUSHMARK) {
	HV *stash;

        assert(PL_parser);
	PL_parser->in_my = FALSE;
	PL_parser->in_my_stash = NULL;

	/* check for C<my Dog $spot> when deciding package */
	stash = PAD_COMPNAME_TYPE(o->op_targ);
	if (!stash)
	    stash = PL_curstash;
	apply_attrs_my(stash, o, attrs, imopsp);
    }
    o->op_flags |= OPf_MOD;
    o->op_private |= OPpLVAL_INTRO;
    if (stately)
	o->op_private |= OPpPAD_STATE;
    return o;
}

OP *
Perl_my_attrs(pTHX_ OP *o, OP *attrs)
{
    OP *rops;
    int maybe_scalar = 0;

    PERL_ARGS_ASSERT_MY_ATTRS;

/* [perl #17376]: this appears to be premature, and results in code such as
   C< our(%x); > executing in list mode rather than void mode */
#if 0
    if (o->op_flags & OPf_PARENS)
	list(o);
    else
	maybe_scalar = 1;
#else
    maybe_scalar = 1;
#endif
    if (attrs)
	SAVEFREEOP(attrs);
    rops = NULL;
    o = my_kid(o, attrs, &rops);
    if (rops) {
	if (maybe_scalar && o->op_type == OP_PADSV) {
	    o = scalar(op_append_list(OP_LIST, rops, o));
	    o->op_private |= OPpLVAL_INTRO;
	}
	else {
	    /* The listop in rops might have a pushmark at the beginning,
	       which will mess up list assignment. */
	    LISTOP * const lrops = (LISTOP *)rops; /* for brevity */
	    if (rops->op_type == OP_LIST && 
	        lrops->op_first && lrops->op_first->op_type == OP_PUSHMARK)
	    {
		OP * const pushmark = lrops->op_first;
                /* excise pushmark */
                op_sibling_splice(rops, NULL, 1, NULL);
		op_free(pushmark);
	    }
	    o = op_append_list(OP_LIST, o, rops);
	}
    }
    PL_parser->in_my = FALSE;
    PL_parser->in_my_stash = NULL;
    return o;
}

OP *
Perl_sawparens(pTHX_ OP *o)
{
    PERL_UNUSED_CONTEXT;
    if (o)
	o->op_flags |= OPf_PARENS;
    return o;
}

OP *
Perl_bind_match(pTHX_ I32 type, OP *left, OP *right)
{
    OP *o;
    bool ismatchop = 0;
    const OPCODE ltype = left->op_type;
    const OPCODE rtype = right->op_type;

    PERL_ARGS_ASSERT_BIND_MATCH;

    if ( (ltype == OP_RV2AV || ltype == OP_RV2HV || ltype == OP_PADAV
	  || ltype == OP_PADHV) && ckWARN(WARN_MISC))
    {
      const char * const desc
	  = PL_op_desc[(
		          rtype == OP_SUBST || rtype == OP_TRANS
		       || rtype == OP_TRANSR
		       )
		       ? (int)rtype : OP_MATCH];
      const bool isary = ltype == OP_RV2AV || ltype == OP_PADAV;
      SV * const name =
	S_op_varname(aTHX_ left);
      if (name)
	Perl_warner(aTHX_ packWARN(WARN_MISC),
             "Applying %s to %"SVf" will act on scalar(%"SVf")",
             desc, SVfARG(name), SVfARG(name));
      else {
	const char * const sample = (isary
	     ? "@@array" : "%hash");
	Perl_warner(aTHX_ packWARN(WARN_MISC),
             "Applying %s to %s will act on scalar(%s)",
             desc, sample, sample);
      }
    }

    if (rtype == OP_CONST &&
	cSVOPx(right)->op_private & OPpCONST_BARE &&
	cSVOPx(right)->op_private & OPpCONST_STRICT)
    {
	no_bareword_allowed(right);
    }

    /* !~ doesn't make sense with /r, so error on it for now */
    if (rtype == OP_SUBST && (cPMOPx(right)->op_pmflags & PMf_NONDESTRUCT) &&
	type == OP_NOT)
	/* diag_listed_as: Using !~ with %s doesn't make sense */
	yyerror("Using !~ with s///r doesn't make sense");
    if (rtype == OP_TRANSR && type == OP_NOT)
	/* diag_listed_as: Using !~ with %s doesn't make sense */
	yyerror("Using !~ with tr///r doesn't make sense");

    ismatchop = (rtype == OP_MATCH ||
		 rtype == OP_SUBST ||
		 rtype == OP_TRANS || rtype == OP_TRANSR)
	     && !(right->op_flags & OPf_SPECIAL);
    if (ismatchop && right->op_private & OPpTARGET_MY) {
	right->op_targ = 0;
	right->op_private &= ~OPpTARGET_MY;
    }
    if (!(right->op_flags & OPf_STACKED) && !right->op_targ && ismatchop) {
        if (left->op_type == OP_PADSV
         && !(left->op_private & OPpLVAL_INTRO))
        {
            right->op_targ = left->op_targ;
            op_free(left);
            o = right;
        }
        else {
            right->op_flags |= OPf_STACKED;
            if (rtype != OP_MATCH && rtype != OP_TRANSR &&
            ! (rtype == OP_TRANS &&
               right->op_private & OPpTRANS_IDENTICAL) &&
	    ! (rtype == OP_SUBST &&
	       (cPMOPx(right)->op_pmflags & PMf_NONDESTRUCT)))
		left = op_lvalue(left, rtype);
	    if (right->op_type == OP_TRANS || right->op_type == OP_TRANSR)
		o = newBINOP(OP_NULL, OPf_STACKED, scalar(left), right);
	    else
		o = op_prepend_elem(rtype, scalar(left), right);
	}
	if (type == OP_NOT)
	    return newUNOP(OP_NOT, 0, scalar(o));
	return o;
    }
    else
	return bind_match(type, left,
		pmruntime(newPMOP(OP_MATCH, 0), right, NULL, 0, 0));
}

OP *
Perl_invert(pTHX_ OP *o)
{
    if (!o)
	return NULL;
    return newUNOP(OP_NOT, OPf_SPECIAL, scalar(o));
}

/*
=for apidoc Amx|OP *|op_scope|OP *o

Wraps up an op tree with some additional ops so that at runtime a dynamic
scope will be created.  The original ops run in the new dynamic scope,
and then, provided that they exit normally, the scope will be unwound.
The additional ops used to create and unwind the dynamic scope will
normally be an C<enter>/C<leave> pair, but a C<scope> op may be used
instead if the ops are simple enough to not need the full dynamic scope
structure.

=cut
*/

OP *
Perl_op_scope(pTHX_ OP *o)
{
    dVAR;
    if (o) {
	if (o->op_flags & OPf_PARENS || PERLDB_NOOPT || TAINTING_get) {
	    o = op_prepend_elem(OP_LINESEQ, newOP(OP_ENTER, 0), o);
            OpTYPE_set(o, OP_LEAVE);
	}
	else if (o->op_type == OP_LINESEQ) {
	    OP *kid;
            OpTYPE_set(o, OP_SCOPE);
	    kid = ((LISTOP*)o)->op_first;
	    if (kid->op_type == OP_NEXTSTATE || kid->op_type == OP_DBSTATE) {
		op_null(kid);

		/* The following deals with things like 'do {1 for 1}' */
		kid = OpSIBLING(kid);
		if (kid &&
		    (kid->op_type == OP_NEXTSTATE || kid->op_type == OP_DBSTATE))
		    op_null(kid);
	    }
	}
	else
	    o = newLISTOP(OP_SCOPE, 0, o, NULL);
    }
    return o;
}

OP *
Perl_op_unscope(pTHX_ OP *o)
{
    if (o && o->op_type == OP_LINESEQ) {
	OP *kid = cLISTOPo->op_first;
	for(; kid; kid = OpSIBLING(kid))
	    if (kid->op_type == OP_NEXTSTATE || kid->op_type == OP_DBSTATE)
		op_null(kid);
    }
    return o;
}

/*
=for apidoc Am|int|block_start|int full

Handles compile-time scope entry.
Arranges for hints to be restored on block
exit and also handles pad sequence numbers to make lexical variables scope
right.  Returns a savestack index for use with C<block_end>.

=cut
*/

int
Perl_block_start(pTHX_ int full)
{
    const int retval = PL_savestack_ix;

    PL_compiling.cop_seq = PL_cop_seqmax;
    COP_SEQMAX_INC;
    pad_block_start(full);
    SAVEHINTS();
    PL_hints &= ~HINT_BLOCK_SCOPE;
    SAVECOMPILEWARNINGS();
    PL_compiling.cop_warnings = DUP_WARNINGS(PL_compiling.cop_warnings);
    SAVEI32(PL_compiling.cop_seq);
    PL_compiling.cop_seq = 0;

    CALL_BLOCK_HOOKS(bhk_start, full);

    return retval;
}

/*
=for apidoc Am|OP *|block_end|I32 floor|OP *seq

Handles compile-time scope exit.  C<floor>
is the savestack index returned by
C<block_start>, and C<seq> is the body of the block.  Returns the block,
possibly modified.

=cut
*/

OP*
Perl_block_end(pTHX_ I32 floor, OP *seq)
{
    const int needblockscope = PL_hints & HINT_BLOCK_SCOPE;
    OP* retval = scalarseq(seq);
    OP *o;

    /* XXX Is the null PL_parser check necessary here? */
    assert(PL_parser); /* Let’s find out under debugging builds.  */
    if (PL_parser && PL_parser->parsed_sub) {
	o = newSTATEOP(0, NULL, NULL);
	op_null(o);
	retval = op_append_elem(OP_LINESEQ, retval, o);
    }

    CALL_BLOCK_HOOKS(bhk_pre_end, &retval);

    LEAVE_SCOPE(floor);
    if (needblockscope)
	PL_hints |= HINT_BLOCK_SCOPE; /* propagate out */
    o = pad_leavemy();

    if (o) {
	/* pad_leavemy has created a sequence of introcv ops for all my
	   subs declared in the block.  We have to replicate that list with
	   clonecv ops, to deal with this situation:

	       sub {
		   my sub s1;
		   my sub s2;
		   sub s1 { state sub foo { \&s2 } }
	       }->()

	   Originally, I was going to have introcv clone the CV and turn
	   off the stale flag.  Since &s1 is declared before &s2, the
	   introcv op for &s1 is executed (on sub entry) before the one for
	   &s2.  But the &foo sub inside &s1 (which is cloned when &s1 is
	   cloned, since it is a state sub) closes over &s2 and expects
	   to see it in its outer CV’s pad.  If the introcv op clones &s1,
	   then &s2 is still marked stale.  Since &s1 is not active, and
	   &foo closes over &s1’s implicit entry for &s2, we get a ‘Varia-
	   ble will not stay shared’ warning.  Because it is the same stub
	   that will be used when the introcv op for &s2 is executed, clos-
	   ing over it is safe.  Hence, we have to turn off the stale flag
	   on all lexical subs in the block before we clone any of them.
	   Hence, having introcv clone the sub cannot work.  So we create a
	   list of ops like this:

	       lineseq
		  |
		  +-- introcv
		  |
		  +-- introcv
		  |
		  +-- introcv
		  |
		  .
		  .
		  .
		  |
		  +-- clonecv
		  |
		  +-- clonecv
		  |
		  +-- clonecv
		  |
		  .
		  .
		  .
	 */
	OP *kid = o->op_flags & OPf_KIDS ? cLISTOPo->op_first : o;
	OP * const last = o->op_flags & OPf_KIDS ? cLISTOPo->op_last : o;
	for (;; kid = OpSIBLING(kid)) {
	    OP *newkid = newOP(OP_CLONECV, 0);
	    newkid->op_targ = kid->op_targ;
	    o = op_append_elem(OP_LINESEQ, o, newkid);
	    if (kid == last) break;
	}
	retval = op_prepend_elem(OP_LINESEQ, o, retval);
    }

    CALL_BLOCK_HOOKS(bhk_post_end, &retval);

    return retval;
}

/*
=head1 Compile-time scope hooks

=for apidoc Aox||blockhook_register

Register a set of hooks to be called when the Perl lexical scope changes
at compile time.  See L<perlguts/"Compile-time scope hooks">.

=cut
*/

void
Perl_blockhook_register(pTHX_ BHK *hk)
{
    PERL_ARGS_ASSERT_BLOCKHOOK_REGISTER;

    Perl_av_create_and_push(aTHX_ &PL_blockhooks, newSViv(PTR2IV(hk)));
}

void
Perl_newPROG(pTHX_ OP *o)
{
    PERL_ARGS_ASSERT_NEWPROG;

    if (PL_in_eval) {
	PERL_CONTEXT *cx;
	I32 i;
	if (PL_eval_root)
		return;
	PL_eval_root = newUNOP(OP_LEAVEEVAL,
			       ((PL_in_eval & EVAL_KEEPERR)
				? OPf_SPECIAL : 0), o);

	cx = CX_CUR();
	assert(CxTYPE(cx) == CXt_EVAL);

	if ((cx->blk_gimme & G_WANT) == G_VOID)
	    scalarvoid(PL_eval_root);
	else if ((cx->blk_gimme & G_WANT) == G_ARRAY)
	    list(PL_eval_root);
	else
	    scalar(PL_eval_root);

	PL_eval_start = op_linklist(PL_eval_root);
	PL_eval_root->op_private |= OPpREFCOUNTED;
	OpREFCNT_set(PL_eval_root, 1);
	PL_eval_root->op_next = 0;
	i = PL_savestack_ix;
	SAVEFREEOP(o);
	ENTER;
	CALL_PEEP(PL_eval_start);
	finalize_optree(PL_eval_root);
        S_prune_chain_head(&PL_eval_start);
	LEAVE;
	PL_savestack_ix = i;
    }
    else {
	if (o->op_type == OP_STUB) {
            /* This block is entered if nothing is compiled for the main
               program. This will be the case for an genuinely empty main
               program, or one which only has BEGIN blocks etc, so already
               run and freed.

               Historically (5.000) the guard above was !o. However, commit
               f8a08f7b8bd67b28 (Jun 2001), integrated to blead as
               c71fccf11fde0068, changed perly.y so that newPROG() is now
               called with the output of block_end(), which returns a new
               OP_STUB for the case of an empty optree. ByteLoader (and
               maybe other things) also take this path, because they set up
               PL_main_start and PL_main_root directly, without generating an
               optree.

               If the parsing the main program aborts (due to parse errors,
               or due to BEGIN or similar calling exit), then newPROG()
               isn't even called, and hence this code path and its cleanups
               are skipped. This shouldn't make a make a difference:
               * a non-zero return from perl_parse is a failure, and
                 perl_destruct() should be called immediately.
               * however, if exit(0) is called during the parse, then
                 perl_parse() returns 0, and perl_run() is called. As
                 PL_main_start will be NULL, perl_run() will return
                 promptly, and the exit code will remain 0.
            */

	    PL_comppad_name = 0;
	    PL_compcv = 0;
	    S_op_destroy(aTHX_ o);
	    return;
	}
	PL_main_root = op_scope(sawparens(scalarvoid(o)));
	PL_curcop = &PL_compiling;
	PL_main_start = LINKLIST(PL_main_root);
	PL_main_root->op_private |= OPpREFCOUNTED;
	OpREFCNT_set(PL_main_root, 1);
	PL_main_root->op_next = 0;
	CALL_PEEP(PL_main_start);
	finalize_optree(PL_main_root);
        S_prune_chain_head(&PL_main_start);
	cv_forget_slab(PL_compcv);
	PL_compcv = 0;

	/* Register with debugger */
	if (PERLDB_INTER) {
	    CV * const cv = get_cvs("DB::postponed", 0);
	    if (cv) {
		dSP;
		PUSHMARK(SP);
		XPUSHs(MUTABLE_SV(CopFILEGV(&PL_compiling)));
		PUTBACK;
		call_sv(MUTABLE_SV(cv), G_DISCARD);
	    }
	}
    }
}

OP *
Perl_localize(pTHX_ OP *o, I32 lex)
{
    PERL_ARGS_ASSERT_LOCALIZE;

    if (o->op_flags & OPf_PARENS)
/* [perl #17376]: this appears to be premature, and results in code such as
   C< our(%x); > executing in list mode rather than void mode */
#if 0
	list(o);
#else
	NOOP;
#endif
    else {
	if ( PL_parser->bufptr > PL_parser->oldbufptr
	    && PL_parser->bufptr[-1] == ','
	    && ckWARN(WARN_PARENTHESIS))
	{
	    char *s = PL_parser->bufptr;
	    bool sigil = FALSE;

	    /* some heuristics to detect a potential error */
	    while (*s && (strchr(", \t\n", *s)))
		s++;

	    while (1) {
		if (*s && (strchr("@@$%", *s) || (!lex && *s == '*'))
		       && *++s
		       && (isWORDCHAR(*s) || UTF8_IS_CONTINUED(*s))) {
		    s++;
		    sigil = TRUE;
		    while (*s && (isWORDCHAR(*s) || UTF8_IS_CONTINUED(*s)))
			s++;
		    while (*s && (strchr(", \t\n", *s)))
			s++;
		}
		else
		    break;
	    }
	    if (sigil && (*s == ';' || *s == '=')) {
		Perl_warner(aTHX_ packWARN(WARN_PARENTHESIS),
				"Parentheses missing around \"%s\" list",
				lex
				    ? (PL_parser->in_my == KEY_our
					? "our"
					: PL_parser->in_my == KEY_state
					    ? "state"
					    : "my")
				    : "local");
	    }
	}
    }
    if (lex)
	o = my(o);
    else
	o = op_lvalue(o, OP_NULL);		/* a bit kludgey */
    PL_parser->in_my = FALSE;
    PL_parser->in_my_stash = NULL;
    return o;
}

OP *
Perl_jmaybe(pTHX_ OP *o)
{
    PERL_ARGS_ASSERT_JMAYBE;

    if (o->op_type == OP_LIST) {
	OP * const o2
	    = newSVREF(newGVOP(OP_GV, 0, gv_fetchpvs(";", GV_ADD|GV_NOTQUAL, SVt_PV)));
	o = op_convert_list(OP_JOIN, 0, op_prepend_elem(OP_LIST, o2, o));
    }
    return o;
}

PERL_STATIC_INLINE OP *
S_op_std_init(pTHX_ OP *o)
{
    I32 type = o->op_type;

    PERL_ARGS_ASSERT_OP_STD_INIT;

    if (PL_opargs[type] & OA_RETSCALAR)
	scalar(o);
    if (PL_opargs[type] & OA_TARGET && !o->op_targ)
	o->op_targ = pad_alloc(type, SVs_PADTMP);

    return o;
}

PERL_STATIC_INLINE OP *
S_op_integerize(pTHX_ OP *o)
{
    I32 type = o->op_type;

    PERL_ARGS_ASSERT_OP_INTEGERIZE;

    /* integerize op. */
    if ((PL_opargs[type] & OA_OTHERINT) && (PL_hints & HINT_INTEGER))
    {
	dVAR;
	o->op_ppaddr = PL_ppaddr[++(o->op_type)];
    }

    if (type == OP_NEGATE)
	/* XXX might want a ck_negate() for this */
	cUNOPo->op_first->op_private &= ~OPpCONST_STRICT;

    return o;
}

static OP *
S_fold_constants(pTHX_ OP *o)
{
    dVAR;
    OP * VOL curop;
    OP *newop;
    VOL I32 type = o->op_type;
    bool is_stringify;
    SV * VOL sv = NULL;
    int ret = 0;
    OP *old_next;
    SV * const oldwarnhook = PL_warnhook;
    SV * const olddiehook  = PL_diehook;
    COP not_compiling;
    U8 oldwarn = PL_dowarn;
    I32 old_cxix;
    dJMPENV;

    PERL_ARGS_ASSERT_FOLD_CONSTANTS;

    if (!(PL_opargs[type] & OA_FOLDCONST))
	goto nope;

    switch (type) {
    case OP_UCFIRST:
    case OP_LCFIRST:
    case OP_UC:
    case OP_LC:
    case OP_FC:
#ifdef USE_LOCALE_CTYPE
	if (IN_LC_COMPILETIME(LC_CTYPE))
	    goto nope;
#endif
        break;
    case OP_SLT:
    case OP_SGT:
    case OP_SLE:
    case OP_SGE:
    case OP_SCMP:
#ifdef USE_LOCALE_COLLATE
	if (IN_LC_COMPILETIME(LC_COLLATE))
	    goto nope;
#endif
        break;
    case OP_SPRINTF:
	/* XXX what about the numeric ops? */
#ifdef USE_LOCALE_NUMERIC
	if (IN_LC_COMPILETIME(LC_NUMERIC))
	    goto nope;
#endif
	break;
    case OP_PACK:
	if (!OpHAS_SIBLING(cLISTOPo->op_first)
	  || OpSIBLING(cLISTOPo->op_first)->op_type != OP_CONST)
	    goto nope;
	{
	    SV * const sv = cSVOPx_sv(OpSIBLING(cLISTOPo->op_first));
	    if (!SvPOK(sv) || SvGMAGICAL(sv)) goto nope;
	    {
		const char *s = SvPVX_const(sv);
		while (s < SvEND(sv)) {
		    if (isALPHA_FOLD_EQ(*s, 'p')) goto nope;
		    s++;
		}
	    }
	}
	break;
    case OP_REPEAT:
	if (o->op_private & OPpREPEAT_DOLIST) goto nope;
	break;
    case OP_SREFGEN:
	if (cUNOPx(cUNOPo->op_first)->op_first->op_type != OP_CONST
	 || SvPADTMP(cSVOPx_sv(cUNOPx(cUNOPo->op_first)->op_first)))
	    goto nope;
    }

    if (PL_parser && PL_parser->error_count)
	goto nope;		/* Don't try to run w/ errors */

    for (curop = LINKLIST(o); curop != o; curop = LINKLIST(curop)) {
	const OPCODE type = curop->op_type;
	if ((type != OP_CONST || (curop->op_private & OPpCONST_BARE)) &&
	    type != OP_LIST &&
	    type != OP_SCALAR &&
	    type != OP_NULL &&
	    type != OP_PUSHMARK)
	{
	    goto nope;
	}
    }

    curop = LINKLIST(o);
    old_next = o->op_next;
    o->op_next = 0;
    PL_op = curop;

    old_cxix = cxstack_ix;
    create_eval_scope(NULL, G_FAKINGEVAL);

    /* Verify that we don't need to save it:  */
    assert(PL_curcop == &PL_compiling);
    StructCopy(&PL_compiling, &not_compiling, COP);
    PL_curcop = &not_compiling;
    /* The above ensures that we run with all the correct hints of the
       currently compiling COP, but that IN_PERL_RUNTIME is true. */
    assert(IN_PERL_RUNTIME);
    PL_warnhook = PERL_WARNHOOK_FATAL;
    PL_diehook  = NULL;
    JMPENV_PUSH(ret);

    /* Effective $^W=1.  */
    if ( ! (PL_dowarn & G_WARN_ALL_MASK))
	PL_dowarn |= G_WARN_ON;

    switch (ret) {
    case 0:
	CALLRUNOPS(aTHX);
	sv = *(PL_stack_sp--);
	if (o->op_targ && sv == PAD_SV(o->op_targ)) {	/* grab pad temp? */
	    pad_swipe(o->op_targ,  FALSE);
	}
	else if (SvTEMP(sv)) {			/* grab mortal temp? */
	    SvREFCNT_inc_simple_void(sv);
	    SvTEMP_off(sv);
	}
	else { assert(SvIMMORTAL(sv)); }
	break;
    case 3:
	/* Something tried to die.  Abandon constant folding.  */
	/* Pretend the error never happened.  */
	CLEAR_ERRSV();
	o->op_next = old_next;
	break;
    default:
	JMPENV_POP;
	/* Don't expect 1 (setjmp failed) or 2 (something called my_exit)  */
	PL_warnhook = oldwarnhook;
	PL_diehook  = olddiehook;
	/* XXX note that this croak may fail as we've already blown away
	 * the stack - eg any nested evals */
	Perl_croak(aTHX_ "panic: fold_constants JMPENV_PUSH returned %d", ret);
    }
    JMPENV_POP;
    PL_dowarn   = oldwarn;
    PL_warnhook = oldwarnhook;
    PL_diehook  = olddiehook;
    PL_curcop = &PL_compiling;

    /* if we croaked, depending on how we croaked the eval scope
     * may or may not have already been popped */
    if (cxstack_ix > old_cxix) {
        assert(cxstack_ix == old_cxix + 1);
        assert(CxTYPE(CX_CUR()) == CXt_EVAL);
        delete_eval_scope();
    }
    if (ret)
	goto nope;

    /* OP_STRINGIFY and constant folding are used to implement qq.
       Here the constant folding is an implementation detail that we
       want to hide.  If the stringify op is itself already marked
       folded, however, then it is actually a folded join.  */
    is_stringify = type == OP_STRINGIFY && !o->op_folded;
    op_free(o);
    assert(sv);
    if (is_stringify)
	SvPADTMP_off(sv);
    else if (!SvIMMORTAL(sv)) {
	SvPADTMP_on(sv);
	SvREADONLY_on(sv);
    }
    newop = newSVOP(OP_CONST, 0, MUTABLE_SV(sv));
    if (!is_stringify) newop->op_folded = 1;
    return newop;

 nope:
    return o;
}

static OP *
S_gen_constant_list(pTHX_ OP *o)
{
    dVAR;
    OP *curop;
    const SSize_t oldtmps_floor = PL_tmps_floor;
    SV **svp;
    AV *av;

    list(o);
    if (PL_parser && PL_parser->error_count)
	return o;		/* Don't attempt to run with errors */

    curop = LINKLIST(o);
    o->op_next = 0;
    CALL_PEEP(curop);
    S_prune_chain_head(&curop);
    PL_op = curop;
    Perl_pp_pushmark(aTHX);
    CALLRUNOPS(aTHX);
    PL_op = curop;
    assert (!(curop->op_flags & OPf_SPECIAL));
    assert(curop->op_type == OP_RANGE);
    Perl_pp_anonlist(aTHX);
    PL_tmps_floor = oldtmps_floor;

    OpTYPE_set(o, OP_RV2AV);
    o->op_flags &= ~OPf_REF;	/* treat \(1..2) like an ordinary list */
    o->op_flags |= OPf_PARENS;	/* and flatten \(1..2,3) */
    o->op_opt = 0;		/* needs to be revisited in rpeep() */
    av = (AV *)SvREFCNT_inc_NN(*PL_stack_sp--);

    /* replace subtree with an OP_CONST */
    curop = ((UNOP*)o)->op_first;
    op_sibling_splice(o, NULL, -1, newSVOP(OP_CONST, 0, (SV *)av));
    op_free(curop);

    if (AvFILLp(av) != -1)
	for (svp = AvARRAY(av) + AvFILLp(av); svp >= AvARRAY(av); --svp)
	{
	    SvPADTMP_on(*svp);
	    SvREADONLY_on(*svp);
	}
    LINKLIST(o);
    return list(o);
}

/*
=head1 Optree Manipulation Functions
*/

/* List constructors */

/*
=for apidoc Am|OP *|op_append_elem|I32 optype|OP *first|OP *last

Append an item to the list of ops contained directly within a list-type
op, returning the lengthened list.  C<first> is the list-type op,
and C<last> is the op to append to the list.  C<optype> specifies the
intended opcode for the list.  If C<first> is not already a list of the
right type, it will be upgraded into one.  If either C<first> or C<last>
is null, the other is returned unchanged.

=cut
*/

OP *
Perl_op_append_elem(pTHX_ I32 type, OP *first, OP *last)
{
    if (!first)
	return last;

    if (!last)
	return first;

    if (first->op_type != (unsigned)type
	|| (type == OP_LIST && (first->op_flags & OPf_PARENS)))
    {
	return newLISTOP(type, 0, first, last);
    }

    op_sibling_splice(first, ((LISTOP*)first)->op_last, 0, last);
    first->op_flags |= OPf_KIDS;
    return first;
}

/*
=for apidoc Am|OP *|op_append_list|I32 optype|OP *first|OP *last

Concatenate the lists of ops contained directly within two list-type ops,
returning the combined list.  C<first> and C<last> are the list-type ops
to concatenate.  C<optype> specifies the intended opcode for the list.
If either C<first> or C<last> is not already a list of the right type,
it will be upgraded into one.  If either C<first> or C<last> is null,
the other is returned unchanged.

=cut
*/

OP *
Perl_op_append_list(pTHX_ I32 type, OP *first, OP *last)
{
    if (!first)
	return last;

    if (!last)
	return first;

    if (first->op_type != (unsigned)type)
	return op_prepend_elem(type, first, last);

    if (last->op_type != (unsigned)type)
	return op_append_elem(type, first, last);

    OpMORESIB_set(((LISTOP*)first)->op_last, ((LISTOP*)last)->op_first);
    ((LISTOP*)first)->op_last = ((LISTOP*)last)->op_last;
    OpLASTSIB_set(((LISTOP*)first)->op_last, first);
    first->op_flags |= (last->op_flags & OPf_KIDS);

    S_op_destroy(aTHX_ last);

    return first;
}

/*
=for apidoc Am|OP *|op_prepend_elem|I32 optype|OP *first|OP *last

Prepend an item to the list of ops contained directly within a list-type
op, returning the lengthened list.  C<first> is the op to prepend to the
list, and C<last> is the list-type op.  C<optype> specifies the intended
opcode for the list.  If C<last> is not already a list of the right type,
it will be upgraded into one.  If either C<first> or C<last> is null,
the other is returned unchanged.

=cut
*/

OP *
Perl_op_prepend_elem(pTHX_ I32 type, OP *first, OP *last)
{
    if (!first)
	return last;

    if (!last)
	return first;

    if (last->op_type == (unsigned)type) {
	if (type == OP_LIST) {	/* already a PUSHMARK there */
            /* insert 'first' after pushmark */
            op_sibling_splice(last, cLISTOPx(last)->op_first, 0, first);
            if (!(first->op_flags & OPf_PARENS))
                last->op_flags &= ~OPf_PARENS;
	}
	else
            op_sibling_splice(last, NULL, 0, first);
	last->op_flags |= OPf_KIDS;
	return last;
    }

    return newLISTOP(type, 0, first, last);
}

/*
=for apidoc Am|OP *|op_convert_list|I32 type|I32 flags|OP *o

Converts C<o> into a list op if it is not one already, and then converts it
into the specified C<type>, calling its check function, allocating a target if
it needs one, and folding constants.

A list-type op is usually constructed one kid at a time via C<newLISTOP>,
C<op_prepend_elem> and C<op_append_elem>.  Then finally it is passed to
C<op_convert_list> to make it the right type.

=cut
*/

OP *
Perl_op_convert_list(pTHX_ I32 type, I32 flags, OP *o)
{
    dVAR;
    if (type < 0) type = -type, flags |= OPf_SPECIAL;
    if (!o || o->op_type != OP_LIST)
        o = force_list(o, 0);
    else
    {
	o->op_flags &= ~OPf_WANT;
	o->op_private &= ~OPpLVAL_INTRO;
    }

    if (!(PL_opargs[type] & OA_MARK))
	op_null(cLISTOPo->op_first);
    else {
	OP * const kid2 = OpSIBLING(cLISTOPo->op_first);
	if (kid2 && kid2->op_type == OP_COREARGS) {
	    op_null(cLISTOPo->op_first);
	    kid2->op_private |= OPpCOREARGS_PUSHMARK;
	}
    }

    OpTYPE_set(o, type);
    o->op_flags |= flags;
    if (flags & OPf_FOLDED)
	o->op_folded = 1;

    o = CHECKOP(type, o);
    if (o->op_type != (unsigned)type)
	return o;

    return fold_constants(op_integerize(op_std_init(o)));
}

/* Constructors */


/*
=head1 Optree construction

=for apidoc Am|OP *|newNULLLIST

Constructs, checks, and returns a new C<stub> op, which represents an
empty list expression.

=cut
*/

OP *
Perl_newNULLLIST(pTHX)
{
    return newOP(OP_STUB, 0);
}

/* promote o and any siblings to be a list if its not already; i.e.
 *
 *  o - A - B
 *
 * becomes
 *
 *  list
 *    |
 *  pushmark - o - A - B
 *
 * If nullit it true, the list op is nulled.
 */

static OP *
S_force_list(pTHX_ OP *o, bool nullit)
{
    if (!o || o->op_type != OP_LIST) {
        OP *rest = NULL;
        if (o) {
            /* manually detach any siblings then add them back later */
            rest = OpSIBLING(o);
            OpLASTSIB_set(o, NULL);
        }
	o = newLISTOP(OP_LIST, 0, o, NULL);
        if (rest)
            op_sibling_splice(o, cLISTOPo->op_last, 0, rest);
    }
    if (nullit)
        op_null(o);
    return o;
}

/*
=for apidoc Am|OP *|newLISTOP|I32 type|I32 flags|OP *first|OP *last

Constructs, checks, and returns an op of any list type.  C<type> is
the opcode.  C<flags> gives the eight bits of C<op_flags>, except that
C<OPf_KIDS> will be set automatically if required.  C<first> and C<last>
supply up to two ops to be direct children of the list op; they are
consumed by this function and become part of the constructed op tree.

For most list operators, the check function expects all the kid ops to be
present already, so calling C<newLISTOP(OP_JOIN, ...)> (e.g.) is not
appropriate.  What you want to do in that case is create an op of type
C<OP_LIST>, append more children to it, and then call L</op_convert_list>.
See L</op_convert_list> for more information.


=cut
*/

OP *
Perl_newLISTOP(pTHX_ I32 type, I32 flags, OP *first, OP *last)
{
    dVAR;
    LISTOP *listop;

    assert((PL_opargs[type] & OA_CLASS_MASK) == OA_LISTOP
	|| type == OP_CUSTOM);

    NewOp(1101, listop, 1, LISTOP);

    OpTYPE_set(listop, type);
    if (first || last)
	flags |= OPf_KIDS;
    listop->op_flags = (U8)flags;

    if (!last && first)
	last = first;
    else if (!first && last)
	first = last;
    else if (first)
	OpMORESIB_set(first, last);
    listop->op_first = first;
    listop->op_last = last;
    if (type == OP_LIST) {
	OP* const pushop = newOP(OP_PUSHMARK, 0);
	OpMORESIB_set(pushop, first);
	listop->op_first = pushop;
	listop->op_flags |= OPf_KIDS;
	if (!last)
	    listop->op_last = pushop;
    }
    if (listop->op_last)
        OpLASTSIB_set(listop->op_last, (OP*)listop);

    return CHECKOP(type, listop);
}

/*
=for apidoc Am|OP *|newOP|I32 type|I32 flags

Constructs, checks, and returns an op of any base type (any type that
has no extra fields).  C<type> is the opcode.  C<flags> gives the
eight bits of C<op_flags>, and, shifted up eight bits, the eight bits
of C<op_private>.

=cut
*/

OP *
Perl_newOP(pTHX_ I32 type, I32 flags)
{
    dVAR;
    OP *o;

    if (type == -OP_ENTEREVAL) {
	type = OP_ENTEREVAL;
	flags |= OPpEVAL_BYTES<<8;
    }

    assert((PL_opargs[type] & OA_CLASS_MASK) == OA_BASEOP
	|| (PL_opargs[type] & OA_CLASS_MASK) == OA_BASEOP_OR_UNOP
	|| (PL_opargs[type] & OA_CLASS_MASK) == OA_FILESTATOP
	|| (PL_opargs[type] & OA_CLASS_MASK) == OA_LOOPEXOP);

    NewOp(1101, o, 1, OP);
    OpTYPE_set(o, type);
    o->op_flags = (U8)flags;

    o->op_next = o;
    o->op_private = (U8)(0 | (flags >> 8));
    if (PL_opargs[type] & OA_RETSCALAR)
	scalar(o);
    if (PL_opargs[type] & OA_TARGET)
	o->op_targ = pad_alloc(type, SVs_PADTMP);
    return CHECKOP(type, o);
}

/*
=for apidoc Am|OP *|newUNOP|I32 type|I32 flags|OP *first

Constructs, checks, and returns an op of any unary type.  C<type> is
the opcode.  C<flags> gives the eight bits of C<op_flags>, except that
C<OPf_KIDS> will be set automatically if required, and, shifted up eight
bits, the eight bits of C<op_private>, except that the bit with value 1
is automatically set.  C<first> supplies an optional op to be the direct
child of the unary op; it is consumed by this function and become part
of the constructed op tree.

=cut
*/

OP *
Perl_newUNOP(pTHX_ I32 type, I32 flags, OP *first)
{
    dVAR;
    UNOP *unop;

    if (type == -OP_ENTEREVAL) {
	type = OP_ENTEREVAL;
	flags |= OPpEVAL_BYTES<<8;
    }

    assert((PL_opargs[type] & OA_CLASS_MASK) == OA_UNOP
	|| (PL_opargs[type] & OA_CLASS_MASK) == OA_BASEOP_OR_UNOP
	|| (PL_opargs[type] & OA_CLASS_MASK) == OA_FILESTATOP
	|| (PL_opargs[type] & OA_CLASS_MASK) == OA_LOOPEXOP
	|| type == OP_SASSIGN
	|| type == OP_ENTERTRY
	|| type == OP_CUSTOM
	|| type == OP_NULL );

    if (!first)
	first = newOP(OP_STUB, 0);
    if (PL_opargs[type] & OA_MARK)
	first = force_list(first, 1);

    NewOp(1101, unop, 1, UNOP);
    OpTYPE_set(unop, type);
    unop->op_first = first;
    unop->op_flags = (U8)(flags | OPf_KIDS);
    unop->op_private = (U8)(1 | (flags >> 8));

    if (!OpHAS_SIBLING(first)) /* true unless weird syntax error */
        OpLASTSIB_set(first, (OP*)unop);

    unop = (UNOP*) CHECKOP(type, unop);
    if (unop->op_next)
	return (OP*)unop;

    return fold_constants(op_integerize(op_std_init((OP *) unop)));
}

/*
=for apidoc newUNOP_AUX

Similar to C<newUNOP>, but creates an C<UNOP_AUX> struct instead, with C<op_aux>
initialised to C<aux>

=cut
*/

OP *
Perl_newUNOP_AUX(pTHX_ I32 type, I32 flags, OP *first, UNOP_AUX_item *aux)
{
    dVAR;
    UNOP_AUX *unop;

    assert((PL_opargs[type] & OA_CLASS_MASK) == OA_UNOP_AUX
        || type == OP_CUSTOM);

    NewOp(1101, unop, 1, UNOP_AUX);
    unop->op_type = (OPCODE)type;
    unop->op_ppaddr = PL_ppaddr[type];
    unop->op_first = first;
    unop->op_flags = (U8)(flags | (first ? OPf_KIDS : 0));
    unop->op_private = (U8)((first ? 1 : 0) | (flags >> 8));
    unop->op_aux = aux;

    if (first && !OpHAS_SIBLING(first)) /* true unless weird syntax error */
        OpLASTSIB_set(first, (OP*)unop);

    unop = (UNOP_AUX*) CHECKOP(type, unop);

    return op_std_init((OP *) unop);
}

/*
=for apidoc Am|OP *|newMETHOP|I32 type|I32 flags|OP *first

Constructs, checks, and returns an op of method type with a method name
evaluated at runtime.  C<type> is the opcode.  C<flags> gives the eight
bits of C<op_flags>, except that C<OPf_KIDS> will be set automatically,
and, shifted up eight bits, the eight bits of C<op_private>, except that
the bit with value 1 is automatically set.  C<dynamic_meth> supplies an
op which evaluates method name; it is consumed by this function and
become part of the constructed op tree.
Supported optypes: C<OP_METHOD>.

=cut
*/

static OP*
S_newMETHOP_internal(pTHX_ I32 type, I32 flags, OP* dynamic_meth, SV* const_meth) {
    dVAR;
    METHOP *methop;

    assert((PL_opargs[type] & OA_CLASS_MASK) == OA_METHOP
        || type == OP_CUSTOM);

    NewOp(1101, methop, 1, METHOP);
    if (dynamic_meth) {
        if (PL_opargs[type] & OA_MARK) dynamic_meth = force_list(dynamic_meth, 1);
        methop->op_flags = (U8)(flags | OPf_KIDS);
        methop->op_u.op_first = dynamic_meth;
        methop->op_private = (U8)(1 | (flags >> 8));

        if (!OpHAS_SIBLING(dynamic_meth))
            OpLASTSIB_set(dynamic_meth, (OP*)methop);
    }
    else {
        assert(const_meth);
        methop->op_flags = (U8)(flags & ~OPf_KIDS);
        methop->op_u.op_meth_sv = const_meth;
        methop->op_private = (U8)(0 | (flags >> 8));
        methop->op_next = (OP*)methop;
    }

#ifdef USE_ITHREADS
    methop->op_rclass_targ = 0;
#else
    methop->op_rclass_sv = NULL;
#endif

    OpTYPE_set(methop, type);
    return CHECKOP(type, methop);
}

OP *
Perl_newMETHOP (pTHX_ I32 type, I32 flags, OP* dynamic_meth) {
    PERL_ARGS_ASSERT_NEWMETHOP;
    return newMETHOP_internal(type, flags, dynamic_meth, NULL);
}

/*
=for apidoc Am|OP *|newMETHOP_named|I32 type|I32 flags|SV *const_meth

Constructs, checks, and returns an op of method type with a constant
method name.  C<type> is the opcode.  C<flags> gives the eight bits of
C<op_flags>, and, shifted up eight bits, the eight bits of
C<op_private>.  C<const_meth> supplies a constant method name;
it must be a shared COW string.
Supported optypes: C<OP_METHOD_NAMED>.

=cut
*/

OP *
Perl_newMETHOP_named (pTHX_ I32 type, I32 flags, SV* const_meth) {
    PERL_ARGS_ASSERT_NEWMETHOP_NAMED;
    return newMETHOP_internal(type, flags, NULL, const_meth);
}

/*
=for apidoc Am|OP *|newBINOP|I32 type|I32 flags|OP *first|OP *last

Constructs, checks, and returns an op of any binary type.  C<type>
is the opcode.  C<flags> gives the eight bits of C<op_flags>, except
that C<OPf_KIDS> will be set automatically, and, shifted up eight bits,
the eight bits of C<op_private>, except that the bit with value 1 or
2 is automatically set as required.  C<first> and C<last> supply up to
two ops to be the direct children of the binary op; they are consumed
by this function and become part of the constructed op tree.

=cut
*/

OP *
Perl_newBINOP(pTHX_ I32 type, I32 flags, OP *first, OP *last)
{
    dVAR;
    BINOP *binop;

    ASSUME((PL_opargs[type] & OA_CLASS_MASK) == OA_BINOP
	|| type == OP_SASSIGN || type == OP_NULL || type == OP_CUSTOM);

    NewOp(1101, binop, 1, BINOP);

    if (!first)
	first = newOP(OP_NULL, 0);

    OpTYPE_set(binop, type);
    binop->op_first = first;
    binop->op_flags = (U8)(flags | OPf_KIDS);
    if (!last) {
	last = first;
	binop->op_private = (U8)(1 | (flags >> 8));
    }
    else {
	binop->op_private = (U8)(2 | (flags >> 8));
        OpMORESIB_set(first, last);
    }

    if (!OpHAS_SIBLING(last)) /* true unless weird syntax error */
        OpLASTSIB_set(last, (OP*)binop);

    binop->op_last = OpSIBLING(binop->op_first);
    if (binop->op_last)
        OpLASTSIB_set(binop->op_last, (OP*)binop);

    binop = (BINOP*)CHECKOP(type, binop);
    if (binop->op_next || binop->op_type != (OPCODE)type)
	return (OP*)binop;

    return fold_constants(op_integerize(op_std_init((OP *)binop)));
}

static int uvcompare(const void *a, const void *b)
    __attribute__nonnull__(1)
    __attribute__nonnull__(2)
    __attribute__pure__;
static int uvcompare(const void *a, const void *b)
{
    if (*((const UV *)a) < (*(const UV *)b))
	return -1;
    if (*((const UV *)a) > (*(const UV *)b))
	return 1;
    if (*((const UV *)a+1) < (*(const UV *)b+1))
	return -1;
    if (*((const UV *)a+1) > (*(const UV *)b+1))
	return 1;
    return 0;
}

static OP *
S_pmtrans(pTHX_ OP *o, OP *expr, OP *repl)
{
    SV * const tstr = ((SVOP*)expr)->op_sv;
    SV * const rstr =
			      ((SVOP*)repl)->op_sv;
    STRLEN tlen;
    STRLEN rlen;
    const U8 *t = (U8*)SvPV_const(tstr, tlen);
    const U8 *r = (U8*)SvPV_const(rstr, rlen);
    I32 i;
    I32 j;
    I32 grows = 0;
    short *tbl;

    const I32 complement = o->op_private & OPpTRANS_COMPLEMENT;
    const I32 squash     = o->op_private & OPpTRANS_SQUASH;
    I32 del              = o->op_private & OPpTRANS_DELETE;
    SV* swash;

    PERL_ARGS_ASSERT_PMTRANS;

    PL_hints |= HINT_BLOCK_SCOPE;

    if (SvUTF8(tstr))
        o->op_private |= OPpTRANS_FROM_UTF;

    if (SvUTF8(rstr))
        o->op_private |= OPpTRANS_TO_UTF;

    if (o->op_private & (OPpTRANS_FROM_UTF|OPpTRANS_TO_UTF)) {
	SV* const listsv = newSVpvs("# comment\n");
	SV* transv = NULL;
	const U8* tend = t + tlen;
	const U8* rend = r + rlen;
	STRLEN ulen;
	UV tfirst = 1;
	UV tlast = 0;
	IV tdiff;
	STRLEN tcount = 0;
	UV rfirst = 1;
	UV rlast = 0;
	IV rdiff;
	STRLEN rcount = 0;
	IV diff;
	I32 none = 0;
	U32 max = 0;
	I32 bits;
	I32 havefinal = 0;
	U32 final = 0;
	const I32 from_utf  = o->op_private & OPpTRANS_FROM_UTF;
	const I32 to_utf    = o->op_private & OPpTRANS_TO_UTF;
	U8* tsave = NULL;
	U8* rsave = NULL;
	const U32 flags = UTF8_ALLOW_DEFAULT;

	if (!from_utf) {
	    STRLEN len = tlen;
	    t = tsave = bytes_to_utf8(t, &len);
	    tend = t + len;
	}
	if (!to_utf && rlen) {
	    STRLEN len = rlen;
	    r = rsave = bytes_to_utf8(r, &len);
	    rend = r + len;
	}

/* There is a snag with this code on EBCDIC: scan_const() in toke.c has
 * encoded chars in native encoding which makes ranges in the EBCDIC 0..255
 * odd.  */

	if (complement) {
	    U8 tmpbuf[UTF8_MAXBYTES+1];
	    UV *cp;
	    UV nextmin = 0;
	    Newx(cp, 2*tlen, UV);
	    i = 0;
	    transv = newSVpvs("");
	    while (t < tend) {
		cp[2*i] = utf8n_to_uvchr(t, tend-t, &ulen, flags);
		t += ulen;
		if (t < tend && *t == ILLEGAL_UTF8_BYTE) {
		    t++;
		    cp[2*i+1] = utf8n_to_uvchr(t, tend-t, &ulen, flags);
		    t += ulen;
		}
		else {
		 cp[2*i+1] = cp[2*i];
		}
		i++;
	    }
	    qsort(cp, i, 2*sizeof(UV), uvcompare);
	    for (j = 0; j < i; j++) {
		UV  val = cp[2*j];
		diff = val - nextmin;
		if (diff > 0) {
		    t = uvchr_to_utf8(tmpbuf,nextmin);
		    sv_catpvn(transv, (char*)tmpbuf, t - tmpbuf);
		    if (diff > 1) {
			U8  range_mark = ILLEGAL_UTF8_BYTE;
			t = uvchr_to_utf8(tmpbuf, val - 1);
			sv_catpvn(transv, (char *)&range_mark, 1);
			sv_catpvn(transv, (char*)tmpbuf, t - tmpbuf);
		    }
	        }
		val = cp[2*j+1];
		if (val >= nextmin)
		    nextmin = val + 1;
	    }
	    t = uvchr_to_utf8(tmpbuf,nextmin);
	    sv_catpvn(transv, (char*)tmpbuf, t - tmpbuf);
	    {
		U8 range_mark = ILLEGAL_UTF8_BYTE;
		sv_catpvn(transv, (char *)&range_mark, 1);
	    }
	    t = uvchr_to_utf8(tmpbuf, 0x7fffffff);
	    sv_catpvn(transv, (char*)tmpbuf, t - tmpbuf);
	    t = (const U8*)SvPVX_const(transv);
	    tlen = SvCUR(transv);
	    tend = t + tlen;
	    Safefree(cp);
	}
	else if (!rlen && !del) {
	    r = t; rlen = tlen; rend = tend;
	}
	if (!squash) {
		if ((!rlen && !del) || t == r ||
		    (tlen == rlen && memEQ((char *)t, (char *)r, tlen)))
		{
		    o->op_private |= OPpTRANS_IDENTICAL;
		}
	}

	while (t < tend || tfirst <= tlast) {
	    /* see if we need more "t" chars */
	    if (tfirst > tlast) {
		tfirst = (I32)utf8n_to_uvchr(t, tend - t, &ulen, flags);
		t += ulen;
		if (t < tend && *t == ILLEGAL_UTF8_BYTE) {	/* illegal utf8 val indicates range */
		    t++;
		    tlast = (I32)utf8n_to_uvchr(t, tend - t, &ulen, flags);
		    t += ulen;
		}
		else
		    tlast = tfirst;
	    }

	    /* now see if we need more "r" chars */
	    if (rfirst > rlast) {
		if (r < rend) {
		    rfirst = (I32)utf8n_to_uvchr(r, rend - r, &ulen, flags);
		    r += ulen;
		    if (r < rend && *r == ILLEGAL_UTF8_BYTE) {	/* illegal utf8 val indicates range */
			r++;
			rlast = (I32)utf8n_to_uvchr(r, rend - r, &ulen, flags);
			r += ulen;
		    }
		    else
			rlast = rfirst;
		}
		else {
		    if (!havefinal++)
			final = rlast;
		    rfirst = rlast = 0xffffffff;
		}
	    }

	    /* now see which range will peter out first, if either. */
	    tdiff = tlast - tfirst;
	    rdiff = rlast - rfirst;
	    tcount += tdiff + 1;
	    rcount += rdiff + 1;

	    if (tdiff <= rdiff)
		diff = tdiff;
	    else
		diff = rdiff;

	    if (rfirst == 0xffffffff) {
		diff = tdiff;	/* oops, pretend rdiff is infinite */
		if (diff > 0)
		    Perl_sv_catpvf(aTHX_ listsv, "%04lx\t%04lx\tXXXX\n",
				   (long)tfirst, (long)tlast);
		else
		    Perl_sv_catpvf(aTHX_ listsv, "%04lx\t\tXXXX\n", (long)tfirst);
	    }
	    else {
		if (diff > 0)
		    Perl_sv_catpvf(aTHX_ listsv, "%04lx\t%04lx\t%04lx\n",
				   (long)tfirst, (long)(tfirst + diff),
				   (long)rfirst);
		else
		    Perl_sv_catpvf(aTHX_ listsv, "%04lx\t\t%04lx\n",
				   (long)tfirst, (long)rfirst);

		if (rfirst + diff > max)
		    max = rfirst + diff;
		if (!grows)
		    grows = (tfirst < rfirst &&
			     UVCHR_SKIP(tfirst) < UVCHR_SKIP(rfirst + diff));
		rfirst += diff + 1;
	    }
	    tfirst += diff + 1;
	}

	none = ++max;
	if (del)
	    del = ++max;

	if (max > 0xffff)
	    bits = 32;
	else if (max > 0xff)
	    bits = 16;
	else
	    bits = 8;

	swash = MUTABLE_SV(swash_init("utf8", "", listsv, bits, none));
#ifdef USE_ITHREADS
	cPADOPo->op_padix = pad_alloc(OP_TRANS, SVf_READONLY);
	SvREFCNT_dec(PAD_SVl(cPADOPo->op_padix));
	PAD_SETSV(cPADOPo->op_padix, swash);
	SvPADTMP_on(swash);
	SvREADONLY_on(swash);
#else
	cSVOPo->op_sv = swash;
#endif
	SvREFCNT_dec(listsv);
	SvREFCNT_dec(transv);

	if (!del && havefinal && rlen)
	    (void)hv_store(MUTABLE_HV(SvRV(swash)), "FINAL", 5,
			   newSVuv((UV)final), 0);

	Safefree(tsave);
	Safefree(rsave);

	tlen = tcount;
	rlen = rcount;
	if (r < rend)
	    rlen++;
	else if (rlast == 0xffffffff)
	    rlen = 0;

	goto warnins;
    }

    tbl = (short*)PerlMemShared_calloc(
	(o->op_private & OPpTRANS_COMPLEMENT) &&
	    !(o->op_private & OPpTRANS_DELETE) ? 258 : 256,
	sizeof(short));
    cPVOPo->op_pv = (char*)tbl;
    if (complement) {
	for (i = 0; i < (I32)tlen; i++)
	    tbl[t[i]] = -1;
	for (i = 0, j = 0; i < 256; i++) {
	    if (!tbl[i]) {
		if (j >= (I32)rlen) {
		    if (del)
			tbl[i] = -2;
		    else if (rlen)
			tbl[i] = r[j-1];
		    else
			tbl[i] = (short)i;
		}
		else {
		    if (i < 128 && r[j] >= 128)
			grows = 1;
		    tbl[i] = r[j++];
		}
	    }
	}
	if (!del) {
	    if (!rlen) {
		j = rlen;
		if (!squash)
		    o->op_private |= OPpTRANS_IDENTICAL;
	    }
	    else if (j >= (I32)rlen)
		j = rlen - 1;
	    else {
		tbl = 
		    (short *)
		    PerlMemShared_realloc(tbl,
					  (0x101+rlen-j) * sizeof(short));
		cPVOPo->op_pv = (char*)tbl;
	    }
	    tbl[0x100] = (short)(rlen - j);
	    for (i=0; i < (I32)rlen - j; i++)
		tbl[0x101+i] = r[j+i];
	}
    }
    else {
	if (!rlen && !del) {
	    r = t; rlen = tlen;
	    if (!squash)
		o->op_private |= OPpTRANS_IDENTICAL;
	}
	else if (!squash && rlen == tlen && memEQ((char*)t, (char*)r, tlen)) {
	    o->op_private |= OPpTRANS_IDENTICAL;
	}
	for (i = 0; i < 256; i++)
	    tbl[i] = -1;
	for (i = 0, j = 0; i < (I32)tlen; i++,j++) {
	    if (j >= (I32)rlen) {
		if (del) {
		    if (tbl[t[i]] == -1)
			tbl[t[i]] = -2;
		    continue;
		}
		--j;
	    }
	    if (tbl[t[i]] == -1) {
		if (t[i] < 128 && r[j] >= 128)
		    grows = 1;
		tbl[t[i]] = r[j];
	    }
	}
    }

  warnins:
    if(del && rlen == tlen) {
	Perl_ck_warner(aTHX_ packWARN(WARN_MISC), "Useless use of /d modifier in transliteration operator"); 
    } else if(rlen > tlen && !complement) {
	Perl_ck_warner(aTHX_ packWARN(WARN_MISC), "Replacement list is longer than search list");
    }

    if (grows)
	o->op_private |= OPpTRANS_GROWS;
    op_free(expr);
    op_free(repl);

    return o;
}

/*
=for apidoc Am|OP *|newPMOP|I32 type|I32 flags

Constructs, checks, and returns an op of any pattern matching type.
C<type> is the opcode.  C<flags> gives the eight bits of C<op_flags>
and, shifted up eight bits, the eight bits of C<op_private>.

=cut
*/

OP *
Perl_newPMOP(pTHX_ I32 type, I32 flags)
{
    dVAR;
    PMOP *pmop;

    assert((PL_opargs[type] & OA_CLASS_MASK) == OA_PMOP
	|| type == OP_CUSTOM);

    NewOp(1101, pmop, 1, PMOP);
    OpTYPE_set(pmop, type);
    pmop->op_flags = (U8)flags;
    pmop->op_private = (U8)(0 | (flags >> 8));
    if (PL_opargs[type] & OA_RETSCALAR)
	scalar((OP *)pmop);

    if (PL_hints & HINT_RE_TAINT)
	pmop->op_pmflags |= PMf_RETAINT;
#ifdef USE_LOCALE_CTYPE
    if (IN_LC_COMPILETIME(LC_CTYPE)) {
	set_regex_charset(&(pmop->op_pmflags), REGEX_LOCALE_CHARSET);
    }
    else
#endif
         if (IN_UNI_8_BIT) {
	set_regex_charset(&(pmop->op_pmflags), REGEX_UNICODE_CHARSET);
    }
    if (PL_hints & HINT_RE_FLAGS) {
        SV *reflags = Perl_refcounted_he_fetch_pvn(aTHX_
         PL_compiling.cop_hints_hash, STR_WITH_LEN("reflags"), 0, 0
        );
        if (reflags && SvOK(reflags)) pmop->op_pmflags |= SvIV(reflags);
        reflags = Perl_refcounted_he_fetch_pvn(aTHX_
         PL_compiling.cop_hints_hash, STR_WITH_LEN("reflags_charset"), 0, 0
        );
        if (reflags && SvOK(reflags)) {
            set_regex_charset(&(pmop->op_pmflags), (regex_charset)SvIV(reflags));
        }
    }


#ifdef USE_ITHREADS
    assert(SvPOK(PL_regex_pad[0]));
    if (SvCUR(PL_regex_pad[0])) {
	/* Pop off the "packed" IV from the end.  */
	SV *const repointer_list = PL_regex_pad[0];
	const char *p = SvEND(repointer_list) - sizeof(IV);
	const IV offset = *((IV*)p);

	assert(SvCUR(repointer_list) % sizeof(IV) == 0);

	SvEND_set(repointer_list, p);

	pmop->op_pmoffset = offset;
	/* This slot should be free, so assert this:  */
	assert(PL_regex_pad[offset] == &PL_sv_undef);
    } else {
	SV * const repointer = &PL_sv_undef;
	av_push(PL_regex_padav, repointer);
	pmop->op_pmoffset = av_tindex(PL_regex_padav);
	PL_regex_pad = AvARRAY(PL_regex_padav);
    }
#endif

    return CHECKOP(type, pmop);
}

static void
S_set_haseval(pTHX)
{
    PADOFFSET i = 1;
    PL_cv_has_eval = 1;
    /* Any pad names in scope are potentially lvalues.  */
    for (; i < PadnamelistMAXNAMED(PL_comppad_name); i++) {
	PADNAME *pn = PAD_COMPNAME_SV(i);
	if (!pn || !PadnameLEN(pn))
	    continue;
	if (PadnameOUTER(pn) || PadnameIN_SCOPE(pn, PL_cop_seqmax))
	    S_mark_padname_lvalue(aTHX_ pn);
    }
}

/* Given some sort of match op o, and an expression expr containing a
 * pattern, either compile expr into a regex and attach it to o (if it's
 * constant), or convert expr into a runtime regcomp op sequence (if it's
 * not)
 *
 * isreg indicates that the pattern is part of a regex construct, eg
 * $x =~ /pattern/ or split /pattern/, as opposed to $x =~ $pattern or
 * split "pattern", which aren't. In the former case, expr will be a list
 * if the pattern contains more than one term (eg /a$b/).
 *
 * When the pattern has been compiled within a new anon CV (for
 * qr/(?{...})/ ), then floor indicates the savestack level just before
 * the new sub was created
 */

OP *
Perl_pmruntime(pTHX_ OP *o, OP *expr, OP *repl, bool isreg, I32 floor)
{
    PMOP *pm;
    LOGOP *rcop;
    I32 repl_has_vars = 0;
    bool is_trans = (o->op_type == OP_TRANS || o->op_type == OP_TRANSR);
    bool is_compiletime;
    bool has_code;

    PERL_ARGS_ASSERT_PMRUNTIME;

    if (is_trans) {
        return pmtrans(o, expr, repl);
    }

    /* find whether we have any runtime or code elements;
     * at the same time, temporarily set the op_next of each DO block;
     * then when we LINKLIST, this will cause the DO blocks to be excluded
     * from the op_next chain (and from having LINKLIST recursively
     * applied to them). We fix up the DOs specially later */

    is_compiletime = 1;
    has_code = 0;
    if (expr->op_type == OP_LIST) {
	OP *o;
	for (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o)) {
	    if (o->op_type == OP_NULL && (o->op_flags & OPf_SPECIAL)) {
		has_code = 1;
		assert(!o->op_next);
		if (UNLIKELY(!OpHAS_SIBLING(o))) {
		    assert(PL_parser && PL_parser->error_count);
		    /* This can happen with qr/ (?{(^{})/.  Just fake up
		       the op we were expecting to see, to avoid crashing
		       elsewhere.  */
		    op_sibling_splice(expr, o, 0,
				      newSVOP(OP_CONST, 0, &PL_sv_no));
		}
		o->op_next = OpSIBLING(o);
	    }
	    else if (o->op_type != OP_CONST && o->op_type != OP_PUSHMARK)
		is_compiletime = 0;
	}
    }
    else if (expr->op_type != OP_CONST)
	is_compiletime = 0;

    LINKLIST(expr);

    /* fix up DO blocks; treat each one as a separate little sub;
     * also, mark any arrays as LIST/REF */

    if (expr->op_type == OP_LIST) {
	OP *o;
	for (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o)) {

            if (o->op_type == OP_PADAV || o->op_type == OP_RV2AV) {
                assert( !(o->op_flags  & OPf_WANT));
                /* push the array rather than its contents. The regex
                 * engine will retrieve and join the elements later */
                o->op_flags |= (OPf_WANT_LIST | OPf_REF);
                continue;
            }

	    if (!(o->op_type == OP_NULL && (o->op_flags & OPf_SPECIAL)))
		continue;
	    o->op_next = NULL; /* undo temporary hack from above */
	    scalar(o);
	    LINKLIST(o);
	    if (cLISTOPo->op_first->op_type == OP_LEAVE) {
		LISTOP *leaveop = cLISTOPx(cLISTOPo->op_first);
		/* skip ENTER */
		assert(leaveop->op_first->op_type == OP_ENTER);
		assert(OpHAS_SIBLING(leaveop->op_first));
		o->op_next = OpSIBLING(leaveop->op_first);
		/* skip leave */
		assert(leaveop->op_flags & OPf_KIDS);
		assert(leaveop->op_last->op_next == (OP*)leaveop);
		leaveop->op_next = NULL; /* stop on last op */
		op_null((OP*)leaveop);
	    }
	    else {
		/* skip SCOPE */
		OP *scope = cLISTOPo->op_first;
		assert(scope->op_type == OP_SCOPE);
		assert(scope->op_flags & OPf_KIDS);
		scope->op_next = NULL; /* stop on last op */
		op_null(scope);
	    }
	    /* have to peep the DOs individually as we've removed it from
	     * the op_next chain */
	    CALL_PEEP(o);
            S_prune_chain_head(&(o->op_next));
	    if (is_compiletime)
		/* runtime finalizes as part of finalizing whole tree */
		finalize_optree(o);
	}
    }
    else if (expr->op_type == OP_PADAV || expr->op_type == OP_RV2AV) {
        assert( !(expr->op_flags  & OPf_WANT));
        /* push the array rather than its contents. The regex
         * engine will retrieve and join the elements later */
        expr->op_flags |= (OPf_WANT_LIST | OPf_REF);
    }

    PL_hints |= HINT_BLOCK_SCOPE;
    pm = (PMOP*)o;
    assert(floor==0 || (pm->op_pmflags & PMf_HAS_CV));

    if (is_compiletime) {
	U32 rx_flags = pm->op_pmflags & RXf_PMf_COMPILETIME;
	regexp_engine const *eng = current_re_engine();

        if (o->op_flags & OPf_SPECIAL)
            rx_flags |= RXf_SPLIT;

	if (!has_code || !eng->op_comp) {
	    /* compile-time simple constant pattern */

	    if ((pm->op_pmflags & PMf_HAS_CV) && !has_code) {
		/* whoops! we guessed that a qr// had a code block, but we
		 * were wrong (e.g. /[(?{}]/ ). Throw away the PL_compcv
		 * that isn't required now. Note that we have to be pretty
		 * confident that nothing used that CV's pad while the
		 * regex was parsed, except maybe op targets for \Q etc.
		 * If there were any op targets, though, they should have
		 * been stolen by constant folding.
		 */
#ifdef DEBUGGING
		SSize_t i = 0;
		assert(PadnamelistMAXNAMED(PL_comppad_name) == 0);
		while (++i <= AvFILLp(PL_comppad)) {
		    assert(!PL_curpad[i]);
		}
#endif
		/* But we know that one op is using this CV's slab. */
		cv_forget_slab(PL_compcv);
		LEAVE_SCOPE(floor);
		pm->op_pmflags &= ~PMf_HAS_CV;
	    }

	    PM_SETRE(pm,
		eng->op_comp
		    ? eng->op_comp(aTHX_ NULL, 0, expr, eng, NULL, NULL,
					rx_flags, pm->op_pmflags)
		    : Perl_re_op_compile(aTHX_ NULL, 0, expr, eng, NULL, NULL,
					rx_flags, pm->op_pmflags)
	    );
	    op_free(expr);
	}
	else {
	    /* compile-time pattern that includes literal code blocks */
	    REGEXP* re = eng->op_comp(aTHX_ NULL, 0, expr, eng, NULL, NULL,
			rx_flags,
			(pm->op_pmflags |
			    ((PL_hints & HINT_RE_EVAL) ? PMf_USE_RE_EVAL : 0))
		    );
	    PM_SETRE(pm, re);
	    if (pm->op_pmflags & PMf_HAS_CV) {
		CV *cv;
		/* this QR op (and the anon sub we embed it in) is never
		 * actually executed. It's just a placeholder where we can
		 * squirrel away expr in op_code_list without the peephole
		 * optimiser etc processing it for a second time */
		OP *qr = newPMOP(OP_QR, 0);
		((PMOP*)qr)->op_code_list = expr;

		/* handle the implicit sub{} wrapped round the qr/(?{..})/ */
		SvREFCNT_inc_simple_void(PL_compcv);
		cv = newATTRSUB(floor, 0, NULL, NULL, qr);
		ReANY(re)->qr_anoncv = cv;

		/* attach the anon CV to the pad so that
		 * pad_fixup_inner_anons() can find it */
		(void)pad_add_anon(cv, o->op_type);
		SvREFCNT_inc_simple_void(cv);
	    }
	    else {
		pm->op_code_list = expr;
	    }
	}
    }
    else {
	/* runtime pattern: build chain of regcomp etc ops */
	bool reglist;
	PADOFFSET cv_targ = 0;

	reglist = isreg && expr->op_type == OP_LIST;
	if (reglist)
	    op_null(expr);

	if (has_code) {
	    pm->op_code_list = expr;
	    /* don't free op_code_list; its ops are embedded elsewhere too */
	    pm->op_pmflags |= PMf_CODELIST_PRIVATE;
	}

        if (o->op_flags & OPf_SPECIAL)
            pm->op_pmflags |= PMf_SPLIT;

	/* the OP_REGCMAYBE is a placeholder in the non-threaded case
	 * to allow its op_next to be pointed past the regcomp and
	 * preceding stacking ops;
	 * OP_REGCRESET is there to reset taint before executing the
	 * stacking ops */
	if (pm->op_pmflags & PMf_KEEP || TAINTING_get)
	    expr = newUNOP((TAINTING_get ? OP_REGCRESET : OP_REGCMAYBE),0,expr);

	if (pm->op_pmflags & PMf_HAS_CV) {
	    /* we have a runtime qr with literal code. This means
	     * that the qr// has been wrapped in a new CV, which
	     * means that runtime consts, vars etc will have been compiled
	     * against a new pad. So... we need to execute those ops
	     * within the environment of the new CV. So wrap them in a call
	     * to a new anon sub. i.e. for
	     *
	     *     qr/a$b(?{...})/,
	     *
	     * we build an anon sub that looks like
	     *
	     *     sub { "a", $b, '(?{...})' }
	     *
	     * and call it, passing the returned list to regcomp.
	     * Or to put it another way, the list of ops that get executed
	     * are:
	     *
	     *     normal              PMf_HAS_CV
	     *     ------              -------------------
	     *                         pushmark (for regcomp)
	     *                         pushmark (for entersub)
	     *                         anoncode
	     *                         srefgen
	     *                         entersub
	     *     regcreset                  regcreset
	     *     pushmark                   pushmark
	     *     const("a")                 const("a")
	     *     gvsv(b)                    gvsv(b)
	     *     const("(?{...})")          const("(?{...})")
	     *                                leavesub
	     *     regcomp             regcomp
	     */

	    SvREFCNT_inc_simple_void(PL_compcv);
	    CvLVALUE_on(PL_compcv);
	    /* these lines are just an unrolled newANONATTRSUB */
	    expr = newSVOP(OP_ANONCODE, 0,
		    MUTABLE_SV(newATTRSUB(floor, 0, NULL, NULL, expr)));
	    cv_targ = expr->op_targ;
	    expr = newUNOP(OP_REFGEN, 0, expr);

	    expr = list(force_list(newUNOP(OP_ENTERSUB, 0, scalar(expr)), 1));
	}

        rcop = S_alloc_LOGOP(aTHX_ OP_REGCOMP, scalar(expr), o);
	rcop->op_flags |=  ((PL_hints & HINT_RE_EVAL) ? OPf_SPECIAL : 0)
			   | (reglist ? OPf_STACKED : 0);
	rcop->op_targ = cv_targ;

	/* /$x/ may cause an eval, since $x might be qr/(?{..})/  */
	if (PL_hints & HINT_RE_EVAL)
	    S_set_haseval(aTHX);

	/* establish postfix order */
	if (expr->op_type == OP_REGCRESET || expr->op_type == OP_REGCMAYBE) {
	    LINKLIST(expr);
	    rcop->op_next = expr;
	    ((UNOP*)expr)->op_first->op_next = (OP*)rcop;
	}
	else {
	    rcop->op_next = LINKLIST(expr);
	    expr->op_next = (OP*)rcop;
	}

	op_prepend_elem(o->op_type, scalar((OP*)rcop), o);
    }

    if (repl) {
	OP *curop = repl;
	bool konst;
	/* If we are looking at s//.../e with a single statement, get past
	   the implicit do{}. */
	if (curop->op_type == OP_NULL && curop->op_flags & OPf_KIDS
             && cUNOPx(curop)->op_first->op_type == OP_SCOPE
             && cUNOPx(curop)->op_first->op_flags & OPf_KIDS)
         {
            OP *sib;
	    OP *kid = cUNOPx(cUNOPx(curop)->op_first)->op_first;
	    if (kid->op_type == OP_NULL && (sib = OpSIBLING(kid))
	     && !OpHAS_SIBLING(sib))
		curop = sib;
	}
	if (curop->op_type == OP_CONST)
	    konst = TRUE;
	else if (( (curop->op_type == OP_RV2SV ||
		    curop->op_type == OP_RV2AV ||
		    curop->op_type == OP_RV2HV ||
		    curop->op_type == OP_RV2GV)
		   && cUNOPx(curop)->op_first
		   && cUNOPx(curop)->op_first->op_type == OP_GV )
		|| curop->op_type == OP_PADSV
		|| curop->op_type == OP_PADAV
		|| curop->op_type == OP_PADHV
		|| curop->op_type == OP_PADANY) {
	    repl_has_vars = 1;
	    konst = TRUE;
	}
	else konst = FALSE;
	if (konst
	    && !(repl_has_vars
		 && (!PM_GETRE(pm)
		     || !RX_PRELEN(PM_GETRE(pm))
		     || RX_EXTFLAGS(PM_GETRE(pm)) & RXf_EVAL_SEEN)))
	{
	    pm->op_pmflags |= PMf_CONST;	/* const for long enough */
	    op_prepend_elem(o->op_type, scalar(repl), o);
	}
	else {
            rcop = S_alloc_LOGOP(aTHX_ OP_SUBSTCONT, scalar(repl), o);
	    rcop->op_private = 1;

	    /* establish postfix order */
	    rcop->op_next = LINKLIST(repl);
	    repl->op_next = (OP*)rcop;

	    pm->op_pmreplrootu.op_pmreplroot = scalar((OP*)rcop);
	    assert(!(pm->op_pmflags & PMf_ONCE));
	    pm->op_pmstashstartu.op_pmreplstart = LINKLIST(rcop);
	    rcop->op_next = 0;
	}
    }

    return (OP*)pm;
}

/*
=for apidoc Am|OP *|newSVOP|I32 type|I32 flags|SV *sv

Constructs, checks, and returns an op of any type that involves an
embedded SV.  C<type> is the opcode.  C<flags> gives the eight bits
of C<op_flags>.  C<sv> gives the SV to embed in the op; this function
takes ownership of one reference to it.

=cut
*/

OP *
Perl_newSVOP(pTHX_ I32 type, I32 flags, SV *sv)
{
    dVAR;
    SVOP *svop;

    PERL_ARGS_ASSERT_NEWSVOP;

    assert((PL_opargs[type] & OA_CLASS_MASK) == OA_SVOP
	|| (PL_opargs[type] & OA_CLASS_MASK) == OA_PVOP_OR_SVOP
	|| (PL_opargs[type] & OA_CLASS_MASK) == OA_FILESTATOP
	|| type == OP_CUSTOM);

    NewOp(1101, svop, 1, SVOP);
    OpTYPE_set(svop, type);
    svop->op_sv = sv;
    svop->op_next = (OP*)svop;
    svop->op_flags = (U8)flags;
    svop->op_private = (U8)(0 | (flags >> 8));
    if (PL_opargs[type] & OA_RETSCALAR)
	scalar((OP*)svop);
    if (PL_opargs[type] & OA_TARGET)
	svop->op_targ = pad_alloc(type, SVs_PADTMP);
    return CHECKOP(type, svop);
}

/*
=for apidoc Am|OP *|newDEFSVOP|

Constructs and returns an op to access C<$_>.

=cut
*/

OP *
Perl_newDEFSVOP(pTHX)
{
	return newSVREF(newGVOP(OP_GV, 0, PL_defgv));
}

#ifdef USE_ITHREADS

/*
=for apidoc Am|OP *|newPADOP|I32 type|I32 flags|SV *sv

Constructs, checks, and returns an op of any type that involves a
reference to a pad element.  C<type> is the opcode.  C<flags> gives the
eight bits of C<op_flags>.  A pad slot is automatically allocated, and
is populated with C<sv>; this function takes ownership of one reference
to it.

This function only exists if Perl has been compiled to use ithreads.

=cut
*/

OP *
Perl_newPADOP(pTHX_ I32 type, I32 flags, SV *sv)
{
    dVAR;
    PADOP *padop;

    PERL_ARGS_ASSERT_NEWPADOP;

    assert((PL_opargs[type] & OA_CLASS_MASK) == OA_SVOP
	|| (PL_opargs[type] & OA_CLASS_MASK) == OA_PVOP_OR_SVOP
	|| (PL_opargs[type] & OA_CLASS_MASK) == OA_FILESTATOP
	|| type == OP_CUSTOM);

    NewOp(1101, padop, 1, PADOP);
    OpTYPE_set(padop, type);
    padop->op_padix =
	pad_alloc(type, isGV(sv) ? SVf_READONLY : SVs_PADTMP);
    SvREFCNT_dec(PAD_SVl(padop->op_padix));
    PAD_SETSV(padop->op_padix, sv);
    assert(sv);
    padop->op_next = (OP*)padop;
    padop->op_flags = (U8)flags;
    if (PL_opargs[type] & OA_RETSCALAR)
	scalar((OP*)padop);
    if (PL_opargs[type] & OA_TARGET)
	padop->op_targ = pad_alloc(type, SVs_PADTMP);
    return CHECKOP(type, padop);
}

#endif /* USE_ITHREADS */

/*
=for apidoc Am|OP *|newGVOP|I32 type|I32 flags|GV *gv

Constructs, checks, and returns an op of any type that involves an
embedded reference to a GV.  C<type> is the opcode.  C<flags> gives the
eight bits of C<op_flags>.  C<gv> identifies the GV that the op should
reference; calling this function does not transfer ownership of any
reference to it.

=cut
*/

OP *
Perl_newGVOP(pTHX_ I32 type, I32 flags, GV *gv)
{
    PERL_ARGS_ASSERT_NEWGVOP;

#ifdef USE_ITHREADS
    return newPADOP(type, flags, SvREFCNT_inc_simple_NN(gv));
#else
    return newSVOP(type, flags, SvREFCNT_inc_simple_NN(gv));
#endif
}

/*
=for apidoc Am|OP *|newPVOP|I32 type|I32 flags|char *pv

Constructs, checks, and returns an op of any type that involves an
embedded C-level pointer (PV).  C<type> is the opcode.  C<flags> gives
the eight bits of C<op_flags>.  C<pv> supplies the C-level pointer, which
must have been allocated using C<PerlMemShared_malloc>; the memory will
be freed when the op is destroyed.

=cut
*/

OP *
Perl_newPVOP(pTHX_ I32 type, I32 flags, char *pv)
{
    dVAR;
    const bool utf8 = cBOOL(flags & SVf_UTF8);
    PVOP *pvop;

    flags &= ~SVf_UTF8;

    assert((PL_opargs[type] & OA_CLASS_MASK) == OA_PVOP_OR_SVOP
	|| type == OP_RUNCV || type == OP_CUSTOM
	|| (PL_opargs[type] & OA_CLASS_MASK) == OA_LOOPEXOP);

    NewOp(1101, pvop, 1, PVOP);
    OpTYPE_set(pvop, type);
    pvop->op_pv = pv;
    pvop->op_next = (OP*)pvop;
    pvop->op_flags = (U8)flags;
    pvop->op_private = utf8 ? OPpPV_IS_UTF8 : 0;
    if (PL_opargs[type] & OA_RETSCALAR)
	scalar((OP*)pvop);
    if (PL_opargs[type] & OA_TARGET)
	pvop->op_targ = pad_alloc(type, SVs_PADTMP);
    return CHECKOP(type, pvop);
}

void
Perl_package(pTHX_ OP *o)
{
    SV *const sv = cSVOPo->op_sv;

    PERL_ARGS_ASSERT_PACKAGE;

    SAVEGENERICSV(PL_curstash);
    save_item(PL_curstname);

    PL_curstash = (HV *)SvREFCNT_inc(gv_stashsv(sv, GV_ADD));

    sv_setsv(PL_curstname, sv);

    PL_hints |= HINT_BLOCK_SCOPE;
    PL_parser->copline = NOLINE;

    op_free(o);
}

void
Perl_package_version( pTHX_ OP *v )
{
    U32 savehints = PL_hints;
    PERL_ARGS_ASSERT_PACKAGE_VERSION;
    PL_hints &= ~HINT_STRICT_VARS;
    sv_setsv( GvSV(gv_fetchpvs("VERSION", GV_ADDMULTI, SVt_PV)), cSVOPx(v)->op_sv );
    PL_hints = savehints;
    op_free(v);
}

void
Perl_utilize(pTHX_ int aver, I32 floor, OP *version, OP *idop, OP *arg)
{
    OP *pack;
    OP *imop;
    OP *veop;
    SV *use_version = NULL;

    PERL_ARGS_ASSERT_UTILIZE;

    if (idop->op_type != OP_CONST)
	Perl_croak(aTHX_ "Module name must be constant");

    veop = NULL;

    if (version) {
	SV * const vesv = ((SVOP*)version)->op_sv;

	if (!arg && !SvNIOKp(vesv)) {
	    arg = version;
	}
	else {
	    OP *pack;
	    SV *meth;

	    if (version->op_type != OP_CONST || !SvNIOKp(vesv))
		Perl_croak(aTHX_ "Version number must be a constant number");

	    /* Make copy of idop so we don't free it twice */
	    pack = newSVOP(OP_CONST, 0, newSVsv(((SVOP*)idop)->op_sv));

	    /* Fake up a method call to VERSION */
	    meth = newSVpvs_share("VERSION");
	    veop = op_convert_list(OP_ENTERSUB, OPf_STACKED|OPf_SPECIAL,
			    op_append_elem(OP_LIST,
					op_prepend_elem(OP_LIST, pack, version),
					newMETHOP_named(OP_METHOD_NAMED, 0, meth)));
	}
    }

    /* Fake up an import/unimport */
    if (arg && arg->op_type == OP_STUB) {
	imop = arg;		/* no import on explicit () */
    }
    else if (SvNIOKp(((SVOP*)idop)->op_sv)) {
	imop = NULL;		/* use 5.0; */
	if (aver)
	    use_version = ((SVOP*)idop)->op_sv;
	else
	    idop->op_private |= OPpCONST_NOVER;
    }
    else {
	SV *meth;

	/* Make copy of idop so we don't free it twice */
	pack = newSVOP(OP_CONST, 0, newSVsv(((SVOP*)idop)->op_sv));

	/* Fake up a method call to import/unimport */
	meth = aver
	    ? newSVpvs_share("import") : newSVpvs_share("unimport");
	imop = op_convert_list(OP_ENTERSUB, OPf_STACKED|OPf_SPECIAL,
		       op_append_elem(OP_LIST,
				   op_prepend_elem(OP_LIST, pack, arg),
				   newMETHOP_named(OP_METHOD_NAMED, 0, meth)
		       ));
    }

    /* Fake up the BEGIN {}, which does its thing immediately. */
    newATTRSUB(floor,
	newSVOP(OP_CONST, 0, newSVpvs_share("BEGIN")),
	NULL,
	NULL,
	op_append_elem(OP_LINESEQ,
	    op_append_elem(OP_LINESEQ,
	        newSTATEOP(0, NULL, newUNOP(OP_REQUIRE, 0, idop)),
	        newSTATEOP(0, NULL, veop)),
	    newSTATEOP(0, NULL, imop) ));

    if (use_version) {
	/* Enable the
	 * feature bundle that corresponds to the required version. */
	use_version = sv_2mortal(new_version(use_version));
	S_enable_feature_bundle(aTHX_ use_version);

	/* If a version >= 5.11.0 is requested, strictures are on by default! */
	if (vcmp(use_version,
		 sv_2mortal(upg_version(newSVnv(5.011000), FALSE))) >= 0) {
	    if (!(PL_hints & HINT_EXPLICIT_STRICT_REFS))
		PL_hints |= HINT_STRICT_REFS;
	    if (!(PL_hints & HINT_EXPLICIT_STRICT_SUBS))
		PL_hints |= HINT_STRICT_SUBS;
	    if (!(PL_hints & HINT_EXPLICIT_STRICT_VARS))
		PL_hints |= HINT_STRICT_VARS;
	}
	/* otherwise they are off */
	else {
	    if (!(PL_hints & HINT_EXPLICIT_STRICT_REFS))
		PL_hints &= ~HINT_STRICT_REFS;
	    if (!(PL_hints & HINT_EXPLICIT_STRICT_SUBS))
		PL_hints &= ~HINT_STRICT_SUBS;
	    if (!(PL_hints & HINT_EXPLICIT_STRICT_VARS))
		PL_hints &= ~HINT_STRICT_VARS;
	}
    }

    /* The "did you use incorrect case?" warning used to be here.
     * The problem is that on case-insensitive filesystems one
     * might get false positives for "use" (and "require"):
     * "use Strict" or "require CARP" will work.  This causes
     * portability problems for the script: in case-strict
     * filesystems the script will stop working.
     *
     * The "incorrect case" warning checked whether "use Foo"
     * imported "Foo" to your namespace, but that is wrong, too:
     * there is no requirement nor promise in the language that
     * a Foo.pm should or would contain anything in package "Foo".
     *
     * There is very little Configure-wise that can be done, either:
     * the case-sensitivity of the build filesystem of Perl does not
     * help in guessing the case-sensitivity of the runtime environment.
     */

    PL_hints |= HINT_BLOCK_SCOPE;
    PL_parser->copline = NOLINE;
    COP_SEQMAX_INC; /* Purely for B::*'s benefit */
}

/*
=head1 Embedding Functions

=for apidoc load_module

Loads the module whose name is pointed to by the string part of name.
Note that the actual module name, not its filename, should be given.
Eg, "Foo::Bar" instead of "Foo/Bar.pm".  flags can be any of
C<PERL_LOADMOD_DENY>, C<PERL_LOADMOD_NOIMPORT>, or C<PERL_LOADMOD_IMPORT_OPS>
(or 0 for no flags).  ver, if specified
and not NULL, provides version semantics
similar to C<use Foo::Bar VERSION>.  The optional trailing SV*
arguments can be used to specify arguments to the module's C<import()>
method, similar to C<use Foo::Bar VERSION LIST>.  They must be
terminated with a final C<NULL> pointer.  Note that this list can only
be omitted when the C<PERL_LOADMOD_NOIMPORT> flag has been used.
Otherwise at least a single C<NULL> pointer to designate the default
import list is required.

The reference count for each specified C<SV*> parameter is decremented.

=cut */

void
Perl_load_module(pTHX_ U32 flags, SV *name, SV *ver, ...)
{
    va_list args;

    PERL_ARGS_ASSERT_LOAD_MODULE;

    va_start(args, ver);
    vload_module(flags, name, ver, &args);
    va_end(args);
}

#ifdef PERL_IMPLICIT_CONTEXT
void
Perl_load_module_nocontext(U32 flags, SV *name, SV *ver, ...)
{
    dTHX;
    va_list args;
    PERL_ARGS_ASSERT_LOAD_MODULE_NOCONTEXT;
    va_start(args, ver);
    vload_module(flags, name, ver, &args);
    va_end(args);
}
#endif

void
Perl_vload_module(pTHX_ U32 flags, SV *name, SV *ver, va_list *args)
{
    OP *veop, *imop;
    OP * const modname = newSVOP(OP_CONST, 0, name);

    PERL_ARGS_ASSERT_VLOAD_MODULE;

    modname->op_private |= OPpCONST_BARE;
    if (ver) {
	veop = newSVOP(OP_CONST, 0, ver);
    }
    else
	veop = NULL;
    if (flags & PERL_LOADMOD_NOIMPORT) {
	imop = sawparens(newNULLLIST());
    }
    else if (flags & PERL_LOADMOD_IMPORT_OPS) {
	imop = va_arg(*args, OP*);
    }
    else {
	SV *sv;
	imop = NULL;
	sv = va_arg(*args, SV*);
	while (sv) {
	    imop = op_append_elem(OP_LIST, imop, newSVOP(OP_CONST, 0, sv));
	    sv = va_arg(*args, SV*);
	}
    }

    /* utilize() fakes up a BEGIN { require ..; import ... }, so make sure
     * that it has a PL_parser to play with while doing that, and also
     * that it doesn't mess with any existing parser, by creating a tmp
     * new parser with lex_start(). This won't actually be used for much,
     * since pp_require() will create another parser for the real work.
     * The ENTER/LEAVE pair protect callers from any side effects of use.  */

    ENTER;
    SAVEVPTR(PL_curcop);
    lex_start(NULL, NULL, LEX_START_SAME_FILTER);
    utilize(!(flags & PERL_LOADMOD_DENY), start_subparse(FALSE, 0),
	    veop, modname, imop);
    LEAVE;
}

PERL_STATIC_INLINE OP *
S_new_entersubop(pTHX_ GV *gv, OP *arg)
{
    return newUNOP(OP_ENTERSUB, OPf_STACKED,
		   newLISTOP(OP_LIST, 0, arg,
			     newUNOP(OP_RV2CV, 0,
				     newGVOP(OP_GV, 0, gv))));
}

OP *
Perl_dofile(pTHX_ OP *term, I32 force_builtin)
{
    OP *doop;
    GV *gv;

    PERL_ARGS_ASSERT_DOFILE;

    if (!force_builtin && (gv = gv_override("do", 2))) {
	doop = S_new_entersubop(aTHX_ gv, term);
    }
    else {
	doop = newUNOP(OP_DOFILE, 0, scalar(term));
    }
    return doop;
}

/*
=head1 Optree construction

=for apidoc Am|OP *|newSLICEOP|I32 flags|OP *subscript|OP *listval

Constructs, checks, and returns an C<lslice> (list slice) op.  C<flags>
gives the eight bits of C<op_flags>, except that C<OPf_KIDS> will
be set automatically, and, shifted up eight bits, the eight bits of
C<op_private>, except that the bit with value 1 or 2 is automatically
set as required.  C<listval> and C<subscript> supply the parameters of
the slice; they are consumed by this function and become part of the
constructed op tree.

=cut
*/

OP *
Perl_newSLICEOP(pTHX_ I32 flags, OP *subscript, OP *listval)
{
    return newBINOP(OP_LSLICE, flags,
	    list(force_list(subscript, 1)),
	    list(force_list(listval,   1)) );
}

#define ASSIGN_LIST   1
#define ASSIGN_REF    2

STATIC I32
S_assignment_type(pTHX_ const OP *o)
{
    unsigned type;
    U8 flags;
    U8 ret;

    if (!o)
	return TRUE;

    if ((o->op_type == OP_NULL) && (o->op_flags & OPf_KIDS))
	o = cUNOPo->op_first;

    flags = o->op_flags;
    type = o->op_type;
    if (type == OP_COND_EXPR) {
        OP * const sib = OpSIBLING(cLOGOPo->op_first);
        const I32 t = assignment_type(sib);
        const I32 f = assignment_type(OpSIBLING(sib));

	if (t == ASSIGN_LIST && f == ASSIGN_LIST)
	    return ASSIGN_LIST;
	if ((t == ASSIGN_LIST) ^ (f == ASSIGN_LIST))
	    yyerror("Assignment to both a list and a scalar");
	return FALSE;
    }

    if (type == OP_SREFGEN)
    {
	OP * const kid = cUNOPx(cUNOPo->op_first)->op_first;
	type = kid->op_type;
	flags |= kid->op_flags;
	if (!(flags & OPf_PARENS)
	  && (kid->op_type == OP_RV2AV || kid->op_type == OP_PADAV ||
	      kid->op_type == OP_RV2HV || kid->op_type == OP_PADHV ))
	    return ASSIGN_REF;
	ret = ASSIGN_REF;
    }
    else ret = 0;

    if (type == OP_LIST &&
	(flags & OPf_WANT) == OPf_WANT_SCALAR &&
	o->op_private & OPpLVAL_INTRO)
	return ret;

    if (type == OP_LIST || flags & OPf_PARENS ||
	type == OP_RV2AV || type == OP_RV2HV ||
	type == OP_ASLICE || type == OP_HSLICE ||
        type == OP_KVASLICE || type == OP_KVHSLICE || type == OP_REFGEN)
	return TRUE;

    if (type == OP_PADAV || type == OP_PADHV)
	return TRUE;

    if (type == OP_RV2SV)
	return ret;

    return ret;
}


/*
=for apidoc Am|OP *|newASSIGNOP|I32 flags|OP *left|I32 optype|OP *right

Constructs, checks, and returns an assignment op.  C<left> and C<right>
supply the parameters of the assignment; they are consumed by this
function and become part of the constructed op tree.

If C<optype> is C<OP_ANDASSIGN>, C<OP_ORASSIGN>, or C<OP_DORASSIGN>, then
a suitable conditional optree is constructed.  If C<optype> is the opcode
of a binary operator, such as C<OP_BIT_OR>, then an op is constructed that
performs the binary operation and assigns the result to the left argument.
Either way, if C<optype> is non-zero then C<flags> has no effect.

If C<optype> is zero, then a plain scalar or list assignment is
constructed.  Which type of assignment it is is automatically determined.
C<flags> gives the eight bits of C<op_flags>, except that C<OPf_KIDS>
will be set automatically, and, shifted up eight bits, the eight bits
of C<op_private>, except that the bit with value 1 or 2 is automatically
set as required.

=cut
*/

OP *
Perl_newASSIGNOP(pTHX_ I32 flags, OP *left, I32 optype, OP *right)
{
    OP *o;
    I32 assign_type;

    if (optype) {
	if (optype == OP_ANDASSIGN || optype == OP_ORASSIGN || optype == OP_DORASSIGN) {
	    return newLOGOP(optype, 0,
		op_lvalue(scalar(left), optype),
		newUNOP(OP_SASSIGN, 0, scalar(right)));
	}
	else {
	    return newBINOP(optype, OPf_STACKED,
		op_lvalue(scalar(left), optype), scalar(right));
	}
    }

    if ((assign_type = assignment_type(left)) == ASSIGN_LIST) {
	static const char no_list_state[] = "Initialization of state variables"
	    " in list context currently forbidden";
	OP *curop;

	if (left->op_type == OP_ASLICE || left->op_type == OP_HSLICE)
	    left->op_private &= ~ OPpSLICEWARNING;

	PL_modcount = 0;
	left = op_lvalue(left, OP_AASSIGN);
	curop = list(force_list(left, 1));
	o = newBINOP(OP_AASSIGN, flags, list(force_list(right, 1)), curop);
	o->op_private = (U8)(0 | (flags >> 8));

	if (OP_TYPE_IS_OR_WAS(left, OP_LIST))
	{
	    OP* lop = ((LISTOP*)left)->op_first;
	    while (lop) {
		if ((lop->op_type == OP_PADSV ||
		     lop->op_type == OP_PADAV ||
		     lop->op_type == OP_PADHV ||
		     lop->op_type == OP_PADANY)
		  && (lop->op_private & OPpPAD_STATE)
                )
                    yyerror(no_list_state);
		lop = OpSIBLING(lop);
	    }
	}
	else if (  (left->op_private & OPpLVAL_INTRO)
                && (left->op_private & OPpPAD_STATE)
		&& (   left->op_type == OP_PADSV
		    || left->op_type == OP_PADAV
		    || left->op_type == OP_PADHV
		    || left->op_type == OP_PADANY)
        ) {
		/* All single variable list context state assignments, hence
		   state ($a) = ...
		   (state $a) = ...
		   state @@a = ...
		   state (@@a) = ...
		   (state @@a) = ...
		   state %a = ...
		   state (%a) = ...
		   (state %a) = ...
		*/
		yyerror(no_list_state);
	}

	if (right && right->op_type == OP_SPLIT
	 && !(right->op_flags & OPf_STACKED)) {
	    OP* tmpop = ((LISTOP*)right)->op_first;
	    PMOP * const pm = (PMOP*)tmpop;
	    assert (tmpop && (tmpop->op_type == OP_PUSHRE));
	    if (
#ifdef USE_ITHREADS
		    !pm->op_pmreplrootu.op_pmtargetoff
#else
		    !pm->op_pmreplrootu.op_pmtargetgv
#endif
		 && !pm->op_targ
		) {
		    if (!(left->op_private & OPpLVAL_INTRO) &&
		        ( (left->op_type == OP_RV2AV &&
			  (tmpop=((UNOP*)left)->op_first)->op_type==OP_GV)
		        || left->op_type == OP_PADAV )
			) {
			if (tmpop != (OP *)pm) {
#ifdef USE_ITHREADS
			  pm->op_pmreplrootu.op_pmtargetoff
			    = cPADOPx(tmpop)->op_padix;
			  cPADOPx(tmpop)->op_padix = 0;	/* steal it */
#else
			  pm->op_pmreplrootu.op_pmtargetgv
			    = MUTABLE_GV(cSVOPx(tmpop)->op_sv);
			  cSVOPx(tmpop)->op_sv = NULL;	/* steal it */
#endif
			  right->op_private |=
			    left->op_private & OPpOUR_INTRO;
			}
			else {
			    pm->op_targ = left->op_targ;
			    left->op_targ = 0; /* filch it */
			}
		      detach_split:
			tmpop = cUNOPo->op_first;	/* to list (nulled) */
			tmpop = ((UNOP*)tmpop)->op_first; /* to pushmark */
                        /* detach rest of siblings from o subtree,
                         * and free subtree */
                        op_sibling_splice(cUNOPo->op_first, tmpop, -1, NULL);
			op_free(o);			/* blow off assign */
			right->op_flags &= ~OPf_WANT;
				/* "I don't know and I don't care." */
			return right;
		    }
		    else if (left->op_type == OP_RV2AV
			  || left->op_type == OP_PADAV)
		    {
			/* Detach the array.  */
#ifdef DEBUGGING
			OP * const ary =
#endif
			op_sibling_splice(cBINOPo->op_last,
					  cUNOPx(cBINOPo->op_last)
						->op_first, 1, NULL);
			assert(ary == left);
			/* Attach it to the split.  */
			op_sibling_splice(right, cLISTOPx(right)->op_last,
					  0, left);
			right->op_flags |= OPf_STACKED;
			/* Detach split and expunge aassign as above.  */
			goto detach_split;
		    }
		    else if (PL_modcount < RETURN_UNLIMITED_NUMBER &&
			    ((LISTOP*)right)->op_last->op_type == OP_CONST)
		    {
			SV ** const svp =
			    &((SVOP*)((LISTOP*)right)->op_last)->op_sv;
			SV * const sv = *svp;
			if (SvIOK(sv) && SvIVX(sv) == 0)
			{
			  if (right->op_private & OPpSPLIT_IMPLIM) {
			    /* our own SV, created in ck_split */
			    SvREADONLY_off(sv);
			    sv_setiv(sv, PL_modcount+1);
			  }
			  else {
			    /* SV may belong to someone else */
			    SvREFCNT_dec(sv);
			    *svp = newSViv(PL_modcount+1);
			  }
			}
		    }
	    }
	}
	return o;
    }
    if (assign_type == ASSIGN_REF)
	return newBINOP(OP_REFASSIGN, flags, scalar(right), left);
    if (!right)
	right = newOP(OP_UNDEF, 0);
    if (right->op_type == OP_READLINE) {
	right->op_flags |= OPf_STACKED;
	return newBINOP(OP_NULL, flags, op_lvalue(scalar(left), OP_SASSIGN),
		scalar(right));
    }
    else {
	o = newBINOP(OP_SASSIGN, flags,
	    scalar(right), op_lvalue(scalar(left), OP_SASSIGN) );
    }
    return o;
}

/*
=for apidoc Am|OP *|newSTATEOP|I32 flags|char *label|OP *o

Constructs a state op (COP).  The state op is normally a C<nextstate> op,
but will be a C<dbstate> op if debugging is enabled for currently-compiled
code.  The state op is populated from C<PL_curcop> (or C<PL_compiling>).
If C<label> is non-null, it supplies the name of a label to attach to
the state op; this function takes ownership of the memory pointed at by
C<label>, and will free it.  C<flags> gives the eight bits of C<op_flags>
for the state op.

If C<o> is null, the state op is returned.  Otherwise the state op is
combined with C<o> into a C<lineseq> list op, which is returned.  C<o>
is consumed by this function and becomes part of the returned op tree.

=cut
*/

OP *
Perl_newSTATEOP(pTHX_ I32 flags, char *label, OP *o)
{
    dVAR;
    const U32 seq = intro_my();
    const U32 utf8 = flags & SVf_UTF8;
    COP *cop;

    PL_parser->parsed_sub = 0;

    flags &= ~SVf_UTF8;

    NewOp(1101, cop, 1, COP);
    if (PERLDB_LINE && CopLINE(PL_curcop) && PL_curstash != PL_debstash) {
        OpTYPE_set(cop, OP_DBSTATE);
    }
    else {
        OpTYPE_set(cop, OP_NEXTSTATE);
    }
    cop->op_flags = (U8)flags;
    CopHINTS_set(cop, PL_hints);
#ifdef VMS
    if (VMSISH_HUSHED) cop->op_private |= OPpHUSH_VMSISH;
#endif
    cop->op_next = (OP*)cop;

    cop->cop_seq = seq;
    cop->cop_warnings = DUP_WARNINGS(PL_curcop->cop_warnings);
    CopHINTHASH_set(cop, cophh_copy(CopHINTHASH_get(PL_curcop)));
    if (label) {
	Perl_cop_store_label(aTHX_ cop, label, strlen(label), utf8);

	PL_hints |= HINT_BLOCK_SCOPE;
	/* It seems that we need to defer freeing this pointer, as other parts
	   of the grammar end up wanting to copy it after this op has been
	   created. */
	SAVEFREEPV(label);
    }

    if (PL_parser->preambling != NOLINE) {
        CopLINE_set(cop, PL_parser->preambling);
        PL_parser->copline = NOLINE;
    }
    else if (PL_parser->copline == NOLINE)
        CopLINE_set(cop, CopLINE(PL_curcop));
    else {
	CopLINE_set(cop, PL_parser->copline);
	PL_parser->copline = NOLINE;
    }
#ifdef USE_ITHREADS
    CopFILE_set(cop, CopFILE(PL_curcop));	/* XXX share in a pvtable? */
#else
    CopFILEGV_set(cop, CopFILEGV(PL_curcop));
#endif
    CopSTASH_set(cop, PL_curstash);

    if (cop->op_type == OP_DBSTATE) {
	/* this line can have a breakpoint - store the cop in IV */
	AV *av = CopFILEAVx(PL_curcop);
	if (av) {
	    SV * const * const svp = av_fetch(av, CopLINE(cop), FALSE);
	    if (svp && *svp != &PL_sv_undef ) {
		(void)SvIOK_on(*svp);
		SvIV_set(*svp, PTR2IV(cop));
	    }
	}
    }

    if (flags & OPf_SPECIAL)
	op_null((OP*)cop);
    return op_prepend_elem(OP_LINESEQ, (OP*)cop, o);
}

/*
=for apidoc Am|OP *|newLOGOP|I32 type|I32 flags|OP *first|OP *other

Constructs, checks, and returns a logical (flow control) op.  C<type>
is the opcode.  C<flags> gives the eight bits of C<op_flags>, except
that C<OPf_KIDS> will be set automatically, and, shifted up eight bits,
the eight bits of C<op_private>, except that the bit with value 1 is
automatically set.  C<first> supplies the expression controlling the
flow, and C<other> supplies the side (alternate) chain of ops; they are
consumed by this function and become part of the constructed op tree.

=cut
*/

OP *
Perl_newLOGOP(pTHX_ I32 type, I32 flags, OP *first, OP *other)
{
    PERL_ARGS_ASSERT_NEWLOGOP;

    return new_logop(type, flags, &first, &other);
}

STATIC OP *
S_search_const(pTHX_ OP *o)
{
    PERL_ARGS_ASSERT_SEARCH_CONST;

    switch (o->op_type) {
	case OP_CONST:
	    return o;
	case OP_NULL:
	    if (o->op_flags & OPf_KIDS)
		return search_const(cUNOPo->op_first);
	    break;
	case OP_LEAVE:
	case OP_SCOPE:
	case OP_LINESEQ:
	{
	    OP *kid;
	    if (!(o->op_flags & OPf_KIDS))
		return NULL;
	    kid = cLISTOPo->op_first;
	    do {
		switch (kid->op_type) {
		    case OP_ENTER:
		    case OP_NULL:
		    case OP_NEXTSTATE:
			kid = OpSIBLING(kid);
			break;
		    default:
			if (kid != cLISTOPo->op_last)
			    return NULL;
			goto last;
		}
	    } while (kid);
	    if (!kid)
		kid = cLISTOPo->op_last;
          last:
	    return search_const(kid);
	}
    }

    return NULL;
}

STATIC OP *
S_new_logop(pTHX_ I32 type, I32 flags, OP** firstp, OP** otherp)
{
    dVAR;
    LOGOP *logop;
    OP *o;
    OP *first;
    OP *other;
    OP *cstop = NULL;
    int prepend_not = 0;

    PERL_ARGS_ASSERT_NEW_LOGOP;

    first = *firstp;
    other = *otherp;

    /* [perl #59802]: Warn about things like "return $a or $b", which
       is parsed as "(return $a) or $b" rather than "return ($a or
       $b)".  NB: This also applies to xor, which is why we do it
       here.
     */
    switch (first->op_type) {
    case OP_NEXT:
    case OP_LAST:
    case OP_REDO:
	/* XXX: Perhaps we should emit a stronger warning for these.
	   Even with the high-precedence operator they don't seem to do
	   anything sensible.

	   But until we do, fall through here.
         */
    case OP_RETURN:
    case OP_EXIT:
    case OP_DIE:
    case OP_GOTO:
	/* XXX: Currently we allow people to "shoot themselves in the
	   foot" by explicitly writing "(return $a) or $b".

	   Warn unless we are looking at the result from folding or if
	   the programmer explicitly grouped the operators like this.
	   The former can occur with e.g.

		use constant FEATURE => ( $] >= ... );
		sub { not FEATURE and return or do_stuff(); }
	 */
	if (!first->op_folded && !(first->op_flags & OPf_PARENS))
	    Perl_ck_warner(aTHX_ packWARN(WARN_SYNTAX),
	                   "Possible precedence issue with control flow operator");
	/* XXX: Should we optimze this to "return $a;" (i.e. remove
	   the "or $b" part)?
	*/
	break;
    }

    if (type == OP_XOR)		/* Not short circuit, but here by precedence. */
	return newBINOP(type, flags, scalar(first), scalar(other));

    assert((PL_opargs[type] & OA_CLASS_MASK) == OA_LOGOP
	|| type == OP_CUSTOM);

    scalarboolean(first);
    /* optimize AND and OR ops that have NOTs as children */
    if (first->op_type == OP_NOT
	&& (first->op_flags & OPf_KIDS)
	&& ((first->op_flags & OPf_SPECIAL) /* unless ($x) { } */
	    || (other->op_type == OP_NOT))  /* if (!$x && !$y) { } */
	) {
	if (type == OP_AND || type == OP_OR) {
	    if (type == OP_AND)
		type = OP_OR;
	    else
		type = OP_AND;
	    op_null(first);
	    if (other->op_type == OP_NOT) { /* !a AND|OR !b => !(a OR|AND b) */
		op_null(other);
		prepend_not = 1; /* prepend a NOT op later */
	    }
	}
    }
    /* search for a constant op that could let us fold the test */
    if ((cstop = search_const(first))) {
	if (cstop->op_private & OPpCONST_STRICT)
	    no_bareword_allowed(cstop);
	else if ((cstop->op_private & OPpCONST_BARE))
		Perl_ck_warner(aTHX_ packWARN(WARN_BAREWORD), "Bareword found in conditional");
	if ((type == OP_AND &&  SvTRUE(((SVOP*)cstop)->op_sv)) ||
	    (type == OP_OR  && !SvTRUE(((SVOP*)cstop)->op_sv)) ||
	    (type == OP_DOR && !SvOK(((SVOP*)cstop)->op_sv))) {
	    *firstp = NULL;
	    if (other->op_type == OP_CONST)
		other->op_private |= OPpCONST_SHORTCIRCUIT;
	    op_free(first);
	    if (other->op_type == OP_LEAVE)
		other = newUNOP(OP_NULL, OPf_SPECIAL, other);
	    else if (other->op_type == OP_MATCH
	          || other->op_type == OP_SUBST
	          || other->op_type == OP_TRANSR
	          || other->op_type == OP_TRANS)
		/* Mark the op as being unbindable with =~ */
		other->op_flags |= OPf_SPECIAL;

	    other->op_folded = 1;
	    return other;
	}
	else {
	    /* check for C<my $x if 0>, or C<my($x,$y) if 0> */
	    const OP *o2 = other;
	    if ( ! (o2->op_type == OP_LIST
		    && (( o2 = cUNOPx(o2)->op_first))
		    && o2->op_type == OP_PUSHMARK
		    && (( o2 = OpSIBLING(o2))) )
	    )
		o2 = other;
	    if ((o2->op_type == OP_PADSV || o2->op_type == OP_PADAV
			|| o2->op_type == OP_PADHV)
		&& o2->op_private & OPpLVAL_INTRO
		&& !(o2->op_private & OPpPAD_STATE))
	    {
		Perl_ck_warner_d(aTHX_ packWARN(WARN_DEPRECATED),
				 "Deprecated use of my() in false conditional");
	    }

	    *otherp = NULL;
	    if (cstop->op_type == OP_CONST)
		cstop->op_private |= OPpCONST_SHORTCIRCUIT;
	        op_free(other);
	    return first;
	}
    }
    else if ((first->op_flags & OPf_KIDS) && type != OP_DOR
	&& ckWARN(WARN_MISC)) /* [#24076] Don't warn for <FH> err FOO. */
    {
	const OP * const k1 = ((UNOP*)first)->op_first;
	const OP * const k2 = OpSIBLING(k1);
	OPCODE warnop = 0;
	switch (first->op_type)
	{
	case OP_NULL:
	    if (k2 && k2->op_type == OP_READLINE
		  && (k2->op_flags & OPf_STACKED)
		  && ((k1->op_flags & OPf_WANT) == OPf_WANT_SCALAR))
	    {
		warnop = k2->op_type;
	    }
	    break;

	case OP_SASSIGN:
	    if (k1->op_type == OP_READDIR
		  || k1->op_type == OP_GLOB
		  || (k1->op_type == OP_NULL && k1->op_targ == OP_GLOB)
                 || k1->op_type == OP_EACH
                 || k1->op_type == OP_AEACH)
	    {
		warnop = ((k1->op_type == OP_NULL)
			  ? (OPCODE)k1->op_targ : k1->op_type);
	    }
	    break;
	}
	if (warnop) {
	    const line_t oldline = CopLINE(PL_curcop);
            /* This ensures that warnings are reported at the first line
               of the construction, not the last.  */
	    CopLINE_set(PL_curcop, PL_parser->copline);
	    Perl_warner(aTHX_ packWARN(WARN_MISC),
		 "Value of %s%s can be \"0\"; test with defined()",
		 PL_op_desc[warnop],
		 ((warnop == OP_READLINE || warnop == OP_GLOB)
		  ? " construct" : "() operator"));
	    CopLINE_set(PL_curcop, oldline);
	}
    }

    if (!other)
	return first;

    if (type == OP_ANDASSIGN || type == OP_ORASSIGN || type == OP_DORASSIGN)
	other->op_private |= OPpASSIGN_BACKWARDS;  /* other is an OP_SASSIGN */

    logop = S_alloc_LOGOP(aTHX_ type, first, LINKLIST(other));
    logop->op_flags |= (U8)flags;
    logop->op_private = (U8)(1 | (flags >> 8));

    /* establish postfix order */
    logop->op_next = LINKLIST(first);
    first->op_next = (OP*)logop;
    assert(!OpHAS_SIBLING(first));
    op_sibling_splice((OP*)logop, first, 0, other);

    CHECKOP(type,logop);

    o = newUNOP(prepend_not ? OP_NOT : OP_NULL,
		PL_opargs[type] & OA_RETSCALAR ? OPf_WANT_SCALAR : 0,
		(OP*)logop);
    other->op_next = o;

    return o;
}

/*
=for apidoc Am|OP *|newCONDOP|I32 flags|OP *first|OP *trueop|OP *falseop

Constructs, checks, and returns a conditional-expression (C<cond_expr>)
op.  C<flags> gives the eight bits of C<op_flags>, except that C<OPf_KIDS>
will be set automatically, and, shifted up eight bits, the eight bits of
C<op_private>, except that the bit with value 1 is automatically set.
C<first> supplies the expression selecting between the two branches,
and C<trueop> and C<falseop> supply the branches; they are consumed by
this function and become part of the constructed op tree.

=cut
*/

OP *
Perl_newCONDOP(pTHX_ I32 flags, OP *first, OP *trueop, OP *falseop)
{
    dVAR;
    LOGOP *logop;
    OP *start;
    OP *o;
    OP *cstop;

    PERL_ARGS_ASSERT_NEWCONDOP;

    if (!falseop)
	return newLOGOP(OP_AND, 0, first, trueop);
    if (!trueop)
	return newLOGOP(OP_OR, 0, first, falseop);

    scalarboolean(first);
    if ((cstop = search_const(first))) {
	/* Left or right arm of the conditional?  */
	const bool left = SvTRUE(((SVOP*)cstop)->op_sv);
	OP *live = left ? trueop : falseop;
	OP *const dead = left ? falseop : trueop;
        if (cstop->op_private & OPpCONST_BARE &&
	    cstop->op_private & OPpCONST_STRICT) {
	    no_bareword_allowed(cstop);
	}
        op_free(first);
        op_free(dead);
	if (live->op_type == OP_LEAVE)
	    live = newUNOP(OP_NULL, OPf_SPECIAL, live);
	else if (live->op_type == OP_MATCH || live->op_type == OP_SUBST
	      || live->op_type == OP_TRANS || live->op_type == OP_TRANSR)
	    /* Mark the op as being unbindable with =~ */
	    live->op_flags |= OPf_SPECIAL;
	live->op_folded = 1;
	return live;
    }
    logop = S_alloc_LOGOP(aTHX_ OP_COND_EXPR, first, LINKLIST(trueop));
    logop->op_flags |= (U8)flags;
    logop->op_private = (U8)(1 | (flags >> 8));
    logop->op_next = LINKLIST(falseop);

    CHECKOP(OP_COND_EXPR, /* that's logop->op_type */
	    logop);

    /* establish postfix order */
    start = LINKLIST(first);
    first->op_next = (OP*)logop;

    /* make first, trueop, falseop siblings */
    op_sibling_splice((OP*)logop, first,  0, trueop);
    op_sibling_splice((OP*)logop, trueop, 0, falseop);

    o = newUNOP(OP_NULL, 0, (OP*)logop);

    trueop->op_next = falseop->op_next = o;

    o->op_next = start;
    return o;
}

/*
=for apidoc Am|OP *|newRANGE|I32 flags|OP *left|OP *right

Constructs and returns a C<range> op, with subordinate C<flip> and
C<flop> ops.  C<flags> gives the eight bits of C<op_flags> for the
C<flip> op and, shifted up eight bits, the eight bits of C<op_private>
for both the C<flip> and C<range> ops, except that the bit with value
1 is automatically set.  C<left> and C<right> supply the expressions
controlling the endpoints of the range; they are consumed by this function
and become part of the constructed op tree.

=cut
*/

OP *
Perl_newRANGE(pTHX_ I32 flags, OP *left, OP *right)
{
    LOGOP *range;
    OP *flip;
    OP *flop;
    OP *leftstart;
    OP *o;

    PERL_ARGS_ASSERT_NEWRANGE;

    range = S_alloc_LOGOP(aTHX_ OP_RANGE, left, LINKLIST(right));
    range->op_flags = OPf_KIDS;
    leftstart = LINKLIST(left);
    range->op_private = (U8)(1 | (flags >> 8));

    /* make left and right siblings */
    op_sibling_splice((OP*)range, left, 0, right);

    range->op_next = (OP*)range;
    flip = newUNOP(OP_FLIP, flags, (OP*)range);
    flop = newUNOP(OP_FLOP, 0, flip);
    o = newUNOP(OP_NULL, 0, flop);
    LINKLIST(flop);
    range->op_next = leftstart;

    left->op_next = flip;
    right->op_next = flop;

    range->op_targ =
	pad_add_name_pvn("$", 1, padadd_NO_DUP_CHECK|padadd_STATE, 0, 0);
    sv_upgrade(PAD_SV(range->op_targ), SVt_PVNV);
    flip->op_targ =
	pad_add_name_pvn("$", 1, padadd_NO_DUP_CHECK|padadd_STATE, 0, 0);;
    sv_upgrade(PAD_SV(flip->op_targ), SVt_PVNV);
    SvPADTMP_on(PAD_SV(flip->op_targ));

    flip->op_private =  left->op_type == OP_CONST ? OPpFLIP_LINENUM : 0;
    flop->op_private = right->op_type == OP_CONST ? OPpFLIP_LINENUM : 0;

    /* check barewords before they might be optimized aways */
    if (flip->op_private && cSVOPx(left)->op_private & OPpCONST_STRICT)
	no_bareword_allowed(left);
    if (flop->op_private && cSVOPx(right)->op_private & OPpCONST_STRICT)
	no_bareword_allowed(right);

    flip->op_next = o;
    if (!flip->op_private || !flop->op_private)
	LINKLIST(o);		/* blow off optimizer unless constant */

    return o;
}

/*
=for apidoc Am|OP *|newLOOPOP|I32 flags|I32 debuggable|OP *expr|OP *block

Constructs, checks, and returns an op tree expressing a loop.  This is
only a loop in the control flow through the op tree; it does not have
the heavyweight loop structure that allows exiting the loop by C<last>
and suchlike.  C<flags> gives the eight bits of C<op_flags> for the
top-level op, except that some bits will be set automatically as required.
C<expr> supplies the expression controlling loop iteration, and C<block>
supplies the body of the loop; they are consumed by this function and
become part of the constructed op tree.  C<debuggable> is currently
unused and should always be 1.

=cut
*/

OP *
Perl_newLOOPOP(pTHX_ I32 flags, I32 debuggable, OP *expr, OP *block)
{
    OP* listop;
    OP* o;
    const bool once = block && block->op_flags & OPf_SPECIAL &&
		      block->op_type == OP_NULL;

    PERL_UNUSED_ARG(debuggable);

    if (expr) {
	if (once && (
	      (expr->op_type == OP_CONST && !SvTRUE(((SVOP*)expr)->op_sv))
	   || (  expr->op_type == OP_NOT
	      && cUNOPx(expr)->op_first->op_type == OP_CONST
	      && SvTRUE(cSVOPx_sv(cUNOPx(expr)->op_first))
	      )
	   ))
	    /* Return the block now, so that S_new_logop does not try to
	       fold it away. */
	    return block;	/* do {} while 0 does once */
	if (expr->op_type == OP_READLINE
	    || expr->op_type == OP_READDIR
	    || expr->op_type == OP_GLOB
	    || expr->op_type == OP_EACH || expr->op_type == OP_AEACH
	    || (expr->op_type == OP_NULL && expr->op_targ == OP_GLOB)) {
	    expr = newUNOP(OP_DEFINED, 0,
		newASSIGNOP(0, newDEFSVOP(), 0, expr) );
	} else if (expr->op_flags & OPf_KIDS) {
	    const OP * const k1 = ((UNOP*)expr)->op_first;
	    const OP * const k2 = k1 ? OpSIBLING(k1) : NULL;
	    switch (expr->op_type) {
	      case OP_NULL:
		if (k2 && (k2->op_type == OP_READLINE || k2->op_type == OP_READDIR)
		      && (k2->op_flags & OPf_STACKED)
		      && ((k1->op_flags & OPf_WANT) == OPf_WANT_SCALAR))
		    expr = newUNOP(OP_DEFINED, 0, expr);
		break;

	      case OP_SASSIGN:
		if (k1 && (k1->op_type == OP_READDIR
		      || k1->op_type == OP_GLOB
		      || (k1->op_type == OP_NULL && k1->op_targ == OP_GLOB)
                     || k1->op_type == OP_EACH
                     || k1->op_type == OP_AEACH))
		    expr = newUNOP(OP_DEFINED, 0, expr);
		break;
	    }
	}
    }

    /* if block is null, the next op_append_elem() would put UNSTACK, a scalar
     * op, in listop. This is wrong. [perl #27024] */
    if (!block)
	block = newOP(OP_NULL, 0);
    listop = op_append_elem(OP_LINESEQ, block, newOP(OP_UNSTACK, 0));
    o = new_logop(OP_AND, 0, &expr, &listop);

    if (once) {
	ASSUME(listop);
    }

    if (listop)
	((LISTOP*)listop)->op_last->op_next = LINKLIST(o);

    if (once && o != listop)
    {
	assert(cUNOPo->op_first->op_type == OP_AND
	    || cUNOPo->op_first->op_type == OP_OR);
	o->op_next = ((LOGOP*)cUNOPo->op_first)->op_other;
    }

    if (o == listop)
	o = newUNOP(OP_NULL, 0, o);	/* or do {} while 1 loses outer block */

    o->op_flags |= flags;
    o = op_scope(o);
    o->op_flags |= OPf_SPECIAL;	/* suppress cx_popblock() curpm restoration*/
    return o;
}

/*
=for apidoc Am|OP *|newWHILEOP|I32 flags|I32 debuggable|LOOP *loop|OP *expr|OP *block|OP *cont|I32 has_my

Constructs, checks, and returns an op tree expressing a C<while> loop.
This is a heavyweight loop, with structure that allows exiting the loop
by C<last> and suchlike.

C<loop> is an optional preconstructed C<enterloop> op to use in the
loop; if it is null then a suitable op will be constructed automatically.
C<expr> supplies the loop's controlling expression.  C<block> supplies the
main body of the loop, and C<cont> optionally supplies a C<continue> block
that operates as a second half of the body.  All of these optree inputs
are consumed by this function and become part of the constructed op tree.

C<flags> gives the eight bits of C<op_flags> for the C<leaveloop>
op and, shifted up eight bits, the eight bits of C<op_private> for
the C<leaveloop> op, except that (in both cases) some bits will be set
automatically.  C<debuggable> is currently unused and should always be 1.
C<has_my> can be supplied as true to force the
loop body to be enclosed in its own scope.

=cut
*/

OP *
Perl_newWHILEOP(pTHX_ I32 flags, I32 debuggable, LOOP *loop,
	OP *expr, OP *block, OP *cont, I32 has_my)
{
    dVAR;
    OP *redo;
    OP *next = NULL;
    OP *listop;
    OP *o;
    U8 loopflags = 0;

    PERL_UNUSED_ARG(debuggable);

    if (expr) {
	if (expr->op_type == OP_READLINE
         || expr->op_type == OP_READDIR
         || expr->op_type == OP_GLOB
	 || expr->op_type == OP_EACH || expr->op_type == OP_AEACH
		     || (expr->op_type == OP_NULL && expr->op_targ == OP_GLOB)) {
	    expr = newUNOP(OP_DEFINED, 0,
		newASSIGNOP(0, newDEFSVOP(), 0, expr) );
	} else if (expr->op_flags & OPf_KIDS) {
	    const OP * const k1 = ((UNOP*)expr)->op_first;
	    const OP * const k2 = (k1) ? OpSIBLING(k1) : NULL;
	    switch (expr->op_type) {
	      case OP_NULL:
		if (k2 && (k2->op_type == OP_READLINE || k2->op_type == OP_READDIR)
		      && (k2->op_flags & OPf_STACKED)
		      && ((k1->op_flags & OPf_WANT) == OPf_WANT_SCALAR))
		    expr = newUNOP(OP_DEFINED, 0, expr);
		break;

	      case OP_SASSIGN:
		if (k1 && (k1->op_type == OP_READDIR
		      || k1->op_type == OP_GLOB
		      || (k1->op_type == OP_NULL && k1->op_targ == OP_GLOB)
                     || k1->op_type == OP_EACH
                     || k1->op_type == OP_AEACH))
		    expr = newUNOP(OP_DEFINED, 0, expr);
		break;
	    }
	}
    }

    if (!block)
	block = newOP(OP_NULL, 0);
    else if (cont || has_my) {
	block = op_scope(block);
    }

    if (cont) {
	next = LINKLIST(cont);
    }
    if (expr) {
	OP * const unstack = newOP(OP_UNSTACK, 0);
	if (!next)
	    next = unstack;
	cont = op_append_elem(OP_LINESEQ, cont, unstack);
    }

    assert(block);
    listop = op_append_list(OP_LINESEQ, block, cont);
    assert(listop);
    redo = LINKLIST(listop);

    if (expr) {
	scalar(listop);
	o = new_logop(OP_AND, 0, &expr, &listop);
	if (o == expr && o->op_type == OP_CONST && !SvTRUE(cSVOPo->op_sv)) {
	    op_free((OP*)loop);
	    return expr;		/* listop already freed by new_logop */
	}
	if (listop)
	    ((LISTOP*)listop)->op_last->op_next =
		(o == listop ? redo : LINKLIST(o));
    }
    else
	o = listop;

    if (!loop) {
	NewOp(1101,loop,1,LOOP);
        OpTYPE_set(loop, OP_ENTERLOOP);
	loop->op_private = 0;
	loop->op_next = (OP*)loop;
    }

    o = newBINOP(OP_LEAVELOOP, 0, (OP*)loop, o);

    loop->op_redoop = redo;
    loop->op_lastop = o;
    o->op_private |= loopflags;

    if (next)
	loop->op_nextop = next;
    else
	loop->op_nextop = o;

    o->op_flags |= flags;
    o->op_private |= (flags >> 8);
    return o;
}

/*
=for apidoc Am|OP *|newFOROP|I32 flags|OP *sv|OP *expr|OP *block|OP *cont

Constructs, checks, and returns an op tree expressing a C<foreach>
loop (iteration through a list of values).  This is a heavyweight loop,
with structure that allows exiting the loop by C<last> and suchlike.

C<sv> optionally supplies the variable that will be aliased to each
item in turn; if null, it defaults to C<$_>.
C<expr> supplies the list of values to iterate over.  C<block> supplies
the main body of the loop, and C<cont> optionally supplies a C<continue>
block that operates as a second half of the body.  All of these optree
inputs are consumed by this function and become part of the constructed
op tree.

C<flags> gives the eight bits of C<op_flags> for the C<leaveloop>
op and, shifted up eight bits, the eight bits of C<op_private> for
the C<leaveloop> op, except that (in both cases) some bits will be set
automatically.

=cut
*/

OP *
Perl_newFOROP(pTHX_ I32 flags, OP *sv, OP *expr, OP *block, OP *cont)
{
    dVAR;
    LOOP *loop;
    OP *wop;
    PADOFFSET padoff = 0;
    I32 iterflags = 0;
    I32 iterpflags = 0;

    PERL_ARGS_ASSERT_NEWFOROP;

    if (sv) {
	if (sv->op_type == OP_RV2SV) {	/* symbol table variable */
	    iterpflags = sv->op_private & OPpOUR_INTRO; /* for our $x () */
            OpTYPE_set(sv, OP_RV2GV);

	    /* The op_type check is needed to prevent a possible segfault
	     * if the loop variable is undeclared and 'strict vars' is in
	     * effect. This is illegal but is nonetheless parsed, so we
	     * may reach this point with an OP_CONST where we're expecting
	     * an OP_GV.
	     */
	    if (cUNOPx(sv)->op_first->op_type == OP_GV
	     && cGVOPx_gv(cUNOPx(sv)->op_first) == PL_defgv)
		iterpflags |= OPpITER_DEF;
	}
	else if (sv->op_type == OP_PADSV) { /* private variable */
	    iterpflags = sv->op_private & OPpLVAL_INTRO; /* for my $x () */
	    padoff = sv->op_targ;
            sv->op_targ = 0;
            op_free(sv);
	    sv = NULL;
	    PAD_COMPNAME_GEN_set(padoff, PERL_INT_MAX);
	}
	else if (sv->op_type == OP_NULL && sv->op_targ == OP_SREFGEN)
	    NOOP;
	else
	    Perl_croak(aTHX_ "Can't use %s for loop variable", PL_op_desc[sv->op_type]);
	if (padoff) {
	    PADNAME * const pn = PAD_COMPNAME(padoff);
	    const char * const name = PadnamePV(pn);

	    if (PadnameLEN(pn) == 2 && name[0] == '$' && name[1] == '_')
		iterpflags |= OPpITER_DEF;
	}
    }
    else {
	sv = newGVOP(OP_GV, 0, PL_defgv);
	iterpflags |= OPpITER_DEF;
    }

    if (expr->op_type == OP_RV2AV || expr->op_type == OP_PADAV) {
	expr = op_lvalue(force_list(scalar(ref(expr, OP_ITER)), 1), OP_GREPSTART);
	iterflags |= OPf_STACKED;
    }
    else if (expr->op_type == OP_NULL &&
             (expr->op_flags & OPf_KIDS) &&
             ((BINOP*)expr)->op_first->op_type == OP_FLOP)
    {
	/* Basically turn for($x..$y) into the same as for($x,$y), but we
	 * set the STACKED flag to indicate that these values are to be
	 * treated as min/max values by 'pp_enteriter'.
	 */
	const UNOP* const flip = (UNOP*)((UNOP*)((BINOP*)expr)->op_first)->op_first;
	LOGOP* const range = (LOGOP*) flip->op_first;
	OP* const left  = range->op_first;
	OP* const right = OpSIBLING(left);
	LISTOP* listop;

	range->op_flags &= ~OPf_KIDS;
        /* detach range's children */
        op_sibling_splice((OP*)range, NULL, -1, NULL);

	listop = (LISTOP*)newLISTOP(OP_LIST, 0, left, right);
	listop->op_first->op_next = range->op_next;
	left->op_next = range->op_other;
	right->op_next = (OP*)listop;
	listop->op_next = listop->op_first;

	op_free(expr);
	expr = (OP*)(listop);
        op_null(expr);
	iterflags |= OPf_STACKED;
    }
    else {
        expr = op_lvalue(force_list(expr, 1), OP_GREPSTART);
    }

    loop = (LOOP*)op_convert_list(OP_ENTERITER, iterflags,
                                  op_append_elem(OP_LIST, list(expr),
                                                 scalar(sv)));
    assert(!loop->op_next);
    /* for my  $x () sets OPpLVAL_INTRO;
     * for our $x () sets OPpOUR_INTRO */
    loop->op_private = (U8)iterpflags;
    if (loop->op_slabbed
     && DIFF(loop, OpSLOT(loop)->opslot_next)
	 < SIZE_TO_PSIZE(sizeof(LOOP)))
    {
	LOOP *tmp;
	NewOp(1234,tmp,1,LOOP);
	Copy(loop,tmp,1,LISTOP);
#ifdef PERL_OP_PARENT
        assert(loop->op_last->op_sibparent == (OP*)loop);
        OpLASTSIB_set(loop->op_last, (OP*)tmp); /*point back to new parent */
#endif
	S_op_destroy(aTHX_ (OP*)loop);
	loop = tmp;
    }
    else if (!loop->op_slabbed)
    {
	loop = (LOOP*)PerlMemShared_realloc(loop, sizeof(LOOP));
#ifdef PERL_OP_PARENT
        OpLASTSIB_set(loop->op_last, (OP*)loop);
#endif
    }
    loop->op_targ = padoff;
    wop = newWHILEOP(flags, 1, loop, newOP(OP_ITER, 0), block, cont, 0);
    return wop;
}

/*
=for apidoc Am|OP *|newLOOPEX|I32 type|OP *label

Constructs, checks, and returns a loop-exiting op (such as C<goto>
or C<last>).  C<type> is the opcode.  C<label> supplies the parameter
determining the target of the op; it is consumed by this function and
becomes part of the constructed op tree.

=cut
*/

OP*
Perl_newLOOPEX(pTHX_ I32 type, OP *label)
{
    OP *o = NULL;

    PERL_ARGS_ASSERT_NEWLOOPEX;

    assert((PL_opargs[type] & OA_CLASS_MASK) == OA_LOOPEXOP
	|| type == OP_CUSTOM);

    if (type != OP_GOTO) {
	/* "last()" means "last" */
	if (label->op_type == OP_STUB && (label->op_flags & OPf_PARENS)) {
	    o = newOP(type, OPf_SPECIAL);
	}
    }
    else {
	/* Check whether it's going to be a goto &function */
	if (label->op_type == OP_ENTERSUB
		&& !(label->op_flags & OPf_STACKED))
	    label = newUNOP(OP_REFGEN, 0, op_lvalue(label, OP_REFGEN));
    }

    /* Check for a constant argument */
    if (label->op_type == OP_CONST) {
	    SV * const sv = ((SVOP *)label)->op_sv;
	    STRLEN l;
	    const char *s = SvPV_const(sv,l);
	    if (l == strlen(s)) {
		o = newPVOP(type,
			    SvUTF8(((SVOP*)label)->op_sv),
			    savesharedpv(
				SvPV_nolen_const(((SVOP*)label)->op_sv)));
	    }
    }
    
    /* If we have already created an op, we do not need the label. */
    if (o)
		op_free(label);
    else o = newUNOP(type, OPf_STACKED, label);

    PL_hints |= HINT_BLOCK_SCOPE;
    return o;
}

/* if the condition is a literal array or hash
   (or @@{ ... } etc), make a reference to it.
 */
STATIC OP *
S_ref_array_or_hash(pTHX_ OP *cond)
{
    if (cond
    && (cond->op_type == OP_RV2AV
    ||  cond->op_type == OP_PADAV
    ||  cond->op_type == OP_RV2HV
    ||  cond->op_type == OP_PADHV))

	return newUNOP(OP_REFGEN, 0, op_lvalue(cond, OP_REFGEN));

    else if(cond
    && (cond->op_type == OP_ASLICE
    ||  cond->op_type == OP_KVASLICE
    ||  cond->op_type == OP_HSLICE
    ||  cond->op_type == OP_KVHSLICE)) {

	/* anonlist now needs a list from this op, was previously used in
	 * scalar context */
	cond->op_flags &= ~(OPf_WANT_SCALAR | OPf_REF);
	cond->op_flags |= OPf_WANT_LIST;

	return newANONLIST(op_lvalue(cond, OP_ANONLIST));
    }

    else
	return cond;
}

/* These construct the optree fragments representing given()
   and when() blocks.

   entergiven and enterwhen are LOGOPs; the op_other pointer
   points up to the associated leave op. We need this so we
   can put it in the context and make break/continue work.
   (Also, of course, pp_enterwhen will jump straight to
   op_other if the match fails.)
 */

STATIC OP *
S_newGIVWHENOP(pTHX_ OP *cond, OP *block,
		   I32 enter_opcode, I32 leave_opcode,
		   PADOFFSET entertarg)
{
    dVAR;
    LOGOP *enterop;
    OP *o;

    PERL_ARGS_ASSERT_NEWGIVWHENOP;
    PERL_UNUSED_ARG(entertarg); /* used to indicate targ of lexical $_ */

    enterop = S_alloc_LOGOP(aTHX_ enter_opcode, block, NULL);
    enterop->op_targ = 0;
    enterop->op_private = 0;

    o = newUNOP(leave_opcode, 0, (OP *) enterop);

    if (cond) {
        /* prepend cond if we have one */
        op_sibling_splice((OP*)enterop, NULL, 0, scalar(cond));

	o->op_next = LINKLIST(cond);
	cond->op_next = (OP *) enterop;
    }
    else {
	/* This is a default {} block */
	enterop->op_flags |= OPf_SPECIAL;
	o      ->op_flags |= OPf_SPECIAL;

	o->op_next = (OP *) enterop;
    }

    CHECKOP(enter_opcode, enterop); /* Currently does nothing, since
    				       entergiven and enterwhen both
    				       use ck_null() */

    enterop->op_next = LINKLIST(block);
    block->op_next = enterop->op_other = o;

    return o;
}

/* Does this look like a boolean operation? For these purposes
   a boolean operation is:
     - a subroutine call [*]
     - a logical connective
     - a comparison operator
     - a filetest operator, with the exception of -s -M -A -C
     - defined(), exists() or eof()
     - /$re/ or $foo =~ /$re/
   
   [*] possibly surprising
 */
STATIC bool
S_looks_like_bool(pTHX_ const OP *o)
{
    PERL_ARGS_ASSERT_LOOKS_LIKE_BOOL;

    switch(o->op_type) {
	case OP_OR:
	case OP_DOR:
	    return looks_like_bool(cLOGOPo->op_first);

	case OP_AND:
        {
            OP* sibl = OpSIBLING(cLOGOPo->op_first);
            ASSUME(sibl);
	    return (
	    	looks_like_bool(cLOGOPo->op_first)
	     && looks_like_bool(sibl));
        }

	case OP_NULL:
	case OP_SCALAR:
	    return (
		o->op_flags & OPf_KIDS
	    && looks_like_bool(cUNOPo->op_first));

	case OP_ENTERSUB:

	case OP_NOT:	case OP_XOR:

	case OP_EQ:	case OP_NE:	case OP_LT:
	case OP_GT:	case OP_LE:	case OP_GE:

	case OP_I_EQ:	case OP_I_NE:	case OP_I_LT:
	case OP_I_GT:	case OP_I_LE:	case OP_I_GE:

	case OP_SEQ:	case OP_SNE:	case OP_SLT:
	case OP_SGT:	case OP_SLE:	case OP_SGE:
	
	case OP_SMARTMATCH:
	
	case OP_FTRREAD:  case OP_FTRWRITE: case OP_FTREXEC:
	case OP_FTEREAD:  case OP_FTEWRITE: case OP_FTEEXEC:
	case OP_FTIS:     case OP_FTEOWNED: case OP_FTROWNED:
	case OP_FTZERO:   case OP_FTSOCK:   case OP_FTCHR:
	case OP_FTBLK:    case OP_FTFILE:   case OP_FTDIR:
	case OP_FTPIPE:   case OP_FTLINK:   case OP_FTSUID:
	case OP_FTSGID:   case OP_FTSVTX:   case OP_FTTTY:
	case OP_FTTEXT:   case OP_FTBINARY:
	
	case OP_DEFINED: case OP_EXISTS:
	case OP_MATCH:	 case OP_EOF:

	case OP_FLOP:

	    return TRUE;
	
	case OP_CONST:
	    /* Detect comparisons that have been optimized away */
	    if (cSVOPo->op_sv == &PL_sv_yes
	    ||  cSVOPo->op_sv == &PL_sv_no)
	    
		return TRUE;
	    else
		return FALSE;

	/* FALLTHROUGH */
	default:
	    return FALSE;
    }
}

/*
=for apidoc Am|OP *|newGIVENOP|OP *cond|OP *block|PADOFFSET defsv_off

Constructs, checks, and returns an op tree expressing a C<given> block.
C<cond> supplies the expression that will be locally assigned to a lexical
variable, and C<block> supplies the body of the C<given> construct; they
are consumed by this function and become part of the constructed op tree.
C<defsv_off> must be zero (it used to identity the pad slot of lexical $_).

=cut
*/

OP *
Perl_newGIVENOP(pTHX_ OP *cond, OP *block, PADOFFSET defsv_off)
{
    PERL_ARGS_ASSERT_NEWGIVENOP;
    PERL_UNUSED_ARG(defsv_off);

    assert(!defsv_off);
    return newGIVWHENOP(
    	ref_array_or_hash(cond),
    	block,
	OP_ENTERGIVEN, OP_LEAVEGIVEN,
	0);
}

/*
=for apidoc Am|OP *|newWHENOP|OP *cond|OP *block

Constructs, checks, and returns an op tree expressing a C<when> block.
C<cond> supplies the test expression, and C<block> supplies the block
that will be executed if the test evaluates to true; they are consumed
by this function and become part of the constructed op tree.  C<cond>
will be interpreted DWIMically, often as a comparison against C<$_>,
and may be null to generate a C<default> block.

=cut
*/

OP *
Perl_newWHENOP(pTHX_ OP *cond, OP *block)
{
    const bool cond_llb = (!cond || looks_like_bool(cond));
    OP *cond_op;

    PERL_ARGS_ASSERT_NEWWHENOP;

    if (cond_llb)
	cond_op = cond;
    else {
	cond_op = newBINOP(OP_SMARTMATCH, OPf_SPECIAL,
		newDEFSVOP(),
		scalar(ref_array_or_hash(cond)));
    }
    
    return newGIVWHENOP(cond_op, block, OP_ENTERWHEN, OP_LEAVEWHEN, 0);
}

/* must not conflict with SVf_UTF8 */
#define CV_CKPROTO_CURSTASH	0x1

void
Perl_cv_ckproto_len_flags(pTHX_ const CV *cv, const GV *gv, const char *p,
		    const STRLEN len, const U32 flags)
{
    SV *name = NULL, *msg;
    const char * cvp = SvROK(cv)
			? SvTYPE(SvRV_const(cv)) == SVt_PVCV
			   ? (cv = (const CV *)SvRV_const(cv), CvPROTO(cv))
			   : ""
			: CvPROTO(cv);
    STRLEN clen = CvPROTOLEN(cv), plen = len;

    PERL_ARGS_ASSERT_CV_CKPROTO_LEN_FLAGS;

    if (p == NULL && cvp == NULL)
	return;

    if (!ckWARN_d(WARN_PROTOTYPE))
	return;

    if (p && cvp) {
	p = S_strip_spaces(aTHX_ p, &plen);
	cvp = S_strip_spaces(aTHX_ cvp, &clen);
	if ((flags & SVf_UTF8) == SvUTF8(cv)) {
	    if (plen == clen && memEQ(cvp, p, plen))
		return;
	} else {
	    if (flags & SVf_UTF8) {
		if (bytes_cmp_utf8((const U8 *)cvp, clen, (const U8 *)p, plen) == 0)
		    return;
            }
	    else {
		if (bytes_cmp_utf8((const U8 *)p, plen, (const U8 *)cvp, clen) == 0)
		    return;
	    }
	}
    }

    msg = sv_newmortal();

    if (gv)
    {
	if (isGV(gv))
	    gv_efullname3(name = sv_newmortal(), gv, NULL);
	else if (SvPOK(gv) && *SvPVX((SV *)gv) == '&')
	    name = newSVpvn_flags(SvPVX((SV *)gv)+1, SvCUR(gv)-1, SvUTF8(gv)|SVs_TEMP);
	else if (flags & CV_CKPROTO_CURSTASH || SvROK(gv)) {
	    name = sv_2mortal(newSVhek(HvNAME_HEK(PL_curstash)));
	    sv_catpvs(name, "::");
	    if (SvROK(gv)) {
		assert (SvTYPE(SvRV_const(gv)) == SVt_PVCV);
		assert (CvNAMED(SvRV_const(gv)));
		sv_cathek(name, CvNAME_HEK(MUTABLE_CV(SvRV_const(gv))));
	    }
	    else sv_catsv(name, (SV *)gv);
	}
	else name = (SV *)gv;
    }
    sv_setpvs(msg, "Prototype mismatch:");
    if (name)
	Perl_sv_catpvf(aTHX_ msg, " sub %"SVf, SVfARG(name));
    if (cvp)
	Perl_sv_catpvf(aTHX_ msg, " (%"UTF8f")", 
	    UTF8fARG(SvUTF8(cv),clen,cvp)
	);
    else
	sv_catpvs(msg, ": none");
    sv_catpvs(msg, " vs ");
    if (p)
	Perl_sv_catpvf(aTHX_ msg, "(%"UTF8f")", UTF8fARG(flags & SVf_UTF8,len,p));
    else
	sv_catpvs(msg, "none");
    Perl_warner(aTHX_ packWARN(WARN_PROTOTYPE), "%"SVf, SVfARG(msg));
}

static void const_sv_xsub(pTHX_ CV* cv);
static void const_av_xsub(pTHX_ CV* cv);

/*

=head1 Optree Manipulation Functions

=for apidoc cv_const_sv

If C<cv> is a constant sub eligible for inlining, returns the constant
value returned by the sub.  Otherwise, returns C<NULL>.

Constant subs can be created with C<newCONSTSUB> or as described in
L<perlsub/"Constant Functions">.

=cut
*/
SV *
Perl_cv_const_sv(const CV *const cv)
{
    SV *sv;
    if (!cv)
	return NULL;
    if (!(SvTYPE(cv) == SVt_PVCV || SvTYPE(cv) == SVt_PVFM))
	return NULL;
    sv = CvCONST(cv) ? MUTABLE_SV(CvXSUBANY(cv).any_ptr) : NULL;
    if (sv && SvTYPE(sv) == SVt_PVAV) return NULL;
    return sv;
}

SV *
Perl_cv_const_sv_or_av(const CV * const cv)
{
    if (!cv)
	return NULL;
    if (SvROK(cv)) return SvRV((SV *)cv);
    assert (SvTYPE(cv) == SVt_PVCV || SvTYPE(cv) == SVt_PVFM);
    return CvCONST(cv) ? MUTABLE_SV(CvXSUBANY(cv).any_ptr) : NULL;
}

/* op_const_sv:  examine an optree to determine whether it's in-lineable.
 * Can be called in 2 ways:
 *
 * !allow_lex
 * 	look for a single OP_CONST with attached value: return the value
 *
 * allow_lex && !CvCONST(cv);
 *
 * 	examine the clone prototype, and if contains only a single
 * 	OP_CONST, return the value; or if it contains a single PADSV ref-
 * 	erencing an outer lexical, turn on CvCONST to indicate the CV is
 * 	a candidate for "constizing" at clone time, and return NULL.
 */

static SV *
S_op_const_sv(pTHX_ const OP *o, CV *cv, bool allow_lex)
{
    SV *sv = NULL;
    bool padsv = FALSE;

    assert(o);
    assert(cv);

    for (; o; o = o->op_next) {
	const OPCODE type = o->op_type;

	if (type == OP_NEXTSTATE || type == OP_LINESEQ
	     || type == OP_NULL
	     || type == OP_PUSHMARK)
		continue;
	if (type == OP_DBSTATE)
		continue;
	if (type == OP_LEAVESUB)
	    break;
	if (sv)
	    return NULL;
	if (type == OP_CONST && cSVOPo->op_sv)
	    sv = cSVOPo->op_sv;
	else if (type == OP_UNDEF && !o->op_private) {
	    sv = newSV(0);
	    SAVEFREESV(sv);
	}
	else if (allow_lex && type == OP_PADSV) {
		if (PAD_COMPNAME_FLAGS(o->op_targ) & PADNAMEt_OUTER)
		{
		    sv = &PL_sv_undef; /* an arbitrary non-null value */
		    padsv = TRUE;
		}
		else
		    return NULL;
	}
	else {
	    return NULL;
	}
    }
    if (padsv) {
	CvCONST_on(cv);
	return NULL;
    }
    return sv;
}

static bool
S_already_defined(pTHX_ CV *const cv, OP * const block, OP * const o,
			PADNAME * const name, SV ** const const_svp)
{
    assert (cv);
    assert (o || name);
    assert (const_svp);
    if ((!block
	 )) {
	if (CvFLAGS(PL_compcv)) {
	    /* might have had built-in attrs applied */
	    const bool pureperl = !CvISXSUB(cv) && CvROOT(cv);
	    if (CvLVALUE(PL_compcv) && ! CvLVALUE(cv) && pureperl
	     && ckWARN(WARN_MISC))
	    {
		/* protect against fatal warnings leaking compcv */
		SAVEFREESV(PL_compcv);
		Perl_warner(aTHX_ packWARN(WARN_MISC), "lvalue attribute ignored after the subroutine has been defined");
		SvREFCNT_inc_simple_void_NN(PL_compcv);
	    }
	    CvFLAGS(cv) |=
		(CvFLAGS(PL_compcv) & CVf_BUILTIN_ATTRS
		  & ~(CVf_LVALUE * pureperl));
	}
	return FALSE;
    }

    /* redundant check for speed: */
    if (CvCONST(cv) || ckWARN(WARN_REDEFINE)) {
	const line_t oldline = CopLINE(PL_curcop);
	SV *namesv = o
	    ? cSVOPo->op_sv
	    : sv_2mortal(newSVpvn_utf8(
		PadnamePV(name)+1,PadnameLEN(name)-1, PadnameUTF8(name)
	      ));
	if (PL_parser && PL_parser->copline != NOLINE)
            /* This ensures that warnings are reported at the first
               line of a redefinition, not the last.  */
	    CopLINE_set(PL_curcop, PL_parser->copline);
	/* protect against fatal warnings leaking compcv */
	SAVEFREESV(PL_compcv);
	report_redefined_cv(namesv, cv, const_svp);
	SvREFCNT_inc_simple_void_NN(PL_compcv);
	CopLINE_set(PL_curcop, oldline);
    }
    SAVEFREESV(cv);
    return TRUE;
}

CV *
Perl_newMYSUB(pTHX_ I32 floor, OP *o, OP *proto, OP *attrs, OP *block)
{
    CV **spot;
    SV **svspot;
    const char *ps;
    STRLEN ps_len = 0; /* init it to avoid false uninit warning from icc */
    U32 ps_utf8 = 0;
    CV *cv = NULL;
    CV *compcv = PL_compcv;
    SV *const_sv;
    PADNAME *name;
    PADOFFSET pax = o->op_targ;
    CV *outcv = CvOUTSIDE(PL_compcv);
    CV *clonee = NULL;
    HEK *hek = NULL;
    bool reusable = FALSE;
    OP *start = NULL;
#ifdef PERL_DEBUG_READONLY_OPS
    OPSLAB *slab = NULL;
#endif

    PERL_ARGS_ASSERT_NEWMYSUB;

    /* Find the pad slot for storing the new sub.
       We cannot use PL_comppad, as it is the pad owned by the new sub.  We
       need to look in CvOUTSIDE and find the pad belonging to the enclos-
       ing sub.  And then we need to dig deeper if this is a lexical from
       outside, as in:
	   my sub foo; sub { sub foo { } }
     */
   redo:
    name = PadlistNAMESARRAY(CvPADLIST(outcv))[pax];
    if (PadnameOUTER(name) && PARENT_PAD_INDEX(name)) {
	pax = PARENT_PAD_INDEX(name);
	outcv = CvOUTSIDE(outcv);
	assert(outcv);
	goto redo;
    }
    svspot =
	&PadARRAY(PadlistARRAY(CvPADLIST(outcv))
			[CvDEPTH(outcv) ? CvDEPTH(outcv) : 1])[pax];
    spot = (CV **)svspot;

    if (!(PL_parser && PL_parser->error_count))
        move_proto_attr(&proto, &attrs, (GV *)PadnameSV(name));

    if (proto) {
	assert(proto->op_type == OP_CONST);
	ps = SvPV_const(((SVOP*)proto)->op_sv, ps_len);
        ps_utf8 = SvUTF8(((SVOP*)proto)->op_sv);
    }
    else
	ps = NULL;

    if (proto)
        SAVEFREEOP(proto);
    if (attrs)
        SAVEFREEOP(attrs);

    if (PL_parser && PL_parser->error_count) {
	op_free(block);
	SvREFCNT_dec(PL_compcv);
	PL_compcv = 0;
	goto done;
    }

    if (CvDEPTH(outcv) && CvCLONE(compcv)) {
	cv = *spot;
	svspot = (SV **)(spot = &clonee);
    }
    else if (PadnameIsSTATE(name) || CvDEPTH(outcv))
	cv = *spot;
    else {
	assert (SvTYPE(*spot) == SVt_PVCV);
	if (CvNAMED(*spot))
	    hek = CvNAME_HEK(*spot);
	else {
            dVAR;
	    U32 hash;
	    PERL_HASH(hash, PadnamePV(name)+1, PadnameLEN(name)-1);
	    CvNAME_HEK_set(*spot, hek =
		share_hek(
		    PadnamePV(name)+1,
		    (PadnameLEN(name)-1) * (PadnameUTF8(name) ? -1 : 1),
		    hash
		)
	    );
	    CvLEXICAL_on(*spot);
	}
	cv = PadnamePROTOCV(name);
	svspot = (SV **)(spot = &PadnamePROTOCV(name));
    }

    if (block) {
	/* This makes sub {}; work as expected.  */
	if (block->op_type == OP_STUB) {
	    const line_t l = PL_parser->copline;
	    op_free(block);
	    block = newSTATEOP(0, NULL, 0);
	    PL_parser->copline = l;
	}
	block = CvLVALUE(compcv)
	     || (cv && CvLVALUE(cv) && !CvROOT(cv) && !CvXSUB(cv))
		   ? newUNOP(OP_LEAVESUBLV, 0,
			     op_lvalue(scalarseq(block), OP_LEAVESUBLV))
		   : newUNOP(OP_LEAVESUB, 0, scalarseq(block));
	start = LINKLIST(block);
	block->op_next = 0;
        if (ps && !*ps && !attrs && !CvLVALUE(compcv))
            const_sv = S_op_const_sv(aTHX_ start, compcv, FALSE);
        else
            const_sv = NULL;
    }
    else
        const_sv = NULL;

    if (cv) {
        const bool exists = CvROOT(cv) || CvXSUB(cv);

        /* if the subroutine doesn't exist and wasn't pre-declared
         * with a prototype, assume it will be AUTOLOADed,
         * skipping the prototype check
         */
        if (exists || SvPOK(cv))
            cv_ckproto_len_flags(cv, (GV *)PadnameSV(name), ps, ps_len,
                                 ps_utf8);
	/* already defined? */
	if (exists) {
	    if (S_already_defined(aTHX_ cv,block,NULL,name,&const_sv))
		cv = NULL;
	    else {
		if (attrs) goto attrs;
		/* just a "sub foo;" when &foo is already defined */
		SAVEFREESV(compcv);
		goto done;
	    }
	}
	else if (CvDEPTH(outcv) && CvCLONE(compcv)) {
	    cv = NULL;
	    reusable = TRUE;
	}
    }
    if (const_sv) {
	SvREFCNT_inc_simple_void_NN(const_sv);
	SvFLAGS(const_sv) |= SVs_PADTMP;
	if (cv) {
	    assert(!CvROOT(cv) && !CvCONST(cv));
	    cv_forget_slab(cv);
	}
	else {
	    cv = MUTABLE_CV(newSV_type(SVt_PVCV));
	    CvFILE_set_from_cop(cv, PL_curcop);
	    CvSTASH_set(cv, PL_curstash);
	    *spot = cv;
	}
	sv_setpvs(MUTABLE_SV(cv), "");  /* prototype is "" */
	CvXSUBANY(cv).any_ptr = const_sv;
	CvXSUB(cv) = const_sv_xsub;
	CvCONST_on(cv);
	CvISXSUB_on(cv);
	PoisonPADLIST(cv);
	CvFLAGS(cv) |= CvMETHOD(compcv);
	op_free(block);
	SvREFCNT_dec(compcv);
	PL_compcv = NULL;
	goto setname;
    }
    /* Checking whether outcv is CvOUTSIDE(compcv) is not sufficient to
       determine whether this sub definition is in the same scope as its
       declaration.  If this sub definition is inside an inner named pack-
       age sub (my sub foo; sub bar { sub foo { ... } }), outcv points to
       the package sub.  So check PadnameOUTER(name) too.
     */
    if (outcv == CvOUTSIDE(compcv) && !PadnameOUTER(name)) { 
	assert(!CvWEAKOUTSIDE(compcv));
	SvREFCNT_dec(CvOUTSIDE(compcv));
	CvWEAKOUTSIDE_on(compcv);
    }
    /* XXX else do we have a circular reference? */
    if (cv) {	/* must reuse cv in case stub is referenced elsewhere */
	/* transfer PL_compcv to cv */
	if (block
	) {
	    cv_flags_t preserved_flags =
		CvFLAGS(cv) & (CVf_BUILTIN_ATTRS|CVf_NAMED);
	    PADLIST *const temp_padl = CvPADLIST(cv);
	    CV *const temp_cv = CvOUTSIDE(cv);
	    const cv_flags_t other_flags =
		CvFLAGS(cv) & (CVf_SLABBED|CVf_WEAKOUTSIDE);
	    OP * const cvstart = CvSTART(cv);

	    SvPOK_off(cv);
	    CvFLAGS(cv) =
		CvFLAGS(compcv) | preserved_flags;
	    CvOUTSIDE(cv) = CvOUTSIDE(compcv);
	    CvOUTSIDE_SEQ(cv) = CvOUTSIDE_SEQ(compcv);
	    CvPADLIST_set(cv, CvPADLIST(compcv));
	    CvOUTSIDE(compcv) = temp_cv;
	    CvPADLIST_set(compcv, temp_padl);
	    CvSTART(cv) = CvSTART(compcv);
	    CvSTART(compcv) = cvstart;
	    CvFLAGS(compcv) &= ~(CVf_SLABBED|CVf_WEAKOUTSIDE);
	    CvFLAGS(compcv) |= other_flags;

	    if (CvFILE(cv) && CvDYNFILE(cv)) {
		Safefree(CvFILE(cv));
	    }

	    /* inner references to compcv must be fixed up ... */
	    pad_fixup_inner_anons(CvPADLIST(cv), compcv, cv);
	    if (PERLDB_INTER)/* Advice debugger on the new sub. */
	      ++PL_sub_generation;
	}
	else {
	    /* Might have had built-in attributes applied -- propagate them. */
	    CvFLAGS(cv) |= (CvFLAGS(compcv) & CVf_BUILTIN_ATTRS);
	}
	/* ... before we throw it away */
	SvREFCNT_dec(compcv);
	PL_compcv = compcv = cv;
    }
    else {
	cv = compcv;
	*spot = cv;
    }
   setname:
    CvLEXICAL_on(cv);
    if (!CvNAME_HEK(cv)) {
	if (hek) (void)share_hek_hek(hek);
	else {
            dVAR;
	    U32 hash;
	    PERL_HASH(hash, PadnamePV(name)+1, PadnameLEN(name)-1);
	    hek = share_hek(PadnamePV(name)+1,
		      (PadnameLEN(name)-1) * (PadnameUTF8(name) ? -1 : 1),
		      hash);
	}
	CvNAME_HEK_set(cv, hek);
    }
    if (const_sv) goto clone;

    CvFILE_set_from_cop(cv, PL_curcop);
    CvSTASH_set(cv, PL_curstash);

    if (ps) {
	sv_setpvn(MUTABLE_SV(cv), ps, ps_len);
        if ( ps_utf8 ) SvUTF8_on(MUTABLE_SV(cv));
    }

    if (!block)
	goto attrs;

    /* If we assign an optree to a PVCV, then we've defined a subroutine that
       the debugger could be able to set a breakpoint in, so signal to
       pp_entereval that it should not throw away any saved lines at scope
       exit.  */
       
    PL_breakable_sub_gen++;
    CvROOT(cv) = block;
    CvROOT(cv)->op_private |= OPpREFCOUNTED;
    OpREFCNT_set(CvROOT(cv), 1);
    /* The cv no longer needs to hold a refcount on the slab, as CvROOT
       itself has a refcount. */
    CvSLABBED_off(cv);
    OpslabREFCNT_dec_padok((OPSLAB *)CvSTART(cv));
#ifdef PERL_DEBUG_READONLY_OPS
    slab = (OPSLAB *)CvSTART(cv);
#endif
    CvSTART(cv) = start;
    CALL_PEEP(start);
    finalize_optree(CvROOT(cv));
    S_prune_chain_head(&CvSTART(cv));

    /* now that optimizer has done its work, adjust pad values */

    pad_tidy(CvCLONE(cv) ? padtidy_SUBCLONE : padtidy_SUB);

  attrs:
    if (attrs) {
	/* Need to do a C<use attributes $stash_of_cv,\&cv,@@attrs>. */
	apply_attrs(PL_curstash, MUTABLE_SV(cv), attrs);
    }

    if (block) {
	if (PERLDB_SUBLINE && PL_curstash != PL_debstash) {
	    SV * const tmpstr = sv_newmortal();
	    GV * const db_postponed = gv_fetchpvs("DB::postponed",
						  GV_ADDMULTI, SVt_PVHV);
	    HV *hv;
	    SV * const sv = Perl_newSVpvf(aTHX_ "%s:%ld-%ld",
					  CopFILE(PL_curcop),
					  (long)PL_subline,
					  (long)CopLINE(PL_curcop));
	    if (HvNAME_HEK(PL_curstash)) {
		sv_sethek(tmpstr, HvNAME_HEK(PL_curstash));
		sv_catpvs(tmpstr, "::");
	    }
	    else sv_setpvs(tmpstr, "__ANON__::");
	    sv_catpvn_flags(tmpstr, PadnamePV(name)+1, PadnameLEN(name)-1,
			    PadnameUTF8(name) ? SV_CATUTF8 : SV_CATBYTES);
	    (void)hv_store(GvHV(PL_DBsub), SvPVX_const(tmpstr),
		    SvUTF8(tmpstr) ? -(I32)SvCUR(tmpstr) : (I32)SvCUR(tmpstr), sv, 0);
	    hv = GvHVn(db_postponed);
	    if (HvTOTALKEYS(hv) > 0 && hv_exists(hv, SvPVX_const(tmpstr), SvUTF8(tmpstr) ? -(I32)SvCUR(tmpstr) : (I32)SvCUR(tmpstr))) {
		CV * const pcv = GvCV(db_postponed);
		if (pcv) {
		    dSP;
		    PUSHMARK(SP);
		    XPUSHs(tmpstr);
		    PUTBACK;
		    call_sv(MUTABLE_SV(pcv), G_DISCARD);
		}
	    }
	}
    }

  clone:
    if (clonee) {
	assert(CvDEPTH(outcv));
	spot = (CV **)
	    &PadARRAY(PadlistARRAY(CvPADLIST(outcv))[CvDEPTH(outcv)])[pax];
	if (reusable) cv_clone_into(clonee, *spot);
	else *spot = cv_clone(clonee);
	SvREFCNT_dec_NN(clonee);
	cv = *spot;
    }
    if (CvDEPTH(outcv) && !reusable && PadnameIsSTATE(name)) {
	PADOFFSET depth = CvDEPTH(outcv);
	while (--depth) {
	    SV *oldcv;
	    svspot = &PadARRAY(PadlistARRAY(CvPADLIST(outcv))[depth])[pax];
	    oldcv = *svspot;
	    *svspot = SvREFCNT_inc_simple_NN(cv);
	    SvREFCNT_dec(oldcv);
	}
    }

  done:
    if (PL_parser)
	PL_parser->copline = NOLINE;
    LEAVE_SCOPE(floor);
#ifdef PERL_DEBUG_READONLY_OPS
    if (slab)
	Slab_to_ro(slab);
#endif
    op_free(o);
    return cv;
}

/* _x = extended */
CV *
Perl_newATTRSUB_x(pTHX_ I32 floor, OP *o, OP *proto, OP *attrs,
			    OP *block, bool o_is_gv)
{
    GV *gv;
    const char *ps;
    STRLEN ps_len = 0; /* init it to avoid false uninit warning from icc */
    U32 ps_utf8 = 0;
    CV *cv = NULL;
    SV *const_sv;
    const bool ec = PL_parser && PL_parser->error_count;
    /* If the subroutine has no body, no attributes, and no builtin attributes
       then it's just a sub declaration, and we may be able to get away with
       storing with a placeholder scalar in the symbol table, rather than a
       full CV.  If anything is present then it will take a full CV to
       store it.  */
    const I32 gv_fetch_flags
	= ec ? GV_NOADD_NOINIT :
        (block || attrs || (CvFLAGS(PL_compcv) & CVf_BUILTIN_ATTRS))
	? GV_ADDMULTI : GV_ADDMULTI | GV_NOINIT;
    STRLEN namlen = 0;
    const char * const name =
	 o ? SvPV_const(o_is_gv ? (SV *)o : cSVOPo->op_sv, namlen) : NULL;
    bool has_name;
    bool name_is_utf8 = o && !o_is_gv && SvUTF8(cSVOPo->op_sv);
    bool evanescent = FALSE;
    OP *start = NULL;
#ifdef PERL_DEBUG_READONLY_OPS
    OPSLAB *slab = NULL;
#endif

    if (o_is_gv) {
	gv = (GV*)o;
	o = NULL;
	has_name = TRUE;
    } else if (name) {
	/* Try to optimise and avoid creating a GV.  Instead, the CV’s name
	   hek and CvSTASH pointer together can imply the GV.  If the name
	   contains a package name, then GvSTASH(CvGV(cv)) may differ from
	   CvSTASH, so forego the optimisation if we find any.
	   Also, we may be called from load_module at run time, so
	   PL_curstash (which sets CvSTASH) may not point to the stash the
	   sub is stored in.  */
	const I32 flags =
	   ec ? GV_NOADD_NOINIT
	      :   PL_curstash != CopSTASH(PL_curcop)
	       || memchr(name, ':', namlen) || memchr(name, '\'', namlen)
		    ? gv_fetch_flags
		    : GV_ADDMULTI | GV_NOINIT | GV_NOTQUAL;
	gv = gv_fetchsv(cSVOPo->op_sv, flags, SVt_PVCV);
	has_name = TRUE;
    } else if (PERLDB_NAMEANON && CopLINE(PL_curcop)) {
	SV * const sv = sv_newmortal();
	Perl_sv_setpvf(aTHX_ sv, "%s[%s:%"IVdf"]",
		       PL_curstash ? "__ANON__" : "__ANON__::__ANON__",
		       CopFILE(PL_curcop), (IV)CopLINE(PL_curcop));
	gv = gv_fetchsv(sv, gv_fetch_flags, SVt_PVCV);
	has_name = TRUE;
    } else if (PL_curstash) {
	gv = gv_fetchpvs("__ANON__", gv_fetch_flags, SVt_PVCV);
	has_name = FALSE;
    } else {
	gv = gv_fetchpvs("__ANON__::__ANON__", gv_fetch_flags, SVt_PVCV);
	has_name = FALSE;
    }
    if (!ec) {
        if (isGV(gv)) {
            move_proto_attr(&proto, &attrs, gv);
        } else {
            assert(cSVOPo);
            move_proto_attr(&proto, &attrs, (GV *)cSVOPo->op_sv);
        }
    }

    if (proto) {
	assert(proto->op_type == OP_CONST);
	ps = SvPV_const(((SVOP*)proto)->op_sv, ps_len);
        ps_utf8 = SvUTF8(((SVOP*)proto)->op_sv);
    }
    else
	ps = NULL;

    if (o)
        SAVEFREEOP(o);
    if (proto)
        SAVEFREEOP(proto);
    if (attrs)
        SAVEFREEOP(attrs);

    if (ec) {
	op_free(block);
	if (name) SvREFCNT_dec(PL_compcv);
	else cv = PL_compcv;
	PL_compcv = 0;
	if (name && block) {
	    const char *s = strrchr(name, ':');
	    s = s ? s+1 : name;
	    if (strEQ(s, "BEGIN")) {
		if (PL_in_eval & EVAL_KEEPERR)
		    Perl_croak_nocontext("BEGIN not safe after errors--compilation aborted");
		else {
                    SV * const errsv = ERRSV;
		    /* force display of errors found but not reported */
		    sv_catpvs(errsv, "BEGIN not safe after errors--compilation aborted");
		    Perl_croak_nocontext("%"SVf, SVfARG(errsv));
		}
	    }
	}
	goto done;
    }

    if (!block && SvTYPE(gv) != SVt_PVGV) {
      /* If we are not defining a new sub and the existing one is not a
         full GV + CV... */
      if (attrs || (CvFLAGS(PL_compcv) & CVf_BUILTIN_ATTRS)) {
	/* We are applying attributes to an existing sub, so we need it
	   upgraded if it is a constant.  */
	if (SvROK(gv) && SvTYPE(SvRV(gv)) != SVt_PVCV)
	    gv_init_pvn(gv, PL_curstash, name, namlen,
			SVf_UTF8 * name_is_utf8);
      }
      else {			/* Maybe prototype now, and had at maximum
				   a prototype or const/sub ref before.  */
	if (SvTYPE(gv) > SVt_NULL) {
	    cv_ckproto_len_flags((const CV *)gv,
				 o ? (const GV *)cSVOPo->op_sv : NULL, ps,
				 ps_len, ps_utf8);
	}
	if (!SvROK(gv)) {
	  if (ps) {
	    sv_setpvn(MUTABLE_SV(gv), ps, ps_len);
            if ( ps_utf8 ) SvUTF8_on(MUTABLE_SV(gv));
          }
	  else
	    sv_setiv(MUTABLE_SV(gv), -1);
	}

	SvREFCNT_dec(PL_compcv);
	cv = PL_compcv = NULL;
	goto done;
      }
    }

    cv = (!name || (isGV(gv) && GvCVGEN(gv)))
	? NULL
	: isGV(gv)
	    ? GvCV(gv)
	    : SvROK(gv) && SvTYPE(SvRV(gv)) == SVt_PVCV
		? (CV *)SvRV(gv)
		: NULL;

    if (block) {
	assert(PL_parser);
	/* This makes sub {}; work as expected.  */
	if (block->op_type == OP_STUB) {
	    const line_t l = PL_parser->copline;
	    op_free(block);
	    block = newSTATEOP(0, NULL, 0);
	    PL_parser->copline = l;
	}
	block = CvLVALUE(PL_compcv)
	     || (cv && CvLVALUE(cv) && !CvROOT(cv) && !CvXSUB(cv)
		    && (!isGV(gv) || !GvASSUMECV(gv)))
		   ? newUNOP(OP_LEAVESUBLV, 0,
			     op_lvalue(scalarseq(block), OP_LEAVESUBLV))
		   : newUNOP(OP_LEAVESUB, 0, scalarseq(block));
	start = LINKLIST(block);
	block->op_next = 0;
        if (ps && !*ps && !attrs && !CvLVALUE(PL_compcv))
            const_sv =
                S_op_const_sv(aTHX_ start, PL_compcv,
                                        cBOOL(CvCLONE(PL_compcv)));
        else
            const_sv = NULL;
    }
    else
        const_sv = NULL;

    if (SvPOK(gv) || (SvROK(gv) && SvTYPE(SvRV(gv)) != SVt_PVCV)) {
	cv_ckproto_len_flags((const CV *)gv,
			     o ? (const GV *)cSVOPo->op_sv : NULL, ps,
			     ps_len, ps_utf8|CV_CKPROTO_CURSTASH);
	if (SvROK(gv)) {
	    /* All the other code for sub redefinition warnings expects the
	       clobbered sub to be a CV.  Instead of making all those code
	       paths more complex, just inline the RV version here.  */
	    const line_t oldline = CopLINE(PL_curcop);
	    assert(IN_PERL_COMPILETIME);
	    if (PL_parser && PL_parser->copline != NOLINE)
		/* This ensures that warnings are reported at the first
		   line of a redefinition, not the last.  */
		CopLINE_set(PL_curcop, PL_parser->copline);
	    /* protect against fatal warnings leaking compcv */
	    SAVEFREESV(PL_compcv);

	    if (ckWARN(WARN_REDEFINE)
	     || (  ckWARN_d(WARN_REDEFINE)
		&& (  !const_sv || SvRV(gv) == const_sv
		   || sv_cmp(SvRV(gv), const_sv)  )))
		Perl_warner(aTHX_ packWARN(WARN_REDEFINE),
			  "Constant subroutine %"SVf" redefined",
			  SVfARG(cSVOPo->op_sv));

	    SvREFCNT_inc_simple_void_NN(PL_compcv);
	    CopLINE_set(PL_curcop, oldline);
	    SvREFCNT_dec(SvRV(gv));
	}
    }

    if (cv) {
        const bool exists = CvROOT(cv) || CvXSUB(cv);

        /* if the subroutine doesn't exist and wasn't pre-declared
         * with a prototype, assume it will be AUTOLOADed,
         * skipping the prototype check
         */
        if (exists || SvPOK(cv))
            cv_ckproto_len_flags(cv, gv, ps, ps_len, ps_utf8);
	/* already defined (or promised)? */
	if (exists || (isGV(gv) && GvASSUMECV(gv))) {
	    if (S_already_defined(aTHX_ cv, block, o, NULL, &const_sv))
		cv = NULL;
	    else {
		if (attrs) goto attrs;
		/* just a "sub foo;" when &foo is already defined */
		SAVEFREESV(PL_compcv);
		goto done;
	    }
	}
    }
    if (const_sv) {
	SvREFCNT_inc_simple_void_NN(const_sv);
	SvFLAGS(const_sv) |= SVs_PADTMP;
	if (cv) {
	    assert(!CvROOT(cv) && !CvCONST(cv));
	    cv_forget_slab(cv);
	    sv_setpvs(MUTABLE_SV(cv), "");  /* prototype is "" */
	    CvXSUBANY(cv).any_ptr = const_sv;
	    CvXSUB(cv) = const_sv_xsub;
	    CvCONST_on(cv);
	    CvISXSUB_on(cv);
	    PoisonPADLIST(cv);
	    CvFLAGS(cv) |= CvMETHOD(PL_compcv);
	}
	else {
	    if (isGV(gv) || CvMETHOD(PL_compcv)) {
		if (name && isGV(gv))
		    GvCV_set(gv, NULL);
		cv = newCONSTSUB_flags(
		    NULL, name, namlen, name_is_utf8 ? SVf_UTF8 : 0,
		    const_sv
		);
		CvFLAGS(cv) |= CvMETHOD(PL_compcv);
	    }
	    else {
		if (!SvROK(gv)) {
		    SV_CHECK_THINKFIRST_COW_DROP((SV *)gv);
		    prepare_SV_for_RV((SV *)gv);
		    SvOK_off((SV *)gv);
		    SvROK_on(gv);
		}
		SvRV_set(gv, const_sv);
	    }
	}
	op_free(block);
	SvREFCNT_dec(PL_compcv);
	PL_compcv = NULL;
	goto done;
    }
    if (cv) {				/* must reuse cv if autoloaded */
	/* transfer PL_compcv to cv */
	if (block
	) {
	    cv_flags_t existing_builtin_attrs = CvFLAGS(cv) & CVf_BUILTIN_ATTRS;
	    PADLIST *const temp_av = CvPADLIST(cv);
	    CV *const temp_cv = CvOUTSIDE(cv);
	    const cv_flags_t other_flags =
		CvFLAGS(cv) & (CVf_SLABBED|CVf_WEAKOUTSIDE);
	    OP * const cvstart = CvSTART(cv);

	    if (isGV(gv)) {
		CvGV_set(cv,gv);
		assert(!CvCVGV_RC(cv));
		assert(CvGV(cv) == gv);
	    }
	    else {
		dVAR;
		U32 hash;
		PERL_HASH(hash, name, namlen);
		CvNAME_HEK_set(cv,
			       share_hek(name,
					 name_is_utf8
					    ? -(SSize_t)namlen
					    :  (SSize_t)namlen,
					 hash));
	    }

	    SvPOK_off(cv);
	    CvFLAGS(cv) = CvFLAGS(PL_compcv) | existing_builtin_attrs
					     | CvNAMED(cv);
	    CvOUTSIDE(cv) = CvOUTSIDE(PL_compcv);
	    CvOUTSIDE_SEQ(cv) = CvOUTSIDE_SEQ(PL_compcv);
	    CvPADLIST_set(cv,CvPADLIST(PL_compcv));
	    CvOUTSIDE(PL_compcv) = temp_cv;
	    CvPADLIST_set(PL_compcv, temp_av);
	    CvSTART(cv) = CvSTART(PL_compcv);
	    CvSTART(PL_compcv) = cvstart;
	    CvFLAGS(PL_compcv) &= ~(CVf_SLABBED|CVf_WEAKOUTSIDE);
	    CvFLAGS(PL_compcv) |= other_flags;

	    if (CvFILE(cv) && CvDYNFILE(cv)) {
		Safefree(CvFILE(cv));
    }
	    CvFILE_set_from_cop(cv, PL_curcop);
	    CvSTASH_set(cv, PL_curstash);

	    /* inner references to PL_compcv must be fixed up ... */
	    pad_fixup_inner_anons(CvPADLIST(cv), PL_compcv, cv);
	    if (PERLDB_INTER)/* Advice debugger on the new sub. */
	      ++PL_sub_generation;
	}
	else {
	    /* Might have had built-in attributes applied -- propagate them. */
	    CvFLAGS(cv) |= (CvFLAGS(PL_compcv) & CVf_BUILTIN_ATTRS);
	}
	/* ... before we throw it away */
	SvREFCNT_dec(PL_compcv);
	PL_compcv = cv;
    }
    else {
	cv = PL_compcv;
	if (name && isGV(gv)) {
	    GvCV_set(gv, cv);
	    GvCVGEN(gv) = 0;
	    if (HvENAME_HEK(GvSTASH(gv)))
		/* sub Foo::bar { (shift)+1 } */
		gv_method_changed(gv);
	}
	else if (name) {
	    if (!SvROK(gv)) {
		SV_CHECK_THINKFIRST_COW_DROP((SV *)gv);
		prepare_SV_for_RV((SV *)gv);
		SvOK_off((SV *)gv);
		SvROK_on(gv);
	    }
	    SvRV_set(gv, (SV *)cv);
	}
    }
    if (!CvHASGV(cv)) {
	if (isGV(gv)) CvGV_set(cv, gv);
	else {
            dVAR;
	    U32 hash;
	    PERL_HASH(hash, name, namlen);
	    CvNAME_HEK_set(cv, share_hek(name,
					 name_is_utf8
					    ? -(SSize_t)namlen
					    :  (SSize_t)namlen,
					 hash));
	}
	CvFILE_set_from_cop(cv, PL_curcop);
	CvSTASH_set(cv, PL_curstash);
    }

    if (ps) {
	sv_setpvn(MUTABLE_SV(cv), ps, ps_len);
        if ( ps_utf8 ) SvUTF8_on(MUTABLE_SV(cv));
    }

    if (!block)
	goto attrs;

    /* If we assign an optree to a PVCV, then we've defined a subroutine that
       the debugger could be able to set a breakpoint in, so signal to
       pp_entereval that it should not throw away any saved lines at scope
       exit.  */
       
    PL_breakable_sub_gen++;
    CvROOT(cv) = block;
    CvROOT(cv)->op_private |= OPpREFCOUNTED;
    OpREFCNT_set(CvROOT(cv), 1);
    /* The cv no longer needs to hold a refcount on the slab, as CvROOT
       itself has a refcount. */
    CvSLABBED_off(cv);
    OpslabREFCNT_dec_padok((OPSLAB *)CvSTART(cv));
#ifdef PERL_DEBUG_READONLY_OPS
    slab = (OPSLAB *)CvSTART(cv);
#endif
    CvSTART(cv) = start;
    CALL_PEEP(start);
    finalize_optree(CvROOT(cv));
    S_prune_chain_head(&CvSTART(cv));

    /* now that optimizer has done its work, adjust pad values */

    pad_tidy(CvCLONE(cv) ? padtidy_SUBCLONE : padtidy_SUB);

  attrs:
    if (attrs) {
	/* Need to do a C<use attributes $stash_of_cv,\&cv,@@attrs>. */
	HV *stash = name && !CvNAMED(cv) && GvSTASH(CvGV(cv))
			? GvSTASH(CvGV(cv))
			: PL_curstash;
	if (!name) SAVEFREESV(cv);
	apply_attrs(stash, MUTABLE_SV(cv), attrs);
	if (!name) SvREFCNT_inc_simple_void_NN(cv);
    }

    if (block && has_name) {
	if (PERLDB_SUBLINE && PL_curstash != PL_debstash) {
	    SV * const tmpstr = cv_name(cv,NULL,0);
	    GV * const db_postponed = gv_fetchpvs("DB::postponed",
						  GV_ADDMULTI, SVt_PVHV);
	    HV *hv;
	    SV * const sv = Perl_newSVpvf(aTHX_ "%s:%ld-%ld",
					  CopFILE(PL_curcop),
					  (long)PL_subline,
					  (long)CopLINE(PL_curcop));
	    (void)hv_store(GvHV(PL_DBsub), SvPVX_const(tmpstr),
		    SvUTF8(tmpstr) ? -(I32)SvCUR(tmpstr) : (I32)SvCUR(tmpstr), sv, 0);
	    hv = GvHVn(db_postponed);
	    if (HvTOTALKEYS(hv) > 0 && hv_exists(hv, SvPVX_const(tmpstr), SvUTF8(tmpstr) ? -(I32)SvCUR(tmpstr) : (I32)SvCUR(tmpstr))) {
		CV * const pcv = GvCV(db_postponed);
		if (pcv) {
		    dSP;
		    PUSHMARK(SP);
		    XPUSHs(tmpstr);
		    PUTBACK;
		    call_sv(MUTABLE_SV(pcv), G_DISCARD);
		}
	    }
	}

        if (name) {
            if (PL_parser && PL_parser->error_count)
                clear_special_blocks(name, gv, cv);
            else
                evanescent =
                    process_special_blocks(floor, name, gv, cv);
        }
    }

  done:
    if (PL_parser)
	PL_parser->copline = NOLINE;
    LEAVE_SCOPE(floor);
    if (!evanescent) {
#ifdef PERL_DEBUG_READONLY_OPS
      if (slab)
	Slab_to_ro(slab);
#endif
      if (cv && name && CvOUTSIDE(cv) && !CvEVAL(CvOUTSIDE(cv)))
	pad_add_weakref(cv);
    }
    return cv;
}

STATIC void
S_clear_special_blocks(pTHX_ const char *const fullname,
                       GV *const gv, CV *const cv) {
    const char *colon;
    const char *name;

    PERL_ARGS_ASSERT_CLEAR_SPECIAL_BLOCKS;

    colon = strrchr(fullname,':');
    name = colon ? colon + 1 : fullname;

    if ((*name == 'B' && strEQ(name, "BEGIN"))
        || (*name == 'E' && strEQ(name, "END"))
        || (*name == 'U' && strEQ(name, "UNITCHECK"))
        || (*name == 'C' && strEQ(name, "CHECK"))
        || (*name == 'I' && strEQ(name, "INIT"))) {
        if (!isGV(gv)) {
            (void)CvGV(cv);
            assert(isGV(gv));
        }
        GvCV_set(gv, NULL);
        SvREFCNT_dec_NN(MUTABLE_SV(cv));
    }
}

/* Returns true if the sub has been freed.  */
STATIC bool
S_process_special_blocks(pTHX_ I32 floor, const char *const fullname,
			 GV *const gv,
			 CV *const cv)
{
    const char *const colon = strrchr(fullname,':');
    const char *const name = colon ? colon + 1 : fullname;

    PERL_ARGS_ASSERT_PROCESS_SPECIAL_BLOCKS;

    if (*name == 'B') {
	if (strEQ(name, "BEGIN")) {
	    const I32 oldscope = PL_scopestack_ix;
            dSP;
            (void)CvGV(cv);
	    if (floor) LEAVE_SCOPE(floor);
	    ENTER;
            PUSHSTACKi(PERLSI_REQUIRE);
	    SAVECOPFILE(&PL_compiling);
	    SAVECOPLINE(&PL_compiling);
	    SAVEVPTR(PL_curcop);

	    DEBUG_x( dump_sub(gv) );
	    Perl_av_create_and_push(aTHX_ &PL_beginav, MUTABLE_SV(cv));
	    GvCV_set(gv,0);		/* cv has been hijacked */
	    call_list(oldscope, PL_beginav);

            POPSTACK;
	    LEAVE;
	    return !PL_savebegin;
	}
	else
	    return FALSE;
    } else {
	if (*name == 'E') {
	    if strEQ(name, "END") {
		DEBUG_x( dump_sub(gv) );
		Perl_av_create_and_unshift_one(aTHX_ &PL_endav, MUTABLE_SV(cv));
	    } else
		return FALSE;
	} else if (*name == 'U') {
	    if (strEQ(name, "UNITCHECK")) {
		/* It's never too late to run a unitcheck block */
		Perl_av_create_and_unshift_one(aTHX_ &PL_unitcheckav, MUTABLE_SV(cv));
	    }
	    else
		return FALSE;
	} else if (*name == 'C') {
	    if (strEQ(name, "CHECK")) {
		if (PL_main_start)
		    /* diag_listed_as: Too late to run %s block */
		    Perl_ck_warner(aTHX_ packWARN(WARN_VOID),
				   "Too late to run CHECK block");
		Perl_av_create_and_unshift_one(aTHX_ &PL_checkav, MUTABLE_SV(cv));
	    }
	    else
		return FALSE;
	} else if (*name == 'I') {
	    if (strEQ(name, "INIT")) {
		if (PL_main_start)
		    /* diag_listed_as: Too late to run %s block */
		    Perl_ck_warner(aTHX_ packWARN(WARN_VOID),
				   "Too late to run INIT block");
		Perl_av_create_and_push(aTHX_ &PL_initav, MUTABLE_SV(cv));
	    }
	    else
		return FALSE;
	} else
	    return FALSE;
	DEBUG_x( dump_sub(gv) );
	(void)CvGV(cv);
	GvCV_set(gv,0);		/* cv has been hijacked */
	return FALSE;
    }
}

/*
=for apidoc newCONSTSUB

See L</newCONSTSUB_flags>.

=cut
*/

CV *
Perl_newCONSTSUB(pTHX_ HV *stash, const char *name, SV *sv)
{
    return newCONSTSUB_flags(stash, name, name ? strlen(name) : 0, 0, sv);
}

/*
=for apidoc newCONSTSUB_flags

Creates a constant sub equivalent to Perl S<C<sub FOO () { 123 }>> which is
eligible for inlining at compile-time.

Currently, the only useful value for C<flags> is C<SVf_UTF8>.

The newly created subroutine takes ownership of a reference to the passed in
SV.

Passing C<NULL> for SV creates a constant sub equivalent to S<C<sub BAR () {}>>,
which won't be called if used as a destructor, but will suppress the overhead
of a call to C<AUTOLOAD>.  (This form, however, isn't eligible for inlining at
compile time.)

=cut
*/

CV *
Perl_newCONSTSUB_flags(pTHX_ HV *stash, const char *name, STRLEN len,
                             U32 flags, SV *sv)
{
    CV* cv;
    const char *const file = CopFILE(PL_curcop);

    ENTER;

    if (IN_PERL_RUNTIME) {
	/* at runtime, it's not safe to manipulate PL_curcop: it may be
	 * an op shared between threads. Use a non-shared COP for our
	 * dirty work */
	 SAVEVPTR(PL_curcop);
	 SAVECOMPILEWARNINGS();
	 PL_compiling.cop_warnings = DUP_WARNINGS(PL_curcop->cop_warnings);
	 PL_curcop = &PL_compiling;
    }
    SAVECOPLINE(PL_curcop);
    CopLINE_set(PL_curcop, PL_parser ? PL_parser->copline : NOLINE);

    SAVEHINTS();
    PL_hints &= ~HINT_BLOCK_SCOPE;

    if (stash) {
	SAVEGENERICSV(PL_curstash);
	PL_curstash = (HV *)SvREFCNT_inc_simple_NN(stash);
    }

    /* Protect sv against leakage caused by fatal warnings. */
    if (sv) SAVEFREESV(sv);

    /* file becomes the CvFILE. For an XS, it's usually static storage,
       and so doesn't get free()d.  (It's expected to be from the C pre-
       processor __FILE__ directive). But we need a dynamically allocated one,
       and we need it to get freed.  */
    cv = newXS_len_flags(name, len,
			 sv && SvTYPE(sv) == SVt_PVAV
			     ? const_av_xsub
			     : const_sv_xsub,
			 file ? file : "", "",
			 &sv, XS_DYNAMIC_FILENAME | flags);
    CvXSUBANY(cv).any_ptr = SvREFCNT_inc_simple(sv);
    CvCONST_on(cv);

    LEAVE;

    return cv;
}

/*
=for apidoc U||newXS

Used by C<xsubpp> to hook up XSUBs as Perl subs.  C<filename> needs to be
static storage, as it is used directly as CvFILE(), without a copy being made.

=cut
*/

CV *
Perl_newXS(pTHX_ const char *name, XSUBADDR_t subaddr, const char *filename)
{
    PERL_ARGS_ASSERT_NEWXS;
    return newXS_len_flags(
	name, name ? strlen(name) : 0, subaddr, filename, NULL, NULL, 0
    );
}

CV *
Perl_newXS_flags(pTHX_ const char *name, XSUBADDR_t subaddr,
		 const char *const filename, const char *const proto,
		 U32 flags)
{
    PERL_ARGS_ASSERT_NEWXS_FLAGS;
    return newXS_len_flags(
       name, name ? strlen(name) : 0, subaddr, filename, proto, NULL, flags
    );
}

CV *
Perl_newXS_deffile(pTHX_ const char *name, XSUBADDR_t subaddr)
{
    PERL_ARGS_ASSERT_NEWXS_DEFFILE;
    return newXS_len_flags(
        name, strlen(name), subaddr, NULL, NULL, NULL, 0
    );
}

CV *
Perl_newXS_len_flags(pTHX_ const char *name, STRLEN len,
			   XSUBADDR_t subaddr, const char *const filename,
			   const char *const proto, SV **const_svp,
			   U32 flags)
{
    CV *cv;
    bool interleave = FALSE;

    PERL_ARGS_ASSERT_NEWXS_LEN_FLAGS;

    {
        GV * const gv = gv_fetchpvn(
			    name ? name : PL_curstash ? "__ANON__" : "__ANON__::__ANON__",
			    name ? len : PL_curstash ? sizeof("__ANON__") - 1:
				sizeof("__ANON__::__ANON__") - 1,
			    GV_ADDMULTI | flags, SVt_PVCV);

        if ((cv = (name ? GvCV(gv) : NULL))) {
            if (GvCVGEN(gv)) {
                /* just a cached method */
                SvREFCNT_dec(cv);
                cv = NULL;
            }
            else if (CvROOT(cv) || CvXSUB(cv) || GvASSUMECV(gv)) {
                /* already defined (or promised) */
                /* Redundant check that allows us to avoid creating an SV
                   most of the time: */
                if (CvCONST(cv) || ckWARN(WARN_REDEFINE)) {
                    report_redefined_cv(newSVpvn_flags(
                                         name,len,(flags&SVf_UTF8)|SVs_TEMP
                                        ),
                                        cv, const_svp);
                }
                interleave = TRUE;
                ENTER;
                SAVEFREESV(cv);
                cv = NULL;
            }
        }
    
        if (cv)				/* must reuse cv if autoloaded */
            cv_undef(cv);
        else {
            cv = MUTABLE_CV(newSV_type(SVt_PVCV));
            if (name) {
                GvCV_set(gv,cv);
                GvCVGEN(gv) = 0;
                if (HvENAME_HEK(GvSTASH(gv)))
                    gv_method_changed(gv); /* newXS */
            }
        }

        CvGV_set(cv, gv);
        if(filename) {
            /* XSUBs can't be perl lang/perl5db.pl debugged
            if (PERLDB_LINE_OR_SAVESRC)
                (void)gv_fetchfile(filename); */
            assert(!CvDYNFILE(cv)); /* cv_undef should have turned it off */
            if (flags & XS_DYNAMIC_FILENAME) {
                CvDYNFILE_on(cv);
                CvFILE(cv) = savepv(filename);
            } else {
            /* NOTE: not copied, as it is expected to be an external constant string */
                CvFILE(cv) = (char *)filename;
            }
        } else {
            assert((flags & XS_DYNAMIC_FILENAME) == 0 && PL_xsubfilename);
            CvFILE(cv) = (char*)PL_xsubfilename;
        }
        CvISXSUB_on(cv);
        CvXSUB(cv) = subaddr;
#ifndef PERL_IMPLICIT_CONTEXT
        CvHSCXT(cv) = &PL_stack_sp;
#else
        PoisonPADLIST(cv);
#endif

        if (name)
            process_special_blocks(0, name, gv, cv);
        else
            CvANON_on(cv);
    } /* <- not a conditional branch */


    sv_setpv(MUTABLE_SV(cv), proto);
    if (interleave) LEAVE;
    return cv;
}

CV *
Perl_newSTUB(pTHX_ GV *gv, bool fake)
{
    CV *cv = MUTABLE_CV(newSV_type(SVt_PVCV));
    GV *cvgv;
    PERL_ARGS_ASSERT_NEWSTUB;
    assert(!GvCVu(gv));
    GvCV_set(gv, cv);
    GvCVGEN(gv) = 0;
    if (!fake && HvENAME_HEK(GvSTASH(gv)))
	gv_method_changed(gv);
    if (SvFAKE(gv)) {
	cvgv = gv_fetchsv((SV *)gv, GV_ADDMULTI, SVt_PVCV);
	SvFAKE_off(cvgv);
    }
    else cvgv = gv;
    CvGV_set(cv, cvgv);
    CvFILE_set_from_cop(cv, PL_curcop);
    CvSTASH_set(cv, PL_curstash);
    GvMULTI_on(gv);
    return cv;
}

void
Perl_newFORM(pTHX_ I32 floor, OP *o, OP *block)
{
    CV *cv;

    GV *gv;

    if (PL_parser && PL_parser->error_count) {
	op_free(block);
	goto finish;
    }

    gv = o
	? gv_fetchsv(cSVOPo->op_sv, GV_ADD, SVt_PVFM)
	: gv_fetchpvs("STDOUT", GV_ADD|GV_NOTQUAL, SVt_PVFM);

    GvMULTI_on(gv);
    if ((cv = GvFORM(gv))) {
	if (ckWARN(WARN_REDEFINE)) {
	    const line_t oldline = CopLINE(PL_curcop);
	    if (PL_parser && PL_parser->copline != NOLINE)
		CopLINE_set(PL_curcop, PL_parser->copline);
	    if (o) {
		Perl_warner(aTHX_ packWARN(WARN_REDEFINE),
			    "Format %"SVf" redefined", SVfARG(cSVOPo->op_sv));
	    } else {
		/* diag_listed_as: Format %s redefined */
		Perl_warner(aTHX_ packWARN(WARN_REDEFINE),
			    "Format STDOUT redefined");
	    }
	    CopLINE_set(PL_curcop, oldline);
	}
	SvREFCNT_dec(cv);
    }
    cv = PL_compcv;
    GvFORM(gv) = (CV *)SvREFCNT_inc_simple_NN(cv);
    CvGV_set(cv, gv);
    CvFILE_set_from_cop(cv, PL_curcop);


    pad_tidy(padtidy_FORMAT);
    CvROOT(cv) = newUNOP(OP_LEAVEWRITE, 0, scalarseq(block));
    CvROOT(cv)->op_private |= OPpREFCOUNTED;
    OpREFCNT_set(CvROOT(cv), 1);
    CvSTART(cv) = LINKLIST(CvROOT(cv));
    CvROOT(cv)->op_next = 0;
    CALL_PEEP(CvSTART(cv));
    finalize_optree(CvROOT(cv));
    S_prune_chain_head(&CvSTART(cv));
    cv_forget_slab(cv);

  finish:
    op_free(o);
    if (PL_parser)
	PL_parser->copline = NOLINE;
    LEAVE_SCOPE(floor);
    PL_compiling.cop_seq = 0;
}

OP *
Perl_newANONLIST(pTHX_ OP *o)
{
    return op_convert_list(OP_ANONLIST, OPf_SPECIAL, o);
}

OP *
Perl_newANONHASH(pTHX_ OP *o)
{
    return op_convert_list(OP_ANONHASH, OPf_SPECIAL, o);
}

OP *
Perl_newANONSUB(pTHX_ I32 floor, OP *proto, OP *block)
{
    return newANONATTRSUB(floor, proto, NULL, block);
}

OP *
Perl_newANONATTRSUB(pTHX_ I32 floor, OP *proto, OP *attrs, OP *block)
{
    SV * const cv = MUTABLE_SV(newATTRSUB(floor, 0, proto, attrs, block));
    OP * anoncode = 
	newSVOP(OP_ANONCODE, 0,
		cv);
    if (CvANONCONST(cv))
	anoncode = newUNOP(OP_ANONCONST, 0,
			   op_convert_list(OP_ENTERSUB,
					   OPf_STACKED|OPf_WANT_SCALAR,
					   anoncode));
    return newUNOP(OP_REFGEN, 0, anoncode);
}

OP *
Perl_oopsAV(pTHX_ OP *o)
{
    dVAR;

    PERL_ARGS_ASSERT_OOPSAV;

    switch (o->op_type) {
    case OP_PADSV:
    case OP_PADHV:
        OpTYPE_set(o, OP_PADAV);
	return ref(o, OP_RV2AV);

    case OP_RV2SV:
    case OP_RV2HV:
        OpTYPE_set(o, OP_RV2AV);
	ref(o, OP_RV2AV);
	break;

    default:
	Perl_ck_warner_d(aTHX_ packWARN(WARN_INTERNAL), "oops: oopsAV");
	break;
    }
    return o;
}

OP *
Perl_oopsHV(pTHX_ OP *o)
{
    dVAR;

    PERL_ARGS_ASSERT_OOPSHV;

    switch (o->op_type) {
    case OP_PADSV:
    case OP_PADAV:
        OpTYPE_set(o, OP_PADHV);
	return ref(o, OP_RV2HV);

    case OP_RV2SV:
    case OP_RV2AV:
        OpTYPE_set(o, OP_RV2HV);
	ref(o, OP_RV2HV);
	break;

    default:
	Perl_ck_warner_d(aTHX_ packWARN(WARN_INTERNAL), "oops: oopsHV");
	break;
    }
    return o;
}

OP *
Perl_newAVREF(pTHX_ OP *o)
{
    dVAR;

    PERL_ARGS_ASSERT_NEWAVREF;

    if (o->op_type == OP_PADANY) {
        OpTYPE_set(o, OP_PADAV);
	return o;
    }
    else if ((o->op_type == OP_RV2AV || o->op_type == OP_PADAV)) {
	Perl_croak(aTHX_ "Can't use an array as a reference");
    }
    return newUNOP(OP_RV2AV, 0, scalar(o));
}

OP *
Perl_newGVREF(pTHX_ I32 type, OP *o)
{
    if (type == OP_MAPSTART || type == OP_GREPSTART || type == OP_SORT)
	return newUNOP(OP_NULL, 0, o);
    return ref(newUNOP(OP_RV2GV, OPf_REF, o), type);
}

OP *
Perl_newHVREF(pTHX_ OP *o)
{
    dVAR;

    PERL_ARGS_ASSERT_NEWHVREF;

    if (o->op_type == OP_PADANY) {
        OpTYPE_set(o, OP_PADHV);
	return o;
    }
    else if ((o->op_type == OP_RV2HV || o->op_type == OP_PADHV)) {
	Perl_croak(aTHX_ "Can't use a hash as a reference");
    }
    return newUNOP(OP_RV2HV, 0, scalar(o));
}

OP *
Perl_newCVREF(pTHX_ I32 flags, OP *o)
{
    if (o->op_type == OP_PADANY) {
	dVAR;
        OpTYPE_set(o, OP_PADCV);
    }
    return newUNOP(OP_RV2CV, flags, scalar(o));
}

OP *
Perl_newSVREF(pTHX_ OP *o)
{
    dVAR;

    PERL_ARGS_ASSERT_NEWSVREF;

    if (o->op_type == OP_PADANY) {
        OpTYPE_set(o, OP_PADSV);
        scalar(o);
	return o;
    }
    return newUNOP(OP_RV2SV, 0, scalar(o));
}

/* Check routines. See the comments at the top of this file for details
 * on when these are called */

OP *
Perl_ck_anoncode(pTHX_ OP *o)
{
    PERL_ARGS_ASSERT_CK_ANONCODE;

    cSVOPo->op_targ = pad_add_anon((CV*)cSVOPo->op_sv, o->op_type);
    cSVOPo->op_sv = NULL;
    return o;
}

static void
S_io_hints(pTHX_ OP *o)
{
#if O_BINARY != 0 || O_TEXT != 0
    HV * const table =
	PL_hints & HINT_LOCALIZE_HH ? GvHV(PL_hintgv) : NULL;;
    if (table) {
	SV **svp = hv_fetchs(table, "open_IN", FALSE);
	if (svp && *svp) {
	    STRLEN len = 0;
	    const char *d = SvPV_const(*svp, len);
	    const I32 mode = mode_from_discipline(d, len);
            /* bit-and:ing with zero O_BINARY or O_TEXT would be useless. */
#  if O_BINARY != 0
	    if (mode & O_BINARY)
		o->op_private |= OPpOPEN_IN_RAW;
#  endif
#  if O_TEXT != 0
	    if (mode & O_TEXT)
		o->op_private |= OPpOPEN_IN_CRLF;
#  endif
	}

	svp = hv_fetchs(table, "open_OUT", FALSE);
	if (svp && *svp) {
	    STRLEN len = 0;
	    const char *d = SvPV_const(*svp, len);
	    const I32 mode = mode_from_discipline(d, len);
            /* bit-and:ing with zero O_BINARY or O_TEXT would be useless. */
#  if O_BINARY != 0
	    if (mode & O_BINARY)
		o->op_private |= OPpOPEN_OUT_RAW;
#  endif
#  if O_TEXT != 0
	    if (mode & O_TEXT)
		o->op_private |= OPpOPEN_OUT_CRLF;
#  endif
	}
    }
#else
    PERL_UNUSED_CONTEXT;
    PERL_UNUSED_ARG(o);
#endif
}

OP *
Perl_ck_backtick(pTHX_ OP *o)
{
    GV *gv;
    OP *newop = NULL;
    OP *sibl;
    PERL_ARGS_ASSERT_CK_BACKTICK;
    /* qx and `` have a null pushmark; CORE::readpipe has only one kid. */
    if (o->op_flags & OPf_KIDS && (sibl = OpSIBLING(cUNOPo->op_first))
     && (gv = gv_override("readpipe",8)))
    {
        /* detach rest of siblings from o and its first child */
        op_sibling_splice(o, cUNOPo->op_first, -1, NULL);
	newop = S_new_entersubop(aTHX_ gv, sibl);
    }
    else if (!(o->op_flags & OPf_KIDS))
	newop = newUNOP(OP_BACKTICK, 0,	newDEFSVOP());
    if (newop) {
	op_free(o);
	return newop;
    }
    S_io_hints(aTHX_ o);
    return o;
}

OP *
Perl_ck_bitop(pTHX_ OP *o)
{
    PERL_ARGS_ASSERT_CK_BITOP;

    o->op_private = (U8)(PL_hints & HINT_INTEGER);

    if (o->op_type == OP_NBIT_OR     || o->op_type == OP_SBIT_OR
     || o->op_type == OP_NBIT_XOR    || o->op_type == OP_SBIT_XOR
     || o->op_type == OP_NBIT_AND    || o->op_type == OP_SBIT_AND
     || o->op_type == OP_NCOMPLEMENT || o->op_type == OP_SCOMPLEMENT)
	Perl_ck_warner_d(aTHX_ packWARN(WARN_EXPERIMENTAL__BITWISE),
			      "The bitwise feature is experimental");
    if (!(o->op_flags & OPf_STACKED) /* Not an assignment */
	    && OP_IS_INFIX_BIT(o->op_type))
    {
	const OP * const left = cBINOPo->op_first;
	const OP * const right = OpSIBLING(left);
	if ((OP_IS_NUMCOMPARE(left->op_type) &&
		(left->op_flags & OPf_PARENS) == 0) ||
	    (OP_IS_NUMCOMPARE(right->op_type) &&
		(right->op_flags & OPf_PARENS) == 0))
	    Perl_ck_warner(aTHX_ packWARN(WARN_PRECEDENCE),
			  "Possible precedence problem on bitwise %s operator",
			   o->op_type ==  OP_BIT_OR
			 ||o->op_type == OP_NBIT_OR  ? "|"
			:  o->op_type ==  OP_BIT_AND
			 ||o->op_type == OP_NBIT_AND ? "&"
			:  o->op_type ==  OP_BIT_XOR
			 ||o->op_type == OP_NBIT_XOR ? "^"
			:  o->op_type == OP_SBIT_OR  ? "|."
			:  o->op_type == OP_SBIT_AND ? "&." : "^."
			   );
    }
    return o;
}

PERL_STATIC_INLINE bool
is_dollar_bracket(pTHX_ const OP * const o)
{
    const OP *kid;
    PERL_UNUSED_CONTEXT;
    return o->op_type == OP_RV2SV && o->op_flags & OPf_KIDS
	&& (kid = cUNOPx(o)->op_first)
	&& kid->op_type == OP_GV
	&& strEQ(GvNAME(cGVOPx_gv(kid)), "[");
}

OP *
Perl_ck_cmp(pTHX_ OP *o)
{
    PERL_ARGS_ASSERT_CK_CMP;
    if (ckWARN(WARN_SYNTAX)) {
	const OP *kid = cUNOPo->op_first;
	if (kid &&
            (
		(   is_dollar_bracket(aTHX_ kid)
                 && OpSIBLING(kid) && OpSIBLING(kid)->op_type == OP_CONST
		)
	     || (   kid->op_type == OP_CONST
		 && (kid = OpSIBLING(kid)) && is_dollar_bracket(aTHX_ kid)
                )
	   )
        )
	    Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
			"$[ used in %s (did you mean $] ?)", OP_DESC(o));
    }
    return o;
}

OP *
Perl_ck_concat(pTHX_ OP *o)
{
    const OP * const kid = cUNOPo->op_first;

    PERL_ARGS_ASSERT_CK_CONCAT;
    PERL_UNUSED_CONTEXT;

    if (kid->op_type == OP_CONCAT && !(kid->op_private & OPpTARGET_MY) &&
	    !(kUNOP->op_first->op_flags & OPf_MOD))
        o->op_flags |= OPf_STACKED;
    return o;
}

OP *
Perl_ck_spair(pTHX_ OP *o)
{
    dVAR;

    PERL_ARGS_ASSERT_CK_SPAIR;

    if (o->op_flags & OPf_KIDS) {
	OP* newop;
	OP* kid;
        OP* kidkid;
	const OPCODE type = o->op_type;
	o = modkids(ck_fun(o), type);
	kid    = cUNOPo->op_first;
	kidkid = kUNOP->op_first;
	newop = OpSIBLING(kidkid);
	if (newop) {
	    const OPCODE type = newop->op_type;
	    if (OpHAS_SIBLING(newop))
		return o;
	    if (o->op_type == OP_REFGEN
	     && (  type == OP_RV2CV
		|| (  !(newop->op_flags & OPf_PARENS)
		   && (  type == OP_RV2AV || type == OP_PADAV
		      || type == OP_RV2HV || type == OP_PADHV))))
	    	NOOP; /* OK (allow srefgen for \@@a and \%h) */
	    else if (OP_GIMME(newop,0) != G_SCALAR)
		return o;
	}
        /* excise first sibling */
        op_sibling_splice(kid, NULL, 1, NULL);
	op_free(kidkid);
    }
    /* transforms OP_REFGEN into OP_SREFGEN, OP_CHOP into OP_SCHOP,
     * and OP_CHOMP into OP_SCHOMP */
    o->op_ppaddr = PL_ppaddr[++o->op_type];
    return ck_fun(o);
}

OP *
Perl_ck_delete(pTHX_ OP *o)
{
    PERL_ARGS_ASSERT_CK_DELETE;

    o = ck_fun(o);
    o->op_private = 0;
    if (o->op_flags & OPf_KIDS) {
	OP * const kid = cUNOPo->op_first;
	switch (kid->op_type) {
	case OP_ASLICE:
	    o->op_flags |= OPf_SPECIAL;
	    /* FALLTHROUGH */
	case OP_HSLICE:
	    o->op_private |= OPpSLICE;
	    break;
	case OP_AELEM:
	    o->op_flags |= OPf_SPECIAL;
	    /* FALLTHROUGH */
	case OP_HELEM:
	    break;
	case OP_KVASLICE:
	    Perl_croak(aTHX_ "delete argument is index/value array slice,"
			     " use array slice");
	case OP_KVHSLICE:
	    Perl_croak(aTHX_ "delete argument is key/value hash slice, use"
			     " hash slice");
	default:
	    Perl_croak(aTHX_ "delete argument is not a HASH or ARRAY "
			     "element or slice");
	}
	if (kid->op_private & OPpLVAL_INTRO)
	    o->op_private |= OPpLVAL_INTRO;
	op_null(kid);
    }
    return o;
}

OP *
Perl_ck_eof(pTHX_ OP *o)
{
    PERL_ARGS_ASSERT_CK_EOF;

    if (o->op_flags & OPf_KIDS) {
	OP *kid;
	if (cLISTOPo->op_first->op_type == OP_STUB) {
	    OP * const newop
		= newUNOP(o->op_type, OPf_SPECIAL, newGVOP(OP_GV, 0, PL_argvgv));
	    op_free(o);
	    o = newop;
	}
	o = ck_fun(o);
	kid = cLISTOPo->op_first;
	if (kid->op_type == OP_RV2GV)
	    kid->op_private |= OPpALLOW_FAKE;
    }
    return o;
}

OP *
Perl_ck_eval(pTHX_ OP *o)
{
    dVAR;

    PERL_ARGS_ASSERT_CK_EVAL;

    PL_hints |= HINT_BLOCK_SCOPE;
    if (o->op_flags & OPf_KIDS) {
	SVOP * const kid = (SVOP*)cUNOPo->op_first;
	assert(kid);

	if (o->op_type == OP_ENTERTRY) {
	    LOGOP *enter;

            /* cut whole sibling chain free from o */
            op_sibling_splice(o, NULL, -1, NULL);
	    op_free(o);

            enter = S_alloc_LOGOP(aTHX_ OP_ENTERTRY, NULL, NULL);

	    /* establish postfix order */
	    enter->op_next = (OP*)enter;

	    o = op_prepend_elem(OP_LINESEQ, (OP*)enter, (OP*)kid);
            OpTYPE_set(o, OP_LEAVETRY);
	    enter->op_other = o;
	    return o;
	}
	else {
	    scalar((OP*)kid);
	    S_set_haseval(aTHX);
	}
    }
    else {
	const U8 priv = o->op_private;
	op_free(o);
        /* the newUNOP will recursively call ck_eval(), which will handle
         * all the stuff at the end of this function, like adding
         * OP_HINTSEVAL
         */
	return newUNOP(OP_ENTEREVAL, priv <<8, newDEFSVOP());
    }
    o->op_targ = (PADOFFSET)PL_hints;
    if (o->op_private & OPpEVAL_BYTES) o->op_targ &= ~HINT_UTF8;
    if ((PL_hints & HINT_LOCALIZE_HH) != 0
     && !(o->op_private & OPpEVAL_COPHH) && GvHV(PL_hintgv)) {
	/* Store a copy of %^H that pp_entereval can pick up. */
	OP *hhop = newSVOP(OP_HINTSEVAL, 0,
			   MUTABLE_SV(hv_copy_hints_hv(GvHV(PL_hintgv))));
        /* append hhop to only child  */
        op_sibling_splice(o, cUNOPo->op_first, 0, hhop);

	o->op_private |= OPpEVAL_HAS_HH;
    }
    if (!(o->op_private & OPpEVAL_BYTES)
	 && FEATURE_UNIEVAL_IS_ENABLED)
	    o->op_private |= OPpEVAL_UNICODE;
    return o;
}

OP *
Perl_ck_exec(pTHX_ OP *o)
{
    PERL_ARGS_ASSERT_CK_EXEC;

    if (o->op_flags & OPf_STACKED) {
        OP *kid;
	o = ck_fun(o);
	kid = OpSIBLING(cUNOPo->op_first);
	if (kid->op_type == OP_RV2GV)
	    op_null(kid);
    }
    else
	o = listkids(o);
    return o;
}

OP *
Perl_ck_exists(pTHX_ OP *o)
{
    PERL_ARGS_ASSERT_CK_EXISTS;

    o = ck_fun(o);
    if (o->op_flags & OPf_KIDS) {
	OP * const kid = cUNOPo->op_first;
	if (kid->op_type == OP_ENTERSUB) {
	    (void) ref(kid, o->op_type);
	    if (kid->op_type != OP_RV2CV
			&& !(PL_parser && PL_parser->error_count))
		Perl_croak(aTHX_
			  "exists argument is not a subroutine name");
	    o->op_private |= OPpEXISTS_SUB;
	}
	else if (kid->op_type == OP_AELEM)
	    o->op_flags |= OPf_SPECIAL;
	else if (kid->op_type != OP_HELEM)
	    Perl_croak(aTHX_ "exists argument is not a HASH or ARRAY "
			     "element or a subroutine");
	op_null(kid);
    }
    return o;
}

OP *
Perl_ck_rvconst(pTHX_ OP *o)
{
    dVAR;
    SVOP * const kid = (SVOP*)cUNOPo->op_first;

    PERL_ARGS_ASSERT_CK_RVCONST;

    o->op_private |= (PL_hints & HINT_STRICT_REFS);

    if (kid->op_type == OP_CONST) {
	int iscv;
	GV *gv;
	SV * const kidsv = kid->op_sv;

	/* Is it a constant from cv_const_sv()? */
	if ((SvROK(kidsv) || isGV_with_GP(kidsv)) && SvREADONLY(kidsv)) {
	    return o;
	}
	if (SvTYPE(kidsv) == SVt_PVAV) return o;
	if ((o->op_private & HINT_STRICT_REFS) && (kid->op_private & OPpCONST_BARE)) {
	    const char *badthing;
	    switch (o->op_type) {
	    case OP_RV2SV:
		badthing = "a SCALAR";
		break;
	    case OP_RV2AV:
		badthing = "an ARRAY";
		break;
	    case OP_RV2HV:
		badthing = "a HASH";
		break;
	    default:
		badthing = NULL;
		break;
	    }
	    if (badthing)
		Perl_croak(aTHX_
			   "Can't use bareword (\"%"SVf"\") as %s ref while \"strict refs\" in use",
			   SVfARG(kidsv), badthing);
	}
	/*
	 * This is a little tricky.  We only want to add the symbol if we
	 * didn't add it in the lexer.  Otherwise we get duplicate strict
	 * warnings.  But if we didn't add it in the lexer, we must at
	 * least pretend like we wanted to add it even if it existed before,
	 * or we get possible typo warnings.  OPpCONST_ENTERED says
	 * whether the lexer already added THIS instance of this symbol.
	 */
	iscv = o->op_type == OP_RV2CV ? GV_NOEXPAND|GV_ADDMULTI : 0;
	gv = gv_fetchsv(kidsv,
		o->op_type == OP_RV2CV
			&& o->op_private & OPpMAY_RETURN_CONSTANT
		    ? GV_NOEXPAND
		    : iscv | !(kid->op_private & OPpCONST_ENTERED),
		iscv
		    ? SVt_PVCV
		    : o->op_type == OP_RV2SV
			? SVt_PV
			: o->op_type == OP_RV2AV
			    ? SVt_PVAV
			    : o->op_type == OP_RV2HV
				? SVt_PVHV
				: SVt_PVGV);
	if (gv) {
	    if (!isGV(gv)) {
		assert(iscv);
		assert(SvROK(gv));
		if (!(o->op_private & OPpMAY_RETURN_CONSTANT)
		  && SvTYPE(SvRV(gv)) != SVt_PVCV)
		    gv_fetchsv(kidsv, GV_ADDMULTI, SVt_PVCV);
	    }
            OpTYPE_set(kid, OP_GV);
	    SvREFCNT_dec(kid->op_sv);
#ifdef USE_ITHREADS
	    /* XXX hack: dependence on sizeof(PADOP) <= sizeof(SVOP) */
	    STATIC_ASSERT_STMT(sizeof(PADOP) <= sizeof(SVOP));
	    kPADOP->op_padix = pad_alloc(OP_GV, SVf_READONLY);
	    SvREFCNT_dec(PAD_SVl(kPADOP->op_padix));
	    PAD_SETSV(kPADOP->op_padix, MUTABLE_SV(SvREFCNT_inc_simple_NN(gv)));
#else
	    kid->op_sv = SvREFCNT_inc_simple_NN(gv);
#endif
	    kid->op_private = 0;
	    /* FAKE globs in the symbol table cause weird bugs (#77810) */
	    SvFAKE_off(gv);
	}
    }
    return o;
}

OP *
Perl_ck_ftst(pTHX_ OP *o)
{
    dVAR;
    const I32 type = o->op_type;

    PERL_ARGS_ASSERT_CK_FTST;

    if (o->op_flags & OPf_REF) {
	NOOP;
    }
    else if (o->op_flags & OPf_KIDS && cUNOPo->op_first->op_type != OP_STUB) {
	SVOP * const kid = (SVOP*)cUNOPo->op_first;
	const OPCODE kidtype = kid->op_type;

	if (kidtype == OP_CONST && (kid->op_private & OPpCONST_BARE)
	 && !kid->op_folded) {
	    OP * const newop = newGVOP(type, OPf_REF,
		gv_fetchsv(kid->op_sv, GV_ADD, SVt_PVIO));
	    op_free(o);
	    return newop;
	}

        if ((kidtype == OP_RV2AV || kidtype == OP_PADAV) && ckWARN(WARN_SYNTAX)) {
            SV *name = S_op_varname_subscript(aTHX_ (OP*)kid, 2);
            if (name) {
                /* diag_listed_as: Array passed to stat will be coerced to a scalar%s */
                Perl_warner(aTHX_ packWARN(WARN_SYNTAX), "%s (did you want stat %" SVf "?)",
                            array_passed_to_stat, name);
            }
            else {
                /* diag_listed_as: Array passed to stat will be coerced to a scalar%s */
                Perl_warner(aTHX_ packWARN(WARN_SYNTAX), "%s", array_passed_to_stat);
            }
       }
	scalar((OP *) kid);
	if ((PL_hints & HINT_FILETEST_ACCESS) && OP_IS_FILETEST_ACCESS(o->op_type))
	    o->op_private |= OPpFT_ACCESS;
	if (type != OP_STAT && type != OP_LSTAT
            && PL_check[kidtype] == Perl_ck_ftst
            && kidtype != OP_STAT && kidtype != OP_LSTAT
        ) {
	    o->op_private |= OPpFT_STACKED;
	    kid->op_private |= OPpFT_STACKING;
	    if (kidtype == OP_FTTTY && (
		   !(kid->op_private & OPpFT_STACKED)
		|| kid->op_private & OPpFT_AFTER_t
	       ))
		o->op_private |= OPpFT_AFTER_t;
	}
    }
    else {
	op_free(o);
	if (type == OP_FTTTY)
	    o = newGVOP(type, OPf_REF, PL_stdingv);
	else
	    o = newUNOP(type, 0, newDEFSVOP());
    }
    return o;
}

OP *
Perl_ck_fun(pTHX_ OP *o)
{
    const int type = o->op_type;
    I32 oa = PL_opargs[type] >> OASHIFT;

    PERL_ARGS_ASSERT_CK_FUN;

    if (o->op_flags & OPf_STACKED) {
	if ((oa & OA_OPTIONAL) && (oa >> 4) && !((oa >> 4) & OA_OPTIONAL))
	    oa &= ~OA_OPTIONAL;
	else
	    return no_fh_allowed(o);
    }

    if (o->op_flags & OPf_KIDS) {
        OP *prev_kid = NULL;
        OP *kid = cLISTOPo->op_first;
        I32 numargs = 0;
	bool seen_optional = FALSE;

	if (kid->op_type == OP_PUSHMARK ||
	    (kid->op_type == OP_NULL && kid->op_targ == OP_PUSHMARK))
	{
	    prev_kid = kid;
	    kid = OpSIBLING(kid);
	}
	if (kid && kid->op_type == OP_COREARGS) {
	    bool optional = FALSE;
	    while (oa) {
		numargs++;
		if (oa & OA_OPTIONAL) optional = TRUE;
		oa = oa >> 4;
	    }
	    if (optional) o->op_private |= numargs;
	    return o;
	}

	while (oa) {
	    if (oa & OA_OPTIONAL || (oa & 7) == OA_LIST) {
		if (!kid && !seen_optional && PL_opargs[type] & OA_DEFGV) {
		    kid = newDEFSVOP();
                    /* append kid to chain */
                    op_sibling_splice(o, prev_kid, 0, kid);
                }
		seen_optional = TRUE;
	    }
	    if (!kid) break;

	    numargs++;
	    switch (oa & 7) {
	    case OA_SCALAR:
		/* list seen where single (scalar) arg expected? */
		if (numargs == 1 && !(oa >> 4)
		    && kid->op_type == OP_LIST && type != OP_SCALAR)
		{
		    return too_many_arguments_pv(o,PL_op_desc[type], 0);
		}
		if (type != OP_DELETE) scalar(kid);
		break;
	    case OA_LIST:
		if (oa < 16) {
		    kid = 0;
		    continue;
		}
		else
		    list(kid);
		break;
	    case OA_AVREF:
		if ((type == OP_PUSH || type == OP_UNSHIFT)
		    && !OpHAS_SIBLING(kid))
		    Perl_ck_warner(aTHX_ packWARN(WARN_SYNTAX),
				   "Useless use of %s with no values",
				   PL_op_desc[type]);

		if (kid->op_type == OP_CONST
		      && (  !SvROK(cSVOPx_sv(kid)) 
		         || SvTYPE(SvRV(cSVOPx_sv(kid))) != SVt_PVAV  )
		        )
		    bad_type_pv(numargs, "array", o, kid);
		else if (kid->op_type != OP_RV2AV && kid->op_type != OP_PADAV) {
                    yyerror_pv(Perl_form(aTHX_ "Experimental %s on scalar is now forbidden",
                                         PL_op_desc[type]), 0);
		}
                else {
                    op_lvalue(kid, type);
                }
		break;
	    case OA_HVREF:
		if (kid->op_type != OP_RV2HV && kid->op_type != OP_PADHV)
		    bad_type_pv(numargs, "hash", o, kid);
		op_lvalue(kid, type);
		break;
	    case OA_CVREF:
		{
                    /* replace kid with newop in chain */
		    OP * const newop =
                        S_op_sibling_newUNOP(aTHX_ o, prev_kid, OP_NULL, 0);
		    newop->op_next = newop;
		    kid = newop;
		}
		break;
	    case OA_FILEREF:
		if (kid->op_type != OP_GV && kid->op_type != OP_RV2GV) {
		    if (kid->op_type == OP_CONST &&
			(kid->op_private & OPpCONST_BARE))
		    {
			OP * const newop = newGVOP(OP_GV, 0,
			    gv_fetchsv(((SVOP*)kid)->op_sv, GV_ADD, SVt_PVIO));
                        /* replace kid with newop in chain */
                        op_sibling_splice(o, prev_kid, 1, newop);
			op_free(kid);
			kid = newop;
		    }
		    else if (kid->op_type == OP_READLINE) {
			/* neophyte patrol: open(<FH>), close(<FH>) etc. */
			bad_type_pv(numargs, "HANDLE", o, kid);
		    }
		    else {
			I32 flags = OPf_SPECIAL;
			I32 priv = 0;
			PADOFFSET targ = 0;

			/* is this op a FH constructor? */
			if (is_handle_constructor(o,numargs)) {
                            const char *name = NULL;
			    STRLEN len = 0;
                            U32 name_utf8 = 0;
			    bool want_dollar = TRUE;

			    flags = 0;
			    /* Set a flag to tell rv2gv to vivify
			     * need to "prove" flag does not mean something
			     * else already - NI-S 1999/05/07
			     */
			    priv = OPpDEREF;
			    if (kid->op_type == OP_PADSV) {
				PADNAME * const pn
				    = PAD_COMPNAME_SV(kid->op_targ);
				name = PadnamePV (pn);
				len  = PadnameLEN(pn);
				name_utf8 = PadnameUTF8(pn);
			    }
			    else if (kid->op_type == OP_RV2SV
				     && kUNOP->op_first->op_type == OP_GV)
			    {
				GV * const gv = cGVOPx_gv(kUNOP->op_first);
				name = GvNAME(gv);
				len = GvNAMELEN(gv);
                                name_utf8 = GvNAMEUTF8(gv) ? SVf_UTF8 : 0;
			    }
			    else if (kid->op_type == OP_AELEM
				     || kid->op_type == OP_HELEM)
			    {
				 OP *firstop;
				 OP *op = ((BINOP*)kid)->op_first;
				 name = NULL;
				 if (op) {
				      SV *tmpstr = NULL;
				      const char * const a =
					   kid->op_type == OP_AELEM ?
					   "[]" : "{}";
				      if (((op->op_type == OP_RV2AV) ||
					   (op->op_type == OP_RV2HV)) &&
					  (firstop = ((UNOP*)op)->op_first) &&
					  (firstop->op_type == OP_GV)) {
					   /* packagevar $a[] or $h{} */
					   GV * const gv = cGVOPx_gv(firstop);
					   if (gv)
						tmpstr =
						     Perl_newSVpvf(aTHX_
								   "%s%c...%c",
								   GvNAME(gv),
								   a[0], a[1]);
				      }
				      else if (op->op_type == OP_PADAV
					       || op->op_type == OP_PADHV) {
					   /* lexicalvar $a[] or $h{} */
					   const char * const padname =
						PAD_COMPNAME_PV(op->op_targ);
					   if (padname)
						tmpstr =
						     Perl_newSVpvf(aTHX_
								   "%s%c...%c",
								   padname + 1,
								   a[0], a[1]);
				      }
				      if (tmpstr) {
					   name = SvPV_const(tmpstr, len);
                                           name_utf8 = SvUTF8(tmpstr);
					   sv_2mortal(tmpstr);
				      }
				 }
				 if (!name) {
				      name = "__ANONIO__";
				      len = 10;
				      want_dollar = FALSE;
				 }
				 op_lvalue(kid, type);
			    }
			    if (name) {
				SV *namesv;
				targ = pad_alloc(OP_RV2GV, SVf_READONLY);
				namesv = PAD_SVl(targ);
				if (want_dollar && *name != '$')
				    sv_setpvs(namesv, "$");
				else
				    sv_setpvs(namesv, "");
				sv_catpvn(namesv, name, len);
                                if ( name_utf8 ) SvUTF8_on(namesv);
			    }
			}
                        scalar(kid);
                        kid = S_op_sibling_newUNOP(aTHX_ o, prev_kid,
                                    OP_RV2GV, flags);
                        kid->op_targ = targ;
                        kid->op_private |= priv;
		    }
		}
		scalar(kid);
		break;
	    case OA_SCALARREF:
		if ((type == OP_UNDEF || type == OP_POS)
		    && numargs == 1 && !(oa >> 4)
		    && kid->op_type == OP_LIST)
		    return too_many_arguments_pv(o,PL_op_desc[type], 0);
		op_lvalue(scalar(kid), type);
		break;
	    }
	    oa >>= 4;
	    prev_kid = kid;
	    kid = OpSIBLING(kid);
	}
	/* FIXME - should the numargs or-ing move after the too many
         * arguments check? */
	o->op_private |= numargs;
	if (kid)
	    return too_many_arguments_pv(o,OP_DESC(o), 0);
	listkids(o);
    }
    else if (PL_opargs[type] & OA_DEFGV) {
	/* Ordering of these two is important to keep f_map.t passing.  */
	op_free(o);
	return newUNOP(type, 0, newDEFSVOP());
    }

    if (oa) {
	while (oa & OA_OPTIONAL)
	    oa >>= 4;
	if (oa && oa != OA_LIST)
	    return too_few_arguments_pv(o,OP_DESC(o), 0);
    }
    return o;
}

OP *
Perl_ck_glob(pTHX_ OP *o)
{
    GV *gv;

    PERL_ARGS_ASSERT_CK_GLOB;

    o = ck_fun(o);
    if ((o->op_flags & OPf_KIDS) && !OpHAS_SIBLING(cLISTOPo->op_first))
	op_append_elem(OP_GLOB, o, newDEFSVOP()); /* glob() => glob($_) */

    if (!(o->op_flags & OPf_SPECIAL) && (gv = gv_override("glob", 4)))
    {
	/* convert
	 *     glob
	 *       \ null - const(wildcard)
	 * into
	 *     null
	 *       \ enter
	 *            \ list
	 *                 \ mark - glob - rv2cv
	 *                             |        \ gv(CORE::GLOBAL::glob)
	 *                             |
	 *                              \ null - const(wildcard)
	 */
	o->op_flags |= OPf_SPECIAL;
	o->op_targ = pad_alloc(OP_GLOB, SVs_PADTMP);
	o = S_new_entersubop(aTHX_ gv, o);
	o = newUNOP(OP_NULL, 0, o);
	o->op_targ = OP_GLOB; /* hint at what it used to be: eg in newWHILEOP */
	return o;
    }
    else o->op_flags &= ~OPf_SPECIAL;
#if !defined(PERL_EXTERNAL_GLOB)
    if (!PL_globhook) {
	ENTER;
	Perl_load_module(aTHX_ PERL_LOADMOD_NOIMPORT,
			       newSVpvs("File::Glob"), NULL, NULL, NULL);
	LEAVE;
    }
#endif /* !PERL_EXTERNAL_GLOB */
    gv = (GV *)newSV(0);
    gv_init(gv, 0, "", 0, 0);
    gv_IOadd(gv);
    op_append_elem(OP_GLOB, o, newGVOP(OP_GV, 0, gv));
    SvREFCNT_dec_NN(gv); /* newGVOP increased it */
    scalarkids(o);
    return o;
}

OP *
Perl_ck_grep(pTHX_ OP *o)
{
    LOGOP *gwop;
    OP *kid;
    const OPCODE type = o->op_type == OP_GREPSTART ? OP_GREPWHILE : OP_MAPWHILE;

    PERL_ARGS_ASSERT_CK_GREP;

    /* don't allocate gwop here, as we may leak it if PL_parser->error_count > 0 */

    if (o->op_flags & OPf_STACKED) {
	kid = cUNOPx(OpSIBLING(cLISTOPo->op_first))->op_first;
	if (kid->op_type != OP_SCOPE && kid->op_type != OP_LEAVE)
	    return no_fh_allowed(o);
	o->op_flags &= ~OPf_STACKED;
    }
    kid = OpSIBLING(cLISTOPo->op_first);
    if (type == OP_MAPWHILE)
	list(kid);
    else
	scalar(kid);
    o = ck_fun(o);
    if (PL_parser && PL_parser->error_count)
	return o;
    kid = OpSIBLING(cLISTOPo->op_first);
    if (kid->op_type != OP_NULL)
	Perl_croak(aTHX_ "panic: ck_grep, type=%u", (unsigned) kid->op_type);
    kid = kUNOP->op_first;

    gwop = S_alloc_LOGOP(aTHX_ type, o, LINKLIST(kid));
    kid->op_next = (OP*)gwop;
    o->op_private = gwop->op_private = 0;
    gwop->op_targ = pad_alloc(type, SVs_PADTMP);

    kid = OpSIBLING(cLISTOPo->op_first);
    for (kid = OpSIBLING(kid); kid; kid = OpSIBLING(kid))
	op_lvalue(kid, OP_GREPSTART);

    return (OP*)gwop;
}

OP *
Perl_ck_index(pTHX_ OP *o)
{
    PERL_ARGS_ASSERT_CK_INDEX;

    if (o->op_flags & OPf_KIDS) {
	OP *kid = OpSIBLING(cLISTOPo->op_first);	/* get past pushmark */
	if (kid)
	    kid = OpSIBLING(kid);			/* get past "big" */
	if (kid && kid->op_type == OP_CONST) {
	    const bool save_taint = TAINT_get;
	    SV *sv = kSVOP->op_sv;
	    if ((!SvPOK(sv) || SvNIOKp(sv)) && SvOK(sv) && !SvROK(sv)) {
		sv = newSV(0);
		sv_copypv(sv, kSVOP->op_sv);
		SvREFCNT_dec_NN(kSVOP->op_sv);
		kSVOP->op_sv = sv;
	    }
	    if (SvOK(sv)) fbm_compile(sv, 0);
	    TAINT_set(save_taint);
#ifdef NO_TAINT_SUPPORT
            PERL_UNUSED_VAR(save_taint);
#endif
	}
    }
    return ck_fun(o);
}

OP *
Perl_ck_lfun(pTHX_ OP *o)
{
    const OPCODE type = o->op_type;

    PERL_ARGS_ASSERT_CK_LFUN;

    return modkids(ck_fun(o), type);
}

OP *
Perl_ck_defined(pTHX_ OP *o)		/* 19990527 MJD */
{
    PERL_ARGS_ASSERT_CK_DEFINED;

    if ((o->op_flags & OPf_KIDS)) {
	switch (cUNOPo->op_first->op_type) {
	case OP_RV2AV:
	case OP_PADAV:
	    Perl_croak(aTHX_ "Can't use 'defined(@@array)'"
			     " (Maybe you should just omit the defined()?)");
	break;
	case OP_RV2HV:
	case OP_PADHV:
	    Perl_croak(aTHX_ "Can't use 'defined(%%hash)'"
			     " (Maybe you should just omit the defined()?)");
	    break;
	default:
	    /* no warning */
	    break;
	}
    }
    return ck_rfun(o);
}

OP *
Perl_ck_readline(pTHX_ OP *o)
{
    PERL_ARGS_ASSERT_CK_READLINE;

    if (o->op_flags & OPf_KIDS) {
	 OP *kid = cLISTOPo->op_first;
	 if (kid->op_type == OP_RV2GV) kid->op_private |= OPpALLOW_FAKE;
    }
    else {
	OP * const newop
	    = newUNOP(OP_READLINE, 0, newGVOP(OP_GV, 0, PL_argvgv));
	op_free(o);
	return newop;
    }
    return o;
}

OP *
Perl_ck_rfun(pTHX_ OP *o)
{
    const OPCODE type = o->op_type;

    PERL_ARGS_ASSERT_CK_RFUN;

    return refkids(ck_fun(o), type);
}

OP *
Perl_ck_listiob(pTHX_ OP *o)
{
    OP *kid;

    PERL_ARGS_ASSERT_CK_LISTIOB;

    kid = cLISTOPo->op_first;
    if (!kid) {
	o = force_list(o, 1);
	kid = cLISTOPo->op_first;
    }
    if (kid->op_type == OP_PUSHMARK)
	kid = OpSIBLING(kid);
    if (kid && o->op_flags & OPf_STACKED)
	kid = OpSIBLING(kid);
    else if (kid && !OpHAS_SIBLING(kid)) {		/* print HANDLE; */
	if (kid->op_type == OP_CONST && kid->op_private & OPpCONST_BARE
	 && !kid->op_folded) {
	    o->op_flags |= OPf_STACKED;	/* make it a filehandle */
            scalar(kid);
            /* replace old const op with new OP_RV2GV parent */
            kid = S_op_sibling_newUNOP(aTHX_ o, cLISTOPo->op_first,
                                        OP_RV2GV, OPf_REF);
            kid = OpSIBLING(kid);
	}
    }

    if (!kid)
	op_append_elem(o->op_type, o, newDEFSVOP());

    if (o->op_type == OP_PRTF) return modkids(listkids(o), OP_PRTF);
    return listkids(o);
}

OP *
Perl_ck_smartmatch(pTHX_ OP *o)
{
    dVAR;
    PERL_ARGS_ASSERT_CK_SMARTMATCH;
    if (0 == (o->op_flags & OPf_SPECIAL)) {
	OP *first  = cBINOPo->op_first;
	OP *second = OpSIBLING(first);
	
	/* Implicitly take a reference to an array or hash */

        /* remove the original two siblings, then add back the
         * (possibly different) first and second sibs.
         */
        op_sibling_splice(o, NULL, 1, NULL);
        op_sibling_splice(o, NULL, 1, NULL);
	first  = ref_array_or_hash(first);
	second = ref_array_or_hash(second);
        op_sibling_splice(o, NULL, 0, second);
        op_sibling_splice(o, NULL, 0, first);
	
	/* Implicitly take a reference to a regular expression */
	if (first->op_type == OP_MATCH) {
            OpTYPE_set(first, OP_QR);
	}
	if (second->op_type == OP_MATCH) {
            OpTYPE_set(second, OP_QR);
        }
    }
    
    return o;
}


static OP *
S_maybe_targlex(pTHX_ OP *o)
{
    OP * const kid = cLISTOPo->op_first;
    /* has a disposable target? */
    if ((PL_opargs[kid->op_type] & OA_TARGLEX)
	&& !(kid->op_flags & OPf_STACKED)
	/* Cannot steal the second time! */
	&& !(kid->op_private & OPpTARGET_MY)
	)
    {
	OP * const kkid = OpSIBLING(kid);

	/* Can just relocate the target. */
	if (kkid && kkid->op_type == OP_PADSV
	    && (!(kkid->op_private & OPpLVAL_INTRO)
	       || kkid->op_private & OPpPAD_STATE))
	{
	    kid->op_targ = kkid->op_targ;
	    kkid->op_targ = 0;
	    /* Now we do not need PADSV and SASSIGN.
	     * Detach kid and free the rest. */
	    op_sibling_splice(o, NULL, 1, NULL);
	    op_free(o);
	    kid->op_private |= OPpTARGET_MY;	/* Used for context settings */
	    return kid;
	}
    }
    return o;
}

OP *
Perl_ck_sassign(pTHX_ OP *o)
{
    dVAR;
    OP * const kid = cLISTOPo->op_first;

    PERL_ARGS_ASSERT_CK_SASSIGN;

    if (OpHAS_SIBLING(kid)) {
	OP *kkid = OpSIBLING(kid);
	/* For state variable assignment with attributes, kkid is a list op
	   whose op_last is a padsv. */
	if ((kkid->op_type == OP_PADSV ||
	     (OP_TYPE_IS_OR_WAS(kkid, OP_LIST) &&
	      (kkid = cLISTOPx(kkid)->op_last)->op_type == OP_PADSV
	     )
	    )
		&& (kkid->op_private & (OPpLVAL_INTRO|OPpPAD_STATE))
		    == (OPpLVAL_INTRO|OPpPAD_STATE)) {
	    const PADOFFSET target = kkid->op_targ;
	    OP *const other = newOP(OP_PADSV,
				    kkid->op_flags
				    | ((kkid->op_private & ~OPpLVAL_INTRO) << 8));
	    OP *const first = newOP(OP_NULL, 0);
	    OP *const nullop =
		newCONDOP(0, first, o, other);
	    /* XXX targlex disabled for now; see ticket #124160
		newCONDOP(0, first, S_maybe_targlex(aTHX_ o), other);
	     */
	    OP *const condop = first->op_next;

            OpTYPE_set(condop, OP_ONCE);
	    other->op_targ = target;
	    nullop->op_flags |= OPf_WANT_SCALAR;

	    /* Store the initializedness of state vars in a separate
	       pad entry.  */
	    condop->op_targ =
	      pad_add_name_pvn("$",1,padadd_NO_DUP_CHECK|padadd_STATE,0,0);
	    /* hijacking PADSTALE for uninitialized state variables */
	    SvPADSTALE_on(PAD_SVl(condop->op_targ));

	    return nullop;
	}
    }
    return S_maybe_targlex(aTHX_ o);
}

OP *
Perl_ck_match(pTHX_ OP *o)
{
    PERL_UNUSED_CONTEXT;
    PERL_ARGS_ASSERT_CK_MATCH;

    if (o->op_type == OP_MATCH || o->op_type == OP_QR)
	o->op_private |= OPpRUNTIME;
    return o;
}

OP *
Perl_ck_method(pTHX_ OP *o)
{
    SV *sv, *methsv, *rclass;
    const char* method;
    char* compatptr;
    int utf8;
    STRLEN len, nsplit = 0, i;
    OP* new_op;
    OP * const kid = cUNOPo->op_first;

    PERL_ARGS_ASSERT_CK_METHOD;
    if (kid->op_type != OP_CONST) return o;

    sv = kSVOP->op_sv;

    /* replace ' with :: */
    while ((compatptr = strchr(SvPVX(sv), '\''))) {
        *compatptr = ':';
        sv_insert(sv, compatptr - SvPVX_const(sv), 0, ":", 1);
    }

    method = SvPVX_const(sv);
    len = SvCUR(sv);
    utf8 = SvUTF8(sv) ? -1 : 1;

    for (i = len - 1; i > 0; --i) if (method[i] == ':') {
        nsplit = i+1;
        break;
    }

    methsv = newSVpvn_share(method+nsplit, utf8*(len - nsplit), 0);

    if (!nsplit) { /* $proto->method() */
        op_free(o);
        return newMETHOP_named(OP_METHOD_NAMED, 0, methsv);
    }

    if (nsplit == 7 && memEQ(method, "SUPER::", nsplit)) { /* $proto->SUPER::method() */
        op_free(o);
        return newMETHOP_named(OP_METHOD_SUPER, 0, methsv);
    }

    /* $proto->MyClass::method() and $proto->MyClass::SUPER::method() */
    if (nsplit >= 9 && strnEQ(method+nsplit-9, "::SUPER::", 9)) {
        rclass = newSVpvn_share(method, utf8*(nsplit-9), 0);
        new_op = newMETHOP_named(OP_METHOD_REDIR_SUPER, 0, methsv);
    } else {
        rclass = newSVpvn_share(method, utf8*(nsplit-2), 0);
        new_op = newMETHOP_named(OP_METHOD_REDIR, 0, methsv);
    }
#ifdef USE_ITHREADS
    op_relocate_sv(&rclass, &cMETHOPx(new_op)->op_rclass_targ);
#else
    cMETHOPx(new_op)->op_rclass_sv = rclass;
#endif
    op_free(o);
    return new_op;
}

OP *
Perl_ck_null(pTHX_ OP *o)
{
    PERL_ARGS_ASSERT_CK_NULL;
    PERL_UNUSED_CONTEXT;
    return o;
}

OP *
Perl_ck_open(pTHX_ OP *o)
{
    PERL_ARGS_ASSERT_CK_OPEN;

    S_io_hints(aTHX_ o);
    {
	 /* In case of three-arg dup open remove strictness
	  * from the last arg if it is a bareword. */
	 OP * const first = cLISTOPx(o)->op_first; /* The pushmark. */
	 OP * const last  = cLISTOPx(o)->op_last;  /* The bareword. */
	 OP *oa;
	 const char *mode;

	 if ((last->op_type == OP_CONST) &&		/* The bareword. */
	     (last->op_private & OPpCONST_BARE) &&
	     (last->op_private & OPpCONST_STRICT) &&
	     (oa = OpSIBLING(first)) &&		/* The fh. */
	     (oa = OpSIBLING(oa)) &&			/* The mode. */
	     (oa->op_type == OP_CONST) &&
	     SvPOK(((SVOP*)oa)->op_sv) &&
	     (mode = SvPVX_const(((SVOP*)oa)->op_sv)) &&
	     mode[0] == '>' && mode[1] == '&' &&	/* A dup open. */
	     (last == OpSIBLING(oa)))			/* The bareword. */
	      last->op_private &= ~OPpCONST_STRICT;
    }
    return ck_fun(o);
}

OP *
Perl_ck_prototype(pTHX_ OP *o)
{
    PERL_ARGS_ASSERT_CK_PROTOTYPE;
    if (!(o->op_flags & OPf_KIDS)) {
	op_free(o);
	return newUNOP(OP_PROTOTYPE, 0, newDEFSVOP());
    }
    return o;
}

OP *
Perl_ck_refassign(pTHX_ OP *o)
{
    OP * const right = cLISTOPo->op_first;
    OP * const left = OpSIBLING(right);
    OP *varop = cUNOPx(cUNOPx(left)->op_first)->op_first;
    bool stacked = 0;

    PERL_ARGS_ASSERT_CK_REFASSIGN;
    assert (left);
    assert (left->op_type == OP_SREFGEN);

    o->op_private = 0;
    /* we use OPpPAD_STATE in refassign to mean either of those things,
     * and the code assumes the two flags occupy the same bit position
     * in the various ops below */
    assert(OPpPAD_STATE == OPpOUR_INTRO);

    switch (varop->op_type) {
    case OP_PADAV:
	o->op_private |= OPpLVREF_AV;
	goto settarg;
    case OP_PADHV:
	o->op_private |= OPpLVREF_HV;
        /* FALLTHROUGH */
    case OP_PADSV:
      settarg:
        o->op_private |= (varop->op_private & (OPpLVAL_INTRO|OPpPAD_STATE));
	o->op_targ = varop->op_targ;
	varop->op_targ = 0;
	PAD_COMPNAME_GEN_set(o->op_targ, PERL_INT_MAX);
	break;

    case OP_RV2AV:
	o->op_private |= OPpLVREF_AV;
	goto checkgv;
        NOT_REACHED; /* NOTREACHED */
    case OP_RV2HV:
	o->op_private |= OPpLVREF_HV;
        /* FALLTHROUGH */
    case OP_RV2SV:
      checkgv:
        o->op_private |= (varop->op_private & (OPpLVAL_INTRO|OPpOUR_INTRO));
	if (cUNOPx(varop)->op_first->op_type != OP_GV) goto bad;
      detach_and_stack:
	/* Point varop to its GV kid, detached.  */
	varop = op_sibling_splice(varop, NULL, -1, NULL);
	stacked = TRUE;
	break;
    case OP_RV2CV: {
	OP * const kidparent =
	    OpSIBLING(cUNOPx(cUNOPx(varop)->op_first)->op_first);
	OP * const kid = cUNOPx(kidparent)->op_first;
	o->op_private |= OPpLVREF_CV;
	if (kid->op_type == OP_GV) {
	    varop = kidparent;
	    goto detach_and_stack;
	}
	if (kid->op_type != OP_PADCV)	goto bad;
	o->op_targ = kid->op_targ;
	kid->op_targ = 0;
	break;
    }
    case OP_AELEM:
    case OP_HELEM:
        o->op_private |= (varop->op_private & OPpLVAL_INTRO);
	o->op_private |= OPpLVREF_ELEM;
	op_null(varop);
	stacked = TRUE;
	/* Detach varop.  */
	op_sibling_splice(cUNOPx(left)->op_first, NULL, -1, NULL);
	break;
    default:
      bad:
	/* diag_listed_as: Can't modify reference to %s in %s assignment */
	yyerror(Perl_form(aTHX_ "Can't modify reference to %s in scalar "
				"assignment",
				 OP_DESC(varop)));
	return o;
    }
    if (!FEATURE_REFALIASING_IS_ENABLED)
	Perl_croak(aTHX_
		  "Experimental aliasing via reference not enabled");
    Perl_ck_warner_d(aTHX_
		     packWARN(WARN_EXPERIMENTAL__REFALIASING),
		    "Aliasing via reference is experimental");
    if (stacked) {
	o->op_flags |= OPf_STACKED;
	op_sibling_splice(o, right, 1, varop);
    }
    else {
	o->op_flags &=~ OPf_STACKED;
	op_sibling_splice(o, right, 1, NULL);
    }
    op_free(left);
    return o;
}

OP *
Perl_ck_repeat(pTHX_ OP *o)
{
    PERL_ARGS_ASSERT_CK_REPEAT;

    if (cBINOPo->op_first->op_flags & OPf_PARENS) {
        OP* kids;
	o->op_private |= OPpREPEAT_DOLIST;
        kids = op_sibling_splice(o, NULL, 1, NULL); /* detach first kid */
        kids = force_list(kids, 1); /* promote it to a list */
        op_sibling_splice(o, NULL, 0, kids); /* and add back */
    }
    else
	scalar(o);
    return o;
}

OP *
Perl_ck_require(pTHX_ OP *o)
{
    GV* gv;

    PERL_ARGS_ASSERT_CK_REQUIRE;

    if (o->op_flags & OPf_KIDS) {	/* Shall we supply missing .pm? */
	SVOP * const kid = (SVOP*)cUNOPo->op_first;
	HEK *hek;
	U32 hash;
	char *s;
	STRLEN len;
	if (kid->op_type == OP_CONST) {
	  SV * const sv = kid->op_sv;
	  U32 const was_readonly = SvREADONLY(sv);
	  if (kid->op_private & OPpCONST_BARE) {
            dVAR;
	    const char *end;

	    if (was_readonly) {
		    SvREADONLY_off(sv);
	    }   
	    if (SvIsCOW(sv)) sv_force_normal_flags(sv, 0);

	    s = SvPVX(sv);
	    len = SvCUR(sv);
	    end = s + len;
	    for (; s < end; s++) {
		if (*s == ':' && s[1] == ':') {
		    *s = '/';
		    Move(s+2, s+1, end - s - 1, char);
		    --end;
		}
	    }
	    SvEND_set(sv, end);
	    sv_catpvs(sv, ".pm");
	    PERL_HASH(hash, SvPVX(sv), SvCUR(sv));
	    hek = share_hek(SvPVX(sv),
			    (SSize_t)SvCUR(sv) * (SvUTF8(sv) ? -1 : 1),
			    hash);
	    sv_sethek(sv, hek);
	    unshare_hek(hek);
	    SvFLAGS(sv) |= was_readonly;
	  }
	  else if (SvPOK(sv) && !SvNIOK(sv) && !SvGMAGICAL(sv)
		&& !SvVOK(sv)) {
	    s = SvPV(sv, len);
	    if (SvREFCNT(sv) > 1) {
		kid->op_sv = newSVpvn_share(
		    s, SvUTF8(sv) ? -(SSize_t)len : (SSize_t)len, 0);
		SvREFCNT_dec_NN(sv);
	    }
	    else {
                dVAR;
		if (was_readonly) SvREADONLY_off(sv);
		PERL_HASH(hash, s, len);
		hek = share_hek(s,
				SvUTF8(sv) ? -(SSize_t)len : (SSize_t)len,
				hash);
		sv_sethek(sv, hek);
		unshare_hek(hek);
		SvFLAGS(sv) |= was_readonly;
	    }
	  }
	}
    }

    if (!(o->op_flags & OPf_SPECIAL) /* Wasn't written as CORE::require */
	/* handle override, if any */
     && (gv = gv_override("require", 7))) {
	OP *kid, *newop;
	if (o->op_flags & OPf_KIDS) {
	    kid = cUNOPo->op_first;
            op_sibling_splice(o, NULL, -1, NULL);
	}
	else {
	    kid = newDEFSVOP();
	}
	op_free(o);
	newop = S_new_entersubop(aTHX_ gv, kid);
	return newop;
    }

    return ck_fun(o);
}

OP *
Perl_ck_return(pTHX_ OP *o)
{
    OP *kid;

    PERL_ARGS_ASSERT_CK_RETURN;

    kid = OpSIBLING(cLISTOPo->op_first);
    if (CvLVALUE(PL_compcv)) {
	for (; kid; kid = OpSIBLING(kid))
	    op_lvalue(kid, OP_LEAVESUBLV);
    }

    return o;
}

OP *
Perl_ck_select(pTHX_ OP *o)
{
    dVAR;
    OP* kid;

    PERL_ARGS_ASSERT_CK_SELECT;

    if (o->op_flags & OPf_KIDS) {
        kid = OpSIBLING(cLISTOPo->op_first);     /* get past pushmark */
        if (kid && OpHAS_SIBLING(kid)) {
            OpTYPE_set(o, OP_SSELECT);
	    o = ck_fun(o);
	    return fold_constants(op_integerize(op_std_init(o)));
	}
    }
    o = ck_fun(o);
    kid = OpSIBLING(cLISTOPo->op_first);    /* get past pushmark */
    if (kid && kid->op_type == OP_RV2GV)
	kid->op_private &= ~HINT_STRICT_REFS;
    return o;
}

OP *
Perl_ck_shift(pTHX_ OP *o)
{
    const I32 type = o->op_type;

    PERL_ARGS_ASSERT_CK_SHIFT;

    if (!(o->op_flags & OPf_KIDS)) {
	OP *argop;

	if (!CvUNIQUE(PL_compcv)) {
	    o->op_flags |= OPf_SPECIAL;
	    return o;
	}

	argop = newUNOP(OP_RV2AV, 0, scalar(newGVOP(OP_GV, 0, PL_argvgv)));
	op_free(o);
	return newUNOP(type, 0, scalar(argop));
    }
    return scalar(ck_fun(o));
}

OP *
Perl_ck_sort(pTHX_ OP *o)
{
    OP *firstkid;
    OP *kid;
    HV * const hinthv =
	PL_hints & HINT_LOCALIZE_HH ? GvHV(PL_hintgv) : NULL;
    U8 stacked;

    PERL_ARGS_ASSERT_CK_SORT;

    if (hinthv) {
	    SV ** const svp = hv_fetchs(hinthv, "sort", FALSE);
	    if (svp) {
		const I32 sorthints = (I32)SvIV(*svp);
		if ((sorthints & HINT_SORT_QUICKSORT) != 0)
		    o->op_private |= OPpSORT_QSORT;
		if ((sorthints & HINT_SORT_STABLE) != 0)
		    o->op_private |= OPpSORT_STABLE;
	    }
    }

    if (o->op_flags & OPf_STACKED)
	simplify_sort(o);
    firstkid = OpSIBLING(cLISTOPo->op_first);		/* get past pushmark */

    if ((stacked = o->op_flags & OPf_STACKED)) {	/* may have been cleared */
	OP *kid = cUNOPx(firstkid)->op_first;		/* get past null */

        /* if the first arg is a code block, process it and mark sort as
         * OPf_SPECIAL */
	if (kid->op_type == OP_SCOPE || kid->op_type == OP_LEAVE) {
	    LINKLIST(kid);
	    if (kid->op_type == OP_LEAVE)
		    op_null(kid);			/* wipe out leave */
	    /* Prevent execution from escaping out of the sort block. */
	    kid->op_next = 0;

	    /* provide scalar context for comparison function/block */
	    kid = scalar(firstkid);
	    kid->op_next = kid;
	    o->op_flags |= OPf_SPECIAL;
	}
	else if (kid->op_type == OP_CONST
	      && kid->op_private & OPpCONST_BARE) {
	    char tmpbuf[256];
	    STRLEN len;
	    PADOFFSET off;
	    const char * const name = SvPV(kSVOP_sv, len);
	    *tmpbuf = '&';
	    assert (len < 256);
	    Copy(name, tmpbuf+1, len, char);
	    off = pad_findmy_pvn(tmpbuf, len+1, SvUTF8(kSVOP_sv));
	    if (off != NOT_IN_PAD) {
		if (PAD_COMPNAME_FLAGS_isOUR(off)) {
		    SV * const fq =
			newSVhek(HvNAME_HEK(PAD_COMPNAME_OURSTASH(off)));
		    sv_catpvs(fq, "::");
		    sv_catsv(fq, kSVOP_sv);
		    SvREFCNT_dec_NN(kSVOP_sv);
		    kSVOP->op_sv = fq;
		}
		else {
		    OP * const padop = newOP(OP_PADCV, 0);
		    padop->op_targ = off;
                    /* replace the const op with the pad op */
                    op_sibling_splice(firstkid, NULL, 1, padop);
		    op_free(kid);
		}
	    }
	}

	firstkid = OpSIBLING(firstkid);
    }

    for (kid = firstkid; kid; kid = OpSIBLING(kid)) {
	/* provide list context for arguments */
	list(kid);
	if (stacked)
	    op_lvalue(kid, OP_GREPSTART);
    }

    return o;
}

/* for sort { X } ..., where X is one of
 *   $a <=> $b, $b <= $a, $a cmp $b, $b cmp $a
 * elide the second child of the sort (the one containing X),
 * and set these flags as appropriate
	OPpSORT_NUMERIC;
	OPpSORT_INTEGER;
	OPpSORT_DESCEND;
 * Also, check and warn on lexical $a, $b.
 */

STATIC void
S_simplify_sort(pTHX_ OP *o)
{
    OP *kid = OpSIBLING(cLISTOPo->op_first);	/* get past pushmark */
    OP *k;
    int descending;
    GV *gv;
    const char *gvname;
    bool have_scopeop;

    PERL_ARGS_ASSERT_SIMPLIFY_SORT;

    kid = kUNOP->op_first;				/* get past null */
    if (!(have_scopeop = kid->op_type == OP_SCOPE)
     && kid->op_type != OP_LEAVE)
	return;
    kid = kLISTOP->op_last;				/* get past scope */
    switch(kid->op_type) {
	case OP_NCMP:
	case OP_I_NCMP:
	case OP_SCMP:
	    if (!have_scopeop) goto padkids;
	    break;
	default:
	    return;
    }
    k = kid;						/* remember this node*/
    if (kBINOP->op_first->op_type != OP_RV2SV
     || kBINOP->op_last ->op_type != OP_RV2SV)
    {
	/*
	   Warn about my($a) or my($b) in a sort block, *if* $a or $b is
	   then used in a comparison.  This catches most, but not
	   all cases.  For instance, it catches
	       sort { my($a); $a <=> $b }
	   but not
	       sort { my($a); $a < $b ? -1 : $a == $b ? 0 : 1; }
	   (although why you'd do that is anyone's guess).
	*/

       padkids:
	if (!ckWARN(WARN_SYNTAX)) return;
	kid = kBINOP->op_first;
	do {
	    if (kid->op_type == OP_PADSV) {
		PADNAME * const name = PAD_COMPNAME(kid->op_targ);
		if (PadnameLEN(name) == 2 && *PadnamePV(name) == '$'
		 && (  PadnamePV(name)[1] == 'a'
		    || PadnamePV(name)[1] == 'b'  ))
		    /* diag_listed_as: "my %s" used in sort comparison */
		    Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
				     "\"%s %s\" used in sort comparison",
				      PadnameIsSTATE(name)
					? "state"
					: "my",
				      PadnamePV(name));
	    }
	} while ((kid = OpSIBLING(kid)));
	return;
    }
    kid = kBINOP->op_first;				/* get past cmp */
    if (kUNOP->op_first->op_type != OP_GV)
	return;
    kid = kUNOP->op_first;				/* get past rv2sv */
    gv = kGVOP_gv;
    if (GvSTASH(gv) != PL_curstash)
	return;
    gvname = GvNAME(gv);
    if (*gvname == 'a' && gvname[1] == '\0')
	descending = 0;
    else if (*gvname == 'b' && gvname[1] == '\0')
	descending = 1;
    else
	return;

    kid = k;						/* back to cmp */
    /* already checked above that it is rv2sv */
    kid = kBINOP->op_last;				/* down to 2nd arg */
    if (kUNOP->op_first->op_type != OP_GV)
	return;
    kid = kUNOP->op_first;				/* get past rv2sv */
    gv = kGVOP_gv;
    if (GvSTASH(gv) != PL_curstash)
	return;
    gvname = GvNAME(gv);
    if ( descending
	 ? !(*gvname == 'a' && gvname[1] == '\0')
	 : !(*gvname == 'b' && gvname[1] == '\0'))
	return;
    o->op_flags &= ~(OPf_STACKED | OPf_SPECIAL);
    if (descending)
	o->op_private |= OPpSORT_DESCEND;
    if (k->op_type == OP_NCMP)
	o->op_private |= OPpSORT_NUMERIC;
    if (k->op_type == OP_I_NCMP)
	o->op_private |= OPpSORT_NUMERIC | OPpSORT_INTEGER;
    kid = OpSIBLING(cLISTOPo->op_first);
    /* cut out and delete old block (second sibling) */
    op_sibling_splice(o, cLISTOPo->op_first, 1, NULL);
    op_free(kid);
}

OP *
Perl_ck_split(pTHX_ OP *o)
{
    dVAR;
    OP *kid;

    PERL_ARGS_ASSERT_CK_SPLIT;

    if (o->op_flags & OPf_STACKED)
	return no_fh_allowed(o);

    kid = cLISTOPo->op_first;
    if (kid->op_type != OP_NULL)
	Perl_croak(aTHX_ "panic: ck_split, type=%u", (unsigned) kid->op_type);
    /* delete leading NULL node, then add a CONST if no other nodes */
    op_sibling_splice(o, NULL, 1,
	OpHAS_SIBLING(kid) ? NULL : newSVOP(OP_CONST, 0, newSVpvs(" ")));
    op_free(kid);
    kid = cLISTOPo->op_first;

    if (kid->op_type != OP_MATCH || kid->op_flags & OPf_STACKED) {
        /* remove kid, and replace with new optree */
        op_sibling_splice(o, NULL, 1, NULL);
        /* OPf_SPECIAL is used to trigger split " " behavior */
        kid = pmruntime( newPMOP(OP_MATCH, OPf_SPECIAL), kid, NULL, 0, 0);
        op_sibling_splice(o, NULL, 0, kid);
    }
    OpTYPE_set(kid, OP_PUSHRE);
    /* target implies @@ary=..., so wipe it */
    kid->op_targ = 0;
    scalar(kid);
    if (((PMOP *)kid)->op_pmflags & PMf_GLOBAL) {
      Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP),
		     "Use of /g modifier is meaningless in split");
    }

    if (!OpHAS_SIBLING(kid))
	op_append_elem(OP_SPLIT, o, newDEFSVOP());

    kid = OpSIBLING(kid);
    assert(kid);
    scalar(kid);

    if (!OpHAS_SIBLING(kid))
    {
	op_append_elem(OP_SPLIT, o, newSVOP(OP_CONST, 0, newSViv(0)));
	o->op_private |= OPpSPLIT_IMPLIM;
    }
    assert(OpHAS_SIBLING(kid));

    kid = OpSIBLING(kid);
    scalar(kid);

    if (OpHAS_SIBLING(kid))
	return too_many_arguments_pv(o,OP_DESC(o), 0);

    return o;
}

OP *
Perl_ck_stringify(pTHX_ OP *o)
{
    OP * const kid = OpSIBLING(cUNOPo->op_first);
    PERL_ARGS_ASSERT_CK_STRINGIFY;
    if ((   kid->op_type == OP_JOIN || kid->op_type == OP_QUOTEMETA
         || kid->op_type == OP_LC   || kid->op_type == OP_LCFIRST
         || kid->op_type == OP_UC   || kid->op_type == OP_UCFIRST)
	&& !OpHAS_SIBLING(kid)) /* syntax errs can leave extra children */
    {
	op_sibling_splice(o, cUNOPo->op_first, -1, NULL);
	op_free(o);
	return kid;
    }
    return ck_fun(o);
}
	
OP *
Perl_ck_join(pTHX_ OP *o)
{
    OP * const kid = OpSIBLING(cLISTOPo->op_first);

    PERL_ARGS_ASSERT_CK_JOIN;

    if (kid && kid->op_type == OP_MATCH) {
	if (ckWARN(WARN_SYNTAX)) {
            const REGEXP *re = PM_GETRE(kPMOP);
            const SV *msg = re
                    ? newSVpvn_flags( RX_PRECOMP_const(re), RX_PRELEN(re),
                                            SVs_TEMP | ( RX_UTF8(re) ? SVf_UTF8 : 0 ) )
                    : newSVpvs_flags( "STRING", SVs_TEMP );
	    Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
			"/%"SVf"/ should probably be written as \"%"SVf"\"",
			SVfARG(msg), SVfARG(msg));
	}
    }
    if (kid
     && (kid->op_type == OP_CONST /* an innocent, unsuspicious separator */
	|| (kid->op_type == OP_PADSV && !(kid->op_private & OPpLVAL_INTRO))
	|| (  kid->op_type==OP_RV2SV && kUNOP->op_first->op_type == OP_GV
	   && !(kid->op_private & (OPpLVAL_INTRO|OPpOUR_INTRO)))))
    {
	const OP * const bairn = OpSIBLING(kid); /* the list */
	if (bairn && !OpHAS_SIBLING(bairn) /* single-item list */
	 && OP_GIMME(bairn,0) == G_SCALAR)
	{
	    OP * const ret = op_convert_list(OP_STRINGIFY, OPf_FOLDED,
				     op_sibling_splice(o, kid, 1, NULL));
	    op_free(o);
	    return ret;
	}
    }

    return ck_fun(o);
}

/*
=for apidoc Am|CV *|rv2cv_op_cv|OP *cvop|U32 flags

Examines an op, which is expected to identify a subroutine at runtime,
and attempts to determine at compile time which subroutine it identifies.
This is normally used during Perl compilation to determine whether
a prototype can be applied to a function call.  C<cvop> is the op
being considered, normally an C<rv2cv> op.  A pointer to the identified
subroutine is returned, if it could be determined statically, and a null
pointer is returned if it was not possible to determine statically.

Currently, the subroutine can be identified statically if the RV that the
C<rv2cv> is to operate on is provided by a suitable C<gv> or C<const> op.
A C<gv> op is suitable if the GV's CV slot is populated.  A C<const> op is
suitable if the constant value must be an RV pointing to a CV.  Details of
this process may change in future versions of Perl.  If the C<rv2cv> op
has the C<OPpENTERSUB_AMPER> flag set then no attempt is made to identify
the subroutine statically: this flag is used to suppress compile-time
magic on a subroutine call, forcing it to use default runtime behaviour.

If C<flags> has the bit C<RV2CVOPCV_MARK_EARLY> set, then the handling
of a GV reference is modified.  If a GV was examined and its CV slot was
found to be empty, then the C<gv> op has the C<OPpEARLY_CV> flag set.
If the op is not optimised away, and the CV slot is later populated with
a subroutine having a prototype, that flag eventually triggers the warning
"called too early to check prototype".

If C<flags> has the bit C<RV2CVOPCV_RETURN_NAME_GV> set, then instead
of returning a pointer to the subroutine it returns a pointer to the
GV giving the most appropriate name for the subroutine in this context.
Normally this is just the C<CvGV> of the subroutine, but for an anonymous
(C<CvANON>) subroutine that is referenced through a GV it will be the
referencing GV.  The resulting C<GV*> is cast to C<CV*> to be returned.
A null pointer is returned as usual if there is no statically-determinable
subroutine.

=cut
*/

/* shared by toke.c:yylex */
CV *
Perl_find_lexical_cv(pTHX_ PADOFFSET off)
{
    PADNAME *name = PAD_COMPNAME(off);
    CV *compcv = PL_compcv;
    while (PadnameOUTER(name)) {
	assert(PARENT_PAD_INDEX(name));
	compcv = CvOUTSIDE(compcv);
	name = PadlistNAMESARRAY(CvPADLIST(compcv))
		[off = PARENT_PAD_INDEX(name)];
    }
    assert(!PadnameIsOUR(name));
    if (!PadnameIsSTATE(name) && PadnamePROTOCV(name)) {
	return PadnamePROTOCV(name);
    }
    return (CV *)AvARRAY(PadlistARRAY(CvPADLIST(compcv))[1])[off];
}

CV *
Perl_rv2cv_op_cv(pTHX_ OP *cvop, U32 flags)
{
    OP *rvop;
    CV *cv;
    GV *gv;
    PERL_ARGS_ASSERT_RV2CV_OP_CV;
    if (flags & ~RV2CVOPCV_FLAG_MASK)
	Perl_croak(aTHX_ "panic: rv2cv_op_cv bad flags %x", (unsigned)flags);
    if (cvop->op_type != OP_RV2CV)
	return NULL;
    if (cvop->op_private & OPpENTERSUB_AMPER)
	return NULL;
    if (!(cvop->op_flags & OPf_KIDS))
	return NULL;
    rvop = cUNOPx(cvop)->op_first;
    switch (rvop->op_type) {
	case OP_GV: {
	    gv = cGVOPx_gv(rvop);
	    if (!isGV(gv)) {
		if (SvROK(gv) && SvTYPE(SvRV(gv)) == SVt_PVCV) {
		    cv = MUTABLE_CV(SvRV(gv));
		    gv = NULL;
		    break;
		}
		if (flags & RV2CVOPCV_RETURN_STUB)
		    return (CV *)gv;
		else return NULL;
	    }
	    cv = GvCVu(gv);
	    if (!cv) {
		if (flags & RV2CVOPCV_MARK_EARLY)
		    rvop->op_private |= OPpEARLY_CV;
		return NULL;
	    }
	} break;
	case OP_CONST: {
	    SV *rv = cSVOPx_sv(rvop);
	    if (!SvROK(rv))
		return NULL;
	    cv = (CV*)SvRV(rv);
	    gv = NULL;
	} break;
	case OP_PADCV: {
	    cv = find_lexical_cv(rvop->op_targ);
	    gv = NULL;
	} break;
	default: {
	    return NULL;
	} NOT_REACHED; /* NOTREACHED */
    }
    if (SvTYPE((SV*)cv) != SVt_PVCV)
	return NULL;
    if (flags & (RV2CVOPCV_RETURN_NAME_GV|RV2CVOPCV_MAYBE_NAME_GV)) {
	if ((!CvANON(cv) || !gv) && !CvLEXICAL(cv)
	 && ((flags & RV2CVOPCV_RETURN_NAME_GV) || !CvNAMED(cv)))
	    gv = CvGV(cv);
	return (CV*)gv;
    } else {
	return cv;
    }
}

/*
=for apidoc Am|OP *|ck_entersub_args_list|OP *entersubop

Performs the default fixup of the arguments part of an C<entersub>
op tree.  This consists of applying list context to each of the
argument ops.  This is the standard treatment used on a call marked
with C<&>, or a method call, or a call through a subroutine reference,
or any other call where the callee can't be identified at compile time,
or a call where the callee has no prototype.

=cut
*/

OP *
Perl_ck_entersub_args_list(pTHX_ OP *entersubop)
{
    OP *aop;

    PERL_ARGS_ASSERT_CK_ENTERSUB_ARGS_LIST;

    aop = cUNOPx(entersubop)->op_first;
    if (!OpHAS_SIBLING(aop))
	aop = cUNOPx(aop)->op_first;
    for (aop = OpSIBLING(aop); OpHAS_SIBLING(aop); aop = OpSIBLING(aop)) {
        /* skip the extra attributes->import() call implicitly added in
         * something like foo(my $x : bar)
         */
        if (   aop->op_type == OP_ENTERSUB
            && (aop->op_flags & OPf_WANT) == OPf_WANT_VOID
        )
            continue;
        list(aop);
        op_lvalue(aop, OP_ENTERSUB);
    }
    return entersubop;
}

/*
=for apidoc Am|OP *|ck_entersub_args_proto|OP *entersubop|GV *namegv|SV *protosv

Performs the fixup of the arguments part of an C<entersub> op tree
based on a subroutine prototype.  This makes various modifications to
the argument ops, from applying context up to inserting C<refgen> ops,
and checking the number and syntactic types of arguments, as directed by
the prototype.  This is the standard treatment used on a subroutine call,
not marked with C<&>, where the callee can be identified at compile time
and has a prototype.

C<protosv> supplies the subroutine prototype to be applied to the call.
It may be a normal defined scalar, of which the string value will be used.
Alternatively, for convenience, it may be a subroutine object (a C<CV*>
that has been cast to C<SV*>) which has a prototype.  The prototype
supplied, in whichever form, does not need to match the actual callee
referenced by the op tree.

If the argument ops disagree with the prototype, for example by having
an unacceptable number of arguments, a valid op tree is returned anyway.
The error is reflected in the parser state, normally resulting in a single
exception at the top level of parsing which covers all the compilation
errors that occurred.  In the error message, the callee is referred to
by the name defined by the C<namegv> parameter.

=cut
*/

OP *
Perl_ck_entersub_args_proto(pTHX_ OP *entersubop, GV *namegv, SV *protosv)
{
    STRLEN proto_len;
    const char *proto, *proto_end;
    OP *aop, *prev, *cvop, *parent;
    int optional = 0;
    I32 arg = 0;
    I32 contextclass = 0;
    const char *e = NULL;
    PERL_ARGS_ASSERT_CK_ENTERSUB_ARGS_PROTO;
    if (SvTYPE(protosv) == SVt_PVCV ? !SvPOK(protosv) : !SvOK(protosv))
	Perl_croak(aTHX_ "panic: ck_entersub_args_proto CV with no proto, "
		   "flags=%lx", (unsigned long) SvFLAGS(protosv));
    if (SvTYPE(protosv) == SVt_PVCV)
	 proto = CvPROTO(protosv), proto_len = CvPROTOLEN(protosv);
    else proto = SvPV(protosv, proto_len);
    proto = S_strip_spaces(aTHX_ proto, &proto_len);
    proto_end = proto + proto_len;
    parent = entersubop;
    aop = cUNOPx(entersubop)->op_first;
    if (!OpHAS_SIBLING(aop)) {
        parent = aop;
	aop = cUNOPx(aop)->op_first;
    }
    prev = aop;
    aop = OpSIBLING(aop);
    for (cvop = aop; OpHAS_SIBLING(cvop); cvop = OpSIBLING(cvop)) ;
    while (aop != cvop) {
	OP* o3 = aop;

	if (proto >= proto_end)
	{
	    SV * const namesv = cv_name((CV *)namegv, NULL, 0);
	    yyerror_pv(Perl_form(aTHX_ "Too many arguments for %"SVf,
					SVfARG(namesv)), SvUTF8(namesv));
	    return entersubop;
	}

	switch (*proto) {
	    case ';':
		optional = 1;
		proto++;
		continue;
	    case '_':
		/* _ must be at the end */
		if (proto[1] && !strchr(";@@%", proto[1]))
		    goto oops;
                /* FALLTHROUGH */
	    case '$':
		proto++;
		arg++;
		scalar(aop);
		break;
	    case '%':
	    case '@@':
		list(aop);
		arg++;
		break;
	    case '&':
		proto++;
		arg++;
		if (    o3->op_type != OP_UNDEF
                    && (o3->op_type != OP_SREFGEN
                        || (  cUNOPx(cUNOPx(o3)->op_first)->op_first->op_type
                                != OP_ANONCODE
                            && cUNOPx(cUNOPx(o3)->op_first)->op_first->op_type
                                != OP_RV2CV)))
		    bad_type_gv(arg, namegv, o3,
			    arg == 1 ? "block or sub {}" : "sub {}");
		break;
	    case '*':
		/* '*' allows any scalar type, including bareword */
		proto++;
		arg++;
		if (o3->op_type == OP_RV2GV)
		    goto wrapref;	/* autoconvert GLOB -> GLOBref */
		else if (o3->op_type == OP_CONST)
		    o3->op_private &= ~OPpCONST_STRICT;
		scalar(aop);
		break;
	    case '+':
		proto++;
		arg++;
		if (o3->op_type == OP_RV2AV ||
		    o3->op_type == OP_PADAV ||
		    o3->op_type == OP_RV2HV ||
		    o3->op_type == OP_PADHV
		) {
		    goto wrapref;
		}
		scalar(aop);
		break;
	    case '[': case ']':
		goto oops;

	    case '\\':
		proto++;
		arg++;
	    again:
		switch (*proto++) {
		    case '[':
			if (contextclass++ == 0) {
			    e = strchr(proto, ']');
			    if (!e || e == proto)
				goto oops;
			}
			else
			    goto oops;
			goto again;

		    case ']':
			if (contextclass) {
			    const char *p = proto;
			    const char *const end = proto;
			    contextclass = 0;
			    while (*--p != '[')
				/* \[$] accepts any scalar lvalue */
				if (*p == '$'
				 && Perl_op_lvalue_flags(aTHX_
				     scalar(o3),
				     OP_READ, /* not entersub */
				     OP_LVALUE_NO_CROAK
				    )) goto wrapref;
			    bad_type_gv(arg, namegv, o3,
				    Perl_form(aTHX_ "one of %.*s",(int)(end - p), p));
			} else
			    goto oops;
			break;
		    case '*':
			if (o3->op_type == OP_RV2GV)
			    goto wrapref;
			if (!contextclass)
			    bad_type_gv(arg, namegv, o3, "symbol");
			break;
		    case '&':
			if (o3->op_type == OP_ENTERSUB
			 && !(o3->op_flags & OPf_STACKED))
			    goto wrapref;
			if (!contextclass)
			    bad_type_gv(arg, namegv, o3, "subroutine");
			break;
		    case '$':
			if (o3->op_type == OP_RV2SV ||
				o3->op_type == OP_PADSV ||
				o3->op_type == OP_HELEM ||
				o3->op_type == OP_AELEM)
			    goto wrapref;
			if (!contextclass) {
			    /* \$ accepts any scalar lvalue */
			    if (Perl_op_lvalue_flags(aTHX_
				    scalar(o3),
				    OP_READ,  /* not entersub */
				    OP_LVALUE_NO_CROAK
			       )) goto wrapref;
			    bad_type_gv(arg, namegv, o3, "scalar");
			}
			break;
		    case '@@':
			if (o3->op_type == OP_RV2AV ||
				o3->op_type == OP_PADAV)
			{
			    o3->op_flags &=~ OPf_PARENS;
			    goto wrapref;
			}
			if (!contextclass)
			    bad_type_gv(arg, namegv, o3, "array");
			break;
		    case '%':
			if (o3->op_type == OP_RV2HV ||
				o3->op_type == OP_PADHV)
			{
			    o3->op_flags &=~ OPf_PARENS;
			    goto wrapref;
			}
			if (!contextclass)
			    bad_type_gv(arg, namegv, o3, "hash");
			break;
		    wrapref:
                            aop = S_op_sibling_newUNOP(aTHX_ parent, prev,
                                                OP_REFGEN, 0);
			if (contextclass && e) {
			    proto = e + 1;
			    contextclass = 0;
			}
			break;
		    default: goto oops;
		}
		if (contextclass)
		    goto again;
		break;
	    case ' ':
		proto++;
		continue;
	    default:
	    oops: {
		Perl_croak(aTHX_ "Malformed prototype for %"SVf": %"SVf,
				  SVfARG(cv_name((CV *)namegv, NULL, 0)),
				  SVfARG(protosv));
            }
	}

	op_lvalue(aop, OP_ENTERSUB);
	prev = aop;
	aop = OpSIBLING(aop);
    }
    if (aop == cvop && *proto == '_') {
	/* generate an access to $_ */
        op_sibling_splice(parent, prev, 0, newDEFSVOP());
    }
    if (!optional && proto_end > proto &&
	(*proto != '@@' && *proto != '%' && *proto != ';' && *proto != '_'))
    {
	SV * const namesv = cv_name((CV *)namegv, NULL, 0);
	yyerror_pv(Perl_form(aTHX_ "Not enough arguments for %"SVf,
				    SVfARG(namesv)), SvUTF8(namesv));
    }
    return entersubop;
}

/*
=for apidoc Am|OP *|ck_entersub_args_proto_or_list|OP *entersubop|GV *namegv|SV *protosv

Performs the fixup of the arguments part of an C<entersub> op tree either
based on a subroutine prototype or using default list-context processing.
This is the standard treatment used on a subroutine call, not marked
with C<&>, where the callee can be identified at compile time.

C<protosv> supplies the subroutine prototype to be applied to the call,
or indicates that there is no prototype.  It may be a normal scalar,
in which case if it is defined then the string value will be used
as a prototype, and if it is undefined then there is no prototype.
Alternatively, for convenience, it may be a subroutine object (a C<CV*>
that has been cast to C<SV*>), of which the prototype will be used if it
has one.  The prototype (or lack thereof) supplied, in whichever form,
does not need to match the actual callee referenced by the op tree.

If the argument ops disagree with the prototype, for example by having
an unacceptable number of arguments, a valid op tree is returned anyway.
The error is reflected in the parser state, normally resulting in a single
exception at the top level of parsing which covers all the compilation
errors that occurred.  In the error message, the callee is referred to
by the name defined by the C<namegv> parameter.

=cut
*/

OP *
Perl_ck_entersub_args_proto_or_list(pTHX_ OP *entersubop,
	GV *namegv, SV *protosv)
{
    PERL_ARGS_ASSERT_CK_ENTERSUB_ARGS_PROTO_OR_LIST;
    if (SvTYPE(protosv) == SVt_PVCV ? SvPOK(protosv) : SvOK(protosv))
	return ck_entersub_args_proto(entersubop, namegv, protosv);
    else
	return ck_entersub_args_list(entersubop);
}

OP *
Perl_ck_entersub_args_core(pTHX_ OP *entersubop, GV *namegv, SV *protosv)
{
    int opnum = SvTYPE(protosv) == SVt_PVCV ? 0 : (int)SvUV(protosv);
    OP *aop = cUNOPx(entersubop)->op_first;

    PERL_ARGS_ASSERT_CK_ENTERSUB_ARGS_CORE;

    if (!opnum) {
	OP *cvop;
	if (!OpHAS_SIBLING(aop))
	    aop = cUNOPx(aop)->op_first;
	aop = OpSIBLING(aop);
	for (cvop = aop; OpSIBLING(cvop); cvop = OpSIBLING(cvop)) ;
	if (aop != cvop)
	    (void)too_many_arguments_pv(entersubop, GvNAME(namegv), 0);
	
	op_free(entersubop);
	switch(GvNAME(namegv)[2]) {
	case 'F': return newSVOP(OP_CONST, 0,
					newSVpv(CopFILE(PL_curcop),0));
	case 'L': return newSVOP(
	                   OP_CONST, 0,
                           Perl_newSVpvf(aTHX_
	                     "%"IVdf, (IV)CopLINE(PL_curcop)
	                   )
	                 );
	case 'P': return newSVOP(OP_CONST, 0,
	                           (PL_curstash
	                             ? newSVhek(HvNAME_HEK(PL_curstash))
	                             : &PL_sv_undef
	                           )
	                        );
	}
	NOT_REACHED; /* NOTREACHED */
    }
    else {
	OP *prev, *cvop, *first, *parent;
	U32 flags = 0;

        parent = entersubop;
        if (!OpHAS_SIBLING(aop)) {
            parent = aop;
	    aop = cUNOPx(aop)->op_first;
        }
	
	first = prev = aop;
	aop = OpSIBLING(aop);
        /* find last sibling */
	for (cvop = aop;
	     OpHAS_SIBLING(cvop);
	     prev = cvop, cvop = OpSIBLING(cvop))
	    ;
        if (!(cvop->op_private & OPpENTERSUB_NOPAREN)
            /* Usually, OPf_SPECIAL on an op with no args means that it had
             * parens, but these have their own meaning for that flag: */
            && opnum != OP_VALUES && opnum != OP_KEYS && opnum != OP_EACH
            && opnum != OP_DELETE && opnum != OP_EXISTS)
                flags |= OPf_SPECIAL;
        /* excise cvop from end of sibling chain */
        op_sibling_splice(parent, prev, 1, NULL);
	op_free(cvop);
	if (aop == cvop) aop = NULL;

        /* detach remaining siblings from the first sibling, then
         * dispose of original optree */

        if (aop)
            op_sibling_splice(parent, first, -1, NULL);
	op_free(entersubop);

	if (opnum == OP_ENTEREVAL
	 && GvNAMELEN(namegv)==9 && strnEQ(GvNAME(namegv), "evalbytes", 9))
	    flags |= OPpEVAL_BYTES <<8;
	
	switch (PL_opargs[opnum] & OA_CLASS_MASK) {
	case OA_UNOP:
	case OA_BASEOP_OR_UNOP:
	case OA_FILESTATOP:
	    return aop ? newUNOP(opnum,flags,aop) : newOP(opnum,flags);
	case OA_BASEOP:
	    if (aop) {
		    (void)too_many_arguments_pv(aop, GvNAME(namegv), 0);
		op_free(aop);
	    }
	    return opnum == OP_RUNCV
		? newPVOP(OP_RUNCV,0,NULL)
		: newOP(opnum,0);
	default:
	    return op_convert_list(opnum,0,aop);
	}
    }
    NOT_REACHED; /* NOTREACHED */
    return entersubop;
}

/*
=for apidoc Am|void|cv_get_call_checker|CV *cv|Perl_call_checker *ckfun_p|SV **ckobj_p

Retrieves the function that will be used to fix up a call to C<cv>.
Specifically, the function is applied to an C<entersub> op tree for a
subroutine call, not marked with C<&>, where the callee can be identified
at compile time as C<cv>.

The C-level function pointer is returned in C<*ckfun_p>, and an SV
argument for it is returned in C<*ckobj_p>.  The function is intended
to be called in this manner:

 entersubop = (*ckfun_p)(aTHX_ entersubop, namegv, (*ckobj_p));

In this call, C<entersubop> is a pointer to the C<entersub> op,
which may be replaced by the check function, and C<namegv> is a GV
supplying the name that should be used by the check function to refer
to the callee of the C<entersub> op if it needs to emit any diagnostics.
It is permitted to apply the check function in non-standard situations,
such as to a call to a different subroutine or to a method call.

By default, the function is
L<Perl_ck_entersub_args_proto_or_list|/ck_entersub_args_proto_or_list>,
and the SV parameter is C<cv> itself.  This implements standard
prototype processing.  It can be changed, for a particular subroutine,
by L</cv_set_call_checker>.

=cut
*/

static void
S_cv_get_call_checker(CV *cv, Perl_call_checker *ckfun_p, SV **ckobj_p,
		      U8 *flagsp)
{
    MAGIC *callmg;
    callmg = SvMAGICAL((SV*)cv) ? mg_find((SV*)cv, PERL_MAGIC_checkcall) : NULL;
    if (callmg) {
	*ckfun_p = DPTR2FPTR(Perl_call_checker, callmg->mg_ptr);
	*ckobj_p = callmg->mg_obj;
	if (flagsp) *flagsp = callmg->mg_flags;
    } else {
	*ckfun_p = Perl_ck_entersub_args_proto_or_list;
	*ckobj_p = (SV*)cv;
	if (flagsp) *flagsp = 0;
    }
}

void
Perl_cv_get_call_checker(pTHX_ CV *cv, Perl_call_checker *ckfun_p, SV **ckobj_p)
{
    PERL_ARGS_ASSERT_CV_GET_CALL_CHECKER;
    PERL_UNUSED_CONTEXT;
    S_cv_get_call_checker(cv, ckfun_p, ckobj_p, NULL);
}

/*
=for apidoc Am|void|cv_set_call_checker_flags|CV *cv|Perl_call_checker ckfun|SV *ckobj|U32 flags

Sets the function that will be used to fix up a call to C<cv>.
Specifically, the function is applied to an C<entersub> op tree for a
subroutine call, not marked with C<&>, where the callee can be identified
at compile time as C<cv>.

The C-level function pointer is supplied in C<ckfun>, and an SV argument
for it is supplied in C<ckobj>.  The function should be defined like this:

    STATIC OP * ckfun(pTHX_ OP *op, GV *namegv, SV *ckobj)

It is intended to be called in this manner:

    entersubop = ckfun(aTHX_ entersubop, namegv, ckobj);

In this call, C<entersubop> is a pointer to the C<entersub> op,
which may be replaced by the check function, and C<namegv> supplies
the name that should be used by the check function to refer
to the callee of the C<entersub> op if it needs to emit any diagnostics.
It is permitted to apply the check function in non-standard situations,
such as to a call to a different subroutine or to a method call.

C<namegv> may not actually be a GV.  For efficiency, perl may pass a
CV or other SV instead.  Whatever is passed can be used as the first
argument to L</cv_name>.  You can force perl to pass a GV by including
C<CALL_CHECKER_REQUIRE_GV> in the C<flags>.

The current setting for a particular CV can be retrieved by
L</cv_get_call_checker>.

=for apidoc Am|void|cv_set_call_checker|CV *cv|Perl_call_checker ckfun|SV *ckobj

The original form of L</cv_set_call_checker_flags>, which passes it the
C<CALL_CHECKER_REQUIRE_GV> flag for backward-compatibility.

=cut
*/

void
Perl_cv_set_call_checker(pTHX_ CV *cv, Perl_call_checker ckfun, SV *ckobj)
{
    PERL_ARGS_ASSERT_CV_SET_CALL_CHECKER;
    cv_set_call_checker_flags(cv, ckfun, ckobj, CALL_CHECKER_REQUIRE_GV);
}

void
Perl_cv_set_call_checker_flags(pTHX_ CV *cv, Perl_call_checker ckfun,
				     SV *ckobj, U32 flags)
{
    PERL_ARGS_ASSERT_CV_SET_CALL_CHECKER_FLAGS;
    if (ckfun == Perl_ck_entersub_args_proto_or_list && ckobj == (SV*)cv) {
	if (SvMAGICAL((SV*)cv))
	    mg_free_type((SV*)cv, PERL_MAGIC_checkcall);
    } else {
	MAGIC *callmg;
	sv_magic((SV*)cv, &PL_sv_undef, PERL_MAGIC_checkcall, NULL, 0);
	callmg = mg_find((SV*)cv, PERL_MAGIC_checkcall);
	assert(callmg);
	if (callmg->mg_flags & MGf_REFCOUNTED) {
	    SvREFCNT_dec(callmg->mg_obj);
	    callmg->mg_flags &= ~MGf_REFCOUNTED;
	}
	callmg->mg_ptr = FPTR2DPTR(char *, ckfun);
	callmg->mg_obj = ckobj;
	if (ckobj != (SV*)cv) {
	    SvREFCNT_inc_simple_void_NN(ckobj);
	    callmg->mg_flags |= MGf_REFCOUNTED;
	}
	callmg->mg_flags = (callmg->mg_flags &~ MGf_REQUIRE_GV)
			 | (U8)(flags & MGf_REQUIRE_GV) | MGf_COPY;
    }
}

static void
S_entersub_alloc_targ(pTHX_ OP * const o)
{
    o->op_targ = pad_alloc(OP_ENTERSUB, SVs_PADTMP);
    o->op_private |= OPpENTERSUB_HASTARG;
}

OP *
Perl_ck_subr(pTHX_ OP *o)
{
    OP *aop, *cvop;
    CV *cv;
    GV *namegv;
    SV **const_class = NULL;

    PERL_ARGS_ASSERT_CK_SUBR;

    aop = cUNOPx(o)->op_first;
    if (!OpHAS_SIBLING(aop))
	aop = cUNOPx(aop)->op_first;
    aop = OpSIBLING(aop);
    for (cvop = aop; OpHAS_SIBLING(cvop); cvop = OpSIBLING(cvop)) ;
    cv = rv2cv_op_cv(cvop, RV2CVOPCV_MARK_EARLY);
    namegv = cv ? (GV*)rv2cv_op_cv(cvop, RV2CVOPCV_MAYBE_NAME_GV) : NULL;

    o->op_private &= ~1;
    o->op_private |= (PL_hints & HINT_STRICT_REFS);
    if (PERLDB_SUB && PL_curstash != PL_debstash)
	o->op_private |= OPpENTERSUB_DB;
    switch (cvop->op_type) {
	case OP_RV2CV:
	    o->op_private |= (cvop->op_private & OPpENTERSUB_AMPER);
	    op_null(cvop);
	    break;
	case OP_METHOD:
	case OP_METHOD_NAMED:
	case OP_METHOD_SUPER:
	case OP_METHOD_REDIR:
	case OP_METHOD_REDIR_SUPER:
	    if (aop->op_type == OP_CONST) {
		aop->op_private &= ~OPpCONST_STRICT;
		const_class = &cSVOPx(aop)->op_sv;
	    }
	    else if (aop->op_type == OP_LIST) {
		OP * const sib = OpSIBLING(((UNOP*)aop)->op_first);
		if (sib && sib->op_type == OP_CONST) {
		    sib->op_private &= ~OPpCONST_STRICT;
		    const_class = &cSVOPx(sib)->op_sv;
		}
	    }
	    /* make class name a shared cow string to speedup method calls */
	    /* constant string might be replaced with object, f.e. bigint */
	    if (const_class && SvPOK(*const_class)) {
		STRLEN len;
		const char* str = SvPV(*const_class, len);
		if (len) {
		    SV* const shared = newSVpvn_share(
			str, SvUTF8(*const_class)
                                    ? -(SSize_t)len : (SSize_t)len,
                        0
		    );
                    if (SvREADONLY(*const_class))
                        SvREADONLY_on(shared);
		    SvREFCNT_dec(*const_class);
		    *const_class = shared;
		}
	    }
	    break;
    }

    if (!cv) {
	S_entersub_alloc_targ(aTHX_ o);
	return ck_entersub_args_list(o);
    } else {
	Perl_call_checker ckfun;
	SV *ckobj;
	U8 flags;
	S_cv_get_call_checker(cv, &ckfun, &ckobj, &flags);
	if (CvISXSUB(cv) || !CvROOT(cv))
	    S_entersub_alloc_targ(aTHX_ o);
	if (!namegv) {
	    /* The original call checker API guarantees that a GV will be
	       be provided with the right name.  So, if the old API was
	       used (or the REQUIRE_GV flag was passed), we have to reify
	       the CV’s GV, unless this is an anonymous sub.  This is not
	       ideal for lexical subs, as its stringification will include
	       the package.  But it is the best we can do.  */
	    if (flags & MGf_REQUIRE_GV) {
		if (!CvANON(cv) && (!CvNAMED(cv) || CvNAME_HEK(cv)))
		    namegv = CvGV(cv);
	    }
	    else namegv = MUTABLE_GV(cv);
	    /* After a syntax error in a lexical sub, the cv that
	       rv2cv_op_cv returns may be a nameless stub. */
	    if (!namegv) return ck_entersub_args_list(o);

	}
	return ckfun(aTHX_ o, namegv, ckobj);
    }
}

OP *
Perl_ck_svconst(pTHX_ OP *o)
{
    SV * const sv = cSVOPo->op_sv;
    PERL_ARGS_ASSERT_CK_SVCONST;
    PERL_UNUSED_CONTEXT;
#ifdef PERL_COPY_ON_WRITE
    /* Since the read-only flag may be used to protect a string buffer, we
       cannot do copy-on-write with existing read-only scalars that are not
       already copy-on-write scalars.  To allow $_ = "hello" to do COW with
       that constant, mark the constant as COWable here, if it is not
       already read-only. */
    if (!SvREADONLY(sv) && !SvIsCOW(sv) && SvCANCOW(sv)) {
	SvIsCOW_on(sv);
	CowREFCNT(sv) = 0;
# ifdef PERL_DEBUG_READONLY_COW
	sv_buf_to_ro(sv);
# endif
    }
#endif
    SvREADONLY_on(sv);
    return o;
}

OP *
Perl_ck_trunc(pTHX_ OP *o)
{
    PERL_ARGS_ASSERT_CK_TRUNC;

    if (o->op_flags & OPf_KIDS) {
	SVOP *kid = (SVOP*)cUNOPo->op_first;

	if (kid->op_type == OP_NULL)
	    kid = (SVOP*)OpSIBLING(kid);
	if (kid && kid->op_type == OP_CONST &&
	    (kid->op_private & OPpCONST_BARE) &&
	    !kid->op_folded)
	{
	    o->op_flags |= OPf_SPECIAL;
	    kid->op_private &= ~OPpCONST_STRICT;
	}
    }
    return ck_fun(o);
}

OP *
Perl_ck_substr(pTHX_ OP *o)
{
    PERL_ARGS_ASSERT_CK_SUBSTR;

    o = ck_fun(o);
    if ((o->op_flags & OPf_KIDS) && (o->op_private == 4)) {
	OP *kid = cLISTOPo->op_first;

	if (kid->op_type == OP_NULL)
	    kid = OpSIBLING(kid);
	if (kid)
	    kid->op_flags |= OPf_MOD;

    }
    return o;
}

OP *
Perl_ck_tell(pTHX_ OP *o)
{
    PERL_ARGS_ASSERT_CK_TELL;
    o = ck_fun(o);
    if (o->op_flags & OPf_KIDS) {
     OP *kid = cLISTOPo->op_first;
     if (kid->op_type == OP_NULL && OpHAS_SIBLING(kid)) kid = OpSIBLING(kid);
     if (kid->op_type == OP_RV2GV) kid->op_private |= OPpALLOW_FAKE;
    }
    return o;
}

OP *
Perl_ck_each(pTHX_ OP *o)
{
    dVAR;
    OP *kid = o->op_flags & OPf_KIDS ? cUNOPo->op_first : NULL;
    const unsigned orig_type  = o->op_type;

    PERL_ARGS_ASSERT_CK_EACH;

    if (kid) {
	switch (kid->op_type) {
	    case OP_PADHV:
	    case OP_RV2HV:
		break;
	    case OP_PADAV:
	    case OP_RV2AV:
                OpTYPE_set(o, orig_type == OP_EACH ? OP_AEACH
                            : orig_type == OP_KEYS ? OP_AKEYS
                            :                        OP_AVALUES);
		break;
	    case OP_CONST:
		if (kid->op_private == OPpCONST_BARE
		 || !SvROK(cSVOPx_sv(kid))
		 || (  SvTYPE(SvRV(cSVOPx_sv(kid))) != SVt_PVAV
		    && SvTYPE(SvRV(cSVOPx_sv(kid))) != SVt_PVHV  )
		   )
		    /* we let ck_fun handle it */
		    break;
	    default:
                Perl_croak_nocontext(
                    "Experimental %s on scalar is now forbidden",
                    PL_op_desc[orig_type]);
                break;
	}
    }
    return ck_fun(o);
}

OP *
Perl_ck_length(pTHX_ OP *o)
{
    PERL_ARGS_ASSERT_CK_LENGTH;

    o = ck_fun(o);

    if (ckWARN(WARN_SYNTAX)) {
        const OP *kid = o->op_flags & OPf_KIDS ? cLISTOPo->op_first : NULL;

        if (kid) {
            SV *name = NULL;
            const bool hash = kid->op_type == OP_PADHV
                           || kid->op_type == OP_RV2HV;
            switch (kid->op_type) {
                case OP_PADHV:
                case OP_PADAV:
                case OP_RV2HV:
                case OP_RV2AV:
		    name = S_op_varname(aTHX_ kid);
                    break;
                default:
                    return o;
            }
            if (name)
                Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
                    "length() used on %"SVf" (did you mean \"scalar(%s%"SVf
                    ")\"?)",
                    SVfARG(name), hash ? "keys " : "", SVfARG(name)
                );
            else if (hash)
     /* diag_listed_as: length() used on %s (did you mean "scalar(%s)"?) */
                Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
                    "length() used on %%hash (did you mean \"scalar(keys %%hash)\"?)");
            else
     /* diag_listed_as: length() used on %s (did you mean "scalar(%s)"?) */
                Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
                    "length() used on @@array (did you mean \"scalar(@@array)\"?)");
        }
    }

    return o;
}



/* 
   ---------------------------------------------------------
 
   Common vars in list assignment

   There now follows some enums and static functions for detecting
   common variables in list assignments. Here is a little essay I wrote
   for myself when trying to get my head around this. DAPM.

   ----

   First some random observations:
   
   * If a lexical var is an alias of something else, e.g.
       for my $x ($lex, $pkg, $a[0]) {...}
     then the act of aliasing will increase the reference count of the SV
   
   * If a package var is an alias of something else, it may still have a
     reference count of 1, depending on how the alias was created, e.g.
     in *a = *b, $a may have a refcount of 1 since the GP is shared
     with a single GvSV pointer to the SV. So If it's an alias of another
     package var, then RC may be 1; if it's an alias of another scalar, e.g.
     a lexical var or an array element, then it will have RC > 1.
   
   * There are many ways to create a package alias; ultimately, XS code
     may quite legally do GvSV(gv) = SvREFCNT_inc(sv) for example, so
     run-time tracing mechanisms are unlikely to be able to catch all cases.
   
   * When the LHS is all my declarations, the same vars can't appear directly
     on the RHS, but they can indirectly via closures, aliasing and lvalue
     subs. But those techniques all involve an increase in the lexical
     scalar's ref count.
   
   * When the LHS is all lexical vars (but not necessarily my declarations),
     it is possible for the same lexicals to appear directly on the RHS, and
     without an increased ref count, since the stack isn't refcounted.
     This case can be detected at compile time by scanning for common lex
     vars with PL_generation.
   
   * lvalue subs defeat common var detection, but they do at least
     return vars with a temporary ref count increment. Also, you can't
     tell at compile time whether a sub call is lvalue.
   
    
   So...
         
   A: There are a few circumstances where there definitely can't be any
     commonality:
   
       LHS empty:  () = (...);
       RHS empty:  (....) = ();
       RHS contains only constants or other 'can't possibly be shared'
           elements (e.g. ops that return PADTMPs):  (...) = (1,2, length)
           i.e. they only contain ops not marked as dangerous, whose children
           are also not dangerous;
       LHS ditto;
       LHS contains a single scalar element: e.g. ($x) = (....); because
           after $x has been modified, it won't be used again on the RHS;
       RHS contains a single element with no aggregate on LHS: e.g.
           ($a,$b,$c)  = ($x); again, once $a has been modified, its value
           won't be used again.
   
   B: If LHS are all 'my' lexical var declarations (or safe ops, which
     we can ignore):
   
       my ($a, $b, @@c) = ...;
   
       Due to closure and goto tricks, these vars may already have content.
       For the same reason, an element on the RHS may be a lexical or package
       alias of one of the vars on the left, or share common elements, for
       example:
   
           my ($x,$y) = f(); # $x and $y on both sides
           sub f : lvalue { ($x,$y) = (1,2); $y, $x }
   
       and
   
           my $ra = f();
           my @@a = @@$ra;  # elements of @@a on both sides
           sub f { @@a = 1..4; \@@a }
   
   
       First, just consider scalar vars on LHS:
   
           RHS is safe only if (A), or in addition,
               * contains only lexical *scalar* vars, where neither side's
                 lexicals have been flagged as aliases 
   
           If RHS is not safe, then it's always legal to check LHS vars for
           RC==1, since the only RHS aliases will always be associated
           with an RC bump.
   
           Note that in particular, RHS is not safe if:
   
               * it contains package scalar vars; e.g.:
   
                   f();
                   my ($x, $y) = (2, $x_alias);
                   sub f { $x = 1; *x_alias = \$x; }
   
               * It contains other general elements, such as flattened or
               * spliced or single array or hash elements, e.g.
   
                   f();
                   my ($x,$y) = @@a; # or $a[0] or @@a{@@b} etc 
   
                   sub f {
                       ($x, $y) = (1,2);
                       use feature 'refaliasing';
                       \($a[0], $a[1]) = \($y,$x);
                   }
   
                 It doesn't matter if the array/hash is lexical or package.
   
               * it contains a function call that happens to be an lvalue
                 sub which returns one or more of the above, e.g.
   
                   f();
                   my ($x,$y) = f();
   
                   sub f : lvalue {
                       ($x, $y) = (1,2);
                       *x1 = \$x;
                       $y, $x1;
                   }
   
                   (so a sub call on the RHS should be treated the same
                   as having a package var on the RHS).
   
               * any other "dangerous" thing, such an op or built-in that
                 returns one of the above, e.g. pp_preinc
   
   
           If RHS is not safe, what we can do however is at compile time flag
           that the LHS are all my declarations, and at run time check whether
           all the LHS have RC == 1, and if so skip the full scan.
   
       Now consider array and hash vars on LHS: e.g. my (...,@@a) = ...;
   
           Here the issue is whether there can be elements of @@a on the RHS
           which will get prematurely freed when @@a is cleared prior to
           assignment. This is only a problem if the aliasing mechanism
           is one which doesn't increase the refcount - only if RC == 1
           will the RHS element be prematurely freed.
   
           Because the array/hash is being INTROed, it or its elements
           can't directly appear on the RHS:
   
               my (@@a) = ($a[0], @@a, etc) # NOT POSSIBLE
   
           but can indirectly, e.g.:
   
               my $r = f();
               my (@@a) = @@$r;
               sub f { @@a = 1..3; \@@a }
   
           So if the RHS isn't safe as defined by (A), we must always
           mortalise and bump the ref count of any remaining RHS elements
           when assigning to a non-empty LHS aggregate.
   
           Lexical scalars on the RHS aren't safe if they've been involved in
           aliasing, e.g.
   
               use feature 'refaliasing';
   
               f();
               \(my $lex) = \$pkg;
               my @@a = ($lex,3); # equivalent to ($a[0],3)
   
               sub f {
                   @@a = (1,2);
                   \$pkg = \$a[0];
               }
   
           Similarly with lexical arrays and hashes on the RHS:
   
               f();
               my @@b;
               my @@a = (@@b);
   
               sub f {
                   @@a = (1,2);
                   \$b[0] = \$a[1];
                   \$b[1] = \$a[0];
               }
   
   
   
   C: As (B), but in addition the LHS may contain non-intro lexicals, e.g.
       my $a; ($a, my $b) = (....);
   
       The difference between (B) and (C) is that it is now physically
       possible for the LHS vars to appear on the RHS too, where they
       are not reference counted; but in this case, the compile-time
       PL_generation sweep will detect such common vars.
   
       So the rules for (C) differ from (B) in that if common vars are
       detected, the runtime "test RC==1" optimisation can no longer be used,
       and a full mark and sweep is required
   
   D: As (C), but in addition the LHS may contain package vars.
   
       Since package vars can be aliased without a corresponding refcount
       increase, all bets are off. It's only safe if (A). E.g.
   
           my ($x, $y) = (1,2);
   
           for $x_alias ($x) {
               ($x_alias, $y) = (3, $x); # whoops
           }
   
       Ditto for LHS aggregate package vars.
   
   E: Any other dangerous ops on LHS, e.g.
           (f(), $a[0], @@$r) = (...);
   
       this is similar to (E) in that all bets are off. In addition, it's
       impossible to determine at compile time whether the LHS
       contains a scalar or an aggregate, e.g.
   
           sub f : lvalue { @@a }
           (f()) = 1..3;

* ---------------------------------------------------------
*/


/* A set of bit flags returned by S_aassign_scan(). Each flag indicates
 * that at least one of the things flagged was seen.
 */

enum {
    AAS_MY_SCALAR       = 0x001, /* my $scalar */
    AAS_MY_AGG          = 0x002, /* aggregate: my @@array or my %hash */
    AAS_LEX_SCALAR      = 0x004, /* $lexical */
    AAS_LEX_AGG         = 0x008, /* @@lexical or %lexical aggregate */
    AAS_LEX_SCALAR_COMM = 0x010, /* $lexical seen on both sides */
    AAS_PKG_SCALAR      = 0x020, /* $scalar (where $scalar is pkg var) */
    AAS_PKG_AGG         = 0x040, /* package @@array or %hash aggregate */
    AAS_DANGEROUS       = 0x080, /* an op (other than the above)
                                         that's flagged OA_DANGEROUS */
    AAS_SAFE_SCALAR     = 0x100, /* produces at least one scalar SV that's
                                        not in any of the categories above */
    AAS_DEFAV           = 0x200  /* contains just a single '@@_' on RHS */
};



/* helper function for S_aassign_scan().
 * check a PAD-related op for commonality and/or set its generation number.
 * Returns a boolean indicating whether its shared */

static bool
S_aassign_padcheck(pTHX_ OP* o, bool rhs)
{
    if (PAD_COMPNAME_GEN(o->op_targ) == PERL_INT_MAX)
        /* lexical used in aliasing */
        return TRUE;

    if (rhs)
        return cBOOL(PAD_COMPNAME_GEN(o->op_targ) == (STRLEN)PL_generation);
    else
        PAD_COMPNAME_GEN_set(o->op_targ, PL_generation);

    return FALSE;
}


/*
  Helper function for OPpASSIGN_COMMON* detection in rpeep().
  It scans the left or right hand subtree of the aassign op, and returns a
  set of flags indicating what sorts of things it found there.
  'rhs' indicates whether we're scanning the LHS or RHS. If the former, we
  set PL_generation on lexical vars; if the latter, we see if
  PL_generation matches.
  'top' indicates whether we're recursing or at the top level.
  'scalars_p' is a pointer to a counter of the number of scalar SVs seen.
  This fn will increment it by the number seen. It's not intended to
  be an accurate count (especially as many ops can push a variable
  number of SVs onto the stack); rather it's used as to test whether there
  can be at most 1 SV pushed; so it's only meanings are "0, 1, many".
*/

static int
S_aassign_scan(pTHX_ OP* o, bool rhs, bool top, int *scalars_p)
{
    int flags = 0;
    bool kid_top = FALSE;

    /* first, look for a solitary @@_ on the RHS */
    if (   rhs
        && top
        && (o->op_flags & OPf_KIDS)
        && OP_TYPE_IS_OR_WAS(o, OP_LIST)
    ) {
        OP *kid = cUNOPo->op_first;
        if (   (   kid->op_type == OP_PUSHMARK
                || kid->op_type == OP_PADRANGE) /* ex-pushmark */
            && ((kid = OpSIBLING(kid)))
            && !OpHAS_SIBLING(kid)
            && kid->op_type == OP_RV2AV
            && !(kid->op_flags & OPf_REF)
            && !(kid->op_private & (OPpLVAL_INTRO|OPpMAYBE_LVSUB))
            && ((kid->op_flags & OPf_WANT) == OPf_WANT_LIST)
            && ((kid = cUNOPx(kid)->op_first))
            && kid->op_type == OP_GV
            && cGVOPx_gv(kid) == PL_defgv
        )
            flags |= AAS_DEFAV;
    }

    switch (o->op_type) {
    case OP_GVSV:
        (*scalars_p)++;
        return AAS_PKG_SCALAR;

    case OP_PADAV:
    case OP_PADHV:
        (*scalars_p) += 2;
        if (top && (o->op_flags & OPf_REF))
            return (o->op_private & OPpLVAL_INTRO)
                ? AAS_MY_AGG : AAS_LEX_AGG;
        return AAS_DANGEROUS;

    case OP_PADSV:
        {
            int comm = S_aassign_padcheck(aTHX_ o, rhs)
                        ?  AAS_LEX_SCALAR_COMM : 0;
            (*scalars_p)++;
            return (o->op_private & OPpLVAL_INTRO)
                ? (AAS_MY_SCALAR|comm) : (AAS_LEX_SCALAR|comm);
        }

    case OP_RV2AV:
    case OP_RV2HV:
        (*scalars_p) += 2;
        if (cUNOPx(o)->op_first->op_type != OP_GV)
            return AAS_DANGEROUS; /* @@{expr}, %{expr} */
        /* @@pkg, %pkg */
        if (top && (o->op_flags & OPf_REF))
            return AAS_PKG_AGG;
        return AAS_DANGEROUS;

    case OP_RV2SV:
        (*scalars_p)++;
        if (cUNOPx(o)->op_first->op_type != OP_GV) {
            (*scalars_p) += 2;
            return AAS_DANGEROUS; /* ${expr} */
        }
        return AAS_PKG_SCALAR; /* $pkg */

    case OP_SPLIT:
        if (cLISTOPo->op_first->op_type == OP_PUSHRE) {
            /* "@@foo = split... " optimises away the aassign and stores its
             * destination array in the OP_PUSHRE that precedes it.
             * A flattened array is always dangerous.
             */
            (*scalars_p) += 2;
            return AAS_DANGEROUS;
        }
        break;

    case OP_UNDEF:
        /* undef counts as a scalar on the RHS:
         *   (undef, $x) = ...;         # only 1 scalar on LHS: always safe
         *   ($x, $y)    = (undef, $x); # 2 scalars on RHS: unsafe
         */
        if (rhs)
            (*scalars_p)++;
        flags = AAS_SAFE_SCALAR;
        break;

    case OP_PUSHMARK:
    case OP_STUB:
        /* these are all no-ops; they don't push a potentially common SV
         * onto the stack, so they are neither AAS_DANGEROUS nor
         * AAS_SAFE_SCALAR */
        return 0;

    case OP_PADRANGE: /* Ignore padrange; checking its siblings is enough */
        break;

    case OP_NULL:
    case OP_LIST:
        /* these do nothing but may have children; but their children
         * should also be treated as top-level */
        kid_top = top;
        break;

    default:
        if (PL_opargs[o->op_type] & OA_DANGEROUS) {
            (*scalars_p) += 2;
            flags = AAS_DANGEROUS;
            break;
        }

        if (   (PL_opargs[o->op_type] & OA_TARGLEX)
            && (o->op_private & OPpTARGET_MY))
        {
            (*scalars_p)++;
            return S_aassign_padcheck(aTHX_ o, rhs)
                ? AAS_LEX_SCALAR_COMM : AAS_LEX_SCALAR;
        }

        /* if its an unrecognised, non-dangerous op, assume that it
         * it the cause of at least one safe scalar */
        (*scalars_p)++;
        flags = AAS_SAFE_SCALAR;
        break;
    }

    if (o->op_flags & OPf_KIDS) {
        OP *kid;
        for (kid = cUNOPo->op_first; kid; kid = OpSIBLING(kid))
            flags |= S_aassign_scan(aTHX_ kid, rhs, kid_top, scalars_p);
    }
    return flags;
}


/* Check for in place reverse and sort assignments like "@@a = reverse @@a"
   and modify the optree to make them work inplace */

STATIC void
S_inplace_aassign(pTHX_ OP *o) {

    OP *modop, *modop_pushmark;
    OP *oright;
    OP *oleft, *oleft_pushmark;

    PERL_ARGS_ASSERT_INPLACE_AASSIGN;

    assert((o->op_flags & OPf_WANT) == OPf_WANT_VOID);

    assert(cUNOPo->op_first->op_type == OP_NULL);
    modop_pushmark = cUNOPx(cUNOPo->op_first)->op_first;
    assert(modop_pushmark->op_type == OP_PUSHMARK);
    modop = OpSIBLING(modop_pushmark);

    if (modop->op_type != OP_SORT && modop->op_type != OP_REVERSE)
	return;

    /* no other operation except sort/reverse */
    if (OpHAS_SIBLING(modop))
	return;

    assert(cUNOPx(modop)->op_first->op_type == OP_PUSHMARK);
    if (!(oright = OpSIBLING(cUNOPx(modop)->op_first))) return;

    if (modop->op_flags & OPf_STACKED) {
	/* skip sort subroutine/block */
	assert(oright->op_type == OP_NULL);
	oright = OpSIBLING(oright);
    }

    assert(OpSIBLING(cUNOPo->op_first)->op_type == OP_NULL);
    oleft_pushmark = cUNOPx(OpSIBLING(cUNOPo->op_first))->op_first;
    assert(oleft_pushmark->op_type == OP_PUSHMARK);
    oleft = OpSIBLING(oleft_pushmark);

    /* Check the lhs is an array */
    if (!oleft ||
	(oleft->op_type != OP_RV2AV && oleft->op_type != OP_PADAV)
	|| OpHAS_SIBLING(oleft)
	|| (oleft->op_private & OPpLVAL_INTRO)
    )
	return;

    /* Only one thing on the rhs */
    if (OpHAS_SIBLING(oright))
	return;

    /* check the array is the same on both sides */
    if (oleft->op_type == OP_RV2AV) {
	if (oright->op_type != OP_RV2AV
	    || !cUNOPx(oright)->op_first
	    || cUNOPx(oright)->op_first->op_type != OP_GV
	    || cUNOPx(oleft )->op_first->op_type != OP_GV
	    || cGVOPx_gv(cUNOPx(oleft)->op_first) !=
	       cGVOPx_gv(cUNOPx(oright)->op_first)
	)
	    return;
    }
    else if (oright->op_type != OP_PADAV
	|| oright->op_targ != oleft->op_targ
    )
	return;

    /* This actually is an inplace assignment */

    modop->op_private |= OPpSORT_INPLACE;

    /* transfer MODishness etc from LHS arg to RHS arg */
    oright->op_flags = oleft->op_flags;

    /* remove the aassign op and the lhs */
    op_null(o);
    op_null(oleft_pushmark);
    if (oleft->op_type == OP_RV2AV && cUNOPx(oleft)->op_first)
	op_null(cUNOPx(oleft)->op_first);
    op_null(oleft);
}



/* S_maybe_multideref(): given an op_next chain of ops beginning at 'start'
 * that potentially represent a series of one or more aggregate derefs
 * (such as $a->[1]{$key}), examine the chain, and if appropriate, convert
 * the whole chain to a single OP_MULTIDEREF op (maybe with a few
 * additional ops left in too).
 *
 * The caller will have already verified that the first few ops in the
 * chain following 'start' indicate a multideref candidate, and will have
 * set 'orig_o' to the point further on in the chain where the first index
 * expression (if any) begins.  'orig_action' specifies what type of
 * beginning has already been determined by the ops between start..orig_o
 * (e.g.  $lex_ary[], $pkg_ary->{}, expr->[], etc).
 *
 * 'hints' contains any hints flags that need adding (currently just
 * OPpHINT_STRICT_REFS) as found in any rv2av/hv skipped by the caller.
 */

STATIC void
S_maybe_multideref(pTHX_ OP *start, OP *orig_o, UV orig_action, U8 hints)
{
    dVAR;
    int pass;
    UNOP_AUX_item *arg_buf = NULL;
    bool reset_start_targ  = FALSE; /* start->op_targ needs zeroing */
    int index_skip         = -1;    /* don't output index arg on this action */

    /* similar to regex compiling, do two passes; the first pass
     * determines whether the op chain is convertible and calculates the
     * buffer size; the second pass populates the buffer and makes any
     * changes necessary to ops (such as moving consts to the pad on
     * threaded builds).
     *
     * NB: for things like Coverity, note that both passes take the same
     * path through the logic tree (except for 'if (pass)' bits), since
     * both passes are following the same op_next chain; and in
     * particular, if it would return early on the second pass, it would
     * already have returned early on the first pass.
     */
    for (pass = 0; pass < 2; pass++) {
        OP *o                = orig_o;
        UV action            = orig_action;
        OP *first_elem_op    = NULL;  /* first seen aelem/helem */
        OP *top_op           = NULL;  /* highest [ah]elem/exists/del/rv2[ah]v */
        int action_count     = 0;     /* number of actions seen so far */
        int action_ix        = 0;     /* action_count % (actions per IV) */
        bool next_is_hash    = FALSE; /* is the next lookup to be a hash? */
        bool is_last         = FALSE; /* no more derefs to follow */
        bool maybe_aelemfast = FALSE; /* we can replace with aelemfast? */
        UNOP_AUX_item *arg     = arg_buf;
        UNOP_AUX_item *action_ptr = arg_buf;

        if (pass)
            action_ptr->uv = 0;
        arg++;

        switch (action) {
        case MDEREF_HV_gvsv_vivify_rv2hv_helem:
        case MDEREF_HV_gvhv_helem:
            next_is_hash = TRUE;
            /* FALLTHROUGH */
        case MDEREF_AV_gvsv_vivify_rv2av_aelem:
        case MDEREF_AV_gvav_aelem:
            if (pass) {
#ifdef USE_ITHREADS
                arg->pad_offset = cPADOPx(start)->op_padix;
                /* stop it being swiped when nulled */
                cPADOPx(start)->op_padix = 0;
#else
                arg->sv = cSVOPx(start)->op_sv;
                cSVOPx(start)->op_sv = NULL;
#endif
            }
            arg++;
            break;

        case MDEREF_HV_padhv_helem:
        case MDEREF_HV_padsv_vivify_rv2hv_helem:
            next_is_hash = TRUE;
            /* FALLTHROUGH */
        case MDEREF_AV_padav_aelem:
        case MDEREF_AV_padsv_vivify_rv2av_aelem:
            if (pass) {
                arg->pad_offset = start->op_targ;
                /* we skip setting op_targ = 0 for now, since the intact
                 * OP_PADXV is needed by S_check_hash_fields_and_hekify */
                reset_start_targ = TRUE;
            }
            arg++;
            break;

        case MDEREF_HV_pop_rv2hv_helem:
            next_is_hash = TRUE;
            /* FALLTHROUGH */
        case MDEREF_AV_pop_rv2av_aelem:
            break;

        default:
            NOT_REACHED; /* NOTREACHED */
            return;
        }

        while (!is_last) {
            /* look for another (rv2av/hv; get index;
             * aelem/helem/exists/delele) sequence */

            OP *kid;
            bool is_deref;
            bool ok;
            UV index_type = MDEREF_INDEX_none;

            if (action_count) {
                /* if this is not the first lookup, consume the rv2av/hv  */

                /* for N levels of aggregate lookup, we normally expect
                 * that the first N-1 [ah]elem ops will be flagged as
                 * /DEREF (so they autovivifiy if necessary), and the last
                 * lookup op not to be.
                 * For other things (like @@{$h{k1}{k2}}) extra scope or
                 * leave ops can appear, so abandon the effort in that
                 * case */
                if (o->op_type != OP_RV2AV && o->op_type != OP_RV2HV)
                    return;

                /* rv2av or rv2hv sKR/1 */

                ASSUME(!(o->op_flags & ~(OPf_WANT|OPf_KIDS|OPf_PARENS
                                            |OPf_REF|OPf_MOD|OPf_SPECIAL)));
                if (o->op_flags != (OPf_WANT_SCALAR|OPf_KIDS|OPf_REF))
                    return;

                /* at this point, we wouldn't expect any of these
                 * possible private flags:
                 * OPpMAYBE_LVSUB, OPpOUR_INTRO, OPpLVAL_INTRO
                 * OPpTRUEBOOL, OPpMAYBE_TRUEBOOL (rv2hv only)
                 */
                ASSUME(!(o->op_private &
                    ~(OPpHINT_STRICT_REFS|OPpARG1_MASK|OPpSLICEWARNING)));

                hints = (o->op_private & OPpHINT_STRICT_REFS);

                /* make sure the type of the previous /DEREF matches the
                 * type of the next lookup */
                ASSUME(o->op_type == (next_is_hash ? OP_RV2HV : OP_RV2AV));
                top_op = o;

                action = next_is_hash
                            ? MDEREF_HV_vivify_rv2hv_helem
                            : MDEREF_AV_vivify_rv2av_aelem;
                o = o->op_next;
            }

            /* if this is the second pass, and we're at the depth where
             * previously we encountered a non-simple index expression,
             * stop processing the index at this point */
            if (action_count != index_skip) {

                /* look for one or more simple ops that return an array
                 * index or hash key */

                switch (o->op_type) {
                case OP_PADSV:
                    /* it may be a lexical var index */
                    ASSUME(!(o->op_flags & ~(OPf_WANT|OPf_PARENS
                                            |OPf_REF|OPf_MOD|OPf_SPECIAL)));
                    ASSUME(!(o->op_private &
                            ~(OPpPAD_STATE|OPpDEREF|OPpLVAL_INTRO)));

                    if (   OP_GIMME(o,0) == G_SCALAR
                        && !(o->op_flags & (OPf_REF|OPf_MOD))
                        && o->op_private == 0)
                    {
                        if (pass)
                            arg->pad_offset = o->op_targ;
                        arg++;
                        index_type = MDEREF_INDEX_padsv;
                        o = o->op_next;
                    }
                    break;

                case OP_CONST:
                    if (next_is_hash) {
                        /* it's a constant hash index */
                        if (!(SvFLAGS(cSVOPo_sv) & (SVf_IOK|SVf_NOK|SVf_POK)))
                            /* "use constant foo => FOO; $h{+foo}" for
                             * some weird FOO, can leave you with constants
                             * that aren't simple strings. It's not worth
                             * the extra hassle for those edge cases */
                            break;

                        if (pass) {
                            UNOP *rop = NULL;
                            OP * helem_op = o->op_next;

                            ASSUME(   helem_op->op_type == OP_HELEM
                                   || helem_op->op_type == OP_NULL);
                            if (helem_op->op_type == OP_HELEM) {
                                rop = (UNOP*)(((BINOP*)helem_op)->op_first);
                                if (   helem_op->op_private & OPpLVAL_INTRO
                                    || rop->op_type != OP_RV2HV
                                )
                                    rop = NULL;
                            }
                            S_check_hash_fields_and_hekify(aTHX_ rop, cSVOPo);

#ifdef USE_ITHREADS
                            /* Relocate sv to the pad for thread safety */
                            op_relocate_sv(&cSVOPo->op_sv, &o->op_targ);
                            arg->pad_offset = o->op_targ;
                            o->op_targ = 0;
#else
                            arg->sv = cSVOPx_sv(o);
#endif
                        }
                    }
                    else {
                        /* it's a constant array index */
                        IV iv;
                        SV *ix_sv = cSVOPo->op_sv;
                        if (!SvIOK(ix_sv))
                            break;
                        iv = SvIV(ix_sv);

                        if (   action_count == 0
                            && iv >= -128
                            && iv <= 127
                            && (   action == MDEREF_AV_padav_aelem
                                || action == MDEREF_AV_gvav_aelem)
                        )
                            maybe_aelemfast = TRUE;

                        if (pass) {
                            arg->iv = iv;
                            SvREFCNT_dec_NN(cSVOPo->op_sv);
                        }
                    }
                    if (pass)
                        /* we've taken ownership of the SV */
                        cSVOPo->op_sv = NULL;
                    arg++;
                    index_type = MDEREF_INDEX_const;
                    o = o->op_next;
                    break;

                case OP_GV:
                    /* it may be a package var index */

                    ASSUME(!(o->op_flags & ~(OPf_WANT|OPf_SPECIAL)));
                    ASSUME(!(o->op_private & ~(OPpEARLY_CV)));
                    if (  (o->op_flags &~ OPf_SPECIAL) != OPf_WANT_SCALAR
                        || o->op_private != 0
                    )
                        break;

                    kid = o->op_next;
                    if (kid->op_type != OP_RV2SV)
                        break;

                    ASSUME(!(kid->op_flags &
                            ~(OPf_WANT|OPf_KIDS|OPf_MOD|OPf_REF
                             |OPf_SPECIAL|OPf_PARENS)));
                    ASSUME(!(kid->op_private &
                                    ~(OPpARG1_MASK
                                     |OPpHINT_STRICT_REFS|OPpOUR_INTRO
                                     |OPpDEREF|OPpLVAL_INTRO)));
                    if(   (kid->op_flags &~ OPf_PARENS)
                            != (OPf_WANT_SCALAR|OPf_KIDS)
                       || (kid->op_private & ~(OPpARG1_MASK|HINT_STRICT_REFS))
                    )
                        break;

                    if (pass) {
#ifdef USE_ITHREADS
                        arg->pad_offset = cPADOPx(o)->op_padix;
                        /* stop it being swiped when nulled */
                        cPADOPx(o)->op_padix = 0;
#else
                        arg->sv = cSVOPx(o)->op_sv;
                        cSVOPo->op_sv = NULL;
#endif
                    }
                    arg++;
                    index_type = MDEREF_INDEX_gvsv;
                    o = kid->op_next;
                    break;

                } /* switch */
            } /* action_count != index_skip */

            action |= index_type;


            /* at this point we have either:
             *   * detected what looks like a simple index expression,
             *     and expect the next op to be an [ah]elem, or
             *     an nulled  [ah]elem followed by a delete or exists;
             *  * found a more complex expression, so something other
             *    than the above follows.
             */

            /* possibly an optimised away [ah]elem (where op_next is
             * exists or delete) */
            if (o->op_type == OP_NULL)
                o = o->op_next;

            /* at this point we're looking for an OP_AELEM, OP_HELEM,
             * OP_EXISTS or OP_DELETE */

            /* if something like arybase (a.k.a $[ ) is in scope,
             * abandon optimisation attempt */
            if (  (o->op_type == OP_AELEM || o->op_type == OP_HELEM)
               && PL_check[o->op_type] != Perl_ck_null)
                return;

            if (   o->op_type != OP_AELEM
                || (o->op_private &
		      (OPpLVAL_INTRO|OPpLVAL_DEFER|OPpDEREF|OPpMAYBE_LVSUB))
                )
                maybe_aelemfast = FALSE;

            /* look for aelem/helem/exists/delete. If it's not the last elem
             * lookup, it *must* have OPpDEREF_AV/HV, but not many other
             * flags; if it's the last, then it mustn't have
             * OPpDEREF_AV/HV, but may have lots of other flags, like
             * OPpLVAL_INTRO etc
             */

            if (   index_type == MDEREF_INDEX_none
                || (   o->op_type != OP_AELEM  && o->op_type != OP_HELEM
                    && o->op_type != OP_EXISTS && o->op_type != OP_DELETE)
            )
                ok = FALSE;
            else {
                /* we have aelem/helem/exists/delete with valid simple index */

                is_deref =    (o->op_type == OP_AELEM || o->op_type == OP_HELEM)
                           && (   (o->op_private & OPpDEREF) == OPpDEREF_AV
                               || (o->op_private & OPpDEREF) == OPpDEREF_HV);

                if (is_deref) {
                    ASSUME(!(o->op_flags &
                                 ~(OPf_WANT|OPf_KIDS|OPf_MOD|OPf_PARENS)));
                    ASSUME(!(o->op_private & ~(OPpARG2_MASK|OPpDEREF)));

                    ok =    (o->op_flags &~ OPf_PARENS)
                               == (OPf_WANT_SCALAR|OPf_KIDS|OPf_MOD)
                         && !(o->op_private & ~(OPpDEREF|OPpARG2_MASK));
                }
                else if (o->op_type == OP_EXISTS) {
                    ASSUME(!(o->op_flags & ~(OPf_WANT|OPf_KIDS|OPf_PARENS
                                |OPf_REF|OPf_MOD|OPf_SPECIAL)));
                    ASSUME(!(o->op_private & ~(OPpARG1_MASK|OPpEXISTS_SUB)));
                    ok =  !(o->op_private & ~OPpARG1_MASK);
                }
                else if (o->op_type == OP_DELETE) {
                    ASSUME(!(o->op_flags & ~(OPf_WANT|OPf_KIDS|OPf_PARENS
                                |OPf_REF|OPf_MOD|OPf_SPECIAL)));
                    ASSUME(!(o->op_private &
                                    ~(OPpARG1_MASK|OPpSLICE|OPpLVAL_INTRO)));
                    /* don't handle slices or 'local delete'; the latter
                     * is fairly rare, and has a complex runtime */
                    ok =  !(o->op_private & ~OPpARG1_MASK);
                    if (OP_TYPE_IS_OR_WAS(cUNOPo->op_first, OP_AELEM))
                        /* skip handling run-tome error */
                        ok = (ok && cBOOL(o->op_flags & OPf_SPECIAL));
                }
                else {
                    ASSUME(o->op_type == OP_AELEM || o->op_type == OP_HELEM);
                    ASSUME(!(o->op_flags & ~(OPf_WANT|OPf_KIDS|OPf_MOD
                                            |OPf_PARENS|OPf_REF|OPf_SPECIAL)));
                    ASSUME(!(o->op_private & ~(OPpARG2_MASK|OPpMAYBE_LVSUB
                                    |OPpLVAL_DEFER|OPpDEREF|OPpLVAL_INTRO)));
                    ok = (o->op_private & OPpDEREF) != OPpDEREF_SV;
                }
            }

            if (ok) {
                if (!first_elem_op)
                    first_elem_op = o;
                top_op = o;
                if (is_deref) {
                    next_is_hash = cBOOL((o->op_private & OPpDEREF) == OPpDEREF_HV);
                    o = o->op_next;
                }
                else {
                    is_last = TRUE;
                    action |= MDEREF_FLAG_last;
                }
            }
            else {
                /* at this point we have something that started
                 * promisingly enough (with rv2av or whatever), but failed
                 * to find a simple index followed by an
                 * aelem/helem/exists/delete. If this is the first action,
                 * give up; but if we've already seen at least one
                 * aelem/helem, then keep them and add a new action with
                 * MDEREF_INDEX_none, which causes it to do the vivify
                 * from the end of the previous lookup, and do the deref,
                 * but stop at that point. So $a[0][expr] will do one
                 * av_fetch, vivify and deref, then continue executing at
                 * expr */
                if (!action_count)
                    return;
                is_last = TRUE;
                index_skip = action_count;
                action |= MDEREF_FLAG_last;
            }

            if (pass)
                action_ptr->uv |= (action << (action_ix * MDEREF_SHIFT));
            action_ix++;
            action_count++;
            /* if there's no space for the next action, create a new slot
             * for it *before* we start adding args for that action */
            if ((action_ix + 1) * MDEREF_SHIFT > UVSIZE*8) {
                action_ptr = arg;
                if (pass)
                    arg->uv = 0;
                arg++;
                action_ix = 0;
            }
        } /* while !is_last */

        /* success! */

        if (pass) {
            OP *mderef;
            OP *p, *q;

            mderef = newUNOP_AUX(OP_MULTIDEREF, 0, NULL, arg_buf);
            if (index_skip == -1) {
                mderef->op_flags = o->op_flags
                        & (OPf_WANT|OPf_MOD|(next_is_hash ? OPf_SPECIAL : 0));
                if (o->op_type == OP_EXISTS)
                    mderef->op_private = OPpMULTIDEREF_EXISTS;
                else if (o->op_type == OP_DELETE)
                    mderef->op_private = OPpMULTIDEREF_DELETE;
                else
                    mderef->op_private = o->op_private
                        & (OPpMAYBE_LVSUB|OPpLVAL_DEFER|OPpLVAL_INTRO);
            }
            /* accumulate strictness from every level (although I don't think
             * they can actually vary) */
            mderef->op_private |= hints;

            /* integrate the new multideref op into the optree and the
             * op_next chain.
             *
             * In general an op like aelem or helem has two child
             * sub-trees: the aggregate expression (a_expr) and the
             * index expression (i_expr):
             *
             *     aelem
             *       |
             *     a_expr - i_expr
             *
             * The a_expr returns an AV or HV, while the i-expr returns an
             * index. In general a multideref replaces most or all of a
             * multi-level tree, e.g.
             *
             *     exists
             *       |
             *     ex-aelem
             *       |
             *     rv2av  - i_expr1
             *       |
             *     helem
             *       |
             *     rv2hv  - i_expr2
             *       |
             *     aelem
             *       |
             *     a_expr - i_expr3
             *
             * With multideref, all the i_exprs will be simple vars or
             * constants, except that i_expr1 may be arbitrary in the case
             * of MDEREF_INDEX_none.
             *
             * The bottom-most a_expr will be either:
             *   1) a simple var (so padXv or gv+rv2Xv);
             *   2) a simple scalar var dereferenced (e.g. $r->[0]):
             *      so a simple var with an extra rv2Xv;
             *   3) or an arbitrary expression.
             *
             * 'start', the first op in the execution chain, will point to
             *   1),2): the padXv or gv op;
             *   3):    the rv2Xv which forms the last op in the a_expr
             *          execution chain, and the top-most op in the a_expr
             *          subtree.
             *
             * For all cases, the 'start' node is no longer required,
             * but we can't free it since one or more external nodes
             * may point to it. E.g. consider
             *     $h{foo} = $a ? $b : $c
             * Here, both the op_next and op_other branches of the
             * cond_expr point to the gv[*h] of the hash expression, so
             * we can't free the 'start' op.
             *
             * For expr->[...], we need to save the subtree containing the
             * expression; for the other cases, we just need to save the
             * start node.
             * So in all cases, we null the start op and keep it around by
             * making it the child of the multideref op; for the expr->
             * case, the expr will be a subtree of the start node.
             *
             * So in the simple 1,2 case the  optree above changes to
             *
             *     ex-exists
             *       |
             *     multideref
             *       |
             *     ex-gv (or ex-padxv)
             *
             *  with the op_next chain being
             *
             *  -> ex-gv -> multideref -> op-following-ex-exists ->
             *
             *  In the 3 case, we have
             *
             *     ex-exists
             *       |
             *     multideref
             *       |
             *     ex-rv2xv
             *       |
             *    rest-of-a_expr
             *      subtree
             *
             *  and
             *
             *  -> rest-of-a_expr subtree ->
             *    ex-rv2xv -> multideref -> op-following-ex-exists ->
             *
             *
             * Where the last i_expr is non-simple (i.e. MDEREF_INDEX_none,
             * e.g. $a[0]{foo}[$x+1], the next rv2xv is nulled and the
             * multideref attached as the child, e.g.
             *
             *     exists
             *       |
             *     ex-aelem
             *       |
             *     ex-rv2av  - i_expr1
             *       |
             *     multideref
             *       |
             *     ex-whatever
             *
             */

            /* if we free this op, don't free the pad entry */
            if (reset_start_targ)
                start->op_targ = 0;


            /* Cut the bit we need to save out of the tree and attach to
             * the multideref op, then free the rest of the tree */

            /* find parent of node to be detached (for use by splice) */
            p = first_elem_op;
            if (   orig_action == MDEREF_AV_pop_rv2av_aelem
                || orig_action == MDEREF_HV_pop_rv2hv_helem)
            {
                /* there is an arbitrary expression preceding us, e.g.
                 * expr->[..]? so we need to save the 'expr' subtree */
                if (p->op_type == OP_EXISTS || p->op_type == OP_DELETE)
                    p = cUNOPx(p)->op_first;
                ASSUME(   start->op_type == OP_RV2AV
                       || start->op_type == OP_RV2HV);
            }
            else {
                /* either a padXv or rv2Xv+gv, maybe with an ex-Xelem
                 * above for exists/delete. */
                while (   (p->op_flags & OPf_KIDS)
                       && cUNOPx(p)->op_first != start
                )
                    p = cUNOPx(p)->op_first;
            }
            ASSUME(cUNOPx(p)->op_first == start);

            /* detach from main tree, and re-attach under the multideref */
            op_sibling_splice(mderef, NULL, 0,
                    op_sibling_splice(p, NULL, 1, NULL));
            op_null(start);

            start->op_next = mderef;

            mderef->op_next = index_skip == -1 ? o->op_next : o;

            /* excise and free the original tree, and replace with
             * the multideref op */
            p = op_sibling_splice(top_op, NULL, -1, mderef);
            while (p) {
                q = OpSIBLING(p);
                op_free(p);
                p = q;
            }
            op_null(top_op);
        }
        else {
            Size_t size = arg - arg_buf;

            if (maybe_aelemfast && action_count == 1)
                return;

            arg_buf = (UNOP_AUX_item*)PerlMemShared_malloc(
                                sizeof(UNOP_AUX_item) * (size + 1));
            /* for dumping etc: store the length in a hidden first slot;
             * we set the op_aux pointer to the second slot */
            arg_buf->uv = size;
            arg_buf++;
        }
    } /* for (pass = ...) */
}



/* mechanism for deferring recursion in rpeep() */

#define MAX_DEFERRED 4

#define DEFER(o) \
  STMT_START { \
    if (defer_ix == (MAX_DEFERRED-1)) { \
        OP **defer = defer_queue[defer_base]; \
        CALL_RPEEP(*defer); \
        S_prune_chain_head(defer); \
	defer_base = (defer_base + 1) % MAX_DEFERRED; \
	defer_ix--; \
    } \
    defer_queue[(defer_base + ++defer_ix) % MAX_DEFERRED] = &(o); \
  } STMT_END

#define IS_AND_OP(o)   (o->op_type == OP_AND)
#define IS_OR_OP(o)    (o->op_type == OP_OR)


/* A peephole optimizer.  We visit the ops in the order they're to execute.
 * See the comments at the top of this file for more details about when
 * peep() is called */

void
Perl_rpeep(pTHX_ OP *o)
{
    dVAR;
    OP* oldop = NULL;
    OP* oldoldop = NULL;
    OP** defer_queue[MAX_DEFERRED]; /* small queue of deferred branches */
    int defer_base = 0;
    int defer_ix = -1;
    OP *fop;
    OP *sop;

    if (!o || o->op_opt)
	return;
    ENTER;
    SAVEOP();
    SAVEVPTR(PL_curcop);
    for (;; o = o->op_next) {
	if (o && o->op_opt)
	    o = NULL;
	if (!o) {
	    while (defer_ix >= 0) {
                OP **defer =
                        defer_queue[(defer_base + defer_ix--) % MAX_DEFERRED];
                CALL_RPEEP(*defer);
                S_prune_chain_head(defer);
            }
	    break;
	}

      redo:

        /* oldoldop -> oldop -> o should be a chain of 3 adjacent ops */
        assert(!oldoldop || oldoldop->op_next == oldop);
        assert(!oldop    || oldop->op_next    == o);

	/* By default, this op has now been optimised. A couple of cases below
	   clear this again.  */
	o->op_opt = 1;
	PL_op = o;

        /* look for a series of 1 or more aggregate derefs, e.g.
         *   $a[1]{foo}[$i]{$k}
         * and replace with a single OP_MULTIDEREF op.
         * Each index must be either a const, or a simple variable,
         *
         * First, look for likely combinations of starting ops,
         * corresponding to (global and lexical variants of)
         *     $a[...]   $h{...}
         *     $r->[...] $r->{...}
         *     (preceding expression)->[...]
         *     (preceding expression)->{...}
         * and if so, call maybe_multideref() to do a full inspection
         * of the op chain and if appropriate, replace with an
         * OP_MULTIDEREF
         */
        {
            UV action;
            OP *o2 = o;
            U8 hints = 0;

            switch (o2->op_type) {
            case OP_GV:
                /* $pkg[..]   :   gv[*pkg]
                 * $pkg->[...]:   gv[*pkg]; rv2sv sKM/DREFAV */

                /* Fail if there are new op flag combinations that we're
                 * not aware of, rather than:
                 *  * silently failing to optimise, or
                 *  * silently optimising the flag away.
                 * If this ASSUME starts failing, examine what new flag
                 * has been added to the op, and decide whether the
                 * optimisation should still occur with that flag, then
                 * update the code accordingly. This applies to all the
                 * other ASSUMEs in the block of code too.
                 */
                ASSUME(!(o2->op_flags &
                            ~(OPf_WANT|OPf_MOD|OPf_PARENS|OPf_SPECIAL)));
                ASSUME(!(o2->op_private & ~OPpEARLY_CV));

                o2 = o2->op_next;

                if (o2->op_type == OP_RV2AV) {
                    action = MDEREF_AV_gvav_aelem;
                    goto do_deref;
                }

                if (o2->op_type == OP_RV2HV) {
                    action = MDEREF_HV_gvhv_helem;
                    goto do_deref;
                }

                if (o2->op_type != OP_RV2SV)
                    break;

                /* at this point we've seen gv,rv2sv, so the only valid
                 * construct left is $pkg->[] or $pkg->{} */

                ASSUME(!(o2->op_flags & OPf_STACKED));
                if ((o2->op_flags & (OPf_WANT|OPf_REF|OPf_MOD|OPf_SPECIAL))
                            != (OPf_WANT_SCALAR|OPf_MOD))
                    break;

                ASSUME(!(o2->op_private & ~(OPpARG1_MASK|HINT_STRICT_REFS
                                    |OPpOUR_INTRO|OPpDEREF|OPpLVAL_INTRO)));
                if (o2->op_private & (OPpOUR_INTRO|OPpLVAL_INTRO))
                    break;
                if (   (o2->op_private & OPpDEREF) != OPpDEREF_AV
                    && (o2->op_private & OPpDEREF) != OPpDEREF_HV)
                    break;

                o2 = o2->op_next;
                if (o2->op_type == OP_RV2AV) {
                    action = MDEREF_AV_gvsv_vivify_rv2av_aelem;
                    goto do_deref;
                }
                if (o2->op_type == OP_RV2HV) {
                    action = MDEREF_HV_gvsv_vivify_rv2hv_helem;
                    goto do_deref;
                }
                break;

            case OP_PADSV:
                /* $lex->[...]: padsv[$lex] sM/DREFAV */

                ASSUME(!(o2->op_flags &
                    ~(OPf_WANT|OPf_PARENS|OPf_REF|OPf_MOD|OPf_SPECIAL)));
                if ((o2->op_flags &
                        (OPf_WANT|OPf_REF|OPf_MOD|OPf_SPECIAL))
                     != (OPf_WANT_SCALAR|OPf_MOD))
                    break;

                ASSUME(!(o2->op_private &
                                ~(OPpPAD_STATE|OPpDEREF|OPpLVAL_INTRO)));
                /* skip if state or intro, or not a deref */
                if (      o2->op_private != OPpDEREF_AV
                       && o2->op_private != OPpDEREF_HV)
                    break;

                o2 = o2->op_next;
                if (o2->op_type == OP_RV2AV) {
                    action = MDEREF_AV_padsv_vivify_rv2av_aelem;
                    goto do_deref;
                }
                if (o2->op_type == OP_RV2HV) {
                    action = MDEREF_HV_padsv_vivify_rv2hv_helem;
                    goto do_deref;
                }
                break;

            case OP_PADAV:
            case OP_PADHV:
                /*    $lex[..]:  padav[@@lex:1,2] sR *
                 * or $lex{..}:  padhv[%lex:1,2] sR */
                ASSUME(!(o2->op_flags & ~(OPf_WANT|OPf_MOD|OPf_PARENS|
                                            OPf_REF|OPf_SPECIAL)));
                if ((o2->op_flags &
                        (OPf_WANT|OPf_REF|OPf_MOD|OPf_SPECIAL))
                     != (OPf_WANT_SCALAR|OPf_REF))
                    break;
                if (o2->op_flags != (OPf_WANT_SCALAR|OPf_REF))
                    break;
                /* OPf_PARENS isn't currently used in this case;
                 * if that changes, let us know! */
                ASSUME(!(o2->op_flags & OPf_PARENS));

                /* at this point, we wouldn't expect any of the remaining
                 * possible private flags:
                 * OPpPAD_STATE, OPpLVAL_INTRO, OPpTRUEBOOL,
                 * OPpMAYBE_TRUEBOOL, OPpMAYBE_LVSUB
                 *
                 * OPpSLICEWARNING shouldn't affect runtime
                 */
                ASSUME(!(o2->op_private & ~(OPpSLICEWARNING)));

                action = o2->op_type == OP_PADAV
                            ? MDEREF_AV_padav_aelem
                            : MDEREF_HV_padhv_helem;
                o2 = o2->op_next;
                S_maybe_multideref(aTHX_ o, o2, action, 0);
                break;


            case OP_RV2AV:
            case OP_RV2HV:
                action = o2->op_type == OP_RV2AV
                            ? MDEREF_AV_pop_rv2av_aelem
                            : MDEREF_HV_pop_rv2hv_helem;
                /* FALLTHROUGH */
            do_deref:
                /* (expr)->[...]:  rv2av sKR/1;
                 * (expr)->{...}:  rv2hv sKR/1; */

                ASSUME(o2->op_type == OP_RV2AV || o2->op_type == OP_RV2HV);

                ASSUME(!(o2->op_flags & ~(OPf_WANT|OPf_KIDS|OPf_PARENS
                                |OPf_REF|OPf_MOD|OPf_STACKED|OPf_SPECIAL)));
                if (o2->op_flags != (OPf_WANT_SCALAR|OPf_KIDS|OPf_REF))
                    break;

                /* at this point, we wouldn't expect any of these
                 * possible private flags:
                 * OPpMAYBE_LVSUB, OPpLVAL_INTRO
                 * OPpTRUEBOOL, OPpMAYBE_TRUEBOOL, (rv2hv only)
                 */
                ASSUME(!(o2->op_private &
                    ~(OPpHINT_STRICT_REFS|OPpARG1_MASK|OPpSLICEWARNING
                     |OPpOUR_INTRO)));
                hints |= (o2->op_private & OPpHINT_STRICT_REFS);

                o2 = o2->op_next;

                S_maybe_multideref(aTHX_ o, o2, action, hints);
                break;

            default:
                break;
            }
        }


	switch (o->op_type) {
	case OP_DBSTATE:
	    PL_curcop = ((COP*)o);		/* for warnings */
	    break;
	case OP_NEXTSTATE:
	    PL_curcop = ((COP*)o);		/* for warnings */

	    /* Optimise a "return ..." at the end of a sub to just be "...".
	     * This saves 2 ops. Before:
	     * 1  <;> nextstate(main 1 -e:1) v ->2
	     * 4  <@@> return K ->5
	     * 2    <0> pushmark s ->3
	     * -    <1> ex-rv2sv sK/1 ->4
	     * 3      <#> gvsv[*cat] s ->4
	     *
	     * After:
	     * -  <@@> return K ->-
	     * -    <0> pushmark s ->2
	     * -    <1> ex-rv2sv sK/1 ->-
	     * 2      <$> gvsv(*cat) s ->3
	     */
	    {
		OP *next = o->op_next;
		OP *sibling = OpSIBLING(o);
		if (   OP_TYPE_IS(next, OP_PUSHMARK)
		    && OP_TYPE_IS(sibling, OP_RETURN)
		    && OP_TYPE_IS(sibling->op_next, OP_LINESEQ)
		    && ( OP_TYPE_IS(sibling->op_next->op_next, OP_LEAVESUB)
		       ||OP_TYPE_IS(sibling->op_next->op_next,
				    OP_LEAVESUBLV))
		    && cUNOPx(sibling)->op_first == next
		    && OpHAS_SIBLING(next) && OpSIBLING(next)->op_next
		    && next->op_next
		) {
		    /* Look through the PUSHMARK's siblings for one that
		     * points to the RETURN */
		    OP *top = OpSIBLING(next);
		    while (top && top->op_next) {
			if (top->op_next == sibling) {
			    top->op_next = sibling->op_next;
			    o->op_next = next->op_next;
			    break;
			}
			top = OpSIBLING(top);
		    }
		}
	    }

	    /* Optimise 'my $x; my $y;' into 'my ($x, $y);'
             *
	     * This latter form is then suitable for conversion into padrange
	     * later on. Convert:
	     *
	     *   nextstate1 -> padop1 -> nextstate2 -> padop2 -> nextstate3
	     *
	     * into:
	     *
	     *   nextstate1 ->     listop     -> nextstate3
	     *                 /            \
	     *         pushmark -> padop1 -> padop2
	     */
	    if (o->op_next && (
		    o->op_next->op_type == OP_PADSV
		 || o->op_next->op_type == OP_PADAV
		 || o->op_next->op_type == OP_PADHV
		)
		&& !(o->op_next->op_private & ~OPpLVAL_INTRO)
		&& o->op_next->op_next && o->op_next->op_next->op_type == OP_NEXTSTATE
		&& o->op_next->op_next->op_next && (
		    o->op_next->op_next->op_next->op_type == OP_PADSV
		 || o->op_next->op_next->op_next->op_type == OP_PADAV
		 || o->op_next->op_next->op_next->op_type == OP_PADHV
		)
		&& !(o->op_next->op_next->op_next->op_private & ~OPpLVAL_INTRO)
		&& o->op_next->op_next->op_next->op_next && o->op_next->op_next->op_next->op_next->op_type == OP_NEXTSTATE
		&& (!CopLABEL((COP*)o)) /* Don't mess with labels */
		&& (!CopLABEL((COP*)o->op_next->op_next)) /* ... */
	    ) {
		OP *pad1, *ns2, *pad2, *ns3, *newop, *newpm;

		pad1 =    o->op_next;
		ns2  = pad1->op_next;
		pad2 =  ns2->op_next;
		ns3  = pad2->op_next;

                /* we assume here that the op_next chain is the same as
                 * the op_sibling chain */
                assert(OpSIBLING(o)    == pad1);
                assert(OpSIBLING(pad1) == ns2);
                assert(OpSIBLING(ns2)  == pad2);
                assert(OpSIBLING(pad2) == ns3);

                /* excise and delete ns2 */
                op_sibling_splice(NULL, pad1, 1, NULL);
                op_free(ns2);

                /* excise pad1 and pad2 */
                op_sibling_splice(NULL, o, 2, NULL);

                /* create new listop, with children consisting of:
                 * a new pushmark, pad1, pad2. */
		newop = newLISTOP(OP_LIST, 0, pad1, pad2);
		newop->op_flags |= OPf_PARENS;
		newop->op_flags = (newop->op_flags & ~OPf_WANT) | OPf_WANT_VOID;

                /* insert newop between o and ns3 */
                op_sibling_splice(NULL, o, 0, newop);

                /*fixup op_next chain */
                newpm = cUNOPx(newop)->op_first; /* pushmark */
		o    ->op_next = newpm;
		newpm->op_next = pad1;
		pad1 ->op_next = pad2;
		pad2 ->op_next = newop; /* listop */
		newop->op_next = ns3;

		/* Ensure pushmark has this flag if padops do */
		if (pad1->op_flags & OPf_MOD && pad2->op_flags & OPf_MOD) {
		    newpm->op_flags |= OPf_MOD;
		}

		break;
	    }

	    /* Two NEXTSTATEs in a row serve no purpose. Except if they happen
	       to carry two labels. For now, take the easier option, and skip
	       this optimisation if the first NEXTSTATE has a label.  */
	    if (!CopLABEL((COP*)o) && !PERLDB_NOOPT) {
		OP *nextop = o->op_next;
		while (nextop && nextop->op_type == OP_NULL)
		    nextop = nextop->op_next;

		if (nextop && (nextop->op_type == OP_NEXTSTATE)) {
		    op_null(o);
		    if (oldop)
			oldop->op_next = nextop;
                    o = nextop;
		    /* Skip (old)oldop assignment since the current oldop's
		       op_next already points to the next op.  */
		    goto redo;
		}
	    }
	    break;

	case OP_CONCAT:
	    if (o->op_next && o->op_next->op_type == OP_STRINGIFY) {
		if (o->op_next->op_private & OPpTARGET_MY) {
		    if (o->op_flags & OPf_STACKED) /* chained concats */
			break; /* ignore_optimization */
		    else {
			/* assert(PL_opargs[o->op_type] & OA_TARGLEX); */
			o->op_targ = o->op_next->op_targ;
			o->op_next->op_targ = 0;
			o->op_private |= OPpTARGET_MY;
		    }
		}
		op_null(o->op_next);
	    }
	    break;
	case OP_STUB:
	    if ((o->op_flags & OPf_WANT) != OPf_WANT_LIST) {
		break; /* Scalar stub must produce undef.  List stub is noop */
	    }
	    goto nothin;
	case OP_NULL:
	    if (o->op_targ == OP_NEXTSTATE
		|| o->op_targ == OP_DBSTATE)
	    {
		PL_curcop = ((COP*)o);
	    }
	    /* XXX: We avoid setting op_seq here to prevent later calls
	       to rpeep() from mistakenly concluding that optimisation
	       has already occurred. This doesn't fix the real problem,
	       though (See 20010220.007). AMS 20010719 */
	    /* op_seq functionality is now replaced by op_opt */
	    o->op_opt = 0;
	    /* FALLTHROUGH */
	case OP_SCALAR:
	case OP_LINESEQ:
	case OP_SCOPE:
	nothin:
	    if (oldop) {
		oldop->op_next = o->op_next;
		o->op_opt = 0;
		continue;
	    }
	    break;

        case OP_PUSHMARK:

            /* Given
                 5 repeat/DOLIST
                 3   ex-list
                 1     pushmark
                 2     scalar or const
                 4   const[0]
               convert repeat into a stub with no kids.
             */
            if (o->op_next->op_type == OP_CONST
             || (  o->op_next->op_type == OP_PADSV
                && !(o->op_next->op_private & OPpLVAL_INTRO))
             || (  o->op_next->op_type == OP_GV
                && o->op_next->op_next->op_type == OP_RV2SV
                && !(o->op_next->op_next->op_private
                        & (OPpLVAL_INTRO|OPpOUR_INTRO))))
            {
                const OP *kid = o->op_next->op_next;
                if (o->op_next->op_type == OP_GV)
                   kid = kid->op_next;
                /* kid is now the ex-list.  */
                if (kid->op_type == OP_NULL
                 && (kid = kid->op_next)->op_type == OP_CONST
                    /* kid is now the repeat count.  */
                 && kid->op_next->op_type == OP_REPEAT
                 && kid->op_next->op_private & OPpREPEAT_DOLIST
                 && (kid->op_next->op_flags & OPf_WANT) == OPf_WANT_LIST
                 && SvIOK(kSVOP_sv) && SvIVX(kSVOP_sv) == 0)
                {
                    o = kid->op_next; /* repeat */
                    assert(oldop);
                    oldop->op_next = o;
                    op_free(cBINOPo->op_first);
                    op_free(cBINOPo->op_last );
                    o->op_flags &=~ OPf_KIDS;
                    /* stub is a baseop; repeat is a binop */
                    STATIC_ASSERT_STMT(sizeof(OP) <= sizeof(BINOP));
                    OpTYPE_set(o, OP_STUB);
                    o->op_private = 0;
                    break;
                }
            }

            /* Convert a series of PAD ops for my vars plus support into a
             * single padrange op. Basically
             *
             *    pushmark -> pad[ahs]v -> pad[ahs]?v -> ... -> (list) -> rest
             *
             * becomes, depending on circumstances, one of
             *
             *    padrange  ----------------------------------> (list) -> rest
             *    padrange  --------------------------------------------> rest
             *
             * where all the pad indexes are sequential and of the same type
             * (INTRO or not).
             * We convert the pushmark into a padrange op, then skip
             * any other pad ops, and possibly some trailing ops.
             * Note that we don't null() the skipped ops, to make it
             * easier for Deparse to undo this optimisation (and none of
             * the skipped ops are holding any resourses). It also makes
             * it easier for find_uninit_var(), as it can just ignore
             * padrange, and examine the original pad ops.
             */
        {
            OP *p;
            OP *followop = NULL; /* the op that will follow the padrange op */
            U8 count = 0;
            U8 intro = 0;
            PADOFFSET base = 0; /* init only to stop compiler whining */
            bool gvoid = 0;     /* init only to stop compiler whining */
            bool defav = 0;  /* seen (...) = @@_ */
            bool reuse = 0;  /* reuse an existing padrange op */

            /* look for a pushmark -> gv[_] -> rv2av */

            {
                OP *rv2av, *q;
                p = o->op_next;
                if (   p->op_type == OP_GV
                    && cGVOPx_gv(p) == PL_defgv
                    && (rv2av = p->op_next)
                    && rv2av->op_type == OP_RV2AV
                    && !(rv2av->op_flags & OPf_REF)
                    && !(rv2av->op_private & (OPpLVAL_INTRO|OPpMAYBE_LVSUB))
                    && ((rv2av->op_flags & OPf_WANT) == OPf_WANT_LIST)
                ) {
                    q = rv2av->op_next;
                    if (q->op_type == OP_NULL)
                        q = q->op_next;
                    if (q->op_type == OP_PUSHMARK) {
                        defav = 1;
                        p = q;
                    }
                }
            }
            if (!defav) {
                p = o;
            }

            /* scan for PAD ops */

            for (p = p->op_next; p; p = p->op_next) {
                if (p->op_type == OP_NULL)
                    continue;

                if ((     p->op_type != OP_PADSV
                       && p->op_type != OP_PADAV
                       && p->op_type != OP_PADHV
                    )
                      /* any private flag other than INTRO? e.g. STATE */
                   || (p->op_private & ~OPpLVAL_INTRO)
                )
                    break;

                /* let $a[N] potentially be optimised into AELEMFAST_LEX
                 * instead */
                if (   p->op_type == OP_PADAV
                    && p->op_next
                    && p->op_next->op_type == OP_CONST
                    && p->op_next->op_next
                    && p->op_next->op_next->op_type == OP_AELEM
                )
                    break;

                /* for 1st padop, note what type it is and the range
                 * start; for the others, check that it's the same type
                 * and that the targs are contiguous */
                if (count == 0) {
                    intro = (p->op_private & OPpLVAL_INTRO);
                    base = p->op_targ;
                    gvoid = OP_GIMME(p,0) == G_VOID;
                }
                else {
                    if ((p->op_private & OPpLVAL_INTRO) != intro)
                        break;
                    /* Note that you'd normally  expect targs to be
                     * contiguous in my($a,$b,$c), but that's not the case
                     * when external modules start doing things, e.g.
                     * Function::Parameters */
                    if (p->op_targ != base + count)
                        break;
                    assert(p->op_targ == base + count);
                    /* Either all the padops or none of the padops should
                       be in void context.  Since we only do the optimisa-
                       tion for av/hv when the aggregate itself is pushed
                       on to the stack (one item), there is no need to dis-
                       tinguish list from scalar context.  */
                    if (gvoid != (OP_GIMME(p,0) == G_VOID))
                        break;
                }

                /* for AV, HV, only when we're not flattening */
                if (   p->op_type != OP_PADSV
                    && !gvoid
                    && !(p->op_flags & OPf_REF)
                )
                    break;

                if (count >= OPpPADRANGE_COUNTMASK)
                    break;

                /* there's a biggest base we can fit into a
                 * SAVEt_CLEARPADRANGE in pp_padrange.
                 * (The sizeof() stuff will be constant-folded, and is
                 * intended to avoid getting "comparison is always false"
                 * compiler warnings. See the comments above
                 * MEM_WRAP_CHECK for more explanation on why we do this
                 * in a weird way to avoid compiler warnings.)
                 */
                if (   intro
                    && (8*sizeof(base) >
                        8*sizeof(UV)-OPpPADRANGE_COUNTSHIFT-SAVE_TIGHT_SHIFT
                        ? base
                        : (UV_MAX >> (OPpPADRANGE_COUNTSHIFT+SAVE_TIGHT_SHIFT))
                        ) >
                        (UV_MAX >> (OPpPADRANGE_COUNTSHIFT+SAVE_TIGHT_SHIFT))
                )
                    break;

                /* Success! We've got another valid pad op to optimise away */
                count++;
                followop = p->op_next;
            }

            if (count < 1 || (count == 1 && !defav))
                break;

            /* pp_padrange in specifically compile-time void context
             * skips pushing a mark and lexicals; in all other contexts
             * (including unknown till runtime) it pushes a mark and the
             * lexicals. We must be very careful then, that the ops we
             * optimise away would have exactly the same effect as the
             * padrange.
             * In particular in void context, we can only optimise to
             * a padrange if we see the complete sequence
             *     pushmark, pad*v, ...., list
             * which has the net effect of leaving the markstack as it
             * was.  Not pushing onto the stack (whereas padsv does touch
             * the stack) makes no difference in void context.
             */
            assert(followop);
            if (gvoid) {
                if (followop->op_type == OP_LIST
                        && OP_GIMME(followop,0) == G_VOID
                   )
                {
                    followop = followop->op_next; /* skip OP_LIST */

                    /* consolidate two successive my(...);'s */

                    if (   oldoldop
                        && oldoldop->op_type == OP_PADRANGE
                        && (oldoldop->op_flags & OPf_WANT) == OPf_WANT_VOID
                        && (oldoldop->op_private & OPpLVAL_INTRO) == intro
                        && !(oldoldop->op_flags & OPf_SPECIAL)
                    ) {
                        U8 old_count;
                        assert(oldoldop->op_next == oldop);
                        assert(   oldop->op_type == OP_NEXTSTATE
                               || oldop->op_type == OP_DBSTATE);
                        assert(oldop->op_next == o);

                        old_count
                            = (oldoldop->op_private & OPpPADRANGE_COUNTMASK);

                       /* Do not assume pad offsets for $c and $d are con-
                          tiguous in
                            my ($a,$b,$c);
                            my ($d,$e,$f);
                        */
                        if (  oldoldop->op_targ + old_count == base
                           && old_count < OPpPADRANGE_COUNTMASK - count) {
                            base = oldoldop->op_targ;
                            count += old_count;
                            reuse = 1;
                        }
                    }

                    /* if there's any immediately following singleton
                     * my var's; then swallow them and the associated
                     * nextstates; i.e.
                     *    my ($a,$b); my $c; my $d;
                     * is treated as
                     *    my ($a,$b,$c,$d);
                     */

                    while (    ((p = followop->op_next))
                            && (  p->op_type == OP_PADSV
                               || p->op_type == OP_PADAV
                               || p->op_type == OP_PADHV)
                            && (p->op_flags & OPf_WANT) == OPf_WANT_VOID
                            && (p->op_private & OPpLVAL_INTRO) == intro
                            && !(p->op_private & ~OPpLVAL_INTRO)
                            && p->op_next
                            && (   p->op_next->op_type == OP_NEXTSTATE
                                || p->op_next->op_type == OP_DBSTATE)
                            && count < OPpPADRANGE_COUNTMASK
                            && base + count == p->op_targ
                    ) {
                        count++;
                        followop = p->op_next;
                    }
                }
                else
                    break;
            }

            if (reuse) {
                assert(oldoldop->op_type == OP_PADRANGE);
                oldoldop->op_next = followop;
                oldoldop->op_private = (intro | count);
                o = oldoldop;
                oldop = NULL;
                oldoldop = NULL;
            }
            else {
                /* Convert the pushmark into a padrange.
                 * To make Deparse easier, we guarantee that a padrange was
                 * *always* formerly a pushmark */
                assert(o->op_type == OP_PUSHMARK);
                o->op_next = followop;
                OpTYPE_set(o, OP_PADRANGE);
                o->op_targ = base;
                /* bit 7: INTRO; bit 6..0: count */
                o->op_private = (intro | count);
                o->op_flags = ((o->op_flags & ~(OPf_WANT|OPf_SPECIAL))
                              | gvoid * OPf_WANT_VOID
                              | (defav ? OPf_SPECIAL : 0));
            }
            break;
        }

	case OP_PADAV:
	case OP_PADSV:
	case OP_PADHV:
	/* Skip over state($x) in void context.  */
	if (oldop && o->op_private == (OPpPAD_STATE|OPpLVAL_INTRO)
	 && (o->op_flags & OPf_WANT) == OPf_WANT_VOID)
	{
	    oldop->op_next = o->op_next;
	    goto redo_nextstate;
	}
	if (o->op_type != OP_PADAV)
	    break;
	/* FALLTHROUGH */
	case OP_GV:
	    if (o->op_type == OP_PADAV || o->op_next->op_type == OP_RV2AV) {
		OP* const pop = (o->op_type == OP_PADAV) ?
			    o->op_next : o->op_next->op_next;
		IV i;
		if (pop && pop->op_type == OP_CONST &&
		    ((PL_op = pop->op_next)) &&
		    pop->op_next->op_type == OP_AELEM &&
		    !(pop->op_next->op_private &
		      (OPpLVAL_INTRO|OPpLVAL_DEFER|OPpDEREF|OPpMAYBE_LVSUB)) &&
		    (i = SvIV(((SVOP*)pop)->op_sv)) >= -128 && i <= 127)
		{
		    GV *gv;
		    if (cSVOPx(pop)->op_private & OPpCONST_STRICT)
			no_bareword_allowed(pop);
		    if (o->op_type == OP_GV)
			op_null(o->op_next);
		    op_null(pop->op_next);
		    op_null(pop);
		    o->op_flags |= pop->op_next->op_flags & OPf_MOD;
		    o->op_next = pop->op_next->op_next;
		    o->op_ppaddr = PL_ppaddr[OP_AELEMFAST];
		    o->op_private = (U8)i;
		    if (o->op_type == OP_GV) {
			gv = cGVOPo_gv;
			GvAVn(gv);
			o->op_type = OP_AELEMFAST;
		    }
		    else
			o->op_type = OP_AELEMFAST_LEX;
		}
		if (o->op_type != OP_GV)
		    break;
	    }

	    /* Remove $foo from the op_next chain in void context.  */
	    if (oldop
	     && (  o->op_next->op_type == OP_RV2SV
		|| o->op_next->op_type == OP_RV2AV
		|| o->op_next->op_type == OP_RV2HV  )
	     && (o->op_next->op_flags & OPf_WANT) == OPf_WANT_VOID
	     && !(o->op_next->op_private & OPpLVAL_INTRO))
	    {
		oldop->op_next = o->op_next->op_next;
		/* Reprocess the previous op if it is a nextstate, to
		   allow double-nextstate optimisation.  */
	      redo_nextstate:
		if (oldop->op_type == OP_NEXTSTATE) {
		    oldop->op_opt = 0;
		    o = oldop;
		    oldop = oldoldop;
		    oldoldop = NULL;
		    goto redo;
		}
		o = oldop->op_next;
                goto redo;
	    }
	    else if (o->op_next->op_type == OP_RV2SV) {
		if (!(o->op_next->op_private & OPpDEREF)) {
		    op_null(o->op_next);
		    o->op_private |= o->op_next->op_private & (OPpLVAL_INTRO
							       | OPpOUR_INTRO);
		    o->op_next = o->op_next->op_next;
                    OpTYPE_set(o, OP_GVSV);
		}
	    }
	    else if (o->op_next->op_type == OP_READLINE
		    && o->op_next->op_next->op_type == OP_CONCAT
		    && (o->op_next->op_next->op_flags & OPf_STACKED))
	    {
		/* Turn "$a .= <FH>" into an OP_RCATLINE. AMS 20010917 */
                OpTYPE_set(o, OP_RCATLINE);
		o->op_flags |= OPf_STACKED;
		op_null(o->op_next->op_next);
		op_null(o->op_next);
	    }

	    break;
        
#define HV_OR_SCALARHV(op)                                   \
    (  (op)->op_type == OP_PADHV || (op)->op_type == OP_RV2HV \
       ? (op)                                                  \
       : (op)->op_type == OP_SCALAR && (op)->op_flags & OPf_KIDS \
       && (  cUNOPx(op)->op_first->op_type == OP_PADHV          \
          || cUNOPx(op)->op_first->op_type == OP_RV2HV)          \
         ? cUNOPx(op)->op_first                                   \
         : NULL)

        case OP_NOT:
            if ((fop = HV_OR_SCALARHV(cUNOP->op_first)))
                fop->op_private |= OPpTRUEBOOL;
            break;

        case OP_AND:
	case OP_OR:
	case OP_DOR:
            fop = cLOGOP->op_first;
            sop = OpSIBLING(fop);
	    while (cLOGOP->op_other->op_type == OP_NULL)
		cLOGOP->op_other = cLOGOP->op_other->op_next;
	    while (o->op_next && (   o->op_type == o->op_next->op_type
				  || o->op_next->op_type == OP_NULL))
		o->op_next = o->op_next->op_next;

	    /* If we're an OR and our next is an AND in void context, we'll
	       follow its op_other on short circuit, same for reverse.
	       We can't do this with OP_DOR since if it's true, its return
	       value is the underlying value which must be evaluated
	       by the next op. */
	    if (o->op_next &&
	        (
		    (IS_AND_OP(o) && IS_OR_OP(o->op_next))
	         || (IS_OR_OP(o) && IS_AND_OP(o->op_next))
	        )
	        && (o->op_next->op_flags & OPf_WANT) == OPf_WANT_VOID
	    ) {
	        o->op_next = ((LOGOP*)o->op_next)->op_other;
	    }
	    DEFER(cLOGOP->op_other);
          
	    o->op_opt = 1;
            fop = HV_OR_SCALARHV(fop);
            if (sop) sop = HV_OR_SCALARHV(sop);
            if (fop || sop
            ){	
                OP * nop = o;
                OP * lop = o;
                if (!((nop->op_flags & OPf_WANT) == OPf_WANT_VOID)) {
                    while (nop && nop->op_next) {
                        switch (nop->op_next->op_type) {
                            case OP_NOT:
                            case OP_AND:
                            case OP_OR:
                            case OP_DOR:
                                lop = nop = nop->op_next;
                                break;
                            case OP_NULL:
                                nop = nop->op_next;
                                break;
                            default:
                                nop = NULL;
                                break;
                        }
                    }            
                }
                if (fop) {
                    if (  (lop->op_flags & OPf_WANT) == OPf_WANT_VOID
                      || o->op_type == OP_AND  )
                        fop->op_private |= OPpTRUEBOOL;
                    else if (!(lop->op_flags & OPf_WANT))
                        fop->op_private |= OPpMAYBE_TRUEBOOL;
                }
                if (  (lop->op_flags & OPf_WANT) == OPf_WANT_VOID
                   && sop)
                    sop->op_private |= OPpTRUEBOOL;
            }                  
            
	    
	    break;
	
	case OP_COND_EXPR:
	    if ((fop = HV_OR_SCALARHV(cLOGOP->op_first)))
		fop->op_private |= OPpTRUEBOOL;
#undef HV_OR_SCALARHV
	    /* GERONIMO! */ /* FALLTHROUGH */

	case OP_MAPWHILE:
	case OP_GREPWHILE:
	case OP_ANDASSIGN:
	case OP_ORASSIGN:
	case OP_DORASSIGN:
	case OP_RANGE:
	case OP_ONCE:
	    while (cLOGOP->op_other->op_type == OP_NULL)
		cLOGOP->op_other = cLOGOP->op_other->op_next;
	    DEFER(cLOGOP->op_other);
	    break;

	case OP_ENTERLOOP:
	case OP_ENTERITER:
	    while (cLOOP->op_redoop->op_type == OP_NULL)
		cLOOP->op_redoop = cLOOP->op_redoop->op_next;
	    while (cLOOP->op_nextop->op_type == OP_NULL)
		cLOOP->op_nextop = cLOOP->op_nextop->op_next;
	    while (cLOOP->op_lastop->op_type == OP_NULL)
		cLOOP->op_lastop = cLOOP->op_lastop->op_next;
	    /* a while(1) loop doesn't have an op_next that escapes the
	     * loop, so we have to explicitly follow the op_lastop to
	     * process the rest of the code */
	    DEFER(cLOOP->op_lastop);
	    break;

        case OP_ENTERTRY:
	    assert(cLOGOPo->op_other->op_type == OP_LEAVETRY);
	    DEFER(cLOGOPo->op_other);
	    break;

	case OP_SUBST:
	    assert(!(cPMOP->op_pmflags & PMf_ONCE));
	    while (cPMOP->op_pmstashstartu.op_pmreplstart &&
		   cPMOP->op_pmstashstartu.op_pmreplstart->op_type == OP_NULL)
		cPMOP->op_pmstashstartu.op_pmreplstart
		    = cPMOP->op_pmstashstartu.op_pmreplstart->op_next;
	    DEFER(cPMOP->op_pmstashstartu.op_pmreplstart);
	    break;

	case OP_SORT: {
	    OP *oright;

	    if (o->op_flags & OPf_SPECIAL) {
                /* first arg is a code block */
                OP * const nullop = OpSIBLING(cLISTOP->op_first);
                OP * kid          = cUNOPx(nullop)->op_first;

                assert(nullop->op_type == OP_NULL);
		assert(kid->op_type == OP_SCOPE
		 || (kid->op_type == OP_NULL && kid->op_targ == OP_LEAVE));
                /* since OP_SORT doesn't have a handy op_other-style
                 * field that can point directly to the start of the code
                 * block, store it in the otherwise-unused op_next field
                 * of the top-level OP_NULL. This will be quicker at
                 * run-time, and it will also allow us to remove leading
                 * OP_NULLs by just messing with op_nexts without
                 * altering the basic op_first/op_sibling layout. */
                kid = kLISTOP->op_first;
                assert(
                      (kid->op_type == OP_NULL
                      && (  kid->op_targ == OP_NEXTSTATE
                         || kid->op_targ == OP_DBSTATE  ))
                    || kid->op_type == OP_STUB
                    || kid->op_type == OP_ENTER);
                nullop->op_next = kLISTOP->op_next;
                DEFER(nullop->op_next);
	    }

	    /* check that RHS of sort is a single plain array */
	    oright = cUNOPo->op_first;
	    if (!oright || oright->op_type != OP_PUSHMARK)
		break;

	    if (o->op_private & OPpSORT_INPLACE)
		break;

	    /* reverse sort ... can be optimised.  */
	    if (!OpHAS_SIBLING(cUNOPo)) {
		/* Nothing follows us on the list. */
		OP * const reverse = o->op_next;

		if (reverse->op_type == OP_REVERSE &&
		    (reverse->op_flags & OPf_WANT) == OPf_WANT_LIST) {
		    OP * const pushmark = cUNOPx(reverse)->op_first;
		    if (pushmark && (pushmark->op_type == OP_PUSHMARK)
			&& (OpSIBLING(cUNOPx(pushmark)) == o)) {
			/* reverse -> pushmark -> sort */
			o->op_private |= OPpSORT_REVERSE;
			op_null(reverse);
			pushmark->op_next = oright->op_next;
			op_null(oright);
		    }
		}
	    }

	    break;
	}

	case OP_REVERSE: {
	    OP *ourmark, *theirmark, *ourlast, *iter, *expushmark, *rv2av;
	    OP *gvop = NULL;
	    LISTOP *enter, *exlist;

	    if (o->op_private & OPpSORT_INPLACE)
		break;

	    enter = (LISTOP *) o->op_next;
	    if (!enter)
		break;
	    if (enter->op_type == OP_NULL) {
		enter = (LISTOP *) enter->op_next;
		if (!enter)
		    break;
	    }
	    /* for $a (...) will have OP_GV then OP_RV2GV here.
	       for (...) just has an OP_GV.  */
	    if (enter->op_type == OP_GV) {
		gvop = (OP *) enter;
		enter = (LISTOP *) enter->op_next;
		if (!enter)
		    break;
		if (enter->op_type == OP_RV2GV) {
		  enter = (LISTOP *) enter->op_next;
		  if (!enter)
		    break;
		}
	    }

	    if (enter->op_type != OP_ENTERITER)
		break;

	    iter = enter->op_next;
	    if (!iter || iter->op_type != OP_ITER)
		break;
	    
	    expushmark = enter->op_first;
	    if (!expushmark || expushmark->op_type != OP_NULL
		|| expushmark->op_targ != OP_PUSHMARK)
		break;

	    exlist = (LISTOP *) OpSIBLING(expushmark);
	    if (!exlist || exlist->op_type != OP_NULL
		|| exlist->op_targ != OP_LIST)
		break;

	    if (exlist->op_last != o) {
		/* Mmm. Was expecting to point back to this op.  */
		break;
	    }
	    theirmark = exlist->op_first;
	    if (!theirmark || theirmark->op_type != OP_PUSHMARK)
		break;

	    if (OpSIBLING(theirmark) != o) {
		/* There's something between the mark and the reverse, eg
		   for (1, reverse (...))
		   so no go.  */
		break;
	    }

	    ourmark = ((LISTOP *)o)->op_first;
	    if (!ourmark || ourmark->op_type != OP_PUSHMARK)
		break;

	    ourlast = ((LISTOP *)o)->op_last;
	    if (!ourlast || ourlast->op_next != o)
		break;

	    rv2av = OpSIBLING(ourmark);
	    if (rv2av && rv2av->op_type == OP_RV2AV && !OpHAS_SIBLING(rv2av)
		&& rv2av->op_flags == (OPf_WANT_LIST | OPf_KIDS)) {
		/* We're just reversing a single array.  */
		rv2av->op_flags = OPf_WANT_SCALAR | OPf_KIDS | OPf_REF;
		enter->op_flags |= OPf_STACKED;
	    }

	    /* We don't have control over who points to theirmark, so sacrifice
	       ours.  */
	    theirmark->op_next = ourmark->op_next;
	    theirmark->op_flags = ourmark->op_flags;
	    ourlast->op_next = gvop ? gvop : (OP *) enter;
	    op_null(ourmark);
	    op_null(o);
	    enter->op_private |= OPpITER_REVERSED;
	    iter->op_private |= OPpITER_REVERSED;

            oldoldop = NULL;
            oldop    = ourlast;
            o        = oldop->op_next;
            goto redo;
	    
	    break;
	}

	case OP_QR:
	case OP_MATCH:
	    if (!(cPMOP->op_pmflags & PMf_ONCE)) {
		assert (!cPMOP->op_pmstashstartu.op_pmreplstart);
	    }
	    break;

	case OP_RUNCV:
	    if (!(o->op_private & OPpOFFBYONE) && !CvCLONE(PL_compcv)
	     && (!CvANON(PL_compcv) || (!PL_cv_has_eval && !PL_perldb)))
	    {
		SV *sv;
		if (CvEVAL(PL_compcv)) sv = &PL_sv_undef;
		else {
		    sv = newRV((SV *)PL_compcv);
		    sv_rvweaken(sv);
		    SvREADONLY_on(sv);
		}
                OpTYPE_set(o, OP_CONST);
		o->op_flags |= OPf_SPECIAL;
		cSVOPo->op_sv = sv;
	    }
	    break;

	case OP_SASSIGN:
	    if (OP_GIMME(o,0) == G_VOID
	     || (  o->op_next->op_type == OP_LINESEQ
		&& (  o->op_next->op_next->op_type == OP_LEAVESUB
		   || (  o->op_next->op_next->op_type == OP_RETURN
		      && !CvLVALUE(PL_compcv)))))
	    {
		OP *right = cBINOP->op_first;
		if (right) {
                    /*   sassign
                    *      RIGHT
                    *      substr
                    *         pushmark
                    *         arg1
                    *         arg2
                    *         ...
                    * becomes
                    *
                    *  ex-sassign
                    *     substr
                    *        pushmark
                    *        RIGHT
                    *        arg1
                    *        arg2
                    *        ...
                    */
		    OP *left = OpSIBLING(right);
		    if (left->op_type == OP_SUBSTR
			 && (left->op_private & 7) < 4) {
			op_null(o);
                        /* cut out right */
                        op_sibling_splice(o, NULL, 1, NULL);
                        /* and insert it as second child of OP_SUBSTR */
                        op_sibling_splice(left, cBINOPx(left)->op_first, 0,
                                    right);
			left->op_private |= OPpSUBSTR_REPL_FIRST;
			left->op_flags =
			    (o->op_flags & ~OPf_WANT) | OPf_WANT_VOID;
		    }
		}
	    }
	    break;

	case OP_AASSIGN: {
            int l, r, lr, lscalars, rscalars;

            /* handle common vars detection, e.g. ($a,$b) = ($b,$a).
               Note that we do this now rather than in newASSIGNOP(),
               since only by now are aliased lexicals flagged as such

               See the essay "Common vars in list assignment" above for
               the full details of the rationale behind all the conditions
               below.

               PL_generation sorcery:
               To detect whether there are common vars, the global var
               PL_generation is incremented for each assign op we scan.
               Then we run through all the lexical variables on the LHS,
               of the assignment, setting a spare slot in each of them to
               PL_generation.  Then we scan the RHS, and if any lexicals
               already have that value, we know we've got commonality.
               Also, if the generation number is already set to
               PERL_INT_MAX, then the variable is involved in aliasing, so
               we also have potential commonality in that case.
             */

            PL_generation++;
            /* scan LHS */
            lscalars = 0;
            l = S_aassign_scan(aTHX_ cLISTOPo->op_last,  FALSE, 1, &lscalars);
            /* scan RHS */
            rscalars = 0;
            r = S_aassign_scan(aTHX_ cLISTOPo->op_first, TRUE, 1, &rscalars);
            lr = (l|r);


            /* After looking for things which are *always* safe, this main
             * if/else chain selects primarily based on the type of the
             * LHS, gradually working its way down from the more dangerous
             * to the more restrictive and thus safer cases */

            if (   !l                      /* () = ....; */
                || !r                      /* .... = (); */
                || !(l & ~AAS_SAFE_SCALAR) /* (undef, pos()) = ...; */
                || !(r & ~AAS_SAFE_SCALAR) /* ... = (1,2,length,undef); */
                || (lscalars < 2)          /* ($x, undef) = ... */
            ) {
                NOOP; /* always safe */
            }
            else if (l & AAS_DANGEROUS) {
                /* always dangerous */
                o->op_private |= OPpASSIGN_COMMON_SCALAR;
                o->op_private |= OPpASSIGN_COMMON_AGG;
            }
            else if (l & (AAS_PKG_SCALAR|AAS_PKG_AGG)) {
                /* package vars are always dangerous - too many
                 * aliasing possibilities */
                if (l & AAS_PKG_SCALAR)
                    o->op_private |= OPpASSIGN_COMMON_SCALAR;
                if (l & AAS_PKG_AGG)
                    o->op_private |= OPpASSIGN_COMMON_AGG;
            }
            else if (l & ( AAS_MY_SCALAR|AAS_MY_AGG
                          |AAS_LEX_SCALAR|AAS_LEX_AGG))
            {
                /* LHS contains only lexicals and safe ops */

                if (l & (AAS_MY_AGG|AAS_LEX_AGG))
                    o->op_private |= OPpASSIGN_COMMON_AGG;

                if (l & (AAS_MY_SCALAR|AAS_LEX_SCALAR)) {
                    if (lr & AAS_LEX_SCALAR_COMM)
                        o->op_private |= OPpASSIGN_COMMON_SCALAR;
                    else if (   !(l & AAS_LEX_SCALAR)
                             && (r & AAS_DEFAV))
                    {
                        /* falsely mark
                         *    my (...) = @@_
                         * as scalar-safe for performance reasons.
                         * (it will still have been marked _AGG if necessary */
                        NOOP;
                    }
                    else if (r  & (AAS_PKG_SCALAR|AAS_PKG_AGG|AAS_DANGEROUS))
                        o->op_private |= OPpASSIGN_COMMON_RC1;
                }
            }

            /* ... = ($x)
             * may have to handle aggregate on LHS, but we can't
             * have common scalars. */
            if (rscalars < 2)
                o->op_private &=
                        ~(OPpASSIGN_COMMON_SCALAR|OPpASSIGN_COMMON_RC1);

	    break;
        }

	case OP_CUSTOM: {
	    Perl_cpeep_t cpeep = 
		XopENTRYCUSTOM(o, xop_peep);
	    if (cpeep)
		cpeep(aTHX_ o, oldop);
	    break;
	}
	    
	}
        /* did we just null the current op? If so, re-process it to handle
         * eliding "empty" ops from the chain */
        if (o->op_type == OP_NULL && oldop && oldop->op_next == o) {
            o->op_opt = 0;
            o = oldop;
        }
        else {
            oldoldop = oldop;
            oldop = o;
        }
    }
    LEAVE;
}

void
Perl_peep(pTHX_ OP *o)
{
    CALL_RPEEP(o);
}

/*
=head1 Custom Operators

=for apidoc Ao||custom_op_xop
Return the XOP structure for a given custom op.  This macro should be
considered internal to C<OP_NAME> and the other access macros: use them instead.
This macro does call a function.  Prior
to 5.19.6, this was implemented as a
function.

=cut
*/

XOPRETANY
Perl_custom_op_get_field(pTHX_ const OP *o, const xop_flags_enum field)
{
    SV *keysv;
    HE *he = NULL;
    XOP *xop;

    static const XOP xop_null = { 0, 0, 0, 0, 0 };

    PERL_ARGS_ASSERT_CUSTOM_OP_GET_FIELD;
    assert(o->op_type == OP_CUSTOM);

    /* This is wrong. It assumes a function pointer can be cast to IV,
     * which isn't guaranteed, but this is what the old custom OP code
     * did. In principle it should be safer to Copy the bytes of the
     * pointer into a PV: since the new interface is hidden behind
     * functions, this can be changed later if necessary.  */
    /* Change custom_op_xop if this ever happens */
    keysv = sv_2mortal(newSViv(PTR2IV(o->op_ppaddr)));

    if (PL_custom_ops)
	he = hv_fetch_ent(PL_custom_ops, keysv, 0, 0);

    /* assume noone will have just registered a desc */
    if (!he && PL_custom_op_names &&
	(he = hv_fetch_ent(PL_custom_op_names, keysv, 0, 0))
    ) {
	const char *pv;
	STRLEN l;

	/* XXX does all this need to be shared mem? */
	Newxz(xop, 1, XOP);
	pv = SvPV(HeVAL(he), l);
	XopENTRY_set(xop, xop_name, savepvn(pv, l));
	if (PL_custom_op_descs &&
	    (he = hv_fetch_ent(PL_custom_op_descs, keysv, 0, 0))
	) {
	    pv = SvPV(HeVAL(he), l);
	    XopENTRY_set(xop, xop_desc, savepvn(pv, l));
	}
	Perl_custom_op_register(aTHX_ o->op_ppaddr, xop);
    }
    else {
	if (!he)
	    xop = (XOP *)&xop_null;
	else
	    xop = INT2PTR(XOP *, SvIV(HeVAL(he)));
    }
    {
	XOPRETANY any;
	if(field == XOPe_xop_ptr) {
	    any.xop_ptr = xop;
	} else {
	    const U32 flags = XopFLAGS(xop);
	    if(flags & field) {
		switch(field) {
		case XOPe_xop_name:
		    any.xop_name = xop->xop_name;
		    break;
		case XOPe_xop_desc:
		    any.xop_desc = xop->xop_desc;
		    break;
		case XOPe_xop_class:
		    any.xop_class = xop->xop_class;
		    break;
		case XOPe_xop_peep:
		    any.xop_peep = xop->xop_peep;
		    break;
		default:
		    NOT_REACHED; /* NOTREACHED */
		    break;
		}
	    } else {
		switch(field) {
		case XOPe_xop_name:
		    any.xop_name = XOPd_xop_name;
		    break;
		case XOPe_xop_desc:
		    any.xop_desc = XOPd_xop_desc;
		    break;
		case XOPe_xop_class:
		    any.xop_class = XOPd_xop_class;
		    break;
		case XOPe_xop_peep:
		    any.xop_peep = XOPd_xop_peep;
		    break;
		default:
		    NOT_REACHED; /* NOTREACHED */
		    break;
		}
	    }
	}
        /* On some platforms (HP-UX, IA64) gcc emits a warning for this function:
         * op.c: In function 'Perl_custom_op_get_field':
         * op.c:...: warning: 'any.xop_name' may be used uninitialized in this function [-Wmaybe-uninitialized]
         * This is because on those platforms (with -DEBUGGING) NOT_REACHED
         * expands to assert(0), which expands to ((0) ? (void)0 :
         * __assert(...)), and gcc doesn't know that __assert can never return. */
	return any;
    }
}

/*
=for apidoc Ao||custom_op_register
Register a custom op.  See L<perlguts/"Custom Operators">.

=cut
*/

void
Perl_custom_op_register(pTHX_ Perl_ppaddr_t ppaddr, const XOP *xop)
{
    SV *keysv;

    PERL_ARGS_ASSERT_CUSTOM_OP_REGISTER;

    /* see the comment in custom_op_xop */
    keysv = sv_2mortal(newSViv(PTR2IV(ppaddr)));

    if (!PL_custom_ops)
	PL_custom_ops = newHV();

    if (!hv_store_ent(PL_custom_ops, keysv, newSViv(PTR2IV(xop)), 0))
	Perl_croak(aTHX_ "panic: can't register custom OP %s", xop->xop_name);
}

/*

=for apidoc core_prototype

This function assigns the prototype of the named core function to C<sv>, or
to a new mortal SV if C<sv> is C<NULL>.  It returns the modified C<sv>, or
C<NULL> if the core function has no prototype.  C<code> is a code as returned
by C<keyword()>.  It must not be equal to 0.

=cut
*/

SV *
Perl_core_prototype(pTHX_ SV *sv, const char *name, const int code,
                          int * const opnum)
{
    int i = 0, n = 0, seen_question = 0, defgv = 0;
    I32 oa;
#define MAX_ARGS_OP ((sizeof(I32) - 1) * 2)
    char str[ MAX_ARGS_OP * 2 + 2 ]; /* One ';', one '\0' */
    bool nullret = FALSE;

    PERL_ARGS_ASSERT_CORE_PROTOTYPE;

    assert (code);

    if (!sv) sv = sv_newmortal();

#define retsetpvs(x,y) sv_setpvs(sv, x); if(opnum) *opnum=(y); return sv

    switch (code < 0 ? -code : code) {
    case KEY_and   : case KEY_chop: case KEY_chomp:
    case KEY_cmp   : case KEY_defined: case KEY_delete: case KEY_exec  :
    case KEY_exists: case KEY_eq     : case KEY_ge    : case KEY_goto  :
    case KEY_grep  : case KEY_gt     : case KEY_last  : case KEY_le    :
    case KEY_lt    : case KEY_map    : case KEY_ne    : case KEY_next  :
    case KEY_or    : case KEY_print  : case KEY_printf: case KEY_qr    :
    case KEY_redo  : case KEY_require: case KEY_return: case KEY_say   :
    case KEY_select: case KEY_sort   : case KEY_split : case KEY_system:
    case KEY_x     : case KEY_xor    :
	if (!opnum) return NULL; nullret = TRUE; goto findopnum;
    case KEY_glob:    retsetpvs("_;", OP_GLOB);
    case KEY_keys:    retsetpvs("\\[%@@]", OP_KEYS);
    case KEY_values:  retsetpvs("\\[%@@]", OP_VALUES);
    case KEY_each:    retsetpvs("\\[%@@]", OP_EACH);
    case KEY_push:    retsetpvs("\\@@@@", OP_PUSH);
    case KEY_unshift: retsetpvs("\\@@@@", OP_UNSHIFT);
    case KEY_pop:     retsetpvs(";\\@@", OP_POP);
    case KEY_shift:   retsetpvs(";\\@@", OP_SHIFT);
    case KEY_pos:     retsetpvs(";\\[$*]", OP_POS);
    case KEY_splice:
	retsetpvs("\\@@;$$@@", OP_SPLICE);
    case KEY___FILE__: case KEY___LINE__: case KEY___PACKAGE__:
	retsetpvs("", 0);
    case KEY_evalbytes:
	name = "entereval"; break;
    case KEY_readpipe:
	name = "backtick";
    }

#undef retsetpvs

  findopnum:
    while (i < MAXO) {	/* The slow way. */
	if (strEQ(name, PL_op_name[i])
	    || strEQ(name, PL_op_desc[i]))
	{
	    if (nullret) { assert(opnum); *opnum = i; return NULL; }
	    goto found;
	}
	i++;
    }
    return NULL;
  found:
    defgv = PL_opargs[i] & OA_DEFGV;
    oa = PL_opargs[i] >> OASHIFT;
    while (oa) {
	if (oa & OA_OPTIONAL && !seen_question && (
	      !defgv || (oa & (OA_OPTIONAL - 1)) == OA_FILEREF
	)) {
	    seen_question = 1;
	    str[n++] = ';';
	}
	if ((oa & (OA_OPTIONAL - 1)) >= OA_AVREF
	    && (oa & (OA_OPTIONAL - 1)) <= OA_SCALARREF
	    /* But globs are already references (kinda) */
	    && (oa & (OA_OPTIONAL - 1)) != OA_FILEREF
	) {
	    str[n++] = '\\';
	}
	if ((oa & (OA_OPTIONAL - 1)) == OA_SCALARREF
	 && !scalar_mod_type(NULL, i)) {
	    str[n++] = '[';
	    str[n++] = '$';
	    str[n++] = '@@';
	    str[n++] = '%';
	    if (i == OP_LOCK || i == OP_UNDEF) str[n++] = '&';
	    str[n++] = '*';
	    str[n++] = ']';
	}
	else str[n++] = ("?$@@@@%&*$")[oa & (OA_OPTIONAL - 1)];
	if (oa & OA_OPTIONAL && defgv && str[n-1] == '$') {
	    str[n-1] = '_'; defgv = 0;
	}
	oa = oa >> 4;
    }
    if (code == -KEY_not || code == -KEY_getprotobynumber) str[n++] = ';';
    str[n++] = '\0';
    sv_setpvn(sv, str, n - 1);
    if (opnum) *opnum = i;
    return sv;
}

OP *
Perl_coresub_op(pTHX_ SV * const coreargssv, const int code,
                      const int opnum)
{
    OP * const argop = newSVOP(OP_COREARGS,0,coreargssv);
    OP *o;

    PERL_ARGS_ASSERT_CORESUB_OP;

    switch(opnum) {
    case 0:
	return op_append_elem(OP_LINESEQ,
	               argop,
	               newSLICEOP(0,
	                          newSVOP(OP_CONST, 0, newSViv(-code % 3)),
	                          newOP(OP_CALLER,0)
	               )
	       );
    case OP_SELECT: /* which represents OP_SSELECT as well */
	if (code)
	    return newCONDOP(
	                 0,
	                 newBINOP(OP_GT, 0,
	                          newAVREF(newGVOP(OP_GV, 0, PL_defgv)),
	                          newSVOP(OP_CONST, 0, newSVuv(1))
	                         ),
	                 coresub_op(newSVuv((UV)OP_SSELECT), 0,
	                            OP_SSELECT),
	                 coresub_op(coreargssv, 0, OP_SELECT)
	           );
	/* FALLTHROUGH */
    default:
	switch (PL_opargs[opnum] & OA_CLASS_MASK) {
	case OA_BASEOP:
	    return op_append_elem(
	                OP_LINESEQ, argop,
	                newOP(opnum,
	                      opnum == OP_WANTARRAY || opnum == OP_RUNCV
	                        ? OPpOFFBYONE << 8 : 0)
	           );
	case OA_BASEOP_OR_UNOP:
	    if (opnum == OP_ENTEREVAL) {
		o = newUNOP(OP_ENTEREVAL,OPpEVAL_COPHH<<8,argop);
		if (code == -KEY_evalbytes) o->op_private |= OPpEVAL_BYTES;
	    }
	    else o = newUNOP(opnum,0,argop);
	    if (opnum == OP_CALLER) o->op_private |= OPpOFFBYONE;
	    else {
	  onearg:
	      if (is_handle_constructor(o, 1))
		argop->op_private |= OPpCOREARGS_DEREF1;
	      if (scalar_mod_type(NULL, opnum))
		argop->op_private |= OPpCOREARGS_SCALARMOD;
	    }
	    return o;
	default:
	    o = op_convert_list(opnum,OPf_SPECIAL*(opnum == OP_GLOB),argop);
	    if (is_handle_constructor(o, 2))
		argop->op_private |= OPpCOREARGS_DEREF2;
	    if (opnum == OP_SUBSTR) {
		o->op_private |= OPpMAYBE_LVSUB;
		return o;
	    }
	    else goto onearg;
	}
    }
}

void
Perl_report_redefined_cv(pTHX_ const SV *name, const CV *old_cv,
			       SV * const *new_const_svp)
{
    const char *hvname;
    bool is_const = !!CvCONST(old_cv);
    SV *old_const_sv = is_const ? cv_const_sv(old_cv) : NULL;

    PERL_ARGS_ASSERT_REPORT_REDEFINED_CV;

    if (is_const && new_const_svp && old_const_sv == *new_const_svp)
	return;
	/* They are 2 constant subroutines generated from
	   the same constant. This probably means that
	   they are really the "same" proxy subroutine
	   instantiated in 2 places. Most likely this is
	   when a constant is exported twice.  Don't warn.
	*/
    if (
	(ckWARN(WARN_REDEFINE)
	 && !(
		CvGV(old_cv) && GvSTASH(CvGV(old_cv))
	     && HvNAMELEN(GvSTASH(CvGV(old_cv))) == 7
	     && (hvname = HvNAME(GvSTASH(CvGV(old_cv))),
		 strEQ(hvname, "autouse"))
	     )
	)
     || (is_const
	 && ckWARN_d(WARN_REDEFINE)
	 && (!new_const_svp || sv_cmp(old_const_sv, *new_const_svp))
	)
    )
	Perl_warner(aTHX_ packWARN(WARN_REDEFINE),
			  is_const
			    ? "Constant subroutine %"SVf" redefined"
			    : "Subroutine %"SVf" redefined",
			  SVfARG(name));
}

/*
=head1 Hook manipulation

These functions provide convenient and thread-safe means of manipulating
hook variables.

=cut
*/

/*
=for apidoc Am|void|wrap_op_checker|Optype opcode|Perl_check_t new_checker|Perl_check_t *old_checker_p

Puts a C function into the chain of check functions for a specified op
type.  This is the preferred way to manipulate the L</PL_check> array.
C<opcode> specifies which type of op is to be affected.  C<new_checker>
is a pointer to the C function that is to be added to that opcode's
check chain, and C<old_checker_p> points to the storage location where a
pointer to the next function in the chain will be stored.  The value of
C<new_pointer> is written into the L</PL_check> array, while the value
previously stored there is written to C<*old_checker_p>.

The function should be defined like this:

    static OP *new_checker(pTHX_ OP *op) { ... }

It is intended to be called in this manner:

    new_checker(aTHX_ op)

C<old_checker_p> should be defined like this:

    static Perl_check_t old_checker_p;

L</PL_check> is global to an entire process, and a module wishing to
hook op checking may find itself invoked more than once per process,
typically in different threads.  To handle that situation, this function
is idempotent.  The location C<*old_checker_p> must initially (once
per process) contain a null pointer.  A C variable of static duration
(declared at file scope, typically also marked C<static> to give
it internal linkage) will be implicitly initialised appropriately,
if it does not have an explicit initialiser.  This function will only
actually modify the check chain if it finds C<*old_checker_p> to be null.
This function is also thread safe on the small scale.  It uses appropriate
locking to avoid race conditions in accessing L</PL_check>.

When this function is called, the function referenced by C<new_checker>
must be ready to be called, except for C<*old_checker_p> being unfilled.
In a threading situation, C<new_checker> may be called immediately,
even before this function has returned.  C<*old_checker_p> will always
be appropriately set before C<new_checker> is called.  If C<new_checker>
decides not to do anything special with an op that it is given (which
is the usual case for most uses of op check hooking), it must chain the
check function referenced by C<*old_checker_p>.

If you want to influence compilation of calls to a specific subroutine,
then use L</cv_set_call_checker> rather than hooking checking of all
C<entersub> ops.

=cut
*/

void
Perl_wrap_op_checker(pTHX_ Optype opcode,
    Perl_check_t new_checker, Perl_check_t *old_checker_p)
{
    dVAR;

    PERL_UNUSED_CONTEXT;
    PERL_ARGS_ASSERT_WRAP_OP_CHECKER;
    if (*old_checker_p) return;
    OP_CHECK_MUTEX_LOCK;
    if (!*old_checker_p) {
	*old_checker_p = PL_check[opcode];
	PL_check[opcode] = new_checker;
    }
    OP_CHECK_MUTEX_UNLOCK;
}

#include "XSUB.h"

/* Efficient sub that returns a constant scalar value. */
static void
const_sv_xsub(pTHX_ CV* cv)
{
    dXSARGS;
    SV *const sv = MUTABLE_SV(XSANY.any_ptr);
    PERL_UNUSED_ARG(items);
    if (!sv) {
	XSRETURN(0);
    }
    EXTEND(sp, 1);
    ST(0) = sv;
    XSRETURN(1);
}

static void
const_av_xsub(pTHX_ CV* cv)
{
    dXSARGS;
    AV * const av = MUTABLE_AV(XSANY.any_ptr);
    SP -= items;
    assert(av);
#ifndef DEBUGGING
    if (!av) {
	XSRETURN(0);
    }
#endif
    if (SvRMAGICAL(av))
	Perl_croak(aTHX_ "Magical list constants are not supported");
    if (GIMME_V != G_ARRAY) {
	EXTEND(SP, 1);
	ST(0) = sv_2mortal(newSViv((IV)AvFILLp(av)+1));
	XSRETURN(1);
    }
    EXTEND(SP, AvFILLp(av)+1);
    Copy(AvARRAY(av), &ST(0), AvFILLp(av)+1, SV *);
    XSRETURN(AvFILLp(av)+1);
}

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
@


1.20
log
@Update to perl 5.20.3

OK bluhm@@
@
text
@d112 19
d137 1
a137 1
S_prune_chain_head(pTHX_ OP** op_p)
d185 4
a201 1
    dVAR;
d216 4
a219 1
	return PerlMemShared_calloc(1, sz);
d244 1
a244 1
	DEBUG_S_warn((aTHX_ "found free op at %p, slab %p", o, slab));
d248 1
a248 1
	    if (o) { DEBUG_S_warn((aTHX_ "found another free op at %p", o)); }
d254 1
a254 1
	    return (void *)o;
d299 9
a307 1
    DEBUG_S_warn((aTHX_ "allocating op at %p, slab %p", o, slab));
a364 1
    dVAR;
d382 1
a382 1
    DEBUG_S_warn((aTHX_ "free op at %p, recorded in slab %p", o, slab));
a388 1
    dVAR;
a401 1
    dVAR;
d404 2
a405 1
    DEBUG_S_warn((aTHX_ "freeing slab %p", slab));
d407 1
a407 1
    for (; slab; slab = slab2) {
d414 1
a414 1
					       slab));
d422 2
a423 1
    }
d515 1
a515 1
#define CHANGE_TYPE(o,type) \
a520 11
STATIC SV*
S_gv_ename(pTHX_ GV *gv)
{
    SV* const tmpsv = sv_newmortal();

    PERL_ARGS_ASSERT_GV_ENAME;

    gv_efullname3(tmpsv, gv, NULL);
    return tmpsv;
}

a531 9
S_too_few_arguments_sv(pTHX_ OP *o, SV *namesv, U32 flags)
{
    PERL_ARGS_ASSERT_TOO_FEW_ARGUMENTS_SV;
    yyerror_pv(Perl_form(aTHX_ "Not enough arguments for %"SVf, namesv),
                                    SvUTF8(namesv) | flags);
    return o;
}

STATIC OP *
a547 10
STATIC OP *
S_too_many_arguments_sv(pTHX_ OP *o, SV *namesv, U32 flags)
{
    PERL_ARGS_ASSERT_TOO_MANY_ARGUMENTS_SV;

    yyerror_pv(Perl_form(aTHX_ "Too many arguments for %"SVf, SVfARG(namesv)),
                SvUTF8(namesv) | flags);
    return o;
}

d549 1
a549 1
S_bad_type_pv(pTHX_ I32 n, const char *t, const char *name, U32 flags, const OP *kid)
d554 1
a554 1
		 (int)n, name, t, OP_DESC(kid)), flags);
d557 2
d560 1
a560 1
S_bad_type_gv(pTHX_ I32 n, const char *t, GV *gv, U32 flags, const OP *kid)
d562 1
a562 1
    SV * const namesv = gv_ename(gv);
d566 1
a566 1
		 (int)n, SVfARG(namesv), t, OP_DESC(kid)), SvUTF8(namesv) | flags);
a573 2
    if (PL_madskills)
	return;		/* various ok barewords are hidden in extra OP_NULL */
a584 1
    dVAR;
a593 4
    /* Until we're using the length for real, cross check that we're being
       told the truth.  */
    assert(strlen(name) == len);

d599 1
a599 1
	  (name[1] == '_' && (*name == '$' || len > 2))))
a600 1
	/* name[2] is true if strlen(name) > 2  */
d602 1
a611 7
    else if (len == 2 && name[1] == '_' && !is_our)
	/* diag_listed_as: Use of my $_ is experimental */
	Perl_ck_warner_d(aTHX_ packWARN(WARN_EXPERIMENTAL__LEXICAL_TOPIC),
			      "Use of %s $_ is experimental",
			       PL_parser->in_my == KEY_state
				 ? "state"
				 : "my");
d617 1
a617 2
		        PL_parser->in_my == KEY_state ? padadd_STATE : 0)
                            | ( flags & SVf_UTF8 ? SVf_UTF8 : 0 ),
d621 3
a623 1
			? (PL_curstash && !strEQ(name,"$_") ? PL_curstash : PL_defstash)
d637 2
d700 34
d735 25
a759 7
    /* Though ops may be freed twice, freeing the op after its slab is a
       big no-no. */
    assert(!o || !o->op_slabbed || OpSLAB(o)->opslab_refcnt != ~(size_t)0); 
    /* During the forced freeing of ops after compilation failure, kidops
       may be freed before their parents. */
    if (!o || o->op_type == OP_FREED)
	return;
d761 23
a783 26
    type = o->op_type;
    if (o->op_private & OPpREFCOUNTED) {
	switch (type) {
	case OP_LEAVESUB:
	case OP_LEAVESUBLV:
	case OP_LEAVEEVAL:
	case OP_LEAVE:
	case OP_SCOPE:
	case OP_LEAVEWRITE:
	    {
	    PADOFFSET refcnt;
	    OP_REFCNT_LOCK;
	    refcnt = OpREFCNT_dec(o);
	    OP_REFCNT_UNLOCK;
	    if (refcnt) {
		/* Need to find and remove any pattern match ops from the list
		   we maintain for reset().  */
		find_and_forget_pmops(o);
		return;
	    }
	    }
	    break;
	default:
	    break;
	}
    }
d785 2
a786 4
    /* Call the op_free hook if it has been set. Do it now so that it's called
     * at the right time for refcounted ops, but still before all of the kids
     * are freed. */
    CALL_OPFREEHOOK(o);
d788 5
a792 18
    if (o->op_flags & OPf_KIDS) {
        OP *kid, *nextkid;
	for (kid = cUNOPo->op_first; kid; kid = nextkid) {
	    nextkid = kid->op_sibling; /* Get before next freeing kid */
	    op_free(kid);
	}
    }
    if (type == OP_NULL)
	type = (OPCODE)o->op_targ;

    if (o->op_slabbed)
        Slab_to_rw(OpSLAB(o));

    /* COP* is not cleared by op_clear() so that we may track line
     * numbers etc even after null() */
    if (type == OP_NEXTSTATE || type == OP_DBSTATE) {
	cop_free((COP*)o);
    }
d794 2
a795 2
    op_clear(o);
    FreeOp(o);
d797 25
a821 2
    if (PL_op == o)
	PL_op = NULL;
d823 33
d858 1
a866 6
#ifdef PERL_MAD
    mad_free(o->op_madprop);
    o->op_madprop = 0;
#endif    

 retry:
d869 1
a869 5
	if (PL_madskills && o->op_targ != OP_NULL) {
	    o->op_type = (Optype)o->op_targ;
	    o->op_targ = 0;
	    goto retry;
	}
d878 1
a878 1
	/* FALL THROUGH */
a881 2
	{
	    GV *gv = (o->op_type == OP_GV || o->op_type == OP_GVSV)
d883 3
a885 1
			&& PL_curpad
d887 3
a889 19
			? cGVOPo_gv : NULL;
	    /* It's possible during global destruction that the GV is freed
	       before the optree. Whilst the SvREFCNT_inc is happy to bump from
	       0 to 1 on a freed SV, the corresponding SvREFCNT_dec from 1 to 0
	       will trigger an assertion failure, because the entry to sv_clear
	       checks that the scalar is not already freed.  A check of for
	       !SvIS_FREED(gv) turns out to be invalid, because during global
	       destruction the reference count can be forced down to zero
	       (with SVf_BREAK set).  In which case raising to 1 and then
	       dropping to 0 triggers cleanup before it should happen.  I
	       *think* that this might actually be a general, systematic,
	       weakness of the whole idea of SVf_BREAK, in that code *is*
	       allowed to raise and lower references during global destruction,
	       so any *valid* code that happens to do this during global
	       destruction might well trigger premature cleanup.  */
	    bool still_valid = gv && SvREFCNT(gv);

	    if (still_valid)
		SvREFCNT_inc_simple_void(gv);
d891 4
a894 6
	    if (cPADOPo->op_padix > 0) {
		/* No GvIN_PAD_off(cGVOPo_gv) here, because other references
		 * may still exist on the pad */
		pad_swipe(cPADOPo->op_padix, TRUE);
		cPADOPo->op_padix = 0;
	    }
d896 2
a897 2
	    SvREFCNT_dec(cSVOPo->op_sv);
	    cSVOPo->op_sv = NULL;
a898 8
	    if (still_valid) {
		int try_downgrade = SvREFCNT(gv) == 2;
		SvREFCNT_dec_NN(gv);
		if (try_downgrade)
		    gv_try_downgrade(gv);
	    }
	}
	break;
d900 10
d934 1
a934 1
	/* FALL THROUGH */
a959 2
	    /* No GvIN_PAD_off here, because other references may still
	     * exist on the pad */
d965 1
a965 1
	/* FALL THROUGH */
d968 1
a968 1
clear_pmop:
d994 103
d1170 1
a1170 1
	    kid = kid->op_sibling;
d1193 1
a1193 2
    if (!PL_madskills)
	op_clear(o);
d1195 1
a1195 2
    o->op_type = OP_NULL;
    o->op_ppaddr = PL_ppaddr[OP_NULL];
d1200 1
d1202 1
d1204 1
d1211 1
d1213 1
d1215 1
d1220 230
d1456 1
a1456 1
I<o> is the op tree, and I<context> must be C<G_SCALAR>, C<G_ARRAY>,
a1473 1
	    return o;
a1477 1
=head1 Optree Manipulation Functions
d1503 4
a1506 3
	    if (kid->op_sibling) {
		kid->op_next = LINKLIST(kid->op_sibling);
		kid = kid->op_sibling;
d1524 1
a1524 1
	for (kid = cLISTOPo->op_first; kid; kid = kid->op_sibling)
a1532 2
    dVAR;

d1553 1
a1553 1
S_op_varname(pTHX_ const OP *o)
d1566 1
a1566 1
	    return varname(gv, funny, 0, NULL, 0, 1);
d1569 1
a1569 1
	    varname(MUTABLE_GV(PL_compcv), funny, o->op_targ, NULL, 0, 1);
d1573 6
d1615 1
a1615 1
    kid = kid->op_sibling; /* get past pushmark */
a1639 3
    case OP_REACH:
    case OP_RKEYS:
    case OP_RVALUES:
d1647 2
a1648 2
    assert(kid->op_sibling);
    name = S_op_varname(aTHX_ kid->op_sibling);
d1666 2
a1667 2
		    SVfARG(name), lbrack, keysv, rbrack,
		    SVfARG(name), lbrack, keysv, rbrack);
a1672 1
    dVAR;
d1688 8
d1700 1
a1700 1
	for (kid = cUNOPo->op_first->op_sibling; kid; kid = kid->op_sibling)
d1703 1
a1703 1
	/* FALL THROUGH */
d1711 1
a1711 1
	    for (kid = cUNOPo->op_first; kid; kid = kid->op_sibling)
d1719 1
a1719 1
	kid = kid->op_sibling;
d1722 5
a1726 2
	    OP *sib = kid->op_sibling;
	    if (sib && kid->op_type != OP_LEAVEWHEN)
d1759 3
a1761 3
	kid = kid->op_sibling; /* get past pushmark */
	assert(kid->op_sibling);
	name = S_op_varname(aTHX_ kid->op_sibling);
d1779 2
a1780 2
			SVfARG(name), lbrack, keysv, rbrack,
			SVfARG(name), lbrack, keysv, rbrack);
d1787 1
a1787 1
Perl_scalarvoid(pTHX_ OP *o)
a1790 2
    SV *useless_sv = NULL;
    const char* useless = NULL;
d1793 4
d1800 3
a1802 14
    /* trailing mad null ops don't count as "there" for void processing */
    if (PL_madskills &&
    	o->op_type != OP_NULL &&
	o->op_sibling &&
	o->op_sibling->op_type == OP_NULL)
    {
	OP *sib;
	for (sib = o->op_sibling;
		sib && sib->op_type == OP_NULL;
		sib = sib->op_sibling) ;
	
	if (!sib)
	    return o;
    }
d1804 14
a1817 5
    if (o->op_type == OP_NEXTSTATE
	|| o->op_type == OP_DBSTATE
	|| (o->op_type == OP_NULL && (o->op_targ == OP_NEXTSTATE
				      || o->op_targ == OP_DBSTATE)))
	PL_curcop = (COP*)o;		/* for warning below */
d1819 7
a1825 8
    /* assumes no premature commitment */
    want = o->op_flags & OPf_WANT;
    if ((want && want != OPf_WANT_SCALAR)
	 || (PL_parser && PL_parser->error_count)
	 || o->op_type == OP_RETURN || o->op_type == OP_REQUIRE || o->op_type == OP_LEAVEWHEN)
    {
	return o;
    }
d1827 1
a1827 5
    if ((o->op_private & OPpTARGET_MY)
	&& (PL_opargs[o->op_type] & OA_TARGLEX))/* OPp share the meaning */
    {
	return scalar(o);			/* As if inside SASSIGN */
    }
d1829 80
a1908 1
    o->op_flags = (o->op_flags & ~OPf_WANT) | OPf_WANT_VOID;
d1910 15
a1924 91
    switch (o->op_type) {
    default:
	if (!(PL_opargs[o->op_type] & OA_FOLDCONST))
	    break;
	/* FALL THROUGH */
    case OP_REPEAT:
	if (o->op_flags & OPf_STACKED)
	    break;
	goto func_ops;
    case OP_SUBSTR:
	if (o->op_private == 4)
	    break;
	/* FALL THROUGH */
    case OP_GVSV:
    case OP_WANTARRAY:
    case OP_GV:
    case OP_SMARTMATCH:
    case OP_PADSV:
    case OP_PADAV:
    case OP_PADHV:
    case OP_PADANY:
    case OP_AV2ARYLEN:
    case OP_REF:
    case OP_REFGEN:
    case OP_SREFGEN:
    case OP_DEFINED:
    case OP_HEX:
    case OP_OCT:
    case OP_LENGTH:
    case OP_VEC:
    case OP_INDEX:
    case OP_RINDEX:
    case OP_SPRINTF:
    case OP_AELEM:
    case OP_AELEMFAST:
    case OP_AELEMFAST_LEX:
    case OP_ASLICE:
    case OP_KVASLICE:
    case OP_HELEM:
    case OP_HSLICE:
    case OP_KVHSLICE:
    case OP_UNPACK:
    case OP_PACK:
    case OP_JOIN:
    case OP_LSLICE:
    case OP_ANONLIST:
    case OP_ANONHASH:
    case OP_SORT:
    case OP_REVERSE:
    case OP_RANGE:
    case OP_FLIP:
    case OP_FLOP:
    case OP_CALLER:
    case OP_FILENO:
    case OP_EOF:
    case OP_TELL:
    case OP_GETSOCKNAME:
    case OP_GETPEERNAME:
    case OP_READLINK:
    case OP_TELLDIR:
    case OP_GETPPID:
    case OP_GETPGRP:
    case OP_GETPRIORITY:
    case OP_TIME:
    case OP_TMS:
    case OP_LOCALTIME:
    case OP_GMTIME:
    case OP_GHBYNAME:
    case OP_GHBYADDR:
    case OP_GHOSTENT:
    case OP_GNBYNAME:
    case OP_GNBYADDR:
    case OP_GNETENT:
    case OP_GPBYNAME:
    case OP_GPBYNUMBER:
    case OP_GPROTOENT:
    case OP_GSBYNAME:
    case OP_GSBYPORT:
    case OP_GSERVENT:
    case OP_GPWNAM:
    case OP_GPWUID:
    case OP_GGRNAM:
    case OP_GGRGID:
    case OP_GETLOGIN:
    case OP_PROTOTYPE:
    case OP_RUNCV:
      func_ops:
	if (!(o->op_private & (OPpLVAL_INTRO|OPpOUR_INTRO)))
	    /* Otherwise it's "Useless use of grep iterator" */
	    useless = OP_DESC(o);
	break;
d1926 5
a1930 3
    case OP_SPLIT:
	kid = cLISTOPo->op_first;
	if (kid && kid->op_type == OP_PUSHRE
d1932 1
a1932 1
		&& !((PMOP*)kid)->op_pmreplrootu.op_pmtargetoff)
d1934 1
a1934 1
		&& !((PMOP*)kid)->op_pmreplrootu.op_pmtargetgv)
d1936 12
a1947 2
	    useless = OP_DESC(o);
	break;
d1949 4
a1952 8
    case OP_NOT:
       kid = cUNOPo->op_first;
       if (kid->op_type != OP_MATCH && kid->op_type != OP_SUBST &&
           kid->op_type != OP_TRANS && kid->op_type != OP_TRANSR) {
	        goto func_ops;
       }
       useless = "negative pattern binding (!~)";
       break;
d1954 3
a1956 4
    case OP_SUBST:
	if (cPMOPo->op_pmflags & PMf_NONDESTRUCT)
	    useless = "non-destructive substitution (s///r)";
	break;
d1958 8
a1965 3
    case OP_TRANSR:
	useless = "non-destructive transliteration (tr///r)";
	break;
d1967 37
a2003 8
    case OP_RV2GV:
    case OP_RV2SV:
    case OP_RV2AV:
    case OP_RV2HV:
	if (!(o->op_private & (OPpLVAL_INTRO|OPpOUR_INTRO)) &&
		(!o->op_sibling || o->op_sibling->op_type != OP_READLINE))
	    useless = "a variable";
	break;
d2005 3
a2007 36
    case OP_CONST:
	sv = cSVOPo_sv;
	if (cSVOPo->op_private & OPpCONST_STRICT)
	    no_bareword_allowed(o);
	else {
	    if (ckWARN(WARN_VOID)) {
		/* don't warn on optimised away booleans, eg 
		 * use constant Foo, 5; Foo || print; */
		if (cSVOPo->op_private & OPpCONST_SHORTCIRCUIT)
		    useless = NULL;
		/* the constants 0 and 1 are permitted as they are
		   conventionally used as dummies in constructs like
		        1 while some_condition_with_side_effects;  */
		else if (SvNIOK(sv) && (SvNV(sv) == 0.0 || SvNV(sv) == 1.0))
		    useless = NULL;
		else if (SvPOK(sv)) {
                    SV * const dsv = newSVpvs("");
                    useless_sv
                        = Perl_newSVpvf(aTHX_
                                        "a constant (%s)",
                                        pv_pretty(dsv, SvPVX_const(sv),
                                                  SvCUR(sv), 32, NULL, NULL,
                                                  PERL_PV_PRETTY_DUMP
                                                  | PERL_PV_ESCAPE_NOCLEAR
                                                  | PERL_PV_ESCAPE_UNI_DETECT));
                    SvREFCNT_dec_NN(dsv);
		}
		else if (SvOK(sv)) {
		    useless_sv = Perl_newSVpvf(aTHX_ "a constant (%"SVf")", sv);
		}
		else
		    useless = "a constant (undef)";
	    }
	}
	op_null(o);		/* don't execute or even remember it */
	break;
d2009 3
a2011 4
    case OP_POSTINC:
	o->op_type = OP_PREINC;		/* pre-increment is faster */
	o->op_ppaddr = PL_ppaddr[OP_PREINC];
	break;
d2013 3
a2015 4
    case OP_POSTDEC:
	o->op_type = OP_PREDEC;		/* pre-decrement is faster */
	o->op_ppaddr = PL_ppaddr[OP_PREDEC];
	break;
d2017 3
a2019 4
    case OP_I_POSTINC:
	o->op_type = OP_I_PREINC;	/* pre-increment is faster */
	o->op_ppaddr = PL_ppaddr[OP_I_PREINC];
	break;
d2021 4
a2024 4
    case OP_I_POSTDEC:
	o->op_type = OP_I_PREDEC;	/* pre-decrement is faster */
	o->op_ppaddr = PL_ppaddr[OP_I_PREDEC];
	break;
d2026 2
a2027 4
    case OP_SASSIGN: {
	OP *rv2gv;
	UNOP *refgen, *rv2cv;
	LISTOP *exlist;
d2029 3
a2031 2
	if ((o->op_private & ~OPpASSIGN_BACKWARDS) != 2)
	    break;
d2033 1
a2033 3
	rv2gv = ((BINOP *)o)->op_last;
	if (!rv2gv || rv2gv->op_type != OP_RV2GV)
	    break;
d2035 3
a2037 1
	refgen = (UNOP *)((BINOP *)o)->op_first;
d2039 4
a2042 2
	if (!refgen || refgen->op_type != OP_REFGEN)
	    break;
d2044 3
a2046 4
	exlist = (LISTOP *)refgen->op_first;
	if (!exlist || exlist->op_type != OP_NULL
	    || exlist->op_targ != OP_LIST)
	    break;
d2048 1
a2048 2
	if (exlist->op_first->op_type != OP_PUSHMARK)
	    break;
d2050 2
a2051 1
	rv2cv = (UNOP*)exlist->op_last;
d2053 7
a2059 2
	if (rv2cv->op_type != OP_RV2CV)
	    break;
d2061 2
a2062 3
	assert ((rv2gv->op_private & OPpDONT_INIT_GV) == 0);
	assert ((o->op_private & OPpASSIGN_CV_TO_GV) == 0);
	assert ((rv2cv->op_private & OPpMAY_RETURN_CONSTANT) == 0);
d2064 4
a2067 3
	o->op_private |= OPpASSIGN_CV_TO_GV;
	rv2gv->op_private |= OPpDONT_INIT_GV;
	rv2cv->op_private |= OPpMAY_RETURN_CONSTANT;
d2069 13
a2081 2
	break;
    }
d2083 10
a2092 4
    case OP_AASSIGN: {
	inplace_aassign(o);
	break;
    }
d2094 52
a2145 15
    case OP_OR:
    case OP_AND:
	kid = cLOGOPo->op_first;
	if (kid->op_type == OP_NOT
	    && (kid->op_flags & OPf_KIDS)
	    && !PL_madskills) {
	    if (o->op_type == OP_AND) {
		o->op_type = OP_OR;
		o->op_ppaddr = PL_ppaddr[OP_OR];
	    } else {
		o->op_type = OP_AND;
		o->op_ppaddr = PL_ppaddr[OP_AND];
	    }
	    op_null(kid);
	}
d2147 12
a2158 7
    case OP_DOR:
    case OP_COND_EXPR:
    case OP_ENTERGIVEN:
    case OP_ENTERWHEN:
	for (kid = cUNOPo->op_first->op_sibling; kid; kid = kid->op_sibling)
	    scalarvoid(kid);
	break;
d2160 1
a2160 28
    case OP_NULL:
	if (o->op_flags & OPf_STACKED)
	    break;
	/* FALL THROUGH */
    case OP_NEXTSTATE:
    case OP_DBSTATE:
    case OP_ENTERTRY:
    case OP_ENTER:
	if (!(o->op_flags & OPf_KIDS))
	    break;
	/* FALL THROUGH */
    case OP_SCOPE:
    case OP_LEAVE:
    case OP_LEAVETRY:
    case OP_LEAVELOOP:
    case OP_LINESEQ:
    case OP_LIST:
    case OP_LEAVEGIVEN:
    case OP_LEAVEWHEN:
	for (kid = cLISTOPo->op_first; kid; kid = kid->op_sibling)
	    scalarvoid(kid);
	break;
    case OP_ENTEREVAL:
	scalarkids(o);
	break;
    case OP_SCALAR:
	return scalar(o);
    }
d2162 1
a2162 12
    if (useless_sv) {
        /* mortalise it, in case warnings are fatal.  */
        Perl_ck_warner(aTHX_ packWARN(WARN_VOID),
                       "Useless use of %"SVf" in void context",
                       sv_2mortal(useless_sv));
    }
    else if (useless) {
       Perl_ck_warner(aTHX_ packWARN(WARN_VOID),
                      "Useless use of %s in void context",
                      useless);
    }
    return o;
d2170 1
a2170 1
	for (kid = cLISTOPo->op_first; kid; kid = kid->op_sibling)
a2178 1
    dVAR;
d2199 2
d2202 14
a2215 1
	list(cBINOPo->op_first);
d2220 1
a2220 1
	for (kid = cUNOPo->op_first->op_sibling; kid; kid = kid->op_sibling)
d2234 2
d2238 4
d2247 1
a2247 1
	kid = kid->op_sibling;
d2250 1
a2250 1
	    OP *sib = kid->op_sibling;
a2269 1
    dVAR;
d2276 7
a2282 3
            OP *kid;
	    for (kid = cLISTOPo->op_first; kid; kid = kid->op_sibling) {
		if (kid->op_sibling) {
d2302 1
a2302 1
	for (kid = cLISTOPo->op_first; kid; kid = kid->op_sibling)
d2308 79
d2392 1
a2392 1
checking which can't be done in the normal ck_xxx functions and makes
d2410 21
a2435 17
#if defined(PERL_MAD) && defined(USE_ITHREADS)
    {
	/* Make sure mad ops are also thread-safe */
	MADPROP *mp = o->op_madprop;
	while (mp) {
	    if (mp->mad_type == MAD_OP && mp->mad_vlen) {
		OP *prop_op = (OP *) mp->mad_val;
		/* We only need "Relocate sv to the pad for thread safety.", but this
		   easiest way to make sure it traverses everything */
		if (prop_op->op_type == OP_CONST)
		    cSVOPx(prop_op)->op_private &= ~OPpCONST_STRICT;
		finalize_op(prop_op);
	    }
	    mp = mp->mad_next;
	}
    }
#endif
d2443 7
a2449 6
	if ( o->op_sibling
	    && (o->op_sibling->op_type == OP_NEXTSTATE || o->op_sibling->op_type == OP_DBSTATE)
	    && ckWARN(WARN_EXEC))
	    {
		if (o->op_sibling->op_sibling) {
		    const OPCODE type = o->op_sibling->op_sibling->op_type;
d2452 1
a2452 1
			CopLINE_set(PL_curcop, CopLINE((COP*)o->op_sibling));
a2458 1
		}
d2460 1
d2483 6
d2490 5
a2494 12
	/* Relocate sv to the pad for thread safety.
	 * Despite being a "constant", the SV is written to,
	 * for reference counts, sv_upgrade() etc. */
	if (cSVOPo->op_sv) {
	    const PADOFFSET ix = pad_alloc(OP_CONST, SVf_READONLY);
	    SvREFCNT_dec(PAD_SVl(ix));
	    PAD_SETSV(ix, cSVOPo->op_sv);
	    /* XXX I don't know how this isn't readonly already. */
	    if (!SvIsCOW(PAD_SVl(ix))) SvREADONLY_on(PAD_SVl(ix));
	    cSVOPo->op_sv = NULL;
	    o->op_targ = ix;
	}
a2495 1
	break;
a2498 2
	SV *lexname;
	GV **fields;
a2500 1
	bool check_fields;
d2511 1
d2514 1
a2514 1
        kid = cLISTOPo->op_first->op_sibling;
d2524 1
a2524 1
				: kLISTOP->op_first->op_sibling);
d2529 3
a2531 51
	if (o->op_private & OPpLVAL_INTRO || rop->op_type != OP_RV2HV)
	    rop = NULL;
	else if (rop->op_first->op_type == OP_PADSV)
	    /* @@$hash{qw(keys here)} */
	    rop = (UNOP*)rop->op_first;
	else {
	    /* @@{$hash}{qw(keys here)} */
	    if (rop->op_first->op_type == OP_SCOPE
		&& cLISTOPx(rop->op_first)->op_last->op_type == OP_PADSV)
		{
		    rop = (UNOP*)cLISTOPx(rop->op_first)->op_last;
		}
	    else
		rop = NULL;
	}

        lexname = NULL; /* just to silence compiler warnings */
        fields  = NULL; /* just to silence compiler warnings */

	check_fields =
	    rop
	 && (lexname = *av_fetch(PL_comppad_name, rop->op_targ, TRUE),
	     SvPAD_TYPED(lexname))
	 && (fields = (GV**)hv_fetchs(SvSTASH(lexname), "FIELDS", FALSE))
	 && isGV(*fields) && GvHV(*fields);
	for (; key_op;
	     key_op = (SVOP*)key_op->op_sibling) {
	    SV **svp, *sv;
	    if (key_op->op_type != OP_CONST)
		continue;
	    svp = cSVOPx_svp(key_op);

	    /* Make the CONST have a shared SV */
	    if ((!SvIsCOW_shared_hash(sv = *svp))
	     && SvTYPE(sv) < SVt_PVMG && SvOK(sv) && !SvROK(sv)) {
		SSize_t keylen;
		const char * const key = SvPV_const(sv, *(STRLEN*)&keylen);
		SV *nsv = newSVpvn_share(key,
					 SvUTF8(sv) ? -keylen : keylen,	0);
		SvREFCNT_dec_NN(sv);
		*svp = nsv;
	    }

	    if (check_fields
	     && !hv_fetch_ent(GvHV(*fields), *svp, FALSE, 0)) {
		Perl_croak(aTHX_ "No such class field \"%"SVf"\" " 
			   "in variable %"SVf" of type %"HEKf, 
		      SVfARG(*svp), SVfARG(lexname),
                      HEKfARG(HvNAME_HEK(SvSTASH(lexname))));
	    }
	}
d2549 54
a2602 1
	for (kid = cUNOPo->op_first; kid; kid = kid->op_sibling)
d2611 2
a2612 2
I<type> represents the context type, roughly based on the type of op that
would do the modifying, although C<local()> is represented by OP_NULL,
d2618 1
a2618 1
called with an op of type OP_ADD and a C<type> argument of OP_SASSIGN.
d2626 22
d2653 121
a2773 6
    case OP_RV2HV:     case OP_KVASLICE:
    case OP_RV2SV:     case   OP_HSLICE:
    case OP_AELEMFAST: case OP_KVHSLICE:
    case OP_HELEM:
    case OP_AELEM:
	return 1;
d2775 5
a2779 1
    return 0;
d2808 1
a2808 1
	if ((o->op_flags & OPf_PARENS) || PL_madskills)
d2814 1
a2814 5
	    o->op_type = OP_RV2CV;		/* entersub => rv2cv */
	    /* Both ENTERSUB and RV2CV use this bit, but for different pur-
	       poses, so we need it clear.  */
	    o->op_private &= ~1;
	    o->op_ppaddr = PL_ppaddr[OP_RV2CV];
d2820 1
a2820 2
	    o->op_private |= OPpLVAL_INTRO
	                   |(OPpENTERSUB_INARGS * (type == OP_LEAVESUBLV));
d2822 2
a2823 1
	    if (type == OP_GREPSTART || type == OP_ENTERSUB || type == OP_REFGEN) {
d2831 2
d2842 2
a2843 2
		while (kid->op_sibling)
		    kid = kid->op_sibling;
d2860 6
a2865 1
		cv = GvCV(kGVOP_gv);
d2870 9
d2881 1
a2881 1
	/* FALL THROUGH */
d2892 1
a2892 3
		      : (o->op_type == OP_ENTERSUB
			? "non-lvalue subroutine call"
			: OP_DESC(o))),
a2901 1
    case OP_REPEAT:
d2920 24
d2946 1
a2946 1
	for (kid = cUNOPo->op_first->op_sibling; kid; kid = kid->op_sibling)
d2956 1
a2956 1
	/* FALL THROUGH */
d2961 1
a2961 1
	/* FALL THROUGH */
d2965 1
a2965 1
	/* FALL THROUGH */
d2973 1
a2973 1
	/* FALL THROUGH */
d2992 1
a2992 1
	/* FALL THROUGH */
d2995 1
d3019 1
a3019 1
	/* FALL THROUGH */
d3023 6
a3028 2
	    Perl_croak(aTHX_ "Can't localize lexical variable %"SVf,
		 PAD_COMPNAME_SV(o->op_targ));
a3035 1
    case OP_RKEYS:
d3042 1
a3042 1
	/* FALL THROUGH */
d3049 1
a3049 1
	    op_lvalue(cBINOPo->op_first->op_sibling, type);
d3067 1
d3086 1
a3086 1
	/* FALL THROUGH */
d3089 1
a3089 1
	for (kid = cLISTOPo->op_first; kid; kid = kid->op_sibling)
a3095 5
    case OP_RETURN:
	if (type != OP_LEAVESUBLV)
	    goto nomod;
	break; /* op_lvalue()ing was handled by ck_return() */

d3105 52
a3156 2
	 || !S_vivifies(cLOGOPo->op_first->op_sibling->op_type))
	    op_lvalue(cLOGOPo->op_first->op_sibling, type);
d3200 1
a3200 1
	/* FALL THROUGH */
d3252 1
a3252 1
	/* FALL THROUGH */
d3272 1
a3272 1
	for (kid = cLISTOPo->op_first; kid; kid = kid->op_sibling)
d3286 1
a3286 1
    if (!o || (PL_parser && PL_parser->error_count))
d3293 1
a3293 2
	    o->op_type = OP_RV2CV;             /* entersub => rv2cv */
	    o->op_ppaddr = PL_ppaddr[OP_RV2CV];
a3296 1
	    o->op_private &= ~1;
d3308 1
a3308 1
	for (kid = cUNOPo->op_first->op_sibling; kid; kid = kid->op_sibling)
d3315 1
a3315 1
	/* FALL THROUGH */
d3329 1
a3329 1
	/* FALL THROUGH */
d3362 1
a3362 1
	/* FALL THROUGH */
a3378 1
    dVAR;
a3388 4
#ifdef PERL_MAD
    else if (o->op_type == OP_NULL)
	rop = NULL;
#endif
d3392 1
a3392 1
	for (o = cLISTOPo->op_first; o; o=o->op_sibling) {
a3404 3
    dVAR;
    SV * const stashsv = stash ? newSVhek(HvNAME_HEK(stash)) : &PL_sv_no;

d3406 2
d3409 1
a3409 1
    /* fake up C<use attributes $pkg,$rv,@@attrs> */
d3414 11
a3424 9
    Perl_load_module(aTHX_ PERL_LOADMOD_IMPORT_OPS,
			 newSVpvs(ATTRSMODULE),
			 NULL,
			 op_prepend_elem(OP_LIST,
				      newSVOP(OP_CONST, 0, stashsv),
				      op_prepend_elem(OP_LIST,
						   newSVOP(OP_CONST, 0,
							   newRV(target)),
						   dup_attrlist(attrs))));
a3429 1
    dVAR;
d3455 1
a3455 1
    stashsv = stash ? newSVhek(HvNAME_HEK(stash)) : &PL_sv_no;
d3463 1
a3463 1
					    op_lvalue(arg, OP_REFGEN)),
d3468 1
a3468 1
    imop = convert(OP_ENTERSUB, OPf_STACKED|OPf_SPECIAL|OPf_WANT_VOID,
d3470 2
a3471 2
			       op_prepend_elem(OP_LIST, pack, list(arg)),
			       newSVOP(OP_METHOD_NAMED, 0, meth)));
d3552 1
a3552 1
        OP * lasto = NULL;
d3554 3
a3556 3
        assert(cLISTOPo->op_first->op_type == OP_PUSHMARK);
        /* Counting on the first op to hit the lasto = o line */
        for (o = cLISTOPo->op_first; o; o=o->op_sibling) {
d3575 3
a3577 1
                    lasto->op_sibling = o->op_sibling;
d3585 1
a3585 1
        if (!cLISTOPx(*attrs)->op_first->op_sibling) {
a3639 1
    dVAR;
a3648 4
    if (PL_madskills && type == OP_NULL && o->op_flags & OPf_KIDS) {
	(void)my_kid(cUNOPo->op_first, attrs, imopsp);
	return o;
    }
d3652 1
a3652 1
	for (kid = cLISTOPo->op_first; kid; kid = kid->op_sibling)
d3664 1
d3687 1
a3706 1
    dVAR;
d3739 2
a3740 1
		lrops->op_first = pushmark->op_sibling;
d3785 1
a3785 1
             desc, name, name);
d3819 11
a3829 5
    if (!(right->op_flags & OPf_STACKED) && ismatchop) {
	OP *newleft;

	right->op_flags |= OPf_STACKED;
	if (rtype != OP_MATCH && rtype != OP_TRANSR &&
d3834 6
a3839 7
	    newleft = op_lvalue(left, rtype);
	else
	    newleft = left;
	if (right->op_type == OP_TRANS || right->op_type == OP_TRANSR)
	    o = newBINOP(OP_NULL, OPf_STACKED, scalar(newleft), right);
	else
	    o = op_prepend_elem(rtype, scalar(newleft), right);
d3846 1
a3846 1
		pmruntime(newPMOP(OP_MATCH, 0), right, 0, 0));
d3878 1
a3878 2
	    o->op_type = OP_LEAVE;
	    o->op_ppaddr = PL_ppaddr[OP_LEAVE];
d3882 1
a3882 2
	    o->op_type = OP_SCOPE;
	    o->op_ppaddr = PL_ppaddr[OP_SCOPE];
d3888 1
a3888 1
		kid = kid->op_sibling;
d3905 1
a3905 1
	for(; kid; kid = kid->op_sibling)
d3912 11
a3925 1
    dVAR;
d3928 2
d3935 2
d3943 11
a3956 1
    dVAR;
d3961 8
d4026 1
a4026 1
	for (;; kid = kid->op_sibling) {
a4058 15
STATIC OP *
S_newDEFSVOP(pTHX)
{
    dVAR;
    const PADOFFSET offset = pad_findmy_pvs("$_", 0);
    if (offset == NOT_IN_PAD || PAD_COMPNAME_FLAGS_isOUR(offset)) {
	return newSVREF(newGVOP(OP_GV, 0, PL_defgv));
    }
    else {
	OP * const o = newOP(OP_PADSV, 0);
	o->op_targ = offset;
	return o;
    }
}

a4061 2
    dVAR;

d4073 1
a4073 1
	cx = &cxstack[cxstack_ix];
d4092 1
a4092 1
        S_prune_chain_head(aTHX_ &PL_eval_start);
d4137 1
a4137 1
        S_prune_chain_head(aTHX_ &PL_main_start);
a4157 2
    dVAR;

d4181 2
a4182 1
		if (*s && strchr("@@$%*", *s) && *++s
d4224 1
a4224 1
	o = convert(OP_JOIN, 0, op_prepend_elem(OP_LIST, o2, o));
d4272 1
a4274 1
    I32 oldscope;
d4279 2
d4294 5
d4304 5
d4311 2
a4312 1
	if (IN_LOCALE_COMPILETIME)
d4314 1
d4317 2
a4318 2
	if (!cLISTOPo->op_first->op_sibling
	  || cLISTOPo->op_first->op_sibling->op_type != OP_CONST)
d4321 1
a4321 1
	    SV * const sv = cSVOPx_sv(cLISTOPo->op_first->op_sibling);
d4326 1
a4326 1
		    if (*s == 'p' || *s == 'P') goto nope;
d4361 2
a4362 2
    oldscope = PL_scopestack_ix;
    create_eval_scope(G_FAKINGEVAL);
d4369 1
a4369 1
       currently compiling COP, but that IN_PERL_RUNTIME is not true. */
d4375 4
a4383 6
#ifdef PERL_MAD
	    /* Can't simply swipe the SV from the pad, because that relies on
	       the op being freed "real soon now". Under MAD, this doesn't
	       happen (see the #ifdef below).  */
	    sv = newSVsv(sv);
#else
a4384 1
#endif
d4408 1
d4413 7
a4419 3
    if (PL_scopestack_ix > oldscope)
	delete_eval_scope();

d4423 5
a4427 1
#ifndef PERL_MAD
a4428 1
#endif
d4430 2
a4431 1
    if (type == OP_STRINGIFY) SvPADTMP_off(sv);
d4436 2
a4437 8
    if (type == OP_RV2GV)
	newop = newGVOP(OP_GV, 0, MUTABLE_GV(sv));
    else
    {
	newop = newSVOP(OP_CONST, 0, MUTABLE_SV(sv));
	if (type != OP_STRINGIFY) newop->op_folded = 1;
    }
    op_getmad(o,newop,'f');
d4460 1
a4460 1
    S_prune_chain_head(aTHX_ &curop);
d4470 1
a4470 2
    o->op_type = OP_RV2AV;
    o->op_ppaddr = PL_ppaddr[OP_RV2AV];
d4474 3
d4478 3
a4480 2
    av = (AV *)SvREFCNT_inc_NN(*PL_stack_sp--);
    ((UNOP*)o)->op_first = newSVOP(OP_CONST, 0, (SV *)av);
a4486 5
#ifdef PERL_MAD
    op_getmad(curop,o,'O');
#else
    op_free(curop);
#endif
a4490 31
OP *
Perl_convert(pTHX_ I32 type, I32 flags, OP *o)
{
    dVAR;
    if (type < 0) type = -type, flags |= OPf_SPECIAL;
    if (!o || o->op_type != OP_LIST)
	o = newLISTOP(OP_LIST, 0, o, NULL);
    else
	o->op_flags &= ~OPf_WANT;

    if (!(PL_opargs[type] & OA_MARK))
	op_null(cLISTOPo->op_first);
    else {
	OP * const kid2 = cLISTOPo->op_first->op_sibling;
	if (kid2 && kid2->op_type == OP_COREARGS) {
	    op_null(cLISTOPo->op_first);
	    kid2->op_private |= OPpCOREARGS_PUSHMARK;
	}
    }	

    o->op_type = (OPCODE)type;
    o->op_ppaddr = PL_ppaddr[type];
    o->op_flags |= flags;

    o = CHECKOP(type, o);
    if (o->op_type != (unsigned)type)
	return o;

    return fold_constants(op_integerize(op_std_init(o)));
}

d4501 4
a4504 4
op, returning the lengthened list.  I<first> is the list-type op,
and I<last> is the op to append to the list.  I<optype> specifies the
intended opcode for the list.  If I<first> is not already a list of the
right type, it will be upgraded into one.  If either I<first> or I<last>
d4525 2
a4526 7
    if (first->op_flags & OPf_KIDS)
	((LISTOP*)first)->op_last->op_sibling = last;
    else {
	first->op_flags |= OPf_KIDS;
	((LISTOP*)first)->op_first = last;
    }
    ((LISTOP*)first)->op_last = last;
d4534 4
a4537 4
returning the combined list.  I<first> and I<last> are the list-type ops
to concatenate.  I<optype> specifies the intended opcode for the list.
If either I<first> or I<last> is not already a list of the right type,
it will be upgraded into one.  If either I<first> or I<last> is null,
d4558 1
a4558 1
    ((LISTOP*)first)->op_last->op_sibling = ((LISTOP*)last)->op_first;
d4560 1
a4562 16
#ifdef PERL_MAD
    if (((LISTOP*)last)->op_first && first->op_madprop) {
	MADPROP *mp = ((LISTOP*)last)->op_first->op_madprop;
	if (mp) {
	    while (mp->mad_next)
		mp = mp->mad_next;
	    mp->mad_next = first->op_madprop;
	}
	else {
	    ((LISTOP*)last)->op_first->op_madprop = first->op_madprop;
	}
    }
    first->op_madprop = last->op_madprop;
    last->op_madprop = 0;
#endif

d4568 15
a4582 159
/*
=for apidoc Am|OP *|op_prepend_elem|I32 optype|OP *first|OP *last

Prepend an item to the list of ops contained directly within a list-type
op, returning the lengthened list.  I<first> is the op to prepend to the
list, and I<last> is the list-type op.  I<optype> specifies the intended
opcode for the list.  If I<last> is not already a list of the right type,
it will be upgraded into one.  If either I<first> or I<last> is null,
the other is returned unchanged.

=cut
*/

OP *
Perl_op_prepend_elem(pTHX_ I32 type, OP *first, OP *last)
{
    if (!first)
	return last;

    if (!last)
	return first;

    if (last->op_type == (unsigned)type) {
	if (type == OP_LIST) {	/* already a PUSHMARK there */
	    first->op_sibling = ((LISTOP*)last)->op_first->op_sibling;
	    ((LISTOP*)last)->op_first->op_sibling = first;
            if (!(first->op_flags & OPf_PARENS))
                last->op_flags &= ~OPf_PARENS;
	}
	else {
	    if (!(last->op_flags & OPf_KIDS)) {
		((LISTOP*)last)->op_last = first;
		last->op_flags |= OPf_KIDS;
	    }
	    first->op_sibling = ((LISTOP*)last)->op_first;
	    ((LISTOP*)last)->op_first = first;
	}
	last->op_flags |= OPf_KIDS;
	return last;
    }

    return newLISTOP(type, 0, first, last);
}

/* Constructors */

#ifdef PERL_MAD
 
TOKEN *
Perl_newTOKEN(pTHX_ I32 optype, YYSTYPE lval, MADPROP* madprop)
{
    TOKEN *tk;
    Newxz(tk, 1, TOKEN);
    tk->tk_type = (OPCODE)optype;
    tk->tk_type = 12345;
    tk->tk_lval = lval;
    tk->tk_mad = madprop;
    return tk;
}

void
Perl_token_free(pTHX_ TOKEN* tk)
{
    PERL_ARGS_ASSERT_TOKEN_FREE;

    if (tk->tk_type != 12345)
	return;
    mad_free(tk->tk_mad);
    Safefree(tk);
}

void
Perl_token_getmad(pTHX_ TOKEN* tk, OP* o, char slot)
{
    MADPROP* mp;
    MADPROP* tm;

    PERL_ARGS_ASSERT_TOKEN_GETMAD;

    if (tk->tk_type != 12345) {
	Perl_warner(aTHX_ packWARN(WARN_MISC),
	     "Invalid TOKEN object ignored");
	return;
    }
    tm = tk->tk_mad;
    if (!tm)
	return;

    /* faked up qw list? */
    if (slot == '(' &&
	tm->mad_type == MAD_SV &&
	SvPVX((SV *)tm->mad_val)[0] == 'q')
	    slot = 'x';

    if (o) {
	mp = o->op_madprop;
	if (mp) {
	    for (;;) {
		/* pretend constant fold didn't happen? */
		if (mp->mad_key == 'f' &&
		    (o->op_type == OP_CONST ||
		     o->op_type == OP_GV) )
		{
		    token_getmad(tk,(OP*)mp->mad_val,slot);
		    return;
		}
		if (!mp->mad_next)
		    break;
		mp = mp->mad_next;
	    }
	    mp->mad_next = tm;
	    mp = mp->mad_next;
	}
	else {
	    o->op_madprop = tm;
	    mp = o->op_madprop;
	}
	if (mp->mad_key == 'X')
	    mp->mad_key = slot;	/* just change the first one */

	tk->tk_mad = 0;
    }
    else
	mad_free(tm);
    Safefree(tk);
}

void
Perl_op_getmad_weak(pTHX_ OP* from, OP* o, char slot)
{
    MADPROP* mp;
    if (!from)
	return;
    if (o) {
	mp = o->op_madprop;
	if (mp) {
	    for (;;) {
		/* pretend constant fold didn't happen? */
		if (mp->mad_key == 'f' &&
		    (o->op_type == OP_CONST ||
		     o->op_type == OP_GV) )
		{
		    op_getmad(from,(OP*)mp->mad_val,slot);
		    return;
		}
		if (!mp->mad_next)
		    break;
		mp = mp->mad_next;
	    }
	    mp->mad_next = newMADPROP(slot,MAD_OP,from,0);
	}
	else {
	    o->op_madprop = newMADPROP(slot,MAD_OP,from,0);
	}
    }
}

void
Perl_op_getmad(pTHX_ OP* from, OP* o, char slot)
d4584 12
a4595 23
    MADPROP* mp;
    if (!from)
	return;
    if (o) {
	mp = o->op_madprop;
	if (mp) {
	    for (;;) {
		/* pretend constant fold didn't happen? */
		if (mp->mad_key == 'f' &&
		    (o->op_type == OP_CONST ||
		     o->op_type == OP_GV) )
		{
		    op_getmad(from,(OP*)mp->mad_val,slot);
		    return;
		}
		if (!mp->mad_next)
		    break;
		mp = mp->mad_next;
	    }
	    mp->mad_next = newMADPROP(slot,MAD_OP,from,1);
	}
	else {
	    o->op_madprop = newMADPROP(slot,MAD_OP,from,1);
d4597 4
d4602 2
a4603 5
    else {
	PerlIO_printf(PerlIO_stderr(),
		      "DESTROYING op = %0"UVxf"\n", PTR2UV(from));
	op_free(from);
    }
d4606 10
a4615 17
void
Perl_prepend_madprops(pTHX_ MADPROP* mp, OP* o, char slot)
{
    MADPROP* tm;
    if (!mp || !o)
	return;
    if (slot)
	mp->mad_key = slot;
    tm = o->op_madprop;
    o->op_madprop = mp;
    for (;;) {
	if (!mp->mad_next)
	    break;
	mp = mp->mad_next;
    }
    mp->mad_next = tm;
}
d4617 2
a4618 7
void
Perl_append_madprops(pTHX_ MADPROP* tm, OP* o, char slot)
{
    if (!o)
	return;
    addmad(tm, &(o->op_madprop), slot);
}
d4620 2
a4621 2
void
Perl_addmad(pTHX_ MADPROP* tm, MADPROP** root, char slot)
d4623 8
a4630 9
    MADPROP* mp;
    if (!tm || !root)
	return;
    if (slot)
	tm->mad_key = slot;
    mp = *root;
    if (!mp) {
	*root = tm;
	return;
d4632 9
a4640 4
    for (;;) {
	if (!mp->mad_next)
	    break;
	mp = mp->mad_next;
a4641 2
    mp->mad_next = tm;
}
d4643 4
a4646 4
MADPROP *
Perl_newMADsv(pTHX_ char key, SV* sv)
{
    PERL_ARGS_ASSERT_NEWMADSV;
d4648 3
a4650 2
    return newMADPROP(key, MAD_SV, sv, 0);
}
d4652 1
a4652 11
MADPROP *
Perl_newMADPROP(pTHX_ char key, char type, void* val, I32 vlen)
{
    MADPROP *const mp = (MADPROP *) PerlMemShared_malloc(sizeof(MADPROP));
    mp->mad_next = 0;
    mp->mad_key = key;
    mp->mad_vlen = vlen;
    mp->mad_type = type;
    mp->mad_val = val;
/*    PerlIO_printf(PerlIO_stderr(), "NEW  mp = %0x\n", mp);  */
    return mp;
d4655 1
a4655 29
void
Perl_mad_free(pTHX_ MADPROP* mp)
{
/*    PerlIO_printf(PerlIO_stderr(), "FREE mp = %0x\n", mp); */
    if (!mp)
	return;
    if (mp->mad_next)
	mad_free(mp->mad_next);
/*    if (PL_parser && PL_parser->lex_state != LEX_NOTPARSING && mp->mad_vlen)
	PerlIO_printf(PerlIO_stderr(), "DESTROYING '%c'=<%s>\n", mp->mad_key & 255, mp->mad_val); */
    switch (mp->mad_type) {
    case MAD_NULL:
	break;
    case MAD_PV:
	Safefree(mp->mad_val);
	break;
    case MAD_OP:
	if (mp->mad_vlen)	/* vlen holds "strong/weak" boolean */
	    op_free((OP*)mp->mad_val);
	break;
    case MAD_SV:
	sv_free(MUTABLE_SV(mp->mad_val));
	break;
    default:
	PerlIO_printf(PerlIO_stderr(), "Unrecognized mad\n");
	break;
    }
    PerlMemShared_free(mp);
}
a4656 1
#endif
d4675 13
d4689 1
a4689 1
S_force_list(pTHX_ OP *o)
d4691 7
a4697 1
    if (!o || o->op_type != OP_LIST)
d4699 5
a4703 1
    op_null(o);
d4710 3
a4712 3
Constructs, checks, and returns an op of any list type.  I<type> is
the opcode.  I<flags> gives the eight bits of C<op_flags>, except that
C<OPf_KIDS> will be set automatically if required.  I<first> and I<last>
d4716 7
d4732 2
a4733 1
    assert((PL_opargs[type] & OA_CLASS_MASK) == OA_LISTOP);
d4737 1
a4737 2
    listop->op_type = (OPCODE)type;
    listop->op_ppaddr = PL_ppaddr[type];
d4747 1
a4747 1
	first->op_sibling = last;
d4752 1
a4752 1
	pushop->op_sibling = first;
d4758 2
d4768 1
a4768 1
has no extra fields).  I<type> is the opcode.  I<flags> gives the
d4792 1
a4792 2
    o->op_type = (OPCODE)type;
    o->op_ppaddr = PL_ppaddr[type];
d4807 2
a4808 2
Constructs, checks, and returns an op of any unary type.  I<type> is
the opcode.  I<flags> gives the eight bits of C<op_flags>, except that
d4811 1
a4811 1
is automatically set.  I<first> supplies an optional op to be the direct
d4835 1
d4841 1
a4841 1
	first = force_list(first);
d4844 1
a4844 2
    unop->op_type = (OPCODE)type;
    unop->op_ppaddr = PL_ppaddr[type];
d4848 4
d4860 110
d4972 2
a4973 2
Constructs, checks, and returns an op of any binary type.  I<type>
is the opcode.  I<flags> gives the eight bits of C<op_flags>, except
d4976 1
a4976 1
2 is automatically set as required.  I<first> and I<last> supply up to
d4990 1
a4990 1
	|| type == OP_SASSIGN || type == OP_NULL );
d4997 1
a4997 2
    binop->op_type = (OPCODE)type;
    binop->op_ppaddr = PL_ppaddr[type];
d5006 1
a5006 1
	first->op_sibling = last;
d5009 7
a5019 2
    binop->op_last = binop->op_first->op_sibling;

a5042 1
    dVAR;
a5044 4
#ifdef PERL_MAD
			(repl->op_type == OP_NULL)
			    ? ((SVOP*)((LISTOP*)repl)->op_first)->op_sv :
#endif
d5079 1
d5083 1
d5107 1
a5107 1
/* There is a  snag with this code on EBCDIC: scan_const() in toke.c has
d5207 1
a5207 1
	    /* now see which range will peter our first, if either. */
d5210 2
d5239 1
a5239 1
			     UNISKIP(tfirst) < UNISKIP(rfirst + diff));
a5272 3
	if (grows)
	    o->op_private |= OPpTRANS_GROWS;

d5276 8
a5283 8
#ifdef PERL_MAD
	op_getmad(expr,o,'e');
	op_getmad(repl,o,'r');
#else
	op_free(expr);
	op_free(repl);
#endif
	return o;
d5359 1
a5367 4
#ifdef PERL_MAD
    op_getmad(expr,o,'e');
    op_getmad(repl,o,'r');
#else
a5369 1
#endif
d5378 1
a5378 1
I<type> is the opcode.  I<flags> gives the eight bits of C<op_flags>
d5390 2
a5391 1
    assert((PL_opargs[type] & OA_CLASS_MASK) == OA_PMOP);
d5394 1
a5394 2
    pmop->op_type = (OPCODE)type;
    pmop->op_ppaddr = PL_ppaddr[type];
d5397 2
d5402 2
a5403 1
    if (IN_LOCALE_COMPILETIME) {
d5406 3
a5408 4
    else if ((! (PL_hints & HINT_BYTES))
                /* Both UNI_8_BIT and locale :not_characters imply Unicode */
	     && (PL_hints & (HINT_UNI_8_BIT|HINT_LOCALE_NOT_CHARS)))
    {
d5451 15
d5474 1
a5474 2
 * if the pattern contains more than one term (eg /a$b/) or if it contains
 * a replacement, ie s/// or tr///.
d5482 1
a5482 1
Perl_pmruntime(pTHX_ OP *o, OP *expr, bool isreg, I32 floor)
a5483 1
    dVAR;
a5486 1
    OP* repl = NULL;
a5492 17
    /* for s/// and tr///, last element in list is the replacement; pop it */

    /* If we have a syntax error causing tokens to be popped and the parser
       to see PMFUNC '(' expr ')' with no commas in it; e.g., s/${<>{})//,
       then expr will not be of type OP_LIST, there being no repl.  */
    if ((is_trans || o->op_type == OP_SUBST) && expr->op_type == OP_LIST) {
	OP* kid;
	repl = cLISTOPx(expr)->op_last;
	kid = cLISTOPx(expr)->op_first;
	while (kid->op_sibling != repl)
	    kid = kid->op_sibling;
	kid->op_sibling = NULL;
	cLISTOPx(expr)->op_last = kid;
    }

    /* for TRANS, convert LIST/PUSH/CONST into CONST, and pass to pmtrans() */

d5494 1
a5494 10
	OP* const oe = expr;
	assert(expr->op_type == OP_LIST);
	assert(cLISTOPx(expr)->op_first->op_type == OP_PUSHMARK);
	assert(cLISTOPx(expr)->op_first->op_sibling == cLISTOPx(expr)->op_last);
	expr = cLISTOPx(oe)->op_last;
	cLISTOPx(oe)->op_first->op_sibling = NULL;
	cLISTOPx(oe)->op_last = NULL;
	op_free(oe);

	return pmtrans(o, expr, repl);
d5507 1
a5507 1
	for (o = cLISTOPx(expr)->op_first; o; o = o->op_sibling) {
d5510 10
a5519 2
		assert(!o->op_next && o->op_sibling);
		o->op_next = o->op_sibling;
d5535 1
a5535 1
	for (o = cLISTOPx(expr)->op_first; o; o = o->op_sibling) {
d5554 2
a5555 2
		assert(leaveop->op_first->op_sibling);
		o->op_next = leaveop->op_first->op_sibling;
d5573 1
a5573 1
            S_prune_chain_head(aTHX_ &(o->op_next));
d5610 1
a5610 1
		PADOFFSET i = 0;
a5628 3
#ifdef PERL_MAD
	    op_getmad(expr,(OP*)pm,'e');
#else
a5629 1
#endif
a5710 1
	     *                         pushmark (for refgen)
d5712 1
a5712 1
	     *                         refgen
d5731 1
a5731 1
	    expr = list(force_list(newUNOP(OP_ENTERSUB, 0, scalar(expr))));
d5734 3
a5736 9
	NewOp(1101, rcop, 1, LOGOP);
	rcop->op_type = OP_REGCOMP;
	rcop->op_ppaddr = PL_ppaddr[OP_REGCOMP];
	rcop->op_first = scalar(expr);
	rcop->op_flags |= OPf_KIDS
			    | ((PL_hints & HINT_RE_EVAL) ? OPf_SPECIAL : 0)
			    | (reglist ? OPf_STACKED : 0);
	rcop->op_private = 0;
	rcop->op_other = o;
d5740 2
a5741 1
	if (PL_hints & HINT_RE_EVAL) PL_cv_has_eval = 1;
d5763 4
a5766 2
	 && cUNOPx(curop)->op_first->op_type == OP_SCOPE
	 && cUNOPx(curop)->op_first->op_flags & OPf_KIDS) {
d5768 3
a5770 3
	    if (kid->op_type == OP_NULL && kid->op_sibling
	     && !kid->op_sibling->op_sibling)
		curop = kid->op_sibling;
d5798 1
a5798 5
	    NewOp(1101, rcop, 1, LOGOP);
	    rcop->op_type = OP_SUBSTCONT;
	    rcop->op_ppaddr = PL_ppaddr[OP_SUBSTCONT];
	    rcop->op_first = scalar(repl);
	    rcop->op_flags |= OPf_KIDS;
a5799 1
	    rcop->op_other = o;
d5819 2
a5820 2
embedded SV.  I<type> is the opcode.  I<flags> gives the eight bits
of C<op_flags>.  I<sv> gives the SV to embed in the op; this function
d5836 2
a5837 1
	|| (PL_opargs[type] & OA_CLASS_MASK) == OA_FILESTATOP);
d5840 1
a5840 2
    svop->op_type = (OPCODE)type;
    svop->op_ppaddr = PL_ppaddr[type];
d5852 14
d5872 1
a5872 1
reference to a pad element.  I<type> is the opcode.  I<flags> gives the
d5874 1
a5874 1
is populated with I<sv>; this function takes ownership of one reference
d5892 2
a5893 1
	|| (PL_opargs[type] & OA_CLASS_MASK) == OA_FILESTATOP);
d5896 3
a5898 3
    padop->op_type = (OPCODE)type;
    padop->op_ppaddr = PL_ppaddr[type];
    padop->op_padix = pad_alloc(type, SVs_PADTMP);
d5917 2
a5918 2
embedded reference to a GV.  I<type> is the opcode.  I<flags> gives the
eight bits of C<op_flags>.  I<gv> identifies the GV that the op should
a5927 2
    dVAR;

a5930 1
    GvIN_PAD_on(gv);
d5941 2
a5942 2
embedded C-level pointer (PV).  I<type> is the opcode.  I<flags> gives
the eight bits of C<op_flags>.  I<pv> supplies the C-level pointer, which
d5959 1
a5959 1
	|| type == OP_RUNCV
d5963 1
a5963 2
    pvop->op_type = (OPCODE)type;
    pvop->op_ppaddr = PL_ppaddr[type];
a5974 3
#ifdef PERL_MAD
OP*
#else
a5975 1
#endif
a5977 1
    dVAR;
a5978 3
#ifdef PERL_MAD
    OP *pegop;
#endif
a5990 1
    PL_parser->expect = XSTATE;
a5991 1
#ifndef PERL_MAD
a5992 10
#else
    if (!PL_madskills) {
	op_free(o);
	return NULL;
    }

    pegop = newOP(OP_NULL,0);
    op_getmad(o,pegop,'P');
    return pegop;
#endif
a5997 1
    dVAR;
a6005 3
#ifdef PERL_MAD
OP*
#else
a6006 1
#endif
a6008 1
    dVAR;
a6011 3
#ifdef PERL_MAD
    OP *pegop = PL_madskills ? newOP(OP_NULL,0) : NULL;
#endif
a6018 3
    if (PL_madskills)
	op_getmad(idop,pegop,'U');

a6023 2
	if (PL_madskills)
	    op_getmad(version,pegop,'V');
d6039 1
a6039 1
	    veop = convert(OP_ENTERSUB, OPf_STACKED|OPf_SPECIAL,
d6041 2
a6042 2
					op_prepend_elem(OP_LIST, pack, list(version)),
					newSVOP(OP_METHOD_NAMED, 0, meth)));
a6047 2
	if (PL_madskills)
	    op_getmad(arg,pegop,'S');
a6059 3
	if (PL_madskills)
	    op_getmad(arg,pegop,'A');

d6066 1
a6066 1
	imop = convert(OP_ENTERSUB, OPf_STACKED|OPf_SPECIAL,
d6068 3
a6070 2
				   op_prepend_elem(OP_LIST, pack, list(arg)),
				   newSVOP(OP_METHOD_NAMED, 0, meth)));
d6130 1
a6130 8
    PL_parser->expect = XSTATE;
    PL_cop_seqmax++; /* Purely for B::*'s benefit */
    if (PL_cop_seqmax == PERL_PADSEQ_INTRO) /* not a legal value */
	PL_cop_seqmax++;

#ifdef PERL_MAD
    return pegop;
#endif
d6141 1
a6141 1
PERL_LOADMOD_DENY, PERL_LOADMOD_NOIMPORT, or PERL_LOADMOD_IMPORT_OPS
d6145 1
a6145 1
arguments can be used to specify arguments to the module's import()
d6147 3
a6149 3
terminated with a final NULL pointer.  Note that this list can only
be omitted when the PERL_LOADMOD_NOIMPORT flag has been used.
Otherwise at least a single NULL pointer to designate the default
a6183 1
    dVAR;
a6237 1
    dVAR;
d6257 1
a6257 1
Constructs, checks, and returns an C<lslice> (list slice) op.  I<flags>
d6261 1
a6261 1
set as required.  I<listval> and I<subscript> supply the parameters of
d6272 2
a6273 2
	    list(force_list(subscript)),
	    list(force_list(listval)) );
d6276 3
d6280 1
a6280 1
S_is_list_assignment(pTHX_ const OP *o)
d6284 1
d6295 7
a6301 6
        const I32 t = is_list_assignment(cLOGOPo->op_first->op_sibling);
        const I32 f = is_list_assignment(cLOGOPo->op_first->op_sibling->op_sibling);

	if (t && f)
	    return TRUE;
	if (t || f)
d6306 13
d6322 1
a6322 1
	return FALSE;
d6327 1
a6327 1
        type == OP_KVASLICE || type == OP_KVHSLICE)
d6334 1
a6334 62
	return FALSE;

    return FALSE;
}

/*
  Helper function for newASSIGNOP to detection commonality between the
  lhs and the rhs.  Marks all variables with PL_generation.  If it
  returns TRUE the assignment must be able to handle common variables.
*/
PERL_STATIC_INLINE bool
S_aassign_common_vars(pTHX_ OP* o)
{
    OP *curop;
    for (curop = cUNOPo->op_first; curop; curop=curop->op_sibling) {
	if (PL_opargs[curop->op_type] & OA_DANGEROUS) {
	    if (curop->op_type == OP_GV) {
		GV *gv = cGVOPx_gv(curop);
		if (gv == PL_defgv
		    || (int)GvASSIGN_GENERATION(gv) == PL_generation)
		    return TRUE;
		GvASSIGN_GENERATION_set(gv, PL_generation);
	    }
	    else if (curop->op_type == OP_PADSV ||
		curop->op_type == OP_PADAV ||
		curop->op_type == OP_PADHV ||
		curop->op_type == OP_PADANY)
		{
		    if (PAD_COMPNAME_GEN(curop->op_targ)
			== (STRLEN)PL_generation)
			return TRUE;
		    PAD_COMPNAME_GEN_set(curop->op_targ, PL_generation);

		}
	    else if (curop->op_type == OP_RV2CV)
		return TRUE;
	    else if (curop->op_type == OP_RV2SV ||
		curop->op_type == OP_RV2AV ||
		curop->op_type == OP_RV2HV ||
		curop->op_type == OP_RV2GV) {
		if (cUNOPx(curop)->op_first->op_type != OP_GV)	/* funny deref? */
		    return TRUE;
	    }
	    else if (curop->op_type == OP_PUSHRE) {
		GV *const gv =
#ifdef USE_ITHREADS
		    ((PMOP*)curop)->op_pmreplrootu.op_pmtargetoff
			? MUTABLE_GV(PAD_SVl(((PMOP*)curop)->op_pmreplrootu.op_pmtargetoff))
			: NULL;
#else
		    ((PMOP*)curop)->op_pmreplrootu.op_pmtargetgv;
#endif
		if (gv) {
		    if (gv == PL_defgv
			|| (int)GvASSIGN_GENERATION(gv) == PL_generation)
			return TRUE;
		    GvASSIGN_GENERATION_set(gv, PL_generation);
		}
	    }
	    else
		return TRUE;
	}
d6336 1
a6336 6
	if (curop->op_flags & OPf_KIDS) {
	    if (aassign_common_vars(curop))
		return TRUE;
	}
    }
    return FALSE;
d6339 1
d6343 1
a6343 1
Constructs, checks, and returns an assignment op.  I<left> and I<right>
d6347 2
a6348 2
If I<optype> is C<OP_ANDASSIGN>, C<OP_ORASSIGN>, or C<OP_DORASSIGN>, then
a suitable conditional optree is constructed.  If I<optype> is the opcode
d6351 1
a6351 1
Either way, if I<optype> is non-zero then I<flags> has no effect.
d6353 1
a6353 1
If I<optype> is zero, then a plain scalar or list assignment is
d6355 1
a6355 1
I<flags> gives the eight bits of C<op_flags>, except that C<OPf_KIDS>
a6365 1
    dVAR;
d6367 1
d6381 1
a6381 1
    if (is_list_assignment(left)) {
a6384 1
	bool maybe_common_vars = TRUE;
d6391 2
a6392 2
	curop = list(force_list(left));
	o = newBINOP(OP_AASSIGN, flags, list(force_list(right)), curop);
a6397 1
	    maybe_common_vars = FALSE;
d6399 8
a6406 29
		if (lop->op_type == OP_PADSV ||
		    lop->op_type == OP_PADAV ||
		    lop->op_type == OP_PADHV ||
		    lop->op_type == OP_PADANY) {
		    if (!(lop->op_private & OPpLVAL_INTRO))
			maybe_common_vars = TRUE;

		    if (lop->op_private & OPpPAD_STATE) {
			if (left->op_private & OPpLVAL_INTRO) {
			    /* Each variable in state($a, $b, $c) = ... */
			}
			else {
			    /* Each state variable in
			       (state $a, my $b, our $c, $d, undef) = ... */
			}
			yyerror(no_list_state);
		    } else {
			/* Each my variable in
			   (state $a, my $b, our $c, $d, undef) = ... */
		    }
		} else if (lop->op_type == OP_UNDEF ||
                           OP_TYPE_IS_OR_WAS(lop, OP_PUSHMARK)) {
		    /* undef may be interesting in
		       (state $a, undef, state $c) */
		} else {
		    /* Other ops in the list. */
		    maybe_common_vars = TRUE;
		}
		lop = lop->op_sibling;
d6409 2
a6410 1
	else if ((left->op_private & OPpLVAL_INTRO)
d6414 2
a6415 4
		    || left->op_type == OP_PADANY))
	{
	    if (left->op_type == OP_PADSV) maybe_common_vars = FALSE;
	    if (left->op_private & OPpPAD_STATE) {
a6426 22
	    }
	}

	/* PL_generation sorcery:
	 * an assignment like ($a,$b) = ($c,$d) is easier than
	 * ($a,$b) = ($c,$a), since there is no need for temporary vars.
	 * To detect whether there are common vars, the global var
	 * PL_generation is incremented for each assign op we compile.
	 * Then, while compiling the assign op, we run through all the
	 * variables on both sides of the assignment, setting a spare slot
	 * in each of them to PL_generation. If any of them already have
	 * that value, we know we've got commonality.  We could use a
	 * single bit marker, but then we'd have to make 2 passes, first
	 * to clear the flag, then to test and set it.  To find somewhere
	 * to store these values, evil chicanery is done with SvUVX().
	 */

	if (maybe_common_vars) {
	    PL_generation++;
	    if (aassign_common_vars(o))
		o->op_private |= OPpASSIGN_COMMON;
	    LINKLIST(o);
d6429 2
a6430 1
	if (right && right->op_type == OP_SPLIT && !PL_madskills) {
d6432 3
a6434 8
	    if (tmpop && (tmpop->op_type == OP_PUSHRE)) {
		PMOP * const pm = (PMOP*)tmpop;
		if (left->op_type == OP_RV2AV &&
		    !(left->op_private & OPpLVAL_INTRO) &&
		    !(o->op_private & OPpASSIGN_COMMON) )
		{
		    tmpop = ((UNOP*)left)->op_first;
		    if (tmpop->op_type == OP_GV
d6436 1
a6436 1
			&& !pm->op_pmreplrootu.op_pmtargetoff
d6438 1
a6438 1
			&& !pm->op_pmreplrootu.op_pmtargetgv
d6440 6
d6447 1
d6449 1
a6449 1
			pm->op_pmreplrootu.op_pmtargetoff
d6451 1
a6451 1
			cPADOPx(tmpop)->op_padix = 0;	/* steal it */
d6453 1
a6453 1
			pm->op_pmreplrootu.op_pmtargetgv
d6455 1
a6455 1
			cSVOPx(tmpop)->op_sv = NULL;	/* steal it */
d6457 8
d6467 3
a6469 2
			tmpop->op_sibling = NULL;	/* don't free split */
			right->op_next = tmpop->op_next;  /* fix starting loc */
d6475 20
a6494 4
		}
		else {
                   if (PL_modcount < RETURN_UNLIMITED_NUMBER &&
		      ((LISTOP*)right)->op_last->op_type == OP_CONST)
a6512 1
		}
d6517 2
d6539 1
a6539 1
If I<label> is non-null, it supplies the name of a label to attach to
d6541 1
a6541 1
I<label>, and will free it.  I<flags> gives the eight bits of C<op_flags>
d6544 2
a6545 2
If I<o> is null, the state op is returned.  Otherwise the state op is
combined with I<o> into a C<lineseq> list op, which is returned.  I<o>
d6559 2
d6565 1
a6565 2
	cop->op_type = OP_DBSTATE;
	cop->op_ppaddr = PL_ppaddr[ OP_DBSTATE ];
d6568 1
a6568 2
	cop->op_type = OP_NEXTSTATE;
	cop->op_ppaddr = PL_ppaddr[ OP_NEXTSTATE ];
a6571 3
#ifdef NATIVE_HINTS
    cop->op_private |= NATIVE_HINTS;
#endif
d6627 2
a6628 2
Constructs, checks, and returns a logical (flow control) op.  I<type>
is the opcode.  I<flags> gives the eight bits of C<op_flags>, except
d6631 2
a6632 2
automatically set.  I<first> supplies the expression controlling the
flow, and I<other> supplies the side (alternate) chain of ops; they are
a6640 2
    dVAR;

d6671 1
a6671 1
			kid = kid->op_sibling;
d6681 1
a6681 1
last:
d6746 2
a6747 1
    assert((PL_opargs[type] & OA_CLASS_MASK) == OA_LOGOP);
d6755 1
a6755 1
	&& !PL_madskills) {
a6779 6
	    if (PL_madskills) {
		OP *newop = newUNOP(OP_NULL, 0, other);
		op_getmad(first, newop, '1');
		newop->op_targ = type;	/* set "was" field */
		return newop;
	    }
d6799 1
a6799 1
		    && (( o2 = o2->op_sibling)) )
d6814 1
a6814 7
	    if (PL_madskills) {
		first = newUNOP(OP_NULL, 0, first);
		op_getmad(other, first, '2');
		first->op_targ = type;	/* set "was" field */
	    }
	    else
		op_free(other);
d6822 1
a6822 1
	const OP * const k2 = k1->op_sibling;
d6867 2
a6868 7
    NewOp(1101, logop, 1, LOGOP);

    logop->op_type = (OPCODE)type;
    logop->op_ppaddr = PL_ppaddr[type];
    logop->op_first = first;
    logop->op_flags = (U8)(flags | OPf_KIDS);
    logop->op_other = LINKLIST(other);
d6874 2
a6875 1
    first->op_sibling = other;
d6879 3
a6881 1
    o = newUNOP(prepend_not ? OP_NOT : OP_NULL, 0, (OP*)logop);
d6891 1
a6891 1
op.  I<flags> gives the eight bits of C<op_flags>, except that C<OPf_KIDS>
d6894 2
a6895 2
I<first> supplies the expression selecting between the two branches,
and I<trueop> and I<falseop> supply the branches; they are consumed by
d6927 2
a6928 9
	if (PL_madskills) {
	    /* This is all dead code when PERL_MAD is not defined.  */
	    live = newUNOP(OP_NULL, 0, live);
	    op_getmad(first, live, 'C');
	    op_getmad(dead, live, left ? 'e' : 't');
	} else {
	    op_free(first);
	    op_free(dead);
	}
d6938 2
a6939 5
    NewOp(1101, logop, 1, LOGOP);
    logop->op_type = OP_COND_EXPR;
    logop->op_ppaddr = PL_ppaddr[OP_COND_EXPR];
    logop->op_first = first;
    logop->op_flags = (U8)(flags | OPf_KIDS);
a6940 1
    logop->op_other = LINKLIST(trueop);
d6950 4
a6953 2
    first->op_sibling = trueop;
    trueop->op_sibling = falseop;
d6966 1
a6966 1
C<flop> ops.  I<flags> gives the eight bits of C<op_flags> for the
d6969 1
a6969 1
1 is automatically set.  I<left> and I<right> supply the expressions
a6978 1
    dVAR;
d6987 1
a6987 5
    NewOp(1101, range, 1, LOGOP);

    range->op_type = OP_RANGE;
    range->op_ppaddr = PL_ppaddr[OP_RANGE];
    range->op_first = left;
a6989 1
    range->op_other = LINKLIST(right);
d6992 2
a6993 1
    left->op_sibling = right;
d7005 2
a7006 1
    range->op_targ = pad_alloc(OP_RANGE, SVs_PADMY);
d7008 2
a7009 1
    flip->op_targ = pad_alloc(OP_RANGE, SVs_PADMY);
d7011 1
d7035 1
a7035 1
and suchlike.  I<flags> gives the eight bits of C<op_flags> for the
d7037 1
a7037 1
I<expr> supplies the expression controlling loop iteration, and I<block>
d7039 1
a7039 1
become part of the constructed op tree.  I<debuggable> is currently
a7047 1
    dVAR;
d7075 1
a7075 1
	    const OP * const k2 = k1 ? k1->op_sibling : NULL;
d7122 1
a7122 1
    o->op_flags |= OPf_SPECIAL;	/* suppress POPBLOCK curpm restoration*/
d7133 1
a7133 1
I<loop> is an optional preconstructed C<enterloop> op to use in the
d7135 2
a7136 2
I<expr> supplies the loop's controlling expression.  I<block> supplies the
main body of the loop, and I<cont> optionally supplies a C<continue> block
d7140 1
a7140 1
I<flags> gives the eight bits of C<op_flags> for the C<leaveloop>
d7143 2
a7144 2
automatically.  I<debuggable> is currently unused and should always be 1.
I<has_my> can be supplied as true to force the
d7173 1
a7173 1
	    const OP * const k2 = (k1) ? k1->op_sibling : NULL;
d7231 1
a7231 2
	loop->op_type = OP_ENTERLOOP;
	loop->op_ppaddr = PL_ppaddr[OP_ENTERLOOP];
d7259 4
a7262 4
I<sv> optionally supplies the variable that will be aliased to each
item in turn; if null, it defaults to C<$_> (either lexical or global).
I<expr> supplies the list of values to iterate over.  I<block> supplies
the main body of the loop, and I<cont> optionally supplies a C<continue>
d7267 1
a7267 1
I<flags> gives the eight bits of C<op_flags> for the C<leaveloop>
a7283 1
    OP *madsv = NULL;
d7290 1
a7290 2
	    sv->op_type = OP_RV2GV;
	    sv->op_ppaddr = PL_ppaddr[OP_RV2GV];
d7305 2
a7306 6
	    if (PL_madskills)
		madsv = sv;
	    else {
		sv->op_targ = 0;
		op_free(sv);
	    }
d7308 1
d7310 2
d7315 2
a7316 3
	    SV *const namesv = PAD_COMPNAME_SV(padoff);
	    STRLEN len;
	    const char *const name = SvPV_const(namesv, len);
d7318 1
a7318 1
	    if (len == 2 && name[0] == '$' && name[1] == '_')
d7323 1
a7323 7
        const PADOFFSET offset = pad_findmy_pvs("$_", 0);
	if (offset == NOT_IN_PAD || PAD_COMPNAME_FLAGS_isOUR(offset)) {
	    sv = newGVOP(OP_GV, 0, PL_defgv);
	}
	else {
	    padoff = offset;
	}
d7326 1
d7328 1
a7328 1
	expr = op_lvalue(force_list(scalar(ref(expr, OP_ITER))), OP_GREPSTART);
d7342 1
a7342 1
	OP* const right = left->op_sibling;
d7346 2
a7347 1
	range->op_first = NULL;
a7354 3
#ifdef PERL_MAD
	op_getmad(expr,(OP*)listop,'O');
#else
a7355 1
#endif
d7361 1
a7361 1
        expr = op_lvalue(force_list(expr), OP_GREPSTART);
d7364 3
a7366 2
    loop = (LOOP*)list(convert(OP_ENTERITER, iterflags,
			       op_append_elem(OP_LIST, expr, scalar(sv))));
d7378 4
d7386 1
d7388 4
a7393 2
    if (madsv)
	op_getmad(madsv, (OP*)loop, 'v');
d7401 1
a7401 1
or C<last>).  I<type> is the opcode.  I<label> supplies the parameter
a7410 1
    dVAR;
d7415 2
a7416 1
    assert((PL_opargs[type] & OA_CLASS_MASK) == OA_LOOPEXOP);
a7445 3
#ifdef PERL_MAD
		op_getmad(label,o,'L');
#else
a7446 1
#endif
d7475 1
a7475 1
	cond->op_flags |= ~(OPf_WANT_SCALAR | OPf_REF);
d7505 1
d7507 2
a7508 5
    NewOp(1101, enterop, 1, LOGOP);
    enterop->op_type = (Optype)enter_opcode;
    enterop->op_ppaddr = PL_ppaddr[enter_opcode];
    enterop->op_flags =  (U8) OPf_KIDS;
    enterop->op_targ = ((entertarg == NOT_IN_PAD) ? 0 : entertarg);
d7514 2
a7515 2
	enterop->op_first = scalar(cond);
	cond->op_sibling = block;
a7521 1
	enterop->op_first = block;
a7551 2
    dVAR;

d7560 3
d7565 2
a7566 1
	     && looks_like_bool(cLOGOPo->op_first->op_sibling));
d7614 1
a7614 1
	/* FALL THROUGH */
d7624 2
a7625 2
I<cond> supplies the expression that will be locally assigned to a lexical
variable, and I<block> supplies the body of the C<given> construct; they
d7627 1
a7627 2
I<defsv_off> is the pad offset of the scalar lexical variable that will
be affected.  If it is 0, the global $_ will be used.
a7634 1
    dVAR;
d7636 3
d7643 1
a7643 1
	defsv_off);
d7650 1
a7650 1
I<cond> supplies the test expression, and I<block> supplies the block
d7652 1
a7652 1
by this function and become part of the constructed op tree.  I<cond>
d7678 3
d7686 5
a7690 1
    const char * cvp = SvROK(cv) ? "" : CvPROTO(cv);
d7727 10
d7766 1
a7766 1
value returned by the sub.  Otherwise, returns NULL.
d7774 1
a7774 1
Perl_cv_const_sv(pTHX_ const CV *const cv)
a7776 1
    PERL_UNUSED_CONTEXT;
d7787 1
a7787 1
Perl_cv_const_sv_or_av(pTHX_ const CV * const cv)
a7788 1
    PERL_UNUSED_CONTEXT;
d7791 1
d7797 1
a7797 1
 * Can be called in 3 ways:
d7799 1
a7799 1
 * !cv
d7802 1
a7802 1
 * cv && CvCLONE(cv) && !CvCONST(cv)
d7805 3
a7807 10
 * 	OP_CONST referencing a pad const, or a single PADSV referencing
 * 	an outer lexical, return a non-zero value to indicate the CV is
 * 	a candidate for "constizing" at clone time
 *
 * cv && CvCONST(cv)
 *
 *	We have just cloned an anon prototype that was marked as a const
 *	candidate. Try to grab the current value, and in the case of
 *	PADSV, ignore it if it has multiple references. In this case we
 *	return a newly created *copy* of the value.
d7810 2
a7811 2
SV *
Perl_op_const_sv(pTHX_ const OP *o, CV *cv)
a7812 1
    dVAR;
d7814 1
d7816 2
a7817 8
    if (PL_madskills)
	return NULL;

    if (!o)
	return NULL;

    if (o->op_type == OP_LINESEQ && cLISTOPo->op_first)
	o = cLISTOPo->op_first->op_sibling;
d7822 2
a7823 5
	if (sv && o->op_next == o)
	    return sv;
	if (o->op_next != o) {
	    if (type == OP_NEXTSTATE
	     || (type == OP_NULL && !(o->op_flags & OPf_KIDS))
d7826 1
a7826 1
	    if (type == OP_DBSTATE)
d7828 1
a7828 2
	}
	if (type == OP_LEAVESUB || type == OP_RETURN)
d7834 3
a7836 4
	else if (cv && type == OP_CONST) {
	    sv = PAD_BASE_SV(CvPADLIST(cv), o->op_targ);
	    if (!sv)
		return NULL;
d7838 7
a7844 6
	else if (cv && type == OP_PADSV) {
	    if (CvCONST(cv)) { /* newly cloned anon */
		sv = PAD_BASE_SV(CvPADLIST(cv), o->op_targ);
		/* the candidate should have 1 ref from this pad and 1 ref
		 * from the parent */
		if (!sv || SvREFCNT(sv) != 2)
a7845 8
		sv = newSVsv(sv);
		SvREADONLY_on(sv);
		return sv;
	    }
	    else {
		if (PAD_COMPNAME_FLAGS(o->op_targ) & SVf_FAKE)
		    sv = &PL_sv_undef; /* an arbitrary non-null value */
	    }
d7851 4
a7865 3
#ifdef PERL_MAD
	 || block->op_type == OP_NULL
#endif
d7903 1
a7903 7
#ifdef PERL_MAD
    if (!PL_minus_c)	/* keep old one around for madskills */
#endif
    {
	/* (PL_madskills unset in used file.) */
	SAVEFREESV(cv);
    }
a7909 1
    dVAR;
d7924 4
d7952 1
a7952 1
        move_proto_attr(&proto, &attrs, (GV *)name);
d7962 4
a7965 6
    if (!PL_madskills) {
	if (proto)
	    SAVEFREEOP(proto);
	if (attrs)
	    SAVEFREEOP(attrs);
    }
a7980 3
	MAGIC *mg;
	SvUPGRADE(name, SVt_PVMG);
	mg = mg_find(name, PERL_MAGIC_proto);
d7985 3
d7991 2
a7992 1
		    PadnameLEN(name)-1 * (PadnameUTF8(name) ? -1 : 1), 0
d7995 1
d7997 11
a8007 3
	if (mg) {
	    assert(mg->mg_obj);
	    cv = (CV *)mg->mg_obj;
d8009 11
a8019 5
	else {
	    sv_magic(name, &PL_sv_undef, PERL_MAGIC_proto, NULL, 0);
	    mg = mg_find(name, PERL_MAGIC_proto);
	}
	spot = (CV **)(svspot = &mg->mg_obj);
a8020 8

    if (!block || !ps || *ps || attrs
	|| (CvFLAGS(compcv) & CVf_BUILTIN_ATTRS)
#ifdef PERL_MAD
	|| block->op_type == OP_NULL
#endif
	)
	const_sv = NULL;
d8022 1
a8022 1
	const_sv = op_const_sv(block, NULL);
d8032 2
a8033 1
            cv_ckproto_len_flags(cv, (GV *)name, ps, ps_len, ps_utf8);
d8052 1
a8052 1
	SvFLAGS(const_sv) = (SvFLAGS(const_sv) & ~SVs_PADMY) | SVs_PADTMP;
d8068 2
a8069 2
	if (PL_madskills)
	    goto install_block;
a8089 3
#ifdef PERL_MAD
                  && block->op_type != OP_NULL
#endif
d8104 1
a8104 1
	    CvPADLIST(cv) = CvPADLIST(compcv);
d8106 1
a8106 1
	    CvPADLIST(compcv) = temp_padl;
d8134 1
d8136 10
a8145 7
	CvNAME_HEK_set(cv,
	 hek
	  ? share_hek_hek(hek)
	  : share_hek(PadnamePV(name)+1,
		      PadnameLEN(name)-1 * (PadnameUTF8(name) ? -1 : 1),
		      0)
	);
a8156 1
 install_block:
d8166 1
a8166 14
    /* This makes sub {}; work as expected.  */
    if (block->op_type == OP_STUB) {
	    OP* const newblock = newSTATEOP(0, NULL, 0);
#ifdef PERL_MAD
	    op_getmad(block,newblock,'B');
#else
	    op_free(block);
#endif
	    block = newblock;
    }
    CvROOT(cv) = CvLVALUE(cv)
		   ? newUNOP(OP_LEAVESUBLV, 0,
			     op_lvalue(scalarseq(block), OP_LEAVESUBLV))
		   : newUNOP(OP_LEAVESUB, 0, scalarseq(block));
d8173 5
a8177 3
    CvSTART(cv) = LINKLIST(CvROOT(cv));
    CvROOT(cv)->op_next = 0;
    CALL_PEEP(CvSTART(cv));
d8179 1
a8179 1
    S_prune_chain_head(aTHX_ &CvSTART(cv));
a8184 6
    if (CvCLONE(cv)) {
	assert(!CvCONST(cv));
	if (ps && !*ps && op_const_sv(block, cv))
	    CvCONST_on(cv);
    }

a8232 1
	SvPADMY_on(cv);
d8249 5
a8253 1
    if (o) op_free(o);
a8261 1
    dVAR;
d8272 1
a8272 1
       full GV and CV.  If anything is present then it will take a full CV to
d8276 1
a8276 2
	 (block || attrs || (CvFLAGS(PL_compcv) & CVf_BUILTIN_ATTRS)
	   || PL_madskills)
d8283 2
d8294 14
a8307 1
	gv = gv_fetchsv(cSVOPo->op_sv, gv_fetch_flags, SVt_PVCV);
d8323 8
a8330 3

    if (!ec)
        move_proto_attr(&proto, &attrs, gv);
d8340 6
a8345 8
    if (!PL_madskills) {
	if (o)
	    SAVEFREEOP(o);
	if (proto)
	    SAVEFREEOP(proto);
	if (attrs)
	    SAVEFREEOP(attrs);
    }
d8369 12
a8380 2
    if (SvTYPE(gv) != SVt_PVGV) {	/* Maybe prototype now, and had at
					   maximum a prototype before. */
d8386 2
a8387 1
	if (ps) {
d8390 2
a8391 2
        }
	else
d8393 1
d8398 1
d8401 7
a8407 1
    cv = (!name || GvCVGEN(gv)) ? NULL : GvCV(gv);
d8409 24
a8432 7
    if (!block || !ps || *ps || attrs
	|| (CvFLAGS(PL_compcv) & CVf_BUILTIN_ATTRS)
#ifdef PERL_MAD
	|| block->op_type == OP_NULL
#endif
	)
	const_sv = NULL;
d8434 32
a8465 1
	const_sv = op_const_sv(block, NULL);
d8477 1
a8477 1
	if (exists || GvASSUMECV(gv)) {
d8490 1
a8490 1
	SvFLAGS(const_sv) = (SvFLAGS(const_sv) & ~SVs_PADMY) | SVs_PADTMP;
d8499 2
d8503 18
a8520 5
	    GvCV_set(gv, NULL);
	    cv = newCONSTSUB_flags(
		NULL, name, namlen, name_is_utf8 ? SVf_UTF8 : 0,
		const_sv
	    );
a8521 2
	if (PL_madskills)
	    goto install_block;
a8529 3
#ifdef PERL_MAD
                  && block->op_type != OP_NULL
#endif
d8538 16
a8553 3
	    CvGV_set(cv,gv);
	    assert(!CvCVGV_RC(cv));
	    assert(CvGV(cv) == gv);
d8556 2
a8557 1
	    CvFLAGS(cv) = CvFLAGS(PL_compcv) | existing_builtin_attrs;
d8560 1
a8560 1
	    CvPADLIST(cv) = CvPADLIST(PL_compcv);
d8562 1
a8562 1
	    CvPADLIST(PL_compcv) = temp_av;
d8589 1
a8589 1
	if (name) {
d8596 9
d8606 12
a8617 2
    if (!CvGV(cv)) {
	CvGV_set(cv, gv);
a8626 1
 install_block:
d8636 1
a8636 14
    /* This makes sub {}; work as expected.  */
    if (block->op_type == OP_STUB) {
	    OP* const newblock = newSTATEOP(0, NULL, 0);
#ifdef PERL_MAD
	    op_getmad(block,newblock,'B');
#else
	    op_free(block);
#endif
	    block = newblock;
    }
    CvROOT(cv) = CvLVALUE(cv)
		   ? newUNOP(OP_LEAVESUBLV, 0,
			     op_lvalue(scalarseq(block), OP_LEAVESUBLV))
		   : newUNOP(OP_LEAVESUB, 0, scalarseq(block));
d8646 2
a8647 3
    CvSTART(cv) = LINKLIST(CvROOT(cv));
    CvROOT(cv)->op_next = 0;
    CALL_PEEP(CvSTART(cv));
d8649 1
a8649 1
    S_prune_chain_head(aTHX_ &CvSTART(cv));
a8654 6
    if (CvCLONE(cv)) {
	assert(!CvCONST(cv));
	if (ps && !*ps && op_const_sv(block, cv))
	    CvCONST_on(cv);
    }

d8658 3
a8660 1
	HV *stash = name && GvSTASH(CvGV(cv)) ? GvSTASH(CvGV(cv)) : PL_curstash;
d8668 1
a8668 1
	    SV * const tmpstr = sv_newmortal();
a8675 1
	    gv_efullname3(tmpstr, gv, NULL);
d8691 7
a8697 2
	if (name && ! (PL_parser && PL_parser->error_count))
	    process_special_blocks(floor, name, gv, cv);
d8704 1
d8706 2
a8707 2
    /* Watch out for BEGIN blocks */
    if (slab && gv && isGV(gv) && GvCV(gv)) Slab_to_ro(slab);
d8709 3
d8716 26
d8755 1
d8770 1
d8773 1
a8773 1
	    return;
d8780 1
a8780 1
		return;
d8787 1
a8787 1
		return;
d8797 1
a8797 1
		return;
d8807 1
a8807 1
		return;
d8809 1
a8809 1
	    return;
d8811 1
d8813 1
d8834 1
a8834 1
Creates a constant sub equivalent to Perl C<sub FOO () { 123 }> which is
d8837 1
a8837 1
Currently, the only useful value for C<flags> is SVf_UTF8.
d8842 1
a8842 1
Passing NULL for SV creates a constant sub equivalent to C<sub BAR () {}>,
a8853 1
    dVAR;
d8897 19
a8915 1
    return cv;
d8930 9
d8955 1
a8955 4
    
        if (!subaddr)
            Perl_croak(aTHX_ "panic: no address for '%s' in '%s'", name, filename);
    
d8990 1
a8990 2
        if (!name)
            CvANON_on(cv);
d8992 16
a9007 4
        (void)gv_fetchfile(filename);
        CvFILE(cv) = (char *)filename; /* NOTE: not copied, as it is expected to be
                                    an external constant string */
        assert(!CvDYNFILE(cv)); /* cv_undef should have turned it off */
d9010 6
a9015 1
    
d9018 4
a9021 1
    }
a9022 4
    if (flags & XS_DYNAMIC_FILENAME) {
	CvFILE(cv) = savepv(filename);
	CvDYNFILE_on(cv);
    }
a9050 21
/*
=for apidoc U||newXS

Used by C<xsubpp> to hook up XSUBs as Perl subs.  I<filename> needs to be
static storage, as it is used directly as CvFILE(), without a copy being made.

=cut
*/

CV *
Perl_newXS(pTHX_ const char *name, XSUBADDR_t subaddr, const char *filename)
{
    PERL_ARGS_ASSERT_NEWXS;
    return newXS_len_flags(
	name, name ? strlen(name) : 0, subaddr, filename, NULL, NULL, 0
    );
}

#ifdef PERL_MAD
OP *
#else
a9051 1
#endif
a9053 1
    dVAR;
a9054 3
#ifdef PERL_MAD
    OP* pegop = newOP(OP_NULL, 0);
#endif
d9099 1
a9099 1
    S_prune_chain_head(aTHX_ &CvSTART(cv));
a9102 4
#ifdef PERL_MAD
    op_getmad(o,pegop,'n');
    op_getmad_weak(block, pegop, 'b');
#else
a9103 1
#endif
d9107 1
a9107 3
#ifdef PERL_MAD
    return pegop;
#endif
d9113 1
a9113 1
    return convert(OP_ANONLIST, OPf_SPECIAL, o);
d9119 1
a9119 1
    return convert(OP_ANONHASH, OPf_SPECIAL, o);
d9131 2
a9132 1
    return newUNOP(OP_REFGEN, 0,
d9134 7
a9140 1
		MUTABLE_SV(newATTRSUB(floor, 0, proto, attrs, block))));
d9153 1
a9153 2
	o->op_type = OP_PADAV;
	o->op_ppaddr = PL_ppaddr[OP_PADAV];
d9158 1
a9158 2
	o->op_type = OP_RV2AV;
	o->op_ppaddr = PL_ppaddr[OP_RV2AV];
d9179 1
a9179 2
	o->op_type = OP_PADHV;
	o->op_ppaddr = PL_ppaddr[OP_PADHV];
d9184 1
a9184 2
	o->op_type = OP_RV2HV;
	o->op_ppaddr = PL_ppaddr[OP_RV2HV];
d9203 1
a9203 2
	o->op_type = OP_PADAV;
	o->op_ppaddr = PL_ppaddr[OP_PADAV];
d9207 1
a9207 2
	Perl_ck_warner_d(aTHX_ packWARN(WARN_DEPRECATED),
		       "Using an array as a reference is deprecated");
d9228 1
a9228 2
	o->op_type = OP_PADHV;
	o->op_ppaddr = PL_ppaddr[OP_PADHV];
d9232 1
a9232 2
	Perl_ck_warner_d(aTHX_ packWARN(WARN_DEPRECATED),
		       "Using a hash as a reference is deprecated");
d9242 1
a9242 2
	o->op_type = OP_PADCV;
	o->op_ppaddr = PL_ppaddr[OP_PADCV];
d9255 2
a9256 2
	o->op_type = OP_PADSV;
	o->op_ppaddr = PL_ppaddr[OP_PADSV];
d9271 1
a9271 2
    if (!PL_madskills)
	cSVOPo->op_sv = NULL;
d9278 1
d9287 2
d9291 3
a9293 1
	    else if (mode & O_TEXT)
d9295 1
d9303 2
d9307 3
a9309 1
	    else if (mode & O_TEXT)
d9311 1
d9314 4
d9325 1
d9328 6
a9333 4
    if (o->op_flags & OPf_KIDS && cUNOPo->op_first->op_sibling
     && (gv = gv_override("readpipe",8))) {
	newop = S_new_entersubop(aTHX_ gv, cUNOPo->op_first->op_sibling);
	cUNOPo->op_first->op_sibling = NULL;
a9337 3
#ifdef PERL_MAD
	op_getmad(o,newop,'O');
#else
a9338 1
#endif
a9347 2
    dVAR;

d9351 7
d9359 1
a9359 3
	    && (o->op_type == OP_BIT_OR
	     || o->op_type == OP_BIT_AND
	     || o->op_type == OP_BIT_XOR))
d9362 1
a9362 1
	const OP * const right = left->op_sibling;
d9368 9
a9376 3
			   "Possible precedence problem on bitwise %c operator",
			   o->op_type == OP_BIT_OR ? '|'
			   : o->op_type == OP_BIT_AND ? '&' : '^'
d9386 1
d9399 4
a9402 4
	if (kid && (
		(
		   is_dollar_bracket(aTHX_ kid)
		&& kid->op_sibling && kid->op_sibling->op_type == OP_CONST
d9404 5
a9408 3
	     || (  kid->op_type == OP_CONST
		&& (kid = kid->op_sibling) && is_dollar_bracket(aTHX_ kid))
	   ))
d9439 1
d9442 3
a9444 2
	kid = cUNOPo->op_first;
	newop = kUNOP->op_first->op_sibling;
d9447 9
a9455 3
	    if (newop->op_sibling || !(PL_opargs[type] & OA_RETSCALAR) ||
		    type == OP_PADAV || type == OP_PADHV ||
		    type == OP_RV2AV || type == OP_RV2HV)
d9458 3
a9460 6
#ifdef PERL_MAD
	op_getmad(kUNOP->op_first,newop,'K');
#else
	op_free(kUNOP->op_first);
#endif
	kUNOP->op_first = newop;
d9480 1
a9480 1
	    /* FALL THROUGH */
d9486 1
a9486 1
	    /* FALL THROUGH */
a9508 2
    dVAR;

a9515 3
#ifdef PERL_MAD
	    op_getmad(o,newop,'O');
#else
a9516 1
#endif
a9540 3
#ifdef PERL_MAD
	    OP* const oldo = o;
#endif
d9542 2
a9543 2
	    cUNOPo->op_first = 0;
#ifndef PERL_MAD
a9544 1
#endif
d9546 1
a9546 4
	    NewOp(1101, enter, 1, LOGOP);
	    enter->op_type = OP_ENTERTRY;
	    enter->op_ppaddr = PL_ppaddr[OP_ENTERTRY];
	    enter->op_private = 0;
d9552 1
a9552 2
	    o->op_type = OP_LEAVETRY;
	    o->op_ppaddr = PL_ppaddr[OP_LEAVETRY];
a9553 1
	    op_getmad(oldo,o,'O');
d9558 1
a9558 1
	    PL_cv_has_eval = 1;
a9562 3
#ifdef PERL_MAD
	OP* const oldo = o;
#else
d9564 5
a9568 3
#endif
	o = newUNOP(OP_ENTEREVAL, priv <<8, newDEFSVOP());
	op_getmad(oldo,o,'O');
d9577 3
a9579 1
	cUNOPo->op_first->op_sibling = hhop;
d9596 1
a9596 1
	kid = cUNOPo->op_first->op_sibling;
a9607 2
    dVAR;

a9639 2
    if (o->op_type == OP_RV2CV)
	o->op_private &= ~1;
d9647 1
a9647 25
	if (SvROK(kidsv) && SvREADONLY(kidsv)) {
	    SV * const rsv = SvRV(kidsv);
	    const svtype type = SvTYPE(rsv);
            const char *badtype = NULL;

	    switch (o->op_type) {
	    case OP_RV2SV:
		if (type > SVt_PVMG)
		    badtype = "a SCALAR";
		break;
	    case OP_RV2AV:
		if (type != SVt_PVAV)
		    badtype = "an ARRAY";
		break;
	    case OP_RV2HV:
		if (type != SVt_PVHV)
		    badtype = "a HASH";
		break;
	    case OP_RV2CV:
		if (type != SVt_PVCV)
		    badtype = "a CODE";
		break;
	    }
	    if (badtype)
		Perl_croak(aTHX_ "Constant is not %s reference", badtype);
d9680 6
a9685 4
	iscv = (o->op_type == OP_RV2CV) * 2;
	do {
	    gv = gv_fetchsv(kidsv,
		iscv | !(kid->op_private & OPpCONST_ENTERED),
a9694 1
	} while (!gv && !(kid->op_private & OPpCONST_ENTERED) && !iscv++);
d9696 8
a9703 1
	    kid->op_type = OP_GV;
d9707 2
a9708 2
	    assert (sizeof(PADOP) <= sizeof(SVOP));
	    kPADOP->op_padix = pad_alloc(OP_GV, SVs_PADTMP);
a9709 1
	    GvIN_PAD_on(gv);
a9714 1
	    kid->op_ppaddr = PL_ppaddr[OP_GV];
a9740 3
#ifdef PERL_MAD
	    op_getmad(o,newop,'O');
#else
a9741 1
#endif
d9744 14
d9760 4
a9763 2
	if (PL_check[kidtype] == Perl_ck_ftst
	        && kidtype != OP_STAT && kidtype != OP_LSTAT) {
a9773 3
#ifdef PERL_MAD
	OP* const oldo = o;
#else
a9774 1
#endif
a9778 1
	op_getmad(oldo,o,'O');
a9785 1
    dVAR;
d9799 1
a9799 1
        OP **tokid = &cLISTOPo->op_first;
a9800 1
        OP *sibl;
d9807 2
a9808 2
	    tokid = &kid->op_sibling;
	    kid = kid->op_sibling;
d9823 5
a9827 2
		if (!kid && !seen_optional && PL_opargs[type] & OA_DEFGV)
		    *tokid = kid = newDEFSVOP();
a9832 7
	    sibl = kid->op_sibling;
#ifdef PERL_MAD
	    if (!sibl && kid->op_type == OP_STUB) {
		numargs--;
		break;
	    }
#endif
d9853 1
a9853 1
		    && !kid->op_sibling)
d9858 1
a9858 18
		if (kid->op_type == OP_CONST &&
		    (kid->op_private & OPpCONST_BARE))
		{
		    OP * const newop = newAVREF(newGVOP(OP_GV, 0,
			gv_fetchsv(((SVOP*)kid)->op_sv, GV_ADD, SVt_PVAV) ));
		    Perl_ck_warner_d(aTHX_ packWARN(WARN_DEPRECATED),
				   "Array @@%"SVf" missing the @@ in argument %"IVdf" of %s()",
				   SVfARG(((SVOP*)kid)->op_sv), (IV)numargs, PL_op_desc[type]);
#ifdef PERL_MAD
		    op_getmad(kid,newop,'K');
#else
		    op_free(kid);
#endif
		    kid = newop;
		    kid->op_sibling = sibl;
		    *tokid = kid;
		}
		else if (kid->op_type == OP_CONST
d9862 4
a9865 11
		    bad_type_pv(numargs, "array", PL_op_desc[type], 0, kid);
		/* Defer checks to run-time if we have a scalar arg */
		if (kid->op_type == OP_RV2AV || kid->op_type == OP_PADAV)
		    op_lvalue(kid, type);
		else {
		    scalar(kid);
		    /* diag_listed_as: push on reference is experimental */
		    Perl_ck_warner_d(aTHX_
				     packWARN(WARN_EXPERIMENTAL__AUTODEREF),
				    "%s on reference is experimental",
				     PL_op_desc[type]);
d9867 3
d9872 2
a9873 19
		if (kid->op_type == OP_CONST &&
		    (kid->op_private & OPpCONST_BARE))
		{
		    OP * const newop = newHVREF(newGVOP(OP_GV, 0,
			gv_fetchsv(((SVOP*)kid)->op_sv, GV_ADD, SVt_PVHV) ));
		    Perl_ck_warner_d(aTHX_ packWARN(WARN_DEPRECATED),
				   "Hash %%%"SVf" missing the %% in argument %"IVdf" of %s()",
				   SVfARG(((SVOP*)kid)->op_sv), (IV)numargs, PL_op_desc[type]);
#ifdef PERL_MAD
		    op_getmad(kid,newop,'K');
#else
		    op_free(kid);
#endif
		    kid = newop;
		    kid->op_sibling = sibl;
		    *tokid = kid;
		}
		else if (kid->op_type != OP_RV2HV && kid->op_type != OP_PADHV)
		    bad_type_pv(numargs, "hash", PL_op_desc[type], 0, kid);
d9878 3
a9880 2
		    OP * const newop = newUNOP(OP_NULL, 0, kid);
		    kid->op_sibling = 0;
a9882 2
		    kid->op_sibling = sibl;
		    *tokid = kid;
d9892 2
a9893 6
			if (!(o->op_private & 1) && /* if not unop */
			    kid == cLISTOPo->op_last)
			    cLISTOPo->op_last = newop;
#ifdef PERL_MAD
			op_getmad(kid,newop,'K');
#else
a9894 1
#endif
d9899 1
a9899 1
			bad_type_pv(numargs, "HANDLE", OP_DESC(o), 0, kid);
d9920 1
a9920 1
				SV *const namesv
d9922 3
a9924 2
				name = SvPV_const(namesv, len);
                                name_utf8 = SvUTF8(namesv);
d9995 5
a9999 4
			kid->op_sibling = 0;
			kid = newUNOP(OP_RV2GV, flags, scalar(kid));
			kid->op_targ = targ;
			kid->op_private |= priv;
a10000 2
		    kid->op_sibling = sibl;
		    *tokid = kid;
d10013 2
a10014 2
	    tokid = &kid->op_sibling;
	    kid = kid->op_sibling;
d10016 2
a10017 6
#ifdef PERL_MAD
	if (kid && kid->op_type != OP_STUB)
	    return too_many_arguments_pv(o,OP_DESC(o), 0);
	o->op_private |= numargs;
#else
	/* FIXME - should the numargs move as for the PERL_MAD case?  */
a10020 1
#endif
a10023 5
#ifdef PERL_MAD
	OP *newop = newUNOP(type, 0, newDEFSVOP());
	op_getmad(o,newop,'O');
	return newop;
#else
a10026 1
#endif
a10040 1
    dVAR;
d10046 1
a10046 1
    if ((o->op_flags & OPf_KIDS) && !cLISTOPo->op_first->op_sibling)
a10090 1
    dVAR;
a10093 1
    PADOFFSET offset;
a10096 1
    o->op_ppaddr = PL_ppaddr[OP_GREPSTART];
d10100 1
a10100 1
        kid = cUNOPx(cLISTOPo->op_first->op_sibling)->op_first;
d10105 1
a10105 1
    kid = cLISTOPo->op_first->op_sibling;
d10113 1
a10113 1
    kid = cLISTOPo->op_first->op_sibling;
d10118 1
a10118 6
    NewOp(1101, gwop, 1, LOGOP);
    gwop->op_type = type;
    gwop->op_ppaddr = PL_ppaddr[type];
    gwop->op_first = o;
    gwop->op_flags |= OPf_KIDS;
    gwop->op_other = LINKLIST(kid);
d10120 2
a10121 9
    offset = pad_findmy_pvs("$_", 0);
    if (offset == NOT_IN_PAD || PAD_COMPNAME_FLAGS_isOUR(offset)) {
	o->op_private = gwop->op_private = 0;
	gwop->op_targ = pad_alloc(type, SVs_PADTMP);
    }
    else {
	o->op_private = gwop->op_private = OPpGREP_LEX;
	gwop->op_targ = o->op_targ = offset;
    }
d10123 2
a10124 2
    kid = cLISTOPo->op_first->op_sibling;
    for (kid = kid->op_sibling; kid; kid = kid->op_sibling)
d10136 1
a10136 1
	OP *kid = cLISTOPo->op_first->op_sibling;	/* get past pushmark */
d10138 1
a10138 1
	    kid = kid->op_sibling;			/* get past "big" */
d10177 2
a10178 5
	case OP_AASSIGN:		/* Is this a good idea? */
	    Perl_ck_warner_d(aTHX_ packWARN(WARN_DEPRECATED),
			   "defined(@@array) is deprecated");
	    Perl_ck_warner_d(aTHX_ packWARN(WARN_DEPRECATED),
			   "\t(Maybe you should just omit the defined()?)\n");
d10182 2
a10183 4
	    Perl_ck_warner_d(aTHX_ packWARN(WARN_DEPRECATED),
			   "defined(%%hash) is deprecated");
	    Perl_ck_warner_d(aTHX_ packWARN(WARN_DEPRECATED),
			   "\t(Maybe you should just omit the defined()?)\n");
a10204 3
#ifdef PERL_MAD
	op_getmad(o,newop,'O');
#else
a10205 1
#endif
d10230 1
a10230 1
	o = force_list(o);
d10234 1
a10234 1
	kid = kid->op_sibling;
d10236 2
a10237 2
	kid = kid->op_sibling;
    else if (kid && !kid->op_sibling) {		/* print HANDLE; */
d10241 5
a10245 4
	    kid = newUNOP(OP_RV2GV, OPf_REF, scalar(kid));
	    cLISTOPo->op_first->op_sibling = kid;
	    cLISTOPo->op_last = kid;
	    kid = kid->op_sibling;
d10263 1
a10263 1
	OP *second = first->op_sibling;
d10266 10
a10275 3
	first->op_sibling = NULL;
	first = cBINOPo->op_first = ref_array_or_hash(first);
	second = first->op_sibling = ref_array_or_hash(second);
d10279 1
a10279 2
	    first->op_type = OP_QR;
	    first->op_ppaddr = PL_ppaddr[OP_QR];
d10282 1
a10282 2
	    second->op_type = OP_QR;
	    second->op_ppaddr = PL_ppaddr[OP_QR];
d10290 2
a10291 2
OP *
Perl_ck_sassign(pTHX_ OP *o)
a10292 1
    dVAR;
a10293 3

    PERL_ARGS_ASSERT_CK_SASSIGN;

a10298 2
	/* Keep the full thing for madskills */
	&& !PL_madskills
d10301 1
a10301 1
	OP * const kkid = kid->op_sibling;
d10305 2
a10306 1
	    && !(kkid->op_private & OPpLVAL_INTRO))
d10310 3
a10312 3
	    /* Now we do not need PADSV and SASSIGN. */
	    kid->op_sibling = o->op_sibling;	/* NULL */
	    cLISTOPo->op_first = NULL;
a10313 1
	    op_free(kkid);
d10318 15
a10332 4
    if (kid->op_sibling) {
	OP *kkid = kid->op_sibling;
	/* For state variable assignment, kkid is a list op whose op_last
	   is a padsv. */
d10338 2
a10339 2
		&& (kkid->op_private & OPpLVAL_INTRO)
		&& SvPAD_STATE(*av_fetch(PL_comppad_name, kkid->op_targ, FALSE))) {
d10345 5
a10349 1
	    OP *const nullop = newCONDOP(0, first, o, other);
a10350 2
	    /* hijacking PADSTALE for uninitialized state variables */
	    SvPADSTALE_on(PAD_SVl(target));
d10352 1
a10352 3
	    condop->op_type = OP_ONCE;
	    condop->op_ppaddr = PL_ppaddr[OP_ONCE];
	    condop->op_targ = target;
d10354 1
d10356 6
a10361 4
	    /* Because we change the type of the op here, we will skip the
	       assignment binop->op_last = binop->op_first->op_sibling; at the
	       end of Perl_newBINOP(). So need to do it here. */
	    cBINOPo->op_last = cBINOPo->op_first->op_sibling;
d10366 1
a10366 1
    return o;
d10372 1
a10372 2
    dVAR;

a10374 7
    if (o->op_type != OP_QR && PL_compcv) {
	const PADOFFSET offset = pad_findmy_pvs("$_", 0);
	if (offset != NOT_IN_PAD && !(PAD_COMPNAME_FLAGS_isOUR(offset))) {
	    o->op_targ = offset;
	    o->op_private |= OPpTARGET_MY;
	}
    }
d10383 6
d10392 30
d10423 10
a10432 14
    if (kid->op_type == OP_CONST) {
	SV* sv = kSVOP->op_sv;
	const char * const method = SvPVX_const(sv);
	if (!(strchr(method, ':') || strchr(method, '\''))) {
	    OP *cmop;
	    if (!SvIsCOW_shared_hash(sv)) {
		sv = newSVpvn_share(method, SvUTF8(sv) ? -(I32)SvCUR(sv) : (I32)SvCUR(sv), 0);
	    }
	    else {
		kSVOP->op_sv = NULL;
	    }
	    cmop = newSVOP(OP_METHOD_NAMED, 0, sv);
#ifdef PERL_MAD
	    op_getmad(o,cmop,'O');
d10434 1
a10434 1
	    op_free(o);
d10436 2
a10437 4
	    return cmop;
	}
    }
    return o;
a10450 2
    dVAR;

d10465 2
a10466 2
	     (oa = first->op_sibling) &&		/* The fh. */
	     (oa = oa->op_sibling) &&			/* The mode. */
d10471 1
a10471 1
	     (last == oa->op_sibling))			/* The bareword. */
d10478 109
d10592 1
d10594 3
a10596 1
	cBINOPo->op_first = force_list(cBINOPo->op_first);
a10605 1
    dVAR;
d10612 9
a10620 6

	if (kid->op_type == OP_CONST && (kid->op_private & OPpCONST_BARE)) {
	    SV * const sv = kid->op_sv;
	    U32 was_readonly = SvREADONLY(sv);
	    char *s;
	    STRLEN len;
d10640 6
d10647 21
d10677 1
a10677 1
	    cUNOPo->op_first = NULL;
a10681 1
#ifndef PERL_MAD
a10682 1
#endif
a10683 1
	op_getmad(o,newop,'O');
d10687 1
a10687 1
    return scalar(ck_fun(o));
a10692 1
    dVAR;
d10697 1
a10697 1
    kid = cLISTOPo->op_first->op_sibling;
d10699 1
a10699 1
	for (; kid; kid = kid->op_sibling)
d10715 3
a10717 4
	kid = cLISTOPo->op_first->op_sibling;	/* get past pushmark */
	if (kid && kid->op_sibling) {
	    o->op_type = OP_SSELECT;
	    o->op_ppaddr = PL_ppaddr[OP_SSELECT];
d10723 1
a10723 1
    kid = cLISTOPo->op_first->op_sibling;    /* get past pushmark */
a10731 1
    dVAR;
a10744 8
#ifdef PERL_MAD
	{
	    OP * const oldo = o;
	    o = newUNOP(type, 0, scalar(argop));
	    op_getmad(oldo,o,'O');
	    return o;
	}
#else
a10746 1
#endif
a10753 1
    dVAR;
d10775 1
a10775 1
    firstkid = cLISTOPo->op_first->op_sibling;		/* get past pushmark */
d10789 32
a10820 4
	    /* provide scalar context for comparison function/block */
	    kid = scalar(firstkid);
	    kid->op_next = kid;
	    o->op_flags |= OPf_SPECIAL;
d10823 1
a10823 1
	firstkid = firstkid->op_sibling;
d10826 1
a10826 1
    for (kid = firstkid; kid; kid = kid->op_sibling) {
d10849 1
a10849 2
    dVAR;
    OP *kid = cLISTOPo->op_first->op_sibling;	/* get past pushmark */
d10891 4
a10894 3
		SV * const name = AvARRAY(PL_comppad_name)[kid->op_targ];
		if (SvCUR(name) == 2 && *SvPVX(name) == '$'
		 && (SvPVX(name)[1] == 'a' || SvPVX(name)[1] == 'b'))
d10898 4
a10901 2
				      SvPAD_STATE(name) ? "state" : "my",
				      SvPVX(name));
d10903 1
a10903 1
	} while ((kid = kid->op_sibling));
d10942 4
a10945 7
    kid = cLISTOPo->op_first->op_sibling;
    cLISTOPo->op_first->op_sibling = kid->op_sibling; /* bypass old block */
#ifdef PERL_MAD
    op_getmad(kid,o,'S');			      /* then delete it */
#else
    op_free(kid);				      /* then delete it */
#endif
d10962 5
a10966 8
    kid = kid->op_sibling;
    op_free(cLISTOPo->op_first);
    if (kid)
	cLISTOPo->op_first = kid;
    else {
	cLISTOPo->op_first = kid = newSVOP(OP_CONST, 0, newSVpvs(" "));
	cLISTOPo->op_last = kid; /* There was only one element previously */
    }
d10969 9
a10977 11
	OP * const sibl = kid->op_sibling;
	kid->op_sibling = 0;
        kid = pmruntime( newPMOP(OP_MATCH, OPf_SPECIAL), kid, 0, 0); /* OPf_SPECIAL is used to trigger split " " behavior */
	if (cLISTOPo->op_first == cLISTOPo->op_last)
	    cLISTOPo->op_last = kid;
	cLISTOPo->op_first = kid;
	kid->op_sibling = sibl;
    }

    kid->op_type = OP_PUSHRE;
    kid->op_ppaddr = PL_ppaddr[OP_PUSHRE];
d10984 1
a10984 1
    if (!kid->op_sibling)
d10987 2
a10988 1
    kid = kid->op_sibling;
d10991 1
a10991 1
    if (!kid->op_sibling)
d10996 1
a10996 1
    assert(kid->op_sibling);
d10998 1
a10998 1
    kid = kid->op_sibling;
d11001 1
a11001 1
    if (kid->op_sibling)
d11008 17
d11027 1
a11027 1
    const OP * const kid = cLISTOPo->op_first->op_sibling;
d11043 17
d11069 1
a11069 1
a prototype can be applied to a function call.  I<cvop> is the op
d11083 1
a11083 1
If I<flags> has the bit C<RV2CVOPCV_MARK_EARLY> set, then the handling
d11090 1
a11090 1
If I<flags> has the bit C<RV2CVOPCV_RETURN_NAME_GV> set, then instead
d11110 1
a11110 1
	compcv = CvOUTSIDE(PL_compcv);
d11115 2
a11116 5
    if (!PadnameIsSTATE(name) && SvMAGICAL(name)) {
	MAGIC * mg = mg_find(name, PERL_MAGIC_proto);
	assert(mg);
	assert(mg->mg_obj);
	return (CV *)mg->mg_obj;
d11128 1
a11128 1
    if (flags & ~(RV2CVOPCV_MARK_EARLY|RV2CVOPCV_RETURN_NAME_GV))
d11140 10
d11170 1
a11170 1
	} break;
d11174 3
a11176 2
    if (flags & RV2CVOPCV_RETURN_NAME_GV) {
	if (!CvANON(cv) || !gv)
d11201 1
d11203 1
d11205 1
a11205 1
    if (!aop->op_sibling)
d11207 10
a11216 5
    for (aop = aop->op_sibling; aop->op_sibling; aop = aop->op_sibling) {
	if (!(PL_madskills && aop->op_type == OP_STUB)) {
	    list(aop);
	    op_lvalue(aop, OP_ENTERSUB);
	}
d11232 1
a11232 1
I<protosv> supplies the subroutine prototype to be applied to the call.
d11244 1
a11244 1
by the name defined by the I<namegv> parameter.
d11254 1
a11254 1
    OP *aop, *prev, *cvop;
d11268 1
d11270 2
a11271 1
    if (!aop->op_sibling)
d11273 1
d11275 2
a11276 2
    aop = aop->op_sibling;
    for (cvop = aop; cvop->op_sibling; cvop = cvop->op_sibling) ;
d11278 1
a11278 9
	OP* o3;
	if (PL_madskills && aop->op_type == OP_STUB) {
	    aop = aop->op_sibling;
	    continue;
	}
	if (PL_madskills && aop->op_type == OP_NULL)
	    o3 = ((UNOP*)aop)->op_first;
	else
	    o3 = aop;
d11281 6
a11286 1
	    return too_many_arguments_sv(entersubop, gv_ename(namegv), 0);
d11297 1
d11311 8
a11318 4
		if (o3->op_type != OP_REFGEN && o3->op_type != OP_UNDEF)
		    bad_type_gv(arg,
			    arg == 1 ? "block or sub {}" : "sub {}",
			    namegv, 0, o3);
a11327 30
		else if (o3->op_type == OP_ENTERSUB) {
		    /* accidental subroutine, revert to bareword */
		    OP *gvop = ((UNOP*)o3)->op_first;
		    if (gvop && gvop->op_type == OP_NULL) {
			gvop = ((UNOP*)gvop)->op_first;
			if (gvop) {
			    for (; gvop->op_sibling; gvop = gvop->op_sibling)
				;
			    if (gvop &&
				    (gvop->op_private & OPpENTERSUB_NOPAREN) &&
				    (gvop = ((UNOP*)gvop)->op_first) &&
				    gvop->op_type == OP_GV)
			    {
				GV * const gv = cGVOPx_gv(gvop);
				OP * const sibling = aop->op_sibling;
				SV * const n = newSVpvs("");
#ifdef PERL_MAD
				OP * const oldaop = aop;
#else
				op_free(aop);
#endif
				gv_fullname4(n, gv, "", FALSE);
				aop = newSVOP(OP_CONST, 0, n);
				op_getmad(oldaop,aop,'O');
				prev->op_sibling = aop;
				aop->op_sibling = sibling;
			    }
			}
		    }
		}
d11344 1
a11344 1
		break;
d11359 1
a11359 1
			break;
d11373 2
a11374 3
			    bad_type_gv(arg, Perl_form(aTHX_ "one of %.*s",
					(int)(end - p), p),
				    namegv, 0, o3);
d11382 1
a11382 1
			    bad_type_gv(arg, "symbol", namegv, 0, o3);
d11385 2
a11386 1
			if (o3->op_type == OP_ENTERSUB)
d11389 1
a11389 2
			    bad_type_gv(arg, "subroutine entry", namegv, 0,
				    o3);
d11404 1
a11404 1
			    bad_type_gv(arg, "scalar", namegv, 0, o3);
d11410 2
d11413 1
d11415 1
a11415 1
			    bad_type_gv(arg, "array", namegv, 0, o3);
d11420 2
d11423 1
d11425 1
a11425 1
			    bad_type_gv(arg, "hash", namegv, 0, o3);
d11428 2
a11429 8
			{
			    OP* const kid = aop;
			    OP* const sib = kid->op_sibling;
			    kid->op_sibling = 0;
			    aop = newUNOP(OP_REFGEN, 0, kid);
			    aop->op_sibling = sib;
			    prev->op_sibling = aop;
			}
a11444 2
                SV* const tmpsv = sv_newmortal();
                gv_efullname3(tmpsv, namegv, NULL);
d11446 2
a11447 1
			SVfARG(tmpsv), SVfARG(protosv));
d11453 1
a11453 1
	aop = aop->op_sibling;
d11457 1
a11457 3
	aop = newDEFSVOP();
	aop->op_sibling = prev->op_sibling;
	prev->op_sibling = aop; /* instead of cvop */
d11461 5
a11465 1
	return too_few_arguments_sv(entersubop, gv_ename(namegv), 0);
d11477 1
a11477 1
I<protosv> supplies the subroutine prototype to be applied to the call,
d11491 1
a11491 1
by the name defined by the I<namegv> parameter.
d11517 1
a11517 1
	if (!aop->op_sibling)
d11519 2
a11520 5
	aop = aop->op_sibling;
	for (cvop = aop; cvop->op_sibling; cvop = cvop->op_sibling) ;
	if (PL_madskills) while (aop != cvop && aop->op_type == OP_STUB) {
	    aop = aop->op_sibling;
	}
d11541 1
a11541 1
	NOT_REACHED;
d11544 6
a11549 6
	OP *prev, *cvop;
	U32 flags;
#ifdef PERL_MAD
	bool seenarg = FALSE;
#endif
	if (!aop->op_sibling)
d11551 1
d11553 3
a11555 3
	prev = aop;
	aop = aop->op_sibling;
	prev->op_sibling = NULL;
d11557 2
a11558 6
	     cvop->op_sibling;
	     prev=cvop, cvop = cvop->op_sibling)
#ifdef PERL_MAD
	    if (PL_madskills && cvop->op_sibling
	     && cvop->op_type != OP_STUB) seenarg = TRUE
#endif
d11560 8
a11567 2
	prev->op_sibling = NULL;
	flags = OPf_SPECIAL * !(cvop->op_private & OPpENTERSUB_NOPAREN);
d11570 6
a11588 3
#ifdef PERL_MAD
		if (!PL_madskills || seenarg)
#endif
d11596 1
a11596 1
	    return convert(opnum,0,aop);
d11599 1
a11599 1
    assert(0);
d11606 1
a11606 1
Retrieves the function that will be used to fix up a call to I<cv>.
d11609 1
a11609 1
at compile time as I<cv>.
d11611 2
a11612 2
The C-level function pointer is returned in I<*ckfun_p>, and an SV
argument for it is returned in I<*ckobj_p>.  The function is intended
d11615 1
a11615 1
    entersubop = (*ckfun_p)(aTHX_ entersubop, namegv, (*ckobj_p));
d11617 2
a11618 2
In this call, I<entersubop> is a pointer to the C<entersub> op,
which may be replaced by the check function, and I<namegv> is a GV
d11626 1
a11626 1
and the SV parameter is I<cv> itself.  This implements standard
d11633 3
a11635 2
void
Perl_cv_get_call_checker(pTHX_ CV *cv, Perl_call_checker *ckfun_p, SV **ckobj_p)
a11637 1
    PERL_ARGS_ASSERT_CV_GET_CALL_CHECKER;
d11642 1
d11646 1
d11650 8
d11659 1
a11659 1
=for apidoc Am|void|cv_set_call_checker|CV *cv|Perl_call_checker ckfun|SV *ckobj
d11661 1
a11661 1
Sets the function that will be used to fix up a call to I<cv>.
d11664 1
a11664 1
at compile time as I<cv>.
d11666 2
a11667 2
The C-level function pointer is supplied in I<ckfun>, and an SV argument
for it is supplied in I<ckobj>.  The function should be defined like this:
d11675 3
a11677 3
In this call, I<entersubop> is a pointer to the C<entersub> op,
which may be replaced by the check function, and I<namegv> is a GV
supplying the name that should be used by the check function to refer
d11682 5
d11690 5
d11702 8
d11717 1
d11728 2
a11729 1
	callmg->mg_flags |= MGf_COPY;
d11733 7
d11746 1
d11751 1
a11751 1
    if (!aop->op_sibling)
d11753 2
a11754 2
    aop = aop->op_sibling;
    for (cvop = aop; cvop->op_sibling; cvop = cvop->op_sibling) ;
d11756 1
a11756 1
    namegv = cv ? (GV*)rv2cv_op_cv(cvop, RV2CVOPCV_RETURN_NAME_GV) : NULL;
a11758 1
    o->op_private |= OPpENTERSUB_HASTARG;
d11762 39
a11800 11
    if (cvop->op_type == OP_RV2CV) {
	o->op_private |= (cvop->op_private & OPpENTERSUB_AMPER);
	op_null(cvop);
    } else if (cvop->op_type == OP_METHOD || cvop->op_type == OP_METHOD_NAMED) {
	if (aop->op_type == OP_CONST)
	    aop->op_private &= ~OPpCONST_STRICT;
	else if (aop->op_type == OP_LIST) {
	    OP * const sib = ((UNOP*)aop)->op_first->op_sibling;
	    if (sib && sib->op_type == OP_CONST)
		sib->op_private &= ~OPpCONST_STRICT;
	}
d11804 1
d11809 16
a11824 9
	cv_get_call_checker(cv, &ckfun, &ckobj);
	if (!namegv) { /* expletive! */
	    /* XXX The call checker API is public.  And it guarantees that
		   a GV will be provided with the right name.  So we have
		   to create a GV.  But it is still not correct, as its
		   stringification will include the package.  What we
		   really need is a new call checker API that accepts a
		   GV or string (or GV or CV). */
	    HEK * const hek = CvNAME_HEK(cv);
d11827 2
a11828 4
	    if (!hek) return ck_entersub_args_list(o);;
	    namegv = (GV *)sv_newmortal();
	    gv_init_pvn(namegv, PL_curstash, HEK_KEY(hek), HEK_LEN(hek),
			SVf_UTF8 * !!HEK_UTF8(hek));
d11840 1
a11840 3
#ifdef PERL_OLD_COPY_ON_WRITE
    if (SvIsCOW(sv)) sv_force_normal(sv);
#elif defined(PERL_NEW_COPY_ON_WRITE)
d11867 1
a11867 1
	    kid = (SVOP*)kid->op_sibling;
d11889 1
a11889 1
	    kid = kid->op_sibling;
d11904 1
a11904 1
     if (kid->op_type == OP_NULL && kid->op_sibling) kid = kid->op_sibling;
a11915 4
    const unsigned array_type = orig_type == OP_EACH ? OP_AEACH
	                      : orig_type == OP_KEYS ? OP_AKEYS : OP_AVALUES;
    const unsigned ref_type   = orig_type == OP_EACH ? OP_REACH
	                      : orig_type == OP_KEYS ? OP_RKEYS : OP_RVALUES;
d11926 3
a11928 1
		CHANGE_TYPE(o, array_type);
d11939 4
a11942 2
		CHANGE_TYPE(o, ref_type);
		scalar(kid);
a11944 7
    /* if treating as a reference, defer additional checks to runtime */
    if (o->op_type == ref_type) {
	/* diag_listed_as: keys on reference is experimental */
	Perl_ck_warner_d(aTHX_ packWARN(WARN_EXPERIMENTAL__AUTODEREF),
			      "%s is experimental", PL_op_desc[ref_type]);
	return o;
    }
d11967 429
a12395 19
		    name = S_op_varname(aTHX_ kid);
                    break;
                default:
                    return o;
            }
            if (name)
                Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
                    "length() used on %"SVf" (did you mean \"scalar(%s%"SVf
                    ")\"?)",
                    name, hash ? "keys " : "", name
                );
            else if (hash)
     /* diag_listed_as: length() used on %s (did you mean "scalar(%s)"?) */
                Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
                    "length() used on %%hash (did you mean \"scalar(keys %%hash)\"?)");
            else
     /* diag_listed_as: length() used on %s (did you mean "scalar(%s)"?) */
                Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
                    "length() used on @@array (did you mean \"scalar(@@array)\"?)");
d12397 6
d12405 6
a12410 1
    return o;
d12413 1
d12431 1
a12431 1
    modop = modop_pushmark->op_sibling;
d12437 1
a12437 1
    if (modop->op_sibling)
d12441 1
a12441 1
    if (!(oright = cUNOPx(modop)->op_first->op_sibling)) return;
d12446 1
a12446 1
	oright = oright->op_sibling;
d12449 2
a12450 2
    assert(cUNOPo->op_first->op_sibling->op_type == OP_NULL);
    oleft_pushmark = cUNOPx(cUNOPo->op_first->op_sibling)->op_first;
d12452 1
a12452 1
    oleft = oleft_pushmark->op_sibling;
d12457 1
a12457 1
	|| oleft->op_sibling
d12463 1
a12463 1
    if (oright->op_sibling)
d12499 616
d13124 1
a13124 1
        S_prune_chain_head(aTHX_ defer); \
a13134 12
STATIC void
S_null_listop_in_list_context(pTHX_ OP *o)
{
    PERL_ARGS_ASSERT_NULL_LISTOP_IN_LIST_CONTEXT;

    /* This is an OP_LIST in list context. That means we
     * can ditch the OP_LIST and the OP_PUSHMARK within. */

    op_null(cUNOPo->op_first); /* NULL the pushmark */
    op_null(o); /* NULL the list */
}

d13148 2
d13164 1
a13164 1
                S_prune_chain_head(aTHX_ defer);
d13169 6
d13180 14
a13193 16

        /* The following will have the OP_LIST and OP_PUSHMARK
         * patched out later IF the OP_LIST is in list context.
         * So in that case, we can set the this OP's op_next
         * to skip to after the OP_PUSHMARK:
         *   a THIS -> b
         *   d list -> e
         *   b   pushmark -> c
         *   c   whatever -> d
         *   e whatever
         * will eventually become:
         *   a THIS -> c
         *   - ex-list -> -
         *   -   ex-pushmark -> -
         *   c   whatever -> e
         *   e whatever
d13196 160
a13355 16
            OP *sibling;
            OP *other_pushmark;
            if (OP_TYPE_IS(o->op_next, OP_PUSHMARK)
                && (sibling = o->op_sibling)
                && sibling->op_type == OP_LIST
                /* This KIDS check is likely superfluous since OP_LIST
                 * would otherwise be an OP_STUB. */
                && sibling->op_flags & OPf_KIDS
                && (sibling->op_flags & OPf_WANT) == OPf_WANT_LIST
                && (other_pushmark = cLISTOPx(sibling)->op_first)
                /* Pointer equality also effectively checks that it's a
                 * pushmark. */
                && other_pushmark == o->op_next)
            {
                o->op_next = other_pushmark->op_next;
                null_listop_in_list_context(sibling);
d13359 1
d13383 1
a13383 1
		OP *sibling = o->op_sibling;
d13387 3
a13389 1
		    && OP_TYPE_IS(sibling->op_next->op_next, OP_LEAVESUB)
d13391 1
a13391 1
		    && next->op_sibling && next->op_sibling->op_next
d13396 1
a13396 1
		    OP *top = next->op_sibling;
d13403 1
a13403 1
			top = top->op_sibling;
d13438 1
a13438 3
		OP *first;
		OP *last;
		OP *newop;
d13440 22
a13461 4
		first = o->op_next;
		last = o->op_next->op_next->op_next;

		newop = newLISTOP(OP_LIST, 0, first, last);
d13465 2
a13466 13
		/* Kill nextstate2 between padop1/padop2 */
		op_free(first->op_next);

		first->op_next = last;                /* padop2 */
		first->op_sibling = last;             /* ... */
		o->op_next = cUNOPx(newop)->op_first; /* pushmark */
		o->op_next->op_next = first;          /* padop1 */
		o->op_next->op_sibling = first;       /* ... */
		newop->op_next = last->op_next;       /* nextstate3 */
		newop->op_sibling = last->op_sibling;
		last->op_next = newop;                /* listop */
		last->op_sibling = NULL;
		o->op_sibling = newop;                /* ... */
d13468 7
a13474 1
		newop->op_flags = (newop->op_flags & ~OPf_WANT) | OPf_WANT_VOID;
d13477 2
a13478 2
		if (first->op_flags & OPf_MOD && last->op_flags & OPf_MOD) {
		    o->op_next->op_flags |= OPf_MOD;
d13493 7
a13499 38
		    COP *firstcop = (COP *)o;
		    COP *secondcop = (COP *)nextop;
		    /* We want the COP pointed to by o (and anything else) to
		       become the next COP down the line.  */
		    cop_free(firstcop);

		    firstcop->op_next = secondcop->op_next;

		    /* Now steal all its pointers, and duplicate the other
		       data.  */
		    firstcop->cop_line = secondcop->cop_line;
#ifdef USE_ITHREADS
		    firstcop->cop_stashoff = secondcop->cop_stashoff;
		    firstcop->cop_file = secondcop->cop_file;
#else
		    firstcop->cop_stash = secondcop->cop_stash;
		    firstcop->cop_filegv = secondcop->cop_filegv;
#endif
		    firstcop->cop_hints = secondcop->cop_hints;
		    firstcop->cop_seq = secondcop->cop_seq;
		    firstcop->cop_warnings = secondcop->cop_warnings;
		    firstcop->cop_hints_hash = secondcop->cop_hints_hash;

#ifdef USE_ITHREADS
		    secondcop->cop_stashoff = 0;
		    secondcop->cop_file = NULL;
#else
		    secondcop->cop_stash = NULL;
		    secondcop->cop_filegv = NULL;
#endif
		    secondcop->cop_warnings = NULL;
		    secondcop->cop_hints_hash = NULL;

		    /* If we use op_null(), and hence leave an ex-COP, some
		       warnings are misreported. For example, the compile-time
		       error in 'use strict; no strict refs;'  */
		    secondcop->op_type = OP_NULL;
		    secondcop->op_ppaddr = PL_ppaddr[OP_NULL];
d13536 1
a13536 1
	    /* FALL THROUGH */
d13550 42
d13618 1
a13618 1
            U8 gimme       = 0; /* init only to stop compiler whining */
a13624 1
                GV *gv;
d13628 1
a13628 4
                    && (gv = cGVOPx_gv(p))
                    && GvNAMELEN_get(gv) == 1
                    && *GvNAME_get(gv) == '_'
                    && GvSTASH(gv) == PL_defstash
a13633 2
                    && o->op_sibling == rv2av /* these two for Deparse */
                    && cUNOPx(rv2av)->op_first == p
a13644 5
                /* To allow Deparse to pessimise this, it needs to be able
                 * to restore the pushmark's original op_next, which it
                 * will assume to be the same as op_sibling. */
                if (o->op_next != o->op_sibling)
                    break;
d13679 1
a13679 1
                    gimme = (p->op_flags & OPf_WANT);
d13687 1
a13687 1
                     i* Function::Parameters */
d13691 6
a13696 2
                    /* all the padops should be in the same context */
                    if (gimme != (p->op_flags & OPf_WANT))
d13702 1
a13702 1
                    && gimme != OPf_WANT_VOID
d13711 15
a13725 3
                 * SAVEt_CLEARPADRANGE in pp_padrange */
                if (intro && base >
                        (UV_MAX >> (OPpPADRANGE_COUNTSHIFT+SAVE_TIGHT_SHIFT)))
d13733 1
a13733 1
            if (count < 1)
d13743 5
a13747 5
             * a padrange if see see the complete sequence
             *     pushmark, pad*v, ...., list, nextstate
             * which has the net effect of of leaving the stack empty
             * (for now we leave the nextstate in the execution chain, for
             * its other side-effects).
d13750 4
a13753 5
            if (gimme == OPf_WANT_VOID) {
                if (OP_TYPE_IS_OR_WAS(followop, OP_LIST)
                        && gimme == (followop->op_flags & OPf_WANT)
                        && (   followop->op_next->op_type == OP_NEXTSTATE
                            || followop->op_next->op_type == OP_DBSTATE))
d13830 1
a13830 2
                o->op_type = OP_PADRANGE;
                o->op_ppaddr = PL_ppaddr[OP_PADRANGE];
d13835 2
a13836 1
                                    | gimme | (defav ? OPf_SPECIAL : 0));
d13842 12
d13885 2
a13886 1
		break;
d13889 23
a13911 1
	    if (o->op_next->op_type == OP_RV2SV) {
d13917 1
a13917 2
		    o->op_type = OP_GVSV;
		    o->op_ppaddr = PL_ppaddr[OP_GVSV];
d13925 1
a13925 1
		o->op_type   = OP_RCATLINE;
a13926 1
		o->op_ppaddr = PL_ppaddr[OP_RCATLINE];
a13932 4
        {
            OP *fop;
            OP *sop;
            
d13951 1
a13951 1
            sop = fop->op_sibling;
d13958 2
a13959 2
	    /* if we're an OR and our next is a AND in void context, we'll
	       follow it's op_other on short circuit, same for reverse.
d13962 1
a13962 1
	       by the next op */
d14018 1
a14018 2
	    /* GERONIMO! */
	}    
d14065 1
a14065 1
		OP * const nullop = cLISTOP->op_first->op_sibling;
d14098 1
a14098 1
	    if (!cUNOPo->op_sibling) {
d14106 1
a14106 1
			&& (cUNOPx(pushmark)->op_sibling == o)) {
d14161 1
a14161 1
	    exlist = (LISTOP *) expushmark->op_sibling;
d14174 1
a14174 1
	    if (theirmark->op_sibling != o) {
d14189 3
a14191 4
	    rv2av = ourmark->op_sibling;
	    if (rv2av && rv2av->op_type == OP_RV2AV && rv2av->op_sibling == 0
		&& rv2av->op_flags == (OPf_WANT_LIST | OPf_KIDS)
		&& enter->op_flags == (OPf_WANT_LIST | OPf_KIDS)) {
d14206 5
d14223 3
a14225 1
	    if (!(o->op_private & OPpOFFBYONE) && !CvCLONE(PL_compcv)) {
d14233 1
a14233 2
		o->op_type = OP_CONST;
		o->op_ppaddr = PL_ppaddr[OP_CONST];
d14240 6
a14245 1
	    if (OP_GIMME(o,0) == G_VOID) {
d14265 1
a14265 1
		    OP *left = right->op_sibling;
d14269 5
a14273 4
			cBINOP->op_first = left;
			right->op_sibling =
			    cBINOPx(left)->op_first->op_sibling;
			cBINOPx(left)->op_first->op_sibling = right;
d14282 94
d14410 1
a14410 1
considered internal to OP_NAME and the other access macros: use them instead.
d14487 1
a14487 1
		    NOT_REACHED;
d14505 1
a14505 1
		    NOT_REACHED;
d14510 6
a14544 1
=head1 Functions in file op.c
d14547 1
d14549 2
a14550 2
to a new mortal SV if C<sv> is NULL.  It returns the modified C<sv>, or
NULL if the core function has no prototype.  C<code> is a code as returned
d14586 7
a14592 7
    case KEY_keys:    retsetpvs("+", OP_KEYS);
    case KEY_values:  retsetpvs("+", OP_VALUES);
    case KEY_each:    retsetpvs("+", OP_EACH);
    case KEY_push:    retsetpvs("+@@", OP_PUSH);
    case KEY_unshift: retsetpvs("+@@", OP_UNSHIFT);
    case KEY_pop:     retsetpvs(";+", OP_POP);
    case KEY_shift:   retsetpvs(";+", OP_SHIFT);
d14595 1
a14595 1
	retsetpvs("+;$$@@", OP_SPLICE);
d14687 1
a14687 1
	/* FALL THROUGH */
d14713 1
a14713 1
	    o = convert(opnum,OPf_SPECIAL*(opnum == OP_GLOB),argop);
d14761 1
a14761 1
			  name);
d14778 1
a14778 1
I<opcode> specifies which type of op is to be affected.  I<new_checker>
d14780 1
a14780 1
check chain, and I<old_checker_p> points to the storage location where a
d14782 2
a14783 2
I<new_pointer> is written into the L</PL_check> array, while the value
previously stored there is written to I<*old_checker_p>.
d14793 1
a14793 1
I<old_checker_p> should be defined like this:
d14800 1
a14800 1
is idempotent.  The location I<*old_checker_p> must initially (once
d14805 1
a14805 1
actually modify the check chain if it finds I<*old_checker_p> to be null.
d14809 5
a14813 5
When this function is called, the function referenced by I<new_checker>
must be ready to be called, except for I<*old_checker_p> being unfilled.
In a threading situation, I<new_checker> may be called immediately,
even before this function has returned.  I<*old_checker_p> will always
be appropriately set before I<new_checker> is called.  If I<new_checker>
d14816 1
a14816 1
check function referenced by I<*old_checker_p>.
d14831 1
a14847 1
    dVAR;
a14861 1
    dVAR;
a14883 6
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
@


1.19
log
@Fix merge issues, remove excess files - match perl-5.20.2 dist
@
text
@d8868 1
a8868 1
	if (kid->op_type == OP_LINESEQ || kid->op_type == OP_STUB) {
@


1.18
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d4808 4
a4811 1
    if (is_trans || o->op_type == OP_SUBST) {
d4936 11
a4946 2
		 * regex was parsed */
		assert(AvFILLp(PL_comppad) == 0); /* just @@_ */
d5060 1
a11266 2
    OP *kid;

a11271 6
    kid = cLISTOPo->op_first;
    /* Find the end of the chain of OPs executed within the OP_LIST. */
    while (kid->op_next != o)
        kid = kid->op_next;

    kid->op_next = o->op_next; /* patch list out of exec chain */
d12014 3
a12016 1
                      (kid->op_type == OP_NULL && kid->op_targ == OP_NEXTSTATE)
@


1.17
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d112 18
d186 6
d196 7
a202 14
#if defined(USE_ITHREADS) && IVSIZE > U32SIZE && IVSIZE > PTRSIZE
    /* Work around a goof with alignment on our part. For sparc32 (and
       possibly other architectures), if built with -Duse64bitint, the IV
       op_pmoffset in struct pmop should be 8 byte aligned, but the slab
       allocator is only providing 4 byte alignment. The real fix is to change
       the IV to a type the same size as a pointer, such as size_t, but we
       can't do that without breaking the ABI, which is a no-no in a maint
       release. So instead, simply allocate struct pmop directly, which will be
       suitably aligned:  */
    if (sz == sizeof(struct pmop))
	return PerlMemShared_calloc(1, sz);
#endif

    if (!CvSTART(PL_compcv)) { /* sneak it in here */
d213 3
d319 1
a319 1
#  define Slab_to_rw(op)
d556 1
a556 1
S_bad_type_sv(pTHX_ I32 n, const char *t, SV *namesv, U32 flags, const OP *kid)
d558 2
a559 1
    PERL_ARGS_ASSERT_BAD_TYPE_SV;
d693 9
d758 2
a759 3
    if (o->op_slabbed) {
	Slab_to_rw(OpSLAB(o));
    }
d955 2
d1016 9
d1089 1
a1089 1
This function is the implementation of the L</LINKLIST> macro. It should
d1162 115
d1339 40
d1470 1
d1473 1
d1579 10
a1588 23
                  /* perl4's way of mixing documentation and code
                     (before the invention of POD) was based on a
                     trick to mix nroff and perl code. The trick was
                     built upon these three nroff macros being used in
                     void context. The pink camel has the details in
                     the script wrapman near page 319. */
		    const char * const maybe_macro = SvPVX_const(sv);
		    if (strnEQ(maybe_macro, "di", 2) ||
			strnEQ(maybe_macro, "ds", 2) ||
			strnEQ(maybe_macro, "ig", 2))
			    useless = NULL;
		    else {
			SV * const dsv = newSVpvs("");
			useless_sv
                            = Perl_newSVpvf(aTHX_
                                            "a constant (%s)",
                                            pv_pretty(dsv, maybe_macro,
                                                      SvCUR(sv), 32, NULL, NULL,
                                                      PERL_PV_PRETTY_DUMP
                                                      | PERL_PV_ESCAPE_NOCLEAR
                                                      | PERL_PV_ESCAPE_UNI_DETECT));
			SvREFCNT_dec_NN(dsv);
		    }
d1856 2
a1857 2
This function finalizes the optree. Should be called directly after
the complete optree is built. It does some additional
d1907 1
a1907 1
	    && ckWARN(WARN_SYNTAX))
d1949 5
a1953 29
	    const PADOFFSET ix = pad_alloc(OP_CONST, SVs_PADTMP);
	    if (o->op_type != OP_METHOD_NAMED &&
		(SvPADTMP(cSVOPo->op_sv) || SvPADMY(cSVOPo->op_sv)))
	    {
		/* If op_sv is already a PADTMP/MY then it is being used by
		 * some pad, so make a copy. */
		sv_setsv(PAD_SVl(ix),cSVOPo->op_sv);
		if (!SvIsCOW(PAD_SVl(ix))) SvREADONLY_on(PAD_SVl(ix));
		SvREFCNT_dec(cSVOPo->op_sv);
	    }
	    else if (o->op_type != OP_METHOD_NAMED
		&& cSVOPo->op_sv == &PL_sv_undef) {
		/* PL_sv_undef is hack - it's unsafe to store it in the
		   AV that is the pad, because av_fetch treats values of
		   PL_sv_undef as a "free" AV entry and will merrily
		   replace them with a new SV, causing pad_alloc to think
		   that this pad slot is free. (When, clearly, it is not)
		*/
		SvOK_off(PAD_SVl(ix));
		SvPADTMP_on(PAD_SVl(ix));
		SvREADONLY_on(PAD_SVl(ix));
	    }
	    else {
		SvREFCNT_dec(PAD_SVl(ix));
		SvPADTMP_on(cSVOPo->op_sv);
		PAD_SETSV(ix, cSVOPo->op_sv);
		/* XXX I don't know how this isn't readonly already. */
		if (!SvIsCOW(PAD_SVl(ix))) SvREADONLY_on(PAD_SVl(ix));
	    }
d1964 3
a1966 3
	SV **svp, *sv;
	const char *key = NULL;
	STRLEN keylen;
d1968 1
a1968 1
	if (((BINOP*)o)->op_last->op_type != OP_CONST)
d1971 6
a1976 11
	/* Make the CONST have a shared SV */
	svp = cSVOPx_svp(((BINOP*)o)->op_last);
	if ((!SvIsCOW(sv = *svp))
	    && SvTYPE(sv) < SVt_PVMG && !SvROK(sv)) {
	    key = SvPV_const(sv, keylen);
	    lexname = newSVpvn_share(key,
		SvUTF8(sv) ? -(I32)keylen : (I32)keylen,
		0);
	    SvREFCNT_dec_NN(sv);
	    *svp = lexname;
	}
d1978 6
a1983 1
	if ((o->op_private & (OPpLVAL_INTRO)))
d1985 1
d1987 3
a1989 19
	rop = (UNOP*)((BINOP*)o)->op_first;
	if (rop->op_type != OP_RV2HV || rop->op_first->op_type != OP_PADSV)
	    break;
	lexname = *av_fetch(PL_comppad_name, rop->op_first->op_targ, TRUE);
	if (!SvPAD_TYPED(lexname))
	    break;
	fields = (GV**)hv_fetchs(SvSTASH(lexname), "FIELDS", FALSE);
	if (!fields || !GvHV(*fields))
	    break;
	key = SvPV_const(*svp, keylen);
	if (!hv_fetch(GvHV(*fields), key,
		SvUTF8(*svp) ? -(I32)keylen : (I32)keylen, FALSE)) {
	    Perl_croak(aTHX_ "No such class field \"%"SVf"\" " 
			   "in variable %"SVf" of type %"HEKf, 
		      SVfARG(*svp), SVfARG(lexname),
                      HEKfARG(HvNAME_HEK(SvSTASH(lexname))));
	}
	break;
    }
a1990 14
    case OP_HSLICE: {
	UNOP *rop;
	SV *lexname;
	GV **fields;
	SV **svp;
	const char *key;
	STRLEN keylen;
	SVOP *first_key_op, *key_op;

	if ((o->op_private & (OPpLVAL_INTRO))
	    /* I bet there's always a pushmark... */
	    || ((LISTOP*)o)->op_first->op_sibling->op_type != OP_LIST)
	    /* hmmm, no optimization if list contains only one key. */
	    break;
d1992 5
a1996 3
	if (rop->op_type != OP_RV2HV)
	    break;
	if (rop->op_first->op_type == OP_PADSV)
d2007 1
a2007 1
		break;
d2010 10
a2019 10
	lexname = *av_fetch(PL_comppad_name, rop->op_targ, TRUE);
	if (!SvPAD_TYPED(lexname))
	    break;
	fields = (GV**)hv_fetchs(SvSTASH(lexname), "FIELDS", FALSE);
	if (!fields || !GvHV(*fields))
	    break;
	/* Again guessing that the pushmark can be jumped over.... */
	first_key_op = (SVOP*)((LISTOP*)((LISTOP*)o)->op_first->op_sibling)
	    ->op_first->op_sibling;
	for (key_op = first_key_op; key_op;
d2021 1
d2025 14
a2038 3
	    key = SvPV_const(*svp, keylen);
	    if (!hv_fetch(GvHV(*fields), key,
		    SvUTF8(*svp) ? -(I32)keylen : (I32)keylen, FALSE)) {
d2047 3
d2077 1
a2077 1
generates errors for them. For example, C<$x+1 = 2> would cause it to be
d2086 15
d2253 5
a2257 1
	if (type == OP_LEAVESUBLV)
d2264 5
d2301 2
a2302 1
	if (type == OP_LEAVESUBLV)
a2329 3
	pad_free(o->op_targ);
	o->op_targ = pad_alloc(o->op_type, SVs_PADMY);
	assert(SvTYPE(PAD_SV(o->op_targ)) == SVt_NULL);
d2346 3
a2349 1
    case OP_LEAVE:
d2384 10
a2653 1
    ENTER;		/* need to protect against side-effects of 'use' */
a2666 1
    LEAVE;
a2685 1
    ENTER;		/* need to protect against side-effects of 'use' */
a2692 1
    LEAVE;
d2770 108
d2907 1
a2907 5
	    yyerror(Perl_form(aTHX_ "Can't declare %s in \"%s\"",
			OP_DESC(o),
			PL_parser->in_my == KEY_our
			    ? "our"
			    : PL_parser->in_my == KEY_state ? "state" : "my"));
d2926 1
a2926 5
	yyerror(Perl_form(aTHX_ "Can't declare %s in \"%s\"",
			  OP_DESC(o),
			  PL_parser->in_my == KEY_our
			    ? "our"
			    : PL_parser->in_my == KEY_state ? "state" : "my"));
a3023 1
      GV *gv;
d3025 1
a3025 8
       (ltype == OP_RV2AV || ltype == OP_RV2HV)
        ?    cUNOPx(left)->op_first->op_type == OP_GV
          && (gv = cGVOPx_gv(cUNOPx(left)->op_first))
              ? varname(gv, isary ? '@@' : '%', 0, NULL, 0, 1)
              : NULL
        : varname(
           (GV *)PL_compcv, isary ? '@@' : '%', left->op_targ, NULL, 0, 1
          );
d3049 1
d3052 1
a3180 1
    CopHINTS_set(&PL_compiling, PL_hints);
d3255 1
a3255 1
at compile time. See L<perlguts/"Compile-time scope hooks">.
d3318 1
d3363 1
d3518 1
d3547 5
d3606 1
d3638 5
d3646 4
a3649 1
	newop = newSVOP(OP_CONST, OPpCONST_FOLDED<<8, MUTABLE_SV(sv));
d3662 3
a3664 1
    const I32 oldtmps_floor = PL_tmps_floor;
d3670 1
a3670 1
    PL_op = curop = LINKLIST(o);
d3673 2
d3689 8
a3696 1
    ((UNOP*)o)->op_first = newSVOP(OP_CONST, 0, SvREFCNT_inc_NN(*PL_stack_sp--));
d4312 1
a4312 1
    assert((PL_opargs[type] & OA_CLASS_MASK) == OA_BINOP
d4429 3
a4431 5
/* There are several snags with this code on EBCDIC:
   1. 0xFF is a legal UTF-EBCDIC byte (there are no illegal bytes).
   2. scan_const() in toke.c has encoded chars in native encoding which makes
      ranges at least in EBCDIC 0..255 range the bottom odd.
*/
d4441 1
a4441 1
		cp[2*i] = utf8n_to_uvuni(t, tend-t, &ulen, flags);
d4443 1
a4443 1
		if (t < tend && NATIVE_TO_UTF(*t) == 0xff) {
d4445 1
a4445 1
		    cp[2*i+1] = utf8n_to_uvuni(t, tend-t, &ulen, flags);
d4458 1
a4458 1
		    t = uvuni_to_utf8(tmpbuf,nextmin);
d4461 2
a4462 2
			U8  range_mark = UTF_TO_NATIVE(0xff);
			t = uvuni_to_utf8(tmpbuf, val - 1);
d4471 1
a4471 1
	    t = uvuni_to_utf8(tmpbuf,nextmin);
d4474 1
a4474 1
		U8 range_mark = UTF_TO_NATIVE(0xff);
d4477 1
a4477 1
	    t = uvuni_to_utf8(tmpbuf, 0x7fffffff);
d4498 1
a4498 1
		tfirst = (I32)utf8n_to_uvuni(t, tend - t, &ulen, flags);
d4500 1
a4500 1
		if (t < tend && NATIVE_TO_UTF(*t) == 0xff) {	/* illegal utf8 val indicates range */
d4502 1
a4502 1
		    tlast = (I32)utf8n_to_uvuni(t, tend - t, &ulen, flags);
d4512 1
a4512 1
		    rfirst = (I32)utf8n_to_uvuni(r, rend - r, &ulen, flags);
d4514 1
a4514 1
		    if (r < rend && NATIVE_TO_UTF(*r) == 0xff) {	/* illegal utf8 val indicates range */
d4516 1
a4516 1
			rlast = (I32)utf8n_to_uvuni(r, rend - r, &ulen, flags);
d4578 1
a4578 1
	cPADOPo->op_padix = pad_alloc(OP_TRANS, SVs_PADTMP);
d4684 1
a4684 1
    } else if(rlen > tlen) {
d4768 1
a4768 1
	pmop->op_pmoffset = av_len(PL_regex_padav);
d4901 1
a5087 4
	if (pm->op_pmflags & PMf_EVAL) {
	    if (CopLINE(PL_curcop) < (line_t)PL_parser->multi_end)
		CopLINE_set(PL_curcop, (line_t)PL_parser->multi_end);
	}
a5217 1
    SvPADTMP_on(sv);
d5227 1
a5227 1
#endif /* !USE_ITHREADS */
d5262 1
a5262 1
must have been allocated using L</PerlMemShared_malloc>; the memory will
d5507 2
a5508 1
(or 0 for no flags). ver, if specified and not NULL, provides version semantics
d5581 2
a5582 1
     * since pp_require() will create another parser for the real work. */
d5592 9
d5606 1
a5606 1
    GV *gv = NULL;
d5610 2
a5611 13
    if (!force_builtin) {
	gv = gv_fetchpvs("do", GV_NOTQUAL, SVt_PVCV);
	if (!(gv && GvCVu(gv) && GvIMPORTED_CV(gv))) {
	    GV * const * const gvp = (GV**)hv_fetchs(PL_globalstash, "do", FALSE);
	    gv = gvp ? *gvp : NULL;
	}
    }

    if (gv && GvCVu(gv) && GvIMPORTED_CV(gv)) {
	doop = newUNOP(OP_ENTERSUB, OPf_STACKED,
			       op_append_elem(OP_LIST, term,
					   scalar(newUNOP(OP_RV2CV, 0,
							  newGVOP(OP_GV, 0, gv)))));
d5675 2
a5676 1
	type == OP_ASLICE || type == OP_HSLICE)
d5727 1
d5729 3
a5731 7
		if (((PMOP*)curop)->op_pmreplrootu.op_pmtargetoff) {
		    GV *const gv = MUTABLE_GV(PAD_SVl(((PMOP*)curop)->op_pmreplrootu.op_pmtargetoff));
		    if (gv == PL_defgv
			|| (int)GvASSIGN_GENERATION(gv) == PL_generation)
			return TRUE;
		    GvASSIGN_GENERATION_set(gv, PL_generation);
		}
d5733 2
a5734 2
		GV *const gv
		    = ((PMOP*)curop)->op_pmreplrootu.op_pmtargetgv;
a5740 1
#endif
d5801 3
d5810 1
a5810 2
	if ((left->op_type == OP_LIST
	     || (left->op_type == OP_NULL && left->op_targ == OP_LIST)))
d5836 1
a5836 1
			   lop->op_type == OP_PUSHMARK) {
d5928 3
a5930 1
			SV *sv = ((SVOP*)((LISTOP*)right)->op_last)->op_sv;
d5932 4
d5937 7
d5969 1
a5969 1
code.  The state op is populated from L</PL_curcop> (or L</PL_compiling>).
d6006 3
a6008 1
    CopHINTS_set(&PL_compiling, CopHINTS_get(cop));
d6024 5
a6028 1
    if (PL_parser && PL_parser->copline == NOLINE)
d6041 1
a6041 1
    if ((PERLDB_LINE || PERLDB_SAVESRC) && PL_curstash != PL_debstash) {
d6045 1
a6045 1
	    SV * const * const svp = av_fetch(av, (I32)CopLINE(cop), FALSE);
d6141 38
d6230 2
a6231 2
	    else if (other->op_type == OP_CONST)
		other->op_private |= OPpCONST_FOLDED;
d6253 2
a6254 2
	    if (first->op_type == OP_CONST)
		first->op_private |= OPpCONST_SHORTCIRCUIT;
d6391 1
a6391 2
	else if (live->op_type == OP_CONST)
	    live->op_private |= OPpCONST_FOLDED;
d6512 1
a6512 1
      (block->op_type == OP_ENTERSUB || block->op_type == OP_NULL);
d6517 9
a6525 1
	if (once && expr->op_type == OP_CONST && !SvTRUE(((SVOP*)expr)->op_sv))
d6564 4
d6572 3
d6576 1
d6939 3
a6941 1
    ||  cond->op_type == OP_HSLICE)) {
d7152 3
a7154 2
    const char * const cvp = SvROK(cv) ? "" : CvPROTO(cv);
    const STRLEN clen = CvPROTOLEN(cv);
d7158 25
a7182 15
    if (((!p != !cvp) /* One has prototype, one has not.  */
	|| (p && (
		  (flags & SVf_UTF8) == SvUTF8(cv)
		   ? len != clen || memNE(cvp, p, len)
		   : flags & SVf_UTF8
		      ? bytes_cmp_utf8((const U8 *)cvp, clen,
				       (const U8 *)p, len)
		      : bytes_cmp_utf8((const U8 *)p, len,
				       (const U8 *)cvp, clen)
		 )
	   )
        )
	 && ckWARN_d(WARN_PROTOTYPE)) {
	SV* const msg = sv_newmortal();
	SV* name = NULL;
d7184 3
a7186 3
	if (gv)
	{
	  if (isGV(gv))
d7188 19
a7206 21
	  else if (SvPOK(gv) && *SvPVX((SV *)gv) == '&')
	    name = newSVpvn_flags(SvPVX((SV *)gv)+1, SvCUR(gv)-1,
				  SvUTF8(gv)|SVs_TEMP);
	  else name = (SV *)gv;
	}
	sv_setpvs(msg, "Prototype mismatch:");
	if (name)
	    Perl_sv_catpvf(aTHX_ msg, " sub %"SVf, SVfARG(name));
	if (cvp)
	    Perl_sv_catpvf(aTHX_ msg, " (%"SVf")",
		SVfARG(newSVpvn_flags(cvp,clen, SvUTF8(cv)|SVs_TEMP))
	    );
	else
	    sv_catpvs(msg, ": none");
	sv_catpvs(msg, " vs ");
	if (p)
	    Perl_sv_catpvf(aTHX_ msg, "(%"SVf")", SVfARG(newSVpvn_flags(p, len, flags | SVs_TEMP)));
	else
	    sv_catpvs(msg, "none");
	Perl_warner(aTHX_ packWARN(WARN_PROTOTYPE), "%"SVf, SVfARG(msg));
    }
d7210 1
d7218 1
a7218 1
If C<cv> is a constant sub eligible for inlining. returns the constant
d7229 1
d7235 12
d7386 1
a7386 1
	SvREFCNT_dec(cv);
d7432 3
d7510 1
a7510 1
	    if (S_already_defined(aTHX_ cv, block, NULL, name, &const_sv))
d7526 1
d7664 1
d7745 1
d7747 2
a7748 8
Perl_newATTRSUB(pTHX_ I32 floor, OP *o, OP *proto, OP *attrs, OP *block)
{
    return newATTRSUB_flags(floor, o, proto, attrs, block, 0);
}

CV *
Perl_newATTRSUB_flags(pTHX_ I32 floor, OP *o, OP *proto, OP *attrs,
			    OP *block, U32 flags)
a7768 1
    const bool o_is_gv = flags & 1;
a7776 8
    if (proto) {
	assert(proto->op_type == OP_CONST);
	ps = SvPV_const(((SVOP*)proto)->op_sv, ps_len);
        ps_utf8 = SvUTF8(((SVOP*)proto)->op_sv);
    }
    else
	ps = NULL;

d7799 11
d7895 1
d8026 1
d8101 1
d8104 1
d8114 1
a8114 1
	    CopHINTS_set(&PL_compiling, PL_hints);
a8198 1
#ifdef USE_ITHREADS
a8199 4
#else
    SV *const temp_sv = CopFILESV(PL_curcop);
    const char *const file = temp_sv ? SvPV_nolen_const(temp_sv) : NULL;
#endif
d8230 5
a8234 1
    cv = newXS_len_flags(name, len, const_sv_xsub, file ? file : "", "",
d8262 1
d8292 3
a8294 1
                SvREFCNT_dec_NN(cv);
d8329 1
d8337 1
d8344 6
a8349 1
    CvGV_set(cv, gv);
d8430 1
d8483 1
d8489 1
d8616 56
d8799 6
d8806 2
a8807 2
	    Perl_croak(aTHX_ "%s argument is not a HASH or ARRAY element or slice",
		  OP_DESC(o));
a8816 11
Perl_ck_die(pTHX_ OP *o)
{
    PERL_ARGS_ASSERT_CK_DIE;

#ifdef VMS
    if (VMSISH_HUSHED) o->op_private |= OPpHUSH_VMSISH;
#endif
    return ck_fun(o);
}

OP *
d8853 1
d8855 1
a8855 5
	if (!kid) {
	    o->op_flags &= ~OPf_KIDS;
	    op_null(o);
	}
	else if (kid->op_type == OP_LINESEQ || kid->op_type == OP_STUB) {
a8912 17
Perl_ck_exit(pTHX_ OP *o)
{
    PERL_ARGS_ASSERT_CK_EXIT;

#ifdef VMS
    HV * const table = GvHV(PL_hintgv);
    if (table) {
       SV * const * const svp = hv_fetchs(table, "vmsish_exit", FALSE);
       if (svp && *svp && SvTRUE(*svp))
           o->op_private |= OPpEXIT_VMSISH;
    }
    if (VMSISH_HUSHED) o->op_private |= OPpHUSH_VMSISH;
#endif
    return ck_fun(o);
}

OP *
d8943 2
a8944 2
		Perl_croak(aTHX_ "%s argument is not a subroutine name",
			    OP_DESC(o));
d8950 2
a8951 2
	    Perl_croak(aTHX_ "%s argument is not a HASH or ARRAY element or a subroutine",
		        OP_DESC(o));
d9002 1
d9051 1
d9084 1
a9084 1
	 && !(kid->op_private & OPpCONST_FOLDED)) {
d9186 1
a9186 1
		scalar(kid);
d9228 8
a9235 1
		else scalar(kid);
d9373 1
a9373 1
				targ = pad_alloc(OP_RV2GV, SVs_PADTMP);
a9374 1
				SvUPGRADE(namesv, SVt_PV);
d9377 2
a9442 1
    const bool core = o->op_flags & OPf_SPECIAL;
d9450 1
a9450 3
    if (core) gv = NULL;
    else if (!((gv = gv_fetchpvs("glob", GV_NOTQUAL, SVt_PVCV))
	  && GvCVu(gv) && GvIMPORTED_CV(gv)))
a9451 6
	GV * const * const gvp =
	    (GV **)hv_fetchs(PL_globalstash, "glob", FALSE);
	gv = gvp ? *gvp : NULL;
    }

    if (gv && GvCVu(gv) && GvIMPORTED_CV(gv)) {
d9466 1
a9466 5
	o = newLISTOP(OP_LIST, 0, o, NULL);
	o = newUNOP(OP_ENTERSUB, OPf_STACKED,
		    op_append_elem(OP_LIST, o,
				scalar(newUNOP(OP_RV2CV, 0,
					       newGVOP(OP_GV, 0, gv)))));
d9557 8
a9564 1
	    fbm_compile(((SVOP*)kid)->op_sv, 0);
d9664 1
a9664 1
	 && !(kid->op_private & OPpCONST_FOLDED)) {
d9748 1
a9748 1
	     (kkid->op_type == OP_LIST &&
d9811 1
a9811 1
	    if (!SvIsCOW(sv)) {
a9840 1
    HV * const table = GvHV(PL_hintgv);
d9844 1
a9844 35
    if (table) {
	SV **svp = hv_fetchs(table, "open_IN", FALSE);
	if (svp && *svp) {
	    STRLEN len = 0;
	    const char *d = SvPV_const(*svp, len);
	    const I32 mode = mode_from_discipline(d, len);
	    if (mode & O_BINARY)
		o->op_private |= OPpOPEN_IN_RAW;
	    else if (mode & O_TEXT)
		o->op_private |= OPpOPEN_IN_CRLF;
	}

	svp = hv_fetchs(table, "open_OUT", FALSE);
	if (svp && *svp) {
	    STRLEN len = 0;
	    const char *d = SvPV_const(*svp, len);
	    const I32 mode = mode_from_discipline(d, len);
	    if (mode & O_BINARY)
		o->op_private |= OPpOPEN_OUT_RAW;
	    else if (mode & O_TEXT)
		o->op_private |= OPpOPEN_OUT_CRLF;
	}
    }
    if (o->op_type == OP_BACKTICK) {
	if (!(o->op_flags & OPf_KIDS)) {
	    OP * const newop = newUNOP(OP_BACKTICK, 0, newDEFSVOP());
#ifdef PERL_MAD
	    op_getmad(o,newop,'O');
#else
	    op_free(o);
#endif
	    return newop;
	}
	return o;
    }
d9886 1
a9886 1
    GV* gv = NULL;
d9921 1
a9921 1
    if (!(o->op_flags & OPf_SPECIAL)) { /* Wasn't written as CORE::require */
d9923 1
a9923 8
	gv = gv_fetchpvs("require", GV_NOTQUAL, SVt_PVCV);
	if (!(gv && GvCVu(gv) && GvIMPORTED_CV(gv))) {
	    GV * const * const gvp = (GV**)hv_fetchs(PL_globalstash, "require", FALSE);
	    gv = gvp ? *gvp : NULL;
	}
    }

    if (gv && GvCVu(gv) && GvIMPORTED_CV(gv)) {
d9935 1
a9935 5
	newop = newUNOP(OP_ENTERSUB, OPf_STACKED,
				op_append_elem(OP_LIST, kid,
					    scalar(newUNOP(OP_RV2CV, 0,
							   newGVOP(OP_GV, 0,
								   gv)))));
d10021 4
a10024 1
    HV * const hinthv = GvHV(PL_hintgv);
d10042 2
a10043 1
    if (o->op_flags & OPf_STACKED) {			/* may have been cleared */
d10046 2
d10064 6
a10069 2
    /* provide list context for arguments */
    list(firstkid);
d10074 10
a10096 4
    if (!(o->op_flags & OPf_STACKED))
	return;
    GvMULTI_on(gv_fetchpvs("a", GV_ADD|GV_NOTQUAL, SVt_PV));
    GvMULTI_on(gv_fetchpvs("b", GV_ADD|GV_NOTQUAL, SVt_PV));
d10235 1
d10237 2
d10460 1
d10505 1
a10505 1
		    bad_type_sv(arg,
d10507 1
a10507 1
			    gv_ename(namegv), 0, o3);
d10592 1
a10592 1
			    bad_type_sv(arg, Perl_form(aTHX_ "one of %.*s",
d10594 1
a10594 1
				    gv_ename(namegv), 0, o3);
d10602 1
a10602 1
			    bad_type_sv(arg, "symbol", gv_ename(namegv), 0, o3);
d10608 1
a10608 1
			    bad_type_sv(arg, "subroutine entry", gv_ename(namegv), 0,
d10624 1
a10624 1
			    bad_type_sv(arg, "scalar", gv_ename(namegv), 0, o3);
d10632 1
a10632 1
			    bad_type_sv(arg, "array", gv_ename(namegv), 0, o3);
d10639 1
a10639 1
			    bad_type_sv(arg, "hash", gv_ename(namegv), 0, o3);
d10763 1
a10763 1
	assert(0);
d10873 5
a10877 2
for it is supplied in I<ckobj>.  The function is intended to be called
in this manner:
d10982 1
d10985 17
a11001 1
    if (!SvIsCOW(cSVOPo->op_sv)) SvREADONLY_on(cSVOPo->op_sv);
d11016 2
a11017 2
	    (kid->op_private & (OPpCONST_BARE|OPpCONST_FOLDED))
			     == OPpCONST_BARE)
d11093 7
a11099 1
    return o->op_type == ref_type ? o : ck_fun(o);
a11118 5
                    name = varname(
                        (GV *)PL_compcv, hash ? '%' : '@@', kid->op_targ,
                        NULL, 0, 1
                    );
                    break;
d11121 1
a11121 6
                    if (cUNOPx(kid)->op_first->op_type != OP_GV) break;
                    {
                        GV *gv = cGVOPx_gv(cUNOPx(kid)->op_first);
                        if (!gv) break;
                        name = varname(gv, hash?'%':'@@', 0, NULL, 0, 1);
                    }
d11133 1
d11137 1
d11229 4
d11238 3
a11240 1
	CALL_RPEEP(defer_queue[defer_base]); \
d11244 1
a11244 1
    defer_queue[(defer_base + ++defer_ix) % MAX_DEFERRED] = o; \
d11247 24
d11281 1
a11281 1
    OP* defer_queue[MAX_DEFERRED]; /* small queue of deferred branches */
d11294 6
a11299 2
	    while (defer_ix >= 0)
		CALL_RPEEP(defer_queue[(defer_base + defer_ix--) % MAX_DEFERRED]);
d11307 38
d11352 104
d11544 1
a11544 1
	    if (oldop && o->op_next) {
d11635 1
a11635 1
                /* let $a[N] potentially be optimised into ALEMFAST_LEX
d11707 1
a11707 1
                if (followop->op_type == OP_LIST
a11729 1
                        assert(oldoldop->op_targ + old_count == base);
d11731 7
a11737 1
                        if (old_count < OPpPADRANGE_COUNTMASK - count) {
d11758 1
d11809 1
a11809 1
		    (i = SvIV(((SVOP*)pop)->op_sv)) <= 255 && i >= 0)
d11885 15
d11975 5
d11992 22
a12013 6
	    if (o->op_flags & OPf_STACKED) {
		OP * const kid =
		    cUNOPx(cLISTOP->op_first->op_sibling)->op_first;
		if (kid->op_type == OP_SCOPE
		 || (kid->op_type == OP_NULL && kid->op_targ == OP_LEAVE))
		    DEFER(kLISTOP->op_first);
d12165 17
d12200 1
a12200 1
		XopENTRY(Perl_custom_op_xop(aTHX_ o), xop_peep);
d12207 10
a12216 2
	oldoldop = oldop;
	oldop = o;
d12231 1
a12231 1
Return the XOP structure for a given custom op. This function should be
d12233 3
d12240 2
a12241 2
const XOP *
Perl_custom_op_xop(pTHX_ const OP *o)
d12249 1
a12249 1
    PERL_ARGS_ASSERT_CUSTOM_OP_XOP;
a12280 1
	return xop;
d12282 52
a12333 5

    if (!he) return &xop_null;

    xop = INT2PTR(XOP *, SvIV(HeVAL(he)));
    return xop;
d12338 1
a12338 1
Register a custom op. See L<perlguts/"Custom Operators">.
d12367 1
a12367 1
by C<keyword()>.  It must not be equal to 0 or -KEY_CORE.
d12384 1
a12384 1
    assert (code && code != -KEY_CORE);
d12601 12
d12666 1
a12666 8
    if (items != 0) {
	NOOP;
#if 0
	/* diag_listed_as: SKIPME */
        Perl_croak(aTHX_ "usage: %s::%s()",
                   HvNAME_get(GvSTASH(CvGV(cv))), GvNAME(CvGV(cv)));
#endif
    }
d12673 25
@


1.16
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d106 1
d112 1
a112 1
#if defined(PL_OP_SLAB_ALLOC)
d115 2
a116 1
#  define PERL_SLAB_SIZE 4096
d121 1
a121 1
#define PERL_SLAB_SIZE 2048
d123 34
d162 95
a256 22
    /*
     * To make incrementing use count easy PL_OpSlab is an I32 *
     * To make inserting the link to slab PL_OpPtr is I32 **
     * So compute size in units of sizeof(I32 *) as that is how Pl_OpPtr increments
     * Add an overhead for pointer to slab and round up as a number of pointers
     */
    sz = (sz + 2*sizeof(I32 *) -1)/sizeof(I32 *);
    if ((PL_OpSpace -= sz) < 0) {
#ifdef PERL_DEBUG_READONLY_OPS
	/* We need to allocate chunk by chunk so that we can control the VM
	   mapping */
	PL_OpPtr = (I32**) mmap(0, PERL_SLAB_SIZE*sizeof(I32*), PROT_READ|PROT_WRITE,
			MAP_ANON|MAP_PRIVATE, -1, 0);

	DEBUG_m(PerlIO_printf(Perl_debug_log, "mapped %lu at %p\n",
			      (unsigned long) PERL_SLAB_SIZE*sizeof(I32*),
			      PL_OpPtr));
	if(PL_OpPtr == MAP_FAILED) {
	    perror("mmap failed");
	    abort();
	}
#else
d258 1
a258 16
        PL_OpPtr = (I32 **) PerlMemShared_calloc(PERL_SLAB_SIZE,sizeof(I32*)); 
#endif
    	if (!PL_OpPtr) {
	    return NULL;
	}
	/* We reserve the 0'th I32 sized chunk as a use count */
	PL_OpSlab = (I32 *) PL_OpPtr;
	/* Reduce size by the use count word, and by the size we need.
	 * Latter is to mimic the '-=' in the if() above
	 */
	PL_OpSpace = PERL_SLAB_SIZE - (sizeof(I32)+sizeof(I32 **)-1)/sizeof(I32 **) - sz;
	/* Allocation pointer starts at the top.
	   Theory: because we build leaves before trunk allocating at end
	   means that at run time access is cache friendly upward
	 */
	PL_OpPtr += PERL_SLAB_SIZE;
d261 14
a274 16
	/* We remember this slab.  */
	/* This implementation isn't efficient, but it is simple. */
	PL_slabs = (I32**) realloc(PL_slabs, sizeof(I32**) * (PL_slab_count + 1));
	PL_slabs[PL_slab_count++] = PL_OpSlab;
	DEBUG_m(PerlIO_printf(Perl_debug_log, "Allocate %p\n", PL_OpSlab));
#endif
    }
    assert( PL_OpSpace >= 0 );
    /* Move the allocation pointer down */
    PL_OpPtr   -= sz;
    assert( PL_OpPtr > (I32 **) PL_OpSlab );
    *PL_OpPtr   = PL_OpSlab;	/* Note which slab it belongs to */
    (*PL_OpSlab)++;		/* Increment use count of slab */
    assert( PL_OpPtr+sz <= ((I32 **) PL_OpSlab + PERL_SLAB_SIZE) );
    assert( *PL_OpSlab > 0 );
    return (void *)(PL_OpPtr + 1);
a276 1
#ifdef PERL_DEBUG_READONLY_OPS
d278 23
a300 4
Perl_pending_Slabs_to_ro(pTHX) {
    /* Turn all the allocated op slabs read only.  */
    U32 count = PL_slab_count;
    I32 **const slabs = PL_slabs;
d302 6
a307 3
    /* Reset the array of pending OP slabs, as we're about to turn this lot
       read only. Also, do it ahead of the loop in case the warn triggers,
       and a warn handler has an eval */
d309 6
a314 2
    PL_slabs = NULL;
    PL_slab_count = 0;
d316 1
a316 2
    /* Force a new slab for any further allocation.  */
    PL_OpSpace = 0;
d318 4
a321 7
    while (count--) {
	void *const start = slabs[count];
	const size_t size = PERL_SLAB_SIZE* sizeof(I32*);
	if(mprotect(start, size, PROT_READ)) {
	    Perl_warn(aTHX_ "mprotect for %p %lu failed with %d",
		      start, (unsigned long) size, errno);
	}
d324 8
a331 1
    free(slabs);
d334 2
a335 2
STATIC void
S_Slab_to_rw(pTHX_ void *op)
d337 10
a346 2
    I32 * const * const ptr = (I32 **) op;
    I32 * const slab = ptr[-1];
d348 25
a372 1
    PERL_ARGS_ASSERT_SLAB_TO_RW;
d374 35
a408 6
    assert( ptr-1 > (I32 **) slab );
    assert( ptr < ( (I32 **) slab + PERL_SLAB_SIZE) );
    assert( *slab > 0 );
    if(mprotect(slab, PERL_SLAB_SIZE*sizeof(I32*), PROT_READ|PROT_WRITE)) {
	Perl_warn(aTHX_ "mprotect RW for %p %lu failed with %d",
		  slab, (unsigned long) PERL_SLAB_SIZE*sizeof(I32*), errno);
d410 2
d414 1
d419 8
a426 2
	Slab_to_rw(o);
	++o->op_targ;
d435 3
a438 6
    Slab_to_rw(o);
    return --o->op_targ;
}
#else
#  define Slab_to_rw(op)
#endif
d440 6
a445 45
void
Perl_Slab_Free(pTHX_ void *op)
{
    I32 * const * const ptr = (I32 **) op;
    I32 * const slab = ptr[-1];
    PERL_ARGS_ASSERT_SLAB_FREE;
    assert( ptr-1 > (I32 **) slab );
    assert( ptr < ( (I32 **) slab + PERL_SLAB_SIZE) );
    assert( *slab > 0 );
    Slab_to_rw(op);
    if (--(*slab) == 0) {
#  ifdef NETWARE
#    define PerlMemShared PerlMem
#  endif
	
#ifdef PERL_DEBUG_READONLY_OPS
	U32 count = PL_slab_count;
	/* Need to remove this slab from our list of slabs */
	if (count) {
	    while (count--) {
		if (PL_slabs[count] == slab) {
		    dVAR;
		    /* Found it. Move the entry at the end to overwrite it.  */
		    DEBUG_m(PerlIO_printf(Perl_debug_log,
					  "Deallocate %p by moving %p from %lu to %lu\n",
					  PL_OpSlab,
					  PL_slabs[PL_slab_count - 1],
					  PL_slab_count, count));
		    PL_slabs[count] = PL_slabs[--PL_slab_count];
		    /* Could realloc smaller at this point, but probably not
		       worth it.  */
		    if(munmap(slab, PERL_SLAB_SIZE*sizeof(I32*))) {
			perror("munmap failed");
			abort();
		    }
		    break;
		}
	    }
	}
#else
    PerlMemShared_free(slab);
#endif
	if (slab == PL_OpSlab) {
	    PL_OpSpace = 0;
	}
d447 1
d594 7
d624 37
a666 4
    if (o->op_latefree) {
	o->op_latefreed = 1;
	return;
    }
a669 6
#ifdef USE_ITHREADS
#  define forget_pmop(a,b)	S_forget_pmop(aTHX_ a,b)
#else
#  define forget_pmop(a,b)	S_forget_pmop(aTHX_ a)
#endif

d678 6
a683 1
    if (!o)
a684 5
    if (o->op_latefreed) {
	if (o->op_latefree)
	    return;
	goto do_free;
    }
d719 1
a719 1
        register OP *kid, *nextkid;
d725 2
d728 3
a730 3
#ifdef PERL_DEBUG_READONLY_OPS
    Slab_to_rw(o);
#endif
d734 1
a734 4
    if (type == OP_NEXTSTATE || type == OP_DBSTATE
	    || (type == OP_NULL /* the COP might have been null'ed */
		&& ((OPCODE)o->op_targ == OP_NEXTSTATE
		    || (OPCODE)o->op_targ == OP_DBSTATE))) {
a737 3
    if (type == OP_NULL)
	type = (OPCODE)o->op_targ;

a738 5
    if (o->op_latefree) {
	o->op_latefreed = 1;
	return;
    }
  do_free:
d816 1
a816 1
		SvREFCNT_dec(gv);
d840 1
d851 1
d884 4
a887 1
	forget_pmop(cPMOPo, 1);
a922 1
    CopSTASH_free(cop);
a929 3
#ifdef USE_ITHREADS
	      , U32 flags
#endif
a961 4
#ifdef USE_ITHREADS
    if (flags)
	PmopSTASH_free(o);
#endif
d977 1
a977 1
		forget_pmop((PMOP*)kid, 0);
d1068 1
a1068 1
        register OP *kid;
d1110 3
a1112 1
	    if (PL_parser && PL_parser->copline != NOLINE)
d1114 1
d1193 1
a1194 1
    U32 useless_is_utf8 = 0;
d1395 9
a1403 7
			SV* msv = sv_2mortal(Perl_newSVpvf(aTHX_
				    "a constant (%s)",
				    pv_pretty(dsv, maybe_macro, SvCUR(sv), 32, NULL, NULL,
					    PERL_PV_PRETTY_DUMP | PERL_PV_ESCAPE_NOCLEAR | PERL_PV_ESCAPE_UNI_DETECT )));
			SvREFCNT_dec(dsv);
			useless = SvPV_nolen(msv);
			useless_is_utf8 = SvUTF8(msv);
d1407 1
a1407 3
		    SV* msv = sv_2mortal(Perl_newSVpvf(aTHX_
				"a constant (%"SVf")", sv));
		    useless = SvPV_nolen(msv);
d1534 12
a1545 4
    if (useless)
       Perl_ck_warner(aTHX_ packWARN(WARN_VOID), "Useless use of %"SVf" in void context",
                       newSVpvn_flags(useless, strlen(useless),
                            SVs_TEMP | ( useless_is_utf8 ? SVf_UTF8 : 0 )));
d1772 1
a1772 1
		SvREADONLY_on(PAD_SVl(ix));
d1792 1
a1792 1
		SvREADONLY_on(PAD_SVl(ix));
d1813 1
a1813 1
	if ((!SvFAKE(sv = *svp) || !SvREADONLY(sv))
d1819 1
a1819 1
	    SvREFCNT_dec(sv);
d1902 1
a1960 1
	localize = 0;
d2087 3
a2091 1
	localize = 1;
a2092 1
    case OP_AASSIGN:
d2209 3
a2248 2
    assert(o || type != OP_SASSIGN);

d2250 1
d2252 1
a2252 1
	if (o->op_type == OP_RV2GV)
d2400 1
a2400 1
	if (!(o->op_flags & OPf_KIDS))
d2464 1
a2464 1
S_apply_attrs(pTHX_ HV *stash, SV *target, OP *attrs, bool for_my)
d2467 1
a2467 1
    SV *stashsv;
a2472 1
    stashsv = stash ? newSVhek(HvNAME_HEK(stash)) : &PL_sv_no;
d2477 1
a2477 11
    if (for_my) {
	/* Don't force the C<use> if we don't need it. */
	SV * const * const svp = hv_fetchs(GvHVn(PL_incgv), ATTRSMODULE_PM, FALSE);
	if (svp && *svp != &PL_sv_undef)
	    NOOP;	/* already in %INC */
	else
	    Perl_load_module(aTHX_ PERL_LOADMOD_NOIMPORT,
			     newSVpvs(ATTRSMODULE), NULL);
    }
    else {
	Perl_load_module(aTHX_ PERL_LOADMOD_IMPORT_OPS,
a2485 1
    }
d2494 1
a2494 1
    SV *meth, *stashsv;
d2506 9
a2514 1
    apply_attrs(stash, PAD_SV(target->op_targ), attrs, TRUE);
d2615 1
a2615 5
    } else if (type == OP_UNDEF
#ifdef PERL_MAD
	       || type == OP_STUB
#endif
	       ) {
d2634 1
a2634 1
			attrs, FALSE);
d2813 1
a2813 1
		pmruntime(newPMOP(OP_MATCH, 0), right, 0));
d2843 1
a2843 1
	if (o->op_flags & OPf_PARENS || PERLDB_NOOPT || PL_tainting) {
d2869 12
d2904 1
d2912 60
a2971 1
    pad_leavemy();
a3037 3
	/* don't use LINKLIST, since PL_eval_root might indirect through
	 * a rather expensive function call and LINKLIST evaluates its
	 * argument more than once */
d3052 26
d3091 1
d3137 1
a3137 1
		       && (isALNUM(*s) || UTF8_IS_CONTINUED(*s))) {
d3140 1
a3140 1
		    while (*s && (isALNUM(*s) || UTF8_IS_CONTINUED(*s)))
d3205 2
a3206 5
    /* integerize op, unless it happens to be C<-foo>.
     * XXX should pp_i_negate() do magic string negation instead? */
    if ((PL_opargs[type] & OA_OTHERINT) && (PL_hints & HINT_INTEGER)
	&& !(type == OP_NEGATE && cUNOPo->op_first->op_type == OP_CONST
	     && (cUNOPo->op_first->op_private & OPpCONST_BARE)))
d3209 1
a3209 1
	o->op_ppaddr = PL_ppaddr[type = ++(o->op_type)];
d3220 1
a3220 1
S_fold_constants(pTHX_ register OP *o)
d3223 1
a3223 1
    register OP * VOL curop;
d3255 18
d3361 1
a3361 1
	newop = newSVOP(OP_CONST, 0, MUTABLE_SV(sv));
d3370 1
a3370 1
S_gen_constant_list(pTHX_ register OP *o)
d3373 1
a3373 1
    register OP *curop;
d3809 1
a3809 1
	Safefree((char*)mp->mad_val);
a3931 3
    o->op_latefree = 0;
    o->op_latefreed = 0;
    o->op_attached = 0;
d4075 2
a4076 2
    register I32 i;
    register I32 j;
d4078 1
a4078 1
    register short *tbl;
d4489 4
d4496 1
a4496 1
Perl_pmruntime(pTHX_ OP *o, OP *expr, bool isreg)
d4503 3
a4505 1
    bool reglist;
d4509 3
a4511 5
    if (
        o->op_type == OP_SUBST
     || o->op_type == OP_TRANS || o->op_type == OP_TRANSR
    ) {
	/* last element in list is the replacement; pop it */
d4521 3
a4523 4
    if (isreg && expr->op_type == OP_LIST &&
	cLISTOPx(expr)->op_first->op_sibling == cLISTOPx(expr)->op_last)
    {
	/* convert single element list to element */
d4525 4
a4528 1
	expr = cLISTOPx(oe)->op_first->op_sibling;
a4531 1
    }
a4532 1
    if (o->op_type == OP_TRANS || o->op_type == OP_TRANSR) {
d4536 79
a4614 3
    reglist = isreg && expr->op_type == OP_LIST;
    if (reglist)
	op_null(expr);
d4618 1
d4620 30
a4649 21
    if (expr->op_type == OP_CONST) {
	SV *pat = ((SVOP*)expr)->op_sv;
	U32 pm_flags = pm->op_pmflags & RXf_PMf_COMPILETIME;

	if (o->op_flags & OPf_SPECIAL)
	    pm_flags |= RXf_SPLIT;

	if (DO_UTF8(pat)) {
	    assert (SvUTF8(pat));
	} else if (SvUTF8(pat)) {
	    /* Not doing UTF-8, despite what the SV says. Is this only if we're
	       trapped in use 'bytes'?  */
	    /* Make a copy of the octet sequence, but without the flag on, as
	       the compiler now honours the SvUTF8 flag on pat.  */
	    STRLEN len;
	    const char *const p = SvPV(pat, len);
	    pat = newSVpvn_flags(p, len, SVs_TEMP);
	}

	PM_SETRE(pm, CALLREGCOMP(pat, pm_flags));

d4651 1
a4651 1
	op_getmad(expr,(OP*)pm,'e');
d4653 1
a4653 1
	op_free(expr);
d4655 32
d4689 69
a4757 4
	if (pm->op_pmflags & PMf_KEEP || !(PL_hints & HINT_RE_EVAL))
	    expr = newUNOP((!(PL_hints & HINT_RE_EVAL)
			    ? OP_REGCRESET
			    : OP_REGCMAYBE),0,expr);
d4766 1
a4766 1
	rcop->op_private = 1;
d4768 1
a4768 2
	if (reglist)
	    rcop->op_targ = pad_alloc(rcop->op_type, SVs_PADTMP);
d4774 1
a4774 1
	if (pm->op_pmflags & PMf_KEEP || !(PL_hints & HINT_RE_EVAL)) {
d4788 2
a4789 1
	OP *curop;
a4790 1
	    curop = NULL;
d4794 24
a4817 37
	else if (repl->op_type == OP_CONST)
	    curop = repl;
	else {
	    OP *lastop = NULL;
	    for (curop = LINKLIST(repl); curop!=repl; curop = LINKLIST(curop)) {
		if (curop->op_type == OP_SCOPE
			|| curop->op_type == OP_LEAVE
			|| (PL_opargs[curop->op_type] & OA_DANGEROUS)) {
		    if (curop->op_type == OP_GV) {
			GV * const gv = cGVOPx_gv(curop);
			repl_has_vars = 1;
			if (strchr("&`'123456789+-\016\022", *GvENAME(gv)))
			    break;
		    }
		    else if (curop->op_type == OP_RV2CV)
			break;
		    else if (curop->op_type == OP_RV2SV ||
			     curop->op_type == OP_RV2AV ||
			     curop->op_type == OP_RV2HV ||
			     curop->op_type == OP_RV2GV) {
			if (lastop && lastop->op_type != OP_GV)	/*funny deref?*/
			    break;
		    }
		    else if (curop->op_type == OP_PADSV ||
			     curop->op_type == OP_PADAV ||
			     curop->op_type == OP_PADHV ||
			     curop->op_type == OP_PADANY)
		    {
			repl_has_vars = 1;
		    }
		    else if (curop->op_type == OP_PUSHRE)
			NOOP; /* Okay here, dangerous in newASSIGNOP */
		    else
			break;
		}
		lastop = curop;
	    }
d4819 2
a4820 1
	if (curop == repl
d4823 1
a4829 3
	    if (curop == repl && !PM_GETRE(pm)) { /* Has variables. */
		pm->op_pmflags |= PMf_MAYBE_CONST;
	    }
d4881 1
d5066 1
a5066 1
    OP *pegop = newOP(OP_NULL,0);
a5200 5
    if (!PL_madskills) {
	/* FIXME - don't allocate pegop if !PL_madskills */
	op_free(pegop);
	return NULL;
    }
d5315 1
a5315 1
	doop = ck_subr(newUNOP(OP_ENTERSUB, OPf_STACKED,
d5318 1
a5318 1
							  newGVOP(OP_GV, 0, gv))))));
d5351 1
a5351 1
S_is_list_assignment(pTHX_ register const OP *o)
a5621 1
			pm->op_pmflags |= PMf_ONCE;
d5683 1
a5683 1
    register COP *cop;
d5721 1
a5721 2
	if (PL_parser)
	    PL_parser->copline = NOLINE;
d5881 2
d5947 2
d6042 2
d6174 1
d6264 1
a6315 1
	    op_free(expr);		/* oops, it's a while (0) */
d6317 1
a6317 1
	    return NULL;		/* listop already freed by new_logop */
d6444 1
a6444 1
	 * treated as min/max values by 'pp_iterinit'.
d6480 3
a6482 1
#ifdef PL_OP_SLAB_ALLOC
d6490 2
a6491 3
#else
    loop = (LOOP*)PerlMemShared_realloc(loop, sizeof(LOOP));
#endif
d6505 1
a6505 1
become part of the constructed op tree.
d6514 1
a6514 1
    OP *o;
d6520 1
a6520 1
    if (type != OP_GOTO || label->op_type == OP_CONST) {
d6522 1
a6522 1
	if (label->op_type == OP_STUB && (label->op_flags & OPf_PARENS))
a6523 8
	else {
	    o = newPVOP(type,
                        label->op_type == OP_CONST
                            ? SvUTF8(((SVOP*)label)->op_sv)
                            : 0,
                        savesharedpv(label->op_type == OP_CONST
				? SvPV_nolen_const(((SVOP*)label)->op_sv)
				: ""));
a6524 5
#ifdef PERL_MAD
	op_getmad(label,o,'L');
#else
	op_free(label);
#endif
a6530 1
	o = newUNOP(type, OPf_STACKED, label);
d6532 26
a6557 3
    PL_hints |= HINT_BLOCK_SCOPE;
    return o;
}
d6733 1
a6733 1
be affected.
d6786 1
a6786 1
    const char * const cvp = CvPROTO(cv);
d6808 2
d6811 5
d6819 1
a6819 1
	if (SvPOK(cv))
d6878 2
a6879 1
 *	PADSV, ignore it if it has multiple references. Return the value.
d6944 48
d6993 1
a6993 3
OP *
#else
void
d6995 8
d7005 168
a7172 3
#if 0
    /* This would be the return value, but the return cannot be reached.  */
    OP* pegop = newOP(OP_NULL, 0);
d7174 62
d7237 3
a7239 1
    PERL_UNUSED_ARG(floor);
d7241 9
a7249 9
    if (o)
	SAVEFREEOP(o);
    if (proto)
	SAVEFREEOP(proto);
    if (attrs)
	SAVEFREEOP(attrs);
    if (block)
	SAVEFREEOP(block);
    Perl_croak(aTHX_ "\"my sub\" not yet implemented");
d7251 3
a7253 1
    NORETURN_FUNCTION_END;
d7255 94
d7366 1
a7366 1
    register CV *cv = NULL;
d7368 1
d7375 2
a7376 1
	= (block || attrs || (CvFLAGS(PL_compcv) & CVf_BUILTIN_ATTRS)
d7385 3
d7428 22
d7453 3
a7455 6
	    if (!SvPOK((const SV *)gv)
		&& !(SvIOK((const SV *)gv) && SvIVX((const SV *)gv) == -1))
	    {
		Perl_ck_warner_d(aTHX_ packWARN(WARN_PROTOTYPE), "Runaway prototype");
	    }
	    cv_ckproto_len_flags((const CV *)gv, NULL, ps, ps_len, ps_utf8);
d7492 3
a7494 15
	    if ((!block
#ifdef PERL_MAD
		 || block->op_type == OP_NULL
#endif
		 )) {
		if (CvFLAGS(PL_compcv)) {
		    /* might have had built-in attrs applied */
		    const bool pureperl = !CvISXSUB(cv) && CvROOT(cv);
		    if (CvLVALUE(PL_compcv) && ! CvLVALUE(cv) && pureperl
		     && ckWARN(WARN_MISC))
			Perl_warner(aTHX_ packWARN(WARN_MISC), "lvalue attribute ignored after the subroutine has been defined");
		    CvFLAGS(cv) |=
			(CvFLAGS(PL_compcv) & CVf_BUILTIN_ATTRS
			  & ~(CVf_LVALUE * pureperl));
		}
a7499 19
	    if (block
#ifdef PERL_MAD
		&& block->op_type != OP_NULL
#endif
		) {
		const line_t oldline = CopLINE(PL_curcop);
		if (PL_parser && PL_parser->copline != NOLINE)
			CopLINE_set(PL_curcop, PL_parser->copline);
		report_redefined_cv(cSVOPo->op_sv, cv, &const_sv);
		CopLINE_set(PL_curcop, oldline);
#ifdef PERL_MAD
		if (!PL_minus_c)	/* keep old one around for madskills */
#endif
		    {
			/* (PL_madskills unset in used file.) */
			SvREFCNT_dec(cv);
		    }
		cv = NULL;
	    }
a7502 1
	HV *stash;
d7506 1
a7519 8
	stash =
            (CvGV(cv) && GvSTASH(CvGV(cv)))
                ? GvSTASH(CvGV(cv))
                : CvSTASH(cv)
                    ? CvSTASH(cv)
                    : PL_curstash;
	if (HvENAME_HEK(stash))
            mro_method_changed_in(stash); /* sub Foo::Bar () { 123 } */
d7535 1
a7535 1
	    AV *const temp_av = CvPADLIST(cv);
d7537 3
d7541 1
a7541 1
	    assert(!CvWEAKOUTSIDE(cv));
d7552 4
a7579 7
	    if (PL_madskills) {
		if (strEQ(name, "import")) {
		    PL_formfeed = MUTABLE_SV(cv);
		    /* diag_listed_as: SKIPME */
		    Perl_warner(aTHX_ packWARN(WARN_VOID), "0x%"UVxf"\n", PTR2UV(cv));
		}
	    }
d7583 1
a7583 1
		mro_method_changed_in(GvSTASH(gv));
a7596 19
    if (PL_parser && PL_parser->error_count) {
	op_free(block);
	block = NULL;
	if (name) {
	    const char *s = strrchr(name, ':');
	    s = s ? s+1 : name;
	    if (strEQ(s, "BEGIN")) {
		const char not_safe[] =
		    "BEGIN not safe after errors--compilation aborted";
		if (PL_in_eval & EVAL_KEEPERR)
		    Perl_croak(aTHX_ not_safe);
		else {
		    /* force display of errors found but not reported */
		    sv_catpv(ERRSV, not_safe);
		    Perl_croak(aTHX_ "%"SVf, SVfARG(ERRSV));
		}
	    }
	}
    }
a7616 1
    else block->op_attached = 1;
d7623 7
d7649 3
a7651 1
	apply_attrs(stash, MUTABLE_SV(cv), attrs, FALSE);
d7681 1
a7681 1
	    process_special_blocks(name, gv, cv);
d7688 4
d7696 2
a7697 1
S_process_special_blocks(pTHX_ const char *const fullname, GV *const gv,
d7708 1
d7787 3
a7829 1
	SAVECOPSTASH(PL_curcop);
a7830 1
	CopSTASH_set(PL_curcop,stash);
d7833 3
d7842 1
a7842 1
    CvXSUBANY(cv).any_ptr = sv;
a7844 4
#ifdef USE_ITHREADS
    if (stash)
	CopSTASH_free(PL_curcop);
#endif
d7872 5
a7876 7
        GV * const gv = name
			 ? gv_fetchpvn(
				name,len,GV_ADDMULTI|flags,SVt_PVCV
			   )
			 : gv_fetchpv(
                            (PL_curstash ? "__ANON__" : "__ANON__::__ANON__"),
                            GV_ADDMULTI | flags, SVt_PVCV);
a7891 3
                    const line_t oldline = CopLINE(PL_curcop);
                    if (PL_parser && PL_parser->copline != NOLINE)
                        CopLINE_set(PL_curcop, PL_parser->copline);
a7895 1
                    CopLINE_set(PL_curcop, oldline);
d7897 1
a7897 1
                SvREFCNT_dec(cv);
d7910 1
a7910 1
                    mro_method_changed_in(GvSTASH(gv)); /* newXS */
d7924 1
a7924 1
            process_special_blocks(name, gv, cv);
d7935 17
d7965 3
a7967 1
    return newXS_flags(name, subaddr, filename, NULL, 0);
d7978 1
a7978 1
    register CV *cv;
d7983 8
a7990 1
    GV * const gv = o
d8013 1
a8013 1
    GvFORM(gv) = cv;
d8026 3
d8172 5
d8309 2
d8520 1
a8520 1
Perl_ck_rvconst(pTHX_ register OP *o)
d8643 2
a8644 1
	if (kidtype == OP_CONST && (kid->op_private & OPpCONST_BARE)) {
d8687 1
a8687 1
    register I32 oa = PL_opargs[type] >> OASHIFT;
d8700 1
a8700 1
        register OP *kid = cLISTOPo->op_first;
a8815 1
		    LINKLIST(kid);
d8946 4
d9007 3
a9009 9
	gv = gv_fetchpvs("CORE::GLOBAL::glob", 0, SVt_PVCV);
    }

#if !defined(PERL_EXTERNAL_GLOB)
    if (!(gv && GvCVu(gv) && GvIMPORTED_CV(gv))) {
	ENTER;
	Perl_load_module(aTHX_ PERL_LOADMOD_NOIMPORT,
		newSVpvs("File::Glob"), NULL, NULL, NULL);
	LEAVE;
a9010 1
#endif /* !PERL_EXTERNAL_GLOB */
d9023 1
a9023 1
	 *                              \ null - const(wildcard) - const(ix)
a9026 2
	op_append_elem(OP_GLOB, o,
		    newSVOP(OP_CONST, 0, newSViv(PL_glob_index++)));
d9032 1
a9032 1
	o = newUNOP(OP_NULL, 0, ck_subr(o));
d9037 10
a9046 1
    gv = newGVgen("main");
a9047 3
#ifndef PERL_EXTERNAL_GLOB
    sv_setiv(GvSVn(gv),PL_glob_index++);
#endif
d9049 1
d9058 1
a9058 1
    LOGOP *gwop = NULL;
a9068 2
	OP* k;
	o = ck_sort(o);
a9071 5
	for (k = kid; k; k = k->op_next) {
	    kid = k;
	}
	NewOp(1101, gwop, 1, LOGOP);
	kid->op_next = (OP*)gwop;
d9087 1
a9087 2
    if (!gwop)
	NewOp(1101, gwop, 1, LOGOP);
d9090 1
a9090 1
    gwop->op_first = listkids(o);
a9104 2
    if (!kid || !kid->op_sibling)
	return too_few_arguments_pv(o,OP_DESC(o), 0);
d9121 1
a9121 1
	    const bool save_taint = PL_tainted;
d9123 4
a9126 1
	    PL_tainted = save_taint;
d9207 1
a9207 1
    register OP *kid;
d9221 2
a9222 1
	if (kid->op_type == OP_CONST && kid->op_private & OPpCONST_BARE) {
d9369 1
a9369 1
	    if (!SvREADONLY(sv) || !SvFAKE(sv)) {
a9493 5
		if (SvFAKE(sv)) {
		    sv_force_normal_flags(sv, 0);
		    assert(!SvREADONLY(sv));
		    was_readonly = 0;
		} else {
a9494 1
		}
d9496 1
d9535 1
a9535 1
	newop = ck_subr(newUNOP(OP_ENTERSUB, OPf_STACKED,
d9539 1
a9539 1
								   gv))))));
d9625 1
d9629 1
a9629 3
    if (o->op_type == OP_SORT && (PL_hints & HINT_LOCALIZE_HH) != 0) {
	HV * const hinthv = GvHV(PL_hintgv);
	if (hinthv) {
a9637 1
	}
d9640 1
a9640 1
    if (o->op_type == OP_SORT && o->op_flags & OPf_STACKED)
a9643 1
	OP *k = NULL;
d9648 1
a9648 6
	    if (kid->op_type == OP_SCOPE) {
		k = kid->op_next;
		kid->op_next = 0;
	    }
	    else if (kid->op_type == OP_LEAVE) {
		if (o->op_type == OP_SORT) {
d9650 2
a9651 18
		    kid->op_next = kid;

		    for (k = kLISTOP->op_first->op_next; k; k = k->op_next) {
			if (k->op_next == kid)
			    k->op_next = 0;
			/* don't descend into loops */
			else if (k->op_type == OP_ENTERLOOP
				 || k->op_type == OP_ENTERITER)
			{
			    k = cLOOPx(k)->op_lastop;
			}
		    }
		}
		else
		    kid->op_next = 0;		/* just disconnect the leave */
		k = kLISTOP->op_first;
	    }
	    CALL_PEEP(k);
d9653 3
a9655 8
	    kid = firstkid;
	    if (o->op_type == OP_SORT) {
		/* provide scalar context for comparison function/block */
		kid = scalar(kid);
		kid->op_next = kid;
	    }
	    else
		kid->op_next = k;
d9663 1
a9663 2
    if (o->op_type == OP_SORT)
	list(firstkid);
d9672 1
a9672 1
    register OP *kid = cLISTOPo->op_first->op_sibling;	/* get past pushmark */
d9677 1
d9686 2
a9687 1
    if (kid->op_type != OP_SCOPE)
d9694 1
d9700 28
a9727 1
    if (kBINOP->op_first->op_type != OP_RV2SV)
d9729 1
d9746 1
a9746 2
    if (kBINOP->op_last->op_type != OP_RV2SV)
	return;
d9779 1
a9779 1
    register OP *kid;
d9801 1
a9801 1
	kid = pmruntime( newPMOP(OP_MATCH, OPf_SPECIAL), kid, 0);
d9896 22
d9951 4
d10496 1
d10541 15
d10565 1
a10565 1
    SvREADONLY_on(cSVOPo->op_sv);
a10569 17
Perl_ck_chdir(pTHX_ OP *o)
{
    PERL_ARGS_ASSERT_CK_CHDIR;
    if (o->op_flags & OPf_KIDS) {
	SVOP * const kid = (SVOP*)cUNOPo->op_first;

	if (kid && kid->op_type == OP_CONST &&
	    (kid->op_private & OPpCONST_BARE))
	{
	    o->op_flags |= OPf_SPECIAL;
	    kid->op_private &= ~OPpCONST_STRICT;
	}
    }
    return ck_fun(o);
}

OP *
d10580 2
a10581 1
	    (kid->op_private & OPpCONST_BARE))
a10711 28
/* caller is supposed to assign the return to the 
   container of the rep_op var */
STATIC OP *
S_opt_scalarhv(pTHX_ OP *rep_op) {
    dVAR;
    UNOP *unop;

    PERL_ARGS_ASSERT_OPT_SCALARHV;

    NewOp(1101, unop, 1, UNOP);
    unop->op_type = (OPCODE)OP_BOOLKEYS;
    unop->op_ppaddr = PL_ppaddr[OP_BOOLKEYS];
    unop->op_flags = (U8)(OPf_WANT_SCALAR | OPf_KIDS );
    unop->op_private = (U8)(1 | ((OPf_WANT_SCALAR | OPf_KIDS) >> 8));
    unop->op_first = rep_op;
    unop->op_next = rep_op->op_next;
    rep_op->op_next = (OP*)unop;
    rep_op->op_flags|=(OPf_REF | OPf_MOD);
    unop->op_sibling = rep_op->op_sibling;
    rep_op->op_sibling = NULL;
    /* unop->op_targ = pad_alloc(OP_BOOLKEYS, SVs_PADTMP); */
    if (rep_op->op_type == OP_PADHV) { 
        rep_op->op_flags &= ~OPf_WANT_SCALAR;
        rep_op->op_flags |= OPf_WANT_LIST;
    }
    return (OP*)unop;
}                        

d10798 1
d10804 2
a10805 1
    defer_queue[(defer_base + ++defer_ix) % MAX_DEFERRED] = o;
d10812 1
a10812 1
Perl_rpeep(pTHX_ register OP *o)
d10815 2
a10816 1
    register OP* oldop = NULL;
d10867 1
a10867 2
		    firstcop->cop_stashpv = secondcop->cop_stashpv;
		    firstcop->cop_stashlen = secondcop->cop_stashlen;
d10879 1
a10879 1
		    secondcop->cop_stashpv = NULL;
d10941 241
d11245 9
d11255 2
a11256 3
            fop = cUNOP->op_first;
            sop = NULL;
            goto stitch_keys;
a11270 1
          stitch_keys:	    
d11272 3
a11274 4
            if ((fop->op_type == OP_PADHV || fop->op_type == OP_RV2HV)
                || ( sop && 
                     (sop->op_type == OP_PADHV || sop->op_type == OP_RV2HV)
                    )
d11296 10
a11305 6
                if ((lop->op_flags & OPf_WANT) == OPf_WANT_VOID) {
                    if (fop->op_type == OP_PADHV || fop->op_type == OP_RV2HV) 
                        cLOGOP->op_first = opt_scalarhv(fop);
                    if (sop && (sop->op_type == OP_PADHV || sop->op_type == OP_RV2HV)) 
                        cLOGOP->op_first->op_sibling = opt_scalarhv(sop);
                }                                        
d11310 6
d11317 1
a11317 1
	
a11322 1
	case OP_COND_EXPR:
d11354 10
d11365 1
a11365 1
	    OP *oright = cUNOPo->op_first;
d11538 1
d11545 1
a11545 1
Perl_peep(pTHX_ register OP *o)
d11641 1
a11641 1
by C<keyword()>.  It must be negative and unequal to -KEY_CORE.
d11658 1
a11658 1
    assert (code < 0 && code != -KEY_CORE);
d11664 1
a11664 1
    switch (-code) {
d11666 8
a11673 4
    case KEY_cmp   : case KEY_exec: case KEY_eq   :
    case KEY_ge    : case KEY_gt  : case KEY_le   :
    case KEY_lt    : case KEY_ne  : case KEY_or   :
    case KEY_select: case KEY_system: case KEY_x  : case KEY_xor:
d11675 1
d11683 1
d11706 1
a11706 1
    assert(0); return NULL;    /* Should not happen... */
d11730 1
a11730 1
	    if (i == OP_LOCK) str[n++] = '&';
d11798 2
d11803 1
a11803 1
	    o = convert(opnum,0,argop);
a11805 2
	    if (scalar_mod_type(NULL, opnum))
		argop->op_private |= OPpCOREARGS_SCALARMOD;
d11948 1
a11948 1
 * indent-tabs-mode: t
d11951 1
a11951 1
 * ex: set ts=8 sts=4 sw=4 noet:
@


1.15
log
@merge in perl 5.12.2 plus local changes
@
text
@d105 1
d107 3
a109 2
#define CALL_PEEP(o) CALL_FPTR(PL_peepp)(aTHX_ o)
#define CALL_OPFREEHOOK(o) if (PL_opfreehook) CALL_FPTR(PL_opfreehook)(aTHX_ o)
d310 1
a310 1
     : CALL_FPTR(PL_check[type])(aTHX_ (OP*)o))
d314 7
a320 1
STATIC const char*
d328 1
a328 1
    return SvPV_nolen_const(tmpsv);
d342 18
a359 1
S_too_few_arguments(pTHX_ OP *o, const char *name)
d361 1
a361 1
    PERL_ARGS_ASSERT_TOO_FEW_ARGUMENTS;
d363 1
a363 1
    yyerror(Perl_form(aTHX_ "Not enough arguments for %s", name));
d368 1
a368 1
S_too_many_arguments(pTHX_ OP *o, const char *name)
d370 1
a370 1
    PERL_ARGS_ASSERT_TOO_MANY_ARGUMENTS;
d372 2
a373 1
    yyerror(Perl_form(aTHX_ "Too many arguments for %s", name));
d378 1
a378 1
S_bad_type(pTHX_ I32 n, const char *t, const char *name, const OP *kid)
d380 5
a384 1
    PERL_ARGS_ASSERT_BAD_TYPE;
d386 7
a392 2
    yyerror(Perl_form(aTHX_ "Type of arg %d to %s must be %s (not %s)",
		 (int)n, name, t, OP_DESC(kid)));
d396 1
a396 1
S_no_bareword_allowed(pTHX_ const OP *o)
d405 1
d419 1
a419 1
    if (flags)
d431 1
a431 1
	  (USE_UTF8_IN_NAMES && UTF8_IS_START(name[1])) ||
d435 2
a436 1
	if (!isPRINT(name[1]) || strchr("\t\n\r\f", name[1])) {
d441 2
a442 2
	    yyerror(Perl_form(aTHX_ "Can't use global %.*s in \"%s\"", (int) len, name,
			      PL_parser->in_my == KEY_state ? "state" : "my"));
d448 4
a451 3
    off = pad_add_name(name, len,
		       is_our ? padadd_OUR :
		       PL_parser->in_my == KEY_state ? padadd_STATE : 0,
d581 2
a582 12
    /* if (o->op_madprop && o->op_madprop->mad_next)
       abort(); */
    /* FIXME for MAD - if I uncomment these two lines t/op/pack.t fails with
       "modification of a read only value" for a reason I can't fathom why.
       It's the "" stringification of $_, where $_ was set to '' in a foreach
       loop, but it defies simplification into a small test case.
       However, commenting them out has caused ext/List/Util/t/weak.t to fail
       the last test.  */
    /*
      mad_free(o->op_madprop);
      o->op_madprop = 0;
    */
d599 1
a599 1
	    || (PL_check[o->op_type] != MEMBER_TO_FPTR(Perl_ck_ftst)))
d605 1
a605 2
	if (! (o->op_type == OP_AELEMFAST && o->op_flags & OPf_SPECIAL)) {
	    /* not an OP_PADAV replacement */
d674 1
d747 1
a747 1
    Perl_refcounted_he_free(aTHX_ cop->cop_hints_hash);
d761 1
a761 1
    if (pmstash && !SvIS_FREED(pmstash)) {
d848 32
a879 1
#define LINKLIST(o) ((o)->op_next ? (o)->op_next : linklist((OP*)o))
d881 5
a885 2
static OP *
S_linklist(pTHX_ OP *o)
d889 1
a889 1
    PERL_ARGS_ASSERT_LINKLIST;
d934 2
a935 1
    if (o->op_type == OP_SASSIGN && cBINOPo->op_first->op_type == OP_CONST) {
d990 5
a994 2
	while ((kid = kid->op_sibling)) {
	    if (kid->op_sibling)
d998 1
d1005 2
a1006 8
	for (kid = cLISTOPo->op_first; kid; kid = kid->op_sibling) {
	    if (kid->op_sibling)
		scalarvoid(kid);
	    else
		scalar(kid);
	}
	PL_curcop = &PL_compiling;
	break;
d1020 1
d1051 1
a1051 1
	 || o->op_type == OP_RETURN || o->op_type == OP_REQUIRE)
d1099 1
d1147 1
d1168 1
a1168 1
           kid->op_type != OP_TRANS) {
d1174 9
a1197 9
		if (SvOK(sv)) {
		    SV* msv = sv_2mortal(Perl_newSVpvf(aTHX_
				"a constant (%"SVf")", sv));
		    useless = SvPV_nolen(msv);
		}
		else
		    useless = "a constant (undef)";
		if (o->op_private & OPpCONST_ARYBASE)
		    useless = NULL;
d1219 10
d1230 7
d1262 46
d1361 3
a1363 1
	Perl_ck_warner(aTHX_ packWARN(WARN_VOID), "Useless use of %s in void context", useless);
d1429 5
a1433 2
	while ((kid = kid->op_sibling)) {
	    if (kid->op_sibling)
d1437 1
d1443 2
a1444 8
	for (kid = cLISTOPo->op_first; kid; kid = kid->op_sibling) {
	    if (kid->op_sibling)
		scalarvoid(kid);
	    else
		list(kid);
	}
	PL_curcop = &PL_compiling;
	break;
d1482 1
a1482 1
	    mod(kid, type);
d1487 267
a1753 10
/* Propagate lvalue ("modifiable") context to an op and its children.
 * 'type' represents the context type, roughly based on the type of op that
 * would do the modifying, although local() is represented by OP_NULL.
 * It's responsible for detecting things that can't be modified,  flag
 * things that need to behave specially in an lvalue context (e.g., "$$x = 5"
 * might have to vivify a reference in $x), and so on.
 *
 * For example, "$a+1 = 2" would cause mod() to be called with o being
 * OP_ADD and type being OP_SASSIGN, and would output an error.
 */
d1756 1
a1756 1
Perl_mod(pTHX_ OP *o, I32 type)
d1772 4
a1780 18
    case OP_CONST:
	if (!(o->op_private & OPpCONST_ARYBASE))
	    goto nomod;
	localize = 0;
	if (PL_eval_start && PL_eval_start->op_type == OP_CONST) {
	    CopARYBASE_set(&PL_compiling,
			   (I32)SvIV(cSVOPx(PL_eval_start)->op_sv));
	    PL_eval_start = 0;
	}
	else if (!type) {
	    SAVECOPARYBASE(&PL_compiling);
	    CopARYBASE_set(&PL_compiling, 0);
	}
	else if (type == OP_REFGEN)
	    goto nomod;
	else
	    Perl_croak(aTHX_ "That use of $[ is unsupported");
	break;
d1786 1
a1786 1
	if ((type == OP_UNDEF || type == OP_REFGEN) &&
d1789 2
a1790 3
	    /* The default is to set op_private to the number of children,
	       which for a UNOP such as RV2CV is always 1. And w're using
	       the bit for a flag in RV2CV, so we need it clear.  */
a1796 2
	else if (o->op_private & OPpENTERSUB_NOMOD)
	    return o;
d1798 2
a1799 1
	    o->op_private |= OPpLVAL_INTRO;
d1802 1
a1802 1
		/* Backward compatibility mode: */
a1808 1
		OP *okid;
a1820 23
		    /* Indirect call */
		    if (kid->op_type == OP_METHOD_NAMED
			|| kid->op_type == OP_METHOD)
		    {
			UNOP *newop;

			NewOp(1101, newop, 1, UNOP);
			newop->op_type = OP_RV2CV;
			newop->op_ppaddr = PL_ppaddr[OP_RV2CV];
			newop->op_first = NULL;
                        newop->op_next = (OP*)newop;
			kid->op_sibling = (OP*)newop;
			newop->op_private |= OPpLVAL_INTRO;
			newop->op_private &= ~1;
			break;
		    }

		    if (kid->op_type != OP_RV2CV)
			Perl_croak(aTHX_
				   "panic: unexpected lvalue entersub "
				   "entry via type/targ %ld:%"UVuf,
				   (long)kid->op_type, (UV)kid->op_targ);
		    kid->op_private |= OPpLVAL_INTRO;
a1823 1
		okid = kid;
a1832 13
		    /* Restore RV2CV to check lvalueness */
		  restore_2cv:
		    if (kid->op_next && kid->op_next != kid) { /* Happens? */
			okid->op_next = kid->op_next;
			kid->op_next = okid;
		    }
		    else
			okid->op_next = NULL;
		    okid->op_type = OP_RV2CV;
		    okid->op_targ = 0;
		    okid->op_ppaddr = PL_ppaddr[OP_RV2CV];
		    okid->op_private |= OPpLVAL_INTRO;
		    okid->op_private &= ~1;
d1838 1
a1838 1
		    goto restore_2cv;
d1846 1
d1848 2
a1849 1
	if (type == OP_GREPSTART || type == OP_ENTERSUB || type == OP_REFGEN)
d1888 1
a1888 1
	    mod(kid, type);
d1934 1
d1952 2
a1953 2
	    Perl_croak(aTHX_ "Can't localize lexical variable %s",
		 PAD_COMPNAME_PV(o->op_targ));
d1961 2
a1962 1
	if (type != OP_SASSIGN)
d1971 1
a1973 1
      lvalue_func:
d1978 1
a1978 1
	    mod(cBINOPo->op_first->op_sibling, type);
d1999 1
a1999 1
	    mod(cLISTOPo->op_last, type);
d2009 1
a2009 1
	    mod(cBINOPo->op_first, type);
d2016 4
a2019 1
	    mod(kid, type);
d2025 1
a2025 1
	break; /* mod()ing was handled by ck_return() */
d2032 1
a2032 1
        PL_check[o->op_type] == MEMBER_TO_FPTR(Perl_ck_ftst))
d2063 1
a2063 1
    PERL_ARGS_ASSERT_SCALAR_MOD_TYPE;
d2098 1
d2160 1
a2160 1
	if ((type == OP_EXISTS || type == OP_DEFINED || type == OP_LOCK) &&
d2169 7
d2270 1
a2270 1
		rop = append_elem(OP_LIST, rop,
d2306 1
a2306 1
			 prepend_elem(OP_LIST,
d2308 1
a2308 1
				      prepend_elem(OP_LIST,
d2343 1
a2343 1
    arg = prepend_elem(OP_LIST,
d2345 1
a2345 1
		       prepend_elem(OP_LIST,
d2347 1
a2347 1
					    mod(arg, OP_REFGEN)),
d2353 2
a2354 2
		   append_elem(OP_LIST,
			       prepend_elem(OP_LIST, pack, list(arg)),
a2355 1
    imop->op_private |= OPpENTERSUB_NOMOD;
d2358 1
a2358 1
    *imopsp = append_elem(OP_LIST, *imopsp, imop);
d2395 1
a2395 1
            attrs = append_elem(OP_LIST, attrs,
d2403 1
a2403 1
                     NULL, prepend_elem(OP_LIST,
d2405 1
a2405 1
				  prepend_elem(OP_LIST,
d2416 1
d2433 1
d2488 1
a2488 1
    if (PL_parser->in_my == KEY_state)
d2518 1
a2518 1
	    o = scalar(append_list(OP_LIST, (LISTOP*)rops, (LISTOP*)o));
d2521 13
a2533 2
	else
	    o = append_list(OP_LIST, (LISTOP*)o, (LISTOP*)rops);
d2563 4
a2566 1
	  = PL_op_desc[(rtype == OP_SUBST || rtype == OP_TRANS)
d2568 17
a2584 1
      const char * const sample = ((ltype == OP_RV2AV || ltype == OP_PADAV)
d2586 1
a2586 1
      Perl_warner(aTHX_ packWARN(WARN_MISC),
d2589 1
d2599 11
a2609 3
    ismatchop = rtype == OP_MATCH ||
		rtype == OP_SUBST ||
		rtype == OP_TRANS;
d2618 1
a2618 1
	if (rtype != OP_MATCH &&
d2620 4
a2623 2
               right->op_private & OPpTRANS_IDENTICAL))
	    newleft = mod(left, rtype);
d2626 1
a2626 1
	if (right->op_type == OP_TRANS)
d2629 1
a2629 1
	    o = prepend_elem(rtype, scalar(newleft), right);
d2647 14
d2662 1
a2662 1
Perl_scope(pTHX_ OP *o)
d2667 1
a2667 1
	    o = prepend_elem(OP_LINESEQ, newOP(OP_ENTER, 0), o);
d2691 1
a2691 1
	
d2697 1
d2703 3
d2714 4
a2717 1
    OP* const retval = scalarseq(seq);
d2723 3
d2729 19
d2752 1
a2752 1
    const PADOFFSET offset = Perl_pad_findmy(aTHX_ STR_WITH_LEN("$_"), 0);
d2771 2
d2778 15
a2792 1
	PL_eval_start = linklist(PL_eval_root);
d2796 3
d2800 3
d2811 1
a2811 1
	PL_main_root = scope(sawparens(scalarvoid(o)));
d2818 1
d2891 1
a2891 1
	o = mod(o, OP_NULL);		/* a bit kludgey */
d2905 35
a2939 1
	o = convert(OP_JOIN, 0, prepend_elem(OP_LIST, o2, o));
d2941 5
a2966 14
    if (PL_opargs[type] & OA_RETSCALAR)
	scalar(o);
    if (PL_opargs[type] & OA_TARGET && !o->op_targ)
	o->op_targ = pad_alloc(type, SVs_PADTMP);

    /* integerize op, unless it happens to be C<-foo>.
     * XXX should pp_i_negate() do magic string negation instead? */
    if ((PL_opargs[type] & OA_OTHERINT) && (PL_hints & HINT_INTEGER)
	&& !(type == OP_NEGATE && cUNOPo->op_first->op_type == OP_CONST
	     && (cUNOPo->op_first->op_private & OPpCONST_BARE)))
    {
	o->op_ppaddr = PL_ppaddr[type = ++(o->op_type)];
    }

a2970 4
    case OP_NEGATE:
	/* XXX might want a ck_negate() for this */
	cUNOPo->op_first->op_private &= ~OPpCONST_STRICT;
	break;
d2980 1
d2982 1
a2982 1
	if (PL_hints & HINT_LOCALE)
d3025 7
a3031 1
	if (o->op_targ && sv == PAD_SV(o->op_targ))	/* grab pad temp? */
d3033 2
d3095 1
a3095 1
    pp_pushmark();
d3100 1
a3100 1
    pp_anonlist();
d3107 1
a3107 1
    o->op_opt = 0;		/* needs to be revisited in peep() */
d3115 1
a3115 1
    linklist(o);
d3123 1
d3131 7
d3147 1
a3147 1
    return fold_constants(o);
d3150 4
d3156 13
d3170 1
a3170 1
Perl_append_elem(pTHX_ I32 type, OP *first, OP *last)
d3194 13
d3208 1
a3208 1
Perl_append_list(pTHX_ I32 type, LISTOP *first, LISTOP *last)
d3211 1
a3211 1
	return (OP*)last;
d3214 1
a3214 1
	return (OP*)first;
d3217 1
a3217 1
	return prepend_elem(type, (OP*)first, (OP*)last);
d3220 1
a3220 1
	return append_elem(type, (OP*)first, (OP*)last);
d3222 2
a3223 2
    first->op_last->op_sibling = last->op_first;
    first->op_last = last->op_last;
d3227 2
a3228 2
    if (last->op_first && first->op_madprop) {
	MADPROP *mp = last->op_first->op_madprop;
d3235 1
a3235 1
	    last->op_first->op_madprop = first->op_madprop;
d3242 1
a3242 1
    S_op_destroy(aTHX_ (OP*)last);
d3244 1
a3244 1
    return (OP*)first;
d3247 13
d3261 1
a3261 1
Perl_prepend_elem(pTHX_ I32 type, OP *first, OP *last)
d3497 1
a3497 2
    MADPROP *mp;
    Newxz(mp, 1, MADPROP);
d3534 1
a3534 1
    Safefree(mp);
d3539 11
d3565 12
d3613 11
d3630 5
d3657 14
d3677 5
d3705 1
a3705 1
    return fold_constants((OP *) unop);
d3708 14
d3755 1
a3755 1
    return fold_constants((OP *)binop);
d3895 1
a3895 2
	    t = uvuni_to_utf8_flags(tmpbuf, 0x7fffffff,
				    UNICODE_ALLOW_SUPER);
a3993 3
	PerlMemShared_free(cPVOPo->op_pv);
	cPVOPo->op_pv = NULL;

d4027 5
a4031 1
    tbl = (short*)cPVOPo->op_pv;
a4032 1
	Zero(tbl, 256, short);
d4119 10
d4145 21
a4165 2
    if (PL_hints & HINT_LOCALE)
	pmop->op_pmflags |= PMf_LOCALE;
d4218 4
a4221 1
    if (o->op_type == OP_SUBST || o->op_type == OP_TRANS) {
d4243 1
a4243 1
    if (o->op_type == OP_TRANS) {
d4256 1
a4256 1
	U32 pm_flags = pm->op_pmflags & PMf_COMPILETIME;
d4300 1
a4300 1
	PL_cv_has_eval = 1;
d4313 1
a4313 1
	prepend_elem(o->op_type, scalar((OP*)rcop), o);
d4367 1
a4367 1
	    prepend_elem(o->op_type, scalar(repl), o);
d4395 11
d4432 15
d4475 14
a4488 1
#endif
d4505 12
d4521 1
d4524 2
d4527 1
d4536 1
d4559 1
a4559 1
    save_hptr(&PL_curstash);
d4562 1
a4562 1
    PL_curstash = gv_stashsv(sv, GV_ADD);
d4610 1
d4643 2
a4644 2
			    append_elem(OP_LIST,
					prepend_elem(OP_LIST, pack, list(version)),
d4657 3
a4659 1
	if (!aver)
d4675 2
a4676 2
		       append_elem(OP_LIST,
				   prepend_elem(OP_LIST, pack, list(arg)),
d4685 2
a4686 2
	append_elem(OP_LINESEQ,
	    append_elem(OP_LINESEQ,
d4691 27
d4739 2
d4761 1
a4761 1
(or 0 for no flags). ver, if specified, provides version semantics
d4770 2
d4825 1
a4825 1
	    imop = append_elem(OP_LIST, imop, newSVOP(OP_CONST, 0, sv));
d4838 1
a4838 1
    lex_start(NULL, NULL, FALSE);
d4863 1
a4863 1
			       append_elem(OP_LIST, term,
d4873 16
d4941 93
d5043 1
a5043 1
		mod(scalar(left), optype),
d5048 1
a5048 1
		mod(scalar(left), optype), scalar(right));
d5059 1
a5059 11
	/* Grandfathering $[ assignment here.  Bletch.*/
	/* Only simple assignments like C<< ($[) = 1 >> are allowed */
	PL_eval_start = (left->op_type == OP_CONST) ? right : NULL;
	left = mod(left, OP_AASSIGN);
	if (PL_eval_start)
	    PL_eval_start = 0;
	else if (left->op_type == OP_CONST) {
	    /* FIXME for MAD */
	    /* Result of assignment is always 1 (or we'd be dead already) */
	    return newSVOP(OP_CONST, 0, newSViv(1));
	}
a5137 1
	    OP *lastop = o;
d5139 4
a5142 18
	    for (curop = LINKLIST(o); curop != o; curop = LINKLIST(curop)) {
		if (PL_opargs[curop->op_type] & OA_DANGEROUS) {
		    if (curop->op_type == OP_GV) {
			GV *gv = cGVOPx_gv(curop);
			if (gv == PL_defgv
			    || (int)GvASSIGN_GENERATION(gv) == PL_generation)
			    break;
			GvASSIGN_GENERATION_set(gv, PL_generation);
		    }
		    else if (curop->op_type == OP_PADSV ||
			     curop->op_type == OP_PADAV ||
			     curop->op_type == OP_PADHV ||
			     curop->op_type == OP_PADANY)
		    {
			if (PAD_COMPNAME_GEN(curop->op_targ)
						    == (STRLEN)PL_generation)
			    break;
			PAD_COMPNAME_GEN_set(curop->op_targ, PL_generation);
d5144 14
a5157 53
		    }
		    else if (curop->op_type == OP_RV2CV)
			break;
		    else if (curop->op_type == OP_RV2SV ||
			     curop->op_type == OP_RV2AV ||
			     curop->op_type == OP_RV2HV ||
			     curop->op_type == OP_RV2GV) {
			if (lastop->op_type != OP_GV)	/* funny deref? */
			    break;
		    }
		    else if (curop->op_type == OP_PUSHRE) {
#ifdef USE_ITHREADS
			if (((PMOP*)curop)->op_pmreplrootu.op_pmtargetoff) {
			    GV *const gv = MUTABLE_GV(PAD_SVl(((PMOP*)curop)->op_pmreplrootu.op_pmtargetoff));
			    if (gv == PL_defgv
				|| (int)GvASSIGN_GENERATION(gv) == PL_generation)
				break;
			    GvASSIGN_GENERATION_set(gv, PL_generation);
			}
#else
			GV *const gv
			    = ((PMOP*)curop)->op_pmreplrootu.op_pmtargetgv;
			if (gv) {
			    if (gv == PL_defgv
				|| (int)GvASSIGN_GENERATION(gv) == PL_generation)
				break;
			    GvASSIGN_GENERATION_set(gv, PL_generation);
			}
#endif
		    }
		    else
			break;
		}
		lastop = curop;
	    }
	    if (curop != o)
		o->op_private |= OPpASSIGN_COMMON;
	}

	if (right && right->op_type == OP_SPLIT && !PL_madskills) {
	    OP* tmpop = ((LISTOP*)right)->op_first;
	    if (tmpop && (tmpop->op_type == OP_PUSHRE)) {
		PMOP * const pm = (PMOP*)tmpop;
		if (left->op_type == OP_RV2AV &&
		    !(left->op_private & OPpLVAL_INTRO) &&
		    !(o->op_private & OPpASSIGN_COMMON) )
		{
		    tmpop = ((UNOP*)left)->op_first;
		    if (tmpop->op_type == OP_GV
#ifdef USE_ITHREADS
			&& !pm->op_pmreplrootu.op_pmtargetoff
#else
			&& !pm->op_pmreplrootu.op_pmtargetgv
d5197 2
a5198 1
	return newBINOP(OP_NULL, flags, mod(scalar(left), OP_SASSIGN), scalar(right));
a5200 1
	PL_eval_start = right;	/* Grandfathering $[ assignment here.  Bletch.*/
d5202 1
a5202 11
	    scalar(right), mod(scalar(left), OP_SASSIGN) );
	if (PL_eval_start)
	    PL_eval_start = 0;
	else {
	    if (!PL_madskills) { /* assignment to $[ is ignored when making a mad dump */
		deprecate("assignment to $[");
		op_free(o);
		o = newSVOP(OP_CONST, 0, newSViv(CopARYBASE_get(&PL_compiling)));
		o->op_private |= OPpCONST_ARYBASE;
	    }
	}
d5207 18
d5230 1
d5233 2
a5252 3
    /* CopARYBASE is now "virtual", in that it's stored as a flag bit in
       CopHINTS and a possible value in cop_hints_hash, so no need to copy it.
    */
d5254 1
a5254 6
    cop->cop_hints_hash = PL_curcop->cop_hints_hash;
    if (cop->cop_hints_hash) {
	HINTS_REFCNT_LOCK;
	cop->cop_hints_hash->refcounted_he_refcnt++;
	HINTS_REFCNT_UNLOCK;
    }
d5256 2
a5257 3
	cop->cop_hints_hash
	    = Perl_store_cop_label(aTHX_ cop->cop_hints_hash, label);
						     
d5293 1
a5293 1
    return prepend_elem(OP_LINESEQ, (OP*)cop, o);
d5296 13
d5424 6
d5484 2
a5485 1
		  || k1->op_type == OP_EACH)
d5532 14
d5583 4
d5615 14
d5657 1
a5657 1
    linklist(flop);
d5671 6
d5679 1
a5679 1
	linklist(o);		/* blow off optimizer unless constant */
d5684 16
d5735 2
a5736 1
		      || k1->op_type == OP_EACH))
d5743 1
a5743 1
    /* if block is null, the next append_elem() would put UNSTACK, a scalar
d5747 1
a5747 1
    listop = append_elem(OP_LINESEQ, block, newOP(OP_UNSTACK, 0));
d5760 1
a5760 1
    o = scope(o);
d5765 24
d5790 2
a5791 2
Perl_newWHILEOP(pTHX_ I32 flags, I32 debuggable, LOOP *loop, I32
whileline, OP *expr, OP *block, OP *cont, I32 has_my)
d5824 2
a5825 1
		      || k1->op_type == OP_EACH))
d5835 1
a5835 1
	block = scope(block);
d5845 1
a5845 1
	cont = append_elem(OP_LINESEQ, cont, unstack);
d5849 1
a5849 1
    listop = append_list(OP_LINESEQ, (LISTOP*)block, (LISTOP*)cont);
a5853 1
	PL_parser->copline = (line_t)whileline;
d5892 23
d5916 1
a5916 1
Perl_newFOROP(pTHX_ I32 flags, char *label, line_t forline, OP *sv, OP *expr, OP *block, OP *cont)
d5967 1
a5967 1
        const PADOFFSET offset = Perl_pad_findmy(aTHX_ STR_WITH_LEN("$_"), 0);
d5977 1
a5977 1
	expr = mod(force_list(scalar(ref(expr, OP_ITER))), OP_GREPSTART);
d6013 1
a6013 1
        expr = mod(force_list(expr), OP_GREPSTART);
d6017 1
a6017 1
			       append_elem(OP_LIST, expr, scalar(sv))));
d6034 1
a6034 1
    wop = newWHILEOP(flags, 1, loop, forline, newOP(OP_ITER, 0), block, cont, 0);
d6037 1
a6037 2
    PL_parser->copline = forline;
    return newSTATEOP(0, label, wop);
d6040 11
d6066 7
a6072 3
	    o = newPVOP(type, 0, savesharedpv(label->op_type == OP_CONST
					? SvPV_nolen_const(((SVOP*)label)->op_sv)
					: ""));
d6084 1
a6084 1
	    label = newUNOP(OP_REFGEN, 0, mod(label, OP_REFGEN));
d6103 13
a6115 2
	return newUNOP(OP_REFGEN,
	    0, mod(cond, OP_REFGEN));
d6162 1
d6257 13
d6282 13
a6294 1
/* If cond is null, this is a default {} block */
d6311 1
a6311 4
    return newGIVWHENOP(
	cond_op,
	append_elem(block->op_type, block, newOP(OP_BREAK, OPf_SPECIAL)),
	OP_ENTERWHEN, OP_LEAVEWHEN, 0);
a6313 11
/*
=for apidoc cv_undef

Clear out all the active components of a CV. This can happen either
by an explicit C<undef &foo>, or by the reference count going to zero.
In the former case, we keep the CvOUTSIDE pointer, so that any anonymous
children can still follow the full lexical scope chain.

=cut
*/

d6315 2
a6316 1
Perl_cv_undef(pTHX_ CV *cv)
d6318 2
a6319 31
    dVAR;

    PERL_ARGS_ASSERT_CV_UNDEF;

    DEBUG_X(PerlIO_printf(Perl_debug_log,
	  "CV undef: cv=0x%"UVxf" comppad=0x%"UVxf"\n",
	    PTR2UV(cv), PTR2UV(PL_comppad))
    );

#ifdef USE_ITHREADS
    if (CvFILE(cv) && !CvISXSUB(cv)) {
	/* for XSUBs CvFILE point directly to static memory; __FILE__ */
	Safefree(CvFILE(cv));
    }
    CvFILE(cv) = NULL;
#endif

    if (!CvISXSUB(cv) && CvROOT(cv)) {
	if (SvTYPE(cv) == SVt_PVCV && CvDEPTH(cv))
	    Perl_croak(aTHX_ "Can't undef active subroutine");
	ENTER;

	PAD_SAVE_SETNULLPAD();

	op_free(CvROOT(cv));
	CvROOT(cv) = NULL;
	CvSTART(cv) = NULL;
	LEAVE;
    }
    SvPOK_off(MUTABLE_SV(cv));		/* forget prototype */
    CvGV(cv) = NULL;
d6321 1
a6321 1
    pad_undef(cv);
d6323 12
a6334 28
    /* remove CvOUTSIDE unless this is an undef rather than a free */
    if (!SvREFCNT(cv) && CvOUTSIDE(cv)) {
	if (!CvWEAKOUTSIDE(cv))
	    SvREFCNT_dec(CvOUTSIDE(cv));
	CvOUTSIDE(cv) = NULL;
    }
    if (CvCONST(cv)) {
	SvREFCNT_dec(MUTABLE_SV(CvXSUBANY(cv).any_ptr));
	CvCONST_off(cv);
    }
    if (CvISXSUB(cv) && CvXSUB(cv)) {
	CvXSUB(cv) = NULL;
    }
    /* delete all flags except WEAKOUTSIDE */
    CvFLAGS(cv) &= CVf_WEAKOUTSIDE;
}

void
Perl_cv_ckproto_len(pTHX_ const CV *cv, const GV *gv, const char *p,
		    const STRLEN len)
{
    PERL_ARGS_ASSERT_CV_CKPROTO_LEN;

    /* Can't just use a strcmp on the prototype, as CONSTSUBs "cheat" by
       relying on SvCUR, and doubling up the buffer to hold CvFILE().  */
    if (((!p != !SvPOK(cv)) /* One has prototype, one has not.  */
	 || (p && (len != SvCUR(cv) /* Not the same length.  */
		   || memNE(p, SvPVX_const(cv), len))))
d6345 3
a6347 1
	    Perl_sv_catpvf(aTHX_ msg, " (%"SVf")", SVfARG(cv));
d6352 1
a6352 1
	    Perl_sv_catpvf(aTHX_ msg, "(%.*s)", (int) len, p);
d6402 1
a6402 1
 *	candidiate. Try to grab the current value, and in the case of
d6427 3
a6429 1
	    if (type == OP_NEXTSTATE || type == OP_NULL || type == OP_PUSHMARK)
d6497 1
a6497 1
Perl_newSUB(pTHX_ I32 floor, OP *o, OP *proto, OP *block)
d6499 1
a6499 1
    return Perl_newATTRSUB(aTHX_ floor, o, proto, NULL, block);
d6503 2
a6504 1
Perl_newATTRSUB(pTHX_ I32 floor, OP *o, OP *proto, OP *attrs, OP *block)
d6509 2
a6510 1
    STRLEN ps_len;
d6522 4
a6525 1
    const char * const name = o ? SvPV_nolen_const(cSVOPo->op_sv) : NULL;
d6527 1
d6532 1
d6537 5
a6541 1
    if (name) {
d6576 1
a6576 1
	    cv_ckproto_len((const CV *)gv, NULL, ps, ps_len);
d6578 1
a6578 1
	if (ps)
d6580 2
d6610 1
a6610 1
	    cv_ckproto_len(cv, gv, ps, ps_len);
d6617 1
a6617 1
		 )&& !attrs) {
d6620 3
a6622 1
		    if (CvLVALUE(PL_compcv) && ! CvLVALUE(cv) && ckWARN(WARN_MISC))
d6624 3
a6626 1
		    CvFLAGS(cv) |= (CvFLAGS(PL_compcv) & CVf_BUILTIN_ATTRS & ~CVf_LVALUE);
d6628 1
d6638 2
a6639 6
		if (ckWARN(WARN_REDEFINE)
		    || (CvCONST(cv)
			&& (!const_sv || sv_cmp(cv_const_sv(cv), const_sv))))
		{
		    const line_t oldline = CopLINE(PL_curcop);
		    if (PL_parser && PL_parser->copline != NOLINE)
d6641 2
a6642 5
		    Perl_warner(aTHX_ packWARN(WARN_REDEFINE),
			CvCONST(cv) ? "Constant subroutine %s redefined"
				    : "Subroutine %s redefined", name);
		    CopLINE_set(PL_curcop, oldline);
		}
d6655 1
d6666 5
a6670 2
	    GvCV(gv) = NULL;
	    cv = newCONSTSUB(NULL, name, const_sv);
d6672 1
a6672 1
        mro_method_changed_in( /* sub Foo::Bar () { 123 } */
d6677 3
a6679 2
                    : PL_curstash
        );
d6695 8
a6702 1
	    cv_undef(cv);
a6703 2
	    if (!CvWEAKOUTSIDE(cv))
		SvREFCNT_dec(CvOUTSIDE(cv));
a6705 1
	    CvOUTSIDE(PL_compcv) = 0;
d6707 9
a6715 1
	    CvPADLIST(PL_compcv) = 0;
d6732 1
a6732 1
	    GvCV(gv) = cv;
d6741 3
a6743 1
            mro_method_changed_in(GvSTASH(gv)); /* sub Foo::bar { (shift)+1 } */
d6747 1
a6747 1
	CvGV(cv) = gv;
d6749 1
a6749 6
	CvSTASH(cv) = PL_curstash;
    }
    if (attrs) {
	/* Need to do a C<use attributes $stash_of_cv,\&cv,@@attrs>. */
	HV *stash = name && GvSTASH(CvGV(cv)) ? GvSTASH(CvGV(cv)) : PL_curstash;
	apply_attrs(stash, MUTABLE_SV(cv), attrs, FALSE);
d6752 1
a6752 1
    if (ps)
d6754 2
d6778 1
a6778 1
	goto done;
d6786 2
a6787 8
    if (CvLVALUE(cv)) {
	CvROOT(cv) = newUNOP(OP_LEAVESUBLV, 0,
			     mod(scalarseq(block), OP_LEAVESUBLV));
	block->op_attached = 1;
    }
    else {
	/* This makes sub {}; work as expected.  */
	if (block->op_type == OP_STUB) {
a6794 4
	}
	else
	    block->op_attached = 1;
	CvROOT(cv) = newUNOP(OP_LEAVESUB, 0, scalarseq(block));
d6796 5
d6806 1
d6818 8
a6825 1
    if (has_name) {
a6826 1
	    SV * const sv = newSV(0);
d6831 4
a6834 4

	    Perl_sv_setpvf(aTHX_ sv, "%s:%ld-%ld",
			   CopFILE(PL_curcop),
			   (long)PL_subline, (long)CopLINE(PL_curcop));
d6837 1
a6837 1
		    SvCUR(tmpstr), sv, 0);
d6839 1
a6839 1
	    if (HvFILL(hv) > 0 && hv_exists(hv, SvPVX_const(tmpstr), SvCUR(tmpstr))) {
d6877 1
d6881 1
a6881 1
	    GvCV(gv) = 0;		/* cv has been hijacked */
a6883 1
	    PL_curcop = &PL_compiling;
d6906 1
d6916 1
d6926 1
a6926 1
	GvCV(gv) = 0;		/* cv has been hijacked */
d6933 14
d6950 2
d6961 2
a6962 1
Perl_newCONSTSUB(pTHX_ HV *stash, const char *name, SV *sv)
d6980 2
d6991 1
a6991 1
	SAVESPTR(PL_curstash);
d6993 1
a6993 1
	PL_curstash = stash;
d6997 1
a6997 1
    /* file becomes the CvFILE. For an XS, it's supposed to be static storage,
d7001 2
a7002 2
    cv = newXS_flags(name, const_sv_xsub, file ? file : "", "",
		     XS_DYNAMIC_FILENAME);
d7020 15
a7034 1
    CV *cv = newXS(name, subaddr, filename);
d7036 61
a7096 1
    PERL_ARGS_ASSERT_NEWXS_FLAGS;
d7099 2
a7100 33
	/* We need to "make arrangements" (ie cheat) to ensure that the
	   filename lasts as long as the PVCV we just created, but also doesn't
	   leak  */
	STRLEN filename_len = strlen(filename);
	STRLEN proto_and_file_len = filename_len;
	char *proto_and_file;
	STRLEN proto_len;

	if (proto) {
	    proto_len = strlen(proto);
	    proto_and_file_len += proto_len;

	    Newx(proto_and_file, proto_and_file_len + 1, char);
	    Copy(proto, proto_and_file, proto_len, char);
	    Copy(filename, proto_and_file + proto_len, filename_len + 1, char);
	} else {
	    proto_len = 0;
	    proto_and_file = savepvn(filename, filename_len);
	}

	/* This gets free()d.  :-)  */
	sv_usepvn_flags(MUTABLE_SV(cv), proto_and_file, proto_and_file_len,
			SV_HAS_TRAILING_NUL);
	if (proto) {
	    /* This gives us the correct prototype, rather than one with the
	       file name appended.  */
	    SvCUR_set(cv, proto_len);
	} else {
	    SvPOK_off(cv);
	}
	CvFILE(cv) = proto_and_file + proto_len;
    } else {
	sv_setpv(MUTABLE_SV(cv), proto);
d7102 1
a7117 6
    dVAR;
    GV * const gv = gv_fetchpv(name ? name :
			(PL_curstash ? "__ANON__" : "__ANON__::__ANON__"),
			GV_ADDMULTI, SVt_PVCV);
    register CV *cv;

d7119 1
a7119 60

    if (!subaddr)
	Perl_croak(aTHX_ "panic: no address for '%s' in '%s'", name, filename);

    if ((cv = (name ? GvCV(gv) : NULL))) {
	if (GvCVGEN(gv)) {
	    /* just a cached method */
	    SvREFCNT_dec(cv);
	    cv = NULL;
	}
	else if (CvROOT(cv) || CvXSUB(cv) || GvASSUMECV(gv)) {
	    /* already defined (or promised) */
	    /* XXX It's possible for this HvNAME_get to return null, and get passed into strEQ */
	    if (ckWARN(WARN_REDEFINE)) {
		GV * const gvcv = CvGV(cv);
		if (gvcv) {
		    HV * const stash = GvSTASH(gvcv);
		    if (stash) {
			const char *redefined_name = HvNAME_get(stash);
			if ( strEQ(redefined_name,"autouse") ) {
			    const line_t oldline = CopLINE(PL_curcop);
			    if (PL_parser && PL_parser->copline != NOLINE)
				CopLINE_set(PL_curcop, PL_parser->copline);
			    Perl_warner(aTHX_ packWARN(WARN_REDEFINE),
					CvCONST(cv) ? "Constant subroutine %s redefined"
						    : "Subroutine %s redefined"
					,name);
			    CopLINE_set(PL_curcop, oldline);
			}
		    }
		}
	    }
	    SvREFCNT_dec(cv);
	    cv = NULL;
	}
    }

    if (cv)				/* must reuse cv if autoloaded */
	cv_undef(cv);
    else {
	cv = MUTABLE_CV(newSV_type(SVt_PVCV));
	if (name) {
	    GvCV(gv) = cv;
	    GvCVGEN(gv) = 0;
            mro_method_changed_in(GvSTASH(gv)); /* newXS */
	}
    }
    CvGV(cv) = gv;
    (void)gv_fetchfile(filename);
    CvFILE(cv) = (char *)filename; /* NOTE: not copied, as it is expected to be
				   an external constant string */
    CvISXSUB_on(cv);
    CvXSUB(cv) = subaddr;

    if (name)
	process_special_blocks(name, gv, cv);
    else
	CvANON_on(cv);

    return cv;
d7149 1
d7159 1
a7159 1
    CvGV(cv) = gv;
d7170 1
d7340 1
a7340 1
    cSVOPo->op_targ = pad_add_anon(cSVOPo->op_sv, o->op_type);
a7352 8
#define OP_IS_NUMCOMPARE(op) \
	((op) == OP_LT   || (op) == OP_I_LT || \
	 (op) == OP_GT   || (op) == OP_I_GT || \
	 (op) == OP_LE   || (op) == OP_I_LE || \
	 (op) == OP_GE   || (op) == OP_I_GE || \
	 (op) == OP_EQ   || (op) == OP_I_EQ || \
	 (op) == OP_NE   || (op) == OP_I_NE || \
	 (op) == OP_NCMP || (op) == OP_I_NCMP)
d7374 30
d7501 1
d7512 4
a7515 1
	return ck_fun(o);
d7554 1
a7554 1
	    o = prepend_elem(OP_LINESEQ, (OP*)enter, (OP*)kid);
d7567 1
d7573 1
a7573 1
	o = newUNOP(OP_ENTEREVAL, 0, newDEFSVOP());
d7577 3
a7579 1
    if ((PL_hints & HINT_LOCALIZE_HH) != 0 && GvHV(PL_hintgv)) {
d7582 1
a7582 1
			   MUTABLE_SV(Perl_hv_copy_hints_hv(aTHX_ GvHV(PL_hintgv))));
d7586 3
a7698 11
	else if ((o->op_type == OP_RV2HV || o->op_type == OP_RV2SV) &&
		(PL_hints & HINT_STRICT_REFS) && SvPOK(kidsv)) {
	    /* If this is an access to a stash, disable "strict refs", because
	     * stashes aren't auto-vivified at compile-time (unless we store
	     * symbols in them), and we don't want to produce a run-time
	     * stricture error when auto-vivifying the stash. */
	    const char *s = SvPV_nolen(kidsv);
	    const STRLEN l = SvCUR(kidsv);
	    if (l > 1 && s[l-1] == ':' && s[l-2] == ':')
		o->op_private &= ~HINT_STRICT_REFS;
	}
d7756 2
d7790 2
a7791 2
	if (PL_check[kidtype] == MEMBER_TO_FPTR(Perl_ck_ftst)
		&& kidtype != OP_STAT && kidtype != OP_LSTAT)
d7793 7
d7837 1
d7845 18
a7862 2
	if (!kid && PL_opargs[type] & OA_DEFGV)
	    *tokid = kid = newDEFSVOP();
a7863 1
	while (oa && kid) {
d7878 1
a7878 1
		    return too_many_arguments(o,PL_op_desc[type]);
d7914 9
a7922 3
		else if (kid->op_type != OP_RV2AV && kid->op_type != OP_PADAV)
		    bad_type(numargs, "array", PL_op_desc[type], kid);
		mod(kid, type);
d7943 2
a7944 2
		    bad_type(numargs, "hash", PL_op_desc[type], kid);
		mod(kid, type);
d7950 1
a7950 1
		    linklist(kid);
d7976 1
a7976 1
			bad_type(numargs, "HANDLE", OP_DESC(o), kid);
d7987 2
d8000 1
d8008 1
d8048 1
d8055 1
d8057 1
a8057 1
				 mod(kid, type);
d8064 1
a8064 1
				if (*name != '$')
d8067 1
d8081 1
a8081 1
		mod(scalar(kid), type);
d8090 1
a8090 1
	    return too_many_arguments(o,OP_DESC(o));
d8096 1
a8096 1
	    return too_many_arguments(o,OP_DESC(o));
d8116 1
a8116 1
	    return too_few_arguments(o,OP_DESC(o));
d8126 1
d8132 1
a8132 1
	append_elem(OP_GLOB, o, newDEFSVOP());
d8134 2
a8135 1
    if (!((gv = gv_fetchpvs("glob", GV_NOTQUAL, SVt_PVCV))
a8141 1
    /* XXX this can be tightened up and made more failsafe. */
a8142 1
	GV *glob_gv;
a8145 6
	if((glob_gv = gv_fetchpvs("File::Glob::csh_glob", 0, SVt_PVCV))) {
	    gv = gv_fetchpvs("CORE::GLOBAL::glob", 0, SVt_PVCV);
	    GvCV(gv) = GvCV(glob_gv);
	    SvREFCNT_inc_void(MUTABLE_SV(GvCV(gv)));
	    GvIMPORTED_CV_on(gv);
	}
d8148 1
a8148 1
#endif /* PERL_EXTERNAL_GLOB */
d8151 15
a8165 1
	append_elem(OP_GLOB, o,
d8167 1
a8167 5
	o->op_type = OP_LIST;
	o->op_ppaddr = PL_ppaddr[OP_LIST];
	cLISTOPo->op_first->op_type = OP_PUSHMARK;
	cLISTOPo->op_first->op_ppaddr = PL_ppaddr[OP_PUSHMARK];
	cLISTOPo->op_first->op_targ = 0;
d8169 1
a8169 1
		    append_elem(OP_LIST, o,
d8173 1
a8173 1
	o->op_targ = OP_GLOB;		/* hint at what it used to be */
d8176 1
d8179 4
a8182 1
    append_elem(OP_GLOB, o, newGVOP(OP_GV, 0, gv));
d8224 1
a8224 1
	Perl_croak(aTHX_ "panic: ck_grep");
d8235 1
a8235 1
    offset = Perl_pad_findmy(aTHX_ STR_WITH_LEN("$_"), 0);
d8247 1
a8247 1
	return too_few_arguments(o,OP_DESC(o));
d8249 1
a8249 1
	mod(kid, OP_GREPSTART);
d8263 2
a8264 1
	if (kid && kid->op_type == OP_CONST)
d8266 2
a8289 5
	    /* This is needed for
	       if (defined %stash::)
	       to work.   Do not break Tk.
	       */
	    break;                      /* Globals via GV can be undef */
d8317 5
a8321 1
    if (!(o->op_flags & OPf_KIDS)) {
d8371 1
a8371 1
	append_elem(o->op_type, o, newDEFSVOP());
d8373 1
d8381 1
d8442 7
a8448 1
	if (kkid->op_type == OP_PADSV
d8467 1
a8467 1
	       assinment binop->op_last = binop->op_first->op_sibling; at the
d8485 1
a8485 1
	const PADOFFSET offset = Perl_pad_findmy(aTHX_ STR_WITH_LEN("$_"), 0);
d8509 1
a8509 1
		sv = newSVpvn_share(method, SvCUR(sv), 0);
d8668 8
a8675 4
	OP * const kid = cUNOPo->op_first;
	OP * newop;

	cUNOPo->op_first = 0;
d8680 1
a8680 1
				append_elem(OP_LIST, kid,
d8702 1
a8702 14
	    mod(kid, OP_LEAVESUBLV);
    } else {
	for (; kid; kid = kid->op_sibling)
	    if ((kid->op_type == OP_NULL)
		&& ((kid->op_flags & (OPf_SPECIAL|OPf_KIDS)) == (OPf_SPECIAL|OPf_KIDS))) {
		/* This is a do block */
		OP *op = kUNOP->op_first;
		if (op->op_type == OP_LEAVE && op->op_flags & OPf_KIDS) {
		    op = cUNOPx(op)->op_first;
		    assert(op->op_type == OP_ENTER && !(op->op_flags & OPf_SPECIAL));
		    /* Force the use of the caller's context */
		    op->op_flags |= OPf_SPECIAL;
		}
	    }
d8722 1
a8722 1
	    return fold_constants(o);
d8741 8
a8748 2
	OP *argop = newUNOP(OP_RV2AV, 0,
	    scalar(newGVOP(OP_GV, 0, CvUNIQUE(PL_compcv) ? PL_argvgv : PL_defgv)));
d8750 6
a8755 4
	OP * const oldo = o;
	o = newUNOP(type, 0, scalar(argop));
	op_getmad(oldo,o,'O');
	return o;
d8761 1
a8761 1
    return scalar(modkids(ck_fun(o), type));
d8794 1
a8794 1
	    linklist(kid);
a8830 2
	else if (kid->op_type == OP_RV2SV || kid->op_type == OP_PADSV)
	    op_null(firstkid);
d8932 1
a8932 1
	Perl_croak(aTHX_ "panic: ck_split");
d8935 3
a8937 2
    cLISTOPo->op_first = kid;
    if (!kid) {
d8961 1
a8961 1
	append_elem(OP_SPLIT, o, newDEFSVOP());
d8967 1
a8967 1
	append_elem(OP_SPLIT, o, newSVOP(OP_CONST, 0, newSViv(0)));
d8974 1
a8974 1
	return too_many_arguments(o,OP_DESC(o));
d8989 4
a8992 2
	    const char *pmstr = re ? RX_PRECOMP_const(re) : "STRING";
	    const STRLEN len = re ? RX_PRELEN(re) : 6;
d8994 2
a8995 2
			"/%.*s/ should probably be written as \"%.*s\"",
			(int)len, pmstr, (int)len, pmstr);
d9001 145
d9147 1
a9147 1
Perl_ck_subr(pTHX_ OP *o)
d9149 3
a9151 9
    dVAR;
    OP *prev = ((cUNOPo->op_first->op_sibling)
	     ? cUNOPo : ((UNOP*)cUNOPo->op_first))->op_first;
    OP *o2 = prev->op_sibling;
    OP *cvop;
    const char *proto = NULL;
    const char *proto_end = NULL;
    CV *cv = NULL;
    GV *namegv = NULL;
d9156 15
a9170 46
    bool delete_op = 0;

    PERL_ARGS_ASSERT_CK_SUBR;

    o->op_private |= OPpENTERSUB_HASTARG;
    for (cvop = o2; cvop->op_sibling; cvop = cvop->op_sibling) ;
    if (cvop->op_type == OP_RV2CV) {
	o->op_private |= (cvop->op_private & OPpENTERSUB_AMPER);
	op_null(cvop);		/* disable rv2cv */
	if (!(o->op_private & OPpENTERSUB_AMPER)) {
	    SVOP *tmpop = (SVOP*)((UNOP*)cvop)->op_first;
	    GV *gv = NULL;
	    switch (tmpop->op_type) {
		case OP_GV: {
		    gv = cGVOPx_gv(tmpop);
		    cv = GvCVu(gv);
		    if (!cv)
			tmpop->op_private |= OPpEARLY_CV;
		} break;
		case OP_CONST: {
		    SV *sv = cSVOPx_sv(tmpop);
		    if (SvROK(sv) && SvTYPE(SvRV(sv)) == SVt_PVCV)
			cv = (CV*)SvRV(sv);
		} break;
	    }
	    if (cv && SvPOK(cv)) {
		STRLEN len;
		namegv = gv && CvANON(cv) ? gv : CvGV(cv);
		proto = SvPV(MUTABLE_SV(cv), len);
		proto_end = proto + len;
	    }
	}
    }
    else if (cvop->op_type == OP_METHOD || cvop->op_type == OP_METHOD_NAMED) {
	if (o2->op_type == OP_CONST)
	    o2->op_private &= ~OPpCONST_STRICT;
	else if (o2->op_type == OP_LIST) {
	    OP * const sib = ((UNOP*)o2)->op_first->op_sibling;
	    if (sib && sib->op_type == OP_CONST)
		sib->op_private &= ~OPpCONST_STRICT;
	}
    }
    o->op_private |= (PL_hints & HINT_STRICT_REFS);
    if (PERLDB_SUB && PL_curstash != PL_debstash)
	o->op_private |= OPpENTERSUB_DB;
    while (o2 != cvop) {
d9172 2
a9173 2
	if (PL_madskills && o2->op_type == OP_STUB) {
	    o2 = o2->op_sibling;
d9176 2
a9177 2
	if (PL_madskills && o2->op_type == OP_NULL)
	    o3 = ((UNOP*)o2)->op_first;
d9179 4
a9182 4
	    o3 = o2;
	if (proto) {
	    if (proto >= proto_end)
		return too_many_arguments(o, gv_ename(namegv));
d9184 1
a9184 1
	    switch (*proto) {
d9191 1
a9191 1
		if (proto[1] && proto[1] != ';')
d9196 1
a9196 1
		scalar(o2);
d9200 1
a9200 1
		list(o2);
d9207 3
a9209 3
		    bad_type(arg,
			arg == 1 ? "block or sub {}" : "sub {}",
			gv_ename(namegv), o3);
d9228 3
a9230 3
				(gvop->op_private & OPpENTERSUB_NOPAREN) &&
				(gvop = ((UNOP*)gvop)->op_first) &&
				gvop->op_type == OP_GV)
d9233 1
a9233 1
				OP * const sibling = o2->op_sibling;
d9236 1
a9236 1
				OP * const oldo2 = o2;
d9238 1
a9238 1
				op_free(o2);
d9241 4
a9244 4
				o2 = newSVOP(OP_CONST, 0, n);
				op_getmad(oldo2,o2,'O');
				prev->op_sibling = o2;
				o2->op_sibling = sibling;
d9249 13
a9261 1
		scalar(o2);
d9264 2
a9265 2
		 goto oops;
		 break;
d9271 87
a9357 73
		case '[':
		     if (contextclass++ == 0) {
		          e = strchr(proto, ']');
			  if (!e || e == proto)
			       goto oops;
		     }
		     else
			  goto oops;
		     goto again;
		     break;
		case ']':
		     if (contextclass) {
		         const char *p = proto;
			 const char *const end = proto;
			 contextclass = 0;
			 while (*--p != '[') {}
			 bad_type(arg, Perl_form(aTHX_ "one of %.*s",
						 (int)(end - p), p),
				  gv_ename(namegv), o3);
		     } else
			  goto oops;
		     break;
		case '*':
		     if (o3->op_type == OP_RV2GV)
			  goto wrapref;
		     if (!contextclass)
			  bad_type(arg, "symbol", gv_ename(namegv), o3);
		     break;
		case '&':
		     if (o3->op_type == OP_ENTERSUB)
			  goto wrapref;
		     if (!contextclass)
			  bad_type(arg, "subroutine entry", gv_ename(namegv),
				   o3);
		     break;
		case '$':
		    if (o3->op_type == OP_RV2SV ||
			o3->op_type == OP_PADSV ||
			o3->op_type == OP_HELEM ||
			o3->op_type == OP_AELEM)
			 goto wrapref;
		    if (!contextclass)
			bad_type(arg, "scalar", gv_ename(namegv), o3);
		     break;
		case '@@':
		    if (o3->op_type == OP_RV2AV ||
			o3->op_type == OP_PADAV)
			 goto wrapref;
		    if (!contextclass)
			bad_type(arg, "array", gv_ename(namegv), o3);
		    break;
		case '%':
		    if (o3->op_type == OP_RV2HV ||
			o3->op_type == OP_PADHV)
			 goto wrapref;
		    if (!contextclass)
			 bad_type(arg, "hash", gv_ename(namegv), o3);
		    break;
		wrapref:
		    {
			OP* const kid = o2;
			OP* const sib = kid->op_sibling;
			kid->op_sibling = 0;
			o2 = newUNOP(OP_REFGEN, 0, kid);
			o2->op_sibling = sib;
			prev->op_sibling = o2;
		    }
		    if (contextclass && e) {
			 proto = e + 1;
			 contextclass = 0;
		    }
		    break;
		default: goto oops;
d9360 1
a9360 1
		     goto again;
d9366 6
a9371 4
	      oops:
		Perl_croak(aTHX_ "Malformed prototype for %s: %"SVf,
			   gv_ename(namegv), SVfARG(cv));
	    }
d9373 6
a9378 7
	else
	    list(o2);
	mod(o2, OP_ENTERSUB);
	prev = o2;
	o2 = o2->op_sibling;
    } /* while */
    if (o2 == cvop && proto && *proto == '_') {
d9380 3
a9382 3
	o2 = newDEFSVOP();
	o2->op_sibling = prev->op_sibling;
	prev->op_sibling = o2; /* instead of cvop */
d9384 1
a9384 1
    if (proto && !optional && proto_end > proto &&
d9386 84
a9469 2
	return too_few_arguments(o, gv_ename(namegv));
    if(delete_op) {
d9471 1
a9471 3
	OP * const oldo = o;
#else
	op_free(o);
d9473 186
a9658 2
	o=newSVOP(OP_CONST, 0, newSViv(0));
	op_getmad(oldo,o,'O');
a9659 1
    return o;
d9674 1
a9708 15
Perl_ck_unpack(pTHX_ OP *o)
{
    OP *kid = cLISTOPo->op_first;

    PERL_ARGS_ASSERT_CK_UNPACK;

    if (kid->op_sibling) {
	kid = kid->op_sibling;
	if (!kid->op_sibling)
	    kid->op_sibling = newDEFSVOP();
    }
    return ck_fun(o);
}

OP *
d9727 13
d9743 6
a9748 1
    OP *kid = o->op_flags & OPf_KIDS ? cLISTOPo->op_first : NULL;
d9753 19
a9771 11
	if (kid->op_type == OP_PADAV || kid->op_type == OP_RV2AV) {
	    const unsigned new_type = o->op_type == OP_EACH ? OP_AEACH
		: o->op_type == OP_KEYS ? OP_AKEYS : OP_AVALUES;
	    o->op_type = new_type;
	    o->op_ppaddr = PL_ppaddr[new_type];
	}
	else if (!(kid->op_type == OP_PADHV || kid->op_type == OP_RV2HV
		    || (kid->op_type == OP_CONST && kid->op_private & OPpCONST_BARE)
		  )) {
	    bad_type(1, "hash or array", PL_op_desc[o->op_type], kid);
	    return o;
d9774 54
a9827 1
    return ck_fun(o);
d9858 11
a9868 3
/* Checks if o acts as an in-place operator on an array. oright points to the
 * beginning of the right-hand side. Returns the left-hand side of the
 * assignment if o acts in-place, or NULL otherwise. */
d9870 16
a9885 13
STATIC OP *
S_is_inplace_av(pTHX_ OP *o, OP *oright) {
    OP *o2;
    OP *oleft = NULL;

    PERL_ARGS_ASSERT_IS_INPLACE_AV;

    if (!oright ||
	(oright->op_type != OP_RV2AV && oright->op_type != OP_PADAV)
	|| oright->op_next != o
	|| (oright->op_private & OPpLVAL_INTRO)
    )
	return NULL;
d9887 16
a9902 14
    /* o2 follows the chain of op_nexts through the LHS of the
     * assign (if any) to the aassign op itself */
    o2 = o->op_next;
    if (!o2 || o2->op_type != OP_NULL)
	return NULL;
    o2 = o2->op_next;
    if (!o2 || o2->op_type != OP_PUSHMARK)
	return NULL;
    o2 = o2->op_next;
    if (o2 && o2->op_type == OP_GV)
	o2 = o2->op_next;
    if (!o2
	|| (o2->op_type != OP_PADAV && o2->op_type != OP_RV2AV)
	|| (o2->op_private & OPpLVAL_INTRO)
d9904 1
a9904 9
	return NULL;
    oleft = o2;
    o2 = o2->op_next;
    if (!o2 || o2->op_type != OP_NULL)
	return NULL;
    o2 = o2->op_next;
    if (!o2 || o2->op_type != OP_AASSIGN
	    || (o2->op_flags & OPf_WANT) != OPf_WANT_VOID)
	return NULL;
d9906 3
a9908 10
    /* check that the sort is the first arg on RHS of assign */

    o2 = cUNOPx(o2)->op_first;
    if (!o2 || o2->op_type != OP_NULL)
	return NULL;
    o2 = cUNOPx(o2)->op_first;
    if (!o2 || o2->op_type != OP_PUSHMARK)
	return NULL;
    if (o2->op_sibling != o)
	return NULL;
d9915 1
d9919 1
a9919 1
	    return NULL;
d9924 8
a9931 1
	return NULL;
d9933 6
a9938 1
    return oleft;
d9941 10
d9956 1
a9956 1
Perl_peep(pTHX_ register OP *o)
d9960 3
d9969 6
a9974 2
    for (; o; o = o->op_next) {
	if (o->op_opt)
d9976 2
a9982 1
	case OP_NEXTSTATE:
d9986 35
a10021 3
	case OP_CONST:
	    if (cSVOPo->op_private & OPpCONST_STRICT)
		no_bareword_allowed(o);
d10023 14
a10036 25
	case OP_HINTSEVAL:
	case OP_METHOD_NAMED:
	    /* Relocate sv to the pad for thread safety.
	     * Despite being a "constant", the SV is written to,
	     * for reference counts, sv_upgrade() etc. */
	    if (cSVOP->op_sv) {
		const PADOFFSET ix = pad_alloc(OP_CONST, SVs_PADTMP);
		if (o->op_type != OP_METHOD_NAMED && SvPADTMP(cSVOPo->op_sv)) {
		    /* If op_sv is already a PADTMP then it is being used by
		     * some pad, so make a copy. */
		    sv_setsv(PAD_SVl(ix),cSVOPo->op_sv);
		    SvREADONLY_on(PAD_SVl(ix));
		    SvREFCNT_dec(cSVOPo->op_sv);
		}
		else if (o->op_type != OP_METHOD_NAMED
			 && cSVOPo->op_sv == &PL_sv_undef) {
		    /* PL_sv_undef is hack - it's unsafe to store it in the
		       AV that is the pad, because av_fetch treats values of
		       PL_sv_undef as a "free" AV entry and will merrily
		       replace them with a new SV, causing pad_alloc to think
		       that this pad slot is free. (When, clearly, it is not)
		    */
		    SvOK_off(PAD_SVl(ix));
		    SvPADTMP_on(PAD_SVl(ix));
		    SvREADONLY_on(PAD_SVl(ix));
a10037 9
		else {
		    SvREFCNT_dec(PAD_SVl(ix));
		    SvPADTMP_on(cSVOPo->op_sv);
		    PAD_SETSV(ix, cSVOPo->op_sv);
		    /* XXX I don't know how this isn't readonly already. */
		    SvREADONLY_on(PAD_SVl(ix));
		}
		cSVOPo->op_sv = NULL;
		o->op_targ = ix;
a10038 1
#endif
d10068 1
a10068 1
	       to peep() from mistakenly concluding that optimisation
d10096 1
a10096 3
		    (i = SvIV(((SVOP*)pop)->op_sv) - CopARYBASE_get(PL_curcop))
				<= 255 &&
		    i >= 0)
d10112 1
d10115 1
a10115 2
			o->op_flags |= OPf_SPECIAL;
		    o->op_type = OP_AELEMFAST;
a10129 11
	    else if ((o->op_private & OPpEARLY_CV) && ckWARN(WARN_PROTOTYPE)) {
		GV * const gv = cGVOPo_gv;
		if (SvTYPE(gv) == SVt_PVGV && GvCV(gv) && SvPVX_const(GvCV(gv))) {
		    /* XXX could check prototype here instead of just carping */
		    SV * const sv = sv_newmortal();
		    gv_efullname3(sv, gv, NULL);
		    Perl_warner(aTHX_ packWARN(WARN_PROTOTYPE),
				"%"SVf"() called too early to check prototype",
				SVfARG(sv));
		}
	    }
d10161 4
a10164 1
	    peep(cLOGOP->op_other); /* Recursive calls are not replaced by fptr calls */
d10215 1
a10215 1
	    peep(cLOGOP->op_other); /* Recursive calls are not replaced by fptr calls */
a10221 1
	    peep(cLOOP->op_redoop);
a10223 1
	    peep(cLOOP->op_nextop);
d10226 4
a10229 1
	    peep(cLOOP->op_lastop);
d10238 1
a10238 1
	    peep(cPMOP->op_pmstashstartu.op_pmreplstart);
a10240 122
	case OP_EXEC:
	    if (o->op_next && o->op_next->op_type == OP_NEXTSTATE
		&& ckWARN(WARN_SYNTAX))
	    {
		if (o->op_next->op_sibling) {
		    const OPCODE type = o->op_next->op_sibling->op_type;
		    if (type != OP_EXIT && type != OP_WARN && type != OP_DIE) {
			const line_t oldline = CopLINE(PL_curcop);
			CopLINE_set(PL_curcop, CopLINE((COP*)o->op_next));
			Perl_warner(aTHX_ packWARN(WARN_EXEC),
				    "Statement unlikely to be reached");
			Perl_warner(aTHX_ packWARN(WARN_EXEC),
				    "\t(Maybe you meant system() when you said exec()?)\n");
			CopLINE_set(PL_curcop, oldline);
		    }
		}
	    }
	    break;

	case OP_HELEM: {
	    UNOP *rop;
            SV *lexname;
	    GV **fields;
	    SV **svp, *sv;
	    const char *key = NULL;
	    STRLEN keylen;

	    if (((BINOP*)o)->op_last->op_type != OP_CONST)
		break;

	    /* Make the CONST have a shared SV */
	    svp = cSVOPx_svp(((BINOP*)o)->op_last);
	    if (!SvFAKE(sv = *svp) || !SvREADONLY(sv)) {
		key = SvPV_const(sv, keylen);
		lexname = newSVpvn_share(key,
					 SvUTF8(sv) ? -(I32)keylen : (I32)keylen,
					 0);
		SvREFCNT_dec(sv);
		*svp = lexname;
	    }

	    if ((o->op_private & (OPpLVAL_INTRO)))
		break;

	    rop = (UNOP*)((BINOP*)o)->op_first;
	    if (rop->op_type != OP_RV2HV || rop->op_first->op_type != OP_PADSV)
		break;
	    lexname = *av_fetch(PL_comppad_name, rop->op_first->op_targ, TRUE);
	    if (!SvPAD_TYPED(lexname))
		break;
	    fields = (GV**)hv_fetchs(SvSTASH(lexname), "FIELDS", FALSE);
	    if (!fields || !GvHV(*fields))
		break;
	    key = SvPV_const(*svp, keylen);
	    if (!hv_fetch(GvHV(*fields), key,
			SvUTF8(*svp) ? -(I32)keylen : (I32)keylen, FALSE))
	    {
		Perl_croak(aTHX_ "No such class field \"%s\" " 
			   "in variable %s of type %s", 
		      key, SvPV_nolen_const(lexname), HvNAME_get(SvSTASH(lexname)));
	    }

            break;
        }

	case OP_HSLICE: {
	    UNOP *rop;
	    SV *lexname;
	    GV **fields;
	    SV **svp;
	    const char *key;
	    STRLEN keylen;
	    SVOP *first_key_op, *key_op;

	    if ((o->op_private & (OPpLVAL_INTRO))
		/* I bet there's always a pushmark... */
		|| ((LISTOP*)o)->op_first->op_sibling->op_type != OP_LIST)
		/* hmmm, no optimization if list contains only one key. */
		break;
	    rop = (UNOP*)((LISTOP*)o)->op_last;
	    if (rop->op_type != OP_RV2HV)
		break;
	    if (rop->op_first->op_type == OP_PADSV)
		/* @@$hash{qw(keys here)} */
		rop = (UNOP*)rop->op_first;
	    else {
		/* @@{$hash}{qw(keys here)} */
		if (rop->op_first->op_type == OP_SCOPE 
		    && cLISTOPx(rop->op_first)->op_last->op_type == OP_PADSV)
		{
		    rop = (UNOP*)cLISTOPx(rop->op_first)->op_last;
		}
		else
		    break;
	    }
		    
	    lexname = *av_fetch(PL_comppad_name, rop->op_targ, TRUE);
	    if (!SvPAD_TYPED(lexname))
		break;
	    fields = (GV**)hv_fetchs(SvSTASH(lexname), "FIELDS", FALSE);
	    if (!fields || !GvHV(*fields))
		break;
	    /* Again guessing that the pushmark can be jumped over.... */
	    first_key_op = (SVOP*)((LISTOP*)((LISTOP*)o)->op_first->op_sibling)
		->op_first->op_sibling;
	    for (key_op = first_key_op; key_op;
		 key_op = (SVOP*)key_op->op_sibling) {
		if (key_op->op_type != OP_CONST)
		    continue;
		svp = cSVOPx_svp(key_op);
		key = SvPV_const(*svp, keylen);
		if (!hv_fetch(GvHV(*fields), key, 
			    SvUTF8(*svp) ? -(I32)keylen : (I32)keylen, FALSE))
		{
		    Perl_croak(aTHX_ "No such class field \"%s\" "
			       "in variable %s of type %s",
			  key, SvPV_nolen(lexname), HvNAME_get(SvSTASH(lexname)));
		}
	    }
	    break;
	}

a10241 4
	    /* will point to RV2AV or PADAV op on LHS/RHS of assign */
	    OP *oleft;
	    OP *o2;

d10247 3
a10268 31
	    /* make @@a = sort @@a act in-place */

	    oright = cUNOPx(oright)->op_sibling;
	    if (!oright)
		break;
	    if (oright->op_type == OP_NULL) { /* skip sort block/sub */
		oright = cUNOPx(oright)->op_sibling;
	    }

	    oleft = is_inplace_av(o, oright);
	    if (!oleft)
		break;

	    /* transfer MODishness etc from LHS arg to RHS arg */
	    oright->op_flags = oleft->op_flags;
	    o->op_private |= OPpSORT_INPLACE;

	    /* excise push->gv->rv2av->null->aassign */
	    o2 = o->op_next->op_next;
	    op_null(o2); /* PUSHMARK */
	    o2 = o2->op_next;
	    if (o2->op_type == OP_GV) {
		op_null(o2); /* GV */
		o2 = o2->op_next;
	    }
	    op_null(o2); /* RV2AV or PADAV */
	    o2 = o2->op_next->op_next;
	    op_null(o2); /* AASSIGN */

	    o->op_next = o2->op_next;

a10274 1
	    OP *oleft, *oright;
d10277 1
a10277 24
	    /* @@a = reverse @@a */
	    if ((oright = cLISTOPo->op_first)
		    && (oright->op_type == OP_PUSHMARK)
		    && (oright = oright->op_sibling)
		    && (oleft = is_inplace_av(o, oright))) {
		OP *o2;

		/* transfer MODishness etc from LHS arg to RHS arg */
		oright->op_flags = oleft->op_flags;
		o->op_private |= OPpREVERSE_INPLACE;

		/* excise push->gv->rv2av->null->aassign */
		o2 = o->op_next->op_next;
		op_null(o2); /* PUSHMARK */
		o2 = o2->op_next;
		if (o2->op_type == OP_GV) {
		    op_null(o2); /* GV */
		    o2 = o2->op_next;
		}
		op_null(o2); /* RV2AV or PADAV */
		o2 = o2->op_next->op_next;
		op_null(o2); /* AASSIGN */

		o->op_next = o2->op_next;
a10278 1
	    }
d10364 6
a10369 4
	case OP_SASSIGN: {
	    OP *rv2gv;
	    UNOP *refgen, *rv2cv;
	    LISTOP *exlist;
d10371 115
a10485 2
	    if ((o->op_flags & OPf_WANT) != OPf_WANT_VOID)
		break;
d10487 3
a10489 2
	    if ((o->op_private & ~OPpASSIGN_BACKWARDS) != 2)
		break;
d10491 2
a10492 3
	    rv2gv = ((BINOP *)o)->op_last;
	    if (!rv2gv || rv2gv->op_type != OP_RV2GV)
		break;
d10494 4
a10497 1
	    refgen = (UNOP *)((BINOP *)o)->op_first;
d10499 1
a10499 2
	    if (!refgen || refgen->op_type != OP_REFGEN)
		break;
d10501 2
a10502 4
	    exlist = (LISTOP *)refgen->op_first;
	    if (!exlist || exlist->op_type != OP_NULL
		|| exlist->op_targ != OP_LIST)
		break;
d10504 2
a10505 2
	    if (exlist->op_first->op_type != OP_PUSHMARK)
		break;
d10507 3
a10509 1
	    rv2cv = (UNOP*)exlist->op_last;
d10511 2
a10512 2
	    if (rv2cv->op_type != OP_RV2CV)
		break;
d10514 5
a10518 3
	    assert ((rv2gv->op_private & OPpDONT_INIT_GV) == 0);
	    assert ((o->op_private & OPpASSIGN_CV_TO_GV) == 0);
	    assert ((rv2cv->op_private & OPpMAY_RETURN_CONSTANT) == 0);
d10520 2
a10521 3
	    o->op_private |= OPpASSIGN_CV_TO_GV;
	    rv2gv->op_private |= OPpDONT_INIT_GV;
	    rv2cv->op_private |= OPpMAY_RETURN_CONSTANT;
d10523 71
a10593 1
	    break;
d10595 31
d10627 53
a10679 5
	
	case OP_QR:
	case OP_MATCH:
	    if (!(cPMOP->op_pmflags & PMf_ONCE)) {
		assert (!cPMOP->op_pmstashstartu.op_pmreplstart);
d10681 1
a10681 1
	    break;
a10682 1
	oldop = o;
a10683 1
    LEAVE;
d10686 3
a10688 2
const char*
Perl_custom_op_name(pTHX_ const OP* o)
d10690 3
a10692 4
    dVAR;
    const IV index = PTR2IV(o->op_ppaddr);
    SV* keysv;
    HE* he;
d10694 1
a10694 1
    PERL_ARGS_ASSERT_CUSTOM_OP_NAME;
d10696 28
a10723 2
    if (!PL_custom_op_names) /* This probably shouldn't happen */
        return (char *)PL_op_name[OP_CUSTOM];
d10725 2
a10726 1
    keysv = sv_2mortal(newSViv(index));
d10728 2
a10729 3
    he = hv_fetch_ent(PL_custom_op_names, keysv, 0, 0);
    if (!he)
        return (char *)PL_op_name[OP_CUSTOM]; /* Don't know who you are */
d10731 2
a10732 2
    return SvPV_nolen(HeVAL(he));
}
d10734 2
a10735 7
const char*
Perl_custom_op_desc(pTHX_ const OP* o)
{
    dVAR;
    const IV index = PTR2IV(o->op_ppaddr);
    SV* keysv;
    HE* he;
d10737 33
a10769 1
    PERL_ARGS_ASSERT_CUSTOM_OP_DESC;
d10771 2
a10772 2
    if (!PL_custom_op_descs)
        return (char *)PL_op_desc[OP_CUSTOM];
d10774 5
a10778 1
    keysv = sv_2mortal(newSViv(index));
d10780 8
a10787 5
    he = hv_fetch_ent(PL_custom_op_descs, keysv, 0, 0);
    if (!he)
        return (char *)PL_op_desc[OP_CUSTOM];

    return SvPV_nolen(HeVAL(he));
@


1.14
log
@Merge in perl 5.10.1
@
text
@d1 1
d61 1
a61 1
top level node.
d107 1
d375 1
a375 1
Perl_allocmy(pTHX_ const char *const name)
d383 8
d392 1
a392 1
    if (*name &&
d396 1
a396 1
	  (name[1] == '_' && (*name == '$' || name[2]))))
d400 2
a401 2
	    yyerror(Perl_form(aTHX_ "Can't use global %c^%c%s in \"%s\"",
			      name[0], toCTRL(name[1]), name + 2,
d404 1
a404 1
	    yyerror(Perl_form(aTHX_ "Can't use global %s in \"%s\"",name,
a408 11
    /* check for duplicate declaration */
    pad_check_dup(name, is_our, (PL_curstash ? PL_curstash : PL_defstash));

    if (PL_parser->in_my_stash && *name != '$') {
	yyerror(Perl_form(aTHX_
		    "Can't declare class for non-scalar %s in \"%s\"",
 		     name,
 		     is_our ? "our"
			    : PL_parser->in_my == KEY_state ? "state" : "my"));
    }

d411 3
a413 1
    off = pad_add_name(name,
d419 1
a419 3
		    ),
		    0, /*  not fake */
		    PL_parser->in_my == KEY_state
d492 5
d511 1
a511 1
    if (type == OP_NEXTSTATE || type == OP_SETSTATE || type == OP_DBSTATE
a513 1
		    || (OPCODE)o->op_targ == OP_SETSTATE
d565 1
d579 23
d613 6
d623 1
d690 1
d692 3
a694 4
            av_push((AV*) PL_regex_pad[0],(SV*) PL_regex_pad[(cPMOPo)->op_pmoffset]);
            SvREADONLY_off(PL_regex_pad[(cPMOPo)->op_pmoffset]);
	    SvREPADTMP_on(PL_regex_pad[(cPMOPo)->op_pmoffset]);
            PM_SETRE_OFFSET(cPMOPo, (cPMOPo)->op_pmoffset);
a714 1
    CopLABEL_free(cop);
d822 2
a823 2
OP *
Perl_linklist(pTHX_ OP *o)
d854 2
a855 2
OP *
Perl_scalarkids(pTHX_ OP *o)
d911 1
a912 5
	if ((kid = cLISTOPo->op_first) && kid->op_type == OP_PUSHRE) {
	    if (!kPMOP->op_pmreplrootu.op_pmreplroot)
		deprecate_old("implicit split to @@_");
	}
	/* FALL THROUGH */
d947 1
a947 2
	if (ckWARN(WARN_VOID))
	    Perl_warner(aTHX_ packWARN(WARN_VOID), "Useless use of sort in scalar context");
a979 1
	|| o->op_type == OP_SETSTATE
a981 1
				      || o->op_targ == OP_SETSTATE
d989 1
a989 1
	 || o->op_type == OP_RETURN)
d1090 11
d1125 7
a1131 1
		useless = "a constant";
d1183 14
a1229 4
    case OP_REQUIRE:
	/* all requires must return a boolean value */
	o->op_flags &= ~OPf_WANT;
	/* FALL THROUGH */
a1231 6
    case OP_SPLIT:
	if ((kid = cLISTOPo->op_first) && kid->op_type == OP_PUSHRE) {
	    if (!kPMOP->op_pmreplrootu.op_pmreplroot)
		deprecate_old("implicit split to @@_");
	}
	break;
d1233 2
a1234 2
    if (useless && ckWARN(WARN_VOID))
	Perl_warner(aTHX_ packWARN(WARN_VOID), "Useless use of %s in void context", useless);
d1238 2
a1239 2
OP *
Perl_listkids(pTHX_ OP *o)
a1317 4
    case OP_REQUIRE:
	/* all requires must return a boolean value */
	o->op_flags &= ~OPf_WANT;
	return scalar(o);
d1322 2
a1323 2
OP *
Perl_scalarseq(pTHX_ OP *o)
d1582 6
a1592 1
    case OP_AV2ARYLEN:
d1713 2
a1714 4
	    if (ckWARN(WARN_SYNTAX)) {
		Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
		    "Useless localization of %s", OP_DESC(o));
	    }
d1798 2
a1799 2
OP *
Perl_refkids(pTHX_ OP *o, I32 type)
a2183 8
Perl_my(pTHX_ OP *o)
{
    PERL_ARGS_ASSERT_MY;

    return my_attrs(o, NULL);
}

OP *
d2322 1
a2322 1
    const PADOFFSET offset = pad_findmy("$_");
d2370 1
a2370 2
	    CV * const cv
		= Perl_get_cvn_flags(aTHX_ STR_WITH_LEN("DB::postponed"), 0);
d2457 2
a2458 2
OP *
Perl_fold_constants(pTHX_ register OP *o)
d2598 2
a2599 2
OP *
Perl_gen_constant_list(pTHX_ register OP *o)
d2804 1
a2804 1
	SvPVX((const SV *)tm->mad_val)[0] == 'q')
d2961 1
a2961 1
Perl_newMADPROP(pTHX_ char key, char type, const void* val, I32 vlen)
d3012 2
a3013 2
OP *
Perl_force_list(pTHX_ OP *o)
d3027 2
d3062 6
d3091 8
d3122 4
d3170 2
a3171 2
OP *
Perl_pmtrans(pTHX_ OP *o, OP *expr, OP *repl)
d3495 7
d3521 2
d3536 14
a3549 5
    if (av_len((AV*) PL_regex_pad[0]) > -1) {
	SV * const repointer = av_pop((AV*)PL_regex_pad[0]);
	pmop->op_pmoffset = SvIV(repointer);
	SvREPADTMP_off(repointer);
	sv_setiv(repointer,0);
d3551 2
a3552 2
	SV * const repointer = newSViv(0);
	av_push(PL_regex_padav, SvREFCNT_inc_simple_NN(repointer));
d3619 1
a3619 1
	SV * const pat = ((SVOP*)expr)->op_sv;
d3625 11
a3635 2
	if (DO_UTF8(pat))
	    pm_flags |= RXf_UTF8;
d3767 4
d3793 4
d3835 4
d3892 12
d3942 1
a3942 1
		Perl_croak(aTHX_ "Version number must be constant number");
d4282 1
a4282 1
	    maybe_common_vars = FALSE;
d4436 1
a4469 4
    if (label) {
	CopLABEL_set(cop, label);
	PL_hints |= HINT_BLOCK_SCOPE;
    }
d4481 10
d4537 2
d4586 3
a4592 2
    PERL_ARGS_ASSERT_NEW_LOGOP;

d4596 2
d4599 1
a4599 1
    /* optimize "!a && b" to "a || b", and "!a || b" to "a && b" */
a4600 1
	&& (first->op_flags & OPf_SPECIAL)
d4602 2
d4610 5
a4614 6
	    o = first;
	    first = *firstp = cUNOPo->op_first;
	    if (o->op_next)
		first->op_next = o->op_next;
	    cUNOPo->op_first = NULL;
	    op_free(o);
d4621 2
a4622 2
	else if ((cstop->op_private & OPpCONST_BARE) && ckWARN(WARN_BAREWORD))
		Perl_warner(aTHX_ packWARN(WARN_BAREWORD), "Bareword found in conditional");
d4636 2
d4652 1
a4652 2
		&& !(o2->op_private & OPpPAD_STATE)
		&& ckWARN(WARN_DEPRECATED))
d4654 2
a4655 2
		Perl_warner(aTHX_ packWARN(WARN_DEPRECATED),
			    "Deprecated use of my() in false conditional");
d4733 1
a4733 1
    o = newUNOP(OP_NULL, 0, (OP*)logop);
d4774 2
d4867 3
a4869 1
	if (expr->op_type == OP_READLINE || expr->op_type == OP_GLOB
d4878 1
a4878 1
		if (k2 && k2->op_type == OP_READLINE
d4931 3
a4933 1
	if (expr->op_type == OP_READLINE || expr->op_type == OP_GLOB
d4942 1
a4942 1
		if (k2 && k2->op_type == OP_READLINE
d5072 1
a5072 1
        const PADOFFSET offset = pad_findmy("$_");
d5154 2
d5285 1
d5486 1
a5486 1
Perl_cv_const_sv(pTHX_ CV *cv)
a5613 1
    const char *aname;
d5629 1
d5638 4
a5641 1
    if (!name && PERLDB_NAMEANON && CopLINE(PL_curcop)) {
d5646 8
a5653 1
	aname = SvPVX_const(sv);
a5654 7
    else
	aname = NULL;

    gv = name ? gv_fetchsv(cSVOPo->op_sv, gv_fetch_flags, SVt_PVCV)
	: gv_fetchpv(aname ? aname
		     : (PL_curstash ? "__ANON__" : "__ANON__::__ANON__"),
		     gv_fetch_flags, SVt_PVCV);
d5669 1
a5669 2
		&& !(SvIOK((const SV *)gv) && SvIVX((const SV *)gv) == -1)
		&& ckWARN_d(WARN_PROTOTYPE))
d5671 1
a5671 1
		Perl_warner(aTHX_ packWARN(WARN_PROTOTYPE), "Runaway prototype");
a5686 6
#ifdef GV_UNIQUE_CHECK
    if (cv && GvUNIQUE(gv) && SvREADONLY(cv)) {
        Perl_croak(aTHX_ "Can't define subroutine %s (GV is unique)", name);
    }
#endif

a5699 6
#ifdef GV_UNIQUE_CHECK
        if (exists && GvUNIQUE(gv)) {
            Perl_croak(aTHX_ "Can't redefine unique subroutine %s", name);
        }
#endif

d5715 3
a5717 1
		    CvFLAGS(cv) |= (CvFLAGS(PL_compcv) & CVf_BUILTIN_ATTRS);
d5779 3
a5781 8
    if (attrs) {
	HV *stash;
	SV *rcv;

	/* Need to do a C<use attributes $stash_of_cv,\&cv,@@attrs>
	 * before we clobber PL_compcv.
	 */
	if (cv && (!block
d5783 1
a5783 1
		    || block->op_type == OP_NULL
d5785 17
a5801 2
		    )) {
	    rcv = MUTABLE_SV(cv);
a5803 30
	    if (CvGV(cv) && GvSTASH(CvGV(cv)))
		stash = GvSTASH(CvGV(cv));
	    else if (CvSTASH(cv))
		stash = CvSTASH(cv);
	    else
		stash = PL_curstash;
	}
	else {
	    /* possibly about to re-define existing subr -- ignore old cv */
	    rcv = MUTABLE_SV(PL_compcv);
	    if (name && GvSTASH(gv))
		stash = GvSTASH(gv);
	    else
		stash = PL_curstash;
	}
	apply_attrs(stash, rcv, attrs, FALSE);
    }
    if (cv) {				/* must reuse cv if autoloaded */
	if (
#ifdef PERL_MAD
	    (
#endif
	     !block
#ifdef PERL_MAD
	     || block->op_type == OP_NULL) && !PL_madskills
#endif
	     ) {
	    /* got here with just attrs -- work done, so bug out */
	    SAVEFREESV(PL_compcv);
	    goto done;
a5804 12
	/* transfer PL_compcv to cv */
	cv_undef(cv);
	CvFLAGS(cv) = CvFLAGS(PL_compcv);
	if (!CvWEAKOUTSIDE(cv))
	    SvREFCNT_dec(CvOUTSIDE(cv));
	CvOUTSIDE(cv) = CvOUTSIDE(PL_compcv);
	CvOUTSIDE_SEQ(cv) = CvOUTSIDE_SEQ(PL_compcv);
	CvOUTSIDE(PL_compcv) = 0;
	CvPADLIST(cv) = CvPADLIST(PL_compcv);
	CvPADLIST(PL_compcv) = 0;
	/* inner references to PL_compcv must be fixed up ... */
	pad_fixup_inner_anons(CvPADLIST(cv), PL_compcv, cv);
a5807 2
	if (PERLDB_INTER)/* Advice debugger on the new sub. */
	  ++PL_sub_generation;
d5816 2
a5817 1
		    Perl_warner(aTHX_ packWARN(WARN_VOID), "%lx\n", (long)cv);
d5824 10
a5833 3
    CvGV(cv) = gv;
    CvFILE_set_from_cop(cv, PL_curcop);
    CvSTASH(cv) = PL_curstash;
d5903 1
a5903 1
    if (name || aname) {
d5984 3
a5986 3
		if (PL_main_start && ckWARN(WARN_VOID))
		    Perl_warner(aTHX_ packWARN(WARN_VOID),
				"Too late to run CHECK block");
d5993 3
a5995 3
		if (PL_main_start && ckWARN(WARN_VOID))
		    Perl_warner(aTHX_ packWARN(WARN_VOID),
				"Too late to run INIT block");
d6013 5
a6217 5
#ifdef GV_UNIQUE_CHECK
    if (GvUNIQUE(gv)) {
        Perl_croak(aTHX_ "Bad symbol for form (GV is unique)");
    }
#endif
d6308 1
a6308 2
	if (ckWARN_d(WARN_INTERNAL))
	    Perl_warner(aTHX_ packWARN(WARN_INTERNAL), "oops: oopsAV");
d6336 1
a6336 2
	if (ckWARN_d(WARN_INTERNAL))
	    Perl_warner(aTHX_ packWARN(WARN_INTERNAL), "oops: oopsHV");
d6354 3
a6356 4
    else if ((o->op_type == OP_RV2AV || o->op_type == OP_PADAV)
		&& ckWARN(WARN_DEPRECATED)) {
	Perl_warner(aTHX_ packWARN(WARN_DEPRECATED),
		"Using an array as a reference is deprecated");
d6381 3
a6383 4
    else if ((o->op_type == OP_RV2HV || o->op_type == OP_PADHV)
		&& ckWARN(WARN_DEPRECATED)) {
	Perl_warner(aTHX_ packWARN(WARN_DEPRECATED),
		"Using a hash as a reference is deprecated");
d6450 5
a6454 6
	    if (ckWARN(WARN_PRECEDENCE))
		Perl_warner(aTHX_ packWARN(WARN_PRECEDENCE),
			"Possible precedence problem on bitwise %c operator",
			o->op_type == OP_BIT_OR ? '|'
			    : o->op_type == OP_BIT_AND ? '&' : '^'
			);
d6530 2
a6604 2
	    CHECKOP(OP_ENTERTRY, enter);

d6628 2
a6629 5
	/* Store a copy of %^H that pp_entereval can pick up.
	   OPf_SPECIAL flags the opcode as being for this purpose,
	   so that it in turn will return a copy at every
	   eval.*/
	OP *hhop = newSVOP(OP_CONST, OPf_SPECIAL,
d6842 1
a6842 1
	if ((PL_hints & HINT_FILETEST_ACCESS) && OP_IS_FILETEST_ACCESS(o))
d6923 4
a6926 4
		    && !kid->op_sibling && ckWARN(WARN_SYNTAX))
		    Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
			"Useless use of %s with no values",
			PL_op_desc[type]);
d6933 3
a6935 4
		    if (ckWARN2(WARN_DEPRECATED, WARN_SYNTAX))
			Perl_warner(aTHX_ packWARN2(WARN_DEPRECATED, WARN_SYNTAX),
			    "Array @@%"SVf" missing the @@ in argument %"IVdf" of %s()",
			    SVfARG(((SVOP*)kid)->op_sv), (IV)numargs, PL_op_desc[type]);
d6955 3
a6957 4
		    if (ckWARN2(WARN_DEPRECATED, WARN_SYNTAX))
			Perl_warner(aTHX_ packWARN2(WARN_DEPRECATED, WARN_SYNTAX),
			    "Hash %%%"SVf" missing the %% in argument %"IVdf" of %s()",
			    SVfARG(((SVOP*)kid)->op_sv), (IV)numargs, PL_op_desc[type]);
d7164 6
a7169 5
	gv = gv_fetchpvs("CORE::GLOBAL::glob", 0, SVt_PVCV);
	glob_gv = gv_fetchpvs("File::Glob::csh_glob", 0, SVt_PVCV);
	GvCV(gv) = GvCV(glob_gv);
	SvREFCNT_inc_void(MUTABLE_SV(GvCV(gv)));
	GvIMPORTED_CV_on(gv);
d7214 4
a7217 4
        kid = cLISTOPo->op_first->op_sibling;
	if (!cUNOPx(kid)->op_next)
	    Perl_croak(aTHX_ "panic: ck_grep");
	for (k = cUNOPx(kid)->op_first; k; k = k->op_next) {
d7245 1
a7245 1
    offset = pad_findmy("$_");
a7279 9
Perl_ck_lengthconst(pTHX_ OP *o)
{
    PERL_ARGS_ASSERT_CK_LENGTHCONST;

    /* XXX length optimization goes here */
    return ck_fun(o);
}

OP *
d7294 1
a7294 1
    if ((o->op_flags & OPf_KIDS) && ckWARN2(WARN_DEPRECATED, WARN_SYNTAX)) {
d7304 4
a7307 4
	    Perl_warner(aTHX_ packWARN2(WARN_DEPRECATED, WARN_SYNTAX),
			"defined(@@array) is deprecated");
	    Perl_warner(aTHX_ packWARN2(WARN_DEPRECATED, WARN_SYNTAX),
			"\t(Maybe you should just omit the defined()?)\n");
a7309 5
	    /* This is needed for
	       if (defined %stash::)
	       to work.   Do not break Tk.
	       */
	    break;                      /* Globals via GV can be undef */
d7311 4
a7314 4
	    Perl_warner(aTHX_ packWARN2(WARN_DEPRECATED, WARN_SYNTAX),
			"defined(%%hash) is deprecated");
	    Perl_warner(aTHX_ packWARN2(WARN_DEPRECATED, WARN_SYNTAX),
			"\t(Maybe you should just omit the defined()?)\n");
d7485 1
a7485 1
	const PADOFFSET offset = pad_findmy("$_");
d7545 3
a7547 1
	    const I32 mode = mode_from_discipline(*svp);
d7556 3
a7558 1
	    const I32 mode = mode_from_discipline(*svp);
d7684 1
a7684 1
    return ck_fun(o);
d7691 1
d7695 1
d7697 1
a7697 2
        OP *kid;
	for (kid = cLISTOPo->op_first->op_sibling; kid; kid = kid->op_sibling)
d7699 13
d7713 1
d7750 2
a7751 2
	OP *argop;
	/* FIXME - this can be refactored to reduce code in #ifdefs  */
a7753 6
#else
	op_free(o);
#endif
	argop = newUNOP(OP_RV2AV, 0,
	    scalar(newGVOP(OP_GV, 0, CvUNIQUE(PL_compcv) ? PL_argvgv : PL_defgv)));
#ifdef PERL_MAD
d7758 1
d7957 3
a7959 3
    if (((PMOP *)kid)->op_pmflags & PMf_GLOBAL && ckWARN(WARN_REGEXP)) {
      Perl_warner(aTHX_ packWARN(WARN_REGEXP),
                  "Use of /g modifier is meaningless in split");
a8023 1
	SVOP* tmpop;
d8026 21
a8046 13
	tmpop = (SVOP*)((UNOP*)cvop)->op_first;
	if (tmpop->op_type == OP_GV && !(o->op_private & OPpENTERSUB_AMPER)) {
	    GV *gv = cGVOPx_gv(tmpop);
	    cv = GvCVu(gv);
	    if (!cv)
		tmpop->op_private |= OPpEARLY_CV;
	    else {
		if (SvPOK(cv)) {
		    STRLEN len;
		    namegv = CvANON(cv) ? gv : CvGV(cv);
		    proto = SvPV(MUTABLE_SV(cv), len);
		    proto_end = proto + len;
		}
d8342 125
a8489 1
	case OP_SETSTATE:
d8499 1
d8506 1
a8506 1
		if (o->op_type == OP_CONST && SvPADTMP(cSVOPo->op_sv)) {
d8513 1
a8513 1
		else if (o->op_type == OP_CONST
d8560 1
a8560 2
		|| o->op_targ == OP_DBSTATE
		|| o->op_targ == OP_SETSTATE)
d8653 10
d8664 48
a8713 3
	case OP_AND:
	case OP_OR:
	case OP_DOR:
d8779 1
a8779 1
	    if ((!SvFAKE(sv = *svp) || !SvREADONLY(sv)) && !IS_PADCONST(sv)) {
d8907 2
a8908 56
	    if (!oright ||
		(oright->op_type != OP_RV2AV && oright->op_type != OP_PADAV)
		|| oright->op_next != o
		|| (oright->op_private & OPpLVAL_INTRO)
	    )
		break;

	    /* o2 follows the chain of op_nexts through the LHS of the
	     * assign (if any) to the aassign op itself */
	    o2 = o->op_next;
	    if (!o2 || o2->op_type != OP_NULL)
		break;
	    o2 = o2->op_next;
	    if (!o2 || o2->op_type != OP_PUSHMARK)
		break;
	    o2 = o2->op_next;
	    if (o2 && o2->op_type == OP_GV)
		o2 = o2->op_next;
	    if (!o2
		|| (o2->op_type != OP_PADAV && o2->op_type != OP_RV2AV)
		|| (o2->op_private & OPpLVAL_INTRO)
	    )
		break;
	    oleft = o2;
	    o2 = o2->op_next;
	    if (!o2 || o2->op_type != OP_NULL)
		break;
	    o2 = o2->op_next;
	    if (!o2 || o2->op_type != OP_AASSIGN
		    || (o2->op_flags & OPf_WANT) != OPf_WANT_VOID)
		break;

	    /* check that the sort is the first arg on RHS of assign */

	    o2 = cUNOPx(o2)->op_first;
	    if (!o2 || o2->op_type != OP_NULL)
		break;
	    o2 = cUNOPx(o2)->op_first;
	    if (!o2 || o2->op_type != OP_PUSHMARK)
		break;
	    if (o2->op_sibling != o)
		break;

	    /* check the array is the same on both sides */
	    if (oleft->op_type == OP_RV2AV) {
		if (oright->op_type != OP_RV2AV
		    || !cUNOPx(oright)->op_first
		    || cUNOPx(oright)->op_first->op_type != OP_GV
		    ||  cGVOPx_gv(cUNOPx(oleft)->op_first) !=
		       	cGVOPx_gv(cUNOPx(oright)->op_first)
		)
		    break;
	    }
	    else if (oright->op_type != OP_PADAV
		|| oright->op_targ != oleft->op_targ
	    )
d8935 1
d8938 27
d9158 1
d9162 1
d9167 3
d9171 1
a9171 1
    ST(0) = MUTABLE_SV(XSANY.any_ptr);
@


1.13
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
d12 7
a18 5
 * "You see: Mr. Drogo, he married poor Miss Primula Brandybuck.  She was
 * our Mr. Bilbo's first cousin on the mother's side (her mother being the
 * youngest of the Old Took's daughters); and Mr. Drogo was his second
 * cousin.  So Mr. Frodo is his first *and* second cousin, once removed
 * either way, as the saying is, if you follow me."  --the Gaffer
d95 1
a95 1
   record, with deletes written by C<Perl_magic_clearhint>. C<SAVE_HINTS>
d121 1
d133 1
a133 1
	PL_OpPtr = mmap(0, PERL_SLAB_SIZE*sizeof(I32*), PROT_READ|PROT_WRITE,
d165 1
a165 1
	PL_slabs = realloc(PL_slabs, sizeof(I32**) * (PL_slab_count + 1));
d215 3
d241 1
d254 1
d270 1
d314 3
d324 2
d334 2
d343 2
d352 2
d361 2
d379 2
a499 2
    if (type == OP_NULL)
	type = (OPCODE)o->op_targ;
d507 5
a511 1
    if (type == OP_NEXTSTATE || type == OP_SETSTATE || type == OP_DBSTATE) {
d515 3
d536 3
d558 1
a558 1
	    o->op_type = o->op_targ;
d640 1
a640 1
	SvREFCNT_dec((SV*)cPMOPo->op_pmreplrootu.op_pmtargetgv);
d648 2
a649 2
        /* we use the "SAFE" version of the PM_ macros here
         * since sv_clean_all might release some PMOPs
a653 2
	ReREFCNT_dec(PM_GETRE_SAFE(cPMOPo));
	PM_SETRE_SAFE(cPMOPo, NULL);
d656 1
d660 1
a660 1
            PM_SETRE(cPMOPo, (cPMOPo)->op_pmoffset);
d662 3
d679 2
d697 3
d701 1
a701 1
	MAGIC * const mg = mg_find((SV*)pmstash, PERL_MAGIC_symtab);
d735 2
d757 3
d794 2
d836 3
d920 1
d934 2
d992 1
d1060 1
d1680 2
d1730 2
d1769 2
d1862 2
d1893 2
d1932 2
d1994 2
d2017 1
a2017 1
						       newRV((SV*)cv)),
d2027 2
d2063 2
a2064 2
			 type == OP_RV2AV ? (SV*)GvAV(gv) :
			 type == OP_RV2HV ? (SV*)GvHV(gv) : (SV*)gv),
d2108 2
d2140 2
d2162 2
d2299 3
d2337 1
a2337 1
		XPUSHs((SV*)CopFILEGV(&PL_compiling));
d2339 1
a2339 1
		call_sv((SV*)cv, G_DISCARD);
d2349 3
d2410 2
d2424 1
a2424 1
    register OP *curop;
d2433 1
d2436 2
d2472 1
d2498 7
d2523 1
a2523 1
	sv_setpvn(ERRSV,"",0);
d2538 1
d2551 1
a2551 1
	newop = newGVOP(OP_GV, 0, (GV*)sv);
d2553 1
a2553 1
	newop = newSVOP(OP_CONST, 0, (SV*)sv);
d2739 2
d2752 3
d2767 1
a2767 1
	SvPVX((SV*)tm->mad_val)[0] == 'q')
d2918 2
d2958 1
a2958 1
	sv_free((SV*)mp->mad_val);
d3137 3
d3336 1
a3336 1
	swash = (SV*)swash_init("utf8", "", listsv, bits, none);
d3342 1
d3350 1
a3350 1
	    (void)hv_store((HV*)SvRV(swash), "FINAL", 5,
d3508 2
d3644 1
a3644 1
		     || PM_GETRE(pm)->extflags & RXf_EVAL_SEEN)))
d3680 3
d3702 3
d3727 3
a3729 1
    assert(gv);
d3769 2
d3811 2
d3932 5
a3936 1
method, similar to C<use Foo::Bar VERSION LIST>.
d3944 3
d3958 1
d3970 3
a3973 1
    OP * const modname = newSVOP(OP_CONST, 0, name);
d4017 2
d4113 1
d4131 59
d4204 1
a4204 1
	{
d4239 1
a4239 1
			    GV *const gv = (GV*)PAD_SVl(((PMOP*)curop)->op_pmreplrootu.op_pmtargetoff);
a4264 48
	if ((left->op_type == OP_LIST
	     || (left->op_type == OP_NULL && left->op_targ == OP_LIST))) {
	    OP* lop = ((LISTOP*)left)->op_first;
	    while (lop) {
		if (lop->op_type == OP_PADSV ||
		    lop->op_type == OP_PADAV ||
		    lop->op_type == OP_PADHV ||
		    lop->op_type == OP_PADANY) {
		    if (lop->op_private & OPpPAD_STATE) {
			if (left->op_private & OPpLVAL_INTRO) {
			    /* Each variable in state($a, $b, $c) = ... */
			}
			else {
			    /* Each state variable in
			       (state $a, my $b, our $c, $d, undef) = ... */
			}
			yyerror(no_list_state);
		    } else {
			/* Each my variable in
			   (state $a, my $b, our $c, $d, undef) = ... */
		    }
		} else {
		    /* Other ops in the list. undef may be interesting in
		       (state $a, undef, state $c) */
		}
		lop = lop->op_sibling;
	    }
	}
	else if (((left->op_private & (OPpLVAL_INTRO | OPpPAD_STATE))
		    == (OPpLVAL_INTRO | OPpPAD_STATE))
		&& (   left->op_type == OP_PADSV
		    || left->op_type == OP_PADAV
		    || left->op_type == OP_PADHV
		    || left->op_type == OP_PADANY))
	{
	    /* All single variable list context state assignments, hence
	       state ($a) = ...
	       (state $a) = ...
	       state @@a = ...
	       state (@@a) = ...
	       (state @@a) = ...
	       state %a = ...
	       state (%a) = ...
	       (state %a) = ...
	    */
	    yyerror(no_list_state);
	}

d4287 1
a4287 1
			    = (GV*)cSVOPx(tmpop)->op_sv;
d4306 1
a4306 1
			if (SvIVX(sv) == 0)
d4327 5
a4331 4
	    /* FIXME for MAD */
	    op_free(o);
	    o = newSVOP(OP_CONST, 0, newSViv(CopARYBASE_get(&PL_compiling)));
	    o->op_private |= OPpCONST_ARYBASE;
d4391 2
a4392 1
    if (PERLDB_LINE && PL_curstash != PL_debstash) {
d4403 2
d4413 3
d4420 41
d4466 8
a4473 2
    OP *first = *firstp;
    OP * const other = *otherp;
d4497 5
a4501 4
    if (first->op_type == OP_CONST) {
	if (first->op_private & OPpCONST_STRICT)
	    no_bareword_allowed(first);
	else if ((first->op_private & OPpCONST_BARE) && ckWARN(WARN_BAREWORD))
d4503 3
a4505 3
	if ((type == OP_AND &&  SvTRUE(((SVOP*)first)->op_sv)) ||
	    (type == OP_OR  && !SvTRUE(((SVOP*)first)->op_sv)) ||
	    (type == OP_DOR && !SvOK(((SVOP*)first)->op_sv))) {
d4625 3
d4635 1
a4635 1
    if (first->op_type == OP_CONST) {
d4637 1
a4637 1
	const bool left = SvTRUE(((SVOP*)first)->op_sv);
d4640 3
a4642 3
        if (first->op_private & OPpCONST_BARE &&
	    first->op_private & OPpCONST_STRICT) {
	    no_bareword_allowed(first);
d4691 2
d4904 2
d5025 2
d5091 2
d5094 1
a5094 1
    enterop->op_type = enter_opcode;
d5142 3
d5147 1
a5162 1
	/* Note that OP_DOR is not here */
d5187 2
d5197 3
a5199 1
		
d5210 1
a5210 1
    assert( cond );
d5225 2
d5257 2
d5284 1
a5284 1
    SvPOK_off((SV*)cv);		/* forget prototype */
d5296 1
a5296 1
	SvREFCNT_dec((SV*)CvXSUBANY(cv).any_ptr);
d5310 2
d5363 1
a5363 1
    return CvCONST(cv) ? (SV*)CvXSUBANY(cv).any_ptr : NULL;
d5535 2
a5536 1
	    if (!SvPOK((SV*)gv) && !(SvIOK((SV*)gv) && SvIVX((SV*)gv) == -1)
d5541 1
a5541 1
	    cv_ckproto_len((CV*)gv, NULL, ps, ps_len);
d5544 1
a5544 1
	    sv_setpvn((SV*)gv, ps, ps_len);
d5546 1
a5546 1
	    sv_setiv((SV*)gv, -1);
d5633 1
a5633 1
	    sv_setpvn((SV*)cv, "", 0);  /* prototype is "" */
d5669 1
a5669 1
	    rcv = (SV*)cv;
d5681 1
a5681 1
	    rcv = (SV*)PL_compcv;
d5727 1
a5727 1
		    PL_formfeed = (SV*)cv;
d5740 1
a5740 1
	sv_setpvn((SV*)cv, ps, ps_len);
d5765 6
d5829 1
a5829 1
		    call_sv((SV*)pcv, G_DISCARD);
d5852 2
d5862 1
a5862 1
	    Perl_av_create_and_push(aTHX_ &PL_beginav, (SV*)cv);
d5876 1
a5876 1
		Perl_av_create_and_unshift_one(aTHX_ &PL_endav, (SV*)cv);
d5882 1
a5882 1
		Perl_av_create_and_unshift_one(aTHX_ &PL_unitcheckav, (SV*)cv);
d5891 1
a5891 1
		Perl_av_create_and_unshift_one(aTHX_ &PL_checkav, (SV*)cv);
d5900 1
a5900 1
		Perl_av_create_and_push(aTHX_ &PL_initav, (SV*)cv);
d5926 1
a5926 2
    const char *const temp_p = CopFILE(PL_curcop);
    const STRLEN len = temp_p ? strlen(temp_p) : 0;
d5929 1
a5929 2
    STRLEN len;
    const char *const temp_p = temp_sv ? SvPV_const(temp_sv, len) : NULL;
a5930 1
    char *const file = savepvn(temp_p, temp_p ? len : 0);
d5958 2
a5959 1
    cv = newXS_flags(name, const_sv_xsub, file, "", XS_DYNAMIC_FILENAME);
a5961 1
    Safefree(file);
d5979 2
d6003 1
a6003 1
	sv_usepvn_flags((SV*)cv, proto_and_file, proto_and_file_len,
d6014 1
a6014 1
	sv_setpv((SV *)cv, proto);
d6037 2
d6078 1
a6078 1
	cv = (CV*)newSV_type(SVt_PVCV);
d6128 7
a6134 3
	    Perl_warner(aTHX_ packWARN(WARN_REDEFINE),
			o ? "Format %"SVf" redefined"
			: "Format STDOUT redefined", SVfARG(cSVOPo->op_sv));
d6189 1
a6189 1
		(SV*)newATTRSUB(floor, 0, proto, attrs, block)));
d6196 3
d6223 3
d6252 3
d6280 3
d6306 3
d6323 2
d6335 3
d6372 2
d6375 1
d6386 3
d6417 2
d6447 2
d6460 2
d6482 3
d6512 2
d6542 1
a6542 1
			   (SV*)Perl_hv_copy_hints_hv(aTHX_ GvHV(PL_hintgv)));
d6552 2
d6569 2
d6587 3
d6604 1
a6604 1
	    Perl_croak(aTHX_ "%s argument is not a HASH or ARRAY element",
d6617 2
d6718 1
a6718 1
	    PAD_SETSV(kPADOP->op_padix, (SV*) SvREFCNT_inc_simple_NN(gv));
d6735 2
d6782 2
d6998 1
a6998 1
				    sv_setpvn(namesv, "$", 1);
d7059 2
d7081 1
a7081 1
	SvREFCNT_inc_void((SV*)GvCV(gv));
d7119 2
d7180 2
d7195 2
d7205 3
d7214 2
d7254 2
d7273 3
d7284 2
d7344 3
d7408 3
d7427 3
d7456 1
d7466 3
d7526 2
d7543 2
d7614 3
d7630 3
d7655 2
d7684 2
d7767 3
d7841 2
d7898 3
d7904 2
a7905 2
	    const char *pmstr = re ? re->precomp : "STRING";
	    const STRLEN len = re ? re->prelen : 6;
d7932 2
d7950 1
a7950 1
		    proto = SvPV((SV*)cv, len);
d8072 1
a8072 1
			 while (*--p != '[');
d8173 1
d8198 2
d8219 3
d8233 2
d8807 1
a8807 1
	    if ((o->op_flags && OPf_WANT) != OPf_WANT_VOID)
d8867 2
d8889 2
d8919 1
a8919 1
    ST(0) = (SV*)XSANY.any_ptr;
@


1.12
log
@merge in perl 5.8.8
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, by Larry Wall and others
d76 22
d107 5
d117 1
a117 1
Perl_Slab_Alloc(pTHX_ int m, size_t sz)
d127 17
a143 1
        PL_OpPtr = (I32 **) PerlMemShared_malloc(PERL_SLAB_SIZE*sizeof(I32*)); 
a146 1
	Zero(PL_OpPtr,PERL_SLAB_SIZE,I32 **);
d158 8
d178 64
d250 1
d256 24
d281 1
d289 1
a289 1
 * In the following definition, the ", Nullop" is just to make the compiler
d293 1
a293 1
    ((PL_op_mask && PL_op_mask[type])					\
d296 1
a296 1
	 Nullop )						\
d305 1
a305 1
    gv_efullname3(tmpsv, gv, Nullch);
d335 1
a335 1
		 (int)n, name, t, OP_DESC((OP *)kid)));
d341 2
d345 1
a345 1
		     cSVOPo_sv));
d351 1
a351 1
Perl_allocmy(pTHX_ char *name)
d353 1
d355 1
d357 3
a359 2
    /* complain about "my $_" etc etc */
    if (!(PL_in_my == KEY_our ||
d362 1
a362 1
	  (name[1] == '_' && (int)strlen(name) > 2)))
d364 1
d366 6
a371 17
	    /* 1999-02-27 mjd@@plover.com */
	    char *p;
	    p = strchr(name, '\0');
	    /* The next block assumes the buffer is at least 205 chars
	       long.  At present, it's always at least 256 chars. */
	    if (p-name > 200) {
		strcpy(name+200, "...");
		p = name+199;
	    }
	    else {
		p[1] = '\0';
	    }
	    /* Move everything else down one character */
	    for (; p-name > 2; p--)
		*p = *(p-1);
	    name[2] = toCTRL(name[1]);
	    name[1] = '^';
a372 1
	yyerror(Perl_form(aTHX_ "Can't use global %s in \"my\"",name));
d374 1
d376 1
a376 4
    pad_check_dup(name,
		(bool)(PL_in_my == KEY_our),
		(PL_curstash ? PL_curstash : PL_defstash)
    );
d378 1
a378 1
    if (PL_in_my_stash && *name != '$') {
d381 3
a383 1
		     name, PL_in_my == KEY_our ? "our" : "my"));
d389 5
a393 4
		    PL_in_my_stash,
		    (PL_in_my == KEY_our 
			? (PL_curstash ? PL_curstash : PL_defstash)
			: Nullhv
d395 2
a396 1
		    0 /*  not fake */
d398 6
d407 2
d410 2
a411 4
#ifdef USE_5005THREADS
/* find_threadsv is not reentrant */
PADOFFSET
Perl_find_threadsv(pTHX_ const char *name)
d413 3
a415 57
    char *p;
    PADOFFSET key;
    SV **svp;
    /* We currently only handle names of a single character */
    p = strchr(PL_threadsv_names, *name);
    if (!p)
	return NOT_IN_PAD;
    key = p - PL_threadsv_names;
    MUTEX_LOCK(&thr->mutex);
    svp = av_fetch(thr->threadsv, key, FALSE);
    if (svp)
	MUTEX_UNLOCK(&thr->mutex);
    else {
	SV *sv = NEWSV(0, 0);
	av_store(thr->threadsv, key, sv);
	thr->threadsvp = AvARRAY(thr->threadsv);
	MUTEX_UNLOCK(&thr->mutex);
	/*
	 * Some magic variables used to be automagically initialised
	 * in gv_fetchpv. Those which are now per-thread magicals get
	 * initialised here instead.
	 */
	switch (*name) {
	case '_':
	    break;
	case ';':
	    sv_setpv(sv, "\034");
	    sv_magic(sv, 0, PERL_MAGIC_sv, name, 1);
	    break;
	case '&':
	case '`':
	case '\'':
	    PL_sawampersand = TRUE;
	    /* FALL THROUGH */
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	    SvREADONLY_on(sv);
	    /* FALL THROUGH */

	/* XXX %! tied to Errno.pm needs to be added here.
	 * See gv_fetchpv(). */
	/* case '!': */

	default:
	    sv_magic(sv, 0, PERL_MAGIC_sv, name, 1);
	}
	DEBUG_S(PerlIO_printf(Perl_error_log,
			      "find_threadsv: new SV %p for $%s%c\n",
			      sv, (*name < 32) ? "^" : "",
			      (*name < 32) ? toCTRL(*name) : *name));
d417 1
a417 1
    return key;
d419 6
a424 1
#endif /* USE_5005THREADS */
d431 1
a432 1
    PADOFFSET refcnt;
d434 1
a434 1
    if (!o || o->op_seq == (U16)-1)
d436 5
d442 1
d444 1
a444 1
	switch (o->op_type) {
d451 2
d456 4
a459 1
	    if (refcnt)
d461 2
a475 1
    type = o->op_type;
d479 4
d485 1
a485 1
    if (type == OP_NEXTSTATE || type == OP_SETSTATE || type == OP_DBSTATE)
d487 1
d490 5
d496 4
d506 17
d525 5
a530 3
#ifdef USE_5005THREADS
    case OP_THREADSV:	/* Was holding index into thr->threadsv AV. */
#endif
a532 6
#ifdef USE_5005THREADS
    case OP_ENTERITER:
	if (!(o->op_flags & OPf_SPECIAL))
	    break;
	/* FALL THROUGH */
#endif /* USE_5005THREADS */
d552 1
a552 1
	    cSVOPo->op_sv = Nullsv;
d559 1
a559 1
	cSVOPo->op_sv = Nullsv;
d582 6
d589 2
a590 1
	    cSVOPo->op_sv = Nullsv;
d593 2
a594 2
	    Safefree(cPVOPo->op_pv);
	    cPVOPo->op_pv = Nullch;
d598 1
a598 1
	op_free(cPMOPo->op_pmreplroot);
d602 1
a602 1
        if (INT2PTR(PADOFFSET, cPMOPo->op_pmreplroot)) {
d605 1
a605 1
	    pad_swipe(INT2PTR(PADOFFSET, cPMOPo->op_pmreplroot), TRUE);
d608 1
a608 1
	SvREFCNT_dec((SV*)cPMOPo->op_pmreplroot);
d614 2
a615 20
	{
	    HV * const pmstash = PmopSTASH(cPMOPo);
	    if (pmstash && SvREFCNT(pmstash)) {
		PMOP *pmop = HvPMROOT(pmstash);
		PMOP *lastpmop = NULL;
		while (pmop) {
		    if (cPMOPo == pmop) {
			if (lastpmop)
			    lastpmop->op_pmnext = pmop->op_pmnext;
			else
			    HvPMROOT(pmstash) = pmop->op_pmnext;
			break;
		    }
		    lastpmop = pmop;
		    pmop = pmop->op_pmnext;
		}
	    }
	    PmopSTASH_free(cPMOPo);
	}
	cPMOPo->op_pmreplroot = Nullop;
d623 1
a623 1
	PM_SETRE_SAFE(cPMOPo, (REGEXP*)NULL);
d627 1
d645 1
a645 1
    Safefree(cop->cop_label);   /* FIXME: treaddead ??? */
d649 6
a654 2
	SvREFCNT_dec(cop->cop_warnings);
    if (! specialCopIO(cop->cop_io)) {
d656 1
a656 4
#if 0
	STRLEN len;
        char *s = SvPV(cop->cop_io,len);
	Perl_warn(aTHX_ "io='%.*s'",(int) len,s); /* ??? --jhi */
d658 32
a689 2
#else
	SvREFCNT_dec(cop->cop_io);
d691 18
d715 1
d718 2
a719 1
    op_clear(o);
d728 2
d736 2
d748 1
d754 2
a755 1
    if (cUNOPo->op_first) {
d757 4
a760 3
	o->op_next = LINKLIST(cUNOPo->op_first);
	for (kid = cUNOPo->op_first; kid; kid = kid->op_sibling) {
	    if (kid->op_sibling)
d762 2
a763 1
	    else
d765 2
d789 1
d794 2
a795 2
	    if (PL_copline != NOLINE)
		CopLINE_set(PL_curcop, PL_copline);
d806 1
d810 2
a811 1
    if (!o || PL_error_count || (o->op_flags & OPf_WANT)
d831 1
a831 1
	    if (!kPMOP->op_pmreplroot)
d855 1
a855 1
	WITH_THR(PL_curcop = &PL_compiling);
d866 1
a866 1
	WITH_THR(PL_curcop = &PL_compiling);
d878 1
d880 1
a880 1
    const char* useless = 0;
d884 15
d909 2
a910 1
    if ((want && want != OPf_WANT_SCALAR) || PL_error_count
d1010 9
d1035 2
d1040 1
a1040 1
		    useless = 0;
d1045 1
a1045 1
		    useless = 0;
d1053 5
a1057 4
		    if (strnEQ(SvPVX_const(sv), "di", 2) ||
			strnEQ(SvPVX_const(sv), "ds", 2) ||
			strnEQ(SvPVX_const(sv), "ig", 2))
			    useless = 0;
d1086 1
d1088 2
d1111 2
d1127 1
a1127 1
	    if (!kPMOP->op_pmreplroot)
d1151 1
d1155 2
a1156 1
    if (!o || (o->op_flags & OPf_WANT) || PL_error_count
d1205 1
a1205 1
	WITH_THR(PL_curcop = &PL_compiling);
d1215 1
a1215 1
	WITH_THR(PL_curcop = &PL_compiling);
d1228 1
d1230 4
a1233 4
	if (o->op_type == OP_LINESEQ ||
	     o->op_type == OP_SCOPE ||
	     o->op_type == OP_LEAVE ||
	     o->op_type == OP_LEAVETRY)
d1263 11
d1277 1
d1279 2
d1282 1
a1282 1
    if (!o || PL_error_count)
d1293 1
d1297 1
a1297 1
	if (!(o->op_private & (OPpCONST_ARYBASE)))
d1299 1
d1301 2
a1302 1
	    PL_compiling.cop_arybase = (I32)SvIV(cSVOPx(PL_eval_start)->op_sv);
d1306 2
a1307 2
	    SAVEI32(PL_compiling.cop_arybase);
	    PL_compiling.cop_arybase = 0;
d1315 1
a1315 1
	if (o->op_flags & OPf_PARENS)
d1322 4
d1346 8
a1353 9
		if (kid->op_type == OP_PUSHMARK)
		    goto skip_kids;
		if (kid->op_type != OP_NULL || kid->op_targ != OP_LIST)
		    Perl_croak(aTHX_
			       "panic: unexpected lvalue entersub "
			       "args: type/targ %ld:%"UVuf,
			       (long)kid->op_type, (UV)kid->op_targ);
		kid = kLISTOP->op_first;
	      skip_kids:
d1366 1
a1366 1
			newop->op_first = Nullop;
d1370 1
d1400 1
a1400 1
			okid->op_next = Nullop;
d1405 1
d1457 1
d1478 1
d1487 1
d1495 4
d1500 1
a1500 3
	/* Needed if maint gets patch 19588
	   localize = -1;
	*/
d1516 1
a1516 5
	if (!type)
	{   /* XXX DAPM 2002.08.25 tmp assert test */
	    /* XXX */ assert(av_fetch(PL_comppad_name, (o->op_targ), FALSE));
	    /* XXX */ assert(*av_fetch(PL_comppad_name, (o->op_targ), FALSE));

a1518 1
	}
a1520 6
#ifdef USE_5005THREADS
    case OP_THREADSV:
	PL_modcount++;	/* XXX ??? */
	break;
#endif /* USE_5005THREADS */

d1522 1
d1553 1
d1561 1
d1567 1
d1578 1
d1601 15
a1615 4
    else if (!type) {
	o->op_private |= OPpLVAL_INTRO;
	o->op_flags &= ~OPf_SPECIAL;
	PL_hints |= HINT_BLOCK_SCOPE;
d1624 1
a1624 1
S_scalar_mod_type(pTHX_ const OP *o, I32 type)
d1664 1
d1672 1
a1672 1
S_is_handle_constructor(pTHX_ const OP *o, I32 numargs)
d1688 1
a1688 1
	/* FALL THROUGH */
d1706 1
a1706 1
Perl_ref(pTHX_ OP *o, I32 type)
d1708 1
d1711 1
a1711 1
    if (!o || PL_error_count)
d1723 1
d1729 1
a1729 1
	    ref(kid, type);
d1734 1
a1734 1
	ref(cUNOPo->op_first, o->op_type);
a1744 4
    case OP_THREADSV:
	o->op_flags |= OPf_MOD;		/* XXX ??? */
	break;

d1747 2
a1748 1
	o->op_flags |= OPf_REF;
d1753 1
a1753 1
	ref(cUNOPo->op_first, o->op_type);
d1758 2
a1759 1
	o->op_flags |= OPf_REF;
d1766 1
a1766 1
	ref(cBINOPo->op_first, type);
d1770 1
a1770 1
	ref(cBINOPo->op_first, o->op_type);
d1781 2
d1787 1
a1787 1
	ref(cLISTOPo->op_last, type);
d1799 2
a1800 1
    OP *rop = Nullop;
d1807 5
a1811 1
	rop = newSVOP(OP_CONST, o->op_flags, SvREFCNT_inc(cSVOPo->op_sv));
d1814 1
d1819 1
a1819 1
					  SvREFCNT_inc(cSVOPo->op_sv)));
d1828 1
d1833 1
a1833 5
    SAVEINT(PL_expect);
    if (stash)
	stashsv = newSVpv(HvNAME_get(stash), 0);
    else
	stashsv = &PL_sv_no;
d1840 1
a1840 2
	SV * const * const svp = hv_fetch(GvHVn(PL_incgv), ATTRSMODULE_PM,
		       sizeof(ATTRSMODULE_PM)-1, 0);
d1842 1
a1842 1
	    ; 		/* already in %INC */
d1845 1
a1845 2
			     newSVpvn(ATTRSMODULE, sizeof(ATTRSMODULE)-1),
			     Nullsv);
d1849 2
a1850 2
			 newSVpvn(ATTRSMODULE, sizeof(ATTRSMODULE)-1),
			 Nullsv,
d1864 1
d1879 1
a1879 1
    pack = newSVOP(OP_CONST, 0, newSVpvn(ATTRSMODULE, sizeof(ATTRSMODULE)-1));
d1882 2
a1883 4
    if (stash)
	stashsv = newSVpv(HvNAME_get(stash), 0);
    else
	stashsv = &PL_sv_no;
d1894 1
a1894 8
    meth = newSVpvn("import", 6);
    (void)SvUPGRADE(meth, SVt_PVIV);
    (void)SvIOK_on(meth);
    {
	U32 hash;
	PERL_HASH(hash, SvPVX_const(meth), SvCUR(meth));
	SvUV_set(meth, hash);
    }
d1923 2
a1924 2
Perl_apply_attrs_string(pTHX_ char *stashpv, CV *cv,
                        char *attrstr, STRLEN len)
d1926 1
a1926 1
    OP *attrs = Nullop;
d1944 2
a1945 2
                     newSVpvn(ATTRSMODULE, sizeof(ATTRSMODULE)-1),
                     Nullsv, prepend_elem(OP_LIST,
d1956 1
d1959 1
a1959 1
    if (!o || PL_error_count)
d1963 5
d1972 5
a1976 1
    } else if (type == OP_UNDEF) {
d1982 5
a1986 2
	    yyerror(Perl_form(aTHX_ "Can't declare %s in %s",
			OP_DESC(o), PL_in_my == KEY_our ? "our" : "my"));
d1989 2
a1990 2
	    PL_in_my = FALSE;
	    PL_in_my_stash = Nullhv;
d2007 3
a2009 1
			  PL_in_my == KEY_our ? "our" : "my"));
d2015 2
a2016 2
	PL_in_my = FALSE;
	PL_in_my_stash = Nullhv;
d2026 2
d2034 2
a2035 1
    OP *rops = Nullop;
d2050 1
d2060 2
a2061 2
    PL_in_my = FALSE;
    PL_in_my_stash = Nullhv;
d2068 1
a2068 1
    return my_attrs(o, Nullop);
d2074 1
d2084 3
d2088 2
a2089 5
    if ( (left->op_type == OP_RV2AV ||
       left->op_type == OP_RV2HV ||
       left->op_type == OP_PADAV ||
       left->op_type == OP_PADHV)
       && ckWARN(WARN_MISC))
d2091 5
a2095 6
      const char * const desc = PL_op_desc[(right->op_type == OP_SUBST ||
                            right->op_type == OP_TRANS)
                           ? right->op_type : OP_MATCH];
      const char * const sample = ((left->op_type == OP_RV2AV ||
			     left->op_type == OP_PADAV)
			    ? "@@array" : "%hash");
d2101 1
a2101 1
    if (right->op_type == OP_CONST &&
d2108 10
a2117 4
    if (!(right->op_flags & OPf_STACKED) &&
       (right->op_type == OP_MATCH ||
	right->op_type == OP_SUBST ||
	right->op_type == OP_TRANS)) {
d2119 2
a2120 2
	if (right->op_type != OP_MATCH &&
            ! (right->op_type == OP_TRANS &&
d2122 3
a2124 1
	    left = mod(left, right->op_type);
d2126 1
a2126 1
	    o = newBINOP(OP_NULL, OPf_STACKED, scalar(left), right);
d2128 1
a2128 1
	    o = prepend_elem(right->op_type, scalar(left), right);
d2135 1
a2135 1
		pmruntime(newPMOP(OP_MATCH, 0), right, Nullop));
d2142 1
a2142 2
	return o;
    /* XXX need to optimize away NOT NOT here?  Or do we let optimizer do it? */
d2149 1
d2172 1
a2172 1
	    o = newLISTOP(OP_SCOPE, 0, o, Nullop);
d2176 1
a2176 8

/* XXX kept for BINCOMPAT only */
void
Perl_save_hints(pTHX)
{
    Perl_croak(aTHX_ "internal error: obsolete function save_hints() called");
}

d2180 1
a2181 3
    /* If there were syntax errors, don't try to start a block */
    if (PL_yynerrs) return retval;

d2185 2
a2186 10
    SAVESPTR(PL_compiling.cop_warnings);
    if (! specialWARN(PL_compiling.cop_warnings)) {
        PL_compiling.cop_warnings = newSVsv(PL_compiling.cop_warnings) ;
        SAVEFREESV(PL_compiling.cop_warnings) ;
    }
    SAVESPTR(PL_compiling.cop_io);
    if (! specialCopIO(PL_compiling.cop_io)) {
        PL_compiling.cop_io = newSVsv(PL_compiling.cop_io) ;
        SAVEFREESV(PL_compiling.cop_io) ;
    }
d2193 1
a2195 2
    /* If there were syntax errors, don't try to close a block */
    if (PL_yynerrs) return retval;
d2197 1
a2197 1
    PL_compiling.op_private = (U8)(PL_hints & HINT_PRIVATE_MASK);
d2207 10
a2216 7
#ifdef USE_5005THREADS
    OP *const o = newOP(OP_THREADSV, 0);
    o->op_targ = find_threadsv("_");
    return o;
#else
    return newSVREF(newGVOP(OP_GV, 0, PL_defgv));
#endif /* USE_5005THREADS */
d2222 1
d2239 1
a2239 1
	    FreeOp(o);
d2253 2
a2254 1
	    CV * const cv = get_cv("DB::postponed", FALSE);
d2269 1
d2276 1
a2276 1
	;
d2279 2
a2280 1
	if ( PL_bufptr > PL_oldbufptr && PL_bufptr[-1] == ','
d2283 1
a2283 1
	    char *s = PL_bufptr;
d2306 7
a2312 2
				lex ? (PL_in_my == KEY_our ? "our" : "my")
				: "local");
d2320 2
a2321 2
    PL_in_my = FALSE;
    PL_in_my_stash = Nullhv;
d2329 2
a2330 7
	OP *o2;
#ifdef USE_5005THREADS
	o2 = newOP(OP_THREADSV, 0);
	o2->op_targ = find_threadsv(";");
#else
	o2 = newSVREF(newGVOP(OP_GV, 0, gv_fetchpv(";", TRUE, SVt_PV))),
#endif /* USE_5005THREADS */
d2339 1
d2341 9
a2349 2
    I32 type = o->op_type;
    SV *sv;
d2387 1
a2387 1
    if (PL_error_count)
d2391 6
a2396 6
	if ((curop->op_type != OP_CONST ||
	     (curop->op_private & OPpCONST_BARE)) &&
	    curop->op_type != OP_LIST &&
	    curop->op_type != OP_SCALAR &&
	    curop->op_type != OP_NULL &&
	    curop->op_type != OP_PUSHMARK)
d2403 1
d2406 45
a2450 8
    CALLRUNOPS(aTHX);
    sv = *(PL_stack_sp--);
    if (o->op_targ && sv == PAD_SV(o->op_targ))	/* grab pad temp? */
	pad_swipe(o->op_targ,  FALSE);
    else if (SvTEMP(sv)) {			/* grab mortal temp? */
	(void)SvREFCNT_inc(sv);
	SvTEMP_off(sv);
    }
d2452 2
d2455 5
a2459 2
	return newGVOP(OP_GV, 0, (GV*)sv);
    return newSVOP(OP_CONST, 0, sv);
d2461 1
a2461 1
  nope:
d2468 1
d2473 1
a2473 1
    if (PL_error_count)
d2482 2
d2491 1
a2491 1
    o->op_seq = 0;		/* needs to be revisited in peep() */
d2493 4
a2496 1
    ((UNOP*)o)->op_first = newSVOP(OP_CONST, 0, SvREFCNT_inc(*PL_stack_sp--));
d2498 1
d2506 1
d2508 1
a2508 1
	o = newLISTOP(OP_LIST, 0, o, Nullop);
d2572 17
a2588 1
    FreeOp(last);
d2626 12
a2637 4
OP *
Perl_newNULLLIST(pTHX)
{
    return newOP(OP_STUB, 0);
d2640 2
a2641 2
OP *
Perl_force_list(pTHX_ OP *o)
d2643 4
a2646 4
    if (!o || o->op_type != OP_LIST)
	o = newLISTOP(OP_LIST, 0, o, Nullop);
    op_null(o);
    return o;
d2649 2
a2650 2
OP *
Perl_newLISTOP(pTHX_ I32 type, I32 flags, OP *first, OP *last)
d2652 10
a2661 1
    LISTOP *listop;
d2663 225
a2887 1
    NewOp(1101, listop, 1, LISTOP);
d2918 1
d2924 3
d2940 1
d2964 1
d2993 4
a2996 1
static int uvcompare(const void *a, const void *b) __attribute__nonnull__(1) __attribute__nonnull__(2) __attribute__pure__;
d3013 1
d3015 6
a3020 1
    SV * const rstr = ((SVOP*)repl)->op_sv;
d3033 1
d3043 2
a3044 2
	SV* const listsv = newSVpvn("# comment\n",10);
	SV* transv = 0;
d3064 1
d3068 1
a3068 1
	    t = tsave = bytes_to_utf8((U8 *)t, &len);
d3073 1
a3073 1
	    r = rsave = bytes_to_utf8((U8 *)r, &len);
d3089 1
a3089 1
	    transv = newSVpvn("",0);
d3091 1
a3091 1
		cp[2*i] = utf8n_to_uvuni((U8 *)t, tend-t, &ulen, 0);
d3095 1
a3095 1
		    cp[2*i+1] = utf8n_to_uvuni((U8 *)t, tend-t, &ulen, 0);
d3149 1
a3149 1
		tfirst = (I32)utf8n_to_uvuni((U8 *)t, tend - t, &ulen, 0);
d3153 1
a3153 1
		    tlast = (I32)utf8n_to_uvuni((U8 *)t, tend - t, &ulen, 0);
d3163 1
a3163 1
		    rfirst = (I32)utf8n_to_uvuni((U8 *)r, rend - r, &ulen, 0);
d3167 1
a3167 2
			rlast = (I32)utf8n_to_uvuni((U8 *)r, rend - r, &ulen,
						    0);
d3227 12
a3238 2
	Safefree(cPVOPo->op_pv);
	cSVOPo->op_sv = (SV*)swash_init("utf8", "", listsv, bits, none);
d3240 1
a3240 2
	if (transv)
	    SvREFCNT_dec(transv);
d3243 1
a3243 1
	    (void)hv_store((HV*)SvRV((cSVOPo->op_sv)), "FINAL", 5,
d3249 2
a3250 4
	if (tsave)
	    Safefree(tsave);
	if (rsave)
	    Safefree(rsave);
d3252 4
d3258 1
d3292 7
a3298 2
	    else
		cPVOPo->op_pv = (char*)Renew(tbl, 0x101+rlen-j, short);
d3333 4
d3339 1
d3347 1
d3357 1
a3357 1
	pmop->op_pmpermflags |= PMf_RETAINT;
d3359 2
a3360 2
	pmop->op_pmpermflags |= PMf_LOCALE;
    pmop->op_pmflags = pmop->op_pmpermflags;
d3370 1
a3370 1
	av_push(PL_regex_padav,SvREFCNT_inc(repointer));
a3375 7
        /* link into pm list */
    if (type != OP_TRANS && PL_curstash) {
	pmop->op_pmnext = HvPMROOT(PL_curstash);
	HvPMROOT(PL_curstash) = pmop;
	PmopSTASH_set(pmop,PL_curstash);
    }

d3379 12
d3392 1
a3392 1
Perl_pmruntime(pTHX_ OP *o, OP *expr, OP *repl)
d3394 1
d3398 13
d3412 12
a3423 1
    if (o->op_type == OP_TRANS)
d3425 5
d3435 2
a3436 5
	STRLEN plen;
	SV *pat = ((SVOP*)expr)->op_sv;
	const char *p = SvPV_const(pat, plen);
	if ((o->op_flags & OPf_SPECIAL) && (*p == ' ' && p[1] == '\0')) {
	    U32 was_readonly = SvREADONLY(pat);
d3438 2
a3439 9
	    if (was_readonly) {
		if (SvFAKE(pat)) {
		    sv_force_normal_flags(pat, 0);
		    assert(!SvREADONLY(pat));
		    was_readonly = 0;
		} else {
		    SvREADONLY_off(pat);
		}
	    }   
d3441 2
a3442 1
	    sv_setpvn(pat, "\\s+", 3);
d3444 1
a3444 1
	    SvFLAGS(pat) |= was_readonly;
d3446 3
a3448 9
	    p = SvPV_const(pat, plen);
	    pm->op_pmflags |= PMf_SKIPWHITE;
	}
        if (DO_UTF8(pat))
	    pm->op_pmdynflags |= PMdf_UTF8;
	/* FIXME - can we make this function take const char * args?  */
	PM_SETRE(pm, CALLREGCOMP(aTHX_ (char*)p, (char*)p + plen, pm));
	if (strEQ("\\s+", PM_GETRE(pm)->precomp))
	    pm->op_pmflags |= PMf_WHITE;
d3450 1
d3462 3
a3464 3
	rcop->op_flags |= ((PL_hints & HINT_RE_EVAL)
			   ? (OPf_SPECIAL | OPf_KIDS)
			   : OPf_KIDS);
d3467 5
d3490 3
a3492 10
	    curop = 0;
	    if (CopLINE(PL_curcop) < (line_t)PL_multi_end)
		CopLINE_set(PL_curcop, (line_t)PL_multi_end);
	}
#ifdef USE_5005THREADS
	else if (repl->op_type == OP_THREADSV
		 && strchr("&`'123456789+",
			   PL_threadsv_names[repl->op_targ]))
	{
	    curop = 0;
a3493 1
#endif /* USE_5005THREADS */
d3497 1
a3497 1
	    OP *lastop = 0;
d3499 3
a3501 8
		if (PL_opargs[curop->op_type] & OA_DANGEROUS) {
#ifdef USE_5005THREADS
		    if (curop->op_type == OP_THREADSV) {
			repl_has_vars = 1;
			if (strchr("&`'123456789+", curop->op_private))
			    break;
		    }
#else
d3503 1
a3503 1
			GV *gv = cGVOPx_gv(curop);
a3507 1
#endif /* USE_5005THREADS */
d3520 2
a3521 1
			     curop->op_type == OP_PADANY) {
d3525 1
a3525 1
			; /* Okay here, dangerous in newASSIGNOP */
d3535 2
a3536 1
		     || PM_GETRE(pm)->reganch & ROPT_EVAL_SEEN))) {
a3537 1
	    pm->op_pmpermflags |= PMf_CONST;	/* const for long enough */
a3542 1
		pm->op_pmpermflags |= PMf_MAYBE_CONST;
d3556 3
a3558 2
	    pm->op_pmreplroot = scalar((OP*)rcop);
	    pm->op_pmreplstart = LINKLIST(rcop);
d3569 1
d3584 1
d3588 1
d3596 2
a3597 2
    if (sv)
	SvPADTMP_on(sv);
d3606 1
d3611 2
d3614 2
a3615 3
    if (gv)
	GvIN_PAD_on(gv);
    return newPADOP(type, flags, SvREFCNT_inc(gv));
d3617 1
a3617 1
    return newSVOP(type, flags, SvREFCNT_inc(gv));
d3624 1
d3639 3
d3643 1
d3646 5
a3650 1
    SV *sv;
d3654 13
a3666 7
    if (o) {
	STRLEN len;
	const char *name;
	sv = cSVOPo->op_sv;
	name = SvPV_const(sv, len);
	PL_curstash = gv_stashpvn(name,len,TRUE);
	sv_setpvn(PL_curstname, name, len);
d3668 1
d3670 5
a3674 8
    else {
	deprecate("\"package\" with no arguments");
	sv_setpv(PL_curstname,"<none>");
	PL_curstash = Nullhv;
    }
    PL_hints |= HINT_BLOCK_SCOPE;
    PL_copline = NOLINE;
    PL_expect = XSTATE;
d3677 3
d3681 1
d3684 1
d3688 3
d3695 4
a3698 1
    veop = Nullop;
d3703 2
d3719 1
a3719 8
	    meth = newSVpvn("VERSION",7);
	    sv_upgrade(meth, SVt_PVIV);
	    (void)SvIOK_on(meth);
	    {
		U32 hash;
		PERL_HASH(hash, SvPVX_const(meth), SvCUR(meth));
		SvUV_set(meth, hash);
	    }
d3728 3
a3730 1
    if (arg && arg->op_type == OP_STUB)
d3732 1
d3734 3
a3736 1
	imop = Nullop;		/* use 5.0; */
d3741 3
d3748 2
a3749 8
	meth = aver ? newSVpvn("import",6) : newSVpvn("unimport", 8);
	(void)SvUPGRADE(meth, SVt_PVIV);
	(void)SvIOK_on(meth);
	{
	    U32 hash;
	    PERL_HASH(hash, SvPVX_const(meth), SvCUR(meth));
	    SvUV_set(meth, hash);
	}
d3758 3
a3760 3
	newSVOP(OP_CONST, 0, newSVpvn("BEGIN", 5)),
	Nullop,
	Nullop,
d3763 3
a3765 3
	        newSTATEOP(0, Nullch, newUNOP(OP_REQUIRE, 0, idop)),
	        newSTATEOP(0, Nullch, veop)),
	    newSTATEOP(0, Nullch, imop) ));
d3785 2
a3786 2
    PL_copline = NOLINE;
    PL_expect = XSTATE;
d3788 9
d3839 1
d3848 1
a3848 1
	veop = Nullop;
d3857 1
a3857 1
	imop = Nullop;
a3863 4
    {
	const line_t ocopline = PL_copline;
	COP * const ocurcop = PL_curcop;
	const int oexpect = PL_expect;
d3865 12
a3876 6
	utilize(!(flags & PERL_LOADMOD_DENY), start_subparse(FALSE, 0),
		veop, modname, imop);
	PL_expect = oexpect;
	PL_copline = ocopline;
	PL_curcop = ocurcop;
    }
d3880 1
a3880 1
Perl_dofile(pTHX_ OP *term)
d3882 1
d3884 1
a3884 1
    GV *gv;
d3886 7
a3892 3
    gv = gv_fetchpv("do", FALSE, SVt_PVCV);
    if (!(gv && GvCVu(gv) && GvIMPORTED_CV(gv)))
	gv = gv_fetchpv("CORE::GLOBAL::do", FALSE, SVt_PVCV);
d3898 1
a3898 2
							  newGVOP(OP_GV, 0,
								  gv))))));
d3917 3
d3923 1
a3923 1
    if (o->op_type == OP_NULL && o->op_flags & OPf_KIDS)
d3926 3
a3928 1
    if (o->op_type == OP_COND_EXPR) {
d3939 2
a3940 2
    if (o->op_type == OP_LIST &&
	(o->op_flags & OPf_WANT) == OPf_WANT_SCALAR &&
d3944 3
a3946 3
    if (o->op_type == OP_LIST || o->op_flags & OPf_PARENS ||
	o->op_type == OP_RV2AV || o->op_type == OP_RV2HV ||
	o->op_type == OP_ASLICE || o->op_type == OP_HSLICE)
d3949 1
a3949 1
    if (o->op_type == OP_PADAV || o->op_type == OP_PADHV)
d3952 1
a3952 1
    if (o->op_type == OP_RV2SV)
d3961 1
d3965 1
a3965 1
	if (optype == OP_ANDASSIGN || optype == OP_ORASSIGN) {
d3977 2
d3984 1
a3984 1
	PL_eval_start = (left->op_type == OP_CONST) ? right : 0;
d3989 1
a3995 9
	for (curop = ((LISTOP*)curop)->op_first;
	     curop; curop = curop->op_sibling)
	{
	    if (curop->op_type == OP_RV2HV &&
		((UNOP*)curop)->op_first->op_type != OP_GV) {
		o->op_private |= OPpASSIGN_HASH;
		break;
	    }
	}
d4008 1
a4008 1
	 * to store these values, evil chicanery is done with SvCUR().
d4010 2
a4011 2
	
	if (!(left->op_private & OPpLVAL_INTRO)) {
d4018 2
a4019 1
			if (gv == PL_defgv || (int)SvCUR(gv) == PL_generation)
d4021 1
a4021 1
			SvCUR_set(gv, PL_generation);
d4028 2
a4029 2
			if ((int)PAD_COMPNAME_GEN(curop->op_targ)
						    == PL_generation)
a4043 1
			if (((PMOP*)curop)->op_pmreplroot) {
d4045 7
a4051 2
			    GV *gv = (GV*)PAD_SVl(INT2PTR(PADOFFSET,
					((PMOP*)curop)->op_pmreplroot));
d4053 5
a4057 3
			    GV *gv = (GV*)((PMOP*)curop)->op_pmreplroot;
#endif
			    if (gv == PL_defgv || (int)SvCUR(gv) == PL_generation)
d4059 1
a4059 1
			    SvCUR_set(gv, PL_generation);
d4061 1
d4071 52
a4122 5
	if (right && right->op_type == OP_SPLIT) {
	    OP* tmpop;
	    if ((tmpop = ((LISTOP*)right)->op_first) &&
		tmpop->op_type == OP_PUSHRE)
	    {
d4129 7
a4135 1
		    if (tmpop->op_type == OP_GV && !pm->op_pmreplroot) {
d4137 2
a4138 1
			pm->op_pmreplroot = INT2PTR(OP*, cPADOPx(tmpop)->op_padix);
d4141 3
a4143 2
			pm->op_pmreplroot = (OP*)cSVOPx(tmpop)->op_sv;
			cSVOPx(tmpop)->op_sv = Nullsv;	/* steal it */
d4148 1
a4148 1
			tmpop->op_sibling = Nullop;	/* don't free split */
d4182 4
a4185 1
	    o = newSVOP(OP_CONST, 0, newSViv(PL_compiling.cop_arybase));
d4194 1
d4208 1
a4208 1
    cop->op_private = (U8)(PL_hints & HINT_PRIVATE_MASK);
d4212 1
a4212 1
    PL_compiling.op_private = cop->op_private;
d4216 1
a4216 1
	cop->cop_label = label;
d4220 10
a4229 10
    cop->cop_arybase = PL_curcop->cop_arybase;
    if (specialWARN(PL_curcop->cop_warnings))
        cop->cop_warnings = PL_curcop->cop_warnings ;
    else
        cop->cop_warnings = newSVsv(PL_curcop->cop_warnings) ;
    if (specialCopIO(PL_curcop->cop_io))
        cop->cop_io = PL_curcop->cop_io;
    else
        cop->cop_io = newSVsv(PL_curcop->cop_io) ;

d4231 1
a4231 1
    if (PL_copline == NOLINE)
d4234 3
a4236 2
	CopLINE_set(cop, PL_copline);
        PL_copline = NOLINE;
d4246 7
a4252 4
	SV * const * const svp = av_fetch(CopFILEAV(PL_curcop), (I32)CopLINE(cop), FALSE);
	if (svp && *svp != &PL_sv_undef ) {
	    (void)SvIOK_on(*svp);
	    SvIV_set(*svp, PTR2IV(cop));
d4263 1
d4270 1
d4281 4
a4284 1
    if (first->op_type == OP_NOT && (first->op_flags & OPf_SPECIAL)) {
d4294 1
a4294 1
	    cUNOPo->op_first = Nullop;
d4303 4
a4306 3
	if ((type == OP_AND) == (SvTRUE(((SVOP*)first)->op_sv))) {
	    op_free(first);
	    *firstp = Nullop;
d4309 7
d4319 19
a4337 2
	    op_free(other);
	    *otherp = Nullop;
d4340 7
d4350 3
a4352 1
    else if ((first->op_flags & OPf_KIDS) && ckWARN(WARN_MISC)) {
d4380 1
a4380 1
	    CopLINE_set(PL_curcop, PL_copline);
d4393 1
a4393 1
    if (type == OP_ANDASSIGN || type == OP_ORASSIGN)
d4421 1
d4433 4
d4441 6
a4446 1
	if (SvTRUE(((SVOP*)first)->op_sv)) {
d4448 1
a4448 7
	    op_free(falseop);
	    return trueop;
	}
	else {
	    op_free(first);
	    op_free(trueop);
	    return falseop;
d4450 1
d4481 1
d4528 1
d4555 1
a4555 1
		if (k1->op_type == OP_READDIR
d4558 1
a4558 1
		      || k1->op_type == OP_EACH)
d4588 2
a4589 1
Perl_newWHILEOP(pTHX_ I32 flags, I32 debuggable, LOOP *loop, I32 whileline, OP *expr, OP *block, OP *cont)
d4591 1
d4593 1
a4593 1
    OP *next = 0;
d4617 1
a4617 1
		if (k1->op_type == OP_READDIR
d4620 1
a4620 1
		      || k1->op_type == OP_EACH)
d4629 1
a4629 1
    else if (cont) {
d4643 1
d4645 1
d4649 1
a4649 1
	PL_copline = (line_t)whileline;
d4655 1
a4655 1
	    return Nullop;		/* listop already freed by new_logop */
d4691 1
d4697 1
d4704 10
d4718 7
a4724 10
	    sv->op_targ = 0;
	    op_free(sv);
	    sv = Nullop;
	}
	else if (sv->op_type == OP_THREADSV) { /* per-thread variable */
	    padoff = sv->op_targ;
	    sv->op_targ = 0;
	    iterflags |= OPf_SPECIAL;
	    op_free(sv);
	    sv = Nullop;
d4728 8
d4738 8
a4745 6
#ifdef USE_5005THREADS
	padoff = find_threadsv("_");
	iterflags |= OPf_SPECIAL;
#else
	sv = newGVOP(OP_GV, 0, PL_defgv);
#endif
d4759 1
a4759 1
	UNOP* const flip = (UNOP*)((UNOP*)((BINOP*)expr)->op_first)->op_first;
d4766 1
a4766 1
	range->op_first = Nullop;
d4774 3
d4778 1
d4791 1
a4791 1
     * for our $x () sets OPpOUR_INTRO; both only used by Deparse.pm */
d4798 1
a4798 1
	FreeOp(loop);
d4802 1
a4802 1
    Renew(loop, 1, LOOP);
d4805 4
a4808 2
    wop = newWHILEOP(flags, 1, loop, forline, newOP(OP_ITER, 0), block, cont);
    PL_copline = forline;
d4815 1
d4823 2
a4824 2
	    o = newPVOP(type, 0, savepv(label->op_type == OP_CONST
					? SvPVx_nolen_const(((SVOP*)label)->op_sv)
d4827 3
d4831 1
d4844 177
d5035 6
a5040 7
#ifdef USE_5005THREADS
    if (CvMUTEXP(cv)) {
	MUTEX_DESTROY(CvMUTEXP(cv));
	Safefree(CvMUTEXP(cv));
	CvMUTEXP(cv) = 0;
    }
#endif /* USE_5005THREADS */
d5043 1
a5043 1
    if (CvFILE(cv) && !CvXSUB(cv)) {
d5047 1
a5047 1
    CvFILE(cv) = 0;
d5050 2
a5051 3
    if (!CvXSUB(cv) && CvROOT(cv)) {
#ifdef USE_5005THREADS
	if (CvDEPTH(cv) || (CvOWNER(cv) && CvOWNER(cv) != thr))
a5052 4
#else
	if (CvDEPTH(cv))
	    Perl_croak(aTHX_ "Can't undef active subroutine");
#endif /* USE_5005THREADS */
d5058 2
a5059 2
	CvROOT(cv) = Nullop;
	CvSTART(cv) = Nullop;
d5063 1
a5063 1
    CvGV(cv) = Nullgv;
d5071 1
a5071 1
	CvOUTSIDE(cv) = Nullcv;
d5077 2
a5078 2
    if (CvXSUB(cv)) {
        CvXSUB(cv) = 0;
d5085 2
a5086 1
Perl_cv_ckproto(pTHX_ CV *cv, GV *gv, char *p)
d5088 6
a5093 1
    if (((!p != !SvPOK(cv)) || (p && strNE(p, SvPVX_const(cv)))) && ckWARN_d(WARN_PROTOTYPE)) {
d5095 1
a5095 1
	SV* name = Nullsv;
d5098 2
a5099 2
	    gv_efullname3(name = sv_newmortal(), gv, Nullch);
	sv_setpv(msg, "Prototype mismatch:");
d5101 1
a5101 1
	    Perl_sv_catpvf(aTHX_ msg, " sub %"SVf, name);
d5103 1
a5103 1
	    Perl_sv_catpvf(aTHX_ msg, " (%"SVf")", (const SV *)cv);
d5105 2
a5106 2
	    Perl_sv_catpv(aTHX_ msg, ": none");
	sv_catpv(msg, " vs ");
d5108 1
a5108 1
	    Perl_sv_catpvf(aTHX_ msg, "(%s)", p);
d5110 2
a5111 2
	    sv_catpv(msg, "none");
	Perl_warner(aTHX_ packWARN(WARN_PROTOTYPE), "%"SVf, msg);
d5134 6
a5139 3
    if (!cv || !CvCONST(cv))
	return Nullsv;
    return (SV*)CvXSUBANY(cv).any_ptr;
d5142 20
d5163 1
a5163 1
Perl_op_const_sv(pTHX_ OP *o, CV *cv)
d5165 5
a5169 1
    SV *sv = Nullsv;
d5172 1
a5172 1
	return Nullsv;
d5191 1
a5191 1
	    return Nullsv;
d5194 1
a5194 1
	else if ((type == OP_PADSV || type == OP_CONST) && cv) {
d5197 9
a5205 7
		return Nullsv;
	    if (CvCONST(cv)) {
		/* We get here only from cv_clone2() while creating a closure.
		   Copy the const value here instead of in cv_clone2 so that
		   SvREADONLY_on doesn't lead to problems when leaving
		   scope.
		*/
d5207 6
a5213 2
	    if (!SvREADONLY(sv) && SvREFCNT(sv) > 1)
		return Nullsv;
d5215 3
a5217 2
	else
	    return Nullsv;
a5218 2
    if (sv)
	SvREADONLY_on(sv);
d5222 3
d5226 1
d5229 5
d5245 3
d5253 1
a5253 1
    return Perl_newATTRSUB(aTHX_ floor, o, proto, Nullop, block);
d5259 1
d5264 1
a5264 1
    register CV *cv=0;
d5266 10
a5275 3
    I32 gv_fetch_flags;

    const char * const name = o ? SvPVx_nolen_const(cSVOPo->op_sv) : Nullch;
d5279 1
a5279 1
	ps = SvPVx_const(((SVOP*)proto)->op_sv, ps_len);
d5282 1
a5282 1
	ps = Nullch;
d5292 1
a5292 1
	aname = Nullch;
d5294 13
a5306 13
    /* There may be future conflict here as change 23766 is not yet merged.  */
    gv_fetch_flags = (block || attrs || (CvFLAGS(PL_compcv) & CVf_BUILTIN_ATTRS))
	? GV_ADDMULTI : GV_ADDMULTI | GV_NOINIT;
    gv = gv_fetchpv(name ? name : (aname ? aname : 
		    (PL_curstash ? "__ANON__" : "__ANON__::__ANON__")),
		    gv_fetch_flags, SVt_PVCV);

    if (o)
	SAVEFREEOP(o);
    if (proto)
	SAVEFREEOP(proto);
    if (attrs)
	SAVEFREEOP(attrs);
d5316 1
a5316 1
	    cv_ckproto((CV*)gv, NULL, (char *)ps);
d5322 1
a5324 1
	PL_sub_generation++;
d5328 1
a5328 1
    cv = (!name || GvCVGEN(gv)) ? Nullcv : GvCV(gv);
d5336 7
a5342 2
    if (!block || !ps || *ps || attrs || (CvFLAGS(PL_compcv) & CVf_BUILTIN_ATTRS))
	const_sv = Nullsv;
d5344 1
a5344 1
	const_sv = op_const_sv(block, Nullcv);
d5360 1
a5360 1
	    cv_ckproto(cv, gv, (char *)ps);
d5363 5
a5367 1
	    if (!block && !attrs) {
d5376 5
a5380 4
	    /* ahem, death to those who redefine active sort subs */
	    if (PL_curstackinfo->si_type == PERLSI_SORT && PL_sortcop == CvSTART(cv))
		Perl_croak(aTHX_ "Can't redefine active sort subroutine %s", name);
	    if (block) {
d5386 2
a5387 2
		    if (PL_copline != NOLINE)
			CopLINE_set(PL_curcop, PL_copline);
d5393 8
a5400 2
		SvREFCNT_dec(cv);
		cv = Nullcv;
d5405 1
a5405 1
	(void)SvREFCNT_inc(const_sv);
d5412 1
d5415 2
a5416 2
	    GvCV(gv) = Nullcv;
	    cv = newCONSTSUB(NULL, (char *)name, const_sv);
d5418 9
a5429 1
	PL_sub_generation++;
d5439 5
a5443 1
	if (cv && !block) {
d5465 9
a5473 1
	if (!block) {
d5492 1
d5500 6
d5507 1
a5507 1
	    PL_sub_generation++;
a5512 7
#ifdef USE_5005THREADS
    CvOWNER(cv) = 0;
    if (!CvMUTEXP(cv)) {
	New(666, CvMUTEXP(cv), 1, perl_mutex);
	MUTEX_INIT(CvMUTEXP(cv));
    }
#endif /* USE_5005THREADS */
d5517 1
a5517 1
    if (PL_error_count) {
d5519 1
a5519 1
	block = Nullop;
d5531 1
a5531 1
		    Perl_croak(aTHX_ "%"SVf, ERRSV);
d5536 1
d5543 1
d5548 4
d5553 2
a5554 1
	    block = newSTATEOP(0, Nullch, 0);
d5556 2
a5576 3
	const char *s;
	const char *tname = (name ? name : aname);

d5578 4
a5581 3
	    SV *sv = NEWSV(0,0);
	    SV *tmpstr = sv_newmortal();
	    GV *db_postponed = gv_fetchpv("DB::postponed", GV_ADDMULTI, SVt_PVHV);
d5587 3
a5589 2
	    gv_efullname3(tmpstr, gv, Nullch);
	    hv_store(GvHV(PL_DBsub), SvPVX_const(tmpstr), SvCUR(tmpstr), sv, 0);
d5603 10
a5612 4
	if ((s = strrchr(tname,':')))
	    s++;
	else
	    s = tname;
d5614 6
a5619 2
	if (*s != 'B' && *s != 'E' && *s != 'C' && *s != 'I')
	    goto done;
d5621 2
a5622 1
	if (strEQ(s, "BEGIN")) {
a5627 2
	    if (!PL_beginav)
		PL_beginav = newAV();
d5629 1
a5629 1
	    av_push(PL_beginav, (SV*)cv);
d5634 1
a5634 1
	    PL_compiling.op_private = (U8)(PL_hints & HINT_PRIVATE_MASK);
d5637 38
a5674 27
	else if (strEQ(s, "END") && !PL_error_count) {
	    if (!PL_endav)
		PL_endav = newAV();
	    DEBUG_x( dump_sub(gv) );
	    av_unshift(PL_endav, 1);
	    av_store(PL_endav, 0, (SV*)cv);
	    GvCV(gv) = 0;		/* cv has been hijacked */
	}
	else if (strEQ(s, "CHECK") && !PL_error_count) {
	    if (!PL_checkav)
		PL_checkav = newAV();
	    DEBUG_x( dump_sub(gv) );
	    if (PL_main_start && ckWARN(WARN_VOID))
		Perl_warner(aTHX_ packWARN(WARN_VOID), "Too late to run CHECK block");
	    av_unshift(PL_checkav, 1);
	    av_store(PL_checkav, 0, (SV*)cv);
	    GvCV(gv) = 0;		/* cv has been hijacked */
	}
	else if (strEQ(s, "INIT") && !PL_error_count) {
	    if (!PL_initav)
		PL_initav = newAV();
	    DEBUG_x( dump_sub(gv) );
	    if (PL_main_start && ckWARN(WARN_VOID))
		Perl_warner(aTHX_ packWARN(WARN_VOID), "Too late to run INIT block");
	    av_push(PL_initav, (SV*)cv);
	    GvCV(gv) = 0;		/* cv has been hijacked */
	}
a5675 5

  done:
    PL_copline = NOLINE;
    LEAVE_SCOPE(floor);
    return cv;
a5677 1
/* XXX unsafe for threads if eval_owner isn't held */
d5688 1
a5688 1
Perl_newCONSTSUB(pTHX_ HV *stash, char *name, SV *sv)
d5690 1
d5692 9
d5704 7
d5712 1
a5712 1
    CopLINE_set(PL_curcop, PL_copline);
d5724 5
a5728 1
    cv = newXS(name, const_sv_xsub, savepv(CopFILE(PL_curcop)));
d5731 1
a5731 1
    sv_setpvn((SV*)cv, "", 0);  /* prototype is "" */
d5733 1
d5736 5
d5742 27
a5768 1
    LEAVE;
d5770 14
d5790 2
a5791 1
Used by C<xsubpp> to hook up XSUBs as Perl subs.
d5797 1
a5797 1
Perl_newXS(pTHX_ char *name, XSUBADDR_t subaddr, char *filename)
d5799 1
d5805 4
a5808 1
    if ((cv = (name ? GvCV(gv) : Nullcv))) {
d5812 1
a5812 1
	    cv = Nullcv;
d5822 2
a5823 2
			const char *name = HvNAME_get(stash);
			if ( strEQ(name,"autouse") ) {
d5825 2
a5826 2
			    if (PL_copline != NOLINE)
				CopLINE_set(PL_curcop, PL_copline);
d5837 1
a5837 1
	    cv = Nullcv;
d5844 1
a5844 2
	cv = (CV*)NEWSV(1105,0);
	sv_upgrade((SV *)cv, SVt_PVCV);
d5848 1
a5848 1
	    PL_sub_generation++;
a5851 5
#ifdef USE_5005THREADS
    New(666, CvMUTEXP(cv), 1, perl_mutex);
    MUTEX_INIT(CvMUTEXP(cv));
    CvOWNER(cv) = 0;
#endif /* USE_5005THREADS */
d5855 1
d5858 2
a5859 41
    if (name) {
	const char *s = strrchr(name,':');
	if (s)
	    s++;
	else
	    s = name;

	if (*s != 'B' && *s != 'E' && *s != 'C' && *s != 'I')
	    goto done;

	if (strEQ(s, "BEGIN")) {
	    if (!PL_beginav)
		PL_beginav = newAV();
	    av_push(PL_beginav, (SV*)cv);
	    GvCV(gv) = 0;		/* cv has been hijacked */
	}
	else if (strEQ(s, "END")) {
	    if (!PL_endav)
		PL_endav = newAV();
	    av_unshift(PL_endav, 1);
	    av_store(PL_endav, 0, (SV*)cv);
	    GvCV(gv) = 0;		/* cv has been hijacked */
	}
	else if (strEQ(s, "CHECK")) {
	    if (!PL_checkav)
		PL_checkav = newAV();
	    if (PL_main_start && ckWARN(WARN_VOID))
		Perl_warner(aTHX_ packWARN(WARN_VOID), "Too late to run CHECK block");
	    av_unshift(PL_checkav, 1);
	    av_store(PL_checkav, 0, (SV*)cv);
	    GvCV(gv) = 0;		/* cv has been hijacked */
	}
	else if (strEQ(s, "INIT")) {
	    if (!PL_initav)
		PL_initav = newAV();
	    if (PL_main_start && ckWARN(WARN_VOID))
		Perl_warner(aTHX_ packWARN(WARN_VOID), "Too late to run INIT block");
	    av_push(PL_initav, (SV*)cv);
	    GvCV(gv) = 0;		/* cv has been hijacked */
	}
    }
a5862 1
done:
d5866 3
d5870 1
d5873 1
d5875 7
a5881 3
    char *name;
    GV *gv;
    STRLEN n_a;
a5882 5
    if (o)
	name = SvPVx(cSVOPo->op_sv, n_a);
    else
	name = "STDOUT";
    gv = gv_fetchpv(name,TRUE, SVt_PVFM);
d5892 5
a5896 3
	    if (PL_copline != NOLINE)
		CopLINE_set(PL_curcop, PL_copline);
	    Perl_warner(aTHX_ packWARN(WARN_REDEFINE), "Format %s redefined",name);
d5914 4
d5919 3
a5921 1
    PL_copline = NOLINE;
d5923 3
d5931 1
a5931 2
    return newUNOP(OP_REFGEN, 0,
	mod(list(convert(OP_ANONLIST, 0, o)), OP_REFGEN));
d5937 1
a5937 2
    return newUNOP(OP_REFGEN, 0,
	mod(list(convert(OP_ANONHASH, 0, o)), OP_REFGEN));
d5943 1
a5943 1
    return newANONATTRSUB(floor, proto, Nullop, block);
d5957 1
d5981 1
d6007 1
d6032 1
a6046 9
Perl_oopsCV(pTHX_ OP *o)
{
    Perl_croak(aTHX_ "NOT IMPL LINE %d",__LINE__);
    /* STUB */
    PERL_UNUSED_ARG(o);
    NORETURN_FUNCTION_END;
}

OP *
d6055 1
a6060 4
    else if (o->op_type == OP_THREADSV && !(o->op_flags & OPpDONE_SVREF)) {
	o->op_flags |= OPpDONE_SVREF;
	return o;
    }
d6071 2
a6072 1
    cSVOPo->op_sv = Nullsv;
d6079 1
d6088 1
a6088 1
    o->op_private = (U8)(PL_hints & HINT_PRIVATE_MASK);
d6113 2
a6114 1
    const OP *kid = cUNOPo->op_first;
d6124 1
d6132 6
a6137 7
	if (newop &&
	    (newop->op_sibling ||
	     !(PL_opargs[newop->op_type] & OA_RETSCALAR) ||
	     newop->op_type == OP_PADAV || newop->op_type == OP_PADHV ||
	     newop->op_type == OP_RV2AV || newop->op_type == OP_RV2HV)) {

	    return o;
d6139 3
d6143 1
d6190 1
a6190 1
    const I32 type = o->op_type;
d6194 5
d6200 2
a6201 1
	    o = newUNOP(type, OPf_SPECIAL, newGVOP(OP_GV, 0, PL_argvgv));
d6211 1
d6222 3
d6227 1
d6229 1
d6243 1
d6246 1
a6246 1
	else
d6248 2
d6252 3
d6256 1
d6258 1
d6261 10
d6280 1
a6280 1
       SV * const * const svp = hv_fetch(table, "vmsish_exit", 11, FALSE);
d6307 1
d6313 2
a6314 1
	    if (kid->op_type != OP_RV2CV && !PL_error_count)
d6332 2
a6333 1
    SVOP *kid = (SVOP*)cUNOPo->op_first;
d6336 3
a6339 1
	char *name;
a6342 1
	STRLEN n_a;
d6346 3
a6348 3
	    SV *rsv = SvRV(kidsv);
	    const int svtype = SvTYPE(rsv);
            const char *badtype = Nullch;
d6352 1
a6352 1
		if (svtype > SVt_PVMG)
d6356 1
a6356 1
		if (svtype != SVt_PVAV)
d6360 1
a6360 9
		if (svtype != SVt_PVHV) {
		    if (svtype == SVt_PVAV) {	/* pseudohash? */
			SV **ksv = av_fetch((AV*)rsv, 0, FALSE);
			if (ksv && SvROK(*ksv)
			    && SvTYPE(SvRV(*ksv)) == SVt_PVHV)
			{
				break;
			}
		    }
a6361 1
		}
d6364 1
a6364 1
		if (svtype != SVt_PVCV)
d6372 13
a6384 3
	name = SvPV(kidsv, n_a);
	if ((PL_hints & HINT_STRICT_REFS) && (kid->op_private & OPpCONST_BARE)) {
            const char *badthing = Nullch;
d6395 3
d6401 2
a6402 2
	  "Can't use bareword (\"%s\") as %s ref while \"strict refs\" in use",
		      name, badthing);
d6414 1
a6414 1
	    gv = gv_fetchpv(name,
d6434 1
a6434 1
	    PAD_SETSV(kPADOP->op_padix, (SV*) SvREFCNT_inc(gv));
d6436 1
a6436 1
	    kid->op_sv = SvREFCNT_inc(gv);
d6448 1
d6452 1
a6452 1
	/* nothing */
d6456 1
d6458 1
a6458 2
	if (kid->op_type == OP_CONST && (kid->op_private & OPpCONST_BARE)) {
	    STRLEN n_a;
d6460 4
a6463 1
		gv_fetchpv(SvPVx(kid->op_sv, n_a), TRUE, SVt_PVIO));
d6465 2
a6466 1
	    o = newop;
d6468 1
a6468 3
	else {
	  if ((PL_hints & HINT_FILETEST_ACCESS) &&
	      OP_IS_FILETEST_ACCESS(o))
d6470 3
a6472 1
	}
d6475 3
d6479 1
d6484 1
d6492 1
a6503 1
	STRLEN n_a;
d6521 6
a6554 1
		    char *name = SvPVx(((SVOP*)kid)->op_sv, n_a);
d6556 1
a6556 1
			gv_fetchpv(name, TRUE, SVt_PVAV) ));
d6559 5
a6563 2
			    "Array @@%s missing the @@ in argument %"IVdf" of %s()",
			    name, (IV)numargs, PL_op_desc[type]);
d6565 1
a6577 1
		    char *name = SvPVx(((SVOP*)kid)->op_sv, n_a);
d6579 1
a6579 1
			gv_fetchpv(name, TRUE, SVt_PVHV) ));
d6582 5
a6586 2
			    "Hash %%%s missing the %% in argument %"IVdf" of %s()",
			    name, (IV)numargs, PL_op_desc[type]);
d6588 1
d6613 2
a6614 3
			OP *newop = newGVOP(OP_GV, 0,
			    gv_fetchpv(SvPVx(((SVOP*)kid)->op_sv, n_a), TRUE,
					SVt_PVIO) );
d6618 3
d6622 1
d6636 1
a6636 1
                            const char *name = Nullch;
d6646 3
a6648 11
				/*XXX DAPM 2002.08.25 tmp assert test */
				/*XXX*/ assert(av_fetch(PL_comppad_name, (kid->op_targ), FALSE));
				/*XXX*/ assert(*av_fetch(PL_comppad_name, (kid->op_targ), FALSE));

				name = PAD_COMPNAME_PV(kid->op_targ);
				/* SvCUR of a pad namesv can't be trusted
				 * (see PL_generation), so calc its length
				 * manually */
				if (name)
				    len = strlen(name);

d6653 1
a6653 1
				GV *gv = cGVOPx_gv(kUNOP->op_first);
d6660 1
d6662 1
a6662 1
				 name = 0;
d6664 1
a6664 1
				      SV *tmpstr = Nullsv;
d6670 2
a6671 2
					  (op = ((UNOP*)op)->op_first) &&
					  (op->op_type == OP_GV)) {
d6673 1
a6673 1
					   GV * const gv = cGVOPx_gv(op);
d6708 1
a6708 1
				(void)SvUPGRADE(namesv, SVt_PV);
d6732 6
d6741 1
d6745 6
d6753 1
d6768 1
d6775 1
a6775 1
    if (!((gv = gv_fetchpv("glob", FALSE, SVt_PVCV))
d6778 1
a6778 1
	gv = gv_fetchpv("CORE::GLOBAL::glob", FALSE, SVt_PVCV);
d6787 3
a6789 3
		newSVpvn("File::Glob", 10), Nullsv, Nullsv, Nullsv);
	gv = gv_fetchpv("CORE::GLOBAL::glob", FALSE, SVt_PVCV);
	glob_gv = gv_fetchpv("File::Glob::csh_glob", FALSE, SVt_PVCV);
d6791 1
a6791 1
	(void)SvREFCNT_inc((SV*)GvCV(gv));
d6823 2
a6824 1
    LOGOP *gwop;
d6827 1
d6830 1
a6830 1
    NewOp(1101, gwop, 1, LOGOP);
d6841 1
d6851 1
a6851 1
    if (PL_error_count)
d6858 2
a6863 1
    gwop->op_private = 1;
a6864 1
    gwop->op_targ = pad_alloc(type, SVs_PADTMP);
d6866 9
d6951 16
d7004 28
d7034 2
a7035 1
    OP *kid = cLISTOPo->op_first;
d7040 4
a7043 1
	&& !(kid->op_private & OPpTARGET_MY))
d7062 28
d7096 10
a7105 1
    o->op_private |= OPpRUNTIME;
d7115 2
a7116 1
	if (!(strchr(SvPVX_const(sv), ':') || strchr(SvPVX_const(sv), '\''))) {
d7119 1
a7119 1
		sv = newSVpvn_share(SvPVX_const(sv), SvCUR(sv), 0);
d7122 1
a7122 1
		kSVOP->op_sv = Nullsv;
d7125 3
d7129 1
d7139 1
d7146 1
d7149 1
a7149 1
	SV **svp = hv_fetch(table, "open_IN", 7, FALSE);
d7158 1
a7158 1
	svp = hv_fetch(table, "open_OUT", 8, FALSE);
d7167 10
a7176 1
    if (o->op_type == OP_BACKTICK)
d7178 1
d7217 2
a7218 1
    GV* gv;
d7227 2
d7240 4
a7243 1
	    for (s = SvPVX(sv); *s; s++) {
d7246 2
a7247 2
		    Move(s+2, s+1, strlen(s+2)+1, char);
		    SvCUR_set(sv, SvCUR(sv) - 1);
d7250 2
a7251 1
	    sv_catpvn(sv, ".pm", 3);
d7256 8
a7263 4
    /* handle override, if any */
    gv = gv_fetchpv("require", FALSE, SVt_PVCV);
    if (!(gv && GvCVu(gv) && GvIMPORTED_CV(gv)))
	gv = gv_fetchpv("CORE::GLOBAL::require", FALSE, SVt_PVCV);
d7267 2
d7270 1
d7272 8
a7279 5
	return ck_subr(newUNOP(OP_ENTERSUB, OPf_STACKED,
			       append_elem(OP_LIST, kid,
					   scalar(newUNOP(OP_RV2CV, 0,
							  newGVOP(OP_GV, 0,
								  gv))))));
d7288 1
a7296 10
#if 0
OP *
Perl_ck_retarget(pTHX_ OP *o)
{
    Perl_croak(aTHX_ "NOT IMPL LINE %d",__LINE__);
    /* STUB */
    return o;
}
#endif

d7300 1
d7321 1
d7326 4
a7329 1

d7331 1
a7331 11
#ifdef USE_5005THREADS
	if (!CvUNIQUE(PL_compcv)) {
	    argop = newOP(OP_PADAV, OPf_REF);
	    argop->op_targ = 0;		/* PAD_SV(0) is @@_ */
	}
	else {
	    argop = newUNOP(OP_RV2AV, 0,
		scalar(newGVOP(OP_GV, 0,
		    gv_fetchpv("ARGV", TRUE, SVt_PVAV))));
	}
#else
d7334 5
a7338 1
#endif /* USE_5005THREADS */
d7340 1
d7348 1
d7351 14
d7426 1
d7434 2
a7435 2
    GvMULTI_on(gv_fetchpv("a", TRUE, SVt_PV));
    GvMULTI_on(gv_fetchpv("b", TRUE, SVt_PV));
d7490 3
d7494 1
d7500 1
d7513 1
a7513 1
	cLISTOPo->op_first = kid = newSVOP(OP_CONST, 0, newSVpvn(" ", 1));
d7520 1
a7520 1
	kid = pmruntime( newPMOP(OP_MATCH, OPf_SPECIAL), kid, Nullop);
d7543 1
d7562 1
d7564 2
a7565 2
			"/%s/ should probably be written as \"%s\"",
			pmstr, pmstr);
d7574 1
d7579 4
a7582 3
    char *proto = 0;
    CV *cv = 0;
    GV *namegv = 0;
d7586 2
a7587 1
    char *e = 0;
d7601 7
a7607 3
	    else if (SvPOK(cv)) {
		namegv = CvANON(cv) ? gv : CvGV(cv);
		proto = SvPV_nolen((SV*)cv);
d7615 3
a7617 3
	    OP * const o = ((UNOP*)o2)->op_first->op_sibling;
	    if (o && o->op_type == OP_CONST)
		o->op_private &= ~OPpCONST_STRICT;
d7624 9
d7634 3
a7637 2
	    case '\0':
		return too_many_arguments(o, gv_ename(namegv));
d7642 4
d7659 1
a7659 1
		if (o2->op_type != OP_REFGEN && o2->op_type != OP_UNDEF)
d7662 1
a7662 1
			gv_ename(namegv), o2);
d7668 1
a7668 1
		if (o2->op_type == OP_RV2GV)
d7670 3
a7672 3
		else if (o2->op_type == OP_CONST)
		    o2->op_private &= ~OPpCONST_STRICT;
		else if (o2->op_type == OP_ENTERSUB) {
d7674 1
a7674 1
		    OP *gvop = ((UNOP*)o2)->op_first;
d7687 4
a7690 1
				SV * const n = newSVpvn("",0);
d7692 1
d7695 1
d7724 2
a7725 2
		         char *p = proto;
			 const char s = *p;
a7726 1
			 *p = '\0';
d7728 3
a7730 3
			 bad_type(arg, Perl_form(aTHX_ "one of %s", p),
				 gv_ename(namegv), o2);
			 *proto = s;
d7735 1
a7735 1
		     if (o2->op_type == OP_RV2GV)
d7738 1
a7738 1
			  bad_type(arg, "symbol", gv_ename(namegv), o2);
d7741 1
a7741 1
		     if (o2->op_type == OP_ENTERSUB)
d7744 2
a7745 1
			  bad_type(arg, "subroutine entry", gv_ename(namegv), o2);
d7748 4
a7751 5
		    if (o2->op_type == OP_RV2SV ||
			o2->op_type == OP_PADSV ||
			o2->op_type == OP_HELEM ||
			o2->op_type == OP_AELEM ||
			o2->op_type == OP_THREADSV)
d7754 1
a7754 1
			bad_type(arg, "scalar", gv_ename(namegv), o2);
d7757 2
a7758 2
		    if (o2->op_type == OP_RV2AV ||
			o2->op_type == OP_PADAV)
d7761 1
a7761 1
			bad_type(arg, "array", gv_ename(namegv), o2);
d7764 2
a7765 2
		    if (o2->op_type == OP_RV2HV ||
			o2->op_type == OP_PADHV)
d7768 1
a7768 1
			 bad_type(arg, "hash", gv_ename(namegv), o2);
d7795 1
a7795 1
			   gv_ename(namegv), cv);
d7804 8
a7811 2
    if (proto && !optional &&
	  (*proto && *proto != '@@' && *proto != '%' && *proto != ';'))
d7813 9
d7828 1
d7834 16
d7868 12
d7883 1
a7883 1
    if ((o->op_flags & OPf_KIDS) && o->op_private == 4) {
d7902 2
a7903 2
    register OP* oldop = 0;
    STRLEN n_a;
d7905 1
a7905 1
    if (!o || o->op_seq)
d7911 1
a7911 1
	if (o->op_seq)
d7913 3
a7915 4
        /* The special value -1 is used by the B::C compiler backend to indicate
         * that an op is statically defined and should not be freed */
	if (!PL_op_seqmax || PL_op_seqmax == (U16)-1)
	    PL_op_seqmax = 1;
a7921 1
	    o->op_seq = PL_op_seqmax++;
d7941 12
d7960 1
a7960 1
		cSVOPo->op_sv = Nullsv;
a7963 1
	    o->op_seq = PL_op_seqmax++;
d7970 1
a7970 1
			goto ignore_optimization;
a7979 2
	  ignore_optimization:
	    o->op_seq = PL_op_seqmax++;
a7982 1
		o->op_seq = PL_op_seqmax++;
d7997 3
a7999 5
	    if (oldop && o->op_next) {
		oldop->op_next = o->op_next;
		continue;
	    }
	    break;
d8003 1
a8003 1
	  nothin:
d8006 1
a8008 1
	    o->op_seq = PL_op_seqmax++;
d8014 1
a8014 1
		OP* pop = (o->op_type == OP_PADAV) ?
d8022 1
a8022 1
		    (i = SvIV(((SVOP*)pop)->op_sv) - PL_curcop->cop_arybase)
a8044 1
		o->op_seq = PL_op_seqmax++;
d8063 1
a8063 1
		    gv_efullname3(sv, gv, Nullch);
d8066 1
a8066 1
				sv);
a8080 1
	    o->op_seq = PL_op_seqmax++;
d8087 1
d8090 1
d8093 1
a8093 1
	    o->op_seq = PL_op_seqmax++;
a8100 1
	    o->op_seq = PL_op_seqmax++;
a8111 2
	case OP_QR:
	case OP_MATCH:
d8113 6
a8118 5
	    o->op_seq = PL_op_seqmax++;
	    while (cPMOP->op_pmreplstart &&
		   cPMOP->op_pmreplstart->op_type == OP_NULL)
		cPMOP->op_pmreplstart = cPMOP->op_pmreplstart->op_next;
	    peep(cPMOP->op_pmreplstart);
a8121 1
	    o->op_seq = PL_op_seqmax++;
d8125 11
a8135 12
		if (o->op_next->op_sibling &&
			o->op_next->op_sibling->op_type != OP_EXIT &&
			o->op_next->op_sibling->op_type != OP_WARN &&
			o->op_next->op_sibling->op_type != OP_DIE) {
		    const line_t oldline = CopLINE(PL_curcop);

		    CopLINE_set(PL_curcop, CopLINE((COP*)o->op_next));
		    Perl_warner(aTHX_ packWARN(WARN_EXEC),
				"Statement unlikely to be reached");
		    Perl_warner(aTHX_ packWARN(WARN_EXEC),
				"\t(Maybe you meant system() when you said exec()?)\n");
		    CopLINE_set(PL_curcop, oldline);
d8142 1
a8142 1
	    SV *lexname;
d8144 1
a8144 2
	    SV **svp, **indsvp, *sv;
	    I32 ind;
a8147 2
	    o->op_seq = PL_op_seqmax++;

d8156 1
a8156 1
					 SvUTF8(sv) ? -(I32)keylen : keylen,
d8169 1
a8169 1
	    if (!(SvFLAGS(lexname) & SVpad_TYPED))
d8171 1
a8171 1
	    fields = (GV**)hv_fetch(SvSTASH(lexname), "FIELDS", 6, FALSE);
d8175 10
a8184 24
	    indsvp = hv_fetch(GvHV(*fields), key,
			      SvUTF8(*svp) ? -(I32)keylen : keylen, FALSE);
	    if (!indsvp) {
		Perl_croak(aTHX_ "No such pseudo-hash field \"%s\" "
			   "in variable %s of type %s",
		      key, SvPV_nolen_const(lexname),
		      HvNAME_get(SvSTASH(lexname)));
	    }
	    ind = SvIV(*indsvp);
	    if (ind < 1)
		Perl_croak(aTHX_ "Bad index while coercing array into hash");
	    rop->op_type = OP_RV2AV;
	    rop->op_ppaddr = PL_ppaddr[OP_RV2AV];
	    o->op_type = OP_AELEM;
	    o->op_ppaddr = PL_ppaddr[OP_AELEM];
	    sv = newSViv(ind);
	    if (SvREADONLY(*svp))
		SvREADONLY_on(sv);
	    SvFLAGS(sv) |= (SvFLAGS(*svp)
			    & (SVs_PADBUSY|SVs_PADTMP|SVs_PADMY));
	    SvREFCNT_dec(*svp);
	    *svp = sv;
	    break;
	}
d8190 1
a8190 2
	    SV **svp, **indsvp, *sv;
	    I32 ind;
a8194 1
	    o->op_seq = PL_op_seqmax++;
d8201 1
a8201 1
	    if (rop->op_type != OP_RV2HV || rop->op_first->op_type != OP_PADSV)
d8203 16
a8218 2
	    lexname = *av_fetch(PL_comppad_name, rop->op_first->op_targ, TRUE);
	    if (!(SvFLAGS(lexname) & SVpad_TYPED))
d8220 1
a8220 1
	    fields = (GV**)hv_fetch(SvSTASH(lexname), "FIELDS", 6, FALSE);
a8225 1
	    /* Check that the key list contains only constants. */
d8227 1
a8227 1
		 key_op = (SVOP*)key_op->op_sibling)
d8229 1
a8229 9
		    break;
	    if (key_op)
		break;
	    rop->op_type = OP_RV2AV;
	    rop->op_ppaddr = PL_ppaddr[OP_RV2AV];
	    o->op_type = OP_ASLICE;
	    o->op_ppaddr = PL_ppaddr[OP_ASLICE];
	    for (key_op = first_key_op; key_op;
		 key_op = (SVOP*)key_op->op_sibling) {
d8232 4
a8235 4
		indsvp = hv_fetch(GvHV(*fields), key,
				  SvUTF8(*svp) ? -(I32)keylen : keylen, FALSE);
		if (!indsvp) {
		    Perl_croak(aTHX_ "No such pseudo-hash field \"%s\" "
d8237 1
a8237 1
			  key, SvPV(lexname, n_a), HvNAME_get(SvSTASH(lexname)));
a8238 10
		ind = SvIV(*indsvp);
		if (ind < 1)
		    Perl_croak(aTHX_ "Bad index while coercing array into hash");
		sv = newSViv(ind);
		if (SvREADONLY(*svp))
		    SvREADONLY_on(sv);
		SvFLAGS(sv) |= (SvFLAGS(*svp)
				& (SVs_PADBUSY|SVs_PADTMP|SVs_PADMY));
		SvREFCNT_dec(*svp);
		*svp = sv;
a8273 2
	    o->op_seq = PL_op_seqmax++;

a8363 1
	    o->op_seq = PL_op_seqmax++;
d8448 45
d8494 5
a8498 2
	default:
	    o->op_seq = PL_op_seqmax++;
d8506 2
a8507 2
char*
Perl_custom_op_name(pTHX_ OP* o)
d8509 1
d8526 2
a8527 2
char*
Perl_custom_op_desc(pTHX_ OP* o)
d8529 1
d8552 1
d8555 1
@


1.11
log
@The official fix for the Perl sprintf buffer overflow.

ok millert@@
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
d131 2
a132 2
    I32 **ptr = (I32 **) op;
    I32 *slab = ptr[-1];
d161 1
a161 1
STATIC char*
d164 1
a164 2
    STRLEN n_a;
    SV* tmpsv = sv_newmortal();
d166 1
a166 1
    return SvPV(tmpsv,n_a);
d178 1
a178 1
S_too_few_arguments(pTHX_ OP *o, char *name)
d185 1
a185 1
S_too_many_arguments(pTHX_ OP *o, char *name)
d192 1
a192 1
S_bad_type(pTHX_ I32 n, char *t, char *name, OP *kid)
d195 1
a195 1
		 (int)n, name, t, OP_DESC(kid)));
d199 1
a199 1
S_no_bareword_allowed(pTHX_ OP *o)
a337 1
    register OP *kid, *nextkid;
d339 1
d353 3
a355 2
	    if (OpREFCNT_dec(o)) {
		OP_REFCNT_UNLOCK;
a356 2
	    }
	    OP_REFCNT_UNLOCK;
d364 1
d476 1
a476 1
	    HV *pmstash = PmopSTASH(cPMOPo);
d552 12
a570 1
    register OP *kid;
d577 1
a594 1
    OP *kid;
d596 1
d608 1
a608 1
	    line_t oldline = CopLINE(PL_curcop);
d625 1
a625 1
    if (!o || (o->op_flags & OPf_WANT) || PL_error_count
d693 1
a693 1
    char* useless = 0;
d839 3
a841 3
		    if (strnEQ(SvPVX(sv), "di", 2) ||
			strnEQ(SvPVX(sv), "ds", 2) ||
			strnEQ(SvPVX(sv), "ig", 2))
d859 10
a919 1
    OP *kid;
d921 1
a1005 2
    OP *kid;

d1012 1
a1031 1
    OP *kid;
d1033 1
d1369 1
a1369 1
S_scalar_mod_type(pTHX_ OP *o, I32 type)
d1416 1
a1416 1
S_is_handle_constructor(pTHX_ OP *o, I32 argnum)
d1421 1
a1421 1
	if (argnum == 2)
d1430 1
a1430 1
	if (argnum == 1)
a1440 1
    OP *kid;
d1442 1
d1570 1
a1570 1
	stashsv = newSVpv(HvNAME(stash), 0);
a1577 1
	SV **svp;
d1579 1
a1579 1
	svp = hv_fetch(GvHVn(PL_incgv), ATTRSMODULE_PM,
d1623 1
a1623 1
	stashsv = newSVpv(HvNAME(stash), 0);
d1639 5
a1643 1
    PERL_HASH(SvUVX(meth), SvPVX(meth), SvCUR(meth));
d1684 1
a1684 1
            char *sstr = attrstr;
a1704 1
    OP *kid;
d1712 1
d1724 1
a1724 1
	    GV *gv = cGVOPx_gv(cUNOPo->op_first);
d1814 1
a1814 2
    if (ckWARN(WARN_MISC) &&
      (left->op_type == OP_RV2AV ||
d1817 4
a1820 2
       left->op_type == OP_PADHV)) {
      char *desc = PL_op_desc[(right->op_type == OP_SUBST ||
d1823 1
a1823 1
      const char *sample = ((left->op_type == OP_RV2AV ||
d1883 1
a1883 1
	    if (kid->op_type == OP_NEXTSTATE || kid->op_type == OP_DBSTATE)
d1885 7
d1909 1
a1909 1
    int retval = PL_savestack_ix;
d1932 2
a1933 2
    int needblockscope = PL_hints & HINT_BLOCK_SCOPE;
    OP* retval = scalarseq(seq);
d1948 1
a1948 1
    OP *o = newOP(OP_THREADSV, 0);
d1989 1
a1989 1
	    CV *cv = get_cv("DB::postponed", FALSE);
d2013 2
a2014 2
	if (ckWARN(WARN_PARENTHESIS)
	    && PL_bufptr > PL_oldbufptr && PL_bufptr[-1] == ',')
d2151 1
a2151 1
    I32 oldtmps_floor = PL_tmps_floor;
d2194 1
a2194 1
    if (o->op_type != type)
d2211 1
a2211 1
    if (first->op_type != type
d2236 1
a2236 1
    if (first->op_type != type)
d2239 1
a2239 1
    if (last->op_type != type)
d2260 1
a2260 1
    if (last->op_type == type) {
d2321 1
a2321 2
	OP* pushop;
	pushop = newOP(OP_PUSHMARK, 0);
d2364 1
a2364 1
    unop->op_flags = flags | OPf_KIDS;
d2385 1
a2385 1
    binop->op_flags = flags | OPf_KIDS;
d2404 2
a2405 2
static int
uvcompare(const void *a, const void *b)
d2407 1
a2407 1
    if (*((UV *)a) < (*(UV *)b))
d2409 1
a2409 1
    if (*((UV *)a) > (*(UV *)b))
d2411 1
a2411 1
    if (*((UV *)a+1) < (*(UV *)b+1))
d2413 1
a2413 1
    if (*((UV *)a+1) > (*(UV *)b+1))
d2421 2
a2422 2
    SV *tstr = ((SVOP*)expr)->op_sv;
    SV *rstr = ((SVOP*)repl)->op_sv;
d2425 2
a2426 2
    U8 *t = (U8*)SvPV(tstr, tlen);
    U8 *r = (U8*)SvPV(rstr, rlen);
a2428 3
    I32 del;
    I32 complement;
    I32 squash;
d2432 3
a2435 3
    complement	= o->op_private & OPpTRANS_COMPLEMENT;
    del		= o->op_private & OPpTRANS_DELETE;
    squash	= o->op_private & OPpTRANS_SQUASH;
d2444 1
a2444 1
	SV* listsv = newSVpvn("# comment\n",10);
d2446 2
a2447 2
	U8* tend = t + tlen;
	U8* rend = r + rlen;
d2461 2
a2462 2
	I32 from_utf	= o->op_private & OPpTRANS_FROM_UTF;
	I32 to_utf	= o->op_private & OPpTRANS_TO_UTF;
d2468 1
a2468 1
	    tsave = t = bytes_to_utf8(t, &len);
d2473 1
a2473 1
	    rsave = r = bytes_to_utf8(r, &len);
d2484 1
a2484 1
	    U8 tmpbuf[UTF8_MAXLEN+1];
d2487 1
a2487 1
	    New(1109, cp, 2*tlen, UV);
d2491 1
a2491 1
		cp[2*i] = utf8n_to_uvuni(t, tend-t, &ulen, 0);
d2495 1
a2495 1
		    cp[2*i+1] = utf8n_to_uvuni(t, tend-t, &ulen, 0);
d2530 1
a2530 1
	    t = (U8*)SvPVX(transv);
d2549 1
a2549 1
		tfirst = (I32)utf8n_to_uvuni(t, tend - t, &ulen, 0);
d2553 1
a2553 1
		    tlast = (I32)utf8n_to_uvuni(t, tend - t, &ulen, 0);
d2563 1
a2563 1
		    rfirst = (I32)utf8n_to_uvuni(r, rend - r, &ulen, 0);
d2567 2
a2568 1
			rlast = (I32)utf8n_to_uvuni(r, rend - r, &ulen, 0);
d2683 1
a2683 1
	    tbl[0x100] = rlen - j;
d2741 10
a2750 13
    {
        SV* repointer;
        if(av_len((AV*) PL_regex_pad[0]) > -1) {
	    repointer = av_pop((AV*)PL_regex_pad[0]);
            pmop->op_pmoffset = SvIV(repointer);
	    SvREPADTMP_off(repointer);
	    sv_setiv(repointer,0);
        } else {
            repointer = newSViv(0);
            av_push(PL_regex_padav,SvREFCNT_inc(repointer));
            pmop->op_pmoffset = av_len(PL_regex_padav);
            PL_regex_pad = AvARRAY(PL_regex_padav);
        }
d2780 14
a2793 2
	char *p = SvPV(pat, plen);
	if ((o->op_flags & OPf_SPECIAL) && strEQ(p, " ")) {
d2795 4
a2798 1
	    p = SvPV(pat, plen);
d2803 2
a2804 1
	PM_SETRE(pm, CALLREGCOMP(aTHX_ p, p + plen, pm));
d3007 1
a3007 1
	char *name;
d3009 1
a3009 1
	name = SvPV(sv, len);
d3036 2
a3037 2
    if (version != Nullop) {
	SV *vesv = ((SVOP*)version)->op_sv;
d3039 1
a3039 1
	if (arg == Nullop && !SvNIOKp(vesv)) {
d3056 5
a3060 1
	    PERL_HASH(SvUVX(meth), SvPVX(meth), SvCUR(meth));
d3084 5
a3088 1
	PERL_HASH(SvUVX(meth), SvPVX(meth), SvCUR(meth));
d3169 1
a3169 1
    OP *modname, *veop, *imop;
d3171 1
a3171 1
    modname = newSVOP(OP_CONST, 0, name);
d3194 3
a3196 3
	line_t ocopline = PL_copline;
	COP *ocurcop = PL_curcop;
	int oexpect = PL_expect;
d3238 1
a3238 1
S_list_assignment(pTHX_ register OP *o)
d3247 2
a3248 2
	I32 t = list_assignment(cLOGOPo->op_first->op_sibling);
	I32 f = list_assignment(cLOGOPo->op_first->op_sibling->op_sibling);
d3293 1
a3293 1
    if (list_assignment(left)) {
d3297 3
a3299 1
	PL_eval_start = right;	/* Grandfathering $[ assignment here.  Bletch.*/
d3303 3
a3305 13
	else {
	    op_free(left);
	    op_free(right);
	    return Nullop;
	}
	/* optimise C<my @@x = ()> to C<my @@x>, and likewise for hashes */
	if ((left->op_type == OP_PADAV || left->op_type == OP_PADHV)
		&& right->op_type == OP_STUB
		&& (left->op_private & OPpLVAL_INTRO))
	{
	    op_free(right);
	    left->op_flags &= ~(OPf_REF|OPf_SPECIAL);
	    return left;
d3343 1
a3343 1
			SvCUR(gv) = PL_generation;
d3353 1
a3353 2
			PAD_COMPNAME_GEN(curop->op_targ)
			    				= PL_generation;
d3375 1
a3375 1
			    SvCUR(gv) = PL_generation;
d3391 1
a3391 1
		PMOP *pm = (PMOP*)tmpop;
d3442 1
a3442 2
	    op_free(o);
	    return Nullop;
d3451 1
a3451 1
    U32 seq = intro_my();
d3501 4
a3504 4
	SV **svp = av_fetch(CopFILEAV(PL_curcop), (I32)CopLINE(cop), FALSE);
        if (svp && *svp != &PL_sv_undef ) {
           (void)SvIOK_on(*svp);
	    SvIVX(*svp) = PTR2IV(cop);
d3524 1
a3524 1
    OP *other = *otherp;
d3548 1
a3548 1
	else if (ckWARN(WARN_BAREWORD) && (first->op_private & OPpCONST_BARE))
d3565 3
a3567 3
    else if (ckWARN(WARN_MISC) && (first->op_flags & OPf_KIDS)) {
	OP *k1 = ((UNOP*)first)->op_first;
	OP *k2 = k1->op_sibling;
d3592 1
a3592 1
	    line_t oldline = CopLINE(PL_curcop);
d3614 1
a3614 1
    logop->op_flags = flags | OPf_KIDS;
d3646 3
a3648 3
           first->op_private & OPpCONST_STRICT) {
           no_bareword_allowed(first);
       }
d3664 1
a3664 1
    logop->op_flags = flags | OPf_KIDS;
d3737 1
a3737 1
    int once = block && block->op_flags & OPf_SPECIAL &&
d3740 2
d3750 2
a3751 2
	    OP *k1 = ((UNOP*)expr)->op_first;
	    OP *k2 = (k1) ? k1->op_sibling : NULL;
d3802 17
a3818 14
    if (expr && (expr->op_type == OP_READLINE || expr->op_type == OP_GLOB
		 || (expr->op_type == OP_NULL && expr->op_targ == OP_GLOB))) {
	expr = newUNOP(OP_DEFINED, 0,
	    newASSIGNOP(0, newDEFSVOP(), 0, expr) );
    } else if (expr && (expr->op_flags & OPf_KIDS)) {
	OP *k1 = ((UNOP*)expr)->op_first;
	OP *k2 = (k1) ? k1->op_sibling : NULL;
	switch (expr->op_type) {
	  case OP_NULL:
	    if (k2 && k2->op_type == OP_READLINE
		  && (k2->op_flags & OPf_STACKED)
		  && ((k1->op_flags & OPf_WANT) == OPf_WANT_SCALAR))
		expr = newUNOP(OP_DEFINED, 0, expr);
	    break;
d3820 8
a3827 7
	  case OP_SASSIGN:
	    if (k1->op_type == OP_READDIR
		  || k1->op_type == OP_GLOB
		  || (k1->op_type == OP_NULL && k1->op_targ == OP_GLOB)
		  || k1->op_type == OP_EACH)
		expr = newUNOP(OP_DEFINED, 0, expr);
	    break;
d3841 1
a3841 1
	OP *unstack = newOP(OP_UNSTACK, 0);
d3891 1
a3891 1
Perl_newFOROP(pTHX_ I32 flags,char *label,line_t forline,OP *sv,OP *expr,OP *block,OP *cont)
d3942 4
a3945 4
	UNOP* flip = (UNOP*)((UNOP*)((BINOP*)expr)->op_first)->op_first;
	LOGOP* range = (LOGOP*) flip->op_first;
	OP* left  = range->op_first;
	OP* right = left->op_sibling;
a3965 1

d3976 1
a3976 1
	Copy(loop,tmp,1,LOOP);
a3992 1
    STRLEN n_a;
d4000 1
a4000 1
					? SvPVx(((SVOP*)label)->op_sv, n_a)
d4060 1
d4088 2
a4089 2
    if (((!p != !SvPOK(cv)) || (p && strNE(p, SvPVX(cv)))) && ckWARN_d(WARN_PROTOTYPE)) {
	SV* msg = sv_newmortal();
d4098 1
a4098 1
	    Perl_sv_catpvf(aTHX_ msg, " (%"SVf")", (SV *)cv);
d4100 1
a4100 1
	    Perl_sv_catpvf(aTHX_ msg, ": none");
d4146 1
a4146 1
	OPCODE type = o->op_type;
d4188 2
d4210 1
a4210 3
    STRLEN n_a;
    char *name;
    char *aname;
d4212 2
a4213 1
    char *ps;
d4216 1
d4218 1
a4218 1
    name = o ? SvPVx(cSVOPo->op_sv, n_a) : Nullch;
d4222 1
a4222 1
	ps = SvPVx(((SVOP*)proto)->op_sv, n_a);
d4228 1
a4228 1
	SV *sv = sv_newmortal();
d4232 1
a4232 1
	aname = SvPVX(sv);
d4236 4
d4242 1
a4242 2
		    GV_ADDMULTI | ((block || attrs) ? 0 : GV_NOINIT),
		    SVt_PVCV);
d4259 1
a4259 1
	    cv_ckproto((CV*)gv, NULL, ps);
d4262 1
a4262 1
	    sv_setpv((SV*)gv, ps);
d4279 1
a4279 1
    if (!block || !ps || *ps || attrs)
d4285 1
a4285 1
        bool exists = CvROOT(cv) || CvXSUB(cv);
d4298 1
a4298 1
	    cv_ckproto(cv, gv, ps);
d4318 1
a4318 1
		    line_t oldline = CopLINE(PL_curcop);
d4332 1
a4332 1
	SvREFCNT_inc(const_sv);
d4335 1
a4335 1
	    sv_setpv((SV*)cv, "");  /* prototype is "" */
d4342 1
a4342 1
	    cv = newCONSTSUB(NULL, name, const_sv);
d4421 1
a4421 1
	sv_setpv((SV*)cv, ps);
d4427 1
a4427 1
	    char *s = strrchr(name, ':');
d4430 1
a4430 1
		char *not_safe =
d4474 2
a4475 2
	char *s;
	char *tname = (name ? name : aname);
a4480 1
	    CV *pcv;
d4487 1
a4487 1
	    hv_store(GvHV(PL_DBsub), SvPVX(tmpstr), SvCUR(tmpstr), sv, 0);
d4489 9
a4497 8
	    if (HvFILL(hv) > 0 && hv_exists(hv, SvPVX(tmpstr), SvCUR(tmpstr))
		&& (pcv = GvCV(db_postponed)))
	    {
		dSP;
		PUSHMARK(SP);
		XPUSHs(tmpstr);
		PUTBACK;
		call_sv((SV*)pcv, G_DISCARD);
d4510 1
a4510 1
	    I32 oldscope = PL_scopestack_ix;
d4594 1
a4594 1
    sv_setpv((SV*)cv, "");  /* prototype is "" */
d4615 1
a4615 1
    GV *gv = gv_fetchpv(name ? name :
d4624 1
a4624 1
	    cv = 0;
d4628 19
a4646 10
	    if (ckWARN(WARN_REDEFINE) && !(CvGV(cv) && GvSTASH(CvGV(cv))
			    && strEQ(HvNAME(GvSTASH(CvGV(cv))), "autouse"))) {
		line_t oldline = CopLINE(PL_curcop);
		if (PL_copline != NOLINE)
		    CopLINE_set(PL_curcop, PL_copline);
		Perl_warner(aTHX_ packWARN(WARN_REDEFINE),
			    CvCONST(cv) ? "Constant subroutine %s redefined"
					: "Subroutine %s redefined"
			    ,name);
		CopLINE_set(PL_curcop, oldline);
d4649 1
a4649 1
	    cv = 0;
d4671 1
a4671 1
    CvFILE(cv) = filename;	/* NOTE: not copied, as it is expected to be
d4676 1
a4676 1
	char *s = strrchr(name,':');
d4744 1
a4744 1
	    line_t oldline = CopLINE(PL_curcop);
d4891 2
a4892 1
    return o;
d4944 2
a4945 2
	OP * left = cBINOPo->op_first;
	OP * right = left->op_sibling;
d4963 1
a4963 1
    OP *kid = cUNOPo->op_first;
d4976 1
a4976 1
	OPCODE type = o->op_type;
d5001 1
a5001 1
	OP *kid = cUNOPo->op_first;
d5035 1
a5035 1
    I32 type = o->op_type;
d5052 1
a5052 1
	SVOP *kid = (SVOP*)cUNOPo->op_first;
d5093 1
a5093 1
    HV *table = GvHV(PL_hintgv);
d5095 1
a5095 1
       SV **svp = hv_fetch(table, "vmsish_exit", 11, FALSE);
a5106 1
    OP *kid;
d5108 1
d5124 1
a5124 1
	OP *kid = cUNOPo->op_first;
a5141 11
#if 0
OP *
Perl_ck_gvconst(pTHX_ register OP *o)
{
    o = fold_constants(o);
    if (o->op_type == OP_CONST)
	o->op_type = OP_GV;
    return o;
}
#endif

d5152 1
a5152 1
	SV *kidsv = kid->op_sv;
d5158 2
a5159 2
	    int svtype = SvTYPE(rsv);
	    char *badtype = Nullch;
d5194 1
a5194 1
	    char *badthing = Nullch;
d5255 1
a5255 1
    I32 type = o->op_type;
d5261 1
a5261 1
	SVOP *kid = (SVOP*)cUNOPo->op_first;
d5265 1
a5265 1
	    OP *newop = newGVOP(type, OPf_REF,
d5289 1
a5289 5
    register OP *kid;
    OP **tokid;
    OP *sibl;
    I32 numargs = 0;
    int type = o->op_type;
d5301 5
a5305 2
	tokid = &cLISTOPo->op_first;
	kid = cLISTOPo->op_first;
d5347 1
a5347 1
		    OP *newop = newAVREF(newGVOP(OP_GV, 0,
d5367 1
a5367 1
		    OP *newop = newHVREF(newGVOP(OP_GV, 0,
d5384 1
a5384 1
		    OP *newop = newUNOP(OP_NULL, 0, kid);
d5418 1
a5418 1
			    char *name = Nullch;
d5450 1
a5450 2
				 OP *op;

d5452 1
a5452 1
				 if ((op = ((BINOP*)kid)->op_first)) {
d5454 1
a5454 1
				      char *a =
d5462 1
a5462 1
					   GV *gv = cGVOPx_gv(op);
d5473 1
a5473 1
					   char *padname =
a5480 1
					   
d5483 1
a5483 1
					   name = SvPV(tmpstr, len);
d5565 1
a5565 1
	SvREFCNT_inc((SV*)GvCV(gv));
d5599 1
a5599 1
    OPCODE type = o->op_type == OP_GREPSTART ? OP_GREPWHILE : OP_MAPWHILE;
d5608 2
d5670 1
a5670 1
    OPCODE type = o->op_type;
d5715 1
a5715 1
    OPCODE type = o->op_type;
d5759 1
a5759 1
	OP *kkid = kid->op_sibling;
a5775 13
    /* optimise C<my $x = undef> to C<my $x> */
    if (kid->op_type == OP_UNDEF) {
	OP *kkid = kid->op_sibling;
	if (kkid && kkid->op_type == OP_PADSV
		&& (kkid->op_private & OPpLVAL_INTRO))
	{
	    cLISTOPo->op_first = NULL;
	    kid->op_sibling = NULL;
	    op_free(o);
	    op_free(kid);
	    return kkid;
	}
    }
d5789 1
a5789 1
    OP *kid = cUNOPo->op_first;
d5792 1
a5792 1
	if (!(strchr(SvPVX(sv), ':') || strchr(SvPVX(sv), '\''))) {
d5795 1
a5795 1
		sv = newSVpvn_share(SvPVX(sv), SvCUR(sv), 0);
d5817 1
a5817 1
    HV *table = GvHV(PL_hintgv);
d5819 1
a5819 3
	SV **svp;
	I32 mode;
	svp = hv_fetch(table, "open_IN", 7, FALSE);
d5821 1
a5821 1
	    mode = mode_from_discipline(*svp);
d5830 1
a5830 1
	    mode = mode_from_discipline(*svp);
d5842 2
a5843 2
	 OP *first = cLISTOPx(o)->op_first; /* The pushmark. */
	 OP *last  = cLISTOPx(o)->op_last;  /* The bareword. */
d5845 1
a5845 1
	 char *mode;
d5852 1
d5854 1
a5854 1
	     (mode = SvPVX(((SVOP*)oa)->op_sv)) &&
d5880 1
a5880 1
	SVOP *kid = (SVOP*)cUNOPo->op_first;
d5883 2
d5886 12
a5897 1
	    for (s = SvPVX(kid->op_sv); *s; s++) {
d5901 1
a5901 1
		    --SvCUR(kid->op_sv);
d5904 2
a5905 7
	    if (SvREADONLY(kid->op_sv)) {
		SvREADONLY_off(kid->op_sv);
		sv_catpvn(kid->op_sv, ".pm", 3);
		SvREADONLY_on(kid->op_sv);
	    }
	    else
		sv_catpvn(kid->op_sv, ".pm", 3);
d5915 1
a5915 1
	OP *kid = cUNOPo->op_first;
a5930 1
    OP *kid;
d5932 1
d5972 1
a5972 1
    I32 type = o->op_type;
d6067 1
d6094 2
a6095 1
    if (strEQ(GvNAME(gv), "a"))
d6097 1
a6097 1
    else if (strEQ(GvNAME(gv), "b"))
d6110 6
a6115 4
    if (GvSTASH(gv) != PL_curstash
	|| ( descending
	    ? strNE(GvNAME(gv), "a")
	    : strNE(GvNAME(gv), "b")))
d6149 1
a6149 1
	OP *sibl = kid->op_sibling;
d6161 1
a6161 1
    if (ckWARN(WARN_REGEXP) && ((PMOP *)kid)->op_pmflags & PMf_GLOBAL) {
d6187 5
a6191 6
    if (ckWARN(WARN_SYNTAX)) {
	OP *kid = cLISTOPo->op_first->op_sibling;
	if (kid && kid->op_type == OP_MATCH) {
	    char *pmstr = "STRING";
	    if (PM_GETRE(kPMOP))
		pmstr = PM_GETRE(kPMOP)->precomp;
a6213 1
    STRLEN n_a;
d6229 1
a6229 1
		proto = SvPV((SV*)cv, n_a);
d6237 1
a6237 1
	    OP *o = ((UNOP*)o2)->op_first->op_sibling;
d6293 3
a6295 3
				GV *gv = cGVOPx_gv(gvop);
				OP *sibling = o2->op_sibling;
				SV *n = newSVpvn("",0);
d6297 1
a6297 3
				gv_fullname3(n, gv, "");
				if (SvCUR(n)>6 && strnEQ(SvPVX(n),"main::",6))
				    sv_chop(n, SvPVX(n)+6);
d6327 2
a6328 2
			 char *p = proto;
			 char s = *p;
d6376 2
a6377 2
			OP* kid = o2;
			OP* sib = kid->op_sibling;
d6407 1
a6407 1
    }
d6495 1
a6495 1
		PADOFFSET ix = pad_alloc(OP_CONST, SVs_PADTMP);
d6616 2
a6617 2
		GV *gv = cGVOPo_gv;
		if (SvTYPE(gv) == SVt_PVGV && GvCV(gv) && SvPVX(GvCV(gv))) {
d6619 1
a6619 1
		    SV *sv = sv_newmortal();
d6681 3
a6683 2
	    if (ckWARN(WARN_SYNTAX) && o->op_next
		&& o->op_next->op_type == OP_NEXTSTATE) {
d6688 1
a6688 1
		    line_t oldline = CopLINE(PL_curcop);
d6706 1
a6706 1
	    char *key = NULL;
d6717 1
a6717 1
		key = SvPV(sv, keylen);
d6737 1
a6737 1
	    key = SvPV(*svp, keylen);
d6741 4
a6744 2
		Perl_croak(aTHX_ "No such pseudo-hash field \"%s\" in variable %s of type %s",
		      key, SvPV(lexname, n_a), HvNAME(SvSTASH(lexname)));
d6769 1
a6769 1
	    char *key;
d6805 1
a6805 1
		key = SvPV(*svp, keylen);
d6811 1
a6811 1
			  key, SvPV(lexname, n_a), HvNAME(SvSTASH(lexname)));
d6829 1
a6829 1
	    OP *oleft, *oright;
d6833 1
a6833 1
	    oright = cUNOPo->op_first;
d6840 1
a6840 1
		OP *reverse = o->op_next;
d6844 1
a6844 1
		    OP *pushmark = cUNOPx(reverse)->op_first;
d7045 2
a7046 3


char* Perl_custom_op_name(pTHX_ OP* o)
d7048 1
a7048 1
    IV  index = PTR2IV(o->op_ppaddr);
d7053 1
a7053 1
        return PL_op_name[OP_CUSTOM];
d7059 1
a7059 1
        return PL_op_name[OP_CUSTOM]; /* Don't know who you are */
d7064 2
a7065 1
char* Perl_custom_op_desc(pTHX_ OP* o)
d7067 1
a7067 1
    IV  index = PTR2IV(o->op_ppaddr);
d7072 1
a7072 1
        return PL_op_desc[OP_CUSTOM];
d7078 1
a7078 1
        return PL_op_desc[OP_CUSTOM];
a7082 1

d7093 1
a7093 1
                   HvNAME(GvSTASH(CvGV(cv))), GvNAME(CvGV(cv)));
d7100 10
@


1.10
log
@sync in-tree perl with 5.8.6
@
text
@a2066 1
    case OP_SPRINTF:
@


1.10.2.1
log
@MFC:
Fix by brad@@

The official fix for the Perl sprintf buffer overflow.
@
text
@d2067 1
@


1.10.4.1
log
@MFC:
Fix by brad@@

The official fix for the Perl sprintf buffer overflow.
@
text
@d2067 1
@


1.9
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d19 56
d4858 2
a4859 1
/* Check routines. */
d6025 1
a6025 1
    int reversed;
d6054 1
a6054 1
	reversed = 0;
d6056 1
a6056 1
	reversed = 1;
d6059 1
d6069 1
a6069 1
	|| ( reversed
d6074 2
a6075 2
    if (reversed)
	o->op_private |= OPpSORT_REVERSE;
d6415 3
a6417 1
/* A peephole optimizer.  We visit the ops in the order they're to execute. */
a6784 2
	    /* make @@a = sort @@a act in-place */

a6788 2
	    o->op_seq = PL_op_seqmax++;

d6793 24
a6901 1
	
d6903 76
d6980 13
@


1.8
log
@merge local changes into perl-5.8.3
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, by Larry Wall and others
d354 2
d357 6
a362 6
	if (cPADOPo->op_padix > 0) {
	    /* No GvIN_PAD_off(cGVOPo_gv) here, because other references
	     * may still exist on the pad */
	    pad_swipe(cPADOPo->op_padix, TRUE);
	    cPADOPo->op_padix = 0;
	}
d364 2
a365 2
	SvREFCNT_dec(cSVOPo->op_sv);
	cSVOPo->op_sv = Nullsv;
d367 1
d376 1
a376 1
	  pad_free doesn't actually remove the sv that exists in the bad
d756 4
d763 1
a763 1
		if (SvNIOK(sv) && (SvNV(sv) == 0.0 || SvNV(sv) == 1.0))
d1172 3
d1812 1
d1816 1
a1816 4
    SAVEI32(PL_hints);
    SAVESPTR(GvHV(PL_hintgv));
    GvHV(PL_hintgv) = newHVhv(GvHV(PL_hintgv));
    SAVEFREESV(GvHV(PL_hintgv));
d1930 1
a1930 1
	    int sigil = 0;
d1933 1
a1933 2
	    while (*s && (strchr(", \t\n", *s)
			|| (strchr("@@$%*", *s) && ++sigil) ))
d1935 4
a1938 3
	    if (sigil) {
		while (*s && (isALNUM(*s) || UTF8_IS_CONTINUED(*s)
			    || strchr("@@$%*, \t\n", *s)))
d1940 11
a1950 3

		if (*s == ';' || *s == '=')
		    Perl_warner(aTHX_ packWARN(WARN_PARENTHESIS),
d3202 9
d3452 3
a3454 4
	if (ckWARN(WARN_BAREWORD) && (first->op_private & OPpCONST_BARE)) {
	    if (first->op_private & OPpCONST_STRICT)
		no_bareword_allowed(first);
	    else
a3455 1
	}
d3459 2
d3466 2
d3675 4
d4000 2
d4113 1
a4113 1
    char *ps = proto ? SvPVx(((SVOP*)proto)->op_sv, n_a) : Nullch;
d4118 8
d4283 2
d5477 1
d5507 1
a5507 1
	for (k = cLISTOPo->op_first->op_sibling->op_next; k; k = k->op_next) {
d5673 13
d6467 1
d6469 3
a6471 12
	    if (o->op_next->op_type == OP_RV2SV) {
		if (!(o->op_next->op_private & OPpDEREF)) {
		    op_null(o->op_next);
		    o->op_private |= o->op_next->op_private & (OPpLVAL_INTRO
							       | OPpOUR_INTRO);
		    o->op_next = o->op_next->op_next;
		    o->op_type = OP_GVSV;
		    o->op_ppaddr = PL_ppaddr[OP_GVSV];
		}
	    }
	    else if (o->op_next->op_type == OP_RV2AV) {
		OP* pop = o->op_next->op_next;
d6474 1
a6474 1
		    (PL_op = pop->op_next) &&
d6483 4
a6486 1
		    op_null(o->op_next);
a6490 1
		    o->op_type = OP_AELEMFAST;
d6493 20
a6512 2
		    gv = cGVOPo_gv;
		    GvAVn(gv);
d6723 101
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d1880 1
d4303 5
d4806 2
a4807 1
    if (kid->op_type == OP_CONCAT && !(kUNOP->op_first->op_flags & OPf_MOD))
d5339 1
a5339 2
					   name = savepv(SvPVX(tmpstr));
					   len = strlen(name);
a6377 11
	    if(!oldop &&
	       o->op_next &&
	       o->op_next->op_type == OP_LEAVESUB) {
	      OP* newop = newSTATEOP(0, Nullch, 0);
	       newop->op_next = o->op_next;
	       o->op_next = 0;
       	       op_free(o);
	       o = newop;
       	       ((UNOP*)o->op_next)->op_first = newop;	
	       CvSTART(PL_compcv) = newop;	
	    }
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 2
a4 1
 *    Copyright (c) 1991-2002, Larry Wall
d33 2
a34 7
#define NewOp(m,var,c,type) \
	STMT_START { var = (type *) Slab_Alloc(m,c*sizeof(type)); } STMT_END

#define FreeOp(p) Slab_Free(p)

STATIC void *
S_Slab_Alloc(pTHX_ int m, size_t sz)
d72 2
a73 2
STATIC void
S_Slab_Free(pTHX_ void *op)
d81 3
a83 3
     #ifdef NETWARE
      #define PerlMemShared PerlMem
     #endif
a90 4

#else
#define NewOp(m, var, c, type) Newz(m, var, c, type)
#define FreeOp(p) Safefree(p)
d99 1
a99 1
	 Perl_croak(aTHX_ "%s trapped by operation mask", PL_op_desc[type]),	\
a102 1
#define PAD_MAX 999999999
d147 2
a148 2
		     "Bareword \"%s\" not allowed while \"strict subs\" in use",
		     SvPV_nolen(cSVOPo_sv)));
d154 1
a154 1
Perl_pad_allocmy(pTHX_ char *name)
a156 1
    SV *sv;
d158 1
d185 22
a206 66
    if (ckWARN(WARN_MISC) && AvFILLp(PL_comppad_name) >= 0) {
	SV **svp = AvARRAY(PL_comppad_name);
	HV *ourstash = (PL_curstash ? PL_curstash : PL_defstash);
	PADOFFSET top = AvFILLp(PL_comppad_name);
	for (off = top; (I32)off > PL_comppad_name_floor; off--) {
	    if ((sv = svp[off])
		&& sv != &PL_sv_undef
		&& (SvIVX(sv) == PAD_MAX || SvIVX(sv) == 0)
		&& (PL_in_my != KEY_our
		    || ((SvFLAGS(sv) & SVpad_OUR) && GvSTASH(sv) == ourstash))
		&& strEQ(name, SvPVX(sv)))
	    {
		Perl_warner(aTHX_ packWARN(WARN_MISC),
		    "\"%s\" variable %s masks earlier declaration in same %s",
		    (PL_in_my == KEY_our ? "our" : "my"),
		    name,
		    (SvIVX(sv) == PAD_MAX ? "scope" : "statement"));
		--off;
		break;
	    }
	}
	if (PL_in_my == KEY_our) {
	    do {
		if ((sv = svp[off])
		    && sv != &PL_sv_undef
		    && (SvIVX(sv) == PAD_MAX || SvIVX(sv) == 0)
		    && ((SvFLAGS(sv) & SVpad_OUR) && GvSTASH(sv) == ourstash)
		    && strEQ(name, SvPVX(sv)))
		{
		    Perl_warner(aTHX_ packWARN(WARN_MISC),
			"\"our\" variable %s redeclared", name);
		    Perl_warner(aTHX_ packWARN(WARN_MISC),
			"\t(Did you mean \"local\" instead of \"our\"?)\n");
		    break;
		}
	    } while ( off-- > 0 );
	}
    }
    off = pad_alloc(OP_PADSV, SVs_PADMY);
    sv = NEWSV(1102,0);
    sv_upgrade(sv, SVt_PVNV);
    sv_setpv(sv, name);
    if (PL_in_my_stash) {
	if (*name != '$')
	    yyerror(Perl_form(aTHX_ "Can't declare class for non-scalar %s in \"%s\"",
			 name, PL_in_my == KEY_our ? "our" : "my"));
	SvFLAGS(sv) |= SVpad_TYPED;
	(void)SvUPGRADE(sv, SVt_PVMG);
	SvSTASH(sv) = (HV*)SvREFCNT_inc(PL_in_my_stash);
    }
    if (PL_in_my == KEY_our) {
	(void)SvUPGRADE(sv, SVt_PVGV);
	GvSTASH(sv) = (HV*)SvREFCNT_inc(PL_curstash ? (SV*)PL_curstash : (SV*)PL_defstash);
	SvFLAGS(sv) |= SVpad_OUR;
    }
    av_store(PL_comppad_name, off, sv);
    SvNVX(sv) = (NV)PAD_MAX;
    SvIVX(sv) = 0;			/* Not yet introduced--see newSTATEOP */
    if (!PL_min_intro_pending)
	PL_min_intro_pending = off;
    PL_max_intro_pending = off;
    if (*name == '@@')
	av_store(PL_comppad, off, (SV*)newAV());
    else if (*name == '%')
	av_store(PL_comppad, off, (SV*)newHV());
    SvPADMY_on(PL_curpad[off]);
a209 411
STATIC PADOFFSET
S_pad_addlex(pTHX_ SV *proto_namesv)
{
    SV *namesv = NEWSV(1103,0);
    PADOFFSET newoff = pad_alloc(OP_PADSV, SVs_PADMY);
    sv_upgrade(namesv, SVt_PVNV);
    sv_setpv(namesv, SvPVX(proto_namesv));
    av_store(PL_comppad_name, newoff, namesv);
    SvNVX(namesv) = (NV)PL_curcop->cop_seq;
    SvIVX(namesv) = PAD_MAX;			/* A ref, intro immediately */
    SvFAKE_on(namesv);				/* A ref, not a real var */
    if (SvFLAGS(proto_namesv) & SVpad_OUR) {	/* An "our" variable */
	SvFLAGS(namesv) |= SVpad_OUR;
	(void)SvUPGRADE(namesv, SVt_PVGV);
	GvSTASH(namesv) = (HV*)SvREFCNT_inc((SV*)GvSTASH(proto_namesv));
    }
    if (SvFLAGS(proto_namesv) & SVpad_TYPED) {	/* A typed lexical */
	SvFLAGS(namesv) |= SVpad_TYPED;
	(void)SvUPGRADE(namesv, SVt_PVMG);
	SvSTASH(namesv) = (HV*)SvREFCNT_inc((SV*)SvSTASH(proto_namesv));
    }
    return newoff;
}

#define FINDLEX_NOSEARCH	1		/* don't search outer contexts */

STATIC PADOFFSET
S_pad_findlex(pTHX_ char *name, PADOFFSET newoff, U32 seq, CV* startcv,
	    I32 cx_ix, I32 saweval, U32 flags)
{
    CV *cv;
    I32 off;
    SV *sv;
    register I32 i;
    register PERL_CONTEXT *cx;

    for (cv = startcv; cv; cv = CvOUTSIDE(cv)) {
	AV *curlist = CvPADLIST(cv);
	SV **svp = av_fetch(curlist, 0, FALSE);
	AV *curname;

	if (!svp || *svp == &PL_sv_undef)
	    continue;
	curname = (AV*)*svp;
	svp = AvARRAY(curname);
	for (off = AvFILLp(curname); off > 0; off--) {
	    if ((sv = svp[off]) &&
		sv != &PL_sv_undef &&
		seq <= (U32)SvIVX(sv) &&
		seq > (U32)I_32(SvNVX(sv)) &&
		strEQ(SvPVX(sv), name))
	    {
		I32 depth;
		AV *oldpad;
		SV *oldsv;

		depth = CvDEPTH(cv);
		if (!depth) {
		    if (newoff) {
			if (SvFAKE(sv))
			    continue;
			return 0; /* don't clone from inactive stack frame */
		    }
		    depth = 1;
		}
		oldpad = (AV*)AvARRAY(curlist)[depth];
		oldsv = *av_fetch(oldpad, off, TRUE);
		if (!newoff) {		/* Not a mere clone operation. */
		    newoff = pad_addlex(sv);
		    if (CvANON(PL_compcv) || SvTYPE(PL_compcv) == SVt_PVFM) {
			/* "It's closures all the way down." */
			CvCLONE_on(PL_compcv);
			if (cv == startcv) {
			    if (CvANON(PL_compcv))
				oldsv = Nullsv; /* no need to keep ref */
			}
			else {
			    CV *bcv;
			    for (bcv = startcv;
				 bcv && bcv != cv && !CvCLONE(bcv);
				 bcv = CvOUTSIDE(bcv))
			    {
				if (CvANON(bcv)) {
				    /* install the missing pad entry in intervening
				     * nested subs and mark them cloneable.
				     * XXX fix pad_foo() to not use globals */
				    AV *ocomppad_name = PL_comppad_name;
				    AV *ocomppad = PL_comppad;
				    SV **ocurpad = PL_curpad;
				    AV *padlist = CvPADLIST(bcv);
				    PL_comppad_name = (AV*)AvARRAY(padlist)[0];
				    PL_comppad = (AV*)AvARRAY(padlist)[1];
				    PL_curpad = AvARRAY(PL_comppad);
				    pad_addlex(sv);
				    PL_comppad_name = ocomppad_name;
				    PL_comppad = ocomppad;
				    PL_curpad = ocurpad;
				    CvCLONE_on(bcv);
				}
				else {
				    if (ckWARN(WARN_CLOSURE)
					&& !CvUNIQUE(bcv) && !CvUNIQUE(cv))
				    {
					Perl_warner(aTHX_ packWARN(WARN_CLOSURE),
					  "Variable \"%s\" may be unavailable",
					     name);
				    }
				    break;
				}
			    }
			}
		    }
		    else if (!CvUNIQUE(PL_compcv)) {
			if (ckWARN(WARN_CLOSURE) && !SvFAKE(sv) && !CvUNIQUE(cv)
			    && !(SvFLAGS(sv) & SVpad_OUR))
			{
			    Perl_warner(aTHX_ packWARN(WARN_CLOSURE),
				"Variable \"%s\" will not stay shared", name);
			}
		    }
		}
		av_store(PL_comppad, newoff, SvREFCNT_inc(oldsv));
		return newoff;
	    }
	}
    }

    if (flags & FINDLEX_NOSEARCH)
	return 0;

    /* Nothing in current lexical context--try eval's context, if any.
     * This is necessary to let the perldb get at lexically scoped variables.
     * XXX This will also probably interact badly with eval tree caching.
     */

    for (i = cx_ix; i >= 0; i--) {
	cx = &cxstack[i];
	switch (CxTYPE(cx)) {
	default:
	    if (i == 0 && saweval) {
		return pad_findlex(name, newoff, seq, PL_main_cv, -1, saweval, 0);
	    }
	    break;
	case CXt_EVAL:
	    switch (cx->blk_eval.old_op_type) {
	    case OP_ENTEREVAL:
		if (CxREALEVAL(cx)) {
		    PADOFFSET off;
		    saweval = i;
		    seq = cxstack[i].blk_oldcop->cop_seq;
		    startcv = cxstack[i].blk_eval.cv;
		    if (startcv && CvOUTSIDE(startcv)) {
			off = pad_findlex(name, newoff, seq, CvOUTSIDE(startcv),
					  i-1, saweval, 0);
			if (off)	/* continue looking if not found here */
			    return off;
		    }
		}
		break;
	    case OP_DOFILE:
	    case OP_REQUIRE:
		/* require/do must have their own scope */
		return 0;
	    }
	    break;
	case CXt_FORMAT:
	case CXt_SUB:
	    if (!saweval)
		return 0;
	    cv = cx->blk_sub.cv;
	    if (PL_debstash && CvSTASH(cv) == PL_debstash) {	/* ignore DB'* scope */
		saweval = i;	/* so we know where we were called from */
		seq = cxstack[i].blk_oldcop->cop_seq;
		continue;
	    }
	    return pad_findlex(name, newoff, seq, cv, i-1, saweval,FINDLEX_NOSEARCH);
	}
    }

    return 0;
}

PADOFFSET
Perl_pad_findmy(pTHX_ char *name)
{
    I32 off;
    I32 pendoff = 0;
    SV *sv;
    SV **svp = AvARRAY(PL_comppad_name);
    U32 seq = PL_cop_seqmax;
    PERL_CONTEXT *cx;
    CV *outside;

#ifdef USE_5005THREADS
    /*
     * Special case to get lexical (and hence per-thread) @@_.
     * XXX I need to find out how to tell at parse-time whether use
     * of @@_ should refer to a lexical (from a sub) or defgv (global
     * scope and maybe weird sub-ish things like formats). See
     * startsub in perly.y.  It's possible that @@_ could be lexical
     * (at least from subs) even in non-threaded perl.
     */
    if (strEQ(name, "@@_"))
	return 0;		/* success. (NOT_IN_PAD indicates failure) */
#endif /* USE_5005THREADS */

    /* The one we're looking for is probably just before comppad_name_fill. */
    for (off = AvFILLp(PL_comppad_name); off > 0; off--) {
	if ((sv = svp[off]) &&
	    sv != &PL_sv_undef &&
	    (!SvIVX(sv) ||
	     (seq <= (U32)SvIVX(sv) &&
	      seq > (U32)I_32(SvNVX(sv)))) &&
	    strEQ(SvPVX(sv), name))
	{
	    if (SvIVX(sv) || SvFLAGS(sv) & SVpad_OUR)
		return (PADOFFSET)off;
	    pendoff = off;	/* this pending def. will override import */
	}
    }

    outside = CvOUTSIDE(PL_compcv);

    /* Check if if we're compiling an eval'', and adjust seq to be the
     * eval's seq number.  This depends on eval'' having a non-null
     * CvOUTSIDE() while it is being compiled.  The eval'' itself is
     * identified by CvEVAL being true and CvGV being null. */
    if (outside && CvEVAL(PL_compcv) && !CvGV(PL_compcv) && cxstack_ix >= 0) {
	cx = &cxstack[cxstack_ix];
	if (CxREALEVAL(cx))
	    seq = cx->blk_oldcop->cop_seq;
    }

    /* See if it's in a nested scope */
    off = pad_findlex(name, 0, seq, outside, cxstack_ix, 0, 0);
    if (off) {
	/* If there is a pending local definition, this new alias must die */
	if (pendoff)
	    SvIVX(AvARRAY(PL_comppad_name)[off]) = seq;
	return off;		/* pad_findlex returns 0 for failure...*/
    }
    return NOT_IN_PAD;		/* ...but we return NOT_IN_PAD for failure */
}

void
Perl_pad_leavemy(pTHX_ I32 fill)
{
    I32 off;
    SV **svp = AvARRAY(PL_comppad_name);
    SV *sv;
    if (PL_min_intro_pending && fill < PL_min_intro_pending) {
	for (off = PL_max_intro_pending; off >= PL_min_intro_pending; off--) {
	    if ((sv = svp[off]) && sv != &PL_sv_undef && ckWARN_d(WARN_INTERNAL))
		Perl_warner(aTHX_ packWARN(WARN_INTERNAL), "%s never introduced", SvPVX(sv));
	}
    }
    /* "Deintroduce" my variables that are leaving with this scope. */
    for (off = AvFILLp(PL_comppad_name); off > fill; off--) {
	if ((sv = svp[off]) && sv != &PL_sv_undef && SvIVX(sv) == PAD_MAX)
	    SvIVX(sv) = PL_cop_seqmax;
    }
}

PADOFFSET
Perl_pad_alloc(pTHX_ I32 optype, U32 tmptype)
{
    SV *sv;
    I32 retval;

    if (AvARRAY(PL_comppad) != PL_curpad)
	Perl_croak(aTHX_ "panic: pad_alloc");
    if (PL_pad_reset_pending)
	pad_reset();
    if (tmptype & SVs_PADMY) {
	do {
	    sv = *av_fetch(PL_comppad, AvFILLp(PL_comppad) + 1, TRUE);
	} while (SvPADBUSY(sv));		/* need a fresh one */
	retval = AvFILLp(PL_comppad);
    }
    else {
	SV **names = AvARRAY(PL_comppad_name);
	SSize_t names_fill = AvFILLp(PL_comppad_name);
	for (;;) {
	    /*
	     * "foreach" index vars temporarily become aliases to non-"my"
	     * values.  Thus we must skip, not just pad values that are
	     * marked as current pad values, but also those with names.
	     */
	    if (++PL_padix <= names_fill &&
		   (sv = names[PL_padix]) && sv != &PL_sv_undef)
		continue;
	    sv = *av_fetch(PL_comppad, PL_padix, TRUE);
	    if (!(SvFLAGS(sv) & (SVs_PADTMP|SVs_PADMY)) &&
		!IS_PADGV(sv) && !IS_PADCONST(sv))
		break;
	}
	retval = PL_padix;
    }
    SvFLAGS(sv) |= tmptype;
    PL_curpad = AvARRAY(PL_comppad);
#ifdef USE_5005THREADS
    DEBUG_X(PerlIO_printf(Perl_debug_log,
			  "0x%"UVxf" Pad 0x%"UVxf" alloc %ld for %s\n",
			  PTR2UV(thr), PTR2UV(PL_curpad),
			  (long) retval, PL_op_name[optype]));
#else
    DEBUG_X(PerlIO_printf(Perl_debug_log,
			  "Pad 0x%"UVxf" alloc %ld for %s\n",
			  PTR2UV(PL_curpad),
			  (long) retval, PL_op_name[optype]));
#endif /* USE_5005THREADS */
    return (PADOFFSET)retval;
}

SV *
Perl_pad_sv(pTHX_ PADOFFSET po)
{
#ifdef USE_5005THREADS
    DEBUG_X(PerlIO_printf(Perl_debug_log,
			  "0x%"UVxf" Pad 0x%"UVxf" sv %"IVdf"\n",
			  PTR2UV(thr), PTR2UV(PL_curpad), (IV)po));
#else
    if (!po)
	Perl_croak(aTHX_ "panic: pad_sv po");
    DEBUG_X(PerlIO_printf(Perl_debug_log, "Pad 0x%"UVxf" sv %"IVdf"\n",
			  PTR2UV(PL_curpad), (IV)po));
#endif /* USE_5005THREADS */
    return PL_curpad[po];		/* eventually we'll turn this into a macro */
}

void
Perl_pad_free(pTHX_ PADOFFSET po)
{
    if (!PL_curpad)
	return;
    if (AvARRAY(PL_comppad) != PL_curpad)
	Perl_croak(aTHX_ "panic: pad_free curpad");
    if (!po)
	Perl_croak(aTHX_ "panic: pad_free po");
#ifdef USE_5005THREADS
    DEBUG_X(PerlIO_printf(Perl_debug_log,
			  "0x%"UVxf" Pad 0x%"UVxf" free %"IVdf"\n",
			  PTR2UV(thr), PTR2UV(PL_curpad), (IV)po));
#else
    DEBUG_X(PerlIO_printf(Perl_debug_log, "Pad 0x%"UVxf" free %"IVdf"\n",
			  PTR2UV(PL_curpad), (IV)po));
#endif /* USE_5005THREADS */
    if (PL_curpad[po] && PL_curpad[po] != &PL_sv_undef) {
	SvPADTMP_off(PL_curpad[po]);
#ifdef USE_ITHREADS
	SvREADONLY_off(PL_curpad[po]);	/* could be a freed constant */
#endif
    }
    if ((I32)po < PL_padix)
	PL_padix = po - 1;
}

void
Perl_pad_swipe(pTHX_ PADOFFSET po)
{
    if (AvARRAY(PL_comppad) != PL_curpad)
	Perl_croak(aTHX_ "panic: pad_swipe curpad");
    if (!po)
	Perl_croak(aTHX_ "panic: pad_swipe po");
#ifdef USE_5005THREADS
    DEBUG_X(PerlIO_printf(Perl_debug_log,
			  "0x%"UVxf" Pad 0x%"UVxf" swipe %"IVdf"\n",
			  PTR2UV(thr), PTR2UV(PL_curpad), (IV)po));
#else
    DEBUG_X(PerlIO_printf(Perl_debug_log, "Pad 0x%"UVxf" swipe %"IVdf"\n",
			  PTR2UV(PL_curpad), (IV)po));
#endif /* USE_5005THREADS */
    SvPADTMP_off(PL_curpad[po]);
    PL_curpad[po] = NEWSV(1107,0);
    SvPADTMP_on(PL_curpad[po]);
    if ((I32)po < PL_padix)
	PL_padix = po - 1;
}

/* XXX pad_reset() is currently disabled because it results in serious bugs.
 * It causes pad temp TARGs to be shared between OPs. Since TARGs are pushed
 * on the stack by OPs that use them, there are several ways to get an alias
 * to  a shared TARG.  Such an alias will change randomly and unpredictably.
 * We avoid doing this until we can think of a Better Way.
 * GSAR 97-10-29 */
void
Perl_pad_reset(pTHX)
{
#ifdef USE_BROKEN_PAD_RESET
    register I32 po;

    if (AvARRAY(PL_comppad) != PL_curpad)
	Perl_croak(aTHX_ "panic: pad_reset curpad");
#ifdef USE_5005THREADS
    DEBUG_X(PerlIO_printf(Perl_debug_log,
			  "0x%"UVxf" Pad 0x%"UVxf" reset\n",
			  PTR2UV(thr), PTR2UV(PL_curpad)));
#else
    DEBUG_X(PerlIO_printf(Perl_debug_log, "Pad 0x%"UVxf" reset\n",
			  PTR2UV(PL_curpad)));
#endif /* USE_5005THREADS */
    if (!PL_tainting) {	/* Can't mix tainted and non-tainted temporaries. */
	for (po = AvMAX(PL_comppad); po > PL_padix_floor; po--) {
	    if (PL_curpad[po] && !SvIMMORTAL(PL_curpad[po]))
		SvPADTMP_off(PL_curpad[po]);
	}
	PL_padix = PL_padix_floor;
    }
#endif
    PL_pad_reset_pending = FALSE;
}
d356 3
a358 7
	    if (PL_curpad) {
		GV *gv = cGVOPo_gv;
		pad_swipe(cPADOPo->op_padix);
		/* No GvIN_PAD_off(gv) here, because other references may still
		 * exist on the pad */
		SvREFCNT_dec(gv);
	    }
d370 12
d406 3
a408 7
	    if (PL_curpad) {
		GV *gv = (GV*)PL_curpad[INT2PTR(PADOFFSET, cPMOPo->op_pmreplroot)];
		pad_swipe(INT2PTR(PADOFFSET, cPMOPo->op_pmreplroot));
		/* No GvIN_PAD_off(gv) here, because other references may still
		 * exist on the pad */
		SvREFCNT_dec(gv);
	    }
d731 1
a960 1
    STRLEN n_a;
a1134 2
	if (!type && cUNOPo->op_first->op_type != OP_GV)
	    Perl_croak(aTHX_ "Can't localize through a reference");
a1152 1
    case OP_CHOMP:
a1155 2
	if (!type && cUNOPo->op_first->op_type != OP_GV)
	    Perl_croak(aTHX_ "Can't localize through a reference");
d1181 4
d1186 2
a1187 1
		SvPV(*av_fetch(PL_comppad_name, o->op_targ, 4), n_a));
d1531 1
a1531 1
    apply_attrs(stash, pad_sv(target->op_targ), attrs, TRUE);
d1631 13
a1643 13
      if (cUNOPo->op_first->op_type != OP_GV) { /* MJD 20011224 */
           yyerror(Perl_form(aTHX_ "Can't declare %s in my", OP_DESC(o)));
        }
        if (attrs) {
            GV *gv = cGVOPx_gv(cUNOPo->op_first);
            PL_in_my = FALSE;
            PL_in_my_stash = Nullhv;
            apply_attrs(GvSTASH(gv),
                        (type == OP_RV2SV ? GvSV(gv) :
                         type == OP_RV2AV ? (SV*)GvAV(gv) :
                         type == OP_RV2HV ? (SV*)GvHV(gv) : (SV*)gv),
                        attrs, FALSE);
        }
a1658 1
	SV **namesvp;
d1664 2
a1665 4
	namesvp = av_fetch(PL_comppad_name, o->op_targ, FALSE);
	if (namesvp && *namesvp && (SvFLAGS(*namesvp) & SVpad_TYPED))
	    stash = SvSTASH(*namesvp);
	else
d1680 3
d1687 3
d1788 7
a1794 11
	else {
	    if (o->op_type == OP_LINESEQ) {
		OP *kid;
		o->op_type = OP_SCOPE;
		o->op_ppaddr = PL_ppaddr[OP_SCOPE];
		kid = ((LISTOP*)o)->op_first;
		if (kid->op_type == OP_NEXTSTATE || kid->op_type == OP_DBSTATE)
		    op_null(kid);
	    }
	    else
		o = newLISTOP(OP_SCOPE, 0, o, Nullop);
d1796 2
d1815 2
d1818 1
a1818 13
    SAVEI32(PL_comppad_name_floor);
    PL_comppad_name_floor = AvFILLp(PL_comppad_name);
    if (full)
	PL_comppad_name_fill = PL_comppad_name_floor;
    if (PL_comppad_name_floor < 0)
	PL_comppad_name_floor = 0;
    SAVEI32(PL_min_intro_pending);
    SAVEI32(PL_max_intro_pending);
    PL_min_intro_pending = 0;
    SAVEI32(PL_comppad_name_fill);
    SAVEI32(PL_padix_floor);
    PL_padix_floor = PL_padix;
    PL_pad_reset_pending = FALSE;
d1838 3
a1840 4
    line_t copline = PL_copline;
    /* there should be a nextstate in every block */
    OP* retval = seq ? scalarseq(seq) : newSTATEOP(0, Nullch, seq);
    PL_copline = copline;  /* XXX newSTATEOP may reset PL_copline */
a1841 1
    PL_pad_reset_pending = FALSE;
d1845 1
a1845 2
    pad_leavemy(PL_comppad_name_fill);
    PL_cop_seqmax++;
d1877 3
a1879 1
	if (!o)
d1881 1
d1909 3
d1913 3
d1921 1
d1923 3
a1925 1
	    while (*s && (isALNUM(*s) || UTF8_IS_CONTINUED(*s) || strchr("@@$%, ", *s)))
d1927 11
a1937 5

	    if (*s == ';' || *s == '=')
		Perl_warner(aTHX_ packWARN(WARN_PARENTHESIS),
			    "Parentheses missing around \"%s\" list",
			    lex ? (PL_in_my == KEY_our ? "our" : "my") : "local");
d2030 1
a2030 1
	pad_swipe(o->op_targ);
d2038 1
a2038 13
    else {
	/* try to smush double to int, but don't smush -2.0 to -2 */
	if ((SvFLAGS(sv) & (SVf_IOK|SVf_NOK|SVf_POK)) == SVf_NOK &&
	    type != OP_NEGATE)
	{
#ifdef PERL_PRESERVE_IVUV
	    /* Only bother to attempt to fold to IV if
	       most operators will benefit  */
	    SvIV_please(sv);
#endif
	}
	return newSVOP(OP_CONST, 0, sv);
    }
d2065 2
d2227 1
a2227 1
    return (OP*)listop;
d2350 7
a2356 7
	U32 tfirst = 1;
	U32 tlast = 0;
	I32 tdiff;
	U32 rfirst = 1;
	U32 rlast = 0;
	I32 rdiff;
	I32 diff;
d2664 1
a2664 1
    return (OP*)pmop;
d2730 1
a2730 1
	    if (CopLINE(PL_curcop) < PL_multi_end)
d2757 1
a2757 1
			if (strchr("&`'123456789+", *GvENAME(gv)))
d2843 4
a2846 3
    SvREFCNT_dec(PL_curpad[padop->op_padix]);
    PL_curpad[padop->op_padix] = sv;
    SvPADTMP_on(sv);
d2860 2
a2861 1
    GvIN_PAD_on(gv);
d2912 1
a2912 1
Perl_utilize(pTHX_ int aver, I32 floor, OP *version, OP *id, OP *arg)
d2918 1
a2918 1
    if (id->op_type != OP_CONST)
d2936 2
a2937 2
	    /* Make copy of id so we don't free it twice */
	    pack = newSVOP(OP_CONST, 0, newSVsv(((SVOP*)id)->op_sv));
d2954 1
a2954 1
    else if (SvNIOKp(((SVOP*)id)->op_sv)) {
d2960 2
a2961 2
	/* Make copy of id so we don't free it twice */
	pack = newSVOP(OP_CONST, 0, newSVsv(((SVOP*)id)->op_sv));
d2981 1
a2981 1
	        newSTATEOP(0, Nullch, newUNOP(OP_REQUIRE, 0, id)),
d3005 1
d3074 1
d3081 1
d3197 15
d3226 4
a3229 4
			     curop->op_type == OP_PADANY) {
			SV **svp = AvARRAY(PL_comppad_name);
			SV *sv = svp[curop->op_targ];
			if ((int)SvCUR(sv) == PL_generation)
d3231 3
a3233 1
			SvCUR(sv) = PL_generation;	/* (SvCUR not used any more) */
d3247 2
a3248 1
			    GV *gv = (GV*)PL_curpad[INT2PTR(PADOFFSET,((PMOP*)curop)->op_pmreplroot)];
a3390 22
/* "Introduce" my variables to visible status. */
U32
Perl_intro_my(pTHX)
{
    SV **svp;
    SV *sv;
    I32 i;

    if (! PL_min_intro_pending)
	return PL_cop_seqmax;

    svp = AvARRAY(PL_comppad_name);
    for (i = PL_min_intro_pending; i <= PL_max_intro_pending; i++) {
	if ((sv = svp[i]) && sv != &PL_sv_undef && !SvIVX(sv)) {
	    SvIVX(sv) = PAD_MAX;	/* Don't know scope end yet. */
	    SvNVX(sv) = (NV)PL_cop_seqmax;
	}
    }
    PL_min_intro_pending = 0;
    PL_comppad_name_fill = PL_max_intro_pending;	/* Needn't search higher */
    return PL_cop_seqmax++;
}
d3426 6
a3431 2
	if (ckWARN(WARN_BAREWORD) && (first->op_private & OPpCONST_BARE))
	    Perl_warner(aTHX_ packWARN(WARN_BAREWORD), "Bareword found in conditional");
d3501 2
d3547 2
a3712 5
	if ((line_t)whileline != NOLINE) {
	    PL_copline = (line_t)whileline;
	    cont = append_elem(OP_LINESEQ, cont,
			       newSTATEOP(0, Nullch, Nullop));
	}
d3765 1
d3769 1
d3774 1
d3838 3
d3876 3
a3878 1
	if (label->op_type == OP_ENTERSUB)
d3886 11
a3899 4
    CV *outsidecv;
    CV *freecv = Nullcv;
    bool is_eval = CvEVAL(cv) && !CvGV(cv);	/* is this eval"" ? */

d3926 1
a3926 2
	SAVEVPTR(PL_curpad);
	PL_curpad = 0;
d3934 9
a3942 9
    outsidecv = CvOUTSIDE(cv);
    /* Since closure prototypes have the same lifetime as the containing
     * CV, they don't hold a refcount on the outside CV.  This avoids
     * the refcount loop between the outer CV (which keeps a refcount to
     * the closure prototype in the pad entry for pp_anoncode()) and the
     * closure prototype, and the ensuing memory leak.  --GSAR */
    if (!CvANON(cv) || CvCLONED(cv))
        freecv = outsidecv;
    CvOUTSIDE(cv) = Nullcv;
a3946 53
    if (CvPADLIST(cv)) {
	/* may be during global destruction */
	if (SvREFCNT(CvPADLIST(cv))) {
	    AV *padlist = CvPADLIST(cv);
	    I32 ix;
	    /* pads may be cleared out already during global destruction */
	    if (is_eval && !PL_dirty) {
		/* inner references to eval's cv must be fixed up */
		AV *comppad_name = (AV*)AvARRAY(padlist)[0];
		AV *comppad = (AV*)AvARRAY(padlist)[1];
		SV **namepad = AvARRAY(comppad_name);
		SV **curpad = AvARRAY(comppad);
		for (ix = AvFILLp(comppad_name); ix > 0; ix--) {
		    SV *namesv = namepad[ix];
		    if (namesv && namesv != &PL_sv_undef
			&& *SvPVX(namesv) == '&'
			&& ix <= AvFILLp(comppad))
		    {
			CV *innercv = (CV*)curpad[ix];
			if (innercv && SvTYPE(innercv) == SVt_PVCV
			    && CvOUTSIDE(innercv) == cv)
			{
			    CvOUTSIDE(innercv) = outsidecv;
			    if (!CvANON(innercv) || CvCLONED(innercv)) {
				(void)SvREFCNT_inc(outsidecv);
				if (SvREFCNT(cv))
				    SvREFCNT_dec(cv);
			    }
			}
		    }
		}
	    }
	    if (freecv)
		SvREFCNT_dec(freecv);
	    ix = AvFILLp(padlist);
	    while (ix >= 0) {
		SV* sv = AvARRAY(padlist)[ix--];
		if (!sv)
		    continue;
		if (sv == (SV*)PL_comppad_name)
		    PL_comppad_name = Nullav;
		else if (sv == (SV*)PL_comppad) {
		    PL_comppad = Nullav;
		    PL_curpad = Null(SV**);
		}
		SvREFCNT_dec(sv);
	    }
	    SvREFCNT_dec((SV*)CvPADLIST(cv));
	}
	CvPADLIST(cv) = Nullav;
    }
    else if (freecv)
	SvREFCNT_dec(freecv);
d3950 2
a3951 206
    CvFLAGS(cv) = 0;
}

#ifdef DEBUG_CLOSURES
STATIC void
S_cv_dump(pTHX_ CV *cv)
{
#ifdef DEBUGGING
    CV *outside = CvOUTSIDE(cv);
    AV* padlist = CvPADLIST(cv);
    AV* pad_name;
    AV* pad;
    SV** pname;
    SV** ppad;
    I32 ix;

    PerlIO_printf(Perl_debug_log,
		  "\tCV=0x%"UVxf" (%s), OUTSIDE=0x%"UVxf" (%s)\n",
		  PTR2UV(cv),
		  (CvANON(cv) ? "ANON"
		   : (cv == PL_main_cv) ? "MAIN"
		   : CvUNIQUE(cv) ? "UNIQUE"
		   : CvGV(cv) ? GvNAME(CvGV(cv)) : "UNDEFINED"),
		  PTR2UV(outside),
		  (!outside ? "null"
		   : CvANON(outside) ? "ANON"
		   : (outside == PL_main_cv) ? "MAIN"
		   : CvUNIQUE(outside) ? "UNIQUE"
		   : CvGV(outside) ? GvNAME(CvGV(outside)) : "UNDEFINED"));

    if (!padlist)
	return;

    pad_name = (AV*)*av_fetch(padlist, 0, FALSE);
    pad = (AV*)*av_fetch(padlist, 1, FALSE);
    pname = AvARRAY(pad_name);
    ppad = AvARRAY(pad);

    for (ix = 1; ix <= AvFILLp(pad_name); ix++) {
	if (SvPOK(pname[ix]))
	    PerlIO_printf(Perl_debug_log,
			  "\t%4d. 0x%"UVxf" (%s\"%s\" %"IVdf"-%"IVdf")\n",
			  (int)ix, PTR2UV(ppad[ix]),
			  SvFAKE(pname[ix]) ? "FAKE " : "",
			  SvPVX(pname[ix]),
			  (IV)I_32(SvNVX(pname[ix])),
			  SvIVX(pname[ix]));
    }
#endif /* DEBUGGING */
}
#endif /* DEBUG_CLOSURES */

STATIC CV *
S_cv_clone2(pTHX_ CV *proto, CV *outside)
{
    AV* av;
    I32 ix;
    AV* protopadlist = CvPADLIST(proto);
    AV* protopad_name = (AV*)*av_fetch(protopadlist, 0, FALSE);
    AV* protopad = (AV*)*av_fetch(protopadlist, 1, FALSE);
    SV** pname = AvARRAY(protopad_name);
    SV** ppad = AvARRAY(protopad);
    I32 fname = AvFILLp(protopad_name);
    I32 fpad = AvFILLp(protopad);
    AV* comppadlist;
    CV* cv;

    assert(!CvUNIQUE(proto));

    ENTER;
    SAVECOMPPAD();
    SAVESPTR(PL_comppad_name);
    SAVESPTR(PL_compcv);

    cv = PL_compcv = (CV*)NEWSV(1104,0);
    sv_upgrade((SV *)cv, SvTYPE(proto));
    CvFLAGS(cv) = CvFLAGS(proto) & ~CVf_CLONE;
    CvCLONED_on(cv);

#ifdef USE_5005THREADS
    New(666, CvMUTEXP(cv), 1, perl_mutex);
    MUTEX_INIT(CvMUTEXP(cv));
    CvOWNER(cv)		= 0;
#endif /* USE_5005THREADS */
#ifdef USE_ITHREADS
    CvFILE(cv)		= CvXSUB(proto) ? CvFILE(proto)
					: savepv(CvFILE(proto));
#else
    CvFILE(cv)		= CvFILE(proto);
#endif
    CvGV(cv)		= CvGV(proto);
    CvSTASH(cv)		= CvSTASH(proto);
    CvROOT(cv)		= OpREFCNT_inc(CvROOT(proto));
    CvSTART(cv)		= CvSTART(proto);
    if (outside)
	CvOUTSIDE(cv)	= (CV*)SvREFCNT_inc(outside);

    if (SvPOK(proto))
	sv_setpvn((SV*)cv, SvPVX(proto), SvCUR(proto));

    PL_comppad_name = newAV();
    for (ix = fname; ix >= 0; ix--)
	av_store(PL_comppad_name, ix, SvREFCNT_inc(pname[ix]));

    PL_comppad = newAV();

    comppadlist = newAV();
    AvREAL_off(comppadlist);
    av_store(comppadlist, 0, (SV*)PL_comppad_name);
    av_store(comppadlist, 1, (SV*)PL_comppad);
    CvPADLIST(cv) = comppadlist;
    av_fill(PL_comppad, AvFILLp(protopad));
    PL_curpad = AvARRAY(PL_comppad);

    av = newAV();           /* will be @@_ */
    av_extend(av, 0);
    av_store(PL_comppad, 0, (SV*)av);
    AvFLAGS(av) = AVf_REIFY;

    for (ix = fpad; ix > 0; ix--) {
	SV* namesv = (ix <= fname) ? pname[ix] : Nullsv;
	if (namesv && namesv != &PL_sv_undef) {
	    char *name = SvPVX(namesv);    /* XXX */
	    if (SvFLAGS(namesv) & SVf_FAKE) {   /* lexical from outside? */
		I32 off = pad_findlex(name, ix, SvIVX(namesv),
				      CvOUTSIDE(cv), cxstack_ix, 0, 0);
		if (!off)
		    PL_curpad[ix] = SvREFCNT_inc(ppad[ix]);
		else if (off != ix)
		    Perl_croak(aTHX_ "panic: cv_clone: %s", name);
	    }
	    else {				/* our own lexical */
		SV* sv;
		if (*name == '&') {
		    /* anon code -- we'll come back for it */
		    sv = SvREFCNT_inc(ppad[ix]);
		}
		else if (*name == '@@')
		    sv = (SV*)newAV();
		else if (*name == '%')
		    sv = (SV*)newHV();
		else
		    sv = NEWSV(0,0);
		if (!SvPADBUSY(sv))
		    SvPADMY_on(sv);
		PL_curpad[ix] = sv;
	    }
	}
	else if (IS_PADGV(ppad[ix]) || IS_PADCONST(ppad[ix])) {
	    PL_curpad[ix] = SvREFCNT_inc(ppad[ix]);
	}
	else {
	    SV* sv = NEWSV(0,0);
	    SvPADTMP_on(sv);
	    PL_curpad[ix] = sv;
	}
    }

    /* Now that vars are all in place, clone nested closures. */

    for (ix = fpad; ix > 0; ix--) {
	SV* namesv = (ix <= fname) ? pname[ix] : Nullsv;
	if (namesv
	    && namesv != &PL_sv_undef
	    && !(SvFLAGS(namesv) & SVf_FAKE)
	    && *SvPVX(namesv) == '&'
	    && CvCLONE(ppad[ix]))
	{
	    CV *kid = cv_clone2((CV*)ppad[ix], cv);
	    SvREFCNT_dec(ppad[ix]);
	    CvCLONE_on(kid);
	    SvPADMY_on(kid);
	    PL_curpad[ix] = (SV*)kid;
	}
    }

#ifdef DEBUG_CLOSURES
    PerlIO_printf(Perl_debug_log, "Cloned inside:\n");
    cv_dump(outside);
    PerlIO_printf(Perl_debug_log, "  from:\n");
    cv_dump(proto);
    PerlIO_printf(Perl_debug_log, "   to:\n");
    cv_dump(cv);
#endif

    LEAVE;

    if (CvCONST(cv)) {
	SV* const_sv = op_const_sv(CvSTART(cv), cv);
	assert(const_sv);
	/* constant sub () { $x } closing over $x - see lib/constant.pm */
	SvREFCNT_dec(cv);
	cv = newCONSTSUB(CvSTASH(proto), 0, const_sv);
    }

    return cv;
}

CV *
Perl_cv_clone(pTHX_ CV *proto)
{
    CV *cv;
    LOCK_CRED_MUTEX;			/* XXX create separate mutex */
    cv = cv_clone2(proto, CvOUTSIDE(proto));
    UNLOCK_CRED_MUTEX;			/* XXX create separate mutex */
    return cv;
d3967 1
a3967 1
	    Perl_sv_catpvf(aTHX_ msg, " (%s)", SvPVX(cv));
d4030 1
a4030 2
	    AV* padav = (AV*)(AvARRAY(CvPADLIST(cv))[1]);
	    sv = padav ? AvARRAY(padav)[o->op_targ] : Nullsv;
a4080 1
    I32 ix;
d4238 1
d4242 1
d4247 1
a4247 22
	{
	    AV *padlist = CvPADLIST(cv);
	    AV *comppad_name = (AV*)AvARRAY(padlist)[0];
	    AV *comppad = (AV*)AvARRAY(padlist)[1];
	    SV **namepad = AvARRAY(comppad_name);
	    SV **curpad = AvARRAY(comppad);
	    for (ix = AvFILLp(comppad_name); ix > 0; ix--) {
		SV *namesv = namepad[ix];
		if (namesv && namesv != &PL_sv_undef
		    && *SvPVX(namesv) == '&')
		{
		    CV *innercv = (CV*)curpad[ix];
		    if (CvOUTSIDE(innercv) == PL_compcv) {
			CvOUTSIDE(innercv) = cv;
			if (!CvANON(innercv) || CvCLONED(innercv)) {
			    (void)SvREFCNT_inc(cv);
			    SvREFCNT_dec(PL_compcv);
			}
		    }
		}
	    }
	}
d4289 1
a4289 1
		    Perl_croak(aTHX_ "%s", SvPVx(ERRSV, n_a));
a4296 3
    if (AvFILLp(PL_comppad_name) < AvFILLp(PL_comppad))
	av_store(PL_comppad_name, AvFILLp(PL_comppad), Nullsv);

d4311 3
a4314 20
	SV **namep = AvARRAY(PL_comppad_name);
	for (ix = AvFILLp(PL_comppad); ix > 0; ix--) {
	    SV *namesv;

	    if (SvIMMORTAL(PL_curpad[ix]) || IS_PADGV(PL_curpad[ix]) || IS_PADCONST(PL_curpad[ix]))
		continue;
	    /*
	     * The only things that a clonable function needs in its
	     * pad are references to outer lexicals and anonymous subs.
	     * The rest are created anew during cloning.
	     */
	    if (!((namesv = namep[ix]) != Nullsv &&
		  namesv != &PL_sv_undef &&
		  (SvFAKE(namesv) ||
		   *SvPVX(namesv) == '&')))
	    {
		SvREFCNT_dec(PL_curpad[ix]);
		PL_curpad[ix] = Nullsv;
	    }
	}
a4318 20
    else {
	AV *av = newAV();			/* Will be @@_ */
	av_extend(av, 0);
	av_store(PL_comppad, 0, (SV*)av);
	AvFLAGS(av) = AVf_REIFY;

	for (ix = AvFILLp(PL_comppad); ix > 0; ix--) {
	    if (SvIMMORTAL(PL_curpad[ix]) || IS_PADGV(PL_curpad[ix]) || IS_PADCONST(PL_curpad[ix]))
		continue;
	    if (!SvPADMY(PL_curpad[ix]))
		SvPADTMP_on(PL_curpad[ix]);
	}
    }

    /* If a potential closure prototype, don't keep a refcount on outer CV.
     * This is okay as the lifetime of the prototype is tied to the
     * lifetime of the outer CV.  Avoids memory leak due to reference
     * loop. --GSAR */
    if (!name)
	SvREFCNT_dec(CvOUTSIDE(cv));
d4438 1
a4438 1
    cv = newXS(name, const_sv_xsub, __FILE__);
d4443 3
a4566 1
    I32 ix;
a4594 4
    for (ix = AvFILLp(PL_comppad); ix > 0; ix--) {
	if (!SvPADMY(PL_curpad[ix]) && !SvIMMORTAL(PL_curpad[ix]))
	    SvPADTMP_on(PL_curpad[ix]);
    }
d4596 1
d4758 1
a4758 12
    PADOFFSET ix;
    SV* name;

    name = NEWSV(1106,0);
    sv_upgrade(name, SVt_PVNV);
    sv_setpvn(name, "&", 1);
    SvIVX(name) = -1;
    SvNVX(name) = 1;
    ix = pad_alloc(o->op_type, SVs_PADMY);
    av_store(PL_comppad_name, ix, name);
    av_store(PL_comppad, ix, cSVOPo->op_sv);
    SvPADMY_on(cSVOPo->op_sv);
a4759 1
    cSVOPo->op_targ = ix;
d4766 8
d4775 18
d4799 3
a4801 2
    if (cUNOPo->op_first->op_type == OP_CONCAT)
	o->op_flags |= OPf_STACKED;
d4875 1
a4875 2
	    o = newUNOP(type, OPf_SPECIAL,
		newGVOP(OP_GV, 0, gv_fetchpv("main::ARGV", TRUE, SVt_PVAV)));
d4893 1
a4893 1
	else if (kid->op_type == OP_LINESEQ) {
a4895 1
	    kid->op_next = o->op_next;
d5085 1
a5085 1
	    SvREFCNT_dec(PL_curpad[kPADOP->op_padix]);
d5087 1
a5087 1
	    PL_curpad[kPADOP->op_padix] = SvREFCNT_inc(gv);
d5116 5
d5125 1
a5125 2
           o =  newGVOP(type, OPf_REF, gv_fetchpv("main::STDIN", TRUE,
				SVt_PVIO));
d5266 1
a5266 1
			    STRLEN len;
d5275 11
a5285 4
				SV **namep = av_fetch(PL_comppad_name,
						      kid->op_targ, 4);
				if (namep && *namep)
				    name = SvPV(*namep, len);
d5297 45
a5341 3
				name = "__ANONIO__";
				len = 10;
				mod(kid,type);
d5346 1
a5346 1
				namesv = PL_curpad[targ];
d5407 1
a5407 1
    if (!gv) {
d5688 19
d5821 1
a5821 1
	    argop->op_targ = 0;		/* PL_curpad[0] is @@_ */
d5830 1
a5830 2
	    scalar(newGVOP(OP_GV, 0, !CvUNIQUE(PL_compcv) ?
			   PL_defgv : gv_fetchpv("ARGV", TRUE, SVt_PVAV))));
d6237 2
a6238 2
		Perl_croak(aTHX_ "Malformed prototype for %s: %s",
			   gv_ename(namegv), SvPV((SV*)cv, n_a));
d6310 4
a6313 2
	if (!PL_op_seqmax)
	    PL_op_seqmax++;
d6327 1
d6333 1
a6333 1
		if (SvPADTMP(cSVOPo->op_sv)) {
d6336 2
a6337 2
		    sv_setsv(PL_curpad[ix],cSVOPo->op_sv);
		    SvREADONLY_on(PL_curpad[ix]);
d6341 1
a6341 1
		    SvREFCNT_dec(PL_curpad[ix]);
d6343 1
a6343 1
		    PL_curpad[ix] = cSVOPo->op_sv;
d6345 1
a6345 1
		    SvREADONLY_on(PL_curpad[ix]);
d6372 11
d6458 2
a6459 2
				"%s() called too early to check prototype",
				SvPV_nolen(sv));
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d18 1
d24 7
a30 1
/* #define PL_OP_SLAB_ALLOC */
d32 2
a33 9
#ifdef PL_OP_SLAB_ALLOC 
#define SLAB_SIZE 8192
static char    *PL_OpPtr  = NULL;
static int     PL_OpSpace = 0;
#define NewOp(m,var,c,type) do { if ((PL_OpSpace -= c*sizeof(type)) >= 0)     \
                              var =  (type *)(PL_OpPtr -= c*sizeof(type));    \
                             else                                             \
                              var = (type *) Slab_Alloc(m,c*sizeof(type));    \
                           } while (0)
d35 3
a37 1
STATIC void *           
d39 55
a93 4
{ 
 Newz(m,PL_OpPtr,SLAB_SIZE,char);
 PL_OpSpace = SLAB_SIZE - sz;
 return PL_OpPtr += PL_OpSpace;
d96 1
a96 1
#else 
d98 1
d127 1
a127 1
		 PL_op_desc[o->op_type]));
d149 1
a149 1
		 (int)n, name, t, PL_op_desc[kid->op_type]));
a159 24
STATIC U8*
S_trlist_upgrade(pTHX_ U8** sp, U8** ep)
{
    U8 *s = *sp;
    U8 *e = *ep;
    U8 *d;

    Newz(801, d, (e - s) * 2, U8);
    *sp = d;

    while (s < e) {
        if (*s < 0x80 || *s == 0xff)
            *d++ = *s++;
	else {
            U8 c = *s++;
            *d++ = ((c >> 6)         | 0xc0);
            *d++ = ((c       & 0x3f) | 0x80);
        }
    }
    *ep = d;
    return *sp;
}
  

d170 1
a170 1
	  (PL_hints & HINT_UTF8 && UTF8_IS_START(name[1])) ||
d198 1
a198 1
	for (off = top; off > PL_comppad_name_floor; off--) {
d206 2
a207 2
		Perl_warner(aTHX_ WARN_MISC,
		    "\"%s\" variable %s masks earlier declaration in same %s", 
d223 1
a223 1
		    Perl_warner(aTHX_ WARN_MISC,
d225 1
a225 1
		    Perl_warner(aTHX_ WARN_MISC,
d240 1
a240 1
	SvOBJECT_on(sv);
a242 1
	PL_sv_objcount++;
d279 2
a280 2
    if (SvOBJECT(proto_namesv)) {		/* A typed var */
	SvOBJECT_on(namesv);
a282 1
	PL_sv_objcount++;
d311 2
a312 2
		seq <= SvIVX(sv) &&
		seq > I_32(SvNVX(sv)) &&
d366 1
a366 1
					Perl_warner(aTHX_ WARN_CLOSURE,
d379 1
a379 1
			    Perl_warner(aTHX_ WARN_CLOSURE,
a402 1
		seq = cxstack[saweval].blk_oldcop->cop_seq;
d409 2
a410 1
		if (CxREALEVAL(cx))
d412 9
d435 1
a437 1
	    seq = cxstack[saweval].blk_oldcop->cop_seq;
d456 1
a456 1
#ifdef USE_THREADS
d467 1
a467 1
#endif /* USE_THREADS */
d474 2
a475 2
	     (seq <= SvIVX(sv) &&
	      seq > I_32(SvNVX(sv)))) &&
d516 1
a516 1
		Perl_warner(aTHX_ WARN_INTERNAL, "%s never introduced", SvPVX(sv));
d555 2
a556 1
	    if (!(SvFLAGS(sv) & (SVs_PADTMP|SVs_PADMY)) && !IS_PADGV(sv))
d563 1
a563 1
#ifdef USE_THREADS
d573 1
a573 1
#endif /* USE_THREADS */
d580 1
a580 1
#ifdef USE_THREADS
d589 1
a589 1
#endif /* USE_THREADS */
d602 1
a602 1
#ifdef USE_THREADS
d609 1
a609 1
#endif /* USE_THREADS */
d627 1
a627 1
#ifdef USE_THREADS
d634 1
a634 1
#endif /* USE_THREADS */
d656 1
a656 1
#ifdef USE_THREADS
d663 1
a663 1
#endif /* USE_THREADS */
d675 1
a675 1
#ifdef USE_THREADS
d707 1
a707 1
	    sv_magic(sv, 0, 0, name, 1); 
d731 1
a731 1
	    sv_magic(sv, 0, 0, name, 1); 
d740 1
a740 1
#endif /* USE_THREADS */
d781 1
a781 1
	type = o->op_targ;
d789 1
a789 8

#ifdef PL_OP_SLAB_ALLOC
    if ((char *) o == PL_OpPtr)
     {
     }
#else
    Safefree(o);
#endif
d792 2
a793 2
STATIC void
S_op_clear(pTHX_ OP *o)
d795 1
d799 1
a799 1
#ifdef USE_THREADS
d804 1
a804 1
#ifdef USE_THREADS
d809 1
a809 1
#endif /* USE_THREADS */
d861 1
a861 1
	if ((PADOFFSET)cPMOPo->op_pmreplroot) {
d863 2
a864 2
		GV *gv = (GV*)PL_curpad[(PADOFFSET)cPMOPo->op_pmreplroot];
		pad_swipe((PADOFFSET)cPMOPo->op_pmreplroot);
d877 19
d897 16
a912 2
	ReREFCNT_dec(cPMOPo->op_pmregexp);
	cPMOPo->op_pmregexp = (REGEXP*)NULL;
d925 6
a930 1
    Safefree(cop->cop_label);
d932 5
a936 2
    Safefree(CopFILE(cop));		/* XXX share in a pvtable? */
    Safefree(CopSTASHPV(cop));		/* XXX share in a pvtable? */
d938 1
a938 2
    /* NOTE: COP.cop_stash is not refcounted */
    SvREFCNT_dec(CopFILEGV(cop));
d940 1
a940 2
    if (! specialWARN(cop->cop_warnings))
	SvREFCNT_dec(cop->cop_warnings);
d943 2
a944 2
STATIC void
S_null(pTHX_ OP *o)
d1002 1
a1002 1
	    Perl_warner(aTHX_ WARN_SYNTAX, "Found = in conditional, should be ==");
a1024 2
	if (o->op_private & OPpREPEAT_DOLIST)
	    null(((LISTOP*)cBINOPo->op_first)->op_first);
d1036 1
a1036 1
		deprecate("implicit split to @@_");
d1072 3
d1108 1
a1108 1
    
d1193 1
a1193 1
	    useless = PL_op_desc[o->op_type];
d1212 3
d1218 6
d1231 1
a1231 1
	null(o);		/* don't execute or even remember it */
d1283 1
a1283 1
		deprecate("implicit split to @@_");
d1288 1
a1288 1
	Perl_warner(aTHX_ WARN_VOID, "Useless use of %s in void context", useless);
d1320 1
a1320 1
    
d1430 1
a1430 1
    
a1435 25
        if (o->op_private & (OPpCONST_BARE) && 
                !(type == OP_GREPSTART || type == OP_ENTERSUB || type == OP_REFGEN)) {
            SV *sv = ((SVOP*)o)->op_sv;
            GV *gv;

            /* Could be a filehandle */
            if (gv = gv_fetchpv(SvPV_nolen(sv), FALSE, SVt_PVIO)) {
                OP* gvio = newUNOP(OP_RV2GV, 0, newGVOP(OP_GV, 0, gv));
                op_free(o);
                o = gvio;
            } else {
                /* OK, it's a sub */
                OP* enter;
                gv = gv_fetchpv(SvPV_nolen(sv), TRUE, SVt_PVCV);

                enter = newUNOP(OP_ENTERSUB,0, 
                        newUNOP(OP_RV2CV, 0, 
                            newGVOP(OP_GV, 0, gv)
                        ));
                enter->op_private |= OPpLVAL_INTRO;
                op_free(o);
                o = enter;
            }
            break;
        }
d1461 1
a1461 1
	    null(((LISTOP*)cUNOPo->op_first)->op_first);/* disable pushmark */
d1464 2
d1484 2
a1485 2
			       "args: type/targ %ld:%ld",
			       (long)kid->op_type,kid->op_targ);
a1496 5
			if (kid->op_sibling || kid->op_next != kid) {
			    yyerror("panic: unexpected optree near method call");
			    break;
			}
			
d1506 1
a1506 1
		    
d1510 2
a1511 2
				   "entry via type/targ %ld:%ld",
				   (long)kid->op_type,kid->op_targ);
d1515 2
a1516 2
		
		okid = kid;		
d1520 1
a1520 1
		if (kid->op_type == OP_NULL)		
d1523 2
a1524 2
			       "entry via type/targ %ld:%ld",
			       (long)kid->op_type,kid->op_targ);
d1540 1
a1540 1
		
d1542 1
a1542 1
		if (!cv) 
d1559 1
a1559 1
			: PL_op_desc[o->op_type])),
d1587 1
a1587 1
	
d1650 1
a1650 1
#ifdef USE_THREADS
d1654 1
a1654 1
#endif /* USE_THREADS */
d1658 1
a1658 1
	
d1718 8
d1838 1
a1838 1
	    null(((LISTOP*)cUNOPo->op_first)->op_first);	/* disable pushmark */
d1860 1
a1860 1
      
d1936 1
a1936 1
S_apply_attrs(pTHX_ HV *stash, SV *target, OP *attrs)
d1943 1
a1943 1
    if (stash && HvNAME(stash))
d1949 1
d1951 23
a1973 9
    Perl_load_module(aTHX_ PERL_LOADMOD_IMPORT_OPS,
		     newSVpvn(ATTRSMODULE, sizeof(ATTRSMODULE)-1),
		     Nullsv,
		     prepend_elem(OP_LIST,
				  newSVOP(OP_CONST, 0, stashsv),
				  prepend_elem(OP_LIST,
					       newSVOP(OP_CONST, 0,
						       newRV(target)),
					       dup_attrlist(attrs))));
d1977 65
d2074 1
a2074 1
S_my_kid(pTHX_ OP *o, OP *attrs)
d2085 1
a2085 1
	    my_kid(kid, attrs);
d2091 13
d2106 2
a2107 1
    } else if (type != OP_PADSV &&
d2113 1
a2113 1
			  PL_op_desc[o->op_type],
a2118 1
	SV *padsv;
d2126 1
a2126 1
	if (namesvp && *namesvp && SvOBJECT(*namesvp) && HvNAME(SvSTASH(*namesvp)))
d2130 1
a2130 2
	padsv = PAD_SV(o->op_targ);
	apply_attrs(stash, padsv, attrs);
d2140 3
d2145 2
d2149 9
a2157 1
    o = my_kid(o, attrs);
d2166 1
a2166 1
    return my_kid(o, Nullop);
d2193 2
a2194 2
      Perl_warner(aTHX_ WARN_MISC,
             "Applying %s to %s will act on scalar(%s)", 
d2198 7
d2252 1
a2252 1
		    null(kid);
d2290 1
a2290 1
    SAVESPTR(PL_compiling.cop_warnings); 
d2295 5
d2307 4
a2310 1
    OP* retval = scalarseq(seq);
d2313 1
a2313 1
    PL_compiling.op_private = PL_hints;
d2324 1
a2324 1
#ifdef USE_THREADS
d2330 1
a2330 1
#endif /* USE_THREADS */
d2346 1
a2346 1
	peep(PL_eval_start);
d2357 1
a2357 1
	peep(PL_main_start);
d2380 8
a2387 3
	if (ckWARN(WARN_PARENTHESIS) && PL_bufptr > PL_oldbufptr && PL_bufptr[-1] == ',') {
	    char *s;
	    for (s = PL_bufptr; *s && (isALNUM(*s) || UTF8_IS_CONTINUED(*s) || strchr("@@$%, ",*s)); s++) ;
d2389 1
a2389 1
		Perl_warner(aTHX_ WARN_PARENTHESIS,
d2408 1
a2408 1
#ifdef USE_THREADS
d2413 1
a2413 1
#endif /* USE_THREADS */
d2458 2
a2459 2

	if (o->op_private & OPpLOCALE)
d2497 5
a2501 7
	    IV iv = SvIV(sv);
	    if ((NV)iv == SvNV(sv)) {
		SvREFCNT_dec(sv);
		sv = newSViv(iv);
	    }
	    else
		SvIOK_off(sv);			/* undo SvIV() damage */
a2506 24
    if (!(PL_opargs[type] & OA_OTHERINT))
	return o;

    if (!(PL_hints & HINT_INTEGER)) {
	if (type == OP_MODULO
	    || type == OP_DIVIDE
	    || !(o->op_flags & OPf_KIDS))
	{
	    return o;
	}

	for (curop = ((UNOP*)o)->op_first; curop; curop = curop->op_sibling) {
	    if (curop->op_type == OP_CONST) {
		if (SvIOK(((SVOP*)curop)->op_sv))
		    continue;
		return o;
	    }
	    if (PL_opargs[curop->op_type] & OA_RETINTEGER)
		continue;
	    return o;
	}
	o->op_ppaddr = PL_ppaddr[++(o->op_type)];
    }

d2522 1
a2522 1
    peep(curop);
d2531 1
a2541 3
    OP *kid;
    OP *last = 0;

d2548 1
a2548 1
	null(cLISTOPo->op_first);
d2550 1
a2550 1
    o->op_type = type;
d2607 2
a2608 4
#ifdef PL_OP_SLAB_ALLOC
#else
    Safefree(last);     
#endif
d2625 2
d2656 1
a2656 1
    null(o);
d2667 1
a2667 1
    listop->op_type = type;
d2671 1
a2671 1
    listop->op_flags = flags;
d2699 1
a2699 1
    o->op_type = type;
d2701 1
a2701 1
    o->op_flags = flags;
d2704 1
a2704 1
    o->op_private = 0 + (flags >> 8);
d2723 1
a2723 1
    unop->op_type = type;
d2727 1
a2727 1
    unop->op_private = 1 | (flags >> 8);
d2744 1
a2744 1
    binop->op_type = type;
d2750 1
a2750 1
	binop->op_private = 1 | (flags >> 8);
d2753 1
a2753 1
	binop->op_private = 2 | (flags >> 8);
d2758 1
a2758 1
    if (binop->op_next || binop->op_type != type)
d2767 1
a2767 1
utf8compare(const void *a, const void *b)
d2769 8
a2776 7
    int i;
    for (i = 0; i < 10; i++) {
	if ((*(U8**)a)[i] < (*(U8**)b)[i])
	    return -1;
	if ((*(U8**)a)[i] > (*(U8**)b)[i])
	    return 1;
    }
d2801 1
a2801 1
    
d2804 2
a2805 2
    
    if (SvUTF8(rstr)) 
d2825 1
a2825 1
	U32 final;
d2828 19
a2846 2
	U8* tsave = from_utf ? NULL : trlist_upgrade(&t, &tend);
	U8* rsave = to_utf   ? NULL : trlist_upgrade(&r, &rend);
d2850 1
a2850 2
	    U8** cp;
	    I32* cl;
d2852 1
a2852 1
	    New(1109, cp, tlen, U8*);
d2856 3
a2858 3
		cp[i++] = t;
		t += UTF8SKIP(t);
		if (t < tend && *t == 0xff) {
d2860 2
a2861 1
		    t += UTF8SKIP(t);
d2863 4
d2868 1
a2868 1
	    qsort(cp, i, sizeof(U8*), utf8compare);
d2870 1
a2870 4
		U8 *s = cp[j];
		I32 cur = j < i - 1 ? cp[j+1] - s : tend - s;
		UV  val = utf8_to_uv(s, cur, &ulen, 0);
		s += ulen;
d2873 1
a2873 1
		    t = uv_to_utf8(tmpbuf,nextmin);
d2876 3
a2878 2
			t = uv_to_utf8(tmpbuf, val - 1);
			sv_catpvn(transv, "\377", 1);
d2882 1
a2882 2
		if (s < tend && *s == 0xff)
		    val = utf8_to_uv(s+1, cur - 1, &ulen, 0);
d2886 1
a2886 1
	    t = uv_to_utf8(tmpbuf,nextmin);
d2888 6
a2893 2
	    t = uv_to_utf8(tmpbuf, 0x7fffffff);
	    sv_catpvn(transv, "\377", 1);
d2904 1
a2904 1
		if (t == r ||
d2914 1
a2914 1
		tfirst = (I32)utf8_to_uv(t, tend - t, &ulen, 0);
d2916 1
a2916 1
		if (t < tend && *t == 0xff) {	/* illegal utf8 val indicates range */
d2918 1
a2918 1
		    tlast = (I32)utf8_to_uv(t, tend - t, &ulen, 0);
d2928 1
a2928 1
		    rfirst = (I32)utf8_to_uv(r, rend - r, &ulen, 0);
d2930 1
a2930 1
		    if (r < rend && *r == 0xff) {	/* illegal utf8 val indicates range */
d2932 1
a2932 1
			rlast = (I32)utf8_to_uv(r, rend - r, &ulen, 0);
d2973 3
a2976 2
		if (!grows)
		    grows = (UNISKIP(tfirst) < UNISKIP(rfirst));
d2998 1
a2998 1
	if (!del && havefinal)
d3018 1
a3018 1
	for (i = 0; i < tlen; i++)
d3022 1
a3022 1
		if (j >= rlen) {
d3028 1
a3028 1
			tbl[i] = i;
d3037 14
d3058 3
d3063 2
a3064 2
	for (i = 0, j = 0; i < tlen; i++,j++) {
	    if (j >= rlen) {
d3093 1
a3093 1
    pmop->op_type = type;
d3095 2
a3096 2
    pmop->op_flags = flags;
    pmop->op_private = 0 | (flags >> 8);
d3104 18
a3121 1
    /* link into pm list */
d3125 1
d3153 1
a3153 1
	if ((PL_hints & HINT_UTF8) || DO_UTF8(pat))
d3155 2
a3156 2
	pm->op_pmregexp = CALLREGCOMP(aTHX_ p, p + plen, pm);
	if (strEQ("\\s+", pm->op_pmregexp->precomp))
a3160 2
	if (PL_hints & HINT_UTF8)
	    pm->op_pmdynflags |= PMdf_UTF8;
d3162 1
a3162 1
	    expr = newUNOP((!(PL_hints & HINT_RE_EVAL) 
d3170 1
a3170 1
	rcop->op_flags |= ((PL_hints & HINT_RE_EVAL) 
d3195 1
a3195 1
		CopLINE_set(PL_curcop, PL_multi_end);
d3197 1
a3197 1
#ifdef USE_THREADS
d3204 1
a3204 1
#endif /* USE_THREADS */
d3211 1
a3211 1
#ifdef USE_THREADS
d3224 1
a3224 1
#endif /* USE_THREADS */
d3249 3
a3251 3
	    && !(repl_has_vars 
		 && (!pm->op_pmregexp 
		     || pm->op_pmregexp->reganch & ROPT_EVAL_SEEN))) {
d3257 1
a3257 1
	    if (curop == repl && !pm->op_pmregexp) { /* Has variables. */
d3287 1
a3287 1
    svop->op_type = type;
d3291 1
a3291 1
    svop->op_flags = flags;
d3304 1
a3304 1
    padop->op_type = type;
d3311 1
a3311 1
    padop->op_flags = flags;
d3335 1
a3335 1
    pvop->op_type = type;
d3339 1
a3339 1
    pvop->op_flags = flags;
d3364 1
a3376 1
    OP *rqop;
a3378 1
    GV *gv;
d3426 2
a3427 2
	meth = aver ? newSVpvn("import",6) : newSVpvn("unimport", 8);;
	sv_upgrade(meth, SVt_PVIV);
a3435 16
    /* Fake up a require, handle override, if any */
    gv = gv_fetchpv("require", FALSE, SVt_PVCV);
    if (!(gv && GvIMPORTED_CV(gv)))
	gv = gv_fetchpv("CORE::GLOBAL::require", FALSE, SVt_PVCV);

    if (gv && GvIMPORTED_CV(gv)) {
	rqop = ck_subr(newUNOP(OP_ENTERSUB, OPf_STACKED,
			       append_elem(OP_LIST, id,
					   scalar(newUNOP(OP_RV2CV, 0,
							  newGVOP(OP_GV, 0,
								  gv))))));
    }
    else {
	rqop = newUNOP(OP_REQUIRE, 0, id);
    }

d3443 1
a3443 1
	        newSTATEOP(0, Nullch, rqop),
d3447 17
d3469 16
d3551 1
a3551 1
    if (!(gv && GvIMPORTED_CV(gv)))
d3554 1
a3554 1
    if (gv && GvIMPORTED_CV(gv)) {
d3595 5
d3646 1
a3646 1
	o->op_private = 0 | (flags >> 8);
d3663 1
a3663 1
			if (gv == PL_defgv || SvCUR(gv) == PL_generation)
d3673 1
a3673 1
			if (SvCUR(sv) == PL_generation)
d3689 1
a3689 1
			    GV *gv = (GV*)PL_curpad[(PADOFFSET)((PMOP*)curop)->op_pmreplroot];
d3693 1
a3693 1
			    if (gv == PL_defgv || SvCUR(gv) == PL_generation)
d3696 1
a3696 1
			}	
d3719 1
a3719 1
			pm->op_pmreplroot = (OP*)cPADOPx(tmpop)->op_padix;
d3784 2
a3785 2
    cop->op_flags = flags;
    cop->op_private = (PL_hints & HINT_BYTE);
d3800 1
a3800 1
    else 
d3802 4
d3823 2
a3824 2
	if (svp && *svp != &PL_sv_undef && !SvIOK(*svp)) {
	    (void)SvIOK_on(*svp);
d3890 1
a3890 1
	    Perl_warner(aTHX_ WARN_BAREWORD, "Bareword found in conditional"); 
a3901 6
    else if (first->op_type == OP_WANTARRAY) {
	if (type == OP_AND)
	    list(other);
	else
	    scalar(other);
    }
d3911 1
a3911 1
		  && ((k1->op_flags & OPf_WANT) == OPf_WANT_SCALAR)) 
d3924 1
a3924 1
			  ? k1->op_targ : k1->op_type);
d3931 1
a3931 1
	    Perl_warner(aTHX_ WARN_MISC,
d3948 1
a3948 1
    logop->op_type = type;
d3953 1
a3953 1
    logop->op_private = 1 | (flags >> 8);
d3980 4
a3994 4
    else if (first->op_type == OP_WANTARRAY) {
	list(trueop);
	scalar(falseop);
    }
d4000 1
a4000 1
    logop->op_private = 1 | (flags >> 8);
d4036 1
a4036 1
    range->op_private = 1 | (flags >> 8);
d4084 1
a4084 1
	      case OP_NULL: 
d4087 1
a4087 1
		      && ((k1->op_flags & OPf_WANT) == OPf_WANT_SCALAR)) 
d4089 1
a4089 1
		break;                                
d4094 1
a4094 1
		      || (k1->op_type == OP_NULL && k1->op_targ == OP_NULL)
a4126 1
    OP *condop;
d4137 1
a4137 1
	  case OP_NULL: 
d4140 1
a4140 1
		  && ((k1->op_flags & OPf_WANT) == OPf_WANT_SCALAR)) 
d4142 1
a4142 1
	    break;                                
d4169 1
a4169 1
	    PL_copline = whileline;
d4179 1
a4179 1
	PL_copline = whileline;
d4188 1
a4188 1
	    ((LISTOP*)listop)->op_last->op_next = condop =
d4223 1
a4223 1
    int padoff = 0;
d4248 1
a4248 1
#ifdef USE_THREADS
d4284 1
a4284 1
        null(expr);
d4300 1
d4305 1
a4305 1
#endif 
d4341 5
a4345 1
#ifdef USE_THREADS
d4351 9
a4359 1
#endif /* USE_THREADS */
d4362 1
a4362 1
#ifdef USE_THREADS
d4368 1
a4368 1
#endif /* USE_THREADS */
d4380 1
d4387 1
a4387 1
	SvREFCNT_dec(CvOUTSIDE(cv));
d4389 4
d4396 34
a4429 4
	    I32 i = AvFILLp(CvPADLIST(cv));
	    while (i >= 0) {
		SV** svp = av_fetch(CvPADLIST(cv), i--, FALSE);
		SV* sv = svp ? *svp : Nullsv;
d4444 5
d4452 1
d4499 1
d4528 1
a4528 1
#ifdef USE_THREADS
d4532 5
a4536 1
#endif /* USE_THREADS */
d4538 1
d4635 9
d4676 1
a4676 1
	Perl_warner(aTHX_ WARN_PROTOTYPE, "%"SVf, msg);
d4680 16
d4699 1
a4699 1
    if (!cv || !SvPOK(cv) || SvCUR(cv))
d4701 1
a4701 1
    return op_const_sv(CvSTART(cv), cv);
d4711 2
a4712 2
 
    if (o->op_type == OP_LINESEQ && cLISTOPo->op_first) 
d4718 1
a4718 1
	if (sv && o->op_next == o) 
d4720 6
a4725 2
	if (type == OP_NEXTSTATE || type == OP_NULL || type == OP_PUSHMARK)
	    continue;
d4735 11
a4745 1
	    if (!sv || (!SvREADONLY(sv) && SvREFCNT(sv) > 1))
d4786 1
d4791 2
a4792 1
	Perl_sv_setpvf(aTHX_ sv, "__ANON__[%s:%"IVdf"]",
d4798 2
a4799 1
    gv = gv_fetchpv(name ? name : (aname ? aname : "__ANON__"),
d4816 1
a4816 1
		Perl_warner(aTHX_ WARN_PROTOTYPE, "Runaway prototype");
d4827 8
a4834 1
	goto noblock;
d4836 1
d4838 20
a4857 4
    if (!name || GvCVGEN(gv))
	cv = Nullcv;
    else if ((cv = GvCV(gv))) {
	cv_ckproto(cv, gv, ps);
d4859 1
a4859 3
	if (CvROOT(cv) || CvXSUB(cv) || GvASSUMECV(gv)) {
	    SV* const_sv;
	    bool const_changed = TRUE;
d4861 4
d4870 1
a4870 3
	    if (PL_curstackinfo->si_type == PERLSI_SORT &&
		PL_sortcop == CvSTART(cv)) {
		op_free(block);
d4872 15
a4887 15
	    if (!block)
		goto withattrs;
	    if ((const_sv = cv_const_sv(cv)))
		const_changed = sv_cmp(const_sv, op_const_sv(block, Nullcv));
	    if ((const_sv || const_changed) && ckWARN(WARN_REDEFINE))
	    {
		line_t oldline = CopLINE(PL_curcop);
		CopLINE_set(PL_curcop, PL_copline);
		Perl_warner(aTHX_ WARN_REDEFINE,
			const_sv ? "Constant subroutine %s redefined"
				 : "Subroutine %s redefined", name);
		CopLINE_set(PL_curcop, oldline);
	    }
	    SvREFCNT_dec(cv);
	    cv = Nullcv;
d4890 19
a4908 1
  withattrs:
d4918 3
a4920 1
	    if (CvGV(cv) && GvSTASH(CvGV(cv)) && HvNAME(GvSTASH(CvGV(cv))))
d4922 1
a4922 1
	    else if (CvSTASH(cv) && HvNAME(CvSTASH(cv)))
d4930 1
a4930 1
	    if (name && GvSTASH(gv) && HvNAME(GvSTASH(gv)))
d4935 1
a4935 1
	apply_attrs(stash, rcv, attrs);
d4974 2
d4986 1
a4986 1
    CvFILE(cv) = CopFILE(PL_curcop);
d4988 1
a4988 1
#ifdef USE_THREADS
d4994 1
a4994 1
#endif /* USE_THREADS */
d5018 2
a5019 6
    if (!block) {
      noblock:
	PL_copline = NOLINE;
	LEAVE_SCOPE(floor);
	return cv;
    }
d5035 1
a5035 1
    peep(CvSTART(cv));
d5059 3
a5124 2
	    save_svref(&PL_rs);
	    sv_setsv(PL_rs, PL_nrs);
d5134 1
a5134 1
	    PL_compiling.op_private = PL_hints;
d5150 1
a5150 1
		Perl_warner(aTHX_ WARN_VOID, "Too late to run CHECK block");
d5160 1
a5160 1
		Perl_warner(aTHX_ WARN_VOID, "Too late to run INIT block");
d5182 1
a5182 1
void
d5185 1
d5199 1
a5199 5
#ifdef USE_ITHREADS
	CopSTASHPV(PL_curcop) = stash ? HvNAME(stash) : Nullch;
#else
	CopSTASH(PL_curcop) = stash;
#endif
d5202 4
a5205 7
    newATTRSUB(
	start_subparse(FALSE, 0),
	newSVOP(OP_CONST, 0, newSVpv(name,0)),
	newSVOP(OP_CONST, 0, &PL_sv_no),	/* SvPV(&PL_sv_no) == "" -- GMB */
	Nullop,
	newSTATEOP(0, Nullch, newSVOP(OP_CONST, 0, sv))
    );
d5208 2
d5223 3
a5225 1
    GV *gv = gv_fetchpv(name ? name : "__ANON__", GV_ADDMULTI, SVt_PVCV);
a5236 1
			    && HvNAME(GvSTASH(CvGV(cv)))
d5241 4
a5244 1
		Perl_warner(aTHX_ WARN_REDEFINE, "Subroutine %s redefined",name);
d5264 1
a5264 1
#ifdef USE_THREADS
d5268 1
a5268 1
#endif /* USE_THREADS */
d5301 1
a5301 1
		Perl_warner(aTHX_ WARN_VOID, "Too late to run CHECK block");
d5310 1
a5310 1
		Perl_warner(aTHX_ WARN_VOID, "Too late to run INIT block");
d5336 5
d5345 3
a5347 3

	    CopLINE_set(PL_curcop, PL_copline);
	    Perl_warner(aTHX_ WARN_REDEFINE, "Format %s redefined",name);
d5355 1
a5355 1
    CvFILE(cv) = CopFILE(PL_curcop);
d5367 1
a5367 1
    peep(CvSTART(cv));
d5409 1
a5409 1
	
d5418 1
a5418 1
	    Perl_warner(aTHX_ WARN_INTERNAL, "oops: oopsAV");
d5443 1
a5443 1
	    Perl_warner(aTHX_ WARN_INTERNAL, "oops: oopsHV");
d5457 5
d5481 5
d5543 1
a5543 1
    o->op_private = PL_hints;
d5570 1
a5570 1
	
d5601 1
a5601 1
		  PL_op_desc[o->op_type]);
d5603 1
a5603 1
	null(kid);
d5609 9
d5642 1
a5642 1
	    null(o);
d5686 1
d5699 1
a5699 1
	    null(kid);
d5716 1
a5716 1
			   PL_op_desc[o->op_type]);
d5723 2
a5724 2
		       PL_op_desc[o->op_type]);
	null(kid);
d5805 1
a5805 1
		Perl_croak(aTHX_ 
a5876 7
#ifdef USE_LOCALE
    if (type == OP_FTTEXT || type == OP_FTBINARY) {
	o->op_private = 0;
	if (PL_hints & HINT_LOCALE)
	    o->op_private |= OPpLOCALE;
    }
#endif
d5932 6
d5944 2
a5945 2
		    if (ckWARN(WARN_DEPRECATED))
			Perl_warner(aTHX_ WARN_DEPRECATED,
d5964 2
a5965 2
		    if (ckWARN(WARN_DEPRECATED))
			Perl_warner(aTHX_ WARN_DEPRECATED,
d5996 3
d6004 1
a6004 1
			bad_type(numargs, "HANDLE", PL_op_desc[o->op_type], kid);
d6072 1
a6072 1
	    return too_many_arguments(o,PL_op_desc[o->op_type]);
d6084 1
a6084 1
	    return too_few_arguments(o,PL_op_desc[o->op_type]);
d6098 3
a6100 1
    if (!((gv = gv_fetchpv("glob", FALSE, SVt_PVCV)) && GvIMPORTED_CV(gv)))
d6102 1
d6107 1
d6109 2
a6110 3
	Perl_load_module(aTHX_ 0, newSVpvn("File::Glob", 10), Nullsv,
			 /* null-terminated import list */
			 newSVpvn(":globally", 9), Nullsv);
d6112 4
d6120 1
a6120 1
    if (gv && GvIMPORTED_CV(gv)) {
a6137 1
    SvREFCNT_dec((SV*)gv); /* had excess refcnt */
d6186 1
a6186 1
	return too_few_arguments(o,PL_op_desc[o->op_type]);
d6223 1
a6223 1
    if ((o->op_flags & OPf_KIDS) && ckWARN(WARN_DEPRECATED)) {
d6230 1
a6230 1
	    break;                      /* Globals via GV can be undef */ 
d6233 1
a6233 1
	    Perl_warner(aTHX_ WARN_DEPRECATED,
d6235 1
a6235 1
	    Perl_warner(aTHX_ WARN_DEPRECATED,
d6243 1
a6243 1
	    break;                      /* Globals via GV can be undef */ 
d6245 1
a6245 1
	    Perl_warner(aTHX_ WARN_DEPRECATED,
d6247 1
a6247 1
	    Perl_warner(aTHX_ WARN_DEPRECATED,
d6288 1
a6288 1
	
d6292 1
a6292 23
    o = listkids(o);

    o->op_private = 0;
#ifdef USE_LOCALE
    if (PL_hints & HINT_LOCALE)
	o->op_private |= OPpLOCALE;
#endif

    return o;
}

OP *
Perl_ck_fun_locale(pTHX_ OP *o)
{
    o = ck_fun(o);

    o->op_private = 0;
#ifdef USE_LOCALE
    if (PL_hints & HINT_LOCALE)
	o->op_private |= OPpLOCALE;
#endif

    return o;
a6325 12
Perl_ck_scmp(pTHX_ OP *o)
{
    o->op_private = 0;
#ifdef USE_LOCALE
    if (PL_hints & HINT_LOCALE)
	o->op_private |= OPpLOCALE;
#endif

    return o;
}

OP *
d6340 6
a6345 3
	    (void)SvUPGRADE(sv, SVt_PVIV);
	    (void)SvIOK_on(sv);
	    PERL_HASH(SvUVX(sv), SvPVX(sv), SvCUR(sv));
a6346 1
	    kSVOP->op_sv = Nullsv;
d6405 2
d6428 17
d6496 1
a6496 1
	
d6498 1
a6498 1
#ifdef USE_THREADS
d6512 1
a6512 1
#endif /* USE_THREADS */
a6521 5
    o->op_private = 0;
#ifdef USE_LOCALE
    if (PL_hints & HINT_LOCALE)
	o->op_private |= OPpLOCALE;
#endif
d6527 1
a6527 1
	OP *k;
d6538 1
a6538 1
		    null(kid);			/* wipe out leave */
d6556 1
a6556 1
	    peep(k);
d6569 1
a6569 1
	    null(firstkid);
d6590 2
a6591 2
    GvMULTI_on(gv_fetchpv("a", TRUE, SVt_PV)); 
    GvMULTI_on(gv_fetchpv("b", TRUE, SVt_PV)); 
d6677 4
d6695 1
a6695 1
	return too_many_arguments(o,PL_op_desc[o->op_type]);
d6701 1
a6701 1
Perl_ck_join(pTHX_ OP *o) 
d6707 3
a6709 3
	    if (kPMOP->op_pmregexp)
		pmstr = kPMOP->op_pmregexp->precomp;
	    Perl_warner(aTHX_ WARN_SYNTAX,
d6729 2
d6738 1
a6738 1
	null(cvop);		/* disable rv2cv */
d6827 3
d6833 1
d6835 23
d6859 5
a6863 3
		    if (o2->op_type != OP_RV2GV)
			bad_type(arg, "symbol", gv_ename(namegv), o2);
		    goto wrapref;
d6865 5
a6869 3
		    if (o2->op_type != OP_ENTERSUB)
			bad_type(arg, "subroutine entry", gv_ename(namegv), o2);
		    goto wrapref;
d6871 7
a6877 6
		    if (o2->op_type != OP_RV2SV
			&& o2->op_type != OP_PADSV
			&& o2->op_type != OP_HELEM
			&& o2->op_type != OP_AELEM
			&& o2->op_type != OP_THREADSV)
		    {
d6879 1
a6879 2
		    }
		    goto wrapref;
d6881 4
a6884 1
		    if (o2->op_type != OP_RV2AV && o2->op_type != OP_PADAV)
d6886 1
a6886 1
		    goto wrapref;
d6888 7
a6894 3
		    if (o2->op_type != OP_RV2HV && o2->op_type != OP_PADHV)
			bad_type(arg, "hash", gv_ename(namegv), o2);
		  wrapref:
d6903 4
d6910 2
d6919 1
a6919 1
			gv_ename(namegv), SvPV((SV*)cv, n_a));
d7013 1
a7013 1
		     * another pad, so make a copy. */
d7022 2
d7044 1
a7044 1
		null(o->op_next);
d7062 9
a7070 1
	    goto nothin;
d7085 1
a7085 1
		    null(o->op_next);
d7096 1
a7096 1
		if (pop->op_type == OP_CONST &&
d7101 1
a7101 1
		    (i = SvIV(((SVOP*)pop)->op_sv) - PL_compiling.cop_arybase)
d7106 3
a7108 3
		    null(o->op_next);
		    null(pop->op_next);
		    null(pop);
d7124 1
a7124 1
		    Perl_warner(aTHX_ WARN_PROTOTYPE,
d7129 11
d7155 1
a7155 1
	    peep(cLOGOP->op_other);
d7176 1
a7176 1
	    while (cPMOP->op_pmreplstart && 
d7184 1
a7184 1
	    if (ckWARN(WARN_SYNTAX) && o->op_next 
d7193 1
a7193 1
		    Perl_warner(aTHX_ WARN_EXEC,
d7195 1
a7195 1
		    Perl_warner(aTHX_ WARN_EXEC,
d7201 1
a7201 1
	
d7208 1
a7208 1
	    char *key;
d7210 1
a7210 1
	
d7212 16
a7227 2
	    if ((o->op_private & (OPpLVAL_INTRO))
		|| ((BINOP*)o)->op_last->op_type != OP_CONST)
d7229 1
d7234 1
a7234 1
	    if (!SvOBJECT(lexname))
a7238 1
	    svp = cSVOPx_svp(((BINOP*)o)->op_last);
d7240 2
a7241 1
	    indsvp = hv_fetch(GvHV(*fields), key, keylen, FALSE);
d7262 1
a7262 1
	
d7283 1
a7283 1
	    if (!SvOBJECT(lexname))
d7306 2
a7307 1
		indsvp = hv_fetch(GvHV(*fields), key, keylen, FALSE);
d7334 57
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
d58 1
d106 24
a134 1
    dTHR;
d140 1
a140 1
	  (PL_hints & HINT_UTF8 && (name[1] & 0xc0) == 0xc0) ||
d189 1
a264 1
    dTHR;
d348 3
a350 1
			if (ckWARN(WARN_CLOSURE) && !SvFAKE(sv) && !CvUNIQUE(cv))
d353 1
a410 1
    dTHR;
a472 1
    dTHR;
a491 1
    dTHR;
a541 1
    dTHR;
a557 1
    dTHR;
a584 1
    dTHR;
a613 1
    dTHR;
a641 1
    dTHR;
d802 1
d862 2
a863 2
    Safefree(CopFILE(cop));		/* XXXXX share in a pvtable? */
    Safefree(CopSTASHPV(cop));		/* XXXXX share in a pvtable? */
a925 1
	dTHR;
a1020 2
    {
	dTHR;
a1021 1
    }
a1137 1
	    dTHR;
a1177 1
    case OP_SCALAR:
d1196 2
d1206 2
a1207 5
    if (useless) {
	dTHR;
	if (ckWARN(WARN_VOID))
	    Perl_warner(aTHX_ WARN_VOID, "Useless use of %s in void context", useless);
    }
a1307 1
	    dTHR;
a1337 1
    dTHR;
d1355 25
d1410 1
d1545 1
a1545 1
	    PL_modcount = 10000;
a1553 1
    case OP_AASSIGN:
d1556 4
a1561 1
    case OP_REFGEN:
d1563 1
a1563 1
	PL_modcount = 10000;
d1582 1
a1582 1
	PL_modcount = 10000;
d1587 2
d1616 2
d1632 2
d1640 1
d1659 5
d1665 2
a1666 1
    o->op_flags |= OPf_MOD;
d1675 2
a1676 1
    else if (type != OP_GREPSTART && type != OP_ENTERSUB)
d1901 31
a2013 1
    dTHR;
d2032 2
a2033 1
    if (right->op_type == OP_MATCH ||
d2035 1
a2035 1
	right->op_type == OP_TRANS) {
d2037 3
a2039 1
	if (right->op_type != OP_MATCH)
a2099 1
    dTHR;
a2127 1
    dTHR;
a2154 1
    dTHR;
a2198 1
	dTHR;
d2201 1
a2201 1
	    for (s = PL_bufptr; *s && (isALNUM(*s) || (*s & 0x80) || strchr("@@$%, ",*s)); s++) ;
a2235 1
    dTHR;
a2352 1
    dTHR;
a2399 7
    if (cLISTOPo->op_children < 7) {
	/* XXX do we really need to do this if we're done appending?? */
	for (kid = cLISTOPo->op_first; kid; kid = kid->op_sibling)
	    last = kid;
	cLISTOPo->op_last = last;	/* in case check substituted last arg */
    }

a2426 1
    ((LISTOP*)first)->op_children++;
d2447 2
a2448 4
    first->op_children += last->op_children;
    if (first->op_children)
	first->op_flags |= OPf_KIDS;
    
d2478 1
a2478 1
	((LISTOP*)last)->op_children++;
d2511 2
a2512 1
    listop->op_children = (first != 0) + (last != 0);
a2531 2
    else if (listop->op_children)
	listop->op_flags |= OPf_KIDS;
d2628 2
a2629 2
    register U8 *t = (U8*)SvPV(tstr, tlen);
    register U8 *r = (U8*)SvPV(rstr, rlen);
d2635 1
d2638 1
d2642 6
d2654 1
a2654 1
	I32 ulen;
a2664 1
	I32 grows = 0;
d2669 2
d2673 1
a2673 1
	    U8 tmpbuf[UTF8_MAXLEN];
d2675 1
d2683 1
a2683 1
		if (*t == 0xff) {
d2691 2
a2692 1
		UV val = utf8_to_uv(s, &ulen);
d2704 2
a2705 2
		if (*s == 0xff)
		    val = utf8_to_uv(s+1, &ulen);
d2717 1
d2723 3
a2725 2
	    if (to_utf && from_utf) {	/* only counting characters */
		if (t == r || (tlen == rlen && memEQ(t, r, tlen)))
d2727 1
a2727 6
	    }
	    else {	/* straight latin-1 translation */
		if (tlen == 4 && memEQ(t, "\0\377\303\277", 4) &&
		    rlen == 4 && memEQ(r, "\0\377\303\277", 4))
		    o->op_private |= OPpTRANS_IDENTICAL;
	    }
d2733 1
a2733 1
		tfirst = (I32)utf8_to_uv(t, &ulen);
d2736 2
a2737 1
		    tlast = (I32)utf8_to_uv(++t, &ulen);
d2747 1
a2747 1
		    rfirst = (I32)utf8_to_uv(r, &ulen);
d2750 2
a2751 1
			rlast = (I32)utf8_to_uv(++r, &ulen);
d2793 2
a2794 14
		if (!grows) {
		    if (rfirst <= 0x80)
			;
		    else if (rfirst <= 0x800)
			grows |= (tfirst < 0x80);
		    else if (rfirst <= 0x10000)
			grows |= (tfirst < 0x800);
		    else if (rfirst <= 0x200000)
			grows |= (tfirst < 0x10000);
		    else if (rfirst <= 0x4000000)
			grows |= (tfirst < 0x200000);
		    else if (rfirst <= 0x80000000)
			grows |= (tfirst < 0x4000000);
		}
d2810 1
d2820 1
a2820 1
	if (grows && to_utf)
d2823 5
d2848 3
a2850 1
		else
d2852 1
d2873 3
a2875 1
	    if (tbl[t[i]] == -1)
d2877 1
d2880 2
a2890 1
    dTHR;
a2916 1
    dTHR;
d2936 1
a2936 1
	if ((PL_hints & HINT_UTF8) || (SvUTF8(pat) && !(PL_hints & HINT_BYTE)))
a3106 1
    dTHR;
a3134 1
    dTHR;
d3302 9
a3310 2
    utilize(!(flags & PERL_LOADMOD_DENY), start_subparse(FALSE, 0),
	    veop, modname, imop);
a3395 1
	dTHR;
d3452 3
d3456 1
d3501 1
a3501 1
		    if (PL_modcount < 10000 &&
a3535 1
    dTHR;
d3575 1
a3575 1
    CopFILE_set(cop, CopFILE(PL_curcop));	/* XXXXX share in a pvtable? */
d3577 1
a3577 1
    CopFILEGV_set(cop, (GV*)SvREFCNT_inc(CopFILEGV(PL_curcop)));
a3623 1
    dTHR;
a3734 1
    dTHR;
a3787 1
    dTHR;
a3833 1
    dTHR;
a3888 1
    dTHR;
a3928 1
	loopflags |= OPpLOOP_CONTINUE;
d3931 4
a3934 1
	cont = append_elem(OP_LINESEQ, cont, newOP(OP_UNSTACK, 0));
a3956 2
	if (!next)
	    next = condop;
a4080 1
    dTHR;
a4106 1
    dTHR;
d4128 1
a4128 2
	if (!CvCLONED(cv))
	    op_free(CvROOT(cv));
a4132 2
    CvFLAGS(cv) = 0;
    SvREFCNT_dec(CvGV(cv));
d4134 7
a4140 1
    SvREFCNT_dec(CvOUTSIDE(cv));
d4163 1
a4215 1
    dTHR;
d4246 1
a4246 1
    CvGV(cv)		= (GV*)SvREFCNT_inc(CvGV(proto));
d4248 1
a4248 1
    CvROOT(cv)		= CvROOT(proto);
a4357 2
    dTHR;

a4446 1
    dTHR;
d4509 3
a4511 1
	    if (PL_curstackinfo->si_type == PERLSI_SORT && PL_sortcop == CvSTART(cv))
d4513 1
d4570 24
a4593 2
	if (SvREFCNT(PL_compcv) > 1) /* XXX Make closures transit through stub. */
	    CvOUTSIDE(PL_compcv) = (CV*)SvREFCNT_inc((SV*)cv);
d4604 1
a4604 1
    CvGV(cv) = (GV*)SvREFCNT_inc(gv);
d4648 2
a4649 1
	CvROOT(cv) = newUNOP(OP_LEAVESUBLV, 0, scalarseq(block));
d4697 7
d4751 2
a4752 2
	    av_push(PL_beginav, SvREFCNT_inc(cv));
	    GvCV(gv) = 0;
d4764 2
a4765 2
	    av_store(PL_endav, 0, SvREFCNT_inc(cv));
	    GvCV(gv) = 0;
d4774 2
a4775 2
	    av_store(PL_checkav, 0, SvREFCNT_inc(cv));
	    GvCV(gv) = 0;
d4783 2
a4784 2
	    av_push(PL_initav, SvREFCNT_inc(cv));
	    GvCV(gv) = 0;
a4806 1
    dTHR;
d4809 1
d4811 2
a4813 2

    CopLINE_set(PL_curcop, PL_copline);
a4848 1
    dTHR;
d4885 1
a4885 1
    CvGV(cv) = (GV*)SvREFCNT_inc(gv);
d4909 2
a4910 2
	    av_push(PL_beginav, SvREFCNT_inc(cv));
	    GvCV(gv) = 0;
d4916 2
a4917 2
	    av_store(PL_endav, 0, SvREFCNT_inc(cv));
	    GvCV(gv) = 0;
d4925 2
a4926 2
	    av_store(PL_checkav, 0, SvREFCNT_inc(cv));
	    GvCV(gv) = 0;
d4933 2
a4934 2
	    av_push(PL_initav, SvREFCNT_inc(cv));
	    GvCV(gv) = 0;
a4946 1
    dTHR;
d4971 1
a4971 1
    CvGV(cv) = (GV*)SvREFCNT_inc(gv);
a5043 2
    dTHR;
    
a5339 1
    dTHR;
d5434 1
d5440 1
a5449 1
    dTHR;
a5486 1
    dTHR;
d5726 1
a5811 1
    dTHR;
d5815 4
d5828 4
d6050 11
d6123 1
d6132 2
a6133 2
    if (o->op_flags & OPf_STACKED) {		     /* may have been cleared */
	OP *kid = cLISTOPo->op_first->op_sibling;	/* get past pushmark */
d6135 1
a6135 1
	kid = kUNOP->op_first;				/* get past null */
d6165 4
a6168 2
	    kid = cLISTOPo->op_first->op_sibling;	/* get past pushmark */
	    if (o->op_type == OP_SORT)
d6170 1
d6176 3
a6178 1
	    null(cLISTOPo->op_first->op_sibling);
d6181 4
a6190 1
    dTHR;
a6249 1
    cLISTOPo->op_children--;
d6271 1
a6271 1
    if (kid->op_type != OP_MATCH) {
a6322 1
    dTHR;
d6387 3
a6389 1
		    bad_type(arg, "block", gv_ename(namegv), o2);
d6437 2
a6438 2
		    if (o2->op_type != OP_RV2CV)
			bad_type(arg, "sub", gv_ename(namegv), o2);
d6516 16
a6536 1
    dTHR;
a6538 1
    OP *last_composite = Nullop;
a6556 1
	    last_composite = Nullop;
d6568 12
a6579 3
		SvREFCNT_dec(PL_curpad[ix]);
		SvPADTMP_on(cSVOPo->op_sv);
		PL_curpad[ix] = cSVOPo->op_sv;
d6647 1
a6647 1
		      (OPpLVAL_INTRO|OPpLVAL_DEFER|OPpDEREF)) &&
d6695 1
d6697 2
d6700 2
d6703 2
d6712 3
a6845 36

	case OP_RV2AV:
	case OP_RV2HV:
	    if (!(o->op_flags & OPf_WANT)
		|| (o->op_flags & OPf_WANT) == OPf_WANT_LIST)
	    {
		last_composite = o;
	    }
	    o->op_seq = PL_op_seqmax++;
	    break;

	case OP_RETURN:
	    if (o->op_next && o->op_next->op_type != OP_LEAVESUBLV) {
		o->op_seq = PL_op_seqmax++;
		break;
	    }
	    /* FALL THROUGH */

	case OP_LEAVESUBLV:
	    if (last_composite) {
		OP *r = last_composite;

		while (r->op_sibling)
		   r = r->op_sibling;
		if (r->op_next == o 
		    || (r->op_next->op_type == OP_LIST
			&& r->op_next->op_next == o))
		{
		    if (last_composite->op_type == OP_RV2AV)
			yyerror("Lvalue subs returning arrays not implemented yet");
		    else
			yyerror("Lvalue subs returning hashes not implemented yet");
			;
		}		
	    }
	    /* FALL THROUGH */
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
d19 1
d21 1
d23 22
a44 4
#ifdef PERL_OBJECT
#define CHECKCALL this->*check
#else
#define CHECKCALL *check
a45 1

d53 1
a53 1
	 croak("%s trapped by operation mask", op_desc[type]),	\
d55 1
a55 1
     : (CHECKCALL[type])((OP*)o))
a58 16
static bool scalar_mod_type _((OP *o, I32 type));
#ifndef PERL_OBJECT
static I32 list_assignment _((OP *o));
static void bad_type _((I32 n, char *t, char *name, OP *kid));
static OP *modkids _((OP *o, I32 type));
static OP *no_fh_allowed _((OP *o));
static OP *scalarboolean _((OP *o));
static OP *too_few_arguments _((OP *o, char* name));
static OP *too_many_arguments _((OP *o, char* name));
static void null _((OP* o));
static PADOFFSET pad_findlex _((char* name, PADOFFSET newoff, U32 seq,
	CV* startcv, I32 cx_ix, I32 saweval, U32 flags));
static OP *newDEFSVOP _((void));
static OP *new_logop _((I32 type, I32 flags, OP **firstp, OP **otherp));
#endif

d60 1
a60 1
gv_ename(GV *gv)
d62 1
a63 1
    STRLEN n_a;
d69 1
a69 1
no_fh_allowed(OP *o)
d71 2
a72 2
    yyerror(form("Missing comma after first argument to %s function",
		 op_desc[o->op_type]));
d77 1
a77 1
too_few_arguments(OP *o, char *name)
d79 1
a79 1
    yyerror(form("Not enough arguments for %s", name));
d84 1
a84 1
too_many_arguments(OP *o, char *name)
d86 1
a86 1
    yyerror(form("Too many arguments for %s", name));
d91 1
a91 1
bad_type(I32 n, char *t, char *name, OP *kid)
d93 2
a94 2
    yyerror(form("Type of arg %d to %s must be %s (not %s)",
		 (int)n, name, t, op_desc[kid->op_type]));
d97 2
a98 2
void
assertref(OP *o)
d100 3
a102 16
    int type = o->op_type;
    if (type != OP_AELEM && type != OP_HELEM && type != OP_GELEM) {
	yyerror(form("Can't use subscript on %s", op_desc[type]));
	if (type == OP_ENTERSUB || type == OP_RV2HV || type == OP_PADHV) {
	    dTHR;
	    SV *msg = sv_2mortal(
			newSVpvf("(Did you mean $ or @@ instead of %c?)\n",
				 type == OP_ENTERSUB ? '&' : '%'));
	    if (PL_in_eval & 2)
		warn("%_", msg);
	    else if (PL_in_eval)
		sv_catsv(GvSV(PL_errgv), msg);
	    else
		PerlIO_write(PerlIO_stderr(), SvPVX(msg), SvCUR(msg));
	}
    }
d108 1
a108 1
pad_allocmy(char *name)
d114 21
a134 3
    if (!(isALPHA(name[1]) || name[1] == '_' && (int)strlen(name) > 2)) {
	if (!isPRINT(name[1])) {
	    name[3] = '\0';
d138 1
a138 1
	croak("Can't use global %s in \"my\"",name);
d140 1
a140 1
    if (PL_dowarn && AvFILLp(PL_comppad_name) >= 0) {
d142 3
a144 1
	for (off = AvFILLp(PL_comppad_name); off > PL_comppad_name_floor; off--) {
d148 2
d152 6
a157 2
		warn("\"my\" variable %s masks earlier declaration in same %s",
			name, (SvIVX(sv) == PAD_MAX ? "scope" : "statement"));
d161 15
d183 2
a184 1
	    croak("Can't declare class for non-scalar %s in \"my\"",name);
d190 5
d196 1
a196 1
    SvNVX(sv) = (double)PAD_MAX;
d209 25
d237 2
a238 2
pad_findlex(char *name, PADOFFSET newoff, U32 seq, CV* startcv, I32 cx_ix, I32 saweval,
	    U32 flags)
d276 1
a276 1
		oldpad = (AV*)*av_fetch(curlist, depth, FALSE);
d279 1
a279 14
		    SV *namesv = NEWSV(1103,0);
		    newoff = pad_alloc(OP_PADSV, SVs_PADMY);
		    sv_upgrade(namesv, SVt_PVNV);
		    sv_setpv(namesv, name);
		    av_store(PL_comppad_name, newoff, namesv);
		    SvNVX(namesv) = (double)PL_curcop->cop_seq;
		    SvIVX(namesv) = PAD_MAX;	/* A ref, intro immediately */
		    SvFAKE_on(namesv);		/* A ref, not a real var */
		    if (SvOBJECT(svp[off])) {	/* A typed var */
			SvOBJECT_on(namesv);
			(void)SvUPGRADE(namesv, SVt_PVMG);
			SvSTASH(namesv) = (HV*)SvREFCNT_inc((SV*)SvSTASH(svp[off]));
			PL_sv_objcount++;
		    }
d293 15
a307 1
				if (CvANON(bcv))
d309 1
d311 1
a311 1
				    if (PL_dowarn
d314 1
a314 1
					warn(
d324 3
a326 2
			if (PL_dowarn && !SvFAKE(sv) && !CvUNIQUE(cv))
			    warn("Variable \"%s\" will not stay shared", name);
d358 1
d360 1
a360 1
		/* require must have its own scope */
d364 1
d382 1
a382 1
pad_findmy(char *name)
d415 1
a415 1
	    if (SvIVX(sv))
d445 1
a445 1
pad_leavemy(I32 fill)
d447 1
d453 2
a454 2
	    if ((sv = svp[off]) && sv != &PL_sv_undef)
		warn("%s never introduced", SvPVX(sv));
d465 1
a465 1
pad_alloc(I32 optype, U32 tmptype)
d472 1
a472 1
	croak("panic: pad_alloc");
d494 1
a494 1
	    if (!(SvFLAGS(sv) & (SVs_PADTMP|SVs_PADMY)))
d502 4
a505 3
    DEBUG_X(PerlIO_printf(Perl_debug_log, "0x%lx Pad 0x%lx alloc %ld for %s\n",
			  (unsigned long) thr, (unsigned long) PL_curpad,
			  (long) retval, op_name[optype]));
d507 4
a510 3
    DEBUG_X(PerlIO_printf(Perl_debug_log, "Pad 0x%lx alloc %ld for %s\n",
			  (unsigned long) PL_curpad,
			  (long) retval, op_name[optype]));
d516 1
a516 1
pad_sv(PADOFFSET po)
d520 3
a522 2
    DEBUG_X(PerlIO_printf(Perl_debug_log, "0x%lx Pad 0x%lx sv %d\n",
			  (unsigned long) thr, (unsigned long) PL_curpad, po));
d525 3
a527 3
	croak("panic: pad_sv po");
    DEBUG_X(PerlIO_printf(Perl_debug_log, "Pad 0x%lx sv %d\n",
			  (unsigned long) PL_curpad, po));
d533 1
a533 1
pad_free(PADOFFSET po)
d539 1
a539 1
	croak("panic: pad_free curpad");
d541 1
a541 1
	croak("panic: pad_free po");
d543 3
a545 2
    DEBUG_X(PerlIO_printf(Perl_debug_log, "0x%lx Pad 0x%lx free %d\n",
			  (unsigned long) thr, (unsigned long) PL_curpad, po));
d547 2
a548 2
    DEBUG_X(PerlIO_printf(Perl_debug_log, "Pad 0x%lx free %d\n",
			  (unsigned long) PL_curpad, po));
d550 1
a550 1
    if (PL_curpad[po] && PL_curpad[po] != &PL_sv_undef)
d552 4
d561 1
a561 1
pad_swipe(PADOFFSET po)
d565 1
a565 1
	croak("panic: pad_swipe curpad");
d567 1
a567 1
	croak("panic: pad_swipe po");
d569 3
a571 2
    DEBUG_X(PerlIO_printf(Perl_debug_log, "0x%lx Pad 0x%lx swipe %d\n",
			  (unsigned long) thr, (unsigned long) PL_curpad, po));
d573 2
a574 2
    DEBUG_X(PerlIO_printf(Perl_debug_log, "Pad 0x%lx swipe %d\n",
			  (unsigned long) PL_curpad, po));
d590 1
a590 1
pad_reset(void)
d597 1
a597 1
	croak("panic: pad_reset curpad");
d599 3
a601 2
    DEBUG_X(PerlIO_printf(Perl_debug_log, "0x%lx Pad 0x%lx reset\n",
			  (unsigned long) thr, (unsigned long) PL_curpad));
d603 2
a604 2
    DEBUG_X(PerlIO_printf(Perl_debug_log, "Pad 0x%lx reset\n",
			  (unsigned long) PL_curpad));
d620 1
a620 1
find_threadsv(char *name)
d676 1
a676 1
	DEBUG_S(PerlIO_printf(PerlIO_stderr(),
d688 1
a688 1
op_free(OP *o)
d691 1
d696 20
d722 19
d742 3
d746 6
a751 5
    case OP_NULL:
	o->op_targ = 0;	/* Was holding old type, if any. */
	break;
    case OP_ENTEREVAL:
	o->op_targ = 0;	/* Was holding hints. */
a757 3
    case OP_THREADSV:
	o->op_targ = 0;	/* Was holding index into thr->threadsv AV. */
	break;
d761 1
a761 1
	    || (check[o->op_type] != FUNC_NAME_TO_PTR(ck_ftst)))
d767 15
a781 6
	SvREFCNT_dec(cGVOPo->op_gv);
	break;
    case OP_NEXTSTATE:
    case OP_DBSTATE:
	Safefree(cCOPo->cop_label);
	SvREFCNT_dec(cCOPo->cop_filegv);
d785 1
d795 8
a802 1
	Safefree(cPVOPo->op_pv);
d806 15
a821 1
    case OP_PUSHRE:
d824 2
d827 1
d831 1
a831 1
    if (o->op_targ > 0)
d833 3
d837 13
a849 1
    Safefree(o);
d853 1
a853 1
null(OP *o)
d855 3
a857 2
    if (o->op_type != OP_NULL && o->op_type != OP_THREADSV && o->op_targ > 0)
	pad_free(o->op_targ);
d860 1
a860 1
    o->op_ppaddr = ppaddr[OP_NULL];
d868 1
a868 1
linklist(OP *o)
d892 1
a892 1
scalarkids(OP *o)
d903 1
a903 1
scalarboolean(OP *o)
d905 1
a905 2
    if (PL_dowarn &&
	o->op_type == OP_SASSIGN && cBINOPo->op_first->op_type == OP_CONST) {
d907 2
a908 1
	line_t oldline = PL_curcop->cop_line;
d910 5
a914 4
	if (PL_copline != NOLINE)
	    PL_curcop->cop_line = PL_copline;
	warn("Found = in conditional, should be ==");
	PL_curcop->cop_line = oldline;
d920 1
a920 1
scalar(OP *o)
d927 1
d929 1
d965 1
a965 1
	while (kid = kid->op_sibling) {
d989 1
a989 1
scalarvoid(OP *o)
d994 12
d1008 2
a1009 2
    U8 want = o->op_flags & OPf_WANT;
    if (!o || (want && want != OPf_WANT_SCALAR) || PL_error_count
d1011 1
d1013 1
d1015 6
d1025 1
a1025 1
	if (!(opargs[o->op_type] & OA_FOLDCONST))
d1104 2
a1105 2
	if (!(o->op_private & OPpLVAL_INTRO))
	    useless = op_desc[o->op_type];
d1112 1
a1112 1
	if (!(o->op_private & OPpLVAL_INTRO) &&
a1116 5
    case OP_NEXTSTATE:
    case OP_DBSTATE:
	WITH_THR(PL_curcop = ((COP*)o));		/* for warning below */
	break;

d1118 15
a1132 10
	sv = cSVOPo->op_sv;
	if (PL_dowarn) {
	    useless = "a constant";
	    if (SvNIOK(sv) && (SvNV(sv) == 0.0 || SvNV(sv) == 1.0))
		useless = 0;
	    else if (SvPOK(sv)) {
		if (strnEQ(SvPVX(sv), "di", 2) ||
		    strnEQ(SvPVX(sv), "ds", 2) ||
		    strnEQ(SvPVX(sv), "ig", 2))
			useless = 0;
d1135 1
a1135 2
	null(o);		/* don't execute a constant */
	SvREFCNT_dec(sv);	/* don't even remember it */
d1140 1
a1140 1
	o->op_ppaddr = ppaddr[OP_PREINC];
d1145 1
a1145 1
	o->op_ppaddr = ppaddr[OP_PREDEC];
a1155 2
	if (o->op_targ == OP_NEXTSTATE || o->op_targ == OP_DBSTATE)
	    WITH_THR(PL_curcop = ((COP*)o));	/* for warning below */
d1159 2
d1190 5
a1194 2
    if (useless && PL_dowarn)
	warn("Useless use of %s in void context", useless);
d1199 1
a1199 1
listkids(OP *o)
d1210 1
a1210 1
list(OP *o)
d1217 1
d1219 1
d1221 6
d1258 1
a1258 1
	while (kid = kid->op_sibling) {
d1285 1
a1285 1
scalarseq(OP *o)
d1313 1
a1313 1
modkids(OP *o, I32 type)
d1324 1
a1324 1
mod(OP *o, I32 type)
a1327 1
    SV *sv;
d1333 6
d1347 1
a1347 1
	    PL_compiling.cop_arybase = (I32)SvIV(((SVOP*)PL_eval_start)->op_sv);
d1357 1
a1357 1
	    croak("That use of $[ is unsupported");
d1367 1
a1367 1
	    o->op_ppaddr = ppaddr[OP_RV2CV];
d1372 86
d1464 7
a1470 3
	yyerror(form("Can't modify %s in %s",
		     op_desc[o->op_type],
		     type ? op_desc[type] : "local"));
d1506 1
a1506 1
	    croak("Can't localize through a reference");
d1528 1
a1528 1
	    croak("Can't localize through a reference");
d1535 2
d1552 1
a1552 1
	    croak("Can't localize lexical variable %s",
d1600 3
a1602 1
	if (!(o->op_flags & OPf_KIDS))
d1628 2
a1629 2
static bool
scalar_mod_type(OP *o, I32 type)
d1667 2
a1668 2
    case OP_ANDASSIGN:	/* may work later */
    case OP_ORASSIGN:	/* may work later */
d1675 23
d1699 1
a1699 1
refkids(OP *o, I32 type)
d1710 1
a1710 1
ref(OP *o, I32 type)
d1719 1
a1719 1
	if ((type == OP_DEFINED || type == OP_LOCK) &&
d1722 1
a1722 1
	    o->op_ppaddr = ppaddr[OP_RV2CV];
d1734 2
d1756 2
d1798 52
a1849 2
OP *
my(OP *o)
d1860 1
a1860 1
	    my(kid);
d1863 5
d1873 3
a1875 1
	yyerror(form("Can't declare %s in my", op_desc[o->op_type]));
d1878 17
d1901 20
a1920 1
sawparens(OP *o)
d1928 1
a1928 1
bind_match(I32 type, OP *left, OP *right)
d1930 1
d1933 14
a1946 12
    if (PL_dowarn &&
	(left->op_type == OP_RV2AV ||
	 left->op_type == OP_RV2HV ||
	 left->op_type == OP_PADAV ||
	 left->op_type == OP_PADHV)) {
	char *desc = op_desc[(right->op_type == OP_SUBST ||
			      right->op_type == OP_TRANS)
			     ? right->op_type : OP_MATCH];
	char *sample = ((left->op_type == OP_RV2AV ||
			 left->op_type == OP_PADAV)
			? "@@array" : "%hash");
	warn("Applying %s to %s will act on scalar(%s)", desc, sample, sample);
d1969 1
a1969 1
invert(OP *o)
d1978 1
a1978 1
scope(OP *o)
d1984 1
a1984 1
	    o->op_ppaddr = ppaddr[OP_LEAVE];
d1990 1
a1990 1
		o->op_ppaddr = ppaddr[OP_SCOPE];
d1992 1
a1992 2
		if (kid->op_type == OP_NEXTSTATE || kid->op_type == OP_DBSTATE){
		    SvREFCNT_dec(((COP*)kid)->cop_filegv);
a1993 1
		}
d2003 1
a2003 1
save_hints(void)
d2012 1
a2012 1
block_start(int full)
d2018 5
a2022 6
    if (full) {
	if ((PL_comppad_name_fill = AvFILLp(PL_comppad_name)) > 0)
	    PL_comppad_name_floor = PL_comppad_name_fill;
	else
	    PL_comppad_name_floor = 0;
    }
d2032 5
d2041 1
a2041 1
block_end(I32 floor, OP *seq)
d2048 1
d2057 1
a2057 1
newDEFSVOP(void)
d2069 1
a2069 1
newPROG(OP *o)
d2073 5
a2077 1
	PL_eval_root = newUNOP(OP_LEAVEEVAL, ((PL_in_eval & 4) ? OPf_SPECIAL : 0), o);
d2079 2
d2090 2
d2098 1
a2098 1
	    CV *cv = perl_get_cv("DB::postponed", FALSE);
d2102 1
a2102 1
		XPUSHs((SV*)PL_compiling.cop_filegv);
d2104 1
a2104 1
		perl_call_sv((SV*)cv, G_DISCARD);
d2111 1
a2111 1
localize(OP *o, I32 lex)
d2116 2
a2117 1
	if (PL_dowarn && PL_bufptr > PL_oldbufptr && PL_bufptr[-1] == ',') {
d2119 1
a2119 1
	    for (s = PL_bufptr; *s && (isALNUM(*s) || strchr("@@$%, ",*s)); s++) ;
d2121 3
a2123 1
		warn("Parens missing around \"%s\" list", lex ? "my" : "local");
d2126 4
d2132 1
a2132 4
    if (lex)
	return my(o);
    else
	return mod(o, OP_NULL);		/* a bit kludgey */
d2136 1
a2136 1
jmaybe(OP *o)
d2152 1
a2152 1
fold_constants(register OP *o)
d2159 1
a2159 1
    if (opargs[type] & OA_RETSCALAR)
d2161 1
a2161 1
    if (opargs[type] & OA_TARGET)
d2164 8
a2171 2
    if ((opargs[type] & OA_OTHERINT) && (PL_hints & HINT_INTEGER))
	o->op_ppaddr = ppaddr[type = ++(o->op_type)];
d2173 1
a2173 1
    if (!(opargs[type] & OA_FOLDCONST))
d2177 4
d2200 7
a2206 5
	if (curop->op_type != OP_CONST &&
		curop->op_type != OP_LIST &&
		curop->op_type != OP_SCALAR &&
		curop->op_type != OP_NULL &&
		curop->op_type != OP_PUSHMARK) {
d2214 1
a2214 1
    CALLRUNOPS();
d2231 1
a2231 1
	    if ((double)iv == SvNV(sv)) {
d2242 1
a2242 1
    if (!(opargs[type] & OA_OTHERINT))
d2246 4
a2249 1
	if (type == OP_DIVIDE || !(o->op_flags & OPf_KIDS))
d2251 1
d2259 1
a2259 1
	    if (opargs[curop->op_type] & OA_RETINTEGER)
d2263 1
a2263 1
	o->op_ppaddr = ppaddr[++(o->op_type)];
d2270 1
a2270 1
gen_constant_list(register OP *o)
d2282 3
a2284 2
    pp_pushmark(ARGS);
    CALLRUNOPS();
d2286 1
a2286 1
    pp_anonlist(ARGS);
d2290 1
a2290 1
    o->op_ppaddr = ppaddr[OP_RV2AV];
d2299 1
a2299 1
convert(I32 type, I32 flags, OP *o)
d2309 1
a2309 1
    if (!(opargs[type] & OA_MARK))
d2313 1
a2313 1
    o->op_ppaddr = ppaddr[type];
d2333 1
a2333 1
append_elem(I32 type, OP *first, OP *last)
d2341 5
a2345 2
    if (first->op_type != type || type==OP_LIST && first->op_flags & OPf_PARENS)
	    return newLISTOP(type, 0, first, last);
d2359 1
a2359 1
append_list(I32 type, LISTOP *first, LISTOP *last)
d2378 5
a2382 2

    Safefree(last);
d2387 1
a2387 1
prepend_elem(I32 type, OP *first, OP *last)
d2418 1
a2418 1
newNULLLIST(void)
d2424 1
a2424 1
force_list(OP *o)
d2433 1
a2433 1
newLISTOP(I32 type, I32 flags, OP *first, OP *last)
d2437 1
a2437 1
    Newz(1101, listop, 1, LISTOP);
d2440 1
a2440 1
    listop->op_ppaddr = ppaddr[type];
d2468 1
a2468 1
newOP(I32 type, I32 flags)
d2471 1
a2471 1
    Newz(1101, o, 1, OP);
d2473 1
a2473 1
    o->op_ppaddr = ppaddr[type];
d2478 1
a2478 1
    if (opargs[type] & OA_RETSCALAR)
d2480 1
a2480 1
    if (opargs[type] & OA_TARGET)
d2486 1
a2486 1
newUNOP(I32 type, I32 flags, OP *first)
d2492 1
a2492 1
    if (opargs[type] & OA_MARK)
d2495 1
a2495 1
    Newz(1101, unop, 1, UNOP);
d2497 1
a2497 1
    unop->op_ppaddr = ppaddr[type];
d2509 1
a2509 1
newBINOP(I32 type, I32 flags, OP *first, OP *last)
d2512 1
a2512 1
    Newz(1101, binop, 1, BINOP);
d2518 1
a2518 1
    binop->op_ppaddr = ppaddr[type];
d2531 1
a2531 1
    if (binop->op_next)
d2534 1
a2534 1
    binop->op_last = last = binop->op_first->op_sibling;
d2539 13
d2553 1
a2553 1
pmtrans(OP *o, OP *expr, OP *repl)
d2563 1
a2563 1
    I32 Delete;
a2567 1
    tbl = (short*)cPVOPo->op_pv;
d2569 1
a2569 1
    Delete	= o->op_private & OPpTRANS_DELETE;
d2572 189
d2768 1
a2768 1
		    if (Delete)
d2781 1
a2781 1
	if (!rlen && !Delete) {
d2784 1
a2784 1
		o->op_private |= OPpTRANS_COUNTONLY;
d2790 1
a2790 1
		if (Delete) {
d2808 1
a2808 1
newPMOP(I32 type, I32 flags)
d2813 1
a2813 1
    Newz(1101, pmop, 1, PMOP);
d2815 1
a2815 1
    pmop->op_ppaddr = ppaddr[type];
d2835 1
a2835 1
pmruntime(OP *o, OP *expr, OP *repl)
d2857 3
a2859 1
	pm->op_pmregexp = CALLREGCOMP(p, p + plen, pm);
d2865 2
d2872 1
a2872 1
	Newz(1101, rcop, 1, LOGOP);
d2874 1
a2874 1
	rcop->op_ppaddr = ppaddr[OP_REGCOMP];
d2900 2
a2901 2
	    if (PL_curcop->cop_line < PL_multi_end)
		PL_curcop->cop_line = PL_multi_end;
d2916 1
a2916 1
		if (opargs[curop->op_type] & OA_DANGEROUS) {
d2925 1
a2925 1
			GV *gv = ((GVOP*)curop)->op_gv;
d2967 1
a2967 1
	    Newz(1101, rcop, 1, LOGOP);
d2969 1
a2969 1
	    rcop->op_ppaddr = ppaddr[OP_SUBSTCONT];
d2989 1
a2989 1
newSVOP(I32 type, I32 flags, SV *sv)
d2992 1
a2992 1
    Newz(1101, svop, 1, SVOP);
d2994 1
a2994 1
    svop->op_ppaddr = ppaddr[type];
d2998 1
a2998 1
    if (opargs[type] & OA_RETSCALAR)
d3000 1
a3000 1
    if (opargs[type] & OA_TARGET)
d3006 21
a3026 1
newGVOP(I32 type, I32 flags, GV *gv)
d3029 6
a3034 12
    GVOP *gvop;
    Newz(1101, gvop, 1, GVOP);
    gvop->op_type = type;
    gvop->op_ppaddr = ppaddr[type];
    gvop->op_gv = (GV*)SvREFCNT_inc(gv);
    gvop->op_next = (OP*)gvop;
    gvop->op_flags = flags;
    if (opargs[type] & OA_RETSCALAR)
	scalar((OP*)gvop);
    if (opargs[type] & OA_TARGET)
	gvop->op_targ = pad_alloc(type, SVs_PADTMP);
    return CHECKOP(type, gvop);
d3038 1
a3038 1
newPVOP(I32 type, I32 flags, char *pv)
d3041 1
a3041 1
    Newz(1101, pvop, 1, PVOP);
d3043 1
a3043 1
    pvop->op_ppaddr = ppaddr[type];
d3047 1
a3047 1
    if (opargs[type] & OA_RETSCALAR)
d3049 1
a3049 1
    if (opargs[type] & OA_TARGET)
d3055 1
a3055 1
package(OP *o)
d3081 1
a3081 1
utilize(int aver, I32 floor, OP *version, OP *id, OP *arg)
a3083 1
    OP *meth;
d3090 1
a3090 1
	croak("Module name must be constant");
d3094 1
a3094 1
    if(version != Nullop) {
d3097 1
a3097 1
	if (arg == Nullop && !SvNIOK(vesv)) {
d3102 1
a3102 1
	    OP *meth;
d3104 2
a3105 2
	    if (version->op_type != OP_CONST || !SvNIOK(vesv))
		croak("Version number must be constant number");
d3111 4
a3114 1
	    meth = newSVOP(OP_CONST, 0, newSVpv("VERSION", 7));
d3117 2
a3118 2
			    prepend_elem(OP_LIST, pack, list(version)),
			    newUNOP(OP_METHOD, 0, meth)));
d3125 1
a3125 1
    else if(SvNIOK(((SVOP*)id)->op_sv)) {
d3129 2
d3133 6
a3138 5
	meth = newSVOP(OP_CONST, 0,
	    aver
		? newSVpv("import", 6)
		: newSVpv("unimport", 8)
	    );
d3140 3
a3142 3
		    append_elem(OP_LIST,
			prepend_elem(OP_LIST, pack, list(arg)),
			newUNOP(OP_METHOD, 0, meth)));
d3162 3
a3164 2
    newSUB(floor,
	newSVOP(OP_CONST, 0, newSVpv("BEGIN", 5)),
d3172 1
d3177 52
d3230 1
a3230 1
dofile(OP *term)
d3253 1
a3253 1
newSLICEOP(I32 flags, OP *subscript, OP *listval)
d3261 1
a3261 1
list_assignment(register OP *o)
d3270 2
a3271 2
	I32 t = list_assignment(cCONDOPo->op_first->op_sibling);
	I32 f = list_assignment(cCONDOPo->op_first->op_sibling->op_sibling);
d3295 1
a3295 1
newASSIGNOP(I32 flags, OP *left, I32 optype, OP *right)
d3313 2
d3325 2
a3326 3
	o = newBINOP(OP_AASSIGN, flags,
		list(force_list(right)),
		list(force_list(left)) );
d3328 9
a3337 1
	    OP *curop;
d3341 1
a3341 1
		if (opargs[curop->op_type] & OA_DANGEROUS) {
d3343 1
a3343 1
			GV *gv = ((GVOP*)curop)->op_gv;
d3381 1
a3381 1
		o->op_private = OPpASSIGN_COMMON;
d3395 7
a3401 1
			pm->op_pmreplroot = (OP*)((GVOP*)tmpop)->op_gv;
d3447 1
a3447 1
newSTATEOP(I32 flags, char *label, OP *o)
d3453 2
a3454 2
    Newz(1101, cop, 1, COP);
    if (PERLDB_LINE && PL_curcop->cop_line && PL_curstash != PL_debstash) {
d3456 1
a3456 1
	cop->op_ppaddr = ppaddr[ OP_DBSTATE ];
d3460 1
a3460 1
	cop->op_ppaddr = ppaddr[ OP_NEXTSTATE ];
d3463 1
a3463 1
    cop->op_private = 0 | (flags >> 8);
d3467 1
d3476 5
d3483 1
a3483 1
        cop->cop_line = PL_curcop->cop_line;
d3485 1
a3485 1
        cop->cop_line = PL_copline;
d3488 6
a3493 2
    cop->cop_filegv = (GV*)SvREFCNT_inc(PL_curcop->cop_filegv);
    cop->cop_stash = PL_curstash;
d3496 1
a3496 1
	SV **svp = av_fetch(GvAV(PL_curcop->cop_filegv),(I32)cop->cop_line, FALSE);
d3499 1
a3499 2
	    SvIVX(*svp) = 1;
	    SvSTASH(*svp) = (HV*)cop;
d3508 1
a3508 1
intro_my(void)
d3521 1
a3521 1
	    SvNVX(sv) = (double)PL_cop_seqmax;
d3530 1
a3530 1
newLOGOP(I32 type, I32 flags, OP *first, OP *other)
d3536 1
a3536 1
new_logop(I32 type, I32 flags, OP** firstp, OP** otherp)
d3564 2
a3565 2
	if (PL_dowarn && (first->op_private & OPpCONST_BARE))
	    warn("Probable precedence problem on %s", op_desc[type]);
d3583 1
a3583 1
    else if (PL_dowarn && (first->op_flags & OPf_KIDS)) {
d3593 1
d3595 1
d3601 1
d3603 4
a3606 1
		warnop = k1->op_type;
d3610 5
a3614 4
	    line_t oldline = PL_curcop->cop_line;
	    PL_curcop->cop_line = PL_copline;
	    warn("Value of %s%s can be \"0\"; test with defined()",
		 op_desc[warnop],
d3617 1
a3617 1
	    PL_curcop->cop_line = oldline;
d3627 1
a3627 1
    Newz(1101, logop, 1, LOGOP);
d3630 1
a3630 1
    logop->op_ppaddr = ppaddr[type];
d3648 1
a3648 1
newCONDOP(I32 flags, OP *first, OP *trueop, OP *falseop)
d3651 2
a3652 1
    CONDOP *condop;
d3677 8
a3684 1
    Newz(1101, condop, 1, CONDOP);
a3685 7
    condop->op_type = OP_COND_EXPR;
    condop->op_ppaddr = ppaddr[OP_COND_EXPR];
    condop->op_first = first;
    condop->op_flags = flags | OPf_KIDS;
    condop->op_true = LINKLIST(trueop);
    condop->op_false = LINKLIST(falseop);
    condop->op_private = 1 | (flags >> 8);
d3688 2
a3689 2
    condop->op_next = LINKLIST(first);
    first->op_next = (OP*)condop;
d3693 1
a3693 1
    o = newUNOP(OP_NULL, 0, (OP*)condop);
d3695 1
a3695 2
    trueop->op_next = o;
    falseop->op_next = o;
d3697 1
d3702 1
a3702 1
newRANGE(I32 flags, OP *left, OP *right)
d3705 1
a3705 1
    CONDOP *condop;
d3708 1
d3711 1
a3711 1
    Newz(1101, condop, 1, CONDOP);
d3713 7
a3719 7
    condop->op_type = OP_RANGE;
    condop->op_ppaddr = ppaddr[OP_RANGE];
    condop->op_first = left;
    condop->op_flags = OPf_KIDS;
    condop->op_true = LINKLIST(left);
    condop->op_false = LINKLIST(right);
    condop->op_private = 1 | (flags >> 8);
d3723 2
a3724 2
    condop->op_next = (OP*)condop;
    flip = newUNOP(OP_FLIP, flags, (OP*)condop);
d3728 1
d3733 2
a3734 2
    condop->op_targ = pad_alloc(OP_RANGE, SVs_PADMY);
    sv_upgrade(PAD_SV(condop->op_targ), SVt_PVNV);
d3749 1
a3749 1
newLOOPOP(I32 flags, I32 debuggable, OP *expr, OP *block)
d3778 1
d3805 1
a3805 1
newWHILEOP(I32 flags, I32 debuggable, LOOP *loop, I32 whileline, OP *expr, OP *block, OP *cont)
d3813 1
d3833 1
d3842 3
d3846 1
a3846 1
    if (cont)
d3848 2
d3881 1
a3881 1
	Newz(1101,loop,1,LOOP);
d3883 1
a3883 1
	loop->op_ppaddr = ppaddr[OP_ENTERLOOP];
d3892 1
d3905 1
a3905 1
newFOROP(I32 flags,char *label,line_t forline,OP *sv,OP *expr,OP *block,OP *cont)
d3915 1
a3915 1
	    sv->op_ppaddr = ppaddr[OP_RV2GV];
d3919 1
d3925 1
d3931 1
a3931 1
	    croak("Can't use %s for loop variable", op_desc[sv->op_type]);
d3954 1
a3954 1
	CONDOP* range = (CONDOP*) flip->op_first;
d3963 2
a3964 2
	listop->op_first->op_next = range->op_true;
	left->op_next = range->op_false;
d3981 8
d3990 1
d3998 1
a3998 1
newLOOPEX(I32 type, OP *label)
d4003 1
d4025 1
a4025 1
cv_undef(CV *cv)
d4039 1
a4039 1
	    croak("Can't undef active subroutine");
d4042 1
a4042 1
	    croak("Can't undef active subroutine");
d4046 1
a4046 1
	SAVESPTR(PL_curpad);
a4082 1
#ifdef DEBUG_CLOSURES
d4084 1
a4084 2
cv_dump(cv)
CV* cv;
d4086 1
d4095 3
a4097 2
    PerlIO_printf(Perl_debug_log, "\tCV=0x%lx (%s), OUTSIDE=0x%lx (%s)\n",
		  cv,
d4102 1
a4102 1
		  outside,
d4119 3
a4121 2
	    PerlIO_printf(Perl_debug_log, "\t%4d. 0x%lx (%s\"%s\" %ld-%ld)\n",
			  ix, ppad[ix],
d4124 2
a4125 2
			  (long)I_32(SvNVX(pname[ix])),
			  (long)SvIVX(pname[ix]));
d4127 1
a4128 1
#endif /* DEBUG_CLOSURES */
d4131 1
a4131 1
cv_clone2(CV *proto, CV *outside)
d4149 1
a4149 2
    SAVESPTR(PL_curpad);
    SAVESPTR(PL_comppad);
d4155 1
a4156 2
    if (CvANON(proto))
	CvANON_on(cv);
d4163 1
a4163 1
    CvFILEGV(cv)	= CvFILEGV(proto);
d4203 1
a4203 1
		    croak("panic: cv_clone: %s", name);
d4222 3
d4264 1
a4264 1
cv_clone(CV *proto)
d4267 1
a4267 1
    MUTEX_LOCK(&PL_cred_mutex);		/* XXX create separate mutex */
d4269 1
a4269 1
    MUTEX_UNLOCK(&PL_cred_mutex);	/* XXX create separate mutex */
d4274 1
a4274 1
cv_ckproto(CV *cv, GV *gv, char *p)
d4276 3
a4278 1
    if ((!p != !SvPOK(cv)) || (p && strNE(p, SvPVX(cv)))) {
d4286 1
a4286 1
	    sv_catpvf(msg, " sub %_", name);
d4288 1
a4288 1
	    sv_catpvf(msg, " (%s)", SvPVX(cv));
d4291 1
a4291 1
	    sv_catpvf(msg, "(%s)", p);
d4294 1
a4294 1
	warn("%_", msg);
d4299 1
a4299 1
cv_const_sv(CV *cv)
d4307 1
a4307 1
op_const_sv(OP *o, CV *cv)
d4311 1
a4311 1
    if(!o)
d4314 1
a4314 1
    if(o->op_type == OP_LINESEQ && cLISTOPo->op_first) 
d4320 1
a4320 1
	if(sv && o->op_next == o) 
d4328 1
a4328 1
	if (type == OP_CONST)
d4330 1
a4330 1
	else if (type == OP_PADSV && cv) {
d4344 14
d4359 7
a4365 1
newSUB(I32 floor, OP *o, OP *proto, OP *block)
d4369 3
a4371 3
    char *name = o ? SvPVx(cSVOPo->op_sv, n_a) : Nullch;
    GV *gv = gv_fetchpv(name ? name : "__ANON__",
			GV_ADDMULTI | (block ? 0 : GV_NOINIT), SVt_PVCV);
d4376 13
d4393 2
d4396 1
a4396 1
    if (SvTYPE(gv) != SVt_PVGV) {	/* Prototype now, and had
d4399 5
a4403 2
	    if (!SvPOK((SV*)gv) && !(SvIOK((SV*)gv) && SvIVX((SV*)gv) == -1))
		warn("Runaway prototype");
d4418 1
a4418 1
    else if (cv = GvCV(gv)) {
d4424 1
a4424 1
	    if (!block) {
d4431 4
a4434 2
		croak("Can't redefine active sort subroutine %s", name);
	    if(const_sv = cv_const_sv(cv))
d4436 8
a4443 9
	    if ((const_sv && const_changed) || PL_dowarn && !(CvGV(cv) && GvSTASH(CvGV(cv))
					&& HvNAME(GvSTASH(CvGV(cv)))
					&& strEQ(HvNAME(GvSTASH(CvGV(cv))),
						 "autouse"))) {
		line_t oldline = PL_curcop->cop_line;
		PL_curcop->cop_line = PL_copline;
		warn(const_sv ? "Constant subroutine %s redefined"
		     : "Subroutine %s redefined", name);
		PL_curcop->cop_line = oldline;
d4449 27
d4477 5
d4501 1
a4501 1
    CvFILEGV(cv) = PL_curcop->cop_filegv;
d4523 2
a4524 2
		if (PL_in_eval & 4)
		    croak(not_safe);
d4528 1
a4528 1
		    croak("%s", SvPVx(ERRSV, n_a));
d4543 13
d4561 1
a4561 1
	    if (SvIMMORTAL(PL_curpad[ix]))
d4585 1
a4585 1
	    if (SvIMMORTAL(PL_curpad[ix]))
d4592 1
a4592 6
    CvROOT(cv) = newUNOP(OP_LEAVESUB, 0, scalarseq(block));
    CvSTART(cv) = LINKLIST(CvROOT(cv));
    CvROOT(cv)->op_next = 0;
    peep(CvSTART(cv));

    if (name) {
d4594 1
d4600 1
a4600 1
	    CV *cv;
d4603 3
a4605 3
	    sv_setpvf(sv, "%_:%ld-%ld",
		    GvSV(PL_curcop->cop_filegv),
		    (long)PL_subline, (long)PL_curcop->cop_line);
d4610 2
a4611 1
		  && (cv = GvCV(db_postponed))) {
d4616 1
a4616 1
		perl_call_sv((SV*)cv, G_DISCARD);
d4620 1
a4620 1
	if ((s = strrchr(name,':')))
d4623 5
a4627 1
	    s = name;
d4631 2
a4632 2
	    SAVESPTR(PL_compiling.cop_filegv);
	    SAVEI16(PL_compiling.cop_line);
d4639 1
a4639 1
	    av_push(PL_beginav, (SV *)cv);
d4644 1
d4650 1
d4652 11
a4662 1
	    av_store(PL_endav, 0, (SV *)cv);
d4668 3
d4683 9
d4693 1
a4693 1
newCONSTSUB(HV *stash, char *name, SV *sv)
a4695 5
    U32 oldhints = PL_hints;
    HV *old_cop_stash = PL_curcop->cop_stash;
    HV *old_curstash = PL_curstash;
    line_t oldline = PL_curcop->cop_line;
    PL_curcop->cop_line = PL_copline;
d4697 5
a4702 2
    if(stash)
	PL_curstash = PL_curcop->cop_stash = stash;
d4704 12
a4715 1
    newSUB(
d4719 1
d4723 1
a4723 4
    PL_hints = oldhints;
    PL_curcop->cop_stash = old_cop_stash;
    PL_curstash = old_curstash;
    PL_curcop->cop_line = oldline;
d4726 8
d4735 1
a4735 1
newXS(char *name, void (*subaddr) (CV * _CPERLproto), char *filename)
d4741 1
a4741 1
    if (cv = (name ? GvCV(gv) : Nullcv)) {
d4749 1
a4749 1
	    if (PL_dowarn && !(CvGV(cv) && GvSTASH(CvGV(cv))
d4752 1
a4752 1
		line_t oldline = PL_curcop->cop_line;
d4754 3
a4756 3
		    PL_curcop->cop_line = PL_copline;
		warn("Subroutine %s redefined",name);
		PL_curcop->cop_line = oldline;
d4780 3
a4782 1
    CvFILEGV(cv) = gv_fetchfile(filename);
d4791 4
d4798 1
a4798 1
	    av_push(PL_beginav, (SV *)cv);
d4805 10
a4814 1
	    av_store(PL_endav, 0, (SV *)cv);
d4820 3
a4822 1
	    av_push(PL_initav, (SV *)cv);
d4829 1
d4834 1
a4834 1
newFORM(I32 floor, OP *o, OP *block)
d4849 7
a4855 7
    if (cv = GvFORM(gv)) {
	if (PL_dowarn) {
	    line_t oldline = PL_curcop->cop_line;

	    PL_curcop->cop_line = PL_copline;
	    warn("Format %s redefined",name);
	    PL_curcop->cop_line = oldline;
d4862 1
a4862 1
    CvFILEGV(cv) = PL_curcop->cop_filegv;
d4870 2
d4881 1
a4881 1
newANONLIST(OP *o)
d4888 1
a4888 1
newANONHASH(OP *o)
d4895 7
a4901 1
newANONSUB(I32 floor, OP *proto, OP *block)
d4904 2
a4905 1
	newSVOP(OP_ANONCODE, 0, (SV*)newSUB(floor, 0, proto, block)));
d4909 1
a4909 1
oopsAV(OP *o)
d4914 1
a4914 1
	o->op_ppaddr = ppaddr[OP_PADAV];
d4919 1
a4919 1
	o->op_ppaddr = ppaddr[OP_RV2AV];
d4924 2
a4925 1
	warn("oops: oopsAV");
d4932 1
a4932 1
oopsHV(OP *o)
d4934 2
d4940 1
a4940 1
	o->op_ppaddr = ppaddr[OP_PADHV];
d4946 1
a4946 1
	o->op_ppaddr = ppaddr[OP_RV2HV];
d4951 2
a4952 1
	warn("oops: oopsHV");
d4959 1
a4959 1
newAVREF(OP *o)
d4963 1
a4963 1
	o->op_ppaddr = ppaddr[OP_PADAV];
d4970 1
a4970 1
newGVREF(I32 type, OP *o)
d4972 1
a4972 1
    if (type == OP_MAPSTART || type == OP_GREPSTART)
d4978 1
a4978 1
newHVREF(OP *o)
d4982 1
a4982 1
	o->op_ppaddr = ppaddr[OP_PADHV];
d4989 1
a4989 1
oopsCV(OP *o)
d4991 1
a4991 1
    croak("NOT IMPL LINE %d",__LINE__);
d4997 1
a4997 1
newCVREF(I32 flags, OP *o)
d5003 1
a5003 1
newSVREF(OP *o)
d5007 1
a5007 1
	o->op_ppaddr = ppaddr[OP_PADSV];
d5020 1
a5020 1
ck_anoncode(OP *o)
d5040 1
a5040 1
ck_bitop(OP *o)
d5047 1
a5047 1
ck_concat(OP *o)
d5055 1
a5055 1
ck_spair(OP *o)
d5066 1
a5066 1
	     !(opargs[newop->op_type] & OA_RETSCALAR) ||
d5075 1
a5075 1
    o->op_ppaddr = ppaddr[++o->op_type];
d5080 1
a5080 1
ck_delete(OP *o)
d5086 5
a5090 1
	if (kid->op_type == OP_HSLICE)
d5092 10
a5101 3
	else if (kid->op_type != OP_HELEM)
	    croak("%s argument is not a HASH element or slice",
		  op_desc[o->op_type]);
d5108 1
a5108 1
ck_eof(OP *o)
d5124 1
a5124 1
ck_eval(OP *o)
d5141 1
a5141 1
	    Newz(1101, enter, 1, LOGOP);
d5143 1
a5143 1
	    enter->op_ppaddr = ppaddr[OP_ENTERTRY];
d5151 1
a5151 1
	    o->op_ppaddr = ppaddr[OP_LEAVETRY];
d5167 15
a5181 1
ck_exec(OP *o)
d5196 1
a5196 1
ck_exists(OP *o)
d5201 12
a5212 2
	if (kid->op_type != OP_HELEM)
	    croak("%s argument is not a HASH element", op_desc[o->op_type]);
d5218 1
d5220 1
a5220 1
ck_gvconst(register OP *o)
d5227 1
d5230 1
a5230 1
ck_rvconst(register OP *o)
d5277 1
a5277 1
		croak("Constant is not %s reference", badtype);
a5280 1

d5295 1
a5295 1
		croak(
d5324 6
d5331 2
d5339 1
a5339 1
ck_ftst(OP *o)
d5344 4
a5347 4
    if (o->op_flags & OPf_REF)
	return o;

    if (o->op_flags & OPf_KIDS && cUNOPo->op_first->op_type != OP_STUB) {
d5355 1
a5355 1
	    return newop;
d5361 1
a5361 1
           return newGVOP(type, OPf_REF, gv_fetchpv("main::STDIN", TRUE,
d5364 7
a5370 1
	    return newUNOP(type, 0, newDEFSVOP());
d5372 1
d5377 1
a5377 1
ck_fun(OP *o)
d5385 1
a5385 1
    register I32 oa = opargs[type] >> OASHIFT;
d5399 1
a5399 1
	    kid->op_type == OP_NULL && kid->op_targ == OP_PUSHMARK)
d5404 1
a5404 1
	if (!kid && opargs[type] & OA_DEFGV)
d5412 6
d5430 2
a5431 1
		  (kid->op_private & OPpCONST_BARE)) {
d5435 4
a5438 3
		    if (PL_dowarn)
			warn("Array @@%s missing the @@ in argument %ld of %s()",
			    name, (long)numargs, op_desc[type]);
d5445 1
a5445 1
		    bad_type(numargs, "array", op_desc[o->op_type], kid);
d5450 2
a5451 1
		  (kid->op_private & OPpCONST_BARE)) {
d5455 4
a5458 3
		    if (PL_dowarn)
			warn("Hash %%%s missing the %% in argument %ld of %s()",
			    name, (long)numargs, op_desc[type]);
d5465 1
a5465 1
		    bad_type(numargs, "hash", op_desc[o->op_type], kid);
d5482 2
a5483 1
		      (kid->op_private & OPpCONST_BARE)) {
d5492 1
a5492 1
			bad_type(numargs, "HANDLE", op_desc[o->op_type], kid);
d5495 45
d5541 3
a5543 1
			kid = newUNOP(OP_RV2GV, 0, scalar(kid));
d5560 1
a5560 1
	    return too_many_arguments(o,op_desc[o->op_type]);
d5563 1
a5563 1
    else if (opargs[type] & OA_DEFGV) {
d5572 1
a5572 1
	    return too_few_arguments(o,op_desc[o->op_type]);
d5578 1
a5578 1
ck_glob(OP *o)
d5582 1
d5589 12
a5601 4
#ifndef PERL_OBJECT
	static int glob_index;
#endif

d5603 1
a5603 1
		    newSVOP(OP_CONST, 0, newSViv(glob_index++)));
d5605 1
a5605 1
	o->op_ppaddr = ppaddr[OP_LIST];
d5607 1
a5607 1
	cLISTOPo->op_first->op_ppaddr = ppaddr[OP_PUSHMARK];
d5620 1
a5620 1
    return ck_fun(o);
d5624 1
a5624 1
ck_grep(OP *o)
d5630 2
a5631 2
    o->op_ppaddr = ppaddr[OP_GREPSTART];
    Newz(1101, gwop, 1, LOGOP);
d5653 1
a5653 1
	croak("panic: ck_grep");
d5657 1
a5657 1
    gwop->op_ppaddr = ppaddr[type];
d5667 1
a5667 1
	return too_few_arguments(o,op_desc[o->op_type]);
d5675 1
a5675 1
ck_index(OP *o)
d5688 1
a5688 1
ck_lengthconst(OP *o)
d5695 1
a5695 1
ck_lfun(OP *o)
d5702 32
a5733 1
ck_rfun(OP *o)
d5740 1
a5740 1
ck_listiob(OP *o)
d5778 1
a5778 1
ck_fun_locale(OP *o)
d5792 31
a5822 1
ck_scmp(OP *o)
d5834 1
a5834 1
ck_match(OP *o)
d5841 21
a5861 1
ck_null(OP *o)
d5867 31
a5897 1
ck_repeat(OP *o)
d5909 1
a5909 1
ck_require(OP *o)
d5923 7
a5929 1
	    sv_catpvn(kid->op_sv, ".pm", 3);
d5935 1
d5937 1
a5937 1
ck_retarget(OP *o)
d5939 1
a5939 1
    croak("NOT IMPL LINE %d",__LINE__);
d5943 1
d5946 1
a5946 1
ck_select(OP *o)
d5953 1
a5953 1
	    o->op_ppaddr = ppaddr[OP_SSELECT];
d5966 1
a5966 1
ck_shift(OP *o)
d5995 1
a5995 1
ck_sort(OP *o)
d6003 3
a6005 1
    if (o->op_flags & OPf_STACKED) {
d6008 1
a6008 6

	if (o->op_type == OP_SORT) {
	    GvMULTI_on(gv_fetchpv("a", TRUE, SVt_PV));
	    GvMULTI_on(gv_fetchpv("b", TRUE, SVt_PV));
	}
	kid = kUNOP->op_first;				/* get past rv2gv */
d6024 6
a6038 1
	    null(kid);					/* wipe out rv2gv */
d6047 1
a6047 1
     }
d6052 66
d6119 1
a6119 1
ck_split(OP *o)
d6128 1
a6128 1
	croak("panic: ck_split");
d6133 1
a6133 1
	cLISTOPo->op_first = kid = newSVOP(OP_CONST, 0, newSVpv(" ", 1));
d6148 1
a6148 1
    kid->op_ppaddr = ppaddr[OP_PUSHRE];
d6164 1
a6164 1
	return too_many_arguments(o,op_desc[o->op_type]);
d6170 18
a6187 1
ck_subr(OP *o)
d6201 1
d6208 7
a6214 4
	if (tmpop->op_type == OP_GV) {
	    cv = GvCVu(tmpop->op_sv);
	    if (cv && SvPOK(cv) && !(o->op_private & OPpENTERSUB_AMPER)) {
		namegv = CvANON(cv) ? (GV*)tmpop->op_sv : CvGV(cv);
d6219 9
d6262 29
d6308 2
d6340 1
a6340 1
		croak("Malformed prototype for %s: %s",
d6357 1
a6357 1
ck_svconst(OP *o)
d6364 1
a6364 1
ck_trunc(OP *o)
d6371 3
a6373 2
	if (kid &&
	  kid->op_type == OP_CONST && (kid->op_private & OPpCONST_BARE))
d6375 2
d6384 1
a6384 1
peep(register OP *o)
d6389 2
d6395 1
a6395 1
    SAVESPTR(PL_curcop);
d6403 1
d6408 20
d6431 11
a6441 8
	case OP_CONST:
	case OP_JOIN:
	case OP_UC:
	case OP_UCFIRST:
	case OP_LC:
	case OP_LCFIRST:
	case OP_QUOTEMETA:
	    if (o->op_next && o->op_next->op_type == OP_STRINGIFY)
d6443 2
d6454 4
a6457 1
	    if (o->op_targ == OP_NEXTSTATE || o->op_targ == OP_DBSTATE)
d6459 1
d6476 2
a6477 1
		    o->op_private |= o->op_next->op_private & OPpLVAL_INTRO;
d6480 1
a6480 1
		    o->op_ppaddr = ppaddr[OP_GVSV];
d6495 1
a6495 1
		    SvREFCNT_dec(((SVOP*)pop)->op_sv);
d6502 1
a6502 1
		    o->op_ppaddr = ppaddr[OP_AELEMFAST];
d6504 2
a6505 1
		    GvAVn(((GVOP*)o)->op_gv);
d6508 12
d6527 4
a6536 6
	case OP_COND_EXPR:
	    o->op_seq = PL_op_seqmax++;
	    peep(cCONDOP->op_true);
	    peep(cCONDOP->op_false);
	    break;

d6553 2
a6554 1
	    if (PL_dowarn && o->op_next && o->op_next->op_type == OP_NEXTSTATE) {
d6559 1
a6559 1
		    line_t oldline = PL_curcop->cop_line;
d6561 6
a6566 4
		    PL_curcop->cop_line = ((COP*)o->op_next)->cop_line;
		    warn("Statement unlikely to be reached");
		    warn("(Maybe you meant system() when you said exec()?)\n");
		    PL_curcop->cop_line = oldline;
d6575 1
a6575 1
	    SV **svp, **indsvp;
d6580 2
a6581 1
	    if (o->op_private & (OPpDEREF_HV|OPpDEREF_AV|OPpLVAL_INTRO)
d6593 1
a6593 1
	    svp = &((SVOP*)((BINOP*)o)->op_last)->op_sv;
d6597 1
a6597 1
		croak("No such field \"%s\" in variable %s of type %s",
d6602 1
a6602 1
		croak("Bad index while coercing array into hash");
d6604 1
a6604 1
	    rop->op_ppaddr = ppaddr[OP_RV2AV];
d6606 6
a6611 1
	    o->op_ppaddr = ppaddr[OP_AELEM];
d6613 1
a6613 1
	    *svp = newSViv(ind);
d6616 99
@


1.2
log
@perl 5.004_04
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1997, Larry Wall
d21 5
a25 1
#define USE_OP_MASK  /* Turned on by default in 5.002beta1h */
a26 1
#ifdef USE_OP_MASK
d28 1
a28 1
 * In the following definition, the ", (OP *) op" is just to make the compiler
d31 3
a33 3
#define CHECKOP(type,op) \
    ((op_mask && op_mask[type])					\
     ? ( op_free((OP*)op),					\
d36 3
a38 4
     : (*check[type])((OP*)op))
#else
#define CHECKOP(type,op) (*check[type])(op)
#endif /* USE_OP_MASK */
d40 10
a49 9
static I32 list_assignment _((OP *op));
static OP *bad_type _((I32 n, char *t, char *name, OP *kid));
static OP *modkids _((OP *op, I32 type));
static OP *no_fh_allowed _((OP *op));
static bool scalar_mod_type _((OP *op, I32 type));
static OP *scalarboolean _((OP *op));
static OP *too_few_arguments _((OP *op, char* name));
static OP *too_many_arguments _((OP *op, char* name));
static void null _((OP* op));
d51 4
a54 1
	CV* startcv, I32 cx_ix));
d56 2
a57 3
static char*
gv_ename(gv)
GV* gv;
d60 1
d62 1
a62 1
    return SvPV(tmpsv,na);
d65 2
a66 3
static OP *
no_fh_allowed(op)
OP *op;
d69 2
a70 2
		 op_desc[op->op_type]));
    return op;
d73 2
a74 4
static OP *
too_few_arguments(op, name)
OP* op;
char* name;
d77 1
a77 1
    return op;
d80 2
a81 4
static OP *
too_many_arguments(op, name)
OP *op;
char* name;
d84 1
a84 1
    return op;
d87 2
a88 6
static OP *
bad_type(n, t, name, kid)
I32 n;
char *t;
char *name;
OP *kid;
a91 1
    return op;
d95 1
a95 2
assertref(op)
OP *op;
d97 2
a98 2
    int type = op->op_type;
    if (type != OP_AELEM && type != OP_HELEM) {
d100 12
a111 3
	if (type == OP_ENTERSUB || type == OP_RV2HV || type == OP_PADHV)
	    warn("(Did you mean $ or @@ instead of %c?)\n",
		 type == OP_ENTERSUB ? '&' : '%');
d118 1
a118 2
pad_allocmy(name)
char *name;
d120 1
d132 3
a134 3
    if (dowarn && AvFILL(comppad_name) >= 0) {
	SV **svp = AvARRAY(comppad_name);
	for (off = AvFILL(comppad_name); off > comppad_name_floor; off--) {
d136 2
a137 2
		&& sv != &sv_undef
		&& SvIVX(sv) == 999999999       /* var is in open scope */
d140 2
a141 1
		warn("\"my\" variable %s masks earlier declaration in same scope", name);
d150 10
a159 2
    av_store(comppad_name, off, sv);
    SvNVX(sv) = (double)999999999;
d161 3
a163 3
    if (!min_intro_pending)
	min_intro_pending = off;
    max_intro_pending = off;
d165 1
a165 1
	av_store(comppad, off, (SV*)newAV());
d167 2
a168 2
	av_store(comppad, off, (SV*)newHV());
    SvPADMY_on(curpad[off]);
d172 5
a176 11
static PADOFFSET
#ifndef CAN_PROTOTYPE
pad_findlex(name, newoff, seq, startcv, cx_ix)
char *name;
PADOFFSET newoff;
U32 seq;
CV* startcv;
I32 cx_ix;
#else
pad_findlex(char *name, PADOFFSET newoff, U32 seq, CV* startcv, I32 cx_ix)
#endif
d178 1
d183 1
a183 2
    register CONTEXT *cx;
    int saweval;
d190 1
a190 1
	if (!svp || *svp == &sv_undef)
d194 1
a194 1
	for (off = AvFILL(curname); off > 0; off--) {
d196 1
a196 1
		sv != &sv_undef &&
d221 3
a223 3
		    av_store(comppad_name, newoff, namesv);
		    SvNVX(namesv) = (double)curcop->cop_seq;
		    SvIVX(namesv) = 999999999;	/* A ref, intro immediately */
d225 7
a231 1
		    if (CvANON(compcv) || SvTYPE(compcv) == SVt_PVFM) {
d233 1
a233 1
			CvCLONE_on(compcv);
d235 1
a235 1
			    if (CvANON(compcv))
d242 2
a243 1
				 bcv = CvOUTSIDE(bcv)) {
d247 3
a249 1
				    if (dowarn && !CvUNIQUE(cv))
d253 1
d259 2
a260 2
		    else if (!CvUNIQUE(compcv)) {
			if (dowarn && !SvFAKE(sv) && !CvUNIQUE(cv))
d264 1
a264 1
		av_store(comppad, newoff, SvREFCNT_inc(oldsv));
d270 3
a277 1
    saweval = 0;
d280 1
a280 1
	switch (cx->cx_type) {
d284 1
a284 1
		return pad_findlex(name, newoff, seq, main_cv, 0);
d290 2
a291 1
		saweval = i;
d302 1
a302 1
	    if (debstash && CvSTASH(cv) == debstash) {	/* ignore DB'* scope */
d307 1
a307 1
	    return pad_findlex(name, newoff, seq, cv, i-1);
d315 1
a315 2
pad_findmy(name)
char *name;
d317 1
d321 17
a337 2
    SV **svp = AvARRAY(comppad_name);
    U32 seq = cop_seqmax;
d340 1
a340 1
    for (off = AvFILL(comppad_name); off > 0; off--) {
d342 1
a342 1
	    sv != &sv_undef &&
d354 12
d367 1
a367 1
    off = pad_findlex(name, 0, seq, CvOUTSIDE(compcv), cxstack_ix);
d371 2
a372 2
	    SvIVX(AvARRAY(comppad_name)[off]) = seq;
	return off;
d374 1
a374 2

    return 0;
d378 1
a378 2
pad_leavemy(fill)
I32 fill;
d381 1
a381 1
    SV **svp = AvARRAY(comppad_name);
d383 3
a385 3
    if (min_intro_pending && fill < min_intro_pending) {
	for (off = max_intro_pending; off >= min_intro_pending; off--) {
	    if ((sv = svp[off]) && sv != &sv_undef)
d390 3
a392 3
    for (off = AvFILL(comppad_name); off > fill; off--) {
	if ((sv = svp[off]) && sv != &sv_undef && SvIVX(sv) == 999999999)
	    SvIVX(sv) = cop_seqmax;
d397 1
a397 3
pad_alloc(optype,tmptype)	
I32 optype;
U32 tmptype;
d399 1
d403 1
a403 1
    if (AvARRAY(comppad) != curpad)
d405 1
a405 1
    if (pad_reset_pending)
d409 1
a409 1
	    sv = *av_fetch(comppad, AvFILL(comppad) + 1, TRUE);
d411 1
a411 1
	retval = AvFILL(comppad);
d414 2
a415 2
	SV **names = AvARRAY(comppad_name);
	SSize_t names_fill = AvFILL(comppad_name);
d422 2
a423 2
	    if (++padix <= names_fill &&
		   (sv = names[padix]) && sv != &sv_undef)
d425 1
a425 1
	    sv = *av_fetch(comppad, padix, TRUE);
d429 1
a429 1
	retval = padix;
d432 10
a441 2
    curpad = AvARRAY(comppad);
    DEBUG_X(PerlIO_printf(Perl_debug_log, "Pad alloc %ld for %s\n", (long) retval, op_name[optype]));
a445 4
#ifndef CAN_PROTOTYPE
pad_sv(po)
PADOFFSET po;
#else
a446 1
#endif /* CAN_PROTOTYPE */
d448 5
d455 4
a458 2
    DEBUG_X(PerlIO_printf(Perl_debug_log, "Pad sv %lu\n", (unsigned long)po));
    return curpad[po];		/* eventually we'll turn this into a macro */
a461 4
#ifndef CAN_PROTOTYPE
pad_free(po)
PADOFFSET po;
#else
a462 1
#endif /* CAN_PROTOTYPE */
d464 2
a465 1
    if (!curpad)
d467 1
a467 1
    if (AvARRAY(comppad) != curpad)
d471 11
a481 5
    DEBUG_X(PerlIO_printf(Perl_debug_log, "Pad free %lu\n", (unsigned long)po));
    if (curpad[po] && !SvIMMORTAL(curpad[po]))
	SvPADTMP_off(curpad[po]);
    if ((I32)po < padix)
	padix = po - 1;
a484 4
#ifndef CAN_PROTOTYPE
pad_swipe(po)
PADOFFSET po;
#else
a485 1
#endif /* CAN_PROTOTYPE */
d487 2
a488 1
    if (AvARRAY(comppad) != curpad)
d492 20
a511 8
    DEBUG_X(PerlIO_printf(Perl_debug_log, "Pad swipe %lu\n", (unsigned long)po));
    SvPADTMP_off(curpad[po]);
    curpad[po] = NEWSV(1107,0);
    SvPADTMP_on(curpad[po]);
    if ((I32)po < padix)
	padix = po - 1;
}

d513 1
a513 1
pad_reset()
d515 2
d519 1
a519 1
    if (AvARRAY(comppad) != curpad)
d521 76
a596 5
    DEBUG_X(PerlIO_printf(Perl_debug_log, "Pad reset\n"));
    if (!tainting) {	/* Can't mix tainted and non-tainted temporaries. */
	for (po = AvMAX(comppad); po > padix_floor; po--) {
	    if (curpad[po] && !SvIMMORTAL(curpad[po]))
		SvPADTMP_off(curpad[po]);
d598 4
a601 1
	padix = padix_floor;
d603 1
a603 1
    pad_reset_pending = FALSE;
d605 1
d610 1
a610 2
op_free(op)
OP *op;
d614 1
a614 1
    if (!op || op->op_seq == (U16)-1)
d617 2
a618 2
    if (op->op_flags & OPf_KIDS) {
	for (kid = cUNOP->op_first; kid; kid = nextkid) {
d624 1
a624 1
    switch (op->op_type) {
d626 1
a626 1
	op->op_targ = 0;	/* Was holding old type, if any. */
d629 1
a629 1
	op->op_targ = 0;	/* Was holding hints. */
d631 9
d641 2
a642 1
	if (!(op->op_flags & OPf_REF) || (check[op->op_type] != ck_ftst))
d648 1
a648 1
	SvREFCNT_dec(cGVOP->op_gv);
d652 2
a653 2
	Safefree(cCOP->cop_label);
	SvREFCNT_dec(cCOP->cop_filegv);
d656 1
a656 1
	SvREFCNT_dec(cSVOP->op_sv);
d662 1
a662 1
	if (op->op_flags & (OPf_SPECIAL|OPf_STACKED|OPf_KIDS))
d666 1
a666 1
	Safefree(cPVOP->op_pv);
d669 1
a669 1
	op_free(cPMOP->op_pmreplroot);
d673 2
a674 2
	pregfree(cPMOP->op_pmregexp);
	SvREFCNT_dec(cPMOP->op_pmshort);
d678 2
a679 2
    if (op->op_targ > 0)
	pad_free(op->op_targ);
d681 1
a681 1
    Safefree(op);
d684 2
a685 3
static void
null(op)
OP* op;
d687 5
a691 5
    if (op->op_type != OP_NULL && op->op_targ > 0)
	pad_free(op->op_targ);
    op->op_targ = op->op_type;
    op->op_type = OP_NULL;
    op->op_ppaddr = ppaddr[OP_NULL];
d699 1
a699 2
linklist(op)
OP *op;
d703 2
a704 2
    if (op->op_next)
	return op->op_next;
d707 3
a709 3
    if (cUNOP->op_first) {
	op->op_next = LINKLIST(cUNOP->op_first);
	for (kid = cUNOP->op_first; kid; kid = kid->op_sibling) {
d713 1
a713 1
		kid->op_next = op;
d717 1
a717 1
	op->op_next = op;
d719 1
a719 1
    return op->op_next;
d723 1
a723 2
scalarkids(op)
OP *op;
d726 2
a727 2
    if (op && op->op_flags & OPf_KIDS) {
	for (kid = cLISTOP->op_first; kid; kid = kid->op_sibling)
d730 1
a730 1
    return op;
d733 2
a734 3
static OP *
scalarboolean(op)
OP *op;
d736 4
a739 3
    if (dowarn &&
	op->op_type == OP_SASSIGN && cBINOP->op_first->op_type == OP_CONST) {
	line_t oldline = curcop->cop_line;
d741 2
a742 2
	if (copline != NOLINE)
	    curcop->cop_line = copline;
d744 1
a744 1
	curcop->cop_line = oldline;
d746 1
a746 1
    return scalar(op);
d750 1
a750 2
scalar(op)
OP *op;
d755 3
a757 3
    if (!op || (op->op_flags & OPf_WANT) || error_count
	 || op->op_type == OP_RETURN)
	return op;
d759 1
a759 1
    op->op_flags = (op->op_flags & ~OPf_WANT) | OPf_WANT_SCALAR;
d761 1
a761 1
    switch (op->op_type) {
d763 3
a765 3
	if (op->op_private & OPpREPEAT_DOLIST)
	    null(((LISTOP*)cBINOP->op_first)->op_first);
	scalar(cBINOP->op_first);
d770 1
a770 1
	for (kid = cUNOP->op_first->op_sibling; kid; kid = kid->op_sibling)
d774 1
a774 1
	if ((kid = ((LISTOP*)op)->op_first) && kid->op_type == OP_PUSHRE) {
d780 1
d784 2
a785 2
	if (op->op_flags & OPf_KIDS) {
	    for (kid = cUNOP->op_first; kid; kid = kid->op_sibling)
d791 1
a791 1
	kid = cLISTOP->op_first;
d799 1
a799 1
	curcop = &compiling;
d804 1
a804 1
	for (kid = cLISTOP->op_first; kid; kid = kid->op_sibling) {
d810 1
a810 1
	curcop = &compiling;
d813 1
a813 1
    return op;
d817 1
a817 2
scalarvoid(op)
OP *op;
d824 4
a827 3
    if (!op || (op->op_flags & OPf_WANT) == OPf_WANT_LIST || error_count
	 || op->op_type == OP_RETURN)
	return op;
d829 1
a829 1
    op->op_flags = (op->op_flags & ~OPf_WANT) | OPf_WANT_VOID;
d831 1
a831 1
    switch (op->op_type) {
d833 1
a833 1
	if (!(opargs[op->op_type] & OA_FOLDCONST))
d837 5
a841 1
	if (op->op_flags & OPf_STACKED)
a858 1
    case OP_SUBSTR:
d911 3
a913 2
	if (!(op->op_private & OPpLVAL_INTRO))
	    useless = op_desc[op->op_type];
d920 2
a921 2
	if (!(op->op_private & OPpLVAL_INTRO) &&
		(!op->op_sibling || op->op_sibling->op_type != OP_READLINE))
d927 1
a927 1
	curcop = ((COP*)op);		/* for warning below */
d931 2
a932 2
	sv = cSVOP->op_sv;
	if (dowarn) {
d943 1
a943 1
	null(op);		/* don't execute a constant */
d948 2
a949 2
	op->op_type = OP_PREINC;		/* pre-increment is faster */
	op->op_ppaddr = ppaddr[OP_PREINC];
d953 2
a954 2
	op->op_type = OP_PREDEC;		/* pre-decrement is faster */
	op->op_ppaddr = ppaddr[OP_PREDEC];
d960 1
a960 1
	for (kid = cUNOP->op_first->op_sibling; kid; kid = kid->op_sibling)
d965 3
a967 3
	if (op->op_targ == OP_NEXTSTATE || op->op_targ == OP_DBSTATE)
	    curcop = ((COP*)op);		/* for warning below */
	if (op->op_flags & OPf_STACKED)
d973 1
a973 1
	if (!(op->op_flags & OPf_KIDS))
d982 1
a982 1
	for (kid = cLISTOP->op_first; kid; kid = kid->op_sibling)
d986 1
a986 1
	scalarkids(op);
d990 2
a991 2
	op->op_flags &= ~OPf_WANT;
	return scalar(op);
d993 1
a993 1
	if ((kid = ((LISTOP*)op)->op_first) && kid->op_type == OP_PUSHRE) {
d999 1
a999 1
    if (useless && dowarn)
d1001 1
a1001 1
    return op;
d1005 1
a1005 2
listkids(op)
OP *op;
d1008 2
a1009 2
    if (op && op->op_flags & OPf_KIDS) {
	for (kid = cLISTOP->op_first; kid; kid = kid->op_sibling)
d1012 1
a1012 1
    return op;
d1016 1
a1016 2
list(op)
OP *op;
d1021 3
a1023 3
    if (!op || (op->op_flags & OPf_WANT) || error_count
	 || op->op_type == OP_RETURN)
	return op;
d1025 1
a1025 1
    op->op_flags = (op->op_flags & ~OPf_WANT) | OPf_WANT_LIST;
d1027 1
a1027 1
    switch (op->op_type) {
d1030 1
a1030 1
	list(cBINOP->op_first);
d1035 1
a1035 1
	for (kid = cUNOP->op_first->op_sibling; kid; kid = kid->op_sibling)
d1040 1
d1043 1
a1043 1
	if (!(op->op_flags & OPf_KIDS))
d1045 3
a1047 3
	if (!op->op_next && cUNOP->op_first->op_type == OP_FLOP) {
	    list(cBINOP->op_first);
	    return gen_constant_list(op);
d1050 1
a1050 1
	listkids(op);
d1054 1
a1054 1
	kid = cLISTOP->op_first;
d1062 1
a1062 1
	curcop = &compiling;
d1066 1
a1066 1
	for (kid = cLISTOP->op_first; kid; kid = kid->op_sibling) {
d1072 1
a1072 1
	curcop = &compiling;
d1076 2
a1077 2
	op->op_flags &= ~OPf_WANT;
	return scalar(op);
d1079 1
a1079 1
    return op;
d1083 1
a1083 2
scalarseq(op)
OP *op;
d1087 5
a1091 5
    if (op) {
	if (op->op_type == OP_LINESEQ ||
	     op->op_type == OP_SCOPE ||
	     op->op_type == OP_LEAVE ||
	     op->op_type == OP_LEAVETRY)
d1093 2
a1094 1
	    for (kid = cLISTOP->op_first; kid; kid = kid->op_sibling) {
d1099 1
a1099 1
	    curcop = &compiling;
d1101 3
a1103 3
	op->op_flags &= ~OPf_PARENS;
	if (hints & HINT_BLOCK_SCOPE)
	    op->op_flags |= OPf_PARENS;
d1106 2
a1107 2
	op = newOP(OP_STUB, 0);
    return op;
d1110 2
a1111 4
static OP *
modkids(op, type)
OP *op;
I32 type;
d1114 2
a1115 2
    if (op && op->op_flags & OPf_KIDS) {
	for (kid = cLISTOP->op_first; kid; kid = kid->op_sibling)
d1118 1
a1118 1
    return op;
a1120 2
static I32 modcount;

d1122 1
a1122 3
mod(op, type)
OP *op;
I32 type;
d1124 1
d1127 1
d1129 2
a1130 2
    if (!op || error_count)
	return op;
d1132 1
a1132 1
    switch (op->op_type) {
d1134 2
a1135 2
	modcount++;
	return op;
d1137 1
a1137 1
	if (!(op->op_private & (OPpCONST_ARYBASE)))
d1139 3
a1141 3
	if (eval_start && eval_start->op_type == OP_CONST) {
	    compiling.cop_arybase = (I32)SvIV(((SVOP*)eval_start)->op_sv);
	    eval_start = 0;
d1144 2
a1145 2
	    SAVEI32(compiling.cop_arybase);
	    compiling.cop_arybase = 0;
d1153 1
a1153 1
	if (op->op_flags & OPf_PARENS)
d1158 5
a1162 5
	    !(op->op_flags & OPf_STACKED)) {
	    op->op_type = OP_RV2CV;		/* entersub => rv2cv */
	    op->op_ppaddr = ppaddr[OP_RV2CV];
	    assert(cUNOP->op_first->op_type == OP_NULL);
	    null(((LISTOP*)cUNOP->op_first)->op_first);	/* disable pushmark */
d1172 1
a1172 1
		     op_desc[op->op_type],
d1174 1
a1174 1
	return op;
d1196 1
a1196 1
	if (!(op->op_flags & OPf_STACKED))
d1198 1
a1198 1
	modcount++;
d1202 1
a1202 1
	for (kid = cUNOP->op_first->op_sibling; kid; kid = kid->op_sibling)
d1208 1
a1208 1
	if (!type && cUNOP->op_first->op_type != OP_GV)
d1210 3
a1212 3
	if (type == OP_REFGEN && op->op_flags & OPf_PARENS) {
	    modcount = 10000;
	    return op;		/* Treat \(@@foo) like ordinary list. */
d1216 1
a1216 1
	if (scalar_mod_type(op, type))
d1218 1
a1218 1
	ref(cUNOP->op_first, op->op_type);
d1227 1
a1227 1
	modcount = 10000;
d1230 1
a1230 1
	if (!type && cUNOP->op_first->op_type != OP_GV)
d1232 1
a1232 1
	ref(cUNOP->op_first, op->op_type); 
d1236 1
d1239 1
a1239 1
	modcount++;
d1244 4
a1247 4
	modcount = 10000;
	if (type == OP_REFGEN && op->op_flags & OPf_PARENS)
	    return op;		/* Treat \(@@foo) like ordinary list. */
	if (scalar_mod_type(op, type))
d1251 1
a1251 1
	modcount++;
d1254 6
a1259 1
		SvPV(*av_fetch(comppad_name, op->op_targ, 4), na));
d1261 1
d1269 4
d1276 6
a1281 6
    case OP_SUBSTR:
	pad_free(op->op_targ);
	op->op_targ = pad_alloc(op->op_type, SVs_PADMY);
	assert(SvTYPE(PAD_SV(op->op_targ)) == SVt_NULL);
	if (op->op_flags & OPf_KIDS)
	    mod(cBINOP->op_first->op_sibling, type);
d1286 1
a1286 1
	ref(cBINOP->op_first, op->op_type);
d1288 3
a1290 3
	     !(op->op_private & (OPpLVAL_INTRO | OPpDEREF)))
	    op->op_private |= OPpLVAL_DEFER;
	modcount++;
d1296 2
a1297 2
	if (op->op_flags & OPf_KIDS)
	    mod(cLISTOP->op_last, type);
d1301 1
a1301 1
	if (!(op->op_flags & OPf_KIDS))
d1303 2
a1304 2
	if (op->op_targ != OP_LIST) {
	    mod(cBINOP->op_first, type);
d1309 1
a1309 1
	for (kid = cLISTOP->op_first; kid; kid = kid->op_sibling)
d1313 1
a1313 1
    op->op_flags |= OPf_MOD;
d1316 1
a1316 1
	op->op_flags |= OPf_SPECIAL|OPf_REF;
d1318 3
a1320 2
	op->op_private |= OPpLVAL_INTRO;
	op->op_flags &= ~OPf_SPECIAL;
d1323 2
a1324 2
	op->op_flags |= OPf_REF;
    return op;
d1328 1
a1328 3
scalar_mod_type(op, type)
OP *op;
I32 type;
d1332 1
a1332 1
	if (op->op_type == OP_RV2GV)
d1363 3
d1375 1
a1375 3
refkids(op, type)
OP *op;
I32 type;
d1378 2
a1379 2
    if (op && op->op_flags & OPf_KIDS) {
	for (kid = cLISTOP->op_first; kid; kid = kid->op_sibling)
d1382 1
a1382 1
    return op;
d1386 1
a1386 3
ref(op, type)
OP *op;
I32 type;
d1390 2
a1391 2
    if (!op || error_count)
	return op;
d1393 1
a1393 1
    switch (op->op_type) {
d1395 7
a1401 7
	if ((type == OP_DEFINED) &&
	    !(op->op_flags & OPf_STACKED)) {
	    op->op_type = OP_RV2CV;             /* entersub => rv2cv */
	    op->op_ppaddr = ppaddr[OP_RV2CV];
	    assert(cUNOP->op_first->op_type == OP_NULL);
	    null(((LISTOP*)cUNOP->op_first)->op_first);	/* disable pushmark */
	    op->op_flags |= OPf_SPECIAL;
d1404 1
a1404 1
      
d1406 1
a1406 1
	for (kid = cUNOP->op_first->op_sibling; kid; kid = kid->op_sibling)
d1410 1
a1410 1
	ref(cUNOP->op_first, op->op_type);
d1414 4
a1417 4
	    op->op_private |= (type == OP_RV2AV ? OPpDEREF_AV
			       : type == OP_RV2HV ? OPpDEREF_HV
			       : OPpDEREF_SV);
	    op->op_flags |= OPf_MOD;
d1421 4
d1427 1
a1427 1
	op->op_flags |= OPf_REF; 
d1430 1
a1430 1
	ref(cUNOP->op_first, op->op_type);
d1435 1
a1435 1
	op->op_flags |= OPf_REF; 
d1437 1
a1437 1
      
d1440 1
a1440 1
	if (!(op->op_flags & OPf_KIDS))
d1442 1
a1442 1
	ref(cBINOP->op_first, type);
d1446 1
a1446 1
	ref(cBINOP->op_first, op->op_type);
d1448 4
a1451 4
	    op->op_private |= (type == OP_RV2AV ? OPpDEREF_AV
			       : type == OP_RV2HV ? OPpDEREF_HV
			       : OPpDEREF_SV);
	    op->op_flags |= OPf_MOD;
d1459 1
a1459 1
	if (!(op->op_flags & OPf_KIDS))
d1461 1
a1461 1
	ref(cLISTOP->op_last, type);
d1466 1
a1466 1
    return scalar(op);
d1471 1
a1471 2
my(op)
OP *op;
d1476 2
a1477 2
    if (!op || error_count)
	return op;
d1479 1
a1479 1
    type = op->op_type;
d1481 1
a1481 1
	for (kid = cLISTOP->op_first; kid; kid = kid->op_sibling)
d1483 3
a1485 2
    }
    else if (type != OP_PADSV &&
d1490 2
a1491 2
	yyerror(form("Can't declare %s in my", op_desc[op->op_type]));
	return op;
d1493 3
a1495 3
    op->op_flags |= OPf_MOD;
    op->op_private |= OPpLVAL_INTRO;
    return op;
d1499 1
a1499 2
sawparens(o)
OP *o;
d1507 1
a1507 4
bind_match(type, left, right)
I32 type;
OP *left;
OP *right;
d1509 1
a1509 1
    OP *op;
d1511 1
a1511 1
    if (dowarn &&
d1532 1
a1532 1
	    op = newBINOP(OP_NULL, OPf_STACKED, scalar(left), right);
d1534 1
a1534 1
	    op = prepend_elem(right->op_type, scalar(left), right);
d1536 2
a1537 2
	    return newUNOP(OP_NOT, 0, scalar(op));
	return op;
d1545 1
a1545 2
invert(op)
OP *op;
d1547 2
a1548 2
    if (!op)
	return op;
d1550 1
a1550 1
    return newUNOP(OP_NOT, OPf_SPECIAL, scalar(op));
d1554 1
a1554 2
scope(o)
OP *o;
d1557 1
a1557 1
	if (o->op_flags & OPf_PARENS || PERLDB_NOOPT || tainting) {
d1580 9
d1590 1
a1590 2
block_start(full)
int full;
d1592 4
a1595 2
    int retval = savestack_ix;
    SAVEI32(comppad_name_floor);
d1597 2
a1598 2
	if ((comppad_name_fill = AvFILL(comppad_name)) > 0)
	    comppad_name_floor = comppad_name_fill;
d1600 1
a1600 1
	    comppad_name_floor = 0;
d1602 9
a1610 9
    SAVEI32(min_intro_pending);
    SAVEI32(max_intro_pending);
    min_intro_pending = 0;
    SAVEI32(comppad_name_fill);
    SAVEI32(padix_floor);
    padix_floor = padix;
    pad_reset_pending = FALSE;
    SAVEI32(hints);
    hints &= ~HINT_BLOCK_SCOPE;
d1615 1
a1615 3
block_end(floor, seq)
I32 floor;
OP* seq;
d1617 2
a1618 1
    int needblockscope = hints & HINT_BLOCK_SCOPE;
d1621 1
a1621 1
    pad_reset_pending = FALSE;
d1623 3
a1625 3
	hints |= HINT_BLOCK_SCOPE; /* propagate out */
    pad_leavemy(comppad_name_fill);
    cop_seqmax++;
d1629 12
d1642 1
a1642 2
newPROG(op)
OP *op;
d1644 6
a1649 5
    if (in_eval) {
	eval_root = newUNOP(OP_LEAVEEVAL, ((in_eval & 4) ? OPf_SPECIAL : 0), op);
	eval_start = linklist(eval_root);
	eval_root->op_next = 0;
	peep(eval_start);
d1652 1
a1652 1
	if (!op)
d1654 6
a1659 6
	main_root = scope(sawparens(scalarvoid(op)));
	curcop = &compiling;
	main_start = LINKLIST(main_root);
	main_root->op_next = 0;
	peep(main_start);
	compcv = 0;
d1666 2
a1667 2
		PUSHMARK(sp);
		XPUSHs((SV*)compiling.cop_filegv);
d1676 1
a1676 3
localize(o, lex)
OP *o;
I32 lex;
d1681 1
a1681 2
	scalar(o);
	if (dowarn && bufptr > oldbufptr && bufptr[-1] == ',') {
d1683 1
a1683 1
	    for (s = bufptr; *s && (isALNUM(*s) || strchr("@@$%, ",*s)); s++) ;
d1688 2
a1689 1
    in_my = FALSE;
d1697 1
a1697 2
jmaybe(o)
OP *o;
d1700 8
a1707 4
	o = convert(OP_JOIN, 0,
		prepend_elem(OP_LIST,
		    newSVREF(newGVOP(OP_GV, 0, gv_fetchpv(";", TRUE, SVt_PV))),
		    o));
d1713 1
a1713 2
fold_constants(o)
register OP *o;
d1715 1
d1725 1
a1725 1
    if ((opargs[type] & OA_OTHERINT) && (hints & HINT_INTEGER))
d1737 6
d1747 1
a1747 1
    if (error_count)
d1762 3
a1764 3
    op = curop;
    runops();
    sv = *(stack_sp--);
d1775 4
a1778 1
	if ((SvFLAGS(sv) & (SVf_IOK|SVf_NOK|SVf_POK)) == SVf_NOK) {
d1780 1
a1780 1
	    if ((double)iv == SvNV(sv)) {	/* can we smush double to int */
d1789 1
a1789 1
    
d1794 1
a1794 1
    if (!(hints & HINT_INTEGER)) {
d1815 1
a1815 2
gen_constant_list(o)
register OP *o;
d1817 1
d1819 1
a1819 1
    I32 oldtmps_floor = tmps_floor;
d1822 1
a1822 1
    if (error_count)
d1825 1
a1825 1
    op = curop = LINKLIST(o);
d1827 5
a1831 5
    pp_pushmark();
    runops();
    op = curop;
    pp_anonlist();
    tmps_floor = oldtmps_floor;
d1836 1
a1836 1
    ((UNOP*)o)->op_first = newSVOP(OP_CONST, 0, SvREFCNT_inc(*stack_sp--));
d1843 1
a1843 4
convert(type, flags, op)
I32 type;
I32 flags;
OP* op;
d1848 2
a1849 2
    if (!op || op->op_type != OP_LIST)
	op = newLISTOP(OP_LIST, 0, op, Nullop);
d1851 1
a1851 1
	op->op_flags &= ~OPf_WANT;
d1854 1
a1854 1
	null(cLISTOP->op_first);
d1856 3
a1858 3
    op->op_type = type;
    op->op_ppaddr = ppaddr[type];
    op->op_flags |= flags;
d1860 3
a1862 3
    op = CHECKOP(type, op);
    if (op->op_type != type)
	return op;
d1864 1
a1864 1
    if (cLISTOP->op_children < 7) {
d1866 1
a1866 1
	for (kid = cLISTOP->op_first; kid; kid = kid->op_sibling)
d1868 1
a1868 1
	cLISTOP->op_last = last;	/* in case check substituted last arg */
d1871 1
a1871 1
    return fold_constants(op);
d1877 1
a1877 4
append_elem(type, first, last)
I32 type;
OP* first;
OP* last;
d1900 1
a1900 4
append_list(type, first, last)
I32 type;
LISTOP* first;
LISTOP* last;
d1918 1
a1918 1
	last->op_flags |= OPf_KIDS;
d1925 1
a1925 4
prepend_elem(type, first, last)
I32 type;
OP* first;
OP* last;
d1956 1
a1956 1
newNULLLIST()
d1962 1
a1962 2
force_list(op)
OP* op;
d1964 4
a1967 4
    if (!op || op->op_type != OP_LIST)
	op = newLISTOP(OP_LIST, 0, op, Nullop);
    null(op);
    return op;
d1971 1
a1971 5
newLISTOP(type, flags, first, last)
I32 type;
I32 flags;
OP* first;
OP* last;
d2006 7
a2012 9
newOP(type, flags)
I32 type;
I32 flags;
{
    OP *op;
    Newz(1101, op, 1, OP);
    op->op_type = type;
    op->op_ppaddr = ppaddr[type];
    op->op_flags = flags;
d2014 2
a2015 2
    op->op_next = op;
    op->op_private = 0 + (flags >> 8);
d2017 1
a2017 1
	scalar(op);
d2019 2
a2020 2
	op->op_targ = pad_alloc(type, SVs_PADTMP);
    return CHECKOP(type, op);
d2024 1
a2024 4
newUNOP(type, flags, first)
I32 type;
I32 flags;
OP* first;
d2029 1
a2029 1
	first = newOP(OP_STUB, 0); 
a2038 1

d2047 1
a2047 5
newBINOP(type, flags, first, last)
I32 type;
I32 flags;
OP* first;
OP* last;
d2078 1
a2078 4
pmtrans(op, expr, repl)
OP *op;
OP *expr;
OP *repl;
d2088 1
a2088 1
    I32 delete;
d2090 1
d2093 4
a2096 4
    tbl = (short*)cPVOP->op_pv;
    complement	= op->op_private & OPpTRANS_COMPLEMENT;
    delete	= op->op_private & OPpTRANS_DELETE;
    /* squash	= op->op_private & OPpTRANS_SQUASH; */
d2105 1
a2105 1
		    if (delete)
d2118 1
a2118 1
	if (!rlen && !delete) {
d2120 2
d2127 1
a2127 1
		if (delete) {
d2141 1
a2141 1
    return op;
d2145 1
a2145 3
newPMOP(type, flags)
I32 type;
I32 flags;
d2147 1
d2156 5
a2160 2
    if (hints & HINT_LOCALE)
	pmop->op_pmpermflags = (pmop->op_pmflags |= PMf_LOCALE);
d2163 3
a2165 3
    if (type != OP_TRANS && curstash) {
	pmop->op_pmnext = HvPMROOT(curstash);
	HvPMROOT(curstash) = pmop;
d2172 1
a2172 4
pmruntime(op, expr, repl)
OP *op;
OP *expr;
OP *repl;
d2174 1
d2177 1
d2179 2
a2180 2
    if (op->op_type == OP_TRANS)
	return pmtrans(op, expr, repl);
d2182 2
a2183 2
    hints |= HINT_BLOCK_SCOPE;
    pm = (PMOP*)op;
d2189 1
a2189 1
	if ((op->op_flags & OPf_SPECIAL) && strEQ(p, " ")) {
d2194 2
a2195 2
	pm->op_pmregexp = pregcomp(p, p + plen, pm);
	if (strEQ("\\s+", pm->op_pmregexp->precomp)) 
a2196 1
	hoistmust(pm);
d2200 4
a2203 2
	if (pm->op_pmflags & PMf_KEEP)
	    expr = newUNOP(OP_REGCMAYBE,0,expr);
d2209 3
a2211 1
	rcop->op_flags |= OPf_KIDS;
d2213 1
a2213 1
	rcop->op_other = op;
d2216 1
a2216 1
	if (pm->op_pmflags & PMf_KEEP) {
d2226 1
a2226 1
	prepend_elem(op->op_type, scalar((OP*)rcop), op);
d2231 10
a2240 1
	if (pm->op_pmflags & PMf_EVAL)
d2242 2
d2250 7
d2259 1
d2263 1
d2277 1
a2277 1
			     /* is okay */
d2279 2
d2287 4
a2290 1
	if (curop == repl) {
d2293 1
a2293 1
	    prepend_elem(op->op_type, scalar(repl), op);
d2296 4
d2306 1
a2306 1
	    rcop->op_other = op;
d2322 1
a2322 4
newSVOP(type, flags, sv)
I32 type;
I32 flags;
SV *sv;
d2339 1
a2339 4
newGVOP(type, flags, gv)
I32 type;
I32 flags;
GV *gv;
d2341 1
d2357 1
a2357 4
newPVOP(type, flags, pv)
I32 type;
I32 flags;
char *pv;
d2374 1
a2374 2
package(op)
OP *op;
d2376 1
d2379 3
a2381 3
    save_hptr(&curstash);
    save_item(curstname);
    if (op) {
d2384 1
a2384 1
	sv = cSVOP->op_sv;
d2386 3
a2388 3
	curstash = gv_stashpvn(name,len,TRUE);
	sv_setpvn(curstname, name, len);
	op_free(op);
d2391 2
a2392 2
	sv_setpv(curstname,"<none>");
	curstash = Nullhv;
d2394 3
a2396 2
    copline = NOLINE;
    expect = XSTATE;
d2400 1
a2400 6
utilize(aver, floor, version, id, arg)
int aver;
I32 floor;
OP *version;
OP *id;
OP *arg;
d2407 1
d2438 1
a2438 1
     
d2459 15
a2473 2
    /* Fake up a require */
    rqop = newUNOP(OP_REQUIRE, 0, id);
d2485 25
a2509 2
    copline = NOLINE;
    expect = XSTATE;
d2513 1
a2513 4
newSLICEOP(flags, subscript, listval)
I32 flags;
OP *subscript;
OP *listval;
d2520 2
a2521 3
static I32
list_assignment(op)
register OP *op;
d2523 1
a2523 1
    if (!op)
d2526 2
a2527 2
    if (op->op_type == OP_NULL && op->op_flags & OPf_KIDS)
	op = cUNOP->op_first;
d2529 3
a2531 3
    if (op->op_type == OP_COND_EXPR) {
	I32 t = list_assignment(cCONDOP->op_first->op_sibling);
	I32 f = list_assignment(cCONDOP->op_first->op_sibling->op_sibling);
d2540 3
a2542 3
    if (op->op_type == OP_LIST || op->op_flags & OPf_PARENS ||
	op->op_type == OP_RV2AV || op->op_type == OP_RV2HV ||
	op->op_type == OP_ASLICE || op->op_type == OP_HSLICE)
d2545 1
a2545 1
    if (op->op_type == OP_PADAV || op->op_type == OP_PADHV)
d2548 1
a2548 1
    if (op->op_type == OP_RV2SV)
d2555 1
a2555 5
newASSIGNOP(flags, left, optype, right)
I32 flags;
OP *left;
I32 optype;
OP *right;
d2557 1
a2557 1
    OP *op;
d2572 3
a2574 2
	modcount = 0;
	eval_start = right;	/* Grandfathering $[ assignment here.  Bletch.*/
d2576 2
a2577 2
	if (eval_start)
	    eval_start = 0;
d2583 1
a2583 1
	op = newBINOP(OP_AASSIGN, flags,
d2586 1
a2586 1
	op->op_private = 0 | (flags >> 8);
a2587 1
	    static int generation = 100;
d2589 3
a2591 3
	    OP *lastop = op;
	    generation++;
	    for (curop = LINKLIST(op); curop != op; curop = LINKLIST(curop)) {
d2595 1
a2595 1
			if (gv == defgv || SvCUR(gv) == generation)
d2597 1
a2597 1
			SvCUR(gv) = generation;
d2603 1
a2603 1
			SV **svp = AvARRAY(comppad_name);
d2605 1
a2605 1
			if (SvCUR(sv) == generation)
d2607 1
a2607 1
			SvCUR(sv) = generation;	/* (SvCUR not used any more) */
d2618 8
d2631 2
a2632 2
	    if (curop != op)
		op->op_private = OPpASSIGN_COMMON;
d2642 1
a2642 1
		    !(op->op_private & OPpASSIGN_COMMON) )
d2648 1
a2648 1
			tmpop = ((UNOP*)op)->op_first;	/* to list (nulled) */
d2652 1
a2652 1
			op_free(op);			/* blow off assign */
d2659 1
a2659 1
		    if (modcount < 10000 &&
d2664 1
a2664 1
			    sv_setiv(sv, modcount+1);
d2669 1
a2669 1
	return op;
d2678 2
a2679 2
	eval_start = right;	/* Grandfathering $[ assignment here.  Bletch.*/
	op = newBINOP(OP_SASSIGN, flags,
d2681 2
a2682 2
	if (eval_start)
	    eval_start = 0;
d2684 1
a2684 1
	    op_free(op);
d2688 1
a2688 1
    return op;
d2692 1
a2692 4
newSTATEOP(flags, label, op)
I32 flags;
char *label;
OP *op;
d2694 1
d2699 1
a2699 1
    if (PERLDB_LINE && curcop->cop_line && curstash != debstash) {
d2716 1
a2716 1
	hints |= HINT_BLOCK_SCOPE;
d2719 1
a2719 1
    cop->cop_arybase = curcop->cop_arybase;
d2721 2
a2722 2
    if (copline == NOLINE)
        cop->cop_line = curcop->cop_line;
d2724 2
a2725 2
        cop->cop_line = copline;
        copline = NOLINE;
d2727 2
a2728 2
    cop->cop_filegv = (GV*)SvREFCNT_inc(curcop->cop_filegv);
    cop->cop_stash = curstash;
d2730 3
a2732 3
    if (PERLDB_LINE && curstash != debstash) {
	SV **svp = av_fetch(GvAV(curcop->cop_filegv),(I32)cop->cop_line, FALSE);
	if (svp && *svp != &sv_undef && !SvIOK(*svp)) {
d2739 1
a2739 1
    return prepend_elem(OP_LINESEQ, (OP*)cop, op);
d2744 1
a2744 1
intro_my()
d2750 2
a2751 2
    if (! min_intro_pending)
	return cop_seqmax;
d2753 5
a2757 5
    svp = AvARRAY(comppad_name);
    for (i = min_intro_pending; i <= max_intro_pending; i++) {
	if ((sv = svp[i]) && sv != &sv_undef && !SvIVX(sv)) {
	    SvIVX(sv) = 999999999;	/* Don't know scope end yet. */
	    SvNVX(sv) = (double)cop_seqmax;
d2760 3
a2762 3
    min_intro_pending = 0;
    comppad_name_fill = max_intro_pending;	/* Needn't search higher */
    return cop_seqmax++;
d2766 7
a2772 5
newLOGOP(type, flags, first, other)
I32 type;
I32 flags;
OP* first;
OP* other;
d2774 1
d2776 3
a2778 1
    OP *op;
d2791 6
a2796 6
	    op = first;
	    first = cUNOP->op_first;
	    if (op->op_next)
		first->op_next = op->op_next;
	    cUNOP->op_first = Nullop;
	    op_free(op);
d2800 1
a2800 1
	if (dowarn && (first->op_private & OPpCONST_BARE))
d2804 1
d2809 1
d2819 1
a2819 1
    else if (dowarn && (first->op_flags & OPf_KIDS)) {
d2828 1
a2828 1
		  && (k1->op_type == OP_RV2SV || k1->op_type == OP_PADSV))
d2840 2
a2841 2
	    line_t oldline = curcop->cop_line;
	    curcop->cop_line = copline;
d2846 1
a2846 1
	    curcop->cop_line = oldline;
d2870 2
a2871 2
    op = newUNOP(OP_NULL, 0, (OP*)logop);
    other->op_next = op;
d2873 1
a2873 1
    return op;
d2877 1
a2877 5
newCONDOP(flags, first, trueop, falseop)
I32 flags;
OP* first;
OP* trueop;
OP* falseop;
d2879 1
d2881 1
a2881 1
    OP *op;
d2921 1
a2921 1
    op = newUNOP(OP_NULL, 0, (OP*)condop);
d2923 2
a2924 2
    trueop->op_next = op;
    falseop->op_next = op;
d2926 1
a2926 1
    return op;
d2930 1
a2930 4
newRANGE(flags, left, right)
I32 flags;
OP *left;
OP *right;
d2932 1
d2936 1
a2936 1
    OP *op;
d2953 1
a2953 1
    op = newUNOP(OP_NULL, 0, flop);
d2967 1
a2967 1
    flip->op_next = op;
d2969 1
a2969 1
	linklist(op);		/* blow off optimizer unless constant */
d2971 1
a2971 1
    return op;
d2975 1
a2975 5
newLOOPOP(flags, debuggable, expr, block)
I32 flags;
I32 debuggable;
OP *expr;
OP *block;
d2977 1
d2979 1
a2979 1
    OP* op;
d2989 19
a3007 1
		newASSIGNOP(0, newSVREF(newGVOP(OP_GV, 0, defgv)), 0, expr) );
d3012 1
a3012 1
    op = newLOGOP(OP_AND, 0, expr, listop);
d3014 2
a3015 1
    ((LISTOP*)listop)->op_last->op_next = LINKLIST(op);
d3017 2
a3018 2
    if (once && op != listop)
	op->op_next = ((LOGOP*)cUNOP->op_first)->op_other;
d3020 2
a3021 2
    if (op == listop)
	op = newUNOP(OP_NULL, 0, op);	/* or do {} while 1 loses outer block */
d3023 4
a3026 4
    op->op_flags |= flags;
    op = scope(op);
    op->op_flags |= OPf_SPECIAL;	/* suppress POPBLOCK curpm restoration*/
    return op;
d3030 1
a3030 8
newWHILEOP(flags, debuggable, loop, whileline, expr, block, cont)
I32 flags;
I32 debuggable;
LOOP *loop;
I32 whileline;
OP *expr;
OP *block;
OP *cont;
d3032 1
d3036 1
a3036 1
    OP *op;
d3042 19
a3060 1
	    newASSIGNOP(0, newSVREF(newGVOP(OP_GV, 0, defgv)), 0, expr) );
d3071 1
a3071 1
	    copline = whileline;
d3081 4
a3084 2
	op = newLOGOP(OP_AND, 0, expr, scalar(listop));
	if (op == expr && op->op_type == OP_CONST && !SvTRUE(cSVOP->op_sv)) {
d3087 1
a3087 1
	    return Nullop;		/* (listop already freed by newLOGOP) */
d3089 3
a3091 2
	((LISTOP*)listop)->op_last->op_next = condop = 
	    (op == listop ? redo : LINKLIST(op));
d3096 1
a3096 1
	op = listop;
d3106 1
a3106 1
    op = newBINOP(OP_LEAVELOOP, 0, (OP*)loop, op);
d3109 1
a3109 1
    loop->op_lastop = op;
d3114 1
a3114 1
	loop->op_nextop = op;
d3116 3
a3118 3
    op->op_flags |= flags;
    op->op_private |= (flags >> 8);
    return op;
a3121 10
#ifndef CAN_PROTOTYPE
newFOROP(flags,label,forline,sv,expr,block,cont)
I32 flags;
char *label;
line_t forline;
OP* sv;
OP* expr;
OP*block;
OP*cont;
#else
a3122 1
#endif /* CAN_PROTOTYPE */
d3139 6
d3149 6
a3154 1
	sv = newGVOP(OP_GV, 0, defgv);
d3157 29
a3185 1
	expr = scalar(ref(expr, OP_ITER));
d3188 5
d3194 1
a3194 2
	append_elem(OP_LIST, mod(force_list(expr), OP_GREPSTART),
		    scalar(sv))));
d3199 1
a3199 1
    copline = forline;
d3204 1
a3204 3
newLOOPEX(type, label)
I32 type;
OP* label;
d3206 3
a3208 1
    OP *op;
d3210 8
a3217 4
	op = newPVOP(type, 0, savepv(
		label->op_type == OP_CONST
		    ? SvPVx(((SVOP*)label)->op_sv, na)
		    : "" ));
d3223 1
a3223 1
	op = newUNOP(type, OPf_STACKED, label);
d3225 2
a3226 2
    hints |= HINT_BLOCK_SCOPE;
    return op;
d3230 1
a3230 2
cv_undef(cv)
CV *cv;
d3232 9
d3242 4
d3248 1
d3251 2
a3252 2
	SAVESPTR(curpad);
	curpad = 0;
d3268 1
a3268 1
	    I32 i = AvFILL(CvPADLIST(cv));
d3274 5
a3278 5
		if (sv == (SV*)comppad_name)
		    comppad_name = Nullav;
		else if (sv == (SV*)comppad) {
		    comppad = Nullav;
		    curpad = Null(SV**);
d3289 1
a3289 1
static void
d3304 2
a3305 2
		   : (cv == main_cv) ? "MAIN"
		   : CvUNIQUE(outside) ? "UNIQUE"
d3310 1
a3310 1
		   : (outside == main_cv) ? "MAIN"
d3322 1
a3322 1
    for (ix = 1; ix <= AvFILL(pad_name); ix++) {
d3334 2
a3335 4
static CV *
cv_clone2(proto, outside)
CV* proto;
CV* outside;
d3337 1
d3345 2
a3346 2
    I32 fname = AvFILL(protopad_name);
    I32 fpad = AvFILL(protopad);
d3353 4
a3356 4
    SAVESPTR(curpad);
    SAVESPTR(comppad);
    SAVESPTR(comppad_name);
    SAVESPTR(compcv);
d3358 1
a3358 1
    cv = compcv = (CV*)NEWSV(1104,0);
d3364 5
d3380 1
a3380 1
    comppad_name = newAV();
d3382 1
a3382 1
	av_store(comppad_name, ix, SvREFCNT_inc(pname[ix]));
d3384 1
a3384 1
    comppad = newAV();
d3388 2
a3389 2
    av_store(comppadlist, 0, (SV*)comppad_name);
    av_store(comppadlist, 1, (SV*)comppad);
d3391 2
a3392 2
    av_fill(comppad, AvFILL(protopad));
    curpad = AvARRAY(comppad);
d3396 1
a3396 1
    av_store(comppad, 0, (SV*)av);
d3401 1
a3401 1
	if (namesv && namesv != &sv_undef) {
d3405 1
a3405 1
				      CvOUTSIDE(cv), cxstack_ix);
d3407 1
a3407 1
		    curpad[ix] = SvREFCNT_inc(ppad[ix]);
d3425 1
a3425 1
		curpad[ix] = sv;
d3431 1
a3431 1
	    curpad[ix] = sv;
d3440 1
a3440 1
	    && namesv != &sv_undef
d3449 1
a3449 1
	    curpad[ix] = (SV*)kid;
d3467 1
a3467 2
cv_clone(proto)
CV* proto;
d3469 5
a3473 1
    return cv_clone2(proto, CvOUTSIDE(proto));
d3477 1
a3477 4
cv_ckproto(cv, gv, p)
CV* cv;
GV* gv;
char* p;
d3500 1
a3500 2
cv_const_sv(cv)
CV* cv;
a3501 3
    OP *o;
    SV *sv;
    
d3504 13
d3518 1
a3518 2
    sv = Nullsv;
    for (o = CvSTART(cv); o; o = o->op_next) {
d3520 3
a3522 1
	
d3530 4
a3533 4
	    sv = ((SVOP*)o)->op_sv;
	else if (type == OP_PADSV) {
	    AV* pad = (AV*)(AvARRAY(CvPADLIST(cv))[1]);
	    sv = pad ? AvARRAY(pad)[o->op_targ] : Nullsv;
d3546 1
a3546 5
newSUB(floor,op,proto,block)
I32 floor;
OP *op;
OP *proto;
OP *block;
d3548 7
a3554 4
    char *name = op ? SvPVx(cSVOP->op_sv, na) : Nullch;
    GV *gv = gv_fetchpv(name ? name : "__ANON__", GV_ADDMULTI, SVt_PVCV);
    char *ps = proto ? SvPVx(((SVOP*)proto)->op_sv, na) : Nullch;
    register CV *cv;
d3557 2
a3558 2
    if (op)
	SAVEFREEOP(op);
d3562 17
d3586 1
d3589 1
a3589 1
		SAVEFREESV(compcv);
d3593 1
a3593 1
	    if (curstack == sortstack && sortcop == CvSTART(cv))
d3595 8
a3602 4
	    const_sv = cv_const_sv(cv);
	    if (const_sv || dowarn) {
		line_t oldline = curcop->cop_line;
		curcop->cop_line = copline;
d3605 1
a3605 1
		curcop->cop_line = oldline;
d3613 8
a3620 8
	CvFLAGS(cv) = CvFLAGS(compcv);
	CvOUTSIDE(cv) = CvOUTSIDE(compcv);
	CvOUTSIDE(compcv) = 0;
	CvPADLIST(cv) = CvPADLIST(compcv);
	CvPADLIST(compcv) = 0;
	if (SvREFCNT(compcv) > 1) /* XXX Make closures transit through stub. */
	    CvOUTSIDE(compcv) = (CV*)SvREFCNT_inc((SV*)cv);
	SvREFCNT_dec(compcv);
d3623 1
a3623 1
	cv = compcv;
d3627 1
a3627 1
	    sub_generation++;
d3631 9
a3639 2
    CvFILEGV(cv) = curcop->cop_filegv;
    CvSTASH(cv) = curstash;
d3644 1
a3644 1
    if (error_count) {
d3653 1
a3653 1
		if (in_eval & 4)
d3657 2
a3658 2
		    sv_catpv(GvSV(errgv), not_safe);
		    croak("%s", SvPVx(GvSV(errgv), na));
d3664 2
a3665 1
	copline = NOLINE;
d3670 2
a3671 2
    if (AvFILL(comppad_name) < AvFILL(comppad))
	av_store(comppad_name, AvFILL(comppad), Nullsv);
d3674 2
a3675 2
	SV **namep = AvARRAY(comppad_name);
	for (ix = AvFILL(comppad); ix > 0; ix--) {
d3678 1
a3678 1
	    if (SvIMMORTAL(curpad[ix]))
d3686 1
a3686 1
		  namesv != &sv_undef &&
d3690 2
a3691 2
		SvREFCNT_dec(curpad[ix]);
		curpad[ix] = Nullsv;
d3698 1
a3698 1
	av_store(comppad, 0, (SV*)av);
d3701 2
a3702 2
	for (ix = AvFILL(comppad); ix > 0; ix--) {
	    if (SvIMMORTAL(curpad[ix]))
d3704 2
a3705 2
	    if (!SvPADMY(curpad[ix]))
		SvPADTMP_on(curpad[ix]);
d3717 1
a3717 1
	if (PERLDB_SUBLINE && curstash != debstash) {
d3720 1
a3720 1
	    static GV *db_postponed;
d3725 2
a3726 2
		    GvSV(curcop->cop_filegv),
		    (long)subline, (long)curcop->cop_line);
d3728 1
a3728 4
	    hv_store(GvHV(DBsub), SvPVX(tmpstr), SvCUR(tmpstr), sv, 0);
	    if (!db_postponed) {
		db_postponed = gv_fetchpv("DB::postponed", GV_ADDMULTI, SVt_PVHV);
	    }
d3733 1
a3733 1
		PUSHMARK(sp);
d3745 1
a3745 1
	    I32 oldscope = scopestack_ix;
d3747 4
a3750 5
	    SAVESPTR(compiling.cop_filegv);
	    SAVEI16(compiling.cop_line);
	    SAVEI32(perldb);
	    save_svref(&rs);
	    sv_setsv(rs, nrs);
d3752 2
a3753 2
	    if (!beginav)
		beginav = newAV();
d3755 1
a3755 1
	    av_push(beginav, (SV *)cv);
d3757 1
a3757 1
	    call_list(oldscope, beginav);
d3759 1
a3759 1
	    curcop = &compiling;
d3762 11
a3772 5
	else if (strEQ(s, "END") && !error_count) {
	    if (!endav)
		endav = newAV();
	    av_unshift(endav, 1);
	    av_store(endav, 0, (SV *)cv);
d3778 1
a3778 1
    copline = NOLINE;
d3783 26
a3808 12
#ifdef DEPRECATED
CV *
newXSUB(name, ix, subaddr, filename)
char *name;
I32 ix;
I32 (*subaddr)();
char *filename;
{
    CV* cv = newXS(name, (void(*)())subaddr, filename);
    CvOLDSTYLE_on(cv);
    CvXSUBANY(cv).any_i32 = ix;
    return cv;
a3809 1
#endif
d3812 1
a3812 4
newXS(name, subaddr, filename)
char *name;
void (*subaddr) _((CV*));
char *filename;
d3814 1
d3826 6
a3831 3
	    if (dowarn) {
		line_t oldline = curcop->cop_line;
		curcop->cop_line = copline;
d3833 1
a3833 1
		curcop->cop_line = oldline;
d3848 1
a3848 1
	    sub_generation++;
d3852 5
d3867 3
a3869 3
	    if (!beginav)
		beginav = newAV();
	    av_push(beginav, (SV *)cv);
d3873 10
a3882 4
	    if (!endav)
		endav = newAV();
	    av_unshift(endav, 1);
	    av_store(endav, 0, (SV *)cv);
d3893 1
a3893 4
newFORM(floor,op,block)
I32 floor;
OP *op;
OP *block;
d3895 1
d3900 1
d3902 2
a3903 2
    if (op)
	name = SvPVx(cSVOP->op_sv, na);
d3909 2
a3910 2
	if (dowarn) {
	    line_t oldline = curcop->cop_line;
d3912 1
a3912 1
	    curcop->cop_line = copline;
d3914 1
a3914 1
	    curcop->cop_line = oldline;
d3918 1
a3918 1
    cv = compcv;
d3921 1
a3921 1
    CvFILEGV(cv) = curcop->cop_filegv;
d3923 3
a3925 3
    for (ix = AvFILL(comppad); ix > 0; ix--) {
	if (!SvPADMY(curpad[ix]) && !SvIMMORTAL(curpad[ix]))
	    SvPADTMP_on(curpad[ix]);
d3932 2
a3933 2
    op_free(op);
    copline = NOLINE;
d3938 1
a3938 2
newANONLIST(op)
OP* op;
d3941 1
a3941 1
	mod(list(convert(OP_ANONLIST, 0, op)), OP_REFGEN));
d3945 1
a3945 2
newANONHASH(op)
OP* op;
d3948 1
a3948 1
	mod(list(convert(OP_ANONHASH, 0, op)), OP_REFGEN));
d3952 1
a3952 4
newANONSUB(floor, proto, block)
I32 floor;
OP *proto;
OP *block;
d3959 1
a3959 2
oopsAV(o)
OP *o;
d3965 1
a3965 1
	return ref(newUNOP(OP_RV2AV, 0, scalar(o)), OP_RV2AV);
d3981 1
a3981 2
oopsHV(o)
OP *o;
d3988 1
a3988 1
	return ref(newUNOP(OP_RV2HV, 0, scalar(o)), OP_RV2HV);
d4005 1
a4005 2
newAVREF(o)
OP *o;
d4016 1
a4016 3
newGVREF(type,o)
I32 type;
OP *o;
d4018 1
a4018 1
    if (type == OP_MAPSTART)
d4024 1
a4024 2
newHVREF(o)
OP *o;
d4035 1
a4035 2
oopsCV(o)
OP *o;
d4043 1
a4043 3
newCVREF(flags, o)
I32 flags;
OP *o;
d4049 1
a4049 2
newSVREF(o)
OP *o;
d4056 4
d4066 1
a4066 2
ck_anoncode(op)
OP *op;
d4076 7
a4082 7
    ix = pad_alloc(op->op_type, SVs_PADMY);
    av_store(comppad_name, ix, name);
    av_store(comppad, ix, cSVOP->op_sv);
    SvPADMY_on(cSVOP->op_sv);
    cSVOP->op_sv = Nullsv;
    cSVOP->op_targ = ix;
    return op;
d4086 1
a4086 2
ck_bitop(op)
OP *op;
d4088 2
a4089 2
    op->op_private = hints;
    return op;
d4093 1
a4093 2
ck_concat(op)
OP *op;
d4095 3
a4097 3
    if (cUNOP->op_first->op_type == OP_CONCAT)
	op->op_flags |= OPf_STACKED;
    return op;
d4101 1
a4101 2
ck_spair(op)
OP *op;
d4103 1
a4103 1
    if (op->op_flags & OPf_KIDS) {
d4106 3
a4108 3
	OPCODE type = op->op_type;
	op = modkids(ck_fun(op), type);
	kid = cUNOP->op_first;
d4115 2
a4116 2
	    
	    return op;
d4121 2
a4122 2
    op->op_ppaddr = ppaddr[++op->op_type];
    return ck_fun(op);
d4126 1
a4126 2
ck_delete(op)
OP *op;
d4128 4
a4131 4
    op = ck_fun(op);
    op->op_private = 0;
    if (op->op_flags & OPf_KIDS) {
	OP *kid = cUNOP->op_first;
d4133 1
a4133 1
	    op->op_private |= OPpSLICE;
d4136 1
a4136 1
		  op_desc[op->op_type]);
d4139 1
a4139 1
    return op;
d4143 1
a4143 2
ck_eof(op)
OP *op;
d4145 1
a4145 1
    I32 type = op->op_type;
d4147 5
a4151 5
    if (op->op_flags & OPf_KIDS) {
	if (cLISTOP->op_first->op_type == OP_STUB) {
	    op_free(op);
	    op = newUNOP(type, OPf_SPECIAL,
               newGVOP(OP_GV, 0, gv_fetchpv("main::ARGV", TRUE, SVt_PVAV)));
d4153 1
a4153 1
	return ck_fun(op);
d4155 1
a4155 1
    return op;
d4159 1
a4159 2
ck_eval(op)
OP *op;
d4161 3
a4163 3
    hints |= HINT_BLOCK_SCOPE;
    if (op->op_flags & OPf_KIDS) {
	SVOP *kid = (SVOP*)cUNOP->op_first;
d4166 2
a4167 2
	    op->op_flags &= ~OPf_KIDS;
	    null(op);
d4172 3
a4174 3
	    kid->op_next = op->op_next;
	    cUNOP->op_first = 0;
	    op_free(op);
d4184 5
a4188 5
	    op = prepend_elem(OP_LINESEQ, (OP*)enter, (OP*)kid);
	    op->op_type = OP_LEAVETRY;
	    op->op_ppaddr = ppaddr[OP_LEAVETRY];
	    enter->op_other = op;
	    return op;
d4190 2
d4194 2
a4195 2
	op_free(op);
	op = newUNOP(OP_ENTEREVAL, 0, newSVREF(newGVOP(OP_GV, 0, defgv)));
d4197 2
a4198 2
    op->op_targ = (PADOFFSET)hints;
    return op;
d4202 1
a4202 2
ck_exec(op)
OP *op;
d4205 3
a4207 3
    if (op->op_flags & OPf_STACKED) {
	op = ck_fun(op);
	kid = cUNOP->op_first->op_sibling;
d4212 2
a4213 2
	op = listkids(op);
    return op;
d4217 1
a4217 2
ck_exists(op)
OP *op;
d4219 3
a4221 3
    op = ck_fun(op);
    if (op->op_flags & OPf_KIDS) {
	OP *kid = cUNOP->op_first;
d4223 1
a4223 1
	    croak("%s argument is not a HASH element", op_desc[op->op_type]);
d4226 1
a4226 1
    return op;
d4230 1
a4230 2
ck_gvconst(o)
register OP *o;
d4239 1
a4239 2
ck_rvconst(op)
register OP *op;
d4241 2
a4242 1
    SVOP *kid = (SVOP*)cUNOP->op_first;
d4244 1
a4244 1
    op->op_private |= (hints & HINT_STRICT_REFS);
d4249 41
d4291 1
a4291 2
	name = SvPV(kid->op_sv, na);
	if ((hints & HINT_STRICT_REFS) && (kid->op_private & OPpCONST_BARE)) {
d4293 1
a4293 1
	    switch (op->op_type) {
d4309 10
a4318 11
	kid->op_type = OP_GV;
	iscv = (op->op_type == OP_RV2CV) * 2;
	for (gv = 0; !gv; iscv++) {
	    /*
	     * This is a little tricky.  We only want to add the symbol if we
	     * didn't add it in the lexer.  Otherwise we get duplicate strict
	     * warnings.  But if we didn't add it in the lexer, we must at
	     * least pretend like we wanted to add it even if it existed before,
	     * or we get possible typo warnings.  OPpCONST_ENTERED says
	     * whether the lexer already added THIS instance of this symbol.
	     */
d4323 1
a4323 1
		    : op->op_type == OP_RV2SV
d4325 1
a4325 1
			: op->op_type == OP_RV2AV
d4327 1
a4327 1
			    : op->op_type == OP_RV2HV
d4330 5
a4335 2
	SvREFCNT_dec(kid->op_sv);
	kid->op_sv = SvREFCNT_inc(gv);
d4337 1
a4337 1
    return op;
d4341 1
a4341 2
ck_ftst(op)
OP *op;
d4343 2
a4344 1
    I32 type = op->op_type;
d4346 2
a4347 2
    if (op->op_flags & OPf_REF)
	return op;
d4349 2
a4350 2
    if (op->op_flags & OPf_KIDS) {
	SVOP *kid = (SVOP*)cUNOP->op_first;
d4353 1
d4355 2
a4356 2
		gv_fetchpv(SvPVx(kid->op_sv, na), TRUE, SVt_PVIO));
	    op_free(op);
d4361 1
a4361 1
	op_free(op);
d4366 1
a4366 1
	    return newUNOP(type, 0, newSVREF(newGVOP(OP_GV, 0, defgv)));
d4368 1
a4368 1
    return op;
d4372 1
a4372 2
ck_fun(op)
OP *op;
d4374 1
d4379 1
a4379 1
    int type = op->op_type;
d4381 2
a4382 2
    
    if (op->op_flags & OPf_STACKED) {
d4386 1
a4386 1
	    return no_fh_allowed(op);
d4389 4
a4392 3
    if (op->op_flags & OPf_KIDS) {
	tokid = &cLISTOP->op_first;
	kid = cLISTOP->op_first;
d4400 1
a4400 1
	    *tokid = kid = newSVREF(newGVOP(OP_GV, 0, defgv));
d4420 1
a4420 1
		    char *name = SvPVx(((SVOP*)kid)->op_sv, na);
d4423 1
a4423 1
		    if (dowarn)
d4432 1
a4432 1
		    bad_type(numargs, "array", op_desc[op->op_type], kid);
d4438 1
a4438 1
		    char *name = SvPVx(((SVOP*)kid)->op_sv, na);
d4441 1
a4441 1
		    if (dowarn)
d4450 1
a4450 1
		    bad_type(numargs, "hash", op_desc[op->op_type], kid);
d4465 1
a4465 1
		if (kid->op_type != OP_GV) {
d4469 1
a4469 1
			    gv_fetchpv(SvPVx(((SVOP*)kid)->op_sv, na), TRUE,
d4474 4
d4495 1
a4495 1
	op->op_private |= numargs;
d4497 2
a4498 2
	    return too_many_arguments(op,op_desc[op->op_type]);
	listkids(op);
d4501 2
a4502 2
	op_free(op);
	return newUNOP(type, 0, newSVREF(newGVOP(OP_GV, 0, defgv)));
d4509 1
a4509 1
	    return too_few_arguments(op,op_desc[op->op_type]);
d4511 1
a4511 1
    return op;
d4515 1
a4515 2
ck_glob(op)
OP *op;
d4519 2
a4520 2
    if ((op->op_flags & OPf_KIDS) && !cLISTOP->op_first->op_sibling)
	append_elem(OP_GLOB, op, newSVREF(newGVOP(OP_GV, 0, defgv)));
d4526 1
d4528 1
d4530 1
a4530 1
	append_elem(OP_GLOB, op,
d4532 11
a4542 11
	op->op_type = OP_LIST;
	op->op_ppaddr = ppaddr[OP_LIST];
	((LISTOP*)op)->op_first->op_type = OP_PUSHMARK;
	((LISTOP*)op)->op_first->op_ppaddr = ppaddr[OP_PUSHMARK];
	op = newUNOP(OP_ENTERSUB, OPf_STACKED,
		     append_elem(OP_LIST, op, 
				 scalar(newUNOP(OP_RV2CV, 0,
						newGVOP(OP_GV, 0, gv)))));
	op = newUNOP(OP_NULL, 0, ck_subr(op));
	op->op_targ = OP_GLOB;		/* hint at what it used to be */
	return op;
d4546 3
a4548 3
    append_elem(OP_GLOB, op, newGVOP(OP_GV, 0, gv));
    scalarkids(op);
    return ck_fun(op);
d4552 1
a4552 2
ck_grep(op)
OP *op;
d4556 1
a4556 1
    OPCODE type = op->op_type == OP_GREPSTART ? OP_GREPWHILE : OP_MAPWHILE;
d4558 1
a4558 1
    op->op_ppaddr = ppaddr[OP_GREPSTART];
d4560 2
a4561 2
    
    if (op->op_flags & OPf_STACKED) {
d4563 3
a4565 3
	op = ck_sort(op);
        kid = cLISTOP->op_first->op_sibling;
	for (k = cLISTOP->op_first->op_sibling->op_next; k; k = k->op_next) {
d4569 1
a4569 1
	op->op_flags &= ~OPf_STACKED;
d4571 1
a4571 1
    kid = cLISTOP->op_first->op_sibling;
d4576 4
a4579 4
    op = ck_fun(op);
    if (error_count)
	return op;
    kid = cLISTOP->op_first->op_sibling; 
d4586 1
a4586 1
    gwop->op_first = listkids(op);
d4593 1
a4593 1
    kid = cLISTOP->op_first->op_sibling;
d4595 1
a4595 1
	return too_few_arguments(op,op_desc[op->op_type]);
d4603 1
a4603 2
ck_index(op)
OP *op;
d4605 4
a4608 2
    if (op->op_flags & OPf_KIDS) {
	OP *kid = cLISTOP->op_first->op_sibling;	/* get past pushmark */
d4610 1
a4610 1
	    fbm_compile(((SVOP*)kid)->op_sv);
d4612 1
a4612 1
    return ck_fun(op);
d4616 1
a4616 2
ck_lengthconst(op)
OP *op;
d4619 1
a4619 1
    return ck_fun(op);
d4623 1
a4623 2
ck_lfun(op)
OP *op;
d4625 2
a4626 2
    OPCODE type = op->op_type;
    return modkids(ck_fun(op), type);
d4630 1
a4630 2
ck_rfun(op)
OP *op;
d4632 2
a4633 2
    OPCODE type = op->op_type;
    return refkids(ck_fun(op), type);
d4637 1
a4637 2
ck_listiob(op)
OP *op;
d4640 2
a4641 2
    
    kid = cLISTOP->op_first;
d4643 2
a4644 2
	op = force_list(op);
	kid = cLISTOP->op_first;
d4648 1
a4648 1
    if (kid && op->op_flags & OPf_STACKED)
d4652 1
a4652 1
	    op->op_flags |= OPf_STACKED;	/* make it a filehandle */
d4654 2
a4655 2
	    cLISTOP->op_first->op_sibling = kid;
	    cLISTOP->op_last = kid;
d4661 1
a4661 1
	append_elem(op->op_type, op, newSVREF(newGVOP(OP_GV, 0, defgv)) );
d4663 1
a4663 1
    op = listkids(op);
d4665 1
a4665 1
    op->op_private = 0;
d4667 2
a4668 2
    if (hints & HINT_LOCALE)
	op->op_private |= OPpLOCALE;
d4671 1
a4671 1
    return op;
d4675 1
a4675 2
ck_fun_locale(op)
OP *op;
d4677 1
a4677 1
    op = ck_fun(op);
d4679 1
a4679 1
    op->op_private = 0;
d4681 2
a4682 2
    if (hints & HINT_LOCALE)
	op->op_private |= OPpLOCALE;
d4685 1
a4685 1
    return op;
d4689 1
a4689 2
ck_scmp(op)
OP *op;
d4691 1
a4691 1
    op->op_private = 0;
d4693 2
a4694 2
    if (hints & HINT_LOCALE)
	op->op_private |= OPpLOCALE;
d4697 1
a4697 1
    return op;
d4701 1
a4701 2
ck_match(op)
OP *op;
d4703 2
a4704 2
    op->op_private |= OPpRUNTIME;
    return op;
d4708 1
a4708 2
ck_null(op)
OP *op;
d4710 1
a4710 1
    return op;
d4714 1
a4714 2
ck_repeat(op)
OP *op;
d4716 3
a4718 3
    if (cBINOP->op_first->op_flags & OPf_PARENS) {
	op->op_private |= OPpREPEAT_DOLIST;
	cBINOP->op_first = force_list(cBINOP->op_first);
d4721 2
a4722 2
	scalar(op);
    return op;
d4726 1
a4726 2
ck_require(op)
OP *op;
d4728 2
a4729 2
    if (op->op_flags & OPf_KIDS) {	/* Shall we supply missing .pm? */
	SVOP *kid = (SVOP*)cUNOP->op_first;
d4743 1
a4743 1
    return ck_fun(op);
d4747 1
a4747 2
ck_retarget(op)
OP *op;
d4751 1
a4751 1
    return op;
d4755 1
a4755 2
ck_select(op)
OP *op;
d4758 2
a4759 2
    if (op->op_flags & OPf_KIDS) {
	kid = cLISTOP->op_first->op_sibling;	/* get past pushmark */
d4761 4
a4764 4
	    op->op_type = OP_SSELECT;
	    op->op_ppaddr = ppaddr[OP_SSELECT];
	    op = ck_fun(op);
	    return fold_constants(op);
d4767 2
a4768 2
    op = ck_fun(op);
    kid = cLISTOP->op_first->op_sibling;    /* get past pushmark */
d4771 1
a4771 1
    return op;
d4775 1
a4775 2
ck_shift(op)
OP *op;
d4777 1
a4777 1
    I32 type = op->op_type;
d4779 20
a4798 7
    if (!(op->op_flags & OPf_KIDS)) {
	op_free(op);
	return newUNOP(type, 0,
	    scalar(newUNOP(OP_RV2AV, 0,
		scalar(newGVOP(OP_GV, 0, subline 
			       ? defgv 
			       : gv_fetchpv("ARGV", TRUE, SVt_PVAV) )))));
d4800 1
a4800 1
    return scalar(modkids(ck_fun(op), type));
d4804 1
a4804 2
ck_sort(op)
OP *op;
d4806 1
a4806 1
    op->op_private = 0;
d4808 2
a4809 2
    if (hints & HINT_LOCALE)
	op->op_private |= OPpLOCALE;
d4812 2
a4813 2
    if (op->op_flags & OPf_STACKED) {
	OP *kid = cLISTOP->op_first->op_sibling;	/* get past pushmark */
d4815 5
d4829 1
a4829 1
		if (op->op_type == OP_SORT) {
d4844 1
a4844 1
	    kid = cLISTOP->op_first->op_sibling;	/* get past pushmark */
d4846 1
a4846 1
	    if (op->op_type == OP_SORT)
d4850 1
a4850 1
	    op->op_flags |= OPf_SPECIAL;
d4852 3
a4854 1
    }
d4856 1
a4856 1
    return op;
d4860 1
a4860 2
ck_split(op)
OP *op;
a4862 4
    PMOP* pm;
    
    if (op->op_flags & OPf_STACKED)
	return no_fh_allowed(op);
d4864 4
a4867 1
    kid = cLISTOP->op_first;
d4871 2
a4872 2
    op_free(cLISTOP->op_first);
    cLISTOP->op_first = kid;
d4874 2
a4875 2
	cLISTOP->op_first = kid = newSVOP(OP_CONST, 0, newSVpv(" ", 1));
	cLISTOP->op_last = kid; /* There was only one element previously */
d4882 3
a4884 3
	if (cLISTOP->op_first == cLISTOP->op_last)
	    cLISTOP->op_last = kid;
	cLISTOP->op_first = kid;
a4886 5
    pm = (PMOP*)kid;
    if (pm->op_pmshort && !(pm->op_pmflags & PMf_ALL)) {
	SvREFCNT_dec(pm->op_pmshort);	/* can't use substring to optimize */
	pm->op_pmshort = 0;
    }
d4893 1
a4893 1
	append_elem(OP_SPLIT, op, newSVREF(newGVOP(OP_GV, 0, defgv)) );
d4899 1
a4899 1
	append_elem(OP_SPLIT, op, newSVOP(OP_CONST, 0, newSViv(0)));
d4905 1
a4905 1
	return too_many_arguments(op,op_desc[op->op_type]);
d4907 1
a4907 1
    return op;
d4911 1
a4911 2
ck_subr(op)
OP *op;
d4913 4
a4916 3
    OP *prev = ((cUNOP->op_first->op_sibling)
	     ? cUNOP : ((UNOP*)cUNOP->op_first))->op_first;
    OP *o = prev->op_sibling;
d4923 1
d4925 1
a4925 1
    for (cvop = o; cvop->op_sibling; cvop = cvop->op_sibling) ;
d4928 1
a4928 1
	op->op_private |= (cvop->op_private & OPpENTERSUB_AMPER);
d4933 1
a4933 1
	    if (cv && SvPOK(cv) && !(op->op_private & OPpENTERSUB_AMPER)) {
d4935 1
a4935 1
		proto = SvPV((SV*)cv, na);
d4939 4
a4942 4
    op->op_private |= (hints & HINT_STRICT_REFS);
    if (PERLDB_SUB && curstash != debstash)
	op->op_private |= OPpENTERSUB_DB;
    while (o != cvop) {
d4946 1
a4946 1
		return too_many_arguments(op, gv_ename(namegv));
d4954 1
a4954 1
		scalar(o);
d4958 1
a4958 1
		list(o);
d4964 2
a4965 2
		if (o->op_type != OP_REFGEN && o->op_type != OP_UNDEF)
		    bad_type(arg, "block", gv_ename(namegv), o);
d4968 1
d4971 4
a4974 10
		if (o->op_type == OP_RV2GV)
		    goto wrapref;
		{
		    OP* kid = o;
		    o = newUNOP(OP_RV2GV, 0, kid);
		    o->op_sibling = kid->op_sibling;
		    kid->op_sibling = 0;
		    prev->op_sibling = o;
		}
		goto wrapref;
d4980 2
a4981 2
		    if (o->op_type != OP_RV2GV)
			bad_type(arg, "symbol", gv_ename(namegv), o);
d4984 2
a4985 2
		    if (o->op_type != OP_RV2CV)
			bad_type(arg, "sub", gv_ename(namegv), o);
d4988 6
a4993 2
		    if (o->op_type != OP_RV2SV && o->op_type != OP_PADSV)
			bad_type(arg, "scalar", gv_ename(namegv), o);
d4996 2
a4997 2
		    if (o->op_type != OP_RV2AV && o->op_type != OP_PADAV)
			bad_type(arg, "array", gv_ename(namegv), o);
d5000 2
a5001 2
		    if (o->op_type != OP_RV2HV && o->op_type != OP_PADHV)
			bad_type(arg, "hash", gv_ename(namegv), o);
d5004 2
a5005 3
			OP* kid = o;
			o = newUNOP(OP_REFGEN, 0, kid);
			o->op_sibling = kid->op_sibling;
d5007 3
a5009 1
			prev->op_sibling = o;
d5021 1
a5021 1
			gv_ename(namegv), SvPV((SV*)cv, na));
d5025 4
a5028 4
	    list(o);
	mod(o, OP_ENTERSUB);
	prev = o;
	o = o->op_sibling;
d5032 2
a5033 2
	return too_few_arguments(op, gv_ename(namegv));
    return op;
d5037 1
a5037 2
ck_svconst(op)
OP *op;
d5039 2
a5040 2
    SvREADONLY_on(cSVOP->op_sv);
    return op;
d5044 1
a5044 2
ck_trunc(op)
OP *op;
d5046 2
a5047 2
    if (op->op_flags & OPf_KIDS) {
	SVOP *kid = (SVOP*)cUNOP->op_first;
d5053 1
a5053 1
	    op->op_flags |= OPf_SPECIAL;
d5055 1
a5055 1
    return ck_fun(op);
d5061 1
a5061 2
peep(o)
register OP* o;
d5063 1
d5065 1
d5069 2
a5070 2
    SAVESPTR(op);
    SAVESPTR(curcop);
d5074 3
a5076 3
	if (!op_seqmax)
	    op_seqmax++;
	op = o;
d5080 2
a5081 2
	    curcop = ((COP*)o);		/* for warnings */
	    o->op_seq = op_seqmax++;
d5092 1
a5092 1
	    if (o->op_next->op_type == OP_STRINGIFY)
d5094 1
a5094 1
	    o->op_seq = op_seqmax++;
d5098 1
a5098 1
		o->op_seq = op_seqmax++;
d5104 1
a5104 1
		curcop = ((COP*)op);
d5114 1
a5114 1
	    o->op_seq = op_seqmax++;
d5131 1
a5131 1
		    (op = pop->op_next) &&
d5135 1
a5135 1
		    (i = SvIV(((SVOP*)pop)->op_sv) - compiling.cop_arybase)
d5151 1
a5151 1
	    o->op_seq = op_seqmax++;
d5158 3
a5160 1
	    o->op_seq = op_seqmax++;
d5165 1
a5165 1
	    o->op_seq = op_seqmax++;
d5171 1
a5171 1
	    o->op_seq = op_seqmax++;
d5177 1
d5180 1
a5180 1
	    o->op_seq = op_seqmax++;
d5185 2
a5186 2
	    o->op_seq = op_seqmax++;
	    if (dowarn && o->op_next && o->op_next->op_type == OP_NEXTSTATE) {
d5188 2
d5191 1
a5191 1
		    line_t oldline = curcop->cop_line;
d5193 1
a5193 1
		    curcop->cop_line = ((COP*)o->op_next)->cop_line;
d5196 1
a5196 1
		    curcop->cop_line = oldline;
d5200 41
d5242 1
a5242 1
	    o->op_seq = op_seqmax++;
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1994, Larry Wall
d29 4
a32 2
    ((op_mask && op_mask[type]) \
     ? (croak("%s trapped by operation mask", op_desc[type]), (OP*)op) \
d42 1
d47 1
a47 1
static PADOFFSET pad_findlex _((char* name, PADOFFSET newoff, I32 seq,
d51 2
a52 2
CvNAME(cv)
CV* cv;
d55 1
a55 1
    gv_efullname(tmpsv, CvGV(cv));
d63 2
a64 3
    sprintf(tokenbuf,"Missing comma after first argument to %s function",
	op_desc[op->op_type]);
    yyerror(tokenbuf);
d73 1
a73 2
    sprintf(tokenbuf,"Not enough arguments for %s", name);
    yyerror(tokenbuf);
d82 1
a82 2
    sprintf(tokenbuf,"Too many arguments for %s", name);
    yyerror(tokenbuf);
d93 2
a94 3
    sprintf(tokenbuf, "Type of arg %d to %s must be %s (not %s)",
	(int) n, name, t, op_desc[kid->op_type]);
    yyerror(tokenbuf);
d104 2
a105 3
	sprintf(tokenbuf, "Can't use subscript on %s", op_desc[type]);
	yyerror(tokenbuf);
	if (type == OP_RV2HV || type == OP_ENTERSUB)
d107 1
a107 1
		type == OP_RV2HV ? '%' : '&');
d121 5
a125 2
	if (!isprint(name[1]))
	    sprintf(name+1, "^%c", name[1] ^ 64); /* XXX is tokenbuf, really */
d128 13
d164 1
a164 1
I32 seq;
d168 1
a168 1
pad_findlex(char *name, PADOFFSET newoff, I32 seq, CV* startcv, I32 cx_ix)
d179 2
a180 2
	AV* curlist = CvPADLIST(cv);
	SV** svp = av_fetch(curlist, 0, FALSE);
d182 1
d191 1
a191 1
		seq > (I32)SvNVX(sv) &&
d194 15
a208 3
		I32 depth = CvDEPTH(cv) ? CvDEPTH(cv) : 1;
		AV *oldpad = (AV*)*av_fetch(curlist, depth, FALSE);
		SV *oldsv = *av_fetch(oldpad, off, TRUE);
d210 1
a210 1
		    SV *sv = NEWSV(1103,0);
d212 34
a245 6
		    sv_upgrade(sv, SVt_PVNV);
		    sv_setpv(sv, name);
		    av_store(comppad_name, newoff, sv);
		    SvNVX(sv) = (double)curcop->cop_seq;
		    SvIVX(sv) = 999999999;	/* A ref, intro immediately */
		    SvFLAGS(sv) |= SVf_FAKE;
a247 1
		CvCLONE_on(compcv);
d269 8
a276 4
	    if (cx->blk_eval.old_op_type != OP_ENTEREVAL &&
		cx->blk_eval.old_op_type != OP_ENTERTRY)
		return 0;	/* require must have its own scope */
	    saweval = i;
d299 1
d302 1
a302 1
    I32 seq = cop_seqmax;
d308 3
a310 2
	    seq <= SvIVX(sv) &&
	    seq > (I32)SvNVX(sv) &&
d313 3
a315 1
	    return (PADOFFSET)off;
d321 4
a324 1
    if (off)
d326 1
d370 15
a384 3
	do {
	    sv = *av_fetch(comppad, ++padix, TRUE);
	} while (SvFLAGS(sv) & (SVs_PADTMP|SVs_PADMY));
d389 1
a389 1
    DEBUG_X(fprintf(stderr, "Pad alloc %ld for %s\n", (long) retval, op_name[optype]));
d403 1
a403 1
    DEBUG_X(fprintf(stderr, "Pad sv %d\n", po));
d421 2
a422 2
    DEBUG_X(fprintf(stderr, "Pad free %d\n", po));
    if (curpad[po] && curpad[po] != &sv_undef)
d440 1
a440 1
    DEBUG_X(fprintf(stderr, "Pad swipe %d\n", po));
d455 1
a455 1
    DEBUG_X(fprintf(stderr, "Pad reset\n"));
d458 1
a458 1
	    if (curpad[po] && curpad[po] != &sv_undef)
d474 1
a474 1
    if (!op)
d491 4
d497 1
d502 1
a525 2
    default:
	break;
d609 2
a610 1
    if (!op || (op->op_flags & OPf_KNOW) || error_count)
d613 1
a613 2
    op->op_flags &= ~OPf_LIST;
    op->op_flags |= OPf_KNOW;
d644 10
a653 2
	scalar(cLISTOP->op_first);
	/* FALL THROUGH */
d677 3
a679 3
    if (!op || error_count)
	return op;
    if (op->op_flags & OPf_LIST)
d682 1
a682 1
    op->op_flags |= OPf_KNOW;
d688 2
a715 2
    case OP_VALUES:
    case OP_KEYS:
a805 5
    case OP_REPEAT:
	scalarvoid(cBINOP->op_first);
	useless = op_desc[op->op_type];
	break;

d812 1
d818 1
d824 1
a828 1
	op->op_private |= OPpLEAVE_VOID;
d834 7
a846 3
    case OP_DELETE:
	op->op_private |= OPpLEAVE_VOID;
	break;
d872 2
a873 1
    if (!op || (op->op_flags & OPf_KNOW) || error_count)
d876 1
a876 1
    op->op_flags |= (OPf_KNOW | OPf_LIST);
d904 10
a913 2
	list(cLISTOP->op_first);
	/* FALL THROUGH */
d924 4
a981 1
    char mtype;
d987 3
d1006 4
d1025 3
a1027 4
	sprintf(tokenbuf, "Can't modify %s in %s",
	    op_desc[op->op_type],
	    type ? op_desc[type] : "local");
	yyerror(tokenbuf);
d1062 2
d1070 2
d1085 1
a1085 1
	    croak("Can't localize a reference");
a1087 1
    case OP_UNDEF:
d1098 4
d1113 4
a1117 2
	mtype = '.';
	goto makelv;
a1118 2
	mtype = 'v';
	goto makelv;
a1119 2
	mtype = 'x';
      makelv:
d1122 1
a1122 4
	sv = PAD_SV(op->op_targ);
	sv_upgrade(sv, SVt_PVLV);
	sv_magic(sv, Nullsv, mtype, Nullch, 0);
	curpad[op->op_targ] = sv;
d1130 3
d1169 46
d1258 4
a1261 2
	if (type == OP_RV2AV || type == OP_RV2HV) {
	    op->op_private |= (type == OP_RV2AV ? OPpDEREF_AV : OPpDEREF_HV);
d1288 4
a1291 2
	if (type == OP_RV2AV || type == OP_RV2HV) {
	    op->op_private |= (type == OP_RV2AV ? OPpDEREF_AV : OPpDEREF_HV);
d1331 1
a1331 2
	sprintf(tokenbuf, "Can't declare %s in my", op_desc[op->op_type]);
	yyerror(tokenbuf);
d1356 14
d1404 1
a1404 1
	if (o->op_flags & OPf_PARENS || perldb || tainting) {
d1428 2
a1429 1
block_start()
d1432 9
a1440 3
    comppad_name_fill = AvFILL(comppad_name);
    SAVEINT(min_intro_pending);
    SAVEINT(max_intro_pending);
d1442 2
a1443 2
    SAVEINT(comppad_name_fill);
    SAVEINT(padix_floor);
d1446 1
a1446 1
    SAVEINT(hints);
d1452 2
a1453 3
block_end(line, floor, seq)
int line;
int floor;
a1457 2
    if (copline > (line_t)line)
	copline = line;
d1463 1
d1472 1
a1472 1
	eval_root = newUNOP(OP_LEAVEEVAL, 0, op);
d1478 1
a1478 2
	if (!op) {
	    main_start = 0;
a1479 1
	}
a1484 1
	main_cv = compcv;
d1486 12
d1556 10
d1592 1
a1592 1
	return newGVOP(OP_GV, 0, sv);
d1600 2
a1610 2
	int vars = 0;

d1616 1
a1616 3
		if (SvIOK(((SVOP*)curop)->op_sv)) {
		    if (SvIVX(((SVOP*)curop)->op_sv) <= 0 && vars++)
			return o;	/* negatives truncate wrong way, alas */
a1617 1
		}
a1621 12
	    if (curop->op_type == OP_PADSV || curop->op_type == OP_RV2SV) {
		if (vars++)
		    return o;
		if (((o->op_type == OP_LT || o->op_type == OP_GE) &&
			curop == ((BINOP*)o)->op_first ) ||
		    ((o->op_type == OP_GT || o->op_type == OP_LE) &&
			curop == ((BINOP*)o)->op_last ))
		{
		    /* Allow "$i < 100" and variants to integerize */
		    continue;
		}
	    }
d1670 1
a1670 1
	op->op_flags &= ~(OPf_KNOW|OPf_LIST);
d2000 3
d2024 1
d2204 1
a2204 1
	curstash = gv_stashpv(name,TRUE);
d2217 1
a2217 1
utilize(aver, floor, id, arg)
d2220 1
d2228 1
d2233 27
d2263 3
a2268 1

d2288 3
a2290 1
	    newSTATEOP(0, Nullch, rqop),
d2438 1
a2438 1
			right->op_flags &= ~(OPf_KNOW|OPf_LIST);
d2482 1
a2484 15
    /* Introduce my variables. */
    if (min_intro_pending) {
	SV **svp = AvARRAY(comppad_name);
	I32 i;
	SV *sv;
	for (i = min_intro_pending; i <= max_intro_pending; i++) {
	    if ((sv = svp[i]) && sv != &sv_undef && !SvIVX(sv)) {
		SvIVX(sv) = 999999999;	/* Don't know scope end yet. */
		SvNVX(sv) = (double)cop_seqmax;
	    }
	}
	min_intro_pending = 0;
	comppad_name_fill = max_intro_pending;	/* Needn't search higher */
    }

d2486 1
a2486 1
    if (perldb && curcop->cop_line && curstash != debstash) {
d2496 3
d2505 1
a2505 1
    cop->cop_seq = cop_seqmax++;
d2514 1
a2514 1
    cop->cop_filegv = SvREFCNT_inc(curcop->cop_filegv);
d2517 1
a2517 1
    if (perldb && curstash != debstash) {
d2529 23
d2599 30
d2657 1
a2657 1
newCONDOP(flags, first, true, false)
d2660 2
a2661 2
OP* true;
OP* false;
d2666 4
a2669 4
    if (!false)
	return newLOGOP(OP_AND, 0, first, true);
    if (!true)
	return newLOGOP(OP_OR, 0, first, false);
d2675 2
a2676 2
	    op_free(false);
	    return true;
d2680 2
a2681 2
	    op_free(true);
	    return false;
d2685 2
a2686 2
	list(true);
	scalar(false);
d2694 2
a2695 2
    condop->op_true = LINKLIST(true);
    condop->op_false = LINKLIST(false);
d2702 2
a2703 2
    first->op_sibling = true;
    true->op_sibling = false;
d2706 2
a2707 2
    true->op_next = op;
    false->op_next = op;
d2774 5
a2778 2
	else if (expr->op_type == OP_READLINE || expr->op_type == OP_GLOB)
	    expr = newASSIGNOP(0, newSVREF(newGVOP(OP_GV, 0, defgv)), 0, expr);
d2799 1
a2799 1
newWHILEOP(flags, debuggable, loop, expr, block, cont)
d2803 1
d2814 2
a2815 1
    if (expr && (expr->op_type == OP_READLINE || expr->op_type == OP_GLOB)) {
d2825 1
a2825 1
    if (expr)
d2827 6
d2890 1
a2893 1
    copline = forline;
d2910 1
a2910 1
    if (expr->op_type == OP_RV2AV) {
d2920 3
a2922 2
    return newSTATEOP(0, label, newWHILEOP(flags, 1, loop,
	newOP(OP_ITER, 0), block, cont));
d2964 2
d2971 17
a2987 5
	I32 i = AvFILL(CvPADLIST(cv));
	while (i >= 0) {
	    SV** svp = av_fetch(CvPADLIST(cv), i--, FALSE);
	    if (svp)
		SvREFCNT_dec(*svp);
a2988 1
	SvREFCNT_dec((SV*)CvPADLIST(cv));
d2993 48
a3040 2
CV *
cv_clone(proto)
d3042 1
d3049 4
a3052 1
    SV** svp = AvARRAY(protopad);
d3056 2
d3061 1
d3065 1
a3065 1
    sv_upgrade((SV *)cv, SVt_PVCV);
d3067 2
d3071 1
a3071 1
    CvGV(cv)		= SvREFCNT_inc(CvGV(proto));
d3075 9
a3083 2
    if (CvOUTSIDE(proto))
	CvOUTSIDE(cv)	= (CV*)SvREFCNT_inc((SV*)CvOUTSIDE(proto));
d3089 1
a3089 1
    av_store(comppadlist, 0, SvREFCNT_inc((SV*)protopad_name));
d3092 1
a3092 1
    av_extend(comppad, AvFILL(protopad));
d3100 10
a3109 9
    svp = AvARRAY(protopad_name);
    for ( ix = AvFILL(protopad); ix > 0; ix--) {
	SV *sv;
	if (svp[ix] != &sv_undef) {
	    char *name = SvPVX(svp[ix]);    /* XXX */
	    if (SvFLAGS(svp[ix]) & SVf_FAKE) {	/* lexical from outside? */
		I32 off = pad_findlex(name,ix,curcop->cop_seq, CvOUTSIDE(proto),
					cxstack_ix);
		if (off != ix)
d3113 7
a3119 2
		if (*name == '@@')
		    av_store(comppad, ix, sv = (SV*)newAV());
d3121 1
a3121 1
		    av_store(comppad, ix, sv = (SV*)newHV());
d3123 4
a3126 2
		    av_store(comppad, ix, sv = NEWSV(0,0));
		SvPADMY_on(sv);
d3130 1
a3130 1
	    av_store(comppad, ix, sv = NEWSV(0,0));
d3132 19
d3154 9
d3168 69
d3243 3
a3246 4
    char *name = op ? SvPVx(cSVOP->op_sv, na) : "__ANON__";
    GV* gv = gv_fetchpv(name, GV_ADDMULTI, SVt_PVCV);
    AV* av;
    char *s;
d3250 21
a3270 6
	sub_generation++;
    if (cv = GvCV(gv)) {
	if (GvCVGEN(gv))
	    cv = 0;			/* just a cached method */
	else if (CvROOT(cv) || CvXSUB(cv) || GvASSUMECV(gv)) {
	    if (dowarn) {		/* already defined (or promised)? */
a3271 1

d3273 2
a3274 1
		warn("Subroutine %s redefined",name);
d3278 1
a3278 1
	    cv = 0;
d3283 1
d3294 5
d3300 1
a3300 2
    GvCV(gv) = cv;
    GvCVGEN(gv) = 0;
a3301 1
    CvGV(cv) = SvREFCNT_inc(gv);
d3304 2
a3305 7
    if (proto) {
	char *p = SvPVx(((SVOP*)proto)->op_sv, na);
	if (SvPOK(cv) && strNE(SvPV((SV*)cv,na), p))
	    warn("Prototype mismatch: (%s) vs (%s)", SvPV((SV*)cv, na), p);
	sv_setpv((SV*)cv, p);
	op_free(proto);
    }
d3310 15
a3326 2
	CvROOT(cv) = 0;
	op_free(op);
d3332 7
a3338 4
    av = newAV();			/* Will be @@_ */
    av_extend(av, 0);
    av_store(comppad, 0, (SV*)av);
    AvFLAGS(av) = AVf_REIFY;
d3340 16
a3355 3
    for (ix = AvFILL(comppad); ix > 0; ix--) {
	if (!SvPADMY(curpad[ix]))
	    SvPADTMP_on(curpad[ix]);
d3357 5
d3363 7
a3369 2
    if (AvFILL(comppad_name) < AvFILL(comppad))
	av_store(comppad_name, AvFILL(comppad), Nullsv);
a3374 7
    if (s = strrchr(name,':'))
	s++;
    else
	s = name;
    if (strEQ(s, "BEGIN") && !error_count) {
	line_t oldline = compiling.cop_line;
	SV *oldrs = rs;
d3376 59
a3434 15
	ENTER;
	SAVESPTR(compiling.cop_filegv);
	SAVEI32(perldb);
	if (!beginav)
	    beginav = newAV();
	av_push(beginav, (SV *)cv);
	DEBUG_x( dump_sub(gv) );
	rs = SvREFCNT_inc(nrs);
	GvCV(gv) = 0;
	calllist(beginav);
	SvREFCNT_dec(rs);
	rs = oldrs;
	curcop = &compiling;
	curcop->cop_line = oldline;	/* might have recursed to yylex */
	LEAVE;
d3436 2
a3437 19
    else if (strEQ(s, "END") && !error_count) {
	if (!endav)
	    endav = newAV();
	av_unshift(endav, 1);
	av_store(endav, 0, SvREFCNT_inc(cv));
    }
    if (perldb && curstash != debstash) {
	SV *sv;
	SV *tmpstr = sv_newmortal();

	sprintf(buf,"%s:%ld",SvPVX(GvSV(curcop->cop_filegv)), (long)subline);
	sv = newSVpv(buf,0);
	sv_catpv(sv,"-");
	sprintf(buf,"%ld",(long)curcop->cop_line);
	sv_catpv(sv,buf);
	gv_efullname(tmpstr,gv);
	hv_store(GvHV(DBsub), SvPVX(tmpstr), SvCUR(tmpstr), sv, 0);
    }
    op_free(op);
a3439 4
    if (!op) {
	GvCV(gv) = 0;	/* Will remember in SVOP instead. */
	CvANON_on(cv);
    }
d3464 1
a3465 2
    GV *gv = gv_fetchpv((name ? name : "__ANON__"), GV_ADDMULTI, SVt_PVCV);
    char *s;
d3467 8
a3474 6
    if (name)
	sub_generation++;
    if (cv = GvCV(gv)) {
	if (GvCVGEN(gv))
	    cv = 0;			/* just a cached method */
	else if (CvROOT(cv) || CvXSUB(cv)) {	/* already defined? */
a3476 1

d3485 3
a3487 4
    if (cv) {				/* must reuse cv if autoloaded */
	assert(SvREFCNT(CvGV(cv)) > 1);
	SvREFCNT_dec(CvGV(cv));
    }
d3491 5
d3497 1
a3497 3
    GvCV(gv) = cv;
    CvGV(cv) = SvREFCNT_inc(gv);
    GvCVGEN(gv) = 0;
d3500 21
a3520 4
    if (!name)
	s = "__ANON__";
    else if (s = strrchr(name,':'))
	s++;
a3521 14
	s = name;
    if (strEQ(s, "BEGIN")) {
	if (!beginav)
	    beginav = newAV();
	av_push(beginav, SvREFCNT_inc(gv));
    }
    else if (strEQ(s, "END")) {
	if (!endav)
	    endav = newAV();
	av_unshift(endav, 1);
	av_store(endav, 0, SvREFCNT_inc(gv));
    }
    if (!name) {
	GvCV(gv) = 0;	/* Will remember elsewhere instead. */
d3523 1
a3523 1
    }
d3556 1
a3556 1
    CvGV(cv) = SvREFCNT_inc(gv);
d3560 1
a3560 1
	if (!SvPADMY(curpad[ix]))
a3567 1
    FmLINES(cv) = 0;
d3713 29
d3757 2
a3758 1
	op = modkids(ck_fun(op), op->op_type);
d3781 1
d3784 5
a3788 2
	if (kid->op_type != OP_HELEM)
	    croak("%s argument is not a HASH element", op_desc[op->op_type]);
d3804 1
a3804 1
		newGVOP(OP_GV, 0, gv_fetchpv("main'ARGV", TRUE, SVt_PVAV)));
d3870 14
d3901 23
a3923 2
	int iscv = (op->op_type==OP_RV2CV)*2;
	GV *gv = 0;
d3925 1
d3935 1
a3935 1
	    gv = gv_fetchpv(SvPVx(kid->op_sv, na),
a3953 7
ck_formline(op)
OP *op;
{
    return ck_fun(op);
}

OP *
d3975 1
a3975 1
	    return newGVOP(type, OPf_REF, gv_fetchpv("main'STDIN", TRUE,
d4035 2
a4036 2
			warn("Array @@%s missing the @@ in argument %d of %s()",
			    name, numargs, op_desc[type]);
d4053 2
a4054 2
			warn("Hash %%%s missing the %% in argument %d of %s()",
			    name, numargs, op_desc[type]);
d4125 26
a4150 1
    GV *gv = newGVgen("main");
d4216 1
a4216 1
	    fbm_compile(((SVOP*)kid)->op_sv, 0);
d4233 2
a4234 1
    return modkids(ck_fun(op), op->op_type);
d4241 2
a4242 1
    return refkids(ck_fun(op), op->op_type);
d4273 37
a4309 1
    return listkids(op);
d4316 1
a4316 2
    cPMOP->op_pmflags |= PMf_RUNTIME;
    cPMOP->op_pmpermflags |= PMf_RUNTIME;
d4402 3
a4404 2
		scalar(newGVOP(OP_GV, 0,
		    gv_fetchpv((subline ? "_" : "ARGV"), TRUE, SVt_PVAV) )))));
d4413 6
d4455 1
d4527 1
d4538 5
a4542 3
	    cv = GvCV(tmpop->op_sv);
	    if (cv && SvPOK(cv) && !(op->op_private & OPpENTERSUB_AMPER))
		proto = SvPV((SV*)cv,na);
d4546 1
a4546 1
    if (perldb && curstash != debstash)
d4552 1
a4552 1
		return too_many_arguments(op, CvNAME(cv));
d4571 1
a4571 1
		    bad_type(arg, "block", CvNAME(cv), o);
d4592 1
a4592 1
			bad_type(arg, "symbol", CvNAME(cv), o);
d4596 1
a4596 1
			bad_type(arg, "sub", CvNAME(cv), o);
d4600 1
a4600 1
			bad_type(arg, "scalar", CvNAME(cv), o);
d4604 1
a4604 1
			bad_type(arg, "array", CvNAME(cv), o);
d4608 1
a4608 1
			bad_type(arg, "hash", CvNAME(cv), o);
d4621 3
d4627 1
a4627 1
			CvNAME(cv),SvPV((SV*)cv,na));
d4636 3
a4638 2
    if (proto && !optional && *proto == '$')
	return too_few_arguments(op, CvNAME(cv));
d4704 1
a4704 1
	    if ((o->op_flags & (OPf_KNOW|OPf_LIST)) != (OPf_KNOW|OPf_LIST)) {
d4706 1
a4706 1
		break;	/* Scalar stub must produce undef.  List stub is noop */
d4726 1
a4726 1
		if (!(o->op_next->op_private & (OPpDEREF_HV|OPpDEREF_AV))) {
d4741 1
a4741 1
			(OPpDEREF_HV|OPpDEREF_AV|OPpLVAL_INTRO)) &&
d4755 1
a4755 1
		    GvAVn((GV*)(((SVOP*)o)->op_sv));
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
d21 1
a21 5
#ifdef PERL_OBJECT
#define CHECKCALL this->*check
#else
#define CHECKCALL *check
#endif
d23 1
d25 1
a25 1
 * In the following definition, the ", Nullop" is just to make the compiler
d28 18
a45 24
#define CHECKOP(type,o) \
    ((PL_op_mask && PL_op_mask[type])					\
     ? ( op_free((OP*)o),					\
	 croak("%s trapped by operation mask", op_desc[type]),	\
	 Nullop )						\
     : (CHECKCALL[type])((OP*)o))

#define PAD_MAX 999999999

static bool scalar_mod_type _((OP *o, I32 type));
#ifndef PERL_OBJECT
static I32 list_assignment _((OP *o));
static void bad_type _((I32 n, char *t, char *name, OP *kid));
static OP *modkids _((OP *o, I32 type));
static OP *no_fh_allowed _((OP *o));
static OP *scalarboolean _((OP *o));
static OP *too_few_arguments _((OP *o, char* name));
static OP *too_many_arguments _((OP *o, char* name));
static void null _((OP* o));
static PADOFFSET pad_findlex _((char* name, PADOFFSET newoff, U32 seq,
	CV* startcv, I32 cx_ix, I32 saweval, U32 flags));
static OP *newDEFSVOP _((void));
static OP *new_logop _((I32 type, I32 flags, OP **firstp, OP **otherp));
#endif
d47 3
a49 2
STATIC char*
gv_ename(GV *gv)
d52 2
a53 3
    STRLEN n_a;
    gv_efullname3(tmpsv, gv, Nullch);
    return SvPV(tmpsv,n_a);
d56 3
a58 2
STATIC OP *
no_fh_allowed(OP *o)
d60 4
a63 3
    yyerror(form("Missing comma after first argument to %s function",
		 op_desc[o->op_type]));
    return o;
d66 4
a69 2
STATIC OP *
too_few_arguments(OP *o, char *name)
d71 3
a73 2
    yyerror(form("Not enough arguments for %s", name));
    return o;
d76 4
a79 2
STATIC OP *
too_many_arguments(OP *o, char *name)
d81 3
a83 2
    yyerror(form("Too many arguments for %s", name));
    return o;
d86 6
a91 2
STATIC void
bad_type(I32 n, char *t, char *name, OP *kid)
d93 4
a96 2
    yyerror(form("Type of arg %d to %s must be %s (not %s)",
		 (int)n, name, t, op_desc[kid->op_type]));
d100 2
a101 1
assertref(OP *o)
d103 7
a109 15
    int type = o->op_type;
    if (type != OP_AELEM && type != OP_HELEM && type != OP_GELEM) {
	yyerror(form("Can't use subscript on %s", op_desc[type]));
	if (type == OP_ENTERSUB || type == OP_RV2HV || type == OP_PADHV) {
	    dTHR;
	    SV *msg = sv_2mortal(
			newSVpvf("(Did you mean $ or @@ instead of %c?)\n",
				 type == OP_ENTERSUB ? '&' : '%'));
	    if (PL_in_eval & 2)
		warn("%_", msg);
	    else if (PL_in_eval)
		sv_catsv(GvSV(PL_errgv), msg);
	    else
		PerlIO_write(PerlIO_stderr(), SvPVX(msg), SvCUR(msg));
	}
d116 2
a117 1
pad_allocmy(char *name)
a118 1
    dTHR;
d123 2
a124 5
	if (!isPRINT(name[1])) {
	    name[3] = '\0';
	    name[2] = toCTRL(name[1]);
	    name[1] = '^';
	}
a126 14
    if (PL_dowarn && AvFILLp(PL_comppad_name) >= 0) {
	SV **svp = AvARRAY(PL_comppad_name);
	for (off = AvFILLp(PL_comppad_name); off > PL_comppad_name_floor; off--) {
	    if ((sv = svp[off])
		&& sv != &PL_sv_undef
		&& (SvIVX(sv) == PAD_MAX || SvIVX(sv) == 0)
		&& strEQ(name, SvPVX(sv)))
	    {
		warn("\"my\" variable %s masks earlier declaration in same %s",
			name, (SvIVX(sv) == PAD_MAX ? "scope" : "statement"));
		break;
	    }
	}
    }
d131 2
a132 10
    if (PL_in_my_stash) {
	if (*name != '$')
	    croak("Can't declare class for non-scalar %s in \"my\"",name);
	SvOBJECT_on(sv);
	(void)SvUPGRADE(sv, SVt_PVMG);
	SvSTASH(sv) = (HV*)SvREFCNT_inc(PL_in_my_stash);
	PL_sv_objcount++;
    }
    av_store(PL_comppad_name, off, sv);
    SvNVX(sv) = (double)PAD_MAX;
d134 3
a136 3
    if (!PL_min_intro_pending)
	PL_min_intro_pending = off;
    PL_max_intro_pending = off;
d138 1
a138 1
	av_store(PL_comppad, off, (SV*)newAV());
d140 2
a141 2
	av_store(PL_comppad, off, (SV*)newHV());
    SvPADMY_on(PL_curpad[off]);
d145 11
a155 5
#define FINDLEX_NOSEARCH	1		/* don't search outer contexts */

STATIC PADOFFSET
pad_findlex(char *name, PADOFFSET newoff, U32 seq, CV* startcv, I32 cx_ix, I32 saweval,
	    U32 flags)
a156 1
    dTHR;
d161 2
a162 1
    register PERL_CONTEXT *cx;
d165 2
a166 2
	AV *curlist = CvPADLIST(cv);
	SV **svp = av_fetch(curlist, 0, FALSE);
d168 1
a168 2

	if (!svp || *svp == &PL_sv_undef)
d172 1
a172 1
	for (off = AvFILLp(curname); off > 0; off--) {
d174 1
a174 1
		sv != &PL_sv_undef &&
d176 1
a176 1
		seq > I_32(SvNVX(sv)) &&
d179 3
a181 15
		I32 depth;
		AV *oldpad;
		SV *oldsv;

		depth = CvDEPTH(cv);
		if (!depth) {
		    if (newoff) {
			if (SvFAKE(sv))
			    continue;
			return 0; /* don't clone from inactive stack frame */
		    }
		    depth = 1;
		}
		oldpad = (AV*)*av_fetch(curlist, depth, FALSE);
		oldsv = *av_fetch(oldpad, off, TRUE);
d183 1
a183 1
		    SV *namesv = NEWSV(1103,0);
d185 6
a190 44
		    sv_upgrade(namesv, SVt_PVNV);
		    sv_setpv(namesv, name);
		    av_store(PL_comppad_name, newoff, namesv);
		    SvNVX(namesv) = (double)PL_curcop->cop_seq;
		    SvIVX(namesv) = PAD_MAX;	/* A ref, intro immediately */
		    SvFAKE_on(namesv);		/* A ref, not a real var */
		    if (SvOBJECT(svp[off])) {	/* A typed var */
			SvOBJECT_on(namesv);
			(void)SvUPGRADE(namesv, SVt_PVMG);
			SvSTASH(namesv) = (HV*)SvREFCNT_inc((SV*)SvSTASH(svp[off]));
			PL_sv_objcount++;
		    }
		    if (CvANON(PL_compcv) || SvTYPE(PL_compcv) == SVt_PVFM) {
			/* "It's closures all the way down." */
			CvCLONE_on(PL_compcv);
			if (cv == startcv) {
			    if (CvANON(PL_compcv))
				oldsv = Nullsv; /* no need to keep ref */
			}
			else {
			    CV *bcv;
			    for (bcv = startcv;
				 bcv && bcv != cv && !CvCLONE(bcv);
				 bcv = CvOUTSIDE(bcv))
			    {
				if (CvANON(bcv))
				    CvCLONE_on(bcv);
				else {
				    if (PL_dowarn
					&& !CvUNIQUE(bcv) && !CvUNIQUE(cv))
				    {
					warn(
					  "Variable \"%s\" may be unavailable",
					     name);
				    }
				    break;
				}
			    }
			}
		    }
		    else if (!CvUNIQUE(PL_compcv)) {
			if (PL_dowarn && !SvFAKE(sv) && !CvUNIQUE(cv))
			    warn("Variable \"%s\" will not stay shared", name);
		    }
d192 2
a193 1
		av_store(PL_comppad, newoff, SvREFCNT_inc(oldsv));
a198 3
    if (flags & FINDLEX_NOSEARCH)
	return 0;

d204 1
d207 1
a207 1
	switch (CxTYPE(cx)) {
d211 1
a211 1
		return pad_findlex(name, newoff, seq, PL_main_cv, -1, saweval, 0);
d215 4
a218 9
	    switch (cx->blk_eval.old_op_type) {
	    case OP_ENTEREVAL:
		if (CxREALEVAL(cx))
		    saweval = i;
		break;
	    case OP_REQUIRE:
		/* require must have its own scope */
		return 0;
	    }
d224 1
a224 1
	    if (PL_debstash && CvSTASH(cv) == PL_debstash) {	/* ignore DB'* scope */
d229 1
a229 1
	    return pad_findlex(name, newoff, seq, cv, i-1, saweval,FINDLEX_NOSEARCH);
d237 2
a238 1
pad_findmy(char *name)
a239 1
    dTHR;
a240 1
    I32 pendoff = 0;
d242 2
a243 17
    SV **svp = AvARRAY(PL_comppad_name);
    U32 seq = PL_cop_seqmax;
    PERL_CONTEXT *cx;
    CV *outside;

#ifdef USE_THREADS
    /*
     * Special case to get lexical (and hence per-thread) @@_.
     * XXX I need to find out how to tell at parse-time whether use
     * of @@_ should refer to a lexical (from a sub) or defgv (global
     * scope and maybe weird sub-ish things like formats). See
     * startsub in perly.y.  It's possible that @@_ could be lexical
     * (at least from subs) even in non-threaded perl.
     */
    if (strEQ(name, "@@_"))
	return 0;		/* success. (NOT_IN_PAD indicates failure) */
#endif /* USE_THREADS */
d246 1
a246 1
    for (off = AvFILLp(PL_comppad_name); off > 0; off--) {
d248 3
a250 4
	    sv != &PL_sv_undef &&
	    (!SvIVX(sv) ||
	     (seq <= SvIVX(sv) &&
	      seq > I_32(SvNVX(sv)))) &&
d253 1
a253 3
	    if (SvIVX(sv))
		return (PADOFFSET)off;
	    pendoff = off;	/* this pending def. will override import */
d257 4
a260 11
    outside = CvOUTSIDE(PL_compcv);

    /* Check if if we're compiling an eval'', and adjust seq to be the
     * eval's seq number.  This depends on eval'' having a non-null
     * CvOUTSIDE() while it is being compiled.  The eval'' itself is
     * identified by CvEVAL being true and CvGV being null. */
    if (outside && CvEVAL(PL_compcv) && !CvGV(PL_compcv) && cxstack_ix >= 0) {
	cx = &cxstack[cxstack_ix];
	if (CxREALEVAL(cx))
	    seq = cx->blk_oldcop->cop_seq;
    }
d262 1
a262 9
    /* See if it's in a nested scope */
    off = pad_findlex(name, 0, seq, outside, cxstack_ix, 0, 0);
    if (off) {
	/* If there is a pending local definition, this new alias must die */
	if (pendoff)
	    SvIVX(AvARRAY(PL_comppad_name)[off]) = seq;
	return off;		/* pad_findlex returns 0 for failure...*/
    }
    return NOT_IN_PAD;		/* ...but we return NOT_IN_PAD for failure */
d266 2
a267 1
pad_leavemy(I32 fill)
d270 1
a270 1
    SV **svp = AvARRAY(PL_comppad_name);
d272 3
a274 3
    if (PL_min_intro_pending && fill < PL_min_intro_pending) {
	for (off = PL_max_intro_pending; off >= PL_min_intro_pending; off--) {
	    if ((sv = svp[off]) && sv != &PL_sv_undef)
d279 3
a281 3
    for (off = AvFILLp(PL_comppad_name); off > fill; off--) {
	if ((sv = svp[off]) && sv != &PL_sv_undef && SvIVX(sv) == PAD_MAX)
	    SvIVX(sv) = PL_cop_seqmax;
d286 3
a288 1
pad_alloc(I32 optype, U32 tmptype)
a289 1
    dTHR;
d293 1
a293 1
    if (AvARRAY(PL_comppad) != PL_curpad)
d295 1
a295 1
    if (PL_pad_reset_pending)
d299 1
a299 1
	    sv = *av_fetch(PL_comppad, AvFILLp(PL_comppad) + 1, TRUE);
d301 1
a301 1
	retval = AvFILLp(PL_comppad);
d304 4
a307 16
	SV **names = AvARRAY(PL_comppad_name);
	SSize_t names_fill = AvFILLp(PL_comppad_name);
	for (;;) {
	    /*
	     * "foreach" index vars temporarily become aliases to non-"my"
	     * values.  Thus we must skip, not just pad values that are
	     * marked as current pad values, but also those with names.
	     */
	    if (++PL_padix <= names_fill &&
		   (sv = names[PL_padix]) && sv != &PL_sv_undef)
		continue;
	    sv = *av_fetch(PL_comppad, PL_padix, TRUE);
	    if (!(SvFLAGS(sv) & (SVs_PADTMP|SVs_PADMY)))
		break;
	}
	retval = PL_padix;
d310 2
a311 10
    PL_curpad = AvARRAY(PL_comppad);
#ifdef USE_THREADS
    DEBUG_X(PerlIO_printf(Perl_debug_log, "0x%lx Pad 0x%lx alloc %ld for %s\n",
			  (unsigned long) thr, (unsigned long) PL_curpad,
			  (long) retval, op_name[optype]));
#else
    DEBUG_X(PerlIO_printf(Perl_debug_log, "Pad 0x%lx alloc %ld for %s\n",
			  (unsigned long) PL_curpad,
			  (long) retval, op_name[optype]));
#endif /* USE_THREADS */
d316 4
d321 1
a322 5
    dTHR;
#ifdef USE_THREADS
    DEBUG_X(PerlIO_printf(Perl_debug_log, "0x%lx Pad 0x%lx sv %d\n",
			  (unsigned long) thr, (unsigned long) PL_curpad, po));
#else
d325 2
a326 4
    DEBUG_X(PerlIO_printf(Perl_debug_log, "Pad 0x%lx sv %d\n",
			  (unsigned long) PL_curpad, po));
#endif /* USE_THREADS */
    return PL_curpad[po];		/* eventually we'll turn this into a macro */
d330 4
d335 1
d337 1
a337 2
    dTHR;
    if (!PL_curpad)
d339 1
a339 1
    if (AvARRAY(PL_comppad) != PL_curpad)
d343 5
a347 11
#ifdef USE_THREADS
    DEBUG_X(PerlIO_printf(Perl_debug_log, "0x%lx Pad 0x%lx free %d\n",
			  (unsigned long) thr, (unsigned long) PL_curpad, po));
#else
    DEBUG_X(PerlIO_printf(Perl_debug_log, "Pad 0x%lx free %d\n",
			  (unsigned long) PL_curpad, po));
#endif /* USE_THREADS */
    if (PL_curpad[po] && PL_curpad[po] != &PL_sv_undef)
	SvPADTMP_off(PL_curpad[po]);
    if ((I32)po < PL_padix)
	PL_padix = po - 1;
d351 4
d356 1
d358 1
a358 2
    dTHR;
    if (AvARRAY(PL_comppad) != PL_curpad)
d362 8
a369 20
#ifdef USE_THREADS
    DEBUG_X(PerlIO_printf(Perl_debug_log, "0x%lx Pad 0x%lx swipe %d\n",
			  (unsigned long) thr, (unsigned long) PL_curpad, po));
#else
    DEBUG_X(PerlIO_printf(Perl_debug_log, "Pad 0x%lx swipe %d\n",
			  (unsigned long) PL_curpad, po));
#endif /* USE_THREADS */
    SvPADTMP_off(PL_curpad[po]);
    PL_curpad[po] = NEWSV(1107,0);
    SvPADTMP_on(PL_curpad[po]);
    if ((I32)po < PL_padix)
	PL_padix = po - 1;
}

/* XXX pad_reset() is currently disabled because it results in serious bugs.
 * It causes pad temp TARGs to be shared between OPs. Since TARGs are pushed
 * on the stack by OPs that use them, there are several ways to get an alias
 * to  a shared TARG.  Such an alias will change randomly and unpredictably.
 * We avoid doing this until we can think of a Better Way.
 * GSAR 97-10-29 */
d371 1
a371 1
pad_reset(void)
a372 2
#ifdef USE_BROKEN_PAD_RESET
    dTHR;
d375 1
a375 1
    if (AvARRAY(PL_comppad) != PL_curpad)
d377 5
a381 76
#ifdef USE_THREADS
    DEBUG_X(PerlIO_printf(Perl_debug_log, "0x%lx Pad 0x%lx reset\n",
			  (unsigned long) thr, (unsigned long) PL_curpad));
#else
    DEBUG_X(PerlIO_printf(Perl_debug_log, "Pad 0x%lx reset\n",
			  (unsigned long) PL_curpad));
#endif /* USE_THREADS */
    if (!PL_tainting) {	/* Can't mix tainted and non-tainted temporaries. */
	for (po = AvMAX(PL_comppad); po > PL_padix_floor; po--) {
	    if (PL_curpad[po] && !SvIMMORTAL(PL_curpad[po]))
		SvPADTMP_off(PL_curpad[po]);
	}
	PL_padix = PL_padix_floor;
    }
#endif
    PL_pad_reset_pending = FALSE;
}

#ifdef USE_THREADS
/* find_threadsv is not reentrant */
PADOFFSET
find_threadsv(char *name)
{
    dTHR;
    char *p;
    PADOFFSET key;
    SV **svp;
    /* We currently only handle names of a single character */
    p = strchr(PL_threadsv_names, *name);
    if (!p)
	return NOT_IN_PAD;
    key = p - PL_threadsv_names;
    MUTEX_LOCK(&thr->mutex);
    svp = av_fetch(thr->threadsv, key, FALSE);
    if (svp)
	MUTEX_UNLOCK(&thr->mutex);
    else {
	SV *sv = NEWSV(0, 0);
	av_store(thr->threadsv, key, sv);
	thr->threadsvp = AvARRAY(thr->threadsv);
	MUTEX_UNLOCK(&thr->mutex);
	/*
	 * Some magic variables used to be automagically initialised
	 * in gv_fetchpv. Those which are now per-thread magicals get
	 * initialised here instead.
	 */
	switch (*name) {
	case '_':
	    break;
	case ';':
	    sv_setpv(sv, "\034");
	    sv_magic(sv, 0, 0, name, 1); 
	    break;
	case '&':
	case '`':
	case '\'':
	    PL_sawampersand = TRUE;
	    /* FALL THROUGH */
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	    SvREADONLY_on(sv);
	    /* FALL THROUGH */

	/* XXX %! tied to Errno.pm needs to be added here.
	 * See gv_fetchpv(). */
	/* case '!': */

	default:
	    sv_magic(sv, 0, 0, name, 1); 
d383 1
a383 4
	DEBUG_S(PerlIO_printf(PerlIO_stderr(),
			      "find_threadsv: new SV %p for $%s%c\n",
			      sv, (*name < 32) ? "^" : "",
			      (*name < 32) ? toCTRL(*name) : *name));
d385 1
a385 1
    return key;
a386 1
#endif /* USE_THREADS */
d391 2
a392 1
op_free(OP *o)
d396 1
a396 1
    if (!o || o->op_seq == (U16)-1)
d399 2
a400 2
    if (o->op_flags & OPf_KIDS) {
	for (kid = cUNOPo->op_first; kid; kid = nextkid) {
d406 1
a406 1
    switch (o->op_type) {
d408 1
a408 1
	o->op_targ = 0;	/* Was holding old type, if any. */
d411 1
a411 9
	o->op_targ = 0;	/* Was holding hints. */
	break;
#ifdef USE_THREADS
    case OP_ENTERITER:
	if (!(o->op_flags & OPf_SPECIAL))
	    break;
	/* FALL THROUGH */
    case OP_THREADSV:
	o->op_targ = 0;	/* Was holding index into thr->threadsv AV. */
a412 6
#endif /* USE_THREADS */
    default:
	if (!(o->op_flags & OPf_REF)
	    || (check[o->op_type] != FUNC_NAME_TO_PTR(ck_ftst)))
	    break;
	/* FALL THROUGH */
d415 1
a415 2
    case OP_AELEMFAST:
	SvREFCNT_dec(cGVOPo->op_gv);
d419 1
a419 2
	Safefree(cCOPo->cop_label);
	SvREFCNT_dec(cCOPo->cop_filegv);
d422 1
a422 1
	SvREFCNT_dec(cSVOPo->op_sv);
d428 1
a428 1
	if (o->op_flags & (OPf_SPECIAL|OPf_STACKED|OPf_KIDS))
d432 1
a432 1
	Safefree(cPVOPo->op_pv);
d435 1
a435 1
	op_free(cPMOPo->op_pmreplroot);
d439 4
a442 2
    case OP_QR:
	ReREFCNT_dec(cPMOPo->op_pmregexp);
d446 2
a447 2
    if (o->op_targ > 0)
	pad_free(o->op_targ);
d449 1
a449 1
    Safefree(o);
d452 3
a454 2
STATIC void
null(OP *o)
d456 5
a460 5
    if (o->op_type != OP_NULL && o->op_type != OP_THREADSV && o->op_targ > 0)
	pad_free(o->op_targ);
    o->op_targ = o->op_type;
    o->op_type = OP_NULL;
    o->op_ppaddr = ppaddr[OP_NULL];
d468 2
a469 1
linklist(OP *o)
d473 2
a474 2
    if (o->op_next)
	return o->op_next;
d477 3
a479 3
    if (cUNOPo->op_first) {
	o->op_next = LINKLIST(cUNOPo->op_first);
	for (kid = cUNOPo->op_first; kid; kid = kid->op_sibling) {
d483 1
a483 1
		kid->op_next = o;
d487 1
a487 1
	o->op_next = o;
d489 1
a489 1
    return o->op_next;
d493 2
a494 1
scalarkids(OP *o)
d497 2
a498 2
    if (o && o->op_flags & OPf_KIDS) {
	for (kid = cLISTOPo->op_first; kid; kid = kid->op_sibling)
d501 1
a501 1
    return o;
d504 3
a506 2
STATIC OP *
scalarboolean(OP *o)
d508 3
a510 4
    if (PL_dowarn &&
	o->op_type == OP_SASSIGN && cBINOPo->op_first->op_type == OP_CONST) {
	dTHR;
	line_t oldline = PL_curcop->cop_line;
d512 2
a513 2
	if (PL_copline != NOLINE)
	    PL_curcop->cop_line = PL_copline;
d515 1
a515 1
	PL_curcop->cop_line = oldline;
d517 1
a517 1
    return scalar(o);
d521 2
a522 1
scalar(OP *o)
d527 2
a528 3
    if (!o || (o->op_flags & OPf_WANT) || PL_error_count
	 || o->op_type == OP_RETURN)
	return o;
d530 2
a531 1
    o->op_flags = (o->op_flags & ~OPf_WANT) | OPf_WANT_SCALAR;
d533 1
a533 1
    switch (o->op_type) {
d535 3
a537 3
	if (o->op_private & OPpREPEAT_DOLIST)
	    null(((LISTOP*)cBINOPo->op_first)->op_first);
	scalar(cBINOPo->op_first);
d542 1
a542 1
	for (kid = cUNOPo->op_first->op_sibling; kid; kid = kid->op_sibling)
d546 1
a546 1
	if ((kid = cLISTOPo->op_first) && kid->op_type == OP_PUSHRE) {
a551 1
    case OP_QR:
d555 2
a556 2
	if (o->op_flags & OPf_KIDS) {
	    for (kid = cUNOPo->op_first; kid; kid = kid->op_sibling)
d562 2
a563 10
	kid = cLISTOPo->op_first;
	scalar(kid);
	while (kid = kid->op_sibling) {
	    if (kid->op_sibling)
		scalarvoid(kid);
	    else
		scalar(kid);
	}
	WITH_THR(PL_curcop = &PL_compiling);
	break;
d567 1
a567 1
	for (kid = cLISTOPo->op_first; kid; kid = kid->op_sibling) {
d573 1
a573 1
	WITH_THR(PL_curcop = &PL_compiling);
d576 1
a576 1
    return o;
d580 2
a581 1
scalarvoid(OP *o)
d587 4
a590 5
    /* assumes no premature commitment */
    U8 want = o->op_flags & OPf_WANT;
    if (!o || (want && want != OPf_WANT_SCALAR) || PL_error_count
	 || o->op_type == OP_RETURN)
	return o;
d592 1
a592 1
    o->op_flags = (o->op_flags & ~OPf_WANT) | OPf_WANT_VOID;
d594 1
a594 1
    switch (o->op_type) {
d596 1
a596 5
	if (!(opargs[o->op_type] & OA_FOLDCONST))
	    break;
	/* FALL THROUGH */
    case OP_REPEAT:
	if (o->op_flags & OPf_STACKED)
d598 1
a598 3
	goto func_ops;
    case OP_SUBSTR:
	if (o->op_private == 4)
d616 1
d624 2
d671 2
a672 3
      func_ops:
	if (!(o->op_private & OPpLVAL_INTRO))
	    useless = op_desc[o->op_type];
d679 2
a680 2
	if (!(o->op_private & OPpLVAL_INTRO) &&
		(!o->op_sibling || o->op_sibling->op_type != OP_READLINE))
d686 1
a686 1
	WITH_THR(PL_curcop = ((COP*)o));		/* for warning below */
d690 2
a691 2
	sv = cSVOPo->op_sv;
	if (PL_dowarn) {
d702 1
a702 1
	null(o);		/* don't execute a constant */
d707 2
a708 2
	o->op_type = OP_PREINC;		/* pre-increment is faster */
	o->op_ppaddr = ppaddr[OP_PREINC];
d712 7
a718 2
	o->op_type = OP_PREDEC;		/* pre-decrement is faster */
	o->op_ppaddr = ppaddr[OP_PREDEC];
d724 1
a724 1
	for (kid = cUNOPo->op_first->op_sibling; kid; kid = kid->op_sibling)
a726 1

d728 3
a730 3
	if (o->op_targ == OP_NEXTSTATE || o->op_targ == OP_DBSTATE)
	    WITH_THR(PL_curcop = ((COP*)o));	/* for warning below */
	if (o->op_flags & OPf_STACKED)
a731 1
	/* FALL THROUGH */
d735 1
a735 1
	if (!(o->op_flags & OPf_KIDS))
a736 1
	/* FALL THROUGH */
d741 1
d744 1
a744 1
	for (kid = cLISTOPo->op_first; kid; kid = kid->op_sibling)
a746 7
    case OP_ENTEREVAL:
	scalarkids(o);
	break;
    case OP_REQUIRE:
	/* all requires must return a boolean value */
	o->op_flags &= ~OPf_WANT;
	return scalar(o);
d748 1
a748 1
	if ((kid = cLISTOPo->op_first) && kid->op_type == OP_PUSHRE) {
d753 3
d757 1
a757 1
    if (useless && PL_dowarn)
d759 1
a759 1
    return o;
d763 2
a764 1
listkids(OP *o)
d767 2
a768 2
    if (o && o->op_flags & OPf_KIDS) {
	for (kid = cLISTOPo->op_first; kid; kid = kid->op_sibling)
d771 1
a771 1
    return o;
d775 2
a776 1
list(OP *o)
d781 2
a782 3
    if (!o || (o->op_flags & OPf_WANT) || PL_error_count
	 || o->op_type == OP_RETURN)
	return o;
d784 1
a784 1
    o->op_flags = (o->op_flags & ~OPf_WANT) | OPf_WANT_LIST;
d786 1
a786 1
    switch (o->op_type) {
d789 1
a789 1
	list(cBINOPo->op_first);
d794 1
a794 1
	for (kid = cUNOPo->op_first->op_sibling; kid; kid = kid->op_sibling)
a798 1
    case OP_QR:
d801 1
a801 1
	if (!(o->op_flags & OPf_KIDS))
d803 3
a805 3
	if (!o->op_next && cUNOPo->op_first->op_type == OP_FLOP) {
	    list(cBINOPo->op_first);
	    return gen_constant_list(o);
d808 1
a808 1
	listkids(o);
d812 2
a813 10
	kid = cLISTOPo->op_first;
	list(kid);
	while (kid = kid->op_sibling) {
	    if (kid->op_sibling)
		scalarvoid(kid);
	    else
		list(kid);
	}
	WITH_THR(PL_curcop = &PL_compiling);
	break;
d816 1
a816 1
	for (kid = cLISTOPo->op_first; kid; kid = kid->op_sibling) {
d822 1
a822 1
	WITH_THR(PL_curcop = &PL_compiling);
a823 4
    case OP_REQUIRE:
	/* all requires must return a boolean value */
	o->op_flags &= ~OPf_WANT;
	return scalar(o);
d825 1
a825 1
    return o;
d829 2
a830 1
scalarseq(OP *o)
d834 5
a838 5
    if (o) {
	if (o->op_type == OP_LINESEQ ||
	     o->op_type == OP_SCOPE ||
	     o->op_type == OP_LEAVE ||
	     o->op_type == OP_LEAVETRY)
d840 1
a840 2
	    dTHR;
	    for (kid = cLISTOPo->op_first; kid; kid = kid->op_sibling) {
d845 1
a845 1
	    PL_curcop = &PL_compiling;
d847 3
a849 3
	o->op_flags &= ~OPf_PARENS;
	if (PL_hints & HINT_BLOCK_SCOPE)
	    o->op_flags |= OPf_PARENS;
d852 2
a853 2
	o = newOP(OP_STUB, 0);
    return o;
d856 4
a859 2
STATIC OP *
modkids(OP *o, I32 type)
d862 2
a863 2
    if (o && o->op_flags & OPf_KIDS) {
	for (kid = cLISTOPo->op_first; kid; kid = kid->op_sibling)
d866 1
a866 1
    return o;
d869 2
d872 3
a874 1
mod(OP *o, I32 type)
a875 1
    dTHR;
d878 1
a878 1
    STRLEN n_a;
d880 2
a881 2
    if (!o || PL_error_count)
	return o;
d883 1
a883 4
    switch (o->op_type) {
    case OP_UNDEF:
	PL_modcount++;
	return o;
d885 1
a885 1
	if (!(o->op_private & (OPpCONST_ARYBASE)))
d887 3
a889 3
	if (PL_eval_start && PL_eval_start->op_type == OP_CONST) {
	    PL_compiling.cop_arybase = (I32)SvIV(((SVOP*)PL_eval_start)->op_sv);
	    PL_eval_start = 0;
d892 2
a893 2
	    SAVEI32(PL_compiling.cop_arybase);
	    PL_compiling.cop_arybase = 0;
a899 4
    case OP_STUB:
	if (o->op_flags & OPf_PARENS)
	    break;
	goto nomod;
d902 5
a906 5
	    !(o->op_flags & OPf_STACKED)) {
	    o->op_type = OP_RV2CV;		/* entersub => rv2cv */
	    o->op_ppaddr = ppaddr[OP_RV2CV];
	    assert(cUNOPo->op_first->op_type == OP_NULL);
	    null(((LISTOP*)cUNOPo->op_first)->op_first);/* disable pushmark */
d915 5
a919 4
	yyerror(form("Can't modify %s in %s",
		     op_desc[o->op_type],
		     type ? op_desc[type] : "local"));
	return o;
d941 1
a941 1
	if (!(o->op_flags & OPf_STACKED))
d943 1
a943 1
	PL_modcount++;
d947 1
a947 1
	for (kid = cUNOPo->op_first->op_sibling; kid; kid = kid->op_sibling)
d953 3
a955 5
	if (!type && cUNOPo->op_first->op_type != OP_GV)
	    croak("Can't localize through a reference");
	if (type == OP_REFGEN && o->op_flags & OPf_PARENS) {
	    PL_modcount = 10000;
	    return o;		/* Treat \(@@foo) like ordinary list. */
d959 1
a959 3
	if (scalar_mod_type(o, type))
	    goto nomod;
	ref(cUNOPo->op_first, o->op_type);
d968 1
a968 1
	PL_modcount = 10000;
d971 3
a973 3
	if (!type && cUNOPo->op_first->op_type != OP_GV)
	    croak("Can't localize through a reference");
	ref(cUNOPo->op_first, o->op_type);
d975 1
a977 1
	PL_hints |= HINT_BLOCK_SCOPE;
d980 1
a980 1
	PL_modcount++;
d985 1
a985 5
	PL_modcount = 10000;
	if (type == OP_REFGEN && o->op_flags & OPf_PARENS)
	    return o;		/* Treat \(@@foo) like ordinary list. */
	if (scalar_mod_type(o, type))
	    goto nomod;
d988 1
a988 1
	PL_modcount++;
d991 1
a991 6
		SvPV(*av_fetch(PL_comppad_name, o->op_targ, 4), n_a));
	break;

#ifdef USE_THREADS
    case OP_THREADSV:
	PL_modcount++;	/* XXX ??? */
a992 1
#endif /* USE_THREADS */
a996 8
    case OP_KEYS:
	if (type != OP_SASSIGN)
	    goto nomod;
	goto lvalue_func;
    case OP_SUBSTR:
	if (o->op_private == 4) /* don't allow 4 arg substr as lvalue */
	    goto nomod;
	/* FALL THROUGH */
d998 2
d1001 13
a1013 6
      lvalue_func:
	pad_free(o->op_targ);
	o->op_targ = pad_alloc(o->op_type, SVs_PADMY);
	assert(SvTYPE(PAD_SV(o->op_targ)) == SVt_NULL);
	if (o->op_flags & OPf_KIDS)
	    mod(cBINOPo->op_first->op_sibling, type);
d1018 2
a1019 5
	ref(cBINOPo->op_first, o->op_type);
	if (type == OP_ENTERSUB &&
	     !(o->op_private & (OPpLVAL_INTRO | OPpDEREF)))
	    o->op_private |= OPpLVAL_DEFER;
	PL_modcount++;
d1025 2
a1026 2
	if (o->op_flags & OPf_KIDS)
	    mod(cLISTOPo->op_last, type);
d1030 1
a1030 1
	if (!(o->op_flags & OPf_KIDS))
d1032 2
a1033 2
	if (o->op_targ != OP_LIST) {
	    mod(cBINOPo->op_first, type);
d1038 1
a1038 1
	for (kid = cLISTOPo->op_first; kid; kid = kid->op_sibling)
d1042 1
a1042 1
    o->op_flags |= OPf_MOD;
d1045 1
a1045 1
	o->op_flags |= OPf_SPECIAL|OPf_REF;
d1047 2
a1048 3
	o->op_private |= OPpLVAL_INTRO;
	o->op_flags &= ~OPf_SPECIAL;
	PL_hints |= HINT_BLOCK_SCOPE;
d1051 2
a1052 49
	o->op_flags |= OPf_REF;
    return o;
}

static bool
scalar_mod_type(OP *o, I32 type)
{
    switch (type) {
    case OP_SASSIGN:
	if (o->op_type == OP_RV2GV)
	    return FALSE;
	/* FALL THROUGH */
    case OP_PREINC:
    case OP_PREDEC:
    case OP_POSTINC:
    case OP_POSTDEC:
    case OP_I_PREINC:
    case OP_I_PREDEC:
    case OP_I_POSTINC:
    case OP_I_POSTDEC:
    case OP_POW:
    case OP_MULTIPLY:
    case OP_DIVIDE:
    case OP_MODULO:
    case OP_REPEAT:
    case OP_ADD:
    case OP_SUBTRACT:
    case OP_I_MULTIPLY:
    case OP_I_DIVIDE:
    case OP_I_MODULO:
    case OP_I_ADD:
    case OP_I_SUBTRACT:
    case OP_LEFT_SHIFT:
    case OP_RIGHT_SHIFT:
    case OP_BIT_AND:
    case OP_BIT_XOR:
    case OP_BIT_OR:
    case OP_CONCAT:
    case OP_SUBST:
    case OP_TRANS:
    case OP_READ:
    case OP_SYSREAD:
    case OP_RECV:
    case OP_ANDASSIGN:	/* may work later */
    case OP_ORASSIGN:	/* may work later */
	return TRUE;
    default:
	return FALSE;
    }
d1056 3
a1058 1
refkids(OP *o, I32 type)
d1061 2
a1062 2
    if (o && o->op_flags & OPf_KIDS) {
	for (kid = cLISTOPo->op_first; kid; kid = kid->op_sibling)
d1065 1
a1065 1
    return o;
d1069 3
a1071 1
ref(OP *o, I32 type)
d1075 2
a1076 2
    if (!o || PL_error_count)
	return o;
d1078 1
a1078 1
    switch (o->op_type) {
d1080 7
a1086 7
	if ((type == OP_DEFINED || type == OP_LOCK) &&
	    !(o->op_flags & OPf_STACKED)) {
	    o->op_type = OP_RV2CV;             /* entersub => rv2cv */
	    o->op_ppaddr = ppaddr[OP_RV2CV];
	    assert(cUNOPo->op_first->op_type == OP_NULL);
	    null(((LISTOP*)cUNOPo->op_first)->op_first);	/* disable pushmark */
	    o->op_flags |= OPf_SPECIAL;
d1089 1
a1089 1

d1091 1
a1091 1
	for (kid = cUNOPo->op_first->op_sibling; kid; kid = kid->op_sibling)
d1095 1
a1095 1
	ref(cUNOPo->op_first, o->op_type);
d1098 3
a1100 5
	if (type == OP_RV2SV || type == OP_RV2AV || type == OP_RV2HV) {
	    o->op_private |= (type == OP_RV2AV ? OPpDEREF_AV
			      : type == OP_RV2HV ? OPpDEREF_HV
			      : OPpDEREF_SV);
	    o->op_flags |= OPf_MOD;
a1103 4
    case OP_THREADSV:
	o->op_flags |= OPf_MOD;		/* XXX ??? */
	break;

d1106 1
a1106 1
	o->op_flags |= OPf_REF;
d1109 1
a1109 1
	ref(cUNOPo->op_first, o->op_type);
d1114 1
a1114 1
	o->op_flags |= OPf_REF;
d1116 1
a1116 1

d1119 1
a1119 1
	if (!(o->op_flags & OPf_KIDS))
d1121 1
a1121 1
	ref(cBINOPo->op_first, type);
d1125 4
a1128 6
	ref(cBINOPo->op_first, o->op_type);
	if (type == OP_RV2SV || type == OP_RV2AV || type == OP_RV2HV) {
	    o->op_private |= (type == OP_RV2AV ? OPpDEREF_AV
			      : type == OP_RV2HV ? OPpDEREF_HV
			      : OPpDEREF_SV);
	    o->op_flags |= OPf_MOD;
d1136 1
a1136 1
	if (!(o->op_flags & OPf_KIDS))
d1138 1
a1138 1
	ref(cLISTOPo->op_last, type);
d1143 1
a1143 1
    return scalar(o);
d1148 2
a1149 1
my(OP *o)
d1154 2
a1155 2
    if (!o || PL_error_count)
	return o;
d1157 1
a1157 1
    type = o->op_type;
d1159 1
a1159 1
	for (kid = cLISTOPo->op_first; kid; kid = kid->op_sibling)
d1161 2
a1162 3
    } else if (type == OP_UNDEF) {
	return o;
    } else if (type != OP_PADSV &&
d1167 3
a1169 2
	yyerror(form("Can't declare %s in my", op_desc[o->op_type]));
	return o;
d1171 3
a1173 3
    o->op_flags |= OPf_MOD;
    o->op_private |= OPpLVAL_INTRO;
    return o;
d1177 2
a1178 1
sawparens(OP *o)
d1186 4
a1189 1
bind_match(I32 type, OP *left, OP *right)
d1191 1
a1191 15
    OP *o;

    if (PL_dowarn &&
	(left->op_type == OP_RV2AV ||
	 left->op_type == OP_RV2HV ||
	 left->op_type == OP_PADAV ||
	 left->op_type == OP_PADHV)) {
	char *desc = op_desc[(right->op_type == OP_SUBST ||
			      right->op_type == OP_TRANS)
			     ? right->op_type : OP_MATCH];
	char *sample = ((left->op_type == OP_RV2AV ||
			 left->op_type == OP_PADAV)
			? "@@array" : "%hash");
	warn("Applying %s to %s will act on scalar(%s)", desc, sample, sample);
    }
d1200 1
a1200 1
	    o = newBINOP(OP_NULL, OPf_STACKED, scalar(left), right);
d1202 1
a1202 1
	    o = prepend_elem(right->op_type, scalar(left), right);
d1204 2
a1205 2
	    return newUNOP(OP_NOT, 0, scalar(o));
	return o;
d1213 2
a1214 1
invert(OP *o)
d1216 2
a1217 2
    if (!o)
	return o;
d1219 1
a1219 1
    return newUNOP(OP_NOT, OPf_SPECIAL, scalar(o));
d1223 2
a1224 1
scope(OP *o)
d1227 1
a1227 1
	if (o->op_flags & OPf_PARENS || PERLDB_NOOPT || PL_tainting) {
a1249 9
void
save_hints(void)
{
    SAVEI32(PL_hints);
    SAVESPTR(GvHV(PL_hintgv));
    GvHV(PL_hintgv) = newHVhv(GvHV(PL_hintgv));
    SAVEFREESV(GvHV(PL_hintgv));
}

d1251 1
a1251 1
block_start(int full)
d1253 11
a1263 19
    dTHR;
    int retval = PL_savestack_ix;

    SAVEI32(PL_comppad_name_floor);
    if (full) {
	if ((PL_comppad_name_fill = AvFILLp(PL_comppad_name)) > 0)
	    PL_comppad_name_floor = PL_comppad_name_fill;
	else
	    PL_comppad_name_floor = 0;
    }
    SAVEI32(PL_min_intro_pending);
    SAVEI32(PL_max_intro_pending);
    PL_min_intro_pending = 0;
    SAVEI32(PL_comppad_name_fill);
    SAVEI32(PL_padix_floor);
    PL_padix_floor = PL_padix;
    PL_pad_reset_pending = FALSE;
    SAVEHINTS();
    PL_hints &= ~HINT_BLOCK_SCOPE;
d1268 4
a1271 1
block_end(I32 floor, OP *seq)
d1273 1
a1273 2
    dTHR;
    int needblockscope = PL_hints & HINT_BLOCK_SCOPE;
d1275 2
d1278 1
a1278 1
    PL_pad_reset_pending = FALSE;
d1280 2
a1281 3
	PL_hints |= HINT_BLOCK_SCOPE; /* propagate out */
    pad_leavemy(PL_comppad_name_fill);
    PL_cop_seqmax++;
a1284 12
STATIC OP *
newDEFSVOP(void)
{
#ifdef USE_THREADS
    OP *o = newOP(OP_THREADSV, 0);
    o->op_targ = find_threadsv("_");
    return o;
#else
    return newSVREF(newGVOP(OP_GV, 0, PL_defgv));
#endif /* USE_THREADS */
}

d1286 2
a1287 1
newPROG(OP *o)
d1289 5
a1293 6
    dTHR;
    if (PL_in_eval) {
	PL_eval_root = newUNOP(OP_LEAVEEVAL, ((PL_in_eval & 4) ? OPf_SPECIAL : 0), o);
	PL_eval_start = linklist(PL_eval_root);
	PL_eval_root->op_next = 0;
	peep(PL_eval_start);
d1296 2
a1297 1
	if (!o)
a1298 17
	PL_main_root = scope(sawparens(scalarvoid(o)));
	PL_curcop = &PL_compiling;
	PL_main_start = LINKLIST(PL_main_root);
	PL_main_root->op_next = 0;
	peep(PL_main_start);
	PL_compcv = 0;

	/* Register with debugger */
	if (PERLDB_INTER) {
	    CV *cv = perl_get_cv("DB::postponed", FALSE);
	    if (cv) {
		dSP;
		PUSHMARK(SP);
		XPUSHs((SV*)PL_compiling.cop_filegv);
		PUTBACK;
		perl_call_sv((SV*)cv, G_DISCARD);
	    }
d1300 7
d1311 3
a1313 1
localize(OP *o, I32 lex)
d1318 2
a1319 1
	if (PL_dowarn && PL_bufptr > PL_oldbufptr && PL_bufptr[-1] == ',') {
d1321 1
a1321 1
	    for (s = PL_bufptr; *s && (isALNUM(*s) || strchr("@@$%, ",*s)); s++) ;
d1326 1
a1326 2
    PL_in_my = FALSE;
    PL_in_my_stash = Nullhv;
d1334 2
a1335 1
jmaybe(OP *o)
d1338 4
a1341 8
	OP *o2;
#ifdef USE_THREADS
	o2 = newOP(OP_THREADSV, 0);
	o2->op_targ = find_threadsv(";");
#else
	o2 = newSVREF(newGVOP(OP_GV, 0, gv_fetchpv(";", TRUE, SVt_PV))),
#endif /* USE_THREADS */
	o = convert(OP_JOIN, 0, prepend_elem(OP_LIST, o2, o));
d1347 2
a1348 1
fold_constants(register OP *o)
a1349 1
    dTHR;
d1359 1
a1359 1
    if ((opargs[type] & OA_OTHERINT) && (PL_hints & HINT_INTEGER))
d1365 1
a1365 17
    switch (type) {
    case OP_SPRINTF:
    case OP_UCFIRST:
    case OP_LCFIRST:
    case OP_UC:
    case OP_LC:
    case OP_SLT:
    case OP_SGT:
    case OP_SLE:
    case OP_SGE:
    case OP_SCMP:

	if (o->op_private & OPpLOCALE)
	    goto nope;
    }

    if (PL_error_count)
d1380 3
a1382 3
    PL_op = curop;
    CALLRUNOPS();
    sv = *(PL_stack_sp--);
d1391 1
a1391 1
	return newGVOP(OP_GV, 0, (GV*)sv);
d1393 1
a1393 4
	/* try to smush double to int, but don't smush -2.0 to -2 */
	if ((SvFLAGS(sv) & (SVf_IOK|SVf_NOK|SVf_POK)) == SVf_NOK &&
	    type != OP_NEGATE)
	{
d1395 1
a1395 1
	    if ((double)iv == SvNV(sv)) {
a1398 2
	    else
		SvIOK_off(sv);			/* undo SvIV() damage */
d1402 1
a1402 1

d1407 3
a1409 1
    if (!(PL_hints & HINT_INTEGER)) {
d1415 3
a1417 1
		if (SvIOK(((SVOP*)curop)->op_sv))
d1419 1
d1424 12
d1445 2
a1446 1
gen_constant_list(register OP *o)
a1447 1
    dTHR;
d1449 1
a1449 1
    I32 oldtmps_floor = PL_tmps_floor;
d1452 1
a1452 1
    if (PL_error_count)
d1455 1
a1455 1
    PL_op = curop = LINKLIST(o);
d1457 5
a1461 5
    pp_pushmark(ARGS);
    CALLRUNOPS();
    PL_op = curop;
    pp_anonlist(ARGS);
    PL_tmps_floor = oldtmps_floor;
d1466 1
a1466 1
    ((UNOP*)o)->op_first = newSVOP(OP_CONST, 0, SvREFCNT_inc(*PL_stack_sp--));
d1473 4
a1476 1
convert(I32 type, I32 flags, OP *o)
d1481 2
a1482 2
    if (!o || o->op_type != OP_LIST)
	o = newLISTOP(OP_LIST, 0, o, Nullop);
d1484 1
a1484 1
	o->op_flags &= ~OPf_WANT;
d1487 1
a1487 1
	null(cLISTOPo->op_first);
d1489 3
a1491 3
    o->op_type = type;
    o->op_ppaddr = ppaddr[type];
    o->op_flags |= flags;
d1493 3
a1495 3
    o = CHECKOP(type, o);
    if (o->op_type != type)
	return o;
d1497 1
a1497 1
    if (cLISTOPo->op_children < 7) {
d1499 1
a1499 1
	for (kid = cLISTOPo->op_first; kid; kid = kid->op_sibling)
d1501 1
a1501 1
	cLISTOPo->op_last = last;	/* in case check substituted last arg */
d1504 1
a1504 1
    return fold_constants(o);
d1510 4
a1513 1
append_elem(I32 type, OP *first, OP *last)
d1536 4
a1539 1
append_list(I32 type, LISTOP *first, LISTOP *last)
d1557 1
a1557 1
	first->op_flags |= OPf_KIDS;
d1564 4
a1567 1
prepend_elem(I32 type, OP *first, OP *last)
d1598 1
a1598 1
newNULLLIST(void)
d1604 2
a1605 1
force_list(OP *o)
d1607 4
a1610 4
    if (!o || o->op_type != OP_LIST)
	o = newLISTOP(OP_LIST, 0, o, Nullop);
    null(o);
    return o;
d1614 5
a1618 1
newLISTOP(I32 type, I32 flags, OP *first, OP *last)
d1653 9
a1661 7
newOP(I32 type, I32 flags)
{
    OP *o;
    Newz(1101, o, 1, OP);
    o->op_type = type;
    o->op_ppaddr = ppaddr[type];
    o->op_flags = flags;
d1663 2
a1664 2
    o->op_next = o;
    o->op_private = 0 + (flags >> 8);
d1666 1
a1666 1
	scalar(o);
d1668 2
a1669 2
	o->op_targ = pad_alloc(type, SVs_PADTMP);
    return CHECKOP(type, o);
d1673 4
a1676 1
newUNOP(I32 type, I32 flags, OP *first)
d1681 1
a1681 1
	first = newOP(OP_STUB, 0);
d1691 1
d1700 5
a1704 1
newBINOP(I32 type, I32 flags, OP *first, OP *last)
d1735 4
a1738 1
pmtrans(OP *o, OP *expr, OP *repl)
d1748 1
a1748 1
    I32 Delete;
a1749 1
    I32 squash;
d1752 4
a1755 4
    tbl = (short*)cPVOPo->op_pv;
    complement	= o->op_private & OPpTRANS_COMPLEMENT;
    Delete	= o->op_private & OPpTRANS_DELETE;
    squash	= o->op_private & OPpTRANS_SQUASH;
d1764 1
a1764 1
		    if (Delete)
d1777 1
a1777 1
	if (!rlen && !Delete) {
a1778 2
	    if (!squash)
		o->op_private |= OPpTRANS_COUNTONLY;
d1784 1
a1784 1
		if (Delete) {
d1798 1
a1798 1
    return o;
d1802 3
a1804 1
newPMOP(I32 type, I32 flags)
a1805 1
    dTHR;
a1813 6
    if (PL_hints & HINT_RE_TAINT)
	pmop->op_pmpermflags |= PMf_RETAINT;
    if (PL_hints & HINT_LOCALE)
	pmop->op_pmpermflags |= PMf_LOCALE;
    pmop->op_pmflags = pmop->op_pmpermflags;

d1815 3
a1817 3
    if (type != OP_TRANS && PL_curstash) {
	pmop->op_pmnext = HvPMROOT(PL_curstash);
	HvPMROOT(PL_curstash) = pmop;
d1824 4
a1827 1
pmruntime(OP *o, OP *expr, OP *repl)
a1828 1
    dTHR;
a1830 1
    I32 repl_has_vars = 0;
d1832 2
a1833 2
    if (o->op_type == OP_TRANS)
	return pmtrans(o, expr, repl);
d1835 1
a1835 2
    PL_hints |= HINT_BLOCK_SCOPE;
    pm = (PMOP*)o;
d1841 1
a1841 1
	if ((o->op_flags & OPf_SPECIAL) && strEQ(p, " ")) {
d1846 2
a1847 2
	pm->op_pmregexp = CALLREGCOMP(p, p + plen, pm);
	if (strEQ("\\s+", pm->op_pmregexp->precomp))
d1849 1
d1853 2
a1854 4
	if (pm->op_pmflags & PMf_KEEP || !(PL_hints & HINT_RE_EVAL))
	    expr = newUNOP((!(PL_hints & HINT_RE_EVAL) 
			    ? OP_REGCRESET
			    : OP_REGCMAYBE),0,expr);
d1860 1
a1860 3
	rcop->op_flags |= ((PL_hints & HINT_RE_EVAL) 
			   ? (OPf_SPECIAL | OPf_KIDS)
			   : OPf_KIDS);
d1862 1
a1862 1
	rcop->op_other = o;
d1865 1
a1865 1
	if (pm->op_pmflags & PMf_KEEP || !(PL_hints & HINT_RE_EVAL)) {
d1875 1
a1875 1
	prepend_elem(o->op_type, scalar((OP*)rcop), o);
d1880 1
a1880 10
	if (pm->op_pmflags & PMf_EVAL) {
	    curop = 0;
	    if (PL_curcop->cop_line < PL_multi_end)
		PL_curcop->cop_line = PL_multi_end;
	}
#ifdef USE_THREADS
	else if (repl->op_type == OP_THREADSV
		 && strchr("&`'123456789+",
			   PL_threadsv_names[repl->op_targ]))
	{
a1881 2
	}
#endif /* USE_THREADS */
a1887 7
#ifdef USE_THREADS
		    if (curop->op_type == OP_THREADSV) {
			repl_has_vars = 1;
			if (strchr("&`'123456789+", curop->op_private))
			    break;
		    }
#else
a1889 1
			repl_has_vars = 1;
a1892 1
#endif /* USE_THREADS */
d1906 1
a1906 1
			repl_has_vars = 1;
a1907 2
		    else if (curop->op_type == OP_PUSHRE)
			; /* Okay here, dangerous in newASSIGNOP */
d1914 1
a1914 4
	if (curop == repl
	    && !(repl_has_vars 
		 && (!pm->op_pmregexp 
		     || pm->op_pmregexp->reganch & ROPT_EVAL_SEEN))) {
d1917 1
a1917 1
	    prepend_elem(o->op_type, scalar(repl), o);
a1919 4
	    if (curop == repl && !pm->op_pmregexp) { /* Has variables. */
		pm->op_pmflags |= PMf_MAYBE_CONST;
		pm->op_pmpermflags |= PMf_MAYBE_CONST;
	    }
d1926 1
a1926 1
	    rcop->op_other = o;
d1942 4
a1945 1
newSVOP(I32 type, I32 flags, SV *sv)
d1962 4
a1965 1
newGVOP(I32 type, I32 flags, GV *gv)
a1966 1
    dTHR;
d1982 4
a1985 1
newPVOP(I32 type, I32 flags, char *pv)
d2002 2
a2003 1
package(OP *o)
a2004 1
    dTHR;
d2007 3
a2009 3
    save_hptr(&PL_curstash);
    save_item(PL_curstname);
    if (o) {
d2012 1
a2012 1
	sv = cSVOPo->op_sv;
d2014 3
a2016 3
	PL_curstash = gv_stashpvn(name,len,TRUE);
	sv_setpvn(PL_curstname, name, len);
	op_free(o);
d2019 2
a2020 2
	sv_setpv(PL_curstname,"<none>");
	PL_curstash = Nullhv;
d2022 2
a2023 3
    PL_hints |= HINT_BLOCK_SCOPE;
    PL_copline = NOLINE;
    PL_expect = XSTATE;
d2027 5
a2031 1
utilize(int aver, I32 floor, OP *version, OP *id, OP *arg)
a2036 2
    OP *veop;
    GV *gv;
a2040 27
    veop = Nullop;

    if(version != Nullop) {
	SV *vesv = ((SVOP*)version)->op_sv;

	if (arg == Nullop && !SvNIOK(vesv)) {
	    arg = version;
	}
	else {
	    OP *pack;
	    OP *meth;

	    if (version->op_type != OP_CONST || !SvNIOK(vesv))
		croak("Version number must be constant number");

	    /* Make copy of id so we don't free it twice */
	    pack = newSVOP(OP_CONST, 0, newSVsv(((SVOP*)id)->op_sv));

	    /* Fake up a method call to VERSION */
	    meth = newSVOP(OP_CONST, 0, newSVpv("VERSION", 7));
	    veop = convert(OP_ENTERSUB, OPf_STACKED|OPf_SPECIAL,
			    append_elem(OP_LIST,
			    prepend_elem(OP_LIST, pack, list(version)),
			    newUNOP(OP_METHOD, 0, meth)));
	}
    }

a2043 3
    else if(SvNIOK(((SVOP*)id)->op_sv)) {
	imop = Nullop;		/* use 5.0; */
    }
d2047 1
d2059 2
a2060 15
    /* Fake up a require, handle override, if any */
    gv = gv_fetchpv("require", FALSE, SVt_PVCV);
    if (!(gv && GvIMPORTED_CV(gv)))
	gv = gv_fetchpv("CORE::GLOBAL::require", FALSE, SVt_PVCV);

    if (gv && GvIMPORTED_CV(gv)) {
	rqop = ck_subr(newUNOP(OP_ENTERSUB, OPf_STACKED,
			       append_elem(OP_LIST, id,
					   scalar(newUNOP(OP_RV2CV, 0,
							  newGVOP(OP_GV, 0,
								  gv))))));
    }
    else {
	rqop = newUNOP(OP_REQUIRE, 0, id);
    }
d2067 1
a2067 3
	    append_elem(OP_LINESEQ,
	        newSTATEOP(0, Nullch, rqop),
	        newSTATEOP(0, Nullch, veop)),
d2070 2
a2071 2
    PL_copline = NOLINE;
    PL_expect = XSTATE;
d2075 4
a2078 1
dofile(OP *term)
d2080 2
a2081 25
    OP *doop;
    GV *gv;

    gv = gv_fetchpv("do", FALSE, SVt_PVCV);
    if (!(gv && GvIMPORTED_CV(gv)))
	gv = gv_fetchpv("CORE::GLOBAL::do", FALSE, SVt_PVCV);

    if (gv && GvIMPORTED_CV(gv)) {
	doop = ck_subr(newUNOP(OP_ENTERSUB, OPf_STACKED,
			       append_elem(OP_LIST, term,
					   scalar(newUNOP(OP_RV2CV, 0,
							  newGVOP(OP_GV, 0,
								  gv))))));
    }
    else {
	doop = newUNOP(OP_DOFILE, 0, scalar(term));
    }
    return doop;
}

OP *
newSLICEOP(I32 flags, OP *subscript, OP *listval)
{
    return newBINOP(OP_LSLICE, flags,
	    list(force_list(subscript)),
d2085 3
a2087 2
STATIC I32
list_assignment(register OP *o)
d2089 1
a2089 1
    if (!o)
d2092 2
a2093 2
    if (o->op_type == OP_NULL && o->op_flags & OPf_KIDS)
	o = cUNOPo->op_first;
d2095 3
a2097 3
    if (o->op_type == OP_COND_EXPR) {
	I32 t = list_assignment(cCONDOPo->op_first->op_sibling);
	I32 f = list_assignment(cCONDOPo->op_first->op_sibling->op_sibling);
d2106 3
a2108 3
    if (o->op_type == OP_LIST || o->op_flags & OPf_PARENS ||
	o->op_type == OP_RV2AV || o->op_type == OP_RV2HV ||
	o->op_type == OP_ASLICE || o->op_type == OP_HSLICE)
d2111 1
a2111 1
    if (o->op_type == OP_PADAV || o->op_type == OP_PADHV)
d2114 1
a2114 1
    if (o->op_type == OP_RV2SV)
d2121 5
a2125 1
newASSIGNOP(I32 flags, OP *left, I32 optype, OP *right)
d2127 1
a2127 1
    OP *o;
d2142 2
a2143 3
	dTHR;
	PL_modcount = 0;
	PL_eval_start = right;	/* Grandfathering $[ assignment here.  Bletch.*/
d2145 2
a2146 2
	if (PL_eval_start)
	    PL_eval_start = 0;
d2152 1
a2152 1
	o = newBINOP(OP_AASSIGN, flags,
d2155 1
a2155 1
	o->op_private = 0 | (flags >> 8);
d2157 1
d2159 3
a2161 3
	    OP *lastop = o;
	    PL_generation++;
	    for (curop = LINKLIST(o); curop != o; curop = LINKLIST(curop)) {
d2165 1
a2165 1
			if (gv == PL_defgv || SvCUR(gv) == PL_generation)
d2167 1
a2167 1
			SvCUR(gv) = PL_generation;
d2173 1
a2173 1
			SV **svp = AvARRAY(PL_comppad_name);
d2175 1
a2175 1
			if (SvCUR(sv) == PL_generation)
d2177 1
a2177 1
			SvCUR(sv) = PL_generation;	/* (SvCUR not used any more) */
a2187 8
		    else if (curop->op_type == OP_PUSHRE) {
			if (((PMOP*)curop)->op_pmreplroot) {
			    GV *gv = (GV*)((PMOP*)curop)->op_pmreplroot;
			    if (gv == PL_defgv || SvCUR(gv) == PL_generation)
				break;
			    SvCUR(gv) = PL_generation;
			}	
		    }
d2193 2
a2194 2
	    if (curop != o)
		o->op_private = OPpASSIGN_COMMON;
d2204 1
a2204 1
		    !(o->op_private & OPpASSIGN_COMMON) )
d2210 1
a2210 1
			tmpop = cUNOPo->op_first;	/* to list (nulled) */
d2214 2
a2215 2
			op_free(o);			/* blow off assign */
			right->op_flags &= ~OPf_WANT;
d2221 1
a2221 1
		    if (PL_modcount < 10000 &&
d2226 1
a2226 1
			    sv_setiv(sv, PL_modcount+1);
d2231 1
a2231 1
	return o;
d2240 2
a2241 2
	PL_eval_start = right;	/* Grandfathering $[ assignment here.  Bletch.*/
	o = newBINOP(OP_SASSIGN, flags,
d2243 2
a2244 2
	if (PL_eval_start)
	    PL_eval_start = 0;
d2246 1
a2246 1
	    op_free(o);
d2250 1
a2250 1
    return o;
d2254 4
a2257 1
newSTATEOP(I32 flags, char *label, OP *o)
a2258 2
    dTHR;
    U32 seq = intro_my();
d2261 15
d2277 1
a2277 1
    if (PERLDB_LINE && PL_curcop->cop_line && PL_curstash != PL_debstash) {
a2286 3
#ifdef NATIVE_HINTS
    cop->op_private |= NATIVE_HINTS;
#endif
d2291 1
a2291 1
	PL_hints |= HINT_BLOCK_SCOPE;
d2293 2
a2294 2
    cop->cop_seq = seq;
    cop->cop_arybase = PL_curcop->cop_arybase;
d2296 2
a2297 2
    if (PL_copline == NOLINE)
        cop->cop_line = PL_curcop->cop_line;
d2299 2
a2300 2
        cop->cop_line = PL_copline;
        PL_copline = NOLINE;
d2302 2
a2303 2
    cop->cop_filegv = (GV*)SvREFCNT_inc(PL_curcop->cop_filegv);
    cop->cop_stash = PL_curstash;
d2305 3
a2307 3
    if (PERLDB_LINE && PL_curstash != PL_debstash) {
	SV **svp = av_fetch(GvAV(PL_curcop->cop_filegv),(I32)cop->cop_line, FALSE);
	if (svp && *svp != &PL_sv_undef && !SvIOK(*svp)) {
d2314 1
a2314 24
    return prepend_elem(OP_LINESEQ, (OP*)cop, o);
}

/* "Introduce" my variables to visible status. */
U32
intro_my(void)
{
    SV **svp;
    SV *sv;
    I32 i;

    if (! PL_min_intro_pending)
	return PL_cop_seqmax;

    svp = AvARRAY(PL_comppad_name);
    for (i = PL_min_intro_pending; i <= PL_max_intro_pending; i++) {
	if ((sv = svp[i]) && sv != &PL_sv_undef && !SvIVX(sv)) {
	    SvIVX(sv) = PAD_MAX;	/* Don't know scope end yet. */
	    SvNVX(sv) = (double)PL_cop_seqmax;
	}
    }
    PL_min_intro_pending = 0;
    PL_comppad_name_fill = PL_max_intro_pending;	/* Needn't search higher */
    return PL_cop_seqmax++;
d2318 5
a2322 1
newLOGOP(I32 type, I32 flags, OP *first, OP *other)
a2323 7
    return new_logop(type, flags, &first, &other);
}

STATIC OP *
new_logop(I32 type, I32 flags, OP** firstp, OP** otherp)
{
    dTHR;
d2325 1
a2325 3
    OP *o;
    OP *first = *firstp;
    OP *other = *otherp;
d2338 6
a2343 6
	    o = first;
	    first = *firstp = cUNOPo->op_first;
	    if (o->op_next)
		first->op_next = o->op_next;
	    cUNOPo->op_first = Nullop;
	    op_free(o);
d2347 1
a2347 1
	if (PL_dowarn && (first->op_private & OPpCONST_BARE))
a2350 1
	    *firstp = Nullop;
a2354 1
	    *otherp = Nullop;
a2363 30
    else if (PL_dowarn && (first->op_flags & OPf_KIDS)) {
	OP *k1 = ((UNOP*)first)->op_first;
	OP *k2 = k1->op_sibling;
	OPCODE warnop = 0;
	switch (first->op_type)
	{
	case OP_NULL:
	    if (k2 && k2->op_type == OP_READLINE
		  && (k2->op_flags & OPf_STACKED)
		  && ((k1->op_flags & OPf_WANT) == OPf_WANT_SCALAR)) 
		warnop = k2->op_type;
	    break;

	case OP_SASSIGN:
	    if (k1->op_type == OP_READDIR
		  || k1->op_type == OP_GLOB
		  || k1->op_type == OP_EACH)
		warnop = k1->op_type;
	    break;
	}
	if (warnop) {
	    line_t oldline = PL_curcop->cop_line;
	    PL_curcop->cop_line = PL_copline;
	    warn("Value of %s%s can be \"0\"; test with defined()",
		 op_desc[warnop],
		 ((warnop == OP_READLINE || warnop == OP_GLOB)
		  ? " construct" : "() operator"));
	    PL_curcop->cop_line = oldline;
	}
    }
d2385 2
a2386 2
    o = newUNOP(OP_NULL, 0, (OP*)logop);
    other->op_next = o;
d2388 1
a2388 1
    return o;
d2392 5
a2396 1
newCONDOP(I32 flags, OP *first, OP *trueop, OP *falseop)
a2397 1
    dTHR;
d2399 1
a2399 1
    OP *o;
d2401 4
a2404 4
    if (!falseop)
	return newLOGOP(OP_AND, 0, first, trueop);
    if (!trueop)
	return newLOGOP(OP_OR, 0, first, falseop);
d2410 2
a2411 2
	    op_free(falseop);
	    return trueop;
d2415 2
a2416 2
	    op_free(trueop);
	    return falseop;
d2420 2
a2421 2
	list(trueop);
	scalar(falseop);
d2429 2
a2430 2
    condop->op_true = LINKLIST(trueop);
    condop->op_false = LINKLIST(falseop);
d2437 3
a2439 3
    first->op_sibling = trueop;
    trueop->op_sibling = falseop;
    o = newUNOP(OP_NULL, 0, (OP*)condop);
d2441 2
a2442 2
    trueop->op_next = o;
    falseop->op_next = o;
d2444 1
a2444 1
    return o;
d2448 4
a2451 1
newRANGE(I32 flags, OP *left, OP *right)
a2452 1
    dTHR;
d2456 1
a2456 1
    OP *o;
d2473 1
a2473 1
    o = newUNOP(OP_NULL, 0, flop);
d2487 1
a2487 1
    flip->op_next = o;
d2489 1
a2489 1
	linklist(o);		/* blow off optimizer unless constant */
d2491 1
a2491 1
    return o;
d2495 5
a2499 1
newLOOPOP(I32 flags, I32 debuggable, OP *expr, OP *block)
a2500 1
    dTHR;
d2502 1
a2502 1
    OP* o;
d2509 2
a2510 23
	if (expr->op_type == OP_READLINE || expr->op_type == OP_GLOB
	    || (expr->op_type == OP_NULL && expr->op_targ == OP_GLOB)) {
	    expr = newUNOP(OP_DEFINED, 0,
		newASSIGNOP(0, newDEFSVOP(), 0, expr) );
	} else if (expr->op_flags & OPf_KIDS) {
	    OP *k1 = ((UNOP*)expr)->op_first;
	    OP *k2 = (k1) ? k1->op_sibling : NULL;
	    switch (expr->op_type) {
	      case OP_NULL: 
		if (k2 && k2->op_type == OP_READLINE
		      && (k2->op_flags & OPf_STACKED)
		      && ((k1->op_flags & OPf_WANT) == OPf_WANT_SCALAR)) 
		    expr = newUNOP(OP_DEFINED, 0, expr);
		break;                                

	      case OP_SASSIGN:
		if (k1->op_type == OP_READDIR
		      || k1->op_type == OP_GLOB
		      || k1->op_type == OP_EACH)
		    expr = newUNOP(OP_DEFINED, 0, expr);
		break;
	    }
	}
d2514 1
a2514 1
    o = new_logop(OP_AND, 0, &expr, &listop);
d2516 1
a2516 2
    if (listop)
	((LISTOP*)listop)->op_last->op_next = LINKLIST(o);
d2518 2
a2519 2
    if (once && o != listop)
	o->op_next = ((LOGOP*)cUNOPo->op_first)->op_other;
d2521 2
a2522 2
    if (o == listop)
	o = newUNOP(OP_NULL, 0, o);	/* or do {} while 1 loses outer block */
d2524 4
a2527 4
    o->op_flags |= flags;
    o = scope(o);
    o->op_flags |= OPf_SPECIAL;	/* suppress POPBLOCK curpm restoration*/
    return o;
d2531 7
a2537 1
newWHILEOP(I32 flags, I32 debuggable, LOOP *loop, I32 whileline, OP *expr, OP *block, OP *cont)
a2538 1
    dTHR;
d2542 1
a2542 1
    OP *o;
d2545 1
a2545 2
    if (expr && (expr->op_type == OP_READLINE || expr->op_type == OP_GLOB
		 || (expr->op_type == OP_NULL && expr->op_targ == OP_GLOB))) {
d2547 1
a2547 19
	    newASSIGNOP(0, newDEFSVOP(), 0, expr) );
    } else if (expr && (expr->op_flags & OPf_KIDS)) {
	OP *k1 = ((UNOP*)expr)->op_first;
	OP *k2 = (k1) ? k1->op_sibling : NULL;
	switch (expr->op_type) {
	  case OP_NULL: 
	    if (k2 && k2->op_type == OP_READLINE
		  && (k2->op_flags & OPf_STACKED)
		  && ((k1->op_flags & OPf_WANT) == OPf_WANT_SCALAR)) 
		expr = newUNOP(OP_DEFINED, 0, expr);
	    break;                                

	  case OP_SASSIGN:
	    if (k1->op_type == OP_READDIR
		  || k1->op_type == OP_GLOB
		  || k1->op_type == OP_EACH)
		expr = newUNOP(OP_DEFINED, 0, expr);
	    break;
	}
d2555 1
a2555 1
    if (expr) {
a2556 6
	if ((line_t)whileline != NOLINE) {
	    PL_copline = whileline;
	    cont = append_elem(OP_LINESEQ, cont,
			       newSTATEOP(0, Nullch, Nullop));
	}
    }
d2562 2
a2563 4
	PL_copline = whileline;
	scalar(listop);
	o = new_logop(OP_AND, 0, &expr, &listop);
	if (o == expr && o->op_type == OP_CONST && !SvTRUE(cSVOPo->op_sv)) {
d2566 1
a2566 1
	    return Nullop;		/* listop already freed by new_logop */
d2568 2
a2569 3
	if (listop)
	    ((LISTOP*)listop)->op_last->op_next = condop =
		(o == listop ? redo : LINKLIST(o));
d2574 1
a2574 1
	o = listop;
d2584 1
a2584 1
    o = newBINOP(OP_LEAVELOOP, 0, (OP*)loop, o);
d2587 1
a2587 1
    loop->op_lastop = o;
d2592 1
a2592 1
	loop->op_nextop = o;
d2594 3
a2596 3
    o->op_flags |= flags;
    o->op_private |= (flags >> 8);
    return o;
d2600 10
d2611 1
a2613 1
    OP *wop;
d2617 1
a2627 6
	else if (sv->op_type == OP_THREADSV) { /* per-thread variable */
	    padoff = sv->op_targ;
	    iterflags |= OPf_SPECIAL;
	    op_free(sv);
	    sv = Nullop;
	}
d2632 1
a2632 6
#ifdef USE_THREADS
	padoff = find_threadsv("_");
	iterflags |= OPf_SPECIAL;
#else
	sv = newGVOP(OP_GV, 0, PL_defgv);
#endif
d2634 2
a2635 30
    if (expr->op_type == OP_RV2AV || expr->op_type == OP_PADAV) {
	expr = mod(force_list(scalar(ref(expr, OP_ITER))), OP_GREPSTART);
	iterflags |= OPf_STACKED;
    }
    else if (expr->op_type == OP_NULL &&
             (expr->op_flags & OPf_KIDS) &&
             ((BINOP*)expr)->op_first->op_type == OP_FLOP)
    {
	/* Basically turn for($x..$y) into the same as for($x,$y), but we
	 * set the STACKED flag to indicate that these values are to be
	 * treated as min/max values by 'pp_iterinit'.
	 */
	UNOP* flip = (UNOP*)((UNOP*)((BINOP*)expr)->op_first)->op_first;
	CONDOP* range = (CONDOP*) flip->op_first;
	OP* left  = range->op_first;
	OP* right = left->op_sibling;
	LISTOP* listop;

	range->op_flags &= ~OPf_KIDS;
	range->op_first = Nullop;

	listop = (LISTOP*)newLISTOP(OP_LIST, 0, left, right);
	listop->op_first->op_next = range->op_true;
	left->op_next = range->op_false;
	right->op_next = (OP*)listop;
	listop->op_next = listop->op_first;

	op_free(expr);
	expr = (OP*)(listop);
        null(expr);
a2637 5
    else {
        expr = mod(force_list(expr), OP_GREPSTART);
    }


d2639 2
a2640 1
			       append_elem(OP_LIST, expr, scalar(sv))));
d2644 2
a2645 3
    wop = newWHILEOP(flags, 1, loop, forline, newOP(OP_ITER, 0), block, cont);
    PL_copline = forline;
    return newSTATEOP(0, label, wop);
d2649 3
a2651 1
newLOOPEX(I32 type, OP *label)
d2653 1
a2653 3
    dTHR;
    OP *o;
    STRLEN n_a;
d2655 4
a2658 8
	/* "last()" means "last" */
	if (label->op_type == OP_STUB && (label->op_flags & OPf_PARENS))
	    o = newOP(type, OPf_SPECIAL);
	else {
	    o = newPVOP(type, 0, savepv(label->op_type == OP_CONST
					? SvPVx(((SVOP*)label)->op_sv, n_a)
					: ""));
	}
d2664 1
a2664 1
	o = newUNOP(type, OPf_STACKED, label);
d2666 2
a2667 2
    PL_hints |= HINT_BLOCK_SCOPE;
    return o;
d2671 2
a2672 1
cv_undef(CV *cv)
a2673 9
    dTHR;
#ifdef USE_THREADS
    if (CvMUTEXP(cv)) {
	MUTEX_DESTROY(CvMUTEXP(cv));
	Safefree(CvMUTEXP(cv));
	CvMUTEXP(cv) = 0;
    }
#endif /* USE_THREADS */

a2674 4
#ifdef USE_THREADS
	if (CvDEPTH(cv) || (CvOWNER(cv) && CvOWNER(cv) != thr))
	    croak("Can't undef active subroutine");
#else
a2676 1
#endif /* USE_THREADS */
d2679 2
a2680 2
	SAVESPTR(PL_curpad);
	PL_curpad = 0;
a2686 2
    SvPOK_off((SV*)cv);		/* forget prototype */
    CvFLAGS(cv) = 0;
d2692 5
a2696 17
	/* may be during global destruction */
	if (SvREFCNT(CvPADLIST(cv))) {
	    I32 i = AvFILLp(CvPADLIST(cv));
	    while (i >= 0) {
		SV** svp = av_fetch(CvPADLIST(cv), i--, FALSE);
		SV* sv = svp ? *svp : Nullsv;
		if (!sv)
		    continue;
		if (sv == (SV*)PL_comppad_name)
		    PL_comppad_name = Nullav;
		else if (sv == (SV*)PL_comppad) {
		    PL_comppad = Nullav;
		    PL_curpad = Null(SV**);
		}
		SvREFCNT_dec(sv);
	    }
	    SvREFCNT_dec((SV*)CvPADLIST(cv));
d2698 1
d2703 3
a2705 4
#ifdef DEBUG_CLOSURES
STATIC void
cv_dump(cv)
CV* cv;
a2706 45
    CV *outside = CvOUTSIDE(cv);
    AV* padlist = CvPADLIST(cv);
    AV* pad_name;
    AV* pad;
    SV** pname;
    SV** ppad;
    I32 ix;

    PerlIO_printf(Perl_debug_log, "\tCV=0x%lx (%s), OUTSIDE=0x%lx (%s)\n",
		  cv,
		  (CvANON(cv) ? "ANON"
		   : (cv == PL_main_cv) ? "MAIN"
		   : CvUNIQUE(cv) ? "UNIQUE"
		   : CvGV(cv) ? GvNAME(CvGV(cv)) : "UNDEFINED"),
		  outside,
		  (!outside ? "null"
		   : CvANON(outside) ? "ANON"
		   : (outside == PL_main_cv) ? "MAIN"
		   : CvUNIQUE(outside) ? "UNIQUE"
		   : CvGV(outside) ? GvNAME(CvGV(outside)) : "UNDEFINED"));

    if (!padlist)
	return;

    pad_name = (AV*)*av_fetch(padlist, 0, FALSE);
    pad = (AV*)*av_fetch(padlist, 1, FALSE);
    pname = AvARRAY(pad_name);
    ppad = AvARRAY(pad);

    for (ix = 1; ix <= AvFILLp(pad_name); ix++) {
	if (SvPOK(pname[ix]))
	    PerlIO_printf(Perl_debug_log, "\t%4d. 0x%lx (%s\"%s\" %ld-%ld)\n",
			  ix, ppad[ix],
			  SvFAKE(pname[ix]) ? "FAKE " : "",
			  SvPVX(pname[ix]),
			  (long)I_32(SvNVX(pname[ix])),
			  (long)SvIVX(pname[ix]));
    }
}
#endif /* DEBUG_CLOSURES */

STATIC CV *
cv_clone2(CV *proto, CV *outside)
{
    dTHR;
d2712 1
a2712 4
    SV** pname = AvARRAY(protopad_name);
    SV** ppad = AvARRAY(protopad);
    I32 fname = AvFILLp(protopad_name);
    I32 fpad = AvFILLp(protopad);
a2715 2
    assert(!CvUNIQUE(proto));

d2717 3
a2719 4
    SAVESPTR(PL_curpad);
    SAVESPTR(PL_comppad);
    SAVESPTR(PL_comppad_name);
    SAVESPTR(PL_compcv);
d2721 2
a2722 2
    cv = PL_compcv = (CV*)NEWSV(1104,0);
    sv_upgrade((SV *)cv, SvTYPE(proto));
a2723 2
    if (CvANON(proto))
	CvANON_on(cv);
a2724 5
#ifdef USE_THREADS
    New(666, CvMUTEXP(cv), 1, perl_mutex);
    MUTEX_INIT(CvMUTEXP(cv));
    CvOWNER(cv)		= 0;
#endif /* USE_THREADS */
d2726 1
a2726 1
    CvGV(cv)		= (GV*)SvREFCNT_inc(CvGV(proto));
d2730 2
a2731 9
    if (outside)
	CvOUTSIDE(cv)	= (CV*)SvREFCNT_inc(outside);

    if (SvPOK(proto))
	sv_setpvn((SV*)cv, SvPVX(proto), SvCUR(proto));

    PL_comppad_name = newAV();
    for (ix = fname; ix >= 0; ix--)
	av_store(PL_comppad_name, ix, SvREFCNT_inc(pname[ix]));
d2733 1
a2733 1
    PL_comppad = newAV();
d2737 2
a2738 2
    av_store(comppadlist, 0, (SV*)PL_comppad_name);
    av_store(comppadlist, 1, (SV*)PL_comppad);
d2740 2
a2741 2
    av_fill(PL_comppad, AvFILLp(protopad));
    PL_curpad = AvARRAY(PL_comppad);
d2745 1
a2745 1
    av_store(PL_comppad, 0, (SV*)av);
d2748 9
a2756 10
    for (ix = fpad; ix > 0; ix--) {
	SV* namesv = (ix <= fname) ? pname[ix] : Nullsv;
	if (namesv && namesv != &PL_sv_undef) {
	    char *name = SvPVX(namesv);    /* XXX */
	    if (SvFLAGS(namesv) & SVf_FAKE) {   /* lexical from outside? */
		I32 off = pad_findlex(name, ix, SvIVX(namesv),
				      CvOUTSIDE(cv), cxstack_ix, 0, 0);
		if (!off)
		    PL_curpad[ix] = SvREFCNT_inc(ppad[ix]);
		else if (off != ix)
d2760 2
a2761 7
		SV* sv;
		if (*name == '&') {
		    /* anon code -- we'll come back for it */
		    sv = SvREFCNT_inc(ppad[ix]);
		}
		else if (*name == '@@')
		    sv = (SV*)newAV();
d2763 1
a2763 1
		    sv = (SV*)newHV();
d2765 2
a2766 4
		    sv = NEWSV(0,0);
		if (!SvPADBUSY(sv))
		    SvPADMY_on(sv);
		PL_curpad[ix] = sv;
d2770 1
a2770 1
	    SV* sv = NEWSV(0,0);
a2771 1
	    PL_curpad[ix] = sv;
a2774 27
    /* Now that vars are all in place, clone nested closures. */

    for (ix = fpad; ix > 0; ix--) {
	SV* namesv = (ix <= fname) ? pname[ix] : Nullsv;
	if (namesv
	    && namesv != &PL_sv_undef
	    && !(SvFLAGS(namesv) & SVf_FAKE)
	    && *SvPVX(namesv) == '&'
	    && CvCLONE(ppad[ix]))
	{
	    CV *kid = cv_clone2((CV*)ppad[ix], cv);
	    SvREFCNT_dec(ppad[ix]);
	    CvCLONE_on(kid);
	    SvPADMY_on(kid);
	    PL_curpad[ix] = (SV*)kid;
	}
    }

#ifdef DEBUG_CLOSURES
    PerlIO_printf(Perl_debug_log, "Cloned inside:\n");
    cv_dump(outside);
    PerlIO_printf(Perl_debug_log, "  from:\n");
    cv_dump(proto);
    PerlIO_printf(Perl_debug_log, "   to:\n");
    cv_dump(cv);
#endif

d2780 5
a2784 1
cv_clone(CV *proto)
d2786 6
a2791 6
    CV *cv;
    MUTEX_LOCK(&PL_cred_mutex);		/* XXX create separate mutex */
    cv = cv_clone2(proto, CvOUTSIDE(proto));
    MUTEX_UNLOCK(&PL_cred_mutex);	/* XXX create separate mutex */
    return cv;
}
d2793 8
a2800 22
void
cv_ckproto(CV *cv, GV *gv, char *p)
{
    if ((!p != !SvPOK(cv)) || (p && strNE(p, SvPVX(cv)))) {
	SV* msg = sv_newmortal();
	SV* name = Nullsv;

	if (gv)
	    gv_efullname3(name = sv_newmortal(), gv, Nullch);
	sv_setpv(msg, "Prototype mismatch:");
	if (name)
	    sv_catpvf(msg, " sub %_", name);
	if (SvPOK(cv))
	    sv_catpvf(msg, " (%s)", SvPVX(cv));
	sv_catpv(msg, " vs ");
	if (p)
	    sv_catpvf(msg, "(%s)", p);
	else
	    sv_catpv(msg, "none");
	warn("%_", msg);
    }
}
d2802 3
a2804 107
SV *
cv_const_sv(CV *cv)
{
    if (!cv || !SvPOK(cv) || SvCUR(cv))
	return Nullsv;
    return op_const_sv(CvSTART(cv), cv);
}

SV *
op_const_sv(OP *o, CV *cv)
{
    SV *sv = Nullsv;

    if(!o)
	return Nullsv;
 
    if(o->op_type == OP_LINESEQ && cLISTOPo->op_first) 
	o = cLISTOPo->op_first->op_sibling;

    for (; o; o = o->op_next) {
	OPCODE type = o->op_type;

	if(sv && o->op_next == o) 
	    return sv;
	if (type == OP_NEXTSTATE || type == OP_NULL || type == OP_PUSHMARK)
	    continue;
	if (type == OP_LEAVESUB || type == OP_RETURN)
	    break;
	if (sv)
	    return Nullsv;
	if (type == OP_CONST)
	    sv = cSVOPo->op_sv;
	else if (type == OP_PADSV && cv) {
	    AV* padav = (AV*)(AvARRAY(CvPADLIST(cv))[1]);
	    sv = padav ? AvARRAY(padav)[o->op_targ] : Nullsv;
	    if (!sv || (!SvREADONLY(sv) && SvREFCNT(sv) > 1))
		return Nullsv;
	}
	else
	    return Nullsv;
    }
    if (sv)
	SvREADONLY_on(sv);
    return sv;
}

CV *
newSUB(I32 floor, OP *o, OP *proto, OP *block)
{
    dTHR;
    STRLEN n_a;
    char *name = o ? SvPVx(cSVOPo->op_sv, n_a) : Nullch;
    GV *gv = gv_fetchpv(name ? name : "__ANON__",
			GV_ADDMULTI | (block ? 0 : GV_NOINIT), SVt_PVCV);
    char *ps = proto ? SvPVx(((SVOP*)proto)->op_sv, n_a) : Nullch;
    register CV *cv=0;
    I32 ix;

    if (o)
	SAVEFREEOP(o);
    if (proto)
	SAVEFREEOP(proto);

    if (SvTYPE(gv) != SVt_PVGV) {	/* Prototype now, and had
					   maximum a prototype before. */
	if (SvTYPE(gv) > SVt_NULL) {
	    if (!SvPOK((SV*)gv) && !(SvIOK((SV*)gv) && SvIVX((SV*)gv) == -1))
		warn("Runaway prototype");
	    cv_ckproto((CV*)gv, NULL, ps);
	}
	if (ps)
	    sv_setpv((SV*)gv, ps);
	else
	    sv_setiv((SV*)gv, -1);
	SvREFCNT_dec(PL_compcv);
	cv = PL_compcv = NULL;
	PL_sub_generation++;
	goto noblock;
    }

    if (!name || GvCVGEN(gv))
	cv = Nullcv;
    else if (cv = GvCV(gv)) {
	cv_ckproto(cv, gv, ps);
	/* already defined (or promised)? */
	if (CvROOT(cv) || CvXSUB(cv) || GvASSUMECV(gv)) {
	    SV* const_sv;
	    bool const_changed = TRUE;
	    if (!block) {
		/* just a "sub foo;" when &foo is already defined */
		SAVEFREESV(PL_compcv);
		goto done;
	    }
	    /* ahem, death to those who redefine active sort subs */
	    if (PL_curstackinfo->si_type == PERLSI_SORT && PL_sortcop == CvSTART(cv))
		croak("Can't redefine active sort subroutine %s", name);
	    if(const_sv = cv_const_sv(cv))
		const_changed = sv_cmp(const_sv, op_const_sv(block, Nullcv));
	    if ((const_sv && const_changed) || PL_dowarn && !(CvGV(cv) && GvSTASH(CvGV(cv))
					&& HvNAME(GvSTASH(CvGV(cv)))
					&& strEQ(HvNAME(GvSTASH(CvGV(cv))),
						 "autouse"))) {
		line_t oldline = PL_curcop->cop_line;
		PL_curcop->cop_line = PL_copline;
		warn(const_sv ? "Constant subroutine %s redefined"
		     : "Subroutine %s redefined", name);
		PL_curcop->cop_line = oldline;
d2807 1
a2807 1
	    cv = Nullcv;
d2812 7
a2818 8
	CvFLAGS(cv) = CvFLAGS(PL_compcv);
	CvOUTSIDE(cv) = CvOUTSIDE(PL_compcv);
	CvOUTSIDE(PL_compcv) = 0;
	CvPADLIST(cv) = CvPADLIST(PL_compcv);
	CvPADLIST(PL_compcv) = 0;
	if (SvREFCNT(PL_compcv) > 1) /* XXX Make closures transit through stub. */
	    CvOUTSIDE(PL_compcv) = (CV*)SvREFCNT_inc((SV*)cv);
	SvREFCNT_dec(PL_compcv);
d2821 14
a2834 15
	cv = PL_compcv;
	if (name) {
	    GvCV(gv) = cv;
	    GvCVGEN(gv) = 0;
	    PL_sub_generation++;
	}
    }
    CvGV(cv) = (GV*)SvREFCNT_inc(gv);
    CvFILEGV(cv) = PL_curcop->cop_filegv;
    CvSTASH(cv) = PL_curstash;
#ifdef USE_THREADS
    CvOWNER(cv) = 0;
    if (!CvMUTEXP(cv)) {
	New(666, CvMUTEXP(cv), 1, perl_mutex);
	MUTEX_INIT(CvMUTEXP(cv));
a2835 4
#endif /* USE_THREADS */

    if (ps)
	sv_setpv((SV*)cv, ps);
d2837 1
a2837 1
    if (PL_error_count) {
a2839 15
	if (name) {
	    char *s = strrchr(name, ':');
	    s = s ? s+1 : name;
	    if (strEQ(s, "BEGIN")) {
		char *not_safe =
		    "BEGIN not safe after errors--compilation aborted";
		if (PL_in_eval & 4)
		    croak(not_safe);
		else {
		    /* force display of errors found but not reported */
		    sv_catpv(ERRSV, not_safe);
		    croak("%s", SvPVx(ERRSV, n_a));
		}
	    }
	}
d2842 3
a2844 2
      noblock:
	PL_copline = NOLINE;
d2849 4
a2852 7
    if (AvFILLp(PL_comppad_name) < AvFILLp(PL_comppad))
	av_store(PL_comppad_name, AvFILLp(PL_comppad), Nullsv);

    if (CvCLONE(cv)) {
	SV **namep = AvARRAY(PL_comppad_name);
	for (ix = AvFILLp(PL_comppad); ix > 0; ix--) {
	    SV *namesv;
d2854 3
a2856 16
	    if (SvIMMORTAL(PL_curpad[ix]))
		continue;
	    /*
	     * The only things that a clonable function needs in its
	     * pad are references to outer lexicals and anonymous subs.
	     * The rest are created anew during cloning.
	     */
	    if (!((namesv = namep[ix]) != Nullsv &&
		  namesv != &PL_sv_undef &&
		  (SvFAKE(namesv) ||
		   *SvPVX(namesv) == '&')))
	    {
		SvREFCNT_dec(PL_curpad[ix]);
		PL_curpad[ix] = Nullsv;
	    }
	}
a2857 5
    else {
	AV *av = newAV();			/* Will be @@_ */
	av_extend(av, 0);
	av_store(PL_comppad, 0, (SV*)av);
	AvFLAGS(av) = AVf_REIFY;
d2859 2
a2860 7
	for (ix = AvFILLp(PL_comppad); ix > 0; ix--) {
	    if (SvIMMORTAL(PL_curpad[ix]))
		continue;
	    if (!SvPADMY(PL_curpad[ix]))
		SvPADTMP_on(PL_curpad[ix]);
	}
    }
d2866 7
d2874 33
a2906 61
    if (name) {
	char *s;

	if (PERLDB_SUBLINE && PL_curstash != PL_debstash) {
	    SV *sv = NEWSV(0,0);
	    SV *tmpstr = sv_newmortal();
	    GV *db_postponed = gv_fetchpv("DB::postponed", GV_ADDMULTI, SVt_PVHV);
	    CV *cv;
	    HV *hv;

	    sv_setpvf(sv, "%_:%ld-%ld",
		    GvSV(PL_curcop->cop_filegv),
		    (long)PL_subline, (long)PL_curcop->cop_line);
	    gv_efullname3(tmpstr, gv, Nullch);
	    hv_store(GvHV(PL_DBsub), SvPVX(tmpstr), SvCUR(tmpstr), sv, 0);
	    hv = GvHVn(db_postponed);
	    if (HvFILL(hv) > 0 && hv_exists(hv, SvPVX(tmpstr), SvCUR(tmpstr))
		  && (cv = GvCV(db_postponed))) {
		dSP;
		PUSHMARK(SP);
		XPUSHs(tmpstr);
		PUTBACK;
		perl_call_sv((SV*)cv, G_DISCARD);
	    }
	}

	if ((s = strrchr(name,':')))
	    s++;
	else
	    s = name;
	if (strEQ(s, "BEGIN")) {
	    I32 oldscope = PL_scopestack_ix;
	    ENTER;
	    SAVESPTR(PL_compiling.cop_filegv);
	    SAVEI16(PL_compiling.cop_line);
	    save_svref(&PL_rs);
	    sv_setsv(PL_rs, PL_nrs);

	    if (!PL_beginav)
		PL_beginav = newAV();
	    DEBUG_x( dump_sub(gv) );
	    av_push(PL_beginav, (SV *)cv);
	    GvCV(gv) = 0;
	    call_list(oldscope, PL_beginav);

	    PL_curcop = &PL_compiling;
	    LEAVE;
	}
	else if (strEQ(s, "END") && !PL_error_count) {
	    if (!PL_endav)
		PL_endav = newAV();
	    av_unshift(PL_endav, 1);
	    av_store(PL_endav, 0, (SV *)cv);
	    GvCV(gv) = 0;
	}
	else if (strEQ(s, "INIT") && !PL_error_count) {
	    if (!PL_initav)
		PL_initav = newAV();
	    av_push(PL_initav, SvREFCNT_inc(cv));
	    GvCV(gv) = 0;
	}
d2908 2
a2909 3

  done:
    PL_copline = NOLINE;
d2911 4
d2918 12
a2929 26
/* XXX unsafe for threads if eval_owner isn't held */
void
newCONSTSUB(HV *stash, char *name, SV *sv)
{
    dTHR;
    U32 oldhints = PL_hints;
    HV *old_cop_stash = PL_curcop->cop_stash;
    HV *old_curstash = PL_curstash;
    line_t oldline = PL_curcop->cop_line;
    PL_curcop->cop_line = PL_copline;

    PL_hints &= ~HINT_BLOCK_SCOPE;
    if(stash)
	PL_curstash = PL_curcop->cop_stash = stash;

    newSUB(
	start_subparse(FALSE, 0),
	newSVOP(OP_CONST, 0, newSVpv(name,0)),
	newSVOP(OP_CONST, 0, &PL_sv_no),	/* SvPV(&PL_sv_no) == "" -- GMB */
	newSTATEOP(0, Nullch, newSVOP(OP_CONST, 0, sv))
    );

    PL_hints = oldhints;
    PL_curcop->cop_stash = old_cop_stash;
    PL_curstash = old_curstash;
    PL_curcop->cop_line = oldline;
d2931 1
d2934 4
a2937 1
newXS(char *name, void (*subaddr) (CV * _CPERLproto), char *filename)
a2938 2
    dTHR;
    GV *gv = gv_fetchpv(name ? name : "__ANON__", GV_ADDMULTI, SVt_PVCV);
d2940 11
d2952 1
a2952 14
    if (cv = (name ? GvCV(gv) : Nullcv)) {
	if (GvCVGEN(gv)) {
	    /* just a cached method */
	    SvREFCNT_dec(cv);
	    cv = 0;
	}
	else if (CvROOT(cv) || CvXSUB(cv) || GvASSUMECV(gv)) {
	    /* already defined (or promised) */
	    if (PL_dowarn && !(CvGV(cv) && GvSTASH(CvGV(cv))
			    && HvNAME(GvSTASH(CvGV(cv)))
			    && strEQ(HvNAME(GvSTASH(CvGV(cv))), "autouse"))) {
		line_t oldline = PL_curcop->cop_line;
		if (PL_copline != NOLINE)
		    PL_curcop->cop_line = PL_copline;
d2954 1
a2954 1
		PL_curcop->cop_line = oldline;
d2960 4
a2963 3

    if (cv)				/* must reuse cv if autoloaded */
	cv_undef(cv);
a2966 5
	if (name) {
	    GvCV(gv) = cv;
	    GvCVGEN(gv) = 0;
	    PL_sub_generation++;
	}
d2968 3
a2970 6
    CvGV(cv) = (GV*)SvREFCNT_inc(gv);
#ifdef USE_THREADS
    New(666, CvMUTEXP(cv), 1, perl_mutex);
    MUTEX_INIT(CvMUTEXP(cv));
    CvOWNER(cv) = 0;
#endif /* USE_THREADS */
d2973 16
a2988 26

    if (name) {
	char *s = strrchr(name,':');
	if (s)
	    s++;
	else
	    s = name;
	if (strEQ(s, "BEGIN")) {
	    if (!PL_beginav)
		PL_beginav = newAV();
	    av_push(PL_beginav, (SV *)cv);
	    GvCV(gv) = 0;
	}
	else if (strEQ(s, "END")) {
	    if (!PL_endav)
		PL_endav = newAV();
	    av_unshift(PL_endav, 1);
	    av_store(PL_endav, 0, (SV *)cv);
	    GvCV(gv) = 0;
	}
	else if (strEQ(s, "INIT")) {
	    if (!PL_initav)
		PL_initav = newAV();
	    av_push(PL_initav, (SV *)cv);
	    GvCV(gv) = 0;
	}
d2990 2
a2991 1
    else
d2993 1
a2993 1

d2998 4
a3001 1
newFORM(I32 floor, OP *o, OP *block)
a3002 1
    dTHR;
a3006 1
    STRLEN n_a;
d3008 2
a3009 2
    if (o)
	name = SvPVx(cSVOPo->op_sv, n_a);
d3015 2
a3016 2
	if (PL_dowarn) {
	    line_t oldline = PL_curcop->cop_line;
d3018 1
a3018 1
	    PL_curcop->cop_line = PL_copline;
d3020 1
a3020 1
	    PL_curcop->cop_line = oldline;
d3024 1
a3024 1
    cv = PL_compcv;
d3026 2
a3027 2
    CvGV(cv) = (GV*)SvREFCNT_inc(gv);
    CvFILEGV(cv) = PL_curcop->cop_filegv;
d3029 3
a3031 3
    for (ix = AvFILLp(PL_comppad); ix > 0; ix--) {
	if (!SvPADMY(PL_curpad[ix]) && !SvIMMORTAL(PL_curpad[ix]))
	    SvPADTMP_on(PL_curpad[ix]);
d3038 3
a3040 2
    op_free(o);
    PL_copline = NOLINE;
d3045 2
a3046 1
newANONLIST(OP *o)
d3049 1
a3049 1
	mod(list(convert(OP_ANONLIST, 0, o)), OP_REFGEN));
d3053 2
a3054 1
newANONHASH(OP *o)
d3057 1
a3057 1
	mod(list(convert(OP_ANONHASH, 0, o)), OP_REFGEN));
d3061 4
a3064 1
newANONSUB(I32 floor, OP *proto, OP *block)
d3071 2
a3072 1
oopsAV(OP *o)
d3078 1
a3078 1
	return ref(o, OP_RV2AV);
d3094 2
a3095 1
oopsHV(OP *o)
d3102 1
a3102 1
	return ref(o, OP_RV2HV);
d3119 2
a3120 1
newAVREF(OP *o)
d3131 3
a3133 1
newGVREF(I32 type, OP *o)
d3135 1
a3135 1
    if (type == OP_MAPSTART || type == OP_GREPSTART)
d3141 2
a3142 1
newHVREF(OP *o)
d3153 2
a3154 1
oopsCV(OP *o)
d3162 3
a3164 1
newCVREF(I32 flags, OP *o)
d3170 2
a3171 1
newSVREF(OP *o)
a3177 4
    else if (o->op_type == OP_THREADSV && !(o->op_flags & OPpDONE_SVREF)) {
	o->op_flags |= OPpDONE_SVREF;
	return o;
    }
d3184 2
a3185 1
ck_anoncode(OP *o)
d3187 3
a3189 22
    PADOFFSET ix;
    SV* name;

    name = NEWSV(1106,0);
    sv_upgrade(name, SVt_PVNV);
    sv_setpvn(name, "&", 1);
    SvIVX(name) = -1;
    SvNVX(name) = 1;
    ix = pad_alloc(o->op_type, SVs_PADMY);
    av_store(PL_comppad_name, ix, name);
    av_store(PL_comppad, ix, cSVOPo->op_sv);
    SvPADMY_on(cSVOPo->op_sv);
    cSVOPo->op_sv = Nullsv;
    cSVOPo->op_targ = ix;
    return o;
}

OP *
ck_bitop(OP *o)
{
    o->op_private = PL_hints;
    return o;
d3193 2
a3194 1
ck_concat(OP *o)
d3196 1
a3196 9
    if (cUNOPo->op_first->op_type == OP_CONCAT)
	o->op_flags |= OPf_STACKED;
    return o;
}

OP *
ck_spair(OP *o)
{
    if (o->op_flags & OPf_KIDS) {
d3199 2
a3200 3
	OPCODE type = o->op_type;
	o = modkids(ck_fun(o), type);
	kid = cUNOPo->op_first;
d3207 2
a3208 2
	
	    return o;
d3213 2
a3214 2
    o->op_ppaddr = ppaddr[++o->op_type];
    return ck_fun(o);
d3218 2
a3219 1
ck_delete(OP *o)
d3221 5
a3225 9
    o = ck_fun(o);
    o->op_private = 0;
    if (o->op_flags & OPf_KIDS) {
	OP *kid = cUNOPo->op_first;
	if (kid->op_type == OP_HSLICE)
	    o->op_private |= OPpSLICE;
	else if (kid->op_type != OP_HELEM)
	    croak("%s argument is not a HASH element or slice",
		  op_desc[o->op_type]);
d3228 1
a3228 1
    return o;
d3232 2
a3233 1
ck_eof(OP *o)
d3235 1
a3235 1
    I32 type = o->op_type;
d3237 5
a3241 5
    if (o->op_flags & OPf_KIDS) {
	if (cLISTOPo->op_first->op_type == OP_STUB) {
	    op_free(o);
	    o = newUNOP(type, OPf_SPECIAL,
		newGVOP(OP_GV, 0, gv_fetchpv("main::ARGV", TRUE, SVt_PVAV)));
d3243 1
a3243 1
	return ck_fun(o);
d3245 1
a3245 1
    return o;
d3249 2
a3250 1
ck_eval(OP *o)
d3252 3
a3254 3
    PL_hints |= HINT_BLOCK_SCOPE;
    if (o->op_flags & OPf_KIDS) {
	SVOP *kid = (SVOP*)cUNOPo->op_first;
d3257 2
a3258 2
	    o->op_flags &= ~OPf_KIDS;
	    null(o);
d3263 3
a3265 3
	    kid->op_next = o->op_next;
	    cUNOPo->op_first = 0;
	    op_free(o);
d3275 5
a3279 5
	    o = prepend_elem(OP_LINESEQ, (OP*)enter, (OP*)kid);
	    o->op_type = OP_LEAVETRY;
	    o->op_ppaddr = ppaddr[OP_LEAVETRY];
	    enter->op_other = o;
	    return o;
a3280 2
	else
	    scalar((OP*)kid);
d3283 2
a3284 2
	op_free(o);
	o = newUNOP(OP_ENTEREVAL, 0, newDEFSVOP());
d3286 2
a3287 2
    o->op_targ = (PADOFFSET)PL_hints;
    return o;
d3291 2
a3292 1
ck_exec(OP *o)
d3295 3
a3297 3
    if (o->op_flags & OPf_STACKED) {
	o = ck_fun(o);
	kid = cUNOPo->op_first->op_sibling;
d3302 2
a3303 2
	o = listkids(o);
    return o;
d3307 2
a3308 14
ck_exists(OP *o)
{
    o = ck_fun(o);
    if (o->op_flags & OPf_KIDS) {
	OP *kid = cUNOPo->op_first;
	if (kid->op_type != OP_HELEM)
	    croak("%s argument is not a HASH element", op_desc[o->op_type]);
	null(kid);
    }
    return o;
}

OP *
ck_gvconst(register OP *o)
d3317 2
a3318 1
ck_rvconst(register OP *o)
d3320 1
a3320 2
    dTHR;
    SVOP *kid = (SVOP*)cUNOPo->op_first;
d3322 1
a3322 1
    o->op_private |= (PL_hints & HINT_STRICT_REFS);
d3324 13
a3336 74
	char *name;
	int iscv;
	GV *gv;
	SV *kidsv = kid->op_sv;
	STRLEN n_a;

	/* Is it a constant from cv_const_sv()? */
	if (SvROK(kidsv) && SvREADONLY(kidsv)) {
	    SV *rsv = SvRV(kidsv);
	    int svtype = SvTYPE(rsv);
	    char *badtype = Nullch;

	    switch (o->op_type) {
	    case OP_RV2SV:
		if (svtype > SVt_PVMG)
		    badtype = "a SCALAR";
		break;
	    case OP_RV2AV:
		if (svtype != SVt_PVAV)
		    badtype = "an ARRAY";
		break;
	    case OP_RV2HV:
		if (svtype != SVt_PVHV) {
		    if (svtype == SVt_PVAV) {	/* pseudohash? */
			SV **ksv = av_fetch((AV*)rsv, 0, FALSE);
			if (ksv && SvROK(*ksv)
			    && SvTYPE(SvRV(*ksv)) == SVt_PVHV)
			{
				break;
			}
		    }
		    badtype = "a HASH";
		}
		break;
	    case OP_RV2CV:
		if (svtype != SVt_PVCV)
		    badtype = "a CODE";
		break;
	    }
	    if (badtype)
		croak("Constant is not %s reference", badtype);
	    return o;
	}
	name = SvPV(kidsv, n_a);

	if ((PL_hints & HINT_STRICT_REFS) && (kid->op_private & OPpCONST_BARE)) {
	    char *badthing = Nullch;
	    switch (o->op_type) {
	    case OP_RV2SV:
		badthing = "a SCALAR";
		break;
	    case OP_RV2AV:
		badthing = "an ARRAY";
		break;
	    case OP_RV2HV:
		badthing = "a HASH";
		break;
	    }
	    if (badthing)
		croak(
	  "Can't use bareword (\"%s\") as %s ref while \"strict refs\" in use",
		      name, badthing);
	}
	/*
	 * This is a little tricky.  We only want to add the symbol if we
	 * didn't add it in the lexer.  Otherwise we get duplicate strict
	 * warnings.  But if we didn't add it in the lexer, we must at
	 * least pretend like we wanted to add it even if it existed before,
	 * or we get possible typo warnings.  OPpCONST_ENTERED says
	 * whether the lexer already added THIS instance of this symbol.
	 */
	iscv = (o->op_type == OP_RV2CV) * 2;
	do {
	    gv = gv_fetchpv(name,
d3340 1
a3340 1
		    : o->op_type == OP_RV2SV
d3342 1
a3342 1
			: o->op_type == OP_RV2AV
d3344 1
a3344 1
			    : o->op_type == OP_RV2HV
a3346 5
	} while (!gv && !(kid->op_private & OPpCONST_ENTERED) && !iscv++);
	if (gv) {
	    kid->op_type = OP_GV;
	    SvREFCNT_dec(kid->op_sv);
	    kid->op_sv = SvREFCNT_inc(gv);
d3348 2
d3351 8
a3358 1
    return o;
d3362 2
a3363 1
ck_ftst(OP *o)
d3365 1
a3365 2
    dTHR;
    I32 type = o->op_type;
d3367 2
a3368 2
    if (o->op_flags & OPf_REF)
	return o;
d3370 2
a3371 2
    if (o->op_flags & OPf_KIDS && cUNOPo->op_first->op_type != OP_STUB) {
	SVOP *kid = (SVOP*)cUNOPo->op_first;
a3373 1
	    STRLEN n_a;
d3375 2
a3376 2
		gv_fetchpv(SvPVx(kid->op_sv, n_a), TRUE, SVt_PVIO));
	    op_free(o);
d3381 1
a3381 1
	op_free(o);
d3383 1
a3383 1
           return newGVOP(type, OPf_REF, gv_fetchpv("main::STDIN", TRUE,
d3386 1
a3386 1
	    return newUNOP(type, 0, newDEFSVOP());
d3388 1
a3388 1
    return o;
d3392 2
a3393 1
ck_fun(OP *o)
a3394 1
    dTHR;
d3399 1
a3399 1
    int type = o->op_type;
d3401 2
a3402 2

    if (o->op_flags & OPf_STACKED) {
d3406 1
a3406 1
	    return no_fh_allowed(o);
d3409 3
a3411 4
    if (o->op_flags & OPf_KIDS) {
	STRLEN n_a;
	tokid = &cLISTOPo->op_first;
	kid = cLISTOPo->op_first;
d3419 1
a3419 1
	    *tokid = kid = newDEFSVOP();
d3439 1
a3439 1
		    char *name = SvPVx(((SVOP*)kid)->op_sv, n_a);
d3442 3
a3444 3
		    if (PL_dowarn)
			warn("Array @@%s missing the @@ in argument %ld of %s()",
			    name, (long)numargs, op_desc[type]);
d3451 1
a3451 1
		    bad_type(numargs, "array", op_desc[o->op_type], kid);
d3457 1
a3457 1
		    char *name = SvPVx(((SVOP*)kid)->op_sv, n_a);
d3460 3
a3462 3
		    if (PL_dowarn)
			warn("Hash %%%s missing the %% in argument %ld of %s()",
			    name, (long)numargs, op_desc[type]);
d3469 1
a3469 1
		    bad_type(numargs, "hash", op_desc[o->op_type], kid);
d3484 1
a3484 1
		if (kid->op_type != OP_GV && kid->op_type != OP_RV2GV) {
d3488 1
a3488 1
			    gv_fetchpv(SvPVx(((SVOP*)kid)->op_sv, n_a), TRUE,
a3492 4
		    else if (kid->op_type == OP_READLINE) {
			/* neophyte patrol: open(<FH>), close(<FH>) etc. */
			bad_type(numargs, "HANDLE", op_desc[o->op_type], kid);
		    }
d3510 1
a3510 1
	o->op_private |= numargs;
d3512 2
a3513 2
	    return too_many_arguments(o,op_desc[o->op_type]);
	listkids(o);
d3516 2
a3517 2
	op_free(o);
	return newUNOP(type, 0, newDEFSVOP());
d3524 1
a3524 1
	    return too_few_arguments(o,op_desc[o->op_type]);
d3526 1
a3526 1
    return o;
d3530 2
a3531 1
ck_glob(OP *o)
d3533 1
a3533 28
    GV *gv;

    if ((o->op_flags & OPf_KIDS) && !cLISTOPo->op_first->op_sibling)
	append_elem(OP_GLOB, o, newDEFSVOP());

    if (!((gv = gv_fetchpv("glob", FALSE, SVt_PVCV)) && GvIMPORTED_CV(gv)))
	gv = gv_fetchpv("CORE::GLOBAL::glob", FALSE, SVt_PVCV);

    if (gv && GvIMPORTED_CV(gv)) {
#ifndef PERL_OBJECT
	static int glob_index;
#endif

	append_elem(OP_GLOB, o,
		    newSVOP(OP_CONST, 0, newSViv(glob_index++)));
	o->op_type = OP_LIST;
	o->op_ppaddr = ppaddr[OP_LIST];
	cLISTOPo->op_first->op_type = OP_PUSHMARK;
	cLISTOPo->op_first->op_ppaddr = ppaddr[OP_PUSHMARK];
	o = newUNOP(OP_ENTERSUB, OPf_STACKED,
		    append_elem(OP_LIST, o,
				scalar(newUNOP(OP_RV2CV, 0,
					       newGVOP(OP_GV, 0, gv)))));
	o = newUNOP(OP_NULL, 0, ck_subr(o));
	o->op_targ = OP_GLOB;		/* hint at what it used to be */
	return o;
    }
    gv = newGVgen("main");
d3535 3
a3537 3
    append_elem(OP_GLOB, o, newGVOP(OP_GV, 0, gv));
    scalarkids(o);
    return ck_fun(o);
d3541 2
a3542 1
ck_grep(OP *o)
d3546 1
a3546 1
    OPCODE type = o->op_type == OP_GREPSTART ? OP_GREPWHILE : OP_MAPWHILE;
d3548 1
a3548 1
    o->op_ppaddr = ppaddr[OP_GREPSTART];
d3550 2
a3551 2

    if (o->op_flags & OPf_STACKED) {
d3553 3
a3555 3
	o = ck_sort(o);
        kid = cLISTOPo->op_first->op_sibling;
	for (k = cLISTOPo->op_first->op_sibling->op_next; k; k = k->op_next) {
d3559 1
a3559 1
	o->op_flags &= ~OPf_STACKED;
d3561 1
a3561 1
    kid = cLISTOPo->op_first->op_sibling;
d3566 4
a3569 4
    o = ck_fun(o);
    if (PL_error_count)
	return o;
    kid = cLISTOPo->op_first->op_sibling;
d3576 1
a3576 1
    gwop->op_first = listkids(o);
d3583 1
a3583 1
    kid = cLISTOPo->op_first->op_sibling;
d3585 1
a3585 1
	return too_few_arguments(o,op_desc[o->op_type]);
d3593 2
a3594 1
ck_index(OP *o)
d3596 2
a3597 4
    if (o->op_flags & OPf_KIDS) {
	OP *kid = cLISTOPo->op_first->op_sibling;	/* get past pushmark */
	if (kid)
	    kid = kid->op_sibling;			/* get past "big" */
d3601 1
a3601 1
    return ck_fun(o);
d3605 2
a3606 1
ck_lengthconst(OP *o)
d3609 1
a3609 1
    return ck_fun(o);
d3613 2
a3614 1
ck_lfun(OP *o)
d3616 1
a3616 2
    OPCODE type = o->op_type;
    return modkids(ck_fun(o), type);
d3620 2
a3621 1
ck_rfun(OP *o)
d3623 1
a3623 2
    OPCODE type = o->op_type;
    return refkids(ck_fun(o), type);
d3627 2
a3628 1
ck_listiob(OP *o)
d3631 2
a3632 2

    kid = cLISTOPo->op_first;
d3634 2
a3635 2
	o = force_list(o);
	kid = cLISTOPo->op_first;
d3639 1
a3639 1
    if (kid && o->op_flags & OPf_STACKED)
d3643 1
a3643 1
	    o->op_flags |= OPf_STACKED;	/* make it a filehandle */
d3645 2
a3646 2
	    cLISTOPo->op_first->op_sibling = kid;
	    cLISTOPo->op_last = kid;
d3652 1
a3652 9
	append_elem(o->op_type, o, newDEFSVOP());

    o = listkids(o);

    o->op_private = 0;
#ifdef USE_LOCALE
    if (PL_hints & HINT_LOCALE)
	o->op_private |= OPpLOCALE;
#endif
d3654 1
a3654 1
    return o;
d3658 2
a3659 1
ck_fun_locale(OP *o)
d3661 3
a3663 9
    o = ck_fun(o);

    o->op_private = 0;
#ifdef USE_LOCALE
    if (PL_hints & HINT_LOCALE)
	o->op_private |= OPpLOCALE;
#endif

    return o;
d3667 2
a3668 1
ck_scmp(OP *o)
d3670 1
a3670 7
    o->op_private = 0;
#ifdef USE_LOCALE
    if (PL_hints & HINT_LOCALE)
	o->op_private |= OPpLOCALE;
#endif

    return o;
d3674 2
a3675 1
ck_match(OP *o)
d3677 3
a3679 16
    o->op_private |= OPpRUNTIME;
    return o;
}

OP *
ck_null(OP *o)
{
    return o;
}

OP *
ck_repeat(OP *o)
{
    if (cBINOPo->op_first->op_flags & OPf_PARENS) {
	o->op_private |= OPpREPEAT_DOLIST;
	cBINOPo->op_first = force_list(cBINOPo->op_first);
d3682 2
a3683 2
	scalar(o);
    return o;
d3687 2
a3688 1
ck_require(OP *o)
d3690 2
a3691 2
    if (o->op_flags & OPf_KIDS) {	/* Shall we supply missing .pm? */
	SVOP *kid = (SVOP*)cUNOPo->op_first;
d3705 1
a3705 1
    return ck_fun(o);
d3709 2
a3710 1
ck_retarget(OP *o)
d3714 1
a3714 1
    return o;
d3718 2
a3719 1
ck_select(OP *o)
d3722 2
a3723 2
    if (o->op_flags & OPf_KIDS) {
	kid = cLISTOPo->op_first->op_sibling;	/* get past pushmark */
d3725 4
a3728 4
	    o->op_type = OP_SSELECT;
	    o->op_ppaddr = ppaddr[OP_SSELECT];
	    o = ck_fun(o);
	    return fold_constants(o);
d3731 2
a3732 2
    o = ck_fun(o);
    kid = cLISTOPo->op_first->op_sibling;    /* get past pushmark */
d3735 1
a3735 1
    return o;
d3739 2
a3740 1
ck_shift(OP *o)
d3742 1
a3742 1
    I32 type = o->op_type;
d3744 4
a3747 11
    if (!(o->op_flags & OPf_KIDS)) {
	OP *argop;
	
	op_free(o);
#ifdef USE_THREADS
	if (!CvUNIQUE(PL_compcv)) {
	    argop = newOP(OP_PADAV, OPf_REF);
	    argop->op_targ = 0;		/* PL_curpad[0] is @@_ */
	}
	else {
	    argop = newUNOP(OP_RV2AV, 0,
d3749 1
a3749 8
		    gv_fetchpv("ARGV", TRUE, SVt_PVAV))));
	}
#else
	argop = newUNOP(OP_RV2AV, 0,
	    scalar(newGVOP(OP_GV, 0, !CvUNIQUE(PL_compcv) ?
			   PL_defgv : gv_fetchpv("ARGV", TRUE, SVt_PVAV))));
#endif /* USE_THREADS */
	return newUNOP(type, 0, scalar(argop));
d3751 1
a3751 1
    return scalar(modkids(ck_fun(o), type));
d3755 2
a3756 1
ck_sort(OP *o)
d3758 2
a3759 8
    o->op_private = 0;
#ifdef USE_LOCALE
    if (PL_hints & HINT_LOCALE)
	o->op_private |= OPpLOCALE;
#endif

    if (o->op_flags & OPf_STACKED) {
	OP *kid = cLISTOPo->op_first->op_sibling;	/* get past pushmark */
a3760 5

	if (o->op_type == OP_SORT) {
	    GvMULTI_on(gv_fetchpv("a", TRUE, SVt_PV));
	    GvMULTI_on(gv_fetchpv("b", TRUE, SVt_PV));
	}
d3770 1
a3770 1
		if (o->op_type == OP_SORT) {
d3785 1
a3785 1
	    kid = cLISTOPo->op_first->op_sibling;	/* get past pushmark */
d3787 1
a3787 1
	    if (o->op_type == OP_SORT)
d3791 1
a3791 1
	    o->op_flags |= OPf_SPECIAL;
d3793 2
a3794 5
	else if (kid->op_type == OP_RV2SV || kid->op_type == OP_PADSV)
	    null(cLISTOPo->op_first->op_sibling);
     }

    return o;
d3798 2
a3799 1
ck_split(OP *o)
d3802 4
d3807 1
a3807 4
    if (o->op_flags & OPf_STACKED)
	return no_fh_allowed(o);

    kid = cLISTOPo->op_first;
d3811 2
a3812 2
    op_free(cLISTOPo->op_first);
    cLISTOPo->op_first = kid;
d3814 2
a3815 2
	cLISTOPo->op_first = kid = newSVOP(OP_CONST, 0, newSVpv(" ", 1));
	cLISTOPo->op_last = kid; /* There was only one element previously */
d3822 3
a3824 3
	if (cLISTOPo->op_first == cLISTOPo->op_last)
	    cLISTOPo->op_last = kid;
	cLISTOPo->op_first = kid;
d3827 5
d3838 1
a3838 1
	append_elem(OP_SPLIT, o, newDEFSVOP());
d3844 1
a3844 1
	append_elem(OP_SPLIT, o, newSVOP(OP_CONST, 0, newSViv(0)));
d3850 1
a3850 1
	return too_many_arguments(o,op_desc[o->op_type]);
d3852 1
a3852 1
    return o;
d3856 2
a3857 1
ck_subr(OP *o)
d3859 3
a3861 4
    dTHR;
    OP *prev = ((cUNOPo->op_first->op_sibling)
	     ? cUNOPo : ((UNOP*)cUNOPo->op_first))->op_first;
    OP *o2 = prev->op_sibling;
a3864 1
    GV *namegv = 0;
a3866 1
    STRLEN n_a;
d3868 1
a3868 1
    for (cvop = o2; cvop->op_sibling; cvop = cvop->op_sibling) ;
d3871 1
a3871 1
	o->op_private |= (cvop->op_private & OPpENTERSUB_AMPER);
d3875 3
a3877 5
	    cv = GvCVu(tmpop->op_sv);
	    if (cv && SvPOK(cv) && !(o->op_private & OPpENTERSUB_AMPER)) {
		namegv = CvANON(cv) ? (GV*)tmpop->op_sv : CvGV(cv);
		proto = SvPV((SV*)cv, n_a);
	    }
d3880 4
a3883 4
    o->op_private |= (PL_hints & HINT_STRICT_REFS);
    if (PERLDB_SUB && PL_curstash != PL_debstash)
	o->op_private |= OPpENTERSUB_DB;
    while (o2 != cvop) {
d3887 1
a3887 1
		return too_many_arguments(o, gv_ename(namegv));
d3895 1
a3895 1
		scalar(o2);
d3899 1
a3899 1
		list(o2);
d3905 2
a3906 2
		if (o2->op_type != OP_REFGEN && o2->op_type != OP_UNDEF)
		    bad_type(arg, "block", gv_ename(namegv), o2);
a3908 1
		/* '*' allows any scalar type, including bareword */
d3911 10
a3920 4
		if (o2->op_type == OP_RV2GV)
		    goto wrapref;	/* autoconvert GLOB -> GLOBref */
		scalar(o2);
		break;
d3926 2
a3927 2
		    if (o2->op_type != OP_RV2GV)
			bad_type(arg, "symbol", gv_ename(namegv), o2);
d3930 2
a3931 2
		    if (o2->op_type != OP_RV2CV)
			bad_type(arg, "sub", gv_ename(namegv), o2);
d3934 2
a3935 6
		    if (o2->op_type != OP_RV2SV
			&& o2->op_type != OP_PADSV
			&& o2->op_type != OP_THREADSV)
		    {
			bad_type(arg, "scalar", gv_ename(namegv), o2);
		    }
d3938 2
a3939 2
		    if (o2->op_type != OP_RV2AV && o2->op_type != OP_PADAV)
			bad_type(arg, "array", gv_ename(namegv), o2);
d3942 2
a3943 2
		    if (o2->op_type != OP_RV2HV && o2->op_type != OP_PADHV)
			bad_type(arg, "hash", gv_ename(namegv), o2);
d3946 3
a3948 2
			OP* kid = o2;
			OP* sib = kid->op_sibling;
d3950 1
a3950 3
			o2 = newUNOP(OP_REFGEN, 0, kid);
			o2->op_sibling = sib;
			prev->op_sibling = o2;
a3955 3
	    case ' ':
		proto++;
		continue;
d3959 1
a3959 1
			gv_ename(namegv), SvPV((SV*)cv, n_a));
d3963 8
a3970 9
	    list(o2);
	mod(o2, OP_ENTERSUB);
	prev = o2;
	o2 = o2->op_sibling;
    }
    if (proto && !optional &&
	  (*proto && *proto != '@@' && *proto != '%' && *proto != ';'))
	return too_few_arguments(o, gv_ename(namegv));
    return o;
d3974 2
a3975 1
ck_svconst(OP *o)
d3977 2
a3978 2
    SvREADONLY_on(cSVOPo->op_sv);
    return o;
d3982 2
a3983 1
ck_trunc(OP *o)
d3985 2
a3986 2
    if (o->op_flags & OPf_KIDS) {
	SVOP *kid = (SVOP*)cUNOPo->op_first;
d3992 1
a3992 1
	    o->op_flags |= OPf_SPECIAL;
d3994 1
a3994 1
    return ck_fun(o);
d4000 2
a4001 1
peep(register OP *o)
a4002 1
    dTHR;
a4003 1
    STRLEN n_a;
d4007 2
a4008 2
    SAVEOP();
    SAVESPTR(PL_curcop);
d4012 3
a4014 3
	if (!PL_op_seqmax)
	    PL_op_seqmax++;
	PL_op = o;
d4018 2
a4019 2
	    PL_curcop = ((COP*)o);		/* for warnings */
	    o->op_seq = PL_op_seqmax++;
d4030 1
a4030 1
	    if (o->op_next && o->op_next->op_type == OP_STRINGIFY)
d4032 1
a4032 1
	    o->op_seq = PL_op_seqmax++;
d4035 3
a4037 3
	    if ((o->op_flags & OPf_WANT) != OPf_WANT_LIST) {
		o->op_seq = PL_op_seqmax++;
		break; /* Scalar stub must produce undef.  List stub is noop */
d4042 1
a4042 1
		PL_curcop = ((COP*)o);
d4052 1
a4052 1
	    o->op_seq = PL_op_seqmax++;
d4057 1
a4057 1
		if (!(o->op_next->op_private & OPpDEREF)) {
d4069 1
a4069 1
		    (PL_op = pop->op_next) &&
d4072 2
a4073 2
		      (OPpLVAL_INTRO|OPpLVAL_DEFER|OPpDEREF)) &&
		    (i = SvIV(((SVOP*)pop)->op_sv) - PL_compiling.cop_arybase)
d4086 1
a4086 1
		    GvAVn(((GVOP*)o)->op_gv);
d4089 1
a4089 1
	    o->op_seq = PL_op_seqmax++;
d4096 1
a4096 3
	    o->op_seq = PL_op_seqmax++;
	    while (cLOGOP->op_other->op_type == OP_NULL)
		cLOGOP->op_other = cLOGOP->op_other->op_next;
d4101 1
a4101 1
	    o->op_seq = PL_op_seqmax++;
d4107 1
a4107 1
	    o->op_seq = PL_op_seqmax++;
a4112 1
	case OP_QR:
d4115 1
a4115 1
	    o->op_seq = PL_op_seqmax++;
d4120 2
a4121 2
	    o->op_seq = PL_op_seqmax++;
	    if (PL_dowarn && o->op_next && o->op_next->op_type == OP_NEXTSTATE) {
a4122 2
			o->op_next->op_sibling->op_type != OP_EXIT &&
			o->op_next->op_sibling->op_type != OP_WARN &&
d4124 1
a4124 1
		    line_t oldline = PL_curcop->cop_line;
d4126 1
a4126 1
		    PL_curcop->cop_line = ((COP*)o->op_next)->cop_line;
d4129 1
a4129 1
		    PL_curcop->cop_line = oldline;
a4132 41
	
	case OP_HELEM: {
	    UNOP *rop;
	    SV *lexname;
	    GV **fields;
	    SV **svp, **indsvp;
	    I32 ind;
	    char *key;
	    STRLEN keylen;
	
	    if (o->op_private & (OPpDEREF_HV|OPpDEREF_AV|OPpLVAL_INTRO)
		|| ((BINOP*)o)->op_last->op_type != OP_CONST)
		break;
	    rop = (UNOP*)((BINOP*)o)->op_first;
	    if (rop->op_type != OP_RV2HV || rop->op_first->op_type != OP_PADSV)
		break;
	    lexname = *av_fetch(PL_comppad_name, rop->op_first->op_targ, TRUE);
	    if (!SvOBJECT(lexname))
		break;
	    fields = (GV**)hv_fetch(SvSTASH(lexname), "FIELDS", 6, FALSE);
	    if (!fields || !GvHV(*fields))
		break;
	    svp = &((SVOP*)((BINOP*)o)->op_last)->op_sv;
	    key = SvPV(*svp, keylen);
	    indsvp = hv_fetch(GvHV(*fields), key, keylen, FALSE);
	    if (!indsvp) {
		croak("No such field \"%s\" in variable %s of type %s",
		      key, SvPV(lexname, n_a), HvNAME(SvSTASH(lexname)));
	    }
	    ind = SvIV(*indsvp);
	    if (ind < 1)
		croak("Bad index while coercing array into hash");
	    rop->op_type = OP_RV2AV;
	    rop->op_ppaddr = ppaddr[OP_RV2AV];
	    o->op_type = OP_AELEM;
	    o->op_ppaddr = ppaddr[OP_AELEM];
	    SvREFCNT_dec(*svp);
	    *svp = newSViv(ind);
	    break;
	}

d4134 1
a4134 1
	    o->op_seq = PL_op_seqmax++;
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
a18 1
#define PERL_IN_OP_C
a19 1
#include "keywords.h"
d21 5
a25 19
/* #define PL_OP_SLAB_ALLOC */

#ifdef PL_OP_SLAB_ALLOC 
#define SLAB_SIZE 8192
static char    *PL_OpPtr  = NULL;
static int     PL_OpSpace = 0;
#define NewOp(m,var,c,type) do { if ((PL_OpSpace -= c*sizeof(type)) >= 0)     \
                              var =  (type *)(PL_OpPtr -= c*sizeof(type));    \
                             else                                             \
                              var = (type *) Slab_Alloc(m,c*sizeof(type));    \
                           } while (0)

STATIC void *           
S_Slab_Alloc(pTHX_ int m, size_t sz)
{ 
 Newz(m,PL_OpPtr,SLAB_SIZE,char);
 PL_OpSpace = SLAB_SIZE - sz;
 return PL_OpPtr += PL_OpSpace;
}
a26 3
#else 
#define NewOp(m, var, c, type) Newz(m, var, c, type)
#endif
d34 1
a34 1
	 Perl_croak(aTHX_ "%s trapped by operation mask", PL_op_desc[type]),	\
d36 1
a36 1
     : CALL_FPTR(PL_check[type])(aTHX_ (OP*)o))
d40 16
d57 1
a57 1
S_gv_ename(pTHX_ GV *gv)
d59 1
a60 1
    SV* tmpsv = sv_newmortal();
d66 1
a66 1
S_no_fh_allowed(pTHX_ OP *o)
d68 2
a69 2
    yyerror(Perl_form(aTHX_ "Missing comma after first argument to %s function",
		 PL_op_desc[o->op_type]));
d74 1
a74 1
S_too_few_arguments(pTHX_ OP *o, char *name)
d76 1
a76 1
    yyerror(Perl_form(aTHX_ "Not enough arguments for %s", name));
d81 1
a81 1
S_too_many_arguments(pTHX_ OP *o, char *name)
d83 1
a83 1
    yyerror(Perl_form(aTHX_ "Too many arguments for %s", name));
d88 1
a88 1
S_bad_type(pTHX_ I32 n, char *t, char *name, OP *kid)
d90 2
a91 2
    yyerror(Perl_form(aTHX_ "Type of arg %d to %s must be %s (not %s)",
		 (int)n, name, t, PL_op_desc[kid->op_type]));
d94 2
a95 2
STATIC void
S_no_bareword_allowed(pTHX_ OP *o)
d97 16
a112 3
    qerror(Perl_mess(aTHX_
		     "Bareword \"%s\" not allowed while \"strict subs\" in use",
		     SvPV_nolen(cSVOPo_sv)));
d118 1
a118 1
Perl_pad_allocmy(pTHX_ char *name)
d124 3
a126 21
    if (!(PL_in_my == KEY_our ||
	  isALPHA(name[1]) ||
	  (PL_hints & HINT_UTF8 && (name[1] & 0xc0) == 0xc0) ||
	  (name[1] == '_' && (int)strlen(name) > 2)))
    {
	if (!isPRINT(name[1]) || strchr("\t\n\r\f", name[1])) {
	    /* 1999-02-27 mjd@@plover.com */
	    char *p;
	    p = strchr(name, '\0');
	    /* The next block assumes the buffer is at least 205 chars
	       long.  At present, it's always at least 256 chars. */
	    if (p-name > 200) {
		strcpy(name+200, "...");
		p = name+199;
	    }
	    else {
		p[1] = '\0';
	    }
	    /* Move everything else down one character */
	    for (; p-name > 2; p--)
		*p = *(p-1);
d130 1
a130 1
	yyerror(Perl_form(aTHX_ "Can't use global %s in \"my\"",name));
d132 1
a132 1
    if (ckWARN(WARN_MISC) && AvFILLp(PL_comppad_name) >= 0) {
d134 1
a134 3
	HV *ourstash = (PL_curstash ? PL_curstash : PL_defstash);
	PADOFFSET top = AvFILLp(PL_comppad_name);
	for (off = top; off > PL_comppad_name_floor; off--) {
a137 2
		&& (PL_in_my != KEY_our
		    || ((SvFLAGS(sv) & SVpad_OUR) && GvSTASH(sv) == ourstash))
d140 2
a141 6
		Perl_warner(aTHX_ WARN_MISC,
		    "\"%s\" variable %s masks earlier declaration in same %s", 
		    (PL_in_my == KEY_our ? "our" : "my"),
		    name,
		    (SvIVX(sv) == PAD_MAX ? "scope" : "statement"));
		--off;
a144 15
	if (PL_in_my == KEY_our) {
	    do {
		if ((sv = svp[off])
		    && sv != &PL_sv_undef
		    && ((SvFLAGS(sv) & SVpad_OUR) && GvSTASH(sv) == ourstash)
		    && strEQ(name, SvPVX(sv)))
		{
		    Perl_warner(aTHX_ WARN_MISC,
			"\"our\" variable %s redeclared", name);
		    Perl_warner(aTHX_ WARN_MISC,
			"\t(Did you mean \"local\" instead of \"our\"?)\n");
		    break;
		}
	    } while ( off-- > 0 );
	}
d152 1
a152 2
	    yyerror(Perl_form(aTHX_ "Can't declare class for non-scalar %s in \"%s\"",
			 name, PL_in_my == KEY_our ? "our" : "my"));
a157 5
    if (PL_in_my == KEY_our) {
	(void)SvUPGRADE(sv, SVt_PVGV);
	GvSTASH(sv) = (HV*)SvREFCNT_inc(PL_curstash ? (SV*)PL_curstash : (SV*)PL_defstash);
	SvFLAGS(sv) |= SVpad_OUR;
    }
d159 1
a159 1
    SvNVX(sv) = (NV)PAD_MAX;
a171 25
STATIC PADOFFSET
S_pad_addlex(pTHX_ SV *proto_namesv)
{
    SV *namesv = NEWSV(1103,0);
    PADOFFSET newoff = pad_alloc(OP_PADSV, SVs_PADMY);
    sv_upgrade(namesv, SVt_PVNV);
    sv_setpv(namesv, SvPVX(proto_namesv));
    av_store(PL_comppad_name, newoff, namesv);
    SvNVX(namesv) = (NV)PL_curcop->cop_seq;
    SvIVX(namesv) = PAD_MAX;			/* A ref, intro immediately */
    SvFAKE_on(namesv);				/* A ref, not a real var */
    if (SvFLAGS(proto_namesv) & SVpad_OUR) {	/* An "our" variable */
	SvFLAGS(namesv) |= SVpad_OUR;
	(void)SvUPGRADE(namesv, SVt_PVGV);
	GvSTASH(namesv) = (HV*)SvREFCNT_inc((SV*)GvSTASH(proto_namesv));
    }
    if (SvOBJECT(proto_namesv)) {		/* A typed var */
	SvOBJECT_on(namesv);
	(void)SvUPGRADE(namesv, SVt_PVMG);
	SvSTASH(namesv) = (HV*)SvREFCNT_inc((SV*)SvSTASH(proto_namesv));
	PL_sv_objcount++;
    }
    return newoff;
}

d175 2
a176 2
S_pad_findlex(pTHX_ char *name, PADOFFSET newoff, U32 seq, CV* startcv,
	    I32 cx_ix, I32 saweval, U32 flags)
d214 1
a214 1
		oldpad = (AV*)AvARRAY(curlist)[depth];
d217 14
a230 1
		    newoff = pad_addlex(sv);
d244 1
a244 15
				if (CvANON(bcv)) {
				    /* install the missing pad entry in intervening
				     * nested subs and mark them cloneable.
				     * XXX fix pad_foo() to not use globals */
				    AV *ocomppad_name = PL_comppad_name;
				    AV *ocomppad = PL_comppad;
				    SV **ocurpad = PL_curpad;
				    AV *padlist = CvPADLIST(bcv);
				    PL_comppad_name = (AV*)AvARRAY(padlist)[0];
				    PL_comppad = (AV*)AvARRAY(padlist)[1];
				    PL_curpad = AvARRAY(PL_comppad);
				    pad_addlex(sv);
				    PL_comppad_name = ocomppad_name;
				    PL_comppad = ocomppad;
				    PL_curpad = ocurpad;
a245 1
				}
d247 1
a247 1
				    if (ckWARN(WARN_CLOSURE)
d250 1
a250 1
					Perl_warner(aTHX_ WARN_CLOSURE,
d260 2
a261 3
			if (ckWARN(WARN_CLOSURE) && !SvFAKE(sv) && !CvUNIQUE(cv))
			    Perl_warner(aTHX_ WARN_CLOSURE,
				"Variable \"%s\" will not stay shared", name);
a292 1
	    case OP_DOFILE:
d294 1
a294 1
		/* require/do must have their own scope */
a297 1
	case CXt_FORMAT:
d315 1
a315 1
Perl_pad_findmy(pTHX_ char *name)
d348 1
a348 1
	    if (SvIVX(sv) || SvFLAGS(sv) & SVpad_OUR)
d378 1
a378 1
Perl_pad_leavemy(pTHX_ I32 fill)
a379 1
    dTHR;
d385 2
a386 2
	    if ((sv = svp[off]) && sv != &PL_sv_undef && ckWARN_d(WARN_INTERNAL))
		Perl_warner(aTHX_ WARN_INTERNAL, "%s never introduced", SvPVX(sv));
d397 1
a397 1
Perl_pad_alloc(pTHX_ I32 optype, U32 tmptype)
d404 1
a404 1
	Perl_croak(aTHX_ "panic: pad_alloc");
d426 1
a426 1
	    if (!(SvFLAGS(sv) & (SVs_PADTMP|SVs_PADMY)) && !IS_PADGV(sv))
d434 3
a436 4
    DEBUG_X(PerlIO_printf(Perl_debug_log,
			  "0x%"UVxf" Pad 0x%"UVxf" alloc %ld for %s\n",
			  PTR2UV(thr), PTR2UV(PL_curpad),
			  (long) retval, PL_op_name[optype]));
d438 3
a440 4
    DEBUG_X(PerlIO_printf(Perl_debug_log,
			  "Pad 0x%"UVxf" alloc %ld for %s\n",
			  PTR2UV(PL_curpad),
			  (long) retval, PL_op_name[optype]));
d446 1
a446 1
Perl_pad_sv(pTHX_ PADOFFSET po)
d450 2
a451 3
    DEBUG_X(PerlIO_printf(Perl_debug_log,
			  "0x%"UVxf" Pad 0x%"UVxf" sv %"IVdf"\n",
			  PTR2UV(thr), PTR2UV(PL_curpad), (IV)po));
d454 3
a456 3
	Perl_croak(aTHX_ "panic: pad_sv po");
    DEBUG_X(PerlIO_printf(Perl_debug_log, "Pad 0x%"UVxf" sv %"IVdf"\n",
			  PTR2UV(PL_curpad), (IV)po));
d462 1
a462 1
Perl_pad_free(pTHX_ PADOFFSET po)
d468 1
a468 1
	Perl_croak(aTHX_ "panic: pad_free curpad");
d470 1
a470 1
	Perl_croak(aTHX_ "panic: pad_free po");
d472 2
a473 3
    DEBUG_X(PerlIO_printf(Perl_debug_log,
			  "0x%"UVxf" Pad 0x%"UVxf" free %"IVdf"\n",
			  PTR2UV(thr), PTR2UV(PL_curpad), (IV)po));
d475 2
a476 2
    DEBUG_X(PerlIO_printf(Perl_debug_log, "Pad 0x%"UVxf" free %"IVdf"\n",
			  PTR2UV(PL_curpad), (IV)po));
d478 1
a478 1
    if (PL_curpad[po] && PL_curpad[po] != &PL_sv_undef) {
a479 4
#ifdef USE_ITHREADS
	SvREADONLY_off(PL_curpad[po]);	/* could be a freed constant */
#endif
    }
d485 1
a485 1
Perl_pad_swipe(pTHX_ PADOFFSET po)
d489 1
a489 1
	Perl_croak(aTHX_ "panic: pad_swipe curpad");
d491 1
a491 1
	Perl_croak(aTHX_ "panic: pad_swipe po");
d493 2
a494 3
    DEBUG_X(PerlIO_printf(Perl_debug_log,
			  "0x%"UVxf" Pad 0x%"UVxf" swipe %"IVdf"\n",
			  PTR2UV(thr), PTR2UV(PL_curpad), (IV)po));
d496 2
a497 2
    DEBUG_X(PerlIO_printf(Perl_debug_log, "Pad 0x%"UVxf" swipe %"IVdf"\n",
			  PTR2UV(PL_curpad), (IV)po));
d513 1
a513 1
Perl_pad_reset(pTHX)
d520 1
a520 1
	Perl_croak(aTHX_ "panic: pad_reset curpad");
d522 2
a523 3
    DEBUG_X(PerlIO_printf(Perl_debug_log,
			  "0x%"UVxf" Pad 0x%"UVxf" reset\n",
			  PTR2UV(thr), PTR2UV(PL_curpad)));
d525 2
a526 2
    DEBUG_X(PerlIO_printf(Perl_debug_log, "Pad 0x%"UVxf" reset\n",
			  PTR2UV(PL_curpad)));
d542 1
a542 1
Perl_find_threadsv(pTHX_ const char *name)
d598 1
a598 1
	DEBUG_S(PerlIO_printf(Perl_error_log,
d610 1
a610 1
Perl_op_free(pTHX_ OP *o)
a612 1
    OPCODE type;
a616 20
    if (o->op_private & OPpREFCOUNTED) {
	switch (o->op_type) {
	case OP_LEAVESUB:
	case OP_LEAVESUBLV:
	case OP_LEAVEEVAL:
	case OP_LEAVE:
	case OP_SCOPE:
	case OP_LEAVEWRITE:
	    OP_REFCNT_LOCK;
	    if (OpREFCNT_dec(o)) {
		OP_REFCNT_UNLOCK;
		return;
	    }
	    OP_REFCNT_UNLOCK;
	    break;
	default:
	    break;
	}
    }

a622 19
    type = o->op_type;
    if (type == OP_NULL)
	type = o->op_targ;

    /* COP* is not cleared by op_clear() so that we may track line
     * numbers etc even after null() */
    if (type == OP_NEXTSTATE || type == OP_SETSTATE || type == OP_DBSTATE)
	cop_free((COP*)o);

    op_clear(o);

#ifdef PL_OP_SLAB_ALLOC
    if ((char *) o == PL_OpPtr)
     {
     }
#else
    Safefree(o);
#endif
}
a623 3
STATIC void
S_op_clear(pTHX_ OP *o)
{
d625 5
a629 6
    case OP_NULL:	/* Was holding old type, if any. */
    case OP_ENTEREVAL:	/* Was holding hints. */
#ifdef USE_THREADS
    case OP_THREADSV:	/* Was holding index into thr->threadsv AV. */
#endif
	o->op_targ = 0;
d636 3
d642 1
a642 1
	    || (PL_check[o->op_type] != MEMBER_TO_FPTR(Perl_ck_ftst)))
d648 6
a653 15
#ifdef USE_ITHREADS
	if (cPADOPo->op_padix > 0) {
	    if (PL_curpad) {
		GV *gv = cGVOPo_gv;
		pad_swipe(cPADOPo->op_padix);
		/* No GvIN_PAD_off(gv) here, because other references may still
		 * exist on the pad */
		SvREFCNT_dec(gv);
	    }
	    cPADOPo->op_padix = 0;
	}
#else
	SvREFCNT_dec(cSVOPo->op_sv);
	cSVOPo->op_sv = Nullsv;
#endif
a656 1
	cSVOPo->op_sv = Nullsv;
d666 1
a666 8
	if (o->op_private & (OPpTRANS_FROM_UTF|OPpTRANS_TO_UTF)) {
	    SvREFCNT_dec(cSVOPo->op_sv);
	    cSVOPo->op_sv = Nullsv;
	}
	else {
	    Safefree(cPVOPo->op_pv);
	    cPVOPo->op_pv = Nullch;
	}
d670 1
a670 1
	goto clear_pmop;
a671 14
#ifdef USE_ITHREADS
	if ((PADOFFSET)cPMOPo->op_pmreplroot) {
	    if (PL_curpad) {
		GV *gv = (GV*)PL_curpad[(PADOFFSET)cPMOPo->op_pmreplroot];
		pad_swipe((PADOFFSET)cPMOPo->op_pmreplroot);
		/* No GvIN_PAD_off(gv) here, because other references may still
		 * exist on the pad */
		SvREFCNT_dec(gv);
	    }
	}
#else
	SvREFCNT_dec((SV*)cPMOPo->op_pmreplroot);
#endif
	/* FALL THROUGH */
a673 2
clear_pmop:
	cPMOPo->op_pmreplroot = Nullop;
a674 1
	cPMOPo->op_pmregexp = (REGEXP*)NULL;
d678 1
a678 1
    if (o->op_targ > 0) {
a679 3
	o->op_targ = 0;
    }
}
d681 1
a681 13
STATIC void
S_cop_free(pTHX_ COP* cop)
{
    Safefree(cop->cop_label);
#ifdef USE_ITHREADS
    Safefree(CopFILE(cop));		/* XXXXX share in a pvtable? */
    Safefree(CopSTASHPV(cop));		/* XXXXX share in a pvtable? */
#else
    /* NOTE: COP.cop_stash is not refcounted */
    SvREFCNT_dec(CopFILEGV(cop));
#endif
    if (! specialWARN(cop->cop_warnings))
	SvREFCNT_dec(cop->cop_warnings);
d685 1
a685 1
S_null(pTHX_ OP *o)
d687 2
a688 3
    if (o->op_type == OP_NULL)
	return;
    op_clear(o);
d691 1
a691 1
    o->op_ppaddr = PL_ppaddr[OP_NULL];
d699 1
a699 1
Perl_linklist(pTHX_ OP *o)
d723 1
a723 1
Perl_scalarkids(pTHX_ OP *o)
d734 1
a734 1
S_scalarboolean(pTHX_ OP *o)
d736 2
a737 1
    if (o->op_type == OP_SASSIGN && cBINOPo->op_first->op_type == OP_CONST) {
d739 1
a739 2
	if (ckWARN(WARN_SYNTAX)) {
	    line_t oldline = CopLINE(PL_curcop);
d741 4
a744 5
	    if (PL_copline != NOLINE)
		CopLINE_set(PL_curcop, PL_copline);
	    Perl_warner(aTHX_ WARN_SYNTAX, "Found = in conditional, should be ==");
	    CopLINE_set(PL_curcop, oldline);
	}
d750 1
a750 1
Perl_scalar(pTHX_ OP *o)
a756 1
    {
a757 1
    }
d793 1
a793 1
	while ((kid = kid->op_sibling)) {
d817 1
a817 1
Perl_scalarvoid(pTHX_ OP *o)
a821 12
    U8 want;

    if (o->op_type == OP_NEXTSTATE
	|| o->op_type == OP_SETSTATE
	|| o->op_type == OP_DBSTATE
	|| (o->op_type == OP_NULL && (o->op_targ == OP_NEXTSTATE
				      || o->op_targ == OP_SETSTATE
				      || o->op_targ == OP_DBSTATE)))
    {
	dTHR;
	PL_curcop = (COP*)o;		/* for warning below */
    }
d824 2
a825 2
    want = o->op_flags & OPf_WANT;
    if ((want && want != OPf_WANT_SCALAR) || PL_error_count
a826 1
    {
a827 1
    }
a828 6
    if ((o->op_private & OPpTARGET_MY)
	&& (PL_opargs[o->op_type] & OA_TARGLEX))/* OPp share the meaning */
    {
	return scalar(o);			/* As if inside SASSIGN */
    }
    
d833 1
a833 1
	if (!(PL_opargs[o->op_type] & OA_FOLDCONST))
d912 2
a913 2
	if (!(o->op_private & (OPpLVAL_INTRO|OPpOUR_INTRO)))
	    useless = PL_op_desc[o->op_type];
d920 1
a920 1
	if (!(o->op_private & (OPpLVAL_INTRO|OPpOUR_INTRO)) &&
d925 5
d931 10
a940 15
	sv = cSVOPo_sv;
	if (cSVOPo->op_private & OPpCONST_STRICT)
	    no_bareword_allowed(o);
	else {
	    dTHR;
	    if (ckWARN(WARN_VOID)) {
		useless = "a constant";
		if (SvNIOK(sv) && (SvNV(sv) == 0.0 || SvNV(sv) == 1.0))
		    useless = 0;
		else if (SvPOK(sv)) {
		    if (strnEQ(SvPVX(sv), "di", 2) ||
			strnEQ(SvPVX(sv), "ds", 2) ||
			strnEQ(SvPVX(sv), "ig", 2))
			    useless = 0;
		}
d943 2
a944 1
	null(o);		/* don't execute or even remember it */
d949 1
a949 1
	o->op_ppaddr = PL_ppaddr[OP_PREINC];
d954 1
a954 1
	o->op_ppaddr = PL_ppaddr[OP_PREDEC];
d965 2
a969 2
    case OP_NEXTSTATE:
    case OP_DBSTATE:
d999 2
a1000 5
    if (useless) {
	dTHR;
	if (ckWARN(WARN_VOID))
	    Perl_warner(aTHX_ WARN_VOID, "Useless use of %s in void context", useless);
    }
d1005 1
a1005 1
Perl_listkids(pTHX_ OP *o)
d1016 1
a1016 1
Perl_list(pTHX_ OP *o)
a1022 1
    {
a1023 1
    }
a1024 6
    if ((o->op_private & OPpTARGET_MY)
	&& (PL_opargs[o->op_type] & OA_TARGLEX))/* OPp share the meaning */
    {
	return o;				/* As if inside SASSIGN */
    }
    
d1056 1
a1056 1
	while ((kid = kid->op_sibling)) {
d1083 1
a1083 1
Perl_scalarseq(pTHX_ OP *o)
d1111 1
a1111 1
S_modkids(pTHX_ OP *o, I32 type)
d1122 1
a1122 1
Perl_mod(pTHX_ OP *o, I32 type)
d1126 1
a1131 6
    if ((o->op_private & OPpTARGET_MY)
	&& (PL_opargs[o->op_type] & OA_TARGLEX))/* OPp share the meaning */
    {
	return o;
    }
    
d1140 1
a1140 1
	    PL_compiling.cop_arybase = (I32)SvIV(cSVOPx(PL_eval_start)->op_sv);
d1150 1
a1150 1
	    Perl_croak(aTHX_ "That use of $[ is unsupported");
d1160 1
a1160 1
	    o->op_ppaddr = PL_ppaddr[OP_RV2CV];
a1164 86
	else {				/* lvalue subroutine call */
	    o->op_private |= OPpLVAL_INTRO;
	    if (type == OP_GREPSTART || type == OP_ENTERSUB || type == OP_REFGEN) {
		/* Backward compatibility mode: */
		o->op_private |= OPpENTERSUB_INARGS;
		break;
	    }
	    else {                      /* Compile-time error message: */
		OP *kid = cUNOPo->op_first;
		CV *cv;
		OP *okid;

		if (kid->op_type == OP_PUSHMARK)
		    goto skip_kids;
		if (kid->op_type != OP_NULL || kid->op_targ != OP_LIST)
		    Perl_croak(aTHX_
			       "panic: unexpected lvalue entersub "
			       "args: type/targ %ld:%ld",
			       (long)kid->op_type,kid->op_targ);
		kid = kLISTOP->op_first;
	      skip_kids:
		while (kid->op_sibling)
		    kid = kid->op_sibling;
		if (!(kid->op_type == OP_NULL && kid->op_targ == OP_RV2CV)) {
		    /* Indirect call */
		    if (kid->op_type == OP_METHOD_NAMED
			|| kid->op_type == OP_METHOD)
		    {
			UNOP *newop;

			if (kid->op_sibling || kid->op_next != kid) {
			    yyerror("panic: unexpected optree near method call");
			    break;
			}
			
			NewOp(1101, newop, 1, UNOP);
			newop->op_type = OP_RV2CV;
			newop->op_ppaddr = PL_ppaddr[OP_RV2CV];
			newop->op_first = Nullop;
                        newop->op_next = (OP*)newop;
			kid->op_sibling = (OP*)newop;
			newop->op_private |= OPpLVAL_INTRO;
			break;
		    }
		    
		    if (kid->op_type != OP_RV2CV)
			Perl_croak(aTHX_
				   "panic: unexpected lvalue entersub "
				   "entry via type/targ %ld:%ld",
				   (long)kid->op_type,kid->op_targ);
		    kid->op_private |= OPpLVAL_INTRO;
		    break;	/* Postpone until runtime */
		}
		
		okid = kid;		
		kid = kUNOP->op_first;
		if (kid->op_type == OP_NULL && kid->op_targ == OP_RV2SV)
		    kid = kUNOP->op_first;
		if (kid->op_type == OP_NULL)		
		    Perl_croak(aTHX_
			       "Unexpected constant lvalue entersub "
			       "entry via type/targ %ld:%ld",
			       (long)kid->op_type,kid->op_targ);
		if (kid->op_type != OP_GV) {
		    /* Restore RV2CV to check lvalueness */
		  restore_2cv:
		    if (kid->op_next && kid->op_next != kid) { /* Happens? */
			okid->op_next = kid->op_next;
			kid->op_next = okid;
		    }
		    else
			okid->op_next = Nullop;
		    okid->op_type = OP_RV2CV;
		    okid->op_targ = 0;
		    okid->op_ppaddr = PL_ppaddr[OP_RV2CV];
		    okid->op_private |= OPpLVAL_INTRO;
		    break;
		}
		
		cv = GvCV(kGVOP_gv);
		if (!cv) 
		    goto restore_2cv;
		if (CvLVALUE(cv))
		    break;
	    }
	}
d1171 3
a1173 7
	yyerror(Perl_form(aTHX_ "Can't modify %s in %s",
		     (o->op_type == OP_NULL && (o->op_flags & OPf_SPECIAL)
		      ? "do block"
		      : (o->op_type == OP_ENTERSUB
			? "non-lvalue subroutine call"
			: PL_op_desc[o->op_type])),
		     type ? PL_op_desc[type] : "local"));
d1209 1
a1209 1
	    Perl_croak(aTHX_ "Can't localize through a reference");
d1231 1
a1231 1
	    Perl_croak(aTHX_ "Can't localize through a reference");
a1237 2
    case OP_ANDASSIGN:
    case OP_ORASSIGN:
d1253 1
a1253 1
	    Perl_croak(aTHX_ "Can't localize lexical variable %s",
d1301 1
a1301 3
	if (o->op_flags & OPf_SPECIAL)		/* do BLOCK */
	    goto nomod;
	else if (!(o->op_flags & OPf_KIDS))
d1327 2
a1328 2
STATIC bool
S_scalar_mod_type(pTHX_ OP *o, I32 type)
d1366 2
a1367 2
    case OP_ANDASSIGN:
    case OP_ORASSIGN:
a1373 23
STATIC bool
S_is_handle_constructor(pTHX_ OP *o, I32 argnum)
{
    switch (o->op_type) {
    case OP_PIPE_OP:
    case OP_SOCKPAIR:
	if (argnum == 2)
	    return TRUE;
	/* FALL THROUGH */
    case OP_SYSOPEN:
    case OP_OPEN:
    case OP_SELECT:		/* XXX c.f. SelectSaver.pm */
    case OP_SOCKET:
    case OP_OPEN_DIR:
    case OP_ACCEPT:
	if (argnum == 1)
	    return TRUE;
	/* FALL THROUGH */
    default:
	return FALSE;
    }
}

d1375 1
a1375 1
Perl_refkids(pTHX_ OP *o, I32 type)
d1386 1
a1386 1
Perl_ref(pTHX_ OP *o, I32 type)
d1395 1
a1395 1
	if ((type == OP_EXISTS || type == OP_DEFINED || type == OP_LOCK) &&
d1398 1
a1398 1
	    o->op_ppaddr = PL_ppaddr[OP_RV2CV];
a1409 2
	if (type == OP_DEFINED)
	    o->op_flags |= OPf_SPECIAL;		/* don't create GV */
a1429 2
	if (type == OP_DEFINED)
	    o->op_flags |= OPf_SPECIAL;		/* don't create GV */
d1470 2
a1471 52
STATIC OP *
S_dup_attrlist(pTHX_ OP *o)
{
    OP *rop = Nullop;

    /* An attrlist is either a simple OP_CONST or an OP_LIST with kids,
     * where the first kid is OP_PUSHMARK and the remaining ones
     * are OP_CONST.  We need to push the OP_CONST values.
     */
    if (o->op_type == OP_CONST)
	rop = newSVOP(OP_CONST, o->op_flags, SvREFCNT_inc(cSVOPo->op_sv));
    else {
	assert((o->op_type == OP_LIST) && (o->op_flags & OPf_KIDS));
	for (o = cLISTOPo->op_first; o; o=o->op_sibling) {
	    if (o->op_type == OP_CONST)
		rop = append_elem(OP_LIST, rop,
				  newSVOP(OP_CONST, o->op_flags,
					  SvREFCNT_inc(cSVOPo->op_sv)));
	}
    }
    return rop;
}

STATIC void
S_apply_attrs(pTHX_ HV *stash, SV *target, OP *attrs)
{
    SV *stashsv;

    /* fake up C<use attributes $pkg,$rv,@@attrs> */
    ENTER;		/* need to protect against side-effects of 'use' */
    SAVEINT(PL_expect);
    if (stash && HvNAME(stash))
	stashsv = newSVpv(HvNAME(stash), 0);
    else
	stashsv = &PL_sv_no;

#define ATTRSMODULE "attributes"

    Perl_load_module(aTHX_ PERL_LOADMOD_IMPORT_OPS,
		     newSVpvn(ATTRSMODULE, sizeof(ATTRSMODULE)-1),
		     Nullsv,
		     prepend_elem(OP_LIST,
				  newSVOP(OP_CONST, 0, stashsv),
				  prepend_elem(OP_LIST,
					       newSVOP(OP_CONST, 0,
						       newRV(target)),
					       dup_attrlist(attrs))));
    LEAVE;
}

STATIC OP *
S_my_kid(pTHX_ OP *o, OP *attrs)
d1482 1
a1482 1
	    my_kid(kid, attrs);
a1484 5
    } else if (type == OP_RV2SV ||	/* "our" declaration */
	       type == OP_RV2AV ||
	       type == OP_RV2HV) { /* XXX does this let anything illegal in? */
	o->op_private |= OPpOUR_INTRO;
	return o;
d1490 1
a1490 3
	yyerror(Perl_form(aTHX_ "Can't declare %s in \"%s\"",
			  PL_op_desc[o->op_type],
			  PL_in_my == KEY_our ? "our" : "my"));
a1492 17
    else if (attrs && type != OP_PUSHMARK) {
	HV *stash;
	SV *padsv;
	SV **namesvp;

	PL_in_my = FALSE;
	PL_in_my_stash = Nullhv;

	/* check for C<my Dog $spot> when deciding package */
	namesvp = av_fetch(PL_comppad_name, o->op_targ, FALSE);
	if (namesvp && *namesvp && SvOBJECT(*namesvp) && HvNAME(SvSTASH(*namesvp)))
	    stash = SvSTASH(*namesvp);
	else
	    stash = PL_curstash;
	padsv = PAD_SV(o->op_targ);
	apply_attrs(stash, padsv, attrs);
    }
d1499 1
a1499 20
Perl_my_attrs(pTHX_ OP *o, OP *attrs)
{
    if (o->op_flags & OPf_PARENS)
	list(o);
    if (attrs)
	SAVEFREEOP(attrs);
    o = my_kid(o, attrs);
    PL_in_my = FALSE;
    PL_in_my_stash = Nullhv;
    return o;
}

OP *
Perl_my(pTHX_ OP *o)
{
    return my_kid(o, Nullop);
}

OP *
Perl_sawparens(pTHX_ OP *o)
d1507 1
a1507 1
Perl_bind_match(pTHX_ I32 type, OP *left, OP *right)
a1508 1
    dTHR;
d1511 12
a1522 14
    if (ckWARN(WARN_MISC) &&
      (left->op_type == OP_RV2AV ||
       left->op_type == OP_RV2HV ||
       left->op_type == OP_PADAV ||
       left->op_type == OP_PADHV)) {
      char *desc = PL_op_desc[(right->op_type == OP_SUBST ||
                            right->op_type == OP_TRANS)
                           ? right->op_type : OP_MATCH];
      const char *sample = ((left->op_type == OP_RV2AV ||
			     left->op_type == OP_PADAV)
			    ? "@@array" : "%hash");
      Perl_warner(aTHX_ WARN_MISC,
             "Applying %s to %s will act on scalar(%s)", 
             desc, sample, sample);
d1545 1
a1545 1
Perl_invert(pTHX_ OP *o)
d1554 1
a1554 1
Perl_scope(pTHX_ OP *o)
d1560 1
a1560 1
	    o->op_ppaddr = PL_ppaddr[OP_LEAVE];
d1566 1
a1566 1
		o->op_ppaddr = PL_ppaddr[OP_SCOPE];
d1568 2
a1569 1
		if (kid->op_type == OP_NEXTSTATE || kid->op_type == OP_DBSTATE)
d1571 1
d1581 1
a1581 1
Perl_save_hints(pTHX)
d1590 1
a1590 1
Perl_block_start(pTHX_ int full)
d1596 6
a1601 5
    PL_comppad_name_floor = AvFILLp(PL_comppad_name);
    if (full)
	PL_comppad_name_fill = PL_comppad_name_floor;
    if (PL_comppad_name_floor < 0)
	PL_comppad_name_floor = 0;
a1610 5
    SAVESPTR(PL_compiling.cop_warnings); 
    if (! specialWARN(PL_compiling.cop_warnings)) {
        PL_compiling.cop_warnings = newSVsv(PL_compiling.cop_warnings) ;
        SAVEFREESV(PL_compiling.cop_warnings) ;
    }
d1615 1
a1615 1
Perl_block_end(pTHX_ I32 floor, OP *seq)
a1621 1
    PL_compiling.op_private = PL_hints;
d1630 1
a1630 1
S_newDEFSVOP(pTHX)
d1642 1
a1642 1
Perl_newPROG(pTHX_ OP *o)
d1646 1
a1646 5
	if (PL_eval_root)
		return;
	PL_eval_root = newUNOP(OP_LEAVEEVAL,
			       ((PL_in_eval & EVAL_KEEPERR)
				? OPf_SPECIAL : 0), o);
a1647 2
	PL_eval_root->op_private |= OPpREFCOUNTED;
	OpREFCNT_set(PL_eval_root, 1);
a1656 2
	PL_main_root->op_private |= OPpREFCOUNTED;
	OpREFCNT_set(PL_main_root, 1);
d1663 1
a1663 1
	    CV *cv = get_cv("DB::postponed", FALSE);
d1667 1
a1667 1
		XPUSHs((SV*)CopFILEGV(&PL_compiling));
d1669 1
a1669 1
		call_sv((SV*)cv, G_DISCARD);
d1676 1
a1676 1
Perl_localize(pTHX_ OP *o, I32 lex)
d1681 1
a1681 2
	dTHR;
	if (ckWARN(WARN_PARENTHESIS) && PL_bufptr > PL_oldbufptr && PL_bufptr[-1] == ',') {
d1683 1
a1683 1
	    for (s = PL_bufptr; *s && (isALNUM(*s) || (*s & 0x80) || strchr("@@$%, ",*s)); s++) ;
d1685 1
a1685 3
		Perl_warner(aTHX_ WARN_PARENTHESIS,
			    "Parentheses missing around \"%s\" list",
			    lex ? (PL_in_my == KEY_our ? "our" : "my") : "local");
d1688 2
d1691 1
a1691 1
	o = my(o);
d1693 1
a1693 4
	o = mod(o, OP_NULL);		/* a bit kludgey */
    PL_in_my = FALSE;
    PL_in_my_stash = Nullhv;
    return o;
d1697 1
a1697 1
Perl_jmaybe(pTHX_ OP *o)
d1713 1
a1713 1
Perl_fold_constants(pTHX_ register OP *o)
d1720 1
a1720 1
    if (PL_opargs[type] & OA_RETSCALAR)
d1722 1
a1722 1
    if (PL_opargs[type] & OA_TARGET && !o->op_targ)
d1725 2
a1726 8
    /* integerize op, unless it happens to be C<-foo>.
     * XXX should pp_i_negate() do magic string negation instead? */
    if ((PL_opargs[type] & OA_OTHERINT) && (PL_hints & HINT_INTEGER)
	&& !(type == OP_NEGATE && cUNOPo->op_first->op_type == OP_CONST
	     && (cUNOPo->op_first->op_private & OPpCONST_BARE)))
    {
	o->op_ppaddr = PL_ppaddr[type = ++(o->op_type)];
    }
d1728 1
a1728 1
    if (!(PL_opargs[type] & OA_FOLDCONST))
a1731 4
    case OP_NEGATE:
	/* XXX might want a ck_negate() for this */
	cUNOPo->op_first->op_private &= ~OPpCONST_STRICT;
	break;
d1751 5
a1755 7
	if ((curop->op_type != OP_CONST ||
	     (curop->op_private & OPpCONST_BARE)) &&
	    curop->op_type != OP_LIST &&
	    curop->op_type != OP_SCALAR &&
	    curop->op_type != OP_NULL &&
	    curop->op_type != OP_PUSHMARK)
	{
d1763 1
a1763 1
    CALLRUNOPS(aTHX);
d1780 1
a1780 1
	    if ((NV)iv == SvNV(sv)) {
d1791 1
a1791 1
    if (!(PL_opargs[type] & OA_OTHERINT))
d1795 1
a1795 4
	if (type == OP_MODULO
	    || type == OP_DIVIDE
	    || !(o->op_flags & OPf_KIDS))
	{
a1796 1
	}
d1804 1
a1804 1
	    if (PL_opargs[curop->op_type] & OA_RETINTEGER)
d1808 1
a1808 1
	o->op_ppaddr = PL_ppaddr[++(o->op_type)];
d1815 1
a1815 1
Perl_gen_constant_list(pTHX_ register OP *o)
d1827 2
a1828 3
    peep(curop);
    pp_pushmark();
    CALLRUNOPS(aTHX);
d1830 1
a1830 1
    pp_anonlist();
d1834 1
a1834 1
    o->op_ppaddr = PL_ppaddr[OP_RV2AV];
d1843 1
a1843 1
Perl_convert(pTHX_ I32 type, I32 flags, OP *o)
d1853 1
a1853 1
    if (!(PL_opargs[type] & OA_MARK))
d1857 1
a1857 1
    o->op_ppaddr = PL_ppaddr[type];
d1877 1
a1877 1
Perl_append_elem(pTHX_ I32 type, OP *first, OP *last)
d1885 2
a1886 5
    if (first->op_type != type
	|| (type == OP_LIST && (first->op_flags & OPf_PARENS)))
    {
	return newLISTOP(type, 0, first, last);
    }
d1900 1
a1900 1
Perl_append_list(pTHX_ I32 type, LISTOP *first, LISTOP *last)
d1919 2
a1920 5
    
#ifdef PL_OP_SLAB_ALLOC
#else
    Safefree(last);     
#endif
d1925 1
a1925 1
Perl_prepend_elem(pTHX_ I32 type, OP *first, OP *last)
d1956 1
a1956 1
Perl_newNULLLIST(pTHX)
d1962 1
a1962 1
Perl_force_list(pTHX_ OP *o)
d1971 1
a1971 1
Perl_newLISTOP(pTHX_ I32 type, I32 flags, OP *first, OP *last)
d1975 1
a1975 1
    NewOp(1101, listop, 1, LISTOP);
d1978 1
a1978 1
    listop->op_ppaddr = PL_ppaddr[type];
d2006 1
a2006 1
Perl_newOP(pTHX_ I32 type, I32 flags)
d2009 1
a2009 1
    NewOp(1101, o, 1, OP);
d2011 1
a2011 1
    o->op_ppaddr = PL_ppaddr[type];
d2016 1
a2016 1
    if (PL_opargs[type] & OA_RETSCALAR)
d2018 1
a2018 1
    if (PL_opargs[type] & OA_TARGET)
d2024 1
a2024 1
Perl_newUNOP(pTHX_ I32 type, I32 flags, OP *first)
d2030 1
a2030 1
    if (PL_opargs[type] & OA_MARK)
d2033 1
a2033 1
    NewOp(1101, unop, 1, UNOP);
d2035 1
a2035 1
    unop->op_ppaddr = PL_ppaddr[type];
d2047 1
a2047 1
Perl_newBINOP(pTHX_ I32 type, I32 flags, OP *first, OP *last)
d2050 1
a2050 1
    NewOp(1101, binop, 1, BINOP);
d2056 1
a2056 1
    binop->op_ppaddr = PL_ppaddr[type];
d2069 1
a2069 1
    if (binop->op_next || binop->op_type != type)
d2072 1
a2072 1
    binop->op_last = binop->op_first->op_sibling;
a2076 13
static int
utf8compare(const void *a, const void *b)
{
    int i;
    for (i = 0; i < 10; i++) {
	if ((*(U8**)a)[i] < (*(U8**)b)[i])
	    return -1;
	if ((*(U8**)a)[i] > (*(U8**)b)[i])
	    return 1;
    }
    return 0;
}

d2078 1
a2078 1
Perl_pmtrans(pTHX_ OP *o, OP *expr, OP *repl)
d2088 1
a2088 1
    I32 del;
d2093 1
d2095 1
a2095 1
    del		= o->op_private & OPpTRANS_DELETE;
a2097 189
    if (o->op_private & (OPpTRANS_FROM_UTF|OPpTRANS_TO_UTF)) {
	SV* listsv = newSVpvn("# comment\n",10);
	SV* transv = 0;
	U8* tend = t + tlen;
	U8* rend = r + rlen;
	I32 ulen;
	U32 tfirst = 1;
	U32 tlast = 0;
	I32 tdiff;
	U32 rfirst = 1;
	U32 rlast = 0;
	I32 rdiff;
	I32 diff;
	I32 none = 0;
	U32 max = 0;
	I32 bits;
	I32 grows = 0;
	I32 havefinal = 0;
	U32 final;
	I32 from_utf	= o->op_private & OPpTRANS_FROM_UTF;
	I32 to_utf	= o->op_private & OPpTRANS_TO_UTF;

	if (complement) {
	    U8 tmpbuf[UTF8_MAXLEN];
	    U8** cp;
	    UV nextmin = 0;
	    New(1109, cp, tlen, U8*);
	    i = 0;
	    transv = newSVpvn("",0);
	    while (t < tend) {
		cp[i++] = t;
		t += UTF8SKIP(t);
		if (*t == 0xff) {
		    t++;
		    t += UTF8SKIP(t);
		}
	    }
	    qsort(cp, i, sizeof(U8*), utf8compare);
	    for (j = 0; j < i; j++) {
		U8 *s = cp[j];
		UV val = utf8_to_uv(s, &ulen);
		s += ulen;
		diff = val - nextmin;
		if (diff > 0) {
		    t = uv_to_utf8(tmpbuf,nextmin);
		    sv_catpvn(transv, (char*)tmpbuf, t - tmpbuf);
		    if (diff > 1) {
			t = uv_to_utf8(tmpbuf, val - 1);
			sv_catpvn(transv, "\377", 1);
			sv_catpvn(transv, (char*)tmpbuf, t - tmpbuf);
		    }
	        }
		if (*s == 0xff)
		    val = utf8_to_uv(s+1, &ulen);
		if (val >= nextmin)
		    nextmin = val + 1;
	    }
	    t = uv_to_utf8(tmpbuf,nextmin);
	    sv_catpvn(transv, (char*)tmpbuf, t - tmpbuf);
	    t = uv_to_utf8(tmpbuf, 0x7fffffff);
	    sv_catpvn(transv, "\377", 1);
	    sv_catpvn(transv, (char*)tmpbuf, t - tmpbuf);
	    t = (U8*)SvPVX(transv);
	    tlen = SvCUR(transv);
	    tend = t + tlen;
	}
	else if (!rlen && !del) {
	    r = t; rlen = tlen; rend = tend;
	}
	if (!squash) {
	    if (to_utf && from_utf) {	/* only counting characters */
		if (t == r || (tlen == rlen && memEQ(t, r, tlen)))
		    o->op_private |= OPpTRANS_IDENTICAL;
	    }
	    else {	/* straight latin-1 translation */
		if (tlen == 4 && memEQ(t, "\0\377\303\277", 4) &&
		    rlen == 4 && memEQ(r, "\0\377\303\277", 4))
		    o->op_private |= OPpTRANS_IDENTICAL;
	    }
	}

	while (t < tend || tfirst <= tlast) {
	    /* see if we need more "t" chars */
	    if (tfirst > tlast) {
		tfirst = (I32)utf8_to_uv(t, &ulen);
		t += ulen;
		if (t < tend && *t == 0xff) {	/* illegal utf8 val indicates range */
		    tlast = (I32)utf8_to_uv(++t, &ulen);
		    t += ulen;
		}
		else
		    tlast = tfirst;
	    }

	    /* now see if we need more "r" chars */
	    if (rfirst > rlast) {
		if (r < rend) {
		    rfirst = (I32)utf8_to_uv(r, &ulen);
		    r += ulen;
		    if (r < rend && *r == 0xff) {	/* illegal utf8 val indicates range */
			rlast = (I32)utf8_to_uv(++r, &ulen);
			r += ulen;
		    }
		    else
			rlast = rfirst;
		}
		else {
		    if (!havefinal++)
			final = rlast;
		    rfirst = rlast = 0xffffffff;
		}
	    }

	    /* now see which range will peter our first, if either. */
	    tdiff = tlast - tfirst;
	    rdiff = rlast - rfirst;

	    if (tdiff <= rdiff)
		diff = tdiff;
	    else
		diff = rdiff;

	    if (rfirst == 0xffffffff) {
		diff = tdiff;	/* oops, pretend rdiff is infinite */
		if (diff > 0)
		    Perl_sv_catpvf(aTHX_ listsv, "%04lx\t%04lx\tXXXX\n",
				   (long)tfirst, (long)tlast);
		else
		    Perl_sv_catpvf(aTHX_ listsv, "%04lx\t\tXXXX\n", (long)tfirst);
	    }
	    else {
		if (diff > 0)
		    Perl_sv_catpvf(aTHX_ listsv, "%04lx\t%04lx\t%04lx\n",
				   (long)tfirst, (long)(tfirst + diff),
				   (long)rfirst);
		else
		    Perl_sv_catpvf(aTHX_ listsv, "%04lx\t\t%04lx\n",
				   (long)tfirst, (long)rfirst);

		if (rfirst + diff > max)
		    max = rfirst + diff;
		rfirst += diff + 1;
		if (!grows) {
		    if (rfirst <= 0x80)
			;
		    else if (rfirst <= 0x800)
			grows |= (tfirst < 0x80);
		    else if (rfirst <= 0x10000)
			grows |= (tfirst < 0x800);
		    else if (rfirst <= 0x200000)
			grows |= (tfirst < 0x10000);
		    else if (rfirst <= 0x4000000)
			grows |= (tfirst < 0x200000);
		    else if (rfirst <= 0x80000000)
			grows |= (tfirst < 0x4000000);
		}
	    }
	    tfirst += diff + 1;
	}

	none = ++max;
	if (del)
	    del = ++max;

	if (max > 0xffff)
	    bits = 32;
	else if (max > 0xff)
	    bits = 16;
	else
	    bits = 8;

	cSVOPo->op_sv = (SV*)swash_init("utf8", "", listsv, bits, none);
	SvREFCNT_dec(listsv);
	if (transv)
	    SvREFCNT_dec(transv);

	if (!del && havefinal)
	    (void)hv_store((HV*)SvRV((cSVOPo->op_sv)), "FINAL", 5,
			   newSVuv((UV)final), 0);

	if (grows && to_utf)
	    o->op_private |= OPpTRANS_GROWS;

	op_free(expr);
	op_free(repl);
	return o;
    }

    tbl = (short*)cPVOPo->op_pv;
d2105 1
a2105 1
		    if (del)
d2118 1
a2118 1
	if (!rlen && !del) {
d2121 1
a2121 1
		o->op_private |= OPpTRANS_IDENTICAL;
d2127 1
a2127 1
		if (del) {
d2145 1
a2145 1
Perl_newPMOP(pTHX_ I32 type, I32 flags)
d2150 1
a2150 1
    NewOp(1101, pmop, 1, PMOP);
d2152 1
a2152 1
    pmop->op_ppaddr = PL_ppaddr[type];
d2172 1
a2172 1
Perl_pmruntime(pTHX_ OP *o, OP *expr, OP *repl)
d2194 1
a2194 3
	if ((PL_hints & HINT_UTF8) || (SvUTF8(pat) && !(PL_hints & HINT_BYTE)))
	    pm->op_pmdynflags |= PMdf_UTF8;
	pm->op_pmregexp = CALLREGCOMP(aTHX_ p, p + plen, pm);
a2199 2
	if (PL_hints & HINT_UTF8)
	    pm->op_pmdynflags |= PMdf_UTF8;
d2205 1
a2205 1
	NewOp(1101, rcop, 1, LOGOP);
d2207 1
a2207 1
	rcop->op_ppaddr = PL_ppaddr[OP_REGCOMP];
d2233 2
a2234 2
	    if (CopLINE(PL_curcop) < PL_multi_end)
		CopLINE_set(PL_curcop, PL_multi_end);
d2249 1
a2249 1
		if (PL_opargs[curop->op_type] & OA_DANGEROUS) {
d2258 1
a2258 1
			GV *gv = cGVOPx_gv(curop);
d2300 1
a2300 1
	    NewOp(1101, rcop, 1, LOGOP);
d2302 1
a2302 1
	    rcop->op_ppaddr = PL_ppaddr[OP_SUBSTCONT];
d2322 1
a2322 1
Perl_newSVOP(pTHX_ I32 type, I32 flags, SV *sv)
d2325 1
a2325 1
    NewOp(1101, svop, 1, SVOP);
d2327 1
a2327 1
    svop->op_ppaddr = PL_ppaddr[type];
d2331 1
a2331 1
    if (PL_opargs[type] & OA_RETSCALAR)
d2333 1
a2333 1
    if (PL_opargs[type] & OA_TARGET)
d2339 1
a2339 21
Perl_newPADOP(pTHX_ I32 type, I32 flags, SV *sv)
{
    PADOP *padop;
    NewOp(1101, padop, 1, PADOP);
    padop->op_type = type;
    padop->op_ppaddr = PL_ppaddr[type];
    padop->op_padix = pad_alloc(type, SVs_PADTMP);
    SvREFCNT_dec(PL_curpad[padop->op_padix]);
    PL_curpad[padop->op_padix] = sv;
    SvPADTMP_on(sv);
    padop->op_next = (OP*)padop;
    padop->op_flags = flags;
    if (PL_opargs[type] & OA_RETSCALAR)
	scalar((OP*)padop);
    if (PL_opargs[type] & OA_TARGET)
	padop->op_targ = pad_alloc(type, SVs_PADTMP);
    return CHECKOP(type, padop);
}

OP *
Perl_newGVOP(pTHX_ I32 type, I32 flags, GV *gv)
d2342 12
a2353 6
#ifdef USE_ITHREADS
    GvIN_PAD_on(gv);
    return newPADOP(type, flags, SvREFCNT_inc(gv));
#else
    return newSVOP(type, flags, SvREFCNT_inc(gv));
#endif
d2357 1
a2357 1
Perl_newPVOP(pTHX_ I32 type, I32 flags, char *pv)
d2360 1
a2360 1
    NewOp(1101, pvop, 1, PVOP);
d2362 1
a2362 1
    pvop->op_ppaddr = PL_ppaddr[type];
d2366 1
a2366 1
    if (PL_opargs[type] & OA_RETSCALAR)
d2368 1
a2368 1
    if (PL_opargs[type] & OA_TARGET)
d2374 1
a2374 1
Perl_package(pTHX_ OP *o)
d2400 1
a2400 1
Perl_utilize(pTHX_ int aver, I32 floor, OP *version, OP *id, OP *arg)
d2403 1
d2410 1
a2410 1
	Perl_croak(aTHX_ "Module name must be constant");
d2414 1
a2414 1
    if (version != Nullop) {
d2417 1
a2417 1
	if (arg == Nullop && !SvNIOKp(vesv)) {
d2422 1
a2422 1
	    SV *meth;
d2424 2
a2425 2
	    if (version->op_type != OP_CONST || !SvNIOKp(vesv))
		Perl_croak(aTHX_ "Version number must be constant number");
d2431 1
a2431 4
	    meth = newSVpvn("VERSION",7);
	    sv_upgrade(meth, SVt_PVIV);
	    (void)SvIOK_on(meth);
	    PERL_HASH(SvUVX(meth), SvPVX(meth), SvCUR(meth));
d2434 2
a2435 2
					prepend_elem(OP_LIST, pack, list(version)),
					newSVOP(OP_METHOD_NAMED, 0, meth)));
d2442 1
a2442 1
    else if (SvNIOKp(((SVOP*)id)->op_sv)) {
a2445 2
	SV *meth;

d2448 5
a2452 6

	/* Fake up a method call to import/unimport */
	meth = aver ? newSVpvn("import",6) : newSVpvn("unimport", 8);;
	sv_upgrade(meth, SVt_PVIV);
	(void)SvIOK_on(meth);
	PERL_HASH(SvUVX(meth), SvPVX(meth), SvCUR(meth));
d2454 3
a2456 3
		       append_elem(OP_LIST,
				   prepend_elem(OP_LIST, pack, list(arg)),
				   newSVOP(OP_METHOD_NAMED, 0, meth)));
d2476 2
a2477 3
    newATTRSUB(floor,
	newSVOP(OP_CONST, 0, newSVpvn("BEGIN", 5)),
	Nullop,
a2484 1
    PL_hints |= HINT_BLOCK_SCOPE;
a2488 52
void
Perl_load_module(pTHX_ U32 flags, SV *name, SV *ver, ...)
{
    va_list args;
    va_start(args, ver);
    vload_module(flags, name, ver, &args);
    va_end(args);
}

#ifdef PERL_IMPLICIT_CONTEXT
void
Perl_load_module_nocontext(U32 flags, SV *name, SV *ver, ...)
{
    dTHX;
    va_list args;
    va_start(args, ver);
    vload_module(flags, name, ver, &args);
    va_end(args);
}
#endif

void
Perl_vload_module(pTHX_ U32 flags, SV *name, SV *ver, va_list *args)
{
    OP *modname, *veop, *imop;

    modname = newSVOP(OP_CONST, 0, name);
    modname->op_private |= OPpCONST_BARE;
    if (ver) {
	veop = newSVOP(OP_CONST, 0, ver);
    }
    else
	veop = Nullop;
    if (flags & PERL_LOADMOD_NOIMPORT) {
	imop = sawparens(newNULLLIST());
    }
    else if (flags & PERL_LOADMOD_IMPORT_OPS) {
	imop = va_arg(*args, OP*);
    }
    else {
	SV *sv;
	imop = Nullop;
	sv = va_arg(*args, SV*);
	while (sv) {
	    imop = append_elem(OP_LIST, imop, newSVOP(OP_CONST, 0, sv));
	    sv = va_arg(*args, SV*);
	}
    }
    utilize(!(flags & PERL_LOADMOD_DENY), start_subparse(FALSE, 0),
	    veop, modname, imop);
}

d2490 1
a2490 1
Perl_dofile(pTHX_ OP *term)
d2513 1
a2513 1
Perl_newSLICEOP(pTHX_ I32 flags, OP *subscript, OP *listval)
d2521 1
a2521 1
S_list_assignment(pTHX_ register OP *o)
d2530 2
a2531 2
	I32 t = list_assignment(cLOGOPo->op_first->op_sibling);
	I32 f = list_assignment(cLOGOPo->op_first->op_sibling->op_sibling);
d2555 1
a2555 1
Perl_newASSIGNOP(pTHX_ I32 flags, OP *left, I32 optype, OP *right)
a2572 2
	OP *curop;

d2583 3
a2585 2
	curop = list(force_list(left));
	o = newBINOP(OP_AASSIGN, flags, list(force_list(right)), curop);
a2586 9
	for (curop = ((LISTOP*)curop)->op_first;
	     curop; curop = curop->op_sibling)
	{
	    if (curop->op_type == OP_RV2HV &&
		((UNOP*)curop)->op_first->op_type != OP_GV) {
		o->op_private |= OPpASSIGN_HASH;
		break;
	    }
	}
d2588 1
d2592 1
a2592 1
		if (PL_opargs[curop->op_type] & OA_DANGEROUS) {
d2594 1
a2594 1
			GV *gv = cGVOPx_gv(curop);
d2632 1
a2632 1
		o->op_private |= OPpASSIGN_COMMON;
d2646 1
a2646 7
#ifdef USE_ITHREADS
			pm->op_pmreplroot = (OP*)cPADOPx(tmpop)->op_padix;
			cPADOPx(tmpop)->op_padix = 0;	/* steal it */
#else
			pm->op_pmreplroot = (OP*)cSVOPx(tmpop)->op_sv;
			cSVOPx(tmpop)->op_sv = Nullsv;	/* steal it */
#endif
d2692 1
a2692 1
Perl_newSTATEOP(pTHX_ I32 flags, char *label, OP *o)
d2698 2
a2699 2
    NewOp(1101, cop, 1, COP);
    if (PERLDB_LINE && CopLINE(PL_curcop) && PL_curstash != PL_debstash) {
d2701 1
a2701 1
	cop->op_ppaddr = PL_ppaddr[ OP_DBSTATE ];
d2705 1
a2705 1
	cop->op_ppaddr = PL_ppaddr[ OP_NEXTSTATE ];
d2708 1
a2708 1
    cop->op_private = (PL_hints & HINT_BYTE);
a2711 1
    PL_compiling.op_private = cop->op_private;
a2719 5
    if (specialWARN(PL_curcop->cop_warnings))
        cop->cop_warnings = PL_curcop->cop_warnings ;
    else 
        cop->cop_warnings = newSVsv(PL_curcop->cop_warnings) ;

d2722 1
a2722 1
        CopLINE_set(cop, CopLINE(PL_curcop));
d2724 1
a2724 1
	CopLINE_set(cop, PL_copline);
d2727 2
a2728 6
#ifdef USE_ITHREADS
    CopFILE_set(cop, CopFILE(PL_curcop));	/* XXXXX share in a pvtable? */
#else
    CopFILEGV_set(cop, (GV*)SvREFCNT_inc(CopFILEGV(PL_curcop)));
#endif
    CopSTASH_set(cop, PL_curstash);
d2731 1
a2731 1
	SV **svp = av_fetch(CopFILEAV(PL_curcop), (I32)CopLINE(cop), FALSE);
d2734 2
a2735 1
	    SvIVX(*svp) = PTR2IV(cop);
d2744 1
a2744 1
Perl_intro_my(pTHX)
d2757 1
a2757 1
	    SvNVX(sv) = (NV)PL_cop_seqmax;
d2766 1
a2766 1
Perl_newLOGOP(pTHX_ I32 type, I32 flags, OP *first, OP *other)
d2772 1
a2772 1
S_new_logop(pTHX_ I32 type, I32 flags, OP** firstp, OP** otherp)
d2800 2
a2801 2
	if (ckWARN(WARN_BAREWORD) && (first->op_private & OPpCONST_BARE))
	    Perl_warner(aTHX_ WARN_BAREWORD, "Bareword found in conditional"); 
d2819 1
a2819 1
    else if (ckWARN(WARN_MISC) && (first->op_flags & OPf_KIDS)) {
a2828 1
	    {
a2829 1
	    }
a2834 1
		  || (k1->op_type == OP_NULL && k1->op_targ == OP_GLOB)
d2836 1
a2836 4
	    {
		warnop = ((k1->op_type == OP_NULL)
			  ? k1->op_targ : k1->op_type);
	    }
d2840 4
a2843 5
	    line_t oldline = CopLINE(PL_curcop);
	    CopLINE_set(PL_curcop, PL_copline);
	    Perl_warner(aTHX_ WARN_MISC,
		 "Value of %s%s can be \"0\"; test with defined()",
		 PL_op_desc[warnop],
d2846 1
a2846 1
	    CopLINE_set(PL_curcop, oldline);
d2856 1
a2856 1
    NewOp(1101, logop, 1, LOGOP);
d2859 1
a2859 1
    logop->op_ppaddr = PL_ppaddr[type];
d2877 1
a2877 1
Perl_newCONDOP(pTHX_ I32 flags, OP *first, OP *trueop, OP *falseop)
d2880 1
a2880 2
    LOGOP *logop;
    OP *start;
d2905 1
a2905 8
    NewOp(1101, logop, 1, LOGOP);
    logop->op_type = OP_COND_EXPR;
    logop->op_ppaddr = PL_ppaddr[OP_COND_EXPR];
    logop->op_first = first;
    logop->op_flags = flags | OPf_KIDS;
    logop->op_private = 1 | (flags >> 8);
    logop->op_other = LINKLIST(trueop);
    logop->op_next = LINKLIST(falseop);
d2907 7
d2916 2
a2917 2
    start = LINKLIST(first);
    first->op_next = (OP*)logop;
d2921 1
a2921 1
    o = newUNOP(OP_NULL, 0, (OP*)logop);
d2923 2
a2924 1
    trueop->op_next = falseop->op_next = o;
a2925 1
    o->op_next = start;
d2930 1
a2930 1
Perl_newRANGE(pTHX_ I32 flags, OP *left, OP *right)
d2933 1
a2933 1
    LOGOP *range;
a2935 1
    OP *leftstart;
d2938 1
a2938 1
    NewOp(1101, range, 1, LOGOP);
d2940 7
a2946 7
    range->op_type = OP_RANGE;
    range->op_ppaddr = PL_ppaddr[OP_RANGE];
    range->op_first = left;
    range->op_flags = OPf_KIDS;
    leftstart = LINKLIST(left);
    range->op_other = LINKLIST(right);
    range->op_private = 1 | (flags >> 8);
d2950 2
a2951 2
    range->op_next = (OP*)range;
    flip = newUNOP(OP_FLIP, flags, (OP*)range);
a2954 1
    range->op_next = leftstart;
d2959 2
a2960 2
    range->op_targ = pad_alloc(OP_RANGE, SVs_PADMY);
    sv_upgrade(PAD_SV(range->op_targ), SVt_PVNV);
d2975 1
a2975 1
Perl_newLOOPOP(pTHX_ I32 flags, I32 debuggable, OP *expr, OP *block)
a3003 1
		      || (k1->op_type == OP_NULL && k1->op_targ == OP_NULL)
d3030 1
a3030 1
Perl_newWHILEOP(pTHX_ I32 flags, I32 debuggable, LOOP *loop, I32 whileline, OP *expr, OP *block, OP *cont)
a3037 1
    U8 loopflags = 0;
a3056 1
		  || (k1->op_type == OP_NULL && k1->op_targ == OP_GLOB)
a3064 3
    else if (cont) {
	block = scope(block);
    }
d3066 1
a3066 1
    if (cont) {
a3067 2
	loopflags |= OPpLOOP_CONTINUE;
    }
d3099 1
a3099 1
	NewOp(1101,loop,1,LOOP);
d3101 1
a3101 1
	loop->op_ppaddr = PL_ppaddr[OP_ENTERLOOP];
a3109 1
    o->op_private |= loopflags;
d3122 1
a3122 1
Perl_newFOROP(pTHX_ I32 flags,char *label,line_t forline,OP *sv,OP *expr,OP *block,OP *cont)
d3132 1
a3132 1
	    sv->op_ppaddr = PL_ppaddr[OP_RV2GV];
a3135 1
	    sv->op_targ = 0;
a3140 1
	    sv->op_targ = 0;
d3146 1
a3146 1
	    Perl_croak(aTHX_ "Can't use %s for loop variable", PL_op_desc[sv->op_type]);
d3169 1
a3169 1
	LOGOP* range = (LOGOP*) flip->op_first;
d3178 2
a3179 2
	listop->op_first->op_next = range->op_next;
	left->op_next = range->op_other;
a3195 8
#ifdef PL_OP_SLAB_ALLOC
    {
	LOOP *tmp;
	NewOp(1234,tmp,1,LOOP);
	Copy(loop,tmp,1,LOOP);
	loop = tmp;
    }
#else
a3196 1
#endif 
d3204 1
a3204 1
Perl_newLOOPEX(pTHX_ I32 type, OP *label)
a3208 1

d3230 1
a3230 1
Perl_cv_undef(pTHX_ CV *cv)
d3244 1
a3244 1
	    Perl_croak(aTHX_ "Can't undef active subroutine");
d3247 1
a3247 1
	    Perl_croak(aTHX_ "Can't undef active subroutine");
d3251 1
a3251 1
	SAVEVPTR(PL_curpad);
d3288 1
d3290 2
a3291 1
S_cv_dump(pTHX_ CV *cv)
a3292 1
#ifdef DEBUGGING
d3301 2
a3302 3
    PerlIO_printf(Perl_debug_log,
		  "\tCV=0x%"UVxf" (%s), OUTSIDE=0x%"UVxf" (%s)\n",
		  PTR2UV(cv),
d3307 1
a3307 1
		  PTR2UV(outside),
d3324 2
a3325 3
	    PerlIO_printf(Perl_debug_log,
			  "\t%4d. 0x%"UVxf" (%s\"%s\" %"IVdf"-%"IVdf")\n",
			  (int)ix, PTR2UV(ppad[ix]),
d3328 2
a3329 2
			  (IV)I_32(SvNVX(pname[ix])),
			  SvIVX(pname[ix]));
a3330 1
#endif /* DEBUGGING */
d3332 1
d3335 1
a3335 1
S_cv_clone2(pTHX_ CV *proto, CV *outside)
d3353 2
a3354 1
    SAVECOMPPAD();
a3359 1
    CvFLAGS(cv) = CvFLAGS(proto) & ~CVf_CLONE;
d3361 2
d3369 1
a3369 1
    CvFILE(cv)		= CvFILE(proto);
d3409 1
a3409 1
		    Perl_croak(aTHX_ "panic: cv_clone: %s", name);
a3427 3
	else if (IS_PADGV(ppad[ix]) || IS_PADCONST(ppad[ix])) {
	    PL_curpad[ix] = SvREFCNT_inc(ppad[ix]);
	}
d3467 1
a3467 1
Perl_cv_clone(pTHX_ CV *proto)
d3470 1
a3470 1
    LOCK_CRED_MUTEX;			/* XXX create separate mutex */
d3472 1
a3472 1
    UNLOCK_CRED_MUTEX;			/* XXX create separate mutex */
d3477 1
a3477 1
Perl_cv_ckproto(pTHX_ CV *cv, GV *gv, char *p)
d3479 1
a3479 3
    dTHR;

    if (((!p != !SvPOK(cv)) || (p && strNE(p, SvPVX(cv)))) && ckWARN_d(WARN_PROTOTYPE)) {
d3487 1
a3487 1
	    Perl_sv_catpvf(aTHX_ msg, " sub %"SVf, name);
d3489 1
a3489 1
	    Perl_sv_catpvf(aTHX_ msg, " (%s)", SvPVX(cv));
d3492 1
a3492 1
	    Perl_sv_catpvf(aTHX_ msg, "(%s)", p);
d3495 1
a3495 1
	Perl_warner(aTHX_ WARN_PROTOTYPE, "%"SVf, msg);
d3500 1
a3500 1
Perl_cv_const_sv(pTHX_ CV *cv)
d3508 1
a3508 1
Perl_op_const_sv(pTHX_ OP *o, CV *cv)
d3512 1
a3512 1
    if (!o)
d3515 1
a3515 1
    if (o->op_type == OP_LINESEQ && cLISTOPo->op_first) 
d3521 1
a3521 1
	if (sv && o->op_next == o) 
d3529 1
a3529 1
	if (type == OP_CONST && cSVOPo->op_sv)
d3531 1
a3531 1
	else if ((type == OP_PADSV || type == OP_CONST) && cv) {
a3544 14
void
Perl_newMYSUB(pTHX_ I32 floor, OP *o, OP *proto, OP *attrs, OP *block)
{
    if (o)
	SAVEFREEOP(o);
    if (proto)
	SAVEFREEOP(proto);
    if (attrs)
	SAVEFREEOP(attrs);
    if (block)
	SAVEFREEOP(block);
    Perl_croak(aTHX_ "\"my sub\" not yet implemented");
}

d3546 1
a3546 7
Perl_newSUB(pTHX_ I32 floor, OP *o, OP *proto, OP *block)
{
    return Perl_newATTRSUB(aTHX_ floor, o, proto, Nullop, block);
}

CV *
Perl_newATTRSUB(pTHX_ I32 floor, OP *o, OP *proto, OP *attrs, OP *block)
d3550 3
a3552 3
    char *name;
    char *aname;
    GV *gv;
a3556 13
    name = o ? SvPVx(cSVOPo->op_sv, n_a) : Nullch;
    if (!name && PERLDB_NAMEANON && CopLINE(PL_curcop)) {
	SV *sv = sv_newmortal();
	Perl_sv_setpvf(aTHX_ sv, "__ANON__[%s:%"IVdf"]",
		       CopFILE(PL_curcop), (IV)CopLINE(PL_curcop));
	aname = SvPVX(sv);
    }
    else
	aname = Nullch;
    gv = gv_fetchpv(name ? name : (aname ? aname : "__ANON__"),
		    GV_ADDMULTI | ((block || attrs) ? 0 : GV_NOINIT),
		    SVt_PVCV);

a3560 2
    if (attrs)
	SAVEFREEOP(attrs);
d3562 1
a3562 1
    if (SvTYPE(gv) != SVt_PVGV) {	/* Maybe prototype now, and had at
d3565 2
a3566 5
	    if (!SvPOK((SV*)gv) && !(SvIOK((SV*)gv) && SvIVX((SV*)gv) == -1)
		&& ckWARN_d(WARN_PROTOTYPE))
	    {
		Perl_warner(aTHX_ WARN_PROTOTYPE, "Runaway prototype");
	    }
d3581 1
a3581 1
    else if ((cv = GvCV(gv))) {
d3587 1
a3587 1
	    if (!block && !attrs) {
d3594 2
a3595 4
		Perl_croak(aTHX_ "Can't redefine active sort subroutine %s", name);
	    if (!block)
		goto withattrs;
	    if ((const_sv = cv_const_sv(cv)))
d3597 9
a3605 8
	    if ((const_sv || const_changed) && ckWARN(WARN_REDEFINE))
	    {
		line_t oldline = CopLINE(PL_curcop);
		CopLINE_set(PL_curcop, PL_copline);
		Perl_warner(aTHX_ WARN_REDEFINE,
			const_sv ? "Constant subroutine %s redefined"
				 : "Subroutine %s redefined", name);
		CopLINE_set(PL_curcop, oldline);
a3610 27
  withattrs:
    if (attrs) {
	HV *stash;
	SV *rcv;

	/* Need to do a C<use attributes $stash_of_cv,\&cv,@@attrs>
	 * before we clobber PL_compcv.
	 */
	if (cv && !block) {
	    rcv = (SV*)cv;
	    if (CvGV(cv) && GvSTASH(CvGV(cv)) && HvNAME(GvSTASH(CvGV(cv))))
		stash = GvSTASH(CvGV(cv));
	    else if (CvSTASH(cv) && HvNAME(CvSTASH(cv)))
		stash = CvSTASH(cv);
	    else
		stash = PL_curstash;
	}
	else {
	    /* possibly about to re-define existing subr -- ignore old cv */
	    rcv = (SV*)PL_compcv;
	    if (name && GvSTASH(gv) && HvNAME(GvSTASH(gv)))
		stash = GvSTASH(gv);
	    else
		stash = PL_curstash;
	}
	apply_attrs(stash, rcv, attrs);
    }
a3611 5
	if (!block) {
	    /* got here with just attrs -- work done, so bug out */
	    SAVEFREESV(PL_compcv);
	    goto done;
	}
d3631 1
a3631 1
    CvFILE(cv) = CopFILE(PL_curcop);
d3653 2
a3654 2
		if (PL_in_eval & EVAL_KEEPERR)
		    Perl_croak(aTHX_ not_safe);
d3658 1
a3658 1
		    Perl_croak(aTHX_ "%s", SvPVx(ERRSV, n_a));
a3672 13
    if (CvLVALUE(cv)) {
	CvROOT(cv) = newUNOP(OP_LEAVESUBLV, 0, scalarseq(block));
    }
    else {
	CvROOT(cv) = newUNOP(OP_LEAVESUB, 0, scalarseq(block));
    }
    CvROOT(cv)->op_private |= OPpREFCOUNTED;
    OpREFCNT_set(CvROOT(cv), 1);
    CvSTART(cv) = LINKLIST(CvROOT(cv));
    CvROOT(cv)->op_next = 0;
    peep(CvSTART(cv));

    /* now that optimizer has done its work, adjust pad values */
d3678 1
a3678 1
	    if (SvIMMORTAL(PL_curpad[ix]) || IS_PADGV(PL_curpad[ix]) || IS_PADCONST(PL_curpad[ix]))
d3702 1
a3702 1
	    if (SvIMMORTAL(PL_curpad[ix]) || IS_PADGV(PL_curpad[ix]) || IS_PADCONST(PL_curpad[ix]))
d3709 6
a3714 1
    if (name || aname) {
a3715 1
	char *tname = (name ? name : aname);
d3721 1
a3721 1
	    CV *pcv;
d3724 3
a3726 3
	    Perl_sv_setpvf(aTHX_ sv, "%s:%ld-%ld",
			   CopFILE(PL_curcop),
			   (long)PL_subline, (long)CopLINE(PL_curcop));
d3731 1
a3731 2
		&& (pcv = GvCV(db_postponed)))
	    {
d3736 1
a3736 1
		call_sv((SV*)pcv, G_DISCARD);
d3740 1
a3740 1
	if ((s = strrchr(tname,':')))
d3743 1
a3743 5
	    s = tname;

	if (*s != 'B' && *s != 'E' && *s != 'C' && *s != 'I')
	    goto done;

d3747 2
a3748 2
	    SAVECOPFILE(&PL_compiling);
	    SAVECOPLINE(&PL_compiling);
d3755 1
a3755 1
	    av_push(PL_beginav, SvREFCNT_inc(cv));
a3759 1
	    PL_compiling.op_private = PL_hints;
a3764 1
	    DEBUG_x( dump_sub(gv) );
d3766 1
a3766 11
	    av_store(PL_endav, 0, SvREFCNT_inc(cv));
	    GvCV(gv) = 0;
	}
	else if (strEQ(s, "CHECK") && !PL_error_count) {
	    if (!PL_checkav)
		PL_checkav = newAV();
	    DEBUG_x( dump_sub(gv) );
	    if (PL_main_start && ckWARN(WARN_VOID))
		Perl_warner(aTHX_ WARN_VOID, "Too late to run CHECK block");
	    av_unshift(PL_checkav, 1);
	    av_store(PL_checkav, 0, SvREFCNT_inc(cv));
a3771 3
	    DEBUG_x( dump_sub(gv) );
	    if (PL_main_start && ckWARN(WARN_VOID))
		Perl_warner(aTHX_ WARN_VOID, "Too late to run INIT block");
a3783 9
/*
=for apidoc newCONSTSUB

Creates a constant sub equivalent to Perl C<sub FOO () { 123 }> which is
eligible for inlining at compile-time.

=cut
*/

d3785 1
a3785 1
Perl_newCONSTSUB(pTHX_ HV *stash, char *name, SV *sv)
d3788 5
a3793 5
    ENTER;
    SAVECOPLINE(PL_curcop);
    SAVEHINTS();

    CopLINE_set(PL_curcop, PL_copline);
d3795 2
d3798 1
a3798 12
    if (stash) {
	SAVESPTR(PL_curstash);
	SAVECOPSTASH(PL_curcop);
	PL_curstash = stash;
#ifdef USE_ITHREADS
	CopSTASHPV(PL_curcop) = stash ? HvNAME(stash) : Nullch;
#else
	CopSTASH(PL_curcop) = stash;
#endif
    }

    newATTRSUB(
a3801 1
	Nullop,
d3805 4
a3808 1
    LEAVE;
a3810 8
/*
=for apidoc U||newXS

Used by C<xsubpp> to hook up XSUBs as Perl subs.

=cut
*/

d3812 1
a3812 1
Perl_newXS(pTHX_ char *name, XSUBADDR_t subaddr, char *filename)
d3818 1
a3818 1
    if ((cv = (name ? GvCV(gv) : Nullcv))) {
d3826 1
a3826 1
	    if (ckWARN(WARN_REDEFINE) && !(CvGV(cv) && GvSTASH(CvGV(cv))
d3829 1
a3829 1
		line_t oldline = CopLINE(PL_curcop);
d3831 3
a3833 3
		    CopLINE_set(PL_curcop, PL_copline);
		Perl_warner(aTHX_ WARN_REDEFINE, "Subroutine %s redefined",name);
		CopLINE_set(PL_curcop, oldline);
d3857 1
a3857 3
    (void)gv_fetchfile(filename);
    CvFILE(cv) = filename;	/* NOTE: not copied, as it is expected to be
				   an external constant string */
a3865 4

	if (*s != 'B' && *s != 'E' && *s != 'C' && *s != 'I')
	    goto done;

d3869 1
a3869 1
	    av_push(PL_beginav, SvREFCNT_inc(cv));
d3876 1
a3876 10
	    av_store(PL_endav, 0, SvREFCNT_inc(cv));
	    GvCV(gv) = 0;
	}
	else if (strEQ(s, "CHECK")) {
	    if (!PL_checkav)
		PL_checkav = newAV();
	    if (PL_main_start && ckWARN(WARN_VOID))
		Perl_warner(aTHX_ WARN_VOID, "Too late to run CHECK block");
	    av_unshift(PL_checkav, 1);
	    av_store(PL_checkav, 0, SvREFCNT_inc(cv));
d3882 1
a3882 3
	    if (PL_main_start && ckWARN(WARN_VOID))
		Perl_warner(aTHX_ WARN_VOID, "Too late to run INIT block");
	    av_push(PL_initav, SvREFCNT_inc(cv));
a3888 1
done:
d3893 1
a3893 1
Perl_newFORM(pTHX_ I32 floor, OP *o, OP *block)
d3908 7
a3914 7
    if ((cv = GvFORM(gv))) {
	if (ckWARN(WARN_REDEFINE)) {
	    line_t oldline = CopLINE(PL_curcop);

	    CopLINE_set(PL_curcop, PL_copline);
	    Perl_warner(aTHX_ WARN_REDEFINE, "Format %s redefined",name);
	    CopLINE_set(PL_curcop, oldline);
d3921 1
a3921 1
    CvFILE(cv) = CopFILE(PL_curcop);
a3928 2
    CvROOT(cv)->op_private |= OPpREFCOUNTED;
    OpREFCNT_set(CvROOT(cv), 1);
d3938 1
a3938 1
Perl_newANONLIST(pTHX_ OP *o)
d3945 1
a3945 1
Perl_newANONHASH(pTHX_ OP *o)
d3952 1
a3952 7
Perl_newANONSUB(pTHX_ I32 floor, OP *proto, OP *block)
{
    return newANONATTRSUB(floor, proto, Nullop, block);
}

OP *
Perl_newANONATTRSUB(pTHX_ I32 floor, OP *proto, OP *attrs, OP *block)
d3955 1
a3955 2
	newSVOP(OP_ANONCODE, 0,
		(SV*)newATTRSUB(floor, 0, proto, attrs, block)));
d3959 1
a3959 1
Perl_oopsAV(pTHX_ OP *o)
d3964 1
a3964 1
	o->op_ppaddr = PL_ppaddr[OP_PADAV];
d3969 1
a3969 1
	o->op_ppaddr = PL_ppaddr[OP_RV2AV];
d3974 1
a3974 2
	if (ckWARN_d(WARN_INTERNAL))
	    Perl_warner(aTHX_ WARN_INTERNAL, "oops: oopsAV");
d3981 1
a3981 1
Perl_oopsHV(pTHX_ OP *o)
a3982 2
    dTHR;
    
d3987 1
a3987 1
	o->op_ppaddr = PL_ppaddr[OP_PADHV];
d3993 1
a3993 1
	o->op_ppaddr = PL_ppaddr[OP_RV2HV];
d3998 1
a3998 2
	if (ckWARN_d(WARN_INTERNAL))
	    Perl_warner(aTHX_ WARN_INTERNAL, "oops: oopsHV");
d4005 1
a4005 1
Perl_newAVREF(pTHX_ OP *o)
d4009 1
a4009 1
	o->op_ppaddr = PL_ppaddr[OP_PADAV];
d4016 1
a4016 1
Perl_newGVREF(pTHX_ I32 type, OP *o)
d4018 1
a4018 1
    if (type == OP_MAPSTART || type == OP_GREPSTART || type == OP_SORT)
d4024 1
a4024 1
Perl_newHVREF(pTHX_ OP *o)
d4028 1
a4028 1
	o->op_ppaddr = PL_ppaddr[OP_PADHV];
d4035 1
a4035 1
Perl_oopsCV(pTHX_ OP *o)
d4037 1
a4037 1
    Perl_croak(aTHX_ "NOT IMPL LINE %d",__LINE__);
d4043 1
a4043 1
Perl_newCVREF(pTHX_ I32 flags, OP *o)
d4049 1
a4049 1
Perl_newSVREF(pTHX_ OP *o)
d4053 1
a4053 1
	o->op_ppaddr = PL_ppaddr[OP_PADSV];
d4066 1
a4066 1
Perl_ck_anoncode(pTHX_ OP *o)
d4086 1
a4086 1
Perl_ck_bitop(pTHX_ OP *o)
d4093 1
a4093 1
Perl_ck_concat(pTHX_ OP *o)
d4101 1
a4101 1
Perl_ck_spair(pTHX_ OP *o)
d4112 1
a4112 1
	     !(PL_opargs[newop->op_type] & OA_RETSCALAR) ||
d4121 1
a4121 1
    o->op_ppaddr = PL_ppaddr[++o->op_type];
d4126 1
a4126 1
Perl_ck_delete(pTHX_ OP *o)
d4132 1
a4132 5
	switch (kid->op_type) {
	case OP_ASLICE:
	    o->op_flags |= OPf_SPECIAL;
	    /* FALL THROUGH */
	case OP_HSLICE:
d4134 3
a4136 10
	    break;
	case OP_AELEM:
	    o->op_flags |= OPf_SPECIAL;
	    /* FALL THROUGH */
	case OP_HELEM:
	    break;
	default:
	    Perl_croak(aTHX_ "%s argument is not a HASH or ARRAY element or slice",
		  PL_op_desc[o->op_type]);
	}
d4143 1
a4143 1
Perl_ck_eof(pTHX_ OP *o)
d4159 1
a4159 1
Perl_ck_eval(pTHX_ OP *o)
d4176 1
a4176 1
	    NewOp(1101, enter, 1, LOGOP);
d4178 1
a4178 1
	    enter->op_ppaddr = PL_ppaddr[OP_ENTERTRY];
d4186 1
a4186 1
	    o->op_ppaddr = PL_ppaddr[OP_LEAVETRY];
d4202 1
a4202 15
Perl_ck_exit(pTHX_ OP *o)
{
#ifdef VMS
    HV *table = GvHV(PL_hintgv);
    if (table) {
       SV **svp = hv_fetch(table, "vmsish_exit", 11, FALSE);
       if (svp && *svp && SvTRUE(*svp))
           o->op_private |= OPpEXIT_VMSISH;
    }
#endif
    return ck_fun(o);
}

OP *
Perl_ck_exec(pTHX_ OP *o)
d4217 1
a4217 1
Perl_ck_exists(pTHX_ OP *o)
d4222 2
a4223 12
	if (kid->op_type == OP_ENTERSUB) {
	    (void) ref(kid, o->op_type);
	    if (kid->op_type != OP_RV2CV && !PL_error_count)
		Perl_croak(aTHX_ "%s argument is not a subroutine name",
			   PL_op_desc[o->op_type]);
	    o->op_private |= OPpEXISTS_SUB;
	}
	else if (kid->op_type == OP_AELEM)
	    o->op_flags |= OPf_SPECIAL;
	else if (kid->op_type != OP_HELEM)
	    Perl_croak(aTHX_ "%s argument is not a HASH or ARRAY element",
		       PL_op_desc[o->op_type]);
a4228 1
#if 0
d4230 1
a4230 1
Perl_ck_gvconst(pTHX_ register OP *o)
a4236 1
#endif
d4239 1
a4239 1
Perl_ck_rvconst(pTHX_ register OP *o)
d4286 1
a4286 1
		Perl_croak(aTHX_ "Constant is not %s reference", badtype);
d4290 1
d4305 1
a4305 1
		Perl_croak(aTHX_ 
a4333 6
#ifdef USE_ITHREADS
	    /* XXX hack: dependence on sizeof(PADOP) <= sizeof(SVOP) */
	    kPADOP->op_padix = pad_alloc(OP_GV, SVs_PADTMP);
	    GvIN_PAD_on(gv);
	    PL_curpad[kPADOP->op_padix] = SvREFCNT_inc(gv);
#else
a4334 2
#endif
	    kid->op_ppaddr = PL_ppaddr[OP_GV];
d4341 1
a4341 1
Perl_ck_ftst(pTHX_ OP *o)
d4346 4
a4349 4
    if (o->op_flags & OPf_REF) {
	/* nothing */
    }
    else if (o->op_flags & OPf_KIDS && cUNOPo->op_first->op_type != OP_STUB) {
d4357 1
a4357 1
	    o = newop;
d4363 1
a4363 1
           o =  newGVOP(type, OPf_REF, gv_fetchpv("main::STDIN", TRUE,
d4366 1
a4366 7
	    o = newUNOP(type, 0, newDEFSVOP());
    }
#ifdef USE_LOCALE
    if (type == OP_FTTEXT || type == OP_FTBINARY) {
	o->op_private = 0;
	if (PL_hints & HINT_LOCALE)
	    o->op_private |= OPpLOCALE;
a4367 1
#endif
d4372 1
a4372 1
Perl_ck_fun(pTHX_ OP *o)
d4380 1
a4380 1
    register I32 oa = PL_opargs[type] >> OASHIFT;
d4394 1
a4394 1
	    (kid->op_type == OP_NULL && kid->op_targ == OP_PUSHMARK))
d4399 1
a4399 1
	if (!kid && PL_opargs[type] & OA_DEFGV)
a4406 6
		/* list seen where single (scalar) arg expected? */
		if (numargs == 1 && !(oa >> 4)
		    && kid->op_type == OP_LIST && type != OP_SCALAR)
		{
		    return too_many_arguments(o,PL_op_desc[type]);
		}
d4419 1
a4419 2
		    (kid->op_private & OPpCONST_BARE))
		{
d4423 3
a4425 4
		    if (ckWARN(WARN_DEPRECATED))
			Perl_warner(aTHX_ WARN_DEPRECATED,
			    "Array @@%s missing the @@ in argument %"IVdf" of %s()",
			    name, (IV)numargs, PL_op_desc[type]);
d4432 1
a4432 1
		    bad_type(numargs, "array", PL_op_desc[type], kid);
d4437 1
a4437 2
		    (kid->op_private & OPpCONST_BARE))
		{
d4441 3
a4443 4
		    if (ckWARN(WARN_DEPRECATED))
			Perl_warner(aTHX_ WARN_DEPRECATED,
			    "Hash %%%s missing the %% in argument %"IVdf" of %s()",
			    name, (IV)numargs, PL_op_desc[type]);
d4450 1
a4450 1
		    bad_type(numargs, "hash", PL_op_desc[type], kid);
d4467 1
a4467 2
			(kid->op_private & OPpCONST_BARE))
		    {
d4476 1
a4476 1
			bad_type(numargs, "HANDLE", PL_op_desc[o->op_type], kid);
a4478 45
			I32 flags = OPf_SPECIAL;
			I32 priv = 0;
			PADOFFSET targ = 0;

			/* is this op a FH constructor? */
			if (is_handle_constructor(o,numargs)) {
			    char *name = Nullch;
			    STRLEN len;

			    flags = 0;
			    /* Set a flag to tell rv2gv to vivify
			     * need to "prove" flag does not mean something
			     * else already - NI-S 1999/05/07
			     */
			    priv = OPpDEREF;
			    if (kid->op_type == OP_PADSV) {
				SV **namep = av_fetch(PL_comppad_name,
						      kid->op_targ, 4);
				if (namep && *namep)
				    name = SvPV(*namep, len);
			    }
			    else if (kid->op_type == OP_RV2SV
				     && kUNOP->op_first->op_type == OP_GV)
			    {
				GV *gv = cGVOPx_gv(kUNOP->op_first);
				name = GvNAME(gv);
				len = GvNAMELEN(gv);
			    }
			    else if (kid->op_type == OP_AELEM
				     || kid->op_type == OP_HELEM)
			    {
				name = "__ANONIO__";
				len = 10;
				mod(kid,type);
			    }
			    if (name) {
				SV *namesv;
				targ = pad_alloc(OP_RV2GV, SVs_PADTMP);
				namesv = PL_curpad[targ];
				(void)SvUPGRADE(namesv, SVt_PV);
				if (*name != '$')
				    sv_setpvn(namesv, "$", 1);
				sv_catpvn(namesv, name, len);
			    }
			}
d4480 1
a4480 3
			kid = newUNOP(OP_RV2GV, flags, scalar(kid));
			kid->op_targ = targ;
			kid->op_private |= priv;
d4497 1
a4497 1
	    return too_many_arguments(o,PL_op_desc[o->op_type]);
d4500 1
a4500 1
    else if (PL_opargs[type] & OA_DEFGV) {
d4509 1
a4509 1
	    return too_few_arguments(o,PL_op_desc[o->op_type]);
d4515 1
a4515 1
Perl_ck_glob(pTHX_ OP *o)
a4518 1
    o = ck_fun(o);
d4525 4
a4528 11
#if !defined(PERL_EXTERNAL_GLOB)
    /* XXX this can be tightened up and made more failsafe. */
    if (!gv) {
	ENTER;
	Perl_load_module(aTHX_ 0, newSVpvn("File::Glob", 10), Nullsv,
			 /* null-terminated import list */
			 newSVpvn(":globally", 9), Nullsv);
	gv = gv_fetchpv("CORE::GLOBAL::glob", FALSE, SVt_PVCV);
	LEAVE;
    }
#endif /* PERL_EXTERNAL_GLOB */
a4529 1
    if (gv && GvIMPORTED_CV(gv)) {
d4531 1
a4531 1
		    newSVOP(OP_CONST, 0, newSViv(PL_glob_index++)));
d4533 1
a4533 1
	o->op_ppaddr = PL_ppaddr[OP_LIST];
d4535 1
a4535 1
	cLISTOPo->op_first->op_ppaddr = PL_ppaddr[OP_PUSHMARK];
d4548 1
a4548 1
    return o;
d4552 1
a4552 1
Perl_ck_grep(pTHX_ OP *o)
d4558 2
a4559 2
    o->op_ppaddr = PL_ppaddr[OP_GREPSTART];
    NewOp(1101, gwop, 1, LOGOP);
d4581 1
a4581 1
	Perl_croak(aTHX_ "panic: ck_grep");
d4585 1
a4585 1
    gwop->op_ppaddr = PL_ppaddr[type];
d4595 1
a4595 1
	return too_few_arguments(o,PL_op_desc[o->op_type]);
d4603 1
a4603 1
Perl_ck_index(pTHX_ OP *o)
d4616 1
a4616 1
Perl_ck_lengthconst(pTHX_ OP *o)
d4623 1
a4623 1
Perl_ck_lfun(pTHX_ OP *o)
d4630 1
a4630 32
Perl_ck_defined(pTHX_ OP *o)		/* 19990527 MJD */
{
    dTHR;
    if ((o->op_flags & OPf_KIDS) && ckWARN(WARN_DEPRECATED)) {
	switch (cUNOPo->op_first->op_type) {
	case OP_RV2AV:
	    break;                      /* Globals via GV can be undef */ 
	case OP_PADAV:
	case OP_AASSIGN:		/* Is this a good idea? */
	    Perl_warner(aTHX_ WARN_DEPRECATED,
			"defined(@@array) is deprecated");
	    Perl_warner(aTHX_ WARN_DEPRECATED,
			"\t(Maybe you should just omit the defined()?)\n");
	break;
	case OP_RV2HV:
	    break;                      /* Globals via GV can be undef */ 
	case OP_PADHV:
	    Perl_warner(aTHX_ WARN_DEPRECATED,
			"defined(%%hash) is deprecated");
	    Perl_warner(aTHX_ WARN_DEPRECATED,
			"\t(Maybe you should just omit the defined()?)\n");
	    break;
	default:
	    /* no warning */
	    break;
	}
    }
    return ck_rfun(o);
}

OP *
Perl_ck_rfun(pTHX_ OP *o)
d4637 1
a4637 1
Perl_ck_listiob(pTHX_ OP *o)
d4675 1
a4675 1
Perl_ck_fun_locale(pTHX_ OP *o)
d4689 1
a4689 31
Perl_ck_sassign(pTHX_ OP *o)
{
    OP *kid = cLISTOPo->op_first;
    /* has a disposable target? */
    if ((PL_opargs[kid->op_type] & OA_TARGLEX)
	&& !(kid->op_flags & OPf_STACKED)
	/* Cannot steal the second time! */
	&& !(kid->op_private & OPpTARGET_MY))
    {
	OP *kkid = kid->op_sibling;

	/* Can just relocate the target. */
	if (kkid && kkid->op_type == OP_PADSV
	    && !(kkid->op_private & OPpLVAL_INTRO))
	{
	    kid->op_targ = kkid->op_targ;
	    kkid->op_targ = 0;
	    /* Now we do not need PADSV and SASSIGN. */
	    kid->op_sibling = o->op_sibling;	/* NULL */
	    cLISTOPo->op_first = NULL;
	    op_free(o);
	    op_free(kkid);
	    kid->op_private |= OPpTARGET_MY;	/* Used for context settings */
	    return kid;
	}
    }
    return o;
}

OP *
Perl_ck_scmp(pTHX_ OP *o)
d4701 1
a4701 1
Perl_ck_match(pTHX_ OP *o)
d4708 1
a4708 21
Perl_ck_method(pTHX_ OP *o)
{
    OP *kid = cUNOPo->op_first;
    if (kid->op_type == OP_CONST) {
	SV* sv = kSVOP->op_sv;
	if (!(strchr(SvPVX(sv), ':') || strchr(SvPVX(sv), '\''))) {
	    OP *cmop;
	    (void)SvUPGRADE(sv, SVt_PVIV);
	    (void)SvIOK_on(sv);
	    PERL_HASH(SvUVX(sv), SvPVX(sv), SvCUR(sv));
	    cmop = newSVOP(OP_METHOD_NAMED, 0, sv);
	    kSVOP->op_sv = Nullsv;
	    op_free(o);
	    return cmop;
	}
    }
    return o;
}

OP *
Perl_ck_null(pTHX_ OP *o)
d4714 1
a4714 31
Perl_ck_open(pTHX_ OP *o)
{
    HV *table = GvHV(PL_hintgv);
    if (table) {
	SV **svp;
	I32 mode;
	svp = hv_fetch(table, "open_IN", 7, FALSE);
	if (svp && *svp) {
	    mode = mode_from_discipline(*svp);
	    if (mode & O_BINARY)
		o->op_private |= OPpOPEN_IN_RAW;
	    else if (mode & O_TEXT)
		o->op_private |= OPpOPEN_IN_CRLF;
	}

	svp = hv_fetch(table, "open_OUT", 8, FALSE);
	if (svp && *svp) {
	    mode = mode_from_discipline(*svp);
	    if (mode & O_BINARY)
		o->op_private |= OPpOPEN_OUT_RAW;
	    else if (mode & O_TEXT)
		o->op_private |= OPpOPEN_OUT_CRLF;
	}
    }
    if (o->op_type == OP_BACKTICK)
	return o;
    return ck_fun(o);
}

OP *
Perl_ck_repeat(pTHX_ OP *o)
d4726 1
a4726 1
Perl_ck_require(pTHX_ OP *o)
d4740 1
a4740 7
	    if (SvREADONLY(kid->op_sv)) {
		SvREADONLY_off(kid->op_sv);
		sv_catpvn(kid->op_sv, ".pm", 3);
		SvREADONLY_on(kid->op_sv);
	    }
	    else
		sv_catpvn(kid->op_sv, ".pm", 3);
a4745 1
#if 0
d4747 1
a4747 1
Perl_ck_retarget(pTHX_ OP *o)
d4749 1
a4749 1
    Perl_croak(aTHX_ "NOT IMPL LINE %d",__LINE__);
a4752 1
#endif
d4755 1
a4755 1
Perl_ck_select(pTHX_ OP *o)
d4762 1
a4762 1
	    o->op_ppaddr = PL_ppaddr[OP_SSELECT];
d4775 1
a4775 1
Perl_ck_shift(pTHX_ OP *o)
d4804 1
a4804 1
Perl_ck_sort(pTHX_ OP *o)
d4812 1
a4812 3
    if (o->op_type == OP_SORT && o->op_flags & OPf_STACKED)
	simplify_sort(o);
    if (o->op_flags & OPf_STACKED) {		     /* may have been cleared */
d4815 6
a4820 1
	kid = kUNOP->op_first;				/* get past null */
a4835 6
			/* don't descend into loops */
			else if (k->op_type == OP_ENTERLOOP
				 || k->op_type == OP_ENTERITER)
			{
			    k = cLOOPx(k)->op_lastop;
			}
d4845 1
d4854 1
a4854 1
    }
a4858 66
STATIC void
S_simplify_sort(pTHX_ OP *o)
{
    dTHR;
    register OP *kid = cLISTOPo->op_first->op_sibling;	/* get past pushmark */
    OP *k;
    int reversed;
    GV *gv;
    if (!(o->op_flags & OPf_STACKED))
	return;
    GvMULTI_on(gv_fetchpv("a", TRUE, SVt_PV)); 
    GvMULTI_on(gv_fetchpv("b", TRUE, SVt_PV)); 
    kid = kUNOP->op_first;				/* get past null */
    if (kid->op_type != OP_SCOPE)
	return;
    kid = kLISTOP->op_last;				/* get past scope */
    switch(kid->op_type) {
	case OP_NCMP:
	case OP_I_NCMP:
	case OP_SCMP:
	    break;
	default:
	    return;
    }
    k = kid;						/* remember this node*/
    if (kBINOP->op_first->op_type != OP_RV2SV)
	return;
    kid = kBINOP->op_first;				/* get past cmp */
    if (kUNOP->op_first->op_type != OP_GV)
	return;
    kid = kUNOP->op_first;				/* get past rv2sv */
    gv = kGVOP_gv;
    if (GvSTASH(gv) != PL_curstash)
	return;
    if (strEQ(GvNAME(gv), "a"))
	reversed = 0;
    else if (strEQ(GvNAME(gv), "b"))
	reversed = 1;
    else
	return;
    kid = k;						/* back to cmp */
    if (kBINOP->op_last->op_type != OP_RV2SV)
	return;
    kid = kBINOP->op_last;				/* down to 2nd arg */
    if (kUNOP->op_first->op_type != OP_GV)
	return;
    kid = kUNOP->op_first;				/* get past rv2sv */
    gv = kGVOP_gv;
    if (GvSTASH(gv) != PL_curstash
	|| ( reversed
	    ? strNE(GvNAME(gv), "a")
	    : strNE(GvNAME(gv), "b")))
	return;
    o->op_flags &= ~(OPf_STACKED | OPf_SPECIAL);
    if (reversed)
	o->op_private |= OPpSORT_REVERSE;
    if (k->op_type == OP_NCMP)
	o->op_private |= OPpSORT_NUMERIC;
    if (k->op_type == OP_I_NCMP)
	o->op_private |= OPpSORT_NUMERIC | OPpSORT_INTEGER;
    kid = cLISTOPo->op_first->op_sibling;
    cLISTOPo->op_first->op_sibling = kid->op_sibling; /* bypass old block */
    op_free(kid);				      /* then delete it */
    cLISTOPo->op_children--;
}

d4860 1
a4860 1
Perl_ck_split(pTHX_ OP *o)
d4869 1
a4869 1
	Perl_croak(aTHX_ "panic: ck_split");
d4874 1
a4874 1
	cLISTOPo->op_first = kid = newSVOP(OP_CONST, 0, newSVpvn(" ", 1));
d4889 1
a4889 1
    kid->op_ppaddr = PL_ppaddr[OP_PUSHRE];
d4905 1
a4905 1
	return too_many_arguments(o,PL_op_desc[o->op_type]);
d4911 1
a4911 18
Perl_ck_join(pTHX_ OP *o) 
{
    if (ckWARN(WARN_SYNTAX)) {
	OP *kid = cLISTOPo->op_first->op_sibling;
	if (kid && kid->op_type == OP_MATCH) {
	    char *pmstr = "STRING";
	    if (kPMOP->op_pmregexp)
		pmstr = kPMOP->op_pmregexp->precomp;
	    Perl_warner(aTHX_ WARN_SYNTAX,
			"/%s/ should probably be written as \"%s\"",
			pmstr, pmstr);
	}
    }
    return ck_fun(o);
}

OP *
Perl_ck_subr(pTHX_ OP *o)
a4924 1
    o->op_private |= OPpENTERSUB_HASTARG;
d4931 4
a4934 7
	if (tmpop->op_type == OP_GV && !(o->op_private & OPpENTERSUB_AMPER)) {
	    GV *gv = cGVOPx_gv(tmpop);
	    cv = GvCVu(gv);
	    if (!cv)
		tmpop->op_private |= OPpEARLY_CV;
	    else if (SvPOK(cv)) {
		namegv = CvANON(cv) ? gv : CvGV(cv);
a4938 9
    else if (cvop->op_type == OP_METHOD || cvop->op_type == OP_METHOD_NAMED) {
	if (o2->op_type == OP_CONST)
	    o2->op_private &= ~OPpCONST_STRICT;
	else if (o2->op_type == OP_LIST) {
	    OP *o = ((UNOP*)o2)->op_first->op_sibling;
	    if (o && o->op_type == OP_CONST)
		o->op_private &= ~OPpCONST_STRICT;
	}
    }
a4972 29
		else if (o2->op_type == OP_CONST)
		    o2->op_private &= ~OPpCONST_STRICT;
		else if (o2->op_type == OP_ENTERSUB) {
		    /* accidental subroutine, revert to bareword */
		    OP *gvop = ((UNOP*)o2)->op_first;
		    if (gvop && gvop->op_type == OP_NULL) {
			gvop = ((UNOP*)gvop)->op_first;
			if (gvop) {
			    for (; gvop->op_sibling; gvop = gvop->op_sibling)
				;
			    if (gvop &&
				(gvop->op_private & OPpENTERSUB_NOPAREN) &&
				(gvop = ((UNOP*)gvop)->op_first) &&
				gvop->op_type == OP_GV)
			    {
				GV *gv = cGVOPx_gv(gvop);
				OP *sibling = o2->op_sibling;
				SV *n = newSVpvn("",0);
				op_free(o2);
				gv_fullname3(n, gv, "");
				if (SvCUR(n)>6 && strnEQ(SvPVX(n),"main::",6))
				    sv_chop(n, SvPVX(n)+6);
				o2 = newSVOP(OP_CONST, 0, n);
				prev->op_sibling = o2;
				o2->op_sibling = sibling;
			    }
			}
		    }
		}
a4989 2
			&& o2->op_type != OP_HELEM
			&& o2->op_type != OP_AELEM
d5020 1
a5020 1
		Perl_croak(aTHX_ "Malformed prototype for %s: %s",
d5037 1
a5037 1
Perl_ck_svconst(pTHX_ OP *o)
d5044 1
a5044 1
Perl_ck_trunc(pTHX_ OP *o)
d5051 2
a5052 3
	if (kid && kid->op_type == OP_CONST &&
	    (kid->op_private & OPpCONST_BARE))
	{
a5053 2
	    kid->op_private &= ~OPpCONST_STRICT;
	}
d5061 1
a5061 1
Perl_peep(pTHX_ register OP *o)
a5065 2
    OP *last_composite = Nullop;

d5070 1
a5070 1
    SAVEVPTR(PL_curcop);
a5077 1
	case OP_SETSTATE:
a5081 1
	    last_composite = Nullop;
d5084 1
d5086 7
a5092 30
	    if (cSVOPo->op_private & OPpCONST_STRICT)
		no_bareword_allowed(o);
#ifdef USE_ITHREADS
	    /* Relocate sv to the pad for thread safety.
	     * Despite being a "constant", the SV is written to,
	     * for reference counts, sv_upgrade() etc. */
	    if (cSVOP->op_sv) {
		PADOFFSET ix = pad_alloc(OP_CONST, SVs_PADTMP);
		SvREFCNT_dec(PL_curpad[ix]);
		SvPADTMP_on(cSVOPo->op_sv);
		PL_curpad[ix] = cSVOPo->op_sv;
		cSVOPo->op_sv = Nullsv;
		o->op_targ = ix;
	    }
#endif
	    o->op_seq = PL_op_seqmax++;
	    break;

	case OP_CONCAT:
	    if (o->op_next && o->op_next->op_type == OP_STRINGIFY) {
		if (o->op_next->op_private & OPpTARGET_MY) {
		    if (o->op_flags & OPf_STACKED) /* chained concats */
			goto ignore_optimization;
		    else {
			/* assert(PL_opargs[o->op_type] & OA_TARGLEX); */
			o->op_targ = o->op_next->op_targ;
			o->op_next->op_targ = 0;
			o->op_private |= OPpTARGET_MY;
		    }
		}
a5093 2
	    }
	  ignore_optimization:
d5103 1
a5103 4
	    if (o->op_targ == OP_NEXTSTATE
		|| o->op_targ == OP_DBSTATE
		|| o->op_targ == OP_SETSTATE)
	    {
a5104 1
	    }
d5121 1
a5121 2
		    o->op_private |= o->op_next->op_private & (OPpLVAL_INTRO
							       | OPpOUR_INTRO);
d5124 1
a5124 1
		    o->op_ppaddr = PL_ppaddr[OP_GVSV];
d5139 1
a5139 1
		    GV *gv;
d5146 1
a5146 1
		    o->op_ppaddr = PL_ppaddr[OP_AELEMFAST];
d5148 1
a5148 2
		    gv = cGVOPo_gv;
		    GvAVn(gv);
a5150 12
	    else if ((o->op_private & OPpEARLY_CV) && ckWARN(WARN_PROTOTYPE)) {
		GV *gv = cGVOPo_gv;
		if (SvTYPE(gv) == SVt_PVGV && GvCV(gv) && SvPVX(GvCV(gv))) {
		    /* XXX could check prototype here instead of just carping */
		    SV *sv = sv_newmortal();
		    gv_efullname3(sv, gv, Nullch);
		    Perl_warner(aTHX_ WARN_PROTOTYPE,
				"%s() called too early to check prototype",
				SvPV_nolen(sv));
		}
	    }

a5157 4
	case OP_ANDASSIGN:
	case OP_ORASSIGN:
	case OP_COND_EXPR:
	case OP_RANGE:
d5164 6
d5186 1
a5186 2
	    if (ckWARN(WARN_SYNTAX) && o->op_next 
		&& o->op_next->op_type == OP_NEXTSTATE) {
d5191 1
a5191 1
		    line_t oldline = CopLINE(PL_curcop);
d5193 4
a5196 6
		    CopLINE_set(PL_curcop, CopLINE((COP*)o->op_next));
		    Perl_warner(aTHX_ WARN_EXEC,
				"Statement unlikely to be reached");
		    Perl_warner(aTHX_ WARN_EXEC,
				"\t(Maybe you meant system() when you said exec()?)\n");
		    CopLINE_set(PL_curcop, oldline);
d5205 1
a5205 1
	    SV **svp, **indsvp, *sv;
d5210 1
a5210 2
	    o->op_seq = PL_op_seqmax++;
	    if ((o->op_private & (OPpLVAL_INTRO))
d5222 1
a5222 1
	    svp = cSVOPx_svp(((BINOP*)o)->op_last);
d5226 1
a5226 1
		Perl_croak(aTHX_ "No such pseudo-hash field \"%s\" in variable %s of type %s",
d5231 1
a5231 1
		Perl_croak(aTHX_ "Bad index while coercing array into hash");
d5233 1
a5233 1
	    rop->op_ppaddr = PL_ppaddr[OP_RV2AV];
d5235 1
a5235 6
	    o->op_ppaddr = PL_ppaddr[OP_AELEM];
	    sv = newSViv(ind);
	    if (SvREADONLY(*svp))
		SvREADONLY_on(sv);
	    SvFLAGS(sv) |= (SvFLAGS(*svp)
			    & (SVs_PADBUSY|SVs_PADTMP|SVs_PADMY));
d5237 1
a5237 1
	    *svp = sv;
a5239 99
	
	case OP_HSLICE: {
	    UNOP *rop;
	    SV *lexname;
	    GV **fields;
	    SV **svp, **indsvp, *sv;
	    I32 ind;
	    char *key;
	    STRLEN keylen;
	    SVOP *first_key_op, *key_op;

	    o->op_seq = PL_op_seqmax++;
	    if ((o->op_private & (OPpLVAL_INTRO))
		/* I bet there's always a pushmark... */
		|| ((LISTOP*)o)->op_first->op_sibling->op_type != OP_LIST)
		/* hmmm, no optimization if list contains only one key. */
		break;
	    rop = (UNOP*)((LISTOP*)o)->op_last;
	    if (rop->op_type != OP_RV2HV || rop->op_first->op_type != OP_PADSV)
		break;
	    lexname = *av_fetch(PL_comppad_name, rop->op_first->op_targ, TRUE);
	    if (!SvOBJECT(lexname))
		break;
	    fields = (GV**)hv_fetch(SvSTASH(lexname), "FIELDS", 6, FALSE);
	    if (!fields || !GvHV(*fields))
		break;
	    /* Again guessing that the pushmark can be jumped over.... */
	    first_key_op = (SVOP*)((LISTOP*)((LISTOP*)o)->op_first->op_sibling)
		->op_first->op_sibling;
	    /* Check that the key list contains only constants. */
	    for (key_op = first_key_op; key_op;
		 key_op = (SVOP*)key_op->op_sibling)
		if (key_op->op_type != OP_CONST)
		    break;
	    if (key_op)
		break;
	    rop->op_type = OP_RV2AV;
	    rop->op_ppaddr = PL_ppaddr[OP_RV2AV];
	    o->op_type = OP_ASLICE;
	    o->op_ppaddr = PL_ppaddr[OP_ASLICE];
	    for (key_op = first_key_op; key_op;
		 key_op = (SVOP*)key_op->op_sibling) {
		svp = cSVOPx_svp(key_op);
		key = SvPV(*svp, keylen);
		indsvp = hv_fetch(GvHV(*fields), key, keylen, FALSE);
		if (!indsvp) {
		    Perl_croak(aTHX_ "No such pseudo-hash field \"%s\" "
			       "in variable %s of type %s",
			  key, SvPV(lexname, n_a), HvNAME(SvSTASH(lexname)));
		}
		ind = SvIV(*indsvp);
		if (ind < 1)
		    Perl_croak(aTHX_ "Bad index while coercing array into hash");
		sv = newSViv(ind);
		if (SvREADONLY(*svp))
		    SvREADONLY_on(sv);
		SvFLAGS(sv) |= (SvFLAGS(*svp)
				& (SVs_PADBUSY|SVs_PADTMP|SVs_PADMY));
		SvREFCNT_dec(*svp);
		*svp = sv;
	    }
	    break;
	}

	case OP_RV2AV:
	case OP_RV2HV:
	    if (!(o->op_flags & OPf_WANT)
		|| (o->op_flags & OPf_WANT) == OPf_WANT_LIST)
	    {
		last_composite = o;
	    }
	    o->op_seq = PL_op_seqmax++;
	    break;

	case OP_RETURN:
	    if (o->op_next && o->op_next->op_type != OP_LEAVESUBLV) {
		o->op_seq = PL_op_seqmax++;
		break;
	    }
	    /* FALL THROUGH */

	case OP_LEAVESUBLV:
	    if (last_composite) {
		OP *r = last_composite;

		while (r->op_sibling)
		   r = r->op_sibling;
		if (r->op_next == o 
		    || (r->op_next->op_type == OP_LIST
			&& r->op_next->op_next == o))
		{
		    if (last_composite->op_type == OP_RV2AV)
			yyerror("Lvalue subs returning arrays not implemented yet");
		    else
			yyerror("Lvalue subs returning hashes not implemented yet");
			;
		}		
	    }
	    /* FALL THROUGH */
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
a57 1
#define RETURN_UNLIMITED_NUMBER (PERL_INT_MAX / 2)
a104 24
STATIC U8*
S_trlist_upgrade(pTHX_ U8** sp, U8** ep)
{
    U8 *s = *sp;
    U8 *e = *ep;
    U8 *d;

    Newz(801, d, (e - s) * 2, U8);
    *sp = d;

    while (s < e) {
        if (*s < 0x80 || *s == 0xff)
            *d++ = *s++;
	else {
            U8 c = *s++;
            *d++ = ((c >> 6)         | 0xc0);
            *d++ = ((c       & 0x3f) | 0x80);
        }
    }
    *ep = d;
    return *sp;
}
  

d110 1
d116 1
a116 1
	  (PL_hints & HINT_UTF8 && UTF8_IS_START(name[1])) ||
a164 1
		    && (SvIVX(sv) == PAD_MAX || SvIVX(sv) == 0)
d240 1
d324 1
a324 3
			if (ckWARN(WARN_CLOSURE) && !SvFAKE(sv) && !CvUNIQUE(cv)
			    && !(SvFLAGS(sv) & SVpad_OUR))
			{
a326 1
			}
d384 1
d447 1
d467 1
d518 1
d535 1
d563 1
d593 1
d622 1
a782 1
    case OP_METHOD_NAMED:
d842 2
a843 2
    Safefree(CopFILE(cop));		/* XXX share in a pvtable? */
    Safefree(CopSTASHPV(cop));		/* XXX share in a pvtable? */
d906 1
d1002 2
d1005 1
d1122 1
d1163 1
a1181 2
	/* FALL THROUGH */
    case OP_SCALAR:
d1190 5
a1194 2
    if (useless && ckWARN(WARN_VOID))
	Perl_warner(aTHX_ WARN_VOID, "Useless use of %s in void context", useless);
d1295 1
d1326 1
a1343 25
        if (o->op_private & (OPpCONST_BARE) && 
                !(type == OP_GREPSTART || type == OP_ENTERSUB || type == OP_REFGEN)) {
            SV *sv = ((SVOP*)o)->op_sv;
            GV *gv;

            /* Could be a filehandle */
            if (gv = gv_fetchpv(SvPV_nolen(sv), FALSE, SVt_PVIO)) {
                OP* gvio = newUNOP(OP_RV2GV, 0, newGVOP(OP_GV, 0, gv));
                op_free(o);
                o = gvio;
            } else {
                /* OK, it's a sub */
                OP* enter;
                gv = gv_fetchpv(SvPV_nolen(sv), TRUE, SVt_PVCV);

                enter = newUNOP(OP_ENTERSUB,0, 
                        newUNOP(OP_RV2CV, 0, 
                            newGVOP(OP_GV, 0, gv)
                        ));
                enter->op_private |= OPpLVAL_INTRO;
                op_free(o);
                o = enter;
            }
            break;
        }
a1373 1
	    PL_modcount = RETURN_UNLIMITED_NUMBER;
d1508 1
a1508 1
           PL_modcount = RETURN_UNLIMITED_NUMBER;
d1517 1
a1519 4
	if (type == OP_LEAVESUBLV)
	    o->op_private |= OPpMAYBE_LVSUB;
	/* FALL THROUGH */
    case OP_AASSIGN:
d1522 1
d1524 1
a1524 1
       PL_modcount = RETURN_UNLIMITED_NUMBER;
d1543 1
a1543 1
       PL_modcount = RETURN_UNLIMITED_NUMBER;
a1547 2
	if (type == OP_LEAVESUBLV)
	    o->op_private |= OPpMAYBE_LVSUB;
a1574 2
	if (type == OP_LEAVESUBLV)
	    o->op_private |= OPpMAYBE_LVSUB;
a1588 2
	if (type == OP_LEAVESUBLV)
	    o->op_private |= OPpMAYBE_LVSUB;
a1594 1
    case OP_LINESEQ:
a1612 5

    case OP_RETURN:
	if (type != OP_LEAVESUBLV)
	    goto nomod;
	break; /* mod()ing was handled by ck_return() */
d1614 1
a1614 2
    if (type != OP_LEAVESUBLV)
        o->op_flags |= OPf_MOD;
d1623 1
a1623 2
    else if (type != OP_GREPSTART && type != OP_ENTERSUB
             && type != OP_LEAVESUBLV)
a1847 31
void
Perl_apply_attrs_string(pTHX_ char *stashpv, CV *cv,
                        char *attrstr, STRLEN len)
{
    OP *attrs = Nullop;

    if (!len) {
        len = strlen(attrstr);
    }

    while (len) {
        for (; isSPACE(*attrstr) && len; --len, ++attrstr) ;
        if (len) {
            char *sstr = attrstr;
            for (; !isSPACE(*attrstr) && len; --len, ++attrstr) ;
            attrs = append_elem(OP_LIST, attrs,
                                newSVOP(OP_CONST, 0,
                                        newSVpvn(sstr, attrstr-sstr)));
        }
    }

    Perl_load_module(aTHX_ PERL_LOADMOD_IMPORT_OPS,
                     newSVpvn(ATTRSMODULE, sizeof(ATTRSMODULE)-1),
                     Nullsv, prepend_elem(OP_LIST,
				  newSVOP(OP_CONST, 0, newSVpv(stashpv,0)),
				  prepend_elem(OP_LIST,
					       newSVOP(OP_CONST, 0,
						       newRV((SV*)cv)),
                                               attrs)));
}

d1930 1
d1949 1
a1949 2
    if (!(right->op_flags & OPf_STACKED) &&
       (right->op_type == OP_MATCH ||
d1951 1
a1951 1
	right->op_type == OP_TRANS)) {
d1953 1
a1953 3
	if (right->op_type != OP_MATCH &&
            ! (right->op_type == OP_TRANS &&
               right->op_private & OPpTRANS_IDENTICAL))
d2014 1
d2043 1
d2071 1
d2116 1
d2119 1
a2119 1
	    for (s = PL_bufptr; *s && (isALNUM(*s) || UTF8_IS_CONTINUED(*s) || strchr("@@$%, ",*s)); s++) ;
d2154 1
d2272 1
d2320 7
d2354 1
d2375 4
a2378 2
    first->op_flags |= (last->op_flags & OPf_KIDS);

d2408 1
a2408 1
	last->op_flags |= OPf_KIDS;
d2441 1
a2441 2
    if (first || last)
	flags |= OPf_KIDS;
d2461 2
d2559 2
a2560 2
    U8 *t = (U8*)SvPV(tstr, tlen);
    U8 *r = (U8*)SvPV(rstr, rlen);
a2565 1
    I32 grows = 0;
a2567 1
    PL_hints |= HINT_BLOCK_SCOPE;
a2570 6
    
    if (SvUTF8(tstr))
        o->op_private |= OPpTRANS_FROM_UTF;
    
    if (SvUTF8(rstr)) 
        o->op_private |= OPpTRANS_TO_UTF;
d2577 1
a2577 1
	STRLEN ulen;
d2588 1
a2592 2
	U8* tsave = from_utf ? NULL : trlist_upgrade(&t, &tend);
	U8* rsave = to_utf   ? NULL : trlist_upgrade(&r, &rend);
d2595 1
a2595 1
	    U8 tmpbuf[UTF8_MAXLEN+1];
a2596 1
	    I32* cl;
d2604 1
a2604 1
		if (t < tend && *t == 0xff) {
d2612 1
a2612 2
		I32 cur = j < i - 1 ? cp[j+1] - s : tend - s;
		UV  val = utf8_to_uv(s, cur, &ulen, 0);
d2624 2
a2625 2
		if (s < tend && *s == 0xff)
		    val = utf8_to_uv(s+1, cur - 1, &ulen, 0);
a2636 1
	    Safefree(cp);
d2642 7
a2648 3
		if (t == r ||
		    (tlen == rlen && memEQ((char *)t, (char *)r, tlen)))
		{
d2650 1
a2650 1
		}
d2656 1
a2656 1
		tfirst = (I32)utf8_to_uv(t, tend - t, &ulen, 0);
d2659 1
a2659 2
		    t++;
		    tlast = (I32)utf8_to_uv(t, tend - t, &ulen, 0);
d2669 1
a2669 1
		    rfirst = (I32)utf8_to_uv(r, rend - r, &ulen, 0);
d2672 1
a2672 2
			r++;
			rlast = (I32)utf8_to_uv(r, rend - r, &ulen, 0);
d2714 14
a2727 2
		if (!grows)
		    grows = (UNISKIP(tfirst) < UNISKIP(rfirst));
a2742 1
	Safefree(cPVOPo->op_pv);
d2752 1
a2752 1
	if (grows)
a2754 5
	if (tsave)
	    Safefree(tsave);
	if (rsave)
	    Safefree(rsave);

d2775 1
a2775 3
		else {
		    if (i < 128 && r[j] >= 128)
			grows = 1;
a2776 1
		}
d2797 1
a2797 3
	    if (tbl[t[i]] == -1) {
		if (t[i] < 128 && r[j] >= 128)
		    grows = 1;
a2798 1
	    }
a2800 2
    if (grows)
	o->op_private |= OPpTRANS_GROWS;
d2810 1
d2837 1
d2857 1
a2857 1
	if ((PL_hints & HINT_UTF8) || DO_UTF8(pat))
d3028 1
d3057 1
d3225 2
a3226 9
    {
	line_t ocopline = PL_copline;
	int oexpect = PL_expect;

	utilize(!(flags & PERL_LOADMOD_DENY), start_subparse(FALSE, 0),
		veop, modname, imop);
	PL_expect = oexpect;
	PL_copline = ocopline;
    }
d3312 1
a3368 3
#ifdef USE_ITHREADS
			    GV *gv = (GV*)PL_curpad[(PADOFFSET)((PMOP*)curop)->op_pmreplroot];
#else
a3369 1
#endif
d3414 1
a3414 1
                   if (PL_modcount < RETURN_UNLIMITED_NUMBER &&
d3449 1
d3489 1
a3489 1
    CopFILE_set(cop, CopFILE(PL_curcop));	/* XXX share in a pvtable? */
d3491 1
a3491 1
    CopFILEGV_set(cop, CopFILEGV(PL_curcop));
d3538 1
d3650 1
d3704 1
d3751 1
d3807 1
d3848 1
d3851 1
a3851 4
	OP *unstack = newOP(OP_UNSTACK, 0);
	if (!next)
	    next = unstack;
	cont = append_elem(OP_LINESEQ, cont, unstack);
d3874 2
d4000 1
d4027 1
d4049 2
a4050 1
	op_free(CvROOT(cv));
d4055 2
d4058 1
a4058 7
    /* Since closure prototypes have the same lifetime as the containing
     * CV, they don't hold a refcount on the outside CV.  This avoids
     * the refcount loop between the outer CV (which keeps a refcount to
     * the closure prototype in the pad entry for pp_anoncode()) and the
     * closure prototype, and the ensuing memory leak.  --GSAR */
    if (!CvANON(cv) || CvCLONED(cv))
	SvREFCNT_dec(CvOUTSIDE(cv));
a4080 1
    CvFLAGS(cv) = 0;
d4133 1
d4164 1
a4164 1
    CvGV(cv)		= CvGV(proto);
d4166 1
a4166 1
    CvROOT(cv)		= OpREFCNT_inc(CvROOT(proto));
d4276 2
d4367 1
d4430 1
a4430 3
	    if (PL_curstackinfo->si_type == PERLSI_SORT &&
		PL_sortcop == CvSTART(cv)) {
		op_free(block);
a4431 1
	    }
d4488 2
a4489 24
	/* inner references to PL_compcv must be fixed up ... */
	{
	    AV *padlist = CvPADLIST(cv);
	    AV *comppad_name = (AV*)AvARRAY(padlist)[0];
	    AV *comppad = (AV*)AvARRAY(padlist)[1];
	    SV **namepad = AvARRAY(comppad_name);
	    SV **curpad = AvARRAY(comppad);
	    for (ix = AvFILLp(comppad_name); ix > 0; ix--) {
		SV *namesv = namepad[ix];
		if (namesv && namesv != &PL_sv_undef
		    && *SvPVX(namesv) == '&')
		{
		    CV *innercv = (CV*)curpad[ix];
		    if (CvOUTSIDE(innercv) == PL_compcv) {
			CvOUTSIDE(innercv) = cv;
			if (!CvANON(innercv) || CvCLONED(innercv)) {
			    (void)SvREFCNT_inc(cv);
			    SvREFCNT_dec(PL_compcv);
			}
		    }
		}
	    }
	}
	/* ... before we throw it away */
d4500 1
a4500 1
    CvGV(cv) = gv;
d4544 1
a4544 2
	CvROOT(cv) = newUNOP(OP_LEAVESUBLV, 0,
			     mod(scalarseq(block), OP_LEAVESUBLV));
a4591 7
    /* If a potential closure prototype, don't keep a refcount on outer CV.
     * This is okay as the lifetime of the prototype is tied to the
     * lifetime of the outer CV.  Avoids memory leak due to reference
     * loop. --GSAR */
    if (!name)
	SvREFCNT_dec(CvOUTSIDE(cv));

d4639 2
a4640 2
	    av_push(PL_beginav, (SV*)cv);
	    GvCV(gv) = 0;		/* cv has been hijacked */
d4652 2
a4653 2
	    av_store(PL_endav, 0, (SV*)cv);
	    GvCV(gv) = 0;		/* cv has been hijacked */
d4662 2
a4663 2
	    av_store(PL_checkav, 0, (SV*)cv);
	    GvCV(gv) = 0;		/* cv has been hijacked */
d4671 2
a4672 2
	    av_push(PL_initav, (SV*)cv);
	    GvCV(gv) = 0;		/* cv has been hijacked */
d4695 1
d4698 2
a4700 1
    SAVECOPLINE(PL_curcop);
a4701 2

    SAVEHINTS();
d4737 1
d4774 1
a4774 1
    CvGV(cv) = gv;
d4798 2
a4799 2
	    av_push(PL_beginav, (SV*)cv);
	    GvCV(gv) = 0;		/* cv has been hijacked */
d4805 2
a4806 2
	    av_store(PL_endav, 0, (SV*)cv);
	    GvCV(gv) = 0;		/* cv has been hijacked */
d4814 2
a4815 2
	    av_store(PL_checkav, 0, (SV*)cv);
	    GvCV(gv) = 0;		/* cv has been hijacked */
d4822 2
a4823 2
	    av_push(PL_initav, (SV*)cv);
	    GvCV(gv) = 0;		/* cv has been hijacked */
d4836 1
d4861 1
a4861 1
    CvGV(cv) = gv;
d4934 2
d5232 1
a5326 1
	    SvREFCNT_dec(PL_curpad[kPADOP->op_padix]);
a5331 1
	    kid->op_private = 0;
d5341 1
d5379 1
a5618 1
    SvREFCNT_dec((SV*)gv); /* had excess refcnt */
d5704 1
a5707 4
	    /* This is needed for
	       if (defined %stash::)
	       to work.   Do not break Tk.
	       */
a5716 4
	    /* This is needed for
	       if (defined %stash::)
	       to work.   Do not break Tk.
	       */
a5934 11
OP *
Perl_ck_return(pTHX_ OP *o)
{
    OP *kid;
    if (CvLVALUE(PL_compcv)) {
	for (kid = cLISTOPo->op_first->op_sibling; kid; kid = kid->op_sibling)
	    mod(kid, OP_LEAVESUBLV);
    }
    return o;
}

a5996 1
    OP *firstkid;
d6005 2
a6006 2
    firstkid = cLISTOPo->op_first->op_sibling;		/* get past pushmark */
    if (o->op_flags & OPf_STACKED) {			/* may have been cleared */
d6008 1
a6008 1
	OP *kid = cUNOPx(firstkid)->op_first;		/* get past null */
d6038 2
a6039 4
	    kid = firstkid;
	    if (o->op_type == OP_SORT) {
		/* provide scalar context for comparison function/block */
		kid = scalar(kid);
a6040 1
	    }
d6046 1
a6046 3
	    null(firstkid);

	firstkid = firstkid->op_sibling;
a6048 4
    /* provide list context for arguments */
    if (o->op_type == OP_SORT)
	list(firstkid);

d6055 1
d6115 1
d6137 1
a6137 1
    if (kid->op_type != OP_MATCH || kid->op_flags & OPf_STACKED) {
d6189 1
d6254 1
a6254 3
		    bad_type(arg,
			arg == 1 ? "block or sub {}" : "sub {}",
			gv_ename(namegv), o2);
d6302 2
a6303 2
		    if (o2->op_type != OP_ENTERSUB)
			bad_type(arg, "subroutine entry", gv_ename(namegv), o2);
a6380 16
OP *
Perl_ck_substr(pTHX_ OP *o)
{
    o = ck_fun(o);
    if ((o->op_flags & OPf_KIDS) && o->op_private == 4) {
	OP *kid = cLISTOPo->op_first;

	if (kid->op_type == OP_NULL)
	    kid = kid->op_sibling;
	if (kid)
	    kid->op_flags |= OPf_MOD;

    }
    return o;
}

d6386 1
d6389 1
d6408 1
d6420 3
a6422 12
		if (SvPADTMP(cSVOPo->op_sv)) {
		    /* If op_sv is already a PADTMP then it is being used by
		     * another pad, so make a copy. */
		    sv_setsv(PL_curpad[ix],cSVOPo->op_sv);
		    SvREADONLY_on(PL_curpad[ix]);
		    SvREFCNT_dec(cSVOPo->op_sv);
		}
		else {
		    SvREFCNT_dec(PL_curpad[ix]);
		    SvPADTMP_on(cSVOPo->op_sv);
		    PL_curpad[ix] = cSVOPo->op_sv;
		}
d6490 1
a6490 1
		      (OPpLVAL_INTRO|OPpLVAL_DEFER|OPpDEREF|OPpMAYBE_LVSUB)) &&
a6537 1
	case OP_ENTERITER:
a6538 2
	    while (cLOOP->op_redoop->op_type == OP_NULL)
		cLOOP->op_redoop = cLOOP->op_redoop->op_next;
a6539 2
	    while (cLOOP->op_nextop->op_type == OP_NULL)
		cLOOP->op_nextop = cLOOP->op_nextop->op_next;
a6540 2
	    while (cLOOP->op_lastop->op_type == OP_NULL)
		cLOOP->op_lastop = cLOOP->op_lastop->op_next;
a6547 3
	    while (cPMOP->op_pmreplstart && 
		   cPMOP->op_pmreplstart->op_type == OP_NULL)
		cPMOP->op_pmreplstart = cPMOP->op_pmreplstart->op_next;
d6679 36
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2002, Larry Wall
a17 1

d23 1
a23 7
#define CALL_PEEP(o) CALL_FPTR(PL_peepp)(aTHX_ o)

#if defined(PL_OP_SLAB_ALLOC)

#ifndef PERL_SLAB_SIZE
#define PERL_SLAB_SIZE 2048
#endif
d25 9
a33 2
#define NewOp(m,var,c,type) \
	STMT_START { var = (type *) Slab_Alloc(m,c*sizeof(type)); } STMT_END
d35 1
a35 3
#define FreeOp(p) Slab_Free(p)

STATIC void *
d37 4
a40 55
{
    /*
     * To make incrementing use count easy PL_OpSlab is an I32 *
     * To make inserting the link to slab PL_OpPtr is I32 **
     * So compute size in units of sizeof(I32 *) as that is how Pl_OpPtr increments
     * Add an overhead for pointer to slab and round up as a number of pointers
     */
    sz = (sz + 2*sizeof(I32 *) -1)/sizeof(I32 *);
    if ((PL_OpSpace -= sz) < 0) {
        PL_OpPtr = (I32 **) PerlMemShared_malloc(PERL_SLAB_SIZE*sizeof(I32*)); 
    	if (!PL_OpPtr) {
	    return NULL;
	}
	Zero(PL_OpPtr,PERL_SLAB_SIZE,I32 **);
	/* We reserve the 0'th I32 sized chunk as a use count */
	PL_OpSlab = (I32 *) PL_OpPtr;
	/* Reduce size by the use count word, and by the size we need.
	 * Latter is to mimic the '-=' in the if() above
	 */
	PL_OpSpace = PERL_SLAB_SIZE - (sizeof(I32)+sizeof(I32 **)-1)/sizeof(I32 **) - sz;
	/* Allocation pointer starts at the top.
	   Theory: because we build leaves before trunk allocating at end
	   means that at run time access is cache friendly upward
	 */
	PL_OpPtr += PERL_SLAB_SIZE;
    }
    assert( PL_OpSpace >= 0 );
    /* Move the allocation pointer down */
    PL_OpPtr   -= sz;
    assert( PL_OpPtr > (I32 **) PL_OpSlab );
    *PL_OpPtr   = PL_OpSlab;	/* Note which slab it belongs to */
    (*PL_OpSlab)++;		/* Increment use count of slab */
    assert( PL_OpPtr+sz <= ((I32 **) PL_OpSlab + PERL_SLAB_SIZE) );
    assert( *PL_OpSlab > 0 );
    return (void *)(PL_OpPtr + 1);
}

STATIC void
S_Slab_Free(pTHX_ void *op)
{
    I32 **ptr = (I32 **) op;
    I32 *slab = ptr[-1];
    assert( ptr-1 > (I32 **) slab );
    assert( ptr < ( (I32 **) slab + PERL_SLAB_SIZE) );
    assert( *slab > 0 );
    if (--(*slab) == 0) {
     #ifdef NETWARE
      #define PerlMemShared PerlMem
     #endif
	
    PerlMemShared_free(slab);
	if (slab == PL_OpSlab) {
	    PL_OpSpace = 0;
	}
    }
d43 1
a43 1
#else
a44 1
#define FreeOp(p) Safefree(p)
d73 1
a73 1
		 OP_DESC(o)));
d95 1
a95 1
		 (int)n, name, t, OP_DESC(kid)));
d106 24
d140 1
a140 1
	  (USE_UTF8_IN_NAMES && UTF8_IS_START(name[1])) ||
d168 1
a168 1
	for (off = top; (I32)off > PL_comppad_name_floor; off--) {
d176 2
a177 2
		Perl_warner(aTHX_ packWARN(WARN_MISC),
		    "\"%s\" variable %s masks earlier declaration in same %s",
d193 1
a193 1
		    Perl_warner(aTHX_ packWARN(WARN_MISC),
d195 1
a195 1
		    Perl_warner(aTHX_ packWARN(WARN_MISC),
d210 1
a210 1
	SvFLAGS(sv) |= SVpad_TYPED;
d213 1
d250 2
a251 2
    if (SvFLAGS(proto_namesv) & SVpad_TYPED) {	/* A typed lexical */
	SvFLAGS(namesv) |= SVpad_TYPED;
d254 1
d283 2
a284 2
		seq <= (U32)SvIVX(sv) &&
		seq > (U32)I_32(SvNVX(sv)) &&
d338 1
a338 1
					Perl_warner(aTHX_ packWARN(WARN_CLOSURE),
d351 1
a351 1
			    Perl_warner(aTHX_ packWARN(WARN_CLOSURE),
d375 1
d382 1
a382 2
		if (CxREALEVAL(cx)) {
		    PADOFFSET off;
a383 9
		    seq = cxstack[i].blk_oldcop->cop_seq;
		    startcv = cxstack[i].blk_eval.cv;
		    if (startcv && CvOUTSIDE(startcv)) {
			off = pad_findlex(name, newoff, seq, CvOUTSIDE(startcv),
					  i-1, saweval, 0);
			if (off)	/* continue looking if not found here */
			    return off;
		    }
		}
a397 1
		seq = cxstack[i].blk_oldcop->cop_seq;
d400 1
d419 1
a419 1
#ifdef USE_5005THREADS
d430 1
a430 1
#endif /* USE_5005THREADS */
d437 2
a438 2
	     (seq <= (U32)SvIVX(sv) &&
	      seq > (U32)I_32(SvNVX(sv)))) &&
d479 1
a479 1
		Perl_warner(aTHX_ packWARN(WARN_INTERNAL), "%s never introduced", SvPVX(sv));
d518 1
a518 2
	    if (!(SvFLAGS(sv) & (SVs_PADTMP|SVs_PADMY)) &&
		!IS_PADGV(sv) && !IS_PADCONST(sv))
d525 1
a525 1
#ifdef USE_5005THREADS
d535 1
a535 1
#endif /* USE_5005THREADS */
d542 1
a542 1
#ifdef USE_5005THREADS
d551 1
a551 1
#endif /* USE_5005THREADS */
d564 1
a564 1
#ifdef USE_5005THREADS
d571 1
a571 1
#endif /* USE_5005THREADS */
d589 1
a589 1
#ifdef USE_5005THREADS
d596 1
a596 1
#endif /* USE_5005THREADS */
d618 1
a618 1
#ifdef USE_5005THREADS
d625 1
a625 1
#endif /* USE_5005THREADS */
d637 1
a637 1
#ifdef USE_5005THREADS
d669 1
a669 1
	    sv_magic(sv, 0, PERL_MAGIC_sv, name, 1);
d693 1
a693 1
	    sv_magic(sv, 0, PERL_MAGIC_sv, name, 1);
d702 1
a702 1
#endif /* USE_5005THREADS */
d743 1
a743 1
	type = (OPCODE)o->op_targ;
d751 8
a758 1
    FreeOp(o);
d761 2
a762 2
void
Perl_op_clear(pTHX_ OP *o)
a763 1

d767 1
a767 1
#ifdef USE_5005THREADS
d772 1
a772 1
#ifdef USE_5005THREADS
d777 1
a777 1
#endif /* USE_5005THREADS */
d829 1
a829 1
        if (INT2PTR(PADOFFSET, cPMOPo->op_pmreplroot)) {
d831 2
a832 2
		GV *gv = (GV*)PL_curpad[INT2PTR(PADOFFSET, cPMOPo->op_pmreplroot)];
		pad_swipe(INT2PTR(PADOFFSET, cPMOPo->op_pmreplroot));
a844 19
	{
	    HV *pmstash = PmopSTASH(cPMOPo);
	    if (pmstash && SvREFCNT(pmstash)) {
		PMOP *pmop = HvPMROOT(pmstash);
		PMOP *lastpmop = NULL;
		while (pmop) {
		    if (cPMOPo == pmop) {
			if (lastpmop)
			    lastpmop->op_pmnext = pmop->op_pmnext;
			else
			    HvPMROOT(pmstash) = pmop->op_pmnext;
			break;
		    }
		    lastpmop = pmop;
		    pmop = pmop->op_pmnext;
		}
	    }
	    PmopSTASH_free(cPMOPo);
	}
d846 2
a847 16
        /* we use the "SAFE" version of the PM_ macros here
         * since sv_clean_all might release some PMOPs
         * after PL_regex_padav has been cleared
         * and the clearing of PL_regex_padav needs to
         * happen before sv_clean_all
         */
	ReREFCNT_dec(PM_GETRE_SAFE(cPMOPo));
	PM_SETRE_SAFE(cPMOPo, (REGEXP*)NULL);
#ifdef USE_ITHREADS
	if(PL_regex_pad) {        /* We could be in destruction */
            av_push((AV*) PL_regex_pad[0],(SV*) PL_regex_pad[(cPMOPo)->op_pmoffset]);
	    SvREPADTMP_on(PL_regex_pad[(cPMOPo)->op_pmoffset]);
            PM_SETRE(cPMOPo, (cPMOPo)->op_pmoffset);
        }
#endif

d860 1
a860 6
    Safefree(cop->cop_label);   /* FIXME: treaddead ??? */
    CopFILE_free(cop);
    CopSTASH_free(cop);
    if (! specialWARN(cop->cop_warnings))
	SvREFCNT_dec(cop->cop_warnings);
    if (! specialCopIO(cop->cop_io)) {
d862 2
a863 5
#if 0
	STRLEN len;
        char *s = SvPV(cop->cop_io,len);
	Perl_warn(aTHX_ "io='%.*s'",(int) len,s); /* ??? --jhi */
#endif
d865 2
a866 1
	SvREFCNT_dec(cop->cop_io);
d868 2
a869 1
    }
d872 2
a873 2
void
Perl_op_null(pTHX_ OP *o)
d931 1
a931 1
	    Perl_warner(aTHX_ packWARN(WARN_SYNTAX), "Found = in conditional, should be ==");
d954 2
d967 1
a967 1
		deprecate_old("implicit split to @@_");
a1002 3
    case OP_SORT:
	if (ckWARN(WARN_VOID))
	    Perl_warner(aTHX_ packWARN(WARN_VOID), "Useless use of sort in scalar context");
d1036 1
a1036 1

d1121 1
a1121 1
	    useless = OP_DESC(o);
a1139 3
		/* the constants 0 and 1 are permitted as they are
		   conventionally used as dummies in constructs like
		        1 while some_condition_with_side_effects;  */
a1142 6
                  /* perl4's way of mixing documentation and code
                     (before the invention of POD) was based on a
                     trick to mix nroff and perl code. The trick was
                     built upon these three nroff macros being used in
                     void context. The pink camel has the details in
                     the script wrapman near page 319. */
d1150 1
a1150 1
	op_null(o);		/* don't execute or even remember it */
d1202 1
a1202 1
		deprecate_old("implicit split to @@_");
d1207 1
a1207 1
	Perl_warner(aTHX_ packWARN(WARN_VOID), "Useless use of %s in void context", useless);
d1239 1
a1239 1

d1349 1
a1349 1

d1355 25
d1405 1
a1405 1
	    op_null(((LISTOP*)cUNOPo->op_first)->op_first);/* disable pushmark */
a1407 2
	else if (o->op_private & OPpENTERSUB_NOMOD)
	    return o;
d1426 2
a1427 2
			       "args: type/targ %ld:%"UVuf,
			       (long)kid->op_type, (UV)kid->op_targ);
d1439 5
d1453 1
a1453 1

d1457 2
a1458 2
				   "entry via type/targ %ld:%"UVuf,
				   (long)kid->op_type, (UV)kid->op_targ);
d1462 2
a1463 2

		okid = kid;
d1467 1
a1467 1
		if (kid->op_type == OP_NULL)
d1470 2
a1471 2
			       "entry via type/targ %ld:%"UVuf,
			       (long)kid->op_type, (UV)kid->op_targ);
d1487 1
a1487 1

d1489 1
a1489 1
		if (!cv)
d1506 1
a1506 1
			: OP_DESC(o))),
d1534 1
a1534 1

d1597 1
a1597 1
#ifdef USE_5005THREADS
d1601 1
a1601 1
#endif /* USE_5005THREADS */
d1605 1
a1605 1

a1664 8

    /* [20011101.069] File test operators interpret OPf_REF to mean that
       their argument is a filehandle; thus \stat(".") should not set
       it. AMS 20011102 */
    if (type == OP_REFGEN &&
        PL_check[o->op_type] == MEMBER_TO_FPTR(Perl_ck_ftst))
        return o;

d1777 1
a1777 1
	    op_null(((LISTOP*)cUNOPo->op_first)->op_first);	/* disable pushmark */
d1799 1
a1799 1

d1875 1
a1875 1
S_apply_attrs(pTHX_ HV *stash, SV *target, OP *attrs, bool for_my)
d1882 1
a1882 1
    if (stash)
a1887 1
#define ATTRSMODULE_PM "attributes.pm"
d1889 9
a1897 23
    if (for_my) {
	SV **svp;
	/* Don't force the C<use> if we don't need it. */
	svp = hv_fetch(GvHVn(PL_incgv), ATTRSMODULE_PM,
		       sizeof(ATTRSMODULE_PM)-1, 0);
	if (svp && *svp != &PL_sv_undef)
	    ; 		/* already in %INC */
	else
	    Perl_load_module(aTHX_ PERL_LOADMOD_NOIMPORT,
			     newSVpvn(ATTRSMODULE, sizeof(ATTRSMODULE)-1),
			     Nullsv);
    }
    else {
	Perl_load_module(aTHX_ PERL_LOADMOD_IMPORT_OPS,
			 newSVpvn(ATTRSMODULE, sizeof(ATTRSMODULE)-1),
			 Nullsv,
			 prepend_elem(OP_LIST,
				      newSVOP(OP_CONST, 0, stashsv),
				      prepend_elem(OP_LIST,
						   newSVOP(OP_CONST, 0,
							   newRV(target)),
						   dup_attrlist(attrs))));
    }
a1900 65
STATIC void
S_apply_attrs_my(pTHX_ HV *stash, OP *target, OP *attrs, OP **imopsp)
{
    OP *pack, *imop, *arg;
    SV *meth, *stashsv;

    if (!attrs)
	return;

    assert(target->op_type == OP_PADSV ||
	   target->op_type == OP_PADHV ||
	   target->op_type == OP_PADAV);

    /* Ensure that attributes.pm is loaded. */
    apply_attrs(stash, pad_sv(target->op_targ), attrs, TRUE);

    /* Need package name for method call. */
    pack = newSVOP(OP_CONST, 0, newSVpvn(ATTRSMODULE, sizeof(ATTRSMODULE)-1));

    /* Build up the real arg-list. */
    if (stash)
	stashsv = newSVpv(HvNAME(stash), 0);
    else
	stashsv = &PL_sv_no;
    arg = newOP(OP_PADSV, 0);
    arg->op_targ = target->op_targ;
    arg = prepend_elem(OP_LIST,
		       newSVOP(OP_CONST, 0, stashsv),
		       prepend_elem(OP_LIST,
				    newUNOP(OP_REFGEN, 0,
					    mod(arg, OP_REFGEN)),
				    dup_attrlist(attrs)));

    /* Fake up a method call to import */
    meth = newSVpvn("import", 6);
    (void)SvUPGRADE(meth, SVt_PVIV);
    (void)SvIOK_on(meth);
    PERL_HASH(SvUVX(meth), SvPVX(meth), SvCUR(meth));
    imop = convert(OP_ENTERSUB, OPf_STACKED|OPf_SPECIAL|OPf_WANT_VOID,
		   append_elem(OP_LIST,
			       prepend_elem(OP_LIST, pack, list(arg)),
			       newSVOP(OP_METHOD_NAMED, 0, meth)));
    imop->op_private |= OPpENTERSUB_NOMOD;

    /* Combine the ops. */
    *imopsp = append_elem(OP_LIST, *imopsp, imop);
}

/*
=notfor apidoc apply_attrs_string

Attempts to apply a list of attributes specified by the C<attrstr> and
C<len> arguments to the subroutine identified by the C<cv> argument which
is expected to be associated with the package identified by the C<stashpv>
argument (see L<attributes>).  It gets this wrong, though, in that it
does not correctly identify the boundaries of the individual attribute
specifications within C<attrstr>.  This is not really intended for the
public API, but has to be listed here for systems such as AIX which
need an explicit export list for symbols.  (It's called from XS code
in support of the C<ATTRS:> keyword from F<xsubpp>.)  Patches to fix it
to respect attribute syntax properly would be welcome.

=cut
*/

d1933 1
a1933 1
S_my_kid(pTHX_ OP *o, OP *attrs, OP **imopsp)
d1944 1
a1944 1
	    my_kid(kid, attrs, imopsp);
a1949 13
      if (cUNOPo->op_first->op_type != OP_GV) { /* MJD 20011224 */
           yyerror(Perl_form(aTHX_ "Can't declare %s in my", OP_DESC(o)));
        }
        if (attrs) {
            GV *gv = cGVOPx_gv(cUNOPo->op_first);
            PL_in_my = FALSE;
            PL_in_my_stash = Nullhv;
            apply_attrs(GvSTASH(gv),
                        (type == OP_RV2SV ? GvSV(gv) :
                         type == OP_RV2AV ? (SV*)GvAV(gv) :
                         type == OP_RV2HV ? (SV*)GvHV(gv) : (SV*)gv),
                        attrs, FALSE);
        }
d1952 1
a1952 2
    }
    else if (type != OP_PADSV &&
d1958 1
a1958 1
			  OP_DESC(o),
d1964 1
d1972 1
a1972 1
	if (namesvp && *namesvp && (SvFLAGS(*namesvp) & SVpad_TYPED))
d1976 2
a1977 1
	apply_attrs_my(stash, o, attrs, imopsp);
a1986 3
    OP *rops = Nullop;
    int maybe_scalar = 0;

a1988 2
    else
	maybe_scalar = 1;
d1991 1
a1991 9
    o = my_kid(o, attrs, &rops);
    if (rops) {
	if (maybe_scalar && o->op_type == OP_PADSV) {
	    o = scalar(append_list(OP_LIST, (LISTOP*)rops, (LISTOP*)o));
	    o->op_private |= OPpLVAL_INTRO;
	}
	else
	    o = append_list(OP_LIST, (LISTOP*)o, (LISTOP*)rops);
    }
d2000 1
a2000 1
    return my_attrs(o, Nullop);
d2027 2
a2028 2
      Perl_warner(aTHX_ packWARN(WARN_MISC),
             "Applying %s to %s will act on scalar(%s)",
a2031 7
    if (right->op_type == OP_CONST &&
	cSVOPx(right)->op_private & OPpCONST_BARE &&
	cSVOPx(right)->op_private & OPpCONST_STRICT)
    {
	no_bareword_allowed(right);
    }

d2079 1
a2079 1
		    op_null(kid);
d2117 1
a2117 1
    SAVESPTR(PL_compiling.cop_warnings);
a2121 5
    SAVESPTR(PL_compiling.cop_io);
    if (! specialCopIO(PL_compiling.cop_io)) {
        PL_compiling.cop_io = newSVsv(PL_compiling.cop_io) ;
        SAVEFREESV(PL_compiling.cop_io) ;
    }
d2129 1
a2129 4
    line_t copline = PL_copline;
    /* there should be a nextstate in every block */
    OP* retval = seq ? scalarseq(seq) : newSTATEOP(0, Nullch, seq);
    PL_copline = copline;  /* XXX newSTATEOP may reset PL_copline */
d2132 1
a2132 1
    PL_compiling.op_private = (U8)(PL_hints & HINT_PRIVATE_MASK);
d2143 1
a2143 1
#ifdef USE_5005THREADS
d2149 1
a2149 1
#endif /* USE_5005THREADS */
d2165 1
a2165 1
	CALL_PEEP(PL_eval_start);
d2176 1
a2176 1
	CALL_PEEP(PL_main_start);
d2199 3
a2201 8
	if (ckWARN(WARN_PARENTHESIS)
	    && PL_bufptr > PL_oldbufptr && PL_bufptr[-1] == ',')
	{
	    char *s = PL_bufptr;

	    while (*s && (isALNUM(*s) || UTF8_IS_CONTINUED(*s) || strchr("@@$%, ", *s)))
		s++;

d2203 1
a2203 1
		Perl_warner(aTHX_ packWARN(WARN_PARENTHESIS),
d2222 1
a2222 1
#ifdef USE_5005THREADS
d2227 1
a2227 1
#endif /* USE_5005THREADS */
d2272 2
a2273 2
	/* XXX what about the numeric ops? */
	if (PL_hints & HINT_LOCALE)
d2311 7
a2317 5
#ifdef PERL_PRESERVE_IVUV
	    /* Only bother to attempt to fold to IV if
	       most operators will benefit  */
	    SvIV_please(sv);
#endif
d2323 24
d2362 1
a2362 1
    CALL_PEEP(curop);
a2370 1
    o->op_seq = 0;		/* needs to be revisited in peep() */
d2381 3
d2390 1
a2390 1
	op_null(cLISTOPo->op_first);
d2392 1
a2392 1
    o->op_type = (OPCODE)type;
d2449 4
a2452 2
    FreeOp(last);

a2468 2
            if (!(first->op_flags & OPf_PARENS))
                last->op_flags &= ~OPf_PARENS;
d2498 1
a2498 1
    op_null(o);
d2509 1
a2509 1
    listop->op_type = (OPCODE)type;
d2513 1
a2513 1
    listop->op_flags = (U8)flags;
d2541 1
a2541 1
    o->op_type = (OPCODE)type;
d2543 1
a2543 1
    o->op_flags = (U8)flags;
d2546 1
a2546 1
    o->op_private = (U8)(0 | (flags >> 8));
d2565 1
a2565 1
    unop->op_type = (OPCODE)type;
d2569 1
a2569 1
    unop->op_private = (U8)(1 | (flags >> 8));
d2586 1
a2586 1
    binop->op_type = (OPCODE)type;
d2592 1
a2592 1
	binop->op_private = (U8)(1 | (flags >> 8));
d2595 1
a2595 1
	binop->op_private = (U8)(2 | (flags >> 8));
d2600 1
a2600 1
    if (binop->op_next || binop->op_type != (OPCODE)type)
d2609 1
a2609 1
uvcompare(const void *a, const void *b)
d2611 7
a2617 8
    if (*((UV *)a) < (*(UV *)b))
	return -1;
    if (*((UV *)a) > (*(UV *)b))
	return 1;
    if (*((UV *)a+1) < (*(UV *)b+1))
	return -1;
    if (*((UV *)a+1) > (*(UV *)b+1))
	return 1;
d2642 1
a2642 1

d2645 2
a2646 2

    if (SvUTF8(rstr))
d2666 1
a2666 1
	U32 final = 0;
d2669 2
a2670 19
	U8* tsave = NULL;
	U8* rsave = NULL;

	if (!from_utf) {
	    STRLEN len = tlen;
	    tsave = t = bytes_to_utf8(t, &len);
	    tend = t + len;
	}
	if (!to_utf && rlen) {
	    STRLEN len = rlen;
	    rsave = r = bytes_to_utf8(r, &len);
	    rend = r + len;
	}

/* There are several snags with this code on EBCDIC:
   1. 0xFF is a legal UTF-EBCDIC byte (there are no illegal bytes).
   2. scan_const() in toke.c has encoded chars in native encoding which makes
      ranges at least in EBCDIC 0..255 range the bottom odd.
*/
d2674 2
a2675 1
	    UV *cp;
d2677 1
a2677 1
	    New(1109, cp, 2*tlen, UV);
d2681 3
a2683 3
		cp[2*i] = utf8n_to_uvuni(t, tend-t, &ulen, 0);
		t += ulen;
		if (t < tend && NATIVE_TO_UTF(*t) == 0xff) {
d2685 1
a2685 2
		    cp[2*i+1] = utf8n_to_uvuni(t, tend-t, &ulen, 0);
		    t += ulen;
a2686 4
		else {
		 cp[2*i+1] = cp[2*i];
		}
		i++;
d2688 1
a2688 1
	    qsort(cp, i, 2*sizeof(UV), uvcompare);
d2690 4
a2693 1
		UV  val = cp[2*j];
d2696 1
a2696 1
		    t = uvuni_to_utf8(tmpbuf,nextmin);
d2699 2
a2700 3
			U8  range_mark = UTF_TO_NATIVE(0xff);
			t = uvuni_to_utf8(tmpbuf, val - 1);
			sv_catpvn(transv, (char *)&range_mark, 1);
d2704 2
a2705 1
		val = cp[2*j+1];
d2709 1
a2709 1
	    t = uvuni_to_utf8(tmpbuf,nextmin);
d2711 2
a2712 6
	    {
		U8 range_mark = UTF_TO_NATIVE(0xff);
		sv_catpvn(transv, (char *)&range_mark, 1);
	    }
	    t = uvuni_to_utf8_flags(tmpbuf, 0x7fffffff,
				    UNICODE_ALLOW_SUPER);
d2723 1
a2723 1
		if ((!rlen && !del) || t == r ||
d2733 1
a2733 1
		tfirst = (I32)utf8n_to_uvuni(t, tend - t, &ulen, 0);
d2735 1
a2735 1
		if (t < tend && NATIVE_TO_UTF(*t) == 0xff) {	/* illegal utf8 val indicates range */
d2737 1
a2737 1
		    tlast = (I32)utf8n_to_uvuni(t, tend - t, &ulen, 0);
d2747 1
a2747 1
		    rfirst = (I32)utf8n_to_uvuni(r, rend - r, &ulen, 0);
d2749 1
a2749 1
		    if (r < rend && NATIVE_TO_UTF(*r) == 0xff) {	/* illegal utf8 val indicates range */
d2751 1
a2751 1
			rlast = (I32)utf8n_to_uvuni(r, rend - r, &ulen, 0);
d2792 1
d2794 1
a2794 3
		    grows = (tfirst < rfirst &&
			     UNISKIP(tfirst) < UNISKIP(rfirst + diff));
		rfirst += diff + 1;
d2816 1
a2816 1
	if (!del && havefinal && rlen)
d2836 1
a2836 1
	for (i = 0; i < (I32)tlen; i++)
d2840 1
a2840 1
		if (j >= (I32)rlen) {
d2846 1
a2846 1
			tbl[i] = (short)i;
a2854 14
	if (!del) {
	    if (!rlen) {
		j = rlen;
		if (!squash)
		    o->op_private |= OPpTRANS_IDENTICAL;
	    }
	    else if (j >= (I32)rlen)
		j = rlen - 1;
	    else
		cPVOPo->op_pv = (char*)Renew(tbl, 0x101+rlen-j, short);
	    tbl[0x100] = rlen - j;
	    for (i=0; i < (I32)rlen - j; i++)
		tbl[0x101+i] = r[j+i];
	}
a2861 3
	else if (!squash && rlen == tlen && memEQ((char*)t, (char*)r, tlen)) {
	    o->op_private |= OPpTRANS_IDENTICAL;
	}
d2864 2
a2865 2
	for (i = 0, j = 0; i < (I32)tlen; i++,j++) {
	    if (j >= (I32)rlen) {
d2894 1
a2894 1
    pmop->op_type = (OPCODE)type;
d2896 2
a2897 2
    pmop->op_flags = (U8)flags;
    pmop->op_private = (U8)(0 | (flags >> 8));
d2905 1
a2905 18
#ifdef USE_ITHREADS
    {
        SV* repointer;
        if(av_len((AV*) PL_regex_pad[0]) > -1) {
	    repointer = av_pop((AV*)PL_regex_pad[0]);
            pmop->op_pmoffset = SvIV(repointer);
	    SvREPADTMP_off(repointer);
	    sv_setiv(repointer,0);
        } else {
            repointer = newSViv(0);
            av_push(PL_regex_padav,SvREFCNT_inc(repointer));
            pmop->op_pmoffset = av_len(PL_regex_padav);
            PL_regex_pad = AvARRAY(PL_regex_padav);
        }
    }
#endif

        /* link into pm list */
a2908 1
	PmopSTASH_set(pmop,PL_curstash);
d2936 1
a2936 1
        if (DO_UTF8(pat))
d2938 2
a2939 2
	PM_SETRE(pm, CALLREGCOMP(aTHX_ p, p + plen, pm));
	if (strEQ("\\s+", PM_GETRE(pm)->precomp))
d2944 2
d2947 1
a2947 1
	    expr = newUNOP((!(PL_hints & HINT_RE_EVAL)
d2955 1
a2955 1
	rcop->op_flags |= ((PL_hints & HINT_RE_EVAL)
d2980 1
a2980 1
		CopLINE_set(PL_curcop, (line_t)PL_multi_end);
d2982 1
a2982 1
#ifdef USE_5005THREADS
d2989 1
a2989 1
#endif /* USE_5005THREADS */
d2996 1
a2996 1
#ifdef USE_5005THREADS
d3009 1
a3009 1
#endif /* USE_5005THREADS */
d3034 3
a3036 3
	    && !(repl_has_vars
		 && (!PM_GETRE(pm)
		     || PM_GETRE(pm)->reganch & ROPT_EVAL_SEEN))) {
d3042 1
a3042 1
	    if (curop == repl && !PM_GETRE(pm)) { /* Has variables. */
d3072 1
a3072 1
    svop->op_type = (OPCODE)type;
d3076 1
a3076 1
    svop->op_flags = (U8)flags;
d3089 1
a3089 1
    padop->op_type = (OPCODE)type;
d3096 1
a3096 1
    padop->op_flags = (U8)flags;
d3120 1
a3120 1
    pvop->op_type = (OPCODE)type;
d3124 1
a3124 1
    pvop->op_flags = (U8)flags;
a3148 1
	deprecate("\"package\" with no arguments");
d3161 1
d3164 1
d3212 2
a3213 2
	meth = aver ? newSVpvn("import",6) : newSVpvn("unimport", 8);
	(void)SvUPGRADE(meth, SVt_PVIV);
d3222 16
d3245 1
a3245 1
	        newSTATEOP(0, Nullch, newUNOP(OP_REQUIRE, 0, id)),
a3248 17
    /* The "did you use incorrect case?" warning used to be here.
     * The problem is that on case-insensitive filesystems one
     * might get false positives for "use" (and "require"):
     * "use Strict" or "require CARP" will work.  This causes
     * portability problems for the script: in case-strict
     * filesystems the script will stop working.
     *
     * The "incorrect case" warning checked whether "use Foo"
     * imported "Foo" to your namespace, but that is wrong, too:
     * there is no requirement nor promise in the language that
     * a Foo.pm should or would contain anything in package "Foo".
     *
     * There is very little Configure-wise that can be done, either:
     * the case-sensitivity of the build filesystem of Perl does not
     * help in guessing the case-sensitivity of the runtime environment.
     */

a3253 16
/*
=head1 Embedding Functions

=for apidoc load_module

Loads the module whose name is pointed to by the string part of name.
Note that the actual module name, not its filename, should be given.
Eg, "Foo::Bar" instead of "Foo/Bar.pm".  flags can be any of
PERL_LOADMOD_DENY, PERL_LOADMOD_NOIMPORT, or PERL_LOADMOD_IMPORT_OPS
(or 0 for no flags). ver, if specified, provides version semantics
similar to C<use Foo::Bar VERSION>.  The optional trailing SV*
arguments can be used to specify arguments to the module's import()
method, similar to C<use Foo::Bar VERSION LIST>.

=cut */

d3320 1
a3320 1
    if (!(gv && GvCVu(gv) && GvIMPORTED_CV(gv)))
d3323 1
a3323 1
    if (gv && GvCVu(gv) && GvIMPORTED_CV(gv)) {
a3363 5
    if (o->op_type == OP_LIST &&
	(o->op_flags & OPf_WANT) == OPf_WANT_SCALAR &&
	o->op_private & OPpLVAL_INTRO)
	return FALSE;

d3410 1
a3410 1
	o->op_private = (U8)(0 | (flags >> 8));
d3427 1
a3427 1
			if (gv == PL_defgv || (int)SvCUR(gv) == PL_generation)
d3437 1
a3437 1
			if ((int)SvCUR(sv) == PL_generation)
d3453 1
a3453 1
			    GV *gv = (GV*)PL_curpad[INT2PTR(PADOFFSET,((PMOP*)curop)->op_pmreplroot)];
d3457 1
a3457 1
			    if (gv == PL_defgv || (int)SvCUR(gv) == PL_generation)
d3460 1
a3460 1
			}
d3483 1
a3483 1
			pm->op_pmreplroot = INT2PTR(OP*, cPADOPx(tmpop)->op_padix);
d3548 2
a3549 2
    cop->op_flags = (U8)flags;
    cop->op_private = (U8)(PL_hints & HINT_PRIVATE_MASK);
d3564 1
a3564 1
    else
a3565 4
    if (specialCopIO(PL_curcop->cop_io))
        cop->cop_io = PL_curcop->cop_io;
    else
        cop->cop_io = newSVsv(PL_curcop->cop_io) ;
d3583 2
a3584 2
        if (svp && *svp != &PL_sv_undef ) {
           (void)SvIOK_on(*svp);
d3650 1
a3650 1
	    Perl_warner(aTHX_ packWARN(WARN_BAREWORD), "Bareword found in conditional");
d3662 6
d3677 1
a3677 1
		  && ((k1->op_flags & OPf_WANT) == OPf_WANT_SCALAR))
d3690 1
a3690 1
			  ? (OPCODE)k1->op_targ : k1->op_type);
d3697 1
a3697 1
	    Perl_warner(aTHX_ packWARN(WARN_MISC),
d3714 1
a3714 1
    logop->op_type = (OPCODE)type;
d3719 1
a3719 1
    logop->op_private = (U8)(1 | (flags >> 8));
a3745 4
        if (first->op_private & OPpCONST_BARE &&
           first->op_private & OPpCONST_STRICT) {
           no_bareword_allowed(first);
       }
d3757 4
d3766 1
a3766 1
    logop->op_private = (U8)(1 | (flags >> 8));
d3802 1
a3802 1
    range->op_private = (U8)(1 | (flags >> 8));
d3850 1
a3850 1
	      case OP_NULL:
d3853 1
a3853 1
		      && ((k1->op_flags & OPf_WANT) == OPf_WANT_SCALAR))
d3855 1
a3855 1
		break;
d3860 1
a3860 1
		      || (k1->op_type == OP_NULL && k1->op_targ == OP_GLOB)
d3893 1
d3904 1
a3904 1
	  case OP_NULL:
d3907 1
a3907 1
		  && ((k1->op_flags & OPf_WANT) == OPf_WANT_SCALAR))
d3909 1
a3909 1
	    break;
d3936 1
a3936 1
	    PL_copline = (line_t)whileline;
d3946 1
a3946 1
	PL_copline = (line_t)whileline;
d3955 1
a3955 1
	    ((LISTOP*)listop)->op_last->op_next =
d3990 1
a3990 1
    PADOFFSET padoff = 0;
d4015 1
a4015 1
#ifdef USE_5005THREADS
d4051 1
a4051 1
        op_null(expr);
a4066 1
	FreeOp(loop);
d4071 1
a4071 1
#endif
d4107 1
a4107 5
    CV *outsidecv;
    CV *freecv = Nullcv;
    bool is_eval = CvEVAL(cv) && !CvGV(cv);	/* is this eval"" ? */

#ifdef USE_5005THREADS
d4113 1
a4113 9
#endif /* USE_5005THREADS */

#ifdef USE_ITHREADS
    if (CvFILE(cv) && !CvXSUB(cv)) {
	/* for XSUBs CvFILE point directly to static memory; __FILE__ */
	Safefree(CvFILE(cv));
    }
    CvFILE(cv) = 0;
#endif
d4116 1
a4116 1
#ifdef USE_5005THREADS
d4122 1
a4122 1
#endif /* USE_5005THREADS */
a4133 1
    outsidecv = CvOUTSIDE(cv);
d4140 1
a4140 1
        freecv = outsidecv;
a4141 4
    if (CvCONST(cv)) {
	SvREFCNT_dec((SV*)CvXSUBANY(cv).any_ptr);
	CvCONST_off(cv);
    }
d4145 4
a4148 34
	    AV *padlist = CvPADLIST(cv);
	    I32 ix;
	    /* pads may be cleared out already during global destruction */
	    if (is_eval && !PL_dirty) {
		/* inner references to eval's cv must be fixed up */
		AV *comppad_name = (AV*)AvARRAY(padlist)[0];
		AV *comppad = (AV*)AvARRAY(padlist)[1];
		SV **namepad = AvARRAY(comppad_name);
		SV **curpad = AvARRAY(comppad);
		for (ix = AvFILLp(comppad_name); ix > 0; ix--) {
		    SV *namesv = namepad[ix];
		    if (namesv && namesv != &PL_sv_undef
			&& *SvPVX(namesv) == '&'
			&& ix <= AvFILLp(comppad))
		    {
			CV *innercv = (CV*)curpad[ix];
			if (innercv && SvTYPE(innercv) == SVt_PVCV
			    && CvOUTSIDE(innercv) == cv)
			{
			    CvOUTSIDE(innercv) = outsidecv;
			    if (!CvANON(innercv) || CvCLONED(innercv)) {
				(void)SvREFCNT_inc(outsidecv);
				if (SvREFCNT(cv))
				    SvREFCNT_dec(cv);
			    }
			}
		    }
		}
	    }
	    if (freecv)
		SvREFCNT_dec(freecv);
	    ix = AvFILLp(padlist);
	    while (ix >= 0) {
		SV* sv = AvARRAY(padlist)[ix--];
a4162 5
    else if (freecv)
	SvREFCNT_dec(freecv);
    if (CvXSUB(cv)) {
        CvXSUB(cv) = 0;
    }
a4165 1
#ifdef DEBUG_CLOSURES
a4211 1
#endif /* DEBUG_CLOSURES */
d4240 1
a4240 1
#ifdef USE_5005THREADS
d4244 1
a4244 5
#endif /* USE_5005THREADS */
#ifdef USE_ITHREADS
    CvFILE(cv)		= CvXSUB(proto) ? CvFILE(proto)
					: savepv(CvFILE(proto));
#else
a4245 1
#endif
a4341 9

    if (CvCONST(cv)) {
	SV* const_sv = op_const_sv(CvSTART(cv), cv);
	assert(const_sv);
	/* constant sub () { $x } closing over $x - see lib/constant.pm */
	SvREFCNT_dec(cv);
	cv = newCONSTSUB(CvSTASH(proto), 0, const_sv);
    }

d4374 1
a4374 1
	Perl_warner(aTHX_ packWARN(WARN_PROTOTYPE), "%"SVf, msg);
a4377 16
static void const_sv_xsub(pTHX_ CV* cv);

/*

=head1 Optree Manipulation Functions

=for apidoc cv_const_sv

If C<cv> is a constant sub eligible for inlining. returns the constant
value returned by the sub.  Otherwise, returns NULL.

Constant subs can be created with C<newCONSTSUB> or as described in
L<perlsub/"Constant Functions">.

=cut
*/
d4381 1
a4381 1
    if (!cv || !CvCONST(cv))
d4383 1
a4383 1
    return (SV*)CvXSUBANY(cv).any_ptr;
d4393 2
a4394 2

    if (o->op_type == OP_LINESEQ && cLISTOPo->op_first)
d4400 1
a4400 1
	if (sv && o->op_next == o)
d4402 2
a4403 6
	if (o->op_next != o) {
	    if (type == OP_NEXTSTATE || type == OP_NULL || type == OP_PUSHMARK)
		continue;
	    if (type == OP_DBSTATE)
		continue;
	}
d4413 1
a4413 11
	    if (!sv)
		return Nullsv;
	    if (CvCONST(cv)) {
		/* We get here only from cv_clone2() while creating a closure.
		   Copy the const value here instead of in cv_clone2 so that
		   SvREADONLY_on doesn't lead to problems when leaving
		   scope.
		*/
		sv = newSVsv(sv);
	    }
	    if (!SvREADONLY(sv) && SvREFCNT(sv) > 1)
a4453 1
    SV *const_sv;
d4458 1
a4458 2
	Perl_sv_setpvf(aTHX_ sv, "%s[%s:%"IVdf"]",
		       PL_curstash ? "__ANON__" : "__ANON__::__ANON__",
d4464 1
a4464 2
    gv = gv_fetchpv(name ? name : (aname ? aname : 
		    (PL_curstash ? "__ANON__" : "__ANON__::__ANON__")),
d4481 1
a4481 1
		Perl_warner(aTHX_ packWARN(WARN_PROTOTYPE), "Runaway prototype");
d4492 1
a4492 8
	goto done;
    }

    cv = (!name || GvCVGEN(gv)) ? Nullcv : GvCV(gv);

#ifdef GV_UNIQUE_CHECK
    if (cv && GvUNIQUE(gv) && SvREADONLY(cv)) {
        Perl_croak(aTHX_ "Can't define subroutine %s (GV is unique)", name);
a4493 1
#endif
d4495 4
a4498 20
    if (!block || !ps || *ps || attrs)
	const_sv = Nullsv;
    else
	const_sv = op_const_sv(block, Nullcv);

    if (cv) {
        bool exists = CvROOT(cv) || CvXSUB(cv);

#ifdef GV_UNIQUE_CHECK
        if (exists && GvUNIQUE(gv)) {
            Perl_croak(aTHX_ "Can't redefine unique subroutine %s", name);
        }
#endif

        /* if the subroutine doesn't exist and wasn't pre-declared
         * with a prototype, assume it will be AUTOLOADed,
         * skipping the prototype check
         */
        if (exists || SvPOK(cv))
	    cv_ckproto(cv, gv, ps);
d4500 3
a4502 1
	if (exists || GvASSUMECV(gv)) {
a4503 4
		if (CvFLAGS(PL_compcv)) {
		    /* might have had built-in attrs applied */
		    CvFLAGS(cv) |= (CvFLAGS(PL_compcv) & CVf_BUILTIN_ATTRS);
		}
d4509 3
a4511 1
	    if (PL_curstackinfo->si_type == PERLSI_SORT && PL_sortcop == CvSTART(cv))
a4512 15
	    if (block) {
		if (ckWARN(WARN_REDEFINE)
		    || (CvCONST(cv)
			&& (!const_sv || sv_cmp(cv_const_sv(cv), const_sv))))
		{
		    line_t oldline = CopLINE(PL_curcop);
		    if (PL_copline != NOLINE)
			CopLINE_set(PL_curcop, PL_copline);
		    Perl_warner(aTHX_ packWARN(WARN_REDEFINE),
			CvCONST(cv) ? "Constant subroutine %s redefined"
				    : "Subroutine %s redefined", name);
		    CopLINE_set(PL_curcop, oldline);
		}
		SvREFCNT_dec(cv);
		cv = Nullcv;
d4514 15
d4531 1
a4531 19
    if (const_sv) {
	SvREFCNT_inc(const_sv);
	if (cv) {
	    assert(!CvROOT(cv) && !CvCONST(cv));
	    sv_setpv((SV*)cv, "");  /* prototype is "" */
	    CvXSUBANY(cv).any_ptr = const_sv;
	    CvXSUB(cv) = const_sv_xsub;
	    CvCONST_on(cv);
	}
	else {
	    GvCV(gv) = Nullcv;
	    cv = newCONSTSUB(NULL, name, const_sv);
	}
	op_free(block);
	SvREFCNT_dec(PL_compcv);
	PL_compcv = NULL;
	PL_sub_generation++;
	goto done;
    }
d4541 1
a4541 3
	    /* Might have had built-in attributes applied -- propagate them. */
	    CvFLAGS(cv) |= (CvFLAGS(PL_compcv) & CVf_BUILTIN_ATTRS);
	    if (CvGV(cv) && GvSTASH(CvGV(cv)))
d4543 1
a4543 1
	    else if (CvSTASH(cv))
d4551 1
a4551 1
	    if (name && GvSTASH(gv))
d4556 1
a4556 1
	apply_attrs(stash, rcv, attrs, FALSE);
a4594 2
	if (PERLDB_INTER)/* Advice debugger on the new sub. */
	  ++PL_sub_generation;
d4605 1
a4605 1
    CvFILE_set_from_cop(cv, PL_curcop);
d4607 1
a4607 1
#ifdef USE_5005THREADS
d4613 1
a4613 1
#endif /* USE_5005THREADS */
d4637 6
a4642 2
    if (!block)
	goto done;
d4658 1
a4658 1
    CALL_PEEP(CvSTART(cv));
a4681 3
	assert(!CvCONST(cv));
	if (ps && !*ps && op_const_sv(block, cv))
	    CvCONST_on(cv);
d4745 2
d4756 1
a4756 1
	    PL_compiling.op_private = (U8)(PL_hints & HINT_PRIVATE_MASK);
d4772 1
a4772 1
		Perl_warner(aTHX_ packWARN(WARN_VOID), "Too late to run CHECK block");
d4782 1
a4782 1
		Perl_warner(aTHX_ packWARN(WARN_VOID), "Too late to run INIT block");
d4804 1
a4804 1
CV *
a4806 1
    CV* cv;
d4820 5
a4824 1
	CopSTASH_set(PL_curcop,stash);
d4827 7
a4833 4
    cv = newXS(name, const_sv_xsub, __FILE__);
    CvXSUBANY(cv).any_ptr = sv;
    CvCONST_on(cv);
    sv_setpv((SV*)cv, "");  /* prototype is "" */
a4835 2

    return cv;
d4849 1
a4849 3
    GV *gv = gv_fetchpv(name ? name :
			(PL_curstash ? "__ANON__" : "__ANON__::__ANON__"),
			GV_ADDMULTI, SVt_PVCV);
d4861 1
d4866 1
a4866 4
		Perl_warner(aTHX_ packWARN(WARN_REDEFINE),
			    CvCONST(cv) ? "Constant subroutine %s redefined"
					: "Subroutine %s redefined"
			    ,name);
d4886 1
a4886 1
#ifdef USE_5005THREADS
d4890 1
a4890 1
#endif /* USE_5005THREADS */
d4923 1
a4923 1
		Perl_warner(aTHX_ packWARN(WARN_VOID), "Too late to run CHECK block");
d4932 1
a4932 1
		Perl_warner(aTHX_ packWARN(WARN_VOID), "Too late to run INIT block");
a4957 5
#ifdef GV_UNIQUE_CHECK
    if (GvUNIQUE(gv)) {
        Perl_croak(aTHX_ "Bad symbol for form (GV is unique)");
    }
#endif
d4962 3
a4964 3
	    if (PL_copline != NOLINE)
		CopLINE_set(PL_curcop, PL_copline);
	    Perl_warner(aTHX_ packWARN(WARN_REDEFINE), "Format %s redefined",name);
d4972 1
a4972 1
    CvFILE_set_from_cop(cv, PL_curcop);
d4984 1
a4984 1
    CALL_PEEP(CvSTART(cv));
d5026 1
a5026 1

d5035 1
a5035 1
	    Perl_warner(aTHX_ packWARN(WARN_INTERNAL), "oops: oopsAV");
d5060 1
a5060 1
	    Perl_warner(aTHX_ packWARN(WARN_INTERNAL), "oops: oopsHV");
a5073 5
    else if ((o->op_type == OP_RV2AV || o->op_type == OP_PADAV)
		&& ckWARN(WARN_DEPRECATED)) {
	Perl_warner(aTHX_ packWARN(WARN_DEPRECATED),
		"Using an array as a reference is deprecated");
    }
a5092 5
    else if ((o->op_type == OP_RV2HV || o->op_type == OP_PADHV)
		&& ckWARN(WARN_DEPRECATED)) {
	Perl_warner(aTHX_ packWARN(WARN_DEPRECATED),
		"Using a hash as a reference is deprecated");
    }
d5150 1
a5150 1
    o->op_private = (U8)(PL_hints & HINT_PRIVATE_MASK);
d5177 1
a5177 1

d5208 1
a5208 1
		  OP_DESC(o));
d5210 1
a5210 1
	op_null(kid);
a5215 9
Perl_ck_die(pTHX_ OP *o)
{
#ifdef VMS
    if (VMSISH_HUSHED) o->op_private |= OPpHUSH_VMSISH;
#endif
    return ck_fun(o);
}

OP *
d5240 1
a5240 1
	    op_null(o);
a5283 1
    if (VMSISH_HUSHED) o->op_private |= OPpHUSH_VMSISH;
d5296 1
a5296 1
	    op_null(kid);
d5313 1
a5313 1
			    OP_DESC(o));
d5320 2
a5321 2
		        OP_DESC(o));
	op_null(kid);
d5402 1
a5402 1
		Perl_croak(aTHX_
d5474 7
a5535 6
		if ((type == OP_PUSH || type == OP_UNSHIFT)
		    && !kid->op_sibling && ckWARN(WARN_SYNTAX))
		    Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
			"Useless use of %s with no values",
			PL_op_desc[type]);

d5542 2
a5543 2
		    if (ckWARN2(WARN_DEPRECATED, WARN_SYNTAX))
			Perl_warner(aTHX_ packWARN2(WARN_DEPRECATED, WARN_SYNTAX),
d5562 2
a5563 2
		    if (ckWARN2(WARN_DEPRECATED, WARN_SYNTAX))
			Perl_warner(aTHX_ packWARN2(WARN_DEPRECATED, WARN_SYNTAX),
a5593 3
			if (!(o->op_private & 1) && /* if not unop */
			    kid == cLISTOPo->op_last)
			    cLISTOPo->op_last = newop;
d5599 1
a5599 1
			bad_type(numargs, "HANDLE", OP_DESC(o), kid);
d5667 1
a5667 1
	    return too_many_arguments(o,OP_DESC(o));
d5679 1
a5679 1
	    return too_few_arguments(o,OP_DESC(o));
d5693 1
a5693 3
    if (!((gv = gv_fetchpv("glob", FALSE, SVt_PVCV))
	  && GvCVu(gv) && GvIMPORTED_CV(gv)))
    {
a5694 1
    }
a5698 1
	GV *glob_gv;
d5700 3
a5702 2
	Perl_load_module(aTHX_ PERL_LOADMOD_NOIMPORT,
		newSVpvn("File::Glob", 10), Nullsv, Nullsv, Nullsv);
a5703 4
	glob_gv = gv_fetchpv("File::Glob::csh_glob", FALSE, SVt_PVCV);
	GvCV(gv) = GvCV(glob_gv);
	SvREFCNT_inc((SV*)GvCV(gv));
	GvIMPORTED_CV_on(gv);
d5708 1
a5708 1
    if (gv && GvCVu(gv) && GvIMPORTED_CV(gv)) {
d5726 1
d5775 1
a5775 1
	return too_few_arguments(o,OP_DESC(o));
d5812 1
a5812 1
    if ((o->op_flags & OPf_KIDS) && ckWARN2(WARN_DEPRECATED, WARN_SYNTAX)) {
d5819 1
a5819 1
	    break;                      /* Globals via GV can be undef */
d5822 1
a5822 1
	    Perl_warner(aTHX_ packWARN2(WARN_DEPRECATED, WARN_SYNTAX),
d5824 1
a5824 1
	    Perl_warner(aTHX_ packWARN2(WARN_DEPRECATED, WARN_SYNTAX),
d5832 1
a5832 1
	    break;                      /* Globals via GV can be undef */
d5834 1
a5834 1
	    Perl_warner(aTHX_ packWARN2(WARN_DEPRECATED, WARN_SYNTAX),
d5836 1
a5836 1
	    Perl_warner(aTHX_ packWARN2(WARN_DEPRECATED, WARN_SYNTAX),
d5877 1
a5877 1

d5881 23
a5903 1
    return listkids(o);
d5937 12
d5963 3
a5965 6
	    if (!SvREADONLY(sv) || !SvFAKE(sv)) {
		sv = newSVpvn_share(SvPVX(sv), SvCUR(sv), 0);
	    }
	    else {
		kSVOP->op_sv = Nullsv;
	    }
d5967 1
a6025 2
    GV* gv;

a6046 17

    /* handle override, if any */
    gv = gv_fetchpv("require", FALSE, SVt_PVCV);
    if (!(gv && GvCVu(gv) && GvIMPORTED_CV(gv)))
	gv = gv_fetchpv("CORE::GLOBAL::require", FALSE, SVt_PVCV);

    if (gv && GvCVu(gv) && GvIMPORTED_CV(gv)) {
	OP *kid = cUNOPo->op_first;
	cUNOPo->op_first = 0;
	op_free(o);
	return ck_subr(newUNOP(OP_ENTERSUB, OPf_STACKED,
			       append_elem(OP_LIST, kid,
					   scalar(newUNOP(OP_RV2CV, 0,
							  newGVOP(OP_GV, 0,
								  gv))))));
    }

d6098 1
a6098 1

d6100 1
a6100 1
#ifdef USE_5005THREADS
d6114 1
a6114 1
#endif /* USE_5005THREADS */
d6124 5
d6134 1
a6134 1
	OP *k = NULL;
d6145 1
a6145 1
		    op_null(kid);			/* wipe out leave */
d6163 1
a6163 1
	    CALL_PEEP(k);
d6176 1
a6176 1
	    op_null(firstkid);
d6197 2
a6198 2
    GvMULTI_on(gv_fetchpv("a", TRUE, SVt_PV));
    GvMULTI_on(gv_fetchpv("b", TRUE, SVt_PV));
a6283 4
    if (ckWARN(WARN_REGEXP) && ((PMOP *)kid)->op_pmflags & PMf_GLOBAL) {
      Perl_warner(aTHX_ packWARN(WARN_REGEXP),
                  "Use of /g modifier is meaningless in split");
    }
d6298 1
a6298 1
	return too_many_arguments(o,OP_DESC(o));
d6304 1
a6304 1
Perl_ck_join(pTHX_ OP *o)
d6310 3
a6312 3
	    if (PM_GETRE(kPMOP))
		pmstr = PM_GETRE(kPMOP)->precomp;
	    Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
a6331 2
    I32 contextclass = 0;
    char *e = 0;
d6339 1
a6339 1
	op_null(cvop);		/* disable rv2cv */
a6427 3
	    case '[': case ']':
		 goto oops;
		 break;
a6430 1
	    again:
a6431 23
		case '[':
		     if (contextclass++ == 0) {
		          e = strchr(proto, ']');
			  if (!e || e == proto)
			       goto oops;
		     }
		     else
			  goto oops;
		     goto again;
		     break;
		case ']':
		     if (contextclass) {
			 char *p = proto;
			 char s = *p;
			 contextclass = 0;
			 *p = '\0';
			 while (*--p != '[');
			 bad_type(arg, Perl_form(aTHX_ "one of %s", p),
				 gv_ename(namegv), o2);
			 *proto = s;
		     } else
			  goto oops;
		     break;
d6433 3
a6435 5
		     if (o2->op_type == OP_RV2GV)
			  goto wrapref;
		     if (!contextclass)
			  bad_type(arg, "symbol", gv_ename(namegv), o2);
		     break;
d6437 3
a6439 5
		     if (o2->op_type == OP_ENTERSUB)
			  goto wrapref;
		     if (!contextclass)
			  bad_type(arg, "subroutine entry", gv_ename(namegv), o2);
		     break;
d6441 6
a6446 7
		    if (o2->op_type == OP_RV2SV ||
			o2->op_type == OP_PADSV ||
			o2->op_type == OP_HELEM ||
			o2->op_type == OP_AELEM ||
			o2->op_type == OP_THREADSV)
			 goto wrapref;
		    if (!contextclass)
d6448 2
a6449 1
		     break;
d6451 1
a6451 4
		    if (o2->op_type == OP_RV2AV ||
			o2->op_type == OP_PADAV)
			 goto wrapref;
		    if (!contextclass)
d6453 1
a6453 1
		    break;
d6455 3
a6457 7
		    if (o2->op_type == OP_RV2HV ||
			o2->op_type == OP_PADHV)
			 goto wrapref;
		    if (!contextclass)
			 bad_type(arg, "hash", gv_ename(namegv), o2);
		    break;
		wrapref:
a6465 4
		    if (contextclass && e) {
			 proto = e + 1;
			 contextclass = 0;
		    }
a6468 2
		if (contextclass)
		     goto again;
d6476 1
a6476 1
			   gv_ename(namegv), SvPV((SV*)cv, n_a));
d6570 1
a6570 1
		     * some pad, so make a copy. */
a6578 2
		    /* XXX I don't know how this isn't readonly already. */
		    SvREADONLY_on(PL_curpad[ix]);
d6599 1
a6599 1
		op_null(o->op_next);
d6617 1
a6617 9
	    /* XXX: We avoid setting op_seq here to prevent later calls
	       to peep() from mistakenly concluding that optimisation
	       has already occurred. This doesn't fix the real problem,
	       though (See 20010220.007). AMS 20010719 */
	    if (oldop && o->op_next) {
		oldop->op_next = o->op_next;
		continue;
	    }
	    break;
d6632 1
a6632 1
		    op_null(o->op_next);
d6643 1
a6643 1
		if (pop && pop->op_type == OP_CONST &&
d6648 1
a6648 1
		    (i = SvIV(((SVOP*)pop)->op_sv) - PL_curcop->cop_arybase)
d6653 3
a6655 3
		    op_null(o->op_next);
		    op_null(pop->op_next);
		    op_null(pop);
d6671 1
a6671 1
		    Perl_warner(aTHX_ packWARN(WARN_PROTOTYPE),
a6675 11
	    else if (o->op_next->op_type == OP_READLINE
		    && o->op_next->op_next->op_type == OP_CONCAT
		    && (o->op_next->op_next->op_flags & OPf_STACKED))
	    {
		/* Turn "$a .= <FH>" into an OP_RCATLINE. AMS 20010917 */
		o->op_type   = OP_RCATLINE;
		o->op_flags |= OPf_STACKED;
		o->op_ppaddr = PL_ppaddr[OP_RCATLINE];
		op_null(o->op_next->op_next);
		op_null(o->op_next);
	    }
d6691 1
a6691 1
	    peep(cLOGOP->op_other); /* Recursive calls are not replaced by fptr calls */
d6712 1
a6712 1
	    while (cPMOP->op_pmreplstart &&
d6720 1
a6720 1
	    if (ckWARN(WARN_SYNTAX) && o->op_next
d6729 1
a6729 1
		    Perl_warner(aTHX_ packWARN(WARN_EXEC),
d6731 1
a6731 1
		    Perl_warner(aTHX_ packWARN(WARN_EXEC),
d6737 1
a6737 1

d6744 1
a6744 1
	    char *key = NULL;
d6746 1
a6746 1

d6748 2
a6749 16

	    if (((BINOP*)o)->op_last->op_type != OP_CONST)
		break;

	    /* Make the CONST have a shared SV */
	    svp = cSVOPx_svp(((BINOP*)o)->op_last);
	    if ((!SvFAKE(sv = *svp) || !SvREADONLY(sv)) && !IS_PADCONST(sv)) {
		key = SvPV(sv, keylen);
		lexname = newSVpvn_share(key,
					 SvUTF8(sv) ? -(I32)keylen : keylen,
					 0);
		SvREFCNT_dec(sv);
		*svp = lexname;
	    }

	    if ((o->op_private & (OPpLVAL_INTRO)))
a6750 1

d6755 1
a6755 1
	    if (!(SvFLAGS(lexname) & SVpad_TYPED))
d6760 1
d6762 1
a6762 2
	    indsvp = hv_fetch(GvHV(*fields), key,
			      SvUTF8(*svp) ? -(I32)keylen : keylen, FALSE);
d6783 1
a6783 1

d6804 1
a6804 1
	    if (!(SvFLAGS(lexname) & SVpad_TYPED))
d6827 1
a6827 2
		indsvp = hv_fetch(GvHV(*fields), key,
				  SvUTF8(*svp) ? -(I32)keylen : keylen, FALSE);
a6853 57
}



char* Perl_custom_op_name(pTHX_ OP* o)
{
    IV  index = PTR2IV(o->op_ppaddr);
    SV* keysv;
    HE* he;

    if (!PL_custom_op_names) /* This probably shouldn't happen */
        return PL_op_name[OP_CUSTOM];

    keysv = sv_2mortal(newSViv(index));

    he = hv_fetch_ent(PL_custom_op_names, keysv, 0, 0);
    if (!he)
        return PL_op_name[OP_CUSTOM]; /* Don't know who you are */

    return SvPV_nolen(HeVAL(he));
}

char* Perl_custom_op_desc(pTHX_ OP* o)
{
    IV  index = PTR2IV(o->op_ppaddr);
    SV* keysv;
    HE* he;

    if (!PL_custom_op_descs)
        return PL_op_desc[OP_CUSTOM];

    keysv = sv_2mortal(newSViv(index));

    he = hv_fetch_ent(PL_custom_op_descs, keysv, 0, 0);
    if (!he)
        return PL_op_desc[OP_CUSTOM];

    return SvPV_nolen(HeVAL(he));
}


#include "XSUB.h"

/* Efficient sub that returns a constant scalar value. */
static void
const_sv_xsub(pTHX_ CV* cv)
{
    dXSARGS;
    if (items != 0) {
#if 0
        Perl_croak(aTHX_ "usage: %s::%s()",
                   HvNAME(GvSTASH(CvGV(cv))), GvNAME(CvGV(cv)));
#endif
    }
    EXTEND(sp, 1);
    ST(0) = (SV*)XSANY.any_ptr;
    XSRETURN(1);
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, by Larry Wall and others
d32 7
a38 2
void *
Perl_Slab_Alloc(pTHX_ int m, size_t sz)
d76 2
a77 2
void
Perl_Slab_Free(pTHX_ void *op)
d85 3
a87 3
#  ifdef NETWARE
#    define PerlMemShared PerlMem
#  endif
d95 4
d107 1
a107 1
	 Perl_croak(aTHX_ "'%s' trapped by operation mask", PL_op_desc[type]),	\
d111 1
d156 2
a157 2
		     "Bareword \"%"SVf"\" not allowed while \"strict subs\" in use",
		     cSVOPo_sv));
d163 1
a163 1
Perl_allocmy(pTHX_ char *name)
d166 1
a167 1
    /* complain about "my $_" etc etc */
d194 66
a259 22
    /* check for duplicate declaration */
    pad_check_dup(name,
		(bool)(PL_in_my == KEY_our),
		(PL_curstash ? PL_curstash : PL_defstash)
    );

    if (PL_in_my_stash && *name != '$') {
	yyerror(Perl_form(aTHX_
		    "Can't declare class for non-scalar %s in \"%s\"",
		     name, PL_in_my == KEY_our ? "our" : "my"));
    }

    /* allocate a spare slot and store the name in that slot */

    off = pad_add_name(name,
		    PL_in_my_stash,
		    (PL_in_my == KEY_our 
			? (PL_curstash ? PL_curstash : PL_defstash)
			: Nullhv
		    ),
		    0 /*  not fake */
    );
d263 411
d820 7
a826 3
	    /* No GvIN_PAD_off(cGVOPo_gv) here, because other references
	     * may still exist on the pad */
	    pad_swipe(cPADOPo->op_padix, TRUE);
a837 12
#ifdef USE_ITHREADS
	/** Bug #15654
	  Even if op_clear does a pad_free for the target of the op,
	  pad_free doesn't actually remove the sv that exists in the bad
	  instead it lives on. This results in that it could be reused as 
	  a target later on when the pad was reallocated.
	**/
        if(o->op_targ) {
          pad_swipe(o->op_targ,1);
          o->op_targ = 0;
        }
#endif
d862 7
a868 3
	    /* No GvIN_PAD_off here, because other references may still
	     * exist on the pad */
	    pad_swipe(INT2PTR(PADOFFSET, cPMOPo->op_pmreplroot), TRUE);
a1190 1
    case OP_PROTOTYPE:
d1420 1
d1595 2
d1615 1
d1619 2
a1645 4
	{   /* XXX DAPM 2002.08.25 tmp assert test */
	    /* XXX */ assert(av_fetch(PL_comppad_name, (o->op_targ), FALSE));
	    /* XXX */ assert(*av_fetch(PL_comppad_name, (o->op_targ), FALSE));

d1647 1
a1647 2
		 PAD_COMPNAME_PV(o->op_targ));
	}
d1991 1
a1991 1
    apply_attrs(stash, PAD_SV(target->op_targ), attrs, TRUE);
d2091 13
a2103 13
	if (cUNOPo->op_first->op_type != OP_GV) { /* MJD 20011224 */
	    yyerror(Perl_form(aTHX_ "Can't declare %s in %s",
			OP_DESC(o), PL_in_my == KEY_our ? "our" : "my"));
	} else if (attrs) {
	    GV *gv = cGVOPx_gv(cUNOPo->op_first);
	    PL_in_my = FALSE;
	    PL_in_my_stash = Nullhv;
	    apply_attrs(GvSTASH(gv),
			(type == OP_RV2SV ? GvSV(gv) :
			 type == OP_RV2AV ? (SV*)GvAV(gv) :
			 type == OP_RV2HV ? (SV*)GvHV(gv) : (SV*)gv),
			attrs, FALSE);
	}
d2119 1
d2125 4
a2128 2
	stash = PAD_COMPNAME_TYPE(o->op_targ);
	if (!stash)
a2142 3
/* [perl #17376]: this appears to be premature, and results in code such as
   C< our(%x); > executing in list mode rather than void mode */
#if 0
a2146 3
#else
    maybe_scalar = 1;
#endif
d2245 11
a2255 7
	else if (o->op_type == OP_LINESEQ) {
	    OP *kid;
	    o->op_type = OP_SCOPE;
	    o->op_ppaddr = PL_ppaddr[OP_SCOPE];
	    kid = ((LISTOP*)o)->op_first;
	    if (kid->op_type == OP_NEXTSTATE || kid->op_type == OP_DBSTATE)
		op_null(kid);
a2256 2
	else
	    o = newLISTOP(OP_SCOPE, 0, o, Nullop);
a2273 2
    /* If there were syntax errors, don't try to start a block */
    if (PL_yynerrs) return retval;
d2275 13
a2287 1
    pad_block_start(full);
d2307 4
a2310 3
    OP* retval = scalarseq(seq);
    /* If there were syntax errors, don't try to close a block */
    if (PL_yynerrs) return retval;
d2312 1
d2316 2
a2317 1
    pad_leavemy();
d2349 1
a2349 3
	if (o->op_type == OP_STUB) {
	    PL_comppad_name = 0;
	    PL_compcv = 0;
a2350 1
	}
a2377 3
/* [perl #17376]: this appears to be premature, and results in code such as
   C< our(%x); > executing in list mode rather than void mode */
#if 0
a2378 3
#else
	;
#endif
a2383 1
	    int sigil = 0;
d2385 1
a2385 3
	    /* some heuristics to detect a potential error */
	    while (*s && (strchr(", \t\n", *s)
			|| (strchr("@@$%*", *s) && ++sigil) ))
d2387 5
a2391 11
	    if (sigil) {
		while (*s && (isALNUM(*s) || UTF8_IS_CONTINUED(*s)
			    || strchr("@@$%*, \t\n", *s)))
		    s++;

		if (*s == ';' || *s == '=')
		    Perl_warner(aTHX_ packWARN(WARN_PARENTHESIS),
				"Parentheses missing around \"%s\" list",
				lex ? (PL_in_my == KEY_our ? "our" : "my")
				: "local");
	    }
d2484 1
a2484 1
	pad_swipe(o->op_targ,  FALSE);
d2492 13
a2504 1
    return newSVOP(OP_CONST, 0, sv);
a2530 2
    o->op_flags &= ~OPf_REF;	/* treat \(1..2) like an ordinary list */
    o->op_flags |= OPf_PARENS;	/* and flatten \(1..2,3) */
d2691 1
a2691 1
    return CHECKOP(type, listop);
d2814 7
a2820 7
	UV tfirst = 1;
	UV tlast = 0;
	IV tdiff;
	UV rfirst = 1;
	UV rlast = 0;
	IV rdiff;
	IV diff;
d3128 1
a3128 1
    return CHECKOP(type, pmop);
d3194 1
a3194 1
	    if (CopLINE(PL_curcop) < (line_t)PL_multi_end)
d3221 1
a3221 1
			if (strchr("&`'123456789+-\016\022", *GvENAME(gv)))
d3307 3
a3309 4
    SvREFCNT_dec(PAD_SVl(padop->op_padix));
    PAD_SETSV(padop->op_padix, sv);
    if (sv)
	SvPADTMP_on(sv);
d3323 1
a3323 2
    if (gv)
	GvIN_PAD_on(gv);
d3374 1
a3374 1
Perl_utilize(pTHX_ int aver, I32 floor, OP *version, OP *idop, OP *arg)
d3380 1
a3380 1
    if (idop->op_type != OP_CONST)
d3398 2
a3399 2
	    /* Make copy of idop so we don't free it twice */
	    pack = newSVOP(OP_CONST, 0, newSVsv(((SVOP*)idop)->op_sv));
d3416 1
a3416 1
    else if (SvNIOKp(((SVOP*)idop)->op_sv)) {
d3422 2
a3423 2
	/* Make copy of idop so we don't free it twice */
	pack = newSVOP(OP_CONST, 0, newSVsv(((SVOP*)idop)->op_sv));
d3443 1
a3443 1
	        newSTATEOP(0, Nullch, newUNOP(OP_REQUIRE, 0, idop)),
a3466 1
    PL_cop_seqmax++; /* Purely for B::*'s benefit */
a3534 1
	COP *ocurcop = PL_curcop;
a3540 1
	PL_curcop = ocurcop;
a3655 15

	/* PL_generation sorcery:
	 * an assignment like ($a,$b) = ($c,$d) is easier than
	 * ($a,$b) = ($c,$a), since there is no need for temporary vars.
	 * To detect whether there are common vars, the global var
	 * PL_generation is incremented for each assign op we compile.
	 * Then, while compiling the assign op, we run through all the
	 * variables on both sides of the assignment, setting a spare slot
	 * in each of them to PL_generation. If any of them already have
	 * that value, we know we've got commonality.  We could use a
	 * single bit marker, but then we'd have to make 2 passes, first
	 * to clear the flag, then to test and set it.  To find somewhere
	 * to store these values, evil chicanery is done with SvCUR().
	 */
	
d3670 4
a3673 4
			     curop->op_type == OP_PADANY)
		    {
			if ((int)PAD_COMPNAME_GEN(curop->op_targ)
						    == PL_generation)
d3675 1
a3675 3
			PAD_COMPNAME_GEN(curop->op_targ)
			    				= PL_generation;

d3689 1
a3689 2
			    GV *gv = (GV*)PAD_SVl(INT2PTR(PADOFFSET,
					((PMOP*)curop)->op_pmreplroot));
d3832 22
d3889 2
a3890 6
	if (ckWARN(WARN_BAREWORD) && (first->op_private & OPpCONST_BARE)) {
	    if (first->op_private & OPpCONST_STRICT)
		no_bareword_allowed(first);
	    else
		Perl_warner(aTHX_ packWARN(WARN_BAREWORD), "Bareword found in conditional");
	}
a3959 2
    CHECKOP(type,logop);

a4003 2
    CHECKOP(OP_COND_EXPR, /* that's logop->op_type */
	    logop);
d4168 5
a4224 1
    I32 iterpflags = 0;
a4227 1
	    iterpflags = sv->op_private & OPpOUR_INTRO; /* for our $x () */
a4231 1
	    iterpflags = sv->op_private & OPpLVAL_INTRO; /* for my $x () */
a4294 3
    /* for my  $x () sets OPpLVAL_INTRO;
     * for our $x () sets OPpOUR_INTRO; both only used by Deparse.pm */
    loop->op_private = (U8)iterpflags;
d4330 1
a4330 3
	/* Check whether it's going to be a goto &function */
	if (label->op_type == OP_ENTERSUB
		&& !(label->op_flags & OPf_STACKED))
a4337 11
/*
=for apidoc cv_undef

Clear out all the active components of a CV. This can happen either
by an explicit C<undef &foo>, or by the reference count going to zero.
In the former case, we keep the CvOUTSIDE pointer, so that any anonymous
children can still follow the full lexical scope chain.

=cut
*/

d4341 4
d4371 2
a4372 1
	PAD_SAVE_SETNULLPAD();
d4380 9
a4388 9

    pad_undef(cv);

    /* remove CvOUTSIDE unless this is an undef rather than a free */
    if (!SvREFCNT(cv) && CvOUTSIDE(cv)) {
	if (!CvWEAKOUTSIDE(cv))
	    SvREFCNT_dec(CvOUTSIDE(cv));
	CvOUTSIDE(cv) = Nullcv;
    }
d4393 53
d4449 206
a4654 2
    /* delete all flags except WEAKOUTSIDE */
    CvFLAGS(cv) &= CVf_WEAKOUTSIDE;
d4670 1
a4670 1
	    Perl_sv_catpvf(aTHX_ msg, " (%"SVf")", (SV *)cv);
d4733 2
a4734 1
	    sv = PAD_BASE_SV(CvPADLIST(cv), o->op_targ);
d4785 1
a4942 1
	/* transfer PL_compcv to cv */
a4945 1
	CvOUTSIDE_SEQ(cv) = CvOUTSIDE_SEQ(PL_compcv);
d4950 22
a4971 1
	pad_fixup_inner_anons(CvPADLIST(cv), PL_compcv, cv);
d5013 1
a5013 1
		    Perl_croak(aTHX_ "%"SVf, ERRSV);
d5021 3
d5038 4
d5043 16
a5058 3
    pad_tidy(CvCLONE(cv) ? padtidy_SUBCLONE : padtidy_SUB);

    if (CvCLONE(cv)) {
d5063 20
d5202 1
a5202 1
    cv = newXS(name, const_sv_xsub, savepv(CopFILE(PL_curcop)));
a5206 3
    if (stash)
	CopSTASH_free(PL_curcop);

d5328 1
d5357 4
a5361 1
    pad_tidy(padtidy_FORMAT);
d5523 12
a5534 1
    cSVOPo->op_targ = pad_add_anon(cSVOPo->op_sv, o->op_type);
d5536 1
a5542 8
#define OP_IS_NUMCOMPARE(op) \
	((op) == OP_LT   || (op) == OP_I_LT || \
	 (op) == OP_GT   || (op) == OP_I_GT || \
	 (op) == OP_LE   || (op) == OP_I_LE || \
	 (op) == OP_GE   || (op) == OP_I_GE || \
	 (op) == OP_EQ   || (op) == OP_I_EQ || \
	 (op) == OP_NE   || (op) == OP_I_NE || \
	 (op) == OP_NCMP || (op) == OP_I_NCMP)
a5543 18
    if (!(o->op_flags & OPf_STACKED) /* Not an assignment */
	    && (o->op_type == OP_BIT_OR
	     || o->op_type == OP_BIT_AND
	     || o->op_type == OP_BIT_XOR))
    {
	OP * left = cBINOPo->op_first;
	OP * right = left->op_sibling;
	if ((OP_IS_NUMCOMPARE(left->op_type) &&
		(left->op_flags & OPf_PARENS) == 0) ||
	    (OP_IS_NUMCOMPARE(right->op_type) &&
		(right->op_flags & OPf_PARENS) == 0))
	    if (ckWARN(WARN_PRECEDENCE))
		Perl_warner(aTHX_ packWARN(WARN_PRECEDENCE),
			"Possible precedence problem on bitwise %c operator",
			o->op_type == OP_BIT_OR ? '|'
			    : o->op_type == OP_BIT_AND ? '&' : '^'
			);
    }
d5550 2
a5551 3
    OP *kid = cUNOPo->op_first;
    if (kid->op_type == OP_CONCAT && !(kUNOP->op_first->op_flags & OPf_MOD))
        o->op_flags |= OPf_STACKED;
d5625 2
a5626 1
	    o = newUNOP(type, OPf_SPECIAL, newGVOP(OP_GV, 0, PL_argvgv));
d5644 1
a5644 1
	else if (kid->op_type == OP_LINESEQ || kid->op_type == OP_STUB) {
d5647 1
d5837 1
a5837 1
	    SvREFCNT_dec(PAD_SVl(kPADOP->op_padix));
d5839 1
a5839 1
	    PAD_SETSV(kPADOP->op_padix, (SV*) SvREFCNT_inc(gv));
a5867 5
	else {
	  if ((PL_hints & HINT_FILETEST_ACCESS) &&
	      OP_IS_FILETEST_ACCESS(o))
	    o->op_private |= OPpFT_ACCESS;
	}
d5872 2
a5873 1
	    o = newGVOP(type, OPf_REF, PL_stdingv);
d6014 1
a6014 1
			    STRLEN len = 0;
d6023 4
a6026 11
				/*XXX DAPM 2002.08.25 tmp assert test */
				/*XXX*/ assert(av_fetch(PL_comppad_name, (kid->op_targ), FALSE));
				/*XXX*/ assert(*av_fetch(PL_comppad_name, (kid->op_targ), FALSE));

				name = PAD_COMPNAME_PV(kid->op_targ);
				/* SvCUR of a pad namesv can't be trusted
				 * (see PL_generation), so calc its length
				 * manually */
				if (name)
				    len = strlen(name);

d6038 3
a6040 45
				 OP *op;

				 name = 0;
				 if ((op = ((BINOP*)kid)->op_first)) {
				      SV *tmpstr = Nullsv;
				      char *a =
					   kid->op_type == OP_AELEM ?
					   "[]" : "{}";
				      if (((op->op_type == OP_RV2AV) ||
					   (op->op_type == OP_RV2HV)) &&
					  (op = ((UNOP*)op)->op_first) &&
					  (op->op_type == OP_GV)) {
					   /* packagevar $a[] or $h{} */
					   GV *gv = cGVOPx_gv(op);
					   if (gv)
						tmpstr =
						     Perl_newSVpvf(aTHX_
								   "%s%c...%c",
								   GvNAME(gv),
								   a[0], a[1]);
				      }
				      else if (op->op_type == OP_PADAV
					       || op->op_type == OP_PADHV) {
					   /* lexicalvar $a[] or $h{} */
					   char *padname =
						PAD_COMPNAME_PV(op->op_targ);
					   if (padname)
						tmpstr =
						     Perl_newSVpvf(aTHX_
								   "%s%c...%c",
								   padname + 1,
								   a[0], a[1]);
					   
				      }
				      if (tmpstr) {
					   name = savepv(SvPVX(tmpstr));
					   len = strlen(name);
					   sv_2mortal(tmpstr);
				      }
				 }
				 if (!name) {
				      name = "__ANONIO__";
				      len = 10;
				 }
				 mod(kid, type);
d6045 1
a6045 1
				namesv = PAD_SVl(targ);
d6106 1
a6106 1
    if (!(gv && GvCVu(gv) && GvIMPORTED_CV(gv))) {
a6386 19
    {
	 /* In case of three-arg dup open remove strictness
	  * from the last arg if it is a bareword. */
	 OP *first = cLISTOPx(o)->op_first; /* The pushmark. */
	 OP *last  = cLISTOPx(o)->op_last;  /* The bareword. */
	 OP *oa;
	 char *mode;

	 if ((last->op_type == OP_CONST) &&		/* The bareword. */
	     (last->op_private & OPpCONST_BARE) &&
	     (last->op_private & OPpCONST_STRICT) &&
	     (oa = first->op_sibling) &&		/* The fh. */
	     (oa = oa->op_sibling) &&			/* The mode. */
	     SvPOK(((SVOP*)oa)->op_sv) &&
	     (mode = SvPVX(((SVOP*)oa)->op_sv)) &&
	     mode[0] == '>' && mode[1] == '&' &&	/* A dup open. */
	     (last == oa->op_sibling))			/* The bareword. */
	      last->op_private &= ~OPpCONST_STRICT;
    }
d6501 1
a6501 1
	    argop->op_targ = 0;		/* PAD_SV(0) is @@_ */
d6510 2
a6511 1
	    scalar(newGVOP(OP_GV, 0, CvUNIQUE(PL_compcv) ? PL_argvgv : PL_defgv)));
d6918 2
a6919 2
		Perl_croak(aTHX_ "Malformed prototype for %s: %"SVf,
			   gv_ename(namegv), cv);
d6991 2
a6992 4
        /* The special value -1 is used by the B::C compiler backend to indicate
         * that an op is statically defined and should not be freed */
	if (!PL_op_seqmax || PL_op_seqmax == (U16)-1)
	    PL_op_seqmax = 1;
a7005 1
	case OP_METHOD_NAMED:
d7011 1
a7011 1
		if (o->op_type == OP_CONST && SvPADTMP(cSVOPo->op_sv)) {
d7014 2
a7015 2
		    sv_setsv(PAD_SVl(ix),cSVOPo->op_sv);
		    SvREADONLY_on(PAD_SVl(ix));
d7019 1
a7019 1
		    SvREFCNT_dec(PAD_SVl(ix));
d7021 1
a7021 1
		    PAD_SETSV(ix, cSVOPo->op_sv);
d7023 1
a7023 1
		    SvREADONLY_on(PAD_SVl(ix));
a7049 11
	    if(!oldop &&
	       o->op_next &&
	       o->op_next->op_type == OP_LEAVESUB) {
	      OP* newop = newSTATEOP(0, Nullch, 0);
	       newop->op_next = o->op_next;
	       o->op_next = 0;
       	       op_free(o);
	       o = newop;
       	       ((UNOP*)o->op_next)->op_first = newop;	
	       CvSTART(PL_compcv) = newop;	
	    }
d7125 2
a7126 2
				"%"SVf"() called too early to check prototype",
				sv);
@


1.1.1.7
log
@perl 5.8.3 from CPAN
@
text
@a1879 1
	    FreeOp(o);
a4301 5
	/* This makes sub {}; work as expected.  */
	if (block->op_type == OP_STUB) {
	    op_free(block);
	    block = newSTATEOP(0, Nullch, 0);
	}
d4800 1
a4800 2
    if (kid->op_type == OP_CONCAT && !(kid->op_private & OPpTARGET_MY) &&
	    !(kUNOP->op_first->op_flags & OPf_MOD))
d5332 2
a5333 1
					   name = SvPV(tmpstr, len);
d6372 11
@


1.1.1.8
log
@Import of stock perl 5.8.5
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
a353 2
	if (! (o->op_type == OP_AELEMFAST && o->op_flags & OPf_SPECIAL)) {
	    /* not an OP_PADAV replacement */
d355 6
a360 6
	    if (cPADOPo->op_padix > 0) {
		/* No GvIN_PAD_off(cGVOPo_gv) here, because other references
		 * may still exist on the pad */
		pad_swipe(cPADOPo->op_padix, TRUE);
		cPADOPo->op_padix = 0;
	    }
d362 2
a363 2
	    SvREFCNT_dec(cSVOPo->op_sv);
	    cSVOPo->op_sv = Nullsv;
a364 1
	}
d373 1
a373 1
	  pad_free doesn't actually remove the sv that exists in the pad;
a752 4
		/* don't warn on optimised away booleans, eg 
		 * use constant Foo, 5; Foo || print; */
		if (cSVOPo->op_private & OPpCONST_SHORTCIRCUIT)
		    useless = 0;
d756 1
a756 1
		else if (SvNIOK(sv) && (SvNV(sv) == 0.0 || SvNV(sv) == 1.0))
a1164 3
	/* Needed if maint gets patch 19588
	   localize = -1;
	*/
a1801 1
/* XXX kept for BINCOMPAT only */
d1805 4
a1808 1
    Perl_croak(aTHX_ "internal error: obsolete function save_hints() called");
d1922 1
a1922 1
	    bool sigil = FALSE;
d1925 2
a1926 1
	    while (*s && (strchr(", \t\n", *s)))
d1928 4
d1933 2
a1934 15
	    while (1) {
		if (*s && strchr("@@$%*", *s) && *++s
		       && (isALNUM(*s) || UTF8_IS_CONTINUED(*s))) {
		    s++;
		    sigil = TRUE;
		    while (*s && (isALNUM(*s) || UTF8_IS_CONTINUED(*s)))
			s++;
		    while (*s && (strchr(", \t\n", *s)))
			s++;
		}
		else
		    break;
	    }
	    if (sigil && (*s == ';' || *s == '=')) {
		Perl_warner(aTHX_ packWARN(WARN_PARENTHESIS),
a3185 9
	/* optimise C<my @@x = ()> to C<my @@x>, and likewise for hashes */
	if ((left->op_type == OP_PADAV || left->op_type == OP_PADHV)
		&& right->op_type == OP_STUB
		&& (left->op_private & OPpLVAL_INTRO))
	{
	    op_free(right);
	    left->op_flags &= ~(OPf_REF|OPf_SPECIAL);
	    return left;
	}
d3427 4
a3430 3
	if (first->op_private & OPpCONST_STRICT)
	    no_bareword_allowed(first);
	else if (ckWARN(WARN_BAREWORD) && (first->op_private & OPpCONST_BARE))
d3432 1
a3435 2
	    if (other->op_type == OP_CONST)
		other->op_private |= OPpCONST_SHORTCIRCUIT;
a3440 2
	    if (first->op_type == OP_CONST)
		first->op_private |= OPpCONST_SHORTCIRCUIT;
a3647 4
    /* if block is null, the next append_elem() would put UNSTACK, a scalar
     * op, in listop. This is wrong. [perl #27024] */
    if (!block)
	block = newOP(OP_NULL, 0);
a3968 2
	else
	    Perl_sv_catpvf(aTHX_ msg, ": none");
d4080 1
a4080 1
    char *ps;
a4084 8

    if (proto) {
	assert(proto->op_type == OP_CONST);
	ps = SvPVx(((SVOP*)proto)->op_sv, n_a);
    }
    else
	ps = Nullch;

a4241 2
	if (!CvWEAKOUTSIDE(cv))
	    SvREFCNT_dec(CvOUTSIDE(cv));
a5433 1
	cLISTOPo->op_first->op_targ = 0;
d5463 1
a5463 1
	for (k = cUNOPx(kid)->op_first; k; k = k->op_next) {
a5628 13
    /* optimise C<my $x = undef> to C<my $x> */
    if (kid->op_type == OP_UNDEF) {
	OP *kkid = kid->op_sibling;
	if (kkid && kkid->op_type == OP_PADSV
		&& (kkid->op_private & OPpLVAL_INTRO))
	{
	    cLISTOPo->op_first = NULL;
	    kid->op_sibling = NULL;
	    op_free(o);
	    op_free(kid);
	    return kkid;
	}
    }
a6409 1
	case OP_PADAV:
d6411 12
a6422 3
	    if (o->op_type == OP_PADAV || o->op_next->op_type == OP_RV2AV) {
		OP* pop = (o->op_type == OP_PADAV) ?
			    o->op_next : o->op_next->op_next;
d6425 1
a6425 1
		    ((PL_op = pop->op_next)) &&
d6434 1
a6434 4
		    if (cSVOPx(pop)->op_private & OPpCONST_STRICT)
			no_bareword_allowed(pop);
		    if (o->op_type == OP_GV)
			op_null(o->op_next);
d6439 1
d6442 2
a6443 20
		    if (o->op_type == OP_GV) {
			gv = cGVOPo_gv;
			GvAVn(gv);
		    }
		    else
			o->op_flags |= OPf_SPECIAL;
		    o->op_type = OP_AELEMFAST;
		}
		o->op_seq = PL_op_seqmax++;
		break;
	    }

	    if (o->op_next->op_type == OP_RV2SV) {
		if (!(o->op_next->op_private & OPpDEREF)) {
		    op_null(o->op_next);
		    o->op_private |= o->op_next->op_private & (OPpLVAL_INTRO
							       | OPpOUR_INTRO);
		    o->op_next = o->op_next->op_next;
		    o->op_type = OP_GVSV;
		    o->op_ppaddr = PL_ppaddr[OP_GVSV];
a6653 101

	case OP_SORT: {
	    /* make @@a = sort @@a act in-place */

	    /* will point to RV2AV or PADAV op on LHS/RHS of assign */
	    OP *oleft, *oright;
	    OP *o2;

	    o->op_seq = PL_op_seqmax++;

	    /* check that RHS of sort is a single plain array */
	    oright = cUNOPo->op_first;
	    if (!oright || oright->op_type != OP_PUSHMARK)
		break;
	    oright = cUNOPx(oright)->op_sibling;
	    if (!oright)
		break;
	    if (oright->op_type == OP_NULL) { /* skip sort block/sub */
		oright = cUNOPx(oright)->op_sibling;
	    }

	    if (!oright ||
		(oright->op_type != OP_RV2AV && oright->op_type != OP_PADAV)
		|| oright->op_next != o
		|| (oright->op_private & OPpLVAL_INTRO)
	    )
		break;

	    /* o2 follows the chain of op_nexts through the LHS of the
	     * assign (if any) to the aassign op itself */
	    o2 = o->op_next;
	    if (!o2 || o2->op_type != OP_NULL)
		break;
	    o2 = o2->op_next;
	    if (!o2 || o2->op_type != OP_PUSHMARK)
		break;
	    o2 = o2->op_next;
	    if (o2 && o2->op_type == OP_GV)
		o2 = o2->op_next;
	    if (!o2
		|| (o2->op_type != OP_PADAV && o2->op_type != OP_RV2AV)
		|| (o2->op_private & OPpLVAL_INTRO)
	    )
		break;
	    oleft = o2;
	    o2 = o2->op_next;
	    if (!o2 || o2->op_type != OP_NULL)
		break;
	    o2 = o2->op_next;
	    if (!o2 || o2->op_type != OP_AASSIGN
		    || (o2->op_flags & OPf_WANT) != OPf_WANT_VOID)
		break;

	    /* check that the sort is the first arg on RHS of assign */

	    o2 = cUNOPx(o2)->op_first;
	    if (!o2 || o2->op_type != OP_NULL)
		break;
	    o2 = cUNOPx(o2)->op_first;
	    if (!o2 || o2->op_type != OP_PUSHMARK)
		break;
	    if (o2->op_sibling != o)
		break;

	    /* check the array is the same on both sides */
	    if (oleft->op_type == OP_RV2AV) {
		if (oright->op_type != OP_RV2AV
		    || !cUNOPx(oright)->op_first
		    || cUNOPx(oright)->op_first->op_type != OP_GV
		    ||  cGVOPx_gv(cUNOPx(oleft)->op_first) !=
		       	cGVOPx_gv(cUNOPx(oright)->op_first)
		)
		    break;
	    }
	    else if (oright->op_type != OP_PADAV
		|| oright->op_targ != oleft->op_targ
	    )
		break;

	    /* transfer MODishness etc from LHS arg to RHS arg */
	    oright->op_flags = oleft->op_flags;
	    o->op_private |= OPpSORT_INPLACE;

	    /* excise push->gv->rv2av->null->aassign */
	    o2 = o->op_next->op_next;
	    op_null(o2); /* PUSHMARK */
	    o2 = o2->op_next;
	    if (o2->op_type == OP_GV) {
		op_null(o2); /* GV */
		o2 = o2->op_next;
	    }
	    op_null(o2); /* RV2AV or PADAV */
	    o2 = o2->op_next->op_next;
	    op_null(o2); /* AASSIGN */

	    o->op_next = o2->op_next;

	    break;
	}
	

@


1.1.1.9
log
@perl 5.8.6 from CPAN
@
text
@a18 56
/* This file contains the functions that create, manipulate and optimize
 * the OP structures that hold a compiled perl program.
 *
 * A Perl program is compiled into a tree of OPs. Each op contains
 * structural pointers (eg to its siblings and the next op in the
 * execution sequence), a pointer to the function that would execute the
 * op, plus any data specific to that op. For example, an OP_CONST op
 * points to the pp_const() function and to an SV containing the constant
 * value. When pp_const() is executed, its job is to push that SV onto the
 * stack.
 *
 * OPs are mainly created by the newFOO() functions, which are mainly
 * called from the parser (in perly.y) as the code is parsed. For example
 * the Perl code $a + $b * $c would cause the equivalent of the following
 * to be called (oversimplifying a bit):
 *
 *  newBINOP(OP_ADD, flags,
 *	newSVREF($a),
 *	newBINOP(OP_MULTIPLY, flags, newSVREF($b), newSVREF($c))
 *  )
 *
 * Note that during the build of miniperl, a temporary copy of this file
 * is made, called opmini.c.
 */

/*
Perl's compiler is essentially a 3-pass compiler with interleaved phases:

    A bottom-up pass
    A top-down pass
    An execution-order pass

The bottom-up pass is represented by all the "newOP" routines and
the ck_ routines.  The bottom-upness is actually driven by yacc.
So at the point that a ck_ routine fires, we have no idea what the
context is, either upward in the syntax tree, or either forward or
backward in the execution order.  (The bottom-up parser builds that
part of the execution order it knows about, but if you follow the "next"
links around, you'll find it's actually a closed loop through the
top level node.

Whenever the bottom-up parser gets to a node that supplies context to
its components, it invokes that portion of the top-down pass that applies
to that part of the subtree (and marks the top node as processed, so
if a node further up supplies context, it doesn't have to take the
plunge again).  As a particular subcase of this, as the new node is
built, it takes all the closed execution loops of its subcomponents
and links them into a new closed loop for the higher level node.  But
it's still not the real execution order.

The actual execution order is not known till we get a grammar reduction
to a top-level unit like a subroutine or file that will be called by
"name" rather than via a "next" pointer.  At that point, we can call
into peep() to do that code's portion of the 3rd pass.  It has to be
recursive, but it's recursive on basic blocks, not on tree nodes.
*/
d4802 1
a4802 2
/* Check routines. See the comments at the top of this file for details
 * on when these are called */
d5968 1
a5968 1
    int descending;
d5997 1
a5997 1
	descending = 0;
d5999 1
a5999 1
	descending = 1;
a6001 1

d6011 1
a6011 1
	|| ( descending
d6016 2
a6017 2
    if (descending)
	o->op_private |= OPpSORT_DESCEND;
d6357 1
a6357 3
/* A peephole optimizer.  We visit the ops in the order they're to execute.
 * See the comments at the top of this file for more details about when
 * peep() is called */
d6725 2
d6731 2
a6736 24

	    /* reverse sort ... can be optimised.  */
	    if (!cUNOPo->op_sibling) {
		/* Nothing follows us on the list. */
		OP *reverse = o->op_next;

		if (reverse->op_type == OP_REVERSE &&
		    (reverse->op_flags & OPf_WANT) == OPf_WANT_LIST) {
		    OP *pushmark = cUNOPx(reverse)->op_first;
		    if (pushmark && (pushmark->op_type == OP_PUSHMARK)
			&& (cUNOPx(pushmark)->op_sibling == o)) {
			/* reverse -> pushmark -> sort */
			o->op_private |= OPpSORT_REVERSE;
			op_null(reverse);
			pushmark->op_next = oright->op_next;
			op_null(oright);
		    }
		}
	    }

	    /* make @@a = sort @@a act in-place */

	    o->op_seq = PL_op_seqmax++;

d6822 1
a6823 5
	case OP_REVERSE: {
	    OP *ourmark, *theirmark, *ourlast, *iter, *expushmark, *rv2av;
	    OP *gvop = NULL;
	    LISTOP *enter, *exlist;
	    o->op_seq = PL_op_seqmax++;
a6824 84
	    enter = (LISTOP *) o->op_next;
	    if (!enter)
		break;
	    if (enter->op_type == OP_NULL) {
		enter = (LISTOP *) enter->op_next;
		if (!enter)
		    break;
	    }
	    /* for $a (...) will have OP_GV then OP_RV2GV here.
	       for (...) just has an OP_GV.  */
	    if (enter->op_type == OP_GV) {
		gvop = (OP *) enter;
		enter = (LISTOP *) enter->op_next;
		if (!enter)
		    break;
		if (enter->op_type == OP_RV2GV) {
		  enter = (LISTOP *) enter->op_next;
		  if (!enter)
		    break;
		}
	    }

	    if (enter->op_type != OP_ENTERITER)
		break;

	    iter = enter->op_next;
	    if (!iter || iter->op_type != OP_ITER)
		break;
	    
	    expushmark = enter->op_first;
	    if (!expushmark || expushmark->op_type != OP_NULL
		|| expushmark->op_targ != OP_PUSHMARK)
		break;

	    exlist = (LISTOP *) expushmark->op_sibling;
	    if (!exlist || exlist->op_type != OP_NULL
		|| exlist->op_targ != OP_LIST)
		break;

	    if (exlist->op_last != o) {
		/* Mmm. Was expecting to point back to this op.  */
		break;
	    }
	    theirmark = exlist->op_first;
	    if (!theirmark || theirmark->op_type != OP_PUSHMARK)
		break;

	    if (theirmark->op_sibling != o) {
		/* There's something between the mark and the reverse, eg
		   for (1, reverse (...))
		   so no go.  */
		break;
	    }

	    ourmark = ((LISTOP *)o)->op_first;
	    if (!ourmark || ourmark->op_type != OP_PUSHMARK)
		break;

	    ourlast = ((LISTOP *)o)->op_last;
	    if (!ourlast || ourlast->op_next != o)
		break;

	    rv2av = ourmark->op_sibling;
	    if (rv2av && rv2av->op_type == OP_RV2AV && rv2av->op_sibling == 0
		&& rv2av->op_flags == (OPf_WANT_LIST | OPf_KIDS)
		&& enter->op_flags == (OPf_WANT_LIST | OPf_KIDS)) {
		/* We're just reversing a single array.  */
		rv2av->op_flags = OPf_WANT_SCALAR | OPf_KIDS | OPf_REF;
		enter->op_flags |= OPf_STACKED;
	    }

	    /* We don't have control over who points to theirmark, so sacrifice
	       ours.  */
	    theirmark->op_next = ourmark->op_next;
	    theirmark->op_flags = ourmark->op_flags;
	    ourlast->op_next = gvop ? gvop : (OP *) enter;
	    op_null(ourmark);
	    op_null(o);
	    enter->op_private |= OPpITER_REVERSED;
	    iter->op_private |= OPpITER_REVERSED;
	    
	    break;
	}
	
@


1.1.1.10
log
@perl 5.8.8 import
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, by Larry Wall and others
d131 2
a132 2
    I32 * const * const ptr = (I32 **) op;
    I32 * const slab = ptr[-1];
d161 1
a161 1
STATIC const char*
d164 2
a165 1
    SV* const tmpsv = sv_newmortal();
d167 1
a167 1
    return SvPV_nolen_const(tmpsv);
d179 1
a179 1
S_too_few_arguments(pTHX_ OP *o, const char *name)
d186 1
a186 1
S_too_many_arguments(pTHX_ OP *o, const char *name)
d193 1
a193 1
S_bad_type(pTHX_ I32 n, const char *t, const char *name, const OP *kid)
d196 1
a196 1
		 (int)n, name, t, OP_DESC((OP *)kid)));
d200 1
a200 1
S_no_bareword_allowed(pTHX_ const OP *o)
d339 1
a340 1
    PADOFFSET refcnt;
d354 4
a357 1
	    refcnt = OpREFCNT_dec(o);
a358 2
	    if (refcnt)
		return;
a365 1
        register OP *kid, *nextkid;
d477 1
a477 1
	    HV * const pmstash = PmopSTASH(cPMOPo);
a552 12
void
Perl_op_refcnt_lock(pTHX)
{
    OP_REFCNT_LOCK;
}

void
Perl_op_refcnt_unlock(pTHX)
{
    OP_REFCNT_UNLOCK;
}

d560 1
a566 1
        register OP *kid;
d584 1
a585 1
        OP *kid;
d597 1
a597 1
	    const line_t oldline = CopLINE(PL_curcop);
d614 1
a614 1
    if (!o || PL_error_count || (o->op_flags & OPf_WANT)
d682 1
a682 1
    const char* useless = 0;
d828 3
a830 3
		    if (strnEQ(SvPVX_const(sv), "di", 2) ||
			strnEQ(SvPVX_const(sv), "ds", 2) ||
			strnEQ(SvPVX_const(sv), "ig", 2))
a847 10
    case OP_I_POSTINC:
	o->op_type = OP_I_PREINC;	/* pre-increment is faster */
	o->op_ppaddr = PL_ppaddr[OP_I_PREINC];
	break;

    case OP_I_POSTDEC:
	o->op_type = OP_I_PREDEC;	/* pre-decrement is faster */
	o->op_ppaddr = PL_ppaddr[OP_I_PREDEC];
	break;

d899 1
a900 1
        OP *kid;
d985 2
a992 1
            OP *kid;
d1012 1
a1013 1
        OP *kid;
d1349 1
a1349 1
S_scalar_mod_type(pTHX_ const OP *o, I32 type)
d1396 1
a1396 1
S_is_handle_constructor(pTHX_ const OP *o, I32 numargs)
d1401 1
a1401 1
	if (numargs == 2)
d1410 1
a1410 1
	if (numargs == 1)
d1421 1
a1422 1
        OP *kid;
d1550 1
a1550 1
	stashsv = newSVpv(HvNAME_get(stash), 0);
d1558 1
d1560 1
a1560 1
	SV * const * const svp = hv_fetch(GvHVn(PL_incgv), ATTRSMODULE_PM,
d1604 1
a1604 1
	stashsv = newSVpv(HvNAME_get(stash), 0);
d1620 1
a1620 5
    {
	U32 hash;
	PERL_HASH(hash, SvPVX_const(meth), SvCUR(meth));
	SvUV_set(meth, hash);
    }
d1661 1
a1661 1
            const char * const sstr = attrstr;
d1682 1
a1689 1
        OP *kid;
d1701 1
a1701 1
	    GV * const gv = cGVOPx_gv(cUNOPo->op_first);
d1791 2
a1792 1
    if ( (left->op_type == OP_RV2AV ||
d1795 2
a1796 4
       left->op_type == OP_PADHV)
       && ckWARN(WARN_MISC))
    {
      const char * const desc = PL_op_desc[(right->op_type == OP_SUBST ||
d1799 1
a1799 1
      const char * const sample = ((left->op_type == OP_RV2AV ||
d1859 1
a1859 1
	    if (kid->op_type == OP_NEXTSTATE || kid->op_type == OP_DBSTATE) {
a1860 7

		/* The following deals with things like 'do {1 for 1}' */
		kid = kid->op_sibling;
		if (kid &&
		    (kid->op_type == OP_NEXTSTATE || kid->op_type == OP_DBSTATE))
		    op_null(kid);
	    }
d1878 1
a1878 1
    const int retval = PL_savestack_ix;
d1901 2
a1902 2
    const int needblockscope = PL_hints & HINT_BLOCK_SCOPE;
    OP* const retval = scalarseq(seq);
d1917 1
a1917 1
    OP *const o = newOP(OP_THREADSV, 0);
d1958 1
a1958 1
	    CV * const cv = get_cv("DB::postponed", FALSE);
d1982 2
a1983 2
	if ( PL_bufptr > PL_oldbufptr && PL_bufptr[-1] == ','
	    && ckWARN(WARN_PARENTHESIS))
d2067 1
d2121 1
a2121 1
    const I32 oldtmps_floor = PL_tmps_floor;
d2164 1
a2164 1
    if (o->op_type != (unsigned)type)
d2181 1
a2181 1
    if (first->op_type != (unsigned)type
d2206 1
a2206 1
    if (first->op_type != (unsigned)type)
d2209 1
a2209 1
    if (last->op_type != (unsigned)type)
d2230 1
a2230 1
    if (last->op_type == (unsigned)type) {
d2291 2
a2292 1
	OP* const pushop = newOP(OP_PUSHMARK, 0);
d2335 1
a2335 1
    unop->op_flags = (U8)(flags | OPf_KIDS);
d2356 1
a2356 1
    binop->op_flags = (U8)(flags | OPf_KIDS);
d2375 2
a2376 2
static int uvcompare(const void *a, const void *b) __attribute__nonnull__(1) __attribute__nonnull__(2) __attribute__pure__;
static int uvcompare(const void *a, const void *b)
d2378 1
a2378 1
    if (*((const UV *)a) < (*(const UV *)b))
d2380 1
a2380 1
    if (*((const UV *)a) > (*(const UV *)b))
d2382 1
a2382 1
    if (*((const UV *)a+1) < (*(const UV *)b+1))
d2384 1
a2384 1
    if (*((const UV *)a+1) > (*(const UV *)b+1))
d2392 2
a2393 2
    SV * const tstr = ((SVOP*)expr)->op_sv;
    SV * const rstr = ((SVOP*)repl)->op_sv;
d2396 2
a2397 2
    const U8 *t = (U8*)SvPV_const(tstr, tlen);
    const U8 *r = (U8*)SvPV_const(rstr, rlen);
d2400 3
a2405 3
    const I32 complement = o->op_private & OPpTRANS_COMPLEMENT;
    const I32 squash     = o->op_private & OPpTRANS_SQUASH;
    I32 del              = o->op_private & OPpTRANS_DELETE;
d2407 3
d2418 1
a2418 1
	SV* const listsv = newSVpvn("# comment\n",10);
d2420 2
a2421 2
	const U8* tend = t + tlen;
	const U8* rend = r + rlen;
d2435 2
a2436 2
	const I32 from_utf  = o->op_private & OPpTRANS_FROM_UTF;
	const I32 to_utf    = o->op_private & OPpTRANS_TO_UTF;
d2442 1
a2442 1
	    t = tsave = bytes_to_utf8((U8 *)t, &len);
d2447 1
a2447 1
	    r = rsave = bytes_to_utf8((U8 *)r, &len);
d2458 1
a2458 1
	    U8 tmpbuf[UTF8_MAXBYTES+1];
d2461 1
a2461 1
	    Newx(cp, 2*tlen, UV);
d2465 1
a2465 1
		cp[2*i] = utf8n_to_uvuni((U8 *)t, tend-t, &ulen, 0);
d2469 1
a2469 1
		    cp[2*i+1] = utf8n_to_uvuni((U8 *)t, tend-t, &ulen, 0);
d2504 1
a2504 1
	    t = (const U8*)SvPVX_const(transv);
d2523 1
a2523 1
		tfirst = (I32)utf8n_to_uvuni((U8 *)t, tend - t, &ulen, 0);
d2527 1
a2527 1
		    tlast = (I32)utf8n_to_uvuni((U8 *)t, tend - t, &ulen, 0);
d2537 1
a2537 1
		    rfirst = (I32)utf8n_to_uvuni((U8 *)r, rend - r, &ulen, 0);
d2541 1
a2541 2
			rlast = (I32)utf8n_to_uvuni((U8 *)r, rend - r, &ulen,
						    0);
d2656 1
a2656 1
	    tbl[0x100] = (short)(rlen - j);
d2714 13
a2726 10
    if (av_len((AV*) PL_regex_pad[0]) > -1) {
	SV * const repointer = av_pop((AV*)PL_regex_pad[0]);
	pmop->op_pmoffset = SvIV(repointer);
	SvREPADTMP_off(repointer);
	sv_setiv(repointer,0);
    } else {
	SV * const repointer = newSViv(0);
	av_push(PL_regex_padav,SvREFCNT_inc(repointer));
	pmop->op_pmoffset = av_len(PL_regex_padav);
	PL_regex_pad = AvARRAY(PL_regex_padav);
d2756 2
a2757 14
	const char *p = SvPV_const(pat, plen);
	if ((o->op_flags & OPf_SPECIAL) && (*p == ' ' && p[1] == '\0')) {
	    U32 was_readonly = SvREADONLY(pat);

	    if (was_readonly) {
		if (SvFAKE(pat)) {
		    sv_force_normal_flags(pat, 0);
		    assert(!SvREADONLY(pat));
		    was_readonly = 0;
		} else {
		    SvREADONLY_off(pat);
		}
	    }   

d2759 1
a2759 4

	    SvFLAGS(pat) |= was_readonly;

	    p = SvPV_const(pat, plen);
d2764 1
a2764 2
	/* FIXME - can we make this function take const char * args?  */
	PM_SETRE(pm, CALLREGCOMP(aTHX_ (char*)p, (char*)p + plen, pm));
d2967 1
a2967 1
	const char *name;
d2969 1
a2969 1
	name = SvPV_const(sv, len);
d2996 2
a2997 2
    if (version) {
	SV * const vesv = ((SVOP*)version)->op_sv;
d2999 1
a2999 1
	if (!arg && !SvNIOKp(vesv)) {
d3016 1
a3016 5
	    {
		U32 hash;
		PERL_HASH(hash, SvPVX_const(meth), SvCUR(meth));
		SvUV_set(meth, hash);
	    }
d3040 1
a3040 5
	{
	    U32 hash;
	    PERL_HASH(hash, SvPVX_const(meth), SvCUR(meth));
	    SvUV_set(meth, hash);
	}
d3121 1
a3121 1
    OP *veop, *imop;
d3123 1
a3123 1
    OP * const modname = newSVOP(OP_CONST, 0, name);
d3146 3
a3148 3
	const line_t ocopline = PL_copline;
	COP * const ocurcop = PL_curcop;
	const int oexpect = PL_expect;
d3190 1
a3190 1
S_is_list_assignment(pTHX_ register const OP *o)
d3199 2
a3200 2
        const I32 t = is_list_assignment(cLOGOPo->op_first->op_sibling);
        const I32 f = is_list_assignment(cLOGOPo->op_first->op_sibling->op_sibling);
d3245 1
a3245 1
    if (is_list_assignment(left)) {
d3249 1
a3249 3
	/* Grandfathering $[ assignment here.  Bletch.*/
	/* Only simple assignments like C<< ($[) = 1 >> are allowed */
	PL_eval_start = (left->op_type == OP_CONST) ? right : 0;
d3253 13
a3265 3
	else if (left->op_type == OP_CONST) {
	    /* Result of assignment is always 1 (or we'd be dead already) */
	    return newSVOP(OP_CONST, 0, newSViv(1));
d3303 1
a3303 1
			SvCUR_set(gv, PL_generation);
d3313 2
a3314 1
			PAD_COMPNAME_GEN_set(curop->op_targ, PL_generation);
d3336 1
a3336 1
			    SvCUR_set(gv, PL_generation);
d3352 1
a3352 1
		PMOP * const pm = (PMOP*)tmpop;
d3403 2
a3404 1
	    o = newSVOP(OP_CONST, 0, newSViv(PL_compiling.cop_arybase));
d3413 1
a3413 1
    const U32 seq = intro_my();
d3463 4
a3466 4
	SV * const * const svp = av_fetch(CopFILEAV(PL_curcop), (I32)CopLINE(cop), FALSE);
	if (svp && *svp != &PL_sv_undef ) {
	    (void)SvIOK_on(*svp);
	    SvIV_set(*svp, PTR2IV(cop));
d3486 1
a3486 1
    OP * const other = *otherp;
d3510 1
a3510 1
	else if ((first->op_private & OPpCONST_BARE) && ckWARN(WARN_BAREWORD))
d3527 3
a3529 3
    else if ((first->op_flags & OPf_KIDS) && ckWARN(WARN_MISC)) {
	const OP * const k1 = ((UNOP*)first)->op_first;
	const OP * const k2 = k1->op_sibling;
d3554 1
a3554 1
	    const line_t oldline = CopLINE(PL_curcop);
d3576 1
a3576 1
    logop->op_flags = (U8)(flags | OPf_KIDS);
d3608 3
a3610 3
	    first->op_private & OPpCONST_STRICT) {
	    no_bareword_allowed(first);
	}
d3626 1
a3626 1
    logop->op_flags = (U8)(flags | OPf_KIDS);
d3699 1
a3699 1
    const bool once = block && block->op_flags & OPf_SPECIAL &&
a3701 2
    PERL_UNUSED_ARG(debuggable);

d3710 2
a3711 2
	    const OP * const k1 = ((UNOP*)expr)->op_first;
	    const OP * const k2 = k1 ? k1->op_sibling : NULL;
d3762 14
a3775 1
    PERL_UNUSED_ARG(debuggable);
d3777 7
a3783 24
    if (expr) {
	if (expr->op_type == OP_READLINE || expr->op_type == OP_GLOB
		     || (expr->op_type == OP_NULL && expr->op_targ == OP_GLOB)) {
	    expr = newUNOP(OP_DEFINED, 0,
		newASSIGNOP(0, newDEFSVOP(), 0, expr) );
	} else if (expr->op_flags & OPf_KIDS) {
	    const OP * const k1 = ((UNOP*)expr)->op_first;
	    const OP * const k2 = (k1) ? k1->op_sibling : NULL;
	    switch (expr->op_type) {
	      case OP_NULL:
		if (k2 && k2->op_type == OP_READLINE
		      && (k2->op_flags & OPf_STACKED)
		      && ((k1->op_flags & OPf_WANT) == OPf_WANT_SCALAR))
		    expr = newUNOP(OP_DEFINED, 0, expr);
		break;

	      case OP_SASSIGN:
		if (k1->op_type == OP_READDIR
		      || k1->op_type == OP_GLOB
		      || (k1->op_type == OP_NULL && k1->op_targ == OP_GLOB)
		      || k1->op_type == OP_EACH)
		    expr = newUNOP(OP_DEFINED, 0, expr);
		break;
	    }
d3797 1
a3797 1
	OP * const unstack = newOP(OP_UNSTACK, 0);
d3847 1
a3847 1
Perl_newFOROP(pTHX_ I32 flags, char *label, line_t forline, OP *sv, OP *expr, OP *block, OP *cont)
d3898 4
a3901 4
	UNOP* const flip = (UNOP*)((UNOP*)((BINOP*)expr)->op_first)->op_first;
	LOGOP* const range = (LOGOP*) flip->op_first;
	OP* const left  = range->op_first;
	OP* const right = left->op_sibling;
d3922 1
d3933 1
a3933 1
	Copy(loop,tmp,1,LISTOP);
d3950 1
d3958 1
a3958 1
					? SvPVx_nolen_const(((SVOP*)label)->op_sv)
a4017 1
	CvSTART(cv) = Nullop;
d4045 2
a4046 2
    if (((!p != !SvPOK(cv)) || (p && strNE(p, SvPVX_const(cv)))) && ckWARN_d(WARN_PROTOTYPE)) {
	SV* const msg = sv_newmortal();
d4055 1
a4055 1
	    Perl_sv_catpvf(aTHX_ msg, " (%"SVf")", (const SV *)cv);
d4057 1
a4057 1
	    Perl_sv_catpv(aTHX_ msg, ": none");
d4103 1
a4103 1
	const OPCODE type = o->op_type;
a4144 2
    PERL_UNUSED_ARG(floor);

d4165 3
a4167 1
    const char *aname;
d4169 1
a4169 2
    const char *ps;
    STRLEN ps_len;
a4171 1
    I32 gv_fetch_flags;
d4173 1
a4173 1
    const char * const name = o ? SvPVx_nolen_const(cSVOPo->op_sv) : Nullch;
d4177 1
a4177 1
	ps = SvPVx_const(((SVOP*)proto)->op_sv, ps_len);
d4183 1
a4183 1
	SV * const sv = sv_newmortal();
d4187 1
a4187 1
	aname = SvPVX_const(sv);
a4190 4

    /* There may be future conflict here as change 23766 is not yet merged.  */
    gv_fetch_flags = (block || attrs || (CvFLAGS(PL_compcv) & CVf_BUILTIN_ATTRS))
	? GV_ADDMULTI : GV_ADDMULTI | GV_NOINIT;
d4193 2
a4194 1
		    gv_fetch_flags, SVt_PVCV);
d4211 1
a4211 1
	    cv_ckproto((CV*)gv, NULL, (char *)ps);
d4214 1
a4214 1
	    sv_setpvn((SV*)gv, ps, ps_len);
d4231 1
a4231 1
    if (!block || !ps || *ps || attrs || (CvFLAGS(PL_compcv) & CVf_BUILTIN_ATTRS))
d4237 1
a4237 1
        const bool exists = CvROOT(cv) || CvXSUB(cv);
d4250 1
a4250 1
	    cv_ckproto(cv, gv, (char *)ps);
d4270 1
a4270 1
		    const line_t oldline = CopLINE(PL_curcop);
d4284 1
a4284 1
	(void)SvREFCNT_inc(const_sv);
d4287 1
a4287 1
	    sv_setpvn((SV*)cv, "", 0);  /* prototype is "" */
d4294 1
a4294 1
	    cv = newCONSTSUB(NULL, (char *)name, const_sv);
d4373 1
a4373 1
	sv_setpvn((SV*)cv, ps, ps_len);
d4379 1
a4379 1
	    const char *s = strrchr(name, ':');
d4382 1
a4382 1
		const char not_safe[] =
d4426 2
a4427 2
	const char *s;
	const char *tname = (name ? name : aname);
d4433 1
d4440 1
a4440 1
	    hv_store(GvHV(PL_DBsub), SvPVX_const(tmpstr), SvCUR(tmpstr), sv, 0);
d4442 8
a4449 9
	    if (HvFILL(hv) > 0 && hv_exists(hv, SvPVX_const(tmpstr), SvCUR(tmpstr))) {
		CV * const pcv = GvCV(db_postponed);
		if (pcv) {
		    dSP;
		    PUSHMARK(SP);
		    XPUSHs(tmpstr);
		    PUTBACK;
		    call_sv((SV*)pcv, G_DISCARD);
		}
d4462 1
a4462 1
	    const I32 oldscope = PL_scopestack_ix;
d4546 1
a4546 1
    sv_setpvn((SV*)cv, "", 0);  /* prototype is "" */
d4567 1
a4567 1
    GV * const gv = gv_fetchpv(name ? name :
d4576 1
a4576 1
	    cv = Nullcv;
d4580 10
a4589 19
	    /* XXX It's possible for this HvNAME_get to return null, and get passed into strEQ */
	    if (ckWARN(WARN_REDEFINE)) {
		GV * const gvcv = CvGV(cv);
		if (gvcv) {
		    HV * const stash = GvSTASH(gvcv);
		    if (stash) {
			const char *name = HvNAME_get(stash);
			if ( strEQ(name,"autouse") ) {
			    const line_t oldline = CopLINE(PL_curcop);
			    if (PL_copline != NOLINE)
				CopLINE_set(PL_curcop, PL_copline);
			    Perl_warner(aTHX_ packWARN(WARN_REDEFINE),
					CvCONST(cv) ? "Constant subroutine %s redefined"
						    : "Subroutine %s redefined"
					,name);
			    CopLINE_set(PL_curcop, oldline);
			}
		    }
		}
d4592 1
a4592 1
	    cv = Nullcv;
d4614 1
a4614 1
    CvFILE(cv) = (char *)filename; /* NOTE: not copied, as it is expected to be
d4619 1
a4619 1
	const char *s = strrchr(name,':');
d4687 1
a4687 1
	    const line_t oldline = CopLINE(PL_curcop);
d4834 1
a4834 2
    PERL_UNUSED_ARG(o);
    NORETURN_FUNCTION_END;
d4886 2
a4887 2
	const OP * const left = cBINOPo->op_first;
	const OP * const right = left->op_sibling;
d4905 1
a4905 1
    const OP *kid = cUNOPo->op_first;
d4918 1
a4918 1
	const OPCODE type = o->op_type;
d4943 1
a4943 1
	OP * const kid = cUNOPo->op_first;
d4977 1
a4977 1
    const I32 type = o->op_type;
d4994 1
a4994 1
	SVOP * const kid = (SVOP*)cUNOPo->op_first;
d5035 1
a5035 1
    HV * const table = GvHV(PL_hintgv);
d5037 1
a5037 1
       SV * const * const svp = hv_fetch(table, "vmsish_exit", 11, FALSE);
d5049 1
a5050 1
        OP *kid;
d5066 1
a5066 1
	OP * const kid = cUNOPo->op_first;
d5084 11
d5105 1
a5105 1
	SV * const kidsv = kid->op_sv;
d5111 2
a5112 2
	    const int svtype = SvTYPE(rsv);
            const char *badtype = Nullch;
d5147 1
a5147 1
            const char *badthing = Nullch;
d5208 1
a5208 1
    const I32 type = o->op_type;
d5214 1
a5214 1
	SVOP * const kid = (SVOP*)cUNOPo->op_first;
d5218 1
a5218 1
	    OP * const newop = newGVOP(type, OPf_REF,
d5242 5
a5246 1
    const int type = o->op_type;
d5258 2
a5259 5
        OP **tokid = &cLISTOPo->op_first;
        register OP *kid = cLISTOPo->op_first;
        OP *sibl;
        I32 numargs = 0;

d5301 1
a5301 1
		    OP * const newop = newAVREF(newGVOP(OP_GV, 0,
d5321 1
a5321 1
		    OP * const newop = newHVREF(newGVOP(OP_GV, 0,
d5338 1
a5338 1
		    OP * const newop = newUNOP(OP_NULL, 0, kid);
d5372 1
a5372 1
                            const char *name = Nullch;
d5404 2
a5405 1
				 OP *op = ((BINOP*)kid)->op_first;
d5407 1
a5407 1
				 if (op) {
d5409 1
a5409 1
				      const char * const a =
d5417 1
a5417 1
					   GV * const gv = cGVOPx_gv(op);
d5428 1
a5428 1
					   const char * const padname =
d5436 1
d5439 1
a5439 1
					   name = SvPV_const(tmpstr, len);
d5521 1
a5521 1
	(void)SvREFCNT_inc((SV*)GvCV(gv));
d5555 1
a5555 1
    const OPCODE type = o->op_type == OP_GREPSTART ? OP_GREPWHILE : OP_MAPWHILE;
a5563 2
	if (!cUNOPx(kid)->op_next)
	    Perl_croak(aTHX_ "panic: ck_grep");
d5624 1
a5624 1
    const OPCODE type = o->op_type;
d5669 1
a5669 1
    const OPCODE type = o->op_type;
d5713 1
a5713 1
	OP * const kkid = kid->op_sibling;
d5730 13
d5756 1
a5756 1
    OP * const kid = cUNOPo->op_first;
d5759 1
a5759 1
	if (!(strchr(SvPVX_const(sv), ':') || strchr(SvPVX_const(sv), '\''))) {
d5762 1
a5762 1
		sv = newSVpvn_share(SvPVX_const(sv), SvCUR(sv), 0);
d5784 1
a5784 1
    HV * const table = GvHV(PL_hintgv);
d5786 3
a5788 1
	SV **svp = hv_fetch(table, "open_IN", 7, FALSE);
d5790 1
a5790 1
	    const I32 mode = mode_from_discipline(*svp);
d5799 1
a5799 1
	    const I32 mode = mode_from_discipline(*svp);
d5811 2
a5812 2
	 OP * const first = cLISTOPx(o)->op_first; /* The pushmark. */
	 OP * const last  = cLISTOPx(o)->op_last;  /* The bareword. */
d5814 1
a5814 1
	 const char *mode;
a5820 1
	     (oa->op_type == OP_CONST) &&
d5822 1
a5822 1
	     (mode = SvPVX_const(((SVOP*)oa)->op_sv)) &&
d5848 1
a5848 1
	SVOP * const kid = (SVOP*)cUNOPo->op_first;
a5850 2
	    SV * const sv = kid->op_sv;
	    U32 was_readonly = SvREADONLY(sv);
d5852 1
a5852 12

	    if (was_readonly) {
		if (SvFAKE(sv)) {
		    sv_force_normal_flags(sv, 0);
		    assert(!SvREADONLY(sv));
		    was_readonly = 0;
		} else {
		    SvREADONLY_off(sv);
		}
	    }   

	    for (s = SvPVX(sv); *s; s++) {
d5856 1
a5856 1
		    SvCUR_set(sv, SvCUR(sv) - 1);
d5859 7
a5865 2
	    sv_catpvn(sv, ".pm", 3);
	    SvFLAGS(sv) |= was_readonly;
d5875 1
a5875 1
	OP * const kid = cUNOPo->op_first;
d5891 1
a5892 1
        OP *kid;
d5932 1
a5932 1
    const I32 type = o->op_type;
a6026 1
    const char *gvname;
d6053 1
a6053 2
    gvname = GvNAME(gv);
    if (*gvname == 'a' && gvname[1] == '\0')
d6055 1
a6055 1
    else if (*gvname == 'b' && gvname[1] == '\0')
d6068 4
a6071 6
    if (GvSTASH(gv) != PL_curstash)
	return;
    gvname = GvNAME(gv);
    if ( descending
	 ? !(*gvname == 'a' && gvname[1] == '\0')
	 : !(*gvname == 'b' && gvname[1] == '\0'))
d6105 1
a6105 1
	OP * const sibl = kid->op_sibling;
d6117 1
a6117 1
    if (((PMOP *)kid)->op_pmflags & PMf_GLOBAL && ckWARN(WARN_REGEXP)) {
d6143 6
a6148 5
    const OP * const kid = cLISTOPo->op_first->op_sibling;
    if (kid && kid->op_type == OP_MATCH) {
	if (ckWARN(WARN_SYNTAX)) {
            const REGEXP *re = PM_GETRE(kPMOP);
	    const char *pmstr = re ? re->precomp : "STRING";
d6171 1
d6187 1
a6187 1
		proto = SvPV_nolen((SV*)cv);
d6195 1
a6195 1
	    OP * const o = ((UNOP*)o2)->op_first->op_sibling;
d6251 3
a6253 3
				GV * const gv = cGVOPx_gv(gvop);
				OP * const sibling = o2->op_sibling;
				SV * const n = newSVpvn("",0);
d6255 3
a6257 1
				gv_fullname4(n, gv, "", FALSE);
d6287 2
a6288 2
		         char *p = proto;
			 const char s = *p;
d6336 2
a6337 2
			OP* const kid = o2;
			OP* const sib = kid->op_sibling;
d6367 1
a6367 1
    } /* while */
d6455 1
a6455 1
		const PADOFFSET ix = pad_alloc(OP_CONST, SVs_PADTMP);
d6576 2
a6577 2
		GV * const gv = cGVOPo_gv;
		if (SvTYPE(gv) == SVt_PVGV && GvCV(gv) && SvPVX_const(GvCV(gv))) {
d6579 1
a6579 1
		    SV * const sv = sv_newmortal();
d6641 2
a6642 3
	    if (o->op_next && o->op_next->op_type == OP_NEXTSTATE
		&& ckWARN(WARN_SYNTAX))
	    {
d6647 1
a6647 1
		    const line_t oldline = CopLINE(PL_curcop);
d6665 1
a6665 1
	    const char *key = NULL;
d6676 1
a6676 1
		key = SvPV_const(sv, keylen);
d6696 1
a6696 1
	    key = SvPV_const(*svp, keylen);
d6700 2
a6701 4
		Perl_croak(aTHX_ "No such pseudo-hash field \"%s\" "
			   "in variable %s of type %s",
		      key, SvPV_nolen_const(lexname),
		      HvNAME_get(SvSTASH(lexname)));
d6726 1
a6726 1
	    const char *key;
d6762 1
a6762 1
		key = SvPV_const(*svp, keylen);
d6768 1
a6768 1
			  key, SvPV(lexname, n_a), HvNAME_get(SvSTASH(lexname)));
d6786 1
a6786 1
	    OP *oleft;
d6790 1
a6790 1
	    OP *oright = cUNOPo->op_first;
d6797 1
a6797 1
		OP * const reverse = o->op_next;
d6801 1
a6801 1
		    OP * const pushmark = cUNOPx(reverse)->op_first;
d7002 3
a7004 2
char*
Perl_custom_op_name(pTHX_ OP* o)
d7006 1
a7006 1
    const IV index = PTR2IV(o->op_ppaddr);
d7011 1
a7011 1
        return (char *)PL_op_name[OP_CUSTOM];
d7017 1
a7017 1
        return (char *)PL_op_name[OP_CUSTOM]; /* Don't know who you are */
d7022 1
a7022 2
char*
Perl_custom_op_desc(pTHX_ OP* o)
d7024 1
a7024 1
    const IV index = PTR2IV(o->op_ppaddr);
d7029 1
a7029 1
        return (char *)PL_op_desc[OP_CUSTOM];
d7035 1
a7035 1
        return (char *)PL_op_desc[OP_CUSTOM];
d7040 1
d7051 1
a7051 1
                   HvNAME_get(GvSTASH(CvGV(cv))), GvNAME(CvGV(cv)));
a7057 10

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
@


1.1.1.11
log
@import perl 5.10.0 from CPAN
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
a75 22
/* To implement user lexical pragmas, there needs to be a way at run time to
   get the compile time state of %^H for that block.  Storing %^H in every
   block (or even COP) would be very expensive, so a different approach is
   taken.  The (running) state of %^H is serialised into a tree of HE-like
   structs.  Stores into %^H are chained onto the current leaf as a struct
   refcounted_he * with the key and the value.  Deletes from %^H are saved
   with a value of PL_sv_placeholder.  The state of %^H at any point can be
   turned back into a regular HV by walking back up the tree from that point's
   leaf, ignoring any key you've already seen (placeholder or not), storing
   the rest into the HV structure, then removing the placeholders. Hence
   memory is only used to store the %^H deltas from the enclosing COP, rather
   than the entire %^H on each COP.

   To cause actions on %^H to write out the serialisation records, it has
   magic type 'H'. This magic (itself) does nothing, but its presence causes
   the values to gain magic type 'h', which has entries for set and clear.
   C<Perl_magic_sethint> updates C<PL_compiling.cop_hints_hash> with a store
   record, with deletes written by C<Perl_magic_clearhint>. C<SAVE_HINTS>
   saves the current C<PL_compiling.cop_hints_hash> on the save stack, so that
   it will be correctly restored when any inner compiling scope is exited.
*/

a84 5
#ifdef PERL_DEBUG_READONLY_OPS
#  define PERL_SLAB_SIZE 4096
#  include <sys/mman.h>
#endif

d90 1
a90 1
Perl_Slab_Alloc(pTHX_ size_t sz)
d100 1
a100 17
#ifdef PERL_DEBUG_READONLY_OPS
	/* We need to allocate chunk by chunk so that we can control the VM
	   mapping */
	PL_OpPtr = mmap(0, PERL_SLAB_SIZE*sizeof(I32*), PROT_READ|PROT_WRITE,
			MAP_ANON|MAP_PRIVATE, -1, 0);

	DEBUG_m(PerlIO_printf(Perl_debug_log, "mapped %lu at %p\n",
			      (unsigned long) PERL_SLAB_SIZE*sizeof(I32*),
			      PL_OpPtr));
	if(PL_OpPtr == MAP_FAILED) {
	    perror("mmap failed");
	    abort();
	}
#else

        PL_OpPtr = (I32 **) PerlMemShared_calloc(PERL_SLAB_SIZE,sizeof(I32*)); 
#endif
d104 1
a115 8

#ifdef PERL_DEBUG_READONLY_OPS
	/* We remember this slab.  */
	/* This implementation isn't efficient, but it is simple. */
	PL_slabs = realloc(PL_slabs, sizeof(I32**) * (PL_slab_count + 1));
	PL_slabs[PL_slab_count++] = PL_OpSlab;
	DEBUG_m(PerlIO_printf(Perl_debug_log, "Allocate %p\n", PL_OpSlab));
#endif
a127 64
#ifdef PERL_DEBUG_READONLY_OPS
void
Perl_pending_Slabs_to_ro(pTHX) {
    /* Turn all the allocated op slabs read only.  */
    U32 count = PL_slab_count;
    I32 **const slabs = PL_slabs;

    /* Reset the array of pending OP slabs, as we're about to turn this lot
       read only. Also, do it ahead of the loop in case the warn triggers,
       and a warn handler has an eval */

    PL_slabs = NULL;
    PL_slab_count = 0;

    /* Force a new slab for any further allocation.  */
    PL_OpSpace = 0;

    while (count--) {
	void *const start = slabs[count];
	const size_t size = PERL_SLAB_SIZE* sizeof(I32*);
	if(mprotect(start, size, PROT_READ)) {
	    Perl_warn(aTHX_ "mprotect for %p %lu failed with %d",
		      start, (unsigned long) size, errno);
	}
    }

    free(slabs);
}

STATIC void
S_Slab_to_rw(pTHX_ void *op)
{
    I32 * const * const ptr = (I32 **) op;
    I32 * const slab = ptr[-1];
    assert( ptr-1 > (I32 **) slab );
    assert( ptr < ( (I32 **) slab + PERL_SLAB_SIZE) );
    assert( *slab > 0 );
    if(mprotect(slab, PERL_SLAB_SIZE*sizeof(I32*), PROT_READ|PROT_WRITE)) {
	Perl_warn(aTHX_ "mprotect RW for %p %lu failed with %d",
		  slab, (unsigned long) PERL_SLAB_SIZE*sizeof(I32*), errno);
    }
}

OP *
Perl_op_refcnt_inc(pTHX_ OP *o)
{
    if(o) {
	Slab_to_rw(o);
	++o->op_targ;
    }
    return o;

}

PADOFFSET
Perl_op_refcnt_dec(pTHX_ OP *o)
{
    Slab_to_rw(o);
    return --o->op_targ;
}
#else
#  define Slab_to_rw(op)
#endif

a135 1
    Slab_to_rw(op);
a140 24
#ifdef PERL_DEBUG_READONLY_OPS
	U32 count = PL_slab_count;
	/* Need to remove this slab from our list of slabs */
	if (count) {
	    while (count--) {
		if (PL_slabs[count] == slab) {
		    /* Found it. Move the entry at the end to overwrite it.  */
		    DEBUG_m(PerlIO_printf(Perl_debug_log,
					  "Deallocate %p by moving %p from %lu to %lu\n",
					  PL_OpSlab,
					  PL_slabs[PL_slab_count - 1],
					  PL_slab_count, count));
		    PL_slabs[count] = PL_slabs[--PL_slab_count];
		    /* Could realloc smaller at this point, but probably not
		       worth it.  */
		    if(munmap(slab, PERL_SLAB_SIZE*sizeof(I32*))) {
			perror("munmap failed");
			abort();
		    }
		    break;
		}
	    }
	}
#else
a141 1
#endif
d149 1
a149 1
 * In the following definition, the ", (OP*)0" is just to make the compiler
d153 1
a153 1
    ((PL_op_mask && PL_op_mask[type])				\
d156 1
a156 1
	 (OP*)0 )						\
d165 1
a165 1
    gv_efullname3(tmpsv, gv, NULL);
d195 1
a195 1
		 (int)n, name, t, OP_DESC(kid)));
a200 2
    if (PL_madskills)
	return;		/* various ok barewords are hidden in extra OP_NULL */
d203 1
a203 1
		     SVfARG(cSVOPo_sv)));
d209 1
a209 1
Perl_allocmy(pTHX_ const char *const name)
a210 1
    dVAR;
a211 1
    const bool is_our = (PL_parser->in_my == KEY_our);
d213 2
a214 3
    /* complain about "my $<special_var>" etc etc */
    if (*name &&
	!(is_our ||
d217 1
a217 1
	  (name[1] == '_' && (*name == '$' || name[2]))))
a218 1
	/* name[2] is true if strlen(name) > 2  */
d220 17
a236 6
	    yyerror(Perl_form(aTHX_ "Can't use global %c^%c%s in \"%s\"",
			      name[0], toCTRL(name[1]), name + 2,
			      PL_parser->in_my == KEY_state ? "state" : "my"));
	} else {
	    yyerror(Perl_form(aTHX_ "Can't use global %s in \"%s\"",name,
			      PL_parser->in_my == KEY_state ? "state" : "my"));
d238 1
a239 1

d241 4
a244 1
    pad_check_dup(name, is_our, (PL_curstash ? PL_curstash : PL_defstash));
d246 1
a246 1
    if (PL_parser->in_my_stash && *name != '$') {
d249 1
a249 3
 		     name,
 		     is_our ? "our"
			    : PL_parser->in_my == KEY_state ? "state" : "my"));
d255 4
a258 5
		    PL_parser->in_my_stash,
		    (is_our
		        /* $_ is always in main::, even with our */
			? (PL_curstash && !strEQ(name,"$_") ? PL_curstash : PL_defstash)
			: NULL
d260 1
a260 2
		    0, /*  not fake */
		    PL_parser->in_my == KEY_state
a261 6
    /* anon sub prototypes contains state vars should always be cloned,
     * otherwise the state var would be shared between anon subs */

    if (PL_parser->in_my == KEY_state && CvANON(PL_compcv))
	CvCLONE_on(PL_compcv);

a264 2
/* free the body of an op without examining its contents.
 * Always use this rather than FreeOp directly */
d266 4
a269 2
static void
S_op_destroy(pTHX_ OP *o)
d271 57
a327 3
    if (o->op_latefree) {
	o->op_latefreed = 1;
	return;
d329 1
a329 1
    FreeOp(o);
d331 1
a331 6

#ifdef USE_ITHREADS
#  define forget_pmop(a,b)	S_forget_pmop(aTHX_ a,b)
#else
#  define forget_pmop(a,b)	S_forget_pmop(aTHX_ a)
#endif
a337 1
    dVAR;
d339 1
d341 1
a341 1
    if (!o)
a342 5
    if (o->op_latefreed) {
	if (o->op_latefree)
	    return;
	goto do_free;
    }
a343 1
    type = o->op_type;
d345 1
a345 1
	switch (type) {
a351 2
	    {
	    PADOFFSET refcnt;
d355 1
a355 4
	    if (refcnt) {
		/* Need to find and remove any pattern match ops from the list
		   we maintain for reset().  */
		find_and_forget_pmops(o);
a356 2
	    }
	    }
d370 1
a373 4
#ifdef PERL_DEBUG_READONLY_OPS
    Slab_to_rw(o);
#endif

d376 1
a376 1
    if (type == OP_NEXTSTATE || type == OP_SETSTATE || type == OP_DBSTATE) {
a377 1
    }
a379 5
    if (o->op_latefree) {
	o->op_latefreed = 1;
	return;
    }
  do_free:
a380 4
#ifdef DEBUG_LEAKING_SCALARS
    if (PL_op == o)
	PL_op = NULL;
#endif
a386 17
    dVAR;
#ifdef PERL_MAD
    /* if (o->op_madprop && o->op_madprop->mad_next)
       abort(); */
    /* FIXME for MAD - if I uncomment these two lines t/op/pack.t fails with
       "modification of a read only value" for a reason I can't fathom why.
       It's the "" stringification of $_, where $_ was set to '' in a foreach
       loop, but it defies simplification into a small test case.
       However, commenting them out has caused ext/List/Util/t/weak.t to fail
       the last test.  */
    /*
      mad_free(o->op_madprop);
      o->op_madprop = 0;
    */
#endif    

 retry:
a388 5
	if (PL_madskills && o->op_targ != OP_NULL) {
	    o->op_type = o->op_targ;
	    o->op_targ = 0;
	    goto retry;
	}
d390 3
d395 6
d420 1
a420 1
	    cSVOPo->op_sv = NULL;
d427 1
a427 1
	cSVOPo->op_sv = NULL;
a449 6
#ifdef USE_ITHREADS
	    if (cPADOPo->op_padix > 0) {
		pad_swipe(cPADOPo->op_padix, TRUE);
		cPADOPo->op_padix = 0;
	    }
#else
d451 1
a451 2
	    cSVOPo->op_sv = NULL;
#endif
d454 2
a455 2
	    PerlMemShared_free(cPVOPo->op_pv);
	    cPVOPo->op_pv = NULL;
d459 1
a459 1
	op_free(cPMOPo->op_pmreplrootu.op_pmreplroot);
d463 1
a463 1
        if (cPMOPo->op_pmreplrootu.op_pmtargetoff) {
d466 1
a466 1
	    pad_swipe(cPMOPo->op_pmreplrootu.op_pmtargetoff, TRUE);
d469 1
a469 1
	SvREFCNT_dec((SV*)cPMOPo->op_pmreplrootu.op_pmtargetgv);
d475 20
a494 2
	forget_pmop(cPMOPo, 1);
	cPMOPo->op_pmreplrootu.op_pmreplroot = NULL;
d502 1
a502 1
	PM_SETRE_SAFE(cPMOPo, NULL);
a505 1
            SvREADONLY_off(PL_regex_pad[(cPMOPo)->op_pmoffset]);
d523 1
a523 1
    CopLABEL_free(cop);
d527 2
a528 6
	PerlMemShared_free(cop->cop_warnings);
    Perl_refcounted_he_free(aTHX_ cop->cop_hints_hash);
}

STATIC void
S_forget_pmop(pTHX_ PMOP *const o
d530 4
a533 1
	      , U32 flags
d535 2
a536 32
	      )
{
    HV * const pmstash = PmopSTASH(o);
    if (pmstash && !SvIS_FREED(pmstash)) {
	MAGIC * const mg = mg_find((SV*)pmstash, PERL_MAGIC_symtab);
	if (mg) {
	    PMOP **const array = (PMOP**) mg->mg_ptr;
	    U32 count = mg->mg_len / sizeof(PMOP**);
	    U32 i = count;

	    while (i--) {
		if (array[i] == o) {
		    /* Found it. Move the entry at the end to overwrite it.  */
		    array[i] = array[--count];
		    mg->mg_len = count * sizeof(PMOP**);
		    /* Could realloc smaller at this point always, but probably
		       not worth it. Probably worth free()ing if we're the
		       last.  */
		    if(!count) {
			Safefree(mg->mg_ptr);
			mg->mg_ptr = NULL;
		    }
		    break;
		}
	    }
	}
    }
    if (PL_curpm == o) 
	PL_curpm = NULL;
#ifdef USE_ITHREADS
    if (flags)
	PmopSTASH_free(o);
a537 18
}

STATIC void
S_find_and_forget_pmops(pTHX_ OP *o)
{
    if (o->op_flags & OPf_KIDS) {
        OP *kid = cUNOPo->op_first;
	while (kid) {
	    switch (kid->op_type) {
	    case OP_SUBST:
	    case OP_PUSHRE:
	    case OP_MATCH:
	    case OP_QR:
		forget_pmop((PMOP*)kid, 0);
	    }
	    find_and_forget_pmops(kid);
	    kid = kid->op_sibling;
	}
a543 1
    dVAR;
d546 1
a546 2
    if (!PL_madskills)
	op_clear(o);
a554 2
    dVAR;
    PERL_UNUSED_CONTEXT;
a560 2
    dVAR;
    PERL_UNUSED_CONTEXT;
a570 1
    OP *first;
d576 1
a576 2
    first = cUNOPo->op_first;
    if (first) {
d578 3
a580 4
	o->op_next = LINKLIST(first);
	kid = first;
	for (;;) {
	    if (kid->op_sibling) {
d582 1
a582 2
		kid = kid->op_sibling;
	    } else {
a583 2
		break;
	    }
a605 1
    dVAR;
d610 2
a611 2
	    if (PL_parser && PL_parser->copline != NOLINE)
		CopLINE_set(PL_curcop, PL_parser->copline);
a621 1
    dVAR;
d625 1
a625 2
    if (!o || (PL_parser && PL_parser->error_count)
	 || (o->op_flags & OPf_WANT)
d645 1
a645 1
	    if (!kPMOP->op_pmreplrootu.op_pmreplroot)
d669 1
a669 1
	PL_curcop = &PL_compiling;
d680 1
a680 1
	PL_curcop = &PL_compiling;
a691 1
    dVAR;
d693 1
a693 1
    const char* useless = NULL;
a696 15
    /* trailing mad null ops don't count as "there" for void processing */
    if (PL_madskills &&
    	o->op_type != OP_NULL &&
	o->op_sibling &&
	o->op_sibling->op_type == OP_NULL)
    {
	OP *sib;
	for (sib = o->op_sibling;
		sib && sib->op_type == OP_NULL;
		sib = sib->op_sibling) ;
	
	if (!sib)
	    return o;
    }

d707 1
a707 2
    if ((want && want != OPf_WANT_SCALAR)
	 || (PL_parser && PL_parser->error_count)
a806 9
    case OP_NOT:
       kid = cUNOPo->op_first;
       if (kid->op_type != OP_MATCH && kid->op_type != OP_SUBST &&
           kid->op_type != OP_TRANS) {
	        goto func_ops;
       }
       useless = "negative pattern binding (!~)";
       break;

a822 2
		if (o->op_private & OPpCONST_ARYBASE)
		    useless = NULL;
d826 1
a826 1
		    useless = NULL;
d831 1
a831 1
		    useless = NULL;
d839 4
a842 5
		    const char * const maybe_macro = SvPVX_const(sv);
		    if (strnEQ(maybe_macro, "di", 2) ||
			strnEQ(maybe_macro, "ds", 2) ||
			strnEQ(maybe_macro, "ig", 2))
			    useless = NULL;
a870 1
    case OP_DOR:
a871 2
    case OP_ENTERGIVEN:
    case OP_ENTERWHEN:
a892 2
    case OP_LEAVEGIVEN:
    case OP_LEAVEWHEN:
d907 1
a907 1
	    if (!kPMOP->op_pmreplrootu.op_pmreplroot)
a930 1
    dVAR;
d934 1
a934 2
    if (!o || (o->op_flags & OPf_WANT)
	 || (PL_parser && PL_parser->error_count)
d983 1
a983 1
	PL_curcop = &PL_compiling;
d993 1
a993 1
	PL_curcop = &PL_compiling;
a1005 1
    dVAR;
d1007 4
a1010 4
	const OPCODE type = o->op_type;

	if (type == OP_LINESEQ || type == OP_SCOPE ||
	    type == OP_LEAVE || type == OP_LEAVETRY)
a1039 11
/* Propagate lvalue ("modifiable") context to an op and its children.
 * 'type' represents the context type, roughly based on the type of op that
 * would do the modifying, although local() is represented by OP_NULL.
 * It's responsible for detecting things that can't be modified,  flag
 * things that need to behave specially in an lvalue context (e.g., "$$x = 5"
 * might have to vivify a reference in $x), and so on.
 *
 * For example, "$a+1 = 2" would cause mod() to be called with o being
 * OP_ADD and type being OP_SASSIGN, and would output an error.
 */

a1042 1
    dVAR;
a1043 2
    /* -1 = error on localize, 0 = ignore localize, 1 = ok to localize */
    int localize = -1;
d1045 1
a1045 1
    if (!o || (PL_parser && PL_parser->error_count))
a1055 1
	localize = 0;
d1059 1
a1059 1
	if (!(o->op_private & OPpCONST_ARYBASE))
a1060 1
	localize = 0;
d1062 1
a1062 2
	    CopARYBASE_set(&PL_compiling,
			   (I32)SvIV(cSVOPx(PL_eval_start)->op_sv));
d1066 2
a1067 2
	    SAVECOPARYBASE(&PL_compiling);
	    CopARYBASE_set(&PL_compiling, 0);
d1075 1
a1075 1
	if ((o->op_flags & OPf_PARENS) || PL_madskills)
a1081 4
	    /* The default is to set op_private to the number of children,
	       which for a UNOP such as RV2CV is always 1. And w're using
	       the bit for a flag in RV2CV, so we need it clear.  */
	    o->op_private &= ~1;
d1102 9
a1110 8
		if (kid->op_type != OP_PUSHMARK) {
		    if (kid->op_type != OP_NULL || kid->op_targ != OP_LIST)
			Perl_croak(aTHX_
				"panic: unexpected lvalue entersub "
				"args: type/targ %ld:%"UVuf,
				(long)kid->op_type, (UV)kid->op_targ);
		    kid = kLISTOP->op_first;
		}
d1123 1
a1123 1
			newop->op_first = NULL;
a1126 1
			newop->op_private &= ~1;
d1156 1
a1156 1
			okid->op_next = NULL;
a1160 1
		    okid->op_private &= ~1;
a1211 1
	localize = 1;
a1231 1
	localize = 1;
a1239 1
	localize = 1;
a1246 4
    case OP_DORASSIGN:
	PL_modcount++;
	break;

d1248 3
a1250 1
	localize = -1;
d1266 5
a1270 1
	if (!type) /* local() */
d1273 1
d1276 6
a1282 1
	localize = 0;
a1312 1
	localize = 1;
a1319 1
	localize = 0;
a1324 1
	localize = 0;
a1334 1
	localize = 0;
d1357 4
a1360 15
    else if (!type) { /* local() */
	switch (localize) {
	case 1:
	    o->op_private |= OPpLVAL_INTRO;
	    o->op_flags &= ~OPf_SPECIAL;
	    PL_hints |= HINT_BLOCK_SCOPE;
	    break;
	case 0:
	    break;
	case -1:
	    if (ckWARN(WARN_SYNTAX)) {
		Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
		    "Useless localization of %s", OP_DESC(o));
	    }
	}
d1369 1
a1369 1
S_scalar_mod_type(const OP *o, I32 type)
a1408 1
    case OP_DORASSIGN:
d1416 1
a1416 1
S_is_handle_constructor(const OP *o, I32 numargs)
d1432 1
a1432 1
	/* FALLTHROUGH */
d1450 1
a1450 1
Perl_doref(pTHX_ OP *o, I32 type, bool set_op_ref)
a1451 1
    dVAR;
d1454 1
a1454 1
    if (!o || (PL_parser && PL_parser->error_count))
a1465 1
	    o->op_private &= ~1;
d1471 1
a1471 1
	    doref(kid, type, set_op_ref);
d1476 1
a1476 1
	doref(cUNOPo->op_first, o->op_type, set_op_ref);
d1487 4
d1493 1
a1493 2
	if (set_op_ref)
	    o->op_flags |= OPf_REF;
d1498 1
a1498 1
	doref(cUNOPo->op_first, o->op_type, set_op_ref);
d1503 1
a1503 2
	if (set_op_ref)
	    o->op_flags |= OPf_REF;
d1510 1
a1510 1
	doref(cBINOPo->op_first, type, set_op_ref);
d1514 1
a1514 1
	doref(cBINOPo->op_first, o->op_type, set_op_ref);
a1524 2
	set_op_ref = FALSE;
	/* FALL THROUGH */
d1529 1
a1529 1
	doref(cLISTOPo->op_last, type, set_op_ref);
d1541 1
a1541 2
    dVAR;
    OP *rop;
d1548 1
a1548 5
	rop = newSVOP(OP_CONST, o->op_flags, SvREFCNT_inc_NN(cSVOPo->op_sv));
#ifdef PERL_MAD
    else if (o->op_type == OP_NULL)
	rop = NULL;
#endif
a1550 1
	rop = NULL;
d1555 1
a1555 1
					  SvREFCNT_inc_NN(cSVOPo->op_sv)));
a1563 1
    dVAR;
d1568 5
a1572 1
    stashsv = stash ? newSVhek(HvNAME_HEK(stash)) : &PL_sv_no;
d1579 2
a1580 1
	SV * const * const svp = hv_fetchs(GvHVn(PL_incgv), ATTRSMODULE_PM, FALSE);
d1582 1
a1582 1
	    NOOP;	/* already in %INC */
d1585 2
a1586 1
			     newSVpvs(ATTRSMODULE), NULL);
d1590 2
a1591 2
			 newSVpvs(ATTRSMODULE),
			 NULL,
a1604 1
    dVAR;
d1619 1
a1619 1
    pack = newSVOP(OP_CONST, 0, newSVpvs(ATTRSMODULE));
d1622 4
a1625 2
    stashsv = stash ? newSVhek(HvNAME_HEK(stash)) : &PL_sv_no;

d1636 8
a1643 1
    meth = newSVpvs_share("import");
d1672 2
a1673 2
Perl_apply_attrs_string(pTHX_ const char *stashpv, CV *cv,
                        const char *attrstr, STRLEN len)
d1675 1
a1675 1
    OP *attrs = NULL;
d1693 2
a1694 2
		     newSVpvs(ATTRSMODULE),
                     NULL, prepend_elem(OP_LIST,
a1704 1
    dVAR;
d1707 1
a1707 1
    if (!o || (PL_parser && PL_parser->error_count))
a1710 5
    if (PL_madskills && type == OP_NULL && o->op_flags & OPf_KIDS) {
	(void)my_kid(cUNOPo->op_first, attrs, imopsp);
	return o;
    }

d1715 1
a1715 5
    } else if (type == OP_UNDEF
#ifdef PERL_MAD
	       || type == OP_STUB
#endif
	       ) {
d1721 2
a1722 5
	    yyerror(Perl_form(aTHX_ "Can't declare %s in \"%s\"",
			OP_DESC(o),
			PL_parser->in_my == KEY_our
			    ? "our"
			    : PL_parser->in_my == KEY_state ? "state" : "my"));
d1725 2
a1726 2
	    PL_parser->in_my = FALSE;
	    PL_parser->in_my_stash = NULL;
d1743 1
a1743 3
			  PL_parser->in_my == KEY_our
			    ? "our"
			    : PL_parser->in_my == KEY_state ? "state" : "my"));
d1749 2
a1750 2
	PL_parser->in_my = FALSE;
	PL_parser->in_my_stash = NULL;
a1759 2
    if (PL_parser->in_my == KEY_state)
	o->op_private |= OPpPAD_STATE;
d1766 1
a1766 2
    dVAR;
    OP *rops;
a1780 1
    rops = NULL;
d1790 2
a1791 2
    PL_parser->in_my = FALSE;
    PL_parser->in_my_stash = NULL;
d1798 1
a1798 1
    return my_attrs(o, NULL);
a1803 1
    PERL_UNUSED_CONTEXT;
a1812 3
    bool ismatchop = 0;
    const OPCODE ltype = left->op_type;
    const OPCODE rtype = right->op_type;
d1814 5
a1818 2
    if ( (ltype == OP_RV2AV || ltype == OP_RV2HV || ltype == OP_PADAV
	  || ltype == OP_PADHV) && ckWARN(WARN_MISC))
d1820 6
a1825 5
      const char * const desc
	  = PL_op_desc[(rtype == OP_SUBST || rtype == OP_TRANS)
		       ? (int)rtype : OP_MATCH];
      const char * const sample = ((ltype == OP_RV2AV || ltype == OP_PADAV)
	     ? "@@array" : "%hash");
d1831 1
a1831 1
    if (rtype == OP_CONST &&
d1838 4
a1841 10
    ismatchop = rtype == OP_MATCH ||
		rtype == OP_SUBST ||
		rtype == OP_TRANS;
    if (ismatchop && right->op_private & OPpTARGET_MY) {
	right->op_targ = 0;
	right->op_private &= ~OPpTARGET_MY;
    }
    if (!(right->op_flags & OPf_STACKED) && ismatchop) {
	OP *newleft;

d1843 2
a1844 2
	if (rtype != OP_MATCH &&
            ! (rtype == OP_TRANS &&
d1846 1
a1846 3
	    newleft = mod(left, rtype);
	else
	    newleft = left;
d1848 1
a1848 1
	    o = newBINOP(OP_NULL, OPf_STACKED, scalar(newleft), right);
d1850 1
a1850 1
	    o = prepend_elem(rtype, scalar(newleft), right);
d1857 1
a1857 1
		pmruntime(newPMOP(OP_MATCH, 0), right, 0));
d1864 2
a1865 1
	return NULL;
a1871 1
    dVAR;
d1894 1
a1894 1
	    o = newLISTOP(OP_SCOPE, 0, o, NULL);
d1898 8
a1905 1
	
a1908 1
    dVAR;
d1910 3
d1916 10
a1925 2
    SAVECOMPILEWARNINGS();
    PL_compiling.cop_warnings = DUP_WARNINGS(PL_compiling.cop_warnings);
a1931 1
    dVAR;
d1934 2
d1937 1
a1937 1
    CopHINTS_set(&PL_compiling, PL_hints);
d1947 7
a1953 10
    dVAR;
    const PADOFFSET offset = pad_findmy("$_");
    if (offset == NOT_IN_PAD || PAD_COMPNAME_FLAGS_isOUR(offset)) {
	return newSVREF(newGVOP(OP_GV, 0, PL_defgv));
    }
    else {
	OP * const o = newOP(OP_PADSV, 0);
	o->op_targ = offset;
	return o;
    }
a1958 1
    dVAR;
d1975 1
a1975 1
	    S_op_destroy(aTHX_ o);
d1989 1
a1989 2
	    CV * const cv
		= Perl_get_cvn_flags(aTHX_ STR_WITH_LEN("DB::postponed"), 0);
a2003 1
    dVAR;
d2010 1
a2010 1
	NOOP;
d2013 1
a2013 2
	if ( PL_parser->bufptr > PL_parser->oldbufptr
	    && PL_parser->bufptr[-1] == ','
d2016 1
a2016 1
	    char *s = PL_parser->bufptr;
d2039 2
a2040 7
				lex
				    ? (PL_parser->in_my == KEY_our
					? "our"
					: PL_parser->in_my == KEY_state
					    ? "state"
					    : "my")
				    : "local");
d2048 2
a2049 2
    PL_parser->in_my = FALSE;
    PL_parser->in_my_stash = NULL;
d2057 7
a2063 2
	OP * const o2
	    = newSVREF(newGVOP(OP_GV, 0, gv_fetchpvs(";", GV_ADD|GV_NOTQUAL, SVt_PV)));
a2071 1
    dVAR;
d2073 2
a2074 9
    OP *newop;
    VOL I32 type = o->op_type;
    SV * VOL sv = NULL;
    int ret = 0;
    I32 oldscope;
    OP *old_next;
    SV * const oldwarnhook = PL_warnhook;
    SV * const olddiehook  = PL_diehook;
    dJMPENV;
d2112 1
a2112 1
    if (PL_parser && PL_parser->error_count)
d2116 6
a2121 6
	const OPCODE type = curop->op_type;
	if ((type != OP_CONST || (curop->op_private & OPpCONST_BARE)) &&
	    type != OP_LIST &&
	    type != OP_SCALAR &&
	    type != OP_NULL &&
	    type != OP_PUSHMARK)
a2127 1
    old_next = o->op_next;
d2130 8
a2137 45

    oldscope = PL_scopestack_ix;
    create_eval_scope(G_FAKINGEVAL);

    PL_warnhook = PERL_WARNHOOK_FATAL;
    PL_diehook  = NULL;
    JMPENV_PUSH(ret);

    switch (ret) {
    case 0:
	CALLRUNOPS(aTHX);
	sv = *(PL_stack_sp--);
	if (o->op_targ && sv == PAD_SV(o->op_targ))	/* grab pad temp? */
	    pad_swipe(o->op_targ,  FALSE);
	else if (SvTEMP(sv)) {			/* grab mortal temp? */
	    SvREFCNT_inc_simple_void(sv);
	    SvTEMP_off(sv);
	}
	break;
    case 3:
	/* Something tried to die.  Abandon constant folding.  */
	/* Pretend the error never happened.  */
	sv_setpvn(ERRSV,"",0);
	o->op_next = old_next;
	break;
    default:
	JMPENV_POP;
	/* Don't expect 1 (setjmp failed) or 2 (something called my_exit)  */
	PL_warnhook = oldwarnhook;
	PL_diehook  = olddiehook;
	/* XXX note that this croak may fail as we've already blown away
	 * the stack - eg any nested evals */
	Perl_croak(aTHX_ "panic: fold_constants JMPENV_PUSH returned %d", ret);
    }
    JMPENV_POP;
    PL_warnhook = oldwarnhook;
    PL_diehook  = olddiehook;

    if (PL_scopestack_ix > oldscope)
	delete_eval_scope();

    if (ret)
	goto nope;

#ifndef PERL_MAD
a2138 2
#endif
    assert(sv);
d2140 2
a2141 5
	newop = newGVOP(OP_GV, 0, (GV*)sv);
    else
	newop = newSVOP(OP_CONST, 0, (SV*)sv);
    op_getmad(o,newop,'f');
    return newop;
d2143 1
a2143 1
 nope:
a2149 1
    dVAR;
d2154 1
a2154 1
    if (PL_parser && PL_parser->error_count)
a2162 2
    assert (!(curop->op_flags & OPf_SPECIAL));
    assert(curop->op_type == OP_RANGE);
d2170 1
a2170 1
    o->op_opt = 0;		/* needs to be revisited in peep() */
d2172 1
a2172 4
    ((UNOP*)o)->op_first = newSVOP(OP_CONST, 0, SvREFCNT_inc_NN(*PL_stack_sp--));
#ifdef PERL_MAD
    op_getmad(curop,o,'O');
#else
a2173 1
#endif
a2180 1
    dVAR;
d2182 1
a2182 1
	o = newLISTOP(OP_LIST, 0, o, NULL);
d2246 1
a2246 17
#ifdef PERL_MAD
    if (last->op_first && first->op_madprop) {
	MADPROP *mp = last->op_first->op_madprop;
	if (mp) {
	    while (mp->mad_next)
		mp = mp->mad_next;
	    mp->mad_next = first->op_madprop;
	}
	else {
	    last->op_first->op_madprop = first->op_madprop;
	}
    }
    first->op_madprop = last->op_madprop;
    last->op_madprop = 0;
#endif

    S_op_destroy(aTHX_ (OP*)last);
d2284 4
a2287 12
#ifdef PERL_MAD
 
TOKEN *
Perl_newTOKEN(pTHX_ I32 optype, YYSTYPE lval, MADPROP* madprop)
{
    TOKEN *tk;
    Newxz(tk, 1, TOKEN);
    tk->tk_type = (OPCODE)optype;
    tk->tk_type = 12345;
    tk->tk_lval = lval;
    tk->tk_mad = madprop;
    return tk;
d2290 2
a2291 2
void
Perl_token_free(pTHX_ TOKEN* tk)
d2293 4
a2296 4
    if (tk->tk_type != 12345)
	return;
    mad_free(tk->tk_mad);
    Safefree(tk);
d2299 2
a2300 2
void
Perl_token_getmad(pTHX_ TOKEN* tk, OP* o, char slot)
d2302 3
a2304 10
    MADPROP* mp;
    MADPROP* tm;
    if (tk->tk_type != 12345) {
	Perl_warner(aTHX_ packWARN(WARN_MISC),
	     "Invalid TOKEN object ignored");
	return;
    }
    tm = tk->tk_mad;
    if (!tm)
	return;
d2306 5
a2310 5
    /* faked up qw list? */
    if (slot == '(' &&
	tm->mad_type == MAD_SV &&
	SvPVX((SV*)tm->mad_val)[0] == 'q')
	    slot = 'x';
d2312 2
a2313 228
    if (o) {
	mp = o->op_madprop;
	if (mp) {
	    for (;;) {
		/* pretend constant fold didn't happen? */
		if (mp->mad_key == 'f' &&
		    (o->op_type == OP_CONST ||
		     o->op_type == OP_GV) )
		{
		    token_getmad(tk,(OP*)mp->mad_val,slot);
		    return;
		}
		if (!mp->mad_next)
		    break;
		mp = mp->mad_next;
	    }
	    mp->mad_next = tm;
	    mp = mp->mad_next;
	}
	else {
	    o->op_madprop = tm;
	    mp = o->op_madprop;
	}
	if (mp->mad_key == 'X')
	    mp->mad_key = slot;	/* just change the first one */

	tk->tk_mad = 0;
    }
    else
	mad_free(tm);
    Safefree(tk);
}

void
Perl_op_getmad_weak(pTHX_ OP* from, OP* o, char slot)
{
    MADPROP* mp;
    if (!from)
	return;
    if (o) {
	mp = o->op_madprop;
	if (mp) {
	    for (;;) {
		/* pretend constant fold didn't happen? */
		if (mp->mad_key == 'f' &&
		    (o->op_type == OP_CONST ||
		     o->op_type == OP_GV) )
		{
		    op_getmad(from,(OP*)mp->mad_val,slot);
		    return;
		}
		if (!mp->mad_next)
		    break;
		mp = mp->mad_next;
	    }
	    mp->mad_next = newMADPROP(slot,MAD_OP,from,0);
	}
	else {
	    o->op_madprop = newMADPROP(slot,MAD_OP,from,0);
	}
    }
}

void
Perl_op_getmad(pTHX_ OP* from, OP* o, char slot)
{
    MADPROP* mp;
    if (!from)
	return;
    if (o) {
	mp = o->op_madprop;
	if (mp) {
	    for (;;) {
		/* pretend constant fold didn't happen? */
		if (mp->mad_key == 'f' &&
		    (o->op_type == OP_CONST ||
		     o->op_type == OP_GV) )
		{
		    op_getmad(from,(OP*)mp->mad_val,slot);
		    return;
		}
		if (!mp->mad_next)
		    break;
		mp = mp->mad_next;
	    }
	    mp->mad_next = newMADPROP(slot,MAD_OP,from,1);
	}
	else {
	    o->op_madprop = newMADPROP(slot,MAD_OP,from,1);
	}
    }
    else {
	PerlIO_printf(PerlIO_stderr(),
		      "DESTROYING op = %0"UVxf"\n", PTR2UV(from));
	op_free(from);
    }
}

void
Perl_prepend_madprops(pTHX_ MADPROP* mp, OP* o, char slot)
{
    MADPROP* tm;
    if (!mp || !o)
	return;
    if (slot)
	mp->mad_key = slot;
    tm = o->op_madprop;
    o->op_madprop = mp;
    for (;;) {
	if (!mp->mad_next)
	    break;
	mp = mp->mad_next;
    }
    mp->mad_next = tm;
}

void
Perl_append_madprops(pTHX_ MADPROP* tm, OP* o, char slot)
{
    if (!o)
	return;
    addmad(tm, &(o->op_madprop), slot);
}

void
Perl_addmad(pTHX_ MADPROP* tm, MADPROP** root, char slot)
{
    MADPROP* mp;
    if (!tm || !root)
	return;
    if (slot)
	tm->mad_key = slot;
    mp = *root;
    if (!mp) {
	*root = tm;
	return;
    }
    for (;;) {
	if (!mp->mad_next)
	    break;
	mp = mp->mad_next;
    }
    mp->mad_next = tm;
}

MADPROP *
Perl_newMADsv(pTHX_ char key, SV* sv)
{
    return newMADPROP(key, MAD_SV, sv, 0);
}

MADPROP *
Perl_newMADPROP(pTHX_ char key, char type, const void* val, I32 vlen)
{
    MADPROP *mp;
    Newxz(mp, 1, MADPROP);
    mp->mad_next = 0;
    mp->mad_key = key;
    mp->mad_vlen = vlen;
    mp->mad_type = type;
    mp->mad_val = val;
/*    PerlIO_printf(PerlIO_stderr(), "NEW  mp = %0x\n", mp);  */
    return mp;
}

void
Perl_mad_free(pTHX_ MADPROP* mp)
{
/*    PerlIO_printf(PerlIO_stderr(), "FREE mp = %0x\n", mp); */
    if (!mp)
	return;
    if (mp->mad_next)
	mad_free(mp->mad_next);
/*    if (PL_parser && PL_parser->lex_state != LEX_NOTPARSING && mp->mad_vlen)
	PerlIO_printf(PerlIO_stderr(), "DESTROYING '%c'=<%s>\n", mp->mad_key & 255, mp->mad_val); */
    switch (mp->mad_type) {
    case MAD_NULL:
	break;
    case MAD_PV:
	Safefree((char*)mp->mad_val);
	break;
    case MAD_OP:
	if (mp->mad_vlen)	/* vlen holds "strong/weak" boolean */
	    op_free((OP*)mp->mad_val);
	break;
    case MAD_SV:
	sv_free((SV*)mp->mad_val);
	break;
    default:
	PerlIO_printf(PerlIO_stderr(), "Unrecognized mad\n");
	break;
    }
    Safefree(mp);
}

#endif

OP *
Perl_newNULLLIST(pTHX)
{
    return newOP(OP_STUB, 0);
}

OP *
Perl_force_list(pTHX_ OP *o)
{
    if (!o || o->op_type != OP_LIST)
	o = newLISTOP(OP_LIST, 0, o, NULL);
    op_null(o);
    return o;
}

OP *
Perl_newLISTOP(pTHX_ I32 type, I32 flags, OP *first, OP *last)
{
    dVAR;
    LISTOP *listop;

    NewOp(1101, listop, 1, LISTOP);

    listop->op_type = (OPCODE)type;
    listop->op_ppaddr = PL_ppaddr[type];
    if (first || last)
	flags |= OPf_KIDS;
    listop->op_flags = (U8)flags;

    if (!last && first)
	last = first;
a2334 1
    dVAR;
a2339 3
    o->op_latefree = 0;
    o->op_latefreed = 0;
    o->op_attached = 0;
a2352 1
    dVAR;
a2375 1
    dVAR;
d2404 1
a2404 4
static int uvcompare(const void *a, const void *b)
    __attribute__nonnull__(1)
    __attribute__nonnull__(2)
    __attribute__pure__;
a2420 1
    dVAR;
d2422 1
a2422 6
    SV * const rstr =
#ifdef PERL_MAD
			(repl->op_type == OP_NULL)
			    ? ((SVOP*)((LISTOP*)repl)->op_first)->op_sv :
#endif
			      ((SVOP*)repl)->op_sv;
a2434 1
    SV* swash;
d2444 2
a2445 2
	SV* const listsv = newSVpvs("# comment\n");
	SV* transv = NULL;
a2464 1
	const U32 flags = UTF8_ALLOW_DEFAULT;
d2468 1
a2468 1
	    t = tsave = bytes_to_utf8(t, &len);
d2473 1
a2473 1
	    r = rsave = bytes_to_utf8(r, &len);
d2489 1
a2489 1
	    transv = newSVpvs("");
d2491 1
a2491 1
		cp[2*i] = utf8n_to_uvuni(t, tend-t, &ulen, flags);
d2495 1
a2495 1
		    cp[2*i+1] = utf8n_to_uvuni(t, tend-t, &ulen, flags);
d2549 1
a2549 1
		tfirst = (I32)utf8n_to_uvuni(t, tend - t, &ulen, flags);
d2553 1
a2553 1
		    tlast = (I32)utf8n_to_uvuni(t, tend - t, &ulen, flags);
d2563 1
a2563 1
		    rfirst = (I32)utf8n_to_uvuni(r, rend - r, &ulen, flags);
d2567 2
a2568 1
			rlast = (I32)utf8n_to_uvuni(r, rend - r, &ulen, flags);
d2628 2
a2629 12
	PerlMemShared_free(cPVOPo->op_pv);
	cPVOPo->op_pv = NULL;

	swash = (SV*)swash_init("utf8", "", listsv, bits, none);
#ifdef USE_ITHREADS
	cPADOPo->op_padix = pad_alloc(OP_TRANS, SVs_PADTMP);
	SvREFCNT_dec(PAD_SVl(cPADOPo->op_padix));
	PAD_SETSV(cPADOPo->op_padix, swash);
	SvPADTMP_on(swash);
#else
	cSVOPo->op_sv = swash;
#endif
d2631 2
a2632 1
	SvREFCNT_dec(transv);
d2635 1
a2635 1
	    (void)hv_store((HV*)SvRV(swash), "FINAL", 5,
d2641 4
a2644 2
	Safefree(tsave);
	Safefree(rsave);
a2645 4
#ifdef PERL_MAD
	op_getmad(expr,o,'e');
	op_getmad(repl,o,'r');
#else
a2647 1
#endif
d2681 2
a2682 7
	    else {
		tbl = 
		    (short *)
		    PerlMemShared_realloc(tbl,
					  (0x101+rlen-j) * sizeof(short));
		cPVOPo->op_pv = (char*)tbl;
	    }
a2716 4
#ifdef PERL_MAD
    op_getmad(expr,o,'e');
    op_getmad(repl,o,'r');
#else
a2718 1
#endif
a2725 1
    dVAR;
d2735 1
a2735 1
	pmop->op_pmflags |= PMf_RETAINT;
d2737 2
a2738 2
	pmop->op_pmflags |= PMf_LOCALE;

d2748 1
a2748 1
	av_push(PL_regex_padav, SvREFCNT_inc_simple_NN(repointer));
d2754 7
a2763 12
/* Given some sort of match op o, and an expression expr containing a
 * pattern, either compile expr into a regex and attach it to o (if it's
 * constant), or convert expr into a runtime regcomp op sequence (if it's
 * not)
 *
 * isreg indicates that the pattern is part of a regex construct, eg
 * $x =~ /pattern/ or split /pattern/, as opposed to $x =~ $pattern or
 * split "pattern", which aren't. In the former case, expr will be a list
 * if the pattern contains more than one term (eg /a$b/) or if it contains
 * a replacement, ie s/// or tr///.
 */

d2765 1
a2765 1
Perl_pmruntime(pTHX_ OP *o, OP *expr, bool isreg)
a2766 1
    dVAR;
a2769 2
    OP* repl = NULL;
    bool reglist;
d2771 1
a2771 23
    if (o->op_type == OP_SUBST || o->op_type == OP_TRANS) {
	/* last element in list is the replacement; pop it */
	OP* kid;
	repl = cLISTOPx(expr)->op_last;
	kid = cLISTOPx(expr)->op_first;
	while (kid->op_sibling != repl)
	    kid = kid->op_sibling;
	kid->op_sibling = NULL;
	cLISTOPx(expr)->op_last = kid;
    }

    if (isreg && expr->op_type == OP_LIST &&
	cLISTOPx(expr)->op_first->op_sibling == cLISTOPx(expr)->op_last)
    {
	/* convert single element list to element */
	OP* const oe = expr;
	expr = cLISTOPx(oe)->op_first->op_sibling;
	cLISTOPx(oe)->op_first->op_sibling = NULL;
	cLISTOPx(oe)->op_last = NULL;
	op_free(oe);
    }

    if (o->op_type == OP_TRANS) {
a2772 5
    }

    reglist = isreg && expr->op_type == OP_LIST;
    if (reglist)
	op_null(expr);
d2778 5
a2782 2
	SV * const pat = ((SVOP*)expr)->op_sv;
	U32 pm_flags = pm->op_pmflags & PMf_COMPILETIME;
d2784 9
a2792 2
	if (o->op_flags & OPf_SPECIAL)
	    pm_flags |= RXf_SPLIT;
d2794 1
a2794 2
	if (DO_UTF8(pat))
	    pm_flags |= RXf_UTF8;
d2796 1
a2796 1
	PM_SETRE(pm, CALLREGCOMP(pat, pm_flags));
d2798 9
a2806 3
#ifdef PERL_MAD
	op_getmad(expr,(OP*)pm,'e');
#else
a2807 1
#endif
d2819 3
a2821 3
	rcop->op_flags |= OPf_KIDS
			    | ((PL_hints & HINT_RE_EVAL) ? OPf_SPECIAL : 0)
			    | (reglist ? OPf_STACKED : 0);
a2823 5
	if (reglist)
	    rcop->op_targ = pad_alloc(rcop->op_type, SVs_PADTMP);

	/* /$x/ may cause an eval, since $x might be qr/(?{..})/  */
	PL_cv_has_eval = 1;
d2842 10
a2851 3
	    curop = NULL;
	    if (CopLINE(PL_curcop) < (line_t)PL_parser->multi_end)
		CopLINE_set(PL_curcop, (line_t)PL_parser->multi_end);
d2853 1
d2857 1
a2857 1
	    OP *lastop = NULL;
d2859 8
a2866 3
		if (curop->op_type == OP_SCOPE
			|| curop->op_type == OP_LEAVE
			|| (PL_opargs[curop->op_type] & OA_DANGEROUS)) {
d2868 1
a2868 1
			GV * const gv = cGVOPx_gv(curop);
d2873 1
d2886 1
a2886 2
			     curop->op_type == OP_PADANY)
		    {
d2890 1
a2890 1
			NOOP; /* Okay here, dangerous in newASSIGNOP */
d2900 1
a2900 2
		     || PM_GETRE(pm)->extflags & RXf_EVAL_SEEN)))
	{
d2902 1
d2908 1
d2922 2
a2923 3
	    pm->op_pmreplrootu.op_pmreplroot = scalar((OP*)rcop);
	    assert(!(pm->op_pmflags & PMf_ONCE));
	    pm->op_pmstashstartu.op_pmreplstart = LINKLIST(rcop);
a2933 1
    dVAR;
a2947 1
#ifdef USE_ITHREADS
a2950 1
    dVAR;
d2958 2
a2959 2
    assert(sv);
    SvPADTMP_on(sv);
a2967 1
#endif
a2971 2
    dVAR;
    assert(gv);
d2973 3
a2975 2
    GvIN_PAD_on(gv);
    return newPADOP(type, flags, SvREFCNT_inc_simple_NN(gv));
d2977 1
a2977 1
    return newSVOP(type, flags, SvREFCNT_inc_simple_NN(gv));
a2983 1
    dVAR;
a2997 3
#ifdef PERL_MAD
OP*
#else
a2998 1
#endif
d3001 1
a3001 5
    dVAR;
    SV *const sv = cSVOPo->op_sv;
#ifdef PERL_MAD
    OP *pegop;
#endif
d3005 7
a3011 13

    PL_curstash = gv_stashsv(sv, GV_ADD);

    sv_setsv(PL_curstname, sv);

    PL_hints |= HINT_BLOCK_SCOPE;
    PL_parser->copline = NOLINE;
    PL_parser->expect = XSTATE;

#ifndef PERL_MAD
    op_free(o);
#else
    if (!PL_madskills) {
a3012 1
	return NULL;
d3014 8
a3021 5

    pegop = newOP(OP_NULL,0);
    op_getmad(o,pegop,'P');
    return pegop;
#endif
a3023 3
#ifdef PERL_MAD
OP*
#else
a3024 1
#endif
a3026 1
    dVAR;
a3029 3
#ifdef PERL_MAD
    OP *pegop = newOP(OP_NULL,0);
#endif
d3034 1
a3034 4
    if (PL_madskills)
	op_getmad(idop,pegop,'U');

    veop = NULL;
a3038 2
	if (PL_madskills)
	    op_getmad(version,pegop,'V');
d3053 8
a3060 1
	    meth = newSVpvs_share("VERSION");
d3069 1
a3069 3
    if (arg && arg->op_type == OP_STUB) {
	if (PL_madskills)
	    op_getmad(arg,pegop,'S');
a3070 1
    }
d3072 1
a3072 3
	imop = NULL;		/* use 5.0; */
	if (!aver)
	    idop->op_private |= OPpCONST_NOVER;
a3076 3
	if (PL_madskills)
	    op_getmad(arg,pegop,'A');

d3081 8
a3088 2
	meth = aver
	    ? newSVpvs_share("import") : newSVpvs_share("unimport");
d3097 3
a3099 3
	newSVOP(OP_CONST, 0, newSVpvs_share("BEGIN")),
	NULL,
	NULL,
d3102 3
a3104 3
	        newSTATEOP(0, NULL, newUNOP(OP_REQUIRE, 0, idop)),
	        newSTATEOP(0, NULL, veop)),
	    newSTATEOP(0, NULL, imop) ));
d3124 2
a3125 2
    PL_parser->copline = NOLINE;
    PL_parser->expect = XSTATE;
a3126 9

#ifdef PERL_MAD
    if (!PL_madskills) {
	/* FIXME - don't allocate pegop if !PL_madskills */
	op_free(pegop);
	return NULL;
    }
    return pegop;
#endif
a3168 1
    dVAR;
d3177 1
a3177 1
	veop = NULL;
d3186 1
a3186 1
	imop = NULL;
d3193 4
d3198 6
a3203 12
    /* utilize() fakes up a BEGIN { require ..; import ... }, so make sure
     * that it has a PL_parser to play with while doing that, and also
     * that it doesn't mess with any existing parser, by creating a tmp
     * new parser with lex_start(). This won't actually be used for much,
     * since pp_require() will create another parser for the real work. */

    ENTER;
    SAVEVPTR(PL_curcop);
    lex_start(NULL, NULL, FALSE);
    utilize(!(flags & PERL_LOADMOD_DENY), start_subparse(FALSE, 0),
	    veop, modname, imop);
    LEAVE;
d3207 1
a3207 1
Perl_dofile(pTHX_ OP *term, I32 force_builtin)
a3208 1
    dVAR;
d3210 1
a3210 1
    GV *gv = NULL;
d3212 3
a3214 7
    if (!force_builtin) {
	gv = gv_fetchpvs("do", GV_NOTQUAL, SVt_PVCV);
	if (!(gv && GvCVu(gv) && GvIMPORTED_CV(gv))) {
	    GV * const * const gvp = (GV**)hv_fetchs(PL_globalstash, "do", FALSE);
	    gv = gvp ? *gvp : NULL;
	}
    }
d3220 2
a3221 1
							  newGVOP(OP_GV, 0, gv))))));
a3239 3
    unsigned type;
    U8 flags;

d3243 1
a3243 1
    if ((o->op_type == OP_NULL) && (o->op_flags & OPf_KIDS))
d3246 1
a3246 3
    flags = o->op_flags;
    type = o->op_type;
    if (type == OP_COND_EXPR) {
d3257 2
a3258 2
    if (type == OP_LIST &&
	(flags & OPf_WANT) == OPf_WANT_SCALAR &&
d3262 3
a3264 3
    if (type == OP_LIST || flags & OPf_PARENS ||
	type == OP_RV2AV || type == OP_RV2HV ||
	type == OP_ASLICE || type == OP_HSLICE)
d3267 1
a3267 1
    if (type == OP_PADAV || type == OP_PADHV)
d3270 1
a3270 1
    if (type == OP_RV2SV)
a3278 1
    dVAR;
d3282 1
a3282 1
	if (optype == OP_ANDASSIGN || optype == OP_ORASSIGN || optype == OP_DORASSIGN) {
a3293 2
	static const char no_list_state[] = "Initialization of state variables"
	    " in list context currently forbidden";
d3299 1
a3299 1
	PL_eval_start = (left->op_type == OP_CONST) ? right : NULL;
a3303 1
	    /* FIXME for MAD */
d3310 9
d3331 1
a3331 1
	 * to store these values, evil chicanery is done with SvUVX().
d3333 2
a3334 2

	{
d3341 1
a3341 2
			if (gv == PL_defgv
			    || (int)GvASSIGN_GENERATION(gv) == PL_generation)
d3343 1
a3343 1
			GvASSIGN_GENERATION_set(gv, PL_generation);
d3350 2
a3351 2
			if (PAD_COMPNAME_GEN(curop->op_targ)
						    == (STRLEN)PL_generation)
d3366 1
d3368 2
a3369 7
			if (((PMOP*)curop)->op_pmreplrootu.op_pmtargetoff) {
			    GV *const gv = (GV*)PAD_SVl(((PMOP*)curop)->op_pmreplrootu.op_pmtargetoff);
			    if (gv == PL_defgv
				|| (int)GvASSIGN_GENERATION(gv) == PL_generation)
				break;
			    GvASSIGN_GENERATION_set(gv, PL_generation);
			}
d3371 3
a3373 5
			GV *const gv
			    = ((PMOP*)curop)->op_pmreplrootu.op_pmtargetgv;
			if (gv) {
			    if (gv == PL_defgv
				|| (int)GvASSIGN_GENERATION(gv) == PL_generation)
d3375 1
a3375 1
			    GvASSIGN_GENERATION_set(gv, PL_generation);
a3376 1
#endif
d3386 5
a3390 52

	if ((left->op_type == OP_LIST
	     || (left->op_type == OP_NULL && left->op_targ == OP_LIST))) {
	    OP* lop = ((LISTOP*)left)->op_first;
	    while (lop) {
		if (lop->op_type == OP_PADSV ||
		    lop->op_type == OP_PADAV ||
		    lop->op_type == OP_PADHV ||
		    lop->op_type == OP_PADANY) {
		    if (lop->op_private & OPpPAD_STATE) {
			if (left->op_private & OPpLVAL_INTRO) {
			    /* Each variable in state($a, $b, $c) = ... */
			}
			else {
			    /* Each state variable in
			       (state $a, my $b, our $c, $d, undef) = ... */
			}
			yyerror(no_list_state);
		    } else {
			/* Each my variable in
			   (state $a, my $b, our $c, $d, undef) = ... */
		    }
		} else {
		    /* Other ops in the list. undef may be interesting in
		       (state $a, undef, state $c) */
		}
		lop = lop->op_sibling;
	    }
	}
	else if (((left->op_private & (OPpLVAL_INTRO | OPpPAD_STATE))
		    == (OPpLVAL_INTRO | OPpPAD_STATE))
		&& (   left->op_type == OP_PADSV
		    || left->op_type == OP_PADAV
		    || left->op_type == OP_PADHV
		    || left->op_type == OP_PADANY))
	{
	    /* All single variable list context state assignments, hence
	       state ($a) = ...
	       (state $a) = ...
	       state @@a = ...
	       state (@@a) = ...
	       (state @@a) = ...
	       state %a = ...
	       state (%a) = ...
	       (state %a) = ...
	    */
	    yyerror(no_list_state);
	}

	if (right && right->op_type == OP_SPLIT && !PL_madskills) {
	    OP* tmpop = ((LISTOP*)right)->op_first;
	    if (tmpop && (tmpop->op_type == OP_PUSHRE)) {
d3397 1
a3397 7
		    if (tmpop->op_type == OP_GV
#ifdef USE_ITHREADS
			&& !pm->op_pmreplrootu.op_pmtargetoff
#else
			&& !pm->op_pmreplrootu.op_pmtargetgv
#endif
			) {
d3399 1
a3399 2
			pm->op_pmreplrootu.op_pmtargetoff
			    = cPADOPx(tmpop)->op_padix;
d3402 2
a3403 3
			pm->op_pmreplrootu.op_pmtargetgv
			    = (GV*)cSVOPx(tmpop)->op_sv;
			cSVOPx(tmpop)->op_sv = NULL;	/* steal it */
d3408 1
a3408 1
			tmpop->op_sibling = NULL;	/* don't free split */
d3442 1
a3442 4
	    /* FIXME for MAD */
	    op_free(o);
	    o = newSVOP(OP_CONST, 0, newSViv(CopARYBASE_get(&PL_compiling)));
	    o->op_private |= OPpCONST_ARYBASE;
a3450 1
    dVAR;
d3464 1
a3464 1
    CopHINTS_set(cop, PL_hints);
d3468 1
a3468 1
    CopHINTS_set(&PL_compiling, CopHINTS_get(cop));
d3472 1
a3472 1
	CopLABEL_set(cop, label);
d3476 10
a3485 10
    /* CopARYBASE is now "virtual", in that it's stored as a flag bit in
       CopHINTS and a possible value in cop_hints_hash, so no need to copy it.
    */
    cop->cop_warnings = DUP_WARNINGS(PL_curcop->cop_warnings);
    cop->cop_hints_hash = PL_curcop->cop_hints_hash;
    if (cop->cop_hints_hash) {
	HINTS_REFCNT_LOCK;
	cop->cop_hints_hash->refcounted_he_refcnt++;
	HINTS_REFCNT_UNLOCK;
    }
d3487 1
a3487 1
    if (PL_parser && PL_parser->copline == NOLINE)
d3490 2
a3491 3
	CopLINE_set(cop, PL_parser->copline);
	if (PL_parser)
	    PL_parser->copline = NOLINE;
d3501 4
a3504 7
	AV *av = CopFILEAVx(PL_curcop);
	if (av) {
	    SV * const * const svp = av_fetch(av, (I32)CopLINE(cop), FALSE);
	    if (svp && *svp != &PL_sv_undef ) {
		(void)SvIOK_on(*svp);
		SvIV_set(*svp, PTR2IV(cop));
	    }
a3514 1
    dVAR;
a3520 1
    dVAR;
d3531 1
a3531 4
    if (first->op_type == OP_NOT
	&& (first->op_flags & OPf_SPECIAL)
	&& (first->op_flags & OPf_KIDS)
	&& !PL_madskills) {
d3541 1
a3541 1
	    cUNOPo->op_first = NULL;
d3550 3
a3552 4
	if ((type == OP_AND &&  SvTRUE(((SVOP*)first)->op_sv)) ||
	    (type == OP_OR  && !SvTRUE(((SVOP*)first)->op_sv)) ||
	    (type == OP_DOR && !SvOK(((SVOP*)first)->op_sv))) {
	    *firstp = NULL;
a3554 7
	    if (PL_madskills) {
		OP *newop = newUNOP(OP_NULL, 0, other);
		op_getmad(first, newop, '1');
		newop->op_targ = type;	/* set "was" field */
		return newop;
	    }
	    op_free(first);
d3558 2
a3559 19
	    /* check for C<my $x if 0>, or C<my($x,$y) if 0> */
	    const OP *o2 = other;
	    if ( ! (o2->op_type == OP_LIST
		    && (( o2 = cUNOPx(o2)->op_first))
		    && o2->op_type == OP_PUSHMARK
		    && (( o2 = o2->op_sibling)) )
	    )
		o2 = other;
	    if ((o2->op_type == OP_PADSV || o2->op_type == OP_PADAV
			|| o2->op_type == OP_PADHV)
		&& o2->op_private & OPpLVAL_INTRO
		&& !(o2->op_private & OPpPAD_STATE)
		&& ckWARN(WARN_DEPRECATED))
	    {
		Perl_warner(aTHX_ packWARN(WARN_DEPRECATED),
			    "Deprecated use of my() in false conditional");
	    }

	    *otherp = NULL;
a3561 7
	    if (PL_madskills) {
		first = newUNOP(OP_NULL, 0, first);
		op_getmad(other, first, '2');
		first->op_targ = type;	/* set "was" field */
	    }
	    else
		op_free(other);
d3565 1
a3565 3
    else if ((first->op_flags & OPf_KIDS) && type != OP_DOR
	&& ckWARN(WARN_MISC)) /* [#24076] Don't warn for <FH> err FOO. */
    {
d3593 1
a3593 1
	    CopLINE_set(PL_curcop, PL_parser->copline);
d3606 1
a3606 1
    if (type == OP_ANDASSIGN || type == OP_ORASSIGN || type == OP_DORASSIGN)
a3633 1
    dVAR;
a3644 4
	/* Left or right arm of the conditional?  */
	const bool left = SvTRUE(((SVOP*)first)->op_sv);
	OP *live = left ? trueop : falseop;
	OP *const dead = left ? falseop : trueop;
d3649 6
a3654 6
	if (PL_madskills) {
	    /* This is all dead code when PERL_MAD is not defined.  */
	    live = newUNOP(OP_NULL, 0, live);
	    op_getmad(first, live, 'C');
	    op_getmad(dead, live, left ? 'e' : 't');
	} else {
d3656 2
a3657 1
	    op_free(dead);
a3658 1
	return live;
a3688 1
    dVAR;
a3734 1
    dVAR;
d3761 1
a3761 1
		if (k1 && (k1->op_type == OP_READDIR
d3764 1
a3764 1
		      || k1->op_type == OP_EACH))
d3794 1
a3794 2
Perl_newWHILEOP(pTHX_ I32 flags, I32 debuggable, LOOP *loop, I32
whileline, OP *expr, OP *block, OP *cont, I32 has_my)
a3795 1
    dVAR;
d3797 1
a3797 1
    OP *next = NULL;
d3821 1
a3821 1
		if (k1 && (k1->op_type == OP_READDIR
d3824 1
a3824 1
		      || k1->op_type == OP_EACH))
d3833 1
a3833 1
    else if (cont || has_my) {
a3846 1
    assert(block);
a3847 1
    assert(listop);
d3851 1
a3851 1
	PL_parser->copline = (line_t)whileline;
d3857 1
a3857 1
	    return NULL;		/* listop already freed by new_logop */
a3892 1
    dVAR;
a3897 1
    OP *madsv = NULL;
a3903 10

	    /* The op_type check is needed to prevent a possible segfault
	     * if the loop variable is undeclared and 'strict vars' is in
	     * effect. This is illegal but is nonetheless parsed, so we
	     * may reach this point with an OP_CONST where we're expecting
	     * an OP_GV.
	     */
	    if (cUNOPx(sv)->op_first->op_type == OP_GV
	     && cGVOPx_gv(cUNOPx(sv)->op_first) == PL_defgv)
		iterpflags |= OPpITER_DEF;
d3908 10
a3917 7
	    if (PL_madskills)
		madsv = sv;
	    else {
		sv->op_targ = 0;
		op_free(sv);
	    }
	    sv = NULL;
a3920 8
	if (padoff) {
	    SV *const namesv = PAD_COMPNAME_SV(padoff);
	    STRLEN len;
	    const char *const name = SvPV_const(namesv, len);

	    if (len == 2 && name[0] == '$' && name[1] == '_')
		iterpflags |= OPpITER_DEF;
	}
d3923 6
a3928 8
        const PADOFFSET offset = pad_findmy("$_");
	if (offset == NOT_IN_PAD || PAD_COMPNAME_FLAGS_isOUR(offset)) {
	    sv = newGVOP(OP_GV, 0, PL_defgv);
	}
	else {
	    padoff = offset;
	}
	iterpflags |= OPpITER_DEF;
d3942 1
a3942 1
	const UNOP* const flip = (UNOP*)((UNOP*)((BINOP*)expr)->op_first)->op_first;
d3949 1
a3949 1
	range->op_first = NULL;
a3956 3
#ifdef PERL_MAD
	op_getmad(expr,(OP*)listop,'O');
#else
a3957 1
#endif
d3970 1
a3970 1
     * for our $x () sets OPpOUR_INTRO */
d3977 1
a3977 1
	S_op_destroy(aTHX_ (OP*)loop);
d3981 1
a3981 1
    loop = (LOOP*)PerlMemShared_realloc(loop, sizeof(LOOP));
d3984 2
a3985 4
    wop = newWHILEOP(flags, 1, loop, forline, newOP(OP_ITER, 0), block, cont, 0);
    if (madsv)
	op_getmad(madsv, (OP*)loop, 'v');
    PL_parser->copline = forline;
a3991 1
    dVAR;
d3999 2
a4000 2
	    o = newPVOP(type, 0, savesharedpv(label->op_type == OP_CONST
					? SvPV_nolen_const(((SVOP*)label)->op_sv)
a4002 3
#ifdef PERL_MAD
	op_getmad(label,o,'L');
#else
a4003 1
#endif
a4015 177
/* if the condition is a literal array or hash
   (or @@{ ... } etc), make a reference to it.
 */
STATIC OP *
S_ref_array_or_hash(pTHX_ OP *cond)
{
    if (cond
    && (cond->op_type == OP_RV2AV
    ||  cond->op_type == OP_PADAV
    ||  cond->op_type == OP_RV2HV
    ||  cond->op_type == OP_PADHV))

	return newUNOP(OP_REFGEN,
	    0, mod(cond, OP_REFGEN));

    else
	return cond;
}

/* These construct the optree fragments representing given()
   and when() blocks.

   entergiven and enterwhen are LOGOPs; the op_other pointer
   points up to the associated leave op. We need this so we
   can put it in the context and make break/continue work.
   (Also, of course, pp_enterwhen will jump straight to
   op_other if the match fails.)
 */

STATIC OP *
S_newGIVWHENOP(pTHX_ OP *cond, OP *block,
		   I32 enter_opcode, I32 leave_opcode,
		   PADOFFSET entertarg)
{
    dVAR;
    LOGOP *enterop;
    OP *o;

    NewOp(1101, enterop, 1, LOGOP);
    enterop->op_type = enter_opcode;
    enterop->op_ppaddr = PL_ppaddr[enter_opcode];
    enterop->op_flags =  (U8) OPf_KIDS;
    enterop->op_targ = ((entertarg == NOT_IN_PAD) ? 0 : entertarg);
    enterop->op_private = 0;

    o = newUNOP(leave_opcode, 0, (OP *) enterop);

    if (cond) {
	enterop->op_first = scalar(cond);
	cond->op_sibling = block;

	o->op_next = LINKLIST(cond);
	cond->op_next = (OP *) enterop;
    }
    else {
	/* This is a default {} block */
	enterop->op_first = block;
	enterop->op_flags |= OPf_SPECIAL;

	o->op_next = (OP *) enterop;
    }

    CHECKOP(enter_opcode, enterop); /* Currently does nothing, since
    				       entergiven and enterwhen both
    				       use ck_null() */

    enterop->op_next = LINKLIST(block);
    block->op_next = enterop->op_other = o;

    return o;
}

/* Does this look like a boolean operation? For these purposes
   a boolean operation is:
     - a subroutine call [*]
     - a logical connective
     - a comparison operator
     - a filetest operator, with the exception of -s -M -A -C
     - defined(), exists() or eof()
     - /$re/ or $foo =~ /$re/
   
   [*] possibly surprising
 */
STATIC bool
S_looks_like_bool(pTHX_ const OP *o)
{
    dVAR;
    switch(o->op_type) {
	case OP_OR:
	    return looks_like_bool(cLOGOPo->op_first);

	case OP_AND:
	    return (
	    	looks_like_bool(cLOGOPo->op_first)
	     && looks_like_bool(cLOGOPo->op_first->op_sibling));

	case OP_NULL:
	    return (
		o->op_flags & OPf_KIDS
	    && looks_like_bool(cUNOPo->op_first));

	case OP_ENTERSUB:

	case OP_NOT:	case OP_XOR:
	/* Note that OP_DOR is not here */

	case OP_EQ:	case OP_NE:	case OP_LT:
	case OP_GT:	case OP_LE:	case OP_GE:

	case OP_I_EQ:	case OP_I_NE:	case OP_I_LT:
	case OP_I_GT:	case OP_I_LE:	case OP_I_GE:

	case OP_SEQ:	case OP_SNE:	case OP_SLT:
	case OP_SGT:	case OP_SLE:	case OP_SGE:
	
	case OP_SMARTMATCH:
	
	case OP_FTRREAD:  case OP_FTRWRITE: case OP_FTREXEC:
	case OP_FTEREAD:  case OP_FTEWRITE: case OP_FTEEXEC:
	case OP_FTIS:     case OP_FTEOWNED: case OP_FTROWNED:
	case OP_FTZERO:   case OP_FTSOCK:   case OP_FTCHR:
	case OP_FTBLK:    case OP_FTFILE:   case OP_FTDIR:
	case OP_FTPIPE:   case OP_FTLINK:   case OP_FTSUID:
	case OP_FTSGID:   case OP_FTSVTX:   case OP_FTTTY:
	case OP_FTTEXT:   case OP_FTBINARY:
	
	case OP_DEFINED: case OP_EXISTS:
	case OP_MATCH:	 case OP_EOF:

	    return TRUE;
	
	case OP_CONST:
	    /* Detect comparisons that have been optimized away */
	    if (cSVOPo->op_sv == &PL_sv_yes
	    ||  cSVOPo->op_sv == &PL_sv_no)
	    
		return TRUE;
		
	/* FALL THROUGH */
	default:
	    return FALSE;
    }
}

OP *
Perl_newGIVENOP(pTHX_ OP *cond, OP *block, PADOFFSET defsv_off)
{
    dVAR;
    assert( cond );
    return newGIVWHENOP(
    	ref_array_or_hash(cond),
    	block,
	OP_ENTERGIVEN, OP_LEAVEGIVEN,
	defsv_off);
}

/* If cond is null, this is a default {} block */
OP *
Perl_newWHENOP(pTHX_ OP *cond, OP *block)
{
    const bool cond_llb = (!cond || looks_like_bool(cond));
    OP *cond_op;

    if (cond_llb)
	cond_op = cond;
    else {
	cond_op = newBINOP(OP_SMARTMATCH, OPf_SPECIAL,
		newDEFSVOP(),
		scalar(ref_array_or_hash(cond)));
    }
    
    return newGIVWHENOP(
	cond_op,
	append_elem(block->op_type, block, newOP(OP_BREAK, OPf_SPECIAL)),
	OP_ENTERWHEN, OP_LEAVEWHEN, 0);
}

d4030 7
a4036 6
    dVAR;

    DEBUG_X(PerlIO_printf(Perl_debug_log,
	  "CV undef: cv=0x%"UVxf" comppad=0x%"UVxf"\n",
	    PTR2UV(cv), PTR2UV(PL_comppad))
    );
d4039 1
a4039 1
    if (CvFILE(cv) && !CvISXSUB(cv)) {
d4043 1
a4043 1
    CvFILE(cv) = NULL;
d4046 6
a4051 2
    if (!CvISXSUB(cv) && CvROOT(cv)) {
	if (SvTYPE(cv) == SVt_PVCV && CvDEPTH(cv))
d4053 1
d4059 2
a4060 2
	CvROOT(cv) = NULL;
	CvSTART(cv) = NULL;
d4064 1
a4064 1
    CvGV(cv) = NULL;
d4072 1
a4072 1
	CvOUTSIDE(cv) = NULL;
d4078 2
a4079 2
    if (CvISXSUB(cv) && CvXSUB(cv)) {
	CvXSUB(cv) = NULL;
d4086 1
a4086 2
Perl_cv_ckproto_len(pTHX_ const CV *cv, const GV *gv, const char *p,
		    const STRLEN len)
d4088 1
a4088 6
    /* Can't just use a strcmp on the prototype, as CONSTSUBs "cheat" by
       relying on SvCUR, and doubling up the buffer to hold CvFILE().  */
    if (((!p != !SvPOK(cv)) /* One has prototype, one has not.  */
	 || (p && (len != SvCUR(cv) /* Not the same length.  */
		   || memNE(p, SvPVX_const(cv), len))))
	 && ckWARN_d(WARN_PROTOTYPE)) {
d4090 1
a4090 1
	SV* name = NULL;
d4093 2
a4094 2
	    gv_efullname3(name = sv_newmortal(), gv, NULL);
	sv_setpvs(msg, "Prototype mismatch:");
d4096 1
a4096 1
	    Perl_sv_catpvf(aTHX_ msg, " sub %"SVf, SVfARG(name));
d4098 1
a4098 1
	    Perl_sv_catpvf(aTHX_ msg, " (%"SVf")", SVfARG(cv));
d4100 2
a4101 2
	    sv_catpvs(msg, ": none");
	sv_catpvs(msg, " vs ");
d4103 1
a4103 1
	    Perl_sv_catpvf(aTHX_ msg, "(%.*s)", (int) len, p);
d4105 2
a4106 2
	    sv_catpvs(msg, "none");
	Perl_warner(aTHX_ packWARN(WARN_PROTOTYPE), "%"SVf, SVfARG(msg));
d4129 3
a4131 6
    PERL_UNUSED_CONTEXT;
    if (!cv)
	return NULL;
    if (!(SvTYPE(cv) == SVt_PVCV || SvTYPE(cv) == SVt_PVFM))
	return NULL;
    return CvCONST(cv) ? (SV*)CvXSUBANY(cv).any_ptr : NULL;
a4133 20
/* op_const_sv:  examine an optree to determine whether it's in-lineable.
 * Can be called in 3 ways:
 *
 * !cv
 * 	look for a single OP_CONST with attached value: return the value
 *
 * cv && CvCLONE(cv) && !CvCONST(cv)
 *
 * 	examine the clone prototype, and if contains only a single
 * 	OP_CONST referencing a pad const, or a single PADSV referencing
 * 	an outer lexical, return a non-zero value to indicate the CV is
 * 	a candidate for "constizing" at clone time
 *
 * cv && CvCONST(cv)
 *
 *	We have just cloned an anon prototype that was marked as a const
 *	candidiate. Try to grab the current value, and in the case of
 *	PADSV, ignore it if it has multiple references. Return the value.
 */

d4135 1
a4135 1
Perl_op_const_sv(pTHX_ const OP *o, CV *cv)
d4137 1
a4137 5
    dVAR;
    SV *sv = NULL;

    if (PL_madskills)
	return NULL;
d4140 1
a4140 1
	return NULL;
d4159 1
a4159 1
	    return NULL;
d4162 1
a4162 1
	else if (cv && type == OP_CONST) {
d4165 7
a4171 9
		return NULL;
	}
	else if (cv && type == OP_PADSV) {
	    if (CvCONST(cv)) { /* newly cloned anon */
		sv = PAD_BASE_SV(CvPADLIST(cv), o->op_targ);
		/* the candidate should have 1 ref from this pad and 1 ref
		 * from the parent */
		if (!sv || SvREFCNT(sv) != 2)
		    return NULL;
a4172 6
		SvREADONLY_on(sv);
		return sv;
	    }
	    else {
		if (PAD_COMPNAME_FLAGS(o->op_targ) & SVf_FAKE)
		    sv = &PL_sv_undef; /* an arbitrary non-null value */
d4174 2
d4177 2
a4178 3
	else {
	    return NULL;
	}
d4180 2
a4184 3
#ifdef PERL_MAD
OP *
#else
a4185 1
#endif
a4187 5
#if 0
    /* This would be the return value, but the return cannot be reached.  */
    OP* pegop = newOP(OP_NULL, 0);
#endif

a4198 3
#ifdef PERL_MAD
    NORETURN_FUNCTION_END;
#endif
d4204 1
a4204 1
    return Perl_newATTRSUB(aTHX_ floor, o, proto, NULL, block);
a4209 1
    dVAR;
d4214 1
a4214 1
    register CV *cv = NULL;
d4216 3
a4218 10
    /* If the subroutine has no body, no attributes, and no builtin attributes
       then it's just a sub declaration, and we may be able to get away with
       storing with a placeholder scalar in the symbol table, rather than a
       full GV and CV.  If anything is present then it will take a full CV to
       store it.  */
    const I32 gv_fetch_flags
	= (block || attrs || (CvFLAGS(PL_compcv) & CVf_BUILTIN_ATTRS)
	   || PL_madskills)
	? GV_ADDMULTI : GV_ADDMULTI | GV_NOINIT;
    const char * const name = o ? SvPV_nolen_const(cSVOPo->op_sv) : NULL;
d4222 1
a4222 1
	ps = SvPV_const(((SVOP*)proto)->op_sv, ps_len);
d4225 1
a4225 1
	ps = NULL;
d4235 8
a4242 1
	aname = NULL;
d4244 6
a4249 13
    gv = name ? gv_fetchsv(cSVOPo->op_sv, gv_fetch_flags, SVt_PVCV)
	: gv_fetchpv(aname ? aname
		     : (PL_curstash ? "__ANON__" : "__ANON__::__ANON__"),
		     gv_fetch_flags, SVt_PVCV);

    if (!PL_madskills) {
	if (o)
	    SAVEFREEOP(o);
	if (proto)
	    SAVEFREEOP(proto);
	if (attrs)
	    SAVEFREEOP(attrs);
    }
d4259 1
a4259 1
	    cv_ckproto_len((CV*)gv, NULL, ps, ps_len);
a4264 1

d4267 1
d4271 1
a4271 1
    cv = (!name || GvCVGEN(gv)) ? NULL : GvCV(gv);
d4279 2
a4280 7
    if (!block || !ps || *ps || attrs
	|| (CvFLAGS(PL_compcv) & CVf_BUILTIN_ATTRS)
#ifdef PERL_MAD
	|| block->op_type == OP_NULL
#endif
	)
	const_sv = NULL;
d4282 1
a4282 1
	const_sv = op_const_sv(block, NULL);
d4298 1
a4298 1
	    cv_ckproto_len(cv, gv, ps, ps_len);
d4301 1
a4301 5
	    if ((!block
#ifdef PERL_MAD
		 || block->op_type == OP_NULL
#endif
		 )&& !attrs) {
d4310 4
a4313 5
	    if (block
#ifdef PERL_MAD
		&& block->op_type != OP_NULL
#endif
		) {
d4319 2
a4320 2
		    if (PL_parser && PL_parser->copline != NOLINE)
			CopLINE_set(PL_curcop, PL_parser->copline);
d4326 2
a4327 8
#ifdef PERL_MAD
		if (!PL_minus_c)	/* keep old one around for madskills */
#endif
		    {
			/* (PL_madskills unset in used file.) */
			SvREFCNT_dec(cv);
		    }
		cv = NULL;
d4332 1
a4332 1
	SvREFCNT_inc_simple_void_NN(const_sv);
a4338 1
	    CvISXSUB_on(cv);
d4341 2
a4342 2
	    GvCV(gv) = NULL;
	    cv = newCONSTSUB(NULL, name, const_sv);
a4343 9
        mro_method_changed_in( /* sub Foo::Bar () { 123 } */
            (CvGV(cv) && GvSTASH(CvGV(cv)))
                ? GvSTASH(CvGV(cv))
                : CvSTASH(cv)
                    ? CvSTASH(cv)
                    : PL_curstash
        );
	if (PL_madskills)
	    goto install_block;
d4347 1
d4357 1
a4357 5
	if (cv && (!block
#ifdef PERL_MAD
		    || block->op_type == OP_NULL
#endif
		    )) {
d4379 1
a4379 9
	if (
#ifdef PERL_MAD
	    (
#endif
	     !block
#ifdef PERL_MAD
	     || block->op_type == OP_NULL) && !PL_madskills
#endif
	     ) {
a4397 1
	PL_compcv = cv;
a4404 6
	    if (PL_madskills) {
		if (strEQ(name, "import")) {
		    PL_formfeed = (SV*)cv;
		    Perl_warner(aTHX_ packWARN(WARN_VOID), "%lx\n", (long)cv);
		}
	    }
d4406 1
a4406 1
            mro_method_changed_in(GvSTASH(gv)); /* sub Foo::bar { (shift)+1 } */
d4412 7
d4423 1
a4423 1
    if (PL_parser && PL_parser->error_count) {
d4425 1
a4425 1
	block = NULL;
d4437 1
a4437 1
		    Perl_croak(aTHX_ "%"SVf, SVfARG(ERRSV));
a4441 1
 install_block:
a4447 1
	block->op_attached = 1;
a4451 4
	    OP* const newblock = newSTATEOP(0, NULL, 0);
#ifdef PERL_MAD
	    op_getmad(block,newblock,'B');
#else
d4453 1
a4453 2
#endif
	    block = newblock;
a4454 2
	else
	    block->op_attached = 1;
d4474 3
d4478 3
a4480 4
	    SV * const sv = newSV(0);
	    SV * const tmpstr = sv_newmortal();
	    GV * const db_postponed = gv_fetchpvs("DB::postponed",
						  GV_ADDMULTI, SVt_PVHV);
d4486 2
a4487 3
	    gv_efullname3(tmpstr, gv, NULL);
	    (void)hv_store(GvHV(PL_DBsub), SvPVX_const(tmpstr),
		    SvCUR(tmpstr), sv, 0);
d4501 4
a4504 3
	if (name && ! (PL_parser && PL_parser->error_count))
	    process_special_blocks(name, gv, cv);
    }
d4506 2
a4507 13
  done:
    if (PL_parser)
	PL_parser->copline = NOLINE;
    LEAVE_SCOPE(floor);
    return cv;
}

STATIC void
S_process_special_blocks(pTHX_ const char *const fullname, GV *const gv,
			 CV *const cv)
{
    const char *const colon = strrchr(fullname,':');
    const char *const name = colon ? colon + 1 : fullname;
d4509 1
a4509 2
    if (*name == 'B') {
	if (strEQ(name, "BEGIN")) {
d4515 2
d4518 1
a4518 1
	    Perl_av_create_and_push(aTHX_ &PL_beginav, (SV*)cv);
d4523 1
a4523 1
	    CopHINTS_set(&PL_compiling, PL_hints);
d4526 27
a4552 38
	else
	    return;
    } else {
	if (*name == 'E') {
	    if strEQ(name, "END") {
		DEBUG_x( dump_sub(gv) );
		Perl_av_create_and_unshift_one(aTHX_ &PL_endav, (SV*)cv);
	    } else
		return;
	} else if (*name == 'U') {
	    if (strEQ(name, "UNITCHECK")) {
		/* It's never too late to run a unitcheck block */
		Perl_av_create_and_unshift_one(aTHX_ &PL_unitcheckav, (SV*)cv);
	    }
	    else
		return;
	} else if (*name == 'C') {
	    if (strEQ(name, "CHECK")) {
		if (PL_main_start && ckWARN(WARN_VOID))
		    Perl_warner(aTHX_ packWARN(WARN_VOID),
				"Too late to run CHECK block");
		Perl_av_create_and_unshift_one(aTHX_ &PL_checkav, (SV*)cv);
	    }
	    else
		return;
	} else if (*name == 'I') {
	    if (strEQ(name, "INIT")) {
		if (PL_main_start && ckWARN(WARN_VOID))
		    Perl_warner(aTHX_ packWARN(WARN_VOID),
				"Too late to run INIT block");
		Perl_av_create_and_push(aTHX_ &PL_initav, (SV*)cv);
	    }
	    else
		return;
	} else
	    return;
	DEBUG_x( dump_sub(gv) );
	GvCV(gv) = 0;		/* cv has been hijacked */
d4554 5
d4561 1
d4572 1
a4572 1
Perl_newCONSTSUB(pTHX_ HV *stash, const char *name, SV *sv)
a4573 1
    dVAR;
a4574 9
#ifdef USE_ITHREADS
    const char *const temp_p = CopFILE(PL_curcop);
    const STRLEN len = temp_p ? strlen(temp_p) : 0;
#else
    SV *const temp_sv = CopFILESV(PL_curcop);
    STRLEN len;
    const char *const temp_p = temp_sv ? SvPV_const(temp_sv, len) : NULL;
#endif
    char *const file = savepvn(temp_p, temp_p ? len : 0);
a4577 7
    if (IN_PERL_RUNTIME) {
	/* at runtime, it's not safe to manipulate PL_curcop: it may be
	 * an op shared between threads. Use a non-shared COP for our
	 * dirty work */
	 SAVEVPTR(PL_curcop);
	 PL_curcop = &PL_compiling;
    }
d4579 1
a4579 1
    CopLINE_set(PL_curcop, PL_parser ? PL_parser->copline : NOLINE);
d4591 1
a4591 5
    /* file becomes the CvFILE. For an XS, it's supposed to be static storage,
       and so doesn't get free()d.  (It's expected to be from the C pre-
       processor __FILE__ directive). But we need a dynamically allocated one,
       and we need it to get freed.  */
    cv = newXS_flags(name, const_sv_xsub, file, "", XS_DYNAMIC_FILENAME);
d4594 1
a4594 1
    Safefree(file);
a4595 1
#ifdef USE_ITHREADS
d4598 1
a4598 1
#endif
a4603 45
CV *
Perl_newXS_flags(pTHX_ const char *name, XSUBADDR_t subaddr,
		 const char *const filename, const char *const proto,
		 U32 flags)
{
    CV *cv = newXS(name, subaddr, filename);

    if (flags & XS_DYNAMIC_FILENAME) {
	/* We need to "make arrangements" (ie cheat) to ensure that the
	   filename lasts as long as the PVCV we just created, but also doesn't
	   leak  */
	STRLEN filename_len = strlen(filename);
	STRLEN proto_and_file_len = filename_len;
	char *proto_and_file;
	STRLEN proto_len;

	if (proto) {
	    proto_len = strlen(proto);
	    proto_and_file_len += proto_len;

	    Newx(proto_and_file, proto_and_file_len + 1, char);
	    Copy(proto, proto_and_file, proto_len, char);
	    Copy(filename, proto_and_file + proto_len, filename_len + 1, char);
	} else {
	    proto_len = 0;
	    proto_and_file = savepvn(filename, filename_len);
	}

	/* This gets free()d.  :-)  */
	sv_usepvn_flags((SV*)cv, proto_and_file, proto_and_file_len,
			SV_HAS_TRAILING_NUL);
	if (proto) {
	    /* This gives us the correct prototype, rather than one with the
	       file name appended.  */
	    SvCUR_set(cv, proto_len);
	} else {
	    SvPOK_off(cv);
	}
	CvFILE(cv) = proto_and_file + proto_len;
    } else {
	sv_setpv((SV *)cv, proto);
    }
    return cv;
}

d4607 1
a4607 2
Used by C<xsubpp> to hook up XSUBs as Perl subs.  I<filename> needs to be
static storage, as it is used directly as CvFILE(), without a copy being made.
d4613 1
a4613 1
Perl_newXS(pTHX_ const char *name, XSUBADDR_t subaddr, const char *filename)
a4614 1
    dVAR;
d4620 1
a4620 4
    if (!subaddr)
	Perl_croak(aTHX_ "panic: no address for '%s' in '%s'", name, filename);

    if ((cv = (name ? GvCV(gv) : NULL))) {
d4624 1
a4624 1
	    cv = NULL;
d4634 2
a4635 2
			const char *redefined_name = HvNAME_get(stash);
			if ( strEQ(redefined_name,"autouse") ) {
d4637 2
a4638 2
			    if (PL_parser && PL_parser->copline != NOLINE)
				CopLINE_set(PL_curcop, PL_parser->copline);
d4649 1
a4649 1
	    cv = NULL;
d4656 2
a4657 1
	cv = (CV*)newSV_type(SVt_PVCV);
d4661 1
a4661 1
            mro_method_changed_in(GvSTASH(gv)); /* newXS */
d4665 5
a4672 1
    CvISXSUB_on(cv);
d4675 41
a4715 2
    if (name)
	process_special_blocks(name, gv, cv);
d4719 1
a4722 3
#ifdef PERL_MAD
OP *
#else
a4723 1
#endif
a4725 1
    dVAR;
d4727 3
a4729 7
#ifdef PERL_MAD
    OP* pegop = newOP(OP_NULL, 0);
#endif

    GV * const gv = o
	? gv_fetchsv(cSVOPo->op_sv, GV_ADD, SVt_PVFM)
	: gv_fetchpvs("STDOUT", GV_ADD|GV_NOTQUAL, SVt_PVFM);
d4731 5
d4745 3
a4747 5
	    if (PL_parser && PL_parser->copline != NOLINE)
		CopLINE_set(PL_curcop, PL_parser->copline);
	    Perl_warner(aTHX_ packWARN(WARN_REDEFINE),
			o ? "Format %"SVf" redefined"
			: "Format STDOUT redefined", SVfARG(cSVOPo->op_sv));
a4764 4
#ifdef PERL_MAD
    op_getmad(o,pegop,'n');
    op_getmad_weak(block, pegop, 'b');
#else
d4766 1
a4766 3
#endif
    if (PL_parser)
	PL_parser->copline = NOLINE;
a4767 3
#ifdef PERL_MAD
    return pegop;
#endif
d4773 2
a4774 1
    return convert(OP_ANONLIST, OPf_SPECIAL, o);
d4780 2
a4781 1
    return convert(OP_ANONHASH, OPf_SPECIAL, o);
d4787 1
a4787 1
    return newANONATTRSUB(floor, proto, NULL, block);
a4800 1
    dVAR;
a4823 1
    dVAR;
a4848 1
    dVAR;
a4872 1
    dVAR;
d4887 9
a4903 1
    dVAR;
d4909 4
d4923 1
a4923 2
    if (!PL_madskills)
	cSVOPo->op_sv = NULL;
a4929 1
    dVAR;
d4938 1
a4938 1
    o->op_private = (U8)(PL_hints & HINT_INTEGER);
d4963 1
a4963 2
    const OP * const kid = cUNOPo->op_first;
    PERL_UNUSED_CONTEXT;
a4972 1
    dVAR;
d4980 7
a4986 6
	if (newop) {
	    const OPCODE type = newop->op_type;
	    if (newop->op_sibling || !(PL_opargs[type] & OA_RETSCALAR) ||
		    type == OP_PADAV || type == OP_PADHV ||
		    type == OP_RV2AV || type == OP_RV2HV)
		return o;
a4987 3
#ifdef PERL_MAD
	op_getmad(kUNOP->op_first,newop,'K');
#else
a4988 1
#endif
d5035 1
a5035 1
    dVAR;
a5038 5
	    OP * const newop
		= newUNOP(o->op_type, OPf_SPECIAL, newGVOP(OP_GV, 0, PL_argvgv));
#ifdef PERL_MAD
	    op_getmad(o,newop,'O');
#else
d5040 1
a5040 2
#endif
	    o = newop;
a5049 1
    dVAR;
a5059 3
#ifdef PERL_MAD
	    OP* const oldo = o;
#endif
a5061 1
#ifndef PERL_MAD
a5062 1
#endif
a5075 1
	    op_getmad(oldo,o,'O');
d5078 1
a5078 1
	else {
a5079 2
	    PL_cv_has_eval = 1;
	}
a5081 3
#ifdef PERL_MAD
	OP* const oldo = o;
#else
a5082 1
#endif
a5083 1
	op_getmad(oldo,o,'O');
a5085 10
    if ((PL_hints & HINT_LOCALIZE_HH) != 0 && GvHV(PL_hintgv)) {
	/* Store a copy of %^H that pp_entereval can pick up.
	   OPf_SPECIAL flags the opcode as being for this purpose,
	   so that it in turn will return a copy at every
	   eval.*/
	OP *hhop = newSVOP(OP_CONST, OPf_SPECIAL,
			   (SV*)Perl_hv_copy_hints_hv(aTHX_ GvHV(PL_hintgv)));
	cUNOPo->op_first->op_sibling = hhop;
	o->op_private |= OPpEVAL_HAS_HH;
    }
d5095 1
a5095 1
       SV * const * const svp = hv_fetchs(table, "vmsish_exit", FALSE);
a5121 1
    dVAR;
d5127 1
a5127 2
	    if (kid->op_type != OP_RV2CV
			&& !(PL_parser && PL_parser->error_count))
d5145 1
a5145 2
    dVAR;
    SVOP * const kid = (SVOP*)cUNOPo->op_first;
a5147 3
    if (o->op_type == OP_RV2CV)
	o->op_private &= ~1;

d5149 1
d5153 1
d5157 3
a5159 3
	    SV * const rsv = SvRV(kidsv);
	    const svtype type = SvTYPE(rsv);
            const char *badtype = NULL;
d5163 1
a5163 1
		if (type > SVt_PVMG)
d5167 1
a5167 1
		if (type != SVt_PVAV)
d5171 9
a5179 1
		if (type != SVt_PVHV)
d5181 1
d5184 1
a5184 1
		if (type != SVt_PVCV)
d5192 3
a5194 13
	else if ((o->op_type == OP_RV2HV || o->op_type == OP_RV2SV) &&
		(PL_hints & HINT_STRICT_REFS) && SvPOK(kidsv)) {
	    /* If this is an access to a stash, disable "strict refs", because
	     * stashes aren't auto-vivified at compile-time (unless we store
	     * symbols in them), and we don't want to produce a run-time
	     * stricture error when auto-vivifying the stash. */
	    const char *s = SvPV_nolen(kidsv);
	    const STRLEN l = SvCUR(kidsv);
	    if (l > 1 && s[l-1] == ':' && s[l-2] == ':')
		o->op_private &= ~HINT_STRICT_REFS;
	}
	if ((o->op_private & HINT_STRICT_REFS) && (kid->op_private & OPpCONST_BARE)) {
	    const char *badthing;
a5204 3
	    default:
		badthing = NULL;
		break;
d5208 2
a5209 2
			   "Can't use bareword (\"%"SVf"\") as %s ref while \"strict refs\" in use",
			   SVfARG(kidsv), badthing);
d5221 1
a5221 1
	    gv = gv_fetchsv(kidsv,
d5241 1
a5241 1
	    PAD_SETSV(kPADOP->op_padix, (SV*) SvREFCNT_inc_simple_NN(gv));
d5243 1
a5243 1
	    kid->op_sv = SvREFCNT_inc_simple_NN(gv);
a5254 1
    dVAR;
d5258 1
a5258 1
	NOOP;
a5261 1
	const OPCODE kidtype = kid->op_type;
d5263 2
a5264 1
	if (kidtype == OP_CONST && (kid->op_private & OPpCONST_BARE)) {
d5266 1
a5266 4
		gv_fetchsv(kid->op_sv, GV_ADD, SVt_PVIO));
#ifdef PERL_MAD
	    op_getmad(o,newop,'O');
#else
d5268 1
a5268 2
#endif
	    return newop;
d5270 3
a5272 1
	if ((PL_hints & HINT_FILETEST_ACCESS) && OP_IS_FILETEST_ACCESS(o))
d5274 1
a5274 3
	if (PL_check[kidtype] == MEMBER_TO_FPTR(Perl_ck_ftst)
		&& kidtype != OP_STAT && kidtype != OP_LSTAT)
	    o->op_private |= OPpFT_STACKED;
a5276 3
#ifdef PERL_MAD
	OP* const oldo = o;
#else
a5277 1
#endif
a5281 1
	op_getmad(oldo,o,'O');
a5288 1
    dVAR;
d5300 1
a5317 6
#ifdef PERL_MAD
	    if (!sibl && kid->op_type == OP_STUB) {
		numargs--;
		break;
	    }
#endif
d5346 1
d5348 1
a5348 1
			gv_fetchsv(((SVOP*)kid)->op_sv, GV_ADD, SVt_PVAV) ));
d5351 2
a5352 5
			    "Array @@%"SVf" missing the @@ in argument %"IVdf" of %s()",
			    SVfARG(((SVOP*)kid)->op_sv), (IV)numargs, PL_op_desc[type]);
#ifdef PERL_MAD
		    op_getmad(kid,newop,'K');
#else
a5353 1
#endif
d5366 1
d5368 1
a5368 1
			gv_fetchsv(((SVOP*)kid)->op_sv, GV_ADD, SVt_PVHV) ));
d5371 2
a5372 5
			    "Hash %%%"SVf" missing the %% in argument %"IVdf" of %s()",
			    SVfARG(((SVOP*)kid)->op_sv), (IV)numargs, PL_op_desc[type]);
#ifdef PERL_MAD
		    op_getmad(kid,newop,'K');
#else
a5373 1
#endif
d5398 3
a5400 2
			OP * const newop = newGVOP(OP_GV, 0,
			    gv_fetchsv(((SVOP*)kid)->op_sv, GV_ADD, SVt_PVIO));
a5403 3
#ifdef PERL_MAD
			op_getmad(kid,newop,'K');
#else
a5404 1
#endif
d5418 1
a5418 1
                            const char *name = NULL;
d5428 11
a5438 3
				SV *const namesv
				    = PAD_COMPNAME_SV(kid->op_targ);
				name = SvPV_const(namesv, len);
d5443 1
a5443 1
				GV * const gv = cGVOPx_gv(kUNOP->op_first);
a5449 1
				 OP *firstop;
d5451 1
a5451 1
				 name = NULL;
d5453 1
a5453 1
				      SV *tmpstr = NULL;
d5459 2
a5460 2
					  (firstop = ((UNOP*)op)->op_first) &&
					  (firstop->op_type == OP_GV)) {
d5462 1
a5462 1
					   GV * const gv = cGVOPx_gv(firstop);
d5497 1
a5497 1
				SvUPGRADE(namesv, SVt_PV);
a5520 6
#ifdef PERL_MAD
	if (kid && kid->op_type != OP_STUB)
	    return too_many_arguments(o,OP_DESC(o));
	o->op_private |= numargs;
#else
	/* FIXME - should the numargs move as for the PERL_MAD case?  */
a5523 1
#endif
a5526 6
#ifdef PERL_MAD
	OP *newop = newUNOP(type, 0, newDEFSVOP());
	op_getmad(o,newop,'O');
	return newop;
#else
	/* Ordering of these two is important to keep f_map.t passing.  */
a5528 1
#endif
a5542 1
    dVAR;
d5549 1
a5549 1
    if (!((gv = gv_fetchpvs("glob", GV_NOTQUAL, SVt_PVCV))
d5552 1
a5552 1
	gv = gv_fetchpvs("CORE::GLOBAL::glob", 0, SVt_PVCV);
d5561 3
a5563 3
		newSVpvs("File::Glob"), NULL, NULL, NULL);
	gv = gv_fetchpvs("CORE::GLOBAL::glob", 0, SVt_PVCV);
	glob_gv = gv_fetchpvs("File::Glob::csh_glob", 0, SVt_PVCV);
d5565 1
a5565 1
	SvREFCNT_inc_void((SV*)GvCV(gv));
d5597 1
a5597 2
    dVAR;
    LOGOP *gwop = NULL;
a5599 1
    PADOFFSET offset;
d5602 1
a5602 1
    /* don't allocate gwop here, as we may leak it if PL_parser->error_count > 0 */
a5612 1
	NewOp(1101, gwop, 1, LOGOP);
d5622 1
a5622 1
    if (PL_parser && PL_parser->error_count)
a5628 2
    if (!gwop)
	NewOp(1101, gwop, 1, LOGOP);
d5633 1
d5635 1
a5636 9
    offset = pad_findmy("$_");
    if (offset == NOT_IN_PAD || PAD_COMPNAME_FLAGS_isOUR(offset)) {
	o->op_private = gwop->op_private = 0;
	gwop->op_targ = pad_alloc(type, SVs_PADTMP);
    }
    else {
	o->op_private = gwop->op_private = OPpGREP_LEX;
	gwop->op_targ = o->op_targ = offset;
    }
a5712 16
Perl_ck_readline(pTHX_ OP *o)
{
    if (!(o->op_flags & OPf_KIDS)) {
	OP * const newop
	    = newUNOP(OP_READLINE, 0, newGVOP(OP_GV, 0, PL_argvgv));
#ifdef PERL_MAD
	op_getmad(o,newop,'O');
#else
	op_free(o);
#endif
	return newop;
    }
    return o;
}

OP *
a5749 28
Perl_ck_smartmatch(pTHX_ OP *o)
{
    dVAR;
    if (0 == (o->op_flags & OPf_SPECIAL)) {
	OP *first  = cBINOPo->op_first;
	OP *second = first->op_sibling;
	
	/* Implicitly take a reference to an array or hash */
	first->op_sibling = NULL;
	first = cBINOPo->op_first = ref_array_or_hash(first);
	second = first->op_sibling = ref_array_or_hash(second);
	
	/* Implicitly take a reference to a regular expression */
	if (first->op_type == OP_MATCH) {
	    first->op_type = OP_QR;
	    first->op_ppaddr = PL_ppaddr[OP_QR];
	}
	if (second->op_type == OP_MATCH) {
	    second->op_type = OP_QR;
	    second->op_ppaddr = PL_ppaddr[OP_QR];
        }
    }
    
    return o;
}


OP *
d5752 1
a5752 2
    dVAR;
    OP * const kid = cLISTOPo->op_first;
d5757 1
a5757 4
	&& !(kid->op_private & OPpTARGET_MY)
	/* Keep the full thing for madskills */
	&& !PL_madskills
	)
a5775 28
    if (kid->op_sibling) {
	OP *kkid = kid->op_sibling;
	if (kkid->op_type == OP_PADSV
		&& (kkid->op_private & OPpLVAL_INTRO)
		&& SvPAD_STATE(*av_fetch(PL_comppad_name, kkid->op_targ, FALSE))) {
	    const PADOFFSET target = kkid->op_targ;
	    OP *const other = newOP(OP_PADSV,
				    kkid->op_flags
				    | ((kkid->op_private & ~OPpLVAL_INTRO) << 8));
	    OP *const first = newOP(OP_NULL, 0);
	    OP *const nullop = newCONDOP(0, first, o, other);
	    OP *const condop = first->op_next;
	    /* hijacking PADSTALE for uninitialized state variables */
	    SvPADSTALE_on(PAD_SVl(target));

	    condop->op_type = OP_ONCE;
	    condop->op_ppaddr = PL_ppaddr[OP_ONCE];
	    condop->op_targ = target;
	    other->op_targ = target;

	    /* Because we change the type of the op here, we will skip the
	       assinment binop->op_last = binop->op_first->op_sibling; at the
	       end of Perl_newBINOP(). So need to do it here. */
	    cBINOPo->op_last = cBINOPo->op_first->op_sibling;

	    return nullop;
	}
    }
d5782 1
a5782 10
    dVAR;
    if (o->op_type != OP_QR && PL_compcv) {
	const PADOFFSET offset = pad_findmy("$_");
	if (offset != NOT_IN_PAD && !(PAD_COMPNAME_FLAGS_isOUR(offset))) {
	    o->op_targ = offset;
	    o->op_private |= OPpTARGET_MY;
	}
    }
    if (o->op_type == OP_MATCH || o->op_type == OP_QR)
	o->op_private |= OPpRUNTIME;
d5792 1
a5792 2
	const char * const method = SvPVX_const(sv);
	if (!(strchr(method, ':') || strchr(method, '\''))) {
d5795 1
a5795 1
		sv = newSVpvn_share(method, SvCUR(sv), 0);
d5798 1
a5798 1
		kSVOP->op_sv = NULL;
a5800 3
#ifdef PERL_MAD
	    op_getmad(o,cmop,'O');
#else
a5801 1
#endif
a5810 1
    PERL_UNUSED_CONTEXT;
a5816 1
    dVAR;
d5819 1
a5819 1
	SV **svp = hv_fetchs(table, "open_IN", FALSE);
d5828 1
a5828 1
	svp = hv_fetchs(table, "open_OUT", FALSE);
d5837 1
a5837 10
    if (o->op_type == OP_BACKTICK) {
	if (!(o->op_flags & OPf_KIDS)) {
	    OP * const newop = newUNOP(OP_BACKTICK, 0, newDEFSVOP());
#ifdef PERL_MAD
	    op_getmad(o,newop,'O');
#else
	    op_free(o);
#endif
	    return newop;
	}
a5838 1
    }
d5877 1
a5877 2
    dVAR;
    GV* gv = NULL;
a5885 2
	    STRLEN len;
	    const char *end;
d5897 1
a5897 4
	    s = SvPVX(sv);
	    len = SvCUR(sv);
	    end = s + len;
	    for (; s < end; s++) {
d5900 2
a5901 2
		    Move(s+2, s+1, end - s - 1, char);
		    --end;
d5904 1
a5904 2
	    SvEND_set(sv, end);
	    sv_catpvs(sv, ".pm");
d5909 4
a5912 8
    if (!(o->op_flags & OPf_SPECIAL)) { /* Wasn't written as CORE::require */
	/* handle override, if any */
	gv = gv_fetchpvs("require", GV_NOTQUAL, SVt_PVCV);
	if (!(gv && GvCVu(gv) && GvIMPORTED_CV(gv))) {
	    GV * const * const gvp = (GV**)hv_fetchs(PL_globalstash, "require", FALSE);
	    gv = gvp ? *gvp : NULL;
	}
    }
a5915 2
	OP * newop;

a5916 1
#ifndef PERL_MAD
d5918 5
a5922 8
#endif
	newop = ck_subr(newUNOP(OP_ENTERSUB, OPf_STACKED,
				append_elem(OP_LIST, kid,
					    scalar(newUNOP(OP_RV2CV, 0,
							   newGVOP(OP_GV, 0,
								   gv))))));
	op_getmad(o,newop,'O');
	return newop;
a5930 1
    dVAR;
d5939 10
a5951 1
    dVAR;
a5971 1
    dVAR;
d5976 12
a5987 3
	/* FIXME - this can be refactored to reduce code in #ifdefs  */
#ifdef PERL_MAD
	OP * const oldo = o;
a5988 2
	op_free(o);
#endif
d5991 1
a5991 5
#ifdef PERL_MAD
	o = newUNOP(type, 0, scalar(argop));
	op_getmad(oldo,o,'O');
	return o;
#else
a5992 1
#endif
a5999 1
    dVAR;
a6001 14
    if (o->op_type == OP_SORT && (PL_hints & HINT_LOCALIZE_HH) != 0) {
	HV * const hinthv = GvHV(PL_hintgv);
	if (hinthv) {
	    SV ** const svp = hv_fetchs(hinthv, "sort", FALSE);
	    if (svp) {
		const I32 sorthints = (I32)SvIV(*svp);
		if ((sorthints & HINT_SORT_QUICKSORT) != 0)
		    o->op_private |= OPpSORT_QSORT;
		if ((sorthints & HINT_SORT_STABLE) != 0)
		    o->op_private |= OPpSORT_STABLE;
	    }
	}
    }

a6062 1
    dVAR;
d6070 2
a6071 2
    GvMULTI_on(gv_fetchpvs("a", GV_ADD|GV_NOTQUAL, SVt_PV));
    GvMULTI_on(gv_fetchpvs("b", GV_ADD|GV_NOTQUAL, SVt_PV));
a6125 3
#ifdef PERL_MAD
    op_getmad(kid,o,'S');			      /* then delete it */
#else
a6126 1
#endif
a6131 1
    dVAR;
d6144 1
a6144 1
	cLISTOPo->op_first = kid = newSVOP(OP_CONST, 0, newSVpvs(" "));
d6151 1
a6151 1
	kid = pmruntime( newPMOP(OP_MATCH, OPf_SPECIAL), kid, 0);
a6173 1
    assert(kid->op_sibling);
a6191 1
	    const STRLEN len = re ? re->prelen : 6;
d6193 2
a6194 2
			"/%.*s/ should probably be written as \"%.*s\"",
			(int)len, pmstr, (int)len, pmstr);
a6202 1
    dVAR;
d6207 3
a6209 4
    const char *proto = NULL;
    const char *proto_end = NULL;
    CV *cv = NULL;
    GV *namegv = NULL;
d6213 1
a6213 2
    const char *e = NULL;
    bool delete_op = 0;
d6227 3
a6229 7
	    else {
		if (SvPOK(cv)) {
		    STRLEN len;
		    namegv = CvANON(cv) ? gv : CvGV(cv);
		    proto = SvPV((SV*)cv, len);
		    proto_end = proto + len;
		}
d6237 3
a6239 3
	    OP * const sib = ((UNOP*)o2)->op_first->op_sibling;
	    if (sib && sib->op_type == OP_CONST)
		sib->op_private &= ~OPpCONST_STRICT;
a6245 9
	OP* o3;
	if (PL_madskills && o2->op_type == OP_STUB) {
	    o2 = o2->op_sibling;
	    continue;
	}
	if (PL_madskills && o2->op_type == OP_NULL)
	    o3 = ((UNOP*)o2)->op_first;
	else
	    o3 = o2;
d6247 2
a6248 1
	    if (proto >= proto_end)
a6249 2

	    switch (*proto) {
a6253 4
	    case '_':
		/* _ must be at the end */
		if (proto[1] && proto[1] != ';')
		    goto oops;
d6267 1
a6267 1
		if (o3->op_type != OP_REFGEN && o3->op_type != OP_UNDEF)
d6270 1
a6270 1
			gv_ename(namegv), o3);
d6276 1
a6276 1
		if (o3->op_type == OP_RV2GV)
d6278 3
a6280 3
		else if (o3->op_type == OP_CONST)
		    o3->op_private &= ~OPpCONST_STRICT;
		else if (o3->op_type == OP_ENTERSUB) {
d6282 1
a6282 1
		    OP *gvop = ((UNOP*)o3)->op_first;
d6295 1
a6295 4
				SV * const n = newSVpvs("");
#ifdef PERL_MAD
				OP * const oldo2 = o2;
#else
a6296 1
#endif
a6298 1
				op_getmad(oldo2,o2,'O');
d6327 2
a6328 2
		         const char *p = proto;
			 const char *const end = proto;
d6330 1
d6332 3
a6334 3
			 bad_type(arg, Perl_form(aTHX_ "one of %.*s",
						 (int)(end - p), p),
				  gv_ename(namegv), o3);
d6339 1
a6339 1
		     if (o3->op_type == OP_RV2GV)
d6342 1
a6342 1
			  bad_type(arg, "symbol", gv_ename(namegv), o3);
d6345 1
a6345 1
		     if (o3->op_type == OP_ENTERSUB)
d6348 1
a6348 2
			  bad_type(arg, "subroutine entry", gv_ename(namegv),
				   o3);
d6351 5
a6355 4
		    if (o3->op_type == OP_RV2SV ||
			o3->op_type == OP_PADSV ||
			o3->op_type == OP_HELEM ||
			o3->op_type == OP_AELEM)
d6358 1
a6358 1
			bad_type(arg, "scalar", gv_ename(namegv), o3);
d6361 2
a6362 2
		    if (o3->op_type == OP_RV2AV ||
			o3->op_type == OP_PADAV)
d6365 1
a6365 1
			bad_type(arg, "array", gv_ename(namegv), o3);
d6368 2
a6369 2
		    if (o3->op_type == OP_RV2HV ||
			o3->op_type == OP_PADHV)
d6372 1
a6372 1
			 bad_type(arg, "hash", gv_ename(namegv), o3);
d6399 1
a6399 1
			   gv_ename(namegv), SVfARG(cv));
d6408 2
a6409 8
    if (o2 == cvop && proto && *proto == '_') {
	/* generate an access to $_ */
	o2 = newDEFSVOP();
	o2->op_sibling = prev->op_sibling;
	prev->op_sibling = o2; /* instead of cvop */
    }
    if (proto && !optional && proto_end > proto &&
	(*proto != '@@' && *proto != '%' && *proto != ';' && *proto != '_'))
a6410 9
    if(delete_op) {
#ifdef PERL_MAD
	OP * const oldo = o;
#else
	op_free(o);
#endif
	o=newSVOP(OP_CONST, 0, newSViv(0));
	op_getmad(oldo,o,'O');
    }
a6416 1
    PERL_UNUSED_CONTEXT;
a6421 16
Perl_ck_chdir(pTHX_ OP *o)
{
    if (o->op_flags & OPf_KIDS) {
	SVOP * const kid = (SVOP*)cUNOPo->op_first;

	if (kid && kid->op_type == OP_CONST &&
	    (kid->op_private & OPpCONST_BARE))
	{
	    o->op_flags |= OPf_SPECIAL;
	    kid->op_private &= ~OPpCONST_STRICT;
	}
    }
    return ck_fun(o);
}

OP *
a6439 12
Perl_ck_unpack(pTHX_ OP *o)
{
    OP *kid = cLISTOPo->op_first;
    if (kid->op_sibling) {
	kid = kid->op_sibling;
	if (!kid->op_sibling)
	    kid->op_sibling = newDEFSVOP();
    }
    return ck_fun(o);
}

OP *
d6443 1
a6443 1
    if ((o->op_flags & OPf_KIDS) && (o->op_private == 4)) {
d6462 2
a6463 2
    dVAR;
    register OP* oldop = NULL;
d6465 1
a6465 1
    if (!o || o->op_opt)
d6471 1
a6471 1
	if (o->op_opt)
d6473 4
a6476 3
	/* By default, this op has now been optimised. A couple of cases below
	   clear this again.  */
	o->op_opt = 1;
d6483 1
a6502 12
		else if (o->op_type == OP_CONST
			 && cSVOPo->op_sv == &PL_sv_undef) {
		    /* PL_sv_undef is hack - it's unsafe to store it in the
		       AV that is the pad, because av_fetch treats values of
		       PL_sv_undef as a "free" AV entry and will merrily
		       replace them with a new SV, causing pad_alloc to think
		       that this pad slot is free. (When, clearly, it is not)
		    */
		    SvOK_off(PAD_SVl(ix));
		    SvPADTMP_on(PAD_SVl(ix));
		    SvREADONLY_on(PAD_SVl(ix));
		}
d6510 1
a6510 1
		cSVOPo->op_sv = NULL;
d6514 1
d6521 1
a6521 1
			break; /* ignore_optimization */
d6531 2
d6536 1
d6551 5
a6555 3
	    /* op_seq functionality is now replaced by op_opt */
	    o->op_opt = 0;
	    /* FALL THROUGH */
d6559 1
a6559 1
	nothin:
a6561 1
		o->op_opt = 0;
d6564 1
d6570 1
a6570 1
		OP* const pop = (o->op_type == OP_PADAV) ?
d6578 1
a6578 1
		    (i = SvIV(((SVOP*)pop)->op_sv) - CopARYBASE_get(PL_curcop))
d6601 1
d6620 1
a6620 1
		    gv_efullname3(sv, gv, NULL);
d6623 1
a6623 1
				SVfARG(sv));
d6638 1
a6644 1
	case OP_DOR:
a6646 1
	case OP_DORASSIGN:
d6649 1
a6649 1
	case OP_ONCE:
d6657 1
d6669 2
d6672 5
a6676 6
	    assert(!(cPMOP->op_pmflags & PMf_ONCE));
	    while (cPMOP->op_pmstashstartu.op_pmreplstart &&
		   cPMOP->op_pmstashstartu.op_pmreplstart->op_type == OP_NULL)
		cPMOP->op_pmstashstartu.op_pmreplstart
		    = cPMOP->op_pmstashstartu.op_pmreplstart->op_next;
	    peep(cPMOP->op_pmstashstartu.op_pmreplstart);
d6680 1
d6684 12
a6695 11
		if (o->op_next->op_sibling) {
		    const OPCODE type = o->op_next->op_sibling->op_type;
		    if (type != OP_EXIT && type != OP_WARN && type != OP_DIE) {
			const line_t oldline = CopLINE(PL_curcop);
			CopLINE_set(PL_curcop, CopLINE((COP*)o->op_next));
			Perl_warner(aTHX_ packWARN(WARN_EXEC),
				    "Statement unlikely to be reached");
			Perl_warner(aTHX_ packWARN(WARN_EXEC),
				    "\t(Maybe you meant system() when you said exec()?)\n");
			CopLINE_set(PL_curcop, oldline);
		    }
d6702 1
a6702 1
            SV *lexname;
d6704 2
a6705 1
	    SV **svp, *sv;
d6709 2
d6719 1
a6719 1
					 SvUTF8(sv) ? -(I32)keylen : (I32)keylen,
d6732 1
a6732 1
	    if (!SvPAD_TYPED(lexname))
d6734 1
a6734 1
	    fields = (GV**)hv_fetchs(SvSTASH(lexname), "FIELDS", FALSE);
d6738 24
a6761 10
	    if (!hv_fetch(GvHV(*fields), key,
			SvUTF8(*svp) ? -(I32)keylen : (I32)keylen, FALSE))
	    {
		Perl_croak(aTHX_ "No such class field \"%s\" " 
			   "in variable %s of type %s", 
		      key, SvPV_nolen_const(lexname), HvNAME_get(SvSTASH(lexname)));
	    }

            break;
        }
d6767 2
a6768 1
	    SV **svp;
d6773 1
d6780 1
a6780 1
	    if (rop->op_type != OP_RV2HV)
d6782 2
a6783 16
	    if (rop->op_first->op_type == OP_PADSV)
		/* @@$hash{qw(keys here)} */
		rop = (UNOP*)rop->op_first;
	    else {
		/* @@{$hash}{qw(keys here)} */
		if (rop->op_first->op_type == OP_SCOPE 
		    && cLISTOPx(rop->op_first)->op_last->op_type == OP_PADSV)
		{
		    rop = (UNOP*)cLISTOPx(rop->op_first)->op_last;
		}
		else
		    break;
	    }
		    
	    lexname = *av_fetch(PL_comppad_name, rop->op_targ, TRUE);
	    if (!SvPAD_TYPED(lexname))
d6785 1
a6785 1
	    fields = (GV**)hv_fetchs(SvSTASH(lexname), "FIELDS", FALSE);
d6791 11
a6803 2
		if (key_op->op_type != OP_CONST)
		    continue;
d6806 4
a6809 4
		if (!hv_fetch(GvHV(*fields), key, 
			    SvUTF8(*svp) ? -(I32)keylen : (I32)keylen, FALSE))
		{
		    Perl_croak(aTHX_ "No such class field \"%s\" "
d6811 1
a6811 1
			  key, SvPV_nolen(lexname), HvNAME_get(SvSTASH(lexname)));
d6813 10
d6858 2
d6950 1
a7034 45

	case OP_SASSIGN: {
	    OP *rv2gv;
	    UNOP *refgen, *rv2cv;
	    LISTOP *exlist;

	    if ((o->op_flags && OPf_WANT) != OPf_WANT_VOID)
		break;

	    if ((o->op_private & ~OPpASSIGN_BACKWARDS) != 2)
		break;

	    rv2gv = ((BINOP *)o)->op_last;
	    if (!rv2gv || rv2gv->op_type != OP_RV2GV)
		break;

	    refgen = (UNOP *)((BINOP *)o)->op_first;

	    if (!refgen || refgen->op_type != OP_REFGEN)
		break;

	    exlist = (LISTOP *)refgen->op_first;
	    if (!exlist || exlist->op_type != OP_NULL
		|| exlist->op_targ != OP_LIST)
		break;

	    if (exlist->op_first->op_type != OP_PUSHMARK)
		break;

	    rv2cv = (UNOP*)exlist->op_last;

	    if (rv2cv->op_type != OP_RV2CV)
		break;

	    assert ((rv2gv->op_private & OPpDONT_INIT_GV) == 0);
	    assert ((o->op_private & OPpASSIGN_CV_TO_GV) == 0);
	    assert ((rv2cv->op_private & OPpMAY_RETURN_CONSTANT) == 0);

	    o->op_private |= OPpASSIGN_CV_TO_GV;
	    rv2gv->op_private |= OPpDONT_INIT_GV;
	    rv2cv->op_private |= OPpMAY_RETURN_CONSTANT;

	    break;
	}

d7036 2
a7037 5
	case OP_QR:
	case OP_MATCH:
	    if (!(cPMOP->op_pmflags & PMf_ONCE)) {
		assert (!cPMOP->op_pmstashstartu.op_pmreplstart);
	    }
d7045 2
a7046 2
const char*
Perl_custom_op_name(pTHX_ const OP* o)
a7047 1
    dVAR;
d7064 2
a7065 2
const char*
Perl_custom_op_desc(pTHX_ const OP* o)
a7066 1
    dVAR;
a7088 1
    dVAR;
a7090 1
	NOOP;
@


1.1.1.12
log
@import perl 5.10.1
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
d12 5
a16 7
 * 'You see: Mr. Drogo, he married poor Miss Primula Brandybuck.  She was
 *  our Mr. Bilbo's first cousin on the mother's side (her mother being the
 *  youngest of the Old Took's daughters); and Mr. Drogo was his second
 *  cousin.  So Mr. Frodo is his first *and* second cousin, once removed
 *  either way, as the saying is, if you follow me.'       --the Gaffer
 *
 *     [p.23 of _The Lord of the Rings_, I/i: "A Long-Expected Party"]
d93 1
a93 1
   record, with deletes written by C<Perl_magic_clearhint>. C<SAVEHINTS>
a118 1
    dVAR;
d130 1
a130 1
	PL_OpPtr = (I32**) mmap(0, PERL_SLAB_SIZE*sizeof(I32*), PROT_READ|PROT_WRITE,
d162 1
a162 1
	PL_slabs = (I32**) realloc(PL_slabs, sizeof(I32**) * (PL_slab_count + 1));
a211 3

    PERL_ARGS_ASSERT_SLAB_TO_RW;

a234 1
    PERL_ARGS_ASSERT_OP_REFCNT_DEC;
a246 1
    PERL_ARGS_ASSERT_SLAB_FREE;
a261 1
		    dVAR;
a304 3

    PERL_ARGS_ASSERT_GV_ENAME;

a311 2
    PERL_ARGS_ASSERT_NO_FH_ALLOWED;

a319 2
    PERL_ARGS_ASSERT_TOO_FEW_ARGUMENTS;

a326 2
    PERL_ARGS_ASSERT_TOO_MANY_ARGUMENTS;

a333 2
    PERL_ARGS_ASSERT_BAD_TYPE;

a340 2
    PERL_ARGS_ASSERT_NO_BAREWORD_ALLOWED;

a356 2
    PERL_ARGS_ASSERT_ALLOCMY;

d476 2
d485 1
a485 5
    if (type == OP_NEXTSTATE || type == OP_SETSTATE || type == OP_DBSTATE
	    || (type == OP_NULL /* the COP might have been null'ed */
		&& ((OPCODE)o->op_targ == OP_NEXTSTATE
		    || (OPCODE)o->op_targ == OP_SETSTATE
		    || (OPCODE)o->op_targ == OP_DBSTATE))) {
a488 3
    if (type == OP_NULL)
	type = (OPCODE)o->op_targ;

a506 3

    PERL_ARGS_ASSERT_OP_CLEAR;

d526 1
a526 1
	    o->op_type = (Optype)o->op_targ;
d608 1
a608 1
	SvREFCNT_dec(MUTABLE_SV(cPMOPo->op_pmreplrootu.op_pmtargetgv));
d616 2
a617 2
        /* we use the same protection as the "SAFE" version of the PM_ macros
         * here since sv_clean_all might release some PMOPs
d622 2
a625 1
	    ReREFCNT_dec(PM_GETRE(cPMOPo));
d629 1
a629 1
            PM_SETRE_OFFSET(cPMOPo, (cPMOPo)->op_pmoffset);
a630 3
#else
	ReREFCNT_dec(PM_GETRE(cPMOPo));
	PM_SETRE(cPMOPo, NULL);
a644 2
    PERL_ARGS_ASSERT_COP_FREE;

a660 3

    PERL_ARGS_ASSERT_FORGET_PMOP;

d662 1
a662 1
	MAGIC * const mg = mg_find((const SV *)pmstash, PERL_MAGIC_symtab);
a695 2
    PERL_ARGS_ASSERT_FIND_AND_FORGET_PMOPS;

a715 3

    PERL_ARGS_ASSERT_OP_NULL;

a749 2
    PERL_ARGS_ASSERT_LINKLIST;

a789 3

    PERL_ARGS_ASSERT_SCALARBOOLEAN;

a870 1
	break;
a883 2
    PERL_ARGS_ASSERT_SCALARVOID;

a939 1
    case OP_SMARTMATCH:
a1006 1
	    /* Otherwise it's "Useless use of grep iterator" */
a1625 2
    PERL_ARGS_ASSERT_SCALAR_MOD_TYPE;

a1673 2
    PERL_ARGS_ASSERT_IS_HANDLE_CONSTRUCTOR;

a1710 2
    PERL_ARGS_ASSERT_DOREF;

a1801 2
    PERL_ARGS_ASSERT_DUP_ATTRLIST;

a1830 2
    PERL_ARGS_ASSERT_APPLY_ATTRS;

a1867 2
    PERL_ARGS_ASSERT_APPLY_ATTRS_MY;

a1927 2
    PERL_ARGS_ASSERT_APPLY_ATTRS_STRING;

d1949 1
a1949 1
						       newRV(MUTABLE_SV(cv))),
a1958 2
    PERL_ARGS_ASSERT_MY_KID;

d1993 2
a1994 2
			 type == OP_RV2AV ? MUTABLE_SV(GvAV(gv)) :
			 type == OP_RV2HV ? MUTABLE_SV(GvHV(gv)) : MUTABLE_SV(gv)),
a2037 2
    PERL_ARGS_ASSERT_MY_ATTRS;

a2067 2
    PERL_ARGS_ASSERT_MY;

a2087 2
    PERL_ARGS_ASSERT_BIND_MATCH;

a2222 3

    PERL_ARGS_ASSERT_NEWPROG;

d2258 1
a2258 1
		XPUSHs(MUTABLE_SV(CopFILEGV(&PL_compiling)));
d2260 1
a2260 1
		call_sv(MUTABLE_SV(cv), G_DISCARD);
a2269 3

    PERL_ARGS_ASSERT_LOCALIZE;

a2327 2
    PERL_ARGS_ASSERT_JMAYBE;

d2340 1
a2340 1
    register OP * VOL curop;
a2348 1
    COP not_compiling;
a2350 2
    PERL_ARGS_ASSERT_FOLD_CONSTANTS;

a2384 1
	break;
a2409 7
    /* Verify that we don't need to save it:  */
    assert(PL_curcop == &PL_compiling);
    StructCopy(&PL_compiling, &not_compiling, COP);
    PL_curcop = &not_compiling;
    /* The above ensures that we run with all the correct hints of the
       currently compiling COP, but that IN_PERL_RUNTIME is not true. */
    assert(IN_PERL_RUNTIME);
d2428 1
a2428 1
	CLEAR_ERRSV();
a2442 1
    PL_curcop = &PL_compiling;
d2455 1
a2455 1
	newop = newGVOP(OP_GV, 0, MUTABLE_GV(sv));
d2457 1
a2457 1
	newop = newSVOP(OP_CONST, 0, MUTABLE_SV(sv));
a2642 2
    PERL_ARGS_ASSERT_TOKEN_FREE;

a2653 3

    PERL_ARGS_ASSERT_TOKEN_GETMAD;

d2666 1
a2666 1
	SvPVX((const SV *)tm->mad_val)[0] == 'q')
a2816 2
    PERL_ARGS_ASSERT_NEWMADSV;

d2855 1
a2855 1
	sv_free(MUTABLE_SV(mp->mad_val));
a3033 3

    PERL_ARGS_ASSERT_PMTRANS;

d3230 1
a3230 1
	swash = MUTABLE_SV(swash_init("utf8", "", listsv, bits, none));
a3235 1
	SvREADONLY_on(swash);
d3243 1
a3243 1
	    (void)hv_store(MUTABLE_HV(SvRV(swash)), "FINAL", 5,
a3400 2
    PERL_ARGS_ASSERT_PMRUNTIME;

d3535 1
a3535 1
		     || RX_EXTFLAGS(PM_GETRE(pm)) & RXf_EVAL_SEEN)))
a3570 3

    PERL_ARGS_ASSERT_NEWSVOP;

a3589 3

    PERL_ARGS_ASSERT_NEWPADOP;

d3612 1
a3612 3

    PERL_ARGS_ASSERT_NEWGVOP;

a3651 2
    PERL_ARGS_ASSERT_PACKAGE;

a3691 2
    PERL_ARGS_ASSERT_UTILIZE;

d3811 1
a3811 5
method, similar to C<use Foo::Bar VERSION LIST>.  They must be
terminated with a final NULL pointer.  Note that this list can only
be omitted when the PERL_LOADMOD_NOIMPORT flag has been used.
Otherwise at least a single NULL pointer to designate the default
import list is required.
a3818 3

    PERL_ARGS_ASSERT_LOAD_MODULE;

a3829 1
    PERL_ARGS_ASSERT_LOAD_MODULE_NOCONTEXT;
d3841 1
a3842 3

    PERL_ARGS_ASSERT_VLOAD_MODULE;

a3885 2
    PERL_ARGS_ASSERT_DOFILE;

a3979 1
	bool maybe_common_vars = TRUE;
a3996 59
	if ((left->op_type == OP_LIST
	     || (left->op_type == OP_NULL && left->op_targ == OP_LIST)))
	{
	    OP* lop = ((LISTOP*)left)->op_first;
	    maybe_common_vars = FALSE;
	    while (lop) {
		if (lop->op_type == OP_PADSV ||
		    lop->op_type == OP_PADAV ||
		    lop->op_type == OP_PADHV ||
		    lop->op_type == OP_PADANY) {
		    if (!(lop->op_private & OPpLVAL_INTRO))
			maybe_common_vars = TRUE;

		    if (lop->op_private & OPpPAD_STATE) {
			if (left->op_private & OPpLVAL_INTRO) {
			    /* Each variable in state($a, $b, $c) = ... */
			}
			else {
			    /* Each state variable in
			       (state $a, my $b, our $c, $d, undef) = ... */
			}
			yyerror(no_list_state);
		    } else {
			/* Each my variable in
			   (state $a, my $b, our $c, $d, undef) = ... */
		    }
		} else if (lop->op_type == OP_UNDEF ||
			   lop->op_type == OP_PUSHMARK) {
		    /* undef may be interesting in
		       (state $a, undef, state $c) */
		} else {
		    /* Other ops in the list. */
		    maybe_common_vars = TRUE;
		}
		lop = lop->op_sibling;
	    }
	}
	else if ((left->op_private & OPpLVAL_INTRO)
		&& (   left->op_type == OP_PADSV
		    || left->op_type == OP_PADAV
		    || left->op_type == OP_PADHV
		    || left->op_type == OP_PADANY))
	{
	    maybe_common_vars = FALSE;
	    if (left->op_private & OPpPAD_STATE) {
		/* All single variable list context state assignments, hence
		   state ($a) = ...
		   (state $a) = ...
		   state @@a = ...
		   state (@@a) = ...
		   (state @@a) = ...
		   state %a = ...
		   state (%a) = ...
		   (state %a) = ...
		*/
		yyerror(no_list_state);
	    }
	}

d4011 1
a4011 1
	if (maybe_common_vars) {
d4046 1
a4046 1
			    GV *const gv = MUTABLE_GV(PAD_SVl(((PMOP*)curop)->op_pmreplrootu.op_pmtargetoff));
d4072 48
d4142 1
a4142 1
			    = MUTABLE_GV(cSVOPx(tmpop)->op_sv);
d4161 1
a4161 1
			if (SvIOK(sv) && SvIVX(sv) == 0)
d4182 4
a4185 5
	    if (!PL_madskills) { /* assignment to $[ is ignored when making a mad dump */
		op_free(o);
		o = newSVOP(OP_CONST, 0, newSViv(CopARYBASE_get(&PL_compiling)));
		o->op_private |= OPpCONST_ARYBASE;
	    }
d4245 1
a4245 2
    if ((PERLDB_LINE || PERLDB_SAVESRC) && PL_curstash != PL_debstash) {
	/* this line can have a breakpoint - store the cop in IV */
a4255 2
    if (flags & OPf_SPECIAL)
	op_null((OP*)cop);
a4263 3

    PERL_ARGS_ASSERT_NEWLOGOP;

a4267 41
S_search_const(pTHX_ OP *o)
{
    switch (o->op_type) {
	case OP_CONST:
	    return o;
	case OP_NULL:
	    if (o->op_flags & OPf_KIDS)
		return search_const(cUNOPo->op_first);
	    break;
	case OP_LEAVE:
	case OP_SCOPE:
	case OP_LINESEQ:
	{
	    OP *kid;
	    if (!(o->op_flags & OPf_KIDS))
		return NULL;
	    kid = cLISTOPo->op_first;
	    do {
		switch (kid->op_type) {
		    case OP_ENTER:
		    case OP_NULL:
		    case OP_NEXTSTATE:
			kid = kid->op_sibling;
			break;
		    default:
			if (kid != cLISTOPo->op_last)
			    return NULL;
			goto last;
		}
	    } while (kid);
	    if (!kid)
		kid = cLISTOPo->op_last;
last:
	    return search_const(kid);
	}
    }

    return NULL;
}

STATIC OP *
d4273 2
a4274 8
    OP *first;
    OP *other;
    OP *cstop = NULL;

    first = *firstp;
    other = *otherp;

    PERL_ARGS_ASSERT_NEW_LOGOP;
d4298 4
a4301 5
    /* search for a constant op that could let us fold the test */
    if ((cstop = search_const(first))) {
	if (cstop->op_private & OPpCONST_STRICT)
	    no_bareword_allowed(cstop);
	else if ((cstop->op_private & OPpCONST_BARE) && ckWARN(WARN_BAREWORD))
d4303 3
a4305 3
	if ((type == OP_AND &&  SvTRUE(((SVOP*)cstop)->op_sv)) ||
	    (type == OP_OR  && !SvTRUE(((SVOP*)cstop)->op_sv)) ||
	    (type == OP_DOR && !SvOK(((SVOP*)cstop)->op_sv))) {
a4424 3
    OP *cstop;

    PERL_ARGS_ASSERT_NEWCONDOP;
d4432 1
a4432 1
    if ((cstop = search_const(first))) {
d4434 1
a4434 1
	const bool left = SvTRUE(((SVOP*)cstop)->op_sv);
d4437 3
a4439 3
        if (cstop->op_private & OPpCONST_BARE &&
	    cstop->op_private & OPpCONST_STRICT) {
	    no_bareword_allowed(cstop);
a4487 2
    PERL_ARGS_ASSERT_NEWRANGE;

a4698 2
    PERL_ARGS_ASSERT_NEWFOROP;

a4817 2
    PERL_ARGS_ASSERT_NEWLOOPEX;

a4881 2
    PERL_ARGS_ASSERT_NEWGIVWHENOP;

d4883 1
a4883 1
    enterop->op_type = (Optype)enter_opcode;
a4930 3

    PERL_ARGS_ASSERT_LOOKS_LIKE_BOOL;

a4932 1
	case OP_DOR:
d4948 1
a4972 2
	case OP_FLOP:

d4981 1
a4981 3
	    else
		return FALSE;

d4992 1
a4992 1
    PERL_ARGS_ASSERT_NEWGIVENOP;
a5006 2
    PERL_ARGS_ASSERT_NEWWHENOP;

a5036 2
    PERL_ARGS_ASSERT_CV_UNDEF;

d5062 1
a5062 1
    SvPOK_off(MUTABLE_SV(cv));		/* forget prototype */
d5074 1
a5074 1
	SvREFCNT_dec(MUTABLE_SV(CvXSUBANY(cv).any_ptr));
a5087 2
    PERL_ARGS_ASSERT_CV_CKPROTO_LEN;

d5139 1
a5139 1
    return CvCONST(cv) ? MUTABLE_SV(CvXSUBANY(cv).any_ptr) : NULL;
d5311 1
a5311 2
	    if (!SvPOK((const SV *)gv)
		&& !(SvIOK((const SV *)gv) && SvIVX((const SV *)gv) == -1)
d5316 1
a5316 1
	    cv_ckproto_len((const CV *)gv, NULL, ps, ps_len);
d5319 1
a5319 1
	    sv_setpvn(MUTABLE_SV(gv), ps, ps_len);
d5321 1
a5321 1
	    sv_setiv(MUTABLE_SV(gv), -1);
d5408 1
a5408 1
	    sv_setpvs(MUTABLE_SV(cv), "");  /* prototype is "" */
d5444 1
a5444 1
	    rcv = MUTABLE_SV(cv);
d5456 1
a5456 1
	    rcv = MUTABLE_SV(PL_compcv);
d5502 1
a5502 1
		    PL_formfeed = MUTABLE_SV(cv);
d5515 1
a5515 1
	sv_setpvn(MUTABLE_SV(cv), ps, ps_len);
a5539 6
    /* If we assign an optree to a PVCV, then we've defined a subroutine that
       the debugger could be able to set a breakpoint in, so signal to
       pp_entereval that it should not throw away any saved lines at scope
       exit.  */
       
    PL_breakable_sub_gen++;
d5598 1
a5598 1
		    call_sv(MUTABLE_SV(pcv), G_DISCARD);
a5620 2
    PERL_ARGS_ASSERT_PROCESS_SPECIAL_BLOCKS;

d5629 1
a5629 1
	    Perl_av_create_and_push(aTHX_ &PL_beginav, MUTABLE_SV(cv));
d5643 1
a5643 1
		Perl_av_create_and_unshift_one(aTHX_ &PL_endav, MUTABLE_SV(cv));
d5649 1
a5649 1
		Perl_av_create_and_unshift_one(aTHX_ &PL_unitcheckav, MUTABLE_SV(cv));
d5658 1
a5658 1
		Perl_av_create_and_unshift_one(aTHX_ &PL_checkav, MUTABLE_SV(cv));
d5667 1
a5667 1
		Perl_av_create_and_push(aTHX_ &PL_initav, MUTABLE_SV(cv));
d5693 2
a5694 1
    const char *const file = CopFILE(PL_curcop);
d5697 2
a5698 1
    const char *const file = temp_sv ? SvPV_nolen_const(temp_sv) : NULL;
d5700 1
d5728 1
a5728 2
    cv = newXS_flags(name, const_sv_xsub, file ? file : "", "",
		     XS_DYNAMIC_FILENAME);
d5731 1
a5748 2
    PERL_ARGS_ASSERT_NEWXS_FLAGS;

d5771 1
a5771 1
	sv_usepvn_flags(MUTABLE_SV(cv), proto_and_file, proto_and_file_len,
d5782 1
a5782 1
	sv_setpv(MUTABLE_SV(cv), proto);
a5804 2
    PERL_ARGS_ASSERT_NEWXS;

d5844 1
a5844 1
	cv = MUTABLE_CV(newSV_type(SVt_PVCV));
d5894 3
a5896 7
	    if (o) {
		Perl_warner(aTHX_ packWARN(WARN_REDEFINE),
			    "Format %"SVf" redefined", SVfARG(cSVOPo->op_sv));
	    } else {
		Perl_warner(aTHX_ packWARN(WARN_REDEFINE),
			    "Format STDOUT redefined");
	    }
d5951 1
a5951 1
		MUTABLE_SV(newATTRSUB(floor, 0, proto, attrs, block))));
a5957 3

    PERL_ARGS_ASSERT_OOPSAV;

a5981 3

    PERL_ARGS_ASSERT_OOPSHV;

a6007 3

    PERL_ARGS_ASSERT_NEWAVREF;

a6032 3

    PERL_ARGS_ASSERT_NEWHVREF;

a6055 3

    PERL_ARGS_ASSERT_NEWSVREF;

a6069 2
    PERL_ARGS_ASSERT_CK_ANONCODE;

a6079 3

    PERL_ARGS_ASSERT_CK_BITOP;

a6113 2

    PERL_ARGS_ASSERT_CK_CONCAT;
a6114 1

a6124 3

    PERL_ARGS_ASSERT_CK_SPAIR;

a6152 2
    PERL_ARGS_ASSERT_CK_DELETE;

a6180 2
    PERL_ARGS_ASSERT_CK_DIE;

a6191 2
    PERL_ARGS_ASSERT_CK_EOF;

a6211 3

    PERL_ARGS_ASSERT_CK_EVAL;

a6238 2
	    CHECKOP(OP_ENTERTRY, enter);

d6267 1
a6267 1
			   MUTABLE_SV(Perl_hv_copy_hints_hv(aTHX_ GvHV(PL_hintgv))));
a6276 2
    PERL_ARGS_ASSERT_CK_EXIT;

a6291 2
    PERL_ARGS_ASSERT_CK_EXEC;

a6307 3

    PERL_ARGS_ASSERT_CK_EXISTS;

d6322 1
a6322 1
	    Perl_croak(aTHX_ "%s argument is not a HASH or ARRAY element or a subroutine",
a6334 2
    PERL_ARGS_ASSERT_CK_RVCONST;

d6434 1
a6434 1
	    PAD_SETSV(kPADOP->op_padix, MUTABLE_SV(SvREFCNT_inc_simple_NN(gv)));
a6450 2
    PERL_ARGS_ASSERT_CK_FTST;

a6495 2
    PERL_ARGS_ASSERT_CK_FUN;

d6710 1
a6710 1
				    sv_setpvs(namesv, "$");
a6770 2
    PERL_ARGS_ASSERT_CK_GLOB;

d6791 1
a6791 1
	SvREFCNT_inc_void(MUTABLE_SV(GvCV(gv)));
a6828 2
    PERL_ARGS_ASSERT_CK_GREP;

a6887 2
    PERL_ARGS_ASSERT_CK_INDEX;

a6900 2
    PERL_ARGS_ASSERT_CK_LENGTHCONST;

a6908 3

    PERL_ARGS_ASSERT_CK_LFUN;

a6914 2
    PERL_ARGS_ASSERT_CK_DEFINED;

a6952 2
    PERL_ARGS_ASSERT_CK_READLINE;

a6969 3

    PERL_ARGS_ASSERT_CK_RFUN;

a6977 2
    PERL_ARGS_ASSERT_CK_LISTIOB;

a7035 3

    PERL_ARGS_ASSERT_CK_SASSIGN;

a7096 3

    PERL_ARGS_ASSERT_CK_MATCH;

a7112 3

    PERL_ARGS_ASSERT_CK_METHOD;

a7138 1
    PERL_ARGS_ASSERT_CK_NULL;
a7147 3

    PERL_ARGS_ASSERT_CK_OPEN;

a7204 2
    PERL_ARGS_ASSERT_CK_REPEAT;

a7219 2
    PERL_ARGS_ASSERT_CK_REQUIRE;

a7288 3

    PERL_ARGS_ASSERT_CK_RETURN;

a7301 3

    PERL_ARGS_ASSERT_CK_SELECT;

a7323 2
    PERL_ARGS_ASSERT_CK_SHIFT;

a7350 2
    PERL_ARGS_ASSERT_CK_SORT;

a7431 3

    PERL_ARGS_ASSERT_SIMPLIFY_SORT;

a7502 2
    PERL_ARGS_ASSERT_CK_SPLIT;

a7557 3

    PERL_ARGS_ASSERT_CK_JOIN;

d7561 2
a7562 2
	    const char *pmstr = re ? RX_PRECOMP_const(re) : "STRING";
	    const STRLEN len = re ? RX_PRELEN(re) : 6;
a7588 2
    PERL_ARGS_ASSERT_CK_SUBR;

d7605 1
a7605 1
		    proto = SvPV(MUTABLE_SV(cv), len);
d7727 1
a7727 1
			 while (*--p != '[') {}
a7827 1
    PERL_ARGS_ASSERT_CK_SVCONST;
a7851 2
    PERL_ARGS_ASSERT_CK_TRUNC;

a7870 3

    PERL_ARGS_ASSERT_CK_UNPACK;

a7881 2
    PERL_ARGS_ASSERT_CK_SUBSTR;

d8454 1
a8454 1
	    if ((o->op_flags & OPf_WANT) != OPf_WANT_VOID)
a8513 2
    PERL_ARGS_ASSERT_CUSTOM_OP_NAME;

a8533 2
    PERL_ARGS_ASSERT_CUSTOM_OP_DESC;

d8562 1
a8562 1
    ST(0) = MUTABLE_SV(XSANY.any_ptr);
@


1.1.1.13
log
@Perl 5.12.2 from CPAN
@
text
@a0 1
#line 2 "op.c"
d60 1
a60 1
top level node.)
a105 1
#define CALL_OPFREEHOOK(o) if (PL_opfreehook) CALL_FPTR(PL_opfreehook)(aTHX_ o)
d373 1
a373 1
Perl_allocmy(pTHX_ const char *const name, const STRLEN len, const U32 flags)
a380 8
    if (flags)
	Perl_croak(aTHX_ "panic: allocmy illegal flag bits 0x%" UVxf,
		   (UV)flags);

    /* Until we're using the length for real, cross check that we're being
       told the truth.  */
    assert(strlen(name) == len);

d382 1
a382 1
    if (len &&
d386 1
a386 1
	  (name[1] == '_' && (*name == '$' || len > 2))))
d390 2
a391 2
	    yyerror(Perl_form(aTHX_ "Can't use global %c^%c%.*s in \"%s\"",
			      name[0], toCTRL(name[1]), (int)(len - 2), name + 2,
d394 1
a394 1
	    yyerror(Perl_form(aTHX_ "Can't use global %.*s in \"%s\"", (int) len, name,
d399 11
d412 1
a412 3
    off = pad_add_name(name, len,
		       is_our ? padadd_OUR :
		       PL_parser->in_my == KEY_state ? padadd_STATE : 0,
d418 3
a420 1
		    )
a492 5
    /* Call the op_free hook if it has been set. Do it now so that it's called
     * at the right time for refcounted ops, but still before all of the kids
     * are freed. */
    CALL_OPFREEHOOK(o);

d507 1
a507 1
    if (type == OP_NEXTSTATE || type == OP_DBSTATE
d510 1
a561 1
    case OP_ENTERTRY:
a574 23
	    GV *gv = (o->op_type == OP_GV || o->op_type == OP_GVSV)
#ifdef USE_ITHREADS
			&& PL_curpad
#endif
			? cGVOPo_gv : NULL;
	    /* It's possible during global destruction that the GV is freed
	       before the optree. Whilst the SvREFCNT_inc is happy to bump from
	       0 to 1 on a freed SV, the corresponding SvREFCNT_dec from 1 to 0
	       will trigger an assertion failure, because the entry to sv_clear
	       checks that the scalar is not already freed.  A check of for
	       !SvIS_FREED(gv) turns out to be invalid, because during global
	       destruction the reference count can be forced down to zero
	       (with SVf_BREAK set).  In which case raising to 1 and then
	       dropping to 0 triggers cleanup before it should happen.  I
	       *think* that this might actually be a general, systematic,
	       weakness of the whole idea of SVf_BREAK, in that code *is*
	       allowed to raise and lower references during global destruction,
	       so any *valid* code that happens to do this during global
	       destruction might well trigger premature cleanup.  */
	    bool still_valid = gv && SvREFCNT(gv);

	    if (still_valid)
		SvREFCNT_inc_simple_void(gv);
a585 6
	    if (still_valid) {
		int try_downgrade = SvREFCNT(gv) == 2;
		SvREFCNT_dec(gv);
		if (try_downgrade)
		    gv_try_downgrade(gv);
	    }
a589 1
    case OP_HINTSEVAL:
a655 1
	    const IV offset = (cPMOPo)->op_pmoffset;
d657 4
a660 3
	    PL_regex_pad[offset] = &PL_sv_undef;
            sv_catpvn_nomg(PL_regex_pad[0], (const char *)&offset,
			   sizeof(offset));
d681 1
d789 2
a790 2
static OP *
S_linklist(pTHX_ OP *o)
d821 2
a822 2
static OP *
S_scalarkids(pTHX_ OP *o)
d878 5
a883 1
    case OP_SPLIT:
d918 2
a919 1
	Perl_ck_warner(aTHX_ packWARN(WARN_VOID), "Useless use of sort in scalar context");
d952 1
d955 1
d963 1
a963 1
	 || o->op_type == OP_RETURN || o->op_type == OP_REQUIRE)
a1063 11
    case OP_SPLIT:
	kid = cLISTOPo->op_first;
	if (kid && kid->op_type == OP_PUSHRE
#ifdef USE_ITHREADS
		&& !((PMOP*)kid)->op_pmreplrootu.op_pmtargetoff)
#else
		&& !((PMOP*)kid)->op_pmreplrootu.op_pmtargetgv)
#endif
	    useless = OP_DESC(o);
	break;

d1088 1
a1088 7
		if (SvOK(sv)) {
		    SV* msv = sv_2mortal(Perl_newSVpvf(aTHX_
				"a constant (%"SVf")", sv));
		    useless = SvPV_nolen(msv);
		}
		else
		    useless = "a constant (undef)";
a1139 14
	kid = cLOGOPo->op_first;
	if (kid->op_type == OP_NOT
	    && (kid->op_flags & OPf_KIDS)
	    && !PL_madskills) {
	    if (o->op_type == OP_AND) {
		o->op_type = OP_OR;
		o->op_ppaddr = PL_ppaddr[OP_OR];
	    } else {
		o->op_type = OP_AND;
		o->op_ppaddr = PL_ppaddr[OP_AND];
	    }
	    op_null(kid);
	}

d1173 4
d1179 6
d1186 2
a1187 2
    if (useless)
	Perl_ck_warner(aTHX_ packWARN(WARN_VOID), "Useless use of %s in void context", useless);
d1191 2
a1192 2
static OP *
S_listkids(pTHX_ OP *o)
d1271 4
d1279 2
a1280 2
static OP *
S_scalarseq(pTHX_ OP *o)
a1538 6
    case OP_AV2ARYLEN:
	PL_hints |= HINT_BLOCK_SCOPE;
	if (type == OP_LEAVESUBLV)
	    o->op_private |= OPpMAYBE_LVSUB;
	PL_modcount++;
	break;
d1544 1
d1665 4
a1668 2
	    Perl_ck_warner(aTHX_ packWARN(WARN_SYNTAX),
			   "Useless localization of %s", OP_DESC(o));
d1752 2
a1753 2
static OP *
S_refkids(pTHX_ OP *o, I32 type)
d2138 8
d2284 1
a2284 1
    const PADOFFSET offset = Perl_pad_findmy(aTHX_ STR_WITH_LEN("$_"), 0);
d2332 2
a2333 1
	    CV * const cv = get_cvs("DB::postponed", 0);
d2420 2
a2421 2
static OP *
S_fold_constants(pTHX_ register OP *o)
d2561 2
a2562 2
static OP *
S_gen_constant_list(pTHX_ register OP *o)
d2767 1
a2767 1
	SvPVX((SV *)tm->mad_val)[0] == 'q')
d2924 1
a2924 1
Perl_newMADPROP(pTHX_ char key, char type, void* val, I32 vlen)
d2975 2
a2976 2
static OP *
S_force_list(pTHX_ OP *o)
a2989 2
    assert((PL_opargs[type] & OA_CLASS_MASK) == OA_LISTOP);

a3022 6

    assert((PL_opargs[type] & OA_CLASS_MASK) == OA_BASEOP
	|| (PL_opargs[type] & OA_CLASS_MASK) == OA_BASEOP_OR_UNOP
	|| (PL_opargs[type] & OA_CLASS_MASK) == OA_FILESTATOP
	|| (PL_opargs[type] & OA_CLASS_MASK) == OA_LOOPEXOP);

a3045 8
    assert((PL_opargs[type] & OA_CLASS_MASK) == OA_UNOP
	|| (PL_opargs[type] & OA_CLASS_MASK) == OA_BASEOP_OR_UNOP
	|| (PL_opargs[type] & OA_CLASS_MASK) == OA_FILESTATOP
	|| (PL_opargs[type] & OA_CLASS_MASK) == OA_LOOPEXOP
	|| type == OP_SASSIGN
	|| type == OP_ENTERTRY
	|| type == OP_NULL );

a3068 4

    assert((PL_opargs[type] & OA_CLASS_MASK) == OA_BINOP
	|| type == OP_SASSIGN || type == OP_NULL );

d3113 2
a3114 2
static OP *
S_pmtrans(pTHX_ OP *o, OP *expr, OP *repl)
a3437 7

    if(del && rlen == tlen) {
	Perl_ck_warner(aTHX_ packWARN(WARN_MISC), "Useless use of /d modifier in transliteration operator"); 
    } else if(rlen > tlen) {
	Perl_ck_warner(aTHX_ packWARN(WARN_MISC), "Replacement list is longer than search list");
    }

a3456 2
    assert((PL_opargs[type] & OA_CLASS_MASK) == OA_PMOP);

d3470 5
a3474 14
    assert(SvPOK(PL_regex_pad[0]));
    if (SvCUR(PL_regex_pad[0])) {
	/* Pop off the "packed" IV from the end.  */
	SV *const repointer_list = PL_regex_pad[0];
	const char *p = SvEND(repointer_list) - sizeof(IV);
	const IV offset = *((IV*)p);

	assert(SvCUR(repointer_list) % sizeof(IV) == 0);

	SvEND_set(repointer_list, p);

	pmop->op_pmoffset = offset;
	/* This slot should be free, so assert this:  */
	assert(PL_regex_pad[offset] == &PL_sv_undef);
d3476 2
a3477 2
	SV * const repointer = &PL_sv_undef;
	av_push(PL_regex_padav, repointer);
d3544 1
a3544 1
	SV *pat = ((SVOP*)expr)->op_sv;
d3550 2
a3551 11
	if (DO_UTF8(pat)) {
	    assert (SvUTF8(pat));
	} else if (SvUTF8(pat)) {
	    /* Not doing UTF-8, despite what the SV says. Is this only if we're
	       trapped in use 'bytes'?  */
	    /* Make a copy of the octet sequence, but without the flag on, as
	       the compiler now honours the SvUTF8 flag on pat.  */
	    STRLEN len;
	    const char *const p = SvPV(pat, len);
	    pat = newSVpvn_flags(p, len, SVs_TEMP);
	}
a3682 4
    assert((PL_opargs[type] & OA_CLASS_MASK) == OA_SVOP
	|| (PL_opargs[type] & OA_CLASS_MASK) == OA_PVOP_OR_SVOP
	|| (PL_opargs[type] & OA_CLASS_MASK) == OA_FILESTATOP);

a3704 4
    assert((PL_opargs[type] & OA_CLASS_MASK) == OA_SVOP
	|| (PL_opargs[type] & OA_CLASS_MASK) == OA_PVOP_OR_SVOP
	|| (PL_opargs[type] & OA_CLASS_MASK) == OA_FILESTATOP);

a3742 4

    assert((PL_opargs[type] & OA_CLASS_MASK) == OA_PVOP_OR_SVOP
	|| (PL_opargs[type] & OA_CLASS_MASK) == OA_LOOPEXOP);

a3795 12
void
Perl_package_version( pTHX_ OP *v )
{
    dVAR;
    U32 savehints = PL_hints;
    PERL_ARGS_ASSERT_PACKAGE_VERSION;
    PL_hints &= ~HINT_STRICT_VARS;
    sv_setsv( GvSV(gv_fetchpvs("VERSION", GV_ADDMULTI, SVt_PV)), cSVOPx(v)->op_sv );
    PL_hints = savehints;
    op_free(v);
}

d3834 1
a3834 1
		Perl_croak(aTHX_ "Version number must be a constant number");
d4174 1
a4174 1
	    if (left->op_type == OP_PADSV) maybe_common_vars = FALSE;
a4327 1
		deprecate("assignment to $[");
d4361 4
a4375 10
    if (label) {
	cop->cop_hints_hash
	    = Perl_store_cop_label(aTHX_ cop->cop_hints_hash, label);
						     
	PL_hints |= HINT_BLOCK_SCOPE;
	/* It seems that we need to defer freeing this pointer, as other parts
	   of the grammar end up wanting to copy it after this op has been
	   created. */
	SAVEFREEPV(label);
    }
a4421 2
    PERL_ARGS_ASSERT_SEARCH_CONST;

a4468 3
    int prepend_not = 0;

    PERL_ARGS_ASSERT_NEW_LOGOP;
d4473 2
a4477 2
    assert((PL_opargs[type] & OA_CLASS_MASK) == OA_LOGOP);

d4479 1
a4479 1
    /* optimize AND and OR ops that have NOTs as children */
d4481 1
a4482 2
	&& ((first->op_flags & OPf_SPECIAL) /* unless ($x) { } */
	    || (other->op_type == OP_NOT))  /* if (!$x && !$y) { } */
d4489 6
a4494 5
	    op_null(first);
	    if (other->op_type == OP_NOT) { /* !a AND|OR !b => !(a OR|AND b) */
		op_null(other);
		prepend_not = 1; /* prepend a NOT op later */
	    }
d4501 2
a4502 2
	else if ((cstop->op_private & OPpCONST_BARE))
		Perl_ck_warner(aTHX_ packWARN(WARN_BAREWORD), "Bareword found in conditional");
a4515 2
	    if (other->op_type == OP_LEAVE)
		other = newUNOP(OP_NULL, OPf_SPECIAL, other);
d4530 2
a4531 1
		&& !(o2->op_private & OPpPAD_STATE))
d4533 2
a4534 2
		Perl_ck_warner_d(aTHX_ packWARN(WARN_DEPRECATED),
				 "Deprecated use of my() in false conditional");
d4612 1
a4612 1
    o = newUNOP(prepend_not ? OP_NOT : OP_NULL, 0, (OP*)logop);
a4652 2
	if (live->op_type == OP_LEAVE)
	    live = newUNOP(OP_NULL, OPf_SPECIAL, live);
d4744 1
a4744 3
	if (expr->op_type == OP_READLINE
	    || expr->op_type == OP_READDIR
	    || expr->op_type == OP_GLOB
d4753 1
a4753 1
		if (k2 && (k2->op_type == OP_READLINE || k2->op_type == OP_READDIR)
d4806 1
a4806 3
	if (expr->op_type == OP_READLINE
         || expr->op_type == OP_READDIR
         || expr->op_type == OP_GLOB
d4815 1
a4815 1
		if (k2 && (k2->op_type == OP_READLINE || k2->op_type == OP_READDIR)
d4945 1
a4945 1
        const PADOFFSET offset = Perl_pad_findmy(aTHX_ STR_WITH_LEN("$_"), 0);
a5026 2
    assert((PL_opargs[type] & OA_CLASS_MASK) == OA_LOOPEXOP);

a5155 1
	case OP_SCALAR:
d5356 1
a5356 1
Perl_cv_const_sv(pTHX_ const CV *const cv)
d5484 1
a5499 1
    bool has_name;
d5508 1
a5508 4
    if (name) {
	gv = gv_fetchsv(cSVOPo->op_sv, gv_fetch_flags, SVt_PVCV);
	has_name = TRUE;
    } else if (PERLDB_NAMEANON && CopLINE(PL_curcop)) {
d5513 1
a5513 8
	gv = gv_fetchsv(sv, gv_fetch_flags, SVt_PVCV);
	has_name = TRUE;
    } else if (PL_curstash) {
	gv = gv_fetchpvs("__ANON__", gv_fetch_flags, SVt_PVCV);
	has_name = FALSE;
    } else {
	gv = gv_fetchpvs("__ANON__::__ANON__", gv_fetch_flags, SVt_PVCV);
	has_name = FALSE;
d5515 7
d5536 2
a5537 1
		&& !(SvIOK((const SV *)gv) && SvIVX((const SV *)gv) == -1))
d5539 1
a5539 1
		Perl_ck_warner_d(aTHX_ packWARN(WARN_PROTOTYPE), "Runaway prototype");
d5555 6
d5574 6
d5595 1
a5595 3
		    if (CvLVALUE(PL_compcv) && ! CvLVALUE(cv) && ckWARN(WARN_MISC))
			Perl_warner(aTHX_ packWARN(WARN_MISC), "lvalue attribute ignored after the subroutine has been defined");
		    CvFLAGS(cv) |= (CvFLAGS(PL_compcv) & CVf_BUILTIN_ATTRS & ~CVf_LVALUE);
d5657 8
a5664 3
    if (cv) {				/* must reuse cv if autoloaded */
	/* transfer PL_compcv to cv */
	if (block
d5666 1
a5666 1
                  && block->op_type != OP_NULL
d5668 10
a5677 15
	) {
	    cv_flags_t existing_builtin_attrs = CvFLAGS(cv) & CVf_BUILTIN_ATTRS;
	    cv_undef(cv);
	    CvFLAGS(cv) = CvFLAGS(PL_compcv) | existing_builtin_attrs;
	    if (!CvWEAKOUTSIDE(cv))
		SvREFCNT_dec(CvOUTSIDE(cv));
	    CvOUTSIDE(cv) = CvOUTSIDE(PL_compcv);
	    CvOUTSIDE_SEQ(cv) = CvOUTSIDE_SEQ(PL_compcv);
	    CvOUTSIDE(PL_compcv) = 0;
	    CvPADLIST(cv) = CvPADLIST(PL_compcv);
	    CvPADLIST(PL_compcv) = 0;
	    /* inner references to PL_compcv must be fixed up ... */
	    pad_fixup_inner_anons(CvPADLIST(cv), PL_compcv, cv);
	    if (PERLDB_INTER)/* Advice debugger on the new sub. */
	      ++PL_sub_generation;
d5680 22
a5701 2
	    /* Might have had built-in attributes applied -- propagate them. */
	    CvFLAGS(cv) |= (CvFLAGS(PL_compcv) & CVf_BUILTIN_ATTRS);
d5703 12
d5718 2
d5728 1
a5728 2
		    /* diag_listed_as: SKIPME */
		    Perl_warner(aTHX_ packWARN(WARN_VOID), "0x%"UVxf"\n", PTR2UV(cv));
d5735 3
a5737 10
    if (!CvGV(cv)) {
	CvGV(cv) = gv;
	CvFILE_set_from_cop(cv, PL_curcop);
	CvSTASH(cv) = PL_curstash;
    }
    if (attrs) {
	/* Need to do a C<use attributes $stash_of_cv,\&cv,@@attrs>. */
	HV *stash = name && GvSTASH(CvGV(cv)) ? GvSTASH(CvGV(cv)) : PL_curstash;
	apply_attrs(stash, MUTABLE_SV(cv), attrs, FALSE);
    }
d5807 1
a5807 1
    if (has_name) {
d5888 3
a5890 3
		if (PL_main_start)
		    Perl_ck_warner(aTHX_ packWARN(WARN_VOID),
				   "Too late to run CHECK block");
d5897 3
a5899 3
		if (PL_main_start)
		    Perl_ck_warner(aTHX_ packWARN(WARN_VOID),
				   "Too late to run INIT block");
a5916 5
Passing NULL for SV creates a constant sub equivalent to C<sub BAR () {}>,
which won't be called if used as a destructor, but will suppress the overhead
of a call to C<AUTOLOAD>.  (This form, however, isn't eligible for inlining at
compile time.)

d6117 5
d6212 2
a6213 1
	Perl_ck_warner_d(aTHX_ packWARN(WARN_INTERNAL), "oops: oopsAV");
d6241 2
a6242 1
	Perl_ck_warner_d(aTHX_ packWARN(WARN_INTERNAL), "oops: oopsHV");
d6260 4
a6263 3
    else if ((o->op_type == OP_RV2AV || o->op_type == OP_PADAV)) {
	Perl_ck_warner_d(aTHX_ packWARN(WARN_DEPRECATED),
		       "Using an array as a reference is deprecated");
d6288 4
a6291 3
    else if ((o->op_type == OP_RV2HV || o->op_type == OP_PADHV)) {
	Perl_ck_warner_d(aTHX_ packWARN(WARN_DEPRECATED),
		       "Using a hash as a reference is deprecated");
d6358 6
a6363 5
	    Perl_ck_warner(aTHX_ packWARN(WARN_PRECEDENCE),
			   "Possible precedence problem on bitwise %c operator",
			   o->op_type == OP_BIT_OR ? '|'
			   : o->op_type == OP_BIT_AND ? '&' : '^'
			   );
a6438 2
	if (kid->op_private & OPpLVAL_INTRO)
	    o->op_private |= OPpLVAL_INTRO;
d6512 2
d6537 5
a6541 2
	/* Store a copy of %^H that pp_entereval can pick up. */
	OP *hhop = newSVOP(OP_HINTSEVAL, 0,
d6754 1
a6754 1
	if ((PL_hints & HINT_FILETEST_ACCESS) && OP_IS_FILETEST_ACCESS(o->op_type))
d6835 4
a6838 4
		    && !kid->op_sibling)
		    Perl_ck_warner(aTHX_ packWARN(WARN_SYNTAX),
				   "Useless use of %s with no values",
				   PL_op_desc[type]);
d6845 4
a6848 3
		    Perl_ck_warner_d(aTHX_ packWARN(WARN_DEPRECATED),
				   "Array @@%"SVf" missing the @@ in argument %"IVdf" of %s()",
				   SVfARG(((SVOP*)kid)->op_sv), (IV)numargs, PL_op_desc[type]);
d6868 4
a6871 3
		    Perl_ck_warner_d(aTHX_ packWARN(WARN_DEPRECATED),
				   "Hash %%%"SVf" missing the %% in argument %"IVdf" of %s()",
				   SVfARG(((SVOP*)kid)->op_sv), (IV)numargs, PL_op_desc[type]);
d7078 5
a7082 6
	if((glob_gv = gv_fetchpvs("File::Glob::csh_glob", 0, SVt_PVCV))) {
	    gv = gv_fetchpvs("CORE::GLOBAL::glob", 0, SVt_PVCV);
	    GvCV(gv) = GvCV(glob_gv);
	    SvREFCNT_inc_void(MUTABLE_SV(GvCV(gv)));
	    GvIMPORTED_CV_on(gv);
	}
d7127 4
a7130 4
        kid = cUNOPx(cLISTOPo->op_first->op_sibling)->op_first;
	if (kid->op_type != OP_SCOPE && kid->op_type != OP_LEAVE)
	    return no_fh_allowed(o);
	for (k = kid; k; k = k->op_next) {
d7158 1
a7158 1
    offset = Perl_pad_findmy(aTHX_ STR_WITH_LEN("$_"), 0);
d7193 9
d7216 1
a7216 1
    if ((o->op_flags & OPf_KIDS)) {
d7226 4
a7229 4
	    Perl_ck_warner_d(aTHX_ packWARN(WARN_DEPRECATED),
			   "defined(@@array) is deprecated");
	    Perl_ck_warner_d(aTHX_ packWARN(WARN_DEPRECATED),
			   "\t(Maybe you should just omit the defined()?)\n");
d7232 5
d7238 4
a7241 4
	    Perl_ck_warner_d(aTHX_ packWARN(WARN_DEPRECATED),
			   "defined(%%hash) is deprecated");
	    Perl_ck_warner_d(aTHX_ packWARN(WARN_DEPRECATED),
			   "\t(Maybe you should just omit the defined()?)\n");
d7412 1
a7412 1
	const PADOFFSET offset = Perl_pad_findmy(aTHX_ STR_WITH_LEN("$_"), 0);
d7472 1
a7472 3
	    STRLEN len = 0;
	    const char *d = SvPV_const(*svp, len);
	    const I32 mode = mode_from_discipline(d, len);
d7481 1
a7481 3
	    STRLEN len = 0;
	    const char *d = SvPV_const(*svp, len);
	    const I32 mode = mode_from_discipline(d, len);
d7607 1
a7607 1
    return scalar(ck_fun(o));
a7613 1
    OP *kid;
a7616 1
    kid = cLISTOPo->op_first->op_sibling;
d7618 2
a7619 1
	for (; kid; kid = kid->op_sibling)
a7620 13
    } else {
	for (; kid; kid = kid->op_sibling)
	    if ((kid->op_type == OP_NULL)
		&& ((kid->op_flags & (OPf_SPECIAL|OPf_KIDS)) == (OPf_SPECIAL|OPf_KIDS))) {
		/* This is a do block */
		OP *op = kUNOP->op_first;
		if (op->op_type == OP_LEAVE && op->op_flags & OPf_KIDS) {
		    op = cUNOPx(op)->op_first;
		    assert(op->op_type == OP_ENTER && !(op->op_flags & OPf_SPECIAL));
		    /* Force the use of the caller's context */
		    op->op_flags |= OPf_SPECIAL;
		}
	    }
a7621 1

d7658 8
a7665 1
	OP *argop = newUNOP(OP_RV2AV, 0,
a7667 1
	OP * const oldo = o;
a7671 1
	op_free(o);
d7870 3
a7872 3
    if (((PMOP *)kid)->op_pmflags & PMf_GLOBAL) {
      Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP),
		     "Use of /g modifier is meaningless in split");
d7937 1
d7940 13
a7952 21
	if (!(o->op_private & OPpENTERSUB_AMPER)) {
	    SVOP *tmpop = (SVOP*)((UNOP*)cvop)->op_first;
	    GV *gv = NULL;
	    switch (tmpop->op_type) {
		case OP_GV: {
		    gv = cGVOPx_gv(tmpop);
		    cv = GvCVu(gv);
		    if (!cv)
			tmpop->op_private |= OPpEARLY_CV;
		} break;
		case OP_CONST: {
		    SV *sv = cSVOPx_sv(tmpop);
		    if (SvROK(sv) && SvTYPE(SvRV(sv)) == SVt_PVCV)
			cv = (CV*)SvRV(sv);
		} break;
	    }
	    if (cv && SvPOK(cv)) {
		STRLEN len;
		namegv = gv && CvANON(cv) ? gv : CvGV(cv);
		proto = SvPV(MUTABLE_SV(cv), len);
		proto_end = proto + len;
a8247 125
OP *
Perl_ck_each(pTHX_ OP *o)
{
    dVAR;
    OP *kid = o->op_flags & OPf_KIDS ? cLISTOPo->op_first : NULL;

    PERL_ARGS_ASSERT_CK_EACH;

    if (kid) {
	if (kid->op_type == OP_PADAV || kid->op_type == OP_RV2AV) {
	    const unsigned new_type = o->op_type == OP_EACH ? OP_AEACH
		: o->op_type == OP_KEYS ? OP_AKEYS : OP_AVALUES;
	    o->op_type = new_type;
	    o->op_ppaddr = PL_ppaddr[new_type];
	}
	else if (!(kid->op_type == OP_PADHV || kid->op_type == OP_RV2HV
		    || (kid->op_type == OP_CONST && kid->op_private & OPpCONST_BARE)
		  )) {
	    bad_type(1, "hash or array", PL_op_desc[o->op_type], kid);
	    return o;
	}
    }
    return ck_fun(o);
}

/* caller is supposed to assign the return to the 
   container of the rep_op var */
STATIC OP *
S_opt_scalarhv(pTHX_ OP *rep_op) {
    dVAR;
    UNOP *unop;

    PERL_ARGS_ASSERT_OPT_SCALARHV;

    NewOp(1101, unop, 1, UNOP);
    unop->op_type = (OPCODE)OP_BOOLKEYS;
    unop->op_ppaddr = PL_ppaddr[OP_BOOLKEYS];
    unop->op_flags = (U8)(OPf_WANT_SCALAR | OPf_KIDS );
    unop->op_private = (U8)(1 | ((OPf_WANT_SCALAR | OPf_KIDS) >> 8));
    unop->op_first = rep_op;
    unop->op_next = rep_op->op_next;
    rep_op->op_next = (OP*)unop;
    rep_op->op_flags|=(OPf_REF | OPf_MOD);
    unop->op_sibling = rep_op->op_sibling;
    rep_op->op_sibling = NULL;
    /* unop->op_targ = pad_alloc(OP_BOOLKEYS, SVs_PADTMP); */
    if (rep_op->op_type == OP_PADHV) { 
        rep_op->op_flags &= ~OPf_WANT_SCALAR;
        rep_op->op_flags |= OPf_WANT_LIST;
    }
    return (OP*)unop;
}                        

/* Checks if o acts as an in-place operator on an array. oright points to the
 * beginning of the right-hand side. Returns the left-hand side of the
 * assignment if o acts in-place, or NULL otherwise. */

STATIC OP *
S_is_inplace_av(pTHX_ OP *o, OP *oright) {
    OP *o2;
    OP *oleft = NULL;

    PERL_ARGS_ASSERT_IS_INPLACE_AV;

    if (!oright ||
	(oright->op_type != OP_RV2AV && oright->op_type != OP_PADAV)
	|| oright->op_next != o
	|| (oright->op_private & OPpLVAL_INTRO)
    )
	return NULL;

    /* o2 follows the chain of op_nexts through the LHS of the
     * assign (if any) to the aassign op itself */
    o2 = o->op_next;
    if (!o2 || o2->op_type != OP_NULL)
	return NULL;
    o2 = o2->op_next;
    if (!o2 || o2->op_type != OP_PUSHMARK)
	return NULL;
    o2 = o2->op_next;
    if (o2 && o2->op_type == OP_GV)
	o2 = o2->op_next;
    if (!o2
	|| (o2->op_type != OP_PADAV && o2->op_type != OP_RV2AV)
	|| (o2->op_private & OPpLVAL_INTRO)
    )
	return NULL;
    oleft = o2;
    o2 = o2->op_next;
    if (!o2 || o2->op_type != OP_NULL)
	return NULL;
    o2 = o2->op_next;
    if (!o2 || o2->op_type != OP_AASSIGN
	    || (o2->op_flags & OPf_WANT) != OPf_WANT_VOID)
	return NULL;

    /* check that the sort is the first arg on RHS of assign */

    o2 = cUNOPx(o2)->op_first;
    if (!o2 || o2->op_type != OP_NULL)
	return NULL;
    o2 = cUNOPx(o2)->op_first;
    if (!o2 || o2->op_type != OP_PUSHMARK)
	return NULL;
    if (o2->op_sibling != o)
	return NULL;

    /* check the array is the same on both sides */
    if (oleft->op_type == OP_RV2AV) {
	if (oright->op_type != OP_RV2AV
	    || !cUNOPx(oright)->op_first
	    || cUNOPx(oright)->op_first->op_type != OP_GV
	    || cGVOPx_gv(cUNOPx(oleft)->op_first) !=
	       cGVOPx_gv(cUNOPx(oright)->op_first)
	)
	    return NULL;
    }
    else if (oright->op_type != OP_PADAV
	|| oright->op_targ != oleft->op_targ
    )
	return NULL;

    return oleft;
}

d8271 1
a8280 1
	case OP_HINTSEVAL:
d8287 1
a8287 1
		if (o->op_type != OP_METHOD_NAMED && SvPADTMP(cSVOPo->op_sv)) {
d8294 1
a8294 1
		else if (o->op_type != OP_METHOD_NAMED
d8341 2
a8342 1
		|| o->op_targ == OP_DBSTATE)
a8434 10
        
        {
            OP *fop;
            OP *sop;
            
        case OP_NOT:
            fop = cUNOP->op_first;
            sop = NULL;
            goto stitch_keys;
            break;
d8436 3
a8438 1
        case OP_AND:
a8440 47
            fop = cLOGOP->op_first;
            sop = fop->op_sibling;
	    while (cLOGOP->op_other->op_type == OP_NULL)
		cLOGOP->op_other = cLOGOP->op_other->op_next;
	    peep(cLOGOP->op_other); /* Recursive calls are not replaced by fptr calls */
          
          stitch_keys:	    
	    o->op_opt = 1;
            if ((fop->op_type == OP_PADHV || fop->op_type == OP_RV2HV)
                || ( sop && 
                     (sop->op_type == OP_PADHV || sop->op_type == OP_RV2HV)
                    )
            ){	
                OP * nop = o;
                OP * lop = o;
                if (!((nop->op_flags & OPf_WANT) == OPf_WANT_VOID)) {
                    while (nop && nop->op_next) {
                        switch (nop->op_next->op_type) {
                            case OP_NOT:
                            case OP_AND:
                            case OP_OR:
                            case OP_DOR:
                                lop = nop = nop->op_next;
                                break;
                            case OP_NULL:
                                nop = nop->op_next;
                                break;
                            default:
                                nop = NULL;
                                break;
                        }
                    }            
                }
                if ((lop->op_flags & OPf_WANT) == OPf_WANT_VOID) {
                    if (fop->op_type == OP_PADHV || fop->op_type == OP_RV2HV) 
                        cLOGOP->op_first = opt_scalarhv(fop);
                    if (sop && (sop->op_type == OP_PADHV || sop->op_type == OP_RV2HV)) 
                        cLOGOP->op_first->op_sibling = opt_scalarhv(sop);
                }                                        
            }                  
            
	    
	    break;
	}    
	
	case OP_MAPWHILE:
	case OP_GREPWHILE:
d8506 1
a8506 1
	    if (!SvFAKE(sv = *svp) || !SvREADONLY(sv)) {
d8634 56
a8689 2
	    oleft = is_inplace_av(o, oright);
	    if (!oleft)
a8715 1
	    OP *oleft, *oright;
a8717 27
	    /* @@a = reverse @@a */
	    if ((oright = cLISTOPo->op_first)
		    && (oright->op_type == OP_PUSHMARK)
		    && (oright = oright->op_sibling)
		    && (oleft = is_inplace_av(o, oright))) {
		OP *o2;

		/* transfer MODishness etc from LHS arg to RHS arg */
		oright->op_flags = oleft->op_flags;
		o->op_private |= OPpREVERSE_INPLACE;

		/* excise push->gv->rv2av->null->aassign */
		o2 = o->op_next->op_next;
		op_null(o2); /* PUSHMARK */
		o2 = o2->op_next;
		if (o2->op_type == OP_GV) {
		    op_null(o2); /* GV */
		    o2 = o2->op_next;
		}
		op_null(o2); /* RV2AV or PADAV */
		o2 = o2->op_next->op_next;
		op_null(o2); /* AASSIGN */

		o->op_next = o2->op_next;
		break;
	    }

a8910 1
    SV *const sv = MUTABLE_SV(XSANY.any_ptr);
a8913 1
	/* diag_listed_as: SKIPME */
a8917 3
    if (!sv) {
	XSRETURN(0);
    }
d8919 1
a8919 1
    ST(0) = sv;
@


1.1.1.14
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a104 1
#include "feature.h"
d106 2
a107 3
#define CALL_PEEP(o) PL_peepp(aTHX_ o)
#define CALL_RPEEP(o) PL_rpeepp(aTHX_ o)
#define CALL_OPFREEHOOK(o) if (PL_opfreehook) PL_opfreehook(aTHX_ o)
d308 1
a308 1
     : PL_check[type](aTHX_ (OP*)o))
d312 1
a312 7
#define CHANGE_TYPE(o,type) \
    STMT_START {				\
	o->op_type = (OPCODE)type;		\
	o->op_ppaddr = PL_ppaddr[type];		\
    } STMT_END

STATIC SV*
d320 1
a320 1
    return tmpsv;
d334 1
a334 18
S_too_few_arguments_sv(pTHX_ OP *o, SV *namesv, U32 flags)
{
    PERL_ARGS_ASSERT_TOO_FEW_ARGUMENTS_SV;
    yyerror_pv(Perl_form(aTHX_ "Not enough arguments for %"SVf, namesv),
                                    SvUTF8(namesv) | flags);
    return o;
}

STATIC OP *
S_too_few_arguments_pv(pTHX_ OP *o, const char* name, U32 flags)
{
    PERL_ARGS_ASSERT_TOO_FEW_ARGUMENTS_PV;
    yyerror_pv(Perl_form(aTHX_ "Not enough arguments for %s", name), flags);
    return o;
}
 
STATIC OP *
S_too_many_arguments_pv(pTHX_ OP *o, const char *name, U32 flags)
d336 1
a336 1
    PERL_ARGS_ASSERT_TOO_MANY_ARGUMENTS_PV;
d338 1
a338 1
    yyerror_pv(Perl_form(aTHX_ "Too many arguments for %s", name), flags);
d343 1
a343 1
S_too_many_arguments_sv(pTHX_ OP *o, SV *namesv, U32 flags)
d345 1
a345 1
    PERL_ARGS_ASSERT_TOO_MANY_ARGUMENTS_SV;
d347 1
a347 2
    yyerror_pv(Perl_form(aTHX_ "Too many arguments for %"SVf, SVfARG(namesv)),
                SvUTF8(namesv) | flags);
d352 1
a352 1
S_bad_type_pv(pTHX_ I32 n, const char *t, const char *name, U32 flags, const OP *kid)
d354 1
a354 5
    PERL_ARGS_ASSERT_BAD_TYPE_PV;

    yyerror_pv(Perl_form(aTHX_ "Type of arg %d to %s must be %s (not %s)",
		 (int)n, name, t, OP_DESC(kid)), flags);
}
d356 2
a357 7
STATIC void
S_bad_type_sv(pTHX_ I32 n, const char *t, SV *namesv, U32 flags, const OP *kid)
{
    PERL_ARGS_ASSERT_BAD_TYPE_SV;
 
    yyerror_pv(Perl_form(aTHX_ "Type of arg %d to %"SVf" must be %s (not %s)",
		 (int)n, SVfARG(namesv), t, OP_DESC(kid)), SvUTF8(namesv) | flags);
d361 1
a361 1
S_no_bareword_allowed(pTHX_ OP *o)
a369 1
    o->op_private &= ~OPpCONST_STRICT; /* prevent warning twice about the same OP */
d383 1
a383 1
    if (flags & ~SVf_UTF8)
d395 1
a395 1
	  ((flags & SVf_UTF8) && isIDFIRST_utf8((U8 *)name+1)) ||
d399 1
a399 2
	if (!(flags & SVf_UTF8 && UTF8_IS_START(name[1]))
	 && (!isPRINT(name[1]) || strchr("\t\n\r\f", name[1]))) {
d404 2
a405 2
	    yyerror_pv(Perl_form(aTHX_ "Can't use global %.*s in \"%s\"", (int) len, name,
			      PL_parser->in_my == KEY_state ? "state" : "my"), flags & SVf_UTF8);
d411 3
a413 4
    off = pad_add_name_pvn(name, len,
		       (is_our ? padadd_OUR :
		        PL_parser->in_my == KEY_state ? padadd_STATE : 0)
                            | ( flags & SVf_UTF8 ? SVf_UTF8 : 0 ),
d543 12
a554 2
    mad_free(o->op_madprop);
    o->op_madprop = 0;
d571 1
a571 1
	    || (PL_check[o->op_type] != Perl_ck_ftst))
d577 2
a578 1
	{
a646 1
    case OP_TRANSR:
d719 1
a719 1
    cophh_free(CopHINTHASH_get(cop));
d733 1
a733 1
    if (pmstash && !SvIS_FREED(pmstash) && SvMAGICAL(pmstash)) {
d820 1
a820 2
/*
=for apidoc Am|OP *|op_contextualize|OP *o|I32 context
d822 2
a823 35
Applies a syntactic context to an op tree representing an expression.
I<o> is the op tree, and I<context> must be C<G_SCALAR>, C<G_ARRAY>,
or C<G_VOID> to specify the context to apply.  The modified op tree
is returned.

=cut
*/

OP *
Perl_op_contextualize(pTHX_ OP *o, I32 context)
{
    PERL_ARGS_ASSERT_OP_CONTEXTUALIZE;
    switch (context) {
	case G_SCALAR: return scalar(o);
	case G_ARRAY:  return list(o);
	case G_VOID:   return scalarvoid(o);
	default:
	    Perl_croak(aTHX_ "panic: op_contextualize bad context %ld",
		       (long) context);
	    return o;
    }
}

/*
=head1 Optree Manipulation Functions

=for apidoc Am|OP*|op_linklist|OP *o
This function is the implementation of the L</LINKLIST> macro. It should
not be called directly.

=cut
*/

OP *
Perl_op_linklist(pTHX_ OP *o)
d827 1
a827 1
    PERL_ARGS_ASSERT_OP_LINKLIST;
d872 1
a872 2
    if (o->op_type == OP_SASSIGN && cBINOPo->op_first->op_type == OP_CONST
     && !(cBINOPo->op_first->op_flags & OPf_SPECIAL)) {
d927 2
a928 5
	kid = kid->op_sibling;
    do_kids:
	while (kid) {
	    OP *sib = kid->op_sibling;
	    if (sib && kid->op_type != OP_LEAVEWHEN)
a931 1
	    kid = sib;
d938 8
a945 2
	kid = cLISTOPo->op_first;
	goto do_kids;
a958 1
    U32 useless_is_utf8 = 0;
d989 1
a989 1
	 || o->op_type == OP_RETURN || o->op_type == OP_REQUIRE || o->op_type == OP_LEAVEWHEN)
a1036 1
    case OP_AELEMFAST_LEX:
a1083 1
    case OP_RUNCV:
d1104 1
a1104 1
           kid->op_type != OP_TRANS && kid->op_type != OP_TRANSR) {
a1109 9
    case OP_SUBST:
	if (cPMOPo->op_pmflags & PMf_NONDESTRUCT)
	    useless = "non-destructive substitution (s///r)";
	break;

    case OP_TRANSR:
	useless = "non-destructive transliteration (tr///r)";
	break;

d1125 9
a1154 10
		    else {
			SV * const dsv = newSVpvs("");
			SV* msv = sv_2mortal(Perl_newSVpvf(aTHX_
				    "a constant (%s)",
				    pv_pretty(dsv, maybe_macro, SvCUR(sv), 32, NULL, NULL,
					    PERL_PV_PRETTY_DUMP | PERL_PV_ESCAPE_NOCLEAR | PERL_PV_ESCAPE_UNI_DETECT )));
			SvREFCNT_dec(dsv);
			useless = SvPV_nolen(msv);
			useless_is_utf8 = SvUTF8(msv);
		    }
a1155 7
		else if (SvOK(sv)) {
		    SV* msv = sv_2mortal(Perl_newSVpvf(aTHX_
				"a constant (%"SVf")", sv));
		    useless = SvPV_nolen(msv);
		}
		else
		    useless = "a constant (undef)";
a1180 46
    case OP_SASSIGN: {
	OP *rv2gv;
	UNOP *refgen, *rv2cv;
	LISTOP *exlist;

	if ((o->op_private & ~OPpASSIGN_BACKWARDS) != 2)
	    break;

	rv2gv = ((BINOP *)o)->op_last;
	if (!rv2gv || rv2gv->op_type != OP_RV2GV)
	    break;

	refgen = (UNOP *)((BINOP *)o)->op_first;

	if (!refgen || refgen->op_type != OP_REFGEN)
	    break;

	exlist = (LISTOP *)refgen->op_first;
	if (!exlist || exlist->op_type != OP_NULL
	    || exlist->op_targ != OP_LIST)
	    break;

	if (exlist->op_first->op_type != OP_PUSHMARK)
	    break;

	rv2cv = (UNOP*)exlist->op_last;

	if (rv2cv->op_type != OP_RV2CV)
	    break;

	assert ((rv2gv->op_private & OPpDONT_INIT_GV) == 0);
	assert ((o->op_private & OPpASSIGN_CV_TO_GV) == 0);
	assert ((rv2cv->op_private & OPpMAY_RETURN_CONSTANT) == 0);

	o->op_private |= OPpASSIGN_CV_TO_GV;
	rv2gv->op_private |= OPpDONT_INIT_GV;
	rv2cv->op_private |= OPpMAY_RETURN_CONSTANT;

	break;
    }

    case OP_AASSIGN: {
	inplace_aassign(o);
	break;
    }

d1234 1
a1234 3
       Perl_ck_warner(aTHX_ packWARN(WARN_VOID), "Useless use of %"SVf" in void context",
                       newSVpvn_flags(useless, strlen(useless),
                            SVs_TEMP | ( useless_is_utf8 ? SVf_UTF8 : 0 )));
d1300 2
a1301 5
	kid = kid->op_sibling;
    do_kids:
	while (kid) {
	    OP *sib = kid->op_sibling;
	    if (sib && kid->op_type != OP_LEAVEWHEN)
a1304 1
	    kid = sib;
d1310 8
a1317 2
	kid = cLISTOPo->op_first;
	goto do_kids;
d1355 1
a1355 1
	    op_lvalue(kid, type);
d1360 10
a1369 267
/*
=for apidoc finalize_optree

This function finalizes the optree. Should be called directly after
the complete optree is built. It does some additional
checking which can't be done in the normal ck_xxx functions and makes
the tree thread-safe.

=cut
*/
void
Perl_finalize_optree(pTHX_ OP* o)
{
    PERL_ARGS_ASSERT_FINALIZE_OPTREE;

    ENTER;
    SAVEVPTR(PL_curcop);

    finalize_op(o);

    LEAVE;
}

STATIC void
S_finalize_op(pTHX_ OP* o)
{
    PERL_ARGS_ASSERT_FINALIZE_OP;

#if defined(PERL_MAD) && defined(USE_ITHREADS)
    {
	/* Make sure mad ops are also thread-safe */
	MADPROP *mp = o->op_madprop;
	while (mp) {
	    if (mp->mad_type == MAD_OP && mp->mad_vlen) {
		OP *prop_op = (OP *) mp->mad_val;
		/* We only need "Relocate sv to the pad for thread safety.", but this
		   easiest way to make sure it traverses everything */
		if (prop_op->op_type == OP_CONST)
		    cSVOPx(prop_op)->op_private &= ~OPpCONST_STRICT;
		finalize_op(prop_op);
	    }
	    mp = mp->mad_next;
	}
    }
#endif

    switch (o->op_type) {
    case OP_NEXTSTATE:
    case OP_DBSTATE:
	PL_curcop = ((COP*)o);		/* for warnings */
	break;
    case OP_EXEC:
	if ( o->op_sibling
	    && (o->op_sibling->op_type == OP_NEXTSTATE || o->op_sibling->op_type == OP_DBSTATE)
	    && ckWARN(WARN_SYNTAX))
	    {
		if (o->op_sibling->op_sibling) {
		    const OPCODE type = o->op_sibling->op_sibling->op_type;
		    if (type != OP_EXIT && type != OP_WARN && type != OP_DIE) {
			const line_t oldline = CopLINE(PL_curcop);
			CopLINE_set(PL_curcop, CopLINE((COP*)o->op_sibling));
			Perl_warner(aTHX_ packWARN(WARN_EXEC),
			    "Statement unlikely to be reached");
			Perl_warner(aTHX_ packWARN(WARN_EXEC),
			    "\t(Maybe you meant system() when you said exec()?)\n");
			CopLINE_set(PL_curcop, oldline);
		    }
		}
	    }
	break;

    case OP_GV:
	if ((o->op_private & OPpEARLY_CV) && ckWARN(WARN_PROTOTYPE)) {
	    GV * const gv = cGVOPo_gv;
	    if (SvTYPE(gv) == SVt_PVGV && GvCV(gv) && SvPVX_const(GvCV(gv))) {
		/* XXX could check prototype here instead of just carping */
		SV * const sv = sv_newmortal();
		gv_efullname3(sv, gv, NULL);
		Perl_warner(aTHX_ packWARN(WARN_PROTOTYPE),
		    "%"SVf"() called too early to check prototype",
		    SVfARG(sv));
	    }
	}
	break;

    case OP_CONST:
	if (cSVOPo->op_private & OPpCONST_STRICT)
	    no_bareword_allowed(o);
	/* FALLTHROUGH */
#ifdef USE_ITHREADS
    case OP_HINTSEVAL:
    case OP_METHOD_NAMED:
	/* Relocate sv to the pad for thread safety.
	 * Despite being a "constant", the SV is written to,
	 * for reference counts, sv_upgrade() etc. */
	if (cSVOPo->op_sv) {
	    const PADOFFSET ix = pad_alloc(OP_CONST, SVs_PADTMP);
	    if (o->op_type != OP_METHOD_NAMED &&
		(SvPADTMP(cSVOPo->op_sv) || SvPADMY(cSVOPo->op_sv)))
	    {
		/* If op_sv is already a PADTMP/MY then it is being used by
		 * some pad, so make a copy. */
		sv_setsv(PAD_SVl(ix),cSVOPo->op_sv);
		SvREADONLY_on(PAD_SVl(ix));
		SvREFCNT_dec(cSVOPo->op_sv);
	    }
	    else if (o->op_type != OP_METHOD_NAMED
		&& cSVOPo->op_sv == &PL_sv_undef) {
		/* PL_sv_undef is hack - it's unsafe to store it in the
		   AV that is the pad, because av_fetch treats values of
		   PL_sv_undef as a "free" AV entry and will merrily
		   replace them with a new SV, causing pad_alloc to think
		   that this pad slot is free. (When, clearly, it is not)
		*/
		SvOK_off(PAD_SVl(ix));
		SvPADTMP_on(PAD_SVl(ix));
		SvREADONLY_on(PAD_SVl(ix));
	    }
	    else {
		SvREFCNT_dec(PAD_SVl(ix));
		SvPADTMP_on(cSVOPo->op_sv);
		PAD_SETSV(ix, cSVOPo->op_sv);
		/* XXX I don't know how this isn't readonly already. */
		SvREADONLY_on(PAD_SVl(ix));
	    }
	    cSVOPo->op_sv = NULL;
	    o->op_targ = ix;
	}
#endif
	break;

    case OP_HELEM: {
	UNOP *rop;
	SV *lexname;
	GV **fields;
	SV **svp, *sv;
	const char *key = NULL;
	STRLEN keylen;

	if (((BINOP*)o)->op_last->op_type != OP_CONST)
	    break;

	/* Make the CONST have a shared SV */
	svp = cSVOPx_svp(((BINOP*)o)->op_last);
	if ((!SvFAKE(sv = *svp) || !SvREADONLY(sv))
	    && SvTYPE(sv) < SVt_PVMG && !SvROK(sv)) {
	    key = SvPV_const(sv, keylen);
	    lexname = newSVpvn_share(key,
		SvUTF8(sv) ? -(I32)keylen : (I32)keylen,
		0);
	    SvREFCNT_dec(sv);
	    *svp = lexname;
	}

	if ((o->op_private & (OPpLVAL_INTRO)))
	    break;

	rop = (UNOP*)((BINOP*)o)->op_first;
	if (rop->op_type != OP_RV2HV || rop->op_first->op_type != OP_PADSV)
	    break;
	lexname = *av_fetch(PL_comppad_name, rop->op_first->op_targ, TRUE);
	if (!SvPAD_TYPED(lexname))
	    break;
	fields = (GV**)hv_fetchs(SvSTASH(lexname), "FIELDS", FALSE);
	if (!fields || !GvHV(*fields))
	    break;
	key = SvPV_const(*svp, keylen);
	if (!hv_fetch(GvHV(*fields), key,
		SvUTF8(*svp) ? -(I32)keylen : (I32)keylen, FALSE)) {
	    Perl_croak(aTHX_ "No such class field \"%"SVf"\" " 
			   "in variable %"SVf" of type %"HEKf, 
		      SVfARG(*svp), SVfARG(lexname),
                      HEKfARG(HvNAME_HEK(SvSTASH(lexname))));
	}
	break;
    }

    case OP_HSLICE: {
	UNOP *rop;
	SV *lexname;
	GV **fields;
	SV **svp;
	const char *key;
	STRLEN keylen;
	SVOP *first_key_op, *key_op;

	if ((o->op_private & (OPpLVAL_INTRO))
	    /* I bet there's always a pushmark... */
	    || ((LISTOP*)o)->op_first->op_sibling->op_type != OP_LIST)
	    /* hmmm, no optimization if list contains only one key. */
	    break;
	rop = (UNOP*)((LISTOP*)o)->op_last;
	if (rop->op_type != OP_RV2HV)
	    break;
	if (rop->op_first->op_type == OP_PADSV)
	    /* @@$hash{qw(keys here)} */
	    rop = (UNOP*)rop->op_first;
	else {
	    /* @@{$hash}{qw(keys here)} */
	    if (rop->op_first->op_type == OP_SCOPE
		&& cLISTOPx(rop->op_first)->op_last->op_type == OP_PADSV)
		{
		    rop = (UNOP*)cLISTOPx(rop->op_first)->op_last;
		}
	    else
		break;
	}

	lexname = *av_fetch(PL_comppad_name, rop->op_targ, TRUE);
	if (!SvPAD_TYPED(lexname))
	    break;
	fields = (GV**)hv_fetchs(SvSTASH(lexname), "FIELDS", FALSE);
	if (!fields || !GvHV(*fields))
	    break;
	/* Again guessing that the pushmark can be jumped over.... */
	first_key_op = (SVOP*)((LISTOP*)((LISTOP*)o)->op_first->op_sibling)
	    ->op_first->op_sibling;
	for (key_op = first_key_op; key_op;
	     key_op = (SVOP*)key_op->op_sibling) {
	    if (key_op->op_type != OP_CONST)
		continue;
	    svp = cSVOPx_svp(key_op);
	    key = SvPV_const(*svp, keylen);
	    if (!hv_fetch(GvHV(*fields), key,
		    SvUTF8(*svp) ? -(I32)keylen : (I32)keylen, FALSE)) {
		Perl_croak(aTHX_ "No such class field \"%"SVf"\" " 
			   "in variable %"SVf" of type %"HEKf, 
		      SVfARG(*svp), SVfARG(lexname),
                      HEKfARG(HvNAME_HEK(SvSTASH(lexname))));
	    }
	}
	break;
    }
    case OP_SUBST: {
	if (cPMOPo->op_pmreplrootu.op_pmreplroot)
	    finalize_op(cPMOPo->op_pmreplrootu.op_pmreplroot);
	break;
    }
    default:
	break;
    }

    if (o->op_flags & OPf_KIDS) {
	OP *kid;
	for (kid = cUNOPo->op_first; kid; kid = kid->op_sibling)
	    finalize_op(kid);
    }
}

/*
=for apidoc Amx|OP *|op_lvalue|OP *o|I32 type

Propagate lvalue ("modifiable") context to an op and its children.
I<type> represents the context type, roughly based on the type of op that
would do the modifying, although C<local()> is represented by OP_NULL,
because it has no op type of its own (it is signalled by a flag on
the lvalue op).

This function detects things that can't be modified, such as C<$x+1>, and
generates errors for them. For example, C<$x+1 = 2> would cause it to be
called with an op of type OP_ADD and a C<type> argument of OP_SASSIGN.

It also flags things that need to behave specially in an lvalue context,
such as C<$$x = 5> which might have to vivify a reference in C<$x>.

=cut
*/
d1372 1
a1372 1
Perl_op_lvalue_flags(pTHX_ OP *o, I32 type, U32 flags)
a1387 4
    assert( (o->op_flags & OPf_WANT) != OPf_WANT_VOID );

    if (type == OP_PRTF || type == OP_SPRINTF) type = OP_ENTERSUB;

d1393 18
d1416 1
a1416 1
	if ((type == OP_UNDEF || type == OP_REFGEN || type == OP_LOCK) &&
d1419 3
a1421 2
	    /* Both ENTERSUB and RV2CV use this bit, but for different pur-
	       poses, so we need it clear.  */
d1428 2
d1431 1
a1431 2
	    o->op_private |= OPpLVAL_INTRO
	                   |(OPpENTERSUB_INARGS * (type == OP_LEAVESUBLV));
d1434 1
a1434 1
		/* Potential lvalue context: */
d1441 1
d1454 23
d1480 1
d1490 13
d1508 1
a1508 1
		    break;
a1515 1
	if (flags & OP_LVALUE_NO_CROAK) return NULL;
d1517 1
a1517 2
	if (type == OP_GREPSTART || type == OP_ENTERSUB
	 || type == OP_REFGEN    || type == OP_LEAVESUBLV)
d1556 1
a1556 1
	    op_lvalue(kid, type);
a1601 1
    case OP_AELEMFAST_LEX:
d1619 2
a1620 2
	    Perl_croak(aTHX_ "Can't localize lexical variable %"SVf,
		 PAD_COMPNAME_SV(o->op_targ));
d1628 1
a1628 2
    case OP_RKEYS:
	if (type != OP_SASSIGN && type != OP_LEAVESUBLV)
a1636 1
      lvalue_func:
d1639 1
d1644 1
a1644 1
	    op_lvalue(cBINOPo->op_first->op_sibling, type);
d1665 1
a1665 1
	    op_lvalue(cLISTOPo->op_last, type);
d1675 1
a1675 1
	    op_lvalue(cBINOPo->op_first, type);
d1682 1
a1682 4
	    /* elements might be in void context because the list is
	       in scalar context or because they are attribute sub calls */
	    if ( (kid->op_flags & OPf_WANT) != OPf_WANT_VOID )
		op_lvalue(kid, type);
d1688 1
a1688 1
	break; /* op_lvalue()ing was handled by ck_return() */
d1695 1
a1695 1
        PL_check[o->op_type] == Perl_ck_ftst)
d1726 1
a1726 1
    assert(o || type != OP_SASSIGN);
a1760 1
    case OP_TRANSR:
d1822 1
a1822 1
	if ((type == OP_EXISTS || type == OP_DEFINED) &&
a1830 7
	else if (type == OP_RV2SV || type == OP_RV2AV || type == OP_RV2HV){
	    o->op_private |= (type == OP_RV2AV ? OPpDEREF_AV
			      : type == OP_RV2HV ? OPpDEREF_HV
			      : OPpDEREF_SV);
	    o->op_flags |= OPf_MOD;
	}

d1925 1
a1925 1
		rop = op_append_elem(OP_LIST, rop,
d1961 1
a1961 1
			 op_prepend_elem(OP_LIST,
d1963 1
a1963 1
				      op_prepend_elem(OP_LIST,
d1998 1
a1998 1
    arg = op_prepend_elem(OP_LIST,
d2000 1
a2000 1
		       op_prepend_elem(OP_LIST,
d2002 1
a2002 1
					    op_lvalue(arg, OP_REFGEN)),
d2008 2
a2009 2
		   op_append_elem(OP_LIST,
			       op_prepend_elem(OP_LIST, pack, list(arg)),
d2011 1
d2014 1
a2014 1
    *imopsp = op_append_elem(OP_LIST, *imopsp, imop);
d2051 1
a2051 1
            attrs = op_append_elem(OP_LIST, attrs,
d2059 1
a2059 1
                     NULL, op_prepend_elem(OP_LIST,
d2061 1
a2061 1
				  op_prepend_elem(OP_LIST,
a2071 1
    const bool stately = PL_parser && PL_parser->in_my == KEY_state;
a2087 1
	return o;
d2142 1
a2142 1
    if (stately)
d2172 1
a2172 1
	    o = scalar(op_append_list(OP_LIST, rops, o));
d2175 2
a2176 13
	else {
	    /* The listop in rops might have a pushmark at the beginning,
	       which will mess up list assignment. */
	    LISTOP * const lrops = (LISTOP *)rops; /* for brevity */
	    if (rops->op_type == OP_LIST && 
	        lrops->op_first && lrops->op_first->op_type == OP_PUSHMARK)
	    {
		OP * const pushmark = lrops->op_first;
		lrops->op_first = pushmark->op_sibling;
		op_free(pushmark);
	    }
	    o = op_append_list(OP_LIST, o, rops);
	}
d2206 1
a2206 4
	  = PL_op_desc[(
		          rtype == OP_SUBST || rtype == OP_TRANS
		       || rtype == OP_TRANSR
		       )
d2208 1
a2208 17
      const bool isary = ltype == OP_RV2AV || ltype == OP_PADAV;
      GV *gv;
      SV * const name =
       (ltype == OP_RV2AV || ltype == OP_RV2HV)
        ?    cUNOPx(left)->op_first->op_type == OP_GV
          && (gv = cGVOPx_gv(cUNOPx(left)->op_first))
              ? varname(gv, isary ? '@@' : '%', 0, NULL, 0, 1)
              : NULL
        : varname(
           (GV *)PL_compcv, isary ? '@@' : '%', left->op_targ, NULL, 0, 1
          );
      if (name)
	Perl_warner(aTHX_ packWARN(WARN_MISC),
             "Applying %s to %"SVf" will act on scalar(%"SVf")",
             desc, name, name);
      else {
	const char * const sample = (isary
d2210 1
a2210 1
	Perl_warner(aTHX_ packWARN(WARN_MISC),
a2212 1
      }
d2222 3
a2224 11
    /* !~ doesn't make sense with /r, so error on it for now */
    if (rtype == OP_SUBST && (cPMOPx(right)->op_pmflags & PMf_NONDESTRUCT) &&
	type == OP_NOT)
	yyerror("Using !~ with s///r doesn't make sense");
    if (rtype == OP_TRANSR && type == OP_NOT)
	yyerror("Using !~ with tr///r doesn't make sense");

    ismatchop = (rtype == OP_MATCH ||
		 rtype == OP_SUBST ||
		 rtype == OP_TRANS || rtype == OP_TRANSR)
	     && !(right->op_flags & OPf_SPECIAL);
d2233 1
a2233 1
	if (rtype != OP_MATCH && rtype != OP_TRANSR &&
d2235 2
a2236 4
               right->op_private & OPpTRANS_IDENTICAL) &&
	    ! (rtype == OP_SUBST &&
	       (cPMOPx(right)->op_pmflags & PMf_NONDESTRUCT)))
	    newleft = op_lvalue(left, rtype);
d2239 1
a2239 1
	if (right->op_type == OP_TRANS || right->op_type == OP_TRANSR)
d2242 1
a2242 1
	    o = op_prepend_elem(rtype, scalar(newleft), right);
d2260 5
a2264 19
/*
=for apidoc Amx|OP *|op_scope|OP *o

Wraps up an op tree with some additional ops so that at runtime a dynamic
scope will be created.  The original ops run in the new dynamic scope,
and then, provided that they exit normally, the scope will be unwound.
The additional ops used to create and unwind the dynamic scope will
normally be an C<enter>/C<leave> pair, but a C<scope> op may be used
instead if the ops are simple enough to not need the full dynamic scope
structure.

=cut
*/

OP *
Perl_op_scope(pTHX_ OP *o)
{
    dVAR;
    if (o) {
d2266 1
a2266 1
	    o = op_prepend_elem(OP_LINESEQ, newOP(OP_ENTER, 0), o);
d2290 1
a2290 1

a2295 1

a2300 3

    CALL_BLOCK_HOOKS(bhk_start, full);

d2309 1
a2309 4
    OP* retval = scalarseq(seq);

    CALL_BLOCK_HOOKS(bhk_pre_end, &retval);

a2314 3

    CALL_BLOCK_HOOKS(bhk_post_end, &retval);

a2317 19
/*
=head1 Compile-time scope hooks

=for apidoc Aox||blockhook_register

Register a set of hooks to be called when the Perl lexical scope changes
at compile time. See L<perlguts/"Compile-time scope hooks">.

=cut
*/

void
Perl_blockhook_register(pTHX_ BHK *hk)
{
    PERL_ARGS_ASSERT_BLOCKHOOK_REGISTER;

    Perl_av_create_and_push(aTHX_ &PL_blockhooks, newSViv(PTR2IV(hk)));
}

d2322 1
a2322 1
    const PADOFFSET offset = pad_findmy_pvs("$_", 0);
a2340 2
	PERL_CONTEXT *cx;
	I32 i;
d2346 1
a2346 15

	cx = &cxstack[cxstack_ix];
	assert(CxTYPE(cx) == CXt_EVAL);

	if ((cx->blk_gimme & G_WANT) == G_VOID)
	    scalarvoid(PL_eval_root);
	else if ((cx->blk_gimme & G_WANT) == G_ARRAY)
	    list(PL_eval_root);
	else
	    scalar(PL_eval_root);

	/* don't use LINKLIST, since PL_eval_root might indirect through
	 * a rather expensive function call and LINKLIST evaluates its
	 * argument more than once */
	PL_eval_start = op_linklist(PL_eval_root);
a2349 3
	i = PL_savestack_ix;
	SAVEFREEOP(o);
	ENTER;
a2350 3
	finalize_optree(PL_eval_root);
	LEAVE;
	PL_savestack_ix = i;
d2359 1
a2359 1
	PL_main_root = op_scope(sawparens(scalarvoid(o)));
a2365 1
	finalize_optree(PL_main_root);
d2438 1
a2438 1
	o = op_lvalue(o, OP_NULL);		/* a bit kludgey */
d2452 1
a2452 35
	o = convert(OP_JOIN, 0, op_prepend_elem(OP_LIST, o2, o));
    }
    return o;
}

PERL_STATIC_INLINE OP *
S_op_std_init(pTHX_ OP *o)
{
    I32 type = o->op_type;

    PERL_ARGS_ASSERT_OP_STD_INIT;

    if (PL_opargs[type] & OA_RETSCALAR)
	scalar(o);
    if (PL_opargs[type] & OA_TARGET && !o->op_targ)
	o->op_targ = pad_alloc(type, SVs_PADTMP);

    return o;
}

PERL_STATIC_INLINE OP *
S_op_integerize(pTHX_ OP *o)
{
    I32 type = o->op_type;

    PERL_ARGS_ASSERT_OP_INTEGERIZE;

    /* integerize op, unless it happens to be C<-foo>.
     * XXX should pp_i_negate() do magic string negation instead? */
    if ((PL_opargs[type] & OA_OTHERINT) && (PL_hints & HINT_INTEGER)
	&& !(type == OP_NEGATE && cUNOPo->op_first->op_type == OP_CONST
	     && (cUNOPo->op_first->op_private & OPpCONST_BARE)))
    {
	dVAR;
	o->op_ppaddr = PL_ppaddr[type = ++(o->op_type)];
a2453 5

    if (type == OP_NEGATE)
	/* XXX might want a ck_negate() for this */
	cUNOPo->op_first->op_private &= ~OPpCONST_STRICT;

d2475 14
d2493 4
a2505 1
    case OP_SPRINTF:
d2507 1
a2507 1
	if (IN_LOCALE_COMPILETIME)
d2550 1
a2550 7
	if (o->op_targ && sv == PAD_SV(o->op_targ)) {	/* grab pad temp? */
#ifdef PERL_MAD
	    /* Can't simply swipe the SV from the pad, because that relies on
	       the op being freed "real soon now". Under MAD, this doesn't
	       happen (see the #ifdef below).  */
	    sv = newSVsv(sv);
#else
a2551 2
#endif
	}
d2612 1
a2612 1
    Perl_pp_pushmark(aTHX);
d2617 1
a2617 1
    Perl_pp_anonlist(aTHX);
d2624 1
a2624 1
    o->op_opt = 0;		/* needs to be revisited in rpeep() */
d2632 1
a2632 1
    LINKLIST(o);
a2639 1
    if (type < 0) type = -type, flags |= OPf_SPECIAL;
a2646 7
    else {
	OP * const kid2 = cLISTOPo->op_first->op_sibling;
	if (kid2 && kid2->op_type == OP_COREARGS) {
	    op_null(cLISTOPo->op_first);
	    kid2->op_private |= OPpCOREARGS_PUSHMARK;
	}
    }	
d2656 1
a2656 1
    return fold_constants(op_integerize(op_std_init(o)));
a2658 4
/*
=head1 Optree Manipulation Functions
*/

a2660 13
/*
=for apidoc Am|OP *|op_append_elem|I32 optype|OP *first|OP *last

Append an item to the list of ops contained directly within a list-type
op, returning the lengthened list.  I<first> is the list-type op,
and I<last> is the op to append to the list.  I<optype> specifies the
intended opcode for the list.  If I<first> is not already a list of the
right type, it will be upgraded into one.  If either I<first> or I<last>
is null, the other is returned unchanged.

=cut
*/

d2662 1
a2662 1
Perl_op_append_elem(pTHX_ I32 type, OP *first, OP *last)
a2685 13
/*
=for apidoc Am|OP *|op_append_list|I32 optype|OP *first|OP *last

Concatenate the lists of ops contained directly within two list-type ops,
returning the combined list.  I<first> and I<last> are the list-type ops
to concatenate.  I<optype> specifies the intended opcode for the list.
If either I<first> or I<last> is not already a list of the right type,
it will be upgraded into one.  If either I<first> or I<last> is null,
the other is returned unchanged.

=cut
*/

d2687 1
a2687 1
Perl_op_append_list(pTHX_ I32 type, OP *first, OP *last)
d2690 1
a2690 1
	return last;
d2693 1
a2693 1
	return first;
d2696 1
a2696 1
	return op_prepend_elem(type, first, last);
d2699 1
a2699 1
	return op_append_elem(type, first, last);
d2701 2
a2702 2
    ((LISTOP*)first)->op_last->op_sibling = ((LISTOP*)last)->op_first;
    ((LISTOP*)first)->op_last = ((LISTOP*)last)->op_last;
d2706 2
a2707 2
    if (((LISTOP*)last)->op_first && first->op_madprop) {
	MADPROP *mp = ((LISTOP*)last)->op_first->op_madprop;
d2714 1
a2714 1
	    ((LISTOP*)last)->op_first->op_madprop = first->op_madprop;
d2721 1
a2721 1
    S_op_destroy(aTHX_ last);
d2723 1
a2723 1
    return first;
a2725 13
/*
=for apidoc Am|OP *|op_prepend_elem|I32 optype|OP *first|OP *last

Prepend an item to the list of ops contained directly within a list-type
op, returning the lengthened list.  I<first> is the op to prepend to the
list, and I<last> is the list-type op.  I<optype> specifies the intended
opcode for the list.  If I<last> is not already a list of the right type,
it will be upgraded into one.  If either I<first> or I<last> is null,
the other is returned unchanged.

=cut
*/

d2727 1
a2727 1
Perl_op_prepend_elem(pTHX_ I32 type, OP *first, OP *last)
d2963 2
a2964 1
    MADPROP *const mp = (MADPROP *) PerlMemShared_malloc(sizeof(MADPROP));
d3001 1
a3001 1
    PerlMemShared_free(mp);
a3005 11
/*
=head1 Optree construction

=for apidoc Am|OP *|newNULLLIST

Constructs, checks, and returns a new C<stub> op, which represents an
empty list expression.

=cut
*/

a3020 12
/*
=for apidoc Am|OP *|newLISTOP|I32 type|I32 flags|OP *first|OP *last

Constructs, checks, and returns an op of any list type.  I<type> is
the opcode.  I<flags> gives the eight bits of C<op_flags>, except that
C<OPf_KIDS> will be set automatically if required.  I<first> and I<last>
supply up to two ops to be direct children of the list op; they are
consumed by this function and become part of the constructed op tree.

=cut
*/

a3056 11
/*
=for apidoc Am|OP *|newOP|I32 type|I32 flags

Constructs, checks, and returns an op of any base type (any type that
has no extra fields).  I<type> is the opcode.  I<flags> gives the
eight bits of C<op_flags>, and, shifted up eight bits, the eight bits
of C<op_private>.

=cut
*/

a3062 5
    if (type == -OP_ENTEREVAL) {
	type = OP_ENTEREVAL;
	flags |= OPpEVAL_BYTES<<8;
    }

a3084 14
/*
=for apidoc Am|OP *|newUNOP|I32 type|I32 flags|OP *first

Constructs, checks, and returns an op of any unary type.  I<type> is
the opcode.  I<flags> gives the eight bits of C<op_flags>, except that
C<OPf_KIDS> will be set automatically if required, and, shifted up eight
bits, the eight bits of C<op_private>, except that the bit with value 1
is automatically set.  I<first> supplies an optional op to be the direct
child of the unary op; it is consumed by this function and become part
of the constructed op tree.

=cut
*/

a3090 5
    if (type == -OP_ENTEREVAL) {
	type = OP_ENTEREVAL;
	flags |= OPpEVAL_BYTES<<8;
    }

d3114 1
a3114 1
    return fold_constants(op_integerize(op_std_init((OP *) unop)));
a3116 14
/*
=for apidoc Am|OP *|newBINOP|I32 type|I32 flags|OP *first|OP *last

Constructs, checks, and returns an op of any binary type.  I<type>
is the opcode.  I<flags> gives the eight bits of C<op_flags>, except
that C<OPf_KIDS> will be set automatically, and, shifted up eight bits,
the eight bits of C<op_private>, except that the bit with value 1 or
2 is automatically set as required.  I<first> and I<last> supply up to
two ops to be the direct children of the binary op; they are consumed
by this function and become part of the constructed op tree.

=cut
*/

d3150 1
a3150 1
    return fold_constants(op_integerize(op_std_init((OP *)binop)));
d3290 2
a3291 1
	    t = uvuni_to_utf8(tmpbuf, 0x7fffffff);
d3390 3
d3426 1
a3426 5
    tbl = (short*)PerlMemShared_calloc(
	(o->op_private & OPpTRANS_COMPLEMENT) &&
	    !(o->op_private & OPpTRANS_DELETE) ? 258 : 256,
	sizeof(short));
    cPVOPo->op_pv = (char*)tbl;
d3428 1
a3514 10
/*
=for apidoc Am|OP *|newPMOP|I32 type|I32 flags

Constructs, checks, and returns an op of any pattern matching type.
I<type> is the opcode.  I<flags> gives the eight bits of C<op_flags>
and, shifted up eight bits, the eight bits of C<op_private>.

=cut
*/

d3531 2
a3532 21
    if (IN_LOCALE_COMPILETIME) {
	set_regex_charset(&(pmop->op_pmflags), REGEX_LOCALE_CHARSET);
    }
    else if ((! (PL_hints & HINT_BYTES))
                /* Both UNI_8_BIT and locale :not_characters imply Unicode */
	     && (PL_hints & (HINT_UNI_8_BIT|HINT_LOCALE_NOT_CHARS)))
    {
	set_regex_charset(&(pmop->op_pmflags), REGEX_UNICODE_CHARSET);
    }
    if (PL_hints & HINT_RE_FLAGS) {
        SV *reflags = Perl_refcounted_he_fetch_pvn(aTHX_
         PL_compiling.cop_hints_hash, STR_WITH_LEN("reflags"), 0, 0
        );
        if (reflags && SvOK(reflags)) pmop->op_pmflags |= SvIV(reflags);
        reflags = Perl_refcounted_he_fetch_pvn(aTHX_
         PL_compiling.cop_hints_hash, STR_WITH_LEN("reflags_charset"), 0, 0
        );
        if (reflags && SvOK(reflags)) {
            set_regex_charset(&(pmop->op_pmflags), (regex_charset)SvIV(reflags));
        }
    }
d3585 1
a3585 4
    if (
        o->op_type == OP_SUBST
     || o->op_type == OP_TRANS || o->op_type == OP_TRANSR
    ) {
d3607 1
a3607 1
    if (o->op_type == OP_TRANS || o->op_type == OP_TRANSR) {
d3620 1
a3620 1
	U32 pm_flags = pm->op_pmflags & RXf_PMf_COMPILETIME;
d3664 1
a3664 1
	if (PL_hints & HINT_RE_EVAL) PL_cv_has_eval = 1;
d3677 1
a3677 1
	op_prepend_elem(o->op_type, scalar((OP*)rcop), o);
d3731 1
a3731 1
	    op_prepend_elem(o->op_type, scalar(repl), o);
a3758 11
/*
=for apidoc Am|OP *|newSVOP|I32 type|I32 flags|SV *sv

Constructs, checks, and returns an op of any type that involves an
embedded SV.  I<type> is the opcode.  I<flags> gives the eight bits
of C<op_flags>.  I<sv> gives the SV to embed in the op; this function
takes ownership of one reference to it.

=cut
*/

a3784 15

/*
=for apidoc Am|OP *|newPADOP|I32 type|I32 flags|SV *sv

Constructs, checks, and returns an op of any type that involves a
reference to a pad element.  I<type> is the opcode.  I<flags> gives the
eight bits of C<op_flags>.  A pad slot is automatically allocated, and
is populated with I<sv>; this function takes ownership of one reference
to it.

This function only exists if Perl has been compiled to use ithreads.

=cut
*/

d3813 1
a3813 14

#endif /* !USE_ITHREADS */

/*
=for apidoc Am|OP *|newGVOP|I32 type|I32 flags|GV *gv

Constructs, checks, and returns an op of any type that involves an
embedded reference to a GV.  I<type> is the opcode.  I<flags> gives the
eight bits of C<op_flags>.  I<gv> identifies the GV that the op should
reference; calling this function does not transfer ownership of any
reference to it.

=cut
*/
a3829 12
/*
=for apidoc Am|OP *|newPVOP|I32 type|I32 flags|char *pv

Constructs, checks, and returns an op of any type that involves an
embedded C-level pointer (PV).  I<type> is the opcode.  I<flags> gives
the eight bits of C<op_flags>.  I<pv> supplies the C-level pointer, which
must have been allocated using L</PerlMemShared_malloc>; the memory will
be freed when the op is destroyed.

=cut
*/

a3833 1
    const bool utf8 = cBOOL(flags & SVf_UTF8);
a3835 2
    flags &= ~SVf_UTF8;

a3836 1
	|| type == OP_RUNCV
a3844 1
    pvop->op_private = utf8 ? OPpPV_IS_UTF8 : 0;
d3867 1
a3867 1
    SAVEGENERICSV(PL_curstash);
d3870 1
a3870 1
    PL_curstash = (HV *)SvREFCNT_inc(gv_stashsv(sv, GV_ADD));
a3917 1
    SV *use_version = NULL;
d3950 2
a3951 2
			    op_append_elem(OP_LIST,
					op_prepend_elem(OP_LIST, pack, list(version)),
d3964 1
a3964 3
	if (aver)
	    use_version = ((SVOP*)idop)->op_sv;
	else
d3980 2
a3981 2
		       op_append_elem(OP_LIST,
				   op_prepend_elem(OP_LIST, pack, list(arg)),
d3990 2
a3991 2
	op_append_elem(OP_LINESEQ,
	    op_append_elem(OP_LINESEQ,
a3995 27
    if (use_version) {
	/* Enable the
	 * feature bundle that corresponds to the required version. */
	use_version = sv_2mortal(new_version(use_version));
	S_enable_feature_bundle(aTHX_ use_version);

	/* If a version >= 5.11.0 is requested, strictures are on by default! */
	if (vcmp(use_version,
		 sv_2mortal(upg_version(newSVnv(5.011000), FALSE))) >= 0) {
	    if (!(PL_hints & HINT_EXPLICIT_STRICT_REFS))
		PL_hints |= HINT_STRICT_REFS;
	    if (!(PL_hints & HINT_EXPLICIT_STRICT_SUBS))
		PL_hints |= HINT_STRICT_SUBS;
	    if (!(PL_hints & HINT_EXPLICIT_STRICT_VARS))
		PL_hints |= HINT_STRICT_VARS;
	}
	/* otherwise they are off */
	else {
	    if (!(PL_hints & HINT_EXPLICIT_STRICT_REFS))
		PL_hints &= ~HINT_STRICT_REFS;
	    if (!(PL_hints & HINT_EXPLICIT_STRICT_SUBS))
		PL_hints &= ~HINT_STRICT_SUBS;
	    if (!(PL_hints & HINT_EXPLICIT_STRICT_VARS))
		PL_hints &= ~HINT_STRICT_VARS;
	}
    }

a4016 2
    if (PL_cop_seqmax == PERL_PADSEQ_INTRO) /* not a legal value */
	PL_cop_seqmax++;
d4037 1
a4037 1
(or 0 for no flags). ver, if specified and not NULL, provides version semantics
a4045 2
The reference count for each specified C<SV*> parameter is decremented.

d4099 1
a4099 1
	    imop = op_append_elem(OP_LIST, imop, newSVOP(OP_CONST, 0, sv));
d4112 1
a4112 1
    lex_start(NULL, NULL, LEX_START_SAME_FILTER);
d4137 1
a4137 1
			       op_append_elem(OP_LIST, term,
a4146 16
/*
=head1 Optree construction

=for apidoc Am|OP *|newSLICEOP|I32 flags|OP *subscript|OP *listval

Constructs, checks, and returns an C<lslice> (list slice) op.  I<flags>
gives the eight bits of C<op_flags>, except that C<OPf_KIDS> will
be set automatically, and, shifted up eight bits, the eight bits of
C<op_private>, except that the bit with value 1 or 2 is automatically
set as required.  I<listval> and I<subscript> supply the parameters of
the slice; they are consumed by this function and become part of the
constructed op tree.

=cut
*/

a4198 93
/*
  Helper function for newASSIGNOP to detection commonality between the
  lhs and the rhs.  Marks all variables with PL_generation.  If it
  returns TRUE the assignment must be able to handle common variables.
*/
PERL_STATIC_INLINE bool
S_aassign_common_vars(pTHX_ OP* o)
{
    OP *curop;
    for (curop = cUNOPo->op_first; curop; curop=curop->op_sibling) {
	if (PL_opargs[curop->op_type] & OA_DANGEROUS) {
	    if (curop->op_type == OP_GV) {
		GV *gv = cGVOPx_gv(curop);
		if (gv == PL_defgv
		    || (int)GvASSIGN_GENERATION(gv) == PL_generation)
		    return TRUE;
		GvASSIGN_GENERATION_set(gv, PL_generation);
	    }
	    else if (curop->op_type == OP_PADSV ||
		curop->op_type == OP_PADAV ||
		curop->op_type == OP_PADHV ||
		curop->op_type == OP_PADANY)
		{
		    if (PAD_COMPNAME_GEN(curop->op_targ)
			== (STRLEN)PL_generation)
			return TRUE;
		    PAD_COMPNAME_GEN_set(curop->op_targ, PL_generation);

		}
	    else if (curop->op_type == OP_RV2CV)
		return TRUE;
	    else if (curop->op_type == OP_RV2SV ||
		curop->op_type == OP_RV2AV ||
		curop->op_type == OP_RV2HV ||
		curop->op_type == OP_RV2GV) {
		if (cUNOPx(curop)->op_first->op_type != OP_GV)	/* funny deref? */
		    return TRUE;
	    }
	    else if (curop->op_type == OP_PUSHRE) {
#ifdef USE_ITHREADS
		if (((PMOP*)curop)->op_pmreplrootu.op_pmtargetoff) {
		    GV *const gv = MUTABLE_GV(PAD_SVl(((PMOP*)curop)->op_pmreplrootu.op_pmtargetoff));
		    if (gv == PL_defgv
			|| (int)GvASSIGN_GENERATION(gv) == PL_generation)
			return TRUE;
		    GvASSIGN_GENERATION_set(gv, PL_generation);
		}
#else
		GV *const gv
		    = ((PMOP*)curop)->op_pmreplrootu.op_pmtargetgv;
		if (gv) {
		    if (gv == PL_defgv
			|| (int)GvASSIGN_GENERATION(gv) == PL_generation)
			return TRUE;
		    GvASSIGN_GENERATION_set(gv, PL_generation);
		}
#endif
	    }
	    else
		return TRUE;
	}

	if (curop->op_flags & OPf_KIDS) {
	    if (aassign_common_vars(curop))
		return TRUE;
	}
    }
    return FALSE;
}

/*
=for apidoc Am|OP *|newASSIGNOP|I32 flags|OP *left|I32 optype|OP *right

Constructs, checks, and returns an assignment op.  I<left> and I<right>
supply the parameters of the assignment; they are consumed by this
function and become part of the constructed op tree.

If I<optype> is C<OP_ANDASSIGN>, C<OP_ORASSIGN>, or C<OP_DORASSIGN>, then
a suitable conditional optree is constructed.  If I<optype> is the opcode
of a binary operator, such as C<OP_BIT_OR>, then an op is constructed that
performs the binary operation and assigns the result to the left argument.
Either way, if I<optype> is non-zero then I<flags> has no effect.

If I<optype> is zero, then a plain scalar or list assignment is
constructed.  Which type of assignment it is is automatically determined.
I<flags> gives the eight bits of C<op_flags>, except that C<OPf_KIDS>
will be set automatically, and, shifted up eight bits, the eight bits
of C<op_private>, except that the bit with value 1 or 2 is automatically
set as required.

=cut
*/

d4208 1
a4208 1
		op_lvalue(scalar(left), optype),
d4213 1
a4213 1
		op_lvalue(scalar(left), optype), scalar(right));
d4224 11
a4234 1
	left = op_lvalue(left, OP_AASSIGN);
d4313 1
d4315 57
a4371 4
	    if (aassign_common_vars(o))
		o->op_private |= OPpASSIGN_COMMON;
	    LINKLIST(o);
	}
d4426 1
a4426 2
	return newBINOP(OP_NULL, flags, op_lvalue(scalar(left), OP_SASSIGN),
		scalar(right));
d4429 1
d4431 11
a4441 1
	    scalar(right), op_lvalue(scalar(left), OP_SASSIGN) );
a4445 18
/*
=for apidoc Am|OP *|newSTATEOP|I32 flags|char *label|OP *o

Constructs a state op (COP).  The state op is normally a C<nextstate> op,
but will be a C<dbstate> op if debugging is enabled for currently-compiled
code.  The state op is populated from L</PL_curcop> (or L</PL_compiling>).
If I<label> is non-null, it supplies the name of a label to attach to
the state op; this function takes ownership of the memory pointed at by
I<label>, and will free it.  I<flags> gives the eight bits of C<op_flags>
for the state op.

If I<o> is null, the state op is returned.  Otherwise the state op is
combined with I<o> into a C<lineseq> list op, which is returned.  I<o>
is consumed by this function and becomes part of the returned op tree.

=cut
*/

a4450 1
    const U32 utf8 = flags & SVf_UTF8;
a4452 2
    flags &= ~SVf_UTF8;

d4471 3
d4475 6
a4480 1
    CopHINTHASH_set(cop, cophh_copy(CopHINTHASH_get(PL_curcop)));
d4482 3
a4484 2
	Perl_cop_store_label(aTHX_ cop, label, strlen(label), utf8);

d4520 1
a4520 1
    return op_prepend_elem(OP_LINESEQ, (OP*)cop, o);
a4522 13
/*
=for apidoc Am|OP *|newLOGOP|I32 type|I32 flags|OP *first|OP *other

Constructs, checks, and returns a logical (flow control) op.  I<type>
is the opcode.  I<flags> gives the eight bits of C<op_flags>, except
that C<OPf_KIDS> will be set automatically, and, shifted up eight bits,
the eight bits of C<op_private>, except that the bit with value 1 is
automatically set.  I<first> supplies the expression controlling the
flow, and I<other> supplies the side (alternate) chain of ops; they are
consumed by this function and become part of the constructed op tree.

=cut
*/
a4637 6
	    else if (other->op_type == OP_MATCH
	          || other->op_type == OP_SUBST
	          || other->op_type == OP_TRANSR
	          || other->op_type == OP_TRANS)
		/* Mark the op as being unbindable with =~ */
		other->op_flags |= OPf_SPECIAL;
d4692 1
a4692 2
                 || k1->op_type == OP_EACH
                 || k1->op_type == OP_AEACH)
a4738 14
/*
=for apidoc Am|OP *|newCONDOP|I32 flags|OP *first|OP *trueop|OP *falseop

Constructs, checks, and returns a conditional-expression (C<cond_expr>)
op.  I<flags> gives the eight bits of C<op_flags>, except that C<OPf_KIDS>
will be set automatically, and, shifted up eight bits, the eight bits of
C<op_private>, except that the bit with value 1 is automatically set.
I<first> supplies the expression selecting between the two branches,
and I<trueop> and I<falseop> supply the branches; they are consumed by
this function and become part of the constructed op tree.

=cut
*/

a4775 4
	else if (live->op_type == OP_MATCH || live->op_type == OP_SUBST
	      || live->op_type == OP_TRANS || live->op_type == OP_TRANSR)
	    /* Mark the op as being unbindable with =~ */
	    live->op_flags |= OPf_SPECIAL;
a4803 14
/*
=for apidoc Am|OP *|newRANGE|I32 flags|OP *left|OP *right

Constructs and returns a C<range> op, with subordinate C<flip> and
C<flop> ops.  I<flags> gives the eight bits of C<op_flags> for the
C<flip> op and, shifted up eight bits, the eight bits of C<op_private>
for both the C<flip> and C<range> ops, except that the bit with value
1 is automatically set.  I<left> and I<right> supply the expressions
controlling the endpoints of the range; they are consumed by this function
and become part of the constructed op tree.

=cut
*/

d4832 1
a4832 1
    LINKLIST(flop);
a4845 6
    /* check barewords before they might be optimized aways */
    if (flip->op_private && cSVOPx(left)->op_private & OPpCONST_STRICT)
	no_bareword_allowed(left);
    if (flop->op_private && cSVOPx(right)->op_private & OPpCONST_STRICT)
	no_bareword_allowed(right);

d4848 1
a4848 1
	LINKLIST(o);		/* blow off optimizer unless constant */
a4852 16
/*
=for apidoc Am|OP *|newLOOPOP|I32 flags|I32 debuggable|OP *expr|OP *block

Constructs, checks, and returns an op tree expressing a loop.  This is
only a loop in the control flow through the op tree; it does not have
the heavyweight loop structure that allows exiting the loop by C<last>
and suchlike.  I<flags> gives the eight bits of C<op_flags> for the
top-level op, except that some bits will be set automatically as required.
I<expr> supplies the expression controlling loop iteration, and I<block>
supplies the body of the loop; they are consumed by this function and
become part of the constructed op tree.  I<debuggable> is currently
unused and should always be 1.

=cut
*/

d4888 1
a4888 2
                     || k1->op_type == OP_EACH
                     || k1->op_type == OP_AEACH))
d4895 1
a4895 1
    /* if block is null, the next op_append_elem() would put UNSTACK, a scalar
d4899 1
a4899 1
    listop = op_append_elem(OP_LINESEQ, block, newOP(OP_UNSTACK, 0));
d4912 1
a4912 1
    o = op_scope(o);
a4916 24
/*
=for apidoc Am|OP *|newWHILEOP|I32 flags|I32 debuggable|LOOP *loop|OP *expr|OP *block|OP *cont|I32 has_my

Constructs, checks, and returns an op tree expressing a C<while> loop.
This is a heavyweight loop, with structure that allows exiting the loop
by C<last> and suchlike.

I<loop> is an optional preconstructed C<enterloop> op to use in the
loop; if it is null then a suitable op will be constructed automatically.
I<expr> supplies the loop's controlling expression.  I<block> supplies the
main body of the loop, and I<cont> optionally supplies a C<continue> block
that operates as a second half of the body.  All of these optree inputs
are consumed by this function and become part of the constructed op tree.

I<flags> gives the eight bits of C<op_flags> for the C<leaveloop>
op and, shifted up eight bits, the eight bits of C<op_private> for
the C<leaveloop> op, except that (in both cases) some bits will be set
automatically.  I<debuggable> is currently unused and should always be 1.
I<has_my> can be supplied as true to force the
loop body to be enclosed in its own scope.

=cut
*/

d4918 2
a4919 2
Perl_newWHILEOP(pTHX_ I32 flags, I32 debuggable, LOOP *loop,
	OP *expr, OP *block, OP *cont, I32 has_my)
d4952 1
a4952 2
                     || k1->op_type == OP_EACH
                     || k1->op_type == OP_AEACH))
d4962 1
a4962 1
	block = op_scope(block);
d4972 1
a4972 1
	cont = op_append_elem(OP_LINESEQ, cont, unstack);
d4976 1
a4976 1
    listop = op_append_list(OP_LINESEQ, block, cont);
d4981 1
a5019 23
/*
=for apidoc Am|OP *|newFOROP|I32 flags|OP *sv|OP *expr|OP *block|OP *cont

Constructs, checks, and returns an op tree expressing a C<foreach>
loop (iteration through a list of values).  This is a heavyweight loop,
with structure that allows exiting the loop by C<last> and suchlike.

I<sv> optionally supplies the variable that will be aliased to each
item in turn; if null, it defaults to C<$_> (either lexical or global).
I<expr> supplies the list of values to iterate over.  I<block> supplies
the main body of the loop, and I<cont> optionally supplies a C<continue>
block that operates as a second half of the body.  All of these optree
inputs are consumed by this function and become part of the constructed
op tree.

I<flags> gives the eight bits of C<op_flags> for the C<leaveloop>
op and, shifted up eight bits, the eight bits of C<op_private> for
the C<leaveloop> op, except that (in both cases) some bits will be set
automatically.

=cut
*/

d5021 1
a5021 1
Perl_newFOROP(pTHX_ I32 flags, OP *sv, OP *expr, OP *block, OP *cont)
d5072 1
a5072 1
        const PADOFFSET offset = pad_findmy_pvs("$_", 0);
d5082 1
a5082 1
	expr = op_lvalue(force_list(scalar(ref(expr, OP_ITER))), OP_GREPSTART);
d5118 1
a5118 1
        expr = op_lvalue(force_list(expr), OP_GREPSTART);
d5122 1
a5122 1
			       op_append_elem(OP_LIST, expr, scalar(sv))));
d5139 1
a5139 1
    wop = newWHILEOP(flags, 1, loop, newOP(OP_ITER, 0), block, cont, 0);
d5142 2
a5143 1
    return wop;
a5145 11
/*
=for apidoc Am|OP *|newLOOPEX|I32 type|OP *label

Constructs, checks, and returns a loop-exiting op (such as C<goto>
or C<last>).  I<type> is the opcode.  I<label> supplies the parameter
determining the target of the op; it is consumed by this function and
become part of the constructed op tree.

=cut
*/

d5161 3
a5163 7
	    o = newPVOP(type,
                        label->op_type == OP_CONST
                            ? SvUTF8(((SVOP*)label)->op_sv)
                            : 0,
                        savesharedpv(label->op_type == OP_CONST
				? SvPV_nolen_const(((SVOP*)label)->op_sv)
				: ""));
d5175 1
a5175 1
	    label = newUNOP(OP_REFGEN, 0, op_lvalue(label, OP_REFGEN));
d5194 2
a5195 13
	return newUNOP(OP_REFGEN, 0, op_lvalue(cond, OP_REFGEN));

    else if(cond
    && (cond->op_type == OP_ASLICE
    ||  cond->op_type == OP_HSLICE)) {

	/* anonlist now needs a list from this op, was previously used in
	 * scalar context */
	cond->op_flags |= ~(OPf_WANT_SCALAR | OPf_REF);
	cond->op_flags |= OPf_WANT_LIST;

	return newANONLIST(op_lvalue(cond, OP_ANONLIST));
    }
a5241 1
	o      ->op_flags |= OPf_SPECIAL;
a5335 13
/*
=for apidoc Am|OP *|newGIVENOP|OP *cond|OP *block|PADOFFSET defsv_off

Constructs, checks, and returns an op tree expressing a C<given> block.
I<cond> supplies the expression that will be locally assigned to a lexical
variable, and I<block> supplies the body of the C<given> construct; they
are consumed by this function and become part of the constructed op tree.
I<defsv_off> is the pad offset of the scalar lexical variable that will
be affected.

=cut
*/

d5348 1
a5348 13
/*
=for apidoc Am|OP *|newWHENOP|OP *cond|OP *block

Constructs, checks, and returns an op tree expressing a C<when> block.
I<cond> supplies the test expression, and I<block> supplies the block
that will be executed if the test evaluates to true; they are consumed
by this function and become part of the constructed op tree.  I<cond>
will be interpreted DWIMically, often as a comparison against C<$_>,
and may be null to generate a C<default> block.

=cut
*/

d5365 4
a5368 1
    return newGIVWHENOP(cond_op, block, OP_ENTERWHEN, OP_LEAVEWHEN, 0);
d5371 11
d5383 1
a5383 2
Perl_cv_ckproto_len_flags(pTHX_ const CV *cv, const GV *gv, const char *p,
		    const STRLEN len, const U32 flags)
d5385 3
a5387 2
    const char * const cvp = CvPROTO(cv);
    const STRLEN clen = CvPROTOLEN(cv);
d5389 46
a5434 1
    PERL_ARGS_ASSERT_CV_CKPROTO_LEN_FLAGS;
d5436 11
a5446 12
    if (((!p != !cvp) /* One has prototype, one has not.  */
	|| (p && (
		  (flags & SVf_UTF8) == SvUTF8(cv)
		   ? len != clen || memNE(cvp, p, len)
		   : flags & SVf_UTF8
		      ? bytes_cmp_utf8((const U8 *)cvp, clen,
				       (const U8 *)p, len)
		      : bytes_cmp_utf8((const U8 *)p, len,
				       (const U8 *)cvp, clen)
		 )
	   )
        )
d5457 1
a5457 3
	    Perl_sv_catpvf(aTHX_ msg, " (%"SVf")",
		SVfARG(newSVpvn_flags(cvp,clen, SvUTF8(cv)|SVs_TEMP))
	    );
d5462 1
a5462 1
	    Perl_sv_catpvf(aTHX_ msg, "(%"SVf")", SVfARG(newSVpvn_flags(p, len, flags | SVs_TEMP)));
d5512 1
a5512 1
 *	candidate. Try to grab the current value, and in the case of
d5537 1
a5537 3
	    if (type == OP_NEXTSTATE
	     || (type == OP_NULL && !(o->op_flags & OPf_KIDS))
	     || type == OP_PUSHMARK)
d5605 1
a5605 1
Perl_newATTRSUB(pTHX_ I32 floor, OP *o, OP *proto, OP *attrs, OP *block)
d5607 1
a5607 1
    return newATTRSUB_flags(floor, o, proto, attrs, block, 0);
d5611 1
a5611 2
Perl_newATTRSUB_flags(pTHX_ I32 floor, OP *o, OP *proto, OP *attrs,
			    OP *block, U32 flags)
d5616 1
a5616 2
    STRLEN ps_len = 0; /* init it to avoid false uninit warning from icc */
    U32 ps_utf8 = 0;
d5628 1
a5628 4
    STRLEN namlen = 0;
    const bool o_is_gv = flags & 1;
    const char * const name =
	 o ? SvPV_const(o_is_gv ? (SV *)o : cSVOPo->op_sv, namlen) : NULL;
a5629 1
    bool name_is_utf8 = o && !o_is_gv && SvUTF8(cSVOPo->op_sv);
a5633 1
        ps_utf8 = SvUTF8(((SVOP*)proto)->op_sv);
d5638 1
a5638 5
    if (o_is_gv) {
	gv = (GV*)o;
	o = NULL;
	has_name = TRUE;
    } else if (name) {
d5673 1
a5673 1
	    cv_ckproto_len_flags((const CV *)gv, NULL, ps, ps_len, ps_utf8);
d5675 1
a5675 1
	if (ps) {
a5676 2
            if ( ps_utf8 ) SvUTF8_on(MUTABLE_SV(gv));
        }
d5705 1
a5705 1
            cv_ckproto_len_flags(cv, gv, ps, ps_len, ps_utf8);
d5712 1
a5712 1
		 )) {
d5715 1
a5715 3
		    const bool pureperl = !CvISXSUB(cv) && CvROOT(cv);
		    if (CvLVALUE(PL_compcv) && ! CvLVALUE(cv) && pureperl
		     && ckWARN(WARN_MISC))
d5717 1
a5717 3
		    CvFLAGS(cv) |=
			(CvFLAGS(PL_compcv) & CVf_BUILTIN_ATTRS
			  & ~(CVf_LVALUE * pureperl));
a5718 1
		if (attrs) goto attrs;
d5728 6
a5733 2
		const line_t oldline = CopLINE(PL_curcop);
		if (PL_parser && PL_parser->copline != NOLINE)
d5735 5
a5739 2
		report_redefined_cv(cSVOPo->op_sv, cv, &const_sv);
		CopLINE_set(PL_curcop, oldline);
a5751 1
	HV *stash;
d5762 2
a5763 5
	    GvCV_set(gv, NULL);
	    cv = newCONSTSUB_flags(
		NULL, name, namlen, name_is_utf8 ? SVf_UTF8 : 0,
		const_sv
	    );
d5765 1
a5765 1
	stash =
d5770 2
a5771 3
                    : PL_curstash;
	if (HvENAME_HEK(stash))
            mro_method_changed_in(stash); /* sub Foo::Bar () { 123 } */
d5787 1
a5787 8
	    AV *const temp_av = CvPADLIST(cv);
	    CV *const temp_cv = CvOUTSIDE(cv);

	    assert(!CvWEAKOUTSIDE(cv));
	    assert(!CvCVGV_RC(cv));
	    assert(CvGV(cv) == gv);

	    SvPOK_off(cv);
d5789 2
d5793 1
d5795 1
a5795 9
	    CvOUTSIDE(PL_compcv) = temp_cv;
	    CvPADLIST(PL_compcv) = temp_av;

	    if (CvFILE(cv) && CvDYNFILE(cv)) {
		Safefree(CvFILE(cv));
    }
	    CvFILE_set_from_cop(cv, PL_curcop);
	    CvSTASH_set(cv, PL_curstash);

d5812 1
a5812 1
	    GvCV_set(gv, cv);
d5821 1
a5821 3
	    if (HvENAME_HEK(GvSTASH(gv)))
		/* sub Foo::bar { (shift)+1 } */
		mro_method_changed_in(GvSTASH(gv));
d5825 1
a5825 1
	CvGV_set(cv, gv);
d5827 6
a5832 1
	CvSTASH_set(cv, PL_curstash);
d5835 1
a5835 1
    if (ps) {
a5836 2
        if ( ps_utf8 ) SvUTF8_on(MUTABLE_SV(cv));
    }
d5859 1
a5859 1
	goto attrs;
d5867 8
a5874 2
    /* This makes sub {}; work as expected.  */
    if (block->op_type == OP_STUB) {
d5882 4
a5886 5
    else block->op_attached = 1;
    CvROOT(cv) = CvLVALUE(cv)
		   ? newUNOP(OP_LEAVESUBLV, 0,
			     op_lvalue(scalarseq(block), OP_LEAVESUBLV))
		   : newUNOP(OP_LEAVESUB, 0, scalarseq(block));
a5891 1
    finalize_optree(CvROOT(cv));
d5903 1
a5903 8
  attrs:
    if (attrs) {
	/* Need to do a C<use attributes $stash_of_cv,\&cv,@@attrs>. */
	HV *stash = name && GvSTASH(CvGV(cv)) ? GvSTASH(CvGV(cv)) : PL_curstash;
	apply_attrs(stash, MUTABLE_SV(cv), attrs, FALSE);
    }

    if (block && has_name) {
d5905 1
d5910 4
a5913 4
	    SV * const sv = Perl_newSVpvf(aTHX_ "%s:%ld-%ld",
					  CopFILE(PL_curcop),
					  (long)PL_subline,
					  (long)CopLINE(PL_curcop));
d5916 1
a5916 1
		    SvUTF8(tmpstr) ? -(I32)SvCUR(tmpstr) : (I32)SvCUR(tmpstr), sv, 0);
d5918 1
a5918 1
	    if (HvTOTALKEYS(hv) > 0 && hv_exists(hv, SvPVX_const(tmpstr), SvUTF8(tmpstr) ? -(I32)SvCUR(tmpstr) : (I32)SvCUR(tmpstr))) {
a5955 1
	    SAVEVPTR(PL_curcop);
d5959 1
a5959 1
	    GvCV_set(gv,0);		/* cv has been hijacked */
d5962 1
a5984 1
		    /* diag_listed_as: Too late to run %s block */
a5993 1
		    /* diag_listed_as: Too late to run %s block */
d6003 1
a6003 1
	GvCV_set(gv,0);		/* cv has been hijacked */
a6009 14
See L</newCONSTSUB_flags>.

=cut
*/

CV *
Perl_newCONSTSUB(pTHX_ HV *stash, const char *name, SV *sv)
{
    return newCONSTSUB_flags(stash, name, name ? strlen(name) : 0, 0, sv);
}

/*
=for apidoc newCONSTSUB_flags

a6012 2
Currently, the only useful value for C<flags> is SVf_UTF8.

d6022 1
a6022 2
Perl_newCONSTSUB_flags(pTHX_ HV *stash, const char *name, STRLEN len,
                             U32 flags, SV *sv)
a6039 2
	 SAVECOMPILEWARNINGS();
	 PL_compiling.cop_warnings = DUP_WARNINGS(PL_curcop->cop_warnings);
d6049 1
a6049 1
	SAVEGENERICSV(PL_curstash);
d6051 1
a6051 1
	PL_curstash = (HV *)SvREFCNT_inc_simple_NN(stash);
d6055 1
a6055 1
    /* file becomes the CvFILE. For an XS, it's usually static storage,
d6059 2
a6060 2
    cv = newXS_len_flags(name, len, const_sv_xsub, file ? file : "", "",
			 &sv, XS_DYNAMIC_FILENAME | flags);
d6078 2
a6080 4
    return newXS_len_flags(
       name, name ? strlen(name) : 0, subaddr, filename, proto, NULL, flags
    );
}
d6082 20
a6101 7
CV *
Perl_newXS_len_flags(pTHX_ const char *name, STRLEN len,
			   XSUBADDR_t subaddr, const char *const filename,
			   const char *const proto, SV **const_svp,
			   U32 flags)
{
    CV *cv;
d6103 13
a6115 67
    PERL_ARGS_ASSERT_NEWXS_LEN_FLAGS;

    {
        GV * const gv = name
			 ? gv_fetchpvn(
				name,len,GV_ADDMULTI|flags,SVt_PVCV
			   )
			 : gv_fetchpv(
                            (PL_curstash ? "__ANON__" : "__ANON__::__ANON__"),
                            GV_ADDMULTI | flags, SVt_PVCV);
    
        if (!subaddr)
            Perl_croak(aTHX_ "panic: no address for '%s' in '%s'", name, filename);
    
        if ((cv = (name ? GvCV(gv) : NULL))) {
            if (GvCVGEN(gv)) {
                /* just a cached method */
                SvREFCNT_dec(cv);
                cv = NULL;
            }
            else if (CvROOT(cv) || CvXSUB(cv) || GvASSUMECV(gv)) {
                /* already defined (or promised) */
                /* Redundant check that allows us to avoid creating an SV
                   most of the time: */
                if (CvCONST(cv) || ckWARN(WARN_REDEFINE)) {
                    const line_t oldline = CopLINE(PL_curcop);
                    if (PL_parser && PL_parser->copline != NOLINE)
                        CopLINE_set(PL_curcop, PL_parser->copline);
                    report_redefined_cv(newSVpvn_flags(
                                         name,len,(flags&SVf_UTF8)|SVs_TEMP
                                        ),
                                        cv, const_svp);
                    CopLINE_set(PL_curcop, oldline);
                }
                SvREFCNT_dec(cv);
                cv = NULL;
            }
        }
    
        if (cv)				/* must reuse cv if autoloaded */
            cv_undef(cv);
        else {
            cv = MUTABLE_CV(newSV_type(SVt_PVCV));
            if (name) {
                GvCV_set(gv,cv);
                GvCVGEN(gv) = 0;
                if (HvENAME_HEK(GvSTASH(gv)))
                    mro_method_changed_in(GvSTASH(gv)); /* newXS */
            }
        }
        if (!name)
            CvANON_on(cv);
        CvGV_set(cv, gv);
        (void)gv_fetchfile(filename);
        CvFILE(cv) = (char *)filename; /* NOTE: not copied, as it is expected to be
                                    an external constant string */
        assert(!CvDYNFILE(cv)); /* cv_undef should have turned it off */
        CvISXSUB_on(cv);
        CvXSUB(cv) = subaddr;
    
        if (name)
            process_special_blocks(name, gv, cv);
    }

    if (flags & XS_DYNAMIC_FILENAME) {
	CvFILE(cv) = savepv(filename);
	CvDYNFILE_on(cv);
a6116 1
    sv_setpv(MUTABLE_SV(cv), proto);
d6132 6
d6139 60
a6198 1
    return newXS_flags(name, subaddr, filename, NULL, 0);
a6227 1
		/* diag_listed_as: Format %s redefined */
d6237 1
a6237 1
    CvGV_set(cv, gv);
a6247 1
    finalize_optree(CvROOT(cv));
d6417 1
a6417 1
    cSVOPo->op_targ = pad_add_anon((CV*)cSVOPo->op_sv, o->op_type);
d6430 8
a6458 30
PERL_STATIC_INLINE bool
is_dollar_bracket(pTHX_ const OP * const o)
{
    const OP *kid;
    return o->op_type == OP_RV2SV && o->op_flags & OPf_KIDS
	&& (kid = cUNOPx(o)->op_first)
	&& kid->op_type == OP_GV
	&& strEQ(GvNAME(cGVOPx_gv(kid)), "[");
}

OP *
Perl_ck_cmp(pTHX_ OP *o)
{
    PERL_ARGS_ASSERT_CK_CMP;
    if (ckWARN(WARN_SYNTAX)) {
	const OP *kid = cUNOPo->op_first;
	if (kid && (
		(
		   is_dollar_bracket(aTHX_ kid)
		&& kid->op_sibling && kid->op_sibling->op_type == OP_CONST
		)
	     || (  kid->op_type == OP_CONST
		&& (kid = kid->op_sibling) && is_dollar_bracket(aTHX_ kid))
	   ))
	    Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
			"$[ used in %s (did you mean $] ?)", OP_DESC(o));
    }
    return o;
}

a6555 1
	OP *kid;
d6566 1
a6566 4
	o = ck_fun(o);
	kid = cLISTOPo->op_first;
	if (kid->op_type == OP_RV2GV)
	    kid->op_private |= OPpALLOW_FAKE;
d6605 1
a6605 1
	    o = op_prepend_elem(OP_LINESEQ, (OP*)enter, (OP*)kid);
a6617 1
	const U8 priv = o->op_private;
d6623 1
a6623 1
	o = newUNOP(OP_ENTEREVAL, priv <<8, newDEFSVOP());
d6627 1
a6627 3
    if (o->op_private & OPpEVAL_BYTES) o->op_targ &= ~HINT_UTF8;
    if ((PL_hints & HINT_LOCALIZE_HH) != 0
     && !(o->op_private & OPpEVAL_COPHH) && GvHV(PL_hintgv)) {
d6630 1
a6630 1
			   MUTABLE_SV(hv_copy_hints_hv(GvHV(PL_hintgv))));
a6633 3
    if (!(o->op_private & OPpEVAL_BYTES)
	 && FEATURE_UNIEVAL_IS_ENABLED)
	    o->op_private |= OPpEVAL_UNICODE;
d6744 11
a6811 2
	    /* FAKE globs in the symbol table cause weird bugs (#77810) */
	    SvFAKE_off(gv);
d6844 2
a6845 2
	if (PL_check[kidtype] == Perl_ck_ftst
	        && kidtype != OP_STAT && kidtype != OP_LSTAT) {
a6846 7
	    kid->op_private |= OPpFT_STACKING;
	    if (kidtype == OP_FTTTY && (
		   !(kid->op_private & OPpFT_STACKED)
		|| kid->op_private & OPpFT_AFTER_t
	       ))
		o->op_private |= OPpFT_AFTER_t;
	}
a6883 1
	bool seen_optional = FALSE;
d6891 2
a6892 18
	if (kid && kid->op_type == OP_COREARGS) {
	    bool optional = FALSE;
	    while (oa) {
		numargs++;
		if (oa & OA_OPTIONAL) optional = TRUE;
		oa = oa >> 4;
	    }
	    if (optional) o->op_private |= numargs;
	    return o;
	}

	while (oa) {
	    if (oa & OA_OPTIONAL || (oa & 7) == OA_LIST) {
		if (!kid && !seen_optional && PL_opargs[type] & OA_DEFGV)
		    *tokid = kid = newDEFSVOP();
		seen_optional = TRUE;
	    }
	    if (!kid) break;
d6894 1
d6909 1
a6909 1
		    return too_many_arguments_pv(o,PL_op_desc[type], 0);
d6945 3
a6947 9
		else if (kid->op_type == OP_CONST
		      && (  !SvROK(cSVOPx_sv(kid)) 
		         || SvTYPE(SvRV(cSVOPx_sv(kid))) != SVt_PVAV  )
		        )
		    bad_type_pv(numargs, "array", PL_op_desc[type], 0, kid);
		/* Defer checks to run-time if we have a scalar arg */
		if (kid->op_type == OP_RV2AV || kid->op_type == OP_PADAV)
		    op_lvalue(kid, type);
		else scalar(kid);
d6968 2
a6969 2
		    bad_type_pv(numargs, "hash", PL_op_desc[type], 0, kid);
		op_lvalue(kid, type);
d6975 1
a6975 1
		    LINKLIST(kid);
d7001 1
a7001 1
			bad_type_pv(numargs, "HANDLE", OP_DESC(o), 0, kid);
a7011 2
                            U32 name_utf8 = 0;
			    bool want_dollar = TRUE;
a7022 1
                                name_utf8 = SvUTF8(namesv);
a7029 1
                                name_utf8 = GvNAMEUTF8(gv) ? SVf_UTF8 : 0;
a7068 1
                                           name_utf8 = SvUTF8(tmpstr);
a7074 1
				      want_dollar = FALSE;
d7076 1
a7076 1
				 op_lvalue(kid, type);
d7083 1
a7083 1
				if (want_dollar && *name != '$')
a7085 1
                                if ( name_utf8 ) SvUTF8_on(namesv);
d7099 1
a7099 1
		op_lvalue(scalar(kid), type);
d7108 1
a7108 1
	    return too_many_arguments_pv(o,OP_DESC(o), 0);
d7114 1
a7114 1
	    return too_many_arguments_pv(o,OP_DESC(o), 0);
d7134 1
a7134 1
	    return too_few_arguments_pv(o,OP_DESC(o), 0);
a7143 1
    const bool core = o->op_flags & OPf_SPECIAL;
d7149 1
a7149 1
	op_append_elem(OP_GLOB, o, newDEFSVOP()); /* glob() => glob($_) */
d7151 1
a7151 2
    if (core) gv = NULL;
    else if (!((gv = gv_fetchpvs("glob", GV_NOTQUAL, SVt_PVCV))
d7158 1
d7160 1
d7164 6
d7172 1
a7172 1
#endif /* !PERL_EXTERNAL_GLOB */
d7175 1
a7175 15
	/* convert
	 *     glob
	 *       \ null - const(wildcard)
	 * into
	 *     null
	 *       \ enter
	 *            \ list
	 *                 \ mark - glob - rv2cv
	 *                             |        \ gv(CORE::GLOBAL::glob)
	 *                             |
	 *                              \ null - const(wildcard) - const(ix)
	 */
	o->op_flags |= OPf_SPECIAL;
	o->op_targ = pad_alloc(OP_GLOB, SVs_PADTMP);
	op_append_elem(OP_GLOB, o,
d7177 5
a7181 1
	o = newLISTOP(OP_LIST, 0, o, NULL);
d7183 1
a7183 1
		    op_append_elem(OP_LIST, o,
d7187 1
a7187 1
	o->op_targ = OP_GLOB; /* hint at what it used to be: eg in newWHILEOP */
a7189 1
    else o->op_flags &= ~OPf_SPECIAL;
d7192 1
a7192 4
#ifndef PERL_EXTERNAL_GLOB
    sv_setiv(GvSVn(gv),PL_glob_index++);
#endif
    op_append_elem(OP_GLOB, o, newGVOP(OP_GV, 0, gv));
d7234 1
a7234 1
	Perl_croak(aTHX_ "panic: ck_grep, type=%u", (unsigned) kid->op_type);
d7245 1
a7245 1
    offset = pad_findmy_pvs("$_", 0);
d7257 1
a7257 1
	return too_few_arguments_pv(o,OP_DESC(o), 0);
d7259 1
a7259 1
	op_lvalue(kid, OP_GREPSTART);
d7273 1
a7273 2
	if (kid && kid->op_type == OP_CONST) {
	    const bool save_taint = PL_tainted;
a7274 2
	    PL_tainted = save_taint;
	}
d7297 5
d7329 1
a7329 5
    if (o->op_flags & OPf_KIDS) {
	 OP *kid = cLISTOPo->op_first;
	 if (kid->op_type == OP_RV2GV) kid->op_private |= OPpALLOW_FAKE;
    }
    else {
d7379 1
a7379 1
	op_append_elem(o->op_type, o, newDEFSVOP());
a7380 1
    if (o->op_type == OP_PRTF) return modkids(listkids(o), OP_PRTF);
a7387 1
    PERL_ARGS_ASSERT_CK_SMARTMATCH;
d7448 1
a7448 7
	/* For state variable assignment, kkid is a list op whose op_last
	   is a padsv. */
	if ((kkid->op_type == OP_PADSV ||
	     (kkid->op_type == OP_LIST &&
	      (kkid = cLISTOPx(kkid)->op_last)->op_type == OP_PADSV
	     )
	    )
d7467 1
a7467 1
	       assignment binop->op_last = binop->op_first->op_sibling; at the
d7485 1
a7485 1
	const PADOFFSET offset = pad_findmy_pvs("$_", 0);
d7509 1
a7509 1
		sv = newSVpvn_share(method, SvUTF8(sv) ? -(I32)SvCUR(sv) : (I32)SvCUR(sv), 0);
d7668 4
a7671 8
	OP *kid, *newop;
	if (o->op_flags & OPf_KIDS) {
	    kid = cUNOPo->op_first;
	    cUNOPo->op_first = NULL;
	}
	else {
	    kid = newDEFSVOP();
	}
d7676 1
a7676 1
				op_append_elem(OP_LIST, kid,
d7698 14
a7711 1
	    op_lvalue(kid, OP_LEAVESUBLV);
d7731 1
a7731 1
	    return fold_constants(op_integerize(op_std_init(o)));
d7750 2
a7751 8
	OP *argop;

	if (!CvUNIQUE(PL_compcv)) {
	    o->op_flags |= OPf_SPECIAL;
	    return o;
	}

	argop = newUNOP(OP_RV2AV, 0, scalar(newGVOP(OP_GV, 0, PL_argvgv)));
d7753 4
a7756 6
	{
	    OP * const oldo = o;
	    o = newUNOP(type, 0, scalar(argop));
	    op_getmad(oldo,o,'O');
	    return o;
	}
d7762 1
a7762 1
    return scalar(ck_fun(o));
d7795 1
a7795 1
	    LINKLIST(kid);
d7832 2
d7935 1
a7935 1
	Perl_croak(aTHX_ "panic: ck_split, type=%u", (unsigned) kid->op_type);
d7938 2
a7939 3
    if (kid)
	cLISTOPo->op_first = kid;
    else {
d7963 1
a7963 1
	op_append_elem(OP_SPLIT, o, newDEFSVOP());
d7969 1
a7969 1
	op_append_elem(OP_SPLIT, o, newSVOP(OP_CONST, 0, newSViv(0)));
d7976 1
a7976 1
	return too_many_arguments_pv(o,OP_DESC(o), 0);
d7991 2
a7992 4
            const SV *msg = re
                    ? newSVpvn_flags( RX_PRECOMP_const(re), RX_PRELEN(re),
                                            SVs_TEMP | ( RX_UTF8(re) ? SVf_UTF8 : 0 ) )
                    : newSVpvs_flags( "STRING", SVs_TEMP );
d7994 2
a7995 2
			"/%"SVf"/ should probably be written as \"%"SVf"\"",
			SVfARG(msg), SVfARG(msg));
d8001 17
a8017 2
/*
=for apidoc Am|CV *|rv2cv_op_cv|OP *cvop|U32 flags
d8019 1
a8019 32
Examines an op, which is expected to identify a subroutine at runtime,
and attempts to determine at compile time which subroutine it identifies.
This is normally used during Perl compilation to determine whether
a prototype can be applied to a function call.  I<cvop> is the op
being considered, normally an C<rv2cv> op.  A pointer to the identified
subroutine is returned, if it could be determined statically, and a null
pointer is returned if it was not possible to determine statically.

Currently, the subroutine can be identified statically if the RV that the
C<rv2cv> is to operate on is provided by a suitable C<gv> or C<const> op.
A C<gv> op is suitable if the GV's CV slot is populated.  A C<const> op is
suitable if the constant value must be an RV pointing to a CV.  Details of
this process may change in future versions of Perl.  If the C<rv2cv> op
has the C<OPpENTERSUB_AMPER> flag set then no attempt is made to identify
the subroutine statically: this flag is used to suppress compile-time
magic on a subroutine call, forcing it to use default runtime behaviour.

If I<flags> has the bit C<RV2CVOPCV_MARK_EARLY> set, then the handling
of a GV reference is modified.  If a GV was examined and its CV slot was
found to be empty, then the C<gv> op has the C<OPpEARLY_CV> flag set.
If the op is not optimised away, and the CV slot is later populated with
a subroutine having a prototype, that flag eventually triggers the warning
"called too early to check prototype".

If I<flags> has the bit C<RV2CVOPCV_RETURN_NAME_GV> set, then instead
of returning a pointer to the subroutine it returns a pointer to the
GV giving the most appropriate name for the subroutine in this context.
Normally this is just the C<CvGV> of the subroutine, but for an anonymous
(C<CvANON>) subroutine that is referenced through a GV it will be the
referencing GV.  The resulting C<GV*> is cast to C<CV*> to be returned.
A null pointer is returned as usual if there is no statically-determinable
subroutine.
d8021 26
a8046 27
=cut
*/

CV *
Perl_rv2cv_op_cv(pTHX_ OP *cvop, U32 flags)
{
    OP *rvop;
    CV *cv;
    GV *gv;
    PERL_ARGS_ASSERT_RV2CV_OP_CV;
    if (flags & ~(RV2CVOPCV_MARK_EARLY|RV2CVOPCV_RETURN_NAME_GV))
	Perl_croak(aTHX_ "panic: rv2cv_op_cv bad flags %x", (unsigned)flags);
    if (cvop->op_type != OP_RV2CV)
	return NULL;
    if (cvop->op_private & OPpENTERSUB_AMPER)
	return NULL;
    if (!(cvop->op_flags & OPf_KIDS))
	return NULL;
    rvop = cUNOPx(cvop)->op_first;
    switch (rvop->op_type) {
	case OP_GV: {
	    gv = cGVOPx_gv(rvop);
	    cv = GvCVu(gv);
	    if (!cv) {
		if (flags & RV2CVOPCV_MARK_EARLY)
		    rvop->op_private |= OPpEARLY_CV;
		return NULL;
d8048 1
a8048 11
	} break;
	case OP_CONST: {
	    SV *rv = cSVOPx_sv(rvop);
	    if (!SvROK(rv))
		return NULL;
	    cv = (CV*)SvRV(rv);
	    gv = NULL;
	} break;
	default: {
	    return NULL;
	} break;
d8050 7
a8056 36
    if (SvTYPE((SV*)cv) != SVt_PVCV)
	return NULL;
    if (flags & RV2CVOPCV_RETURN_NAME_GV) {
	if (!CvANON(cv) || !gv)
	    gv = CvGV(cv);
	return (CV*)gv;
    } else {
	return cv;
    }
}

/*
=for apidoc Am|OP *|ck_entersub_args_list|OP *entersubop

Performs the default fixup of the arguments part of an C<entersub>
op tree.  This consists of applying list context to each of the
argument ops.  This is the standard treatment used on a call marked
with C<&>, or a method call, or a call through a subroutine reference,
or any other call where the callee can't be identified at compile time,
or a call where the callee has no prototype.

=cut
*/

OP *
Perl_ck_entersub_args_list(pTHX_ OP *entersubop)
{
    OP *aop;
    PERL_ARGS_ASSERT_CK_ENTERSUB_ARGS_LIST;
    aop = cUNOPx(entersubop)->op_first;
    if (!aop->op_sibling)
	aop = cUNOPx(aop)->op_first;
    for (aop = aop->op_sibling; aop->op_sibling; aop = aop->op_sibling) {
	if (!(PL_madskills && aop->op_type == OP_STUB)) {
	    list(aop);
	    op_lvalue(aop, OP_ENTERSUB);
d8059 4
a8062 56
    return entersubop;
}

/*
=for apidoc Am|OP *|ck_entersub_args_proto|OP *entersubop|GV *namegv|SV *protosv

Performs the fixup of the arguments part of an C<entersub> op tree
based on a subroutine prototype.  This makes various modifications to
the argument ops, from applying context up to inserting C<refgen> ops,
and checking the number and syntactic types of arguments, as directed by
the prototype.  This is the standard treatment used on a subroutine call,
not marked with C<&>, where the callee can be identified at compile time
and has a prototype.

I<protosv> supplies the subroutine prototype to be applied to the call.
It may be a normal defined scalar, of which the string value will be used.
Alternatively, for convenience, it may be a subroutine object (a C<CV*>
that has been cast to C<SV*>) which has a prototype.  The prototype
supplied, in whichever form, does not need to match the actual callee
referenced by the op tree.

If the argument ops disagree with the prototype, for example by having
an unacceptable number of arguments, a valid op tree is returned anyway.
The error is reflected in the parser state, normally resulting in a single
exception at the top level of parsing which covers all the compilation
errors that occurred.  In the error message, the callee is referred to
by the name defined by the I<namegv> parameter.

=cut
*/

OP *
Perl_ck_entersub_args_proto(pTHX_ OP *entersubop, GV *namegv, SV *protosv)
{
    STRLEN proto_len;
    const char *proto, *proto_end;
    OP *aop, *prev, *cvop;
    int optional = 0;
    I32 arg = 0;
    I32 contextclass = 0;
    const char *e = NULL;
    PERL_ARGS_ASSERT_CK_ENTERSUB_ARGS_PROTO;
    if (SvTYPE(protosv) == SVt_PVCV ? !SvPOK(protosv) : !SvOK(protosv))
	Perl_croak(aTHX_ "panic: ck_entersub_args_proto CV with no proto, "
		   "flags=%lx", (unsigned long) SvFLAGS(protosv));
    if (SvTYPE(protosv) == SVt_PVCV)
	 proto = CvPROTO(protosv), proto_len = CvPROTOLEN(protosv);
    else proto = SvPV(protosv, proto_len);
    proto_end = proto + proto_len;
    aop = cUNOPx(entersubop)->op_first;
    if (!aop->op_sibling)
	aop = cUNOPx(aop)->op_first;
    prev = aop;
    aop = aop->op_sibling;
    for (cvop = aop; cvop->op_sibling; cvop = cvop->op_sibling) ;
    while (aop != cvop) {
d8064 2
a8065 2
	if (PL_madskills && aop->op_type == OP_STUB) {
	    aop = aop->op_sibling;
d8068 2
a8069 2
	if (PL_madskills && aop->op_type == OP_NULL)
	    o3 = ((UNOP*)aop)->op_first;
d8071 4
a8074 1
	    o3 = aop;
d8076 1
a8076 4
	if (proto >= proto_end)
	    return too_many_arguments_sv(entersubop, gv_ename(namegv), 0);

	switch (*proto) {
d8083 1
a8083 1
		if (proto[1] && !strchr(";@@%", proto[1]))
d8088 1
a8088 1
		scalar(aop);
d8092 1
a8092 1
		list(aop);
d8099 3
a8101 3
		    bad_type_sv(arg,
			    arg == 1 ? "block or sub {}" : "sub {}",
			    gv_ename(namegv), 0, o3);
d8120 3
a8122 3
				    (gvop->op_private & OPpENTERSUB_NOPAREN) &&
				    (gvop = ((UNOP*)gvop)->op_first) &&
				    gvop->op_type == OP_GV)
d8125 1
a8125 1
				OP * const sibling = aop->op_sibling;
d8128 1
a8128 1
				OP * const oldaop = aop;
d8130 1
a8130 1
				op_free(aop);
d8133 4
a8136 4
				aop = newSVOP(OP_CONST, 0, n);
				op_getmad(oldaop,aop,'O');
				prev->op_sibling = aop;
				aop->op_sibling = sibling;
d8141 1
a8141 13
		scalar(aop);
		break;
	    case '+':
		proto++;
		arg++;
		if (o3->op_type == OP_RV2AV ||
		    o3->op_type == OP_PADAV ||
		    o3->op_type == OP_RV2HV ||
		    o3->op_type == OP_PADHV
		) {
		    goto wrapref;
		}
		scalar(aop);
d8144 2
a8145 2
		goto oops;
		break;
d8151 73
a8223 87
		    case '[':
			if (contextclass++ == 0) {
			    e = strchr(proto, ']');
			    if (!e || e == proto)
				goto oops;
			}
			else
			    goto oops;
			goto again;
			break;
		    case ']':
			if (contextclass) {
			    const char *p = proto;
			    const char *const end = proto;
			    contextclass = 0;
			    while (*--p != '[')
				/* \[$] accepts any scalar lvalue */
				if (*p == '$'
				 && Perl_op_lvalue_flags(aTHX_
				     scalar(o3),
				     OP_READ, /* not entersub */
				     OP_LVALUE_NO_CROAK
				    )) goto wrapref;
			    bad_type_sv(arg, Perl_form(aTHX_ "one of %.*s",
					(int)(end - p), p),
				    gv_ename(namegv), 0, o3);
			} else
			    goto oops;
			break;
		    case '*':
			if (o3->op_type == OP_RV2GV)
			    goto wrapref;
			if (!contextclass)
			    bad_type_sv(arg, "symbol", gv_ename(namegv), 0, o3);
			break;
		    case '&':
			if (o3->op_type == OP_ENTERSUB)
			    goto wrapref;
			if (!contextclass)
			    bad_type_sv(arg, "subroutine entry", gv_ename(namegv), 0,
				    o3);
			break;
		    case '$':
			if (o3->op_type == OP_RV2SV ||
				o3->op_type == OP_PADSV ||
				o3->op_type == OP_HELEM ||
				o3->op_type == OP_AELEM)
			    goto wrapref;
			if (!contextclass) {
			    /* \$ accepts any scalar lvalue */
			    if (Perl_op_lvalue_flags(aTHX_
				    scalar(o3),
				    OP_READ,  /* not entersub */
				    OP_LVALUE_NO_CROAK
			       )) goto wrapref;
			    bad_type_sv(arg, "scalar", gv_ename(namegv), 0, o3);
			}
			break;
		    case '@@':
			if (o3->op_type == OP_RV2AV ||
				o3->op_type == OP_PADAV)
			    goto wrapref;
			if (!contextclass)
			    bad_type_sv(arg, "array", gv_ename(namegv), 0, o3);
			break;
		    case '%':
			if (o3->op_type == OP_RV2HV ||
				o3->op_type == OP_PADHV)
			    goto wrapref;
			if (!contextclass)
			    bad_type_sv(arg, "hash", gv_ename(namegv), 0, o3);
			break;
		    wrapref:
			{
			    OP* const kid = aop;
			    OP* const sib = kid->op_sibling;
			    kid->op_sibling = 0;
			    aop = newUNOP(OP_REFGEN, 0, kid);
			    aop->op_sibling = sib;
			    prev->op_sibling = aop;
			}
			if (contextclass && e) {
			    proto = e + 1;
			    contextclass = 0;
			}
			break;
		    default: goto oops;
d8226 1
a8226 1
		    goto again;
d8232 4
a8235 6
	    oops: {
                SV* const tmpsv = sv_newmortal();
                gv_efullname3(tmpsv, namegv, NULL);
		Perl_croak(aTHX_ "Malformed prototype for %"SVf": %"SVf,
			SVfARG(tmpsv), SVfARG(protosv));
            }
d8237 7
a8243 6

	op_lvalue(aop, OP_ENTERSUB);
	prev = aop;
	aop = aop->op_sibling;
    }
    if (aop == cvop && *proto == '_') {
d8245 3
a8247 3
	aop = newDEFSVOP();
	aop->op_sibling = prev->op_sibling;
	prev->op_sibling = aop; /* instead of cvop */
d8249 1
a8249 1
    if (!optional && proto_end > proto &&
d8251 2
a8252 84
	return too_few_arguments_sv(entersubop, gv_ename(namegv), 0);
    return entersubop;
}

/*
=for apidoc Am|OP *|ck_entersub_args_proto_or_list|OP *entersubop|GV *namegv|SV *protosv

Performs the fixup of the arguments part of an C<entersub> op tree either
based on a subroutine prototype or using default list-context processing.
This is the standard treatment used on a subroutine call, not marked
with C<&>, where the callee can be identified at compile time.

I<protosv> supplies the subroutine prototype to be applied to the call,
or indicates that there is no prototype.  It may be a normal scalar,
in which case if it is defined then the string value will be used
as a prototype, and if it is undefined then there is no prototype.
Alternatively, for convenience, it may be a subroutine object (a C<CV*>
that has been cast to C<SV*>), of which the prototype will be used if it
has one.  The prototype (or lack thereof) supplied, in whichever form,
does not need to match the actual callee referenced by the op tree.

If the argument ops disagree with the prototype, for example by having
an unacceptable number of arguments, a valid op tree is returned anyway.
The error is reflected in the parser state, normally resulting in a single
exception at the top level of parsing which covers all the compilation
errors that occurred.  In the error message, the callee is referred to
by the name defined by the I<namegv> parameter.

=cut
*/

OP *
Perl_ck_entersub_args_proto_or_list(pTHX_ OP *entersubop,
	GV *namegv, SV *protosv)
{
    PERL_ARGS_ASSERT_CK_ENTERSUB_ARGS_PROTO_OR_LIST;
    if (SvTYPE(protosv) == SVt_PVCV ? SvPOK(protosv) : SvOK(protosv))
	return ck_entersub_args_proto(entersubop, namegv, protosv);
    else
	return ck_entersub_args_list(entersubop);
}

OP *
Perl_ck_entersub_args_core(pTHX_ OP *entersubop, GV *namegv, SV *protosv)
{
    int opnum = SvTYPE(protosv) == SVt_PVCV ? 0 : (int)SvUV(protosv);
    OP *aop = cUNOPx(entersubop)->op_first;

    PERL_ARGS_ASSERT_CK_ENTERSUB_ARGS_CORE;

    if (!opnum) {
	OP *cvop;
	if (!aop->op_sibling)
	    aop = cUNOPx(aop)->op_first;
	aop = aop->op_sibling;
	for (cvop = aop; cvop->op_sibling; cvop = cvop->op_sibling) ;
	if (PL_madskills) while (aop != cvop && aop->op_type == OP_STUB) {
	    aop = aop->op_sibling;
	}
	if (aop != cvop)
	    (void)too_many_arguments_pv(entersubop, GvNAME(namegv), 0);
	
	op_free(entersubop);
	switch(GvNAME(namegv)[2]) {
	case 'F': return newSVOP(OP_CONST, 0,
					newSVpv(CopFILE(PL_curcop),0));
	case 'L': return newSVOP(
	                   OP_CONST, 0,
                           Perl_newSVpvf(aTHX_
	                     "%"IVdf, (IV)CopLINE(PL_curcop)
	                   )
	                 );
	case 'P': return newSVOP(OP_CONST, 0,
	                           (PL_curstash
	                             ? newSVhek(HvNAME_HEK(PL_curstash))
	                             : &PL_sv_undef
	                           )
	                        );
	}
	assert(0);
    }
    else {
	OP *prev, *cvop;
	U32 flags;
d8254 3
a8256 1
	bool seenarg = FALSE;
d8258 2
a8259 186
	if (!aop->op_sibling)
	    aop = cUNOPx(aop)->op_first;
	
	prev = aop;
	aop = aop->op_sibling;
	prev->op_sibling = NULL;
	for (cvop = aop;
	     cvop->op_sibling;
	     prev=cvop, cvop = cvop->op_sibling)
#ifdef PERL_MAD
	    if (PL_madskills && cvop->op_sibling
	     && cvop->op_type != OP_STUB) seenarg = TRUE
#endif
	    ;
	prev->op_sibling = NULL;
	flags = OPf_SPECIAL * !(cvop->op_private & OPpENTERSUB_NOPAREN);
	op_free(cvop);
	if (aop == cvop) aop = NULL;
	op_free(entersubop);

	if (opnum == OP_ENTEREVAL
	 && GvNAMELEN(namegv)==9 && strnEQ(GvNAME(namegv), "evalbytes", 9))
	    flags |= OPpEVAL_BYTES <<8;
	
	switch (PL_opargs[opnum] & OA_CLASS_MASK) {
	case OA_UNOP:
	case OA_BASEOP_OR_UNOP:
	case OA_FILESTATOP:
	    return aop ? newUNOP(opnum,flags,aop) : newOP(opnum,flags);
	case OA_BASEOP:
	    if (aop) {
#ifdef PERL_MAD
		if (!PL_madskills || seenarg)
#endif
		    (void)too_many_arguments_pv(aop, GvNAME(namegv), 0);
		op_free(aop);
	    }
	    return opnum == OP_RUNCV
		? newPVOP(OP_RUNCV,0,NULL)
		: newOP(opnum,0);
	default:
	    return convert(opnum,0,aop);
	}
    }
    assert(0);
    return entersubop;
}

/*
=for apidoc Am|void|cv_get_call_checker|CV *cv|Perl_call_checker *ckfun_p|SV **ckobj_p

Retrieves the function that will be used to fix up a call to I<cv>.
Specifically, the function is applied to an C<entersub> op tree for a
subroutine call, not marked with C<&>, where the callee can be identified
at compile time as I<cv>.

The C-level function pointer is returned in I<*ckfun_p>, and an SV
argument for it is returned in I<*ckobj_p>.  The function is intended
to be called in this manner:

    entersubop = (*ckfun_p)(aTHX_ entersubop, namegv, (*ckobj_p));

In this call, I<entersubop> is a pointer to the C<entersub> op,
which may be replaced by the check function, and I<namegv> is a GV
supplying the name that should be used by the check function to refer
to the callee of the C<entersub> op if it needs to emit any diagnostics.
It is permitted to apply the check function in non-standard situations,
such as to a call to a different subroutine or to a method call.

By default, the function is
L<Perl_ck_entersub_args_proto_or_list|/ck_entersub_args_proto_or_list>,
and the SV parameter is I<cv> itself.  This implements standard
prototype processing.  It can be changed, for a particular subroutine,
by L</cv_set_call_checker>.

=cut
*/

void
Perl_cv_get_call_checker(pTHX_ CV *cv, Perl_call_checker *ckfun_p, SV **ckobj_p)
{
    MAGIC *callmg;
    PERL_ARGS_ASSERT_CV_GET_CALL_CHECKER;
    callmg = SvMAGICAL((SV*)cv) ? mg_find((SV*)cv, PERL_MAGIC_checkcall) : NULL;
    if (callmg) {
	*ckfun_p = DPTR2FPTR(Perl_call_checker, callmg->mg_ptr);
	*ckobj_p = callmg->mg_obj;
    } else {
	*ckfun_p = Perl_ck_entersub_args_proto_or_list;
	*ckobj_p = (SV*)cv;
    }
}

/*
=for apidoc Am|void|cv_set_call_checker|CV *cv|Perl_call_checker ckfun|SV *ckobj

Sets the function that will be used to fix up a call to I<cv>.
Specifically, the function is applied to an C<entersub> op tree for a
subroutine call, not marked with C<&>, where the callee can be identified
at compile time as I<cv>.

The C-level function pointer is supplied in I<ckfun>, and an SV argument
for it is supplied in I<ckobj>.  The function is intended to be called
in this manner:

    entersubop = ckfun(aTHX_ entersubop, namegv, ckobj);

In this call, I<entersubop> is a pointer to the C<entersub> op,
which may be replaced by the check function, and I<namegv> is a GV
supplying the name that should be used by the check function to refer
to the callee of the C<entersub> op if it needs to emit any diagnostics.
It is permitted to apply the check function in non-standard situations,
such as to a call to a different subroutine or to a method call.

The current setting for a particular CV can be retrieved by
L</cv_get_call_checker>.

=cut
*/

void
Perl_cv_set_call_checker(pTHX_ CV *cv, Perl_call_checker ckfun, SV *ckobj)
{
    PERL_ARGS_ASSERT_CV_SET_CALL_CHECKER;
    if (ckfun == Perl_ck_entersub_args_proto_or_list && ckobj == (SV*)cv) {
	if (SvMAGICAL((SV*)cv))
	    mg_free_type((SV*)cv, PERL_MAGIC_checkcall);
    } else {
	MAGIC *callmg;
	sv_magic((SV*)cv, &PL_sv_undef, PERL_MAGIC_checkcall, NULL, 0);
	callmg = mg_find((SV*)cv, PERL_MAGIC_checkcall);
	if (callmg->mg_flags & MGf_REFCOUNTED) {
	    SvREFCNT_dec(callmg->mg_obj);
	    callmg->mg_flags &= ~MGf_REFCOUNTED;
	}
	callmg->mg_ptr = FPTR2DPTR(char *, ckfun);
	callmg->mg_obj = ckobj;
	if (ckobj != (SV*)cv) {
	    SvREFCNT_inc_simple_void_NN(ckobj);
	    callmg->mg_flags |= MGf_REFCOUNTED;
	}
    }
}

OP *
Perl_ck_subr(pTHX_ OP *o)
{
    OP *aop, *cvop;
    CV *cv;
    GV *namegv;

    PERL_ARGS_ASSERT_CK_SUBR;

    aop = cUNOPx(o)->op_first;
    if (!aop->op_sibling)
	aop = cUNOPx(aop)->op_first;
    aop = aop->op_sibling;
    for (cvop = aop; cvop->op_sibling; cvop = cvop->op_sibling) ;
    cv = rv2cv_op_cv(cvop, RV2CVOPCV_MARK_EARLY);
    namegv = cv ? (GV*)rv2cv_op_cv(cvop, RV2CVOPCV_RETURN_NAME_GV) : NULL;

    o->op_private &= ~1;
    o->op_private |= OPpENTERSUB_HASTARG;
    o->op_private |= (PL_hints & HINT_STRICT_REFS);
    if (PERLDB_SUB && PL_curstash != PL_debstash)
	o->op_private |= OPpENTERSUB_DB;
    if (cvop->op_type == OP_RV2CV) {
	o->op_private |= (cvop->op_private & OPpENTERSUB_AMPER);
	op_null(cvop);
    } else if (cvop->op_type == OP_METHOD || cvop->op_type == OP_METHOD_NAMED) {
	if (aop->op_type == OP_CONST)
	    aop->op_private &= ~OPpCONST_STRICT;
	else if (aop->op_type == OP_LIST) {
	    OP * const sib = ((UNOP*)aop)->op_first->op_sibling;
	    if (sib && sib->op_type == OP_CONST)
		sib->op_private &= ~OPpCONST_STRICT;
	}
    }

    if (!cv) {
	return ck_entersub_args_list(o);
    } else {
	Perl_call_checker ckfun;
	SV *ckobj;
	cv_get_call_checker(cv, &ckfun, &ckobj);
	return ckfun(aTHX_ o, namegv, ckobj);
d8261 1
a8275 1
    PERL_ARGS_ASSERT_CK_CHDIR;
d8310 15
a8342 13
Perl_ck_tell(pTHX_ OP *o)
{
    PERL_ARGS_ASSERT_CK_TELL;
    o = ck_fun(o);
    if (o->op_flags & OPf_KIDS) {
     OP *kid = cLISTOPo->op_first;
     if (kid->op_type == OP_NULL && kid->op_sibling) kid = kid->op_sibling;
     if (kid->op_type == OP_RV2GV) kid->op_private |= OPpALLOW_FAKE;
    }
    return o;
}

OP *
d8346 1
a8346 6
    OP *kid = o->op_flags & OPf_KIDS ? cUNOPo->op_first : NULL;
    const unsigned orig_type  = o->op_type;
    const unsigned array_type = orig_type == OP_EACH ? OP_AEACH
	                      : orig_type == OP_KEYS ? OP_AKEYS : OP_AVALUES;
    const unsigned ref_type   = orig_type == OP_EACH ? OP_REACH
	                      : orig_type == OP_KEYS ? OP_RKEYS : OP_RVALUES;
d8351 11
a8361 19
	switch (kid->op_type) {
	    case OP_PADHV:
	    case OP_RV2HV:
		break;
	    case OP_PADAV:
	    case OP_RV2AV:
		CHANGE_TYPE(o, array_type);
		break;
	    case OP_CONST:
		if (kid->op_private == OPpCONST_BARE
		 || !SvROK(cSVOPx_sv(kid))
		 || (  SvTYPE(SvRV(cSVOPx_sv(kid))) != SVt_PVAV
		    && SvTYPE(SvRV(cSVOPx_sv(kid))) != SVt_PVHV  )
		   )
		    /* we let ck_fun handle it */
		    break;
	    default:
		CHANGE_TYPE(o, ref_type);
		scalar(kid);
d8364 1
a8364 54
    /* if treating as a reference, defer additional checks to runtime */
    return o->op_type == ref_type ? o : ck_fun(o);
}

OP *
Perl_ck_length(pTHX_ OP *o)
{
    PERL_ARGS_ASSERT_CK_LENGTH;

    o = ck_fun(o);

    if (ckWARN(WARN_SYNTAX)) {
        const OP *kid = o->op_flags & OPf_KIDS ? cLISTOPo->op_first : NULL;

        if (kid) {
            SV *name = NULL;
            const bool hash = kid->op_type == OP_PADHV
                           || kid->op_type == OP_RV2HV;
            switch (kid->op_type) {
                case OP_PADHV:
                case OP_PADAV:
                    name = varname(
                        (GV *)PL_compcv, hash ? '%' : '@@', kid->op_targ,
                        NULL, 0, 1
                    );
                    break;
                case OP_RV2HV:
                case OP_RV2AV:
                    if (cUNOPx(kid)->op_first->op_type != OP_GV) break;
                    {
                        GV *gv = cGVOPx_gv(cUNOPx(kid)->op_first);
                        if (!gv) break;
                        name = varname(gv, hash?'%':'@@', 0, NULL, 0, 1);
                    }
                    break;
                default:
                    return o;
            }
            if (name)
                Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
                    "length() used on %"SVf" (did you mean \"scalar(%s%"SVf
                    ")\"?)",
                    name, hash ? "keys " : "", name
                );
            else if (hash)
                Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
                    "length() used on %%hash (did you mean \"scalar(keys %%hash)\"?)");
            else
                Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
                    "length() used on @@array (did you mean \"scalar(@@array)\"?)");
        }
    }

    return o;
d8395 3
a8397 2
/* Check for in place reverse and sort assignments like "@@a = reverse @@a"
   and modify the optree to make them work inplace */
d8399 13
a8411 2
STATIC void
S_inplace_aassign(pTHX_ OP *o) {
d8413 24
a8436 3
    OP *modop, *modop_pushmark;
    OP *oright;
    OP *oleft, *oleft_pushmark;
d8438 1
a8438 1
    PERL_ARGS_ASSERT_INPLACE_AASSIGN;
d8440 8
a8447 39
    assert((o->op_flags & OPf_WANT) == OPf_WANT_VOID);

    assert(cUNOPo->op_first->op_type == OP_NULL);
    modop_pushmark = cUNOPx(cUNOPo->op_first)->op_first;
    assert(modop_pushmark->op_type == OP_PUSHMARK);
    modop = modop_pushmark->op_sibling;

    if (modop->op_type != OP_SORT && modop->op_type != OP_REVERSE)
	return;

    /* no other operation except sort/reverse */
    if (modop->op_sibling)
	return;

    assert(cUNOPx(modop)->op_first->op_type == OP_PUSHMARK);
    if (!(oright = cUNOPx(modop)->op_first->op_sibling)) return;

    if (modop->op_flags & OPf_STACKED) {
	/* skip sort subroutine/block */
	assert(oright->op_type == OP_NULL);
	oright = oright->op_sibling;
    }

    assert(cUNOPo->op_first->op_sibling->op_type == OP_NULL);
    oleft_pushmark = cUNOPx(cUNOPo->op_first->op_sibling)->op_first;
    assert(oleft_pushmark->op_type == OP_PUSHMARK);
    oleft = oleft_pushmark->op_sibling;

    /* Check the lhs is an array */
    if (!oleft ||
	(oleft->op_type != OP_RV2AV && oleft->op_type != OP_PADAV)
	|| oleft->op_sibling
	|| (oleft->op_private & OPpLVAL_INTRO)
    )
	return;

    /* Only one thing on the rhs */
    if (oright->op_sibling)
	return;
a8453 1
	    || cUNOPx(oleft )->op_first->op_type != OP_GV
d8457 1
a8457 1
	    return;
d8462 1
a8462 5
	return;

    /* This actually is an inplace assignment */

    modop->op_private |= OPpSORT_INPLACE;
d8464 1
a8464 9
    /* transfer MODishness etc from LHS arg to RHS arg */
    oright->op_flags = oleft->op_flags;

    /* remove the aassign op and the lhs */
    op_null(o);
    op_null(oleft_pushmark);
    if (oleft->op_type == OP_RV2AV && cUNOPx(oleft)->op_first)
	op_null(cUNOPx(oleft)->op_first);
    op_null(oleft);
a8466 10
#define MAX_DEFERRED 4

#define DEFER(o) \
    if (defer_ix == (MAX_DEFERRED-1)) { \
	CALL_RPEEP(defer_queue[defer_base]); \
	defer_base = (defer_base + 1) % MAX_DEFERRED; \
	defer_ix--; \
    } \
    defer_queue[(defer_base + ++defer_ix) % MAX_DEFERRED] = o;

d8472 1
a8472 1
Perl_rpeep(pTHX_ register OP *o)
a8475 3
    OP* defer_queue[MAX_DEFERRED]; /* small queue of deferred branches */
    int defer_base = 0;
    int defer_ix = -1;
d8482 2
a8483 6
    for (;; o = o->op_next) {
	if (o && o->op_opt)
	    o = NULL;
	if (!o) {
	    while (defer_ix >= 0)
		CALL_RPEEP(defer_queue[(defer_base + defer_ix--) % MAX_DEFERRED]);
a8484 2
	}

d8490 1
a8493 2
	case OP_NEXTSTATE:
	    PL_curcop = ((COP*)o);		/* for warnings */
d8495 3
a8497 20
	    /* Two NEXTSTATEs in a row serve no purpose. Except if they happen
	       to carry two labels. For now, take the easier option, and skip
	       this optimisation if the first NEXTSTATE has a label.  */
	    if (!CopLABEL((COP*)o) && !PERLDB_NOOPT) {
		OP *nextop = o->op_next;
		while (nextop && nextop->op_type == OP_NULL)
		    nextop = nextop->op_next;

		if (nextop && (nextop->op_type == OP_NEXTSTATE)) {
		    COP *firstcop = (COP *)o;
		    COP *secondcop = (COP *)nextop;
		    /* We want the COP pointed to by o (and anything else) to
		       become the next COP down the line.  */
		    cop_free(firstcop);

		    firstcop->op_next = secondcop->op_next;

		    /* Now steal all its pointers, and duplicate the other
		       data.  */
		    firstcop->cop_line = secondcop->cop_line;
d8499 32
a8530 27
		    firstcop->cop_stashpv = secondcop->cop_stashpv;
		    firstcop->cop_stashlen = secondcop->cop_stashlen;
		    firstcop->cop_file = secondcop->cop_file;
#else
		    firstcop->cop_stash = secondcop->cop_stash;
		    firstcop->cop_filegv = secondcop->cop_filegv;
#endif
		    firstcop->cop_hints = secondcop->cop_hints;
		    firstcop->cop_seq = secondcop->cop_seq;
		    firstcop->cop_warnings = secondcop->cop_warnings;
		    firstcop->cop_hints_hash = secondcop->cop_hints_hash;

#ifdef USE_ITHREADS
		    secondcop->cop_stashpv = NULL;
		    secondcop->cop_file = NULL;
#else
		    secondcop->cop_stash = NULL;
		    secondcop->cop_filegv = NULL;
#endif
		    secondcop->cop_warnings = NULL;
		    secondcop->cop_hints_hash = NULL;

		    /* If we use op_null(), and hence leave an ex-COP, some
		       warnings are misreported. For example, the compile-time
		       error in 'use strict; no strict refs;'  */
		    secondcop->op_type = OP_NULL;
		    secondcop->op_ppaddr = PL_ppaddr[OP_NULL];
d8532 2
d8535 1
d8565 1
a8565 1
	       to rpeep() from mistakenly concluding that optimisation
d8593 3
a8595 1
		    (i = SvIV(((SVOP*)pop)->op_sv)) <= 255 && i >= 0)
a8610 1
			o->op_type = OP_AELEMFAST;
d8613 2
a8614 1
			o->op_type = OP_AELEMFAST_LEX;
d8629 11
d8671 1
a8671 4
	    while (o->op_next && (   o->op_type == o->op_next->op_type
				  || o->op_next->op_type == OP_NULL))
		o->op_next = o->op_next->op_next;
	    DEFER(cLOGOP->op_other);
d8722 1
a8722 1
	    DEFER(cLOGOP->op_other);
d8729 1
d8732 1
d8735 1
a8735 4
	    /* a while(1) loop doesn't have an op_next that escapes the
	     * loop, so we have to explicitly follow the op_lastop to
	     * process the rest of the code */
	    DEFER(cLOOP->op_lastop);
d8744 122
a8865 1
	    DEFER(cPMOP->op_pmstashstartu.op_pmreplstart);
d8867 1
d8870 4
a8878 3
	    if (o->op_private & OPpSORT_INPLACE)
		break;

d8898 31
d8935 1
d8938 24
a8961 1
	    if (o->op_private & OPpSORT_INPLACE)
d8963 1
d9049 4
a9052 62
	case OP_QR:
	case OP_MATCH:
	    if (!(cPMOP->op_pmflags & PMf_ONCE)) {
		assert (!cPMOP->op_pmstashstartu.op_pmreplstart);
	    }
	    break;

	case OP_RUNCV:
	    if (!(o->op_private & OPpOFFBYONE) && !CvCLONE(PL_compcv)) {
		SV *sv;
		if (CvEVAL(PL_compcv)) sv = &PL_sv_undef;
		else {
		    sv = newRV((SV *)PL_compcv);
		    sv_rvweaken(sv);
		    SvREADONLY_on(sv);
		}
		o->op_type = OP_CONST;
		o->op_ppaddr = PL_ppaddr[OP_CONST];
		o->op_flags |= OPf_SPECIAL;
		cSVOPo->op_sv = sv;
	    }
	    break;

	case OP_SASSIGN:
	    if (OP_GIMME(o,0) == G_VOID) {
		OP *right = cBINOP->op_first;
		if (right) {
		    OP *left = right->op_sibling;
		    if (left->op_type == OP_SUBSTR
			 && (left->op_private & 7) < 4) {
			op_null(o);
			cBINOP->op_first = left;
			right->op_sibling =
			    cBINOPx(left)->op_first->op_sibling;
			cBINOPx(left)->op_first->op_sibling = right;
			left->op_private |= OPpSUBSTR_REPL_FIRST;
			left->op_flags =
			    (o->op_flags & ~OPf_WANT) | OPf_WANT_VOID;
		    }
		}
	    }
	    break;

	case OP_CUSTOM: {
	    Perl_cpeep_t cpeep = 
		XopENTRY(Perl_custom_op_xop(aTHX_ o), xop_peep);
	    if (cpeep)
		cpeep(aTHX_ o, oldop);
	    break;
	}
	    
	}
	oldop = o;
    }
    LEAVE;
}

void
Perl_peep(pTHX_ register OP *o)
{
    CALL_RPEEP(o);
}
d9054 2
a9055 2
/*
=head1 Custom Operators
d9057 2
a9058 3
=for apidoc Ao||custom_op_xop
Return the XOP structure for a given custom op. This function should be
considered internal to OP_NAME and the other access macros: use them instead.
d9060 3
a9062 2
=cut
*/
d9064 1
a9064 43
const XOP *
Perl_custom_op_xop(pTHX_ const OP *o)
{
    SV *keysv;
    HE *he = NULL;
    XOP *xop;

    static const XOP xop_null = { 0, 0, 0, 0, 0 };

    PERL_ARGS_ASSERT_CUSTOM_OP_XOP;
    assert(o->op_type == OP_CUSTOM);

    /* This is wrong. It assumes a function pointer can be cast to IV,
     * which isn't guaranteed, but this is what the old custom OP code
     * did. In principle it should be safer to Copy the bytes of the
     * pointer into a PV: since the new interface is hidden behind
     * functions, this can be changed later if necessary.  */
    /* Change custom_op_xop if this ever happens */
    keysv = sv_2mortal(newSViv(PTR2IV(o->op_ppaddr)));

    if (PL_custom_ops)
	he = hv_fetch_ent(PL_custom_ops, keysv, 0, 0);

    /* assume noone will have just registered a desc */
    if (!he && PL_custom_op_names &&
	(he = hv_fetch_ent(PL_custom_op_names, keysv, 0, 0))
    ) {
	const char *pv;
	STRLEN l;

	/* XXX does all this need to be shared mem? */
	Newxz(xop, 1, XOP);
	pv = SvPV(HeVAL(he), l);
	XopENTRY_set(xop, xop_name, savepvn(pv, l));
	if (PL_custom_op_descs &&
	    (he = hv_fetch_ent(PL_custom_op_descs, keysv, 0, 0))
	) {
	    pv = SvPV(HeVAL(he), l);
	    XopENTRY_set(xop, xop_desc, savepvn(pv, l));
	}
	Perl_custom_op_register(aTHX_ o->op_ppaddr, xop);
	return xop;
    }
d9066 2
a9067 1
    if (!he) return &xop_null;
d9069 4
a9072 3
    xop = INT2PTR(XOP *, SvIV(HeVAL(he)));
    return xop;
}
d9074 2
a9075 3
/*
=for apidoc Ao||custom_op_register
Register a custom op. See L<perlguts/"Custom Operators">.
d9077 1
a9077 2
=cut
*/
d9079 2
a9080 4
void
Perl_custom_op_register(pTHX_ Perl_ppaddr_t ppaddr, const XOP *xop)
{
    SV *keysv;
d9082 3
a9084 1
    PERL_ARGS_ASSERT_CUSTOM_OP_REGISTER;
d9086 3
a9088 2
    /* see the comment in custom_op_xop */
    keysv = sv_2mortal(newSViv(PTR2IV(ppaddr)));
d9090 2
a9091 2
    if (!PL_custom_ops)
	PL_custom_ops = newHV();
d9093 7
a9099 67
    if (!hv_store_ent(PL_custom_ops, keysv, newSViv(PTR2IV(xop)), 0))
	Perl_croak(aTHX_ "panic: can't register custom OP %s", xop->xop_name);
}

/*
=head1 Functions in file op.c

=for apidoc core_prototype
This function assigns the prototype of the named core function to C<sv>, or
to a new mortal SV if C<sv> is NULL.  It returns the modified C<sv>, or
NULL if the core function has no prototype.  C<code> is a code as returned
by C<keyword()>.  It must be negative and unequal to -KEY_CORE.

=cut
*/

SV *
Perl_core_prototype(pTHX_ SV *sv, const char *name, const int code,
                          int * const opnum)
{
    int i = 0, n = 0, seen_question = 0, defgv = 0;
    I32 oa;
#define MAX_ARGS_OP ((sizeof(I32) - 1) * 2)
    char str[ MAX_ARGS_OP * 2 + 2 ]; /* One ';', one '\0' */
    bool nullret = FALSE;

    PERL_ARGS_ASSERT_CORE_PROTOTYPE;

    assert (code < 0 && code != -KEY_CORE);

    if (!sv) sv = sv_newmortal();

#define retsetpvs(x,y) sv_setpvs(sv, x); if(opnum) *opnum=(y); return sv

    switch (-code) {
    case KEY_and   : case KEY_chop: case KEY_chomp:
    case KEY_cmp   : case KEY_exec: case KEY_eq   :
    case KEY_ge    : case KEY_gt  : case KEY_le   :
    case KEY_lt    : case KEY_ne  : case KEY_or   :
    case KEY_select: case KEY_system: case KEY_x  : case KEY_xor:
	if (!opnum) return NULL; nullret = TRUE; goto findopnum;
    case KEY_keys:    retsetpvs("+", OP_KEYS);
    case KEY_values:  retsetpvs("+", OP_VALUES);
    case KEY_each:    retsetpvs("+", OP_EACH);
    case KEY_push:    retsetpvs("+@@", OP_PUSH);
    case KEY_unshift: retsetpvs("+@@", OP_UNSHIFT);
    case KEY_pop:     retsetpvs(";+", OP_POP);
    case KEY_shift:   retsetpvs(";+", OP_SHIFT);
    case KEY_splice:
	retsetpvs("+;$$@@", OP_SPLICE);
    case KEY___FILE__: case KEY___LINE__: case KEY___PACKAGE__:
	retsetpvs("", 0);
    case KEY_evalbytes:
	name = "entereval"; break;
    case KEY_readpipe:
	name = "backtick";
    }

#undef retsetpvs

  findopnum:
    while (i < MAXO) {	/* The slow way. */
	if (strEQ(name, PL_op_name[i])
	    || strEQ(name, PL_op_desc[i]))
	{
	    if (nullret) { assert(opnum); *opnum = i; return NULL; }
	    goto found;
d9101 1
a9101 1
	i++;
d9103 1
a9103 39
    assert(0); return NULL;    /* Should not happen... */
  found:
    defgv = PL_opargs[i] & OA_DEFGV;
    oa = PL_opargs[i] >> OASHIFT;
    while (oa) {
	if (oa & OA_OPTIONAL && !seen_question && (
	      !defgv || (oa & (OA_OPTIONAL - 1)) == OA_FILEREF
	)) {
	    seen_question = 1;
	    str[n++] = ';';
	}
	if ((oa & (OA_OPTIONAL - 1)) >= OA_AVREF
	    && (oa & (OA_OPTIONAL - 1)) <= OA_SCALARREF
	    /* But globs are already references (kinda) */
	    && (oa & (OA_OPTIONAL - 1)) != OA_FILEREF
	) {
	    str[n++] = '\\';
	}
	if ((oa & (OA_OPTIONAL - 1)) == OA_SCALARREF
	 && !scalar_mod_type(NULL, i)) {
	    str[n++] = '[';
	    str[n++] = '$';
	    str[n++] = '@@';
	    str[n++] = '%';
	    if (i == OP_LOCK) str[n++] = '&';
	    str[n++] = '*';
	    str[n++] = ']';
	}
	else str[n++] = ("?$@@@@%&*$")[oa & (OA_OPTIONAL - 1)];
	if (oa & OA_OPTIONAL && defgv && str[n-1] == '$') {
	    str[n-1] = '_'; defgv = 0;
	}
	oa = oa >> 4;
    }
    if (code == -KEY_not || code == -KEY_getprotobynumber) str[n++] = ';';
    str[n++] = '\0';
    sv_setpvn(sv, str, n - 1);
    if (opnum) *opnum = i;
    return sv;
d9106 2
a9107 3
OP *
Perl_coresub_op(pTHX_ SV * const coreargssv, const int code,
                      const int opnum)
d9109 4
a9112 2
    OP * const argop = newSVOP(OP_COREARGS,0,coreargssv);
    OP *o;
d9114 1
a9114 1
    PERL_ARGS_ASSERT_CORESUB_OP;
d9116 2
a9117 58
    switch(opnum) {
    case 0:
	return op_append_elem(OP_LINESEQ,
	               argop,
	               newSLICEOP(0,
	                          newSVOP(OP_CONST, 0, newSViv(-code % 3)),
	                          newOP(OP_CALLER,0)
	               )
	       );
    case OP_SELECT: /* which represents OP_SSELECT as well */
	if (code)
	    return newCONDOP(
	                 0,
	                 newBINOP(OP_GT, 0,
	                          newAVREF(newGVOP(OP_GV, 0, PL_defgv)),
	                          newSVOP(OP_CONST, 0, newSVuv(1))
	                         ),
	                 coresub_op(newSVuv((UV)OP_SSELECT), 0,
	                            OP_SSELECT),
	                 coresub_op(coreargssv, 0, OP_SELECT)
	           );
	/* FALL THROUGH */
    default:
	switch (PL_opargs[opnum] & OA_CLASS_MASK) {
	case OA_BASEOP:
	    return op_append_elem(
	                OP_LINESEQ, argop,
	                newOP(opnum,
	                      opnum == OP_WANTARRAY || opnum == OP_RUNCV
	                        ? OPpOFFBYONE << 8 : 0)
	           );
	case OA_BASEOP_OR_UNOP:
	    if (opnum == OP_ENTEREVAL) {
		o = newUNOP(OP_ENTEREVAL,OPpEVAL_COPHH<<8,argop);
		if (code == -KEY_evalbytes) o->op_private |= OPpEVAL_BYTES;
	    }
	    else o = newUNOP(opnum,0,argop);
	    if (opnum == OP_CALLER) o->op_private |= OPpOFFBYONE;
	    else {
	  onearg:
	      if (is_handle_constructor(o, 1))
		argop->op_private |= OPpCOREARGS_DEREF1;
	    }
	    return o;
	default:
	    o = convert(opnum,0,argop);
	    if (is_handle_constructor(o, 2))
		argop->op_private |= OPpCOREARGS_DEREF2;
	    if (scalar_mod_type(NULL, opnum))
		argop->op_private |= OPpCOREARGS_SCALARMOD;
	    if (opnum == OP_SUBSTR) {
		o->op_private |= OPpMAYBE_LVSUB;
		return o;
	    }
	    else goto onearg;
	}
    }
}
d9119 1
a9119 7
void
Perl_report_redefined_cv(pTHX_ const SV *name, const CV *old_cv,
			       SV * const *new_const_svp)
{
    const char *hvname;
    bool is_const = !!CvCONST(old_cv);
    SV *old_const_sv = is_const ? cv_const_sv(old_cv) : NULL;
d9121 3
a9123 1
    PERL_ARGS_ASSERT_REPORT_REDEFINED_CV;
d9125 1
a9125 27
    if (is_const && new_const_svp && old_const_sv == *new_const_svp)
	return;
	/* They are 2 constant subroutines generated from
	   the same constant. This probably means that
	   they are really the "same" proxy subroutine
	   instantiated in 2 places. Most likely this is
	   when a constant is exported twice.  Don't warn.
	*/
    if (
	(ckWARN(WARN_REDEFINE)
	 && !(
		CvGV(old_cv) && GvSTASH(CvGV(old_cv))
	     && HvNAMELEN(GvSTASH(CvGV(old_cv))) == 7
	     && (hvname = HvNAME(GvSTASH(CvGV(old_cv))),
		 strEQ(hvname, "autouse"))
	     )
	)
     || (is_const
	 && ckWARN_d(WARN_REDEFINE)
	 && (!new_const_svp || sv_cmp(old_const_sv, *new_const_svp))
	)
    )
	Perl_warner(aTHX_ packWARN(WARN_REDEFINE),
			  is_const
			    ? "Constant subroutine %"SVf" redefined"
			    : "Subroutine %"SVf" redefined",
			  name);
d9128 7
a9134 2
/*
=head1 Hook manipulation
d9136 1
a9136 2
These functions provide convenient and thread-safe means of manipulating
hook variables.
d9138 2
a9139 2
=cut
*/
d9141 1
a9141 2
/*
=for apidoc Am|void|wrap_op_checker|Optype opcode|Perl_check_t new_checker|Perl_check_t *old_checker_p
d9143 3
a9145 33
Puts a C function into the chain of check functions for a specified op
type.  This is the preferred way to manipulate the L</PL_check> array.
I<opcode> specifies which type of op is to be affected.  I<new_checker>
is a pointer to the C function that is to be added to that opcode's
check chain, and I<old_checker_p> points to the storage location where a
pointer to the next function in the chain will be stored.  The value of
I<new_pointer> is written into the L</PL_check> array, while the value
previously stored there is written to I<*old_checker_p>.

L</PL_check> is global to an entire process, and a module wishing to
hook op checking may find itself invoked more than once per process,
typically in different threads.  To handle that situation, this function
is idempotent.  The location I<*old_checker_p> must initially (once
per process) contain a null pointer.  A C variable of static duration
(declared at file scope, typically also marked C<static> to give
it internal linkage) will be implicitly initialised appropriately,
if it does not have an explicit initialiser.  This function will only
actually modify the check chain if it finds I<*old_checker_p> to be null.
This function is also thread safe on the small scale.  It uses appropriate
locking to avoid race conditions in accessing L</PL_check>.

When this function is called, the function referenced by I<new_checker>
must be ready to be called, except for I<*old_checker_p> being unfilled.
In a threading situation, I<new_checker> may be called immediately,
even before this function has returned.  I<*old_checker_p> will always
be appropriately set before I<new_checker> is called.  If I<new_checker>
decides not to do anything special with an op that it is given (which
is the usual case for most uses of op check hooking), it must chain the
check function referenced by I<*old_checker_p>.

If you want to influence compilation of calls to a specific subroutine,
then use L</cv_set_call_checker> rather than hooking checking of all
C<entersub> ops.
d9147 1
a9147 17
=cut
*/

void
Perl_wrap_op_checker(pTHX_ Optype opcode,
    Perl_check_t new_checker, Perl_check_t *old_checker_p)
{
    dVAR;

    PERL_ARGS_ASSERT_WRAP_OP_CHECKER;
    if (*old_checker_p) return;
    OP_CHECK_MUTEX_LOCK;
    if (!*old_checker_p) {
	*old_checker_p = PL_check[opcode];
	PL_check[opcode] = new_checker;
    }
    OP_CHECK_MUTEX_UNLOCK;
@


1.1.1.15
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a105 1
#include "regcomp.h"
d111 1
a111 1
/* See the explanatory comments above struct opslab in op.h. */
d114 1
a114 2
#  define PERL_SLAB_SIZE 128
#  define PERL_MAX_SLAB_SIZE 4096
d119 1
a119 1
#  define PERL_SLAB_SIZE 64
a120 34
#ifndef PERL_MAX_SLAB_SIZE
#  define PERL_MAX_SLAB_SIZE 2048
#endif

/* rounds up to nearest pointer */
#define SIZE_TO_PSIZE(x)	(((x) + sizeof(I32 *) - 1)/sizeof(I32 *))
#define DIFF(o,p)		((size_t)((I32 **)(p) - (I32**)(o)))

static OPSLAB *
S_new_slab(pTHX_ size_t sz)
{
#ifdef PERL_DEBUG_READONLY_OPS
    OPSLAB *slab = (OPSLAB *) mmap(0, sz * sizeof(I32 *),
				   PROT_READ|PROT_WRITE,
				   MAP_ANON|MAP_PRIVATE, -1, 0);
    DEBUG_m(PerlIO_printf(Perl_debug_log, "mapped %lu at %p\n",
			  (unsigned long) sz, slab));
    if (slab == MAP_FAILED) {
	perror("mmap failed");
	abort();
    }
    slab->opslab_size = (U16)sz;
#else
    OPSLAB *slab = (OPSLAB *)PerlMemShared_calloc(sz, sizeof(I32 *));
#endif
    slab->opslab_first = (OPSLOT *)((I32 **)slab + sz - 1);
    return slab;
}

/* requires double parens and aTHX_ */
#define DEBUG_S_warn(args)					       \
    DEBUG_S( 								\
	PerlIO_printf(Perl_debug_log, "%s", SvPVx_nolen(Perl_mess args)) \
    )
d126 39
a164 5
    OPSLAB *slab;
    OPSLAB *slab2;
    OPSLOT *slot;
    OP *o;
    size_t opsz, space;
d166 17
a182 88
    if (!PL_compcv || CvROOT(PL_compcv)
     || (CvSTART(PL_compcv) && !CvSLABBED(PL_compcv)))
	return PerlMemShared_calloc(1, sz);

#if defined(USE_ITHREADS) && IVSIZE > U32SIZE && IVSIZE > PTRSIZE
    /* Work around a goof with alignment on our part. For sparc32 (and
       possibly other architectures), if built with -Duse64bitint, the IV
       op_pmoffset in struct pmop should be 8 byte aligned, but the slab
       allocator is only providing 4 byte alignment. The real fix is to change
       the IV to a type the same size as a pointer, such as size_t, but we
       can't do that without breaking the ABI, which is a no-no in a maint
       release. So instead, simply allocate struct pmop directly, which will be
       suitably aligned:  */
    if (sz == sizeof(struct pmop))
	return PerlMemShared_calloc(1, sz);
#endif

    if (!CvSTART(PL_compcv)) { /* sneak it in here */
	CvSTART(PL_compcv) =
	    (OP *)(slab = S_new_slab(aTHX_ PERL_SLAB_SIZE));
	CvSLABBED_on(PL_compcv);
	slab->opslab_refcnt = 2; /* one for the CV; one for the new OP */
    }
    else ++(slab = (OPSLAB *)CvSTART(PL_compcv))->opslab_refcnt;

    opsz = SIZE_TO_PSIZE(sz);
    sz = opsz + OPSLOT_HEADER_P;

    if (slab->opslab_freed) {
	OP **too = &slab->opslab_freed;
	o = *too;
	DEBUG_S_warn((aTHX_ "found free op at %p, slab %p", o, slab));
	while (o && DIFF(OpSLOT(o), OpSLOT(o)->opslot_next) < sz) {
	    DEBUG_S_warn((aTHX_ "Alas! too small"));
	    o = *(too = &o->op_next);
	    if (o) { DEBUG_S_warn((aTHX_ "found another free op at %p", o)); }
	}
	if (o) {
	    *too = o->op_next;
	    Zero(o, opsz, I32 *);
	    o->op_slabbed = 1;
	    return (void *)o;
	}
    }

#define INIT_OPSLOT \
	    slot->opslot_slab = slab;			\
	    slot->opslot_next = slab2->opslab_first;	\
	    slab2->opslab_first = slot;			\
	    o = &slot->opslot_op;			\
	    o->op_slabbed = 1

    /* The partially-filled slab is next in the chain. */
    slab2 = slab->opslab_next ? slab->opslab_next : slab;
    if ((space = DIFF(&slab2->opslab_slots, slab2->opslab_first)) < sz) {
	/* Remaining space is too small. */

	/* If we can fit a BASEOP, add it to the free chain, so as not
	   to waste it. */
	if (space >= SIZE_TO_PSIZE(sizeof(OP)) + OPSLOT_HEADER_P) {
	    slot = &slab2->opslab_slots;
	    INIT_OPSLOT;
	    o->op_type = OP_FREED;
	    o->op_next = slab->opslab_freed;
	    slab->opslab_freed = o;
	}

	/* Create a new slab.  Make this one twice as big. */
	slot = slab2->opslab_first;
	while (slot->opslot_next) slot = slot->opslot_next;
	slab2 = S_new_slab(aTHX_
			    (DIFF(slab2, slot)+1)*2 > PERL_MAX_SLAB_SIZE
					? PERL_MAX_SLAB_SIZE
					: (DIFF(slab2, slot)+1)*2);
	slab2->opslab_next = slab->opslab_next;
	slab->opslab_next = slab2;
    }
    assert(DIFF(&slab2->opslab_slots, slab2->opslab_first) >= sz);

    /* Create a new op slot */
    slot = (OPSLOT *)((I32 **)slab2->opslab_first - sz);
    assert(slot >= &slab2->opslab_slots);
    if (DIFF(&slab2->opslab_slots, slot)
	 < SIZE_TO_PSIZE(sizeof(OP)) + OPSLOT_HEADER_P)
	slot = &slab2->opslab_slots;
    INIT_OPSLOT;
    DEBUG_S_warn((aTHX_ "allocating op at %p, slab %p", o, slab));
    return (void *)o;
a184 2
#undef INIT_OPSLOT

d187 4
a190 3
Perl_Slab_to_ro(pTHX_ OPSLAB *slab)
{
    PERL_ARGS_ASSERT_SLAB_TO_RO;
d192 3
a194 10
    if (slab->opslab_readonly) return;
    slab->opslab_readonly = 1;
    for (; slab; slab = slab->opslab_next) {
	/*DEBUG_U(PerlIO_printf(Perl_debug_log,"mprotect ->ro %lu at %p\n",
			      (unsigned long) slab->opslab_size, slab));*/
	if (mprotect(slab, slab->opslab_size * sizeof(I32 *), PROT_READ))
	    Perl_warn(aTHX_ "mprotect for %p %lu failed with %d", slab,
			     (unsigned long)slab->opslab_size, errno);
    }
}
d196 2
a197 4
void
Perl_Slab_to_rw(pTHX_ OPSLAB *const slab)
{
    OPSLAB *slab2;
d199 2
a200 1
    PERL_ARGS_ASSERT_SLAB_TO_RW;
d202 6
a207 9
    if (!slab->opslab_readonly) return;
    slab2 = slab;
    for (; slab2; slab2 = slab2->opslab_next) {
	/*DEBUG_U(PerlIO_printf(Perl_debug_log,"mprotect ->rw %lu at %p\n",
			      (unsigned long) size, slab2));*/
	if (mprotect((void *)slab2, slab2->opslab_size * sizeof(I32 *),
		     PROT_READ|PROT_WRITE)) {
	    Perl_warn(aTHX_ "mprotect RW for %p %lu failed with %d", slab,
			     (unsigned long)slab2->opslab_size, errno);
a209 28
    slab->opslab_readonly = 0;
}

#else
#  define Slab_to_rw(op)
#endif

/* This cannot possibly be right, but it was copied from the old slab
   allocator, to which it was originally added, without explanation, in
   commit 083fcd5. */
#ifdef NETWARE
#    define PerlMemShared PerlMem
#endif

void
Perl_Slab_Free(pTHX_ void *op)
{
    dVAR;
    OP * const o = (OP *)op;
    OPSLAB *slab;

    PERL_ARGS_ASSERT_SLAB_FREE;

    if (!o->op_slabbed) {
        if (!o->op_static)
	    PerlMemShared_free(op);
	return;
    }
d211 1
a211 8
    slab = OpSLAB(o);
    /* If this op is already freed, our refcount will get screwy. */
    assert(o->op_type != OP_FREED);
    o->op_type = OP_FREED;
    o->op_next = slab->opslab_freed;
    slab->opslab_freed = o;
    DEBUG_S_warn((aTHX_ "free op at %p, recorded in slab %p", o, slab));
    OpslabREFCNT_dec_padok(slab);
d214 2
a215 2
void
Perl_opslab_free_nopad(pTHX_ OPSLAB *slab)
d217 2
a218 10
    dVAR;
    const bool havepad = !!PL_comppad;
    PERL_ARGS_ASSERT_OPSLAB_FREE_NOPAD;
    if (havepad) {
	ENTER;
	PAD_SAVE_SETNULLPAD();
    }
    opslab_free(slab);
    if (havepad) LEAVE;
}
d220 1
a220 25
void
Perl_opslab_free(pTHX_ OPSLAB *slab)
{
    dVAR;
    OPSLAB *slab2;
    PERL_ARGS_ASSERT_OPSLAB_FREE;
    DEBUG_S_warn((aTHX_ "freeing slab %p", slab));
    assert(slab->opslab_refcnt == 1);
    for (; slab; slab = slab2) {
	slab2 = slab->opslab_next;
#ifdef DEBUGGING
	slab->opslab_refcnt = ~(size_t)0;
#endif
#ifdef PERL_DEBUG_READONLY_OPS
	DEBUG_m(PerlIO_printf(Perl_debug_log, "Deallocate slab at %p\n",
					       slab));
	if (munmap(slab, slab->opslab_size * sizeof(I32 *))) {
	    perror("munmap failed");
	    abort();
	}
#else
	PerlMemShared_free(slab);
#endif
    }
}
d222 6
a227 35
void
Perl_opslab_force_free(pTHX_ OPSLAB *slab)
{
    OPSLAB *slab2;
    OPSLOT *slot;
#ifdef DEBUGGING
    size_t savestack_count = 0;
#endif
    PERL_ARGS_ASSERT_OPSLAB_FORCE_FREE;
    slab2 = slab;
    do {
	for (slot = slab2->opslab_first;
	     slot->opslot_next;
	     slot = slot->opslot_next) {
	    if (slot->opslot_op.op_type != OP_FREED
	     && !(slot->opslot_op.op_savefree
#ifdef DEBUGGING
		  && ++savestack_count
#endif
		 )
	    ) {
		assert(slot->opslot_op.op_slabbed);
		op_free(&slot->opslot_op);
		if (slab->opslab_refcnt == 1) goto free;
	    }
	}
    } while ((slab2 = slab2->opslab_next));
    /* > 1 because the CV still holds a reference count. */
    if (slab->opslab_refcnt > 1) { /* still referenced by the savestack */
#ifdef DEBUGGING
	assert(savestack_count == slab->opslab_refcnt-1);
#endif
	/* Remove the CV’s reference count. */
	slab->opslab_refcnt--;
	return;
a228 2
   free:
    opslab_free(slab);
a230 1
#ifdef PERL_DEBUG_READONLY_OPS
d235 2
a236 8
        OPSLAB *const slab = o->op_slabbed ? OpSLAB(o) : NULL;
        if (slab && slab->opslab_readonly) {
            Slab_to_rw(slab);
            ++o->op_targ;
            Slab_to_ro(slab);
        } else {
            ++o->op_targ;
        }
a244 3
    PADOFFSET result;
    OPSLAB *const slab = o->op_slabbed ? OpSLAB(o) : NULL;

d246 6
d253 45
a297 6
    if (slab && slab->opslab_readonly) {
        Slab_to_rw(slab);
        result = --o->op_targ;
        Slab_to_ro(slab);
    } else {
        result = --o->op_targ;
a298 1
    return result;
a444 7
    else if (len == 2 && name[1] == '_' && !is_our)
	/* diag_listed_as: Use of my $_ is experimental */
	Perl_ck_warner_d(aTHX_ packWARN(WARN_EXPERIMENTAL__LEXICAL_TOPIC),
			      "Use of %s $_ is experimental",
			       PL_parser->in_my == KEY_state
				 ? "state"
				 : "my");
a467 37
/*
=for apidoc alloccopstash

Available only under threaded builds, this function allocates an entry in
C<PL_stashpad> for the stash passed to it.

=cut
*/

#ifdef USE_ITHREADS
PADOFFSET
Perl_alloccopstash(pTHX_ HV *hv)
{
    PADOFFSET off = 0, o = 1;
    bool found_slot = FALSE;

    PERL_ARGS_ASSERT_ALLOCCOPSTASH;

    if (PL_stashpad[PL_stashpadix] == hv) return PL_stashpadix;

    for (; o < PL_stashpadmax; ++o) {
	if (PL_stashpad[o] == hv) return PL_stashpadix = o;
	if (!PL_stashpad[o] || SvTYPE(PL_stashpad[o]) != SVt_PVHV)
	    found_slot = TRUE, off = o;
    }
    if (!found_slot) {
	Renew(PL_stashpad, PL_stashpadmax + 10, HV *);
	Zero(PL_stashpad + PL_stashpadmax, 10, HV *);
	off = PL_stashpadmax;
	PL_stashpadmax += 10;
    }

    PL_stashpad[PL_stashpadix = off] = hv;
    return off;
}
#endif

d474 4
d481 6
d495 1
a495 6
    /* Though ops may be freed twice, freeing the op after its slab is a
       big no-no. */
    assert(!o || !o->op_slabbed || OpSLAB(o)->opslab_refcnt != ~(size_t)0); 
    /* During the forced freeing of ops after compilation failure, kidops
       may be freed before their parents. */
    if (!o || o->op_type == OP_FREED)
d497 5
d536 1
a536 1
        OP *kid, *nextkid;
a541 2
    if (type == OP_NULL)
	type = (OPCODE)o->op_targ;
d543 3
a545 3
    if (o->op_slabbed) {
	Slab_to_rw(OpSLAB(o));
    }
d549 4
a552 1
    if (type == OP_NEXTSTATE || type == OP_DBSTATE) {
d556 3
d560 5
d642 1
a642 1
		SvREFCNT_dec_NN(gv);
a665 1
    case OP_DUMP:
a675 1
	    assert(o->op_type == OP_TRANS || o->op_type == OP_TRANSR);
d708 1
a708 4
	if (!(cPMOPo->op_pmflags & PMf_CODELIST_PRIVATE))
	    op_free(cPMOPo->op_code_list);
	cPMOPo->op_code_list = NULL;
	forget_pmop(cPMOPo);
d744 1
d752 3
d787 4
d806 1
a806 1
		forget_pmop((PMOP*)kid);
d897 1
a897 1
        OP *kid;
d939 1
a939 3
	    if (PL_parser && PL_parser->copline != NOLINE) {
		/* This ensures that warnings are reported at the first line
                   of the conditional, not the last.  */
a940 1
            }
a1018 1
    SV *useless_sv = NULL;
d1020 1
d1221 7
a1227 9
			useless_sv
                            = Perl_newSVpvf(aTHX_
                                            "a constant (%s)",
                                            pv_pretty(dsv, maybe_macro,
                                                      SvCUR(sv), 32, NULL, NULL,
                                                      PERL_PV_PRETTY_DUMP
                                                      | PERL_PV_ESCAPE_NOCLEAR
                                                      | PERL_PV_ESCAPE_UNI_DETECT));
			SvREFCNT_dec_NN(dsv);
d1231 3
a1233 1
		    useless_sv = Perl_newSVpvf(aTHX_ "a constant (%"SVf")", sv);
d1360 4
a1363 12

    if (useless_sv) {
        /* mortalise it, in case warnings are fatal.  */
        Perl_ck_warner(aTHX_ packWARN(WARN_VOID),
                       "Useless use of %"SVf" in void context",
                       sv_2mortal(useless_sv));
    }
    else if (useless) {
       Perl_ck_warner(aTHX_ packWARN(WARN_VOID),
                      "Useless use of %s in void context",
                      useless);
    }
d1590 1
a1590 1
		if (!SvIsCOW(PAD_SVl(ix))) SvREADONLY_on(PAD_SVl(ix));
d1610 1
a1610 1
		if (!SvIsCOW(PAD_SVl(ix))) SvREADONLY_on(PAD_SVl(ix));
d1631 1
a1631 1
	if ((!SvIsCOW(sv = *svp))
d1637 1
a1637 1
	    SvREFCNT_dec_NN(sv);
a1719 1

d1778 1
d1905 2
a1909 3
	if (type == OP_LEAVESUBLV)
	    o->op_private |= OPpMAYBE_LVSUB;
	/* FALL THROUGH */
a2025 3

    case OP_COREARGS:
	return o;
d2063 2
a2065 1
    case OP_POS:
d2067 1
a2067 1
	if (o && o->op_type == OP_RV2GV)
d2215 1
a2215 1
	if (!(o->op_flags & OPf_KIDS) || type == OP_DEFINED)
d2279 1
a2279 1
S_apply_attrs(pTHX_ HV *stash, SV *target, OP *attrs)
d2282 1
a2282 1
    SV * const stashsv = stash ? newSVhek(HvNAME_HEK(stash)) : &PL_sv_no;
d2288 1
d2293 11
a2303 1
    Perl_load_module(aTHX_ PERL_LOADMOD_IMPORT_OPS,
d2312 1
d2321 1
a2321 1
    SV *meth, *stashsv, **svp;
d2333 1
a2333 9
    ENTER;		/* need to protect against side-effects of 'use' */
    /* Don't force the C<use> if we don't need it. */
    svp = hv_fetchs(GvHVn(PL_incgv), ATTRSMODULE_PM, FALSE);
    if (svp && *svp != &PL_sv_undef)
	NOOP;	/* already in %INC */
    else
	Perl_load_module(aTHX_ PERL_LOADMOD_NOIMPORT,
			       newSVpvs(ATTRSMODULE), NULL);
    LEAVE;
d2434 5
a2438 1
    } else if (type == OP_UNDEF || type == OP_STUB) {
d2457 1
a2457 1
			attrs);
d2636 1
a2636 1
		pmruntime(newPMOP(OP_MATCH, 0), right, 0, 0));
d2666 1
a2666 1
	if (o->op_flags & OPf_PARENS || PERLDB_NOOPT || TAINTING_get) {
a2691 12
OP *
Perl_op_unscope(pTHX_ OP *o)
{
    if (o && o->op_type == OP_LINESEQ) {
	OP *kid = cLISTOPo->op_first;
	for(; kid; kid = kid->op_sibling)
	    if (kid->op_type == OP_NEXTSTATE || kid->op_type == OP_DBSTATE)
		op_null(kid);
    }
    return o;
}

a2714 1
    OP *o;
d2722 1
a2722 60
    o = pad_leavemy();

    if (o) {
	/* pad_leavemy has created a sequence of introcv ops for all my
	   subs declared in the block.  We have to replicate that list with
	   clonecv ops, to deal with this situation:

	       sub {
		   my sub s1;
		   my sub s2;
		   sub s1 { state sub foo { \&s2 } }
	       }->()

	   Originally, I was going to have introcv clone the CV and turn
	   off the stale flag.  Since &s1 is declared before &s2, the
	   introcv op for &s1 is executed (on sub entry) before the one for
	   &s2.  But the &foo sub inside &s1 (which is cloned when &s1 is
	   cloned, since it is a state sub) closes over &s2 and expects
	   to see it in its outer CV’s pad.  If the introcv op clones &s1,
	   then &s2 is still marked stale.  Since &s1 is not active, and
	   &foo closes over &s1’s implicit entry for &s2, we get a ‘Varia-
	   ble will not stay shared’ warning.  Because it is the same stub
	   that will be used when the introcv op for &s2 is executed, clos-
	   ing over it is safe.  Hence, we have to turn off the stale flag
	   on all lexical subs in the block before we clone any of them.
	   Hence, having introcv clone the sub cannot work.  So we create a
	   list of ops like this:

	       lineseq
		  |
		  +-- introcv
		  |
		  +-- introcv
		  |
		  +-- introcv
		  |
		  .
		  .
		  .
		  |
		  +-- clonecv
		  |
		  +-- clonecv
		  |
		  +-- clonecv
		  |
		  .
		  .
		  .
	 */
	OP *kid = o->op_flags & OPf_KIDS ? cLISTOPo->op_first : o;
	OP * const last = o->op_flags & OPf_KIDS ? cLISTOPo->op_last : o;
	for (;; kid = kid->op_sibling) {
	    OP *newkid = newOP(OP_CLONECV, 0);
	    newkid->op_targ = kid->op_targ;
	    o = op_append_elem(OP_LINESEQ, o, newkid);
	    if (kid == last) break;
	}
	retval = op_prepend_elem(OP_LINESEQ, o, retval);
    }
d2789 3
a2805 26
            /* This block is entered if nothing is compiled for the main
               program. This will be the case for an genuinely empty main
               program, or one which only has BEGIN blocks etc, so already
               run and freed.

               Historically (5.000) the guard above was !o. However, commit
               f8a08f7b8bd67b28 (Jun 2001), integrated to blead as
               c71fccf11fde0068, changed perly.y so that newPROG() is now
               called with the output of block_end(), which returns a new
               OP_STUB for the case of an empty optree. ByteLoader (and
               maybe other things) also take this path, because they set up
               PL_main_start and PL_main_root directly, without generating an
               optree.

               If the parsing the main program aborts (due to parse errors,
               or due to BEGIN or similar calling exit), then newPROG()
               isn't even called, and hence this code path and its cleanups
               are skipped. This shouldn't make a make a difference:
               * a non-zero return from perl_parse is a failure, and
                 perl_destruct() should be called immediately.
               * however, if exit(0) is called during the parse, then
                 perl_parse() returns 0, and perl_run() is called. As
                 PL_main_start will be NULL, perl_run() will return
                 promptly, and the exit code will remain 0.
            */

a2818 1
	cv_forget_slab(PL_compcv);
d2864 1
a2864 1
		       && (isWORDCHAR(*s) || UTF8_IS_CONTINUED(*s))) {
d2867 1
a2867 1
		    while (*s && (isWORDCHAR(*s) || UTF8_IS_CONTINUED(*s)))
d2932 5
a2936 2
    /* integerize op. */
    if ((PL_opargs[type] & OA_OTHERINT) && (PL_hints & HINT_INTEGER))
d2939 1
a2939 1
	o->op_ppaddr = PL_ppaddr[++(o->op_type)];
d2950 1
a2950 1
S_fold_constants(pTHX_ OP *o)
d2953 1
a2953 1
    OP * VOL curop;
a2984 18
    case OP_PACK:
	if (!cLISTOPo->op_first->op_sibling
	  || cLISTOPo->op_first->op_sibling->op_type != OP_CONST)
	    goto nope;
	{
	    SV * const sv = cSVOPx_sv(cLISTOPo->op_first->op_sibling);
	    if (!SvPOK(sv) || SvGMAGICAL(sv)) goto nope;
	    {
		const char *s = SvPVX_const(sv);
		while (s < SvEND(sv)) {
		    if (*s == 'p' || *s == 'P') goto nope;
		    s++;
		}
	    }
	}
	break;
    case OP_REPEAT:
	if (o->op_private & OPpREPEAT_DOLIST) goto nope;
d3073 1
a3073 1
	newop = newSVOP(OP_CONST, OPpCONST_FOLDED<<8, MUTABLE_SV(sv));
d3082 1
a3082 1
S_gen_constant_list(pTHX_ OP *o)
d3085 1
a3085 1
    OP *curop;
d3521 1
a3521 1
	Safefree(mp->mad_val);
d3644 3
d3790 2
a3791 2
    I32 i;
    I32 j;
d3793 1
a3793 1
    short *tbl;
a4203 4
 *
 * When the pattern has been compiled within a new anon CV (for
 * qr/(?{...})/ ), then floor indicates the savestack level just before
 * the new sub was created
d4207 1
a4207 1
Perl_pmruntime(pTHX_ OP *o, OP *expr, bool isreg, I32 floor)
d4214 1
a4214 3
    bool is_trans = (o->op_type == OP_TRANS || o->op_type == OP_TRANSR);
    bool is_compiletime;
    bool has_code;
d4218 5
a4222 3
    /* for s/// and tr///, last element in list is the replacement; pop it */

    if (is_trans || o->op_type == OP_SUBST) {
d4232 4
a4235 3
    /* for TRANS, convert LIST/PUSH/CONST into CONST, and pass to pmtrans() */

    if (is_trans) {
d4237 1
a4237 4
	assert(expr->op_type == OP_LIST);
	assert(cLISTOPx(expr)->op_first->op_type == OP_PUSHMARK);
	assert(cLISTOPx(expr)->op_first->op_sibling == cLISTOPx(expr)->op_last);
	expr = cLISTOPx(oe)->op_last;
d4241 1
d4243 1
d4247 3
a4249 79
    /* find whether we have any runtime or code elements;
     * at the same time, temporarily set the op_next of each DO block;
     * then when we LINKLIST, this will cause the DO blocks to be excluded
     * from the op_next chain (and from having LINKLIST recursively
     * applied to them). We fix up the DOs specially later */

    is_compiletime = 1;
    has_code = 0;
    if (expr->op_type == OP_LIST) {
	OP *o;
	for (o = cLISTOPx(expr)->op_first; o; o = o->op_sibling) {
	    if (o->op_type == OP_NULL && (o->op_flags & OPf_SPECIAL)) {
		has_code = 1;
		assert(!o->op_next && o->op_sibling);
		o->op_next = o->op_sibling;
	    }
	    else if (o->op_type != OP_CONST && o->op_type != OP_PUSHMARK)
		is_compiletime = 0;
	}
    }
    else if (expr->op_type != OP_CONST)
	is_compiletime = 0;

    LINKLIST(expr);

    /* fix up DO blocks; treat each one as a separate little sub;
     * also, mark any arrays as LIST/REF */

    if (expr->op_type == OP_LIST) {
	OP *o;
	for (o = cLISTOPx(expr)->op_first; o; o = o->op_sibling) {

            if (o->op_type == OP_PADAV || o->op_type == OP_RV2AV) {
                assert( !(o->op_flags  & OPf_WANT));
                /* push the array rather than its contents. The regex
                 * engine will retrieve and join the elements later */
                o->op_flags |= (OPf_WANT_LIST | OPf_REF);
                continue;
            }

	    if (!(o->op_type == OP_NULL && (o->op_flags & OPf_SPECIAL)))
		continue;
	    o->op_next = NULL; /* undo temporary hack from above */
	    scalar(o);
	    LINKLIST(o);
	    if (cLISTOPo->op_first->op_type == OP_LEAVE) {
		LISTOP *leaveop = cLISTOPx(cLISTOPo->op_first);
		/* skip ENTER */
		assert(leaveop->op_first->op_type == OP_ENTER);
		assert(leaveop->op_first->op_sibling);
		o->op_next = leaveop->op_first->op_sibling;
		/* skip leave */
		assert(leaveop->op_flags & OPf_KIDS);
		assert(leaveop->op_last->op_next == (OP*)leaveop);
		leaveop->op_next = NULL; /* stop on last op */
		op_null((OP*)leaveop);
	    }
	    else {
		/* skip SCOPE */
		OP *scope = cLISTOPo->op_first;
		assert(scope->op_type == OP_SCOPE);
		assert(scope->op_flags & OPf_KIDS);
		scope->op_next = NULL; /* stop on last op */
		op_null(scope);
	    }
	    /* have to peep the DOs individually as we've removed it from
	     * the op_next chain */
	    CALL_PEEP(o);
	    if (is_compiletime)
		/* runtime finalizes as part of finalizing whole tree */
		finalize_optree(o);
	}
    }
    else if (expr->op_type == OP_PADAV || expr->op_type == OP_RV2AV) {
        assert( !(expr->op_flags  & OPf_WANT));
        /* push the array rather than its contents. The regex
         * engine will retrieve and join the elements later */
        expr->op_flags |= (OPf_WANT_LIST | OPf_REF);
    }
a4252 1
    assert(floor==0 || (pm->op_pmflags & PMf_HAS_CV));
d4254 21
a4274 30
    if (is_compiletime) {
	U32 rx_flags = pm->op_pmflags & RXf_PMf_COMPILETIME;
	regexp_engine const *eng = current_re_engine();

        if (o->op_flags & OPf_SPECIAL)
            rx_flags |= RXf_SPLIT;

	if (!has_code || !eng->op_comp) {
	    /* compile-time simple constant pattern */

	    if ((pm->op_pmflags & PMf_HAS_CV) && !has_code) {
		/* whoops! we guessed that a qr// had a code block, but we
		 * were wrong (e.g. /[(?{}]/ ). Throw away the PL_compcv
		 * that isn't required now. Note that we have to be pretty
		 * confident that nothing used that CV's pad while the
		 * regex was parsed */
		assert(AvFILLp(PL_comppad) == 0); /* just @@_ */
		/* But we know that one op is using this CV's slab. */
		cv_forget_slab(PL_compcv);
		LEAVE_SCOPE(floor);
		pm->op_pmflags &= ~PMf_HAS_CV;
	    }

	    PM_SETRE(pm,
		eng->op_comp
		    ? eng->op_comp(aTHX_ NULL, 0, expr, eng, NULL, NULL,
					rx_flags, pm->op_pmflags)
		    : Perl_re_op_compile(aTHX_ NULL, 0, expr, eng, NULL, NULL,
					rx_flags, pm->op_pmflags)
	    );
d4276 1
a4276 1
	    op_getmad(expr,(OP*)pm,'e');
d4278 1
a4278 1
	    op_free(expr);
a4279 32
	}
	else {
	    /* compile-time pattern that includes literal code blocks */
	    REGEXP* re = eng->op_comp(aTHX_ NULL, 0, expr, eng, NULL, NULL,
			rx_flags,
			(pm->op_pmflags |
			    ((PL_hints & HINT_RE_EVAL) ? PMf_USE_RE_EVAL : 0))
		    );
	    PM_SETRE(pm, re);
	    if (pm->op_pmflags & PMf_HAS_CV) {
		CV *cv;
		/* this QR op (and the anon sub we embed it in) is never
		 * actually executed. It's just a placeholder where we can
		 * squirrel away expr in op_code_list without the peephole
		 * optimiser etc processing it for a second time */
		OP *qr = newPMOP(OP_QR, 0);
		((PMOP*)qr)->op_code_list = expr;

		/* handle the implicit sub{} wrapped round the qr/(?{..})/ */
		SvREFCNT_inc_simple_void(PL_compcv);
		cv = newATTRSUB(floor, 0, NULL, NULL, qr);
		ReANY(re)->qr_anoncv = cv;

		/* attach the anon CV to the pad so that
		 * pad_fixup_inner_anons() can find it */
		(void)pad_add_anon(cv, o->op_type);
		SvREFCNT_inc_simple_void(cv);
	    }
	    else {
		pm->op_code_list = expr;
	    }
	}
d4282 4
a4285 69
	/* runtime pattern: build chain of regcomp etc ops */
	bool reglist;
	PADOFFSET cv_targ = 0;

	reglist = isreg && expr->op_type == OP_LIST;
	if (reglist)
	    op_null(expr);

	if (has_code) {
	    pm->op_code_list = expr;
	    /* don't free op_code_list; its ops are embedded elsewhere too */
	    pm->op_pmflags |= PMf_CODELIST_PRIVATE;
	}

        if (o->op_flags & OPf_SPECIAL)
            pm->op_pmflags |= PMf_SPLIT;

	/* the OP_REGCMAYBE is a placeholder in the non-threaded case
	 * to allow its op_next to be pointed past the regcomp and
	 * preceding stacking ops;
	 * OP_REGCRESET is there to reset taint before executing the
	 * stacking ops */
	if (pm->op_pmflags & PMf_KEEP || TAINTING_get)
	    expr = newUNOP((TAINTING_get ? OP_REGCRESET : OP_REGCMAYBE),0,expr);

	if (pm->op_pmflags & PMf_HAS_CV) {
	    /* we have a runtime qr with literal code. This means
	     * that the qr// has been wrapped in a new CV, which
	     * means that runtime consts, vars etc will have been compiled
	     * against a new pad. So... we need to execute those ops
	     * within the environment of the new CV. So wrap them in a call
	     * to a new anon sub. i.e. for
	     *
	     *     qr/a$b(?{...})/,
	     *
	     * we build an anon sub that looks like
	     *
	     *     sub { "a", $b, '(?{...})' }
	     *
	     * and call it, passing the returned list to regcomp.
	     * Or to put it another way, the list of ops that get executed
	     * are:
	     *
	     *     normal              PMf_HAS_CV
	     *     ------              -------------------
	     *                         pushmark (for regcomp)
	     *                         pushmark (for entersub)
	     *                         pushmark (for refgen)
	     *                         anoncode
	     *                         refgen
	     *                         entersub
	     *     regcreset                  regcreset
	     *     pushmark                   pushmark
	     *     const("a")                 const("a")
	     *     gvsv(b)                    gvsv(b)
	     *     const("(?{...})")          const("(?{...})")
	     *                                leavesub
	     *     regcomp             regcomp
	     */

	    SvREFCNT_inc_simple_void(PL_compcv);
	    /* these lines are just an unrolled newANONATTRSUB */
	    expr = newSVOP(OP_ANONCODE, 0,
		    MUTABLE_SV(newATTRSUB(floor, 0, NULL, NULL, expr)));
	    cv_targ = expr->op_targ;
	    expr = newUNOP(OP_REFGEN, 0, expr);

	    expr = list(force_list(newUNOP(OP_ENTERSUB, 0, scalar(expr))));
	}
d4294 1
a4294 1
	rcop->op_private = 0;
d4296 2
a4297 1
	rcop->op_targ = cv_targ;
d4303 1
a4303 1
	if (expr->op_type == OP_REGCRESET || expr->op_type == OP_REGCMAYBE) {
d4317 1
a4317 2
	OP *curop = repl;
	bool konst;
d4319 1
d4323 37
a4359 24
	/* If we are looking at s//.../e with a single statement, get past
	   the implicit do{}. */
	if (curop->op_type == OP_NULL && curop->op_flags & OPf_KIDS
	 && cUNOPx(curop)->op_first->op_type == OP_SCOPE
	 && cUNOPx(curop)->op_first->op_flags & OPf_KIDS) {
	    OP *kid = cUNOPx(cUNOPx(curop)->op_first)->op_first;
	    if (kid->op_type == OP_NULL && kid->op_sibling
	     && !kid->op_sibling->op_sibling)
		curop = kid->op_sibling;
	}
	if (curop->op_type == OP_CONST)
	    konst = TRUE;
	else if (( (curop->op_type == OP_RV2SV ||
		    curop->op_type == OP_RV2AV ||
		    curop->op_type == OP_RV2HV ||
		    curop->op_type == OP_RV2GV)
		   && cUNOPx(curop)->op_first
		   && cUNOPx(curop)->op_first->op_type == OP_GV )
		|| curop->op_type == OP_PADSV
		|| curop->op_type == OP_PADAV
		|| curop->op_type == OP_PADHV
		|| curop->op_type == OP_PADANY) {
	    repl_has_vars = 1;
	    konst = TRUE;
d4361 1
a4361 2
	else konst = FALSE;
	if (konst
a4363 1
		     || !RX_PRELEN(PM_GETRE(pm))
d4370 3
a4423 1
    svop->op_private = (U8)(0 | (flags >> 8));
d4608 1
a4608 1
    OP *pegop = PL_madskills ? newOP(OP_NULL,0) : NULL;
d4743 5
d4862 1
a4862 1
	doop = newUNOP(OP_ENTERSUB, OPf_STACKED,
d4865 1
a4865 1
							  newGVOP(OP_GV, 0, gv)))));
d4898 1
a4898 1
S_is_list_assignment(pTHX_ const OP *o)
d5169 1
d5231 1
a5231 1
    COP *cop;
d5269 2
a5270 1
	PL_parser->copline = NOLINE;
a5429 2
	    else if (other->op_type == OP_CONST)
		other->op_private |= OPpCONST_FOLDED;
a5493 2
            /* This ensures that warnings are reported at the first line
               of the construction, not the last.  */
a5586 2
	else if (live->op_type == OP_CONST)
	    live->op_private |= OPpCONST_FOLDED;
a5716 1
	    || expr->op_type == OP_EACH || expr->op_type == OP_AEACH
a5805 1
	 || expr->op_type == OP_EACH || expr->op_type == OP_AEACH
d5857 1
d5859 1
a5859 1
	    return expr;		/* listop already freed by new_logop */
d5986 1
a5986 1
	 * treated as min/max values by 'pp_enteriter'.
d6022 1
a6022 3
    if (loop->op_slabbed
     && DIFF(loop, OpSLOT(loop)->opslot_next)
	 < SIZE_TO_PSIZE(sizeof(LOOP)))
d6030 3
a6032 2
    else if (!loop->op_slabbed)
	loop = (LOOP*)PerlMemShared_realloc(loop, sizeof(LOOP));
d6046 1
a6046 1
becomes part of the constructed op tree.
d6055 1
a6055 1
    OP *o = NULL;
d6061 1
a6061 1
    if (type != OP_GOTO) {
d6063 1
a6063 1
	if (label->op_type == OP_STUB && (label->op_flags & OPf_PARENS)) {
d6065 8
d6074 5
d6085 1
d6087 3
d6091 2
a6092 28
    /* Check for a constant argument */
    if (label->op_type == OP_CONST) {
	    SV * const sv = ((SVOP *)label)->op_sv;
	    STRLEN l;
	    const char *s = SvPV_const(sv,l);
	    if (l == strlen(s)) {
		o = newPVOP(type,
			    SvUTF8(((SVOP*)label)->op_sv),
			    savesharedpv(
				SvPV_nolen_const(((SVOP*)label)->op_sv)));
	    }
    }
    
    /* If we have already created an op, we do not need the label. */
    if (o)
#ifdef PERL_MAD
		op_getmad(label,o,'L');
#else
		op_free(label);
#endif
    else o = newUNOP(type, OPf_STACKED, label);

    PL_hints |= HINT_BLOCK_SCOPE;
    return o;
}

/* if the condition is a literal array or hash
   (or @@{ ... } etc), make a reference to it.
d6265 1
a6265 1
be affected.  If it is 0, the global $_ will be used.
d6318 1
a6318 1
    const char * const cvp = SvROK(cv) ? "" : CvPROTO(cv);
a6339 2
	{
	  if (isGV(gv))
a6340 5
	  else if (SvPOK(gv) && *SvPVX((SV *)gv) == '&')
	    name = newSVpvn_flags(SvPVX((SV *)gv)+1, SvCUR(gv)-1,
				  SvUTF8(gv)|SVs_TEMP);
	  else name = (SV *)gv;
	}
d6344 1
a6344 1
	if (cvp)
d6403 1
a6403 2
 *	PADSV, ignore it if it has multiple references. In this case we
 *	return a newly created *copy* of the value.
a6467 48
static bool
S_already_defined(pTHX_ CV *const cv, OP * const block, OP * const o,
			PADNAME * const name, SV ** const const_svp)
{
    assert (cv);
    assert (o || name);
    assert (const_svp);
    if ((!block
#ifdef PERL_MAD
	 || block->op_type == OP_NULL
#endif
	 )) {
	if (CvFLAGS(PL_compcv)) {
	    /* might have had built-in attrs applied */
	    const bool pureperl = !CvISXSUB(cv) && CvROOT(cv);
	    if (CvLVALUE(PL_compcv) && ! CvLVALUE(cv) && pureperl
	     && ckWARN(WARN_MISC))
	    {
		/* protect against fatal warnings leaking compcv */
		SAVEFREESV(PL_compcv);
		Perl_warner(aTHX_ packWARN(WARN_MISC), "lvalue attribute ignored after the subroutine has been defined");
		SvREFCNT_inc_simple_void_NN(PL_compcv);
	    }
	    CvFLAGS(cv) |=
		(CvFLAGS(PL_compcv) & CVf_BUILTIN_ATTRS
		  & ~(CVf_LVALUE * pureperl));
	}
	return FALSE;
    }

    /* redundant check for speed: */
    if (CvCONST(cv) || ckWARN(WARN_REDEFINE)) {
	const line_t oldline = CopLINE(PL_curcop);
	SV *namesv = o
	    ? cSVOPo->op_sv
	    : sv_2mortal(newSVpvn_utf8(
		PadnamePV(name)+1,PadnameLEN(name)-1, PadnameUTF8(name)
	      ));
	if (PL_parser && PL_parser->copline != NOLINE)
            /* This ensures that warnings are reported at the first
               line of a redefinition, not the last.  */
	    CopLINE_set(PL_curcop, PL_parser->copline);
	/* protect against fatal warnings leaking compcv */
	SAVEFREESV(PL_compcv);
	report_redefined_cv(namesv, cv, const_svp);
	SvREFCNT_inc_simple_void_NN(PL_compcv);
	CopLINE_set(PL_curcop, oldline);
    }
d6469 3
a6471 1
    if (!PL_minus_c)	/* keep old one around for madskills */
a6472 8
    {
	/* (PL_madskills unset in used file.) */
	SvREFCNT_dec(cv);
    }
    return TRUE;
}

CV *
d6475 3
a6477 96
    dVAR;
    CV **spot;
    SV **svspot;
    const char *ps;
    STRLEN ps_len = 0; /* init it to avoid false uninit warning from icc */
    U32 ps_utf8 = 0;
    CV *cv = NULL;
    CV *compcv = PL_compcv;
    SV *const_sv;
    PADNAME *name;
    PADOFFSET pax = o->op_targ;
    CV *outcv = CvOUTSIDE(PL_compcv);
    CV *clonee = NULL;
    HEK *hek = NULL;
    bool reusable = FALSE;

    PERL_ARGS_ASSERT_NEWMYSUB;

    /* Find the pad slot for storing the new sub.
       We cannot use PL_comppad, as it is the pad owned by the new sub.  We
       need to look in CvOUTSIDE and find the pad belonging to the enclos-
       ing sub.  And then we need to dig deeper if this is a lexical from
       outside, as in:
	   my sub foo; sub { sub foo { } }
     */
   redo:
    name = PadlistNAMESARRAY(CvPADLIST(outcv))[pax];
    if (PadnameOUTER(name) && PARENT_PAD_INDEX(name)) {
	pax = PARENT_PAD_INDEX(name);
	outcv = CvOUTSIDE(outcv);
	assert(outcv);
	goto redo;
    }
    svspot =
	&PadARRAY(PadlistARRAY(CvPADLIST(outcv))
			[CvDEPTH(outcv) ? CvDEPTH(outcv) : 1])[pax];
    spot = (CV **)svspot;

    if (proto) {
	assert(proto->op_type == OP_CONST);
	ps = SvPV_const(((SVOP*)proto)->op_sv, ps_len);
        ps_utf8 = SvUTF8(((SVOP*)proto)->op_sv);
    }
    else
	ps = NULL;

    if (!PL_madskills) {
	if (proto)
	    SAVEFREEOP(proto);
	if (attrs)
	    SAVEFREEOP(attrs);
    }

    if (PL_parser && PL_parser->error_count) {
	op_free(block);
	SvREFCNT_dec(PL_compcv);
	PL_compcv = 0;
	goto done;
    }

    if (CvDEPTH(outcv) && CvCLONE(compcv)) {
	cv = *spot;
	svspot = (SV **)(spot = &clonee);
    }
    else if (PadnameIsSTATE(name) || CvDEPTH(outcv))
	cv = *spot;
    else {
	MAGIC *mg;
	SvUPGRADE(name, SVt_PVMG);
	mg = mg_find(name, PERL_MAGIC_proto);
	assert (SvTYPE(*spot) == SVt_PVCV);
	if (CvNAMED(*spot))
	    hek = CvNAME_HEK(*spot);
	else {
	    CvNAME_HEK_set(*spot, hek =
		share_hek(
		    PadnamePV(name)+1,
		    PadnameLEN(name)-1 * (PadnameUTF8(name) ? -1 : 1), 0
		)
	    );
	}
	if (mg) {
	    assert(mg->mg_obj);
	    cv = (CV *)mg->mg_obj;
	}
	else {
	    sv_magic(name, &PL_sv_undef, PERL_MAGIC_proto, NULL, 0);
	    mg = mg_find(name, PERL_MAGIC_proto);
	}
	spot = (CV **)(svspot = &mg->mg_obj);
    }

    if (!block || !ps || *ps || attrs
	|| (CvFLAGS(compcv) & CVf_BUILTIN_ATTRS)
#ifdef PERL_MAD
	|| block->op_type == OP_NULL
a6478 4
	)
	const_sv = NULL;
    else
	const_sv = op_const_sv(block, NULL);
d6480 1
a6480 2
    if (cv) {
        const bool exists = CvROOT(cv) || CvXSUB(cv);
d6482 9
a6490 140
        /* if the subroutine doesn't exist and wasn't pre-declared
         * with a prototype, assume it will be AUTOLOADed,
         * skipping the prototype check
         */
        if (exists || SvPOK(cv))
            cv_ckproto_len_flags(cv, (GV *)name, ps, ps_len, ps_utf8);
	/* already defined? */
	if (exists) {
	    if (S_already_defined(aTHX_ cv, block, NULL, name, &const_sv))
		cv = NULL;
	    else {
		if (attrs) goto attrs;
		/* just a "sub foo;" when &foo is already defined */
		SAVEFREESV(compcv);
		goto done;
	    }
	}
	else if (CvDEPTH(outcv) && CvCLONE(compcv)) {
	    cv = NULL;
	    reusable = TRUE;
	}
    }
    if (const_sv) {
	SvREFCNT_inc_simple_void_NN(const_sv);
	if (cv) {
	    assert(!CvROOT(cv) && !CvCONST(cv));
	    cv_forget_slab(cv);
	}
	else {
	    cv = MUTABLE_CV(newSV_type(SVt_PVCV));
	    CvFILE_set_from_cop(cv, PL_curcop);
	    CvSTASH_set(cv, PL_curstash);
	    *spot = cv;
	}
	sv_setpvs(MUTABLE_SV(cv), "");  /* prototype is "" */
	CvXSUBANY(cv).any_ptr = const_sv;
	CvXSUB(cv) = const_sv_xsub;
	CvCONST_on(cv);
	CvISXSUB_on(cv);
	if (PL_madskills)
	    goto install_block;
	op_free(block);
	SvREFCNT_dec(compcv);
	PL_compcv = NULL;
	goto setname;
    }
    /* Checking whether outcv is CvOUTSIDE(compcv) is not sufficient to
       determine whether this sub definition is in the same scope as its
       declaration.  If this sub definition is inside an inner named pack-
       age sub (my sub foo; sub bar { sub foo { ... } }), outcv points to
       the package sub.  So check PadnameOUTER(name) too.
     */
    if (outcv == CvOUTSIDE(compcv) && !PadnameOUTER(name)) { 
	assert(!CvWEAKOUTSIDE(compcv));
	SvREFCNT_dec(CvOUTSIDE(compcv));
	CvWEAKOUTSIDE_on(compcv);
    }
    /* XXX else do we have a circular reference? */
    if (cv) {	/* must reuse cv in case stub is referenced elsewhere */
	/* transfer PL_compcv to cv */
	if (block
#ifdef PERL_MAD
                  && block->op_type != OP_NULL
#endif
	) {
	    cv_flags_t preserved_flags =
		CvFLAGS(cv) & (CVf_BUILTIN_ATTRS|CVf_NAMED);
	    PADLIST *const temp_padl = CvPADLIST(cv);
	    CV *const temp_cv = CvOUTSIDE(cv);
	    const cv_flags_t other_flags =
		CvFLAGS(cv) & (CVf_SLABBED|CVf_WEAKOUTSIDE);
	    OP * const cvstart = CvSTART(cv);

	    SvPOK_off(cv);
	    CvFLAGS(cv) =
		CvFLAGS(compcv) | preserved_flags;
	    CvOUTSIDE(cv) = CvOUTSIDE(compcv);
	    CvOUTSIDE_SEQ(cv) = CvOUTSIDE_SEQ(compcv);
	    CvPADLIST(cv) = CvPADLIST(compcv);
	    CvOUTSIDE(compcv) = temp_cv;
	    CvPADLIST(compcv) = temp_padl;
	    CvSTART(cv) = CvSTART(compcv);
	    CvSTART(compcv) = cvstart;
	    CvFLAGS(compcv) &= ~(CVf_SLABBED|CVf_WEAKOUTSIDE);
	    CvFLAGS(compcv) |= other_flags;

	    if (CvFILE(cv) && CvDYNFILE(cv)) {
		Safefree(CvFILE(cv));
	    }

	    /* inner references to compcv must be fixed up ... */
	    pad_fixup_inner_anons(CvPADLIST(cv), compcv, cv);
	    if (PERLDB_INTER)/* Advice debugger on the new sub. */
	      ++PL_sub_generation;
	}
	else {
	    /* Might have had built-in attributes applied -- propagate them. */
	    CvFLAGS(cv) |= (CvFLAGS(compcv) & CVf_BUILTIN_ATTRS);
	}
	/* ... before we throw it away */
	SvREFCNT_dec(compcv);
	PL_compcv = compcv = cv;
    }
    else {
	cv = compcv;
	*spot = cv;
    }
   setname:
    if (!CvNAME_HEK(cv)) {
	CvNAME_HEK_set(cv,
	 hek
	  ? share_hek_hek(hek)
	  : share_hek(PadnamePV(name)+1,
		      PadnameLEN(name)-1 * (PadnameUTF8(name) ? -1 : 1),
		      0)
	);
    }
    if (const_sv) goto clone;

    CvFILE_set_from_cop(cv, PL_curcop);
    CvSTASH_set(cv, PL_curstash);

    if (ps) {
	sv_setpvn(MUTABLE_SV(cv), ps, ps_len);
        if ( ps_utf8 ) SvUTF8_on(MUTABLE_SV(cv));
    }

 install_block:
    if (!block)
	goto attrs;

    /* If we assign an optree to a PVCV, then we've defined a subroutine that
       the debugger could be able to set a breakpoint in, so signal to
       pp_entereval that it should not throw away any saved lines at scope
       exit.  */
       
    PL_breakable_sub_gen++;
    /* This makes sub {}; work as expected.  */
    if (block->op_type == OP_STUB) {
	    OP* const newblock = newSTATEOP(0, NULL, 0);
d6492 1
a6492 3
	    op_getmad(block,newblock,'B');
#else
	    op_free(block);
a6493 94
	    block = newblock;
    }
    CvROOT(cv) = CvLVALUE(cv)
		   ? newUNOP(OP_LEAVESUBLV, 0,
			     op_lvalue(scalarseq(block), OP_LEAVESUBLV))
		   : newUNOP(OP_LEAVESUB, 0, scalarseq(block));
    CvROOT(cv)->op_private |= OPpREFCOUNTED;
    OpREFCNT_set(CvROOT(cv), 1);
    /* The cv no longer needs to hold a refcount on the slab, as CvROOT
       itself has a refcount. */
    CvSLABBED_off(cv);
    OpslabREFCNT_dec_padok((OPSLAB *)CvSTART(cv));
    CvSTART(cv) = LINKLIST(CvROOT(cv));
    CvROOT(cv)->op_next = 0;
    CALL_PEEP(CvSTART(cv));
    finalize_optree(CvROOT(cv));

    /* now that optimizer has done its work, adjust pad values */

    pad_tidy(CvCLONE(cv) ? padtidy_SUBCLONE : padtidy_SUB);

    if (CvCLONE(cv)) {
	assert(!CvCONST(cv));
	if (ps && !*ps && op_const_sv(block, cv))
	    CvCONST_on(cv);
    }

  attrs:
    if (attrs) {
	/* Need to do a C<use attributes $stash_of_cv,\&cv,@@attrs>. */
	apply_attrs(PL_curstash, MUTABLE_SV(cv), attrs);
    }

    if (block) {
	if (PERLDB_SUBLINE && PL_curstash != PL_debstash) {
	    SV * const tmpstr = sv_newmortal();
	    GV * const db_postponed = gv_fetchpvs("DB::postponed",
						  GV_ADDMULTI, SVt_PVHV);
	    HV *hv;
	    SV * const sv = Perl_newSVpvf(aTHX_ "%s:%ld-%ld",
					  CopFILE(PL_curcop),
					  (long)PL_subline,
					  (long)CopLINE(PL_curcop));
	    if (HvNAME_HEK(PL_curstash)) {
		sv_sethek(tmpstr, HvNAME_HEK(PL_curstash));
		sv_catpvs(tmpstr, "::");
	    }
	    else sv_setpvs(tmpstr, "__ANON__::");
	    sv_catpvn_flags(tmpstr, PadnamePV(name)+1, PadnameLEN(name)-1,
			    PadnameUTF8(name) ? SV_CATUTF8 : SV_CATBYTES);
	    (void)hv_store(GvHV(PL_DBsub), SvPVX_const(tmpstr),
		    SvUTF8(tmpstr) ? -(I32)SvCUR(tmpstr) : (I32)SvCUR(tmpstr), sv, 0);
	    hv = GvHVn(db_postponed);
	    if (HvTOTALKEYS(hv) > 0 && hv_exists(hv, SvPVX_const(tmpstr), SvUTF8(tmpstr) ? -(I32)SvCUR(tmpstr) : (I32)SvCUR(tmpstr))) {
		CV * const pcv = GvCV(db_postponed);
		if (pcv) {
		    dSP;
		    PUSHMARK(SP);
		    XPUSHs(tmpstr);
		    PUTBACK;
		    call_sv(MUTABLE_SV(pcv), G_DISCARD);
		}
	    }
	}
    }

  clone:
    if (clonee) {
	assert(CvDEPTH(outcv));
	spot = (CV **)
	    &PadARRAY(PadlistARRAY(CvPADLIST(outcv))[CvDEPTH(outcv)])[pax];
	if (reusable) cv_clone_into(clonee, *spot);
	else *spot = cv_clone(clonee);
	SvREFCNT_dec_NN(clonee);
	cv = *spot;
	SvPADMY_on(cv);
    }
    if (CvDEPTH(outcv) && !reusable && PadnameIsSTATE(name)) {
	PADOFFSET depth = CvDEPTH(outcv);
	while (--depth) {
	    SV *oldcv;
	    svspot = &PadARRAY(PadlistARRAY(CvPADLIST(outcv))[depth])[pax];
	    oldcv = *svspot;
	    *svspot = SvREFCNT_inc_simple_NN(cv);
	    SvREFCNT_dec(oldcv);
	}
    }

  done:
    if (PL_parser)
	PL_parser->copline = NOLINE;
    LEAVE_SCOPE(floor);
    if (o) op_free(o);
    return cv;
d6511 1
a6511 1
    CV *cv = NULL;
a6512 1
    const bool ec = PL_parser && PL_parser->error_count;
d6519 1
a6519 2
	= ec ? GV_NOADD_NOINIT :
	 (block || attrs || (CvFLAGS(PL_compcv) & CVf_BUILTIN_ATTRS)
a6527 3
#ifdef PERL_DEBUG_READONLY_OPS
    OPSLAB *slab = NULL;
#endif
a6567 22
    if (ec) {
	op_free(block);
	if (name) SvREFCNT_dec(PL_compcv);
	else cv = PL_compcv;
	PL_compcv = 0;
	if (name && block) {
	    const char *s = strrchr(name, ':');
	    s = s ? s+1 : name;
	    if (strEQ(s, "BEGIN")) {
		if (PL_in_eval & EVAL_KEEPERR)
		    Perl_croak_nocontext("BEGIN not safe after errors--compilation aborted");
		else {
                    SV * const errsv = ERRSV;
		    /* force display of errors found but not reported */
		    sv_catpvs(errsv, "BEGIN not safe after errors--compilation aborted");
		    Perl_croak_nocontext("%"SVf, SVfARG(errsv));
		}
	    }
	}
	goto done;
    }

d6571 6
a6576 3
	    cv_ckproto_len_flags((const CV *)gv,
				 o ? (const GV *)cSVOPo->op_sv : NULL, ps,
				 ps_len, ps_utf8);
d6613 15
a6627 3
	    if (S_already_defined(aTHX_ cv, block, o, NULL, &const_sv))
		cv = NULL;
	    else {
d6633 19
d6655 1
a6658 1
	    cv_forget_slab(cv);
d6672 8
d6695 1
a6695 1
	    PADLIST *const temp_av = CvPADLIST(cv);
a6696 3
	    const cv_flags_t other_flags =
		CvFLAGS(cv) & (CVf_SLABBED|CVf_WEAKOUTSIDE);
	    OP * const cvstart = CvSTART(cv);
d6698 1
a6698 1
	    CvGV_set(cv,gv);
a6708 4
	    CvSTART(cv) = CvSTART(PL_compcv);
	    CvSTART(PL_compcv) = cvstart;
	    CvFLAGS(PL_compcv) &= ~(CVf_SLABBED|CVf_WEAKOUTSIDE);
	    CvFLAGS(PL_compcv) |= other_flags;
d6733 7
d6743 1
a6743 1
		gv_method_changed(gv);
d6757 19
d6796 1
a6802 7
    /* The cv no longer needs to hold a refcount on the slab, as CvROOT
       itself has a refcount. */
    CvSLABBED_off(cv);
    OpslabREFCNT_dec_padok((OPSLAB *)CvSTART(cv));
#ifdef PERL_DEBUG_READONLY_OPS
    slab = (OPSLAB *)CvSTART(cv);
#endif
d6822 1
a6822 3
	if (!name) SAVEFREESV(cv);
	apply_attrs(stash, MUTABLE_SV(cv), attrs);
	if (!name) SvREFCNT_inc_simple_void_NN(cv);
d6852 1
a6852 1
	    process_special_blocks(floor, name, gv, cv);
a6858 4
#ifdef PERL_DEBUG_READONLY_OPS
    /* Watch out for BEGIN blocks */
    if (slab && gv && isGV(gv) && GvCV(gv)) Slab_to_ro(slab);
#endif
d6863 1
a6863 2
S_process_special_blocks(pTHX_ I32 floor, const char *const fullname,
			 GV *const gv,
a6873 1
	    if (floor) LEAVE_SCOPE(floor);
a6951 3
The newly created subroutine takes ownership of a reference to the passed in
SV.

d6992 1
d6994 1
a6996 3
    /* Protect sv against leakage caused by fatal warnings. */
    if (sv) SAVEFREESV(sv);

d7003 1
a7003 1
    CvXSUBANY(cv).any_ptr = SvREFCNT_inc_simple(sv);
d7006 4
d7037 7
a7043 5
        GV * const gv = gv_fetchpvn(
			    name ? name : PL_curstash ? "__ANON__" : "__ANON__::__ANON__",
			    name ? len : PL_curstash ? sizeof("__ANON__") - 1:
				sizeof("__ANON__::__ANON__") - 1,
			    GV_ADDMULTI | flags, SVt_PVCV);
d7059 3
d7066 1
d7068 1
a7068 1
                SvREFCNT_dec_NN(cv);
d7081 1
a7081 1
                    gv_method_changed(gv); /* newXS */
d7095 1
a7095 1
            process_special_blocks(0, name, gv, cv);
a7105 17
CV *
Perl_newSTUB(pTHX_ GV *gv, bool fake)
{
    CV *cv = MUTABLE_CV(newSV_type(SVt_PVCV));
    PERL_ARGS_ASSERT_NEWSTUB;
    assert(!GvCVu(gv));
    GvCV_set(gv, cv);
    GvCVGEN(gv) = 0;
    if (!fake && HvENAME_HEK(GvSTASH(gv)))
	gv_method_changed(gv);
    CvGV_set(cv, gv);
    CvFILE_set_from_cop(cv, PL_curcop);
    CvSTASH_set(cv, PL_curstash);
    GvMULTI_on(gv);
    return cv;
}

d7119 1
a7119 3
    return newXS_len_flags(
	name, name ? strlen(name) : 0, subaddr, filename, NULL, NULL, 0
    );
d7130 1
a7130 1
    CV *cv;
d7135 1
a7135 8
    GV *gv;

    if (PL_parser && PL_parser->error_count) {
	op_free(block);
	goto finish;
    }

    gv = o
d7158 1
a7158 1
    GvFORM(gv) = (CV *)SvREFCNT_inc_simple_NN(cv);
a7170 3
    cv_forget_slab(cv);

  finish:
a7313 5
    if (o->op_type == OP_PADANY) {
	dVAR;
	o->op_type = OP_PADCV;
	o->op_ppaddr = PL_ppaddr[OP_PADCV];
    }
a7445 2
    /* transforms OP_REFGEN into OP_SREFGEN, OP_CHOP into OP_SCHOP,
     * and OP_CHOMP into OP_SCHOMP */
d7655 1
a7655 1
Perl_ck_rvconst(pTHX_ OP *o)
d7778 1
a7778 2
	if (kidtype == OP_CONST && (kid->op_private & OPpCONST_BARE)
	 && !(kid->op_private & OPpCONST_FOLDED)) {
d7821 1
a7821 1
    I32 oa = PL_opargs[type] >> OASHIFT;
d7834 1
a7834 1
        OP *kid = cLISTOPo->op_first;
d7950 1
a8080 4
		if ((type == OP_UNDEF || type == OP_POS)
		    && numargs == 1 && !(oa >> 4)
		    && kid->op_type == OP_LIST)
		    return too_many_arguments_pv(o,PL_op_desc[type], 0);
d8138 1
a8138 3
	GV * const * const gvp =
	    (GV **)hv_fetchs(PL_globalstash, "glob", FALSE);
	gv = gvp ? *gvp : NULL;
d8141 9
d8161 1
a8161 1
	 *                              \ null - const(wildcard)
d8165 2
d8172 1
a8172 1
	o = newUNOP(OP_NULL, 0, o);
d8177 1
a8177 10
#if !defined(PERL_EXTERNAL_GLOB)
    if (!PL_globhook) {
	ENTER;
	Perl_load_module(aTHX_ PERL_LOADMOD_NOIMPORT,
			       newSVpvs("File::Glob"), NULL, NULL, NULL);
	LEAVE;
    }
#endif /* !PERL_EXTERNAL_GLOB */
    gv = (GV *)newSV(0);
    gv_init(gv, 0, "", 0, 0);
d8179 3
a8182 1
    SvREFCNT_dec_NN(gv); /* newGVOP increased it */
d8191 1
a8191 1
    LOGOP *gwop;
d8202 2
d8207 5
d8227 2
a8228 1
    NewOp(1101, gwop, 1, LOGOP);
d8231 1
a8231 1
    gwop->op_first = o;
d8246 2
d8264 1
a8264 1
	    const bool save_taint = TAINT_get;
d8266 1
a8266 4
	    TAINT_set(save_taint);
#ifdef NO_TAINT_SUPPORT
            PERL_UNUSED_VAR(save_taint);
#endif
d8347 1
a8347 1
    OP *kid;
d8361 1
a8361 2
	if (kid->op_type == OP_CONST && kid->op_private & OPpCONST_BARE
	 && !(kid->op_private & OPpCONST_FOLDED)) {
d8508 1
a8508 1
	    if (!SvIsCOW(sv)) {
d8633 5
d8639 1
a8640 1
	    if (SvIsCOW(sv)) sv_force_normal_flags(sv, 0);
d8679 1
a8679 1
	newop = newUNOP(OP_ENTERSUB, OPf_STACKED,
d8683 1
a8683 1
								   gv)))));
a8768 1
    HV * const hinthv = GvHV(PL_hintgv);
d8772 3
a8774 1
    if (hinthv) {
d8783 1
d8786 1
a8786 1
    if (o->op_flags & OPf_STACKED)
d8790 1
d8795 6
a8800 1
	    if (kid->op_type == OP_LEAVE)
d8802 18
a8819 2
	    /* Prevent execution from escaping out of the sort block. */
	    kid->op_next = 0;
d8821 8
a8828 3
	    /* provide scalar context for comparison function/block */
	    kid = scalar(firstkid);
	    kid->op_next = kid;
d8836 2
a8837 1
    list(firstkid);
d8846 1
a8846 1
    OP *kid = cLISTOPo->op_first->op_sibling;	/* get past pushmark */
a8850 1
    bool have_scopeop;
d8859 1
a8859 2
    if (!(have_scopeop = kid->op_type == OP_SCOPE)
     && kid->op_type != OP_LEAVE)
a8865 1
	    if (!have_scopeop) goto padkids;
d8871 1
a8871 28
    if (kBINOP->op_first->op_type != OP_RV2SV
     || kBINOP->op_last ->op_type != OP_RV2SV)
    {
	/*
	   Warn about my($a) or my($b) in a sort block, *if* $a or $b is
	   then used in a comparison.  This catches most, but not
	   all cases.  For instance, it catches
	       sort { my($a); $a <=> $b }
	   but not
	       sort { my($a); $a < $b ? -1 : $a == $b ? 0 : 1; }
	   (although why you'd do that is anyone's guess).
	*/

       padkids:
	if (!ckWARN(WARN_SYNTAX)) return;
	kid = kBINOP->op_first;
	do {
	    if (kid->op_type == OP_PADSV) {
		SV * const name = AvARRAY(PL_comppad_name)[kid->op_targ];
		if (SvCUR(name) == 2 && *SvPVX(name) == '$'
		 && (SvPVX(name)[1] == 'a' || SvPVX(name)[1] == 'b'))
		    /* diag_listed_as: "my %s" used in sort comparison */
		    Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
				     "\"%s %s\" used in sort comparison",
				      SvPAD_STATE(name) ? "state" : "my",
				      SvPVX(name));
	    }
	} while ((kid = kid->op_sibling));
a8872 1
    }
d8889 2
a8890 1
    /* already checked above that it is rv2sv */
d8923 1
a8923 1
    OP *kid;
d8945 1
a8945 1
        kid = pmruntime( newPMOP(OP_MATCH, OPf_SPECIAL), kid, 0, 0); /* OPf_SPECIAL is used to trigger split " " behavior */
a9039 22
/* shared by toke.c:yylex */
CV *
Perl_find_lexical_cv(pTHX_ PADOFFSET off)
{
    PADNAME *name = PAD_COMPNAME(off);
    CV *compcv = PL_compcv;
    while (PadnameOUTER(name)) {
	assert(PARENT_PAD_INDEX(name));
	compcv = CvOUTSIDE(PL_compcv);
	name = PadlistNAMESARRAY(CvPADLIST(compcv))
		[off = PARENT_PAD_INDEX(name)];
    }
    assert(!PadnameIsOUR(name));
    if (!PadnameIsSTATE(name) && SvMAGICAL(name)) {
	MAGIC * mg = mg_find(name, PERL_MAGIC_proto);
	assert(mg);
	assert(mg->mg_obj);
	return (CV *)mg->mg_obj;
    }
    return (CV *)AvARRAY(PadlistARRAY(CvPADLIST(compcv))[1])[off];
}

a9072 4
	case OP_PADCV: {
	    cv = find_lexical_cv(rvop->op_targ);
	    gv = NULL;
	} break;
a9613 1
	callmg->mg_flags |= MGf_COPY;
a9657 15
	if (!namegv) { /* expletive! */
	    /* XXX The call checker API is public.  And it guarantees that
		   a GV will be provided with the right name.  So we have
		   to create a GV.  But it is still not correct, as its
		   stringification will include the package.  What we
		   really need is a new call checker API that accepts a
		   GV or string (or GV or CV). */
	    HEK * const hek = CvNAME_HEK(cv);
	    /* After a syntax error in a lexical sub, the cv that
	       rv2cv_op_cv returns may be a nameless stub. */
	    if (!hek) return ck_entersub_args_list(o);;
	    namegv = (GV *)sv_newmortal();
	    gv_init_pvn(namegv, PL_curstash, HEK_KEY(hek), HEK_LEN(hek),
			SVf_UTF8 * !!HEK_UTF8(hek));
	}
d9667 1
a9667 1
    if (!SvIsCOW(cSVOPo->op_sv)) SvREADONLY_on(cSVOPo->op_sv);
d9672 17
d9699 1
a9699 2
	    (kid->op_private & (OPpCONST_BARE|OPpCONST_FOLDED))
			     == OPpCONST_BARE)
d9830 28
a9943 1
  STMT_START { \
d9949 1
a9949 2
    defer_queue[(defer_base + ++defer_ix) % MAX_DEFERRED] = o; \
  } STMT_END
d9956 1
a9956 1
Perl_rpeep(pTHX_ OP *o)
d9959 1
a9959 2
    OP* oldop = NULL;
    OP* oldoldop = NULL;
d10010 2
a10011 1
		    firstcop->cop_stashoff = secondcop->cop_stashoff;
d10023 1
a10023 1
		    secondcop->cop_stashoff = 0;
a10084 241
        case OP_PUSHMARK:

            /* Convert a series of PAD ops for my vars plus support into a
             * single padrange op. Basically
             *
             *    pushmark -> pad[ahs]v -> pad[ahs]?v -> ... -> (list) -> rest
             *
             * becomes, depending on circumstances, one of
             *
             *    padrange  ----------------------------------> (list) -> rest
             *    padrange  --------------------------------------------> rest
             *
             * where all the pad indexes are sequential and of the same type
             * (INTRO or not).
             * We convert the pushmark into a padrange op, then skip
             * any other pad ops, and possibly some trailing ops.
             * Note that we don't null() the skipped ops, to make it
             * easier for Deparse to undo this optimisation (and none of
             * the skipped ops are holding any resourses). It also makes
             * it easier for find_uninit_var(), as it can just ignore
             * padrange, and examine the original pad ops.
             */
        {
            OP *p;
            OP *followop = NULL; /* the op that will follow the padrange op */
            U8 count = 0;
            U8 intro = 0;
            PADOFFSET base = 0; /* init only to stop compiler whining */
            U8 gimme       = 0; /* init only to stop compiler whining */
            bool defav = 0;  /* seen (...) = @@_ */
            bool reuse = 0;  /* reuse an existing padrange op */

            /* look for a pushmark -> gv[_] -> rv2av */

            {
                GV *gv;
                OP *rv2av, *q;
                p = o->op_next;
                if (   p->op_type == OP_GV
                    && (gv = cGVOPx_gv(p))
                    && GvNAMELEN_get(gv) == 1
                    && *GvNAME_get(gv) == '_'
                    && GvSTASH(gv) == PL_defstash
                    && (rv2av = p->op_next)
                    && rv2av->op_type == OP_RV2AV
                    && !(rv2av->op_flags & OPf_REF)
                    && !(rv2av->op_private & (OPpLVAL_INTRO|OPpMAYBE_LVSUB))
                    && ((rv2av->op_flags & OPf_WANT) == OPf_WANT_LIST)
                    && o->op_sibling == rv2av /* these two for Deparse */
                    && cUNOPx(rv2av)->op_first == p
                ) {
                    q = rv2av->op_next;
                    if (q->op_type == OP_NULL)
                        q = q->op_next;
                    if (q->op_type == OP_PUSHMARK) {
                        defav = 1;
                        p = q;
                    }
                }
            }
            if (!defav) {
                /* To allow Deparse to pessimise this, it needs to be able
                 * to restore the pushmark's original op_next, which it
                 * will assume to be the same as op_sibling. */
                if (o->op_next != o->op_sibling)
                    break;
                p = o;
            }

            /* scan for PAD ops */

            for (p = p->op_next; p; p = p->op_next) {
                if (p->op_type == OP_NULL)
                    continue;

                if ((     p->op_type != OP_PADSV
                       && p->op_type != OP_PADAV
                       && p->op_type != OP_PADHV
                    )
                      /* any private flag other than INTRO? e.g. STATE */
                   || (p->op_private & ~OPpLVAL_INTRO)
                )
                    break;

                /* let $a[N] potentially be optimised into ALEMFAST_LEX
                 * instead */
                if (   p->op_type == OP_PADAV
                    && p->op_next
                    && p->op_next->op_type == OP_CONST
                    && p->op_next->op_next
                    && p->op_next->op_next->op_type == OP_AELEM
                )
                    break;

                /* for 1st padop, note what type it is and the range
                 * start; for the others, check that it's the same type
                 * and that the targs are contiguous */
                if (count == 0) {
                    intro = (p->op_private & OPpLVAL_INTRO);
                    base = p->op_targ;
                    gimme = (p->op_flags & OPf_WANT);
                }
                else {
                    if ((p->op_private & OPpLVAL_INTRO) != intro)
                        break;
                    /* Note that you'd normally  expect targs to be
                     * contiguous in my($a,$b,$c), but that's not the case
                     * when external modules start doing things, e.g.
                     i* Function::Parameters */
                    if (p->op_targ != base + count)
                        break;
                    assert(p->op_targ == base + count);
                    /* all the padops should be in the same context */
                    if (gimme != (p->op_flags & OPf_WANT))
                        break;
                }

                /* for AV, HV, only when we're not flattening */
                if (   p->op_type != OP_PADSV
                    && gimme != OPf_WANT_VOID
                    && !(p->op_flags & OPf_REF)
                )
                    break;

                if (count >= OPpPADRANGE_COUNTMASK)
                    break;

                /* there's a biggest base we can fit into a
                 * SAVEt_CLEARPADRANGE in pp_padrange */
                if (intro && base >
                        (UV_MAX >> (OPpPADRANGE_COUNTSHIFT+SAVE_TIGHT_SHIFT)))
                    break;

                /* Success! We've got another valid pad op to optimise away */
                count++;
                followop = p->op_next;
            }

            if (count < 1)
                break;

            /* pp_padrange in specifically compile-time void context
             * skips pushing a mark and lexicals; in all other contexts
             * (including unknown till runtime) it pushes a mark and the
             * lexicals. We must be very careful then, that the ops we
             * optimise away would have exactly the same effect as the
             * padrange.
             * In particular in void context, we can only optimise to
             * a padrange if see see the complete sequence
             *     pushmark, pad*v, ...., list, nextstate
             * which has the net effect of of leaving the stack empty
             * (for now we leave the nextstate in the execution chain, for
             * its other side-effects).
             */
            assert(followop);
            if (gimme == OPf_WANT_VOID) {
                if (followop->op_type == OP_LIST
                        && gimme == (followop->op_flags & OPf_WANT)
                        && (   followop->op_next->op_type == OP_NEXTSTATE
                            || followop->op_next->op_type == OP_DBSTATE))
                {
                    followop = followop->op_next; /* skip OP_LIST */

                    /* consolidate two successive my(...);'s */

                    if (   oldoldop
                        && oldoldop->op_type == OP_PADRANGE
                        && (oldoldop->op_flags & OPf_WANT) == OPf_WANT_VOID
                        && (oldoldop->op_private & OPpLVAL_INTRO) == intro
                        && !(oldoldop->op_flags & OPf_SPECIAL)
                    ) {
                        U8 old_count;
                        assert(oldoldop->op_next == oldop);
                        assert(   oldop->op_type == OP_NEXTSTATE
                               || oldop->op_type == OP_DBSTATE);
                        assert(oldop->op_next == o);

                        old_count
                            = (oldoldop->op_private & OPpPADRANGE_COUNTMASK);
                        assert(oldoldop->op_targ + old_count == base);

                        if (old_count < OPpPADRANGE_COUNTMASK - count) {
                            base = oldoldop->op_targ;
                            count += old_count;
                            reuse = 1;
                        }
                    }

                    /* if there's any immediately following singleton
                     * my var's; then swallow them and the associated
                     * nextstates; i.e.
                     *    my ($a,$b); my $c; my $d;
                     * is treated as
                     *    my ($a,$b,$c,$d);
                     */

                    while (    ((p = followop->op_next))
                            && (  p->op_type == OP_PADSV
                               || p->op_type == OP_PADAV
                               || p->op_type == OP_PADHV)
                            && (p->op_flags & OPf_WANT) == OPf_WANT_VOID
                            && (p->op_private & OPpLVAL_INTRO) == intro
                            && p->op_next
                            && (   p->op_next->op_type == OP_NEXTSTATE
                                || p->op_next->op_type == OP_DBSTATE)
                            && count < OPpPADRANGE_COUNTMASK
                            && base + count == p->op_targ
                    ) {
                        count++;
                        followop = p->op_next;
                    }
                }
                else
                    break;
            }

            if (reuse) {
                assert(oldoldop->op_type == OP_PADRANGE);
                oldoldop->op_next = followop;
                oldoldop->op_private = (intro | count);
                o = oldoldop;
                oldop = NULL;
                oldoldop = NULL;
            }
            else {
                /* Convert the pushmark into a padrange.
                 * To make Deparse easier, we guarantee that a padrange was
                 * *always* formerly a pushmark */
                assert(o->op_type == OP_PUSHMARK);
                o->op_next = followop;
                o->op_type = OP_PADRANGE;
                o->op_ppaddr = PL_ppaddr[OP_PADRANGE];
                o->op_targ = base;
                /* bit 7: INTRO; bit 6..0: count */
                o->op_private = (intro | count);
                o->op_flags = ((o->op_flags & ~(OPf_WANT|OPf_SPECIAL))
                                    | gimme | (defav ? OPf_SPECIAL : 0));
            }
            break;
        }

a10147 9
#define HV_OR_SCALARHV(op)                                   \
    (  (op)->op_type == OP_PADHV || (op)->op_type == OP_RV2HV \
       ? (op)                                                  \
       : (op)->op_type == OP_SCALAR && (op)->op_flags & OPf_KIDS \
       && (  cUNOPx(op)->op_first->op_type == OP_PADHV          \
          || cUNOPx(op)->op_first->op_type == OP_RV2HV)          \
         ? cUNOPx(op)->op_first                                   \
         : NULL)

d10149 3
a10151 2
            if ((fop = HV_OR_SCALARHV(cUNOP->op_first)))
                fop->op_private |= OPpTRUEBOOL;
d10166 1
d10168 4
a10171 3
            fop = HV_OR_SCALARHV(fop);
            if (sop) sop = HV_OR_SCALARHV(sop);
            if (fop || sop
d10193 6
a10198 10
                if (fop) {
                    if (  (lop->op_flags & OPf_WANT) == OPf_WANT_VOID
                      || o->op_type == OP_AND  )
                        fop->op_private |= OPpTRUEBOOL;
                    else if (!(lop->op_flags & OPf_WANT))
                        fop->op_private |= OPpMAYBE_TRUEBOOL;
                }
                if (  (lop->op_flags & OPf_WANT) == OPf_WANT_VOID
                   && sop)
                    sop->op_private |= OPpTRUEBOOL;
d10203 1
a10204 7
	case OP_COND_EXPR:
	    if ((fop = HV_OR_SCALARHV(cLOGOP->op_first)))
		fop->op_private |= OPpTRUEBOOL;
#undef HV_OR_SCALARHV
	    /* GERONIMO! */
	}    

d10210 1
a10241 10
	    OP *oright;

	    if (o->op_flags & OPf_STACKED) {
		OP * const kid =
		    cUNOPx(cLISTOP->op_first->op_sibling)->op_first;
		if (kid->op_type == OP_SCOPE
		 || (kid->op_type == OP_NULL && kid->op_targ == OP_LEAVE))
		    DEFER(kLISTOP->op_first);
	    }

d10243 1
a10243 1
	    oright = cUNOPo->op_first;
a10415 1
	oldoldop = oldop;
d10422 1
a10422 1
Perl_peep(pTHX_ OP *o)
d10518 1
a10518 1
by C<keyword()>.  It must not be equal to 0 or -KEY_CORE.
d10535 1
a10535 1
    assert (code && code != -KEY_CORE);
d10541 1
a10541 1
    switch (code < 0 ? -code : code) {
d10543 4
a10546 8
    case KEY_cmp   : case KEY_defined: case KEY_delete: case KEY_exec  :
    case KEY_exists: case KEY_eq     : case KEY_ge    : case KEY_goto  :
    case KEY_grep  : case KEY_gt     : case KEY_last  : case KEY_le    :
    case KEY_lt    : case KEY_map    : case KEY_ne    : case KEY_next  :
    case KEY_or    : case KEY_print  : case KEY_printf: case KEY_qr    :
    case KEY_redo  : case KEY_require: case KEY_return: case KEY_say   :
    case KEY_select: case KEY_sort   : case KEY_split : case KEY_system:
    case KEY_x     : case KEY_xor    :
a10547 1
    case KEY_glob:    retsetpvs("_;", OP_GLOB);
a10554 1
    case KEY_pos:     retsetpvs(";\\[$*]", OP_POS);
d10577 1
a10577 1
    return NULL;
d10601 1
a10601 1
	    if (i == OP_LOCK || i == OP_UNDEF) str[n++] = '&';
a10668 2
	      if (scalar_mod_type(NULL, opnum))
		argop->op_private |= OPpCOREARGS_SCALARMOD;
d10672 1
a10672 1
	    o = convert(opnum,OPf_SPECIAL*(opnum == OP_GLOB),argop);
d10675 2
d10819 1
a10819 1
 * indent-tabs-mode: nil
d10822 1
a10822 1
 * ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.16
log
@Import perl-5.20.1
@
text
@a111 18
/* remove any leading "empty" ops from the op_next chain whose first
 * node's address is stored in op_p. Store the updated address of the
 * first node in op_p.
 */

STATIC void
S_prune_chain_head(pTHX_ OP** op_p)
{
    while (*op_p
        && (   (*op_p)->op_type == OP_NULL
            || (*op_p)->op_type == OP_SCOPE
            || (*op_p)->op_type == OP_SCALAR
            || (*op_p)->op_type == OP_LINESEQ)
    )
        *op_p = (*op_p)->op_next;
}


a167 6
    /* We only allocate ops from the slab during subroutine compilation.
       We find the slab via PL_compcv, hence that must be non-NULL. It could
       also be pointing to a subroutine which is now fully set up (CvROOT()
       pointing to the top of the optree for that sub), or a subroutine
       which isn't using the slab allocator. If our sanity checks aren't met,
       don't use a slab, but allocate the OP directly from the heap.  */
d172 14
a185 7
    /* While the subroutine is under construction, the slabs are accessed via
       CvSTART(), to avoid needing to expand PVCV by one pointer for something
       unneeded at runtime. Once a subroutine is constructed, the slabs are
       accessed via CvROOT(). So if CvSTART() is NULL, no slab has been
       allocated yet.  See the commit message for 8be227ab5eaa23f2 for more
       details.  */
    if (!CvSTART(PL_compcv)) {
a195 3
    /* The slabs maintain a free list of OPs. In particular, constant folding
       will free up OPs, so it makes sense to re-use them where possible. A
       freed up slot is used in preference to a new allocation.  */
d299 1
a299 1
#  define Slab_to_rw(op)    NOOP
d536 1
a536 1
S_bad_type_gv(pTHX_ I32 n, const char *t, GV *gv, U32 flags, const OP *kid)
d538 1
a538 2
    SV * const namesv = gv_ename(gv);
    PERL_ARGS_ASSERT_BAD_TYPE_GV;
a671 9
/*
=for apidoc Am|void|op_free|OP *o

Free an op.  Only use this when an op is no longer linked to from any
optree.

=cut
*/

d728 3
a730 2
    if (o->op_slabbed)
        Slab_to_rw(OpSLAB(o));
a925 2
    if (PL_curcop == cop)
       PL_curcop = NULL;
a984 9
/*
=for apidoc Am|void|op_null|OP *o

Neutralizes an op when it is no longer needed, but is still linked to from
other ops.

=cut
*/

d1049 1
a1049 1
This function is the implementation of the L</LINKLIST> macro.  It should
a1121 115
static SV *
S_op_varname(pTHX_ const OP *o)
{
    assert(o);
    assert(o->op_type == OP_PADAV || o->op_type == OP_RV2AV ||
	   o->op_type == OP_PADHV || o->op_type == OP_RV2HV);
    {
	const char funny  = o->op_type == OP_PADAV
			 || o->op_type == OP_RV2AV ? '@@' : '%';
	if (o->op_type == OP_RV2AV || o->op_type == OP_RV2HV) {
	    GV *gv;
	    if (cUNOPo->op_first->op_type != OP_GV
	     || !(gv = cGVOPx_gv(cUNOPo->op_first)))
		return NULL;
	    return varname(gv, funny, 0, NULL, 0, 1);
	}
	return
	    varname(MUTABLE_GV(PL_compcv), funny, o->op_targ, NULL, 0, 1);
    }
}

static void
S_op_pretty(pTHX_ const OP *o, SV **retsv, const char **retpv)
{ /* or not so pretty :-) */
    if (o->op_type == OP_CONST) {
	*retsv = cSVOPo_sv;
	if (SvPOK(*retsv)) {
	    SV *sv = *retsv;
	    *retsv = sv_newmortal();
	    pv_pretty(*retsv, SvPVX_const(sv), SvCUR(sv), 32, NULL, NULL,
		      PERL_PV_PRETTY_DUMP |PERL_PV_ESCAPE_UNI_DETECT);
	}
	else if (!SvOK(*retsv))
	    *retpv = "undef";
    }
    else *retpv = "...";
}

static void
S_scalar_slice_warning(pTHX_ const OP *o)
{
    OP *kid;
    const char lbrack =
	o->op_type == OP_HSLICE ? '{' : '[';
    const char rbrack =
	o->op_type == OP_HSLICE ? '}' : ']';
    SV *name;
    SV *keysv = NULL; /* just to silence compiler warnings */
    const char *key = NULL;

    if (!(o->op_private & OPpSLICEWARNING))
	return;
    if (PL_parser && PL_parser->error_count)
	/* This warning can be nonsensical when there is a syntax error. */
	return;

    kid = cLISTOPo->op_first;
    kid = kid->op_sibling; /* get past pushmark */
    /* weed out false positives: any ops that can return lists */
    switch (kid->op_type) {
    case OP_BACKTICK:
    case OP_GLOB:
    case OP_READLINE:
    case OP_MATCH:
    case OP_RV2AV:
    case OP_EACH:
    case OP_VALUES:
    case OP_KEYS:
    case OP_SPLIT:
    case OP_LIST:
    case OP_SORT:
    case OP_REVERSE:
    case OP_ENTERSUB:
    case OP_CALLER:
    case OP_LSTAT:
    case OP_STAT:
    case OP_READDIR:
    case OP_SYSTEM:
    case OP_TMS:
    case OP_LOCALTIME:
    case OP_GMTIME:
    case OP_ENTEREVAL:
    case OP_REACH:
    case OP_RKEYS:
    case OP_RVALUES:
	return;
    }

    /* Don't warn if we have a nulled list either. */
    if (kid->op_type == OP_NULL && kid->op_targ == OP_LIST)
        return;

    assert(kid->op_sibling);
    name = S_op_varname(aTHX_ kid->op_sibling);
    if (!name) /* XS module fiddling with the op tree */
	return;
    S_op_pretty(aTHX_ kid, &keysv, &key);
    assert(SvPOK(name));
    sv_chop(name,SvPVX(name)+1);
    if (key)
       /* diag_listed_as: Scalar value @@%s[%s] better written as $%s[%s] */
	Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
		   "Scalar value @@%"SVf"%c%s%c better written as $%"SVf
		   "%c%s%c",
		    SVfARG(name), lbrack, key, rbrack, SVfARG(name),
		    lbrack, key, rbrack);
    else
       /* diag_listed_as: Scalar value @@%s[%s] better written as $%s[%s] */
	Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
		   "Scalar value @@%"SVf"%c%"SVf"%c better written as $%"
		    SVf"%c%"SVf"%c",
		    SVfARG(name), lbrack, keysv, rbrack,
		    SVfARG(name), lbrack, keysv, rbrack);
}

a1183 40
    case OP_KVHSLICE:
    case OP_KVASLICE:
    {
	/* Warn about scalar context */
	const char lbrack = o->op_type == OP_KVHSLICE ? '{' : '[';
	const char rbrack = o->op_type == OP_KVHSLICE ? '}' : ']';
	SV *name;
	SV *keysv;
	const char *key = NULL;

	/* This warning can be nonsensical when there is a syntax error. */
	if (PL_parser && PL_parser->error_count)
	    break;

	if (!ckWARN(WARN_SYNTAX)) break;

	kid = cLISTOPo->op_first;
	kid = kid->op_sibling; /* get past pushmark */
	assert(kid->op_sibling);
	name = S_op_varname(aTHX_ kid->op_sibling);
	if (!name) /* XS module fiddling with the op tree */
	    break;
	S_op_pretty(aTHX_ kid, &keysv, &key);
	assert(SvPOK(name));
	sv_chop(name,SvPVX(name)+1);
	if (key)
  /* diag_listed_as: %%s[%s] in scalar context better written as $%s[%s] */
	    Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
		       "%%%"SVf"%c%s%c in scalar context better written "
		       "as $%"SVf"%c%s%c",
			SVfARG(name), lbrack, key, rbrack, SVfARG(name),
			lbrack, key, rbrack);
	else
  /* diag_listed_as: %%s[%s] in scalar context better written as $%s[%s] */
	    Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
		       "%%%"SVf"%c%"SVf"%c in scalar context better "
		       "written as $%"SVf"%c%"SVf"%c",
			SVfARG(name), lbrack, keysv, rbrack,
			SVfARG(name), lbrack, keysv, rbrack);
    }
a1274 1
    case OP_KVASLICE:
a1276 1
    case OP_KVHSLICE:
d1382 23
a1404 10
                    SV * const dsv = newSVpvs("");
                    useless_sv
                        = Perl_newSVpvf(aTHX_
                                        "a constant (%s)",
                                        pv_pretty(dsv, SvPVX_const(sv),
                                                  SvCUR(sv), 32, NULL, NULL,
                                                  PERL_PV_PRETTY_DUMP
                                                  | PERL_PV_ESCAPE_NOCLEAR
                                                  | PERL_PV_ESCAPE_UNI_DETECT));
                    SvREFCNT_dec_NN(dsv);
d1672 2
a1673 2
This function finalizes the optree.  Should be called directly after
the complete optree is built.  It does some additional
d1723 1
a1723 1
	    && ckWARN(WARN_EXEC))
d1765 29
a1793 5
	    const PADOFFSET ix = pad_alloc(OP_CONST, SVf_READONLY);
	    SvREFCNT_dec(PAD_SVl(ix));
	    PAD_SETSV(ix, cSVOPo->op_sv);
	    /* XXX I don't know how this isn't readonly already. */
	    if (!SvIsCOW(PAD_SVl(ix))) SvREADONLY_on(PAD_SVl(ix));
d1804 3
a1806 3
	SVOP *key_op;
	OP *kid;
	bool check_fields;
d1808 1
a1808 1
	if ((key_op = cSVOPx(((BINOP*)o)->op_last))->op_type != OP_CONST)
d1811 11
a1821 1
	rop = (UNOP*)((BINOP*)o)->op_first;
d1823 2
a1824 1
	goto check_keys;
d1826 19
a1844 2
    case OP_HSLICE:
	S_scalar_slice_warning(aTHX_ o);
d1846 13
a1858 6
    case OP_KVHSLICE:
        kid = cLISTOPo->op_first->op_sibling;
	if (/* I bet there's always a pushmark... */
	    OP_TYPE_ISNT_AND_WASNT_NN(kid, OP_LIST)
	    && OP_TYPE_ISNT_NN(kid, OP_CONST))
        {
a1859 6
        }

	key_op = (SVOP*)(kid->op_type == OP_CONST
				? kid
				: kLISTOP->op_first->op_sibling);

d1861 3
a1863 5

      check_keys:	
	if (o->op_private & OPpLVAL_INTRO || rop->op_type != OP_RV2HV)
	    rop = NULL;
	else if (rop->op_first->op_type == OP_PADSV)
d1874 1
a1874 1
		rop = NULL;
d1877 10
a1886 10
        lexname = NULL; /* just to silence compiler warnings */
        fields  = NULL; /* just to silence compiler warnings */

	check_fields =
	    rop
	 && (lexname = *av_fetch(PL_comppad_name, rop->op_targ, TRUE),
	     SvPAD_TYPED(lexname))
	 && (fields = (GV**)hv_fetchs(SvSTASH(lexname), "FIELDS", FALSE))
	 && isGV(*fields) && GvHV(*fields);
	for (; key_op;
a1887 1
	    SV **svp, *sv;
d1891 3
a1893 14

	    /* Make the CONST have a shared SV */
	    if ((!SvIsCOW_shared_hash(sv = *svp))
	     && SvTYPE(sv) < SVt_PVMG && SvOK(sv) && !SvROK(sv)) {
		SSize_t keylen;
		const char * const key = SvPV_const(sv, *(STRLEN*)&keylen);
		SV *nsv = newSVpvn_share(key,
					 SvUTF8(sv) ? -keylen : keylen,	0);
		SvREFCNT_dec_NN(sv);
		*svp = nsv;
	    }

	    if (check_fields
	     && !hv_fetch_ent(GvHV(*fields), *svp, FALSE, 0)) {
a1901 3
    case OP_ASLICE:
	S_scalar_slice_warning(aTHX_ o);
	break;
d1929 1
a1929 1
generates errors for them.  For example, C<$x+1 = 2> would cause it to be
a1937 15
static bool
S_vivifies(const OPCODE type)
{
    switch(type) {
    case OP_RV2AV:     case   OP_ASLICE:
    case OP_RV2HV:     case OP_KVASLICE:
    case OP_RV2SV:     case   OP_HSLICE:
    case OP_AELEMFAST: case OP_KVHSLICE:
    case OP_HELEM:
    case OP_AELEM:
	return 1;
    }
    return 0;
}

d2090 1
a2090 5
	/* Do not apply the lvsub flag for rv2[ah]v in scalar context.  */
	if (type == OP_LEAVESUBLV && (
		(o->op_type != OP_RV2AV && o->op_type != OP_RV2HV)
	     || (o->op_flags & OPf_WANT) != OPf_WANT_SCALAR
	   ))
a2096 5
    case OP_KVHSLICE:
    case OP_KVASLICE:
	if (type == OP_LEAVESUBLV)
	    o->op_private |= OPpMAYBE_LVSUB;
        goto nomod;
d2129 1
a2129 2
	if ((o->op_flags & OPf_WANT) != OPf_WANT_SCALAR
	  && type == OP_LEAVESUBLV)
d2157 3
d2176 1
a2177 3
    case OP_LEAVELOOP:
	o->op_private |= OPpLVALUE;
    case OP_SCOPE:
a2211 10

    case OP_AND:
    case OP_OR:
	if (type == OP_LEAVESUBLV
	 || !S_vivifies(cLOGOPo->op_first->op_type))
	    op_lvalue(cLOGOPo->op_first, type);
	if (type == OP_LEAVESUBLV
	 || !S_vivifies(cLOGOPo->op_first->op_sibling->op_type))
	    op_lvalue(cLOGOPo->op_first->op_sibling, type);
	goto nomod;
d2472 1
d2486 1
d2506 1
d2514 1
a2591 108
STATIC void
S_move_proto_attr(pTHX_ OP **proto, OP **attrs, const GV * name)
{
    OP *new_proto = NULL;
    STRLEN pvlen;
    char *pv;
    OP *o;

    PERL_ARGS_ASSERT_MOVE_PROTO_ATTR;

    if (!*attrs)
        return;

    o = *attrs;
    if (o->op_type == OP_CONST) {
        pv = SvPV(cSVOPo_sv, pvlen);
        if (pvlen >= 10 && memEQ(pv, "prototype(", 10)) {
            SV * const tmpsv = newSVpvn_flags(pv + 10, pvlen - 11, SvUTF8(cSVOPo_sv));
            SV ** const tmpo = cSVOPx_svp(o);
            SvREFCNT_dec(cSVOPo_sv);
            *tmpo = tmpsv;
            new_proto = o;
            *attrs = NULL;
        }
    } else if (o->op_type == OP_LIST) {
        OP * lasto = NULL;
        assert(o->op_flags & OPf_KIDS);
        assert(cLISTOPo->op_first->op_type == OP_PUSHMARK);
        /* Counting on the first op to hit the lasto = o line */
        for (o = cLISTOPo->op_first; o; o=o->op_sibling) {
            if (o->op_type == OP_CONST) {
                pv = SvPV(cSVOPo_sv, pvlen);
                if (pvlen >= 10 && memEQ(pv, "prototype(", 10)) {
                    SV * const tmpsv = newSVpvn_flags(pv + 10, pvlen - 11, SvUTF8(cSVOPo_sv));
                    SV ** const tmpo = cSVOPx_svp(o);
                    SvREFCNT_dec(cSVOPo_sv);
                    *tmpo = tmpsv;
                    if (new_proto && ckWARN(WARN_MISC)) {
                        STRLEN new_len;
                        const char * newp = SvPV(cSVOPo_sv, new_len);
                        Perl_warner(aTHX_ packWARN(WARN_MISC),
                            "Attribute prototype(%"UTF8f") discards earlier prototype attribute in same sub",
                            UTF8fARG(SvUTF8(cSVOPo_sv), new_len, newp));
                        op_free(new_proto);
                    }
                    else if (new_proto)
                        op_free(new_proto);
                    new_proto = o;
                    lasto->op_sibling = o->op_sibling;
                    continue;
                }
            }
            lasto = o;
        }
        /* If the list is now just the PUSHMARK, scrap the whole thing; otherwise attributes.xs
           would get pulled in with no real need */
        if (!cLISTOPx(*attrs)->op_first->op_sibling) {
            op_free(*attrs);
            *attrs = NULL;
        }
    }

    if (new_proto) {
        SV *svname;
        if (isGV(name)) {
            svname = sv_newmortal();
            gv_efullname3(svname, name, NULL);
        }
        else if (SvPOK(name) && *SvPVX((SV *)name) == '&')
            svname = newSVpvn_flags(SvPVX((SV *)name)+1, SvCUR(name)-1, SvUTF8(name)|SVs_TEMP);
        else
            svname = (SV *)name;
        if (ckWARN(WARN_ILLEGALPROTO))
            (void)validate_proto(svname, cSVOPx_sv(new_proto), TRUE);
        if (*proto && ckWARN(WARN_PROTOTYPE)) {
            STRLEN old_len, new_len;
            const char * oldp = SvPV(cSVOPx_sv(*proto), old_len);
            const char * newp = SvPV(cSVOPx_sv(new_proto), new_len);

            Perl_warner(aTHX_ packWARN(WARN_PROTOTYPE),
                "Prototype '%"UTF8f"' overridden by attribute 'prototype(%"UTF8f")'"
                " in %"SVf,
                UTF8fARG(SvUTF8(cSVOPx_sv(*proto)), old_len, oldp),
                UTF8fARG(SvUTF8(cSVOPx_sv(new_proto)), new_len, newp),
                SVfARG(svname));
        }
        if (*proto)
            op_free(*proto);
        *proto = new_proto;
    }
}

static void
S_cant_declare(pTHX_ OP *o)
{
    if (o->op_type == OP_NULL
     && (o->op_flags & (OPf_SPECIAL|OPf_KIDS)) == OPf_KIDS)
        o = cUNOPo->op_first;
    yyerror(Perl_form(aTHX_ "Can't declare %s in \"%s\"",
                             o->op_type == OP_NULL
                               && o->op_flags & OPf_SPECIAL
                                 ? "do block"
                                 : OP_DESC(o),
                             PL_parser->in_my == KEY_our   ? "our"   :
                             PL_parser->in_my == KEY_state ? "state" :
                                                             "my"));
}

d2621 5
a2625 1
	    S_cant_declare(aTHX_ o);
d2644 5
a2648 1
	S_cant_declare(aTHX_ o);
d2746 1
d2748 8
a2755 1
	S_op_varname(aTHX_ left);
a2778 1
	/* diag_listed_as: Using !~ with %s doesn't make sense */
a2780 1
	/* diag_listed_as: Using !~ with %s doesn't make sense */
d2909 1
d2984 1
a2984 1
at compile time.  See L<perlguts/"Compile-time scope hooks">.
a3046 1
        S_prune_chain_head(aTHX_ &PL_eval_start);
a3090 1
        S_prune_chain_head(aTHX_ &PL_main_start);
a3244 1
    case OP_FC:
a3272 5
	break;
    case OP_SREFGEN:
	if (cUNOPx(cUNOPo->op_first)->op_first->op_type != OP_CONST
	 || SvPADTMP(cSVOPx_sv(cUNOPx(cUNOPo->op_first)->op_first)))
	    goto nope;
a3326 1
	else { assert(SvIMMORTAL(sv)); }
a3357 5
    if (type == OP_STRINGIFY) SvPADTMP_off(sv);
    else if (!SvIMMORTAL(sv)) {
	SvPADTMP_on(sv);
	SvREADONLY_on(sv);
    }
d3361 1
a3361 4
    {
	newop = newSVOP(OP_CONST, 0, MUTABLE_SV(sv));
	if (type != OP_STRINGIFY) newop->op_folded = 1;
    }
d3374 1
a3374 3
    const SSize_t oldtmps_floor = PL_tmps_floor;
    SV **svp;
    AV *av;
d3380 1
a3380 1
    curop = LINKLIST(o);
a3382 2
    S_prune_chain_head(aTHX_ &curop);
    PL_op = curop;
d3397 1
a3397 8
    av = (AV *)SvREFCNT_inc_NN(*PL_stack_sp--);
    ((UNOP*)o)->op_first = newSVOP(OP_CONST, 0, (SV *)av);
    if (AvFILLp(av) != -1)
	for (svp = AvARRAY(av) + AvFILLp(av); svp >= AvARRAY(av); --svp)
	{
	    SvPADTMP_on(*svp);
	    SvREADONLY_on(*svp);
	}
d4013 1
a4013 1
    ASSUME((PL_opargs[type] & OA_CLASS_MASK) == OA_BINOP
d4130 5
a4134 3
/* There is a  snag with this code on EBCDIC: scan_const() in toke.c has
 * encoded chars in native encoding which makes ranges in the EBCDIC 0..255
 * odd.  */
d4144 1
a4144 1
		cp[2*i] = utf8n_to_uvchr(t, tend-t, &ulen, flags);
d4146 1
a4146 1
		if (t < tend && *t == ILLEGAL_UTF8_BYTE) {
d4148 1
a4148 1
		    cp[2*i+1] = utf8n_to_uvchr(t, tend-t, &ulen, flags);
d4161 1
a4161 1
		    t = uvchr_to_utf8(tmpbuf,nextmin);
d4164 2
a4165 2
			U8  range_mark = ILLEGAL_UTF8_BYTE;
			t = uvchr_to_utf8(tmpbuf, val - 1);
d4174 1
a4174 1
	    t = uvchr_to_utf8(tmpbuf,nextmin);
d4177 1
a4177 1
		U8 range_mark = ILLEGAL_UTF8_BYTE;
d4180 1
a4180 1
	    t = uvchr_to_utf8(tmpbuf, 0x7fffffff);
d4201 1
a4201 1
		tfirst = (I32)utf8n_to_uvchr(t, tend - t, &ulen, flags);
d4203 1
a4203 1
		if (t < tend && *t == ILLEGAL_UTF8_BYTE) {	/* illegal utf8 val indicates range */
d4205 1
a4205 1
		    tlast = (I32)utf8n_to_uvchr(t, tend - t, &ulen, flags);
d4215 1
a4215 1
		    rfirst = (I32)utf8n_to_uvchr(r, rend - r, &ulen, flags);
d4217 1
a4217 1
		    if (r < rend && *r == ILLEGAL_UTF8_BYTE) {	/* illegal utf8 val indicates range */
d4219 1
a4219 1
			rlast = (I32)utf8n_to_uvchr(r, rend - r, &ulen, flags);
d4281 1
a4281 1
	cPADOPo->op_padix = pad_alloc(OP_TRANS, SVf_READONLY);
d4387 1
a4387 1
    } else if(rlen > tlen && !complement) {
d4471 1
a4471 1
	pmop->op_pmoffset = av_tindex(PL_regex_padav);
a4603 1
            S_prune_chain_head(aTHX_ &(o->op_next));
d4790 4
d4924 1
d4934 1
a4934 1
#endif /* USE_ITHREADS */
d4969 1
a4969 1
must have been allocated using C<PerlMemShared_malloc>; the memory will
d5214 1
a5214 2
(or 0 for no flags).  ver, if specified
and not NULL, provides version semantics
d5287 1
a5287 2
     * since pp_require() will create another parser for the real work.
     * The ENTER/LEAVE pair protect callers from any side effects of use.  */
a5296 9
PERL_STATIC_INLINE OP *
S_new_entersubop(pTHX_ GV *gv, OP *arg)
{
    return newUNOP(OP_ENTERSUB, OPf_STACKED,
		   newLISTOP(OP_LIST, 0, arg,
			     newUNOP(OP_RV2CV, 0,
				     newGVOP(OP_GV, 0, gv))));
}

d5302 1
a5302 1
    GV *gv;
d5306 13
a5318 2
    if (!force_builtin && (gv = gv_override("do", 2))) {
	doop = S_new_entersubop(aTHX_ gv, term);
d5382 1
a5382 2
	type == OP_ASLICE || type == OP_HSLICE ||
        type == OP_KVASLICE || type == OP_KVHSLICE)
a5432 1
		GV *const gv =
d5434 7
a5440 3
		    ((PMOP*)curop)->op_pmreplrootu.op_pmtargetoff
			? MUTABLE_GV(PAD_SVl(((PMOP*)curop)->op_pmreplrootu.op_pmtargetoff))
			: NULL;
d5442 2
a5443 2
		    ((PMOP*)curop)->op_pmreplrootu.op_pmtargetgv;
#endif
d5450 1
a5510 3
	if (left->op_type == OP_ASLICE || left->op_type == OP_HSLICE)
	    left->op_private &= ~ OPpSLICEWARNING;

d5517 2
a5518 1
	if (OP_TYPE_IS_OR_WAS(left, OP_LIST))
d5544 1
a5544 1
                           OP_TYPE_IS_OR_WAS(lop, OP_PUSHMARK)) {
d5636 1
a5636 3
			SV ** const svp =
			    &((SVOP*)((LISTOP*)right)->op_last)->op_sv;
			SV * const sv = *svp;
a5637 4
			{
			  if (right->op_private & OPpSPLIT_IMPLIM) {
			    /* our own SV, created in ck_split */
			    SvREADONLY_off(sv);
a5638 7
			  }
			  else {
			    /* SV may belong to someone else */
			    SvREFCNT_dec(sv);
			    *svp = newSViv(PL_modcount+1);
			  }
			}
d5664 1
a5664 1
code.  The state op is populated from C<PL_curcop> (or C<PL_compiling>).
d5701 1
a5701 3
#ifdef VMS
    if (VMSISH_HUSHED) cop->op_private |= OPpHUSH_VMSISH;
#endif
d5717 1
a5717 5
    if (PL_parser->preambling != NOLINE) {
        CopLINE_set(cop, PL_parser->preambling);
        PL_parser->copline = NOLINE;
    }
    else if (PL_parser->copline == NOLINE)
d5730 1
a5730 1
    if (cop->op_type == OP_DBSTATE) {
d5734 1
a5734 1
	    SV * const * const svp = av_fetch(av, CopLINE(cop), FALSE);
a5829 38
    /* [perl #59802]: Warn about things like "return $a or $b", which
       is parsed as "(return $a) or $b" rather than "return ($a or
       $b)".  NB: This also applies to xor, which is why we do it
       here.
     */
    switch (first->op_type) {
    case OP_NEXT:
    case OP_LAST:
    case OP_REDO:
	/* XXX: Perhaps we should emit a stronger warning for these.
	   Even with the high-precedence operator they don't seem to do
	   anything sensible.

	   But until we do, fall through here.
         */
    case OP_RETURN:
    case OP_EXIT:
    case OP_DIE:
    case OP_GOTO:
	/* XXX: Currently we allow people to "shoot themselves in the
	   foot" by explicitly writing "(return $a) or $b".

	   Warn unless we are looking at the result from folding or if
	   the programmer explicitly grouped the operators like this.
	   The former can occur with e.g.

		use constant FEATURE => ( $] >= ... );
		sub { not FEATURE and return or do_stuff(); }
	 */
	if (!first->op_folded && !(first->op_flags & OPf_PARENS))
	    Perl_ck_warner(aTHX_ packWARN(WARN_SYNTAX),
	                   "Possible precedence issue with control flow operator");
	/* XXX: Should we optimze this to "return $a;" (i.e. remove
	   the "or $b" part)?
	*/
	break;
    }

d5881 2
a5882 2

	    other->op_folded = 1;
d5904 2
a5905 2
	    if (cstop->op_type == OP_CONST)
		cstop->op_private |= OPpCONST_SHORTCIRCUIT;
d6042 2
a6043 1
	live->op_folded = 1;
d6164 1
a6164 1
		      block->op_type == OP_NULL;
d6169 1
a6169 9
	if (once && (
	      (expr->op_type == OP_CONST && !SvTRUE(((SVOP*)expr)->op_sv))
	   || (  expr->op_type == OP_NOT
	      && cUNOPx(expr)->op_first->op_type == OP_CONST
	      && SvTRUE(cSVOPx_sv(cUNOPx(expr)->op_first))
	      )
	   ))
	    /* Return the block now, so that S_new_logop does not try to
	       fold it away. */
a6207 4
    if (once) {
	ASSUME(listop);
    }

a6211 3
    {
	assert(cUNOPo->op_first->op_type == OP_AND
	    || cUNOPo->op_first->op_type == OP_OR);
a6212 1
    }
d6575 1
a6575 3
    ||  cond->op_type == OP_KVASLICE
    ||  cond->op_type == OP_HSLICE
    ||  cond->op_type == OP_KVHSLICE)) {
d6786 2
a6787 3
    SV *name = NULL, *msg;
    const char * cvp = SvROK(cv) ? "" : CvPROTO(cv);
    STRLEN clen = CvPROTOLEN(cv), plen = len;
d6791 15
a6805 2
    if (p == NULL && cvp == NULL)
	return;
d6807 24
a6830 19
    if (!ckWARN_d(WARN_PROTOTYPE))
	return;

    if (p && cvp) {
	p = S_strip_spaces(aTHX_ p, &plen);
	cvp = S_strip_spaces(aTHX_ cvp, &clen);
	if ((flags & SVf_UTF8) == SvUTF8(cv)) {
	    if (plen == clen && memEQ(cvp, p, plen))
		return;
	} else {
	    if (flags & SVf_UTF8) {
		if (bytes_cmp_utf8((const U8 *)cvp, clen, (const U8 *)p, plen) == 0)
		    return;
            }
	    else {
		if (bytes_cmp_utf8((const U8 *)p, plen, (const U8 *)cvp, clen) == 0)
		    return;
	    }
	}
a6831 26

    msg = sv_newmortal();

    if (gv)
    {
	if (isGV(gv))
	    gv_efullname3(name = sv_newmortal(), gv, NULL);
	else if (SvPOK(gv) && *SvPVX((SV *)gv) == '&')
	    name = newSVpvn_flags(SvPVX((SV *)gv)+1, SvCUR(gv)-1, SvUTF8(gv)|SVs_TEMP);
	else name = (SV *)gv;
    }
    sv_setpvs(msg, "Prototype mismatch:");
    if (name)
	Perl_sv_catpvf(aTHX_ msg, " sub %"SVf, SVfARG(name));
    if (cvp)
	Perl_sv_catpvf(aTHX_ msg, " (%"UTF8f")", 
	    UTF8fARG(SvUTF8(cv),clen,cvp)
	);
    else
	sv_catpvs(msg, ": none");
    sv_catpvs(msg, " vs ");
    if (p)
	Perl_sv_catpvf(aTHX_ msg, "(%"UTF8f")", UTF8fARG(flags & SVf_UTF8,len,p));
    else
	sv_catpvs(msg, "none");
    Perl_warner(aTHX_ packWARN(WARN_PROTOTYPE), "%"SVf, SVfARG(msg));
a6834 1
static void const_av_xsub(pTHX_ CV* cv);
d6842 1
a6842 1
If C<cv> is a constant sub eligible for inlining, returns the constant
a6852 1
    SV *sv;
a6857 12
    sv = CvCONST(cv) ? MUTABLE_SV(CvXSUBANY(cv).any_ptr) : NULL;
    if (sv && SvTYPE(sv) == SVt_PVAV) return NULL;
    return sv;
}

SV *
Perl_cv_const_sv_or_av(pTHX_ const CV * const cv)
{
    PERL_UNUSED_CONTEXT;
    if (!cv)
	return NULL;
    assert (SvTYPE(cv) == SVt_PVCV || SvTYPE(cv) == SVt_PVFM);
d6997 1
a6997 1
	SAVEFREESV(cv);
a7042 3
    if (!(PL_parser && PL_parser->error_count))
        move_proto_attr(&proto, &attrs, (GV *)name);

d7118 1
a7118 1
	    if (S_already_defined(aTHX_ cv,block,NULL,name,&const_sv))
a7133 1
	SvFLAGS(const_sv) = (SvFLAGS(const_sv) & ~SVs_PADMY) | SVs_PADTMP;
a7270 1
    S_prune_chain_head(aTHX_ &CvSTART(cv));
a7350 1
/* _x = extended */
d7352 8
a7359 2
Perl_newATTRSUB_x(pTHX_ I32 floor, OP *o, OP *proto, OP *attrs,
			    OP *block, bool o_is_gv)
d7380 1
d7389 8
a7418 11
    if (!ec)
        move_proto_attr(&proto, &attrs, gv);

    if (proto) {
	assert(proto->op_type == OP_CONST);
	ps = SvPV_const(((SVOP*)proto)->op_sv, ps_len);
        ps_utf8 = SvUTF8(((SVOP*)proto)->op_sv);
    }
    else
	ps = NULL;

a7503 1
	SvFLAGS(const_sv) = (SvFLAGS(const_sv) & ~SVs_PADMY) | SVs_PADTMP;
a7633 1
    S_prune_chain_head(aTHX_ &CvSTART(cv));
a7707 1
            dSP;
a7709 1
            PUSHSTACKi(PERLSI_REQUIRE);
d7719 1
a7719 1
            POPSTACK;
d7804 1
d7806 4
d7840 1
a7840 5
    cv = newXS_len_flags(name, len,
			 sv && SvTYPE(sv) == SVt_PVAV
			     ? const_av_xsub
			     : const_sv_xsub,
			 file ? file : "", "",
a7867 1
    bool interleave = FALSE;
d7897 1
a7897 3
                interleave = TRUE;
                ENTER;
                SAVEFREESV(cv);
a7931 1
    if (interleave) LEAVE;
a7938 1
    GV *cvgv;
d7945 1
a7945 6
    if (SvFAKE(gv)) {
	cvgv = gv_fetchsv((SV *)gv, GV_ADDMULTI, SVt_PVCV);
	SvFAKE_off(cvgv);
    }
    else cvgv = gv;
    CvGV_set(cv, cvgv);
a8025 1
    S_prune_chain_head(aTHX_ &CvSTART(cv));
a8077 1
    case OP_PADHV:
a8082 1
    case OP_RV2HV:
a8208 56
static void
S_io_hints(pTHX_ OP *o)
{
    HV * const table =
	PL_hints & HINT_LOCALIZE_HH ? GvHV(PL_hintgv) : NULL;;
    if (table) {
	SV **svp = hv_fetchs(table, "open_IN", FALSE);
	if (svp && *svp) {
	    STRLEN len = 0;
	    const char *d = SvPV_const(*svp, len);
	    const I32 mode = mode_from_discipline(d, len);
	    if (mode & O_BINARY)
		o->op_private |= OPpOPEN_IN_RAW;
	    else if (mode & O_TEXT)
		o->op_private |= OPpOPEN_IN_CRLF;
	}

	svp = hv_fetchs(table, "open_OUT", FALSE);
	if (svp && *svp) {
	    STRLEN len = 0;
	    const char *d = SvPV_const(*svp, len);
	    const I32 mode = mode_from_discipline(d, len);
	    if (mode & O_BINARY)
		o->op_private |= OPpOPEN_OUT_RAW;
	    else if (mode & O_TEXT)
		o->op_private |= OPpOPEN_OUT_CRLF;
	}
    }
}

OP *
Perl_ck_backtick(pTHX_ OP *o)
{
    GV *gv;
    OP *newop = NULL;
    PERL_ARGS_ASSERT_CK_BACKTICK;
    /* qx and `` have a null pushmark; CORE::readpipe has only one kid. */
    if (o->op_flags & OPf_KIDS && cUNOPo->op_first->op_sibling
     && (gv = gv_override("readpipe",8))) {
	newop = S_new_entersubop(aTHX_ gv, cUNOPo->op_first->op_sibling);
	cUNOPo->op_first->op_sibling = NULL;
    }
    else if (!(o->op_flags & OPf_KIDS))
	newop = newUNOP(OP_BACKTICK, 0,	newDEFSVOP());
    if (newop) {
#ifdef PERL_MAD
	op_getmad(o,newop,'O');
#else
	op_free(o);
#endif
	return newop;
    }
    S_io_hints(aTHX_ o);
    return o;
}

a8335 6
	case OP_KVASLICE:
	    Perl_croak(aTHX_ "delete argument is index/value array slice,"
			     " use array slice");
	case OP_KVHSLICE:
	    Perl_croak(aTHX_ "delete argument is key/value hash slice, use"
			     " hash slice");
d8337 2
a8338 2
	    Perl_croak(aTHX_ "delete argument is not a HASH or ARRAY "
			     "element or slice");
d8348 11
a8394 1
	assert(kid);
d8396 5
a8400 1
	if (kid->op_type == OP_LINESEQ || kid->op_type == OP_STUB) {
d8458 17
d8505 2
a8506 2
		Perl_croak(aTHX_
			  "exists argument is not a subroutine name");
d8512 2
a8513 2
	    Perl_croak(aTHX_ "exists argument is not a HASH or ARRAY "
			     "element or a subroutine");
a8563 1
	if (SvTYPE(kidsv) == SVt_PVAV) return o;
a8611 1
	    assert (sizeof(PADOP) <= sizeof(SVOP));
d8644 1
a8644 1
	 && !kid->op_folded) {
d8746 1
a8746 1
		if (type != OP_DELETE) scalar(kid);
d8788 1
a8788 8
		else {
		    scalar(kid);
		    /* diag_listed_as: push on reference is experimental */
		    Perl_ck_warner_d(aTHX_
				     packWARN(WARN_EXPERIMENTAL__AUTODEREF),
				    "%s on reference is experimental",
				     PL_op_desc[type]);
		}
d8926 1
a8926 1
				targ = pad_alloc(OP_RV2GV, SVf_READONLY);
d8928 1
a8930 2
				else
				    sv_setpvs(namesv, "");
d8995 1
d9003 3
a9005 1
    if (!(o->op_flags & OPf_SPECIAL) && (gv = gv_override("glob", 4)))
d9007 6
d9027 5
a9031 1
	o = S_new_entersubop(aTHX_ gv, o);
d9122 1
a9122 8
	    SV *sv = kSVOP->op_sv;
	    if ((!SvPOK(sv) || SvNIOKp(sv)) && SvOK(sv) && !SvROK(sv)) {
		sv = newSV(0);
		sv_copypv(sv, kSVOP->op_sv);
		SvREFCNT_dec_NN(kSVOP->op_sv);
		kSVOP->op_sv = sv;
	    }
	    if (SvOK(sv)) fbm_compile(sv, 0);
d9222 1
a9222 1
	 && !kid->op_folded) {
d9306 1
a9306 1
	     (OP_TYPE_IS_OR_WAS(kkid, OP_LIST) &&
d9369 1
a9369 1
	    if (!SvIsCOW_shared_hash(sv)) {
d9399 1
d9403 35
a9437 1
    S_io_hints(aTHX_ o);
d9479 1
a9479 1
    GV* gv;
d9514 1
a9514 1
    if (!(o->op_flags & OPf_SPECIAL) /* Wasn't written as CORE::require */
d9516 8
a9523 1
     && (gv = gv_override("require", 7))) {
d9535 5
a9539 1
	newop = S_new_entersubop(aTHX_ gv, kid);
d9625 1
a9625 4
    OP *kid;
    HV * const hinthv =
	PL_hints & HINT_LOCALIZE_HH ? GvHV(PL_hintgv) : NULL;
    U8 stacked;
d9643 1
a9643 2

    if ((stacked = o->op_flags & OPf_STACKED)) {	/* may have been cleared */
a9645 2
        /* if the first arg is a code block, process it and mark sort as
         * OPf_SPECIAL */
d9662 2
a9663 6
    for (kid = firstkid; kid; kid = kid->op_sibling) {
	/* provide list context for arguments */
	list(kid);
	if (stacked)
	    op_lvalue(kid, OP_GREPSTART);
    }
a9667 10
/* for sort { X } ..., where X is one of
 *   $a <=> $b, $b <= $a, $a cmp $b, $b cmp $a
 * elide the second child of the sort (the one containing X),
 * and set these flags as appropriate
	OPpSORT_NUMERIC;
	OPpSORT_INTEGER;
	OPpSORT_DESCEND;
 * Also, check and warn on lexical $a, $b.
 */

d9681 4
a9822 1
    {
a9823 2
	o->op_private |= OPpSPLIT_IMPLIM;
    }
a10044 1
    proto = S_strip_spaces(aTHX_ proto, &proto_len);
d10089 1
a10089 1
		    bad_type_gv(arg,
d10091 1
a10091 1
			    namegv, 0, o3);
d10176 1
a10176 1
			    bad_type_gv(arg, Perl_form(aTHX_ "one of %.*s",
d10178 1
a10178 1
				    namegv, 0, o3);
d10186 1
a10186 1
			    bad_type_gv(arg, "symbol", namegv, 0, o3);
d10192 1
a10192 1
			    bad_type_gv(arg, "subroutine entry", namegv, 0,
d10208 1
a10208 1
			    bad_type_gv(arg, "scalar", namegv, 0, o3);
d10216 1
a10216 1
			    bad_type_gv(arg, "array", namegv, 0, o3);
d10223 1
a10223 1
			    bad_type_gv(arg, "hash", namegv, 0, o3);
d10347 1
a10347 1
	NOT_REACHED;
d10457 2
a10458 5
for it is supplied in I<ckobj>.  The function should be defined like this:

    STATIC OP * ckfun(pTHX_ OP *op, GV *namegv, SV *ckobj)

It is intended to be called in this manner:
a10562 1
    SV * const sv = cSVOPo->op_sv;
d10565 1
a10565 17
#ifdef PERL_OLD_COPY_ON_WRITE
    if (SvIsCOW(sv)) sv_force_normal(sv);
#elif defined(PERL_NEW_COPY_ON_WRITE)
    /* Since the read-only flag may be used to protect a string buffer, we
       cannot do copy-on-write with existing read-only scalars that are not
       already copy-on-write scalars.  To allow $_ = "hello" to do COW with
       that constant, mark the constant as COWable here, if it is not
       already read-only. */
    if (!SvREADONLY(sv) && !SvIsCOW(sv) && SvCANCOW(sv)) {
	SvIsCOW_on(sv);
	CowREFCNT(sv) = 0;
# ifdef PERL_DEBUG_READONLY_COW
	sv_buf_to_ro(sv);
# endif
    }
#endif
    SvREADONLY_on(sv);
d10580 2
a10581 2
	    (kid->op_private & OPpCONST_BARE) &&
	    !kid->op_folded)
d10657 1
a10657 7
    if (o->op_type == ref_type) {
	/* diag_listed_as: keys on reference is experimental */
	Perl_ck_warner_d(aTHX_ packWARN(WARN_EXPERIMENTAL__AUTODEREF),
			      "%s is experimental", PL_op_desc[ref_type]);
	return o;
    }
    return ck_fun(o);
d10677 5
d10684 6
a10689 1
		    name = S_op_varname(aTHX_ kid);
a10700 1
     /* diag_listed_as: length() used on %s (did you mean "scalar(%s)"?) */
a10703 1
     /* diag_listed_as: length() used on %s (did you mean "scalar(%s)"?) */
a10794 4


/* mechanism for deferring recursion in rpeep() */

d10800 1
a10800 3
        OP **defer = defer_queue[defer_base]; \
        CALL_RPEEP(*defer); \
        S_prune_chain_head(aTHX_ defer); \
d10804 1
a10804 1
    defer_queue[(defer_base + ++defer_ix) % MAX_DEFERRED] = &(o); \
a10806 24
#define IS_AND_OP(o)   (o->op_type == OP_AND)
#define IS_OR_OP(o)    (o->op_type == OP_OR)


STATIC void
S_null_listop_in_list_context(pTHX_ OP *o)
{
    OP *kid;

    PERL_ARGS_ASSERT_NULL_LISTOP_IN_LIST_CONTEXT;

    /* This is an OP_LIST in list context. That means we
     * can ditch the OP_LIST and the OP_PUSHMARK within. */

    kid = cLISTOPo->op_first;
    /* Find the end of the chain of OPs executed within the OP_LIST. */
    while (kid->op_next != o)
        kid = kid->op_next;

    kid->op_next = o->op_next; /* patch list out of exec chain */
    op_null(cUNOPo->op_first); /* NULL the pushmark */
    op_null(o); /* NULL the list */
}

d10817 1
a10817 1
    OP** defer_queue[MAX_DEFERRED]; /* small queue of deferred branches */
d10830 2
a10831 6
	    while (defer_ix >= 0) {
                OP **defer =
                        defer_queue[(defer_base + defer_ix--) % MAX_DEFERRED];
                CALL_RPEEP(*defer);
                S_prune_chain_head(aTHX_ defer);
            }
a10838 38


        /* The following will have the OP_LIST and OP_PUSHMARK
         * patched out later IF the OP_LIST is in list context.
         * So in that case, we can set the this OP's op_next
         * to skip to after the OP_PUSHMARK:
         *   a THIS -> b
         *   d list -> e
         *   b   pushmark -> c
         *   c   whatever -> d
         *   e whatever
         * will eventually become:
         *   a THIS -> c
         *   - ex-list -> -
         *   -   ex-pushmark -> -
         *   c   whatever -> e
         *   e whatever
         */
        {
            OP *sibling;
            OP *other_pushmark;
            if (OP_TYPE_IS(o->op_next, OP_PUSHMARK)
                && (sibling = o->op_sibling)
                && sibling->op_type == OP_LIST
                /* This KIDS check is likely superfluous since OP_LIST
                 * would otherwise be an OP_STUB. */
                && sibling->op_flags & OPf_KIDS
                && (sibling->op_flags & OPf_WANT) == OPf_WANT_LIST
                && (other_pushmark = cLISTOPx(sibling)->op_first)
                /* Pointer equality also effectively checks that it's a
                 * pushmark. */
                && other_pushmark == o->op_next)
            {
                o->op_next = other_pushmark->op_next;
                null_listop_in_list_context(sibling);
            }
        }

a10845 104
	    /* Optimise a "return ..." at the end of a sub to just be "...".
	     * This saves 2 ops. Before:
	     * 1  <;> nextstate(main 1 -e:1) v ->2
	     * 4  <@@> return K ->5
	     * 2    <0> pushmark s ->3
	     * -    <1> ex-rv2sv sK/1 ->4
	     * 3      <#> gvsv[*cat] s ->4
	     *
	     * After:
	     * -  <@@> return K ->-
	     * -    <0> pushmark s ->2
	     * -    <1> ex-rv2sv sK/1 ->-
	     * 2      <$> gvsv(*cat) s ->3
	     */
	    {
		OP *next = o->op_next;
		OP *sibling = o->op_sibling;
		if (   OP_TYPE_IS(next, OP_PUSHMARK)
		    && OP_TYPE_IS(sibling, OP_RETURN)
		    && OP_TYPE_IS(sibling->op_next, OP_LINESEQ)
		    && OP_TYPE_IS(sibling->op_next->op_next, OP_LEAVESUB)
		    && cUNOPx(sibling)->op_first == next
		    && next->op_sibling && next->op_sibling->op_next
		    && next->op_next
		) {
		    /* Look through the PUSHMARK's siblings for one that
		     * points to the RETURN */
		    OP *top = next->op_sibling;
		    while (top && top->op_next) {
			if (top->op_next == sibling) {
			    top->op_next = sibling->op_next;
			    o->op_next = next->op_next;
			    break;
			}
			top = top->op_sibling;
		    }
		}
	    }

	    /* Optimise 'my $x; my $y;' into 'my ($x, $y);'
             *
	     * This latter form is then suitable for conversion into padrange
	     * later on. Convert:
	     *
	     *   nextstate1 -> padop1 -> nextstate2 -> padop2 -> nextstate3
	     *
	     * into:
	     *
	     *   nextstate1 ->     listop     -> nextstate3
	     *                 /            \
	     *         pushmark -> padop1 -> padop2
	     */
	    if (o->op_next && (
		    o->op_next->op_type == OP_PADSV
		 || o->op_next->op_type == OP_PADAV
		 || o->op_next->op_type == OP_PADHV
		)
		&& !(o->op_next->op_private & ~OPpLVAL_INTRO)
		&& o->op_next->op_next && o->op_next->op_next->op_type == OP_NEXTSTATE
		&& o->op_next->op_next->op_next && (
		    o->op_next->op_next->op_next->op_type == OP_PADSV
		 || o->op_next->op_next->op_next->op_type == OP_PADAV
		 || o->op_next->op_next->op_next->op_type == OP_PADHV
		)
		&& !(o->op_next->op_next->op_next->op_private & ~OPpLVAL_INTRO)
		&& o->op_next->op_next->op_next->op_next && o->op_next->op_next->op_next->op_next->op_type == OP_NEXTSTATE
		&& (!CopLABEL((COP*)o)) /* Don't mess with labels */
		&& (!CopLABEL((COP*)o->op_next->op_next)) /* ... */
	    ) {
		OP *first;
		OP *last;
		OP *newop;

		first = o->op_next;
		last = o->op_next->op_next->op_next;

		newop = newLISTOP(OP_LIST, 0, first, last);
		newop->op_flags |= OPf_PARENS;
		newop->op_flags = (newop->op_flags & ~OPf_WANT) | OPf_WANT_VOID;

		/* Kill nextstate2 between padop1/padop2 */
		op_free(first->op_next);

		first->op_next = last;                /* padop2 */
		first->op_sibling = last;             /* ... */
		o->op_next = cUNOPx(newop)->op_first; /* pushmark */
		o->op_next->op_next = first;          /* padop1 */
		o->op_next->op_sibling = first;       /* ... */
		newop->op_next = last->op_next;       /* nextstate3 */
		newop->op_sibling = last->op_sibling;
		last->op_next = newop;                /* listop */
		last->op_sibling = NULL;
		o->op_sibling = newop;                /* ... */

		newop->op_flags = (newop->op_flags & ~OPf_WANT) | OPf_WANT_VOID;

		/* Ensure pushmark has this flag if padops do */
		if (first->op_flags & OPf_MOD && last->op_flags & OPf_MOD) {
		    o->op_next->op_flags |= OPf_MOD;
		}

		break;
	    }

d10934 1
a10934 1
	    if (oldop) {
d11025 1
a11025 1
                /* let $a[N] potentially be optimised into AELEMFAST_LEX
d11097 1
a11097 1
                if (OP_TYPE_IS_OR_WAS(followop, OP_LIST)
d11120 1
d11122 1
a11122 7
                       /* Do not assume pad offsets for $c and $d are con-
                          tiguous in
                            my ($a,$b,$c);
                            my ($d,$e,$f);
                        */
                        if (  oldoldop->op_targ + old_count == base
                           && old_count < OPpPADRANGE_COUNTMASK - count) {
a11142 1
                            && !(p->op_private & ~OPpLVAL_INTRO)
d11193 1
a11193 1
		    (i = SvIV(((SVOP*)pop)->op_sv)) >= -128 && i <= 127)
a11268 15

	    /* if we're an OR and our next is a AND in void context, we'll
	       follow it's op_other on short circuit, same for reverse.
	       We can't do this with OP_DOR since if it's true, its return
	       value is the underlying value which must be evaluated
	       by the next op */
	    if (o->op_next &&
	        (
		    (IS_AND_OP(o) && IS_OR_OP(o->op_next))
	         || (IS_OR_OP(o) && IS_AND_OP(o->op_next))
	        )
	        && (o->op_next->op_flags & OPf_WANT) == OPf_WANT_VOID
	    ) {
	        o->op_next = ((LOGOP*)o->op_next)->op_other;
	    }
a11343 5
        case OP_ENTERTRY:
	    assert(cLOGOPo->op_other->op_type == OP_LEAVETRY);
	    DEFER(cLOGOPo->op_other);
	    break;

d11356 6
a11361 22
	    if (o->op_flags & OPf_SPECIAL) {
                /* first arg is a code block */
		OP * const nullop = cLISTOP->op_first->op_sibling;
                OP * kid          = cUNOPx(nullop)->op_first;

                assert(nullop->op_type == OP_NULL);
		assert(kid->op_type == OP_SCOPE
		 || (kid->op_type == OP_NULL && kid->op_targ == OP_LEAVE));
                /* since OP_SORT doesn't have a handy op_other-style
                 * field that can point directly to the start of the code
                 * block, store it in the otherwise-unused op_next field
                 * of the top-level OP_NULL. This will be quicker at
                 * run-time, and it will also allow us to remove leading
                 * OP_NULLs by just messing with op_nexts without
                 * altering the basic op_first/op_sibling layout. */
                kid = kLISTOP->op_first;
                assert(
                      (kid->op_type == OP_NULL && kid->op_targ == OP_NEXTSTATE)
                    || kid->op_type == OP_STUB
                    || kid->op_type == OP_ENTER);
                nullop->op_next = kLISTOP->op_next;
                DEFER(nullop->op_next);
a11512 17
                    /*   sassign
                    *      RIGHT
                    *      substr
                    *         pushmark
                    *         arg1
                    *         arg2
                    *         ...
                    * becomes
                    *
                    *  ex-sassign
                    *     substr
                    *        pushmark
                    *        RIGHT
                    *        arg1
                    *        arg2
                    *        ...
                    */
d11531 1
a11531 1
		XopENTRYCUSTOM(o, xop_peep);
d11538 2
a11539 10
        /* did we just null the current op? If so, re-process it to handle
         * eliding "empty" ops from the chain */
        if (o->op_type == OP_NULL && oldop && oldop->op_next == o) {
            o->op_opt = 0;
            o = oldop;
        }
        else {
            oldoldop = oldop;
            oldop = o;
        }
d11554 1
a11554 1
Return the XOP structure for a given custom op.  This macro should be
a11555 3
This macro does call a function.  Prior
to 5.19.6, this was implemented as a
function.
d11560 2
a11561 2
XOPRETANY
Perl_custom_op_get_field(pTHX_ const OP *o, const xop_flags_enum field)
d11569 1
a11569 1
    PERL_ARGS_ASSERT_CUSTOM_OP_GET_FIELD;
d11601 1
d11603 5
a11607 52
    else {
	if (!he)
	    xop = (XOP *)&xop_null;
	else
	    xop = INT2PTR(XOP *, SvIV(HeVAL(he)));
    }
    {
	XOPRETANY any;
	if(field == XOPe_xop_ptr) {
	    any.xop_ptr = xop;
	} else {
	    const U32 flags = XopFLAGS(xop);
	    if(flags & field) {
		switch(field) {
		case XOPe_xop_name:
		    any.xop_name = xop->xop_name;
		    break;
		case XOPe_xop_desc:
		    any.xop_desc = xop->xop_desc;
		    break;
		case XOPe_xop_class:
		    any.xop_class = xop->xop_class;
		    break;
		case XOPe_xop_peep:
		    any.xop_peep = xop->xop_peep;
		    break;
		default:
		    NOT_REACHED;
		    break;
		}
	    } else {
		switch(field) {
		case XOPe_xop_name:
		    any.xop_name = XOPd_xop_name;
		    break;
		case XOPe_xop_desc:
		    any.xop_desc = XOPd_xop_desc;
		    break;
		case XOPe_xop_class:
		    any.xop_class = XOPd_xop_class;
		    break;
		case XOPe_xop_peep:
		    any.xop_peep = XOPd_xop_peep;
		    break;
		default:
		    NOT_REACHED;
		    break;
		}
	    }
	}
	return any;
    }
d11612 1
a11612 1
Register a custom op.  See L<perlguts/"Custom Operators">.
d11641 1
a11641 1
by C<keyword()>.  It must not be equal to 0.
d11658 1
a11658 1
    assert (code);
a11874 12
The function should be defined like this:

    static OP *new_checker(pTHX_ OP *op) { ... }

It is intended to be called in this manner:

    new_checker(aTHX_ op)

I<old_checker_p> should be defined like this:

    static Perl_check_t old_checker_p;

d11928 8
a11935 1
    PERL_UNUSED_ARG(items);
a11941 25
}

static void
const_av_xsub(pTHX_ CV* cv)
{
    dVAR;
    dXSARGS;
    AV * const av = MUTABLE_AV(XSANY.any_ptr);
    SP -= items;
    assert(av);
#ifndef DEBUGGING
    if (!av) {
	XSRETURN(0);
    }
#endif
    if (SvRMAGICAL(av))
	Perl_croak(aTHX_ "Magical list constants are not supported");
    if (GIMME_V != G_ARRAY) {
	EXTEND(SP, 1);
	ST(0) = sv_2mortal(newSViv((IV)AvFILLp(av)+1));
	XSRETURN(1);
    }
    EXTEND(SP, AvFILLp(av)+1);
    Copy(AvARRAY(av), &ST(0), AvFILLp(av)+1, SV *);
    XSRETURN(AvFILLp(av)+1);
@


1.1.1.17
log
@Import perl-5.20.2
@
text
@d4808 1
a4808 4
    /* If we have a syntax error causing tokens to be popped and the parser
       to see PMFUNC '(' expr ')' with no commas in it; e.g., s/${<>{})//,
       then expr will not be of type OP_LIST, there being no repl.  */
    if ((is_trans || o->op_type == OP_SUBST) && expr->op_type == OP_LIST) {
d4933 2
a4934 11
		 * regex was parsed, except maybe op targets for \Q etc.
		 * If there were any op targets, though, they should have
		 * been stolen by constant folding.
		 */
#ifdef DEBUGGING
		PADOFFSET i = 0;
		assert(PadnamelistMAXNAMED(PL_comppad_name) == 0);
		while (++i <= AvFILLp(PL_comppad)) {
		    assert(!PL_curpad[i]);
		}
#endif
a5047 1
	    CvLVALUE_on(PL_compcv);
d11254 2
d11261 6
d12009 1
a12009 3
                      (kid->op_type == OP_NULL
                      && (  kid->op_targ == OP_NEXTSTATE
                         || kid->op_targ == OP_DBSTATE  ))
@


