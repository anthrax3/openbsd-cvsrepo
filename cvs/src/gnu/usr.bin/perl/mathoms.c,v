head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.2
	OPENBSD_6_2_BASE:1.2
	PERL_5_24_2:1.1.1.7
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.6.0.10
	OPENBSD_6_0_BASE:1.1.1.6
	OPENBSD_5_9:1.1.1.6.0.4
	OPENBSD_5_9_BASE:1.1.1.6
	OPENBSD_5_8:1.1.1.6.0.6
	OPENBSD_5_8_BASE:1.1.1.6
	PERL_5_20_2:1.1.1.6
	OPENBSD_5_7:1.1.1.6.0.2
	OPENBSD_5_7_BASE:1.1.1.6
	PERL_5_20_1:1.1.1.6
	OPENBSD_5_6:1.1.1.5.0.4
	OPENBSD_5_6_BASE:1.1.1.5
	PERL_5_18_2:1.1.1.5
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.4.0.6
	OPENBSD_5_5_BASE:1.1.1.4
	OPENBSD_5_4:1.1.1.4.0.2
	OPENBSD_5_4_BASE:1.1.1.4
	PERL_5_16_3:1.1.1.4
	OPENBSD_5_3:1.1.1.3.0.10
	OPENBSD_5_3_BASE:1.1.1.3
	OPENBSD_5_2:1.1.1.3.0.8
	OPENBSD_5_2_BASE:1.1.1.3
	OPENBSD_5_1_BASE:1.1.1.3
	OPENBSD_5_1:1.1.1.3.0.6
	OPENBSD_5_0:1.1.1.3.0.4
	OPENBSD_5_0_BASE:1.1.1.3
	OPENBSD_4_9:1.1.1.3.0.2
	OPENBSD_4_9_BASE:1.1.1.3
	PERL_5_12_2:1.1.1.3
	OPENBSD_4_8:1.1.1.2.0.4
	OPENBSD_4_8_BASE:1.1.1.2
	OPENBSD_4_7:1.1.1.2.0.2
	OPENBSD_4_7_BASE:1.1.1.2
	PERL_5_10_1:1.1.1.2
	OPENBSD_4_6:1.1.1.1.0.6
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.2
	OPENBSD_4_5_BASE:1.1.1.1
	PERL_5_10_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.2
date	2017.02.05.00.31.52;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2008.09.29.17.18.06;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.09.29.17.18.06;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2009.10.12.18.10.34;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2010.09.24.14.48.34;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.03.25.20.06.26;	author sthen;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.03.24.14.58.45;	author afresh1;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.11.17.20.52.37;	author afresh1;	state Exp;
branches;
next	1.1.1.7;
commitid	B31cAbBIXiCqnL97;

1.1.1.7
date	2017.08.14.13.45.26;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*    mathoms.c
 *
 *    Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010,
 *    2011, 2012 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 *  Anything that Hobbits had no immediate use for, but were unwilling to
 *  throw away, they called a mathom.  Their dwellings were apt to become
 *  rather crowded with mathoms, and many of the presents that passed from
 *  hand to hand were of that sort.
 *
 *     [p.5 of _The Lord of the Rings_: "Prologue"]
 */



/* 
 * This file contains mathoms, various binary artifacts from previous
 * versions of Perl.  For binary or source compatibility reasons, though,
 * we cannot completely remove them from the core code.  
 *
 * REMEMBER to update makedef.pl when adding a function to mathoms.c whose
 * name doesn't begin with "Perl_".
 *
 * SMP - Oct. 24, 2005
 *
 * The compilation of this file can be suppressed; see INSTALL
 *
=head1 Obsolete backwards compatibility functions
Some of these are also deprecated.  You can exclude these from
your compiled Perl by adding this option to Configure:
C<-Accflags='-DNO_MATHOMS'>

=cut

 */


#include "EXTERN.h"
#define PERL_IN_MATHOMS_C
#include "perl.h"

#ifdef NO_MATHOMS
/* ..." warning: ISO C forbids an empty source file"
   So make sure we have something in here by processing the headers anyway.
 */
#else

/* Not all of these have prototypes elsewhere, so do this to get
 * non-mangled names.
 */
START_EXTERN_C

PERL_CALLCONV OP * Perl_ref(pTHX_ OP *o, I32 type);
PERL_CALLCONV void Perl_sv_unref(pTHX_ SV *sv);
PERL_CALLCONV void Perl_sv_taint(pTHX_ SV *sv);
PERL_CALLCONV IV Perl_sv_2iv(pTHX_ SV *sv);
PERL_CALLCONV UV Perl_sv_2uv(pTHX_ SV *sv);
PERL_CALLCONV NV Perl_sv_2nv(pTHX_ SV *sv);
PERL_CALLCONV char * Perl_sv_2pv(pTHX_ SV *sv, STRLEN *lp);
PERL_CALLCONV char * Perl_sv_2pv_nolen(pTHX_ SV *sv);
PERL_CALLCONV char * Perl_sv_2pvbyte_nolen(pTHX_ SV *sv);
PERL_CALLCONV char * Perl_sv_2pvutf8_nolen(pTHX_ SV *sv);
PERL_CALLCONV void Perl_sv_force_normal(pTHX_ SV *sv);
PERL_CALLCONV void Perl_sv_setsv(pTHX_ SV *dstr, SV *sstr);
PERL_CALLCONV void Perl_sv_catpvn(pTHX_ SV *dsv, const char* sstr, STRLEN slen);
PERL_CALLCONV void Perl_sv_catpvn_mg(pTHX_ SV *sv, const char *ptr, STRLEN len);
PERL_CALLCONV void Perl_sv_catsv(pTHX_ SV *dstr, SV *sstr);
PERL_CALLCONV void Perl_sv_catsv_mg(pTHX_ SV *dsv, SV *ssv);
PERL_CALLCONV char * Perl_sv_pv(pTHX_ SV *sv);
PERL_CALLCONV char * Perl_sv_pvn_force(pTHX_ SV *sv, STRLEN *lp);
PERL_CALLCONV char * Perl_sv_pvbyte(pTHX_ SV *sv);
PERL_CALLCONV char * Perl_sv_pvutf8(pTHX_ SV *sv);
PERL_CALLCONV STRLEN Perl_sv_utf8_upgrade(pTHX_ SV *sv);
PERL_CALLCONV NV Perl_huge(void);
PERL_CALLCONV void Perl_gv_fullname3(pTHX_ SV *sv, const GV *gv, const char *prefix);
PERL_CALLCONV void Perl_gv_efullname3(pTHX_ SV *sv, const GV *gv, const char *prefix);
PERL_CALLCONV GV * Perl_gv_fetchmethod(pTHX_ HV *stash, const char *name);
PERL_CALLCONV HE * Perl_hv_iternext(pTHX_ HV *hv);
PERL_CALLCONV void Perl_hv_magic(pTHX_ HV *hv, GV *gv, int how);
PERL_CALLCONV bool Perl_do_open(pTHX_ GV *gv, const char *name, I32 len, int as_raw, int rawmode, int rawperm, PerlIO *supplied_fp);
PERL_CALLCONV bool Perl_do_aexec(pTHX_ SV *really, SV **mark, SV **sp);
PERL_CALLCONV U8 * Perl_uvuni_to_utf8(pTHX_ U8 *d, UV uv);
PERL_CALLCONV bool Perl_is_utf8_string_loc(pTHX_ const U8 *s, STRLEN len, const U8 **ep);
PERL_CALLCONV void Perl_sv_nolocking(pTHX_ SV *sv);
PERL_CALLCONV void Perl_sv_usepvn_mg(pTHX_ SV *sv, char *ptr, STRLEN len);
PERL_CALLCONV void Perl_sv_usepvn(pTHX_ SV *sv, char *ptr, STRLEN len);
PERL_CALLCONV int Perl_fprintf_nocontext(PerlIO *stream, const char *format, ...);
PERL_CALLCONV int Perl_printf_nocontext(const char *format, ...);
PERL_CALLCONV int Perl_magic_setglob(pTHX_ SV* sv, MAGIC* mg);
PERL_CALLCONV AV * Perl_newAV(pTHX);
PERL_CALLCONV HV * Perl_newHV(pTHX);
PERL_CALLCONV IO * Perl_newIO(pTHX);
PERL_CALLCONV I32 Perl_my_stat(pTHX);
PERL_CALLCONV I32 Perl_my_lstat(pTHX);
PERL_CALLCONV I32 Perl_sv_eq(pTHX_ SV *sv1, SV *sv2);
PERL_CALLCONV char * Perl_sv_collxfrm(pTHX_ SV *const sv, STRLEN *const nxp);
PERL_CALLCONV bool Perl_sv_2bool(pTHX_ SV *const sv);
PERL_CALLCONV CV * Perl_newSUB(pTHX_ I32 floor, OP* o, OP* proto, OP* block);
PERL_CALLCONV UV Perl_to_utf8_lower(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp);
PERL_CALLCONV UV Perl_to_utf8_title(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp);
PERL_CALLCONV UV Perl_to_utf8_upper(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp);
PERL_CALLCONV UV Perl_to_utf8_fold(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp);
PERL_CALLCONV SV *Perl_sv_mortalcopy(pTHX_ SV *const oldstr);

/* ref() is now a macro using Perl_doref;
 * this version provided for binary compatibility only.
 */
OP *
Perl_ref(pTHX_ OP *o, I32 type)
{
    return doref(o, type, TRUE);
}

/*
=for apidoc sv_unref

Unsets the RV status of the SV, and decrements the reference count of
whatever was being referenced by the RV.  This can almost be thought of
as a reversal of C<newSVrv>.  This is C<sv_unref_flags> with the C<flag>
being zero.  See C<L</SvROK_off>>.

=cut
*/

void
Perl_sv_unref(pTHX_ SV *sv)
{
    PERL_ARGS_ASSERT_SV_UNREF;

    sv_unref_flags(sv, 0);
}

/*
=for apidoc sv_taint

Taint an SV.  Use C<SvTAINTED_on> instead.

=cut
*/

void
Perl_sv_taint(pTHX_ SV *sv)
{
    PERL_ARGS_ASSERT_SV_TAINT;

    sv_magic((sv), NULL, PERL_MAGIC_taint, NULL, 0);
}

/* sv_2iv() is now a macro using Perl_sv_2iv_flags();
 * this function provided for binary compatibility only
 */

IV
Perl_sv_2iv(pTHX_ SV *sv)
{
    PERL_ARGS_ASSERT_SV_2IV;

    return sv_2iv_flags(sv, SV_GMAGIC);
}

/* sv_2uv() is now a macro using Perl_sv_2uv_flags();
 * this function provided for binary compatibility only
 */

UV
Perl_sv_2uv(pTHX_ SV *sv)
{
    PERL_ARGS_ASSERT_SV_2UV;

    return sv_2uv_flags(sv, SV_GMAGIC);
}

/* sv_2nv() is now a macro using Perl_sv_2nv_flags();
 * this function provided for binary compatibility only
 */

NV
Perl_sv_2nv(pTHX_ SV *sv)
{
    return sv_2nv_flags(sv, SV_GMAGIC);
}


/* sv_2pv() is now a macro using Perl_sv_2pv_flags();
 * this function provided for binary compatibility only
 */

char *
Perl_sv_2pv(pTHX_ SV *sv, STRLEN *lp)
{
    PERL_ARGS_ASSERT_SV_2PV;

    return sv_2pv_flags(sv, lp, SV_GMAGIC);
}

/*
=for apidoc sv_2pv_nolen

Like C<sv_2pv()>, but doesn't return the length too.  You should usually
use the macro wrapper C<SvPV_nolen(sv)> instead.

=cut
*/

char *
Perl_sv_2pv_nolen(pTHX_ SV *sv)
{
    PERL_ARGS_ASSERT_SV_2PV_NOLEN;
    return sv_2pv(sv, NULL);
}

/*
=for apidoc sv_2pvbyte_nolen

Return a pointer to the byte-encoded representation of the SV.
May cause the SV to be downgraded from UTF-8 as a side-effect.

Usually accessed via the C<SvPVbyte_nolen> macro.

=cut
*/

char *
Perl_sv_2pvbyte_nolen(pTHX_ SV *sv)
{
    PERL_ARGS_ASSERT_SV_2PVBYTE_NOLEN;

    return sv_2pvbyte(sv, NULL);
}

/*
=for apidoc sv_2pvutf8_nolen

Return a pointer to the UTF-8-encoded representation of the SV.
May cause the SV to be upgraded to UTF-8 as a side-effect.

Usually accessed via the C<SvPVutf8_nolen> macro.

=cut
*/

char *
Perl_sv_2pvutf8_nolen(pTHX_ SV *sv)
{
    PERL_ARGS_ASSERT_SV_2PVUTF8_NOLEN;

    return sv_2pvutf8(sv, NULL);
}

/*
=for apidoc sv_force_normal

Undo various types of fakery on an SV: if the PV is a shared string, make
a private copy; if we're a ref, stop refing; if we're a glob, downgrade to
an C<xpvmg>.  See also C<L</sv_force_normal_flags>>.

=cut
*/

void
Perl_sv_force_normal(pTHX_ SV *sv)
{
    PERL_ARGS_ASSERT_SV_FORCE_NORMAL;

    sv_force_normal_flags(sv, 0);
}

/* sv_setsv() is now a macro using Perl_sv_setsv_flags();
 * this function provided for binary compatibility only
 */

void
Perl_sv_setsv(pTHX_ SV *dstr, SV *sstr)
{
    PERL_ARGS_ASSERT_SV_SETSV;

    sv_setsv_flags(dstr, sstr, SV_GMAGIC);
}

/* sv_catpvn() is now a macro using Perl_sv_catpvn_flags();
 * this function provided for binary compatibility only
 */

void
Perl_sv_catpvn(pTHX_ SV *dsv, const char* sstr, STRLEN slen)
{
    PERL_ARGS_ASSERT_SV_CATPVN;

    sv_catpvn_flags(dsv, sstr, slen, SV_GMAGIC);
}

/*
=for apidoc sv_catpvn_mg

Like C<sv_catpvn>, but also handles 'set' magic.

=cut
*/

void
Perl_sv_catpvn_mg(pTHX_ SV *sv, const char *ptr, STRLEN len)
{
    PERL_ARGS_ASSERT_SV_CATPVN_MG;

    sv_catpvn_flags(sv,ptr,len,SV_GMAGIC|SV_SMAGIC);
}

/* sv_catsv() is now a macro using Perl_sv_catsv_flags();
 * this function provided for binary compatibility only
 */

void
Perl_sv_catsv(pTHX_ SV *dstr, SV *sstr)
{
    PERL_ARGS_ASSERT_SV_CATSV;

    sv_catsv_flags(dstr, sstr, SV_GMAGIC);
}

/*
=for apidoc sv_catsv_mg

Like C<sv_catsv>, but also handles 'set' magic.

=cut
*/

void
Perl_sv_catsv_mg(pTHX_ SV *dsv, SV *ssv)
{
    PERL_ARGS_ASSERT_SV_CATSV_MG;

    sv_catsv_flags(dsv,ssv,SV_GMAGIC|SV_SMAGIC);
}

/*
=for apidoc sv_iv

A private implementation of the C<SvIVx> macro for compilers which can't
cope with complex macro expressions.  Always use the macro instead.

=cut
*/

IV
Perl_sv_iv(pTHX_ SV *sv)
{
    PERL_ARGS_ASSERT_SV_IV;

    if (SvIOK(sv)) {
	if (SvIsUV(sv))
	    return (IV)SvUVX(sv);
	return SvIVX(sv);
    }
    return sv_2iv(sv);
}

/*
=for apidoc sv_uv

A private implementation of the C<SvUVx> macro for compilers which can't
cope with complex macro expressions.  Always use the macro instead.

=cut
*/

UV
Perl_sv_uv(pTHX_ SV *sv)
{
    PERL_ARGS_ASSERT_SV_UV;

    if (SvIOK(sv)) {
	if (SvIsUV(sv))
	    return SvUVX(sv);
	return (UV)SvIVX(sv);
    }
    return sv_2uv(sv);
}

/*
=for apidoc sv_nv

A private implementation of the C<SvNVx> macro for compilers which can't
cope with complex macro expressions.  Always use the macro instead.

=cut
*/

NV
Perl_sv_nv(pTHX_ SV *sv)
{
    PERL_ARGS_ASSERT_SV_NV;

    if (SvNOK(sv))
	return SvNVX(sv);
    return sv_2nv(sv);
}

/*
=for apidoc sv_pv

Use the C<SvPV_nolen> macro instead

=for apidoc sv_pvn

A private implementation of the C<SvPV> macro for compilers which can't
cope with complex macro expressions.  Always use the macro instead.

=cut
*/

char *
Perl_sv_pvn(pTHX_ SV *sv, STRLEN *lp)
{
    PERL_ARGS_ASSERT_SV_PVN;

    if (SvPOK(sv)) {
	*lp = SvCUR(sv);
	return SvPVX(sv);
    }
    return sv_2pv(sv, lp);
}


char *
Perl_sv_pvn_nomg(pTHX_ SV *sv, STRLEN *lp)
{
    PERL_ARGS_ASSERT_SV_PVN_NOMG;

    if (SvPOK(sv)) {
	*lp = SvCUR(sv);
	return SvPVX(sv);
    }
    return sv_2pv_flags(sv, lp, 0);
}

/* sv_pv() is now a macro using SvPV_nolen();
 * this function provided for binary compatibility only
 */

char *
Perl_sv_pv(pTHX_ SV *sv)
{
    PERL_ARGS_ASSERT_SV_PV;

    if (SvPOK(sv))
        return SvPVX(sv);

    return sv_2pv(sv, NULL);
}

/* sv_pvn_force() is now a macro using Perl_sv_pvn_force_flags();
 * this function provided for binary compatibility only
 */

char *
Perl_sv_pvn_force(pTHX_ SV *sv, STRLEN *lp)
{
    PERL_ARGS_ASSERT_SV_PVN_FORCE;

    return sv_pvn_force_flags(sv, lp, SV_GMAGIC);
}

/* sv_pvbyte () is now a macro using Perl_sv_2pv_flags();
 * this function provided for binary compatibility only
 */

char *
Perl_sv_pvbyte(pTHX_ SV *sv)
{
    PERL_ARGS_ASSERT_SV_PVBYTE;

    sv_utf8_downgrade(sv, FALSE);
    return sv_pv(sv);
}

/*
=for apidoc sv_pvbyte

Use C<SvPVbyte_nolen> instead.

=for apidoc sv_pvbyten

A private implementation of the C<SvPVbyte> macro for compilers
which can't cope with complex macro expressions.  Always use the macro
instead.

=cut
*/

char *
Perl_sv_pvbyten(pTHX_ SV *sv, STRLEN *lp)
{
    PERL_ARGS_ASSERT_SV_PVBYTEN;

    sv_utf8_downgrade(sv, FALSE);
    return sv_pvn(sv,lp);
}

/* sv_pvutf8 () is now a macro using Perl_sv_2pv_flags();
 * this function provided for binary compatibility only
 */

char *
Perl_sv_pvutf8(pTHX_ SV *sv)
{
    PERL_ARGS_ASSERT_SV_PVUTF8;

    sv_utf8_upgrade(sv);
    return sv_pv(sv);
}

/*
=for apidoc sv_pvutf8

Use the C<SvPVutf8_nolen> macro instead

=for apidoc sv_pvutf8n

A private implementation of the C<SvPVutf8> macro for compilers
which can't cope with complex macro expressions.  Always use the macro
instead.

=cut
*/

char *
Perl_sv_pvutf8n(pTHX_ SV *sv, STRLEN *lp)
{
    PERL_ARGS_ASSERT_SV_PVUTF8N;

    sv_utf8_upgrade(sv);
    return sv_pvn(sv,lp);
}

/* sv_utf8_upgrade() is now a macro using sv_utf8_upgrade_flags();
 * this function provided for binary compatibility only
 */

STRLEN
Perl_sv_utf8_upgrade(pTHX_ SV *sv)
{
    PERL_ARGS_ASSERT_SV_UTF8_UPGRADE;

    return sv_utf8_upgrade_flags(sv, SV_GMAGIC);
}

int
Perl_fprintf_nocontext(PerlIO *stream, const char *format, ...)
{
    int ret = 0;
    va_list(arglist);

    /* Easier to special case this here than in embed.pl. (Look at what it
       generates for proto.h) */
#ifdef PERL_IMPLICIT_CONTEXT
    PERL_ARGS_ASSERT_FPRINTF_NOCONTEXT;
#endif

    va_start(arglist, format);
    ret = PerlIO_vprintf(stream, format, arglist);
    va_end(arglist);
    return ret;
}

int
Perl_printf_nocontext(const char *format, ...)
{
    dTHX;
    va_list(arglist);
    int ret = 0;

#ifdef PERL_IMPLICIT_CONTEXT
    PERL_ARGS_ASSERT_PRINTF_NOCONTEXT;
#endif

    va_start(arglist, format);
    ret = PerlIO_vprintf(PerlIO_stdout(), format, arglist);
    va_end(arglist);
    return ret;
}

#if defined(HUGE_VAL) || (defined(USE_LONG_DOUBLE) && defined(HUGE_VALL))
/*
 * This hack is to force load of "huge" support from libm.a
 * So it is in perl for (say) POSIX to use.
 * Needed for SunOS with Sun's 'acc' for example.
 */
NV
Perl_huge(void)
{
#  if defined(USE_LONG_DOUBLE) && defined(HUGE_VALL)
    return HUGE_VALL;
#  else
    return HUGE_VAL;
#  endif
}
#endif

/* compatibility with versions <= 5.003. */
void
Perl_gv_fullname(pTHX_ SV *sv, const GV *gv)
{
    PERL_ARGS_ASSERT_GV_FULLNAME;

    gv_fullname3(sv, gv, sv == (const SV*)gv ? "*" : "");
}

/* compatibility with versions <= 5.003. */
void
Perl_gv_efullname(pTHX_ SV *sv, const GV *gv)
{
    PERL_ARGS_ASSERT_GV_EFULLNAME;

    gv_efullname3(sv, gv, sv == (const SV*)gv ? "*" : "");
}

void
Perl_gv_fullname3(pTHX_ SV *sv, const GV *gv, const char *prefix)
{
    PERL_ARGS_ASSERT_GV_FULLNAME3;

    gv_fullname4(sv, gv, prefix, TRUE);
}

void
Perl_gv_efullname3(pTHX_ SV *sv, const GV *gv, const char *prefix)
{
    PERL_ARGS_ASSERT_GV_EFULLNAME3;

    gv_efullname4(sv, gv, prefix, TRUE);
}

/*
=for apidoc gv_fetchmethod

See L</gv_fetchmethod_autoload>.

=cut
*/

GV *
Perl_gv_fetchmethod(pTHX_ HV *stash, const char *name)
{
    PERL_ARGS_ASSERT_GV_FETCHMETHOD;

    return gv_fetchmethod_autoload(stash, name, TRUE);
}

HE *
Perl_hv_iternext(pTHX_ HV *hv)
{
    PERL_ARGS_ASSERT_HV_ITERNEXT;

    return hv_iternext_flags(hv, 0);
}

void
Perl_hv_magic(pTHX_ HV *hv, GV *gv, int how)
{
    PERL_ARGS_ASSERT_HV_MAGIC;

    sv_magic(MUTABLE_SV(hv), MUTABLE_SV(gv), how, NULL, 0);
}

bool
Perl_do_open(pTHX_ GV *gv, const char *name, I32 len, int as_raw,
	     int rawmode, int rawperm, PerlIO *supplied_fp)
{
    PERL_ARGS_ASSERT_DO_OPEN;

    return do_openn(gv, name, len, as_raw, rawmode, rawperm,
		    supplied_fp, (SV **) NULL, 0);
}

bool
Perl_do_open9(pTHX_ GV *gv, const char *name, I32 len, int
as_raw,
              int rawmode, int rawperm, PerlIO *supplied_fp, SV *svs,
              I32 num_svs)
{
    PERL_ARGS_ASSERT_DO_OPEN9;

    PERL_UNUSED_ARG(num_svs);
    return do_openn(gv, name, len, as_raw, rawmode, rawperm,
                    supplied_fp, &svs, 1);
}

int
Perl_do_binmode(pTHX_ PerlIO *fp, int iotype, int mode)
{
 /* The old body of this is now in non-LAYER part of perlio.c
  * This is a stub for any XS code which might have been calling it.
  */
 const char *name = ":raw";

 PERL_ARGS_ASSERT_DO_BINMODE;

#ifdef PERLIO_USING_CRLF
 if (!(mode & O_BINARY))
     name = ":crlf";
#endif
 return PerlIO_binmode(aTHX_ fp, iotype, mode, name);
}

#ifndef OS2
bool
Perl_do_aexec(pTHX_ SV *really, SV **mark, SV **sp)
{
    PERL_ARGS_ASSERT_DO_AEXEC;

    return do_aexec5(really, mark, sp, 0, 0);
}
#endif

/* Backwards compatibility. */
int
Perl_init_i18nl14n(pTHX_ int printwarn)
{
    return init_i18nl10n(printwarn);
}

bool
Perl_is_utf8_string_loc(pTHX_ const U8 *s, STRLEN len, const U8 **ep)
{
    PERL_ARGS_ASSERT_IS_UTF8_STRING_LOC;
    PERL_UNUSED_CONTEXT;

    return is_utf8_string_loclen(s, len, ep, 0);
}

/*
=for apidoc sv_nolocking

Dummy routine which "locks" an SV when there is no locking module present.
Exists to avoid test for a C<NULL> function pointer and because it could
potentially warn under some level of strict-ness.

"Superseded" by C<sv_nosharing()>.

=cut
*/

void
Perl_sv_nolocking(pTHX_ SV *sv)
{
    PERL_UNUSED_CONTEXT;
    PERL_UNUSED_ARG(sv);
}


/*
=for apidoc sv_nounlocking

Dummy routine which "unlocks" an SV when there is no locking module present.
Exists to avoid test for a C<NULL> function pointer and because it could
potentially warn under some level of strict-ness.

"Superseded" by C<sv_nosharing()>.

=cut
*/

void
Perl_sv_nounlocking(pTHX_ SV *sv)
{
    PERL_UNUSED_CONTEXT;
    PERL_UNUSED_ARG(sv);
}

void
Perl_save_long(pTHX_ long int *longp)
{
    PERL_ARGS_ASSERT_SAVE_LONG;

    SSCHECK(3);
    SSPUSHLONG(*longp);
    SSPUSHPTR(longp);
    SSPUSHUV(SAVEt_LONG);
}

void
Perl_save_iv(pTHX_ IV *ivp)
{
    PERL_ARGS_ASSERT_SAVE_IV;

    SSCHECK(3);
    SSPUSHIV(*ivp);
    SSPUSHPTR(ivp);
    SSPUSHUV(SAVEt_IV);
}

void
Perl_save_nogv(pTHX_ GV *gv)
{
    PERL_ARGS_ASSERT_SAVE_NOGV;

    SSCHECK(2);
    SSPUSHPTR(gv);
    SSPUSHUV(SAVEt_NSTAB);
}

void
Perl_save_list(pTHX_ SV **sarg, I32 maxsarg)
{
    I32 i;

    PERL_ARGS_ASSERT_SAVE_LIST;

    for (i = 1; i <= maxsarg; i++) {
	SV *sv;
	SvGETMAGIC(sarg[i]);
	sv = newSV(0);
	sv_setsv_nomg(sv,sarg[i]);
	SSCHECK(3);
	SSPUSHPTR(sarg[i]);		/* remember the pointer */
	SSPUSHPTR(sv);			/* remember the value */
	SSPUSHUV(SAVEt_ITEM);
    }
}

/*
=for apidoc sv_usepvn_mg

Like C<sv_usepvn>, but also handles 'set' magic.

=cut
*/

void
Perl_sv_usepvn_mg(pTHX_ SV *sv, char *ptr, STRLEN len)
{
    PERL_ARGS_ASSERT_SV_USEPVN_MG;

    sv_usepvn_flags(sv,ptr,len, SV_SMAGIC);
}

/*
=for apidoc sv_usepvn

Tells an SV to use C<ptr> to find its string value.  Implemented by
calling C<sv_usepvn_flags> with C<flags> of 0, hence does not handle 'set'
magic.  See C<L</sv_usepvn_flags>>.

=cut
*/

void
Perl_sv_usepvn(pTHX_ SV *sv, char *ptr, STRLEN len)
{
    PERL_ARGS_ASSERT_SV_USEPVN;

    sv_usepvn_flags(sv,ptr,len, 0);
}

/*
=for apidoc unpack_str

The engine implementing C<unpack()> Perl function.  Note: parameters C<strbeg>,
C<new_s> and C<ocnt> are not used.  This call should not be used, use
C<unpackstring> instead.

=cut */

I32
Perl_unpack_str(pTHX_ const char *pat, const char *patend, const char *s,
		const char *strbeg, const char *strend, char **new_s, I32 ocnt,
		U32 flags)
{
    PERL_ARGS_ASSERT_UNPACK_STR;

    PERL_UNUSED_ARG(strbeg);
    PERL_UNUSED_ARG(new_s);
    PERL_UNUSED_ARG(ocnt);

    return unpackstring(pat, patend, s, strend, flags);
}

/*
=for apidoc pack_cat

The engine implementing C<pack()> Perl function.  Note: parameters
C<next_in_list> and C<flags> are not used.  This call should not be used; use
C<packlist> instead.

=cut
*/

void
Perl_pack_cat(pTHX_ SV *cat, const char *pat, const char *patend, SV **beglist, SV **endlist, SV ***next_in_list, U32 flags)
{
    PERL_ARGS_ASSERT_PACK_CAT;

    PERL_UNUSED_ARG(next_in_list);
    PERL_UNUSED_ARG(flags);

    packlist(cat, pat, patend, beglist, endlist);
}

HE *
Perl_hv_store_ent(pTHX_ HV *hv, SV *keysv, SV *val, U32 hash)
{
  return (HE *)hv_common(hv, keysv, NULL, 0, 0, HV_FETCH_ISSTORE, val, hash);
}

bool
Perl_hv_exists_ent(pTHX_ HV *hv, SV *keysv, U32 hash)
{
    PERL_ARGS_ASSERT_HV_EXISTS_ENT;

    return hv_common(hv, keysv, NULL, 0, 0, HV_FETCH_ISEXISTS, 0, hash)
	? TRUE : FALSE;
}

HE *
Perl_hv_fetch_ent(pTHX_ HV *hv, SV *keysv, I32 lval, U32 hash)
{
    PERL_ARGS_ASSERT_HV_FETCH_ENT;

    return (HE *)hv_common(hv, keysv, NULL, 0, 0, 
		     (lval ? HV_FETCH_LVALUE : 0), NULL, hash);
}

SV *
Perl_hv_delete_ent(pTHX_ HV *hv, SV *keysv, I32 flags, U32 hash)
{
    PERL_ARGS_ASSERT_HV_DELETE_ENT;

    return MUTABLE_SV(hv_common(hv, keysv, NULL, 0, 0, flags | HV_DELETE, NULL,
				hash));
}

SV**
Perl_hv_store_flags(pTHX_ HV *hv, const char *key, I32 klen, SV *val, U32 hash,
		    int flags)
{
    return (SV**) hv_common(hv, NULL, key, klen, flags,
			    (HV_FETCH_ISSTORE|HV_FETCH_JUST_SV), val, hash);
}

SV**
Perl_hv_store(pTHX_ HV *hv, const char *key, I32 klen_i32, SV *val, U32 hash)
{
    STRLEN klen;
    int flags;

    if (klen_i32 < 0) {
	klen = -klen_i32;
	flags = HVhek_UTF8;
    } else {
	klen = klen_i32;
	flags = 0;
    }
    return (SV **) hv_common(hv, NULL, key, klen, flags,
			     (HV_FETCH_ISSTORE|HV_FETCH_JUST_SV), val, hash);
}

bool
Perl_hv_exists(pTHX_ HV *hv, const char *key, I32 klen_i32)
{
    STRLEN klen;
    int flags;

    PERL_ARGS_ASSERT_HV_EXISTS;

    if (klen_i32 < 0) {
	klen = -klen_i32;
	flags = HVhek_UTF8;
    } else {
	klen = klen_i32;
	flags = 0;
    }
    return hv_common(hv, NULL, key, klen, flags, HV_FETCH_ISEXISTS, 0, 0)
	? TRUE : FALSE;
}

SV**
Perl_hv_fetch(pTHX_ HV *hv, const char *key, I32 klen_i32, I32 lval)
{
    STRLEN klen;
    int flags;

    PERL_ARGS_ASSERT_HV_FETCH;

    if (klen_i32 < 0) {
	klen = -klen_i32;
	flags = HVhek_UTF8;
    } else {
	klen = klen_i32;
	flags = 0;
    }
    return (SV **) hv_common(hv, NULL, key, klen, flags,
			     lval ? (HV_FETCH_JUST_SV | HV_FETCH_LVALUE)
			     : HV_FETCH_JUST_SV, NULL, 0);
}

SV *
Perl_hv_delete(pTHX_ HV *hv, const char *key, I32 klen_i32, I32 flags)
{
    STRLEN klen;
    int k_flags;

    PERL_ARGS_ASSERT_HV_DELETE;

    if (klen_i32 < 0) {
	klen = -klen_i32;
	k_flags = HVhek_UTF8;
    } else {
	klen = klen_i32;
	k_flags = 0;
    }
    return MUTABLE_SV(hv_common(hv, NULL, key, klen, k_flags, flags | HV_DELETE,
				NULL, 0));
}

AV *
Perl_newAV(pTHX)
{
    return MUTABLE_AV(newSV_type(SVt_PVAV));
    /* sv_upgrade does AvREAL_only():
    AvALLOC(av) = 0;
    AvARRAY(av) = NULL;
    AvMAX(av) = AvFILLp(av) = -1; */
}

HV *
Perl_newHV(pTHX)
{
    HV * const hv = MUTABLE_HV(newSV_type(SVt_PVHV));
    assert(!SvOK(hv));

    return hv;
}

void
Perl_sv_insert(pTHX_ SV *const bigstr, const STRLEN offset, const STRLEN len, 
              const char *const little, const STRLEN littlelen)
{
    PERL_ARGS_ASSERT_SV_INSERT;
    sv_insert_flags(bigstr, offset, len, little, littlelen, SV_GMAGIC);
}

void
Perl_save_freesv(pTHX_ SV *sv)
{
    save_freesv(sv);
}

void
Perl_save_mortalizesv(pTHX_ SV *sv)
{
    PERL_ARGS_ASSERT_SAVE_MORTALIZESV;

    save_mortalizesv(sv);
}

void
Perl_save_freeop(pTHX_ OP *o)
{
    save_freeop(o);
}

void
Perl_save_freepv(pTHX_ char *pv)
{
    save_freepv(pv);
}

void
Perl_save_op(pTHX)
{
    save_op();
}

#ifdef PERL_DONT_CREATE_GVSV
GV *
Perl_gv_SVadd(pTHX_ GV *gv)
{
    return gv_SVadd(gv);
}
#endif

GV *
Perl_gv_AVadd(pTHX_ GV *gv)
{
    return gv_AVadd(gv);
}

GV *
Perl_gv_HVadd(pTHX_ GV *gv)
{
    return gv_HVadd(gv);
}

GV *
Perl_gv_IOadd(pTHX_ GV *gv)
{
    return gv_IOadd(gv);
}

IO *
Perl_newIO(pTHX)
{
    return MUTABLE_IO(newSV_type(SVt_PVIO));
}

I32
Perl_my_stat(pTHX)
{
    return my_stat_flags(SV_GMAGIC);
}

I32
Perl_my_lstat(pTHX)
{
    return my_lstat_flags(SV_GMAGIC);
}

I32
Perl_sv_eq(pTHX_ SV *sv1, SV *sv2)
{
    return sv_eq_flags(sv1, sv2, SV_GMAGIC);
}

#ifdef USE_LOCALE_COLLATE
char *
Perl_sv_collxfrm(pTHX_ SV *const sv, STRLEN *const nxp)
{
    return sv_collxfrm_flags(sv, nxp, SV_GMAGIC);
}
#endif

bool
Perl_sv_2bool(pTHX_ SV *const sv)
{
    return sv_2bool_flags(sv, SV_GMAGIC);
}


/*
=for apidoc custom_op_name
Return the name for a given custom op.  This was once used by the C<OP_NAME>
macro, but is no longer: it has only been kept for compatibility, and
should not be used.

=for apidoc custom_op_desc
Return the description of a given custom op.  This was once used by the
C<OP_DESC> macro, but is no longer: it has only been kept for
compatibility, and should not be used.

=cut
*/

const char*
Perl_custom_op_name(pTHX_ const OP* o)
{
    PERL_ARGS_ASSERT_CUSTOM_OP_NAME;
    return XopENTRYCUSTOM(o, xop_name);
}

const char*
Perl_custom_op_desc(pTHX_ const OP* o)
{
    PERL_ARGS_ASSERT_CUSTOM_OP_DESC;
    return XopENTRYCUSTOM(o, xop_desc);
}

CV *
Perl_newSUB(pTHX_ I32 floor, OP *o, OP *proto, OP *block)
{
    return newATTRSUB(floor, o, proto, NULL, block);
}

UV
Perl_to_utf8_fold(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp)
{
    PERL_ARGS_ASSERT_TO_UTF8_FOLD;

    return _to_utf8_fold_flags(p, ustrp, lenp, FOLD_FLAGS_FULL);
}

UV
Perl_to_utf8_lower(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp)
{
    PERL_ARGS_ASSERT_TO_UTF8_LOWER;

    return _to_utf8_lower_flags(p, ustrp, lenp, FALSE);
}

UV
Perl_to_utf8_title(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp)
{
    PERL_ARGS_ASSERT_TO_UTF8_TITLE;

    return _to_utf8_title_flags(p, ustrp, lenp, FALSE);
}

UV
Perl_to_utf8_upper(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp)
{
    PERL_ARGS_ASSERT_TO_UTF8_UPPER;

    return _to_utf8_upper_flags(p, ustrp, lenp, FALSE);
}

SV *
Perl_sv_mortalcopy(pTHX_ SV *const oldstr)
{
    return Perl_sv_mortalcopy_flags(aTHX_ oldstr, SV_GMAGIC);
}

void
Perl_sv_copypv(pTHX_ SV *const dsv, SV *const ssv)
{
    PERL_ARGS_ASSERT_SV_COPYPV;

    sv_copypv_flags(dsv, ssv, 0);
}

UV      /* Made into a function, so can be deprecated */
NATIVE_TO_NEED(const UV enc, const UV ch)
{
    PERL_UNUSED_ARG(enc);
    return ch;
}

UV      /* Made into a function, so can be deprecated */
ASCII_TO_NEED(const UV enc, const UV ch)
{
    PERL_UNUSED_ARG(enc);
    return ch;
}

bool      /* Made into a function, so can be deprecated */
Perl_isIDFIRST_lazy(pTHX_ const char* p)
{
    PERL_ARGS_ASSERT_ISIDFIRST_LAZY;

    return isIDFIRST_lazy_if(p,1);
}

bool      /* Made into a function, so can be deprecated */
Perl_isALNUM_lazy(pTHX_ const char* p)
{
    PERL_ARGS_ASSERT_ISALNUM_LAZY;

    return isALNUM_lazy_if(p,1);
}

bool
Perl_is_uni_alnum(pTHX_ UV c)
{
    return isWORDCHAR_uni(c);
}

bool
Perl_is_uni_alnumc(pTHX_ UV c)
{
    return isALNUM_uni(c);
}

bool
Perl_is_uni_alpha(pTHX_ UV c)
{
    return isALPHA_uni(c);
}

bool
Perl_is_uni_ascii(pTHX_ UV c)
{
    PERL_UNUSED_CONTEXT;
    return isASCII_uni(c);
}

bool
Perl_is_uni_blank(pTHX_ UV c)
{
    PERL_UNUSED_CONTEXT;
    return isBLANK_uni(c);
}

bool
Perl_is_uni_space(pTHX_ UV c)
{
    PERL_UNUSED_CONTEXT;
    return isSPACE_uni(c);
}

bool
Perl_is_uni_digit(pTHX_ UV c)
{
    PERL_UNUSED_CONTEXT;
    return isDIGIT_uni(c);
}

bool
Perl_is_uni_upper(pTHX_ UV c)
{
    PERL_UNUSED_CONTEXT;
    return isUPPER_uni(c);
}

bool
Perl_is_uni_lower(pTHX_ UV c)
{
    PERL_UNUSED_CONTEXT;
    return isLOWER_uni(c);
}

bool
Perl_is_uni_cntrl(pTHX_ UV c)
{
    PERL_UNUSED_CONTEXT;
    return isCNTRL_L1(c);
}

bool
Perl_is_uni_graph(pTHX_ UV c)
{
    PERL_UNUSED_CONTEXT;
    return isGRAPH_uni(c);
}

bool
Perl_is_uni_print(pTHX_ UV c)
{
    PERL_UNUSED_CONTEXT;
    return isPRINT_uni(c);
}

bool
Perl_is_uni_punct(pTHX_ UV c)
{
    PERL_UNUSED_CONTEXT;
    return isPUNCT_uni(c);
}

bool
Perl_is_uni_xdigit(pTHX_ UV c)
{
    PERL_UNUSED_CONTEXT;
    return isXDIGIT_uni(c);
}

bool
Perl_is_uni_alnum_lc(pTHX_ UV c)
{
    PERL_UNUSED_CONTEXT;
    return isWORDCHAR_LC_uvchr(c);
}

bool
Perl_is_uni_alnumc_lc(pTHX_ UV c)
{
    PERL_UNUSED_CONTEXT;
    return isALPHANUMERIC_LC_uvchr(c);
}

bool
Perl_is_uni_idfirst_lc(pTHX_ UV c)
{
    PERL_UNUSED_CONTEXT;
    /* XXX Should probably be something that resolves to the old IDFIRST, but
     * this function is deprecated, so not bothering */
    return isIDFIRST_LC_uvchr(c);
}

bool
Perl_is_uni_alpha_lc(pTHX_ UV c)
{
    PERL_UNUSED_CONTEXT;
    return isALPHA_LC_uvchr(c);
}

bool
Perl_is_uni_ascii_lc(pTHX_ UV c)
{
    PERL_UNUSED_CONTEXT;
    return isASCII_LC_uvchr(c);
}

bool
Perl_is_uni_blank_lc(pTHX_ UV c)
{
    PERL_UNUSED_CONTEXT;
    return isBLANK_LC_uvchr(c);
}

bool
Perl_is_uni_space_lc(pTHX_ UV c)
{
    PERL_UNUSED_CONTEXT;
    return isSPACE_LC_uvchr(c);
}

bool
Perl_is_uni_digit_lc(pTHX_ UV c)
{
    return isDIGIT_LC_uvchr(c);
}

bool
Perl_is_uni_idfirst(pTHX_ UV c)
{
    U8 tmpbuf[UTF8_MAXBYTES+1];
    uvchr_to_utf8(tmpbuf, c);
    return _is_utf8_idstart(tmpbuf);
}

bool
Perl_is_utf8_idfirst(pTHX_ const U8 *p) /* The naming is historical. */
{
    PERL_ARGS_ASSERT_IS_UTF8_IDFIRST;

    return _is_utf8_idstart(p);
}

bool
Perl_is_utf8_xidfirst(pTHX_ const U8 *p) /* The naming is historical. */
{
    PERL_ARGS_ASSERT_IS_UTF8_XIDFIRST;

    return _is_utf8_xidstart(p);
}

bool
Perl_is_utf8_idcont(pTHX_ const U8 *p)
{
    PERL_ARGS_ASSERT_IS_UTF8_IDCONT;

    return _is_utf8_idcont(p);
}

bool
Perl_is_utf8_xidcont(pTHX_ const U8 *p)
{
    PERL_ARGS_ASSERT_IS_UTF8_XIDCONT;

    return _is_utf8_xidcont(p);
}

bool
Perl_is_uni_upper_lc(pTHX_ UV c)
{
    return isUPPER_LC_uvchr(c);
}

bool
Perl_is_uni_lower_lc(pTHX_ UV c)
{
    return isLOWER_LC_uvchr(c);
}

bool
Perl_is_uni_cntrl_lc(pTHX_ UV c)
{
    return isCNTRL_LC_uvchr(c);
}

bool
Perl_is_uni_graph_lc(pTHX_ UV c)
{
    return isGRAPH_LC_uvchr(c);
}

bool
Perl_is_uni_print_lc(pTHX_ UV c)
{
    return isPRINT_LC_uvchr(c);
}

bool
Perl_is_uni_punct_lc(pTHX_ UV c)
{
    return isPUNCT_LC_uvchr(c);
}

bool
Perl_is_uni_xdigit_lc(pTHX_ UV c)
{
    return isXDIGIT_LC_uvchr(c);
}

U32
Perl_to_uni_upper_lc(pTHX_ U32 c)
{
    /* XXX returns only the first character -- do not use XXX */
    /* XXX no locale support yet */
    STRLEN len;
    U8 tmpbuf[UTF8_MAXBYTES_CASE+1];
    return (U32)to_uni_upper(c, tmpbuf, &len);
}

U32
Perl_to_uni_title_lc(pTHX_ U32 c)
{
    /* XXX returns only the first character XXX -- do not use XXX */
    /* XXX no locale support yet */
    STRLEN len;
    U8 tmpbuf[UTF8_MAXBYTES_CASE+1];
    return (U32)to_uni_title(c, tmpbuf, &len);
}

U32
Perl_to_uni_lower_lc(pTHX_ U32 c)
{
    /* XXX returns only the first character -- do not use XXX */
    /* XXX no locale support yet */
    STRLEN len;
    U8 tmpbuf[UTF8_MAXBYTES_CASE+1];
    return (U32)to_uni_lower(c, tmpbuf, &len);
}

bool
Perl_is_utf8_alnum(pTHX_ const U8 *p)
{
    PERL_ARGS_ASSERT_IS_UTF8_ALNUM;

    /* NOTE: "IsWord", not "IsAlnum", since Alnum is a true
     * descendant of isalnum(3), in other words, it doesn't
     * contain the '_'. --jhi */
    return isWORDCHAR_utf8(p);
}

bool
Perl_is_utf8_alnumc(pTHX_ const U8 *p)
{
    PERL_ARGS_ASSERT_IS_UTF8_ALNUMC;

    return isALPHANUMERIC_utf8(p);
}

bool
Perl_is_utf8_alpha(pTHX_ const U8 *p)
{
    PERL_ARGS_ASSERT_IS_UTF8_ALPHA;

    return isALPHA_utf8(p);
}

bool
Perl_is_utf8_ascii(pTHX_ const U8 *p)
{
    PERL_ARGS_ASSERT_IS_UTF8_ASCII;
    PERL_UNUSED_CONTEXT;

    return isASCII_utf8(p);
}

bool
Perl_is_utf8_blank(pTHX_ const U8 *p)
{
    PERL_ARGS_ASSERT_IS_UTF8_BLANK;
    PERL_UNUSED_CONTEXT;

    return isBLANK_utf8(p);
}

bool
Perl_is_utf8_space(pTHX_ const U8 *p)
{
    PERL_ARGS_ASSERT_IS_UTF8_SPACE;
    PERL_UNUSED_CONTEXT;

    return isSPACE_utf8(p);
}

bool
Perl_is_utf8_perl_space(pTHX_ const U8 *p)
{
    PERL_ARGS_ASSERT_IS_UTF8_PERL_SPACE;
    PERL_UNUSED_CONTEXT;

    /* Only true if is an ASCII space-like character, and ASCII is invariant
     * under utf8, so can just use the macro */
    return isSPACE_A(*p);
}

bool
Perl_is_utf8_perl_word(pTHX_ const U8 *p)
{
    PERL_ARGS_ASSERT_IS_UTF8_PERL_WORD;
    PERL_UNUSED_CONTEXT;

    /* Only true if is an ASCII word character, and ASCII is invariant
     * under utf8, so can just use the macro */
    return isWORDCHAR_A(*p);
}

bool
Perl_is_utf8_digit(pTHX_ const U8 *p)
{
    PERL_ARGS_ASSERT_IS_UTF8_DIGIT;

    return isDIGIT_utf8(p);
}

bool
Perl_is_utf8_posix_digit(pTHX_ const U8 *p)
{
    PERL_ARGS_ASSERT_IS_UTF8_POSIX_DIGIT;
    PERL_UNUSED_CONTEXT;

    /* Only true if is an ASCII digit character, and ASCII is invariant
     * under utf8, so can just use the macro */
    return isDIGIT_A(*p);
}

bool
Perl_is_utf8_upper(pTHX_ const U8 *p)
{
    PERL_ARGS_ASSERT_IS_UTF8_UPPER;

    return isUPPER_utf8(p);
}

bool
Perl_is_utf8_lower(pTHX_ const U8 *p)
{
    PERL_ARGS_ASSERT_IS_UTF8_LOWER;

    return isLOWER_utf8(p);
}

bool
Perl_is_utf8_cntrl(pTHX_ const U8 *p)
{
    PERL_ARGS_ASSERT_IS_UTF8_CNTRL;
    PERL_UNUSED_CONTEXT;

    return isCNTRL_utf8(p);
}

bool
Perl_is_utf8_graph(pTHX_ const U8 *p)
{
    PERL_ARGS_ASSERT_IS_UTF8_GRAPH;

    return isGRAPH_utf8(p);
}

bool
Perl_is_utf8_print(pTHX_ const U8 *p)
{
    PERL_ARGS_ASSERT_IS_UTF8_PRINT;

    return isPRINT_utf8(p);
}

bool
Perl_is_utf8_punct(pTHX_ const U8 *p)
{
    PERL_ARGS_ASSERT_IS_UTF8_PUNCT;

    return isPUNCT_utf8(p);
}

bool
Perl_is_utf8_xdigit(pTHX_ const U8 *p)
{
    PERL_ARGS_ASSERT_IS_UTF8_XDIGIT;
    PERL_UNUSED_CONTEXT;

    return isXDIGIT_utf8(p);
}

bool
Perl_is_utf8_mark(pTHX_ const U8 *p)
{
    PERL_ARGS_ASSERT_IS_UTF8_MARK;

    return _is_utf8_mark(p);
}

/*
=for apidoc is_utf8_char

Tests if some arbitrary number of bytes begins in a valid UTF-8
character.  Note that an INVARIANT (i.e. ASCII on non-EBCDIC machines)
character is a valid UTF-8 character.  The actual number of bytes in the UTF-8
character will be returned if it is valid, otherwise 0.

This function is deprecated due to the possibility that malformed input could
cause reading beyond the end of the input buffer.  Use L</isUTF8_CHAR>
instead.

=cut */

STRLEN
Perl_is_utf8_char(const U8 *s)
{
    PERL_ARGS_ASSERT_IS_UTF8_CHAR;

    /* Assumes we have enough space, which is why this is deprecated */
    return isUTF8_CHAR(s, s + UTF8SKIP(s));
}

/*
=for apidoc is_utf8_char_buf

This is identical to the macro L</isUTF8_CHAR>.

=cut */

STRLEN
Perl_is_utf8_char_buf(const U8 *buf, const U8* buf_end)
{

    PERL_ARGS_ASSERT_IS_UTF8_CHAR_BUF;

    return isUTF8_CHAR(buf, buf_end);
}

/* DEPRECATED!
 * Like L</utf8_to_uvuni_buf>(), but should only be called when it is known that
 * there are no malformations in the input UTF-8 string C<s>.  Surrogates,
 * non-character code points, and non-Unicode code points are allowed */

UV
Perl_valid_utf8_to_uvuni(pTHX_ const U8 *s, STRLEN *retlen)
{
    PERL_ARGS_ASSERT_VALID_UTF8_TO_UVUNI;

    return NATIVE_TO_UNI(valid_utf8_to_uvchr(s, retlen));
}

/*
=for apidoc utf8_to_uvchr

Returns the native code point of the first character in the string C<s>
which is assumed to be in UTF-8 encoding; C<retlen> will be set to the
length, in bytes, of that character.

Some, but not all, UTF-8 malformations are detected, and in fact, some
malformed input could cause reading beyond the end of the input buffer, which
is why this function is deprecated.  Use L</utf8_to_uvchr_buf> instead.

If C<s> points to one of the detected malformations, and UTF8 warnings are
enabled, zero is returned and C<*retlen> is set (if C<retlen> isn't
C<NULL>) to -1.  If those warnings are off, the computed value if well-defined (or
the Unicode REPLACEMENT CHARACTER, if not) is silently returned, and C<*retlen>
is set (if C<retlen> isn't NULL) so that (S<C<s> + C<*retlen>>) is the
next possible position in C<s> that could begin a non-malformed character.
See L</utf8n_to_uvchr> for details on when the REPLACEMENT CHARACTER is returned.

=cut
*/

UV
Perl_utf8_to_uvchr(pTHX_ const U8 *s, STRLEN *retlen)
{
    PERL_ARGS_ASSERT_UTF8_TO_UVCHR;

    return utf8_to_uvchr_buf(s, s + UTF8_MAXBYTES, retlen);
}

/*
=for apidoc utf8_to_uvuni

Returns the Unicode code point of the first character in the string C<s>
which is assumed to be in UTF-8 encoding; C<retlen> will be set to the
length, in bytes, of that character.

Some, but not all, UTF-8 malformations are detected, and in fact, some
malformed input could cause reading beyond the end of the input buffer, which
is one reason why this function is deprecated.  The other is that only in
extremely limited circumstances should the Unicode versus native code point be
of any interest to you.  See L</utf8_to_uvuni_buf> for alternatives.

If C<s> points to one of the detected malformations, and UTF8 warnings are
enabled, zero is returned and C<*retlen> is set (if C<retlen> doesn't point to
NULL) to -1.  If those warnings are off, the computed value if well-defined (or
the Unicode REPLACEMENT CHARACTER, if not) is silently returned, and C<*retlen>
is set (if C<retlen> isn't NULL) so that (S<C<s> + C<*retlen>>) is the
next possible position in C<s> that could begin a non-malformed character.
See L</utf8n_to_uvchr> for details on when the REPLACEMENT CHARACTER is returned.

=cut
*/

UV
Perl_utf8_to_uvuni(pTHX_ const U8 *s, STRLEN *retlen)
{
    PERL_ARGS_ASSERT_UTF8_TO_UVUNI;

    return NATIVE_TO_UNI(valid_utf8_to_uvchr(s, retlen));
}

/*
=for apidoc Am|HV *|pad_compname_type|PADOFFSET po

Looks up the type of the lexical variable at position C<po> in the
currently-compiling pad.  If the variable is typed, the stash of the
class to which it is typed is returned.  If not, C<NULL> is returned.

=cut
*/

HV *
Perl_pad_compname_type(pTHX_ const PADOFFSET po)
{
    return PAD_COMPNAME_TYPE(po);
}


END_EXTERN_C

#endif /* NO_MATHOMS */

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
@


1.1
log
@Initial revision
@
text
@d3 2
a4 1
 *    Copyright (C) 2005, 2006, 2007, 2007, by Larry Wall and others
d12 6
a17 4
 * "Anything that Hobbits had no immediate use for, but were unwilling to 
 * throw away, they called a mathom. Their dwellings were apt to become
 * rather crowded with mathoms, and many of the presents that passed from
 * hand to hand were of that sort." 
d20 1
a20 1
#ifndef NO_MATHOMS
d27 3
d32 9
d43 1
d48 11
d62 9
a70 8
PERL_CALLCONV IV Perl_sv_2iv(pTHX_ register SV *sv);
PERL_CALLCONV UV Perl_sv_2uv(pTHX_ register SV *sv);
PERL_CALLCONV char * Perl_sv_2pv(pTHX_ register SV *sv, STRLEN *lp);
PERL_CALLCONV char * Perl_sv_2pv_nolen(pTHX_ register SV *sv);
PERL_CALLCONV char * Perl_sv_2pvbyte_nolen(pTHX_ register SV *sv);
PERL_CALLCONV char * Perl_sv_2pvutf8_nolen(pTHX_ register SV *sv);
PERL_CALLCONV void Perl_sv_force_normal(pTHX_ register SV *sv);
PERL_CALLCONV void Perl_sv_setsv(pTHX_ SV *dstr, register SV *sstr);
d72 3
a74 3
PERL_CALLCONV void Perl_sv_catpvn_mg(pTHX_ register SV *sv, register const char *ptr, register STRLEN len);
PERL_CALLCONV void Perl_sv_catsv(pTHX_ SV *dstr, register SV *sstr);
PERL_CALLCONV void Perl_sv_catsv_mg(pTHX_ SV *dsv, register SV *ssv);
d79 1
a79 1
PERL_CALLCONV STRLEN Perl_sv_utf8_upgrade(pTHX_ register SV *sv);
d86 2
a87 3
PERL_CALLCONV bool Perl_do_open(pTHX_ GV *gv, register const char *name, I32 len, int as_raw, int rawmode, int rawperm, PerlIO *supplied_fp);
PERL_CALLCONV bool Perl_do_aexec(pTHX_ SV *really, register SV **mark, register SV **sp);
PERL_CALLCONV bool Perl_do_exec(pTHX_ const char *cmd);
d95 15
a109 1

d126 1
a126 1
being zero.  See C<SvROK_off>.
d134 2
d142 2
a143 1
Taint an SV. Use C<SvTAINTED_on> instead.
d150 2
d160 1
a160 1
Perl_sv_2iv(pTHX_ register SV *sv)
d162 2
d172 1
a172 1
Perl_sv_2uv(pTHX_ register SV *sv)
d174 2
d179 11
d195 1
a195 1
Perl_sv_2pv(pTHX_ register SV *sv, STRLEN *lp)
d197 2
d205 1
a205 1
Like C<sv_2pv()>, but doesn't return the length too. You should usually
d207 1
d212 1
a212 1
Perl_sv_2pv_nolen(pTHX_ register SV *sv)
d214 1
d230 1
a230 1
Perl_sv_2pvbyte_nolen(pTHX_ register SV *sv)
d232 2
d249 1
a249 1
Perl_sv_2pvutf8_nolen(pTHX_ register SV *sv)
d251 2
d261 1
a261 1
an xpvmg. See also C<sv_force_normal_flags>.
d267 1
a267 1
Perl_sv_force_normal(pTHX_ register SV *sv)
d269 2
d279 1
a279 1
Perl_sv_setsv(pTHX_ SV *dstr, register SV *sstr)
d281 2
d293 2
d307 1
a307 1
Perl_sv_catpvn_mg(pTHX_ register SV *sv, register const char *ptr, register STRLEN len)
d309 2
d319 1
a319 1
Perl_sv_catsv(pTHX_ SV *dstr, register SV *sstr)
d321 2
d335 1
a335 1
Perl_sv_catsv_mg(pTHX_ SV *dsv, register SV *ssv)
d337 2
d346 1
a346 1
cope with complex macro expressions. Always use the macro instead.
d352 1
a352 1
Perl_sv_iv(pTHX_ register SV *sv)
d354 2
d368 1
a368 1
cope with complex macro expressions. Always use the macro instead.
d374 1
a374 1
Perl_sv_uv(pTHX_ register SV *sv)
d376 2
d390 1
a390 1
cope with complex macro expressions. Always use the macro instead.
d396 1
a396 1
Perl_sv_nv(pTHX_ register SV *sv)
d398 2
d413 1
a413 1
cope with complex macro expressions. Always use the macro instead.
d421 2
d432 1
a432 1
Perl_sv_pvn_nomg(pTHX_ register SV *sv, STRLEN *lp)
d434 2
d450 2
d465 2
d477 2
d491 1
a491 1
which can't cope with complex macro expressions. Always use the macro
d500 2
d513 2
d527 1
a527 1
which can't cope with complex macro expressions. Always use the macro
d536 2
d547 1
a547 1
Perl_sv_utf8_upgrade(pTHX_ register SV *sv)
d549 2
d557 1
a557 1
    dTHXs;
d559 7
d567 3
a569 1
    return PerlIO_vprintf(stream, format, arglist);
d577 6
d584 3
a586 1
    return PerlIO_vprintf(PerlIO_stdout(), format, arglist);
d610 2
d619 2
d627 2
d635 2
d643 1
a643 1
See L<gv_fetchmethod_autoload>.
d651 2
d659 2
d667 1
a667 2
    sv_magic((SV*)hv, (SV*)gv, how, NULL, 0);
}
d669 1
a669 18
AV *
Perl_av_fake(pTHX_ register I32 size, register SV **strp)
{
    register SV** ary;
    register AV * const av = (AV*)newSV_type(SVt_PVAV);
    Newx(ary,size+1,SV*);
    AvALLOC(av) = ary;
    Copy(strp,ary,size,SV*);
    AvREIFY_only(av);
    AvARRAY(av) = ary;
    AvFILLp(av) = size - 1;
    AvMAX(av) = size - 1;
    while (size--) {
        assert (*strp);
        SvTEMP_off(*strp);
        strp++;
    }
    return av;
d673 1
a673 1
Perl_do_open(pTHX_ GV *gv, register const char *name, I32 len, int as_raw,
d676 2
d683 1
a683 1
Perl_do_open9(pTHX_ GV *gv, register const char *name, I32 len, int 
d688 2
d702 3
d714 1
a714 1
Perl_do_aexec(pTHX_ SV *really, register SV **mark, register SV **sp)
d716 2
a721 8
#ifdef PERL_DEFAULT_DO_EXEC3_IMPLEMENTATION
bool
Perl_do_exec(pTHX_ const char *cmd)
{
    return do_exec3(cmd,0,0);
}
#endif

d729 2
a730 2
OP *
Perl_oopsCV(pTHX_ OP *o)
d732 2
a733 5
    Perl_croak(aTHX_ "NOT IMPL LINE %d",__LINE__);
    /* STUB */
    PERL_UNUSED_ARG(o);
    NORETURN_FUNCTION_END;
}
d735 1
a735 3
PP(pp_padany)
{
    DIE(aTHX_ "NOT IMPL LINE %d",__LINE__);
d738 2
a739 4
PP(pp_mapstart)
{
    DIE(aTHX_ "panic: mapstart");	/* uses grepstart */
}
d741 3
a743 6
/* These ops all have the same body as pp_null.  */
PP(pp_scalar)
{
    dVAR;
    return NORMAL;
}
d745 1
a745 5
PP(pp_regcmaybe)
{
    dVAR;
    return NORMAL;
}
d747 2
a748 5
PP(pp_lineseq)
{
    dVAR;
    return NORMAL;
}
d750 2
a751 1
PP(pp_scope)
d753 2
a754 2
    dVAR;
    return NORMAL;
a756 5
/* Ops that are calls to do_kv.  */
PP(pp_values)
{
    return do_kv();
}
d758 2
a759 4
PP(pp_keys)
{
    return do_kv();
}
d761 3
a763 6
/* Ops that are simply calls to other ops.  */
PP(pp_dump)
{
    return pp_goto();
    /*NOTREACHED*/
}
d765 1
a765 4
PP(pp_dofile)
{
    return pp_require();
}
d767 2
a768 4
PP(pp_dbmclose)
{
    return pp_untie();
}
d770 2
a771 1
PP(pp_read)
d773 2
a774 1
    return pp_sysread();
d777 2
a778 1
PP(pp_recv)
d780 1
a780 2
    return pp_sysread();
}
d782 4
a785 3
PP(pp_seek)
{
    return pp_sysseek();
d788 2
a789 1
PP(pp_fcntl)
d791 1
a791 2
    return pp_ioctl();
}
d793 4
a796 3
PP(pp_gsockopt)
{
    return pp_ssockopt();
d799 2
a800 1
PP(pp_getsockname)
d802 1
a802 2
    return pp_getpeername();
}
d804 3
a806 3
PP(pp_lstat)
{
    return pp_stat();
d809 2
a810 1
PP(pp_fteowned)
d812 1
a812 2
    return pp_ftrowned();
}
d814 1
a814 4
PP(pp_ftbinary)
{
    return pp_fttext();
}
d816 10
a825 3
PP(pp_localtime)
{
    return pp_gmtime();
d828 2
a829 4
PP(pp_shmget)
{
    return pp_semget();
}
d831 1
a831 4
PP(pp_shmctl)
{
    return pp_semctl();
}
d833 2
a834 4
PP(pp_shmread)
{
    return pp_shmwrite();
}
d836 2
a837 1
PP(pp_msgget)
d839 1
a839 2
    return pp_semget();
}
d841 1
a841 3
PP(pp_msgctl)
{
    return pp_semctl();
d844 2
a845 4
PP(pp_ghbyname)
{
    return pp_ghostent();
}
d847 3
a849 4
PP(pp_ghbyaddr)
{
    return pp_ghostent();
}
d851 2
a852 4
PP(pp_gnbyname)
{
    return pp_gnetent();
}
d854 2
a855 1
PP(pp_gnbyaddr)
d857 1
a857 2
    return pp_gnetent();
}
d859 1
a859 3
PP(pp_gpbyname)
{
    return pp_gprotoent();
d862 2
a863 4
PP(pp_gpbynumber)
{
    return pp_gprotoent();
}
d865 3
a867 4
PP(pp_gsbyname)
{
    return pp_gservent();
}
d869 1
a869 4
PP(pp_gsbyport)
{
    return pp_gservent();
}
d871 4
a874 1
PP(pp_gpwnam)
d876 1
a876 2
    return pp_gpwent();
}
d878 3
a880 4
PP(pp_gpwuid)
{
    return pp_gpwent();
}
d882 1
a882 3
PP(pp_ggrnam)
{
    return pp_ggrent();
d885 2
a886 4
PP(pp_ggrgid)
{
    return pp_ggrent();
}
d888 3
a890 4
PP(pp_ftsize)
{
    return pp_ftis();
}
d892 2
a893 4
PP(pp_ftmtime)
{
    return pp_ftis();
}
d895 2
a896 1
PP(pp_ftatime)
d898 1
a898 2
    return pp_ftis();
}
d900 2
a901 4
PP(pp_ftctime)
{
    return pp_ftis();
}
d903 1
a903 3
PP(pp_ftzero)
{
    return pp_ftrowned();
d906 2
a907 1
PP(pp_ftsock)
d909 1
a909 1
    return pp_ftrowned();
d912 2
a913 1
PP(pp_ftchr)
d915 1
a915 2
    return pp_ftrowned();
}
d917 2
a918 3
PP(pp_ftblk)
{
    return pp_ftrowned();
d921 2
a922 1
PP(pp_ftfile)
d924 1
a924 2
    return pp_ftrowned();
}
d926 2
a927 3
PP(pp_ftdir)
{
    return pp_ftrowned();
d930 2
a931 1
PP(pp_ftpipe)
d933 1
a933 2
    return pp_ftrowned();
}
d935 2
a936 3
PP(pp_ftsuid)
{
    return pp_ftrowned();
d939 3
a941 1
PP(pp_ftsgid)
d943 2
a944 1
    return pp_ftrowned();
d947 2
a948 1
PP(pp_ftsvtx)
d950 2
a951 2
    return pp_ftrowned();
}
d953 13
a965 1
PP(pp_unlink)
d967 14
a980 1
    return pp_chown();
d983 2
a984 1
PP(pp_chmod)
d986 15
a1000 1
    return pp_chown();
d1003 2
a1004 1
PP(pp_utime)
d1006 14
a1019 1
    return pp_chown();
d1022 2
a1023 1
PP(pp_kill)
d1025 5
a1029 1
    return pp_chown();
d1032 2
a1033 1
PP(pp_symlink)
d1035 4
a1038 1
    return pp_link();
d1041 3
a1043 1
PP(pp_ftrwrite)
d1045 2
a1046 1
    return pp_ftrread();
d1049 2
a1050 1
PP(pp_ftrexec)
d1052 1
a1052 1
    return pp_ftrread();
d1055 2
a1056 1
PP(pp_fteread)
d1058 3
a1060 1
    return pp_ftrread();
d1063 2
a1064 1
PP(pp_ftewrite)
d1066 1
a1066 1
    return pp_ftrread();
d1069 2
a1070 1
PP(pp_fteexec)
d1072 1
a1072 1
    return pp_ftrread();
d1075 2
a1076 1
PP(pp_msgsnd)
d1078 1
a1078 1
    return pp_shmwrite();
d1081 3
a1083 1
PP(pp_msgrcv)
d1085 1
a1085 1
    return pp_shmwrite();
d1087 1
d1089 2
a1090 1
PP(pp_syswrite)
d1092 1
a1092 1
    return pp_send();
d1095 2
a1096 1
PP(pp_semop)
d1098 1
a1098 1
    return pp_shmwrite();
d1101 2
a1102 1
PP(pp_dor)
d1104 1
a1104 1
    return pp_defined();
d1107 2
a1108 1
PP(pp_andassign)
d1110 1
a1110 1
    return pp_and();
d1113 2
a1114 1
PP(pp_orassign)
d1116 1
a1116 1
    return pp_or();
d1119 2
a1120 1
PP(pp_dorassign)
d1122 2
a1123 2
    return pp_defined();
} 
d1125 2
a1126 1
PP(pp_lcfirst)
d1128 1
a1128 1
    return pp_ucfirst();
d1131 3
a1133 1
PP(pp_slt)
d1135 1
a1135 1
    return pp_sle();
d1137 1
d1139 2
a1140 1
PP(pp_sgt)
d1142 1
a1142 1
    return pp_sle();
d1145 17
a1161 1
PP(pp_sge)
d1163 2
a1164 1
    return pp_sle();
d1167 2
a1168 1
PP(pp_rindex)
d1170 2
a1171 1
    return pp_index();
d1174 2
a1175 1
PP(pp_hex)
d1177 1
a1177 1
    return pp_oct();
d1180 2
a1181 1
PP(pp_pop)
d1183 3
a1185 1
    return pp_shift();
d1188 2
a1189 1
PP(pp_cos)
d1191 3
a1193 1
    return pp_sin();
d1196 2
a1197 1
PP(pp_exp)
d1199 3
a1201 1
    return pp_sin();
d1204 2
a1205 1
PP(pp_log)
d1207 3
a1209 1
    return pp_sin();
d1212 2
a1213 1
PP(pp_sqrt)
d1215 1
a1215 1
    return pp_sin();
d1218 2
a1219 1
PP(pp_bit_xor)
d1221 3
a1223 1
    return pp_bit_or();
d1226 2
a1227 1
PP(pp_rv2hv)
d1229 2
a1230 1
    return Perl_pp_rv2av(aTHX);
d1233 2
a1234 2
U8 *
Perl_uvuni_to_utf8(pTHX_ U8 *d, UV uv)
d1236 18
a1253 1
    return Perl_uvuni_to_utf8_flags(aTHX_ d, uv, 0);
d1257 61
a1317 1
Perl_is_utf8_string_loc(pTHX_ const U8 *s, STRLEN len, const U8 **ep)
d1319 2
a1320 1
    return is_utf8_string_loclen(s, len, ep, 0);
d1323 6
a1328 2
/*
=for apidoc sv_nolocking
d1330 6
a1335 3
Dummy routine which "locks" an SV when there is no locking module present.
Exists to avoid test for a NULL function pointer and because it could
potentially warn under some level of strict-ness.
d1337 6
a1342 1
"Superseded" by sv_nosharing().
d1344 6
a1349 2
=cut
*/
d1351 2
a1352 2
void
Perl_sv_nolocking(pTHX_ SV *sv)
d1355 1
a1355 1
    PERL_UNUSED_ARG(sv);
d1358 6
d1365 8
a1372 2
/*
=for apidoc sv_nounlocking
d1374 6
a1379 3
Dummy routine which "unlocks" an SV when there is no locking module present.
Exists to avoid test for a NULL function pointer and because it could
potentially warn under some level of strict-ness.
d1381 6
a1386 1
"Superseded" by sv_nosharing().
d1388 6
a1393 2
=cut
*/
d1395 2
a1396 2
void
Perl_sv_nounlocking(pTHX_ SV *sv)
d1399 59
a1457 1
    PERL_UNUSED_ARG(sv);
d1460 2
a1461 2
void
Perl_save_long(pTHX_ long int *longp)
d1463 1
a1463 5
    dVAR;
    SSCHECK(3);
    SSPUSHLONG(*longp);
    SSPUSHPTR(longp);
    SSPUSHINT(SAVEt_LONG);
d1466 2
a1467 2
void
Perl_save_iv(pTHX_ IV *ivp)
d1469 1
a1469 5
    dVAR;
    SSCHECK(3);
    SSPUSHIV(*ivp);
    SSPUSHPTR(ivp);
    SSPUSHINT(SAVEt_IV);
d1472 2
a1473 2
void
Perl_save_nogv(pTHX_ GV *gv)
d1475 1
a1475 4
    dVAR;
    SSCHECK(2);
    SSPUSHPTR(gv);
    SSPUSHINT(SAVEt_NSTAB);
d1478 2
a1479 2
void
Perl_save_list(pTHX_ register SV **sarg, I32 maxsarg)
d1481 2
a1482 2
    dVAR;
    register I32 i;
d1484 4
a1487 8
    for (i = 1; i <= maxsarg; i++) {
	register SV * const sv = newSV(0);
	sv_setsv(sv,sarg[i]);
	SSCHECK(3);
	SSPUSHPTR(sarg[i]);		/* remember the pointer */
	SSPUSHPTR(sv);			/* remember the value */
	SSPUSHINT(SAVEt_ITEM);
    }
d1490 9
a1498 2
/*
=for apidoc sv_usepvn_mg
d1500 9
a1508 1
Like C<sv_usepvn>, but also handles 'set' magic.
d1510 9
a1518 2
=cut
*/
d1520 2
a1521 2
void
Perl_sv_usepvn_mg(pTHX_ SV *sv, char *ptr, STRLEN len)
d1523 6
a1528 1
    sv_usepvn_flags(sv,ptr,len, SV_SMAGIC);
d1531 7
a1537 2
/*
=for apidoc sv_usepvn
d1539 4
a1542 3
Tells an SV to use C<ptr> to find its string value. Implemented by
calling C<sv_usepvn_flags> with C<flags> of 0, hence does not handle 'set'
magic. See C<sv_usepvn_flags>.
d1544 2
a1545 2
=cut
*/
d1547 2
a1548 2
void
Perl_sv_usepvn(pTHX_ SV *sv, char *ptr, STRLEN len)
d1550 4
a1553 1
    sv_usepvn_flags(sv,ptr,len, 0);
d1556 2
a1557 2
void
Perl_cv_ckproto(pTHX_ const CV *cv, const GV *gv, const char *p)
d1559 4
a1562 1
    cv_ckproto_len(cv, gv, p, p ? strlen(p) : 0);
d1565 5
a1569 2
/*
=for apidoc unpack_str
d1571 2
a1572 2
The engine implementing unpack() Perl function. Note: parameters strbeg, new_s
and ocnt are not used. This call should not be used, use unpackstring instead.
d1574 10
a1583 1
=cut */
d1585 2
a1586 4
I32
Perl_unpack_str(pTHX_ const char *pat, const char *patend, const char *s,
		const char *strbeg, const char *strend, char **new_s, I32 ocnt,
		U32 flags)
d1588 2
a1589 3
    PERL_UNUSED_ARG(strbeg);
    PERL_UNUSED_ARG(new_s);
    PERL_UNUSED_ARG(ocnt);
d1591 3
a1593 1
    return unpackstring(pat, patend, s, strend, flags);
d1596 4
a1599 2
/*
=for apidoc pack_cat
d1601 2
a1602 2
The engine implementing pack() Perl function. Note: parameters next_in_list and
flags are not used. This call should not be used; use packlist instead.
d1604 10
a1613 2
=cut
*/
d1615 2
a1616 2
void
Perl_pack_cat(pTHX_ SV *cat, const char *pat, const char *patend, register SV **beglist, SV **endlist, SV ***next_in_list, U32 flags)
d1618 1
a1618 2
    PERL_UNUSED_ARG(next_in_list);
    PERL_UNUSED_ARG(flags);
d1620 1
a1620 1
    packlist(cat, pat, patend, beglist, endlist);
d1623 2
a1624 2
HE *
Perl_hv_store_ent(pTHX_ HV *hv, SV *keysv, SV *val, U32 hash)
d1626 3
a1628 1
  return (HE *)hv_common(hv, keysv, NULL, 0, 0, HV_FETCH_ISSTORE, val, hash);
d1632 1
a1632 1
Perl_hv_exists_ent(pTHX_ HV *hv, SV *keysv, U32 hash)
d1634 4
a1637 2
    return hv_common(hv, keysv, NULL, 0, 0, HV_FETCH_ISEXISTS, 0, hash)
	? TRUE : FALSE;
d1640 2
a1641 2
HE *
Perl_hv_fetch_ent(pTHX_ HV *hv, SV *keysv, I32 lval, U32 hash)
d1643 3
a1645 2
    return (HE *)hv_common(hv, keysv, NULL, 0, 0, 
		     (lval ? HV_FETCH_LVALUE : 0), NULL, hash);
d1648 2
a1649 2
SV *
Perl_hv_delete_ent(pTHX_ HV *hv, SV *keysv, I32 flags, U32 hash)
d1651 3
a1653 2
    return (SV *) hv_common(hv, keysv, NULL, 0, 0, flags | HV_DELETE, NULL,
			    hash);
d1656 2
a1657 3
SV**
Perl_hv_store_flags(pTHX_ HV *hv, const char *key, I32 klen, SV *val, U32 hash,
		    int flags)
d1659 3
a1661 2
    return (SV**) hv_common(hv, NULL, key, klen, flags,
			    (HV_FETCH_ISSTORE|HV_FETCH_JUST_SV), val, hash);
d1664 2
a1665 2
SV**
Perl_hv_store(pTHX_ HV *hv, const char *key, I32 klen_i32, SV *val, U32 hash)
d1667 2
a1668 2
    STRLEN klen;
    int flags;
d1670 1
a1670 9
    if (klen_i32 < 0) {
	klen = -klen_i32;
	flags = HVhek_UTF8;
    } else {
	klen = klen_i32;
	flags = 0;
    }
    return (SV **) hv_common(hv, NULL, key, klen, flags,
			     (HV_FETCH_ISSTORE|HV_FETCH_JUST_SV), val, hash);
d1674 53
a1726 1
Perl_hv_exists(pTHX_ HV *hv, const char *key, I32 klen_i32)
d1728 1
a1728 2
    STRLEN klen;
    int flags;
d1730 1
a1730 9
    if (klen_i32 < 0) {
	klen = -klen_i32;
	flags = HVhek_UTF8;
    } else {
	klen = klen_i32;
	flags = 0;
    }
    return hv_common(hv, NULL, key, klen, flags, HV_FETCH_ISEXISTS, 0, 0)
	? TRUE : FALSE;
d1733 24
a1756 2
SV**
Perl_hv_fetch(pTHX_ HV *hv, const char *key, I32 klen_i32, I32 lval)
d1758 1
a1758 2
    STRLEN klen;
    int flags;
d1760 1
a1760 10
    if (klen_i32 < 0) {
	klen = -klen_i32;
	flags = HVhek_UTF8;
    } else {
	klen = klen_i32;
	flags = 0;
    }
    return (SV **) hv_common(hv, NULL, key, klen, flags,
			     lval ? (HV_FETCH_JUST_SV | HV_FETCH_LVALUE)
			     : HV_FETCH_JUST_SV, NULL, 0);
d1763 26
a1788 2
SV *
Perl_hv_delete(pTHX_ HV *hv, const char *key, I32 klen_i32, I32 flags)
d1790 14
a1803 2
    STRLEN klen;
    int k_flags;
d1805 4
a1808 9
    if (klen_i32 < 0) {
	klen = -klen_i32;
	k_flags = HVhek_UTF8;
    } else {
	klen = klen_i32;
	k_flags = 0;
    }
    return (SV *) hv_common(hv, NULL, key, klen, k_flags, flags | HV_DELETE,
			    NULL, 0);
d1811 3
d1817 1
a1817 7
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
@


1.1.1.1
log
@import perl 5.10.0 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.10.1
@
text
@d3 1
a3 1
 *    Copyright (C) 2005, 2006, 2007, 2008 by Larry Wall and others
d11 4
a14 6
 *  Anything that Hobbits had no immediate use for, but were unwilling to
 *  throw away, they called a mathom.  Their dwellings were apt to become
 *  rather crowded with mathoms, and many of the presents that passed from
 *  hand to hand were of that sort.
 *
 *     [p.5 of _The Lord of the Rings_: "Prologue"]
d17 1
a17 1

a31 6
#ifdef NO_MATHOMS
/* ..." warning: ISO C forbids an empty source file"
   So make sure we have something in here by processing the headers anyway.
 */
#else

d68 1
a68 3
PERL_CALLCONV int Perl_magic_setglob(pTHX_ SV* sv, MAGIC* mg);
PERL_CALLCONV AV * Perl_newAV(pTHX);
PERL_CALLCONV HV * Perl_newHV(pTHX);
a92 2
    PERL_ARGS_ASSERT_SV_UNREF;

a105 2
    PERL_ARGS_ASSERT_SV_TAINT;

a166 2
    PERL_ARGS_ASSERT_SV_2PVBYTE_NOLEN;

a183 2
    PERL_ARGS_ASSERT_SV_2PVUTF8_NOLEN;

a199 2
    PERL_ARGS_ASSERT_SV_FORCE_NORMAL;

a209 2
    PERL_ARGS_ASSERT_SV_SETSV;

a219 2
    PERL_ARGS_ASSERT_SV_CATPVN;

a233 2
    PERL_ARGS_ASSERT_SV_CATPVN_MG;

a243 2
    PERL_ARGS_ASSERT_SV_CATSV;

a257 2
    PERL_ARGS_ASSERT_SV_CATSV_MG;

a272 2
    PERL_ARGS_ASSERT_SV_IV;

a292 2
    PERL_ARGS_ASSERT_SV_UV;

a312 2
    PERL_ARGS_ASSERT_SV_NV;

a333 2
    PERL_ARGS_ASSERT_SV_PVN;

a344 2
    PERL_ARGS_ASSERT_SV_PVN_NOMG;

a358 2
    PERL_ARGS_ASSERT_SV_PV;

a371 2
    PERL_ARGS_ASSERT_SV_PVN_FORCE;

a381 2
    PERL_ARGS_ASSERT_SV_PVBYTE;

a402 2
    PERL_ARGS_ASSERT_SV_PVBYTEN;

a413 2
    PERL_ARGS_ASSERT_SV_PVUTF8;

a434 2
    PERL_ARGS_ASSERT_SV_PVUTF8N;

a445 2
    PERL_ARGS_ASSERT_SV_UTF8_UPGRADE;

a453 7

    /* Easier to special case this here than in embed.pl. (Look at what it
       generates for proto.h) */
#ifdef PERL_IMPLICIT_CONTEXT
    PERL_ARGS_ASSERT_FPRINTF_NOCONTEXT;
#endif

a462 5

#ifdef PERL_IMPLICIT_CONTEXT
    PERL_ARGS_ASSERT_PRINTF_NOCONTEXT;
#endif

a487 2
    PERL_ARGS_ASSERT_GV_FULLNAME;

a494 2
    PERL_ARGS_ASSERT_GV_EFULLNAME;

a500 2
    PERL_ARGS_ASSERT_GV_FULLNAME3;

a506 2
    PERL_ARGS_ASSERT_GV_EFULLNAME3;

a520 2
    PERL_ARGS_ASSERT_GV_FETCHMETHOD;

a526 2
    PERL_ARGS_ASSERT_HV_ITERNEXT;

d533 1
a533 3
    PERL_ARGS_ASSERT_HV_MAGIC;

    sv_magic(MUTABLE_SV(hv), MUTABLE_SV(gv), how, NULL, 0);
d540 1
a540 4
    register AV * const av = MUTABLE_AV(newSV_type(SVt_PVAV));

    PERL_ARGS_ASSERT_AV_FAKE;

a559 2
    PERL_ARGS_ASSERT_DO_OPEN;

a569 2
    PERL_ARGS_ASSERT_DO_OPEN9;

a581 3

 PERL_ARGS_ASSERT_DO_BINMODE;

a592 2
    PERL_ARGS_ASSERT_DO_AEXEC;

a600 2
    PERL_ARGS_ASSERT_DO_EXEC;

a614 2
    PERL_ARGS_ASSERT_OOPSCV;

a1046 2
    PERL_ARGS_ASSERT_UVUNI_TO_UTF8;

a1052 2
    PERL_ARGS_ASSERT_IS_UTF8_STRING_LOC;

a1098 3

    PERL_ARGS_ASSERT_SAVE_LONG;

a1108 3

    PERL_ARGS_ASSERT_SAVE_IV;

a1118 3

    PERL_ARGS_ASSERT_SAVE_NOGV;

a1129 2
    PERL_ARGS_ASSERT_SAVE_LIST;

a1150 2
    PERL_ARGS_ASSERT_SV_USEPVN_MG;

a1166 2
    PERL_ARGS_ASSERT_SV_USEPVN;

a1172 2
    PERL_ARGS_ASSERT_CV_CKPROTO;

a1188 2
    PERL_ARGS_ASSERT_UNPACK_STR;

a1207 2
    PERL_ARGS_ASSERT_PACK_CAT;

a1222 2
    PERL_ARGS_ASSERT_HV_EXISTS_ENT;

a1229 2
    PERL_ARGS_ASSERT_HV_FETCH_ENT;

d1237 2
a1238 4
    PERL_ARGS_ASSERT_HV_DELETE_ENT;

    return MUTABLE_SV(hv_common(hv, keysv, NULL, 0, 0, flags | HV_DELETE, NULL,
				hash));
a1271 2
    PERL_ARGS_ASSERT_HV_EXISTS;

a1288 2
    PERL_ARGS_ASSERT_HV_FETCH;

a1306 2
    PERL_ARGS_ASSERT_HV_DELETE;

d1314 2
a1315 90
    return MUTABLE_SV(hv_common(hv, NULL, key, klen, k_flags, flags | HV_DELETE,
				NULL, 0));
}

/* Functions after here were made mathoms post 5.10.0 but pre 5.8.9 */
int
Perl_magic_setglob(pTHX_ SV *sv, MAGIC *mg)
{
    PERL_UNUSED_ARG(mg);
    PERL_UNUSED_ARG(sv);

    Perl_croak(aTHX_ "Perl_magic_setglob is dead code?");

    return 0;
}

AV *
Perl_newAV(pTHX)
{
    return MUTABLE_AV(newSV_type(SVt_PVAV));
    /* sv_upgrade does AvREAL_only():
    AvALLOC(av) = 0;
    AvARRAY(av) = NULL;
    AvMAX(av) = AvFILLp(av) = -1; */
}

HV *
Perl_newHV(pTHX)
{
    HV * const hv = MUTABLE_HV(newSV_type(SVt_PVHV));
    assert(!SvOK(hv));

    return hv;
}

int
Perl_magic_setbm(pTHX_ SV *sv, MAGIC *mg)
{
    return Perl_magic_setregexp(aTHX_ sv, mg);
}

int
Perl_magic_setfm(pTHX_ SV *sv, MAGIC *mg)
{
    return Perl_magic_setregexp(aTHX_ sv, mg);
}

void
Perl_sv_insert(pTHX_ SV *bigstr, STRLEN offset, STRLEN len, const char *little, STRLEN littlelen)
{
    PERL_ARGS_ASSERT_SV_INSERT;
    sv_insert_flags(bigstr, offset, len, little, littlelen, SV_GMAGIC);
}

void
Perl_save_freesv(pTHX_ SV *sv)
{
    dVAR;
    save_freesv(sv);
}

void
Perl_save_mortalizesv(pTHX_ SV *sv)
{
    dVAR;

    PERL_ARGS_ASSERT_SAVE_MORTALIZESV;

    save_mortalizesv(sv);
}

void
Perl_save_freeop(pTHX_ OP *o)
{
    dVAR;
    save_freeop(o);
}

void
Perl_save_freepv(pTHX_ char *pv)
{
    dVAR;
    save_freepv(pv);
}

void
Perl_save_op(pTHX)
{
    dVAR;
    save_op();
@


1.1.1.3
log
@Perl 5.12.2 from CPAN
@
text
@a78 1
PERL_CALLCONV IO * Perl_newIO(pTHX);
d616 23
d706 11
a719 1
    return NORMAL;
a724 1
    return NORMAL;
d1285 8
d1452 10
d1482 12
d1495 1
a1495 2
Perl_sv_insert(pTHX_ SV *const bigstr, const STRLEN offset, const STRLEN len, 
              const char *const little, const STRLEN littlelen)
a1536 32
}

#ifdef PERL_DONT_CREATE_GVSV
GV *
Perl_gv_SVadd(pTHX_ GV *gv)
{
    return gv_SVadd(gv);
}
#endif

GV *
Perl_gv_AVadd(pTHX_ GV *gv)
{
    return gv_AVadd(gv);
}

GV *
Perl_gv_HVadd(pTHX_ register GV *gv)
{
    return gv_HVadd(gv);
}

GV *
Perl_gv_IOadd(pTHX_ register GV *gv)
{
    return gv_IOadd(gv);
}

IO *
Perl_newIO(pTHX)
{
    return MUTABLE_IO(newSV_type(SVt_PVIO));
@


1.1.1.4
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d3 1
a3 2
 *    Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010,
 *    2011, 2012 by Larry Wall and others
a44 1
PERL_CALLCONV NV Perl_sv_2nv(pTHX_ register SV *sv);
d68 1
a79 10
PERL_CALLCONV I32 Perl_my_stat(pTHX);
PERL_CALLCONV I32 Perl_my_lstat(pTHX);
PERL_CALLCONV I32 Perl_sv_eq(pTHX_ register SV *sv1, register SV *sv2);
PERL_CALLCONV char * Perl_sv_collxfrm(pTHX_ SV *const sv, STRLEN *const nxp);
PERL_CALLCONV bool Perl_sv_2bool(pTHX_ register SV *const sv);
PERL_CALLCONV CV * Perl_newSUB(pTHX_ I32 floor, OP* o, OP* proto, OP* block);
PERL_CALLCONV UV Perl_to_utf8_lower(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp);
PERL_CALLCONV UV Perl_to_utf8_title(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp);
PERL_CALLCONV UV Perl_to_utf8_upper(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp);
PERL_CALLCONV UV Perl_to_utf8_fold(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp);
a112 1

a143 11
/* sv_2nv() is now a macro using Perl_sv_2nv_flags();
 * this function provided for binary compatibility only
 */

NV
Perl_sv_2nv(pTHX_ register SV *sv)
{
    return sv_2nv_flags(sv, SV_GMAGIC);
}


a158 1

a164 1
    PERL_ARGS_ASSERT_SV_2PV_NOLEN;
d588 1
a588 1
See L</gv_fetchmethod_autoload>.
d667 10
d684 425
d1174 1
a1174 1
    SSPUSHUV(SAVEt_LONG);
d1187 1
a1187 1
    SSPUSHUV(SAVEt_IV);
d1199 1
a1199 1
    SSPUSHUV(SAVEt_NSTAB);
d1216 1
a1216 1
	SSPUSHUV(SAVEt_ITEM);
a1508 99
}

I32
Perl_my_stat(pTHX)
{
    return my_stat_flags(SV_GMAGIC);
}

I32
Perl_my_lstat(pTHX)
{
    return my_lstat_flags(SV_GMAGIC);
}

I32
Perl_sv_eq(pTHX_ register SV *sv1, register SV *sv2)
{
    return sv_eq_flags(sv1, sv2, SV_GMAGIC);
}

#ifdef USE_LOCALE_COLLATE
char *
Perl_sv_collxfrm(pTHX_ SV *const sv, STRLEN *const nxp)
{
    return sv_collxfrm_flags(sv, nxp, SV_GMAGIC);
}
#endif

bool
Perl_sv_2bool(pTHX_ register SV *const sv)
{
    return sv_2bool_flags(sv, SV_GMAGIC);
}


/*
=for apidoc custom_op_name
Return the name for a given custom op. This was once used by the OP_NAME
macro, but is no longer: it has only been kept for compatibility, and
should not be used.

=for apidoc custom_op_desc
Return the description of a given custom op. This was once used by the
OP_DESC macro, but is no longer: it has only been kept for
compatibility, and should not be used.

=cut
*/

const char*
Perl_custom_op_name(pTHX_ const OP* o)
{
    PERL_ARGS_ASSERT_CUSTOM_OP_NAME;
    return XopENTRY(Perl_custom_op_xop(aTHX_ o), xop_name);
}

const char*
Perl_custom_op_desc(pTHX_ const OP* o)
{
    PERL_ARGS_ASSERT_CUSTOM_OP_DESC;
    return XopENTRY(Perl_custom_op_xop(aTHX_ o), xop_desc);
}

CV *
Perl_newSUB(pTHX_ I32 floor, OP *o, OP *proto, OP *block)
{
    return Perl_newATTRSUB(aTHX_ floor, o, proto, NULL, block);
}

UV
Perl_to_utf8_fold(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp)
{
    PERL_ARGS_ASSERT_TO_UTF8_FOLD;

    return _to_utf8_fold_flags(p, ustrp, lenp, FOLD_FLAGS_FULL, NULL);
}

UV
Perl_to_utf8_lower(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp)
{
    PERL_ARGS_ASSERT_TO_UTF8_LOWER;

    return _to_utf8_lower_flags(p, ustrp, lenp, FALSE, NULL);
}

UV
Perl_to_utf8_title(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp)
{
    PERL_ARGS_ASSERT_TO_UTF8_TITLE;

    return _to_utf8_title_flags(p, ustrp, lenp, FALSE, NULL);
}

UV
Perl_to_utf8_upper(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp)
{
    PERL_ARGS_ASSERT_TO_UTF8_UPPER;

    return _to_utf8_upper_flags(p, ustrp, lenp, FALSE, NULL);
@


1.1.1.5
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a28 2
 * The compilation of this file can be suppressed; see INSTALL
 *
a40 5
/* Not all of these have prototypes elsewhere, so do this to get
 * non-mangled names.
 */
START_EXTERN_C

d44 9
a52 9
PERL_CALLCONV IV Perl_sv_2iv(pTHX_ SV *sv);
PERL_CALLCONV UV Perl_sv_2uv(pTHX_ SV *sv);
PERL_CALLCONV NV Perl_sv_2nv(pTHX_ SV *sv);
PERL_CALLCONV char * Perl_sv_2pv(pTHX_ SV *sv, STRLEN *lp);
PERL_CALLCONV char * Perl_sv_2pv_nolen(pTHX_ SV *sv);
PERL_CALLCONV char * Perl_sv_2pvbyte_nolen(pTHX_ SV *sv);
PERL_CALLCONV char * Perl_sv_2pvutf8_nolen(pTHX_ SV *sv);
PERL_CALLCONV void Perl_sv_force_normal(pTHX_ SV *sv);
PERL_CALLCONV void Perl_sv_setsv(pTHX_ SV *dstr, SV *sstr);
d54 3
a56 3
PERL_CALLCONV void Perl_sv_catpvn_mg(pTHX_ SV *sv, const char *ptr, STRLEN len);
PERL_CALLCONV void Perl_sv_catsv(pTHX_ SV *dstr, SV *sstr);
PERL_CALLCONV void Perl_sv_catsv_mg(pTHX_ SV *dsv, SV *ssv);
d61 1
a61 1
PERL_CALLCONV STRLEN Perl_sv_utf8_upgrade(pTHX_ SV *sv);
d68 2
a69 2
PERL_CALLCONV bool Perl_do_open(pTHX_ GV *gv, const char *name, I32 len, int as_raw, int rawmode, int rawperm, PerlIO *supplied_fp);
PERL_CALLCONV bool Perl_do_aexec(pTHX_ SV *really, SV **mark, SV **sp);
d83 1
a83 1
PERL_CALLCONV I32 Perl_sv_eq(pTHX_ SV *sv1, SV *sv2);
d85 1
a85 1
PERL_CALLCONV bool Perl_sv_2bool(pTHX_ SV *const sv);
a90 1
PERL_CALLCONV SV *Perl_sv_mortalcopy(pTHX_ SV *const oldstr);
d141 1
a141 1
Perl_sv_2iv(pTHX_ SV *sv)
d151 1
a151 1
Perl_sv_2uv(pTHX_ SV *sv)
d161 1
a161 1
Perl_sv_2nv(pTHX_ SV *sv)
d172 1
a172 1
Perl_sv_2pv(pTHX_ SV *sv, STRLEN *lp)
d187 1
a187 1
Perl_sv_2pv_nolen(pTHX_ SV *sv)
d205 1
a205 1
Perl_sv_2pvbyte_nolen(pTHX_ SV *sv)
d224 1
a224 1
Perl_sv_2pvutf8_nolen(pTHX_ SV *sv)
d242 1
a242 1
Perl_sv_force_normal(pTHX_ SV *sv)
d254 1
a254 1
Perl_sv_setsv(pTHX_ SV *dstr, SV *sstr)
d282 1
a282 1
Perl_sv_catpvn_mg(pTHX_ SV *sv, const char *ptr, STRLEN len)
d294 1
a294 1
Perl_sv_catsv(pTHX_ SV *dstr, SV *sstr)
d310 1
a310 1
Perl_sv_catsv_mg(pTHX_ SV *dsv, SV *ssv)
d327 1
a327 1
Perl_sv_iv(pTHX_ SV *sv)
d349 1
a349 1
Perl_sv_uv(pTHX_ SV *sv)
d371 1
a371 1
Perl_sv_nv(pTHX_ SV *sv)
d407 1
a407 1
Perl_sv_pvn_nomg(pTHX_ SV *sv, STRLEN *lp)
d522 1
a522 1
Perl_sv_utf8_upgrade(pTHX_ SV *sv)
d643 1
a643 1
Perl_do_open(pTHX_ GV *gv, const char *name, I32 len, int as_raw,
d653 1
a653 1
Perl_do_open9(pTHX_ GV *gv, const char *name, I32 len, int
d684 1
a684 1
Perl_do_aexec(pTHX_ SV *really, SV **mark, SV **sp)
d793 1
a793 1
Perl_save_list(pTHX_ SV **sarg, I32 maxsarg)
d796 1
a796 1
    I32 i;
d801 2
a802 4
	SV *sv;
	SvGETMAGIC(sarg[i]);
	sv = newSV(0);
	sv_setsv_nomg(sv,sarg[i]);
d876 1
a876 1
Perl_pack_cat(pTHX_ SV *cat, const char *pat, const char *patend, SV **beglist, SV **endlist, SV ***next_in_list, U32 flags)
d1084 1
a1084 1
Perl_gv_HVadd(pTHX_ GV *gv)
d1090 1
a1090 1
Perl_gv_IOadd(pTHX_ GV *gv)
d1114 1
a1114 1
Perl_sv_eq(pTHX_ SV *sv1, SV *sv2)
d1128 1
a1128 1
Perl_sv_2bool(pTHX_ SV *const sv)
a1199 8
SV *
Perl_sv_mortalcopy(pTHX_ SV *const oldstr)
{
    return Perl_sv_mortalcopy_flags(aTHX_ oldstr, SV_GMAGIC);
}

END_EXTERN_C

d1206 1
a1206 1
 * indent-tabs-mode: nil
d1209 1
a1209 1
 * ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.6
log
@Import perl-5.20.1
@
text
@d131 1
a131 1
Taint an SV.  Use C<SvTAINTED_on> instead.
a150 2
    PERL_ARGS_ASSERT_SV_2IV;

a160 2
    PERL_ARGS_ASSERT_SV_2UV;

a181 2
    PERL_ARGS_ASSERT_SV_2PV;

d188 1
a188 1
Like C<sv_2pv()>, but doesn't return the length too.  You should usually
d244 1
a244 1
an xpvmg.  See also C<sv_force_normal_flags>.
d329 1
a329 1
cope with complex macro expressions.  Always use the macro instead.
d351 1
a351 1
cope with complex macro expressions.  Always use the macro instead.
d373 1
a373 1
cope with complex macro expressions.  Always use the macro instead.
d396 1
a396 1
cope with complex macro expressions.  Always use the macro instead.
d474 1
a474 1
which can't cope with complex macro expressions.  Always use the macro
d510 1
a510 1
which can't cope with complex macro expressions.  Always use the macro
a540 1
    int ret = 0;
d550 1
a550 3
    ret = PerlIO_vprintf(stream, format, arglist);
    va_end(arglist);
    return ret;
a557 1
    int ret = 0;
d564 1
a564 3
    ret = PerlIO_vprintf(PerlIO_stdout(), format, arglist);
    va_end(arglist);
    return ret;
d707 8
d839 1
a839 1
Tells an SV to use C<ptr> to find its string value.  Implemented by
d841 1
a841 1
magic.  See C<sv_usepvn_flags>.
d857 2
a858 3
The engine implementing unpack() Perl function.  Note: parameters strbeg,
new_s and ocnt are not used.  This call should not be used, use
unpackstring instead.
d879 2
a880 3
The engine implementing pack() Perl function.  Note: parameters
next_in_list and flags are not used.  This call should not be used; use
packlist instead.
d1146 1
a1146 1
Return the name for a given custom op.  This was once used by the OP_NAME
d1151 1
a1151 1
Return the description of a given custom op.  This was once used by the
d1162 1
a1162 1
    return XopENTRYCUSTOM(o, xop_name);
d1169 1
a1169 1
    return XopENTRYCUSTOM(o, xop_desc);
d1175 1
a1175 1
    return newATTRSUB(floor, o, proto, NULL, block);
d1183 1
a1183 1
    return _to_utf8_fold_flags(p, ustrp, lenp, FOLD_FLAGS_FULL);
d1191 1
a1191 1
    return _to_utf8_lower_flags(p, ustrp, lenp, FALSE);
d1199 1
a1199 1
    return _to_utf8_title_flags(p, ustrp, lenp, FALSE);
d1207 1
a1207 1
    return _to_utf8_upper_flags(p, ustrp, lenp, FALSE);
a1213 409
}

UV      /* Made into a function, so can be deprecated */
NATIVE_TO_NEED(const UV enc, const UV ch)
{
    PERL_UNUSED_ARG(enc);
    return ch;
}

UV      /* Made into a function, so can be deprecated */
ASCII_TO_NEED(const UV enc, const UV ch)
{
    PERL_UNUSED_ARG(enc);
    return ch;
}

bool
Perl_is_uni_alnum(pTHX_ UV c)
{
    return isWORDCHAR_uni(c);
}

bool
Perl_is_uni_alnumc(pTHX_ UV c)
{
    return isALNUM_uni(c);
}

bool
Perl_is_uni_alpha(pTHX_ UV c)
{
    return isALPHA_uni(c);
}

bool
Perl_is_uni_ascii(pTHX_ UV c)
{
    return isASCII_uni(c);
}

bool
Perl_is_uni_blank(pTHX_ UV c)
{
    return isBLANK_uni(c);
}

bool
Perl_is_uni_space(pTHX_ UV c)
{
    return isSPACE_uni(c);
}

bool
Perl_is_uni_digit(pTHX_ UV c)
{
    return isDIGIT_uni(c);
}

bool
Perl_is_uni_upper(pTHX_ UV c)
{
    return isUPPER_uni(c);
}

bool
Perl_is_uni_lower(pTHX_ UV c)
{
    return isLOWER_uni(c);
}

bool
Perl_is_uni_cntrl(pTHX_ UV c)
{
    return isCNTRL_L1(c);
}

bool
Perl_is_uni_graph(pTHX_ UV c)
{
    return isGRAPH_uni(c);
}

bool
Perl_is_uni_print(pTHX_ UV c)
{
    return isPRINT_uni(c);
}

bool
Perl_is_uni_punct(pTHX_ UV c)
{
    return isPUNCT_uni(c);
}

bool
Perl_is_uni_xdigit(pTHX_ UV c)
{
    return isXDIGIT_uni(c);
}

bool
Perl_is_uni_alnum_lc(pTHX_ UV c)
{
    return isWORDCHAR_LC_uvchr(c);
}

bool
Perl_is_uni_alnumc_lc(pTHX_ UV c)
{
    return isALPHANUMERIC_LC_uvchr(c);
}

bool
Perl_is_uni_idfirst_lc(pTHX_ UV c)
{
    /* XXX Should probably be something that resolves to the old IDFIRST, but
     * this function is deprecated, so not bothering */
    return isIDFIRST_LC_uvchr(c);
}

bool
Perl_is_uni_alpha_lc(pTHX_ UV c)
{
    return isALPHA_LC_uvchr(c);
}

bool
Perl_is_uni_ascii_lc(pTHX_ UV c)
{
    return isASCII_LC_uvchr(c);
}

bool
Perl_is_uni_blank_lc(pTHX_ UV c)
{
    return isBLANK_LC_uvchr(c);
}

bool
Perl_is_uni_space_lc(pTHX_ UV c)
{
    return isSPACE_LC_uvchr(c);
}

bool
Perl_is_uni_digit_lc(pTHX_ UV c)
{
    return isDIGIT_LC_uvchr(c);
}

bool
Perl_is_uni_upper_lc(pTHX_ UV c)
{
    return isUPPER_LC_uvchr(c);
}

bool
Perl_is_uni_lower_lc(pTHX_ UV c)
{
    return isLOWER_LC_uvchr(c);
}

bool
Perl_is_uni_cntrl_lc(pTHX_ UV c)
{
    return isCNTRL_LC_uvchr(c);
}

bool
Perl_is_uni_graph_lc(pTHX_ UV c)
{
    return isGRAPH_LC_uvchr(c);
}

bool
Perl_is_uni_print_lc(pTHX_ UV c)
{
    return isPRINT_LC_uvchr(c);
}

bool
Perl_is_uni_punct_lc(pTHX_ UV c)
{
    return isPUNCT_LC_uvchr(c);
}

bool
Perl_is_uni_xdigit_lc(pTHX_ UV c)
{
    return isXDIGIT_LC_uvchr(c);
}

U32
Perl_to_uni_upper_lc(pTHX_ U32 c)
{
    /* XXX returns only the first character -- do not use XXX */
    /* XXX no locale support yet */
    STRLEN len;
    U8 tmpbuf[UTF8_MAXBYTES_CASE+1];
    return (U32)to_uni_upper(c, tmpbuf, &len);
}

U32
Perl_to_uni_title_lc(pTHX_ U32 c)
{
    /* XXX returns only the first character XXX -- do not use XXX */
    /* XXX no locale support yet */
    STRLEN len;
    U8 tmpbuf[UTF8_MAXBYTES_CASE+1];
    return (U32)to_uni_title(c, tmpbuf, &len);
}

U32
Perl_to_uni_lower_lc(pTHX_ U32 c)
{
    /* XXX returns only the first character -- do not use XXX */
    /* XXX no locale support yet */
    STRLEN len;
    U8 tmpbuf[UTF8_MAXBYTES_CASE+1];
    return (U32)to_uni_lower(c, tmpbuf, &len);
}

bool
Perl_is_utf8_alnum(pTHX_ const U8 *p)
{
    dVAR;

    PERL_ARGS_ASSERT_IS_UTF8_ALNUM;

    /* NOTE: "IsWord", not "IsAlnum", since Alnum is a true
     * descendant of isalnum(3), in other words, it doesn't
     * contain the '_'. --jhi */
    return isWORDCHAR_utf8(p);
}

bool
Perl_is_utf8_alnumc(pTHX_ const U8 *p)
{
    dVAR;

    PERL_ARGS_ASSERT_IS_UTF8_ALNUMC;

    return isALPHANUMERIC_utf8(p);
}

bool
Perl_is_utf8_alpha(pTHX_ const U8 *p)
{
    dVAR;

    PERL_ARGS_ASSERT_IS_UTF8_ALPHA;

    return isALPHA_utf8(p);
}

bool
Perl_is_utf8_ascii(pTHX_ const U8 *p)
{
    dVAR;

    PERL_ARGS_ASSERT_IS_UTF8_ASCII;

    return isASCII_utf8(p);
}

bool
Perl_is_utf8_blank(pTHX_ const U8 *p)
{
    dVAR;

    PERL_ARGS_ASSERT_IS_UTF8_BLANK;

    return isBLANK_utf8(p);
}

bool
Perl_is_utf8_space(pTHX_ const U8 *p)
{
    dVAR;

    PERL_ARGS_ASSERT_IS_UTF8_SPACE;

    return isSPACE_utf8(p);
}

bool
Perl_is_utf8_perl_space(pTHX_ const U8 *p)
{
    dVAR;

    PERL_ARGS_ASSERT_IS_UTF8_PERL_SPACE;

    /* Only true if is an ASCII space-like character, and ASCII is invariant
     * under utf8, so can just use the macro */
    return isSPACE_A(*p);
}

bool
Perl_is_utf8_perl_word(pTHX_ const U8 *p)
{
    dVAR;

    PERL_ARGS_ASSERT_IS_UTF8_PERL_WORD;

    /* Only true if is an ASCII word character, and ASCII is invariant
     * under utf8, so can just use the macro */
    return isWORDCHAR_A(*p);
}

bool
Perl_is_utf8_digit(pTHX_ const U8 *p)
{
    dVAR;

    PERL_ARGS_ASSERT_IS_UTF8_DIGIT;

    return isDIGIT_utf8(p);
}

bool
Perl_is_utf8_posix_digit(pTHX_ const U8 *p)
{
    dVAR;

    PERL_ARGS_ASSERT_IS_UTF8_POSIX_DIGIT;

    /* Only true if is an ASCII digit character, and ASCII is invariant
     * under utf8, so can just use the macro */
    return isDIGIT_A(*p);
}

bool
Perl_is_utf8_upper(pTHX_ const U8 *p)
{
    dVAR;

    PERL_ARGS_ASSERT_IS_UTF8_UPPER;

    return isUPPER_utf8(p);
}

bool
Perl_is_utf8_lower(pTHX_ const U8 *p)
{
    dVAR;

    PERL_ARGS_ASSERT_IS_UTF8_LOWER;

    return isLOWER_utf8(p);
}

bool
Perl_is_utf8_cntrl(pTHX_ const U8 *p)
{
    dVAR;

    PERL_ARGS_ASSERT_IS_UTF8_CNTRL;

    return isCNTRL_utf8(p);
}

bool
Perl_is_utf8_graph(pTHX_ const U8 *p)
{
    dVAR;

    PERL_ARGS_ASSERT_IS_UTF8_GRAPH;

    return isGRAPH_utf8(p);
}

bool
Perl_is_utf8_print(pTHX_ const U8 *p)
{
    dVAR;

    PERL_ARGS_ASSERT_IS_UTF8_PRINT;

    return isPRINT_utf8(p);
}

bool
Perl_is_utf8_punct(pTHX_ const U8 *p)
{
    dVAR;

    PERL_ARGS_ASSERT_IS_UTF8_PUNCT;

    return isPUNCT_utf8(p);
}

bool
Perl_is_utf8_xdigit(pTHX_ const U8 *p)
{
    dVAR;

    PERL_ARGS_ASSERT_IS_UTF8_XDIGIT;

    return isXDIGIT_utf8(p);
}

bool
Perl_is_utf8_mark(pTHX_ const U8 *p)
{
    dVAR;

    PERL_ARGS_ASSERT_IS_UTF8_MARK;

    return _is_utf8_mark(p);
@


1.1.1.7
log
@Import perl-5.24.2
@
text
@a26 3
 * REMEMBER to update makedef.pl when adding a function to mathoms.c whose
 * name doesn't begin with "Perl_".
 *
a30 7
=head1 Obsolete backwards compatibility functions
Some of these are also deprecated.  You can exclude these from
your compiled Perl by adding this option to Configure:
C<-Accflags='-DNO_MATHOMS'>

=cut

a32 1

d115 1
a115 1
being zero.  See C<L</SvROK_off>>.
d250 1
a250 1
an C<xpvmg>.  See also C<L</sv_force_normal_flags>>.
d546 1
a722 1
    PERL_UNUSED_CONTEXT;
d731 1
a731 1
Exists to avoid test for a C<NULL> function pointer and because it could
d734 1
a734 1
"Superseded" by C<sv_nosharing()>.
d751 1
a751 1
Exists to avoid test for a C<NULL> function pointer and because it could
d754 1
a754 1
"Superseded" by C<sv_nosharing()>.
d769 2
d782 2
d795 2
d807 1
d845 1
a845 1
magic.  See C<L</sv_usepvn_flags>>.
d861 3
a863 3
The engine implementing C<unpack()> Perl function.  Note: parameters C<strbeg>,
C<new_s> and C<ocnt> are not used.  This call should not be used, use
C<unpackstring> instead.
d884 3
a886 3
The engine implementing C<pack()> Perl function.  Note: parameters
C<next_in_list> and C<flags> are not used.  This call should not be used; use
C<packlist> instead.
d1018 2
d1050 1
d1057 2
d1067 1
d1074 1
d1081 1
d1152 1
a1152 1
Return the name for a given custom op.  This was once used by the C<OP_NAME>
d1158 1
a1158 1
C<OP_DESC> macro, but is no longer: it has only been kept for
a1221 8
void
Perl_sv_copypv(pTHX_ SV *const dsv, SV *const ssv)
{
    PERL_ARGS_ASSERT_SV_COPYPV;

    sv_copypv_flags(dsv, ssv, 0);
}

a1235 16
bool      /* Made into a function, so can be deprecated */
Perl_isIDFIRST_lazy(pTHX_ const char* p)
{
    PERL_ARGS_ASSERT_ISIDFIRST_LAZY;

    return isIDFIRST_lazy_if(p,1);
}

bool      /* Made into a function, so can be deprecated */
Perl_isALNUM_lazy(pTHX_ const char* p)
{
    PERL_ARGS_ASSERT_ISALNUM_LAZY;

    return isALNUM_lazy_if(p,1);
}

a1256 1
    PERL_UNUSED_CONTEXT;
a1262 1
    PERL_UNUSED_CONTEXT;
a1268 1
    PERL_UNUSED_CONTEXT;
a1274 1
    PERL_UNUSED_CONTEXT;
a1280 1
    PERL_UNUSED_CONTEXT;
a1286 1
    PERL_UNUSED_CONTEXT;
a1292 1
    PERL_UNUSED_CONTEXT;
a1298 1
    PERL_UNUSED_CONTEXT;
a1304 1
    PERL_UNUSED_CONTEXT;
a1310 1
    PERL_UNUSED_CONTEXT;
a1316 1
    PERL_UNUSED_CONTEXT;
a1322 1
    PERL_UNUSED_CONTEXT;
a1328 1
    PERL_UNUSED_CONTEXT;
a1334 1
    PERL_UNUSED_CONTEXT;
a1342 1
    PERL_UNUSED_CONTEXT;
a1348 1
    PERL_UNUSED_CONTEXT;
a1354 1
    PERL_UNUSED_CONTEXT;
a1360 1
    PERL_UNUSED_CONTEXT;
a1370 40
Perl_is_uni_idfirst(pTHX_ UV c)
{
    U8 tmpbuf[UTF8_MAXBYTES+1];
    uvchr_to_utf8(tmpbuf, c);
    return _is_utf8_idstart(tmpbuf);
}

bool
Perl_is_utf8_idfirst(pTHX_ const U8 *p) /* The naming is historical. */
{
    PERL_ARGS_ASSERT_IS_UTF8_IDFIRST;

    return _is_utf8_idstart(p);
}

bool
Perl_is_utf8_xidfirst(pTHX_ const U8 *p) /* The naming is historical. */
{
    PERL_ARGS_ASSERT_IS_UTF8_XIDFIRST;

    return _is_utf8_xidstart(p);
}

bool
Perl_is_utf8_idcont(pTHX_ const U8 *p)
{
    PERL_ARGS_ASSERT_IS_UTF8_IDCONT;

    return _is_utf8_idcont(p);
}

bool
Perl_is_utf8_xidcont(pTHX_ const U8 *p)
{
    PERL_ARGS_ASSERT_IS_UTF8_XIDCONT;

    return _is_utf8_xidcont(p);
}

bool
d1445 2
d1458 2
d1468 2
d1478 2
a1480 1
    PERL_UNUSED_CONTEXT;
d1488 2
a1490 1
    PERL_UNUSED_CONTEXT;
d1498 2
a1500 1
    PERL_UNUSED_CONTEXT;
d1508 2
a1510 1
    PERL_UNUSED_CONTEXT;
d1520 2
a1522 1
    PERL_UNUSED_CONTEXT;
d1532 2
d1542 2
a1544 1
    PERL_UNUSED_CONTEXT;
d1554 2
d1564 2
d1574 2
a1576 1
    PERL_UNUSED_CONTEXT;
d1584 2
d1594 2
d1604 2
d1614 2
a1616 1
    PERL_UNUSED_CONTEXT;
d1624 2
a1630 131
/*
=for apidoc is_utf8_char

Tests if some arbitrary number of bytes begins in a valid UTF-8
character.  Note that an INVARIANT (i.e. ASCII on non-EBCDIC machines)
character is a valid UTF-8 character.  The actual number of bytes in the UTF-8
character will be returned if it is valid, otherwise 0.

This function is deprecated due to the possibility that malformed input could
cause reading beyond the end of the input buffer.  Use L</isUTF8_CHAR>
instead.

=cut */

STRLEN
Perl_is_utf8_char(const U8 *s)
{
    PERL_ARGS_ASSERT_IS_UTF8_CHAR;

    /* Assumes we have enough space, which is why this is deprecated */
    return isUTF8_CHAR(s, s + UTF8SKIP(s));
}

/*
=for apidoc is_utf8_char_buf

This is identical to the macro L</isUTF8_CHAR>.

=cut */

STRLEN
Perl_is_utf8_char_buf(const U8 *buf, const U8* buf_end)
{

    PERL_ARGS_ASSERT_IS_UTF8_CHAR_BUF;

    return isUTF8_CHAR(buf, buf_end);
}

/* DEPRECATED!
 * Like L</utf8_to_uvuni_buf>(), but should only be called when it is known that
 * there are no malformations in the input UTF-8 string C<s>.  Surrogates,
 * non-character code points, and non-Unicode code points are allowed */

UV
Perl_valid_utf8_to_uvuni(pTHX_ const U8 *s, STRLEN *retlen)
{
    PERL_ARGS_ASSERT_VALID_UTF8_TO_UVUNI;

    return NATIVE_TO_UNI(valid_utf8_to_uvchr(s, retlen));
}

/*
=for apidoc utf8_to_uvchr

Returns the native code point of the first character in the string C<s>
which is assumed to be in UTF-8 encoding; C<retlen> will be set to the
length, in bytes, of that character.

Some, but not all, UTF-8 malformations are detected, and in fact, some
malformed input could cause reading beyond the end of the input buffer, which
is why this function is deprecated.  Use L</utf8_to_uvchr_buf> instead.

If C<s> points to one of the detected malformations, and UTF8 warnings are
enabled, zero is returned and C<*retlen> is set (if C<retlen> isn't
C<NULL>) to -1.  If those warnings are off, the computed value if well-defined (or
the Unicode REPLACEMENT CHARACTER, if not) is silently returned, and C<*retlen>
is set (if C<retlen> isn't NULL) so that (S<C<s> + C<*retlen>>) is the
next possible position in C<s> that could begin a non-malformed character.
See L</utf8n_to_uvchr> for details on when the REPLACEMENT CHARACTER is returned.

=cut
*/

UV
Perl_utf8_to_uvchr(pTHX_ const U8 *s, STRLEN *retlen)
{
    PERL_ARGS_ASSERT_UTF8_TO_UVCHR;

    return utf8_to_uvchr_buf(s, s + UTF8_MAXBYTES, retlen);
}

/*
=for apidoc utf8_to_uvuni

Returns the Unicode code point of the first character in the string C<s>
which is assumed to be in UTF-8 encoding; C<retlen> will be set to the
length, in bytes, of that character.

Some, but not all, UTF-8 malformations are detected, and in fact, some
malformed input could cause reading beyond the end of the input buffer, which
is one reason why this function is deprecated.  The other is that only in
extremely limited circumstances should the Unicode versus native code point be
of any interest to you.  See L</utf8_to_uvuni_buf> for alternatives.

If C<s> points to one of the detected malformations, and UTF8 warnings are
enabled, zero is returned and C<*retlen> is set (if C<retlen> doesn't point to
NULL) to -1.  If those warnings are off, the computed value if well-defined (or
the Unicode REPLACEMENT CHARACTER, if not) is silently returned, and C<*retlen>
is set (if C<retlen> isn't NULL) so that (S<C<s> + C<*retlen>>) is the
next possible position in C<s> that could begin a non-malformed character.
See L</utf8n_to_uvchr> for details on when the REPLACEMENT CHARACTER is returned.

=cut
*/

UV
Perl_utf8_to_uvuni(pTHX_ const U8 *s, STRLEN *retlen)
{
    PERL_ARGS_ASSERT_UTF8_TO_UVUNI;

    return NATIVE_TO_UNI(valid_utf8_to_uvchr(s, retlen));
}

/*
=for apidoc Am|HV *|pad_compname_type|PADOFFSET po

Looks up the type of the lexical variable at position C<po> in the
currently-compiling pad.  If the variable is typed, the stash of the
class to which it is typed is returned.  If not, C<NULL> is returned.

=cut
*/

HV *
Perl_pad_compname_type(pTHX_ const PADOFFSET po)
{
    return PAD_COMPNAME_TYPE(po);
}


d1636 6
@


