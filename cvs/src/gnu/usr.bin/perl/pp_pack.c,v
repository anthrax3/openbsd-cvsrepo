head	1.2;
access;
symbols
	OPENBSD_6_0:1.1.1.11.0.10
	OPENBSD_6_0_BASE:1.1.1.11
	OPENBSD_5_9:1.1.1.11.0.4
	OPENBSD_5_9_BASE:1.1.1.11
	OPENBSD_5_8:1.1.1.11.0.6
	OPENBSD_5_8_BASE:1.1.1.11
	PERL_5_20_2:1.1.1.11
	OPENBSD_5_7:1.1.1.11.0.2
	OPENBSD_5_7_BASE:1.1.1.11
	PERL_5_20_1:1.1.1.11
	OPENBSD_5_6:1.1.1.10.0.4
	OPENBSD_5_6_BASE:1.1.1.10
	PERL_5_18_2:1.1.1.10
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.9.0.6
	OPENBSD_5_5_BASE:1.1.1.9
	OPENBSD_5_4:1.1.1.9.0.2
	OPENBSD_5_4_BASE:1.1.1.9
	PERL_5_16_3:1.1.1.9
	OPENBSD_5_3:1.1.1.8.0.10
	OPENBSD_5_3_BASE:1.1.1.8
	OPENBSD_5_2:1.1.1.8.0.8
	OPENBSD_5_2_BASE:1.1.1.8
	OPENBSD_5_1_BASE:1.1.1.8
	OPENBSD_5_1:1.1.1.8.0.6
	OPENBSD_5_0:1.1.1.8.0.4
	OPENBSD_5_0_BASE:1.1.1.8
	OPENBSD_4_9:1.1.1.8.0.2
	OPENBSD_4_9_BASE:1.1.1.8
	PERL_5_12_2:1.1.1.8
	OPENBSD_4_8:1.1.1.7.0.4
	OPENBSD_4_8_BASE:1.1.1.7
	OPENBSD_4_7:1.1.1.7.0.2
	OPENBSD_4_7_BASE:1.1.1.7
	PERL_5_10_1:1.1.1.7
	OPENBSD_4_6:1.1.1.6.0.6
	OPENBSD_4_6_BASE:1.1.1.6
	OPENBSD_4_5:1.1.1.6.0.2
	OPENBSD_4_5_BASE:1.1.1.6
	PERL_5_10_0:1.1.1.6
	OPENBSD_4_4:1.1.1.5.0.10
	OPENBSD_4_4_BASE:1.1.1.5
	OPENBSD_4_3:1.1.1.5.0.8
	OPENBSD_4_3_BASE:1.1.1.5
	OPENBSD_4_2:1.1.1.5.0.6
	OPENBSD_4_2_BASE:1.1.1.5
	OPENBSD_4_1:1.1.1.5.0.4
	OPENBSD_4_1_BASE:1.1.1.5
	OPENBSD_4_0:1.1.1.5.0.2
	OPENBSD_4_0_BASE:1.1.1.5
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.1.1.4.0.6
	OPENBSD_3_9_BASE:1.1.1.4
	OPENBSD_3_8:1.1.1.4.0.4
	OPENBSD_3_8_BASE:1.1.1.4
	OPENBSD_3_7:1.1.1.4.0.2
	OPENBSD_3_7_BASE:1.1.1.4
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.1.1.3.0.2
	OPENBSD_3_6_BASE:1.1.1.3
	PERL_5_8_5:1.1.1.3
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.2
date	2017.02.05.00.31.53;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2002.10.27.22.14.49;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.14.49;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.43.34;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.08.09.17.45.46;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2005.01.15.21.16.32;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.03.28.18.47.38;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.29.17.18.04;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2009.10.12.18.10.33;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2010.09.24.14.48.17;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2013.03.25.20.06.33;	author sthen;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2014.03.24.14.58.46;	author afresh1;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2014.11.17.20.52.38;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*    pp_pack.c
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 * He still hopefully carried some of his gear in his pack: a small tinder-box,
 * two small shallow pans, the smaller fitting into the larger; inside them a
 * wooden spoon, a short two-pronged fork and some skewers were stowed; and
 * hidden at the bottom of the pack in a flat wooden box a dwindling treasure,
 * some salt.
 *
 *     [p.653 of _The Lord of the Rings_, IV/iv: "Of Herbs and Stewed Rabbit"]
 */

/* This file contains pp ("push/pop") functions that
 * execute the opcodes that make up a perl program. A typical pp function
 * expects to find its arguments on the stack, and usually pushes its
 * results onto the stack, hence the 'pp' terminology. Each OP structure
 * contains a pointer to the relevant pp_foo() function.
 *
 * This particular file just contains pp_pack() and pp_unpack(). See the
 * other pp*.c files for the rest of the pp_ functions.
 */

#include "EXTERN.h"
#define PERL_IN_PP_PACK_C
#include "perl.h"

/* Types used by pack/unpack */ 
typedef enum {
  e_no_len,     /* no length  */
  e_number,     /* number, [] */
  e_star        /* asterisk   */
} howlen_t;

typedef struct tempsym {
  const char*    patptr;   /* current template char */
  const char*    patend;   /* one after last char   */
  const char*    grpbeg;   /* 1st char of ()-group  */
  const char*    grpend;   /* end of ()-group       */
  I32      code;     /* template code (!<>)   */
  I32      length;   /* length/repeat count   */
  howlen_t howlen;   /* how length is given   */ 
  int      level;    /* () nesting level      */
  U32      flags;    /* /=4, comma=2, pack=1  */
                     /*   and group modifiers */
  STRLEN   strbeg;   /* offset of group start */
  struct tempsym *previous; /* previous group */
} tempsym_t;

#define TEMPSYM_INIT(symptr, p, e, f) \
    STMT_START {	\
	(symptr)->patptr   = (p);	\
	(symptr)->patend   = (e);	\
	(symptr)->grpbeg   = NULL;	\
	(symptr)->grpend   = NULL;	\
	(symptr)->grpend   = NULL;	\
	(symptr)->code     = 0;		\
	(symptr)->length   = 0;		\
	(symptr)->howlen   = e_no_len;	\
	(symptr)->level    = 0;		\
	(symptr)->flags    = (f);	\
	(symptr)->strbeg   = 0;		\
	(symptr)->previous = NULL;	\
   } STMT_END

typedef union {
    NV nv;
    U8 bytes[sizeof(NV)];
} NV_bytes;

#if defined(HAS_LONG_DOUBLE) && defined(USE_LONG_DOUBLE)
typedef union {
    long double ld;
    U8 bytes[sizeof(long double)];
} ld_bytes;
#endif

#ifndef CHAR_BIT
# define CHAR_BIT	8
#endif
/* Maximum number of bytes to which a byte can grow due to upgrade */
#define UTF8_EXPAND	2

/*
 * Offset for integer pack/unpack.
 *
 * On architectures where I16 and I32 aren't really 16 and 32 bits,
 * which for now are all Crays, pack and unpack have to play games.
 */

/*
 * These values are required for portability of pack() output.
 * If they're not right on your machine, then pack() and unpack()
 * wouldn't work right anyway; you'll need to apply the Cray hack.
 * (I'd like to check them with #if, but you can't use sizeof() in
 * the preprocessor.)  --???
 */
/*
    The appropriate SHORTSIZE, INTSIZE, LONGSIZE, and LONGLONGSIZE
    defines are now in config.h.  --Andy Dougherty  April 1998
 */
#define SIZE16 2
#define SIZE32 4

/* CROSSCOMPILE and MULTIARCH are going to affect pp_pack() and pp_unpack().
   --jhi Feb 1999 */

#if U16SIZE > SIZE16 || U32SIZE > SIZE32
#  if BYTEORDER == 0x1234 || BYTEORDER == 0x12345678    /* little-endian */
#    define OFF16(p)	((char*)(p))
#    define OFF32(p)	((char*)(p))
#  else
#    if BYTEORDER == 0x4321 || BYTEORDER == 0x87654321  /* big-endian */
#      define OFF16(p)	((char*)(p) + (sizeof(U16) - SIZE16))
#      define OFF32(p)	((char*)(p) + (sizeof(U32) - SIZE32))
#    else
       ++++ bad cray byte order
#    endif
#  endif
#else
#  define OFF16(p)     ((char *) (p))
#  define OFF32(p)     ((char *) (p))
#endif

#define PUSH16(utf8, cur, p, needs_swap)                        \
       PUSH_BYTES(utf8, cur, OFF16(p), SIZE16, needs_swap)
#define PUSH32(utf8, cur, p, needs_swap)                        \
       PUSH_BYTES(utf8, cur, OFF32(p), SIZE32, needs_swap)

#if BYTEORDER == 0x4321 || BYTEORDER == 0x87654321  /* big-endian */
#  define NEEDS_SWAP(d)     (TYPE_ENDIANNESS(d) == TYPE_IS_LITTLE_ENDIAN)
#elif BYTEORDER == 0x1234 || BYTEORDER == 0x12345678  /* little-endian */
#  define NEEDS_SWAP(d)     (TYPE_ENDIANNESS(d) == TYPE_IS_BIG_ENDIAN)
#else
#  error "Unsupported byteorder"
        /* Need to add code here to re-instate mixed endian support.
           NEEDS_SWAP would need to hold a flag indicating which action to
           take, and S_reverse_copy and the code in S_utf8_to_bytes would need
           logic adding to deal with any mixed-endian transformations needed.
        */
#endif

/* Only to be used inside a loop (see the break) */
#define SHIFT_BYTES(utf8, s, strend, buf, len, datumtype, needs_swap)	\
STMT_START {						\
    if (UNLIKELY(utf8)) {                               \
        if (!S_utf8_to_bytes(aTHX_ &s, strend,		\
	  (char *) (buf), len, datumtype)) break;	\
    } else {						\
        if (UNLIKELY(needs_swap))                       \
            S_reverse_copy(s, (char *) (buf), len);     \
        else                                            \
            Copy(s, (char *) (buf), len, char);		\
        s += len;					\
    }							\
} STMT_END

#define SHIFT16(utf8, s, strend, p, datumtype, needs_swap)              \
       SHIFT_BYTES(utf8, s, strend, OFF16(p), SIZE16, datumtype, needs_swap)

#define SHIFT32(utf8, s, strend, p, datumtype, needs_swap)              \
       SHIFT_BYTES(utf8, s, strend, OFF32(p), SIZE32, datumtype, needs_swap)

#define SHIFT_VAR(utf8, s, strend, var, datumtype, needs_swap)          \
       SHIFT_BYTES(utf8, s, strend, &(var), sizeof(var), datumtype, needs_swap)

#define PUSH_VAR(utf8, aptr, var, needs_swap)           \
       PUSH_BYTES(utf8, aptr, &(var), sizeof(var), needs_swap)

/* Avoid stack overflow due to pathological templates. 100 should be plenty. */
#define MAX_SUB_TEMPLATE_LEVEL 100

/* flags (note that type modifiers can also be used as flags!) */
#define FLAG_WAS_UTF8	      0x40
#define FLAG_PARSE_UTF8       0x20	/* Parse as utf8 */
#define FLAG_UNPACK_ONLY_ONE  0x10
#define FLAG_DO_UTF8          0x08	/* The underlying string is utf8 */
#define FLAG_SLASH            0x04
#define FLAG_COMMA            0x02
#define FLAG_PACK             0x01

STATIC SV *
S_mul128(pTHX_ SV *sv, U8 m)
{
  STRLEN          len;
  char           *s = SvPV(sv, len);
  char           *t;

  PERL_ARGS_ASSERT_MUL128;

  if (!strnEQ(s, "0000", 4)) {  /* need to grow sv */
    SV * const tmpNew = newSVpvs("0000000000");

    sv_catsv(tmpNew, sv);
    SvREFCNT_dec(sv);		/* free old sv */
    sv = tmpNew;
    s = SvPV(sv, len);
  }
  t = s + len - 1;
  while (!*t)                   /* trailing '\0'? */
    t--;
  while (t > s) {
    const U32 i = ((*t - '0') << 7) + m;
    *(t--) = '0' + (char)(i % 10);
    m = (char)(i / 10);
  }
  return (sv);
}

/* Explosives and implosives. */

#define ISUUCHAR(ch)    (NATIVE_TO_LATIN1(ch) >= NATIVE_TO_LATIN1(' ')  \
                      && NATIVE_TO_LATIN1(ch) <  NATIVE_TO_LATIN1('a'))

/* type modifiers */
#define TYPE_IS_SHRIEKING	0x100
#define TYPE_IS_BIG_ENDIAN	0x200
#define TYPE_IS_LITTLE_ENDIAN	0x400
#define TYPE_IS_PACK		0x800
#define TYPE_ENDIANNESS_MASK	(TYPE_IS_BIG_ENDIAN|TYPE_IS_LITTLE_ENDIAN)
#define TYPE_MODIFIERS(t)	((t) & ~0xFF)
#define TYPE_NO_MODIFIERS(t)	((t) & 0xFF)

# define TYPE_ENDIANNESS(t)	((t) & TYPE_ENDIANNESS_MASK)
# define TYPE_NO_ENDIANNESS(t)	((t) & ~TYPE_ENDIANNESS_MASK)

# define ENDIANNESS_ALLOWED_TYPES   "sSiIlLqQjJfFdDpP("

#define PACK_SIZE_CANNOT_CSUM		0x80
#define PACK_SIZE_UNPREDICTABLE		0x40	/* Not a fixed size element */
#define PACK_SIZE_MASK			0x3F

#include "packsizetables.inc"

static void
S_reverse_copy(const char *src, char *dest, STRLEN len)
{
    dest += len;
    while (len--)
        *--dest = *src++;
}

STATIC U8
utf8_to_byte(pTHX_ const char **s, const char *end, I32 datumtype)
{
    STRLEN retlen;
    UV val = utf8n_to_uvchr((U8 *) *s, end-*s, &retlen,
			 ckWARN(WARN_UTF8) ? 0 : UTF8_ALLOW_ANY);
    /* We try to process malformed UTF-8 as much as possible (preferably with
       warnings), but these two mean we make no progress in the string and
       might enter an infinite loop */
    if (retlen == (STRLEN) -1 || retlen == 0)
	Perl_croak(aTHX_ "Malformed UTF-8 string in '%c' format in unpack",
		   (int) TYPE_NO_MODIFIERS(datumtype));
    if (val >= 0x100) {
	Perl_ck_warner(aTHX_ packWARN(WARN_UNPACK),
		       "Character in '%c' format wrapped in unpack",
		       (int) TYPE_NO_MODIFIERS(datumtype));
	val &= 0xff;
    }
    *s += retlen;
    return (U8)val;
}

#define SHIFT_BYTE(utf8, s, strend, datumtype) ((utf8) ? \
	utf8_to_byte(aTHX_ &(s), (strend), (datumtype)) : \
	*(U8 *)(s)++)

STATIC bool
S_utf8_to_bytes(pTHX_ const char **s, const char *end, const char *buf, int buf_len, I32 datumtype)
{
    UV val;
    STRLEN retlen;
    const char *from = *s;
    int bad = 0;
    const U32 flags = ckWARN(WARN_UTF8) ?
	UTF8_CHECK_ONLY : (UTF8_CHECK_ONLY | UTF8_ALLOW_ANY);
    const bool needs_swap = NEEDS_SWAP(datumtype);

    if (UNLIKELY(needs_swap))
        buf += buf_len;

    for (;buf_len > 0; buf_len--) {
	if (from >= end) return FALSE;
	val = utf8n_to_uvchr((U8 *) from, end-from, &retlen, flags);
	if (retlen == (STRLEN) -1 || retlen == 0) {
	    from += UTF8SKIP(from);
	    bad |= 1;
	} else from += retlen;
	if (val >= 0x100) {
	    bad |= 2;
	    val &= 0xff;
	}
        if (UNLIKELY(needs_swap))
            *(U8 *)--buf = (U8)val;
        else
            *(U8 *)buf++ = (U8)val;
    }
    /* We have enough characters for the buffer. Did we have problems ? */
    if (bad) {
	if (bad & 1) {
	    /* Rewalk the string fragment while warning */
	    const char *ptr;
	    const int flags = ckWARN(WARN_UTF8) ? 0 : UTF8_ALLOW_ANY;
	    for (ptr = *s; ptr < from; ptr += UTF8SKIP(ptr)) {
		if (ptr >= end) break;
		utf8n_to_uvchr((U8 *) ptr, end-ptr, &retlen, flags);
	    }
	    if (from > end) from = end;
	}
	if ((bad & 2))
	    Perl_ck_warner(aTHX_ packWARN(datumtype & TYPE_IS_PACK ?
				       WARN_PACK : WARN_UNPACK),
			   "Character(s) in '%c' format wrapped in %s",
			   (int) TYPE_NO_MODIFIERS(datumtype),
			   datumtype & TYPE_IS_PACK ? "pack" : "unpack");
    }
    *s = from;
    return TRUE;
}

STATIC char *
S_my_bytes_to_utf8(const U8 *start, STRLEN len, char *dest, const bool needs_swap) {
    PERL_ARGS_ASSERT_MY_BYTES_TO_UTF8;

    if (UNLIKELY(needs_swap)) {
        const U8 *p = start + len;
        while (p-- > start) {
            append_utf8_from_native_byte(*p, (U8 **) & dest);
        }
    } else {
        const U8 * const end = start + len;
        while (start < end) {
            append_utf8_from_native_byte(*start, (U8 **) & dest);
            start++;
        }
    }
    return dest;
}

#define PUSH_BYTES(utf8, cur, buf, len, needs_swap)             \
STMT_START {							\
    if (UNLIKELY(utf8))	                                        \
	(cur) = my_bytes_to_utf8((U8 *) buf, len, (cur), needs_swap);       \
    else {							\
        if (UNLIKELY(needs_swap))                               \
            S_reverse_copy((char *)(buf), cur, len);            \
        else                                                    \
            Copy(buf, cur, len, char);				\
	(cur) += (len);						\
    }								\
} STMT_END

#define GROWING(utf8, cat, start, cur, in_len)	\
STMT_START {					\
    STRLEN glen = (in_len);			\
    if (utf8) glen *= UTF8_EXPAND;		\
    if ((cur) + glen >= (start) + SvLEN(cat)) {	\
	(start) = sv_exp_grow(cat, glen);	\
	(cur) = (start) + SvCUR(cat);		\
    }						\
} STMT_END

#define PUSH_GROWING_BYTES(utf8, cat, start, cur, buf, in_len) \
STMT_START {					\
    const STRLEN glen = (in_len);		\
    STRLEN gl = glen;				\
    if (utf8) gl *= UTF8_EXPAND;		\
    if ((cur) + gl >= (start) + SvLEN(cat)) {	\
        *cur = '\0';				\
        SvCUR_set((cat), (cur) - (start));	\
	(start) = sv_exp_grow(cat, gl);		\
	(cur) = (start) + SvCUR(cat);		\
    }						\
    PUSH_BYTES(utf8, cur, buf, glen, 0);        \
} STMT_END

#define PUSH_BYTE(utf8, s, byte)		\
STMT_START {					\
    if (utf8) {					\
	const U8 au8 = (byte);			\
	(s) = my_bytes_to_utf8(&au8, 1, (s), 0);\
    } else *(U8 *)(s)++ = (byte);		\
} STMT_END

/* Only to be used inside a loop (see the break) */
#define NEXT_UNI_VAL(val, cur, str, end, utf8_flags)		\
STMT_START {							\
    STRLEN retlen;						\
    if (str >= end) break;					\
    val = utf8n_to_uvchr((U8 *) str, end-str, &retlen, utf8_flags);	\
    if (retlen == (STRLEN) -1 || retlen == 0) {			\
	*cur = '\0';						\
	Perl_croak(aTHX_ "Malformed UTF-8 string in pack");	\
    }								\
    str += retlen;						\
} STMT_END

static const char *_action( const tempsym_t* symptr )
{
    return (const char *)(( symptr->flags & FLAG_PACK ) ? "pack" : "unpack");
}

/* Returns the sizeof() struct described by pat */
STATIC I32
S_measure_struct(pTHX_ tempsym_t* symptr)
{
    I32 total = 0;

    PERL_ARGS_ASSERT_MEASURE_STRUCT;

    while (next_symbol(symptr)) {
	I32 len;
	int size;

        switch (symptr->howlen) {
	  case e_star:
   	    Perl_croak(aTHX_ "Within []-length '*' not allowed in %s",
                        _action( symptr ) );

	  default:
	    /* e_no_len and e_number */
	    len = symptr->length;
	    break;
        }

	size = packprops[TYPE_NO_ENDIANNESS(symptr->code)] & PACK_SIZE_MASK;
	if (!size) {
            int star;
	    /* endianness doesn't influence the size of a type */
	    switch(TYPE_NO_ENDIANNESS(symptr->code)) {
	    default:
		Perl_croak(aTHX_ "Invalid type '%c' in %s",
			   (int)TYPE_NO_MODIFIERS(symptr->code),
                           _action( symptr ) );
	    case '.' | TYPE_IS_SHRIEKING:
	    case '@@' | TYPE_IS_SHRIEKING:
	    case '@@':
	    case '.':
	    case '/':
	    case 'U':			/* XXXX Is it correct? */
	    case 'w':
	    case 'u':
		Perl_croak(aTHX_ "Within []-length '%c' not allowed in %s",
			   (int) TYPE_NO_MODIFIERS(symptr->code),
                           _action( symptr ) );
	    case '%':
		size = 0;
		break;
	    case '(':
	    {
		tempsym_t savsym = *symptr;
		symptr->patptr = savsym.grpbeg;
		symptr->patend = savsym.grpend;
		/* XXXX Theoretically, we need to measure many times at
		   different positions, since the subexpression may contain
		   alignment commands, but be not of aligned length.
		   Need to detect this and croak().  */
		size = measure_struct(symptr);
		*symptr = savsym;
		break;
	    }
	    case 'X' | TYPE_IS_SHRIEKING:
		/* XXXX Is this useful?  Then need to treat MEASURE_BACKWARDS.
		 */
		if (!len)		/* Avoid division by 0 */
		    len = 1;
		len = total % len;	/* Assumed: the start is aligned. */
		/* FALLTHROUGH */
	    case 'X':
		size = -1;
		if (total < len)
                    Perl_croak(aTHX_ "'X' outside of string in %s", _action( symptr ) );
		break;
	    case 'x' | TYPE_IS_SHRIEKING:
		if (!len)		/* Avoid division by 0 */
		    len = 1;
		star = total % len;	/* Assumed: the start is aligned. */
		if (star)		/* Other portable ways? */
		    len = len - star;
		else
		    len = 0;
		/* FALLTHROUGH */
	    case 'x':
	    case 'A':
	    case 'Z':
	    case 'a':
		size = 1;
		break;
	    case 'B':
	    case 'b':
		len = (len + 7)/8;
		size = 1;
		break;
	    case 'H':
	    case 'h':
		len = (len + 1)/2;
		size = 1;
		break;

	    case 'P':
		len = 1;
		size = sizeof(char*);
		break;
	    }
	}
	total += len * size;
    }
    return total;
}


/* locate matching closing parenthesis or bracket
 * returns char pointer to char after match, or NULL
 */
STATIC const char *
S_group_end(pTHX_ const char *patptr, const char *patend, char ender)
{
    PERL_ARGS_ASSERT_GROUP_END;

    while (patptr < patend) {
	const char c = *patptr++;

	if (isSPACE(c))
	    continue;
	else if (c == ender)
	    return patptr-1;
	else if (c == '#') {
	    while (patptr < patend && *patptr != '\n')
		patptr++;
	    continue;
	} else if (c == '(')
	    patptr = group_end(patptr, patend, ')') + 1;
	else if (c == '[')
	    patptr = group_end(patptr, patend, ']') + 1;
    }
    Perl_croak(aTHX_ "No group ending character '%c' found in template",
               ender);
    NOT_REACHED; /* NOTREACHED */
}


/* Convert unsigned decimal number to binary.
 * Expects a pointer to the first digit and address of length variable
 * Advances char pointer to 1st non-digit char and returns number
 */
STATIC const char *
S_get_num(pTHX_ const char *patptr, I32 *lenptr )
{
  I32 len = *patptr++ - '0';

  PERL_ARGS_ASSERT_GET_NUM;

  while (isDIGIT(*patptr)) {
    if (len >= 0x7FFFFFFF/10)
      Perl_croak(aTHX_ "pack/unpack repeat count overflow");
    len = (len * 10) + (*patptr++ - '0');
  }
  *lenptr = len;
  return patptr;
}

/* The marvellous template parsing routine: Using state stored in *symptr,
 * locates next template code and count
 */
STATIC bool
S_next_symbol(pTHX_ tempsym_t* symptr )
{
  const char* patptr = symptr->patptr;
  const char* const patend = symptr->patend;

  PERL_ARGS_ASSERT_NEXT_SYMBOL;

  symptr->flags &= ~FLAG_SLASH;

  while (patptr < patend) {
    if (isSPACE(*patptr))
      patptr++;
    else if (*patptr == '#') {
      patptr++;
      while (patptr < patend && *patptr != '\n')
	patptr++;
      if (patptr < patend)
	patptr++;
    } else {
      /* We should have found a template code */
      I32 code = *patptr++ & 0xFF;
      U32 inherited_modifiers = 0;

      if (code == ','){ /* grandfather in commas but with a warning */
	if (((symptr->flags & FLAG_COMMA) == 0) && ckWARN(WARN_UNPACK)){
          symptr->flags |= FLAG_COMMA;
	  Perl_warner(aTHX_ packWARN(WARN_UNPACK),
	 	      "Invalid type ',' in %s", _action( symptr ) );
        }
	continue;
      }

      /* for '(', skip to ')' */
      if (code == '(') {
        if( isDIGIT(*patptr) || *patptr == '*' || *patptr == '[' )
          Perl_croak(aTHX_ "()-group starts with a count in %s",
                        _action( symptr ) );
        symptr->grpbeg = patptr;
        patptr = 1 + ( symptr->grpend = group_end(patptr, patend, ')') );
        if( symptr->level >= MAX_SUB_TEMPLATE_LEVEL )
	  Perl_croak(aTHX_ "Too deeply nested ()-groups in %s",
                        _action( symptr ) );
      }

      /* look for group modifiers to inherit */
      if (TYPE_ENDIANNESS(symptr->flags)) {
        if (strchr(ENDIANNESS_ALLOWED_TYPES, TYPE_NO_MODIFIERS(code)))
          inherited_modifiers |= TYPE_ENDIANNESS(symptr->flags);
      }

      /* look for modifiers */
      while (patptr < patend) {
        const char *allowed;
        I32 modifier;
        switch (*patptr) {
          case '!':
            modifier = TYPE_IS_SHRIEKING;
            allowed = "sSiIlLxXnNvV@@.";
            break;
          case '>':
            modifier = TYPE_IS_BIG_ENDIAN;
            allowed = ENDIANNESS_ALLOWED_TYPES;
            break;
          case '<':
            modifier = TYPE_IS_LITTLE_ENDIAN;
            allowed = ENDIANNESS_ALLOWED_TYPES;
            break;
          default:
            allowed = "";
            modifier = 0;
            break;
        }

        if (modifier == 0)
          break;

        if (!strchr(allowed, TYPE_NO_MODIFIERS(code)))
          Perl_croak(aTHX_ "'%c' allowed only after types %s in %s", *patptr,
                        allowed, _action( symptr ) );

        if (TYPE_ENDIANNESS(code | modifier) == TYPE_ENDIANNESS_MASK)
          Perl_croak(aTHX_ "Can't use both '<' and '>' after type '%c' in %s",
                     (int) TYPE_NO_MODIFIERS(code), _action( symptr ) );
        else if (TYPE_ENDIANNESS(code | modifier | inherited_modifiers) ==
                 TYPE_ENDIANNESS_MASK)
          Perl_croak(aTHX_ "Can't use '%c' in a group with different byte-order in %s",
                     *patptr, _action( symptr ) );

        if ((code & modifier)) {
	    Perl_ck_warner(aTHX_ packWARN(WARN_UNPACK),
			   "Duplicate modifier '%c' after '%c' in %s",
			   *patptr, (int) TYPE_NO_MODIFIERS(code),
			   _action( symptr ) );
        }

        code |= modifier;
        patptr++;
      }

      /* inherit modifiers */
      code |= inherited_modifiers;

      /* look for count and/or / */
      if (patptr < patend) {
	if (isDIGIT(*patptr)) {
 	  patptr = get_num( patptr, &symptr->length );
          symptr->howlen = e_number;

        } else if (*patptr == '*') {
          patptr++;
          symptr->howlen = e_star;

        } else if (*patptr == '[') {
          const char* lenptr = ++patptr;
          symptr->howlen = e_number;
          patptr = group_end( patptr, patend, ']' ) + 1;
          /* what kind of [] is it? */
          if (isDIGIT(*lenptr)) {
            lenptr = get_num( lenptr, &symptr->length );
            if( *lenptr != ']' )
              Perl_croak(aTHX_ "Malformed integer in [] in %s",
                            _action( symptr ) );
          } else {
            tempsym_t savsym = *symptr;
            symptr->patend = patptr-1;
            symptr->patptr = lenptr;
            savsym.length = measure_struct(symptr);
            *symptr = savsym;
          }
        } else {
          symptr->howlen = e_no_len;
          symptr->length = 1;
        }

        /* try to find / */
        while (patptr < patend) {
          if (isSPACE(*patptr))
            patptr++;
          else if (*patptr == '#') {
            patptr++;
            while (patptr < patend && *patptr != '\n')
	      patptr++;
            if (patptr < patend)
	      patptr++;
          } else {
            if (*patptr == '/') {
              symptr->flags |= FLAG_SLASH;
              patptr++;
              if (patptr < patend &&
                  (isDIGIT(*patptr) || *patptr == '*' || *patptr == '['))
                Perl_croak(aTHX_ "'/' does not take a repeat count in %s",
                            _action( symptr ) );
            }
            break;
	  }
	}
      } else {
        /* at end - no count, no / */
        symptr->howlen = e_no_len;
        symptr->length = 1;
      }

      symptr->code = code;
      symptr->patptr = patptr;
      return TRUE;
    }
  }
  symptr->patptr = patptr;
  return FALSE;
}

/*
   There is no way to cleanly handle the case where we should process the
   string per byte in its upgraded form while it's really in downgraded form
   (e.g. estimates like strend-s as an upper bound for the number of
   characters left wouldn't work). So if we foresee the need of this
   (pattern starts with U or contains U0), we want to work on the encoded
   version of the string. Users are advised to upgrade their pack string
   themselves if they need to do a lot of unpacks like this on it
*/
STATIC bool
need_utf8(const char *pat, const char *patend)
{
    bool first = TRUE;

    PERL_ARGS_ASSERT_NEED_UTF8;

    while (pat < patend) {
	if (pat[0] == '#') {
	    pat++;
	    pat = (const char *) memchr(pat, '\n', patend-pat);
	    if (!pat) return FALSE;
	} else if (pat[0] == 'U') {
	    if (first || pat[1] == '0') return TRUE;
	} else first = FALSE;
	pat++;
    }
    return FALSE;
}

STATIC char
first_symbol(const char *pat, const char *patend) {
    PERL_ARGS_ASSERT_FIRST_SYMBOL;

    while (pat < patend) {
	if (pat[0] != '#') return pat[0];
	pat++;
	pat = (const char *) memchr(pat, '\n', patend-pat);
	if (!pat) return 0;
	pat++;
    }
    return 0;
}

/*

=head1 Pack and Unpack

=for apidoc unpackstring

The engine implementing the C<unpack()> Perl function.

Using the template C<pat..patend>, this function unpacks the string
C<s..strend> into a number of mortal SVs, which it pushes onto the perl
argument (C<@@_>) stack (so you will need to issue a C<PUTBACK> before and
C<SPAGAIN> after the call to this function).  It returns the number of
pushed elements.

The C<strend> and C<patend> pointers should point to the byte following the
last character of each string.

Although this function returns its values on the perl argument stack, it
doesn't take any parameters from that stack (and thus in particular
there's no need to do a C<PUSHMARK> before calling it, unlike L</call_pv> for
example).

=cut */

I32
Perl_unpackstring(pTHX_ const char *pat, const char *patend, const char *s, const char *strend, U32 flags)
{
    tempsym_t sym;

    PERL_ARGS_ASSERT_UNPACKSTRING;

    if (flags & FLAG_DO_UTF8) flags |= FLAG_WAS_UTF8;
    else if (need_utf8(pat, patend)) {
	/* We probably should try to avoid this in case a scalar context call
	   wouldn't get to the "U0" */
	STRLEN len = strend - s;
	s = (char *) bytes_to_utf8((U8 *) s, &len);
	SAVEFREEPV(s);
	strend = s + len;
	flags |= FLAG_DO_UTF8;
    }

    if (first_symbol(pat, patend) != 'U' && (flags & FLAG_DO_UTF8))
	flags |= FLAG_PARSE_UTF8;

    TEMPSYM_INIT(&sym, pat, patend, flags);

    return unpack_rec(&sym, s, s, strend, NULL );
}

STATIC I32
S_unpack_rec(pTHX_ tempsym_t* symptr, const char *s, const char *strbeg, const char *strend, const char **new_s )
{
    dSP;
    SV *sv = NULL;
    const I32 start_sp_offset = SP - PL_stack_base;
    howlen_t howlen;
    I32 checksum = 0;
    UV cuv = 0;
    NV cdouble = 0.0;
    const int bits_in_uv = CHAR_BIT * sizeof(cuv);
    bool beyond = FALSE;
    bool explicit_length;
    const bool unpack_only_one = (symptr->flags & FLAG_UNPACK_ONLY_ONE) != 0;
    bool utf8 = (symptr->flags & FLAG_PARSE_UTF8) ? 1 : 0;

    PERL_ARGS_ASSERT_UNPACK_REC;

    symptr->strbeg = s - strbeg;

    while (next_symbol(symptr)) {
	packprops_t props;
	I32 len;
        I32 datumtype = symptr->code;
        bool needs_swap;
	/* do first one only unless in list context
	   / is implemented by unpacking the count, then popping it from the
	   stack, so must check that we're not in the middle of a /  */
        if ( unpack_only_one
	     && (SP - PL_stack_base == start_sp_offset + 1)
	     && (datumtype != '/') )   /* XXX can this be omitted */
            break;

        switch (howlen = symptr->howlen) {
	  case e_star:
	    len = strend - strbeg;	/* long enough */
	    break;
	  default:
	    /* e_no_len and e_number */
	    len = symptr->length;
	    break;
        }

        explicit_length = TRUE;
      redo_switch:
        beyond = s >= strend;

	props = packprops[TYPE_NO_ENDIANNESS(datumtype)];
	if (props) {
	    /* props nonzero means we can process this letter. */
            const long size = props & PACK_SIZE_MASK;
            const long howmany = (strend - s) / size;
	    if (len > howmany)
		len = howmany;

	    if (!checksum || (props & PACK_SIZE_CANNOT_CSUM)) {
		if (len && unpack_only_one) len = 1;
		EXTEND(SP, len);
		EXTEND_MORTAL(len);
	    }
	}

        needs_swap = NEEDS_SWAP(datumtype);

	switch(TYPE_NO_ENDIANNESS(datumtype)) {
	default:
	    Perl_croak(aTHX_ "Invalid type '%c' in unpack", (int)TYPE_NO_MODIFIERS(datumtype) );

	case '%':
	    if (howlen == e_no_len)
		len = 16;		/* len is not specified */
	    checksum = len;
	    cuv = 0;
	    cdouble = 0;
	    continue;

	case '(':
	{
            tempsym_t savsym = *symptr;
            const U32 group_modifiers = TYPE_MODIFIERS(datumtype & ~symptr->flags);
	    symptr->flags |= group_modifiers;
            symptr->patend = savsym.grpend;
	    symptr->previous = &savsym;
            symptr->level++;
	    PUTBACK;
	    if (len && unpack_only_one) len = 1;
	    while (len--) {
  	        symptr->patptr = savsym.grpbeg;
		if (utf8) symptr->flags |=  FLAG_PARSE_UTF8;
		else      symptr->flags &= ~FLAG_PARSE_UTF8;
 	        unpack_rec(symptr, s, strbeg, strend, &s);
                if (s == strend && savsym.howlen == e_star)
		    break; /* No way to continue */
	    }
	    SPAGAIN;
            savsym.flags = symptr->flags & ~group_modifiers;
            *symptr = savsym;
	    break;
	}
	case '.' | TYPE_IS_SHRIEKING:
	case '.': {
	    const char *from;
	    SV *sv;
	    const bool u8 = utf8 && !(datumtype & TYPE_IS_SHRIEKING);
	    if (howlen == e_star) from = strbeg;
	    else if (len <= 0) from = s;
	    else {
		tempsym_t *group = symptr;

		while (--len && group) group = group->previous;
		from = group ? strbeg + group->strbeg : strbeg;
	    }
	    sv = from <= s ?
		newSVuv(  u8 ? (UV) utf8_length((const U8*)from, (const U8*)s) : (UV) (s-from)) :
		newSViv(-(u8 ? (IV) utf8_length((const U8*)s, (const U8*)from) : (IV) (from-s)));
	    mXPUSHs(sv);
	    break;
	}
	case '@@' | TYPE_IS_SHRIEKING:
	case '@@':
	    s = strbeg + symptr->strbeg;
	    if (utf8  && !(datumtype & TYPE_IS_SHRIEKING))
	    {
		while (len > 0) {
		    if (s >= strend)
			Perl_croak(aTHX_ "'@@' outside of string in unpack");
		    s += UTF8SKIP(s);
		    len--;
		}
		if (s > strend)
		    Perl_croak(aTHX_ "'@@' outside of string with malformed UTF-8 in unpack");
	    } else {
		if (strend-s < len)
		    Perl_croak(aTHX_ "'@@' outside of string in unpack");
		s += len;
	    }
	    break;
 	case 'X' | TYPE_IS_SHRIEKING:
 	    if (!len)			/* Avoid division by 0 */
 		len = 1;
	    if (utf8) {
		const char *hop, *last;
		I32 l = len;
		hop = last = strbeg;
		while (hop < s) {
		    hop += UTF8SKIP(hop);
		    if (--l == 0) {
			last = hop;
			l = len;
		    }
		}
		if (last > s)
		    Perl_croak(aTHX_ "Malformed UTF-8 string in unpack");
		s = last;
		break;
	    }
	    len = (s - strbeg) % len;
 	    /* FALLTHROUGH */
	case 'X':
	    if (utf8) {
		while (len > 0) {
		    if (s <= strbeg)
			Perl_croak(aTHX_ "'X' outside of string in unpack");
		    while (--s, UTF8_IS_CONTINUATION(*s)) {
			if (s <= strbeg)
			    Perl_croak(aTHX_ "'X' outside of string in unpack");
		    }
		    len--;
		}
	    } else {
		if (len > s - strbeg)
		    Perl_croak(aTHX_ "'X' outside of string in unpack" );
		s -= len;
	    }
	    break;
 	case 'x' | TYPE_IS_SHRIEKING: {
            I32 ai32;
 	    if (!len)			/* Avoid division by 0 */
 		len = 1;
	    if (utf8) ai32 = utf8_length((U8 *) strbeg, (U8 *) s) % len;
	    else      ai32 = (s - strbeg)                         % len;
	    if (ai32 == 0) break;
	    len -= ai32;
            }
 	    /* FALLTHROUGH */
	case 'x':
	    if (utf8) {
		while (len>0) {
		    if (s >= strend)
			Perl_croak(aTHX_ "'x' outside of string in unpack");
		    s += UTF8SKIP(s);
		    len--;
		}
	    } else {
		if (len > strend - s)
		    Perl_croak(aTHX_ "'x' outside of string in unpack");
		s += len;
	    }
	    break;
	case '/':
	    Perl_croak(aTHX_ "'/' must follow a numeric type in unpack");

	case 'A':
	case 'Z':
	case 'a':
	    if (checksum) {
		/* Preliminary length estimate is assumed done in 'W' */
		if (len > strend - s) len = strend - s;
		goto W_checksum;
	    }
	    if (utf8) {
		I32 l;
		const char *hop;
		for (l=len, hop=s; l>0; l--, hop += UTF8SKIP(hop)) {
		    if (hop >= strend) {
			if (hop > strend)
			    Perl_croak(aTHX_ "Malformed UTF-8 string in unpack");
			break;
		    }
		}
		if (hop > strend)
		    Perl_croak(aTHX_ "Malformed UTF-8 string in unpack");
		len = hop - s;
	    } else if (len > strend - s)
		len = strend - s;

	    if (datumtype == 'Z') {
		/* 'Z' strips stuff after first null */
		const char *ptr, *end;
		end = s + len;
		for (ptr = s; ptr < end; ptr++) if (*ptr == 0) break;
		sv = newSVpvn(s, ptr-s);
		if (howlen == e_star) /* exact for 'Z*' */
		    len = ptr-s + (ptr != strend ? 1 : 0);
	    } else if (datumtype == 'A') {
		/* 'A' strips both nulls and spaces */
		const char *ptr;
		if (utf8 && (symptr->flags & FLAG_WAS_UTF8)) {
		    for (ptr = s+len-1; ptr >= s; ptr--)
			if (*ptr != 0 && !UTF8_IS_CONTINUATION(*ptr) &&
			    !isSPACE_utf8(ptr)) break;
		    if (ptr >= s) ptr += UTF8SKIP(ptr);
		    else ptr++;
		    if (ptr > s+len)
			Perl_croak(aTHX_ "Malformed UTF-8 string in unpack");
		} else {
		    for (ptr = s+len-1; ptr >= s; ptr--)
			if (*ptr != 0 && !isSPACE(*ptr)) break;
		    ptr++;
		}
		sv = newSVpvn(s, ptr-s);
	    } else sv = newSVpvn(s, len);

	    if (utf8) {
		SvUTF8_on(sv);
		/* Undo any upgrade done due to need_utf8() */
		if (!(symptr->flags & FLAG_WAS_UTF8))
		    sv_utf8_downgrade(sv, 0);
	    }
	    mXPUSHs(sv);
	    s += len;
	    break;
	case 'B':
	case 'b': {
	    char *str;
	    if (howlen == e_star || len > (strend - s) * 8)
		len = (strend - s) * 8;
	    if (checksum) {
		if (utf8)
		    while (len >= 8 && s < strend) {
			cuv += PL_bitcount[utf8_to_byte(aTHX_ &s, strend, datumtype)];
			len -= 8;
		    }
		else
		    while (len >= 8) {
			cuv += PL_bitcount[*(U8 *)s++];
			len -= 8;
		    }
		if (len && s < strend) {
		    U8 bits;
		    bits = SHIFT_BYTE(utf8, s, strend, datumtype);
		    if (datumtype == 'b')
			while (len-- > 0) {
			    if (bits & 1) cuv++;
			    bits >>= 1;
			}
		    else
			while (len-- > 0) {
			    if (bits & 0x80) cuv++;
			    bits <<= 1;
			}
		}
		break;
	    }

	    sv = sv_2mortal(newSV(len ? len : 1));
	    SvPOK_on(sv);
	    str = SvPVX(sv);
	    if (datumtype == 'b') {
		U8 bits = 0;
		const I32 ai32 = len;
		for (len = 0; len < ai32; len++) {
		    if (len & 7) bits >>= 1;
		    else if (utf8) {
			if (s >= strend) break;
			bits = utf8_to_byte(aTHX_ &s, strend, datumtype);
		    } else bits = *(U8 *) s++;
		    *str++ = bits & 1 ? '1' : '0';
		}
	    } else {
		U8 bits = 0;
		const I32 ai32 = len;
		for (len = 0; len < ai32; len++) {
		    if (len & 7) bits <<= 1;
		    else if (utf8) {
			if (s >= strend) break;
			bits = utf8_to_byte(aTHX_ &s, strend, datumtype);
		    } else bits = *(U8 *) s++;
		    *str++ = bits & 0x80 ? '1' : '0';
		}
	    }
	    *str = '\0';
	    SvCUR_set(sv, str - SvPVX_const(sv));
	    XPUSHs(sv);
	    break;
	}
	case 'H':
	case 'h': {
	    char *str = NULL;
	    /* Preliminary length estimate, acceptable for utf8 too */
	    if (howlen == e_star || len > (strend - s) * 2)
		len = (strend - s) * 2;
	    if (!checksum) {
		sv = sv_2mortal(newSV(len ? len : 1));
		SvPOK_on(sv);
		str = SvPVX(sv);
	    }
	    if (datumtype == 'h') {
		U8 bits = 0;
		I32 ai32 = len;
		for (len = 0; len < ai32; len++) {
		    if (len & 1) bits >>= 4;
		    else if (utf8) {
			if (s >= strend) break;
			bits = utf8_to_byte(aTHX_ &s, strend, datumtype);
		    } else bits = * (U8 *) s++;
		    if (!checksum)
			*str++ = PL_hexdigit[bits & 15];
		}
	    } else {
		U8 bits = 0;
		const I32 ai32 = len;
		for (len = 0; len < ai32; len++) {
		    if (len & 1) bits <<= 4;
		    else if (utf8) {
			if (s >= strend) break;
			bits = utf8_to_byte(aTHX_ &s, strend, datumtype);
		    } else bits = *(U8 *) s++;
		    if (!checksum)
			*str++ = PL_hexdigit[(bits >> 4) & 15];
		}
	    }
	    if (!checksum) {
		*str = '\0';
		SvCUR_set(sv, str - SvPVX_const(sv));
		XPUSHs(sv);
	    }
	    break;
	}
	case 'C':
            if (len == 0) {
                if (explicit_length)
		    /* Switch to "character" mode */
		    utf8 = (symptr->flags & FLAG_DO_UTF8) ? 1 : 0;
		break;
	    }
	    /* FALLTHROUGH */
	case 'c':
	    while (len-- > 0 && s < strend) {
		int aint;
		if (utf8)
		  {
		    STRLEN retlen;
		    aint = utf8n_to_uvchr((U8 *) s, strend-s, &retlen,
				 ckWARN(WARN_UTF8) ? 0 : UTF8_ALLOW_ANY);
		    if (retlen == (STRLEN) -1 || retlen == 0)
			Perl_croak(aTHX_ "Malformed UTF-8 string in unpack");
		    s += retlen;
		  }
		else
		  aint = *(U8 *)(s)++;
		if (aint >= 128 && datumtype != 'C')	/* fake up signed chars */
		    aint -= 256;
		if (!checksum)
		    mPUSHi(aint);
		else if (checksum > bits_in_uv)
		    cdouble += (NV)aint;
		else
		    cuv += aint;
	    }
	    break;
	case 'W':
	  W_checksum:
	    if (utf8) {
		while (len-- > 0 && s < strend) {
		    STRLEN retlen;
		    const UV val = utf8n_to_uvchr((U8 *) s, strend-s, &retlen,
					 ckWARN(WARN_UTF8) ? 0 : UTF8_ALLOW_ANY);
		    if (retlen == (STRLEN) -1 || retlen == 0)
			Perl_croak(aTHX_ "Malformed UTF-8 string in unpack");
		    s += retlen;
		    if (!checksum)
			mPUSHu(val);
		    else if (checksum > bits_in_uv)
			cdouble += (NV) val;
		    else
			cuv += val;
		}
	    } else if (!checksum)
		while (len-- > 0) {
		    const U8 ch = *(U8 *) s++;
		    mPUSHu(ch);
	    }
	    else if (checksum > bits_in_uv)
		while (len-- > 0) cdouble += (NV) *(U8 *) s++;
	    else
		while (len-- > 0) cuv += *(U8 *) s++;
	    break;
	case 'U':
	    if (len == 0) {
                if (explicit_length && howlen != e_star) {
		    /* Switch to "bytes in UTF-8" mode */
		    if (symptr->flags & FLAG_DO_UTF8) utf8 = 0;
		    else
			/* Should be impossible due to the need_utf8() test */
			Perl_croak(aTHX_ "U0 mode on a byte string");
		}
		break;
	    }
	    if (len > strend - s) len = strend - s;
	    if (!checksum) {
		if (len && unpack_only_one) len = 1;
		EXTEND(SP, len);
		EXTEND_MORTAL(len);
	    }
	    while (len-- > 0 && s < strend) {
		STRLEN retlen;
		UV auv;
		if (utf8) {
		    U8 result[UTF8_MAXLEN];
		    const char *ptr = s;
		    STRLEN len;
		    /* Bug: warns about bad utf8 even if we are short on bytes
		       and will break out of the loop */
		    if (!S_utf8_to_bytes(aTHX_ &ptr, strend, (char *) result, 1,
				      'U'))
			break;
		    len = UTF8SKIP(result);
		    if (!S_utf8_to_bytes(aTHX_ &ptr, strend,
				      (char *) &result[1], len-1, 'U')) break;
		    auv = NATIVE_TO_UNI(utf8n_to_uvchr(result,
                                                       len,
                                                       &retlen,
                                                       UTF8_ALLOW_DEFAULT));
		    s = ptr;
		} else {
		    auv = NATIVE_TO_UNI(utf8n_to_uvchr((U8*)s,
                                                       strend - s,
                                                       &retlen,
                                                       UTF8_ALLOW_DEFAULT));
		    if (retlen == (STRLEN) -1 || retlen == 0)
			Perl_croak(aTHX_ "Malformed UTF-8 string in unpack");
		    s += retlen;
		}
		if (!checksum)
		    mPUSHu(auv);
		else if (checksum > bits_in_uv)
		    cdouble += (NV) auv;
		else
		    cuv += auv;
	    }
	    break;
	case 's' | TYPE_IS_SHRIEKING:
#if SHORTSIZE != SIZE16
	    while (len-- > 0) {
		short ashort;
                SHIFT_VAR(utf8, s, strend, ashort, datumtype, needs_swap);
		if (!checksum)
		    mPUSHi(ashort);
		else if (checksum > bits_in_uv)
		    cdouble += (NV)ashort;
		else
		    cuv += ashort;
	    }
	    break;
#else
	    /* FALLTHROUGH */
#endif
	case 's':
	    while (len-- > 0) {
		I16 ai16;

#if U16SIZE > SIZE16
		ai16 = 0;
#endif
                SHIFT16(utf8, s, strend, &ai16, datumtype, needs_swap);
#if U16SIZE > SIZE16
		if (ai16 > 32767)
		    ai16 -= 65536;
#endif
		if (!checksum)
		    mPUSHi(ai16);
		else if (checksum > bits_in_uv)
		    cdouble += (NV)ai16;
		else
		    cuv += ai16;
	    }
	    break;
	case 'S' | TYPE_IS_SHRIEKING:
#if SHORTSIZE != SIZE16
	    while (len-- > 0) {
		unsigned short aushort;
                SHIFT_VAR(utf8, s, strend, aushort, datumtype, needs_swap,
                          needs_swap);
		if (!checksum)
		    mPUSHu(aushort);
		else if (checksum > bits_in_uv)
		    cdouble += (NV)aushort;
		else
		    cuv += aushort;
	    }
	    break;
#else
            /* FALLTHROUGH */
#endif
	case 'v':
	case 'n':
	case 'S':
	    while (len-- > 0) {
		U16 au16;
#if U16SIZE > SIZE16
		au16 = 0;
#endif
                SHIFT16(utf8, s, strend, &au16, datumtype, needs_swap);
		if (datumtype == 'n')
		    au16 = PerlSock_ntohs(au16);
		if (datumtype == 'v')
		    au16 = vtohs(au16);
		if (!checksum)
		    mPUSHu(au16);
		else if (checksum > bits_in_uv)
		    cdouble += (NV) au16;
		else
		    cuv += au16;
	    }
	    break;
	case 'v' | TYPE_IS_SHRIEKING:
	case 'n' | TYPE_IS_SHRIEKING:
	    while (len-- > 0) {
		I16 ai16;
# if U16SIZE > SIZE16
		ai16 = 0;
# endif
                SHIFT16(utf8, s, strend, &ai16, datumtype, needs_swap);
                /* There should never be any byte-swapping here.  */
                assert(!TYPE_ENDIANNESS(datumtype));
		if (datumtype == ('n' | TYPE_IS_SHRIEKING))
		    ai16 = (I16) PerlSock_ntohs((U16) ai16);
		if (datumtype == ('v' | TYPE_IS_SHRIEKING))
		    ai16 = (I16) vtohs((U16) ai16);
		if (!checksum)
		    mPUSHi(ai16);
		else if (checksum > bits_in_uv)
		    cdouble += (NV) ai16;
		else
		    cuv += ai16;
	    }
	    break;
	case 'i':
	case 'i' | TYPE_IS_SHRIEKING:
	    while (len-- > 0) {
		int aint;
                SHIFT_VAR(utf8, s, strend, aint, datumtype, needs_swap);
		if (!checksum)
		    mPUSHi(aint);
		else if (checksum > bits_in_uv)
		    cdouble += (NV)aint;
		else
		    cuv += aint;
	    }
	    break;
	case 'I':
	case 'I' | TYPE_IS_SHRIEKING:
	    while (len-- > 0) {
		unsigned int auint;
                SHIFT_VAR(utf8, s, strend, auint, datumtype, needs_swap);
		if (!checksum)
		    mPUSHu(auint);
		else if (checksum > bits_in_uv)
		    cdouble += (NV)auint;
		else
		    cuv += auint;
	    }
	    break;
	case 'j':
	    while (len-- > 0) {
		IV aiv;
                SHIFT_VAR(utf8, s, strend, aiv, datumtype, needs_swap);
		if (!checksum)
		    mPUSHi(aiv);
		else if (checksum > bits_in_uv)
		    cdouble += (NV)aiv;
		else
		    cuv += aiv;
	    }
	    break;
	case 'J':
	    while (len-- > 0) {
		UV auv;
                SHIFT_VAR(utf8, s, strend, auv, datumtype, needs_swap);
		if (!checksum)
		    mPUSHu(auv);
		else if (checksum > bits_in_uv)
		    cdouble += (NV)auv;
		else
		    cuv += auv;
	    }
	    break;
	case 'l' | TYPE_IS_SHRIEKING:
#if LONGSIZE != SIZE32
	    while (len-- > 0) {
		long along;
                SHIFT_VAR(utf8, s, strend, along, datumtype, needs_swap);
		if (!checksum)
		    mPUSHi(along);
		else if (checksum > bits_in_uv)
		    cdouble += (NV)along;
		else
		    cuv += along;
	    }
	    break;
#else
	    /* FALLTHROUGH */
#endif
	case 'l':
	    while (len-- > 0) {
		I32 ai32;
#if U32SIZE > SIZE32
		ai32 = 0;
#endif
                SHIFT32(utf8, s, strend, &ai32, datumtype, needs_swap);
#if U32SIZE > SIZE32
		if (ai32 > 2147483647) ai32 -= 4294967296;
#endif
		if (!checksum)
		    mPUSHi(ai32);
		else if (checksum > bits_in_uv)
		    cdouble += (NV)ai32;
		else
		    cuv += ai32;
	    }
	    break;
	case 'L' | TYPE_IS_SHRIEKING:
#if LONGSIZE != SIZE32
	    while (len-- > 0) {
		unsigned long aulong;
                SHIFT_VAR(utf8, s, strend, aulong, datumtype, needs_swap);
		if (!checksum)
		    mPUSHu(aulong);
		else if (checksum > bits_in_uv)
		    cdouble += (NV)aulong;
		else
		    cuv += aulong;
	    }
	    break;
#else
            /* FALLTHROUGH */
#endif
	case 'V':
	case 'N':
	case 'L':
	    while (len-- > 0) {
		U32 au32;
#if U32SIZE > SIZE32
		au32 = 0;
#endif
                SHIFT32(utf8, s, strend, &au32, datumtype, needs_swap);
		if (datumtype == 'N')
		    au32 = PerlSock_ntohl(au32);
		if (datumtype == 'V')
		    au32 = vtohl(au32);
		if (!checksum)
		    mPUSHu(au32);
		else if (checksum > bits_in_uv)
		    cdouble += (NV)au32;
		else
		    cuv += au32;
	    }
	    break;
	case 'V' | TYPE_IS_SHRIEKING:
	case 'N' | TYPE_IS_SHRIEKING:
	    while (len-- > 0) {
		I32 ai32;
#if U32SIZE > SIZE32
		ai32 = 0;
#endif
                SHIFT32(utf8, s, strend, &ai32, datumtype, needs_swap);
                /* There should never be any byte swapping here.  */
                assert(!TYPE_ENDIANNESS(datumtype));
		if (datumtype == ('N' | TYPE_IS_SHRIEKING))
		    ai32 = (I32)PerlSock_ntohl((U32)ai32);
		if (datumtype == ('V' | TYPE_IS_SHRIEKING))
		    ai32 = (I32)vtohl((U32)ai32);
		if (!checksum)
		    mPUSHi(ai32);
		else if (checksum > bits_in_uv)
		    cdouble += (NV)ai32;
		else
		    cuv += ai32;
	    }
	    break;
	case 'p':
	    while (len-- > 0) {
		const char *aptr;
                SHIFT_VAR(utf8, s, strend, aptr, datumtype, needs_swap);
		/* newSVpv generates undef if aptr is NULL */
		mPUSHs(newSVpv(aptr, 0));
	    }
	    break;
	case 'w':
	    {
		UV auv = 0;
		U32 bytes = 0;

		while (len > 0 && s < strend) {
		    U8 ch;
		    ch = SHIFT_BYTE(utf8, s, strend, datumtype);
		    auv = (auv << 7) | (ch & 0x7f);
                    /* UTF8_IS_XXXXX not right here because this is a BER, not
                     * UTF-8 format - using constant 0x80 */
		    if (ch < 0x80) {
			bytes = 0;
			mPUSHu(auv);
			len--;
			auv = 0;
			continue;
		    }
		    if (++bytes >= sizeof(UV)) {	/* promote to string */
			const char *t;

			sv = Perl_newSVpvf(aTHX_ "%.*"UVuf, (int)TYPE_DIGITS(UV), auv);
			while (s < strend) {
			    ch = SHIFT_BYTE(utf8, s, strend, datumtype);
			    sv = mul128(sv, (U8)(ch & 0x7f));
			    if (!(ch & 0x80)) {
				bytes = 0;
				break;
			    }
			}
			t = SvPV_nolen_const(sv);
			while (*t == '0')
			    t++;
			sv_chop(sv, t);
			mPUSHs(sv);
			len--;
			auv = 0;
		    }
		}
		if ((s >= strend) && bytes)
		    Perl_croak(aTHX_ "Unterminated compressed integer in unpack");
	    }
	    break;
	case 'P':
	    if (symptr->howlen == e_star)
	        Perl_croak(aTHX_ "'P' must have an explicit size in unpack");
	    EXTEND(SP, 1);
	    if (s + sizeof(char*) <= strend) {
		char *aptr;
                SHIFT_VAR(utf8, s, strend, aptr, datumtype, needs_swap);
		/* newSVpvn generates undef if aptr is NULL */
		PUSHs(newSVpvn_flags(aptr, len, SVs_TEMP));
	    }
	    break;
#if defined(HAS_QUAD) && IVSIZE >= 8
	case 'q':
	    while (len-- > 0) {
		Quad_t aquad;
                SHIFT_VAR(utf8, s, strend, aquad, datumtype, needs_swap);
		if (!checksum)
                    mPUSHs(newSViv((IV)aquad));
		else if (checksum > bits_in_uv)
		    cdouble += (NV)aquad;
		else
		    cuv += aquad;
	    }
	    break;
	case 'Q':
	    while (len-- > 0) {
		Uquad_t auquad;
                SHIFT_VAR(utf8, s, strend, auquad, datumtype, needs_swap);
		if (!checksum)
		    mPUSHs(newSVuv((UV)auquad));
		else if (checksum > bits_in_uv)
		    cdouble += (NV)auquad;
		else
		    cuv += auquad;
	    }
	    break;
#endif
	/* float and double added gnb@@melba.bby.oz.au 22/11/89 */
	case 'f':
	    while (len-- > 0) {
		float afloat;
                SHIFT_VAR(utf8, s, strend, afloat, datumtype, needs_swap);
		if (!checksum)
		    mPUSHn(afloat);
		else
		    cdouble += afloat;
	    }
	    break;
	case 'd':
	    while (len-- > 0) {
		double adouble;
                SHIFT_VAR(utf8, s, strend, adouble, datumtype, needs_swap);
		if (!checksum)
		    mPUSHn(adouble);
		else
		    cdouble += adouble;
	    }
	    break;
	case 'F':
	    while (len-- > 0) {
		NV_bytes anv;
                SHIFT_BYTES(utf8, s, strend, anv.bytes, sizeof(anv.bytes),
                            datumtype, needs_swap);
		if (!checksum)
		    mPUSHn(anv.nv);
		else
		    cdouble += anv.nv;
	    }
	    break;
#if defined(HAS_LONG_DOUBLE) && defined(USE_LONG_DOUBLE)
	case 'D':
	    while (len-- > 0) {
		ld_bytes aldouble;
                SHIFT_BYTES(utf8, s, strend, aldouble.bytes,
                            sizeof(aldouble.bytes), datumtype, needs_swap);
                /* The most common long double format, the x86 80-bit
                 * extended precision, has either 2 or 6 unused bytes,
                 * which may contain garbage, which may contain
                 * unintentional data.  While we do zero the bytes of
                 * the long double data in pack(), here in unpack() we
                 * don't, because it's really hard to envision that
                 * reading the long double off aldouble would be
                 * affected by the unused bytes.
                 *
                 * Note that trying to unpack 'long doubles' of 'long
                 * doubles' packed in another system is in the general
                 * case doomed without having more detail. */
		if (!checksum)
		    mPUSHn(aldouble.ld);
		else
		    cdouble += aldouble.ld;
	    }
	    break;
#endif
	case 'u':
	    if (!checksum) {
                const STRLEN l = (STRLEN) (strend - s) * 3 / 4;
		sv = sv_2mortal(newSV(l));
		if (l) SvPOK_on(sv);
	    }

            /* Note that all legal uuencoded strings are ASCII printables, so
             * have the same representation under UTF-8 vs not.  This means we
             * can ignore UTF8ness on legal input.  For illegal we stop at the
             * first failure, and don't report where/what that is, so again we
             * can ignore UTF8ness */

            while (s < strend && *s != ' ' && ISUUCHAR(*s)) {
                I32 a, b, c, d;
                char hunk[3];

                len = PL_uudmap[*(U8*)s++] & 077;
                while (len > 0) {
                    if (s < strend && ISUUCHAR(*s))
                        a = PL_uudmap[*(U8*)s++] & 077;
                    else
                        a = 0;
                    if (s < strend && ISUUCHAR(*s))
                        b = PL_uudmap[*(U8*)s++] & 077;
                    else
                        b = 0;
                    if (s < strend && ISUUCHAR(*s))
                        c = PL_uudmap[*(U8*)s++] & 077;
                    else
                        c = 0;
                    if (s < strend && ISUUCHAR(*s))
                        d = PL_uudmap[*(U8*)s++] & 077;
                    else
                        d = 0;
                    hunk[0] = (char)((a << 2) | (b >> 4));
                    hunk[1] = (char)((b << 4) | (c >> 2));
                    hunk[2] = (char)((c << 6) | d);
                    if (!checksum)
                        sv_catpvn(sv, hunk, (len > 3) ? 3 : len);
                    len -= 3;
                }
                if (*s == '\n')
                    s++;
                else	/* possible checksum byte */
                    if (s + 1 < strend && s[1] == '\n')
                        s += 2;
            }
	    if (!checksum)
		XPUSHs(sv);
	    break;
	} /* End of switch */

	if (checksum) {
	    if (strchr("fFdD", TYPE_NO_MODIFIERS(datumtype)) ||
	      (checksum > bits_in_uv &&
	       strchr("cCsSiIlLnNUWvVqQjJ", TYPE_NO_MODIFIERS(datumtype))) ) {
		NV trouble, anv;

                anv = (NV) (1 << (checksum & 15));
		while (checksum >= 16) {
		    checksum -= 16;
		    anv *= 65536.0;
		}
		while (cdouble < 0.0)
		    cdouble += anv;
		cdouble = Perl_modf(cdouble / anv, &trouble);
#ifdef LONGDOUBLE_DOUBLEDOUBLE
                /* Workaround for powerpc doubledouble modfl bug:
                 * close to 1.0L and -1.0L cdouble is 0, and trouble
                 * is cdouble / anv. */
                if (trouble != Perl_ceil(trouble)) {
                  cdouble = trouble;
                  if (cdouble >  1.0L) cdouble -= 1.0L;
                  if (cdouble < -1.0L) cdouble += 1.0L;
                }
#endif
                cdouble *= anv;
		sv = newSVnv(cdouble);
	    }
	    else {
		if (checksum < bits_in_uv) {
		    UV mask = ((UV)1 << checksum) - 1;
		    cuv &= mask;
		}
		sv = newSVuv(cuv);
	    }
	    mXPUSHs(sv);
	    checksum = 0;
	}

        if (symptr->flags & FLAG_SLASH){
            if (SP - PL_stack_base - start_sp_offset <= 0)
		break;
            if( next_symbol(symptr) ){
              if( symptr->howlen == e_number )
		Perl_croak(aTHX_ "Count after length/code in unpack" );
              if( beyond ){
         	/* ...end of char buffer then no decent length available */
		Perl_croak(aTHX_ "length/code after end of string in unpack" );
              } else {
         	/* take top of stack (hope it's numeric) */
                len = POPi;
                if( len < 0 )
                    Perl_croak(aTHX_ "Negative '/' count in unpack" );
              }
            } else {
		Perl_croak(aTHX_ "Code missing after '/' in unpack" );
            }
            datumtype = symptr->code;
            explicit_length = FALSE;
	    goto redo_switch;
        }
    }

    if (new_s)
	*new_s = s;
    PUTBACK;
    return SP - PL_stack_base - start_sp_offset;
}

PP(pp_unpack)
{
    dSP;
    dPOPPOPssrl;
    U8 gimme = GIMME_V;
    STRLEN llen;
    STRLEN rlen;
    const char *pat = SvPV_const(left,  llen);
    const char *s   = SvPV_const(right, rlen);
    const char *strend = s + rlen;
    const char *patend = pat + llen;
    I32 cnt;

    PUTBACK;
    cnt = unpackstring(pat, patend, s, strend,
		     ((gimme == G_SCALAR) ? FLAG_UNPACK_ONLY_ONE : 0)
		     | (DO_UTF8(right) ? FLAG_DO_UTF8 : 0));

    SPAGAIN;
    if ( !cnt && gimme == G_SCALAR )
       PUSHs(&PL_sv_undef);
    RETURN;
}

STATIC U8 *
doencodes(U8 *h, const U8 *s, I32 len)
{
    *h++ = PL_uuemap[len];
    while (len > 2) {
	*h++ = PL_uuemap[(077 & (s[0] >> 2))];
	*h++ = PL_uuemap[(077 & (((s[0] << 4) & 060) | ((s[1] >> 4) & 017)))];
	*h++ = PL_uuemap[(077 & (((s[1] << 2) & 074) | ((s[2] >> 6) & 03)))];
	*h++ = PL_uuemap[(077 & (s[2] & 077))];
	s += 3;
	len -= 3;
    }
    if (len > 0) {
        const U8 r = (len > 1 ? s[1] : '\0');
	*h++ = PL_uuemap[(077 & (s[0] >> 2))];
	*h++ = PL_uuemap[(077 & (((s[0] << 4) & 060) | ((r >> 4) & 017)))];
	*h++ = PL_uuemap[(077 & ((r << 2) & 074))];
	*h++ = PL_uuemap[0];
    }
    *h++ = '\n';
    return h;
}

STATIC SV *
S_is_an_int(pTHX_ const char *s, STRLEN l)
{
  SV *result = newSVpvn(s, l);
  char *const result_c = SvPV_nolen(result);	/* convenience */
  char *out = result_c;
  bool skip = 1;
  bool ignore = 0;

  PERL_ARGS_ASSERT_IS_AN_INT;

  while (*s) {
    switch (*s) {
    case ' ':
      break;
    case '+':
      if (!skip) {
	SvREFCNT_dec(result);
	return (NULL);
      }
      break;
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
      skip = 0;
      if (!ignore) {
	*(out++) = *s;
      }
      break;
    case '.':
      ignore = 1;
      break;
    default:
      SvREFCNT_dec(result);
      return (NULL);
    }
    s++;
  }
  *(out++) = '\0';
  SvCUR_set(result, out - result_c);
  return (result);
}

/* pnum must be '\0' terminated */
STATIC int
S_div128(pTHX_ SV *pnum, bool *done)
{
    STRLEN len;
    char * const s = SvPV(pnum, len);
    char *t = s;
    int m = 0;

    PERL_ARGS_ASSERT_DIV128;

    *done = 1;
    while (*t) {
	const int i = m * 10 + (*t - '0');
	const int r = (i >> 7); /* r < 10 */
	m = i & 0x7F;
	if (r) {
	    *done = 0;
	}
	*(t++) = '0' + r;
    }
    *(t++) = '\0';
    SvCUR_set(pnum, (STRLEN) (t - s));
    return (m);
}

/*
=for apidoc packlist

The engine implementing C<pack()> Perl function.

=cut
*/

void
Perl_packlist(pTHX_ SV *cat, const char *pat, const char *patend, SV **beglist, SV **endlist )
{
    tempsym_t sym;

    PERL_ARGS_ASSERT_PACKLIST;

    TEMPSYM_INIT(&sym, pat, patend, FLAG_PACK);

    /* We're going to do changes through SvPVX(cat). Make sure it's valid.
       Also make sure any UTF8 flag is loaded */
    SvPV_force_nolen(cat);
    if (DO_UTF8(cat))
	sym.flags |= FLAG_PARSE_UTF8 | FLAG_DO_UTF8;

    (void)pack_rec( cat, &sym, beglist, endlist );
}

/* like sv_utf8_upgrade, but also repoint the group start markers */
STATIC void
marked_upgrade(pTHX_ SV *sv, tempsym_t *sym_ptr) {
    STRLEN len;
    tempsym_t *group;
    const char *from_ptr, *from_start, *from_end, **marks, **m;
    char *to_start, *to_ptr;

    if (SvUTF8(sv)) return;

    from_start = SvPVX_const(sv);
    from_end = from_start + SvCUR(sv);
    for (from_ptr = from_start; from_ptr < from_end; from_ptr++)
	if (!NATIVE_BYTE_IS_INVARIANT(*from_ptr)) break;
    if (from_ptr == from_end) {
	/* Simple case: no character needs to be changed */
	SvUTF8_on(sv);
	return;
    }

    len = (from_end-from_ptr)*UTF8_EXPAND+(from_ptr-from_start)+1;
    Newx(to_start, len, char);
    Copy(from_start, to_start, from_ptr-from_start, char);
    to_ptr = to_start + (from_ptr-from_start);

    Newx(marks, sym_ptr->level+2, const char *);
    for (group=sym_ptr; group; group = group->previous)
	marks[group->level] = from_start + group->strbeg;
    marks[sym_ptr->level+1] = from_end+1;
    for (m = marks; *m < from_ptr; m++)
	*m = to_start + (*m-from_start);

    for (;from_ptr < from_end; from_ptr++) {
	while (*m == from_ptr) *m++ = to_ptr;
	to_ptr = (char *) uvchr_to_utf8((U8 *) to_ptr, *(U8 *) from_ptr);
    }
    *to_ptr = 0;

    while (*m == from_ptr) *m++ = to_ptr;
    if (m != marks + sym_ptr->level+1) {
	Safefree(marks);
	Safefree(to_start);
	Perl_croak(aTHX_ "panic: marks beyond string end, m=%p, marks=%p, "
		   "level=%d", m, marks, sym_ptr->level);
    }
    for (group=sym_ptr; group; group = group->previous)
	group->strbeg = marks[group->level] - to_start;
    Safefree(marks);

    if (SvOOK(sv)) {
	if (SvIVX(sv)) {
	    SvLEN_set(sv, SvLEN(sv) + SvIVX(sv));
	    from_start -= SvIVX(sv);
	    SvIV_set(sv, 0);
	}
	SvFLAGS(sv) &= ~SVf_OOK;
    }
    if (SvLEN(sv) != 0)
	Safefree(from_start);
    SvPV_set(sv, to_start);
    SvCUR_set(sv, to_ptr - to_start);
    SvLEN_set(sv, len);
    SvUTF8_on(sv);
}

/* Exponential string grower. Makes string extension effectively O(n)
   needed says how many extra bytes we need (not counting the final '\0')
   Only grows the string if there is an actual lack of space
*/
STATIC char *
S_sv_exp_grow(pTHX_ SV *sv, STRLEN needed) {
    const STRLEN cur = SvCUR(sv);
    const STRLEN len = SvLEN(sv);
    STRLEN extend;

    PERL_ARGS_ASSERT_SV_EXP_GROW;

    if (len - cur > needed) return SvPVX(sv);
    extend = needed > len ? needed : len;
    return SvGROW(sv, len+extend+1);
}

static SV *
S_sv_check_infnan(pTHX_ SV *sv, I32 datumtype)
{
    SvGETMAGIC(sv);
    if (UNLIKELY(SvAMAGIC(sv)))
	sv = sv_2num(sv);
    if (UNLIKELY(isinfnansv(sv))) {
	const I32 c = TYPE_NO_MODIFIERS(datumtype);
	const NV nv = SvNV_nomg(sv);
	if (c == 'w')
	    Perl_croak(aTHX_ "Cannot compress %"NVgf" in pack", nv);
	else
	    Perl_croak(aTHX_ "Cannot pack %"NVgf" with '%c'", nv, (int) c);
    }
    return sv;
}

#define SvIV_no_inf(sv,d) \
	((sv) = S_sv_check_infnan(aTHX_ sv,d), SvIV_nomg(sv))
#define SvUV_no_inf(sv,d) \
	((sv) = S_sv_check_infnan(aTHX_ sv,d), SvUV_nomg(sv))

STATIC
SV **
S_pack_rec(pTHX_ SV *cat, tempsym_t* symptr, SV **beglist, SV **endlist )
{
    tempsym_t lookahead;
    I32 items  = endlist - beglist;
    bool found = next_symbol(symptr);
    bool utf8 = (symptr->flags & FLAG_PARSE_UTF8) ? 1 : 0;
    bool warn_utf8 = ckWARN(WARN_UTF8);
    char* from;

    PERL_ARGS_ASSERT_PACK_REC;

    if (symptr->level == 0 && found && symptr->code == 'U') {
	marked_upgrade(aTHX_ cat, symptr);
	symptr->flags |= FLAG_DO_UTF8;
	utf8 = 0;
    }
    symptr->strbeg = SvCUR(cat);

    while (found) {
	SV *fromstr;
	STRLEN fromlen;
	I32 len;
	SV *lengthcode = NULL;
        I32 datumtype = symptr->code;
        howlen_t howlen = symptr->howlen;
	char *start = SvPVX(cat);
	char *cur   = start + SvCUR(cat);
        bool needs_swap;

#define NEXTFROM (lengthcode ? lengthcode : items > 0 ? (--items, *beglist++) : &PL_sv_no)
#define PEEKFROM (lengthcode ? lengthcode : items > 0 ? *beglist : &PL_sv_no)

        switch (howlen) {
	  case e_star:
	    len = strchr("@@Xxu", TYPE_NO_MODIFIERS(datumtype)) ?
		0 : items;
	    break;
	  default:
	    /* e_no_len and e_number */
	    len = symptr->length;
	    break;
        }

	if (len) {
	    packprops_t props = packprops[TYPE_NO_ENDIANNESS(datumtype)];

	    if (props && !(props & PACK_SIZE_UNPREDICTABLE)) {
		/* We can process this letter. */
		STRLEN size = props & PACK_SIZE_MASK;
		GROWING(utf8, cat, start, cur, (STRLEN) len * size);
	    }
        }

        /* Look ahead for next symbol. Do we have code/code? */
        lookahead = *symptr;
        found = next_symbol(&lookahead);
	if (symptr->flags & FLAG_SLASH) {
	    IV count;
	    if (!found) Perl_croak(aTHX_ "Code missing after '/' in pack");
	    if (strchr("aAZ", lookahead.code)) {
		if (lookahead.howlen == e_number) count = lookahead.length;
		else {
		    if (items > 0) {
			count = sv_len_utf8(*beglist);
		    }
		    else count = 0;
		    if (lookahead.code == 'Z') count++;
		}
	    } else {
		if (lookahead.howlen == e_number && lookahead.length < items)
		    count = lookahead.length;
		else count = items;
	    }
	    lookahead.howlen = e_number;
	    lookahead.length = count;
	    lengthcode = sv_2mortal(newSViv(count));
	}

        needs_swap = NEEDS_SWAP(datumtype);

	/* Code inside the switch must take care to properly update
	   cat (CUR length and '\0' termination) if it updated *cur and
	   doesn't simply leave using break */
	switch (TYPE_NO_ENDIANNESS(datumtype)) {
	default:
	    Perl_croak(aTHX_ "Invalid type '%c' in pack",
		       (int) TYPE_NO_MODIFIERS(datumtype));
	case '%':
	    Perl_croak(aTHX_ "'%%' may not be used in pack");

	case '.' | TYPE_IS_SHRIEKING:
	case '.':
	    if (howlen == e_star) from = start;
	    else if (len == 0) from = cur;
	    else {
		tempsym_t *group = symptr;

		while (--len && group) group = group->previous;
		from = group ? start + group->strbeg : start;
	    }
	    fromstr = NEXTFROM;
	    len = SvIV_no_inf(fromstr, datumtype);
	    goto resize;
	case '@@' | TYPE_IS_SHRIEKING:
	case '@@':
	    from = start + symptr->strbeg;
	  resize:
	    if (utf8  && !(datumtype & TYPE_IS_SHRIEKING))
		if (len >= 0) {
		    while (len && from < cur) {
			from += UTF8SKIP(from);
			len--;
		    }
		    if (from > cur)
			Perl_croak(aTHX_ "Malformed UTF-8 string in pack");
		    if (len) {
			/* Here we know from == cur */
		      grow:
			GROWING(0, cat, start, cur, len);
			Zero(cur, len, char);
			cur += len;
		    } else if (from < cur) {
			len = cur - from;
			goto shrink;
		    } else goto no_change;
		} else {
		    cur = from;
		    len = -len;
		    goto utf8_shrink;
		}
	    else {
		len -= cur - from;
		if (len > 0) goto grow;
		if (len == 0) goto no_change;
		len = -len;
		goto shrink;
	    }
	    break;

	case '(': {
            tempsym_t savsym = *symptr;
	    U32 group_modifiers = TYPE_MODIFIERS(datumtype & ~symptr->flags);
	    symptr->flags |= group_modifiers;
            symptr->patend = savsym.grpend;
            symptr->level++;
	    symptr->previous = &lookahead;
	    while (len--) {
		U32 was_utf8;
		if (utf8) symptr->flags |=  FLAG_PARSE_UTF8;
		else      symptr->flags &= ~FLAG_PARSE_UTF8;
		was_utf8 = SvUTF8(cat);
  	        symptr->patptr = savsym.grpbeg;
		beglist = pack_rec(cat, symptr, beglist, endlist);
		if (SvUTF8(cat) != was_utf8)
		    /* This had better be an upgrade while in utf8==0 mode */
		    utf8 = 1;

		if (savsym.howlen == e_star && beglist == endlist)
		    break;		/* No way to continue */
	    }
	    items = endlist - beglist;
	    lookahead.flags  = symptr->flags & ~group_modifiers;
	    goto no_change;
	}
	case 'X' | TYPE_IS_SHRIEKING:
	    if (!len)			/* Avoid division by 0 */
		len = 1;
	    if (utf8) {
		char *hop, *last;
		I32 l = len;
		hop = last = start;
		while (hop < cur) {
		    hop += UTF8SKIP(hop);
		    if (--l == 0) {
			last = hop;
			l = len;
		    }
		}
		if (last > cur)
		    Perl_croak(aTHX_ "Malformed UTF-8 string in pack");
		cur = last;
		break;
	    }
	    len = (cur-start) % len;
	    /* FALLTHROUGH */
	case 'X':
	    if (utf8) {
		if (len < 1) goto no_change;
	      utf8_shrink:
		while (len > 0) {
		    if (cur <= start)
			Perl_croak(aTHX_ "'%c' outside of string in pack",
				   (int) TYPE_NO_MODIFIERS(datumtype));
		    while (--cur, UTF8_IS_CONTINUATION(*cur)) {
			if (cur <= start)
			    Perl_croak(aTHX_ "'%c' outside of string in pack",
				       (int) TYPE_NO_MODIFIERS(datumtype));
		    }
		    len--;
		}
	    } else {
	      shrink:
		if (cur - start < len)
		    Perl_croak(aTHX_ "'%c' outside of string in pack",
			       (int) TYPE_NO_MODIFIERS(datumtype));
		cur -= len;
	    }
	    if (cur < start+symptr->strbeg) {
		/* Make sure group starts don't point into the void */
		tempsym_t *group;
		const STRLEN length = cur-start;
		for (group = symptr;
		     group && length < group->strbeg;
		     group = group->previous) group->strbeg = length;
		lookahead.strbeg = length;
	    }
	    break;
	case 'x' | TYPE_IS_SHRIEKING: {
	    I32 ai32;
	    if (!len)			/* Avoid division by 0 */
		len = 1;
	    if (utf8) ai32 = utf8_length((U8 *) start, (U8 *) cur) % len;
	    else      ai32 = (cur - start) % len;
	    if (ai32 == 0) goto no_change;
	    len -= ai32;
	}
	/* FALLTHROUGH */
	case 'x':
	    goto grow;
	case 'A':
	case 'Z':
	case 'a': {
	    const char *aptr;

	    fromstr = NEXTFROM;
	    aptr = SvPV_const(fromstr, fromlen);
	    if (DO_UTF8(fromstr)) {
                const char *end, *s;

		if (!utf8 && !SvUTF8(cat)) {
		    marked_upgrade(aTHX_ cat, symptr);
		    lookahead.flags |= FLAG_DO_UTF8;
		    lookahead.strbeg = symptr->strbeg;
		    utf8 = 1;
		    start = SvPVX(cat);
		    cur = start + SvCUR(cat);
		}
		if (howlen == e_star) {
		    if (utf8) goto string_copy;
		    len = fromlen+1;
		}
		s = aptr;
		end = aptr + fromlen;
		fromlen = datumtype == 'Z' ? len-1 : len;
		while ((I32) fromlen > 0 && s < end) {
		    s += UTF8SKIP(s);
		    fromlen--;
		}
		if (s > end)
		    Perl_croak(aTHX_ "Malformed UTF-8 string in pack");
		if (utf8) {
		    len = fromlen;
		    if (datumtype == 'Z') len++;
		    fromlen = s-aptr;
		    len += fromlen;

		    goto string_copy;
		}
		fromlen = len - fromlen;
		if (datumtype == 'Z') fromlen--;
		if (howlen == e_star) {
		    len = fromlen;
		    if (datumtype == 'Z') len++;
		}
		GROWING(0, cat, start, cur, len);
		if (!S_utf8_to_bytes(aTHX_ &aptr, end, cur, fromlen,
				  datumtype | TYPE_IS_PACK))
		    Perl_croak(aTHX_ "panic: predicted utf8 length not available, "
			       "for '%c', aptr=%p end=%p cur=%p, fromlen=%"UVuf,
			       (int)datumtype, aptr, end, cur, (UV)fromlen);
		cur += fromlen;
		len -= fromlen;
	    } else if (utf8) {
		if (howlen == e_star) {
		    len = fromlen;
		    if (datumtype == 'Z') len++;
		}
		if (len <= (I32) fromlen) {
		    fromlen = len;
		    if (datumtype == 'Z' && fromlen > 0) fromlen--;
		}
		/* assumes a byte expands to at most UTF8_EXPAND bytes on
		   upgrade, so:
		   expected_length <= from_len*UTF8_EXPAND + (len-from_len) */
		GROWING(0, cat, start, cur, fromlen*(UTF8_EXPAND-1)+len);
		len -= fromlen;
		while (fromlen > 0) {
		    cur = (char *) uvchr_to_utf8((U8 *) cur, * (U8 *) aptr);
		    aptr++;
		    fromlen--;
		}
	    } else {
	      string_copy:
		if (howlen == e_star) {
		    len = fromlen;
		    if (datumtype == 'Z') len++;
		}
		if (len <= (I32) fromlen) {
		    fromlen = len;
		    if (datumtype == 'Z' && fromlen > 0) fromlen--;
		}
		GROWING(0, cat, start, cur, len);
		Copy(aptr, cur, fromlen, char);
		cur += fromlen;
		len -= fromlen;
	    }
	    memset(cur, datumtype == 'A' ? ' ' : '\0', len);
	    cur += len;
	    SvTAINT(cat);
	    break;
	}
	case 'B':
	case 'b': {
	    const char *str, *end;
	    I32 l, field_len;
	    U8 bits;
	    bool utf8_source;
	    U32 utf8_flags;

	    fromstr = NEXTFROM;
	    str = SvPV_const(fromstr, fromlen);
	    end = str + fromlen;
	    if (DO_UTF8(fromstr)) {
		utf8_source = TRUE;
		utf8_flags  = warn_utf8 ? 0 : UTF8_ALLOW_ANY;
	    } else {
		utf8_source = FALSE;
		utf8_flags  = 0; /* Unused, but keep compilers happy */
	    }
	    if (howlen == e_star) len = fromlen;
	    field_len = (len+7)/8;
	    GROWING(utf8, cat, start, cur, field_len);
	    if (len > (I32)fromlen) len = fromlen;
	    bits = 0;
	    l = 0;
	    if (datumtype == 'B')
		while (l++ < len) {
		    if (utf8_source) {
			UV val = 0;
			NEXT_UNI_VAL(val, cur, str, end, utf8_flags);
			bits |= val & 1;
		    } else bits |= *str++ & 1;
		    if (l & 7) bits <<= 1;
		    else {
			PUSH_BYTE(utf8, cur, bits);
			bits = 0;
		    }
		}
	    else
		/* datumtype == 'b' */
		while (l++ < len) {
		    if (utf8_source) {
			UV val = 0;
			NEXT_UNI_VAL(val, cur, str, end, utf8_flags);
			if (val & 1) bits |= 0x80;
		    } else if (*str++ & 1)
			bits |= 0x80;
		    if (l & 7) bits >>= 1;
		    else {
			PUSH_BYTE(utf8, cur, bits);
			bits = 0;
		    }
		}
	    l--;
	    if (l & 7) {
		if (datumtype == 'B')
		    bits <<= 7 - (l & 7);
		else
		    bits >>= 7 - (l & 7);
		PUSH_BYTE(utf8, cur, bits);
		l += 7;
	    }
	    /* Determine how many chars are left in the requested field */
	    l /= 8;
	    if (howlen == e_star) field_len = 0;
	    else field_len -= l;
	    Zero(cur, field_len, char);
	    cur += field_len;
	    break;
	}
	case 'H':
	case 'h': {
	    const char *str, *end;
	    I32 l, field_len;
	    U8 bits;
	    bool utf8_source;
	    U32 utf8_flags;

	    fromstr = NEXTFROM;
	    str = SvPV_const(fromstr, fromlen);
	    end = str + fromlen;
	    if (DO_UTF8(fromstr)) {
		utf8_source = TRUE;
		utf8_flags  = warn_utf8 ? 0 : UTF8_ALLOW_ANY;
	    } else {
		utf8_source = FALSE;
		utf8_flags  = 0; /* Unused, but keep compilers happy */
	    }
	    if (howlen == e_star) len = fromlen;
	    field_len = (len+1)/2;
	    GROWING(utf8, cat, start, cur, field_len);
	    if (!utf8_source && len > (I32)fromlen) len = fromlen;
	    bits = 0;
	    l = 0;
	    if (datumtype == 'H')
		while (l++ < len) {
		    if (utf8_source) {
			UV val = 0;
			NEXT_UNI_VAL(val, cur, str, end, utf8_flags);
			if (val < 256 && isALPHA(val))
			    bits |= (val + 9) & 0xf;
			else
			    bits |= val & 0xf;
		    } else if (isALPHA(*str))
			bits |= (*str++ + 9) & 0xf;
		    else
			bits |= *str++ & 0xf;
		    if (l & 1) bits <<= 4;
		    else {
			PUSH_BYTE(utf8, cur, bits);
			bits = 0;
		    }
		}
	    else
		while (l++ < len) {
		    if (utf8_source) {
			UV val = 0;
			NEXT_UNI_VAL(val, cur, str, end, utf8_flags);
			if (val < 256 && isALPHA(val))
			    bits |= ((val + 9) & 0xf) << 4;
			else
			    bits |= (val & 0xf) << 4;
		    } else if (isALPHA(*str))
			bits |= ((*str++ + 9) & 0xf) << 4;
		    else
			bits |= (*str++ & 0xf) << 4;
		    if (l & 1) bits >>= 4;
		    else {
			PUSH_BYTE(utf8, cur, bits);
			bits = 0;
		    }
		}
	    l--;
	    if (l & 1) {
		PUSH_BYTE(utf8, cur, bits);
		l++;
	    }
	    /* Determine how many chars are left in the requested field */
	    l /= 2;
	    if (howlen == e_star) field_len = 0;
	    else field_len -= l;
	    Zero(cur, field_len, char);
	    cur += field_len;
	    break;
	}
	case 'c':
	    while (len-- > 0) {
		IV aiv;
		fromstr = NEXTFROM;
                aiv = SvIV_no_inf(fromstr, datumtype);
		if ((-128 > aiv || aiv > 127))
		    Perl_ck_warner(aTHX_ packWARN(WARN_PACK),
				   "Character in 'c' format wrapped in pack");
		PUSH_BYTE(utf8, cur, (U8)(aiv & 0xff));
	    }
	    break;
	case 'C':
	    if (len == 0) {
		utf8 = (symptr->flags & FLAG_DO_UTF8) ? 1 : 0;
		break;
	    }
	    while (len-- > 0) {
		IV aiv;
		fromstr = NEXTFROM;
                aiv = SvIV_no_inf(fromstr, datumtype);
		if ((0 > aiv || aiv > 0xff))
		    Perl_ck_warner(aTHX_ packWARN(WARN_PACK),
				   "Character in 'C' format wrapped in pack");
		PUSH_BYTE(utf8, cur, (U8)(aiv & 0xff));
	    }
	    break;
	case 'W': {
	    char *end;
	    U8 in_bytes = (U8)IN_BYTES;

	    end = start+SvLEN(cat)-1;
	    if (utf8) end -= UTF8_MAXLEN-1;
	    while (len-- > 0) {
		UV auv;
		fromstr = NEXTFROM;
		auv = SvUV_no_inf(fromstr, datumtype);
		if (in_bytes) auv = auv % 0x100;
		if (utf8) {
		  W_utf8:
		    if (cur > end) {
			*cur = '\0';
			SvCUR_set(cat, cur - start);

			GROWING(0, cat, start, cur, len+UTF8_MAXLEN);
			end = start+SvLEN(cat)-UTF8_MAXLEN;
		    }
		    cur = (char *) uvchr_to_utf8_flags((U8 *) cur,
						       auv,
						       warn_utf8 ?
						       0 : UNICODE_ALLOW_ANY);
		} else {
		    if (auv >= 0x100) {
			if (!SvUTF8(cat)) {
			    *cur = '\0';
			    SvCUR_set(cat, cur - start);
			    marked_upgrade(aTHX_ cat, symptr);
			    lookahead.flags |= FLAG_DO_UTF8;
			    lookahead.strbeg = symptr->strbeg;
			    utf8 = 1;
			    start = SvPVX(cat);
			    cur = start + SvCUR(cat);
			    end = start+SvLEN(cat)-UTF8_MAXLEN;
			    goto W_utf8;
			}
			Perl_ck_warner(aTHX_ packWARN(WARN_PACK),
				       "Character in 'W' format wrapped in pack");
			auv &= 0xff;
		    }
		    if (cur >= end) {
			*cur = '\0';
			SvCUR_set(cat, cur - start);
			GROWING(0, cat, start, cur, len+1);
			end = start+SvLEN(cat)-1;
		    }
		    *(U8 *) cur++ = (U8)auv;
		}
	    }
	    break;
	}
	case 'U': {
	    char *end;

	    if (len == 0) {
		if (!(symptr->flags & FLAG_DO_UTF8)) {
		    marked_upgrade(aTHX_ cat, symptr);
		    lookahead.flags |= FLAG_DO_UTF8;
		    lookahead.strbeg = symptr->strbeg;
		}
		utf8 = 0;
		goto no_change;
	    }

	    end = start+SvLEN(cat);
	    if (!utf8) end -= UTF8_MAXLEN;
	    while (len-- > 0) {
		UV auv;
		fromstr = NEXTFROM;
		auv = SvUV_no_inf(fromstr, datumtype);
		if (utf8) {
		    U8 buffer[UTF8_MAXLEN], *endb;
		    endb = uvchr_to_utf8_flags(buffer, UNI_TO_NATIVE(auv),
					       warn_utf8 ?
					       0 : UNICODE_ALLOW_ANY);
		    if (cur+(endb-buffer)*UTF8_EXPAND >= end) {
			*cur = '\0';
			SvCUR_set(cat, cur - start);
			GROWING(0, cat, start, cur,
				len+(endb-buffer)*UTF8_EXPAND);
			end = start+SvLEN(cat);
		    }
                    cur = my_bytes_to_utf8(buffer, endb-buffer, cur, 0);
		} else {
		    if (cur >= end) {
			*cur = '\0';
			SvCUR_set(cat, cur - start);
			GROWING(0, cat, start, cur, len+UTF8_MAXLEN);
			end = start+SvLEN(cat)-UTF8_MAXLEN;
		    }
		    cur = (char *) uvchr_to_utf8_flags((U8 *) cur, UNI_TO_NATIVE(auv),
						       warn_utf8 ?
						       0 : UNICODE_ALLOW_ANY);
		}
	    }
	    break;
	}
	/* Float and double added by gnb@@melba.bby.oz.au  22/11/89 */
	case 'f':
	    while (len-- > 0) {
		float afloat;
		NV anv;
		fromstr = NEXTFROM;
		anv = SvNV(fromstr);
# if defined(VMS) && !defined(_IEEE_FP)
		/* IEEE fp overflow shenanigans are unavailable on VAX and optional
		 * on Alpha; fake it if we don't have them.
		 */
		if (anv > FLT_MAX)
		    afloat = FLT_MAX;
		else if (anv < -FLT_MAX)
		    afloat = -FLT_MAX;
		else afloat = (float)anv;
# else
#if defined(NAN_COMPARE_BROKEN) && defined(Perl_isnan)
		if(Perl_isnan(anv))
		    afloat = (float)NV_NAN;
		else
#endif
                /* a simple cast to float is undefined if outside
                 * the range of values that can be represented */
		afloat = (float)(anv >  FLT_MAX ?  NV_INF :
                                 anv < -FLT_MAX ? -NV_INF : anv);
# endif
                PUSH_VAR(utf8, cur, afloat, needs_swap);
	    }
	    break;
	case 'd':
	    while (len-- > 0) {
		double adouble;
		NV anv;
		fromstr = NEXTFROM;
		anv = SvNV(fromstr);
# if defined(VMS) && !defined(_IEEE_FP)
		/* IEEE fp overflow shenanigans are unavailable on VAX and optional
		 * on Alpha; fake it if we don't have them.
		 */
		if (anv > DBL_MAX)
		    adouble = DBL_MAX;
		else if (anv < -DBL_MAX)
		    adouble = -DBL_MAX;
		else adouble = (double)anv;
# else
		adouble = (double)anv;
# endif
                PUSH_VAR(utf8, cur, adouble, needs_swap);
	    }
	    break;
	case 'F': {
	    NV_bytes anv;
	    Zero(&anv, 1, NV); /* can be long double with unused bits */
	    while (len-- > 0) {
		fromstr = NEXTFROM;
#ifdef __GNUC__
		/* to work round a gcc/x86 bug; don't use SvNV */
		anv.nv = sv_2nv(fromstr);
#    if defined(LONGDOUBLE_X86_80_BIT) && defined(USE_LONG_DOUBLE) \
         && LONG_DOUBLESIZE > 10
                /* GCC sometimes overwrites the padding in the
                   assignment above */
                Zero(anv.bytes+10, sizeof(anv.bytes) - 10, U8);
#    endif
#else
		anv.nv = SvNV(fromstr);
#endif
                PUSH_BYTES(utf8, cur, anv.bytes, sizeof(anv.bytes), needs_swap);
	    }
	    break;
	}
#if defined(HAS_LONG_DOUBLE) && defined(USE_LONG_DOUBLE)
	case 'D': {
	    ld_bytes aldouble;
	    /* long doubles can have unused bits, which may be nonzero */
	    Zero(&aldouble, 1, long double);
	    while (len-- > 0) {
		fromstr = NEXTFROM;
#  ifdef __GNUC__
		/* to work round a gcc/x86 bug; don't use SvNV */
		aldouble.ld = (long double)sv_2nv(fromstr);
#    if defined(LONGDOUBLE_X86_80_BIT) && LONG_DOUBLESIZE > 10
                /* GCC sometimes overwrites the padding in the
                   assignment above */
                Zero(aldouble.bytes+10, sizeof(aldouble.bytes) - 10, U8);
#    endif
#  else
		aldouble.ld = (long double)SvNV(fromstr);
#  endif
                PUSH_BYTES(utf8, cur, aldouble.bytes, sizeof(aldouble.bytes),
                           needs_swap);
	    }
	    break;
	}
#endif
	case 'n' | TYPE_IS_SHRIEKING:
	case 'n':
	    while (len-- > 0) {
		I16 ai16;
		fromstr = NEXTFROM;
		ai16 = (I16)SvIV_no_inf(fromstr, datumtype);
		ai16 = PerlSock_htons(ai16);
                PUSH16(utf8, cur, &ai16, FALSE);
	    }
	    break;
	case 'v' | TYPE_IS_SHRIEKING:
	case 'v':
	    while (len-- > 0) {
		I16 ai16;
		fromstr = NEXTFROM;
		ai16 = (I16)SvIV_no_inf(fromstr, datumtype);
		ai16 = htovs(ai16);
                PUSH16(utf8, cur, &ai16, FALSE);
	    }
	    break;
        case 'S' | TYPE_IS_SHRIEKING:
#if SHORTSIZE != SIZE16
	    while (len-- > 0) {
		unsigned short aushort;
		fromstr = NEXTFROM;
		aushort = SvUV_no_inf(fromstr, datumtype);
                PUSH_VAR(utf8, cur, aushort, needs_swap);
	    }
            break;
#else
            /* FALLTHROUGH */
#endif
	case 'S':
	    while (len-- > 0) {
		U16 au16;
		fromstr = NEXTFROM;
		au16 = (U16)SvUV_no_inf(fromstr, datumtype);
                PUSH16(utf8, cur, &au16, needs_swap);
	    }
	    break;
	case 's' | TYPE_IS_SHRIEKING:
#if SHORTSIZE != SIZE16
	    while (len-- > 0) {
		short ashort;
		fromstr = NEXTFROM;
		ashort = SvIV_no_inf(fromstr, datumtype);
                PUSH_VAR(utf8, cur, ashort, needs_swap);
	    }
            break;
#else
            /* FALLTHROUGH */
#endif
	case 's':
	    while (len-- > 0) {
		I16 ai16;
		fromstr = NEXTFROM;
		ai16 = (I16)SvIV_no_inf(fromstr, datumtype);
                PUSH16(utf8, cur, &ai16, needs_swap);
	    }
	    break;
	case 'I':
	case 'I' | TYPE_IS_SHRIEKING:
	    while (len-- > 0) {
		unsigned int auint;
		fromstr = NEXTFROM;
		auint = SvUV_no_inf(fromstr, datumtype);
                PUSH_VAR(utf8, cur, auint, needs_swap);
	    }
	    break;
	case 'j':
	    while (len-- > 0) {
		IV aiv;
		fromstr = NEXTFROM;
		aiv = SvIV_no_inf(fromstr, datumtype);
                PUSH_VAR(utf8, cur, aiv, needs_swap);
	    }
	    break;
	case 'J':
	    while (len-- > 0) {
		UV auv;
		fromstr = NEXTFROM;
		auv = SvUV_no_inf(fromstr, datumtype);
                PUSH_VAR(utf8, cur, auv, needs_swap);
	    }
	    break;
	case 'w':
            while (len-- > 0) {
		NV anv;
		fromstr = NEXTFROM;
		S_sv_check_infnan(aTHX_ fromstr, datumtype);
		anv = SvNV_nomg(fromstr);

		if (anv < 0) {
		    *cur = '\0';
		    SvCUR_set(cat, cur - start);
		    Perl_croak(aTHX_ "Cannot compress negative numbers in pack");
		}

                /* 0xFFFFFFFFFFFFFFFF may cast to 18446744073709551616.0,
                   which is == UV_MAX_P1. IOK is fine (instead of UV_only), as
                   any negative IVs will have already been got by the croak()
                   above. IOK is untrue for fractions, so we test them
                   against UV_MAX_P1.  */
		if (SvIOK(fromstr) || anv < UV_MAX_P1) {
		    char   buf[(sizeof(UV)*CHAR_BIT)/7+1];
		    char  *in = buf + sizeof(buf);
		    UV     auv = SvUV_nomg(fromstr);

		    do {
			*--in = (char)((auv & 0x7f) | 0x80);
			auv >>= 7;
		    } while (auv);
		    buf[sizeof(buf) - 1] &= 0x7f; /* clear continue bit */
		    PUSH_GROWING_BYTES(utf8, cat, start, cur,
				       in, (buf + sizeof(buf)) - in);
		} else if (SvPOKp(fromstr))
		    goto w_string;
		else if (SvNOKp(fromstr)) {
		    /* 10**NV_MAX_10_EXP is the largest power of 10
		       so 10**(NV_MAX_10_EXP+1) is definitely unrepresentable
		       given 10**(NV_MAX_10_EXP+1) == 128 ** x solve for x:
		       x = (NV_MAX_10_EXP+1) * log (10) / log (128)
		       And with that many bytes only Inf can overflow.
		       Some C compilers are strict about integral constant
		       expressions so we conservatively divide by a slightly
		       smaller integer instead of multiplying by the exact
		       floating-point value.
		    */
#ifdef NV_MAX_10_EXP
		    /* char   buf[1 + (int)((NV_MAX_10_EXP + 1) * 0.47456)]; -- invalid C */
		    char   buf[1 + (int)((NV_MAX_10_EXP + 1) / 2)]; /* valid C */
#else
		    /* char   buf[1 + (int)((308 + 1) * 0.47456)]; -- invalid C */
		    char   buf[1 + (int)((308 + 1) / 2)]; /* valid C */
#endif
		    char  *in = buf + sizeof(buf);

		    anv = Perl_floor(anv);
		    do {
			const NV next = Perl_floor(anv / 128);
			if (in <= buf)  /* this cannot happen ;-) */
			    Perl_croak(aTHX_ "Cannot compress integer in pack");
			*--in = (unsigned char)(anv - (next * 128)) | 0x80;
			anv = next;
		    } while (anv > 0);
		    buf[sizeof(buf) - 1] &= 0x7f; /* clear continue bit */
		    PUSH_GROWING_BYTES(utf8, cat, start, cur,
				       in, (buf + sizeof(buf)) - in);
		} else {
		    const char     *from;
		    char           *result, *in;
		    SV             *norm;
		    STRLEN          len;
		    bool            done;

		  w_string:
		    /* Copy string and check for compliance */
		    from = SvPV_nomg_const(fromstr, len);
		    if ((norm = is_an_int(from, len)) == NULL)
			Perl_croak(aTHX_ "Can only compress unsigned integers in pack");

		    Newx(result, len, char);
		    in = result + len;
		    done = FALSE;
		    while (!done) *--in = div128(norm, &done) | 0x80;
		    result[len - 1] &= 0x7F; /* clear continue bit */
		    PUSH_GROWING_BYTES(utf8, cat, start, cur,
				       in, (result + len) - in);
		    Safefree(result);
		    SvREFCNT_dec(norm);	/* free norm */
		}
	    }
            break;
	case 'i':
	case 'i' | TYPE_IS_SHRIEKING:
	    while (len-- > 0) {
		int aint;
		fromstr = NEXTFROM;
		aint = SvIV_no_inf(fromstr, datumtype);
                PUSH_VAR(utf8, cur, aint, needs_swap);
	    }
	    break;
	case 'N' | TYPE_IS_SHRIEKING:
	case 'N':
	    while (len-- > 0) {
		U32 au32;
		fromstr = NEXTFROM;
		au32 = SvUV_no_inf(fromstr, datumtype);
		au32 = PerlSock_htonl(au32);
                PUSH32(utf8, cur, &au32, FALSE);
	    }
	    break;
	case 'V' | TYPE_IS_SHRIEKING:
	case 'V':
	    while (len-- > 0) {
		U32 au32;
		fromstr = NEXTFROM;
		au32 = SvUV_no_inf(fromstr, datumtype);
		au32 = htovl(au32);
                PUSH32(utf8, cur, &au32, FALSE);
	    }
	    break;
	case 'L' | TYPE_IS_SHRIEKING:
#if LONGSIZE != SIZE32
	    while (len-- > 0) {
		unsigned long aulong;
		fromstr = NEXTFROM;
		aulong = SvUV_no_inf(fromstr, datumtype);
                PUSH_VAR(utf8, cur, aulong, needs_swap);
	    }
	    break;
#else
            /* Fall though! */
#endif
	case 'L':
	    while (len-- > 0) {
		U32 au32;
		fromstr = NEXTFROM;
		au32 = SvUV_no_inf(fromstr, datumtype);
                PUSH32(utf8, cur, &au32, needs_swap);
	    }
	    break;
	case 'l' | TYPE_IS_SHRIEKING:
#if LONGSIZE != SIZE32
	    while (len-- > 0) {
		long along;
		fromstr = NEXTFROM;
		along = SvIV_no_inf(fromstr, datumtype);
                PUSH_VAR(utf8, cur, along, needs_swap);
	    }
	    break;
#else
            /* Fall though! */
#endif
	case 'l':
            while (len-- > 0) {
		I32 ai32;
		fromstr = NEXTFROM;
		ai32 = SvIV_no_inf(fromstr, datumtype);
                PUSH32(utf8, cur, &ai32, needs_swap);
	    }
	    break;
#if defined(HAS_QUAD) && IVSIZE >= 8
	case 'Q':
	    while (len-- > 0) {
		Uquad_t auquad;
		fromstr = NEXTFROM;
		auquad = (Uquad_t) SvUV_no_inf(fromstr, datumtype);
                PUSH_VAR(utf8, cur, auquad, needs_swap);
	    }
	    break;
	case 'q':
	    while (len-- > 0) {
		Quad_t aquad;
		fromstr = NEXTFROM;
		aquad = (Quad_t)SvIV_no_inf(fromstr, datumtype);
                PUSH_VAR(utf8, cur, aquad, needs_swap);
	    }
	    break;
#endif
	case 'P':
	    len = 1;		/* assume SV is correct length */
	    GROWING(utf8, cat, start, cur, sizeof(char *));
	    /* FALLTHROUGH */
	case 'p':
	    while (len-- > 0) {
		const char *aptr;

		fromstr = NEXTFROM;
		SvGETMAGIC(fromstr);
		if (!SvOK(fromstr)) aptr = NULL;
		else {
		    /* XXX better yet, could spirit away the string to
		     * a safe spot and hang on to it until the result
		     * of pack() (and all copies of the result) are
		     * gone.
		     */
		    if ((SvTEMP(fromstr) || (SvPADTMP(fromstr) &&
			     !SvREADONLY(fromstr)))) {
			Perl_ck_warner(aTHX_ packWARN(WARN_PACK),
				       "Attempt to pack pointer to temporary value");
		    }
		    if (SvPOK(fromstr) || SvNIOK(fromstr))
			aptr = SvPV_nomg_const_nolen(fromstr);
		    else
			aptr = SvPV_force_flags_nolen(fromstr, 0);
		}
                PUSH_VAR(utf8, cur, aptr, needs_swap);
	    }
	    break;
	case 'u': {
	    const char *aptr, *aend;
	    bool from_utf8;

	    fromstr = NEXTFROM;
	    if (len <= 2) len = 45;
	    else len = len / 3 * 3;
	    if (len >= 64) {
		Perl_ck_warner(aTHX_ packWARN(WARN_PACK),
			       "Field too wide in 'u' format in pack");
		len = 63;
	    }
	    aptr = SvPV_const(fromstr, fromlen);
	    from_utf8 = DO_UTF8(fromstr);
	    if (from_utf8) {
		aend = aptr + fromlen;
		fromlen = sv_len_utf8_nomg(fromstr);
	    } else aend = NULL; /* Unused, but keep compilers happy */
	    GROWING(utf8, cat, start, cur, (fromlen+2) / 3 * 4 + (fromlen+len-1)/len * 2);
	    while (fromlen > 0) {
		U8 *end;
		I32 todo;
		U8 hunk[1+63/3*4+1];

		if ((I32)fromlen > len)
		    todo = len;
		else
		    todo = fromlen;
		if (from_utf8) {
		    char buffer[64];
		    if (!S_utf8_to_bytes(aTHX_ &aptr, aend, buffer, todo,
				      'u' | TYPE_IS_PACK)) {
			*cur = '\0';
			SvCUR_set(cat, cur - start);
			Perl_croak(aTHX_ "panic: string is shorter than advertised, "
				   "aptr=%p, aend=%p, buffer=%p, todo=%ld",
				   aptr, aend, buffer, (long) todo);
		    }
		    end = doencodes(hunk, (const U8 *)buffer, todo);
		} else {
		    end = doencodes(hunk, (const U8 *)aptr, todo);
		    aptr += todo;
		}
		PUSH_BYTES(utf8, cur, hunk, end-hunk, 0);
		fromlen -= todo;
	    }
	    break;
	}
	}
	*cur = '\0';
	SvCUR_set(cat, cur - start);
      no_change:
	*symptr = lookahead;
    }
    return beglist;
}
#undef NEXTFROM


PP(pp_pack)
{
    dSP; dMARK; dORIGMARK; dTARGET;
    SV *cat = TARG;
    STRLEN fromlen;
    SV *pat_sv = *++MARK;
    const char *pat = SvPV_const(pat_sv, fromlen);
    const char *patend = pat + fromlen;

    MARK++;
    sv_setpvs(cat, "");
    SvUTF8_off(cat);

    packlist(cat, pat, patend, MARK, SP + 1);

    SvSETMAGIC(cat);
    SP = ORIGMARK;
    PUSHs(cat);
    RETURN;
}

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
@


1.1
log
@Initial revision
@
text
@d3 2
a4 1
 *    Copyright (c) 1991-2002, Larry Wall
d17 12
d35 52
a86 9
/*
 * The compiler on Concurrent CX/UX systems has a subtle bug which only
 * seems to show up when compiling pp.c - it generates the wrong double
 * precision constant value for (double)UV_MAX when used inline in the body
 * of the code below, so this makes a static variable up front (which the
 * compiler seems to get correct) and uses it in place of UV_MAX below.
 */
#ifdef CXUX_BROKEN_CONSTANT_CONVERT
static double UV_MAX_cxux = ((double)UV_MAX);
d88 2
d115 4
a118 8
#if SHORTSIZE != SIZE16 || LONGSIZE != SIZE32
#   define PERL_NATINT_PACK
#endif

#if LONGSIZE > 4 && defined(_CRAY)
#  if BYTEORDER == 0x12345678
#    define OFF16(p)	(char*)(p)
#    define OFF32(p)	(char*)(p)
d120 1
a120 1
#    if BYTEORDER == 0x87654321
d124 1
a124 1
       }}}} bad cray byte order
a126 5
#  define COPY16(s,p)  (*(p) = 0, Copy(s, OFF16(p), SIZE16, char))
#  define COPY32(s,p)  (*(p) = 0, Copy(s, OFF32(p), SIZE32, char))
#  define COPYNN(s,p,n) (*(p) = 0, Copy(s, (char *)(p), n, char))
#  define CAT16(sv,p)  sv_catpvn(sv, OFF16(p), SIZE16)
#  define CAT32(sv,p)  sv_catpvn(sv, OFF32(p), SIZE32)
d128 2
a129 5
#  define COPY16(s,p)  Copy(s, p, SIZE16, char)
#  define COPY32(s,p)  Copy(s, p, SIZE32, char)
#  define COPYNN(s,p,n) Copy(s, (char *)(p), n, char)
#  define CAT16(sv,p)  sv_catpvn(sv, (char*)(p), SIZE16)
#  define CAT32(sv,p)  sv_catpvn(sv, (char*)(p), SIZE32)
d132 57
d195 2
a196 1
  U32             i = 0;
d199 1
a199 1
    SV             *tmpNew = newSVpvn("0000000000", 10);
d210 1
a210 1
    i = ((*t - '0') << 7) + m;
d219 52
a270 10
#if 'I' == 73 && 'J' == 74
/* On an ASCII/ISO kind of system */
#define ISUUCHAR(ch)    ((ch) >= ' ' && (ch) < 'a')
#else
/*
  Some other sort of character set - use memchr() so we don't match
  the null byte.
 */
#define ISUUCHAR(ch)    (memchr(PL_uuemap, (ch), sizeof(PL_uuemap)-1) || (ch) == ' ')
#endif
d272 56
a327 2
#define UNPACK_ONLY_ONE	0x1
#define UNPACK_DO_UTF8	0x2
d330 84
a413 1
S_group_end(pTHX_ register char *pat, register char *patend, char ender)
d415 115
a529 2
    while (pat < patend) {
	char c = *pat++;
d534 1
a534 1
	    return --pat;
d536 2
a537 2
	    while (pat < patend && *pat != '\n')
		pat++;
d540 1
a540 1
	    pat = group_end(pat, patend, ')') + 1;
d542 1
a542 1
	    pat = group_end(pat, patend, ']') + 1;
d544 3
a546 2
    Perl_croak(aTHX_ "No group ending character `%c' found", ender);
    return 0;
a548 1
#define TYPE_IS_SHRIEKING	0x100
d550 25
a574 3
/* Returns the sizeof() struct described by pat */
STATIC I32
S_measure_struct(pTHX_ char *pat, register char *patend)
d576 96
a671 38
    I32 datumtype;
    register I32 len;
    register I32 total = 0;
    int commas = 0;
    int star;		/* 1 if count is *, -1 if no count given, -2 for / */
#ifdef PERL_NATINT_PACK
    int natint;		/* native integer */
    int unatint;	/* unsigned native integer */
#endif
    char buf[2];
    register int size;

    while ((pat = next_symbol(pat, patend)) < patend) {
	datumtype = *pat++ & 0xFF;
#ifdef PERL_NATINT_PACK
	natint = 0;
#endif
	if (*pat == '!') {
	    static const char *natstr = "sSiIlLxX";

	    if (strchr(natstr, datumtype)) {
		if (datumtype == 'x' || datumtype == 'X') {
		    datumtype |= TYPE_IS_SHRIEKING;
		} else {		/* XXXX Should be redone similarly! */
#ifdef PERL_NATINT_PACK
		    natint = 1;
#endif
		}
		pat++;
	    }
	    else
		Perl_croak(aTHX_ "'!' allowed only after types %s", natstr);
	}
	len = find_count(&pat, patend, &star);
	if (star > 0)			/*  */
		Perl_croak(aTHX_ "%s not allowed in length fields", "count *");
	else if (star < 0)		/* No explicit len */
		len = datumtype != '@@';
d673 2
a674 22
	switch(datumtype) {
	default:
	    Perl_croak(aTHX_ "Invalid type in unpack: '%c'", (int)datumtype);
	case '@@':
	case '/':
	case 'U':			/* XXXX Is it correct? */
	case 'w':
	case 'u':
	    buf[0] = (char)datumtype;
	    buf[1] = 0;
	    Perl_croak(aTHX_ "%s not allowed in length fields", buf);
	case ',': /* grandfather in commas but with a warning */
	    if (commas++ == 0 && ckWARN(WARN_UNPACK))
		Perl_warner(aTHX_ packWARN(WARN_UNPACK),
			    "Invalid type in unpack: '%c'", (int)datumtype);
	    /* FALL THROUGH */
	case '%':
	    size = 0;
	    break;
	case '(':
	{
	    char *beg = pat, *end;
d676 53
a728 15
	    if (star >= 0)
		Perl_croak(aTHX_ "()-group starts with a count");
	    end = group_end(beg, patend, ')');
	    pat = end + 1;
	    len = find_count(&pat, patend, &star);
	    if (star < 0)		/* No count */
		len = 1;
	    else if (star > 0)	/* Star */
		Perl_croak(aTHX_ "%s not allowed in length fields", "count *");
 	    /* XXXX Theoretically, we need to measure many times at different
 	       positions, since the subexpression may contain
 	       alignment commands, but be not of aligned length.
 	       Need to detect this and croak().  */
	    size = measure_struct(beg, end);
	    break;
d730 9
a738 114
 	case 'X' | TYPE_IS_SHRIEKING:
 	    /* XXXX Is this useful?  Then need to treat MEASURE_BACKWARDS. */
 	    if (!len)			/* Avoid division by 0 */
 		len = 1;
 	    len = total % len;		/* Assumed: the start is aligned. */
 	    /* FALL THROUGH */
	case 'X':
	    size = -1;
	    if (total < len)
		Perl_croak(aTHX_ "X outside of string");
	    break;
 	case 'x' | TYPE_IS_SHRIEKING:
 	    if (!len)			/* Avoid division by 0 */
 		len = 1;
 	    star = total % len;		/* Assumed: the start is aligned. */
 	    if (star)			/* Other portable ways? */
 		len = len - star;
 	    else
 		len = 0;
 	    /* FALL THROUGH */
	case 'x':
	case 'A':
	case 'Z':
	case 'a':
	case 'c':
	case 'C':
	    size = 1;
	    break;
	case 'B':
	case 'b':
	    len = (len + 7)/8;
	    size = 1;
	    break;
	case 'H':
	case 'h':
	    len = (len + 1)/2;
	    size = 1;
	    break;
	case 's':
#if SHORTSIZE == SIZE16
	    size = SIZE16;
#else
	    size = (natint ? sizeof(short) : SIZE16);
#endif
	    break;
	case 'v':
	case 'n':
	case 'S':
#if SHORTSIZE == SIZE16
	    size = SIZE16;
#else
	    unatint = natint && datumtype == 'S';
	    size = (unatint ? sizeof(unsigned short) : SIZE16);
#endif
	    break;
	case 'i':
	    size = sizeof(int);
	    break;
	case 'I':
	    size = sizeof(unsigned int);
	    break;
	case 'j':
	    size = IVSIZE;
	    break;
	case 'J':
	    size = UVSIZE;
	    break;
	case 'l':
#if LONGSIZE == SIZE32
	    size = SIZE32;
#else
	    size = (natint ? sizeof(long) : SIZE32);
#endif
	    break;
	case 'V':
	case 'N':
	case 'L':
#if LONGSIZE == SIZE32
	    size = SIZE32;
#else
	    unatint = natint && datumtype == 'L';
	    size = (unatint ? sizeof(unsigned long) : SIZE32);
#endif
	    break;
	case 'P':
	    len = 1;
	    /* FALL THROUGH */
	case 'p':
	    size = sizeof(char*);
	    break;
#ifdef HAS_QUAD
	case 'q':
	    size = sizeof(Quad_t);
	    break;
	case 'Q':
	    size = sizeof(Uquad_t);
	    break;
#endif
	case 'f':
	    size = sizeof(float);
	    break;
	case 'd':
	    size = sizeof(double);
	    break;
	case 'F':
	    size = NVSIZE;
	    break;
#if defined(HAS_LONG_DOUBLE) && defined(USE_LONG_DOUBLE)
	case 'D':
	    size = LONG_DOUBLESIZE;
	    break;
#endif
	}
	total += len * size;
d740 3
a742 1
    return total;
d745 11
a755 3
/* Returns -1 on no count or on star */
STATIC I32
S_find_count(pTHX_ char **ppat, register char *patend, int *star)
d757 1
a757 2
    char *pat = *ppat;
    I32 len;
d759 10
a768 4
    *star = 0;
    if (pat >= patend)
	len = 1;
    else if (*pat == '*') {
a769 2
	*star = 1;
	len = -1;
d771 1
a771 21
    else if (isDIGIT(*pat)) {
	len = *pat++ - '0';
	while (isDIGIT(*pat)) {
	    len = (len * 10) + (*pat++ - '0');
	    if (len < 0)		/* 50% chance of catching... */
		Perl_croak(aTHX_ "Repeat count in pack/unpack overflows");
	}
    }
    else if (*pat == '[') {
	char *end = group_end(++pat, patend, ']');

	len = 0;
	*ppat = end + 1;
	if (isDIGIT(*pat))
	    return find_count(&pat, end, star);
	return measure_struct(pat, end);
    }
    else
	len = *star = -1;
    *ppat = pat;
    return len;
d774 4
a777 3
STATIC char *
S_next_symbol(pTHX_ register char *pat, register char *patend)
{
d779 5
a783 11
	if (isSPACE(*pat))
	    pat++;
	else if (*pat == '#') {
	    pat++;
	    while (pat < patend && *pat != '\n')
		pat++;
	    if (pat < patend)
		pat++;
	}
	else
	    return pat;
d785 1
a785 1
    return pat;
a788 1
=for apidoc unpack_str
d790 19
a808 1
The engine implementing unpack() Perl function.
d813 27
a839 1
Perl_unpack_str(pTHX_ char *pat, register char *patend, register char *s, char *strbeg, char *strend, char **new_s, I32 ocnt, U32 flags)
d842 3
a844 23
    I32 datumtype;
    register I32 len;
    register I32 bits = 0;
    register char *str;
    SV *sv;
    I32 start_sp_offset = SP - PL_stack_base;

    /* These must not be in registers: */
    short ashort;
    int aint;
    long along;
#ifdef HAS_QUAD
    Quad_t aquad;
#endif
    U16 aushort;
    unsigned int auint;
    U32 aulong;
#ifdef HAS_QUAD
    Uquad_t auquad;
#endif
    char *aptr;
    float afloat;
    double adouble;
d848 15
a862 20
    const int bits_in_uv = 8 * sizeof(cuv);
    int commas = 0;
    int star;		/* 1 if count is *, -1 if no count given, -2 for / */
#ifdef PERL_NATINT_PACK
    int natint;		/* native integer */
    int unatint;	/* unsigned native integer */
#endif
    IV aiv;
    UV auv;
    NV anv;
#if defined(HAS_LONG_DOUBLE) && defined(USE_LONG_DOUBLE)
    long double aldouble;
#endif
    bool do_utf8 = (flags & UNPACK_DO_UTF8) != 0;

    while ((pat = next_symbol(pat, patend)) < patend) {
	datumtype = *pat++ & 0xFF;
#ifdef PERL_NATINT_PACK
	natint = 0;
#endif
d864 1
a864 1
	   / is implemented by unpacking the count, then poping it from the
d866 1
a866 1
        if ( (flags & UNPACK_ONLY_ONE)
d868 1
a868 1
	     && (datumtype != '/') )
a869 2
	if (*pat == '!') {
	    static const char natstr[] = "sSiIlLxX";
d871 26
a896 9
	    if (strchr(natstr, datumtype)) {
		if (datumtype == 'x' || datumtype == 'X') {
		    datumtype |= TYPE_IS_SHRIEKING;
		} else {		/* XXXX Should be redone similarly! */
#ifdef PERL_NATINT_PACK
		    natint = 1;
#endif
		}
		pat++;
a897 2
	    else
		Perl_croak(aTHX_ "'!' allowed only after types %s", natstr);
a898 5
	len = find_count(&pat, patend, &star);
	if (star > 0)
		len = strend - strbeg;	/* long enough */
	else if (star < 0)		/* No explicit len */
		len = datumtype != '@@';
d900 3
a902 2
      redo_switch:
	switch(datumtype) {
d904 2
a905 6
	    Perl_croak(aTHX_ "Invalid type in unpack: '%c'", (int)datumtype);
	case ',': /* grandfather in commas but with a warning */
	    if (commas++ == 0 && ckWARN(WARN_UNPACK))
		Perl_warner(aTHX_ packWARN(WARN_UNPACK),
			    "Invalid type in unpack: '%c'", (int)datumtype);
	    break;
d907 1
a907 1
	    if (len == 1 && pat[-1] != '1' && pat[-1] != ']')
d913 1
a913 1
	    break;
d916 6
a921 14
	    char *beg = pat;
	    char *ss = s;		/* Move from register */

	    if (star >= 0)
		Perl_croak(aTHX_ "()-group starts with a count");
	    aptr = group_end(beg, patend, ')');
	    pat = aptr + 1;
	    if (star != -2) {
		len = find_count(&pat, patend, &star);
		if (star < 0)		/* No count */
		    len = 1;
		else if (star > 0)	/* Star */
		    len = strend - strbeg; /* long enough? */
	    }
d923 1
d925 6
a930 4
		unpack_str(beg, aptr, ss, strbeg, strend, &ss,
			   ocnt + SP - PL_stack_base - start_sp_offset, flags);
		if (star > 0 && ss == strend)
		    break;		/* No way to continue */
d933 2
a934 1
	    s = ss;
d937 20
d958 16
a973 3
	    if (len > strend - strbeg)
		Perl_croak(aTHX_ "@@ outside of string");
	    s = strbeg + len;
d978 18
a995 2
 	    len = (s - strbeg) % len;
 	    /* FALL THROUGH */
d997 15
a1011 3
	    if (len > s - strbeg)
		Perl_croak(aTHX_ "X outside of string");
	    s -= len;
d1013 2
a1014 1
 	case 'x' | TYPE_IS_SHRIEKING:
d1017 6
a1022 6
 	    aint = (s - strbeg) % len;
 	    if (aint)			/* Other portable ways? */
 		len = len - aint;
 	    else
 		len = 0;
 	    /* FALL THROUGH */
d1024 12
a1035 3
	    if (len > strend - s)
		Perl_croak(aTHX_ "x outside of string");
	    s += len;
d1038 2
a1039 10
	    if (ocnt + SP - PL_stack_base - start_sp_offset <= 0)
		Perl_croak(aTHX_ "/ must follow a numeric type");
	    datumtype = *pat++;
	    if (*pat == '*')
		pat++;		/* ignore '*' for compatibility with pack */
	    if (isDIGIT(*pat))
		Perl_croak(aTHX_ "/ cannot take a count" );
	    len = POPi;
	    star = -2;
	    goto redo_switch;
d1043 19
a1061 1
	    if (len > strend - s)
d1063 33
a1095 21
	    if (checksum)
		goto uchar_checksum;
	    sv = NEWSV(35, len);
	    sv_setpvn(sv, s, len);
	    if (datumtype == 'A' || datumtype == 'Z') {
		aptr = s;	/* borrow register */
		if (datumtype == 'Z') {	/* 'Z' strips stuff after first null */
		    s = SvPVX(sv);
		    while (*s)
			s++;
		    if (star > 0) /* exact for 'Z*' */
		        len = s - SvPVX(sv) + 1;
		}
		else {		/* 'A' strips both nulls and spaces */
		    s = SvPVX(sv) + len - 1;
		    while (s >= SvPVX(sv) && (!*s || isSPACE(*s)))
			s--;
		    *++s = '\0';
		}
		SvCUR_set(sv, s - SvPVX(sv));
		s = aptr;	/* unborrow register */
d1097 1
a1098 1
	    XPUSHs(sv_2mortal(sv));
d1101 3
a1103 2
	case 'b':
	    if (star > 0 || len > (strend - s) * 8)
d1106 14
a1119 20
		if (!PL_bitcount) {
		    Newz(601, PL_bitcount, 256, char);
		    for (bits = 1; bits < 256; bits++) {
			if (bits & 1)	PL_bitcount[bits]++;
			if (bits & 2)	PL_bitcount[bits]++;
			if (bits & 4)	PL_bitcount[bits]++;
			if (bits & 8)	PL_bitcount[bits]++;
			if (bits & 16)	PL_bitcount[bits]++;
			if (bits & 32)	PL_bitcount[bits]++;
			if (bits & 64)	PL_bitcount[bits]++;
			if (bits & 128)	PL_bitcount[bits]++;
		    }
		}
		while (len >= 8) {
		    cuv += PL_bitcount[*(unsigned char*)s++];
		    len -= 8;
		}
		if (len) {
		    bits = *s;
		    if (datumtype == 'b') {
d1124 1
a1124 2
		    }
		    else {
d1126 1
a1126 1
			    if (bits & 128) cuv++;
a1128 1
		    }
d1132 2
a1133 2
	    sv = NEWSV(35, len + 1);
	    SvCUR_set(sv, len);
d1137 20
a1156 17
		aint = len;
		for (len = 0; len < aint; len++) {
		    if (len & 7)		/*SUPPRESS 595*/
			bits >>= 1;
		    else
			bits = *s++;
		    *str++ = '0' + (bits & 1);
		}
	    }
	    else {
		aint = len;
		for (len = 0; len < aint; len++) {
		    if (len & 7)
			bits <<= 1;
		    else
			bits = *s++;
		    *str++ = '0' + ((bits & 128) != 0);
d1160 2
a1161 1
	    XPUSHs(sv_2mortal(sv));
d1163 1
d1165 4
a1168 2
	case 'h':
	    if (star > 0 || len > (strend - s) * 2)
d1170 5
a1174 4
	    sv = NEWSV(35, len + 1);
	    SvCUR_set(sv, len);
	    SvPOK_on(sv);
	    str = SvPVX(sv);
d1176 28
a1203 49
		aint = len;
		for (len = 0; len < aint; len++) {
		    if (len & 1)
			bits >>= 4;
		    else
			bits = *s++;
		    *str++ = PL_hexdigit[bits & 15];
		}
	    }
	    else {
		aint = len;
		for (len = 0; len < aint; len++) {
		    if (len & 1)
			bits <<= 4;
		    else
			bits = *s++;
		    *str++ = PL_hexdigit[(bits >> 4) & 15];
		}
	    }
	    *str = '\0';
	    XPUSHs(sv_2mortal(sv));
	    break;
	case 'c':
	    if (len > strend - s)
		len = strend - s;
	    if (checksum) {
		while (len-- > 0) {
		    aint = *s++;
		    if (aint >= 128)	/* fake up signed chars */
			aint -= 256;
		    if (checksum > bits_in_uv)
			cdouble += (NV)aint;
		    else
			cuv += aint;
		}
	    }
	    else {
                if (len && (flags & UNPACK_ONLY_ONE))
                    len = 1;
		EXTEND(SP, len);
		EXTEND_MORTAL(len);
		while (len-- > 0) {
		    aint = *s++;
		    if (aint >= 128)	/* fake up signed chars */
			aint -= 256;
		    sv = NEWSV(36, 0);
		    sv_setiv(sv, (IV)aint);
		    PUSHs(sv_2mortal(sv));
		}
d1206 1
a1207 1
	unpack_C: /* unpack U will jump here if not UTF-8 */
d1209 3
a1211 1
		do_utf8 = FALSE;
d1214 41
a1254 7
	    if (len > strend - s)
		len = strend - s;
	    if (checksum) {
	      uchar_checksum:
		while (len-- > 0) {
		    auint = *s++ & 255;
		    cuv += auint;
d1256 1
a1256 6
	    }
	    else {
                if (len && (flags & UNPACK_ONLY_ONE))
                    len = 1;
		EXTEND(SP, len);
		EXTEND_MORTAL(len);
d1258 2
a1259 5
		    auint = *s++ & 255;
		    sv = NEWSV(37, 0);
		    sv_setiv(sv, (IV)auint);
		    PUSHs(sv_2mortal(sv));
		}
d1261 4
d1268 3
a1270 15
		do_utf8 = TRUE;
		break;
	    }
	    if (!do_utf8)
		 goto unpack_C;
	    if (len > strend - s)
		len = strend - s;
	    if (checksum) {
		while (len-- > 0 && s < strend) {
		    STRLEN alen;
		    auint = NATIVE_TO_UNI(utf8n_to_uvchr((U8*)s, strend - s, &alen, ckWARN(WARN_UTF8) ? 0 : UTF8_ALLOW_ANYUV));
		    along = alen;
		    s += along;
		    if (checksum > bits_in_uv)
			cdouble += (NV)auint;
d1272 2
a1273 1
			cuv += auint;
d1275 1
d1277 3
a1279 3
	    else {
                if (len && (flags & UNPACK_ONLY_ONE))
                    len = 1;
d1282 36
a1317 9
		while (len-- > 0 && s < strend) {
		    STRLEN alen;
		    auint = NATIVE_TO_UNI(utf8n_to_uvchr((U8*)s, strend - s, &alen, ckWARN(WARN_UTF8) ? 0 : UTF8_ALLOW_ANYUV));
		    along = alen;
		    s += along;
		    sv = NEWSV(37, 0);
		    sv_setuv(sv, (UV)auint);
		    PUSHs(sv_2mortal(sv));
		}
d1320 1
a1320 9
	case 's':
#if SHORTSIZE == SIZE16
	    along = (strend - s) / SIZE16;
#else
	    along = (strend - s) / (natint ? sizeof(short) : SIZE16);
#endif
	    if (len > along)
		len = along;
	    if (checksum) {
d1322 7
a1328 12
		if (natint) {
		    short ashort;
		    while (len-- > 0) {
			COPYNN(s, &ashort, sizeof(short));
			s += sizeof(short);
			if (checksum > bits_in_uv)
			    cdouble += (NV)ashort;
			else
			    cuv += ashort;

		    }
		}
d1330 5
d1336 6
a1341 6
                {
		    while (len-- > 0) {
			COPY16(s, &ashort);
#if SHORTSIZE > SIZE16
			if (ashort > 32767)
			  ashort -= 65536;
d1343 11
a1353 7
			s += SIZE16;
			if (checksum > bits_in_uv)
			    cdouble += (NV)ashort;
			else
			    cuv += ashort;
		    }
		}
d1355 2
a1356 5
	    else {
                if (len && (flags & UNPACK_ONLY_ONE))
                    len = 1;
		EXTEND(SP, len);
		EXTEND_MORTAL(len);
d1358 8
a1365 10
		if (natint) {
		    short ashort;
		    while (len-- > 0) {
			COPYNN(s, &ashort, sizeof(short));
			s += sizeof(short);
			sv = NEWSV(38, 0);
			sv_setiv(sv, (IV)ashort);
			PUSHs(sv_2mortal(sv));
		    }
		}
d1367 1
a1367 14
#endif
                {
		    while (len-- > 0) {
			COPY16(s, &ashort);
#if SHORTSIZE > SIZE16
			if (ashort > 32767)
			  ashort -= 65536;
#endif
			s += SIZE16;
			sv = NEWSV(38, 0);
			sv_setiv(sv, (IV)ashort);
			PUSHs(sv_2mortal(sv));
		    }
		}
d1370 3
d1376 14
a1389 21
#if SHORTSIZE == SIZE16
	    along = (strend - s) / SIZE16;
#else
	    unatint = natint && datumtype == 'S';
	    along = (strend - s) / (unatint ? sizeof(unsigned short) : SIZE16);
#endif
	    if (len > along)
		len = along;
	    if (checksum) {
#if SHORTSIZE != SIZE16
		if (unatint) {
		    unsigned short aushort;
		    while (len-- > 0) {
			COPYNN(s, &aushort, sizeof(unsigned short));
			s += sizeof(unsigned short);
			if (checksum > bits_in_uv)
			    cdouble += (NV)aushort;
			else
			    cuv += aushort;
		    }
		}
d1391 1
a1391 19
#endif
                {
		    while (len-- > 0) {
			COPY16(s, &aushort);
			s += SIZE16;
#ifdef HAS_NTOHS
			if (datumtype == 'n')
			    aushort = PerlSock_ntohs(aushort);
#endif
#ifdef HAS_VTOHS
			if (datumtype == 'v')
			    aushort = vtohs(aushort);
#endif
			if (checksum > bits_in_uv)
			    cdouble += (NV)aushort;
			else
			    cuv += aushort;
		    }
		}
d1393 19
a1411 16
	    else {
                if (len && (flags & UNPACK_ONLY_ONE))
                    len = 1;
		EXTEND(SP, len);
		EXTEND_MORTAL(len);
#if SHORTSIZE != SIZE16
		if (unatint) {
		    unsigned short aushort;
		    while (len-- > 0) {
			COPYNN(s, &aushort, sizeof(unsigned short));
			s += sizeof(unsigned short);
			sv = NEWSV(39, 0);
			sv_setiv(sv, (UV)aushort);
			PUSHs(sv_2mortal(sv));
		    }
		}
d1413 1
a1413 18
#endif
                {
		    while (len-- > 0) {
			COPY16(s, &aushort);
			s += SIZE16;
			sv = NEWSV(39, 0);
#ifdef HAS_NTOHS
			if (datumtype == 'n')
			    aushort = PerlSock_ntohs(aushort);
#endif
#ifdef HAS_VTOHS
			if (datumtype == 'v')
			    aushort = vtohs(aushort);
#endif
			sv_setiv(sv, (UV)aushort);
			PUSHs(sv_2mortal(sv));
		    }
		}
d1417 10
a1426 50
	    along = (strend - s) / sizeof(int);
	    if (len > along)
		len = along;
	    if (checksum) {
		while (len-- > 0) {
		    Copy(s, &aint, 1, int);
		    s += sizeof(int);
		    if (checksum > bits_in_uv)
			cdouble += (NV)aint;
		    else
			cuv += aint;
		}
	    }
	    else {
                if (len && (flags & UNPACK_ONLY_ONE))
                    len = 1;
		EXTEND(SP, len);
		EXTEND_MORTAL(len);
		while (len-- > 0) {
		    Copy(s, &aint, 1, int);
		    s += sizeof(int);
		    sv = NEWSV(40, 0);
#ifdef __osf__
                    /* Without the dummy below unpack("i", pack("i",-1))
                     * return 0xFFffFFff instead of -1 for Digital Unix V4.0
                     * cc with optimization turned on.
		     *
		     * The bug was detected in
		     * DEC C V5.8-009 on Digital UNIX V4.0 (Rev. 1091) (V4.0E)
		     * with optimization (-O4) turned on.
		     * DEC C V5.2-040 on Digital UNIX V4.0 (Rev. 564) (V4.0B)
		     * does not have this problem even with -O4.
		     *
		     * This bug was reported as DECC_BUGS 1431
		     * and tracked internally as GEM_BUGS 7775.
		     *
		     * The bug is fixed in
		     * Tru64 UNIX V5.0:      Compaq C V6.1-006 or later
		     * UNIX V4.0F support:   DEC C V5.9-006 or later
		     * UNIX V4.0E support:   DEC C V5.8-011 or later
		     * and also in DTK.
		     *
		     * See also few lines later for the same bug.
		     */
                    (aint) ?
		    	sv_setiv(sv, (IV)aint) :
#endif
		    sv_setiv(sv, (IV)aint);
		    PUSHs(sv_2mortal(sv));
		}
d1430 10
a1439 32
	    along = (strend - s) / sizeof(unsigned int);
	    if (len > along)
		len = along;
	    if (checksum) {
		while (len-- > 0) {
		    Copy(s, &auint, 1, unsigned int);
		    s += sizeof(unsigned int);
		    if (checksum > bits_in_uv)
			cdouble += (NV)auint;
		    else
			cuv += auint;
		}
	    }
	    else {
                if (len && (flags & UNPACK_ONLY_ONE))
                    len = 1;
		EXTEND(SP, len);
		EXTEND_MORTAL(len);
		while (len-- > 0) {
		    Copy(s, &auint, 1, unsigned int);
		    s += sizeof(unsigned int);
		    sv = NEWSV(41, 0);
#ifdef __osf__
                    /* Without the dummy below unpack("I", pack("I",0xFFFFFFFF))
                     * returns 1.84467440737096e+19 instead of 0xFFFFFFFF.
		     * See details few lines earlier. */
                    (auint) ?
		        sv_setuv(sv, (UV)auint) :
#endif
		    sv_setuv(sv, (UV)auint);
		    PUSHs(sv_2mortal(sv));
		}
d1443 9
a1451 25
	    along = (strend - s) / IVSIZE;
	    if (len > along)
		len = along;
	    if (checksum) {
		while (len-- > 0) {
		    Copy(s, &aiv, 1, IV);
		    s += IVSIZE;
		    if (checksum > bits_in_uv)
			cdouble += (NV)aiv;
		    else
			cuv += aiv;
		}
	    }
	    else {
                if (len && (flags & UNPACK_ONLY_ONE))
                    len = 1;
		EXTEND(SP, len);
		EXTEND_MORTAL(len);
		while (len-- > 0) {
		    Copy(s, &aiv, 1, IV);
		    s += IVSIZE;
		    sv = NEWSV(40, 0);
		    sv_setiv(sv, aiv);
		    PUSHs(sv_2mortal(sv));
		}
d1455 9
a1463 12
	    along = (strend - s) / UVSIZE;
	    if (len > along)
		len = along;
	    if (checksum) {
		while (len-- > 0) {
		    Copy(s, &auv, 1, UV);
		    s += UVSIZE;
		    if (checksum > bits_in_uv)
			cdouble += (NV)auv;
		    else
			cuv += auv;
		}
d1465 12
a1476 12
	    else {
                if (len && (flags & UNPACK_ONLY_ONE))
                    len = 1;
		EXTEND(SP, len);
		EXTEND_MORTAL(len);
		while (len-- > 0) {
		    Copy(s, &auv, 1, UV);
		    s += UVSIZE;
		    sv = NEWSV(41, 0);
		    sv_setuv(sv, auv);
		    PUSHs(sv_2mortal(sv));
		}
a1478 3
	case 'l':
#if LONGSIZE == SIZE32
	    along = (strend - s) / SIZE32;
d1480 1
a1480 1
	    along = (strend - s) / (natint ? sizeof(long) : SIZE32);
d1482 14
a1495 14
	    if (len > along)
		len = along;
	    if (checksum) {
#if LONGSIZE != SIZE32
		if (natint) {
		    while (len-- > 0) {
			COPYNN(s, &along, sizeof(long));
			s += sizeof(long);
			if (checksum > bits_in_uv)
			    cdouble += (NV)along;
			else
			    cuv += along;
		    }
		}
d1497 1
a1497 18
#endif
                {
		    while (len-- > 0) {
#if LONGSIZE > SIZE32 && INTSIZE == SIZE32
			I32 along;
#endif
			COPY32(s, &along);
#if LONGSIZE > SIZE32
			if (along > 2147483647)
			  along -= 4294967296;
#endif
			s += SIZE32;
			if (checksum > bits_in_uv)
			    cdouble += (NV)along;
			else
			    cuv += along;
		    }
		}
d1499 2
a1500 5
	    else {
                if (len && (flags & UNPACK_ONLY_ONE))
                    len = 1;
		EXTEND(SP, len);
		EXTEND_MORTAL(len);
d1502 7
a1508 9
		if (natint) {
		    while (len-- > 0) {
			COPYNN(s, &along, sizeof(long));
			s += sizeof(long);
			sv = NEWSV(42, 0);
			sv_setiv(sv, (IV)along);
			PUSHs(sv_2mortal(sv));
		    }
		}
d1510 1
a1510 17
#endif
                {
		    while (len-- > 0) {
#if LONGSIZE > SIZE32 && INTSIZE == SIZE32
			I32 along;
#endif
			COPY32(s, &along);
#if LONGSIZE > SIZE32
			if (along > 2147483647)
			  along -= 4294967296;
#endif
			s += SIZE32;
			sv = NEWSV(42, 0);
			sv_setiv(sv, (IV)along);
			PUSHs(sv_2mortal(sv));
		    }
		}
d1513 3
d1519 14
a1532 21
#if LONGSIZE == SIZE32
	    along = (strend - s) / SIZE32;
#else
	    unatint = natint && datumtype == 'L';
	    along = (strend - s) / (unatint ? sizeof(unsigned long) : SIZE32);
#endif
	    if (len > along)
		len = along;
	    if (checksum) {
#if LONGSIZE != SIZE32
		if (unatint) {
		    unsigned long aulong;
		    while (len-- > 0) {
			COPYNN(s, &aulong, sizeof(unsigned long));
			s += sizeof(unsigned long);
			if (checksum > bits_in_uv)
			    cdouble += (NV)aulong;
			else
			    cuv += aulong;
		    }
		}
d1534 1
a1534 19
#endif
                {
		    while (len-- > 0) {
			COPY32(s, &aulong);
			s += SIZE32;
#ifdef HAS_NTOHL
			if (datumtype == 'N')
			    aulong = PerlSock_ntohl(aulong);
#endif
#ifdef HAS_VTOHL
			if (datumtype == 'V')
			    aulong = vtohl(aulong);
#endif
			if (checksum > bits_in_uv)
			    cdouble += (NV)aulong;
			else
			    cuv += aulong;
		    }
		}
d1536 19
a1554 16
	    else {
                if (len && (flags & UNPACK_ONLY_ONE))
                    len = 1;
		EXTEND(SP, len);
		EXTEND_MORTAL(len);
#if LONGSIZE != SIZE32
		if (unatint) {
		    unsigned long aulong;
		    while (len-- > 0) {
			COPYNN(s, &aulong, sizeof(unsigned long));
			s += sizeof(unsigned long);
			sv = NEWSV(43, 0);
			sv_setuv(sv, (UV)aulong);
			PUSHs(sv_2mortal(sv));
		    }
		}
d1556 1
a1556 18
#endif
                {
		    while (len-- > 0) {
			COPY32(s, &aulong);
			s += SIZE32;
#ifdef HAS_NTOHL
			if (datumtype == 'N')
			    aulong = PerlSock_ntohl(aulong);
#endif
#ifdef HAS_VTOHL
			if (datumtype == 'V')
			    aulong = vtohl(aulong);
#endif
			sv = NEWSV(43, 0);
			sv_setuv(sv, (UV)aulong);
			PUSHs(sv_2mortal(sv));
		    }
		}
a1559 5
	    along = (strend - s) / sizeof(char*);
	    if (len > along)
		len = along;
	    EXTEND(SP, len);
	    EXTEND_MORTAL(len);
d1561 4
a1564 10
		if (sizeof(char*) > strend - s)
		    break;
		else {
		    Copy(s, &aptr, 1, char*);
		    s += sizeof(char*);
		}
		sv = NEWSV(44, 0);
		if (aptr)
		    sv_setpv(sv, aptr);
		PUSHs(sv_2mortal(sv));
a1567 4
            if (len && (flags & UNPACK_ONLY_ONE))
                len = 1;
	    EXTEND(SP, len);
	    EXTEND_MORTAL(len);
d1571 8
a1578 5
		
		while ((len > 0) && (s < strend)) {
		    auv = (auv << 7) | (*s & 0x7f);
		    /* UTF8_IS_XXXXX not right here - using constant 0x80 */
		    if ((U8)(*s++) < 0x80) {
d1580 1
a1580 3
			sv = NEWSV(40, 0);
			sv_setuv(sv, auv);
			PUSHs(sv_2mortal(sv));
d1583 1
d1585 2
a1586 3
		    else if (++bytes >= sizeof(UV)) {	/* promote to string */
			char *t;
			STRLEN n_a;
d1588 1
a1588 1
			sv = Perl_newSVpvf(aTHX_ "%.*"UVf, (int)TYPE_DIGITS(UV), auv);
d1590 3
a1592 2
			    sv = mul128(sv, (U8)(*s & 0x7f));
			    if (!(*s++ & 0x80)) {
d1597 1
a1597 1
			t = SvPV(sv, n_a);
d1601 1
a1601 1
			PUSHs(sv_2mortal(sv));
d1607 1
a1607 1
		    Perl_croak(aTHX_ "Unterminated compressed integer");
d1611 2
a1612 2
	    if (star > 0)
	        Perl_croak(aTHX_ "P must have an explicit size");
d1614 5
a1618 5
	    if (sizeof(char*) > strend - s)
		break;
	    else {
		Copy(s, &aptr, 1, char*);
		s += sizeof(char*);
a1619 4
	    sv = NEWSV(44, 0);
	    if (aptr)
		sv_setpvn(sv, aptr, len);
	    PUSHs(sv_2mortal(sv));
d1621 1
a1621 1
#ifdef HAS_QUAD
d1623 9
a1631 12
	    along = (strend - s) / sizeof(Quad_t);
	    if (len > along)
		len = along;
	    if (checksum) {
		while (len-- > 0) {
		    Copy(s, &aquad, 1, Quad_t);
		    s += sizeof(Quad_t);
		    if (checksum > bits_in_uv)
			cdouble += (NV)aquad;
		    else
			cuv += aquad;
		}
a1632 20
            else {
                if (len && (flags & UNPACK_ONLY_ONE))
                    len = 1;
                EXTEND(SP, len);
                EXTEND_MORTAL(len);
                while (len-- > 0) {
                    if (s + sizeof(Quad_t) > strend)
                        aquad = 0;
                    else {
		        Copy(s, &aquad, 1, Quad_t);
		        s += sizeof(Quad_t);
                    }
                    sv = NEWSV(42, 0);
                    if (aquad >= IV_MIN && aquad <= IV_MAX)
		        sv_setiv(sv, (IV)aquad);
                    else
                        sv_setnv(sv, (NV)aquad);
                    PUSHs(sv_2mortal(sv));
                }
            }
d1635 9
a1643 12
	    along = (strend - s) / sizeof(Uquad_t);
	    if (len > along)
		len = along;
	    if (checksum) {
		while (len-- > 0) {
		    Copy(s, &auquad, 1, Uquad_t);
		    s += sizeof(Uquad_t);
		    if (checksum > bits_in_uv)
			cdouble += (NV)auquad;
		    else
			cuv += auquad;
		}
a1644 20
            else {
                if (len && (flags & UNPACK_ONLY_ONE))
                    len = 1;
                EXTEND(SP, len);
                EXTEND_MORTAL(len);
                while (len-- > 0) {
                    if (s + sizeof(Uquad_t) > strend)
                        auquad = 0;
                    else {
                        Copy(s, &auquad, 1, Uquad_t);
                        s += sizeof(Uquad_t);
                    }
                    sv = NEWSV(43, 0);
                    if (auquad <= UV_MAX)
                        sv_setuv(sv, (UV)auquad);
                    else
		    sv_setnv(sv, (NV)auquad);
                    PUSHs(sv_2mortal(sv));
                }
            }
d1649 6
a1654 7
	    along = (strend - s) / sizeof(float);
	    if (len > along)
		len = along;
	    if (checksum) {
		while (len-- > 0) {
		    Copy(s, &afloat, 1, float);
		    s += sizeof(float);
a1655 14
		}
	    }
	    else {
                if (len && (flags & UNPACK_ONLY_ONE))
                    len = 1;
		EXTEND(SP, len);
		EXTEND_MORTAL(len);
		while (len-- > 0) {
		    Copy(s, &afloat, 1, float);
		    s += sizeof(float);
		    sv = NEWSV(47, 0);
		    sv_setnv(sv, (NV)afloat);
		    PUSHs(sv_2mortal(sv));
		}
d1659 6
a1664 7
	    along = (strend - s) / sizeof(double);
	    if (len > along)
		len = along;
	    if (checksum) {
		while (len-- > 0) {
		    Copy(s, &adouble, 1, double);
		    s += sizeof(double);
a1665 14
		}
	    }
	    else {
                if (len && (flags & UNPACK_ONLY_ONE))
                    len = 1;
		EXTEND(SP, len);
		EXTEND_MORTAL(len);
		while (len-- > 0) {
		    Copy(s, &adouble, 1, double);
		    s += sizeof(double);
		    sv = NEWSV(48, 0);
		    sv_setnv(sv, (NV)adouble);
		    PUSHs(sv_2mortal(sv));
		}
d1669 8
a1676 22
	    along = (strend - s) / NVSIZE;
	    if (len > along)
		len = along;
	    if (checksum) {
		while (len-- > 0) {
		    Copy(s, &anv, 1, NV);
		    s += NVSIZE;
		    cdouble += anv;
		}
	    }
	    else {
                if (len && (flags & UNPACK_ONLY_ONE))
                    len = 1;
		EXTEND(SP, len);
		EXTEND_MORTAL(len);
		while (len-- > 0) {
		    Copy(s, &anv, 1, NV);
		    s += NVSIZE;
		    sv = NEWSV(48, 0);
		    sv_setnv(sv, anv);
		    PUSHs(sv_2mortal(sv));
		}
d1681 20
a1700 22
	    along = (strend - s) / LONG_DOUBLESIZE;
	    if (len > along)
		len = along;
	    if (checksum) {
		while (len-- > 0) {
		    Copy(s, &aldouble, 1, long double);
		    s += LONG_DOUBLESIZE;
		    cdouble += aldouble;
		}
	    }
	    else {
                if (len && (flags & UNPACK_ONLY_ONE))
                    len = 1;
		EXTEND(SP, len);
		EXTEND_MORTAL(len);
		while (len-- > 0) {
		    Copy(s, &aldouble, 1, long double);
		    s += LONG_DOUBLESIZE;
		    sv = NEWSV(48, 0);
		    sv_setnv(sv, (NV)aldouble);
		    PUSHs(sv_2mortal(sv));
		}
d1705 46
a1750 15
	    /* MKS:
	     * Initialise the decode mapping.  By using a table driven
             * algorithm, the code will be character-set independent
             * (and just as fast as doing character arithmetic)
             */
            if (PL_uudmap['M'] == 0) {
                int i;

                for (i = 0; i < sizeof(PL_uuemap); i += 1)
                    PL_uudmap[(U8)PL_uuemap[i]] = i;
                /*
                 * Because ' ' and '`' map to the same value,
                 * we need to decode them both the same.
                 */
                PL_uudmap[' '] = 0;
d1752 4
a1756 42
	    along = (strend - s) * 3 / 4;
	    sv = NEWSV(42, along);
	    if (along)
		SvPOK_on(sv);
	    while (s < strend && *s > ' ' && ISUUCHAR(*s)) {
		I32 a, b, c, d;
		char hunk[4];

		hunk[3] = '\0';
		len = PL_uudmap[*(U8*)s++] & 077;
		while (len > 0) {
		    if (s < strend && ISUUCHAR(*s))
			a = PL_uudmap[*(U8*)s++] & 077;
 		    else
 			a = 0;
		    if (s < strend && ISUUCHAR(*s))
			b = PL_uudmap[*(U8*)s++] & 077;
 		    else
 			b = 0;
		    if (s < strend && ISUUCHAR(*s))
			c = PL_uudmap[*(U8*)s++] & 077;
 		    else
 			c = 0;
		    if (s < strend && ISUUCHAR(*s))
			d = PL_uudmap[*(U8*)s++] & 077;
		    else
			d = 0;
		    hunk[0] = (char)((a << 2) | (b >> 4));
		    hunk[1] = (char)((b << 4) | (c >> 2));
		    hunk[2] = (char)((c << 6) | d);
		    sv_catpvn(sv, hunk, (len > 3) ? 3 : len);
		    len -= 3;
		}
		if (*s == '\n')
		    s++;
		else	/* possible checksum byte */
		    if (s + 1 < strend && s[1] == '\n')
		        s += 2;
	    }
	    XPUSHs(sv_2mortal(sv));
	    break;
	}
d1758 1
a1758 2
	    sv = NEWSV(42, 0);
	    if (strchr("fFdD", datumtype) ||
d1760 2
a1761 2
	       strchr("csSiIlLnNUvVqQjJ", datumtype)) ) {
		NV trouble;
d1763 1
a1763 1
                adouble = (NV) (1 << (checksum & 15));
d1766 1
a1766 1
		    adouble *= 65536.0;
d1769 14
a1782 3
		    cdouble += adouble;
		cdouble = Perl_modf(cdouble / adouble, &trouble) * adouble;
		sv_setnv(sv, cdouble);
a1786 1

d1789 1
a1789 1
		sv_setuv(sv, cuv);
d1791 1
a1791 1
	    XPUSHs(sv_2mortal(sv));
d1794 23
d1818 1
d1829 1
a1829 1
    I32 gimme = GIMME_V;
d1832 5
a1836 12
    register char *pat = SvPV(left, llen);
#ifdef PACKED_IS_OCTETS
    /* Packed side is assumed to be octets - so force downgrade if it
       has been UTF-8 encoded by accident
     */
    register char *s = SvPVbyte(right, rlen);
#else
    register char *s = SvPV(right, rlen);
#endif
    char *strend = s + rlen;
    register char *patend = pat + llen;
    register I32 cnt;
d1839 4
a1842 3
    cnt = unpack_str(pat, patend, s, s, strend, NULL, 0,
		     ((gimme == G_SCALAR) ? UNPACK_ONLY_ONE : 0)
		     | (DO_UTF8(right) ? UNPACK_DO_UTF8 : 0));
d1849 2
a1850 2
STATIC void
S_doencodes(pTHX_ register SV *sv, register char *s, register I32 len)
d1852 1
a1852 5
    char hunk[5];

    *hunk = PL_uuemap[len];
    sv_catpvn(sv, hunk, 1);
    hunk[4] = '\0';
d1854 4
a1857 5
	hunk[0] = PL_uuemap[(077 & (*s >> 2))];
	hunk[1] = PL_uuemap[(077 & (((*s << 4) & 060) | ((s[1] >> 4) & 017)))];
	hunk[2] = PL_uuemap[(077 & (((s[1] << 2) & 074) | ((s[2] >> 6) & 03)))];
	hunk[3] = PL_uuemap[(077 & (s[2] & 077))];
	sv_catpvn(sv, hunk, 4);
d1862 5
a1866 6
	char r = (len > 1 ? s[1] : '\0');
	hunk[0] = PL_uuemap[(077 & (*s >> 2))];
	hunk[1] = PL_uuemap[(077 & (((*s << 4) & 060) | ((r >> 4) & 017)))];
	hunk[2] = PL_uuemap[(077 & ((r << 2) & 074))];
	hunk[3] = PL_uuemap[0];
	sv_catpvn(sv, hunk, 4);
d1868 2
a1869 1
    sv_catpvn(sv, "\n", 1);
d1873 1
a1873 1
S_is_an_int(pTHX_ char *s, STRLEN l)
d1875 7
a1881 6
  STRLEN	 n_a;
  SV             *result = newSVpvn(s, l);
  char           *result_c = SvPV(result, n_a);	/* convenience */
  char           *out = result_c;
  bool            skip = 1;
  bool            ignore = 0;
d1926 16
a1941 15
  STRLEN          len;
  char           *s = SvPV(pnum, len);
  int             m = 0;
  int             r = 0;
  char           *t = s;

  *done = 1;
  while (*t) {
    int             i;

    i = m * 10 + (*t - '0');
    m = i & 0x7F;
    r = (i >> 7);		/* r < 10 */
    if (r) {
      *done = 0;
d1943 3
a1945 5
    *(t++) = '0' + r;
  }
  *(t++) = '\0';
  SvCUR_set(pnum, (STRLEN) (t - s));
  return (m);
a1947 2
#define PACK_CHILD	0x1

d1949 1
a1949 1
=for apidoc pack_cat
d1951 1
a1951 1
The engine implementing pack() Perl function.
d1953 2
a1954 1
=cut */
d1957 124
a2080 1
Perl_pack_cat(pTHX_ SV *cat, char *pat, register char *patend, register SV **beglist, SV **endlist, SV ***next_in_list, U32 flags)
d2082 65
a2146 58
    register I32 items;
    STRLEN fromlen;
    register I32 len;
    I32 datumtype;
    SV *fromstr;
    /*SUPPRESS 442*/
    static char null10[] = {0,0,0,0,0,0,0,0,0,0};
    static char *space10 = "          ";
    int star;

    /* These must not be in registers: */
    char achar;
    I16 ashort;
    int aint;
    unsigned int auint;
    I32 along;
    U32 aulong;
    IV aiv;
    UV auv;
    NV anv;
#if defined(HAS_LONG_DOUBLE) && defined(USE_LONG_DOUBLE)
    long double aldouble;
#endif
#ifdef HAS_QUAD
    Quad_t aquad;
    Uquad_t auquad;
#endif
    char *aptr;
    float afloat;
    double adouble;
    int commas = 0;
#ifdef PERL_NATINT_PACK
    int natint;		/* native integer */
#endif

    items = endlist - beglist;
#ifndef PACKED_IS_OCTETS
    pat = next_symbol(pat, patend);
    if (pat < patend && *pat == 'U' && !flags)
	SvUTF8_on(cat);
#endif
    while ((pat = next_symbol(pat, patend)) < patend) {
	SV *lengthcode = Nullsv;
#define NEXTFROM ( lengthcode ? lengthcode : items-- > 0 ? *beglist++ : &PL_sv_no)
	datumtype = *pat++ & 0xFF;
#ifdef PERL_NATINT_PACK
	natint = 0;
#endif
        if (*pat == '!') {
	    static const char natstr[] = "sSiIlLxX";

	    if (strchr(natstr, datumtype)) {
		if (datumtype == 'x' || datumtype == 'X') {
		    datumtype |= TYPE_IS_SHRIEKING;
		} else {		/* XXXX Should be redone similarly! */
#ifdef PERL_NATINT_PACK
		    natint = 1;
#endif
d2148 8
a2155 4
		pat++;
	    }
	    else
		Perl_croak(aTHX_ "'!' allowed only after types %s", natstr);
d2157 7
a2163 14
	len = find_count(&pat, patend, &star);
	if (star > 0)			/* Count is '*' */
	    len = strchr("@@Xxu", datumtype) ? 0 : items;
	else if (star < 0)		/* Default len */
	    len = 1;
	if (*pat == '/') {		/* doing lookahead how... */
	    ++pat;
	    if ((*pat != 'a' && *pat != 'A' && *pat != 'Z') || pat[1] != '*')
		Perl_croak(aTHX_ "/ must be followed by a*, A* or Z*");
	    lengthcode = sv_2mortal(newSViv(sv_len(items > 0
						   ? *beglist : &PL_sv_no)
                                            + (*pat == 'Z' ? 1 : 0)));
	}
	switch(datumtype) {
d2165 2
a2166 6
	    Perl_croak(aTHX_ "Invalid type in pack: '%c'", (int)datumtype);
	case ',': /* grandfather in commas but with a warning */
	    if (commas++ == 0 && ckWARN(WARN_PACK))
		Perl_warner(aTHX_ packWARN(WARN_PACK),
			    "Invalid type in pack: '%c'", (int)datumtype);
	    break;
d2168 16
a2183 1
	    Perl_croak(aTHX_ "%% may only be used in unpack");
d2185 30
a2214 5
	    len -= SvCUR(cat);
	    if (len > 0)
		goto grow;
	    len = -len;
	    if (len > 0)
d2216 1
a2217 4
	case '(':
	{
	    char *beg = pat;
	    SV **savebeglist = beglist;	/* beglist de-register-ed */
d2219 7
a2225 11
	    if (star >= 0)
		Perl_croak(aTHX_ "()-group starts with a count");
	    aptr = group_end(beg, patend, ')');
	    pat = aptr + 1;
	    if (star != -2) {
		len = find_count(&pat, patend, &star);
		if (star < 0)		/* No count */
		    len = 1;
		else if (star > 0)	/* Star */
		    len = items;	/* long enough? */
	    }
d2227 11
a2237 3
		pack_cat(cat, beg, aptr, savebeglist, endlist,
			 &savebeglist, PACK_CHILD);
		if (star > 0 && savebeglist == endlist)
d2240 3
a2242 2
	    beglist = savebeglist;
	    break;
d2247 18
a2264 2
	    len = (SvCUR(cat)) % len;
	    /* FALL THROUGH */
d2266 30
a2295 5
	  shrink:
	    if ((I32)SvCUR(cat) < len)
		Perl_croak(aTHX_ "X outside of string");
	    SvCUR(cat) -= len;
	    *SvEND(cat) = '\0';
d2297 2
a2298 1
	case 'x' | TYPE_IS_SHRIEKING:
d2301 6
a2306 6
	    aint = (SvCUR(cat)) % len;
	    if (aint)			/* Other portable ways? */
		len = len - aint;
	    else
		len = 0;
	    /* FALL THROUGH */
d2308 1
a2308 7
	  grow:
	    while (len >= 10) {
		sv_catpvn(cat, null10, 10);
		len -= 10;
	    }
	    sv_catpvn(cat, null10, len);
	    break;
d2311 3
a2313 1
	case 'a':
d2315 46
a2360 13
	    aptr = SvPV(fromstr, fromlen);
	    if (star > 0) { /* -2 after '/' */  
		len = fromlen;
		if (datumtype == 'Z')
		    ++len;
	    }
	    if ((I32)fromlen >= len) {
		sv_catpvn(cat, aptr, len);
		if (datumtype == 'Z')
		    *(SvEND(cat)-1) = '\0';
	    }
	    else {
		sv_catpvn(cat, aptr, fromlen);
d2362 4
a2365 6
		if (datumtype == 'A') {
		    while (len >= 10) {
			sv_catpvn(cat, space10, 10);
			len -= 10;
		    }
		    sv_catpvn(cat, space10, len);
d2367 19
a2385 6
		else {
		    while (len >= 10) {
			sv_catpvn(cat, null10, 10);
			len -= 10;
		    }
		    sv_catpvn(cat, null10, len);
d2387 8
d2396 3
d2400 1
d2402 6
a2407 4
	case 'b':
	    {
		register char *str;
		I32 saveitems;
d2409 27
a2435 22
		fromstr = NEXTFROM;
		saveitems = items;
		str = SvPV(fromstr, fromlen);
		if (star > 0)
		    len = fromlen;
		aint = SvCUR(cat);
		SvCUR(cat) += (len+7)/8;
		SvGROW(cat, SvCUR(cat) + 1);
		aptr = SvPVX(cat) + aint;
		if (len > (I32)fromlen)
		    len = fromlen;
		aint = len;
		items = 0;
		if (datumtype == 'B') {
		    for (len = 0; len++ < aint;) {
			items |= *str++ & 1;
			if (len & 7)
			    items <<= 1;
			else {
			    *aptr++ = items & 0xff;
			    items = 0;
			}
d2438 13
a2450 10
		else {
		    for (len = 0; len++ < aint;) {
			if (*str++ & 1)
			    items |= 128;
			if (len & 7)
			    items >>= 1;
			else {
			    *aptr++ = items & 0xff;
			    items = 0;
			}
d2453 15
a2467 13
		if (aint & 7) {
		    if (datumtype == 'B')
			items <<= 7 - (aint & 7);
		    else
			items >>= 7 - (aint & 7);
		    *aptr++ = items & 0xff;
		}
		str = SvPVX(cat) + SvCUR(cat);
		while (aptr <= str)
		    *aptr++ = '\0';

		items = saveitems;
	    }
d2469 1
d2471 6
a2476 4
	case 'h':
	    {
		register char *str;
		I32 saveitems;
d2478 23
a2500 17
		fromstr = NEXTFROM;
		saveitems = items;
		str = SvPV(fromstr, fromlen);
		if (star > 0)
		    len = fromlen;
		aint = SvCUR(cat);
		SvCUR(cat) += (len+1)/2;
		SvGROW(cat, SvCUR(cat) + 1);
		aptr = SvPVX(cat) + aint;
		if (len > (I32)fromlen)
		    len = fromlen;
		aint = len;
		items = 0;
		if (datumtype == 'H') {
		    for (len = 0; len++ < aint;) {
			if (isALPHA(*str))
			    items |= ((*str++ & 15) + 9) & 15;
d2502 9
a2510 7
			    items |= *str++ & 15;
			if (len & 1)
			    items <<= 4;
			else {
			    *aptr++ = items & 0xff;
			    items = 0;
			}
d2513 7
a2519 4
		else {
		    for (len = 0; len++ < aint;) {
			if (isALPHA(*str))
			    items |= (((*str++ & 15) + 9) & 15) << 4;
d2521 9
a2529 7
			    items |= (*str++ & 15) << 4;
			if (len & 1)
			    items >>= 4;
			else {
			    *aptr++ = items & 0xff;
			    items = 0;
			}
d2532 22
a2553 7
		if (aint & 1)
		    *aptr++ = items & 0xff;
		str = SvPVX(cat) + SvCUR(cat);
		while (aptr <= str)
		    *aptr++ = '\0';

		items = saveitems;
d2557 20
a2576 1
	case 'c':
d2578 1
d2580 40
a2619 19
		switch (datumtype) {
		case 'C':
		    aint = SvIV(fromstr);
		    if ((aint < 0 || aint > 255) &&
			ckWARN(WARN_PACK))
		        Perl_warner(aTHX_ packWARN(WARN_PACK),
				    "Character in \"C\" format wrapped");
		    achar = aint & 255;
		    sv_catpvn(cat, &achar, sizeof(char));
		    break;
		case 'c':
		    aint = SvIV(fromstr);
		    if ((aint < -128 || aint > 127) &&
			ckWARN(WARN_PACK))
		        Perl_warner(aTHX_ packWARN(WARN_PACK),
				    "Character in \"c\" format wrapped");
		    achar = aint & 255;
		    sv_catpvn(cat, &achar, sizeof(char));
		    break;
d2623 16
a2638 1
	case 'U':
d2640 1
d2642 25
a2666 8
		auint = UNI_TO_NATIVE(SvUV(fromstr));
		SvGROW(cat, SvCUR(cat) + UTF8_MAXLEN + 1);
		SvCUR_set(cat,
			  (char*)uvchr_to_utf8_flags((U8*)SvEND(cat),
						     auint,
						     ckWARN(WARN_UTF8) ?
						     0 : UNICODE_ALLOW_ANY)
			  - SvPVX(cat));
a2667 1
	    *SvEND(cat) = '\0';
d2669 1
d2673 2
d2676 10
a2685 22
#ifdef __VOS__
/* VOS does not automatically map a floating-point overflow
   during conversion from double to float into infinity, so we
   do it by hand.  This code should either be generalized for
   any OS that needs it, or removed if and when VOS implements
   posix-976 (suggestion to support mapping to infinity).
   Paul.Green@@stratus.com 02-04-02.  */
		if (SvNV(fromstr) > FLT_MAX)
		     afloat = _float_constants[0];   /* single prec. inf. */
		else if (SvNV(fromstr) < -FLT_MAX)
		     afloat = _float_constants[0];   /* single prec. inf. */
		else afloat = (float)SvNV(fromstr);
#else
# if defined(VMS) && !defined(__IEEE_FP)
/* IEEE fp overflow shenanigans are unavailable on VAX and optional
 * on Alpha; fake it if we don't have them.
 */
		if (SvNV(fromstr) > FLT_MAX)
		     afloat = FLT_MAX;
		else if (SvNV(fromstr) < -FLT_MAX)
		     afloat = -FLT_MAX;
		else afloat = (float)SvNV(fromstr);
d2687 9
a2695 1
		afloat = (float)SvNV(fromstr);
d2697 1
a2697 2
#endif
		sv_catpvn(cat, (char *)&afloat, sizeof (float));
d2702 2
d2705 10
a2714 22
#ifdef __VOS__
/* VOS does not automatically map a floating-point overflow
   during conversion from long double to double into infinity,
   so we do it by hand.  This code should either be generalized
   for any OS that needs it, or removed if and when VOS
   implements posix-976 (suggestion to support mapping to
   infinity).  Paul.Green@@stratus.com 02-04-02.  */
		if (SvNV(fromstr) > DBL_MAX)
		     adouble = _double_constants[0];   /* double prec. inf. */
		else if (SvNV(fromstr) < -DBL_MAX)
		     adouble = _double_constants[0];   /* double prec. inf. */
		else adouble = (double)SvNV(fromstr);
#else
# if defined(VMS) && !defined(__IEEE_FP)
/* IEEE fp overflow shenanigans are unavailable on VAX and optional
 * on Alpha; fake it if we don't have them.
 */
		if (SvNV(fromstr) > DBL_MAX)
		     adouble = DBL_MAX;
		else if (SvNV(fromstr) < -DBL_MAX)
		     adouble = -DBL_MAX;
		else adouble = (double)SvNV(fromstr);
d2716 1
a2716 1
		adouble = (double)SvNV(fromstr);
d2718 1
a2718 2
#endif
		sv_catpvn(cat, (char *)&adouble, sizeof (double));
d2721 3
a2723 1
	case 'F':
d2726 13
a2738 2
		anv = SvNV(fromstr);
		sv_catpvn(cat, (char *)&anv, NVSIZE);
d2741 1
d2743 4
a2746 1
	case 'D':
d2749 13
a2761 2
		aldouble = (long double)SvNV(fromstr);
		sv_catpvn(cat, (char *)&aldouble, LONG_DOUBLESIZE);
d2764 1
d2766 1
d2769 1
d2771 3
a2773 5
		ashort = (I16)SvIV(fromstr);
#ifdef HAS_HTONS
		ashort = PerlSock_htons(ashort);
#endif
		CAT16(cat, &ashort);
d2776 1
d2779 1
d2781 3
a2783 5
		ashort = (I16)SvIV(fromstr);
#ifdef HAS_HTOVS
		ashort = htovs(ashort);
#endif
		CAT16(cat, &ashort);
d2786 1
a2786 1
	case 'S':
d2788 1
a2788 1
	    if (natint) {
d2790 3
a2792 6

		while (len-- > 0) {
		    fromstr = NEXTFROM;
		    aushort = SvUV(fromstr);
		    sv_catpvn(cat, (char *)&aushort, sizeof(unsigned short));
		}
d2794 3
a2796 1
	    else
d2798 6
a2803 9
            {
		U16 aushort;

		while (len-- > 0) {
		    fromstr = NEXTFROM;
		    aushort = (U16)SvUV(fromstr);
		    CAT16(cat, &aushort);
		}

d2806 1
a2806 1
	case 's':
d2808 1
a2808 1
	    if (natint) {
d2810 3
a2812 6

		while (len-- > 0) {
		    fromstr = NEXTFROM;
		    ashort = SvIV(fromstr);
		    sv_catpvn(cat, (char *)&ashort, sizeof(short));
		}
d2814 3
a2816 1
	    else
d2818 6
a2823 6
            {
		while (len-- > 0) {
		    fromstr = NEXTFROM;
		    ashort = (I16)SvIV(fromstr);
		    CAT16(cat, &ashort);
		}
d2827 1
d2829 1
d2831 2
a2832 2
		auint = SvUV(fromstr);
		sv_catpvn(cat, (char*)&auint, sizeof(unsigned int));
d2837 1
d2839 2
a2840 2
		aiv = SvIV(fromstr);
		sv_catpvn(cat, (char*)&aiv, IVSIZE);
d2845 1
d2847 2
a2848 2
		auv = SvUV(fromstr);
		sv_catpvn(cat, (char*)&auv, UVSIZE);
d2853 1
d2855 2
a2856 1
		anv = SvNV(fromstr);
d2858 5
a2862 2
		if (anv < 0)
		    Perl_croak(aTHX_ "Cannot compress negative numbers");
d2869 2
a2870 3
		if (SvIOK(fromstr) || anv < UV_MAX_P1)
		{
		    char   buf[(sizeof(UV)*8)/7+1];
d2872 1
a2872 1
		    UV     auv = SvUV(fromstr);
d2879 4
a2882 23
		    sv_catpvn(cat, in, (buf + sizeof(buf)) - in);
		}
		else if (SvPOKp(fromstr)) {  /* decimal string arithmetics */
		    char           *from, *result, *in;
		    SV             *norm;
		    STRLEN          len;
		    bool            done;

		    /* Copy string and check for compliance */
		    from = SvPV(fromstr, len);
		    if ((norm = is_an_int(from, len)) == NULL)
			Perl_croak(aTHX_ "can compress only unsigned integer");

		    New('w', result, len, char);
		    in = result + len;
		    done = FALSE;
		    while (!done)
			*--in = div128(norm, &done) | 0x80;
		    result[len - 1] &= 0x7F; /* clear continue bit */
		    sv_catpvn(cat, in, (result + len) - in);
		    Safefree(result);
		    SvREFCNT_dec(norm);	/* free norm */
                }
d2884 17
a2900 1
		    char   buf[sizeof(NV) * 2];	/* 8/7 <= 2 */
d2903 1
a2903 1
                    anv = Perl_floor(anv);
d2905 3
a2907 1
			NV next = Perl_floor(anv / 128);
a2908 2
			if (in <= buf)  /* this cannot happen ;-) */
			    Perl_croak(aTHX_ "Cannot compress integer");
d2912 5
a2916 4
		    sv_catpvn(cat, in, (buf + sizeof(buf)) - in);
		}
		else {
		    char           *from, *result, *in;
d2921 1
d2923 1
a2923 1
		    from = SvPV(fromstr, len);
d2925 1
a2925 1
			Perl_croak(aTHX_ "can compress only unsigned integer");
d2927 1
a2927 1
		    New('w', result, len, char);
d2930 1
a2930 2
		    while (!done)
			*--in = div128(norm, &done) | 0x80;
d2932 2
a2933 1
		    sv_catpvn(cat, in, (result + len) - in);
d2936 1
a2936 1
               }
d2940 1
d2942 1
d2944 2
a2945 2
		aint = SvIV(fromstr);
		sv_catpvn(cat, (char*)&aint, sizeof(int));
d2948 1
d2951 1
d2953 3
a2955 5
		aulong = SvUV(fromstr);
#ifdef HAS_HTONL
		aulong = PerlSock_htonl(aulong);
#endif
		CAT32(cat, &aulong);
d2958 1
d2961 1
d2963 3
a2965 5
		aulong = SvUV(fromstr);
#ifdef HAS_HTOVL
		aulong = htovl(aulong);
#endif
		CAT32(cat, &aulong);
d2968 1
a2968 1
	case 'L':
d2970 1
a2970 1
	    if (natint) {
d2972 3
a2974 6

		while (len-- > 0) {
		    fromstr = NEXTFROM;
		    aulong = SvUV(fromstr);
		    sv_catpvn(cat, (char *)&aulong, sizeof(unsigned long));
		}
d2976 3
a2978 1
	    else
d2980 6
a2985 6
            {
		while (len-- > 0) {
		    fromstr = NEXTFROM;
		    aulong = SvUV(fromstr);
		    CAT32(cat, &aulong);
		}
d2988 1
a2988 1
	case 'l':
d2990 1
a2990 1
	    if (natint) {
d2992 3
a2994 6

		while (len-- > 0) {
		    fromstr = NEXTFROM;
		    along = SvIV(fromstr);
		    sv_catpvn(cat, (char *)&along, sizeof(long));
		}
d2996 3
a2998 1
	    else
d3000 6
a3005 6
            {
		while (len-- > 0) {
		    fromstr = NEXTFROM;
		    along = SvIV(fromstr);
		    CAT32(cat, &along);
		}
d3008 1
a3008 1
#ifdef HAS_QUAD
d3011 1
d3013 2
a3014 2
		auquad = (Uquad_t)SvUV(fromstr);
		sv_catpvn(cat, (char*)&auquad, sizeof(Uquad_t));
d3019 1
d3021 2
a3022 2
		aquad = (Quad_t)SvIV(fromstr);
		sv_catpvn(cat, (char*)&aquad, sizeof(Quad_t));
d3028 2
a3029 1
	    /* FALL THROUGH */
d3032 2
d3035 2
a3036 2
		if (fromstr == &PL_sv_undef)
		    aptr = NULL;
a3037 1
		    STRLEN n_a;
d3043 4
a3046 6
		    if (ckWARN(WARN_PACK) && (SvTEMP(fromstr)
						|| (SvPADTMP(fromstr)
						    && !SvREADONLY(fromstr))))
		    {
			Perl_warner(aTHX_ packWARN(WARN_PACK),
				"Attempt to pack pointer to temporary value");
d3049 1
a3049 1
			aptr = SvPV(fromstr,n_a);
d3051 1
a3051 1
			aptr = SvPV_force(fromstr,n_a);
d3053 1
a3053 1
		sv_catpvn(cat, (char*)&aptr, sizeof(char*));
d3056 4
a3059 1
	case 'u':
d3061 14
a3074 6
	    aptr = SvPV(fromstr, fromlen);
	    SvGROW(cat, fromlen * 4 / 3);
	    if (len <= 2)
		len = 45;
	    else
		len = len / 3 * 3;
d3076 1
d3078 1
d3084 16
a3099 1
		doencodes(cat, aptr, todo);
a3100 1
		aptr += todo;
d3104 5
d3110 1
a3110 2
    if (next_in_list)
	*next_in_list = beglist;
d3118 1
a3118 1
    register SV *cat = TARG;
d3120 3
a3122 2
    register char *pat = SvPVx(*++MARK, fromlen);
    register char *patend = pat + fromlen;
d3125 2
a3126 1
    sv_setpvn(cat, "", 0);
d3128 1
a3128 1
    pack_cat(cat, pat, patend, MARK, SP + 1, NULL, 0);
d3136 3
@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, by Larry Wall and others
a85 10
/* Avoid stack overflow due to pathological templates. 100 should be plenty. */
#define MAX_SUB_TEMPLATE_LEVEL 100

/* flags */
#define FLAG_UNPACK_ONLY_ONE  0x10
#define FLAG_UNPACK_DO_UTF8   0x08
#define FLAG_SLASH            0x04
#define FLAG_COMMA            0x02
#define FLAG_PACK             0x01

d126 26
d156 1
a156 1
S_measure_struct(pTHX_ register tempsym_t* symptr)
d158 2
a159 1
    register I32 len = 0;
d161 7
a167 2
    int star;

d170 26
a195 1
    while (next_symbol(symptr)) {
d197 1
a197 12
        switch( symptr->howlen ){
        case e_no_len:
	case e_number:
	    len = symptr->length;
	    break;
        case e_star:
   	    Perl_croak(aTHX_ "Within []-length '*' not allowed in %s",
                       symptr->flags & FLAG_PACK ? "pack" : "unpack" );
            break;
        }

	switch(symptr->code) {
d199 1
a199 3
    Perl_croak(aTHX_ "Invalid type '%c' in %s",
                       (int)symptr->code,
                       symptr->flags & FLAG_PACK ? "pack" : "unpack" );
d205 8
a212 3
	    Perl_croak(aTHX_ "Within []-length '%c' not allowed in %s",
                       (int)symptr->code,
                       symptr->flags & FLAG_PACK ? "pack" : "unpack" );
d218 11
a228 3
            tempsym_t savsym = *symptr;
  	    symptr->patptr = savsym.grpbeg;
            symptr->patend = savsym.grpend;
d233 1
a233 2
	    size = measure_struct(symptr);
            *symptr = savsym;
d245 1
a245 2
		Perl_croak(aTHX_ "'X' outside of string in %s",
                          symptr->flags & FLAG_PACK ? "pack" : "unpack" );
a273 7
	case 's' | TYPE_IS_SHRIEKING:
#if SHORTSIZE != SIZE16
	    size = sizeof(short);
	    break;
#else
            /* FALL THROUGH */
#endif
d275 1
a276 5
	    break;
	case 'S' | TYPE_IS_SHRIEKING:
#if SHORTSIZE != SIZE16
	    size = sizeof(unsigned short);
	    break;
d278 1
a278 1
            /* FALL THROUGH */
d280 1
d284 1
d286 4
a290 1
	case 'i' | TYPE_IS_SHRIEKING:
a293 1
	case 'I' | TYPE_IS_SHRIEKING:
a302 7
	case 'l' | TYPE_IS_SHRIEKING:
#if LONGSIZE != SIZE32
	    size = sizeof(long);
            break;
#else
            /* FALL THROUGH */
#endif
d304 1
a305 5
	    break;
	case 'L' | TYPE_IS_SHRIEKING:
#if LONGSIZE != SIZE32
	    size = sizeof(unsigned long);
	    break;
d307 1
a307 1
            /* FALL THROUGH */
d309 1
d313 1
d315 4
d354 6
d361 18
a378 8
/* locate matching closing parenthesis or bracket
 * returns char pointer to char after match, or NULL
 */
STATIC char *
S_group_end(pTHX_ register char *patptr, register char *patend, char ender)
{
    while (patptr < patend) {
	char c = *patptr++;
d380 5
a384 12
	if (isSPACE(c))
	    continue;
	else if (c == ender)
	    return patptr-1;
	else if (c == '#') {
	    while (patptr < patend && *patptr != '\n')
		patptr++;
	    continue;
	} else if (c == '(')
	    patptr = group_end(patptr, patend, ')') + 1;
	else if (c == '[')
	    patptr = group_end(patptr, patend, ']') + 1;
d386 4
a389 3
    Perl_croak(aTHX_ "No group ending character '%c' found in template",
               ender);
    return 0;
a391 5

/* Convert unsigned decimal number to binary.
 * Expects a pointer to the first digit and address of length variable
 * Advances char pointer to 1st non-digit char and returns number
 */ 
d393 1
a393 17
S_get_num(pTHX_ register char *patptr, I32 *lenptr )
{
  I32 len = *patptr++ - '0';
  while (isDIGIT(*patptr)) {
    if (len >= 0x7FFFFFFF/10)
      Perl_croak(aTHX_ "pack/unpack repeat count overflow");
    len = (len * 10) + (*patptr++ - '0');
  }
  *lenptr = len;
  return patptr;
}

/* The marvellous template parsing routine: Using state stored in *symptr,
 * locates next template code and count
 */
STATIC bool
S_next_symbol(pTHX_ register tempsym_t* symptr )
d395 9
a403 104
  register char* patptr = symptr->patptr; 
  register char* patend = symptr->patend; 

  symptr->flags &= ~FLAG_SLASH;

  while (patptr < patend) {
    if (isSPACE(*patptr))
      patptr++;
    else if (*patptr == '#') {
      patptr++;
      while (patptr < patend && *patptr != '\n')
	patptr++;
      if (patptr < patend)
	patptr++;
    } else {
      /* We should have found a template code */ 
      I32 code = *patptr++ & 0xFF;

      if (code == ','){ /* grandfather in commas but with a warning */
	if (((symptr->flags & FLAG_COMMA) == 0) && ckWARN(WARN_UNPACK)){
          symptr->flags |= FLAG_COMMA;
	  Perl_warner(aTHX_ packWARN(WARN_UNPACK),
	 	      "Invalid type ',' in %s",
                      symptr->flags & FLAG_PACK ? "pack" : "unpack" );
        }
	continue;
      }
      
      /* for '(', skip to ')' */
      if (code == '(') {  
        if( isDIGIT(*patptr) || *patptr == '*' || *patptr == '[' )
          Perl_croak(aTHX_ "()-group starts with a count in %s",
                     symptr->flags & FLAG_PACK ? "pack" : "unpack" );
        symptr->grpbeg = patptr;
        patptr = 1 + ( symptr->grpend = group_end(patptr, patend, ')') );
        if( symptr->level >= MAX_SUB_TEMPLATE_LEVEL )
	  Perl_croak(aTHX_ "Too deeply nested ()-groups in %s",
                     symptr->flags & FLAG_PACK ? "pack" : "unpack" );
      }

      /* test for '!' modifier */
      if (patptr < patend && *patptr == '!') {
	static const char natstr[] = "sSiIlLxX";
        patptr++;	        
        if (strchr(natstr, code))
 	  code |= TYPE_IS_SHRIEKING;
        else
   	  Perl_croak(aTHX_ "'!' allowed only after types %s in %s",
                     natstr, symptr->flags & FLAG_PACK ? "pack" : "unpack" );
      }

      /* look for count and/or / */ 
      if (patptr < patend) {
	if (isDIGIT(*patptr)) {
 	  patptr = get_num( patptr, &symptr->length );
          symptr->howlen = e_number;

        } else if (*patptr == '*') {
          patptr++;
          symptr->howlen = e_star;

        } else if (*patptr == '[') {
          char* lenptr = ++patptr;            
          symptr->howlen = e_number;
          patptr = group_end( patptr, patend, ']' ) + 1;
          /* what kind of [] is it? */
          if (isDIGIT(*lenptr)) {
            lenptr = get_num( lenptr, &symptr->length );
            if( *lenptr != ']' )
              Perl_croak(aTHX_ "Malformed integer in [] in %s",
                         symptr->flags & FLAG_PACK ? "pack" : "unpack");
          } else {
            tempsym_t savsym = *symptr;
            symptr->patend = patptr-1;
            symptr->patptr = lenptr;
            savsym.length = measure_struct(symptr);
            *symptr = savsym;
          }
        } else {
          symptr->howlen = e_no_len;
          symptr->length = 1;
        }

        /* try to find / */
        while (patptr < patend) {
          if (isSPACE(*patptr))
            patptr++;
          else if (*patptr == '#') {
            patptr++;
            while (patptr < patend && *patptr != '\n')
	      patptr++;
            if (patptr < patend)
	      patptr++;
          } else {
            if( *patptr == '/' ){ 
              symptr->flags |= FLAG_SLASH;
              patptr++;
              if( patptr < patend &&
                  (isDIGIT(*patptr) || *patptr == '*' || *patptr == '[') )
                Perl_croak(aTHX_ "'/' does not take a repeat count in %s",
                           symptr->flags & FLAG_PACK ? "pack" : "unpack" );
            }
            break;
	  }
d405 2
a406 9
      } else {
        /* at end - no count, no / */
        symptr->howlen = e_no_len;
        symptr->length = 1;
      }

      symptr->code = code;
      symptr->patptr = patptr; 
      return TRUE;
d408 1
a408 3
  }
  symptr->patptr = patptr; 
  return FALSE;
d414 1
a414 2
The engine implementing unpack() Perl function. Note: parameters strbeg, new_s
and ocnt are not used. This call should not be used, use unpackstring instead.
a420 32
    tempsym_t sym = { 0 };
    sym.patptr = pat;
    sym.patend = patend;
    sym.flags  = flags;

    return unpack_rec(&sym, s, s, strend, NULL );
}

/*
=for apidoc unpackstring

The engine implementing unpack() Perl function. C<unpackstring> puts the
extracted list items on the stack and returns the number of elements.
Issue C<PUTBACK> before and C<SPAGAIN> after the call to this function.

=cut */

I32
Perl_unpackstring(pTHX_ char *pat, register char *patend, register char *s, char *strend, U32 flags)
{
    tempsym_t sym = { 0 };
    sym.patptr = pat;
    sym.patend = patend;
    sym.flags  = flags;

    return unpack_rec(&sym, s, s, strend, NULL );
}

STATIC
I32
S_unpack_rec(pTHX_ register tempsym_t* symptr, register char *s, char *strbeg, char *strend, char **new_s )
{
d423 1
a423 1
    register I32 len = 0;
a427 1
    howlen_t howlen;
d449 6
a454 4
    char* strrelbeg = s;
    bool beyond = FALSE;
    bool unpack_only_one = (symptr->flags & FLAG_UNPACK_ONLY_ONE) != 0;

d461 1
d463 5
a467 2
    while (next_symbol(symptr)) {
        datumtype = symptr->code;
d471 1
a471 1
        if ( unpack_only_one
d473 1
a473 1
	     && (datumtype != '/') )   /* XXX can this be omitted */
d475 2
d478 18
a495 9
        switch( howlen = symptr->howlen ){
        case e_no_len:
	case e_number:
	    len = symptr->length;
	    break;
        case e_star:
	    len = strend - strbeg;	/* long enough */          
	    break;
        }
a497 1
        beyond = s >= strend;
d500 6
a505 2
	    Perl_croak(aTHX_ "Invalid type '%c' in unpack", (int)datumtype );

d507 1
a507 1
	    if (howlen == e_no_len)
d516 1
d518 12
a529 3
            tempsym_t savsym = *symptr;
            symptr->patend = savsym.grpend;
            symptr->level++;
d532 4
a535 4
  	        symptr->patptr = savsym.grpbeg;
 	        unpack_rec(symptr, ss, strbeg, strend, &ss );
                if (ss == strend && savsym.howlen == e_star)
		    break; /* No way to continue */
a538 2
            savsym.flags = symptr->flags;
            *symptr = savsym;
d542 3
a544 3
	    if (len > strend - strrelbeg)
		Perl_croak(aTHX_ "'@@' outside of string in unpack");
	    s = strrelbeg + len;
d553 1
a553 1
		Perl_croak(aTHX_ "'X' outside of string in unpack" );
d567 1
a567 1
		Perl_croak(aTHX_ "'x' outside of string in unpack");
d571 10
a580 2
	    Perl_croak(aTHX_ "'/' must follow a numeric type in unpack");
            break;
d590 1
a590 1
	    if (len > 0 && (datumtype == 'A' || datumtype == 'Z')) {
d596 1
a596 1
		    if (howlen == e_star) /* exact for 'Z*' */
d613 1
a613 1
	    if (howlen == e_star || len > (strend - s) * 8)
d679 1
a679 1
	    if (howlen == e_star || len > (strend - s) * 2)
d723 1
a723 1
                if (len && unpack_only_one)
d740 1
a740 1
                symptr->flags &= ~FLAG_UNPACK_DO_UTF8;
d753 1
a753 1
                if (len && unpack_only_one)
d767 1
a767 1
                symptr->flags |= FLAG_UNPACK_DO_UTF8;
d770 1
a770 1
	    if ((symptr->flags & FLAG_UNPACK_DO_UTF8) == 0)
d787 1
a787 1
                if (len && unpack_only_one)
d802 6
a807 3
	case 's' | TYPE_IS_SHRIEKING:
#if SHORTSIZE != SIZE16
	    along = (strend - s) / sizeof(short);
d811 10
a820 8
		short ashort;
		while (len-- > 0) {
		     COPYNN(s, &ashort, sizeof(short));
		      s += sizeof(short);
		      if (checksum > bits_in_uv)
			  cdouble += (NV)ashort;
		      else
			  cuv += ashort;
d822 1
d824 1
a824 18
	    }
	    else {
		short ashort;
                if (len && unpack_only_one)
                    len = 1;
		EXTEND(SP, len);
		EXTEND_MORTAL(len);
		while (len-- > 0) {
		    COPYNN(s, &ashort, sizeof(short));
		    s += sizeof(short);
		    sv = NEWSV(38, 0);
		    sv_setiv(sv, (IV)ashort);
		    PUSHs(sv_2mortal(sv));
		}
	    }
	    break;
#else
	    /* Fallthrough! */
d826 3
a828 7
	case 's':
	    along = (strend - s) / SIZE16;
	    if (len > along)
		len = along;
	    if (checksum) {
      		while (len-- > 0) {
		    COPY16(s, &ashort);
d830 2
a831 2
		    if (ashort > 32767)
			ashort -= 65536;
d833 6
a838 5
		    s += SIZE16;
		    if (checksum > bits_in_uv)
			cdouble += (NV)ashort;
		    else
			cuv += ashort;
d842 1
a842 1
                if (len && unpack_only_one)
d846 16
a861 3

		while (len-- > 0) {
		    COPY16(s, &ashort);
d863 2
a864 2
		    if (ashort > 32767)
			ashort -= 65536;
d866 5
a870 35
		    s += SIZE16;
		    sv = NEWSV(38, 0);
		    sv_setiv(sv, (IV)ashort);
		    PUSHs(sv_2mortal(sv));
		}
	    }
	    break;
	case 'S' | TYPE_IS_SHRIEKING:
#if SHORTSIZE != SIZE16
	    along = (strend - s) / sizeof(unsigned short);
	    if (len > along)
		len = along;
	    if (checksum) {
		unsigned short aushort;
		while (len-- > 0) {
		    COPYNN(s, &aushort, sizeof(unsigned short));
		    s += sizeof(unsigned short);
		    if (checksum > bits_in_uv)
			cdouble += (NV)aushort;
		    else
			cuv += aushort;
		}
	    }
	    else {
                if (len && unpack_only_one)
                    len = 1;
		EXTEND(SP, len);
		EXTEND_MORTAL(len);
		while (len-- > 0) {
  		    unsigned short aushort;
		    COPYNN(s, &aushort, sizeof(unsigned short));
		    s += sizeof(unsigned short);
		    sv = NEWSV(39, 0);
		    sv_setiv(sv, (UV)aushort);
		    PUSHs(sv_2mortal(sv));
a873 3
#else
            /* Fallhrough! */
#endif
d877 1
d879 4
d886 18
a903 3
		while (len-- > 0) {
		    COPY16(s, &aushort);
		    s += SIZE16;
d905 2
a906 2
		    if (datumtype == 'n')
		        aushort = PerlSock_ntohs(aushort);
d909 2
a910 2
		    if (datumtype == 'v')
			aushort = vtohs(aushort);
d912 5
a916 4
		    if (checksum > bits_in_uv)
			cdouble += (NV)aushort;
		    else
		        cuv += aushort;
d920 1
a920 1
                if (len && unpack_only_one)
d924 18
a941 4
		while (len-- > 0) {
		    COPY16(s, &aushort);
		    s += SIZE16;
		    sv = NEWSV(39, 0);
d943 2
a944 2
		    if (datumtype == 'n')
			aushort = PerlSock_ntohs(aushort);
d947 2
a948 2
		    if (datumtype == 'v')
			aushort = vtohs(aushort);
d950 3
a952 2
		    sv_setiv(sv, (UV)aushort);
		    PUSHs(sv_2mortal(sv));
a956 1
	case 'i' | TYPE_IS_SHRIEKING:
d971 1
a971 1
                if (len && unpack_only_one)
a1009 1
	case 'I' | TYPE_IS_SHRIEKING:
d1024 1
a1024 1
                if (len && unpack_only_one)
d1059 1
a1059 1
                if (len && unpack_only_one)
d1087 1
a1087 1
                if (len && unpack_only_one)
d1100 6
a1105 3
	case 'l' | TYPE_IS_SHRIEKING:
#if LONGSIZE != SIZE32
	    along = (strend - s) / sizeof(long);
d1109 10
a1118 7
		while (len-- > 0) {
		    COPYNN(s, &along, sizeof(long));
		    s += sizeof(long);
		    if (checksum > bits_in_uv)
			cdouble += (NV)along;
		    else
			cuv += along;
d1120 1
a1120 17
	    }
	    else {
                if (len && unpack_only_one)
                    len = 1;
		EXTEND(SP, len);
		EXTEND_MORTAL(len);
		while (len-- > 0) {
		    COPYNN(s, &along, sizeof(long));
		    s += sizeof(long);
		    sv = NEWSV(42, 0);
		    sv_setiv(sv, (IV)along);
		    PUSHs(sv_2mortal(sv));
		}
	    }
	    break;
#else
	    /* Fallthrough! */
d1122 2
a1123 6
	case 'l':
	    along = (strend - s) / SIZE32;
	    if (len > along)
		len = along;
	    if (checksum) {
		while (len-- > 0) {
d1125 1
a1125 1
		    I32 along;
d1127 1
a1127 1
		    COPY32(s, &along);
d1129 2
a1130 2
		    if (along > 2147483647)
		        along -= 4294967296;
d1132 6
a1137 5
		    s += SIZE32;
		    if (checksum > bits_in_uv)
			cdouble += (NV)along;
		    else
			cuv += along;
d1141 1
a1141 1
                if (len && unpack_only_one)
d1145 14
a1158 1
		while (len-- > 0) {
d1160 1
a1160 1
		    I32 along;
d1162 1
a1162 1
		    COPY32(s, &along);
d1164 2
a1165 2
		    if (along > 2147483647)
		        along -= 4294967296;
d1167 5
a1171 35
		    s += SIZE32;
		    sv = NEWSV(42, 0);
		    sv_setiv(sv, (IV)along);
		    PUSHs(sv_2mortal(sv));
		}
	    }
	    break;
	case 'L' | TYPE_IS_SHRIEKING:
#if LONGSIZE != SIZE32
	    along = (strend - s) / sizeof(unsigned long);
	    if (len > along)
		len = along;
	    if (checksum) {
		while (len-- > 0) {
		    unsigned long aulong;
		    COPYNN(s, &aulong, sizeof(unsigned long));
		    s += sizeof(unsigned long);
		    if (checksum > bits_in_uv)
			cdouble += (NV)aulong;
		    else
			cuv += aulong;
		}
	    }
	    else {
                if (len && unpack_only_one)
                    len = 1;
		EXTEND(SP, len);
		EXTEND_MORTAL(len);
		while (len-- > 0) {
		    unsigned long aulong;
		    COPYNN(s, &aulong, sizeof(unsigned long));
		    s += sizeof(unsigned long);
		    sv = NEWSV(43, 0);
		    sv_setuv(sv, (UV)aulong);
		    PUSHs(sv_2mortal(sv));
a1174 3
#else
            /* Fall through! */
#endif
d1178 1
d1180 4
d1187 18
a1204 3
		while (len-- > 0) {
		    COPY32(s, &aulong);
		    s += SIZE32;
d1206 2
a1207 2
		    if (datumtype == 'N')
			aulong = PerlSock_ntohl(aulong);
d1210 2
a1211 2
		    if (datumtype == 'V')
			aulong = vtohl(aulong);
d1213 5
a1217 4
		    if (checksum > bits_in_uv)
			cdouble += (NV)aulong;
		    else
			cuv += aulong;
d1221 1
a1221 1
                if (len && unpack_only_one)
d1225 17
a1241 3
		while (len-- > 0) {
		    COPY32(s, &aulong);
		    s += SIZE32;
d1243 2
a1244 2
		    if (datumtype == 'N')
			aulong = PerlSock_ntohl(aulong);
d1247 2
a1248 2
		    if (datumtype == 'V')
			aulong = vtohl(aulong);
d1250 4
a1253 3
		    sv = NEWSV(43, 0);
		    sv_setuv(sv, (UV)aulong);
		    PUSHs(sv_2mortal(sv));
d1277 1
a1277 1
            if (len && unpack_only_one)
d1318 1
a1318 1
		    Perl_croak(aTHX_ "Unterminated compressed integer in unpack");
d1322 2
a1323 2
	    if (symptr->howlen == e_star)
	        Perl_croak(aTHX_ "'P' must have an explicit size in unpack");
d1352 1
a1352 1
                if (len && unpack_only_one)
d1387 1
a1387 1
                if (len && unpack_only_one)
d1421 1
a1421 1
                if (len && unpack_only_one)
d1446 1
a1446 1
                if (len && unpack_only_one)
d1471 1
a1471 1
                if (len && unpack_only_one)
d1497 1
a1497 1
                if (len && unpack_only_one)
a1570 1

d1575 1
a1575 1
	       strchr("csSiIlLnNUvVqQjJ", datumtype&0xFF)) ) {
d1591 1
a1598 22
    
        if (symptr->flags & FLAG_SLASH){
            if (SP - PL_stack_base - start_sp_offset <= 0)
                Perl_croak(aTHX_ "'/' must follow a numeric type in unpack");
            if( next_symbol(symptr) ){
              if( symptr->howlen == e_number )
		Perl_croak(aTHX_ "Count after length/code in unpack" );
              if( beyond ){
         	/* ...end of char buffer then no decent length available */
		Perl_croak(aTHX_ "length/code after end of string in unpack" );
              } else {
         	/* take top of stack (hope it's numeric) */
                len = POPi;
                if( len < 0 )
                    Perl_croak(aTHX_ "Negative '/' count in unpack" );
              }
            } else {
		Perl_croak(aTHX_ "Code missing after '/' in unpack" );
            }
            datumtype = symptr->code;
	    goto redo_switch;
        }
a1599 1

d1627 3
a1629 4
    cnt = unpackstring(pat, patend, s, strend,
		     ((gimme == G_SCALAR) ? FLAG_UNPACK_ONLY_ONE : 0)
		     | (DO_UTF8(right) ? FLAG_UNPACK_DO_UTF8 : 0));

d1740 1
a1740 1

d1745 1
a1745 2
The engine implementing pack() Perl function. Note: parameters next_in_list and
flags are not used. This call should not be used; use packlist instead.
a1748 1

a1751 33
    tempsym_t sym = { 0 };
    sym.patptr = pat;
    sym.patend = patend;
    sym.flags  = FLAG_PACK;

    (void)pack_rec( cat, &sym, beglist, endlist );
}


/*
=for apidoc packlist

The engine implementing pack() Perl function.

=cut */


void
Perl_packlist(pTHX_ SV *cat, char *pat, register char *patend, register SV **beglist, SV **endlist )
{
    tempsym_t sym = { 0 };
    sym.patptr = pat;
    sym.patend = patend;
    sym.flags  = FLAG_PACK;

    (void)pack_rec( cat, &sym, beglist, endlist );
}


STATIC
SV **
S_pack_rec(pTHX_ SV *cat, register tempsym_t* symptr, register SV **beglist, SV **endlist )
{
d1754 2
a1755 1
    register I32 len = 0;
d1760 1
a1760 1
    bool found;
d1782 4
a1785 2
    int strrelbeg = SvCUR(cat);
    tempsym_t lookahead;
a1787 2
    found = next_symbol( symptr );

d1789 2
a1790 1
    if (symptr->level == 0 && found && symptr->code == 'U' ){
a1791 1
    }
d1793 1
a1793 2

    while (found) {
d1796 30
a1825 23

        I32 datumtype = symptr->code;
        howlen_t howlen;

        switch( howlen = symptr->howlen ){
        case e_no_len:
	case e_number:
	    len = symptr->length;
	    break;
        case e_star:
	    len = strchr("@@Xxu", datumtype) ? 0 : items; 
	    break;
        }

        /* Look ahead for next symbol. Do we have code/code? */
        lookahead = *symptr;
        found = next_symbol(&lookahead);
	if ( symptr->flags & FLAG_SLASH ) {
	    if (found){
 	        if ( 0 == strchr( "aAZ", lookahead.code ) ||
                     e_star != lookahead.howlen )
 		    Perl_croak(aTHX_ "'/' must be followed by 'a*', 'A*' or 'Z*' in pack");
	        lengthcode = sv_2mortal(newSViv(sv_len(items > 0
d1827 1
a1827 4
                                           + (lookahead.code == 'Z' ? 1 : 0)));
	    } else {
 		Perl_croak(aTHX_ "Code missing after '/' in pack");
            }
a1828 1

d1831 6
a1836 1
	    Perl_croak(aTHX_ "Invalid type '%c' in pack", (int)datumtype);
d1838 1
a1838 1
	    Perl_croak(aTHX_ "'%%' may not be used in pack");
d1840 1
a1840 1
	    len += strrelbeg - SvCUR(cat);
d1849 14
a1862 3
            tempsym_t savsym = *symptr;
            symptr->patend = savsym.grpend;
            symptr->level++;
d1864 3
a1866 3
  	        symptr->patptr = savsym.grpbeg;
		beglist = pack_rec(cat, symptr, beglist, endlist );
		if (savsym.howlen == e_star && beglist == endlist)
d1869 1
a1869 2
            lookahead.flags = symptr->flags;
            *symptr = savsym;
d1880 1
a1880 1
		Perl_croak(aTHX_ "'X' outside of string in pack");
a1892 1

d1906 1
a1906 1
	    if (howlen == e_star) {   
d1944 1
a1944 1
		if (howlen == e_star)
d2000 1
a2000 1
		if (howlen == e_star)
d2057 1
a2057 1
				    "Character in 'C' format wrapped in pack");
d2066 1
a2066 1
				    "Character in 'c' format wrapped in pack" );
d2188 1
a2188 1
        case 'S' | TYPE_IS_SHRIEKING:
d2190 1
a2190 1
	    {
d2198 2
a2199 4
            }
            break;
#else
            /* Fall through! */
a2200 1
	case 'S':
d2212 1
a2212 1
	case 's' | TYPE_IS_SHRIEKING:
d2214 1
a2214 1
	    {
d2223 1
a2223 3
            break;
#else
            /* Fall through! */
d2225 6
a2230 5
	case 's':
	    while (len-- > 0) {
		fromstr = NEXTFROM;
		ashort = (I16)SvIV(fromstr);
		CAT16(cat, &ashort);
a2233 1
	case 'I' | TYPE_IS_SHRIEKING:
d2260 1
a2260 1
		    Perl_croak(aTHX_ "Cannot compress negative numbers in pack");
d2289 1
a2289 1
			Perl_croak(aTHX_ "Can only compress unsigned integers in pack");
d2302 1
a2302 11
		    /* 10**NV_MAX_10_EXP is the largest power of 10
		       so 10**(NV_MAX_10_EXP+1) is definately unrepresentable
		       given 10**(NV_MAX_10_EXP+1) == 128 ** x solve for x:
		       x = (NV_MAX_10_EXP+1) * log (10) / log (128)
		       And with that many bytes only Inf can overflow.
		    */
#ifdef NV_MAX_10_EXP
		    char   buf[1 + (int)((NV_MAX_10_EXP + 1) * 0.47456)];
#else
		    char   buf[1 + (int)((308 + 1) * 0.47456)];
#endif
d2308 1
d2310 1
a2310 2
			    Perl_croak(aTHX_ "Cannot compress integer in pack");
			*--in = (unsigned char)(anv - (next * 128)) | 0x80;
d2325 1
a2325 1
			Perl_croak(aTHX_ "Can only compress unsigned integers in pack");
a2339 1
	case 'i' | TYPE_IS_SHRIEKING:
d2366 1
a2366 1
	case 'L' | TYPE_IS_SHRIEKING:
d2368 1
a2368 1
	    {
d2377 1
a2377 3
	    break;
#else
            /* Fall though! */
a2378 1
	case 'L':
d2387 1
a2387 1
	case 'l' | TYPE_IS_SHRIEKING:
d2389 1
a2389 1
	    {
d2398 1
a2398 3
	    break;
#else
            /* Fall though! */
d2400 6
a2405 5
	case 'l':
            while (len-- > 0) {
		fromstr = NEXTFROM;
		along = SvIV(fromstr);
		CAT32(cat, &along);
d2426 1
a2426 1
	    /* Fall through! */
a2474 1
	*symptr = lookahead;
d2476 2
a2477 1
    return beglist;
d2493 1
a2493 1
    packlist(cat, pat, patend, MARK, SP + 1);
@


1.1.1.3
log
@Import of stock perl 5.8.5
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
d24 11
a2431 4
		       Some C compilers are strict about integral constant
		       expressions so we conservatively divide by a slightly
		       smaller integer instead of multiplying by the exact
		       floating-point value.
d2434 1
a2434 2
/*		    char   buf[1 + (int)((NV_MAX_10_EXP + 1) * 0.47456)]; -- invalid C */
		    char   buf[1 + (int)((NV_MAX_10_EXP + 1) / 2)]; /* valid C */
d2436 1
a2436 2
/*		    char   buf[1 + (int)((308 + 1) * 0.47456)]; -- invalid C */
		    char   buf[1 + (int)((308 + 1) / 2)]; /* valid C */
@


1.1.1.4
log
@perl 5.8.6 from CPAN
@
text
@a18 11
/* This file contains pp ("push/pop") functions that
 * execute the opcodes that make up a perl program. A typical pp function
 * expects to find its arguments on the stack, and usually pushes its
 * results onto the stack, hence the 'pp' terminology. Each OP structure
 * contains a pointer to the relevant pp_foo() function.
 *
 * This particular file just contains pp_pack() and pp_unpack(). See the
 * other pp*.c files for the rest of the pp_ functions.
 */


@


1.1.1.5
log
@perl 5.8.8 import
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, by Larry Wall and others
a33 5
#if PERL_VERSION >= 9
#define PERL_PACK_CAN_BYTEORDER
#define PERL_PACK_CAN_SHRIEKSIGN
#endif

d58 6
a63 2
#if U16SIZE > SIZE16 || U32SIZE > SIZE32
#  if BYTEORDER == 0x1234 || BYTEORDER == 0x12345678    /* little-endian */
d67 1
a67 1
#    if BYTEORDER == 0x4321 || BYTEORDER == 0x87654321  /* big-endian */
d90 1
a90 1
/* flags (note that type modifiers can also be used as flags!) */
a136 1
/* type modifiers */
a137 354
#define TYPE_IS_BIG_ENDIAN	0x200
#define TYPE_IS_LITTLE_ENDIAN	0x400
#define TYPE_ENDIANNESS_MASK	(TYPE_IS_BIG_ENDIAN|TYPE_IS_LITTLE_ENDIAN)
#define TYPE_MODIFIERS(t)	((t) & ~0xFF)
#define TYPE_NO_MODIFIERS(t)	((t) & 0xFF)

#ifdef PERL_PACK_CAN_SHRIEKSIGN
#define SHRIEKING_ALLOWED_TYPES "sSiIlLxXnNvV"
#else
#define SHRIEKING_ALLOWED_TYPES "sSiIlLxX"
#endif

#ifndef PERL_PACK_CAN_BYTEORDER
/* Put "can't" first because it is shorter  */
# define TYPE_ENDIANNESS(t)	0
# define TYPE_NO_ENDIANNESS(t)	(t)

# define ENDIANNESS_ALLOWED_TYPES   ""

# define DO_BO_UNPACK(var, type)
# define DO_BO_PACK(var, type)
# define DO_BO_UNPACK_PTR(var, type, pre_cast, post_cast)
# define DO_BO_PACK_PTR(var, type, pre_cast, post_cast)
# define DO_BO_UNPACK_N(var, type)
# define DO_BO_PACK_N(var, type)
# define DO_BO_UNPACK_P(var)
# define DO_BO_PACK_P(var)
# define DO_BO_UNPACK_PC(var)
# define DO_BO_PACK_PC(var)

#else

# define TYPE_ENDIANNESS(t)	((t) & TYPE_ENDIANNESS_MASK)
# define TYPE_NO_ENDIANNESS(t)	((t) & ~TYPE_ENDIANNESS_MASK)

# define ENDIANNESS_ALLOWED_TYPES   "sSiIlLqQjJfFdDpP("

# define DO_BO_UNPACK(var, type)                                              \
        STMT_START {                                                          \
          switch (TYPE_ENDIANNESS(datumtype)) {                               \
            case TYPE_IS_BIG_ENDIAN:    var = my_betoh ## type (var); break;  \
            case TYPE_IS_LITTLE_ENDIAN: var = my_letoh ## type (var); break;  \
            default: break;                                                   \
          }                                                                   \
        } STMT_END

# define DO_BO_PACK(var, type)                                                \
        STMT_START {                                                          \
          switch (TYPE_ENDIANNESS(datumtype)) {                               \
            case TYPE_IS_BIG_ENDIAN:    var = my_htobe ## type (var); break;  \
            case TYPE_IS_LITTLE_ENDIAN: var = my_htole ## type (var); break;  \
            default: break;                                                   \
          }                                                                   \
        } STMT_END

# define DO_BO_UNPACK_PTR(var, type, pre_cast, post_cast)                     \
        STMT_START {                                                          \
          switch (TYPE_ENDIANNESS(datumtype)) {                               \
            case TYPE_IS_BIG_ENDIAN:                                          \
              var = (post_cast*) my_betoh ## type ((pre_cast) var);           \
              break;                                                          \
            case TYPE_IS_LITTLE_ENDIAN:                                       \
              var = (post_cast *) my_letoh ## type ((pre_cast) var);          \
              break;                                                          \
            default:                                                          \
              break;                                                          \
          }                                                                   \
        } STMT_END

# define DO_BO_PACK_PTR(var, type, pre_cast, post_cast)                       \
        STMT_START {                                                          \
          switch (TYPE_ENDIANNESS(datumtype)) {                               \
            case TYPE_IS_BIG_ENDIAN:                                          \
              var = (post_cast *) my_htobe ## type ((pre_cast) var);          \
              break;                                                          \
            case TYPE_IS_LITTLE_ENDIAN:                                       \
              var = (post_cast *) my_htole ## type ((pre_cast) var);          \
              break;                                                          \
            default:                                                          \
              break;                                                          \
          }                                                                   \
        } STMT_END

# define BO_CANT_DOIT(action, type)                                           \
        STMT_START {                                                          \
          switch (TYPE_ENDIANNESS(datumtype)) {                               \
             case TYPE_IS_BIG_ENDIAN:                                         \
               Perl_croak(aTHX_ "Can't %s big-endian %ss on this "            \
                                "platform", #action, #type);                  \
               break;                                                         \
             case TYPE_IS_LITTLE_ENDIAN:                                      \
               Perl_croak(aTHX_ "Can't %s little-endian %ss on this "         \
                                "platform", #action, #type);                  \
               break;                                                         \
             default:                                                         \
               break;                                                         \
           }                                                                  \
         } STMT_END

# if PTRSIZE == INTSIZE
#  define DO_BO_UNPACK_P(var)	DO_BO_UNPACK_PTR(var, i, int, void)
#  define DO_BO_PACK_P(var)	DO_BO_PACK_PTR(var, i, int, void)
#  define DO_BO_UNPACK_PC(var)	DO_BO_UNPACK_PTR(var, i, int, char)
#  define DO_BO_PACK_PC(var)	DO_BO_PACK_PTR(var, i, int, char)
# elif PTRSIZE == LONGSIZE
#  define DO_BO_UNPACK_P(var)	DO_BO_UNPACK_PTR(var, l, long, void)
#  define DO_BO_PACK_P(var)	DO_BO_PACK_PTR(var, l, long, void)
#  define DO_BO_UNPACK_PC(var)	DO_BO_UNPACK_PTR(var, l, long, char)
#  define DO_BO_PACK_PC(var)	DO_BO_PACK_PTR(var, l, long, char)
# else
#  define DO_BO_UNPACK_P(var)	BO_CANT_DOIT(unpack, pointer)
#  define DO_BO_PACK_P(var)	BO_CANT_DOIT(pack, pointer)
#  define DO_BO_UNPACK_PC(var)	BO_CANT_DOIT(unpack, pointer)
#  define DO_BO_PACK_PC(var)	BO_CANT_DOIT(pack, pointer)
# endif

# if defined(my_htolen) && defined(my_letohn) && \
    defined(my_htoben) && defined(my_betohn)
#  define DO_BO_UNPACK_N(var, type)                                           \
         STMT_START {                                                         \
           switch (TYPE_ENDIANNESS(datumtype)) {                              \
             case TYPE_IS_BIG_ENDIAN:    my_betohn(&var, sizeof(type)); break;\
             case TYPE_IS_LITTLE_ENDIAN: my_letohn(&var, sizeof(type)); break;\
             default: break;                                                  \
           }                                                                  \
         } STMT_END

#  define DO_BO_PACK_N(var, type)                                             \
         STMT_START {                                                         \
           switch (TYPE_ENDIANNESS(datumtype)) {                              \
             case TYPE_IS_BIG_ENDIAN:    my_htoben(&var, sizeof(type)); break;\
             case TYPE_IS_LITTLE_ENDIAN: my_htolen(&var, sizeof(type)); break;\
             default: break;                                                  \
           }                                                                  \
         } STMT_END
# else
#  define DO_BO_UNPACK_N(var, type)	BO_CANT_DOIT(unpack, type)
#  define DO_BO_PACK_N(var, type)	BO_CANT_DOIT(pack, type)
# endif

#endif

#define PACK_SIZE_CANNOT_CSUM		0x80
#define PACK_SIZE_SPARE			0x40
#define PACK_SIZE_MASK			0x3F


struct packsize_t {
    const unsigned char *array;
    int first;
    int size;
};

#define PACK_SIZE_NORMAL 0
#define PACK_SIZE_SHRIEKING 1

/* These tables are regenerated by genpacksizetables.pl (and then hand pasted
   in).  You're unlikely ever to need to regenerate them.  */
#if 'J'-'I' == 1
/* ASCII */
unsigned char size_normal[53] = {
  /* C */ sizeof(unsigned char),
#if defined(HAS_LONG_DOUBLE) && defined(USE_LONG_DOUBLE)
  /* D */ LONG_DOUBLESIZE,
#else
  0,
#endif
  0,
  /* F */ NVSIZE,
  0, 0,
  /* I */ sizeof(unsigned int),
  /* J */ UVSIZE,
  0,
  /* L */ SIZE32,
  0,
  /* N */ SIZE32,
  0, 0,
#if defined(HAS_QUAD)
  /* Q */ sizeof(Uquad_t),
#else
  0,
#endif
  0,
  /* S */ SIZE16,
  0,
  /* U */ sizeof(char),
  /* V */ SIZE32,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  /* c */ sizeof(char),
  /* d */ sizeof(double),
  0,
  /* f */ sizeof(float),
  0, 0,
  /* i */ sizeof(int),
  /* j */ IVSIZE,
  0,
  /* l */ SIZE32,
  0,
  /* n */ SIZE16,
  0,
  /* p */ sizeof(char *) | PACK_SIZE_CANNOT_CSUM,
#if defined(HAS_QUAD)
  /* q */ sizeof(Quad_t),
#else
  0,
#endif
  0,
  /* s */ SIZE16,
  0, 0,
  /* v */ SIZE16,
  /* w */ sizeof(char) | PACK_SIZE_CANNOT_CSUM,
};
unsigned char size_shrieking[46] = {
  /* I */ sizeof(unsigned int),
  0, 0,
  /* L */ sizeof(unsigned long),
  0,
#if defined(PERL_PACK_CAN_SHRIEKSIGN)
  /* N */ SIZE32,
#else
  0,
#endif
  0, 0, 0, 0,
  /* S */ sizeof(unsigned short),
  0, 0,
#if defined(PERL_PACK_CAN_SHRIEKSIGN)
  /* V */ SIZE32,
#else
  0,
#endif
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  /* i */ sizeof(int),
  0, 0,
  /* l */ sizeof(long),
  0,
#if defined(PERL_PACK_CAN_SHRIEKSIGN)
  /* n */ SIZE16,
#else
  0,
#endif
  0, 0, 0, 0,
  /* s */ sizeof(short),
  0, 0,
#if defined(PERL_PACK_CAN_SHRIEKSIGN)
  /* v */ SIZE16
#else
  0
#endif
};
struct packsize_t packsize[2] = {
  {size_normal, 67, 53},
  {size_shrieking, 73, 46}
};
#else
/* EBCDIC (or bust) */
unsigned char size_normal[99] = {
  /* c */ sizeof(char),
  /* d */ sizeof(double),
  0,
  /* f */ sizeof(float),
  0, 0,
  /* i */ sizeof(int),
  0, 0, 0, 0, 0, 0, 0,
  /* j */ IVSIZE,
  0,
  /* l */ SIZE32,
  0,
  /* n */ SIZE16,
  0,
  /* p */ sizeof(char *) | PACK_SIZE_CANNOT_CSUM,
#if defined(HAS_QUAD)
  /* q */ sizeof(Quad_t),
#else
  0,
#endif
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  /* s */ SIZE16,
  0, 0,
  /* v */ SIZE16,
  /* w */ sizeof(char) | PACK_SIZE_CANNOT_CSUM,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0,
  /* C */ sizeof(unsigned char),
#if defined(HAS_LONG_DOUBLE) && defined(USE_LONG_DOUBLE)
  /* D */ LONG_DOUBLESIZE,
#else
  0,
#endif
  0,
  /* F */ NVSIZE,
  0, 0,
  /* I */ sizeof(unsigned int),
  0, 0, 0, 0, 0, 0, 0,
  /* J */ UVSIZE,
  0,
  /* L */ SIZE32,
  0,
  /* N */ SIZE32,
  0, 0,
#if defined(HAS_QUAD)
  /* Q */ sizeof(Uquad_t),
#else
  0,
#endif
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  /* S */ SIZE16,
  0,
  /* U */ sizeof(char),
  /* V */ SIZE32,
};
unsigned char size_shrieking[93] = {
  /* i */ sizeof(int),
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  /* l */ sizeof(long),
  0,
#if defined(PERL_PACK_CAN_SHRIEKSIGN)
  /* n */ SIZE16,
#else
  0,
#endif
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  /* s */ sizeof(short),
  0, 0,
#if defined(PERL_PACK_CAN_SHRIEKSIGN)
  /* v */ SIZE16,
#else
  0,
#endif
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  /* I */ sizeof(unsigned int),
  0, 0, 0, 0, 0, 0, 0, 0, 0,
  /* L */ sizeof(unsigned long),
  0,
#if defined(PERL_PACK_CAN_SHRIEKSIGN)
  /* N */ SIZE32,
#else
  0,
#endif
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  /* S */ sizeof(unsigned short),
  0, 0,
#if defined(PERL_PACK_CAN_SHRIEKSIGN)
  /* V */ SIZE32
#else
  0
#endif
};
struct packsize_t packsize[2] = {
  {size_normal, 131, 99},
  {size_shrieking, 137, 93}
};
#endif

a149 4
	int which = (symptr->code & TYPE_IS_SHRIEKING)
	    ? PACK_SIZE_SHRIEKING : PACK_SIZE_NORMAL;
	int offset
	    = TYPE_NO_MODIFIERS(symptr->code) - packsize[which].first;
d162 14
a175 3
	if ((offset >= 0) && (offset < packsize[which].size))
	    size = packsize[which].array[offset] & PACK_SIZE_MASK;
	else
d177 139
a315 78

	if (!size) {
	    /* endianness doesn't influence the size of a type */
	    switch(TYPE_NO_ENDIANNESS(symptr->code)) {
	    default:
		Perl_croak(aTHX_ "Invalid type '%c' in %s",
			   (int)TYPE_NO_MODIFIERS(symptr->code),
			   symptr->flags & FLAG_PACK ? "pack" : "unpack" );
	    case '@@':
	    case '/':
	    case 'U':			/* XXXX Is it correct? */
	    case 'w':
	    case 'u':
		Perl_croak(aTHX_ "Within []-length '%c' not allowed in %s",
			   (int)symptr->code,
			   symptr->flags & FLAG_PACK ? "pack" : "unpack" );
	    case '%':
		size = 0;
		break;
	    case '(':
		{
		    tempsym_t savsym = *symptr;
		    symptr->patptr = savsym.grpbeg;
		    symptr->patend = savsym.grpend;
		    /* XXXX Theoretically, we need to measure many times at
		       different positions, since the subexpression may contain
		       alignment commands, but be not of aligned length.
		       Need to detect this and croak().  */
		    size = measure_struct(symptr);
		    *symptr = savsym;
		    break;
		}
	    case 'X' | TYPE_IS_SHRIEKING:
		/* XXXX Is this useful?  Then need to treat MEASURE_BACKWARDS.
		 */
		if (!len)		/* Avoid division by 0 */
		    len = 1;
		len = total % len;	/* Assumed: the start is aligned. */
		/* FALL THROUGH */
	    case 'X':
		size = -1;
		if (total < len)
		    Perl_croak(aTHX_ "'X' outside of string in %s",
			       symptr->flags & FLAG_PACK ? "pack" : "unpack" );
		break;
	    case 'x' | TYPE_IS_SHRIEKING:
		if (!len)		/* Avoid division by 0 */
		    len = 1;
		star = total % len;	/* Assumed: the start is aligned. */
		if (star)		/* Other portable ways? */
		    len = len - star;
		else
		    len = 0;
		/* FALL THROUGH */
	    case 'x':
	    case 'A':
	    case 'Z':
	    case 'a':
	    case 'c':
	    case 'C':
		size = 1;
		break;
	    case 'B':
	    case 'b':
		len = (len + 7)/8;
		size = 1;
		break;
	    case 'H':
	    case 'h':
		len = (len + 1)/2;
		size = 1;
		break;

	    case 'P':
		len = 1;
		size = sizeof(char*);
		break;
	    }
d326 2
a327 2
STATIC const char *
S_group_end(pTHX_ register const char *patptr, register const char *patend, char ender)
d355 2
a356 2
STATIC const char *
S_get_num(pTHX_ register const char *patptr, I32 *lenptr )
d374 2
a375 2
  const char* patptr = symptr->patptr; 
  const char* patend = symptr->patend; 
a390 1
      U32 inherited_modifiers = 0;
d407 2
a408 3
        symptr->grpbeg = (char *) patptr;
        patptr
	    = 1 + ( symptr->grpend = (char *)group_end(patptr, patend, ')') );
d414 9
a422 57
      /* look for group modifiers to inherit */
      if (TYPE_ENDIANNESS(symptr->flags)) {
        if (strchr(ENDIANNESS_ALLOWED_TYPES, TYPE_NO_MODIFIERS(code)))
          inherited_modifiers |= TYPE_ENDIANNESS(symptr->flags);
      }

      /* look for modifiers */
      while (patptr < patend) {
        const char *allowed;
        I32 modifier;
        switch (*patptr) {
          case '!':
            modifier = TYPE_IS_SHRIEKING;
            allowed = SHRIEKING_ALLOWED_TYPES;
            break;
#ifdef PERL_PACK_CAN_BYTEORDER
          case '>':
            modifier = TYPE_IS_BIG_ENDIAN;
            allowed = ENDIANNESS_ALLOWED_TYPES;
            break;
          case '<':
            modifier = TYPE_IS_LITTLE_ENDIAN;
            allowed = ENDIANNESS_ALLOWED_TYPES;
            break;
#endif
          default:
            allowed = "";
            modifier = 0;
            break;
        }

        if (modifier == 0)
          break;

        if (!strchr(allowed, TYPE_NO_MODIFIERS(code)))
          Perl_croak(aTHX_ "'%c' allowed only after types %s in %s", *patptr,
                     allowed, symptr->flags & FLAG_PACK ? "pack" : "unpack" );

        if (TYPE_ENDIANNESS(code | modifier) == TYPE_ENDIANNESS_MASK)
          Perl_croak(aTHX_ "Can't use both '<' and '>' after type '%c' in %s",
                     (int) TYPE_NO_MODIFIERS(code),
                     symptr->flags & FLAG_PACK ? "pack" : "unpack" );
        else if (TYPE_ENDIANNESS(code | modifier | inherited_modifiers) ==
                 TYPE_ENDIANNESS_MASK)
          Perl_croak(aTHX_ "Can't use '%c' in a group with different byte-order in %s",
                     *patptr, symptr->flags & FLAG_PACK ? "pack" : "unpack" );

        if (ckWARN(WARN_UNPACK)) {
          if (code & modifier)
	    Perl_warner(aTHX_ packWARN(WARN_UNPACK),
                        "Duplicate modifier '%c' after '%c' in %s",
                        *patptr, (int) TYPE_NO_MODIFIERS(code),
                        symptr->flags & FLAG_PACK ? "pack" : "unpack" );
        }

        code |= modifier;
        patptr++;
a424 3
      /* inherit modifiers */
      code |= inherited_modifiers;

d436 1
a436 1
          const char* lenptr = ++patptr;            
d447 2
a448 2
            symptr->patend = (char *) patptr-1;
            symptr->patptr = (char *) lenptr;
d468 1
a468 1
            if (*patptr == '/') {
d471 2
a472 2
              if (patptr < patend &&
                  (isDIGIT(*patptr) || *patptr == '*' || *patptr == '['))
d486 1
a486 1
      symptr->patptr = (char *) patptr; 
d490 1
a490 1
  symptr->patptr = (char *) patptr; 
d547 3
a549 4
    I16 ai16;
    U16 au16;
    I32 ai32;
    U32 au32;
a551 1
    Uquad_t auquad;
d553 1
a553 5
#if SHORTSIZE != SIZE16
    short ashort;
    unsigned short aushort;
#endif
    int aint;
d555 3
a557 3
    long along;
#if LONGSIZE != SIZE32
    unsigned long aulong;
a561 7
#if defined(HAS_LONG_DOUBLE) && defined(USE_LONG_DOUBLE)
    long double aldouble;
#endif
    IV aiv;
    UV auv;
    NV anv;

a567 1
    bool explicit_length;
d570 7
a596 1
        explicit_length = TRUE;
d599 1
a599 36
	{
	    int which = (symptr->code & TYPE_IS_SHRIEKING)
		? PACK_SIZE_SHRIEKING : PACK_SIZE_NORMAL;
	    const int rawtype = TYPE_NO_MODIFIERS(datumtype);
	    int offset = rawtype - packsize[which].first;

	    if (offset >= 0 && offset < packsize[which].size) {
		/* Data about this template letter  */
		unsigned char data = packsize[which].array[offset];

		if (data) {
		    /* data nonzero means we can process this letter.  */
		    long size = data & PACK_SIZE_MASK;
		    long howmany = (strend - s) / size;
		    if (len > howmany)
			len = howmany;

		    /* In the old code, 'p' was the only type without shortcut
		       code to curtail unpacking to only one.  As far as I can
		       see the only point of retaining this anomaly is to make
		       code such as $_ = unpack "p2", pack "pI", "Hi", 2
		       continue to segfault. ie, it probably should be
		       construed as a bug.
		    */

		    if (!checksum || (data & PACK_SIZE_CANNOT_CSUM)) {
			if (len && unpack_only_one &&
			    rawtype != 'p')
			    len = 1;
			EXTEND(SP, len);
			EXTEND_MORTAL(len);
		    }
		}
	    }
	}
	switch(TYPE_NO_ENDIANNESS(datumtype)) {
d601 1
a601 1
	    Perl_croak(aTHX_ "Invalid type '%c' in unpack", (int)TYPE_NO_MODIFIERS(datumtype) );
a614 2
	    U32 group_modifiers = TYPE_MODIFIERS(datumtype & ~symptr->flags);
	    symptr->flags |= group_modifiers;
a620 4
		if (savsym.flags & FLAG_UNPACK_DO_UTF8)
		    symptr->flags |=  FLAG_UNPACK_DO_UTF8;
		else
		    symptr->flags &= ~FLAG_UNPACK_DO_UTF8;
a625 1
	    symptr->flags &= ~group_modifiers;
d669 2
a670 1
	    sv = newSVpvn(s, len);
d698 1
a698 1
		    Newxz(PL_bitcount, 256, char);
d715 1
a715 1
		    bits = *s++;
d790 25
a814 6
	    while (len-- > 0) {
		aint = *s++;
		if (aint >= 128)	/* fake up signed chars */
		    aint -= 256;
		if (!checksum) {
		    PUSHs(sv_2mortal(newSViv((IV)aint)));
a815 4
		else if (checksum > bits_in_uv)
		    cdouble += (NV)aint;
		else
		    cuv += aint;
d821 1
a821 2
                if (explicit_length) 
                    symptr->flags &= ~FLAG_UNPACK_DO_UTF8;
d824 2
d830 1
a830 4
		    if (checksum > bits_in_uv)
			cdouble += (NV)auint;
		    else
			cuv += auint;
d834 4
d840 3
a842 1
		    PUSHs(sv_2mortal(newSViv((IV)auint)));
d848 1
a848 2
                if (explicit_length) 
                    symptr->flags |= FLAG_UNPACK_DO_UTF8;
d853 27
a879 7
	    while (len-- > 0 && s < strend) {
		STRLEN alen;
		auint = NATIVE_TO_UNI(utf8n_to_uvchr((U8*)s, strend - s, &alen, ckWARN(WARN_UTF8) ? 0 : UTF8_ALLOW_ANYUV));
		along = alen;
		s += along;
		if (!checksum) {
		    PUSHs(sv_2mortal(newSVuv((UV)auint)));
a880 4
		else if (checksum > bits_in_uv)
		    cdouble += (NV)auint;
		else
		    cuv += auint;
d885 27
a911 6
	    while (len-- > 0) {
		COPYNN(s, &ashort, sizeof(short));
		DO_BO_UNPACK(ashort, s);
		s += sizeof(short);
		if (!checksum) {
		    PUSHs(sv_2mortal(newSViv((IV)ashort)));
a912 4
		else if (checksum > bits_in_uv)
		    cdouble += (NV)ashort;
		else
		    cuv += ashort;
d919 33
a951 10
	    while (len-- > 0) {
		COPY16(s, &ai16);
		DO_BO_UNPACK(ai16, 16);
#if U16SIZE > SIZE16
		if (ai16 > 32767)
		    ai16 -= 65536;
#endif
		s += SIZE16;
		if (!checksum) {
		    PUSHs(sv_2mortal(newSViv((IV)ai16)));
a952 4
		else if (checksum > bits_in_uv)
		    cdouble += (NV)ai16;
		else
		    cuv += ai16;
d957 26
a982 6
	    while (len-- > 0) {
		COPYNN(s, &aushort, sizeof(unsigned short));
		DO_BO_UNPACK(aushort, s);
		s += sizeof(unsigned short);
		if (!checksum) {
		    PUSHs(sv_2mortal(newSViv((UV)aushort)));
a983 4
		else if (checksum > bits_in_uv)
		    cdouble += (NV)aushort;
		else
		    cuv += aushort;
d992 7
a998 4
	    while (len-- > 0) {
		COPY16(s, &au16);
		DO_BO_UNPACK(au16, 16);
		s += SIZE16;
d1000 2
a1001 2
		if (datumtype == 'n')
		    au16 = PerlSock_ntohs(au16);
d1004 2
a1005 2
		if (datumtype == 'v')
		    au16 = vtohs(au16);
d1007 4
a1010 2
		if (!checksum) {
		    PUSHs(sv_2mortal(newSViv((UV)au16)));
a1011 4
		else if (checksum > bits_in_uv)
		    cdouble += (NV)au16;
		else
		    cuv += au16;
d1013 9
a1021 7
	    break;
#ifdef PERL_PACK_CAN_SHRIEKSIGN
	case 'v' | TYPE_IS_SHRIEKING:
	case 'n' | TYPE_IS_SHRIEKING:
	    while (len-- > 0) {
		COPY16(s, &ai16);
		s += SIZE16;
d1023 2
a1024 2
		if (datumtype == ('n' | TYPE_IS_SHRIEKING))
		    ai16 = (I16)PerlSock_ntohs((U16)ai16);
d1027 2
a1028 2
		if (datumtype == ('v' | TYPE_IS_SHRIEKING))
		    ai16 = (I16)vtohs((U16)ai16);
d1030 2
a1031 2
		if (!checksum) {
		    PUSHs(sv_2mortal(newSViv((IV)ai16)));
a1032 4
		else if (checksum > bits_in_uv)
		    cdouble += (NV)ai16;
		else
		    cuv += ai16;
a1034 1
#endif
d1037 49
a1085 6
	    while (len-- > 0) {
		Copy(s, &aint, 1, int);
		DO_BO_UNPACK(aint, i);
		s += sizeof(int);
		if (!checksum) {
		    PUSHs(sv_2mortal(newSViv((IV)aint)));
a1086 4
		else if (checksum > bits_in_uv)
		    cdouble += (NV)aint;
		else
		    cuv += aint;
d1091 31
a1121 6
	    while (len-- > 0) {
		Copy(s, &auint, 1, unsigned int);
		DO_BO_UNPACK(auint, i);
		s += sizeof(unsigned int);
		if (!checksum) {
		    PUSHs(sv_2mortal(newSVuv((UV)auint)));
a1122 4
		else if (checksum > bits_in_uv)
		    cdouble += (NV)auint;
		else
		    cuv += auint;
d1126 24
a1149 12
	    while (len-- > 0) {
		Copy(s, &aiv, 1, IV);
#if IVSIZE == INTSIZE
		DO_BO_UNPACK(aiv, i);
#elif IVSIZE == LONGSIZE
		DO_BO_UNPACK(aiv, l);
#elif defined(HAS_QUAD) && IVSIZE == U64SIZE
		DO_BO_UNPACK(aiv, 64);
#endif
		s += IVSIZE;
		if (!checksum) {
		    PUSHs(sv_2mortal(newSViv(aiv)));
a1150 4
		else if (checksum > bits_in_uv)
		    cdouble += (NV)aiv;
		else
		    cuv += aiv;
d1154 24
a1177 12
	    while (len-- > 0) {
		Copy(s, &auv, 1, UV);
#if UVSIZE == INTSIZE
		DO_BO_UNPACK(auv, i);
#elif UVSIZE == LONGSIZE
		DO_BO_UNPACK(auv, l);
#elif defined(HAS_QUAD) && UVSIZE == U64SIZE
		DO_BO_UNPACK(auv, 64);
#endif
		s += UVSIZE;
		if (!checksum) {
		    PUSHs(sv_2mortal(newSVuv(auv)));
a1178 4
		else if (checksum > bits_in_uv)
		    cdouble += (NV)auv;
		else
		    cuv += auv;
d1183 24
a1206 6
	    while (len-- > 0) {
		COPYNN(s, &along, sizeof(long));
		DO_BO_UNPACK(along, l);
		s += sizeof(long);
		if (!checksum) {
		    PUSHs(sv_2mortal(newSViv((IV)along)));
a1207 4
		else if (checksum > bits_in_uv)
		    cdouble += (NV)along;
		else
		    cuv += along;
d1214 38
a1251 10
	    while (len-- > 0) {
		COPY32(s, &ai32);
		DO_BO_UNPACK(ai32, 32);
#if U32SIZE > SIZE32
		if (ai32 > 2147483647)
		    ai32 -= 4294967296;
#endif
		s += SIZE32;
		if (!checksum) {
		    PUSHs(sv_2mortal(newSViv((IV)ai32)));
a1252 4
		else if (checksum > bits_in_uv)
		    cdouble += (NV)ai32;
		else
		    cuv += ai32;
d1257 26
a1282 6
	    while (len-- > 0) {
		COPYNN(s, &aulong, sizeof(unsigned long));
		DO_BO_UNPACK(aulong, l);
		s += sizeof(unsigned long);
		if (!checksum) {
		    PUSHs(sv_2mortal(newSVuv((UV)aulong)));
a1283 4
		else if (checksum > bits_in_uv)
		    cdouble += (NV)aulong;
		else
		    cuv += aulong;
d1292 7
a1298 4
	    while (len-- > 0) {
		COPY32(s, &au32);
		DO_BO_UNPACK(au32, 32);
		s += SIZE32;
d1300 2
a1301 2
		if (datumtype == 'N')
		    au32 = PerlSock_ntohl(au32);
d1304 2
a1305 2
		if (datumtype == 'V')
		    au32 = vtohl(au32);
d1307 5
a1311 7
		 if (!checksum) {
		     PUSHs(sv_2mortal(newSVuv((UV)au32)));
		 }
		 else if (checksum > bits_in_uv)
		     cdouble += (NV)au32;
		 else
		     cuv += au32;
d1313 8
a1320 7
	    break;
#ifdef PERL_PACK_CAN_SHRIEKSIGN
	case 'V' | TYPE_IS_SHRIEKING:
	case 'N' | TYPE_IS_SHRIEKING:
	    while (len-- > 0) {
		COPY32(s, &ai32);
		s += SIZE32;
d1322 2
a1323 2
		if (datumtype == ('N' | TYPE_IS_SHRIEKING))
		    ai32 = (I32)PerlSock_ntohl((U32)ai32);
d1326 2
a1327 2
		if (datumtype == ('V' | TYPE_IS_SHRIEKING))
		    ai32 = (I32)vtohl((U32)ai32);
d1329 3
a1331 2
		if (!checksum) {
		    PUSHs(sv_2mortal(newSViv((IV)ai32)));
a1332 4
		else if (checksum > bits_in_uv)
		    cdouble += (NV)ai32;
		else
		    cuv += ai32;
a1334 1
#endif
d1336 5
d1342 10
a1351 6
		assert (sizeof(char*) <= strend - s);
		Copy(s, &aptr, 1, char*);
		DO_BO_UNPACK_PC(aptr);
		s += sizeof(char*);
		/* newSVpv generates undef if aptr is NULL */
		PUSHs(sv_2mortal(newSVpv(aptr, 0)));
d1355 4
d1368 3
a1370 1
			PUSHs(sv_2mortal(newSVuv(auv)));
d1375 2
a1376 1
			const char *t;
d1386 1
a1386 1
			t = SvPV_nolen_const(sv);
d1389 1
a1389 1
			sv_chop(sv, (char *)t);
a1406 1
		DO_BO_UNPACK_PC(aptr);
d1409 4
a1412 2
	    /* newSVpvn generates undef if aptr is NULL */
	    PUSHs(sv_2mortal(newSVpvn(aptr, len)));
d1416 31
a1446 8
	    while (len-- > 0) {
		assert (s + sizeof(Quad_t) <= strend);
		Copy(s, &aquad, 1, Quad_t);
		DO_BO_UNPACK(aquad, 64);
		s += sizeof(Quad_t);
		if (!checksum) {
                    PUSHs(sv_2mortal((aquad >= IV_MIN && aquad <= IV_MAX) ?
				     newSViv((IV)aquad) : newSVnv((NV)aquad)));
d1448 1
a1448 5
		else if (checksum > bits_in_uv)
		    cdouble += (NV)aquad;
		else
		    cuv += aquad;
	    }
d1451 11
a1461 8
	    while (len-- > 0) {
		assert (s + sizeof(Uquad_t) <= strend);
		Copy(s, &auquad, 1, Uquad_t);
		DO_BO_UNPACK(auquad, 64);
		s += sizeof(Uquad_t);
		if (!checksum) {
		    PUSHs(sv_2mortal((auquad <= UV_MAX) ?
				     newSVuv((UV)auquad) : newSVnv((NV)auquad)));
a1462 4
		else if (checksum > bits_in_uv)
		    cdouble += (NV)auquad;
		else
		    cuv += auquad;
d1464 20
d1488 8
a1495 6
	    while (len-- > 0) {
		Copy(s, &afloat, 1, float);
		DO_BO_UNPACK_N(afloat, float);
		s += sizeof(float);
		if (!checksum) {
		    PUSHs(sv_2mortal(newSVnv((NV)afloat)));
d1497 12
a1508 2
		else {
		    cdouble += afloat;
d1513 8
a1520 6
	    while (len-- > 0) {
		Copy(s, &adouble, 1, double);
		DO_BO_UNPACK_N(adouble, double);
		s += sizeof(double);
		if (!checksum) {
		    PUSHs(sv_2mortal(newSVnv((NV)adouble)));
d1522 12
a1533 2
		else {
		    cdouble += adouble;
d1538 8
a1545 6
	    while (len-- > 0) {
		Copy(s, &anv, 1, NV);
		DO_BO_UNPACK_N(anv, NV);
		s += NVSIZE;
		if (!checksum) {
		    PUSHs(sv_2mortal(newSVnv(anv)));
d1547 12
a1558 2
		else {
		    cdouble += anv;
d1564 8
a1571 6
	    while (len-- > 0) {
		Copy(s, &aldouble, 1, long double);
		DO_BO_UNPACK_N(aldouble, long double);
		s += LONG_DOUBLESIZE;
		if (!checksum) {
		    PUSHs(sv_2mortal(newSVnv((NV)aldouble)));
d1573 12
a1584 1
		else {cdouble += aldouble;
d1651 2
a1652 1
	    if (strchr("fFdD", TYPE_NO_MODIFIERS(datumtype)) ||
d1654 1
a1654 1
	       strchr("cCsSiIlLnNUvVqQjJ", TYPE_NO_MODIFIERS(datumtype))) ) {
d1665 1
a1665 1
		sv = newSVnv(cdouble);
d1672 1
a1672 1
		sv = newSVuv(cuv);
a1696 1
            explicit_length = FALSE;
d1714 1
a1714 1
    const char *pat = SvPV_const(left, llen);
d1721 1
a1721 1
    const char *s = SvPV_const(right, rlen);
d1723 2
a1724 2
    const char *strend = s + rlen;
    const char *patend = pat + llen;
d1728 1
a1728 1
    cnt = unpackstring((char *)pat, (char *)patend, (char *)s, (char *)strend,
d1767 1
a1767 1
S_is_an_int(pTHX_ const char *s, STRLEN l)
d1769 1
d1771 1
a1771 1
  char           *result_c = SvPV_nolen(result);	/* convenience */
d1900 11
a1910 4
    I16 ai16;
    U16 au16;
    I32 ai32;
    U32 au32;
a1914 10
#if SHORTSIZE != SIZE16
    short ashort;
    unsigned short aushort;
#endif
    int aint;
    unsigned int auint;
#if LONGSIZE != SIZE32
    long along;
    unsigned long aulong;
#endif
a1917 7
#if defined(HAS_LONG_DOUBLE) && defined(USE_LONG_DOUBLE)
    long double aldouble;
#endif
    IV aiv;
    UV auv;
    NV anv;

d1943 1
a1943 1
	    len = strchr("@@Xxu", TYPE_NO_MODIFIERS(datumtype)) ? 0 : items; 
d1963 1
a1963 1
	switch(TYPE_NO_ENDIANNESS(datumtype)) {
d1965 1
a1965 1
	    Perl_croak(aTHX_ "Invalid type '%c' in pack", (int)TYPE_NO_MODIFIERS(datumtype));
a1978 2
	    U32 group_modifiers = TYPE_MODIFIERS(datumtype & ~symptr->flags);
	    symptr->flags |= group_modifiers;
a1986 1
	    symptr->flags &= ~group_modifiers;
d2025 1
a2025 1
	    aptr = (char *) SvPV_const(fromstr, fromlen);
d2033 1
a2033 1
		if (datumtype == 'Z' && len > 0)
d2171 1
a2171 1
		switch (TYPE_NO_MODIFIERS(datumtype)) {
d2197 1
a2197 1
		SvGROW(cat, SvCUR(cat) + UTF8_MAXBYTES + 1);
a2236 1
		DO_BO_PACK_N(afloat, float);
a2268 1
		DO_BO_PACK_N(adouble, double);
a2272 1
	    Zero(&anv, 1, NV); /* can be long double with unused bits */
a2275 1
		DO_BO_PACK_N(anv, NV);
a2280 2
	    /* long doubles can have unused bits, which may be nonzero */
	    Zero(&aldouble, 1, long double);
a2283 1
		DO_BO_PACK_N(aldouble, long double);
a2287 3
#ifdef PERL_PACK_CAN_SHRIEKSIGN
	case 'n' | TYPE_IS_SHRIEKING:
#endif
d2291 1
a2291 1
		ai16 = (I16)SvIV(fromstr);
d2293 1
a2293 1
		ai16 = PerlSock_htons(ai16);
d2295 1
a2295 1
		CAT16(cat, &ai16);
a2297 3
#ifdef PERL_PACK_CAN_SHRIEKSIGN
	case 'v' | TYPE_IS_SHRIEKING:
#endif
d2301 1
a2301 1
		ai16 = (I16)SvIV(fromstr);
d2303 1
a2303 1
		ai16 = htovs(ai16);
d2305 1
a2305 1
		CAT16(cat, &ai16);
d2311 2
a2315 1
		    DO_BO_PACK(aushort, s);
d2325 2
d2329 2
a2330 3
		    au16 = (U16)SvUV(fromstr);
		    DO_BO_PACK(au16, 16);
		    CAT16(cat, &au16);
d2338 2
a2342 1
		    DO_BO_PACK(ashort, s);
d2353 2
a2354 3
		ai16 = (I16)SvIV(fromstr);
		DO_BO_PACK(ai16, 16);
		CAT16(cat, &ai16);
a2361 1
		DO_BO_PACK(auint, i);
a2368 7
#if IVSIZE == INTSIZE
		DO_BO_PACK(aiv, i);
#elif IVSIZE == LONGSIZE
		DO_BO_PACK(aiv, l);
#elif defined(HAS_QUAD) && IVSIZE == U64SIZE
		DO_BO_PACK(aiv, 64);
#endif
a2375 7
#if UVSIZE == INTSIZE
		DO_BO_PACK(auv, i);
#elif UVSIZE == LONGSIZE
		DO_BO_PACK(auv, l);
#elif defined(HAS_QUAD) && UVSIZE == U64SIZE
		DO_BO_PACK(auv, 64);
#endif
d2458 1
a2458 2
		    const char     *from;
		    char           *result, *in;
d2464 1
a2464 1
		    from = SvPV_const(fromstr, len);
d2468 1
a2468 1
		    Newx(result, len, char);
a2484 1
		DO_BO_PACK(aint, i);
a2487 3
#ifdef PERL_PACK_CAN_SHRIEKSIGN
	case 'N' | TYPE_IS_SHRIEKING:
#endif
d2491 1
a2491 1
		au32 = SvUV(fromstr);
d2493 1
a2493 1
		au32 = PerlSock_htonl(au32);
d2495 1
a2495 1
		CAT32(cat, &au32);
a2497 3
#ifdef PERL_PACK_CAN_SHRIEKSIGN
	case 'V' | TYPE_IS_SHRIEKING:
#endif
d2501 1
a2501 1
		au32 = SvUV(fromstr);
d2503 1
a2503 1
		au32 = htovl(au32);
d2505 1
a2505 1
		CAT32(cat, &au32);
d2511 2
a2515 1
		    DO_BO_PACK(aulong, l);
d2527 2
a2528 3
		    au32 = SvUV(fromstr);
		    DO_BO_PACK(au32, 32);
		    CAT32(cat, &au32);
d2535 2
a2539 1
		    DO_BO_PACK(along, l);
d2550 2
a2551 3
		ai32 = SvIV(fromstr);
		DO_BO_PACK(ai32, 32);
		CAT32(cat, &ai32);
a2558 1
		DO_BO_PACK(auquad, 64);
a2565 1
		DO_BO_PACK(aquad, 64);
d2576 2
a2577 2
		SvGETMAGIC(fromstr);
		if (!SvOK(fromstr)) aptr = NULL;
d2593 1
a2593 1
			aptr = (char *) SvPV_nomg_const(fromstr, n_a);
d2595 1
a2595 1
			aptr = SvPV_force_flags(fromstr, n_a, 0);
a2596 1
		DO_BO_PACK_PC(aptr);
d2602 1
a2602 1
	    aptr = (char *) SvPV_const(fromstr, fromlen);
d2633 2
a2634 3
    SV *pat_sv = *++MARK;
    register const char *pat = SvPV_const(pat_sv, fromlen);
    register const char *patend = pat + fromlen;
d2639 1
a2639 1
    packlist(cat, (char *) pat, (char *) patend, MARK, SP + 1);
a2646 9
/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
@


1.1.1.6
log
@import perl 5.10.0 from CPAN
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
d29 1
a33 38
/* Types used by pack/unpack */ 
typedef enum {
  e_no_len,     /* no length  */
  e_number,     /* number, [] */
  e_star        /* asterisk   */
} howlen_t;

typedef struct tempsym {
  const char*    patptr;   /* current template char */
  const char*    patend;   /* one after last char   */
  const char*    grpbeg;   /* 1st char of ()-group  */
  const char*    grpend;   /* end of ()-group       */
  I32      code;     /* template code (!<>)   */
  I32      length;   /* length/repeat count   */
  howlen_t howlen;   /* how length is given   */ 
  int      level;    /* () nesting level      */
  U32      flags;    /* /=4, comma=2, pack=1  */
                     /*   and group modifiers */
  STRLEN   strbeg;   /* offset of group start */
  struct tempsym *previous; /* previous group */
} tempsym_t;

#define TEMPSYM_INIT(symptr, p, e, f) \
    STMT_START {	\
	(symptr)->patptr   = (p);	\
	(symptr)->patend   = (e);	\
	(symptr)->grpbeg   = NULL;	\
	(symptr)->grpend   = NULL;	\
	(symptr)->grpend   = NULL;	\
	(symptr)->code     = 0;		\
	(symptr)->length   = 0;		\
	(symptr)->howlen   = e_no_len;	\
	(symptr)->level    = 0;		\
	(symptr)->flags    = (f);	\
	(symptr)->strbeg   = 0;		\
	(symptr)->previous = NULL;	\
   } STMT_END

d35 2
a36 6
# define PERL_PACK_CAN_BYTEORDER
# define PERL_PACK_CAN_SHRIEKSIGN
#endif

#ifndef CHAR_BIT
# define CHAR_BIT	8
a37 2
/* Maximum number of bytes to which a byte can grow due to upgrade */
#define UTF8_EXPAND	2
d65 2
a66 2
#    define OFF16(p)	((char*)(p))
#    define OFF32(p)	((char*)(p))
d72 1
a72 1
       ++++ bad cray byte order
d75 11
a85 3
#else
#  define OFF16(p)     ((char *) (p))
#  define OFF32(p)     ((char *) (p))
a87 38
/* Only to be used inside a loop (see the break) */
#define SHIFT16(utf8, s, strend, p, datumtype) STMT_START {		\
    if (utf8) {								\
	if (!uni_to_bytes(aTHX_ &(s), strend, OFF16(p), SIZE16, datumtype)) break;	\
    } else {								\
	Copy(s, OFF16(p), SIZE16, char);				\
	(s) += SIZE16;							\
    }									\
} STMT_END

/* Only to be used inside a loop (see the break) */
#define SHIFT32(utf8, s, strend, p, datumtype) STMT_START {		\
    if (utf8) {								\
	if (!uni_to_bytes(aTHX_ &(s), strend, OFF32(p), SIZE32, datumtype)) break;	\
    } else {								\
	Copy(s, OFF32(p), SIZE32, char);				\
	(s) += SIZE32;							\
    }									\
} STMT_END

#define PUSH16(utf8, cur, p) PUSH_BYTES(utf8, cur, OFF16(p), SIZE16)
#define PUSH32(utf8, cur, p) PUSH_BYTES(utf8, cur, OFF32(p), SIZE32)

/* Only to be used inside a loop (see the break) */
#define SHIFT_VAR(utf8, s, strend, var, datumtype)	\
STMT_START {						\
    if (utf8) {						\
        if (!uni_to_bytes(aTHX_ &s, strend,		\
            (char *) &var, sizeof(var), datumtype)) break;\
    } else {						\
        Copy(s, (char *) &var, sizeof(var), char);	\
        s += sizeof(var);				\
    }							\
} STMT_END

#define PUSH_VAR(utf8, aptr, var)	\
	PUSH_BYTES(utf8, aptr, &(var), sizeof(var))

a91 2
#define FLAG_WAS_UTF8	      0x40
#define FLAG_PARSE_UTF8       0x20	/* Parse as utf8 */
d93 1
a93 1
#define FLAG_DO_UTF8          0x08	/* The underlying string is utf8 */
d104 1
d107 1
a107 1
    SV * const tmpNew = newSVpvs("0000000000");
d118 1
a118 1
    const U32 i = ((*t - '0') << 7) + m;
a141 1
#define TYPE_IS_PACK		0x800
d147 1
a147 1
# define SHRIEKING_ALLOWED_TYPES "sSiIlLxXnNvV@@."
d149 1
a149 1
# define SHRIEKING_ALLOWED_TYPES "sSiIlLxX"
d170 1
a170 1
#else /* PERL_PACK_CAN_BYTEORDER */
a248 5
# elif PTRSIZE == IVSIZE
#  define DO_BO_UNPACK_P(var)	DO_BO_UNPACK_PTR(var, l, IV, void)
#  define DO_BO_PACK_P(var)	DO_BO_PACK_PTR(var, l, IV, void)
#  define DO_BO_UNPACK_PC(var)	DO_BO_UNPACK_PTR(var, l, IV, char)
#  define DO_BO_PACK_PC(var)	DO_BO_PACK_PTR(var, l, IV, char)
d280 1
a280 1
#endif /* PERL_PACK_CAN_BYTEORDER */
d283 1
a283 1
#define PACK_SIZE_UNPREDICTABLE		0x40	/* Not a fixed size element */
d286 10
a297 6

#if TYPE_IS_SHRIEKING != 0x100
   ++++shriek offset should be 256
#endif

typedef U8 packprops_t;
d300 2
a301 8
STATIC const packprops_t packprops[512] = {
    /* normal */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0,
    /* C */ sizeof(unsigned char),
d303 1
a303 1
    /* D */ LONG_DOUBLESIZE,
d305 1
a305 1
    0,
d307 10
a316 10
    0,
    /* F */ NVSIZE,
    0, 0,
    /* I */ sizeof(unsigned int),
    /* J */ UVSIZE,
    0,
    /* L */ SIZE32,
    0,
    /* N */ SIZE32,
    0, 0,
d318 1
a318 1
    /* Q */ sizeof(Uquad_t),
d320 1
a320 1
    0,
d322 19
a340 20
    0,
    /* S */ SIZE16,
    0,
    /* U */ sizeof(char) | PACK_SIZE_UNPREDICTABLE,
    /* V */ SIZE32,
    /* W */ sizeof(unsigned char) | PACK_SIZE_UNPREDICTABLE,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    /* c */ sizeof(char),
    /* d */ sizeof(double),
    0,
    /* f */ sizeof(float),
    0, 0,
    /* i */ sizeof(int),
    /* j */ IVSIZE,
    0,
    /* l */ SIZE32,
    0,
    /* n */ SIZE16,
    0,
    /* p */ sizeof(char *) | PACK_SIZE_CANNOT_CSUM,
d342 1
a342 1
    /* q */ sizeof(Quad_t),
d344 1
a344 1
    0,
d346 11
a356 24
    0,
    /* s */ SIZE16,
    0, 0,
    /* v */ SIZE16,
    /* w */ sizeof(char) | PACK_SIZE_UNPREDICTABLE | PACK_SIZE_CANNOT_CSUM,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    /* shrieking */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    /* I */ sizeof(unsigned int),
    0, 0,
    /* L */ sizeof(unsigned long),
    0,
d358 1
a358 1
    /* N */ SIZE32,
d360 1
a360 1
    0,
d362 3
a364 3
    0, 0, 0, 0,
    /* S */ sizeof(unsigned short),
    0, 0,
d366 1
a366 1
    /* V */ SIZE32,
d368 1
a368 1
    0,
d370 5
a374 6
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0,
    /* i */ sizeof(int),
    0, 0,
    /* l */ sizeof(long),
    0,
d376 1
a376 1
    /* n */ SIZE16,
d378 1
a378 1
    0,
d380 3
a382 3
    0, 0, 0, 0,
    /* s */ sizeof(short),
    0, 0,
d384 1
a384 1
    /* v */ SIZE16,
d386 1
a386 1
    0,
d388 4
a391 9
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0
d395 15
a409 25
STATIC const packprops_t packprops[512] = {
    /* normal */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0,
    /* c */ sizeof(char),
    /* d */ sizeof(double),
    0,
    /* f */ sizeof(float),
    0, 0,
    /* i */ sizeof(int),
    0, 0, 0, 0, 0, 0, 0,
    /* j */ IVSIZE,
    0,
    /* l */ SIZE32,
    0,
    /* n */ SIZE16,
    0,
    /* p */ sizeof(char *) | PACK_SIZE_CANNOT_CSUM,
d411 1
a411 1
    /* q */ sizeof(Quad_t),
d413 1
a413 1
    0,
d415 8
a422 8
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    /* s */ SIZE16,
    0, 0,
    /* v */ SIZE16,
    /* w */ sizeof(char) | PACK_SIZE_UNPREDICTABLE | PACK_SIZE_CANNOT_CSUM,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    /* C */ sizeof(unsigned char),
d424 1
a424 1
    /* D */ LONG_DOUBLESIZE,
d426 1
a426 1
    0,
d428 11
a438 11
    0,
    /* F */ NVSIZE,
    0, 0,
    /* I */ sizeof(unsigned int),
    0, 0, 0, 0, 0, 0, 0,
    /* J */ UVSIZE,
    0,
    /* L */ SIZE32,
    0,
    /* N */ SIZE32,
    0, 0,
d440 1
a440 1
    /* Q */ sizeof(Uquad_t),
d442 1
a442 1
    0,
d444 11
a454 22
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    /* S */ SIZE16,
    0,
    /* U */ sizeof(char) | PACK_SIZE_UNPREDICTABLE,
    /* V */ SIZE32,
    /* W */ sizeof(unsigned char) | PACK_SIZE_UNPREDICTABLE,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    /* shrieking */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    /* i */ sizeof(int),
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    /* l */ sizeof(long),
    0,
d456 1
a456 1
    /* n */ SIZE16,
d458 1
a458 1
    0,
d460 3
a462 3
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    /* s */ sizeof(short),
    0, 0,
d464 1
a464 1
    /* v */ SIZE16,
d466 1
a466 1
    0,
d468 6
a473 7
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0,
    /* I */ sizeof(unsigned int),
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    /* L */ sizeof(unsigned long),
    0,
d475 1
a475 1
    /* N */ SIZE32,
d477 1
a477 1
    0,
d479 3
a481 3
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    /* S */ sizeof(unsigned short),
    0, 0,
d483 1
a483 1
    /* V */ SIZE32,
d485 1
a485 1
    0,
d487 4
a490 2
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0
a493 164
STATIC U8
uni_to_byte(pTHX_ const char **s, const char *end, I32 datumtype)
{
    STRLEN retlen;
    UV val = utf8n_to_uvchr((U8 *) *s, end-*s, &retlen,
			 ckWARN(WARN_UTF8) ? 0 : UTF8_ALLOW_ANY);
    /* We try to process malformed UTF-8 as much as possible (preferrably with
       warnings), but these two mean we make no progress in the string and
       might enter an infinite loop */
    if (retlen == (STRLEN) -1 || retlen == 0)
	Perl_croak(aTHX_ "Malformed UTF-8 string in '%c' format in unpack",
		   (int) TYPE_NO_MODIFIERS(datumtype));
    if (val >= 0x100) {
	if (ckWARN(WARN_UNPACK))
	Perl_warner(aTHX_ packWARN(WARN_UNPACK),
		    "Character in '%c' format wrapped in unpack",
		    (int) TYPE_NO_MODIFIERS(datumtype));
	val &= 0xff;
    }
    *s += retlen;
    return (U8)val;
}

#define SHIFT_BYTE(utf8, s, strend, datumtype) ((utf8) ? \
	uni_to_byte(aTHX_ &(s), (strend), (datumtype)) : \
	*(U8 *)(s)++)

STATIC bool
uni_to_bytes(pTHX_ const char **s, const char *end, const char *buf, int buf_len, I32 datumtype)
{
    UV val;
    STRLEN retlen;
    const char *from = *s;
    int bad = 0;
    const U32 flags = ckWARN(WARN_UTF8) ?
	UTF8_CHECK_ONLY : (UTF8_CHECK_ONLY | UTF8_ALLOW_ANY);
    for (;buf_len > 0; buf_len--) {
	if (from >= end) return FALSE;
	val = utf8n_to_uvchr((U8 *) from, end-from, &retlen, flags);
	if (retlen == (STRLEN) -1 || retlen == 0) {
	    from += UTF8SKIP(from);
	    bad |= 1;
	} else from += retlen;
	if (val >= 0x100) {
	    bad |= 2;
	    val &= 0xff;
	}
	*(U8 *)buf++ = (U8)val;
    }
    /* We have enough characters for the buffer. Did we have problems ? */
    if (bad) {
	if (bad & 1) {
	    /* Rewalk the string fragment while warning */
	    const char *ptr;
	    const int flags = ckWARN(WARN_UTF8) ? 0 : UTF8_ALLOW_ANY;
	    for (ptr = *s; ptr < from; ptr += UTF8SKIP(ptr)) {
		if (ptr >= end) break;
		utf8n_to_uvuni((U8 *) ptr, end-ptr, &retlen, flags);
	    }
	    if (from > end) from = end;
	}
	if ((bad & 2) && ckWARN(WARN_UNPACK))
	    Perl_warner(aTHX_ packWARN(datumtype & TYPE_IS_PACK ?
				       WARN_PACK : WARN_UNPACK),
			"Character(s) in '%c' format wrapped in %s",
			(int) TYPE_NO_MODIFIERS(datumtype),
			datumtype & TYPE_IS_PACK ? "pack" : "unpack");
    }
    *s = from;
    return TRUE;
}

STATIC bool
next_uni_uu(pTHX_ const char **s, const char *end, I32 *out)
{
    dVAR;
    STRLEN retlen;
    const UV val = utf8n_to_uvchr((U8 *) *s, end-*s, &retlen, UTF8_CHECK_ONLY);
    if (val >= 0x100 || !ISUUCHAR(val) ||
	retlen == (STRLEN) -1 || retlen == 0) {
	*out = 0;
	return FALSE;
    }
    *out = PL_uudmap[val] & 077;
    *s += retlen;
    return TRUE;
}

STATIC char *
S_bytes_to_uni(const U8 *start, STRLEN len, char *dest) {
    const U8 * const end = start + len;

    while (start < end) {
	const UV uv = NATIVE_TO_ASCII(*start);
	if (UNI_IS_INVARIANT(uv))
	    *dest++ = (char)(U8)UTF_TO_NATIVE(uv);
	else {
	    *dest++ = (char)(U8)UTF8_EIGHT_BIT_HI(uv);
	    *dest++ = (char)(U8)UTF8_EIGHT_BIT_LO(uv);
	}
	start++;
    }
    return dest;
}

#define PUSH_BYTES(utf8, cur, buf, len)				\
STMT_START {							\
    if (utf8)							\
	(cur) = bytes_to_uni((U8 *) buf, len, (cur));		\
    else {							\
	Copy(buf, cur, len, char);				\
	(cur) += (len);						\
    }								\
} STMT_END

#define GROWING(utf8, cat, start, cur, in_len)	\
STMT_START {					\
    STRLEN glen = (in_len);			\
    if (utf8) glen *= UTF8_EXPAND;		\
    if ((cur) + glen >= (start) + SvLEN(cat)) {	\
	(start) = sv_exp_grow(cat, glen);	\
	(cur) = (start) + SvCUR(cat);		\
    }						\
} STMT_END

#define PUSH_GROWING_BYTES(utf8, cat, start, cur, buf, in_len) \
STMT_START {					\
    const STRLEN glen = (in_len);		\
    STRLEN gl = glen;				\
    if (utf8) gl *= UTF8_EXPAND;		\
    if ((cur) + gl >= (start) + SvLEN(cat)) {	\
        *cur = '\0';				\
        SvCUR_set((cat), (cur) - (start));	\
	(start) = sv_exp_grow(cat, gl);		\
	(cur) = (start) + SvCUR(cat);		\
    }						\
    PUSH_BYTES(utf8, cur, buf, glen);		\
} STMT_END

#define PUSH_BYTE(utf8, s, byte)		\
STMT_START {					\
    if (utf8) {					\
	const U8 au8 = (byte);			\
	(s) = bytes_to_uni(&au8, 1, (s));	\
    } else *(U8 *)(s)++ = (byte);		\
} STMT_END

/* Only to be used inside a loop (see the break) */
#define NEXT_UNI_VAL(val, cur, str, end, utf8_flags)		\
STMT_START {							\
    STRLEN retlen;						\
    if (str >= end) break;					\
    val = utf8n_to_uvchr((U8 *) str, end-str, &retlen, utf8_flags);	\
    if (retlen == (STRLEN) -1 || retlen == 0) {			\
	*cur = '\0';						\
	Perl_croak(aTHX_ "Malformed UTF-8 string in pack");	\
    }								\
    str += retlen;						\
} STMT_END

static const char *_action( const tempsym_t* symptr )
{
    return (const char *)(( symptr->flags & FLAG_PACK ) ? "pack" : "unpack");
}
d497 1
a497 1
S_measure_struct(pTHX_ tempsym_t* symptr)
d499 5
a503 1
    I32 total = 0;
d506 11
a516 5
	I32 len;
	int size;

        switch (symptr->howlen) {
	  case e_star:
d518 1
a518 1
                        _action( symptr ) );
a519 4
	  default:
	    /* e_no_len and e_number */
	    len = symptr->length;
	    break;
d522 5
a526 1
	size = packprops[TYPE_NO_ENDIANNESS(symptr->code)] & PACK_SIZE_MASK;
a527 1
            int star;
d533 1
a533 5
                           _action( symptr ) );
#ifdef PERL_PACK_CAN_SHRIEKSIGN
	    case '.' | TYPE_IS_SHRIEKING:
	    case '@@' | TYPE_IS_SHRIEKING:
#endif
a534 1
	    case '.':
d540 2
a541 2
			   (int) TYPE_NO_MODIFIERS(symptr->code),
                           _action( symptr ) );
d546 12
a557 12
	    {
		tempsym_t savsym = *symptr;
		symptr->patptr = savsym.grpbeg;
		symptr->patend = savsym.grpend;
		/* XXXX Theoretically, we need to measure many times at
		   different positions, since the subexpression may contain
		   alignment commands, but be not of aligned length.
		   Need to detect this and croak().  */
		size = measure_struct(symptr);
		*symptr = savsym;
		break;
	    }
d568 2
a569 1
                    Perl_croak(aTHX_ "'X' outside of string in %s", _action( symptr ) );
d584 2
d618 1
a618 1
	const char c = *patptr++;
d642 1
a642 1
 */
d660 1
a660 1
S_next_symbol(pTHX_ tempsym_t* symptr )
d662 2
a663 2
  const char* patptr = symptr->patptr;
  const char* const patend = symptr->patend;
d677 1
a677 1
      /* We should have found a template code */
d685 2
a686 1
	 	      "Invalid type ',' in %s", _action( symptr ) );
d690 1
a690 1

d692 1
a692 1
      if (code == '(') {
d695 4
a698 3
                        _action( symptr ) );
        symptr->grpbeg = patptr;
        patptr = 1 + ( symptr->grpend = group_end(patptr, patend, ')') );
d701 1
a701 1
                        _action( symptr ) );
d728 1
a728 1
#endif /* PERL_PACK_CAN_BYTEORDER */
d740 1
a740 1
                        allowed, _action( symptr ) );
d744 2
a745 1
                     (int) TYPE_NO_MODIFIERS(code), _action( symptr ) );
d749 1
a749 1
                     *patptr, _action( symptr ) );
d751 2
a752 1
        if ((code & modifier) && ckWARN(WARN_UNPACK)) {
d756 1
a756 1
                        _action( symptr ) );
d766 1
a766 1
      /* look for count and/or / */
d777 1
a777 1
          const char* lenptr = ++patptr;
d785 1
a785 1
                            _action( symptr ) );
d788 2
a789 2
            symptr->patend = patptr-1;
            symptr->patptr = lenptr;
d815 1
a815 1
                            _action( symptr ) );
d827 1
a827 1
      symptr->patptr = patptr;
d831 1
a831 1
  symptr->patptr = patptr;
d836 9
a844 10
   There is no way to cleanly handle the case where we should process the
   string per byte in its upgraded form while it's really in downgraded form
   (e.g. estimates like strend-s as an upper bound for the number of
   characters left wouldn't work). So if we foresee the need of this
   (pattern starts with U or contains U0), we want to work on the encoded
   version of the string. Users are advised to upgrade their pack string
   themselves if they need to do a lot of unpacks like this on it
*/
STATIC bool
need_utf8(const char *pat, const char *patend)
d846 4
a849 13
    bool first = TRUE;
    while (pat < patend) {
	if (pat[0] == '#') {
	    pat++;
	    pat = (const char *) memchr(pat, '\n', patend-pat);
	    if (!pat) return FALSE;
	} else if (pat[0] == 'U') {
	    if (first || pat[1] == '0') return TRUE;
	} else first = FALSE;
	pat++;
    }
    return FALSE;
}
d851 1
a851 10
STATIC char
first_symbol(const char *pat, const char *patend) {
    while (pat < patend) {
	if (pat[0] != '#') return pat[0];
	pat++;
	pat = (const char *) memchr(pat, '\n', patend-pat);
	if (!pat) return 0;
	pat++;
    }
    return 0;
d864 1
a864 1
Perl_unpackstring(pTHX_ const char *pat, const char *patend, const char *s, const char *strend, U32 flags)
d866 4
a869 17
    tempsym_t sym;

    if (flags & FLAG_DO_UTF8) flags |= FLAG_WAS_UTF8;
    else if (need_utf8(pat, patend)) {
	/* We probably should try to avoid this in case a scalar context call
	   wouldn't get to the "U0" */
	STRLEN len = strend - s;
	s = (char *) bytes_to_utf8((U8 *) s, &len);
	SAVEFREEPV(s);
	strend = s + len;
	flags |= FLAG_DO_UTF8;
    }

    if (first_symbol(pat, patend) != 'U' && (flags & FLAG_DO_UTF8))
	flags |= FLAG_PARSE_UTF8;

    TEMPSYM_INIT(&sym, pat, patend, flags);
d874 3
a876 2
STATIC I32
S_unpack_rec(pTHX_ tempsym_t* symptr, const char *s, const char *strbeg, const char *strend, const char **new_s )
d878 5
a882 1
    dVAR; dSP;
d884 1
a884 1
    const I32 start_sp_offset = SP - PL_stack_base;
d887 29
d919 2
a920 1
    const int bits_in_uv = CHAR_BIT * sizeof(cuv);
d923 1
a923 3
    const bool unpack_only_one = (symptr->flags & FLAG_UNPACK_ONLY_ONE) != 0;
    bool utf8 = (symptr->flags & FLAG_PARSE_UTF8) ? 1 : 0;
    symptr->strbeg = s - strbeg;
d926 1
a926 3
	packprops_t props;
	I32 len;
        I32 datumtype = symptr->code;
d928 1
a928 1
	   / is implemented by unpacking the count, then popping it from the
d935 4
a938 3
        switch (howlen = symptr->howlen) {
	  case e_star:
	    len = strend - strbeg;	/* long enough */
d940 2
a941 3
	  default:
	    /* e_no_len and e_number */
	    len = symptr->length;
d948 24
d973 8
a980 12
	props = packprops[TYPE_NO_ENDIANNESS(datumtype)];
	if (props) {
	    /* props nonzero means we can process this letter. */
            const long size = props & PACK_SIZE_MASK;
            const long howmany = (strend - s) / size;
	    if (len > howmany)
		len = howmany;

	    if (!checksum || (props & PACK_SIZE_CANNOT_CSUM)) {
		if (len && unpack_only_one) len = 1;
		EXTEND(SP, len);
		EXTEND_MORTAL(len);
a982 1

d997 1
d999 1
a999 1
            const U32 group_modifiers = TYPE_MODIFIERS(datumtype & ~symptr->flags);
a1001 1
	    symptr->previous = &savsym;
d1006 6
a1011 4
		if (utf8) symptr->flags |=  FLAG_PARSE_UTF8;
		else      symptr->flags &= ~FLAG_PARSE_UTF8;
 	        unpack_rec(symptr, s, strbeg, strend, &s);
                if (s == strend && savsym.howlen == e_star)
d1015 3
a1017 1
            savsym.flags = symptr->flags & ~group_modifiers;
a1020 28
#ifdef PERL_PACK_CAN_SHRIEKSIGN
	case '.' | TYPE_IS_SHRIEKING:
#endif
	case '.': {
	    const char *from;
	    SV *sv;
#ifdef PERL_PACK_CAN_SHRIEKSIGN
	    const bool u8 = utf8 && !(datumtype & TYPE_IS_SHRIEKING);
#else /* PERL_PACK_CAN_SHRIEKSIGN */
	    const bool u8 = utf8;
#endif
	    if (howlen == e_star) from = strbeg;
	    else if (len <= 0) from = s;
	    else {
		tempsym_t *group = symptr;

		while (--len && group) group = group->previous;
		from = group ? strbeg + group->strbeg : strbeg;
	    }
	    sv = from <= s ?
		newSVuv(  u8 ? (UV) utf8_length((const U8*)from, (const U8*)s) : (UV) (s-from)) :
		newSViv(-(u8 ? (IV) utf8_length((const U8*)s, (const U8*)from) : (IV) (from-s)));
	    XPUSHs(sv_2mortal(sv));
	    break;
	}
#ifdef PERL_PACK_CAN_SHRIEKSIGN
	case '@@' | TYPE_IS_SHRIEKING:
#endif
d1022 3
a1024 20
	    s = strbeg + symptr->strbeg;
#ifdef PERL_PACK_CAN_SHRIEKSIGN
	    if (utf8  && !(datumtype & TYPE_IS_SHRIEKING))
#else /* PERL_PACK_CAN_SHRIEKSIGN */
	    if (utf8)
#endif
	    {
		while (len > 0) {
		    if (s >= strend)
			Perl_croak(aTHX_ "'@@' outside of string in unpack");
		    s += UTF8SKIP(s);
		    len--;
		}
		if (s > strend)
		    Perl_croak(aTHX_ "'@@' outside of string with malformed UTF-8 in unpack");
	    } else {
		if (strend-s < len)
		    Perl_croak(aTHX_ "'@@' outside of string in unpack");
		s += len;
	    }
d1029 1
a1029 17
	    if (utf8) {
		const char *hop, *last;
		I32 l = len;
		hop = last = strbeg;
		while (hop < s) {
		    hop += UTF8SKIP(hop);
		    if (--l == 0) {
			last = hop;
			l = len;
		    }
		}
		if (last > s)
		    Perl_croak(aTHX_ "Malformed UTF-8 string in unpack");
		s = last;
		break;
	    }
	    len = (s - strbeg) % len;
d1032 3
a1034 15
	    if (utf8) {
		while (len > 0) {
		    if (s <= strbeg)
			Perl_croak(aTHX_ "'X' outside of string in unpack");
		    while (--s, UTF8_IS_CONTINUATION(*s)) {
			if (s <= strbeg)
			    Perl_croak(aTHX_ "'X' outside of string in unpack");
		    }
		    len--;
		}
	    } else {
		if (len > s - strbeg)
		    Perl_croak(aTHX_ "'X' outside of string in unpack" );
		s -= len;
	    }
d1036 1
a1036 2
 	case 'x' | TYPE_IS_SHRIEKING: {
            I32 ai32;
d1039 5
a1043 5
	    if (utf8) ai32 = utf8_length((U8 *) strbeg, (U8 *) s) % len;
	    else      ai32 = (s - strbeg)                         % len;
	    if (ai32 == 0) break;
	    len -= ai32;
            }
d1046 3
a1048 12
	    if (utf8) {
		while (len>0) {
		    if (s >= strend)
			Perl_croak(aTHX_ "'x' outside of string in unpack");
		    s += UTF8SKIP(s);
		    len--;
		}
	    } else {
		if (len > strend - s)
		    Perl_croak(aTHX_ "'x' outside of string in unpack");
		s += len;
	    }
d1056 19
a1074 14
	    if (checksum) {
		/* Preliminary length estimate is assumed done in 'W' */
		if (len > strend - s) len = strend - s;
		goto W_checksum;
	    }
	    if (utf8) {
		I32 l;
		const char *hop;
		for (l=len, hop=s; l>0; l--, hop += UTF8SKIP(hop)) {
		    if (hop >= strend) {
			if (hop > strend)
			    Perl_croak(aTHX_ "Malformed UTF-8 string in unpack");
			break;
		    }
d1076 2
a1077 38
		if (hop > strend)
		    Perl_croak(aTHX_ "Malformed UTF-8 string in unpack");
		len = hop - s;
	    } else if (len > strend - s)
		len = strend - s;

	    if (datumtype == 'Z') {
		/* 'Z' strips stuff after first null */
		const char *ptr, *end;
		end = s + len;
		for (ptr = s; ptr < end; ptr++) if (*ptr == 0) break;
		sv = newSVpvn(s, ptr-s);
		if (howlen == e_star) /* exact for 'Z*' */
		    len = ptr-s + (ptr != strend ? 1 : 0);
	    } else if (datumtype == 'A') {
		/* 'A' strips both nulls and spaces */
		const char *ptr;
		if (utf8 && (symptr->flags & FLAG_WAS_UTF8)) {
		    for (ptr = s+len-1; ptr >= s; ptr--)
			if (*ptr != 0 && !UTF8_IS_CONTINUATION(*ptr) &&
			    !is_utf8_space((U8 *) ptr)) break;
		    if (ptr >= s) ptr += UTF8SKIP(ptr);
		    else ptr++;
		    if (ptr > s+len)
			Perl_croak(aTHX_ "Malformed UTF-8 string in unpack");
		} else {
		    for (ptr = s+len-1; ptr >= s; ptr--)
			if (*ptr != 0 && !isSPACE(*ptr)) break;
		    ptr++;
		}
		sv = newSVpvn(s, ptr-s);
	    } else sv = newSVpvn(s, len);

	    if (utf8) {
		SvUTF8_on(sv);
		/* Undo any upgrade done due to need_utf8() */
		if (!(symptr->flags & FLAG_WAS_UTF8))
		    sv_utf8_downgrade(sv, 0);
d1079 1
a1080 1
	    s += len;
d1083 1
a1083 2
	case 'b': {
	    char *str;
a1087 1
		    int bits;
d1100 7
a1106 14
		if (utf8)
		    while (len >= 8 && s < strend) {
			cuv += PL_bitcount[uni_to_byte(aTHX_ &s, strend, datumtype)];
			len -= 8;
		    }
		else
		    while (len >= 8) {
			cuv += PL_bitcount[*(U8 *)s++];
			len -= 8;
		    }
		if (len && s < strend) {
		    U8 bits;
		    bits = SHIFT_BYTE(utf8, s, strend, datumtype);
		    if (datumtype == 'b')
d1111 2
a1112 1
		    else
d1114 1
a1114 1
			    if (bits & 0x80) cuv++;
d1117 1
d1121 2
a1122 2

	    sv = sv_2mortal(newSV(len ? len : 1));
d1126 7
a1132 9
		U8 bits = 0;
		const I32 ai32 = len;
		for (len = 0; len < ai32; len++) {
		    if (len & 7) bits >>= 1;
		    else if (utf8) {
			if (s >= strend) break;
			bits = uni_to_byte(aTHX_ &s, strend, datumtype);
		    } else bits = *(U8 *) s++;
		    *str++ = bits & 1 ? '1' : '0';
d1134 9
a1142 10
	    } else {
		U8 bits = 0;
		const I32 ai32 = len;
		for (len = 0; len < ai32; len++) {
		    if (len & 7) bits <<= 1;
		    else if (utf8) {
			if (s >= strend) break;
			bits = uni_to_byte(aTHX_ &s, strend, datumtype);
		    } else bits = *(U8 *) s++;
		    *str++ = bits & 0x80 ? '1' : '0';
d1146 1
a1146 2
	    SvCUR_set(sv, str - SvPVX_const(sv));
	    XPUSHs(sv);
a1147 1
	}
d1149 1
a1149 3
	case 'h': {
	    char *str;
	    /* Preliminary length estimate, acceptable for utf8 too */
d1152 2
a1153 1
	    sv = sv_2mortal(newSV(len ? len : 1));
d1157 6
a1162 8
		U8 bits = 0;
		I32 ai32 = len;
		for (len = 0; len < ai32; len++) {
		    if (len & 1) bits >>= 4;
		    else if (utf8) {
			if (s >= strend) break;
			bits = uni_to_byte(aTHX_ &s, strend, datumtype);
		    } else bits = * (U8 *) s++;
d1165 8
a1172 9
	    } else {
		U8 bits = 0;
		const I32 ai32 = len;
		for (len = 0; len < ai32; len++) {
		    if (len & 1) bits <<= 4;
		    else if (utf8) {
			if (s >= strend) break;
			bits = uni_to_byte(aTHX_ &s, strend, datumtype);
		    } else bits = *(U8 *) s++;
d1177 1
a1177 2
	    SvCUR_set(sv, str - SvPVX_const(sv));
	    XPUSHs(sv);
a1178 9
	}
	case 'C':
            if (len == 0) {
                if (explicit_length)
		    /* Switch to "character" mode */
		    utf8 = (symptr->flags & FLAG_DO_UTF8) ? 1 : 0;
		break;
	    }
	    /* FALL THROUGH */
d1180 3
a1182 14
	    while (len-- > 0 && s < strend) {
		int aint;
		if (utf8)
		  {
		    STRLEN retlen;
		    aint = utf8n_to_uvchr((U8 *) s, strend-s, &retlen,
				 ckWARN(WARN_UTF8) ? 0 : UTF8_ALLOW_ANY);
		    if (retlen == (STRLEN) -1 || retlen == 0)
			Perl_croak(aTHX_ "Malformed UTF-8 string in unpack");
		    s += retlen;
		  }
		else
		  aint = *(U8 *)(s)++;
		if (aint >= 128 && datumtype != 'C')	/* fake up signed chars */
d1184 1
a1184 1
		if (!checksum)
d1186 1
d1193 13
a1205 14
	case 'W':
	  W_checksum:
	    if (utf8) {
		while (len-- > 0 && s < strend) {
		    STRLEN retlen;
		    const UV val = utf8n_to_uvchr((U8 *) s, strend-s, &retlen,
					 ckWARN(WARN_UTF8) ? 0 : UTF8_ALLOW_ANY);
		    if (retlen == (STRLEN) -1 || retlen == 0)
			Perl_croak(aTHX_ "Malformed UTF-8 string in unpack");
		    s += retlen;
		    if (!checksum)
			PUSHs(sv_2mortal(newSVuv((UV) val)));
		    else if (checksum > bits_in_uv)
			cdouble += (NV) val;
d1207 1
a1207 1
			cuv += val;
d1209 2
a1210 1
	    } else if (!checksum)
d1212 3
a1214 2
		    const U8 ch = *(U8 *) s++;
		    PUSHs(sv_2mortal(newSVuv((UV) ch)));
a1215 4
	    else if (checksum > bits_in_uv)
		while (len-- > 0) cdouble += (NV) *(U8 *) s++;
	    else
		while (len-- > 0) cuv += *(U8 *) s++;
d1219 2
a1220 7
                if (explicit_length) {
		    /* Switch to "bytes in UTF-8" mode */
		    if (symptr->flags & FLAG_DO_UTF8) utf8 = 0;
		    else
			/* Should be impossible due to the need_utf8() test */
			Perl_croak(aTHX_ "U0 mode on a byte string");
		}
d1223 2
a1224 6
	    if (len > strend - s) len = strend - s;
	    if (!checksum) {
		if (len && unpack_only_one) len = 1;
		EXTEND(SP, len);
		EXTEND_MORTAL(len);
	    }
d1226 6
a1231 21
		STRLEN retlen;
		UV auv;
		if (utf8) {
		    U8 result[UTF8_MAXLEN];
		    const char *ptr = s;
		    STRLEN len;
		    /* Bug: warns about bad utf8 even if we are short on bytes
		       and will break out of the loop */
		    if (!uni_to_bytes(aTHX_ &ptr, strend, (char *) result, 1,
				      'U'))
			break;
		    len = UTF8SKIP(result);
		    if (!uni_to_bytes(aTHX_ &ptr, strend,
				      (char *) &result[1], len-1, 'U')) break;
		    auv = utf8n_to_uvuni(result, len, &retlen, ckWARN(WARN_UTF8) ? 0 : UTF8_ALLOW_ANYUV);
		    s = ptr;
		} else {
		    auv = utf8n_to_uvuni((U8*)s, strend - s, &retlen, ckWARN(WARN_UTF8) ? 0 : UTF8_ALLOW_ANYUV);
		    if (retlen == (STRLEN) -1 || retlen == 0)
			Perl_croak(aTHX_ "Malformed UTF-8 string in unpack");
		    s += retlen;
a1232 2
		if (!checksum)
		    PUSHs(sv_2mortal(newSVuv((UV) auv)));
d1234 1
a1234 1
		    cdouble += (NV) auv;
d1236 1
a1236 1
		    cuv += auv;
d1242 1
a1242 2
		short ashort;
		SHIFT_VAR(utf8, s, strend, ashort, datumtype);
d1244 2
a1245 1
		if (!checksum)
d1247 1
d1259 1
a1259 6
		I16 ai16;

#if U16SIZE > SIZE16
		ai16 = 0;
#endif
		SHIFT16(utf8, s, strend, &ai16, datumtype);
d1265 2
a1266 1
		if (!checksum)
d1268 1
d1278 1
a1278 2
		unsigned short aushort;
		SHIFT_VAR(utf8, s, strend, aushort, datumtype);
d1280 4
a1283 2
		if (!checksum)
		    PUSHs(sv_2mortal(newSVuv((UV) aushort)));
d1297 1
a1297 5
		U16 au16;
#if U16SIZE > SIZE16
		au16 = 0;
#endif
		SHIFT16(utf8, s, strend, &au16, datumtype);
d1299 1
d1308 3
a1310 2
		if (!checksum)
		    PUSHs(sv_2mortal(newSVuv((UV)au16)));
d1312 1
a1312 1
		    cdouble += (NV) au16;
d1321 3
a1323 6
		I16 ai16;
# if U16SIZE > SIZE16
		ai16 = 0;
# endif
		SHIFT16(utf8, s, strend, &ai16, datumtype);
# ifdef HAS_NTOHS
d1325 3
a1327 3
		    ai16 = (I16) PerlSock_ntohs((U16) ai16);
# endif /* HAS_NTOHS */
# ifdef HAS_VTOHS
d1329 3
a1331 3
		    ai16 = (I16) vtohs((U16) ai16);
# endif /* HAS_VTOHS */
		if (!checksum)
d1333 1
d1335 1
a1335 1
		    cdouble += (NV) ai16;
d1340 1
a1340 1
#endif /* PERL_PACK_CAN_SHRIEKSIGN */
d1344 1
a1344 2
		int aint;
		SHIFT_VAR(utf8, s, strend, aint, datumtype);
d1346 2
a1347 1
		if (!checksum)
d1349 1
d1359 1
a1359 2
		unsigned int auint;
		SHIFT_VAR(utf8, s, strend, auint, datumtype);
d1361 2
a1362 1
		if (!checksum)
d1364 1
d1373 1
a1373 2
		IV aiv;
		SHIFT_VAR(utf8, s, strend, aiv, datumtype);
a1379 2
#else
		Perl_croak(aTHX_ "'j' not supported on this platform");
d1381 2
a1382 1
		if (!checksum)
d1384 1
d1393 2
a1394 3
		UV auv;
		SHIFT_VAR(utf8, s, strend, auv, datumtype);
#if IVSIZE == INTSIZE
d1396 1
a1396 1
#elif IVSIZE == LONGSIZE
d1398 1
a1398 1
#elif defined(HAS_QUAD) && IVSIZE == U64SIZE
a1399 2
#else
		Perl_croak(aTHX_ "'J' not supported on this platform");
d1401 2
a1402 1
		if (!checksum)
d1404 1
d1414 1
a1414 2
		long along;
		SHIFT_VAR(utf8, s, strend, along, datumtype);
d1416 2
a1417 1
		if (!checksum)
d1419 1
d1431 1
a1431 5
		I32 ai32;
#if U32SIZE > SIZE32
		ai32 = 0;
#endif
		SHIFT32(utf8, s, strend, &ai32, datumtype);
d1434 2
a1435 1
		if (ai32 > 2147483647) ai32 -= 4294967296;
d1437 2
a1438 1
		if (!checksum)
d1440 1
d1450 1
a1450 2
		unsigned long aulong;
		SHIFT_VAR(utf8, s, strend, aulong, datumtype);
d1452 2
a1453 1
		if (!checksum)
d1455 1
d1469 1
a1469 5
		U32 au32;
#if U32SIZE > SIZE32
		au32 = 0;
#endif
		SHIFT32(utf8, s, strend, &au32, datumtype);
d1471 1
d1480 7
a1486 6
		if (!checksum)
		    PUSHs(sv_2mortal(newSVuv((UV)au32)));
		else if (checksum > bits_in_uv)
		    cdouble += (NV)au32;
		else
		    cuv += au32;
d1493 3
a1495 6
		I32 ai32;
# if U32SIZE > SIZE32
		ai32 = 0;
# endif
		SHIFT32(utf8, s, strend, &ai32, datumtype);
# ifdef HAS_NTOHL
d1498 2
a1499 2
# endif
# ifdef HAS_VTOHL
d1502 2
a1503 2
# endif
		if (!checksum)
d1505 1
d1512 1
a1512 1
#endif /* PERL_PACK_CAN_SHRIEKSIGN */
d1515 2
a1516 2
		const char *aptr;
		SHIFT_VAR(utf8, s, strend, aptr, datumtype);
d1518 1
d1527 3
a1529 5

		while (len > 0 && s < strend) {
		    U8 ch;
		    ch = SHIFT_BYTE(utf8, s, strend, datumtype);
		    auv = (auv << 7) | (ch & 0x7f);
d1531 1
a1531 1
		    if (ch < 0x80) {
a1535 1
			continue;
d1537 1
a1537 1
		    if (++bytes >= sizeof(UV)) {	/* promote to string */
d1540 1
a1540 1
			sv = Perl_newSVpvf(aTHX_ "%.*"UVuf, (int)TYPE_DIGITS(UV), auv);
d1542 2
a1543 3
			    ch = SHIFT_BYTE(utf8, s, strend, datumtype);
			    sv = mul128(sv, (U8)(ch & 0x7f));
			    if (!(ch & 0x80)) {
d1551 1
a1551 1
			sv_chop(sv, t);
d1565 4
a1568 3
	    if (s + sizeof(char*) <= strend) {
		char *aptr;
		SHIFT_VAR(utf8, s, strend, aptr, datumtype);
d1570 1
a1570 2
		/* newSVpvn generates undef if aptr is NULL */
		PUSHs(sv_2mortal(newSVpvn(aptr, len)));
d1572 2
d1578 2
a1579 2
		Quad_t aquad;
		SHIFT_VAR(utf8, s, strend, aquad, datumtype);
d1581 3
a1583 2
		if (!checksum)
                    PUSHs(sv_2mortal(aquad >= IV_MIN && aquad <= IV_MAX ?
d1585 1
d1594 2
a1595 2
		Uquad_t auquad;
		SHIFT_VAR(utf8, s, strend, auquad, datumtype);
d1597 5
a1601 3
		if (!checksum)
		    PUSHs(sv_2mortal(auquad <= UV_MAX ?
				     newSVuv((UV)auquad):newSVnv((NV)auquad)));
d1608 1
a1608 1
#endif /* HAS_QUAD */
d1612 1
a1612 2
		float afloat;
		SHIFT_VAR(utf8, s, strend, afloat, datumtype);
d1614 2
a1615 1
		if (!checksum)
d1617 2
a1618 1
		else
d1620 1
d1625 1
a1625 2
		double adouble;
		SHIFT_VAR(utf8, s, strend, adouble, datumtype);
d1627 2
a1628 1
		if (!checksum)
d1630 2
a1631 1
		else
d1633 1
d1638 1
a1638 2
		NV anv;
		SHIFT_VAR(utf8, s, strend, anv, datumtype);
d1640 2
a1641 1
		if (!checksum)
d1643 2
a1644 1
		else
d1646 1
d1652 1
a1652 2
		long double aldouble;
		SHIFT_VAR(utf8, s, strend, aldouble, datumtype);
d1654 2
a1655 1
		if (!checksum)
d1657 3
a1659 2
		else
		    cdouble += aldouble;
d1664 55
a1718 68
	    {
                const STRLEN l = (STRLEN) (strend - s) * 3 / 4;
		sv = sv_2mortal(newSV(l));
		if (l) SvPOK_on(sv);
	    }
	    if (utf8) {
		while (next_uni_uu(aTHX_ &s, strend, &len)) {
		    I32 a, b, c, d;
		    char hunk[3];

		    while (len > 0) {
			next_uni_uu(aTHX_ &s, strend, &a);
			next_uni_uu(aTHX_ &s, strend, &b);
			next_uni_uu(aTHX_ &s, strend, &c);
			next_uni_uu(aTHX_ &s, strend, &d);
			hunk[0] = (char)((a << 2) | (b >> 4));
			hunk[1] = (char)((b << 4) | (c >> 2));
			hunk[2] = (char)((c << 6) | d);
			sv_catpvn(sv, hunk, (len > 3) ? 3 : len);
			len -= 3;
		    }
		    if (s < strend) {
			if (*s == '\n') {
                            s++;
                        }
			else {
			    /* possible checksum byte */
			    const char *skip = s+UTF8SKIP(s);
			    if (skip < strend && *skip == '\n')
                                s = skip+1;
			}
		    }
		}
	    } else {
		while (s < strend && *s > ' ' && ISUUCHAR(*s)) {
		    I32 a, b, c, d;
		    char hunk[3];

		    len = PL_uudmap[*(U8*)s++] & 077;
		    while (len > 0) {
			if (s < strend && ISUUCHAR(*s))
			    a = PL_uudmap[*(U8*)s++] & 077;
			else
			    a = 0;
			if (s < strend && ISUUCHAR(*s))
			    b = PL_uudmap[*(U8*)s++] & 077;
			else
			    b = 0;
			if (s < strend && ISUUCHAR(*s))
			    c = PL_uudmap[*(U8*)s++] & 077;
			else
			    c = 0;
			if (s < strend && ISUUCHAR(*s))
			    d = PL_uudmap[*(U8*)s++] & 077;
			else
			    d = 0;
			hunk[0] = (char)((a << 2) | (b >> 4));
			hunk[1] = (char)((b << 4) | (c >> 2));
			hunk[2] = (char)((c << 6) | d);
			sv_catpvn(sv, hunk, (len > 3) ? 3 : len);
			len -= 3;
		    }
		    if (*s == '\n')
			s++;
		    else	/* possible checksum byte */
			if (s + 1 < strend && s[1] == '\n')
			    s += 2;
		}
d1720 1
a1720 1
	    XPUSHs(sv);
d1727 2
a1728 2
	       strchr("cCsSiIlLnNUWvVqQjJ", TYPE_NO_MODIFIERS(datumtype))) ) {
		NV trouble, anv;
d1730 1
a1730 1
                anv = (NV) (1 << (checksum & 15));
d1733 1
a1733 1
		    anv *= 65536.0;
d1736 2
a1737 2
		    cdouble += anv;
		cdouble = Perl_modf(cdouble / anv, &trouble) * anv;
d1750 1
a1750 1

a1782 1
    dVAR;
d1788 9
a1796 2
    const char *pat = SvPV_const(left,  llen);
    const char *s   = SvPV_const(right, rlen);
d1799 1
a1799 1
    I32 cnt;
d1802 1
a1802 1
    cnt = unpackstring(pat, patend, s, strend,
d1804 1
a1804 1
		     | (DO_UTF8(right) ? FLAG_DO_UTF8 : 0));
d1812 2
a1813 2
STATIC U8 *
doencodes(U8 *h, const char *s, I32 len)
d1815 5
a1819 1
    *h++ = PL_uuemap[len];
d1821 5
a1825 4
	*h++ = PL_uuemap[(077 & (s[0] >> 2))];
	*h++ = PL_uuemap[(077 & (((s[0] << 4) & 060) | ((s[1] >> 4) & 017)))];
	*h++ = PL_uuemap[(077 & (((s[1] << 2) & 074) | ((s[2] >> 6) & 03)))];
	*h++ = PL_uuemap[(077 & (s[2] & 077))];
d1830 6
a1835 5
        const char r = (len > 1 ? s[1] : '\0');
	*h++ = PL_uuemap[(077 & (s[0] >> 2))];
	*h++ = PL_uuemap[(077 & (((s[0] << 4) & 060) | ((r >> 4) & 017)))];
	*h++ = PL_uuemap[(077 & ((r << 2) & 074))];
	*h++ = PL_uuemap[0];
d1837 1
a1837 2
    *h++ = '\n';
    return h;
d1843 5
a1847 5
  SV *result = newSVpvn(s, l);
  char *const result_c = SvPV_nolen(result);	/* convenience */
  char *out = result_c;
  bool skip = 1;
  bool ignore = 0;
d1892 15
a1906 14
    STRLEN len;
    char * const s = SvPV(pnum, len);
    char *t = s;
    int m = 0;

    *done = 1;
    while (*t) {
	const int i = m * 10 + (*t - '0');
	const int r = (i >> 7); /* r < 10 */
	m = i & 0x7F;
	if (r) {
	    *done = 0;
	}
	*(t++) = '0' + r;
d1908 5
a1912 3
    *(t++) = '\0';
    SvCUR_set(pnum, (STRLEN) (t - s));
    return (m);
d1915 2
d1918 4
a1921 1
=for apidoc packlist
d1923 1
a1923 1
The engine implementing pack() Perl function.
a1924 2
=cut
*/
d1927 1
a1927 1
Perl_packlist(pTHX_ SV *cat, const char *pat, const char *patend, register SV **beglist, SV **endlist )
d1929 4
a1932 2
    dVAR;
    tempsym_t sym;
d1934 2
a1935 1
    TEMPSYM_INIT(&sym, pat, patend, FLAG_PACK);
a1936 5
    /* We're going to do changes through SvPVX(cat). Make sure it's valid.
       Also make sure any UTF8 flag is loaded */
    SvPV_force_nolen(cat);
    if (DO_UTF8(cat))
	sym.flags |= FLAG_PARSE_UTF8 | FLAG_DO_UTF8;
d1938 6
a1943 2
    (void)pack_rec( cat, &sym, beglist, endlist );
}
a1944 19
/* like sv_utf8_upgrade, but also repoint the group start markers */
STATIC void
marked_upgrade(pTHX_ SV *sv, tempsym_t *sym_ptr) {
    STRLEN len;
    tempsym_t *group;
    const char *from_ptr, *from_start, *from_end, **marks, **m;
    char *to_start, *to_ptr;

    if (SvUTF8(sv)) return;

    from_start = SvPVX_const(sv);
    from_end = from_start + SvCUR(sv);
    for (from_ptr = from_start; from_ptr < from_end; from_ptr++)
	if (!NATIVE_IS_INVARIANT(*from_ptr)) break;
    if (from_ptr == from_end) {
	/* Simple case: no character needs to be changed */
	SvUTF8_on(sv);
	return;
    }
d1946 7
a1952 17
    len = (from_end-from_ptr)*UTF8_EXPAND+(from_ptr-from_start)+1;
    Newx(to_start, len, char);
    Copy(from_start, to_start, from_ptr-from_start, char);
    to_ptr = to_start + (from_ptr-from_start);

    Newx(marks, sym_ptr->level+2, const char *);
    for (group=sym_ptr; group; group = group->previous)
	marks[group->level] = from_start + group->strbeg;
    marks[sym_ptr->level+1] = from_end+1;
    for (m = marks; *m < from_ptr; m++)
	*m = to_start + (*m-from_start);

    for (;from_ptr < from_end; from_ptr++) {
	while (*m == from_ptr) *m++ = to_ptr;
	to_ptr = (char *) uvchr_to_utf8((U8 *) to_ptr, *(U8 *) from_ptr);
    }
    *to_ptr = 0;
d1954 1
a1954 24
    while (*m == from_ptr) *m++ = to_ptr;
    if (m != marks + sym_ptr->level+1) {
	Safefree(marks);
	Safefree(to_start);
	Perl_croak(aTHX_ "Assertion: marks beyond string end");
    }
    for (group=sym_ptr; group; group = group->previous)
	group->strbeg = marks[group->level] - to_start;
    Safefree(marks);

    if (SvOOK(sv)) {
	if (SvIVX(sv)) {
	    SvLEN_set(sv, SvLEN(sv) + SvIVX(sv));
	    from_start -= SvIVX(sv);
	    SvIV_set(sv, 0);
	}
	SvFLAGS(sv) &= ~SVf_OOK;
    }
    if (SvLEN(sv) != 0)
	Safefree(from_start);
    SvPV_set(sv, to_start);
    SvCUR_set(sv, to_ptr - to_start);
    SvLEN_set(sv, len);
    SvUTF8_on(sv);
a1956 13
/* Exponential string grower. Makes string extension effectively O(n)
   needed says how many extra bytes we need (not counting the final '\0')
   Only grows the string if there is an actual lack of space
*/
STATIC char *
S_sv_exp_grow(pTHX_ SV *sv, STRLEN needed) {
    const STRLEN cur = SvCUR(sv);
    const STRLEN len = SvLEN(sv);
    STRLEN extend;
    if (len - cur > needed) return SvPVX(sv);
    extend = needed > len ? needed : len;
    return SvGROW(sv, len+extend+1);
}
d1960 1
a1960 1
S_pack_rec(pTHX_ SV *cat, tempsym_t* symptr, SV **beglist, SV **endlist )
d1962 40
a2001 1
    dVAR;
d2003 7
a2009 9
    I32 items  = endlist - beglist;
    bool found = next_symbol(symptr);
    bool utf8 = (symptr->flags & FLAG_PARSE_UTF8) ? 1 : 0;
    bool warn_utf8 = ckWARN(WARN_UTF8);

    if (symptr->level == 0 && found && symptr->code == 'U') {
	marked_upgrade(aTHX_ cat, symptr);
	symptr->flags |= FLAG_DO_UTF8;
	utf8 = 0;
d2011 1
a2011 1
    symptr->strbeg = SvCUR(cat);
d2014 3
a2016 4
	SV *fromstr;
	STRLEN fromlen;
	I32 len;
	SV *lengthcode = NULL;
d2018 6
a2023 10
        howlen_t howlen = symptr->howlen;
	char *start = SvPVX(cat);
	char *cur   = start + SvCUR(cat);

#define NEXTFROM (lengthcode ? lengthcode : items-- > 0 ? *beglist++ : &PL_sv_no)

        switch (howlen) {
	  case e_star:
	    len = strchr("@@Xxu", TYPE_NO_MODIFIERS(datumtype)) ?
		0 : items;
d2025 2
a2026 3
	  default:
	    /* e_no_len and e_number */
	    len = symptr->length;
a2029 10
	if (len) {
	    packprops_t props = packprops[TYPE_NO_ENDIANNESS(datumtype)];

	    if (props && !(props & PACK_SIZE_UNPREDICTABLE)) {
		/* We can process this letter. */
		STRLEN size = props & PACK_SIZE_MASK;
		GROWING(utf8, cat, start, cur, (STRLEN) len * size);
	    }
        }

d2033 8
a2040 23
	if (symptr->flags & FLAG_SLASH) {
	    IV count;
	    if (!found) Perl_croak(aTHX_ "Code missing after '/' in pack");
	    if (strchr("aAZ", lookahead.code)) {
		if (lookahead.howlen == e_number) count = lookahead.length;
		else {
		    if (items > 0) {
			if (SvGAMAGIC(*beglist)) {
			    /* Avoid reading the active data more than once
			       by copying it to a temporary.  */
			    STRLEN len;
			    const char *const pv = SvPV_const(*beglist, len);
			    SV *const temp = sv_2mortal(newSVpvn(pv, len));
			    if (SvUTF8(*beglist))
				SvUTF8_on(temp);
			    *beglist = temp;
			}
			count = DO_UTF8(*beglist) ?
			    sv_len_utf8(*beglist) : sv_len(*beglist);
		    }
		    else count = 0;
		    if (lookahead.code == 'Z') count++;
		}
d2042 2
a2043 7
		if (lookahead.howlen == e_number && lookahead.length < items)
		    count = lookahead.length;
		else count = items;
	    }
	    lookahead.howlen = e_number;
	    lookahead.length = count;
	    lengthcode = sv_2mortal(newSViv(count));
a2045 3
	/* Code inside the switch must take care to properly update
	   cat (CUR length and '\0' termination) if it updated *cur and
	   doesn't simply leave using break */
d2048 1
a2048 2
	    Perl_croak(aTHX_ "Invalid type '%c' in pack",
		       (int) TYPE_NO_MODIFIERS(datumtype));
a2050 20
	{
	    char *from;
#ifdef PERL_PACK_CAN_SHRIEKSIGN
	case '.' | TYPE_IS_SHRIEKING:
#endif
	case '.':
	    if (howlen == e_star) from = start;
	    else if (len == 0) from = cur;
	    else {
		tempsym_t *group = symptr;

		while (--len && group) group = group->previous;
		from = group ? start + group->strbeg : start;
	    }
	    fromstr = NEXTFROM;
	    len = SvIV(fromstr);
	    goto resize;
#ifdef PERL_PACK_CAN_SHRIEKSIGN
	case '@@' | TYPE_IS_SHRIEKING:
#endif
d2052 5
a2056 34
	    from = start + symptr->strbeg;
	  resize:
#ifdef PERL_PACK_CAN_SHRIEKSIGN
	    if (utf8  && !(datumtype & TYPE_IS_SHRIEKING))
#else /* PERL_PACK_CAN_SHRIEKSIGN */
	    if (utf8)
#endif
		if (len >= 0) {
		    while (len && from < cur) {
			from += UTF8SKIP(from);
			len--;
		    }
		    if (from > cur)
			Perl_croak(aTHX_ "Malformed UTF-8 string in pack");
		    if (len) {
			/* Here we know from == cur */
		      grow:
			GROWING(0, cat, start, cur, len);
			Zero(cur, len, char);
			cur += len;
		    } else if (from < cur) {
			len = cur - from;
			goto shrink;
		    } else goto no_change;
		} else {
		    cur = from;
		    len = -len;
		    goto utf8_shrink;
		}
	    else {
		len -= cur - from;
		if (len > 0) goto grow;
		if (len == 0) goto no_change;
		len = -len;
a2057 1
	    }
d2059 2
a2060 2
	}
	case '(': {
a2065 1
	    symptr->previous = &lookahead;
a2066 4
		U32 was_utf8;
		if (utf8) symptr->flags |=  FLAG_PARSE_UTF8;
		else      symptr->flags &= ~FLAG_PARSE_UTF8;
		was_utf8 = SvUTF8(cat);
d2068 1
a2068 5
		beglist = pack_rec(cat, symptr, beglist, endlist);
		if (SvUTF8(cat) != was_utf8)
		    /* This had better be an upgrade while in utf8==0 mode */
		    utf8 = 1;

d2072 4
a2075 3
	    items = endlist - beglist;
	    lookahead.flags  = symptr->flags & ~group_modifiers;
	    goto no_change;
d2080 1
a2080 17
	    if (utf8) {
		char *hop, *last;
		I32 l = len;
		hop = last = start;
		while (hop < cur) {
		    hop += UTF8SKIP(hop);
		    if (--l == 0) {
			last = hop;
			l = len;
		    }
		}
		if (last > cur)
		    Perl_croak(aTHX_ "Malformed UTF-8 string in pack");
		cur = last;
		break;
	    }
	    len = (cur-start) % len;
d2083 5
a2087 30
	    if (utf8) {
		if (len < 1) goto no_change;
	      utf8_shrink:
		while (len > 0) {
		    if (cur <= start)
			Perl_croak(aTHX_ "'%c' outside of string in pack",
				   (int) TYPE_NO_MODIFIERS(datumtype));
		    while (--cur, UTF8_IS_CONTINUATION(*cur)) {
			if (cur <= start)
			    Perl_croak(aTHX_ "'%c' outside of string in pack",
				       (int) TYPE_NO_MODIFIERS(datumtype));
		    }
		    len--;
		}
	    } else {
	      shrink:
		if (cur - start < len)
		    Perl_croak(aTHX_ "'%c' outside of string in pack",
			       (int) TYPE_NO_MODIFIERS(datumtype));
		cur -= len;
	    }
	    if (cur < start+symptr->strbeg) {
		/* Make sure group starts don't point into the void */
		tempsym_t *group;
		const STRLEN length = cur-start;
		for (group = symptr;
		     group && length < group->strbeg;
		     group = group->previous) group->strbeg = length;
		lookahead.strbeg = length;
	    }
d2089 1
a2089 2
	case 'x' | TYPE_IS_SHRIEKING: {
	    I32 ai32;
d2092 7
a2098 6
	    if (utf8) ai32 = utf8_length((U8 *) start, (U8 *) cur) % len;
	    else      ai32 = (cur - start) % len;
	    if (ai32 == 0) goto no_change;
	    len -= ai32;
	}
	/* FALL THROUGH */
d2100 7
a2106 1
	    goto grow;
d2109 1
a2109 3
	case 'a': {
	    const char *aptr;

d2111 13
a2123 44
	    aptr = SvPV_const(fromstr, fromlen);
	    if (DO_UTF8(fromstr)) {
                const char *end, *s;

		if (!utf8 && !SvUTF8(cat)) {
		    marked_upgrade(aTHX_ cat, symptr);
		    lookahead.flags |= FLAG_DO_UTF8;
		    lookahead.strbeg = symptr->strbeg;
		    utf8 = 1;
		    start = SvPVX(cat);
		    cur = start + SvCUR(cat);
		}
		if (howlen == e_star) {
		    if (utf8) goto string_copy;
		    len = fromlen+1;
		}
		s = aptr;
		end = aptr + fromlen;
		fromlen = datumtype == 'Z' ? len-1 : len;
		while ((I32) fromlen > 0 && s < end) {
		    s += UTF8SKIP(s);
		    fromlen--;
		}
		if (s > end)
		    Perl_croak(aTHX_ "Malformed UTF-8 string in pack");
		if (utf8) {
		    len = fromlen;
		    if (datumtype == 'Z') len++;
		    fromlen = s-aptr;
		    len += fromlen;

		    goto string_copy;
		}
		fromlen = len - fromlen;
		if (datumtype == 'Z') fromlen--;
		if (howlen == e_star) {
		    len = fromlen;
		    if (datumtype == 'Z') len++;
		}
		GROWING(0, cat, start, cur, len);
		if (!uni_to_bytes(aTHX_ &aptr, end, cur, fromlen,
				  datumtype | TYPE_IS_PACK))
		    Perl_croak(aTHX_ "Perl bug: predicted utf8 length not available");
		cur += fromlen;
d2125 6
a2130 4
	    } else if (utf8) {
		if (howlen == e_star) {
		    len = fromlen;
		    if (datumtype == 'Z') len++;
d2132 6
a2137 19
		if (len <= (I32) fromlen) {
		    fromlen = len;
		    if (datumtype == 'Z' && fromlen > 0) fromlen--;
		}
		/* assumes a byte expands to at most UTF8_EXPAND bytes on
		   upgrade, so:
		   expected_length <= from_len*UTF8_EXPAND + (len-from_len) */
		GROWING(0, cat, start, cur, fromlen*(UTF8_EXPAND-1)+len);
		len -= fromlen;
		while (fromlen > 0) {
		    cur = (char *) uvchr_to_utf8((U8 *) cur, * (U8 *) aptr);
		    aptr++;
		    fromlen--;
		}
	    } else {
	      string_copy:
		if (howlen == e_star) {
		    len = fromlen;
		    if (datumtype == 'Z') len++;
a2138 8
		if (len <= (I32) fromlen) {
		    fromlen = len;
		    if (datumtype == 'Z' && fromlen > 0) fromlen--;
		}
		GROWING(0, cat, start, cur, len);
		Copy(aptr, cur, fromlen, char);
		cur += fromlen;
		len -= fromlen;
a2139 2
	    memset(cur, datumtype == 'A' ? ' ' : '\0', len);
	    cur += len;
a2140 1
	}
d2142 4
a2145 6
	case 'b': {
	    const char *str, *end;
	    I32 l, field_len;
	    U8 bits;
	    bool utf8_source;
	    U32 utf8_flags;
d2147 22
a2168 27
	    fromstr = NEXTFROM;
	    str = SvPV_const(fromstr, fromlen);
	    end = str + fromlen;
	    if (DO_UTF8(fromstr)) {
		utf8_source = TRUE;
		utf8_flags  = warn_utf8 ? 0 : UTF8_ALLOW_ANY;
	    } else {
		utf8_source = FALSE;
		utf8_flags  = 0; /* Unused, but keep compilers happy */
	    }
	    if (howlen == e_star) len = fromlen;
	    field_len = (len+7)/8;
	    GROWING(utf8, cat, start, cur, field_len);
	    if (len > (I32)fromlen) len = fromlen;
	    bits = 0;
	    l = 0;
	    if (datumtype == 'B')
		while (l++ < len) {
		    if (utf8_source) {
			UV val = 0;
			NEXT_UNI_VAL(val, cur, str, end, utf8_flags);
			bits |= val & 1;
		    } else bits |= *str++ & 1;
		    if (l & 7) bits <<= 1;
		    else {
			PUSH_BYTE(utf8, cur, bits);
			bits = 0;
d2171 10
a2180 13
	    else
		/* datumtype == 'b' */
		while (l++ < len) {
		    if (utf8_source) {
			UV val = 0;
			NEXT_UNI_VAL(val, cur, str, end, utf8_flags);
			if (val & 1) bits |= 0x80;
		    } else if (*str++ & 1)
			bits |= 0x80;
		    if (l & 7) bits >>= 1;
		    else {
			PUSH_BYTE(utf8, cur, bits);
			bits = 0;
d2183 13
a2195 15
	    l--;
	    if (l & 7) {
		if (datumtype == 'B')
		    bits <<= 7 - (l & 7);
		else
		    bits >>= 7 - (l & 7);
		PUSH_BYTE(utf8, cur, bits);
		l += 7;
	    }
	    /* Determine how many chars are left in the requested field */
	    l /= 8;
	    if (howlen == e_star) field_len = 0;
	    else field_len -= l;
	    Zero(cur, field_len, char);
	    cur += field_len;
a2196 1
	}
d2198 4
a2201 6
	case 'h': {
	    const char *str, *end;
	    I32 l, field_len;
	    U8 bits;
	    bool utf8_source;
	    U32 utf8_flags;
d2203 17
a2219 23
	    fromstr = NEXTFROM;
	    str = SvPV_const(fromstr, fromlen);
	    end = str + fromlen;
	    if (DO_UTF8(fromstr)) {
		utf8_source = TRUE;
		utf8_flags  = warn_utf8 ? 0 : UTF8_ALLOW_ANY;
	    } else {
		utf8_source = FALSE;
		utf8_flags  = 0; /* Unused, but keep compilers happy */
	    }
	    if (howlen == e_star) len = fromlen;
	    field_len = (len+1)/2;
	    GROWING(utf8, cat, start, cur, field_len);
	    if (!utf8 && len > (I32)fromlen) len = fromlen;
	    bits = 0;
	    l = 0;
	    if (datumtype == 'H')
		while (l++ < len) {
		    if (utf8_source) {
			UV val = 0;
			NEXT_UNI_VAL(val, cur, str, end, utf8_flags);
			if (val < 256 && isALPHA(val))
			    bits |= (val + 9) & 0xf;
d2221 7
a2227 9
			    bits |= val & 0xf;
		    } else if (isALPHA(*str))
			bits |= (*str++ + 9) & 0xf;
		    else
			bits |= *str++ & 0xf;
		    if (l & 1) bits <<= 4;
		    else {
			PUSH_BYTE(utf8, cur, bits);
			bits = 0;
d2230 4
a2233 7
	    else
		while (l++ < len) {
		    if (utf8_source) {
			UV val = 0;
			NEXT_UNI_VAL(val, cur, str, end, utf8_flags);
			if (val < 256 && isALPHA(val))
			    bits |= ((val + 9) & 0xf) << 4;
d2235 7
a2241 9
			    bits |= (val & 0xf) << 4;
		    } else if (isALPHA(*str))
			bits |= ((*str++ + 9) & 0xf) << 4;
		    else
			bits |= (*str++ & 0xf) << 4;
		    if (l & 1) bits >>= 4;
		    else {
			PUSH_BYTE(utf8, cur, bits);
			bits = 0;
d2244 7
a2250 23
	    l--;
	    if (l & 1) {
		PUSH_BYTE(utf8, cur, bits);
		l++;
	    }
	    /* Determine how many chars are left in the requested field */
	    l /= 2;
	    if (howlen == e_star) field_len = 0;
	    else field_len -= l;
	    Zero(cur, field_len, char);
	    cur += field_len;
	    break;
	}
	case 'c':
	    while (len-- > 0) {
		IV aiv;
		fromstr = NEXTFROM;
		aiv = SvIV(fromstr);
		if ((-128 > aiv || aiv > 127) &&
		    ckWARN(WARN_PACK))
		    Perl_warner(aTHX_ packWARN(WARN_PACK),
				"Character in 'c' format wrapped in pack");
		PUSH_BYTE(utf8, cur, (U8)(aiv & 0xff));
d2254 1
a2254 21
	    if (len == 0) {
		utf8 = (symptr->flags & FLAG_DO_UTF8) ? 1 : 0;
		break;
	    }
	    while (len-- > 0) {
		IV aiv;
		fromstr = NEXTFROM;
		aiv = SvIV(fromstr);
		if ((0 > aiv || aiv > 0xff) &&
		    ckWARN(WARN_PACK))
		    Perl_warner(aTHX_ packWARN(WARN_PACK),
				"Character in 'C' format wrapped in pack");
		PUSH_BYTE(utf8, cur, (U8)(aiv & 0xff));
	    }
	    break;
	case 'W': {
	    char *end;
	    U8 in_bytes = (U8)IN_BYTES;

	    end = start+SvLEN(cat)-1;
	    if (utf8) end -= UTF8_MAXLEN-1;
a2255 1
		UV auv;
d2257 19
a2275 41
		auv = SvUV(fromstr);
		if (in_bytes) auv = auv % 0x100;
		if (utf8) {
		  W_utf8:
		    if (cur > end) {
			*cur = '\0';
			SvCUR_set(cat, cur - start);

			GROWING(0, cat, start, cur, len+UTF8_MAXLEN);
			end = start+SvLEN(cat)-UTF8_MAXLEN;
		    }
		    cur = (char *) uvuni_to_utf8_flags((U8 *) cur,
						       NATIVE_TO_UNI(auv),
						       warn_utf8 ?
						       0 : UNICODE_ALLOW_ANY);
		} else {
		    if (auv >= 0x100) {
			if (!SvUTF8(cat)) {
			    *cur = '\0';
			    SvCUR_set(cat, cur - start);
			    marked_upgrade(aTHX_ cat, symptr);
			    lookahead.flags |= FLAG_DO_UTF8;
			    lookahead.strbeg = symptr->strbeg;
			    utf8 = 1;
			    start = SvPVX(cat);
			    cur = start + SvCUR(cat);
			    end = start+SvLEN(cat)-UTF8_MAXLEN;
			    goto W_utf8;
			}
			if (ckWARN(WARN_PACK))
			    Perl_warner(aTHX_ packWARN(WARN_PACK),
					"Character in 'W' format wrapped in pack");
			auv &= 0xff;
		    }
		    if (cur >= end) {
			*cur = '\0';
			SvCUR_set(cat, cur - start);
			GROWING(0, cat, start, cur, len+1);
			end = start+SvLEN(cat)-1;
		    }
		    *(U8 *) cur++ = (U8)auv;
d2279 1
a2279 16
	}
	case 'U': {
	    char *end;

	    if (len == 0) {
		if (!(symptr->flags & FLAG_DO_UTF8)) {
		    marked_upgrade(aTHX_ cat, symptr);
		    lookahead.flags |= FLAG_DO_UTF8;
		    lookahead.strbeg = symptr->strbeg;
		}
		utf8 = 0;
		goto no_change;
	    }

	    end = start+SvLEN(cat);
	    if (!utf8) end -= UTF8_MAXLEN;
a2280 1
		UV auv;
d2282 8
a2289 25
		auv = SvUV(fromstr);
		if (utf8) {
		    U8 buffer[UTF8_MAXLEN], *endb;
		    endb = uvuni_to_utf8_flags(buffer, auv,
					       warn_utf8 ?
					       0 : UNICODE_ALLOW_ANY);
		    if (cur+(endb-buffer)*UTF8_EXPAND >= end) {
			*cur = '\0';
			SvCUR_set(cat, cur - start);
			GROWING(0, cat, start, cur,
				len+(endb-buffer)*UTF8_EXPAND);
			end = start+SvLEN(cat);
		    }
		    cur = bytes_to_uni(buffer, endb-buffer, cur);
		} else {
		    if (cur >= end) {
			*cur = '\0';
			SvCUR_set(cat, cur - start);
			GROWING(0, cat, start, cur, len+UTF8_MAXLEN);
			end = start+SvLEN(cat)-UTF8_MAXLEN;
		    }
		    cur = (char *) uvuni_to_utf8_flags((U8 *) cur, auv,
						       warn_utf8 ?
						       0 : UNICODE_ALLOW_ANY);
		}
d2291 1
a2292 1
	}
a2295 2
		float afloat;
		NV anv;
a2296 1
		anv = SvNV(fromstr);
d2298 12
a2309 12
		/* VOS does not automatically map a floating-point overflow
		   during conversion from double to float into infinity, so we
		   do it by hand.  This code should either be generalized for
		   any OS that needs it, or removed if and when VOS implements
		   posix-976 (suggestion to support mapping to infinity).
		   Paul.Green@@stratus.com 02-04-02.  */
		if (anv > FLT_MAX)
		    afloat = _float_constants[0];   /* single prec. inf. */
		else if (anv < -FLT_MAX)
		    afloat = _float_constants[0];   /* single prec. inf. */
		else afloat = (float) anv;
#else /* __VOS__ */
d2311 8
a2318 8
		/* IEEE fp overflow shenanigans are unavailable on VAX and optional
		 * on Alpha; fake it if we don't have them.
		 */
		if (anv > FLT_MAX)
		    afloat = FLT_MAX;
		else if (anv < -FLT_MAX)
		    afloat = -FLT_MAX;
		else afloat = (float)anv;
d2320 1
a2320 1
		afloat = (float)anv;
d2322 1
a2322 1
#endif /* __VOS__ */
d2324 1
a2324 1
		PUSH_VAR(utf8, cur, afloat);
a2328 2
		double adouble;
		NV anv;
a2329 1
		anv = SvNV(fromstr);
d2331 12
a2342 12
		/* VOS does not automatically map a floating-point overflow
		   during conversion from long double to double into infinity,
		   so we do it by hand.  This code should either be generalized
		   for any OS that needs it, or removed if and when VOS
		   implements posix-976 (suggestion to support mapping to
		   infinity).  Paul.Green@@stratus.com 02-04-02.  */
		if (anv > DBL_MAX)
		    adouble = _double_constants[0];   /* double prec. inf. */
		else if (anv < -DBL_MAX)
		    adouble = _double_constants[0];   /* double prec. inf. */
		else adouble = (double) anv;
#else /* __VOS__ */
d2344 8
a2351 8
		/* IEEE fp overflow shenanigans are unavailable on VAX and optional
		 * on Alpha; fake it if we don't have them.
		 */
		if (anv > DBL_MAX)
		    adouble = DBL_MAX;
		else if (anv < -DBL_MAX)
		    adouble = -DBL_MAX;
		else adouble = (double)anv;
d2353 1
a2353 1
		adouble = (double)anv;
d2355 1
a2355 1
#endif /* __VOS__ */
d2357 1
a2357 1
		PUSH_VAR(utf8, cur, adouble);
d2360 1
a2360 2
	case 'F': {
	    NV anv;
d2366 1
a2366 1
		PUSH_VAR(utf8, cur, anv);
a2368 1
	}
d2370 1
a2370 2
	case 'D': {
	    long double aldouble;
d2377 1
a2377 1
		PUSH_VAR(utf8, cur, aldouble);
a2379 1
	}
a2385 1
		I16 ai16;
d2391 1
a2391 1
		PUSH16(utf8, cur, &ai16);
a2398 1
		I16 ai16;
d2404 1
a2404 1
		PUSH16(utf8, cur, &ai16);
d2409 8
a2416 7
	    while (len-- > 0) {
		unsigned short aushort;
		fromstr = NEXTFROM;
		aushort = SvUV(fromstr);
		DO_BO_PACK(aushort, s);
		PUSH_VAR(utf8, cur, aushort);
	    }
d2422 8
a2429 6
	    while (len-- > 0) {
		U16 au16;
		fromstr = NEXTFROM;
		au16 = (U16)SvUV(fromstr);
		DO_BO_PACK(au16, 16);
		PUSH16(utf8, cur, &au16);
d2434 7
a2440 6
	    while (len-- > 0) {
		short ashort;
		fromstr = NEXTFROM;
		ashort = SvIV(fromstr);
		DO_BO_PACK(ashort, s);
		PUSH_VAR(utf8, cur, ashort);
a2447 1
		I16 ai16;
d2451 1
a2451 1
		PUSH16(utf8, cur, &ai16);
a2456 1
		unsigned int auint;
d2460 1
a2460 1
		PUSH_VAR(utf8, cur, auint);
a2464 1
		IV aiv;
a2472 2
#else
		Perl_croak(aTHX_ "'j' not supported on this platform");
d2474 1
a2474 1
		PUSH_VAR(utf8, cur, aiv);
a2478 1
		UV auv;
a2486 2
#else
		Perl_croak(aTHX_ "'J' not supported on this platform");
d2488 1
a2488 1
		PUSH_VAR(utf8, cur, auv);
a2492 1
		NV anv;
d2496 1
a2496 3
		if (anv < 0) {
		    *cur = '\0';
		    SvCUR_set(cat, cur - start);
a2497 1
		}
d2504 3
a2506 2
		if (SvIOK(fromstr) || anv < UV_MAX_P1) {
		    char   buf[(sizeof(UV)*CHAR_BIT)/7+1];
d2515 23
a2537 4
		    PUSH_GROWING_BYTES(utf8, cat, start, cur,
				       in, (buf + sizeof(buf)) - in);
		} else if (SvPOKp(fromstr))
		    goto w_string;
d2550 1
a2550 1
		    /* char   buf[1 + (int)((NV_MAX_10_EXP + 1) * 0.47456)]; -- invalid C */
d2553 1
a2553 1
		    /* char   buf[1 + (int)((308 + 1) * 0.47456)]; -- invalid C */
d2558 1
a2558 1
		    anv = Perl_floor(anv);
d2560 1
a2560 1
			const NV next = Perl_floor(anv / 128);
d2567 3
a2569 3
		    PUSH_GROWING_BYTES(utf8, cat, start, cur,
				       in, (buf + sizeof(buf)) - in);
		} else {
a2575 1
		  w_string:
d2584 2
a2585 1
		    while (!done) *--in = div128(norm, &done) | 0x80;
d2587 1
a2587 2
		    PUSH_GROWING_BYTES(utf8, cat, start, cur,
				       in, (result + len) - in);
d2590 1
a2590 1
		}
a2595 1
		int aint;
d2599 1
a2599 1
		PUSH_VAR(utf8, cur, aint);
a2606 1
		U32 au32;
d2612 1
a2612 1
		PUSH32(utf8, cur, &au32);
a2619 1
		U32 au32;
d2625 1
a2625 1
		PUSH32(utf8, cur, &au32);
d2630 7
a2636 6
	    while (len-- > 0) {
		unsigned long aulong;
		fromstr = NEXTFROM;
		aulong = SvUV(fromstr);
		DO_BO_PACK(aulong, l);
		PUSH_VAR(utf8, cur, aulong);
d2643 7
a2649 6
	    while (len-- > 0) {
		U32 au32;
		fromstr = NEXTFROM;
		au32 = SvUV(fromstr);
		DO_BO_PACK(au32, 32);
		PUSH32(utf8, cur, &au32);
d2654 7
a2660 6
	    while (len-- > 0) {
		long along;
		fromstr = NEXTFROM;
		along = SvIV(fromstr);
		DO_BO_PACK(along, l);
		PUSH_VAR(utf8, cur, along);
a2667 1
		I32 ai32;
d2671 1
a2671 1
		PUSH32(utf8, cur, &ai32);
a2676 1
		Uquad_t auquad;
d2678 1
a2678 1
		auquad = (Uquad_t) SvUV(fromstr);
d2680 1
a2680 1
		PUSH_VAR(utf8, cur, auquad);
a2684 1
		Quad_t aquad;
d2688 1
a2688 1
		PUSH_VAR(utf8, cur, aquad);
d2691 1
a2691 1
#endif /* HAS_QUAD */
a2693 1
	    GROWING(utf8, cat, start, cur, sizeof(char *));
a2696 2
		const char *aptr;

d2701 1
d2707 4
a2710 2
		    if ((SvTEMP(fromstr) || (SvPADTMP(fromstr) &&
			     !SvREADONLY(fromstr))) && ckWARN(WARN_PACK)) {
d2712 1
a2712 1
				    "Attempt to pack pointer to temporary value");
d2715 1
a2715 1
			aptr = SvPV_nomg_const_nolen(fromstr);
d2717 1
a2717 1
			aptr = SvPV_force_flags_nolen(fromstr, 0);
d2720 1
a2720 1
		PUSH_VAR(utf8, cur, aptr);
d2723 1
a2723 4
	case 'u': {
	    const char *aptr, *aend;
	    bool from_utf8;

d2725 6
a2730 15
	    if (len <= 2) len = 45;
	    else len = len / 3 * 3;
	    if (len >= 64) {
		if (ckWARN(WARN_PACK))
		    Perl_warner(aTHX_ packWARN(WARN_PACK),
			    "Field too wide in 'u' format in pack");
		len = 63;
	    }
	    aptr = SvPV_const(fromstr, fromlen);
	    from_utf8 = DO_UTF8(fromstr);
	    if (from_utf8) {
		aend = aptr + fromlen;
		fromlen = sv_len_utf8(fromstr);
	    } else aend = NULL; /* Unused, but keep compilers happy */
	    GROWING(utf8, cat, start, cur, (fromlen+2) / 3 * 4 + (fromlen+len-1)/len * 2);
a2731 1
		U8 *end;
a2732 1
		U8 hunk[1+63/3*4+1];
d2738 1
a2738 14
		if (from_utf8) {
		    char buffer[64];
		    if (!uni_to_bytes(aTHX_ &aptr, aend, buffer, todo,
				      'u' | TYPE_IS_PACK)) {
			*cur = '\0';
			SvCUR_set(cat, cur - start);
			Perl_croak(aTHX_ "Assertion: string is shorter than advertised");
		    }
		    end = doencodes(hunk, buffer, todo);
		} else {
		    end = doencodes(hunk, aptr, todo);
		    aptr += todo;
		}
		PUSH_BYTES(utf8, cur, hunk, end-hunk);
d2740 1
a2743 4
	}
	*cur = '\0';
	SvCUR_set(cat, cur - start);
      no_change:
d2753 1
a2753 1
    dVAR; dSP; dMARK; dORIGMARK; dTARGET;
a2761 1
    SvUTF8_off(cat);
d2763 1
a2763 1
    packlist(cat, pat, patend, MARK, SP + 1);
@


1.1.1.7
log
@import perl 5.10.1
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
a16 2
 *
 *     [p.653 of _The Lord of the Rings_, IV/iv: "Of Herbs and Stewed Rabbit"]
a179 2
  PERL_ARGS_ASSERT_MUL128;

a707 2
    PERL_ARGS_ASSERT_BYTES_TO_UNI;

a786 2
    PERL_ARGS_ASSERT_MEASURE_STRUCT;

a895 2
    PERL_ARGS_ASSERT_GROUP_END;

a925 3

  PERL_ARGS_ASSERT_GET_NUM;

a943 2
  PERL_ARGS_ASSERT_NEXT_SYMBOL;

a1122 3

    PERL_ARGS_ASSERT_NEED_UTF8;

a1137 2
    PERL_ARGS_ASSERT_FIRST_SYMBOL;

a1161 2
    PERL_ARGS_ASSERT_UNPACKSTRING;

d1188 1
a1196 3

    PERL_ARGS_ASSERT_UNPACK_REC;

a1260 1
	    if (len && unpack_only_one) len = 1;
d1296 1
a1296 1
	    mXPUSHs(sv);
d1446 1
a1446 1
	    mXPUSHs(sv);
d1589 1
a1589 1
		    mPUSHi(aint);
d1607 1
a1607 1
			mPUSHu(val);
d1616 1
a1616 1
		    mPUSHu(ch);
d1664 1
a1664 1
		    mPUSHu(auv);
d1678 1
a1678 1
		    mPUSHi(ashort);
d1702 1
a1702 1
		    mPUSHi(ai16);
d1716 1
a1716 1
		    mPUSHu(aushort);
d1745 1
a1745 1
		    mPUSHu(au16);
d1770 1
a1770 1
		    mPUSHi(ai16);
d1785 1
a1785 1
		    mPUSHi(aint);
d1799 1
a1799 1
		    mPUSHu(auint);
d1820 1
a1820 1
		    mPUSHi(aiv);
d1841 1
a1841 1
		    mPUSHu(auv);
d1855 1
a1855 1
		    mPUSHi(along);
d1877 1
a1877 1
		    mPUSHi(ai32);
d1891 1
a1891 1
		    mPUSHu(aulong);
d1920 1
a1920 1
		    mPUSHu(au32);
d1945 1
a1945 1
		    mPUSHi(ai32);
d1959 1
a1959 1
		mPUSHs(newSVpv(aptr, 0));
d1974 1
a1974 1
			mPUSHu(auv);
d1995 1
a1995 1
			mPUSHs(sv);
d2013 1
a2013 1
		PUSHs(newSVpvn_flags(aptr, len, SVs_TEMP));
d2023 2
a2024 2
                    mPUSHs(aquad >= IV_MIN && aquad <= IV_MAX ?
			   newSViv((IV)aquad) : newSVnv((NV)aquad));
d2037 2
a2038 2
		    mPUSHs(auquad <= UV_MAX ?
			   newSVuv((UV)auquad) : newSVnv((NV)auquad));
d2053 1
a2053 1
		    mPUSHn(afloat);
d2064 1
a2064 1
		    mPUSHn(adouble);
d2075 1
a2075 1
		    mPUSHn(anv);
d2087 1
a2087 1
		    mPUSHn(aldouble);
d2190 1
a2190 1
	    mXPUSHs(sv);
a2280 2
  PERL_ARGS_ASSERT_IS_AN_INT;

a2328 2
    PERL_ARGS_ASSERT_DIV128;

a2357 2
    PERL_ARGS_ASSERT_PACKLIST;

a2441 3

    PERL_ARGS_ASSERT_SV_EXP_GROW;

a2457 2
    PERL_ARGS_ASSERT_PACK_REC;

d2513 3
a2515 3
			    SV *const temp
				= newSVpvn_flags(pv, len,
						 SVs_TEMP | SvUTF8(*beglist));
a2778 1
	    SvTAINT(cat);
a3066 2
{
extern const float _float_constants[];
a3071 1
}
a3102 2
{
extern const double _double_constants[];
a3107 1
}
d3555 1
a3555 1
    sv_setpvs(cat, "");
@


1.1.1.8
log
@Perl 5.12.2 from CPAN
@
text
@a72 12
typedef union {
    NV nv;
    U8 bytes[sizeof(NV)];
} NV_bytes;

#if defined(HAS_LONG_DOUBLE) && defined(USE_LONG_DOUBLE)
typedef union {
    long double ld;
    U8 bytes[sizeof(long double)];
} ld_bytes;
#endif

d149 1
a149 1
#define SHIFT_BYTES(utf8, s, strend, buf, len, datumtype)	\
d153 1
a153 1
	  (char *) (buf), len, datumtype)) break;	\
d155 2
a156 2
        Copy(s, (char *) (buf), len, char);		\
        s += len;					\
a159 3
#define SHIFT_VAR(utf8, s, strend, var, datumtype)	\
       SHIFT_BYTES(utf8, s, strend, &(var), sizeof(var), datumtype)

d324 4
a327 11
#  if LONGSIZE < IVSIZE && IVSIZE == 8
#   define DO_BO_UNPACK_P(var)	DO_BO_UNPACK_PTR(var, 64, IV, void)
#   define DO_BO_PACK_P(var)	DO_BO_PACK_PTR(var, 64, IV, void)
#   define DO_BO_UNPACK_PC(var)	DO_BO_UNPACK_PTR(var, 64, IV, char)
#   define DO_BO_PACK_PC(var)	DO_BO_PACK_PTR(var, 64, IV, char)
#  else
#   define DO_BO_UNPACK_P(var)	DO_BO_UNPACK_PTR(var, l, IV, void)
#   define DO_BO_PACK_P(var)	DO_BO_PACK_PTR(var, l, IV, void)
#   define DO_BO_UNPACK_PC(var)	DO_BO_UNPACK_PTR(var, l, IV, char)
#   define DO_BO_PACK_PC(var)	DO_BO_PACK_PTR(var, l, IV, char)
#  endif
d633 4
a636 3
	Perl_ck_warner(aTHX_ packWARN(WARN_UNPACK),
		       "Character in '%c' format wrapped in unpack",
		       (int) TYPE_NO_MODIFIERS(datumtype));
d681 2
a682 2
	if ((bad & 2))
	    Perl_ck_warner(aTHX_ packWARN(datumtype & TYPE_IS_PACK ?
d684 3
a686 3
			   "Character(s) in '%c' format wrapped in %s",
			   (int) TYPE_NO_MODIFIERS(datumtype),
			   datumtype & TYPE_IS_PACK ? "pack" : "unpack");
d1042 5
a1046 5
        if ((code & modifier)) {
	    Perl_ck_warner(aTHX_ packWARN(WARN_UNPACK),
			   "Duplicate modifier '%c' after '%c' in %s",
			   *patptr, (int) TYPE_NO_MODIFIERS(code),
			   _action( symptr ) );
d1480 14
d1558 3
a1560 5
	    if (!checksum) {
		sv = sv_2mortal(newSV(len ? len : 1));
		SvPOK_on(sv);
		str = SvPVX(sv);
	    }
d1570 1
a1570 2
		    if (!checksum)
			*str++ = PL_hexdigit[bits & 15];
d1581 1
a1581 2
		    if (!checksum)
			*str++ = PL_hexdigit[(bits >> 4) & 15];
d1584 3
a1586 5
	    if (!checksum) {
		*str = '\0';
		SvCUR_set(sv, str - SvPVX_const(sv));
		XPUSHs(sv);
	    }
d2096 3
a2098 3
		NV_bytes anv;
		SHIFT_BYTES(utf8, s, strend, anv.bytes, sizeof(anv.bytes), datumtype);
		DO_BO_UNPACK_N(anv.nv, NV);
d2100 1
a2100 1
		    mPUSHn(anv.nv);
d2102 1
a2102 1
		    cdouble += anv.nv;
d2108 3
a2110 3
		ld_bytes aldouble;
		SHIFT_BYTES(utf8, s, strend, aldouble.bytes, sizeof(aldouble.bytes), datumtype);
		DO_BO_UNPACK_N(aldouble.ld, long double);
d2112 1
a2112 1
		    mPUSHn(aldouble.ld);
d2114 1
a2114 1
		    cdouble += aldouble.ld;
d2119 1
a2119 1
	    if (!checksum) {
d2137 1
a2137 2
			if (!checksum)
			    sv_catpvn(sv, hunk, (len > 3) ? 3 : len);
d2178 1
a2178 2
			if (!checksum)
			    sv_catpvn(sv, hunk, (len > 3) ? 3 : len);
d2188 1
a2188 2
	    if (!checksum)
		XPUSHs(sv);
d2442 1
a2442 1
	Perl_croak(aTHX_ "panic: marks beyond string end");
d2776 1
a2776 1
		    Perl_croak(aTHX_ "panic: predicted utf8 length not available");
d2967 4
a2970 3
		if ((-128 > aiv || aiv > 127))
		    Perl_ck_warner(aTHX_ packWARN(WARN_PACK),
				   "Character in 'c' format wrapped in pack");
d2983 4
a2986 3
		if ((0 > aiv || aiv > 0xff))
		    Perl_ck_warner(aTHX_ packWARN(WARN_PACK),
				   "Character in 'C' format wrapped in pack");
d3028 3
a3030 2
			Perl_ck_warner(aTHX_ packWARN(WARN_PACK),
				       "Character in 'W' format wrapped in pack");
d3170 1
a3170 1
	    NV_bytes anv;
d3174 1
a3174 1
		anv.nv = SvNV(fromstr);
d3176 1
a3176 1
		PUSH_BYTES(utf8, cur, anv.bytes, sizeof(anv.bytes));
d3182 1
a3182 1
	    ld_bytes aldouble;
d3187 1
a3187 1
		aldouble.ld = (long double)SvNV(fromstr);
d3189 1
a3189 1
		PUSH_BYTES(utf8, cur, aldouble.bytes, sizeof(aldouble.bytes));
d3517 3
a3519 3
			     !SvREADONLY(fromstr)))) {
			Perl_ck_warner(aTHX_ packWARN(WARN_PACK),
				       "Attempt to pack pointer to temporary value");
d3538 3
a3540 2
		Perl_ck_warner(aTHX_ packWARN(WARN_PACK),
			       "Field too wide in 'u' format in pack");
d3565 1
a3565 1
			Perl_croak(aTHX_ "panic: string is shorter than advertised");
@


1.1.1.9
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d648 1
a648 1
    /* We try to process malformed UTF-8 as much as possible (preferably with
d1228 1
a1228 1
    SV *sv = NULL;
d1561 1
a1561 1
	    char *str = NULL;
d1663 1
a1663 1
                if (explicit_length && howlen != e_star) {
d1762 1
a1762 1
            /* Fallthrough! */
d2458 1
a2458 2
	Perl_croak(aTHX_ "panic: marks beyond string end, m=%p, marks=%p, "
		   "level=%d", m, marks, sym_ptr->level);
d2792 1
a2792 3
		    Perl_croak(aTHX_ "panic: predicted utf8 length not available, "
			       "for '%c', aptr=%p end=%p cur=%p, fromlen=%"UVuf,
			       (int)datumtype, aptr, end, cur, (UV)fromlen);
a3186 4
#ifdef __GNUC__
		/* to work round a gcc/x86 bug; don't use SvNV */
		anv.nv = sv_2nv(fromstr);
#else
a3187 1
#endif
a3199 4
#  ifdef __GNUC__
		/* to work round a gcc/x86 bug; don't use SvNV */
		aldouble.ld = (long double)sv_2nv(fromstr);
#  else
a3200 1
#  endif
d3356 1
a3356 1
		       so 10**(NV_MAX_10_EXP+1) is definitely unrepresentable
d3577 1
a3577 3
			Perl_croak(aTHX_ "panic: string is shorter than advertised, "
				   "aptr=%p, aend=%p, buffer=%p, todo=%ld",
				   aptr, aend, buffer, (long) todo);
@


1.1.1.10
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d923 1
a923 1
S_group_end(pTHX_ const char *patptr, const char *patend, char ender)
d954 1
a954 1
S_get_num(pTHX_ const char *patptr, I32 *lenptr )
d1192 3
a1194 15
The engine implementing the unpack() Perl function.

Using the template pat..patend, this function unpacks the string
s..strend into a number of mortal SVs, which it pushes onto the perl
argument (@@_) stack (so you will need to issue a C<PUTBACK> before and
C<SPAGAIN> after the call to this function). It returns the number of
pushed elements.

The strend and patend pointers should point to the byte following the last
character of each string.

Although this function returns its values on the perl argument stack, it
doesn't take any parameters from that stack (and thus in particular
there's no need to do a PUSHMARK before calling it, unlike L</call_pv> for
example).
d1473 1
a1473 1
			    !isSPACE_utf8(ptr)) break;
d1693 1
a1693 1
		    auv = utf8n_to_uvuni(result, len, &retlen, UTF8_ALLOW_DEFAULT);
d1696 1
a1696 1
		    auv = utf8n_to_uvuni((U8*)s, strend - s, &retlen, UTF8_ALLOW_DEFAULT);
d2237 1
a2237 1
		break;
d2398 1
a2398 1
Perl_packlist(pTHX_ SV *cat, const char *pat, const char *patend, SV **beglist, SV **endlist )
d2561 12
a2572 1
			count = sv_len_utf8(*beglist);
d3113 17
a3129 1
# if defined(VMS) && !defined(_IEEE_FP)
d3141 1
d3152 17
a3168 1
# if defined(VMS) && !defined(_IEEE_FP)
d3180 1
d3572 1
a3572 1
		fromlen = sv_len_utf8_nomg(fromstr);
d3618 1
a3618 1
    SV *cat = TARG;
d3621 2
a3622 2
    const char *pat = SvPV_const(pat_sv, fromlen);
    const char *patend = pat + fromlen;
d3640 1
a3640 1
 * indent-tabs-mode: nil
d3643 1
a3643 1
 * ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.11
log
@Import perl-5.20.1
@
text
@d85 5
d137 22
a158 17
#define PUSH16(utf8, cur, p, needs_swap)                        \
       PUSH_BYTES(utf8, cur, OFF16(p), SIZE16, needs_swap)
#define PUSH32(utf8, cur, p, needs_swap)                        \
       PUSH_BYTES(utf8, cur, OFF32(p), SIZE32, needs_swap)

#if BYTEORDER == 0x4321 || BYTEORDER == 0x87654321  /* big-endian */
#  define NEEDS_SWAP(d)     (TYPE_ENDIANNESS(d) == TYPE_IS_LITTLE_ENDIAN)
#elif BYTEORDER == 0x1234 || BYTEORDER == 0x12345678  /* little-endian */
#  define NEEDS_SWAP(d)     (TYPE_ENDIANNESS(d) == TYPE_IS_BIG_ENDIAN)
#else
#  error "Unsupported byteorder"
        /* Need to add code here to re-instate mixed endian support.
           NEEDS_SWAP would need to hold a flag indicating which action to
           take, and S_reverse_copy and the code in uni_to_bytes would need
           logic adding to deal with any mixed-endian transformations needed.
        */
#endif
d161 1
a161 1
#define SHIFT_BYTES(utf8, s, strend, buf, len, datumtype, needs_swap)	\
d163 1
a163 1
    if (UNLIKELY(utf8)) {                               \
d167 1
a167 4
        if (UNLIKELY(needs_swap))                       \
            S_reverse_copy(s, (char *) (buf), len);     \
        else                                            \
            Copy(s, (char *) (buf), len, char);		\
d172 2
a173 8
#define SHIFT16(utf8, s, strend, p, datumtype, needs_swap)              \
       SHIFT_BYTES(utf8, s, strend, OFF16(p), SIZE16, datumtype, needs_swap)

#define SHIFT32(utf8, s, strend, p, datumtype, needs_swap)              \
       SHIFT_BYTES(utf8, s, strend, OFF32(p), SIZE32, datumtype, needs_swap)

#define SHIFT_VAR(utf8, s, strend, var, datumtype, needs_swap)          \
       SHIFT_BYTES(utf8, s, strend, &(var), sizeof(var), datumtype, needs_swap)
d175 2
a176 2
#define PUSH_VAR(utf8, aptr, var, needs_swap)           \
       PUSH_BYTES(utf8, aptr, &(var), sizeof(var), needs_swap)
d240 26
d271 117
d392 6
a397 1
#include "packsizetables.c"
d399 242
a640 7
static void
S_reverse_copy(const char *src, char *dest, STRLEN len)
{
    dest += len;
    while (len--)
        *--dest = *src++;
}
a676 5
    const bool needs_swap = NEEDS_SWAP(datumtype);

    if (UNLIKELY(needs_swap))
        buf += buf_len;

d688 1
a688 4
        if (UNLIKELY(needs_swap))
            *(U8 *)--buf = (U8)val;
        else
            *(U8 *)buf++ = (U8)val;
d698 1
a698 1
		utf8n_to_uvchr((U8 *) ptr, end-ptr, &retlen, flags);
d730 3
a732 1
S_bytes_to_uni(const U8 *start, STRLEN len, char *dest, const bool needs_swap) {
d735 9
a743 11
    if (UNLIKELY(needs_swap)) {
        const U8 *p = start + len;
        while (p-- > start) {
            append_utf8_from_native_byte(*p, (U8 **) & dest);
        }
    } else {
        const U8 * const end = start + len;
        while (start < end) {
            append_utf8_from_native_byte(*start, (U8 **) & dest);
            start++;
        }
d748 1
a748 1
#define PUSH_BYTES(utf8, cur, buf, len, needs_swap)             \
d750 2
a751 2
    if (UNLIKELY(utf8))	                                        \
	(cur) = S_bytes_to_uni((U8 *) buf, len, (cur), needs_swap);       \
d753 1
a753 4
        if (UNLIKELY(needs_swap))                               \
            S_reverse_copy((char *)(buf), cur, len);            \
        else                                                    \
            Copy(buf, cur, len, char);				\
d779 1
a779 1
    PUSH_BYTES(utf8, cur, buf, glen, 0);        \
d786 1
a786 1
	(s) = S_bytes_to_uni(&au8, 1, (s), 0);	\
d840 1
d843 1
d1030 1
a1030 1
            allowed = "sSiIlLxXnNvV@@.";
d1032 1
d1041 1
d1197 1
a1197 1
C<SPAGAIN> after the call to this function).  It returns the number of
a1259 1
        bool needs_swap;
a1296 2
        needs_swap = NEEDS_SWAP(datumtype);

d1332 1
d1334 1
d1338 1
d1340 3
d1357 1
d1359 1
d1362 1
d1364 3
d1705 1
a1705 1
		    auv = utf8n_to_uvchr(result, len, &retlen, UTF8_ALLOW_DEFAULT);
d1708 1
a1708 1
		    auv = utf8n_to_uvchr((U8*)s, strend - s, &retlen, UTF8_ALLOW_DEFAULT);
d1725 2
a1726 1
                SHIFT_VAR(utf8, s, strend, ashort, datumtype, needs_swap);
d1745 2
a1746 1
                SHIFT16(utf8, s, strend, &ai16, datumtype, needs_swap);
d1763 2
a1764 2
                SHIFT_VAR(utf8, s, strend, aushort, datumtype, needs_swap,
                          needs_swap);
d1784 3
a1786 1
                SHIFT16(utf8, s, strend, &au16, datumtype, needs_swap);
d1789 2
d1793 1
d1802 1
d1810 2
a1811 3
                SHIFT16(utf8, s, strend, &ai16, datumtype, needs_swap);
                /* There should never be any byte-swapping here.  */
                assert(!TYPE_ENDIANNESS(datumtype));
d1814 2
d1818 1
d1827 1
d1832 2
a1833 1
                SHIFT_VAR(utf8, s, strend, aint, datumtype, needs_swap);
d1846 2
a1847 1
                SHIFT_VAR(utf8, s, strend, auint, datumtype, needs_swap);
d1859 10
a1868 1
                SHIFT_VAR(utf8, s, strend, aiv, datumtype, needs_swap);
d1880 10
a1889 1
                SHIFT_VAR(utf8, s, strend, auv, datumtype, needs_swap);
d1902 2
a1903 1
                SHIFT_VAR(utf8, s, strend, along, datumtype, needs_swap);
d1921 2
a1922 1
                SHIFT32(utf8, s, strend, &ai32, datumtype, needs_swap);
d1938 2
a1939 1
                SHIFT_VAR(utf8, s, strend, aulong, datumtype, needs_swap);
d1959 3
a1961 1
                SHIFT32(utf8, s, strend, &au32, datumtype, needs_swap);
d1964 2
d1968 1
d1977 1
d1982 1
a1982 1
#if U32SIZE > SIZE32
d1984 3
a1986 4
#endif
                SHIFT32(utf8, s, strend, &ai32, datumtype, needs_swap);
                /* There should never be any byte swapping here.  */
                assert(!TYPE_ENDIANNESS(datumtype));
d1989 2
d1993 1
d2002 1
d2006 2
a2007 1
                SHIFT_VAR(utf8, s, strend, aptr, datumtype, needs_swap);
d2060 2
a2061 1
                SHIFT_VAR(utf8, s, strend, aptr, datumtype, needs_swap);
d2066 1
a2066 1
#if IVSIZE >= 8
d2070 2
a2071 1
                SHIFT_VAR(utf8, s, strend, aquad, datumtype, needs_swap);
d2084 2
a2085 1
                SHIFT_VAR(utf8, s, strend, auquad, datumtype, needs_swap);
d2095 1
a2095 1
#endif
d2100 2
a2101 1
                SHIFT_VAR(utf8, s, strend, afloat, datumtype, needs_swap);
d2111 2
a2112 1
                SHIFT_VAR(utf8, s, strend, adouble, datumtype, needs_swap);
d2122 2
a2123 2
                SHIFT_BYTES(utf8, s, strend, anv.bytes, sizeof(anv.bytes),
                            datumtype, needs_swap);
d2134 2
a2135 2
                SHIFT_BYTES(utf8, s, strend, aldouble.bytes,
                            sizeof(aldouble.bytes), datumtype, needs_swap);
d2441 1
a2441 1
	if (!NATIVE_BYTE_IS_INVARIANT(*from_ptr)) break;
a2538 1
        bool needs_swap;
a2587 2
        needs_swap = NEEDS_SWAP(datumtype);

d2599 1
d2601 1
d2614 1
d2616 1
d2620 1
d2622 3
d3028 2
a3029 2
		    cur = (char *) uvchr_to_utf8_flags((U8 *) cur,
						       auv,
d3082 1
a3082 1
		    endb = uvchr_to_utf8_flags(buffer, auv,
d3092 1
a3092 1
                    cur = S_bytes_to_uni(buffer, endb-buffer, cur, 0);
d3100 1
a3100 1
		    cur = (char *) uvchr_to_utf8_flags((U8 *) cur, auv,
d3126 2
a3127 1
                PUSH_VAR(utf8, cur, afloat, needs_swap);
d3148 2
a3149 1
                PUSH_VAR(utf8, cur, adouble, needs_swap);
d3163 2
a3164 1
                PUSH_BYTES(utf8, cur, anv.bytes, sizeof(anv.bytes), needs_swap);
d3181 2
a3182 2
                PUSH_BYTES(utf8, cur, aldouble.bytes, sizeof(aldouble.bytes),
                           needs_swap);
d3187 1
d3189 1
d3195 1
d3197 2
a3198 1
                PUSH16(utf8, cur, &ai16, FALSE);
d3201 1
d3203 1
d3209 1
d3211 2
a3212 1
                PUSH16(utf8, cur, &ai16, FALSE);
d3221 2
a3222 1
                PUSH_VAR(utf8, cur, aushort, needs_swap);
d3233 2
a3234 1
                PUSH16(utf8, cur, &au16, needs_swap);
d3243 2
a3244 1
                PUSH_VAR(utf8, cur, ashort, needs_swap);
d3255 2
a3256 1
                PUSH16(utf8, cur, &ai16, needs_swap);
d3265 2
a3266 1
                PUSH_VAR(utf8, cur, auint, needs_swap);
d3274 10
a3283 1
                PUSH_VAR(utf8, cur, aiv, needs_swap);
d3291 10
a3300 1
                PUSH_VAR(utf8, cur, auv, needs_swap);
d3396 2
a3397 1
                PUSH_VAR(utf8, cur, aint, needs_swap);
d3400 1
d3402 1
d3408 1
d3410 2
a3411 1
                PUSH32(utf8, cur, &au32, FALSE);
d3414 1
d3416 1
d3422 1
d3424 2
a3425 1
                PUSH32(utf8, cur, &au32, FALSE);
d3434 2
a3435 1
                PUSH_VAR(utf8, cur, aulong, needs_swap);
d3446 2
a3447 1
                PUSH32(utf8, cur, &au32, needs_swap);
d3456 2
a3457 1
                PUSH_VAR(utf8, cur, along, needs_swap);
d3468 2
a3469 1
                PUSH32(utf8, cur, &ai32, needs_swap);
d3472 1
a3472 1
#if IVSIZE >= 8
d3478 2
a3479 1
                PUSH_VAR(utf8, cur, auquad, needs_swap);
d3487 2
a3488 1
                PUSH_VAR(utf8, cur, aquad, needs_swap);
d3491 1
a3491 1
#endif
d3519 2
a3520 1
                PUSH_VAR(utf8, cur, aptr, needs_swap);
d3566 1
a3566 1
		PUSH_BYTES(utf8, cur, hunk, end-hunk, 0);
@


