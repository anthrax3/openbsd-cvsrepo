head	1.22;
access;
symbols
	PERL_5_24_2:1.1.1.17
	OPENBSD_6_1:1.22.0.4
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.21.0.4
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.4
	OPENBSD_5_8_BASE:1.20
	PERL_5_20_2:1.1.1.16
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	PERL_5_20_1:1.1.1.15
	OPENBSD_5_6:1.18.0.4
	OPENBSD_5_6_BASE:1.18
	PERL_5_18_2:1.1.1.14
	PERL:1.1.1
	OPENBSD_5_5:1.17.0.6
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.2
	OPENBSD_5_4_BASE:1.17
	PERL_5_16_3:1.1.1.13
	OPENBSD_5_3:1.16.0.10
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.8
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.6
	OPENBSD_5_0:1.16.0.4
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.2
	OPENBSD_4_9_BASE:1.16
	PERL_5_12_2:1.1.1.12
	OPENBSD_4_8:1.15.0.4
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	PERL_5_10_1:1.1.1.11
	OPENBSD_4_6:1.13.0.6
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.2
	OPENBSD_4_5_BASE:1.13
	PERL_5_10_0:1.1.1.10
	OPENBSD_4_4:1.12.0.4
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.2
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.11.0.6
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.4
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	PERL_5_8_8:1.1.1.9
	OPENBSD_3_9:1.10.0.6
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.4
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	PERL_5_8_6:1.1.1.8
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.7.0.4
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.22
date	2017.02.05.00.31.53;	author afresh1;	state Exp;
branches;
next	1.21;
commitid	cxJ08BvJA9Pt2PTM;

1.21
date	2016.07.03.01.07.48;	author afresh1;	state Exp;
branches;
next	1.20;
commitid	GzHqjSTnBjdF7Wcw;

1.20
date	2015.04.25.19.14.38;	author afresh1;	state Exp;
branches;
next	1.19;
commitid	XRK22kO4se3v2i2I;

1.19
date	2014.11.17.20.56.48;	author afresh1;	state Exp;
branches;
next	1.18;
commitid	QP75iYx42Uo7mMxO;

1.18
date	2014.03.24.15.05.13;	author afresh1;	state Exp;
branches;
next	1.17;

1.17
date	2013.03.25.20.40.45;	author sthen;	state Exp;
branches;
next	1.16;

1.16
date	2010.09.24.15.06.43;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2009.11.03.14.24.09;	author jasper;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.12.18.24.21;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2008.09.29.17.35.59;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2007.11.07.15.41.58;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.28.19.22.58;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.15.21.30.21;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.08.09.18.08.56;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.12.03.03.02.22;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.01.06.11.33.28;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.19;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.34.56;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.04.21;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.09;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.49.14;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.11.48;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.11.48;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.37.51;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.08.46;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.22.20;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.50;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.36;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.45.23;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2005.01.15.21.16.35;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2006.03.28.18.47.42;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2008.09.29.17.18.08;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2009.10.12.18.10.35;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2010.09.24.14.48.26;	author millert;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2013.03.25.20.06.39;	author sthen;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.03.24.14.58.47;	author afresh1;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2014.11.17.20.52.39;	author afresh1;	state Exp;
branches;
next	1.1.1.16;
commitid	B31cAbBIXiCqnL97;

1.1.1.16
date	2015.04.25.19.10.12;	author afresh1;	state Exp;
branches;
next	1.1.1.17;
commitid	Wpcs5S8qILgEZC7F;

1.1.1.17
date	2017.08.14.13.45.29;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.22
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*    regcomp.c
 */

/*
 * 'A fair jaw-cracker dwarf-language must be.'            --Samwise Gamgee
 *
 *     [p.285 of _The Lord of the Rings_, II/iii: "The Ring Goes South"]
 */

/* This file contains functions for compiling a regular expression.  See
 * also regexec.c which funnily enough, contains functions for executing
 * a regular expression.
 *
 * This file is also copied at build time to ext/re/re_comp.c, where
 * it's built with -DPERL_EXT_RE_BUILD -DPERL_EXT_RE_DEBUG -DPERL_EXT.
 * This causes the main functions to be compiled under new names and with
 * debugging support added, which makes "use re 'debug'" work.
 */

/* NOTE: this is derived from Henry Spencer's regexp code, and should not
 * confused with the original package (see point 3 below).  Thanks, Henry!
 */

/* Additional note: this code is very heavily munged from Henry's version
 * in places.  In some spots I've traded clarity for efficiency, so don't
 * blame Henry for some of the lack of readability.
 */

/* The names of the functions have been changed from regcomp and
 * regexec to pregcomp and pregexec in order to avoid conflicts
 * with the POSIX routines of the same names.
*/

#ifdef PERL_EXT_RE_BUILD
#include "re_top.h"
#endif

/*
 * pregcomp and pregexec -- regsub and regerror are not used in perl
 *
 *	Copyright (c) 1986 by University of Toronto.
 *	Written by Henry Spencer.  Not derived from licensed software.
 *
 *	Permission is granted to anyone to use this software for any
 *	purpose on any computer system, and to redistribute it freely,
 *	subject to the following restrictions:
 *
 *	1. The author is not responsible for the consequences of use of
 *		this software, no matter how awful, even if they arise
 *		from defects in it.
 *
 *	2. The origin of this software must not be misrepresented, either
 *		by explicit claim or by omission.
 *
 *	3. Altered versions must be plainly marked as such, and must not
 *		be misrepresented as being the original software.
 *
 *
 ****    Alterations to Henry's code are...
 ****
 ****    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 ****    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
 ****    by Larry Wall and others
 ****
 ****    You may distribute under the terms of either the GNU General Public
 ****    License or the Artistic License, as specified in the README file.

 *
 * Beware that some of this code is subtly aware of the way operator
 * precedence is structured in regular expressions.  Serious changes in
 * regular-expression syntax might require a total rethink.
 */
#include "EXTERN.h"
#define PERL_IN_REGCOMP_C
#include "perl.h"

#ifndef PERL_IN_XSUB_RE
#  include "INTERN.h"
#endif

#define REG_COMP_C
#ifdef PERL_IN_XSUB_RE
#  include "re_comp.h"
EXTERN_C const struct regexp_engine my_reg_engine;
#else
#  include "regcomp.h"
#endif

#include "dquote_inline.h"
#include "invlist_inline.h"
#include "unicode_constants.h"

#define HAS_NONLATIN1_FOLD_CLOSURE(i) \
 _HAS_NONLATIN1_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(i)
#define HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(i) \
 _HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(i)
#define IS_NON_FINAL_FOLD(c) _IS_NON_FINAL_FOLD_ONLY_FOR_USE_BY_REGCOMP_DOT_C(c)
#define IS_IN_SOME_FOLD_L1(c) _IS_IN_SOME_FOLD_ONLY_FOR_USE_BY_REGCOMP_DOT_C(c)

#ifndef STATIC
#define	STATIC	static
#endif

#ifndef MIN
#define MIN(a,b) ((a) < (b) ? (a) : (b))
#endif

#ifndef MAX
#define MAX(a,b) ((a) > (b) ? (a) : (b))
#endif

/* this is a chain of data about sub patterns we are processing that
   need to be handled separately/specially in study_chunk. Its so
   we can simulate recursion without losing state.  */
struct scan_frame;
typedef struct scan_frame {
    regnode *last_regnode;      /* last node to process in this frame */
    regnode *next_regnode;      /* next node to process when last is reached */
    U32 prev_recursed_depth;
    I32 stopparen;              /* what stopparen do we use */
    U32 is_top_frame;           /* what flags do we use? */

    struct scan_frame *this_prev_frame; /* this previous frame */
    struct scan_frame *prev_frame;      /* previous frame */
    struct scan_frame *next_frame;      /* next frame */
} scan_frame;

/* Certain characters are output as a sequence with the first being a
 * backslash. */
#define isBACKSLASHED_PUNCT(c)                                              \
                    ((c) == '-' || (c) == ']' || (c) == '\\' || (c) == '^')


struct RExC_state_t {
    U32		flags;			/* RXf_* are we folding, multilining? */
    U32		pm_flags;		/* PMf_* stuff from the calling PMOP */
    char	*precomp;		/* uncompiled string. */
    char	*precomp_end;		/* pointer to end of uncompiled string. */
    REGEXP	*rx_sv;			/* The SV that is the regexp. */
    regexp	*rx;                    /* perl core regexp structure */
    regexp_internal	*rxi;           /* internal data for regexp object
                                           pprivate field */
    char	*start;			/* Start of input for compile */
    char	*end;			/* End of input for compile */
    char	*parse;			/* Input-scan pointer. */
    char        *adjusted_start;        /* 'start', adjusted.  See code use */
    STRLEN      precomp_adj;            /* an offset beyond precomp.  See code use */
    SSize_t	whilem_seen;		/* number of WHILEM in this expr */
    regnode	*emit_start;		/* Start of emitted-code area */
    regnode	*emit_bound;		/* First regnode outside of the
                                           allocated space */
    regnode	*emit;			/* Code-emit pointer; if = &emit_dummy,
                                           implies compiling, so don't emit */
    regnode_ssc	emit_dummy;		/* placeholder for emit to point to;
                                           large enough for the largest
                                           non-EXACTish node, so can use it as
                                           scratch in pass1 */
    I32		naughty;		/* How bad is this pattern? */
    I32		sawback;		/* Did we see \1, ...? */
    U32		seen;
    SSize_t	size;			/* Code size. */
    I32                npar;            /* Capture buffer count, (OPEN) plus
                                           one. ("par" 0 is the whole
                                           pattern)*/
    I32		nestroot;		/* root parens we are in - used by
                                           accept */
    I32		extralen;
    I32		seen_zerolen;
    regnode	**open_parens;		/* pointers to open parens */
    regnode	**close_parens;		/* pointers to close parens */
    regnode     *end_op;                /* END node in program */
    I32		utf8;		/* whether the pattern is utf8 or not */
    I32		orig_utf8;	/* whether the pattern was originally in utf8 */
				/* XXX use this for future optimisation of case
				 * where pattern must be upgraded to utf8. */
    I32		uni_semantics;	/* If a d charset modifier should use unicode
				   rules, even if the pattern is not in
				   utf8 */
    HV		*paren_names;		/* Paren names */

    regnode	**recurse;		/* Recurse regops */
    I32                recurse_count;                /* Number of recurse regops we have generated */
    U8          *study_chunk_recursed;  /* bitmap of which subs we have moved
                                           through */
    U32         study_chunk_recursed_bytes;  /* bytes in bitmap */
    I32		in_lookbehind;
    I32		contains_locale;
    I32		contains_i;
    I32		override_recoding;
#ifdef EBCDIC
    I32		recode_x_to_native;
#endif
    I32		in_multi_char_class;
    struct reg_code_block *code_blocks;	/* positions of literal (?{})
					    within pattern */
    int		num_code_blocks;	/* size of code_blocks[] */
    int		code_index;		/* next code_blocks[] slot */
    SSize_t     maxlen;                        /* mininum possible number of chars in string to match */
    scan_frame *frame_head;
    scan_frame *frame_last;
    U32         frame_count;
#ifdef ADD_TO_REGEXEC
    char 	*starttry;		/* -Dr: where regtry was called. */
#define RExC_starttry	(pRExC_state->starttry)
#endif
    SV		*runtime_code_qr;	/* qr with the runtime code blocks */
#ifdef DEBUGGING
    const char  *lastparse;
    I32         lastnum;
    AV          *paren_name_list;       /* idx -> name */
    U32         study_chunk_recursed_count;
    SV          *mysv1;
    SV          *mysv2;
#define RExC_lastparse	(pRExC_state->lastparse)
#define RExC_lastnum	(pRExC_state->lastnum)
#define RExC_paren_name_list    (pRExC_state->paren_name_list)
#define RExC_study_chunk_recursed_count    (pRExC_state->study_chunk_recursed_count)
#define RExC_mysv	(pRExC_state->mysv1)
#define RExC_mysv1	(pRExC_state->mysv1)
#define RExC_mysv2	(pRExC_state->mysv2)

#endif
    bool        seen_unfolded_sharp_s;
    bool        strict;
};

#define RExC_flags	(pRExC_state->flags)
#define RExC_pm_flags	(pRExC_state->pm_flags)
#define RExC_precomp	(pRExC_state->precomp)
#define RExC_precomp_adj (pRExC_state->precomp_adj)
#define RExC_adjusted_start  (pRExC_state->adjusted_start)
#define RExC_precomp_end (pRExC_state->precomp_end)
#define RExC_rx_sv	(pRExC_state->rx_sv)
#define RExC_rx		(pRExC_state->rx)
#define RExC_rxi	(pRExC_state->rxi)
#define RExC_start	(pRExC_state->start)
#define RExC_end	(pRExC_state->end)
#define RExC_parse	(pRExC_state->parse)
#define RExC_whilem_seen	(pRExC_state->whilem_seen)

/* Set during the sizing pass when there is a LATIN SMALL LETTER SHARP S in any
 * EXACTF node, hence was parsed under /di rules.  If later in the parse,
 * something forces the pattern into using /ui rules, the sharp s should be
 * folded into the sequence 'ss', which takes up more space than previously
 * calculated.  This means that the sizing pass needs to be restarted.  (The
 * node also becomes an EXACTFU_SS.)  For all other characters, an EXACTF node
 * that gets converted to /ui (and EXACTFU) occupies the same amount of space,
 * so there is no need to resize [perl #125990]. */
#define RExC_seen_unfolded_sharp_s (pRExC_state->seen_unfolded_sharp_s)

#ifdef RE_TRACK_PATTERN_OFFSETS
#define RExC_offsets	(pRExC_state->rxi->u.offsets) /* I am not like the
                                                         others */
#endif
#define RExC_emit	(pRExC_state->emit)
#define RExC_emit_dummy	(pRExC_state->emit_dummy)
#define RExC_emit_start	(pRExC_state->emit_start)
#define RExC_emit_bound	(pRExC_state->emit_bound)
#define RExC_sawback	(pRExC_state->sawback)
#define RExC_seen	(pRExC_state->seen)
#define RExC_size	(pRExC_state->size)
#define RExC_maxlen        (pRExC_state->maxlen)
#define RExC_npar	(pRExC_state->npar)
#define RExC_nestroot   (pRExC_state->nestroot)
#define RExC_extralen	(pRExC_state->extralen)
#define RExC_seen_zerolen	(pRExC_state->seen_zerolen)
#define RExC_utf8	(pRExC_state->utf8)
#define RExC_uni_semantics	(pRExC_state->uni_semantics)
#define RExC_orig_utf8	(pRExC_state->orig_utf8)
#define RExC_open_parens	(pRExC_state->open_parens)
#define RExC_close_parens	(pRExC_state->close_parens)
#define RExC_end_op	(pRExC_state->end_op)
#define RExC_paren_names	(pRExC_state->paren_names)
#define RExC_recurse	(pRExC_state->recurse)
#define RExC_recurse_count	(pRExC_state->recurse_count)
#define RExC_study_chunk_recursed        (pRExC_state->study_chunk_recursed)
#define RExC_study_chunk_recursed_bytes  \
                                   (pRExC_state->study_chunk_recursed_bytes)
#define RExC_in_lookbehind	(pRExC_state->in_lookbehind)
#define RExC_contains_locale	(pRExC_state->contains_locale)
#define RExC_contains_i (pRExC_state->contains_i)
#define RExC_override_recoding (pRExC_state->override_recoding)
#ifdef EBCDIC
#   define RExC_recode_x_to_native (pRExC_state->recode_x_to_native)
#endif
#define RExC_in_multi_char_class (pRExC_state->in_multi_char_class)
#define RExC_frame_head (pRExC_state->frame_head)
#define RExC_frame_last (pRExC_state->frame_last)
#define RExC_frame_count (pRExC_state->frame_count)
#define RExC_strict (pRExC_state->strict)

/* Heuristic check on the complexity of the pattern: if TOO_NAUGHTY, we set
 * a flag to disable back-off on the fixed/floating substrings - if it's
 * a high complexity pattern we assume the benefit of avoiding a full match
 * is worth the cost of checking for the substrings even if they rarely help.
 */
#define RExC_naughty	(pRExC_state->naughty)
#define TOO_NAUGHTY (10)
#define MARK_NAUGHTY(add) \
    if (RExC_naughty < TOO_NAUGHTY) \
        RExC_naughty += (add)
#define MARK_NAUGHTY_EXP(exp, add) \
    if (RExC_naughty < TOO_NAUGHTY) \
        RExC_naughty += RExC_naughty / (exp) + (add)

#define	ISMULT1(c)	((c) == '*' || (c) == '+' || (c) == '?')
#define	ISMULT2(s)	((*s) == '*' || (*s) == '+' || (*s) == '?' || \
	((*s) == '{' && regcurly(s)))

/*
 * Flags to be passed up and down.
 */
#define	WORST		0	/* Worst case. */
#define	HASWIDTH	0x01	/* Known to match non-null strings. */

/* Simple enough to be STAR/PLUS operand; in an EXACTish node must be a single
 * character.  (There needs to be a case: in the switch statement in regexec.c
 * for any node marked SIMPLE.)  Note that this is not the same thing as
 * REGNODE_SIMPLE */
#define	SIMPLE		0x02
#define	SPSTART		0x04	/* Starts with * or + */
#define POSTPONED	0x08    /* (?1),(?&name), (??{...}) or similar */
#define TRYAGAIN	0x10	/* Weeded out a declaration. */
#define RESTART_PASS1   0x20    /* Need to restart sizing pass */
#define NEED_UTF8       0x40    /* In conjunction with RESTART_PASS1, need to
                                   calcuate sizes as UTF-8 */

#define REG_NODE_NUM(x) ((x) ? (int)((x)-RExC_emit_start) : -1)

/* whether trie related optimizations are enabled */
#if PERL_ENABLE_EXTENDED_TRIE_OPTIMISATION
#define TRIE_STUDY_OPT
#define FULL_TRIE_STUDY
#define TRIE_STCLASS
#endif



#define PBYTE(u8str,paren) ((U8*)(u8str))[(paren) >> 3]
#define PBITVAL(paren) (1 << ((paren) & 7))
#define PAREN_TEST(u8str,paren) ( PBYTE(u8str,paren) & PBITVAL(paren))
#define PAREN_SET(u8str,paren) PBYTE(u8str,paren) |= PBITVAL(paren)
#define PAREN_UNSET(u8str,paren) PBYTE(u8str,paren) &= (~PBITVAL(paren))

#define REQUIRE_UTF8(flagp) STMT_START {                                   \
                                     if (!UTF) {                           \
                                         assert(PASS1);                    \
                                         *flagp = RESTART_PASS1|NEED_UTF8; \
                                         return NULL;                      \
                                     }                                     \
                             } STMT_END

/* Change from /d into /u rules, and restart the parse if we've already seen
 * something whose size would increase as a result, by setting *flagp and
 * returning 'restart_retval'.  RExC_uni_semantics is a flag that indicates
 * we've change to /u during the parse.  */
#define REQUIRE_UNI_RULES(flagp, restart_retval)                            \
    STMT_START {                                                            \
            if (DEPENDS_SEMANTICS) {                                        \
                assert(PASS1);                                              \
                set_regex_charset(&RExC_flags, REGEX_UNICODE_CHARSET);      \
                RExC_uni_semantics = 1;                                     \
                if (RExC_seen_unfolded_sharp_s) {                           \
                    *flagp |= RESTART_PASS1;                                \
                    return restart_retval;                                  \
                }                                                           \
            }                                                               \
    } STMT_END

/* This converts the named class defined in regcomp.h to its equivalent class
 * number defined in handy.h. */
#define namedclass_to_classnum(class)  ((int) ((class) / 2))
#define classnum_to_namedclass(classnum)  ((classnum) * 2)

#define _invlist_union_complement_2nd(a, b, output) \
                        _invlist_union_maybe_complement_2nd(a, b, TRUE, output)
#define _invlist_intersection_complement_2nd(a, b, output) \
                 _invlist_intersection_maybe_complement_2nd(a, b, TRUE, output)

/* About scan_data_t.

  During optimisation we recurse through the regexp program performing
  various inplace (keyhole style) optimisations. In addition study_chunk
  and scan_commit populate this data structure with information about
  what strings MUST appear in the pattern. We look for the longest
  string that must appear at a fixed location, and we look for the
  longest string that may appear at a floating location. So for instance
  in the pattern:

    /FOO[xX]A.*B[xX]BAR/

  Both 'FOO' and 'A' are fixed strings. Both 'B' and 'BAR' are floating
  strings (because they follow a .* construct). study_chunk will identify
  both FOO and BAR as being the longest fixed and floating strings respectively.

  The strings can be composites, for instance

     /(f)(o)(o)/

  will result in a composite fixed substring 'foo'.

  For each string some basic information is maintained:

  - offset or min_offset
    This is the position the string must appear at, or not before.
    It also implicitly (when combined with minlenp) tells us how many
    characters must match before the string we are searching for.
    Likewise when combined with minlenp and the length of the string it
    tells us how many characters must appear after the string we have
    found.

  - max_offset
    Only used for floating strings. This is the rightmost point that
    the string can appear at. If set to SSize_t_MAX it indicates that the
    string can occur infinitely far to the right.

  - minlenp
    A pointer to the minimum number of characters of the pattern that the
    string was found inside. This is important as in the case of positive
    lookahead or positive lookbehind we can have multiple patterns
    involved. Consider

    /(?=FOO).*F/

    The minimum length of the pattern overall is 3, the minimum length
    of the lookahead part is 3, but the minimum length of the part that
    will actually match is 1. So 'FOO's minimum length is 3, but the
    minimum length for the F is 1. This is important as the minimum length
    is used to determine offsets in front of and behind the string being
    looked for.  Since strings can be composites this is the length of the
    pattern at the time it was committed with a scan_commit. Note that
    the length is calculated by study_chunk, so that the minimum lengths
    are not known until the full pattern has been compiled, thus the
    pointer to the value.

  - lookbehind

    In the case of lookbehind the string being searched for can be
    offset past the start point of the final matching string.
    If this value was just blithely removed from the min_offset it would
    invalidate some of the calculations for how many chars must match
    before or after (as they are derived from min_offset and minlen and
    the length of the string being searched for).
    When the final pattern is compiled and the data is moved from the
    scan_data_t structure into the regexp structure the information
    about lookbehind is factored in, with the information that would
    have been lost precalculated in the end_shift field for the
    associated string.

  The fields pos_min and pos_delta are used to store the minimum offset
  and the delta to the maximum offset at the current point in the pattern.

*/

typedef struct scan_data_t {
    /*I32 len_min;      unused */
    /*I32 len_delta;    unused */
    SSize_t pos_min;
    SSize_t pos_delta;
    SV *last_found;
    SSize_t last_end;	    /* min value, <0 unless valid. */
    SSize_t last_start_min;
    SSize_t last_start_max;
    SV **longest;	    /* Either &l_fixed, or &l_float. */
    SV *longest_fixed;      /* longest fixed string found in pattern */
    SSize_t offset_fixed;   /* offset where it starts */
    SSize_t *minlen_fixed;  /* pointer to the minlen relevant to the string */
    I32 lookbehind_fixed;   /* is the position of the string modfied by LB */
    SV *longest_float;      /* longest floating string found in pattern */
    SSize_t offset_float_min; /* earliest point in string it can appear */
    SSize_t offset_float_max; /* latest point in string it can appear */
    SSize_t *minlen_float;  /* pointer to the minlen relevant to the string */
    SSize_t lookbehind_float; /* is the pos of the string modified by LB */
    I32 flags;
    I32 whilem_c;
    SSize_t *last_closep;
    regnode_ssc *start_class;
} scan_data_t;

/*
 * Forward declarations for pregcomp()'s friends.
 */

static const scan_data_t zero_scan_data =
  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ,0};

#define SF_BEFORE_EOL		(SF_BEFORE_SEOL|SF_BEFORE_MEOL)
#define SF_BEFORE_SEOL		0x0001
#define SF_BEFORE_MEOL		0x0002
#define SF_FIX_BEFORE_EOL	(SF_FIX_BEFORE_SEOL|SF_FIX_BEFORE_MEOL)
#define SF_FL_BEFORE_EOL	(SF_FL_BEFORE_SEOL|SF_FL_BEFORE_MEOL)

#define SF_FIX_SHIFT_EOL	(+2)
#define SF_FL_SHIFT_EOL		(+4)

#define SF_FIX_BEFORE_SEOL	(SF_BEFORE_SEOL << SF_FIX_SHIFT_EOL)
#define SF_FIX_BEFORE_MEOL	(SF_BEFORE_MEOL << SF_FIX_SHIFT_EOL)

#define SF_FL_BEFORE_SEOL	(SF_BEFORE_SEOL << SF_FL_SHIFT_EOL)
#define SF_FL_BEFORE_MEOL	(SF_BEFORE_MEOL << SF_FL_SHIFT_EOL) /* 0x20 */
#define SF_IS_INF		0x0040
#define SF_HAS_PAR		0x0080
#define SF_IN_PAR		0x0100
#define SF_HAS_EVAL		0x0200


/* SCF_DO_SUBSTR is the flag that tells the regexp analyzer to track the
 * longest substring in the pattern. When it is not set the optimiser keeps
 * track of position, but does not keep track of the actual strings seen,
 *
 * So for instance /foo/ will be parsed with SCF_DO_SUBSTR being true, but
 * /foo/i will not.
 *
 * Similarly, /foo.*(blah|erm|huh).*fnorble/ will have "foo" and "fnorble"
 * parsed with SCF_DO_SUBSTR on, but while processing the (...) it will be
 * turned off because of the alternation (BRANCH). */
#define SCF_DO_SUBSTR		0x0400

#define SCF_DO_STCLASS_AND	0x0800
#define SCF_DO_STCLASS_OR	0x1000
#define SCF_DO_STCLASS		(SCF_DO_STCLASS_AND|SCF_DO_STCLASS_OR)
#define SCF_WHILEM_VISITED_POS	0x2000

#define SCF_TRIE_RESTUDY        0x4000 /* Do restudy? */
#define SCF_SEEN_ACCEPT         0x8000
#define SCF_TRIE_DOING_RESTUDY 0x10000
#define SCF_IN_DEFINE          0x20000




#define UTF cBOOL(RExC_utf8)

/* The enums for all these are ordered so things work out correctly */
#define LOC (get_regex_charset(RExC_flags) == REGEX_LOCALE_CHARSET)
#define DEPENDS_SEMANTICS (get_regex_charset(RExC_flags)                    \
                                                     == REGEX_DEPENDS_CHARSET)
#define UNI_SEMANTICS (get_regex_charset(RExC_flags) == REGEX_UNICODE_CHARSET)
#define AT_LEAST_UNI_SEMANTICS (get_regex_charset(RExC_flags)                \
                                                     >= REGEX_UNICODE_CHARSET)
#define ASCII_RESTRICTED (get_regex_charset(RExC_flags)                      \
                                            == REGEX_ASCII_RESTRICTED_CHARSET)
#define AT_LEAST_ASCII_RESTRICTED (get_regex_charset(RExC_flags)             \
                                            >= REGEX_ASCII_RESTRICTED_CHARSET)
#define ASCII_FOLD_RESTRICTED (get_regex_charset(RExC_flags)                 \
                                        == REGEX_ASCII_MORE_RESTRICTED_CHARSET)

#define FOLD cBOOL(RExC_flags & RXf_PMf_FOLD)

/* For programs that want to be strictly Unicode compatible by dying if any
 * attempt is made to match a non-Unicode code point against a Unicode
 * property.  */
#define ALWAYS_WARN_SUPER  ckDEAD(packWARN(WARN_NON_UNICODE))

#define OOB_NAMEDCLASS		-1

/* There is no code point that is out-of-bounds, so this is problematic.  But
 * its only current use is to initialize a variable that is always set before
 * looked at. */
#define OOB_UNICODE		0xDEADBEEF

#define CHR_SVLEN(sv) (UTF ? sv_len_utf8(sv) : SvCUR(sv))
#define CHR_DIST(a,b) (UTF ? utf8_distance(a,b) : a - b)


/* length of regex to show in messages that don't mark a position within */
#define RegexLengthToShowInErrorMessages 127

/*
 * If MARKER[12] are adjusted, be sure to adjust the constants at the top
 * of t/op/regmesg.t, the tests in t/op/re_tests, and those in
 * op/pragma/warn/regcomp.
 */
#define MARKER1 "<-- HERE"    /* marker as it appears in the description */
#define MARKER2 " <-- HERE "  /* marker as it appears within the regex */

#define REPORT_LOCATION " in regex; marked by " MARKER1    \
                        " in m/%"UTF8f MARKER2 "%"UTF8f"/"

/* The code in this file in places uses one level of recursion with parsing
 * rebased to an alternate string constructed by us in memory.  This can take
 * the form of something that is completely different from the input, or
 * something that uses the input as part of the alternate.  In the first case,
 * there should be no possibility of an error, as we are in complete control of
 * the alternate string.  But in the second case we don't control the input
 * portion, so there may be errors in that.  Here's an example:
 *      /[abc\x{DF}def]/ui
 * is handled specially because \x{df} folds to a sequence of more than one
 * character, 'ss'.  What is done is to create and parse an alternate string,
 * which looks like this:
 *      /(?:\x{DF}|[abc\x{DF}def])/ui
 * where it uses the input unchanged in the middle of something it constructs,
 * which is a branch for the DF outside the character class, and clustering
 * parens around the whole thing. (It knows enough to skip the DF inside the
 * class while in this substitute parse.) 'abc' and 'def' may have errors that
 * need to be reported.  The general situation looks like this:
 *
 *              sI                       tI               xI       eI
 * Input:       ----------------------------------------------------
 * Constructed:         ---------------------------------------------------
 *                      sC               tC               xC       eC     EC
 *
 * The input string sI..eI is the input pattern.  The string sC..EC is the
 * constructed substitute parse string.  The portions sC..tC and eC..EC are
 * constructed by us.  The portion tC..eC is an exact duplicate of the input
 * pattern tI..eI.  In the diagram, these are vertically aligned.  Suppose that
 * while parsing, we find an error at xC.  We want to display a message showing
 * the real input string.  Thus we need to find the point xI in it which
 * corresponds to xC.  xC >= tC, since the portion of the string sC..tC has
 * been constructed by us, and so shouldn't have errors.  We get:
 *
 *      xI = sI + (tI - sI) + (xC - tC)
 *
 * and, the offset into sI is:
 *
 *      (xI - sI) = (tI - sI) + (xC - tC)
 *
 * When the substitute is constructed, we save (tI -sI) as RExC_precomp_adj,
 * and we save tC as RExC_adjusted_start.
 *
 * During normal processing of the input pattern, everything points to that,
 * with RExC_precomp_adj set to 0, and RExC_adjusted_start set to sI.
 */

#define tI_sI           RExC_precomp_adj
#define tC              RExC_adjusted_start
#define sC              RExC_precomp
#define xI_offset(xC)   ((IV) (tI_sI + (xC - tC)))
#define xI(xC)          (sC + xI_offset(xC))
#define eC              RExC_precomp_end

#define REPORT_LOCATION_ARGS(xC)                                            \
    UTF8fARG(UTF,                                                           \
             (xI(xC) > eC) /* Don't run off end */                          \
              ? eC - sC   /* Length before the <--HERE */                   \
              : xI_offset(xC),                                              \
             sC),         /* The input pattern printed up to the <--HERE */ \
    UTF8fARG(UTF,                                                           \
             (xI(xC) > eC) ? 0 : eC - xI(xC), /* Length after <--HERE */    \
             (xI(xC) > eC) ? eC : xI(xC))     /* pattern after <--HERE */

/* Used to point after bad bytes for an error message, but avoid skipping
 * past a nul byte. */
#define SKIP_IF_CHAR(s) (!*(s) ? 0 : UTF ? UTF8SKIP(s) : 1)

/*
 * Calls SAVEDESTRUCTOR_X if needed, then calls Perl_croak with the given
 * arg. Show regex, up to a maximum length. If it's too long, chop and add
 * "...".
 */
#define _FAIL(code) STMT_START {					\
    const char *ellipses = "";						\
    IV len = RExC_precomp_end - RExC_precomp;					\
									\
    if (!SIZE_ONLY)							\
	SAVEFREESV(RExC_rx_sv);						\
    if (len > RegexLengthToShowInErrorMessages) {			\
	/* chop 10 shorter than the max, to ensure meaning of "..." */	\
	len = RegexLengthToShowInErrorMessages - 10;			\
	ellipses = "...";						\
    }									\
    code;                                                               \
} STMT_END

#define	FAIL(msg) _FAIL(			    \
    Perl_croak(aTHX_ "%s in regex m/%"UTF8f"%s/",	    \
	    msg, UTF8fARG(UTF, len, RExC_precomp), ellipses))

#define	FAIL2(msg,arg) _FAIL(			    \
    Perl_croak(aTHX_ msg " in regex m/%"UTF8f"%s/",	    \
	    arg, UTF8fARG(UTF, len, RExC_precomp), ellipses))

/*
 * Simple_vFAIL -- like FAIL, but marks the current location in the scan
 */
#define	Simple_vFAIL(m) STMT_START {					\
    Perl_croak(aTHX_ "%s" REPORT_LOCATION,				\
	    m, REPORT_LOCATION_ARGS(RExC_parse));	                \
} STMT_END

/*
 * Calls SAVEDESTRUCTOR_X if needed, then Simple_vFAIL()
 */
#define	vFAIL(m) STMT_START {				\
    if (!SIZE_ONLY)					\
	SAVEFREESV(RExC_rx_sv);				\
    Simple_vFAIL(m);					\
} STMT_END

/*
 * Like Simple_vFAIL(), but accepts two arguments.
 */
#define	Simple_vFAIL2(m,a1) STMT_START {			\
    S_re_croak2(aTHX_ UTF, m, REPORT_LOCATION, a1,		\
                      REPORT_LOCATION_ARGS(RExC_parse));	\
} STMT_END

/*
 * Calls SAVEDESTRUCTOR_X if needed, then Simple_vFAIL2().
 */
#define	vFAIL2(m,a1) STMT_START {			\
    if (!SIZE_ONLY)					\
	SAVEFREESV(RExC_rx_sv);				\
    Simple_vFAIL2(m, a1);				\
} STMT_END


/*
 * Like Simple_vFAIL(), but accepts three arguments.
 */
#define	Simple_vFAIL3(m, a1, a2) STMT_START {			\
    S_re_croak2(aTHX_ UTF, m, REPORT_LOCATION, a1, a2,		\
	    REPORT_LOCATION_ARGS(RExC_parse));	                \
} STMT_END

/*
 * Calls SAVEDESTRUCTOR_X if needed, then Simple_vFAIL3().
 */
#define	vFAIL3(m,a1,a2) STMT_START {			\
    if (!SIZE_ONLY)					\
	SAVEFREESV(RExC_rx_sv);				\
    Simple_vFAIL3(m, a1, a2);				\
} STMT_END

/*
 * Like Simple_vFAIL(), but accepts four arguments.
 */
#define	Simple_vFAIL4(m, a1, a2, a3) STMT_START {		\
    S_re_croak2(aTHX_ UTF, m, REPORT_LOCATION, a1, a2, a3,	\
	    REPORT_LOCATION_ARGS(RExC_parse));	                \
} STMT_END

#define	vFAIL4(m,a1,a2,a3) STMT_START {			\
    if (!SIZE_ONLY)					\
	SAVEFREESV(RExC_rx_sv);				\
    Simple_vFAIL4(m, a1, a2, a3);			\
} STMT_END

/* A specialized version of vFAIL2 that works with UTF8f */
#define vFAIL2utf8f(m, a1) STMT_START {             \
    if (!SIZE_ONLY)                                 \
        SAVEFREESV(RExC_rx_sv);                     \
    S_re_croak2(aTHX_ UTF, m, REPORT_LOCATION, a1,  \
            REPORT_LOCATION_ARGS(RExC_parse));      \
} STMT_END

#define vFAIL3utf8f(m, a1, a2) STMT_START {             \
    if (!SIZE_ONLY)                                     \
        SAVEFREESV(RExC_rx_sv);                         \
    S_re_croak2(aTHX_ UTF, m, REPORT_LOCATION, a1, a2,  \
            REPORT_LOCATION_ARGS(RExC_parse));          \
} STMT_END

/* These have asserts in them because of [perl #122671] Many warnings in
 * regcomp.c can occur twice.  If they get output in pass1 and later in that
 * pass, the pattern has to be converted to UTF-8 and the pass restarted, they
 * would get output again.  So they should be output in pass2, and these
 * asserts make sure new warnings follow that paradigm. */

/* m is not necessarily a "literal string", in this macro */
#define reg_warn_non_literal_string(loc, m) STMT_START {                \
    __ASSERT_(PASS2) Perl_warner(aTHX_ packWARN(WARN_REGEXP),           \
                                       "%s" REPORT_LOCATION,            \
                                  m, REPORT_LOCATION_ARGS(loc));        \
} STMT_END

#define	ckWARNreg(loc,m) STMT_START {					\
    __ASSERT_(PASS2) Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP),        \
                                          m REPORT_LOCATION,	        \
	                                  REPORT_LOCATION_ARGS(loc));   \
} STMT_END

#define	vWARN(loc, m) STMT_START {				        \
    __ASSERT_(PASS2) Perl_warner(aTHX_ packWARN(WARN_REGEXP),           \
                                       m REPORT_LOCATION,               \
                                       REPORT_LOCATION_ARGS(loc));      \
} STMT_END

#define	vWARN_dep(loc, m) STMT_START {				        \
    __ASSERT_(PASS2) Perl_warner(aTHX_ packWARN(WARN_DEPRECATED),       \
                                       m REPORT_LOCATION,               \
	                               REPORT_LOCATION_ARGS(loc));      \
} STMT_END

#define	ckWARNdep(loc,m) STMT_START {				        \
    __ASSERT_(PASS2) Perl_ck_warner_d(aTHX_ packWARN(WARN_DEPRECATED),  \
	                                    m REPORT_LOCATION,          \
	                                    REPORT_LOCATION_ARGS(loc)); \
} STMT_END

#define	ckWARNregdep(loc,m) STMT_START {				    \
    __ASSERT_(PASS2) Perl_ck_warner_d(aTHX_ packWARN2(WARN_DEPRECATED,      \
                                                      WARN_REGEXP),         \
	                                     m REPORT_LOCATION,             \
	                                     REPORT_LOCATION_ARGS(loc));    \
} STMT_END

#define	ckWARN2reg_d(loc,m, a1) STMT_START {				    \
    __ASSERT_(PASS2) Perl_ck_warner_d(aTHX_ packWARN(WARN_REGEXP),          \
	                                    m REPORT_LOCATION,              \
	                                    a1, REPORT_LOCATION_ARGS(loc)); \
} STMT_END

#define	ckWARN2reg(loc, m, a1) STMT_START {                                 \
    __ASSERT_(PASS2) Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP),            \
                                          m REPORT_LOCATION,	            \
                                          a1, REPORT_LOCATION_ARGS(loc));   \
} STMT_END

#define	vWARN3(loc, m, a1, a2) STMT_START {				    \
    __ASSERT_(PASS2) Perl_warner(aTHX_ packWARN(WARN_REGEXP),               \
                                       m REPORT_LOCATION,                   \
	                               a1, a2, REPORT_LOCATION_ARGS(loc));  \
} STMT_END

#define	ckWARN3reg(loc, m, a1, a2) STMT_START {				    \
    __ASSERT_(PASS2) Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP),            \
                                          m REPORT_LOCATION,                \
	                                  a1, a2,                           \
                                          REPORT_LOCATION_ARGS(loc));       \
} STMT_END

#define	vWARN4(loc, m, a1, a2, a3) STMT_START {				\
    __ASSERT_(PASS2) Perl_warner(aTHX_ packWARN(WARN_REGEXP),           \
                                       m REPORT_LOCATION,               \
	                               a1, a2, a3,                      \
                                       REPORT_LOCATION_ARGS(loc));      \
} STMT_END

#define	ckWARN4reg(loc, m, a1, a2, a3) STMT_START {			\
    __ASSERT_(PASS2) Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP),        \
                                          m REPORT_LOCATION,            \
	                                  a1, a2, a3,                   \
                                          REPORT_LOCATION_ARGS(loc));   \
} STMT_END

#define	vWARN5(loc, m, a1, a2, a3, a4) STMT_START {			\
    __ASSERT_(PASS2) Perl_warner(aTHX_ packWARN(WARN_REGEXP),           \
                                       m REPORT_LOCATION,		\
	                               a1, a2, a3, a4,                  \
                                       REPORT_LOCATION_ARGS(loc));      \
} STMT_END

/* Macros for recording node offsets.   20001227 mjd@@plover.com
 * Nodes are numbered 1, 2, 3, 4.  Node #n's position is recorded in
 * element 2*n-1 of the array.  Element #2n holds the byte length node #n.
 * Element 0 holds the number n.
 * Position is 1 indexed.
 */
#ifndef RE_TRACK_PATTERN_OFFSETS
#define Set_Node_Offset_To_R(node,byte)
#define Set_Node_Offset(node,byte)
#define Set_Cur_Node_Offset
#define Set_Node_Length_To_R(node,len)
#define Set_Node_Length(node,len)
#define Set_Node_Cur_Length(node,start)
#define Node_Offset(n)
#define Node_Length(n)
#define Set_Node_Offset_Length(node,offset,len)
#define ProgLen(ri) ri->u.proglen
#define SetProgLen(ri,x) ri->u.proglen = x
#else
#define ProgLen(ri) ri->u.offsets[0]
#define SetProgLen(ri,x) ri->u.offsets[0] = x
#define Set_Node_Offset_To_R(node,byte) STMT_START {			\
    if (! SIZE_ONLY) {							\
	MJD_OFFSET_DEBUG(("** (%d) offset of node %d is %d.\n",		\
		    __LINE__, (int)(node), (int)(byte)));		\
	if((node) < 0) {						\
	    Perl_croak(aTHX_ "value of node is %d in Offset macro",     \
                                         (int)(node));                  \
	} else {							\
	    RExC_offsets[2*(node)-1] = (byte);				\
	}								\
    }									\
} STMT_END

#define Set_Node_Offset(node,byte) \
    Set_Node_Offset_To_R((node)-RExC_emit_start, (byte)-RExC_start)
#define Set_Cur_Node_Offset Set_Node_Offset(RExC_emit, RExC_parse)

#define Set_Node_Length_To_R(node,len) STMT_START {			\
    if (! SIZE_ONLY) {							\
	MJD_OFFSET_DEBUG(("** (%d) size of node %d is %d.\n",		\
		__LINE__, (int)(node), (int)(len)));			\
	if((node) < 0) {						\
	    Perl_croak(aTHX_ "value of node is %d in Length macro",     \
                                         (int)(node));                  \
	} else {							\
	    RExC_offsets[2*(node)] = (len);				\
	}								\
    }									\
} STMT_END

#define Set_Node_Length(node,len) \
    Set_Node_Length_To_R((node)-RExC_emit_start, len)
#define Set_Node_Cur_Length(node, start)                \
    Set_Node_Length(node, RExC_parse - start)

/* Get offsets and lengths */
#define Node_Offset(n) (RExC_offsets[2*((n)-RExC_emit_start)-1])
#define Node_Length(n) (RExC_offsets[2*((n)-RExC_emit_start)])

#define Set_Node_Offset_Length(node,offset,len) STMT_START {	\
    Set_Node_Offset_To_R((node)-RExC_emit_start, (offset));	\
    Set_Node_Length_To_R((node)-RExC_emit_start, (len));	\
} STMT_END
#endif

#if PERL_ENABLE_EXPERIMENTAL_REGEX_OPTIMISATIONS
#define EXPERIMENTAL_INPLACESCAN
#endif /*PERL_ENABLE_EXPERIMENTAL_REGEX_OPTIMISATIONS*/

#ifdef DEBUGGING
int
Perl_re_printf(pTHX_ const char *fmt, ...)
{
    va_list ap;
    int result;
    PerlIO *f= Perl_debug_log;
    PERL_ARGS_ASSERT_RE_PRINTF;
    va_start(ap, fmt);
    result = PerlIO_vprintf(f, fmt, ap);
    va_end(ap);
    return result;
}

int
Perl_re_indentf(pTHX_ const char *fmt, U32 depth, ...)
{
    va_list ap;
    int result;
    PerlIO *f= Perl_debug_log;
    PERL_ARGS_ASSERT_RE_INDENTF;
    va_start(ap, depth);
    PerlIO_printf(f, "%*s", ( (int)depth % 20 ) * 2, "");
    result = PerlIO_vprintf(f, fmt, ap);
    va_end(ap);
    return result;
}
#endif /* DEBUGGING */

#define DEBUG_RExC_seen()                                                   \
        DEBUG_OPTIMISE_MORE_r({                                             \
            Perl_re_printf( aTHX_ "RExC_seen: ");                                       \
                                                                            \
            if (RExC_seen & REG_ZERO_LEN_SEEN)                              \
                Perl_re_printf( aTHX_ "REG_ZERO_LEN_SEEN ");                            \
                                                                            \
            if (RExC_seen & REG_LOOKBEHIND_SEEN)                            \
                Perl_re_printf( aTHX_ "REG_LOOKBEHIND_SEEN ");                          \
                                                                            \
            if (RExC_seen & REG_GPOS_SEEN)                                  \
                Perl_re_printf( aTHX_ "REG_GPOS_SEEN ");                                \
                                                                            \
            if (RExC_seen & REG_RECURSE_SEEN)                               \
                Perl_re_printf( aTHX_ "REG_RECURSE_SEEN ");                             \
                                                                            \
            if (RExC_seen & REG_TOP_LEVEL_BRANCHES_SEEN)                    \
                Perl_re_printf( aTHX_ "REG_TOP_LEVEL_BRANCHES_SEEN ");                  \
                                                                            \
            if (RExC_seen & REG_VERBARG_SEEN)                               \
                Perl_re_printf( aTHX_ "REG_VERBARG_SEEN ");                             \
                                                                            \
            if (RExC_seen & REG_CUTGROUP_SEEN)                              \
                Perl_re_printf( aTHX_ "REG_CUTGROUP_SEEN ");                            \
                                                                            \
            if (RExC_seen & REG_RUN_ON_COMMENT_SEEN)                        \
                Perl_re_printf( aTHX_ "REG_RUN_ON_COMMENT_SEEN ");                      \
                                                                            \
            if (RExC_seen & REG_UNFOLDED_MULTI_SEEN)                        \
                Perl_re_printf( aTHX_ "REG_UNFOLDED_MULTI_SEEN ");                      \
                                                                            \
            if (RExC_seen & REG_UNBOUNDED_QUANTIFIER_SEEN)                  \
                Perl_re_printf( aTHX_ "REG_UNBOUNDED_QUANTIFIER_SEEN ");                \
                                                                            \
            Perl_re_printf( aTHX_ "\n");                                                \
        });

#define DEBUG_SHOW_STUDY_FLAG(flags,flag) \
  if ((flags) & flag) Perl_re_printf( aTHX_  "%s ", #flag)

#define DEBUG_SHOW_STUDY_FLAGS(flags,open_str,close_str)                    \
    if ( ( flags ) ) {                                                      \
        Perl_re_printf( aTHX_  "%s", open_str);                                         \
        DEBUG_SHOW_STUDY_FLAG(flags,SF_FL_BEFORE_SEOL);                     \
        DEBUG_SHOW_STUDY_FLAG(flags,SF_FL_BEFORE_MEOL);                     \
        DEBUG_SHOW_STUDY_FLAG(flags,SF_IS_INF);                             \
        DEBUG_SHOW_STUDY_FLAG(flags,SF_HAS_PAR);                            \
        DEBUG_SHOW_STUDY_FLAG(flags,SF_IN_PAR);                             \
        DEBUG_SHOW_STUDY_FLAG(flags,SF_HAS_EVAL);                           \
        DEBUG_SHOW_STUDY_FLAG(flags,SCF_DO_SUBSTR);                         \
        DEBUG_SHOW_STUDY_FLAG(flags,SCF_DO_STCLASS_AND);                    \
        DEBUG_SHOW_STUDY_FLAG(flags,SCF_DO_STCLASS_OR);                     \
        DEBUG_SHOW_STUDY_FLAG(flags,SCF_DO_STCLASS);                        \
        DEBUG_SHOW_STUDY_FLAG(flags,SCF_WHILEM_VISITED_POS);                \
        DEBUG_SHOW_STUDY_FLAG(flags,SCF_TRIE_RESTUDY);                      \
        DEBUG_SHOW_STUDY_FLAG(flags,SCF_SEEN_ACCEPT);                       \
        DEBUG_SHOW_STUDY_FLAG(flags,SCF_TRIE_DOING_RESTUDY);                \
        DEBUG_SHOW_STUDY_FLAG(flags,SCF_IN_DEFINE);                         \
        Perl_re_printf( aTHX_  "%s", close_str);                                        \
    }


#define DEBUG_STUDYDATA(str,data,depth)                              \
DEBUG_OPTIMISE_MORE_r(if(data){                                      \
    Perl_re_indentf( aTHX_  "" str "Pos:%"IVdf"/%"IVdf                           \
        " Flags: 0x%"UVXf,                                           \
        depth,                                                       \
        (IV)((data)->pos_min),                                       \
        (IV)((data)->pos_delta),                                     \
        (UV)((data)->flags)                                          \
    );                                                               \
    DEBUG_SHOW_STUDY_FLAGS((data)->flags," [ ","]");                 \
    Perl_re_printf( aTHX_                                                        \
        " Whilem_c: %"IVdf" Lcp: %"IVdf" %s",                        \
        (IV)((data)->whilem_c),                                      \
        (IV)((data)->last_closep ? *((data)->last_closep) : -1),     \
        is_inf ? "INF " : ""                                         \
    );                                                               \
    if ((data)->last_found)                                          \
        Perl_re_printf( aTHX_                                                    \
            "Last:'%s' %"IVdf":%"IVdf"/%"IVdf" %sFixed:'%s' @@ %"IVdf \
            " %sFloat: '%s' @@ %"IVdf"/%"IVdf"",                      \
            SvPVX_const((data)->last_found),                         \
            (IV)((data)->last_end),                                  \
            (IV)((data)->last_start_min),                            \
            (IV)((data)->last_start_max),                            \
            ((data)->longest &&                                      \
             (data)->longest==&((data)->longest_fixed)) ? "*" : "",  \
            SvPVX_const((data)->longest_fixed),                      \
            (IV)((data)->offset_fixed),                              \
            ((data)->longest &&                                      \
             (data)->longest==&((data)->longest_float)) ? "*" : "",  \
            SvPVX_const((data)->longest_float),                      \
            (IV)((data)->offset_float_min),                          \
            (IV)((data)->offset_float_max)                           \
        );                                                           \
    Perl_re_printf( aTHX_ "\n");                                                 \
});


/* =========================================================
 * BEGIN edit_distance stuff.
 *
 * This calculates how many single character changes of any type are needed to
 * transform a string into another one.  It is taken from version 3.1 of
 *
 * https://metacpan.org/pod/Text::Levenshtein::Damerau::XS
 */

/* Our unsorted dictionary linked list.   */
/* Note we use UVs, not chars. */

struct dictionary{
  UV key;
  UV value;
  struct dictionary* next;
};
typedef struct dictionary item;


PERL_STATIC_INLINE item*
push(UV key,item* curr)
{
    item* head;
    Newxz(head, 1, item);
    head->key = key;
    head->value = 0;
    head->next = curr;
    return head;
}


PERL_STATIC_INLINE item*
find(item* head, UV key)
{
    item* iterator = head;
    while (iterator){
        if (iterator->key == key){
            return iterator;
        }
        iterator = iterator->next;
    }

    return NULL;
}

PERL_STATIC_INLINE item*
uniquePush(item* head,UV key)
{
    item* iterator = head;

    while (iterator){
        if (iterator->key == key) {
            return head;
        }
        iterator = iterator->next;
    }

    return push(key,head);
}

PERL_STATIC_INLINE void
dict_free(item* head)
{
    item* iterator = head;

    while (iterator) {
        item* temp = iterator;
        iterator = iterator->next;
        Safefree(temp);
    }

    head = NULL;
}

/* End of Dictionary Stuff */

/* All calculations/work are done here */
STATIC int
S_edit_distance(const UV* src,
                const UV* tgt,
                const STRLEN x,             /* length of src[] */
                const STRLEN y,             /* length of tgt[] */
                const SSize_t maxDistance
)
{
    item *head = NULL;
    UV swapCount,swapScore,targetCharCount,i,j;
    UV *scores;
    UV score_ceil = x + y;

    PERL_ARGS_ASSERT_EDIT_DISTANCE;

    /* intialize matrix start values */
    Newxz(scores, ( (x + 2) * (y + 2)), UV);
    scores[0] = score_ceil;
    scores[1 * (y + 2) + 0] = score_ceil;
    scores[0 * (y + 2) + 1] = score_ceil;
    scores[1 * (y + 2) + 1] = 0;
    head = uniquePush(uniquePush(head,src[0]),tgt[0]);

    /* work loops    */
    /* i = src index */
    /* j = tgt index */
    for (i=1;i<=x;i++) {
        if (i < x)
            head = uniquePush(head,src[i]);
        scores[(i+1) * (y + 2) + 1] = i;
        scores[(i+1) * (y + 2) + 0] = score_ceil;
        swapCount = 0;

        for (j=1;j<=y;j++) {
            if (i == 1) {
                if(j < y)
                head = uniquePush(head,tgt[j]);
                scores[1 * (y + 2) + (j + 1)] = j;
                scores[0 * (y + 2) + (j + 1)] = score_ceil;
            }

            targetCharCount = find(head,tgt[j-1])->value;
            swapScore = scores[targetCharCount * (y + 2) + swapCount] + i - targetCharCount - 1 + j - swapCount;

            if (src[i-1] != tgt[j-1]){
                scores[(i+1) * (y + 2) + (j + 1)] = MIN(swapScore,(MIN(scores[i * (y + 2) + j], MIN(scores[(i+1) * (y + 2) + j], scores[i * (y + 2) + (j + 1)])) + 1));
            }
            else {
                swapCount = j;
                scores[(i+1) * (y + 2) + (j + 1)] = MIN(scores[i * (y + 2) + j], swapScore);
            }
        }

        find(head,src[i-1])->value = i;
    }

    {
        IV score = scores[(x+1) * (y + 2) + (y + 1)];
        dict_free(head);
        Safefree(scores);
        return (maxDistance != 0 && maxDistance < score)?(-1):score;
    }
}

/* END of edit_distance() stuff
 * ========================================================= */

/* is c a control character for which we have a mnemonic? */
#define isMNEMONIC_CNTRL(c) _IS_MNEMONIC_CNTRL_ONLY_FOR_USE_BY_REGCOMP_DOT_C(c)

STATIC const char *
S_cntrl_to_mnemonic(const U8 c)
{
    /* Returns the mnemonic string that represents character 'c', if one
     * exists; NULL otherwise.  The only ones that exist for the purposes of
     * this routine are a few control characters */

    switch (c) {
        case '\a':       return "\\a";
        case '\b':       return "\\b";
        case ESC_NATIVE: return "\\e";
        case '\f':       return "\\f";
        case '\n':       return "\\n";
        case '\r':       return "\\r";
        case '\t':       return "\\t";
    }

    return NULL;
}

/* Mark that we cannot extend a found fixed substring at this point.
   Update the longest found anchored substring and the longest found
   floating substrings if needed. */

STATIC void
S_scan_commit(pTHX_ const RExC_state_t *pRExC_state, scan_data_t *data,
                    SSize_t *minlenp, int is_inf)
{
    const STRLEN l = CHR_SVLEN(data->last_found);
    const STRLEN old_l = CHR_SVLEN(*data->longest);
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_SCAN_COMMIT;

    if ((l >= old_l) && ((l > old_l) || (data->flags & SF_BEFORE_EOL))) {
	SvSetMagicSV(*data->longest, data->last_found);
	if (*data->longest == data->longest_fixed) {
	    data->offset_fixed = l ? data->last_start_min : data->pos_min;
	    if (data->flags & SF_BEFORE_EOL)
		data->flags
		    |= ((data->flags & SF_BEFORE_EOL) << SF_FIX_SHIFT_EOL);
	    else
		data->flags &= ~SF_FIX_BEFORE_EOL;
	    data->minlen_fixed=minlenp;
	    data->lookbehind_fixed=0;
	}
	else { /* *data->longest == data->longest_float */
	    data->offset_float_min = l ? data->last_start_min : data->pos_min;
	    data->offset_float_max = (l
                          ? data->last_start_max
                          : (data->pos_delta > SSize_t_MAX - data->pos_min
					 ? SSize_t_MAX
					 : data->pos_min + data->pos_delta));
	    if (is_inf
		 || (STRLEN)data->offset_float_max > (STRLEN)SSize_t_MAX)
		data->offset_float_max = SSize_t_MAX;
	    if (data->flags & SF_BEFORE_EOL)
		data->flags
		    |= ((data->flags & SF_BEFORE_EOL) << SF_FL_SHIFT_EOL);
	    else
		data->flags &= ~SF_FL_BEFORE_EOL;
            data->minlen_float=minlenp;
            data->lookbehind_float=0;
	}
    }
    SvCUR_set(data->last_found, 0);
    {
	SV * const sv = data->last_found;
	if (SvUTF8(sv) && SvMAGICAL(sv)) {
	    MAGIC * const mg = mg_find(sv, PERL_MAGIC_utf8);
	    if (mg)
		mg->mg_len = 0;
	}
    }
    data->last_end = -1;
    data->flags &= ~SF_BEFORE_EOL;
    DEBUG_STUDYDATA("commit: ",data,0);
}

/* An SSC is just a regnode_charclass_posix with an extra field: the inversion
 * list that describes which code points it matches */

STATIC void
S_ssc_anything(pTHX_ regnode_ssc *ssc)
{
    /* Set the SSC 'ssc' to match an empty string or any code point */

    PERL_ARGS_ASSERT_SSC_ANYTHING;

    assert(is_ANYOF_SYNTHETIC(ssc));

    ssc->invlist = sv_2mortal(_new_invlist(2)); /* mortalize so won't leak */
    _append_range_to_invlist(ssc->invlist, 0, UV_MAX);
    ANYOF_FLAGS(ssc) |= SSC_MATCHES_EMPTY_STRING;  /* Plus matches empty */
}

STATIC int
S_ssc_is_anything(const regnode_ssc *ssc)
{
    /* Returns TRUE if the SSC 'ssc' can match the empty string and any code
     * point; FALSE otherwise.  Thus, this is used to see if using 'ssc' buys
     * us anything: if the function returns TRUE, 'ssc' hasn't been restricted
     * in any way, so there's no point in using it */

    UV start, end;
    bool ret;

    PERL_ARGS_ASSERT_SSC_IS_ANYTHING;

    assert(is_ANYOF_SYNTHETIC(ssc));

    if (! (ANYOF_FLAGS(ssc) & SSC_MATCHES_EMPTY_STRING)) {
        return FALSE;
    }

    /* See if the list consists solely of the range 0 - Infinity */
    invlist_iterinit(ssc->invlist);
    ret = invlist_iternext(ssc->invlist, &start, &end)
          && start == 0
          && end == UV_MAX;

    invlist_iterfinish(ssc->invlist);

    if (ret) {
        return TRUE;
    }

    /* If e.g., both \w and \W are set, matches everything */
    if (ANYOF_POSIXL_SSC_TEST_ANY_SET(ssc)) {
        int i;
        for (i = 0; i < ANYOF_POSIXL_MAX; i += 2) {
            if (ANYOF_POSIXL_TEST(ssc, i) && ANYOF_POSIXL_TEST(ssc, i+1)) {
                return TRUE;
            }
        }
    }

    return FALSE;
}

STATIC void
S_ssc_init(pTHX_ const RExC_state_t *pRExC_state, regnode_ssc *ssc)
{
    /* Initializes the SSC 'ssc'.  This includes setting it to match an empty
     * string, any code point, or any posix class under locale */

    PERL_ARGS_ASSERT_SSC_INIT;

    Zero(ssc, 1, regnode_ssc);
    set_ANYOF_SYNTHETIC(ssc);
    ARG_SET(ssc, ANYOF_ONLY_HAS_BITMAP);
    ssc_anything(ssc);

    /* If any portion of the regex is to operate under locale rules that aren't
     * fully known at compile time, initialization includes it.  The reason
     * this isn't done for all regexes is that the optimizer was written under
     * the assumption that locale was all-or-nothing.  Given the complexity and
     * lack of documentation in the optimizer, and that there are inadequate
     * test cases for locale, many parts of it may not work properly, it is
     * safest to avoid locale unless necessary. */
    if (RExC_contains_locale) {
	ANYOF_POSIXL_SETALL(ssc);
    }
    else {
	ANYOF_POSIXL_ZERO(ssc);
    }
}

STATIC int
S_ssc_is_cp_posixl_init(const RExC_state_t *pRExC_state,
                        const regnode_ssc *ssc)
{
    /* Returns TRUE if the SSC 'ssc' is in its initial state with regard only
     * to the list of code points matched, and locale posix classes; hence does
     * not check its flags) */

    UV start, end;
    bool ret;

    PERL_ARGS_ASSERT_SSC_IS_CP_POSIXL_INIT;

    assert(is_ANYOF_SYNTHETIC(ssc));

    invlist_iterinit(ssc->invlist);
    ret = invlist_iternext(ssc->invlist, &start, &end)
          && start == 0
          && end == UV_MAX;

    invlist_iterfinish(ssc->invlist);

    if (! ret) {
        return FALSE;
    }

    if (RExC_contains_locale && ! ANYOF_POSIXL_SSC_TEST_ALL_SET(ssc)) {
        return FALSE;
    }

    return TRUE;
}

STATIC SV*
S_get_ANYOF_cp_list_for_ssc(pTHX_ const RExC_state_t *pRExC_state,
                               const regnode_charclass* const node)
{
    /* Returns a mortal inversion list defining which code points are matched
     * by 'node', which is of type ANYOF.  Handles complementing the result if
     * appropriate.  If some code points aren't knowable at this time, the
     * returned list must, and will, contain every code point that is a
     * possibility. */

    SV* invlist = NULL;
    SV* only_utf8_locale_invlist = NULL;
    unsigned int i;
    const U32 n = ARG(node);
    bool new_node_has_latin1 = FALSE;

    PERL_ARGS_ASSERT_GET_ANYOF_CP_LIST_FOR_SSC;

    /* Look at the data structure created by S_set_ANYOF_arg() */
    if (n != ANYOF_ONLY_HAS_BITMAP) {
        SV * const rv = MUTABLE_SV(RExC_rxi->data->data[n]);
        AV * const av = MUTABLE_AV(SvRV(rv));
        SV **const ary = AvARRAY(av);
        assert(RExC_rxi->data->what[n] == 's');

        if (ary[1] && ary[1] != &PL_sv_undef) { /* Has compile-time swash */
            invlist = sv_2mortal(invlist_clone(_get_swash_invlist(ary[1])));
        }
        else if (ary[0] && ary[0] != &PL_sv_undef) {

            /* Here, no compile-time swash, and there are things that won't be
             * known until runtime -- we have to assume it could be anything */
            invlist = sv_2mortal(_new_invlist(1));
            return _add_range_to_invlist(invlist, 0, UV_MAX);
        }
        else if (ary[3] && ary[3] != &PL_sv_undef) {

            /* Here no compile-time swash, and no run-time only data.  Use the
             * node's inversion list */
            invlist = sv_2mortal(invlist_clone(ary[3]));
        }

        /* Get the code points valid only under UTF-8 locales */
        if ((ANYOF_FLAGS(node) & ANYOFL_FOLD)
            && ary[2] && ary[2] != &PL_sv_undef)
        {
            only_utf8_locale_invlist = ary[2];
        }
    }

    if (! invlist) {
        invlist = sv_2mortal(_new_invlist(0));
    }

    /* An ANYOF node contains a bitmap for the first NUM_ANYOF_CODE_POINTS
     * code points, and an inversion list for the others, but if there are code
     * points that should match only conditionally on the target string being
     * UTF-8, those are placed in the inversion list, and not the bitmap.
     * Since there are circumstances under which they could match, they are
     * included in the SSC.  But if the ANYOF node is to be inverted, we have
     * to exclude them here, so that when we invert below, the end result
     * actually does include them.  (Think about "\xe0" =~ /[^\xc0]/di;).  We
     * have to do this here before we add the unconditionally matched code
     * points */
    if (ANYOF_FLAGS(node) & ANYOF_INVERT) {
        _invlist_intersection_complement_2nd(invlist,
                                             PL_UpperLatin1,
                                             &invlist);
    }

    /* Add in the points from the bit map */
    for (i = 0; i < NUM_ANYOF_CODE_POINTS; i++) {
        if (ANYOF_BITMAP_TEST(node, i)) {
            unsigned int start = i++;

            for (; i < NUM_ANYOF_CODE_POINTS && ANYOF_BITMAP_TEST(node, i); ++i) {
                /* empty */
            }
            invlist = _add_range_to_invlist(invlist, start, i-1);
            new_node_has_latin1 = TRUE;
        }
    }

    /* If this can match all upper Latin1 code points, have to add them
     * as well.  But don't add them if inverting, as when that gets done below,
     * it would exclude all these characters, including the ones it shouldn't
     * that were added just above */
    if (! (ANYOF_FLAGS(node) & ANYOF_INVERT) && OP(node) == ANYOFD
        && (ANYOF_FLAGS(node) & ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER))
    {
        _invlist_union(invlist, PL_UpperLatin1, &invlist);
    }

    /* Similarly for these */
    if (ANYOF_FLAGS(node) & ANYOF_MATCHES_ALL_ABOVE_BITMAP) {
        _invlist_union_complement_2nd(invlist, PL_InBitmap, &invlist);
    }

    if (ANYOF_FLAGS(node) & ANYOF_INVERT) {
        _invlist_invert(invlist);
    }
    else if (new_node_has_latin1 && ANYOF_FLAGS(node) & ANYOFL_FOLD) {

        /* Under /li, any 0-255 could fold to any other 0-255, depending on the
         * locale.  We can skip this if there are no 0-255 at all. */
        _invlist_union(invlist, PL_Latin1, &invlist);
    }

    /* Similarly add the UTF-8 locale possible matches.  These have to be
     * deferred until after the non-UTF-8 locale ones are taken care of just
     * above, or it leads to wrong results under ANYOF_INVERT */
    if (only_utf8_locale_invlist) {
        _invlist_union_maybe_complement_2nd(invlist,
                                            only_utf8_locale_invlist,
                                            ANYOF_FLAGS(node) & ANYOF_INVERT,
                                            &invlist);
    }

    return invlist;
}

/* These two functions currently do the exact same thing */
#define ssc_init_zero		ssc_init

#define ssc_add_cp(ssc, cp)   ssc_add_range((ssc), (cp), (cp))
#define ssc_match_all_cp(ssc) ssc_add_range(ssc, 0, UV_MAX)

/* 'AND' a given class with another one.  Can create false positives.  'ssc'
 * should not be inverted.  'and_with->flags & ANYOF_MATCHES_POSIXL' should be
 * 0 if 'and_with' is a regnode_charclass instead of a regnode_ssc. */

STATIC void
S_ssc_and(pTHX_ const RExC_state_t *pRExC_state, regnode_ssc *ssc,
                const regnode_charclass *and_with)
{
    /* Accumulate into SSC 'ssc' its 'AND' with 'and_with', which is either
     * another SSC or a regular ANYOF class.  Can create false positives. */

    SV* anded_cp_list;
    U8  anded_flags;

    PERL_ARGS_ASSERT_SSC_AND;

    assert(is_ANYOF_SYNTHETIC(ssc));

    /* 'and_with' is used as-is if it too is an SSC; otherwise have to extract
     * the code point inversion list and just the relevant flags */
    if (is_ANYOF_SYNTHETIC(and_with)) {
        anded_cp_list = ((regnode_ssc *)and_with)->invlist;
        anded_flags = ANYOF_FLAGS(and_with);

        /* XXX This is a kludge around what appears to be deficiencies in the
         * optimizer.  If we make S_ssc_anything() add in the WARN_SUPER flag,
         * there are paths through the optimizer where it doesn't get weeded
         * out when it should.  And if we don't make some extra provision for
         * it like the code just below, it doesn't get added when it should.
         * This solution is to add it only when AND'ing, which is here, and
         * only when what is being AND'ed is the pristine, original node
         * matching anything.  Thus it is like adding it to ssc_anything() but
         * only when the result is to be AND'ed.  Probably the same solution
         * could be adopted for the same problem we have with /l matching,
         * which is solved differently in S_ssc_init(), and that would lead to
         * fewer false positives than that solution has.  But if this solution
         * creates bugs, the consequences are only that a warning isn't raised
         * that should be; while the consequences for having /l bugs is
         * incorrect matches */
        if (ssc_is_anything((regnode_ssc *)and_with)) {
            anded_flags |= ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER;
        }
    }
    else {
        anded_cp_list = get_ANYOF_cp_list_for_ssc(pRExC_state, and_with);
        if (OP(and_with) == ANYOFD) {
            anded_flags = ANYOF_FLAGS(and_with) & ANYOF_COMMON_FLAGS;
        }
        else {
            anded_flags = ANYOF_FLAGS(and_with)
            &( ANYOF_COMMON_FLAGS
              |ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER
              |ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP);
            if (ANYOFL_UTF8_LOCALE_REQD(ANYOF_FLAGS(and_with))) {
                anded_flags &=
                    ANYOFL_SHARED_UTF8_LOCALE_fold_HAS_MATCHES_nonfold_REQD;
            }
        }
    }

    ANYOF_FLAGS(ssc) &= anded_flags;

    /* Below, C1 is the list of code points in 'ssc'; P1, its posix classes.
     * C2 is the list of code points in 'and-with'; P2, its posix classes.
     * 'and_with' may be inverted.  When not inverted, we have the situation of
     * computing:
     *  (C1 | P1) & (C2 | P2)
     *                     =  (C1 & (C2 | P2)) | (P1 & (C2 | P2))
     *                     =  ((C1 & C2) | (C1 & P2)) | ((P1 & C2) | (P1 & P2))
     *                    <=  ((C1 & C2) |       P2)) | ( P1       | (P1 & P2))
     *                    <=  ((C1 & C2) | P1 | P2)
     * Alternatively, the last few steps could be:
     *                     =  ((C1 & C2) | (C1 & P2)) | ((P1 & C2) | (P1 & P2))
     *                    <=  ((C1 & C2) |  C1      ) | (      C2  | (P1 & P2))
     *                    <=  (C1 | C2 | (P1 & P2))
     * We favor the second approach if either P1 or P2 is non-empty.  This is
     * because these components are a barrier to doing optimizations, as what
     * they match cannot be known until the moment of matching as they are
     * dependent on the current locale, 'AND"ing them likely will reduce or
     * eliminate them.
     * But we can do better if we know that C1,P1 are in their initial state (a
     * frequent occurrence), each matching everything:
     *  (<everything>) & (C2 | P2) =  C2 | P2
     * Similarly, if C2,P2 are in their initial state (again a frequent
     * occurrence), the result is a no-op
     *  (C1 | P1) & (<everything>) =  C1 | P1
     *
     * Inverted, we have
     *  (C1 | P1) & ~(C2 | P2)  =  (C1 | P1) & (~C2 & ~P2)
     *                          =  (C1 & (~C2 & ~P2)) | (P1 & (~C2 & ~P2))
     *                         <=  (C1 & ~C2) | (P1 & ~P2)
     * */

    if ((ANYOF_FLAGS(and_with) & ANYOF_INVERT)
        && ! is_ANYOF_SYNTHETIC(and_with))
    {
        unsigned int i;

        ssc_intersection(ssc,
                         anded_cp_list,
                         FALSE /* Has already been inverted */
                         );

        /* If either P1 or P2 is empty, the intersection will be also; can skip
         * the loop */
        if (! (ANYOF_FLAGS(and_with) & ANYOF_MATCHES_POSIXL)) {
            ANYOF_POSIXL_ZERO(ssc);
        }
        else if (ANYOF_POSIXL_SSC_TEST_ANY_SET(ssc)) {

            /* Note that the Posix class component P from 'and_with' actually
             * looks like:
             *      P = Pa | Pb | ... | Pn
             * where each component is one posix class, such as in [\w\s].
             * Thus
             *      ~P = ~(Pa | Pb | ... | Pn)
             *         = ~Pa & ~Pb & ... & ~Pn
             *        <= ~Pa | ~Pb | ... | ~Pn
             * The last is something we can easily calculate, but unfortunately
             * is likely to have many false positives.  We could do better
             * in some (but certainly not all) instances if two classes in
             * P have known relationships.  For example
             *      :lower: <= :alpha: <= :alnum: <= \w <= :graph: <= :print:
             * So
             *      :lower: & :print: = :lower:
             * And similarly for classes that must be disjoint.  For example,
             * since \s and \w can have no elements in common based on rules in
             * the POSIX standard,
             *      \w & ^\S = nothing
             * Unfortunately, some vendor locales do not meet the Posix
             * standard, in particular almost everything by Microsoft.
             * The loop below just changes e.g., \w into \W and vice versa */

            regnode_charclass_posixl temp;
            int add = 1;    /* To calculate the index of the complement */

            ANYOF_POSIXL_ZERO(&temp);
            for (i = 0; i < ANYOF_MAX; i++) {
                assert(i % 2 != 0
                       || ! ANYOF_POSIXL_TEST((regnode_charclass_posixl*) and_with, i)
                       || ! ANYOF_POSIXL_TEST((regnode_charclass_posixl*) and_with, i + 1));

                if (ANYOF_POSIXL_TEST((regnode_charclass_posixl*) and_with, i)) {
                    ANYOF_POSIXL_SET(&temp, i + add);
                }
                add = 0 - add; /* 1 goes to -1; -1 goes to 1 */
            }
            ANYOF_POSIXL_AND(&temp, ssc);

        } /* else ssc already has no posixes */
    } /* else: Not inverted.  This routine is a no-op if 'and_with' is an SSC
         in its initial state */
    else if (! is_ANYOF_SYNTHETIC(and_with)
             || ! ssc_is_cp_posixl_init(pRExC_state, (regnode_ssc *)and_with))
    {
        /* But if 'ssc' is in its initial state, the result is just 'and_with';
         * copy it over 'ssc' */
        if (ssc_is_cp_posixl_init(pRExC_state, ssc)) {
            if (is_ANYOF_SYNTHETIC(and_with)) {
                StructCopy(and_with, ssc, regnode_ssc);
            }
            else {
                ssc->invlist = anded_cp_list;
                ANYOF_POSIXL_ZERO(ssc);
                if (ANYOF_FLAGS(and_with) & ANYOF_MATCHES_POSIXL) {
                    ANYOF_POSIXL_OR((regnode_charclass_posixl*) and_with, ssc);
                }
            }
        }
        else if (ANYOF_POSIXL_SSC_TEST_ANY_SET(ssc)
                 || (ANYOF_FLAGS(and_with) & ANYOF_MATCHES_POSIXL))
        {
            /* One or the other of P1, P2 is non-empty. */
            if (ANYOF_FLAGS(and_with) & ANYOF_MATCHES_POSIXL) {
                ANYOF_POSIXL_AND((regnode_charclass_posixl*) and_with, ssc);
            }
            ssc_union(ssc, anded_cp_list, FALSE);
        }
        else { /* P1 = P2 = empty */
            ssc_intersection(ssc, anded_cp_list, FALSE);
        }
    }
}

STATIC void
S_ssc_or(pTHX_ const RExC_state_t *pRExC_state, regnode_ssc *ssc,
               const regnode_charclass *or_with)
{
    /* Accumulate into SSC 'ssc' its 'OR' with 'or_with', which is either
     * another SSC or a regular ANYOF class.  Can create false positives if
     * 'or_with' is to be inverted. */

    SV* ored_cp_list;
    U8 ored_flags;

    PERL_ARGS_ASSERT_SSC_OR;

    assert(is_ANYOF_SYNTHETIC(ssc));

    /* 'or_with' is used as-is if it too is an SSC; otherwise have to extract
     * the code point inversion list and just the relevant flags */
    if (is_ANYOF_SYNTHETIC(or_with)) {
        ored_cp_list = ((regnode_ssc*) or_with)->invlist;
        ored_flags = ANYOF_FLAGS(or_with);
    }
    else {
        ored_cp_list = get_ANYOF_cp_list_for_ssc(pRExC_state, or_with);
        ored_flags = ANYOF_FLAGS(or_with) & ANYOF_COMMON_FLAGS;
        if (OP(or_with) != ANYOFD) {
            ored_flags
            |= ANYOF_FLAGS(or_with)
             & ( ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER
                |ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP);
            if (ANYOFL_UTF8_LOCALE_REQD(ANYOF_FLAGS(or_with))) {
                ored_flags |=
                    ANYOFL_SHARED_UTF8_LOCALE_fold_HAS_MATCHES_nonfold_REQD;
            }
        }
    }

    ANYOF_FLAGS(ssc) |= ored_flags;

    /* Below, C1 is the list of code points in 'ssc'; P1, its posix classes.
     * C2 is the list of code points in 'or-with'; P2, its posix classes.
     * 'or_with' may be inverted.  When not inverted, we have the simple
     * situation of computing:
     *  (C1 | P1) | (C2 | P2)  =  (C1 | C2) | (P1 | P2)
     * If P1|P2 yields a situation with both a class and its complement are
     * set, like having both \w and \W, this matches all code points, and we
     * can delete these from the P component of the ssc going forward.  XXX We
     * might be able to delete all the P components, but I (khw) am not certain
     * about this, and it is better to be safe.
     *
     * Inverted, we have
     *  (C1 | P1) | ~(C2 | P2)  =  (C1 | P1) | (~C2 & ~P2)
     *                         <=  (C1 | P1) | ~C2
     *                         <=  (C1 | ~C2) | P1
     * (which results in actually simpler code than the non-inverted case)
     * */

    if ((ANYOF_FLAGS(or_with) & ANYOF_INVERT)
        && ! is_ANYOF_SYNTHETIC(or_with))
    {
        /* We ignore P2, leaving P1 going forward */
    }   /* else  Not inverted */
    else if (ANYOF_FLAGS(or_with) & ANYOF_MATCHES_POSIXL) {
        ANYOF_POSIXL_OR((regnode_charclass_posixl*)or_with, ssc);
        if (ANYOF_POSIXL_SSC_TEST_ANY_SET(ssc)) {
            unsigned int i;
            for (i = 0; i < ANYOF_MAX; i += 2) {
                if (ANYOF_POSIXL_TEST(ssc, i) && ANYOF_POSIXL_TEST(ssc, i + 1))
                {
                    ssc_match_all_cp(ssc);
                    ANYOF_POSIXL_CLEAR(ssc, i);
                    ANYOF_POSIXL_CLEAR(ssc, i+1);
                }
            }
        }
    }

    ssc_union(ssc,
              ored_cp_list,
              FALSE /* Already has been inverted */
              );
}

PERL_STATIC_INLINE void
S_ssc_union(pTHX_ regnode_ssc *ssc, SV* const invlist, const bool invert2nd)
{
    PERL_ARGS_ASSERT_SSC_UNION;

    assert(is_ANYOF_SYNTHETIC(ssc));

    _invlist_union_maybe_complement_2nd(ssc->invlist,
                                        invlist,
                                        invert2nd,
                                        &ssc->invlist);
}

PERL_STATIC_INLINE void
S_ssc_intersection(pTHX_ regnode_ssc *ssc,
                         SV* const invlist,
                         const bool invert2nd)
{
    PERL_ARGS_ASSERT_SSC_INTERSECTION;

    assert(is_ANYOF_SYNTHETIC(ssc));

    _invlist_intersection_maybe_complement_2nd(ssc->invlist,
                                               invlist,
                                               invert2nd,
                                               &ssc->invlist);
}

PERL_STATIC_INLINE void
S_ssc_add_range(pTHX_ regnode_ssc *ssc, const UV start, const UV end)
{
    PERL_ARGS_ASSERT_SSC_ADD_RANGE;

    assert(is_ANYOF_SYNTHETIC(ssc));

    ssc->invlist = _add_range_to_invlist(ssc->invlist, start, end);
}

PERL_STATIC_INLINE void
S_ssc_cp_and(pTHX_ regnode_ssc *ssc, const UV cp)
{
    /* AND just the single code point 'cp' into the SSC 'ssc' */

    SV* cp_list = _new_invlist(2);

    PERL_ARGS_ASSERT_SSC_CP_AND;

    assert(is_ANYOF_SYNTHETIC(ssc));

    cp_list = add_cp_to_invlist(cp_list, cp);
    ssc_intersection(ssc, cp_list,
                     FALSE /* Not inverted */
                     );
    SvREFCNT_dec_NN(cp_list);
}

PERL_STATIC_INLINE void
S_ssc_clear_locale(regnode_ssc *ssc)
{
    /* Set the SSC 'ssc' to not match any locale things */
    PERL_ARGS_ASSERT_SSC_CLEAR_LOCALE;

    assert(is_ANYOF_SYNTHETIC(ssc));

    ANYOF_POSIXL_ZERO(ssc);
    ANYOF_FLAGS(ssc) &= ~ANYOF_LOCALE_FLAGS;
}

#define NON_OTHER_COUNT   NON_OTHER_COUNT_FOR_USE_ONLY_BY_REGCOMP_DOT_C

STATIC bool
S_is_ssc_worth_it(const RExC_state_t * pRExC_state, const regnode_ssc * ssc)
{
    /* The synthetic start class is used to hopefully quickly winnow down
     * places where a pattern could start a match in the target string.  If it
     * doesn't really narrow things down that much, there isn't much point to
     * having the overhead of using it.  This function uses some very crude
     * heuristics to decide if to use the ssc or not.
     *
     * It returns TRUE if 'ssc' rules out more than half what it considers to
     * be the "likely" possible matches, but of course it doesn't know what the
     * actual things being matched are going to be; these are only guesses
     *
     * For /l matches, it assumes that the only likely matches are going to be
     *      in the 0-255 range, uniformly distributed, so half of that is 127
     * For /a and /d matches, it assumes that the likely matches will be just
     *      the ASCII range, so half of that is 63
     * For /u and there isn't anything matching above the Latin1 range, it
     *      assumes that that is the only range likely to be matched, and uses
     *      half that as the cut-off: 127.  If anything matches above Latin1,
     *      it assumes that all of Unicode could match (uniformly), except for
     *      non-Unicode code points and things in the General Category "Other"
     *      (unassigned, private use, surrogates, controls and formats).  This
     *      is a much large number. */

    U32 count = 0;      /* Running total of number of code points matched by
                           'ssc' */
    UV start, end;      /* Start and end points of current range in inversion
                           list */
    const U32 max_code_points = (LOC)
                                ?  256
                                : ((   ! UNI_SEMANTICS
                                     || invlist_highest(ssc->invlist) < 256)
                                  ? 128
                                  : NON_OTHER_COUNT);
    const U32 max_match = max_code_points / 2;

    PERL_ARGS_ASSERT_IS_SSC_WORTH_IT;

    invlist_iterinit(ssc->invlist);
    while (invlist_iternext(ssc->invlist, &start, &end)) {
        if (start >= max_code_points) {
            break;
        }
        end = MIN(end, max_code_points - 1);
        count += end - start + 1;
        if (count >= max_match) {
            invlist_iterfinish(ssc->invlist);
            return FALSE;
        }
    }

    return TRUE;
}


STATIC void
S_ssc_finalize(pTHX_ RExC_state_t *pRExC_state, regnode_ssc *ssc)
{
    /* The inversion list in the SSC is marked mortal; now we need a more
     * permanent copy, which is stored the same way that is done in a regular
     * ANYOF node, with the first NUM_ANYOF_CODE_POINTS code points in a bit
     * map */

    SV* invlist = invlist_clone(ssc->invlist);

    PERL_ARGS_ASSERT_SSC_FINALIZE;

    assert(is_ANYOF_SYNTHETIC(ssc));

    /* The code in this file assumes that all but these flags aren't relevant
     * to the SSC, except SSC_MATCHES_EMPTY_STRING, which should be cleared
     * by the time we reach here */
    assert(! (ANYOF_FLAGS(ssc)
        & ~( ANYOF_COMMON_FLAGS
            |ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER
            |ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP)));

    populate_ANYOF_from_invlist( (regnode *) ssc, &invlist);

    set_ANYOF_arg(pRExC_state, (regnode *) ssc, invlist,
                                NULL, NULL, NULL, FALSE);

    /* Make sure is clone-safe */
    ssc->invlist = NULL;

    if (ANYOF_POSIXL_SSC_TEST_ANY_SET(ssc)) {
        ANYOF_FLAGS(ssc) |= ANYOF_MATCHES_POSIXL;
    }

    if (RExC_contains_locale) {
        OP(ssc) = ANYOFL;
    }

    assert(! (ANYOF_FLAGS(ssc) & ANYOF_LOCALE_FLAGS) || RExC_contains_locale);
}

#define TRIE_LIST_ITEM(state,idx) (trie->states[state].trans.list)[ idx ]
#define TRIE_LIST_CUR(state)  ( TRIE_LIST_ITEM( state, 0 ).forid )
#define TRIE_LIST_LEN(state) ( TRIE_LIST_ITEM( state, 0 ).newstate )
#define TRIE_LIST_USED(idx)  ( trie->states[state].trans.list         \
                               ? (TRIE_LIST_CUR( idx ) - 1)           \
                               : 0 )


#ifdef DEBUGGING
/*
   dump_trie(trie,widecharmap,revcharmap)
   dump_trie_interim_list(trie,widecharmap,revcharmap,next_alloc)
   dump_trie_interim_table(trie,widecharmap,revcharmap,next_alloc)

   These routines dump out a trie in a somewhat readable format.
   The _interim_ variants are used for debugging the interim
   tables that are used to generate the final compressed
   representation which is what dump_trie expects.

   Part of the reason for their existence is to provide a form
   of documentation as to how the different representations function.

*/

/*
  Dumps the final compressed table form of the trie to Perl_debug_log.
  Used for debugging make_trie().
*/

STATIC void
S_dump_trie(pTHX_ const struct _reg_trie_data *trie, HV *widecharmap,
	    AV *revcharmap, U32 depth)
{
    U32 state;
    SV *sv=sv_newmortal();
    int colwidth= widecharmap ? 6 : 4;
    U16 word;
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_DUMP_TRIE;

    Perl_re_indentf( aTHX_  "Char : %-6s%-6s%-4s ",
        depth+1, "Match","Base","Ofs" );

    for( state = 0 ; state < trie->uniquecharcount ; state++ ) {
	SV ** const tmp = av_fetch( revcharmap, state, 0);
        if ( tmp ) {
            Perl_re_printf( aTHX_  "%*s",
                colwidth,
                pv_pretty(sv, SvPV_nolen_const(*tmp), SvCUR(*tmp), colwidth,
	                    PL_colors[0], PL_colors[1],
	                    (SvUTF8(*tmp) ? PERL_PV_ESCAPE_UNI : 0) |
	                    PERL_PV_ESCAPE_FIRSTCHAR
                )
            );
        }
    }
    Perl_re_printf( aTHX_  "\n");
    Perl_re_indentf( aTHX_ "State|-----------------------", depth+1);

    for( state = 0 ; state < trie->uniquecharcount ; state++ )
        Perl_re_printf( aTHX_  "%.*s", colwidth, "--------");
    Perl_re_printf( aTHX_  "\n");

    for( state = 1 ; state < trie->statecount ; state++ ) {
	const U32 base = trie->states[ state ].trans.base;

        Perl_re_indentf( aTHX_  "#%4"UVXf"|", depth+1, (UV)state);

        if ( trie->states[ state ].wordnum ) {
            Perl_re_printf( aTHX_  " W%4X", trie->states[ state ].wordnum );
        } else {
            Perl_re_printf( aTHX_  "%6s", "" );
        }

        Perl_re_printf( aTHX_  " @@%4"UVXf" ", (UV)base );

        if ( base ) {
            U32 ofs = 0;

            while( ( base + ofs  < trie->uniquecharcount ) ||
                   ( base + ofs - trie->uniquecharcount < trie->lasttrans
                     && trie->trans[ base + ofs - trie->uniquecharcount ].check
                                                                    != state))
                    ofs++;

            Perl_re_printf( aTHX_  "+%2"UVXf"[ ", (UV)ofs);

            for ( ofs = 0 ; ofs < trie->uniquecharcount ; ofs++ ) {
                if ( ( base + ofs >= trie->uniquecharcount )
                        && ( base + ofs - trie->uniquecharcount
                                                        < trie->lasttrans )
                        && trie->trans[ base + ofs
                                    - trie->uniquecharcount ].check == state )
                {
                   Perl_re_printf( aTHX_  "%*"UVXf, colwidth,
                    (UV)trie->trans[ base + ofs - trie->uniquecharcount ].next
                   );
                } else {
                    Perl_re_printf( aTHX_  "%*s",colwidth,"   ." );
                }
            }

            Perl_re_printf( aTHX_  "]");

        }
        Perl_re_printf( aTHX_  "\n" );
    }
    Perl_re_indentf( aTHX_  "word_info N:(prev,len)=",
                                depth);
    for (word=1; word <= trie->wordcount; word++) {
        Perl_re_printf( aTHX_  " %d:(%d,%d)",
	    (int)word, (int)(trie->wordinfo[word].prev),
	    (int)(trie->wordinfo[word].len));
    }
    Perl_re_printf( aTHX_  "\n" );
}
/*
  Dumps a fully constructed but uncompressed trie in list form.
  List tries normally only are used for construction when the number of
  possible chars (trie->uniquecharcount) is very high.
  Used for debugging make_trie().
*/
STATIC void
S_dump_trie_interim_list(pTHX_ const struct _reg_trie_data *trie,
			 HV *widecharmap, AV *revcharmap, U32 next_alloc,
			 U32 depth)
{
    U32 state;
    SV *sv=sv_newmortal();
    int colwidth= widecharmap ? 6 : 4;
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_DUMP_TRIE_INTERIM_LIST;

    /* print out the table precompression.  */
    Perl_re_indentf( aTHX_  "State :Word | Transition Data\n",
            depth+1 );
    Perl_re_indentf( aTHX_  "%s",
            depth+1, "------:-----+-----------------\n" );

    for( state=1 ; state < next_alloc ; state ++ ) {
        U16 charid;

        Perl_re_indentf( aTHX_  " %4"UVXf" :",
            depth+1, (UV)state  );
        if ( ! trie->states[ state ].wordnum ) {
            Perl_re_printf( aTHX_  "%5s| ","");
        } else {
            Perl_re_printf( aTHX_  "W%4x| ",
                trie->states[ state ].wordnum
            );
        }
        for( charid = 1 ; charid <= TRIE_LIST_USED( state ) ; charid++ ) {
	    SV ** const tmp = av_fetch( revcharmap,
                                        TRIE_LIST_ITEM(state,charid).forid, 0);
	    if ( tmp ) {
                Perl_re_printf( aTHX_  "%*s:%3X=%4"UVXf" | ",
                    colwidth,
                    pv_pretty(sv, SvPV_nolen_const(*tmp), SvCUR(*tmp),
                              colwidth,
                              PL_colors[0], PL_colors[1],
                              (SvUTF8(*tmp) ? PERL_PV_ESCAPE_UNI : 0)
                              | PERL_PV_ESCAPE_FIRSTCHAR
                    ) ,
                    TRIE_LIST_ITEM(state,charid).forid,
                    (UV)TRIE_LIST_ITEM(state,charid).newstate
                );
                if (!(charid % 10))
                    Perl_re_printf( aTHX_  "\n%*s| ",
                        (int)((depth * 2) + 14), "");
            }
        }
        Perl_re_printf( aTHX_  "\n");
    }
}

/*
  Dumps a fully constructed but uncompressed trie in table form.
  This is the normal DFA style state transition table, with a few
  twists to facilitate compression later.
  Used for debugging make_trie().
*/
STATIC void
S_dump_trie_interim_table(pTHX_ const struct _reg_trie_data *trie,
			  HV *widecharmap, AV *revcharmap, U32 next_alloc,
			  U32 depth)
{
    U32 state;
    U16 charid;
    SV *sv=sv_newmortal();
    int colwidth= widecharmap ? 6 : 4;
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_DUMP_TRIE_INTERIM_TABLE;

    /*
       print out the table precompression so that we can do a visual check
       that they are identical.
     */

    Perl_re_indentf( aTHX_  "Char : ", depth+1 );

    for( charid = 0 ; charid < trie->uniquecharcount ; charid++ ) {
	SV ** const tmp = av_fetch( revcharmap, charid, 0);
        if ( tmp ) {
            Perl_re_printf( aTHX_  "%*s",
                colwidth,
                pv_pretty(sv, SvPV_nolen_const(*tmp), SvCUR(*tmp), colwidth,
	                    PL_colors[0], PL_colors[1],
	                    (SvUTF8(*tmp) ? PERL_PV_ESCAPE_UNI : 0) |
	                    PERL_PV_ESCAPE_FIRSTCHAR
                )
            );
        }
    }

    Perl_re_printf( aTHX_ "\n");
    Perl_re_indentf( aTHX_  "State+-", depth+1 );

    for( charid=0 ; charid < trie->uniquecharcount ; charid++ ) {
        Perl_re_printf( aTHX_  "%.*s", colwidth,"--------");
    }

    Perl_re_printf( aTHX_  "\n" );

    for( state=1 ; state < next_alloc ; state += trie->uniquecharcount ) {

        Perl_re_indentf( aTHX_  "%4"UVXf" : ",
            depth+1,
            (UV)TRIE_NODENUM( state ) );

        for( charid = 0 ; charid < trie->uniquecharcount ; charid++ ) {
            UV v=(UV)SAFE_TRIE_NODENUM( trie->trans[ state + charid ].next );
            if (v)
                Perl_re_printf( aTHX_  "%*"UVXf, colwidth, v );
            else
                Perl_re_printf( aTHX_  "%*s", colwidth, "." );
        }
        if ( ! trie->states[ TRIE_NODENUM( state ) ].wordnum ) {
            Perl_re_printf( aTHX_  " (%4"UVXf")\n",
                                            (UV)trie->trans[ state ].check );
        } else {
            Perl_re_printf( aTHX_  " (%4"UVXf") W%4X\n",
                                            (UV)trie->trans[ state ].check,
            trie->states[ TRIE_NODENUM( state ) ].wordnum );
        }
    }
}

#endif


/* make_trie(startbranch,first,last,tail,word_count,flags,depth)
  startbranch: the first branch in the whole branch sequence
  first      : start branch of sequence of branch-exact nodes.
	       May be the same as startbranch
  last       : Thing following the last branch.
	       May be the same as tail.
  tail       : item following the branch sequence
  count      : words in the sequence
  flags      : currently the OP() type we will be building one of /EXACT(|F|FA|FU|FU_SS|L|FLU8)/
  depth      : indent depth

Inplace optimizes a sequence of 2 or more Branch-Exact nodes into a TRIE node.

A trie is an N'ary tree where the branches are determined by digital
decomposition of the key. IE, at the root node you look up the 1st character and
follow that branch repeat until you find the end of the branches. Nodes can be
marked as "accepting" meaning they represent a complete word. Eg:

  /he|she|his|hers/

would convert into the following structure. Numbers represent states, letters
following numbers represent valid transitions on the letter from that state, if
the number is in square brackets it represents an accepting state, otherwise it
will be in parenthesis.

      +-h->+-e->[3]-+-r->(8)-+-s->[9]
      |    |
      |   (2)
      |    |
     (1)   +-i->(6)-+-s->[7]
      |
      +-s->(3)-+-h->(4)-+-e->[5]

      Accept Word Mapping: 3=>1 (he),5=>2 (she), 7=>3 (his), 9=>4 (hers)

This shows that when matching against the string 'hers' we will begin at state 1
read 'h' and move to state 2, read 'e' and move to state 3 which is accepting,
then read 'r' and go to state 8 followed by 's' which takes us to state 9 which
is also accepting. Thus we know that we can match both 'he' and 'hers' with a
single traverse. We store a mapping from accepting to state to which word was
matched, and then when we have multiple possibilities we try to complete the
rest of the regex in the order in which they occurred in the alternation.

The only prior NFA like behaviour that would be changed by the TRIE support is
the silent ignoring of duplicate alternations which are of the form:

 / (DUPE|DUPE) X? (?{ ... }) Y /x

Thus EVAL blocks following a trie may be called a different number of times with
and without the optimisation. With the optimisations dupes will be silently
ignored. This inconsistent behaviour of EVAL type nodes is well established as
the following demonstrates:

 'words'=~/(word|word|word)(?{ print $1 })[xyz]/

which prints out 'word' three times, but

 'words'=~/(word|word|word)(?{ print $1 })S/

which doesnt print it out at all. This is due to other optimisations kicking in.

Example of what happens on a structural level:

The regexp /(ac|ad|ab)+/ will produce the following debug output:

   1: CURLYM[1] {1,32767}(18)
   5:   BRANCH(8)
   6:     EXACT <ac>(16)
   8:   BRANCH(11)
   9:     EXACT <ad>(16)
  11:   BRANCH(14)
  12:     EXACT <ab>(16)
  16:   SUCCEED(0)
  17:   NOTHING(18)
  18: END(0)

This would be optimizable with startbranch=5, first=5, last=16, tail=16
and should turn into:

   1: CURLYM[1] {1,32767}(18)
   5:   TRIE(16)
	[Words:3 Chars Stored:6 Unique Chars:4 States:5 NCP:1]
	  <ac>
	  <ad>
	  <ab>
  16:   SUCCEED(0)
  17:   NOTHING(18)
  18: END(0)

Cases where tail != last would be like /(?foo|bar)baz/:

   1: BRANCH(4)
   2:   EXACT <foo>(8)
   4: BRANCH(7)
   5:   EXACT <bar>(8)
   7: TAIL(8)
   8: EXACT <baz>(10)
  10: END(0)

which would be optimizable with startbranch=1, first=1, last=7, tail=8
and would end up looking like:

    1: TRIE(8)
      [Words:2 Chars Stored:6 Unique Chars:5 States:7 NCP:1]
	<foo>
	<bar>
   7: TAIL(8)
   8: EXACT <baz>(10)
  10: END(0)

    d = uvchr_to_utf8_flags(d, uv, 0);

is the recommended Unicode-aware way of saying

    *(d++) = uv;
*/

#define TRIE_STORE_REVCHAR(val)                                            \
    STMT_START {                                                           \
	if (UTF) {							   \
            SV *zlopp = newSV(UTF8_MAXBYTES);				   \
	    unsigned char *flrbbbbb = (unsigned char *) SvPVX(zlopp);	   \
            unsigned const char *const kapow = uvchr_to_utf8(flrbbbbb, val); \
	    SvCUR_set(zlopp, kapow - flrbbbbb);				   \
	    SvPOK_on(zlopp);						   \
	    SvUTF8_on(zlopp);						   \
	    av_push(revcharmap, zlopp);					   \
	} else {							   \
            char ooooff = (char)val;                                           \
	    av_push(revcharmap, newSVpvn(&ooooff, 1));			   \
	}								   \
        } STMT_END

/* This gets the next character from the input, folding it if not already
 * folded. */
#define TRIE_READ_CHAR STMT_START {                                           \
    wordlen++;                                                                \
    if ( UTF ) {                                                              \
        /* if it is UTF then it is either already folded, or does not need    \
         * folding */                                                         \
        uvc = valid_utf8_to_uvchr( (const U8*) uc, &len);                     \
    }                                                                         \
    else if (folder == PL_fold_latin1) {                                      \
        /* This folder implies Unicode rules, which in the range expressible  \
         *  by not UTF is the lower case, with the two exceptions, one of     \
         *  which should have been taken care of before calling this */       \
        assert(*uc != LATIN_SMALL_LETTER_SHARP_S);                            \
        uvc = toLOWER_L1(*uc);                                                \
        if (UNLIKELY(uvc == MICRO_SIGN)) uvc = GREEK_SMALL_LETTER_MU;         \
        len = 1;                                                              \
    } else {                                                                  \
        /* raw data, will be folded later if needed */                        \
        uvc = (U32)*uc;                                                       \
        len = 1;                                                              \
    }                                                                         \
} STMT_END



#define TRIE_LIST_PUSH(state,fid,ns) STMT_START {               \
    if ( TRIE_LIST_CUR( state ) >=TRIE_LIST_LEN( state ) ) {    \
	U32 ging = TRIE_LIST_LEN( state ) *= 2;                 \
	Renew( trie->states[ state ].trans.list, ging, reg_trie_trans_le ); \
    }                                                           \
    TRIE_LIST_ITEM( state, TRIE_LIST_CUR( state ) ).forid = fid;     \
    TRIE_LIST_ITEM( state, TRIE_LIST_CUR( state ) ).newstate = ns;   \
    TRIE_LIST_CUR( state )++;                                   \
} STMT_END

#define TRIE_LIST_NEW(state) STMT_START {                       \
    Newxz( trie->states[ state ].trans.list,               \
	4, reg_trie_trans_le );                                 \
     TRIE_LIST_CUR( state ) = 1;                                \
     TRIE_LIST_LEN( state ) = 4;                                \
} STMT_END

#define TRIE_HANDLE_WORD(state) STMT_START {                    \
    U16 dupe= trie->states[ state ].wordnum;                    \
    regnode * const noper_next = regnext( noper );              \
                                                                \
    DEBUG_r({                                                   \
        /* store the word for dumping */                        \
        SV* tmp;                                                \
        if (OP(noper) != NOTHING)                               \
            tmp = newSVpvn_utf8(STRING(noper), STR_LEN(noper), UTF);	\
        else                                                    \
            tmp = newSVpvn_utf8( "", 0, UTF );			\
        av_push( trie_words, tmp );                             \
    });                                                         \
                                                                \
    curword++;                                                  \
    trie->wordinfo[curword].prev   = 0;                         \
    trie->wordinfo[curword].len    = wordlen;                   \
    trie->wordinfo[curword].accept = state;                     \
                                                                \
    if ( noper_next < tail ) {                                  \
        if (!trie->jump)                                        \
            trie->jump = (U16 *) PerlMemShared_calloc( word_count + 1, \
                                                 sizeof(U16) ); \
        trie->jump[curword] = (U16)(noper_next - convert);      \
        if (!jumper)                                            \
            jumper = noper_next;                                \
        if (!nextbranch)                                        \
            nextbranch= regnext(cur);                           \
    }                                                           \
                                                                \
    if ( dupe ) {                                               \
        /* It's a dupe. Pre-insert into the wordinfo[].prev   */\
        /* chain, so that when the bits of chain are later    */\
        /* linked together, the dups appear in the chain      */\
	trie->wordinfo[curword].prev = trie->wordinfo[dupe].prev; \
	trie->wordinfo[dupe].prev = curword;                    \
    } else {                                                    \
        /* we haven't inserted this word yet.                */ \
        trie->states[ state ].wordnum = curword;                \
    }                                                           \
} STMT_END


#define TRIE_TRANS_STATE(state,base,ucharcount,charid,special)		\
     ( ( base + charid >=  ucharcount					\
         && base + charid < ubound					\
         && state == trie->trans[ base - ucharcount + charid ].check	\
         && trie->trans[ base - ucharcount + charid ].next )		\
           ? trie->trans[ base - ucharcount + charid ].next		\
           : ( state==1 ? special : 0 )					\
      )

#define MADE_TRIE       1
#define MADE_JUMP_TRIE  2
#define MADE_EXACT_TRIE 4

STATIC I32
S_make_trie(pTHX_ RExC_state_t *pRExC_state, regnode *startbranch,
                  regnode *first, regnode *last, regnode *tail,
                  U32 word_count, U32 flags, U32 depth)
{
    /* first pass, loop through and scan words */
    reg_trie_data *trie;
    HV *widecharmap = NULL;
    AV *revcharmap = newAV();
    regnode *cur;
    STRLEN len = 0;
    UV uvc = 0;
    U16 curword = 0;
    U32 next_alloc = 0;
    regnode *jumper = NULL;
    regnode *nextbranch = NULL;
    regnode *convert = NULL;
    U32 *prev_states; /* temp array mapping each state to previous one */
    /* we just use folder as a flag in utf8 */
    const U8 * folder = NULL;

#ifdef DEBUGGING
    const U32 data_slot = add_data( pRExC_state, STR_WITH_LEN("tuuu"));
    AV *trie_words = NULL;
    /* along with revcharmap, this only used during construction but both are
     * useful during debugging so we store them in the struct when debugging.
     */
#else
    const U32 data_slot = add_data( pRExC_state, STR_WITH_LEN("tu"));
    STRLEN trie_charcount=0;
#endif
    SV *re_trie_maxbuff;
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_MAKE_TRIE;
#ifndef DEBUGGING
    PERL_UNUSED_ARG(depth);
#endif

    switch (flags) {
        case EXACT: case EXACTL: break;
	case EXACTFA:
        case EXACTFU_SS:
	case EXACTFU:
	case EXACTFLU8: folder = PL_fold_latin1; break;
	case EXACTF:  folder = PL_fold; break;
        default: Perl_croak( aTHX_ "panic! In trie construction, unknown node type %u %s", (unsigned) flags, PL_reg_name[flags] );
    }

    trie = (reg_trie_data *) PerlMemShared_calloc( 1, sizeof(reg_trie_data) );
    trie->refcount = 1;
    trie->startstate = 1;
    trie->wordcount = word_count;
    RExC_rxi->data->data[ data_slot ] = (void*)trie;
    trie->charmap = (U16 *) PerlMemShared_calloc( 256, sizeof(U16) );
    if (flags == EXACT || flags == EXACTL)
	trie->bitmap = (char *) PerlMemShared_calloc( ANYOF_BITMAP_SIZE, 1 );
    trie->wordinfo = (reg_trie_wordinfo *) PerlMemShared_calloc(
                       trie->wordcount+1, sizeof(reg_trie_wordinfo));

    DEBUG_r({
        trie_words = newAV();
    });

    re_trie_maxbuff = get_sv(RE_TRIE_MAXBUF_NAME, 1);
    assert(re_trie_maxbuff);
    if (!SvIOK(re_trie_maxbuff)) {
        sv_setiv(re_trie_maxbuff, RE_TRIE_MAXBUF_INIT);
    }
    DEBUG_TRIE_COMPILE_r({
        Perl_re_indentf( aTHX_
          "make_trie start==%d, first==%d, last==%d, tail==%d depth=%d\n",
          depth+1,
          REG_NODE_NUM(startbranch),REG_NODE_NUM(first),
          REG_NODE_NUM(last), REG_NODE_NUM(tail), (int)depth);
    });

   /* Find the node we are going to overwrite */
    if ( first == startbranch && OP( last ) != BRANCH ) {
        /* whole branch chain */
        convert = first;
    } else {
        /* branch sub-chain */
        convert = NEXTOPER( first );
    }

    /*  -- First loop and Setup --

       We first traverse the branches and scan each word to determine if it
       contains widechars, and how many unique chars there are, this is
       important as we have to build a table with at least as many columns as we
       have unique chars.

       We use an array of integers to represent the character codes 0..255
       (trie->charmap) and we use a an HV* to store Unicode characters. We use
       the native representation of the character value as the key and IV's for
       the coded index.

       *TODO* If we keep track of how many times each character is used we can
       remap the columns so that the table compression later on is more
       efficient in terms of memory by ensuring the most common value is in the
       middle and the least common are on the outside.  IMO this would be better
       than a most to least common mapping as theres a decent chance the most
       common letter will share a node with the least common, meaning the node
       will not be compressible. With a middle is most common approach the worst
       case is when we have the least common nodes twice.

     */

    for ( cur = first ; cur < last ; cur = regnext( cur ) ) {
        regnode *noper = NEXTOPER( cur );
        const U8 *uc;
        const U8 *e;
        int foldlen = 0;
        U32 wordlen      = 0;         /* required init */
        STRLEN minchars = 0;
        STRLEN maxchars = 0;
        bool set_bit = trie->bitmap ? 1 : 0; /*store the first char in the
                                               bitmap?*/

        if (OP(noper) == NOTHING) {
            regnode *noper_next= regnext(noper);
            if (noper_next < tail)
                noper= noper_next;
        }

        if ( noper < tail && ( OP(noper) == flags || ( flags == EXACTFU && OP(noper) == EXACTFU_SS ) ) ) {
            uc= (U8*)STRING(noper);
            e= uc + STR_LEN(noper);
        } else {
            trie->minlen= 0;
            continue;
        }


        if ( set_bit ) { /* bitmap only alloced when !(UTF&&Folding) */
            TRIE_BITMAP_SET(trie,*uc); /* store the raw first byte
                                          regardless of encoding */
            if (OP( noper ) == EXACTFU_SS) {
                /* false positives are ok, so just set this */
                TRIE_BITMAP_SET(trie, LATIN_SMALL_LETTER_SHARP_S);
            }
        }
        for ( ; uc < e ; uc += len ) {  /* Look at each char in the current
                                           branch */
            TRIE_CHARCOUNT(trie)++;
            TRIE_READ_CHAR;

            /* TRIE_READ_CHAR returns the current character, or its fold if /i
             * is in effect.  Under /i, this character can match itself, or
             * anything that folds to it.  If not under /i, it can match just
             * itself.  Most folds are 1-1, for example k, K, and KELVIN SIGN
             * all fold to k, and all are single characters.   But some folds
             * expand to more than one character, so for example LATIN SMALL
             * LIGATURE FFI folds to the three character sequence 'ffi'.  If
             * the string beginning at 'uc' is 'ffi', it could be matched by
             * three characters, or just by the one ligature character. (It
             * could also be matched by two characters: LATIN SMALL LIGATURE FF
             * followed by 'i', or by 'f' followed by LATIN SMALL LIGATURE FI).
             * (Of course 'I' and/or 'F' instead of 'i' and 'f' can also
             * match.)  The trie needs to know the minimum and maximum number
             * of characters that could match so that it can use size alone to
             * quickly reject many match attempts.  The max is simple: it is
             * the number of folded characters in this branch (since a fold is
             * never shorter than what folds to it. */

            maxchars++;

            /* And the min is equal to the max if not under /i (indicated by
             * 'folder' being NULL), or there are no multi-character folds.  If
             * there is a multi-character fold, the min is incremented just
             * once, for the character that folds to the sequence.  Each
             * character in the sequence needs to be added to the list below of
             * characters in the trie, but we count only the first towards the
             * min number of characters needed.  This is done through the
             * variable 'foldlen', which is returned by the macros that look
             * for these sequences as the number of bytes the sequence
             * occupies.  Each time through the loop, we decrement 'foldlen' by
             * how many bytes the current char occupies.  Only when it reaches
             * 0 do we increment 'minchars' or look for another multi-character
             * sequence. */
            if (folder == NULL) {
                minchars++;
            }
            else if (foldlen > 0) {
                foldlen -= (UTF) ? UTF8SKIP(uc) : 1;
            }
            else {
                minchars++;

                /* See if *uc is the beginning of a multi-character fold.  If
                 * so, we decrement the length remaining to look at, to account
                 * for the current character this iteration.  (We can use 'uc'
                 * instead of the fold returned by TRIE_READ_CHAR because for
                 * non-UTF, the latin1_safe macro is smart enough to account
                 * for all the unfolded characters, and because for UTF, the
                 * string will already have been folded earlier in the
                 * compilation process */
                if (UTF) {
                    if ((foldlen = is_MULTI_CHAR_FOLD_utf8_safe(uc, e))) {
                        foldlen -= UTF8SKIP(uc);
                    }
                }
                else if ((foldlen = is_MULTI_CHAR_FOLD_latin1_safe(uc, e))) {
                    foldlen--;
                }
            }

            /* The current character (and any potential folds) should be added
             * to the possible matching characters for this position in this
             * branch */
            if ( uvc < 256 ) {
                if ( folder ) {
                    U8 folded= folder[ (U8) uvc ];
                    if ( !trie->charmap[ folded ] ) {
                        trie->charmap[ folded ]=( ++trie->uniquecharcount );
                        TRIE_STORE_REVCHAR( folded );
                    }
                }
                if ( !trie->charmap[ uvc ] ) {
                    trie->charmap[ uvc ]=( ++trie->uniquecharcount );
                    TRIE_STORE_REVCHAR( uvc );
                }
                if ( set_bit ) {
		    /* store the codepoint in the bitmap, and its folded
		     * equivalent. */
                    TRIE_BITMAP_SET(trie, uvc);

		    /* store the folded codepoint */
                    if ( folder ) TRIE_BITMAP_SET(trie, folder[(U8) uvc ]);

		    if ( !UTF ) {
			/* store first byte of utf8 representation of
			   variant codepoints */
			if (! UVCHR_IS_INVARIANT(uvc)) {
			    TRIE_BITMAP_SET(trie, UTF8_TWO_BYTE_HI(uvc));
			}
		    }
                    set_bit = 0; /* We've done our bit :-) */
                }
            } else {

                /* XXX We could come up with the list of code points that fold
                 * to this using PL_utf8_foldclosures, except not for
                 * multi-char folds, as there may be multiple combinations
                 * there that could work, which needs to wait until runtime to
                 * resolve (The comment about LIGATURE FFI above is such an
                 * example */

                SV** svpp;
                if ( !widecharmap )
                    widecharmap = newHV();

                svpp = hv_fetch( widecharmap, (char*)&uvc, sizeof( UV ), 1 );

                if ( !svpp )
                    Perl_croak( aTHX_ "error creating/fetching widecharmap entry for 0x%"UVXf, uvc );

                if ( !SvTRUE( *svpp ) ) {
                    sv_setiv( *svpp, ++trie->uniquecharcount );
                    TRIE_STORE_REVCHAR(uvc);
                }
            }
        } /* end loop through characters in this branch of the trie */

        /* We take the min and max for this branch and combine to find the min
         * and max for all branches processed so far */
        if( cur == first ) {
            trie->minlen = minchars;
            trie->maxlen = maxchars;
        } else if (minchars < trie->minlen) {
            trie->minlen = minchars;
        } else if (maxchars > trie->maxlen) {
            trie->maxlen = maxchars;
        }
    } /* end first pass */
    DEBUG_TRIE_COMPILE_r(
        Perl_re_indentf( aTHX_
                "TRIE(%s): W:%d C:%d Uq:%d Min:%d Max:%d\n",
                depth+1,
                ( widecharmap ? "UTF8" : "NATIVE" ), (int)word_count,
		(int)TRIE_CHARCOUNT(trie), trie->uniquecharcount,
		(int)trie->minlen, (int)trie->maxlen )
    );

    /*
        We now know what we are dealing with in terms of unique chars and
        string sizes so we can calculate how much memory a naive
        representation using a flat table  will take. If it's over a reasonable
        limit (as specified by ${^RE_TRIE_MAXBUF}) we use a more memory
        conservative but potentially much slower representation using an array
        of lists.

        At the end we convert both representations into the same compressed
        form that will be used in regexec.c for matching with. The latter
        is a form that cannot be used to construct with but has memory
        properties similar to the list form and access properties similar
        to the table form making it both suitable for fast searches and
        small enough that its feasable to store for the duration of a program.

        See the comment in the code where the compressed table is produced
        inplace from the flat tabe representation for an explanation of how
        the compression works.

    */


    Newx(prev_states, TRIE_CHARCOUNT(trie) + 2, U32);
    prev_states[1] = 0;

    if ( (IV)( ( TRIE_CHARCOUNT(trie) + 1 ) * trie->uniquecharcount + 1)
                                                    > SvIV(re_trie_maxbuff) )
    {
        /*
            Second Pass -- Array Of Lists Representation

            Each state will be represented by a list of charid:state records
            (reg_trie_trans_le) the first such element holds the CUR and LEN
            points of the allocated array. (See defines above).

            We build the initial structure using the lists, and then convert
            it into the compressed table form which allows faster lookups
            (but cant be modified once converted).
        */

        STRLEN transcount = 1;

        DEBUG_TRIE_COMPILE_MORE_r( Perl_re_indentf( aTHX_  "Compiling trie using list compiler\n",
            depth+1));

	trie->states = (reg_trie_state *)
	    PerlMemShared_calloc( TRIE_CHARCOUNT(trie) + 2,
				  sizeof(reg_trie_state) );
        TRIE_LIST_NEW(1);
        next_alloc = 2;

        for ( cur = first ; cur < last ; cur = regnext( cur ) ) {

            regnode *noper   = NEXTOPER( cur );
	    U32 state        = 1;         /* required init */
	    U16 charid       = 0;         /* sanity init */
            U32 wordlen      = 0;         /* required init */

            if (OP(noper) == NOTHING) {
                regnode *noper_next= regnext(noper);
                if (noper_next < tail)
                    noper= noper_next;
            }

            if ( noper < tail && ( OP(noper) == flags || ( flags == EXACTFU && OP(noper) == EXACTFU_SS ) ) ) {
                const U8 *uc= (U8*)STRING(noper);
                const U8 *e= uc + STR_LEN(noper);

                for ( ; uc < e ; uc += len ) {

                    TRIE_READ_CHAR;

                    if ( uvc < 256 ) {
                        charid = trie->charmap[ uvc ];
		    } else {
                        SV** const svpp = hv_fetch( widecharmap,
                                                    (char*)&uvc,
                                                    sizeof( UV ),
                                                    0);
                        if ( !svpp ) {
                            charid = 0;
                        } else {
                            charid=(U16)SvIV( *svpp );
                        }
		    }
                    /* charid is now 0 if we dont know the char read, or
                     * nonzero if we do */
                    if ( charid ) {

                        U16 check;
                        U32 newstate = 0;

                        charid--;
                        if ( !trie->states[ state ].trans.list ) {
                            TRIE_LIST_NEW( state );
			}
                        for ( check = 1;
                              check <= TRIE_LIST_USED( state );
                              check++ )
                        {
                            if ( TRIE_LIST_ITEM( state, check ).forid
                                                                    == charid )
                            {
                                newstate = TRIE_LIST_ITEM( state, check ).newstate;
                                break;
                            }
                        }
                        if ( ! newstate ) {
                            newstate = next_alloc++;
			    prev_states[newstate] = state;
                            TRIE_LIST_PUSH( state, charid, newstate );
                            transcount++;
                        }
                        state = newstate;
                    } else {
                        Perl_croak( aTHX_ "panic! In trie construction, no char mapping for %"IVdf, uvc );
		    }
		}
	    }
            TRIE_HANDLE_WORD(state);

        } /* end second pass */

        /* next alloc is the NEXT state to be allocated */
        trie->statecount = next_alloc;
        trie->states = (reg_trie_state *)
	    PerlMemShared_realloc( trie->states,
				   next_alloc
				   * sizeof(reg_trie_state) );

        /* and now dump it out before we compress it */
        DEBUG_TRIE_COMPILE_MORE_r(dump_trie_interim_list(trie, widecharmap,
							 revcharmap, next_alloc,
							 depth+1)
        );

        trie->trans = (reg_trie_trans *)
	    PerlMemShared_calloc( transcount, sizeof(reg_trie_trans) );
        {
            U32 state;
            U32 tp = 0;
            U32 zp = 0;


            for( state=1 ; state < next_alloc ; state ++ ) {
                U32 base=0;

                /*
                DEBUG_TRIE_COMPILE_MORE_r(
                    Perl_re_printf( aTHX_  "tp: %d zp: %d ",tp,zp)
                );
                */

                if (trie->states[state].trans.list) {
                    U16 minid=TRIE_LIST_ITEM( state, 1).forid;
                    U16 maxid=minid;
		    U16 idx;

                    for( idx = 2 ; idx <= TRIE_LIST_USED( state ) ; idx++ ) {
			const U16 forid = TRIE_LIST_ITEM( state, idx).forid;
			if ( forid < minid ) {
			    minid=forid;
			} else if ( forid > maxid ) {
			    maxid=forid;
			}
                    }
                    if ( transcount < tp + maxid - minid + 1) {
                        transcount *= 2;
			trie->trans = (reg_trie_trans *)
			    PerlMemShared_realloc( trie->trans,
						     transcount
						     * sizeof(reg_trie_trans) );
                        Zero( trie->trans + (transcount / 2),
                              transcount / 2,
                              reg_trie_trans );
                    }
                    base = trie->uniquecharcount + tp - minid;
                    if ( maxid == minid ) {
                        U32 set = 0;
                        for ( ; zp < tp ; zp++ ) {
                            if ( ! trie->trans[ zp ].next ) {
                                base = trie->uniquecharcount + zp - minid;
                                trie->trans[ zp ].next = TRIE_LIST_ITEM( state,
                                                                   1).newstate;
                                trie->trans[ zp ].check = state;
                                set = 1;
                                break;
                            }
                        }
                        if ( !set ) {
                            trie->trans[ tp ].next = TRIE_LIST_ITEM( state,
                                                                   1).newstate;
                            trie->trans[ tp ].check = state;
                            tp++;
                            zp = tp;
                        }
                    } else {
                        for ( idx=1; idx <= TRIE_LIST_USED( state ) ; idx++ ) {
                            const U32 tid = base
                                           - trie->uniquecharcount
                                           + TRIE_LIST_ITEM( state, idx ).forid;
                            trie->trans[ tid ].next = TRIE_LIST_ITEM( state,
                                                                idx ).newstate;
                            trie->trans[ tid ].check = state;
                        }
                        tp += ( maxid - minid + 1 );
                    }
                    Safefree(trie->states[ state ].trans.list);
                }
                /*
                DEBUG_TRIE_COMPILE_MORE_r(
                    Perl_re_printf( aTHX_  " base: %d\n",base);
                );
                */
                trie->states[ state ].trans.base=base;
            }
            trie->lasttrans = tp + 1;
        }
    } else {
        /*
           Second Pass -- Flat Table Representation.

           we dont use the 0 slot of either trans[] or states[] so we add 1 to
           each.  We know that we will need Charcount+1 trans at most to store
           the data (one row per char at worst case) So we preallocate both
           structures assuming worst case.

           We then construct the trie using only the .next slots of the entry
           structs.

           We use the .check field of the first entry of the node temporarily
           to make compression both faster and easier by keeping track of how
           many non zero fields are in the node.

           Since trans are numbered from 1 any 0 pointer in the table is a FAIL
           transition.

           There are two terms at use here: state as a TRIE_NODEIDX() which is
           a number representing the first entry of the node, and state as a
           TRIE_NODENUM() which is the trans number. state 1 is TRIE_NODEIDX(1)
           and TRIE_NODENUM(1), state 2 is TRIE_NODEIDX(2) and TRIE_NODENUM(3)
           if there are 2 entrys per node. eg:

             A B       A B
          1. 2 4    1. 3 7
          2. 0 3    3. 0 5
          3. 0 0    5. 0 0
          4. 0 0    7. 0 0

           The table is internally in the right hand, idx form. However as we
           also have to deal with the states array which is indexed by nodenum
           we have to use TRIE_NODENUM() to convert.

        */
        DEBUG_TRIE_COMPILE_MORE_r( Perl_re_indentf( aTHX_  "Compiling trie using table compiler\n",
            depth+1));

	trie->trans = (reg_trie_trans *)
	    PerlMemShared_calloc( ( TRIE_CHARCOUNT(trie) + 1 )
				  * trie->uniquecharcount + 1,
				  sizeof(reg_trie_trans) );
        trie->states = (reg_trie_state *)
	    PerlMemShared_calloc( TRIE_CHARCOUNT(trie) + 2,
				  sizeof(reg_trie_state) );
        next_alloc = trie->uniquecharcount + 1;


        for ( cur = first ; cur < last ; cur = regnext( cur ) ) {

            regnode *noper   = NEXTOPER( cur );

            U32 state        = 1;         /* required init */

            U16 charid       = 0;         /* sanity init */
            U32 accept_state = 0;         /* sanity init */

            U32 wordlen      = 0;         /* required init */

            if (OP(noper) == NOTHING) {
                regnode *noper_next= regnext(noper);
                if (noper_next < tail)
                    noper= noper_next;
            }

            if ( noper < tail && ( OP(noper) == flags || ( flags == EXACTFU && OP(noper) == EXACTFU_SS ) ) ) {
                const U8 *uc= (U8*)STRING(noper);
                const U8 *e= uc + STR_LEN(noper);

                for ( ; uc < e ; uc += len ) {

                    TRIE_READ_CHAR;

                    if ( uvc < 256 ) {
                        charid = trie->charmap[ uvc ];
                    } else {
                        SV* const * const svpp = hv_fetch( widecharmap,
                                                           (char*)&uvc,
                                                           sizeof( UV ),
                                                           0);
                        charid = svpp ? (U16)SvIV(*svpp) : 0;
                    }
                    if ( charid ) {
                        charid--;
                        if ( !trie->trans[ state + charid ].next ) {
                            trie->trans[ state + charid ].next = next_alloc;
                            trie->trans[ state ].check++;
			    prev_states[TRIE_NODENUM(next_alloc)]
				    = TRIE_NODENUM(state);
                            next_alloc += trie->uniquecharcount;
                        }
                        state = trie->trans[ state + charid ].next;
                    } else {
                        Perl_croak( aTHX_ "panic! In trie construction, no char mapping for %"IVdf, uvc );
                    }
                    /* charid is now 0 if we dont know the char read, or
                     * nonzero if we do */
                }
            }
            accept_state = TRIE_NODENUM( state );
            TRIE_HANDLE_WORD(accept_state);

        } /* end second pass */

        /* and now dump it out before we compress it */
        DEBUG_TRIE_COMPILE_MORE_r(dump_trie_interim_table(trie, widecharmap,
							  revcharmap,
							  next_alloc, depth+1));

        {
        /*
           * Inplace compress the table.*

           For sparse data sets the table constructed by the trie algorithm will
           be mostly 0/FAIL transitions or to put it another way mostly empty.
           (Note that leaf nodes will not contain any transitions.)

           This algorithm compresses the tables by eliminating most such
           transitions, at the cost of a modest bit of extra work during lookup:

           - Each states[] entry contains a .base field which indicates the
           index in the state[] array wheres its transition data is stored.

           - If .base is 0 there are no valid transitions from that node.

           - If .base is nonzero then charid is added to it to find an entry in
           the trans array.

           -If trans[states[state].base+charid].check!=state then the
           transition is taken to be a 0/Fail transition. Thus if there are fail
           transitions at the front of the node then the .base offset will point
           somewhere inside the previous nodes data (or maybe even into a node
           even earlier), but the .check field determines if the transition is
           valid.

           XXX - wrong maybe?
           The following process inplace converts the table to the compressed
           table: We first do not compress the root node 1,and mark all its
           .check pointers as 1 and set its .base pointer as 1 as well. This
           allows us to do a DFA construction from the compressed table later,
           and ensures that any .base pointers we calculate later are greater
           than 0.

           - We set 'pos' to indicate the first entry of the second node.

           - We then iterate over the columns of the node, finding the first and
           last used entry at l and m. We then copy l..m into pos..(pos+m-l),
           and set the .check pointers accordingly, and advance pos
           appropriately and repreat for the next node. Note that when we copy
           the next pointers we have to convert them from the original
           NODEIDX form to NODENUM form as the former is not valid post
           compression.

           - If a node has no transitions used we mark its base as 0 and do not
           advance the pos pointer.

           - If a node only has one transition we use a second pointer into the
           structure to fill in allocated fail transitions from other states.
           This pointer is independent of the main pointer and scans forward
           looking for null transitions that are allocated to a state. When it
           finds one it writes the single transition into the "hole".  If the
           pointer doesnt find one the single transition is appended as normal.

           - Once compressed we can Renew/realloc the structures to release the
           excess space.

           See "Table-Compression Methods" in sec 3.9 of the Red Dragon,
           specifically Fig 3.47 and the associated pseudocode.

           demq
        */
        const U32 laststate = TRIE_NODENUM( next_alloc );
	U32 state, charid;
        U32 pos = 0, zp=0;
        trie->statecount = laststate;

        for ( state = 1 ; state < laststate ; state++ ) {
            U8 flag = 0;
	    const U32 stateidx = TRIE_NODEIDX( state );
	    const U32 o_used = trie->trans[ stateidx ].check;
	    U32 used = trie->trans[ stateidx ].check;
            trie->trans[ stateidx ].check = 0;

            for ( charid = 0;
                  used && charid < trie->uniquecharcount;
                  charid++ )
            {
                if ( flag || trie->trans[ stateidx + charid ].next ) {
                    if ( trie->trans[ stateidx + charid ].next ) {
                        if (o_used == 1) {
                            for ( ; zp < pos ; zp++ ) {
                                if ( ! trie->trans[ zp ].next ) {
                                    break;
                                }
                            }
                            trie->states[ state ].trans.base
                                                    = zp
                                                      + trie->uniquecharcount
                                                      - charid ;
                            trie->trans[ zp ].next
                                = SAFE_TRIE_NODENUM( trie->trans[ stateidx
                                                             + charid ].next );
                            trie->trans[ zp ].check = state;
                            if ( ++zp > pos ) pos = zp;
                            break;
                        }
                        used--;
                    }
                    if ( !flag ) {
                        flag = 1;
                        trie->states[ state ].trans.base
                                       = pos + trie->uniquecharcount - charid ;
                    }
                    trie->trans[ pos ].next
                        = SAFE_TRIE_NODENUM(
                                       trie->trans[ stateidx + charid ].next );
                    trie->trans[ pos ].check = state;
                    pos++;
                }
            }
        }
        trie->lasttrans = pos + 1;
        trie->states = (reg_trie_state *)
	    PerlMemShared_realloc( trie->states, laststate
				   * sizeof(reg_trie_state) );
        DEBUG_TRIE_COMPILE_MORE_r(
            Perl_re_indentf( aTHX_  "Alloc: %d Orig: %"IVdf" elements, Final:%"IVdf". Savings of %%%5.2f\n",
                depth+1,
                (int)( ( TRIE_CHARCOUNT(trie) + 1 ) * trie->uniquecharcount
                       + 1 ),
                (IV)next_alloc,
                (IV)pos,
                ( ( next_alloc - pos ) * 100 ) / (double)next_alloc );
            );

        } /* end table compress */
    }
    DEBUG_TRIE_COMPILE_MORE_r(
            Perl_re_indentf( aTHX_  "Statecount:%"UVxf" Lasttrans:%"UVxf"\n",
                depth+1,
                (UV)trie->statecount,
                (UV)trie->lasttrans)
    );
    /* resize the trans array to remove unused space */
    trie->trans = (reg_trie_trans *)
	PerlMemShared_realloc( trie->trans, trie->lasttrans
			       * sizeof(reg_trie_trans) );

    {   /* Modify the program and insert the new TRIE node */
        U8 nodetype =(U8)(flags & 0xFF);
        char *str=NULL;

#ifdef DEBUGGING
        regnode *optimize = NULL;
#ifdef RE_TRACK_PATTERN_OFFSETS

        U32 mjd_offset = 0;
        U32 mjd_nodelen = 0;
#endif /* RE_TRACK_PATTERN_OFFSETS */
#endif /* DEBUGGING */
        /*
           This means we convert either the first branch or the first Exact,
           depending on whether the thing following (in 'last') is a branch
           or not and whther first is the startbranch (ie is it a sub part of
           the alternation or is it the whole thing.)
           Assuming its a sub part we convert the EXACT otherwise we convert
           the whole branch sequence, including the first.
         */
        /* Find the node we are going to overwrite */
        if ( first != startbranch || OP( last ) == BRANCH ) {
            /* branch sub-chain */
            NEXT_OFF( first ) = (U16)(last - first);
#ifdef RE_TRACK_PATTERN_OFFSETS
            DEBUG_r({
                mjd_offset= Node_Offset((convert));
                mjd_nodelen= Node_Length((convert));
            });
#endif
            /* whole branch chain */
        }
#ifdef RE_TRACK_PATTERN_OFFSETS
        else {
            DEBUG_r({
                const  regnode *nop = NEXTOPER( convert );
                mjd_offset= Node_Offset((nop));
                mjd_nodelen= Node_Length((nop));
            });
        }
        DEBUG_OPTIMISE_r(
            Perl_re_indentf( aTHX_  "MJD offset:%"UVuf" MJD length:%"UVuf"\n",
                depth+1,
                (UV)mjd_offset, (UV)mjd_nodelen)
        );
#endif
        /* But first we check to see if there is a common prefix we can
           split out as an EXACT and put in front of the TRIE node.  */
        trie->startstate= 1;
        if ( trie->bitmap && !widecharmap && !trie->jump  ) {
            U32 state;
            for ( state = 1 ; state < trie->statecount-1 ; state++ ) {
                U32 ofs = 0;
                I32 idx = -1;
                U32 count = 0;
                const U32 base = trie->states[ state ].trans.base;

                if ( trie->states[state].wordnum )
                        count = 1;

                for ( ofs = 0 ; ofs < trie->uniquecharcount ; ofs++ ) {
                    if ( ( base + ofs >= trie->uniquecharcount ) &&
                         ( base + ofs - trie->uniquecharcount < trie->lasttrans ) &&
                         trie->trans[ base + ofs - trie->uniquecharcount ].check == state )
                    {
                        if ( ++count > 1 ) {
                            SV **tmp = av_fetch( revcharmap, ofs, 0);
			    const U8 *ch = (U8*)SvPV_nolen_const( *tmp );
                            if ( state == 1 ) break;
                            if ( count == 2 ) {
                                Zero(trie->bitmap, ANYOF_BITMAP_SIZE, char);
                                DEBUG_OPTIMISE_r(
                                    Perl_re_indentf( aTHX_  "New Start State=%"UVuf" Class: [",
                                        depth+1,
                                        (UV)state));
				if (idx >= 0) {
				    SV ** const tmp = av_fetch( revcharmap, idx, 0);
				    const U8 * const ch = (U8*)SvPV_nolen_const( *tmp );

                                    TRIE_BITMAP_SET(trie,*ch);
                                    if ( folder )
                                        TRIE_BITMAP_SET(trie, folder[ *ch ]);
                                    DEBUG_OPTIMISE_r(
                                        Perl_re_printf( aTHX_  "%s", (char*)ch)
                                    );
				}
			    }
			    TRIE_BITMAP_SET(trie,*ch);
			    if ( folder )
				TRIE_BITMAP_SET(trie,folder[ *ch ]);
                            DEBUG_OPTIMISE_r(Perl_re_printf( aTHX_ "%s", ch));
			}
                        idx = ofs;
		    }
                }
                if ( count == 1 ) {
                    SV **tmp = av_fetch( revcharmap, idx, 0);
                    STRLEN len;
                    char *ch = SvPV( *tmp, len );
                    DEBUG_OPTIMISE_r({
                        SV *sv=sv_newmortal();
                        Perl_re_indentf( aTHX_  "Prefix State: %"UVuf" Idx:%"UVuf" Char='%s'\n",
                            depth+1,
                            (UV)state, (UV)idx,
                            pv_pretty(sv, SvPV_nolen_const(*tmp), SvCUR(*tmp), 6,
	                        PL_colors[0], PL_colors[1],
	                        (SvUTF8(*tmp) ? PERL_PV_ESCAPE_UNI : 0) |
	                        PERL_PV_ESCAPE_FIRSTCHAR
                            )
                        );
                    });
                    if ( state==1 ) {
                        OP( convert ) = nodetype;
                        str=STRING(convert);
                        STR_LEN(convert)=0;
                    }
                    STR_LEN(convert) += len;
                    while (len--)
                        *str++ = *ch++;
		} else {
#ifdef DEBUGGING
		    if (state>1)
                        DEBUG_OPTIMISE_r(Perl_re_printf( aTHX_ "]\n"));
#endif
		    break;
		}
	    }
	    trie->prefixlen = (state-1);
            if (str) {
                regnode *n = convert+NODE_SZ_STR(convert);
                NEXT_OFF(convert) = NODE_SZ_STR(convert);
                trie->startstate = state;
                trie->minlen -= (state - 1);
                trie->maxlen -= (state - 1);
#ifdef DEBUGGING
               /* At least the UNICOS C compiler choked on this
                * being argument to DEBUG_r(), so let's just have
                * it right here. */
               if (
#ifdef PERL_EXT_RE_BUILD
                   1
#else
                   DEBUG_r_TEST
#endif
                   ) {
                   regnode *fix = convert;
                   U32 word = trie->wordcount;
                   mjd_nodelen++;
                   Set_Node_Offset_Length(convert, mjd_offset, state - 1);
                   while( ++fix < n ) {
                       Set_Node_Offset_Length(fix, 0, 0);
                   }
                   while (word--) {
                       SV ** const tmp = av_fetch( trie_words, word, 0 );
                       if (tmp) {
                           if ( STR_LEN(convert) <= SvCUR(*tmp) )
                               sv_chop(*tmp, SvPV_nolen(*tmp) + STR_LEN(convert));
                           else
                               sv_chop(*tmp, SvPV_nolen(*tmp) + SvCUR(*tmp));
                       }
                   }
               }
#endif
                if (trie->maxlen) {
                    convert = n;
		} else {
                    NEXT_OFF(convert) = (U16)(tail - convert);
                    DEBUG_r(optimize= n);
                }
            }
        }
        if (!jumper)
            jumper = last;
        if ( trie->maxlen ) {
	    NEXT_OFF( convert ) = (U16)(tail - convert);
	    ARG_SET( convert, data_slot );
	    /* Store the offset to the first unabsorbed branch in
	       jump[0], which is otherwise unused by the jump logic.
	       We use this when dumping a trie and during optimisation. */
	    if (trie->jump)
	        trie->jump[0] = (U16)(nextbranch - convert);

            /* If the start state is not accepting (meaning there is no empty string/NOTHING)
	     *   and there is a bitmap
	     *   and the first "jump target" node we found leaves enough room
	     * then convert the TRIE node into a TRIEC node, with the bitmap
	     * embedded inline in the opcode - this is hypothetically faster.
	     */
            if ( !trie->states[trie->startstate].wordnum
		 && trie->bitmap
		 && ( (char *)jumper - (char *)convert) >= (int)sizeof(struct regnode_charclass) )
            {
                OP( convert ) = TRIEC;
                Copy(trie->bitmap, ((struct regnode_charclass *)convert)->bitmap, ANYOF_BITMAP_SIZE, char);
                PerlMemShared_free(trie->bitmap);
                trie->bitmap= NULL;
            } else
                OP( convert ) = TRIE;

            /* store the type in the flags */
            convert->flags = nodetype;
            DEBUG_r({
            optimize = convert
                      + NODE_STEP_REGNODE
                      + regarglen[ OP( convert ) ];
            });
            /* XXX We really should free up the resource in trie now,
                   as we won't use them - (which resources?) dmq */
        }
        /* needed for dumping*/
        DEBUG_r(if (optimize) {
            regnode *opt = convert;

            while ( ++opt < optimize) {
                Set_Node_Offset_Length(opt,0,0);
            }
            /*
                Try to clean up some of the debris left after the
                optimisation.
             */
            while( optimize < jumper ) {
                mjd_nodelen += Node_Length((optimize));
                OP( optimize ) = OPTIMIZED;
                Set_Node_Offset_Length(optimize,0,0);
                optimize++;
            }
            Set_Node_Offset_Length(convert,mjd_offset,mjd_nodelen);
        });
    } /* end node insert */

    /*  Finish populating the prev field of the wordinfo array.  Walk back
     *  from each accept state until we find another accept state, and if
     *  so, point the first word's .prev field at the second word. If the
     *  second already has a .prev field set, stop now. This will be the
     *  case either if we've already processed that word's accept state,
     *  or that state had multiple words, and the overspill words were
     *  already linked up earlier.
     */
    {
	U16 word;
	U32 state;
	U16 prev;

	for (word=1; word <= trie->wordcount; word++) {
	    prev = 0;
	    if (trie->wordinfo[word].prev)
		continue;
	    state = trie->wordinfo[word].accept;
	    while (state) {
		state = prev_states[state];
		if (!state)
		    break;
		prev = trie->states[state].wordnum;
		if (prev)
		    break;
	    }
	    trie->wordinfo[word].prev = prev;
	}
	Safefree(prev_states);
    }


    /* and now dump out the compressed format */
    DEBUG_TRIE_COMPILE_r(dump_trie(trie, widecharmap, revcharmap, depth+1));

    RExC_rxi->data->data[ data_slot + 1 ] = (void*)widecharmap;
#ifdef DEBUGGING
    RExC_rxi->data->data[ data_slot + TRIE_WORDS_OFFSET ] = (void*)trie_words;
    RExC_rxi->data->data[ data_slot + 3 ] = (void*)revcharmap;
#else
    SvREFCNT_dec_NN(revcharmap);
#endif
    return trie->jump
           ? MADE_JUMP_TRIE
           : trie->startstate>1
             ? MADE_EXACT_TRIE
             : MADE_TRIE;
}

STATIC regnode *
S_construct_ahocorasick_from_trie(pTHX_ RExC_state_t *pRExC_state, regnode *source, U32 depth)
{
/* The Trie is constructed and compressed now so we can build a fail array if
 * it's needed

   This is basically the Aho-Corasick algorithm. Its from exercise 3.31 and
   3.32 in the
   "Red Dragon" -- Compilers, principles, techniques, and tools. Aho, Sethi,
   Ullman 1985/88
   ISBN 0-201-10088-6

   We find the fail state for each state in the trie, this state is the longest
   proper suffix of the current state's 'word' that is also a proper prefix of
   another word in our trie. State 1 represents the word '' and is thus the
   default fail state. This allows the DFA not to have to restart after its
   tried and failed a word at a given point, it simply continues as though it
   had been matching the other word in the first place.
   Consider
      'abcdgu'=~/abcdefg|cdgu/
   When we get to 'd' we are still matching the first word, we would encounter
   'g' which would fail, which would bring us to the state representing 'd' in
   the second word where we would try 'g' and succeed, proceeding to match
   'cdgu'.
 */
 /* add a fail transition */
    const U32 trie_offset = ARG(source);
    reg_trie_data *trie=(reg_trie_data *)RExC_rxi->data->data[trie_offset];
    U32 *q;
    const U32 ucharcount = trie->uniquecharcount;
    const U32 numstates = trie->statecount;
    const U32 ubound = trie->lasttrans + ucharcount;
    U32 q_read = 0;
    U32 q_write = 0;
    U32 charid;
    U32 base = trie->states[ 1 ].trans.base;
    U32 *fail;
    reg_ac_data *aho;
    const U32 data_slot = add_data( pRExC_state, STR_WITH_LEN("T"));
    regnode *stclass;
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_CONSTRUCT_AHOCORASICK_FROM_TRIE;
    PERL_UNUSED_CONTEXT;
#ifndef DEBUGGING
    PERL_UNUSED_ARG(depth);
#endif

    if ( OP(source) == TRIE ) {
        struct regnode_1 *op = (struct regnode_1 *)
            PerlMemShared_calloc(1, sizeof(struct regnode_1));
        StructCopy(source,op,struct regnode_1);
        stclass = (regnode *)op;
    } else {
        struct regnode_charclass *op = (struct regnode_charclass *)
            PerlMemShared_calloc(1, sizeof(struct regnode_charclass));
        StructCopy(source,op,struct regnode_charclass);
        stclass = (regnode *)op;
    }
    OP(stclass)+=2; /* convert the TRIE type to its AHO-CORASICK equivalent */

    ARG_SET( stclass, data_slot );
    aho = (reg_ac_data *) PerlMemShared_calloc( 1, sizeof(reg_ac_data) );
    RExC_rxi->data->data[ data_slot ] = (void*)aho;
    aho->trie=trie_offset;
    aho->states=(reg_trie_state *)PerlMemShared_malloc( numstates * sizeof(reg_trie_state) );
    Copy( trie->states, aho->states, numstates, reg_trie_state );
    Newxz( q, numstates, U32);
    aho->fail = (U32 *) PerlMemShared_calloc( numstates, sizeof(U32) );
    aho->refcount = 1;
    fail = aho->fail;
    /* initialize fail[0..1] to be 1 so that we always have
       a valid final fail state */
    fail[ 0 ] = fail[ 1 ] = 1;

    for ( charid = 0; charid < ucharcount ; charid++ ) {
	const U32 newstate = TRIE_TRANS_STATE( 1, base, ucharcount, charid, 0 );
	if ( newstate ) {
            q[ q_write ] = newstate;
            /* set to point at the root */
            fail[ q[ q_write++ ] ]=1;
        }
    }
    while ( q_read < q_write) {
	const U32 cur = q[ q_read++ % numstates ];
        base = trie->states[ cur ].trans.base;

        for ( charid = 0 ; charid < ucharcount ; charid++ ) {
	    const U32 ch_state = TRIE_TRANS_STATE( cur, base, ucharcount, charid, 1 );
	    if (ch_state) {
                U32 fail_state = cur;
                U32 fail_base;
                do {
                    fail_state = fail[ fail_state ];
                    fail_base = aho->states[ fail_state ].trans.base;
                } while ( !TRIE_TRANS_STATE( fail_state, fail_base, ucharcount, charid, 1 ) );

                fail_state = TRIE_TRANS_STATE( fail_state, fail_base, ucharcount, charid, 1 );
                fail[ ch_state ] = fail_state;
                if ( !aho->states[ ch_state ].wordnum && aho->states[ fail_state ].wordnum )
                {
                        aho->states[ ch_state ].wordnum =  aho->states[ fail_state ].wordnum;
                }
                q[ q_write++ % numstates] = ch_state;
            }
        }
    }
    /* restore fail[0..1] to 0 so that we "fall out" of the AC loop
       when we fail in state 1, this allows us to use the
       charclass scan to find a valid start char. This is based on the principle
       that theres a good chance the string being searched contains lots of stuff
       that cant be a start char.
     */
    fail[ 0 ] = fail[ 1 ] = 0;
    DEBUG_TRIE_COMPILE_r({
        Perl_re_indentf( aTHX_  "Stclass Failtable (%"UVuf" states): 0",
                      depth, (UV)numstates
        );
        for( q_read=1; q_read<numstates; q_read++ ) {
            Perl_re_printf( aTHX_  ", %"UVuf, (UV)fail[q_read]);
        }
        Perl_re_printf( aTHX_  "\n");
    });
    Safefree(q);
    /*RExC_seen |= REG_TRIEDFA_SEEN;*/
    return stclass;
}


#define DEBUG_PEEP(str,scan,depth)         \
    DEBUG_OPTIMISE_r({if (scan){           \
       regnode *Next = regnext(scan);      \
       regprop(RExC_rx, RExC_mysv, scan, NULL, pRExC_state);\
       Perl_re_indentf( aTHX_  "" str ">%3d: %s (%d)", \
           depth, REG_NODE_NUM(scan), SvPV_nolen_const(RExC_mysv),\
           Next ? (REG_NODE_NUM(Next)) : 0 );\
       DEBUG_SHOW_STUDY_FLAGS(flags," [ ","]");\
       Perl_re_printf( aTHX_  "\n");                   \
   }});

/* The below joins as many adjacent EXACTish nodes as possible into a single
 * one.  The regop may be changed if the node(s) contain certain sequences that
 * require special handling.  The joining is only done if:
 * 1) there is room in the current conglomerated node to entirely contain the
 *    next one.
 * 2) they are the exact same node type
 *
 * The adjacent nodes actually may be separated by NOTHING-kind nodes, and
 * these get optimized out
 *
 * XXX khw thinks this should be enhanced to fill EXACT (at least) nodes as full
 * as possible, even if that means splitting an existing node so that its first
 * part is moved to the preceeding node.  This would maximise the efficiency of
 * memEQ during matching.  Elsewhere in this file, khw proposes splitting
 * EXACTFish nodes into portions that don't change under folding vs those that
 * do.  Those portions that don't change may be the only things in the pattern that
 * could be used to find fixed and floating strings.
 *
 * If a node is to match under /i (folded), the number of characters it matches
 * can be different than its character length if it contains a multi-character
 * fold.  *min_subtract is set to the total delta number of characters of the
 * input nodes.
 *
 * And *unfolded_multi_char is set to indicate whether or not the node contains
 * an unfolded multi-char fold.  This happens when whether the fold is valid or
 * not won't be known until runtime; namely for EXACTF nodes that contain LATIN
 * SMALL LETTER SHARP S, as only if the target string being matched against
 * turns out to be UTF-8 is that fold valid; and also for EXACTFL nodes whose
 * folding rules depend on the locale in force at runtime.  (Multi-char folds
 * whose components are all above the Latin1 range are not run-time locale
 * dependent, and have already been folded by the time this function is
 * called.)
 *
 * This is as good a place as any to discuss the design of handling these
 * multi-character fold sequences.  It's been wrong in Perl for a very long
 * time.  There are three code points in Unicode whose multi-character folds
 * were long ago discovered to mess things up.  The previous designs for
 * dealing with these involved assigning a special node for them.  This
 * approach doesn't always work, as evidenced by this example:
 *      "\xDFs" =~ /s\xDF/ui    # Used to fail before these patches
 * Both sides fold to "sss", but if the pattern is parsed to create a node that
 * would match just the \xDF, it won't be able to handle the case where a
 * successful match would have to cross the node's boundary.  The new approach
 * that hopefully generally solves the problem generates an EXACTFU_SS node
 * that is "sss" in this case.
 *
 * It turns out that there are problems with all multi-character folds, and not
 * just these three.  Now the code is general, for all such cases.  The
 * approach taken is:
 * 1)   This routine examines each EXACTFish node that could contain multi-
 *      character folded sequences.  Since a single character can fold into
 *      such a sequence, the minimum match length for this node is less than
 *      the number of characters in the node.  This routine returns in
 *      *min_subtract how many characters to subtract from the the actual
 *      length of the string to get a real minimum match length; it is 0 if
 *      there are no multi-char foldeds.  This delta is used by the caller to
 *      adjust the min length of the match, and the delta between min and max,
 *      so that the optimizer doesn't reject these possibilities based on size
 *      constraints.
 * 2)   For the sequence involving the Sharp s (\xDF), the node type EXACTFU_SS
 *      is used for an EXACTFU node that contains at least one "ss" sequence in
 *      it.  For non-UTF-8 patterns and strings, this is the only case where
 *      there is a possible fold length change.  That means that a regular
 *      EXACTFU node without UTF-8 involvement doesn't have to concern itself
 *      with length changes, and so can be processed faster.  regexec.c takes
 *      advantage of this.  Generally, an EXACTFish node that is in UTF-8 is
 *      pre-folded by regcomp.c (except EXACTFL, some of whose folds aren't
 *      known until runtime).  This saves effort in regex matching.  However,
 *      the pre-folding isn't done for non-UTF8 patterns because the fold of
 *      the MICRO SIGN requires UTF-8, and we don't want to slow things down by
 *      forcing the pattern into UTF8 unless necessary.  Also what EXACTF (and,
 *      again, EXACTFL) nodes fold to isn't known until runtime.  The fold
 *      possibilities for the non-UTF8 patterns are quite simple, except for
 *      the sharp s.  All the ones that don't involve a UTF-8 target string are
 *      members of a fold-pair, and arrays are set up for all of them so that
 *      the other member of the pair can be found quickly.  Code elsewhere in
 *      this file makes sure that in EXACTFU nodes, the sharp s gets folded to
 *      'ss', even if the pattern isn't UTF-8.  This avoids the issues
 *      described in the next item.
 * 3)   A problem remains for unfolded multi-char folds. (These occur when the
 *      validity of the fold won't be known until runtime, and so must remain
 *      unfolded for now.  This happens for the sharp s in EXACTF and EXACTFA
 *      nodes when the pattern isn't in UTF-8.  (Note, BTW, that there cannot
 *      be an EXACTF node with a UTF-8 pattern.)  They also occur for various
 *      folds in EXACTFL nodes, regardless of the UTF-ness of the pattern.)
 *      The reason this is a problem is that the optimizer part of regexec.c
 *      (probably unwittingly, in Perl_regexec_flags()) makes an assumption
 *      that a character in the pattern corresponds to at most a single
 *      character in the target string.  (And I do mean character, and not byte
 *      here, unlike other parts of the documentation that have never been
 *      updated to account for multibyte Unicode.)  sharp s in EXACTF and
 *      EXACTFL nodes can match the two character string 'ss'; in EXACTFA nodes
 *      it can match "\x{17F}\x{17F}".  These, along with other ones in EXACTFL
 *      nodes, violate the assumption, and they are the only instances where it
 *      is violated.  I'm reluctant to try to change the assumption, as the
 *      code involved is impenetrable to me (khw), so instead the code here
 *      punts.  This routine examines EXACTFL nodes, and (when the pattern
 *      isn't UTF-8) EXACTF and EXACTFA for such unfolded folds, and returns a
 *      boolean indicating whether or not the node contains such a fold.  When
 *      it is true, the caller sets a flag that later causes the optimizer in
 *      this file to not set values for the floating and fixed string lengths,
 *      and thus avoids the optimizer code in regexec.c that makes the invalid
 *      assumption.  Thus, there is no optimization based on string lengths for
 *      EXACTFL nodes that contain these few folds, nor for non-UTF8-pattern
 *      EXACTF and EXACTFA nodes that contain the sharp s.  (The reason the
 *      assumption is wrong only in these cases is that all other non-UTF-8
 *      folds are 1-1; and, for UTF-8 patterns, we pre-fold all other folds to
 *      their expanded versions.  (Again, we can't prefold sharp s to 'ss' in
 *      EXACTF nodes because we don't know at compile time if it actually
 *      matches 'ss' or not.  For EXACTF nodes it will match iff the target
 *      string is in UTF-8.  This is in contrast to EXACTFU nodes, where it
 *      always matches; and EXACTFA where it never does.  In an EXACTFA node in
 *      a UTF-8 pattern, sharp s is folded to "\x{17F}\x{17F}, avoiding the
 *      problem; but in a non-UTF8 pattern, folding it to that above-Latin1
 *      string would require the pattern to be forced into UTF-8, the overhead
 *      of which we want to avoid.  Similarly the unfolded multi-char folds in
 *      EXACTFL nodes will match iff the locale at the time of match is a UTF-8
 *      locale.)
 *
 *      Similarly, the code that generates tries doesn't currently handle
 *      not-already-folded multi-char folds, and it looks like a pain to change
 *      that.  Therefore, trie generation of EXACTFA nodes with the sharp s
 *      doesn't work.  Instead, such an EXACTFA is turned into a new regnode,
 *      EXACTFA_NO_TRIE, which the trie code knows not to handle.  Most people
 *      using /iaa matching will be doing so almost entirely with ASCII
 *      strings, so this should rarely be encountered in practice */

#define JOIN_EXACT(scan,min_subtract,unfolded_multi_char, flags) \
    if (PL_regkind[OP(scan)] == EXACT) \
        join_exact(pRExC_state,(scan),(min_subtract),unfolded_multi_char, (flags),NULL,depth+1)

STATIC U32
S_join_exact(pTHX_ RExC_state_t *pRExC_state, regnode *scan,
                   UV *min_subtract, bool *unfolded_multi_char,
                   U32 flags,regnode *val, U32 depth)
{
    /* Merge several consecutive EXACTish nodes into one. */
    regnode *n = regnext(scan);
    U32 stringok = 1;
    regnode *next = scan + NODE_SZ_STR(scan);
    U32 merged = 0;
    U32 stopnow = 0;
#ifdef DEBUGGING
    regnode *stop = scan;
    GET_RE_DEBUG_FLAGS_DECL;
#else
    PERL_UNUSED_ARG(depth);
#endif

    PERL_ARGS_ASSERT_JOIN_EXACT;
#ifndef EXPERIMENTAL_INPLACESCAN
    PERL_UNUSED_ARG(flags);
    PERL_UNUSED_ARG(val);
#endif
    DEBUG_PEEP("join",scan,depth);

    /* Look through the subsequent nodes in the chain.  Skip NOTHING, merge
     * EXACT ones that are mergeable to the current one. */
    while (n
           && (PL_regkind[OP(n)] == NOTHING
               || (stringok && OP(n) == OP(scan)))
           && NEXT_OFF(n)
           && NEXT_OFF(scan) + NEXT_OFF(n) < I16_MAX)
    {

        if (OP(n) == TAIL || n > next)
            stringok = 0;
        if (PL_regkind[OP(n)] == NOTHING) {
            DEBUG_PEEP("skip:",n,depth);
            NEXT_OFF(scan) += NEXT_OFF(n);
            next = n + NODE_STEP_REGNODE;
#ifdef DEBUGGING
            if (stringok)
                stop = n;
#endif
            n = regnext(n);
        }
        else if (stringok) {
            const unsigned int oldl = STR_LEN(scan);
            regnode * const nnext = regnext(n);

            /* XXX I (khw) kind of doubt that this works on platforms (should
             * Perl ever run on one) where U8_MAX is above 255 because of lots
             * of other assumptions */
            /* Don't join if the sum can't fit into a single node */
            if (oldl + STR_LEN(n) > U8_MAX)
                break;

            DEBUG_PEEP("merg",n,depth);
            merged++;

            NEXT_OFF(scan) += NEXT_OFF(n);
            STR_LEN(scan) += STR_LEN(n);
            next = n + NODE_SZ_STR(n);
            /* Now we can overwrite *n : */
            Move(STRING(n), STRING(scan) + oldl, STR_LEN(n), char);
#ifdef DEBUGGING
            stop = next - 1;
#endif
            n = nnext;
            if (stopnow) break;
        }

#ifdef EXPERIMENTAL_INPLACESCAN
	if (flags && !NEXT_OFF(n)) {
	    DEBUG_PEEP("atch", val, depth);
	    if (reg_off_by_arg[OP(n)]) {
		ARG_SET(n, val - n);
	    }
	    else {
		NEXT_OFF(n) = val - n;
	    }
	    stopnow = 1;
	}
#endif
    }

    *min_subtract = 0;
    *unfolded_multi_char = FALSE;

    /* Here, all the adjacent mergeable EXACTish nodes have been merged.  We
     * can now analyze for sequences of problematic code points.  (Prior to
     * this final joining, sequences could have been split over boundaries, and
     * hence missed).  The sequences only happen in folding, hence for any
     * non-EXACT EXACTish node */
    if (OP(scan) != EXACT && OP(scan) != EXACTL) {
        U8* s0 = (U8*) STRING(scan);
        U8* s = s0;
        U8* s_end = s0 + STR_LEN(scan);

        int total_count_delta = 0;  /* Total delta number of characters that
                                       multi-char folds expand to */

	/* One pass is made over the node's string looking for all the
	 * possibilities.  To avoid some tests in the loop, there are two main
	 * cases, for UTF-8 patterns (which can't have EXACTF nodes) and
	 * non-UTF-8 */
	if (UTF) {
            U8* folded = NULL;

            if (OP(scan) == EXACTFL) {
                U8 *d;

                /* An EXACTFL node would already have been changed to another
                 * node type unless there is at least one character in it that
                 * is problematic; likely a character whose fold definition
                 * won't be known until runtime, and so has yet to be folded.
                 * For all but the UTF-8 locale, folds are 1-1 in length, but
                 * to handle the UTF-8 case, we need to create a temporary
                 * folded copy using UTF-8 locale rules in order to analyze it.
                 * This is because our macros that look to see if a sequence is
                 * a multi-char fold assume everything is folded (otherwise the
                 * tests in those macros would be too complicated and slow).
                 * Note that here, the non-problematic folds will have already
                 * been done, so we can just copy such characters.  We actually
                 * don't completely fold the EXACTFL string.  We skip the
                 * unfolded multi-char folds, as that would just create work
                 * below to figure out the size they already are */

                Newx(folded, UTF8_MAX_FOLD_CHAR_EXPAND * STR_LEN(scan) + 1, U8);
                d = folded;
                while (s < s_end) {
                    STRLEN s_len = UTF8SKIP(s);
                    if (! is_PROBLEMATIC_LOCALE_FOLD_utf8(s)) {
                        Copy(s, d, s_len, U8);
                        d += s_len;
                    }
                    else if (is_FOLDS_TO_MULTI_utf8(s)) {
                        *unfolded_multi_char = TRUE;
                        Copy(s, d, s_len, U8);
                        d += s_len;
                    }
                    else if (isASCII(*s)) {
                        *(d++) = toFOLD(*s);
                    }
                    else {
                        STRLEN len;
                        _to_utf8_fold_flags(s, d, &len, FOLD_FLAGS_FULL);
                        d += len;
                    }
                    s += s_len;
                }

                /* Point the remainder of the routine to look at our temporary
                 * folded copy */
                s = folded;
                s_end = d;
            } /* End of creating folded copy of EXACTFL string */

            /* Examine the string for a multi-character fold sequence.  UTF-8
             * patterns have all characters pre-folded by the time this code is
             * executed */
            while (s < s_end - 1) /* Can stop 1 before the end, as minimum
                                     length sequence we are looking for is 2 */
	    {
                int count = 0;  /* How many characters in a multi-char fold */
                int len = is_MULTI_CHAR_FOLD_utf8_safe(s, s_end);
                if (! len) {    /* Not a multi-char fold: get next char */
                    s += UTF8SKIP(s);
                    continue;
                }

                /* Nodes with 'ss' require special handling, except for
                 * EXACTFA-ish for which there is no multi-char fold to this */
                if (len == 2 && *s == 's' && *(s+1) == 's'
                    && OP(scan) != EXACTFA
                    && OP(scan) != EXACTFA_NO_TRIE)
                {
                    count = 2;
                    if (OP(scan) != EXACTFL) {
                        OP(scan) = EXACTFU_SS;
                    }
                    s += 2;
                }
                else { /* Here is a generic multi-char fold. */
                    U8* multi_end  = s + len;

                    /* Count how many characters are in it.  In the case of
                     * /aa, no folds which contain ASCII code points are
                     * allowed, so check for those, and skip if found. */
                    if (OP(scan) != EXACTFA && OP(scan) != EXACTFA_NO_TRIE) {
                        count = utf8_length(s, multi_end);
                        s = multi_end;
                    }
                    else {
                        while (s < multi_end) {
                            if (isASCII(*s)) {
                                s++;
                                goto next_iteration;
                            }
                            else {
                                s += UTF8SKIP(s);
                            }
                            count++;
                        }
                    }
                }

                /* The delta is how long the sequence is minus 1 (1 is how long
                 * the character that folds to the sequence is) */
                total_count_delta += count - 1;
              next_iteration: ;
	    }

            /* We created a temporary folded copy of the string in EXACTFL
             * nodes.  Therefore we need to be sure it doesn't go below zero,
             * as the real string could be shorter */
            if (OP(scan) == EXACTFL) {
                int total_chars = utf8_length((U8*) STRING(scan),
                                           (U8*) STRING(scan) + STR_LEN(scan));
                if (total_count_delta > total_chars) {
                    total_count_delta = total_chars;
                }
            }

            *min_subtract += total_count_delta;
            Safefree(folded);
	}
	else if (OP(scan) == EXACTFA) {

            /* Non-UTF-8 pattern, EXACTFA node.  There can't be a multi-char
             * fold to the ASCII range (and there are no existing ones in the
             * upper latin1 range).  But, as outlined in the comments preceding
             * this function, we need to flag any occurrences of the sharp s.
             * This character forbids trie formation (because of added
             * complexity) */
#if    UNICODE_MAJOR_VERSION > 3 /* no multifolds in early Unicode */   \
   || (UNICODE_MAJOR_VERSION == 3 && (   UNICODE_DOT_VERSION > 0)       \
                                      || UNICODE_DOT_DOT_VERSION > 0)
	    while (s < s_end) {
                if (*s == LATIN_SMALL_LETTER_SHARP_S) {
                    OP(scan) = EXACTFA_NO_TRIE;
                    *unfolded_multi_char = TRUE;
                    break;
                }
                s++;
            }
        }
	else {

            /* Non-UTF-8 pattern, not EXACTFA node.  Look for the multi-char
             * folds that are all Latin1.  As explained in the comments
             * preceding this function, we look also for the sharp s in EXACTF
             * and EXACTFL nodes; it can be in the final position.  Otherwise
             * we can stop looking 1 byte earlier because have to find at least
             * two characters for a multi-fold */
	    const U8* upper = (OP(scan) == EXACTF || OP(scan) == EXACTFL)
                              ? s_end
                              : s_end -1;

	    while (s < upper) {
                int len = is_MULTI_CHAR_FOLD_latin1_safe(s, s_end);
                if (! len) {    /* Not a multi-char fold. */
                    if (*s == LATIN_SMALL_LETTER_SHARP_S
                        && (OP(scan) == EXACTF || OP(scan) == EXACTFL))
                    {
                        *unfolded_multi_char = TRUE;
                    }
                    s++;
                    continue;
                }

                if (len == 2
                    && isALPHA_FOLD_EQ(*s, 's')
                    && isALPHA_FOLD_EQ(*(s+1), 's'))
                {

                    /* EXACTF nodes need to know that the minimum length
                     * changed so that a sharp s in the string can match this
                     * ss in the pattern, but they remain EXACTF nodes, as they
                     * won't match this unless the target string is is UTF-8,
                     * which we don't know until runtime.  EXACTFL nodes can't
                     * transform into EXACTFU nodes */
                    if (OP(scan) != EXACTF && OP(scan) != EXACTFL) {
                        OP(scan) = EXACTFU_SS;
                    }
		}

                *min_subtract += len - 1;
                s += len;
	    }
#endif
	}
    }

#ifdef DEBUGGING
    /* Allow dumping but overwriting the collection of skipped
     * ops and/or strings with fake optimized ops */
    n = scan + NODE_SZ_STR(scan);
    while (n <= stop) {
	OP(n) = OPTIMIZED;
	FLAGS(n) = 0;
	NEXT_OFF(n) = 0;
        n++;
    }
#endif
    DEBUG_OPTIMISE_r(if (merged){DEBUG_PEEP("finl",scan,depth)});
    return stopnow;
}

/* REx optimizer.  Converts nodes into quicker variants "in place".
   Finds fixed substrings.  */

/* Stops at toplevel WHILEM as well as at "last". At end *scanp is set
   to the position after last scanned or to NULL. */

#define INIT_AND_WITHP \
    assert(!and_withp); \
    Newx(and_withp,1, regnode_ssc); \
    SAVEFREEPV(and_withp)


static void
S_unwind_scan_frames(pTHX_ const void *p)
{
    scan_frame *f= (scan_frame *)p;
    do {
        scan_frame *n= f->next_frame;
        Safefree(f);
        f= n;
    } while (f);
}


STATIC SSize_t
S_study_chunk(pTHX_ RExC_state_t *pRExC_state, regnode **scanp,
                        SSize_t *minlenp, SSize_t *deltap,
			regnode *last,
			scan_data_t *data,
			I32 stopparen,
                        U32 recursed_depth,
			regnode_ssc *and_withp,
			U32 flags, U32 depth)
			/* scanp: Start here (read-write). */
			/* deltap: Write maxlen-minlen here. */
			/* last: Stop before this one. */
			/* data: string data about the pattern */
			/* stopparen: treat close N as END */
			/* recursed: which subroutines have we recursed into */
			/* and_withp: Valid if flags & SCF_DO_STCLASS_OR */
{
    /* There must be at least this number of characters to match */
    SSize_t min = 0;
    I32 pars = 0, code;
    regnode *scan = *scanp, *next;
    SSize_t delta = 0;
    int is_inf = (flags & SCF_DO_SUBSTR) && (data->flags & SF_IS_INF);
    int is_inf_internal = 0;		/* The studied chunk is infinite */
    I32 is_par = OP(scan) == OPEN ? ARG(scan) : 0;
    scan_data_t data_fake;
    SV *re_trie_maxbuff = NULL;
    regnode *first_non_open = scan;
    SSize_t stopmin = SSize_t_MAX;
    scan_frame *frame = NULL;
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_STUDY_CHUNK;


    if ( depth == 0 ) {
        while (first_non_open && OP(first_non_open) == OPEN)
            first_non_open=regnext(first_non_open);
    }


  fake_study_recurse:
    DEBUG_r(
        RExC_study_chunk_recursed_count++;
    );
    DEBUG_OPTIMISE_MORE_r(
    {
        Perl_re_indentf( aTHX_  "study_chunk stopparen=%ld recursed_count=%lu depth=%lu recursed_depth=%lu scan=%p last=%p",
            depth, (long)stopparen,
            (unsigned long)RExC_study_chunk_recursed_count,
            (unsigned long)depth, (unsigned long)recursed_depth,
            scan,
            last);
        if (recursed_depth) {
            U32 i;
            U32 j;
            for ( j = 0 ; j < recursed_depth ; j++ ) {
                for ( i = 0 ; i < (U32)RExC_npar ; i++ ) {
                    if (
                        PAREN_TEST(RExC_study_chunk_recursed +
                                   ( j * RExC_study_chunk_recursed_bytes), i )
                        && (
                            !j ||
                            !PAREN_TEST(RExC_study_chunk_recursed +
                                   (( j - 1 ) * RExC_study_chunk_recursed_bytes), i)
                        )
                    ) {
                        Perl_re_printf( aTHX_ " %d",(int)i);
                        break;
                    }
                }
                if ( j + 1 < recursed_depth ) {
                    Perl_re_printf( aTHX_  ",");
                }
            }
        }
        Perl_re_printf( aTHX_ "\n");
    }
    );
    while ( scan && OP(scan) != END && scan < last ){
        UV min_subtract = 0;    /* How mmany chars to subtract from the minimum
                                   node length to get a real minimum (because
                                   the folded version may be shorter) */
	bool unfolded_multi_char = FALSE;
	/* Peephole optimizer: */
        DEBUG_STUDYDATA("Peep:", data, depth);
        DEBUG_PEEP("Peep", scan, depth);


        /* The reason we do this here is that we need to deal with things like
         * /(?:f)(?:o)(?:o)/ which cant be dealt with by the normal EXACT
         * parsing code, as each (?:..) is handled by a different invocation of
         * reg() -- Yves
         */
        JOIN_EXACT(scan,&min_subtract, &unfolded_multi_char, 0);

	/* Follow the next-chain of the current node and optimize
	   away all the NOTHINGs from it.  */
	if (OP(scan) != CURLYX) {
	    const int max = (reg_off_by_arg[OP(scan)]
		       ? I32_MAX
		       /* I32 may be smaller than U16 on CRAYs! */
		       : (I32_MAX < U16_MAX ? I32_MAX : U16_MAX));
	    int off = (reg_off_by_arg[OP(scan)] ? ARG(scan) : NEXT_OFF(scan));
	    int noff;
	    regnode *n = scan;

	    /* Skip NOTHING and LONGJMP. */
	    while ((n = regnext(n))
		   && ((PL_regkind[OP(n)] == NOTHING && (noff = NEXT_OFF(n)))
		       || ((OP(n) == LONGJMP) && (noff = ARG(n))))
		   && off + noff < max)
		off += noff;
	    if (reg_off_by_arg[OP(scan)])
		ARG(scan) = off;
	    else
		NEXT_OFF(scan) = off;
	}

	/* The principal pseudo-switch.  Cannot be a switch, since we
	   look into several different things.  */
        if ( OP(scan) == DEFINEP ) {
            SSize_t minlen = 0;
            SSize_t deltanext = 0;
            SSize_t fake_last_close = 0;
            I32 f = SCF_IN_DEFINE;

            StructCopy(&zero_scan_data, &data_fake, scan_data_t);
            scan = regnext(scan);
            assert( OP(scan) == IFTHEN );
            DEBUG_PEEP("expect IFTHEN", scan, depth);

            data_fake.last_closep= &fake_last_close;
            minlen = *minlenp;
            next = regnext(scan);
            scan = NEXTOPER(NEXTOPER(scan));
            DEBUG_PEEP("scan", scan, depth);
            DEBUG_PEEP("next", next, depth);

            /* we suppose the run is continuous, last=next...
             * NOTE we dont use the return here! */
            (void)study_chunk(pRExC_state, &scan, &minlen,
                              &deltanext, next, &data_fake, stopparen,
                              recursed_depth, NULL, f, depth+1);

            scan = next;
        } else
        if (
            OP(scan) == BRANCH  ||
            OP(scan) == BRANCHJ ||
            OP(scan) == IFTHEN
        ) {
	    next = regnext(scan);
	    code = OP(scan);

            /* The op(next)==code check below is to see if we
             * have "BRANCH-BRANCH", "BRANCHJ-BRANCHJ", "IFTHEN-IFTHEN"
             * IFTHEN is special as it might not appear in pairs.
             * Not sure whether BRANCH-BRANCHJ is possible, regardless
             * we dont handle it cleanly. */
	    if (OP(next) == code || code == IFTHEN) {
                /* NOTE - There is similar code to this block below for
                 * handling TRIE nodes on a re-study.  If you change stuff here
                 * check there too. */
		SSize_t max1 = 0, min1 = SSize_t_MAX, num = 0;
		regnode_ssc accum;
		regnode * const startbranch=scan;

                if (flags & SCF_DO_SUBSTR) {
                    /* Cannot merge strings after this. */
                    scan_commit(pRExC_state, data, minlenp, is_inf);
                }

                if (flags & SCF_DO_STCLASS)
		    ssc_init_zero(pRExC_state, &accum);

		while (OP(scan) == code) {
		    SSize_t deltanext, minnext, fake;
		    I32 f = 0;
		    regnode_ssc this_class;

                    DEBUG_PEEP("Branch", scan, depth);

		    num++;
                    StructCopy(&zero_scan_data, &data_fake, scan_data_t);
		    if (data) {
			data_fake.whilem_c = data->whilem_c;
			data_fake.last_closep = data->last_closep;
		    }
		    else
			data_fake.last_closep = &fake;

		    data_fake.pos_delta = delta;
		    next = regnext(scan);

                    scan = NEXTOPER(scan); /* everything */
                    if (code != BRANCH)    /* everything but BRANCH */
			scan = NEXTOPER(scan);

		    if (flags & SCF_DO_STCLASS) {
			ssc_init(pRExC_state, &this_class);
			data_fake.start_class = &this_class;
			f = SCF_DO_STCLASS_AND;
		    }
		    if (flags & SCF_WHILEM_VISITED_POS)
			f |= SCF_WHILEM_VISITED_POS;

		    /* we suppose the run is continuous, last=next...*/
		    minnext = study_chunk(pRExC_state, &scan, minlenp,
                                      &deltanext, next, &data_fake, stopparen,
                                      recursed_depth, NULL, f,depth+1);

		    if (min1 > minnext)
			min1 = minnext;
		    if (deltanext == SSize_t_MAX) {
			is_inf = is_inf_internal = 1;
			max1 = SSize_t_MAX;
		    } else if (max1 < minnext + deltanext)
			max1 = minnext + deltanext;
		    scan = next;
		    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))
			pars++;
	            if (data_fake.flags & SCF_SEEN_ACCEPT) {
	                if ( stopmin > minnext)
	                    stopmin = min + min1;
	                flags &= ~SCF_DO_SUBSTR;
	                if (data)
	                    data->flags |= SCF_SEEN_ACCEPT;
	            }
		    if (data) {
			if (data_fake.flags & SF_HAS_EVAL)
			    data->flags |= SF_HAS_EVAL;
			data->whilem_c = data_fake.whilem_c;
		    }
		    if (flags & SCF_DO_STCLASS)
			ssc_or(pRExC_state, &accum, (regnode_charclass*)&this_class);
		}
		if (code == IFTHEN && num < 2) /* Empty ELSE branch */
		    min1 = 0;
		if (flags & SCF_DO_SUBSTR) {
		    data->pos_min += min1;
		    if (data->pos_delta >= SSize_t_MAX - (max1 - min1))
		        data->pos_delta = SSize_t_MAX;
		    else
		        data->pos_delta += max1 - min1;
		    if (max1 != min1 || is_inf)
			data->longest = &(data->longest_float);
		}
		min += min1;
		if (delta == SSize_t_MAX
		 || SSize_t_MAX - delta - (max1 - min1) < 0)
		    delta = SSize_t_MAX;
		else
		    delta += max1 - min1;
		if (flags & SCF_DO_STCLASS_OR) {
		    ssc_or(pRExC_state, data->start_class, (regnode_charclass*) &accum);
		    if (min1) {
			ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);
			flags &= ~SCF_DO_STCLASS;
		    }
		}
		else if (flags & SCF_DO_STCLASS_AND) {
		    if (min1) {
			ssc_and(pRExC_state, data->start_class, (regnode_charclass *) &accum);
			flags &= ~SCF_DO_STCLASS;
		    }
		    else {
			/* Switch to OR mode: cache the old value of
			 * data->start_class */
			INIT_AND_WITHP;
			StructCopy(data->start_class, and_withp, regnode_ssc);
			flags &= ~SCF_DO_STCLASS_AND;
			StructCopy(&accum, data->start_class, regnode_ssc);
			flags |= SCF_DO_STCLASS_OR;
		    }
		}

                if (PERL_ENABLE_TRIE_OPTIMISATION &&
                        OP( startbranch ) == BRANCH )
                {
		/* demq.

                   Assuming this was/is a branch we are dealing with: 'scan'
                   now points at the item that follows the branch sequence,
                   whatever it is. We now start at the beginning of the
                   sequence and look for subsequences of

		   BRANCH->EXACT=>x1
		   BRANCH->EXACT=>x2
		   tail

                   which would be constructed from a pattern like
                   /A|LIST|OF|WORDS/

		   If we can find such a subsequence we need to turn the first
		   element into a trie and then add the subsequent branch exact
		   strings to the trie.

		   We have two cases

                     1. patterns where the whole set of branches can be
                        converted.

		     2. patterns where only a subset can be converted.

		   In case 1 we can replace the whole set with a single regop
		   for the trie. In case 2 we need to keep the start and end
		   branches so

		     'BRANCH EXACT; BRANCH EXACT; BRANCH X'
		     becomes BRANCH TRIE; BRANCH X;

		  There is an additional case, that being where there is a
		  common prefix, which gets split out into an EXACT like node
		  preceding the TRIE node.

		  If x(1..n)==tail then we can do a simple trie, if not we make
		  a "jump" trie, such that when we match the appropriate word
		  we "jump" to the appropriate tail node. Essentially we turn
		  a nested if into a case structure of sorts.

		*/

		    int made=0;
		    if (!re_trie_maxbuff) {
			re_trie_maxbuff = get_sv(RE_TRIE_MAXBUF_NAME, 1);
			if (!SvIOK(re_trie_maxbuff))
			    sv_setiv(re_trie_maxbuff, RE_TRIE_MAXBUF_INIT);
		    }
                    if ( SvIV(re_trie_maxbuff)>=0  ) {
                        regnode *cur;
                        regnode *first = (regnode *)NULL;
                        regnode *last = (regnode *)NULL;
                        regnode *tail = scan;
                        U8 trietype = 0;
                        U32 count=0;

                        /* var tail is used because there may be a TAIL
                           regop in the way. Ie, the exacts will point to the
                           thing following the TAIL, but the last branch will
                           point at the TAIL. So we advance tail. If we
                           have nested (?:) we may have to move through several
                           tails.
                         */

                        while ( OP( tail ) == TAIL ) {
                            /* this is the TAIL generated by (?:) */
                            tail = regnext( tail );
                        }


                        DEBUG_TRIE_COMPILE_r({
                            regprop(RExC_rx, RExC_mysv, tail, NULL, pRExC_state);
                            Perl_re_indentf( aTHX_  "%s %"UVuf":%s\n",
                              depth+1,
                              "Looking for TRIE'able sequences. Tail node is ",
                              (UV)(tail - RExC_emit_start),
                              SvPV_nolen_const( RExC_mysv )
                            );
                        });

                        /*

                            Step through the branches
                                cur represents each branch,
                                noper is the first thing to be matched as part
                                      of that branch
                                noper_next is the regnext() of that node.

                            We normally handle a case like this
                            /FOO[xyz]|BAR[pqr]/ via a "jump trie" but we also
                            support building with NOJUMPTRIE, which restricts
                            the trie logic to structures like /FOO|BAR/.

                            If noper is a trieable nodetype then the branch is
                            a possible optimization target. If we are building
                            under NOJUMPTRIE then we require that noper_next is
                            the same as scan (our current position in the regex
                            program).

                            Once we have two or more consecutive such branches
                            we can create a trie of the EXACT's contents and
                            stitch it in place into the program.

                            If the sequence represents all of the branches in
                            the alternation we replace the entire thing with a
                            single TRIE node.

                            Otherwise when it is a subsequence we need to
                            stitch it in place and replace only the relevant
                            branches. This means the first branch has to remain
                            as it is used by the alternation logic, and its
                            next pointer, and needs to be repointed at the item
                            on the branch chain following the last branch we
                            have optimized away.

                            This could be either a BRANCH, in which case the
                            subsequence is internal, or it could be the item
                            following the branch sequence in which case the
                            subsequence is at the end (which does not
                            necessarily mean the first node is the start of the
                            alternation).

                            TRIE_TYPE(X) is a define which maps the optype to a
                            trietype.

                                optype          |  trietype
                                ----------------+-----------
                                NOTHING         | NOTHING
                                EXACT           | EXACT
                                EXACTFU         | EXACTFU
                                EXACTFU_SS      | EXACTFU
                                EXACTFA         | EXACTFA
                                EXACTL          | EXACTL
                                EXACTFLU8       | EXACTFLU8


                        */
#define TRIE_TYPE(X) ( ( NOTHING == (X) )                                   \
                       ? NOTHING                                            \
                       : ( EXACT == (X) )                                   \
                         ? EXACT                                            \
                         : ( EXACTFU == (X) || EXACTFU_SS == (X) )          \
                           ? EXACTFU                                        \
                           : ( EXACTFA == (X) )                             \
                             ? EXACTFA                                      \
                             : ( EXACTL == (X) )                            \
                               ? EXACTL                                     \
                               : ( EXACTFLU8 == (X) )                        \
                                 ? EXACTFLU8                                 \
                                 : 0 )

                        /* dont use tail as the end marker for this traverse */
                        for ( cur = startbranch ; cur != scan ; cur = regnext( cur ) ) {
                            regnode * const noper = NEXTOPER( cur );
                            U8 noper_type = OP( noper );
                            U8 noper_trietype = TRIE_TYPE( noper_type );
#if defined(DEBUGGING) || defined(NOJUMPTRIE)
                            regnode * const noper_next = regnext( noper );
                            U8 noper_next_type = (noper_next && noper_next < tail) ? OP(noper_next) : 0;
                            U8 noper_next_trietype = (noper_next && noper_next < tail) ? TRIE_TYPE( noper_next_type ) :0;
#endif

                            DEBUG_TRIE_COMPILE_r({
                                regprop(RExC_rx, RExC_mysv, cur, NULL, pRExC_state);
                                Perl_re_indentf( aTHX_  "- %d:%s (%d)",
                                   depth+1,
                                   REG_NODE_NUM(cur), SvPV_nolen_const( RExC_mysv ), REG_NODE_NUM(cur) );

                                regprop(RExC_rx, RExC_mysv, noper, NULL, pRExC_state);
                                Perl_re_printf( aTHX_  " -> %d:%s",
                                    REG_NODE_NUM(noper), SvPV_nolen_const(RExC_mysv));

                                if ( noper_next ) {
                                  regprop(RExC_rx, RExC_mysv, noper_next, NULL, pRExC_state);
                                  Perl_re_printf( aTHX_ "\t=> %d:%s\t",
                                    REG_NODE_NUM(noper_next), SvPV_nolen_const(RExC_mysv));
                                }
                                Perl_re_printf( aTHX_  "(First==%d,Last==%d,Cur==%d,tt==%s,ntt==%s,nntt==%s)\n",
                                   REG_NODE_NUM(first), REG_NODE_NUM(last), REG_NODE_NUM(cur),
				   PL_reg_name[trietype], PL_reg_name[noper_trietype], PL_reg_name[noper_next_trietype]
				);
                            });

                            /* Is noper a trieable nodetype that can be merged
                             * with the current trie (if there is one)? */
                            if ( noper_trietype
                                  &&
                                  (
                                        ( noper_trietype == NOTHING )
                                        || ( trietype == NOTHING )
                                        || ( trietype == noper_trietype )
                                  )
#ifdef NOJUMPTRIE
                                  && noper_next >= tail
#endif
                                  && count < U16_MAX)
                            {
                                /* Handle mergable triable node Either we are
                                 * the first node in a new trieable sequence,
                                 * in which case we do some bookkeeping,
                                 * otherwise we update the end pointer. */
                                if ( !first ) {
                                    first = cur;
				    if ( noper_trietype == NOTHING ) {
#if !defined(DEBUGGING) && !defined(NOJUMPTRIE)
					regnode * const noper_next = regnext( noper );
                                        U8 noper_next_type = (noper_next && noper_next < tail) ? OP(noper_next) : 0;
					U8 noper_next_trietype = noper_next_type ? TRIE_TYPE( noper_next_type ) :0;
#endif

                                        if ( noper_next_trietype ) {
					    trietype = noper_next_trietype;
                                        } else if (noper_next_type)  {
                                            /* a NOTHING regop is 1 regop wide.
                                             * We need at least two for a trie
                                             * so we can't merge this in */
                                            first = NULL;
                                        }
                                    } else {
                                        trietype = noper_trietype;
                                    }
                                } else {
                                    if ( trietype == NOTHING )
                                        trietype = noper_trietype;
                                    last = cur;
                                }
				if (first)
				    count++;
                            } /* end handle mergable triable node */
                            else {
                                /* handle unmergable node -
                                 * noper may either be a triable node which can
                                 * not be tried together with the current trie,
                                 * or a non triable node */
                                if ( last ) {
                                    /* If last is set and trietype is not
                                     * NOTHING then we have found at least two
                                     * triable branch sequences in a row of a
                                     * similar trietype so we can turn them
                                     * into a trie. If/when we allow NOTHING to
                                     * start a trie sequence this condition
                                     * will be required, and it isn't expensive
                                     * so we leave it in for now. */
                                    if ( trietype && trietype != NOTHING )
                                        make_trie( pRExC_state,
                                                startbranch, first, cur, tail,
                                                count, trietype, depth+1 );
                                    last = NULL; /* note: we clear/update
                                                    first, trietype etc below,
                                                    so we dont do it here */
                                }
                                if ( noper_trietype
#ifdef NOJUMPTRIE
                                     && noper_next >= tail
#endif
                                ){
                                    /* noper is triable, so we can start a new
                                     * trie sequence */
                                    count = 1;
                                    first = cur;
                                    trietype = noper_trietype;
                                } else if (first) {
                                    /* if we already saw a first but the
                                     * current node is not triable then we have
                                     * to reset the first information. */
                                    count = 0;
                                    first = NULL;
                                    trietype = 0;
                                }
                            } /* end handle unmergable node */
                        } /* loop over branches */
                        DEBUG_TRIE_COMPILE_r({
                            regprop(RExC_rx, RExC_mysv, cur, NULL, pRExC_state);
                            Perl_re_indentf( aTHX_  "- %s (%d) <SCAN FINISHED> ",
                              depth+1, SvPV_nolen_const( RExC_mysv ),REG_NODE_NUM(cur));
                            Perl_re_printf( aTHX_  "(First==%d, Last==%d, Cur==%d, tt==%s)\n",
                               REG_NODE_NUM(first), REG_NODE_NUM(last), REG_NODE_NUM(cur),
                               PL_reg_name[trietype]
                            );

                        });
                        if ( last && trietype ) {
                            if ( trietype != NOTHING ) {
                                /* the last branch of the sequence was part of
                                 * a trie, so we have to construct it here
                                 * outside of the loop */
                                made= make_trie( pRExC_state, startbranch,
                                                 first, scan, tail, count,
                                                 trietype, depth+1 );
#ifdef TRIE_STUDY_OPT
                                if ( ((made == MADE_EXACT_TRIE &&
                                     startbranch == first)
                                     || ( first_non_open == first )) &&
                                     depth==0 ) {
                                    flags |= SCF_TRIE_RESTUDY;
                                    if ( startbranch == first
                                         && scan >= tail )
                                    {
                                        RExC_seen &=~REG_TOP_LEVEL_BRANCHES_SEEN;
                                    }
                                }
#endif
                            } else {
                                /* at this point we know whatever we have is a
                                 * NOTHING sequence/branch AND if 'startbranch'
                                 * is 'first' then we can turn the whole thing
                                 * into a NOTHING
                                 */
                                if ( startbranch == first ) {
                                    regnode *opt;
                                    /* the entire thing is a NOTHING sequence,
                                     * something like this: (?:|) So we can
                                     * turn it into a plain NOTHING op. */
                                    DEBUG_TRIE_COMPILE_r({
                                        regprop(RExC_rx, RExC_mysv, cur, NULL, pRExC_state);
                                        Perl_re_indentf( aTHX_  "- %s (%d) <NOTHING BRANCH SEQUENCE>\n",
                                          depth+1,
                                          SvPV_nolen_const( RExC_mysv ),REG_NODE_NUM(cur));

                                    });
                                    OP(startbranch)= NOTHING;
                                    NEXT_OFF(startbranch)= tail - startbranch;
                                    for ( opt= startbranch + 1; opt < tail ; opt++ )
                                        OP(opt)= OPTIMIZED;
                                }
                            }
                        } /* end if ( last) */
                    } /* TRIE_MAXBUF is non zero */

                } /* do trie */

	    }
	    else if ( code == BRANCHJ ) {  /* single branch is optimized. */
		scan = NEXTOPER(NEXTOPER(scan));
	    } else			/* single branch is optimized. */
		scan = NEXTOPER(scan);
	    continue;
        } else if (OP(scan) == SUSPEND || OP(scan) == GOSUB) {
            I32 paren = 0;
            regnode *start = NULL;
            regnode *end = NULL;
            U32 my_recursed_depth= recursed_depth;

            if (OP(scan) != SUSPEND) { /* GOSUB */
                /* Do setup, note this code has side effects beyond
                 * the rest of this block. Specifically setting
                 * RExC_recurse[] must happen at least once during
                 * study_chunk(). */
                paren = ARG(scan);
                RExC_recurse[ARG2L(scan)] = scan;
                start = RExC_open_parens[paren];
                end   = RExC_close_parens[paren];

                /* NOTE we MUST always execute the above code, even
                 * if we do nothing with a GOSUB */
                if (
                    ( flags & SCF_IN_DEFINE )
                    ||
                    (
                        (is_inf_internal || is_inf || (data && data->flags & SF_IS_INF))
                        &&
                        ( (flags & (SCF_DO_STCLASS | SCF_DO_SUBSTR)) == 0 )
                    )
                ) {
                    /* no need to do anything here if we are in a define. */
                    /* or we are after some kind of infinite construct
                     * so we can skip recursing into this item.
                     * Since it is infinite we will not change the maxlen
                     * or delta, and if we miss something that might raise
                     * the minlen it will merely pessimise a little.
                     *
                     * Iow /(?(DEFINE)(?<foo>foo|food))a+(?&foo)/
                     * might result in a minlen of 1 and not of 4,
                     * but this doesn't make us mismatch, just try a bit
                     * harder than we should.
                     * */
                    scan= regnext(scan);
                    continue;
                }

                if (
                    !recursed_depth
                    ||
                    !PAREN_TEST(RExC_study_chunk_recursed + ((recursed_depth-1) * RExC_study_chunk_recursed_bytes), paren)
                ) {
                    /* it is quite possible that there are more efficient ways
                     * to do this. We maintain a bitmap per level of recursion
                     * of which patterns we have entered so we can detect if a
                     * pattern creates a possible infinite loop. When we
                     * recurse down a level we copy the previous levels bitmap
                     * down. When we are at recursion level 0 we zero the top
                     * level bitmap. It would be nice to implement a different
                     * more efficient way of doing this. In particular the top
                     * level bitmap may be unnecessary.
                     */
                    if (!recursed_depth) {
                        Zero(RExC_study_chunk_recursed, RExC_study_chunk_recursed_bytes, U8);
                    } else {
                        Copy(RExC_study_chunk_recursed + ((recursed_depth-1) * RExC_study_chunk_recursed_bytes),
                             RExC_study_chunk_recursed + (recursed_depth * RExC_study_chunk_recursed_bytes),
                             RExC_study_chunk_recursed_bytes, U8);
                    }
                    /* we havent recursed into this paren yet, so recurse into it */
                    DEBUG_STUDYDATA("gosub-set:", data,depth);
                    PAREN_SET(RExC_study_chunk_recursed + (recursed_depth * RExC_study_chunk_recursed_bytes), paren);
                    my_recursed_depth= recursed_depth + 1;
                } else {
                    DEBUG_STUDYDATA("gosub-inf:", data,depth);
                    /* some form of infinite recursion, assume infinite length
                     * */
                    if (flags & SCF_DO_SUBSTR) {
                        scan_commit(pRExC_state, data, minlenp, is_inf);
                        data->longest = &(data->longest_float);
                    }
                    is_inf = is_inf_internal = 1;
                    if (flags & SCF_DO_STCLASS_OR) /* Allow everything */
                        ssc_anything(data->start_class);
                    flags &= ~SCF_DO_STCLASS;

                    start= NULL; /* reset start so we dont recurse later on. */
	        }
            } else {
	        paren = stopparen;
                start = scan + 2;
	        end = regnext(scan);
	    }
            if (start) {
                scan_frame *newframe;
                assert(end);
                if (!RExC_frame_last) {
                    Newxz(newframe, 1, scan_frame);
                    SAVEDESTRUCTOR_X(S_unwind_scan_frames, newframe);
                    RExC_frame_head= newframe;
                    RExC_frame_count++;
                } else if (!RExC_frame_last->next_frame) {
                    Newxz(newframe,1,scan_frame);
                    RExC_frame_last->next_frame= newframe;
                    newframe->prev_frame= RExC_frame_last;
                    RExC_frame_count++;
                } else {
                    newframe= RExC_frame_last->next_frame;
                }
                RExC_frame_last= newframe;

                newframe->next_regnode = regnext(scan);
                newframe->last_regnode = last;
                newframe->stopparen = stopparen;
                newframe->prev_recursed_depth = recursed_depth;
                newframe->this_prev_frame= frame;

                DEBUG_STUDYDATA("frame-new:",data,depth);
                DEBUG_PEEP("fnew", scan, depth);

	        frame = newframe;
	        scan =  start;
	        stopparen = paren;
	        last = end;
                depth = depth + 1;
                recursed_depth= my_recursed_depth;

	        continue;
	    }
	}
	else if (OP(scan) == EXACT || OP(scan) == EXACTL) {
	    SSize_t l = STR_LEN(scan);
	    UV uc;
	    if (UTF) {
		const U8 * const s = (U8*)STRING(scan);
		uc = utf8_to_uvchr_buf(s, s + l, NULL);
		l = utf8_length(s, s + l);
	    } else {
		uc = *((U8*)STRING(scan));
	    }
	    min += l;
	    if (flags & SCF_DO_SUBSTR) { /* Update longest substr. */
		/* The code below prefers earlier match for fixed
		   offset, later match for variable offset.  */
		if (data->last_end == -1) { /* Update the start info. */
		    data->last_start_min = data->pos_min;
 		    data->last_start_max = is_inf
 			? SSize_t_MAX : data->pos_min + data->pos_delta;
		}
		sv_catpvn(data->last_found, STRING(scan), STR_LEN(scan));
		if (UTF)
		    SvUTF8_on(data->last_found);
		{
		    SV * const sv = data->last_found;
		    MAGIC * const mg = SvUTF8(sv) && SvMAGICAL(sv) ?
			mg_find(sv, PERL_MAGIC_utf8) : NULL;
		    if (mg && mg->mg_len >= 0)
			mg->mg_len += utf8_length((U8*)STRING(scan),
                                              (U8*)STRING(scan)+STR_LEN(scan));
		}
		data->last_end = data->pos_min + l;
		data->pos_min += l; /* As in the first entry. */
		data->flags &= ~SF_BEFORE_EOL;
	    }

            /* ANDing the code point leaves at most it, and not in locale, and
             * can't match null string */
	    if (flags & SCF_DO_STCLASS_AND) {
                ssc_cp_and(data->start_class, uc);
                ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;
                ssc_clear_locale(data->start_class);
	    }
	    else if (flags & SCF_DO_STCLASS_OR) {
                ssc_add_cp(data->start_class, uc);
		ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);

                /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a */
                ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;
	    }
	    flags &= ~SCF_DO_STCLASS;
	}
        else if (PL_regkind[OP(scan)] == EXACT) {
            /* But OP != EXACT!, so is EXACTFish */
	    SSize_t l = STR_LEN(scan);
            const U8 * s = (U8*)STRING(scan);

	    /* Search for fixed substrings supports EXACT only. */
	    if (flags & SCF_DO_SUBSTR) {
		assert(data);
                scan_commit(pRExC_state, data, minlenp, is_inf);
	    }
	    if (UTF) {
		l = utf8_length(s, s + l);
	    }
	    if (unfolded_multi_char) {
                RExC_seen |= REG_UNFOLDED_MULTI_SEEN;
	    }
	    min += l - min_subtract;
            assert (min >= 0);
            delta += min_subtract;
	    if (flags & SCF_DO_SUBSTR) {
		data->pos_min += l - min_subtract;
		if (data->pos_min < 0) {
                    data->pos_min = 0;
                }
                data->pos_delta += min_subtract;
		if (min_subtract) {
		    data->longest = &(data->longest_float);
		}
	    }

            if (flags & SCF_DO_STCLASS) {
                SV* EXACTF_invlist = _make_exactf_invlist(pRExC_state, scan);

                assert(EXACTF_invlist);
                if (flags & SCF_DO_STCLASS_AND) {
                    if (OP(scan) != EXACTFL)
                        ssc_clear_locale(data->start_class);
                    ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;
                    ANYOF_POSIXL_ZERO(data->start_class);
                    ssc_intersection(data->start_class, EXACTF_invlist, FALSE);
                }
                else {  /* SCF_DO_STCLASS_OR */
                    ssc_union(data->start_class, EXACTF_invlist, FALSE);
                    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);

                    /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a */
                    ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;
                }
                flags &= ~SCF_DO_STCLASS;
                SvREFCNT_dec(EXACTF_invlist);
            }
	}
	else if (REGNODE_VARIES(OP(scan))) {
	    SSize_t mincount, maxcount, minnext, deltanext, pos_before = 0;
	    I32 fl = 0, f = flags;
	    regnode * const oscan = scan;
	    regnode_ssc this_class;
	    regnode_ssc *oclass = NULL;
	    I32 next_is_eval = 0;

	    switch (PL_regkind[OP(scan)]) {
	    case WHILEM:		/* End of (?:...)* . */
		scan = NEXTOPER(scan);
		goto finish;
	    case PLUS:
		if (flags & (SCF_DO_SUBSTR | SCF_DO_STCLASS)) {
		    next = NEXTOPER(scan);
		    if (OP(next) == EXACT
                        || OP(next) == EXACTL
                        || (flags & SCF_DO_STCLASS))
                    {
			mincount = 1;
			maxcount = REG_INFTY;
			next = regnext(scan);
			scan = NEXTOPER(scan);
			goto do_curly;
		    }
		}
		if (flags & SCF_DO_SUBSTR)
		    data->pos_min++;
		min++;
		/* FALLTHROUGH */
	    case STAR:
		if (flags & SCF_DO_STCLASS) {
		    mincount = 0;
		    maxcount = REG_INFTY;
		    next = regnext(scan);
		    scan = NEXTOPER(scan);
		    goto do_curly;
		}
		if (flags & SCF_DO_SUBSTR) {
                    scan_commit(pRExC_state, data, minlenp, is_inf);
                    /* Cannot extend fixed substrings */
		    data->longest = &(data->longest_float);
		}
                is_inf = is_inf_internal = 1;
                scan = regnext(scan);
		goto optimize_curly_tail;
	    case CURLY:
	        if (stopparen>0 && (OP(scan)==CURLYN || OP(scan)==CURLYM)
	            && (scan->flags == stopparen))
		{
		    mincount = 1;
		    maxcount = 1;
		} else {
		    mincount = ARG1(scan);
		    maxcount = ARG2(scan);
		}
		next = regnext(scan);
		if (OP(scan) == CURLYX) {
		    I32 lp = (data ? *(data->last_closep) : 0);
		    scan->flags = ((lp <= (I32)U8_MAX) ? (U8)lp : U8_MAX);
		}
		scan = NEXTOPER(scan) + EXTRA_STEP_2ARGS;
		next_is_eval = (OP(scan) == EVAL);
	      do_curly:
		if (flags & SCF_DO_SUBSTR) {
                    if (mincount == 0)
                        scan_commit(pRExC_state, data, minlenp, is_inf);
                    /* Cannot extend fixed substrings */
		    pos_before = data->pos_min;
		}
		if (data) {
		    fl = data->flags;
		    data->flags &= ~(SF_HAS_PAR|SF_IN_PAR|SF_HAS_EVAL);
		    if (is_inf)
			data->flags |= SF_IS_INF;
		}
		if (flags & SCF_DO_STCLASS) {
		    ssc_init(pRExC_state, &this_class);
		    oclass = data->start_class;
		    data->start_class = &this_class;
		    f |= SCF_DO_STCLASS_AND;
		    f &= ~SCF_DO_STCLASS_OR;
		}
	        /* Exclude from super-linear cache processing any {n,m}
		   regops for which the combination of input pos and regex
		   pos is not enough information to determine if a match
		   will be possible.

		   For example, in the regex /foo(bar\s*){4,8}baz/ with the
		   regex pos at the \s*, the prospects for a match depend not
		   only on the input position but also on how many (bar\s*)
		   repeats into the {4,8} we are. */
               if ((mincount > 1) || (maxcount > 1 && maxcount != REG_INFTY))
		    f &= ~SCF_WHILEM_VISITED_POS;

		/* This will finish on WHILEM, setting scan, or on NULL: */
		minnext = study_chunk(pRExC_state, &scan, minlenp, &deltanext,
                                  last, data, stopparen, recursed_depth, NULL,
                                  (mincount == 0
                                   ? (f & ~SCF_DO_SUBSTR)
                                   : f)
                                  ,depth+1);

		if (flags & SCF_DO_STCLASS)
		    data->start_class = oclass;
		if (mincount == 0 || minnext == 0) {
		    if (flags & SCF_DO_STCLASS_OR) {
			ssc_or(pRExC_state, data->start_class, (regnode_charclass *) &this_class);
		    }
		    else if (flags & SCF_DO_STCLASS_AND) {
			/* Switch to OR mode: cache the old value of
			 * data->start_class */
			INIT_AND_WITHP;
			StructCopy(data->start_class, and_withp, regnode_ssc);
			flags &= ~SCF_DO_STCLASS_AND;
			StructCopy(&this_class, data->start_class, regnode_ssc);
			flags |= SCF_DO_STCLASS_OR;
                        ANYOF_FLAGS(data->start_class)
                                                |= SSC_MATCHES_EMPTY_STRING;
		    }
		} else {		/* Non-zero len */
		    if (flags & SCF_DO_STCLASS_OR) {
			ssc_or(pRExC_state, data->start_class, (regnode_charclass *) &this_class);
			ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);
		    }
		    else if (flags & SCF_DO_STCLASS_AND)
			ssc_and(pRExC_state, data->start_class, (regnode_charclass *) &this_class);
		    flags &= ~SCF_DO_STCLASS;
		}
		if (!scan) 		/* It was not CURLYX, but CURLY. */
		    scan = next;
		if (!(flags & SCF_TRIE_DOING_RESTUDY)
		    /* ? quantifier ok, except for (?{ ... }) */
		    && (next_is_eval || !(mincount == 0 && maxcount == 1))
		    && (minnext == 0) && (deltanext == 0)
		    && data && !(data->flags & (SF_HAS_PAR|SF_IN_PAR))
                    && maxcount <= REG_INFTY/3) /* Complement check for big
                                                   count */
		{
		    /* Fatal warnings may leak the regexp without this: */
		    SAVEFREESV(RExC_rx_sv);
		    Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP),
			"Quantifier unexpected on zero-length expression "
			"in regex m/%"UTF8f"/",
			 UTF8fARG(UTF, RExC_precomp_end - RExC_precomp,
				  RExC_precomp));
		    (void)ReREFCNT_inc(RExC_rx_sv);
		}

		min += minnext * mincount;
		is_inf_internal |= deltanext == SSize_t_MAX
                         || (maxcount == REG_INFTY && minnext + deltanext > 0);
		is_inf |= is_inf_internal;
                if (is_inf) {
		    delta = SSize_t_MAX;
                } else {
		    delta += (minnext + deltanext) * maxcount
                             - minnext * mincount;
                }
		/* Try powerful optimization CURLYX => CURLYN. */
		if (  OP(oscan) == CURLYX && data
		      && data->flags & SF_IN_PAR
		      && !(data->flags & SF_HAS_EVAL)
		      && !deltanext && minnext == 1 ) {
		    /* Try to optimize to CURLYN.  */
		    regnode *nxt = NEXTOPER(oscan) + EXTRA_STEP_2ARGS;
		    regnode * const nxt1 = nxt;
#ifdef DEBUGGING
		    regnode *nxt2;
#endif

		    /* Skip open. */
		    nxt = regnext(nxt);
		    if (!REGNODE_SIMPLE(OP(nxt))
			&& !(PL_regkind[OP(nxt)] == EXACT
			     && STR_LEN(nxt) == 1))
			goto nogo;
#ifdef DEBUGGING
		    nxt2 = nxt;
#endif
		    nxt = regnext(nxt);
		    if (OP(nxt) != CLOSE)
			goto nogo;
		    if (RExC_open_parens) {
                        RExC_open_parens[ARG(nxt1)]=oscan; /*open->CURLYM*/
                        RExC_close_parens[ARG(nxt1)]=nxt+2; /*close->while*/
		    }
		    /* Now we know that nxt2 is the only contents: */
		    oscan->flags = (U8)ARG(nxt);
		    OP(oscan) = CURLYN;
		    OP(nxt1) = NOTHING;	/* was OPEN. */

#ifdef DEBUGGING
		    OP(nxt1 + 1) = OPTIMIZED; /* was count. */
		    NEXT_OFF(nxt1+ 1) = 0; /* just for consistency. */
		    NEXT_OFF(nxt2) = 0;	/* just for consistency with CURLY. */
		    OP(nxt) = OPTIMIZED;	/* was CLOSE. */
		    OP(nxt + 1) = OPTIMIZED; /* was count. */
		    NEXT_OFF(nxt+ 1) = 0; /* just for consistency. */
#endif
		}
	      nogo:

		/* Try optimization CURLYX => CURLYM. */
		if (  OP(oscan) == CURLYX && data
		      && !(data->flags & SF_HAS_PAR)
		      && !(data->flags & SF_HAS_EVAL)
		      && !deltanext	/* atom is fixed width */
		      && minnext != 0	/* CURLYM can't handle zero width */

                         /* Nor characters whose fold at run-time may be
                          * multi-character */
                      && ! (RExC_seen & REG_UNFOLDED_MULTI_SEEN)
		) {
		    /* XXXX How to optimize if data == 0? */
		    /* Optimize to a simpler form.  */
		    regnode *nxt = NEXTOPER(oscan) + EXTRA_STEP_2ARGS; /* OPEN */
		    regnode *nxt2;

		    OP(oscan) = CURLYM;
		    while ( (nxt2 = regnext(nxt)) /* skip over embedded stuff*/
			    && (OP(nxt2) != WHILEM))
			nxt = nxt2;
		    OP(nxt2)  = SUCCEED; /* Whas WHILEM */
		    /* Need to optimize away parenths. */
		    if ((data->flags & SF_IN_PAR) && OP(nxt) == CLOSE) {
			/* Set the parenth number.  */
			regnode *nxt1 = NEXTOPER(oscan) + EXTRA_STEP_2ARGS; /* OPEN*/

			oscan->flags = (U8)ARG(nxt);
			if (RExC_open_parens) {
                            RExC_open_parens[ARG(nxt1)]=oscan; /*open->CURLYM*/
                            RExC_close_parens[ARG(nxt1)]=nxt2+1; /*close->NOTHING*/
			}
			OP(nxt1) = OPTIMIZED;	/* was OPEN. */
			OP(nxt) = OPTIMIZED;	/* was CLOSE. */

#ifdef DEBUGGING
			OP(nxt1 + 1) = OPTIMIZED; /* was count. */
			OP(nxt + 1) = OPTIMIZED; /* was count. */
			NEXT_OFF(nxt1 + 1) = 0; /* just for consistency. */
			NEXT_OFF(nxt + 1) = 0; /* just for consistency. */
#endif
#if 0
			while ( nxt1 && (OP(nxt1) != WHILEM)) {
			    regnode *nnxt = regnext(nxt1);
			    if (nnxt == nxt) {
				if (reg_off_by_arg[OP(nxt1)])
				    ARG_SET(nxt1, nxt2 - nxt1);
				else if (nxt2 - nxt1 < U16_MAX)
				    NEXT_OFF(nxt1) = nxt2 - nxt1;
				else
				    OP(nxt) = NOTHING;	/* Cannot beautify */
			    }
			    nxt1 = nnxt;
			}
#endif
			/* Optimize again: */
			study_chunk(pRExC_state, &nxt1, minlenp, &deltanext, nxt,
                                    NULL, stopparen, recursed_depth, NULL, 0,depth+1);
		    }
		    else
			oscan->flags = 0;
		}
		else if ((OP(oscan) == CURLYX)
			 && (flags & SCF_WHILEM_VISITED_POS)
			 /* See the comment on a similar expression above.
			    However, this time it's not a subexpression
			    we care about, but the expression itself. */
			 && (maxcount == REG_INFTY)
			 && data && ++data->whilem_c < 16) {
		    /* This stays as CURLYX, we can put the count/of pair. */
		    /* Find WHILEM (as in regexec.c) */
		    regnode *nxt = oscan + NEXT_OFF(oscan);

		    if (OP(PREVOPER(nxt)) == NOTHING) /* LONGJMP */
			nxt += ARG(nxt);
		    PREVOPER(nxt)->flags = (U8)(data->whilem_c
			| (RExC_whilem_seen << 4)); /* On WHILEM */
		}
		if (data && fl & (SF_HAS_PAR|SF_IN_PAR))
		    pars++;
		if (flags & SCF_DO_SUBSTR) {
		    SV *last_str = NULL;
                    STRLEN last_chrs = 0;
		    int counted = mincount != 0;

                    if (data->last_end > 0 && mincount != 0) { /* Ends with a
                                                                  string. */
			SSize_t b = pos_before >= data->last_start_min
			    ? pos_before : data->last_start_min;
			STRLEN l;
			const char * const s = SvPV_const(data->last_found, l);
			SSize_t old = b - data->last_start_min;

			if (UTF)
			    old = utf8_hop((U8*)s, old) - (U8*)s;
			l -= old;
			/* Get the added string: */
			last_str = newSVpvn_utf8(s  + old, l, UTF);
                        last_chrs = UTF ? utf8_length((U8*)(s + old),
                                            (U8*)(s + old + l)) : l;
			if (deltanext == 0 && pos_before == b) {
			    /* What was added is a constant string */
			    if (mincount > 1) {

				SvGROW(last_str, (mincount * l) + 1);
				repeatcpy(SvPVX(last_str) + l,
					  SvPVX_const(last_str), l,
                                          mincount - 1);
				SvCUR_set(last_str, SvCUR(last_str) * mincount);
				/* Add additional parts. */
				SvCUR_set(data->last_found,
					  SvCUR(data->last_found) - l);
				sv_catsv(data->last_found, last_str);
				{
				    SV * sv = data->last_found;
				    MAGIC *mg =
					SvUTF8(sv) && SvMAGICAL(sv) ?
					mg_find(sv, PERL_MAGIC_utf8) : NULL;
				    if (mg && mg->mg_len >= 0)
					mg->mg_len += last_chrs * (mincount-1);
				}
                                last_chrs *= mincount;
				data->last_end += l * (mincount - 1);
			    }
			} else {
			    /* start offset must point into the last copy */
			    data->last_start_min += minnext * (mincount - 1);
			    data->last_start_max =
                              is_inf
                               ? SSize_t_MAX
			       : data->last_start_max +
                                 (maxcount - 1) * (minnext + data->pos_delta);
			}
		    }
		    /* It is counted once already... */
		    data->pos_min += minnext * (mincount - counted);
#if 0
Perl_re_printf( aTHX_  "counted=%"UVuf" deltanext=%"UVuf
                              " SSize_t_MAX=%"UVuf" minnext=%"UVuf
                              " maxcount=%"UVuf" mincount=%"UVuf"\n",
    (UV)counted, (UV)deltanext, (UV)SSize_t_MAX, (UV)minnext, (UV)maxcount,
    (UV)mincount);
if (deltanext != SSize_t_MAX)
Perl_re_printf( aTHX_  "LHS=%"UVuf" RHS=%"UVuf"\n",
    (UV)(-counted * deltanext + (minnext + deltanext) * maxcount
          - minnext * mincount), (UV)(SSize_t_MAX - data->pos_delta));
#endif
		    if (deltanext == SSize_t_MAX
                        || -counted * deltanext + (minnext + deltanext) * maxcount - minnext * mincount >= SSize_t_MAX - data->pos_delta)
		        data->pos_delta = SSize_t_MAX;
		    else
		        data->pos_delta += - counted * deltanext +
			(minnext + deltanext) * maxcount - minnext * mincount;
		    if (mincount != maxcount) {
			 /* Cannot extend fixed substrings found inside
			    the group.  */
                        scan_commit(pRExC_state, data, minlenp, is_inf);
			if (mincount && last_str) {
			    SV * const sv = data->last_found;
			    MAGIC * const mg = SvUTF8(sv) && SvMAGICAL(sv) ?
				mg_find(sv, PERL_MAGIC_utf8) : NULL;

			    if (mg)
				mg->mg_len = -1;
			    sv_setsv(sv, last_str);
			    data->last_end = data->pos_min;
			    data->last_start_min = data->pos_min - last_chrs;
			    data->last_start_max = is_inf
				? SSize_t_MAX
				: data->pos_min + data->pos_delta - last_chrs;
			}
			data->longest = &(data->longest_float);
		    }
		    SvREFCNT_dec(last_str);
		}
		if (data && (fl & SF_HAS_EVAL))
		    data->flags |= SF_HAS_EVAL;
	      optimize_curly_tail:
		if (OP(oscan) != CURLYX) {
		    while (PL_regkind[OP(next = regnext(oscan))] == NOTHING
			   && NEXT_OFF(next))
			NEXT_OFF(oscan) += NEXT_OFF(next);
		}
		continue;

	    default:
#ifdef DEBUGGING
                Perl_croak(aTHX_ "panic: unexpected varying REx opcode %d",
                                                                    OP(scan));
#endif
            case REF:
            case CLUMP:
		if (flags & SCF_DO_SUBSTR) {
                    /* Cannot expect anything... */
                    scan_commit(pRExC_state, data, minlenp, is_inf);
		    data->longest = &(data->longest_float);
		}
		is_inf = is_inf_internal = 1;
		if (flags & SCF_DO_STCLASS_OR) {
                    if (OP(scan) == CLUMP) {
                        /* Actually is any start char, but very few code points
                         * aren't start characters */
                        ssc_match_all_cp(data->start_class);
                    }
                    else {
                        ssc_anything(data->start_class);
                    }
                }
		flags &= ~SCF_DO_STCLASS;
		break;
	    }
	}
	else if (OP(scan) == LNBREAK) {
	    if (flags & SCF_DO_STCLASS) {
    	        if (flags & SCF_DO_STCLASS_AND) {
                    ssc_intersection(data->start_class,
                                    PL_XPosix_ptrs[_CC_VERTSPACE], FALSE);
                    ssc_clear_locale(data->start_class);
                    ANYOF_FLAGS(data->start_class)
                                                &= ~SSC_MATCHES_EMPTY_STRING;
                }
                else if (flags & SCF_DO_STCLASS_OR) {
                    ssc_union(data->start_class,
                              PL_XPosix_ptrs[_CC_VERTSPACE],
                              FALSE);
		    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);

                    /* See commit msg for
                     * 749e076fceedeb708a624933726e7989f2302f6a */
                    ANYOF_FLAGS(data->start_class)
                                                &= ~SSC_MATCHES_EMPTY_STRING;
                }
		flags &= ~SCF_DO_STCLASS;
            }
	    min++;
            if (delta != SSize_t_MAX)
                delta++;    /* Because of the 2 char string cr-lf */
            if (flags & SCF_DO_SUBSTR) {
                /* Cannot expect anything... */
                scan_commit(pRExC_state, data, minlenp, is_inf);
    	        data->pos_min += 1;
	        data->pos_delta += 1;
		data->longest = &(data->longest_float);
    	    }
	}
	else if (REGNODE_SIMPLE(OP(scan))) {

	    if (flags & SCF_DO_SUBSTR) {
                scan_commit(pRExC_state, data, minlenp, is_inf);
		data->pos_min++;
	    }
	    min++;
	    if (flags & SCF_DO_STCLASS) {
                bool invert = 0;
                SV* my_invlist = NULL;
                U8 namedclass;

                /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a */
                ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;

		/* Some of the logic below assumes that switching
		   locale on will only add false positives. */
		switch (OP(scan)) {

		default:
#ifdef DEBUGGING
                   Perl_croak(aTHX_ "panic: unexpected simple REx opcode %d",
                                                                     OP(scan));
#endif
		case SANY:
		    if (flags & SCF_DO_STCLASS_OR) /* Allow everything */
			ssc_match_all_cp(data->start_class);
		    break;

		case REG_ANY:
                    {
                        SV* REG_ANY_invlist = _new_invlist(2);
                        REG_ANY_invlist = add_cp_to_invlist(REG_ANY_invlist,
                                                            '\n');
                        if (flags & SCF_DO_STCLASS_OR) {
                            ssc_union(data->start_class,
                                      REG_ANY_invlist,
                                      TRUE /* TRUE => invert, hence all but \n
                                            */
                                      );
                        }
                        else if (flags & SCF_DO_STCLASS_AND) {
                            ssc_intersection(data->start_class,
                                             REG_ANY_invlist,
                                             TRUE  /* TRUE => invert */
                                             );
                            ssc_clear_locale(data->start_class);
                        }
                        SvREFCNT_dec_NN(REG_ANY_invlist);
		    }
		    break;

                case ANYOFD:
                case ANYOFL:
                case ANYOF:
		    if (flags & SCF_DO_STCLASS_AND)
			ssc_and(pRExC_state, data->start_class,
                                (regnode_charclass *) scan);
		    else
			ssc_or(pRExC_state, data->start_class,
                                                          (regnode_charclass *) scan);
		    break;

		case NPOSIXL:
                    invert = 1;
                    /* FALLTHROUGH */

		case POSIXL:
                    namedclass = classnum_to_namedclass(FLAGS(scan)) + invert;
                    if (flags & SCF_DO_STCLASS_AND) {
                        bool was_there = cBOOL(
                                          ANYOF_POSIXL_TEST(data->start_class,
                                                                 namedclass));
                        ANYOF_POSIXL_ZERO(data->start_class);
                        if (was_there) {    /* Do an AND */
                            ANYOF_POSIXL_SET(data->start_class, namedclass);
                        }
                        /* No individual code points can now match */
                        data->start_class->invlist
                                                = sv_2mortal(_new_invlist(0));
                    }
                    else {
                        int complement = namedclass + ((invert) ? -1 : 1);

                        assert(flags & SCF_DO_STCLASS_OR);

                        /* If the complement of this class was already there,
                         * the result is that they match all code points,
                         * (\d + \D == everything).  Remove the classes from
                         * future consideration.  Locale is not relevant in
                         * this case */
                        if (ANYOF_POSIXL_TEST(data->start_class, complement)) {
                            ssc_match_all_cp(data->start_class);
                            ANYOF_POSIXL_CLEAR(data->start_class, namedclass);
                            ANYOF_POSIXL_CLEAR(data->start_class, complement);
                        }
                        else {  /* The usual case; just add this class to the
                                   existing set */
                            ANYOF_POSIXL_SET(data->start_class, namedclass);
                        }
                    }
                    break;

                case NPOSIXA:   /* For these, we always know the exact set of
                                   what's matched */
                    invert = 1;
                    /* FALLTHROUGH */
		case POSIXA:
                    if (FLAGS(scan) == _CC_ASCII) {
                        my_invlist = invlist_clone(PL_XPosix_ptrs[_CC_ASCII]);
                    }
                    else {
                        _invlist_intersection(PL_XPosix_ptrs[FLAGS(scan)],
                                              PL_XPosix_ptrs[_CC_ASCII],
                                              &my_invlist);
                    }
                    goto join_posix;

		case NPOSIXD:
		case NPOSIXU:
                    invert = 1;
                    /* FALLTHROUGH */
		case POSIXD:
		case POSIXU:
                    my_invlist = invlist_clone(PL_XPosix_ptrs[FLAGS(scan)]);

                    /* NPOSIXD matches all upper Latin1 code points unless the
                     * target string being matched is UTF-8, which is
                     * unknowable until match time.  Since we are going to
                     * invert, we want to get rid of all of them so that the
                     * inversion will match all */
                    if (OP(scan) == NPOSIXD) {
                        _invlist_subtract(my_invlist, PL_UpperLatin1,
                                          &my_invlist);
                    }

                  join_posix:

                    if (flags & SCF_DO_STCLASS_AND) {
                        ssc_intersection(data->start_class, my_invlist, invert);
                        ssc_clear_locale(data->start_class);
                    }
                    else {
                        assert(flags & SCF_DO_STCLASS_OR);
                        ssc_union(data->start_class, my_invlist, invert);
                    }
                    SvREFCNT_dec(my_invlist);
		}
		if (flags & SCF_DO_STCLASS_OR)
		    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);
		flags &= ~SCF_DO_STCLASS;
	    }
	}
	else if (PL_regkind[OP(scan)] == EOL && flags & SCF_DO_SUBSTR) {
	    data->flags |= (OP(scan) == MEOL
			    ? SF_BEFORE_MEOL
			    : SF_BEFORE_SEOL);
            scan_commit(pRExC_state, data, minlenp, is_inf);

	}
	else if (  PL_regkind[OP(scan)] == BRANCHJ
		 /* Lookbehind, or need to calculate parens/evals/stclass: */
		   && (scan->flags || data || (flags & SCF_DO_STCLASS))
		   && (OP(scan) == IFMATCH || OP(scan) == UNLESSM))
        {
            if ( !PERL_ENABLE_POSITIVE_ASSERTION_STUDY
                || OP(scan) == UNLESSM )
            {
                /* Negative Lookahead/lookbehind
                   In this case we can't do fixed string optimisation.
                */

                SSize_t deltanext, minnext, fake = 0;
                regnode *nscan;
                regnode_ssc intrnl;
                int f = 0;

                StructCopy(&zero_scan_data, &data_fake, scan_data_t);
                if (data) {
                    data_fake.whilem_c = data->whilem_c;
                    data_fake.last_closep = data->last_closep;
		}
                else
                    data_fake.last_closep = &fake;
		data_fake.pos_delta = delta;
                if ( flags & SCF_DO_STCLASS && !scan->flags
                     && OP(scan) == IFMATCH ) { /* Lookahead */
                    ssc_init(pRExC_state, &intrnl);
                    data_fake.start_class = &intrnl;
                    f |= SCF_DO_STCLASS_AND;
		}
                if (flags & SCF_WHILEM_VISITED_POS)
                    f |= SCF_WHILEM_VISITED_POS;
                next = regnext(scan);
                nscan = NEXTOPER(NEXTOPER(scan));
                minnext = study_chunk(pRExC_state, &nscan, minlenp, &deltanext,
                                      last, &data_fake, stopparen,
                                      recursed_depth, NULL, f, depth+1);
                if (scan->flags) {
                    if (deltanext) {
			FAIL("Variable length lookbehind not implemented");
                    }
                    else if (minnext > (I32)U8_MAX) {
			FAIL2("Lookbehind longer than %"UVuf" not implemented",
                              (UV)U8_MAX);
                    }
                    scan->flags = (U8)minnext;
                }
                if (data) {
                    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))
                        pars++;
                    if (data_fake.flags & SF_HAS_EVAL)
                        data->flags |= SF_HAS_EVAL;
                    data->whilem_c = data_fake.whilem_c;
                }
                if (f & SCF_DO_STCLASS_AND) {
		    if (flags & SCF_DO_STCLASS_OR) {
			/* OR before, AND after: ideally we would recurse with
			 * data_fake to get the AND applied by study of the
			 * remainder of the pattern, and then derecurse;
			 * *** HACK *** for now just treat as "no information".
			 * See [perl #56690].
			 */
			ssc_init(pRExC_state, data->start_class);
		    }  else {
                        /* AND before and after: combine and continue.  These
                         * assertions are zero-length, so can match an EMPTY
                         * string */
			ssc_and(pRExC_state, data->start_class, (regnode_charclass *) &intrnl);
                        ANYOF_FLAGS(data->start_class)
                                                   |= SSC_MATCHES_EMPTY_STRING;
		    }
                }
	    }
#if PERL_ENABLE_POSITIVE_ASSERTION_STUDY
            else {
                /* Positive Lookahead/lookbehind
                   In this case we can do fixed string optimisation,
                   but we must be careful about it. Note in the case of
                   lookbehind the positions will be offset by the minimum
                   length of the pattern, something we won't know about
                   until after the recurse.
                */
                SSize_t deltanext, fake = 0;
                regnode *nscan;
                regnode_ssc intrnl;
                int f = 0;
                /* We use SAVEFREEPV so that when the full compile
                    is finished perl will clean up the allocated
                    minlens when it's all done. This way we don't
                    have to worry about freeing them when we know
                    they wont be used, which would be a pain.
                 */
                SSize_t *minnextp;
                Newx( minnextp, 1, SSize_t );
                SAVEFREEPV(minnextp);

                if (data) {
                    StructCopy(data, &data_fake, scan_data_t);
                    if ((flags & SCF_DO_SUBSTR) && data->last_found) {
                        f |= SCF_DO_SUBSTR;
                        if (scan->flags)
                            scan_commit(pRExC_state, &data_fake, minlenp, is_inf);
                        data_fake.last_found=newSVsv(data->last_found);
                    }
                }
                else
                    data_fake.last_closep = &fake;
                data_fake.flags = 0;
		data_fake.pos_delta = delta;
                if (is_inf)
	            data_fake.flags |= SF_IS_INF;
                if ( flags & SCF_DO_STCLASS && !scan->flags
                     && OP(scan) == IFMATCH ) { /* Lookahead */
                    ssc_init(pRExC_state, &intrnl);
                    data_fake.start_class = &intrnl;
                    f |= SCF_DO_STCLASS_AND;
                }
                if (flags & SCF_WHILEM_VISITED_POS)
                    f |= SCF_WHILEM_VISITED_POS;
                next = regnext(scan);
                nscan = NEXTOPER(NEXTOPER(scan));

                *minnextp = study_chunk(pRExC_state, &nscan, minnextp,
                                        &deltanext, last, &data_fake,
                                        stopparen, recursed_depth, NULL,
                                        f,depth+1);
                if (scan->flags) {
                    if (deltanext) {
			FAIL("Variable length lookbehind not implemented");
                    }
                    else if (*minnextp > (I32)U8_MAX) {
			FAIL2("Lookbehind longer than %"UVuf" not implemented",
                              (UV)U8_MAX);
                    }
                    scan->flags = (U8)*minnextp;
                }

                *minnextp += min;

                if (f & SCF_DO_STCLASS_AND) {
                    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) &intrnl);
                    ANYOF_FLAGS(data->start_class) |= SSC_MATCHES_EMPTY_STRING;
                }
                if (data) {
                    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))
                        pars++;
                    if (data_fake.flags & SF_HAS_EVAL)
                        data->flags |= SF_HAS_EVAL;
                    data->whilem_c = data_fake.whilem_c;
                    if ((flags & SCF_DO_SUBSTR) && data_fake.last_found) {
                        if (RExC_rx->minlen<*minnextp)
                            RExC_rx->minlen=*minnextp;
                        scan_commit(pRExC_state, &data_fake, minnextp, is_inf);
                        SvREFCNT_dec_NN(data_fake.last_found);

                        if ( data_fake.minlen_fixed != minlenp )
                        {
                            data->offset_fixed= data_fake.offset_fixed;
                            data->minlen_fixed= data_fake.minlen_fixed;
                            data->lookbehind_fixed+= scan->flags;
                        }
                        if ( data_fake.minlen_float != minlenp )
                        {
                            data->minlen_float= data_fake.minlen_float;
                            data->offset_float_min=data_fake.offset_float_min;
                            data->offset_float_max=data_fake.offset_float_max;
                            data->lookbehind_float+= scan->flags;
                        }
                    }
                }
	    }
#endif
	}
	else if (OP(scan) == OPEN) {
	    if (stopparen != (I32)ARG(scan))
	        pars++;
	}
	else if (OP(scan) == CLOSE) {
	    if (stopparen == (I32)ARG(scan)) {
	        break;
	    }
	    if ((I32)ARG(scan) == is_par) {
		next = regnext(scan);

		if ( next && (OP(next) != WHILEM) && next < last)
		    is_par = 0;		/* Disable optimization */
	    }
	    if (data)
		*(data->last_closep) = ARG(scan);
	}
	else if (OP(scan) == EVAL) {
		if (data)
		    data->flags |= SF_HAS_EVAL;
	}
	else if ( PL_regkind[OP(scan)] == ENDLIKE ) {
	    if (flags & SCF_DO_SUBSTR) {
                scan_commit(pRExC_state, data, minlenp, is_inf);
		flags &= ~SCF_DO_SUBSTR;
	    }
	    if (data && OP(scan)==ACCEPT) {
	        data->flags |= SCF_SEEN_ACCEPT;
	        if (stopmin > min)
	            stopmin = min;
	    }
	}
	else if (OP(scan) == LOGICAL && scan->flags == 2) /* Embedded follows */
	{
		if (flags & SCF_DO_SUBSTR) {
                    scan_commit(pRExC_state, data, minlenp, is_inf);
		    data->longest = &(data->longest_float);
		}
		is_inf = is_inf_internal = 1;
		if (flags & SCF_DO_STCLASS_OR) /* Allow everything */
		    ssc_anything(data->start_class);
		flags &= ~SCF_DO_STCLASS;
	}
	else if (OP(scan) == GPOS) {
            if (!(RExC_rx->intflags & PREGf_GPOS_FLOAT) &&
	        !(delta || is_inf || (data && data->pos_delta)))
	    {
                if (!(RExC_rx->intflags & PREGf_ANCH) && (flags & SCF_DO_SUBSTR))
                    RExC_rx->intflags |= PREGf_ANCH_GPOS;
	        if (RExC_rx->gofs < (STRLEN)min)
		    RExC_rx->gofs = min;
            } else {
                RExC_rx->intflags |= PREGf_GPOS_FLOAT;
                RExC_rx->gofs = 0;
            }
	}
#ifdef TRIE_STUDY_OPT
#ifdef FULL_TRIE_STUDY
        else if (PL_regkind[OP(scan)] == TRIE) {
            /* NOTE - There is similar code to this block above for handling
               BRANCH nodes on the initial study.  If you change stuff here
               check there too. */
            regnode *trie_node= scan;
            regnode *tail= regnext(scan);
            reg_trie_data *trie = (reg_trie_data*)RExC_rxi->data->data[ ARG(scan) ];
            SSize_t max1 = 0, min1 = SSize_t_MAX;
            regnode_ssc accum;

            if (flags & SCF_DO_SUBSTR) { /* XXXX Add !SUSPEND? */
                /* Cannot merge strings after this. */
                scan_commit(pRExC_state, data, minlenp, is_inf);
            }
            if (flags & SCF_DO_STCLASS)
                ssc_init_zero(pRExC_state, &accum);

            if (!trie->jump) {
                min1= trie->minlen;
                max1= trie->maxlen;
            } else {
                const regnode *nextbranch= NULL;
                U32 word;

                for ( word=1 ; word <= trie->wordcount ; word++)
                {
                    SSize_t deltanext=0, minnext=0, f = 0, fake;
                    regnode_ssc this_class;

                    StructCopy(&zero_scan_data, &data_fake, scan_data_t);
                    if (data) {
                        data_fake.whilem_c = data->whilem_c;
                        data_fake.last_closep = data->last_closep;
                    }
                    else
                        data_fake.last_closep = &fake;
		    data_fake.pos_delta = delta;
                    if (flags & SCF_DO_STCLASS) {
                        ssc_init(pRExC_state, &this_class);
                        data_fake.start_class = &this_class;
                        f = SCF_DO_STCLASS_AND;
                    }
                    if (flags & SCF_WHILEM_VISITED_POS)
                        f |= SCF_WHILEM_VISITED_POS;

                    if (trie->jump[word]) {
                        if (!nextbranch)
                            nextbranch = trie_node + trie->jump[0];
                        scan= trie_node + trie->jump[word];
                        /* We go from the jump point to the branch that follows
                           it. Note this means we need the vestigal unused
                           branches even though they arent otherwise used. */
                        minnext = study_chunk(pRExC_state, &scan, minlenp,
                            &deltanext, (regnode *)nextbranch, &data_fake,
                            stopparen, recursed_depth, NULL, f,depth+1);
                    }
                    if (nextbranch && PL_regkind[OP(nextbranch)]==BRANCH)
                        nextbranch= regnext((regnode*)nextbranch);

                    if (min1 > (SSize_t)(minnext + trie->minlen))
                        min1 = minnext + trie->minlen;
                    if (deltanext == SSize_t_MAX) {
                        is_inf = is_inf_internal = 1;
                        max1 = SSize_t_MAX;
                    } else if (max1 < (SSize_t)(minnext + deltanext + trie->maxlen))
                        max1 = minnext + deltanext + trie->maxlen;

                    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))
                        pars++;
                    if (data_fake.flags & SCF_SEEN_ACCEPT) {
                        if ( stopmin > min + min1)
	                    stopmin = min + min1;
	                flags &= ~SCF_DO_SUBSTR;
	                if (data)
	                    data->flags |= SCF_SEEN_ACCEPT;
	            }
                    if (data) {
                        if (data_fake.flags & SF_HAS_EVAL)
                            data->flags |= SF_HAS_EVAL;
                        data->whilem_c = data_fake.whilem_c;
                    }
                    if (flags & SCF_DO_STCLASS)
                        ssc_or(pRExC_state, &accum, (regnode_charclass *) &this_class);
                }
            }
            if (flags & SCF_DO_SUBSTR) {
                data->pos_min += min1;
                data->pos_delta += max1 - min1;
                if (max1 != min1 || is_inf)
                    data->longest = &(data->longest_float);
            }
            min += min1;
            if (delta != SSize_t_MAX)
                delta += max1 - min1;
            if (flags & SCF_DO_STCLASS_OR) {
                ssc_or(pRExC_state, data->start_class, (regnode_charclass *) &accum);
                if (min1) {
                    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);
                    flags &= ~SCF_DO_STCLASS;
                }
            }
            else if (flags & SCF_DO_STCLASS_AND) {
                if (min1) {
                    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) &accum);
                    flags &= ~SCF_DO_STCLASS;
                }
                else {
                    /* Switch to OR mode: cache the old value of
                     * data->start_class */
		    INIT_AND_WITHP;
                    StructCopy(data->start_class, and_withp, regnode_ssc);
                    flags &= ~SCF_DO_STCLASS_AND;
                    StructCopy(&accum, data->start_class, regnode_ssc);
                    flags |= SCF_DO_STCLASS_OR;
                }
            }
            scan= tail;
            continue;
        }
#else
	else if (PL_regkind[OP(scan)] == TRIE) {
	    reg_trie_data *trie = (reg_trie_data*)RExC_rxi->data->data[ ARG(scan) ];
	    U8*bang=NULL;

	    min += trie->minlen;
	    delta += (trie->maxlen - trie->minlen);
	    flags &= ~SCF_DO_STCLASS; /* xxx */
            if (flags & SCF_DO_SUBSTR) {
                /* Cannot expect anything... */
                scan_commit(pRExC_state, data, minlenp, is_inf);
    	        data->pos_min += trie->minlen;
    	        data->pos_delta += (trie->maxlen - trie->minlen);
		if (trie->maxlen != trie->minlen)
		    data->longest = &(data->longest_float);
    	    }
    	    if (trie->jump) /* no more substrings -- for now /grr*/
               flags &= ~SCF_DO_SUBSTR;
	}
#endif /* old or new */
#endif /* TRIE_STUDY_OPT */

	/* Else: zero-length, ignore. */
	scan = regnext(scan);
    }
    /* If we are exiting a recursion we can unset its recursed bit
     * and allow ourselves to enter it again - no danger of an
     * infinite loop there.
    if (stopparen > -1 && recursed) {
	DEBUG_STUDYDATA("unset:", data,depth);
        PAREN_UNSET( recursed, stopparen);
    }
    */
    if (frame) {
        depth = depth - 1;

        DEBUG_STUDYDATA("frame-end:",data,depth);
        DEBUG_PEEP("fend", scan, depth);

        /* restore previous context */
        last = frame->last_regnode;
        scan = frame->next_regnode;
        stopparen = frame->stopparen;
        recursed_depth = frame->prev_recursed_depth;

        RExC_frame_last = frame->prev_frame;
        frame = frame->this_prev_frame;
        goto fake_study_recurse;
    }

  finish:
    assert(!frame);
    DEBUG_STUDYDATA("pre-fin:",data,depth);

    *scanp = scan;
    *deltap = is_inf_internal ? SSize_t_MAX : delta;

    if (flags & SCF_DO_SUBSTR && is_inf)
	data->pos_delta = SSize_t_MAX - data->pos_min;
    if (is_par > (I32)U8_MAX)
	is_par = 0;
    if (is_par && pars==1 && data) {
	data->flags |= SF_IN_PAR;
	data->flags &= ~SF_HAS_PAR;
    }
    else if (pars && data) {
	data->flags |= SF_HAS_PAR;
	data->flags &= ~SF_IN_PAR;
    }
    if (flags & SCF_DO_STCLASS_OR)
	ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);
    if (flags & SCF_TRIE_RESTUDY)
        data->flags |= 	SCF_TRIE_RESTUDY;

    DEBUG_STUDYDATA("post-fin:",data,depth);

    {
        SSize_t final_minlen= min < stopmin ? min : stopmin;

        if (!(RExC_seen & REG_UNBOUNDED_QUANTIFIER_SEEN)) {
            if (final_minlen > SSize_t_MAX - delta)
                RExC_maxlen = SSize_t_MAX;
            else if (RExC_maxlen < final_minlen + delta)
                RExC_maxlen = final_minlen + delta;
        }
        return final_minlen;
    }
    NOT_REACHED; /* NOTREACHED */
}

STATIC U32
S_add_data(RExC_state_t* const pRExC_state, const char* const s, const U32 n)
{
    U32 count = RExC_rxi->data ? RExC_rxi->data->count : 0;

    PERL_ARGS_ASSERT_ADD_DATA;

    Renewc(RExC_rxi->data,
	   sizeof(*RExC_rxi->data) + sizeof(void*) * (count + n - 1),
	   char, struct reg_data);
    if(count)
	Renew(RExC_rxi->data->what, count + n, U8);
    else
	Newx(RExC_rxi->data->what, n, U8);
    RExC_rxi->data->count = count + n;
    Copy(s, RExC_rxi->data->what + count, n, U8);
    return count;
}

/*XXX: todo make this not included in a non debugging perl, but appears to be
 * used anyway there, in 'use re' */
#ifndef PERL_IN_XSUB_RE
void
Perl_reginitcolors(pTHX)
{
    const char * const s = PerlEnv_getenv("PERL_RE_COLORS");
    if (s) {
	char *t = savepv(s);
	int i = 0;
	PL_colors[0] = t;
	while (++i < 6) {
	    t = strchr(t, '\t');
	    if (t) {
		*t = '\0';
		PL_colors[i] = ++t;
	    }
	    else
		PL_colors[i] = t = (char *)"";
	}
    } else {
	int i = 0;
	while (i < 6)
	    PL_colors[i++] = (char *)"";
    }
    PL_colorset = 1;
}
#endif


#ifdef TRIE_STUDY_OPT
#define CHECK_RESTUDY_GOTO_butfirst(dOsomething)            \
    STMT_START {                                            \
        if (                                                \
              (data.flags & SCF_TRIE_RESTUDY)               \
              && ! restudied++                              \
        ) {                                                 \
            dOsomething;                                    \
            goto reStudy;                                   \
        }                                                   \
    } STMT_END
#else
#define CHECK_RESTUDY_GOTO_butfirst
#endif

/*
 * pregcomp - compile a regular expression into internal code
 *
 * Decides which engine's compiler to call based on the hint currently in
 * scope
 */

#ifndef PERL_IN_XSUB_RE

/* return the currently in-scope regex engine (or the default if none)  */

regexp_engine const *
Perl_current_re_engine(pTHX)
{
    if (IN_PERL_COMPILETIME) {
	HV * const table = GvHV(PL_hintgv);
	SV **ptr;

	if (!table || !(PL_hints & HINT_LOCALIZE_HH))
	    return &PL_core_reg_engine;
	ptr = hv_fetchs(table, "regcomp", FALSE);
	if ( !(ptr && SvIOK(*ptr) && SvIV(*ptr)))
	    return &PL_core_reg_engine;
	return INT2PTR(regexp_engine*,SvIV(*ptr));
    }
    else {
	SV *ptr;
	if (!PL_curcop->cop_hints_hash)
	    return &PL_core_reg_engine;
	ptr = cop_hints_fetch_pvs(PL_curcop, "regcomp", 0);
	if ( !(ptr && SvIOK(ptr) && SvIV(ptr)))
	    return &PL_core_reg_engine;
	return INT2PTR(regexp_engine*,SvIV(ptr));
    }
}


REGEXP *
Perl_pregcomp(pTHX_ SV * const pattern, const U32 flags)
{
    regexp_engine const *eng = current_re_engine();
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_PREGCOMP;

    /* Dispatch a request to compile a regexp to correct regexp engine. */
    DEBUG_COMPILE_r({
        Perl_re_printf( aTHX_  "Using engine %"UVxf"\n",
			PTR2UV(eng));
    });
    return CALLREGCOMP_ENG(eng, pattern, flags);
}
#endif

/* public(ish) entry point for the perl core's own regex compiling code.
 * It's actually a wrapper for Perl_re_op_compile that only takes an SV
 * pattern rather than a list of OPs, and uses the internal engine rather
 * than the current one */

REGEXP *
Perl_re_compile(pTHX_ SV * const pattern, U32 rx_flags)
{
    SV *pat = pattern; /* defeat constness! */
    PERL_ARGS_ASSERT_RE_COMPILE;
    return Perl_re_op_compile(aTHX_ &pat, 1, NULL,
#ifdef PERL_IN_XSUB_RE
                                &my_reg_engine,
#else
                                &PL_core_reg_engine,
#endif
                                NULL, NULL, rx_flags, 0);
}


/* upgrade pattern pat_p of length plen_p to UTF8, and if there are code
 * blocks, recalculate the indices. Update pat_p and plen_p in-place to
 * point to the realloced string and length.
 *
 * This is essentially a copy of Perl_bytes_to_utf8() with the code index
 * stuff added */

static void
S_pat_upgrade_to_utf8(pTHX_ RExC_state_t * const pRExC_state,
		    char **pat_p, STRLEN *plen_p, int num_code_blocks)
{
    U8 *const src = (U8*)*pat_p;
    U8 *dst, *d;
    int n=0;
    STRLEN s = 0;
    bool do_end = 0;
    GET_RE_DEBUG_FLAGS_DECL;

    DEBUG_PARSE_r(Perl_re_printf( aTHX_
        "UTF8 mismatch! Converting to utf8 for resizing and compile\n"));

    Newx(dst, *plen_p * 2 + 1, U8);
    d = dst;

    while (s < *plen_p) {
        append_utf8_from_native_byte(src[s], &d);
        if (n < num_code_blocks) {
            if (!do_end && pRExC_state->code_blocks[n].start == s) {
                pRExC_state->code_blocks[n].start = d - dst - 1;
                assert(*(d - 1) == '(');
                do_end = 1;
            }
            else if (do_end && pRExC_state->code_blocks[n].end == s) {
                pRExC_state->code_blocks[n].end = d - dst - 1;
                assert(*(d - 1) == ')');
                do_end = 0;
                n++;
            }
        }
        s++;
    }
    *d = '\0';
    *plen_p = d - dst;
    *pat_p = (char*) dst;
    SAVEFREEPV(*pat_p);
    RExC_orig_utf8 = RExC_utf8 = 1;
}



/* S_concat_pat(): concatenate a list of args to the pattern string pat,
 * while recording any code block indices, and handling overloading,
 * nested qr// objects etc.  If pat is null, it will allocate a new
 * string, or just return the first arg, if there's only one.
 *
 * Returns the malloced/updated pat.
 * patternp and pat_count is the array of SVs to be concatted;
 * oplist is the optional list of ops that generated the SVs;
 * recompile_p is a pointer to a boolean that will be set if
 *   the regex will need to be recompiled.
 * delim, if non-null is an SV that will be inserted between each element
 */

static SV*
S_concat_pat(pTHX_ RExC_state_t * const pRExC_state,
                SV *pat, SV ** const patternp, int pat_count,
                OP *oplist, bool *recompile_p, SV *delim)
{
    SV **svp;
    int n = 0;
    bool use_delim = FALSE;
    bool alloced = FALSE;

    /* if we know we have at least two args, create an empty string,
     * then concatenate args to that. For no args, return an empty string */
    if (!pat && pat_count != 1) {
        pat = newSVpvs("");
        SAVEFREESV(pat);
        alloced = TRUE;
    }

    for (svp = patternp; svp < patternp + pat_count; svp++) {
        SV *sv;
        SV *rx  = NULL;
        STRLEN orig_patlen = 0;
        bool code = 0;
        SV *msv = use_delim ? delim : *svp;
        if (!msv) msv = &PL_sv_undef;

        /* if we've got a delimiter, we go round the loop twice for each
         * svp slot (except the last), using the delimiter the second
         * time round */
        if (use_delim) {
            svp--;
            use_delim = FALSE;
        }
        else if (delim)
            use_delim = TRUE;

        if (SvTYPE(msv) == SVt_PVAV) {
            /* we've encountered an interpolated array within
             * the pattern, e.g. /...@@a..../. Expand the list of elements,
             * then recursively append elements.
             * The code in this block is based on S_pushav() */

            AV *const av = (AV*)msv;
            const SSize_t maxarg = AvFILL(av) + 1;
            SV **array;

            if (oplist) {
                assert(oplist->op_type == OP_PADAV
                    || oplist->op_type == OP_RV2AV);
                oplist = OpSIBLING(oplist);
            }

            if (SvRMAGICAL(av)) {
                SSize_t i;

                Newx(array, maxarg, SV*);
                SAVEFREEPV(array);
                for (i=0; i < maxarg; i++) {
                    SV ** const svp = av_fetch(av, i, FALSE);
                    array[i] = svp ? *svp : &PL_sv_undef;
                }
            }
            else
                array = AvARRAY(av);

            pat = S_concat_pat(aTHX_ pRExC_state, pat,
                                array, maxarg, NULL, recompile_p,
                                /* $" */
                                GvSV((gv_fetchpvs("\"", GV_ADDMULTI, SVt_PV))));

            continue;
        }


        /* we make the assumption here that each op in the list of
         * op_siblings maps to one SV pushed onto the stack,
         * except for code blocks, with have both an OP_NULL and
         * and OP_CONST.
         * This allows us to match up the list of SVs against the
         * list of OPs to find the next code block.
         *
         * Note that       PUSHMARK PADSV PADSV ..
         * is optimised to
         *                 PADRANGE PADSV  PADSV  ..
         * so the alignment still works. */

        if (oplist) {
            if (oplist->op_type == OP_NULL
                && (oplist->op_flags & OPf_SPECIAL))
            {
                assert(n < pRExC_state->num_code_blocks);
                pRExC_state->code_blocks[n].start = pat ? SvCUR(pat) : 0;
                pRExC_state->code_blocks[n].block = oplist;
                pRExC_state->code_blocks[n].src_regex = NULL;
                n++;
                code = 1;
                oplist = OpSIBLING(oplist); /* skip CONST */
                assert(oplist);
            }
            oplist = OpSIBLING(oplist);;
        }

	/* apply magic and QR overloading to arg */

        SvGETMAGIC(msv);
        if (SvROK(msv) && SvAMAGIC(msv)) {
            SV *sv = AMG_CALLunary(msv, regexp_amg);
            if (sv) {
                if (SvROK(sv))
                    sv = SvRV(sv);
                if (SvTYPE(sv) != SVt_REGEXP)
                    Perl_croak(aTHX_ "Overloaded qr did not return a REGEXP");
                msv = sv;
            }
        }

        /* try concatenation overload ... */
        if (pat && (SvAMAGIC(pat) || SvAMAGIC(msv)) &&
                (sv = amagic_call(pat, msv, concat_amg, AMGf_assign)))
        {
            sv_setsv(pat, sv);
            /* overloading involved: all bets are off over literal
             * code. Pretend we haven't seen it */
            pRExC_state->num_code_blocks -= n;
            n = 0;
        }
        else  {
            /* ... or failing that, try "" overload */
            while (SvAMAGIC(msv)
                    && (sv = AMG_CALLunary(msv, string_amg))
                    && sv != msv
                    &&  !(   SvROK(msv)
                          && SvROK(sv)
                          && SvRV(msv) == SvRV(sv))
            ) {
                msv = sv;
                SvGETMAGIC(msv);
            }
            if (SvROK(msv) && SvTYPE(SvRV(msv)) == SVt_REGEXP)
                msv = SvRV(msv);

            if (pat) {
                /* this is a partially unrolled
                 *     sv_catsv_nomg(pat, msv);
                 * that allows us to adjust code block indices if
                 * needed */
                STRLEN dlen;
                char *dst = SvPV_force_nomg(pat, dlen);
                orig_patlen = dlen;
                if (SvUTF8(msv) && !SvUTF8(pat)) {
                    S_pat_upgrade_to_utf8(aTHX_ pRExC_state, &dst, &dlen, n);
                    sv_setpvn(pat, dst, dlen);
                    SvUTF8_on(pat);
                }
                sv_catsv_nomg(pat, msv);
                rx = msv;
            }
            else
                pat = msv;

            if (code)
                pRExC_state->code_blocks[n-1].end = SvCUR(pat)-1;
        }

        /* extract any code blocks within any embedded qr//'s */
        if (rx && SvTYPE(rx) == SVt_REGEXP
            && RX_ENGINE((REGEXP*)rx)->op_comp)
        {

            RXi_GET_DECL(ReANY((REGEXP *)rx), ri);
            if (ri->num_code_blocks) {
                int i;
                /* the presence of an embedded qr// with code means
                 * we should always recompile: the text of the
                 * qr// may not have changed, but it may be a
                 * different closure than last time */
                *recompile_p = 1;
                Renew(pRExC_state->code_blocks,
                    pRExC_state->num_code_blocks + ri->num_code_blocks,
                    struct reg_code_block);
                pRExC_state->num_code_blocks += ri->num_code_blocks;

                for (i=0; i < ri->num_code_blocks; i++) {
                    struct reg_code_block *src, *dst;
                    STRLEN offset =  orig_patlen
                        + ReANY((REGEXP *)rx)->pre_prefix;
                    assert(n < pRExC_state->num_code_blocks);
                    src = &ri->code_blocks[i];
                    dst = &pRExC_state->code_blocks[n];
                    dst->start	    = src->start + offset;
                    dst->end	    = src->end   + offset;
                    dst->block	    = src->block;
                    dst->src_regex  = (REGEXP*) SvREFCNT_inc( (SV*)
                                            src->src_regex
                                                ? src->src_regex
                                                : (REGEXP*)rx);
                    n++;
                }
            }
        }
    }
    /* avoid calling magic multiple times on a single element e.g. =~ $qr */
    if (alloced)
        SvSETMAGIC(pat);

    return pat;
}



/* see if there are any run-time code blocks in the pattern.
 * False positives are allowed */

static bool
S_has_runtime_code(pTHX_ RExC_state_t * const pRExC_state,
		    char *pat, STRLEN plen)
{
    int n = 0;
    STRLEN s;
    
    PERL_UNUSED_CONTEXT;

    for (s = 0; s < plen; s++) {
	if (n < pRExC_state->num_code_blocks
	    && s == pRExC_state->code_blocks[n].start)
	{
	    s = pRExC_state->code_blocks[n].end;
	    n++;
	    continue;
	}
	/* TODO ideally should handle [..], (#..), /#.../x to reduce false
	 * positives here */
	if (pat[s] == '(' && s+2 <= plen && pat[s+1] == '?' &&
	    (pat[s+2] == '{'
                || (s + 2 <= plen && pat[s+2] == '?' && pat[s+3] == '{'))
	)
	    return 1;
    }
    return 0;
}

/* Handle run-time code blocks. We will already have compiled any direct
 * or indirect literal code blocks. Now, take the pattern 'pat' and make a
 * copy of it, but with any literal code blocks blanked out and
 * appropriate chars escaped; then feed it into
 *
 *    eval "qr'modified_pattern'"
 *
 * For example,
 *
 *       a\bc(?{"this was literal"})def'ghi\\jkl(?{"this is runtime"})mno
 *
 * becomes
 *
 *    qr'a\\bc_______________________def\'ghi\\\\jkl(?{"this is runtime"})mno'
 *
 * After eval_sv()-ing that, grab any new code blocks from the returned qr
 * and merge them with any code blocks of the original regexp.
 *
 * If the pat is non-UTF8, while the evalled qr is UTF8, don't merge;
 * instead, just save the qr and return FALSE; this tells our caller that
 * the original pattern needs upgrading to utf8.
 */

static bool
S_compile_runtime_code(pTHX_ RExC_state_t * const pRExC_state,
    char *pat, STRLEN plen)
{
    SV *qr;

    GET_RE_DEBUG_FLAGS_DECL;

    if (pRExC_state->runtime_code_qr) {
	/* this is the second time we've been called; this should
	 * only happen if the main pattern got upgraded to utf8
	 * during compilation; re-use the qr we compiled first time
	 * round (which should be utf8 too)
	 */
	qr = pRExC_state->runtime_code_qr;
	pRExC_state->runtime_code_qr = NULL;
	assert(RExC_utf8 && SvUTF8(qr));
    }
    else {
	int n = 0;
	STRLEN s;
	char *p, *newpat;
	int newlen = plen + 6; /* allow for "qr''x\0" extra chars */
	SV *sv, *qr_ref;
	dSP;

	/* determine how many extra chars we need for ' and \ escaping */
	for (s = 0; s < plen; s++) {
	    if (pat[s] == '\'' || pat[s] == '\\')
		newlen++;
	}

	Newx(newpat, newlen, char);
	p = newpat;
	*p++ = 'q'; *p++ = 'r'; *p++ = '\'';

	for (s = 0; s < plen; s++) {
	    if (n < pRExC_state->num_code_blocks
		&& s == pRExC_state->code_blocks[n].start)
	    {
		/* blank out literal code block */
		assert(pat[s] == '(');
		while (s <= pRExC_state->code_blocks[n].end) {
		    *p++ = '_';
		    s++;
		}
		s--;
		n++;
		continue;
	    }
	    if (pat[s] == '\'' || pat[s] == '\\')
		*p++ = '\\';
	    *p++ = pat[s];
	}
	*p++ = '\'';
	if (pRExC_state->pm_flags & RXf_PMf_EXTENDED)
	    *p++ = 'x';
	*p++ = '\0';
	DEBUG_COMPILE_r({
            Perl_re_printf( aTHX_
		"%sre-parsing pattern for runtime code:%s %s\n",
		PL_colors[4],PL_colors[5],newpat);
	});

	sv = newSVpvn_flags(newpat, p-newpat-1, RExC_utf8 ? SVf_UTF8 : 0);
	Safefree(newpat);

	ENTER;
	SAVETMPS;
	save_re_context();
	PUSHSTACKi(PERLSI_REQUIRE);
        /* G_RE_REPARSING causes the toker to collapse \\ into \ when
         * parsing qr''; normally only q'' does this. It also alters
         * hints handling */
	eval_sv(sv, G_SCALAR|G_RE_REPARSING);
	SvREFCNT_dec_NN(sv);
	SPAGAIN;
	qr_ref = POPs;
	PUTBACK;
	{
	    SV * const errsv = ERRSV;
	    if (SvTRUE_NN(errsv))
	    {
		Safefree(pRExC_state->code_blocks);
                /* use croak_sv ? */
		Perl_croak_nocontext("%"SVf, SVfARG(errsv));
	    }
	}
	assert(SvROK(qr_ref));
	qr = SvRV(qr_ref);
	assert(SvTYPE(qr) == SVt_REGEXP && RX_ENGINE((REGEXP*)qr)->op_comp);
	/* the leaving below frees the tmp qr_ref.
	 * Give qr a life of its own */
	SvREFCNT_inc(qr);
	POPSTACK;
	FREETMPS;
	LEAVE;

    }

    if (!RExC_utf8 && SvUTF8(qr)) {
	/* first time through; the pattern got upgraded; save the
	 * qr for the next time through */
	assert(!pRExC_state->runtime_code_qr);
	pRExC_state->runtime_code_qr = qr;
	return 0;
    }


    /* extract any code blocks within the returned qr//  */


    /* merge the main (r1) and run-time (r2) code blocks into one */
    {
	RXi_GET_DECL(ReANY((REGEXP *)qr), r2);
	struct reg_code_block *new_block, *dst;
	RExC_state_t * const r1 = pRExC_state; /* convenient alias */
	int i1 = 0, i2 = 0;

	if (!r2->num_code_blocks) /* we guessed wrong */
	{
	    SvREFCNT_dec_NN(qr);
	    return 1;
	}

	Newx(new_block,
	    r1->num_code_blocks + r2->num_code_blocks,
	    struct reg_code_block);
	dst = new_block;

	while (    i1 < r1->num_code_blocks
		|| i2 < r2->num_code_blocks)
	{
	    struct reg_code_block *src;
	    bool is_qr = 0;

	    if (i1 == r1->num_code_blocks) {
		src = &r2->code_blocks[i2++];
		is_qr = 1;
	    }
	    else if (i2 == r2->num_code_blocks)
		src = &r1->code_blocks[i1++];
	    else if (  r1->code_blocks[i1].start
	             < r2->code_blocks[i2].start)
	    {
		src = &r1->code_blocks[i1++];
		assert(src->end < r2->code_blocks[i2].start);
	    }
	    else {
		assert(  r1->code_blocks[i1].start
		       > r2->code_blocks[i2].start);
		src = &r2->code_blocks[i2++];
		is_qr = 1;
		assert(src->end < r1->code_blocks[i1].start);
	    }

	    assert(pat[src->start] == '(');
	    assert(pat[src->end]   == ')');
	    dst->start	    = src->start;
	    dst->end	    = src->end;
	    dst->block	    = src->block;
	    dst->src_regex  = is_qr ? (REGEXP*) SvREFCNT_inc( (SV*) qr)
				    : src->src_regex;
	    dst++;
	}
	r1->num_code_blocks += r2->num_code_blocks;
	Safefree(r1->code_blocks);
	r1->code_blocks = new_block;
    }

    SvREFCNT_dec_NN(qr);
    return 1;
}


STATIC bool
S_setup_longest(pTHX_ RExC_state_t *pRExC_state, SV* sv_longest,
                      SV** rx_utf8, SV** rx_substr, SSize_t* rx_end_shift,
		      SSize_t lookbehind, SSize_t offset, SSize_t *minlen,
                      STRLEN longest_length, bool eol, bool meol)
{
    /* This is the common code for setting up the floating and fixed length
     * string data extracted from Perl_re_op_compile() below.  Returns a boolean
     * as to whether succeeded or not */

    I32 t;
    SSize_t ml;

    if (! (longest_length
           || (eol /* Can't have SEOL and MULTI */
               && (! meol || (RExC_flags & RXf_PMf_MULTILINE)))
          )
            /* See comments for join_exact for why REG_UNFOLDED_MULTI_SEEN */
        || (RExC_seen & REG_UNFOLDED_MULTI_SEEN))
    {
        return FALSE;
    }

    /* copy the information about the longest from the reg_scan_data
        over to the program. */
    if (SvUTF8(sv_longest)) {
        *rx_utf8 = sv_longest;
        *rx_substr = NULL;
    } else {
        *rx_substr = sv_longest;
        *rx_utf8 = NULL;
    }
    /* end_shift is how many chars that must be matched that
        follow this item. We calculate it ahead of time as once the
        lookbehind offset is added in we lose the ability to correctly
        calculate it.*/
    ml = minlen ? *(minlen) : (SSize_t)longest_length;
    *rx_end_shift = ml - offset
        - longest_length + (SvTAIL(sv_longest) != 0)
        + lookbehind;

    t = (eol/* Can't have SEOL and MULTI */
         && (! meol || (RExC_flags & RXf_PMf_MULTILINE)));
    fbm_compile(sv_longest, t ? FBMcf_TAIL : 0);

    return TRUE;
}

/*
 * Perl_re_op_compile - the perl internal RE engine's function to compile a
 * regular expression into internal code.
 * The pattern may be passed either as:
 *    a list of SVs (patternp plus pat_count)
 *    a list of OPs (expr)
 * If both are passed, the SV list is used, but the OP list indicates
 * which SVs are actually pre-compiled code blocks
 *
 * The SVs in the list have magic and qr overloading applied to them (and
 * the list may be modified in-place with replacement SVs in the latter
 * case).
 *
 * If the pattern hasn't changed from old_re, then old_re will be
 * returned.
 *
 * eng is the current engine. If that engine has an op_comp method, then
 * handle directly (i.e. we assume that op_comp was us); otherwise, just
 * do the initial concatenation of arguments and pass on to the external
 * engine.
 *
 * If is_bare_re is not null, set it to a boolean indicating whether the
 * arg list reduced (after overloading) to a single bare regex which has
 * been returned (i.e. /$qr/).
 *
 * orig_rx_flags contains RXf_* flags. See perlreapi.pod for more details.
 *
 * pm_flags contains the PMf_* flags, typically based on those from the
 * pm_flags field of the related PMOP. Currently we're only interested in
 * PMf_HAS_CV, PMf_IS_QR, PMf_USE_RE_EVAL.
 *
 * We can't allocate space until we know how big the compiled form will be,
 * but we can't compile it (and thus know how big it is) until we've got a
 * place to put the code.  So we cheat:  we compile it twice, once with code
 * generation turned off and size counting turned on, and once "for real".
 * This also means that we don't allocate space until we are sure that the
 * thing really will compile successfully, and we never have to move the
 * code and thus invalidate pointers into it.  (Note that it has to be in
 * one piece because free() must be able to free it all.) [NB: not true in perl]
 *
 * Beware that the optimization-preparation code in here knows about some
 * of the structure of the compiled regexp.  [I'll say.]
 */

REGEXP *
Perl_re_op_compile(pTHX_ SV ** const patternp, int pat_count,
		    OP *expr, const regexp_engine* eng, REGEXP *old_re,
		     bool *is_bare_re, U32 orig_rx_flags, U32 pm_flags)
{
    REGEXP *rx;
    struct regexp *r;
    regexp_internal *ri;
    STRLEN plen;
    char *exp;
    regnode *scan;
    I32 flags;
    SSize_t minlen = 0;
    U32 rx_flags;
    SV *pat;
    SV *code_blocksv = NULL;
    SV** new_patternp = patternp;

    /* these are all flags - maybe they should be turned
     * into a single int with different bit masks */
    I32 sawlookahead = 0;
    I32 sawplus = 0;
    I32 sawopen = 0;
    I32 sawminmod = 0;

    regex_charset initial_charset = get_regex_charset(orig_rx_flags);
    bool recompile = 0;
    bool runtime_code = 0;
    scan_data_t data;
    RExC_state_t RExC_state;
    RExC_state_t * const pRExC_state = &RExC_state;
#ifdef TRIE_STUDY_OPT
    int restudied = 0;
    RExC_state_t copyRExC_state;
#endif
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_RE_OP_COMPILE;

    DEBUG_r(if (!PL_colorset) reginitcolors());

    /* Initialize these here instead of as-needed, as is quick and avoids
     * having to test them each time otherwise */
    if (! PL_AboveLatin1) {
#ifdef DEBUGGING
        char * dump_len_string;
#endif

	PL_AboveLatin1 = _new_invlist_C_array(AboveLatin1_invlist);
	PL_Latin1 = _new_invlist_C_array(Latin1_invlist);
	PL_UpperLatin1 = _new_invlist_C_array(UpperLatin1_invlist);
        PL_utf8_foldable = _new_invlist_C_array(_Perl_Any_Folds_invlist);
        PL_HasMultiCharFold =
                       _new_invlist_C_array(_Perl_Folds_To_Multi_Char_invlist);

        /* This is calculated here, because the Perl program that generates the
         * static global ones doesn't currently have access to
         * NUM_ANYOF_CODE_POINTS */
	PL_InBitmap = _new_invlist(2);
	PL_InBitmap = _add_range_to_invlist(PL_InBitmap, 0,
                                                    NUM_ANYOF_CODE_POINTS - 1);
#ifdef DEBUGGING
        dump_len_string = PerlEnv_getenv("PERL_DUMP_RE_MAX_LEN");
        if (   ! dump_len_string
            || ! grok_atoUV(dump_len_string, (UV *)&PL_dump_re_max_len, NULL))
        {
            PL_dump_re_max_len = 0;
        }
#endif
    }

    pRExC_state->code_blocks = NULL;
    pRExC_state->num_code_blocks = 0;

    if (is_bare_re)
	*is_bare_re = FALSE;

    if (expr && (expr->op_type == OP_LIST ||
		(expr->op_type == OP_NULL && expr->op_targ == OP_LIST))) {
	/* allocate code_blocks if needed */
	OP *o;
	int ncode = 0;

	for (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o))
	    if (o->op_type == OP_NULL && (o->op_flags & OPf_SPECIAL))
		ncode++; /* count of DO blocks */
	if (ncode) {
	    pRExC_state->num_code_blocks = ncode;
	    Newx(pRExC_state->code_blocks, ncode, struct reg_code_block);
	}
    }

    if (!pat_count) {
        /* compile-time pattern with just OP_CONSTs and DO blocks */

        int n;
        OP *o;

        /* find how many CONSTs there are */
        assert(expr);
        n = 0;
        if (expr->op_type == OP_CONST)
            n = 1;
        else
            for (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o)) {
                if (o->op_type == OP_CONST)
                    n++;
            }

        /* fake up an SV array */

        assert(!new_patternp);
        Newx(new_patternp, n, SV*);
        SAVEFREEPV(new_patternp);
        pat_count = n;

        n = 0;
        if (expr->op_type == OP_CONST)
            new_patternp[n] = cSVOPx_sv(expr);
        else
            for (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o)) {
                if (o->op_type == OP_CONST)
                    new_patternp[n++] = cSVOPo_sv;
            }

    }

    DEBUG_PARSE_r(Perl_re_printf( aTHX_
        "Assembling pattern from %d elements%s\n", pat_count,
            orig_rx_flags & RXf_SPLIT ? " for split" : ""));

    /* set expr to the first arg op */

    if (pRExC_state->num_code_blocks
         && expr->op_type != OP_CONST)
    {
            expr = cLISTOPx(expr)->op_first;
            assert(   expr->op_type == OP_PUSHMARK
                   || (expr->op_type == OP_NULL && expr->op_targ == OP_PUSHMARK)
                   || expr->op_type == OP_PADRANGE);
            expr = OpSIBLING(expr);
    }

    pat = S_concat_pat(aTHX_ pRExC_state, NULL, new_patternp, pat_count,
                        expr, &recompile, NULL);

    /* handle bare (possibly after overloading) regex: foo =~ $re */
    {
        SV *re = pat;
        if (SvROK(re))
            re = SvRV(re);
        if (SvTYPE(re) == SVt_REGEXP) {
            if (is_bare_re)
                *is_bare_re = TRUE;
            SvREFCNT_inc(re);
            Safefree(pRExC_state->code_blocks);
            DEBUG_PARSE_r(Perl_re_printf( aTHX_
                "Precompiled pattern%s\n",
                    orig_rx_flags & RXf_SPLIT ? " for split" : ""));

            return (REGEXP*)re;
        }
    }

    exp = SvPV_nomg(pat, plen);

    if (!eng->op_comp) {
	if ((SvUTF8(pat) && IN_BYTES)
		|| SvGMAGICAL(pat) || SvAMAGIC(pat))
	{
	    /* make a temporary copy; either to convert to bytes,
	     * or to avoid repeating get-magic / overloaded stringify */
	    pat = newSVpvn_flags(exp, plen, SVs_TEMP |
					(IN_BYTES ? 0 : SvUTF8(pat)));
	}
	Safefree(pRExC_state->code_blocks);
	return CALLREGCOMP_ENG(eng, pat, orig_rx_flags);
    }

    /* ignore the utf8ness if the pattern is 0 length */
    RExC_utf8 = RExC_orig_utf8 = (plen == 0 || IN_BYTES) ? 0 : SvUTF8(pat);

    RExC_uni_semantics = 0;
    RExC_seen_unfolded_sharp_s = 0;
    RExC_contains_locale = 0;
    RExC_contains_i = 0;
    RExC_strict = cBOOL(pm_flags & RXf_PMf_STRICT);
    pRExC_state->runtime_code_qr = NULL;
    RExC_frame_head= NULL;
    RExC_frame_last= NULL;
    RExC_frame_count= 0;

    DEBUG_r({
        RExC_mysv1= sv_newmortal();
        RExC_mysv2= sv_newmortal();
    });
    DEBUG_COMPILE_r({
            SV *dsv= sv_newmortal();
            RE_PV_QUOTED_DECL(s, RExC_utf8, dsv, exp, plen, 60);
            Perl_re_printf( aTHX_  "%sCompiling REx%s %s\n",
                          PL_colors[4],PL_colors[5],s);
        });

  redo_first_pass:
    /* we jump here if we have to recompile, e.g., from upgrading the pattern
     * to utf8 */

    if ((pm_flags & PMf_USE_RE_EVAL)
		/* this second condition covers the non-regex literal case,
		 * i.e.  $foo =~ '(?{})'. */
		|| (IN_PERL_COMPILETIME && (PL_hints & HINT_RE_EVAL))
    )
	runtime_code = S_has_runtime_code(aTHX_ pRExC_state, exp, plen);

    /* return old regex if pattern hasn't changed */
    /* XXX: note in the below we have to check the flags as well as the
     * pattern.
     *
     * Things get a touch tricky as we have to compare the utf8 flag
     * independently from the compile flags.  */

    if (   old_re
        && !recompile
        && !!RX_UTF8(old_re) == !!RExC_utf8
        && ( RX_COMPFLAGS(old_re) == ( orig_rx_flags & RXf_PMf_FLAGCOPYMASK ) )
	&& RX_PRECOMP(old_re)
	&& RX_PRELEN(old_re) == plen
        && memEQ(RX_PRECOMP(old_re), exp, plen)
	&& !runtime_code /* with runtime code, always recompile */ )
    {
        Safefree(pRExC_state->code_blocks);
        return old_re;
    }

    rx_flags = orig_rx_flags;

    if (rx_flags & PMf_FOLD) {
        RExC_contains_i = 1;
    }
    if (   initial_charset == REGEX_DEPENDS_CHARSET
        && (RExC_utf8 ||RExC_uni_semantics))
    {

	/* Set to use unicode semantics if the pattern is in utf8 and has the
	 * 'depends' charset specified, as it means unicode when utf8  */
	set_regex_charset(&rx_flags, REGEX_UNICODE_CHARSET);
    }

    RExC_precomp = exp;
    RExC_precomp_adj = 0;
    RExC_flags = rx_flags;
    RExC_pm_flags = pm_flags;

    if (runtime_code) {
        assert(TAINTING_get || !TAINT_get);
	if (TAINT_get)
	    Perl_croak(aTHX_ "Eval-group in insecure regular expression");

	if (!S_compile_runtime_code(aTHX_ pRExC_state, exp, plen)) {
	    /* whoops, we have a non-utf8 pattern, whilst run-time code
	     * got compiled as utf8. Try again with a utf8 pattern */
            S_pat_upgrade_to_utf8(aTHX_ pRExC_state, &exp, &plen,
                                    pRExC_state->num_code_blocks);
            goto redo_first_pass;
	}
    }
    assert(!pRExC_state->runtime_code_qr);

    RExC_sawback = 0;

    RExC_seen = 0;
    RExC_maxlen = 0;
    RExC_in_lookbehind = 0;
    RExC_seen_zerolen = *exp == '^' ? -1 : 0;
    RExC_extralen = 0;
    RExC_override_recoding = 0;
#ifdef EBCDIC
    RExC_recode_x_to_native = 0;
#endif
    RExC_in_multi_char_class = 0;

    /* First pass: determine size, legality. */
    RExC_parse = exp;
    RExC_start = RExC_adjusted_start = exp;
    RExC_end = exp + plen;
    RExC_precomp_end = RExC_end;
    RExC_naughty = 0;
    RExC_npar = 1;
    RExC_nestroot = 0;
    RExC_size = 0L;
    RExC_emit = (regnode *) &RExC_emit_dummy;
    RExC_whilem_seen = 0;
    RExC_open_parens = NULL;
    RExC_close_parens = NULL;
    RExC_end_op = NULL;
    RExC_paren_names = NULL;
#ifdef DEBUGGING
    RExC_paren_name_list = NULL;
#endif
    RExC_recurse = NULL;
    RExC_study_chunk_recursed = NULL;
    RExC_study_chunk_recursed_bytes= 0;
    RExC_recurse_count = 0;
    pRExC_state->code_index = 0;

    /* This NUL is guaranteed because the pattern comes from an SV*, and the sv
     * code makes sure the final byte is an uncounted NUL.  But should this
     * ever not be the case, lots of things could read beyond the end of the
     * buffer: loops like
     *      while(isFOO(*RExC_parse)) RExC_parse++;
     *      strchr(RExC_parse, "foo");
     * etc.  So it is worth noting. */
    assert(*RExC_end == '\0');

    DEBUG_PARSE_r(
        Perl_re_printf( aTHX_  "Starting first pass (sizing)\n");
        RExC_lastnum=0;
        RExC_lastparse=NULL;
    );
    /* reg may croak on us, not giving us a chance to free
       pRExC_state->code_blocks.  We cannot SAVEFREEPV it now, as we may
       need it to survive as long as the regexp (qr/(?{})/).
       We must check that code_blocksv is not already set, because we may
       have jumped back to restart the sizing pass. */
    if (pRExC_state->code_blocks && !code_blocksv) {
	code_blocksv = newSV_type(SVt_PV);
	SAVEFREESV(code_blocksv);
	SvPV_set(code_blocksv, (char *)pRExC_state->code_blocks);
	SvLEN_set(code_blocksv, 1); /*sufficient to make sv_clear free it*/
    }
    if (reg(pRExC_state, 0, &flags,1) == NULL) {
        /* It's possible to write a regexp in ascii that represents Unicode
        codepoints outside of the byte range, such as via \x{100}. If we
        detect such a sequence we have to convert the entire pattern to utf8
        and then recompile, as our sizing calculation will have been based
        on 1 byte == 1 character, but we will need to use utf8 to encode
        at least some part of the pattern, and therefore must convert the whole
        thing.
        -- dmq */
        if (flags & RESTART_PASS1) {
            if (flags & NEED_UTF8) {
                S_pat_upgrade_to_utf8(aTHX_ pRExC_state, &exp, &plen,
                                    pRExC_state->num_code_blocks);
            }
            else {
                DEBUG_PARSE_r(Perl_re_printf( aTHX_
                "Need to redo pass 1\n"));
            }

            goto redo_first_pass;
        }
        Perl_croak(aTHX_ "panic: reg returned NULL to re_op_compile for sizing pass, flags=%#"UVxf"", (UV) flags);
    }
    if (code_blocksv)
	SvLEN_set(code_blocksv,0); /* no you can't have it, sv_clear */

    DEBUG_PARSE_r({
        Perl_re_printf( aTHX_
            "Required size %"IVdf" nodes\n"
            "Starting second pass (creation)\n",
            (IV)RExC_size);
        RExC_lastnum=0;
        RExC_lastparse=NULL;
    });

    /* The first pass could have found things that force Unicode semantics */
    if ((RExC_utf8 || RExC_uni_semantics)
	 && get_regex_charset(rx_flags) == REGEX_DEPENDS_CHARSET)
    {
	set_regex_charset(&rx_flags, REGEX_UNICODE_CHARSET);
    }

    /* Small enough for pointer-storage convention?
       If extralen==0, this means that we will not need long jumps. */
    if (RExC_size >= 0x10000L && RExC_extralen)
        RExC_size += RExC_extralen;
    else
	RExC_extralen = 0;
    if (RExC_whilem_seen > 15)
	RExC_whilem_seen = 15;

    /* Allocate space and zero-initialize. Note, the two step process
       of zeroing when in debug mode, thus anything assigned has to
       happen after that */
    rx = (REGEXP*) newSV_type(SVt_REGEXP);
    r = ReANY(rx);
    Newxc(ri, sizeof(regexp_internal) + (unsigned)RExC_size * sizeof(regnode),
	 char, regexp_internal);
    if ( r == NULL || ri == NULL )
	FAIL("Regexp out of space");
#ifdef DEBUGGING
    /* avoid reading uninitialized memory in DEBUGGING code in study_chunk() */
    Zero(ri, sizeof(regexp_internal) + (unsigned)RExC_size * sizeof(regnode),
         char);
#else
    /* bulk initialize base fields with 0. */
    Zero(ri, sizeof(regexp_internal), char);
#endif

    /* non-zero initialization begins here */
    RXi_SET( r, ri );
    r->engine= eng;
    r->extflags = rx_flags;
    RXp_COMPFLAGS(r) = orig_rx_flags & RXf_PMf_FLAGCOPYMASK;

    if (pm_flags & PMf_IS_QR) {
	ri->code_blocks = pRExC_state->code_blocks;
	ri->num_code_blocks = pRExC_state->num_code_blocks;
    }
    else
    {
	int n;
	for (n = 0; n < pRExC_state->num_code_blocks; n++)
	    if (pRExC_state->code_blocks[n].src_regex)
		SAVEFREESV(pRExC_state->code_blocks[n].src_regex);
	if(pRExC_state->code_blocks)
	    SAVEFREEPV(pRExC_state->code_blocks); /* often null */
    }

    {
        bool has_p     = ((r->extflags & RXf_PMf_KEEPCOPY) == RXf_PMf_KEEPCOPY);
        bool has_charset = (get_regex_charset(r->extflags)
                                                    != REGEX_DEPENDS_CHARSET);

        /* The caret is output if there are any defaults: if not all the STD
         * flags are set, or if no character set specifier is needed */
        bool has_default =
                    (((r->extflags & RXf_PMf_STD_PMMOD) != RXf_PMf_STD_PMMOD)
                    || ! has_charset);
        bool has_runon = ((RExC_seen & REG_RUN_ON_COMMENT_SEEN)
                                                   == REG_RUN_ON_COMMENT_SEEN);
	U8 reganch = (U8)((r->extflags & RXf_PMf_STD_PMMOD)
			    >> RXf_PMf_STD_PMMOD_SHIFT);
	const char *fptr = STD_PAT_MODS;        /*"msixn"*/
	char *p;

        /* We output all the necessary flags; we never output a minus, as all
         * those are defaults, so are
         * covered by the caret */
	const STRLEN wraplen = plen + has_p + has_runon
            + has_default       /* If needs a caret */
            + PL_bitcount[reganch] /* 1 char for each set standard flag */

		/* If needs a character set specifier */
	    + ((has_charset) ? MAX_CHARSET_NAME_LENGTH : 0)
            + (sizeof("(?:)") - 1);

        /* make sure PL_bitcount bounds not exceeded */
        assert(sizeof(STD_PAT_MODS) <= 8);

        Newx(p, wraplen + 1, char); /* +1 for the ending NUL */
	r->xpv_len_u.xpvlenu_pv = p;
	if (RExC_utf8)
	    SvFLAGS(rx) |= SVf_UTF8;
        *p++='('; *p++='?';

        /* If a default, cover it using the caret */
        if (has_default) {
            *p++= DEFAULT_PAT_MOD;
        }
        if (has_charset) {
	    STRLEN len;
	    const char* const name = get_regex_charset_name(r->extflags, &len);
	    Copy(name, p, len, char);
	    p += len;
        }
        if (has_p)
            *p++ = KEEPCOPY_PAT_MOD; /*'p'*/
        {
            char ch;
            while((ch = *fptr++)) {
                if(reganch & 1)
                    *p++ = ch;
                reganch >>= 1;
            }
        }

        *p++ = ':';
        Copy(RExC_precomp, p, plen, char);
	assert ((RX_WRAPPED(rx) - p) < 16);
	r->pre_prefix = p - RX_WRAPPED(rx);
        p += plen;
        if (has_runon)
            *p++ = '\n';
        *p++ = ')';
        *p = 0;
	SvCUR_set(rx, p - RX_WRAPPED(rx));
    }

    r->intflags = 0;
    r->nparens = RExC_npar - 1;	/* set early to validate backrefs */

    /* Useful during FAIL. */
#ifdef RE_TRACK_PATTERN_OFFSETS
    Newxz(ri->u.offsets, 2*RExC_size+1, U32); /* MJD 20001228 */
    DEBUG_OFFSETS_r(Perl_re_printf( aTHX_
                          "%s %"UVuf" bytes for offset annotations.\n",
                          ri->u.offsets ? "Got" : "Couldn't get",
                          (UV)((2*RExC_size+1) * sizeof(U32))));
#endif
    SetProgLen(ri,RExC_size);
    RExC_rx_sv = rx;
    RExC_rx = r;
    RExC_rxi = ri;

    /* Second pass: emit code. */
    RExC_flags = rx_flags;	/* don't let top level (?i) bleed */
    RExC_pm_flags = pm_flags;
    RExC_parse = exp;
    RExC_end = exp + plen;
    RExC_naughty = 0;
    RExC_emit_start = ri->program;
    RExC_emit = ri->program;
    RExC_emit_bound = ri->program + RExC_size + 1;
    pRExC_state->code_index = 0;

    *((char*) RExC_emit++) = (char) REG_MAGIC;
    /* setup various meta data about recursion, this all requires
     * RExC_npar to be correctly set, and a bit later on we clear it */
    if (RExC_seen & REG_RECURSE_SEEN) {
        DEBUG_OPTIMISE_MORE_r(Perl_re_printf( aTHX_
            "%*s%*s Setting up open/close parens\n",
                  22, "|    |", (int)(0 * 2 + 1), ""));

        /* setup RExC_open_parens, which holds the address of each
         * OPEN tag, and to make things simpler for the 0 index
         * the start of the program - this is used later for offsets */
        Newxz(RExC_open_parens, RExC_npar,regnode *);
        SAVEFREEPV(RExC_open_parens);
        RExC_open_parens[0] = RExC_emit;

        /* setup RExC_close_parens, which holds the address of each
         * CLOSE tag, and to make things simpler for the 0 index
         * the end of the program - this is used later for offsets */
        Newxz(RExC_close_parens, RExC_npar,regnode *);
        SAVEFREEPV(RExC_close_parens);
        /* we dont know where end op starts yet, so we dont
         * need to set RExC_close_parens[0] like we do RExC_open_parens[0] above */

        /* Note, RExC_npar is 1 + the number of parens in a pattern.
         * So its 1 if there are no parens. */
        RExC_study_chunk_recursed_bytes= (RExC_npar >> 3) +
                                         ((RExC_npar & 0x07) != 0);
        Newx(RExC_study_chunk_recursed,
             RExC_study_chunk_recursed_bytes * RExC_npar, U8);
        SAVEFREEPV(RExC_study_chunk_recursed);
    }
    RExC_npar = 1;
    if (reg(pRExC_state, 0, &flags,1) == NULL) {
	ReREFCNT_dec(rx);
        Perl_croak(aTHX_ "panic: reg returned NULL to re_op_compile for generation pass, flags=%#"UVxf"", (UV) flags);
    }
    DEBUG_OPTIMISE_r(
        Perl_re_printf( aTHX_  "Starting post parse optimization\n");
    );

    /* XXXX To minimize changes to RE engine we always allocate
       3-units-long substrs field. */
    Newx(r->substrs, 1, struct reg_substr_data);
    if (RExC_recurse_count) {
        Newxz(RExC_recurse,RExC_recurse_count,regnode *);
        SAVEFREEPV(RExC_recurse);
    }

  reStudy:
    r->minlen = minlen = sawlookahead = sawplus = sawopen = sawminmod = 0;
    DEBUG_r(
        RExC_study_chunk_recursed_count= 0;
    );
    Zero(r->substrs, 1, struct reg_substr_data);
    if (RExC_study_chunk_recursed) {
        Zero(RExC_study_chunk_recursed,
             RExC_study_chunk_recursed_bytes * RExC_npar, U8);
    }


#ifdef TRIE_STUDY_OPT
    if (!restudied) {
        StructCopy(&zero_scan_data, &data, scan_data_t);
        copyRExC_state = RExC_state;
    } else {
        U32 seen=RExC_seen;
        DEBUG_OPTIMISE_r(Perl_re_printf( aTHX_ "Restudying\n"));

        RExC_state = copyRExC_state;
        if (seen & REG_TOP_LEVEL_BRANCHES_SEEN)
            RExC_seen |= REG_TOP_LEVEL_BRANCHES_SEEN;
        else
            RExC_seen &= ~REG_TOP_LEVEL_BRANCHES_SEEN;
	StructCopy(&zero_scan_data, &data, scan_data_t);
    }
#else
    StructCopy(&zero_scan_data, &data, scan_data_t);
#endif

    /* Dig out information for optimizations. */
    r->extflags = RExC_flags; /* was pm_op */
    /*dmq: removed as part of de-PMOP: pm->op_pmflags = RExC_flags; */

    if (UTF)
	SvUTF8_on(rx);	/* Unicode in it? */
    ri->regstclass = NULL;
    if (RExC_naughty >= TOO_NAUGHTY)	/* Probably an expensive pattern. */
	r->intflags |= PREGf_NAUGHTY;
    scan = ri->program + 1;		/* First BRANCH. */

    /* testing for BRANCH here tells us whether there is "must appear"
       data in the pattern. If there is then we can use it for optimisations */
    if (!(RExC_seen & REG_TOP_LEVEL_BRANCHES_SEEN)) { /*  Only one top-level choice.
                                                  */
	SSize_t fake;
	STRLEN longest_float_length, longest_fixed_length;
	regnode_ssc ch_class; /* pointed to by data */
	int stclass_flag;
	SSize_t last_close = 0; /* pointed to by data */
        regnode *first= scan;
        regnode *first_next= regnext(first);
	/*
	 * Skip introductions and multiplicators >= 1
	 * so that we can extract the 'meat' of the pattern that must
	 * match in the large if() sequence following.
	 * NOTE that EXACT is NOT covered here, as it is normally
	 * picked up by the optimiser separately.
	 *
	 * This is unfortunate as the optimiser isnt handling lookahead
	 * properly currently.
	 *
	 */
	while ((OP(first) == OPEN && (sawopen = 1)) ||
	       /* An OR of *one* alternative - should not happen now. */
	    (OP(first) == BRANCH && OP(first_next) != BRANCH) ||
	    /* for now we can't handle lookbehind IFMATCH*/
	    (OP(first) == IFMATCH && !first->flags && (sawlookahead = 1)) ||
	    (OP(first) == PLUS) ||
	    (OP(first) == MINMOD) ||
	       /* An {n,m} with n>0 */
	    (PL_regkind[OP(first)] == CURLY && ARG1(first) > 0) ||
	    (OP(first) == NOTHING && PL_regkind[OP(first_next)] != END ))
	{
		/*
		 * the only op that could be a regnode is PLUS, all the rest
		 * will be regnode_1 or regnode_2.
		 *
                 * (yves doesn't think this is true)
		 */
		if (OP(first) == PLUS)
		    sawplus = 1;
                else {
                    if (OP(first) == MINMOD)
                        sawminmod = 1;
		    first += regarglen[OP(first)];
                }
		first = NEXTOPER(first);
		first_next= regnext(first);
	}

	/* Starting-point info. */
      again:
        DEBUG_PEEP("first:",first,0);
        /* Ignore EXACT as we deal with it later. */
	if (PL_regkind[OP(first)] == EXACT) {
	    if (OP(first) == EXACT || OP(first) == EXACTL)
		NOOP;	/* Empty, get anchored substr later. */
	    else
		ri->regstclass = first;
	}
#ifdef TRIE_STCLASS
	else if (PL_regkind[OP(first)] == TRIE &&
	        ((reg_trie_data *)ri->data->data[ ARG(first) ])->minlen>0)
	{
            /* this can happen only on restudy */
            ri->regstclass = construct_ahocorasick_from_trie(pRExC_state, (regnode *)first, 0);
	}
#endif
	else if (REGNODE_SIMPLE(OP(first)))
	    ri->regstclass = first;
	else if (PL_regkind[OP(first)] == BOUND ||
		 PL_regkind[OP(first)] == NBOUND)
	    ri->regstclass = first;
	else if (PL_regkind[OP(first)] == BOL) {
            r->intflags |= (OP(first) == MBOL
                           ? PREGf_ANCH_MBOL
                           : PREGf_ANCH_SBOL);
	    first = NEXTOPER(first);
	    goto again;
	}
	else if (OP(first) == GPOS) {
            r->intflags |= PREGf_ANCH_GPOS;
	    first = NEXTOPER(first);
	    goto again;
	}
	else if ((!sawopen || !RExC_sawback) &&
            !sawlookahead &&
	    (OP(first) == STAR &&
	    PL_regkind[OP(NEXTOPER(first))] == REG_ANY) &&
            !(r->intflags & PREGf_ANCH) && !pRExC_state->num_code_blocks)
	{
	    /* turn .* into ^.* with an implied $*=1 */
	    const int type =
		(OP(NEXTOPER(first)) == REG_ANY)
                    ? PREGf_ANCH_MBOL
                    : PREGf_ANCH_SBOL;
            r->intflags |= (type | PREGf_IMPLICIT);
	    first = NEXTOPER(first);
	    goto again;
	}
        if (sawplus && !sawminmod && !sawlookahead
            && (!sawopen || !RExC_sawback)
	    && !pRExC_state->num_code_blocks) /* May examine pos and $& */
	    /* x+ must match at the 1st pos of run of x's */
	    r->intflags |= PREGf_SKIP;

	/* Scan is after the zeroth branch, first is atomic matcher. */
#ifdef TRIE_STUDY_OPT
	DEBUG_PARSE_r(
	    if (!restudied)
                Perl_re_printf( aTHX_  "first at %"IVdf"\n",
			      (IV)(first - scan + 1))
        );
#else
	DEBUG_PARSE_r(
            Perl_re_printf( aTHX_  "first at %"IVdf"\n",
	        (IV)(first - scan + 1))
        );
#endif


	/*
	* If there's something expensive in the r.e., find the
	* longest literal string that must appear and make it the
	* regmust.  Resolve ties in favor of later strings, since
	* the regstart check works with the beginning of the r.e.
	* and avoiding duplication strengthens checking.  Not a
	* strong reason, but sufficient in the absence of others.
	* [Now we resolve ties in favor of the earlier string if
	* it happens that c_offset_min has been invalidated, since the
	* earlier string may buy us something the later one won't.]
	*/

	data.longest_fixed = newSVpvs("");
	data.longest_float = newSVpvs("");
	data.last_found = newSVpvs("");
	data.longest = &(data.longest_fixed);
	ENTER_with_name("study_chunk");
	SAVEFREESV(data.longest_fixed);
	SAVEFREESV(data.longest_float);
	SAVEFREESV(data.last_found);
	first = scan;
	if (!ri->regstclass) {
	    ssc_init(pRExC_state, &ch_class);
	    data.start_class = &ch_class;
	    stclass_flag = SCF_DO_STCLASS_AND;
	} else				/* XXXX Check for BOUND? */
	    stclass_flag = 0;
	data.last_closep = &last_close;

        DEBUG_RExC_seen();
	minlen = study_chunk(pRExC_state, &first, &minlen, &fake,
                             scan + RExC_size, /* Up to end */
            &data, -1, 0, NULL,
            SCF_DO_SUBSTR | SCF_WHILEM_VISITED_POS | stclass_flag
                          | (restudied ? SCF_TRIE_DOING_RESTUDY : 0),
            0);


        CHECK_RESTUDY_GOTO_butfirst(LEAVE_with_name("study_chunk"));


	if ( RExC_npar == 1 && data.longest == &(data.longest_fixed)
	     && data.last_start_min == 0 && data.last_end > 0
	     && !RExC_seen_zerolen
             && !(RExC_seen & REG_VERBARG_SEEN)
             && !(RExC_seen & REG_GPOS_SEEN)
        ){
	    r->extflags |= RXf_CHECK_ALL;
        }
	scan_commit(pRExC_state, &data,&minlen,0);

	longest_float_length = CHR_SVLEN(data.longest_float);

        if (! ((SvCUR(data.longest_fixed)  /* ok to leave SvCUR */
                   && data.offset_fixed == data.offset_float_min
                   && SvCUR(data.longest_fixed) == SvCUR(data.longest_float)))
            && S_setup_longest (aTHX_ pRExC_state,
                                    data.longest_float,
                                    &(r->float_utf8),
                                    &(r->float_substr),
                                    &(r->float_end_shift),
                                    data.lookbehind_float,
                                    data.offset_float_min,
                                    data.minlen_float,
                                    longest_float_length,
                                    cBOOL(data.flags & SF_FL_BEFORE_EOL),
                                    cBOOL(data.flags & SF_FL_BEFORE_MEOL)))
        {
	    r->float_min_offset = data.offset_float_min - data.lookbehind_float;
	    r->float_max_offset = data.offset_float_max;
	    if (data.offset_float_max < SSize_t_MAX) /* Don't offset infinity */
	        r->float_max_offset -= data.lookbehind_float;
	    SvREFCNT_inc_simple_void_NN(data.longest_float);
	}
	else {
	    r->float_substr = r->float_utf8 = NULL;
	    longest_float_length = 0;
	}

	longest_fixed_length = CHR_SVLEN(data.longest_fixed);

        if (S_setup_longest (aTHX_ pRExC_state,
                                data.longest_fixed,
                                &(r->anchored_utf8),
                                &(r->anchored_substr),
                                &(r->anchored_end_shift),
                                data.lookbehind_fixed,
                                data.offset_fixed,
                                data.minlen_fixed,
                                longest_fixed_length,
                                cBOOL(data.flags & SF_FIX_BEFORE_EOL),
                                cBOOL(data.flags & SF_FIX_BEFORE_MEOL)))
        {
	    r->anchored_offset = data.offset_fixed - data.lookbehind_fixed;
	    SvREFCNT_inc_simple_void_NN(data.longest_fixed);
	}
	else {
	    r->anchored_substr = r->anchored_utf8 = NULL;
	    longest_fixed_length = 0;
	}
	LEAVE_with_name("study_chunk");

	if (ri->regstclass
	    && (OP(ri->regstclass) == REG_ANY || OP(ri->regstclass) == SANY))
	    ri->regstclass = NULL;

	if ((!(r->anchored_substr || r->anchored_utf8) || r->anchored_offset)
	    && stclass_flag
            && ! (ANYOF_FLAGS(data.start_class) & SSC_MATCHES_EMPTY_STRING)
	    && is_ssc_worth_it(pRExC_state, data.start_class))
	{
	    const U32 n = add_data(pRExC_state, STR_WITH_LEN("f"));

            ssc_finalize(pRExC_state, data.start_class);

	    Newx(RExC_rxi->data->data[n], 1, regnode_ssc);
	    StructCopy(data.start_class,
		       (regnode_ssc*)RExC_rxi->data->data[n],
		       regnode_ssc);
	    ri->regstclass = (regnode*)RExC_rxi->data->data[n];
	    r->intflags &= ~PREGf_SKIP;	/* Used in find_byclass(). */
	    DEBUG_COMPILE_r({ SV *sv = sv_newmortal();
                      regprop(r, sv, (regnode*)data.start_class, NULL, pRExC_state);
                      Perl_re_printf( aTHX_
				    "synthetic stclass \"%s\".\n",
				    SvPVX_const(sv));});
            data.start_class = NULL;
	}

        /* A temporary algorithm prefers floated substr to fixed one to dig
         * more info. */
	if (longest_fixed_length > longest_float_length) {
	    r->substrs->check_ix = 0;
	    r->check_end_shift = r->anchored_end_shift;
	    r->check_substr = r->anchored_substr;
	    r->check_utf8 = r->anchored_utf8;
	    r->check_offset_min = r->check_offset_max = r->anchored_offset;
            if (r->intflags & (PREGf_ANCH_SBOL|PREGf_ANCH_GPOS))
                r->intflags |= PREGf_NOSCAN;
	}
	else {
	    r->substrs->check_ix = 1;
	    r->check_end_shift = r->float_end_shift;
	    r->check_substr = r->float_substr;
	    r->check_utf8 = r->float_utf8;
	    r->check_offset_min = r->float_min_offset;
	    r->check_offset_max = r->float_max_offset;
	}
	if ((r->check_substr || r->check_utf8) ) {
	    r->extflags |= RXf_USE_INTUIT;
	    if (SvTAIL(r->check_substr ? r->check_substr : r->check_utf8))
		r->extflags |= RXf_INTUIT_TAIL;
	}
        r->substrs->data[0].max_offset = r->substrs->data[0].min_offset;

	/* XXX Unneeded? dmq (shouldn't as this is handled elsewhere)
	if ( (STRLEN)minlen < longest_float_length )
            minlen= longest_float_length;
        if ( (STRLEN)minlen < longest_fixed_length )
            minlen= longest_fixed_length;
        */
    }
    else {
	/* Several toplevels. Best we can is to set minlen. */
	SSize_t fake;
	regnode_ssc ch_class;
	SSize_t last_close = 0;

        DEBUG_PARSE_r(Perl_re_printf( aTHX_  "\nMulti Top Level\n"));

	scan = ri->program + 1;
	ssc_init(pRExC_state, &ch_class);
	data.start_class = &ch_class;
	data.last_closep = &last_close;

        DEBUG_RExC_seen();
	minlen = study_chunk(pRExC_state,
            &scan, &minlen, &fake, scan + RExC_size, &data, -1, 0, NULL,
            SCF_DO_STCLASS_AND|SCF_WHILEM_VISITED_POS|(restudied
                                                      ? SCF_TRIE_DOING_RESTUDY
                                                      : 0),
            0);

        CHECK_RESTUDY_GOTO_butfirst(NOOP);

	r->check_substr = r->check_utf8 = r->anchored_substr = r->anchored_utf8
		= r->float_substr = r->float_utf8 = NULL;

        if (! (ANYOF_FLAGS(data.start_class) & SSC_MATCHES_EMPTY_STRING)
	    && is_ssc_worth_it(pRExC_state, data.start_class))
        {
	    const U32 n = add_data(pRExC_state, STR_WITH_LEN("f"));

            ssc_finalize(pRExC_state, data.start_class);

	    Newx(RExC_rxi->data->data[n], 1, regnode_ssc);
	    StructCopy(data.start_class,
		       (regnode_ssc*)RExC_rxi->data->data[n],
		       regnode_ssc);
	    ri->regstclass = (regnode*)RExC_rxi->data->data[n];
	    r->intflags &= ~PREGf_SKIP;	/* Used in find_byclass(). */
	    DEBUG_COMPILE_r({ SV* sv = sv_newmortal();
                      regprop(r, sv, (regnode*)data.start_class, NULL, pRExC_state);
                      Perl_re_printf( aTHX_
				    "synthetic stclass \"%s\".\n",
				    SvPVX_const(sv));});
            data.start_class = NULL;
	}
    }

    if (RExC_seen & REG_UNBOUNDED_QUANTIFIER_SEEN) {
        r->extflags |= RXf_UNBOUNDED_QUANTIFIER_SEEN;
        r->maxlen = REG_INFTY;
    }
    else {
        r->maxlen = RExC_maxlen;
    }

    /* Guard against an embedded (?=) or (?<=) with a longer minlen than
       the "real" pattern. */
    DEBUG_OPTIMISE_r({
        Perl_re_printf( aTHX_ "minlen: %"IVdf" r->minlen:%"IVdf" maxlen:%"IVdf"\n",
                      (IV)minlen, (IV)r->minlen, (IV)RExC_maxlen);
    });
    r->minlenret = minlen;
    if (r->minlen < minlen)
        r->minlen = minlen;

    if (RExC_seen & REG_RECURSE_SEEN ) {
        r->intflags |= PREGf_RECURSE_SEEN;
        Newxz(r->recurse_locinput, r->nparens + 1, char *);
    }
    if (RExC_seen & REG_GPOS_SEEN)
        r->intflags |= PREGf_GPOS_SEEN;
    if (RExC_seen & REG_LOOKBEHIND_SEEN)
        r->extflags |= RXf_NO_INPLACE_SUBST; /* inplace might break the
                                                lookbehind */
    if (pRExC_state->num_code_blocks)
	r->extflags |= RXf_EVAL_SEEN;
    if (RExC_seen & REG_VERBARG_SEEN)
    {
	r->intflags |= PREGf_VERBARG_SEEN;
        r->extflags |= RXf_NO_INPLACE_SUBST; /* don't understand this! Yves */
    }
    if (RExC_seen & REG_CUTGROUP_SEEN)
	r->intflags |= PREGf_CUTGROUP_SEEN;
    if (pm_flags & PMf_USE_RE_EVAL)
	r->intflags |= PREGf_USE_RE_EVAL;
    if (RExC_paren_names)
        RXp_PAREN_NAMES(r) = MUTABLE_HV(SvREFCNT_inc(RExC_paren_names));
    else
        RXp_PAREN_NAMES(r) = NULL;

    /* If we have seen an anchor in our pattern then we set the extflag RXf_IS_ANCHORED
     * so it can be used in pp.c */
    if (r->intflags & PREGf_ANCH)
        r->extflags |= RXf_IS_ANCHORED;


    {
        /* this is used to identify "special" patterns that might result
         * in Perl NOT calling the regex engine and instead doing the match "itself",
         * particularly special cases in split//. By having the regex compiler
         * do this pattern matching at a regop level (instead of by inspecting the pattern)
         * we avoid weird issues with equivalent patterns resulting in different behavior,
         * AND we allow non Perl engines to get the same optimizations by the setting the
         * flags appropriately - Yves */
        regnode *first = ri->program + 1;
        U8 fop = OP(first);
        regnode *next = regnext(first);
        U8 nop = OP(next);

        if (PL_regkind[fop] == NOTHING && nop == END)
            r->extflags |= RXf_NULL;
        else if ((fop == MBOL || (fop == SBOL && !first->flags)) && nop == END)
            /* when fop is SBOL first->flags will be true only when it was
             * produced by parsing /\A/, and not when parsing /^/. This is
             * very important for the split code as there we want to
             * treat /^/ as /^/m, but we do not want to treat /\A/ as /^/m.
             * See rt #122761 for more details. -- Yves */
            r->extflags |= RXf_START_ONLY;
        else if (fop == PLUS
                 && PL_regkind[nop] == POSIXD && FLAGS(next) == _CC_SPACE
                 && nop == END)
            r->extflags |= RXf_WHITE;
        else if ( r->extflags & RXf_SPLIT
                  && (fop == EXACT || fop == EXACTL)
                  && STR_LEN(first) == 1
                  && *(STRING(first)) == ' '
                  && nop == END )
            r->extflags |= (RXf_SKIPWHITE|RXf_WHITE);

    }

    if (RExC_contains_locale) {
        RXp_EXTFLAGS(r) |= RXf_TAINTED;
    }

#ifdef DEBUGGING
    if (RExC_paren_names) {
        ri->name_list_idx = add_data( pRExC_state, STR_WITH_LEN("a"));
        ri->data->data[ri->name_list_idx]
                                   = (void*)SvREFCNT_inc(RExC_paren_name_list);
    } else
#endif
    ri->name_list_idx = 0;

    while ( RExC_recurse_count > 0 ) {
        const regnode *scan = RExC_recurse[ --RExC_recurse_count ];
        ARG2L_SET( scan, RExC_open_parens[ARG(scan)] - scan );
    }

    Newxz(r->offs, RExC_npar, regexp_paren_pair);
    /* assume we don't need to swap parens around before we match */
    DEBUG_TEST_r({
        Perl_re_printf( aTHX_ "study_chunk_recursed_count: %lu\n",
            (unsigned long)RExC_study_chunk_recursed_count);
    });
    DEBUG_DUMP_r({
        DEBUG_RExC_seen();
        Perl_re_printf( aTHX_ "Final program:\n");
        regdump(r);
    });
#ifdef RE_TRACK_PATTERN_OFFSETS
    DEBUG_OFFSETS_r(if (ri->u.offsets) {
        const STRLEN len = ri->u.offsets[0];
        STRLEN i;
        GET_RE_DEBUG_FLAGS_DECL;
        Perl_re_printf( aTHX_
                      "Offsets: [%"UVuf"]\n\t", (UV)ri->u.offsets[0]);
        for (i = 1; i <= len; i++) {
            if (ri->u.offsets[i*2-1] || ri->u.offsets[i*2])
                Perl_re_printf( aTHX_  "%"UVuf":%"UVuf"[%"UVuf"] ",
                (UV)i, (UV)ri->u.offsets[i*2-1], (UV)ri->u.offsets[i*2]);
            }
        Perl_re_printf( aTHX_  "\n");
    });
#endif

#ifdef USE_ITHREADS
    /* under ithreads the ?pat? PMf_USED flag on the pmop is simulated
     * by setting the regexp SV to readonly-only instead. If the
     * pattern's been recompiled, the USEDness should remain. */
    if (old_re && SvREADONLY(old_re))
        SvREADONLY_on(rx);
#endif
    return rx;
}


SV*
Perl_reg_named_buff(pTHX_ REGEXP * const rx, SV * const key, SV * const value,
                    const U32 flags)
{
    PERL_ARGS_ASSERT_REG_NAMED_BUFF;

    PERL_UNUSED_ARG(value);

    if (flags & RXapif_FETCH) {
        return reg_named_buff_fetch(rx, key, flags);
    } else if (flags & (RXapif_STORE | RXapif_DELETE | RXapif_CLEAR)) {
        Perl_croak_no_modify();
        return NULL;
    } else if (flags & RXapif_EXISTS) {
        return reg_named_buff_exists(rx, key, flags)
            ? &PL_sv_yes
            : &PL_sv_no;
    } else if (flags & RXapif_REGNAMES) {
        return reg_named_buff_all(rx, flags);
    } else if (flags & (RXapif_SCALAR | RXapif_REGNAMES_COUNT)) {
        return reg_named_buff_scalar(rx, flags);
    } else {
        Perl_croak(aTHX_ "panic: Unknown flags %d in named_buff", (int)flags);
        return NULL;
    }
}

SV*
Perl_reg_named_buff_iter(pTHX_ REGEXP * const rx, const SV * const lastkey,
                         const U32 flags)
{
    PERL_ARGS_ASSERT_REG_NAMED_BUFF_ITER;
    PERL_UNUSED_ARG(lastkey);

    if (flags & RXapif_FIRSTKEY)
        return reg_named_buff_firstkey(rx, flags);
    else if (flags & RXapif_NEXTKEY)
        return reg_named_buff_nextkey(rx, flags);
    else {
        Perl_croak(aTHX_ "panic: Unknown flags %d in named_buff_iter",
                                            (int)flags);
        return NULL;
    }
}

SV*
Perl_reg_named_buff_fetch(pTHX_ REGEXP * const r, SV * const namesv,
			  const U32 flags)
{
    AV *retarray = NULL;
    SV *ret;
    struct regexp *const rx = ReANY(r);

    PERL_ARGS_ASSERT_REG_NAMED_BUFF_FETCH;

    if (flags & RXapif_ALL)
        retarray=newAV();

    if (rx && RXp_PAREN_NAMES(rx)) {
        HE *he_str = hv_fetch_ent( RXp_PAREN_NAMES(rx), namesv, 0, 0 );
        if (he_str) {
            IV i;
            SV* sv_dat=HeVAL(he_str);
            I32 *nums=(I32*)SvPVX(sv_dat);
            for ( i=0; i<SvIVX(sv_dat); i++ ) {
                if ((I32)(rx->nparens) >= nums[i]
                    && rx->offs[nums[i]].start != -1
                    && rx->offs[nums[i]].end != -1)
                {
                    ret = newSVpvs("");
                    CALLREG_NUMBUF_FETCH(r,nums[i],ret);
                    if (!retarray)
                        return ret;
                } else {
                    if (retarray)
                        ret = newSVsv(&PL_sv_undef);
                }
                if (retarray)
                    av_push(retarray, ret);
            }
            if (retarray)
                return newRV_noinc(MUTABLE_SV(retarray));
        }
    }
    return NULL;
}

bool
Perl_reg_named_buff_exists(pTHX_ REGEXP * const r, SV * const key,
                           const U32 flags)
{
    struct regexp *const rx = ReANY(r);

    PERL_ARGS_ASSERT_REG_NAMED_BUFF_EXISTS;

    if (rx && RXp_PAREN_NAMES(rx)) {
        if (flags & RXapif_ALL) {
            return hv_exists_ent(RXp_PAREN_NAMES(rx), key, 0);
        } else {
	    SV *sv = CALLREG_NAMED_BUFF_FETCH(r, key, flags);
            if (sv) {
		SvREFCNT_dec_NN(sv);
                return TRUE;
            } else {
                return FALSE;
            }
        }
    } else {
        return FALSE;
    }
}

SV*
Perl_reg_named_buff_firstkey(pTHX_ REGEXP * const r, const U32 flags)
{
    struct regexp *const rx = ReANY(r);

    PERL_ARGS_ASSERT_REG_NAMED_BUFF_FIRSTKEY;

    if ( rx && RXp_PAREN_NAMES(rx) ) {
	(void)hv_iterinit(RXp_PAREN_NAMES(rx));

	return CALLREG_NAMED_BUFF_NEXTKEY(r, NULL, flags & ~RXapif_FIRSTKEY);
    } else {
	return FALSE;
    }
}

SV*
Perl_reg_named_buff_nextkey(pTHX_ REGEXP * const r, const U32 flags)
{
    struct regexp *const rx = ReANY(r);
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_REG_NAMED_BUFF_NEXTKEY;

    if (rx && RXp_PAREN_NAMES(rx)) {
        HV *hv = RXp_PAREN_NAMES(rx);
        HE *temphe;
        while ( (temphe = hv_iternext_flags(hv,0)) ) {
            IV i;
            IV parno = 0;
            SV* sv_dat = HeVAL(temphe);
            I32 *nums = (I32*)SvPVX(sv_dat);
            for ( i = 0; i < SvIVX(sv_dat); i++ ) {
                if ((I32)(rx->lastparen) >= nums[i] &&
                    rx->offs[nums[i]].start != -1 &&
                    rx->offs[nums[i]].end != -1)
                {
                    parno = nums[i];
                    break;
                }
            }
            if (parno || flags & RXapif_ALL) {
		return newSVhek(HeKEY_hek(temphe));
            }
        }
    }
    return NULL;
}

SV*
Perl_reg_named_buff_scalar(pTHX_ REGEXP * const r, const U32 flags)
{
    SV *ret;
    AV *av;
    SSize_t length;
    struct regexp *const rx = ReANY(r);

    PERL_ARGS_ASSERT_REG_NAMED_BUFF_SCALAR;

    if (rx && RXp_PAREN_NAMES(rx)) {
        if (flags & (RXapif_ALL | RXapif_REGNAMES_COUNT)) {
            return newSViv(HvTOTALKEYS(RXp_PAREN_NAMES(rx)));
        } else if (flags & RXapif_ONE) {
            ret = CALLREG_NAMED_BUFF_ALL(r, (flags | RXapif_REGNAMES));
            av = MUTABLE_AV(SvRV(ret));
            length = av_tindex(av);
	    SvREFCNT_dec_NN(ret);
            return newSViv(length + 1);
        } else {
            Perl_croak(aTHX_ "panic: Unknown flags %d in named_buff_scalar",
                                                (int)flags);
            return NULL;
        }
    }
    return &PL_sv_undef;
}

SV*
Perl_reg_named_buff_all(pTHX_ REGEXP * const r, const U32 flags)
{
    struct regexp *const rx = ReANY(r);
    AV *av = newAV();

    PERL_ARGS_ASSERT_REG_NAMED_BUFF_ALL;

    if (rx && RXp_PAREN_NAMES(rx)) {
        HV *hv= RXp_PAREN_NAMES(rx);
        HE *temphe;
        (void)hv_iterinit(hv);
        while ( (temphe = hv_iternext_flags(hv,0)) ) {
            IV i;
            IV parno = 0;
            SV* sv_dat = HeVAL(temphe);
            I32 *nums = (I32*)SvPVX(sv_dat);
            for ( i = 0; i < SvIVX(sv_dat); i++ ) {
                if ((I32)(rx->lastparen) >= nums[i] &&
                    rx->offs[nums[i]].start != -1 &&
                    rx->offs[nums[i]].end != -1)
                {
                    parno = nums[i];
                    break;
                }
            }
            if (parno || flags & RXapif_ALL) {
                av_push(av, newSVhek(HeKEY_hek(temphe)));
            }
        }
    }

    return newRV_noinc(MUTABLE_SV(av));
}

void
Perl_reg_numbered_buff_fetch(pTHX_ REGEXP * const r, const I32 paren,
			     SV * const sv)
{
    struct regexp *const rx = ReANY(r);
    char *s = NULL;
    SSize_t i = 0;
    SSize_t s1, t1;
    I32 n = paren;

    PERL_ARGS_ASSERT_REG_NUMBERED_BUFF_FETCH;

    if (      n == RX_BUFF_IDX_CARET_PREMATCH
           || n == RX_BUFF_IDX_CARET_FULLMATCH
           || n == RX_BUFF_IDX_CARET_POSTMATCH
       )
    {
        bool keepcopy = cBOOL(rx->extflags & RXf_PMf_KEEPCOPY);
        if (!keepcopy) {
            /* on something like
             *    $r = qr/.../;
             *    /$qr/p;
             * the KEEPCOPY is set on the PMOP rather than the regex */
            if (PL_curpm && r == PM_GETRE(PL_curpm))
                 keepcopy = cBOOL(PL_curpm->op_pmflags & PMf_KEEPCOPY);
        }
        if (!keepcopy)
            goto ret_undef;
    }

    if (!rx->subbeg)
        goto ret_undef;

    if (n == RX_BUFF_IDX_CARET_FULLMATCH)
        /* no need to distinguish between them any more */
        n = RX_BUFF_IDX_FULLMATCH;

    if ((n == RX_BUFF_IDX_PREMATCH || n == RX_BUFF_IDX_CARET_PREMATCH)
        && rx->offs[0].start != -1)
    {
        /* $`, ${^PREMATCH} */
	i = rx->offs[0].start;
	s = rx->subbeg;
    }
    else
    if ((n == RX_BUFF_IDX_POSTMATCH || n == RX_BUFF_IDX_CARET_POSTMATCH)
        && rx->offs[0].end != -1)
    {
        /* $', ${^POSTMATCH} */
	s = rx->subbeg - rx->suboffset + rx->offs[0].end;
	i = rx->sublen + rx->suboffset - rx->offs[0].end;
    }
    else
    if ( 0 <= n && n <= (I32)rx->nparens &&
        (s1 = rx->offs[n].start) != -1 &&
        (t1 = rx->offs[n].end) != -1)
    {
        /* $&, ${^MATCH},  $1 ... */
        i = t1 - s1;
        s = rx->subbeg + s1 - rx->suboffset;
    } else {
        goto ret_undef;
    }

    assert(s >= rx->subbeg);
    assert((STRLEN)rx->sublen >= (STRLEN)((s - rx->subbeg) + i) );
    if (i >= 0) {
#ifdef NO_TAINT_SUPPORT
        sv_setpvn(sv, s, i);
#else
        const int oldtainted = TAINT_get;
        TAINT_NOT;
        sv_setpvn(sv, s, i);
        TAINT_set(oldtainted);
#endif
        if (RXp_MATCH_UTF8(rx))
            SvUTF8_on(sv);
        else
            SvUTF8_off(sv);
        if (TAINTING_get) {
            if (RXp_MATCH_TAINTED(rx)) {
                if (SvTYPE(sv) >= SVt_PVMG) {
                    MAGIC* const mg = SvMAGIC(sv);
                    MAGIC* mgt;
                    TAINT;
                    SvMAGIC_set(sv, mg->mg_moremagic);
                    SvTAINT(sv);
                    if ((mgt = SvMAGIC(sv))) {
                        mg->mg_moremagic = mgt;
                        SvMAGIC_set(sv, mg);
                    }
                } else {
                    TAINT;
                    SvTAINT(sv);
                }
            } else
                SvTAINTED_off(sv);
        }
    } else {
      ret_undef:
        sv_setsv(sv,&PL_sv_undef);
        return;
    }
}

void
Perl_reg_numbered_buff_store(pTHX_ REGEXP * const rx, const I32 paren,
							 SV const * const value)
{
    PERL_ARGS_ASSERT_REG_NUMBERED_BUFF_STORE;

    PERL_UNUSED_ARG(rx);
    PERL_UNUSED_ARG(paren);
    PERL_UNUSED_ARG(value);

    if (!PL_localizing)
        Perl_croak_no_modify();
}

I32
Perl_reg_numbered_buff_length(pTHX_ REGEXP * const r, const SV * const sv,
                              const I32 paren)
{
    struct regexp *const rx = ReANY(r);
    I32 i;
    I32 s1, t1;

    PERL_ARGS_ASSERT_REG_NUMBERED_BUFF_LENGTH;

    if (   paren == RX_BUFF_IDX_CARET_PREMATCH
        || paren == RX_BUFF_IDX_CARET_FULLMATCH
        || paren == RX_BUFF_IDX_CARET_POSTMATCH
    )
    {
        bool keepcopy = cBOOL(rx->extflags & RXf_PMf_KEEPCOPY);
        if (!keepcopy) {
            /* on something like
             *    $r = qr/.../;
             *    /$qr/p;
             * the KEEPCOPY is set on the PMOP rather than the regex */
            if (PL_curpm && r == PM_GETRE(PL_curpm))
                 keepcopy = cBOOL(PL_curpm->op_pmflags & PMf_KEEPCOPY);
        }
        if (!keepcopy)
            goto warn_undef;
    }

    /* Some of this code was originally in C<Perl_magic_len> in F<mg.c> */
    switch (paren) {
      case RX_BUFF_IDX_CARET_PREMATCH: /* ${^PREMATCH} */
      case RX_BUFF_IDX_PREMATCH:       /* $` */
        if (rx->offs[0].start != -1) {
			i = rx->offs[0].start;
			if (i > 0) {
				s1 = 0;
				t1 = i;
				goto getlen;
			}
	    }
        return 0;

      case RX_BUFF_IDX_CARET_POSTMATCH: /* ${^POSTMATCH} */
      case RX_BUFF_IDX_POSTMATCH:       /* $' */
	    if (rx->offs[0].end != -1) {
			i = rx->sublen - rx->offs[0].end;
			if (i > 0) {
				s1 = rx->offs[0].end;
				t1 = rx->sublen;
				goto getlen;
			}
	    }
        return 0;

      default: /* $& / ${^MATCH}, $1, $2, ... */
	    if (paren <= (I32)rx->nparens &&
            (s1 = rx->offs[paren].start) != -1 &&
            (t1 = rx->offs[paren].end) != -1)
	    {
            i = t1 - s1;
            goto getlen;
        } else {
          warn_undef:
            if (ckWARN(WARN_UNINITIALIZED))
                report_uninit((const SV *)sv);
            return 0;
        }
    }
  getlen:
    if (i > 0 && RXp_MATCH_UTF8(rx)) {
        const char * const s = rx->subbeg - rx->suboffset + s1;
        const U8 *ep;
        STRLEN el;

        i = t1 - s1;
        if (is_utf8_string_loclen((U8*)s, i, &ep, &el))
			i = el;
    }
    return i;
}

SV*
Perl_reg_qr_package(pTHX_ REGEXP * const rx)
{
    PERL_ARGS_ASSERT_REG_QR_PACKAGE;
	PERL_UNUSED_ARG(rx);
	if (0)
	    return NULL;
	else
	    return newSVpvs("Regexp");
}

/* Scans the name of a named buffer from the pattern.
 * If flags is REG_RSN_RETURN_NULL returns null.
 * If flags is REG_RSN_RETURN_NAME returns an SV* containing the name
 * If flags is REG_RSN_RETURN_DATA returns the data SV* corresponding
 * to the parsed name as looked up in the RExC_paren_names hash.
 * If there is an error throws a vFAIL().. type exception.
 */

#define REG_RSN_RETURN_NULL    0
#define REG_RSN_RETURN_NAME    1
#define REG_RSN_RETURN_DATA    2

STATIC SV*
S_reg_scan_name(pTHX_ RExC_state_t *pRExC_state, U32 flags)
{
    char *name_start = RExC_parse;

    PERL_ARGS_ASSERT_REG_SCAN_NAME;

    assert (RExC_parse <= RExC_end);
    if (RExC_parse == RExC_end) NOOP;
    else if (isIDFIRST_lazy_if(RExC_parse, UTF)) {
         /* Note that the code here assumes well-formed UTF-8.  Skip IDFIRST by
          * using do...while */
	if (UTF)
	    do {
		RExC_parse += UTF8SKIP(RExC_parse);
	    } while (isWORDCHAR_utf8((U8*)RExC_parse));
	else
	    do {
		RExC_parse++;
	    } while (isWORDCHAR(*RExC_parse));
    } else {
        RExC_parse++; /* so the <- from the vFAIL is after the offending
                         character */
        vFAIL("Group name must start with a non-digit word character");
    }
    if ( flags ) {
        SV* sv_name
	    = newSVpvn_flags(name_start, (int)(RExC_parse - name_start),
			     SVs_TEMP | (UTF ? SVf_UTF8 : 0));
        if ( flags == REG_RSN_RETURN_NAME)
            return sv_name;
        else if (flags==REG_RSN_RETURN_DATA) {
            HE *he_str = NULL;
            SV *sv_dat = NULL;
            if ( ! sv_name )      /* should not happen*/
                Perl_croak(aTHX_ "panic: no svname in reg_scan_name");
            if (RExC_paren_names)
                he_str = hv_fetch_ent( RExC_paren_names, sv_name, 0, 0 );
            if ( he_str )
                sv_dat = HeVAL(he_str);
            if ( ! sv_dat )
                vFAIL("Reference to nonexistent named group");
            return sv_dat;
        }
        else {
            Perl_croak(aTHX_ "panic: bad flag %lx in reg_scan_name",
		       (unsigned long) flags);
        }
        NOT_REACHED; /* NOTREACHED */
    }
    return NULL;
}

#define DEBUG_PARSE_MSG(funcname)     DEBUG_PARSE_r({           \
    int num;                                                    \
    if (RExC_lastparse!=RExC_parse) {                           \
        Perl_re_printf( aTHX_  "%s",                                        \
            Perl_pv_pretty(aTHX_ RExC_mysv1, RExC_parse,        \
                RExC_end - RExC_parse, 16,                      \
                "", "",                                         \
                PERL_PV_ESCAPE_UNI_DETECT |                     \
                PERL_PV_PRETTY_ELLIPSES   |                     \
                PERL_PV_PRETTY_LTGT       |                     \
                PERL_PV_ESCAPE_RE         |                     \
                PERL_PV_PRETTY_EXACTSIZE                        \
            )                                                   \
        );                                                      \
    } else                                                      \
        Perl_re_printf( aTHX_ "%16s","");                                   \
                                                                \
    if (SIZE_ONLY)                                              \
       num = RExC_size + 1;                                     \
    else                                                        \
       num=REG_NODE_NUM(RExC_emit);                             \
    if (RExC_lastnum!=num)                                      \
       Perl_re_printf( aTHX_ "|%4d",num);                                   \
    else                                                        \
       Perl_re_printf( aTHX_ "|%4s","");                                    \
    Perl_re_printf( aTHX_ "|%*s%-4s",                                       \
        (int)((depth*2)), "",                                   \
        (funcname)                                              \
    );                                                          \
    RExC_lastnum=num;                                           \
    RExC_lastparse=RExC_parse;                                  \
})



#define DEBUG_PARSE(funcname)     DEBUG_PARSE_r({           \
    DEBUG_PARSE_MSG((funcname));                            \
    Perl_re_printf( aTHX_ "%4s","\n");                                  \
})
#define DEBUG_PARSE_FMT(funcname,fmt,args)     DEBUG_PARSE_r({\
    DEBUG_PARSE_MSG((funcname));                            \
    Perl_re_printf( aTHX_ fmt "\n",args);                               \
})

/* This section of code defines the inversion list object and its methods.  The
 * interfaces are highly subject to change, so as much as possible is static to
 * this file.  An inversion list is here implemented as a malloc'd C UV array
 * as an SVt_INVLIST scalar.
 *
 * An inversion list for Unicode is an array of code points, sorted by ordinal
 * number.  The zeroth element is the first code point in the list.  The 1th
 * element is the first element beyond that not in the list.  In other words,
 * the first range is
 *  invlist[0]..(invlist[1]-1)
 * The other ranges follow.  Thus every element whose index is divisible by two
 * marks the beginning of a range that is in the list, and every element not
 * divisible by two marks the beginning of a range not in the list.  A single
 * element inversion list that contains the single code point N generally
 * consists of two elements
 *  invlist[0] == N
 *  invlist[1] == N+1
 * (The exception is when N is the highest representable value on the
 * machine, in which case the list containing just it would be a single
 * element, itself.  By extension, if the last range in the list extends to
 * infinity, then the first element of that range will be in the inversion list
 * at a position that is divisible by two, and is the final element in the
 * list.)
 * Taking the complement (inverting) an inversion list is quite simple, if the
 * first element is 0, remove it; otherwise add a 0 element at the beginning.
 * This implementation reserves an element at the beginning of each inversion
 * list to always contain 0; there is an additional flag in the header which
 * indicates if the list begins at the 0, or is offset to begin at the next
 * element.
 *
 * More about inversion lists can be found in "Unicode Demystified"
 * Chapter 13 by Richard Gillam, published by Addison-Wesley.
 * More will be coming when functionality is added later.
 *
 * The inversion list data structure is currently implemented as an SV pointing
 * to an array of UVs that the SV thinks are bytes.  This allows us to have an
 * array of UV whose memory management is automatically handled by the existing
 * facilities for SV's.
 *
 * Some of the methods should always be private to the implementation, and some
 * should eventually be made public */

/* The header definitions are in F<invlist_inline.h> */

PERL_STATIC_INLINE UV*
S__invlist_array_init(SV* const invlist, const bool will_have_0)
{
    /* Returns a pointer to the first element in the inversion list's array.
     * This is called upon initialization of an inversion list.  Where the
     * array begins depends on whether the list has the code point U+0000 in it
     * or not.  The other parameter tells it whether the code that follows this
     * call is about to put a 0 in the inversion list or not.  The first
     * element is either the element reserved for 0, if TRUE, or the element
     * after it, if FALSE */

    bool* offset = get_invlist_offset_addr(invlist);
    UV* zero_addr = (UV *) SvPVX(invlist);

    PERL_ARGS_ASSERT__INVLIST_ARRAY_INIT;

    /* Must be empty */
    assert(! _invlist_len(invlist));

    *zero_addr = 0;

    /* 1^1 = 0; 1^0 = 1 */
    *offset = 1 ^ will_have_0;
    return zero_addr + *offset;
}

PERL_STATIC_INLINE void
S_invlist_set_len(pTHX_ SV* const invlist, const UV len, const bool offset)
{
    /* Sets the current number of elements stored in the inversion list.
     * Updates SvCUR correspondingly */
    PERL_UNUSED_CONTEXT;
    PERL_ARGS_ASSERT_INVLIST_SET_LEN;

    assert(SvTYPE(invlist) == SVt_INVLIST);

    SvCUR_set(invlist,
              (len == 0)
               ? 0
               : TO_INTERNAL_SIZE(len + offset));
    assert(SvLEN(invlist) == 0 || SvCUR(invlist) <= SvLEN(invlist));
}

#ifndef PERL_IN_XSUB_RE

STATIC void
S_invlist_replace_list_destroys_src(pTHX_ SV * dest, SV * src)
{
    /* Replaces the inversion list in 'src' with the one in 'dest'.  It steals
     * the list from 'src', so 'src' is made to have a NULL list.  This is
     * similar to what SvSetMagicSV() would do, if it were implemented on
     * inversion lists, though this routine avoids a copy */

    const UV src_len          = _invlist_len(src);
    const bool src_offset     = *get_invlist_offset_addr(src);
    const STRLEN src_byte_len = SvLEN(src);
    char * array              = SvPVX(src);

    const int oldtainted = TAINT_get;

    PERL_ARGS_ASSERT_INVLIST_REPLACE_LIST_DESTROYS_SRC;

    assert(SvTYPE(src) == SVt_INVLIST);
    assert(SvTYPE(dest) == SVt_INVLIST);
    assert(! invlist_is_iterating(src));
    assert(SvCUR(src) == 0 || SvCUR(src) < SvLEN(src));

    /* Make sure it ends in the right place with a NUL, as our inversion list
     * manipulations aren't careful to keep this true, but sv_usepvn_flags()
     * asserts it */
    array[src_byte_len - 1] = '\0';

    TAINT_NOT;      /* Otherwise it breaks */
    sv_usepvn_flags(dest,
                    (char *) array,
                    src_byte_len - 1,

                    /* This flag is documented to cause a copy to be avoided */
                    SV_HAS_TRAILING_NUL);
    TAINT_set(oldtainted);
    SvPV_set(src, 0);
    SvLEN_set(src, 0);
    SvCUR_set(src, 0);

    /* Finish up copying over the other fields in an inversion list */
    *get_invlist_offset_addr(dest) = src_offset;
    invlist_set_len(dest, src_len, src_offset);
    *get_invlist_previous_index_addr(dest) = 0;
    invlist_iterfinish(dest);
}

PERL_STATIC_INLINE IV*
S_get_invlist_previous_index_addr(SV* invlist)
{
    /* Return the address of the IV that is reserved to hold the cached index
     * */
    PERL_ARGS_ASSERT_GET_INVLIST_PREVIOUS_INDEX_ADDR;

    assert(SvTYPE(invlist) == SVt_INVLIST);

    return &(((XINVLIST*) SvANY(invlist))->prev_index);
}

PERL_STATIC_INLINE IV
S_invlist_previous_index(SV* const invlist)
{
    /* Returns cached index of previous search */

    PERL_ARGS_ASSERT_INVLIST_PREVIOUS_INDEX;

    return *get_invlist_previous_index_addr(invlist);
}

PERL_STATIC_INLINE void
S_invlist_set_previous_index(SV* const invlist, const IV index)
{
    /* Caches <index> for later retrieval */

    PERL_ARGS_ASSERT_INVLIST_SET_PREVIOUS_INDEX;

    assert(index == 0 || index < (int) _invlist_len(invlist));

    *get_invlist_previous_index_addr(invlist) = index;
}

PERL_STATIC_INLINE void
S_invlist_trim(SV* invlist)
{
    /* Free the not currently-being-used space in an inversion list */

    /* But don't free up the space needed for the 0 UV that is always at the
     * beginning of the list, nor the trailing NUL */
    const UV min_size = TO_INTERNAL_SIZE(1) + 1;

    PERL_ARGS_ASSERT_INVLIST_TRIM;

    assert(SvTYPE(invlist) == SVt_INVLIST);

    SvPV_renew(invlist, MAX(min_size, SvCUR(invlist) + 1));
}

PERL_STATIC_INLINE void
S_invlist_clear(pTHX_ SV* invlist)    /* Empty the inversion list */
{
    PERL_ARGS_ASSERT_INVLIST_CLEAR;

    assert(SvTYPE(invlist) == SVt_INVLIST);

    invlist_set_len(invlist, 0, 0);
    invlist_trim(invlist);
}

#endif /* ifndef PERL_IN_XSUB_RE */

PERL_STATIC_INLINE bool
S_invlist_is_iterating(SV* const invlist)
{
    PERL_ARGS_ASSERT_INVLIST_IS_ITERATING;

    return *(get_invlist_iter_addr(invlist)) < (STRLEN) UV_MAX;
}

PERL_STATIC_INLINE UV
S_invlist_max(SV* const invlist)
{
    /* Returns the maximum number of elements storable in the inversion list's
     * array, without having to realloc() */

    PERL_ARGS_ASSERT_INVLIST_MAX;

    assert(SvTYPE(invlist) == SVt_INVLIST);

    /* Assumes worst case, in which the 0 element is not counted in the
     * inversion list, so subtracts 1 for that */
    return SvLEN(invlist) == 0  /* This happens under _new_invlist_C_array */
           ? FROM_INTERNAL_SIZE(SvCUR(invlist)) - 1
           : FROM_INTERNAL_SIZE(SvLEN(invlist)) - 1;
}

#ifndef PERL_IN_XSUB_RE
SV*
Perl__new_invlist(pTHX_ IV initial_size)
{

    /* Return a pointer to a newly constructed inversion list, with enough
     * space to store 'initial_size' elements.  If that number is negative, a
     * system default is used instead */

    SV* new_list;

    if (initial_size < 0) {
	initial_size = 10;
    }

    /* Allocate the initial space */
    new_list = newSV_type(SVt_INVLIST);

    /* First 1 is in case the zero element isn't in the list; second 1 is for
     * trailing NUL */
    SvGROW(new_list, TO_INTERNAL_SIZE(initial_size + 1) + 1);
    invlist_set_len(new_list, 0, 0);

    /* Force iterinit() to be used to get iteration to work */
    *get_invlist_iter_addr(new_list) = (STRLEN) UV_MAX;

    *get_invlist_previous_index_addr(new_list) = 0;

    return new_list;
}

SV*
Perl__new_invlist_C_array(pTHX_ const UV* const list)
{
    /* Return a pointer to a newly constructed inversion list, initialized to
     * point to <list>, which has to be in the exact correct inversion list
     * form, including internal fields.  Thus this is a dangerous routine that
     * should not be used in the wrong hands.  The passed in 'list' contains
     * several header fields at the beginning that are not part of the
     * inversion list body proper */

    const STRLEN length = (STRLEN) list[0];
    const UV version_id =          list[1];
    const bool offset   =    cBOOL(list[2]);
#define HEADER_LENGTH 3
    /* If any of the above changes in any way, you must change HEADER_LENGTH
     * (if appropriate) and regenerate INVLIST_VERSION_ID by running
     *      perl -E 'say int(rand 2**31-1)'
     */
#define INVLIST_VERSION_ID 148565664 /* This is a combination of a version and
                                        data structure type, so that one being
                                        passed in can be validated to be an
                                        inversion list of the correct vintage.
                                       */

    SV* invlist = newSV_type(SVt_INVLIST);

    PERL_ARGS_ASSERT__NEW_INVLIST_C_ARRAY;

    if (version_id != INVLIST_VERSION_ID) {
        Perl_croak(aTHX_ "panic: Incorrect version for previously generated inversion list");
    }

    /* The generated array passed in includes header elements that aren't part
     * of the list proper, so start it just after them */
    SvPV_set(invlist, (char *) (list + HEADER_LENGTH));

    SvLEN_set(invlist, 0);  /* Means we own the contents, and the system
			       shouldn't touch it */

    *(get_invlist_offset_addr(invlist)) = offset;

    /* The 'length' passed to us is the physical number of elements in the
     * inversion list.  But if there is an offset the logical number is one
     * less than that */
    invlist_set_len(invlist, length  - offset, offset);

    invlist_set_previous_index(invlist, 0);

    /* Initialize the iteration pointer. */
    invlist_iterfinish(invlist);

    SvREADONLY_on(invlist);

    return invlist;
}
#endif /* ifndef PERL_IN_XSUB_RE */

STATIC void
S_invlist_extend(pTHX_ SV* const invlist, const UV new_max)
{
    /* Grow the maximum size of an inversion list */

    PERL_ARGS_ASSERT_INVLIST_EXTEND;

    assert(SvTYPE(invlist) == SVt_INVLIST);

    /* Add one to account for the zero element at the beginning which may not
     * be counted by the calling parameters */
    SvGROW((SV *)invlist, TO_INTERNAL_SIZE(new_max + 1));
}

STATIC void
S__append_range_to_invlist(pTHX_ SV* const invlist,
                                 const UV start, const UV end)
{
   /* Subject to change or removal.  Append the range from 'start' to 'end' at
    * the end of the inversion list.  The range must be above any existing
    * ones. */

    UV* array;
    UV max = invlist_max(invlist);
    UV len = _invlist_len(invlist);
    bool offset;

    PERL_ARGS_ASSERT__APPEND_RANGE_TO_INVLIST;

    if (len == 0) { /* Empty lists must be initialized */
        offset = start != 0;
        array = _invlist_array_init(invlist, ! offset);
    }
    else {
	/* Here, the existing list is non-empty. The current max entry in the
	 * list is generally the first value not in the set, except when the
	 * set extends to the end of permissible values, in which case it is
	 * the first entry in that final set, and so this call is an attempt to
	 * append out-of-order */

	UV final_element = len - 1;
	array = invlist_array(invlist);
	if (array[final_element] > start
	    || ELEMENT_RANGE_MATCHES_INVLIST(final_element))
	{
	    Perl_croak(aTHX_ "panic: attempting to append to an inversion list, but wasn't at the end of the list, final=%"UVuf", start=%"UVuf", match=%c",
		     array[final_element], start,
		     ELEMENT_RANGE_MATCHES_INVLIST(final_element) ? 't' : 'f');
	}

	/* Here, it is a legal append.  If the new range begins with the first
	 * value not in the set, it is extending the set, so the new first
	 * value not in the set is one greater than the newly extended range.
	 * */
        offset = *get_invlist_offset_addr(invlist);
	if (array[final_element] == start) {
	    if (end != UV_MAX) {
		array[final_element] = end + 1;
	    }
	    else {
		/* But if the end is the maximum representable on the machine,
		 * just let the range that this would extend to have no end */
		invlist_set_len(invlist, len - 1, offset);
	    }
	    return;
	}
    }

    /* Here the new range doesn't extend any existing set.  Add it */

    len += 2;	/* Includes an element each for the start and end of range */

    /* If wll overflow the existing space, extend, which may cause the array to
     * be moved */
    if (max < len) {
	invlist_extend(invlist, len);

        /* Have to set len here to avoid assert failure in invlist_array() */
        invlist_set_len(invlist, len, offset);

	array = invlist_array(invlist);
    }
    else {
	invlist_set_len(invlist, len, offset);
    }

    /* The next item on the list starts the range, the one after that is
     * one past the new range.  */
    array[len - 2] = start;
    if (end != UV_MAX) {
	array[len - 1] = end + 1;
    }
    else {
	/* But if the end is the maximum representable on the machine, just let
	 * the range have no end */
	invlist_set_len(invlist, len - 1, offset);
    }
}

#ifndef PERL_IN_XSUB_RE

IV
Perl__invlist_search(SV* const invlist, const UV cp)
{
    /* Searches the inversion list for the entry that contains the input code
     * point <cp>.  If <cp> is not in the list, -1 is returned.  Otherwise, the
     * return value is the index into the list's array of the range that
     * contains <cp>, that is, 'i' such that
     *	array[i] <= cp < array[i+1]
     */

    IV low = 0;
    IV mid;
    IV high = _invlist_len(invlist);
    const IV highest_element = high - 1;
    const UV* array;

    PERL_ARGS_ASSERT__INVLIST_SEARCH;

    /* If list is empty, return failure. */
    if (high == 0) {
	return -1;
    }

    /* (We can't get the array unless we know the list is non-empty) */
    array = invlist_array(invlist);

    mid = invlist_previous_index(invlist);
    assert(mid >=0);
    if (mid > highest_element) {
        mid = highest_element;
    }

    /* <mid> contains the cache of the result of the previous call to this
     * function (0 the first time).  See if this call is for the same result,
     * or if it is for mid-1.  This is under the theory that calls to this
     * function will often be for related code points that are near each other.
     * And benchmarks show that caching gives better results.  We also test
     * here if the code point is within the bounds of the list.  These tests
     * replace others that would have had to be made anyway to make sure that
     * the array bounds were not exceeded, and these give us extra information
     * at the same time */
    if (cp >= array[mid]) {
        if (cp >= array[highest_element]) {
            return highest_element;
        }

        /* Here, array[mid] <= cp < array[highest_element].  This means that
         * the final element is not the answer, so can exclude it; it also
         * means that <mid> is not the final element, so can refer to 'mid + 1'
         * safely */
        if (cp < array[mid + 1]) {
            return mid;
        }
        high--;
        low = mid + 1;
    }
    else { /* cp < aray[mid] */
        if (cp < array[0]) { /* Fail if outside the array */
            return -1;
        }
        high = mid;
        if (cp >= array[mid - 1]) {
            goto found_entry;
        }
    }

    /* Binary search.  What we are looking for is <i> such that
     *	array[i] <= cp < array[i+1]
     * The loop below converges on the i+1.  Note that there may not be an
     * (i+1)th element in the array, and things work nonetheless */
    while (low < high) {
	mid = (low + high) / 2;
        assert(mid <= highest_element);
	if (array[mid] <= cp) { /* cp >= array[mid] */
	    low = mid + 1;

	    /* We could do this extra test to exit the loop early.
	    if (cp < array[low]) {
		return mid;
	    }
	    */
	}
	else { /* cp < array[mid] */
	    high = mid;
	}
    }

  found_entry:
    high--;
    invlist_set_previous_index(invlist, high);
    return high;
}

void
Perl__invlist_populate_swatch(SV* const invlist,
                              const UV start, const UV end, U8* swatch)
{
    /* populates a swatch of a swash the same way swatch_get() does in utf8.c,
     * but is used when the swash has an inversion list.  This makes this much
     * faster, as it uses a binary search instead of a linear one.  This is
     * intimately tied to that function, and perhaps should be in utf8.c,
     * except it is intimately tied to inversion lists as well.  It assumes
     * that <swatch> is all 0's on input */

    UV current = start;
    const IV len = _invlist_len(invlist);
    IV i;
    const UV * array;

    PERL_ARGS_ASSERT__INVLIST_POPULATE_SWATCH;

    if (len == 0) { /* Empty inversion list */
        return;
    }

    array = invlist_array(invlist);

    /* Find which element it is */
    i = _invlist_search(invlist, start);

    /* We populate from <start> to <end> */
    while (current < end) {
        UV upper;

	/* The inversion list gives the results for every possible code point
	 * after the first one in the list.  Only those ranges whose index is
	 * even are ones that the inversion list matches.  For the odd ones,
	 * and if the initial code point is not in the list, we have to skip
	 * forward to the next element */
        if (i == -1 || ! ELEMENT_RANGE_MATCHES_INVLIST(i)) {
            i++;
            if (i >= len) { /* Finished if beyond the end of the array */
                return;
            }
            current = array[i];
	    if (current >= end) {   /* Finished if beyond the end of what we
				       are populating */
                if (LIKELY(end < UV_MAX)) {
                    return;
                }

                /* We get here when the upper bound is the maximum
                 * representable on the machine, and we are looking for just
                 * that code point.  Have to special case it */
                i = len;
                goto join_end_of_list;
            }
        }
        assert(current >= start);

	/* The current range ends one below the next one, except don't go past
	 * <end> */
        i++;
        upper = (i < len && array[i] < end) ? array[i] : end;

	/* Here we are in a range that matches.  Populate a bit in the 3-bit U8
	 * for each code point in it */
        for (; current < upper; current++) {
            const STRLEN offset = (STRLEN)(current - start);
            swatch[offset >> 3] |= 1 << (offset & 7);
        }

      join_end_of_list:

	/* Quit if at the end of the list */
        if (i >= len) {

	    /* But first, have to deal with the highest possible code point on
	     * the platform.  The previous code assumes that <end> is one
	     * beyond where we want to populate, but that is impossible at the
	     * platform's infinity, so have to handle it specially */
            if (UNLIKELY(end == UV_MAX && ELEMENT_RANGE_MATCHES_INVLIST(len-1)))
	    {
                const STRLEN offset = (STRLEN)(end - start);
                swatch[offset >> 3] |= 1 << (offset & 7);
            }
            return;
        }

	/* Advance to the next range, which will be for code points not in the
	 * inversion list */
        current = array[i];
    }

    return;
}

void
Perl__invlist_union_maybe_complement_2nd(pTHX_ SV* const a, SV* const b,
                                         const bool complement_b, SV** output)
{
    /* Take the union of two inversion lists and point <output> to it.  *output
     * SHOULD BE DEFINED upon input, and if it points to one of the two lists,
     * the reference count to that list will be decremented if not already a
     * temporary (mortal); otherwise just its contents will be modified to be
     * the union.  The first list, <a>, may be NULL, in which case a copy of
     * the second list is returned.  If <complement_b> is TRUE, the union is
     * taken of the complement (inversion) of <b> instead of b itself.
     *
     * The basis for this comes from "Unicode Demystified" Chapter 13 by
     * Richard Gillam, published by Addison-Wesley, and explained at some
     * length there.  The preface says to incorporate its examples into your
     * code at your own risk.
     *
     * The algorithm is like a merge sort.
     *
     * XXX A potential performance improvement is to keep track as we go along
     * if only one of the inputs contributes to the result, meaning the other
     * is a subset of that one.  In that case, we can skip the final copy and
     * return the larger of the input lists, but then outside code might need
     * to keep track of whether to free the input list or not */

    const UV* array_a;    /* a's array */
    const UV* array_b;
    UV len_a;	    /* length of a's array */
    UV len_b;

    SV* u;			/* the resulting union */
    UV* array_u;
    UV len_u = 0;

    UV i_a = 0;		    /* current index into a's array */
    UV i_b = 0;
    UV i_u = 0;

    /* running count, as explained in the algorithm source book; items are
     * stopped accumulating and are output when the count changes to/from 0.
     * The count is incremented when we start a range that's in the set, and
     * decremented when we start a range that's not in the set.  So its range
     * is 0 to 2.  Only when the count is zero is something not in the set.
     */
    UV count = 0;

    PERL_ARGS_ASSERT__INVLIST_UNION_MAYBE_COMPLEMENT_2ND;
    assert(a != b);

    len_b = _invlist_len(b);
    if (len_b == 0) {

        /* Here, 'b' is empty.  If the output is the complement of 'b', the
         * union is all possible code points, and we need not even look at 'a'.
         * It's easiest to create a new inversion list that matches everything.
         * */
        if (complement_b) {
            SV* everything = _new_invlist(1);
            _append_range_to_invlist(everything, 0, UV_MAX);

            /* If the output didn't exist, just point it at the new list */
            if (*output == NULL) {
                *output = everything;
                return;
            }

            /* Otherwise, replace its contents with the new list */
            invlist_replace_list_destroys_src(*output, everything);
            SvREFCNT_dec_NN(everything);
            return;
        }

        /* Here, we don't want the complement of 'b', and since it is empty,
         * the union will come entirely from 'a'.  If 'a' is NULL or empty, the
         * output will be empty */

        if (a == NULL) {
            *output = _new_invlist(0);
            return;
        }

        if (_invlist_len(a) == 0) {
            invlist_clear(*output);
            return;
        }

        /* Here, 'a' is not empty, and entirely determines the union.  If the
         * output is not to overwrite 'b', we can just return 'a'. */
        if (*output != b) {

            /* If the output is to overwrite 'a', we have a no-op, as it's
             * already in 'a' */
            if (*output == a) {
                return;
            }

            /* But otherwise we have to copy 'a' to the output */
            *output = invlist_clone(a);
            return;
        }

        /* Here, 'b' is to be overwritten by the output, which will be 'a' */
        u = invlist_clone(a);
        invlist_replace_list_destroys_src(*output, u);
        SvREFCNT_dec_NN(u);

	return;
    }

    if (a == NULL || ((len_a = _invlist_len(a)) == 0)) {

        /* Here, 'a' is empty (and b is not).  That means the union will come
         * entirely from 'b'.  If the output is not to overwrite 'a', we can
         * just return what's in 'b'.  */
        if (*output != a) {

            /* If the output is to overwrite 'b', it's already in 'b', but
             * otherwise we have to copy 'b' to the output */
            if (*output != b) {
                *output = invlist_clone(b);
            }

            /* And if the output is to be the inversion of 'b', do that */
            if (complement_b) {
                _invlist_invert(*output);
            }

            return;
        }

        /* Here, 'a', which is empty or even NULL, is to be overwritten by the
         * output, which will either be 'b' or the complement of 'b' */

        if (a == NULL) {
            *output = invlist_clone(b);
        }
        else {
            u = invlist_clone(b);
            invlist_replace_list_destroys_src(*output, u);
            SvREFCNT_dec_NN(u);
	}

        if (complement_b) {
            _invlist_invert(*output);
        }

	return;
    }

    /* Here both lists exist and are non-empty */
    array_a = invlist_array(a);
    array_b = invlist_array(b);

    /* If are to take the union of 'a' with the complement of b, set it
     * up so are looking at b's complement. */
    if (complement_b) {

	/* To complement, we invert: if the first element is 0, remove it.  To
	 * do this, we just pretend the array starts one later */
        if (array_b[0] == 0) {
            array_b++;
            len_b--;
        }
        else {

            /* But if the first element is not zero, we pretend the list starts
             * at the 0 that is always stored immediately before the array. */
            array_b--;
            len_b++;
        }
    }

    /* Size the union for the worst case: that the sets are completely
     * disjoint */
    u = _new_invlist(len_a + len_b);

    /* Will contain U+0000 if either component does */
    array_u = _invlist_array_init(u, (len_a > 0 && array_a[0] == 0)
				      || (len_b > 0 && array_b[0] == 0));

    /* Go through each list item by item, stopping when exhausted one of
     * them */
    while (i_a < len_a && i_b < len_b) {
	UV cp;	    /* The element to potentially add to the union's array */
	bool cp_in_set;   /* is it in the the input list's set or not */

	/* We need to take one or the other of the two inputs for the union.
	 * Since we are merging two sorted lists, we take the smaller of the
	 * next items.  In case of a tie, we take the one that is in its set
	 * first.  If we took one not in the set first, it would decrement the
	 * count, possibly to 0 which would cause it to be output as ending the
	 * range, and the next time through we would take the same number, and
	 * output it again as beginning the next range.  By doing it the
	 * opposite way, there is no possibility that the count will be
	 * momentarily decremented to 0, and thus the two adjoining ranges will
	 * be seamlessly merged.  (In a tie and both are in the set or both not
	 * in the set, it doesn't matter which we take first.) */
	if (array_a[i_a] < array_b[i_b]
	    || (array_a[i_a] == array_b[i_b]
		&& ELEMENT_RANGE_MATCHES_INVLIST(i_a)))
	{
	    cp_in_set = ELEMENT_RANGE_MATCHES_INVLIST(i_a);
	    cp= array_a[i_a++];
	}
	else {
	    cp_in_set = ELEMENT_RANGE_MATCHES_INVLIST(i_b);
	    cp = array_b[i_b++];
	}

	/* Here, have chosen which of the two inputs to look at.  Only output
	 * if the running count changes to/from 0, which marks the
	 * beginning/end of a range that's in the set */
	if (cp_in_set) {
	    if (count == 0) {
		array_u[i_u++] = cp;
	    }
	    count++;
	}
	else {
	    count--;
	    if (count == 0) {
		array_u[i_u++] = cp;
	    }
	}
    }

    /* Here, we are finished going through at least one of the lists, which
     * means there is something remaining in at most one.  We check if the list
     * that hasn't been exhausted is positioned such that we are in the middle
     * of a range in its set or not.  (i_a and i_b point to the element beyond
     * the one we care about.) If in the set, we decrement 'count'; if 0, there
     * is potentially more to output.
     * There are four cases:
     *	1) Both weren't in their sets, count is 0, and remains 0.  What's left
     *	   in the union is entirely from the non-exhausted set.
     *	2) Both were in their sets, count is 2.  Nothing further should
     *	   be output, as everything that remains will be in the exhausted
     *	   list's set, hence in the union; decrementing to 1 but not 0 insures
     *	   that
     *	3) the exhausted was in its set, non-exhausted isn't, count is 1.
     *	   Nothing further should be output because the union includes
     *	   everything from the exhausted set.  Not decrementing ensures that.
     *	4) the exhausted wasn't in its set, non-exhausted is, count is 1;
     *	   decrementing to 0 insures that we look at the remainder of the
     *	   non-exhausted set */
    if (   (i_a != len_a && PREV_RANGE_MATCHES_INVLIST(i_a))
	|| (i_b != len_b && PREV_RANGE_MATCHES_INVLIST(i_b)))
    {
	count--;
    }

    /* The final length is what we've output so far, plus what else is about to
     * be output.  (If 'count' is non-zero, then the input list we exhausted
     * has everything remaining up to the machine's limit in its set, and hence
     * in the union, so there will be no further output. */
    len_u = i_u;
    if (count == 0) {
	/* At most one of the subexpressions will be non-zero */
	len_u += (len_a - i_a) + (len_b - i_b);
    }

    /* Set the result to the final length, which can change the pointer to
     * array_u, so re-find it.  (Note that it is unlikely that this will
     * change, as we are shrinking the space, not enlarging it) */
    if (len_u != _invlist_len(u)) {
	invlist_set_len(u, len_u, *get_invlist_offset_addr(u));
	invlist_trim(u);
	array_u = invlist_array(u);
    }

    /* When 'count' is 0, the list that was exhausted (if one was shorter than
     * the other) ended with everything above it not in its set.  That means
     * that the remaining part of the union is precisely the same as the
     * non-exhausted list, so can just copy it unchanged.  (If both lists were
     * exhausted at the same time, then the operations below will be both 0.)
     */
    if (count == 0) {
	IV copy_count; /* At most one will have a non-zero copy count */
	if ((copy_count = len_a - i_a) > 0) {
	    Copy(array_a + i_a, array_u + i_u, copy_count, UV);
	}
	else if ((copy_count = len_b - i_b) > 0) {
	    Copy(array_b + i_b, array_u + i_u, copy_count, UV);
	}
    }

    /* If the output is not to overwrite either of the inputs, just return the
     * calculated union */
    if (a != *output && b != *output) {
        *output = u;
    }
    else {
        /*  Here, the output is to be the same as one of the input scalars,
         *  hence replacing it.  The simple thing to do is to free the input
         *  scalar, making it instead be the output one.  But experience has
         *  shown [perl #127392] that if the input is a mortal, we can get a
         *  huge build-up of these during regex compilation before they get
         *  freed.  So for that case, replace just the input's interior with
         *  the output's, and then free the output */

        assert(! invlist_is_iterating(*output));

        if (! SvTEMP(*output)) {
            SvREFCNT_dec_NN(*output);
            *output = u;
        }
        else {
            invlist_replace_list_destroys_src(*output, u);
            SvREFCNT_dec_NN(u);
        }
    }

    return;
}

void
Perl__invlist_intersection_maybe_complement_2nd(pTHX_ SV* const a, SV* const b,
                                               const bool complement_b, SV** i)
{
    /* Take the intersection of two inversion lists and point <i> to it.  *i
     * SHOULD BE DEFINED upon input, and if it points to one of the two lists,
     * the reference count to that list will be decremented if not already a
     * temporary (mortal); otherwise just its contents will be modified to be
     * the intersection.  The first list, <a>, may be NULL, in which case an
     * empty list is returned.  If <complement_b> is TRUE, the result will be
     * the intersection of <a> and the complement (or inversion) of <b> instead
     * of <b> directly.
     *
     * The basis for this comes from "Unicode Demystified" Chapter 13 by
     * Richard Gillam, published by Addison-Wesley, and explained at some
     * length there.  The preface says to incorporate its examples into your
     * code at your own risk.  In fact, it had bugs
     *
     * The algorithm is like a merge sort, and is essentially the same as the
     * union above
     */

    const UV* array_a;		/* a's array */
    const UV* array_b;
    UV len_a;	/* length of a's array */
    UV len_b;

    SV* r;		     /* the resulting intersection */
    UV* array_r;
    UV len_r = 0;

    UV i_a = 0;		    /* current index into a's array */
    UV i_b = 0;
    UV i_r = 0;

    /* running count, as explained in the algorithm source book; items are
     * stopped accumulating and are output when the count changes to/from 2.
     * The count is incremented when we start a range that's in the set, and
     * decremented when we start a range that's not in the set.  So its range
     * is 0 to 2.  Only when the count is 2 is something in the intersection.
     */
    UV count = 0;

    PERL_ARGS_ASSERT__INVLIST_INTERSECTION_MAYBE_COMPLEMENT_2ND;
    assert(a != b);

    /* Special case if either one is empty */
    len_a = (a == NULL) ? 0 : _invlist_len(a);
    if ((len_a == 0) || ((len_b = _invlist_len(b)) == 0)) {
        if (len_a != 0 && complement_b) {

            /* Here, 'a' is not empty, therefore from the enclosing 'if', 'b'
             * must be empty.  Here, also we are using 'b's complement, which
             * hence must be every possible code point.  Thus the intersection
             * is simply 'a'. */

            if (*i == a) {  /* No-op */
                return;
            }

            /* If not overwriting either input, just make a copy of 'a' */
            if (*i != b) {
                *i = invlist_clone(a);
                return;
            }

            /* Here we are overwriting 'b' with 'a's contents */
            r = invlist_clone(a);
            invlist_replace_list_destroys_src(*i, r);
            SvREFCNT_dec_NN(r);
            return;
        }

        /* Here, 'a' or 'b' is empty and not using the complement of 'b'.  The
         * intersection must be empty */
        if (*i == NULL) {
            *i = _new_invlist(0);
            return;
        }

        invlist_clear(*i);
	return;
    }

    /* Here both lists exist and are non-empty */
    array_a = invlist_array(a);
    array_b = invlist_array(b);

    /* If are to take the intersection of 'a' with the complement of b, set it
     * up so are looking at b's complement. */
    if (complement_b) {

	/* To complement, we invert: if the first element is 0, remove it.  To
	 * do this, we just pretend the array starts one later */
        if (array_b[0] == 0) {
            array_b++;
            len_b--;
        }
        else {

            /* But if the first element is not zero, we pretend the list starts
             * at the 0 that is always stored immediately before the array. */
            array_b--;
            len_b++;
        }
    }

    /* Size the intersection for the worst case: that the intersection ends up
     * fragmenting everything to be completely disjoint */
    r= _new_invlist(len_a + len_b);

    /* Will contain U+0000 iff both components do */
    array_r = _invlist_array_init(r, len_a > 0 && array_a[0] == 0
				     && len_b > 0 && array_b[0] == 0);

    /* Go through each list item by item, stopping when exhausted one of
     * them */
    while (i_a < len_a && i_b < len_b) {
	UV cp;	    /* The element to potentially add to the intersection's
		       array */
	bool cp_in_set;	/* Is it in the input list's set or not */

	/* We need to take one or the other of the two inputs for the
	 * intersection.  Since we are merging two sorted lists, we take the
	 * smaller of the next items.  In case of a tie, we take the one that
	 * is not in its set first (a difference from the union algorithm).  If
	 * we took one in the set first, it would increment the count, possibly
	 * to 2 which would cause it to be output as starting a range in the
	 * intersection, and the next time through we would take that same
	 * number, and output it again as ending the set.  By doing it the
	 * opposite of this, there is no possibility that the count will be
	 * momentarily incremented to 2.  (In a tie and both are in the set or
	 * both not in the set, it doesn't matter which we take first.) */
	if (array_a[i_a] < array_b[i_b]
	    || (array_a[i_a] == array_b[i_b]
		&& ! ELEMENT_RANGE_MATCHES_INVLIST(i_a)))
	{
	    cp_in_set = ELEMENT_RANGE_MATCHES_INVLIST(i_a);
	    cp= array_a[i_a++];
	}
	else {
	    cp_in_set = ELEMENT_RANGE_MATCHES_INVLIST(i_b);
	    cp= array_b[i_b++];
	}

	/* Here, have chosen which of the two inputs to look at.  Only output
	 * if the running count changes to/from 2, which marks the
	 * beginning/end of a range that's in the intersection */
	if (cp_in_set) {
	    count++;
	    if (count == 2) {
		array_r[i_r++] = cp;
	    }
	}
	else {
	    if (count == 2) {
		array_r[i_r++] = cp;
	    }
	    count--;
	}
    }

    /* Here, we are finished going through at least one of the lists, which
     * means there is something remaining in at most one.  We check if the list
     * that has been exhausted is positioned such that we are in the middle
     * of a range in its set or not.  (i_a and i_b point to elements 1 beyond
     * the ones we care about.)  There are four cases:
     *	1) Both weren't in their sets, count is 0, and remains 0.  There's
     *	   nothing left in the intersection.
     *	2) Both were in their sets, count is 2 and perhaps is incremented to
     *	   above 2.  What should be output is exactly that which is in the
     *	   non-exhausted set, as everything it has is also in the intersection
     *	   set, and everything it doesn't have can't be in the intersection
     *	3) The exhausted was in its set, non-exhausted isn't, count is 1, and
     *	   gets incremented to 2.  Like the previous case, the intersection is
     *	   everything that remains in the non-exhausted set.
     *	4) the exhausted wasn't in its set, non-exhausted is, count is 1, and
     *	   remains 1.  And the intersection has nothing more. */
    if (   (i_a == len_a && PREV_RANGE_MATCHES_INVLIST(i_a))
	|| (i_b == len_b && PREV_RANGE_MATCHES_INVLIST(i_b)))
    {
	count++;
    }

    /* The final length is what we've output so far plus what else is in the
     * intersection.  At most one of the subexpressions below will be non-zero
     * */
    len_r = i_r;
    if (count >= 2) {
	len_r += (len_a - i_a) + (len_b - i_b);
    }

    /* Set the result to the final length, which can change the pointer to
     * array_r, so re-find it.  (Note that it is unlikely that this will
     * change, as we are shrinking the space, not enlarging it) */
    if (len_r != _invlist_len(r)) {
	invlist_set_len(r, len_r, *get_invlist_offset_addr(r));
	invlist_trim(r);
	array_r = invlist_array(r);
    }

    /* Finish outputting any remaining */
    if (count >= 2) { /* At most one will have a non-zero copy count */
	IV copy_count;
	if ((copy_count = len_a - i_a) > 0) {
	    Copy(array_a + i_a, array_r + i_r, copy_count, UV);
	}
	else if ((copy_count = len_b - i_b) > 0) {
	    Copy(array_b + i_b, array_r + i_r, copy_count, UV);
	}
    }

    /* If the output is not to overwrite either of the inputs, just return the
     * calculated intersection */
    if (a != *i && b != *i) {
        *i = r;
    }
    else {
        /*  Here, the output is to be the same as one of the input scalars,
         *  hence replacing it.  The simple thing to do is to free the input
         *  scalar, making it instead be the output one.  But experience has
         *  shown [perl #127392] that if the input is a mortal, we can get a
         *  huge build-up of these during regex compilation before they get
         *  freed.  So for that case, replace just the input's interior with
         *  the output's, and then free the output.  A short-cut in this case
         *  is if the output is empty, we can just set the input to be empty */

        assert(! invlist_is_iterating(*i));

        if (! SvTEMP(*i)) {
            SvREFCNT_dec_NN(*i);
            *i = r;
        }
        else {
            if (len_r) {
                invlist_replace_list_destroys_src(*i, r);
            }
            else {
                invlist_clear(*i);
            }
            SvREFCNT_dec_NN(r);
        }
    }

    return;
}

SV*
Perl__add_range_to_invlist(pTHX_ SV* invlist, const UV start, const UV end)
{
    /* Add the range from 'start' to 'end' inclusive to the inversion list's
     * set.  A pointer to the inversion list is returned.  This may actually be
     * a new list, in which case the passed in one has been destroyed.  The
     * passed-in inversion list can be NULL, in which case a new one is created
     * with just the one range in it */

    SV* range_invlist;
    UV len;

    if (invlist == NULL) {
	invlist = _new_invlist(2);
	len = 0;
    }
    else {
	len = _invlist_len(invlist);
    }

    /* If comes after the final entry actually in the list, can just append it
     * to the end, */
    if (len == 0
	|| (! ELEMENT_RANGE_MATCHES_INVLIST(len - 1)
            && start >= invlist_array(invlist)[len - 1]))
    {
	_append_range_to_invlist(invlist, start, end);
	return invlist;
    }

    /* Here, can't just append things, create and return a new inversion list
     * which is the union of this range and the existing inversion list.  (If
     * the new range is well-behaved wrt to the old one, we could just insert
     * it, doing a Move() down on the tail of the old one (potentially growing
     * it first).  But to determine that means we would have the extra
     * (possibly throw-away) work of first finding where the new one goes and
     * whether it disrupts (splits) an existing range, so it doesn't appear to
     * me (khw) that it's worth it) */
    range_invlist = _new_invlist(2);
    _append_range_to_invlist(range_invlist, start, end);

    _invlist_union(invlist, range_invlist, &invlist);

    /* The temporary can be freed */
    SvREFCNT_dec_NN(range_invlist);

    return invlist;
}

SV*
Perl__setup_canned_invlist(pTHX_ const STRLEN size, const UV element0,
                                 UV** other_elements_ptr)
{
    /* Create and return an inversion list whose contents are to be populated
     * by the caller.  The caller gives the number of elements (in 'size') and
     * the very first element ('element0').  This function will set
     * '*other_elements_ptr' to an array of UVs, where the remaining elements
     * are to be placed.
     *
     * Obviously there is some trust involved that the caller will properly
     * fill in the other elements of the array.
     *
     * (The first element needs to be passed in, as the underlying code does
     * things differently depending on whether it is zero or non-zero) */

    SV* invlist = _new_invlist(size);
    bool offset;

    PERL_ARGS_ASSERT__SETUP_CANNED_INVLIST;

    _append_range_to_invlist(invlist, element0, element0);
    offset = *get_invlist_offset_addr(invlist);

    invlist_set_len(invlist, size, offset);
    *other_elements_ptr = invlist_array(invlist) + 1;
    return invlist;
}

#endif

PERL_STATIC_INLINE SV*
S_add_cp_to_invlist(pTHX_ SV* invlist, const UV cp) {
    return _add_range_to_invlist(invlist, cp, cp);
}

#ifndef PERL_IN_XSUB_RE
void
Perl__invlist_invert(pTHX_ SV* const invlist)
{
    /* Complement the input inversion list.  This adds a 0 if the list didn't
     * have a zero; removes it otherwise.  As described above, the data
     * structure is set up so that this is very efficient */

    PERL_ARGS_ASSERT__INVLIST_INVERT;

    assert(! invlist_is_iterating(invlist));

    /* The inverse of matching nothing is matching everything */
    if (_invlist_len(invlist) == 0) {
	_append_range_to_invlist(invlist, 0, UV_MAX);
	return;
    }

    *get_invlist_offset_addr(invlist) = ! *get_invlist_offset_addr(invlist);
}

#endif

PERL_STATIC_INLINE SV*
S_invlist_clone(pTHX_ SV* const invlist)
{

    /* Return a new inversion list that is a copy of the input one, which is
     * unchanged.  The new list will not be mortal even if the old one was. */

    /* Need to allocate extra space to accommodate Perl's addition of a
     * trailing NUL to SvPV's, since it thinks they are always strings */
    SV* new_invlist = _new_invlist(_invlist_len(invlist) + 1);
    STRLEN physical_length = SvCUR(invlist);
    bool offset = *(get_invlist_offset_addr(invlist));

    PERL_ARGS_ASSERT_INVLIST_CLONE;

    *(get_invlist_offset_addr(new_invlist)) = offset;
    invlist_set_len(new_invlist, _invlist_len(invlist), offset);
    Copy(SvPVX(invlist), SvPVX(new_invlist), physical_length, char);

    return new_invlist;
}

PERL_STATIC_INLINE STRLEN*
S_get_invlist_iter_addr(SV* invlist)
{
    /* Return the address of the UV that contains the current iteration
     * position */

    PERL_ARGS_ASSERT_GET_INVLIST_ITER_ADDR;

    assert(SvTYPE(invlist) == SVt_INVLIST);

    return &(((XINVLIST*) SvANY(invlist))->iterator);
}

PERL_STATIC_INLINE void
S_invlist_iterinit(SV* invlist)	/* Initialize iterator for invlist */
{
    PERL_ARGS_ASSERT_INVLIST_ITERINIT;

    *get_invlist_iter_addr(invlist) = 0;
}

PERL_STATIC_INLINE void
S_invlist_iterfinish(SV* invlist)
{
    /* Terminate iterator for invlist.  This is to catch development errors.
     * Any iteration that is interrupted before completed should call this
     * function.  Functions that add code points anywhere else but to the end
     * of an inversion list assert that they are not in the middle of an
     * iteration.  If they were, the addition would make the iteration
     * problematical: if the iteration hadn't reached the place where things
     * were being added, it would be ok */

    PERL_ARGS_ASSERT_INVLIST_ITERFINISH;

    *get_invlist_iter_addr(invlist) = (STRLEN) UV_MAX;
}

STATIC bool
S_invlist_iternext(SV* invlist, UV* start, UV* end)
{
    /* An C<invlist_iterinit> call on <invlist> must be used to set this up.
     * This call sets in <*start> and <*end>, the next range in <invlist>.
     * Returns <TRUE> if successful and the next call will return the next
     * range; <FALSE> if was already at the end of the list.  If the latter,
     * <*start> and <*end> are unchanged, and the next call to this function
     * will start over at the beginning of the list */

    STRLEN* pos = get_invlist_iter_addr(invlist);
    UV len = _invlist_len(invlist);
    UV *array;

    PERL_ARGS_ASSERT_INVLIST_ITERNEXT;

    if (*pos >= len) {
	*pos = (STRLEN) UV_MAX;	/* Force iterinit() to be required next time */
	return FALSE;
    }

    array = invlist_array(invlist);

    *start = array[(*pos)++];

    if (*pos >= len) {
	*end = UV_MAX;
    }
    else {
	*end = array[(*pos)++] - 1;
    }

    return TRUE;
}

PERL_STATIC_INLINE UV
S_invlist_highest(SV* const invlist)
{
    /* Returns the highest code point that matches an inversion list.  This API
     * has an ambiguity, as it returns 0 under either the highest is actually
     * 0, or if the list is empty.  If this distinction matters to you, check
     * for emptiness before calling this function */

    UV len = _invlist_len(invlist);
    UV *array;

    PERL_ARGS_ASSERT_INVLIST_HIGHEST;

    if (len == 0) {
	return 0;
    }

    array = invlist_array(invlist);

    /* The last element in the array in the inversion list always starts a
     * range that goes to infinity.  That range may be for code points that are
     * matched in the inversion list, or it may be for ones that aren't
     * matched.  In the latter case, the highest code point in the set is one
     * less than the beginning of this range; otherwise it is the final element
     * of this range: infinity */
    return (ELEMENT_RANGE_MATCHES_INVLIST(len - 1))
           ? UV_MAX
           : array[len - 1] - 1;
}

STATIC SV *
S_invlist_contents(pTHX_ SV* const invlist, const bool traditional_style)
{
    /* Get the contents of an inversion list into a string SV so that they can
     * be printed out.  If 'traditional_style' is TRUE, it uses the format
     * traditionally done for debug tracing; otherwise it uses a format
     * suitable for just copying to the output, with blanks between ranges and
     * a dash between range components */

    UV start, end;
    SV* output;
    const char intra_range_delimiter = (traditional_style ? '\t' : '-');
    const char inter_range_delimiter = (traditional_style ? '\n' : ' ');

    if (traditional_style) {
        output = newSVpvs("\n");
    }
    else {
        output = newSVpvs("");
    }

    PERL_ARGS_ASSERT_INVLIST_CONTENTS;

    assert(! invlist_is_iterating(invlist));

    invlist_iterinit(invlist);
    while (invlist_iternext(invlist, &start, &end)) {
	if (end == UV_MAX) {
	    Perl_sv_catpvf(aTHX_ output, "%04"UVXf"%cINFINITY%c",
                                          start, intra_range_delimiter,
                                                 inter_range_delimiter);
	}
	else if (end != start) {
	    Perl_sv_catpvf(aTHX_ output, "%04"UVXf"%c%04"UVXf"%c",
		                          start,
                                                   intra_range_delimiter,
                                                  end, inter_range_delimiter);
	}
	else {
	    Perl_sv_catpvf(aTHX_ output, "%04"UVXf"%c",
                                          start, inter_range_delimiter);
	}
    }

    if (SvCUR(output) && ! traditional_style) {/* Get rid of trailing blank */
        SvCUR_set(output, SvCUR(output) - 1);
    }

    return output;
}

#ifndef PERL_IN_XSUB_RE
void
Perl__invlist_dump(pTHX_ PerlIO *file, I32 level,
                         const char * const indent, SV* const invlist)
{
    /* Designed to be called only by do_sv_dump().  Dumps out the ranges of the
     * inversion list 'invlist' to 'file' at 'level'  Each line is prefixed by
     * the string 'indent'.  The output looks like this:
         [0] 0x000A .. 0x000D
         [2] 0x0085
         [4] 0x2028 .. 0x2029
         [6] 0x3104 .. INFINITY
     * This means that the first range of code points matched by the list are
     * 0xA through 0xD; the second range contains only the single code point
     * 0x85, etc.  An inversion list is an array of UVs.  Two array elements
     * are used to define each range (except if the final range extends to
     * infinity, only a single element is needed).  The array index of the
     * first element for the corresponding range is given in brackets. */

    UV start, end;
    STRLEN count = 0;

    PERL_ARGS_ASSERT__INVLIST_DUMP;

    if (invlist_is_iterating(invlist)) {
        Perl_dump_indent(aTHX_ level, file,
             "%sCan't dump inversion list because is in middle of iterating\n",
             indent);
        return;
    }

    invlist_iterinit(invlist);
    while (invlist_iternext(invlist, &start, &end)) {
	if (end == UV_MAX) {
	    Perl_dump_indent(aTHX_ level, file,
                                       "%s[%"UVuf"] 0x%04"UVXf" .. INFINITY\n",
                                   indent, (UV)count, start);
	}
	else if (end != start) {
	    Perl_dump_indent(aTHX_ level, file,
                                    "%s[%"UVuf"] 0x%04"UVXf" .. 0x%04"UVXf"\n",
		                indent, (UV)count, start,         end);
	}
	else {
	    Perl_dump_indent(aTHX_ level, file, "%s[%"UVuf"] 0x%04"UVXf"\n",
                                            indent, (UV)count, start);
	}
        count += 2;
    }
}

void
Perl__load_PL_utf8_foldclosures (pTHX)
{
    assert(! PL_utf8_foldclosures);

    /* If the folds haven't been read in, call a fold function
     * to force that */
    if (! PL_utf8_tofold) {
        U8 dummy[UTF8_MAXBYTES_CASE+1];

        /* This string is just a short named one above \xff */
        to_utf8_fold((U8*) HYPHEN_UTF8, dummy, NULL);
        assert(PL_utf8_tofold); /* Verify that worked */
    }
    PL_utf8_foldclosures = _swash_inversion_hash(PL_utf8_tofold);
}
#endif

#if defined(PERL_ARGS_ASSERT__INVLISTEQ) && !defined(PERL_IN_XSUB_RE)
bool
Perl__invlistEQ(pTHX_ SV* const a, SV* const b, const bool complement_b)
{
    /* Return a boolean as to if the two passed in inversion lists are
     * identical.  The final argument, if TRUE, says to take the complement of
     * the second inversion list before doing the comparison */

    const UV* array_a = invlist_array(a);
    const UV* array_b = invlist_array(b);
    UV len_a = _invlist_len(a);
    UV len_b = _invlist_len(b);

    UV i = 0;		    /* current index into the arrays */
    bool retval = TRUE;     /* Assume are identical until proven otherwise */

    PERL_ARGS_ASSERT__INVLISTEQ;

    /* If are to compare 'a' with the complement of b, set it
     * up so are looking at b's complement. */
    if (complement_b) {

        /* The complement of nothing is everything, so <a> would have to have
         * just one element, starting at zero (ending at infinity) */
        if (len_b == 0) {
            return (len_a == 1 && array_a[0] == 0);
        }
        else if (array_b[0] == 0) {

            /* Otherwise, to complement, we invert.  Here, the first element is
             * 0, just remove it.  To do this, we just pretend the array starts
             * one later */

            array_b++;
            len_b--;
        }
        else {

            /* But if the first element is not zero, we pretend the list starts
             * at the 0 that is always stored immediately before the array. */
            array_b--;
            len_b++;
        }
    }

    /* Make sure that the lengths are the same, as well as the final element
     * before looping through the remainder.  (Thus we test the length, final,
     * and first elements right off the bat) */
    if (len_a != len_b || array_a[len_a-1] != array_b[len_a-1]) {
        retval = FALSE;
    }
    else for (i = 0; i < len_a - 1; i++) {
        if (array_a[i] != array_b[i]) {
            retval = FALSE;
            break;
        }
    }

    return retval;
}
#endif

/*
 * As best we can, determine the characters that can match the start of
 * the given EXACTF-ish node.
 *
 * Returns the invlist as a new SV*; it is the caller's responsibility to
 * call SvREFCNT_dec() when done with it.
 */
STATIC SV*
S__make_exactf_invlist(pTHX_ RExC_state_t *pRExC_state, regnode *node)
{
    const U8 * s = (U8*)STRING(node);
    SSize_t bytelen = STR_LEN(node);
    UV uc;
    /* Start out big enough for 2 separate code points */
    SV* invlist = _new_invlist(4);

    PERL_ARGS_ASSERT__MAKE_EXACTF_INVLIST;

    if (! UTF) {
        uc = *s;

        /* We punt and assume can match anything if the node begins
         * with a multi-character fold.  Things are complicated.  For
         * example, /ffi/i could match any of:
         *  "\N{LATIN SMALL LIGATURE FFI}"
         *  "\N{LATIN SMALL LIGATURE FF}I"
         *  "F\N{LATIN SMALL LIGATURE FI}"
         *  plus several other things; and making sure we have all the
         *  possibilities is hard. */
        if (is_MULTI_CHAR_FOLD_latin1_safe(s, s + bytelen)) {
            invlist = _add_range_to_invlist(invlist, 0, UV_MAX);
        }
        else {
            /* Any Latin1 range character can potentially match any
             * other depending on the locale */
            if (OP(node) == EXACTFL) {
                _invlist_union(invlist, PL_Latin1, &invlist);
            }
            else {
                /* But otherwise, it matches at least itself.  We can
                 * quickly tell if it has a distinct fold, and if so,
                 * it matches that as well */
                invlist = add_cp_to_invlist(invlist, uc);
                if (IS_IN_SOME_FOLD_L1(uc))
                    invlist = add_cp_to_invlist(invlist, PL_fold_latin1[uc]);
            }

            /* Some characters match above-Latin1 ones under /i.  This
             * is true of EXACTFL ones when the locale is UTF-8 */
            if (HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(uc)
                && (! isASCII(uc) || (OP(node) != EXACTFA
                                    && OP(node) != EXACTFA_NO_TRIE)))
            {
                add_above_Latin1_folds(pRExC_state, (U8) uc, &invlist);
            }
        }
    }
    else {  /* Pattern is UTF-8 */
        U8 folded[UTF8_MAX_FOLD_CHAR_EXPAND * UTF8_MAXBYTES_CASE + 1] = { '\0' };
        STRLEN foldlen = UTF8SKIP(s);
        const U8* e = s + bytelen;
        SV** listp;

        uc = utf8_to_uvchr_buf(s, s + bytelen, NULL);

        /* The only code points that aren't folded in a UTF EXACTFish
         * node are are the problematic ones in EXACTFL nodes */
        if (OP(node) == EXACTFL && is_PROBLEMATIC_LOCALE_FOLDEDS_START_cp(uc)) {
            /* We need to check for the possibility that this EXACTFL
             * node begins with a multi-char fold.  Therefore we fold
             * the first few characters of it so that we can make that
             * check */
            U8 *d = folded;
            int i;

            for (i = 0; i < UTF8_MAX_FOLD_CHAR_EXPAND && s < e; i++) {
                if (isASCII(*s)) {
                    *(d++) = (U8) toFOLD(*s);
                    s++;
                }
                else {
                    STRLEN len;
                    to_utf8_fold(s, d, &len);
                    d += len;
                    s += UTF8SKIP(s);
                }
            }

            /* And set up so the code below that looks in this folded
             * buffer instead of the node's string */
            e = d;
            foldlen = UTF8SKIP(folded);
            s = folded;
        }

        /* When we reach here 's' points to the fold of the first
         * character(s) of the node; and 'e' points to far enough along
         * the folded string to be just past any possible multi-char
         * fold. 'foldlen' is the length in bytes of the first
         * character in 's'
         *
         * Unlike the non-UTF-8 case, the macro for determining if a
         * string is a multi-char fold requires all the characters to
         * already be folded.  This is because of all the complications
         * if not.  Note that they are folded anyway, except in EXACTFL
         * nodes.  Like the non-UTF case above, we punt if the node
         * begins with a multi-char fold  */

        if (is_MULTI_CHAR_FOLD_utf8_safe(s, e)) {
            invlist = _add_range_to_invlist(invlist, 0, UV_MAX);
        }
        else {  /* Single char fold */

            /* It matches all the things that fold to it, which are
             * found in PL_utf8_foldclosures (including itself) */
            invlist = add_cp_to_invlist(invlist, uc);
            if (! PL_utf8_foldclosures)
                _load_PL_utf8_foldclosures();
            if ((listp = hv_fetch(PL_utf8_foldclosures,
                                (char *) s, foldlen, FALSE)))
            {
                AV* list = (AV*) *listp;
                IV k;
                for (k = 0; k <= av_tindex_nomg(list); k++) {
                    SV** c_p = av_fetch(list, k, FALSE);
                    UV c;
                    assert(c_p);

                    c = SvUV(*c_p);

                    /* /aa doesn't allow folds between ASCII and non- */
                    if ((OP(node) == EXACTFA || OP(node) == EXACTFA_NO_TRIE)
                        && isASCII(c) != isASCII(uc))
                    {
                        continue;
                    }

                    invlist = add_cp_to_invlist(invlist, c);
                }
            }
        }
    }

    return invlist;
}

#undef HEADER_LENGTH
#undef TO_INTERNAL_SIZE
#undef FROM_INTERNAL_SIZE
#undef INVLIST_VERSION_ID

/* End of inversion list object */

STATIC void
S_parse_lparen_question_flags(pTHX_ RExC_state_t *pRExC_state)
{
    /* This parses the flags that are in either the '(?foo)' or '(?foo:bar)'
     * constructs, and updates RExC_flags with them.  On input, RExC_parse
     * should point to the first flag; it is updated on output to point to the
     * final ')' or ':'.  There needs to be at least one flag, or this will
     * abort */

    /* for (?g), (?gc), and (?o) warnings; warning
       about (?c) will warn about (?g) -- japhy    */

#define WASTED_O  0x01
#define WASTED_G  0x02
#define WASTED_C  0x04
#define WASTED_GC (WASTED_G|WASTED_C)
    I32 wastedflags = 0x00;
    U32 posflags = 0, negflags = 0;
    U32 *flagsp = &posflags;
    char has_charset_modifier = '\0';
    regex_charset cs;
    bool has_use_defaults = FALSE;
    const char* const seqstart = RExC_parse - 1; /* Point to the '?' */
    int x_mod_count = 0;

    PERL_ARGS_ASSERT_PARSE_LPAREN_QUESTION_FLAGS;

    /* '^' as an initial flag sets certain defaults */
    if (UCHARAT(RExC_parse) == '^') {
        RExC_parse++;
        has_use_defaults = TRUE;
        STD_PMMOD_FLAGS_CLEAR(&RExC_flags);
        set_regex_charset(&RExC_flags, (RExC_utf8 || RExC_uni_semantics)
                                        ? REGEX_UNICODE_CHARSET
                                        : REGEX_DEPENDS_CHARSET);
    }

    cs = get_regex_charset(RExC_flags);
    if (cs == REGEX_DEPENDS_CHARSET
        && (RExC_utf8 || RExC_uni_semantics))
    {
        cs = REGEX_UNICODE_CHARSET;
    }

    while (RExC_parse < RExC_end) {
        /* && strchr("iogcmsx", *RExC_parse) */
        /* (?g), (?gc) and (?o) are useless here
           and must be globally applied -- japhy */
        switch (*RExC_parse) {

            /* Code for the imsxn flags */
            CASE_STD_PMMOD_FLAGS_PARSE_SET(flagsp, x_mod_count);

            case LOCALE_PAT_MOD:
                if (has_charset_modifier) {
                    goto excess_modifier;
                }
                else if (flagsp == &negflags) {
                    goto neg_modifier;
                }
                cs = REGEX_LOCALE_CHARSET;
                has_charset_modifier = LOCALE_PAT_MOD;
                break;
            case UNICODE_PAT_MOD:
                if (has_charset_modifier) {
                    goto excess_modifier;
                }
                else if (flagsp == &negflags) {
                    goto neg_modifier;
                }
                cs = REGEX_UNICODE_CHARSET;
                has_charset_modifier = UNICODE_PAT_MOD;
                break;
            case ASCII_RESTRICT_PAT_MOD:
                if (flagsp == &negflags) {
                    goto neg_modifier;
                }
                if (has_charset_modifier) {
                    if (cs != REGEX_ASCII_RESTRICTED_CHARSET) {
                        goto excess_modifier;
                    }
                    /* Doubled modifier implies more restricted */
                    cs = REGEX_ASCII_MORE_RESTRICTED_CHARSET;
                }
                else {
                    cs = REGEX_ASCII_RESTRICTED_CHARSET;
                }
                has_charset_modifier = ASCII_RESTRICT_PAT_MOD;
                break;
            case DEPENDS_PAT_MOD:
                if (has_use_defaults) {
                    goto fail_modifiers;
                }
                else if (flagsp == &negflags) {
                    goto neg_modifier;
                }
                else if (has_charset_modifier) {
                    goto excess_modifier;
                }

                /* The dual charset means unicode semantics if the
                 * pattern (or target, not known until runtime) are
                 * utf8, or something in the pattern indicates unicode
                 * semantics */
                cs = (RExC_utf8 || RExC_uni_semantics)
                     ? REGEX_UNICODE_CHARSET
                     : REGEX_DEPENDS_CHARSET;
                has_charset_modifier = DEPENDS_PAT_MOD;
                break;
              excess_modifier:
                RExC_parse++;
                if (has_charset_modifier == ASCII_RESTRICT_PAT_MOD) {
                    vFAIL2("Regexp modifier \"%c\" may appear a maximum of twice", ASCII_RESTRICT_PAT_MOD);
                }
                else if (has_charset_modifier == *(RExC_parse - 1)) {
                    vFAIL2("Regexp modifier \"%c\" may not appear twice",
                                        *(RExC_parse - 1));
                }
                else {
                    vFAIL3("Regexp modifiers \"%c\" and \"%c\" are mutually exclusive", has_charset_modifier, *(RExC_parse - 1));
                }
                NOT_REACHED; /*NOTREACHED*/
              neg_modifier:
                RExC_parse++;
                vFAIL2("Regexp modifier \"%c\" may not appear after the \"-\"",
                                    *(RExC_parse - 1));
                NOT_REACHED; /*NOTREACHED*/
            case ONCE_PAT_MOD: /* 'o' */
            case GLOBAL_PAT_MOD: /* 'g' */
                if (PASS2 && ckWARN(WARN_REGEXP)) {
                    const I32 wflagbit = *RExC_parse == 'o'
                                         ? WASTED_O
                                         : WASTED_G;
                    if (! (wastedflags & wflagbit) ) {
                        wastedflags |= wflagbit;
			/* diag_listed_as: Useless (?-%s) - don't use /%s modifier in regex; marked by <-- HERE in m/%s/ */
                        vWARN5(
                            RExC_parse + 1,
                            "Useless (%s%c) - %suse /%c modifier",
                            flagsp == &negflags ? "?-" : "?",
                            *RExC_parse,
                            flagsp == &negflags ? "don't " : "",
                            *RExC_parse
                        );
                    }
                }
                break;

            case CONTINUE_PAT_MOD: /* 'c' */
                if (PASS2 && ckWARN(WARN_REGEXP)) {
                    if (! (wastedflags & WASTED_C) ) {
                        wastedflags |= WASTED_GC;
			/* diag_listed_as: Useless (?-%s) - don't use /%s modifier in regex; marked by <-- HERE in m/%s/ */
                        vWARN3(
                            RExC_parse + 1,
                            "Useless (%sc) - %suse /gc modifier",
                            flagsp == &negflags ? "?-" : "?",
                            flagsp == &negflags ? "don't " : ""
                        );
                    }
                }
                break;
            case KEEPCOPY_PAT_MOD: /* 'p' */
                if (flagsp == &negflags) {
                    if (PASS2)
                        ckWARNreg(RExC_parse + 1,"Useless use of (?-p)");
                } else {
                    *flagsp |= RXf_PMf_KEEPCOPY;
                }
                break;
            case '-':
                /* A flag is a default iff it is following a minus, so
                 * if there is a minus, it means will be trying to
                 * re-specify a default which is an error */
                if (has_use_defaults || flagsp == &negflags) {
                    goto fail_modifiers;
                }
                flagsp = &negflags;
                wastedflags = 0;  /* reset so (?g-c) warns twice */
                break;
            case ':':
            case ')':
                RExC_flags |= posflags;
                RExC_flags &= ~negflags;
                set_regex_charset(&RExC_flags, cs);
                if (RExC_flags & RXf_PMf_FOLD) {
                    RExC_contains_i = 1;
                }
                if (PASS2) {
                    STD_PMMOD_FLAGS_PARSE_X_WARN(x_mod_count);
                }
                return;
                /*NOTREACHED*/
            default:
              fail_modifiers:
                RExC_parse += SKIP_IF_CHAR(RExC_parse);
		/* diag_listed_as: Sequence (?%s...) not recognized in regex; marked by <-- HERE in m/%s/ */
                vFAIL2utf8f("Sequence (%"UTF8f"...) not recognized",
                      UTF8fARG(UTF, RExC_parse-seqstart, seqstart));
                NOT_REACHED; /*NOTREACHED*/
        }

        RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;
    }

    vFAIL("Sequence (?... not terminated");
}

/*
 - reg - regular expression, i.e. main body or parenthesized thing
 *
 * Caller must absorb opening parenthesis.
 *
 * Combining parenthesis handling with the base level of regular expression
 * is a trifle forced, but the need to tie the tails of the branches to what
 * follows makes it hard to avoid.
 */
#define REGTAIL(x,y,z) regtail((x),(y),(z),depth+1)
#ifdef DEBUGGING
#define REGTAIL_STUDY(x,y,z) regtail_study((x),(y),(z),depth+1)
#else
#define REGTAIL_STUDY(x,y,z) regtail((x),(y),(z),depth+1)
#endif

PERL_STATIC_INLINE regnode *
S_handle_named_backref(pTHX_ RExC_state_t *pRExC_state,
                             I32 *flagp,
                             char * parse_start,
                             char ch
                      )
{
    regnode *ret;
    char* name_start = RExC_parse;
    U32 num = 0;
    SV *sv_dat = reg_scan_name(pRExC_state, SIZE_ONLY
                                            ? REG_RSN_RETURN_NULL
                                            : REG_RSN_RETURN_DATA);
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_HANDLE_NAMED_BACKREF;

    if (RExC_parse == name_start || *RExC_parse != ch) {
        /* diag_listed_as: Sequence \%s... not terminated in regex; marked by <-- HERE in m/%s/ */
        vFAIL2("Sequence %.3s... not terminated",parse_start);
    }

    if (!SIZE_ONLY) {
        num = add_data( pRExC_state, STR_WITH_LEN("S"));
        RExC_rxi->data->data[num]=(void*)sv_dat;
        SvREFCNT_inc_simple_void(sv_dat);
    }
    RExC_sawback = 1;
    ret = reganode(pRExC_state,
                   ((! FOLD)
                     ? NREF
                     : (ASCII_FOLD_RESTRICTED)
                       ? NREFFA
                       : (AT_LEAST_UNI_SEMANTICS)
                         ? NREFFU
                         : (LOC)
                           ? NREFFL
                           : NREFF),
                    num);
    *flagp |= HASWIDTH;

    Set_Node_Offset(ret, parse_start+1);
    Set_Node_Cur_Length(ret, parse_start);

    nextchar(pRExC_state);
    return ret;
}

/* Returns NULL, setting *flagp to TRYAGAIN at the end of (?) that only sets
   flags. Returns NULL, setting *flagp to RESTART_PASS1 if the sizing scan
   needs to be restarted, or'd with NEED_UTF8 if the pattern needs to be
   upgraded to UTF-8.  Otherwise would only return NULL if regbranch() returns
   NULL, which cannot happen.  */
STATIC regnode *
S_reg(pTHX_ RExC_state_t *pRExC_state, I32 paren, I32 *flagp,U32 depth)
    /* paren: Parenthesized? 0=top; 1,2=inside '(': changed to letter.
     * 2 is like 1, but indicates that nextchar() has been called to advance
     * RExC_parse beyond the '('.  Things like '(?' are indivisible tokens, and
     * this flag alerts us to the need to check for that */
{
    regnode *ret;		/* Will be the head of the group. */
    regnode *br;
    regnode *lastbr;
    regnode *ender = NULL;
    I32 parno = 0;
    I32 flags;
    U32 oregflags = RExC_flags;
    bool have_branch = 0;
    bool is_open = 0;
    I32 freeze_paren = 0;
    I32 after_freeze = 0;
    I32 num; /* numeric backreferences */

    char * parse_start = RExC_parse; /* MJD */
    char * const oregcomp_parse = RExC_parse;

    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_REG;
    DEBUG_PARSE("reg ");

    *flagp = 0;				/* Tentatively. */

    /* Having this true makes it feasible to have a lot fewer tests for the
     * parse pointer being in scope.  For example, we can write
     *      while(isFOO(*RExC_parse)) RExC_parse++;
     * instead of
     *      while(RExC_parse < RExC_end && isFOO(*RExC_parse)) RExC_parse++;
     */
    assert(*RExC_end == '\0');

    /* Make an OPEN node, if parenthesized. */
    if (paren) {

        /* Under /x, space and comments can be gobbled up between the '(' and
         * here (if paren ==2).  The forms '(*VERB' and '(?...' disallow such
         * intervening space, as the sequence is a token, and a token should be
         * indivisible */
        bool has_intervening_patws = paren == 2 && *(RExC_parse - 1) != '(';

        if (RExC_parse >= RExC_end) {
	    vFAIL("Unmatched (");
        }

        if ( *RExC_parse == '*') { /* (*VERB:ARG) */
	    char *start_verb = RExC_parse + 1;
	    STRLEN verb_len;
	    char *start_arg = NULL;
	    unsigned char op = 0;
            int arg_required = 0;
            int internal_argval = -1; /* if >-1 we are not allowed an argument*/

            if (has_intervening_patws) {
                RExC_parse++;   /* past the '*' */
                vFAIL("In '(*VERB...)', the '(' and '*' must be adjacent");
            }
	    while (RExC_parse < RExC_end && *RExC_parse != ')' ) {
	        if ( *RExC_parse == ':' ) {
	            start_arg = RExC_parse + 1;
	            break;
	        }
	        RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;
	    }
	    verb_len = RExC_parse - start_verb;
	    if ( start_arg ) {
                if (RExC_parse >= RExC_end) {
                    goto unterminated_verb_pattern;
                }
	        RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;
	        while ( RExC_parse < RExC_end && *RExC_parse != ')' )
                    RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;
	        if ( RExC_parse >= RExC_end || *RExC_parse != ')' )
                  unterminated_verb_pattern:
	            vFAIL("Unterminated verb pattern argument");
	        if ( RExC_parse == start_arg )
	            start_arg = NULL;
	    } else {
	        if ( RExC_parse >= RExC_end || *RExC_parse != ')' )
	            vFAIL("Unterminated verb pattern");
	    }

            /* Here, we know that RExC_parse < RExC_end */

	    switch ( *start_verb ) {
            case 'A':  /* (*ACCEPT) */
                if ( memEQs(start_verb,verb_len,"ACCEPT") ) {
		    op = ACCEPT;
		    internal_argval = RExC_nestroot;
		}
		break;
            case 'C':  /* (*COMMIT) */
                if ( memEQs(start_verb,verb_len,"COMMIT") )
                    op = COMMIT;
                break;
            case 'F':  /* (*FAIL) */
                if ( verb_len==1 || memEQs(start_verb,verb_len,"FAIL") ) {
		    op = OPFAIL;
		}
		break;
            case ':':  /* (*:NAME) */
	    case 'M':  /* (*MARK:NAME) */
	        if ( verb_len==0 || memEQs(start_verb,verb_len,"MARK") ) {
                    op = MARKPOINT;
                    arg_required = 1;
                }
                break;
            case 'P':  /* (*PRUNE) */
                if ( memEQs(start_verb,verb_len,"PRUNE") )
                    op = PRUNE;
                break;
            case 'S':   /* (*SKIP) */
                if ( memEQs(start_verb,verb_len,"SKIP") )
                    op = SKIP;
                break;
            case 'T':  /* (*THEN) */
                /* [19:06] <TimToady> :: is then */
                if ( memEQs(start_verb,verb_len,"THEN") ) {
                    op = CUTGROUP;
                    RExC_seen |= REG_CUTGROUP_SEEN;
                }
                break;
	    }
	    if ( ! op ) {
	        RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;
                vFAIL2utf8f(
                    "Unknown verb pattern '%"UTF8f"'",
                    UTF8fARG(UTF, verb_len, start_verb));
	    }
            if ( arg_required && !start_arg ) {
                vFAIL3("Verb pattern '%.*s' has a mandatory argument",
                    verb_len, start_verb);
            }
            if (internal_argval == -1) {
                ret = reganode(pRExC_state, op, 0);
            } else {
                ret = reg2Lanode(pRExC_state, op, 0, internal_argval);
            }
            RExC_seen |= REG_VERBARG_SEEN;
            if ( ! SIZE_ONLY ) {
                if (start_arg) {
                    SV *sv = newSVpvn( start_arg,
                                       RExC_parse - start_arg);
                    ARG(ret) = add_data( pRExC_state,
                                         STR_WITH_LEN("S"));
                    RExC_rxi->data->data[ARG(ret)]=(void*)sv;
                    ret->flags = 1;
                } else {
                    ret->flags = 0;
                }
                if ( internal_argval != -1 )
                    ARG2L_SET(ret, internal_argval);
            }
	    nextchar(pRExC_state);
	    return ret;
        }
        else if (*RExC_parse == '?') { /* (?...) */
	    bool is_logical = 0;
	    const char * const seqstart = RExC_parse;
            const char * endptr;
            if (has_intervening_patws) {
                RExC_parse++;
                vFAIL("In '(?...)', the '(' and '?' must be adjacent");
            }

	    RExC_parse++;           /* past the '?' */
            paren = *RExC_parse;    /* might be a trailing NUL, if not
                                       well-formed */
            RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;
            if (RExC_parse > RExC_end) {
                paren = '\0';
            }
	    ret = NULL;			/* For look-ahead/behind. */
	    switch (paren) {

	    case 'P':	/* (?P...) variants for those used to PCRE/Python */
	        paren = *RExC_parse;
		if ( paren == '<') {    /* (?P<...>) named capture */
                    RExC_parse++;
                    if (RExC_parse >= RExC_end) {
                        vFAIL("Sequence (?P<... not terminated");
                    }
		    goto named_capture;
                }
                else if (paren == '>') {   /* (?P>name) named recursion */
                    RExC_parse++;
                    if (RExC_parse >= RExC_end) {
                        vFAIL("Sequence (?P>... not terminated");
                    }
                    goto named_recursion;
                }
                else if (paren == '=') {   /* (?P=...)  named backref */
                    RExC_parse++;
                    return handle_named_backref(pRExC_state, flagp,
                                                parse_start, ')');
                }
                RExC_parse += SKIP_IF_CHAR(RExC_parse);
                /* diag_listed_as: Sequence (?%s...) not recognized in regex; marked by <-- HERE in m/%s/ */
		vFAIL3("Sequence (%.*s...) not recognized",
                                RExC_parse-seqstart, seqstart);
		NOT_REACHED; /*NOTREACHED*/
            case '<':           /* (?<...) */
		if (*RExC_parse == '!')
		    paren = ',';
		else if (*RExC_parse != '=')
              named_capture:
		{               /* (?<...>) */
		    char *name_start;
		    SV *svname;
		    paren= '>';
                /* FALLTHROUGH */
            case '\'':          /* (?'...') */
                    name_start = RExC_parse;
                    svname = reg_scan_name(pRExC_state,
                        SIZE_ONLY    /* reverse test from the others */
                        ? REG_RSN_RETURN_NAME
                        : REG_RSN_RETURN_NULL);
		    if (   RExC_parse == name_start
                        || RExC_parse >= RExC_end
                        || *RExC_parse != paren)
                    {
		        vFAIL2("Sequence (?%c... not terminated",
		            paren=='>' ? '<' : paren);
                    }
		    if (SIZE_ONLY) {
			HE *he_str;
			SV *sv_dat = NULL;
                        if (!svname) /* shouldn't happen */
                            Perl_croak(aTHX_
                                "panic: reg_scan_name returned NULL");
                        if (!RExC_paren_names) {
                            RExC_paren_names= newHV();
                            sv_2mortal(MUTABLE_SV(RExC_paren_names));
#ifdef DEBUGGING
                            RExC_paren_name_list= newAV();
                            sv_2mortal(MUTABLE_SV(RExC_paren_name_list));
#endif
                        }
                        he_str = hv_fetch_ent( RExC_paren_names, svname, 1, 0 );
                        if ( he_str )
                            sv_dat = HeVAL(he_str);
                        if ( ! sv_dat ) {
                            /* croak baby croak */
                            Perl_croak(aTHX_
                                "panic: paren_name hash element allocation failed");
                        } else if ( SvPOK(sv_dat) ) {
                            /* (?|...) can mean we have dupes so scan to check
                               its already been stored. Maybe a flag indicating
                               we are inside such a construct would be useful,
                               but the arrays are likely to be quite small, so
                               for now we punt -- dmq */
                            IV count = SvIV(sv_dat);
                            I32 *pv = (I32*)SvPVX(sv_dat);
                            IV i;
                            for ( i = 0 ; i < count ; i++ ) {
                                if ( pv[i] == RExC_npar ) {
                                    count = 0;
                                    break;
                                }
                            }
                            if ( count ) {
                                pv = (I32*)SvGROW(sv_dat,
                                                SvCUR(sv_dat) + sizeof(I32)+1);
                                SvCUR_set(sv_dat, SvCUR(sv_dat) + sizeof(I32));
                                pv[count] = RExC_npar;
                                SvIV_set(sv_dat, SvIVX(sv_dat) + 1);
                            }
                        } else {
                            (void)SvUPGRADE(sv_dat,SVt_PVNV);
                            sv_setpvn(sv_dat, (char *)&(RExC_npar),
                                                                sizeof(I32));
                            SvIOK_on(sv_dat);
                            SvIV_set(sv_dat, 1);
                        }
#ifdef DEBUGGING
                        /* Yes this does cause a memory leak in debugging Perls
                         * */
                        if (!av_store(RExC_paren_name_list,
                                      RExC_npar, SvREFCNT_inc(svname)))
                            SvREFCNT_dec_NN(svname);
#endif

                        /*sv_dump(sv_dat);*/
                    }
                    nextchar(pRExC_state);
		    paren = 1;
		    goto capturing_parens;
		}
                RExC_seen |= REG_LOOKBEHIND_SEEN;
		RExC_in_lookbehind++;
		RExC_parse++;
                assert(RExC_parse < RExC_end);
                /* FALLTHROUGH */
	    case '=':           /* (?=...) */
		RExC_seen_zerolen++;
                break;
	    case '!':           /* (?!...) */
		RExC_seen_zerolen++;
		/* check if we're really just a "FAIL" assertion */
                skip_to_be_ignored_text(pRExC_state, &RExC_parse,
                                        FALSE /* Don't force to /x */ );
	        if (*RExC_parse == ')') {
                    ret=reganode(pRExC_state, OPFAIL, 0);
	            nextchar(pRExC_state);
	            return ret;
	        }
	        break;
	    case '|':           /* (?|...) */
	        /* branch reset, behave like a (?:...) except that
	           buffers in alternations share the same numbers */
	        paren = ':';
	        after_freeze = freeze_paren = RExC_npar;
	        break;
	    case ':':           /* (?:...) */
	    case '>':           /* (?>...) */
		break;
	    case '$':           /* (?$...) */
	    case '@@':           /* (?@@...) */
		vFAIL2("Sequence (?%c...) not implemented", (int)paren);
		break;
	    case '0' :           /* (?0) */
	    case 'R' :           /* (?R) */
                if (RExC_parse == RExC_end || *RExC_parse != ')')
		    FAIL("Sequence (?R) not terminated");
                num = 0;
                RExC_seen |= REG_RECURSE_SEEN;
		*flagp |= POSTPONED;
                goto gen_recurse_regop;
		/*notreached*/
            /* named and numeric backreferences */
            case '&':            /* (?&NAME) */
                parse_start = RExC_parse - 1;
              named_recursion:
                {
    		    SV *sv_dat = reg_scan_name(pRExC_state,
    		        SIZE_ONLY ? REG_RSN_RETURN_NULL : REG_RSN_RETURN_DATA);
    		     num = sv_dat ? *((I32 *)SvPVX(sv_dat)) : 0;
                }
                if (RExC_parse >= RExC_end || *RExC_parse != ')')
                    vFAIL("Sequence (?&... not terminated");
                goto gen_recurse_regop;
                /* NOTREACHED */
            case '+':
                if (!(RExC_parse[0] >= '1' && RExC_parse[0] <= '9')) {
                    RExC_parse++;
                    vFAIL("Illegal pattern");
                }
                goto parse_recursion;
                /* NOTREACHED*/
            case '-': /* (?-1) */
                if (!(RExC_parse[0] >= '1' && RExC_parse[0] <= '9')) {
                    RExC_parse--; /* rewind to let it be handled later */
                    goto parse_flags;
                }
                /* FALLTHROUGH */
            case '1': case '2': case '3': case '4': /* (?1) */
	    case '5': case '6': case '7': case '8': case '9':
	        RExC_parse = (char *) seqstart + 1;  /* Point to the digit */
              parse_recursion:
                {
                    bool is_neg = FALSE;
                    UV unum;
                    parse_start = RExC_parse - 1; /* MJD */
                    if (*RExC_parse == '-') {
                        RExC_parse++;
                        is_neg = TRUE;
                    }
                    if (grok_atoUV(RExC_parse, &unum, &endptr)
                        && unum <= I32_MAX
                    ) {
                        num = (I32)unum;
                        RExC_parse = (char*)endptr;
                    } else
                        num = I32_MAX;
                    if (is_neg) {
                        /* Some limit for num? */
                        num = -num;
                    }
                }
	        if (*RExC_parse!=')')
	            vFAIL("Expecting close bracket");

              gen_recurse_regop:
                if ( paren == '-' ) {
                    /*
                    Diagram of capture buffer numbering.
                    Top line is the normal capture buffer numbers
                    Bottom line is the negative indexing as from
                    the X (the (?-2))

                    +   1 2    3 4 5 X          6 7
                       /(a(x)y)(a(b(c(?-2)d)e)f)(g(h))/
                    -   5 4    3 2 1 X          x x

                    */
                    num = RExC_npar + num;
                    if (num < 1)  {
                        RExC_parse++;
                        vFAIL("Reference to nonexistent group");
                    }
                } else if ( paren == '+' ) {
                    num = RExC_npar + num - 1;
                }
                /* We keep track how many GOSUB items we have produced.
                   To start off the ARG2L() of the GOSUB holds its "id",
                   which is used later in conjunction with RExC_recurse
                   to calculate the offset we need to jump for the GOSUB,
                   which it will store in the final representation.
                   We have to defer the actual calculation until much later
                   as the regop may move.
                 */

                ret = reg2Lanode(pRExC_state, GOSUB, num, RExC_recurse_count);
                if (!SIZE_ONLY) {
		    if (num > (I32)RExC_rx->nparens) {
			RExC_parse++;
			vFAIL("Reference to nonexistent group");
	            }
	            RExC_recurse_count++;
                    DEBUG_OPTIMISE_MORE_r(Perl_re_printf( aTHX_
                        "%*s%*s Recurse #%"UVuf" to %"IVdf"\n",
                              22, "|    |", (int)(depth * 2 + 1), "",
                              (UV)ARG(ret), (IV)ARG2L(ret)));
                }
                RExC_seen |= REG_RECURSE_SEEN;

                Set_Node_Length(ret, 1 + regarglen[OP(ret)]); /* MJD */
		Set_Node_Offset(ret, parse_start); /* MJD */

                *flagp |= POSTPONED;
                assert(*RExC_parse == ')');
                nextchar(pRExC_state);
                return ret;

            /* NOTREACHED */

	    case '?':           /* (??...) */
		is_logical = 1;
		if (*RExC_parse != '{') {
                    RExC_parse += SKIP_IF_CHAR(RExC_parse);
                    /* diag_listed_as: Sequence (?%s...) not recognized in regex; marked by <-- HERE in m/%s/ */
                    vFAIL2utf8f(
                        "Sequence (%"UTF8f"...) not recognized",
                        UTF8fARG(UTF, RExC_parse-seqstart, seqstart));
		    NOT_REACHED; /*NOTREACHED*/
		}
		*flagp |= POSTPONED;
		paren = '{';
                RExC_parse++;
		/* FALLTHROUGH */
	    case '{':           /* (?{...}) */
	    {
		U32 n = 0;
		struct reg_code_block *cb;

		RExC_seen_zerolen++;

		if (   !pRExC_state->num_code_blocks
		    || pRExC_state->code_index >= pRExC_state->num_code_blocks
		    || pRExC_state->code_blocks[pRExC_state->code_index].start
			!= (STRLEN)((RExC_parse -3 - (is_logical ? 1 : 0))
			    - RExC_start)
		) {
		    if (RExC_pm_flags & PMf_USE_RE_EVAL)
			FAIL("panic: Sequence (?{...}): no code block found\n");
		    FAIL("Eval-group not allowed at runtime, use re 'eval'");
		}
		/* this is a pre-compiled code block (?{...}) */
		cb = &pRExC_state->code_blocks[pRExC_state->code_index];
		RExC_parse = RExC_start + cb->end;
		if (!SIZE_ONLY) {
		    OP *o = cb->block;
		    if (cb->src_regex) {
			n = add_data(pRExC_state, STR_WITH_LEN("rl"));
			RExC_rxi->data->data[n] =
			    (void*)SvREFCNT_inc((SV*)cb->src_regex);
			RExC_rxi->data->data[n+1] = (void*)o;
		    }
		    else {
			n = add_data(pRExC_state,
			       (RExC_pm_flags & PMf_HAS_CV) ? "L" : "l", 1);
			RExC_rxi->data->data[n] = (void*)o;
		    }
		}
		pRExC_state->code_index++;
		nextchar(pRExC_state);

		if (is_logical) {
                    regnode *eval;
		    ret = reg_node(pRExC_state, LOGICAL);

                    eval = reg2Lanode(pRExC_state, EVAL,
                                       n,

                                       /* for later propagation into (??{})
                                        * return value */
                                       RExC_flags & RXf_PMf_COMPILETIME
                                      );
		    if (!SIZE_ONLY) {
			ret->flags = 2;
                    }
                    REGTAIL(pRExC_state, ret, eval);
                    /* deal with the length of this later - MJD */
		    return ret;
		}
		ret = reg2Lanode(pRExC_state, EVAL, n, 0);
		Set_Node_Length(ret, RExC_parse - parse_start + 1);
		Set_Node_Offset(ret, parse_start);
		return ret;
	    }
	    case '(':           /* (?(?{...})...) and (?(?=...)...) */
	    {
	        int is_define= 0;
                const int DEFINE_len = sizeof("DEFINE") - 1;
		if (RExC_parse[0] == '?') {        /* (?(?...)) */
                    if (   RExC_parse < RExC_end - 1
                        && (   RExC_parse[1] == '='
                            || RExC_parse[1] == '!'
                            || RExC_parse[1] == '<'
                            || RExC_parse[1] == '{')
                    ) { /* Lookahead or eval. */
			I32 flag;
                        regnode *tail;

			ret = reg_node(pRExC_state, LOGICAL);
			if (!SIZE_ONLY)
			    ret->flags = 1;

                        tail = reg(pRExC_state, 1, &flag, depth+1);
                        if (flag & (RESTART_PASS1|NEED_UTF8)) {
                            *flagp = flag & (RESTART_PASS1|NEED_UTF8);
                            return NULL;
                        }
                        REGTAIL(pRExC_state, ret, tail);
			goto insert_if;
		    }
		    /* Fall through to ‘Unknown switch condition’ at the
		       end of the if/else chain. */
		}
		else if ( RExC_parse[0] == '<'     /* (?(<NAME>)...) */
		         || RExC_parse[0] == '\'' ) /* (?('NAME')...) */
	        {
	            char ch = RExC_parse[0] == '<' ? '>' : '\'';
	            char *name_start= RExC_parse++;
	            U32 num = 0;
	            SV *sv_dat=reg_scan_name(pRExC_state,
	                SIZE_ONLY ? REG_RSN_RETURN_NULL : REG_RSN_RETURN_DATA);
	            if (   RExC_parse == name_start
                        || RExC_parse >= RExC_end
                        || *RExC_parse != ch)
                    {
                        vFAIL2("Sequence (?(%c... not terminated",
                            (ch == '>' ? '<' : ch));
                    }
                    RExC_parse++;
	            if (!SIZE_ONLY) {
                        num = add_data( pRExC_state, STR_WITH_LEN("S"));
                        RExC_rxi->data->data[num]=(void*)sv_dat;
                        SvREFCNT_inc_simple_void(sv_dat);
                    }
                    ret = reganode(pRExC_state,NGROUPP,num);
                    goto insert_if_check_paren;
		}
		else if (RExC_end - RExC_parse >= DEFINE_len
                        && strnEQ(RExC_parse, "DEFINE", DEFINE_len))
                {
		    ret = reganode(pRExC_state,DEFINEP,0);
		    RExC_parse += DEFINE_len;
		    is_define = 1;
		    goto insert_if_check_paren;
		}
		else if (RExC_parse[0] == 'R') {
		    RExC_parse++;
                    /* parno == 0 => /(?(R)YES|NO)/  "in any form of recursion OR eval"
                     * parno == 1 => /(?(R0)YES|NO)/ "in GOSUB (?0) / (?R)"
                     * parno == 2 => /(?(R1)YES|NO)/ "in GOSUB (?1) (parno-1)"
                     */
		    parno = 0;
                    if (RExC_parse[0] == '0') {
                        parno = 1;
                        RExC_parse++;
                    }
                    else if (RExC_parse[0] >= '1' && RExC_parse[0] <= '9' ) {
                        UV uv;
                        if (grok_atoUV(RExC_parse, &uv, &endptr)
                            && uv <= I32_MAX
                        ) {
                            parno = (I32)uv + 1;
                            RExC_parse = (char*)endptr;
                        }
                        /* else "Switch condition not recognized" below */
		    } else if (RExC_parse[0] == '&') {
		        SV *sv_dat;
		        RExC_parse++;
		        sv_dat = reg_scan_name(pRExC_state,
                            SIZE_ONLY
                            ? REG_RSN_RETURN_NULL
                            : REG_RSN_RETURN_DATA);

                        /* we should only have a false sv_dat when
                         * SIZE_ONLY is true, and we always have false
                         * sv_dat when SIZE_ONLY is true.
                         * reg_scan_name() will VFAIL() if the name is
                         * unknown when SIZE_ONLY is false, and otherwise
                         * will return something, and when SIZE_ONLY is
                         * true, reg_scan_name() just parses the string,
                         * and doesnt return anything. (in theory) */
                        assert(SIZE_ONLY ? !sv_dat : !!sv_dat);

                        if (sv_dat)
                            parno = 1 + *((I32 *)SvPVX(sv_dat));
		    }
		    ret = reganode(pRExC_state,INSUBP,parno);
		    goto insert_if_check_paren;
		}
		else if (RExC_parse[0] >= '1' && RExC_parse[0] <= '9' ) {
                    /* (?(1)...) */
		    char c;
                    UV uv;
                    if (grok_atoUV(RExC_parse, &uv, &endptr)
                        && uv <= I32_MAX
                    ) {
                        parno = (I32)uv;
                        RExC_parse = (char*)endptr;
                    }
                    else {
                        vFAIL("panic: grok_atoUV returned FALSE");
                    }
                    ret = reganode(pRExC_state, GROUPP, parno);

                 insert_if_check_paren:
		    if (UCHARAT(RExC_parse) != ')') {
                        RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;
			vFAIL("Switch condition not recognized");
		    }
		    nextchar(pRExC_state);
		  insert_if:
                    REGTAIL(pRExC_state, ret, reganode(pRExC_state, IFTHEN, 0));
                    br = regbranch(pRExC_state, &flags, 1,depth+1);
		    if (br == NULL) {
                        if (flags & (RESTART_PASS1|NEED_UTF8)) {
                            *flagp = flags & (RESTART_PASS1|NEED_UTF8);
                            return NULL;
                        }
                        FAIL2("panic: regbranch returned NULL, flags=%#"UVxf"",
                              (UV) flags);
                    } else
                        REGTAIL(pRExC_state, br, reganode(pRExC_state,
                                                          LONGJMP, 0));
		    c = UCHARAT(RExC_parse);
                    nextchar(pRExC_state);
		    if (flags&HASWIDTH)
			*flagp |= HASWIDTH;
		    if (c == '|') {
		        if (is_define)
		            vFAIL("(?(DEFINE)....) does not allow branches");

                        /* Fake one for optimizer.  */
                        lastbr = reganode(pRExC_state, IFTHEN, 0);

                        if (!regbranch(pRExC_state, &flags, 1,depth+1)) {
                            if (flags & (RESTART_PASS1|NEED_UTF8)) {
                                *flagp = flags & (RESTART_PASS1|NEED_UTF8);
                                return NULL;
                            }
                            FAIL2("panic: regbranch returned NULL, flags=%#"UVxf"",
                                  (UV) flags);
                        }
                        REGTAIL(pRExC_state, ret, lastbr);
		 	if (flags&HASWIDTH)
			    *flagp |= HASWIDTH;
                        c = UCHARAT(RExC_parse);
                        nextchar(pRExC_state);
		    }
		    else
			lastbr = NULL;
                    if (c != ')') {
                        if (RExC_parse >= RExC_end)
                            vFAIL("Switch (?(condition)... not terminated");
                        else
                            vFAIL("Switch (?(condition)... contains too many branches");
                    }
		    ender = reg_node(pRExC_state, TAIL);
                    REGTAIL(pRExC_state, br, ender);
		    if (lastbr) {
                        REGTAIL(pRExC_state, lastbr, ender);
                        REGTAIL(pRExC_state, NEXTOPER(NEXTOPER(lastbr)), ender);
		    }
		    else
                        REGTAIL(pRExC_state, ret, ender);
                    RExC_size++; /* XXX WHY do we need this?!!
                                    For large programs it seems to be required
                                    but I can't figure out why. -- dmq*/
		    return ret;
		}
                RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;
                vFAIL("Unknown switch condition (?(...))");
	    }
	    case '[':           /* (?[ ... ]) */
                return handle_regex_sets(pRExC_state, NULL, flagp, depth,
                                         oregcomp_parse);
            case 0: /* A NUL */
		RExC_parse--; /* for vFAIL to print correctly */
                vFAIL("Sequence (? incomplete");
                break;
	    default: /* e.g., (?i) */
	        RExC_parse = (char *) seqstart + 1;
              parse_flags:
		parse_lparen_question_flags(pRExC_state);
                if (UCHARAT(RExC_parse) != ':') {
                    if (RExC_parse < RExC_end)
                        nextchar(pRExC_state);
                    *flagp = TRYAGAIN;
                    return NULL;
                }
                paren = ':';
                nextchar(pRExC_state);
                ret = NULL;
                goto parse_rest;
            } /* end switch */
	}
	else if (!(RExC_flags & RXf_PMf_NOCAPTURE)) {   /* (...) */
	  capturing_parens:
	    parno = RExC_npar;
	    RExC_npar++;

	    ret = reganode(pRExC_state, OPEN, parno);
	    if (!SIZE_ONLY ){
	        if (!RExC_nestroot)
	            RExC_nestroot = parno;
                if (RExC_open_parens && !RExC_open_parens[parno])
	        {
                    DEBUG_OPTIMISE_MORE_r(Perl_re_printf( aTHX_
                        "%*s%*s Setting open paren #%"IVdf" to %d\n",
                        22, "|    |", (int)(depth * 2 + 1), "",
			(IV)parno, REG_NODE_NUM(ret)));
                    RExC_open_parens[parno]= ret;
	        }
	    }
            Set_Node_Length(ret, 1); /* MJD */
            Set_Node_Offset(ret, RExC_parse); /* MJD */
	    is_open = 1;
	} else {
            /* with RXf_PMf_NOCAPTURE treat (...) as (?:...) */
            paren = ':';
	    ret = NULL;
	}
    }
    else                        /* ! paren */
	ret = NULL;

   parse_rest:
    /* Pick up the branches, linking them together. */
    parse_start = RExC_parse;   /* MJD */
    br = regbranch(pRExC_state, &flags, 1,depth+1);

    /*     branch_len = (paren != 0); */

    if (br == NULL) {
        if (flags & (RESTART_PASS1|NEED_UTF8)) {
            *flagp = flags & (RESTART_PASS1|NEED_UTF8);
            return NULL;
        }
        FAIL2("panic: regbranch returned NULL, flags=%#"UVxf"", (UV) flags);
    }
    if (*RExC_parse == '|') {
	if (!SIZE_ONLY && RExC_extralen) {
	    reginsert(pRExC_state, BRANCHJ, br, depth+1);
	}
	else {                  /* MJD */
	    reginsert(pRExC_state, BRANCH, br, depth+1);
            Set_Node_Length(br, paren != 0);
            Set_Node_Offset_To_R(br-RExC_emit_start, parse_start-RExC_start);
        }
	have_branch = 1;
	if (SIZE_ONLY)
	    RExC_extralen += 1;		/* For BRANCHJ-BRANCH. */
    }
    else if (paren == ':') {
	*flagp |= flags&SIMPLE;
    }
    if (is_open) {				/* Starts with OPEN. */
        REGTAIL(pRExC_state, ret, br);          /* OPEN -> first. */
    }
    else if (paren != '?')		/* Not Conditional */
	ret = br;
    *flagp |= flags & (SPSTART | HASWIDTH | POSTPONED);
    lastbr = br;
    while (*RExC_parse == '|') {
	if (!SIZE_ONLY && RExC_extralen) {
	    ender = reganode(pRExC_state, LONGJMP,0);

            /* Append to the previous. */
            REGTAIL(pRExC_state, NEXTOPER(NEXTOPER(lastbr)), ender);
	}
	if (SIZE_ONLY)
	    RExC_extralen += 2;		/* Account for LONGJMP. */
	nextchar(pRExC_state);
	if (freeze_paren) {
	    if (RExC_npar > after_freeze)
	        after_freeze = RExC_npar;
            RExC_npar = freeze_paren;
        }
        br = regbranch(pRExC_state, &flags, 0, depth+1);

	if (br == NULL) {
            if (flags & (RESTART_PASS1|NEED_UTF8)) {
                *flagp = flags & (RESTART_PASS1|NEED_UTF8);
                return NULL;
            }
            FAIL2("panic: regbranch returned NULL, flags=%#"UVxf"", (UV) flags);
        }
        REGTAIL(pRExC_state, lastbr, br);               /* BRANCH -> BRANCH. */
	lastbr = br;
	*flagp |= flags & (SPSTART | HASWIDTH | POSTPONED);
    }

    if (have_branch || paren != ':') {
	/* Make a closing node, and hook it on the end. */
	switch (paren) {
	case ':':
	    ender = reg_node(pRExC_state, TAIL);
	    break;
	case 1: case 2:
	    ender = reganode(pRExC_state, CLOSE, parno);
            if ( RExC_close_parens ) {
                DEBUG_OPTIMISE_MORE_r(Perl_re_printf( aTHX_
                        "%*s%*s Setting close paren #%"IVdf" to %d\n",
                        22, "|    |", (int)(depth * 2 + 1), "", (IV)parno, REG_NODE_NUM(ender)));
                RExC_close_parens[parno]= ender;
	        if (RExC_nestroot == parno)
	            RExC_nestroot = 0;
	    }
            Set_Node_Offset(ender,RExC_parse+1); /* MJD */
            Set_Node_Length(ender,1); /* MJD */
	    break;
	case '<':
	case ',':
	case '=':
	case '!':
	    *flagp &= ~HASWIDTH;
	    /* FALLTHROUGH */
	case '>':
	    ender = reg_node(pRExC_state, SUCCEED);
	    break;
	case 0:
	    ender = reg_node(pRExC_state, END);
	    if (!SIZE_ONLY) {
                assert(!RExC_end_op); /* there can only be one! */
                RExC_end_op = ender;
                if (RExC_close_parens) {
                    DEBUG_OPTIMISE_MORE_r(Perl_re_printf( aTHX_
                        "%*s%*s Setting close paren #0 (END) to %d\n",
                        22, "|    |", (int)(depth * 2 + 1), "", REG_NODE_NUM(ender)));

                    RExC_close_parens[0]= ender;
                }
            }
	    break;
	}
        DEBUG_PARSE_r(if (!SIZE_ONLY) {
            DEBUG_PARSE_MSG("lsbr");
            regprop(RExC_rx, RExC_mysv1, lastbr, NULL, pRExC_state);
            regprop(RExC_rx, RExC_mysv2, ender, NULL, pRExC_state);
            Perl_re_printf( aTHX_  "~ tying lastbr %s (%"IVdf") to ender %s (%"IVdf") offset %"IVdf"\n",
                          SvPV_nolen_const(RExC_mysv1),
                          (IV)REG_NODE_NUM(lastbr),
                          SvPV_nolen_const(RExC_mysv2),
                          (IV)REG_NODE_NUM(ender),
                          (IV)(ender - lastbr)
            );
        });
        REGTAIL(pRExC_state, lastbr, ender);

	if (have_branch && !SIZE_ONLY) {
            char is_nothing= 1;
	    if (depth==1)
                RExC_seen |= REG_TOP_LEVEL_BRANCHES_SEEN;

	    /* Hook the tails of the branches to the closing node. */
	    for (br = ret; br; br = regnext(br)) {
		const U8 op = PL_regkind[OP(br)];
		if (op == BRANCH) {
                    REGTAIL_STUDY(pRExC_state, NEXTOPER(br), ender);
                    if ( OP(NEXTOPER(br)) != NOTHING
                         || regnext(NEXTOPER(br)) != ender)
                        is_nothing= 0;
		}
		else if (op == BRANCHJ) {
                    REGTAIL_STUDY(pRExC_state, NEXTOPER(NEXTOPER(br)), ender);
                    /* for now we always disable this optimisation * /
                    if ( OP(NEXTOPER(NEXTOPER(br))) != NOTHING
                         || regnext(NEXTOPER(NEXTOPER(br))) != ender)
                    */
                        is_nothing= 0;
		}
	    }
            if (is_nothing) {
                br= PL_regkind[OP(ret)] != BRANCH ? regnext(ret) : ret;
                DEBUG_PARSE_r(if (!SIZE_ONLY) {
                    DEBUG_PARSE_MSG("NADA");
                    regprop(RExC_rx, RExC_mysv1, ret, NULL, pRExC_state);
                    regprop(RExC_rx, RExC_mysv2, ender, NULL, pRExC_state);
                    Perl_re_printf( aTHX_  "~ converting ret %s (%"IVdf") to ender %s (%"IVdf") offset %"IVdf"\n",
                                  SvPV_nolen_const(RExC_mysv1),
                                  (IV)REG_NODE_NUM(ret),
                                  SvPV_nolen_const(RExC_mysv2),
                                  (IV)REG_NODE_NUM(ender),
                                  (IV)(ender - ret)
                    );
                });
                OP(br)= NOTHING;
                if (OP(ender) == TAIL) {
                    NEXT_OFF(br)= 0;
                    RExC_emit= br + 1;
                } else {
                    regnode *opt;
                    for ( opt= br + 1; opt < ender ; opt++ )
                        OP(opt)= OPTIMIZED;
                    NEXT_OFF(br)= ender - br;
                }
            }
	}
    }

    {
        const char *p;
        static const char parens[] = "=!<,>";

	if (paren && (p = strchr(parens, paren))) {
	    U8 node = ((p - parens) % 2) ? UNLESSM : IFMATCH;
	    int flag = (p - parens) > 1;

	    if (paren == '>')
		node = SUSPEND, flag = 0;
	    reginsert(pRExC_state, node,ret, depth+1);
            Set_Node_Cur_Length(ret, parse_start);
	    Set_Node_Offset(ret, parse_start + 1);
	    ret->flags = flag;
            REGTAIL_STUDY(pRExC_state, ret, reg_node(pRExC_state, TAIL));
	}
    }

    /* Check for proper termination. */
    if (paren) {
        /* restore original flags, but keep (?p) and, if we've changed from /d
         * rules to /u, keep the /u */
	RExC_flags = oregflags | (RExC_flags & RXf_PMf_KEEPCOPY);
        if (DEPENDS_SEMANTICS && RExC_uni_semantics) {
            set_regex_charset(&RExC_flags, REGEX_UNICODE_CHARSET);
        }
	if (RExC_parse >= RExC_end || UCHARAT(RExC_parse) != ')') {
	    RExC_parse = oregcomp_parse;
	    vFAIL("Unmatched (");
	}
	nextchar(pRExC_state);
    }
    else if (!paren && RExC_parse < RExC_end) {
	if (*RExC_parse == ')') {
	    RExC_parse++;
	    vFAIL("Unmatched )");
	}
	else
	    FAIL("Junk on end of regexp");	/* "Can't happen". */
	NOT_REACHED; /* NOTREACHED */
    }

    if (RExC_in_lookbehind) {
	RExC_in_lookbehind--;
    }
    if (after_freeze > RExC_npar)
        RExC_npar = after_freeze;
    return(ret);
}

/*
 - regbranch - one alternative of an | operator
 *
 * Implements the concatenation operator.
 *
 * Returns NULL, setting *flagp to RESTART_PASS1 if the sizing scan needs to be
 * restarted, or'd with NEED_UTF8 if the pattern needs to be upgraded to UTF-8
 */
STATIC regnode *
S_regbranch(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, I32 first, U32 depth)
{
    regnode *ret;
    regnode *chain = NULL;
    regnode *latest;
    I32 flags = 0, c = 0;
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_REGBRANCH;

    DEBUG_PARSE("brnc");

    if (first)
	ret = NULL;
    else {
	if (!SIZE_ONLY && RExC_extralen)
	    ret = reganode(pRExC_state, BRANCHJ,0);
	else {
	    ret = reg_node(pRExC_state, BRANCH);
            Set_Node_Length(ret, 1);
        }
    }

    if (!first && SIZE_ONLY)
	RExC_extralen += 1;			/* BRANCHJ */

    *flagp = WORST;			/* Tentatively. */

    skip_to_be_ignored_text(pRExC_state, &RExC_parse,
                            FALSE /* Don't force to /x */ );
    while (RExC_parse < RExC_end && *RExC_parse != '|' && *RExC_parse != ')') {
	flags &= ~TRYAGAIN;
        latest = regpiece(pRExC_state, &flags,depth+1);
	if (latest == NULL) {
	    if (flags & TRYAGAIN)
		continue;
            if (flags & (RESTART_PASS1|NEED_UTF8)) {
                *flagp = flags & (RESTART_PASS1|NEED_UTF8);
                return NULL;
            }
            FAIL2("panic: regpiece returned NULL, flags=%#"UVxf"", (UV) flags);
	}
	else if (ret == NULL)
	    ret = latest;
	*flagp |= flags&(HASWIDTH|POSTPONED);
	if (chain == NULL) 	/* First piece. */
	    *flagp |= flags&SPSTART;
	else {
	    /* FIXME adding one for every branch after the first is probably
	     * excessive now we have TRIE support. (hv) */
	    MARK_NAUGHTY(1);
            REGTAIL(pRExC_state, chain, latest);
	}
	chain = latest;
	c++;
    }
    if (chain == NULL) {	/* Loop ran zero times. */
	chain = reg_node(pRExC_state, NOTHING);
	if (ret == NULL)
	    ret = chain;
    }
    if (c == 1) {
	*flagp |= flags&SIMPLE;
    }

    return ret;
}

/*
 - regpiece - something followed by possible [*+?]
 *
 * Note that the branching code sequences used for ? and the general cases
 * of * and + are somewhat optimized:  they use the same NOTHING node as
 * both the endmarker for their branch list and the body of the last branch.
 * It might seem that this node could be dispensed with entirely, but the
 * endmarker role is not redundant.
 *
 * Returns NULL, setting *flagp to TRYAGAIN if regatom() returns NULL with
 * TRYAGAIN.
 * Returns NULL, setting *flagp to RESTART_PASS1 if the sizing scan needs to be
 * restarted, or'd with NEED_UTF8 if the pattern needs to be upgraded to UTF-8
 */
STATIC regnode *
S_regpiece(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, U32 depth)
{
    regnode *ret;
    char op;
    char *next;
    I32 flags;
    const char * const origparse = RExC_parse;
    I32 min;
    I32 max = REG_INFTY;
#ifdef RE_TRACK_PATTERN_OFFSETS
    char *parse_start;
#endif
    const char *maxpos = NULL;
    UV uv;

    /* Save the original in case we change the emitted regop to a FAIL. */
    regnode * const orig_emit = RExC_emit;

    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_REGPIECE;

    DEBUG_PARSE("piec");

    ret = regatom(pRExC_state, &flags,depth+1);
    if (ret == NULL) {
	if (flags & (TRYAGAIN|RESTART_PASS1|NEED_UTF8))
	    *flagp |= flags & (TRYAGAIN|RESTART_PASS1|NEED_UTF8);
        else
            FAIL2("panic: regatom returned NULL, flags=%#"UVxf"", (UV) flags);
	return(NULL);
    }

    op = *RExC_parse;

    if (op == '{' && regcurly(RExC_parse)) {
	maxpos = NULL;
#ifdef RE_TRACK_PATTERN_OFFSETS
        parse_start = RExC_parse; /* MJD */
#endif
	next = RExC_parse + 1;
	while (isDIGIT(*next) || *next == ',') {
	    if (*next == ',') {
		if (maxpos)
		    break;
		else
		    maxpos = next;
	    }
	    next++;
	}
	if (*next == '}') {		/* got one */
            const char* endptr;
	    if (!maxpos)
		maxpos = next;
	    RExC_parse++;
            if (isDIGIT(*RExC_parse)) {
                if (!grok_atoUV(RExC_parse, &uv, &endptr))
                    vFAIL("Invalid quantifier in {,}");
                if (uv >= REG_INFTY)
                    vFAIL2("Quantifier in {,} bigger than %d", REG_INFTY - 1);
                min = (I32)uv;
            } else {
                min = 0;
            }
	    if (*maxpos == ',')
		maxpos++;
	    else
		maxpos = RExC_parse;
            if (isDIGIT(*maxpos)) {
                if (!grok_atoUV(maxpos, &uv, &endptr))
                    vFAIL("Invalid quantifier in {,}");
                if (uv >= REG_INFTY)
                    vFAIL2("Quantifier in {,} bigger than %d", REG_INFTY - 1);
                max = (I32)uv;
            } else {
		max = REG_INFTY;		/* meaning "infinity" */
            }
	    RExC_parse = next;
	    nextchar(pRExC_state);
            if (max < min) {    /* If can't match, warn and optimize to fail
                                   unconditionally */
                if (SIZE_ONLY) {

                    /* We can't back off the size because we have to reserve
                     * enough space for all the things we are about to throw
                     * away, but we can shrink it by the amount we are about
                     * to re-use here */
                    RExC_size += PREVOPER(RExC_size) - regarglen[(U8)OPFAIL];
                }
                else {
                    ckWARNreg(RExC_parse, "Quantifier {n,m} with n > m can't match");
                    RExC_emit = orig_emit;
                }
                ret = reganode(pRExC_state, OPFAIL, 0);
                return ret;
            }
            else if (min == max && *RExC_parse == '?')
            {
                if (PASS2) {
                    ckWARN2reg(RExC_parse + 1,
                               "Useless use of greediness modifier '%c'",
                               *RExC_parse);
                }
            }

	  do_curly:
	    if ((flags&SIMPLE)) {
                if (min == 0 && max == REG_INFTY) {
                    reginsert(pRExC_state, STAR, ret, depth+1);
                    ret->flags = 0;
                    MARK_NAUGHTY(4);
                    RExC_seen |= REG_UNBOUNDED_QUANTIFIER_SEEN;
                    goto nest_check;
                }
                if (min == 1 && max == REG_INFTY) {
                    reginsert(pRExC_state, PLUS, ret, depth+1);
                    ret->flags = 0;
                    MARK_NAUGHTY(3);
                    RExC_seen |= REG_UNBOUNDED_QUANTIFIER_SEEN;
                    goto nest_check;
                }
                MARK_NAUGHTY_EXP(2, 2);
		reginsert(pRExC_state, CURLY, ret, depth+1);
                Set_Node_Offset(ret, parse_start+1); /* MJD */
                Set_Node_Cur_Length(ret, parse_start);
	    }
	    else {
		regnode * const w = reg_node(pRExC_state, WHILEM);

		w->flags = 0;
                REGTAIL(pRExC_state, ret, w);
		if (!SIZE_ONLY && RExC_extralen) {
		    reginsert(pRExC_state, LONGJMP,ret, depth+1);
		    reginsert(pRExC_state, NOTHING,ret, depth+1);
		    NEXT_OFF(ret) = 3;	/* Go over LONGJMP. */
		}
		reginsert(pRExC_state, CURLYX,ret, depth+1);
                                /* MJD hk */
                Set_Node_Offset(ret, parse_start+1);
                Set_Node_Length(ret,
                                op == '{' ? (RExC_parse - parse_start) : 1);

		if (!SIZE_ONLY && RExC_extralen)
		    NEXT_OFF(ret) = 3;	/* Go over NOTHING to LONGJMP. */
                REGTAIL(pRExC_state, ret, reg_node(pRExC_state, NOTHING));
		if (SIZE_ONLY)
		    RExC_whilem_seen++, RExC_extralen += 3;
                MARK_NAUGHTY_EXP(1, 4);     /* compound interest */
	    }
	    ret->flags = 0;

	    if (min > 0)
		*flagp = WORST;
	    if (max > 0)
		*flagp |= HASWIDTH;
	    if (!SIZE_ONLY) {
		ARG1_SET(ret, (U16)min);
		ARG2_SET(ret, (U16)max);
	    }
            if (max == REG_INFTY)
                RExC_seen |= REG_UNBOUNDED_QUANTIFIER_SEEN;

	    goto nest_check;
	}
    }

    if (!ISMULT1(op)) {
	*flagp = flags;
	return(ret);
    }

#if 0				/* Now runtime fix should be reliable. */

    /* if this is reinstated, don't forget to put this back into perldiag:

	    =item Regexp *+ operand could be empty at {#} in regex m/%s/

	   (F) The part of the regexp subject to either the * or + quantifier
           could match an empty string. The {#} shows in the regular
           expression about where the problem was discovered.

    */

    if (!(flags&HASWIDTH) && op != '?')
      vFAIL("Regexp *+ operand could be empty");
#endif

#ifdef RE_TRACK_PATTERN_OFFSETS
    parse_start = RExC_parse;
#endif
    nextchar(pRExC_state);

    *flagp = (op != '+') ? (WORST|SPSTART|HASWIDTH) : (WORST|HASWIDTH);

    if (op == '*') {
	min = 0;
	goto do_curly;
    }
    else if (op == '+') {
	min = 1;
	goto do_curly;
    }
    else if (op == '?') {
	min = 0; max = 1;
	goto do_curly;
    }
  nest_check:
    if (!SIZE_ONLY && !(flags&(HASWIDTH|POSTPONED)) && max > REG_INFTY/3) {
	SAVEFREESV(RExC_rx_sv); /* in case of fatal warnings */
	ckWARN2reg(RExC_parse,
		   "%"UTF8f" matches null string many times",
		   UTF8fARG(UTF, (RExC_parse >= origparse
                                 ? RExC_parse - origparse
                                 : 0),
		   origparse));
	(void)ReREFCNT_inc(RExC_rx_sv);
    }

    if (*RExC_parse == '?') {
	nextchar(pRExC_state);
	reginsert(pRExC_state, MINMOD, ret, depth+1);
        REGTAIL(pRExC_state, ret, ret + NODE_STEP_REGNODE);
    }
    else if (*RExC_parse == '+') {
        regnode *ender;
        nextchar(pRExC_state);
        ender = reg_node(pRExC_state, SUCCEED);
        REGTAIL(pRExC_state, ret, ender);
        reginsert(pRExC_state, SUSPEND, ret, depth+1);
        ret->flags = 0;
        ender = reg_node(pRExC_state, TAIL);
        REGTAIL(pRExC_state, ret, ender);
    }

    if (ISMULT2(RExC_parse)) {
	RExC_parse++;
	vFAIL("Nested quantifiers");
    }

    return(ret);
}

STATIC bool
S_grok_bslash_N(pTHX_ RExC_state_t *pRExC_state,
                regnode ** node_p,
                UV * code_point_p,
                int * cp_count,
                I32 * flagp,
                const bool strict,
                const U32 depth
    )
{
 /* This routine teases apart the various meanings of \N and returns
  * accordingly.  The input parameters constrain which meaning(s) is/are valid
  * in the current context.
  *
  * Exactly one of <node_p> and <code_point_p> must be non-NULL.
  *
  * If <code_point_p> is not NULL, the context is expecting the result to be a
  * single code point.  If this \N instance turns out to a single code point,
  * the function returns TRUE and sets *code_point_p to that code point.
  *
  * If <node_p> is not NULL, the context is expecting the result to be one of
  * the things representable by a regnode.  If this \N instance turns out to be
  * one such, the function generates the regnode, returns TRUE and sets *node_p
  * to point to that regnode.
  *
  * If this instance of \N isn't legal in any context, this function will
  * generate a fatal error and not return.
  *
  * On input, RExC_parse should point to the first char following the \N at the
  * time of the call.  On successful return, RExC_parse will have been updated
  * to point to just after the sequence identified by this routine.  Also
  * *flagp has been updated as needed.
  *
  * When there is some problem with the current context and this \N instance,
  * the function returns FALSE, without advancing RExC_parse, nor setting
  * *node_p, nor *code_point_p, nor *flagp.
  *
  * If <cp_count> is not NULL, the caller wants to know the length (in code
  * points) that this \N sequence matches.  This is set even if the function
  * returns FALSE, as detailed below.
  *
  * There are 5 possibilities here, as detailed in the next 5 paragraphs.
  *
  * Probably the most common case is for the \N to specify a single code point.
  * *cp_count will be set to 1, and *code_point_p will be set to that code
  * point.
  *
  * Another possibility is for the input to be an empty \N{}, which for
  * backwards compatibility we accept.  *cp_count will be set to 0. *node_p
  * will be set to a generated NOTHING node.
  *
  * Still another possibility is for the \N to mean [^\n]. *cp_count will be
  * set to 0. *node_p will be set to a generated REG_ANY node.
  *
  * The fourth possibility is that \N resolves to a sequence of more than one
  * code points.  *cp_count will be set to the number of code points in the
  * sequence. *node_p * will be set to a generated node returned by this
  * function calling S_reg().
  *
  * The final possibility is that it is premature to be calling this function;
  * that pass1 needs to be restarted.  This can happen when this changes from
  * /d to /u rules, or when the pattern needs to be upgraded to UTF-8.  The
  * latter occurs only when the fourth possibility would otherwise be in
  * effect, and is because one of those code points requires the pattern to be
  * recompiled as UTF-8.  The function returns FALSE, and sets the
  * RESTART_PASS1 and NEED_UTF8 flags in *flagp, as appropriate.  When this
  * happens, the caller needs to desist from continuing parsing, and return
  * this information to its caller.  This is not set for when there is only one
  * code point, as this can be called as part of an ANYOF node, and they can
  * store above-Latin1 code points without the pattern having to be in UTF-8.
  *
  * For non-single-quoted regexes, the tokenizer has resolved character and
  * sequence names inside \N{...} into their Unicode values, normalizing the
  * result into what we should see here: '\N{U+c1.c2...}', where c1... are the
  * hex-represented code points in the sequence.  This is done there because
  * the names can vary based on what charnames pragma is in scope at the time,
  * so we need a way to take a snapshot of what they resolve to at the time of
  * the original parse. [perl #56444].
  *
  * That parsing is skipped for single-quoted regexes, so we may here get
  * '\N{NAME}'.  This is a fatal error.  These names have to be resolved by the
  * parser.  But if the single-quoted regex is something like '\N{U+41}', that
  * is legal and handled here.  The code point is Unicode, and has to be
  * translated into the native character set for non-ASCII platforms.
  */

    char * endbrace;    /* points to '}' following the name */
    char *endchar;	/* Points to '.' or '}' ending cur char in the input
                           stream */
    char* p = RExC_parse; /* Temporary */

    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_GROK_BSLASH_N;

    GET_RE_DEBUG_FLAGS;

    assert(cBOOL(node_p) ^ cBOOL(code_point_p));  /* Exactly one should be set */
    assert(! (node_p && cp_count));               /* At most 1 should be set */

    if (cp_count) {     /* Initialize return for the most common case */
        *cp_count = 1;
    }

    /* The [^\n] meaning of \N ignores spaces and comments under the /x
     * modifier.  The other meanings do not, so use a temporary until we find
     * out which we are being called with */
    skip_to_be_ignored_text(pRExC_state, &p,
                            FALSE /* Don't force to /x */ );

    /* Disambiguate between \N meaning a named character versus \N meaning
     * [^\n].  The latter is assumed when the {...} following the \N is a legal
     * quantifier, or there is no '{' at all */
    if (*p != '{' || regcurly(p)) {
	RExC_parse = p;
        if (cp_count) {
            *cp_count = -1;
        }

	if (! node_p) {
            return FALSE;
        }

	*node_p = reg_node(pRExC_state, REG_ANY);
	*flagp |= HASWIDTH|SIMPLE;
	MARK_NAUGHTY(1);
        Set_Node_Length(*node_p, 1); /* MJD */
	return TRUE;
    }

    /* Here, we have decided it should be a named character or sequence */

    /* The test above made sure that the next real character is a '{', but
     * under the /x modifier, it could be separated by space (or a comment and
     * \n) and this is not allowed (for consistency with \x{...} and the
     * tokenizer handling of \N{NAME}). */
    if (*RExC_parse != '{') {
	vFAIL("Missing braces on \\N{}");
    }

    RExC_parse++;	/* Skip past the '{' */

    if (! (endbrace = strchr(RExC_parse, '}'))  /* no trailing brace */
	|| ! (endbrace == RExC_parse		/* nothing between the {} */
              || (endbrace - RExC_parse >= 2	/* U+ (bad hex is checked... */
                  && strnEQ(RExC_parse, "U+", 2)))) /* ... below for a better
                                                       error msg) */
    {
	if (endbrace) RExC_parse = endbrace;	/* position msg's '<--HERE' */
	vFAIL("\\N{NAME} must be resolved by the lexer");
    }

    REQUIRE_UNI_RULES(flagp, FALSE); /* Unicode named chars imply Unicode
                                        semantics */

    if (endbrace == RExC_parse) {   /* empty: \N{} */
        if (strict) {
            RExC_parse++;   /* Position after the "}" */
            vFAIL("Zero length \\N{}");
        }
        if (cp_count) {
            *cp_count = 0;
        }
        nextchar(pRExC_state);
	if (! node_p) {
            return FALSE;
        }

        *node_p = reg_node(pRExC_state,NOTHING);
        return TRUE;
    }

    RExC_parse += 2;	/* Skip past the 'U+' */

    /* Because toke.c has generated a special construct for us guaranteed not
     * to have NULs, we can use a str function */
    endchar = RExC_parse + strcspn(RExC_parse, ".}");

    /* Code points are separated by dots.  If none, there is only one code
     * point, and is terminated by the brace */

    if (endchar >= endbrace) {
	STRLEN length_of_hex;
	I32 grok_hex_flags;

        /* Here, exactly one code point.  If that isn't what is wanted, fail */
        if (! code_point_p) {
            RExC_parse = p;
            return FALSE;
        }

        /* Convert code point from hex */
	length_of_hex = (STRLEN)(endchar - RExC_parse);
	grok_hex_flags = PERL_SCAN_ALLOW_UNDERSCORES
                           | PERL_SCAN_DISALLOW_PREFIX

                             /* No errors in the first pass (See [perl
                              * #122671].)  We let the code below find the
                              * errors when there are multiple chars. */
                           | ((SIZE_ONLY)
                              ? PERL_SCAN_SILENT_ILLDIGIT
                              : 0);

        /* This routine is the one place where both single- and double-quotish
         * \N{U+xxxx} are evaluated.  The value is a Unicode code point which
         * must be converted to native. */
	*code_point_p = UNI_TO_NATIVE(grok_hex(RExC_parse,
                                         &length_of_hex,
                                         &grok_hex_flags,
                                         NULL));

	/* The tokenizer should have guaranteed validity, but it's possible to
         * bypass it by using single quoting, so check.  Don't do the check
         * here when there are multiple chars; we do it below anyway. */
        if (length_of_hex == 0
            || length_of_hex != (STRLEN)(endchar - RExC_parse) )
        {
            RExC_parse += length_of_hex;	/* Includes all the valid */
            RExC_parse += (RExC_orig_utf8)	/* point to after 1st invalid */
                            ? UTF8SKIP(RExC_parse)
                            : 1;
            /* Guard against malformed utf8 */
            if (RExC_parse >= endchar) {
                RExC_parse = endchar;
            }
            vFAIL("Invalid hexadecimal number in \\N{U+...}");
        }

        RExC_parse = endbrace + 1;
        return TRUE;
    }
    else {  /* Is a multiple character sequence */
	SV * substitute_parse;
	STRLEN len;
	char *orig_end = RExC_end;
	char *save_start = RExC_start;
        I32 flags;

        /* Count the code points, if desired, in the sequence */
        if (cp_count) {
            *cp_count = 0;
            while (RExC_parse < endbrace) {
                /* Point to the beginning of the next character in the sequence. */
                RExC_parse = endchar + 1;
                endchar = RExC_parse + strcspn(RExC_parse, ".}");
                (*cp_count)++;
            }
        }

        /* Fail if caller doesn't want to handle a multi-code-point sequence.
         * But don't backup up the pointer if the caller want to know how many
         * code points there are (they can then handle things) */
        if (! node_p) {
            if (! cp_count) {
                RExC_parse = p;
            }
            return FALSE;
        }

	/* What is done here is to convert this to a sub-pattern of the form
         * \x{char1}\x{char2}...  and then call reg recursively to parse it
         * (enclosing in "(?: ... )" ).  That way, it retains its atomicness,
         * while not having to worry about special handling that some code
         * points may have. */

	substitute_parse = newSVpvs("?:");

	while (RExC_parse < endbrace) {

	    /* Convert to notation the rest of the code understands */
	    sv_catpv(substitute_parse, "\\x{");
	    sv_catpvn(substitute_parse, RExC_parse, endchar - RExC_parse);
	    sv_catpv(substitute_parse, "}");

	    /* Point to the beginning of the next character in the sequence. */
	    RExC_parse = endchar + 1;
	    endchar = RExC_parse + strcspn(RExC_parse, ".}");

	}
        sv_catpv(substitute_parse, ")");

        RExC_parse = RExC_start = RExC_adjusted_start = SvPV(substitute_parse,
                                                             len);

	/* Don't allow empty number */
	if (len < (STRLEN) 8) {
            RExC_parse = endbrace;
	    vFAIL("Invalid hexadecimal number in \\N{U+...}");
	}
	RExC_end = RExC_parse + len;

        /* The values are Unicode, and therefore not subject to recoding, but
         * have to be converted to native on a non-Unicode (meaning non-ASCII)
         * platform. */
	RExC_override_recoding = 1;
#ifdef EBCDIC
        RExC_recode_x_to_native = 1;
#endif

        if (node_p) {
            if (!(*node_p = reg(pRExC_state, 1, &flags, depth+1))) {
                if (flags & (RESTART_PASS1|NEED_UTF8)) {
                    *flagp = flags & (RESTART_PASS1|NEED_UTF8);
                    return FALSE;
                }
                FAIL2("panic: reg returned NULL to grok_bslash_N, flags=%#"UVxf"",
                    (UV) flags);
            }
            *flagp |= flags&(HASWIDTH|SPSTART|SIMPLE|POSTPONED);
        }

        /* Restore the saved values */
	RExC_start = RExC_adjusted_start = save_start;
	RExC_parse = endbrace;
	RExC_end = orig_end;
	RExC_override_recoding = 0;
#ifdef EBCDIC
        RExC_recode_x_to_native = 0;
#endif

        SvREFCNT_dec_NN(substitute_parse);
        nextchar(pRExC_state);

        return TRUE;
    }
}


/*
 * reg_recode
 *
 * It returns the code point in utf8 for the value in *encp.
 *    value: a code value in the source encoding
 *    encp:  a pointer to an Encode object
 *
 * If the result from Encode is not a single character,
 * it returns U+FFFD (Replacement character) and sets *encp to NULL.
 */
STATIC UV
S_reg_recode(pTHX_ const U8 value, SV **encp)
{
    STRLEN numlen = 1;
    SV * const sv = newSVpvn_flags((const char *) &value, numlen, SVs_TEMP);
    const char * const s = *encp ? sv_recode_to_utf8(sv, *encp) : SvPVX(sv);
    const STRLEN newlen = SvCUR(sv);
    UV uv = UNICODE_REPLACEMENT;

    PERL_ARGS_ASSERT_REG_RECODE;

    if (newlen)
	uv = SvUTF8(sv)
	     ? utf8n_to_uvchr((U8*)s, newlen, &numlen, UTF8_ALLOW_DEFAULT)
	     : *(U8*)s;

    if (!newlen || numlen != newlen) {
	uv = UNICODE_REPLACEMENT;
	*encp = NULL;
    }
    return uv;
}

PERL_STATIC_INLINE U8
S_compute_EXACTish(RExC_state_t *pRExC_state)
{
    U8 op;

    PERL_ARGS_ASSERT_COMPUTE_EXACTISH;

    if (! FOLD) {
        return (LOC)
                ? EXACTL
                : EXACT;
    }

    op = get_regex_charset(RExC_flags);
    if (op >= REGEX_ASCII_RESTRICTED_CHARSET) {
        op--; /* /a is same as /u, and map /aa's offset to what /a's would have
                 been, so there is no hole */
    }

    return op + EXACTF;
}

PERL_STATIC_INLINE void
S_alloc_maybe_populate_EXACT(pTHX_ RExC_state_t *pRExC_state,
                         regnode *node, I32* flagp, STRLEN len, UV code_point,
                         bool downgradable)
{
    /* This knows the details about sizing an EXACTish node, setting flags for
     * it (by setting <*flagp>, and potentially populating it with a single
     * character.
     *
     * If <len> (the length in bytes) is non-zero, this function assumes that
     * the node has already been populated, and just does the sizing.  In this
     * case <code_point> should be the final code point that has already been
     * placed into the node.  This value will be ignored except that under some
     * circumstances <*flagp> is set based on it.
     *
     * If <len> is zero, the function assumes that the node is to contain only
     * the single character given by <code_point> and calculates what <len>
     * should be.  In pass 1, it sizes the node appropriately.  In pass 2, it
     * additionally will populate the node's STRING with <code_point> or its
     * fold if folding.
     *
     * In both cases <*flagp> is appropriately set
     *
     * It knows that under FOLD, the Latin Sharp S and UTF characters above
     * 255, must be folded (the former only when the rules indicate it can
     * match 'ss')
     *
     * When it does the populating, it looks at the flag 'downgradable'.  If
     * true with a node that folds, it checks if the single code point
     * participates in a fold, and if not downgrades the node to an EXACT.
     * This helps the optimizer */

    bool len_passed_in = cBOOL(len != 0);
    U8 character[UTF8_MAXBYTES_CASE+1];

    PERL_ARGS_ASSERT_ALLOC_MAYBE_POPULATE_EXACT;

    /* Don't bother to check for downgrading in PASS1, as it doesn't make any
     * sizing difference, and is extra work that is thrown away */
    if (downgradable && ! PASS2) {
        downgradable = FALSE;
    }

    if (! len_passed_in) {
        if (UTF) {
            if (UVCHR_IS_INVARIANT(code_point)) {
                if (LOC || ! FOLD) {    /* /l defers folding until runtime */
                    *character = (U8) code_point;
                }
                else { /* Here is /i and not /l. (toFOLD() is defined on just
                          ASCII, which isn't the same thing as INVARIANT on
                          EBCDIC, but it works there, as the extra invariants
                          fold to themselves) */
                    *character = toFOLD((U8) code_point);

                    /* We can downgrade to an EXACT node if this character
                     * isn't a folding one.  Note that this assumes that
                     * nothing above Latin1 folds to some other invariant than
                     * one of these alphabetics; otherwise we would also have
                     * to check:
                     *  && (! HAS_NONLATIN1_FOLD_CLOSURE(code_point)
                     *      || ASCII_FOLD_RESTRICTED))
                     */
                    if (downgradable && PL_fold[code_point] == code_point) {
                        OP(node) = EXACT;
                    }
                }
                len = 1;
            }
            else if (FOLD && (! LOC
                              || ! is_PROBLEMATIC_LOCALE_FOLD_cp(code_point)))
            {   /* Folding, and ok to do so now */
                UV folded = _to_uni_fold_flags(
                                   code_point,
                                   character,
                                   &len,
                                   FOLD_FLAGS_FULL | ((ASCII_FOLD_RESTRICTED)
                                                      ? FOLD_FLAGS_NOMIX_ASCII
                                                      : 0));
                if (downgradable
                    && folded == code_point /* This quickly rules out many
                                               cases, avoiding the
                                               _invlist_contains_cp() overhead
                                               for those.  */
                    && ! _invlist_contains_cp(PL_utf8_foldable, code_point))
                {
                    OP(node) = (LOC)
                               ? EXACTL
                               : EXACT;
                }
            }
            else if (code_point <= MAX_UTF8_TWO_BYTE) {

                /* Not folding this cp, and can output it directly */
                *character = UTF8_TWO_BYTE_HI(code_point);
                *(character + 1) = UTF8_TWO_BYTE_LO(code_point);
                len = 2;
            }
            else {
                uvchr_to_utf8( character, code_point);
                len = UTF8SKIP(character);
            }
        } /* Else pattern isn't UTF8.  */
        else if (! FOLD) {
            *character = (U8) code_point;
            len = 1;
        } /* Else is folded non-UTF8 */
#if    UNICODE_MAJOR_VERSION > 3 /* no multifolds in early Unicode */   \
   || (UNICODE_MAJOR_VERSION == 3 && (   UNICODE_DOT_VERSION > 0)       \
                                      || UNICODE_DOT_DOT_VERSION > 0)
        else if (LIKELY(code_point != LATIN_SMALL_LETTER_SHARP_S)) {
#else
        else if (1) {
#endif
            /* We don't fold any non-UTF8 except possibly the Sharp s  (see
             * comments at join_exact()); */
            *character = (U8) code_point;
            len = 1;

            /* Can turn into an EXACT node if we know the fold at compile time,
             * and it folds to itself and doesn't particpate in other folds */
            if (downgradable
                && ! LOC
                && PL_fold_latin1[code_point] == code_point
                && (! HAS_NONLATIN1_FOLD_CLOSURE(code_point)
                    || (isASCII(code_point) && ASCII_FOLD_RESTRICTED)))
            {
                OP(node) = EXACT;
            }
        } /* else is Sharp s.  May need to fold it */
        else if (AT_LEAST_UNI_SEMANTICS && ! ASCII_FOLD_RESTRICTED) {
            *character = 's';
            *(character + 1) = 's';
            len = 2;
        }
        else {
            *character = LATIN_SMALL_LETTER_SHARP_S;
            len = 1;
        }
    }

    if (SIZE_ONLY) {
        RExC_size += STR_SZ(len);
    }
    else {
        RExC_emit += STR_SZ(len);
        STR_LEN(node) = len;
        if (! len_passed_in) {
            Copy((char *) character, STRING(node), len, char);
        }
    }

    *flagp |= HASWIDTH;

    /* A single character node is SIMPLE, except for the special-cased SHARP S
     * under /di. */
    if ((len == 1 || (UTF && len == UVCHR_SKIP(code_point)))
#if    UNICODE_MAJOR_VERSION > 3 /* no multifolds in early Unicode */   \
   || (UNICODE_MAJOR_VERSION == 3 && (   UNICODE_DOT_VERSION > 0)       \
                                      || UNICODE_DOT_DOT_VERSION > 0)
        && ( code_point != LATIN_SMALL_LETTER_SHARP_S
            || ! FOLD || ! DEPENDS_SEMANTICS)
#endif
    ) {
        *flagp |= SIMPLE;
    }

    /* The OP may not be well defined in PASS1 */
    if (PASS2 && OP(node) == EXACTFL) {
        RExC_contains_locale = 1;
    }
}


/* Parse backref decimal value, unless it's too big to sensibly be a backref,
 * in which case return I32_MAX (rather than possibly 32-bit wrapping) */

static I32
S_backref_value(char *p)
{
    const char* endptr;
    UV val;
    if (grok_atoUV(p, &val, &endptr) && val <= I32_MAX)
        return (I32)val;
    return I32_MAX;
}


/*
 - regatom - the lowest level

   Try to identify anything special at the start of the pattern. If there
   is, then handle it as required. This may involve generating a single regop,
   such as for an assertion; or it may involve recursing, such as to
   handle a () structure.

   If the string doesn't start with something special then we gobble up
   as much literal text as we can.

   Once we have been able to handle whatever type of thing started the
   sequence, we return.

   Note: we have to be careful with escapes, as they can be both literal
   and special, and in the case of \10 and friends, context determines which.

   A summary of the code structure is:

   switch (first_byte) {
	cases for each special:
	    handle this special;
	    break;
	case '\\':
	    switch (2nd byte) {
		cases for each unambiguous special:
		    handle this special;
		    break;
		cases for each ambigous special/literal:
		    disambiguate;
		    if (special)  handle here
		    else goto defchar;
		default: // unambiguously literal:
		    goto defchar;
	    }
	default:  // is a literal char
	    // FALL THROUGH
	defchar:
	    create EXACTish node for literal;
	    while (more input and node isn't full) {
		switch (input_byte) {
		   cases for each special;
                       make sure parse pointer is set so that the next call to
                           regatom will see this special first
                       goto loopdone; // EXACTish node terminated by prev. char
		   default:
		       append char to EXACTISH node;
		}
	        get next input byte;
	    }
        loopdone:
   }
   return the generated node;

   Specifically there are two separate switches for handling
   escape sequences, with the one for handling literal escapes requiring
   a dummy entry for all of the special escapes that are actually handled
   by the other.

   Returns NULL, setting *flagp to TRYAGAIN if reg() returns NULL with
   TRYAGAIN.
   Returns NULL, setting *flagp to RESTART_PASS1 if the sizing scan needs to be
   restarted, or'd with NEED_UTF8 if the pattern needs to be upgraded to UTF-8
   Otherwise does not return NULL.
*/

STATIC regnode *
S_regatom(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, U32 depth)
{
    regnode *ret = NULL;
    I32 flags = 0;
    char *parse_start;
    U8 op;
    int invert = 0;
    U8 arg;

    GET_RE_DEBUG_FLAGS_DECL;

    *flagp = WORST;		/* Tentatively. */

    DEBUG_PARSE("atom");

    PERL_ARGS_ASSERT_REGATOM;

  tryagain:
    parse_start = RExC_parse;
    assert(RExC_parse < RExC_end);
    switch ((U8)*RExC_parse) {
    case '^':
	RExC_seen_zerolen++;
	nextchar(pRExC_state);
	if (RExC_flags & RXf_PMf_MULTILINE)
	    ret = reg_node(pRExC_state, MBOL);
	else
	    ret = reg_node(pRExC_state, SBOL);
        Set_Node_Length(ret, 1); /* MJD */
	break;
    case '$':
	nextchar(pRExC_state);
	if (*RExC_parse)
	    RExC_seen_zerolen++;
	if (RExC_flags & RXf_PMf_MULTILINE)
	    ret = reg_node(pRExC_state, MEOL);
	else
	    ret = reg_node(pRExC_state, SEOL);
        Set_Node_Length(ret, 1); /* MJD */
	break;
    case '.':
	nextchar(pRExC_state);
	if (RExC_flags & RXf_PMf_SINGLELINE)
	    ret = reg_node(pRExC_state, SANY);
	else
	    ret = reg_node(pRExC_state, REG_ANY);
	*flagp |= HASWIDTH|SIMPLE;
	MARK_NAUGHTY(1);
        Set_Node_Length(ret, 1); /* MJD */
	break;
    case '[':
    {
	char * const oregcomp_parse = ++RExC_parse;
        ret = regclass(pRExC_state, flagp,depth+1,
                       FALSE, /* means parse the whole char class */
                       TRUE, /* allow multi-char folds */
                       FALSE, /* don't silence non-portable warnings. */
                       (bool) RExC_strict,
                       TRUE, /* Allow an optimized regnode result */
                       NULL,
                       NULL);
        if (ret == NULL) {
            if (*flagp & (RESTART_PASS1|NEED_UTF8))
                return NULL;
            FAIL2("panic: regclass returned NULL to regatom, flags=%#"UVxf"",
                  (UV) *flagp);
        }
	if (*RExC_parse != ']') {
	    RExC_parse = oregcomp_parse;
	    vFAIL("Unmatched [");
	}
	nextchar(pRExC_state);
        Set_Node_Length(ret, RExC_parse - oregcomp_parse + 1); /* MJD */
	break;
    }
    case '(':
	nextchar(pRExC_state);
        ret = reg(pRExC_state, 2, &flags,depth+1);
	if (ret == NULL) {
		if (flags & TRYAGAIN) {
		    if (RExC_parse >= RExC_end) {
			 /* Make parent create an empty node if needed. */
			*flagp |= TRYAGAIN;
			return(NULL);
		    }
		    goto tryagain;
		}
                if (flags & (RESTART_PASS1|NEED_UTF8)) {
                    *flagp = flags & (RESTART_PASS1|NEED_UTF8);
                    return NULL;
                }
                FAIL2("panic: reg returned NULL to regatom, flags=%#"UVxf"",
                                                                 (UV) flags);
	}
	*flagp |= flags&(HASWIDTH|SPSTART|SIMPLE|POSTPONED);
	break;
    case '|':
    case ')':
	if (flags & TRYAGAIN) {
	    *flagp |= TRYAGAIN;
	    return NULL;
	}
	vFAIL("Internal urp");
				/* Supposed to be caught earlier. */
	break;
    case '?':
    case '+':
    case '*':
	RExC_parse++;
	vFAIL("Quantifier follows nothing");
	break;
    case '\\':
	/* Special Escapes

	   This switch handles escape sequences that resolve to some kind
	   of special regop and not to literal text. Escape sequnces that
	   resolve to literal text are handled below in the switch marked
	   "Literal Escapes".

	   Every entry in this switch *must* have a corresponding entry
	   in the literal escape switch. However, the opposite is not
	   required, as the default for this switch is to jump to the
	   literal text handling code.
	*/
	RExC_parse++;
	switch ((U8)*RExC_parse) {
	/* Special Escapes */
	case 'A':
	    RExC_seen_zerolen++;
	    ret = reg_node(pRExC_state, SBOL);
            /* SBOL is shared with /^/ so we set the flags so we can tell
             * /\A/ from /^/ in split. We check ret because first pass we
             * have no regop struct to set the flags on. */
            if (PASS2)
                ret->flags = 1;
	    *flagp |= SIMPLE;
	    goto finish_meta_pat;
	case 'G':
	    ret = reg_node(pRExC_state, GPOS);
            RExC_seen |= REG_GPOS_SEEN;
	    *flagp |= SIMPLE;
	    goto finish_meta_pat;
	case 'K':
	    RExC_seen_zerolen++;
	    ret = reg_node(pRExC_state, KEEPS);
	    *flagp |= SIMPLE;
	    /* XXX:dmq : disabling in-place substitution seems to
	     * be necessary here to avoid cases of memory corruption, as
	     * with: C<$_="x" x 80; s/x\K/y/> -- rgs
	     */
            RExC_seen |= REG_LOOKBEHIND_SEEN;
	    goto finish_meta_pat;
	case 'Z':
	    ret = reg_node(pRExC_state, SEOL);
	    *flagp |= SIMPLE;
	    RExC_seen_zerolen++;		/* Do not optimize RE away */
	    goto finish_meta_pat;
	case 'z':
	    ret = reg_node(pRExC_state, EOS);
	    *flagp |= SIMPLE;
	    RExC_seen_zerolen++;		/* Do not optimize RE away */
	    goto finish_meta_pat;
	case 'C':
	    vFAIL("\\C no longer supported");
	case 'X':
	    ret = reg_node(pRExC_state, CLUMP);
	    *flagp |= HASWIDTH;
	    goto finish_meta_pat;

	case 'W':
            invert = 1;
            /* FALLTHROUGH */
	case 'w':
            arg = ANYOF_WORDCHAR;
            goto join_posix;

	case 'B':
            invert = 1;
            /* FALLTHROUGH */
	case 'b':
          {
	    regex_charset charset = get_regex_charset(RExC_flags);

	    RExC_seen_zerolen++;
            RExC_seen |= REG_LOOKBEHIND_SEEN;
	    op = BOUND + charset;

            if (op == BOUNDL) {
                RExC_contains_locale = 1;
            }

	    ret = reg_node(pRExC_state, op);
	    *flagp |= SIMPLE;
	    if (RExC_parse >= RExC_end || *(RExC_parse + 1) != '{') {
                FLAGS(ret) = TRADITIONAL_BOUND;
                if (PASS2 && op > BOUNDA) {  /* /aa is same as /a */
                    OP(ret) = BOUNDA;
                }
            }
            else {
                STRLEN length;
                char name = *RExC_parse;
                char * endbrace;
                RExC_parse += 2;
                endbrace = strchr(RExC_parse, '}');

                if (! endbrace) {
                    vFAIL2("Missing right brace on \\%c{}", name);
                }
                /* XXX Need to decide whether to take spaces or not.  Should be
                 * consistent with \p{}, but that currently is SPACE, which
                 * means vertical too, which seems wrong
                 * while (isBLANK(*RExC_parse)) {
                    RExC_parse++;
                }*/
                if (endbrace == RExC_parse) {
                    RExC_parse++;  /* After the '}' */
                    vFAIL2("Empty \\%c{}", name);
                }
                length = endbrace - RExC_parse;
                /*while (isBLANK(*(RExC_parse + length - 1))) {
                    length--;
                }*/
                switch (*RExC_parse) {
                    case 'g':
                        if (length != 1
                            && (length != 3 || strnNE(RExC_parse + 1, "cb", 2)))
                        {
                            goto bad_bound_type;
                        }
                        FLAGS(ret) = GCB_BOUND;
                        break;
                    case 'l':
                        if (length != 2 || *(RExC_parse + 1) != 'b') {
                            goto bad_bound_type;
                        }
                        FLAGS(ret) = LB_BOUND;
                        break;
                    case 's':
                        if (length != 2 || *(RExC_parse + 1) != 'b') {
                            goto bad_bound_type;
                        }
                        FLAGS(ret) = SB_BOUND;
                        break;
                    case 'w':
                        if (length != 2 || *(RExC_parse + 1) != 'b') {
                            goto bad_bound_type;
                        }
                        FLAGS(ret) = WB_BOUND;
                        break;
                    default:
                      bad_bound_type:
                        RExC_parse = endbrace;
			vFAIL2utf8f(
                            "'%"UTF8f"' is an unknown bound type",
			    UTF8fARG(UTF, length, endbrace - length));
                        NOT_REACHED; /*NOTREACHED*/
                }
                RExC_parse = endbrace;
                REQUIRE_UNI_RULES(flagp, NULL);

                if (PASS2 && op >= BOUNDA) {  /* /aa is same as /a */
                    OP(ret) = BOUNDU;
                    length += 4;

                    /* Don't have to worry about UTF-8, in this message because
                     * to get here the contents of the \b must be ASCII */
                    ckWARN4reg(RExC_parse + 1,  /* Include the '}' in msg */
                              "Using /u for '%.*s' instead of /%s",
                              (unsigned) length,
                              endbrace - length + 1,
                              (charset == REGEX_ASCII_RESTRICTED_CHARSET)
                              ? ASCII_RESTRICT_PAT_MODS
                              : ASCII_MORE_RESTRICT_PAT_MODS);
                }
	    }

            if (PASS2 && invert) {
                OP(ret) += NBOUND - BOUND;
            }
	    goto finish_meta_pat;
          }

	case 'D':
            invert = 1;
            /* FALLTHROUGH */
	case 'd':
            arg = ANYOF_DIGIT;
            if (! DEPENDS_SEMANTICS) {
                goto join_posix;
            }

            /* \d doesn't have any matches in the upper Latin1 range, hence /d
             * is equivalent to /u.  Changing to /u saves some branches at
             * runtime */
            op = POSIXU;
            goto join_posix_op_known;

	case 'R':
	    ret = reg_node(pRExC_state, LNBREAK);
	    *flagp |= HASWIDTH|SIMPLE;
	    goto finish_meta_pat;

	case 'H':
            invert = 1;
            /* FALLTHROUGH */
	case 'h':
	    arg = ANYOF_BLANK;
            op = POSIXU;
            goto join_posix_op_known;

	case 'V':
            invert = 1;
            /* FALLTHROUGH */
	case 'v':
	    arg = ANYOF_VERTWS;
            op = POSIXU;
            goto join_posix_op_known;

	case 'S':
            invert = 1;
            /* FALLTHROUGH */
	case 's':
            arg = ANYOF_SPACE;

          join_posix:

	    op = POSIXD + get_regex_charset(RExC_flags);
            if (op > POSIXA) {  /* /aa is same as /a */
                op = POSIXA;
            }
            else if (op == POSIXL) {
                RExC_contains_locale = 1;
            }

          join_posix_op_known:

            if (invert) {
                op += NPOSIXD - POSIXD;
            }

	    ret = reg_node(pRExC_state, op);
            if (! SIZE_ONLY) {
                FLAGS(ret) = namedclass_to_classnum(arg);
            }

	    *flagp |= HASWIDTH|SIMPLE;
            /* FALLTHROUGH */

          finish_meta_pat:
	    nextchar(pRExC_state);
            Set_Node_Length(ret, 2); /* MJD */
	    break;
	case 'p':
	case 'P':
            RExC_parse--;

            ret = regclass(pRExC_state, flagp,depth+1,
                           TRUE, /* means just parse this element */
                           FALSE, /* don't allow multi-char folds */
                           FALSE, /* don't silence non-portable warnings.  It
                                     would be a bug if these returned
                                     non-portables */
                           (bool) RExC_strict,
                           TRUE, /* Allow an optimized regnode result */
                           NULL,
                           NULL);
            if (*flagp & RESTART_PASS1)
                return NULL;
            /* regclass() can only return RESTART_PASS1 and NEED_UTF8 if
             * multi-char folds are allowed.  */
            if (!ret)
                FAIL2("panic: regclass returned NULL to regatom, flags=%#"UVxf"",
                      (UV) *flagp);

            RExC_parse--;

            Set_Node_Offset(ret, parse_start);
            Set_Node_Cur_Length(ret, parse_start - 2);
            nextchar(pRExC_state);
	    break;
        case 'N':
            /* Handle \N, \N{} and \N{NAMED SEQUENCE} (the latter meaning the
             * \N{...} evaluates to a sequence of more than one code points).
             * The function call below returns a regnode, which is our result.
             * The parameters cause it to fail if the \N{} evaluates to a
             * single code point; we handle those like any other literal.  The
             * reason that the multicharacter case is handled here and not as
             * part of the EXACtish code is because of quantifiers.  In
             * /\N{BLAH}+/, the '+' applies to the whole thing, and doing it
             * this way makes that Just Happen. dmq.
             * join_exact() will join this up with adjacent EXACTish nodes
             * later on, if appropriate. */
            ++RExC_parse;
            if (grok_bslash_N(pRExC_state,
                              &ret,     /* Want a regnode returned */
                              NULL,     /* Fail if evaluates to a single code
                                           point */
                              NULL,     /* Don't need a count of how many code
                                           points */
                              flagp,
                              RExC_strict,
                              depth)
            ) {
                break;
            }

            if (*flagp & RESTART_PASS1)
                return NULL;

            /* Here, evaluates to a single code point.  Go get that */
            RExC_parse = parse_start;
            goto defchar;

	case 'k':    /* Handle \k<NAME> and \k'NAME' */
      parse_named_seq:
        {
            char ch;
            if (   RExC_parse >= RExC_end - 1
                || ((   ch = RExC_parse[1]) != '<'
                                      && ch != '\''
                                      && ch != '{'))
            {
	        RExC_parse++;
		/* diag_listed_as: Sequence \%s... not terminated in regex; marked by <-- HERE in m/%s/ */
	        vFAIL2("Sequence %.2s... not terminated",parse_start);
	    } else {
		RExC_parse += 2;
                ret = handle_named_backref(pRExC_state,
                                           flagp,
                                           parse_start,
                                           (ch == '<')
                                           ? '>'
                                           : (ch == '{')
                                             ? '}'
                                             : '\'');
            }
            break;
	}
	case 'g':
	case '1': case '2': case '3': case '4':
	case '5': case '6': case '7': case '8': case '9':
	    {
		I32 num;
		bool hasbrace = 0;

		if (*RExC_parse == 'g') {
                    bool isrel = 0;

		    RExC_parse++;
		    if (*RExC_parse == '{') {
		        RExC_parse++;
		        hasbrace = 1;
		    }
		    if (*RExC_parse == '-') {
		        RExC_parse++;
		        isrel = 1;
		    }
		    if (hasbrace && !isDIGIT(*RExC_parse)) {
		        if (isrel) RExC_parse--;
                        RExC_parse -= 2;
		        goto parse_named_seq;
                    }

                    if (RExC_parse >= RExC_end) {
                        goto unterminated_g;
                    }
                    num = S_backref_value(RExC_parse);
                    if (num == 0)
                        vFAIL("Reference to invalid group 0");
                    else if (num == I32_MAX) {
                         if (isDIGIT(*RExC_parse))
			    vFAIL("Reference to nonexistent group");
                        else
                          unterminated_g:
                            vFAIL("Unterminated \\g... pattern");
                    }

                    if (isrel) {
                        num = RExC_npar - num;
                        if (num < 1)
                            vFAIL("Reference to nonexistent or unclosed group");
                    }
                }
                else {
                    num = S_backref_value(RExC_parse);
                    /* bare \NNN might be backref or octal - if it is larger
                     * than or equal RExC_npar then it is assumed to be an
                     * octal escape. Note RExC_npar is +1 from the actual
                     * number of parens. */
                    /* Note we do NOT check if num == I32_MAX here, as that is
                     * handled by the RExC_npar check */

                    if (
                        /* any numeric escape < 10 is always a backref */
                        num > 9
                        /* any numeric escape < RExC_npar is a backref */
                        && num >= RExC_npar
                        /* cannot be an octal escape if it starts with 8 */
                        && *RExC_parse != '8'
                        /* cannot be an octal escape it it starts with 9 */
                        && *RExC_parse != '9'
                    )
                    {
                        /* Probably not a backref, instead likely to be an
                         * octal character escape, e.g. \35 or \777.
                         * The above logic should make it obvious why using
                         * octal escapes in patterns is problematic. - Yves */
                        RExC_parse = parse_start;
                        goto defchar;
                    }
                }

                /* At this point RExC_parse points at a numeric escape like
                 * \12 or \88 or something similar, which we should NOT treat
                 * as an octal escape. It may or may not be a valid backref
                 * escape. For instance \88888888 is unlikely to be a valid
                 * backref. */
                while (isDIGIT(*RExC_parse))
                    RExC_parse++;
                if (hasbrace) {
                    if (*RExC_parse != '}')
                        vFAIL("Unterminated \\g{...} pattern");
                    RExC_parse++;
                }
                if (!SIZE_ONLY) {
                    if (num > (I32)RExC_rx->nparens)
                        vFAIL("Reference to nonexistent group");
                }
                RExC_sawback = 1;
                ret = reganode(pRExC_state,
                               ((! FOLD)
                                 ? REF
                                 : (ASCII_FOLD_RESTRICTED)
                                   ? REFFA
                                   : (AT_LEAST_UNI_SEMANTICS)
                                     ? REFFU
                                     : (LOC)
                                       ? REFFL
                                       : REFF),
                                num);
                *flagp |= HASWIDTH;

                /* override incorrect value set in reganode MJD */
                Set_Node_Offset(ret, parse_start);
                Set_Node_Cur_Length(ret, parse_start-1);
                skip_to_be_ignored_text(pRExC_state, &RExC_parse,
                                        FALSE /* Don't force to /x */ );
	    }
	    break;
	case '\0':
	    if (RExC_parse >= RExC_end)
		FAIL("Trailing \\");
	    /* FALLTHROUGH */
	default:
	    /* Do not generate "unrecognized" warnings here, we fall
	       back into the quick-grab loop below */
            RExC_parse = parse_start;
	    goto defchar;
	} /* end of switch on a \foo sequence */
	break;

    case '#':

        /* '#' comments should have been spaced over before this function was
         * called */
        assert((RExC_flags & RXf_PMf_EXTENDED) == 0);
	/*
        if (RExC_flags & RXf_PMf_EXTENDED) {
	    RExC_parse = reg_skipcomment( pRExC_state, RExC_parse );
	    if (RExC_parse < RExC_end)
		goto tryagain;
	}
        */

	/* FALLTHROUGH */

    default:
	  defchar: {

            /* Here, we have determined that the next thing is probably a
             * literal character.  RExC_parse points to the first byte of its
             * definition.  (It still may be an escape sequence that evaluates
             * to a single character) */

	    STRLEN len = 0;
	    UV ender = 0;
	    char *p;
	    char *s;
#define MAX_NODE_STRING_SIZE 127
	    char foldbuf[MAX_NODE_STRING_SIZE+UTF8_MAXBYTES_CASE];
	    char *s0;
	    U8 upper_parse = MAX_NODE_STRING_SIZE;
            U8 node_type = compute_EXACTish(pRExC_state);
            bool next_is_quantifier;
            char * oldp = NULL;

            /* We can convert EXACTF nodes to EXACTFU if they contain only
             * characters that match identically regardless of the target
             * string's UTF8ness.  The reason to do this is that EXACTF is not
             * trie-able, EXACTFU is.
             *
             * Similarly, we can convert EXACTFL nodes to EXACTFLU8 if they
             * contain only above-Latin1 characters (hence must be in UTF8),
             * which don't participate in folds with Latin1-range characters,
             * as the latter's folds aren't known until runtime.  (We don't
             * need to figure this out until pass 2) */
            bool maybe_exactfu = PASS2
                               && (node_type == EXACTF || node_type == EXACTFL);

            /* If a folding node contains only code points that don't
             * participate in folds, it can be changed into an EXACT node,
             * which allows the optimizer more things to look for */
            bool maybe_exact;

	    ret = reg_node(pRExC_state, node_type);

            /* In pass1, folded, we use a temporary buffer instead of the
             * actual node, as the node doesn't exist yet */
	    s = (SIZE_ONLY && FOLD) ? foldbuf : STRING(ret);

            s0 = s;

	  reparse:

            /* We look for the EXACTFish to EXACT node optimizaton only if
             * folding.  (And we don't need to figure this out until pass 2).
             * XXX It might actually make sense to split the node into portions
             * that are exact and ones that aren't, so that we could later use
             * the exact ones to find the longest fixed and floating strings.
             * One would want to join them back into a larger node.  One could
             * use a pseudo regnode like 'EXACT_ORIG_FOLD' */
            maybe_exact = FOLD && PASS2;

	    /* XXX The node can hold up to 255 bytes, yet this only goes to
             * 127.  I (khw) do not know why.  Keeping it somewhat less than
             * 255 allows us to not have to worry about overflow due to
             * converting to utf8 and fold expansion, but that value is
             * 255-UTF8_MAXBYTES_CASE.  join_exact() may join adjacent nodes
             * split up by this limit into a single one using the real max of
             * 255.  Even at 127, this breaks under rare circumstances.  If
             * folding, we do not want to split a node at a character that is a
             * non-final in a multi-char fold, as an input string could just
             * happen to want to match across the node boundary.  The join
             * would solve that problem if the join actually happens.  But a
             * series of more than two nodes in a row each of 127 would cause
             * the first join to succeed to get to 254, but then there wouldn't
             * be room for the next one, which could at be one of those split
             * multi-char folds.  I don't know of any fool-proof solution.  One
             * could back off to end with only a code point that isn't such a
             * non-final, but it is possible for there not to be any in the
             * entire node. */

            assert(   ! UTF     /* Is at the beginning of a character */
                   || UTF8_IS_INVARIANT(UCHARAT(RExC_parse))
                   || UTF8_IS_START(UCHARAT(RExC_parse)));

	    for (p = RExC_parse;
	         len < upper_parse && p < RExC_end;
	         len++)
	    {
		oldp = p;

                /* White space has already been ignored */
                assert(   (RExC_flags & RXf_PMf_EXTENDED) == 0
                       || ! is_PATWS_safe((p), RExC_end, UTF));

		switch ((U8)*p) {
		case '^':
		case '$':
		case '.':
		case '[':
		case '(':
		case ')':
		case '|':
		    goto loopdone;
		case '\\':
		    /* Literal Escapes Switch

		       This switch is meant to handle escape sequences that
		       resolve to a literal character.

		       Every escape sequence that represents something
		       else, like an assertion or a char class, is handled
		       in the switch marked 'Special Escapes' above in this
		       routine, but also has an entry here as anything that
		       isn't explicitly mentioned here will be treated as
		       an unescaped equivalent literal.
		    */

		    switch ((U8)*++p) {
		    /* These are all the special escapes. */
		    case 'A':             /* Start assertion */
		    case 'b': case 'B':   /* Word-boundary assertion*/
		    case 'C':             /* Single char !DANGEROUS! */
		    case 'd': case 'D':   /* digit class */
		    case 'g': case 'G':   /* generic-backref, pos assertion */
		    case 'h': case 'H':   /* HORIZWS */
		    case 'k': case 'K':   /* named backref, keep marker */
		    case 'p': case 'P':   /* Unicode property */
		              case 'R':   /* LNBREAK */
		    case 's': case 'S':   /* space class */
		    case 'v': case 'V':   /* VERTWS */
		    case 'w': case 'W':   /* word class */
                    case 'X':             /* eXtended Unicode "combining
                                             character sequence" */
		    case 'z': case 'Z':   /* End of line/string assertion */
			--p;
			goto loopdone;

	            /* Anything after here is an escape that resolves to a
	               literal. (Except digits, which may or may not)
	             */
		    case 'n':
			ender = '\n';
			p++;
			break;
		    case 'N': /* Handle a single-code point named character. */
                        RExC_parse = p + 1;
                        if (! grok_bslash_N(pRExC_state,
                                            NULL,   /* Fail if evaluates to
                                                       anything other than a
                                                       single code point */
                                            &ender, /* The returned single code
                                                       point */
                                            NULL,   /* Don't need a count of
                                                       how many code points */
                                            flagp,
                                            RExC_strict,
                                            depth)
                        ) {
                            if (*flagp & NEED_UTF8)
                                FAIL("panic: grok_bslash_N set NEED_UTF8");
                            if (*flagp & RESTART_PASS1)
                                return NULL;

                            /* Here, it wasn't a single code point.  Go close
                             * up this EXACTish node.  The switch() prior to
                             * this switch handles the other cases */
                            RExC_parse = p = oldp;
                            goto loopdone;
                        }
                        p = RExC_parse;
                        if (ender > 0xff) {
                            REQUIRE_UTF8(flagp);
                        }
                        break;
		    case 'r':
			ender = '\r';
			p++;
			break;
		    case 't':
			ender = '\t';
			p++;
			break;
		    case 'f':
			ender = '\f';
			p++;
			break;
		    case 'e':
			ender = ESC_NATIVE;
			p++;
			break;
		    case 'a':
			ender = '\a';
			p++;
			break;
		    case 'o':
			{
			    UV result;
			    const char* error_msg;

			    bool valid = grok_bslash_o(&p,
						       &result,
						       &error_msg,
						       PASS2, /* out warnings */
                                                       (bool) RExC_strict,
                                                       TRUE, /* Output warnings
                                                                for non-
                                                                portables */
                                                       UTF);
			    if (! valid) {
				RExC_parse = p;	/* going to die anyway; point
						   to exact spot of failure */
				vFAIL(error_msg);
			    }
                            ender = result;
			    if (IN_ENCODING && ender < 0x100) {
				goto recode_encoding;
			    }
			    if (ender > 0xff) {
				REQUIRE_UTF8(flagp);
			    }
			    break;
			}
		    case 'x':
			{
                            UV result = UV_MAX; /* initialize to erroneous
                                                   value */
			    const char* error_msg;

			    bool valid = grok_bslash_x(&p,
						       &result,
						       &error_msg,
						       PASS2, /* out warnings */
                                                       (bool) RExC_strict,
                                                       TRUE, /* Silence warnings
                                                                for non-
                                                                portables */
                                                       UTF);
			    if (! valid) {
				RExC_parse = p;	/* going to die anyway; point
						   to exact spot of failure */
				vFAIL(error_msg);
			    }
                            ender = result;

                            if (ender < 0x100) {
#ifdef EBCDIC
                                if (RExC_recode_x_to_native) {
                                    ender = LATIN1_TO_NATIVE(ender);
                                }
                                else
#endif
                                if (IN_ENCODING) {
                                    goto recode_encoding;
                                }
			    }
                            else {
				REQUIRE_UTF8(flagp);
			    }
			    break;
			}
		    case 'c':
			p++;
			ender = grok_bslash_c(*p++, PASS2);
			break;
                    case '8': case '9': /* must be a backreference */
                        --p;
                        /* we have an escape like \8 which cannot be an octal escape
                         * so we exit the loop, and let the outer loop handle this
                         * escape which may or may not be a legitimate backref. */
                        goto loopdone;
                    case '1': case '2': case '3':case '4':
		    case '5': case '6': case '7':
                        /* When we parse backslash escapes there is ambiguity
                         * between backreferences and octal escapes. Any escape
                         * from \1 - \9 is a backreference, any multi-digit
                         * escape which does not start with 0 and which when
                         * evaluated as decimal could refer to an already
                         * parsed capture buffer is a back reference. Anything
                         * else is octal.
                         *
                         * Note this implies that \118 could be interpreted as
                         * 118 OR as "\11" . "8" depending on whether there
                         * were 118 capture buffers defined already in the
                         * pattern.  */

                        /* NOTE, RExC_npar is 1 more than the actual number of
                         * parens we have seen so far, hence the < RExC_npar below. */

                        if ( !isDIGIT(p[1]) || S_backref_value(p) < RExC_npar)
                        {  /* Not to be treated as an octal constant, go
                                   find backref */
                            --p;
                            goto loopdone;
                        }
                        /* FALLTHROUGH */
                    case '0':
			{
			    I32 flags = PERL_SCAN_SILENT_ILLDIGIT;
			    STRLEN numlen = 3;
			    ender = grok_oct(p, &numlen, &flags, NULL);
			    if (ender > 0xff) {
				REQUIRE_UTF8(flagp);
			    }
			    p += numlen;
                            if (PASS2   /* like \08, \178 */
                                && numlen < 3
                                && isDIGIT(*p) && ckWARN(WARN_REGEXP))
                            {
				reg_warn_non_literal_string(
                                         p + 1,
                                         form_short_octal_warning(p, numlen));
                            }
			}
			if (IN_ENCODING && ender < 0x100)
			    goto recode_encoding;
			break;
		      recode_encoding:
			if (! RExC_override_recoding) {
			    SV* enc = _get_encoding();
			    ender = reg_recode((U8)ender, &enc);
			    if (!enc && PASS2)
				ckWARNreg(p, "Invalid escape in the specified encoding");
			    REQUIRE_UTF8(flagp);
			}
			break;
		    case '\0':
			if (p >= RExC_end)
			    FAIL("Trailing \\");
			/* FALLTHROUGH */
		    default:
			if (!SIZE_ONLY&& isALPHANUMERIC(*p)) {
			    /* Include any left brace following the alpha to emphasize
			     * that it could be part of an escape at some point
			     * in the future */
			    int len = (isALPHA(*p) && *(p + 1) == '{') ? 2 : 1;
			    ckWARN3reg(p + len, "Unrecognized escape \\%.*s passed through", len, p);
			}
			goto normal_default;
		    } /* End of switch on '\' */
		    break;
		case '{':
		    /* Currently we don't warn when the lbrace is at the start
		     * of a construct.  This catches it in the middle of a
		     * literal string, or when it's the first thing after
		     * something like "\b" */
		    if (! SIZE_ONLY
			&& (len || (p > RExC_start && isALPHA_A(*(p -1)))))
		    {
			ckWARNregdep(p + 1, "Unescaped left brace in regex is deprecated, passed through");
		    }
		    /*FALLTHROUGH*/
		default:    /* A literal character */
		  normal_default:
		    if (! UTF8_IS_INVARIANT(*p) && UTF) {
			STRLEN numlen;
			ender = utf8n_to_uvchr((U8*)p, RExC_end - p,
					       &numlen, UTF8_ALLOW_DEFAULT);
			p += numlen;
		    }
		    else
			ender = (U8) *p++;
		    break;
		} /* End of switch on the literal */

		/* Here, have looked at the literal character and <ender>
                 * contains its ordinal, <p> points to the character after it.
                 * We need to check if the next non-ignored thing is a
                 * quantifier.  Move <p> to after anything that should be
                 * ignored, which, as a side effect, positions <p> for the next
                 * loop iteration */
                skip_to_be_ignored_text(pRExC_state, &p,
                                        FALSE /* Don't force to /x */ );

                /* If the next thing is a quantifier, it applies to this
                 * character only, which means that this character has to be in
                 * its own node and can't just be appended to the string in an
                 * existing node, so if there are already other characters in
                 * the node, close the node with just them, and set up to do
                 * this character again next time through, when it will be the
                 * only thing in its new node */
                if ((next_is_quantifier = (   LIKELY(p < RExC_end)
                                           && UNLIKELY(ISMULT2(p))))
                    && LIKELY(len))
		{
                    p = oldp;
                    goto loopdone;
                }

                /* Ready to add 'ender' to the node */

                if (! FOLD) {  /* The simple case, just append the literal */

                    /* In the sizing pass, we need only the size of the
                     * character we are appending, hence we can delay getting
                     * its representation until PASS2. */
                    if (SIZE_ONLY) {
                        if (UTF) {
                            const STRLEN unilen = UVCHR_SKIP(ender);
                            s += unilen;

                            /* We have to subtract 1 just below (and again in
                             * the corresponding PASS2 code) because the loop
                             * increments <len> each time, as all but this path
                             * (and one other) through it add a single byte to
                             * the EXACTish node.  But these paths would change
                             * len to be the correct final value, so cancel out
                             * the increment that follows */
                            len += unilen - 1;
                        }
                        else {
                            s++;
                        }
                    } else { /* PASS2 */
                      not_fold_common:
                        if (UTF) {
                            U8 * new_s = uvchr_to_utf8((U8*)s, ender);
                            len += (char *) new_s - s - 1;
                            s = (char *) new_s;
                        }
                        else {
                            *(s++) = (char) ender;
                        }
                    }
                }
                else if (LOC && is_PROBLEMATIC_LOCALE_FOLD_cp(ender)) {

                    /* Here are folding under /l, and the code point is
                     * problematic.  First, we know we can't simplify things */
                    maybe_exact = FALSE;
                    maybe_exactfu = FALSE;

                    /* A problematic code point in this context means that its
                     * fold isn't known until runtime, so we can't fold it now.
                     * (The non-problematic code points are the above-Latin1
                     * ones that fold to also all above-Latin1.  Their folds
                     * don't vary no matter what the locale is.) But here we
                     * have characters whose fold depends on the locale.
                     * Unlike the non-folding case above, we have to keep track
                     * of these in the sizing pass, so that we can make sure we
                     * don't split too-long nodes in the middle of a potential
                     * multi-char fold.  And unlike the regular fold case
                     * handled in the else clauses below, we don't actually
                     * fold and don't have special cases to consider.  What we
                     * do for both passes is the PASS2 code for non-folding */
                    goto not_fold_common;
                }
                else /* A regular FOLD code point */
                    if (! (   UTF
#if    UNICODE_MAJOR_VERSION > 3 /* no multifolds in early Unicode */   \
   || (UNICODE_MAJOR_VERSION == 3 && (   UNICODE_DOT_VERSION > 0)       \
                                      || UNICODE_DOT_DOT_VERSION > 0)
                            /* See comments for join_exact() as to why we fold
                             * this non-UTF at compile time */
                            || (   node_type == EXACTFU
                                && ender == LATIN_SMALL_LETTER_SHARP_S)
#endif
                )) {
                    /* Here, are folding and are not UTF-8 encoded; therefore
                     * the character must be in the range 0-255, and is not /l
                     * (Not /l because we already handled these under /l in
                     * is_PROBLEMATIC_LOCALE_FOLD_cp) */
                    if (IS_IN_SOME_FOLD_L1(ender)) {
                        maybe_exact = FALSE;

                        /* See if the character's fold differs between /d and
                         * /u.  This includes the multi-char fold SHARP S to
                         * 'ss' */
                        if (UNLIKELY(ender == LATIN_SMALL_LETTER_SHARP_S)) {
                            RExC_seen_unfolded_sharp_s = 1;
                            maybe_exactfu = FALSE;
                        }
                        else if (maybe_exactfu
                            && (PL_fold[ender] != PL_fold_latin1[ender]
#if    UNICODE_MAJOR_VERSION > 3 /* no multifolds in early Unicode */   \
   || (UNICODE_MAJOR_VERSION == 3 && (   UNICODE_DOT_VERSION > 0)       \
                                      || UNICODE_DOT_DOT_VERSION > 0)
                                || (   len > 0
                                    && isALPHA_FOLD_EQ(ender, 's')
                                    && isALPHA_FOLD_EQ(*(s-1), 's'))
#endif
                        )) {
                            maybe_exactfu = FALSE;
                        }
                    }

                    /* Even when folding, we store just the input character, as
                     * we have an array that finds its fold quickly */
                    *(s++) = (char) ender;
                }
                else {  /* FOLD, and UTF (or sharp s) */
                    /* Unlike the non-fold case, we do actually have to
                     * calculate the results here in pass 1.  This is for two
                     * reasons, the folded length may be longer than the
                     * unfolded, and we have to calculate how many EXACTish
                     * nodes it will take; and we may run out of room in a node
                     * in the middle of a potential multi-char fold, and have
                     * to back off accordingly.  */

                    UV folded;
                    if (isASCII_uni(ender)) {
                        folded = toFOLD(ender);
                        *(s)++ = (U8) folded;
                    }
                    else {
                        STRLEN foldlen;

                        folded = _to_uni_fold_flags(
                                     ender,
                                     (U8 *) s,
                                     &foldlen,
                                     FOLD_FLAGS_FULL | ((ASCII_FOLD_RESTRICTED)
                                                        ? FOLD_FLAGS_NOMIX_ASCII
                                                        : 0));
                        s += foldlen;

                        /* The loop increments <len> each time, as all but this
                         * path (and one other) through it add a single byte to
                         * the EXACTish node.  But this one has changed len to
                         * be the correct final value, so subtract one to
                         * cancel out the increment that follows */
                        len += foldlen - 1;
                    }
                    /* If this node only contains non-folding code points so
                     * far, see if this new one is also non-folding */
                    if (maybe_exact) {
                        if (folded != ender) {
                            maybe_exact = FALSE;
                        }
                        else {
                            /* Here the fold is the original; we have to check
                             * further to see if anything folds to it */
                            if (_invlist_contains_cp(PL_utf8_foldable,
                                                        ender))
                            {
                                maybe_exact = FALSE;
                            }
                        }
                    }
                    ender = folded;
		}

		if (next_is_quantifier) {

                    /* Here, the next input is a quantifier, and to get here,
                     * the current character is the only one in the node.
                     * Also, here <len> doesn't include the final byte for this
                     * character */
                    len++;
                    goto loopdone;
		}

	    } /* End of loop through literal characters */

            /* Here we have either exhausted the input or ran out of room in
             * the node.  (If we encountered a character that can't be in the
             * node, transfer is made directly to <loopdone>, and so we
             * wouldn't have fallen off the end of the loop.)  In the latter
             * case, we artificially have to split the node into two, because
             * we just don't have enough space to hold everything.  This
             * creates a problem if the final character participates in a
             * multi-character fold in the non-final position, as a match that
             * should have occurred won't, due to the way nodes are matched,
             * and our artificial boundary.  So back off until we find a non-
             * problematic character -- one that isn't at the beginning or
             * middle of such a fold.  (Either it doesn't participate in any
             * folds, or appears only in the final position of all the folds it
             * does participate in.)  A better solution with far fewer false
             * positives, and that would fill the nodes more completely, would
             * be to actually have available all the multi-character folds to
             * test against, and to back-off only far enough to be sure that
             * this node isn't ending with a partial one.  <upper_parse> is set
             * further below (if we need to reparse the node) to include just
             * up through that final non-problematic character that this code
             * identifies, so when it is set to less than the full node, we can
             * skip the rest of this */
            if (FOLD && p < RExC_end && upper_parse == MAX_NODE_STRING_SIZE) {

                const STRLEN full_len = len;

		assert(len >= MAX_NODE_STRING_SIZE);

                /* Here, <s> points to the final byte of the final character.
                 * Look backwards through the string until find a non-
                 * problematic character */

		if (! UTF) {

                    /* This has no multi-char folds to non-UTF characters */
                    if (ASCII_FOLD_RESTRICTED) {
                        goto loopdone;
                    }

                    while (--s >= s0 && IS_NON_FINAL_FOLD(*s)) { }
                    len = s - s0 + 1;
		}
                else {
                    if (!  PL_NonL1NonFinalFold) {
                        PL_NonL1NonFinalFold = _new_invlist_C_array(
                                        NonL1_Perl_Non_Final_Folds_invlist);
                    }

                    /* Point to the first byte of the final character */
                    s = (char *) utf8_hop((U8 *) s, -1);

                    while (s >= s0) {   /* Search backwards until find
                                           non-problematic char */
                        if (UTF8_IS_INVARIANT(*s)) {

                            /* There are no ascii characters that participate
                             * in multi-char folds under /aa.  In EBCDIC, the
                             * non-ascii invariants are all control characters,
                             * so don't ever participate in any folds. */
                            if (ASCII_FOLD_RESTRICTED
                                || ! IS_NON_FINAL_FOLD(*s))
                            {
                                break;
                            }
                        }
                        else if (UTF8_IS_DOWNGRADEABLE_START(*s)) {
                            if (! IS_NON_FINAL_FOLD(EIGHT_BIT_UTF8_TO_NATIVE(
                                                                  *s, *(s+1))))
                            {
                                break;
                            }
                        }
                        else if (! _invlist_contains_cp(
                                        PL_NonL1NonFinalFold,
                                        valid_utf8_to_uvchr((U8 *) s, NULL)))
                        {
                            break;
                        }

                        /* Here, the current character is problematic in that
                         * it does occur in the non-final position of some
                         * fold, so try the character before it, but have to
                         * special case the very first byte in the string, so
                         * we don't read outside the string */
                        s = (s == s0) ? s -1 : (char *) utf8_hop((U8 *) s, -1);
                    } /* End of loop backwards through the string */

                    /* If there were only problematic characters in the string,
                     * <s> will point to before s0, in which case the length
                     * should be 0, otherwise include the length of the
                     * non-problematic character just found */
                    len = (s < s0) ? 0 : s - s0 + UTF8SKIP(s);
		}

                /* Here, have found the final character, if any, that is
                 * non-problematic as far as ending the node without splitting
                 * it across a potential multi-char fold.  <len> contains the
                 * number of bytes in the node up-to and including that
                 * character, or is 0 if there is no such character, meaning
                 * the whole node contains only problematic characters.  In
                 * this case, give up and just take the node as-is.  We can't
                 * do any better */
                if (len == 0) {
                    len = full_len;

                    /* If the node ends in an 's' we make sure it stays EXACTF,
                     * as if it turns into an EXACTFU, it could later get
                     * joined with another 's' that would then wrongly match
                     * the sharp s */
                    if (maybe_exactfu && isALPHA_FOLD_EQ(ender, 's'))
                    {
                        maybe_exactfu = FALSE;
                    }
                } else {

                    /* Here, the node does contain some characters that aren't
                     * problematic.  If one such is the final character in the
                     * node, we are done */
                    if (len == full_len) {
                        goto loopdone;
                    }
                    else if (len + ((UTF) ? UTF8SKIP(s) : 1) == full_len) {

                        /* If the final character is problematic, but the
                         * penultimate is not, back-off that last character to
                         * later start a new node with it */
                        p = oldp;
                        goto loopdone;
                    }

                    /* Here, the final non-problematic character is earlier
                     * in the input than the penultimate character.  What we do
                     * is reparse from the beginning, going up only as far as
                     * this final ok one, thus guaranteeing that the node ends
                     * in an acceptable character.  The reason we reparse is
                     * that we know how far in the character is, but we don't
                     * know how to correlate its position with the input parse.
                     * An alternate implementation would be to build that
                     * correlation as we go along during the original parse,
                     * but that would entail extra work for every node, whereas
                     * this code gets executed only when the string is too
                     * large for the node, and the final two characters are
                     * problematic, an infrequent occurrence.  Yet another
                     * possible strategy would be to save the tail of the
                     * string, and the next time regatom is called, initialize
                     * with that.  The problem with this is that unless you
                     * back off one more character, you won't be guaranteed
                     * regatom will get called again, unless regbranch,
                     * regpiece ... are also changed.  If you do back off that
                     * extra character, so that there is input guaranteed to
                     * force calling regatom, you can't handle the case where
                     * just the first character in the node is acceptable.  I
                     * (khw) decided to try this method which doesn't have that
                     * pitfall; if performance issues are found, we can do a
                     * combination of the current approach plus that one */
                    upper_parse = len;
                    len = 0;
                    s = s0;
                    goto reparse;
                }
	    }   /* End of verifying node ends with an appropriate char */

          loopdone:   /* Jumped to when encounters something that shouldn't be
                         in the node */

            /* I (khw) don't know if you can get here with zero length, but the
             * old code handled this situation by creating a zero-length EXACT
             * node.  Might as well be NOTHING instead */
            if (len == 0) {
                OP(ret) = NOTHING;
            }
            else {
                if (FOLD) {
                    /* If 'maybe_exact' is still set here, means there are no
                     * code points in the node that participate in folds;
                     * similarly for 'maybe_exactfu' and code points that match
                     * differently depending on UTF8ness of the target string
                     * (for /u), or depending on locale for /l */
                    if (maybe_exact) {
                        OP(ret) = (LOC)
                                  ? EXACTL
                                  : EXACT;
                    }
                    else if (maybe_exactfu) {
                        OP(ret) = (LOC)
                                  ? EXACTFLU8
                                  : EXACTFU;
                    }
                }
                alloc_maybe_populate_EXACT(pRExC_state, ret, flagp, len, ender,
                                           FALSE /* Don't look to see if could
                                                    be turned into an EXACT
                                                    node, as we have already
                                                    computed that */
                                          );
            }

	    RExC_parse = p - 1;
            Set_Node_Cur_Length(ret, parse_start);
	    RExC_parse = p;
            skip_to_be_ignored_text(pRExC_state, &RExC_parse,
                                    FALSE /* Don't force to /x */ );
	    {
		/* len is STRLEN which is unsigned, need to copy to signed */
		IV iv = len;
		if (iv < 0)
		    vFAIL("Internal disaster");
	    }

	} /* End of label 'defchar:' */
	break;
    } /* End of giant switch on input character */

    return(ret);
}


STATIC void
S_populate_ANYOF_from_invlist(pTHX_ regnode *node, SV** invlist_ptr)
{
    /* Uses the inversion list '*invlist_ptr' to populate the ANYOF 'node'.  It
     * sets up the bitmap and any flags, removing those code points from the
     * inversion list, setting it to NULL should it become completely empty */

    PERL_ARGS_ASSERT_POPULATE_ANYOF_FROM_INVLIST;
    assert(PL_regkind[OP(node)] == ANYOF);

    ANYOF_BITMAP_ZERO(node);
    if (*invlist_ptr) {

	/* This gets set if we actually need to modify things */
	bool change_invlist = FALSE;

	UV start, end;

	/* Start looking through *invlist_ptr */
	invlist_iterinit(*invlist_ptr);
	while (invlist_iternext(*invlist_ptr, &start, &end)) {
	    UV high;
	    int i;

            if (end == UV_MAX && start <= NUM_ANYOF_CODE_POINTS) {
                ANYOF_FLAGS(node) |= ANYOF_MATCHES_ALL_ABOVE_BITMAP;
            }

	    /* Quit if are above what we should change */
	    if (start >= NUM_ANYOF_CODE_POINTS) {
		break;
	    }

	    change_invlist = TRUE;

	    /* Set all the bits in the range, up to the max that we are doing */
	    high = (end < NUM_ANYOF_CODE_POINTS - 1)
                   ? end
                   : NUM_ANYOF_CODE_POINTS - 1;
	    for (i = start; i <= (int) high; i++) {
		if (! ANYOF_BITMAP_TEST(node, i)) {
		    ANYOF_BITMAP_SET(node, i);
		}
	    }
	}
	invlist_iterfinish(*invlist_ptr);

        /* Done with loop; remove any code points that are in the bitmap from
         * *invlist_ptr; similarly for code points above the bitmap if we have
         * a flag to match all of them anyways */
	if (change_invlist) {
	    _invlist_subtract(*invlist_ptr, PL_InBitmap, invlist_ptr);
	}
        if (ANYOF_FLAGS(node) & ANYOF_MATCHES_ALL_ABOVE_BITMAP) {
	    _invlist_intersection(*invlist_ptr, PL_InBitmap, invlist_ptr);
	}

	/* If have completely emptied it, remove it completely */
	if (_invlist_len(*invlist_ptr) == 0) {
	    SvREFCNT_dec_NN(*invlist_ptr);
	    *invlist_ptr = NULL;
	}
    }
}

/* Parse POSIX character classes: [[:foo:]], [[=foo=]], [[.foo.]].
   Character classes ([:foo:]) can also be negated ([:^foo:]).
   Returns a named class id (ANYOF_XXX) if successful, -1 otherwise.
   Equivalence classes ([=foo=]) and composites ([.foo.]) are parsed,
   but trigger failures because they are currently unimplemented. */

#define POSIXCC_DONE(c)   ((c) == ':')
#define POSIXCC_NOTYET(c) ((c) == '=' || (c) == '.')
#define POSIXCC(c) (POSIXCC_DONE(c) || POSIXCC_NOTYET(c))
#define MAYBE_POSIXCC(c) (POSIXCC(c) || (c) == '^' || (c) == ';')

#define WARNING_PREFIX              "Assuming NOT a POSIX class since "
#define NO_BLANKS_POSIX_WARNING     "no blanks are allowed in one"
#define SEMI_COLON_POSIX_WARNING    "a semi-colon was found instead of a colon"

#define NOT_MEANT_TO_BE_A_POSIX_CLASS (OOB_NAMEDCLASS - 1)

/* 'posix_warnings' and 'warn_text' are names of variables in the following
 * routine. q.v. */
#define ADD_POSIX_WARNING(p, text)  STMT_START {                            \
        if (posix_warnings) {                                               \
            if (! warn_text) warn_text = newAV();                           \
            av_push(warn_text, Perl_newSVpvf(aTHX_                          \
                                             WARNING_PREFIX                 \
                                             text                           \
                                             REPORT_LOCATION,               \
                                             REPORT_LOCATION_ARGS(p)));     \
        }                                                                   \
    } STMT_END

STATIC int
S_handle_possible_posix(pTHX_ RExC_state_t *pRExC_state,

    const char * const s,      /* Where the putative posix class begins.
                                  Normally, this is one past the '['.  This
                                  parameter exists so it can be somewhere
                                  besides RExC_parse. */
    char ** updated_parse_ptr, /* Where to set the updated parse pointer, or
                                  NULL */
    AV ** posix_warnings,      /* Where to place any generated warnings, or
                                  NULL */
    const bool check_only      /* Don't die if error */
)
{
    /* This parses what the caller thinks may be one of the three POSIX
     * constructs:
     *  1) a character class, like [:blank:]
     *  2) a collating symbol, like [. .]
     *  3) an equivalence class, like [= =]
     * In the latter two cases, it croaks if it finds a syntactically legal
     * one, as these are not handled by Perl.
     *
     * The main purpose is to look for a POSIX character class.  It returns:
     *  a) the class number
     *      if it is a completely syntactically and semantically legal class.
     *      'updated_parse_ptr', if not NULL, is set to point to just after the
     *      closing ']' of the class
     *  b) OOB_NAMEDCLASS
     *      if it appears that one of the three POSIX constructs was meant, but
     *      its specification was somehow defective.  'updated_parse_ptr', if
     *      not NULL, is set to point to the character just after the end
     *      character of the class.  See below for handling of warnings.
     *  c) NOT_MEANT_TO_BE_A_POSIX_CLASS
     *      if it  doesn't appear that a POSIX construct was intended.
     *      'updated_parse_ptr' is not changed.  No warnings nor errors are
     *      raised.
     *
     * In b) there may be errors or warnings generated.  If 'check_only' is
     * TRUE, then any errors are discarded.  Warnings are returned to the
     * caller via an AV* created into '*posix_warnings' if it is not NULL.  If
     * instead it is NULL, warnings are suppressed.  This is done in all
     * passes.  The reason for this is that the rest of the parsing is heavily
     * dependent on whether this routine found a valid posix class or not.  If
     * it did, the closing ']' is absorbed as part of the class.  If no class,
     * or an invalid one is found, any ']' will be considered the terminator of
     * the outer bracketed character class, leading to very different results.
     * In particular, a '(?[ ])' construct will likely have a syntax error if
     * the class is parsed other than intended, and this will happen in pass1,
     * before the warnings would normally be output.  This mechanism allows the
     * caller to output those warnings in pass1 just before dieing, giving a
     * much better clue as to what is wrong.
     *
     * The reason for this function, and its complexity is that a bracketed
     * character class can contain just about anything.  But it's easy to
     * mistype the very specific posix class syntax but yielding a valid
     * regular bracketed class, so it silently gets compiled into something
     * quite unintended.
     *
     * The solution adopted here maintains backward compatibility except that
     * it adds a warning if it looks like a posix class was intended but
     * improperly specified.  The warning is not raised unless what is input
     * very closely resembles one of the 14 legal posix classes.  To do this,
     * it uses fuzzy parsing.  It calculates how many single-character edits it
     * would take to transform what was input into a legal posix class.  Only
     * if that number is quite small does it think that the intention was a
     * posix class.  Obviously these are heuristics, and there will be cases
     * where it errs on one side or another, and they can be tweaked as
     * experience informs.
     *
     * The syntax for a legal posix class is:
     *
     * qr/(?xa: \[ : \^? [:lower:]{4,6} : \] )/
     *
     * What this routine considers syntactically to be an intended posix class
     * is this (the comments indicate some restrictions that the pattern
     * doesn't show):
     *
     *  qr/(?x: \[?                         # The left bracket, possibly
     *                                      # omitted
     *          \h*                         # possibly followed by blanks
     *          (?: \^ \h* )?               # possibly a misplaced caret
     *          [:;]?                       # The opening class character,
     *                                      # possibly omitted.  A typo
     *                                      # semi-colon can also be used.
     *          \h*
     *          \^?                         # possibly a correctly placed
     *                                      # caret, but not if there was also
     *                                      # a misplaced one
     *          \h*
     *          .{3,15}                     # The class name.  If there are
     *                                      # deviations from the legal syntax,
     *                                      # its edit distance must be close
     *                                      # to a real class name in order
     *                                      # for it to be considered to be
     *                                      # an intended posix class.
     *          \h*
     *          [:punct:]?                  # The closing class character,
     *                                      # possibly omitted.  If not a colon
     *                                      # nor semi colon, the class name
     *                                      # must be even closer to a valid
     *                                      # one
     *          \h*
     *          \]?                         # The right bracket, possibly
     *                                      # omitted.
     *     )/
     *
     * In the above, \h must be ASCII-only.
     *
     * These are heuristics, and can be tweaked as field experience dictates.
     * There will be cases when someone didn't intend to specify a posix class
     * that this warns as being so.  The goal is to minimize these, while
     * maximizing the catching of things intended to be a posix class that
     * aren't parsed as such.
     */

    const char* p             = s;
    const char * const e      = RExC_end;
    unsigned complement       = 0;      /* If to complement the class */
    bool found_problem        = FALSE;  /* Assume OK until proven otherwise */
    bool has_opening_bracket  = FALSE;
    bool has_opening_colon    = FALSE;
    int class_number          = OOB_NAMEDCLASS; /* Out-of-bounds until find
                                                   valid class */
    AV* warn_text             = NULL;   /* any warning messages */
    const char * possible_end = NULL;   /* used for a 2nd parse pass */
    const char* name_start;             /* ptr to class name first char */

    /* If the number of single-character typos the input name is away from a
     * legal name is no more than this number, it is considered to have meant
     * the legal name */
    int max_distance          = 2;

    /* to store the name.  The size determines the maximum length before we
     * decide that no posix class was intended.  Should be at least
     * sizeof("alphanumeric") */
    UV input_text[15];

    PERL_ARGS_ASSERT_HANDLE_POSSIBLE_POSIX;

    if (p >= e) {
        return NOT_MEANT_TO_BE_A_POSIX_CLASS;
    }

    if (*(p - 1) != '[') {
        ADD_POSIX_WARNING(p, "it doesn't start with a '['");
        found_problem = TRUE;
    }
    else {
        has_opening_bracket = TRUE;
    }

    /* They could be confused and think you can put spaces between the
     * components */
    if (isBLANK(*p)) {
        found_problem = TRUE;

        do {
            p++;
        } while (p < e && isBLANK(*p));

        ADD_POSIX_WARNING(p, NO_BLANKS_POSIX_WARNING);
    }

    /* For [. .] and [= =].  These are quite different internally from [: :],
     * so they are handled separately.  */
    if (POSIXCC_NOTYET(*p) && p < e - 3) /* 1 for the close, and 1 for the ']'
                                            and 1 for at least one char in it
                                          */
    {
        const char open_char  = *p;
        const char * temp_ptr = p + 1;

        /* These two constructs are not handled by perl, and if we find a
         * syntactically valid one, we croak.  khw, who wrote this code, finds
         * this explanation of them very unclear:
         * http://pubs.opengroup.org/onlinepubs/009696899/basedefs/xbd_chap09.html
         * And searching the rest of the internet wasn't very helpful either.
         * It looks like just about any byte can be in these constructs,
         * depending on the locale.  But unless the pattern is being compiled
         * under /l, which is very rare, Perl runs under the C or POSIX locale.
         * In that case, it looks like [= =] isn't allowed at all, and that
         * [. .] could be any single code point, but for longer strings the
         * constituent characters would have to be the ASCII alphabetics plus
         * the minus-hyphen.  Any sensible locale definition would limit itself
         * to these.  And any portable one definitely should.  Trying to parse
         * the general case is a nightmare (see [perl #127604]).  So, this code
         * looks only for interiors of these constructs that match:
         *      qr/.|[-\w]{2,}/
         * Using \w relaxes the apparent rules a little, without adding much
         * danger of mistaking something else for one of these constructs.
         *
         * [. .] in some implementations described on the internet is usable to
         * escape a character that otherwise is special in bracketed character
         * classes.  For example [.].] means a literal right bracket instead of
         * the ending of the class
         *
         * [= =] can legitimately contain a [. .] construct, but we don't
         * handle this case, as that [. .] construct will later get parsed
         * itself and croak then.  And [= =] is checked for even when not under
         * /l, as Perl has long done so.
         *
         * The code below relies on there being a trailing NUL, so it doesn't
         * have to keep checking if the parse ptr < e.
         */
        if (temp_ptr[1] == open_char) {
            temp_ptr++;
        }
        else while (    temp_ptr < e
                    && (isWORDCHAR(*temp_ptr) || *temp_ptr == '-'))
        {
            temp_ptr++;
        }

        if (*temp_ptr == open_char) {
            temp_ptr++;
            if (*temp_ptr == ']') {
                temp_ptr++;
                if (! found_problem && ! check_only) {
                    RExC_parse = (char *) temp_ptr;
                    vFAIL3("POSIX syntax [%c %c] is reserved for future "
                            "extensions", open_char, open_char);
                }

                /* Here, the syntax wasn't completely valid, or else the call
                 * is to check-only */
                if (updated_parse_ptr) {
                    *updated_parse_ptr = (char *) temp_ptr;
                }

                return OOB_NAMEDCLASS;
            }
        }

        /* If we find something that started out to look like one of these
         * constructs, but isn't, we continue below so that it can be checked
         * for being a class name with a typo of '.' or '=' instead of a colon.
         * */
    }

    /* Here, we think there is a possibility that a [: :] class was meant, and
     * we have the first real character.  It could be they think the '^' comes
     * first */
    if (*p == '^') {
        found_problem = TRUE;
        ADD_POSIX_WARNING(p + 1, "the '^' must come after the colon");
        complement = 1;
        p++;

        if (isBLANK(*p)) {
            found_problem = TRUE;

            do {
                p++;
            } while (p < e && isBLANK(*p));

            ADD_POSIX_WARNING(p, NO_BLANKS_POSIX_WARNING);
        }
    }

    /* But the first character should be a colon, which they could have easily
     * mistyped on a qwerty keyboard as a semi-colon (and which may be hard to
     * distinguish from a colon, so treat that as a colon).  */
    if (*p == ':') {
        p++;
        has_opening_colon = TRUE;
    }
    else if (*p == ';') {
        found_problem = TRUE;
        p++;
        ADD_POSIX_WARNING(p, SEMI_COLON_POSIX_WARNING);
        has_opening_colon = TRUE;
    }
    else {
        found_problem = TRUE;
        ADD_POSIX_WARNING(p, "there must be a starting ':'");

        /* Consider an initial punctuation (not one of the recognized ones) to
         * be a left terminator */
        if (*p != '^' && *p != ']' && isPUNCT(*p)) {
            p++;
        }
    }

    /* They may think that you can put spaces between the components */
    if (isBLANK(*p)) {
        found_problem = TRUE;

        do {
            p++;
        } while (p < e && isBLANK(*p));

        ADD_POSIX_WARNING(p, NO_BLANKS_POSIX_WARNING);
    }

    if (*p == '^') {

        /* We consider something like [^:^alnum:]] to not have been intended to
         * be a posix class, but XXX maybe we should */
        if (complement) {
            return NOT_MEANT_TO_BE_A_POSIX_CLASS;
        }

        complement = 1;
        p++;
    }

    /* Again, they may think that you can put spaces between the components */
    if (isBLANK(*p)) {
        found_problem = TRUE;

        do {
            p++;
        } while (p < e && isBLANK(*p));

        ADD_POSIX_WARNING(p, NO_BLANKS_POSIX_WARNING);
    }

    if (*p == ']') {

        /* XXX This ']' may be a typo, and something else was meant.  But
         * treating it as such creates enough complications, that that
         * possibility isn't currently considered here.  So we assume that the
         * ']' is what is intended, and if we've already found an initial '[',
         * this leaves this construct looking like [:] or [:^], which almost
         * certainly weren't intended to be posix classes */
        if (has_opening_bracket) {
            return NOT_MEANT_TO_BE_A_POSIX_CLASS;
        }

        /* But this function can be called when we parse the colon for
         * something like qr/[alpha:]]/, so we back up to look for the
         * beginning */
        p--;

        if (*p == ';') {
            found_problem = TRUE;
            ADD_POSIX_WARNING(p, SEMI_COLON_POSIX_WARNING);
        }
        else if (*p != ':') {

            /* XXX We are currently very restrictive here, so this code doesn't
             * consider the possibility that, say, /[alpha.]]/ was intended to
             * be a posix class. */
            return NOT_MEANT_TO_BE_A_POSIX_CLASS;
        }

        /* Here we have something like 'foo:]'.  There was no initial colon,
         * and we back up over 'foo.  XXX Unlike the going forward case, we
         * don't handle typos of non-word chars in the middle */
        has_opening_colon = FALSE;
        p--;

        while (p > RExC_start && isWORDCHAR(*p)) {
            p--;
        }
        p++;

        /* Here, we have positioned ourselves to where we think the first
         * character in the potential class is */
    }

    /* Now the interior really starts.  There are certain key characters that
     * can end the interior, or these could just be typos.  To catch both
     * cases, we may have to do two passes.  In the first pass, we keep on
     * going unless we come to a sequence that matches
     *      qr/ [[:punct:]] [[:blank:]]* \] /xa
     * This means it takes a sequence to end the pass, so two typos in a row if
     * that wasn't what was intended.  If the class is perfectly formed, just
     * this one pass is needed.  We also stop if there are too many characters
     * being accumulated, but this number is deliberately set higher than any
     * real class.  It is set high enough so that someone who thinks that
     * 'alphanumeric' is a correct name would get warned that it wasn't.
     * While doing the pass, we keep track of where the key characters were in
     * it.  If we don't find an end to the class, and one of the key characters
     * was found, we redo the pass, but stop when we get to that character.
     * Thus the key character was considered a typo in the first pass, but a
     * terminator in the second.  If two key characters are found, we stop at
     * the second one in the first pass.  Again this can miss two typos, but
     * catches a single one
     *
     * In the first pass, 'possible_end' starts as NULL, and then gets set to
     * point to the first key character.  For the second pass, it starts as -1.
     * */

    name_start = p;
  parse_name:
    {
        bool has_blank               = FALSE;
        bool has_upper               = FALSE;
        bool has_terminating_colon   = FALSE;
        bool has_terminating_bracket = FALSE;
        bool has_semi_colon          = FALSE;
        unsigned int name_len        = 0;
        int punct_count              = 0;

        while (p < e) {

            /* Squeeze out blanks when looking up the class name below */
            if (isBLANK(*p) ) {
                has_blank = TRUE;
                found_problem = TRUE;
                p++;
                continue;
            }

            /* The name will end with a punctuation */
            if (isPUNCT(*p)) {
                const char * peek = p + 1;

                /* Treat any non-']' punctuation followed by a ']' (possibly
                 * with intervening blanks) as trying to terminate the class.
                 * ']]' is very likely to mean a class was intended (but
                 * missing the colon), but the warning message that gets
                 * generated shows the error position better if we exit the
                 * loop at the bottom (eventually), so skip it here. */
                if (*p != ']') {
                    if (peek < e && isBLANK(*peek)) {
                        has_blank = TRUE;
                        found_problem = TRUE;
                        do {
                            peek++;
                        } while (peek < e && isBLANK(*peek));
                    }

                    if (peek < e && *peek == ']') {
                        has_terminating_bracket = TRUE;
                        if (*p == ':') {
                            has_terminating_colon = TRUE;
                        }
                        else if (*p == ';') {
                            has_semi_colon = TRUE;
                            has_terminating_colon = TRUE;
                        }
                        else {
                            found_problem = TRUE;
                        }
                        p = peek + 1;
                        goto try_posix;
                    }
                }

                /* Here we have punctuation we thought didn't end the class.
                 * Keep track of the position of the key characters that are
                 * more likely to have been class-enders */
                if (*p == ']' || *p == '[' || *p == ':' || *p == ';') {

                    /* Allow just one such possible class-ender not actually
                     * ending the class. */
                    if (possible_end) {
                        break;
                    }
                    possible_end = p;
                }

                /* If we have too many punctuation characters, no use in
                 * keeping going */
                if (++punct_count > max_distance) {
                    break;
                }

                /* Treat the punctuation as a typo. */
                input_text[name_len++] = *p;
                p++;
            }
            else if (isUPPER(*p)) { /* Use lowercase for lookup */
                input_text[name_len++] = toLOWER(*p);
                has_upper = TRUE;
                found_problem = TRUE;
                p++;
            } else if (! UTF || UTF8_IS_INVARIANT(*p)) {
                input_text[name_len++] = *p;
                p++;
            }
            else {
                input_text[name_len++] = utf8_to_uvchr_buf((U8 *) p, e, NULL);
                p+= UTF8SKIP(p);
            }

            /* The declaration of 'input_text' is how long we allow a potential
             * class name to be, before saying they didn't mean a class name at
             * all */
            if (name_len >= C_ARRAY_LENGTH(input_text)) {
                break;
            }
        }

        /* We get to here when the possible class name hasn't been properly
         * terminated before:
         *   1) we ran off the end of the pattern; or
         *   2) found two characters, each of which might have been intended to
         *      be the name's terminator
         *   3) found so many punctuation characters in the purported name,
         *      that the edit distance to a valid one is exceeded
         *   4) we decided it was more characters than anyone could have
         *      intended to be one. */

        found_problem = TRUE;

        /* In the final two cases, we know that looking up what we've
         * accumulated won't lead to a match, even a fuzzy one. */
        if (   name_len >= C_ARRAY_LENGTH(input_text)
            || punct_count > max_distance)
        {
            /* If there was an intermediate key character that could have been
             * an intended end, redo the parse, but stop there */
            if (possible_end && possible_end != (char *) -1) {
                possible_end = (char *) -1; /* Special signal value to say
                                               we've done a first pass */
                p = name_start;
                goto parse_name;
            }

            /* Otherwise, it can't have meant to have been a class */
            return NOT_MEANT_TO_BE_A_POSIX_CLASS;
        }

        /* If we ran off the end, and the final character was a punctuation
         * one, back up one, to look at that final one just below.  Later, we
         * will restore the parse pointer if appropriate */
        if (name_len && p == e && isPUNCT(*(p-1))) {
            p--;
            name_len--;
        }

        if (p < e && isPUNCT(*p)) {
            if (*p == ']') {
                has_terminating_bracket = TRUE;

                /* If this is a 2nd ']', and the first one is just below this
                 * one, consider that to be the real terminator.  This gives a
                 * uniform and better positioning for the warning message  */
                if (   possible_end
                    && possible_end != (char *) -1
                    && *possible_end == ']'
                    && name_len && input_text[name_len - 1] == ']')
                {
                    name_len--;
                    p = possible_end;

                    /* And this is actually equivalent to having done the 2nd
                     * pass now, so set it to not try again */
                    possible_end = (char *) -1;
                }
            }
            else {
                if (*p == ':') {
                    has_terminating_colon = TRUE;
                }
                else if (*p == ';') {
                    has_semi_colon = TRUE;
                    has_terminating_colon = TRUE;
                }
                p++;
            }
        }

    try_posix:

        /* Here, we have a class name to look up.  We can short circuit the
         * stuff below for short names that can't possibly be meant to be a
         * class name.  (We can do this on the first pass, as any second pass
         * will yield an even shorter name) */
        if (name_len < 3) {
            return NOT_MEANT_TO_BE_A_POSIX_CLASS;
        }

        /* Find which class it is.  Initially switch on the length of the name.
         * */
        switch (name_len) {
            case 4:
                if (memEQ(name_start, "word", 4)) {
                    /* this is not POSIX, this is the Perl \w */
                    class_number = ANYOF_WORDCHAR;
                }
                break;
            case 5:
                /* Names all of length 5: alnum alpha ascii blank cntrl digit
                 *                        graph lower print punct space upper
                 * Offset 4 gives the best switch position.  */
                switch (name_start[4]) {
                    case 'a':
                        if (memEQ(name_start, "alph", 4)) /* alpha */
                            class_number = ANYOF_ALPHA;
                        break;
                    case 'e':
                        if (memEQ(name_start, "spac", 4)) /* space */
                            class_number = ANYOF_SPACE;
                        break;
                    case 'h':
                        if (memEQ(name_start, "grap", 4)) /* graph */
                            class_number = ANYOF_GRAPH;
                        break;
                    case 'i':
                        if (memEQ(name_start, "asci", 4)) /* ascii */
                            class_number = ANYOF_ASCII;
                        break;
                    case 'k':
                        if (memEQ(name_start, "blan", 4)) /* blank */
                            class_number = ANYOF_BLANK;
                        break;
                    case 'l':
                        if (memEQ(name_start, "cntr", 4)) /* cntrl */
                            class_number = ANYOF_CNTRL;
                        break;
                    case 'm':
                        if (memEQ(name_start, "alnu", 4)) /* alnum */
                            class_number = ANYOF_ALPHANUMERIC;
                        break;
                    case 'r':
                        if (memEQ(name_start, "lowe", 4)) /* lower */
                            class_number = (FOLD) ? ANYOF_CASED : ANYOF_LOWER;
                        else if (memEQ(name_start, "uppe", 4)) /* upper */
                            class_number = (FOLD) ? ANYOF_CASED : ANYOF_UPPER;
                        break;
                    case 't':
                        if (memEQ(name_start, "digi", 4)) /* digit */
                            class_number = ANYOF_DIGIT;
                        else if (memEQ(name_start, "prin", 4)) /* print */
                            class_number = ANYOF_PRINT;
                        else if (memEQ(name_start, "punc", 4)) /* punct */
                            class_number = ANYOF_PUNCT;
                        break;
                }
                break;
            case 6:
                if (memEQ(name_start, "xdigit", 6))
                    class_number = ANYOF_XDIGIT;
                break;
        }

        /* If the name exactly matches a posix class name the class number will
         * here be set to it, and the input almost certainly was meant to be a
         * posix class, so we can skip further checking.  If instead the syntax
         * is exactly correct, but the name isn't one of the legal ones, we
         * will return that as an error below.  But if neither of these apply,
         * it could be that no posix class was intended at all, or that one
         * was, but there was a typo.  We tease these apart by doing fuzzy
         * matching on the name */
        if (class_number == OOB_NAMEDCLASS && found_problem) {
            const UV posix_names[][6] = {
                                                { 'a', 'l', 'n', 'u', 'm' },
                                                { 'a', 'l', 'p', 'h', 'a' },
                                                { 'a', 's', 'c', 'i', 'i' },
                                                { 'b', 'l', 'a', 'n', 'k' },
                                                { 'c', 'n', 't', 'r', 'l' },
                                                { 'd', 'i', 'g', 'i', 't' },
                                                { 'g', 'r', 'a', 'p', 'h' },
                                                { 'l', 'o', 'w', 'e', 'r' },
                                                { 'p', 'r', 'i', 'n', 't' },
                                                { 'p', 'u', 'n', 'c', 't' },
                                                { 's', 'p', 'a', 'c', 'e' },
                                                { 'u', 'p', 'p', 'e', 'r' },
                                                { 'w', 'o', 'r', 'd' },
                                                { 'x', 'd', 'i', 'g', 'i', 't' }
                                            };
            /* The names of the above all have added NULs to make them the same
             * size, so we need to also have the real lengths */
            const UV posix_name_lengths[] = {
                                                sizeof("alnum") - 1,
                                                sizeof("alpha") - 1,
                                                sizeof("ascii") - 1,
                                                sizeof("blank") - 1,
                                                sizeof("cntrl") - 1,
                                                sizeof("digit") - 1,
                                                sizeof("graph") - 1,
                                                sizeof("lower") - 1,
                                                sizeof("print") - 1,
                                                sizeof("punct") - 1,
                                                sizeof("space") - 1,
                                                sizeof("upper") - 1,
                                                sizeof("word")  - 1,
                                                sizeof("xdigit")- 1
                                            };
            unsigned int i;
            int temp_max = max_distance;    /* Use a temporary, so if we
                                               reparse, we haven't changed the
                                               outer one */

            /* Use a smaller max edit distance if we are missing one of the
             * delimiters */
            if (   has_opening_bracket + has_opening_colon < 2
                || has_terminating_bracket + has_terminating_colon < 2)
            {
                temp_max--;
            }

            /* See if the input name is close to a legal one */
            for (i = 0; i < C_ARRAY_LENGTH(posix_names); i++) {

                /* Short circuit call if the lengths are too far apart to be
                 * able to match */
                if (abs( (int) (name_len - posix_name_lengths[i]))
                    > temp_max)
                {
                    continue;
                }

                if (edit_distance(input_text,
                                  posix_names[i],
                                  name_len,
                                  posix_name_lengths[i],
                                  temp_max
                                 )
                    > -1)
                { /* If it is close, it probably was intended to be a class */
                    goto probably_meant_to_be;
                }
            }

            /* Here the input name is not close enough to a valid class name
             * for us to consider it to be intended to be a posix class.  If
             * we haven't already done so, and the parse found a character that
             * could have been terminators for the name, but which we absorbed
             * as typos during the first pass, repeat the parse, signalling it
             * to stop at that character */
            if (possible_end && possible_end != (char *) -1) {
                possible_end = (char *) -1;
                p = name_start;
                goto parse_name;
            }

            /* Here neither pass found a close-enough class name */
            return NOT_MEANT_TO_BE_A_POSIX_CLASS;
        }

    probably_meant_to_be:

        /* Here we think that a posix specification was intended.  Update any
         * parse pointer */
        if (updated_parse_ptr) {
            *updated_parse_ptr = (char *) p;
        }

        /* If a posix class name was intended but incorrectly specified, we
         * output or return the warnings */
        if (found_problem) {

            /* We set flags for these issues in the parse loop above instead of
             * adding them to the list of warnings, because we can parse it
             * twice, and we only want one warning instance */
            if (has_upper) {
                ADD_POSIX_WARNING(p, "the name must be all lowercase letters");
            }
            if (has_blank) {
                ADD_POSIX_WARNING(p, NO_BLANKS_POSIX_WARNING);
            }
            if (has_semi_colon) {
                ADD_POSIX_WARNING(p, SEMI_COLON_POSIX_WARNING);
            }
            else if (! has_terminating_colon) {
                ADD_POSIX_WARNING(p, "there is no terminating ':'");
            }
            if (! has_terminating_bracket) {
                ADD_POSIX_WARNING(p, "there is no terminating ']'");
            }

            if (warn_text) {
                if (posix_warnings) {
                    /* mortalize to avoid a leak with FATAL warnings */
                    *posix_warnings = (AV *) sv_2mortal((SV *) warn_text);
                }
                else {
                    SvREFCNT_dec_NN(warn_text);
                }
            }
        }
        else if (class_number != OOB_NAMEDCLASS) {
            /* If it is a known class, return the class.  The class number
             * #defines are structured so each complement is +1 to the normal
             * one */
            return class_number + complement;
        }
        else if (! check_only) {

            /* Here, it is an unrecognized class.  This is an error (unless the
            * call is to check only, which we've already handled above) */
            const char * const complement_string = (complement)
                                                   ? "^"
                                                   : "";
            RExC_parse = (char *) p;
            vFAIL3utf8f("POSIX class [:%s%"UTF8f":] unknown",
                        complement_string,
                        UTF8fARG(UTF, RExC_parse - name_start - 2, name_start));
        }
    }

    return OOB_NAMEDCLASS;
}
#undef ADD_POSIX_WARNING

STATIC unsigned  int
S_regex_set_precedence(const U8 my_operator) {

    /* Returns the precedence in the (?[...]) construct of the input operator,
     * specified by its character representation.  The precedence follows
     * general Perl rules, but it extends this so that ')' and ']' have (low)
     * precedence even though they aren't really operators */

    switch (my_operator) {
        case '!':
            return 5;
        case '&':
            return 4;
        case '^':
        case '|':
        case '+':
        case '-':
            return 3;
        case ')':
            return 2;
        case ']':
            return 1;
    }

    NOT_REACHED; /* NOTREACHED */
    return 0;   /* Silence compiler warning */
}

STATIC regnode *
S_handle_regex_sets(pTHX_ RExC_state_t *pRExC_state, SV** return_invlist,
                    I32 *flagp, U32 depth,
                    char * const oregcomp_parse)
{
    /* Handle the (?[...]) construct to do set operations */

    U8 curchar;                     /* Current character being parsed */
    UV start, end;	            /* End points of code point ranges */
    SV* final = NULL;               /* The end result inversion list */
    SV* result_string;              /* 'final' stringified */
    AV* stack;                      /* stack of operators and operands not yet
                                       resolved */
    AV* fence_stack = NULL;         /* A stack containing the positions in
                                       'stack' of where the undealt-with left
                                       parens would be if they were actually
                                       put there */
    /* The 'VOL' (expanding to 'volatile') is a workaround for an optimiser bug
     * in Solaris Studio 12.3. See RT #127455 */
    VOL IV fence = 0;               /* Position of where most recent undealt-
                                       with left paren in stack is; -1 if none.
                                     */
    STRLEN len;                     /* Temporary */
    regnode* node;                  /* Temporary, and final regnode returned by
                                       this function */
    const bool save_fold = FOLD;    /* Temporary */
    char *save_end, *save_parse;    /* Temporaries */
    const bool in_locale = LOC;     /* we turn off /l during processing */
    AV* posix_warnings = NULL;

    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_HANDLE_REGEX_SETS;

    if (in_locale) {
        set_regex_charset(&RExC_flags, REGEX_UNICODE_CHARSET);
    }

    REQUIRE_UNI_RULES(flagp, NULL);   /* The use of this operator implies /u.
                                         This is required so that the compile
                                         time values are valid in all runtime
                                         cases */

    /* This will return only an ANYOF regnode, or (unlikely) something smaller
     * (such as EXACT).  Thus we can skip most everything if just sizing.  We
     * call regclass to handle '[]' so as to not have to reinvent its parsing
     * rules here (throwing away the size it computes each time).  And, we exit
     * upon an unescaped ']' that isn't one ending a regclass.  To do both
     * these things, we need to realize that something preceded by a backslash
     * is escaped, so we have to keep track of backslashes */
    if (SIZE_ONLY) {
        UV depth = 0; /* how many nested (?[...]) constructs */

        while (RExC_parse < RExC_end) {
            SV* current = NULL;

            skip_to_be_ignored_text(pRExC_state, &RExC_parse,
                                    TRUE /* Force /x */ );

            switch (*RExC_parse) {
                case '?':
                    if (RExC_parse[1] == '[') depth++, RExC_parse++;
                    /* FALLTHROUGH */
                default:
                    break;
                case '\\':
                    /* Skip past this, so the next character gets skipped, after
                     * the switch */
                    RExC_parse++;
                    if (*RExC_parse == 'c') {
                            /* Skip the \cX notation for control characters */
                            RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;
                    }
                    break;

                case '[':
                {
                    /* See if this is a [:posix:] class. */
                    bool is_posix_class = (OOB_NAMEDCLASS
                            < handle_possible_posix(pRExC_state,
                                                RExC_parse + 1,
                                                NULL,
                                                NULL,
                                                TRUE /* checking only */));
                    /* If it is a posix class, leave the parse pointer at the
                     * '[' to fool regclass() into thinking it is part of a
                     * '[[:posix:]]'. */
                    if (! is_posix_class) {
                        RExC_parse++;
                    }

                    /* regclass() can only return RESTART_PASS1 and NEED_UTF8
                     * if multi-char folds are allowed.  */
                    if (!regclass(pRExC_state, flagp,depth+1,
                                  is_posix_class, /* parse the whole char
                                                     class only if not a
                                                     posix class */
                                  FALSE, /* don't allow multi-char folds */
                                  TRUE, /* silence non-portable warnings. */
                                  TRUE, /* strict */
                                  FALSE, /* Require return to be an ANYOF */
                                  &current,
                                  &posix_warnings
                                 ))
                        FAIL2("panic: regclass returned NULL to handle_sets, "
                              "flags=%#"UVxf"", (UV) *flagp);

                    /* function call leaves parse pointing to the ']', except
                     * if we faked it */
                    if (is_posix_class) {
                        RExC_parse--;
                    }

                    SvREFCNT_dec(current);   /* In case it returned something */
                    break;
                }

                case ']':
                    if (depth--) break;
                    RExC_parse++;
                    if (*RExC_parse == ')') {
                        node = reganode(pRExC_state, ANYOF, 0);
                        RExC_size += ANYOF_SKIP;
                        nextchar(pRExC_state);
                        Set_Node_Length(node,
                                RExC_parse - oregcomp_parse + 1); /* MJD */
                        if (in_locale) {
                            set_regex_charset(&RExC_flags, REGEX_LOCALE_CHARSET);
                        }

                        return node;
                    }
                    goto no_close;
            }

            RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;
        }

      no_close:
        /* We output the messages even if warnings are off, because we'll fail
         * the very next thing, and these give a likely diagnosis for that */
        if (posix_warnings && av_tindex_nomg(posix_warnings) >= 0) {
            output_or_return_posix_warnings(pRExC_state, posix_warnings, NULL);
        }

        FAIL("Syntax error in (?[...])");
    }

    /* Pass 2 only after this. */
    Perl_ck_warner_d(aTHX_
        packWARN(WARN_EXPERIMENTAL__REGEX_SETS),
        "The regex_sets feature is experimental" REPORT_LOCATION,
        REPORT_LOCATION_ARGS(RExC_parse));

    /* Everything in this construct is a metacharacter.  Operands begin with
     * either a '\' (for an escape sequence), or a '[' for a bracketed
     * character class.  Any other character should be an operator, or
     * parenthesis for grouping.  Both types of operands are handled by calling
     * regclass() to parse them.  It is called with a parameter to indicate to
     * return the computed inversion list.  The parsing here is implemented via
     * a stack.  Each entry on the stack is a single character representing one
     * of the operators; or else a pointer to an operand inversion list. */

#define IS_OPERATOR(a) SvIOK(a)
#define IS_OPERAND(a)  (! IS_OPERATOR(a))

    /* The stack is kept in Łukasiewicz order.  (That's pronounced similar
     * to luke-a-shave-itch (or -itz), but people who didn't want to bother
     * with pronouncing it called it Reverse Polish instead, but now that YOU
     * know how to pronounce it you can use the correct term, thus giving due
     * credit to the person who invented it, and impressing your geek friends.
     * Wikipedia says that the pronounciation of "Ł" has been changing so that
     * it is now more like an English initial W (as in wonk) than an L.)
     *
     * This means that, for example, 'a | b & c' is stored on the stack as
     *
     * c  [4]
     * b  [3]
     * &  [2]
     * a  [1]
     * |  [0]
     *
     * where the numbers in brackets give the stack [array] element number.
     * In this implementation, parentheses are not stored on the stack.
     * Instead a '(' creates a "fence" so that the part of the stack below the
     * fence is invisible except to the corresponding ')' (this allows us to
     * replace testing for parens, by using instead subtraction of the fence
     * position).  As new operands are processed they are pushed onto the stack
     * (except as noted in the next paragraph).  New operators of higher
     * precedence than the current final one are inserted on the stack before
     * the lhs operand (so that when the rhs is pushed next, everything will be
     * in the correct positions shown above.  When an operator of equal or
     * lower precedence is encountered in parsing, all the stacked operations
     * of equal or higher precedence are evaluated, leaving the result as the
     * top entry on the stack.  This makes higher precedence operations
     * evaluate before lower precedence ones, and causes operations of equal
     * precedence to left associate.
     *
     * The only unary operator '!' is immediately pushed onto the stack when
     * encountered.  When an operand is encountered, if the top of the stack is
     * a '!", the complement is immediately performed, and the '!' popped.  The
     * resulting value is treated as a new operand, and the logic in the
     * previous paragraph is executed.  Thus in the expression
     *      [a] + ! [b]
     * the stack looks like
     *
     * !
     * a
     * +
     *
     * as 'b' gets parsed, the latter gets evaluated to '!b', and the stack
     * becomes
     *
     * !b
     * a
     * +
     *
     * A ')' is treated as an operator with lower precedence than all the
     * aforementioned ones, which causes all operations on the stack above the
     * corresponding '(' to be evaluated down to a single resultant operand.
     * Then the fence for the '(' is removed, and the operand goes through the
     * algorithm above, without the fence.
     *
     * A separate stack is kept of the fence positions, so that the position of
     * the latest so-far unbalanced '(' is at the top of it.
     *
     * The ']' ending the construct is treated as the lowest operator of all,
     * so that everything gets evaluated down to a single operand, which is the
     * result */

    sv_2mortal((SV *)(stack = newAV()));
    sv_2mortal((SV *)(fence_stack = newAV()));

    while (RExC_parse < RExC_end) {
        I32 top_index;              /* Index of top-most element in 'stack' */
        SV** top_ptr;               /* Pointer to top 'stack' element */
        SV* current = NULL;         /* To contain the current inversion list
                                       operand */
        SV* only_to_avoid_leaks;

        skip_to_be_ignored_text(pRExC_state, &RExC_parse,
                                TRUE /* Force /x */ );
        if (RExC_parse >= RExC_end) {
            Perl_croak(aTHX_ "panic: Read past end of '(?[ ])'");
        }

        curchar = UCHARAT(RExC_parse);

redo_curchar:

        top_index = av_tindex_nomg(stack);

        switch (curchar) {
            SV** stacked_ptr;       /* Ptr to something already on 'stack' */
            char stacked_operator;  /* The topmost operator on the 'stack'. */
            SV* lhs;                /* Operand to the left of the operator */
            SV* rhs;                /* Operand to the right of the operator */
            SV* fence_ptr;          /* Pointer to top element of the fence
                                       stack */

            case '(':

                if (   RExC_parse < RExC_end - 1
                    && (UCHARAT(RExC_parse + 1) == '?'))
                {
                    /* If is a '(?', could be an embedded '(?flags:(?[...])'.
                     * This happens when we have some thing like
                     *
                     *   my $thai_or_lao = qr/(?[ \p{Thai} + \p{Lao} ])/;
                     *   ...
                     *   qr/(?[ \p{Digit} & $thai_or_lao ])/;
                     *
                     * Here we would be handling the interpolated
                     * '$thai_or_lao'.  We handle this by a recursive call to
                     * ourselves which returns the inversion list the
                     * interpolated expression evaluates to.  We use the flags
                     * from the interpolated pattern. */
                    U32 save_flags = RExC_flags;
                    const char * save_parse;

                    RExC_parse += 2;        /* Skip past the '(?' */
                    save_parse = RExC_parse;

                    /* Parse any flags for the '(?' */
                    parse_lparen_question_flags(pRExC_state);

                    if (RExC_parse == save_parse  /* Makes sure there was at
                                                     least one flag (or else
                                                     this embedding wasn't
                                                     compiled) */
                        || RExC_parse >= RExC_end - 4
                        || UCHARAT(RExC_parse) != ':'
                        || UCHARAT(++RExC_parse) != '('
                        || UCHARAT(++RExC_parse) != '?'
                        || UCHARAT(++RExC_parse) != '[')
                    {

                        /* In combination with the above, this moves the
                         * pointer to the point just after the first erroneous
                         * character (or if there are no flags, to where they
                         * should have been) */
                        if (RExC_parse >= RExC_end - 4) {
                            RExC_parse = RExC_end;
                        }
                        else if (RExC_parse != save_parse) {
                            RExC_parse += (UTF) ? UTF8SKIP(RExC_parse) : 1;
                        }
                        vFAIL("Expecting '(?flags:(?[...'");
                    }

                    /* Recurse, with the meat of the embedded expression */
                    RExC_parse++;
                    (void) handle_regex_sets(pRExC_state, &current, flagp,
                                                    depth+1, oregcomp_parse);

                    /* Here, 'current' contains the embedded expression's
                     * inversion list, and RExC_parse points to the trailing
                     * ']'; the next character should be the ')' */
                    RExC_parse++;
                    assert(UCHARAT(RExC_parse) == ')');

                    /* Then the ')' matching the original '(' handled by this
                     * case: statement */
                    RExC_parse++;
                    assert(UCHARAT(RExC_parse) == ')');

                    RExC_parse++;
                    RExC_flags = save_flags;
                    goto handle_operand;
                }

                /* A regular '('.  Look behind for illegal syntax */
                if (top_index - fence >= 0) {
                    /* If the top entry on the stack is an operator, it had
                     * better be a '!', otherwise the entry below the top
                     * operand should be an operator */
                    if (   ! (top_ptr = av_fetch(stack, top_index, FALSE))
                        || (IS_OPERATOR(*top_ptr) && SvUV(*top_ptr) != '!')
                        || (   IS_OPERAND(*top_ptr)
                            && (   top_index - fence < 1
                                || ! (stacked_ptr = av_fetch(stack,
                                                             top_index - 1,
                                                             FALSE))
                                || ! IS_OPERATOR(*stacked_ptr))))
                    {
                        RExC_parse++;
                        vFAIL("Unexpected '(' with no preceding operator");
                    }
                }

                /* Stack the position of this undealt-with left paren */
                fence = top_index + 1;
                av_push(fence_stack, newSViv(fence));
                break;

            case '\\':
                /* regclass() can only return RESTART_PASS1 and NEED_UTF8 if
                 * multi-char folds are allowed.  */
                if (!regclass(pRExC_state, flagp,depth+1,
                              TRUE, /* means parse just the next thing */
                              FALSE, /* don't allow multi-char folds */
                              FALSE, /* don't silence non-portable warnings.  */
                              TRUE,  /* strict */
                              FALSE, /* Require return to be an ANYOF */
                              &current,
                              NULL))
                {
                    FAIL2("panic: regclass returned NULL to handle_sets, "
                          "flags=%#"UVxf"", (UV) *flagp);
                }

                /* regclass() will return with parsing just the \ sequence,
                 * leaving the parse pointer at the next thing to parse */
                RExC_parse--;
                goto handle_operand;

            case '[':   /* Is a bracketed character class */
            {
                /* See if this is a [:posix:] class. */
                bool is_posix_class = (OOB_NAMEDCLASS
                            < handle_possible_posix(pRExC_state,
                                                RExC_parse + 1,
                                                NULL,
                                                NULL,
                                                TRUE /* checking only */));
                /* If it is a posix class, leave the parse pointer at the '['
                 * to fool regclass() into thinking it is part of a
                 * '[[:posix:]]'. */
                if (! is_posix_class) {
                    RExC_parse++;
                }

                /* regclass() can only return RESTART_PASS1 and NEED_UTF8 if
                 * multi-char folds are allowed.  */
                if (!regclass(pRExC_state, flagp,depth+1,
                                is_posix_class, /* parse the whole char
                                                    class only if not a
                                                    posix class */
                                FALSE, /* don't allow multi-char folds */
                                TRUE, /* silence non-portable warnings. */
                                TRUE, /* strict */
                                FALSE, /* Require return to be an ANYOF */
                                &current,
                                NULL
                                ))
                {
                    FAIL2("panic: regclass returned NULL to handle_sets, "
                          "flags=%#"UVxf"", (UV) *flagp);
                }

                /* function call leaves parse pointing to the ']', except if we
                 * faked it */
                if (is_posix_class) {
                    RExC_parse--;
                }

                goto handle_operand;
            }

            case ']':
                if (top_index >= 1) {
                    goto join_operators;
                }

                /* Only a single operand on the stack: are done */
                goto done;

            case ')':
                if (av_tindex_nomg(fence_stack) < 0) {
                    RExC_parse++;
                    vFAIL("Unexpected ')'");
                }

                 /* If at least two thing on the stack, treat this as an
                  * operator */
                if (top_index - fence >= 1) {
                    goto join_operators;
                }

                /* Here only a single thing on the fenced stack, and there is a
                 * fence.  Get rid of it */
                fence_ptr = av_pop(fence_stack);
                assert(fence_ptr);
                fence = SvIV(fence_ptr) - 1;
                SvREFCNT_dec_NN(fence_ptr);
                fence_ptr = NULL;

                if (fence < 0) {
                    fence = 0;
                }

                /* Having gotten rid of the fence, we pop the operand at the
                 * stack top and process it as a newly encountered operand */
                current = av_pop(stack);
                if (IS_OPERAND(current)) {
                    goto handle_operand;
                }

                RExC_parse++;
                goto bad_syntax;

            case '&':
            case '|':
            case '+':
            case '-':
            case '^':

                /* These binary operators should have a left operand already
                 * parsed */
                if (   top_index - fence < 0
                    || top_index - fence == 1
                    || ( ! (top_ptr = av_fetch(stack, top_index, FALSE)))
                    || ! IS_OPERAND(*top_ptr))
                {
                    goto unexpected_binary;
                }

                /* If only the one operand is on the part of the stack visible
                 * to us, we just place this operator in the proper position */
                if (top_index - fence < 2) {

                    /* Place the operator before the operand */

                    SV* lhs = av_pop(stack);
                    av_push(stack, newSVuv(curchar));
                    av_push(stack, lhs);
                    break;
                }

                /* But if there is something else on the stack, we need to
                 * process it before this new operator if and only if the
                 * stacked operation has equal or higher precedence than the
                 * new one */

             join_operators:

                /* The operator on the stack is supposed to be below both its
                 * operands */
                if (   ! (stacked_ptr = av_fetch(stack, top_index - 2, FALSE))
                    || IS_OPERAND(*stacked_ptr))
                {
                    /* But if not, it's legal and indicates we are completely
                     * done if and only if we're currently processing a ']',
                     * which should be the final thing in the expression */
                    if (curchar == ']') {
                        goto done;
                    }

                  unexpected_binary:
                    RExC_parse++;
                    vFAIL2("Unexpected binary operator '%c' with no "
                           "preceding operand", curchar);
                }
                stacked_operator = (char) SvUV(*stacked_ptr);

                if (regex_set_precedence(curchar)
                    > regex_set_precedence(stacked_operator))
                {
                    /* Here, the new operator has higher precedence than the
                     * stacked one.  This means we need to add the new one to
                     * the stack to await its rhs operand (and maybe more
                     * stuff).  We put it before the lhs operand, leaving
                     * untouched the stacked operator and everything below it
                     * */
                    lhs = av_pop(stack);
                    assert(IS_OPERAND(lhs));

                    av_push(stack, newSVuv(curchar));
                    av_push(stack, lhs);
                    break;
                }

                /* Here, the new operator has equal or lower precedence than
                 * what's already there.  This means the operation already
                 * there should be performed now, before the new one. */

                rhs = av_pop(stack);
                if (! IS_OPERAND(rhs)) {

                    /* This can happen when a ! is not followed by an operand,
                     * like in /(?[\t &!])/ */
                    goto bad_syntax;
                }

                lhs = av_pop(stack);

                if (! IS_OPERAND(lhs)) {

                    /* This can happen when there is an empty (), like in
                     * /(?[[0]+()+])/ */
                    goto bad_syntax;
                }

                switch (stacked_operator) {
                    case '&':
                        _invlist_intersection(lhs, rhs, &rhs);
                        break;

                    case '|':
                    case '+':
                        _invlist_union(lhs, rhs, &rhs);
                        break;

                    case '-':
                        _invlist_subtract(lhs, rhs, &rhs);
                        break;

                    case '^':   /* The union minus the intersection */
                    {
                        SV* i = NULL;
                        SV* u = NULL;
                        SV* element;

                        _invlist_union(lhs, rhs, &u);
                        _invlist_intersection(lhs, rhs, &i);
                        /* _invlist_subtract will overwrite rhs
                            without freeing what it already contains */
                        element = rhs;
                        _invlist_subtract(u, i, &rhs);
                        SvREFCNT_dec_NN(i);
                        SvREFCNT_dec_NN(u);
                        SvREFCNT_dec_NN(element);
                        break;
                    }
                }
                SvREFCNT_dec(lhs);

                /* Here, the higher precedence operation has been done, and the
                 * result is in 'rhs'.  We overwrite the stacked operator with
                 * the result.  Then we redo this code to either push the new
                 * operator onto the stack or perform any higher precedence
                 * stacked operation */
                only_to_avoid_leaks = av_pop(stack);
                SvREFCNT_dec(only_to_avoid_leaks);
                av_push(stack, rhs);
                goto redo_curchar;

            case '!':   /* Highest priority, right associative */

                /* If what's already at the top of the stack is another '!",
                 * they just cancel each other out */
                if (   (top_ptr = av_fetch(stack, top_index, FALSE))
                    && (IS_OPERATOR(*top_ptr) && SvUV(*top_ptr) == '!'))
                {
                    only_to_avoid_leaks = av_pop(stack);
                    SvREFCNT_dec(only_to_avoid_leaks);
                }
                else { /* Otherwise, since it's right associative, just push
                          onto the stack */
                    av_push(stack, newSVuv(curchar));
                }
                break;

            default:
                RExC_parse += (UTF) ? UTF8SKIP(RExC_parse) : 1;
                vFAIL("Unexpected character");

          handle_operand:

            /* Here 'current' is the operand.  If something is already on the
             * stack, we have to check if it is a !.  But first, the code above
             * may have altered the stack in the time since we earlier set
             * 'top_index'.  */

            top_index = av_tindex_nomg(stack);
            if (top_index - fence >= 0) {
                /* If the top entry on the stack is an operator, it had better
                 * be a '!', otherwise the entry below the top operand should
                 * be an operator */
                top_ptr = av_fetch(stack, top_index, FALSE);
                assert(top_ptr);
                if (IS_OPERATOR(*top_ptr)) {

                    /* The only permissible operator at the top of the stack is
                     * '!', which is applied immediately to this operand. */
                    curchar = (char) SvUV(*top_ptr);
                    if (curchar != '!') {
                        SvREFCNT_dec(current);
                        vFAIL2("Unexpected binary operator '%c' with no "
                                "preceding operand", curchar);
                    }

                    _invlist_invert(current);

                    only_to_avoid_leaks = av_pop(stack);
                    SvREFCNT_dec(only_to_avoid_leaks);

                    /* And we redo with the inverted operand.  This allows
                     * handling multiple ! in a row */
                    goto handle_operand;
                }
                          /* Single operand is ok only for the non-binary ')'
                           * operator */
                else if ((top_index - fence == 0 && curchar != ')')
                         || (top_index - fence > 0
                             && (! (stacked_ptr = av_fetch(stack,
                                                           top_index - 1,
                                                           FALSE))
                                 || IS_OPERAND(*stacked_ptr))))
                {
                    SvREFCNT_dec(current);
                    vFAIL("Operand with no preceding operator");
                }
            }

            /* Here there was nothing on the stack or the top element was
             * another operand.  Just add this new one */
            av_push(stack, current);

        } /* End of switch on next parse token */

        RExC_parse += (UTF) ? UTF8SKIP(RExC_parse) : 1;
    } /* End of loop parsing through the construct */

  done:
    if (av_tindex_nomg(fence_stack) >= 0) {
        vFAIL("Unmatched (");
    }

    if (av_tindex_nomg(stack) < 0   /* Was empty */
        || ((final = av_pop(stack)) == NULL)
        || ! IS_OPERAND(final)
        || SvTYPE(final) != SVt_INVLIST
        || av_tindex_nomg(stack) >= 0)  /* More left on stack */
    {
      bad_syntax:
        SvREFCNT_dec(final);
        vFAIL("Incomplete expression within '(?[ ])'");
    }

    /* Here, 'final' is the resultant inversion list from evaluating the
     * expression.  Return it if so requested */
    if (return_invlist) {
        *return_invlist = final;
        return END;
    }

    /* Otherwise generate a resultant node, based on 'final'.  regclass() is
     * expecting a string of ranges and individual code points */
    invlist_iterinit(final);
    result_string = newSVpvs("");
    while (invlist_iternext(final, &start, &end)) {
        if (start == end) {
            Perl_sv_catpvf(aTHX_ result_string, "\\x{%"UVXf"}", start);
        }
        else {
            Perl_sv_catpvf(aTHX_ result_string, "\\x{%"UVXf"}-\\x{%"UVXf"}",
                                                     start,          end);
        }
    }

    /* About to generate an ANYOF (or similar) node from the inversion list we
     * have calculated */
    save_parse = RExC_parse;
    RExC_parse = SvPV(result_string, len);
    save_end = RExC_end;
    RExC_end = RExC_parse + len;

    /* We turn off folding around the call, as the class we have constructed
     * already has all folding taken into consideration, and we don't want
     * regclass() to add to that */
    RExC_flags &= ~RXf_PMf_FOLD;
    /* regclass() can only return RESTART_PASS1 and NEED_UTF8 if multi-char
     * folds are allowed.  */
    node = regclass(pRExC_state, flagp,depth+1,
                    FALSE, /* means parse the whole char class */
                    FALSE, /* don't allow multi-char folds */
                    TRUE, /* silence non-portable warnings.  The above may very
                             well have generated non-portable code points, but
                             they're valid on this machine */
                    FALSE, /* similarly, no need for strict */
                    FALSE, /* Require return to be an ANYOF */
                    NULL,
                    NULL
                );
    if (!node)
        FAIL2("panic: regclass returned NULL to handle_sets, flags=%#"UVxf,
                    PTR2UV(flagp));

    /* Fix up the node type if we are in locale.  (We have pretended we are
     * under /u for the purposes of regclass(), as this construct will only
     * work under UTF-8 locales.  But now we change the opcode to be ANYOFL (so
     * as to cause any warnings about bad locales to be output in regexec.c),
     * and add the flag that indicates to check if not in a UTF-8 locale.  The
     * reason we above forbid optimization into something other than an ANYOF
     * node is simply to minimize the number of code changes in regexec.c.
     * Otherwise we would have to create new EXACTish node types and deal with
     * them.  This decision could be revisited should this construct become
     * popular.
     *
     * (One might think we could look at the resulting ANYOF node and suppress
     * the flag if everything is above 255, as those would be UTF-8 only,
     * but this isn't true, as the components that led to that result could
     * have been locale-affected, and just happen to cancel each other out
     * under UTF-8 locales.) */
    if (in_locale) {
        set_regex_charset(&RExC_flags, REGEX_LOCALE_CHARSET);

        assert(OP(node) == ANYOF);

        OP(node) = ANYOFL;
        ANYOF_FLAGS(node)
                |= ANYOFL_SHARED_UTF8_LOCALE_fold_HAS_MATCHES_nonfold_REQD;
    }

    if (save_fold) {
        RExC_flags |= RXf_PMf_FOLD;
    }

    RExC_parse = save_parse + 1;
    RExC_end = save_end;
    SvREFCNT_dec_NN(final);
    SvREFCNT_dec_NN(result_string);

    nextchar(pRExC_state);
    Set_Node_Length(node, RExC_parse - oregcomp_parse + 1); /* MJD */
    return node;
}
#undef IS_OPERATOR
#undef IS_OPERAND

STATIC void
S_add_above_Latin1_folds(pTHX_ RExC_state_t *pRExC_state, const U8 cp, SV** invlist)
{
    /* This hard-codes the Latin1/above-Latin1 folding rules, so that an
     * innocent-looking character class, like /[ks]/i won't have to go out to
     * disk to find the possible matches.
     *
     * This should be called only for a Latin1-range code points, cp, which is
     * known to be involved in a simple fold with other code points above
     * Latin1.  It would give false results if /aa has been specified.
     * Multi-char folds are outside the scope of this, and must be handled
     * specially.
     *
     * XXX It would be better to generate these via regen, in case a new
     * version of the Unicode standard adds new mappings, though that is not
     * really likely, and may be caught by the default: case of the switch
     * below. */

    PERL_ARGS_ASSERT_ADD_ABOVE_LATIN1_FOLDS;

    assert(HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(cp));

    switch (cp) {
        case 'k':
        case 'K':
          *invlist =
             add_cp_to_invlist(*invlist, KELVIN_SIGN);
            break;
        case 's':
        case 'S':
          *invlist = add_cp_to_invlist(*invlist, LATIN_SMALL_LETTER_LONG_S);
            break;
        case MICRO_SIGN:
          *invlist = add_cp_to_invlist(*invlist, GREEK_CAPITAL_LETTER_MU);
          *invlist = add_cp_to_invlist(*invlist, GREEK_SMALL_LETTER_MU);
            break;
        case LATIN_CAPITAL_LETTER_A_WITH_RING_ABOVE:
        case LATIN_SMALL_LETTER_A_WITH_RING_ABOVE:
          *invlist = add_cp_to_invlist(*invlist, ANGSTROM_SIGN);
            break;
        case LATIN_SMALL_LETTER_Y_WITH_DIAERESIS:
          *invlist = add_cp_to_invlist(*invlist,
                                        LATIN_CAPITAL_LETTER_Y_WITH_DIAERESIS);
            break;

#ifdef LATIN_CAPITAL_LETTER_SHARP_S /* not defined in early Unicode releases */

        case LATIN_SMALL_LETTER_SHARP_S:
          *invlist = add_cp_to_invlist(*invlist, LATIN_CAPITAL_LETTER_SHARP_S);
            break;

#endif

#if    UNICODE_MAJOR_VERSION < 3                                        \
   || (UNICODE_MAJOR_VERSION == 3 && UNICODE_DOT_VERSION == 0)

        /* In 3.0 and earlier, U+0130 folded simply to 'i'; and in 3.0.1 so did
         * U+0131.  */
        case 'i':
        case 'I':
          *invlist =
             add_cp_to_invlist(*invlist, LATIN_CAPITAL_LETTER_I_WITH_DOT_ABOVE);
#   if UNICODE_DOT_DOT_VERSION == 1
          *invlist = add_cp_to_invlist(*invlist, LATIN_SMALL_LETTER_DOTLESS_I);
#   endif
            break;
#endif

        default:
            /* Use deprecated warning to increase the chances of this being
             * output */
            if (PASS2) {
                ckWARN2reg_d(RExC_parse, "Perl folding rules are not up-to-date for 0x%02X; please use the perlbug utility to report;", cp);
            }
            break;
    }
}

STATIC void
S_output_or_return_posix_warnings(pTHX_ RExC_state_t *pRExC_state, AV* posix_warnings, AV** return_posix_warnings)
{
    /* If the final parameter is NULL, output the elements of the array given
     * by '*posix_warnings' as REGEXP warnings.  Otherwise, the elements are
     * pushed onto it, (creating if necessary) */

    SV * msg;
    const bool first_is_fatal =  ! return_posix_warnings
                                && ckDEAD(packWARN(WARN_REGEXP));

    PERL_ARGS_ASSERT_OUTPUT_OR_RETURN_POSIX_WARNINGS;

    while ((msg = av_shift(posix_warnings)) != &PL_sv_undef) {
        if (return_posix_warnings) {
            if (! *return_posix_warnings) { /* mortalize to not leak if
                                               warnings are fatal */
                *return_posix_warnings = (AV *) sv_2mortal((SV *) newAV());
            }
            av_push(*return_posix_warnings, msg);
        }
        else {
            if (first_is_fatal) {           /* Avoid leaking this */
                av_undef(posix_warnings);   /* This isn't necessary if the
                                               array is mortal, but is a
                                               fail-safe */
                (void) sv_2mortal(msg);
                if (PASS2) {
                    SAVEFREESV(RExC_rx_sv);
                }
            }
            Perl_warner(aTHX_ packWARN(WARN_REGEXP), "%s", SvPVX(msg));
            SvREFCNT_dec_NN(msg);
        }
    }
}

STATIC AV *
S_add_multi_match(pTHX_ AV* multi_char_matches, SV* multi_string, const STRLEN cp_count)
{
    /* This adds the string scalar <multi_string> to the array
     * <multi_char_matches>.  <multi_string> is known to have exactly
     * <cp_count> code points in it.  This is used when constructing a
     * bracketed character class and we find something that needs to match more
     * than a single character.
     *
     * <multi_char_matches> is actually an array of arrays.  Each top-level
     * element is an array that contains all the strings known so far that are
     * the same length.  And that length (in number of code points) is the same
     * as the index of the top-level array.  Hence, the [2] element is an
     * array, each element thereof is a string containing TWO code points;
     * while element [3] is for strings of THREE characters, and so on.  Since
     * this is for multi-char strings there can never be a [0] nor [1] element.
     *
     * When we rewrite the character class below, we will do so such that the
     * longest strings are written first, so that it prefers the longest
     * matching strings first.  This is done even if it turns out that any
     * quantifier is non-greedy, out of this programmer's (khw) laziness.  Tom
     * Christiansen has agreed that this is ok.  This makes the test for the
     * ligature 'ffi' come before the test for 'ff', for example */

    AV* this_array;
    AV** this_array_ptr;

    PERL_ARGS_ASSERT_ADD_MULTI_MATCH;

    if (! multi_char_matches) {
        multi_char_matches = newAV();
    }

    if (av_exists(multi_char_matches, cp_count)) {
        this_array_ptr = (AV**) av_fetch(multi_char_matches, cp_count, FALSE);
        this_array = *this_array_ptr;
    }
    else {
        this_array = newAV();
        av_store(multi_char_matches, cp_count,
                 (SV*) this_array);
    }
    av_push(this_array, multi_string);

    return multi_char_matches;
}

/* The names of properties whose definitions are not known at compile time are
 * stored in this SV, after a constant heading.  So if the length has been
 * changed since initialization, then there is a run-time definition. */
#define HAS_NONLOCALE_RUNTIME_PROPERTY_DEFINITION                            \
                                        (SvCUR(listsv) != initial_listsv_len)

/* There is a restricted set of white space characters that are legal when
 * ignoring white space in a bracketed character class.  This generates the
 * code to skip them.
 *
 * There is a line below that uses the same white space criteria but is outside
 * this macro.  Both here and there must use the same definition */
#define SKIP_BRACKETED_WHITE_SPACE(do_skip, p)                          \
    STMT_START {                                                        \
        if (do_skip) {                                                  \
            while (isBLANK_A(UCHARAT(p)))                               \
            {                                                           \
                p++;                                                    \
            }                                                           \
        }                                                               \
    } STMT_END

STATIC regnode *
S_regclass(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, U32 depth,
                 const bool stop_at_1,  /* Just parse the next thing, don't
                                           look for a full character class */
                 bool allow_multi_folds,
                 const bool silence_non_portable,   /* Don't output warnings
                                                       about too large
                                                       characters */
                 const bool strict,
                 bool optimizable,                  /* ? Allow a non-ANYOF return
                                                       node */
                 SV** ret_invlist, /* Return an inversion list, not a node */
                 AV** return_posix_warnings
          )
{
    /* parse a bracketed class specification.  Most of these will produce an
     * ANYOF node; but something like [a] will produce an EXACT node; [aA], an
     * EXACTFish node; [[:ascii:]], a POSIXA node; etc.  It is more complex
     * under /i with multi-character folds: it will be rewritten following the
     * paradigm of this example, where the <multi-fold>s are characters which
     * fold to multiple character sequences:
     *      /[abc\x{multi-fold1}def\x{multi-fold2}ghi]/i
     * gets effectively rewritten as:
     *      /(?:\x{multi-fold1}|\x{multi-fold2}|[abcdefghi]/i
     * reg() gets called (recursively) on the rewritten version, and this
     * function will return what it constructs.  (Actually the <multi-fold>s
     * aren't physically removed from the [abcdefghi], it's just that they are
     * ignored in the recursion by means of a flag:
     * <RExC_in_multi_char_class>.)
     *
     * ANYOF nodes contain a bit map for the first NUM_ANYOF_CODE_POINTS
     * characters, with the corresponding bit set if that character is in the
     * list.  For characters above this, a range list or swash is used.  There
     * are extra bits for \w, etc. in locale ANYOFs, as what these match is not
     * determinable at compile time
     *
     * Returns NULL, setting *flagp to RESTART_PASS1 if the sizing scan needs
     * to be restarted, or'd with NEED_UTF8 if the pattern needs to be upgraded
     * to UTF-8.  This can only happen if ret_invlist is non-NULL.
     */

    UV prevvalue = OOB_UNICODE, save_prevvalue = OOB_UNICODE;
    IV range = 0;
    UV value = OOB_UNICODE, save_value = OOB_UNICODE;
    regnode *ret;
    STRLEN numlen;
    int namedclass = OOB_NAMEDCLASS;
    char *rangebegin = NULL;
    bool need_class = 0;
    SV *listsv = NULL;
    STRLEN initial_listsv_len = 0; /* Kind of a kludge to see if it is more
				      than just initialized.  */
    SV* properties = NULL;    /* Code points that match \p{} \P{} */
    SV* posixes = NULL;     /* Code points that match classes like [:word:],
                               extended beyond the Latin1 range.  These have to
                               be kept separate from other code points for much
                               of this function because their handling  is
                               different under /i, and for most classes under
                               /d as well */
    SV* nposixes = NULL;    /* Similarly for [:^word:].  These are kept
                               separate for a while from the non-complemented
                               versions because of complications with /d
                               matching */
    SV* simple_posixes = NULL; /* But under some conditions, the classes can be
                                  treated more simply than the general case,
                                  leading to less compilation and execution
                                  work */
    UV element_count = 0;   /* Number of distinct elements in the class.
			       Optimizations may be possible if this is tiny */
    AV * multi_char_matches = NULL; /* Code points that fold to more than one
                                       character; used under /i */
    UV n;
    char * stop_ptr = RExC_end;    /* where to stop parsing */
    const bool skip_white = cBOOL(ret_invlist); /* ignore unescaped white
                                                   space? */

    /* Unicode properties are stored in a swash; this holds the current one
     * being parsed.  If this swash is the only above-latin1 component of the
     * character class, an optimization is to pass it directly on to the
     * execution engine.  Otherwise, it is set to NULL to indicate that there
     * are other things in the class that have to be dealt with at execution
     * time */
    SV* swash = NULL;		/* Code points that match \p{} \P{} */

    /* Set if a component of this character class is user-defined; just passed
     * on to the engine */
    bool has_user_defined_property = FALSE;

    /* inversion list of code points this node matches only when the target
     * string is in UTF-8.  These are all non-ASCII, < 256.  (Because is under
     * /d) */
    SV* has_upper_latin1_only_utf8_matches = NULL;

    /* Inversion list of code points this node matches regardless of things
     * like locale, folding, utf8ness of the target string */
    SV* cp_list = NULL;

    /* Like cp_list, but code points on this list need to be checked for things
     * that fold to/from them under /i */
    SV* cp_foldable_list = NULL;

    /* Like cp_list, but code points on this list are valid only when the
     * runtime locale is UTF-8 */
    SV* only_utf8_locale_list = NULL;

    /* In a range, if one of the endpoints is non-character-set portable,
     * meaning that it hard-codes a code point that may mean a different
     * charactger in ASCII vs. EBCDIC, as opposed to, say, a literal 'A' or a
     * mnemonic '\t' which each mean the same character no matter which
     * character set the platform is on. */
    unsigned int non_portable_endpoint = 0;

    /* Is the range unicode? which means on a platform that isn't 1-1 native
     * to Unicode (i.e. non-ASCII), each code point in it should be considered
     * to be a Unicode value.  */
    bool unicode_range = FALSE;
    bool invert = FALSE;    /* Is this class to be complemented */

    bool warn_super = ALWAYS_WARN_SUPER;

    regnode * const orig_emit = RExC_emit; /* Save the original RExC_emit in
        case we need to change the emitted regop to an EXACT. */
    const char * orig_parse = RExC_parse;
    const SSize_t orig_size = RExC_size;
    bool posixl_matches_all = FALSE; /* Does /l class have both e.g. \W,\w ? */

    /* This variable is used to mark where the end in the input is of something
     * that looks like a POSIX construct but isn't.  During the parse, when
     * something looks like it could be such a construct is encountered, it is
     * checked for being one, but not if we've already checked this area of the
     * input.  Only after this position is reached do we check again */
    char *not_posix_region_end = RExC_parse - 1;

    AV* posix_warnings = NULL;
    const bool do_posix_warnings =     return_posix_warnings
                                   || (PASS2 && ckWARN(WARN_REGEXP));

    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_REGCLASS;
#ifndef DEBUGGING
    PERL_UNUSED_ARG(depth);
#endif

    DEBUG_PARSE("clas");

#if UNICODE_MAJOR_VERSION < 3 /* no multifolds in early Unicode */      \
    || (UNICODE_MAJOR_VERSION == 3 && UNICODE_DOT_VERSION == 0          \
                                   && UNICODE_DOT_DOT_VERSION == 0)
    allow_multi_folds = FALSE;
#endif

    /* Assume we are going to generate an ANYOF node. */
    ret = reganode(pRExC_state,
                   (LOC)
                    ? ANYOFL
                    : ANYOF,
                   0);

    if (SIZE_ONLY) {
	RExC_size += ANYOF_SKIP;
	listsv = &PL_sv_undef; /* For code scanners: listsv always non-NULL. */
    }
    else {
        ANYOF_FLAGS(ret) = 0;

 	RExC_emit += ANYOF_SKIP;
	listsv = newSVpvs_flags("# comment\n", SVs_TEMP);
	initial_listsv_len = SvCUR(listsv);
        SvTEMP_off(listsv); /* Grr, TEMPs and mortals are conflated.  */
    }

    SKIP_BRACKETED_WHITE_SPACE(skip_white, RExC_parse);

    assert(RExC_parse <= RExC_end);

    if (UCHARAT(RExC_parse) == '^') {	/* Complement the class */
	RExC_parse++;
        invert = TRUE;
        allow_multi_folds = FALSE;
        MARK_NAUGHTY(1);
        SKIP_BRACKETED_WHITE_SPACE(skip_white, RExC_parse);
    }

    /* Check that they didn't say [:posix:] instead of [[:posix:]] */
    if (! ret_invlist && MAYBE_POSIXCC(UCHARAT(RExC_parse))) {
        int maybe_class = handle_possible_posix(pRExC_state,
                                                RExC_parse,
                                                &not_posix_region_end,
                                                NULL,
                                                TRUE /* checking only */);
        if (PASS2 && maybe_class >= OOB_NAMEDCLASS && do_posix_warnings) {
            SAVEFREESV(RExC_rx_sv);
            ckWARN4reg(not_posix_region_end,
                    "POSIX syntax [%c %c] belongs inside character classes%s",
                    *RExC_parse, *RExC_parse,
                    (maybe_class == OOB_NAMEDCLASS)
                    ? ((POSIXCC_NOTYET(*RExC_parse))
                        ? " (but this one isn't implemented)"
                        : " (but this one isn't fully valid)")
                    : ""
                    );
            (void)ReREFCNT_inc(RExC_rx_sv);
        }
    }

    /* If the caller wants us to just parse a single element, accomplish this
     * by faking the loop ending condition */
    if (stop_at_1 && RExC_end > RExC_parse) {
        stop_ptr = RExC_parse + 1;
    }

    /* allow 1st char to be ']' (allowing it to be '-' is dealt with later) */
    if (UCHARAT(RExC_parse) == ']')
	goto charclassloop;

    while (1) {

        if (   posix_warnings
            && av_tindex_nomg(posix_warnings) >= 0
            && RExC_parse > not_posix_region_end)
        {
            /* Warnings about posix class issues are considered tentative until
             * we are far enough along in the parse that we can no longer
             * change our mind, at which point we either output them or add
             * them, if it has so specified, to what gets returned to the
             * caller.  This is done each time through the loop so that a later
             * class won't zap them before they have been dealt with. */
            output_or_return_posix_warnings(pRExC_state, posix_warnings,
                                            return_posix_warnings);
        }

        if  (RExC_parse >= stop_ptr) {
            break;
        }

        SKIP_BRACKETED_WHITE_SPACE(skip_white, RExC_parse);

        if  (UCHARAT(RExC_parse) == ']') {
            break;
        }

      charclassloop:

	namedclass = OOB_NAMEDCLASS; /* initialize as illegal */
        save_value = value;
        save_prevvalue = prevvalue;

	if (!range) {
	    rangebegin = RExC_parse;
	    element_count++;
            non_portable_endpoint = 0;
	}
	if (UTF && ! UTF8_IS_INVARIANT(* RExC_parse)) {
	    value = utf8n_to_uvchr((U8*)RExC_parse,
				   RExC_end - RExC_parse,
				   &numlen, UTF8_ALLOW_DEFAULT);
	    RExC_parse += numlen;
	}
	else
	    value = UCHARAT(RExC_parse++);

        if (value == '[') {
            char * posix_class_end;
            namedclass = handle_possible_posix(pRExC_state,
                                               RExC_parse,
                                               &posix_class_end,
                                               do_posix_warnings ? &posix_warnings : NULL,
                                               FALSE    /* die if error */);
            if (namedclass > OOB_NAMEDCLASS) {

                /* If there was an earlier attempt to parse this particular
                 * posix class, and it failed, it was a false alarm, as this
                 * successful one proves */
                if (   posix_warnings
                    && av_tindex_nomg(posix_warnings) >= 0
                    && not_posix_region_end >= RExC_parse
                    && not_posix_region_end <= posix_class_end)
                {
                    av_undef(posix_warnings);
                }

                RExC_parse = posix_class_end;
            }
            else if (namedclass == OOB_NAMEDCLASS) {
                not_posix_region_end = posix_class_end;
            }
            else {
                namedclass = OOB_NAMEDCLASS;
            }
        }
        else if (   RExC_parse - 1 > not_posix_region_end
                 && MAYBE_POSIXCC(value))
        {
            (void) handle_possible_posix(
                        pRExC_state,
                        RExC_parse - 1,  /* -1 because parse has already been
                                            advanced */
                        &not_posix_region_end,
                        do_posix_warnings ? &posix_warnings : NULL,
                        TRUE /* checking only */);
        }
        else if (value == '\\') {
            /* Is a backslash; get the code point of the char after it */

            if (RExC_parse >= RExC_end) {
                vFAIL("Unmatched [");
            }

	    if (UTF && ! UTF8_IS_INVARIANT(UCHARAT(RExC_parse))) {
		value = utf8n_to_uvchr((U8*)RExC_parse,
				   RExC_end - RExC_parse,
				   &numlen, UTF8_ALLOW_DEFAULT);
		RExC_parse += numlen;
	    }
	    else
		value = UCHARAT(RExC_parse++);

	    /* Some compilers cannot handle switching on 64-bit integer
	     * values, therefore value cannot be an UV.  Yes, this will
	     * be a problem later if we want switch on Unicode.
	     * A similar issue a little bit later when switching on
	     * namedclass. --jhi */

            /* If the \ is escaping white space when white space is being
             * skipped, it means that that white space is wanted literally, and
             * is already in 'value'.  Otherwise, need to translate the escape
             * into what it signifies. */
            if (! skip_white || ! isBLANK_A(value)) switch ((I32)value) {

	    case 'w':	namedclass = ANYOF_WORDCHAR;	break;
	    case 'W':	namedclass = ANYOF_NWORDCHAR;	break;
	    case 's':	namedclass = ANYOF_SPACE;	break;
	    case 'S':	namedclass = ANYOF_NSPACE;	break;
	    case 'd':	namedclass = ANYOF_DIGIT;	break;
	    case 'D':	namedclass = ANYOF_NDIGIT;	break;
	    case 'v':	namedclass = ANYOF_VERTWS;	break;
	    case 'V':	namedclass = ANYOF_NVERTWS;	break;
	    case 'h':	namedclass = ANYOF_HORIZWS;	break;
	    case 'H':	namedclass = ANYOF_NHORIZWS;	break;
            case 'N':  /* Handle \N{NAME} in class */
                {
                    const char * const backslash_N_beg = RExC_parse - 2;
                    int cp_count;

                    if (! grok_bslash_N(pRExC_state,
                                        NULL,      /* No regnode */
                                        &value,    /* Yes single value */
                                        &cp_count, /* Multiple code pt count */
                                        flagp,
                                        strict,
                                        depth)
                    ) {

                        if (*flagp & NEED_UTF8)
                            FAIL("panic: grok_bslash_N set NEED_UTF8");
                        if (*flagp & RESTART_PASS1)
                            return NULL;

                        if (cp_count < 0) {
                            vFAIL("\\N in a character class must be a named character: \\N{...}");
                        }
                        else if (cp_count == 0) {
                            if (PASS2) {
                                ckWARNreg(RExC_parse,
                                        "Ignoring zero length \\N{} in character class");
                            }
                        }
                        else { /* cp_count > 1 */
                            if (! RExC_in_multi_char_class) {
                                if (invert || range || *RExC_parse == '-') {
                                    if (strict) {
                                        RExC_parse--;
                                        vFAIL("\\N{} in inverted character class or as a range end-point is restricted to one character");
                                    }
                                    else if (PASS2) {
                                        ckWARNreg(RExC_parse, "Using just the first character returned by \\N{} in character class");
                                    }
                                    break; /* <value> contains the first code
                                              point. Drop out of the switch to
                                              process it */
                                }
                                else {
                                    SV * multi_char_N = newSVpvn(backslash_N_beg,
                                                 RExC_parse - backslash_N_beg);
                                    multi_char_matches
                                        = add_multi_match(multi_char_matches,
                                                          multi_char_N,
                                                          cp_count);
                                }
                            }
                        } /* End of cp_count != 1 */

                        /* This element should not be processed further in this
                         * class */
                        element_count--;
                        value = save_value;
                        prevvalue = save_prevvalue;
                        continue;   /* Back to top of loop to get next char */
                    }

                    /* Here, is a single code point, and <value> contains it */
                    unicode_range = TRUE;   /* \N{} are Unicode */
                }
                break;
	    case 'p':
	    case 'P':
		{
		char *e;

                /* We will handle any undefined properties ourselves */
                U8 swash_init_flags = _CORE_SWASH_INIT_RETURN_IF_UNDEF
                                       /* And we actually would prefer to get
                                        * the straight inversion list of the
                                        * swash, since we will be accessing it
                                        * anyway, to save a little time */
                                      |_CORE_SWASH_INIT_ACCEPT_INVLIST;

		if (RExC_parse >= RExC_end)
		    vFAIL2("Empty \\%c", (U8)value);
		if (*RExC_parse == '{') {
		    const U8 c = (U8)value;
		    e = strchr(RExC_parse, '}');
                    if (!e) {
                        RExC_parse++;
                        vFAIL2("Missing right brace on \\%c{}", c);
                    }

                    RExC_parse++;
                    while (isSPACE(*RExC_parse)) {
                         RExC_parse++;
		    }

		    if (UCHARAT(RExC_parse) == '^') {

                        /* toggle.  (The rhs xor gets the single bit that
                         * differs between P and p; the other xor inverts just
                         * that bit) */
                        value ^= 'P' ^ 'p';

                        RExC_parse++;
                        while (isSPACE(*RExC_parse)) {
                            RExC_parse++;
                        }
                    }

                    if (e == RExC_parse)
                        vFAIL2("Empty \\%c{}", c);

		    n = e - RExC_parse;
		    while (isSPACE(*(RExC_parse + n - 1)))
		        n--;
		}   /* The \p isn't immediately followed by a '{' */
		else if (! isALPHA(*RExC_parse)) {
                    RExC_parse += (UTF) ? UTF8SKIP(RExC_parse) : 1;
                    vFAIL2("Character following \\%c must be '{' or a "
                           "single-character Unicode property name",
                           (U8) value);
                }
                else {
		    e = RExC_parse;
		    n = 1;
		}
		if (!SIZE_ONLY) {
                    SV* invlist;
                    char* name;
                    char* base_name;    /* name after any packages are stripped */
                    char* lookup_name = NULL;
                    const char * const colon_colon = "::";

                    /* Try to get the definition of the property into
                     * <invlist>.  If /i is in effect, the effective property
                     * will have its name be <__NAME_i>.  The design is
                     * discussed in commit
                     * 2f833f5208e26b208886e51e09e2c072b5eabb46 */
                    name = savepv(Perl_form(aTHX_ "%.*s", (int)n, RExC_parse));
                    SAVEFREEPV(name);
                    if (FOLD) {
                        lookup_name = savepv(Perl_form(aTHX_ "__%s_i", name));

                        /* The function call just below that uses this can fail
                         * to return, leaking memory if we don't do this */
                        SAVEFREEPV(lookup_name);
                    }

                    /* Look up the property name, and get its swash and
                     * inversion list, if the property is found  */
                    SvREFCNT_dec(swash); /* Free any left-overs */
                    swash = _core_swash_init("utf8",
                                             (lookup_name)
                                              ? lookup_name
                                              : name,
                                             &PL_sv_undef,
                                             1, /* binary */
                                             0, /* not tr/// */
                                             NULL, /* No inversion list */
                                             &swash_init_flags
                                            );
                    if (! swash || ! (invlist = _get_swash_invlist(swash))) {
                        HV* curpkg = (IN_PERL_COMPILETIME)
                                      ? PL_curstash
                                      : CopSTASH(PL_curcop);
                        UV final_n = n;
                        bool has_pkg;

                        if (swash) {    /* Got a swash but no inversion list.
                                           Something is likely wrong that will
                                           be sorted-out later */
                            SvREFCNT_dec_NN(swash);
                            swash = NULL;
                        }

                        /* Here didn't find it.  It could be a an error (like a
                         * typo) in specifying a Unicode property, or it could
                         * be a user-defined property that will be available at
                         * run-time.  The names of these must begin with 'In'
                         * or 'Is' (after any packages are stripped off).  So
                         * if not one of those, or if we accept only
                         * compile-time properties, is an error; otherwise add
                         * it to the list for run-time look up. */
                        if ((base_name = rninstr(name, name + n,
                                                 colon_colon, colon_colon + 2)))
                        { /* Has ::.  We know this must be a user-defined
                             property */
                            base_name += 2;
                            final_n -= base_name - name;
                            has_pkg = TRUE;
                        }
                        else {
                            base_name = name;
                            has_pkg = FALSE;
                        }

                        if (   final_n < 3
                            || base_name[0] != 'I'
                            || (base_name[1] != 's' && base_name[1] != 'n')
                            || ret_invlist)
                        {
                            const char * const msg
                                = (has_pkg)
                                  ? "Illegal user-defined property name"
                                  : "Can't find Unicode property definition";
                            RExC_parse = e + 1;

                            /* diag_listed_as: Can't find Unicode property definition "%s" */
                            vFAIL3utf8f("%s \"%"UTF8f"\"",
                                msg, UTF8fARG(UTF, n, name));
                        }

                        /* If the property name doesn't already have a package
                         * name, add the current one to it so that it can be
                         * referred to outside it. [perl #121777] */
                        if (! has_pkg && curpkg) {
                            char* pkgname = HvNAME(curpkg);
                            if (strNE(pkgname, "main")) {
                                char* full_name = Perl_form(aTHX_
                                                            "%s::%s",
                                                            pkgname,
                                                            name);
                                n = strlen(full_name);
                                name = savepvn(full_name, n);
                                SAVEFREEPV(name);
                            }
                        }
                        Perl_sv_catpvf(aTHX_ listsv, "%cutf8::%s%"UTF8f"%s\n",
                                        (value == 'p' ? '+' : '!'),
                                        (FOLD) ? "__" : "",
                                        UTF8fARG(UTF, n, name),
                                        (FOLD) ? "_i" : "");
                        has_user_defined_property = TRUE;
                        optimizable = FALSE;    /* Will have to leave this an
                                                   ANYOF node */

                        /* We don't know yet what this matches, so have to flag
                         * it */
                        ANYOF_FLAGS(ret) |= ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP;
                    }
                    else {

                        /* Here, did get the swash and its inversion list.  If
                         * the swash is from a user-defined property, then this
                         * whole character class should be regarded as such */
                        if (swash_init_flags
                            & _CORE_SWASH_INIT_USER_DEFINED_PROPERTY)
                        {
                            has_user_defined_property = TRUE;
                        }
                        else if
                            /* We warn on matching an above-Unicode code point
                             * if the match would return true, except don't
                             * warn for \p{All}, which has exactly one element
                             * = 0 */
                            (_invlist_contains_cp(invlist, 0x110000)
                                && (! (_invlist_len(invlist) == 1
                                       && *invlist_array(invlist) == 0)))
                        {
                            warn_super = TRUE;
                        }


                        /* Invert if asking for the complement */
                        if (value == 'P') {
			    _invlist_union_complement_2nd(properties,
                                                          invlist,
                                                          &properties);

                            /* The swash can't be used as-is, because we've
			     * inverted things; delay removing it to here after
			     * have copied its invlist above */
                            SvREFCNT_dec_NN(swash);
                            swash = NULL;
                        }
                        else {
                            _invlist_union(properties, invlist, &properties);
			}
		    }
		}
		RExC_parse = e + 1;
                namedclass = ANYOF_UNIPROP;  /* no official name, but it's
                                                named */

		/* \p means they want Unicode semantics */
		REQUIRE_UNI_RULES(flagp, NULL);
		}
		break;
	    case 'n':	value = '\n';			break;
	    case 'r':	value = '\r';			break;
	    case 't':	value = '\t';			break;
	    case 'f':	value = '\f';			break;
	    case 'b':	value = '\b';			break;
	    case 'e':	value = ESC_NATIVE;             break;
	    case 'a':	value = '\a';                   break;
	    case 'o':
		RExC_parse--;	/* function expects to be pointed at the 'o' */
		{
		    const char* error_msg;
		    bool valid = grok_bslash_o(&RExC_parse,
					       &value,
					       &error_msg,
                                               PASS2,   /* warnings only in
                                                           pass 2 */
                                               strict,
                                               silence_non_portable,
                                               UTF);
		    if (! valid) {
			vFAIL(error_msg);
		    }
		}
                non_portable_endpoint++;
		if (IN_ENCODING && value < 0x100) {
		    goto recode_encoding;
		}
		break;
	    case 'x':
		RExC_parse--;	/* function expects to be pointed at the 'x' */
		{
		    const char* error_msg;
		    bool valid = grok_bslash_x(&RExC_parse,
					       &value,
					       &error_msg,
					       PASS2, /* Output warnings */
                                               strict,
                                               silence_non_portable,
                                               UTF);
                    if (! valid) {
			vFAIL(error_msg);
		    }
		}
                non_portable_endpoint++;
		if (IN_ENCODING && value < 0x100)
		    goto recode_encoding;
		break;
	    case 'c':
		value = grok_bslash_c(*RExC_parse++, PASS2);
                non_portable_endpoint++;
		break;
	    case '0': case '1': case '2': case '3': case '4':
	    case '5': case '6': case '7':
		{
		    /* Take 1-3 octal digits */
		    I32 flags = PERL_SCAN_SILENT_ILLDIGIT;
                    numlen = (strict) ? 4 : 3;
                    value = grok_oct(--RExC_parse, &numlen, &flags, NULL);
		    RExC_parse += numlen;
                    if (numlen != 3) {
                        if (strict) {
                            RExC_parse += (UTF) ? UTF8SKIP(RExC_parse) : 1;
                            vFAIL("Need exactly 3 octal digits");
                        }
                        else if (! SIZE_ONLY /* like \08, \178 */
                                 && numlen < 3
                                 && RExC_parse < RExC_end
                                 && isDIGIT(*RExC_parse)
                                 && ckWARN(WARN_REGEXP))
                        {
                            SAVEFREESV(RExC_rx_sv);
                            reg_warn_non_literal_string(
                                 RExC_parse + 1,
                                 form_short_octal_warning(RExC_parse, numlen));
                            (void)ReREFCNT_inc(RExC_rx_sv);
                        }
                    }
                    non_portable_endpoint++;
		    if (IN_ENCODING && value < 0x100)
			goto recode_encoding;
		    break;
		}
	      recode_encoding:
		if (! RExC_override_recoding) {
		    SV* enc = _get_encoding();
		    value = reg_recode((U8)value, &enc);
		    if (!enc) {
                        if (strict) {
                            vFAIL("Invalid escape in the specified encoding");
                        }
                        else if (PASS2) {
                            ckWARNreg(RExC_parse,
				  "Invalid escape in the specified encoding");
                        }
                    }
		    break;
		}
	    default:
		/* Allow \_ to not give an error */
		if (!SIZE_ONLY && isWORDCHAR(value) && value != '_') {
                    if (strict) {
                        vFAIL2("Unrecognized escape \\%c in character class",
                               (int)value);
                    }
                    else {
                        SAVEFREESV(RExC_rx_sv);
                        ckWARN2reg(RExC_parse,
                            "Unrecognized escape \\%c in character class passed through",
                            (int)value);
                        (void)ReREFCNT_inc(RExC_rx_sv);
                    }
		}
		break;
	    }   /* End of switch on char following backslash */
	} /* end of handling backslash escape sequences */

        /* Here, we have the current token in 'value' */

	if (namedclass > OOB_NAMEDCLASS) { /* this is a named class \blah */
            U8 classnum;

	    /* a bad range like a-\d, a-[:digit:].  The '-' is taken as a
	     * literal, as is the character that began the false range, i.e.
	     * the 'a' in the examples */
	    if (range) {
		if (!SIZE_ONLY) {
		    const int w = (RExC_parse >= rangebegin)
                                  ? RExC_parse - rangebegin
                                  : 0;
                    if (strict) {
                        vFAIL2utf8f(
                            "False [] range \"%"UTF8f"\"",
                            UTF8fARG(UTF, w, rangebegin));
                    }
                    else {
                        SAVEFREESV(RExC_rx_sv); /* in case of fatal warnings */
                        ckWARN2reg(RExC_parse,
                            "False [] range \"%"UTF8f"\"",
                            UTF8fARG(UTF, w, rangebegin));
                        (void)ReREFCNT_inc(RExC_rx_sv);
                        cp_list = add_cp_to_invlist(cp_list, '-');
                        cp_foldable_list = add_cp_to_invlist(cp_foldable_list,
                                                             prevvalue);
                    }
		}

		range = 0; /* this was not a true range */
                element_count += 2; /* So counts for three values */
	    }

            classnum = namedclass_to_classnum(namedclass);

	    if (LOC && namedclass < ANYOF_POSIXL_MAX
#ifndef HAS_ISASCII
                && classnum != _CC_ASCII
#endif
            ) {
                /* What the Posix classes (like \w, [:space:]) match in locale
                 * isn't knowable under locale until actual match time.  Room
                 * must be reserved (one time per outer bracketed class) to
                 * store such classes.  The space will contain a bit for each
                 * named class that is to be matched against.  This isn't
                 * needed for \p{} and pseudo-classes, as they are not affected
                 * by locale, and hence are dealt with separately */
                if (! need_class) {
                    need_class = 1;
                    if (SIZE_ONLY) {
                        RExC_size += ANYOF_POSIXL_SKIP - ANYOF_SKIP;
                    }
                    else {
                        RExC_emit += ANYOF_POSIXL_SKIP - ANYOF_SKIP;
                    }
                    ANYOF_FLAGS(ret) |= ANYOF_MATCHES_POSIXL;
                    ANYOF_POSIXL_ZERO(ret);

                    /* We can't change this into some other type of node
                     * (unless this is the only element, in which case there
                     * are nodes that mean exactly this) as has runtime
                     * dependencies */
                    optimizable = FALSE;
                }

                /* Coverity thinks it is possible for this to be negative; both
                 * jhi and khw think it's not, but be safer */
                assert(! (ANYOF_FLAGS(ret) & ANYOF_MATCHES_POSIXL)
                       || (namedclass + ((namedclass % 2) ? -1 : 1)) >= 0);

                /* See if it already matches the complement of this POSIX
                 * class */
                if ((ANYOF_FLAGS(ret) & ANYOF_MATCHES_POSIXL)
                    && ANYOF_POSIXL_TEST(ret, namedclass + ((namedclass % 2)
                                                            ? -1
                                                            : 1)))
                {
                    posixl_matches_all = TRUE;
                    break;  /* No need to continue.  Since it matches both
                               e.g., \w and \W, it matches everything, and the
                               bracketed class can be optimized into qr/./s */
                }

                /* Add this class to those that should be checked at runtime */
                ANYOF_POSIXL_SET(ret, namedclass);

                /* The above-Latin1 characters are not subject to locale rules.
                 * Just add them, in the second pass, to the
                 * unconditionally-matched list */
                if (! SIZE_ONLY) {
                    SV* scratch_list = NULL;

                    /* Get the list of the above-Latin1 code points this
                     * matches */
                    _invlist_intersection_maybe_complement_2nd(PL_AboveLatin1,
                                          PL_XPosix_ptrs[classnum],

                                          /* Odd numbers are complements, like
                                           * NDIGIT, NASCII, ... */
                                          namedclass % 2 != 0,
                                          &scratch_list);
                    /* Checking if 'cp_list' is NULL first saves an extra
                     * clone.  Its reference count will be decremented at the
                     * next union, etc, or if this is the only instance, at the
                     * end of the routine */
                    if (! cp_list) {
                        cp_list = scratch_list;
                    }
                    else {
                        _invlist_union(cp_list, scratch_list, &cp_list);
                        SvREFCNT_dec_NN(scratch_list);
                    }
                    continue;   /* Go get next character */
                }
            }
            else if (! SIZE_ONLY) {

                /* Here, not in pass1 (in that pass we skip calculating the
                 * contents of this class), and is /l, or is a POSIX class for
                 * which /l doesn't matter (or is a Unicode property, which is
                 * skipped here). */
                if (namedclass >= ANYOF_POSIXL_MAX) {  /* If a special class */
                    if (namedclass != ANYOF_UNIPROP) { /* UNIPROP = \p and \P */

                        /* Here, should be \h, \H, \v, or \V.  None of /d, /i
                         * nor /l make a difference in what these match,
                         * therefore we just add what they match to cp_list. */
                        if (classnum != _CC_VERTSPACE) {
                            assert(   namedclass == ANYOF_HORIZWS
                                   || namedclass == ANYOF_NHORIZWS);

                            /* It turns out that \h is just a synonym for
                             * XPosixBlank */
                            classnum = _CC_BLANK;
                        }

                        _invlist_union_maybe_complement_2nd(
                                cp_list,
                                PL_XPosix_ptrs[classnum],
                                namedclass % 2 != 0,    /* Complement if odd
                                                          (NHORIZWS, NVERTWS)
                                                        */
                                &cp_list);
                    }
                }
                else if (UNI_SEMANTICS
                        || classnum == _CC_ASCII
                        || (DEPENDS_SEMANTICS && (classnum == _CC_DIGIT
                                                  || classnum == _CC_XDIGIT)))
                {
                    /* We usually have to worry about /d and /a affecting what
                     * POSIX classes match, with special code needed for /d
                     * because we won't know until runtime what all matches.
                     * But there is no extra work needed under /u, and
                     * [:ascii:] is unaffected by /a and /d; and :digit: and
                     * :xdigit: don't have runtime differences under /d.  So we
                     * can special case these, and avoid some extra work below,
                     * and at runtime. */
                    _invlist_union_maybe_complement_2nd(
                                                     simple_posixes,
                                                     PL_XPosix_ptrs[classnum],
                                                     namedclass % 2 != 0,
                                                     &simple_posixes);
                }
                else {  /* Garden variety class.  If is NUPPER, NALPHA, ...
                           complement and use nposixes */
                    SV** posixes_ptr = namedclass % 2 == 0
                                       ? &posixes
                                       : &nposixes;
                    _invlist_union_maybe_complement_2nd(
                                                     *posixes_ptr,
                                                     PL_XPosix_ptrs[classnum],
                                                     namedclass % 2 != 0,
                                                     posixes_ptr);
                }
	    }
	} /* end of namedclass \blah */

        SKIP_BRACKETED_WHITE_SPACE(skip_white, RExC_parse);

        /* If 'range' is set, 'value' is the ending of a range--check its
         * validity.  (If value isn't a single code point in the case of a
         * range, we should have figured that out above in the code that
         * catches false ranges).  Later, we will handle each individual code
         * point in the range.  If 'range' isn't set, this could be the
         * beginning of a range, so check for that by looking ahead to see if
         * the next real character to be processed is the range indicator--the
         * minus sign */

	if (range) {
#ifdef EBCDIC
            /* For unicode ranges, we have to test that the Unicode as opposed
             * to the native values are not decreasing.  (Above 255, there is
             * no difference between native and Unicode) */
	    if (unicode_range && prevvalue < 255 && value < 255) {
                if (NATIVE_TO_LATIN1(prevvalue) > NATIVE_TO_LATIN1(value)) {
                    goto backwards_range;
                }
            }
            else
#endif
	    if (prevvalue > value) /* b-a */ {
		int w;
#ifdef EBCDIC
              backwards_range:
#endif
                w = RExC_parse - rangebegin;
                vFAIL2utf8f(
                    "Invalid [] range \"%"UTF8f"\"",
                    UTF8fARG(UTF, w, rangebegin));
                NOT_REACHED; /* NOTREACHED */
	    }
	}
	else {
            prevvalue = value; /* save the beginning of the potential range */
            if (! stop_at_1     /* Can't be a range if parsing just one thing */
                && *RExC_parse == '-')
            {
                char* next_char_ptr = RExC_parse + 1;

                /* Get the next real char after the '-' */
                SKIP_BRACKETED_WHITE_SPACE(skip_white, next_char_ptr);

                /* If the '-' is at the end of the class (just before the ']',
                 * it is a literal minus; otherwise it is a range */
                if (next_char_ptr < RExC_end && *next_char_ptr != ']') {
                    RExC_parse = next_char_ptr;

                    /* a bad range like \w-, [:word:]- ? */
                    if (namedclass > OOB_NAMEDCLASS) {
                        if (strict || (PASS2 && ckWARN(WARN_REGEXP))) {
                            const int w = RExC_parse >= rangebegin
                                          ?  RExC_parse - rangebegin
                                          : 0;
                            if (strict) {
                                vFAIL4("False [] range \"%*.*s\"",
                                    w, w, rangebegin);
                            }
                            else if (PASS2) {
                                vWARN4(RExC_parse,
                                    "False [] range \"%*.*s\"",
                                    w, w, rangebegin);
                            }
                        }
                        if (!SIZE_ONLY) {
                            cp_list = add_cp_to_invlist(cp_list, '-');
                        }
                        element_count++;
                    } else
                        range = 1;	/* yeah, it's a range! */
                    continue;	/* but do it the next time */
                }
	    }
	}

        if (namedclass > OOB_NAMEDCLASS) {
            continue;
        }

        /* Here, we have a single value this time through the loop, and
         * <prevvalue> is the beginning of the range, if any; or <value> if
         * not. */

	/* non-Latin1 code point implies unicode semantics.  Must be set in
	 * pass1 so is there for the whole of pass 2 */
	if (value > 255) {
            REQUIRE_UNI_RULES(flagp, NULL);
	}

        /* Ready to process either the single value, or the completed range.
         * For single-valued non-inverted ranges, we consider the possibility
         * of multi-char folds.  (We made a conscious decision to not do this
         * for the other cases because it can often lead to non-intuitive
         * results.  For example, you have the peculiar case that:
         *  "s s" =~ /^[^\xDF]+$/i => Y
         *  "ss"  =~ /^[^\xDF]+$/i => N
         *
         * See [perl #89750] */
        if (FOLD && allow_multi_folds && value == prevvalue) {
            if (value == LATIN_SMALL_LETTER_SHARP_S
                || (value > 255 && _invlist_contains_cp(PL_HasMultiCharFold,
                                                        value)))
            {
                /* Here <value> is indeed a multi-char fold.  Get what it is */

                U8 foldbuf[UTF8_MAXBYTES_CASE];
                STRLEN foldlen;

                UV folded = _to_uni_fold_flags(
                                value,
                                foldbuf,
                                &foldlen,
                                FOLD_FLAGS_FULL | (ASCII_FOLD_RESTRICTED
                                                   ? FOLD_FLAGS_NOMIX_ASCII
                                                   : 0)
                                );

                /* Here, <folded> should be the first character of the
                 * multi-char fold of <value>, with <foldbuf> containing the
                 * whole thing.  But, if this fold is not allowed (because of
                 * the flags), <fold> will be the same as <value>, and should
                 * be processed like any other character, so skip the special
                 * handling */
                if (folded != value) {

                    /* Skip if we are recursed, currently parsing the class
                     * again.  Otherwise add this character to the list of
                     * multi-char folds. */
                    if (! RExC_in_multi_char_class) {
                        STRLEN cp_count = utf8_length(foldbuf,
                                                      foldbuf + foldlen);
                        SV* multi_fold = sv_2mortal(newSVpvs(""));

                        Perl_sv_catpvf(aTHX_ multi_fold, "\\x{%"UVXf"}", value);

                        multi_char_matches
                                        = add_multi_match(multi_char_matches,
                                                          multi_fold,
                                                          cp_count);

                    }

                    /* This element should not be processed further in this
                     * class */
                    element_count--;
                    value = save_value;
                    prevvalue = save_prevvalue;
                    continue;
                }
            }
        }

        if (strict && PASS2 && ckWARN(WARN_REGEXP)) {
            if (range) {

                /* If the range starts above 255, everything is portable and
                 * likely to be so for any forseeable character set, so don't
                 * warn. */
                if (unicode_range && non_portable_endpoint && prevvalue < 256) {
                    vWARN(RExC_parse, "Both or neither range ends should be Unicode");
                }
                else if (prevvalue != value) {

                    /* Under strict, ranges that stop and/or end in an ASCII
                     * printable should have each end point be a portable value
                     * for it (preferably like 'A', but we don't warn if it is
                     * a (portable) Unicode name or code point), and the range
                     * must be be all digits or all letters of the same case.
                     * Otherwise, the range is non-portable and unclear as to
                     * what it contains */
                    if ((isPRINT_A(prevvalue) || isPRINT_A(value))
                        && (non_portable_endpoint
                            || ! ((isDIGIT_A(prevvalue) && isDIGIT_A(value))
                                   || (isLOWER_A(prevvalue) && isLOWER_A(value))
                                   || (isUPPER_A(prevvalue) && isUPPER_A(value)))))
                    {
                        vWARN(RExC_parse, "Ranges of ASCII printables should be some subset of \"0-9\", \"A-Z\", or \"a-z\"");
                    }
                    else if (prevvalue >= 0x660) { /* ARABIC_INDIC_DIGIT_ZERO */

                        /* But the nature of Unicode and languages mean we
                         * can't do the same checks for above-ASCII ranges,
                         * except in the case of digit ones.  These should
                         * contain only digits from the same group of 10.  The
                         * ASCII case is handled just above.  0x660 is the
                         * first digit character beyond ASCII.  Hence here, the
                         * range could be a range of digits.  Find out.  */
                        IV index_start = _invlist_search(PL_XPosix_ptrs[_CC_DIGIT],
                                                         prevvalue);
                        IV index_final = _invlist_search(PL_XPosix_ptrs[_CC_DIGIT],
                                                         value);

                        /* If the range start and final points are in the same
                         * inversion list element, it means that either both
                         * are not digits, or both are digits in a consecutive
                         * sequence of digits.  (So far, Unicode has kept all
                         * such sequences as distinct groups of 10, but assert
                         * to make sure).  If the end points are not in the
                         * same element, neither should be a digit. */
                        if (index_start == index_final) {
                            assert(! ELEMENT_RANGE_MATCHES_INVLIST(index_start)
                            || (invlist_array(PL_XPosix_ptrs[_CC_DIGIT])[index_start+1]
                               - invlist_array(PL_XPosix_ptrs[_CC_DIGIT])[index_start]
                               == 10)
                               /* But actually Unicode did have one group of 11
                                * 'digits' in 5.2, so in case we are operating
                                * on that version, let that pass */
                            || (invlist_array(PL_XPosix_ptrs[_CC_DIGIT])[index_start+1]
                               - invlist_array(PL_XPosix_ptrs[_CC_DIGIT])[index_start]
                                == 11
                               && invlist_array(PL_XPosix_ptrs[_CC_DIGIT])[index_start]
                                == 0x19D0)
                            );
                        }
                        else if ((index_start >= 0
                                  && ELEMENT_RANGE_MATCHES_INVLIST(index_start))
                                 || (index_final >= 0
                                     && ELEMENT_RANGE_MATCHES_INVLIST(index_final)))
                        {
                            vWARN(RExC_parse, "Ranges of digits should be from the same group of 10");
                        }
                    }
                }
            }
            if ((! range || prevvalue == value) && non_portable_endpoint) {
                if (isPRINT_A(value)) {
                    char literal[3];
                    unsigned d = 0;
                    if (isBACKSLASHED_PUNCT(value)) {
                        literal[d++] = '\\';
                    }
                    literal[d++] = (char) value;
                    literal[d++] = '\0';

                    vWARN4(RExC_parse,
                           "\"%.*s\" is more clearly written simply as \"%s\"",
                           (int) (RExC_parse - rangebegin),
                           rangebegin,
                           literal
                        );
                }
                else if isMNEMONIC_CNTRL(value) {
                    vWARN4(RExC_parse,
                           "\"%.*s\" is more clearly written simply as \"%s\"",
                           (int) (RExC_parse - rangebegin),
                           rangebegin,
                           cntrl_to_mnemonic((U8) value)
                        );
                }
            }
        }

        /* Deal with this element of the class */
	if (! SIZE_ONLY) {

#ifndef EBCDIC
            cp_foldable_list = _add_range_to_invlist(cp_foldable_list,
                                                     prevvalue, value);
#else
            /* On non-ASCII platforms, for ranges that span all of 0..255, and
             * ones that don't require special handling, we can just add the
             * range like we do for ASCII platforms */
            if ((UNLIKELY(prevvalue == 0) && value >= 255)
                || ! (prevvalue < 256
                      && (unicode_range
                          || (! non_portable_endpoint
                              && ((isLOWER_A(prevvalue) && isLOWER_A(value))
                                  || (isUPPER_A(prevvalue)
                                      && isUPPER_A(value)))))))
            {
                cp_foldable_list = _add_range_to_invlist(cp_foldable_list,
                                                         prevvalue, value);
            }
            else {
                /* Here, requires special handling.  This can be because it is
                 * a range whose code points are considered to be Unicode, and
                 * so must be individually translated into native, or because
                 * its a subrange of 'A-Z' or 'a-z' which each aren't
                 * contiguous in EBCDIC, but we have defined them to include
                 * only the "expected" upper or lower case ASCII alphabetics.
                 * Subranges above 255 are the same in native and Unicode, so
                 * can be added as a range */
                U8 start = NATIVE_TO_LATIN1(prevvalue);
                unsigned j;
                U8 end = (value < 256) ? NATIVE_TO_LATIN1(value) : 255;
                for (j = start; j <= end; j++) {
                    cp_foldable_list = add_cp_to_invlist(cp_foldable_list, LATIN1_TO_NATIVE(j));
                }
                if (value > 255) {
                    cp_foldable_list = _add_range_to_invlist(cp_foldable_list,
                                                             256, value);
                }
            }
#endif
        }

	range = 0; /* this range (if it was one) is done now */
    } /* End of loop through all the text within the brackets */


    if (   posix_warnings && av_tindex_nomg(posix_warnings) >= 0) {
        output_or_return_posix_warnings(pRExC_state, posix_warnings,
                                        return_posix_warnings);
    }

    /* If anything in the class expands to more than one character, we have to
     * deal with them by building up a substitute parse string, and recursively
     * calling reg() on it, instead of proceeding */
    if (multi_char_matches) {
	SV * substitute_parse = newSVpvn_flags("?:", 2, SVs_TEMP);
        I32 cp_count;
	STRLEN len;
	char *save_end = RExC_end;
	char *save_parse = RExC_parse;
	char *save_start = RExC_start;
        STRLEN prefix_end = 0;      /* We copy the character class after a
                                       prefix supplied here.  This is the size
                                       + 1 of that prefix */
        bool first_time = TRUE;     /* First multi-char occurrence doesn't get
                                       a "|" */
        I32 reg_flags;

        assert(! invert);
        assert(RExC_precomp_adj == 0); /* Only one level of recursion allowed */

#if 0   /* Have decided not to deal with multi-char folds in inverted classes,
           because too confusing */
        if (invert) {
            sv_catpv(substitute_parse, "(?:");
        }
#endif

        /* Look at the longest folds first */
        for (cp_count = av_tindex_nomg(multi_char_matches);
                        cp_count > 0;
                        cp_count--)
        {

            if (av_exists(multi_char_matches, cp_count)) {
                AV** this_array_ptr;
                SV* this_sequence;

                this_array_ptr = (AV**) av_fetch(multi_char_matches,
                                                 cp_count, FALSE);
                while ((this_sequence = av_pop(*this_array_ptr)) !=
                                                                &PL_sv_undef)
                {
                    if (! first_time) {
                        sv_catpv(substitute_parse, "|");
                    }
                    first_time = FALSE;

                    sv_catpv(substitute_parse, SvPVX(this_sequence));
                }
            }
        }

        /* If the character class contains anything else besides these
         * multi-character folds, have to include it in recursive parsing */
        if (element_count) {
            sv_catpv(substitute_parse, "|[");
            prefix_end = SvCUR(substitute_parse);
            sv_catpvn(substitute_parse, orig_parse, RExC_parse - orig_parse);

            /* Put in a closing ']' only if not going off the end, as otherwise
             * we are adding something that really isn't there */
            if (RExC_parse < RExC_end) {
                sv_catpv(substitute_parse, "]");
            }
        }

        sv_catpv(substitute_parse, ")");
#if 0
        if (invert) {
            /* This is a way to get the parse to skip forward a whole named
             * sequence instead of matching the 2nd character when it fails the
             * first */
            sv_catpv(substitute_parse, "(*THEN)(*SKIP)(*FAIL)|.)");
        }
#endif

        /* Set up the data structure so that any errors will be properly
         * reported.  See the comments at the definition of
         * REPORT_LOCATION_ARGS for details */
        RExC_precomp_adj = orig_parse - RExC_precomp;
	RExC_start =  RExC_parse = SvPV(substitute_parse, len);
        RExC_adjusted_start = RExC_start + prefix_end;
	RExC_end = RExC_parse + len;
        RExC_in_multi_char_class = 1;
	RExC_override_recoding = 1;
        RExC_emit = (regnode *)orig_emit;

	ret = reg(pRExC_state, 1, &reg_flags, depth+1);

	*flagp |= reg_flags&(HASWIDTH|SIMPLE|SPSTART|POSTPONED|RESTART_PASS1|NEED_UTF8);

        /* And restore so can parse the rest of the pattern */
        RExC_parse = save_parse;
	RExC_start = RExC_adjusted_start = save_start;
        RExC_precomp_adj = 0;
	RExC_end = save_end;
	RExC_in_multi_char_class = 0;
	RExC_override_recoding = 0;
        SvREFCNT_dec_NN(multi_char_matches);
        return ret;
    }

    /* Here, we've gone through the entire class and dealt with multi-char
     * folds.  We are now in a position that we can do some checks to see if we
     * can optimize this ANYOF node into a simpler one, even in Pass 1.
     * Currently we only do two checks:
     * 1) is in the unlikely event that the user has specified both, eg. \w and
     *    \W under /l, then the class matches everything.  (This optimization
     *    is done only to make the optimizer code run later work.)
     * 2) if the character class contains only a single element (including a
     *    single range), we see if there is an equivalent node for it.
     * Other checks are possible */
    if (   optimizable
        && ! ret_invlist   /* Can't optimize if returning the constructed
                              inversion list */
        && (UNLIKELY(posixl_matches_all) || element_count == 1))
    {
        U8 op = END;
        U8 arg = 0;

        if (UNLIKELY(posixl_matches_all)) {
            op = SANY;
        }
        else if (namedclass > OOB_NAMEDCLASS) { /* this is a single named
                                                   class, like \w or [:digit:]
                                                   or \p{foo} */

            /* All named classes are mapped into POSIXish nodes, with its FLAG
             * argument giving which class it is */
            switch ((I32)namedclass) {
                case ANYOF_UNIPROP:
                    break;

                /* These don't depend on the charset modifiers.  They always
                 * match under /u rules */
                case ANYOF_NHORIZWS:
                case ANYOF_HORIZWS:
                    namedclass = ANYOF_BLANK + namedclass - ANYOF_HORIZWS;
                    /* FALLTHROUGH */

                case ANYOF_NVERTWS:
                case ANYOF_VERTWS:
                    op = POSIXU;
                    goto join_posix;

                /* The actual POSIXish node for all the rest depends on the
                 * charset modifier.  The ones in the first set depend only on
                 * ASCII or, if available on this platform, also locale */
                case ANYOF_ASCII:
                case ANYOF_NASCII:
#ifdef HAS_ISASCII
                    op = (LOC) ? POSIXL : POSIXA;
#else
                    op = POSIXA;
#endif
                    goto join_posix;

                /* The following don't have any matches in the upper Latin1
                 * range, hence /d is equivalent to /u for them.  Making it /u
                 * saves some branches at runtime */
                case ANYOF_DIGIT:
                case ANYOF_NDIGIT:
                case ANYOF_XDIGIT:
                case ANYOF_NXDIGIT:
                    if (! DEPENDS_SEMANTICS) {
                        goto treat_as_default;
                    }

                    op = POSIXU;
                    goto join_posix;

                /* The following change to CASED under /i */
                case ANYOF_LOWER:
                case ANYOF_NLOWER:
                case ANYOF_UPPER:
                case ANYOF_NUPPER:
                    if (FOLD) {
                        namedclass = ANYOF_CASED + (namedclass % 2);
                    }
                    /* FALLTHROUGH */

                /* The rest have more possibilities depending on the charset.
                 * We take advantage of the enum ordering of the charset
                 * modifiers to get the exact node type, */
                default:
                  treat_as_default:
                    op = POSIXD + get_regex_charset(RExC_flags);
                    if (op > POSIXA) { /* /aa is same as /a */
                        op = POSIXA;
                    }

                  join_posix:
                    /* The odd numbered ones are the complements of the
                     * next-lower even number one */
                    if (namedclass % 2 == 1) {
                        invert = ! invert;
                        namedclass--;
                    }
                    arg = namedclass_to_classnum(namedclass);
                    break;
            }
        }
        else if (value == prevvalue) {

            /* Here, the class consists of just a single code point */

            if (invert) {
                if (! LOC && value == '\n') {
                    op = REG_ANY; /* Optimize [^\n] */
                    *flagp |= HASWIDTH|SIMPLE;
                    MARK_NAUGHTY(1);
                }
            }
            else if (value < 256 || UTF) {

                /* Optimize a single value into an EXACTish node, but not if it
                 * would require converting the pattern to UTF-8. */
                op = compute_EXACTish(pRExC_state);
            }
        } /* Otherwise is a range */
        else if (! LOC) {   /* locale could vary these */
            if (prevvalue == '0') {
                if (value == '9') {
                    arg = _CC_DIGIT;
                    op = POSIXA;
                }
            }
            else if (! FOLD || ASCII_FOLD_RESTRICTED) {
                /* We can optimize A-Z or a-z, but not if they could match
                 * something like the KELVIN SIGN under /i. */
                if (prevvalue == 'A') {
                    if (value == 'Z'
#ifdef EBCDIC
                        && ! non_portable_endpoint
#endif
                    ) {
                        arg = (FOLD) ? _CC_ALPHA : _CC_UPPER;
                        op = POSIXA;
                    }
                }
                else if (prevvalue == 'a') {
                    if (value == 'z'
#ifdef EBCDIC
                        && ! non_portable_endpoint
#endif
                    ) {
                        arg = (FOLD) ? _CC_ALPHA : _CC_LOWER;
                        op = POSIXA;
                    }
                }
            }
        }

        /* Here, we have changed <op> away from its initial value iff we found
         * an optimization */
        if (op != END) {

            /* Throw away this ANYOF regnode, and emit the calculated one,
             * which should correspond to the beginning, not current, state of
             * the parse */
            const char * cur_parse = RExC_parse;
            RExC_parse = (char *)orig_parse;
            if ( SIZE_ONLY) {
                if (! LOC) {

                    /* To get locale nodes to not use the full ANYOF size would
                     * require moving the code above that writes the portions
                     * of it that aren't in other nodes to after this point.
                     * e.g.  ANYOF_POSIXL_SET */
                    RExC_size = orig_size;
                }
            }
            else {
                RExC_emit = (regnode *)orig_emit;
                if (PL_regkind[op] == POSIXD) {
                    if (op == POSIXL) {
                        RExC_contains_locale = 1;
                    }
                    if (invert) {
                        op += NPOSIXD - POSIXD;
                    }
                }
            }

            ret = reg_node(pRExC_state, op);

            if (PL_regkind[op] == POSIXD || PL_regkind[op] == NPOSIXD) {
                if (! SIZE_ONLY) {
                    FLAGS(ret) = arg;
                }
                *flagp |= HASWIDTH|SIMPLE;
            }
            else if (PL_regkind[op] == EXACT) {
                alloc_maybe_populate_EXACT(pRExC_state, ret, flagp, 0, value,
                                           TRUE /* downgradable to EXACT */
                                           );
            }

            RExC_parse = (char *) cur_parse;

            SvREFCNT_dec(posixes);
            SvREFCNT_dec(nposixes);
            SvREFCNT_dec(simple_posixes);
            SvREFCNT_dec(cp_list);
            SvREFCNT_dec(cp_foldable_list);
            return ret;
        }
    }

    if (SIZE_ONLY)
        return ret;
    /****** !SIZE_ONLY (Pass 2) AFTER HERE *********/

    /* If folding, we calculate all characters that could fold to or from the
     * ones already on the list */
    if (cp_foldable_list) {
        if (FOLD) {
            UV start, end;	/* End points of code point ranges */

            SV* fold_intersection = NULL;
            SV** use_list;

            /* Our calculated list will be for Unicode rules.  For locale
             * matching, we have to keep a separate list that is consulted at
             * runtime only when the locale indicates Unicode rules.  For
             * non-locale, we just use the general list */
            if (LOC) {
                use_list = &only_utf8_locale_list;
            }
            else {
                use_list = &cp_list;
            }

            /* Only the characters in this class that participate in folds need
             * be checked.  Get the intersection of this class and all the
             * possible characters that are foldable.  This can quickly narrow
             * down a large class */
            _invlist_intersection(PL_utf8_foldable, cp_foldable_list,
                                  &fold_intersection);

            /* The folds for all the Latin1 characters are hard-coded into this
             * program, but we have to go out to disk to get the others. */
            if (invlist_highest(cp_foldable_list) >= 256) {

                /* This is a hash that for a particular fold gives all
                 * characters that are involved in it */
                if (! PL_utf8_foldclosures) {
                    _load_PL_utf8_foldclosures();
                }
            }

            /* Now look at the foldable characters in this class individually */
            invlist_iterinit(fold_intersection);
            while (invlist_iternext(fold_intersection, &start, &end)) {
                UV j;

                /* Look at every character in the range */
                for (j = start; j <= end; j++) {
                    U8 foldbuf[UTF8_MAXBYTES_CASE+1];
                    STRLEN foldlen;
                    SV** listp;

                    if (j < 256) {

                        if (IS_IN_SOME_FOLD_L1(j)) {

                            /* ASCII is always matched; non-ASCII is matched
                             * only under Unicode rules (which could happen
                             * under /l if the locale is a UTF-8 one */
                            if (isASCII(j) || ! DEPENDS_SEMANTICS) {
                                *use_list = add_cp_to_invlist(*use_list,
                                                            PL_fold_latin1[j]);
                            }
                            else {
                                has_upper_latin1_only_utf8_matches
                                    = add_cp_to_invlist(
                                            has_upper_latin1_only_utf8_matches,
                                            PL_fold_latin1[j]);
                            }
                        }

                        if (HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(j)
                            && (! isASCII(j) || ! ASCII_FOLD_RESTRICTED))
                        {
                            add_above_Latin1_folds(pRExC_state,
                                                   (U8) j,
                                                   use_list);
                        }
                        continue;
                    }

                    /* Here is an above Latin1 character.  We don't have the
                     * rules hard-coded for it.  First, get its fold.  This is
                     * the simple fold, as the multi-character folds have been
                     * handled earlier and separated out */
                    _to_uni_fold_flags(j, foldbuf, &foldlen,
                                                        (ASCII_FOLD_RESTRICTED)
                                                        ? FOLD_FLAGS_NOMIX_ASCII
                                                        : 0);

                    /* Single character fold of above Latin1.  Add everything in
                    * its fold closure to the list that this node should match.
                    * The fold closures data structure is a hash with the keys
                    * being the UTF-8 of every character that is folded to, like
                    * 'k', and the values each an array of all code points that
                    * fold to its key.  e.g. [ 'k', 'K', KELVIN_SIGN ].
                    * Multi-character folds are not included */
                    if ((listp = hv_fetch(PL_utf8_foldclosures,
                                        (char *) foldbuf, foldlen, FALSE)))
                    {
                        AV* list = (AV*) *listp;
                        IV k;
                        for (k = 0; k <= av_tindex_nomg(list); k++) {
                            SV** c_p = av_fetch(list, k, FALSE);
                            UV c;
                            assert(c_p);

                            c = SvUV(*c_p);

                            /* /aa doesn't allow folds between ASCII and non- */
                            if ((ASCII_FOLD_RESTRICTED
                                && (isASCII(c) != isASCII(j))))
                            {
                                continue;
                            }

                            /* Folds under /l which cross the 255/256 boundary
                             * are added to a separate list.  (These are valid
                             * only when the locale is UTF-8.) */
                            if (c < 256 && LOC) {
                                *use_list = add_cp_to_invlist(*use_list, c);
                                continue;
                            }

                            if (isASCII(c) || c > 255 || AT_LEAST_UNI_SEMANTICS)
                            {
                                cp_list = add_cp_to_invlist(cp_list, c);
                            }
                            else {
                                /* Similarly folds involving non-ascii Latin1
                                * characters under /d are added to their list */
                                has_upper_latin1_only_utf8_matches
                                        = add_cp_to_invlist(
                                           has_upper_latin1_only_utf8_matches,
                                           c);
                            }
                        }
                    }
                }
            }
            SvREFCNT_dec_NN(fold_intersection);
        }

        /* Now that we have finished adding all the folds, there is no reason
         * to keep the foldable list separate */
        _invlist_union(cp_list, cp_foldable_list, &cp_list);
	SvREFCNT_dec_NN(cp_foldable_list);
    }

    /* And combine the result (if any) with any inversion list from posix
     * classes.  The lists are kept separate up to now because we don't want to
     * fold the classes (folding of those is automatically handled by the swash
     * fetching code) */
    if (simple_posixes) {
        _invlist_union(cp_list, simple_posixes, &cp_list);
        SvREFCNT_dec_NN(simple_posixes);
    }
    if (posixes || nposixes) {
        if (posixes && AT_LEAST_ASCII_RESTRICTED) {
            /* Under /a and /aa, nothing above ASCII matches these */
            _invlist_intersection(posixes,
                                  PL_XPosix_ptrs[_CC_ASCII],
                                  &posixes);
        }
        if (nposixes) {
            if (DEPENDS_SEMANTICS) {
                /* Under /d, everything in the upper half of the Latin1 range
                 * matches these complements */
                ANYOF_FLAGS(ret) |= ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER;
            }
            else if (AT_LEAST_ASCII_RESTRICTED) {
                /* Under /a and /aa, everything above ASCII matches these
                 * complements */
                _invlist_union_complement_2nd(nposixes,
                                              PL_XPosix_ptrs[_CC_ASCII],
                                              &nposixes);
            }
            if (posixes) {
                _invlist_union(posixes, nposixes, &posixes);
                SvREFCNT_dec_NN(nposixes);
            }
            else {
                posixes = nposixes;
            }
        }
        if (! DEPENDS_SEMANTICS) {
            if (cp_list) {
                _invlist_union(cp_list, posixes, &cp_list);
                SvREFCNT_dec_NN(posixes);
            }
            else {
                cp_list = posixes;
            }
        }
        else {
            /* Under /d, we put into a separate list the Latin1 things that
             * match only when the target string is utf8 */
            SV* nonascii_but_latin1_properties = NULL;
            _invlist_intersection(posixes, PL_UpperLatin1,
                                  &nonascii_but_latin1_properties);
            _invlist_subtract(posixes, nonascii_but_latin1_properties,
                              &posixes);
            if (cp_list) {
                _invlist_union(cp_list, posixes, &cp_list);
                SvREFCNT_dec_NN(posixes);
            }
            else {
                cp_list = posixes;
            }

            if (has_upper_latin1_only_utf8_matches) {
                _invlist_union(has_upper_latin1_only_utf8_matches,
                               nonascii_but_latin1_properties,
                               &has_upper_latin1_only_utf8_matches);
                SvREFCNT_dec_NN(nonascii_but_latin1_properties);
            }
            else {
                has_upper_latin1_only_utf8_matches
                                            = nonascii_but_latin1_properties;
            }
        }
    }

    /* And combine the result (if any) with any inversion list from properties.
     * The lists are kept separate up to now so that we can distinguish the two
     * in regards to matching above-Unicode.  A run-time warning is generated
     * if a Unicode property is matched against a non-Unicode code point. But,
     * we allow user-defined properties to match anything, without any warning,
     * and we also suppress the warning if there is a portion of the character
     * class that isn't a Unicode property, and which matches above Unicode, \W
     * or [\x{110000}] for example.
     * (Note that in this case, unlike the Posix one above, there is no
     * <has_upper_latin1_only_utf8_matches>, because having a Unicode property
     * forces Unicode semantics */
    if (properties) {
        if (cp_list) {

            /* If it matters to the final outcome, see if a non-property
             * component of the class matches above Unicode.  If so, the
             * warning gets suppressed.  This is true even if just a single
             * such code point is specified, as, though not strictly correct if
             * another such code point is matched against, the fact that they
             * are using above-Unicode code points indicates they should know
             * the issues involved */
            if (warn_super) {
                warn_super = ! (invert
                               ^ (invlist_highest(cp_list) > PERL_UNICODE_MAX));
            }

            _invlist_union(properties, cp_list, &cp_list);
            SvREFCNT_dec_NN(properties);
        }
        else {
            cp_list = properties;
        }

        if (warn_super) {
            ANYOF_FLAGS(ret)
             |= ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER;

            /* Because an ANYOF node is the only one that warns, this node
             * can't be optimized into something else */
            optimizable = FALSE;
        }
    }

    /* Here, we have calculated what code points should be in the character
     * class.
     *
     * Now we can see about various optimizations.  Fold calculation (which we
     * did above) needs to take place before inversion.  Otherwise /[^k]/i
     * would invert to include K, which under /i would match k, which it
     * shouldn't.  Therefore we can't invert folded locale now, as it won't be
     * folded until runtime */

    /* If we didn't do folding, it's because some information isn't available
     * until runtime; set the run-time fold flag for these.  (We don't have to
     * worry about properties folding, as that is taken care of by the swash
     * fetching).  We know to set the flag if we have a non-NULL list for UTF-8
     * locales, or the class matches at least one 0-255 range code point */
    if (LOC && FOLD) {

        /* Some things on the list might be unconditionally included because of
         * other components.  Remove them, and clean up the list if it goes to
         * 0 elements */
        if (only_utf8_locale_list && cp_list) {
            _invlist_subtract(only_utf8_locale_list, cp_list,
                              &only_utf8_locale_list);

            if (_invlist_len(only_utf8_locale_list) == 0) {
                SvREFCNT_dec_NN(only_utf8_locale_list);
                only_utf8_locale_list = NULL;
            }
        }
        if (only_utf8_locale_list) {
            ANYOF_FLAGS(ret)
                 |=  ANYOFL_FOLD
                    |ANYOFL_SHARED_UTF8_LOCALE_fold_HAS_MATCHES_nonfold_REQD;
        }
        else if (cp_list) { /* Look to see if a 0-255 code point is in list */
            UV start, end;
            invlist_iterinit(cp_list);
            if (invlist_iternext(cp_list, &start, &end) && start < 256) {
                ANYOF_FLAGS(ret) |= ANYOFL_FOLD;
            }
            invlist_iterfinish(cp_list);
        }
    }

#define MATCHES_ALL_NON_UTF8_NON_ASCII(ret)                                 \
    (   DEPENDS_SEMANTICS                                                   \
     && (ANYOF_FLAGS(ret)                                                   \
        & ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER))

    /* See if we can simplify things under /d */
    if (   has_upper_latin1_only_utf8_matches
        || MATCHES_ALL_NON_UTF8_NON_ASCII(ret))
    {
        /* But not if we are inverting, as that screws it up */
        if (! invert) {
            if (has_upper_latin1_only_utf8_matches) {
                if (MATCHES_ALL_NON_UTF8_NON_ASCII(ret)) {

                    /* Here, we have both the flag and inversion list.  Any
                     * character in 'has_upper_latin1_only_utf8_matches'
                     * matches when UTF-8 is in effect, but it also matches
                     * when UTF-8 is not in effect because of
                     * MATCHES_ALL_NON_UTF8_NON_ASCII.  Therefore it matches
                     * unconditionally, so can be added to the regular list,
                     * and 'has_upper_latin1_only_utf8_matches' cleared */
                    _invlist_union(cp_list,
                                   has_upper_latin1_only_utf8_matches,
                                   &cp_list);
                    SvREFCNT_dec_NN(has_upper_latin1_only_utf8_matches);
                    has_upper_latin1_only_utf8_matches = NULL;
                }
                else if (cp_list) {

                    /* Here, 'cp_list' gives chars that always match, and
                     * 'has_upper_latin1_only_utf8_matches' gives chars that
                     * were specified to match only if the target string is in
                     * UTF-8.  It may be that these overlap, so we can subtract
                     * the unconditionally matching from the conditional ones,
                     * to make the conditional list as small as possible,
                     * perhaps even clearing it, in which case more
                     * optimizations are possible later */
                    _invlist_subtract(has_upper_latin1_only_utf8_matches,
                                      cp_list,
                                      &has_upper_latin1_only_utf8_matches);
                    if (_invlist_len(has_upper_latin1_only_utf8_matches) == 0) {
                        SvREFCNT_dec_NN(has_upper_latin1_only_utf8_matches);
                        has_upper_latin1_only_utf8_matches = NULL;
                    }
                }
            }

            /* Similarly, if the unconditional matches include every upper
             * latin1 character, we can clear that flag to permit later
             * optimizations */
            if (cp_list && MATCHES_ALL_NON_UTF8_NON_ASCII(ret)) {
                SV* only_non_utf8_list = invlist_clone(PL_UpperLatin1);
                _invlist_subtract(only_non_utf8_list, cp_list,
                                  &only_non_utf8_list);
                if (_invlist_len(only_non_utf8_list) == 0) {
                    ANYOF_FLAGS(ret) &= ~ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER;
                }
                SvREFCNT_dec_NN(only_non_utf8_list);
                only_non_utf8_list = NULL;;
            }
        }

        /* If we haven't gotten rid of all conditional matching, we change the
         * regnode type to indicate that */
        if (   has_upper_latin1_only_utf8_matches
            || MATCHES_ALL_NON_UTF8_NON_ASCII(ret))
        {
            OP(ret) = ANYOFD;
            optimizable = FALSE;
        }
    }
#undef MATCHES_ALL_NON_UTF8_NON_ASCII

    /* Optimize inverted simple patterns (e.g. [^a-z]) when everything is known
     * at compile time.  Besides not inverting folded locale now, we can't
     * invert if there are things such as \w, which aren't known until runtime
     * */
    if (cp_list
        && invert
        && OP(ret) != ANYOFD
        && ! (ANYOF_FLAGS(ret) & (ANYOF_LOCALE_FLAGS))
	&& ! HAS_NONLOCALE_RUNTIME_PROPERTY_DEFINITION)
    {
        _invlist_invert(cp_list);

        /* Any swash can't be used as-is, because we've inverted things */
        if (swash) {
            SvREFCNT_dec_NN(swash);
            swash = NULL;
        }

	/* Clear the invert flag since have just done it here */
	invert = FALSE;
    }

    if (ret_invlist) {
        assert(cp_list);

        *ret_invlist = cp_list;
        SvREFCNT_dec(swash);

        /* Discard the generated node */
        if (SIZE_ONLY) {
            RExC_size = orig_size;
        }
        else {
            RExC_emit = orig_emit;
        }
        return orig_emit;
    }

    /* Some character classes are equivalent to other nodes.  Such nodes take
     * up less room and generally fewer operations to execute than ANYOF nodes.
     * Above, we checked for and optimized into some such equivalents for
     * certain common classes that are easy to test.  Getting to this point in
     * the code means that the class didn't get optimized there.  Since this
     * code is only executed in Pass 2, it is too late to save space--it has
     * been allocated in Pass 1, and currently isn't given back.  But turning
     * things into an EXACTish node can allow the optimizer to join it to any
     * adjacent such nodes.  And if the class is equivalent to things like /./,
     * expensive run-time swashes can be avoided.  Now that we have more
     * complete information, we can find things necessarily missed by the
     * earlier code.  Another possible "optimization" that isn't done is that
     * something like [Ee] could be changed into an EXACTFU.  khw tried this
     * and found that the ANYOF is faster, including for code points not in the
     * bitmap.  This still might make sense to do, provided it got joined with
     * an adjacent node(s) to create a longer EXACTFU one.  This could be
     * accomplished by creating a pseudo ANYOF_EXACTFU node type that the join
     * routine would know is joinable.  If that didn't happen, the node type
     * could then be made a straight ANYOF */

    if (optimizable && cp_list && ! invert) {
        UV start, end;
        U8 op = END;  /* The optimzation node-type */
        int posix_class = -1;   /* Illegal value */
        const char * cur_parse= RExC_parse;

        invlist_iterinit(cp_list);
        if (! invlist_iternext(cp_list, &start, &end)) {

            /* Here, the list is empty.  This happens, for example, when a
             * Unicode property that doesn't match anything is the only element
             * in the character class (perluniprops.pod notes such properties).
             * */
            op = OPFAIL;
            *flagp |= HASWIDTH|SIMPLE;
        }
        else if (start == end) {    /* The range is a single code point */
            if (! invlist_iternext(cp_list, &start, &end)

                    /* Don't do this optimization if it would require changing
                     * the pattern to UTF-8 */
                && (start < 256 || UTF))
            {
                /* Here, the list contains a single code point.  Can optimize
                 * into an EXACTish node */

                value = start;

                if (! FOLD) {
                    op = (LOC)
                         ? EXACTL
                         : EXACT;
                }
                else if (LOC) {

                    /* A locale node under folding with one code point can be
                     * an EXACTFL, as its fold won't be calculated until
                     * runtime */
                    op = EXACTFL;
                }
                else {

                    /* Here, we are generally folding, but there is only one
                     * code point to match.  If we have to, we use an EXACT
                     * node, but it would be better for joining with adjacent
                     * nodes in the optimization pass if we used the same
                     * EXACTFish node that any such are likely to be.  We can
                     * do this iff the code point doesn't participate in any
                     * folds.  For example, an EXACTF of a colon is the same as
                     * an EXACT one, since nothing folds to or from a colon. */
                    if (value < 256) {
                        if (IS_IN_SOME_FOLD_L1(value)) {
                            op = EXACT;
                        }
                    }
                    else {
                        if (_invlist_contains_cp(PL_utf8_foldable, value)) {
                            op = EXACT;
                        }
                    }

                    /* If we haven't found the node type, above, it means we
                     * can use the prevailing one */
                    if (op == END) {
                        op = compute_EXACTish(pRExC_state);
                    }
                }
            }
        }   /* End of first range contains just a single code point */
        else if (start == 0) {
            if (end == UV_MAX) {
                op = SANY;
                *flagp |= HASWIDTH|SIMPLE;
                MARK_NAUGHTY(1);
            }
            else if (end == '\n' - 1
                    && invlist_iternext(cp_list, &start, &end)
                    && start == '\n' + 1 && end == UV_MAX)
            {
                op = REG_ANY;
                *flagp |= HASWIDTH|SIMPLE;
                MARK_NAUGHTY(1);
            }
        }
        invlist_iterfinish(cp_list);

        if (op == END) {
            const UV cp_list_len = _invlist_len(cp_list);
            const UV* cp_list_array = invlist_array(cp_list);

            /* Here, didn't find an optimization.  See if this matches any of
             * the POSIX classes.  These run slightly faster for above-Unicode
             * code points, so don't bother with POSIXA ones nor the 2 that
             * have no above-Unicode matches.  We can avoid these checks unless
             * the ANYOF matches at least as high as the lowest POSIX one
             * (which was manually found to be \v.  The actual code point may
             * increase in later Unicode releases, if a higher code point is
             * assigned to be \v, but this code will never break.  It would
             * just mean we could execute the checks for posix optimizations
             * unnecessarily) */

            if (cp_list_array[cp_list_len-1] > 0x2029) {
                for (posix_class = 0;
                     posix_class <= _HIGHEST_REGCOMP_DOT_H_SYNC;
                     posix_class++)
                {
                    int try_inverted;
                    if (posix_class == _CC_ASCII || posix_class == _CC_CNTRL) {
                        continue;
                    }
                    for (try_inverted = 0; try_inverted < 2; try_inverted++) {

                        /* Check if matches normal or inverted */
                        if (_invlistEQ(cp_list,
                                       PL_XPosix_ptrs[posix_class],
                                       try_inverted))
                        {
                            op = (try_inverted)
                                 ? NPOSIXU
                                 : POSIXU;
                            *flagp |= HASWIDTH|SIMPLE;
                            goto found_posix;
                        }
                    }
                }
              found_posix: ;
            }
        }

        if (op != END) {
            RExC_parse = (char *)orig_parse;
            RExC_emit = (regnode *)orig_emit;

            if (regarglen[op]) {
                ret = reganode(pRExC_state, op, 0);
            } else {
                ret = reg_node(pRExC_state, op);
            }

            RExC_parse = (char *)cur_parse;

            if (PL_regkind[op] == EXACT) {
                alloc_maybe_populate_EXACT(pRExC_state, ret, flagp, 0, value,
                                           TRUE /* downgradable to EXACT */
                                          );
            }
            else if (PL_regkind[op] == POSIXD || PL_regkind[op] == NPOSIXD) {
                FLAGS(ret) = posix_class;
            }

            SvREFCNT_dec_NN(cp_list);
            return ret;
        }
    }

    /* Here, <cp_list> contains all the code points we can determine at
     * compile time that match under all conditions.  Go through it, and
     * for things that belong in the bitmap, put them there, and delete from
     * <cp_list>.  While we are at it, see if everything above 255 is in the
     * list, and if so, set a flag to speed up execution */

    populate_ANYOF_from_invlist(ret, &cp_list);

    if (invert) {
        ANYOF_FLAGS(ret) |= ANYOF_INVERT;
    }

    /* Here, the bitmap has been populated with all the Latin1 code points that
     * always match.  Can now add to the overall list those that match only
     * when the target string is UTF-8 (<has_upper_latin1_only_utf8_matches>).
     * */
    if (has_upper_latin1_only_utf8_matches) {
	if (cp_list) {
	    _invlist_union(cp_list,
                           has_upper_latin1_only_utf8_matches,
                           &cp_list);
	    SvREFCNT_dec_NN(has_upper_latin1_only_utf8_matches);
	}
	else {
	    cp_list = has_upper_latin1_only_utf8_matches;
	}
        ANYOF_FLAGS(ret) |= ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP;
    }

    /* If there is a swash and more than one element, we can't use the swash in
     * the optimization below. */
    if (swash && element_count > 1) {
	SvREFCNT_dec_NN(swash);
	swash = NULL;
    }

    /* Note that the optimization of using 'swash' if it is the only thing in
     * the class doesn't have us change swash at all, so it can include things
     * that are also in the bitmap; otherwise we have purposely deleted that
     * duplicate information */
    set_ANYOF_arg(pRExC_state, ret, cp_list,
                  (HAS_NONLOCALE_RUNTIME_PROPERTY_DEFINITION)
                   ? listsv : NULL,
                  only_utf8_locale_list,
                  swash, has_user_defined_property);

    *flagp |= HASWIDTH|SIMPLE;

    if (ANYOF_FLAGS(ret) & ANYOF_LOCALE_FLAGS) {
        RExC_contains_locale = 1;
    }

    return ret;
}

#undef HAS_NONLOCALE_RUNTIME_PROPERTY_DEFINITION

STATIC void
S_set_ANYOF_arg(pTHX_ RExC_state_t* const pRExC_state,
                regnode* const node,
                SV* const cp_list,
                SV* const runtime_defns,
                SV* const only_utf8_locale_list,
                SV* const swash,
                const bool has_user_defined_property)
{
    /* Sets the arg field of an ANYOF-type node 'node', using information about
     * the node passed-in.  If there is nothing outside the node's bitmap, the
     * arg is set to ANYOF_ONLY_HAS_BITMAP.  Otherwise, it sets the argument to
     * the count returned by add_data(), having allocated and stored an array,
     * av, that that count references, as follows:
     *  av[0] stores the character class description in its textual form.
     *        This is used later (regexec.c:Perl_regclass_swash()) to
     *        initialize the appropriate swash, and is also useful for dumping
     *        the regnode.  This is set to &PL_sv_undef if the textual
     *        description is not needed at run-time (as happens if the other
     *        elements completely define the class)
     *  av[1] if &PL_sv_undef, is a placeholder to later contain the swash
     *        computed from av[0].  But if no further computation need be done,
     *        the swash is stored here now (and av[0] is &PL_sv_undef).
     *  av[2] stores the inversion list of code points that match only if the
     *        current locale is UTF-8
     *  av[3] stores the cp_list inversion list for use in addition or instead
     *        of av[0]; used only if cp_list exists and av[1] is &PL_sv_undef.
     *        (Otherwise everything needed is already in av[0] and av[1])
     *  av[4] is set if any component of the class is from a user-defined
     *        property; used only if av[3] exists */

    UV n;

    PERL_ARGS_ASSERT_SET_ANYOF_ARG;

    if (! cp_list && ! runtime_defns && ! only_utf8_locale_list) {
        assert(! (ANYOF_FLAGS(node)
                & ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP));
	ARG_SET(node, ANYOF_ONLY_HAS_BITMAP);
    }
    else {
	AV * const av = newAV();
	SV *rv;

	av_store(av, 0, (runtime_defns)
			? SvREFCNT_inc(runtime_defns) : &PL_sv_undef);
	if (swash) {
	    assert(cp_list);
	    av_store(av, 1, swash);
	    SvREFCNT_dec_NN(cp_list);
	}
	else {
	    av_store(av, 1, &PL_sv_undef);
	    if (cp_list) {
		av_store(av, 3, cp_list);
		av_store(av, 4, newSVuv(has_user_defined_property));
	    }
	}

        if (only_utf8_locale_list) {
	    av_store(av, 2, only_utf8_locale_list);
        }
        else {
	    av_store(av, 2, &PL_sv_undef);
        }

	rv = newRV_noinc(MUTABLE_SV(av));
	n = add_data(pRExC_state, STR_WITH_LEN("s"));
	RExC_rxi->data->data[n] = (void*)rv;
	ARG_SET(node, n);
    }
}

#if !defined(PERL_IN_XSUB_RE) || defined(PLUGGABLE_RE_EXTENSION)
SV *
Perl__get_regclass_nonbitmap_data(pTHX_ const regexp *prog,
                                        const regnode* node,
                                        bool doinit,
                                        SV** listsvp,
                                        SV** only_utf8_locale_ptr,
                                        SV** output_invlist)

{
    /* For internal core use only.
     * Returns the swash for the input 'node' in the regex 'prog'.
     * If <doinit> is 'true', will attempt to create the swash if not already
     *	  done.
     * If <listsvp> is non-null, will return the printable contents of the
     *    swash.  This can be used to get debugging information even before the
     *    swash exists, by calling this function with 'doinit' set to false, in
     *    which case the components that will be used to eventually create the
     *    swash are returned  (in a printable form).
     * If <only_utf8_locale_ptr> is not NULL, it is where this routine is to
     *    store an inversion list of code points that should match only if the
     *    execution-time locale is a UTF-8 one.
     * If <output_invlist> is not NULL, it is where this routine is to store an
     *    inversion list of the code points that would be instead returned in
     *    <listsvp> if this were NULL.  Thus, what gets output in <listsvp>
     *    when this parameter is used, is just the non-code point data that
     *    will go into creating the swash.  This currently should be just
     *    user-defined properties whose definitions were not known at compile
     *    time.  Using this parameter allows for easier manipulation of the
     *    swash's data by the caller.  It is illegal to call this function with
     *    this parameter set, but not <listsvp>
     *
     * Tied intimately to how S_set_ANYOF_arg sets up the data structure.  Note
     * that, in spite of this function's name, the swash it returns may include
     * the bitmap data as well */

    SV *sw  = NULL;
    SV *si  = NULL;         /* Input swash initialization string */
    SV* invlist = NULL;

    RXi_GET_DECL(prog,progi);
    const struct reg_data * const data = prog ? progi->data : NULL;

    PERL_ARGS_ASSERT__GET_REGCLASS_NONBITMAP_DATA;
    assert(! output_invlist || listsvp);

    if (data && data->count) {
	const U32 n = ARG(node);

	if (data->what[n] == 's') {
	    SV * const rv = MUTABLE_SV(data->data[n]);
	    AV * const av = MUTABLE_AV(SvRV(rv));
	    SV **const ary = AvARRAY(av);
	    U8 swash_init_flags = _CORE_SWASH_INIT_ACCEPT_INVLIST;

	    si = *ary;	/* ary[0] = the string to initialize the swash with */

            if (av_tindex_nomg(av) >= 2) {
                if (only_utf8_locale_ptr
                    && ary[2]
                    && ary[2] != &PL_sv_undef)
                {
                    *only_utf8_locale_ptr = ary[2];
                }
                else {
                    assert(only_utf8_locale_ptr);
                    *only_utf8_locale_ptr = NULL;
                }

                /* Elements 3 and 4 are either both present or both absent. [3]
                 * is any inversion list generated at compile time; [4]
                 * indicates if that inversion list has any user-defined
                 * properties in it. */
                if (av_tindex_nomg(av) >= 3) {
                    invlist = ary[3];
                    if (SvUV(ary[4])) {
                        swash_init_flags |= _CORE_SWASH_INIT_USER_DEFINED_PROPERTY;
                    }
                }
                else {
                    invlist = NULL;
                }
	    }

	    /* Element [1] is reserved for the set-up swash.  If already there,
	     * return it; if not, create it and store it there */
	    if (ary[1] && SvROK(ary[1])) {
		sw = ary[1];
	    }
	    else if (doinit && ((si && si != &PL_sv_undef)
                                 || (invlist && invlist != &PL_sv_undef))) {
		assert(si);
		sw = _core_swash_init("utf8", /* the utf8 package */
				      "", /* nameless */
				      si,
				      1, /* binary */
				      0, /* not from tr/// */
				      invlist,
				      &swash_init_flags);
		(void)av_store(av, 1, sw);
	    }
	}
    }

    /* If requested, return a printable version of what this swash matches */
    if (listsvp) {
	SV* matches_string = NULL;

        /* The swash should be used, if possible, to get the data, as it
         * contains the resolved data.  But this function can be called at
         * compile-time, before everything gets resolved, in which case we
         * return the currently best available information, which is the string
         * that will eventually be used to do that resolving, 'si' */
	if ((! sw || (invlist = _get_swash_invlist(sw)) == NULL)
            && (si && si != &PL_sv_undef))
        {
            /* Here, we only have 'si' (and possibly some passed-in data in
             * 'invlist', which is handled below)  If the caller only wants
             * 'si', use that.  */
            if (! output_invlist) {
                matches_string = newSVsv(si);
            }
            else {
                /* But if the caller wants an inversion list of the node, we
                 * need to parse 'si' and place as much as possible in the
                 * desired output inversion list, making 'matches_string' only
                 * contain the currently unresolvable things */
                const char *si_string = SvPVX(si);
                STRLEN remaining = SvCUR(si);
                UV prev_cp = 0;
                U8 count = 0;

                /* Ignore everything before the first new-line */
                while (*si_string != '\n' && remaining > 0) {
                    si_string++;
                    remaining--;
                }
                assert(remaining > 0);

                si_string++;
                remaining--;

                while (remaining > 0) {

                    /* The data consists of just strings defining user-defined
                     * property names, but in prior incarnations, and perhaps
                     * somehow from pluggable regex engines, it could still
                     * hold hex code point definitions.  Each component of a
                     * range would be separated by a tab, and each range by a
                     * new-line.  If these are found, instead add them to the
                     * inversion list */
                    I32 grok_flags =  PERL_SCAN_SILENT_ILLDIGIT
                                     |PERL_SCAN_SILENT_NON_PORTABLE;
                    STRLEN len = remaining;
                    UV cp = grok_hex(si_string, &len, &grok_flags, NULL);

                    /* If the hex decode routine found something, it should go
                     * up to the next \n */
                    if (   *(si_string + len) == '\n') {
                        if (count) {    /* 2nd code point on line */
                            *output_invlist = _add_range_to_invlist(*output_invlist, prev_cp, cp);
                        }
                        else {
                            *output_invlist = add_cp_to_invlist(*output_invlist, cp);
                        }
                        count = 0;
                        goto prepare_for_next_iteration;
                    }

                    /* If the hex decode was instead for the lower range limit,
                     * save it, and go parse the upper range limit */
                    if (*(si_string + len) == '\t') {
                        assert(count == 0);

                        prev_cp = cp;
                        count = 1;
                      prepare_for_next_iteration:
                        si_string += len + 1;
                        remaining -= len + 1;
                        continue;
                    }

                    /* Here, didn't find a legal hex number.  Just add it from
                     * here to the next \n */

                    remaining -= len;
                    while (*(si_string + len) != '\n' && remaining > 0) {
                        remaining--;
                        len++;
                    }
                    if (*(si_string + len) == '\n') {
                        len++;
                        remaining--;
                    }
                    if (matches_string) {
                        sv_catpvn(matches_string, si_string, len - 1);
                    }
                    else {
                        matches_string = newSVpvn(si_string, len - 1);
                    }
                    si_string += len;
                    sv_catpvs(matches_string, " ");
                } /* end of loop through the text */

                assert(matches_string);
                if (SvCUR(matches_string)) {  /* Get rid of trailing blank */
                    SvCUR_set(matches_string, SvCUR(matches_string) - 1);
                }
            } /* end of has an 'si' but no swash */
	}

        /* If we have a swash in place, its equivalent inversion list was above
         * placed into 'invlist'.  If not, this variable may contain a stored
         * inversion list which is information beyond what is in 'si' */
        if (invlist) {

            /* Again, if the caller doesn't want the output inversion list, put
             * everything in 'matches-string' */
            if (! output_invlist) {
                if ( ! matches_string) {
                    matches_string = newSVpvs("\n");
                }
                sv_catsv(matches_string, invlist_contents(invlist,
                                                  TRUE /* traditional style */
                                                  ));
            }
            else if (! *output_invlist) {
                *output_invlist = invlist_clone(invlist);
            }
            else {
                _invlist_union(*output_invlist, invlist, output_invlist);
            }
        }

	*listsvp = matches_string;
    }

    return sw;
}
#endif /* !defined(PERL_IN_XSUB_RE) || defined(PLUGGABLE_RE_EXTENSION) */

/* reg_skipcomment()

   Absorbs an /x style # comment from the input stream,
   returning a pointer to the first character beyond the comment, or if the
   comment terminates the pattern without anything following it, this returns
   one past the final character of the pattern (in other words, RExC_end) and
   sets the REG_RUN_ON_COMMENT_SEEN flag.

   Note it's the callers responsibility to ensure that we are
   actually in /x mode

*/

PERL_STATIC_INLINE char*
S_reg_skipcomment(RExC_state_t *pRExC_state, char* p)
{
    PERL_ARGS_ASSERT_REG_SKIPCOMMENT;

    assert(*p == '#');

    while (p < RExC_end) {
        if (*(++p) == '\n') {
            return p+1;
        }
    }

    /* we ran off the end of the pattern without ending the comment, so we have
     * to add an \n when wrapping */
    RExC_seen |= REG_RUN_ON_COMMENT_SEEN;
    return p;
}

STATIC void
S_skip_to_be_ignored_text(pTHX_ RExC_state_t *pRExC_state,
                                char ** p,
                                const bool force_to_xmod
                         )
{
    /* If the text at the current parse position '*p' is a '(?#...)' comment,
     * or if we are under /x or 'force_to_xmod' is TRUE, and the text at '*p'
     * is /x whitespace, advance '*p' so that on exit it points to the first
     * byte past all such white space and comments */

    const bool use_xmod = force_to_xmod || (RExC_flags & RXf_PMf_EXTENDED);

    PERL_ARGS_ASSERT_SKIP_TO_BE_IGNORED_TEXT;

    assert( ! UTF || UTF8_IS_INVARIANT(**p) || UTF8_IS_START(**p));

    for (;;) {
	if (RExC_end - (*p) >= 3
	    && *(*p)     == '('
	    && *(*p + 1) == '?'
	    && *(*p + 2) == '#')
	{
	    while (*(*p) != ')') {
		if ((*p) == RExC_end)
		    FAIL("Sequence (?#... not terminated");
		(*p)++;
	    }
	    (*p)++;
	    continue;
	}

	if (use_xmod) {
            const char * save_p = *p;
            while ((*p) < RExC_end) {
                STRLEN len;
                if ((len = is_PATWS_safe((*p), RExC_end, UTF))) {
                    (*p) += len;
                }
                else if (*(*p) == '#') {
                    (*p) = reg_skipcomment(pRExC_state, (*p));
                }
                else {
                    break;
                }
            }
            if (*p != save_p) {
                continue;
            }
	}

        break;
    }

    return;
}

/* nextchar()

   Advances the parse position by one byte, unless that byte is the beginning
   of a '(?#...)' style comment, or is /x whitespace and /x is in effect.  In
   those two cases, the parse position is advanced beyond all such comments and
   white space.

   This is the UTF, (?#...), and /x friendly way of saying RExC_parse++.
*/

STATIC void
S_nextchar(pTHX_ RExC_state_t *pRExC_state)
{
    PERL_ARGS_ASSERT_NEXTCHAR;

    if (RExC_parse < RExC_end) {
        assert(   ! UTF
               || UTF8_IS_INVARIANT(*RExC_parse)
               || UTF8_IS_START(*RExC_parse));

        RExC_parse += (UTF) ? UTF8SKIP(RExC_parse) : 1;

        skip_to_be_ignored_text(pRExC_state, &RExC_parse,
                                FALSE /* Don't assume /x */ );
    }
}

STATIC regnode *
S_regnode_guts(pTHX_ RExC_state_t *pRExC_state, const U8 op, const STRLEN extra_size, const char* const name)
{
    /* Allocate a regnode for 'op' and returns it, with 'extra_size' extra
     * space.  In pass1, it aligns and increments RExC_size; in pass2,
     * RExC_emit */

    regnode * const ret = RExC_emit;
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_REGNODE_GUTS;

    assert(extra_size >= regarglen[op]);

    if (SIZE_ONLY) {
	SIZE_ALIGN(RExC_size);
	RExC_size += 1 + extra_size;
	return(ret);
    }
    if (RExC_emit >= RExC_emit_bound)
        Perl_croak(aTHX_ "panic: reg_node overrun trying to emit %d, %p>=%p",
		   op, (void*)RExC_emit, (void*)RExC_emit_bound);

    NODE_ALIGN_FILL(ret);
#ifndef RE_TRACK_PATTERN_OFFSETS
    PERL_UNUSED_ARG(name);
#else
    if (RExC_offsets) {         /* MJD */
	MJD_OFFSET_DEBUG(
              ("%s:%d: (op %s) %s %"UVuf" (len %"UVuf") (max %"UVuf").\n",
              name, __LINE__,
              PL_reg_name[op],
              (UV)(RExC_emit - RExC_emit_start) > RExC_offsets[0]
		? "Overwriting end of array!\n" : "OK",
              (UV)(RExC_emit - RExC_emit_start),
              (UV)(RExC_parse - RExC_start),
              (UV)RExC_offsets[0]));
	Set_Node_Offset(RExC_emit, RExC_parse + (op == END));
    }
#endif
    return(ret);
}

/*
- reg_node - emit a node
*/
STATIC regnode *			/* Location. */
S_reg_node(pTHX_ RExC_state_t *pRExC_state, U8 op)
{
    regnode * const ret = regnode_guts(pRExC_state, op, regarglen[op], "reg_node");

    PERL_ARGS_ASSERT_REG_NODE;

    assert(regarglen[op] == 0);

    if (PASS2) {
        regnode *ptr = ret;
        FILL_ADVANCE_NODE(ptr, op);
        RExC_emit = ptr;
    }
    return(ret);
}

/*
- reganode - emit a node with an argument
*/
STATIC regnode *			/* Location. */
S_reganode(pTHX_ RExC_state_t *pRExC_state, U8 op, U32 arg)
{
    regnode * const ret = regnode_guts(pRExC_state, op, regarglen[op], "reganode");

    PERL_ARGS_ASSERT_REGANODE;

    assert(regarglen[op] == 1);

    if (PASS2) {
        regnode *ptr = ret;
        FILL_ADVANCE_NODE_ARG(ptr, op, arg);
        RExC_emit = ptr;
    }
    return(ret);
}

STATIC regnode *
S_reg2Lanode(pTHX_ RExC_state_t *pRExC_state, const U8 op, const U32 arg1, const I32 arg2)
{
    /* emit a node with U32 and I32 arguments */

    regnode * const ret = regnode_guts(pRExC_state, op, regarglen[op], "reg2Lanode");

    PERL_ARGS_ASSERT_REG2LANODE;

    assert(regarglen[op] == 2);

    if (PASS2) {
        regnode *ptr = ret;
        FILL_ADVANCE_NODE_2L_ARG(ptr, op, arg1, arg2);
        RExC_emit = ptr;
    }
    return(ret);
}

/*
- reginsert - insert an operator in front of already-emitted operand
*
* Means relocating the operand.
*/
STATIC void
S_reginsert(pTHX_ RExC_state_t *pRExC_state, U8 op, regnode *opnd, U32 depth)
{
    regnode *src;
    regnode *dst;
    regnode *place;
    const int offset = regarglen[(U8)op];
    const int size = NODE_STEP_REGNODE + offset;
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_REGINSERT;
    PERL_UNUSED_CONTEXT;
    PERL_UNUSED_ARG(depth);
/* (PL_regkind[(U8)op] == CURLY ? EXTRA_STEP_2ARGS : 0); */
    DEBUG_PARSE_FMT("inst"," - %s",PL_reg_name[op]);
    if (SIZE_ONLY) {
	RExC_size += size;
	return;
    }

    src = RExC_emit;
    RExC_emit += size;
    dst = RExC_emit;
    if (RExC_open_parens) {
        int paren;
        /*DEBUG_PARSE_FMT("inst"," - %"IVdf, (IV)RExC_npar);*/
        /* remember that RExC_npar is rex->nparens + 1,
         * iow it is 1 more than the number of parens seen in
         * the pattern so far. */
        for ( paren=0 ; paren < RExC_npar ; paren++ ) {
            if ( RExC_open_parens[paren] >= opnd ) {
                /*DEBUG_PARSE_FMT("open"," - %d",size);*/
                RExC_open_parens[paren] += size;
            } else {
                /*DEBUG_PARSE_FMT("open"," - %s","ok");*/
            }
            if ( RExC_close_parens[paren] >= opnd ) {
                /*DEBUG_PARSE_FMT("close"," - %d",size);*/
                RExC_close_parens[paren] += size;
            } else {
                /*DEBUG_PARSE_FMT("close"," - %s","ok");*/
            }
        }
    }
    if (RExC_end_op)
        RExC_end_op += size;

    while (src > opnd) {
	StructCopy(--src, --dst, regnode);
#ifdef RE_TRACK_PATTERN_OFFSETS
        if (RExC_offsets) {     /* MJD 20010112 */
	    MJD_OFFSET_DEBUG(
                 ("%s(%d): (op %s) %s copy %"UVuf" -> %"UVuf" (max %"UVuf").\n",
                  "reg_insert",
		  __LINE__,
		  PL_reg_name[op],
                  (UV)(dst - RExC_emit_start) > RExC_offsets[0]
		    ? "Overwriting end of array!\n" : "OK",
                  (UV)(src - RExC_emit_start),
                  (UV)(dst - RExC_emit_start),
                  (UV)RExC_offsets[0]));
	    Set_Node_Offset_To_R(dst-RExC_emit_start, Node_Offset(src));
	    Set_Node_Length_To_R(dst-RExC_emit_start, Node_Length(src));
        }
#endif
    }


    place = opnd;		/* Op node, where operand used to be. */
#ifdef RE_TRACK_PATTERN_OFFSETS
    if (RExC_offsets) {         /* MJD */
	MJD_OFFSET_DEBUG(
              ("%s(%d): (op %s) %s %"UVuf" <- %"UVuf" (max %"UVuf").\n",
              "reginsert",
	      __LINE__,
	      PL_reg_name[op],
              (UV)(place - RExC_emit_start) > RExC_offsets[0]
              ? "Overwriting end of array!\n" : "OK",
              (UV)(place - RExC_emit_start),
              (UV)(RExC_parse - RExC_start),
              (UV)RExC_offsets[0]));
	Set_Node_Offset(place, RExC_parse);
	Set_Node_Length(place, 1);
    }
#endif
    src = NEXTOPER(place);
    FILL_ADVANCE_NODE(place, op);
    Zero(src, offset, regnode);
}

/*
- regtail - set the next-pointer at the end of a node chain of p to val.
- SEE ALSO: regtail_study
*/
STATIC void
S_regtail(pTHX_ RExC_state_t * pRExC_state,
                const regnode * const p,
                const regnode * const val,
                const U32 depth)
{
    regnode *scan;
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_REGTAIL;
#ifndef DEBUGGING
    PERL_UNUSED_ARG(depth);
#endif

    if (SIZE_ONLY)
	return;

    /* Find last node. */
    scan = (regnode *) p;
    for (;;) {
	regnode * const temp = regnext(scan);
        DEBUG_PARSE_r({
            DEBUG_PARSE_MSG((scan==p ? "tail" : ""));
            regprop(RExC_rx, RExC_mysv, scan, NULL, pRExC_state);
            Perl_re_printf( aTHX_  "~ %s (%d) %s %s\n",
                SvPV_nolen_const(RExC_mysv), REG_NODE_NUM(scan),
                    (temp == NULL ? "->" : ""),
                    (temp == NULL ? PL_reg_name[OP(val)] : "")
            );
        });
        if (temp == NULL)
            break;
        scan = temp;
    }

    if (reg_off_by_arg[OP(scan)]) {
        ARG_SET(scan, val - scan);
    }
    else {
        NEXT_OFF(scan) = val - scan;
    }
}

#ifdef DEBUGGING
/*
- regtail_study - set the next-pointer at the end of a node chain of p to val.
- Look for optimizable sequences at the same time.
- currently only looks for EXACT chains.

This is experimental code. The idea is to use this routine to perform
in place optimizations on branches and groups as they are constructed,
with the long term intention of removing optimization from study_chunk so
that it is purely analytical.

Currently only used when in DEBUG mode. The macro REGTAIL_STUDY() is used
to control which is which.

*/
/* TODO: All four parms should be const */

STATIC U8
S_regtail_study(pTHX_ RExC_state_t *pRExC_state, regnode *p,
                      const regnode *val,U32 depth)
{
    regnode *scan;
    U8 exact = PSEUDO;
#ifdef EXPERIMENTAL_INPLACESCAN
    I32 min = 0;
#endif
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_REGTAIL_STUDY;


    if (SIZE_ONLY)
        return exact;

    /* Find last node. */

    scan = p;
    for (;;) {
        regnode * const temp = regnext(scan);
#ifdef EXPERIMENTAL_INPLACESCAN
        if (PL_regkind[OP(scan)] == EXACT) {
	    bool unfolded_multi_char;	/* Unexamined in this routine */
            if (join_exact(pRExC_state, scan, &min,
                           &unfolded_multi_char, 1, val, depth+1))
                return EXACT;
	}
#endif
        if ( exact ) {
            switch (OP(scan)) {
                case EXACT:
                case EXACTL:
                case EXACTF:
                case EXACTFA_NO_TRIE:
                case EXACTFA:
                case EXACTFU:
                case EXACTFLU8:
                case EXACTFU_SS:
                case EXACTFL:
                        if( exact == PSEUDO )
                            exact= OP(scan);
                        else if ( exact != OP(scan) )
                            exact= 0;
                case NOTHING:
                    break;
                default:
                    exact= 0;
            }
        }
        DEBUG_PARSE_r({
            DEBUG_PARSE_MSG((scan==p ? "tsdy" : ""));
            regprop(RExC_rx, RExC_mysv, scan, NULL, pRExC_state);
            Perl_re_printf( aTHX_  "~ %s (%d) -> %s\n",
                SvPV_nolen_const(RExC_mysv),
                REG_NODE_NUM(scan),
                PL_reg_name[exact]);
        });
	if (temp == NULL)
	    break;
	scan = temp;
    }
    DEBUG_PARSE_r({
        DEBUG_PARSE_MSG("");
        regprop(RExC_rx, RExC_mysv, val, NULL, pRExC_state);
        Perl_re_printf( aTHX_
                      "~ attach to %s (%"IVdf") offset to %"IVdf"\n",
		      SvPV_nolen_const(RExC_mysv),
		      (IV)REG_NODE_NUM(val),
		      (IV)(val - scan)
        );
    });
    if (reg_off_by_arg[OP(scan)]) {
	ARG_SET(scan, val - scan);
    }
    else {
	NEXT_OFF(scan) = val - scan;
    }

    return exact;
}
#endif

/*
 - regdump - dump a regexp onto Perl_debug_log in vaguely comprehensible form
 */
#ifdef DEBUGGING

static void
S_regdump_intflags(pTHX_ const char *lead, const U32 flags)
{
    int bit;
    int set=0;

    ASSUME(REG_INTFLAGS_NAME_SIZE <= sizeof(flags)*8);

    for (bit=0; bit<REG_INTFLAGS_NAME_SIZE; bit++) {
        if (flags & (1<<bit)) {
            if (!set++ && lead)
                Perl_re_printf( aTHX_  "%s",lead);
            Perl_re_printf( aTHX_  "%s ",PL_reg_intflags_name[bit]);
        }
    }
    if (lead)  {
        if (set)
            Perl_re_printf( aTHX_  "\n");
        else
            Perl_re_printf( aTHX_  "%s[none-set]\n",lead);
    }
}

static void
S_regdump_extflags(pTHX_ const char *lead, const U32 flags)
{
    int bit;
    int set=0;
    regex_charset cs;

    ASSUME(REG_EXTFLAGS_NAME_SIZE <= sizeof(flags)*8);

    for (bit=0; bit<REG_EXTFLAGS_NAME_SIZE; bit++) {
        if (flags & (1<<bit)) {
	    if ((1<<bit) & RXf_PMf_CHARSET) {	/* Output separately, below */
		continue;
	    }
            if (!set++ && lead)
                Perl_re_printf( aTHX_  "%s",lead);
            Perl_re_printf( aTHX_  "%s ",PL_reg_extflags_name[bit]);
        }
    }
    if ((cs = get_regex_charset(flags)) != REGEX_DEPENDS_CHARSET) {
            if (!set++ && lead) {
                Perl_re_printf( aTHX_  "%s",lead);
            }
            switch (cs) {
                case REGEX_UNICODE_CHARSET:
                    Perl_re_printf( aTHX_  "UNICODE");
                    break;
                case REGEX_LOCALE_CHARSET:
                    Perl_re_printf( aTHX_  "LOCALE");
                    break;
                case REGEX_ASCII_RESTRICTED_CHARSET:
                    Perl_re_printf( aTHX_  "ASCII-RESTRICTED");
                    break;
                case REGEX_ASCII_MORE_RESTRICTED_CHARSET:
                    Perl_re_printf( aTHX_  "ASCII-MORE_RESTRICTED");
                    break;
                default:
                    Perl_re_printf( aTHX_  "UNKNOWN CHARACTER SET");
                    break;
            }
    }
    if (lead)  {
        if (set)
            Perl_re_printf( aTHX_  "\n");
        else
            Perl_re_printf( aTHX_  "%s[none-set]\n",lead);
    }
}
#endif

void
Perl_regdump(pTHX_ const regexp *r)
{
#ifdef DEBUGGING
    SV * const sv = sv_newmortal();
    SV *dsv= sv_newmortal();
    RXi_GET_DECL(r,ri);
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_REGDUMP;

    (void)dumpuntil(r, ri->program, ri->program + 1, NULL, NULL, sv, 0, 0);

    /* Header fields of interest. */
    if (r->anchored_substr) {
	RE_PV_QUOTED_DECL(s, 0, dsv, SvPVX_const(r->anchored_substr),
	    RE_SV_DUMPLEN(r->anchored_substr), 30);
        Perl_re_printf( aTHX_
		      "anchored %s%s at %"IVdf" ",
		      s, RE_SV_TAIL(r->anchored_substr),
		      (IV)r->anchored_offset);
    } else if (r->anchored_utf8) {
	RE_PV_QUOTED_DECL(s, 1, dsv, SvPVX_const(r->anchored_utf8),
	    RE_SV_DUMPLEN(r->anchored_utf8), 30);
        Perl_re_printf( aTHX_
		      "anchored utf8 %s%s at %"IVdf" ",
		      s, RE_SV_TAIL(r->anchored_utf8),
		      (IV)r->anchored_offset);
    }
    if (r->float_substr) {
	RE_PV_QUOTED_DECL(s, 0, dsv, SvPVX_const(r->float_substr),
	    RE_SV_DUMPLEN(r->float_substr), 30);
        Perl_re_printf( aTHX_
		      "floating %s%s at %"IVdf"..%"UVuf" ",
		      s, RE_SV_TAIL(r->float_substr),
		      (IV)r->float_min_offset, (UV)r->float_max_offset);
    } else if (r->float_utf8) {
	RE_PV_QUOTED_DECL(s, 1, dsv, SvPVX_const(r->float_utf8),
	    RE_SV_DUMPLEN(r->float_utf8), 30);
        Perl_re_printf( aTHX_
		      "floating utf8 %s%s at %"IVdf"..%"UVuf" ",
		      s, RE_SV_TAIL(r->float_utf8),
		      (IV)r->float_min_offset, (UV)r->float_max_offset);
    }
    if (r->check_substr || r->check_utf8)
        Perl_re_printf( aTHX_
		      (const char *)
		      (r->check_substr == r->float_substr
		       && r->check_utf8 == r->float_utf8
		       ? "(checking floating" : "(checking anchored"));
    if (r->intflags & PREGf_NOSCAN)
        Perl_re_printf( aTHX_  " noscan");
    if (r->extflags & RXf_CHECK_ALL)
        Perl_re_printf( aTHX_  " isall");
    if (r->check_substr || r->check_utf8)
        Perl_re_printf( aTHX_  ") ");

    if (ri->regstclass) {
        regprop(r, sv, ri->regstclass, NULL, NULL);
        Perl_re_printf( aTHX_  "stclass %s ", SvPVX_const(sv));
    }
    if (r->intflags & PREGf_ANCH) {
        Perl_re_printf( aTHX_  "anchored");
        if (r->intflags & PREGf_ANCH_MBOL)
            Perl_re_printf( aTHX_  "(MBOL)");
        if (r->intflags & PREGf_ANCH_SBOL)
            Perl_re_printf( aTHX_  "(SBOL)");
        if (r->intflags & PREGf_ANCH_GPOS)
            Perl_re_printf( aTHX_  "(GPOS)");
        Perl_re_printf( aTHX_ " ");
    }
    if (r->intflags & PREGf_GPOS_SEEN)
        Perl_re_printf( aTHX_  "GPOS:%"UVuf" ", (UV)r->gofs);
    if (r->intflags & PREGf_SKIP)
        Perl_re_printf( aTHX_  "plus ");
    if (r->intflags & PREGf_IMPLICIT)
        Perl_re_printf( aTHX_  "implicit ");
    Perl_re_printf( aTHX_  "minlen %"IVdf" ", (IV)r->minlen);
    if (r->extflags & RXf_EVAL_SEEN)
        Perl_re_printf( aTHX_  "with eval ");
    Perl_re_printf( aTHX_  "\n");
    DEBUG_FLAGS_r({
        regdump_extflags("r->extflags: ",r->extflags);
        regdump_intflags("r->intflags: ",r->intflags);
    });
#else
    PERL_ARGS_ASSERT_REGDUMP;
    PERL_UNUSED_CONTEXT;
    PERL_UNUSED_ARG(r);
#endif	/* DEBUGGING */
}

/* Should be synchronized with ANYOF_ #defines in regcomp.h */
#ifdef DEBUGGING

#  if   _CC_WORDCHAR != 0 || _CC_DIGIT != 1        || _CC_ALPHA != 2    \
     || _CC_LOWER != 3    || _CC_UPPER != 4        || _CC_PUNCT != 5    \
     || _CC_PRINT != 6    || _CC_ALPHANUMERIC != 7 || _CC_GRAPH != 8    \
     || _CC_CASED != 9    || _CC_SPACE != 10       || _CC_BLANK != 11   \
     || _CC_XDIGIT != 12  || _CC_CNTRL != 13       || _CC_ASCII != 14   \
     || _CC_VERTSPACE != 15
#   error Need to adjust order of anyofs[]
#  endif
static const char * const anyofs[] = {
    "\\w",
    "\\W",
    "\\d",
    "\\D",
    "[:alpha:]",
    "[:^alpha:]",
    "[:lower:]",
    "[:^lower:]",
    "[:upper:]",
    "[:^upper:]",
    "[:punct:]",
    "[:^punct:]",
    "[:print:]",
    "[:^print:]",
    "[:alnum:]",
    "[:^alnum:]",
    "[:graph:]",
    "[:^graph:]",
    "[:cased:]",
    "[:^cased:]",
    "\\s",
    "\\S",
    "[:blank:]",
    "[:^blank:]",
    "[:xdigit:]",
    "[:^xdigit:]",
    "[:cntrl:]",
    "[:^cntrl:]",
    "[:ascii:]",
    "[:^ascii:]",
    "\\v",
    "\\V"
};
#endif

/*
- regprop - printable representation of opcode, with run time support
*/

void
Perl_regprop(pTHX_ const regexp *prog, SV *sv, const regnode *o, const regmatch_info *reginfo, const RExC_state_t *pRExC_state)
{
#ifdef DEBUGGING
    int k;
    RXi_GET_DECL(prog,progi);
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_REGPROP;

    sv_setpvn(sv, "", 0);

    if (OP(o) > REGNODE_MAX)		/* regnode.type is unsigned */
	/* It would be nice to FAIL() here, but this may be called from
	   regexec.c, and it would be hard to supply pRExC_state. */
	Perl_croak(aTHX_ "Corrupted regexp opcode %d > %d",
                                              (int)OP(o), (int)REGNODE_MAX);
    sv_catpv(sv, PL_reg_name[OP(o)]); /* Take off const! */

    k = PL_regkind[OP(o)];

    if (k == EXACT) {
	sv_catpvs(sv, " ");
	/* Using is_utf8_string() (via PERL_PV_UNI_DETECT)
	 * is a crude hack but it may be the best for now since
	 * we have no flag "this EXACTish node was UTF-8"
	 * --jhi */
	pv_pretty(sv, STRING(o), STR_LEN(o), 60, PL_colors[0], PL_colors[1],
		  PERL_PV_ESCAPE_UNI_DETECT |
		  PERL_PV_ESCAPE_NONASCII   |
		  PERL_PV_PRETTY_ELLIPSES   |
		  PERL_PV_PRETTY_LTGT       |
		  PERL_PV_PRETTY_NOCLEAR
		  );
    } else if (k == TRIE) {
	/* print the details of the trie in dumpuntil instead, as
	 * progi->data isn't available here */
        const char op = OP(o);
        const U32 n = ARG(o);
        const reg_ac_data * const ac = IS_TRIE_AC(op) ?
               (reg_ac_data *)progi->data->data[n] :
               NULL;
        const reg_trie_data * const trie
	    = (reg_trie_data*)progi->data->data[!IS_TRIE_AC(op) ? n : ac->trie];

        Perl_sv_catpvf(aTHX_ sv, "-%s",PL_reg_name[o->flags]);
        DEBUG_TRIE_COMPILE_r(
          Perl_sv_catpvf(aTHX_ sv,
            "<S:%"UVuf"/%"IVdf" W:%"UVuf" L:%"UVuf"/%"UVuf" C:%"UVuf"/%"UVuf">",
            (UV)trie->startstate,
            (IV)trie->statecount-1, /* -1 because of the unused 0 element */
            (UV)trie->wordcount,
            (UV)trie->minlen,
            (UV)trie->maxlen,
            (UV)TRIE_CHARCOUNT(trie),
            (UV)trie->uniquecharcount
          );
        );
        if ( IS_ANYOF_TRIE(op) || trie->bitmap ) {
            sv_catpvs(sv, "[");
            (void) put_charclass_bitmap_innards(sv,
                                                ((IS_ANYOF_TRIE(op))
                                                 ? ANYOF_BITMAP(o)
                                                 : TRIE_BITMAP(trie)),
                                                NULL,
                                                NULL,
                                                NULL
                                               );
            sv_catpvs(sv, "]");
        }

    } else if (k == CURLY) {
        U32 lo = ARG1(o), hi = ARG2(o);
	if (OP(o) == CURLYM || OP(o) == CURLYN || OP(o) == CURLYX)
	    Perl_sv_catpvf(aTHX_ sv, "[%d]", o->flags); /* Parenth number */
        Perl_sv_catpvf(aTHX_ sv, "{%u,", (unsigned) lo);
        if (hi == REG_INFTY)
            sv_catpvs(sv, "INFTY");
        else
            Perl_sv_catpvf(aTHX_ sv, "%u", (unsigned) hi);
        sv_catpvs(sv, "}");
    }
    else if (k == WHILEM && o->flags)			/* Ordinal/of */
	Perl_sv_catpvf(aTHX_ sv, "[%d/%d]", o->flags & 0xf, o->flags>>4);
    else if (k == REF || k == OPEN || k == CLOSE
             || k == GROUPP || OP(o)==ACCEPT)
    {
        AV *name_list= NULL;
        U32 parno= OP(o) == ACCEPT ? (U32)ARG2L(o) : ARG(o);
        Perl_sv_catpvf(aTHX_ sv, "%"UVuf, (UV)parno);        /* Parenth number */
	if ( RXp_PAREN_NAMES(prog) ) {
            name_list= MUTABLE_AV(progi->data->data[progi->name_list_idx]);
        } else if ( pRExC_state ) {
            name_list= RExC_paren_name_list;
        }
        if (name_list) {
            if ( k != REF || (OP(o) < NREF)) {
                SV **name= av_fetch(name_list, parno, 0 );
	        if (name)
	            Perl_sv_catpvf(aTHX_ sv, " '%"SVf"'", SVfARG(*name));
            }
            else {
                SV *sv_dat= MUTABLE_SV(progi->data->data[ parno ]);
                I32 *nums=(I32*)SvPVX(sv_dat);
                SV **name= av_fetch(name_list, nums[0], 0 );
                I32 n;
                if (name) {
                    for ( n=0; n<SvIVX(sv_dat); n++ ) {
                        Perl_sv_catpvf(aTHX_ sv, "%s%"IVdf,
			   	    (n ? "," : ""), (IV)nums[n]);
                    }
                    Perl_sv_catpvf(aTHX_ sv, " '%"SVf"'", SVfARG(*name));
                }
            }
        }
        if ( k == REF && reginfo) {
            U32 n = ARG(o);  /* which paren pair */
            I32 ln = prog->offs[n].start;
            if (prog->lastparen < n || ln == -1)
                Perl_sv_catpvf(aTHX_ sv, ": FAIL");
            else if (ln == prog->offs[n].end)
                Perl_sv_catpvf(aTHX_ sv, ": ACCEPT - EMPTY STRING");
            else {
                const char *s = reginfo->strbeg + ln;
                Perl_sv_catpvf(aTHX_ sv, ": ");
                Perl_pv_pretty( aTHX_ sv, s, prog->offs[n].end - prog->offs[n].start, 32, 0, 0,
                    PERL_PV_ESCAPE_UNI_DETECT|PERL_PV_PRETTY_NOCLEAR|PERL_PV_PRETTY_ELLIPSES|PERL_PV_PRETTY_QUOTE );
            }
        }
    } else if (k == GOSUB) {
        AV *name_list= NULL;
        if ( RXp_PAREN_NAMES(prog) ) {
            name_list= MUTABLE_AV(progi->data->data[progi->name_list_idx]);
        } else if ( pRExC_state ) {
            name_list= RExC_paren_name_list;
        }

        /* Paren and offset */
        Perl_sv_catpvf(aTHX_ sv, "%d[%+d:%d]", (int)ARG(o),(int)ARG2L(o),
                (int)((o + (int)ARG2L(o)) - progi->program) );
        if (name_list) {
            SV **name= av_fetch(name_list, ARG(o), 0 );
            if (name)
                Perl_sv_catpvf(aTHX_ sv, " '%"SVf"'", SVfARG(*name));
        }
    }
    else if (k == LOGICAL)
        /* 2: embedded, otherwise 1 */
	Perl_sv_catpvf(aTHX_ sv, "[%d]", o->flags);
    else if (k == ANYOF) {
	const U8 flags = ANYOF_FLAGS(o);
        bool do_sep = FALSE;    /* Do we need to separate various components of
                                   the output? */
        /* Set if there is still an unresolved user-defined property */
        SV *unresolved                = NULL;

        /* Things that are ignored except when the runtime locale is UTF-8 */
        SV *only_utf8_locale_invlist = NULL;

        /* Code points that don't fit in the bitmap */
        SV *nonbitmap_invlist = NULL;

        /* And things that aren't in the bitmap, but are small enough to be */
        SV* bitmap_range_not_in_bitmap = NULL;

	if (OP(o) == ANYOFL) {
            if (ANYOFL_UTF8_LOCALE_REQD(flags)) {
                sv_catpvs(sv, "{utf8-locale-reqd}");
            }
            if (flags & ANYOFL_FOLD) {
                sv_catpvs(sv, "{i}");
            }
        }

        /* If there is stuff outside the bitmap, get it */
        if (ARG(o) != ANYOF_ONLY_HAS_BITMAP) {
            (void) _get_regclass_nonbitmap_data(prog, o, FALSE,
                                                &unresolved,
                                                &only_utf8_locale_invlist,
                                                &nonbitmap_invlist);
            /* The non-bitmap data may contain stuff that could fit in the
             * bitmap.  This could come from a user-defined property being
             * finally resolved when this call was done; or much more likely
             * because there are matches that require UTF-8 to be valid, and so
             * aren't in the bitmap.  This is teased apart later */
            _invlist_intersection(nonbitmap_invlist,
                                  PL_InBitmap,
                                  &bitmap_range_not_in_bitmap);
            /* Leave just the things that don't fit into the bitmap */
            _invlist_subtract(nonbitmap_invlist,
                              PL_InBitmap,
                              &nonbitmap_invlist);
        }

        /* Obey this flag to add all above-the-bitmap code points */
        if (flags & ANYOF_MATCHES_ALL_ABOVE_BITMAP) {
            nonbitmap_invlist = _add_range_to_invlist(nonbitmap_invlist,
                                                      NUM_ANYOF_CODE_POINTS,
                                                      UV_MAX);
        }

        /* Ready to start outputting.  First, the initial left bracket */
	Perl_sv_catpvf(aTHX_ sv, "[%s", PL_colors[0]);

        /* Then all the things that could fit in the bitmap */
        do_sep = put_charclass_bitmap_innards(sv,
                                              ANYOF_BITMAP(o),
                                              bitmap_range_not_in_bitmap,
                                              only_utf8_locale_invlist,
                                              o);
        SvREFCNT_dec(bitmap_range_not_in_bitmap);

        /* If there are user-defined properties which haven't been defined yet,
         * output them, in a separate [] from the bitmap range stuff */
        if (unresolved) {
            if (do_sep) {
                Perl_sv_catpvf(aTHX_ sv,"%s][%s",PL_colors[1],PL_colors[0]);
            }
            if (flags & ANYOF_INVERT) {
                sv_catpvs(sv, "^");
            }
            sv_catsv(sv, unresolved);
            do_sep = TRUE;
            SvREFCNT_dec_NN(unresolved);
        }

        /* And, finally, add the above-the-bitmap stuff */
        if (nonbitmap_invlist && _invlist_len(nonbitmap_invlist)) {
            SV* contents;

            /* See if truncation size is overridden */
            const STRLEN dump_len = (PL_dump_re_max_len)
                                    ? PL_dump_re_max_len
                                    : 256;

            /* This is output in a separate [] */
            if (do_sep) {
                Perl_sv_catpvf(aTHX_ sv,"%s][%s",PL_colors[1],PL_colors[0]);
            }

            /* And, for easy of understanding, it is always output not-shown as
             * complemented */
            if (flags & ANYOF_INVERT) {
                _invlist_invert(nonbitmap_invlist);
                _invlist_subtract(nonbitmap_invlist, PL_InBitmap, &nonbitmap_invlist);
            }

            contents = invlist_contents(nonbitmap_invlist,
                                        FALSE /* output suitable for catsv */
                                       );

            /* If the output is shorter than the permissible maximum, just do it. */
            if (SvCUR(contents) <= dump_len) {
                sv_catsv(sv, contents);
            }
            else {
                const char * contents_string = SvPVX(contents);
                STRLEN i = dump_len;

                /* Otherwise, start at the permissible max and work back to the
                 * first break possibility */
                while (i > 0 && contents_string[i] != ' ') {
                    i--;
                }
                if (i == 0) {       /* Fail-safe.  Use the max if we couldn't
                                       find a legal break */
                    i = dump_len;
                }

                sv_catpvn(sv, contents_string, i);
                sv_catpvs(sv, "...");
            }

            SvREFCNT_dec_NN(contents);
            SvREFCNT_dec_NN(nonbitmap_invlist);
        }

        /* And finally the matching, closing ']' */
	Perl_sv_catpvf(aTHX_ sv, "%s]", PL_colors[1]);
    }
    else if (k == POSIXD || k == NPOSIXD) {
        U8 index = FLAGS(o) * 2;
        if (index < C_ARRAY_LENGTH(anyofs)) {
            if (*anyofs[index] != '[')  {
                sv_catpv(sv, "[");
            }
            sv_catpv(sv, anyofs[index]);
            if (*anyofs[index] != '[')  {
                sv_catpv(sv, "]");
            }
        }
        else {
            Perl_sv_catpvf(aTHX_ sv, "[illegal type=%d])", index);
        }
    }
    else if (k == BOUND || k == NBOUND) {
        /* Must be synced with order of 'bound_type' in regcomp.h */
        const char * const bounds[] = {
            "",      /* Traditional */
            "{gcb}",
            "{lb}",
            "{sb}",
            "{wb}"
        };
        assert(FLAGS(o) < C_ARRAY_LENGTH(bounds));
        sv_catpv(sv, bounds[FLAGS(o)]);
    }
    else if (k == BRANCHJ && (OP(o) == UNLESSM || OP(o) == IFMATCH))
	Perl_sv_catpvf(aTHX_ sv, "[%d]", -(o->flags));
    else if (OP(o) == SBOL)
        Perl_sv_catpvf(aTHX_ sv, " /%s/", o->flags ? "\\A" : "^");

    /* add on the verb argument if there is one */
    if ( ( k == VERB || OP(o) == ACCEPT || OP(o) == OPFAIL ) && o->flags) {
        Perl_sv_catpvf(aTHX_ sv, ":%"SVf,
                       SVfARG((MUTABLE_SV(progi->data->data[ ARG( o ) ]))));
    }
#else
    PERL_UNUSED_CONTEXT;
    PERL_UNUSED_ARG(sv);
    PERL_UNUSED_ARG(o);
    PERL_UNUSED_ARG(prog);
    PERL_UNUSED_ARG(reginfo);
    PERL_UNUSED_ARG(pRExC_state);
#endif	/* DEBUGGING */
}



SV *
Perl_re_intuit_string(pTHX_ REGEXP * const r)
{				/* Assume that RE_INTUIT is set */
    struct regexp *const prog = ReANY(r);
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_RE_INTUIT_STRING;
    PERL_UNUSED_CONTEXT;

    DEBUG_COMPILE_r(
	{
	    const char * const s = SvPV_nolen_const(RX_UTF8(r)
		      ? prog->check_utf8 : prog->check_substr);

	    if (!PL_colorset) reginitcolors();
            Perl_re_printf( aTHX_
		      "%sUsing REx %ssubstr:%s \"%s%.60s%s%s\"\n",
		      PL_colors[4],
		      RX_UTF8(r) ? "utf8 " : "",
		      PL_colors[5],PL_colors[0],
		      s,
		      PL_colors[1],
		      (strlen(s) > 60 ? "..." : ""));
	} );

    /* use UTF8 check substring if regexp pattern itself is in UTF8 */
    return RX_UTF8(r) ? prog->check_utf8 : prog->check_substr;
}

/*
   pregfree()

   handles refcounting and freeing the perl core regexp structure. When
   it is necessary to actually free the structure the first thing it
   does is call the 'free' method of the regexp_engine associated to
   the regexp, allowing the handling of the void *pprivate; member
   first. (This routine is not overridable by extensions, which is why
   the extensions free is called first.)

   See regdupe and regdupe_internal if you change anything here.
*/
#ifndef PERL_IN_XSUB_RE
void
Perl_pregfree(pTHX_ REGEXP *r)
{
    SvREFCNT_dec(r);
}

void
Perl_pregfree2(pTHX_ REGEXP *rx)
{
    struct regexp *const r = ReANY(rx);
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_PREGFREE2;

    if (r->mother_re) {
        ReREFCNT_dec(r->mother_re);
    } else {
        CALLREGFREE_PVT(rx); /* free the private data */
        SvREFCNT_dec(RXp_PAREN_NAMES(r));
	Safefree(r->xpv_len_u.xpvlenu_pv);
    }
    if (r->substrs) {
        SvREFCNT_dec(r->anchored_substr);
        SvREFCNT_dec(r->anchored_utf8);
        SvREFCNT_dec(r->float_substr);
        SvREFCNT_dec(r->float_utf8);
	Safefree(r->substrs);
    }
    RX_MATCH_COPY_FREE(rx);
#ifdef PERL_ANY_COW
    SvREFCNT_dec(r->saved_copy);
#endif
    Safefree(r->offs);
    SvREFCNT_dec(r->qr_anoncv);
    if (r->recurse_locinput)
        Safefree(r->recurse_locinput);
    rx->sv_u.svu_rx = 0;
}

/*  reg_temp_copy()

    This is a hacky workaround to the structural issue of match results
    being stored in the regexp structure which is in turn stored in
    PL_curpm/PL_reg_curpm. The problem is that due to qr// the pattern
    could be PL_curpm in multiple contexts, and could require multiple
    result sets being associated with the pattern simultaneously, such
    as when doing a recursive match with (??{$qr})

    The solution is to make a lightweight copy of the regexp structure
    when a qr// is returned from the code executed by (??{$qr}) this
    lightweight copy doesn't actually own any of its data except for
    the starp/end and the actual regexp structure itself.

*/


REGEXP *
Perl_reg_temp_copy (pTHX_ REGEXP *ret_x, REGEXP *rx)
{
    struct regexp *ret;
    struct regexp *const r = ReANY(rx);
    const bool islv = ret_x && SvTYPE(ret_x) == SVt_PVLV;

    PERL_ARGS_ASSERT_REG_TEMP_COPY;

    if (!ret_x)
	ret_x = (REGEXP*) newSV_type(SVt_REGEXP);
    else {
	SvOK_off((SV *)ret_x);
	if (islv) {
	    /* For PVLVs, SvANY points to the xpvlv body while sv_u points
	       to the regexp.  (For SVt_REGEXPs, sv_upgrade has already
	       made both spots point to the same regexp body.) */
	    REGEXP *temp = (REGEXP *)newSV_type(SVt_REGEXP);
	    assert(!SvPVX(ret_x));
	    ret_x->sv_u.svu_rx = temp->sv_any;
	    temp->sv_any = NULL;
	    SvFLAGS(temp) = (SvFLAGS(temp) & ~SVTYPEMASK) | SVt_NULL;
	    SvREFCNT_dec_NN(temp);
	    /* SvCUR still resides in the xpvlv struct, so the regexp copy-
	       ing below will not set it. */
	    SvCUR_set(ret_x, SvCUR(rx));
	}
    }
    /* This ensures that SvTHINKFIRST(sv) is true, and hence that
       sv_force_normal(sv) is called.  */
    SvFAKE_on(ret_x);
    ret = ReANY(ret_x);

    SvFLAGS(ret_x) |= SvUTF8(rx);
    /* We share the same string buffer as the original regexp, on which we
       hold a reference count, incremented when mother_re is set below.
       The string pointer is copied here, being part of the regexp struct.
     */
    memcpy(&(ret->xpv_cur), &(r->xpv_cur),
	   sizeof(regexp) - STRUCT_OFFSET(regexp, xpv_cur));
    if (r->offs) {
        const I32 npar = r->nparens+1;
        Newx(ret->offs, npar, regexp_paren_pair);
        Copy(r->offs, ret->offs, npar, regexp_paren_pair);
    }
    if (r->substrs) {
        Newx(ret->substrs, 1, struct reg_substr_data);
	StructCopy(r->substrs, ret->substrs, struct reg_substr_data);

	SvREFCNT_inc_void(ret->anchored_substr);
	SvREFCNT_inc_void(ret->anchored_utf8);
	SvREFCNT_inc_void(ret->float_substr);
	SvREFCNT_inc_void(ret->float_utf8);

	/* check_substr and check_utf8, if non-NULL, point to either their
	   anchored or float namesakes, and don't hold a second reference.  */
    }
    RX_MATCH_COPIED_off(ret_x);
#ifdef PERL_ANY_COW
    ret->saved_copy = NULL;
#endif
    ret->mother_re = ReREFCNT_inc(r->mother_re ? r->mother_re : rx);
    SvREFCNT_inc_void(ret->qr_anoncv);
    if (r->recurse_locinput)
        Newxz(ret->recurse_locinput,r->nparens + 1,char *);

    return ret_x;
}
#endif

/* regfree_internal()

   Free the private data in a regexp. This is overloadable by
   extensions. Perl takes care of the regexp structure in pregfree(),
   this covers the *pprivate pointer which technically perl doesn't
   know about, however of course we have to handle the
   regexp_internal structure when no extension is in use.

   Note this is called before freeing anything in the regexp
   structure.
 */

void
Perl_regfree_internal(pTHX_ REGEXP * const rx)
{
    struct regexp *const r = ReANY(rx);
    RXi_GET_DECL(r,ri);
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_REGFREE_INTERNAL;

    DEBUG_COMPILE_r({
	if (!PL_colorset)
	    reginitcolors();
	{
	    SV *dsv= sv_newmortal();
            RE_PV_QUOTED_DECL(s, RX_UTF8(rx),
                dsv, RX_PRECOMP(rx), RX_PRELEN(rx), 60);
            Perl_re_printf( aTHX_ "%sFreeing REx:%s %s\n",
                PL_colors[4],PL_colors[5],s);
        }
    });
#ifdef RE_TRACK_PATTERN_OFFSETS
    if (ri->u.offsets)
        Safefree(ri->u.offsets);             /* 20010421 MJD */
#endif
    if (ri->code_blocks) {
	int n;
	for (n = 0; n < ri->num_code_blocks; n++)
	    SvREFCNT_dec(ri->code_blocks[n].src_regex);
	Safefree(ri->code_blocks);
    }

    if (ri->data) {
	int n = ri->data->count;

	while (--n >= 0) {
          /* If you add a ->what type here, update the comment in regcomp.h */
	    switch (ri->data->what[n]) {
	    case 'a':
	    case 'r':
	    case 's':
	    case 'S':
	    case 'u':
		SvREFCNT_dec(MUTABLE_SV(ri->data->data[n]));
		break;
	    case 'f':
		Safefree(ri->data->data[n]);
		break;
	    case 'l':
	    case 'L':
	        break;
            case 'T':
                { /* Aho Corasick add-on structure for a trie node.
                     Used in stclass optimization only */
                    U32 refcount;
                    reg_ac_data *aho=(reg_ac_data*)ri->data->data[n];
#ifdef USE_ITHREADS
                    dVAR;
#endif
                    OP_REFCNT_LOCK;
                    refcount = --aho->refcount;
                    OP_REFCNT_UNLOCK;
                    if ( !refcount ) {
                        PerlMemShared_free(aho->states);
                        PerlMemShared_free(aho->fail);
			 /* do this last!!!! */
                        PerlMemShared_free(ri->data->data[n]);
                        /* we should only ever get called once, so
                         * assert as much, and also guard the free
                         * which /might/ happen twice. At the least
                         * it will make code anlyzers happy and it
                         * doesn't cost much. - Yves */
                        assert(ri->regstclass);
                        if (ri->regstclass) {
                            PerlMemShared_free(ri->regstclass);
                            ri->regstclass = 0;
                        }
                    }
                }
                break;
	    case 't':
	        {
	            /* trie structure. */
	            U32 refcount;
	            reg_trie_data *trie=(reg_trie_data*)ri->data->data[n];
#ifdef USE_ITHREADS
                    dVAR;
#endif
                    OP_REFCNT_LOCK;
                    refcount = --trie->refcount;
                    OP_REFCNT_UNLOCK;
                    if ( !refcount ) {
                        PerlMemShared_free(trie->charmap);
                        PerlMemShared_free(trie->states);
                        PerlMemShared_free(trie->trans);
                        if (trie->bitmap)
                            PerlMemShared_free(trie->bitmap);
                        if (trie->jump)
                            PerlMemShared_free(trie->jump);
			PerlMemShared_free(trie->wordinfo);
                        /* do this last!!!! */
                        PerlMemShared_free(ri->data->data[n]);
		    }
		}
		break;
	    default:
		Perl_croak(aTHX_ "panic: regfree data code '%c'",
                                                    ri->data->what[n]);
	    }
	}
	Safefree(ri->data->what);
	Safefree(ri->data);
    }

    Safefree(ri);
}

#define av_dup_inc(s,t)	MUTABLE_AV(sv_dup_inc((const SV *)s,t))
#define hv_dup_inc(s,t)	MUTABLE_HV(sv_dup_inc((const SV *)s,t))
#define SAVEPVN(p,n)	((p) ? savepvn(p,n) : NULL)

/*
   re_dup_guts - duplicate a regexp.

   This routine is expected to clone a given regexp structure. It is only
   compiled under USE_ITHREADS.

   After all of the core data stored in struct regexp is duplicated
   the regexp_engine.dupe method is used to copy any private data
   stored in the *pprivate pointer. This allows extensions to handle
   any duplication it needs to do.

   See pregfree() and regfree_internal() if you change anything here.
*/
#if defined(USE_ITHREADS)
#ifndef PERL_IN_XSUB_RE
void
Perl_re_dup_guts(pTHX_ const REGEXP *sstr, REGEXP *dstr, CLONE_PARAMS *param)
{
    dVAR;
    I32 npar;
    const struct regexp *r = ReANY(sstr);
    struct regexp *ret = ReANY(dstr);

    PERL_ARGS_ASSERT_RE_DUP_GUTS;

    npar = r->nparens+1;
    Newx(ret->offs, npar, regexp_paren_pair);
    Copy(r->offs, ret->offs, npar, regexp_paren_pair);

    if (ret->substrs) {
	/* Do it this way to avoid reading from *r after the StructCopy().
	   That way, if any of the sv_dup_inc()s dislodge *r from the L1
	   cache, it doesn't matter.  */
	const bool anchored = r->check_substr
	    ? r->check_substr == r->anchored_substr
	    : r->check_utf8 == r->anchored_utf8;
        Newx(ret->substrs, 1, struct reg_substr_data);
	StructCopy(r->substrs, ret->substrs, struct reg_substr_data);

	ret->anchored_substr = sv_dup_inc(ret->anchored_substr, param);
	ret->anchored_utf8 = sv_dup_inc(ret->anchored_utf8, param);
	ret->float_substr = sv_dup_inc(ret->float_substr, param);
	ret->float_utf8 = sv_dup_inc(ret->float_utf8, param);

	/* check_substr and check_utf8, if non-NULL, point to either their
	   anchored or float namesakes, and don't hold a second reference.  */

	if (ret->check_substr) {
	    if (anchored) {
		assert(r->check_utf8 == r->anchored_utf8);
		ret->check_substr = ret->anchored_substr;
		ret->check_utf8 = ret->anchored_utf8;
	    } else {
		assert(r->check_substr == r->float_substr);
		assert(r->check_utf8 == r->float_utf8);
		ret->check_substr = ret->float_substr;
		ret->check_utf8 = ret->float_utf8;
	    }
	} else if (ret->check_utf8) {
	    if (anchored) {
		ret->check_utf8 = ret->anchored_utf8;
	    } else {
		ret->check_utf8 = ret->float_utf8;
	    }
	}
    }

    RXp_PAREN_NAMES(ret) = hv_dup_inc(RXp_PAREN_NAMES(ret), param);
    ret->qr_anoncv = MUTABLE_CV(sv_dup_inc((const SV *)ret->qr_anoncv, param));
    if (r->recurse_locinput)
        Newxz(ret->recurse_locinput,r->nparens + 1,char *);

    if (ret->pprivate)
	RXi_SET(ret,CALLREGDUPE_PVT(dstr,param));

    if (RX_MATCH_COPIED(dstr))
	ret->subbeg  = SAVEPVN(ret->subbeg, ret->sublen);
    else
	ret->subbeg = NULL;
#ifdef PERL_ANY_COW
    ret->saved_copy = NULL;
#endif

    /* Whether mother_re be set or no, we need to copy the string.  We
       cannot refrain from copying it when the storage points directly to
       our mother regexp, because that's
	       1: a buffer in a different thread
	       2: something we no longer hold a reference on
	       so we need to copy it locally.  */
    RX_WRAPPED(dstr) = SAVEPVN(RX_WRAPPED(sstr), SvCUR(sstr)+1);
    ret->mother_re   = NULL;
}
#endif /* PERL_IN_XSUB_RE */

/*
   regdupe_internal()

   This is the internal complement to regdupe() which is used to copy
   the structure pointed to by the *pprivate pointer in the regexp.
   This is the core version of the extension overridable cloning hook.
   The regexp structure being duplicated will be copied by perl prior
   to this and will be provided as the regexp *r argument, however
   with the /old/ structures pprivate pointer value. Thus this routine
   may override any copying normally done by perl.

   It returns a pointer to the new regexp_internal structure.
*/

void *
Perl_regdupe_internal(pTHX_ REGEXP * const rx, CLONE_PARAMS *param)
{
    dVAR;
    struct regexp *const r = ReANY(rx);
    regexp_internal *reti;
    int len;
    RXi_GET_DECL(r,ri);

    PERL_ARGS_ASSERT_REGDUPE_INTERNAL;

    len = ProgLen(ri);

    Newxc(reti, sizeof(regexp_internal) + len*sizeof(regnode),
          char, regexp_internal);
    Copy(ri->program, reti->program, len+1, regnode);


    reti->num_code_blocks = ri->num_code_blocks;
    if (ri->code_blocks) {
	int n;
	Newxc(reti->code_blocks, ri->num_code_blocks, struct reg_code_block,
		struct reg_code_block);
	Copy(ri->code_blocks, reti->code_blocks, ri->num_code_blocks,
		struct reg_code_block);
	for (n = 0; n < ri->num_code_blocks; n++)
	     reti->code_blocks[n].src_regex = (REGEXP*)
		    sv_dup_inc((SV*)(ri->code_blocks[n].src_regex), param);
    }
    else
	reti->code_blocks = NULL;

    reti->regstclass = NULL;

    if (ri->data) {
	struct reg_data *d;
        const int count = ri->data->count;
	int i;

	Newxc(d, sizeof(struct reg_data) + count*sizeof(void *),
		char, struct reg_data);
	Newx(d->what, count, U8);

	d->count = count;
	for (i = 0; i < count; i++) {
	    d->what[i] = ri->data->what[i];
	    switch (d->what[i]) {
	        /* see also regcomp.h and regfree_internal() */
	    case 'a': /* actually an AV, but the dup function is identical.  */
	    case 'r':
	    case 's':
	    case 'S':
	    case 'u': /* actually an HV, but the dup function is identical.  */
		d->data[i] = sv_dup_inc((const SV *)ri->data->data[i], param);
		break;
	    case 'f':
		/* This is cheating. */
		Newx(d->data[i], 1, regnode_ssc);
		StructCopy(ri->data->data[i], d->data[i], regnode_ssc);
		reti->regstclass = (regnode*)d->data[i];
		break;
	    case 'T':
		/* Trie stclasses are readonly and can thus be shared
		 * without duplication. We free the stclass in pregfree
		 * when the corresponding reg_ac_data struct is freed.
		 */
		reti->regstclass= ri->regstclass;
		/* FALLTHROUGH */
	    case 't':
		OP_REFCNT_LOCK;
		((reg_trie_data*)ri->data->data[i])->refcount++;
		OP_REFCNT_UNLOCK;
		/* FALLTHROUGH */
	    case 'l':
	    case 'L':
		d->data[i] = ri->data->data[i];
		break;
            default:
                Perl_croak(aTHX_ "panic: re_dup_guts unknown data code '%c'",
                                                           ri->data->what[i]);
	    }
	}

	reti->data = d;
    }
    else
	reti->data = NULL;

    reti->name_list_idx = ri->name_list_idx;

#ifdef RE_TRACK_PATTERN_OFFSETS
    if (ri->u.offsets) {
        Newx(reti->u.offsets, 2*len+1, U32);
        Copy(ri->u.offsets, reti->u.offsets, 2*len+1, U32);
    }
#else
    SetProgLen(reti,len);
#endif

    return (void*)reti;
}

#endif    /* USE_ITHREADS */

#ifndef PERL_IN_XSUB_RE

/*
 - regnext - dig the "next" pointer out of a node
 */
regnode *
Perl_regnext(pTHX_ regnode *p)
{
    I32 offset;

    if (!p)
	return(NULL);

    if (OP(p) > REGNODE_MAX) {		/* regnode.type is unsigned */
	Perl_croak(aTHX_ "Corrupted regexp opcode %d > %d",
                                                (int)OP(p), (int)REGNODE_MAX);
    }

    offset = (reg_off_by_arg[OP(p)] ? ARG(p) : NEXT_OFF(p));
    if (offset == 0)
	return(NULL);

    return(p+offset);
}
#endif

STATIC void
S_re_croak2(pTHX_ bool utf8, const char* pat1,const char* pat2,...)
{
    va_list args;
    STRLEN l1 = strlen(pat1);
    STRLEN l2 = strlen(pat2);
    char buf[512];
    SV *msv;
    const char *message;

    PERL_ARGS_ASSERT_RE_CROAK2;

    if (l1 > 510)
	l1 = 510;
    if (l1 + l2 > 510)
	l2 = 510 - l1;
    Copy(pat1, buf, l1 , char);
    Copy(pat2, buf + l1, l2 , char);
    buf[l1 + l2] = '\n';
    buf[l1 + l2 + 1] = '\0';
    va_start(args, pat2);
    msv = vmess(buf, &args);
    va_end(args);
    message = SvPV_const(msv,l1);
    if (l1 > 512)
	l1 = 512;
    Copy(message, buf, l1 , char);
    /* l1-1 to avoid \n */
    Perl_croak(aTHX_ "%"UTF8f, UTF8fARG(utf8, l1-1, buf));
}

/* XXX Here's a total kludge.  But we need to re-enter for swash routines. */

#ifndef PERL_IN_XSUB_RE
void
Perl_save_re_context(pTHX)
{
    I32 nparens = -1;
    I32 i;

    /* Save $1..$n (#18107: UTF-8 s/(\w+)/uc($1)/e); AMS 20021106. */

    if (PL_curpm) {
	const REGEXP * const rx = PM_GETRE(PL_curpm);
	if (rx)
            nparens = RX_NPARENS(rx);
    }

    /* RT #124109. This is a complete hack; in the SWASHNEW case we know
     * that PL_curpm will be null, but that utf8.pm and the modules it
     * loads will only use $1..$3.
     * The t/porting/re_context.t test file checks this assumption.
     */
    if (nparens == -1)
        nparens = 3;

    for (i = 1; i <= nparens; i++) {
        char digits[TYPE_CHARS(long)];
        const STRLEN len = my_snprintf(digits, sizeof(digits),
                                       "%lu", (long)i);
        GV *const *const gvp
            = (GV**)hv_fetch(PL_defstash, digits, len, 0);

        if (gvp) {
            GV * const gv = *gvp;
            if (SvTYPE(gv) == SVt_PVGV && GvSV(gv))
                save_scalar(gv);
        }
    }
}
#endif

#ifdef DEBUGGING

STATIC void
S_put_code_point(pTHX_ SV *sv, UV c)
{
    PERL_ARGS_ASSERT_PUT_CODE_POINT;

    if (c > 255) {
        Perl_sv_catpvf(aTHX_ sv, "\\x{%04"UVXf"}", c);
    }
    else if (isPRINT(c)) {
	const char string = (char) c;

        /* We use {phrase} as metanotation in the class, so also escape literal
         * braces */
	if (isBACKSLASHED_PUNCT(c) || c == '{' || c == '}')
	    sv_catpvs(sv, "\\");
	sv_catpvn(sv, &string, 1);
    }
    else if (isMNEMONIC_CNTRL(c)) {
        Perl_sv_catpvf(aTHX_ sv, "%s", cntrl_to_mnemonic((U8) c));
    }
    else {
        Perl_sv_catpvf(aTHX_ sv, "\\x%02X", (U8) c);
    }
}

#define MAX_PRINT_A MAX_PRINT_A_FOR_USE_ONLY_BY_REGCOMP_DOT_C

STATIC void
S_put_range(pTHX_ SV *sv, UV start, const UV end, const bool allow_literals)
{
    /* Appends to 'sv' a displayable version of the range of code points from
     * 'start' to 'end'.  Mnemonics (like '\r') are used for the few controls
     * that have them, when they occur at the beginning or end of the range.
     * It uses hex to output the remaining code points, unless 'allow_literals'
     * is true, in which case the printable ASCII ones are output as-is (though
     * some of these will be escaped by put_code_point()).
     *
     * NOTE:  This is designed only for printing ranges of code points that fit
     *        inside an ANYOF bitmap.  Higher code points are simply suppressed
     */

    const unsigned int min_range_count = 3;

    assert(start <= end);

    PERL_ARGS_ASSERT_PUT_RANGE;

    while (start <= end) {
        UV this_end;
        const char * format;

        if (end - start < min_range_count) {

            /* Output chars individually when they occur in short ranges */
            for (; start <= end; start++) {
                put_code_point(sv, start);
            }
            break;
        }

        /* If permitted by the input options, and there is a possibility that
         * this range contains a printable literal, look to see if there is
         * one. */
        if (allow_literals && start <= MAX_PRINT_A) {

            /* If the character at the beginning of the range isn't an ASCII
             * printable, effectively split the range into two parts:
             *  1) the portion before the first such printable,
             *  2) the rest
             * and output them separately. */
            if (! isPRINT_A(start)) {
                UV temp_end = start + 1;

                /* There is no point looking beyond the final possible
                 * printable, in MAX_PRINT_A */
                UV max = MIN(end, MAX_PRINT_A);

                while (temp_end <= max && ! isPRINT_A(temp_end)) {
                    temp_end++;
                }

                /* Here, temp_end points to one beyond the first printable if
                 * found, or to one beyond 'max' if not.  If none found, make
                 * sure that we use the entire range */
                if (temp_end > MAX_PRINT_A) {
                    temp_end = end + 1;
                }

                /* Output the first part of the split range: the part that
                 * doesn't have printables, with the parameter set to not look
                 * for literals (otherwise we would infinitely recurse) */
                put_range(sv, start, temp_end - 1, FALSE);

                /* The 2nd part of the range (if any) starts here. */
                start = temp_end;

                /* We do a continue, instead of dropping down, because even if
                 * the 2nd part is non-empty, it could be so short that we want
                 * to output it as individual characters, as tested for at the
                 * top of this loop.  */
                continue;
            }

            /* Here, 'start' is a printable ASCII.  If it is an alphanumeric,
             * output a sub-range of just the digits or letters, then process
             * the remaining portion as usual. */
            if (isALPHANUMERIC_A(start)) {
                UV mask = (isDIGIT_A(start))
                           ? _CC_DIGIT
                             : isUPPER_A(start)
                               ? _CC_UPPER
                               : _CC_LOWER;
                UV temp_end = start + 1;

                /* Find the end of the sub-range that includes just the
                 * characters in the same class as the first character in it */
                while (temp_end <= end && _generic_isCC_A(temp_end, mask)) {
                    temp_end++;
                }
                temp_end--;

                /* For short ranges, don't duplicate the code above to output
                 * them; just call recursively */
                if (temp_end - start < min_range_count) {
                    put_range(sv, start, temp_end, FALSE);
                }
                else {  /* Output as a range */
                    put_code_point(sv, start);
                    sv_catpvs(sv, "-");
                    put_code_point(sv, temp_end);
                }
                start = temp_end + 1;
                continue;
            }

            /* We output any other printables as individual characters */
            if (isPUNCT_A(start) || isSPACE_A(start)) {
                while (start <= end && (isPUNCT_A(start)
                                        || isSPACE_A(start)))
                {
                    put_code_point(sv, start);
                    start++;
                }
                continue;
            }
        } /* End of looking for literals */

        /* Here is not to output as a literal.  Some control characters have
         * mnemonic names.  Split off any of those at the beginning and end of
         * the range to print mnemonically.  It isn't possible for many of
         * these to be in a row, so this won't overwhelm with output */
        while (isMNEMONIC_CNTRL(start) && start <= end) {
            put_code_point(sv, start);
            start++;
        }
        if (start < end && isMNEMONIC_CNTRL(end)) {

            /* Here, the final character in the range has a mnemonic name.
             * Work backwards from the end to find the final non-mnemonic */
            UV temp_end = end - 1;
            while (isMNEMONIC_CNTRL(temp_end)) {
                temp_end--;
            }

            /* And separately output the interior range that doesn't start or
             * end with mnemonics */
            put_range(sv, start, temp_end, FALSE);

            /* Then output the mnemonic trailing controls */
            start = temp_end + 1;
            while (start <= end) {
                put_code_point(sv, start);
                start++;
            }
            break;
        }

        /* As a final resort, output the range or subrange as hex. */

        this_end = (end < NUM_ANYOF_CODE_POINTS)
                    ? end
                    : NUM_ANYOF_CODE_POINTS - 1;
#if NUM_ANYOF_CODE_POINTS > 256
        format = (this_end < 256)
                 ? "\\x%02"UVXf"-\\x%02"UVXf""
                 : "\\x{%04"UVXf"}-\\x{%04"UVXf"}";
#else
        format = "\\x%02"UVXf"-\\x%02"UVXf"";
#endif
        GCC_DIAG_IGNORE(-Wformat-nonliteral);
        Perl_sv_catpvf(aTHX_ sv, format, start, this_end);
        GCC_DIAG_RESTORE;
        break;
    }
}

STATIC void
S_put_charclass_bitmap_innards_invlist(pTHX_ SV *sv, SV* invlist)
{
    /* Concatenate onto the PV in 'sv' a displayable form of the inversion list
     * 'invlist' */

    UV start, end;
    bool allow_literals = TRUE;

    PERL_ARGS_ASSERT_PUT_CHARCLASS_BITMAP_INNARDS_INVLIST;

    /* Generally, it is more readable if printable characters are output as
     * literals, but if a range (nearly) spans all of them, it's best to output
     * it as a single range.  This code will use a single range if all but 2
     * ASCII printables are in it */
    invlist_iterinit(invlist);
    while (invlist_iternext(invlist, &start, &end)) {

        /* If the range starts beyond the final printable, it doesn't have any
         * in it */
        if (start > MAX_PRINT_A) {
            break;
        }

        /* In both ASCII and EBCDIC, a SPACE is the lowest printable.  To span
         * all but two, the range must start and end no later than 2 from
         * either end */
        if (start < ' ' + 2 && end > MAX_PRINT_A - 2) {
            if (end > MAX_PRINT_A) {
                end = MAX_PRINT_A;
            }
            if (start < ' ') {
                start = ' ';
            }
            if (end - start >= MAX_PRINT_A - ' ' - 2) {
                allow_literals = FALSE;
            }
            break;
        }
    }
    invlist_iterfinish(invlist);

    /* Here we have figured things out.  Output each range */
    invlist_iterinit(invlist);
    while (invlist_iternext(invlist, &start, &end)) {
        if (start >= NUM_ANYOF_CODE_POINTS) {
            break;
        }
        put_range(sv, start, end, allow_literals);
    }
    invlist_iterfinish(invlist);

    return;
}

STATIC SV*
S_put_charclass_bitmap_innards_common(pTHX_
        SV* invlist,            /* The bitmap */
        SV* posixes,            /* Under /l, things like [:word:], \S */
        SV* only_utf8,          /* Under /d, matches iff the target is UTF-8 */
        SV* not_utf8,           /* /d, matches iff the target isn't UTF-8 */
        SV* only_utf8_locale,   /* Under /l, matches if the locale is UTF-8 */
        const bool invert       /* Is the result to be inverted? */
)
{
    /* Create and return an SV containing a displayable version of the bitmap
     * and associated information determined by the input parameters. */

    SV * output;

    PERL_ARGS_ASSERT_PUT_CHARCLASS_BITMAP_INNARDS_COMMON;

    if (invert) {
        output = newSVpvs("^");
    }
    else {
        output = newSVpvs("");
    }

    /* First, the code points in the bitmap that are unconditionally there */
    put_charclass_bitmap_innards_invlist(output, invlist);

    /* Traditionally, these have been placed after the main code points */
    if (posixes) {
        sv_catsv(output, posixes);
    }

    if (only_utf8 && _invlist_len(only_utf8)) {
        Perl_sv_catpvf(aTHX_ output, "%s{utf8}%s", PL_colors[1], PL_colors[0]);
        put_charclass_bitmap_innards_invlist(output, only_utf8);
    }

    if (not_utf8 && _invlist_len(not_utf8)) {
        Perl_sv_catpvf(aTHX_ output, "%s{not utf8}%s", PL_colors[1], PL_colors[0]);
        put_charclass_bitmap_innards_invlist(output, not_utf8);
    }

    if (only_utf8_locale && _invlist_len(only_utf8_locale)) {
        Perl_sv_catpvf(aTHX_ output, "%s{utf8 locale}%s", PL_colors[1], PL_colors[0]);
        put_charclass_bitmap_innards_invlist(output, only_utf8_locale);

        /* This is the only list in this routine that can legally contain code
         * points outside the bitmap range.  The call just above to
         * 'put_charclass_bitmap_innards_invlist' will simply suppress them, so
         * output them here.  There's about a half-dozen possible, and none in
         * contiguous ranges longer than 2 */
        if (invlist_highest(only_utf8_locale) >= NUM_ANYOF_CODE_POINTS) {
            UV start, end;
            SV* above_bitmap = NULL;

            _invlist_subtract(only_utf8_locale, PL_InBitmap, &above_bitmap);

            invlist_iterinit(above_bitmap);
            while (invlist_iternext(above_bitmap, &start, &end)) {
                UV i;

                for (i = start; i <= end; i++) {
                    put_code_point(output, i);
                }
            }
            invlist_iterfinish(above_bitmap);
            SvREFCNT_dec_NN(above_bitmap);
        }
    }

    /* If the only thing we output is the '^', clear it */
    if (invert && SvCUR(output) == 1) {
        SvCUR_set(output, 0);
    }

    return output;
}

STATIC bool
S_put_charclass_bitmap_innards(pTHX_ SV *sv,
                                     char *bitmap,
                                     SV *nonbitmap_invlist,
                                     SV *only_utf8_locale_invlist,
                                     const regnode * const node)
{
    /* Appends to 'sv' a displayable version of the innards of the bracketed
     * character class defined by the other arguments:
     *  'bitmap' points to the bitmap.
     *  'nonbitmap_invlist' is an inversion list of the code points that are in
     *      the bitmap range, but for some reason aren't in the bitmap; NULL if
     *      none.  The reasons for this could be that they require some
     *      condition such as the target string being or not being in UTF-8
     *      (under /d), or because they came from a user-defined property that
     *      was not resolved at the time of the regex compilation (under /u)
     *  'only_utf8_locale_invlist' is an inversion list of the code points that
     *      are valid only if the runtime locale is a UTF-8 one; NULL if none
     *  'node' is the regex pattern node.  It is needed only when the above two
     *      parameters are not null, and is passed so that this routine can
     *      tease apart the various reasons for them.
     *
     * It returns TRUE if there was actually something output.  (It may be that
     * the bitmap, etc is empty.)
     *
     * When called for outputting the bitmap of a non-ANYOF node, just pass the
     * bitmap, with the succeeding parameters set to NULL.
     *
     */

    /* In general, it tries to display the 'cleanest' representation of the
     * innards, choosing whether to display them inverted or not, regardless of
     * whether the class itself is to be inverted.  However,  there are some
     * cases where it can't try inverting, as what actually matches isn't known
     * until runtime, and hence the inversion isn't either. */
    bool inverting_allowed = TRUE;

    int i;
    STRLEN orig_sv_cur = SvCUR(sv);

    SV* invlist;            /* Inversion list we accumulate of code points that
                               are unconditionally matched */
    SV* only_utf8 = NULL;   /* Under /d, list of matches iff the target is
                               UTF-8 */
    SV* not_utf8 =  NULL;   /* /d, list of matches iff the target isn't UTF-8
                             */
    SV* posixes = NULL;     /* Under /l, string of things like [:word:], \D */
    SV* only_utf8_locale = NULL;    /* Under /l, list of matches if the locale
                                       is UTF-8 */

    SV* as_is_display;      /* The output string when we take the inputs
                              literally */
    SV* inverted_display;   /* The output string when we invert the inputs */

    U8 flags = (node) ? ANYOF_FLAGS(node) : 0;

    bool invert = cBOOL(flags & ANYOF_INVERT);  /* Is the input to be inverted
                                                   to match? */
    /* We are biased in favor of displaying things without them being inverted,
     * as that is generally easier to understand */
    const int bias = 5;

    PERL_ARGS_ASSERT_PUT_CHARCLASS_BITMAP_INNARDS;

    /* Start off with whatever code points are passed in.  (We clone, so we
     * don't change the caller's list) */
    if (nonbitmap_invlist) {
        assert(invlist_highest(nonbitmap_invlist) < NUM_ANYOF_CODE_POINTS);
        invlist = invlist_clone(nonbitmap_invlist);
    }
    else {  /* Worst case size is every other code point is matched */
        invlist = _new_invlist(NUM_ANYOF_CODE_POINTS / 2);
    }

    if (flags) {
        if (OP(node) == ANYOFD) {

            /* This flag indicates that the code points below 0x100 in the
             * nonbitmap list are precisely the ones that match only when the
             * target is UTF-8 (they should all be non-ASCII). */
            if (flags & ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP)
            {
                _invlist_intersection(invlist, PL_UpperLatin1, &only_utf8);
                _invlist_subtract(invlist, only_utf8, &invlist);
            }

            /* And this flag for matching all non-ASCII 0xFF and below */
            if (flags & ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER)
            {
                not_utf8 = invlist_clone(PL_UpperLatin1);
            }
        }
        else if (OP(node) == ANYOFL) {

            /* If either of these flags are set, what matches isn't
             * determinable except during execution, so don't know enough here
             * to invert */
            if (flags & (ANYOFL_FOLD|ANYOF_MATCHES_POSIXL)) {
                inverting_allowed = FALSE;
            }

            /* What the posix classes match also varies at runtime, so these
             * will be output symbolically. */
            if (ANYOF_POSIXL_TEST_ANY_SET(node)) {
                int i;

                posixes = newSVpvs("");
                for (i = 0; i < ANYOF_POSIXL_MAX; i++) {
                    if (ANYOF_POSIXL_TEST(node,i)) {
                        sv_catpv(posixes, anyofs[i]);
                    }
                }
            }
        }
    }

    /* Accumulate the bit map into the unconditional match list */
    for (i = 0; i < NUM_ANYOF_CODE_POINTS; i++) {
        if (BITMAP_TEST(bitmap, i)) {
            int start = i++;
            for (; i < NUM_ANYOF_CODE_POINTS && BITMAP_TEST(bitmap, i); i++) {
                /* empty */
            }
            invlist = _add_range_to_invlist(invlist, start, i-1);
        }
    }

    /* Make sure that the conditional match lists don't have anything in them
     * that match unconditionally; otherwise the output is quite confusing.
     * This could happen if the code that populates these misses some
     * duplication. */
    if (only_utf8) {
        _invlist_subtract(only_utf8, invlist, &only_utf8);
    }
    if (not_utf8) {
        _invlist_subtract(not_utf8, invlist, &not_utf8);
    }

    if (only_utf8_locale_invlist) {

        /* Since this list is passed in, we have to make a copy before
         * modifying it */
        only_utf8_locale = invlist_clone(only_utf8_locale_invlist);

        _invlist_subtract(only_utf8_locale, invlist, &only_utf8_locale);

        /* And, it can get really weird for us to try outputting an inverted
         * form of this list when it has things above the bitmap, so don't even
         * try */
        if (invlist_highest(only_utf8_locale) >= NUM_ANYOF_CODE_POINTS) {
            inverting_allowed = FALSE;
        }
    }

    /* Calculate what the output would be if we take the input as-is */
    as_is_display = put_charclass_bitmap_innards_common(invlist,
                                                    posixes,
                                                    only_utf8,
                                                    not_utf8,
                                                    only_utf8_locale,
                                                    invert);

    /* If have to take the output as-is, just do that */
    if (! inverting_allowed) {
        sv_catsv(sv, as_is_display);
    }
    else { /* But otherwise, create the output again on the inverted input, and
              use whichever version is shorter */

        int inverted_bias, as_is_bias;

        /* We will apply our bias to whichever of the the results doesn't have
         * the '^' */
        if (invert) {
            invert = FALSE;
            as_is_bias = bias;
            inverted_bias = 0;
        }
        else {
            invert = TRUE;
            as_is_bias = 0;
            inverted_bias = bias;
        }

        /* Now invert each of the lists that contribute to the output,
         * excluding from the result things outside the possible range */

        /* For the unconditional inversion list, we have to add in all the
         * conditional code points, so that when inverted, they will be gone
         * from it */
        _invlist_union(only_utf8, invlist, &invlist);
        _invlist_union(not_utf8, invlist, &invlist);
        _invlist_union(only_utf8_locale, invlist, &invlist);
        _invlist_invert(invlist);
        _invlist_intersection(invlist, PL_InBitmap, &invlist);

        if (only_utf8) {
            _invlist_invert(only_utf8);
            _invlist_intersection(only_utf8, PL_UpperLatin1, &only_utf8);
        }

        if (not_utf8) {
            _invlist_invert(not_utf8);
            _invlist_intersection(not_utf8, PL_UpperLatin1, &not_utf8);
        }

        if (only_utf8_locale) {
            _invlist_invert(only_utf8_locale);
            _invlist_intersection(only_utf8_locale,
                                  PL_InBitmap,
                                  &only_utf8_locale);
        }

        inverted_display = put_charclass_bitmap_innards_common(
                                            invlist,
                                            posixes,
                                            only_utf8,
                                            not_utf8,
                                            only_utf8_locale, invert);

        /* Use the shortest representation, taking into account our bias
         * against showing it inverted */
        if (SvCUR(inverted_display) + inverted_bias
            < SvCUR(as_is_display) + as_is_bias)
        {
	    sv_catsv(sv, inverted_display);
        }
        else {
	    sv_catsv(sv, as_is_display);
        }

        SvREFCNT_dec_NN(as_is_display);
        SvREFCNT_dec_NN(inverted_display);
    }

    SvREFCNT_dec_NN(invlist);
    SvREFCNT_dec(only_utf8);
    SvREFCNT_dec(not_utf8);
    SvREFCNT_dec(posixes);
    SvREFCNT_dec(only_utf8_locale);

    return SvCUR(sv) > orig_sv_cur;
}

#define CLEAR_OPTSTART                                                       \
    if (optstart) STMT_START {                                               \
        DEBUG_OPTIMISE_r(Perl_re_printf( aTHX_                                           \
                              " (%"IVdf" nodes)\n", (IV)(node - optstart))); \
        optstart=NULL;                                                       \
    } STMT_END

#define DUMPUNTIL(b,e)                                                       \
                    CLEAR_OPTSTART;                                          \
                    node=dumpuntil(r,start,(b),(e),last,sv,indent+1,depth+1);

STATIC const regnode *
S_dumpuntil(pTHX_ const regexp *r, const regnode *start, const regnode *node,
	    const regnode *last, const regnode *plast,
	    SV* sv, I32 indent, U32 depth)
{
    U8 op = PSEUDO;	/* Arbitrary non-END op. */
    const regnode *next;
    const regnode *optstart= NULL;

    RXi_GET_DECL(r,ri);
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_DUMPUNTIL;

#ifdef DEBUG_DUMPUNTIL
    Perl_re_printf( aTHX_  "--- %d : %d - %d - %d\n",indent,node-start,
        last ? last-start : 0,plast ? plast-start : 0);
#endif

    if (plast && plast < last)
        last= plast;

    while (PL_regkind[op] != END && (!last || node < last)) {
        assert(node);
	/* While that wasn't END last time... */
	NODE_ALIGN(node);
	op = OP(node);
	if (op == CLOSE || op == WHILEM)
	    indent--;
	next = regnext((regnode *)node);

	/* Where, what. */
	if (OP(node) == OPTIMIZED) {
	    if (!optstart && RE_DEBUG_FLAG(RE_DEBUG_COMPILE_OPTIMISE))
	        optstart = node;
	    else
		goto after_print;
	} else
	    CLEAR_OPTSTART;

        regprop(r, sv, node, NULL, NULL);
        Perl_re_printf( aTHX_  "%4"IVdf":%*s%s", (IV)(node - start),
		      (int)(2*indent + 1), "", SvPVX_const(sv));

        if (OP(node) != OPTIMIZED) {
            if (next == NULL)		/* Next ptr. */
                Perl_re_printf( aTHX_  " (0)");
            else if (PL_regkind[(U8)op] == BRANCH
                     && PL_regkind[OP(next)] != BRANCH )
                Perl_re_printf( aTHX_  " (FAIL)");
            else
                Perl_re_printf( aTHX_  " (%"IVdf")", (IV)(next - start));
            Perl_re_printf( aTHX_ "\n");
        }

      after_print:
	if (PL_regkind[(U8)op] == BRANCHJ) {
	    assert(next);
	    {
                const regnode *nnode = (OP(next) == LONGJMP
                                       ? regnext((regnode *)next)
                                       : next);
                if (last && nnode > last)
                    nnode = last;
                DUMPUNTIL(NEXTOPER(NEXTOPER(node)), nnode);
	    }
	}
	else if (PL_regkind[(U8)op] == BRANCH) {
	    assert(next);
	    DUMPUNTIL(NEXTOPER(node), next);
	}
	else if ( PL_regkind[(U8)op]  == TRIE ) {
	    const regnode *this_trie = node;
	    const char op = OP(node);
            const U32 n = ARG(node);
	    const reg_ac_data * const ac = op>=AHOCORASICK ?
               (reg_ac_data *)ri->data->data[n] :
               NULL;
	    const reg_trie_data * const trie =
	        (reg_trie_data*)ri->data->data[op<AHOCORASICK ? n : ac->trie];
#ifdef DEBUGGING
	    AV *const trie_words
                           = MUTABLE_AV(ri->data->data[n + TRIE_WORDS_OFFSET]);
#endif
	    const regnode *nextbranch= NULL;
	    I32 word_idx;
            sv_setpvs(sv, "");
	    for (word_idx= 0; word_idx < (I32)trie->wordcount; word_idx++) {
		SV ** const elem_ptr = av_fetch(trie_words,word_idx,0);

                Perl_re_indentf( aTHX_  "%s ",
                    indent+3,
                    elem_ptr
                    ? pv_pretty(sv, SvPV_nolen_const(*elem_ptr),
                                SvCUR(*elem_ptr), 60,
                                PL_colors[0], PL_colors[1],
                                (SvUTF8(*elem_ptr)
                                 ? PERL_PV_ESCAPE_UNI
                                 : 0)
                                | PERL_PV_PRETTY_ELLIPSES
                                | PERL_PV_PRETTY_LTGT
                            )
                    : "???"
                );
                if (trie->jump) {
                    U16 dist= trie->jump[word_idx+1];
                    Perl_re_printf( aTHX_  "(%"UVuf")\n",
                               (UV)((dist ? this_trie + dist : next) - start));
                    if (dist) {
                        if (!nextbranch)
                            nextbranch= this_trie + trie->jump[0];
			DUMPUNTIL(this_trie + dist, nextbranch);
                    }
                    if (nextbranch && PL_regkind[OP(nextbranch)]==BRANCH)
                        nextbranch= regnext((regnode *)nextbranch);
                } else {
                    Perl_re_printf( aTHX_  "\n");
		}
	    }
	    if (last && next > last)
	        node= last;
	    else
	        node= next;
	}
	else if ( op == CURLY ) {   /* "next" might be very big: optimizer */
	    DUMPUNTIL(NEXTOPER(node) + EXTRA_STEP_2ARGS,
                    NEXTOPER(node) + EXTRA_STEP_2ARGS + 1);
	}
	else if (PL_regkind[(U8)op] == CURLY && op != CURLYX) {
	    assert(next);
	    DUMPUNTIL(NEXTOPER(node) + EXTRA_STEP_2ARGS, next);
	}
	else if ( op == PLUS || op == STAR) {
	    DUMPUNTIL(NEXTOPER(node), NEXTOPER(node) + 1);
	}
	else if (PL_regkind[(U8)op] == ANYOF) {
	    /* arglen 1 + class block */
	    node += 1 + ((ANYOF_FLAGS(node) & ANYOF_MATCHES_POSIXL)
                          ? ANYOF_POSIXL_SKIP
                          : ANYOF_SKIP);
	    node = NEXTOPER(node);
	}
	else if (PL_regkind[(U8)op] == EXACT) {
            /* Literal string, where present. */
	    node += NODE_SZ_STR(node) - 1;
	    node = NEXTOPER(node);
	}
	else {
	    node = NEXTOPER(node);
	    node += regarglen[(U8)op];
	}
	if (op == CURLYX || op == OPEN)
	    indent++;
    }
    CLEAR_OPTSTART;
#ifdef DEBUG_DUMPUNTIL
    Perl_re_printf( aTHX_  "--- %d\n", (int)indent);
#endif
    return node;
}

#endif	/* DEBUGGING */

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
@


1.21
log
@Update to perl 5.20.3

OK bluhm@@
@
text
@d89 2
a90 3
#include "dquote_static.c"
#include "charclass_invlists.h"
#include "inline_invlist.c"
d95 2
d104 29
d138 1
d146 2
d171 1
a171 1
    regnode	*opend;			/* END node in program */
d182 2
a183 2
    I32		recurse_count;		/* Number of recurse regops */
    U8          *study_chunk_recursed;  /* bitmap of which parens we have moved
d190 3
d199 3
d211 3
d217 5
d223 2
d230 3
d240 11
a258 1
#define RExC_naughty	(pRExC_state->naughty)
d272 1
a272 1
#define RExC_opend	(pRExC_state->opend)
d283 3
d287 18
a304 1

d308 1
a308 1
	((*s) == '{' && regcurly(s, FALSE)))
d324 3
a326 1
#define RESTART_UTF8    0x20    /* Restart, need to calcuate sizes as UTF-8 */
d345 1
a345 1
#define REQUIRE_UTF8	STMT_START {                                       \
d347 2
a348 1
                                         *flagp = RESTART_UTF8;            \
d351 18
a368 1
                        } STMT_END
a479 18
/* The below is perhaps overboard, but this allows us to save a test at the
 * expense of a mask.  This is because on both EBCDIC and ASCII machines, 'A'
 * and 'a' differ by a single bit; the same with the upper and lower case of
 * all other ASCII-range alphabetics.  On ASCII platforms, they are 32 apart;
 * on EBCDIC, they are 64.  This uses an exclusive 'or' to find that bit and
 * then inverts it to form a mask, with just a single 0, in the bit position
 * where the upper- and lowercase differ.  XXX There are about 40 other
 * instances in the Perl core where this micro-optimization could be used.
 * Should decide if maintenance cost is worse, before changing those
 *
 * Returns a boolean as to whether or not 'v' is either a lowercase or
 * uppercase instance of 'c', where 'c' is in [A-Za-z].  If 'c' is a
 * compile-time constant, the generated code is better than some optimizing
 * compilers figure out, amounting to a mask and test.  The results are
 * meaningless if 'c' is not one of [A-Za-z] */
#define isARG2_lower_or_UPPER_ARG1(c, v) \
                              (((v) & ~('A' ^ 'a')) ==  ((c) & ~('A' ^ 'a')))

d505 12
d518 1
d527 4
d580 65
a644 3
#define REPORT_LOCATION_ARGS(offset)            \
                UTF8fARG(UTF, offset, RExC_precomp), \
                UTF8fARG(UTF, RExC_end - RExC_precomp - offset, RExC_precomp + offset)
d653 1
a653 1
    IV len = RExC_end - RExC_precomp;					\
a676 1
    const IV offset = RExC_parse - RExC_precomp;			\
d678 1
a678 1
	    m, REPORT_LOCATION_ARGS(offset));	\
d694 2
a695 3
    const IV offset = RExC_parse - RExC_precomp;			\
    S_re_croak2(aTHX_ UTF, m, REPORT_LOCATION, a1,			\
                      REPORT_LOCATION_ARGS(offset));	\
a711 1
    const IV offset = RExC_parse - RExC_precomp;		\
d713 1
a713 1
	    REPORT_LOCATION_ARGS(offset));	\
d729 2
a730 3
    const IV offset = RExC_parse - RExC_precomp;		\
    S_re_croak2(aTHX_ UTF, m, REPORT_LOCATION, a1, a2, a3,		\
	    REPORT_LOCATION_ARGS(offset));	\
d740 12
a751 6
#define vFAIL2utf8f(m, a1) STMT_START { \
    const IV offset = RExC_parse - RExC_precomp;   \
    if (!SIZE_ONLY)                                \
        SAVEFREESV(RExC_rx_sv);                    \
    S_re_croak2(aTHX_ UTF, m, REPORT_LOCATION, a1, \
            REPORT_LOCATION_ARGS(offset));         \
d754 5
d762 3
a764 3
    const IV offset = loc - RExC_precomp;                               \
    Perl_warner(aTHX_ packWARN(WARN_REGEXP), "%s" REPORT_LOCATION,      \
            m, REPORT_LOCATION_ARGS(offset));       \
d768 9
a776 3
    const IV offset = loc - RExC_precomp;				\
    Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP), m REPORT_LOCATION,	\
	    REPORT_LOCATION_ARGS(offset));		\
d780 3
a782 3
    const IV offset = loc - RExC_precomp;				\
    Perl_warner(aTHX_ packWARN(WARN_DEPRECATED), m REPORT_LOCATION,	\
	    REPORT_LOCATION_ARGS(offset));	        \
d786 3
a788 4
    const IV offset = loc - RExC_precomp;				\
    Perl_ck_warner_d(aTHX_ packWARN(WARN_DEPRECATED),	                \
	    m REPORT_LOCATION,						\
	    REPORT_LOCATION_ARGS(offset));		\
d791 5
a795 5
#define	ckWARNregdep(loc,m) STMT_START {				\
    const IV offset = loc - RExC_precomp;				\
    Perl_ck_warner_d(aTHX_ packWARN2(WARN_DEPRECATED, WARN_REGEXP),	\
	    m REPORT_LOCATION,						\
	    REPORT_LOCATION_ARGS(offset));		\
d798 4
a801 5
#define	ckWARN2reg_d(loc,m, a1) STMT_START {				\
    const IV offset = loc - RExC_precomp;				\
    Perl_ck_warner_d(aTHX_ packWARN(WARN_REGEXP),			\
	    m REPORT_LOCATION,						\
	    a1, REPORT_LOCATION_ARGS(offset));	\
d804 4
a807 4
#define	ckWARN2reg(loc, m, a1) STMT_START {				\
    const IV offset = loc - RExC_precomp;				\
    Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP), m REPORT_LOCATION,	\
	    a1, REPORT_LOCATION_ARGS(offset));	\
d810 4
a813 4
#define	vWARN3(loc, m, a1, a2) STMT_START {				\
    const IV offset = loc - RExC_precomp;				\
    Perl_warner(aTHX_ packWARN(WARN_REGEXP), m REPORT_LOCATION,		\
	    a1, a2, REPORT_LOCATION_ARGS(offset));	\
d816 5
a820 4
#define	ckWARN3reg(loc, m, a1, a2) STMT_START {				\
    const IV offset = loc - RExC_precomp;				\
    Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP), m REPORT_LOCATION,	\
	    a1, a2, REPORT_LOCATION_ARGS(offset));	\
d824 4
a827 3
    const IV offset = loc - RExC_precomp;				\
    Perl_warner(aTHX_ packWARN(WARN_REGEXP), m REPORT_LOCATION,		\
	    a1, a2, a3, REPORT_LOCATION_ARGS(offset)); \
d831 4
a834 3
    const IV offset = loc - RExC_precomp;				\
    Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP), m REPORT_LOCATION,	\
	    a1, a2, a3, REPORT_LOCATION_ARGS(offset)); \
d838 4
a841 9
    const IV offset = loc - RExC_precomp;				\
    Perl_warner(aTHX_ packWARN(WARN_REGEXP), m REPORT_LOCATION,		\
	    a1, a2, a3, a4, REPORT_LOCATION_ARGS(offset)); \
} STMT_END


/* Allow for side effects in s */
#define REGC(c,s) STMT_START {			\
    if (!SIZE_ONLY) *(s) = (c); else (void)(s);	\
d914 30
a943 1
#define DEBUG_RExC_seen() \
d945 1
a945 1
            PerlIO_printf(Perl_debug_log,"RExC_seen: ");                    \
d948 1
a948 1
                PerlIO_printf(Perl_debug_log,"REG_ZERO_LEN_SEEN ");         \
d951 1
a951 1
                PerlIO_printf(Perl_debug_log,"REG_LOOKBEHIND_SEEN ");       \
d954 1
a954 4
                PerlIO_printf(Perl_debug_log,"REG_GPOS_SEEN ");             \
                                                                            \
            if (RExC_seen & REG_CANY_SEEN)                                  \
                PerlIO_printf(Perl_debug_log,"REG_CANY_SEEN ");             \
d957 1
a957 1
                PerlIO_printf(Perl_debug_log,"REG_RECURSE_SEEN ");          \
d959 2
a960 2
            if (RExC_seen & REG_TOP_LEVEL_BRANCHES_SEEN)                         \
                PerlIO_printf(Perl_debug_log,"REG_TOP_LEVEL_BRANCHES_SEEN ");    \
d963 1
a963 1
                PerlIO_printf(Perl_debug_log,"REG_VERBARG_SEEN ");          \
d966 1
a966 1
                PerlIO_printf(Perl_debug_log,"REG_CUTGROUP_SEEN ");         \
d969 1
a969 1
                PerlIO_printf(Perl_debug_log,"REG_RUN_ON_COMMENT_SEEN ");   \
d972 1
a972 4
                PerlIO_printf(Perl_debug_log,"REG_UNFOLDED_MULTI_SEEN ");   \
                                                                            \
            if (RExC_seen & REG_GOSTART_SEEN)                               \
                PerlIO_printf(Perl_debug_log,"REG_GOSTART_SEEN ");          \
d974 2
a975 2
            if (RExC_seen & REG_UNBOUNDED_QUANTIFIER_SEEN)                               \
                PerlIO_printf(Perl_debug_log,"REG_UNBOUNDED_QUANTIFIER_SEEN ");          \
d977 1
a977 1
            PerlIO_printf(Perl_debug_log,"\n");                             \
d980 25
d1007 3
a1009 4
    PerlIO_printf(Perl_debug_log,                                    \
        "%*s" str "Pos:%"IVdf"/%"IVdf                                \
        " Flags: 0x%"UVXf" Whilem_c: %"IVdf" Lcp: %"IVdf" %s",       \
        (int)(depth)*2, "",                                          \
d1012 5
a1016 1
        (UV)((data)->flags),                                         \
d1022 1
a1022 1
        PerlIO_printf(Perl_debug_log,                                \
d1039 1
a1039 1
    PerlIO_printf(Perl_debug_log,"\n");                              \
d1042 169
d1240 2
a1241 2
				      ? data->last_start_max
				      : (data->pos_delta == SSize_t_MAX
d1284 1
a1284 1
    ANYOF_FLAGS(ssc) |= ANYOF_EMPTY_STRING;    /* Plus match empty string */
d1288 1
a1288 1
S_ssc_is_anything(pTHX_ const regnode_ssc *ssc)
d1302 1
a1302 1
    if (! (ANYOF_FLAGS(ssc) & ANYOF_EMPTY_STRING)) {
d1341 1
a1341 1
    ARG_SET(ssc, ANYOF_NONBITMAP_EMPTY);
d1344 7
a1350 7
    /* If any portion of the regex is to operate under locale rules,
     * initialization includes it.  The reason this isn't done for all regexes
     * is that the optimizer was written under the assumption that locale was
     * all-or-nothing.  Given the complexity and lack of documentation in the
     * optimizer, and that there are inadequate test cases for locale, many
     * parts of it may not work properly, it is safest to avoid locale unless
     * necessary. */
d1360 2
a1361 2
S_ssc_is_cp_posixl_init(pTHX_ const RExC_state_t *pRExC_state,
                              const regnode_ssc *ssc)
d1402 1
a1402 1
    SV* invlist = sv_2mortal(_new_invlist(0));
d1411 1
a1411 1
    if (n != ANYOF_NONBITMAP_EMPTY) {
d1424 1
d1435 1
a1435 1
        if ((ANYOF_FLAGS(node) & ANYOF_LOC_FOLD)
d1442 14
a1455 9
    /* An ANYOF node contains a bitmap for the first 256 code points, and an
     * inversion list for the others, but if there are code points that should
     * match only conditionally on the target string being UTF-8, those are
     * placed in the inversion list, and not the bitmap.  Since there are
     * circumstances under which they could match, they are included in the
     * SSC.  But if the ANYOF node is to be inverted, we have to exclude them
     * here, so that when we invert below, the end result actually does include
     * them.  (Think about "\xe0" =~ /[^\xc0]/di;).  We have to do this here
     * before we add the unconditionally matched code points */
d1463 1
a1463 1
    for (i = 0; i < 256; i++) {
d1465 6
a1470 1
            invlist = add_cp_to_invlist(invlist, i);
d1476 6
a1481 2
     * as well */
    if (ANYOF_FLAGS(node) & ANYOF_NON_UTF8_NON_ASCII_ALL) {
d1486 2
a1487 2
    if (ANYOF_FLAGS(node) & ANYOF_ABOVE_LATIN1_ALL) {
        invlist = _add_range_to_invlist(invlist, 256, UV_MAX);
d1493 1
a1493 1
    else if (new_node_has_latin1 && ANYOF_FLAGS(node) & ANYOF_LOC_FOLD) {
d1520 2
a1521 2
 * should not be inverted.  'and_with->flags & ANYOF_POSIXL' should be 0 if
 * 'and_with' is a regnode_charclass instead of a regnode_ssc. */
d1559 1
a1559 1
            anded_flags |= ANYOF_WARN_SUPER;
d1564 13
a1576 1
        anded_flags = ANYOF_FLAGS(and_with) & ANYOF_COMMON_FLAGS;
d1624 1
a1624 1
        if (! (ANYOF_FLAGS(and_with) & ANYOF_POSIXL)) {
d1683 1
a1683 1
                if (ANYOF_FLAGS(and_with) & ANYOF_POSIXL) {
d1689 1
a1689 1
                 || (ANYOF_FLAGS(and_with) & ANYOF_POSIXL))
d1692 1
a1692 1
            if (ANYOF_FLAGS(and_with) & ANYOF_POSIXL) {
d1727 10
d1764 1
a1764 1
    else if (ANYOF_FLAGS(or_with) & ANYOF_POSIXL) {
d1842 1
a1842 1
S_ssc_clear_locale(pTHX_ regnode_ssc *ssc)
a1844 1

d1853 58
d1916 2
a1917 1
     * ANYOF node, with the first 256 code points in a bit map */
d1926 6
a1931 3
     * to the SSC, except ANYOF_EMPTY_STRING, which should be cleared by the
     * time we reach here */
    assert(! (ANYOF_FLAGS(ssc) & ~ANYOF_COMMON_FLAGS));
d1942 5
a1946 1
        ANYOF_FLAGS(ssc) |= ANYOF_POSIXL;
d1993 2
a1994 3
    PerlIO_printf( Perl_debug_log, "%*sChar : %-6s%-6s%-4s ",
        (int)depth * 2 + 2,"",
        "Match","Base","Ofs" );
d1999 1
a1999 1
            PerlIO_printf( Perl_debug_log, "%*s",
d2009 2
a2010 2
    PerlIO_printf( Perl_debug_log, "\n%*sState|-----------------------",
        (int)depth * 2 + 2,"");
d2013 2
a2014 2
        PerlIO_printf( Perl_debug_log, "%.*s", colwidth, "--------");
    PerlIO_printf( Perl_debug_log, "\n");
d2019 1
a2019 2
        PerlIO_printf( Perl_debug_log, "%*s#%4"UVXf"|",
                                       (int)depth * 2 + 2,"", (UV)state);
d2022 1
a2022 2
            PerlIO_printf( Perl_debug_log, " W%4X",
                                           trie->states[ state ].wordnum );
d2024 1
a2024 1
            PerlIO_printf( Perl_debug_log, "%6s", "" );
d2027 1
a2027 1
        PerlIO_printf( Perl_debug_log, " @@%4"UVXf" ", (UV)base );
d2038 1
a2038 1
            PerlIO_printf( Perl_debug_log, "+%2"UVXf"[ ", (UV)ofs);
d2047 3
a2049 4
                   PerlIO_printf( Perl_debug_log, "%*"UVXf,
                    colwidth,
                    (UV)trie->trans[ base + ofs
                                             - trie->uniquecharcount ].next );
d2051 1
a2051 1
                    PerlIO_printf( Perl_debug_log, "%*s",colwidth,"   ." );
d2055 1
a2055 1
            PerlIO_printf( Perl_debug_log, "]");
d2058 1
a2058 1
        PerlIO_printf( Perl_debug_log, "\n" );
d2060 2
a2061 2
    PerlIO_printf(Perl_debug_log, "%*sword_info N:(prev,len)=",
                                (int)depth*2, "");
d2063 1
a2063 1
	PerlIO_printf(Perl_debug_log, " %d:(%d,%d)",
d2067 1
a2067 1
    PerlIO_printf(Perl_debug_log, "\n" );
d2088 4
a2091 3
    PerlIO_printf( Perl_debug_log, "%*sState :Word | Transition Data\n%*s%s",
        (int)depth * 2 + 2,"", (int)depth * 2 + 2,"",
        "------:-----+-----------------\n" );
d2096 2
a2097 2
        PerlIO_printf( Perl_debug_log, "%*s %4"UVXf" :",
            (int)depth * 2 + 2,"", (UV)state  );
d2099 1
a2099 1
            PerlIO_printf( Perl_debug_log, "%5s| ","");
d2101 1
a2101 1
            PerlIO_printf( Perl_debug_log, "W%4x| ",
d2109 1
a2109 1
                PerlIO_printf( Perl_debug_log, "%*s:%3X=%4"UVXf" | ",
d2121 1
a2121 1
                    PerlIO_printf(Perl_debug_log, "\n%*s| ",
d2125 1
a2125 1
        PerlIO_printf( Perl_debug_log, "\n");
d2153 1
a2153 1
    PerlIO_printf( Perl_debug_log, "%*sChar : ",(int)depth * 2 + 2,"" );
d2158 1
a2158 1
            PerlIO_printf( Perl_debug_log, "%*s",
d2169 2
a2170 1
    PerlIO_printf( Perl_debug_log, "\n%*sState+-",(int)depth * 2 + 2,"" );
d2173 1
a2173 1
        PerlIO_printf( Perl_debug_log, "%.*s", colwidth,"--------");
d2176 1
a2176 1
    PerlIO_printf( Perl_debug_log, "\n" );
d2180 2
a2181 2
        PerlIO_printf( Perl_debug_log, "%*s%4"UVXf" : ",
            (int)depth * 2 + 2,"",
d2187 1
a2187 1
                PerlIO_printf( Perl_debug_log, "%*"UVXf, colwidth, v );
d2189 1
a2189 1
                PerlIO_printf( Perl_debug_log, "%*s", colwidth, "." );
d2192 1
a2192 1
            PerlIO_printf( Perl_debug_log, " (%4"UVXf")\n",
d2195 1
a2195 1
            PerlIO_printf( Perl_debug_log, " (%4"UVXf") W%4X\n",
d2213 1
a2213 1
  flags      : currently the OP() type we will be building one of /EXACT(|F|Fl)/
d2246 1
a2246 1
rest of the regex in the order in which they occured in the alternation.
d2325 1
a2325 1
            SV *zlopp = newSV(7); /* XXX: optimize me */                   \
a2441 1
    dVAR;
d2477 1
a2477 1
        case EXACT: break;
d2480 2
a2481 1
	case EXACTFU: folder = PL_fold_latin1; break;
d2492 1
a2492 1
    if (flags == EXACT)
d2502 1
d2507 3
a2509 3
        PerlIO_printf( Perl_debug_log,
          "%*smake_trie start==%d, first==%d, last==%d, tail==%d depth=%d\n",
          (int)depth * 2 + 2, "",
d2548 2
a2549 2
        const U8 *uc = (U8*)STRING( noper );
        const U8 *e  = uc + STR_LEN( noper );
d2559 10
a2568 9
            if (noper_next != tail && OP(noper_next) == flags) {
                noper = noper_next;
                uc= (U8*)STRING(noper);
                e= uc + STR_LEN(noper);
		trie->minlen= STR_LEN(noper);
            } else {
		trie->minlen= 0;
		continue;
	    }
d2571 1
d2714 3
a2716 3
        PerlIO_printf( Perl_debug_log,
                "%*sTRIE(%s): W:%d C:%d Uq:%d Min:%d Max:%d\n",
                (int)depth * 2 + 2,"",
d2764 2
a2765 3
        DEBUG_TRIE_COMPILE_MORE_r( PerlIO_printf( Perl_debug_log,
            "%*sCompiling trie using list compiler\n",
            (int)depth * 2 + 2, ""));
a2775 2
	    U8 *uc           = (U8*)STRING( noper );
            const U8 *e      = uc + STR_LEN( noper );
d2782 2
a2783 5
                if (noper_next != tail && OP(noper_next) == flags) {
                    noper = noper_next;
                    uc= (U8*)STRING(noper);
                    e= uc + STR_LEN(noper);
                }
d2786 4
a2789 1
            if (OP(noper) != NOTHING) {
d2871 1
a2871 1
                    PerlIO_printf( Perl_debug_log, "tp: %d zp: %d ",tp,zp)
d2933 1
a2933 1
                    PerlIO_printf( Perl_debug_log, " base: %d\n",base);
d2976 2
a2977 3
        DEBUG_TRIE_COMPILE_MORE_r( PerlIO_printf( Perl_debug_log,
            "%*sCompiling trie using table compiler\n",
            (int)depth * 2 + 2, ""));
a2991 2
	    const U8 *uc     = (U8*)STRING( noper );
            const U8 *e      = uc + STR_LEN( noper );
d3002 2
a3003 5
                if (noper_next != tail && OP(noper_next) == flags) {
                    noper = noper_next;
                    uc= (U8*)STRING(noper);
                    e= uc + STR_LEN(noper);
                }
d3006 4
a3009 1
            if ( OP(noper) != NOTHING ) {
d3167 2
a3168 3
            PerlIO_printf( Perl_debug_log,
                "%*sAlloc: %d Orig: %"IVdf" elements, Final:%"IVdf". Savings of %%%5.2f\n",
                (int)depth * 2 + 2,"",
d3179 2
a3180 3
            PerlIO_printf(Perl_debug_log,
                "%*sStatecount:%"UVxf" Lasttrans:%"UVxf"\n",
                (int)depth * 2 + 2, "",
d3230 2
a3231 3
            PerlIO_printf(Perl_debug_log,
                "%*sMJD offset:%"UVuf" MJD length:%"UVuf"\n",
                (int)depth * 2 + 2, "",
d3261 2
a3262 3
                                    PerlIO_printf(Perl_debug_log,
					"%*sNew Start State=%"UVuf" Class: [",
                                        (int)depth * 2 + 2, "",
d3272 1
a3272 1
                                        PerlIO_printf(Perl_debug_log, "%s", (char*)ch)
d3279 1
a3279 1
			    DEBUG_OPTIMISE_r(PerlIO_printf( Perl_debug_log,"%s", ch));
d3290 2
a3291 3
                        PerlIO_printf( Perl_debug_log,
			    "%*sPrefix State: %"UVuf" Idx:%"UVuf" Char='%s'\n",
                            (int)depth * 2 + 2, "",
d3311 1
a3311 1
			DEBUG_OPTIMISE_r(PerlIO_printf( Perl_debug_log,"]\n"));
d3468 2
a3469 2
STATIC void
S_make_trie_failtable(pTHX_ RExC_state_t *pRExC_state, regnode *source,  regnode *stclass, U32 depth)
d3507 1
d3510 2
a3511 1
    PERL_ARGS_ASSERT_MAKE_TRIE_FAILTABLE;
d3516 12
d3583 2
a3584 3
        PerlIO_printf(Perl_debug_log,
		      "%*sStclass Failtable (%"UVuf" states): 0",
		      (int)(depth * 2), "", (UV)numstates
d3587 1
a3587 1
            PerlIO_printf(Perl_debug_log, ", %"UVuf, (UV)fail[q_read]);
d3589 1
a3589 1
        PerlIO_printf(Perl_debug_log, "\n");
d3593 1
d3597 9
a3605 8
#define DEBUG_PEEP(str,scan,depth) \
    DEBUG_OPTIMISE_r({if (scan){ \
       SV * const mysv=sv_newmortal(); \
       regnode *Next = regnext(scan); \
       regprop(RExC_rx, mysv, scan, NULL); \
       PerlIO_printf(Perl_debug_log, "%*s" str ">%3d: %s (%d)\n", \
       (int)depth*2, "", REG_NODE_NUM(scan), SvPV_nolen_const(mysv),\
       Next ? (REG_NODE_NUM(Next)) : 0 ); \
a3607 1

d3618 8
d3833 1
a3833 1
    if (OP(scan) != EXACT) {
d3925 3
a3927 3
                    /* Count how many characters in it.  In the case of /aa, no
                     * folds which contain ASCII code points are allowed, so
                     * check for those, and skip if found. */
d3974 3
a3983 1
                continue;
d4011 2
a4012 2
                    && isARG2_lower_or_UPPER_ARG1('s', *s)
                    && isARG2_lower_or_UPPER_ARG1('s', *(s+1)))
d4029 1
d4059 11
a4069 11
/* this is a chain of data about sub patterns we are processing that
   need to be handled separately/specially in study_chunk. Its so
   we can simulate recursion without losing state.  */
struct scan_frame;
typedef struct scan_frame {
    regnode *last;  /* last node to process in this frame */
    regnode *next;  /* next node to process when last is reached */
    struct scan_frame *prev; /*previous frame*/
    U32 prev_recursed_depth;
    I32 stop; /* what stopparen do we use */
} scan_frame;
a4088 1
    dVAR;
d4106 1
a4106 3
#ifdef DEBUGGING
    StructCopy(&zero_scan_data, &data_fake, scan_data_t);
#endif
d4114 37
a4156 23
        DEBUG_OPTIMISE_MORE_r(
        {
            PerlIO_printf(Perl_debug_log,
                "%*sstudy_chunk stopparen=%ld depth=%lu recursed_depth=%lu ",
                ((int) depth*2), "", (long)stopparen,
                (unsigned long)depth, (unsigned long)recursed_depth);
            if (recursed_depth) {
                U32 i;
                U32 j;
                for ( j = 0 ; j < recursed_depth ; j++ ) {
                    PerlIO_printf(Perl_debug_log,"[");
                    for ( i = 0 ; i < (U32)RExC_npar ; i++ )
                        PerlIO_printf(Perl_debug_log,"%d",
                            PAREN_TEST(RExC_study_chunk_recursed +
                                       (j * RExC_study_chunk_recursed_bytes), i)
                            ? 1 : 0
                        );
                    PerlIO_printf(Perl_debug_log,"]");
                }
            }
            PerlIO_printf(Perl_debug_log,"\n");
        }
        );
d4161 4
a4164 3
        /* The reason we do this here we need to deal with things like /(?:f)(?:o)(?:o)/
         * which cant be dealt with by the normal EXACT parsing code, as each (?:..) is handled
         * by a different invocation of reg() -- Yves
a4190 2


d4193 31
a4223 2
	if (OP(scan) == BRANCH || OP(scan) == BRANCHJ
		   || OP(scan) == IFTHEN) {
a4225 2
            /* demq: the op(next)==code check is to see if we have
             * "branch-branch" AFAICT */
d4227 5
d4253 2
d4256 1
a4256 1
		    data_fake.flags = 0;
d4266 3
a4268 2
		    scan = NEXTOPER(scan);
		    if (code != BRANCH)
d4270 1
d4283 1
a4408 3
#ifdef DEBUGGING
                        SV * const mysv = sv_newmortal();   /* for dumping */
#endif
d4424 6
a4429 5
                            regprop(RExC_rx, mysv, tail, NULL);
                            PerlIO_printf( Perl_debug_log, "%*s%s%s\n",
                              (int)depth * 2 + 2, "",
                              "Looking for TRIE'able sequences. Tail node is: ",
                              SvPV_nolen_const( mysv )
d4485 2
d4490 13
a4502 5
#define TRIE_TYPE(X) ( ( NOTHING == (X) ) ? NOTHING :   \
                       ( EXACT == (X) )   ? EXACT :        \
                       ( EXACTFU == (X) || EXACTFU_SS == (X) ) ? EXACTFU :        \
                       ( EXACTFA == (X) ) ? EXACTFA :        \
                       0 )
d4511 2
a4512 2
			    U8 noper_next_type = (noper_next && noper_next != tail) ? OP(noper_next) : 0;
			    U8 noper_next_trietype = (noper_next && noper_next != tail) ? TRIE_TYPE( noper_next_type ) :0;
d4516 8
a4523 7
                                regprop(RExC_rx, mysv, cur, NULL);
                                PerlIO_printf( Perl_debug_log, "%*s- %s (%d)",
                                   (int)depth * 2 + 2,"", SvPV_nolen_const( mysv ), REG_NODE_NUM(cur) );

                                regprop(RExC_rx, mysv, noper, NULL);
                                PerlIO_printf( Perl_debug_log, " -> %s",
                                    SvPV_nolen_const(mysv));
d4526 3
a4528 3
                                  regprop(RExC_rx, mysv, noper_next, NULL);
                                  PerlIO_printf( Perl_debug_log,"\t=> %s\t",
                                    SvPV_nolen_const(mysv));
d4530 1
a4530 1
                                PerlIO_printf( Perl_debug_log, "(First==%d,Last==%d,Cur==%d,tt==%s,nt==%s,nnt==%s)\n",
d4541 1
a4541 1
                                        ( noper_trietype == NOTHING)
d4546 1
a4546 1
                                  && noper_next == tail
d4559 1
a4559 1
                                        U8 noper_next_type = (noper_next && noper_next!=tail) ? OP(noper_next) : 0;
d4606 1
a4606 1
                                     && noper_next == tail
d4625 7
a4631 5
                            regprop(RExC_rx, mysv, cur, NULL);
                            PerlIO_printf( Perl_debug_log,
                              "%*s- %s (%d) <SCAN FINISHED>\n",
                              (int)depth * 2 + 2,
                              "", SvPV_nolen_const( mysv ),REG_NODE_NUM(cur));
d4649 1
a4649 1
                                         && scan == tail )
d4667 4
a4670 4
                                        regprop(RExC_rx, mysv, cur, NULL);
                                        PerlIO_printf( Perl_debug_log,
                                          "%*s- %s (%d) <NOTHING BRANCH SEQUENCE>\n", (int)depth * 2 + 2,
                                          "", SvPV_nolen_const( mysv ),REG_NODE_NUM(cur));
d4690 4
a4693 5
	} else if (OP(scan) == SUSPEND || OP(scan) == GOSUB || OP(scan) == GOSTART) {
	    scan_frame *newframe = NULL;
	    I32 paren;
	    regnode *start;
	    regnode *end;
d4696 35
a4730 11
	    if (OP(scan) != SUSPEND) {
                /* set the pointer */
	        if (OP(scan) == GOSUB) {
	            paren = ARG(scan);
	            RExC_recurse[ARG2L(scan)] = scan;
                    start = RExC_open_parens[paren-1];
                    end   = RExC_close_parens[paren-1];
                } else {
                    paren = 0;
                    start = RExC_rxi->program + 1;
                    end   = RExC_opend;
d4732 3
a4734 1
                if (!recursed_depth
d4738 10
d4756 1
a4756 1
	            DEBUG_STUDYDATA("set:", data,depth);
a4758 1
                    Newx(newframe,1,scan_frame);
d4760 1
a4760 1
	            DEBUG_STUDYDATA("inf:", data,depth);
d4771 2
a4774 1
	        Newx(newframe,1,scan_frame);
d4776 1
a4776 1
	        start = scan+2;
d4779 2
a4780 2
	    if (newframe) {
                assert(start);
d4782 18
a4799 5
	        SAVEFREEPV(newframe);
	        newframe->next = regnext(scan);
	        newframe->last = last;
	        newframe->stop = stopparen;
	        newframe->prev = frame;
d4801 1
d4816 1
a4816 1
	else if (OP(scan) == EXACT) {
d4855 1
a4855 1
                ANYOF_FLAGS(data->start_class) &= ~ANYOF_EMPTY_STRING;
d4863 1
a4863 1
                ANYOF_FLAGS(data->start_class) &= ~ANYOF_EMPTY_STRING;
d4867 2
a4868 1
	else if (PL_regkind[OP(scan)] == EXACT) { /* But OP != EXACT! */
d4870 1
a4870 3
	    UV uc = *((U8*)STRING(scan));
            SV* EXACTF_invlist = _new_invlist(4); /* Start out big enough for 2
                                                     separate code points */
a4877 2
		const U8 * const s = (U8 *)STRING(scan);
		uc = utf8_to_uvchr_buf(s, s + l, NULL);
a4895 1
            if (OP(scan) == EXACTFL) {
d4897 4
a4900 9
                /* We don't know what the folds are; it could be anything. XXX
                 * Actually, we only support UTF-8 encoding for code points
                 * above Latin1, so we could know what those folds are. */
                EXACTF_invlist = _add_range_to_invlist(EXACTF_invlist,
                                                       0,
                                                       UV_MAX);
            }
            else {  /* Non-locale EXACTFish */
                EXACTF_invlist = add_cp_to_invlist(EXACTF_invlist, uc);
d4902 5
a4906 1
                    ssc_clear_locale(data->start_class);
d4908 3
a4910 20
                if (uc < 256) { /* We know what the Latin1 folds are ... */
                    if (IS_IN_SOME_FOLD_L1(uc)) {   /* For instance, we
                                                       know if anything folds
                                                       with this */
                        EXACTF_invlist = add_cp_to_invlist(EXACTF_invlist,
                                                           PL_fold_latin1[uc]);
                        if (OP(scan) != EXACTFA) { /* The folds below aren't
                                                      legal under /iaa */
                            if (isARG2_lower_or_UPPER_ARG1('s', uc)) {
                                EXACTF_invlist
                                    = add_cp_to_invlist(EXACTF_invlist,
                                                LATIN_SMALL_LETTER_SHARP_S);
                            }
                            else if (uc == LATIN_SMALL_LETTER_SHARP_S) {
                                EXACTF_invlist
                                    = add_cp_to_invlist(EXACTF_invlist, 's');
                                EXACTF_invlist
                                    = add_cp_to_invlist(EXACTF_invlist, 'S');
                            }
                        }
d4912 2
a4913 31
                        /* We also know if there are above-Latin1 code points
                         * that fold to this (none legal for ASCII and /iaa) */
                        if ((! isASCII(uc) || OP(scan) != EXACTFA)
                            && HAS_NONLATIN1_FOLD_CLOSURE(uc))
                        {
                            /* XXX We could know exactly what does fold to this
                             * if the reverse folds are loaded, as currently in
                             * S_regclass() */
                            _invlist_union(EXACTF_invlist,
                                           PL_AboveLatin1,
                                           &EXACTF_invlist);
                        }
                    }
                }
                else {  /* Non-locale, above Latin1.  XXX We don't currently
                           know what participates in folds with this, so have
                           to assume anything could */

                    /* XXX We could know exactly what does fold to this if the
                     * reverse folds are loaded, as currently in S_regclass().
                     * But we do know that under /iaa nothing in the ASCII
                     * range can participate */
                    if (OP(scan) == EXACTFA) {
                        _invlist_union_complement_2nd(EXACTF_invlist,
                                                      PL_XPosix_ptrs[_CC_ASCII],
                                                      &EXACTF_invlist);
                    }
                    else {
                        EXACTF_invlist = _add_range_to_invlist(EXACTF_invlist,
                                                               0, UV_MAX);
                    }
d4915 2
a4917 14
	    if (flags & SCF_DO_STCLASS_AND) {
                ANYOF_FLAGS(data->start_class) &= ~ANYOF_EMPTY_STRING;
                ANYOF_POSIXL_ZERO(data->start_class);
                ssc_intersection(data->start_class, EXACTF_invlist, FALSE);
	    }
	    else if (flags & SCF_DO_STCLASS_OR) {
                ssc_union(data->start_class, EXACTF_invlist, FALSE);
		ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);

                /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a */
                ANYOF_FLAGS(data->start_class) &= ~ANYOF_EMPTY_STRING;
	    }
	    flags &= ~SCF_DO_STCLASS;
            SvREFCNT_dec(EXACTF_invlist);
d4934 4
a4937 1
		    if (OP(next) == EXACT || (flags & SCF_DO_STCLASS)) {
d4948 1
a4948 1
		/* Fall through. */
d5036 2
a5037 1
                        ANYOF_FLAGS(data->start_class) |= ANYOF_EMPTY_STRING;
d5060 5
a5064 2
		    ckWARNreg(RExC_parse,
			    "Quantifier unexpected on zero-length expression");
d5103 2
a5104 2
			RExC_open_parens[ARG(nxt1)-1]=oscan; /*open->CURLYM*/
			RExC_close_parens[ARG(nxt1)-1]=nxt+2; /*close->while*/
d5150 2
a5151 2
			    RExC_open_parens[ARG(nxt1)-1]=oscan; /*open->CURLYM*/
			    RExC_close_parens[ARG(nxt1)-1]=nxt2+1; /*close->NOTHING*/
d5248 5
a5252 2
			    data->last_start_max += is_inf ? SSize_t_MAX
				: (maxcount - 1) * (minnext + data->pos_delta);
d5258 3
a5260 3
PerlIO_printf(Perl_debug_log, "counted=%"UVdf" deltanext=%"UVdf
                              " SSize_t_MAX=%"UVdf" minnext=%"UVdf
                              " maxcount=%"UVdf" mincount=%"UVdf"\n",
d5264 1
a5264 1
PerlIO_printf(Perl_debug_log, "LHS=%"UVdf" RHS=%"UVdf"\n",
d5339 2
a5340 1
                    ANYOF_FLAGS(data->start_class) &= ~ANYOF_EMPTY_STRING;
d5350 2
a5351 1
                    ANYOF_FLAGS(data->start_class) &= ~ANYOF_EMPTY_STRING;
d5356 2
a5357 1
	    delta++;    /* Because of the 2 char string cr-lf */
d5379 1
a5379 1
                ANYOF_FLAGS(data->start_class) &= ~ANYOF_EMPTY_STRING;
a5389 1
		case CANY:
d5418 2
d5431 1
a5431 1
                    /* FALL THROUGH */
d5472 1
a5472 1
                    /* FALL THROUGH */
d5487 1
a5487 1
                    /* FALL THROUGH */
d5529 2
a5530 28
		   && (OP(scan) == IFMATCH || OP(scan) == UNLESSM)) {
            if ( OP(scan) == UNLESSM &&
                 scan->flags == 0 &&
                 OP(NEXTOPER(NEXTOPER(scan))) == NOTHING &&
                 OP(regnext(NEXTOPER(NEXTOPER(scan)))) == SUCCEED
            ) {
                regnode *opt;
                regnode *upto= regnext(scan);
                DEBUG_PARSE_r({
                    SV * const mysv_val=sv_newmortal();
                    DEBUG_STUDYDATA("OPFAIL",data,depth);

                    /*DEBUG_PARSE_MSG("opfail");*/
                    regprop(RExC_rx, mysv_val, upto, NULL);
                    PerlIO_printf(Perl_debug_log,
                        "~ replace with OPFAIL pointed at %s (%"IVdf") offset %"IVdf"\n",
                        SvPV_nolen_const(mysv_val),
                        (IV)REG_NODE_NUM(upto),
                        (IV)(upto - scan)
                    );
                });
                OP(scan) = OPFAIL;
                NEXT_OFF(scan) = upto - scan;
                for (opt= scan + 1; opt < upto ; opt++)
                    OP(opt) = OPTIMIZED;
                scan= upto;
                continue;
            }
d5543 1
a5543 1
                data_fake.flags = 0;
d5595 2
a5596 1
                        ANYOF_FLAGS(data->start_class) |= ANYOF_EMPTY_STRING;
d5668 1
a5668 1
                    ANYOF_FLAGS(data->start_class) |= ANYOF_EMPTY_STRING;
d5787 1
a5787 1
                    data_fake.flags = 0;
d5850 2
a5851 1
            delta += max1 - min1;
d5911 2
d5915 1
d5917 3
a5919 3
        last = frame->last;
        scan = frame->next;
        stopparen = frame->stop;
a5920 1
        depth = depth - 1;
d5922 2
a5923 1
        frame = frame->prev;
d5956 5
a5960 2
        if (!(RExC_seen & REG_UNBOUNDED_QUANTIFIER_SEEN) && (RExC_maxlen < final_minlen + delta)) {
            RExC_maxlen = final_minlen + delta;
d5964 1
a5964 1
    /* not-reached */
d5986 2
a5987 1
/*XXX: todo make this not included in a non debugging perl */
a5991 1
    dVAR;
a6044 2
    dVAR;

a6070 1
    dVAR;
d6078 1
a6078 1
	PerlIO_printf(Perl_debug_log, "Using engine %"UVxf"\n",
d6117 1
a6117 1
    U8 *dst;
d6119 1
a6119 1
    STRLEN s = 0, d = 0;
d6123 1
a6123 1
    DEBUG_PARSE_r(PerlIO_printf(Perl_debug_log,
d6127 1
d6130 1
a6130 6
        if (NATIVE_BYTE_IS_INVARIANT(src[s]))
            dst[d]   = src[s];
        else {
            dst[d++] = UTF8_EIGHT_BIT_HI(src[s]);
            dst[d]   = UTF8_EIGHT_BIT_LO(src[s]);
        }
d6133 2
a6134 2
                pRExC_state->code_blocks[n].start = d;
                assert(dst[d] == '(');
d6138 2
a6139 2
                pRExC_state->code_blocks[n].end = d;
                assert(dst[d] == ')');
a6144 1
        d++;
d6146 2
a6147 2
    dst[d] = '\0';
    *plen_p = d;
d6181 1
a6181 1
        pat = newSVpvn("", 0);
d6217 1
a6217 1
                oplist = oplist->op_sibling;;
d6264 1
a6264 1
                oplist = oplist->op_sibling; /* skip CONST */
d6267 1
a6267 1
            oplist = oplist->op_sibling;;
d6387 2
d6491 1
a6491 1
	    PerlIO_printf(Perl_debug_log,
a6703 1
    dVAR;
a6739 1
#ifndef PERL_IN_XSUB_RE
d6743 4
d6753 15
a6768 1
#endif
d6782 1
a6782 1
	for (o = cLISTOPx(expr)->op_first; o; o = o->op_sibling)
d6803 1
a6803 1
            for (o = cLISTOPx(expr)->op_first; o; o = o->op_sibling) {
d6819 1
a6819 1
            for (o = cLISTOPx(expr)->op_first; o; o = o->op_sibling) {
d6826 1
a6826 1
    DEBUG_PARSE_r(PerlIO_printf(Perl_debug_log,
d6839 1
a6839 1
            expr = expr->op_sibling;
d6855 1
a6855 1
            DEBUG_PARSE_r(PerlIO_printf(Perl_debug_log,
d6880 1
d6882 1
d6885 1
d6887 3
d6891 4
d6898 1
a6898 1
            PerlIO_printf(Perl_debug_log, "%sCompiling REx%s %s\n",
d6903 2
a6904 2
    /* we jump here if we upgrade the pattern to utf8 and have to
     * recompile */
d6938 3
a6940 1
    if (RExC_utf8 && initial_charset == REGEX_DEPENDS_CHARSET) {
d6948 1
d6953 2
a6954 1
	if (TAINTING_get && TAINT_get)
d6975 3
d6982 1
a6982 1
    RExC_start = exp;
d6984 1
d6993 1
a6993 1
    RExC_opend = NULL;
d7004 9
a7012 4
#if 0 /* REGC() is (currently) a NOP at the first pass.
       * Clever compilers notice this and complain. --jhi */
    REGC((U8)REG_MAGIC, (char*)RExC_emit);
#endif
d7014 1
a7014 1
	PerlIO_printf(Perl_debug_log, "Starting first pass (sizing)\n");
d7038 3
a7040 2
        if (flags & RESTART_UTF8) {
            S_pat_upgrade_to_utf8(aTHX_ pRExC_state, &exp, &plen,
d7042 6
d7056 1
a7056 1
        PerlIO_printf(Perl_debug_log,
d7114 2
a7115 1
	SAVEFREEPV(pRExC_state->code_blocks);
d7130 1
a7130 1
	U16 reganch = (U16)((r->extflags & RXf_PMf_STD_PMMOD)
d7132 1
a7132 1
	const char *fptr = STD_PAT_MODS;        /*"msix"*/
d7134 3
a7136 6
        /* Allocate for the worst case, which is all the std flags are turned
         * on.  If more precision is desired, we could do a population count of
         * the flags set.  This could be done with a small lookup table, or by
         * shifting, masking and adding, or even, when available, assembly
         * language for a machine-language population count.
         * We never output a minus, as all those are defaults, so are
d7140 1
a7143 1
            + (sizeof(STD_PAT_MODS) - 1)
d7146 3
a7190 18
    /* setup various meta data about recursion, this all requires
     * RExC_npar to be correctly set, and a bit later on we clear it */
    if (RExC_seen & REG_RECURSE_SEEN) {
        Newxz(RExC_open_parens, RExC_npar,regnode *);
        SAVEFREEPV(RExC_open_parens);
        Newxz(RExC_close_parens,RExC_npar,regnode *);
        SAVEFREEPV(RExC_close_parens);
    }
    if (RExC_seen & (REG_RECURSE_SEEN | REG_GOSTART_SEEN)) {
        /* Note, RExC_npar is 1 + the number of parens in a pattern.
         * So its 1 if there are no parens. */
        RExC_study_chunk_recursed_bytes= (RExC_npar >> 3) +
                                         ((RExC_npar & 0x07) != 0);
        Newx(RExC_study_chunk_recursed,
             RExC_study_chunk_recursed_bytes * RExC_npar, U8);
        SAVEFREEPV(RExC_study_chunk_recursed);
    }

d7194 1
a7194 1
    DEBUG_OFFSETS_r(PerlIO_printf(Perl_debug_log,
a7209 1
    RExC_npar = 1;
d7215 32
a7246 1
    REGC((U8)REG_MAGIC, (char*) RExC_emit++);
d7251 4
d7263 1
a7263 1
reStudy:
d7265 3
d7269 1
a7269 1
    if (RExC_study_chunk_recursed)
d7272 2
d7281 1
a7281 1
        DEBUG_OPTIMISE_r(PerlIO_printf(Perl_debug_log,"Restudying\n"));
d7301 1
a7301 1
    if (RExC_naughty >= 10)	/* Probably an expensive pattern. */
d7360 1
a7360 1
	    if (OP(first) == EXACT)
d7369 2
a7370 16
	    regnode *trie_op;
	    /* this can happen only on restudy */
	    if ( OP(first) == TRIE ) {
                struct regnode_1 *trieop = (struct regnode_1 *)
		    PerlMemShared_calloc(1, sizeof(struct regnode_1));
                StructCopy(first,trieop,struct regnode_1);
                trie_op=(regnode *)trieop;
            } else {
                struct regnode_charclass *trieop = (struct regnode_charclass *)
		    PerlMemShared_calloc(1, sizeof(struct regnode_charclass));
                StructCopy(first,trieop,struct regnode_charclass);
                trie_op=(regnode *)trieop;
            }
            OP(trie_op)+=2;
            make_trie_failtable(pRExC_state, (regnode *)first, trie_op, 0);
	    ri->regstclass = trie_op;
d7381 1
a7381 3
			   : (OP(first) == SBOL
                              ? PREGf_ANCH_SBOL
                              : PREGf_ANCH_BOL));
d7391 1
d7415 1
a7415 1
	        PerlIO_printf(Perl_debug_log, "first at %"IVdf"\n",
d7420 1
a7420 1
	    PerlIO_printf(Perl_debug_log, "first at %"IVdf"\n",
d7534 2
a7535 2
            && ! (ANYOF_FLAGS(data.start_class) & ANYOF_EMPTY_STRING)
	    && !ssc_is_anything(data.start_class))
d7548 2
a7549 2
	              regprop(r, sv, (regnode*)data.start_class, NULL);
		      PerlIO_printf(Perl_debug_log,
d7594 1
a7594 1
	DEBUG_PARSE_r(PerlIO_printf(Perl_debug_log, "\nMulti Top Level\n"));
d7614 2
a7615 2
        if (! (ANYOF_FLAGS(data.start_class) & ANYOF_EMPTY_STRING)
            && ! ssc_is_anything(data.start_class))
d7628 2
a7629 2
	              regprop(r, sv, (regnode*)data.start_class, NULL);
		      PerlIO_printf(Perl_debug_log,
d7647 2
a7648 2
        PerlIO_printf(Perl_debug_log,"minlen: %"IVdf" r->minlen:%"IVdf" maxlen:%ld\n",
                      (IV)minlen, (IV)r->minlen, RExC_maxlen);
d7654 4
a7664 2
    if (RExC_seen & REG_CANY_SEEN)
        r->intflags |= PREGf_CANY_SEEN;
d7695 1
a7695 1
        regnode *next = NEXTOPER(first);
d7700 6
a7705 1
        else if (PL_regkind[fop] == BOL && nop == END)
d7709 1
a7709 1
                 && OP(regnext(first)) == END)
d7712 1
a7712 1
                  && fop == EXACT
d7715 1
a7715 1
                  && OP(regnext(first)) == END )
d7731 1
a7731 1
        ri->name_list_idx = 0;
d7733 3
a7735 5
    if (RExC_recurse_count) {
        for ( ; RExC_recurse_count ; RExC_recurse_count-- ) {
            const regnode *scan = RExC_recurse[RExC_recurse_count-1];
            ARG2L_SET( scan, RExC_open_parens[ARG(scan)-1] - scan );
        }
d7737 1
d7740 4
a7743 1

d7746 1
a7746 1
        PerlIO_printf(Perl_debug_log,"Final program:\n");
d7754 1
a7754 1
        PerlIO_printf(Perl_debug_log,
d7758 1
a7758 1
                PerlIO_printf(Perl_debug_log, "%"UVuf":%"UVuf"[%"UVuf"] ",
d7761 1
a7761 1
        PerlIO_printf(Perl_debug_log, "\n");
d8075 1
a8075 5
        if ( (rx->intflags & PREGf_CANY_SEEN)
            ? (RXp_MATCH_UTF8(rx)
                        && (!i || is_utf8_string((U8*)s, i)))
            : (RXp_MATCH_UTF8(rx)) )
        {
a8076 1
        }
d8233 2
a8234 1
	 /* skip IDFIRST by using do...while */
d8271 1
a8271 1
        assert(0); /* NOT REACHED */
a8276 2
    int rem=(int)(RExC_end - RExC_parse);                       \
    int cut;                                                    \
d8278 11
a8288 11
    int iscut=0;                                                \
    if (rem>10) {                                               \
        rem=10;                                                 \
        iscut=1;                                                \
    }                                                           \
    cut=10-rem;                                                 \
    if (RExC_lastparse!=RExC_parse)                             \
        PerlIO_printf(Perl_debug_log," >%.*s%-*s",              \
            rem, RExC_parse,                                    \
            cut + 4,                                            \
            iscut ? "..." : "<"                                 \
d8290 2
a8291 2
    else                                                        \
        PerlIO_printf(Perl_debug_log,"%16s","");                \
d8298 1
a8298 1
       PerlIO_printf(Perl_debug_log,"|%4d",num);                \
d8300 2
a8301 2
       PerlIO_printf(Perl_debug_log,"|%4s","");                 \
    PerlIO_printf(Perl_debug_log,"|%*s%-4s",                    \
d8313 1
a8313 1
    PerlIO_printf(Perl_debug_log,"%4s","\n");               \
d8315 1
a8315 1
#define DEBUG_PARSE_FMT(funcname,fmt,args)     DEBUG_PARSE_r({           \
d8317 1
a8317 1
    PerlIO_printf(Perl_debug_log,fmt "\n",args);               \
d8362 1
a8362 1
/* The header definitions are in F<inline_invlist.c> */
d8365 1
a8365 1
S__invlist_array_init(pTHX_ SV* const invlist, const bool will_have_0)
a8389 21
PERL_STATIC_INLINE UV*
S_invlist_array(pTHX_ SV* const invlist)
{
    /* Returns the pointer to the inversion list's array.  Every time the
     * length changes, this needs to be called in case malloc or realloc moved
     * it */

    PERL_ARGS_ASSERT_INVLIST_ARRAY;

    /* Must not be empty.  If these fail, you probably didn't check for <len>
     * being non-zero before trying to get the array */
    assert(_invlist_len(invlist));

    /* The very first element always contains zero, The array begins either
     * there, or if the inversion list is offset, at the element after it.
     * The offset header field determines which; it contains 0 or 1 to indicate
     * how much additionally to add */
    assert(0 == *(SvPVX(invlist)));
    return ((UV *) SvPVX(invlist) + *get_invlist_offset_addr(invlist));
}

d8395 1
a8395 1

d8407 48
d8456 1
a8456 1
S_get_invlist_previous_index_addr(pTHX_ SV* invlist)
a8459 1

d8468 1
a8468 1
S_invlist_previous_index(pTHX_ SV* const invlist)
d8478 1
a8478 1
S_invlist_set_previous_index(pTHX_ SV* const invlist, const IV index)
d8489 37
d8527 1
a8527 1
S_invlist_max(pTHX_ SV* const invlist)
a8644 12
PERL_STATIC_INLINE void
S_invlist_trim(pTHX_ SV* const invlist)
{
    PERL_ARGS_ASSERT_INVLIST_TRIM;

    assert(SvTYPE(invlist) == SVt_INVLIST);

    /* Change the length of the inversion list to how many entries it currently
     * has */
    SvPV_shrink_to_cur((SV *) invlist);
}

d8733 1
a8733 1
Perl__invlist_search(pTHX_ SV* const invlist, const UV cp)
d8738 3
a8740 1
     * contains <cp> */
d8759 4
a8762 1
    assert(mid >=0 && mid <= highest_element);
d8826 2
a8827 2
Perl__invlist_populate_swatch(pTHX_ SV* const invlist,
                                    const UV start, const UV end, U8* swatch)
d8894 1
a8894 1
    join_end_of_list:
d8926 4
a8929 4
     * temporary (mortal); otherwise *output will be made correspondingly
     * mortal.  The first list, <a>, may be NULL, in which case a copy of the
     * second list is returned.  If <complement_b> is TRUE, the union is taken
     * of the complement (inversion) of <b> instead of b itself.
d8951 1
a8951 1
    UV len_u;
d8968 10
a8977 3
    /* If either one is empty, the union is the other one */
    if (a == NULL || ((len_a = _invlist_len(a)) == 0)) {
        bool make_temp = FALSE; /* Should we mortalize the result? */
d8979 4
a8982 5
	if (*output == a) {
            if (a != NULL) {
                if (! (make_temp = cBOOL(SvTEMP(a)))) {
                    SvREFCNT_dec_NN(a);
                }
d8984 29
a9012 5
	}
	if (*output != b) {
	    *output = invlist_clone(b);
            if (complement_b) {
                _invlist_invert(*output);
a9013 1
	} /* else *output already = b; */
d9015 3
a9017 2
        if (make_temp) {
            sv_2mortal(*output);
d9019 6
d9027 12
a9038 5
    else if ((len_b = _invlist_len(b)) == 0) {
        bool make_temp = FALSE;
	if (*output == b) {
            if (! (make_temp = cBOOL(SvTEMP(b)))) {
                SvREFCNT_dec_NN(b);
a9039 1
	}
d9041 3
a9043 7
        /* The complement of an empty list is a list that has everything in it,
         * so the union with <a> includes everything too */
        if (complement_b) {
            if (a == *output) {
                if (! (make_temp = cBOOL(SvTEMP(a)))) {
                    SvREFCNT_dec_NN(a);
                }
d9045 2
a9046 2
            *output = _new_invlist(1);
            _append_range_to_invlist(*output, 0, UV_MAX);
d9048 6
a9053 2
        else if (*output != a) {
            *output = invlist_clone(a);
d9055 5
a9059 1
        /* else *output already = a; */
d9061 2
a9062 2
        if (make_temp) {
            sv_2mortal(*output);
d9064 1
d9130 1
a9130 1
	 * beginning/end of a range in that's in the set */
d9164 1
a9164 1
    if ((i_a != len_a && PREV_RANGE_MATCHES_INVLIST(i_a))
d9180 3
a9182 2
    /* Set result to final length, which can change the pointer to array_u, so
     * re-find it */
d9192 1
a9192 1
     * non-exhausted list, so can just copy it unchanged.  (If both list were
d9205 14
a9218 4
    /*  We may be removing a reference to one of the inputs.  If so, the output
     *  is made mortal if the input was.  (Mortal SVs shouldn't have their ref
     *  count decremented) */
    if (a == *output || b == *output) {
d9220 4
a9223 2
        if ((SvTEMP(*output))) {
            sv_2mortal(u);
d9226 2
a9227 1
            SvREFCNT_dec_NN(*output);
a9230 2
    *output = u;

d9241 5
a9245 5
     * temporary (mortal); otherwise *i will be made correspondingly mortal.
     * The first list, <a>, may be NULL, in which case an empty list is
     * returned.  If <complement_b> is TRUE, the result will be the
     * intersection of <a> and the complement (or inversion) of <b> instead of
     * <b> directly.
d9263 1
a9263 1
    UV len_r;
d9283 1
a9283 1
        bool make_temp = FALSE;
d9285 4
a9288 1
        if (len_a != 0 && complement_b) {
d9290 3
a9292 10
            /* Here, 'a' is not empty, therefore from the above 'if', 'b' must
             * be empty.  Here, also we are using 'b's complement, which hence
             * must be every possible code point.  Thus the intersection is
             * simply 'a'. */
            if (*i != a) {
                if (*i == b) {
                    if (! (make_temp = cBOOL(SvTEMP(b)))) {
                        SvREFCNT_dec_NN(b);
                    }
                }
d9294 2
d9297 1
a9298 1
            /* else *i is already 'a' */
d9300 4
a9303 3
            if (make_temp) {
                sv_2mortal(*i);
            }
d9309 3
a9311 13
	if (*i == a) {
            if (! (make_temp = cBOOL(SvTEMP(a)))) {
                SvREFCNT_dec_NN(a);
            }
	}
	else if (*i == b) {
            if (! (make_temp = cBOOL(SvTEMP(b)))) {
                SvREFCNT_dec_NN(b);
            }
	}
	*i = _new_invlist(0);
        if (make_temp) {
            sv_2mortal(*i);
d9314 1
d9412 1
a9412 1
    if ((i_a == len_a && PREV_RANGE_MATCHES_INVLIST(i_a))
d9426 3
a9428 2
    /* Set result to final length, which can change the pointer to array_r, so
     * re-find it */
d9446 15
a9460 4
    /*  We may be removing a reference to one of the inputs.  If so, the output
     *  is made mortal if the input was.  (Mortal SVs shouldn't have their ref
     *  count decremented) */
    if (a == *i || b == *i) {
d9462 4
a9465 2
        if (SvTEMP(*i)) {
            sv_2mortal(r);
d9468 7
a9474 1
            SvREFCNT_dec_NN(*i);
a9477 2
    *i = r;

d9487 1
a9487 1
     * passed in inversion list can be NULL, in which case a new one is created
d9512 7
a9518 1
     * which is the union of this range and the existing inversion list */
d9612 1
a9612 1
S_get_invlist_iter_addr(pTHX_ SV* invlist)
d9625 1
a9625 1
S_invlist_iterinit(pTHX_ SV* invlist)	/* Initialize iterator for invlist */
d9633 1
a9633 1
S_invlist_iterfinish(pTHX_ SV* invlist)
d9649 1
a9649 1
S_invlist_iternext(pTHX_ SV* invlist, UV* start, UV* end)
a9682 8
PERL_STATIC_INLINE bool
S_invlist_is_iterating(pTHX_ SV* const invlist)
{
    PERL_ARGS_ASSERT_INVLIST_IS_ITERATING;

    return *(get_invlist_iter_addr(invlist)) < (STRLEN) UV_MAX;
}

d9684 1
a9684 1
S_invlist_highest(pTHX_ SV* const invlist)
d9713 2
a9714 3
#ifndef PERL_IN_XSUB_RE
SV *
Perl__invlist_contents(pTHX_ SV* const invlist)
d9717 4
a9720 2
     * be printed out.  It uses the format traditionally done for debug tracing
     */
d9723 10
a9732 1
    SV* output = newSVpvs("\n");
d9734 1
a9734 1
    PERL_ARGS_ASSERT__INVLIST_CONTENTS;
d9741 3
a9743 1
	    Perl_sv_catpvf(aTHX_ output, "%04"UVXf"\tINFINITY\n", start);
d9746 4
a9749 2
	    Perl_sv_catpvf(aTHX_ output, "%04"UVXf"\t%04"UVXf"\n",
		    start,       end);
d9752 2
a9753 1
	    Perl_sv_catpvf(aTHX_ output, "%04"UVXf"\n", start);
d9757 4
a9762 1
#endif
d9814 17
d9833 1
a9833 1
#ifdef PERL_ARGS_ASSERT__INVLISTEQ
d9835 1
a9835 1
S__invlistEQ(pTHX_ SV* const a, SV* const b, const bool complement_b)
d9895 150
a10044 4
#undef HEADER_LENGTH
#undef TO_INTERNAL_SIZE
#undef FROM_INTERNAL_SIZE
#undef INVLIST_VERSION_ID
d10071 1
d10092 1
a10092 1
    while (*RExC_parse) {
d10098 2
a10099 2
            /* Code for the imsx flags */
            CASE_STD_PMMOD_FLAGS_PARSE_SET(flagsp);
d10157 1
a10157 1
            excess_modifier:
d10169 2
a10170 2
                /*NOTREACHED*/
            neg_modifier:
d10174 1
a10174 1
                /*NOTREACHED*/
d10177 1
a10177 1
                if (SIZE_ONLY && ckWARN(WARN_REGEXP)) {
d10197 1
a10197 1
                if (SIZE_ONLY && ckWARN(WARN_REGEXP)) {
d10212 1
a10212 1
                    if (SIZE_ONLY)
d10236 3
d10242 2
a10243 2
            fail_modifiers:
                RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;
d10247 1
a10247 1
                /*NOTREACHED*/
d10250 1
a10250 1
        ++RExC_parse;
d10252 2
d10272 48
d10321 4
a10324 4
   flags. Returns NULL, setting *flagp to RESTART_UTF8 if the sizing scan
   needs to be restarted.
   Otherwise would only return NULL if regbranch() returns NULL, which
   cannot happen.  */
a10331 1
    dVAR;
d10343 1
d10355 7
d10372 4
d10377 2
a10378 2
	    char *start_verb = RExC_parse;
	    STRLEN verb_len = 0;
d10381 2
a10382 3
	    int argok = 1;
            int internal_argval = 0; /* internal_argval is only useful if
                                        !argok */
d10384 3
a10386 2
            if (has_intervening_patws && SIZE_ONLY) {
                ckWARNregdep(RExC_parse + 1, "In '(*VERB...)', splitting the initial '(*' is deprecated");
d10388 1
a10388 1
	    while ( *RExC_parse && *RExC_parse != ')' ) {
d10393 1
a10393 1
	        RExC_parse++;
a10394 1
	    ++start_verb;
d10397 8
a10404 4
	        RExC_parse++;
	        while ( *RExC_parse && *RExC_parse != ')' )
	            RExC_parse++;
	        if ( *RExC_parse != ')' )
d10409 1
a10409 1
	        if ( *RExC_parse != ')' )
d10413 2
a10428 1
		    argok = 0;
d10435 1
a10435 1
                    argok = -1;
d10460 24
a10483 30
	    if ( argok ) {
                if ( start_arg && internal_argval ) {
	            vFAIL3("Verb pattern '%.*s' may not have an argument",
	                verb_len, start_verb);
	        } else if ( argok < 0 && !start_arg ) {
                    vFAIL3("Verb pattern '%.*s' has a mandatory argument",
	                verb_len, start_verb);
	        } else {
	            ret = reganode(pRExC_state, op, internal_argval);
	            if ( ! internal_argval && ! SIZE_ONLY ) {
                        if (start_arg) {
                            SV *sv = newSVpvn( start_arg,
                                               RExC_parse - start_arg);
                            ARG(ret) = add_data( pRExC_state,
                                                 STR_WITH_LEN("S"));
                            RExC_rxi->data->data[ARG(ret)]=(void*)sv;
                            ret->flags = 0;
                        } else {
                            ret->flags = 1;
                        }
                    }
	        }
	        if (!internal_argval)
                    RExC_seen |= REG_VERBARG_SEEN;
	    } else if ( start_arg ) {
	        vFAIL3("Verb pattern '%.*s' may not have an argument",
	                verb_len, start_verb);
	    } else {
	        ret = reg_node(pRExC_state, op);
	    }
d10490 4
a10493 2
            if (has_intervening_patws && SIZE_ONLY) {
                ckWARNregdep(RExC_parse + 1, "In '(?...)', splitting the initial '(?' is deprecated");
d10496 7
a10502 2
	    RExC_parse++;
	    paren = *RExC_parse++;
d10507 6
a10512 2
	        paren = *RExC_parse++;
		if ( paren == '<')         /* (?P<...>) named capture */
d10514 1
d10516 4
d10523 3
a10525 35
                    /* this pretty much dupes the code for \k<NAME> in
                     * regatom(), if you change this make sure you change that
                     * */
                    char* name_start = RExC_parse;
		    U32 num = 0;
                    SV *sv_dat = reg_scan_name(pRExC_state,
                        SIZE_ONLY ? REG_RSN_RETURN_NULL : REG_RSN_RETURN_DATA);
                    if (RExC_parse == name_start || *RExC_parse != ')')
                        /* diag_listed_as: Sequence ?P=... not terminated in regex; marked by <-- HERE in m/%s/ */
                        vFAIL2("Sequence %.3s... not terminated",parse_start);

                    if (!SIZE_ONLY) {
                        num = add_data( pRExC_state, STR_WITH_LEN("S"));
                        RExC_rxi->data->data[num]=(void*)sv_dat;
                        SvREFCNT_inc_simple_void(sv_dat);
                    }
                    RExC_sawback = 1;
		    ret = reganode(pRExC_state,
				   ((! FOLD)
				     ? NREF
				     : (ASCII_FOLD_RESTRICTED)
				       ? NREFFA
                                       : (AT_LEAST_UNI_SEMANTICS)
                                         ? NREFFU
                                         : (LOC)
                                           ? NREFFL
                                           : NREFF),
				    num);
                    *flagp |= HASWIDTH;

                    Set_Node_Offset(ret, parse_start+1);
                    Set_Node_Cur_Length(ret, parse_start);

                    nextchar(pRExC_state);
                    return ret;
d10527 1
a10527 1
                RExC_parse++;
d10531 1
a10531 1
		/*NOTREACHED*/
d10541 1
d10543 2
a10544 2
    		    name_start= RExC_parse;
    		    svname = reg_scan_name(pRExC_state,
d10548 4
a10551 1
		    if (RExC_parse == name_start || *RExC_parse != paren)
d10554 1
d10622 2
d10629 3
d10633 1
a10633 1
	            ret=reg_node(pRExC_state, OPFAIL);
a10650 12
            case '#':           /* (?#...) */
                /* XXX As soon as we disallow separating the '?' and '*' (by
                 * spaces or (?#...) comment), it is believed that this case
                 * will be unreachable and can be removed.  See
                 * [perl #117327] */
                while (*RExC_parse && *RExC_parse != ')')
		    RExC_parse++;
		if (*RExC_parse != ')')
		    FAIL("Sequence (?#... not terminated");
		nextchar(pRExC_state);
		*flagp = TRYAGAIN;
		return NULL;
d10653 1
a10653 1
		if (*RExC_parse != ')')
d10655 2
a10656 2
		ret = reg_node(pRExC_state, GOSTART);
                    RExC_seen |= REG_GOSTART_SEEN;
d10658 1
a10658 2
		nextchar(pRExC_state);
		return ret;
d10660 1
a10660 2
            { /* named and numeric backreferences */
                I32 num;
d10669 1
a10669 1
                if (RExC_parse == RExC_end || *RExC_parse != ')')
d10672 1
a10672 1
                assert(0); /* NOT REACHED */
d10679 1
a10679 1
                /* NOT REACHED*/
d10685 1
a10685 1
                /*FALLTHROUGH */
d10688 1
a10688 1
	        RExC_parse--;
d10690 20
a10709 6
		num = atoi(RExC_parse);
  	        parse_start = RExC_parse - 1; /* MJD */
	        if (*RExC_parse == '-')
	            RExC_parse++;
		while (isDIGIT(*RExC_parse))
			RExC_parse++;
d10734 8
d10743 1
a10743 1
                ret = reganode(pRExC_state, GOSUB, num);
d10749 4
a10752 4
	            ARG2L_SET( ret, RExC_recurse_count++);
                    RExC_emit++;
		    DEBUG_OPTIMISE_MORE_r(PerlIO_printf(Perl_debug_log,
			"Recurse #%"UVuf" to %"IVdf"\n",
d10754 3
a10756 4
		} else {
		    RExC_size++;
    		}
                    RExC_seen |= REG_RECURSE_SEEN;
d10761 1
d10764 2
a10765 2
            } /* named and numeric backreferences */
            assert(0); /* NOT REACHED */
d10770 1
a10770 1
		    RExC_parse++;
d10775 1
a10775 1
		    /*NOTREACHED*/
d10778 3
a10780 2
		paren = *RExC_parse++;
		/* FALL THROUGH */
d10821 8
a10828 1
                    eval = reganode(pRExC_state, EVAL, n);
a10830 2
                        /* for later propagation into (??{}) return value */
                        eval->flags = (U8) (RExC_flags & RXf_PMf_COMPILETIME);
d10836 1
a10836 1
		ret = reganode(pRExC_state, EVAL, n);
d10844 1
d10846 6
a10851 3
		    if (RExC_parse[1] == '=' || RExC_parse[1] == '!'
			|| RExC_parse[1] == '<'
			|| RExC_parse[1] == '{') { /* Lookahead or eval. */
d10860 2
a10861 2
                        if (flag & RESTART_UTF8) {
                            *flagp = RESTART_UTF8;
d10867 2
d10878 4
a10881 1
	            if (RExC_parse == name_start || *RExC_parse != ch)
d10884 1
d10894 3
a10896 7
		else if (RExC_parse[0] == 'D' &&
		         RExC_parse[1] == 'E' &&
		         RExC_parse[2] == 'F' &&
		         RExC_parse[3] == 'I' &&
		         RExC_parse[4] == 'N' &&
		         RExC_parse[5] == 'E')
		{
d10898 1
a10898 1
		    RExC_parse +=6 ;
d10904 4
d10909 13
a10921 4
		    if (RExC_parse[0] >= '1' && RExC_parse[0] <= '9' ) {
		        parno = atoi(RExC_parse++);
		        while (isDIGIT(*RExC_parse))
			    RExC_parse++;
d10929 13
a10941 1
    		        parno = sv_dat ? *((I32 *)SvPVX(sv_dat)) : 0;
d10949 10
a10958 5
		    char *tmp;
		    parno = atoi(RExC_parse++);

		    while (isDIGIT(*RExC_parse))
			RExC_parse++;
d10962 1
a10962 5
		    if (*(tmp = nextchar(pRExC_state)) != ')') {
                        /* nextchar also skips comments, so undo its work
                         * and skip over the the next character.
                         */
                        RExC_parse = tmp;
d10966 1
d10971 2
a10972 2
                        if (flags & RESTART_UTF8) {
                            *flagp = RESTART_UTF8;
d10980 2
a10981 1
		    c = *nextchar(pRExC_state);
d10992 2
a10993 2
                            if (flags & RESTART_UTF8) {
                                *flagp = RESTART_UTF8;
d11002 2
a11003 1
			c = *nextchar(pRExC_state);
d11007 6
a11012 2
		    if (c != ')')
			vFAIL("Switch (?(condition)... contains too many branches");
d11026 2
a11027 4
		else {
                    RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;
                    vFAIL("Unknown switch condition (?(...))");
		}
d11032 1
a11032 1
            case 0:
d11037 1
a11037 1
	        --RExC_parse;
d11041 2
a11042 1
                    nextchar(pRExC_state);
d11052 1
a11052 1
	else {                  /* (...) */
d11061 1
a11061 2
                if (RExC_seen & REG_RECURSE_SEEN
	            && !RExC_open_parens[parno-1])
d11063 3
a11065 2
		    DEBUG_OPTIMISE_MORE_r(PerlIO_printf(Perl_debug_log,
			"Setting open paren #%"IVdf" to %d\n",
d11067 1
a11067 1
	            RExC_open_parens[parno-1]= ret;
d11073 4
d11090 2
a11091 2
        if (flags & RESTART_UTF8) {
            *flagp = RESTART_UTF8;
d11137 2
a11138 2
            if (flags & RESTART_UTF8) {
                *flagp = RESTART_UTF8;
d11156 5
a11160 5
            if (!SIZE_ONLY && RExC_seen & REG_RECURSE_SEEN) {
		DEBUG_OPTIMISE_MORE_r(PerlIO_printf(Perl_debug_log,
			"Setting close paren #%"IVdf" to %d\n",
			(IV)parno, REG_NODE_NUM(ender)));
	        RExC_close_parens[parno-1]= ender;
d11172 1
a11172 1
	    /* FALL THROUGH */
d11179 9
a11187 2
                assert(!RExC_opend); /* there can only be one! */
                RExC_opend = ender;
a11191 2
            SV * const mysv_val1=sv_newmortal();
            SV * const mysv_val2=sv_newmortal();
d11193 4
a11196 4
            regprop(RExC_rx, mysv_val1, lastbr, NULL);
            regprop(RExC_rx, mysv_val2, ender, NULL);
            PerlIO_printf(Perl_debug_log, "~ tying lastbr %s (%"IVdf") to ender %s (%"IVdf") offset %"IVdf"\n",
                          SvPV_nolen_const(mysv_val1),
d11198 1
a11198 1
                          SvPV_nolen_const(mysv_val2),
a11230 2
                    SV * const mysv_val1=sv_newmortal();
                    SV * const mysv_val2=sv_newmortal();
d11232 4
a11235 4
                    regprop(RExC_rx, mysv_val1, ret, NULL);
                    regprop(RExC_rx, mysv_val2, ender, NULL);
                    PerlIO_printf(Perl_debug_log, "~ converting ret %s (%"IVdf") to ender %s (%"IVdf") offset %"IVdf"\n",
                                  SvPV_nolen_const(mysv_val1),
d11237 1
a11237 1
                                  SvPV_nolen_const(mysv_val2),
d11276 2
a11277 1
        /* restore original flags, but keep (?p) */
d11279 4
a11282 1
	if (RExC_parse >= RExC_end || *nextchar(pRExC_state) != ')') {
d11286 1
d11295 1
a11295 1
	assert(0); /* NOTREACHED */
d11311 2
a11312 2
 * Returns NULL, setting *flagp to RESTART_UTF8 if the sizing scan needs to be
 * restarted.
a11316 1
    dVAR;
d11343 2
a11344 2
    RExC_parse--;
    nextchar(pRExC_state);
d11351 2
a11352 2
            if (flags & RESTART_UTF8) {
                *flagp = RESTART_UTF8;
d11363 3
a11365 1
	    RExC_naughty++;
d11394 2
a11395 2
 * Returns NULL, setting *flagp to RESTART_UTF8 if the sizing scan needs to be
 * restarted.
a11399 1
    dVAR;
d11411 1
d11424 2
a11425 2
	if (flags & (TRYAGAIN|RESTART_UTF8))
	    *flagp |= flags & (TRYAGAIN|RESTART_UTF8);
d11433 1
a11433 1
    if (op == '{' && regcurly(RExC_parse, FALSE)) {
d11449 1
d11453 9
a11461 1
	    min = atoi(RExC_parse);
d11466 7
a11472 2
	    max = atoi(maxpos);
	    if (!max && *maxpos != '0')
d11474 1
a11474 2
	    else if (max >= REG_INFTY)
		vFAIL2("Quantifier in {,} bigger than %d", REG_INFTY - 1);
a11479 1
                    ckWARNreg(RExC_parse, "Quantifier {n,m} with n > m can't match");
d11483 1
a11483 1
                     * away, but we can shrink it by the ammount we are about
d11485 1
a11485 1
                    RExC_size = PREVOPER(RExC_size) - regarglen[(U8)OPFAIL];
d11488 1
d11491 1
a11491 1
                ret = reg_node(pRExC_state, OPFAIL);
d11494 1
a11494 1
            else if (min == max && RExC_parse < RExC_end && *RExC_parse == '?')
d11496 1
a11496 1
                if (SIZE_ONLY) {
a11500 3
                /* Absorb the modifier, so later code doesn't see nor use
                    * it */
                nextchar(pRExC_state);
d11503 1
a11503 1
	do_curly:
d11505 15
a11519 1
		RExC_naughty += 2 + RExC_naughty / 2;
d11545 1
a11545 1
		RExC_naughty += 4 + RExC_naughty;	/* compound interest */
d11592 1
a11592 7
    if (op == '*' && (flags&SIMPLE)) {
	reginsert(pRExC_state, STAR, ret, depth+1);
	ret->flags = 0;
	RExC_naughty += 4;
        RExC_seen |= REG_UNBOUNDED_QUANTIFIER_SEEN;
    }
    else if (op == '*') {
a11595 6
    else if (op == '+' && (flags&SIMPLE)) {
	reginsert(pRExC_state, PLUS, ret, depth+1);
	ret->flags = 0;
	RExC_naughty += 3;
        RExC_seen |= REG_UNBOUNDED_QUANTIFIER_SEEN;
    }
d11616 1
a11616 1
    if (RExC_parse < RExC_end && *RExC_parse == '?') {
d11621 1
a11621 2
    else
    if (RExC_parse < RExC_end && *RExC_parse == '+') {
d11632 1
a11632 1
    if (RExC_parse < RExC_end && ISMULT2(RExC_parse)) {
d11641 7
a11647 3
S_grok_bslash_N(pTHX_ RExC_state_t *pRExC_state, regnode** node_p,
                      UV *valuep, I32 *flagp, U32 depth, bool in_char_class,
                      const bool strict   /* Apply stricter parsing rules? */
d11650 75
d11726 1
a11726 48
 /* This is expected to be called by a parser routine that has recognized '\N'
   and needs to handle the rest. RExC_parse is expected to point at the first
   char following the N at the time of the call.  On successful return,
   RExC_parse has been updated to point to just after the sequence identified
   by this routine, and <*flagp> has been updated.

   The \N may be inside (indicated by the boolean <in_char_class>) or outside a
   character class.

   \N may begin either a named sequence, or if outside a character class, mean
   to match a non-newline.  For non single-quoted regexes, the tokenizer has
   attempted to decide which, and in the case of a named sequence, converted it
   into one of the forms: \N{} (if the sequence is null), or \N{U+c1.c2...},
   where c1... are the characters in the sequence.  For single-quoted regexes,
   the tokenizer passes the \N sequence through unchanged; this code will not
   attempt to determine this nor expand those, instead raising a syntax error.
   The net effect is that if the beginning of the passed-in pattern isn't '{U+'
   or there is no '}', it signals that this \N occurrence means to match a
   non-newline.

   Only the \N{U+...} form should occur in a character class, for the same
   reason that '.' inside a character class means to just match a period: it
   just doesn't make sense.

   The function raises an error (via vFAIL), and doesn't return for various
   syntax errors.  Otherwise it returns TRUE and sets <node_p> or <valuep> on
   success; it returns FALSE otherwise. Returns FALSE, setting *flagp to
   RESTART_UTF8 if the sizing scan needs to be restarted. Such a restart is
   only possible if node_p is non-NULL.


   If <valuep> is non-null, it means the caller can accept an input sequence
   consisting of a just a single code point; <*valuep> is set to that value
   if the input is such.

   If <node_p> is non-null it signifies that the caller can accept any other
   legal sequence (i.e., one that isn't just a single code point).  <*node_p>
   is set as follows:
    1) \N means not-a-NL: points to a newly created REG_ANY node;
    2) \N{}:              points to a new NOTHING node;
    3) otherwise:         points to a new EXACT node containing the resolved
                          string.
   Note that FALSE is returned for single code point sequences if <valuep> is
   null.
 */

    char * endbrace;    /* '}' following the name */
    char* p;
d11729 1
a11729 2
    bool has_multiple_chars; /* true if the input stream contains a sequence of
                                more than one character */
d11737 6
a11742 1
    assert(cBOOL(node_p) ^ cBOOL(valuep));  /* Exactly one should be set */
d11745 1
a11745 1
     * modifier.  The other meaning does not, so use a temporary until we find
d11747 2
a11748 3
    p = (RExC_flags & RXf_PMf_EXTENDED)
	? regwhite( pRExC_state, RExC_parse )
	: RExC_parse;
d11751 3
a11753 2
     * [^\n].  The former is assumed when it can't be the latter. */
    if (*p != '{' || regcurly(p, FALSE)) {
d11755 4
a11759 4
	    /* no bare \N allowed in a charclass */
            if (in_char_class) {
                vFAIL("\\N in a character class must be a named character: \\N{...}");
            }
d11762 1
a11762 3
        RExC_parse--;   /* Need to back off so nextchar() doesn't skip the
                           current char */
	nextchar(pRExC_state);
d11765 1
a11765 1
	RExC_naughty++;
d11782 1
a11782 1
    if (! (endbrace = strchr(RExC_parse, '}')) /* no trailing brace */
d11784 3
a11786 4
              || (endbrace - RExC_parse >= 2	/* U+ (bad hex is checked below
                                                 */
                  && strnEQ(RExC_parse, "U+", 2)))) /* for a better error msg)
                                                     */
d11792 3
d11796 9
a11804 18
        bool ret = TRUE;
	if (node_p) {
	    *node_p = reg_node(pRExC_state,NOTHING);
	}
        else if (in_char_class) {
            if (SIZE_ONLY && in_char_class) {
                if (strict) {
                    RExC_parse++;   /* Position after the "}" */
                    vFAIL("Zero length \\N{}");
                }
                else {
                    ckWARNreg(RExC_parse,
                              "Ignoring zero length \\N{} in character class");
                }
            }
            ret = FALSE;
	}
        else {
d11807 3
a11809 2
        nextchar(pRExC_state);
        return ret;
a11811 1
    RExC_uni_semantics = 1; /* Unicode named chars imply Unicode semantics */
d11814 2
a11819 1
    has_multiple_chars = (endchar < endbrace);
d11821 9
a11829 12
    if (valuep && (! has_multiple_chars || in_char_class)) {
	/* We only pay attention to the first char of
        multichar strings being returned in char classes. I kinda wonder
	if this makes sense as it does change the behaviour
	from earlier versions, OTOH that behaviour was broken
	as well. XXX Solution is to recharacterize as
	[rest-of-class]|multi1|multi2... */

	STRLEN length_of_hex = (STRLEN)(endchar - RExC_parse);
	I32 grok_hex_flags = PERL_SCAN_ALLOW_UNDERSCORES
	    | PERL_SCAN_DISALLOW_PREFIX
	    | (SIZE_ONLY ? PERL_SCAN_SILENT_ILLDIGIT : 0);
d11831 19
a11849 1
	*valuep = grok_hex(RExC_parse, &length_of_hex, &grok_hex_flags, NULL);
d11852 11
a11862 10
	 * bypass it by using single quoting, so check */
	if (length_of_hex == 0
	    || length_of_hex != (STRLEN)(endchar - RExC_parse) )
	{
	    RExC_parse += length_of_hex;	/* Includes all the valid */
	    RExC_parse += (RExC_orig_utf8)	/* point to after 1st invalid */
			    ? UTF8SKIP(RExC_parse)
			    : 1;
	    /* Guard against malformed utf8 */
	    if (RExC_parse >= endchar) {
d11865 1
a11865 11
	    vFAIL("Invalid hexadecimal number in \\N{U+...}");
	}

        if (in_char_class && has_multiple_chars) {
            if (strict) {
                RExC_parse = endbrace;
                vFAIL("\\N{} in character class restricted to one character");
            }
            else {
                ckWARNreg(endchar, "Using just the first character returned by \\N{} in character class");
            }
d11869 1
d11871 6
a11876 1
    else if (! node_p || ! has_multiple_chars) {
d11878 20
a11897 7
        /* Here, the input is legal, but not according to the caller's
         * options.  We fail without advancing the parse, so that the
         * caller can try again */
        RExC_parse = p;
        return FALSE;
    }
    else {
d11900 4
a11903 7
	 * (?:\x{char1}\x{char2}...)
	 * and then call reg recursively.  That way, it retains its atomicness,
	 * while not having to worry about special handling that some code
	 * points may have.  toke.c has converted the original Unicode values
	 * to native, so that we can just pass on the hex values unchanged.  We
	 * do have to set a flag to keep recoding from happening in the
	 * recursion */
d11905 1
a11905 4
	SV * substitute_parse = newSVpvn_flags("?:", 2, SVf_UTF8|SVs_TEMP);
	STRLEN len;
	char *orig_end = RExC_end;
        I32 flags;
d11917 1
d11919 1
a11919 1
	sv_catpv(substitute_parse, ")");
d11921 2
a11922 1
	RExC_parse = SvPV(substitute_parse, len);
d11925 2
a11926 1
	if (len < 8) {
d11931 3
a11933 1
	/* The values are Unicode, and therefore not subject to recoding */
d11935 3
d11939 8
a11946 4
	if (!(*node_p = reg(pRExC_state, 1, &flags, depth+1))) {
            if (flags & RESTART_UTF8) {
                *flagp = RESTART_UTF8;
                return FALSE;
d11948 1
a11948 2
            FAIL2("panic: reg returned NULL to grok_bslash_N, flags=%#"UVxf"",
                  (UV) flags);
a11949 1
	*flagp |= flags&(HASWIDTH|SPSTART|SIMPLE|POSTPONED);
d11951 2
d11956 3
d11960 1
d11962 2
a11964 2

    return TRUE;
d11979 1
a11979 1
S_reg_recode(pTHX_ const char value, SV **encp)
d11982 1
a11982 1
    SV * const sv = newSVpvn_flags(&value, numlen, SVs_TEMP);
d12002 1
a12002 1
S_compute_EXACTish(pTHX_ RExC_state_t *pRExC_state)
d12009 3
a12011 1
        return EXACT;
d12068 1
a12068 1
            if (UNI_IS_INVARIANT(code_point)) {
d12072 1
a12072 1
                else { /* Here is /i and not /l (toFOLD() is defined on just
d12103 4
a12106 1
                    && folded == code_point
d12109 3
a12111 1
                    OP(node) = EXACT;
d12130 3
d12134 3
a12136 1

d12179 8
a12186 4
    if ((len == 1 || (UTF && len == UNISKIP(code_point)))
        && (code_point != LATIN_SMALL_LETTER_SHARP_S
            || ! FOLD || ! DEPENDS_SEMANTICS))
    {
d12197 1
a12197 1
/* return atoi(p), unless it's too big to sensibly be a backref,
d12203 5
a12207 6
    char *q = p;

    for (;isDIGIT(*q); q++); /* calculate length of num */
    if (q - p == 0 || q - p > 9)
        return I32_MAX;
    return atoi(p);
d12272 2
a12273 2
   Returns NULL, setting *flagp to RESTART_UTF8 if the sizing scan needs to be
   restarted.
a12279 1
    dVAR;
d12282 1
a12282 1
    char *parse_start = RExC_parse;
d12285 1
d12295 3
a12297 1
tryagain:
d12304 1
a12304 1
	else if (RExC_flags & RXf_PMf_SINGLELINE)
a12305 2
	else
	    ret = reg_node(pRExC_state, BOL);
d12314 1
a12314 1
	else if (RExC_flags & RXf_PMf_SINGLELINE)
a12315 2
	else
	    ret = reg_node(pRExC_state, EOL);
d12325 1
a12325 1
	RExC_naughty++;
d12335 3
a12338 4
	if (*RExC_parse != ']') {
	    RExC_parse = oregcomp_parse;
	    vFAIL("Unmatched [");
	}
d12340 1
a12340 1
            if (*flagp & RESTART_UTF8)
d12345 4
d12358 1
a12358 1
		    if (RExC_parse == RExC_end) {
d12365 2
a12366 2
                if (flags & RESTART_UTF8) {
                    *flagp = RESTART_UTF8;
d12383 2
a12384 8
    case '{':
	if (!regcurly(RExC_parse, FALSE)) {
	    RExC_parse++;
	    goto defchar;
	}
	/* FALL THROUGH */
    case '?':
    case '+':
d12402 2
a12403 2
	switch ((U8)*++RExC_parse) {
            U8 arg;
d12408 5
d12441 1
a12441 4
	    ret = reg_node(pRExC_state, CANY);
            RExC_seen |= REG_CANY_SEEN;
	    *flagp |= HASWIDTH|SIMPLE;
	    goto finish_meta_pat;
d12454 3
d12458 3
d12463 3
a12465 5
	    op = BOUND + get_regex_charset(RExC_flags);
            if (op > BOUNDA) {  /* /aa is same as /a */
                op = BOUNDA;
            }
            else if (op == BOUNDL) {
d12468 1
a12469 1
	    FLAGS(ret) = get_regex_charset(RExC_flags);
d12471 82
a12552 3
	    if (! SIZE_ONLY && (U8) *(RExC_parse + 1) == '{') {
                /* diag_listed_as: Use "%s" instead of "%s" */
	        vFAIL("Use \"\\b\\{\" instead of \"\\b{\"");
d12554 3
a12556 10
	    goto finish_meta_pat;
	case 'B':
	    RExC_seen_zerolen++;
            RExC_seen |= REG_LOOKBEHIND_SEEN;
	    op = NBOUND + get_regex_charset(RExC_flags);
            if (op > NBOUNDA) { /* /aa is same as /a */
                op = NBOUNDA;
            }
            else if (op == NBOUNDL) {
                RExC_contains_locale = 1;
a12557 7
	    ret = reg_node(pRExC_state, op);
	    FLAGS(ret) = get_regex_charset(RExC_flags);
	    *flagp |= SIMPLE;
	    if (! SIZE_ONLY && (U8) *(RExC_parse + 1) == '{') {
                /* diag_listed_as: Use "%s" instead of "%s" */
	        vFAIL("Use \"\\B\\{\" instead of \"\\B{\"");
	    }
d12559 1
d12566 9
a12574 1
            goto join_posix;
d12603 1
a12603 1
        join_posix:
d12613 1
a12613 1
        join_posix_op_known:
d12625 1
a12625 1
            /* FALL THROUGH */
d12627 1
a12627 1
         finish_meta_pat:
d12633 1
a12633 4
	    {
#ifdef DEBUGGING
		char* parse_start = RExC_parse - 2;
#endif
d12635 23
a12657 21
		RExC_parse--;

                ret = regclass(pRExC_state, flagp,depth+1,
                               TRUE, /* means just parse this element */
                               FALSE, /* don't allow multi-char folds */
                               FALSE, /* don't silence non-portable warnings.
                                         It would be a bug if these returned
                                         non-portables */
                               NULL);
                /* regclass() can only return RESTART_UTF8 if multi-char folds
                   are allowed.  */
                if (!ret)
                    FAIL2("panic: regclass returned NULL to regatom, flags=%#"UVxf"",
                          (UV) *flagp);

		RExC_parse--;

		Set_Node_Offset(ret, parse_start + 2);
                Set_Node_Cur_Length(ret, parse_start);
		nextchar(pRExC_state);
	    }
d12660 11
a12670 10
            /* Handle \N and \N{NAME} with multiple code points here and not
             * below because it can be multicharacter. join_exact() will join
             * them up later on.  Also this makes sure that things like
             * /\N{BLAH}+/ and \N{BLAH} being multi char Just Happen. dmq.
             * The options to the grok function call causes it to fail if the
             * sequence is just a single code point.  We then go treat it as
             * just another character in the current EXACT node, and hence it
             * gets uniform treatment with all the other characters.  The
             * special treatment for quantifiers is not needed for such single
             * character sequences */
d12672 11
a12682 6
            if (! grok_bslash_N(pRExC_state, &ret, NULL, flagp, depth, FALSE,
                                FALSE /* not strict */ )) {
                if (*flagp & RESTART_UTF8)
                    return NULL;
                RExC_parse--;
                goto defchar;
d12684 8
a12691 1
            break;
d12693 1
a12693 1
	parse_named_seq:
d12695 6
a12700 2
            char ch= RExC_parse[1];
	    if (ch != '<' && ch != '\'' && ch != '{') {
d12705 9
a12713 36
	        /* this pretty much dupes the code for (?P=...) in reg(), if
                   you change this make sure you change that */
		char* name_start = (RExC_parse += 2);
		U32 num = 0;
                SV *sv_dat = reg_scan_name(pRExC_state,
                    SIZE_ONLY ? REG_RSN_RETURN_NULL : REG_RSN_RETURN_DATA);
                ch= (ch == '<') ? '>' : (ch == '{') ? '}' : '\'';
                if (RExC_parse == name_start || *RExC_parse != ch)
                    /* diag_listed_as: Sequence \%s... not terminated in regex; marked by <-- HERE in m/%s/ */
                    vFAIL2("Sequence %.3s... not terminated",parse_start);

                if (!SIZE_ONLY) {
                    num = add_data( pRExC_state, STR_WITH_LEN("S"));
                    RExC_rxi->data->data[num]=(void*)sv_dat;
                    SvREFCNT_inc_simple_void(sv_dat);
                }

                RExC_sawback = 1;
                ret = reganode(pRExC_state,
                               ((! FOLD)
                                 ? NREF
				 : (ASCII_FOLD_RESTRICTED)
				   ? NREFFA
                                   : (AT_LEAST_UNI_SEMANTICS)
                                     ? NREFFU
                                     : (LOC)
                                       ? NREFFL
                                       : NREFF),
                                num);
                *flagp |= HASWIDTH;

                /* override incorrect value set in reganode MJD */
                Set_Node_Offset(ret, parse_start+1);
                Set_Node_Cur_Length(ret, parse_start);
                nextchar(pRExC_state);

d12742 3
d12752 1
d12764 17
a12780 5
                    /* bare \NNN might be backref or octal - if it is larger than or equal
                     * RExC_npar then it is assumed to be and octal escape.
                     * Note RExC_npar is +1 from the actual number of parens*/
                    if (num == I32_MAX || (num > 9 && num >= RExC_npar
                            && *RExC_parse != '8' && *RExC_parse != '9'))
d12782 5
a12786 1
                        /* Probably a character specified in octal, e.g. \35 */
d12791 35
a12825 37
                /* at this point RExC_parse definitely points to a backref
                 * number */
		{
#ifdef RE_TRACK_PATTERN_OFFSETS
		    char * const parse_start = RExC_parse - 1; /* MJD */
#endif
		    while (isDIGIT(*RExC_parse))
			RExC_parse++;
                    if (hasbrace) {
                        if (*RExC_parse != '}')
                            vFAIL("Unterminated \\g{...} pattern");
                        RExC_parse++;
                    }
		    if (!SIZE_ONLY) {
		        if (num > (I32)RExC_rx->nparens)
			    vFAIL("Reference to nonexistent group");
		    }
		    RExC_sawback = 1;
		    ret = reganode(pRExC_state,
				   ((! FOLD)
				     ? REF
				     : (ASCII_FOLD_RESTRICTED)
				       ? REFFA
                                       : (AT_LEAST_UNI_SEMANTICS)
                                         ? REFFU
                                         : (LOC)
                                           ? REFFL
                                           : REFF),
				    num);
		    *flagp |= HASWIDTH;

                    /* override incorrect value set in reganode MJD */
                    Set_Node_Offset(ret, parse_start+1);
                    Set_Node_Cur_Length(ret, parse_start);
		    RExC_parse--;
		    nextchar(pRExC_state);
		}
d12831 1
a12831 1
	    /* FALL THROUGH */
d12835 1
a12835 1
	    parse_start--;
d12837 1
a12837 1
	}
d12841 8
a12848 2
	if (RExC_flags & RXf_PMf_EXTENDED) {
	    if ( reg_skipcomment( pRExC_state ) )
d12851 3
a12853 1
	/* FALL THROUGH */
d12856 1
d12858 4
a12861 3
            parse_start = RExC_parse - 1;

	    RExC_parse++;
a12862 1
	defchar: {
d12880 1
a12880 1
             * Similarly, we can convert EXACTFL nodes to EXACTFU if they
d12901 1
a12901 1
	reparse:
d12903 7
a12909 2
            /* We do the EXACTFish to EXACT node only if folding.  (And we
             * don't need to figure this out until pass 2) */
d12930 6
a12935 1
	    for (p = RExC_parse - 1;
d12941 4
a12944 2
		if (RExC_flags & RXf_PMf_EXTENDED)
		    p = regwhite( pRExC_state, p );
a12995 3
                        /* The options cause it to fail if a multiple code
                         * point sequence.  Handle those in the switch() above
                         * */
d12997 20
a13016 6
                        if (! grok_bslash_N(pRExC_state, NULL, &ender,
                                            flagp, depth, FALSE,
                                            FALSE /* not strict */ ))
                        {
                            if (*flagp & RESTART_UTF8)
                                FAIL("panic: grok_bslash_N set RESTART_UTF8");
d13022 1
a13022 1
                            REQUIRE_UTF8;
d13038 1
a13038 1
			  ender = ASCII_TO_NATIVE('\033');
d13042 1
a13042 1
			  ender = '\a';
d13053 2
a13054 2
						       TRUE, /* out warnings */
                                                       FALSE, /* not strict */
d13065 1
a13065 1
			    if (PL_encoding && ender < 0x100) {
d13069 1
a13069 1
				REQUIRE_UTF8;
d13082 3
a13084 3
						       TRUE, /* out warnings */
                                                       FALSE, /* not strict */
                                                       TRUE, /* Output warnings
d13095 10
a13104 2
			    if (PL_encoding && ender < 0x100) {
				goto recode_encoding;
d13106 2
a13107 2
			    if (ender > 0xff) {
				REQUIRE_UTF8;
d13113 1
a13113 1
			ender = grok_bslash_c(*p++, SIZE_ONLY);
d13117 3
d13128 2
a13129 2
                         * parsed capture buffer is a backslash. Anything else
                         * is octal.
d13145 1
d13152 1
a13152 1
				REQUIRE_UTF8;
d13155 1
a13155 1
                            if (SIZE_ONLY   /* like \08, \178 */
a13156 1
                                && p < RExC_end
d13164 1
a13164 1
			if (PL_encoding && ender < 0x100)
d13167 1
a13167 1
		    recode_encoding:
d13169 3
a13171 3
			    SV* enc = PL_encoding;
			    ender = reg_recode((const char)(U8)ender, &enc);
			    if (!enc && SIZE_ONLY)
d13173 1
a13173 1
			    REQUIRE_UTF8;
d13179 1
a13179 1
			/* FALL THROUGH */
d13182 1
a13182 1
			    /* Include any { following the alpha to emphasize
d13191 11
a13202 10

                    if (! SIZE_ONLY
                        && RExC_flags & RXf_PMf_EXTENDED
                        && ckWARN_d(WARN_DEPRECATED)
                        && is_PATWS_non_low_safe(p, RExC_end, UTF))
                    {
                        vWARN_dep(p + ((UTF) ? UTF8SKIP(p) : 1),
                                "Escape literal pattern white space under /x");
                    }

d13204 1
a13204 1
		    if (UTF8_IS_START(*p) && UTF) {
d13216 7
a13222 5
		 * contains its ordinal, <p> points to the character after it
		 */

		if ( RExC_flags & RXf_PMf_EXTENDED)
		    p = regwhite( pRExC_state, p );
d13231 3
a13233 1
                if ((next_is_quantifier = (p < RExC_end && ISMULT2(p))) && len)
d13239 3
a13241 5
                if (! FOLD   /* The simple case, just append the literal */
                    || (LOC  /* Also don't fold for tricky chars under /l */
                        && is_PROBLEMATIC_LOCALE_FOLD_cp(ender)))
                {
                    if (UTF) {
d13243 29
a13271 13
                        /* Normally, we don't need the representation of the
                         * character in the sizing pass--just its size, but if
                         * folding, we have to actually put the character out
                         * even in the sizing pass, because the size could
                         * change as we juggle things at the end of this loop
                         * to avoid splitting a too-full node in the middle of
                         * a potential multi-char fold [perl #123539] */
                        const STRLEN unilen = (SIZE_ONLY && ! FOLD)
                                               ? UNISKIP(ender)
                                               : (uvchr_to_utf8((U8*)s, ender) - (U8*)s);
                        if (unilen > 0) {
                           s   += unilen;
                           len += unilen;
a13272 14

                        /* The loop increments <len> each time, as all but this
                         * path (and one other) through it add a single byte to
                         * the EXACTish node.  But this one has changed len to
                         * be the correct final value, so subtract one to
                         * cancel out the increment that follows */
                        len--;
                    }
                    else if (FOLD) {
                        /* See comment above for [perl #123539] */
                        *(s++) = (char) ender;
                    }
                    else {
                        REGC((char)ender, s++);
d13274 2
d13277 31
a13307 16
                    /* Can get here if folding only if is one of the /l
                     * characters whose fold depends on the locale.  The
                     * occurrence of any of these indicate that we can't
                     * simplify things */
                    if (FOLD) {
                        maybe_exact = FALSE;
                        maybe_exactfu = FALSE;
                    }
                }
                else             /* FOLD */
                     if (! ( UTF
                        /* See comments for join_exact() as to why we fold this
                         * non-UTF at compile time */
                        || (node_type == EXACTFU
                            && ender == LATIN_SMALL_LETTER_SHARP_S)))
                {
d13311 1
a13311 1
                     * is_PROBLEMATIC_LOCALE_FOLD_cp */
d13318 5
a13322 1
                        if (maybe_exactfu
d13324 8
a13331 6
                                || ender == LATIN_SMALL_LETTER_SHARP_S
                                || (len > 0
                                   && isARG2_lower_or_UPPER_ARG1('s', ender)
                                   && isARG2_lower_or_UPPER_ARG1('s',
                                                                 *(s-1)))))
                        {
d13340 1
a13340 1
                else {  /* FOLD and UTF */
d13347 1
a13347 2
                     * to back off accordingly.  (Hence we can't use REGC for
                     * the simple case just below.) */
d13350 1
a13350 1
                    if (isASCII(ender)) {
d13470 1
a13470 1
                            if (! IS_NON_FINAL_FOLD(TWO_BYTE_UTF8_TO_NATIVE(
d13513 1
a13513 1
                    if (maybe_exactfu && isARG2_lower_or_UPPER_ARG1('s', ender))
d13566 2
a13567 2
	loopdone:   /* Jumped to when encounters something that shouldn't be in
		       the node */
d13583 3
a13585 1
                        OP(ret) = EXACT;
d13588 3
a13590 1
                        OP(ret) = EXACTFU;
d13603 3
a13605 1
	    nextchar(pRExC_state);
a13619 60
STATIC char *
S_regwhite( RExC_state_t *pRExC_state, char *p )
{
    const char *e = RExC_end;

    PERL_ARGS_ASSERT_REGWHITE;

    while (p < e) {
	if (isSPACE(*p))
	    ++p;
	else if (*p == '#') {
            bool ended = 0;
	    do {
		if (*p++ == '\n') {
		    ended = 1;
		    break;
		}
	    } while (p < e);
	    if (!ended)
                RExC_seen |= REG_RUN_ON_COMMENT_SEEN;
	}
	else
	    break;
    }
    return p;
}

STATIC char *
S_regpatws( RExC_state_t *pRExC_state, char *p , const bool recognize_comment )
{
    /* Returns the next non-pattern-white space, non-comment character (the
     * latter only if 'recognize_comment is true) in the string p, which is
     * ended by RExC_end.  If there is no line break ending a comment,
     * RExC_seen has added the REG_RUN_ON_COMMENT_SEEN flag; */
    const char *e = RExC_end;

    PERL_ARGS_ASSERT_REGPATWS;

    while (p < e) {
        STRLEN len;
	if ((len = is_PATWS_safe(p, e, UTF))) {
	    p += len;
        }
	else if (recognize_comment && *p == '#') {
            bool ended = 0;
	    do {
                p++;
                if (is_LNBREAK_safe(p, e, UTF)) {
		    ended = 1;
		    break;
		}
	    } while (p < e);
	    if (!ended)
                RExC_seen |= REG_RUN_ON_COMMENT_SEEN;
	}
	else
	    break;
    }
    return p;
}
d13645 2
a13646 5
            if (end == UV_MAX && start <= 256) {
                ANYOF_FLAGS(node) |= ANYOF_ABOVE_LATIN1_ALL;
            }
            else if (end >= 256) {
                ANYOF_FLAGS(node) |= ANYOF_UTF8;
d13650 1
a13650 1
	    if (start > 255) {
d13657 3
a13659 1
	    high = (end < 255) ? end : 255;
d13669 2
a13670 2
         * *invlist_ptr; similarly for code points above latin1 if we have a
         * flag to match all of them anyways */
d13672 1
a13672 1
	    _invlist_subtract(*invlist_ptr, PL_Latin1, invlist_ptr);
d13674 2
a13675 2
        if (ANYOF_FLAGS(node) & ANYOF_ABOVE_LATIN1_ALL) {
	    _invlist_intersection(*invlist_ptr, PL_Latin1, invlist_ptr);
d13695 176
d13872 3
a13874 5
PERL_STATIC_INLINE I32
S_regpposixcc(pTHX_ RExC_state_t *pRExC_state, I32 value, const bool strict)
{
    dVAR;
    I32 namedclass = OOB_NAMEDCLASS;
d13876 2
a13877 1
    PERL_ARGS_ASSERT_REGPPOSIXCC;
d13879 5
a13883 3
    if (value == '[' && RExC_parse + 1 < RExC_end &&
	/* I smell either [: or [= or [. -- POSIX has been here, right? */
	POSIXCC(UCHARAT(RExC_parse)))
d13885 43
a13927 2
	const char c = UCHARAT(RExC_parse);
	char* const s = RExC_parse++;
d13929 9
a13937 4
	while (RExC_parse < RExC_end && UCHARAT(RExC_parse) != c)
	    RExC_parse++;
	if (RExC_parse == RExC_end) {
            if (strict) {
d13939 4
a13942 5
                /* Try to give a better location for the error (than the end of
                 * the string) by looking for the matching ']' */
                RExC_parse = s;
                while (RExC_parse < RExC_end && UCHARAT(RExC_parse) != ']') {
                    RExC_parse++;
d13944 2
a13945 1
                vFAIL2("Unmatched '%c' in POSIX class", c);
a13946 2
	    /* Grandfather lone [:, [=, [. */
	    RExC_parse = s;
a13947 3
	else {
	    const char* const t = RExC_parse++; /* skip over the c */
	    assert(*t == c);
d13949 14
a13962 71
  	    if (UCHARAT(RExC_parse) == ']') {
		const char *posixcc = s + 1;
  		RExC_parse++; /* skip over the ending ] */

		if (*s == ':') {
		    const I32 complement = *posixcc == '^' ? *posixcc++ : 0;
		    const I32 skip = t - posixcc;

		    /* Initially switch on the length of the name.  */
		    switch (skip) {
		    case 4:
                        if (memEQ(posixcc, "word", 4)) /* this is not POSIX,
                                                          this is the Perl \w
                                                        */
			    namedclass = ANYOF_WORDCHAR;
			break;
		    case 5:
			/* Names all of length 5.  */
			/* alnum alpha ascii blank cntrl digit graph lower
			   print punct space upper  */
			/* Offset 4 gives the best switch position.  */
			switch (posixcc[4]) {
			case 'a':
			    if (memEQ(posixcc, "alph", 4)) /* alpha */
				namedclass = ANYOF_ALPHA;
			    break;
			case 'e':
			    if (memEQ(posixcc, "spac", 4)) /* space */
				namedclass = ANYOF_PSXSPC;
			    break;
			case 'h':
			    if (memEQ(posixcc, "grap", 4)) /* graph */
				namedclass = ANYOF_GRAPH;
			    break;
			case 'i':
			    if (memEQ(posixcc, "asci", 4)) /* ascii */
				namedclass = ANYOF_ASCII;
			    break;
			case 'k':
			    if (memEQ(posixcc, "blan", 4)) /* blank */
				namedclass = ANYOF_BLANK;
			    break;
			case 'l':
			    if (memEQ(posixcc, "cntr", 4)) /* cntrl */
				namedclass = ANYOF_CNTRL;
			    break;
			case 'm':
			    if (memEQ(posixcc, "alnu", 4)) /* alnum */
				namedclass = ANYOF_ALPHANUMERIC;
			    break;
			case 'r':
			    if (memEQ(posixcc, "lowe", 4)) /* lower */
				namedclass = (FOLD) ? ANYOF_CASED : ANYOF_LOWER;
			    else if (memEQ(posixcc, "uppe", 4)) /* upper */
				namedclass = (FOLD) ? ANYOF_CASED : ANYOF_UPPER;
			    break;
			case 't':
			    if (memEQ(posixcc, "digi", 4)) /* digit */
				namedclass = ANYOF_DIGIT;
			    else if (memEQ(posixcc, "prin", 4)) /* print */
				namedclass = ANYOF_PRINT;
			    else if (memEQ(posixcc, "punc", 4)) /* punct */
				namedclass = ANYOF_PUNCT;
			    break;
			}
			break;
		    case 6:
			if (memEQ(posixcc, "xdigit", 6))
			    namedclass = ANYOF_XDIGIT;
			break;
		    }
d13964 2
a13965 4
		    if (namedclass == OOB_NAMEDCLASS)
			vFAIL2utf8f(
                            "POSIX class [:%"UTF8f":] unknown",
			    UTF8fARG(UTF, t - s - 1, s + 1));
d13967 39
a14005 22
                    /* The #defines are structured so each complement is +1 to
                     * the normal one */
                    if (complement) {
                        namedclass++;
                    }
		    assert (posixcc[skip] == ':');
		    assert (posixcc[skip+1] == ']');
		} else if (!SIZE_ONLY) {
		    /* [[=foo=]] and [[.foo.]] are still future. */

		    /* adjust RExC_parse so the warning shows after
		       the class closes */
		    while (UCHARAT(RExC_parse) && UCHARAT(RExC_parse) != ']')
			RExC_parse++;
		    vFAIL3("POSIX syntax [%c %c] is reserved for future extensions", c, c);
		}
	    } else {
		/* Maternal grandfather:
		 * "[:" ending in ":" but not in ":]" */
                if (strict) {
                    vFAIL("Unmatched '[' in POSIX class");
                }
d14007 1
a14007 4
                /* Grandfather lone [:, [=, [. */
		RExC_parse = s;
	    }
	}
d14010 7
a14016 2
    return namedclass;
}
d14018 3
a14020 22
STATIC bool
S_could_it_be_a_POSIX_class(pTHX_ RExC_state_t *pRExC_state)
{
    /* This applies some heuristics at the current parse position (which should
     * be at a '[') to see if what follows might be intended to be a [:posix:]
     * class.  It returns true if it really is a posix class, of course, but it
     * also can return true if it thinks that what was intended was a posix
     * class that didn't quite make it.
     *
     * It will return true for
     *      [:alphanumerics:
     *      [:alphanumerics]  (as long as the ] isn't followed immediately by a
     *                         ')' indicating the end of the (?[
     *      [:any garbage including %^&$ punctuation:]
     *
     * This is designed to be called only from S_handle_regex_sets; it could be
     * easily adapted to be called from the spot at the beginning of regclass()
     * that checks to see in a normal bracketed class if the surrounding []
     * have been omitted ([:word:] instead of [[:word:]]).  But doing so would
     * change long-standing behavior, so I (khw) didn't do that */
    char* p = RExC_parse + 1;
    char first_char = *p;
d14022 3
a14024 1
    PERL_ARGS_ASSERT_COULD_IT_BE_A_POSIX_CLASS;
d14026 3
a14028 1
    assert(*(p - 1) == '[');
d14030 1
a14030 2
    if (! POSIXCC(first_char)) {
        return FALSE;
d14033 1
a14033 2
    p++;
    while (p < RExC_end && isWORDCHAR(*p)) p++;
d14035 40
a14074 2
    if (p >= RExC_end) {
        return FALSE;
d14077 25
a14101 3
    if (p - RExC_parse > 2    /* Got at least 1 word character */
        && (*p == first_char
            || (*p == ']' && p + 1 < RExC_end && *(p + 1) != ')')))
d14103 397
a14499 1
        return TRUE;
d14502 11
a14512 1
    p = (char *) memchr(RExC_parse, ']', RExC_end - RExC_parse);
d14514 18
a14531 4
    return (p
            && p - RExC_parse > 2 /* [:] evaluates to colon;
                                      [::] is a bad posix class. */
            && first_char == *(p - 1));
d14541 22
a14562 9
    U8 curchar;
    UV start, end;	/* End points of code point ranges */
    SV* result_string;
    char *save_end, *save_parse;
    SV* final;
    STRLEN len;
    regnode* node;
    AV* stack;
    const bool save_fold = FOLD;
d14568 2
a14569 2
    if (LOC) {
        vFAIL("(?[...]) not valid in locale");
d14571 5
a14575 1
    RExC_uni_semantics = 1;
a14586 8
        Perl_ck_warner_d(aTHX_
            packWARN(WARN_EXPERIMENTAL__REGEX_SETS),
            "The regex_sets feature is experimental" REPORT_LOCATION,
                UTF8fARG(UTF, (RExC_parse - RExC_precomp), RExC_precomp),
                UTF8fARG(UTF,
                         RExC_end - RExC_start - (RExC_parse - RExC_precomp),
                         RExC_precomp + (RExC_parse - RExC_precomp)));

d14589 4
a14592 2
            RExC_parse = regpatws(pRExC_state, RExC_parse,
                                TRUE); /* means recognize comments */
d14596 1
a14596 1
                    /* FALL THROUGH */
d14600 2
a14601 6
                    /* Skip the next byte (which could cause us to end up in
                     * the middle of a UTF-8 character, but since none of those
                     * are confusable with anything we currently handle in this
                     * switch (invariants all), it's safe.  We'll just hit the
                     * default: case next time and keep on incrementing until
                     * we find one of the invariants we do handle. */
d14603 4
d14608 1
d14611 10
a14620 7
                    /* If this looks like it is a [:posix:] class, leave the
                     * parse pointer at the '[' to fool regclass() into
                     * thinking it is part of a '[[:posix:]]'.  That function
                     * will use strict checking to force a syntax error if it
                     * doesn't work out to a legitimate class */
                    bool is_posix_class
                                    = could_it_be_a_POSIX_class(pRExC_state);
d14625 2
a14626 2
                    /* regclass() can only return RESTART_UTF8 if multi-char
                       folds are allowed.  */
d14633 7
a14639 3
                                  &current))
                        FAIL2("panic: regclass returned NULL to handle_sets, flags=%#"UVxf"",
                              (UV) *flagp);
d14654 1
a14654 3
                    if (RExC_parse < RExC_end
                        && *RExC_parse == ')')
                    {
d14660 4
d14668 9
a14676 1
            RExC_parse++;
a14678 1
        no_close:
d14682 33
a14714 19
    /* Pass 2 only after this.  Everything in this construct is a
     * metacharacter.  Operands begin with either a '\' (for an escape
     * sequence), or a '[' for a bracketed character class.  Any other
     * character should be an operator, or parenthesis for grouping.  Both
     * types of operands are handled by calling regclass() to parse them.  It
     * is called with a parameter to indicate to return the computed inversion
     * list.  The parsing here is implemented via a stack.  Each entry on the
     * stack is a single character representing one of the operators, or the
     * '('; or else a pointer to an operand inversion list. */

#define IS_OPERAND(a)  (! SvIOK(a))

    /* The stack starts empty.  It is a syntax error if the first thing parsed
     * is a binary operator; everything else is pushed on the stack.  When an
     * operand is parsed, the top of the stack is examined.  If it is a binary
     * operator, the item before it should be an operand, and both are replaced
     * by the result of doing that operation on the new operand and the one on
     * the stack.   Thus a sequence of binary operands is reduced to a single
     * one before the next one is parsed.
d14716 21
a14736 2
     * A unary operator may immediately follow a binary in the input, for
     * example
d14738 12
a14749 4
     * When an operand is parsed and the top of the stack is a unary operator,
     * the operation is performed, and then the stack is rechecked to see if
     * this new operand is part of a binary operation; if so, it is handled as
     * above.
d14751 12
a14762 6
     * A '(' is simply pushed on the stack; it is valid only if the stack is
     * empty, or the top element of the stack is an operator or another '('
     * (for which the parenthesized expression will become an operand).  By the
     * time the corresponding ')' is parsed everything in between should have
     * been parsed and evaluated to a single operand (or else is a syntax
     * error), and is handled as a regular operand */
d14765 1
d14768 8
a14775 7
        I32 top_index = av_tindex(stack);
        SV** top_ptr;
        SV* current = NULL;

        /* Skip white space */
        RExC_parse = regpatws(pRExC_state, RExC_parse,
                                TRUE); /* means recognize comments */
d14779 6
a14784 3
        if ((curchar = UCHARAT(RExC_parse)) == ']') {
            break;
        }
d14787 8
d14796 2
a14797 9
            case '?':
                if (av_tindex(stack) >= 0   /* This makes sure that we can
                                               safely subtract 1 from
                                               RExC_parse in the next clause.
                                               If we have something on the
                                               stack, we have parsed something
                                             */
                    && UCHARAT(RExC_parse - 1) == '('
                    && RExC_parse < RExC_end)
d14812 4
a14815 1
                    const char * const save_parse = ++RExC_parse;
d14817 1
d14821 3
a14823 3
                                                     least one flag (or this
                                                     embedding wasn't compiled)
                                                   */
d14843 2
d14851 6
a14856 3
                     * ']'; the next character should be the ')' which will be
                     * paired with the '(' that has been put on the stack, so
                     * the whole embedded expression reduces to '(operand)' */
d14858 1
d14860 1
a14863 1
                /* FALL THROUGH */
d14865 23
a14887 3
            default:
                RExC_parse += (UTF) ? UTF8SKIP(RExC_parse) : 1;
                vFAIL("Unexpected character");
d14890 2
a14891 2
                /* regclass() can only return RESTART_UTF8 if multi-char
                   folds are allowed.  */
d14896 9
a14904 3
                              &current))
                    FAIL2("panic: regclass returned NULL to handle_sets, flags=%#"UVxf"",
                          (UV) *flagp);
d14912 10
a14921 2
                bool is_posix_class = could_it_be_a_POSIX_class(pRExC_state);

d14926 18
a14943 10
                /* regclass() can only return RESTART_UTF8 if multi-char
                   folds are allowed.  */
                if(!regclass(pRExC_state, flagp,depth+1,
                             is_posix_class, /* parse the whole char class
                                                only if not a posix class */
                             FALSE, /* don't allow multi-char folds */
                             FALSE, /* don't silence non-portable warnings.  */
                             &current))
                    FAIL2("panic: regclass returned NULL to handle_sets, flags=%#"UVxf"",
                          (UV) *flagp);
d14953 42
d15000 5
a15004 1
                if (top_index < 0
d15008 1
a15008 2
                    RExC_parse++;
                    vFAIL2("Unexpected binary operator '%c' with no preceding operand", curchar);
a15009 2
                av_push(stack, newSVuv(curchar));
                break;
d15011 11
a15021 3
            case '!':
                av_push(stack, newSVuv(curchar));
                break;
d15023 17
a15039 7
            case '(':
                if (top_index >= 0) {
                    top_ptr = av_fetch(stack, top_index, FALSE);
                    assert(top_ptr);
                    if (IS_OPERAND(*top_ptr)) {
                        RExC_parse++;
                        vFAIL("Unexpected '(' with no preceding operator");
d15041 5
d15047 1
a15047 2
                av_push(stack, newSVuv(curchar));
                break;
d15049 2
a15050 9
            case ')':
            {
                SV* lparen;
                if (top_index < 1
                    || ! (current = av_pop(stack))
                    || ! IS_OPERAND(current)
                    || ! (lparen = av_pop(stack))
                    || IS_OPERAND(lparen)
                    || SvUV(lparen) != '(')
d15052 12
a15063 3
                    SvREFCNT_dec(current);
                    RExC_parse++;
                    vFAIL("Unexpected ')'");
a15064 2
                top_index -= 2;
                SvREFCNT_dec_NN(lparen);
d15066 11
a15076 2
                /* FALL THROUGH */
            }
d15078 1
a15078 1
              handle_operand:
d15080 1
a15080 1
                /* Here, we have an operand to process, in 'current' */
d15082 3
a15084 2
                if (top_index < 0) {    /* Just push if stack is empty */
                    av_push(stack, current);
a15085 21
                else {
                    SV* top = av_pop(stack);
                    SV *prev = NULL;
                    char current_operator;

                    if (IS_OPERAND(top)) {
                        SvREFCNT_dec_NN(top);
                        SvREFCNT_dec_NN(current);
                        vFAIL("Operand with no preceding operator");
                    }
                    current_operator = (char) SvUV(top);
                    switch (current_operator) {
                        case '(':   /* Push the '(' back on followed by the new
                                       operand */
                            av_push(stack, top);
                            av_push(stack, current);
                            SvREFCNT_inc(top);  /* Counters the '_dec' done
                                                   just after the 'break', so
                                                   it doesn't get wrongly freed
                                                 */
                            break;
d15087 63
a15149 2
                        case '!':
                            _invlist_invert(current);
d15151 1
a15151 15
                            /* Unlike binary operators, the top of the stack,
                             * now that this unary one has been popped off, may
                             * legally be an operator, and we now have operand
                             * for it. */
                            top_index--;
                            SvREFCNT_dec_NN(top);
                            goto handle_operand;

                        case '&':
                            prev = av_pop(stack);
                            _invlist_intersection(prev,
                                                   current,
                                                   &current);
                            av_push(stack, current);
                            break;
d15153 22
a15174 6
                        case '|':
                        case '+':
                            prev = av_pop(stack);
                            _invlist_union(prev, current, &current);
                            av_push(stack, current);
                            break;
d15176 1
a15176 5
                        case '-':
                            prev = av_pop(stack);;
                            _invlist_subtract(prev, current, &current);
                            av_push(stack, current);
                            break;
d15178 2
a15179 19
                        case '^':   /* The union minus the intersection */
                        {
                            SV* i = NULL;
                            SV* u = NULL;
                            SV* element;

                            prev = av_pop(stack);
                            _invlist_union(prev, current, &u);
                            _invlist_intersection(prev, current, &i);
                            /* _invlist_subtract will overwrite current
                                without freeing what it already contains */
                            element = current;
                            _invlist_subtract(u, i, &current);
                            av_push(stack, current);
                            SvREFCNT_dec_NN(i);
                            SvREFCNT_dec_NN(u);
                            SvREFCNT_dec_NN(element);
                            break;
                        }
d15181 15
a15195 2
                        default:
                            Perl_croak(aTHX_ "panic: Unexpected item on '(?[ ])' stack");
a15196 2
                SvREFCNT_dec_NN(top);
                SvREFCNT_dec(prev);
d15198 6
a15203 1
        }
d15206 5
d15213 1
a15213 1
    if (av_tindex(stack) < 0   /* Was empty */
d15216 2
a15217 1
        || av_tindex(stack) >= 0)  /* More left on stack */
d15219 2
d15245 2
d15256 2
a15257 2
    /* regclass() can only return RESTART_UTF8 if multi-char folds are allowed.
     */
d15264 5
a15268 1
                    NULL);
d15272 27
d15302 1
d15312 1
d15315 162
d15483 16
d15507 6
a15512 1
                 SV** ret_invlist)  /* Return an inversion list, not a node */
d15529 5
a15533 5
     * ANYOF nodes contain a bit map for the first 256 characters, with the
     * corresponding bit set if that character is in the list.  For characters
     * above 255, a range list or swash is used.  There are extra bits for \w,
     * etc. in locale ANYOFs, as what these match is not determinable at
     * compile time
d15535 3
a15537 2
     * Returns NULL, setting *flagp to RESTART_UTF8 if the sizing scan needs
     * to be restarted.  This can only happen if ret_invlist is non-NULL.
a15539 1
    dVAR;
d15545 1
a15545 1
    IV namedclass = OOB_NAMEDCLASS;
d15562 4
a15573 1
    const bool strict = cBOOL(ret_invlist); /* Apply strict parsing rules? */
d15588 3
a15590 2
     * string is in UTF-8.  (Because is under /d) */
    SV* depends_list = NULL;
d15604 11
a15614 5
#ifdef EBCDIC
    /* In a range, counts how many 0-2 of the ends of it came from literals,
     * not escapes.  Thus we can tell if 'A' was input vs \x{C1} */
    UV literal_endpoint = 0;
#endif
d15624 12
d15645 6
d15652 5
a15656 1
    ret = reganode(pRExC_state, ANYOF, 0);
d15671 3
a15673 4
    if (skip_white) {
        RExC_parse = regpatws(pRExC_state, RExC_parse,
                              FALSE /* means don't recognize comments */);
    }
d15675 1
a15675 1
    if (UCHARAT(RExC_parse) == '^') {	/* Complement of range. */
d15679 2
a15680 5
        RExC_naughty++;
        if (skip_white) {
            RExC_parse = regpatws(pRExC_state, RExC_parse,
                                  FALSE /* means don't recognize comments */);
        }
d15684 19
a15702 13
    if (!SIZE_ONLY && RExC_parse < RExC_end && POSIXCC(UCHARAT(RExC_parse))) {
	const char *s = RExC_parse;
	const char  c = *s++;

	while (isWORDCHAR(*s))
	    s++;
	if (*s && c == *s && s[1] == ']') {
	    SAVEFREESV(RExC_rx_sv);
	    ckWARN3reg(s+2,
		       "POSIX syntax [%c %c] belongs inside character classes",
		       c, c);
	    (void)ReREFCNT_inc(RExC_rx_sv);
	}
a15714 1
parseit:
d15716 15
d15735 1
a15735 4
        if (skip_white) {
            RExC_parse = regpatws(pRExC_state, RExC_parse,
                                  FALSE /* means don't recognize comments */);
        }
d15741 1
a15741 1
    charclassloop:
d15750 1
d15752 1
a15752 1
	if (UTF) {
d15761 31
a15791 3
        if (value == '['
            && RExC_parse < RExC_end
            && POSIXCC(UCHARAT(RExC_parse)))
d15793 7
a15799 1
            namedclass = regpposixcc(pRExC_state, value, strict);
d15802 7
a15808 1
	    if (UTF) {
d15827 1
a15827 1
            if (! skip_white || ! is_PATWS_cp(value)) switch ((I32)value) {
d15841 57
a15897 12
                    /* We only pay attention to the first char of
                    multichar strings being returned. I kinda wonder
                    if this makes sense as it does change the behaviour
                    from earlier versions, OTOH that behaviour was broken
                    as well. */
                    if (! grok_bslash_N(pRExC_state, NULL, &value, flagp, depth,
                                      TRUE, /* => charclass */
                                      strict))
                    {
                        if (*flagp & RESTART_UTF8)
                            FAIL("panic: grok_bslash_N set RESTART_UTF8");
                        goto parseit;
d15899 3
d15918 1
a15918 1
		    vFAIL2("Empty \\%c{}", (U8)value);
d15921 3
a15923 2
		    e = strchr(RExC_parse++, '}');
                    if (!e)
d15925 20
a15944 2
		    while (isSPACE(UCHARAT(RExC_parse)))
		        RExC_parse++;
d15947 1
d15949 1
a15949 1
		    while (isSPACE(UCHARAT(RExC_parse + n - 1)))
d15951 8
a15958 2
		}
		else {
a15963 1
                    char* formatted;
d15965 3
a15968 13
		    if (UCHARAT(RExC_parse) == '^') {
			 RExC_parse++;
			 n--;
                         /* toggle.  (The rhs xor gets the single bit that
                          * differs between P and p; the other xor inverts just
                          * that bit) */
                         value ^= 'P' ^ 'p';

			 while (isSPACE(UCHARAT(RExC_parse))) {
			      RExC_parse++;
			      n--;
			 }
		    }
d15974 9
a15982 8
                    formatted = Perl_form(aTHX_
                                          "%s%.*s%s\n",
                                          (FOLD) ? "__" : "",
                                          (int)n,
                                          RExC_parse,
                                          (FOLD) ? "_i" : ""
                                );
                    name = savepvn(formatted, strlen(formatted));
d15986 6
a15991 4
                    if (swash) {
                        SvREFCNT_dec_NN(swash);
                    }
                    swash = _core_swash_init("utf8", name, &PL_sv_undef,
d15998 9
a16006 1
                        if (swash) {
d16011 30
a16040 5
                        /* Here didn't find it.  It could be a user-defined
                         * property that will be available at run-time.  If we
                         * accept only compile-time properties, is an error;
                         * otherwise add it to the list for run-time look up */
                        if (ret_invlist) {
d16042 20
a16061 3
                            vFAIL2utf8f(
                                "Property '%"UTF8f"' is unknown",
                                UTF8fARG(UTF, n, name));
d16063 1
a16063 1
                        Perl_sv_catpvf(aTHX_ listsv, "%cutf8::%"UTF8f"\n",
d16065 3
a16067 1
                                        UTF8fARG(UTF, n, name));
d16069 2
d16072 3
a16074 8
                        /* We don't know yet, so have to assume that the
                         * property could match something in the Latin1 range,
                         * hence something that isn't utf8.  Note that this
                         * would cause things in <depends_list> to match
                         * inappropriately, except that any \p{}, including
                         * this one forces Unicode semantics, which means there
                         * is no <depends_list> */
                        ANYOF_FLAGS(ret) |= ANYOF_NONBITMAP_NON_UTF8;
a16114 1
		    Safefree(name);
d16121 1
a16121 1
		RExC_uni_semantics = 1;
d16129 1
a16129 1
	    case 'e':	value = ASCII_TO_NATIVE('\033');break;
d16138 2
a16139 2
                                               SIZE_ONLY,   /* warnings in pass
                                                               1 only */
d16147 2
a16148 1
		if (PL_encoding && value < 0x100) {
d16159 1
a16159 1
					       TRUE, /* Output warnings */
d16167 2
a16168 1
		if (PL_encoding && value < 0x100)
d16172 2
a16173 1
		value = grok_bslash_c(*RExC_parse++, SIZE_ONLY);
d16201 2
a16202 1
		    if (PL_encoding && value < 0x100)
d16206 1
a16206 1
	    recode_encoding:
d16208 2
a16209 2
		    SV* enc = PL_encoding;
		    value = reg_recode((const char)(U8)value, &enc);
d16214 1
a16214 1
                        else if (SIZE_ONLY) {
a16238 4
#ifdef EBCDIC
        else
            literal_endpoint++;
#endif
d16296 1
a16296 1
                    ANYOF_FLAGS(ret) |= ANYOF_POSIXL;
d16298 6
d16306 5
d16313 1
a16313 1
                if ((ANYOF_FLAGS(ret) & ANYOF_POSIXL)
d16386 20
a16405 1
                else {  /* Garden variety class.  If is NASCII, NDIGIT, ...
a16409 1
                    SV** source_ptr = &PL_XPosix_ptrs[classnum];
d16412 1
a16412 1
                                                     *source_ptr,
a16415 1
                continue;   /* Go get next character */
d16419 10
a16428 11
        /* Here, we have a single value.  If 'range' is set, it is the ending
         * of a range--check its validity.  Later, we will handle each
         * individual code point in the range.  If 'range' isn't set, this
         * could be the beginning of a range, so check for that by looking
         * ahead to see if the next real character to be processed is the range
         * indicator--the minus sign */

        if (skip_white) {
            RExC_parse = regpatws(pRExC_state, RExC_parse,
                                FALSE /* means don't recognize comments */);
        }
d16431 11
d16443 5
a16447 1
		const int w = RExC_parse - rangebegin;
d16451 1
a16451 1
		range = 0; /* not a valid range */
d16460 3
a16462 6
                if (skip_white) {   /* Get the next real char after the '-' */
                    next_char_ptr = regpatws(pRExC_state,
                                             RExC_parse + 1,
                                             FALSE); /* means don't recognize
                                                        comments */
                }
d16471 4
a16474 4
                        if (strict || ckWARN(WARN_REGEXP)) {
                            const int w =
                                RExC_parse >= rangebegin ?
                                RExC_parse - rangebegin : 0;
d16479 1
a16479 1
                            else {
d16496 7
a16502 2
        /* Here, <prevvalue> is the beginning of the range, if any; or <value>
         * if not */
d16507 1
a16507 1
	    RExC_uni_semantics = 1;
a16549 2
                        AV** this_array_ptr;
                        AV* this_array;
d16552 1
a16552 1
                        SV* multi_fold = sv_2mortal(newSVpvn("", 0));
d16556 19
d16576 24
a16599 3
                        if (! multi_char_matches) {
                            multi_char_matches = newAV();
                        }
d16601 33
a16633 18
                        /* <multi_char_matches> is actually an array of arrays.
                         * There will be one or two top-level elements: [2],
                         * and/or [3].  The [2] element is an array, each
                         * element thereof is a character which folds to TWO
                         * characters; [3] is for folds to THREE characters.
                         * (Unicode guarantees a maximum of 3 characters in any
                         * fold.)  When we rewrite the character class below,
                         * we will do so such that the longest folds are
                         * written first, so that it prefers the longest
                         * matching strings first.  This is done even if it
                         * turns out that any quantifier is non-greedy, out of
                         * programmer laziness.  Tom Christiansen has agreed
                         * that this is ok.  This makes the test for the
                         * ligature 'ffi' come before the test for 'ff' */
                        if (av_exists(multi_char_matches, cp_count)) {
                            this_array_ptr = (AV**) av_fetch(multi_char_matches,
                                                             cp_count, FALSE);
                            this_array = *this_array_ptr;
d16635 6
a16640 4
                        else {
                            this_array = newAV();
                            av_store(multi_char_matches, cp_count,
                                     (SV*) this_array);
a16641 1
                        av_push(this_array, multi_fold);
d16643 26
a16668 7

                    /* This element should not be processed further in this
                     * class */
                    element_count--;
                    value = save_value;
                    prevvalue = save_prevvalue;
                    continue;
d16675 1
d16680 10
a16689 14
            SV* this_range = _new_invlist(1);
            _append_range_to_invlist(this_range, prevvalue, value);

            /* In EBCDIC, the ranges 'A-Z' and 'a-z' are each not contiguous.
             * If this range was specified using something like 'i-j', we want
             * to include only the 'i' and the 'j', and not anything in
             * between, so exclude non-ASCII, non-alphabetics from it.
             * However, if the range was specified with something like
             * [\x89-\x91] or [\x89-j], all code points within it should be
             * included.  literal_endpoint==2 means both ends of the range used
             * a literal character, not \x{foo} */
	    if (literal_endpoint == 2
                && ((prevvalue >= 'a' && value <= 'z')
                    || (prevvalue >= 'A' && value <= 'Z')))
d16691 22
a16712 7
                _invlist_intersection(this_range, PL_ASCII,
                                      &this_range);

                /* Since this above only contains ascii, the intersection of it
                 * with anything will still yield only ascii */
                _invlist_intersection(this_range, PL_XPosix_ptrs[_CC_ALPHA],
                                      &this_range);
a16713 2
            _invlist_union(cp_foldable_list, this_range, &cp_foldable_list);
            literal_endpoint = 0;
d16720 6
d16735 4
d16744 2
d16754 4
a16757 1
        for (cp_count = av_tindex(multi_char_matches); cp_count > 0; cp_count--) {
d16782 1
d16784 6
a16789 1
            sv_catpv(substitute_parse, "]");
d16802 6
a16807 1
	RExC_parse = SvPV(substitute_parse, len);
d16810 1
d16815 1
a16815 1
	*flagp |= reg_flags&(HASWIDTH|SIMPLE|SPSTART|POSTPONED|RESTART_UTF8);
d16817 4
a16820 1
	RExC_parse = save_parse;
d16823 1
d16838 3
a16840 2
    if (! ret_invlist   /* Can't optimize if returning the constructed
                           inversion list */
d16849 3
a16851 3
        else if (namedclass > OOB_NAMEDCLASS) { /* this is a named class, like
                                                   \w or [:digit:] or \p{foo}
                                                 */
d16873 1
a16873 1
                 * ASCII or, if available on this platform, locale */
d16883 15
a16897 1
                case ANYOF_NCASED:
a16901 1
                    /* under /a could be alpha */
d16903 1
a16903 6
                        if (ASCII_RESTRICTED) {
                            namedclass = ANYOF_ALPHA + (namedclass % 2);
                        }
                        else if (! LOC) {
                            break;
                        }
d16911 1
d16917 1
a16917 1
                join_posix:
d16936 1
a16936 1
                    RExC_naughty++;
d16953 24
d17028 1
d17051 1
a17051 1
             * non-locale, we just use to the general list */
d17073 1
a17073 12

                    /* If the folds haven't been read in, call a fold function
                     * to force that */
                    if (! PL_utf8_tofold) {
                        U8 dummy[UTF8_MAXBYTES_CASE+1];

                        /* This string is just a short named one above \xff */
                        to_utf8_fold((U8*) HYPHEN_UTF8, dummy, NULL);
                        assert(PL_utf8_tofold); /* Verify that worked */
                    }
                    PL_utf8_foldclosures
                                      = _swash_inversion_hash(PL_utf8_tofold);
a17089 9
                        /* We have the latin1 folding rules hard-coded here so
                         * that an innocent-looking character class, like
                         * /[ks]/i won't have to go out to disk to find the
                         * possible matches.  XXX It would be better to
                         * generate these via regen, in case a new version of
                         * the Unicode standard adds new mappings, though that
                         * is not really likely, and may be caught by the
                         * default: case of the switch below. */

d17100 4
a17103 3
                                depends_list =
                                 add_cp_to_invlist(depends_list,
                                                   PL_fold_latin1[j]);
d17107 1
a17107 1
                        if (HAS_NONLATIN1_FOLD_CLOSURE(j)
d17110 3
a17112 63
                            /* Certain Latin1 characters have matches outside
                            * Latin1.  To get here, <j> is one of those
                            * characters.   None of these matches is valid for
                            * ASCII characters under /aa, which is why the 'if'
                            * just above excludes those.  These matches only
                            * happen when the target string is utf8.  The code
                            * below adds the single fold closures for <j> to the
                            * inversion list. */

                            switch (j) {
                                case 'k':
                                case 'K':
                                  *use_list =
                                     add_cp_to_invlist(*use_list, KELVIN_SIGN);
                                    break;
                                case 's':
                                case 'S':
                                  *use_list = add_cp_to_invlist(*use_list,
                                                    LATIN_SMALL_LETTER_LONG_S);
                                    break;
                                case MICRO_SIGN:
                                  *use_list = add_cp_to_invlist(*use_list,
                                                      GREEK_CAPITAL_LETTER_MU);
                                  *use_list = add_cp_to_invlist(*use_list,
                                                        GREEK_SMALL_LETTER_MU);
                                    break;
                                case LATIN_CAPITAL_LETTER_A_WITH_RING_ABOVE:
                                case LATIN_SMALL_LETTER_A_WITH_RING_ABOVE:
                                  *use_list =
                                   add_cp_to_invlist(*use_list, ANGSTROM_SIGN);
                                    break;
                                case LATIN_SMALL_LETTER_Y_WITH_DIAERESIS:
                                  *use_list = add_cp_to_invlist(*use_list,
                                        LATIN_CAPITAL_LETTER_Y_WITH_DIAERESIS);
                                    break;
                                case LATIN_SMALL_LETTER_SHARP_S:
                                  *use_list = add_cp_to_invlist(*use_list,
                                                 LATIN_CAPITAL_LETTER_SHARP_S);
                                    break;
                                case 'F': case 'f':
                                case 'I': case 'i':
                                case 'L': case 'l':
                                case 'T': case 't':
                                case 'A': case 'a':
                                case 'H': case 'h':
                                case 'J': case 'j':
                                case 'N': case 'n':
                                case 'W': case 'w':
                                case 'Y': case 'y':
                                    /* These all are targets of multi-character
                                     * folds from code points that require UTF8
                                     * to express, so they can't match unless
                                     * the target string is in UTF-8, so no
                                     * action here is necessary, as regexec.c
                                     * properly handles the general case for
                                     * UTF-8 matching and multi-char folds */
                                    break;
                                default:
                                    /* Use deprecated warning to increase the
                                    * chances of this being output */
                                    ckWARN2reg_d(RExC_parse, "Perl folding rules are not up-to-date for 0x%"UVXf"; please use the perlbug utility to report;", j);
                                    break;
                            }
d17138 1
a17138 1
                        for (k = 0; k <= av_tindex(list); k++) {
d17141 2
a17142 3
                            if (c_p == NULL) {
                                Perl_croak(aTHX_ "panic: invalid PL_utf8_foldclosures structure");
                            }
d17167 4
a17170 2
                                depends_list = add_cp_to_invlist(depends_list,
                                                                 c);
d17189 4
d17204 1
a17204 1
                ANYOF_FLAGS(ret) |= ANYOF_NON_UTF8_NON_ASCII_ALL;
d17246 4
a17249 3
            if (depends_list) {
                _invlist_union(depends_list, nonascii_but_latin1_properties,
                               &depends_list);
d17253 2
a17254 1
                depends_list = nonascii_but_latin1_properties;
d17268 2
a17269 2
     * <depends_list>, because having a Unicode property forces Unicode
     * semantics */
d17276 1
a17276 1
             * such code point is specified, as though not strictly correct if
d17293 6
a17298 1
            ANYOF_FLAGS(ret) |= ANYOF_WARN_SUPER;
d17317 13
d17331 3
a17333 1
            ANYOF_FLAGS(ret) |= ANYOF_LOC_FOLD;
d17335 1
a17335 2
        else if (cp_list) { /* Look to see if there a 0-255 code point is in
                               the list */
d17339 1
a17339 1
                ANYOF_FLAGS(ret) |= ANYOF_LOC_FOLD;
d17345 73
d17424 1
a17425 1
	&& ! depends_list
d17441 2
d17467 8
a17474 9
     * earlier code.  I (khw) am not sure how much to look for here.  It would
     * be easy, but perhaps too slow, to check any candidates against all the
     * node types they could possibly match using _invlistEQ(). */

    if (cp_list
        && ! invert
        && ! depends_list
        && ! (ANYOF_FLAGS(ret) & (ANYOF_LOCALE_FLAGS))
        && ! HAS_NONLOCALE_RUNTIME_PROPERTY_DEFINITION
d17476 1
a17476 5
           /* We don't optimize if we are supposed to make sure all non-Unicode
            * code points raise a warning, as only ANYOF nodes have this check.
            * */
        && ! ((ANYOF_FLAGS(ret) | ANYOF_WARN_SUPER) && ALWAYS_WARN_SUPER))
    {
d17479 1
d17486 3
a17488 3
             * Unicode property is the only thing in the character class, and
             * it doesn't match anything.  (perluniprops.pod notes such
             * properties) */
d17505 3
a17507 1
                    op = EXACT;
d17544 1
a17544 1
        }
d17549 1
a17549 1
                RExC_naughty++;
d17557 1
a17557 1
                RExC_naughty++;
d17562 43
d17609 5
a17613 1
            ret = reg_node(pRExC_state, op);
d17622 3
d17645 3
a17647 2
     * when the target string is UTF-8 (<depends_list>). */
    if (depends_list) {
d17649 4
a17652 2
	    _invlist_union(cp_list, depends_list, &cp_list);
	    SvREFCNT_dec_NN(depends_list);
d17655 1
a17655 1
	    cp_list = depends_list;
d17657 1
a17657 1
        ANYOF_FLAGS(ret) |= ANYOF_UTF8;
d17667 4
d17699 1
a17699 1
     * arg is set to ANYOF_NONBITMAP_EMPTY.  Otherwise, it sets the argument to
d17725 2
a17726 2
                    & (ANYOF_UTF8|ANYOF_NONBITMAP_NON_UTF8)));
	ARG_SET(node, ANYOF_NONBITMAP_EMPTY);
a17731 3
        assert(ANYOF_FLAGS(node)
                    & (ANYOF_UTF8|ANYOF_NONBITMAP_NON_UTF8|ANYOF_LOC_FOLD));

d17735 1
d17761 240
d18004 5
a18008 4
   Absorbs an /x style # comments from the input stream.
   Returns true if there is more text remaining in the stream.
   Will set the REG_RUN_ON_COMMENT_SEEN flag if the comment
   terminates the pattern without including a newline.
d18010 1
a18010 1
   Note its the callers responsibility to ensure that we are
d18015 2
a18016 2
STATIC bool
S_reg_skipcomment(pTHX_ RExC_state_t *pRExC_state)
d18018 1
a18018 1
    bool ended = 0;
d18020 1
a18020 1
    PERL_ARGS_ASSERT_REG_SKIPCOMMENT;
d18022 3
a18024 4
    while (RExC_parse < RExC_end)
        if (*RExC_parse++ == '\n') {
            ended = 1;
            break;
d18026 6
a18031 7
    if (!ended) {
        /* we ran off the end of the pattern without ending
           the comment, so we have to add an \n when wrapping */
        RExC_seen |= REG_RUN_ON_COMMENT_SEEN;
        return 0;
    } else
        return 1;
d18034 10
a18043 9
/* nextchar()

   Advances the parse position, and optionally absorbs
   "whitespace" from the inputstream.

   Without /x "whitespace" means (?#...) style comments only,
   with /x this means (?#...) and # comments and whitespace proper.

   Returns the RExC_parse point from BEFORE the scan occurs.
d18045 1
a18045 2
   This is the /x friendly way of saying RExC_parse++.
*/
d18047 1
a18047 4
STATIC char*
S_nextchar(pTHX_ RExC_state_t *pRExC_state)
{
    char* const retval = RExC_parse++;
d18049 1
a18049 1
    PERL_ARGS_ASSERT_NEXTCHAR;
d18052 4
a18055 4
	if (RExC_end - RExC_parse >= 3
	    && *RExC_parse == '('
	    && RExC_parse[1] == '?'
	    && RExC_parse[2] == '#')
d18057 2
a18058 2
	    while (*RExC_parse != ')') {
		if (RExC_parse == RExC_end)
d18060 1
a18060 1
		RExC_parse++;
d18062 1
a18062 1
	    RExC_parse++;
d18065 18
a18082 9
	if (RExC_flags & RXf_PMf_EXTENDED) {
	    if (isSPACE(*RExC_parse)) {
		RExC_parse++;
		continue;
	    }
	    else if (*RExC_parse == '#') {
	        if ( reg_skipcomment( pRExC_state ) )
	            continue;
	    }
d18084 2
a18085 1
	return retval;
d18087 2
d18091 8
a18098 2
/*
- reg_node - emit a node
d18100 20
a18119 2
STATIC regnode *			/* Location. */
S_reg_node(pTHX_ RExC_state_t *pRExC_state, U8 op)
d18121 4
a18124 2
    dVAR;
    regnode *ptr;
d18128 3
a18130 1
    PERL_ARGS_ASSERT_REG_NODE;
d18134 1
a18134 1
	RExC_size += 1;
d18139 1
a18139 1
		   op, RExC_emit, RExC_emit_bound);
d18142 3
a18144 3
    ptr = ret;
    FILL_ADVANCE_NODE(ptr, op);
#ifdef RE_TRACK_PATTERN_OFFSETS
d18148 1
a18148 1
              "reg_node", __LINE__,
a18157 1
    RExC_emit = ptr;
d18162 1
a18162 1
- reganode - emit a node with an argument
d18165 1
a18165 1
S_reganode(pTHX_ RExC_state_t *pRExC_state, U8 op, U32 arg)
d18167 1
a18167 4
    dVAR;
    regnode *ptr;
    regnode * const ret = RExC_emit;
    GET_RE_DEBUG_FLAGS_DECL;
d18169 1
a18169 12
    PERL_ARGS_ASSERT_REGANODE;

    if (SIZE_ONLY) {
	SIZE_ALIGN(RExC_size);
	RExC_size += 2;
	/*
	   We can't do this:

	   assert(2==regarglen[op]+1);

	   Anything larger than this has to allocate the extra amount.
	   If we changed this to be:
d18171 1
a18171 11
	   RExC_size += (1 + regarglen[op]);

	   then it wouldn't matter. Its not clear what side effect
	   might come from that so its not done so far.
	   -- dmq
	*/
	return(ret);
    }
    if (RExC_emit >= RExC_emit_bound)
        Perl_croak(aTHX_ "panic: reg_node overrun trying to emit %d, %p>=%p",
		   op, RExC_emit, RExC_emit_bound);
d18173 4
a18176 16
    NODE_ALIGN_FILL(ret);
    ptr = ret;
    FILL_ADVANCE_NODE_ARG(ptr, op, arg);
#ifdef RE_TRACK_PATTERN_OFFSETS
    if (RExC_offsets) {         /* MJD */
	MJD_OFFSET_DEBUG(
              ("%s(%d): (op %s) %s %"UVuf" <- %"UVuf" (max %"UVuf").\n",
              "reganode",
	      __LINE__,
	      PL_reg_name[op],
              (UV)(RExC_emit - RExC_emit_start) > RExC_offsets[0] ?
              "Overwriting end of array!\n" : "OK",
              (UV)(RExC_emit - RExC_emit_start),
              (UV)(RExC_parse - RExC_start),
              (UV)RExC_offsets[0]));
	Set_Cur_Node_Offset;
a18177 2
#endif
    RExC_emit = ptr;
d18182 1
a18182 1
- reguni - emit (if appropriate) a Unicode character
d18184 19
a18202 2
PERL_STATIC_INLINE STRLEN
S_reguni(pTHX_ const RExC_state_t *pRExC_state, UV uv, char* s)
d18204 5
a18208 1
    dVAR;
d18210 1
a18210 1
    PERL_ARGS_ASSERT_REGUNI;
d18212 6
a18217 1
    return SIZE_ONLY ? UNISKIP(uv) : (uvchr_to_utf8((U8*)s, uv) - (U8*)s);
a18227 1
    dVAR;
d18236 1
d18251 3
d18269 2
a18318 1
/* TODO: All three parms should be const */
d18320 4
a18323 2
S_regtail(pTHX_ RExC_state_t *pRExC_state, regnode *p,
                const regnode *val,U32 depth)
a18324 1
    dVAR;
d18337 1
a18337 1
    scan = p;
a18340 1
            SV * const mysv=sv_newmortal();
d18342 3
a18344 3
            regprop(RExC_rx, mysv, scan, NULL);
            PerlIO_printf(Perl_debug_log, "~ %s (%d) %s %s\n",
                SvPV_nolen_const(mysv), REG_NODE_NUM(scan),
a18382 1
    dVAR;
d18412 1
d18417 1
a18430 1
            SV * const mysv=sv_newmortal();
d18432 3
a18434 3
            regprop(RExC_rx, mysv, scan, NULL);
            PerlIO_printf(Perl_debug_log, "~ %s (%d) -> %s\n",
                SvPV_nolen_const(mysv),
a18442 1
        SV * const mysv_val=sv_newmortal();
d18444 2
a18445 2
        regprop(RExC_rx, mysv_val, val, NULL);
        PerlIO_printf(Perl_debug_log,
d18447 1
a18447 1
		      SvPV_nolen_const(mysv_val),
d18479 2
a18480 2
                PerlIO_printf(Perl_debug_log, "%s",lead);
            PerlIO_printf(Perl_debug_log, "%s ",PL_reg_intflags_name[bit]);
d18485 1
a18485 1
            PerlIO_printf(Perl_debug_log, "\n");
d18487 1
a18487 1
            PerlIO_printf(Perl_debug_log, "%s[none-set]\n",lead);
d18506 2
a18507 2
                PerlIO_printf(Perl_debug_log, "%s",lead);
            PerlIO_printf(Perl_debug_log, "%s ",PL_reg_extflags_name[bit]);
d18512 1
a18512 1
                PerlIO_printf(Perl_debug_log, "%s",lead);
d18516 1
a18516 1
                    PerlIO_printf(Perl_debug_log, "UNICODE");
d18519 1
a18519 1
                    PerlIO_printf(Perl_debug_log, "LOCALE");
d18522 1
a18522 1
                    PerlIO_printf(Perl_debug_log, "ASCII-RESTRICTED");
d18525 1
a18525 1
                    PerlIO_printf(Perl_debug_log, "ASCII-MORE_RESTRICTED");
d18528 1
a18528 1
                    PerlIO_printf(Perl_debug_log, "UNKNOWN CHARACTER SET");
d18534 1
a18534 1
            PerlIO_printf(Perl_debug_log, "\n");
d18536 1
a18536 1
            PerlIO_printf(Perl_debug_log, "%s[none-set]\n",lead);
a18544 1
    dVAR;
d18558 1
a18558 1
	PerlIO_printf(Perl_debug_log,
d18565 1
a18565 1
	PerlIO_printf(Perl_debug_log,
d18573 1
a18573 1
	PerlIO_printf(Perl_debug_log,
d18580 1
a18580 1
	PerlIO_printf(Perl_debug_log,
d18586 1
a18586 1
	PerlIO_printf(Perl_debug_log,
d18592 1
a18592 1
	PerlIO_printf(Perl_debug_log, " noscan");
d18594 1
a18594 1
	PerlIO_printf(Perl_debug_log, " isall");
d18596 1
a18596 1
	PerlIO_printf(Perl_debug_log, ") ");
d18599 2
a18600 2
	regprop(r, sv, ri->regstclass, NULL);
	PerlIO_printf(Perl_debug_log, "stclass %s ", SvPVX_const(sv));
d18603 1
a18603 3
	PerlIO_printf(Perl_debug_log, "anchored");
        if (r->intflags & PREGf_ANCH_BOL)
	    PerlIO_printf(Perl_debug_log, "(BOL)");
d18605 1
a18605 1
	    PerlIO_printf(Perl_debug_log, "(MBOL)");
d18607 1
a18607 1
	    PerlIO_printf(Perl_debug_log, "(SBOL)");
d18609 2
a18610 2
	    PerlIO_printf(Perl_debug_log, "(GPOS)");
	PerlIO_putc(Perl_debug_log, ' ');
d18613 1
a18613 1
	PerlIO_printf(Perl_debug_log, "GPOS:%"UVuf" ", (UV)r->gofs);
d18615 1
a18615 1
	PerlIO_printf(Perl_debug_log, "plus ");
d18617 2
a18618 2
	PerlIO_printf(Perl_debug_log, "implicit ");
    PerlIO_printf(Perl_debug_log, "minlen %"IVdf" ", (IV)r->minlen);
d18620 2
a18621 2
	PerlIO_printf(Perl_debug_log, "with eval ");
    PerlIO_printf(Perl_debug_log, "\n");
d18633 47
d18685 1
a18685 1
Perl_regprop(pTHX_ const regexp *prog, SV *sv, const regnode *o, const regmatch_info *reginfo)
a18687 1
    dVAR;
a18688 46

    /* Should be synchronized with * ANYOF_ #xdefines in regcomp.h */
    static const char * const anyofs[] = {
#if _CC_WORDCHAR != 0 || _CC_DIGIT != 1 || _CC_ALPHA != 2 || _CC_LOWER != 3 \
    || _CC_UPPER != 4 || _CC_PUNCT != 5 || _CC_PRINT != 6                   \
    || _CC_ALPHANUMERIC != 7 || _CC_GRAPH != 8 || _CC_CASED != 9            \
    || _CC_SPACE != 10 || _CC_BLANK != 11 || _CC_XDIGIT != 12               \
    || _CC_PSXSPC != 13 || _CC_CNTRL != 14 || _CC_ASCII != 15               \
    || _CC_VERTSPACE != 16
  #error Need to adjust order of anyofs[]
#endif
        "\\w",
        "\\W",
        "\\d",
        "\\D",
        "[:alpha:]",
        "[:^alpha:]",
        "[:lower:]",
        "[:^lower:]",
        "[:upper:]",
        "[:^upper:]",
        "[:punct:]",
        "[:^punct:]",
        "[:print:]",
        "[:^print:]",
        "[:alnum:]",
        "[:^alnum:]",
        "[:graph:]",
        "[:^graph:]",
        "[:cased:]",
        "[:^cased:]",
        "\\s",
        "\\S",
        "[:blank:]",
        "[:^blank:]",
        "[:xdigit:]",
        "[:^xdigit:]",
        "[:space:]",
        "[:^space:]",
        "[:cntrl:]",
        "[:^cntrl:]",
        "[:ascii:]",
        "[:^ascii:]",
        "\\v",
        "\\V"
    };
d18694 1
a18694 1
    sv_setpvs(sv, "");
d18744 8
a18751 3
            (void) put_latin1_charclass_innards(sv, IS_ANYOF_TRIE(op)
                                                   ? ANYOF_BITMAP(o)
                                                   : TRIE_BITMAP(trie));
d18756 1
d18759 6
a18764 1
	Perl_sv_catpvf(aTHX_ sv, " {%d,%d}", ARG1(o), ARG2(o));
d18771 3
a18773 1
	Perl_sv_catpvf(aTHX_ sv, "%d", (int)ARG(o));	/* Parenth number */
d18775 5
d18781 1
a18781 2
	        AV *list= MUTABLE_AV(progi->data->data[progi->name_list_idx]);
	        SV **name= av_fetch(list, ARG(o), 0 );
d18786 1
a18786 2
                AV *list= MUTABLE_AV(progi->data->data[ progi->name_list_idx ]);
                SV *sv_dat= MUTABLE_SV(progi->data->data[ ARG( o ) ]);
d18788 1
a18788 1
                SV **name= av_fetch(list, nums[0], 0 );
d18813 8
a18820 1
    } else if (k == GOSUB)
d18822 9
a18830 6
	Perl_sv_catpvf(aTHX_ sv, "%d[%+d]", (int)ARG(o),(int)ARG2L(o));
    else if (k == VERB) {
        if (!o->flags)
            Perl_sv_catpvf(aTHX_ sv, ":%"SVf,
			   SVfARG((MUTABLE_SV(progi->data->data[ ARG( o ) ]))));
    } else if (k == LOGICAL)
d18835 22
a18856 1
	int do_sep = 0;
d18858 26
d18885 1
a18885 4
	if (flags & ANYOF_LOCALE_FLAGS)
	    sv_catpvs(sv, "{loc}");
	if (flags & ANYOF_LOC_FOLD)
	    sv_catpvs(sv, "{i}");
a18886 2
	if (flags & ANYOF_INVERT)
	    sv_catpvs(sv, "^");
d18888 16
a18903 12
	/* output what the standard cp 0-255 bitmap matches */
        do_sep = put_latin1_charclass_innards(sv, ANYOF_BITMAP(o));

        /* output any special charclass tests (used entirely under use
         * locale) * */
	if (ANYOF_POSIXL_TEST_ANY_SET(o)) {
            int i;
	    for (i = 0; i < ANYOF_POSIXL_MAX; i++) {
		if (ANYOF_POSIXL_TEST(o,i)) {
		    sv_catpv(sv, anyofs[i]);
		    do_sep = 1;
		}
d18905 3
d18910 10
a18919 5
	if ((flags & (ANYOF_ABOVE_LATIN1_ALL
                      |ANYOF_UTF8
                      |ANYOF_NONBITMAP_NON_UTF8
                      |ANYOF_LOC_FOLD)))
        {
d18922 1
a18922 24
                if (flags & ANYOF_INVERT)
                    /*make sure the invert info is in each */
                    sv_catpvs(sv, "^");
            }

            if (flags & ANYOF_NON_UTF8_NON_ASCII_ALL) {
                sv_catpvs(sv, "{non-utf8-latin1-all}");
            }

            /* output information about the unicode matching */
            if (flags & ANYOF_ABOVE_LATIN1_ALL)
                sv_catpvs(sv, "{unicode_all}");
            else if (ARG(o) != ANYOF_NONBITMAP_EMPTY) {
                SV *lv; /* Set if there is something outside the bit map. */
                bool byte_output = FALSE;   /* If something in the bitmap has
                                               been output */
                SV *only_utf8_locale;

                /* Get the stuff that wasn't in the bitmap */
                (void) _get_regclass_nonbitmap_data(prog, o, FALSE,
                                                    &lv, &only_utf8_locale);
                if (lv && lv != &PL_sv_undef) {
                    char *s = savesvpv(lv);
                    char * const origs = s;
d18924 6
a18929 2
                    while (*s && *s != '\n')
                        s++;
d18931 11
a18941 2
                    if (*s == '\n') {
                        const char * const t = ++s;
d18943 8
a18950 39
                        if (flags & ANYOF_NONBITMAP_NON_UTF8) {
                            sv_catpvs(sv, "{outside bitmap}");
                        }
                        else {
                            sv_catpvs(sv, "{utf8}");
                        }

                        if (byte_output) {
                            sv_catpvs(sv, " ");
                        }

                        while (*s) {
                            if (*s == '\n') {

                                /* Truncate very long output */
                                if (s - origs > 256) {
                                    Perl_sv_catpvf(aTHX_ sv,
                                                "%.*s...",
                                                (int) (s - origs - 1),
                                                t);
                                    goto out_dump;
                                }
                                *s = ' ';
                            }
                            else if (*s == '\t') {
                                *s = '-';
                            }
                            s++;
                        }
                        if (s[-1] == ' ')
                            s[-1] = 0;

                        sv_catpv(sv, t);
                    }

                out_dump:

                    Safefree(origs);
                    SvREFCNT_dec_NN(lv);
d18953 3
a18955 6
                if ((flags & ANYOF_LOC_FOLD)
                     && only_utf8_locale
                     && only_utf8_locale != &PL_sv_undef)
                {
                    UV start, end;
                    int max_entries = 256;
d18957 3
a18959 15
                    sv_catpvs(sv, "{utf8 locale}");
                    invlist_iterinit(only_utf8_locale);
                    while (invlist_iternext(only_utf8_locale,
                                            &start, &end)) {
                        put_range(sv, start, end);
                        max_entries --;
                        if (max_entries < 0) {
                            sv_catpvs(sv, "...");
                            break;
                        }
                    }
                    invlist_iterfinish(only_utf8_locale);
                }
            }
	}
d18961 1
d18979 12
d18993 8
d19007 1
a19015 1
    dVAR;
d19024 2
a19025 2
	    const char * const s = SvPV_nolen_const(prog->check_substr
		      ? prog->check_substr : prog->check_utf8);
d19028 1
a19028 1
	    PerlIO_printf(Perl_debug_log,
d19031 1
a19031 1
		      prog->check_substr ? "" : "utf8 ",
d19038 2
a19039 1
    return prog->check_substr ? prog->check_substr : prog->check_utf8;
a19063 1
    dVAR;
d19089 2
d19174 2
a19195 1
    dVAR;
d19209 1
a19209 1
            PerlIO_printf(Perl_debug_log,"%sFreeing REx:%s %s\n",
d19248 3
d19259 10
a19268 1
                        PerlMemShared_free(ri->regstclass);
d19277 3
d19314 1
a19314 1
   re_dup - duplicate a regexp.
d19382 2
d19438 1
d19488 1
a19488 1
		/* Fall through */
d19493 1
a19493 1
		/* Fall through */
d19499 1
a19499 1
		Perl_croak(aTHX_ "panic: re_dup unknown data code '%c'",
a19532 1
    dVAR;
a19587 1
    dVAR;
d19626 1
a19626 1
S_put_byte(pTHX_ SV *sv, int c)
d19628 1
a19628 1
    PERL_ARGS_ASSERT_PUT_BYTE;
d19630 5
a19634 7
    if (!isPRINT(c)) {
        switch (c) {
            case '\r': Perl_sv_catpvf(aTHX_ sv, "\\r"); break;
            case '\n': Perl_sv_catpvf(aTHX_ sv, "\\n"); break;
            case '\t': Perl_sv_catpvf(aTHX_ sv, "\\t"); break;
            case '\f': Perl_sv_catpvf(aTHX_ sv, "\\f"); break;
            case '\a': Perl_sv_catpvf(aTHX_ sv, "\\a"); break;
d19636 8
a19643 4
            default:
                Perl_sv_catpvf(aTHX_ sv, "\\x{%x}", c);
                break;
        }
d19646 1
a19646 4
	const char string = c;
	if (c == '-' || c == ']' || c == '\\' || c == '^')
	    sv_catpvs(sv, "\\");
	sv_catpvn(sv, &string, 1);
d19650 2
d19653 1
a19653 1
S_put_range(pTHX_ SV *sv, UV start, UV end)
d19655 10
d19666 1
a19666 2
    /* Appends to 'sv' a displayable version of the range of code points from
     * 'start' to 'end' */
d19672 277
a19948 28
    if (end - start < 3) {  /* Individual chars in short ranges */
        for (; start <= end; start++)
            put_byte(sv, start);
    }
    else if (   end > 255
             || ! isALPHANUMERIC(start)
             || ! isALPHANUMERIC(end)
             || isDIGIT(start) != isDIGIT(end)
             || isUPPER(start) != isUPPER(end)
             || isLOWER(start) != isLOWER(end)

                /* This final test should get optimized out except on EBCDIC
                 * platforms, where it causes ranges that cross discontinuities
                 * like i/j to be shown as hex instead of the misleading,
                 * e.g. H-K (since that range includes more than H, I, J, K).
                 * */
             || (end - start) != NATIVE_TO_ASCII(end) - NATIVE_TO_ASCII(start))
    {
        Perl_sv_catpvf(aTHX_ sv, "\\x{%02" UVXf "}-\\x{%02" UVXf "}",
                       start,
                       (end < 256) ? end : 255);
    }
    else { /* Here, the ends of the range are both digits, or both uppercase,
              or both lowercase; and there's no discontinuity in the range
              (which could happen on EBCDIC platforms) */
        put_byte(sv, start);
        sv_catpvs(sv, "-");
        put_byte(sv, end);
d19950 2
d19955 5
a19959 1
S_put_latin1_charclass_innards(pTHX_ SV *sv, char *bitmap)
d19962 28
a19989 2
     * character class whose bitmap is 'bitmap';  Returns 'TRUE' if it actually
     * output anything */
d19992 55
a20046 1
    bool has_output_anything = FALSE;
d20048 6
a20053 1
    PERL_ARGS_ASSERT_PUT_LATIN1_CHARCLASS_INNARDS;
d20055 4
a20058 2
    for (i = 0; i < 256; i++) {
        if (BITMAP_TEST((U8 *) bitmap,i)) {
d20060 5
a20064 6
            /* The character at index i should be output.  Find the next
             * character that should NOT be output */
            int j;
            for (j = i + 1; j < 256; j++) {
                if (! BITMAP_TEST((U8 *) bitmap, j)) {
                    break;
d20067 106
d20174 9
a20182 5
            /* Everything between them is a single range that should be output
             * */
            put_range(sv, i, j - 1);
            has_output_anything = TRUE;
            i = j;
d20184 3
d20189 7
a20195 1
    return has_output_anything;
d20198 1
a20198 1
#define CLEAR_OPTSTART \
d20200 1
a20200 1
        DEBUG_OPTIMISE_r(PerlIO_printf(Perl_debug_log,                       \
d20202 1
a20202 1
	optstart=NULL;                                                       \
a20213 1
    dVAR;
d20224 1
a20224 1
    PerlIO_printf(Perl_debug_log, "--- %d : %d - %d - %d\n",indent,node-start,
d20232 1
d20249 2
a20250 2
	regprop(r, sv, node, NULL);
	PerlIO_printf(Perl_debug_log, "%4"IVdf":%*s%s", (IV)(node - start),
d20255 1
a20255 1
                PerlIO_printf(Perl_debug_log, " (0)");
d20258 1
a20258 1
                PerlIO_printf(Perl_debug_log, " (FAIL)");
d20260 2
a20261 2
                PerlIO_printf(Perl_debug_log, " (%"IVdf")", (IV)(next - start));
            (void)PerlIO_putc(Perl_debug_log, '\n');
d20299 2
a20300 2
                PerlIO_printf(Perl_debug_log, "%*s%s ",
                   (int)(2*(indent+3)), "",
d20315 1
a20315 1
		    PerlIO_printf(Perl_debug_log, "(%"UVuf")\n",
d20325 1
a20325 1
                    PerlIO_printf(Perl_debug_log, "\n");
d20346 1
a20346 1
	    node += 1 + ((ANYOF_FLAGS(node) & ANYOF_POSIXL)
d20365 1
a20365 1
    PerlIO_printf(Perl_debug_log, "--- %d\n", (int)indent);
a20372 6
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
@


1.20
log
@Fix merge issues, remove excess files - match perl-5.20.2 dist
@
text
@d10458 1
a10458 3
            else if (min == max
                     && RExC_parse < RExC_end
                     && (*RExC_parse == '?' || *RExC_parse == '+'))
d16472 2
d16476 1
d16479 24
a16502 16
	if (rx) {
	    U32 i;
	    for (i = 1; i <= RX_NPARENS(rx); i++) {
		char digits[TYPE_CHARS(long)];
		const STRLEN len = my_snprintf(digits, sizeof(digits),
                                               "%lu", (long)i);
		GV *const *const gvp
		    = (GV**)hv_fetch(PL_defstash, digits, len, 0);

		if (gvp) {
		    GV * const gv = *gvp;
		    if (SvTYPE(gv) == SVt_PVGV && GvSV(gv))
			save_scalar(gv);
		}
	    }
	}
@


1.19
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d4809 1
a4809 1
                SV* my_invlist = sv_2mortal(_new_invlist(0));
d4908 1
a4908 1
                        my_invlist = PL_XPosix_ptrs[_CC_ASCII];
d4945 1
d12004 11
a12014 1
                        const STRLEN unilen = reguni(pRExC_state, ender, s);
d12026 4
@


1.18
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d84 1
a84 1
extern const struct regexp_engine my_reg_engine;
d94 2
a95 1
#define HAS_NONLATIN1_FOLD_CLOSURE(i) _HAS_NONLATIN1_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(i)
a98 13
#ifdef op
#undef op
#endif /* op */

#ifdef MSDOS
#  if defined(BUGGY_MSC6)
 /* MSC 6.00A breaks on op/regexp.t test 85 unless we turn this off */
#    pragma optimize("a",off)
 /* But MSC 6.00A is happy with 'w', for aliases only across function calls*/
#    pragma optimize("w",on )
#  endif /* BUGGY_MSC6 */
#endif /* MSDOS */

d104 1
a104 1
typedef struct RExC_state_t {
d110 2
a111 1
    regexp_internal	*rxi;           /* internal data for regexp object pprivate field */        
d115 1
a115 1
    I32		whilem_seen;		/* number of WHILEM in this expr */
d117 8
a124 2
    regnode	*emit_bound;		/* First regnode outside of the allocated space */
    regnode	*emit;			/* Code-emit pointer; &regdummy = don't = compiling */
d128 6
a133 4
    I32		size;			/* Code size. */
    I32		npar;			/* Capture buffer count, (OPEN). */
    I32		cpar;			/* Capture buffer count, (CLOSE). */
    I32		nestroot;		/* root parens we are in - used by accept */
d147 1
a147 1
    
d150 3
d155 1
d162 2
a163 1
#if ADD_TO_REGEXEC
d176 1
a176 1
} RExC_state_t;
d189 2
a190 1
#define RExC_offsets	(pRExC_state->rxi->u.offsets) /* I am not like the others */
d193 1
d200 1
d214 3
d219 1
a227 3
#ifdef SPSTART
#undef SPSTART		/* dratted cpp namespace... */
#endif
d273 5
d283 1
a283 1
  what strings MUST appear in the pattern. We look for the longest 
d287 1
a287 1
  
d289 1
a289 1
    
d293 1
a293 1
  
d295 1
a295 1
  
d297 1
a297 1
     
d299 1
a299 1
  
d301 1
a301 1
  
d307 1
a307 1
    tells us how many characters must appear after the string we have 
d309 1
a309 1
  
d312 1
a312 1
    the string can appear at. If set to I32 max it indicates that the
d314 1
a314 1
  
d318 1
a318 1
    lookahead or positive lookbehind we can have multiple patterns 
d320 1
a320 1
    
d322 1
a322 1
    
d325 1
a325 1
    will actually match is 1. So 'FOO's minimum length is 3, but the 
d327 1
a327 1
    is used to determine offsets in front of and behind the string being 
d331 1
a331 1
    are not known until the full pattern has been compiled, thus the 
d333 1
a333 1
  
d335 1
a335 1
  
d337 1
a337 1
    offset past the start point of the final matching string. 
d341 1
a341 1
    the length of the string being searched for). 
d344 2
a345 2
    about lookbehind is factored in, with the information that would 
    have been lost precalculated in the end_shift field for the 
d349 1
a349 1
  and the delta to the maximum offset at the current point in the pattern.    
d356 2
a357 2
    I32 pos_min;
    I32 pos_delta;
d359 3
a361 3
    I32 last_end;	    /* min value, <0 unless valid. */
    I32 last_start_min;
    I32 last_start_max;
d364 2
a365 2
    I32 offset_fixed;       /* offset where it starts */
    I32 *minlen_fixed;      /* pointer to the minlen relevant to the string */
d368 4
a371 4
    I32 offset_float_min;   /* earliest point in string it can appear */
    I32 offset_float_max;   /* latest point in string it can appear */
    I32 *minlen_float;      /* pointer to the minlen relevant to the string */
    I32 lookbehind_float;   /* is the position of the string modified by LB */
d374 2
a375 2
    I32 *last_closep;
    struct regnode_charclass_class *start_class;
d378 18
d409 2
a410 7
#ifdef NO_UNARY_PLUS
#  define SF_FIX_SHIFT_EOL	(0+2)
#  define SF_FL_SHIFT_EOL		(0+4)
#else
#  define SF_FIX_SHIFT_EOL	(+2)
#  define SF_FL_SHIFT_EOL		(+4)
#endif
d428 2
a429 1
#define SCF_SEEN_ACCEPT         0x8000 
d435 2
a436 1
#define DEPENDS_SEMANTICS (get_regex_charset(RExC_flags) == REGEX_DEPENDS_CHARSET)
d438 8
a445 4
#define AT_LEAST_UNI_SEMANTICS (get_regex_charset(RExC_flags) >= REGEX_UNICODE_CHARSET)
#define ASCII_RESTRICTED (get_regex_charset(RExC_flags) == REGEX_ASCII_RESTRICTED_CHARSET)
#define AT_LEAST_ASCII_RESTRICTED (get_regex_charset(RExC_flags) >= REGEX_ASCII_RESTRICTED_CHARSET)
#define ASCII_FOLD_RESTRICTED (get_regex_charset(RExC_flags) == REGEX_ASCII_MORE_RESTRICTED_CHARSET)
d449 5
d476 6
a481 1
#define REPORT_LOCATION " in regex; marked by " MARKER1 " in m/%.*s" MARKER2 "%s/"
d503 2
a504 2
    Perl_croak(aTHX_ "%s in regex m/%.*s%s/",	    \
	    msg, (int)len, RExC_precomp, ellipses))
d507 2
a508 2
    Perl_croak(aTHX_ msg " in regex m/%.*s%s/",	    \
	    arg, (int)len, RExC_precomp, ellipses))
d516 1
a516 1
	    m, (int)offset, RExC_precomp, RExC_precomp + offset);	\
d533 2
a534 2
    S_re_croak2(aTHX_ m, REPORT_LOCATION, a1,			\
	    (int)offset, RExC_precomp, RExC_precomp + offset);	\
d552 2
a553 2
    S_re_croak2(aTHX_ m, REPORT_LOCATION, a1, a2,		\
	    (int)offset, RExC_precomp, RExC_precomp + offset);	\
d570 2
a571 2
    S_re_croak2(aTHX_ m, REPORT_LOCATION, a1, a2, a3,		\
	    (int)offset, RExC_precomp, RExC_precomp + offset);	\
d580 10
d594 1
a594 1
            m, (int)offset, RExC_precomp, RExC_precomp + offset);       \
d600 1
a600 1
	    (int)offset, RExC_precomp, RExC_precomp + offset);		\
d606 1
a606 1
	    (int)offset, RExC_precomp, RExC_precomp + offset);	        \
d613 1
a613 1
	    (int)offset, RExC_precomp, RExC_precomp + offset);		\
d620 1
a620 1
	    (int)offset, RExC_precomp, RExC_precomp + offset);		\
d623 1
a623 1
#define	ckWARN2regdep(loc,m, a1) STMT_START {				\
d625 1
a625 1
    Perl_ck_warner_d(aTHX_ packWARN2(WARN_DEPRECATED, WARN_REGEXP),	\
d627 1
a627 1
	    a1, (int)offset, RExC_precomp, RExC_precomp + offset);	\
d633 1
a633 1
	    a1, (int)offset, RExC_precomp, RExC_precomp + offset);	\
d639 1
a639 1
	    a1, a2, (int)offset, RExC_precomp, RExC_precomp + offset);	\
d645 1
a645 1
	    a1, a2, (int)offset, RExC_precomp, RExC_precomp + offset);	\
d651 1
a651 1
	    a1, a2, a3, (int)offset, RExC_precomp, RExC_precomp + offset); \
d657 1
a657 1
	    a1, a2, a3, (int)offset, RExC_precomp, RExC_precomp + offset); \
d663 1
a663 1
	    a1, a2, a3, a4, (int)offset, RExC_precomp, RExC_precomp + offset); \
d672 1
a672 1
/* Macros for recording node offsets.   20001227 mjd@@plover.com 
d684 3
a686 3
#define Set_Node_Cur_Length(node)
#define Node_Offset(n) 
#define Node_Length(n) 
d698 2
a699 1
	    Perl_croak(aTHX_ "value of node is %d in Offset macro", (int)(node)); \
d715 2
a716 1
	    Perl_croak(aTHX_ "value of node is %d in Length macro", (int)(node)); \
d725 2
a726 3
#define Set_Cur_Node_Length(len) Set_Node_Length(RExC_emit, len)
#define Set_Node_Cur_Length(node) \
    Set_Node_Length(node, RExC_parse - parse_start)
d742 43
d824 2
a825 1
S_scan_commit(pTHX_ const RExC_state_t *pRExC_state, scan_data_t *data, I32 *minlenp, int is_inf)
d849 6
a854 3
				      : (data->pos_delta == I32_MAX ? I32_MAX : data->pos_min + data->pos_delta));
	    if (is_inf || (U32)data->offset_float_max > (U32)I32_MAX)
		data->offset_float_max = I32_MAX;
d878 60
a937 10
/* These macros set, clear and test whether the synthetic start class ('ssc',
 * given by the parameter) matches an empty string (EOS).  This uses the
 * 'next_off' field in the node, to save a bit in the flags field.  The ssc
 * stands alone, so there is never a next_off, so this field is otherwise
 * unused.  The EOS information is used only for compilation, but theoretically
 * it could be passed on to the execution code.  This could be used to store
 * more than one bit of information, but only this one is currently used. */
#define SET_SSC_EOS(node)   STMT_START { (node)->next_off = TRUE; } STMT_END
#define CLEAR_SSC_EOS(node) STMT_START { (node)->next_off = FALSE; } STMT_END
#define TEST_SSC_EOS(node)  cBOOL((node)->next_off)
a938 1
/* Can match anything (initialization) */
d940 1
a940 1
S_cl_anything(const RExC_state_t *pRExC_state, struct regnode_charclass_class *cl)
d942 2
a943 1
    PERL_ARGS_ASSERT_CL_ANYTHING;
d945 6
a950 3
    ANYOF_BITMAP_SETALL(cl);
    cl->flags = ANYOF_UNICODE_ALL;
    SET_SSC_EOS(cl);
d956 1
a956 1
     * optimizer, and that there are inadequate test cases for locale, so many
d960 1
a960 2
	ANYOF_CLASS_SETALL(cl);	    /* /l uses class */
	cl->flags |= ANYOF_LOCALE|ANYOF_CLASS|ANYOF_LOC_FOLD;
d963 1
a963 1
	ANYOF_CLASS_ZERO(cl);	    /* Only /l uses class now */
a966 1
/* Can match anything (initialization) */
d968 2
a969 1
S_cl_is_anything(const struct regnode_charclass_class *cl)
d971 15
a985 1
    int value;
d987 1
a987 1
    PERL_ARGS_ASSERT_CL_IS_ANYTHING;
d989 9
a997 8
    for (value = 0; value < ANYOF_MAX; value += 2)
	if (ANYOF_CLASS_TEST(cl, value) && ANYOF_CLASS_TEST(cl, value + 1))
	    return 1;
    if (!(cl->flags & ANYOF_UNICODE_ALL))
	return 0;
    if (!ANYOF_BITMAP_TESTALLSET((const void*)cl))
	return 0;
    return 1;
d1000 3
a1002 3
/* Can match anything (initialization) */
STATIC void
S_cl_init(const RExC_state_t *pRExC_state, struct regnode_charclass_class *cl)
d1004 98
a1101 1
    PERL_ARGS_ASSERT_CL_INIT;
d1103 1
a1103 4
    Zero(cl, 1, struct regnode_charclass_class);
    cl->type = ANYOF;
    cl_anything(pRExC_state, cl);
    ARG_SET(cl, ANYOF_NONBITMAP_EMPTY);
d1107 8
a1114 1
#define cl_init_zero		S_cl_init
a1115 3
/* 'AND' a given class with another one.  Can create false positives.  'cl'
 * should not be inverted.  'and_with->flags & ANYOF_CLASS' should be 0 if
 * 'and_with' is a regnode_charclass instead of a regnode_charclass_class. */
d1117 2
a1118 2
S_cl_and(struct regnode_charclass_class *cl,
	const struct regnode_charclass_class *and_with)
d1120 2
a1121 1
    PERL_ARGS_ASSERT_CL_AND;
d1123 2
a1124 1
    assert(PL_regkind[and_with->type] == ANYOF);
d1126 33
a1158 7
    /* I (khw) am not sure all these restrictions are necessary XXX */
    if (!(ANYOF_CLASS_TEST_ANY_SET(and_with))
	&& !(ANYOF_CLASS_TEST_ANY_SET(cl))
	&& (and_with->flags & ANYOF_LOCALE) == (cl->flags & ANYOF_LOCALE)
	&& !(and_with->flags & ANYOF_LOC_FOLD)
	&& !(cl->flags & ANYOF_LOC_FOLD)) {
	int i;
d1160 1
a1160 60
	if (and_with->flags & ANYOF_INVERT)
	    for (i = 0; i < ANYOF_BITMAP_SIZE; i++)
		cl->bitmap[i] &= ~and_with->bitmap[i];
	else
	    for (i = 0; i < ANYOF_BITMAP_SIZE; i++)
		cl->bitmap[i] &= and_with->bitmap[i];
    } /* XXXX: logic is complicated otherwise, leave it along for a moment. */

    if (and_with->flags & ANYOF_INVERT) {

        /* Here, the and'ed node is inverted.  Get the AND of the flags that
         * aren't affected by the inversion.  Those that are affected are
         * handled individually below */
	U8 affected_flags = cl->flags & ~INVERSION_UNAFFECTED_FLAGS;
	cl->flags &= (and_with->flags & INVERSION_UNAFFECTED_FLAGS);
	cl->flags |= affected_flags;

        /* We currently don't know how to deal with things that aren't in the
         * bitmap, but we know that the intersection is no greater than what
         * is already in cl, so let there be false positives that get sorted
         * out after the synthetic start class succeeds, and the node is
         * matched for real. */

        /* The inversion of these two flags indicate that the resulting
         * intersection doesn't have them */
	if (and_with->flags & ANYOF_UNICODE_ALL) {
	    cl->flags &= ~ANYOF_UNICODE_ALL;
	}
	if (and_with->flags & ANYOF_NON_UTF8_LATIN1_ALL) {
	    cl->flags &= ~ANYOF_NON_UTF8_LATIN1_ALL;
	}
    }
    else {   /* and'd node is not inverted */
	U8 outside_bitmap_but_not_utf8; /* Temp variable */

	if (! ANYOF_NONBITMAP(and_with)) {

            /* Here 'and_with' doesn't match anything outside the bitmap
             * (except possibly ANYOF_UNICODE_ALL), which means the
             * intersection can't either, except for ANYOF_UNICODE_ALL, in
             * which case we don't know what the intersection is, but it's no
             * greater than what cl already has, so can just leave it alone,
             * with possible false positives */
            if (! (and_with->flags & ANYOF_UNICODE_ALL)) {
                ARG_SET(cl, ANYOF_NONBITMAP_EMPTY);
		cl->flags &= ~ANYOF_NONBITMAP_NON_UTF8;
            }
	}
	else if (! ANYOF_NONBITMAP(cl)) {

	    /* Here, 'and_with' does match something outside the bitmap, and cl
	     * doesn't have a list of things to match outside the bitmap.  If
             * cl can match all code points above 255, the intersection will
             * be those above-255 code points that 'and_with' matches.  If cl
             * can't match all Unicode code points, it means that it can't
             * match anything outside the bitmap (since the 'if' that got us
             * into this block tested for that), so we leave the bitmap empty.
             */
	    if (cl->flags & ANYOF_UNICODE_ALL) {
		ARG_SET(cl, ARG(and_with));
d1162 30
a1191 11
                /* and_with's ARG may match things that don't require UTF8.
                 * And now cl's will too, in spite of this being an 'and'.  See
                 * the comments below about the kludge */
		cl->flags |= and_with->flags & ANYOF_NONBITMAP_NON_UTF8;
	    }
	}
	else {
            /* Here, both 'and_with' and cl match something outside the
             * bitmap.  Currently we do not do the intersection, so just match
             * whatever cl had at the beginning.  */
	}
d1193 4
d1198 83
a1280 27
        /* Take the intersection of the two sets of flags.  However, the
         * ANYOF_NONBITMAP_NON_UTF8 flag is treated as an 'or'.  This is a
         * kludge around the fact that this flag is not treated like the others
         * which are initialized in cl_anything().  The way the optimizer works
         * is that the synthetic start class (SSC) is initialized to match
         * anything, and then the first time a real node is encountered, its
         * values are AND'd with the SSC's with the result being the values of
         * the real node.  However, there are paths through the optimizer where
         * the AND never gets called, so those initialized bits are set
         * inappropriately, which is not usually a big deal, as they just cause
         * false positives in the SSC, which will just mean a probably
         * imperceptible slow down in execution.  However this bit has a
         * higher false positive consequence in that it can cause utf8.pm,
         * utf8_heavy.pl ... to be loaded when not necessary, which is a much
         * bigger slowdown and also causes significant extra memory to be used.
         * In order to prevent this, the code now takes a different tack.  The
         * bit isn't set unless some part of the regular expression needs it,
         * but once set it won't get cleared.  This means that these extra
         * modules won't get loaded unless there was some path through the
         * pattern that would have required them anyway, and  so any false
         * positives that occur by not ANDing them out when they could be
         * aren't as severe as they would be if we treated this bit like all
         * the others */
        outside_bitmap_but_not_utf8 = (cl->flags | and_with->flags)
                                      & ANYOF_NONBITMAP_NON_UTF8;
	cl->flags &= and_with->flags;
	cl->flags |= outside_bitmap_but_not_utf8;
a1283 3
/* 'OR' a given class with another one.  Can create false positives.  'cl'
 * should not be inverted.  'or_with->flags & ANYOF_CLASS' should be 0 if
 * 'or_with' is a regnode_charclass instead of a regnode_charclass_class. */
d1285 2
a1286 1
S_cl_or(const RExC_state_t *pRExC_state, struct regnode_charclass_class *cl, const struct regnode_charclass_class *or_with)
d1288 3
a1290 1
    PERL_ARGS_ASSERT_CL_OR;
d1292 2
a1293 1
    if (or_with->flags & ANYOF_INVERT) {
d1295 14
a1308 19
        /* Here, the or'd node is to be inverted.  This means we take the
         * complement of everything not in the bitmap, but currently we don't
         * know what that is, so give up and match anything */
	if (ANYOF_NONBITMAP(or_with)) {
	    cl_anything(pRExC_state, cl);
	}
	/* We do not use
	 * (B1 | CL1) | (!B2 & !CL2) = (B1 | !B2 & !CL2) | (CL1 | (!B2 & !CL2))
	 *   <= (B1 | !B2) | (CL1 | !CL2)
	 * which is wasteful if CL2 is small, but we ignore CL2:
	 *   (B1 | CL1) | (!B2 & !CL2) <= (B1 | CL1) | !B2 = (B1 | !B2) | CL1
	 * XXXX Can we handle case-fold?  Unclear:
	 *   (OK1(i) | OK1(i')) | !(OK1(i) | OK1(i')) =
	 *   (OK1(i) | OK1(i')) | (!OK1(i) & !OK1(i'))
	 */
	else if ( (or_with->flags & ANYOF_LOCALE) == (cl->flags & ANYOF_LOCALE)
	     && !(or_with->flags & ANYOF_LOC_FOLD)
	     && !(cl->flags & ANYOF_LOC_FOLD) ) {
	    int i;
d1310 1
a1310 6
	    for (i = 0; i < ANYOF_BITMAP_SIZE; i++)
		cl->bitmap[i] |= ~or_with->bitmap[i];
	} /* XXXX: logic is complicated otherwise */
	else {
	    cl_anything(pRExC_state, cl);
	}
d1312 17
a1328 19
        /* And, we can just take the union of the flags that aren't affected
         * by the inversion */
	cl->flags |= or_with->flags & INVERSION_UNAFFECTED_FLAGS;

        /* For the remaining flags:
            ANYOF_UNICODE_ALL and inverted means to not match anything above
                    255, which means that the union with cl should just be
                    what cl has in it, so can ignore this flag
            ANYOF_NON_UTF8_LATIN1_ALL and inverted means if not utf8 and ord
                    is 127-255 to match them, but then invert that, so the
                    union with cl should just be what cl has in it, so can
                    ignore this flag
         */
    } else {    /* 'or_with' is not inverted */
	/* (B1 | CL1) | (B2 | CL2) = (B1 | B2) | (CL1 | CL2)) */
	if ( (or_with->flags & ANYOF_LOCALE) == (cl->flags & ANYOF_LOCALE)
	     && (!(or_with->flags & ANYOF_LOC_FOLD)
		 || (cl->flags & ANYOF_LOC_FOLD)) ) {
	    int i;
d1330 16
a1345 5
	    /* OR char bitmap and class bitmap separately */
	    for (i = 0; i < ANYOF_BITMAP_SIZE; i++)
		cl->bitmap[i] |= or_with->bitmap[i];
            if (or_with->flags & ANYOF_CLASS) {
                ANYOF_CLASS_OR(or_with, cl);
d1347 95
a1441 4
	}
	else { /* XXXX: logic is complicated, leave it along for a moment. */
	    cl_anything(pRExC_state, cl);
	}
d1443 1
a1443 1
	if (ANYOF_NONBITMAP(or_with)) {
d1445 2
a1446 11
	    /* Use the added node's outside-the-bit-map match if there isn't a
	     * conflict.  If there is a conflict (both nodes match something
	     * outside the bitmap, but what they match outside is not the same
	     * pointer, and hence not easily compared until XXX we extend
	     * inversion lists this far), give up and allow the start class to
	     * match everything outside the bitmap.  If that stuff is all above
	     * 255, can just set UNICODE_ALL, otherwise caould be anything. */
	    if (! ANYOF_NONBITMAP(cl)) {
		ARG_SET(cl, ARG(or_with));
	    }
	    else if (ARG(cl) != ARG(or_with)) {
d1448 2
a1449 8
		if ((or_with->flags & ANYOF_NONBITMAP_NON_UTF8)) {
		    cl_anything(pRExC_state, cl);
		}
		else {
		    cl->flags |= ANYOF_UNICODE_ALL;
		}
	    }
	}
d1451 2
a1452 2
        /* Take the union */
	cl->flags |= or_with->flags;
d1454 2
d1461 3
a1463 1
#define TRIE_LIST_USED(idx)  ( trie->states[state].trans.list ? (TRIE_LIST_CUR( idx ) - 1) : 0 )
d1506 1
a1506 1
            PerlIO_printf( Perl_debug_log, "%*s", 
d1508 1
a1508 1
                pv_pretty(sv, SvPV_nolen_const(*tmp), SvCUR(*tmp), colwidth, 
d1511 2
a1512 2
	                    PERL_PV_ESCAPE_FIRSTCHAR 
                ) 
d1526 2
a1527 1
        PerlIO_printf( Perl_debug_log, "%*s#%4"UVXf"|", (int)depth * 2 + 2,"", (UV)state);
d1530 2
a1531 1
            PerlIO_printf( Perl_debug_log, " W%4X", trie->states[ state ].wordnum );
d1543 2
a1544 1
                     && trie->trans[ base + ofs - trie->uniquecharcount ].check != state))
d1550 5
a1554 3
                if ( ( base + ofs >= trie->uniquecharcount ) &&
                     ( base + ofs - trie->uniquecharcount < trie->lasttrans ) &&
                     trie->trans[ base + ofs - trie->uniquecharcount ].check == state )
d1558 2
a1559 1
                    (UV)trie->trans[ base + ofs - trie->uniquecharcount ].next );
d1570 2
a1571 1
    PerlIO_printf(Perl_debug_log, "%*sword_info N:(prev,len)=", (int)depth*2, "");
d1578 1
a1578 1
}    
d1581 1
a1581 1
  List tries normally only are used for construction when the number of 
d1601 1
a1601 1
    
d1604 1
a1604 1
    
d1615 2
a1616 1
	    SV ** const tmp = av_fetch( revcharmap, TRIE_LIST_ITEM(state,charid).forid, 0);
d1620 5
a1624 4
                    pv_pretty(sv, SvPV_nolen_const(*tmp), SvCUR(*tmp), colwidth, 
	                    PL_colors[0], PL_colors[1],
	                    (SvUTF8(*tmp) ? PERL_PV_ESCAPE_UNI : 0) |
	                    PERL_PV_ESCAPE_FIRSTCHAR 
d1629 1
a1629 1
                if (!(charid % 10)) 
d1636 1
a1636 1
}    
d1640 2
a1641 2
  This is the normal DFA style state transition table, with a few 
  twists to facilitate compression later. 
d1656 1
a1656 1
    
d1661 1
a1661 1
    
d1667 1
a1667 1
            PerlIO_printf( Perl_debug_log, "%*s", 
d1669 1
a1669 1
                pv_pretty(sv, SvPV_nolen_const(*tmp), SvCUR(*tmp), colwidth, 
d1672 2
a1673 2
	                    PERL_PV_ESCAPE_FIRSTCHAR 
                ) 
d1688 1
a1688 1
        PerlIO_printf( Perl_debug_log, "%*s%4"UVXf" : ", 
d1700 2
a1701 1
            PerlIO_printf( Perl_debug_log, " (%4"UVXf")\n", (UV)trie->trans[ state ].check );
d1703 2
a1704 1
            PerlIO_printf( Perl_debug_log, " (%4"UVXf") W%4X\n", (UV)trie->trans[ state ].check,
d1823 1
a1823 1
    d = uvuni_to_utf8_flags(d, uv, 0);
d1835 1
a1835 1
            unsigned const char *const kapow = uvuni_to_utf8(flrbbbbb, val); \
d1846 22
a1867 25
#define TRIE_READ_CHAR STMT_START {                                                     \
    wordlen++;                                                                          \
    if ( UTF ) {                                                                        \
        /* if it is UTF then it is either already folded, or does not need folding */   \
        uvc = utf8n_to_uvuni( (const U8*) uc, UTF8_MAXLEN, &len, uniflags);             \
    }                                                                                   \
    else if (folder == PL_fold_latin1) {                                                \
        /* if we use this folder we have to obey unicode rules on latin-1 data */       \
        if ( foldlen > 0 ) {                                                            \
           uvc = utf8n_to_uvuni( (const U8*) scan, UTF8_MAXLEN, &len, uniflags );       \
           foldlen -= len;                                                              \
           scan += len;                                                                 \
           len = 0;                                                                     \
        } else {                                                                        \
            len = 1;                                                                    \
            uvc = _to_fold_latin1( (U8) *uc, foldbuf, &foldlen, 1);                     \
            skiplen = UNISKIP(uvc);                                                     \
            foldlen -= skiplen;                                                         \
            scan = foldbuf + skiplen;                                                   \
        }                                                                               \
    } else {                                                                            \
        /* raw data, will be folded later if needed */                                  \
        uvc = (U32)*uc;                                                                 \
        len = 1;                                                                        \
    }                                                                                   \
d1910 2
a1911 1
            trie->jump = (U16 *) PerlMemShared_calloc( word_count + 1, sizeof(U16) ); \
d1946 3
a1948 1
S_make_trie(pTHX_ RExC_state_t *pRExC_state, regnode *startbranch, regnode *first, regnode *last, regnode *tail, U32 word_count, U32 flags, U32 depth)
a1955 1
    const U32 uniflags = UTF8_ALLOW_DEFAULT;
d1968 1
a1968 1
    const U32 data_slot = add_data( pRExC_state, 4, "tuuu" );
d1974 1
a1974 1
    const U32 data_slot = add_data( pRExC_state, 2, "tu" );
a1988 1
        case EXACTFU_TRICKYFOLD:
a1990 1
	case EXACTFL: folder = PL_fold_locale; break;
d2014 5
a2018 6
                PerlIO_printf( Perl_debug_log,
                  "%*smake_trie start==%d, first==%d, last==%d, tail==%d depth=%d\n",
                  (int)depth * 2 + 2, "", 
                  REG_NODE_NUM(startbranch),REG_NODE_NUM(first), 
                  REG_NODE_NUM(last), REG_NODE_NUM(tail),
                  (int)depth);
d2020 1
a2020 1
   
d2029 1
a2029 1
        
d2038 3
a2040 3
       (trie->charmap) and we use a an HV* to store Unicode characters. We use the
       native representation of the character value as the key and IV's for the
       coded index.
d2057 1
a2057 4
        STRLEN foldlen = 0;
        U8 foldbuf[ UTF8_MAXBYTES_CASE + 1 ];
        STRLEN skiplen = 0;
        const U8 *scan = (U8*)NULL;
d2059 4
a2062 2
        STRLEN chars = 0;
        bool set_bit = trie->bitmap ? 1 : 0; /*store the first char in the bitmap?*/
d2082 1
a2082 1
                TRIE_BITMAP_SET(trie,0xDF);
d2085 2
a2086 1
        for ( ; uc < e ; uc += len ) {
d2089 64
a2152 1
            chars++;
d2176 1
a2176 1
			if (! UNI_IS_INVARIANT(uvc)) {
d2183 8
d2205 4
a2208 1
        }
d2210 6
a2215 17
            trie->minlen = chars;
            trie->maxlen = chars;
        } else if (chars < trie->minlen) {
            trie->minlen = chars;
        } else if (chars > trie->maxlen) {
            trie->maxlen = chars;
        }
        if (OP( noper ) == EXACTFU_SS) {
            /* XXX: workaround - 'ss' could match "\x{DF}" so minlen could be 1 and not 2*/
	    if (trie->minlen > 1)
                trie->minlen= 1;
        }
	if (OP( noper ) == EXACTFU_TRICKYFOLD) {
	    /* XXX: workround - things like "\x{1FBE}\x{0308}\x{0301}" can match "\x{0390}" 
	     *		      - We assume that any such sequence might match a 2 byte string */
            if (trie->minlen > 2 )
                trie->minlen= 2;
a2216 1

d2219 2
a2220 1
        PerlIO_printf( Perl_debug_log, "%*sTRIE(%s): W:%d C:%d Uq:%d Min:%d Max:%d\n",
d2252 3
a2254 1
    if ( (IV)( ( TRIE_CHARCOUNT(trie) + 1 ) * trie->uniquecharcount + 1) > SvIV(re_trie_maxbuff) ) {
d2269 1
a2269 1
        DEBUG_TRIE_COMPILE_MORE_r( PerlIO_printf( Perl_debug_log, 
a2285 2
	    U8 *scan         = (U8*)NULL; /* sanity init */
	    STRLEN foldlen   = 0;         /* required init */
a2286 2
	    U8 foldbuf[ UTF8_MAXBYTES_CASE + 1 ];
            STRLEN skiplen   = 0;
d2305 4
a2308 1
                        SV** const svpp = hv_fetch( widecharmap, (char*)&uvc, sizeof( UV ), 0);
d2315 2
a2316 1
                    /* charid is now 0 if we dont know the char read, or nonzero if we do */
d2326 7
a2332 2
                        for ( check = 1; check <= TRIE_LIST_USED( state ); check++ ) {
                            if ( TRIE_LIST_ITEM( state, check ).forid == charid ) {
d2354 1
a2354 1
        trie->statecount = next_alloc; 
d2402 3
a2404 1
                        Zero( trie->trans + (transcount / 2), transcount / 2 , reg_trie_trans );
d2412 2
a2413 1
                                trie->trans[ zp ].next = TRIE_LIST_ITEM( state, 1).newstate;
d2420 2
a2421 1
                            trie->trans[ tp ].next = TRIE_LIST_ITEM( state, 1).newstate;
d2428 5
a2432 2
                            const U32 tid = base -  trie->uniquecharcount + TRIE_LIST_ITEM( state, idx ).forid;
                            trie->trans[ tid ].next = TRIE_LIST_ITEM( state, idx ).newstate;
d2452 4
a2455 4
           we dont use the 0 slot of either trans[] or states[] so we add 1 to each.
           We know that we will need Charcount+1 trans at most to store the data
           (one row per char at worst case) So we preallocate both structures
           assuming worst case.
d2460 3
a2462 3
           We use the .check field of the first entry of the node temporarily to
           make compression both faster and easier by keeping track of how many non
           zero fields are in the node.
d2467 5
a2471 5
           There are two terms at use here: state as a TRIE_NODEIDX() which is a
           number representing the first entry of the node, and state as a
           TRIE_NODENUM() which is the trans number. state 1 is TRIE_NODEIDX(1) and
           TRIE_NODENUM(1), state 2 is TRIE_NODEIDX(2) and TRIE_NODENUM(3) if there
           are 2 entrys per node. eg:
d2479 3
a2481 3
           The table is internally in the right hand, idx form. However as we also
           have to deal with the states array which is indexed by nodenum we have to
           use TRIE_NODENUM() to convert.
d2484 1
a2484 1
        DEBUG_TRIE_COMPILE_MORE_r( PerlIO_printf( Perl_debug_log, 
a2507 1
            U8 *scan         = (U8*)NULL; /* sanity init */
a2508 1
            STRLEN foldlen   = 0;         /* required init */
a2509 2
            STRLEN skiplen   = 0;
            U8 foldbuf[ UTF8_MAXBYTES_CASE + 1 ];
d2528 4
a2531 1
                        SV* const * const svpp = hv_fetch( widecharmap, (char*)&uvc, sizeof( UV ), 0);
d2547 2
a2548 1
                    /* charid is now 0 if we dont know the char read, or nonzero if we do */
d2635 4
a2638 1
            for ( charid = 0 ; used && charid < trie->uniquecharcount ; charid++ ) {
d2647 7
a2653 2
                            trie->states[ state ].trans.base = zp + trie->uniquecharcount - charid ;
                            trie->trans[ zp ].next = SAFE_TRIE_NODENUM( trie->trans[ stateidx + charid ].next );
d2662 2
a2663 1
                        trie->states[ state ].trans.base = pos + trie->uniquecharcount - charid ;
d2665 3
a2667 1
                    trie->trans[ pos ].next = SAFE_TRIE_NODENUM( trie->trans[ stateidx + charid ].next );
d2678 8
a2685 7
                PerlIO_printf( Perl_debug_log,
		    "%*sAlloc: %d Orig: %"IVdf" elements, Final:%"IVdf". Savings of %%%5.2f\n",
		    (int)depth * 2 + 2,"",
                    (int)( ( TRIE_CHARCOUNT(trie) + 1 ) * trie->uniquecharcount + 1 ),
		    (IV)next_alloc,
		    (IV)pos,
                    ( ( next_alloc - pos ) * 100 ) / (double)next_alloc );
d2691 2
a2692 1
            PerlIO_printf(Perl_debug_log, "%*sStatecount:%"UVxf" Lasttrans:%"UVxf"\n",
d2702 1
a2702 1
    {   /* Modify the program and insert the new TRIE node */ 
d2705 1
a2705 1
        
d2743 2
a2744 1
            PerlIO_printf(Perl_debug_log, "%*sMJD offset:%"UVuf" MJD length:%"UVuf"\n",
d2749 1
a2749 1
        /* But first we check to see if there is a common prefix we can 
d2808 2
a2809 2
                            (UV)state, (UV)idx, 
                            pv_pretty(sv, SvPV_nolen_const(*tmp), SvCUR(*tmp), 6, 
d2812 1
a2812 1
	                        PERL_PV_ESCAPE_FIRSTCHAR 
d2825 1
a2825 1
#ifdef DEBUGGING	    
d2876 2
a2877 2
        if (!jumper) 
            jumper = last; 
d2881 2
a2882 2
	    /* Store the offset to the first unabsorbed branch in 
	       jump[0], which is otherwise unused by the jump logic. 
d2884 1
a2884 1
	    if (trie->jump) 
d2886 1
a2886 1
            
d2901 1
a2901 1
            } else 
d2907 2
a2908 2
            optimize = convert 
                      + NODE_STEP_REGNODE 
d2911 1
a2911 1
            /* XXX We really should free up the resource in trie now, 
d2921 2
a2922 2
            /* 
                Try to clean up some of the debris left after the 
d2977 4
a2980 4
    return trie->jump 
           ? MADE_JUMP_TRIE 
           : trie->startstate>1 
             ? MADE_EXACT_TRIE 
d2987 2
a2988 1
/* The Trie is constructed and compressed now so we can build a fail array if it's needed
d2990 4
a2993 2
   This is basically the Aho-Corasick algorithm. Its from exercise 3.31 and 3.32 in the
   "Red Dragon" -- Compilers, principles, techniques, and tools. Aho, Sethi, Ullman 1985/88
d2996 6
a3001 5
   We find the fail state for each state in the trie, this state is the longest proper
   suffix of the current state's 'word' that is also a proper prefix of another word in our
   trie. State 1 represents the word '' and is thus the default fail state. This allows
   the DFA not to have to restart after its tried and failed a word at a given point, it
   simply continues as though it had been matching the other word in the first place.
d3004 4
a3007 3
   When we get to 'd' we are still matching the first word, we would encounter 'g' which would
   fail, which would bring us to the state representing 'd' in the second word where we would
   try 'g' and succeed, proceeding to match 'cdgu'.
d3022 1
a3022 1
    const U32 data_slot = add_data( pRExC_state, 1, "T" );
d3086 1
a3086 1
		      "%*sStclass Failtable (%"UVuf" states): 0", 
d3095 1
a3095 1
    /*RExC_seen |= REG_SEEN_TRIEDFA;*/
a3098 11
/*
 * There are strange code-generation bugs caused on sparc64 by gcc-2.95.2.
 * These need to be revisited when a newer toolchain becomes available.
 */
#if defined(__sparc64__) && defined(__GNUC__)
#   if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 96)
#       undef  SPARC64_GCC_WORKAROUND
#       define SPARC64_GCC_WORKAROUND 1
#   endif
#endif

d3103 1
a3103 1
       regprop(RExC_rx, mysv, scan); \
d3122 2
a3123 1
 * fold.  *min_subtract is set to the total delta of the input nodes.
d3125 9
a3133 2
 * And *has_exactf_sharp_s is set to indicate whether or not the node is EXACTF
 * and contains LATIN SMALL LETTER SHARP S
d3140 1
a3140 1
 * approach doesn't work, as evidenced by this example:
d3142 1
a3142 1
 * Both these fold to "sss", but if the pattern is parsed to create a node that
d3146 1
a3146 1
 * that is "sss".
d3149 2
a3150 2
 * just these three.  Now the code is general, for all such cases, but the
 * three still have some special handling.  The approach taken is:
d3152 10
a3161 10
 *      character fold sequences.  It returns in *min_subtract how much to
 *      subtract from the the actual length of the string to get a real minimum
 *      match length; it is 0 if there are no multi-char folds.  This delta is
 *      used by the caller to adjust the min length of the match, and the delta
 *      between min and max, so that the optimizer doesn't reject these
 *      possibilities based on size constraints.
 * 2)   Certain of these sequences require special handling by the trie code,
 *      so, if found, this code changes the joined node type to special ops:
 *      EXACTFU_TRICKYFOLD and EXACTFU_SS.
 * 3)   For the sequence involving the Sharp s (\xDF), the node type EXACTFU_SS
d3168 6
a3173 5
 *      pre-folded by regcomp.c.  This saves effort in regex matching.
 *      However, the pre-folding isn't done for non-UTF8 patterns because the
 *      fold of the MICRO SIGN requires UTF-8, and we don't want to slow things
 *      down by forcing the pattern into UTF8 unless necessary.  Also what
 *      EXACTF and EXACTFL nodes fold to isn't known until runtime.  The fold
d3181 47
a3227 24
 * 4)   A problem remains for the sharp s in EXACTF nodes.  Whether it matches
 *      'ss' or not is not knowable at compile time.  It will match iff the
 *      target string is in UTF-8, unlike the EXACTFU nodes, where it always
 *      matches; and the EXACTFL and EXACTFA nodes where it never does.  Thus
 *      it can't be folded to "ss" at compile time, unlike EXACTFU does (as
 *      described in item 3).  An assumption that the optimizer part of
 *      regexec.c (probably unwittingly) makes is that a character in the
 *      pattern corresponds to at most a single character in the target string.
 *      (And I do mean character, and not byte here, unlike other parts of the
 *      documentation that have never been updated to account for multibyte
 *      Unicode.)  This assumption is wrong only in this case, as all other
 *      cases are either 1-1 folds when no UTF-8 is involved; or is true by
 *      virtue of having this file pre-fold UTF-8 patterns.   I'm
 *      reluctant to try to change this assumption, so instead the code punts.
 *      This routine examines EXACTF nodes for the sharp s, and returns a
 *      boolean indicating whether or not the node is an EXACTF node that
 *      contains a sharp s.  When it is true, the caller sets a flag that later
 *      causes the optimizer in this file to not set values for the floating
 *      and fixed string lengths, and thus avoids the optimizer code in
 *      regexec.c that makes the invalid assumption.  Thus, there is no
 *      optimization based on string lengths for EXACTF nodes that contain the
 *      sharp s.  This only happens for /id rules (which means the pattern
 *      isn't in UTF-8).
 */
d3229 1
a3229 1
#define JOIN_EXACT(scan,min_subtract,has_exactf_sharp_s, flags) \
d3231 1
a3231 1
        join_exact(pRExC_state,(scan),(min_subtract),has_exactf_sharp_s, (flags),NULL,depth+1)
d3234 4
a3237 1
S_join_exact(pTHX_ RExC_state_t *pRExC_state, regnode *scan, UV *min_subtract, bool *has_exactf_sharp_s, U32 flags,regnode *val, U32 depth) {
d3266 1
a3266 1
        
d3283 3
a3285 2
            /* XXX I (khw) kind of doubt that this works on platforms where
             * U8_MAX is above 255 because of lots of other assumptions */
d3289 1
a3289 1
            
d3320 1
a3320 1
    *has_exactf_sharp_s = FALSE;
d3328 6
a3333 3
        const U8 * const s0 = (U8*) STRING(scan);
        const U8 * s = s0;
        const U8 * const s_end = s0 + STR_LEN(scan);
d3336 1
a3336 1
	 * possibilities.  to avoid some tests in the loop, there are two main
d3340 50
d3397 1
a3397 1
                int count = 0;
d3404 2
a3405 2
                /* Nodes with 'ss' require special handling, except for EXACTFL
                 * and EXACTFA for which there is no multi-char fold to this */
d3407 2
a3408 1
                    && OP(scan) != EXACTFL && OP(scan) != EXACTFA)
d3411 3
a3413 1
                    OP(scan) = EXACTFU_SS;
a3415 24
                else if (len == 6   /* len is the same in both ASCII and EBCDIC for these */
                         && (memEQ(s, GREEK_SMALL_LETTER_IOTA_UTF8
                                      COMBINING_DIAERESIS_UTF8
                                      COMBINING_ACUTE_ACCENT_UTF8,
                                   6)
                             || memEQ(s, GREEK_SMALL_LETTER_UPSILON_UTF8
                                         COMBINING_DIAERESIS_UTF8
                                         COMBINING_ACUTE_ACCENT_UTF8,
                                     6)))
                {
                    count = 3;

                    /* These two folds require special handling by trie's, so
                     * change the node type to indicate this.  If EXACTFA and
                     * EXACTFL were ever to be handled by trie's, this would
                     * have to be changed.  If this node has already been
                     * changed to EXACTFU_SS in this loop, leave it as is.  (I
                     * (khw) think it doesn't matter in regexec.c for UTF
                     * patterns, but no need to change it */
                    if (OP(scan) == EXACTFU) {
                        OP(scan) = EXACTFU_TRICKYFOLD;
                    }
                    s += 6;
                }
d3417 1
a3417 1
                    const U8* multi_end  = s + len;
d3419 4
a3422 10
                    /* Count how many characters in it.  In the case of /l and
                     * /aa, no folds which contain ASCII code points are
                     * allowed, so check for those, and skip if found.  (In
                     * EXACTFL, no folds are allowed to any Latin1 code point,
                     * not just ASCII.  But there aren't any of these
                     * currently, nor ever likely, so don't take the time to
                     * test for them.  The code that generates the
                     * is_MULTI_foo() macros croaks should one actually get put
                     * into Unicode .) */
                    if (OP(scan) != EXACTFL && OP(scan) != EXACTFA) {
d3442 2
a3443 2
                *min_subtract += count - 1;
            next_iteration: ;
a3444 2
	}
	else if (OP(scan) != EXACTFL && OP(scan) != EXACTFA) {
d3446 43
a3488 18
            /* Here, the pattern is not UTF-8.  Look for the multi-char folds
             * that are all ASCII.  As in the above case, EXACTFL and EXACTFA
             * nodes can't have multi-char folds to this range (and there are
             * no existing ones in the upper latin1 range).  In the EXACTF
             * case we look also for the sharp s, which can be in the final
             * position.  Otherwise we can stop looking 1 byte earlier because
             * have to find at least two characters for a multi-fold */
	    const U8* upper = (OP(scan) == EXACTF) ? s_end : s_end -1;

            /* The below is perhaps overboard, but this allows us to save a
             * test each time through the loop at the expense of a mask.  This
             * is because on both EBCDIC and ASCII machines, 'S' and 's' differ
             * by a single bit.  On ASCII they are 32 apart; on EBCDIC, they
             * are 64.  This uses an exclusive 'or' to find that bit and then
             * inverts it to form a mask, with just a single 0, in the bit
             * position where 'S' and 's' differ. */
            const U8 S_or_s_mask = (U8) ~ ('S' ^ 's');
            const U8 s_masked = 's' & S_or_s_mask;
d3493 2
a3494 1
                    if (*s == LATIN_SMALL_LETTER_SHARP_S && OP(scan) == EXACTF)
d3496 1
a3496 1
                        *has_exactf_sharp_s = TRUE;
d3503 2
a3504 2
                    && ((*s & S_or_s_mask) == s_masked)
                    && ((*(s+1) & S_or_s_mask) == s_masked))
d3511 3
a3513 2
                     * which we don't know until runtime */
                    if (OP(scan) != EXACTF) {
d3547 1
a3547 1
    Newx(and_withp,1,struct regnode_charclass_class); \
d3558 1
d3563 1
a3563 3
#define SCAN_COMMIT(s, data, m) scan_commit(s, data, m, is_inf)

STATIC I32
d3565 1
a3565 1
                        I32 *minlenp, I32 *deltap,
d3569 2
a3570 2
			U8* recursed,
			struct regnode_charclass_class *and_withp,
d3581 2
a3582 1
    I32 min = 0;    /* There must be at least this number of characters to match */
d3585 1
a3585 1
    I32 delta = 0;
d3592 1
a3592 1
    I32 stopmin = I32_MAX;
a3600 1

d3612 1
a3612 1
	bool has_exactf_sharp_s = FALSE;
d3614 26
a3639 2
	DEBUG_STUDYDATA("Peep:", data,depth);
	DEBUG_PEEP("Peep",scan,depth);
d3641 5
a3645 4
        /* Its not clear to khw or hv why this is done here, and not in the
         * clauses that deal with EXACT nodes.  khw's guess is that it's
         * because of a previous design */
        JOIN_EXACT(scan,&min_subtract, &has_exactf_sharp_s, 0);
d3678 2
a3679 1
	    /* demq: the op(next)==code check is to see if we have "branch-branch" AFAICT */
d3682 5
a3686 5
	        /* NOTE - There is similar code to this block below for handling
	           TRIE nodes on a re-study.  If you change stuff here check there
	           too. */
		I32 max1 = 0, min1 = I32_MAX, num = 0;
		struct regnode_charclass_class accum;
d3689 7
a3695 4
		if (flags & SCF_DO_SUBSTR)
		    SCAN_COMMIT(pRExC_state, data, minlenp); /* Cannot merge strings after this. */
		if (flags & SCF_DO_STCLASS)
		    cl_init_zero(pRExC_state, &accum);
d3698 3
a3700 2
		    I32 deltanext, minnext, f = 0, fake;
		    struct regnode_charclass_class this_class;
d3717 1
a3717 1
			cl_init(pRExC_state, &this_class);
d3725 3
a3727 3
		    minnext = study_chunk(pRExC_state, &scan, minlenp, &deltanext,
					  next, &data_fake,
					  stopparen, recursed, NULL, f,depth+1);
d3730 1
a3730 1
		    if (deltanext == I32_MAX) {
d3732 1
a3732 1
			max1 = I32_MAX;
d3739 1
a3739 1
	                if ( stopmin > minnext) 
d3751 1
a3751 1
			cl_or(pRExC_state, &accum, &this_class);
d3757 2
a3758 2
		    if (data->pos_delta >= I32_MAX - (max1 - min1))
		        data->pos_delta = I32_MAX;
d3765 3
a3767 2
		if (delta == I32_MAX || I32_MAX - delta - (max1 - min1) < 0)
		    delta = I32_MAX;
d3771 1
a3771 1
		    cl_or(pRExC_state, data->start_class, &accum);
d3773 1
a3773 1
			cl_and(data->start_class, and_withp);
d3779 1
a3779 1
			cl_and(data->start_class, &accum);
d3786 1
a3786 2
			StructCopy(data->start_class, and_withp,
				   struct regnode_charclass_class);
d3788 1
a3788 2
			StructCopy(&accum, data->start_class,
				   struct regnode_charclass_class);
a3789 1
                        SET_SSC_EOS(data->start_class);
d3793 3
a3795 1
                if (PERL_ENABLE_TRIE_OPTIMISATION && OP( startbranch ) == BRANCH ) {
d3798 4
a3801 4
		   Assuming this was/is a branch we are dealing with: 'scan' now
		   points at the item that follows the branch sequence, whatever
		   it is. We now start at the beginning of the sequence and look
		   for subsequences of
d3807 2
a3808 1
		   which would be constructed from a pattern like /A|LIST|OF|WORDS/
d3816 2
a3817 1
		     1. patterns where the whole set of branches can be converted. 
d3828 1
a3828 1
		  There is an additional case, that being where there is a 
d3854 1
a3854 1
                        SV * const mysv = sv_newmortal();       /* for dumping */
d3869 1
a3869 1
                        
d3871 1
a3871 1
                            regprop(RExC_rx, mysv, tail );
d3873 3
a3875 3
                                (int)depth * 2 + 2, "", 
                                "Looking for TRIE'able sequences. Tail node is: ", 
                                SvPV_nolen_const( mysv )
d3878 1
a3878 1
                        
d3883 2
a3884 1
                                noper is the first thing to be matched as part of that branch
d3887 33
a3919 24
                            We normally handle a case like this /FOO[xyz]|BAR[pqr]/
                            via a "jump trie" but we also support building with NOJUMPTRIE,
                            which restricts the trie logic to structures like /FOO|BAR/.

                            If noper is a trieable nodetype then the branch is a possible optimization
                            target. If we are building under NOJUMPTRIE then we require that noper_next
                            is the same as scan (our current position in the regex program).

                            Once we have two or more consecutive such branches we can create a
                            trie of the EXACT's contents and stitch it in place into the program.

                            If the sequence represents all of the branches in the alternation we
                            replace the entire thing with a single TRIE node.

                            Otherwise when it is a subsequence we need to stitch it in place and
                            replace only the relevant branches. This means the first branch has
                            to remain as it is used by the alternation logic, and its next pointer,
                            and needs to be repointed at the item on the branch chain following
                            the last branch we have optimized away.

                            This could be either a BRANCH, in which case the subsequence is internal,
                            or it could be the item following the branch sequence in which case the
                            subsequence is at the end (which does not necessarily mean the first node
                            is the start of the alternation).
d3921 2
a3922 1
                            TRIE_TYPE(X) is a define which maps the optype to a trietype.
d3930 1
a3930 2
                                EXACTFU_TRICKYFOLD | EXACTFU
                                EXACTFA         | 0
d3936 2
a3937 1
                       ( EXACTFU == (X) || EXACTFU_SS == (X) || EXACTFU_TRICKYFOLD == (X) ) ? EXACTFU :        \
d3952 1
a3952 1
                                regprop(RExC_rx, mysv, cur);
d3956 1
a3956 1
                                regprop(RExC_rx, mysv, noper);
d3961 1
a3961 1
                                  regprop(RExC_rx, mysv, noper_next );
d3967 1
a3967 1
				   PL_reg_name[trietype], PL_reg_name[noper_trietype], PL_reg_name[noper_next_trietype] 
d3971 2
a3972 2
                            /* Is noper a trieable nodetype that can be merged with the
                             * current trie (if there is one)? */
d3985 4
a3988 4
                                /* Handle mergable triable node
                                 * Either we are the first node in a new trieable sequence,
                                 * in which case we do some bookkeeping, otherwise we update
                                 * the end pointer. */
d4001 3
a4003 2
                                            /* a NOTHING regop is 1 regop wide. We need at least two
                                             * for a trie so we can't merge this in */
d4019 3
a4021 2
                                 * noper may either be a triable node which can not be tried
                                 * together with the current trie, or a non triable node */
d4023 8
a4030 5
                                    /* If last is set and trietype is not NOTHING then we have found
                                     * at least two triable branch sequences in a row of a similar
                                     * trietype so we can turn them into a trie. If/when we
                                     * allow NOTHING to start a trie sequence this condition will be
                                     * required, and it isn't expensive so we leave it in for now. */
d4033 5
a4037 3
                                                startbranch, first, cur, tail, count,
                                                trietype, depth+1 );
                                    last = NULL; /* note: we clear/update first, trietype etc below, so we dont do it here */
d4044 2
a4045 1
                                    /* noper is triable, so we can start a new trie sequence */
d4050 2
a4051 1
                                    /* if we already saw a first but the current node is not triable then we have
d4060 1
a4060 1
                            regprop(RExC_rx, mysv, cur);
d4062 2
a4063 1
                              "%*s- %s (%d) <SCAN FINISHED>\n", (int)depth * 2 + 2,
d4069 6
a4074 4
                                /* the last branch of the sequence was part of a trie,
                                 * so we have to construct it here outside of the loop
                                 */
                                made= make_trie( pRExC_state, startbranch, first, scan, tail, count, trietype, depth+1 );
d4084 1
a4084 1
                                        RExC_seen &=~REG_TOP_LEVEL_BRANCHES;
d4089 4
a4092 2
                                /* at this point we know whatever we have is a NOTHING sequence/branch
                                 * AND if 'startbranch' is 'first' then we can turn the whole thing into a NOTHING
d4096 3
a4098 2
                                    /* the entire thing is a NOTHING sequence, something like this:
                                     * (?:|) So we can turn it into a plain NOTHING op. */
d4100 1
a4100 1
                                        regprop(RExC_rx, mysv, cur);
d4114 1
a4114 1
                    
d4116 1
a4116 1
                
d4128 1
d4131 1
a4131 1
	    /* set the pointer */
d4142 15
a4156 6
                if (!recursed) {
                    Newxz(recursed, (((RExC_npar)>>3) +1), U8);
                    SAVEFREEPV(recursed);
                }
                if (!PAREN_TEST(recursed,paren+1)) {
		    PAREN_SET(recursed,paren+1);
d4159 3
d4163 1
a4163 1
                        SCAN_COMMIT(pRExC_state,data,minlenp);
d4168 1
a4168 1
                        cl_anything(pRExC_state, data->start_class);
d4185 4
d4194 2
d4201 1
a4201 1
	    I32 l = STR_LEN(scan);
d4217 1
a4217 1
 			? I32_MAX : data->pos_min + data->pos_delta;
d4228 1
a4228 1
						  (U8*)STRING(scan)+STR_LEN(scan));
d4234 3
d4238 3
a4240 42
		/* Check whether it is compatible with what we know already! */
		int compat = 1;


		/* If compatible, we or it in below.  It is compatible if is
		 * in the bitmp and either 1) its bit or its fold is set, or 2)
		 * it's for a locale.  Even if there isn't unicode semantics
		 * here, at runtime there may be because of matching against a
		 * utf8 string, so accept a possible false positive for
		 * latin1-range folds */
		if (uc >= 0x100 ||
		    (!(data->start_class->flags & ANYOF_LOCALE)
		    && !ANYOF_BITMAP_TEST(data->start_class, uc)
		    && (!(data->start_class->flags & ANYOF_LOC_FOLD)
			|| !ANYOF_BITMAP_TEST(data->start_class, PL_fold_latin1[uc])))
                    )
		{
		    compat = 0;
		}
		ANYOF_CLASS_ZERO(data->start_class);
		ANYOF_BITMAP_ZERO(data->start_class);
		if (compat)
		    ANYOF_BITMAP_SET(data->start_class, uc);
		else if (uc >= 0x100) {
		    int i;

		    /* Some Unicode code points fold to the Latin1 range; as
		     * XXX temporary code, instead of figuring out if this is
		     * one, just assume it is and set all the start class bits
		     * that could be some such above 255 code point's fold
		     * which will generate fals positives.  As the code
		     * elsewhere that does compute the fold settles down, it
		     * can be extracted out and re-used here */
		    for (i = 0; i < 256; i++){
			if (HAS_NONLATIN1_FOLD_CLOSURE(i)) {
			    ANYOF_BITMAP_SET(data->start_class, i);
			}
		    }
		}
                CLEAR_SSC_EOS(data->start_class);
		if (uc < 0x100)
		  data->start_class->flags &= ~ANYOF_UNICODE_ALL;
d4243 5
a4247 7
		/* false positive possible if the class is case-folded */
		if (uc < 0x100)
		    ANYOF_BITMAP_SET(data->start_class, uc);
		else
		    data->start_class->flags |= ANYOF_UNICODE_ALL;
                CLEAR_SSC_EOS(data->start_class);
		cl_and(data->start_class, and_withp);
d4252 1
a4252 1
	    I32 l = STR_LEN(scan);
d4254 2
d4260 1
a4260 1
		SCAN_COMMIT(pRExC_state, data, minlenp);
d4267 2
a4268 2
	    if (has_exactf_sharp_s) {
		RExC_seen |= REG_SEEN_EXACTF_SHARP_S;
d4283 68
d4352 3
a4354 51
		/* Check whether it is compatible with what we know already! */
		int compat = 1;
		if (uc >= 0x100 ||
		 (!(data->start_class->flags & ANYOF_LOCALE)
		  && !ANYOF_BITMAP_TEST(data->start_class, uc)
		  && !ANYOF_BITMAP_TEST(data->start_class, PL_fold_latin1[uc])))
		{
		    compat = 0;
		}
		ANYOF_CLASS_ZERO(data->start_class);
		ANYOF_BITMAP_ZERO(data->start_class);
		if (compat) {
		    ANYOF_BITMAP_SET(data->start_class, uc);
                    CLEAR_SSC_EOS(data->start_class);
		    if (OP(scan) == EXACTFL) {
			/* XXX This set is probably no longer necessary, and
			 * probably wrong as LOCALE now is on in the initial
			 * state */
			data->start_class->flags |= ANYOF_LOCALE|ANYOF_LOC_FOLD;
		    }
		    else {

			/* Also set the other member of the fold pair.  In case
			 * that unicode semantics is called for at runtime, use
			 * the full latin1 fold.  (Can't do this for locale,
			 * because not known until runtime) */
			ANYOF_BITMAP_SET(data->start_class, PL_fold_latin1[uc]);

                        /* All other (EXACTFL handled above) folds except under
                         * /iaa that include s, S, and sharp_s also may include
                         * the others */
			if (OP(scan) != EXACTFA) {
			    if (uc == 's' || uc == 'S') {
				ANYOF_BITMAP_SET(data->start_class,
					         LATIN_SMALL_LETTER_SHARP_S);
			    }
			    else if (uc == LATIN_SMALL_LETTER_SHARP_S) {
				ANYOF_BITMAP_SET(data->start_class, 's');
				ANYOF_BITMAP_SET(data->start_class, 'S');
			    }
			}
		    }
		}
		else if (uc >= 0x100) {
		    int i;
		    for (i = 0; i < 256; i++){
			if (_HAS_NONLATIN1_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(i)) {
			    ANYOF_BITMAP_SET(data->start_class, i);
			}
		    }
		}
d4357 5
a4361 30
		if (data->start_class->flags & ANYOF_LOC_FOLD) {
		    /* false positive possible if the class is case-folded.
		       Assume that the locale settings are the same... */
		    if (uc < 0x100) {
			ANYOF_BITMAP_SET(data->start_class, uc);
                        if (OP(scan) != EXACTFL) {

                            /* And set the other member of the fold pair, but
                             * can't do that in locale because not known until
                             * run-time */
                            ANYOF_BITMAP_SET(data->start_class,
					     PL_fold_latin1[uc]);

			    /* All folds except under /iaa that include s, S,
			     * and sharp_s also may include the others */
			    if (OP(scan) != EXACTFA) {
				if (uc == 's' || uc == 'S') {
				    ANYOF_BITMAP_SET(data->start_class,
					           LATIN_SMALL_LETTER_SHARP_S);
				}
				else if (uc == LATIN_SMALL_LETTER_SHARP_S) {
				    ANYOF_BITMAP_SET(data->start_class, 's');
				    ANYOF_BITMAP_SET(data->start_class, 'S');
				}
			    }
                        }
		    }
                    CLEAR_SSC_EOS(data->start_class);
		}
		cl_and(data->start_class, and_withp);
d4364 1
d4367 2
a4368 2
	    I32 mincount, maxcount, minnext, deltanext, fl = 0;
	    I32 f = flags, pos_before = 0;
d4370 2
a4371 2
	    struct regnode_charclass_class this_class;
	    struct regnode_charclass_class *oclass = NULL;
a4400 2
		is_inf = is_inf_internal = 1;
		scan = regnext(scan);
d4402 2
a4403 1
		    SCAN_COMMIT(pRExC_state, data, minlenp); /* Cannot extend fixed substrings */
d4406 2
d4428 3
a4430 1
		    if (mincount == 0) SCAN_COMMIT(pRExC_state,data,minlenp); /* Cannot extend fixed substrings */
d4440 1
a4440 1
		    cl_init(pRExC_state, &this_class);
d4459 6
a4464 4
		minnext = study_chunk(pRExC_state, &scan, minlenp, &deltanext, 
		                      last, data, stopparen, recursed, NULL,
				      (mincount == 0
					? (f & ~SCF_DO_SUBSTR) : f),depth+1);
d4470 1
a4470 1
			cl_or(pRExC_state, data->start_class, &this_class);
d4476 1
a4476 2
			StructCopy(data->start_class, and_withp,
				   struct regnode_charclass_class);
d4478 1
a4478 2
			StructCopy(&this_class, data->start_class,
				   struct regnode_charclass_class);
d4480 1
a4480 1
                        SET_SSC_EOS(data->start_class);
d4484 2
a4485 2
			cl_or(pRExC_state, data->start_class, &this_class);
			cl_and(data->start_class, and_withp);
d4488 1
a4488 1
			cl_and(data->start_class, &this_class);
d4493 3
a4495 2
		if ( /* ? quantifier ok, except for (?{ ... }) */
		    (next_is_eval || !(mincount == 0 && maxcount == 1))
d4498 2
a4499 1
		    && maxcount <= REG_INFTY/3) /* Complement check for big count */
d4504 1
a4504 1
			      "Quantifier unexpected on zero-length expression");
d4509 2
a4510 2
		is_inf_internal |= deltanext == I32_MAX
				     || (maxcount == REG_INFTY && minnext + deltanext > 0);
d4512 6
a4517 5
		if (is_inf)
		    delta = I32_MAX;
		else
		    delta += (minnext + deltanext) * maxcount - minnext * mincount;

d4568 4
a4571 1
                      && ! (RExC_seen & REG_SEEN_EXACTF_SHARP_S) /* Nor \xDF */
d4618 1
a4618 1
				    NULL, stopparen, recursed, NULL, 0,depth+1);
d4643 1
d4646 3
a4648 18
		    if (data->last_end > 0 && mincount != 0) { /* Ends with a string. */
#if defined(SPARC64_GCC_WORKAROUND)
			I32 b = 0;
			STRLEN l = 0;
			const char *s = NULL;
			I32 old = 0;

			if (pos_before >= data->last_start_min)
			    b = pos_before;
			else
			    b = data->last_start_min;

			l = 0;
			s = SvPV_const(data->last_found, l);
			old = b - data->last_start_min;

#else
			I32 b = pos_before >= data->last_start_min
d4652 1
a4652 2
			I32 old = b - data->last_start_min;
#endif
d4659 2
d4664 1
d4667 2
a4668 1
					  SvPVX_const(last_str), l, mincount - 1);
d4680 1
a4680 1
					mg->mg_len += CHR_SVLEN(last_str) - l;
d4682 1
d4688 1
a4688 1
			    data->last_start_max += is_inf ? I32_MAX
d4695 13
a4707 7
PerlIO_printf(Perl_debug_log, "counted=%d deltanext=%d I32_MAX=%d minnext=%d maxcount=%d mincount=%d\n",
    counted, deltanext, I32_MAX, minnext, maxcount, mincount);
if (deltanext != I32_MAX)
PerlIO_printf(Perl_debug_log, "LHS=%d RHS=%d\n", -counted * deltanext + (minnext + deltanext) * maxcount - minnext * mincount, I32_MAX - data->pos_delta);
#endif
		    if (deltanext == I32_MAX || -counted * deltanext + (minnext + deltanext) * maxcount - minnext * mincount >= I32_MAX - data->pos_delta)
		        data->pos_delta = I32_MAX;
d4714 1
a4714 1
			SCAN_COMMIT(pRExC_state,data,minlenp);
d4724 1
a4724 2
			    data->last_start_min =
				data->pos_min - CHR_SVLEN(last_str);
d4726 2
a4727 3
				? I32_MAX
				: data->pos_min + data->pos_delta
				- CHR_SVLEN(last_str);
d4742 8
a4749 1
	    default:			/* REF, and CLUMP only? */
d4751 2
a4752 1
		    SCAN_COMMIT(pRExC_state,data,minlenp);	/* Cannot expect anything... */
d4756 10
a4765 2
		if (flags & SCF_DO_STCLASS_OR)
		    cl_anything(pRExC_state, data->start_class);
a4771 2
		int value = 0;
                CLEAR_SSC_EOS(data->start_class); /* No match on empty */
d4773 14
a4786 8
                    for (value = 0; value < 256; value++)
                        if (!is_VERTWS_cp(value))
                            ANYOF_BITMAP_CLEAR(data->start_class, value);
                }
                else {
                    for (value = 0; value < 256; value++)
                        if (is_VERTWS_cp(value))
                            ANYOF_BITMAP_SET(data->start_class, value);
a4787 2
                if (flags & SCF_DO_STCLASS_OR)
		    cl_and(data->start_class, and_withp);
d4793 2
a4794 1
    	        SCAN_COMMIT(pRExC_state,data,minlenp);	/* Cannot expect anything... */
a4800 1
	    int value = 0;
d4803 1
a4803 1
		SCAN_COMMIT(pRExC_state,data,minlenp);
d4808 6
a4813 2
                int loop_max = 256;
                CLEAR_SSC_EOS(data->start_class); /* No match on empty */
d4817 1
a4817 2
		switch (PL_regkind[OP(scan)]) {
                    U8 classnum;
a4818 1
		case SANY:
d4821 2
a4822 1
                   Perl_croak(aTHX_ "panic: unexpected simple REx opcode %d", OP(scan));
d4824 2
a4825 1
                 do_default:
d4827 1
a4827 1
			cl_anything(pRExC_state, data->start_class);
d4829 1
d4831 19
a4849 6
		    if (OP(scan) == SANY)
			goto do_default;
		    if (flags & SCF_DO_STCLASS_OR) { /* Everything but \n */
			value = (ANYOF_BITMAP_TEST(data->start_class,'\n')
				|| ANYOF_CLASS_TEST_ANY_SET(data->start_class));
			cl_anything(pRExC_state, data->start_class);
a4850 2
		    if (flags & SCF_DO_STCLASS_AND || !value)
			ANYOF_BITMAP_CLEAR(data->start_class,'\n');
d4852 2
a4853 1
		case ANYOF:
d4855 2
a4856 2
			cl_and(data->start_class,
			       (struct regnode_charclass_class*)scan);
d4858 2
a4859 2
			cl_or(pRExC_state, data->start_class,
			      (struct regnode_charclass_class*)scan);
d4861 3
a4863 2
		case POSIXA:
                    loop_max = 128;
d4865 1
d4867 8
a4874 16
		case POSIXD:
		case POSIXU:
                    classnum = FLAGS(scan);
		    if (flags & SCF_DO_STCLASS_AND) {
			if (!(data->start_class->flags & ANYOF_LOCALE)) {
			    ANYOF_CLASS_CLEAR(data->start_class, classnum_to_namedclass(classnum) + 1);
                            for (value = 0; value < loop_max; value++) {
                                if (! _generic_isCC(UNI_TO_NATIVE(value), classnum)) {
                                    ANYOF_BITMAP_CLEAR(data->start_class, UNI_TO_NATIVE(value));
                                }
                            }
			}
		    }
		    else {
			if (data->start_class->flags & ANYOF_LOCALE) {
			    ANYOF_CLASS_SET(data->start_class, classnum_to_namedclass(classnum));
d4876 8
a4883 1
                        else {
d4885 9
a4893 7
			/* Even if under locale, set the bits for non-locale
			 * in case it isn't a true locale-node.  This will
			 * create false positives if it truly is locale */
                        for (value = 0; value < loop_max; value++) {
                            if (_generic_isCC(UNI_TO_NATIVE(value), classnum)) {
                                ANYOF_BITMAP_SET(data->start_class, UNI_TO_NATIVE(value));
                            }
d4895 3
d4899 6
a4904 4
		    }
		    break;
		case NPOSIXA:
                    loop_max = 128;
d4906 12
a4917 1
		case NPOSIXL:
d4919 5
a4923 17
		case NPOSIXD:
                    classnum = FLAGS(scan);
		    if (flags & SCF_DO_STCLASS_AND) {
			if (!(data->start_class->flags & ANYOF_LOCALE)) {
			    ANYOF_CLASS_CLEAR(data->start_class, classnum_to_namedclass(classnum));
                            for (value = 0; value < loop_max; value++) {
                                if (_generic_isCC(UNI_TO_NATIVE(value), classnum)) {
                                    ANYOF_BITMAP_CLEAR(data->start_class, UNI_TO_NATIVE(value));
                                }
                            }
			}
		    }
		    else {
			if (data->start_class->flags & ANYOF_LOCALE) {
			    ANYOF_CLASS_SET(data->start_class, classnum_to_namedclass(classnum) + 1);
                        }
                        else {
d4925 20
a4944 14
			/* Even if under locale, set the bits for non-locale in
			 * case it isn't a true locale-node.  This will create
			 * false positives if it truly is locale */
                        for (value = 0; value < loop_max; value++) {
                            if (! _generic_isCC(UNI_TO_NATIVE(value), classnum)) {
                                ANYOF_BITMAP_SET(data->start_class, UNI_TO_NATIVE(value));
                            }
                        }
                        if (PL_regkind[OP(scan)] == NPOSIXD) {
                            data->start_class->flags |= ANYOF_NON_UTF8_LATIN1_ALL;
                        }
                        }
		    }
		    break;
d4947 1
a4947 1
		    cl_and(data->start_class, and_withp);
d4955 1
a4955 1
	    SCAN_COMMIT(pRExC_state, data, minlenp);
d4974 6
a4979 5
                    regprop(RExC_rx, mysv_val, upto);
                    PerlIO_printf(Perl_debug_log, "~ replace with OPFAIL pointed at %s (%"IVdf") offset %"IVdf"\n",
                                  SvPV_nolen_const(mysv_val),
                                  (IV)REG_NODE_NUM(upto),
                                  (IV)(upto - scan)
d4989 1
a4989 1
            if ( !PERL_ENABLE_POSITIVE_ASSERTION_STUDY 
d4996 1
a4996 1
                I32 deltanext, minnext, fake = 0;
d4998 1
a4998 1
                struct regnode_charclass_class intrnl;
d5011 1
a5011 1
                    cl_init(pRExC_state, &intrnl);
d5019 3
a5021 2
                minnext = study_chunk(pRExC_state, &nscan, minlenp, &deltanext, 
                    last, &data_fake, stopparen, recursed, NULL, f, depth+1);
d5027 2
a5028 1
			FAIL2("Lookbehind longer than %"UVuf" not implemented", (UV)U8_MAX);
d5047 1
a5047 1
			cl_init(pRExC_state, data->start_class);
d5049 5
a5053 6
			/* AND before and after: combine and continue */
			const int was = TEST_SSC_EOS(data->start_class);

			cl_and(data->start_class, &intrnl);
			if (was)
                            SET_SSC_EOS(data->start_class);
d5066 1
a5066 1
                I32 deltanext, fake = 0;
d5068 1
a5068 1
                struct regnode_charclass_class intrnl;
d5070 2
a5071 2
                /* We use SAVEFREEPV so that when the full compile 
                    is finished perl will clean up the allocated 
d5076 2
a5077 2
                I32 *minnextp;
                Newx( minnextp, 1, I32 );
d5084 2
a5085 2
                        if (scan->flags) 
                            SCAN_COMMIT(pRExC_state, &data_fake,minlenp);
d5097 1
a5097 1
                    cl_init(pRExC_state, &intrnl);
d5106 4
a5109 2
                *minnextp = study_chunk(pRExC_state, &nscan, minnextp, &deltanext, 
                    last, &data_fake, stopparen, recursed, NULL, f,depth+1);
d5115 2
a5116 1
			FAIL2("Lookbehind longer than %"UVuf" not implemented", (UV)U8_MAX);
d5124 2
a5125 5
                    const int was = TEST_SSC_EOS(data.start_class);

                    cl_and(data->start_class, &intrnl);
                    if (was)
                        SET_SSC_EOS(data->start_class);
d5136 1
a5136 1
                        SCAN_COMMIT(pRExC_state, &data_fake, minnextp);
d5138 2
a5139 2
                        
                        if ( data_fake.minlen_fixed != minlenp ) 
d5180 1
a5180 1
		SCAN_COMMIT(pRExC_state,data,minlenp);
d5192 1
a5192 1
		    SCAN_COMMIT(pRExC_state,data,minlenp);
d5197 1
a5197 1
		    cl_anything(pRExC_state, data->start_class);
d5201 2
a5202 2
	    if (!(RExC_rx->extflags & RXf_GPOS_FLOAT) &&
	        !(delta || is_inf || (data && data->pos_delta))) 
d5204 3
a5206 3
	        if (!(RExC_rx->extflags & RXf_ANCH) && (flags & SCF_DO_SUBSTR))
		    RExC_rx->extflags |= RXf_ANCH_GPOS;
	        if (RExC_rx->gofs < (U32)min)
d5209 1
a5209 1
                RExC_rx->extflags |= RXf_GPOS_FLOAT;
d5211 1
a5211 1
            }	    
d5222 2
a5223 2
            I32 max1 = 0, min1 = I32_MAX;
            struct regnode_charclass_class accum;
d5225 4
a5228 2
            if (flags & SCF_DO_SUBSTR) /* XXXX Add !SUSPEND? */
                SCAN_COMMIT(pRExC_state, data,minlenp); /* Cannot merge strings after this. */
d5230 2
a5231 2
                cl_init_zero(pRExC_state, &accum);
                
d5238 2
a5239 2
                
                for ( word=1 ; word <= trie->wordcount ; word++) 
d5241 3
a5243 3
                    I32 deltanext=0, minnext=0, f = 0, fake;
                    struct regnode_charclass_class this_class;
                    
d5253 1
a5253 1
                        cl_init(pRExC_state, &this_class);
d5259 1
a5259 1
    
d5265 5
a5269 6
                           it. Note this means we need the vestigal unused branches
                           even though they arent otherwise used.
                         */
                        minnext = study_chunk(pRExC_state, &scan, minlenp, 
                            &deltanext, (regnode *)nextbranch, &data_fake, 
                            stopparen, recursed, NULL, f,depth+1);
d5273 2
a5274 2
                    
                    if (min1 > (I32)(minnext + trie->minlen))
d5276 1
a5276 1
                    if (deltanext == I32_MAX) {
d5278 2
a5279 2
                        max1 = I32_MAX;
                    } else if (max1 < (I32)(minnext + deltanext + trie->maxlen))
d5281 1
a5281 1
                    
d5285 1
a5285 1
                        if ( stopmin > min + min1) 
d5297 1
a5297 1
                        cl_or(pRExC_state, &accum, &this_class);
d5309 1
a5309 1
                cl_or(pRExC_state, data->start_class, &accum);
d5311 1
a5311 1
                    cl_and(data->start_class, and_withp);
d5317 1
a5317 1
                    cl_and(data->start_class, &accum);
d5324 1
a5324 2
                    StructCopy(data->start_class, and_withp,
                               struct regnode_charclass_class);
d5326 1
a5326 2
                    StructCopy(&accum, data->start_class,
                               struct regnode_charclass_class);
a5327 1
                    SET_SSC_EOS(data->start_class);
d5337 1
a5337 1
	    
d5342 2
a5343 1
    	        SCAN_COMMIT(pRExC_state,data,minlenp);	/* Cannot expect anything... */
d5350 1
a5350 1
    	        flags &= ~SCF_DO_SUBSTR; 
d5358 8
d5367 3
d5373 3
d5385 2
a5386 1
    *deltap = is_inf_internal ? I32_MAX : delta;
d5388 1
a5388 1
	data->pos_delta = I32_MAX - data->pos_min;
d5400 1
a5400 1
	cl_and(data->start_class, and_withp);
d5403 1
a5403 1
    
d5405 10
a5414 2
    
    return min < stopmin ? min : stopmin;
d5418 1
a5418 1
S_add_data(RExC_state_t *pRExC_state, U32 n, const char *s)
d5479 1
a5479 1
#endif        
d5488 1
a5488 1
#ifndef PERL_IN_XSUB_RE 
d5501 1
a5501 1
	if (!table)
d5582 2
a5583 3
        const UV uv = NATIVE_TO_ASCII(src[s]);
        if (UNI_IS_INVARIANT(uv))
            dst[d]   = (U8)UTF_TO_NATIVE(uv);
d5585 2
a5586 2
            dst[d++] = (U8)UTF8_EIGHT_BIT_HI(uv);
            dst[d]   = (U8)UTF8_EIGHT_BIT_LO(uv);
d5650 1
d5669 1
a5669 1
            const I32 maxarg = AvFILL(av) + 1;
d5674 1
a5674 1
                    || oplist->op_type == OP_RV2AV); 
d5679 1
a5679 1
                U32 i;
d5683 1
a5683 1
                for (i=0; i < (U32)maxarg; i++) {
d5973 1
a5973 1
		Perl_croak_nocontext("%s", SvPV_nolen_const(errsv));
d6064 4
a6067 1
S_setup_longest(pTHX_ RExC_state_t *pRExC_state, SV* sv_longest, SV** rx_utf8, SV** rx_substr, I32* rx_end_shift, I32 lookbehind, I32 offset, I32 *minlen, STRLEN longest_length, bool eol, bool meol)
d6073 2
a6074 1
    I32 t,ml;
d6080 2
a6081 2
            /* See comments for join_exact for why REG_SEEN_EXACTF_SHARP_S */
        || (RExC_seen & REG_SEEN_EXACTF_SHARP_S))
d6099 1
a6099 1
    ml = minlen ? *(minlen) : (I32)longest_length;
d6168 1
a6168 1
    I32 minlen = 0;
d6179 2
d6187 1
a6187 1
#ifdef TRIE_STUDY_OPT    
d6190 1
a6190 1
#endif    
a6201 1
	PL_ASCII = _new_invlist_C_array(ASCII_invlist);
d6203 4
a6206 53

	PL_L1Posix_ptrs[_CC_ALPHANUMERIC]
                                = _new_invlist_C_array(L1PosixAlnum_invlist);
	PL_Posix_ptrs[_CC_ALPHANUMERIC]
                                = _new_invlist_C_array(PosixAlnum_invlist);

	PL_L1Posix_ptrs[_CC_ALPHA]
                                = _new_invlist_C_array(L1PosixAlpha_invlist);
	PL_Posix_ptrs[_CC_ALPHA] = _new_invlist_C_array(PosixAlpha_invlist);

	PL_Posix_ptrs[_CC_BLANK] = _new_invlist_C_array(PosixBlank_invlist);
	PL_XPosix_ptrs[_CC_BLANK] = _new_invlist_C_array(XPosixBlank_invlist);

        /* Cased is the same as Alpha in the ASCII range */
	PL_L1Posix_ptrs[_CC_CASED] =  _new_invlist_C_array(L1Cased_invlist);
	PL_Posix_ptrs[_CC_CASED] =  _new_invlist_C_array(PosixAlpha_invlist);

	PL_Posix_ptrs[_CC_CNTRL] = _new_invlist_C_array(PosixCntrl_invlist);
	PL_XPosix_ptrs[_CC_CNTRL] = _new_invlist_C_array(XPosixCntrl_invlist);

	PL_Posix_ptrs[_CC_DIGIT] = _new_invlist_C_array(PosixDigit_invlist);
	PL_L1Posix_ptrs[_CC_DIGIT] = _new_invlist_C_array(PosixDigit_invlist);

	PL_L1Posix_ptrs[_CC_GRAPH] = _new_invlist_C_array(L1PosixGraph_invlist);
	PL_Posix_ptrs[_CC_GRAPH] = _new_invlist_C_array(PosixGraph_invlist);

	PL_L1Posix_ptrs[_CC_LOWER] = _new_invlist_C_array(L1PosixLower_invlist);
	PL_Posix_ptrs[_CC_LOWER] = _new_invlist_C_array(PosixLower_invlist);

	PL_L1Posix_ptrs[_CC_PRINT] = _new_invlist_C_array(L1PosixPrint_invlist);
	PL_Posix_ptrs[_CC_PRINT] = _new_invlist_C_array(PosixPrint_invlist);

	PL_L1Posix_ptrs[_CC_PUNCT] = _new_invlist_C_array(L1PosixPunct_invlist);
	PL_Posix_ptrs[_CC_PUNCT] = _new_invlist_C_array(PosixPunct_invlist);

	PL_Posix_ptrs[_CC_SPACE] = _new_invlist_C_array(PerlSpace_invlist);
	PL_XPosix_ptrs[_CC_SPACE] = _new_invlist_C_array(XPerlSpace_invlist);
	PL_Posix_ptrs[_CC_PSXSPC] = _new_invlist_C_array(PosixSpace_invlist);
	PL_XPosix_ptrs[_CC_PSXSPC] = _new_invlist_C_array(XPosixSpace_invlist);

	PL_L1Posix_ptrs[_CC_UPPER] = _new_invlist_C_array(L1PosixUpper_invlist);
	PL_Posix_ptrs[_CC_UPPER] = _new_invlist_C_array(PosixUpper_invlist);

        PL_XPosix_ptrs[_CC_VERTSPACE] = _new_invlist_C_array(VertSpace_invlist);

	PL_Posix_ptrs[_CC_WORDCHAR] = _new_invlist_C_array(PosixWord_invlist);
	PL_L1Posix_ptrs[_CC_WORDCHAR]
                                = _new_invlist_C_array(L1PosixWord_invlist);

	PL_Posix_ptrs[_CC_XDIGIT] = _new_invlist_C_array(PosixXDigit_invlist);
	PL_XPosix_ptrs[_CC_XDIGIT] = _new_invlist_C_array(XPosixXDigit_invlist);

        PL_HasMultiCharFold = _new_invlist_C_array(_Perl_Multi_Char_Folds_invlist);
d6322 1
d6344 2
a6345 1
    /* XXX: note in the below we have to check the flags as well as the pattern.
d6347 2
a6348 3
     * Things get a touch tricky as we have to compare the utf8 flag independently
     * from the compile flags.
     */
d6365 2
a6366 2
    if (initial_charset == REGEX_LOCALE_CHARSET) {
	RExC_contains_locale = 1;
d6368 1
a6368 1
    else if (RExC_utf8 && initial_charset == REGEX_DEPENDS_CHARSET) {
d6396 1
d6411 1
a6411 1
    RExC_emit = &PL_regdummy;
d6421 2
d6460 1
a6460 1
        Perl_croak(aTHX_ "panic: reg returned NULL to re_op_compile for sizing pass, flags=%#X", flags);
d6466 1
a6466 1
        PerlIO_printf(Perl_debug_log, 
d6468 1
a6468 1
            "Starting second pass (creation)\n", 
d6470 2
a6471 2
        RExC_lastnum=0; 
        RExC_lastparse=NULL; 
d6490 2
a6491 2
    /* Allocate space and zero-initialize. Note, the two step process 
       of zeroing when in debug mode, thus anything assigned has to 
d6501 3
a6503 2
    Zero(ri, sizeof(regexp_internal) + (unsigned)RExC_size * sizeof(regnode), char);
#else 
d6505 1
a6505 1
    Zero(ri, sizeof(regexp_internal), char);        
d6529 2
a6530 1
        bool has_charset = (get_regex_charset(r->extflags) != REGEX_DEPENDS_CHARSET);
d6537 2
a6538 1
	bool has_runon = ((RExC_seen & REG_SEEN_RUN_ON_COMMENT)==REG_SEEN_RUN_ON_COMMENT);
d6599 4
a6602 2
    
    if (RExC_seen & REG_SEEN_RECURSE) {
d6608 9
d6645 2
a6646 2
	ReREFCNT_dec(rx);   
        Perl_croak(aTHX_ "panic: reg returned NULL to re_op_compile for generation pass, flags=%#X", flags);
d6657 1
a6657 1
    r->minlen = minlen = sawlookahead = sawplus = sawopen = 0;
d6659 3
d6670 1
a6670 1
        
d6672 2
a6673 2
        if (seen & REG_TOP_LEVEL_BRANCHES) 
            RExC_seen |= REG_TOP_LEVEL_BRANCHES;
d6675 1
a6675 1
            RExC_seen &= ~REG_TOP_LEVEL_BRANCHES;
d6680 1
a6680 1
#endif    
d6685 1
a6685 1
 
d6695 3
a6697 2
    if (!(RExC_seen & REG_TOP_LEVEL_BRANCHES)) { /*  Only one top-level choice. */
	I32 fake;
d6699 1
a6699 1
	struct regnode_charclass_class ch_class; /* pointed to by data */
d6701 1
a6701 1
	I32 last_close = 0; /* pointed to by data */
d6706 1
a6706 1
	 * so that we can extract the 'meat' of the pattern that must 
d6709 1
a6709 1
	 * picked up by the optimiser separately. 
d6726 1
a6726 1
		/* 
d6730 1
d6734 3
a6736 1
		else
d6738 1
a6738 1

d6755 1
a6755 1
	        ((reg_trie_data *)ri->data->data[ ARG(first) ])->minlen>0) 
d6781 2
a6782 2
	    r->extflags |= (OP(first) == MBOL
			   ? RXf_ANCH_MBOL
d6784 2
a6785 2
			      ? RXf_ANCH_SBOL
			      : RXf_ANCH_BOL));
d6790 1
a6790 1
	    r->extflags |= RXf_ANCH_GPOS;
d6797 1
a6797 1
	    !(r->extflags & RXf_ANCH) && !pRExC_state->num_code_blocks)
d6802 3
a6804 4
		    ? RXf_ANCH_MBOL
		    : RXf_ANCH_SBOL;
	    r->extflags |= type;
	    r->intflags |= PREGf_IMPLICIT;
d6808 2
a6809 1
	if (sawplus && !sawlookahead && (!sawopen || !RExC_sawback)
d6851 1
a6851 1
	    cl_init(pRExC_state, &ch_class);
d6857 8
a6864 4
        
	minlen = study_chunk(pRExC_state, &first, &minlen, &fake, scan + RExC_size, /* Up to end */
            &data, -1, NULL, NULL,
            SCF_DO_SUBSTR | SCF_WHILEM_VISITED_POS | stclass_flag,0);
d6873 3
a6875 2
	     && !(RExC_seen & REG_SEEN_VERBARG)
	     && (!(RExC_seen & REG_SEEN_GPOS) || (r->extflags & RXf_ANCH_GPOS)))
d6877 1
d6899 1
a6899 1
	    if (data.offset_float_max < I32_MAX) /* Don't offset infinity */
d6937 2
a6938 2
	    && ! TEST_SSC_EOS(data.start_class)
	    && !cl_is_anything(data.start_class))
d6940 3
a6942 2
	    const U32 n = add_data(pRExC_state, 1, "f");
	    OP(data.start_class) = ANYOF_SYNTHETIC;
d6944 1
a6944 2
	    Newx(RExC_rxi->data->data[n], 1,
		struct regnode_charclass_class);
d6946 2
a6947 2
		       (struct regnode_charclass_class*)RExC_rxi->data->data[n],
		       struct regnode_charclass_class);
d6951 1
a6951 1
	              regprop(r, sv, (regnode*)data.start_class);
d6955 1
d6958 2
a6959 1
	/* A temporary algorithm prefers floated substr to fixed one to dig more info. */
d6961 1
d6966 2
a6967 2
	    if (r->extflags & RXf_ANCH_SINGLE)
		r->extflags |= RXf_NOSCAN;
d6970 1
d6977 1
a6977 3
	/* XXXX Currently intuiting is not compatible with ANCH_GPOS.
	   This should be changed ASAP!  */
	if ((r->check_substr || r->check_utf8) && !(r->extflags & RXf_ANCH_GPOS)) {
d6982 2
d6988 1
a6988 1
            minlen= longest_fixed_length;     
d6993 3
a6995 3
	I32 fake;
	struct regnode_charclass_class ch_class;
	I32 last_close = 0;
d7000 1
a7000 1
	cl_init(pRExC_state, &ch_class);
d7004 8
a7011 4
        
	minlen = study_chunk(pRExC_state, &scan, &minlen, &fake, scan + RExC_size,
	    &data, -1, NULL, NULL, SCF_DO_STCLASS_AND|SCF_WHILEM_VISITED_POS,0);
        
d7017 6
a7022 5
	if (! TEST_SSC_EOS(data.start_class)
	    && !cl_is_anything(data.start_class))
	{
	    const U32 n = add_data(pRExC_state, 1, "f");
	    OP(data.start_class) = ANYOF_SYNTHETIC;
d7024 1
a7024 2
	    Newx(RExC_rxi->data->data[n], 1,
		struct regnode_charclass_class);
d7026 2
a7027 2
		       (struct regnode_charclass_class*)RExC_rxi->data->data[n],
		       struct regnode_charclass_class);
d7031 1
a7031 1
	              regprop(r, sv, (regnode*)data.start_class);
d7035 1
d7039 8
d7050 2
a7051 2
	PerlIO_printf(Perl_debug_log,"minlen: %"IVdf" r->minlen:%"IVdf"\n",
		      (IV)minlen, (IV)r->minlen);
d7054 1
a7054 1
    if (r->minlen < minlen) 
d7056 6
a7061 5
    
    if (RExC_seen & REG_SEEN_GPOS)
	r->extflags |= RXf_GPOS_SEEN;
    if (RExC_seen & REG_SEEN_LOOKBEHIND)
        r->extflags |= RXf_NO_INPLACE_SUBST; /* inplace might break the lookbehind */
d7064 3
a7066 3
    if (RExC_seen & REG_SEEN_CANY)
	r->extflags |= RXf_CANY_SEEN;
    if (RExC_seen & REG_SEEN_VERBARG)
d7071 1
a7071 1
    if (RExC_seen & REG_SEEN_CUTGROUP)
d7080 6
d7087 7
d7103 3
a7105 1
        else if (fop == PLUS && PL_regkind[nop] == POSIXD && FLAGS(next) == _CC_SPACE && OP(regnext(first)) == END)
d7107 5
a7111 1
        else if ( r->extflags & RXf_SPLIT && fop == EXACT && STR_LEN(first) == 1 && *(STRING(first)) == ' ' && OP(regnext(first)) == END )
d7115 5
d7122 3
a7124 2
        ri->name_list_idx = add_data( pRExC_state, 1, "a" );
        ri->data->data[ri->name_list_idx] = (void*)SvREFCNT_inc(RExC_paren_name_list);
d7139 1
d7145 2
a7146 2
        const U32 len = ri->u.offsets[0];
        U32 i;
d7148 2
a7149 1
        PerlIO_printf(Perl_debug_log, "Offsets: [%"UVuf"]\n\t", (UV)ri->u.offsets[0]);
d7209 2
a7210 1
        Perl_croak(aTHX_ "panic: Unknown flags %d in named_buff_iter", (int)flags);
d7336 1
a7336 1
    I32 length;
d7347 1
a7347 1
            length = av_len(av);
d7351 2
a7352 1
            Perl_croak(aTHX_ "panic: Unknown flags %d in named_buff_scalar", (int)flags);
d7400 2
a7401 2
    I32 i = 0;
    I32 s1, t1;
d7405 1
a7405 1
        
d7438 1
a7438 1
    else 
d7445 1
a7445 1
    } 
d7456 1
a7456 1
    }          
d7459 1
a7459 1
    assert(rx->sublen >= (s - rx->subbeg) + i );
d7461 1
a7461 1
#if NO_TAINT_SUPPORT
d7469 1
a7469 1
        if ( (rx->extflags & RXf_CANY_SEEN)
d7494 1
a7494 1
            } else 
d7629 3
a7631 1
    if (isIDFIRST_lazy_if(RExC_parse, UTF)) {
d7642 2
a7643 1
	RExC_parse++; /* so the <- from the vFAIL is after the offending character */
d7723 6
a7728 5
 * with some added info that is placed as UVs at the beginning in a header
 * portion.  An inversion list for Unicode is an array of code points, sorted
 * by ordinal number.  The zeroth element is the first code point in the list.
 * The 1th element is the first element beyond that not in the list.  In other
 * words, the first range is
d7746 3
a7748 3
 * list to contain 0 when the list contains 0, and contains 1 otherwise.  The
 * actual beginning of the list is either that element if 0, or the next one if
 * 1.
a7762 4
#define TO_INTERNAL_SIZE(x) (((x) + HEADER_LENGTH) * sizeof(UV))
#define FROM_INTERNAL_SIZE(x) (((x)/ sizeof(UV)) - HEADER_LENGTH)

#define INVLIST_INITIAL_LEN 10
d7769 5
a7773 5
     * array begins depends on whether the list has the code point U+0000
     * in it or not.  The other parameter tells it whether the code that
     * follows this call is about to put a 0 in the inversion list or not.
     * The first element is either the element with 0, if 0, or the next one,
     * if 1 */
d7775 2
a7776 1
    UV* zero = get_invlist_zero_addr(invlist);
d7781 3
a7783 1
    assert(! *_get_invlist_len_addr(invlist));
d7786 2
a7787 2
    *zero = 1 ^ will_have_0;
    return zero + *zero;
d7801 8
a7808 9
    assert(*_get_invlist_len_addr(invlist));
    assert(*get_invlist_zero_addr(invlist) == 0
	   || *get_invlist_zero_addr(invlist) == 1);

    /* The array begins either at the element reserved for zero if the
     * list contains 0 (that element will be set to 0), or otherwise the next
     * element (in which case the reserved element will be set to 1). */
    return (UV *) (get_invlist_zero_addr(invlist)
		   + *get_invlist_zero_addr(invlist));
d7812 1
a7812 1
S_invlist_set_len(pTHX_ SV* const invlist, const UV len)
d7814 2
a7815 1
    /* Sets the current number of elements stored in the inversion list */
d7819 1
a7819 1
    *_get_invlist_len_addr(invlist) = len;
d7821 5
a7825 16
    assert(len <= SvLEN(invlist));

    SvCUR_set(invlist, TO_INTERNAL_SIZE(len));
    /* If the list contains U+0000, that element is part of the header,
     * and should not be counted as part of the array.  It will contain
     * 0 in that case, and 1 otherwise.  So we could flop 0=>1, 1=>0 and
     * subtract:
     *	SvCUR_set(invlist,
     *		  TO_INTERNAL_SIZE(len
     *				   - (*get_invlist_zero_addr(inv_list) ^ 1)));
     * But, this is only valid if len is not 0.  The consequences of not doing
     * this is that the memory allocation code may think that 1 more UV is
     * being used than actually is, and so might do an unnecessary grow.  That
     * seems worth not bothering to make this the precise amount.
     *
     * Note that when inverting, SvCUR shouldn't change */
d7831 1
a7831 1
    /* Return the address of the UV that is reserved to hold the cached index
d7836 3
a7838 1
    return (IV *) (SvPVX(invlist) + (INVLIST_PREVIOUS_INDEX_OFFSET * sizeof (UV)));
d7871 4
d7876 2
a7877 15
           ? _invlist_len(invlist)
           : FROM_INTERNAL_SIZE(SvLEN(invlist));
}

PERL_STATIC_INLINE UV*
S_get_invlist_zero_addr(pTHX_ SV* invlist)
{
    /* Return the address of the UV that is reserved to hold 0 if the inversion
     * list contains 0.  This has to be the last element of the heading, as the
     * list proper starts with either it if 0, or the next element if not.
     * (But we force it to contain either 0 or 1) */

    PERL_ARGS_ASSERT_GET_INVLIST_ZERO_ADDR;

    return (UV *) (SvPVX(invlist) + (INVLIST_ZERO_OFFSET * sizeof (UV)));
d7892 1
a7892 1
	initial_size = INVLIST_INITIAL_LEN;
d7896 6
a7901 2
    new_list = newSV(TO_INTERNAL_SIZE(initial_size));
    invlist_set_len(new_list, 0);
d7904 1
a7904 5
    *get_invlist_iter_addr(new_list) = UV_MAX;

    /* This should force a segfault if a method doesn't initialize this
     * properly */
    *get_invlist_zero_addr(new_list) = UV_MAX;
a7906 4
    *get_invlist_version_id_addr(new_list) = INVLIST_VERSION_ID;
#if HEADER_LENGTH != 5
#   error Need to regenerate INVLIST_VERSION_ID by running perl -E 'say int(rand 2**31-1)', and then changing the #if to the new length
#endif
a7909 1
#endif
d7911 2
a7912 2
STATIC SV*
S__new_invlist_C_array(pTHX_ UV* list)
d7917 17
a7933 1
     * should not be used in the wrong hands */
d7935 1
a7935 1
    SV* invlist = newSV_type(SVt_PV);
d7939 8
a7946 1
    SvPV_set(invlist, (char *) list);
a7948 1
    SvCUR_set(invlist, TO_INTERNAL_SIZE(_invlist_len(invlist)));
d7950 8
a7957 3
    if (*get_invlist_version_id_addr(invlist) != INVLIST_VERSION_ID) {
        Perl_croak(aTHX_ "panic: Incorrect version for previously generated inversion list");
    }
d7959 1
a7959 5
    /* Initialize the iteration pointer.
     * XXX This could be done at compile time in charclass_invlists.h, but I
     * (khw) am not confident that the suffixes for specifying the C constant
     * UV_MAX are portable, e.g.  'ull' on a 32 bit machine that is configured
     * to use 64 bits; might need a Configure probe */
d7962 2
d7966 1
d7975 5
a7979 1
    SvGROW((SV *)invlist, TO_INTERNAL_SIZE(new_max));
d7987 2
a7990 1

a7993 2
#define _invlist_union_complement_2nd(a, b, output) _invlist_union_maybe_complement_2nd(a, b, TRUE, output)

d7995 2
a7996 1
S__append_range_to_invlist(pTHX_ SV* const invlist, const UV start, const UV end)
d8005 1
d8010 2
a8011 1
        array = _invlist_array_init(invlist, start == 0);
d8026 2
a8027 2
		       array[final_element], start,
		       ELEMENT_RANGE_MATCHES_INVLIST(final_element) ? 't' : 'f');
d8034 1
d8042 1
a8042 1
		invlist_set_len(invlist, len - 1);
d8052 2
a8053 2
    /* If overflows the existing space, extend, which may cause the array to be
     * moved */
d8056 4
a8059 2
	invlist_set_len(invlist, len);	/* Have to set len here to avoid assert
					   failure in invlist_array() */
d8063 1
a8063 1
	invlist_set_len(invlist, len);
d8075 1
a8075 1
	invlist_set_len(invlist, len - 1);
d8170 2
a8171 1
Perl__invlist_populate_swatch(pTHX_ SV* const invlist, const UV start, const UV end, U8* swatch)
d8264 2
a8265 1
Perl__invlist_union_maybe_complement_2nd(pTHX_ SV* const a, SV* const b, bool complement_b, SV** output)
d8269 5
a8273 4
     * the reference count to that list will be decremented.  The first list,
     * <a>, may be NULL, in which case a copy of the second list is returned.
     * If <complement_b> is TRUE, the union is taken of the complement
     * (inversion) of <b> instead of b itself.
d8288 2
a8289 2
    UV* array_a;    /* a's array */
    UV* array_b;
d8314 2
d8318 3
a8320 1
                SvREFCNT_dec_NN(a);
d8329 4
d8336 1
d8338 3
a8340 1
	    SvREFCNT_dec_NN(b);
d8347 3
a8349 1
                SvREFCNT_dec_NN(a);
d8358 4
d8374 1
a8374 2
	 * do this, we just pretend the array starts one later, and clear the
	 * flag as we don't have to do anything else later */
a8377 1
            complement_b = FALSE;
d8381 2
a8382 5
            /* But if the first element is not zero, we unshift a 0 before the
             * array.  The data structure reserves a space for that 0 (which
             * should be a '1' right now), so physical shifting is unneeded,
             * but temporarily change that element to 0.  Before exiting the
             * routine, we must restore the element to '1' */
a8384 1
            array_b[0] = 0;
d8480 1
a8480 1
	invlist_set_len(u, len_u);
d8501 3
a8503 6
    /* If we've changed b, restore it */
    if (complement_b) {
        array_b[0] = 1;
    }

    /*  We may be removing a reference to one of the inputs */
d8506 6
a8511 1
	SvREFCNT_dec_NN(*output);
d8515 1
d8520 2
a8521 1
Perl__invlist_intersection_maybe_complement_2nd(pTHX_ SV* const a, SV* const b, bool complement_b, SV** i)
d8525 6
a8530 3
     * the reference count to that list will be decremented.
     * If <complement_b> is TRUE, the result will be the intersection of <a>
     * and the complement (or inversion) of <b> instead of <b> directly.
d8541 2
a8542 2
    UV* array_a;		/* a's array */
    UV* array_b;
d8566 1
a8566 1
    len_a = _invlist_len(a);
d8568 1
a8576 2
                *i = invlist_clone(a);

d8578 3
a8580 1
                    SvREFCNT_dec_NN(b);
d8582 2
d8586 4
d8596 3
a8598 1
	    SvREFCNT_dec_NN(a);
d8601 3
a8603 1
	    SvREFCNT_dec_NN(b);
d8606 4
d8622 1
a8622 2
	 * do this, we just pretend the array starts one later, and clear the
	 * flag as we don't have to do anything else later */
a8625 1
            complement_b = FALSE;
d8629 2
a8630 5
            /* But if the first element is not zero, we unshift a 0 before the
             * array.  The data structure reserves a space for that 0 (which
             * should be a '1' right now), so physical shifting is unneeded,
             * but temporarily change that element to 0.  Before exiting the
             * routine, we must restore the element to '1' */
a8632 1
            array_b[0] = 0;
d8714 2
a8715 1
     * intersection.  At most one of the subexpressions below will be non-zero */
d8724 1
a8724 1
	invlist_set_len(r, len_r);
d8740 3
a8742 6
    /* If we've changed b, restore it */
    if (complement_b) {
        array_b[0] = 1;
    }

    /*  We may be removing a reference to one of the inputs */
d8745 6
a8750 1
	SvREFCNT_dec_NN(*i);
d8754 1
d8801 29
a8844 2
    UV* len_pos = _get_invlist_len_addr(invlist);

d8850 1
a8850 1
    if (*len_pos == 0) {
d8855 1
a8855 9
    /* The exclusive or complents 0 to 1; and 1 to 0.  If the result is 1, the
     * zero element was a 0, so it is being removed, so the length decrements
     * by 1; and vice-versa.  SvCUR is unaffected */
    if (*get_invlist_zero_addr(invlist) ^= 1) {
	(*len_pos)--;
    }
    else {
	(*len_pos)++;
    }
a8857 37
void
Perl__invlist_invert_prop(pTHX_ SV* const invlist)
{
    /* Complement the input inversion list (which must be a Unicode property,
     * all of which don't match above the Unicode maximum code point.)  And
     * Perl has chosen to not have the inversion match above that either.  This
     * adds a 0x110000 if the list didn't end with it, and removes it if it did
     */

    UV len;
    UV* array;

    PERL_ARGS_ASSERT__INVLIST_INVERT_PROP;

    _invlist_invert(invlist);

    len = _invlist_len(invlist);

    if (len != 0) { /* If empty do nothing */
	array = invlist_array(invlist);
	if (array[len - 1] != PERL_UNICODE_MAX + 1) {
	    /* Add 0x110000.  First, grow if necessary */
	    len++;
	    if (invlist_max(invlist) < len) {
		invlist_extend(invlist, len);
		array = invlist_array(invlist);
	    }
	    invlist_set_len(invlist, len);
	    array[len - 1] = PERL_UNICODE_MAX + 1;
	}
	else {  /* Remove the 0x110000 */
	    invlist_set_len(invlist, len - 1);
	}
    }

    return;
}
d8865 1
a8865 1
     * unchanged */
d8870 2
a8871 1
    STRLEN length = SvCUR(invlist);
d8875 3
a8877 2
    SvCUR_set(new_invlist, length); /* This isn't done automatically */
    Copy(SvPVX(invlist), SvPVX(new_invlist), length, char);
d8882 1
a8882 1
PERL_STATIC_INLINE UV*
d8890 1
a8890 9
    return (UV *) (SvPVX(invlist) + (INVLIST_ITER_OFFSET * sizeof (UV)));
}

PERL_STATIC_INLINE UV*
S_get_invlist_version_id_addr(pTHX_ SV* invlist)
{
    /* Return the address of the UV that contains the version id. */

    PERL_ARGS_ASSERT_GET_INVLIST_VERSION_ID_ADDR;
d8892 1
a8892 1
    return (UV *) (SvPVX(invlist) + (INVLIST_VERSION_ID_OFFSET * sizeof (UV)));
d8916 1
a8916 1
    *get_invlist_iter_addr(invlist) = UV_MAX;
d8929 1
a8929 1
    UV* pos = get_invlist_iter_addr(invlist);
d8936 1
a8936 1
	*pos = UV_MAX;	/* Force iterinit() to be required next time */
d8959 1
a8959 1
    return *(get_invlist_iter_addr(invlist)) < UV_MAX;
d9025 1
a9025 1
#ifdef PERL_ARGS_ASSERT__INVLIST_DUMP
d9027 2
a9028 1
Perl__invlist_dump(pTHX_ SV* const invlist, const char * const header)
d9030 13
a9042 2
    /* Dumps out the ranges in an inversion list.  The string 'header'
     * if present is output on a line before the first range */
d9045 1
a9048 3
    if (header && strlen(header)) {
	PerlIO_printf(Perl_debug_log, "%s\n", header);
    }
d9050 3
a9052 1
        PerlIO_printf(Perl_debug_log, "Can't dump because is in middle of iterating\n");
d9059 3
a9061 1
	    PerlIO_printf(Perl_debug_log, "0x%04"UVXf" .. INFINITY\n", start);
d9064 3
a9066 2
	    PerlIO_printf(Perl_debug_log, "0x%04"UVXf" .. 0x%04"UVXf"\n",
		                                 start,         end);
d9069 2
a9070 1
	    PerlIO_printf(Perl_debug_log, "0x%04"UVXf"\n", start);
d9072 1
d9077 1
a9077 1
#if 0
d9079 1
a9079 1
S__invlistEQ(pTHX_ SV* const a, SV* const b, bool complement_b)
d9085 2
a9086 2
    UV* array_a = invlist_array(a);
    UV* array_b = invlist_array(b);
d9108 1
a9108 2
             * one later, and clear the flag as we don't have to do anything
             * else later */
a9111 1
            complement_b = FALSE;
d9115 2
a9116 5
            /* But if the first element is not zero, we unshift a 0 before the
             * array.  The data structure reserves a space for that 0 (which
             * should be a '1' right now), so physical shifting is unneeded,
             * but temporarily change that element to 0.  Before exiting the
             * routine, we must restore the element to '1' */
a9118 1
            array_b[0] = 0;
a9134 3
    if (complement_b) {
        array_b[0] = 1;
    }
a9139 1
#undef INVLIST_INITIAL_LENGTH
a9141 3
#undef INVLIST_LEN_OFFSET
#undef INVLIST_ZERO_OFFSET
#undef INVLIST_ITER_OFFSET
a9142 1
#undef INVLIST_PREVIOUS_INDEX_OFFSET
d9147 1
a9147 1
S_parse_lparen_question_flags(pTHX_ struct RExC_state_t *pRExC_state)
d9161 1
a9161 1
#define WASTED_GC (0x02|0x04)
a9206 1
                RExC_contains_locale = 1;
d9260 2
a9261 1
                    vFAIL2("Regexp modifier \"%c\" may not appear twice", *(RExC_parse - 1));
d9269 2
a9270 1
                vFAIL2("Regexp modifier \"%c\" may not appear after the \"-\"", *(RExC_parse - 1));
d9275 3
a9277 1
                    const I32 wflagbit = *RExC_parse == 'o' ? WASTED_O : WASTED_G;
d9280 1
d9297 1
d9330 3
d9337 4
a9340 3
                RExC_parse++;
                vFAIL3("Sequence (%.*s...) not recognized",
                       RExC_parse-seqstart, seqstart);
d9415 2
a9416 1
	    int internal_argval = 0; /* internal_argval is only useful if !argok */
d9432 1
a9432 1
	        while ( *RExC_parse && *RExC_parse != ')' ) 
d9434 1
a9434 1
	        if ( *RExC_parse != ')' ) 
d9442 1
a9442 1
	    
d9471 2
a9472 2
            case 'S':   /* (*SKIP) */  
                if ( memEQs(start_verb,verb_len,"SKIP") ) 
d9479 1
a9479 1
                    RExC_seen |= REG_SEEN_CUTGROUP;
d9484 4
a9487 3
	        RExC_parse++;
	        vFAIL3("Unknown verb pattern '%.*s'",
	            verb_len, start_verb);
d9492 1
a9492 1
	                verb_len, start_verb); 
d9495 1
a9495 1
	                verb_len, start_verb);    
d9500 4
a9503 2
                            SV *sv = newSVpvn( start_arg, RExC_parse - start_arg);
                            ARG(ret) = add_data( pRExC_state, 1, "S" );
d9507 1
a9507 1
                            ret->flags = 1; 
d9509 1
a9509 1
                    }	            
d9512 1
a9512 1
	            RExC_seen |= REG_SEEN_VERBARG;
d9515 1
a9515 1
	                verb_len, start_verb);    
d9521 2
a9522 2
        } else 
	if (*RExC_parse == '?') { /* (?...) */
d9542 3
a9544 2
                    /* this pretty much dupes the code for \k<NAME> in regatom(), if
                       you change this make sure you change that */
d9550 1
d9554 1
a9554 1
                        num = add_data( pRExC_state, 1, "S" );
d9573 1
a9573 1
                    Set_Node_Cur_Length(ret); /* MJD */
d9579 3
a9581 1
		vFAIL3("Sequence (%.*s...) not recognized", RExC_parse-seqstart, seqstart);
d9586 1
a9586 1
		else if (*RExC_parse != '=') 
d9595 4
a9598 9
    		        SIZE_ONLY ?  /* reverse test from the others */
    		        REG_RSN_RETURN_NAME : 
    		        REG_RSN_RETURN_NULL);
		    if (RExC_parse == name_start) {
		        RExC_parse++;
		        vFAIL3("Sequence (%.*s...) not recognized", RExC_parse-seqstart, seqstart);
		        /*NOTREACHED*/
                    }
		    if (*RExC_parse != paren)
d9638 2
a9639 1
                                pv = (I32*)SvGROW(sv_dat, SvCUR(sv_dat) + sizeof(I32)+1);
d9646 2
a9647 1
                            sv_setpvn(sv_dat, (char *)&(RExC_npar), sizeof(I32));
d9652 4
a9655 2
			/* Yes this does cause a memory leak in debugging Perls */
                        if (!av_store(RExC_paren_name_list, RExC_npar, SvREFCNT_inc(svname)))
d9665 1
a9665 1
                RExC_seen |= REG_SEEN_LOOKBEHIND;
d9682 1
a9682 1
	        paren = ':'; 
d9709 1
d9724 2
d9739 1
a9739 1
                } 
d9751 1
a9751 1
	        if (*RExC_parse!=')') 
d9785 2
a9786 1
			"Recurse #%"UVuf" to %"IVdf"\n", (UV)ARG(ret), (IV)ARG2L(ret)));
d9790 1
a9790 1
    		RExC_seen |= REG_SEEN_RECURSE;
d9804 4
a9807 1
		    vFAIL3("Sequence (%.*s...) not recognized", RExC_parse-seqstart, seqstart);
d9836 1
a9836 1
			n = add_data(pRExC_state, 2, "rl");
d9842 2
a9843 2
			n = add_data(pRExC_state, 1,
			       (RExC_pm_flags & PMf_HAS_CV) ? "L" : "l");
d9881 1
a9881 1
                        
d9904 1
a9904 1
                        num = add_data( pRExC_state, 1, "S" );
d9934 3
a9936 1
    		            SIZE_ONLY ? REG_RSN_RETURN_NULL : REG_RSN_RETURN_DATA);
d9939 1
a9939 1
		    ret = reganode(pRExC_state,INSUBP,parno); 
d9945 1
d9953 6
a9958 1
		    if ((c = *nextchar(pRExC_state)) != ')')
d9960 1
d9969 2
a9970 2
                        FAIL2("panic: regbranch returned NULL, flags=%#X",
                              flags);
d9972 2
a9973 1
                        REGTAIL(pRExC_state, br, reganode(pRExC_state, LONGJMP, 0));
d9978 1
a9978 1
		        if (is_define) 
d9980 4
a9983 1
			lastbr = reganode(pRExC_state, IFTHEN, 0); /* Fake one for optimizer. */
d9989 2
a9990 2
                            FAIL2("panic: regbranch returned NULL, flags=%#X",
                                  flags);
d10015 2
a10016 1
		    vFAIL2("Unknown switch condition (?(%.2s", RExC_parse);
d10045 1
a10045 1
	    
d10048 1
a10048 1
	        if (!RExC_nestroot) 
d10050 1
a10050 1
	        if (RExC_seen & REG_SEEN_RECURSE
d10054 1
a10054 1
			"Setting open paren #%"IVdf" to %d\n", 
d10066 1
a10066 1
   
d10079 1
a10079 1
        FAIL2("panic: regbranch returned NULL, flags=%#X", flags);
d10107 3
a10109 1
            REGTAIL(pRExC_state, NEXTOPER(NEXTOPER(lastbr)), ender); /* Append to the previous. */
d10117 1
a10117 1
            RExC_npar = freeze_paren;	    
d10126 1
a10126 1
            FAIL2("panic: regbranch returned NULL, flags=%#X", flags);
d10141 1
a10141 1
	    if (!SIZE_ONLY && RExC_seen & REG_SEEN_RECURSE) {
d10143 1
a10143 1
			"Setting close paren #%"IVdf" to %d\n", 
d10146 1
a10146 1
	        if (RExC_nestroot == parno) 
d10148 1
a10148 1
	    }	    
d10173 2
a10174 2
            regprop(RExC_rx, mysv_val1, lastbr);
            regprop(RExC_rx, mysv_val2, ender);
d10188 1
a10188 1
	        RExC_seen |= REG_TOP_LEVEL_BRANCHES;
d10195 2
a10196 1
                    if (OP(NEXTOPER(br)) != NOTHING || regnext(NEXTOPER(br)) != ender)
d10202 2
a10203 1
                    if (OP(NEXTOPER(NEXTOPER(br))) != NOTHING || regnext(NEXTOPER(NEXTOPER(br))) != ender)
d10214 2
a10215 2
                    regprop(RExC_rx, mysv_val1, ret);
                    regprop(RExC_rx, mysv_val2, ender);
d10249 1
a10249 1
	    Set_Node_Cur_Length(ret);
d10333 1
a10333 1
            FAIL2("panic: regpiece returned NULL, flags=%#X", flags);
d10403 1
a10403 1
            FAIL2("panic: regatom returned NULL, flags=%#X", flags);
d10457 13
d10476 1
a10476 1
                Set_Node_Cur_Length(ret);
d10511 2
d10550 1
d10560 1
d10573 6
a10578 4
	ckWARN3reg(RExC_parse,
		   "%.*s matches null string many times",
		   (int)(RExC_parse >= origparse ? RExC_parse - origparse : 0),
		   origparse);
a10586 1
#ifndef REG_ALLOW_MINMOD_SUSPEND
a10587 1
#endif
a10596 1
        /*ret= ender;*/
d10608 3
a10610 2
S_grok_bslash_N(pTHX_ RExC_state_t *pRExC_state, regnode** node_p, UV *valuep, I32 *flagp, U32 depth, bool in_char_class,
        const bool strict   /* Apply stricter parsing rules? */
d10613 1
a10613 1
   
d10668 1
a10668 1
 
d10676 2
a10677 1
     * modifier.  The other meaning does not */
d10687 1
a10687 1
	    /* no bare \N in a charclass */
d10693 2
a10698 1
	RExC_parse--;
d10717 4
a10720 2
	      || (endbrace - RExC_parse >= 2	/* U+ (bad hex is checked below */
		  && strnEQ(RExC_parse, "U+", 2)))) /* for a better error msg) */
d10856 3
a10858 3
            FAIL2("panic: reg returned NULL to grok_bslash_N, flags=%#X",
                  flags);
        } 
d10926 3
a10928 1
S_alloc_maybe_populate_EXACT(pTHX_ RExC_state_t *pRExC_state, regnode *node, I32* flagp, STRLEN len, UV code_point)
d10943 4
a10946 2
     * additionally will populate the node's STRING with <code_point>, if <len>
     * is 0.  In both cases <*flagp> is appropriately set
d10950 6
a10955 1
     * match 'ss') */
d10962 6
d10970 29
a10998 2
            if (FOLD && (! LOC || code_point > 255)) {
                _to_uni_fold_flags(NATIVE_TO_UNI(code_point),
d11001 16
a11016 5
                                   FOLD_FLAGS_FULL | ((LOC)
                                                     ? FOLD_FLAGS_LOCALE
                                                     : (ASCII_FOLD_RESTRICTED)
                                                       ? FOLD_FLAGS_NOMIX_ASCII
                                                       : 0));
d11022 9
a11030 6
        }
        else if (! FOLD
                 || code_point != LATIN_SMALL_LETTER_SHARP_S
                 || ASCII_FOLD_RESTRICTED
                 || ! AT_LEAST_UNI_SEMANTICS)
        {
d11033 13
a11045 2
        }
        else {
d11050 4
d11077 20
d11099 1
d11160 1
a11160 1
   TRYAGAIN.  
d11234 2
a11235 2
            FAIL2("panic: regclass returned NULL to regatom, flags=%#X",
                  *flagp);
d11257 2
a11258 1
                FAIL2("panic: reg returned NULL to regatom, flags=%#X", flags);
d11306 1
a11306 1
	    RExC_seen |= REG_SEEN_GPOS;
d11317 1
a11317 1
	    RExC_seen |= REG_SEEN_LOOKBEHIND;
d11331 1
a11331 1
	    RExC_seen |= REG_SEEN_CANY;
d11348 1
a11348 1
	    RExC_seen |= REG_SEEN_LOOKBEHIND;
d11353 3
d11360 2
a11361 1
		ckWARNdep(RExC_parse, "\"\\b{\" is deprecated; use \"\\b\\{\" or \"\\b[{]\" instead");
d11366 1
a11366 1
	    RExC_seen |= REG_SEEN_LOOKBEHIND;
d11371 3
d11378 2
a11379 1
		ckWARNdep(RExC_parse, "\"\\B{\" is deprecated; use \"\\B\\{\" or \"\\B[{]\" instead");
d11423 3
d11441 1
a11441 1
         finish_meta_pat:	    
d11444 1
a11444 1
	    break;	    
d11464 2
a11465 2
                    FAIL2("panic: regclass returned NULL to regatom, flags=%#X",
                          *flagp);
d11470 1
a11470 1
		Set_Node_Cur_Length(ret);
d11474 1
a11474 1
        case 'N': 
d11496 2
a11497 2
        {   
            char ch= RExC_parse[1];	    
d11500 1
d11511 1
d11515 1
a11515 1
                    num = add_data( pRExC_state, 1, "S" );
d11536 1
a11536 1
                Set_Node_Cur_Length(ret); /* MJD */
d11542 1
a11542 1
	case 'g': 
a11546 2
		bool isg = *RExC_parse == 'g';
		bool isrel = 0; 
d11548 4
a11551 1
		if (isg) {
d11563 1
a11563 1
                        RExC_parse -= 2;		            
d11565 29
a11593 8
		}   }
		num = atoi(RExC_parse);
		if (isg && num == 0)
		    vFAIL("Reference to invalid group 0");
                if (isrel) {
                    num = RExC_npar - num;
                    if (num < 1)
                        vFAIL("Reference to nonexistent or unclosed group");
d11595 5
a11599 4
		if (!isg && num > 9 && num >= RExC_npar)
                    /* Probably a character specified in octal, e.g. \35 */
		    goto defchar;
		else {
d11601 1
a11603 2
	            if (parse_start == RExC_parse - 1) 
	                vFAIL("Unterminated \\g... pattern");
d11605 1
a11605 1
                        if (*RExC_parse != '}') 
d11608 1
a11608 1
                    }    
d11629 1
a11629 1
                    Set_Node_Cur_Length(ret); /* MJD */
d11662 1
a11662 1
	    UV ender;
d11669 1
a11669 2
	    STRLEN foldlen;
            U8 node_type;
d11673 13
a11690 2
	    ender = 0;
            node_type = compute_EXACTish(pRExC_state);
d11701 3
a11703 4
            /* We do the EXACTFish to EXACT node only if folding, and not if in
             * locale, as whether a character folds or not isn't known until
             * runtime */
            maybe_exact = FOLD && ! LOC;
d11768 2
a11769 1
		    case 'X':             /* eXtended Unicode "combining character sequence" */
d11817 1
a11817 1
			  ender = ASCII_TO_NATIVE('\007');
d11880 1
a11880 1
			ender = grok_bslash_c(*p++, UTF, SIZE_ONLY);
d11882 4
a11885 1
		    case '0': case '1': case '2': case '3':case '4':
d11887 23
a11909 2
			if (*p == '0' ||
			    (isDIGIT(p[1]) && atoi(p) >= RExC_npar))
a11927 5
                        else {  /* Not to be treated as an octal constant, go
                                   find backref */
			    --p;
			    goto loopdone;
			}
a11930 6
                    case '8': case '9': /* These are illegal unless backrefs */
                        if (atoi(p) <= RExC_npar) {
                            --p;   /* backup to backslash; handle as backref */
                            goto loopdone;
                        }
                        goto unrecognized;
a11944 1
                    unrecognized:
d11959 2
a11960 2
                        && ckWARN(WARN_DEPRECATED)
                        && is_PATWS_non_low(p, UTF))
d11998 35
a12032 4
		if (FOLD) {
                    if (UTF
                            /* See comments for join_exact() as to why we fold
                             * this non-UTF at compile time */
d12034 23
a12056 2
                            && ender == LATIN_SMALL_LETTER_SHARP_S))
                    {
d12058 21
d12080 21
a12100 14
                        /* Prime the casefolded buffer.  Locale rules, which
                         * apply only to code points < 256, aren't known until
                         * execution, so for them, just output the original
                         * character using utf8.  If we start to fold non-UTF
                         * patterns, be sure to update join_exact() */
                        if (LOC && ender < 256) {
                            if (UNI_IS_INVARIANT(ender)) {
                                *s = (U8) ender;
                                foldlen = 1;
                            } else {
                                *s = UTF8_TWO_BYTE_HI(ender);
                                *(s + 1) = UTF8_TWO_BYTE_LO(ender);
                                foldlen = 2;
                            }
d12103 6
a12108 36
                            UV folded = _to_uni_fold_flags(
                                           ender,
                                           (U8 *) s,
                                           &foldlen,
                                           FOLD_FLAGS_FULL
                                           | ((LOC) ?  FOLD_FLAGS_LOCALE
                                                    : (ASCII_FOLD_RESTRICTED)
                                                      ? FOLD_FLAGS_NOMIX_ASCII
                                                      : 0)
                                            );

                            /* If this node only contains non-folding code
                             * points so far, see if this new one is also
                             * non-folding */
                            if (maybe_exact) {
                                if (folded != ender) {
                                    maybe_exact = FALSE;
                                }
                                else {
                                    /* Here the fold is the original; we have
                                     * to check further to see if anything
                                     * folds to it */
                                    if (! PL_utf8_foldable) {
                                        SV* swash = swash_init("utf8",
                                                           "_Perl_Any_Folds",
                                                           &PL_sv_undef, 1, 0);
                                        PL_utf8_foldable =
                                                    _get_swash_invlist(swash);
                                        SvREFCNT_dec_NN(swash);
                                    }
                                    if (_invlist_contains_cp(PL_utf8_foldable,
                                                             ender))
                                    {
                                        maybe_exact = FALSE;
                                    }
                                }
a12109 1
                            ender = folded;
a12110 13
			s += foldlen;

			/* The loop increments <len> each time, as all but this
			 * path (and the one just below for UTF) through it add
			 * a single byte to the EXACTish node.  But this one
			 * has changed len to be the correct final value, so
			 * subtract one to cancel out the increment that
			 * follows */
			len += foldlen - 1;
                    }
                    else {
                        *(s++) = (char) ender;
                        maybe_exact &= ! IS_IN_SOME_FOLD_L1(ender);
d12112 1
a12113 13
		else if (UTF) {
                    const STRLEN unilen = reguni(pRExC_state, ender, s);
                    if (unilen > 0) {
                       s   += unilen;
                       len += unilen;
                    }

		    /* See comment just above for - 1 */
		    len--;
		}
		else {
		    REGC((char)ender, s++);
                }
d12161 2
a12162 3
                    /* These two have no multi-char folds to non-UTF characters
                     */
                    if (ASCII_FOLD_RESTRICTED || LOC) {
d12193 2
a12194 6

                            /* No Latin1 characters participate in multi-char
                             * folds under /l */
                            if (LOC
                                || ! IS_NON_FINAL_FOLD(TWO_BYTE_UTF8_TO_UNI(
                                                                *s, *(s+1))))
d12231 9
a12291 6
            /* If 'maybe_exact' is still set here, means there are no
             * code points in the node that participate in folds */
            if (FOLD && maybe_exact) {
                OP(ret) = EXACT;
            }

d12298 20
a12317 2
            else{
                alloc_maybe_populate_EXACT(pRExC_state, ret, flagp, len, ender);
d12321 1
a12321 1
            Set_Node_Cur_Length(ret); /* MJD */
d12356 1
a12356 1
	        RExC_seen |= REG_SEEN_RUN_ON_COMMENT;
d12370 1
a12370 1
     * RExC_seen has added the REG_SEEN_RUN_ON_COMMENT flag; */
d12390 1
a12390 1
	        RExC_seen |= REG_SEEN_RUN_ON_COMMENT;
d12398 66
d12582 3
a12584 2
			Simple_vFAIL3("POSIX class [:%.*s:] unknown",
				      t - s - 1, s + 1);
d12672 3
a12674 2
S_handle_regex_sets(pTHX_ RExC_state_t *pRExC_state, SV** return_invlist, I32 *flagp, U32 depth,
                   char * const oregcomp_parse)
d12705 1
d12710 4
a12713 1
            (int) (RExC_parse - RExC_precomp) , RExC_precomp, RExC_parse);
d12720 3
d12756 2
a12757 2
                        FAIL2("panic: regclass returned NULL to handle_sets, flags=%#X",
                              *flagp);
d12770 1
d12923 2
a12924 2
                    FAIL2("panic: regclass returned NULL to handle_sets, flags=%#X",
                          *flagp);
d12946 2
a12947 2
                    FAIL2("panic: regclass returned NULL to handle_sets, flags=%#X",
                          *flagp);
d13167 2
a13168 1
#define HAS_NONLOCALE_RUNTIME_PROPERTY_DEFINITION (SvCUR(listsv) != initial_listsv_len)
d13218 10
a13227 2
    SV* posixes = NULL;     /* Code points that match classes like, [:word:],
                               extended beyond the Latin1 range */
d13254 2
a13255 3
    /* inversion list of code points this node matches.  For much of the
     * function, it includes only those that match regardless of the utf8ness
     * of the target string */
d13258 8
d13273 1
a13273 3
    /* Is there any thing like \W or [:^digit:] that matches above the legal
     * Unicode range? */
    bool runtime_posix_matches_above_Unicode = FALSE;
d13278 2
a13279 1
    const I32 orig_size = RExC_size;
a13299 3
	if (LOC) {
	    ANYOF_FLAGS(ret) |= ANYOF_LOCALE;
	}
d13421 1
a13421 1
                    /* We only pay attention to the first char of 
d13442 6
a13447 1
                U8 swash_init_flags = _CORE_SWASH_INIT_RETURN_IF_UNDEF;
d13470 1
d13491 8
a13498 8
                    Newx(name, n + sizeof("_i__\n"), char);

                    sprintf(name, "%s%.*s%s\n",
                                    (FOLD) ? "__" : "",
                                    (int)n,
                                    RExC_parse,
                                    (FOLD) ? "_i" : ""
                    );
d13523 3
a13525 1
                            vFAIL3("Property '%.*s' is unknown", (int) n, name);
d13527 1
a13527 1
                        Perl_sv_catpvf(aTHX_ listsv, "%cutf8::%s\n",
d13529 1
a13529 1
                                        name);
d13538 1
a13538 1
                         * is <no depends_list> */
d13546 17
a13562 3
                        has_user_defined_property =
                                    (swash_init_flags
                                     & _CORE_SWASH_INIT_USER_DEFINED_PROPERTY);
d13596 1
a13596 1
	    case 'a':	value = ASCII_TO_NATIVE('\007');break;
d13636 1
a13636 1
		value = grok_bslash_c(*RExC_parse++, UTF, SIZE_ONLY);
a13707 24
        /* What matches in a locale is not known until runtime.  This includes
         * what the Posix classes (like \w, [:space:]) match.  Room must be
         * reserved (one time per class) to store such classes, either if Perl
         * is compiled so that locale nodes always should have this space, or
         * if there is such class info to be stored.  The space will contain a
         * bit for each named class that is to be matched against.  This isn't
         * needed for \p{} and pseudo-classes, as they are not affected by
         * locale, and hence are dealt with separately */
        if (LOC
            && ! need_class
            && (ANYOF_LOCALE == ANYOF_CLASS
                || (namedclass > OOB_NAMEDCLASS && namedclass < ANYOF_MAX)))
        {
            need_class = 1;
            if (SIZE_ONLY) {
                RExC_size += ANYOF_CLASS_SKIP - ANYOF_SKIP;
            }
            else {
                RExC_emit += ANYOF_CLASS_SKIP - ANYOF_SKIP;
                ANYOF_CLASS_ZERO(ret);
            }
            ANYOF_FLAGS(ret) |= ANYOF_CLASS;
        }

d13709 1
d13720 3
a13722 1
                        vFAIL4("False [] range \"%*.*s\"", w, w, rangebegin);
d13726 3
a13728 3
                        ckWARN4reg(RExC_parse,
                                "False [] range \"%*.*s\"",
                                w, w, rangebegin);
d13731 2
a13732 1
                        cp_list = add_cp_to_invlist(cp_list, prevvalue);
d13740 78
a13817 3
	    if (! SIZE_ONLY) {
                U8 classnum = namedclass_to_classnum(namedclass);
                if (namedclass >= ANYOF_MAX) {  /* If a special class */
d13820 3
a13822 5
                        /* Here, should be \h, \H, \v, or \V.  Neither /d nor
                         * /l make a difference in what these match.  There
                         * would be problems if these characters had folds
                         * other than themselves, as cp_list is subject to
                         * folding. */
d13835 1
a13835 1
                                cBOOL(namedclass % 2), /* Complement if odd
d13841 11
a13851 22
                else if (classnum == _CC_ASCII) {
#ifdef HAS_ISASCII
                    if (LOC) {
                        ANYOF_CLASS_SET(ret, namedclass);
                    }
                    else
#endif  /* Not isascii(); just use the hard-coded definition for it */
                    {
                        _invlist_union_maybe_complement_2nd(
                                posixes,
                                PL_ASCII,
                                cBOOL(namedclass % 2), /* Complement if odd
                                                          (NASCII) */
                                &posixes);

                        /* The code points 128-255 added above will be
                         * subtracted out below under /d, so the flag needs to
                         * be set */
                        if (namedclass == ANYOF_NASCII && DEPENDS_SEMANTICS) {
                            ANYOF_FLAGS(ret) |= ANYOF_NON_UTF8_LATIN1_ALL;
                        }
                    }
d13853 1
a13853 220
                else {  /* Garden variety class */

                    /* The ascii range inversion list */
                    SV* ascii_source = PL_Posix_ptrs[classnum];

                    /* The full Latin1 range inversion list */
                    SV* l1_source = PL_L1Posix_ptrs[classnum];

                    /* This code is structured into two major clauses.  The
                     * first is for classes whose complete definitions may not
                     * already be known.  It not, the Latin1 definition
                     * (guaranteed to already known) is used plus code is
                     * generated to load the rest at run-time (only if needed).
                     * If the complete definition is known, it drops down to
                     * the second clause, where the complete definition is
                     * known */

                    if (classnum < _FIRST_NON_SWASH_CC) {

                        /* Here, the class has a swash, which may or not
                         * already be loaded */

                        /* The name of the property to use to match the full
                         * eXtended Unicode range swash for this character
                         * class */
                        const char *Xname = swash_property_names[classnum];

                        /* If returning the inversion list, we can't defer
                         * getting this until runtime */
                        if (ret_invlist && !  PL_utf8_swash_ptrs[classnum]) {
                            PL_utf8_swash_ptrs[classnum] =
                                _core_swash_init("utf8", Xname, &PL_sv_undef,
                                             1, /* binary */
                                             0, /* not tr/// */
                                             NULL, /* No inversion list */
                                             NULL  /* No flags */
                                            );
                            assert(PL_utf8_swash_ptrs[classnum]);
                        }
                        if ( !  PL_utf8_swash_ptrs[classnum]) {
                            if (namedclass % 2 == 0) { /* A non-complemented
                                                          class */
                                /* If not /a matching, there are code points we
                                 * don't know at compile time.  Arrange for the
                                 * unknown matches to be loaded at run-time, if
                                 * needed */
                                if (! AT_LEAST_ASCII_RESTRICTED) {
                                    Perl_sv_catpvf(aTHX_ listsv, "+utf8::%s\n",
                                                                 Xname);
                                }
                                if (LOC) {  /* Under locale, set run-time
                                               lookup */
                                    ANYOF_CLASS_SET(ret, namedclass);
                                }
                                else {
                                    /* Add the current class's code points to
                                     * the running total */
                                    _invlist_union(posixes,
                                                   (AT_LEAST_ASCII_RESTRICTED)
                                                        ? ascii_source
                                                        : l1_source,
                                                   &posixes);
                                }
                            }
                            else {  /* A complemented class */
                                if (AT_LEAST_ASCII_RESTRICTED) {
                                    /* Under /a should match everything above
                                     * ASCII, plus the complement of the set's
                                     * ASCII matches */
                                    _invlist_union_complement_2nd(posixes,
                                                                  ascii_source,
                                                                  &posixes);
                                }
                                else {
                                    /* Arrange for the unknown matches to be
                                     * loaded at run-time, if needed */
                                    Perl_sv_catpvf(aTHX_ listsv, "!utf8::%s\n",
                                                                 Xname);
                                    runtime_posix_matches_above_Unicode = TRUE;
                                    if (LOC) {
                                        ANYOF_CLASS_SET(ret, namedclass);
                                    }
                                    else {

                                        /* We want to match everything in
                                         * Latin1, except those things that
                                         * l1_source matches */
                                        SV* scratch_list = NULL;
                                        _invlist_subtract(PL_Latin1, l1_source,
                                                          &scratch_list);

                                        /* Add the list from this class to the
                                         * running total */
                                        if (! posixes) {
                                            posixes = scratch_list;
                                        }
                                        else {
                                            _invlist_union(posixes,
                                                           scratch_list,
                                                           &posixes);
                                            SvREFCNT_dec_NN(scratch_list);
                                        }
                                        if (DEPENDS_SEMANTICS) {
                                            ANYOF_FLAGS(ret)
                                                  |= ANYOF_NON_UTF8_LATIN1_ALL;
                                        }
                                    }
                                }
                            }
                            goto namedclass_done;
                        }

                        /* Here, there is a swash loaded for the class.  If no
                         * inversion list for it yet, get it */
                        if (! PL_XPosix_ptrs[classnum]) {
                            PL_XPosix_ptrs[classnum]
                             = _swash_to_invlist(PL_utf8_swash_ptrs[classnum]);
                        }
                    }

                    /* Here there is an inversion list already loaded for the
                     * entire class */

                    if (namedclass % 2 == 0) {  /* A non-complemented class,
                                                   like ANYOF_PUNCT */
                        if (! LOC) {
                            /* For non-locale, just add it to any existing list
                             * */
                            _invlist_union(posixes,
                                           (AT_LEAST_ASCII_RESTRICTED)
                                               ? ascii_source
                                               : PL_XPosix_ptrs[classnum],
                                           &posixes);
                        }
                        else {  /* Locale */
                            SV* scratch_list = NULL;

                            /* For above Latin1 code points, we use the full
                             * Unicode range */
                            _invlist_intersection(PL_AboveLatin1,
                                                  PL_XPosix_ptrs[classnum],
                                                  &scratch_list);
                            /* And set the output to it, adding instead if
                             * there already is an output.  Checking if
                             * 'posixes' is NULL first saves an extra clone.
                             * Its reference count will be decremented at the
                             * next union, etc, or if this is the only
                             * instance, at the end of the routine */
                            if (! posixes) {
                                posixes = scratch_list;
                            }
                            else {
                                _invlist_union(posixes, scratch_list, &posixes);
                                SvREFCNT_dec_NN(scratch_list);
                            }

#ifndef HAS_ISBLANK
                            if (namedclass != ANYOF_BLANK) {
#endif
                                /* Set this class in the node for runtime
                                 * matching */
                                ANYOF_CLASS_SET(ret, namedclass);
#ifndef HAS_ISBLANK
                            }
                            else {
                                /* No isblank(), use the hard-coded ASCII-range
                                 * blanks, adding them to the running total. */

                                _invlist_union(posixes, ascii_source, &posixes);
                            }
#endif
                        }
                    }
                    else {  /* A complemented class, like ANYOF_NPUNCT */
                        if (! LOC) {
                            _invlist_union_complement_2nd(
                                                posixes,
                                                (AT_LEAST_ASCII_RESTRICTED)
                                                    ? ascii_source
                                                    : PL_XPosix_ptrs[classnum],
                                                &posixes);
                            /* Under /d, everything in the upper half of the
                             * Latin1 range matches this complement */
                            if (DEPENDS_SEMANTICS) {
                                ANYOF_FLAGS(ret) |= ANYOF_NON_UTF8_LATIN1_ALL;
                            }
                        }
                        else {  /* Locale */
                            SV* scratch_list = NULL;
                            _invlist_subtract(PL_AboveLatin1,
                                              PL_XPosix_ptrs[classnum],
                                              &scratch_list);
                            if (! posixes) {
                                posixes = scratch_list;
                            }
                            else {
                                _invlist_union(posixes, scratch_list, &posixes);
                                SvREFCNT_dec_NN(scratch_list);
                            }
#ifndef HAS_ISBLANK
                            if (namedclass != ANYOF_NBLANK) {
#endif
                                ANYOF_CLASS_SET(ret, namedclass);
#ifndef HAS_ISBLANK
                            }
                            else {
                                /* Get the list of all code points in Latin1
                                 * that are not ASCII blanks, and add them to
                                 * the running total */
                                _invlist_subtract(PL_Latin1, ascii_source,
                                                  &scratch_list);
                                _invlist_union(posixes, scratch_list, &posixes);
                                SvREFCNT_dec_NN(scratch_list);
                            }
#endif
                        }
                    }
                }
              namedclass_done:
		continue;   /* Go get next character */
d13872 3
a13874 1
		Simple_vFAIL4("Invalid [] range \"%*.*s\"", w, w, rangebegin);
d13955 3
a13957 5
                                FOLD_FLAGS_FULL
                                | ((LOC) ?  FOLD_FLAGS_LOCALE
                                            : (ASCII_FOLD_RESTRICTED)
                                              ? FOLD_FLAGS_NOMIX_ASCII
                                              : 0)
d13988 11
a13998 11
                         * element thereof is a character which folds to two
                         * characters; likewise for [3].  (Unicode guarantees a
                         * maximum of 3 characters in any fold.)  When we
                         * rewrite the character class below, we will do so
                         * such that the longest folds are written first, so
                         * that it prefers the longest matching strings first.
                         * This is done even if it turns out that any
                         * quantifier is non-greedy, out of programmer
                         * laziness.  Tom Christiansen has agreed that this is
                         * ok.  This makes the test for the ligature 'ffi' come
                         * before the test for 'ff' */
d14025 2
a14026 1
            cp_list = _add_range_to_invlist(cp_list, prevvalue, value);
d14040 2
a14041 2
                && (prevvalue >= 'a' && value <= 'z')
                    || (prevvalue >= 'A' && value <= 'Z'))
d14043 6
a14048 1
                _invlist_intersection(this_range, PL_Posix_ptrs[_CC_ALPHA],
d14051 1
a14051 1
            _invlist_union(cp_list, this_range, &cp_list);
d14081 1
a14081 1
        for (cp_count = av_len(multi_char_matches); cp_count > 0; cp_count--) {
d14136 14
a14149 4
    /* If the character class contains only a single element, it may be
     * optimizable into another node type which is smaller and runs faster.
     * Check if this is the case for this class */
    if (element_count == 1 && ! ret_invlist) {
d14153 6
a14158 2
        if (namedclass > OOB_NAMEDCLASS) { /* this is a named class, like \w or
                                              [:digit:] or \p{foo} */
a14213 8
#ifndef HAS_ISBLANK
                    if (op == POSIXL
                        && (namedclass == ANYOF_BLANK
                            || namedclass == ANYOF_NBLANK))
                    {
                        op = POSIXA;
                    }
#endif
d14268 1
a14268 1
                     * e.g.  ANYOF_CLASS_SET */
d14275 3
d14293 3
a14295 1
                alloc_maybe_populate_EXACT(pRExC_state, ret, flagp, 0, value);
d14301 1
d14303 1
d14314 17
a14330 2
    if (FOLD && cp_list) {
	UV start, end;	/* End points of code point ranges */
d14332 6
a14337 1
	SV* fold_intersection = NULL;
d14339 7
a14345 10
        /* If the highest code point is within Latin1, we can use the
         * compiled-in Alphas list, and not have to go out to disk.  This
         * yields two false positives, the masculine and feminine ordinal
         * indicators, which are weeded out below using the
         * IS_IN_SOME_FOLD_L1() macro */
        if (invlist_highest(cp_list) < 256) {
            _invlist_intersection(PL_L1Posix_ptrs[_CC_ALPHA], cp_list,
                                                           &fold_intersection);
        }
        else {
a14346 24
            /* Here, there are non-Latin1 code points, so we will have to go
             * fetch the list of all the characters that participate in folds
             */
            if (! PL_utf8_foldable) {
                SV* swash = swash_init("utf8", "_Perl_Any_Folds",
                                       &PL_sv_undef, 1, 0);
                PL_utf8_foldable = _get_swash_invlist(swash);
                SvREFCNT_dec_NN(swash);
            }

            /* This is a hash that for a particular fold gives all characters
             * that are involved in it */
            if (! PL_utf8_foldclosures) {

                /* If we were unable to find any folds, then we likely won't be
                 * able to find the closures.  So just create an empty list.
                 * Folding will effectively be restricted to the non-Unicode
                 * rules hard-coded into Perl.  (This case happens legitimately
                 * during compilation of Perl itself before the Unicode tables
                 * are generated) */
                if (_invlist_len(PL_utf8_foldable) == 0) {
                    PL_utf8_foldclosures = newHV();
                }
                else {
d14350 1
a14350 1
                        U8 dummy[UTF8_MAXBYTES+1];
d14356 2
a14357 2
                    PL_utf8_foldclosures =
                                    _swash_inversion_hash(PL_utf8_tofold);
d14361 36
a14396 46
            /* Only the characters in this class that participate in folds need
             * be checked.  Get the intersection of this class and all the
             * possible characters that are foldable.  This can quickly narrow
             * down a large class */
            _invlist_intersection(PL_utf8_foldable, cp_list,
                                  &fold_intersection);
        }

	/* Now look at the foldable characters in this class individually */
	invlist_iterinit(fold_intersection);
	while (invlist_iternext(fold_intersection, &start, &end)) {
	    UV j;

            /* Locale folding for Latin1 characters is deferred until runtime */
            if (LOC && start < 256) {
                start = 256;
            }

	    /* Look at every character in the range */
	    for (j = start; j <= end; j++) {

		U8 foldbuf[UTF8_MAXBYTES_CASE+1];
		STRLEN foldlen;
                SV** listp;

                if (j < 256) {

                    /* We have the latin1 folding rules hard-coded here so that
                     * an innocent-looking character class, like /[ks]/i won't
                     * have to go out to disk to find the possible matches.
                     * XXX It would be better to generate these via regen, in
                     * case a new version of the Unicode standard adds new
                     * mappings, though that is not really likely, and may be
                     * caught by the default: case of the switch below. */

                    if (IS_IN_SOME_FOLD_L1(j)) {

                        /* ASCII is always matched; non-ASCII is matched only
                         * under Unicode rules */
                        if (isASCII(j) || AT_LEAST_UNI_SEMANTICS) {
                            cp_list =
                                add_cp_to_invlist(cp_list, PL_fold_latin1[j]);
                        }
                        else {
                            depends_list =
                             add_cp_to_invlist(depends_list, PL_fold_latin1[j]);
a14397 1
                    }
d14399 21
a14419 20
                    if (HAS_NONLATIN1_FOLD_CLOSURE(j)
                        && (! isASCII(j) || ! ASCII_FOLD_RESTRICTED))
                    {
                        /* Certain Latin1 characters have matches outside
                         * Latin1.  To get here, <j> is one of those
                         * characters.   None of these matches is valid for
                         * ASCII characters under /aa, which is why the 'if'
                         * just above excludes those.  These matches only
                         * happen when the target string is utf8.  The code
                         * below adds the single fold closures for <j> to the
                         * inversion list. */
                        switch (j) {
                            case 'k':
                            case 'K':
                                cp_list =
                                    add_cp_to_invlist(cp_list, KELVIN_SIGN);
                                break;
                            case 's':
                            case 'S':
                                cp_list = add_cp_to_invlist(cp_list,
d14421 14
a14434 14
                                break;
                            case MICRO_SIGN:
                                cp_list = add_cp_to_invlist(cp_list,
                                                    GREEK_CAPITAL_LETTER_MU);
                                cp_list = add_cp_to_invlist(cp_list,
                                                    GREEK_SMALL_LETTER_MU);
                                break;
                            case LATIN_CAPITAL_LETTER_A_WITH_RING_ABOVE:
                            case LATIN_SMALL_LETTER_A_WITH_RING_ABOVE:
                                cp_list =
                                    add_cp_to_invlist(cp_list, ANGSTROM_SIGN);
                                break;
                            case LATIN_SMALL_LETTER_Y_WITH_DIAERESIS:
                                cp_list = add_cp_to_invlist(cp_list,
d14436 29
a14464 28
                                break;
                            case LATIN_SMALL_LETTER_SHARP_S:
                                cp_list = add_cp_to_invlist(cp_list,
                                                LATIN_CAPITAL_LETTER_SHARP_S);
                                break;
                            case 'F': case 'f':
                            case 'I': case 'i':
                            case 'L': case 'l':
                            case 'T': case 't':
                            case 'A': case 'a':
                            case 'H': case 'h':
                            case 'J': case 'j':
                            case 'N': case 'n':
                            case 'W': case 'w':
                            case 'Y': case 'y':
                                /* These all are targets of multi-character
                                 * folds from code points that require UTF8 to
                                 * express, so they can't match unless the
                                 * target string is in UTF-8, so no action here
                                 * is necessary, as regexec.c properly handles
                                 * the general case for UTF-8 matching and
                                 * multi-char folds */
                                break;
                            default:
                                /* Use deprecated warning to increase the
                                 * chances of this being output */
                                ckWARN2regdep(RExC_parse, "Perl folding rules are not up-to-date for 0x%"UVXf"; please use the perlbug utility to report;", j);
                                break;
d14466 1
a14467 2
                    continue;
                }
d14469 43
a14511 39
                /* Here is an above Latin1 character.  We don't have the rules
                 * hard-coded for it.  First, get its fold.  This is the simple
                 * fold, as the multi-character folds have been handled earlier
                 * and separated out */
		_to_uni_fold_flags(j, foldbuf, &foldlen,
                                               ((LOC)
                                               ? FOLD_FLAGS_LOCALE
                                               : (ASCII_FOLD_RESTRICTED)
                                                  ? FOLD_FLAGS_NOMIX_ASCII
                                                  : 0));

                /* Single character fold of above Latin1.  Add everything in
                 * its fold closure to the list that this node should match.
                 * The fold closures data structure is a hash with the keys
                 * being the UTF-8 of every character that is folded to, like
                 * 'k', and the values each an array of all code points that
                 * fold to its key.  e.g. [ 'k', 'K', KELVIN_SIGN ].
                 * Multi-character folds are not included */
                if ((listp = hv_fetch(PL_utf8_foldclosures,
                                      (char *) foldbuf, foldlen, FALSE)))
                {
                    AV* list = (AV*) *listp;
                    IV k;
                    for (k = 0; k <= av_len(list); k++) {
                        SV** c_p = av_fetch(list, k, FALSE);
                        UV c;
                        if (c_p == NULL) {
                            Perl_croak(aTHX_ "panic: invalid PL_utf8_foldclosures structure");
                        }
                        c = SvUV(*c_p);

                        /* /aa doesn't allow folds between ASCII and non-; /l
                         * doesn't allow them between above and below 256 */
                        if ((ASCII_FOLD_RESTRICTED
                                  && (isASCII(c) != isASCII(j)))
                            || (LOC && ((c < 256) != (j < 256))))
                        {
                            continue;
                        }
d14513 10
a14522 8
                        /* Folds involving non-ascii Latin1 characters
                         * under /d are added to a separate list */
                        if (isASCII(c) || c > 255 || AT_LEAST_UNI_SEMANTICS)
                        {
                            cp_list = add_cp_to_invlist(cp_list, c);
                        }
                        else {
                          depends_list = add_cp_to_invlist(depends_list, c);
d14527 7
a14533 2
	}
	SvREFCNT_dec_NN(fold_intersection);
d14540 28
a14567 1
    if (posixes) {
d14581 1
a14581 1
            _invlist_intersection(posixes, PL_Latin1,
a14582 2
            _invlist_subtract(nonascii_but_latin1_properties, PL_ASCII,
                              &nonascii_but_latin1_properties);
a14615 1
        bool warn_super = ! has_user_defined_property;
d14626 2
a14627 8
                bool non_prop_matches_above_Unicode =
                            runtime_posix_matches_above_Unicode
                            | (invlist_highest(cp_list) > PERL_UNICODE_MAX);
                if (invert) {
                    non_prop_matches_above_Unicode =
                                            !  non_prop_matches_above_Unicode;
                }
                warn_super = ! non_prop_matches_above_Unicode;
d14638 1
a14638 1
            OP(ret) = ANYOF_WARN_SUPER;
d14651 20
d14675 3
a14677 2
    if (invert
        && ! (LOC && (FOLD || (ANYOF_FLAGS(ret) & ANYOF_CLASS)))
a14706 9
    /* If we didn't do folding, it's because some information isn't available
     * until runtime; set the run-time fold flag for these.  (We don't have to
     * worry about properties folding, as that is taken care of by the swash
     * fetching) */
    if (FOLD && LOC)
    {
       ANYOF_FLAGS(ret) |= ANYOF_LOC_FOLD;
    }

d14725 7
a14731 2
        && ! (ANYOF_FLAGS(ret) & ANYOF_CLASS)
        && ! HAS_NONLOCALE_RUNTIME_PROPERTY_DEFINITION)
d14755 1
a14755 1
                 * into an EXACT node */
a14784 6
                        if (! PL_utf8_foldable) {
                            SV* swash = swash_init("utf8", "_Perl_Any_Folds",
                                                &PL_sv_undef, 1, 0);
                            PL_utf8_foldable = _get_swash_invlist(swash);
                            SvREFCNT_dec_NN(swash);
                        }
d14824 3
a14826 1
                alloc_maybe_populate_EXACT(pRExC_state, ret, flagp, 0, value);
a14838 2
    ANYOF_BITMAP_ZERO(ret);
    if (cp_list) {
d14840 1
a14840 46
	/* This gets set if we actually need to modify things */
	bool change_invlist = FALSE;

	UV start, end;

	/* Start looking through <cp_list> */
	invlist_iterinit(cp_list);
	while (invlist_iternext(cp_list, &start, &end)) {
	    UV high;
	    int i;

            if (end == UV_MAX && start <= 256) {
                ANYOF_FLAGS(ret) |= ANYOF_UNICODE_ALL;
            }

	    /* Quit if are above what we should change */
	    if (start > 255) {
		break;
	    }

	    change_invlist = TRUE;

	    /* Set all the bits in the range, up to the max that we are doing */
	    high = (end < 255) ? end : 255;
	    for (i = start; i <= (int) high; i++) {
		if (! ANYOF_BITMAP_TEST(ret, i)) {
		    ANYOF_BITMAP_SET(ret, i);
		    prevvalue = value;
		    value = i;
		}
	    }
	}
	invlist_iterfinish(cp_list);

        /* Done with loop; remove any code points that are in the bitmap from
         * <cp_list> */
	if (change_invlist) {
	    _invlist_subtract(cp_list, PL_Latin1, &cp_list);
	}

	/* If have completely emptied it, remove it completely */
	if (_invlist_len(cp_list) == 0) {
	    SvREFCNT_dec_NN(cp_list);
	    cp_list = NULL;
	}
    }
d14857 1
d14867 56
a14922 4
    if (! cp_list
	&& ! HAS_NONLOCALE_RUNTIME_PROPERTY_DEFINITION)
    {
	ARG_SET(ret, ANYOF_NONBITMAP_EMPTY);
a14924 10
	/* av[0] stores the character class description in its textual form:
	 *       used later (regexec.c:Perl_regclass_swash()) to initialize the
	 *       appropriate swash, and is also useful for dumping the regnode.
	 * av[1] if NULL, is a placeholder to later contain the swash computed
	 *       from av[0].  But if no further computation need be done, the
	 *       swash is stored there now.
	 * av[2] stores the cp_list inversion list for use in addition or
	 *       instead of av[0]; used only if av[1] is NULL
	 * av[3] is set if any component of the class is from a user-defined
	 *       property; used only if av[1] is NULL */
d14928 5
a14932 2
	av_store(av, 0, (HAS_NONLOCALE_RUNTIME_PROPERTY_DEFINITION)
			? SvREFCNT_inc(listsv) : &PL_sv_undef);
d14938 1
a14938 1
	    av_store(av, 1, NULL);
d14940 2
a14941 2
		av_store(av, 2, cp_list);
		av_store(av, 3, newSVuv(has_user_defined_property));
d14945 7
d14953 1
a14953 1
	n = add_data(pRExC_state, 1, "s");
d14955 1
a14955 1
	ARG_SET(ret, n);
a14956 3

    *flagp |= HASWIDTH|SIMPLE;
    return ret;
a14957 1
#undef HAS_NONLOCALE_RUNTIME_PROPERTY_DEFINITION
d14964 1
a14964 1
   Will set the REG_SEEN_RUN_ON_COMMENT flag if the comment
d14987 1
a14987 1
        RExC_seen |= REG_SEEN_RUN_ON_COMMENT;
d15068 3
a15070 2
	MJD_OFFSET_DEBUG(("%s:%d: (op %s) %s %"UVuf" (len %"UVuf") (max %"UVuf").\n", 
              "reg_node", __LINE__, 
d15072 1
a15072 1
              (UV)(RExC_emit - RExC_emit_start) > RExC_offsets[0] 
d15076 1
a15076 1
              (UV)RExC_offsets[0])); 
d15100 1
a15100 1
	/* 
d15102 2
a15103 2
	   
	   assert(2==regarglen[op]+1); 
d15107 1
a15107 1
	   
d15109 1
a15109 1
	   
d15125 2
a15126 1
	MJD_OFFSET_DEBUG(("%s(%d): (op %s) %s %"UVuf" <- %"UVuf" (max %"UVuf").\n", 
d15130 1
a15130 1
              (UV)(RExC_emit - RExC_emit_start) > RExC_offsets[0] ? 
d15134 1
a15134 1
              (UV)RExC_offsets[0])); 
d15137 1
a15137 1
#endif            
d15145 1
a15145 1
STATIC STRLEN
d15206 2
a15207 1
	    MJD_OFFSET_DEBUG(("%s(%d): (op %s) %s copy %"UVuf" -> %"UVuf" (max %"UVuf").\n",
d15211 1
a15211 1
                  (UV)(dst - RExC_emit_start) > RExC_offsets[0] 
d15215 1
a15215 1
                  (UV)RExC_offsets[0])); 
d15221 1
a15221 1
    
d15226 2
a15227 1
	MJD_OFFSET_DEBUG(("%s(%d): (op %s) %s %"UVuf" <- %"UVuf" (max %"UVuf").\n", 
d15231 1
a15231 1
              (UV)(place - RExC_emit_start) > RExC_offsets[0] 
d15239 1
a15239 1
#endif    
d15251 2
a15252 1
S_regtail(pTHX_ RExC_state_t *pRExC_state, regnode *p, const regnode *val,U32 depth)
d15273 1
a15273 1
            regprop(RExC_rx, mysv, scan);
d15299 1
a15299 1
This is experimental code. The idea is to use this routine to perform 
d15311 2
a15312 1
S_regtail_study(pTHX_ RExC_state_t *pRExC_state, regnode *p, const regnode *val,U32 depth)
d15335 3
a15337 2
	    bool has_exactf_sharp_s;	/* Unexamined in this routine */
            if (join_exact(pRExC_state,scan,&min, &has_exactf_sharp_s, 1,val,depth+1))
d15345 1
a15348 1
                case EXACTFU_TRICKYFOLD:
d15363 1
a15363 1
            regprop(RExC_rx, mysv, scan);
d15376 3
a15378 2
        regprop(RExC_rx, mysv_val, val);
        PerlIO_printf(Perl_debug_log, "~ attach to %s (%"IVdf") offset to %"IVdf"\n",
d15399 25
a15423 1
static void 
d15430 3
a15432 1
    for (bit=0; bit<32; bit++) {
d15437 1
a15437 1
            if (!set++ && lead) 
d15440 2
a15441 2
        }	        
    }	   
d15465 1
a15465 1
        if (set) 
d15467 1
a15467 1
        else 
d15469 2
a15470 2
    }            
}   
d15489 1
a15489 1
	RE_PV_QUOTED_DECL(s, 0, dsv, SvPVX_const(r->anchored_substr), 
d15496 1
a15496 1
	RE_PV_QUOTED_DECL(s, 1, dsv, SvPVX_const(r->anchored_utf8), 
d15502 1
a15502 1
    }		      
d15504 1
a15504 1
	RE_PV_QUOTED_DECL(s, 0, dsv, SvPVX_const(r->float_substr), 
d15511 1
a15511 1
	RE_PV_QUOTED_DECL(s, 1, dsv, SvPVX_const(r->float_utf8), 
d15524 1
a15524 1
    if (r->extflags & RXf_NOSCAN)
d15532 1
a15532 1
	regprop(r, sv, ri->regstclass);
d15535 1
a15535 1
    if (r->extflags & RXf_ANCH) {
d15537 1
a15537 1
	if (r->extflags & RXf_ANCH_BOL)
d15539 1
a15539 1
	if (r->extflags & RXf_ANCH_MBOL)
d15541 1
a15541 1
	if (r->extflags & RXf_ANCH_SBOL)
d15543 1
a15543 1
	if (r->extflags & RXf_ANCH_GPOS)
d15547 1
a15547 1
    if (r->extflags & RXf_GPOS_SEEN)
d15557 4
a15560 1
    DEBUG_FLAGS_r(regdump_extflags("r->extflags: ",r->extflags));            
d15569 1
a15569 1
- regprop - printable representation of opcode
a15570 10
#define EMIT_ANYOF_TEST_SEPARATOR(do_sep,sv,flags) \
STMT_START { \
        if (do_sep) {                           \
            Perl_sv_catpvf(aTHX_ sv,"%s][%s",PL_colors[1],PL_colors[0]); \
            if (flags & ANYOF_INVERT)           \
                /*make sure the invert info is in each */ \
                sv_catpvs(sv, "^");             \
            do_sep = 0;                         \
        }                                       \
} STMT_END
d15573 1
a15573 1
Perl_regprop(pTHX_ const regexp *prog, SV *sv, const regnode *o)
d15589 4
a15592 4
        "[\\w]",
        "[\\W]",
        "[\\d]",
        "[\\D]",
d15609 2
a15610 2
        "[\\s]",
        "[\\S]",
d15621 2
a15622 2
        "[\\v]",
        "[\\V]"
d15626 1
a15626 1
    
d15634 2
a15635 1
	Perl_croak(aTHX_ "Corrupted regexp opcode %d > %d", (int)OP(o), (int)REGNODE_MAX);
d15642 3
a15644 3
	/* Using is_utf8_string() (via PERL_PV_UNI_DETECT) 
	 * is a crude hack but it may be the best for now since 
	 * we have no flag "this EXACTish node was UTF-8" 
d15663 1
a15663 1
        
d15666 10
a15675 10
            Perl_sv_catpvf(aTHX_ sv,
                "<S:%"UVuf"/%"IVdf" W:%"UVuf" L:%"UVuf"/%"UVuf" C:%"UVuf"/%"UVuf">",
                (UV)trie->startstate,
                (IV)trie->statecount-1, /* -1 because of the unused 0 element */
                (UV)trie->wordcount,
                (UV)trie->minlen,
                (UV)trie->maxlen,
                (UV)TRIE_CHARCOUNT(trie),
                (UV)trie->uniquecharcount
            )
a15677 3
            int i;
            int rangestart = -1;
            U8* bitmap = IS_ANYOF_TRIE(op) ? (U8*)ANYOF_BITMAP(o) : (U8*)TRIE_BITMAP(trie);
d15679 3
a15681 16
            for (i = 0; i <= 256; i++) {
                if (i < 256 && BITMAP_TEST(bitmap,i)) {
                    if (rangestart == -1)
                        rangestart = i;
                } else if (rangestart != -1) {
                    if (i <= rangestart + 3)
                        for (; rangestart < i; rangestart++)
                            put_byte(sv, rangestart);
                    else {
                        put_byte(sv, rangestart);
                        sv_catpvs(sv, "-");
                        put_byte(sv, i - 1);
                    }
                    rangestart = -1;
                }
            }
d15683 2
a15684 2
        } 
	 
d15692 3
a15694 1
    else if (k == REF || k == OPEN || k == CLOSE || k == GROUPP || OP(o)==ACCEPT) {
d15702 1
a15702 1
            }	    
d15717 18
a15734 3
        }            
    } else if (k == GOSUB) 
	Perl_sv_catpvf(aTHX_ sv, "%d[%+d]", (int)ARG(o),(int)ARG2L(o));	/* Paren and offset */
d15736 2
a15737 2
        if (!o->flags) 
            Perl_sv_catpvf(aTHX_ sv, ":%"SVf, 
d15740 2
a15741 1
	Perl_sv_catpvf(aTHX_ sv, "[%d]", o->flags);	/* 2: embedded, otherwise 1 */
a15742 1
	int i, rangestart = -1;
d15747 1
a15747 1
	if (flags & ANYOF_LOCALE)
d15756 8
a15763 23
	for (i = 0; i <= 256; i++) {
	    if (i < 256 && ANYOF_BITMAP_TEST(o,i)) {
		if (rangestart == -1)
		    rangestart = i;
	    } else if (rangestart != -1) {
		if (i <= rangestart + 3)
		    for (; rangestart < i; rangestart++)
			put_byte(sv, rangestart);
		else {
		    put_byte(sv, rangestart);
		    sv_catpvs(sv, "-");
		    put_byte(sv, i - 1);
		}
		do_sep = 1;
		rangestart = -1;
	    }
	}
        
        EMIT_ANYOF_TEST_SEPARATOR(do_sep,sv,flags);
        /* output any special charclass tests (used entirely under use locale) */
	if (ANYOF_CLASS_TEST_ANY_SET(o))
	    for (i = 0; i < (int)(sizeof(anyofs)/sizeof(char*)); i++)
		if (ANYOF_CLASS_TEST(o,i)) {
d15767 2
a15768 52
        
        EMIT_ANYOF_TEST_SEPARATOR(do_sep,sv,flags);
        
	if (flags & ANYOF_NON_UTF8_LATIN1_ALL) {
	    sv_catpvs(sv, "{non-utf8-latin1-all}");
	}

        /* output information about the unicode matching */
	if (flags & ANYOF_UNICODE_ALL)
	    sv_catpvs(sv, "{unicode_all}");
	else if (ANYOF_NONBITMAP(o))
	    sv_catpvs(sv, "{unicode}");
	if (flags & ANYOF_NONBITMAP_NON_UTF8)
	    sv_catpvs(sv, "{outside bitmap}");

	if (ANYOF_NONBITMAP(o)) {
	    SV *lv; /* Set if there is something outside the bit map */
	    SV * const sw = regclass_swash(prog, o, FALSE, &lv, NULL);
            bool byte_output = FALSE;   /* If something in the bitmap has been
                                           output */

	    if (lv && lv != &PL_sv_undef) {
		if (sw) {
		    U8 s[UTF8_MAXBYTES_CASE+1];

		    for (i = 0; i <= 256; i++) { /* Look at chars in bitmap */
			uvchr_to_utf8(s, i);

			if (i < 256
                            && ! ANYOF_BITMAP_TEST(o, i)    /* Don't duplicate
                                                               things already
                                                               output as part
                                                               of the bitmap */
                            && swash_fetch(sw, s, TRUE))
                        {
			    if (rangestart == -1)
				rangestart = i;
			} else if (rangestart != -1) {
                            byte_output = TRUE;
			    if (i <= rangestart + 3)
				for (; rangestart < i; rangestart++) {
				    put_byte(sv, rangestart);
				}
			    else {
				put_byte(sv, rangestart);
				sv_catpvs(sv, "-");
				put_byte(sv, i-1);
			    }
			    rangestart = -1;
			}
		    }
		}
d15770 31
a15800 3
		{
		    char *s = savesvpv(lv);
		    char * const origs = s;
d15802 2
a15803 2
		    while (*s && *s != '\n')
			s++;
d15805 9
a15813 2
		    if (*s == '\n') {
			const char * const t = ++s;
d15819 2
a15820 2
			while (*s) {
			    if (*s == '\n') {
d15823 19
a15841 16
				if (s - origs > 256) {
				    Perl_sv_catpvf(aTHX_ sv,
						   "%.*s...",
					           (int) (s - origs - 1),
						   t);
				    goto out_dump;
				}
				*s = ' ';
			    }
			    else if (*s == '\t') {
				*s = '-';
			    }
			    s++;
			}
			if (s[-1] == ' ')
			    s[-1] = 0;
d15843 1
a15843 2
			sv_catpv(sv, t);
		    }
d15845 3
a15847 1
		out_dump:
d15849 21
a15869 4
		    Safefree(origs);
		}
		SvREFCNT_dec_NN(lv);
	    }
d15876 8
a15883 2
        if (index > (sizeof(anyofs) / sizeof(anyofs[0]))) {
            Perl_sv_catpvf(aTHX_ sv, "[illegal type=%d])", index);
d15886 1
a15886 1
            sv_catpv(sv, anyofs[index]);
d15896 1
d15900 2
d15931 5
a15935 5
/* 
   pregfree() 
   
   handles refcounting and freeing the perl core regexp structure. When 
   it is necessary to actually free the structure the first thing it 
d15937 2
a15938 2
   the regexp, allowing the handling of the void *pprivate; member 
   first. (This routine is not overridable by extensions, which is why 
d15940 2
a15941 2
   
   See regdupe and regdupe_internal if you change anything here. 
d15965 1
a15965 1
    }        
d15983 1
a15983 1
    
d15990 2
a15991 2
    
    The solution is to make a lightweight copy of the regexp structure 
d15994 5
a15998 5
    the starp/end and the actual regexp structure itself. 
    
*/    
    
    
d16031 1
a16031 1
    
d16062 1
a16062 1
    
d16067 1
a16067 1
/* regfree_internal() 
d16069 8
a16076 8
   Free the private data in a regexp. This is overloadable by 
   extensions. Perl takes care of the regexp structure in pregfree(), 
   this covers the *pprivate pointer which technically perl doesn't 
   know about, however of course we have to handle the 
   regexp_internal structure when no extension is in use. 
   
   Note this is called before freeing anything in the regexp 
   structure. 
d16078 1
a16078 1
 
d16096 1
a16096 1
            PerlIO_printf(Perl_debug_log,"%sFreeing REx:%s %s\n", 
d16130 1
a16130 1
            case 'T':	        
d16170 2
a16171 1
		Perl_croak(aTHX_ "panic: regfree data code '%c'", ri->data->what[n]);
d16185 3
a16187 3
/* 
   re_dup - duplicate a regexp. 
   
d16196 1
a16196 1
   See pregfree() and regfree_internal() if you change anything here. 
d16207 1
a16207 1
    
a16273 1
    ret->gofs = 0;
d16279 1
a16279 1
   
d16284 1
a16284 1
   to this and will be provided as the regexp *r argument, however 
d16287 1
a16287 1
   
d16301 1
a16301 1
    
d16303 3
a16305 2
    
    Newxc(reti, sizeof(regexp_internal) + len*sizeof(regnode), char, regexp_internal);
d16347 2
a16348 3
		Newx(d->data[i], 1, struct regnode_charclass_class);
		StructCopy(ri->data->data[i], d->data[i],
			    struct regnode_charclass_class);
d16368 2
a16369 1
		Perl_croak(aTHX_ "panic: re_dup unknown data code '%c'", ri->data->what[i]);
d16409 2
a16410 1
	Perl_croak(aTHX_ "Corrupted regexp opcode %d > %d", (int)OP(p), (int)REGNODE_MAX);
d16422 1
a16422 1
S_re_croak2(pTHX_ const char* pat1,const char* pat2,...)
a16440 2
#ifdef I_STDARG
    /* ANSI variant takes additional second argument */
a16441 3
#else
    va_start(args);
#endif
d16448 2
a16449 2
    buf[l1-1] = '\0';			/* Overwrite \n */
    Perl_croak(aTHX_ "%s", buf);
a16459 23
    struct re_save_state *state;

    SAVEVPTR(PL_curcop);
    SSGROW(SAVESTACK_ALLOC_FOR_RE_SAVE_STATE + 1);

    state = (struct re_save_state *)(PL_savestack + PL_savestack_ix);
    PL_savestack_ix += SAVESTACK_ALLOC_FOR_RE_SAVE_STATE;
    SSPUSHUV(SAVEt_RE_STATE);

    Copy(&PL_reg_state, state, 1, struct re_save_state);

    PL_reg_oldsaved = NULL;
    PL_reg_oldsavedlen = 0;
    PL_reg_oldsavedoffset = 0;
    PL_reg_oldsavedcoffset = 0;
    PL_reg_maxiter = 0;
    PL_reg_leftiter = 0;
    PL_reg_poscache = NULL;
    PL_reg_poscache_size = 0;
#ifdef PERL_ANY_COW
    PL_nrs = NULL;
#endif

d16467 2
a16468 1
		const STRLEN len = my_snprintf(digits, sizeof(digits), "%lu", (long)i);
d16490 7
a16496 11
    /* Our definition of isPRINT() ignores locales, so only bytes that are
       not part of UTF-8 are considered printable. I assume that the same
       holds for UTF-EBCDIC.
       Also, code point 255 is not printable in either (it's E0 in EBCDIC,
       which Wikipedia says:

       EO, or Eight Ones, is an 8-bit EBCDIC character code represented as all
       ones (binary 1111 1111, hexadecimal FF). It is similar, but not
       identical, to the ASCII delete (DEL) or rubout control character. ...
       it is typically mapped to hexadecimal code 9F, in order to provide a
       unique character mapping in both directions)
d16498 4
a16501 8
       So the old condition can be simplified to !isPRINT(c)  */
    if (!isPRINT(c)) {
	if (c < 256) {
	    Perl_sv_catpvf(aTHX_ sv, "\\x%02x", c);
	}
	else {
	    Perl_sv_catpvf(aTHX_ sv, "\\x{%x}", c);
	}
d16511 76
d16589 4
a16592 3
    if (optstart) STMT_START { \
	    DEBUG_OPTIMISE_r(PerlIO_printf(Perl_debug_log, " (%"IVdf" nodes)\n", (IV)(node - optstart))); \
	    optstart=NULL; \
d16595 3
a16597 1
#define DUMPUNTIL(b,e) CLEAR_OPTSTART; node=dumpuntil(r,start,(b),(e),last,sv,indent+1,depth+1);
d16601 1
a16601 1
	    const regnode *last, const regnode *plast, 
d16608 1
a16608 1
    
d16618 2
a16619 2
            
    if (plast && plast < last) 
d16639 1
a16639 1
	regprop(r, sv, node);
d16642 2
a16643 2
        
        if (OP(node) != OPTIMIZED) {		      
d16646 2
a16647 1
            else if (PL_regkind[(U8)op] == BRANCH && PL_regkind[OP(next)] != BRANCH )
d16649 1
a16649 1
            else 
d16651 1
a16651 1
            (void)PerlIO_putc(Perl_debug_log, '\n'); 
d16653 1
a16653 1
        
d16680 2
a16681 1
	    AV *const trie_words = MUTABLE_AV(ri->data->data[n + TRIE_WORDS_OFFSET]);
d16691 9
a16699 5
                    elem_ptr ? pv_pretty(sv, SvPV_nolen_const(*elem_ptr), SvCUR(*elem_ptr), 60,
	                    PL_colors[0], PL_colors[1],
	                    (SvUTF8(*elem_ptr) ? PERL_PV_ESCAPE_UNI : 0) |
	                    PERL_PV_PRETTY_ELLIPSES    |
	                    PERL_PV_PRETTY_LTGT
d16701 1
a16701 1
                            : "???"
d16706 1
a16706 1
				  (UV)((dist ? this_trie + dist : next) - start));
d16709 1
a16709 1
                            nextbranch= this_trie + trie->jump[0];    
d16736 3
a16738 2
	    node += 1 + ((ANYOF_FLAGS(node) & ANYOF_CLASS)
		    ? ANYOF_CLASS_SKIP : ANYOF_SKIP);
d16754 1
a16754 1
#ifdef DEBUG_DUMPUNTIL    
@


1.17
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d84 1
d90 7
a96 3
#ifndef PERL_IN_XSUB_RE
#  include "charclass_invlists.h"
#endif
d115 1
d117 2
a118 1
    U32		flags;			/* are we folding, multilining? */
a138 1
    I32		seen_evals;
d156 5
d165 1
d177 1
a199 1
#define RExC_seen_evals	(pRExC_state->seen_evals)
d211 2
a212 1
#define RExC_override_recoding	(pRExC_state->override_recoding)
d217 1
a217 1
	((*s) == '{' && regcurly(s)))
d228 4
a231 2
/* Simple enough to be STAR/PLUS operand, in an EXACT node must be a single
 * character, and if utf8, must be invariant.  Note that this is not the same thing as REGNODE_SIMPLE */
d233 4
a236 3
#define	SPSTART		0x04	/* Starts with * or +. */
#define TRYAGAIN	0x08	/* Weeded out a declaration. */
#define POSTPONED	0x10    /* (?1),(?&name), (??{...}) or similar */
a254 2
/* If not already in utf8, do a longjmp back to the beginning */
#define UTF8_LONGJMP 42 /* Choose a value not likely to ever conflict */
d256 4
a259 1
                                     if (! UTF) JMPENV_JUMP(UTF8_LONGJMP); \
d262 5
d305 2
a306 2
    A pointer to the minimum length of the pattern that the string 
    was found inside. This is important as in the case of positive 
a413 1
#define MORE_ASCII_RESTRICTED (get_regex_charset(RExC_flags) == REGEX_ASCII_MORE_RESTRICTED_CHARSET)
d415 1
a418 1
#define OOB_UNICODE		12345678
d421 5
d453 1
a453 1
	SAVEDESTRUCTOR_X(clear_re,(void*)RExC_rx_sv);			\
d484 1
a484 1
	SAVEDESTRUCTOR_X(clear_re,(void*)RExC_rx_sv);	\
d502 1
a502 1
	SAVEDESTRUCTOR_X(clear_re,(void*)RExC_rx_sv);	\
d521 1
a521 1
	SAVEDESTRUCTOR_X(clear_re,(void*)RExC_rx_sv);	\
d534 13
d553 13
a724 2
static void clear_re(pTHX_ void *r);

d754 1
a754 1
				      : data->pos_min + data->pos_delta);
d780 11
d798 2
a799 2
    cl->flags = ANYOF_CLASS|ANYOF_EOS|ANYOF_UNICODE_ALL
		|ANYOF_LOC_NONBITMAP_FOLD|ANYOF_NON_UTF8_LATIN1_ALL;
d810 1
a810 1
	cl->flags |= ANYOF_LOCALE;
d825 1
a825 1
    for (value = 0; value <= ANYOF_MAX; value += 2)
d859 1
a859 1
    assert(and_with->type == ANYOF);
d865 2
a866 2
	&& !(and_with->flags & ANYOF_LOC_NONBITMAP_FOLD)
	&& !(cl->flags & ANYOF_LOC_NONBITMAP_FOLD)) {
d999 2
a1000 2
	     && !(or_with->flags & ANYOF_LOC_NONBITMAP_FOLD)
	     && !(cl->flags & ANYOF_LOC_NONBITMAP_FOLD) ) {
d1026 2
a1027 2
	     && (!(or_with->flags & ANYOF_LOC_NONBITMAP_FOLD)
		 || (cl->flags & ANYOF_LOC_NONBITMAP_FOLD)) ) {
d1033 3
a1035 5
	    if (ANYOF_CLASS_TEST_ANY_SET(or_with)) {
		for (i = 0; i < ANYOF_CLASSBITMAP_SIZE; i++)
		    cl->classflags[i] |= or_with->classflags[i];
		cl->flags |= ANYOF_CLASS;
	    }
d1585 1
a1585 1
	case EXACT: break;
d1614 1
a1614 1
    DEBUG_OPTIMISE_r({
d1656 1
a1656 1
        regnode * const noper = NEXTOPER( cur );
d1658 1
a1658 1
        const U8 * const e  = uc + STR_LEN( noper );
d1668 10
a1677 2
            trie->minlen= 0;
            continue;
d1679 1
d1818 1
a1818 1
	    regnode * const noper = NEXTOPER( cur );
d1820 1
a1820 1
	    const U8 * const e = uc + STR_LEN( noper );
d1829 9
d2025 1
a2025 1
	    regnode * const noper   = NEXTOPER( cur );
d2027 1
a2027 1
	    const U8 * const e = uc + STR_LEN( noper );
d2040 8
d2486 1
a2486 1
    SvREFCNT_dec(revcharmap);
d2628 2
a2629 4
 * one, and looks for problematic sequences of characters whose folds vs.
 * non-folds have sufficiently different lengths, that the optimizer would be
 * fooled into rejecting legitimate matches of them, and the trie construction
 * code can't cope with them.  The joining is only done if:
d2634 1
a2634 1
 * The adjacent nodes actually may be separated by NOTHING kind nodes, and
d2637 3
a2639 4
 * If there are problematic code sequences, *min_subtract is set to the delta
 * that the minimum size of the node can be less than its actual size.  And,
 * the node type of the result is changed to reflect that it contains these
 * sequences.
d2645 5
a2649 19
 * problematic sequences.  It's been wrong in Perl for a very long time.  There
 * are three code points in Unicode whose folded lengths differ so much from
 * the un-folded lengths that it causes problems for the optimizer and trie
 * construction.  Why only these are problematic, and not others where lengths
 * also differ is something I (khw) do not understand.  New versions of Unicode
 * might add more such code points.  Hopefully the logic in fold_grind.t that
 * figures out what to test (in part by verifying that each size-combination
 * gets tested) will catch any that do come along, so they can be added to the
 * special handling below.  The chances of new ones are actually rather small,
 * as most, if not all, of the world's scripts that have casefolding have
 * already been encoded by Unicode.  Also, a number of Unicode's decisions were
 * made to allow compatibility with pre-existing standards, and almost all of
 * those have already been dealt with.  These would otherwise be the most
 * likely candidates for generating further tricky sequences.  In other words,
 * Unicode by itself is unlikely to add new ones unless it is for compatibility
 * with pre-existing standards, and there aren't many of those left.
 *
 * The previous designs for dealing with these involved assigning a special
 * node for them.  This approach doesn't work, as evidenced by this example:
d2651 2
a2652 2
 * Both these fold to "sss", but if the pattern is parsed to create a node of
 * that would match just the \xDF, it won't be able to handle the case where a
d2657 5
a2661 4
 * There are a number of components to the approach (a lot of work for just
 * three code points!):
 * 1)   This routine examines each EXACTFish node that could contain the
 *      problematic sequences.  It returns in *min_subtract how much to
d2663 19
a2681 19
 *      for one that could match it.  This number is usually 0 except for the
 *      problematic sequences.  This delta is used by the caller to adjust the
 *      min length of the match, and the delta between min and max, so that the
 *      optimizer doesn't reject these possibilities based on size constraints.
 * 2)   These sequences are not currently correctly handled by the trie code
 *      either, so it changes the joined node type to ops that are not handled
 *      by trie's, those new ops being EXACTFU_SS and EXACTFU_TRICKYFOLD.
 * 3)   This is sufficient for the two Greek sequences (described below), but
 *      the one involving the Sharp s (\xDF) needs more.  The node type
 *      EXACTFU_SS is used for an EXACTFU node that contains at least one "ss"
 *      sequence in it.  For non-UTF-8 patterns and strings, this is the only
 *      case where there is a possible fold length change.  That means that a
 *      regular EXACTFU node without UTF-8 involvement doesn't have to concern
 *      itself with length changes, and so can be processed faster.  regexec.c
 *      takes advantage of this.  Generally, an EXACTFish node that is in UTF-8
 *      is pre-folded by regcomp.c.  This saves effort in regex matching.
 *      However, probably mostly for historical reasons, the pre-folding isn't
 *      done for non-UTF8 patterns (and it can't be for EXACTF and EXACTFL
 *      nodes, as what they fold to isn't known until runtime.)  The fold
d2683 6
a2688 7
 *      the sharp s.  All the ones that don't involve a UTF-8 target string
 *      are members of a fold-pair, and arrays are set up for all of them
 *      that quickly find the other member of the pair.  It might actually
 *      be faster to pre-fold these, but it isn't currently done, except for
 *      the sharp s.  Code elsewhere in this file makes sure that it gets
 *      folded to 'ss', even if the pattern isn't UTF-8.  This avoids the
 *      issues described in the next item.
d2693 1
a2693 1
 *      it can't be folded to "ss" at compile time, unlike EXACTFU does as
d2765 3
d2809 3
a2811 13
        U8 *s;
        U8 * s0 = (U8*) STRING(scan);
        U8 * const s_end = s0 + STR_LEN(scan);

	/* The below is perhaps overboard, but this allows us to save a test
	 * each time through the loop at the expense of a mask.  This is
	 * because on both EBCDIC and ASCII machines, 'S' and 's' differ by a
	 * single bit.  On ASCII they are 32 apart; on EBCDIC, they are 64.
	 * This uses an exclusive 'or' to find that bit and then inverts it to
	 * form a mask, with just a single 0, in the bit position where 'S' and
	 * 's' differ. */
	const U8 S_or_s_mask = (U8) ~ ('S' ^ 's');
	const U8 s_masked = 's' & S_or_s_mask;
d2819 5
a2823 46
	    /* There are two problematic Greek code points in Unicode
	     * casefolding
	     *
	     * U+0390 - GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS
	     * U+03B0 - GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS
	     *
	     * which casefold to
	     *
	     * Unicode                      UTF-8
	     *
	     * U+03B9 U+0308 U+0301         0xCE 0xB9 0xCC 0x88 0xCC 0x81
	     * U+03C5 U+0308 U+0301         0xCF 0x85 0xCC 0x88 0xCC 0x81
             *
	     * This means that in case-insensitive matching (or "loose
	     * matching", as Unicode calls it), an EXACTF of length six (the
	     * UTF-8 encoded byte length of the above casefolded versions) can
	     * match a target string of length two (the byte length of UTF-8
	     * encoded U+0390 or U+03B0).  This would rather mess up the
	     * minimum length computation.  (there are other code points that
	     * also fold to these two sequences, but the delta is smaller)
	     *
	     * If these sequences are found, the minimum length is decreased by
	     * four (six minus two).
	     *
	     * Similarly, 'ss' may match the single char and byte LATIN SMALL
	     * LETTER SHARP S.  We decrease the min length by 1 for each
	     * occurrence of 'ss' found */

#ifdef EBCDIC /* RD tunifold greek 0390 and 03B0 */
#	    define U390_first_byte 0xb4
	    const U8 U390_tail[] = "\x68\xaf\x49\xaf\x42";
#	    define U3B0_first_byte 0xb5
	    const U8 U3B0_tail[] = "\x46\xaf\x49\xaf\x42";
#else
#	    define U390_first_byte 0xce
	    const U8 U390_tail[] = "\xb9\xcc\x88\xcc\x81";
#	    define U3B0_first_byte 0xcf
	    const U8 U3B0_tail[] = "\x85\xcc\x88\xcc\x81";
#endif
	    const U8 len = sizeof(U390_tail); /* (-1 for NUL; +1 for 1st byte;
						 yields a net of 0 */
	    /* Examine the string for one of the problematic sequences */
	    for (s = s0;
		 s < s_end - 1; /* Can stop 1 before the end, as minimum length
				 * sequence we are looking for is 2 */
		 s += UTF8SKIP(s))
d2825 6
d2832 20
a2851 20
		/* Look for the first byte in each problematic sequence */
		switch (*s) {
		    /* We don't have to worry about other things that fold to
		     * 's' (such as the long s, U+017F), as all above-latin1
		     * code points have been pre-folded */
		    case 's':
		    case 'S':

                        /* Current character is an 's' or 'S'.  If next one is
                         * as well, we have the dreaded sequence */
			if (((*(s+1) & S_or_s_mask) == s_masked)
			    /* These two node types don't have special handling
			     * for 'ss' */
			    && OP(scan) != EXACTFL && OP(scan) != EXACTFA)
			{
			    *min_subtract += 1;
			    OP(scan) = EXACTFU_SS;
			    s++;    /* No need to look at this character again */
			}
			break;
d2853 14
a2866 2
		    case U390_first_byte:
			if (s_end - s >= len
d2868 26
a2893 7
			    /* The 1's are because are skipping comparing the
			     * first byte */
			    && memEQ(s + 1, U390_tail, len - 1))
			{
			    goto greek_sequence;
			}
			break;
d2895 4
a2898 23
		    case U3B0_first_byte:
			if (! (s_end - s >= len
			       && memEQ(s + 1, U3B0_tail, len - 1)))
			{
			    break;
			}
		      greek_sequence:
			*min_subtract += 4;

			/* This can't currently be handled by trie's, so change
			 * the node type to indicate this.  If EXACTFA and
			 * EXACTFL were ever to be handled by trie's, this
			 * would have to be changed.  If this node has already
			 * been changed to EXACTFU_SS in this loop, leave it as
			 * is.  (I (khw) think it doesn't matter in regexec.c
			 * for UTF patterns, but no need to change it */
			if (OP(scan) == EXACTFU) {
			    OP(scan) = EXACTFU_TRICKYFOLD;
			}
			s += 6;	/* We already know what this sequence is.  Skip
				   the rest of it */
			break;
		}
d2903 7
a2909 4
	    /* Here, the pattern is not UTF-8.  We need to look only for the
	     * 'ss' sequence, and in the EXACTF case, the sharp s, which can be
	     * in the final position.  Otherwise we can stop looking 1 byte
	     * earlier because have to find both the first and second 's' */
d2912 25
a2936 8
	    for (s = s0; s < upper; s++) {
		switch (*s) {
		    case 'S':
		    case 's':
			if (s_end - s > 1
			    && ((*(s+1) & S_or_s_mask) == s_masked))
			{
			    *min_subtract += 1;
d2938 8
a2945 17
			    /* EXACTF nodes need to know that the minimum
			     * length changed so that a sharp s in the string
			     * can match this ss in the pattern, but they
			     * remain EXACTF nodes, as they are not trie'able,
			     * so don't have to invent a new node type to
			     * exclude them from the trie code */
			    if (OP(scan) != EXACTF) {
				OP(scan) = EXACTFU_SS;
			    }
			    s++;
			}
			break;
		    case LATIN_SMALL_LETTER_SHARP_S:
			if (OP(scan) == EXACTF) {
			    *has_exactf_sharp_s = TRUE;
			}
			break;
d2947 3
a2993 28
#define CASE_SYNST_FNC(nAmE)                                       \
case nAmE:                                                         \
    if (flags & SCF_DO_STCLASS_AND) {                              \
	    for (value = 0; value < 256; value++)                  \
		if (!is_ ## nAmE ## _cp(value))                       \
		    ANYOF_BITMAP_CLEAR(data->start_class, value);  \
    }                                                              \
    else {                                                         \
	    for (value = 0; value < 256; value++)                  \
		if (is_ ## nAmE ## _cp(value))                        \
		    ANYOF_BITMAP_SET(data->start_class, value);	   \
    }                                                              \
    break;                                                         \
case N ## nAmE:                                                    \
    if (flags & SCF_DO_STCLASS_AND) {                              \
	    for (value = 0; value < 256; value++)                   \
		if (is_ ## nAmE ## _cp(value))                         \
		    ANYOF_BITMAP_CLEAR(data->start_class, value);   \
    }                                                               \
    else {                                                          \
	    for (value = 0; value < 256; value++)                   \
		if (!is_ ## nAmE ## _cp(value))                        \
		    ANYOF_BITMAP_SET(data->start_class, value);	    \
    }                                                               \
    break



d3012 2
a3013 1
    I32 min = 0, pars = 0, code;
d3040 3
a3042 3
        UV min_subtract = 0;    /* How much to subtract from the minimum node
                                   length to get a real minimum (because the
                                   folded version may be shorter) */
d3131 4
a3134 1
		    if (max1 < minnext + deltanext)
a3135 2
		    if (deltanext == I32_MAX)
			is_inf = is_inf_internal = 1;
d3158 4
a3161 1
		    data->pos_delta += max1 - min1;
d3166 4
a3169 1
		delta += max1 - min1;
d3192 1
a3192 1
			data->start_class->flags |= ANYOF_EOS;
d3269 1
a3269 1
                        DEBUG_OPTIMISE_r({
d3335 2
d3339 1
a3339 1
                            DEBUG_OPTIMISE_r({
d3353 4
a3356 2
                                PerlIO_printf( Perl_debug_log, "(First==%d,Last==%d,Cur==%d)\n",
                                   REG_NODE_NUM(first), REG_NODE_NUM(last), REG_NODE_NUM(cur) );
d3364 2
a3365 16
                                        /* XXX: Currently we cannot allow a NOTHING node to be the first element
                                         * of a TRIEABLE sequence, Otherwise we will overwrite the regop following
                                         * the NOTHING with the TRIE regop later on. This is because a NOTHING node
                                         * is only one regnode wide, and a TRIE is two regnodes. An example of a
                                         * problematic pattern is: "x" =~ /\A(?>(?:(?:)A|B|C?x))\z/
                                         * At a later point of time we can somewhat workaround this by handling
                                         * NOTHING -> EXACT sequences as generated by /(?:)A|(?:)B/ type patterns,
                                         * as we can effectively ignore the NOTHING regop in that case.
                                         * This clause, which allows NOTHING to start a sequence is left commented
                                         * out as a reference.
                                         * - Yves

                                           ( noper_trietype == NOTHING)
                                           || ( trietype == NOTHING )
                                        */
                                        ( noper_trietype == NOTHING && trietype )
a3376 1
                                count++;
d3379 17
a3395 1
                                    trietype = noper_trietype;
d3401 2
d3414 1
a3414 1
                                    if ( trietype != NOTHING )
d3438 1
a3438 1
                        DEBUG_OPTIMISE_r({
d3445 6
a3450 5
                        if ( last && trietype != NOTHING ) {
                            /* the last branch of the sequence was part of a trie,
                             * so we have to construct it here outside of the loop
                             */
                            made= make_trie( pRExC_state, startbranch, first, scan, tail, count, trietype, depth+1 );
d3452 31
a3482 9
                            if ( ((made == MADE_EXACT_TRIE && 
                                 startbranch == first) 
                                 || ( first_non_open == first )) && 
                                 depth==0 ) {
                                flags |= SCF_TRIE_RESTUDY;
                                if ( startbranch == first 
                                     && scan == tail ) 
                                {
                                    RExC_seen &=~REG_TOP_LEVEL_BRANCHES;
a3484 1
#endif
d3600 1
a3600 1
		    (!(data->start_class->flags & (ANYOF_CLASS | ANYOF_LOCALE))
d3602 1
a3602 1
		    && (!(data->start_class->flags & ANYOF_LOC_NONBITMAP_FOLD)
d3623 1
a3623 1
			if (_HAS_NONLATIN1_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(i)) {
d3628 1
a3628 1
		data->start_class->flags &= ~ANYOF_EOS;
d3638 1
a3638 1
		data->start_class->flags &= ~ANYOF_EOS;
d3657 1
a3657 1
	    else if (has_exactf_sharp_s) {
d3661 1
a3661 3
            if (min < 0) {
                min = 0;
            }
d3677 1
a3677 1
		 (!(data->start_class->flags & (ANYOF_CLASS | ANYOF_LOCALE))
d3687 1
a3687 2
		    data->start_class->flags &= ~ANYOF_EOS;
		    data->start_class->flags |= ANYOF_LOC_NONBITMAP_FOLD;
d3692 1
a3692 1
			data->start_class->flags |= ANYOF_LOCALE;
d3727 1
a3727 1
		if (data->start_class->flags & ANYOF_LOC_NONBITMAP_FOLD) {
d3754 1
a3754 1
		    data->start_class->flags &= ~ANYOF_EOS;
d3871 1
a3871 1
			data->start_class->flags |= ANYOF_EOS;
d3890 2
d3894 1
d3898 2
a3899 3
		is_inf_internal |= ((maxcount == REG_INFTY
				     && (minnext + deltanext) > 0)
				    || deltanext == I32_MAX);
d3901 4
a3904 1
		delta += (minnext + deltanext) * maxcount - minnext * mincount;
d3956 1
d4089 10
a4098 1
		    data->pos_delta += - counted * deltanext +
d4133 1
a4133 1
	    default:			/* REF, ANYOFV, and CLUMP only? */
d4148 1
a4148 1
		data->start_class->flags &= ~ANYOF_EOS;	/* No match on empty */
d4163 2
a4164 2
	    min += 1;
	    delta += 1;
d4181 2
a4182 1
		data->start_class->flags &= ~ANYOF_EOS;	/* No match on empty */
d4187 2
d4191 4
a4194 2
		  do_default:
		    /* Perl_croak(aTHX_ "panic: unexpected simple REx opcode %d", OP(scan)); */
d4203 1
a4203 1
				 || ANYOF_CLASS_TEST_ANY_SET(data->start_class));
d4217 7
a4223 1
		case ALNUM:
d4226 4
a4229 12
			    ANYOF_CLASS_CLEAR(data->start_class,ANYOF_NALNUM);
                            if (OP(scan) == ALNUMU) {
                                for (value = 0; value < 256; value++) {
                                    if (!isWORDCHAR_L1(value)) {
                                        ANYOF_BITMAP_CLEAR(data->start_class, value);
                                    }
                                }
                            } else {
                                for (value = 0; value < 256; value++) {
                                    if (!isALNUM(value)) {
                                        ANYOF_BITMAP_CLEAR(data->start_class, value);
                                    }
d4235 4
a4238 2
			if (data->start_class->flags & ANYOF_LOCALE)
			    ANYOF_CLASS_SET(data->start_class,ANYOF_ALNUM);
d4243 3
a4245 11
                        if (OP(scan) == ALNUMU) {
                            for (value = 0; value < 256; value++) {
                                if (isWORDCHAR_L1(value)) {
                                    ANYOF_BITMAP_SET(data->start_class, value);
                                }
                            }
                        } else {
                            for (value = 0; value < 256; value++) {
                                if (isALNUM(value)) {
                                    ANYOF_BITMAP_SET(data->start_class, value);
                                }
d4247 1
d4251 7
a4257 1
		case NALNUM:
d4260 4
a4263 6
			    ANYOF_CLASS_CLEAR(data->start_class,ANYOF_ALNUM);
                            if (OP(scan) == NALNUMU) {
                                for (value = 0; value < 256; value++) {
                                    if (isWORDCHAR_L1(value)) {
                                        ANYOF_BITMAP_CLEAR(data->start_class, value);
                                    }
d4265 1
a4265 7
                            } else {
                                for (value = 0; value < 256; value++) {
                                    if (isALNUM(value)) {
                                        ANYOF_BITMAP_CLEAR(data->start_class, value);
                                    }
                                }
			    }
d4269 4
a4272 2
			if (data->start_class->flags & ANYOF_LOCALE)
			    ANYOF_CLASS_SET(data->start_class,ANYOF_NALNUM);
d4277 3
a4279 31
			if (OP(scan) == NALNUMU) {
			    for (value = 0; value < 256; value++) {
				if (! isWORDCHAR_L1(value)) {
				    ANYOF_BITMAP_SET(data->start_class, value);
				}
			    }
			} else {
			    for (value = 0; value < 256; value++) {
				if (! isALNUM(value)) {
				    ANYOF_BITMAP_SET(data->start_class, value);
				}
			    }
			}
		    }
		    break;
		case SPACE:
		    if (flags & SCF_DO_STCLASS_AND) {
			if (!(data->start_class->flags & ANYOF_LOCALE)) {
			    ANYOF_CLASS_CLEAR(data->start_class,ANYOF_NSPACE);
			    if (OP(scan) == SPACEU) {
                                for (value = 0; value < 256; value++) {
                                    if (!isSPACE_L1(value)) {
                                        ANYOF_BITMAP_CLEAR(data->start_class, value);
                                    }
                                }
                            } else {
                                for (value = 0; value < 256; value++) {
                                    if (!isSPACE(value)) {
                                        ANYOF_BITMAP_CLEAR(data->start_class, value);
                                    }
                                }
a4280 5
			}
		    }
		    else {
                        if (data->start_class->flags & ANYOF_LOCALE) {
			    ANYOF_CLASS_SET(data->start_class,ANYOF_SPACE);
d4282 2
a4283 43
                        if (OP(scan) == SPACEU) {
                            for (value = 0; value < 256; value++) {
                                if (isSPACE_L1(value)) {
                                    ANYOF_BITMAP_SET(data->start_class, value);
                                }
                            }
                        } else {
                            for (value = 0; value < 256; value++) {
                                if (isSPACE(value)) {
                                    ANYOF_BITMAP_SET(data->start_class, value);
                                }
                            }
			}
		    }
		    break;
		case NSPACE:
		    if (flags & SCF_DO_STCLASS_AND) {
			if (!(data->start_class->flags & ANYOF_LOCALE)) {
			    ANYOF_CLASS_CLEAR(data->start_class,ANYOF_SPACE);
                            if (OP(scan) == NSPACEU) {
                                for (value = 0; value < 256; value++) {
                                    if (isSPACE_L1(value)) {
                                        ANYOF_BITMAP_CLEAR(data->start_class, value);
                                    }
                                }
                            } else {
                                for (value = 0; value < 256; value++) {
                                    if (isSPACE(value)) {
                                        ANYOF_BITMAP_CLEAR(data->start_class, value);
                                    }
                                }
                            }
			}
		    }
		    else {
			if (data->start_class->flags & ANYOF_LOCALE)
			    ANYOF_CLASS_SET(data->start_class,ANYOF_NSPACE);
                        if (OP(scan) == NSPACEU) {
                            for (value = 0; value < 256; value++) {
                                if (!isSPACE_L1(value)) {
                                    ANYOF_BITMAP_SET(data->start_class, value);
                                }
                            }
a4284 6
                        else {
                            for (value = 0; value < 256; value++) {
                                if (!isSPACE(value)) {
                                    ANYOF_BITMAP_SET(data->start_class, value);
                                }
                            }
a4287 36
		case DIGIT:
		    if (flags & SCF_DO_STCLASS_AND) {
			if (!(data->start_class->flags & ANYOF_LOCALE)) {
                            ANYOF_CLASS_CLEAR(data->start_class,ANYOF_NDIGIT);
			    for (value = 0; value < 256; value++)
				if (!isDIGIT(value))
				    ANYOF_BITMAP_CLEAR(data->start_class, value);
			}
		    }
		    else {
			if (data->start_class->flags & ANYOF_LOCALE)
			    ANYOF_CLASS_SET(data->start_class,ANYOF_DIGIT);
			for (value = 0; value < 256; value++)
			    if (isDIGIT(value))
				ANYOF_BITMAP_SET(data->start_class, value);
		    }
		    break;
		case NDIGIT:
		    if (flags & SCF_DO_STCLASS_AND) {
			if (!(data->start_class->flags & ANYOF_LOCALE))
                            ANYOF_CLASS_CLEAR(data->start_class,ANYOF_DIGIT);
			for (value = 0; value < 256; value++)
			    if (isDIGIT(value))
				ANYOF_BITMAP_CLEAR(data->start_class, value);
		    }
		    else {
			if (data->start_class->flags & ANYOF_LOCALE)
			    ANYOF_CLASS_SET(data->start_class,ANYOF_NDIGIT);
			for (value = 0; value < 256; value++)
			    if (!isDIGIT(value))
				ANYOF_BITMAP_SET(data->start_class, value);
		    }
		    break;
		CASE_SYNST_FNC(VERTWS);
		CASE_SYNST_FNC(HORIZWS);

d4298 2
d4305 26
d4390 1
a4390 1
			const int was = (data->start_class->flags & ANYOF_EOS);
d4394 1
a4394 1
			    data->start_class->flags |= ANYOF_EOS;
d4462 1
a4462 1
                    const int was = (data->start_class->flags & ANYOF_EOS);
d4466 1
a4466 1
                        data->start_class->flags |= ANYOF_EOS;
d4478 1
a4478 1
                        SvREFCNT_dec(data_fake.last_found);
a4494 2


d4616 4
a4619 1
                    if (max1 < (I32)(minnext + deltanext + trie->maxlen))
a4620 2
                    if (deltanext == I32_MAX)
                        is_inf = is_inf_internal = 1;
d4670 1
a4670 1
                    data->start_class->flags |= ANYOF_EOS;
d4786 2
a4787 1
#define CHECK_RESTUDY_GOTO                                  \
d4791 5
a4795 1
        )     goto reStudy
d4797 1
a4797 1
#define CHECK_RESTUDY_GOTO
d4801 1
a4801 10
 - pregcomp - compile a regular expression into internal code
 *
 * We can't allocate space until we know how big the compiled form will be,
 * but we can't compile it (and thus know how big it is) until we've got a
 * place to put the code.  So we cheat:  we compile it twice, once with code
 * generation turned off and size counting turned on, and once "for real".
 * This also means that we don't allocate space until we are sure that the
 * thing really will compile successfully, and we never have to move the
 * code and thus invalidate pointers into it.  (Note that it has to be in
 * one piece because free() must be able to free it all.) [NB: not true in perl]
d4803 2
a4804 2
 * Beware that the optimization-preparation code in here knows about some
 * of the structure of the compiled regexp.  [I'll say.]
d4807 3
d4811 26
a4837 6
#ifndef PERL_IN_XSUB_RE
#define RE_ENGINE_PTR &PL_core_reg_engine
#else
extern const struct regexp_engine my_reg_engine;
#define RE_ENGINE_PTR &my_reg_engine
#endif
a4838 1
#ifndef PERL_IN_XSUB_RE 
d4843 2
a4844 1
    HV * const table = GvHV(PL_hintgv);
d4848 6
a4853 15
    /* Dispatch a request to compile a regexp to correct 
       regexp engine. */
    if (table) {
        SV **ptr= hv_fetchs(table, "regcomp", FALSE);
        GET_RE_DEBUG_FLAGS_DECL;
        if (ptr && SvIOK(*ptr) && SvIV(*ptr)) {
            const regexp_engine *eng=INT2PTR(regexp_engine*,SvIV(*ptr));
            DEBUG_COMPILE_r({
                PerlIO_printf(Perl_debug_log, "Using engine %"UVxf"\n",
                    SvIV(*ptr));
            });            
            return CALLREGCOMP_ENG(eng, pattern, flags);
        } 
    }
    return Perl_re_compile(aTHX_ pattern, flags);
d4857 5
d4863 1
a4863 1
Perl_re_compile(pTHX_ SV * const pattern, U32 orig_pm_flags)
d4865 1
a4865 31
    dVAR;
    REGEXP *rx;
    struct regexp *r;
    register regexp_internal *ri;
    STRLEN plen;
    char* VOL exp;
    char* xend;
    regnode *scan;
    I32 flags;
    I32 minlen = 0;
    U32 pm_flags;

    /* these are all flags - maybe they should be turned
     * into a single int with different bit masks */
    I32 sawlookahead = 0;
    I32 sawplus = 0;
    I32 sawopen = 0;
    bool used_setjump = FALSE;
    regex_charset initial_charset = get_regex_charset(orig_pm_flags);

    U8 jump_ret = 0;
    dJMPENV;
    scan_data_t data;
    RExC_state_t RExC_state;
    RExC_state_t * const pRExC_state = &RExC_state;
#ifdef TRIE_STUDY_OPT    
    int restudied;
    RExC_state_t copyRExC_state;
#endif    
    GET_RE_DEBUG_FLAGS_DECL;

d4867 8
a4875 1
    DEBUG_r(if (!PL_colorset) reginitcolors());
d4877 6
a4882 7
#ifndef PERL_IN_XSUB_RE
    /* Initialize these here instead of as-needed, as is quick and avoids
     * having to test them each time otherwise */
    if (! PL_AboveLatin1) {
	PL_AboveLatin1 = _new_invlist_C_array(AboveLatin1_invlist);
	PL_ASCII = _new_invlist_C_array(ASCII_invlist);
	PL_Latin1 = _new_invlist_C_array(Latin1_invlist);
d4884 10
a4893 2
	PL_L1PosixAlnum = _new_invlist_C_array(L1PosixAlnum_invlist);
	PL_PosixAlnum = _new_invlist_C_array(PosixAlnum_invlist);
d4895 2
a4896 2
	PL_L1PosixAlpha = _new_invlist_C_array(L1PosixAlpha_invlist);
	PL_PosixAlpha = _new_invlist_C_array(PosixAlpha_invlist);
d4898 1
a4898 2
	PL_PosixBlank = _new_invlist_C_array(PosixBlank_invlist);
	PL_XPosixBlank = _new_invlist_C_array(XPosixBlank_invlist);
d4900 629
a5528 1
	PL_L1Cased = _new_invlist_C_array(L1Cased_invlist);
d5530 3
a5532 2
	PL_PosixCntrl = _new_invlist_C_array(PosixCntrl_invlist);
	PL_XPosixCntrl = _new_invlist_C_array(XPosixCntrl_invlist);
d5534 2
a5535 1
	PL_PosixDigit = _new_invlist_C_array(PosixDigit_invlist);
d5537 2
a5538 2
	PL_L1PosixGraph = _new_invlist_C_array(L1PosixGraph_invlist);
	PL_PosixGraph = _new_invlist_C_array(PosixGraph_invlist);
d5540 2
a5541 2
	PL_L1PosixAlnum = _new_invlist_C_array(L1PosixAlnum_invlist);
	PL_PosixAlnum = _new_invlist_C_array(PosixAlnum_invlist);
d5543 2
a5544 2
	PL_L1PosixLower = _new_invlist_C_array(L1PosixLower_invlist);
	PL_PosixLower = _new_invlist_C_array(PosixLower_invlist);
d5546 2
a5547 2
	PL_L1PosixPrint = _new_invlist_C_array(L1PosixPrint_invlist);
	PL_PosixPrint = _new_invlist_C_array(PosixPrint_invlist);
d5549 2
a5550 2
	PL_L1PosixPunct = _new_invlist_C_array(L1PosixPunct_invlist);
	PL_PosixPunct = _new_invlist_C_array(PosixPunct_invlist);
d5552 4
a5555 2
	PL_PerlSpace = _new_invlist_C_array(PerlSpace_invlist);
	PL_XPerlSpace = _new_invlist_C_array(XPerlSpace_invlist);
d5557 2
a5558 2
	PL_PosixSpace = _new_invlist_C_array(PosixSpace_invlist);
	PL_XPosixSpace = _new_invlist_C_array(XPosixSpace_invlist);
d5560 1
a5560 2
	PL_L1PosixUpper = _new_invlist_C_array(L1PosixUpper_invlist);
	PL_PosixUpper = _new_invlist_C_array(PosixUpper_invlist);
d5562 3
a5564 1
	PL_VertSpace = _new_invlist_C_array(VertSpace_invlist);
d5566 2
a5567 2
	PL_PosixWord = _new_invlist_C_array(PosixWord_invlist);
	PL_L1PosixWord = _new_invlist_C_array(L1PosixWord_invlist);
d5569 1
a5569 2
	PL_PosixXDigit = _new_invlist_C_array(PosixXDigit_invlist);
	PL_XPosixXDigit = _new_invlist_C_array(XPosixXDigit_invlist);
d5573 44
a5616 1
    exp = SvPV(pattern, plen);
d5618 25
a5642 2
    if (plen == 0) { /* ignore the utf8ness if the pattern is 0 length */
	RExC_utf8 = RExC_orig_utf8 = 0;
d5644 20
a5663 2
    else {
	RExC_utf8 = RExC_orig_utf8 = SvUTF8(pattern);
a5664 2
    RExC_uni_semantics = 0;
    RExC_contains_locale = 0;
d5666 13
a5678 5
    /****************** LONG JUMP TARGET HERE***********************/
    /* Longjmp back to here if have to switch in midstream to utf8 */
    if (! RExC_orig_utf8) {
	JMPENV_PUSH(jump_ret);
	used_setjump = TRUE;
d5681 5
a5685 2
    if (jump_ret == 0) {    /* First time through */
	xend = exp + plen;
d5687 1
a5687 1
        DEBUG_COMPILE_r({
d5689 1
a5689 2
            RE_PV_QUOTED_DECL(s, RExC_utf8,
                dsv, exp, plen, 60);
d5691 1
a5691 1
                           PL_colors[4],PL_colors[5],s);
a5692 3
    }
    else {  /* longjumped back */
        STRLEN len = plen;
d5694 10
a5703 6
        /* If the cause for the longjmp was other than changing to utf8, pop
         * our own setjmp, and longjmp to the correct handler */
	if (jump_ret != UTF8_LONGJMP) {
	    JMPENV_POP;
	    JMPENV_JUMP(jump_ret);
	}
d5705 6
a5710 1
	GET_RE_DEBUG_FLAGS;
d5712 11
a5722 16
        /* It's possible to write a regexp in ascii that represents Unicode
        codepoints outside of the byte range, such as via \x{100}. If we
        detect such a sequence we have to convert the entire pattern to utf8
        and then recompile, as our sizing calculation will have been based
        on 1 byte == 1 character, but we will need to use utf8 to encode
        at least some part of the pattern, and therefore must convert the whole
        thing.
        -- dmq */
        DEBUG_PARSE_r(PerlIO_printf(Perl_debug_log,
	    "UTF8 mismatch! Converting to utf8 for resizing and compile\n"));
        exp = (char*)Perl_bytes_to_utf8(aTHX_
				        (U8*)SvPV_nomg(pattern, plen),
					&len);
        xend = exp + len;
        RExC_orig_utf8 = RExC_utf8 = 1;
        SAVEFREEPV(exp);
d5725 1
a5725 5
#ifdef TRIE_STUDY_OPT
    restudied = 0;
#endif

    pm_flags = orig_pm_flags;
d5734 1
a5734 1
	set_regex_charset(&pm_flags, REGEX_UNICODE_CHARSET);
d5738 17
a5754 1
    RExC_flags = pm_flags;
a5759 1
    RExC_seen_evals = 0;
d5762 1
d5767 1
a5767 1
    RExC_end = xend;
d5783 1
d5794 11
d5806 14
a5819 7
	RExC_precomp = NULL;
	return(NULL);
    }

    /* Here, finished first pass.  Get rid of any added setjmp */
    if (used_setjump) {
	JMPENV_POP;
d5821 2
d5835 1
a5835 1
	 && get_regex_charset(pm_flags) == REGEX_DEPENDS_CHARSET)
d5837 1
a5837 1
	set_regex_charset(&pm_flags, REGEX_UNICODE_CHARSET);
d5853 1
a5853 1
    r = (struct regexp*)SvANY(rx);
d5868 17
a5884 2
    r->engine= RE_ENGINE_PTR;
    r->extflags = pm_flags;
d5914 4
a5917 3
        p = sv_grow(MUTABLE_SV(rx), wraplen + 1); /* +1 for the ending NUL */
	SvPOK_on(rx);
	SvFLAGS(rx) |= SvUTF8(pattern);
d5950 1
a5950 1
	SvCUR_set(rx, p - SvPVX_const(rx));
d5977 2
a5978 1
    RExC_flags = pm_flags;	/* don't let top level (?i) bleed */
d5980 1
a5980 1
    RExC_end = xend;
d5986 1
a5987 2
    /* Store the count of eval-groups for security checks: */
    RExC_rx->seen_evals = RExC_seen_evals;
d5991 1
a5991 1
	return(NULL);
a6017 5
        if (data.last_found) {
            SvREFCNT_dec(data.longest_fixed);
	    SvREFCNT_dec(data.longest_float);
	    SvREFCNT_dec(data.last_found);
	}
d6135 1
a6135 1
	    !(r->extflags & RXf_ANCH) && !(RExC_seen & REG_SEEN_EVAL))
d6148 1
a6148 1
	    && !(RExC_seen & REG_SEEN_EVAL)) /* May examine pos and $& */
d6183 4
d6201 1
a6201 1
        CHECK_RESTUDY_GOTO;
a6210 1
	SvREFCNT_dec(data.last_found);
a6211 4
        /* Note that code very similar to this but for anchored string 
           follows immediately below, changes may need to be made to both. 
           Be careful. 
         */
d6213 15
a6227 4
	if (longest_float_length
	    || (data.flags & SF_FL_BEFORE_EOL
		&& (!(data.flags & SF_FL_BEFORE_MEOL)
		    || (RExC_flags & RXf_PMf_MULTILINE)))) 
a6228 27
            I32 t,ml;

            /* See comments for join_exact for why REG_SEEN_EXACTF_SHARP_S */
	    if ((RExC_seen & REG_SEEN_EXACTF_SHARP_S)
		|| (SvCUR(data.longest_fixed)  /* ok to leave SvCUR */
		    && data.offset_fixed == data.offset_float_min
		    && SvCUR(data.longest_fixed) == SvCUR(data.longest_float)))
		    goto remove_float;		/* As in (a)+. */

            /* copy the information about the longest float from the reg_scan_data
               over to the program. */
	    if (SvUTF8(data.longest_float)) {
		r->float_utf8 = data.longest_float;
		r->float_substr = NULL;
	    } else {
		r->float_substr = data.longest_float;
		r->float_utf8 = NULL;
	    }
	    /* float_end_shift is how many chars that must be matched that 
	       follow this item. We calculate it ahead of time as once the
	       lookbehind offset is added in we lose the ability to correctly
	       calculate it.*/
	    ml = data.minlen_float ? *(data.minlen_float) 
	                           : (I32)longest_float_length;
	    r->float_end_shift = ml - data.offset_float_min
	        - longest_float_length + (SvTAIL(data.longest_float) != 0)
	        + data.lookbehind_float;
d6233 1
a6233 5
	    
	    t = (data.flags & SF_FL_BEFORE_EOL /* Can't have SEOL and MULTI */
		       && (!(data.flags & SF_FL_BEFORE_MEOL)
			   || (RExC_flags & RXf_PMf_MULTILINE)));
	    fbm_compile(data.longest_float, t ? FBMcf_TAIL : 0);
a6235 1
	  remove_float:
a6236 1
	    SvREFCNT_dec(data.longest_float);
a6239 4
        /* Note that code very similar to this but for floating string 
           is immediately above, changes may need to be made to both. 
           Be careful. 
         */
d6242 11
a6252 6
        /* See comments for join_exact for why REG_SEEN_EXACTF_SHARP_S */
	if (! (RExC_seen & REG_SEEN_EXACTF_SHARP_S)
	    && (longest_fixed_length
	        || (data.flags & SF_FIX_BEFORE_EOL /* Cannot have SEOL and MULTI */
		    && (!(data.flags & SF_FIX_BEFORE_MEOL)
		        || (RExC_flags & RXf_PMf_MULTILINE)))) )
a6253 20
            I32 t,ml;

            /* copy the information about the longest fixed 
               from the reg_scan_data over to the program. */
	    if (SvUTF8(data.longest_fixed)) {
		r->anchored_utf8 = data.longest_fixed;
		r->anchored_substr = NULL;
	    } else {
		r->anchored_substr = data.longest_fixed;
		r->anchored_utf8 = NULL;
	    }
	    /* fixed_end_shift is how many chars that must be matched that 
	       follow this item. We calculate it ahead of time as once the
	       lookbehind offset is added in we lose the ability to correctly
	       calculate it.*/
            ml = data.minlen_fixed ? *(data.minlen_fixed) 
                                   : (I32)longest_fixed_length;
            r->anchored_end_shift = ml - data.offset_fixed
	        - longest_fixed_length + (SvTAIL(data.longest_fixed) != 0)
	        + data.lookbehind_fixed;
d6255 1
a6255 5

	    t = (data.flags & SF_FIX_BEFORE_EOL /* Can't have SEOL and MULTI */
		 && (!(data.flags & SF_FIX_BEFORE_MEOL)
		     || (RExC_flags & RXf_PMf_MULTILINE)));
	    fbm_compile(data.longest_fixed, t ? FBMcf_TAIL : 0);
a6258 1
	    SvREFCNT_dec(data.longest_fixed);
d6261 2
d6269 1
a6269 1
	    && !(data.start_class->flags & ANYOF_EOS)
d6273 1
a6273 1
	    data.start_class->flags |= ANYOF_IS_SYNTHETIC;
d6336 1
a6336 1
        CHECK_RESTUDY_GOTO;
d6341 1
a6341 1
	if (!(data.start_class->flags & ANYOF_EOS)
d6345 1
a6345 1
	    data.start_class->flags |= ANYOF_IS_SYNTHETIC;
d6375 2
a6376 2
	r->extflags |= RXf_LOOKBEHIND_SEEN;
    if (RExC_seen & REG_SEEN_EVAL)
d6381 1
d6383 2
d6387 2
d6394 1
a6394 15
#ifdef STUPID_PATTERN_CHECKS            
    if (RX_PRELEN(rx) == 0)
        r->extflags |= RXf_NULL;
    if (r->extflags & RXf_SPLIT && RX_PRELEN(rx) == 1 && RX_PRECOMP(rx)[0] == ' ')
        /* XXX: this should happen BEFORE we compile */
        r->extflags |= (RXf_SKIPWHITE|RXf_WHITE); 
    else if (RX_PRELEN(rx) == 3 && memEQ("\\s+", RX_PRECOMP(rx), 3))
        r->extflags |= RXf_WHITE;
    else if (RX_PRELEN(rx) == 1 && RXp_PRECOMP(rx)[0] == '^')
        r->extflags |= RXf_START_ONLY;
#else
    if (r->extflags & RXf_SPLIT && RX_PRELEN(rx) == 1 && RX_PRECOMP(rx)[0] == ' ')
            /* XXX: this should happen BEFORE we compile */
            r->extflags |= (RXf_SKIPWHITE|RXf_WHITE); 
    else {
d6397 2
d6400 1
a6400 1
        if (PL_regkind[fop] == NOTHING && OP(NEXTOPER(first)) == END)
d6402 1
a6402 1
        else if (PL_regkind[fop] == BOL && OP(NEXTOPER(first)) == END)
d6404 5
a6408 3
        else if (fop == PLUS && OP(NEXTOPER(first)) == SPACE
			     && OP(regnext(first)) == END)
            r->extflags |= RXf_WHITE;    
a6409 1
#endif
d6445 8
a6455 2
#undef RE_ENGINE_PTR

d6468 1
a6468 1
        Perl_croak_no_modify(aTHX);
d6507 1
a6507 1
    struct regexp *const rx = (struct regexp *)SvANY(r);
d6547 1
a6547 1
    struct regexp *const rx = (struct regexp *)SvANY(r);
d6557 1
a6557 1
		SvREFCNT_dec(sv);
d6571 1
a6571 1
    struct regexp *const rx = (struct regexp *)SvANY(r);
d6587 1
a6587 1
    struct regexp *const rx = (struct regexp *)SvANY(r);
d6623 1
a6623 1
    struct regexp *const rx = (struct regexp *)SvANY(r);
d6634 1
a6634 1
	    SvREFCNT_dec(ret);
d6647 1
a6647 1
    struct regexp *const rx = (struct regexp *)SvANY(r);
d6683 1
a6683 1
    struct regexp *const rx = (struct regexp *)SvANY(r);
d6687 1
d6691 29
a6719 7
    if (!rx->subbeg) {
        sv_setsv(sv,&PL_sv_undef);
        return;
    } 
    else               
    if (paren == RX_BUFF_IDX_PREMATCH && rx->offs[0].start != -1) {
        /* $` */
d6724 6
a6729 4
    if (paren == RX_BUFF_IDX_POSTMATCH && rx->offs[0].end != -1) {
        /* $' */
	s = rx->subbeg + rx->offs[0].end;
	i = rx->sublen - rx->offs[0].end;
d6732 3
a6734 3
    if ( 0 <= paren && paren <= (I32)rx->nparens &&
        (s1 = rx->offs[paren].start) != -1 &&
        (t1 = rx->offs[paren].end) != -1)
d6736 1
a6736 1
        /* $& $1 ... */
d6738 1
a6738 1
        s = rx->subbeg + s1;
d6740 1
a6740 2
        sv_setsv(sv,&PL_sv_undef);
        return;
d6742 2
d6746 4
a6749 1
        const int oldtainted = PL_tainted;
d6752 2
a6753 1
        PL_tainted = oldtainted;
d6763 1
a6763 1
        if (PL_tainting) {
d6768 1
a6768 1
                    PL_tainted = 1;
d6776 1
a6776 1
                    PL_tainted = 1;
d6783 1
d6800 1
a6800 1
        Perl_croak_no_modify(aTHX);
d6807 1
a6807 1
    struct regexp *const rx = (struct regexp *)SvANY(r);
d6813 18
d6832 3
a6834 3
	switch (paren) {
      /* $` / ${^PREMATCH} */
      case RX_BUFF_IDX_PREMATCH:
d6844 3
a6846 2
      /* $' / ${^POSTMATCH} */
      case RX_BUFF_IDX_POSTMATCH:
d6856 2
a6857 2
      /* $& / ${^MATCH}, $1, $2, ... */
      default:
d6865 1
d6873 1
a6873 1
        const char * const s = rx->subbeg + s1;
d6919 1
a6919 1
	    } while (isALNUM_utf8((U8*)RExC_parse));
d6923 4
a6926 1
	    } while (isALNUM(*RExC_parse));
a6927 1

d6951 1
a6951 1
        /* NOT REACHED */
d7026 4
a7029 3
 * This implementation reserves an element at the beginning of each inversion list
 * to contain 0 when the list contains 0, and contains 1 otherwise.  The actual
 * beginning of the list is either that element if 0, or the next one if 1.
d7043 3
a7045 28
#define INVLIST_LEN_OFFSET 0	/* Number of elements in the inversion list */
#define INVLIST_ITER_OFFSET 1	/* Current iteration position */

/* This is a combination of a version and data structure type, so that one
 * being passed in can be validated to be an inversion list of the correct
 * vintage.  When the structure of the header is changed, a new random number
 * in the range 2**31-1 should be generated and the new() method changed to
 * insert that at this location.  Then, if an auxiliary program doesn't change
 * correspondingly, it will be discovered immediately */
#define INVLIST_VERSION_ID_OFFSET 2
#define INVLIST_VERSION_ID 1064334010

/* For safety, when adding new elements, remember to #undef them at the end of
 * the inversion list code section */

#define INVLIST_ZERO_OFFSET 3	/* 0 or 1; must be last element in header */
/* The UV at position ZERO contains either 0 or 1.  If 0, the inversion list
 * contains the code point U+00000, and begins here.  If 1, the inversion list
 * doesn't contain U+0000, and it begins at the next UV in the array.
 * Inverting an inversion list consists of adding or removing the 0 at the
 * beginning of it.  By reserving a space for that 0, inversion can be made
 * very fast */

#define HEADER_LENGTH (INVLIST_ZERO_OFFSET + 1)

/* Internally things are UVs */
#define TO_INTERNAL_SIZE(x) ((x + HEADER_LENGTH) * sizeof(UV))
#define FROM_INTERNAL_SIZE(x) ((x / sizeof(UV)) - HEADER_LENGTH)
d7065 1
a7065 1
    assert(! *get_invlist_len_addr(invlist));
d7083 1
a7083 1
    assert(*get_invlist_len_addr(invlist));
a7093 22
PERL_STATIC_INLINE UV*
S_get_invlist_len_addr(pTHX_ SV* invlist)
{
    /* Return the address of the UV that contains the current number
     * of used elements in the inversion list */

    PERL_ARGS_ASSERT_GET_INVLIST_LEN_ADDR;

    return (UV *) (SvPVX(invlist) + (INVLIST_LEN_OFFSET * sizeof (UV)));
}

PERL_STATIC_INLINE UV
S_invlist_len(pTHX_ SV* const invlist)
{
    /* Returns the current number of elements stored in the inversion list's
     * array */

    PERL_ARGS_ASSERT_INVLIST_LEN;

    return *get_invlist_len_addr(invlist);
}

d7101 1
a7101 1
    *get_invlist_len_addr(invlist) = len;
d7121 33
d7162 3
a7164 1
    return FROM_INTERNAL_SIZE(SvLEN(invlist));
d7206 1
d7208 2
a7209 2
#if HEADER_LENGTH != 4
#   error Need to regenerate VERSION_ID by running perl -E 'say int(rand 2**31-1)', and then changing the #if to the new length
d7231 1
a7231 1
    SvCUR_set(invlist, TO_INTERNAL_SIZE(invlist_len(invlist)));
d7237 7
a7267 5
/* An element is in an inversion list iff its index is even numbered: 0, 2, 4,
 * etc */
#define ELEMENT_RANGE_MATCHES_INVLIST(i) (! ((i) & 1))
#define PREV_RANGE_MATCHES_INVLIST(i) (! ELEMENT_RANGE_MATCHES_INVLIST(i))

d7279 1
a7279 1
    UV len = invlist_len(invlist);
d7351 2
a7352 2
STATIC IV
S_invlist_search(pTHX_ SV* const invlist, const UV cp)
d7360 4
a7363 2
    IV high = invlist_len(invlist);
    const UV * const array = invlist_array(invlist);
d7365 1
a7365 1
    PERL_ARGS_ASSERT_INVLIST_SEARCH;
d7367 2
a7368 3
    /* If list is empty or the code point is before the first element, return
     * failure. */
    if (high == 0 || cp < array[0]) {
d7372 40
d7414 2
a7415 1
     * The loop below converges on the i+1. */
d7417 3
a7419 2
	IV mid = (low + high) / 2;
	if (array[mid] <= cp) {
d7433 4
a7436 1
    return high - 1;
d7450 1
a7450 1
    const IV len = invlist_len(invlist);
d7463 1
a7463 1
    i = invlist_search(invlist, start);
d7482 9
a7490 1
                return;
d7507 2
a7531 1

d7536 1
a7536 1
     * should be defined upon input, and if it points to one of the two lists,
d7580 1
a7580 1
    if (a == NULL || ((len_a = invlist_len(a)) == 0)) {
d7583 1
a7583 1
                SvREFCNT_dec(a);
d7594 1
a7594 1
    else if ((len_b = invlist_len(b)) == 0) {
d7596 1
a7596 1
	    SvREFCNT_dec(b);
d7603 1
a7603 1
                SvREFCNT_dec(a);
d7678 1
a7678 1
	    cp= array_b[i_b++];
d7735 1
a7735 1
    if (len_u != invlist_len(u)) {
a7756 5
    /*  We may be removing a reference to one of the inputs */
    if (a == *output || b == *output) {
	SvREFCNT_dec(*output);
    }

d7762 6
d7776 1
a7776 1
     * should be defined upon input, and if it points to one of the two lists,
d7815 2
a7816 2
    len_a = invlist_len(a);
    if ((len_a == 0) || ((len_b = invlist_len(b)) == 0)) {
d7828 1
a7828 1
                    SvREFCNT_dec(b);
d7838 1
a7838 1
	    SvREFCNT_dec(a);
d7841 1
a7841 1
	    SvREFCNT_dec(b);
d7962 1
a7962 1
    if (len_r != invlist_len(r)) {
a7978 5
    /*  We may be removing a reference to one of the inputs */
    if (a == *i || b == *i) {
	SvREFCNT_dec(*i);
    }

d7984 6
d8011 1
a8011 1
	len = invlist_len(invlist);
d8014 2
a8015 1
    /* If comes after the final entry, can just append it to the end */
d8017 2
a8018 2
	|| start >= invlist_array(invlist)
				    [invlist_len(invlist) - 1])
d8032 1
a8032 1
    SvREFCNT_dec(range_invlist);
d8052 1
a8052 1
    UV* len_pos = get_invlist_len_addr(invlist);
d8056 2
d8091 1
a8091 1
    len = invlist_len(invlist);
d8123 1
a8123 1
    SV* new_invlist = _new_invlist(invlist_len(invlist) + 1);
d8163 16
d8190 1
a8190 1
    UV len = invlist_len(invlist);
d8196 1
a8196 1
	*pos = UV_MAX;	/* Force iternit() to be required next time */
d8214 38
d8265 2
d8285 1
a8285 1
#if 0
d8287 1
a8287 1
S_invlist_dump(pTHX_ SV* const invlist, const char * const header)
d8294 2
d8299 5
d8309 4
d8314 1
a8314 1
	    PerlIO_printf(Perl_debug_log, "0x%04"UVXf" .. 0x%04"UVXf"\n", start, end);
d8320 71
d8399 1
d8403 193
d8612 5
d8619 4
a8622 1
    /* paren: Parenthesized? 0=top, 1=(, inside: changed to letter. */
d8625 5
a8629 5
    register regnode *ret;		/* Will be the head of the group. */
    register regnode *br;
    register regnode *lastbr;
    register regnode *ender = NULL;
    register I32 parno = 0;
a8636 9
    /* for (?g), (?gc), and (?o) warnings; warning
       about (?c) will warn about (?g) -- japhy    */

#define WASTED_O  0x01
#define WASTED_G  0x02
#define WASTED_C  0x04
#define WASTED_GC (0x02|0x04)
    I32 wastedflags = 0x00;

d8650 7
d8664 4
d8769 3
a8771 1
            bool has_use_defaults = FALSE;
d8804 1
a8804 1
				     : (MORE_ASCII_RESTRICTED)
d8897 1
a8897 1
                            SvREFCNT_dec(svname);
d8933 6
a8938 2
	    case '#':           /* (?#...) */
		while (*RExC_parse && *RExC_parse != ')')
d8965 1
a8965 1
                /* NOT REACHED */
d9035 1
a9035 1
            /* NOT REACHED */
a9048 1
		I32 count = 1;
d9050 1
a9050 2
		char c;
		char *s = RExC_parse;
d9053 26
a9078 5
		RExC_seen |= REG_SEEN_EVAL;
		while (count && (c = *RExC_parse)) {
		    if (c == '\\') {
			if (RExC_parse[1])
			    RExC_parse++;
a9079 41
		    else if (c == '{')
			count++;
		    else if (c == '}')
			count--;
		    RExC_parse++;
		}
		if (*RExC_parse != ')') {
		    RExC_parse = s;
		    vFAIL("Sequence (?{...}) not terminated or not {}-balanced");
		}
		if (!SIZE_ONLY) {
		    PAD *pad;
		    OP_4tree *sop, *rop;
		    SV * const sv = newSVpvn(s, RExC_parse - 1 - s);

		    ENTER;
		    Perl_save_re_context(aTHX);
		    rop = Perl_sv_compile_2op_is_broken(aTHX_ sv, &sop, "re", &pad);
		    sop->op_private |= OPpREFCOUNTED;
		    /* re_dup will OpREFCNT_inc */
		    OpREFCNT_set(sop, 1);
		    LEAVE;

		    n = add_data(pRExC_state, 3, "nop");
		    RExC_rxi->data->data[n] = (void*)rop;
		    RExC_rxi->data->data[n+1] = (void*)sop;
		    RExC_rxi->data->data[n+2] = (void*)pad;
		    SvREFCNT_dec(sv);
		}
		else {						/* First pass */
		    if (PL_reginterp_cnt < ++RExC_seen_evals
			&& IN_PERL_RUNTIME)
			/* No compiled RE interpolated, has runtime
			   components ===> unsafe.  */
			FAIL("Eval-group not allowed at runtime, use re 'eval'");
		    if (PL_tainting && PL_tainted)
			FAIL("Eval-group in insecure regular expression");
#if PERL_VERSION > 8
		    if (IN_PERL_COMPILETIME)
			PL_cv_has_eval = 1;
#endif
d9081 2
a9083 1
		nextchar(pRExC_state);
d9085 1
d9087 2
a9088 1
		    if (!SIZE_ONLY)
d9090 4
a9093 1
                    REGTAIL(pRExC_state, ret, reganode(pRExC_state, EVAL, n));
d9110 1
d9115 7
a9121 1
                        REGTAIL(pRExC_state, ret, reg(pRExC_state, 1, &flag,depth+1));
d9189 8
a9196 3
		    if (br == NULL)
			br = reganode(pRExC_state, LONGJMP, 0);
		    else
d9205 8
a9212 1
                        regbranch(pRExC_state, &flags, 1,depth+1);
d9239 3
d9246 1
a9246 9
            case DEFAULT_PAT_MOD:   /* Use default flags with the exceptions
				       that follow */
                has_use_defaults = TRUE;
                STD_PMMOD_FLAGS_CLEAR(&RExC_flags);
		set_regex_charset(&RExC_flags, (RExC_utf8 || RExC_uni_semantics)
						? REGEX_UNICODE_CHARSET
						: REGEX_DEPENDS_CHARSET);
                goto parse_flags;
	    default:
d9248 12
a9259 172
	        parse_flags:      /* (?i) */  
	    {
                U32 posflags = 0, negflags = 0;
	        U32 *flagsp = &posflags;
                char has_charset_modifier = '\0';
		regex_charset cs = get_regex_charset(RExC_flags);
		if (cs == REGEX_DEPENDS_CHARSET
		    && (RExC_utf8 || RExC_uni_semantics))
		{
		    cs = REGEX_UNICODE_CHARSET;
		}

		while (*RExC_parse) {
		    /* && strchr("iogcmsx", *RExC_parse) */
		    /* (?g), (?gc) and (?o) are useless here
		       and must be globally applied -- japhy */
                    switch (*RExC_parse) {
	            CASE_STD_PMMOD_FLAGS_PARSE_SET(flagsp);
                    case LOCALE_PAT_MOD:
                        if (has_charset_modifier) {
			    goto excess_modifier;
			}
			else if (flagsp == &negflags) {
                            goto neg_modifier;
                        }
			cs = REGEX_LOCALE_CHARSET;
                        has_charset_modifier = LOCALE_PAT_MOD;
			RExC_contains_locale = 1;
                        break;
                    case UNICODE_PAT_MOD:
                        if (has_charset_modifier) {
			    goto excess_modifier;
			}
			else if (flagsp == &negflags) {
                            goto neg_modifier;
                        }
			cs = REGEX_UNICODE_CHARSET;
                        has_charset_modifier = UNICODE_PAT_MOD;
                        break;
                    case ASCII_RESTRICT_PAT_MOD:
                        if (flagsp == &negflags) {
                            goto neg_modifier;
                        }
                        if (has_charset_modifier) {
                            if (cs != REGEX_ASCII_RESTRICTED_CHARSET) {
                                goto excess_modifier;
                            }
			    /* Doubled modifier implies more restricted */
                            cs = REGEX_ASCII_MORE_RESTRICTED_CHARSET;
                        }
			else {
			    cs = REGEX_ASCII_RESTRICTED_CHARSET;
			}
                        has_charset_modifier = ASCII_RESTRICT_PAT_MOD;
                        break;
                    case DEPENDS_PAT_MOD:
                        if (has_use_defaults) {
                            goto fail_modifiers;
			}
			else if (flagsp == &negflags) {
                            goto neg_modifier;
			}
			else if (has_charset_modifier) {
			    goto excess_modifier;
                        }

			/* The dual charset means unicode semantics if the
			 * pattern (or target, not known until runtime) are
			 * utf8, or something in the pattern indicates unicode
			 * semantics */
			cs = (RExC_utf8 || RExC_uni_semantics)
			     ? REGEX_UNICODE_CHARSET
			     : REGEX_DEPENDS_CHARSET;
                        has_charset_modifier = DEPENDS_PAT_MOD;
                        break;
		    excess_modifier:
			RExC_parse++;
			if (has_charset_modifier == ASCII_RESTRICT_PAT_MOD) {
			    vFAIL2("Regexp modifier \"%c\" may appear a maximum of twice", ASCII_RESTRICT_PAT_MOD);
			}
			else if (has_charset_modifier == *(RExC_parse - 1)) {
			    vFAIL2("Regexp modifier \"%c\" may not appear twice", *(RExC_parse - 1));
			}
			else {
			    vFAIL3("Regexp modifiers \"%c\" and \"%c\" are mutually exclusive", has_charset_modifier, *(RExC_parse - 1));
			}
			/*NOTREACHED*/
		    neg_modifier:
			RExC_parse++;
			vFAIL2("Regexp modifier \"%c\" may not appear after the \"-\"", *(RExC_parse - 1));
			/*NOTREACHED*/
                    case ONCE_PAT_MOD: /* 'o' */
                    case GLOBAL_PAT_MOD: /* 'g' */
			if (SIZE_ONLY && ckWARN(WARN_REGEXP)) {
			    const I32 wflagbit = *RExC_parse == 'o' ? WASTED_O : WASTED_G;
			    if (! (wastedflags & wflagbit) ) {
				wastedflags |= wflagbit;
				vWARN5(
				    RExC_parse + 1,
				    "Useless (%s%c) - %suse /%c modifier",
				    flagsp == &negflags ? "?-" : "?",
				    *RExC_parse,
				    flagsp == &negflags ? "don't " : "",
				    *RExC_parse
				);
			    }
			}
			break;
		        
		    case CONTINUE_PAT_MOD: /* 'c' */
			if (SIZE_ONLY && ckWARN(WARN_REGEXP)) {
			    if (! (wastedflags & WASTED_C) ) {
				wastedflags |= WASTED_GC;
				vWARN3(
				    RExC_parse + 1,
				    "Useless (%sc) - %suse /gc modifier",
				    flagsp == &negflags ? "?-" : "?",
				    flagsp == &negflags ? "don't " : ""
				);
			    }
			}
			break;
	            case KEEPCOPY_PAT_MOD: /* 'p' */
                        if (flagsp == &negflags) {
                            if (SIZE_ONLY)
                                ckWARNreg(RExC_parse + 1,"Useless use of (?-p)");
                        } else {
                            *flagsp |= RXf_PMf_KEEPCOPY;
                        }
	                break;
                    case '-':
                        /* A flag is a default iff it is following a minus, so
                         * if there is a minus, it means will be trying to
                         * re-specify a default which is an error */
                        if (has_use_defaults || flagsp == &negflags) {
            fail_modifiers:
                            RExC_parse++;
		            vFAIL3("Sequence (%.*s...) not recognized", RExC_parse-seqstart, seqstart);
		            /*NOTREACHED*/
		        }
			flagsp = &negflags;
		        wastedflags = 0;  /* reset so (?g-c) warns twice */
		        break;
                    case ':':
		        paren = ':';
		        /*FALLTHROUGH*/
                    case ')':
                        RExC_flags |= posflags;
                        RExC_flags &= ~negflags;
			set_regex_charset(&RExC_flags, cs);
                        if (paren != ':') {
                            oregflags |= posflags;
                            oregflags &= ~negflags;
			    set_regex_charset(&oregflags, cs);
                        }
                        nextchar(pRExC_state);
		        if (paren != ':') {
		            *flagp = TRYAGAIN;
		            return NULL;
		        } else {
                            ret = NULL;
		            goto parse_rest;
		        }
		        /*NOTREACHED*/
                    default:
		        RExC_parse++;
		        vFAIL3("Sequence (%.*s...) not recognized", RExC_parse-seqstart, seqstart);
		        /*NOTREACHED*/
                    }                           
		    ++RExC_parse;
		}
	    }} /* one for the default block, one for the switch */
d9294 7
a9300 2
    if (br == NULL)
	return(NULL);
d9339 7
a9345 2
	if (br == NULL)
	    return(NULL);
d9357 1
a9357 1
	case 1:
d9387 14
d9404 1
d9413 2
d9418 4
d9424 27
d9474 2
a9475 1
	RExC_flags = oregflags;
d9488 1
a9488 1
	/* NOTREACHED */
d9503 3
d9511 3
a9513 3
    register regnode *ret;
    register regnode *chain = NULL;
    register regnode *latest;
d9545 5
a9549 1
	    return(NULL);
d9583 5
d9593 3
a9595 3
    register regnode *ret;
    register char op;
    register char *next;
d9604 4
d9616 4
a9619 2
	if (flags & TRYAGAIN)
	    *flagp |= TRYAGAIN;
d9625 1
a9625 1
    if (op == '{' && regcurly(RExC_parse)) {
d9656 17
a9709 2
	    if (max < min)
		vFAIL("Can't do {n,m} with n > m");
d9771 1
d9776 1
d9807 5
a9811 2

/* reg_namedseq(pRExC_state,UVp, UV depth)
d9813 5
a9817 4
   This is expected to be called by a parser routine that has 
   recognized '\N' and needs to handle the rest. RExC_parse is
   expected to point at the first char following the N at the time
   of the call.
d9819 1
a9819 1
   The \N may be inside (indicated by valuep not being NULL) or outside a
d9824 1
a9824 1
   attempted to decide which, and in the case of a named sequence converted it
d9828 5
a9832 4
   attempt to determine this nor expand those.  The net effect is that if the
   beginning of the passed-in pattern isn't '{U+' or there is no '}', it
   signals that this \N occurrence means to match a non-newline.
   
a9835 15
   
   If valuep is non-null then it is assumed that we are parsing inside 
   of a charclass definition and the first codepoint in the resolved
   string is returned via *valuep and the routine will return NULL. 
   In this mode if a multichar string is returned from the charnames 
   handler, a warning will be issued, and only the first char in the 
   sequence will be examined. If the string returned is zero length
   then the value of *valuep is undefined and NON-NULL will 
   be returned to indicate failure. (This will NOT be a valid pointer 
   to a regnode.)
   
   If valuep is null then it is assumed that we are parsing normal text and a
   new EXACT node is inserted into the program containing the resolved string,
   and a pointer to the new node is returned.  But if the string is zero length
   a NOTHING node is emitted instead.
d9837 20
a9856 2
   On success RExC_parse is set to the char following the endbrace.
   Parsing failures will generate a fatal error via vFAIL(...)
d9858 1
a9858 3
STATIC regnode *
S_reg_namedseq(pTHX_ RExC_state_t *pRExC_state, UV *valuep, I32 *flagp, U32 depth)
{
a9859 1
    regnode *ret = NULL;
d9861 4
d9868 1
a9868 1
    PERL_ARGS_ASSERT_REG_NAMEDSEQ;
d9872 2
d9879 1
a9879 1
   
d9882 1
a9882 1
    if (*p != '{' || regcurly(p)) {
d9884 1
a9884 1
	if (valuep) {
d9886 5
a9890 2
	    vFAIL("\\N in a character class must be a named character: \\N{...}");
	}
d9892 1
a9892 1
	ret = reg_node(pRExC_state, REG_ANY);
d9896 2
a9897 2
        Set_Node_Length(ret, 1); /* MJD */
	return ret;
d9900 1
a9900 1
    /* Here, we have decided it should be a named sequence */
d9922 16
a9937 3
	if (! valuep) {
	    RExC_parse = endbrace + 1;  
	    return reg_node(pRExC_state,NOTHING);
d9939 5
a9943 9

	if (SIZE_ONLY) {
	    ckWARNreg(RExC_parse,
		    "Ignoring zero length \\N{} in character class"
	    );
	    RExC_parse = endbrace + 1;  
	}
	*valuep = 0;
	return (regnode *) &RExC_parse; /* Invalid regnode pointer */
d9946 1
a9946 1
    REQUIRE_UTF8;	/* named sequences imply Unicode semantics */
d9949 9
a9957 3
    if (valuep) {   /* In a bracketed char class */
	/* We only pay attention to the first char of 
	multichar strings being returned. I kinda wonder
d9963 2
a9964 2
	STRLEN length_of_hex;
	I32 flags = PERL_SCAN_ALLOW_UNDERSCORES
a9966 5
    
	char * endchar = RExC_parse + strcspn(RExC_parse, ".}");
	if (endchar < endbrace) {
	    ckWARNreg(endchar, "Using just the first character returned by \\N{} in character class");
	}
d9968 1
a9968 2
	length_of_hex = (STRLEN)(endchar - RExC_parse);
	*valuep = grok_hex(RExC_parse, &length_of_hex, &flags, NULL);
d9980 3
a9982 1
	    if (RExC_parse >= endchar) RExC_parse = endchar;
d9984 11
a9994 1
	}    
d9996 3
a9998 2
	RExC_parse = endbrace + 1;
	if (endchar == endbrace) return NULL;
d10000 5
a10004 1
        ret = (regnode *) &RExC_parse;	/* Invalid regnode pointer */
d10006 1
a10006 1
    else {	/* Not a char class */
a10018 2
	char *endchar;	    /* Points to '.' or '}' ending cur char in the input
			       stream */
d10020 1
a10023 4
	    /* Code points are separated by dots.  If none, there is only one
	     * code point, and is terminated by the brace */
	    endchar = RExC_parse + strcspn(RExC_parse, ".}");

d10031 1
d10046 9
a10054 1
	ret = reg(pRExC_state, 1, flagp, depth+1);
d10060 1
a10060 1
	nextchar(pRExC_state);
d10063 1
a10063 1
    return ret;
d10100 102
d10218 40
a10257 2
   and special, and in the case of \10 and friends can either, depending
   on context. Specifically there are two separate switches for handling
d10261 6
d10273 2
a10274 2
    register regnode *ret = NULL;
    I32 flags;
d10277 2
d10280 3
a10283 1
    *flagp = WORST;		/* Tentatively. */
d10325 5
a10329 1
        ret = regclass(pRExC_state,depth+1);
d10334 6
a10340 1
	*flagp |= HASWIDTH|SIMPLE;
d10346 1
a10346 1
        ret = reg(pRExC_state, 1, &flags,depth+1);
d10356 5
a10360 1
		return(NULL);
d10374 1
a10374 1
	if (!regcurly(RExC_parse)) {
d10399 1
d10440 4
d10445 3
a10447 41
	    switch (get_regex_charset(RExC_flags)) {
		case REGEX_LOCALE_CHARSET:
		    op = ALNUML;
		    break;
		case REGEX_UNICODE_CHARSET:
		    op = ALNUMU;
		    break;
		case REGEX_ASCII_RESTRICTED_CHARSET:
		case REGEX_ASCII_MORE_RESTRICTED_CHARSET:
		    op = ALNUMA;
		    break;
		case REGEX_DEPENDS_CHARSET:
		    op = ALNUM;
		    break;
		default:
		    goto bad_charset;
            }
	    ret = reg_node(pRExC_state, op);
	    *flagp |= HASWIDTH|SIMPLE;
	    goto finish_meta_pat;
	case 'W':
	    switch (get_regex_charset(RExC_flags)) {
		case REGEX_LOCALE_CHARSET:
		    op = NALNUML;
		    break;
		case REGEX_UNICODE_CHARSET:
		    op = NALNUMU;
		    break;
		case REGEX_ASCII_RESTRICTED_CHARSET:
		case REGEX_ASCII_MORE_RESTRICTED_CHARSET:
		    op = NALNUMA;
		    break;
		case REGEX_DEPENDS_CHARSET:
		    op = NALNUM;
		    break;
		default:
		    goto bad_charset;
            }
	    ret = reg_node(pRExC_state, op);
	    *flagp |= HASWIDTH|SIMPLE;
	    goto finish_meta_pat;
d10451 3
a10453 16
	    switch (get_regex_charset(RExC_flags)) {
		case REGEX_LOCALE_CHARSET:
		    op = BOUNDL;
		    break;
		case REGEX_UNICODE_CHARSET:
		    op = BOUNDU;
		    break;
		case REGEX_ASCII_RESTRICTED_CHARSET:
		case REGEX_ASCII_MORE_RESTRICTED_CHARSET:
		    op = BOUNDA;
		    break;
		case REGEX_DEPENDS_CHARSET:
		    op = BOUND;
		    break;
		default:
		    goto bad_charset;
d10459 1
a10459 1
		ckWARNregdep(RExC_parse, "\"\\b{\" is deprecated; use \"\\b\\{\" instead");
d10465 3
a10467 16
	    switch (get_regex_charset(RExC_flags)) {
		case REGEX_LOCALE_CHARSET:
		    op = NBOUNDL;
		    break;
		case REGEX_UNICODE_CHARSET:
		    op = NBOUNDU;
		    break;
		case REGEX_ASCII_RESTRICTED_CHARSET:
		case REGEX_ASCII_MORE_RESTRICTED_CHARSET:
		    op = NBOUNDA;
		    break;
		case REGEX_DEPENDS_CHARSET:
		    op = NBOUND;
		    break;
		default:
		    goto bad_charset;
d10473 1
a10473 1
		ckWARNregdep(RExC_parse, "\"\\B{\" is deprecated; use \"\\B\\{\" instead");
d10476 10
a10485 19
	case 's':
	    switch (get_regex_charset(RExC_flags)) {
		case REGEX_LOCALE_CHARSET:
		    op = SPACEL;
		    break;
		case REGEX_UNICODE_CHARSET:
		    op = SPACEU;
		    break;
		case REGEX_ASCII_RESTRICTED_CHARSET:
		case REGEX_ASCII_MORE_RESTRICTED_CHARSET:
		    op = SPACEA;
		    break;
		case REGEX_DEPENDS_CHARSET:
		    op = SPACE;
		    break;
		default:
		    goto bad_charset;
            }
	    ret = reg_node(pRExC_state, op);
d10488 17
d10506 16
a10521 16
	    switch (get_regex_charset(RExC_flags)) {
		case REGEX_LOCALE_CHARSET:
		    op = NSPACEL;
		    break;
		case REGEX_UNICODE_CHARSET:
		    op = NSPACEU;
		    break;
		case REGEX_ASCII_RESTRICTED_CHARSET:
		case REGEX_ASCII_MORE_RESTRICTED_CHARSET:
		    op = NSPACEA;
		    break;
		case REGEX_DEPENDS_CHARSET:
		    op = NSPACE;
		    break;
		default:
		    goto bad_charset;
d10523 1
d10525 2
a10526 17
	    *flagp |= HASWIDTH|SIMPLE;
	    goto finish_meta_pat;
	case 'd':
	    switch (get_regex_charset(RExC_flags)) {
		case REGEX_LOCALE_CHARSET:
		    op = DIGITL;
		    break;
		case REGEX_ASCII_RESTRICTED_CHARSET:
		case REGEX_ASCII_MORE_RESTRICTED_CHARSET:
		    op = DIGITA;
		    break;
		case REGEX_DEPENDS_CHARSET: /* No difference between these */
		case REGEX_UNICODE_CHARSET:
		    op = DIGIT;
		    break;
		default:
		    goto bad_charset;
d10528 1
a10528 1
	    ret = reg_node(pRExC_state, op);
d10530 5
a10534 42
	    goto finish_meta_pat;
	case 'D':
	    switch (get_regex_charset(RExC_flags)) {
		case REGEX_LOCALE_CHARSET:
		    op = NDIGITL;
		    break;
		case REGEX_ASCII_RESTRICTED_CHARSET:
		case REGEX_ASCII_MORE_RESTRICTED_CHARSET:
		    op = NDIGITA;
		    break;
		case REGEX_DEPENDS_CHARSET: /* No difference between these */
		case REGEX_UNICODE_CHARSET:
		    op = NDIGIT;
		    break;
		default:
		    goto bad_charset;
            }
	    ret = reg_node(pRExC_state, op);
	    *flagp |= HASWIDTH|SIMPLE;
	    goto finish_meta_pat;
	case 'R':
	    ret = reg_node(pRExC_state, LNBREAK);
	    *flagp |= HASWIDTH|SIMPLE;
	    goto finish_meta_pat;
	case 'h':
	    ret = reg_node(pRExC_state, HORIZWS);
	    *flagp |= HASWIDTH|SIMPLE;
	    goto finish_meta_pat;
	case 'H':
	    ret = reg_node(pRExC_state, NHORIZWS);
	    *flagp |= HASWIDTH|SIMPLE;
	    goto finish_meta_pat;
	case 'v':
	    ret = reg_node(pRExC_state, VERTWS);
	    *flagp |= HASWIDTH|SIMPLE;
	    goto finish_meta_pat;
	case 'V':
	    ret = reg_node(pRExC_state, NVERTWS);
	    *flagp |= HASWIDTH|SIMPLE;
         finish_meta_pat:	    
	    nextchar(pRExC_state);
            Set_Node_Length(ret, 2); /* MJD */
a10538 1
		char* const oldregxend = RExC_end;
a10542 16
		if (RExC_parse[1] == '{') {
		  /* a lovely hack--pretend we saw [\pX] instead */
		    RExC_end = strchr(RExC_parse, '}');
		    if (!RExC_end) {
		        const U8 c = (U8)*RExC_parse;
			RExC_parse += 2;
			RExC_end = oldregxend;
			vFAIL2("Missing right brace on \\%c{}", c);
		    }
		    RExC_end++;
		}
		else {
		    RExC_end = RExC_parse + 2;
		    if (RExC_end > oldregxend)
			RExC_end = oldregxend;
		}
d10545 12
a10556 1
                ret = regclass(pRExC_state,depth+1);
a10557 1
		RExC_end = oldregxend;
a10562 1
		*flagp |= HASWIDTH|SIMPLE;
d10566 10
a10575 4
            /* Handle \N and \N{NAME} here and not below because it can be
            multicharacter. join_exact() will join them up later on. 
            Also this makes sure that things like /\N{BLAH}+/ and 
            \N{BLAH} being multi char Just Happen. dmq*/
d10577 7
a10583 1
            ret= reg_namedseq(pRExC_state, NULL, flagp, depth);
d10613 1
a10613 1
				 : (MORE_ASCII_RESTRICTED)
d10663 1
d10684 1
a10684 1
				     : (MORE_ASCII_RESTRICTED)
d10728 3
a10730 3
	    register STRLEN len;
	    register UV ender;
	    register char *p;
d10732 4
a10736 1
	    U8 tmpbuf[UTF8_MAXBYTES_CASE+1], *foldbuf;
d10738 2
d10741 4
a10744 3
	    /* Is this a LATIN LOWER CASE SHARP S in an EXACTFU node?  If so,
	     * it is folded to 'ss' even if not utf8 */
	    bool is_exactfu_sharp_s;
d10747 1
a10747 8
            node_type = ((! FOLD) ? EXACT
		        : (LOC)
			  ? EXACTFL
			  : (MORE_ASCII_RESTRICTED)
			    ? EXACTFA
			    : (AT_LEAST_UNI_SEMANTICS)
			      ? EXACTFU
			      : EXACTF);
d10749 13
a10761 1
	    s = STRING(ret);
d10781 2
a10782 2
	    for (len = 0, p = RExC_parse - 1;
	         len < 127 && p < RExC_end;
d10785 1
a10785 1
		char * const oldp = p;
a10820 1
		    case 'N':             /* named char sequence */
d10838 19
a10878 1
			    STRLEN brace_len = len;
d10882 1
a10882 1
			    bool valid = grok_bslash_o(p,
a10883 1
						       &brace_len,
d10885 6
a10890 2
						       1);
			    p += brace_len;
d10896 1
a10896 4
			    else
			    {
				ender = result;
			    }
d10906 20
a10925 2
			if (*++p == '{') {
			    char* const e = strchr(p, '}');
d10927 2
a10928 3
			    if (!e) {
				RExC_parse = p + 1;
				vFAIL("Missing right brace on \\x{}");
d10930 2
a10931 8
			    else {
                                I32 flags = PERL_SCAN_ALLOW_UNDERSCORES
                                    | PERL_SCAN_DISALLOW_PREFIX;
                                STRLEN numlen = e - p - 1;
				ender = grok_hex(p + 1, &numlen, &flags, NULL);
				if (ender > 0xff)
				    REQUIRE_UTF8;
				p = e + 1;
d10933 1
a10934 9
			else {
                            I32 flags = PERL_SCAN_DISALLOW_PREFIX;
			    STRLEN numlen = 2;
			    ender = grok_hex(p, &numlen, &flags, NULL);
			    p += numlen;
			}
			if (PL_encoding && ender < 0x100)
			    goto recode_encoding;
			break;
d10940 1
a10940 1
		    case '5': case '6': case '7': case '8':case '9':
d10951 9
d10961 2
a10962 1
			else {
d10969 6
d10989 2
a10990 1
			if (!SIZE_ONLY&& isALPHA(*p)) {
d10994 1
a10994 1
			    int len = (*(p + 1) == '{') ? 2 : 1;
d10998 1
a10998 1
		    }
d11000 11
a11010 1
		default:
d11023 4
a11026 2
                is_exactfu_sharp_s = (node_type == EXACTFU
			              && ender == LATIN_SMALL_LETTER_SHARP_S);
d11029 92
a11120 60
		if ((UTF && FOLD) || is_exactfu_sharp_s) {
		    /* Prime the casefolded buffer.  Locale rules, which apply
		     * only to code points < 256, aren't known until execution,
		     * so for them, just output the original character using
                     * utf8.  If we start to fold non-UTF patterns, be sure to
                     * update join_exact() */
		    if (LOC && ender < 256) {
			if (UNI_IS_INVARIANT(ender)) {
			    *tmpbuf = (U8) ender;
			    foldlen = 1;
			} else {
			    *tmpbuf = UTF8_TWO_BYTE_HI(ender);
			    *(tmpbuf + 1) = UTF8_TWO_BYTE_LO(ender);
			    foldlen = 2;
			}
		    }
		    else if (isASCII(ender)) {	/* Note: Here can't also be LOC
						 */
			ender = toLOWER(ender);
			*tmpbuf = (U8) ender;
			foldlen = 1;
		    }
		    else if (! MORE_ASCII_RESTRICTED && ! LOC) {

			/* Locale and /aa require more selectivity about the
			 * fold, so are handled below.  Otherwise, here, just
			 * use the fold */
			ender = toFOLD_uni(ender, tmpbuf, &foldlen);
		    }
		    else {
			/* Under locale rules or /aa we are not to mix,
			 * respectively, ords < 256 or ASCII with non-.  So
			 * reject folds that mix them, using only the
			 * non-folded code point.  So do the fold to a
			 * temporary, and inspect each character in it. */
			U8 trialbuf[UTF8_MAXBYTES_CASE+1];
			U8* s = trialbuf;
			UV tmpender = toFOLD_uni(ender, trialbuf, &foldlen);
			U8* e = s + foldlen;
			bool fold_ok = TRUE;

			while (s < e) {
			    if (isASCII(*s)
				|| (LOC && (UTF8_IS_INVARIANT(*s)
					   || UTF8_IS_DOWNGRADEABLE_START(*s))))
			    {
				fold_ok = FALSE;
				break;
			    }
			    s += UTF8SKIP(s);
			}
			if (fold_ok) {
			    Copy(trialbuf, tmpbuf, foldlen, U8);
			    ender = tmpender;
			}
			else {
			    uvuni_to_utf8(tmpbuf, ender);
			    foldlen = UNISKIP(ender);
			}
		    }
d11122 9
a11130 72
		if (p < RExC_end && ISMULT2(p)) { /* Back off on ?+*. */
		    if (len)
			p = oldp;
		    else if (UTF || is_exactfu_sharp_s) {
			 if (FOLD) {
			      /* Emit all the Unicode characters. */
			      STRLEN numlen;
			      for (foldbuf = tmpbuf;
				   foldlen;
				   foldlen -= numlen) {

				   /* tmpbuf has been constructed by us, so we
				    * know it is valid utf8 */
				   ender = valid_utf8_to_uvchr(foldbuf, &numlen);
				   if (numlen > 0) {
					const STRLEN unilen = reguni(pRExC_state, ender, s);
					s       += unilen;
					len     += unilen;
					/* In EBCDIC the numlen
					 * and unilen can differ. */
					foldbuf += numlen;
					if (numlen >= foldlen)
					     break;
				   }
				   else
					break; /* "Can't happen." */
			      }
			 }
			 else {
			      const STRLEN unilen = reguni(pRExC_state, ender, s);
			      if (unilen > 0) {
				   s   += unilen;
				   len += unilen;
			      }
			 }
		    }
		    else {
			len++;
			REGC((char)ender, s++);
		    }
		    break;
		}
                if (UTF || is_exactfu_sharp_s) {
		     if (FOLD) {
		          /* Emit all the Unicode characters. */
			  STRLEN numlen;
			  for (foldbuf = tmpbuf;
			       foldlen;
			       foldlen -= numlen) {
			       ender = valid_utf8_to_uvchr(foldbuf, &numlen);
			       if (numlen > 0) {
				    const STRLEN unilen = reguni(pRExC_state, ender, s);
				    len     += unilen;
				    s       += unilen;
				    /* In EBCDIC the numlen
				     * and unilen can differ. */
				    foldbuf += numlen;
				    if (numlen >= foldlen)
					 break;
			       }
			       else
				    break;
			  }
		     }
		     else {
			  const STRLEN unilen = reguni(pRExC_state, ender, s);
			  if (unilen > 0) {
			       s   += unilen;
			       len += unilen;
			  }
		     }
		     len--;
d11134 56
d11191 115
a11305 1
	    }
d11308 17
a11333 4
	    if (len > 0)
		*flagp |= HASWIDTH;
	    if (len == 1 && UNI_IS_INVARIANT(ender))
		*flagp |= SIMPLE;
d11335 1
a11335 7
	    if (SIZE_ONLY)
		RExC_size += STR_SZ(len);
	    else {
		STR_LEN(ret) = len;
		RExC_emit += STR_SZ(len);
            }
	}
d11337 1
a11337 1
    }
a11339 5

/* Jumped to when an unrecognized character set is encountered */
bad_charset:
    Perl_croak(aTHX_ "panic: Unknown regex character set encoding: %u", get_regex_charset(RExC_flags));
    return(NULL);
d11369 34
d11413 2
a11414 2
STATIC I32
S_regpposixcc(pTHX_ RExC_state_t *pRExC_state, I32 value)
d11423 2
a11424 1
	POSIXCC(UCHARAT(RExC_parse))) {
d11430 11
a11440 1
	if (RExC_parse == RExC_end)
d11443 1
d11459 4
a11462 2
			if (memEQ(posixcc, "word", 4)) /* this is not POSIX, this is the Perl \w */
			    namedclass = complement ? ANYOF_NALNUM : ANYOF_ALNUM;
d11472 1
a11472 1
				namedclass = complement ? ANYOF_NALPHA : ANYOF_ALPHA;
d11476 1
a11476 1
				namedclass = complement ? ANYOF_NPSXSPC : ANYOF_PSXSPC;
d11480 1
a11480 1
				namedclass = complement ? ANYOF_NGRAPH : ANYOF_GRAPH;
d11484 1
a11484 1
				namedclass = complement ? ANYOF_NASCII : ANYOF_ASCII;
d11488 1
a11488 1
				namedclass = complement ? ANYOF_NBLANK : ANYOF_BLANK;
d11492 1
a11492 1
				namedclass = complement ? ANYOF_NCNTRL : ANYOF_CNTRL;
d11496 1
a11496 1
				namedclass = complement ? ANYOF_NALNUMC : ANYOF_ALNUMC;
d11500 1
a11500 1
				namedclass = complement ? ANYOF_NLOWER : ANYOF_LOWER;
d11502 1
a11502 1
				namedclass = complement ? ANYOF_NUPPER : ANYOF_UPPER;
d11506 1
a11506 1
				namedclass = complement ? ANYOF_NDIGIT : ANYOF_DIGIT;
d11508 1
a11508 1
				namedclass = complement ? ANYOF_NPRINT : ANYOF_PRINT;
d11510 1
a11510 1
				namedclass = complement ? ANYOF_NPUNCT : ANYOF_PUNCT;
d11516 1
a11516 1
			    namedclass = complement ? ANYOF_NXDIGIT : ANYOF_XDIGIT;
d11523 6
d11538 1
a11538 1
		    Simple_vFAIL3("POSIX syntax [%c %c] is reserved for future extensions", c, c);
d11543 5
d11556 2
a11557 2
STATIC void
S_checkposixcc(pTHX_ RExC_state_t *pRExC_state)
d11559 19
a11577 1
    dVAR;
d11579 1
a11579 1
    PERL_ARGS_ASSERT_CHECKPOSIXCC;
d11581 1
a11581 3
    if (POSIXCC(UCHARAT(RExC_parse))) {
	const char *s = RExC_parse;
	const char  c = *s++;
d11583 2
a11584 16
	while (isALNUM(*s))
	    s++;
	if (*s && c == *s && s[1] == ']') {
	    ckWARN3reg(s+2,
		       "POSIX syntax [%c %c] belongs inside character classes",
		       c, c);

	    /* [[=foo=]] and [[.foo.]] are still future. */
	    if (POSIXCC_NOTYET(c)) {
		/* adjust RExC_parse so the error shows after
		   the class closes */
		while (UCHARAT(RExC_parse) && UCHARAT(RExC_parse++) != ']')
		    NOOP;
		Simple_vFAIL3("POSIX syntax [%c %c] is reserved for future extensions", c, c);
	    }
	}
a11585 1
}
d11587 2
a11588 38
/* Generate the code to add a full posix character <class> to the bracketed
 * character class given by <node>.  (<node> is needed only under locale rules)
 * destlist     is the inversion list for non-locale rules that this class is
 *              to be added to
 * sourcelist   is the ASCII-range inversion list to add under /a rules
 * Xsourcelist  is the full Unicode range list to use otherwise. */
#define DO_POSIX(node, class, destlist, sourcelist, Xsourcelist)           \
    if (LOC) {                                                             \
	SV* scratch_list = NULL;                                           \
                                                                           \
        /* Set this class in the node for runtime matching */              \
        ANYOF_CLASS_SET(node, class);                                      \
                                                                           \
        /* For above Latin1 code points, we use the full Unicode range */  \
        _invlist_intersection(PL_AboveLatin1,                              \
                              Xsourcelist,                                 \
                              &scratch_list);                              \
        /* And set the output to it, adding instead if there already is an \
	 * output.  Checking if <destlist> is NULL first saves an extra    \
	 * clone.  Its reference count will be decremented at the next     \
	 * union, etc, or if this is the only instance, at the end of the  \
	 * routine */                                                      \
        if (! destlist) {                                                  \
            destlist = scratch_list;                                       \
        }                                                                  \
        else {                                                             \
            _invlist_union(destlist, scratch_list, &destlist);             \
            SvREFCNT_dec(scratch_list);                                    \
        }                                                                  \
    }                                                                      \
    else {                                                                 \
        /* For non-locale, just add it to any existing list */             \
        _invlist_union(destlist,                                           \
                       (AT_LEAST_ASCII_RESTRICTED)                         \
                           ? sourcelist                                    \
                           : Xsourcelist,                                  \
                       &destlist);                                         \
    }
d11590 2
a11591 86
/* Like DO_POSIX, but matches the complement of <sourcelist> and <Xsourcelist>.
 */
#define DO_N_POSIX(node, class, destlist, sourcelist, Xsourcelist)         \
    if (LOC) {                                                             \
        SV* scratch_list = NULL;                                           \
        ANYOF_CLASS_SET(node, class);					   \
        _invlist_subtract(PL_AboveLatin1, Xsourcelist, &scratch_list);	   \
        if (! destlist) {					           \
            destlist = scratch_list;					   \
        }                                                                  \
        else {                                                             \
            _invlist_union(destlist, scratch_list, &destlist);             \
            SvREFCNT_dec(scratch_list);                                    \
        }                                                                  \
    }                                                                      \
    else {                                                                 \
        _invlist_union_complement_2nd(destlist,                            \
                                    (AT_LEAST_ASCII_RESTRICTED)            \
                                        ? sourcelist                       \
                                        : Xsourcelist,                     \
                                    &destlist);                            \
        /* Under /d, everything in the upper half of the Latin1 range      \
         * matches this complement */                                      \
        if (DEPENDS_SEMANTICS) {                                           \
            ANYOF_FLAGS(node) |= ANYOF_NON_UTF8_LATIN1_ALL;                \
        }                                                                  \
    }

/* Generate the code to add a posix character <class> to the bracketed
 * character class given by <node>.  (<node> is needed only under locale rules)
 * destlist       is the inversion list for non-locale rules that this class is
 *                to be added to
 * sourcelist     is the ASCII-range inversion list to add under /a rules
 * l1_sourcelist  is the Latin1 range list to use otherwise.
 * Xpropertyname  is the name to add to <run_time_list> of the property to
 *                specify the code points above Latin1 that will have to be
 *                determined at run-time
 * run_time_list  is a SV* that contains text names of properties that are to
 *                be computed at run time.  This concatenates <Xpropertyname>
 *                to it, apppropriately
 * This is essentially DO_POSIX, but we know only the Latin1 values at compile
 * time */
#define DO_POSIX_LATIN1_ONLY_KNOWN(node, class, destlist, sourcelist,      \
                              l1_sourcelist, Xpropertyname, run_time_list) \
    /* If not /a matching, there are going to be code points we will have  \
     * to defer to runtime to look-up */                                   \
    if (! AT_LEAST_ASCII_RESTRICTED) {                                     \
        Perl_sv_catpvf(aTHX_ run_time_list, "+utf8::%s\n", Xpropertyname); \
    }                                                                      \
    if (LOC) {                                                             \
        ANYOF_CLASS_SET(node, class);                                      \
    }                                                                      \
    else {                                                                 \
        _invlist_union(destlist,                                           \
                       (AT_LEAST_ASCII_RESTRICTED)                         \
                           ? sourcelist                                    \
                           : l1_sourcelist,                                \
                       &destlist);                                         \
    }

/* Like DO_POSIX_LATIN1_ONLY_KNOWN, but for the complement.  A combination of
 * this and DO_N_POSIX */
#define DO_N_POSIX_LATIN1_ONLY_KNOWN(node, class, destlist, sourcelist,    \
                              l1_sourcelist, Xpropertyname, run_time_list) \
    if (AT_LEAST_ASCII_RESTRICTED) {                                       \
        _invlist_union_complement_2nd(destlist, sourcelist, &destlist);    \
    }                                                                      \
    else {                                                                 \
        Perl_sv_catpvf(aTHX_ run_time_list, "!utf8::%s\n", Xpropertyname); \
	if (LOC) {                                                         \
	    ANYOF_CLASS_SET(node, namedclass);				   \
	}                                                                  \
	else {                                                             \
            SV* scratch_list = NULL;                                       \
	    _invlist_subtract(PL_Latin1, l1_sourcelist, &scratch_list);    \
	    if (! destlist) {                                              \
		destlist = scratch_list;                                   \
	    }                                                              \
	    else {                                                         \
		_invlist_union(destlist, scratch_list, &destlist);         \
		SvREFCNT_dec(scratch_list);                                \
	    }                                                              \
	    if (DEPENDS_SEMANTICS) {                                       \
		ANYOF_FLAGS(node) |= ANYOF_NON_UTF8_LATIN1_ALL;            \
	    }                                                              \
	}                                                                  \
d11594 3
a11596 126
STATIC U8
S_set_regclass_bit_fold(pTHX_ RExC_state_t *pRExC_state, regnode* node, const U8 value, SV** invlist_ptr, AV** alternate_ptr)
{

    /* Handle the setting of folds in the bitmap for non-locale ANYOF nodes.
     * Locale folding is done at run-time, so this function should not be
     * called for nodes that are for locales.
     *
     * This function sets the bit corresponding to the fold of the input
     * 'value', if not already set.  The fold of 'f' is 'F', and the fold of
     * 'F' is 'f'.
     *
     * It also knows about the characters that are in the bitmap that have
     * folds that are matchable only outside it, and sets the appropriate lists
     * and flags.
     *
     * It returns the number of bits that actually changed from 0 to 1 */

    U8 stored = 0;
    U8 fold;

    PERL_ARGS_ASSERT_SET_REGCLASS_BIT_FOLD;

    fold = (AT_LEAST_UNI_SEMANTICS) ? PL_fold_latin1[value]
                                    : PL_fold[value];

    /* It assumes the bit for 'value' has already been set */
    if (fold != value && ! ANYOF_BITMAP_TEST(node, fold)) {
        ANYOF_BITMAP_SET(node, fold);
        stored++;
    }
    if (_HAS_NONLATIN1_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(value) && (! isASCII(value) || ! MORE_ASCII_RESTRICTED)) {
	/* Certain Latin1 characters have matches outside the bitmap.  To get
	 * here, 'value' is one of those characters.   None of these matches is
	 * valid for ASCII characters under /aa, which have been excluded by
	 * the 'if' above.  The matches fall into three categories:
	 * 1) They are singly folded-to or -from an above 255 character, as
	 *    LATIN SMALL LETTER Y WITH DIAERESIS and LATIN CAPITAL LETTER Y
	 *    WITH DIAERESIS;
	 * 2) They are part of a multi-char fold with another character in the
	 *    bitmap, only LATIN SMALL LETTER SHARP S => "ss" fits that bill;
	 * 3) They are part of a multi-char fold with a character not in the
	 *    bitmap, such as various ligatures.
	 * We aren't dealing fully with multi-char folds, except we do deal
	 * with the pattern containing a character that has a multi-char fold
	 * (not so much the inverse).
	 * For types 1) and 3), the matches only happen when the target string
	 * is utf8; that's not true for 2), and we set a flag for it.
	 *
	 * The code below adds to the passed in inversion list the single fold
	 * closures for 'value'.  The values are hard-coded here so that an
	 * innocent-looking character class, like /[ks]/i won't have to go out
	 * to disk to find the possible matches.  XXX It would be better to
	 * generate these via regen, in case a new version of the Unicode
	 * standard adds new mappings, though that is not really likely. */
	switch (value) {
	    case 'k':
	    case 'K':
		/* KELVIN SIGN */
		*invlist_ptr = add_cp_to_invlist(*invlist_ptr, 0x212A);
		break;
	    case 's':
	    case 'S':
		/* LATIN SMALL LETTER LONG S */
		*invlist_ptr = add_cp_to_invlist(*invlist_ptr, 0x017F);
		break;
	    case MICRO_SIGN:
		*invlist_ptr = add_cp_to_invlist(*invlist_ptr,
						 GREEK_SMALL_LETTER_MU);
		*invlist_ptr = add_cp_to_invlist(*invlist_ptr,
						 GREEK_CAPITAL_LETTER_MU);
		break;
	    case LATIN_CAPITAL_LETTER_A_WITH_RING_ABOVE:
	    case LATIN_SMALL_LETTER_A_WITH_RING_ABOVE:
		/* ANGSTROM SIGN */
		*invlist_ptr = add_cp_to_invlist(*invlist_ptr, 0x212B);
		if (DEPENDS_SEMANTICS) {    /* See DEPENDS comment below */
		    *invlist_ptr = add_cp_to_invlist(*invlist_ptr,
						     PL_fold_latin1[value]);
		}
		break;
	    case LATIN_SMALL_LETTER_Y_WITH_DIAERESIS:
		*invlist_ptr = add_cp_to_invlist(*invlist_ptr,
					LATIN_CAPITAL_LETTER_Y_WITH_DIAERESIS);
		break;
	    case LATIN_SMALL_LETTER_SHARP_S:
		*invlist_ptr = add_cp_to_invlist(*invlist_ptr,
					LATIN_CAPITAL_LETTER_SHARP_S);

		/* Under /a, /d, and /u, this can match the two chars "ss" */
		if (! MORE_ASCII_RESTRICTED) {
		    add_alternate(alternate_ptr, (U8 *) "ss", 2);

		    /* And under /u or /a, it can match even if the target is
		     * not utf8 */
		    if (AT_LEAST_UNI_SEMANTICS) {
			ANYOF_FLAGS(node) |= ANYOF_NONBITMAP_NON_UTF8;
		    }
		}
		break;
	    case 'F': case 'f':
	    case 'I': case 'i':
	    case 'L': case 'l':
	    case 'T': case 't':
	    case 'A': case 'a':
	    case 'H': case 'h':
	    case 'J': case 'j':
	    case 'N': case 'n':
	    case 'W': case 'w':
	    case 'Y': case 'y':
                /* These all are targets of multi-character folds from code
                 * points that require UTF8 to express, so they can't match
                 * unless the target string is in UTF-8, so no action here is
                 * necessary, as regexec.c properly handles the general case
                 * for UTF-8 matching */
		break;
	    default:
		/* Use deprecated warning to increase the chances of this
		 * being output */
		ckWARN2regdep(RExC_parse, "Perl folding rules are not up-to-date for 0x%x; please use the perlbug utility to report;", value);
		break;
	}
    }
    else if (DEPENDS_SEMANTICS
	    && ! isASCII(value)
	    && PL_fold_latin1[value] != value)
d11598 1
a11598 7
	   /* Under DEPENDS rules, non-ASCII Latin1 characters match their
	    * folds only when the target string is in UTF-8.  We add the fold
	    * here to the list of things to match outside the bitmap, which
	    * won't be looked at unless it is UTF8 (or else if something else
	    * says to look even if not utf8, but those things better not happen
	    * under DEPENDS semantics. */
	*invlist_ptr = add_cp_to_invlist(*invlist_ptr, PL_fold_latin1[value]);
d11601 6
a11606 1
    return stored;
d11609 3
a11611 3

PERL_STATIC_INLINE U8
S_set_regclass_bit(pTHX_ RExC_state_t *pRExC_state, regnode* node, const U8 value, SV** invlist_ptr, AV** alternate_ptr)
d11613 1
a11613 3
    /* This inline function sets a bit in the bitmap if not already set, and if
     * appropriate, its fold, returning the number of bits that actually
     * changed from 0 to 1 */
d11615 9
a11623 1
    U8 stored;
d11625 1
a11625 5
    PERL_ARGS_ASSERT_SET_REGCLASS_BIT;

    if (ANYOF_BITMAP_TEST(node, value)) {   /* Already set */
	return 0;
    }
d11627 1
a11627 2
    ANYOF_BITMAP_SET(node, value);
    stored = 1;
d11629 2
a11630 2
    if (FOLD && ! LOC) {	/* Locale folds aren't known until runtime */
	stored += set_regclass_bit_fold(pRExC_state, node, value, invlist_ptr, alternate_ptr);
d11632 1
d11634 8
a11641 2
    return stored;
}
d11643 33
a11675 7
STATIC void
S_add_alternate(pTHX_ AV** alternate_ptr, U8* string, STRLEN len)
{
    /* Adds input 'string' with length 'len' to the ANYOF node's unicode
     * alternate list, pointed to by 'alternate_ptr'.  This is an array of
     * the multi-character folds of characters in the node */
    SV *sv;
d11677 17
a11693 1
    PERL_ARGS_ASSERT_ADD_ALTERNATE;
d11695 23
a11717 2
    if (! *alternate_ptr) {
	*alternate_ptr = newAV();
d11719 371
a12089 3
    sv = newSVpvn_utf8((char*)string, len, TRUE);
    av_push(*alternate_ptr, sv);
    return;
d12091 1
d12093 4
a12096 6
/*
   parse a class specification and produce either an ANYOF node that
   matches the pattern or perhaps will be optimized into an EXACTish node
   instead. The node contains a bit map for the first 256 characters, with the
   corresponding bit set if that character is in the list.  For characters
   above 255, a range list is used */
d12099 34
a12132 2
S_regclass(pTHX_ RExC_state_t *pRExC_state, U32 depth)
{
d12134 4
a12137 5
    register UV nextvalue;
    register IV prevvalue = OOB_UNICODE;
    register IV range = 0;
    UV value = 0; /* XXX:dmq: needs to be referenceable (unfortunately) */
    register regnode *ret;
d12139 1
a12139 1
    IV namedclass;
a12141 1
    bool allow_full_fold = TRUE;   /* Assume wants multi-char folding */
d12146 2
d12150 2
d12153 4
d12168 1
a12168 1
    UV has_user_defined_property = 0;
d12170 8
a12177 2
    /* code points this node matches that can't be stored in the bitmap */
    SV* nonbitmap = NULL;
a12178 18
    /* The items that are to match that aren't stored in the bitmap, but are a
     * result of things that are stored there.  This is the fold closure of
     * such a character, either because it has DEPENDS semantics and shouldn't
     * be matched unless the target string is utf8, or is a code point that is
     * too large for the bit map, as for example, the fold of the MICRO SIGN is
     * above 255.  This all is solely for performance reasons.  By having this
     * code know the outside-the-bitmap folds that the bitmapped characters are
     * involved with, we don't have to go out to disk to find the list of
     * matches, unless the character class includes code points that aren't
     * storable in the bit map.  That means that a character class with an 's'
     * in it, for example, doesn't need to go out to disk to find everything
     * that matches.  A 2nd list is used so that the 'nonbitmap' list is kept
     * empty unless there is something whose fold we don't know about, and will
     * have to go out to the disk to find. */
    SV* l1_fold_invlist = NULL;

    /* List of multi-character folds that are matched by this node */
    AV* unicode_alternate  = NULL;
d12180 2
d12184 5
a12188 1
    UV stored = 0;  /* how many chars stored in the bitmap */
d12193 1
a12205 22

    if (!SIZE_ONLY) {
	ANYOF_FLAGS(ret) = 0;
    }

    if (UCHARAT(RExC_parse) == '^') {	/* Complement of range. */
	RExC_naughty++;
	RExC_parse++;
	if (!SIZE_ONLY)
	    ANYOF_FLAGS(ret) |= ANYOF_INVERT;

        /* We have decided to not allow multi-char folds in inverted character
	 * classes, due to the confusion that can happen, especially with
	 * classes that are designed for a non-Unicode world:  You have the
	 * peculiar case that:
            "s s" =~ /^[^\xDF]+$/i => Y
            "ss"  =~ /^[^\xDF]+$/i => N
         *
         * See [perl #89750] */
        allow_full_fold = FALSE;
    }

d12211 2
d12217 1
a12217 2
	ANYOF_BITMAP_ZERO(ret);
	listsv = newSVpvs("# comment\n");
d12219 1
d12222 4
a12225 1
    nextvalue = RExC_parse < RExC_end ? UCHARAT(RExC_parse) : 0;
d12227 10
a12236 2
    if (!SIZE_ONLY && POSIXCC(nextvalue))
	checkposixcc(pRExC_state);
d12238 23
a12260 1
    /* allow 1st char to be ] (allowing it to be - is dealt with later) */
d12265 13
a12277 1
    while (RExC_parse < RExC_end && UCHARAT(RExC_parse) != ']') {
d12282 2
d12298 7
a12304 4
	nextvalue = RExC_parse < RExC_end ? UCHARAT(RExC_parse) : 0;
	if (value == '[' && POSIXCC(nextvalue))
	    namedclass = regpposixcc(pRExC_state, value);
	else if (value == '\\') {
d12313 1
d12319 9
a12327 3
	    switch ((I32)value) {
	    case 'w':	namedclass = ANYOF_ALNUM;	break;
	    case 'W':	namedclass = ANYOF_NALNUM;	break;
d12343 6
a12348 2
                    UV v; /* value is register so we cant & it /grrr */
                    if (reg_namedseq(pRExC_state, &v, NULL, depth)) {
a12350 1
                    value= v; 
d12357 4
a12380 1
                    SV** invlistsvp;
d12383 1
d12387 5
a12391 1
			 value = value == 'p' ? 'P' : 'p'; /* toggle */
d12414 1
a12414 1
                        SvREFCNT_dec(swash);
d12419 2
a12420 3
                                             TRUE, /* this routine will handle
                                                      undefined properties */
                                             NULL, FALSE /* No inversion list */
d12422 1
a12422 8
                    if (   ! swash
                        || ! SvROK(swash)
                        || ! SvTYPE(SvRV(swash)) == SVt_PVHV
                        || ! (invlistsvp =
				hv_fetchs(MUTABLE_HV(SvRV(swash)),
                                "INVLIST", FALSE))
                        || ! (invlist = *invlistsvp))
		    {
d12424 1
a12424 1
                            SvREFCNT_dec(swash);
d12429 7
a12435 2
                         * property that will be available at run-time.  Add it
                         * to the list to look up then */
d12439 1
a12439 1
                        has_user_defined_property = 1;
d12443 5
a12447 1
                         * hence something that isn't utf8 */
d12455 3
a12457 7
                        SV** user_defined_svp =
                                            hv_fetchs(MUTABLE_HV(SvRV(swash)),
                                                        "USER_DEFINED", FALSE);
                        if (user_defined_svp) {
                            has_user_defined_property
                                                    |= SvUV(*user_defined_svp);
                        }
d12461 3
a12463 1
			    _invlist_union_complement_2nd(properties, invlist, &properties);
d12468 1
a12468 1
                            SvREFCNT_dec(swash);
d12478 2
a12479 1
		namedclass = ANYOF_MAX;  /* no official name, but it's named */
d12496 1
a12496 1
		    bool valid = grok_bslash_o(RExC_parse,
a12497 1
					       &numlen,
d12499 5
a12503 2
					       SIZE_ONLY);
		    RExC_parse += numlen;
d12513 13
a12525 16
		if (*RExC_parse == '{') {
                    I32 flags = PERL_SCAN_ALLOW_UNDERSCORES
                        | PERL_SCAN_DISALLOW_PREFIX;
		    char * const e = strchr(RExC_parse++, '}');
                    if (!e)
                        vFAIL("Missing right brace on \\x{}");

		    numlen = e - RExC_parse;
		    value = grok_hex(RExC_parse, &numlen, &flags, NULL);
		    RExC_parse = e + 1;
		}
		else {
                    I32 flags = PERL_SCAN_DISALLOW_PREFIX;
		    numlen = 2;
		    value = grok_hex(RExC_parse, &numlen, &flags, NULL);
		    RExC_parse += numlen;
d12538 2
a12539 2
		    numlen = 3;
		    value = grok_oct(--RExC_parse, &numlen, &flags, NULL);
d12541 18
d12567 6
a12572 2
		    if (!enc && SIZE_ONLY)
			ckWARNreg(RExC_parse,
d12574 2
d12580 12
a12591 4
		if (!SIZE_ONLY && isALNUM(value) && value != '_') {
		    ckWARN2reg(RExC_parse,
			       "Unrecognized escape \\%c in character class passed through",
			       (int)value);
d12594 2
a12595 2
	    }
	} /* end of \blah */
d12597 2
a12598 2
	else
	    literal_endpoint++;
d12601 26
a12628 18
	    /* What matches in a locale is not known until runtime, so need to
	     * (one time per class) allocate extra space to pass to regexec.
	     * The space will contain a bit for each named class that is to be
	     * matched against.  This isn't needed for \p{} and pseudo-classes,
	     * as they are not affected by locale, and hence are dealt with
	     * separately */
	    if (LOC && namedclass < ANYOF_MAX && ! need_class) {
		need_class = 1;
		if (SIZE_ONLY) {
		    RExC_size += ANYOF_CLASS_SKIP - ANYOF_SKIP;
		}
		else {
		    RExC_emit += ANYOF_CLASS_SKIP - ANYOF_SKIP;
		    ANYOF_CLASS_ZERO(ret);
		}
		ANYOF_FLAGS(ret) |= ANYOF_CLASS;
	    }

d12634 15
a12648 16
		    const int w =
			RExC_parse >= rangebegin ?
			RExC_parse - rangebegin : 0;
		    ckWARN4reg(RExC_parse,
			       "False [] range \"%*.*s\"",
			       w, w, rangebegin);

		    stored +=
                         set_regclass_bit(pRExC_state, ret, '-', &l1_fold_invlist, &unicode_alternate);
		    if (prevvalue < 256) {
			stored +=
                         set_regclass_bit(pRExC_state, ret, (U8) prevvalue, &l1_fold_invlist, &unicode_alternate);
		    }
		    else {
			nonbitmap = add_cp_to_invlist(nonbitmap, prevvalue);
		    }
d12652 1
d12655 18
a12672 1
	    if (!SIZE_ONLY) {
d12674 13
a12686 29
		/* Possible truncation here but in some 64-bit environments
		 * the compiler gets heartburn about switch on 64-bit values.
		 * A similar issue a little earlier when switching on value.
		 * --jhi */
		switch ((I32)namedclass) {
		    int i;  /* loop counter */

		case ANYOF_ALNUMC: /* C's alnum, in contrast to \w */
		    DO_POSIX_LATIN1_ONLY_KNOWN(ret, namedclass, properties,
                        PL_PosixAlnum, PL_L1PosixAlnum, "XPosixAlnum", listsv);
		    break;
		case ANYOF_NALNUMC:
		    DO_N_POSIX_LATIN1_ONLY_KNOWN(ret, namedclass, properties,
                        PL_PosixAlnum, PL_L1PosixAlnum, "XPosixAlnum", listsv);
		    break;
		case ANYOF_ALPHA:
		    DO_POSIX_LATIN1_ONLY_KNOWN(ret, namedclass, properties,
                        PL_PosixAlpha, PL_L1PosixAlpha, "XPosixAlpha", listsv);
		    break;
		case ANYOF_NALPHA:
		    DO_N_POSIX_LATIN1_ONLY_KNOWN(ret, namedclass, properties,
                        PL_PosixAlpha, PL_L1PosixAlpha, "XPosixAlpha", listsv);
		    break;
		case ANYOF_ASCII:
		    if (LOC) {
			ANYOF_CLASS_SET(ret, namedclass);
		    }
                    else {
                        _invlist_union(properties, PL_ASCII, &properties);
d12688 14
a12701 9
		    break;
		case ANYOF_NASCII:
		    if (LOC) {
			ANYOF_CLASS_SET(ret, namedclass);
		    }
                    else {
                        _invlist_union_complement_2nd(properties,
                                                    PL_ASCII, &properties);
                        if (DEPENDS_SEMANTICS) {
d12705 873
a13577 48
		    break;
		case ANYOF_BLANK:
                    DO_POSIX(ret, namedclass, properties,
                                            PL_PosixBlank, PL_XPosixBlank);
		    break;
		case ANYOF_NBLANK:
                    DO_N_POSIX(ret, namedclass, properties,
                                            PL_PosixBlank, PL_XPosixBlank);
		    break;
		case ANYOF_CNTRL:
                    DO_POSIX(ret, namedclass, properties,
                                            PL_PosixCntrl, PL_XPosixCntrl);
		    break;
		case ANYOF_NCNTRL:
                    DO_N_POSIX(ret, namedclass, properties,
                                            PL_PosixCntrl, PL_XPosixCntrl);
		    break;
		case ANYOF_DIGIT:
		    /* Ignore the compiler warning for this macro, planned to
		     * be eliminated later */
		    DO_POSIX_LATIN1_ONLY_KNOWN(ret, namedclass, properties,
                        PL_PosixDigit, PL_PosixDigit, "XPosixDigit", listsv);
		    break;
		case ANYOF_NDIGIT:
		    DO_N_POSIX_LATIN1_ONLY_KNOWN(ret, namedclass, properties,
                        PL_PosixDigit, PL_PosixDigit, "XPosixDigit", listsv);
		    break;
		case ANYOF_GRAPH:
		    DO_POSIX_LATIN1_ONLY_KNOWN(ret, namedclass, properties,
                        PL_PosixGraph, PL_L1PosixGraph, "XPosixGraph", listsv);
		    break;
		case ANYOF_NGRAPH:
		    DO_N_POSIX_LATIN1_ONLY_KNOWN(ret, namedclass, properties,
                        PL_PosixGraph, PL_L1PosixGraph, "XPosixGraph", listsv);
		    break;
		case ANYOF_HORIZWS:
		    /* NBSP matches this, and needs to be added unconditionally
		     * to the bit map as it matches even under /d, unlike all
		     * the rest of the Posix-like classes (\v doesn't have any
		     * matches in the Latin1 range, so it is unaffected.) which
		     * Otherwise, we use the nonbitmap, as /d doesn't make a
		     * difference in what these match.  It turns out that \h is
		     * just a synonym for XPosixBlank */
		    _invlist_union(nonbitmap, PL_XPosixBlank, &nonbitmap);
		    stored += set_regclass_bit(pRExC_state, ret,
					       UNI_TO_NATIVE(0xA0),
					       &l1_fold_invlist,
					       &unicode_alternate);
d13579 15
a13593 137
		    break;
		case ANYOF_NHORIZWS:
                    _invlist_union_complement_2nd(nonbitmap,
                                                 PL_XPosixBlank, &nonbitmap);
		    for (i = 128; i < 256; i++) {
			if (i == 0xA0) {
			    continue;
			}
			stored += set_regclass_bit(pRExC_state, ret,
						   UNI_TO_NATIVE(i),
						   &l1_fold_invlist,
						   &unicode_alternate);
		    }
		    break;
		case ANYOF_LOWER:
		case ANYOF_NLOWER:
                {   /* These require special handling, as they differ under
		       folding, matching Cased there (which in the ASCII range
		       is the same as Alpha */

		    SV* ascii_source;
		    SV* l1_source;
		    const char *Xname;

		    if (FOLD && ! LOC) {
			ascii_source = PL_PosixAlpha;
			l1_source = PL_L1Cased;
			Xname = "Cased";
		    }
		    else {
			ascii_source = PL_PosixLower;
			l1_source = PL_L1PosixLower;
			Xname = "XPosixLower";
		    }
		    if (namedclass == ANYOF_LOWER) {
			DO_POSIX_LATIN1_ONLY_KNOWN(ret, namedclass, properties,
                                    ascii_source, l1_source, Xname, listsv);
		    }
		    else {
			DO_N_POSIX_LATIN1_ONLY_KNOWN(ret, namedclass,
                            properties, ascii_source, l1_source, Xname, listsv);
		    }
		    break;
		}
		case ANYOF_PRINT:
		    DO_POSIX_LATIN1_ONLY_KNOWN(ret, namedclass, properties,
                        PL_PosixPrint, PL_L1PosixPrint, "XPosixPrint", listsv);
		    break;
		case ANYOF_NPRINT:
		    DO_N_POSIX_LATIN1_ONLY_KNOWN(ret, namedclass, properties,
                        PL_PosixPrint, PL_L1PosixPrint, "XPosixPrint", listsv);
		    break;
		case ANYOF_PUNCT:
		    DO_POSIX_LATIN1_ONLY_KNOWN(ret, namedclass, properties,
                        PL_PosixPunct, PL_L1PosixPunct, "XPosixPunct", listsv);
		    break;
		case ANYOF_NPUNCT:
		    DO_N_POSIX_LATIN1_ONLY_KNOWN(ret, namedclass, properties,
                        PL_PosixPunct, PL_L1PosixPunct, "XPosixPunct", listsv);
		    break;
		case ANYOF_PSXSPC:
                    DO_POSIX(ret, namedclass, properties,
                                            PL_PosixSpace, PL_XPosixSpace);
		    break;
		case ANYOF_NPSXSPC:
                    DO_N_POSIX(ret, namedclass, properties,
                                            PL_PosixSpace, PL_XPosixSpace);
		    break;
		case ANYOF_SPACE:
                    DO_POSIX(ret, namedclass, properties,
                                            PL_PerlSpace, PL_XPerlSpace);
		    break;
		case ANYOF_NSPACE:
                    DO_N_POSIX(ret, namedclass, properties,
                                            PL_PerlSpace, PL_XPerlSpace);
		    break;
		case ANYOF_UPPER:   /* Same as LOWER, above */
		case ANYOF_NUPPER:
		{
		    SV* ascii_source;
		    SV* l1_source;
		    const char *Xname;

		    if (FOLD && ! LOC) {
			ascii_source = PL_PosixAlpha;
			l1_source = PL_L1Cased;
			Xname = "Cased";
		    }
		    else {
			ascii_source = PL_PosixUpper;
			l1_source = PL_L1PosixUpper;
			Xname = "XPosixUpper";
		    }
		    if (namedclass == ANYOF_UPPER) {
			DO_POSIX_LATIN1_ONLY_KNOWN(ret, namedclass, properties,
                                    ascii_source, l1_source, Xname, listsv);
		    }
		    else {
			DO_N_POSIX_LATIN1_ONLY_KNOWN(ret, namedclass,
                        properties, ascii_source, l1_source, Xname, listsv);
		    }
		    break;
		}
		case ANYOF_ALNUM:   /* Really is 'Word' */
		    DO_POSIX_LATIN1_ONLY_KNOWN(ret, namedclass, properties,
                            PL_PosixWord, PL_L1PosixWord, "XPosixWord", listsv);
		    break;
		case ANYOF_NALNUM:
		    DO_N_POSIX_LATIN1_ONLY_KNOWN(ret, namedclass, properties,
                            PL_PosixWord, PL_L1PosixWord, "XPosixWord", listsv);
		    break;
		case ANYOF_VERTWS:
		    /* For these, we use the nonbitmap, as /d doesn't make a
		     * difference in what these match.  There would be problems
		     * if these characters had folds other than themselves, as
		     * nonbitmap is subject to folding */
		    _invlist_union(nonbitmap, PL_VertSpace, &nonbitmap);
		    break;
		case ANYOF_NVERTWS:
                    _invlist_union_complement_2nd(nonbitmap,
                                                    PL_VertSpace, &nonbitmap);
		    break;
		case ANYOF_XDIGIT:
                    DO_POSIX(ret, namedclass, properties,
                                            PL_PosixXDigit, PL_XPosixXDigit);
		    break;
		case ANYOF_NXDIGIT:
                    DO_N_POSIX(ret, namedclass, properties,
                                            PL_PosixXDigit, PL_XPosixXDigit);
		    break;
		case ANYOF_MAX:
		    /* this is to handle \p and \P */
		    break;
		default:
		    vFAIL("Invalid [::] class");
		    break;
		}
d13595 31
a13625 3
		continue;
	    }
	} /* end of namedclass \blah */
d13627 10
a13636 14
	if (range) {
	    if (prevvalue > (IV)value) /* b-a */ {
		const int w = RExC_parse - rangebegin;
		Simple_vFAIL4("Invalid [] range \"%*.*s\"", w, w, rangebegin);
		range = 0; /* not a valid range */
	    }
	}
	else {
	    prevvalue = value; /* save the beginning of the range */
	    if (RExC_parse+1 < RExC_end
		&& *RExC_parse == '-'
		&& RExC_parse[1] != ']')
	    {
		RExC_parse++;
d13638 14
a13651 18
		/* a bad range like \w-, [:word:]- ? */
		if (namedclass > OOB_NAMEDCLASS) {
		    if (ckWARN(WARN_REGEXP)) {
			const int w =
			    RExC_parse >= rangebegin ?
			    RExC_parse - rangebegin : 0;
			vWARN4(RExC_parse,
			       "False [] range \"%*.*s\"",
			       w, w, rangebegin);
		    }
		    if (!SIZE_ONLY)
			stored +=
                            set_regclass_bit(pRExC_state, ret, '-', &l1_fold_invlist, &unicode_alternate);
		} else
		    range = 1;	/* yeah, it's a range! */
		continue;	/* but do it the next time */
	    }
	}
d13653 17
a13669 5
	/* non-Latin1 code point implies unicode semantics.  Must be set in
	 * pass1 so is there for the whole of pass 2 */
	if (value > 255) {
	    RExC_uni_semantics = 1;
	}
d13671 5
a13675 40
	/* now is the next time */
	if (!SIZE_ONLY) {
	    if (prevvalue < 256) {
	        const IV ceilvalue = value < 256 ? value : 255;
		IV i;
#ifdef EBCDIC
		/* In EBCDIC [\x89-\x91] should include
		 * the \x8e but [i-j] should not. */
		if (literal_endpoint == 2 &&
		    ((isLOWER(prevvalue) && isLOWER(ceilvalue)) ||
		     (isUPPER(prevvalue) && isUPPER(ceilvalue))))
		{
		    if (isLOWER(prevvalue)) {
			for (i = prevvalue; i <= ceilvalue; i++)
			    if (isLOWER(i) && !ANYOF_BITMAP_TEST(ret,i)) {
				stored +=
                                  set_regclass_bit(pRExC_state, ret, (U8) i, &l1_fold_invlist, &unicode_alternate);
			    }
		    } else {
			for (i = prevvalue; i <= ceilvalue; i++)
			    if (isUPPER(i) && !ANYOF_BITMAP_TEST(ret,i)) {
				stored +=
                                  set_regclass_bit(pRExC_state, ret, (U8) i, &l1_fold_invlist, &unicode_alternate);
			    }
		    }
		}
		else
#endif
		      for (i = prevvalue; i <= ceilvalue; i++) {
			stored += set_regclass_bit(pRExC_state, ret, (U8) i, &l1_fold_invlist, &unicode_alternate);
	              }
	  }
	  if (value > 255) {
	    const UV prevnatvalue  = NATIVE_TO_UNI(prevvalue);
	    const UV natvalue      = NATIVE_TO_UNI(value);
	    nonbitmap = _add_range_to_invlist(nonbitmap, prevnatvalue, natvalue);
	}
#ifdef EBCDIC
	    literal_endpoint = 0;
#endif
d13678 3
a13680 1
	range = 0; /* this range (if it was one) is done now */
d13683 25
d13709 3
d13713 3
a13715 3
    if (SIZE_ONLY)
        return ret;
    /****** !SIZE_ONLY AFTER HERE *********/
d13717 9
a13725 4
    /* If folding and there are code points above 255, we calculate all
     * characters that could fold to or from the ones already on the list */
    if (FOLD && nonbitmap) {
	UV start, end;	/* End points of code point ranges */
d13727 8
a13734 1
	SV* fold_intersection = NULL;
d13736 24
a13759 35
	/* This is a list of all the characters that participate in folds
	    * (except marks, etc in multi-char folds */
	if (! PL_utf8_foldable) {
	    SV* swash = swash_init("utf8", "Cased", &PL_sv_undef, 1, 0);
	    PL_utf8_foldable = _swash_to_invlist(swash);
            SvREFCNT_dec(swash);
	}

	/* This is a hash that for a particular fold gives all characters
	    * that are involved in it */
	if (! PL_utf8_foldclosures) {

	    /* If we were unable to find any folds, then we likely won't be
	     * able to find the closures.  So just create an empty list.
	     * Folding will effectively be restricted to the non-Unicode rules
	     * hard-coded into Perl.  (This case happens legitimately during
	     * compilation of Perl itself before the Unicode tables are
	     * generated) */
	    if (invlist_len(PL_utf8_foldable) == 0) {
		PL_utf8_foldclosures = newHV();
	    } else {
		/* If the folds haven't been read in, call a fold function
		    * to force that */
		if (! PL_utf8_tofold) {
		    U8 dummy[UTF8_MAXBYTES+1];
		    STRLEN dummy_len;

		    /* This particular string is above \xff in both UTF-8 and
		     * UTFEBCDIC */
		    to_utf8_fold((U8*) "\xC8\x80", dummy, &dummy_len);
		    assert(PL_utf8_tofold); /* Verify that worked */
		}
		PL_utf8_foldclosures = _swash_inversion_hash(PL_utf8_tofold);
	    }
	}
d13761 2
a13762 5
	/* Only the characters in this class that participate in folds need be
	 * checked.  Get the intersection of this class and all the possible
	 * characters that are foldable.  This can quickly narrow down a large
	 * class */
	_invlist_intersection(PL_utf8_foldable, nonbitmap, &fold_intersection);
d13764 16
a13779 4
	/* Now look at the foldable characters in this class individually */
	invlist_iterinit(fold_intersection);
	while (invlist_iternext(fold_intersection, &start, &end)) {
	    UV j;
d13781 1
a13781 2
	    /* Look at every character in the range */
	    for (j = start; j <= end; j++) {
d13783 4
a13786 5
		/* Get its fold */
		U8 foldbuf[UTF8_MAXBYTES_CASE+1];
		STRLEN foldlen;
		const UV f =
                    _to_uni_fold_flags(j, foldbuf, &foldlen, allow_full_fold);
d13788 6
a13793 1
		if (foldlen > (STRLEN)UNISKIP(f)) {
d13795 24
a13818 40
		    /* Any multicharacter foldings (disallowed in lookbehind
		     * patterns) require the following transform: [ABCDEF] ->
		     * (?:[ABCabcDEFd]|pq|rst) where E folds into "pq" and F
		     * folds into "rst", all other characters fold to single
		     * characters.  We save away these multicharacter foldings,
		     * to be later saved as part of the additional "s" data. */
		    if (! RExC_in_lookbehind) {
			U8* loc = foldbuf;
			U8* e = foldbuf + foldlen;

			/* If any of the folded characters of this are in the
			 * Latin1 range, tell the regex engine that this can
			 * match a non-utf8 target string.  The only multi-byte
			 * fold whose source is in the Latin1 range (U+00DF)
			 * applies only when the target string is utf8, or
			 * under unicode rules */
			if (j > 255 || AT_LEAST_UNI_SEMANTICS) {
			    while (loc < e) {

				/* Can't mix ascii with non- under /aa */
				if (MORE_ASCII_RESTRICTED
				    && (isASCII(*loc) != isASCII(j)))
				{
				    goto end_multi_fold;
				}
				if (UTF8_IS_INVARIANT(*loc)
				    || UTF8_IS_DOWNGRADEABLE_START(*loc))
				{
                                    /* Can't mix above and below 256 under LOC
                                     */
				    if (LOC) {
					goto end_multi_fold;
				    }
				    ANYOF_FLAGS(ret)
					    |= ANYOF_NONBITMAP_NON_UTF8;
				    break;
				}
				loc += UTF8SKIP(loc);
			    }
			}
d13820 24
a13843 3
			add_alternate(&unicode_alternate, foldbuf, foldlen);
		    end_multi_fold: ;
		    }
d13845 3
a13847 33
		    /* This is special-cased, as it is the only letter which
		     * has both a multi-fold and single-fold in Latin1.  All
		     * the other chars that have single and multi-folds are
		     * always in utf8, and the utf8 folding algorithm catches
		     * them */
		    if (! LOC && j == LATIN_CAPITAL_LETTER_SHARP_S) {
			stored += set_regclass_bit(pRExC_state,
					ret,
					LATIN_SMALL_LETTER_SHARP_S,
					&l1_fold_invlist, &unicode_alternate);
		    }
		}
		else {
		    /* Single character fold.  Add everything in its fold
		     * closure to the list that this node should match */
		    SV** listp;

		    /* The fold closures data structure is a hash with the keys
		     * being every character that is folded to, like 'k', and
		     * the values each an array of everything that folds to its
		     * key.  e.g. [ 'k', 'K', KELVIN_SIGN ] */
		    if ((listp = hv_fetch(PL_utf8_foldclosures,
				    (char *) foldbuf, foldlen, FALSE)))
		    {
			AV* list = (AV*) *listp;
			IV k;
			for (k = 0; k <= av_len(list); k++) {
			    SV** c_p = av_fetch(list, k, FALSE);
			    UV c;
			    if (c_p == NULL) {
				Perl_croak(aTHX_ "panic: invalid PL_utf8_foldclosures structure");
			    }
			    c = SvUV(*c_p);
d13849 1
a13849 9
			    /* /aa doesn't allow folds between ASCII and non-;
			     * /l doesn't allow them between above and below
			     * 256 */
			    if ((MORE_ASCII_RESTRICTED
				 && (isASCII(c) != isASCII(j)))
				    || (LOC && ((c < 256) != (j < 256))))
			    {
				continue;
			    }
d13851 1
a13851 22
			    if (c < 256 && AT_LEAST_UNI_SEMANTICS) {
				stored += set_regclass_bit(pRExC_state,
					ret,
					(U8) c,
					&l1_fold_invlist, &unicode_alternate);
			    }
				/* It may be that the code point is already in
				 * this range or already in the bitmap, in
				 * which case we need do nothing */
			    else if ((c < start || c > end)
					&& (c > 255
					    || ! ANYOF_BITMAP_TEST(ret, c)))
			    {
				nonbitmap = add_cp_to_invlist(nonbitmap, c);
			    }
			}
		    }
		}
	    }
	}
	SvREFCNT_dec(fold_intersection);
    }
d13853 3
a13855 10
    /* Combine the two lists into one. */
    if (l1_fold_invlist) {
	if (nonbitmap) {
	    _invlist_union(nonbitmap, l1_fold_invlist, &nonbitmap);
	    SvREFCNT_dec(l1_fold_invlist);
	}
	else {
	    nonbitmap = l1_fold_invlist;
	}
    }
d13857 3
a13859 11
    /* And combine the result (if any) with any inversion list from properties.
     * The lists are kept separate up to now because we don't want to fold the
     * properties */
    if (properties) {
	if (nonbitmap) {
	    _invlist_union(nonbitmap, properties, &nonbitmap);
	    SvREFCNT_dec(properties);
	}
	else {
	    nonbitmap = properties;
	}
d13862 2
a13863 2
    /* Here, <nonbitmap> contains all the code points we can determine at
     * compile time that we haven't put into the bitmap.  Go through it, and
d13865 4
a13868 6
     * <nonbitmap> */
    if (nonbitmap) {

	/* Above-ASCII code points in /d have to stay in <nonbitmap>, as they
	 * possibly only should match when the target string is UTF-8 */
	UV max_cp_to_set = (DEPENDS_SEMANTICS) ? 127 : 255;
d13875 3
a13877 3
	/* Start looking through <nonbitmap> */
	invlist_iterinit(nonbitmap);
	while (invlist_iternext(nonbitmap, &start, &end)) {
d13881 4
d13886 1
a13886 1
	    if (start > max_cp_to_set) {
d13893 1
a13893 1
	    high = (end < max_cp_to_set) ? end : max_cp_to_set;
a13896 1
		    stored++;
d13902 1
d13905 1
a13905 1
         * <nonbitmap> */
d13907 1
a13907 5
	    _invlist_subtract(nonbitmap,
		              (DEPENDS_SEMANTICS)
			        ? PL_ASCII
			        : PL_Latin1,
                              &nonbitmap);
d13911 3
a13913 118
	if (invlist_len(nonbitmap) == 0) {
	    SvREFCNT_dec(nonbitmap);
	    nonbitmap = NULL;
	}
    }

    /* Here, we have calculated what code points should be in the character
     * class.  <nonbitmap> does not overlap the bitmap except possibly in the
     * case of DEPENDS rules.
     *
     * Now we can see about various optimizations.  Fold calculation (which we
     * did above) needs to take place before inversion.  Otherwise /[^k]/i
     * would invert to include K, which under /i would match k, which it
     * shouldn't. */

    /* Optimize inverted simple patterns (e.g. [^a-z]).  Note that we haven't
     * set the FOLD flag yet, so this does optimize those.  It doesn't
     * optimize locale.  Doing so perhaps could be done as long as there is
     * nothing like \w in it; some thought also would have to be given to the
     * interaction with above 0x100 chars */
    if ((ANYOF_FLAGS(ret) & ANYOF_INVERT)
        && ! LOC
	&& ! unicode_alternate
	/* In case of /d, there are some things that should match only when in
	 * not in the bitmap, i.e., they require UTF8 to match.  These are
	 * listed in nonbitmap, but if ANYOF_NONBITMAP_NON_UTF8 is set in this
	 * case, they don't require UTF8, so can invert here */
	&& (! nonbitmap
	    || ! DEPENDS_SEMANTICS
	    || (ANYOF_FLAGS(ret) & ANYOF_NONBITMAP_NON_UTF8))
	&& SvCUR(listsv) == initial_listsv_len)
    {
	int i;
	if (! nonbitmap) {
	    for (i = 0; i < 256; ++i) {
		if (ANYOF_BITMAP_TEST(ret, i)) {
		    ANYOF_BITMAP_CLEAR(ret, i);
		}
		else {
		    ANYOF_BITMAP_SET(ret, i);
		    prevvalue = value;
		    value = i;
		}
	    }
	    /* The inversion means that everything above 255 is matched */
	    ANYOF_FLAGS(ret) |= ANYOF_UNICODE_ALL;
	}
	else {
	    /* Here, also has things outside the bitmap that may overlap with
	     * the bitmap.  We have to sync them up, so that they get inverted
	     * in both places.  Earlier, we removed all overlaps except in the
	     * case of /d rules, so no syncing is needed except for this case
	     */
	    SV *remove_list = NULL;

	    if (DEPENDS_SEMANTICS) {
		UV start, end;

		/* Set the bits that correspond to the ones that aren't in the
		 * bitmap.  Otherwise, when we invert, we'll miss these.
		 * Earlier, we removed from the nonbitmap all code points
		 * < 128, so there is no extra work here */
		invlist_iterinit(nonbitmap);
		while (invlist_iternext(nonbitmap, &start, &end)) {
		    if (start > 255) {  /* The bit map goes to 255 */
			break;
		    }
		    if (end > 255) {
			end = 255;
		    }
		    for (i = start; i <= (int) end; ++i) {
			ANYOF_BITMAP_SET(ret, i);
			prevvalue = value;
			value = i;
		    }
		}
	    }

	    /* Now invert both the bitmap and the nonbitmap.  Anything in the
	     * bitmap has to also be removed from the non-bitmap, but again,
	     * there should not be overlap unless is /d rules. */
	    _invlist_invert(nonbitmap);

	    /* Any swash can't be used as-is, because we've inverted things */
	    if (swash) {
		SvREFCNT_dec(swash);
		swash = NULL;
	    }

	    for (i = 0; i < 256; ++i) {
		if (ANYOF_BITMAP_TEST(ret, i)) {
		    ANYOF_BITMAP_CLEAR(ret, i);
		    if (DEPENDS_SEMANTICS) {
			if (! remove_list) {
			    remove_list = _new_invlist(2);
			}
			remove_list = add_cp_to_invlist(remove_list, i);
		    }
		}
		else {
		    ANYOF_BITMAP_SET(ret, i);
		    prevvalue = value;
		    value = i;
		}
	    }

	    /* And do the removal */
	    if (DEPENDS_SEMANTICS) {
		if (remove_list) {
		    _invlist_subtract(nonbitmap, remove_list, &nonbitmap);
		    SvREFCNT_dec(remove_list);
		}
	    }
	    else {
		/* There is no overlap for non-/d, so just delete anything
		 * below 256 */
		_invlist_intersection(nonbitmap, PL_AboveLatin1, &nonbitmap);
	    }
a13914 5

	stored = 256 - stored;

	/* Clear the invert flag since have just done it here */
	ANYOF_FLAGS(ret) &= ~ANYOF_INVERT;
d13917 2
a13918 12
    /* Folding in the bitmap is taken care of above, but not for locale (for
     * which we have to wait to see what folding is in effect at runtime), and
     * for some things not in the bitmap (only the upper latin folds in this
     * case, as all other single-char folding has been set above).  Set
     * run-time fold flag for these */
    if (FOLD && (LOC
		|| (DEPENDS_SEMANTICS
		    && nonbitmap
		    && ! (ANYOF_FLAGS(ret) & ANYOF_NONBITMAP_NON_UTF8))
		|| unicode_alternate))
    {
	ANYOF_FLAGS(ret) |= ANYOF_LOC_NONBITMAP_FOLD;
d13921 7
a13927 85
    /* A single character class can be "optimized" into an EXACTish node.
     * Note that since we don't currently count how many characters there are
     * outside the bitmap, we are XXX missing optimization possibilities for
     * them.  This optimization can't happen unless this is a truly single
     * character class, which means that it can't be an inversion into a
     * many-character class, and there must be no possibility of there being
     * things outside the bitmap.  'stored' (only) for locales doesn't include
     * \w, etc, so have to make a special test that they aren't present
     *
     * Similarly A 2-character class of the very special form like [bB] can be
     * optimized into an EXACTFish node, but only for non-locales, and for
     * characters which only have the two folds; so things like 'fF' and 'Ii'
     * wouldn't work because they are part of the fold of 'LATIN SMALL LIGATURE
     * FI'. */
    if (! nonbitmap
	&& ! unicode_alternate
	&& SvCUR(listsv) == initial_listsv_len
	&& ! (ANYOF_FLAGS(ret) & (ANYOF_INVERT|ANYOF_UNICODE_ALL))
        && (((stored == 1 && ((! (ANYOF_FLAGS(ret) & ANYOF_LOCALE))
                              || (! ANYOF_CLASS_TEST_ANY_SET(ret)))))
	    || (stored == 2 && ((! (ANYOF_FLAGS(ret) & ANYOF_LOCALE))
				 && (! _HAS_NONLATIN1_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(value))
				 /* If the latest code point has a fold whose
				  * bit is set, it must be the only other one */
				&& ((prevvalue = PL_fold_latin1[value]) != (IV)value)
				 && ANYOF_BITMAP_TEST(ret, prevvalue)))))
    {
        /* Note that the information needed to decide to do this optimization
         * is not currently available until the 2nd pass, and that the actually
	 * used EXACTish node takes less space than the calculated ANYOF node,
	 * and hence the amount of space calculated in the first pass is larger
         * than actually used, so this optimization doesn't gain us any space.
	 * But an EXACT node is faster than an ANYOF node, and can be combined
	 * with any adjacent EXACT nodes later by the optimizer for further
	 * gains.  The speed of executing an EXACTF is similar to an ANYOF
	 * node, so the optimization advantage comes from the ability to join
	 * it to adjacent EXACT nodes */

        const char * cur_parse= RExC_parse;
	U8 op;
        RExC_emit = (regnode *)orig_emit;
        RExC_parse = (char *)orig_parse;

	if (stored == 1) {

	    /* A locale node with one point can be folded; all the other cases
	     * with folding will have two points, since we calculate them above
	     */
	    if (ANYOF_FLAGS(ret) & ANYOF_LOC_NONBITMAP_FOLD) {
		 op = EXACTFL;
	    }
	    else {
		op = EXACT;
	    }
	}
	else {   /* else 2 chars in the bit map: the folds of each other */

	    /* Use the folded value, which for the cases where we get here,
	     * is just the lower case of the current one (which may resolve to
	     * itself, or to the other one */
	    value = toLOWER_LATIN1(value);

	    /* To join adjacent nodes, they must be the exact EXACTish type.
	     * Try to use the most likely type, by using EXACTFA if possible,
	     * then EXACTFU if the regex calls for it, or is required because
	     * the character is non-ASCII.  (If <value> is ASCII, its fold is
	     * also ASCII for the cases where we get here.) */
	    if (MORE_ASCII_RESTRICTED && isASCII(value)) {
		op = EXACTFA;
	    }
	    else if (AT_LEAST_UNI_SEMANTICS || !isASCII(value)) {
		op = EXACTFU;
	    }
	    else {    /* Otherwise, more likely to be EXACTF type */
		op = EXACTF;
	    }
	}

	ret = reg_node(pRExC_state, op);
        RExC_parse = (char *)cur_parse;
	if (UTF && ! NATIVE_IS_INVARIANT(value)) {
	    *STRING(ret)= UTF8_EIGHT_BIT_HI((U8) value);
	    *(STRING(ret) + 1)= UTF8_EIGHT_BIT_LO((U8) value);
	    STR_LEN(ret)= 2;
	    RExC_emit += STR_SZ(2);
d13930 1
a13930 3
	    *STRING(ret)= (char)value;
	    STR_LEN(ret)= 1;
	    RExC_emit += STR_SZ(1);
a13931 2
	SvREFCNT_dec(listsv);
        return ret;
d13937 1
a13937 1
	SvREFCNT_dec(swash);
d13940 3
a13942 3
    if (! nonbitmap
	&& SvCUR(listsv) == initial_listsv_len
	&& ! unicode_alternate)
a13944 2
	SvREFCNT_dec(listsv);
	SvREFCNT_dec(unicode_alternate);
d13953 4
a13956 6
	 * av[2] stores the multicharacter foldings, used later in
	 *       regexec.c:S_reginclass().
	 * av[3] stores the nonbitmap inversion list for use in addition or
	 *       instead of av[0]; not used if av[1] isn't NULL
	 * av[4] is set if any component of the class is from a user-defined
	 *       property; not used if av[1] isn't NULL */
d13960 2
a13961 3
	av_store(av, 0, (SvCUR(listsv) == initial_listsv_len)
			? &PL_sv_undef
			: listsv);
d13964 1
a13964 1
	    SvREFCNT_dec(nonbitmap);
d13968 3
a13970 3
	    if (nonbitmap) {
		av_store(av, 3, nonbitmap);
		av_store(av, 4, newSVuv(has_user_defined_property));
a13973 11
        /* Store any computed multi-char folds only if we are allowing
         * them */
        if (allow_full_fold) {
            av_store(av, 2, MUTABLE_SV(unicode_alternate));
            if (unicode_alternate) { /* This node is variable length */
                OP(ret) = ANYOFV;
            }
        }
        else {
            av_store(av, 2, NULL);
        }
d13979 2
d13983 1
d14074 1
a14074 1
    register regnode *ptr;
d14116 1
a14116 1
    register regnode *ptr;
d14188 3
a14190 3
    register regnode *src;
    register regnode *dst;
    register regnode *place;
d14276 1
a14276 1
    register regnode *scan;
d14335 1
a14335 1
    register regnode *scan;
d14576 47
a14622 1
    register int k;
a14742 33
	/* Should be synchronized with * ANYOF_ #xdefines in regcomp.h */
	static const char * const anyofs[] = {
	    "\\w",
	    "\\W",
	    "\\s",
	    "\\S",
	    "\\d",
	    "\\D",
	    "[:alnum:]",
	    "[:^alnum:]",
	    "[:alpha:]",
	    "[:^alpha:]",
	    "[:ascii:]",
	    "[:^ascii:]",
	    "[:cntrl:]",
	    "[:^cntrl:]",
	    "[:graph:]",
	    "[:^graph:]",
	    "[:lower:]",
	    "[:^lower:]",
	    "[:print:]",
	    "[:^print:]",
	    "[:punct:]",
	    "[:^punct:]",
	    "[:upper:]",
	    "[:^upper:]",
	    "[:xdigit:]",
	    "[:^xdigit:]",
	    "[:space:]",
	    "[:^space:]",
	    "[:blank:]",
	    "[:^blank:]"
	};
d14746 1
a14746 1
	if (flags & ANYOF_LOC_NONBITMAP_FOLD)
d14796 1
a14796 1
	    SV * const sw = regclass_swash(prog, o, FALSE, &lv, 0);
d14874 1
a14874 1
		SvREFCNT_dec(lv);
d14880 9
d14903 1
a14903 1
    struct regexp *const prog = (struct regexp *)SvANY(r);
d14951 1
a14951 1
    struct regexp *const r = (struct regexp *)SvANY(rx);
d14961 1
d14971 1
a14971 1
#ifdef PERL_OLD_COPY_ON_WRITE
d14975 2
d15000 2
a15001 2
    struct regexp *const r = (struct regexp *)SvANY(rx);
    register const I32 npar = r->nparens+1;
d15007 21
a15027 1
    ret = (struct regexp *)SvANY(ret_x);
d15029 5
a15033 7
    (void)ReREFCNT_inc(rx);
    /* We can take advantage of the existing "copied buffer" mechanism in SVs
       by pointing directly at the buffer, but flagging that the allocated
       space in the copy is zero. As we've just done a struct copy, it's now
       a case of zero-ing that, rather than copying the current length.  */
    SvPV_set(ret_x, RX_WRAPPED(rx));
    SvFLAGS(ret_x) |= SvFLAGS(rx) & (SVf_POK|SVp_POK|SVf_UTF8);
d15036 5
a15040 5
    SvLEN_set(ret_x, 0);
    SvSTASH_set(ret_x, NULL);
    SvMAGIC_set(ret_x, NULL);
    Newx(ret->offs, npar, regexp_paren_pair);
    Copy(r->offs, ret->offs, npar, regexp_paren_pair);
d15054 1
a15054 1
#ifdef PERL_OLD_COPY_ON_WRITE
d15057 2
a15058 1
    ret->mother_re = rx;
d15080 1
a15080 1
    struct regexp *const r = (struct regexp *)SvANY(rx);
d15101 7
a15109 3
	PAD* new_comppad = NULL;
	PAD* old_comppad;
	PADOFFSET refcnt;
d15115 1
d15124 2
a15125 21
	    case 'p':
		new_comppad = MUTABLE_AV(ri->data->data[n]);
		break;
	    case 'o':
		if (new_comppad == NULL)
		    Perl_croak(aTHX_ "panic: pregfree comppad");
		PAD_SAVE_LOCAL(old_comppad,
		    /* Watch out for global destruction's random ordering. */
		    (SvTYPE(new_comppad) == SVt_PVAV) ? new_comppad : NULL
		);
		OP_REFCNT_LOCK;
		refcnt = OpREFCNT_dec((OP_4tree*)ri->data->data[n]);
		OP_REFCNT_UNLOCK;
		if (!refcnt)
                    op_free((OP_4tree*)ri->data->data[n]);

		PAD_RESTORE_LOCAL(old_comppad);
		SvREFCNT_dec(MUTABLE_SV(new_comppad));
		new_comppad = NULL;
		break;
	    case 'n':
d15201 2
a15202 2
    const struct regexp *r = (const struct regexp *)SvANY(sstr);
    struct regexp *ret = (struct regexp *)SvANY(dstr);
a15208 4
    if(ret->swap) {
        /* no need to copy these */
        Newx(ret->swap, npar, regexp_paren_pair);
    }
d15249 1
d15258 1
a15258 1
#ifdef PERL_OLD_COPY_ON_WRITE
d15262 3
a15264 3
    if (ret->mother_re) {
	if (SvPVX_const(dstr) == SvPVX_const(ret->mother_re)) {
	    /* Our storage points directly to our mother regexp, but that's
d15268 2
a15269 9
	    /* Note we need to use SvCUR(), rather than
	       SvLEN(), on our mother_re, because it, in
	       turn, may well be pointing to its own mother_re.  */
	    SvPV_set(dstr, SAVEPVN(SvPVX_const(ret->mother_re),
				   SvCUR(ret->mother_re)+1));
	    SvLEN_set(dstr, SvCUR(ret->mother_re)+1);
	}
	ret->mother_re      = NULL;
    }
d15292 1
a15292 1
    struct regexp *const r = (struct regexp *)SvANY(rx);
d15303 14
a15316 1
    
d15333 1
a15333 2
	        /* legal options are one of: sSfpontTua
	           see also regcomp.h and pregfree() */
d15335 1
a15337 1
	    case 'p': /* actually an AV, but the dup function is identical.  */
a15347 7
	    case 'o':
		/* Compiled op trees are readonly and in shared memory,
		   and can thus be shared without duplication. */
		OP_REFCNT_LOCK;
		d->data[i] = (void*)OpREFCNT_inc((OP*)ri->data->data[i]);
		OP_REFCNT_UNLOCK;
		break;
d15360 2
a15361 1
	    case 'n':
d15396 1
a15396 1
Perl_regnext(pTHX_ register regnode *p)
d15399 1
a15399 1
    register I32 offset;
a15470 2
    PL_reg_start_tmp = 0;
    PL_reg_start_tmpl = 0;
d15473 2
d15479 1
a15479 1
#ifdef PERL_OLD_COPY_ON_WRITE
a15504 7
static void
clear_re(pTHX_ void *r)
{
    dVAR;
    ReREFCNT_dec((REGEXP *)r);
}

d15520 5
a15524 2
       identical, to the ASCII delete (DEL) or rubout control character.
       ) So the old condition can be simplified to !isPRINT(c)  */
d15556 2
a15557 2
    register U8 op = PSEUDO;	/* Arbitrary non-END op. */
    register const regnode *next;
d15608 3
a15610 3
                register const regnode *nnode = (OP(next) == LONGJMP
					     ? regnext((regnode *)next)
					     : next);
d15710 1
a15710 1
 * indent-tabs-mode: t
d15713 1
a15713 1
 * ex: set ts=8 sts=4 sw=4 noet:
@


1.16
log
@merge in perl 5.12.2 plus local changes
@
text
@d30 1
a30 1
 * regexec to  pregcomp and pregexec in order to avoid conflicts
d88 5
d140 3
d147 3
d189 1
d197 3
d214 4
a217 1
#define	SIMPLE		0x02	/* Simple enough to be STAR/PLUS operand. */
d239 5
d251 1
a251 1
  string that must appear for at a fixed location, and we look for the
d272 2
a273 2
    character must match before the string we are searching.
    Likewise when combined with minlenp and the length of the string
d279 1
a279 1
    the string can appear at. Ifset to I32 max it indicates that the
d296 1
a296 1
    pattern at the time it was commited with a scan_commit. Note that
d332 1
a332 1
    I32 *minlen_fixed;      /* pointer to the minlen relevent to the string */
d337 1
a337 1
    I32 *minlen_float;      /* pointer to the minlen relevent to the string */
d384 12
a395 3
#define UTF (RExC_utf8 != 0)
#define LOC ((RExC_flags & RXf_PMf_LOCALE) != 0)
#define FOLD ((RExC_flags & RXf_PMf_FOLD) != 0)
d521 7
d637 1
a637 1
#endif /*RE_TRACK_PATTERN_OFFSETS*/
d697 1
a697 1
	    data->minlen_fixed=minlenp;	
a735 1
    ANYOF_CLASS_ZERO(cl);
d737 12
a748 2
    cl->flags = ANYOF_EOS|ANYOF_UNICODE_ALL;
    if (LOC)
d750 4
d783 1
d786 2
a787 11
STATIC void
S_cl_init_zero(const RExC_state_t *pRExC_state, struct regnode_charclass_class *cl)
{
    PERL_ARGS_ASSERT_CL_INIT_ZERO;

    Zero(cl, 1, struct regnode_charclass_class);
    cl->type = ANYOF;
    cl_anything(pRExC_state, cl);
    if (LOC)
	cl->flags |= ANYOF_LOCALE;
}
d789 3
a791 2
/* 'And' a given class with another one.  Can create false positives */
/* We assume that cl is not inverted */
d799 4
a802 2
    if (!(and_with->flags & ANYOF_CLASS)
	&& !(cl->flags & ANYOF_CLASS)
d804 2
a805 2
	&& !(and_with->flags & ANYOF_FOLD)
	&& !(cl->flags & ANYOF_FOLD)) {
a814 2
    if (!(and_with->flags & ANYOF_EOS))
	cl->flags &= ~ANYOF_EOS;
d816 94
a909 12
    if (cl->flags & ANYOF_UNICODE_ALL && and_with->flags & ANYOF_UNICODE &&
	!(and_with->flags & ANYOF_INVERT)) {
	cl->flags &= ~ANYOF_UNICODE_ALL;
	cl->flags |= ANYOF_UNICODE;
	ARG_SET(cl, ARG(and_with));
    }
    if (!(and_with->flags & ANYOF_UNICODE_ALL) &&
	!(and_with->flags & ANYOF_INVERT))
	cl->flags &= ~ANYOF_UNICODE_ALL;
    if (!(and_with->flags & (ANYOF_UNICODE|ANYOF_UNICODE_ALL)) &&
	!(and_with->flags & ANYOF_INVERT))
	cl->flags &= ~ANYOF_UNICODE;
d912 3
a914 2
/* 'OR' a given class with another one.  Can create false positives */
/* We assume that cl is not inverted */
d921 7
d937 3
a939 3
	if ( (or_with->flags & ANYOF_LOCALE) == (cl->flags & ANYOF_LOCALE)
	     && !(or_with->flags & ANYOF_FOLD)
	     && !(cl->flags & ANYOF_FOLD) ) {
d948 15
a962 1
    } else {
d965 2
a966 2
	     && (!(or_with->flags & ANYOF_FOLD)
		 || (cl->flags & ANYOF_FOLD)) ) {
d972 1
a972 1
	    if (or_with->flags & ANYOF_CLASS) {
a980 3
    }
    if (or_with->flags & ANYOF_EOS)
	cl->flags |= ANYOF_EOS;
d982 25
a1006 8
    if (cl->flags & ANYOF_UNICODE && or_with->flags & ANYOF_UNICODE &&
	ARG(cl) != ARG(or_with)) {
	cl->flags |= ANYOF_UNICODE_ALL;
	cl->flags &= ~ANYOF_UNICODE;
    }
    if (or_with->flags & ANYOF_UNICODE_ALL) {
	cl->flags |= ANYOF_UNICODE_ALL;
	cl->flags &= ~ANYOF_UNICODE;
d1027 1
a1027 1
   Part of the reason for their existance is to provide a form
d1036 1
a1036 1
 
d1044 1
d1114 7
d1251 1
d1300 1
a1300 1
Thus EVAL blocks follwing a trie may be called a different number of times with
d1302 1
a1302 1
ignored. This inconsistant behaviour of EVAL type nodes is well established as
d1315 1
a1315 1
The regexp /(ac|ad|ab)+/ will produce the folowing debug output:
d1369 1
a1369 1
#define TRIE_STORE_REVCHAR                                                 \
d1372 1
a1372 1
	    SV *zlopp = newSV(2);					   \
d1374 1
a1374 1
	    unsigned const char *const kapow = uvuni_to_utf8(flrbbbbb, uvc & 0xFF); \
d1380 1
a1380 1
	    char ooooff = (char)uvc;					   	   \
d1385 25
a1409 22
#define TRIE_READ_CHAR STMT_START {                                           \
    wordlen++;                                                                \
    if ( UTF ) {                                                              \
	if ( folder ) {                                                       \
	    if ( foldlen > 0 ) {                                              \
	       uvc = utf8n_to_uvuni( scan, UTF8_MAXLEN, &len, uniflags );     \
	       foldlen -= len;                                                \
	       scan += len;                                                   \
	       len = 0;                                                       \
	    } else {                                                          \
		uvc = utf8n_to_uvuni( (const U8*)uc, UTF8_MAXLEN, &len, uniflags);\
		uvc = to_uni_fold( uvc, foldbuf, &foldlen );                  \
		foldlen -= UNISKIP( uvc );                                    \
		scan = foldbuf + UNISKIP( uvc );                              \
	    }                                                                 \
	} else {                                                              \
	    uvc = utf8n_to_uvuni( (const U8*)uc, UTF8_MAXLEN, &len, uniflags);\
	}                                                                     \
    } else {                                                                  \
	uvc = (U32)*uc;                                                       \
	len = 1;                                                              \
    }                                                                         \
a1434 2
    if (trie->wordlen)                                          \
        trie->wordlen[ curword ] = wordlen;                     \
d1446 3
d1461 5
a1465 10
        /* So it's a dupe. This means we need to maintain a   */\
        /* linked-list from the first to the next.            */\
        /* we only allocate the nextword buffer when there    */\
        /* a dupe, so first time we have to do the allocation */\
        if (!trie->nextword)                                    \
            trie->nextword = (U16 *)					\
		PerlMemShared_calloc( word_count + 1, sizeof(U16));	\
        while ( trie->nextword[dupe] )                          \
            dupe= trie->nextword[dupe];                         \
        trie->nextword[dupe]= curword;                          \
d1503 1
d1505 1
a1505 7
    const U8 * const folder = ( flags == EXACTF
                       ? PL_fold
                       : ( flags == EXACTFL
                           ? PL_fold_locale
                           : NULL
                         )
                     );
d1525 11
d1542 1
a1542 1
    if (!(UTF && folder))
d1544 3
d1587 1
a1587 1
       efficient in terms of memory by ensuring most common value is in the
d1591 1
a1591 1
       will not be compressable. With a middle is most common approach the worst
d1602 1
d1612 1
a1612 1
        if ( set_bit ) /* bitmap only alloced when !(UTF&&Folding) */
d1615 5
a1619 1

d1625 7
d1634 1
a1634 3
                    if ( folder )
                        trie->charmap[ folder[ uvc ] ] = trie->charmap[ uvc ];
                    TRIE_STORE_REVCHAR;
d1637 3
a1639 3
                    /* store the codepoint in the bitmap, and if its ascii
                       also store its folded equivelent. */
                    TRIE_BITMAP_SET(trie,uvc);
d1642 1
a1642 1
		    if ( folder ) TRIE_BITMAP_SET(trie,folder[ uvc ]);
d1646 3
a1648 6
			   codepoints in the 127 < uvc < 256 range */
			if (127 < uvc && uvc < 192) {
			    TRIE_BITMAP_SET(trie,194);
			} else if (191 < uvc ) {
			    TRIE_BITMAP_SET(trie,195);
			/* && uvc < 256 -- we know uvc is < 256 already */
d1665 1
a1665 1
                    TRIE_STORE_REVCHAR;
d1670 2
a1671 2
            trie->minlen=chars;
            trie->maxlen=chars;
d1673 1
a1673 1
            trie->minlen=chars;
d1675 12
a1686 1
            trie->maxlen=chars;
a1696 1
    trie->wordlen = (U32 *) PerlMemShared_calloc( word_count, sizeof(U32) );
d1720 3
d1741 1
a1741 1
	
d1759 1
d1794 1
d1908 1
a1908 1
           We use the .check field of the first entry of the node  temporarily to
d1960 1
d1963 1
d1980 2
d2015 1
a2015 1
           - If .base is 0 there are no  valid transitions from that node.
d2029 1
a2029 1
           table: We first do not compress the root node 1,and mark its all its
d2031 3
a2033 3
           allows to do a DFA construction from the compressed table later, and
           ensures that any .base pointers we calculate later are greater than
           0.
d2129 1
a2129 4
    /* and now dump out the compressed format */
    DEBUG_TRIE_COMPILE_r(dump_trie(trie, widecharmap, revcharmap, depth+1));

    {   /* Modify the program and insert the new TRIE node*/ 
d2146 1
a2146 1
           Assuming its a sub part we conver the EXACT otherwise we convert
d2258 1
d2313 9
a2321 3
            /* XXXX */
            if ( !trie->states[trie->startstate].wordnum && trie->bitmap && 
                 ( (char *)jumper - (char *)convert) >= (int)sizeof(struct regnode_charclass) )
d2360 36
d2413 1
a2413 1
/* The Trie is constructed and compressed now so we can build a fail array now if its needed
d2420 2
a2421 2
   suffix of the current states 'word' that is also a proper prefix of another word in our
   trie. State 1 represents the word '' and is the thus the default fail state. This allows
d2427 2
a2428 2
   fail, which would bring use to the state representing 'd' in the second word where we would
   try 'g' and succeed, prodceding to match 'cdgu'.
d2542 103
d2646 1
a2646 3


#define JOIN_EXACT(scan,min,flags) \
d2648 1
a2648 1
        join_exact(pRExC_state,(scan),(min),(flags),NULL,depth+1)
d2651 1
a2651 1
S_join_exact(pTHX_ RExC_state_t *pRExC_state, regnode *scan, I32 *min, U32 flags,regnode *val, U32 depth) {
d2671 6
a2676 5
    
    /* Skip NOTHING, merge EXACT*. */
    while (n &&
           ( PL_regkind[OP(n)] == NOTHING ||
             (stringok && (OP(n) == OP(scan))))
d2678 2
a2679 1
           && NEXT_OFF(scan) + NEXT_OFF(n) < I16_MAX) {
d2696 3
a2700 1
            
d2702 1
a2702 2
            if (oldl + STR_LEN(n) > U8_MAX)
                break;
d2728 58
a2785 33
    
    if (UTF && ( OP(scan) == EXACTF ) && ( STR_LEN(scan) >= 6 ) ) {
    /*
    Two problematic code points in Unicode casefolding of EXACT nodes:
    
    U+0390 - GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS
    U+03B0 - GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS
    
    which casefold to
    
    Unicode                      UTF-8
    
    U+03B9 U+0308 U+0301         0xCE 0xB9 0xCC 0x88 0xCC 0x81
    U+03C5 U+0308 U+0301         0xCF 0x85 0xCC 0x88 0xCC 0x81
    
    This means that in case-insensitive matching (or "loose matching",
    as Unicode calls it), an EXACTF of length six (the UTF-8 encoded byte
    length of the above casefolded versions) can match a target string
    of length two (the byte length of UTF-8 encoded U+0390 or U+03B0).
    This would rather mess up the minimum length computation.
    
    What we'll do is to look for the tail four bytes, and then peek
    at the preceding two bytes to see whether we need to decrease
    the minimum length by four (six minus two).
    
    Thanks to the design of UTF-8, there cannot be false matches:
    A sequence of valid UTF-8 bytes cannot be a subsequence of
    another valid sequence of UTF-8 bytes.
    
    */
         char * const s0 = STRING(scan), *s, *t;
         char * const s1 = s0 + STR_LEN(scan) - 1;
         char * const s2 = s1 - 4;
d2787 4
a2790 1
	 const char t0[] = "\xaf\x49\xaf\x42";
d2792 108
a2899 16
         const char t0[] = "\xcc\x88\xcc\x81";
#endif
         const char * const t1 = t0 + 3;
    
         for (s = s0 + 2;
              s < s2 && (t = ninstr(s, s1, t0, t1));
              s = t + 4) {
#ifdef EBCDIC
	      if (((U8)t[-1] == 0x68 && (U8)t[-2] == 0xB4) ||
		  ((U8)t[-1] == 0x46 && (U8)t[-2] == 0xB5))
#else
              if (((U8)t[-1] == 0xB9 && (U8)t[-2] == 0xCE) ||
                  ((U8)t[-1] == 0x85 && (U8)t[-2] == 0xCF))
#endif
                   *min -= 4;
         }
d2901 1
a2901 1
    
d2903 2
a2904 1
    /* Allow dumping */
d2907 3
a2909 4
        if (PL_regkind[OP(n)] != NOTHING || OP(n) == NOTHING) {
            OP(n) = OPTIMIZED;
            NEXT_OFF(n) = 0;
        }
d2917 1
a2917 1
/* REx optimizer.  Converts nodes into quickier variants "in place".
d2929 1
a2929 1
   need to be handled seperately/specially in study_chunk. Its so
d3015 4
d3022 5
a3026 1
        JOIN_EXACT(scan,&min,0);
d3038 1
a3038 1
	
d3060 1
a3060 1
	
d3068 1
a3068 1
		
d3178 1
a3178 1
		   If we can find such a subseqence we need to turn the first
d3184 1
a3184 1
		     1. patterns where the whole set of branch can be converted. 
d3190 1
a3190 1
		   branchs so
d3201 1
a3201 1
		  we "jump" to the appopriate tail node. Essentailly we turn
d3205 1
a3205 1
		
d3217 1
a3217 1
                        U8 optype = 0;
d3248 41
a3288 20
                           step through the branches, cur represents each
                           branch, noper is the first thing to be matched
                           as part of that branch and noper_next is the
                           regnext() of that node. if noper is an EXACT
                           and noper_next is the same as scan (our current
                           position in the regex) then the EXACT branch is
                           a possible optimization target. Once we have
                           two or more consequetive such branches we can
                           create a trie of the EXACT's contents and stich
                           it in place. If the sequence represents all of
                           the branches we eliminate the whole thing and
                           replace it with a single TRIE. If it is a
                           subsequence then we need to stitch it in. This
                           means the first branch has to remain, and needs
                           to be repointed at the item on the branch chain
                           following the last branch optimized. This could
                           be either a BRANCH, in which case the
                           subsequence is internal, or it could be the
                           item following the branch sequence in which
                           case the subsequence is at the end.
d3291 4
d3299 2
d3322 24
a3345 3
                            if ( (((first && optype!=NOTHING) ? OP( noper ) == optype
                                         : PL_regkind[ OP( noper ) ] == EXACT )
                                  || OP(noper) == NOTHING )
d3351 4
d3356 3
a3358 3
                                if ( !first || optype == NOTHING ) {
                                    if (!first) first = cur;
                                    optype = OP( noper );
d3360 2
d3364 16
a3379 18
                            } else {
/* 
    Currently we do not believe that the trie logic can
    handle case insensitive matching properly when the
    pattern is not unicode (thus forcing unicode semantics).

    If/when this is fixed the following define can be swapped
    in below to fully enable trie logic.

#define TRIE_TYPE_IS_SAFE 1

*/
#define TRIE_TYPE_IS_SAFE (UTF || optype==EXACT)

                                if ( last && TRIE_TYPE_IS_SAFE ) {
                                    make_trie( pRExC_state, 
                                            startbranch, first, cur, tail, count, 
                                            optype, depth+1 );
d3381 1
a3381 1
                                if ( PL_regkind[ OP( noper ) ] == EXACT
d3386 1
d3389 4
a3392 2
                                    optype = OP( noper );
                                } else {
d3395 1
a3395 1
                                    optype = 0;
d3397 2
a3398 3
                                last = NULL;
                            }
                        }
d3406 6
a3411 4
                        
                        if ( last && TRIE_TYPE_IS_SAFE ) {
                            made= make_trie( pRExC_state, startbranch, first, scan, tail, count, optype, depth+1 );
#ifdef TRIE_STUDY_OPT	
d3424 2
a3425 2
                        }
                    }
d3498 1
a3499 1
		uc = utf8_to_uvchr(s, NULL);
d3531 7
d3541 2
a3542 2
		    && (!(data->start_class->flags & ANYOF_FOLD)
			|| !ANYOF_BITMAP_TEST(data->start_class, PL_fold[uc])))
d3544 1
d3546 1
d3551 16
d3593 1
a3594 1
		uc = utf8_to_uvchr(s, NULL);
d3596 18
a3613 3
	    min += l;
	    if (flags & SCF_DO_SUBSTR)
		data->pos_min += l;
a3616 1

d3618 4
a3621 3
		    (!(data->start_class->flags & (ANYOF_CLASS | ANYOF_LOCALE))
		    && !ANYOF_BITMAP_TEST(data->start_class, uc)
		     && !ANYOF_BITMAP_TEST(data->start_class, PL_fold[uc])))
d3623 1
d3629 5
a3633 2
		    data->start_class->flags |= ANYOF_FOLD;
		    if (OP(scan) == EXACTFL)
d3635 31
d3669 1
a3669 1
		if (data->start_class->flags & ANYOF_FOLD) {
d3672 1
a3672 1
		    if (uc < 0x100)
d3674 22
d3702 1
a3702 1
	else if (strchr((const char*)PL_varies,OP(scan))) {
d3779 10
a3788 7
		/* These are the cases when once a subexpression
		   fails at a particular position, it cannot succeed
		   even after backtracking at the enclosing scope.
		
		   XXXX what if minimal match and we are at the
		        initial run of {n,m}? */
		if ((mincount != maxcount - 1) && (maxcount != REG_INFTY))
d3857 1
a3857 1
		    if (!strchr((const char*)PL_simple,OP(nxt))
d3878 2
a3879 2
		    NEXT_OFF(nxt1+ 1) = 0; /* just for consistancy. */
		    NEXT_OFF(nxt2) = 0;	/* just for consistancy with CURLY. */
d3882 1
a3882 1
		    NEXT_OFF(nxt+ 1) = 0; /* just for consistancy. */
d3905 1
a3905 1
		    if (data->flags & SF_IN_PAR) {
a3908 2
			if (OP(nxt) != CLOSE)
			    FAIL("Panic opt close");
d3920 2
a3921 2
			NEXT_OFF(nxt1 + 1) = 0; /* just for consistancy. */
			NEXT_OFF(nxt + 1) = 0; /* just for consistancy. */
a3925 1
			
d3947 1
a3947 1
			    However, this time it not a subexpression
a3991 1
			
d4060 1
a4060 1
	    default:			/* REF and CLUMP only? */
d4079 3
a4081 3
                            ANYOF_BITMAP_CLEAR(data->start_class, value);  
                }                                                              
                else {                                                         
d4084 2
a4085 2
                            ANYOF_BITMAP_SET(data->start_class, value);	   
                }                                                              
a4097 13
    	    
	}
	else if (OP(scan) == FOLDCHAR) {
	    int d = ARG(scan)==0xDF ? 1 : 2;
	    flags &= ~SCF_DO_STCLASS;
            min += 1;
            delta += d;
            if (flags & SCF_DO_SUBSTR) {
	        SCAN_COMMIT(pRExC_state,data,minlenp);	/* Cannot expect anything... */
	        data->pos_min += 1;
	        data->pos_delta += d;
		data->longest = &(data->longest_float);
	    }
d4099 1
a4099 1
	else if (strchr((const char*)PL_simple,OP(scan))) {
d4125 1
a4125 1
				 || (data->start_class->flags & ANYOF_CLASS));
d4143 13
a4155 3
			    for (value = 0; value < 256; value++)
				if (!isALNUM(value))
				    ANYOF_BITMAP_CLEAR(data->start_class, value);
d4161 17
a4177 15
			else {
			    for (value = 0; value < 256; value++)
				if (isALNUM(value))
				    ANYOF_BITMAP_SET(data->start_class, value);			
			}
		    }
		    break;
		case ALNUML:
		    if (flags & SCF_DO_STCLASS_AND) {
			if (data->start_class->flags & ANYOF_LOCALE)
			    ANYOF_CLASS_CLEAR(data->start_class,ANYOF_NALNUM);
		    }
		    else {
			ANYOF_CLASS_SET(data->start_class,ANYOF_ALNUM);
			data->start_class->flags |= ANYOF_LOCALE;
d4184 13
a4196 3
			    for (value = 0; value < 256; value++)
				if (isALNUM(value))
				    ANYOF_BITMAP_CLEAR(data->start_class, value);
d4202 16
a4217 4
			else {
			    for (value = 0; value < 256; value++)
				if (!isALNUM(value))
				    ANYOF_BITMAP_SET(data->start_class, value);			
a4220 10
		case NALNUML:
		    if (flags & SCF_DO_STCLASS_AND) {
			if (data->start_class->flags & ANYOF_LOCALE)
			    ANYOF_CLASS_CLEAR(data->start_class,ANYOF_ALNUM);
		    }
		    else {
			data->start_class->flags |= ANYOF_LOCALE;
			ANYOF_CLASS_SET(data->start_class,ANYOF_NALNUM);
		    }
		    break;
d4225 13
a4237 3
			    for (value = 0; value < 256; value++)
				if (!isSPACE(value))
				    ANYOF_BITMAP_CLEAR(data->start_class, value);
d4241 1
a4241 1
			if (data->start_class->flags & ANYOF_LOCALE)
d4243 13
a4255 4
			else {
			    for (value = 0; value < 256; value++)
				if (isSPACE(value))
				    ANYOF_BITMAP_SET(data->start_class, value);			
a4258 10
		case SPACEL:
		    if (flags & SCF_DO_STCLASS_AND) {
			if (data->start_class->flags & ANYOF_LOCALE)
			    ANYOF_CLASS_CLEAR(data->start_class,ANYOF_NSPACE);
		    }
		    else {
			data->start_class->flags |= ANYOF_LOCALE;
			ANYOF_CLASS_SET(data->start_class,ANYOF_SPACE);
		    }
		    break;
d4263 13
a4275 3
			    for (value = 0; value < 256; value++)
				if (isSPACE(value))
				    ANYOF_BITMAP_CLEAR(data->start_class, value);
d4281 14
a4294 5
			else {
			    for (value = 0; value < 256; value++)
				if (!isSPACE(value))
				    ANYOF_BITMAP_SET(data->start_class, value);			
			}
d4297 1
a4297 1
		case NSPACEL:
d4299 2
a4300 2
			if (data->start_class->flags & ANYOF_LOCALE) {
			    ANYOF_CLASS_CLEAR(data->start_class,ANYOF_SPACE);
d4302 1
a4302 1
				if (!isSPACE(value))
a4306 12
			data->start_class->flags |= ANYOF_LOCALE;
			ANYOF_CLASS_SET(data->start_class,ANYOF_NSPACE);
		    }
		    break;
		case DIGIT:
		    if (flags & SCF_DO_STCLASS_AND) {
			ANYOF_CLASS_CLEAR(data->start_class,ANYOF_NDIGIT);
			for (value = 0; value < 256; value++)
			    if (!isDIGIT(value))
				ANYOF_BITMAP_CLEAR(data->start_class, value);
		    }
		    else {
d4309 3
a4311 5
			else {
			    for (value = 0; value < 256; value++)
				if (isDIGIT(value))
				    ANYOF_BITMAP_SET(data->start_class, value);			
			}
d4316 2
a4317 1
			ANYOF_CLASS_CLEAR(data->start_class,ANYOF_DIGIT);
d4325 3
a4327 5
			else {
			    for (value = 0; value < 256; value++)
				if (!isDIGIT(value))
				    ANYOF_BITMAP_SET(data->start_class, value);			
			}
d4332 1
a4332 1
		
d4430 1
a4430 1
                    minlens when its all done. This was we don't
d4713 1
a4713 1
#endif /* TRIE_STUDY_OPT */	
d4866 1
a4866 1
Perl_re_compile(pTHX_ SV * const pattern, U32 pm_flags)
d4873 2
a4874 2
    char  *exp = SvPV(pattern, plen);
    char* xend = exp + plen;
d4878 5
d4885 5
d4894 1
a4894 1
    int restudied= 0;
d4903 122
a5024 1
    RExC_utf8 = RExC_orig_utf8 = SvUTF8(pattern);
d5026 9
a5034 7
    DEBUG_COMPILE_r({
        SV *dsv= sv_newmortal();
        RE_PV_QUOTED_DECL(s, RExC_utf8,
            dsv, exp, plen, 60);
        PerlIO_printf(Perl_debug_log, "%sCompiling REx%s %s\n",
		       PL_colors[4],PL_colors[5],s);
    });
a5035 1
redo_first_pass:
d5041 1
d5045 1
d5071 5
a5075 1
    DEBUG_PARSE_r(PerlIO_printf(Perl_debug_log, "Starting first pass (sizing)\n"));
d5080 4
a5083 18
    if (RExC_utf8 && !RExC_orig_utf8) {
        /* It's possible to write a regexp in ascii that represents Unicode
        codepoints outside of the byte range, such as via \x{100}. If we
        detect such a sequence we have to convert the entire pattern to utf8
        and then recompile, as our sizing calculation will have been based
        on 1 byte == 1 character, but we will need to use utf8 to encode
        at least some part of the pattern, and therefore must convert the whole
        thing.
        XXX: somehow figure out how to make this less expensive...
        -- dmq */
        STRLEN len = plen;
        DEBUG_PARSE_r(PerlIO_printf(Perl_debug_log,
	    "UTF8 mismatch! Converting to utf8 for resizing and compile\n"));
        exp = (char*)Perl_bytes_to_utf8(aTHX_ (U8*)exp, &len);
        xend = exp + len;
        RExC_orig_utf8 = RExC_utf8;
        SAVEFREEPV(exp);
        goto redo_first_pass;
d5085 1
d5094 8
d5134 7
a5140 1
	bool has_minus = ((r->extflags & RXf_PMf_STD_PMMOD) != RXf_PMf_STD_PMMOD);
d5146 12
a5157 1
	const STRLEN wraplen = plen + has_minus + has_p + has_runon
d5161 1
a5161 2
	p = sv_grow(MUTABLE_SV(rx), wraplen + 1);
	SvCUR_set(rx, wraplen);
d5165 11
a5178 2
            char *r = p + (sizeof(STD_PAT_MODS) - 1) + has_minus - 1;
            char *colon = r + 1;
a5179 1

a5182 2
                else
                    *r-- = ch;
a5184 4
            if(has_minus) {
                *r = '-';
                p = colon;
            }
d5196 1
d5248 1
a5248 1
    r->minlen = minlen = sawplus = sawopen = 0;
a5295 1
	
d5311 1
a5311 1
	    (OP(first) == IFMATCH && !first->flags) || 
d5327 1
a5327 1
		
d5339 1
a5339 1
	    else if ((OP(first) == EXACTF || OP(first) == EXACTFL))
d5342 1
a5342 1
#ifdef TRIE_STCLASS	
d5363 2
a5364 2
#endif	
	else if (strchr((const char*)PL_simple,OP(first)))
d5398 1
a5398 1
	if (sawplus && (!sawopen || !RExC_sawback)
d5429 1
a5429 1
	
d5447 1
a5447 1
	
d5472 5
a5476 3
	    if (SvCUR(data.longest_fixed)  /* ok to leave SvCUR */
		&& data.offset_fixed == data.offset_float_min
		&& SvCUR(data.longest_fixed) == SvCUR(data.longest_float))
d5519 7
a5525 4
	if (longest_fixed_length
	    || (data.flags & SF_FIX_BEFORE_EOL /* Cannot have SEOL and MULTI */
		&& (!(data.flags & SF_FIX_BEFORE_MEOL)
		    || (RExC_flags & RXf_PMf_MULTILINE)))) 
d5562 1
d5569 1
d5620 1
a5620 1
	
d5636 1
d5641 1
d5702 2
a5703 3
        U8 nop = OP(NEXTOPER(first));
        
        if (PL_regkind[fop] == NOTHING && nop == END)
d5705 1
a5705 1
        else if (PL_regkind[fop] == BOL && nop == END)
d5707 2
a5708 1
        else if (fop == PLUS && nop ==SPACE && OP(regnext(first))==END)
d5714 1
a5714 1
        ri->name_list_idx = add_data( pRExC_state, 1, "p" );
d5764 1
a5764 1
        Perl_croak(aTHX_ "%s", PL_no_modify);
d5826 2
a5827 1
                    ret = newSVsv(&PL_sv_undef);
d6065 1
a6065 1
        Perl_croak(aTHX_ "%s", PL_no_modify);
d6191 2
a6192 1
            Perl_croak(aTHX_ "panic: bad flag in reg_scan_name");
d6244 32
a6275 2
/*
 - reg - regular expression, i.e. main body or parenthesized thing
d6277 4
a6280 1
 * Caller must absorb opening parenthesis.
d6282 100
a6381 10
 * Combining parenthesis handling with the base level of regular expression
 * is a trifle forced, but the need to tie the tails of the branches to what
 * follows makes it hard to avoid.
 */
#define REGTAIL(x,y,z) regtail((x),(y),(z),depth+1)
#ifdef DEBUGGING
#define REGTAIL_STUDY(x,y,z) regtail_study((x),(y),(z),depth+1)
#else
#define REGTAIL_STUDY(x,y,z) regtail((x),(y),(z),depth+1)
#endif
d6383 2
a6384 3
STATIC regnode *
S_reg(pTHX_ RExC_state_t *pRExC_state, I32 paren, I32 *flagp,U32 depth)
    /* paren: Parenthesized? 0=top, 1=(, inside: changed to letter. */
d6386 1
a6386 12
    dVAR;
    register regnode *ret;		/* Will be the head of the group. */
    register regnode *br;
    register regnode *lastbr;
    register regnode *ender = NULL;
    register I32 parno = 0;
    I32 flags;
    U32 oregflags = RExC_flags;
    bool have_branch = 0;
    bool is_open = 0;
    I32 freeze_paren = 0;
    I32 after_freeze = 0;
d6388 1
a6388 2
    /* for (?g), (?gc), and (?o) warnings; warning
       about (?c) will warn about (?g) -- japhy    */
d6390 1
a6390 5
#define WASTED_O  0x01
#define WASTED_G  0x02
#define WASTED_C  0x04
#define WASTED_GC (0x02|0x04)
    I32 wastedflags = 0x00;
d6392 1
a6392 2
    char * parse_start = RExC_parse; /* MJD */
    char * const oregcomp_parse = RExC_parse;
d6394 15
a6408 1
    GET_RE_DEBUG_FLAGS_DECL;
d6410 5
a6414 2
    PERL_ARGS_ASSERT_REG;
    DEBUG_PARSE("reg ");
d6416 1090
a7505 1
    *flagp = 0;				/* Tentatively. */
d7618 1
d7648 11
a7658 3
                    ret = reganode(pRExC_state,
                    	   (U8)(FOLD ? (LOC ? NREFFL : NREFF) : NREF),
                    	   num);
d7696 1
a7696 1
                        if (!svname) /* shouldnt happen */
d7742 1
d7754 1
d7758 1
a7758 1
			break;
d7834 1
a7834 1
			
d7840 1
a7840 1
                    Botton line is the negative indexing as from
d7911 1
a7911 1
		    RExC_parse = s;		
d7921 1
a7921 1
		    rop = sv_compile_2op(sv, &sop, "re", &pad);
d7969 1
a7969 1
			
d8083 8
d8097 7
d8111 73
d8224 5
a8228 1
                        if (flagsp == &negflags) {
d8242 1
d8246 1
a8296 6
    if (freeze_paren) {
        if (RExC_npar > after_freeze)
            after_freeze = RExC_npar;
        RExC_npar = freeze_paren;
    }

d8436 5
a8440 1
    if (after_freeze)
d8474 1
a8474 1
	
d8534 1
d8536 1
d8555 1
d8557 1
d8653 1
d8655 1
d8719 1
a8719 1
/* reg_namedseq(pRExC_state,UVp)
d8762 1
a8762 1
S_reg_namedseq(pTHX_ RExC_state_t *pRExC_state, UV *valuep, I32 *flagp)
a8765 3
#ifdef DEBUGGING
    char* parse_start = RExC_parse - 2;	    /* points to the '\N' */
#endif
d8834 1
a8834 1
    RExC_utf8 = 1;	/* named sequences imply Unicode semantics */
d8878 12
a8889 2
	char *s;	    /* String to put in generated EXACT node */
	STRLEN len = 0;	    /* Its current length */
d8892 1
d8894 1
a8894 18
	ret = reg_node(pRExC_state,
			(U8)(FOLD ? (LOC ? EXACTFL : EXACTF) : EXACT));
	s= STRING(ret);

	/* Exact nodes can hold only a U8 length's of text = 255.  Loop through
	 * the input which is of the form now 'c1.c2.c3...}' until find the
	 * ending brace or exeed length 255.  The characters that exceed this
	 * limit are dropped.  The limit could be relaxed should it become
	 * desirable by reparsing this as (?:\N{NAME}), so could generate
	 * multiple EXACT nodes, as is done for just regular input.  But this
	 * is primarily a named character, and not intended to be a huge long
	 * string, so 255 bytes should be good enough */
	while (1) {
	    STRLEN length_of_hex;
	    I32 grok_flags = PERL_SCAN_ALLOW_UNDERSCORES
			    | PERL_SCAN_DISALLOW_PREFIX
			    | (SIZE_ONLY ? PERL_SCAN_SILENT_ILLDIGIT : 0);
	    UV cp;  /* Ord of current character */
d8900 4
a8903 52
	    /* The values are Unicode even on EBCDIC machines */
	    length_of_hex = (STRLEN)(endchar - RExC_parse);
	    cp = grok_hex(RExC_parse, &length_of_hex, &grok_flags, NULL);
	    if ( length_of_hex == 0 
		|| length_of_hex != (STRLEN)(endchar - RExC_parse) )
	    {
		RExC_parse += length_of_hex;	    /* Includes all the valid */
		RExC_parse += (RExC_orig_utf8)	/* point to after 1st invalid */
				? UTF8SKIP(RExC_parse)
				: 1;
		/* Guard against malformed utf8 */
		if (RExC_parse >= endchar) RExC_parse = endchar;
		vFAIL("Invalid hexadecimal number in \\N{U+...}");
	    }    

	    if (! FOLD) {	/* Not folding, just append to the string */
		STRLEN unilen;

		/* Quit before adding this character if would exceed limit */
		if (len + UNISKIP(cp) > U8_MAX) break;

		unilen = reguni(pRExC_state, cp, s);
		if (unilen > 0) {
		    s   += unilen;
		    len += unilen;
		}
	    } else {	/* Folding, output the folded equivalent */
		STRLEN foldlen,numlen;
		U8 tmpbuf[UTF8_MAXBYTES_CASE+1], *foldbuf;
		cp = toFOLD_uni(cp, tmpbuf, &foldlen);

		/* Quit before exceeding size limit */
		if (len + foldlen > U8_MAX) break;
		
		for (foldbuf = tmpbuf;
		    foldlen;
		    foldlen -= numlen) 
		{
		    cp = utf8_to_uvchr(foldbuf, &numlen);
		    if (numlen > 0) {
			const STRLEN unilen = reguni(pRExC_state, cp, s);
			s       += unilen;
			len     += unilen;
			/* In EBCDIC the numlen and unilen can differ. */
			foldbuf += numlen;
			if (numlen >= foldlen)
			    break;
		    }
		    else
			break; /* "Can't happen." */
		}                          
	    }
d8907 2
d8910 5
a8914 2
	    /* Quit if no more characters */
	    if (RExC_parse >= endbrace) break;
d8916 1
d8918 2
d8921 1
a8921 11
	if (SIZE_ONLY) {
	    if (RExC_parse < endbrace) {
		ckWARNreg(RExC_parse - 1,
			  "Using just the first characters returned by \\N{}");
	    }

	    RExC_size += STR_SZ(len);
	} else {
	    STR_LEN(ret) = len;
	    RExC_emit += STR_SZ(len);
	}
d8923 3
a8925 1
	RExC_parse = endbrace + 1;
a8926 4
	*flagp |= HASWIDTH; /* Not SIMPLE, as that causes the engine to fail
			       with malformed in t/re/pat_advanced.t */
	RExC_parse --;
	Set_Node_Cur_Length(ret); /* MJD */
d8984 1
a8984 1
   on context. Specifically there are two seperate switches for handling
d8997 1
a9088 17
    case 0xDF:
    case 0xC3:
    case 0xCE:
        do_foldchar:
        if (!LOC && FOLD) {
            U32 len,cp;
	    len=0; /* silence a spurious compiler warning */
            if ((cp = what_len_TRICKYFOLD_safe(RExC_parse,RExC_end,UTF,len))) {
                *flagp |= HASWIDTH; /* could be SIMPLE too, but needs a handler in regexec.regrepeat */
                RExC_parse+=len-1; /* we get one from nextchar() as well. :-( */
                ret = reganode(pRExC_state, FOLDCHAR, cp);
                Set_Node_Length(ret, 1); /* MJD */
                nextchar(pRExC_state); /* kill whitespace under /x */
                return ret;
            }
        }
        goto outer_default;
a9102 4
	case 0xDF:
	case 0xC3:
	case 0xCE:
	           goto do_foldchar;	    
d9144 18
a9161 1
	    ret = reg_node(pRExC_state, (U8)(LOC ? ALNUML     : ALNUM));
d9165 18
a9182 1
	    ret = reg_node(pRExC_state, (U8)(LOC ? NALNUML    : NALNUM));
d9188 19
a9206 1
	    ret = reg_node(pRExC_state, (U8)(LOC ? BOUNDL     : BOUND));
d9208 3
d9215 19
a9233 1
	    ret = reg_node(pRExC_state, (U8)(LOC ? NBOUNDL    : NBOUND));
d9235 3
d9240 18
a9257 1
	    ret = reg_node(pRExC_state, (U8)(LOC ? SPACEL     : SPACE));
d9261 18
a9278 1
	    ret = reg_node(pRExC_state, (U8)(LOC ? NSPACEL    : NSPACE));
d9282 16
a9297 1
	    ret = reg_node(pRExC_state, DIGIT);
d9301 16
a9316 1
	    ret = reg_node(pRExC_state, NDIGIT);
d9344 1
a9344 1
	    {	
d9385 1
a9385 1
            ret= reg_namedseq(pRExC_state, NULL, flagp); 
d9413 10
a9422 2
                	   (U8)(FOLD ? (LOC ? NREFFL : NREFF) : NREF),
                	   num);
d9483 10
a9492 2
				   (U8)(FOLD ? (LOC ? REFFL : REFF) : REF),
				   num);
d9523 6
a9528 1
        outer_default:{
d9535 1
d9537 3
a9539 3
            parse_start = RExC_parse - 1;

	    RExC_parse++;
a9540 1
	defchar:
d9542 9
a9550 2
	    ret = reg_node(pRExC_state,
			   (U8)(FOLD ? (LOC ? EXACTFL : EXACTF) : EXACT));
d9552 19
d9572 2
a9573 2
	      len < 127 && p < RExC_end;
	      len++)
a9579 5
		case 0xDF:
		case 0xC3:
		case 0xCE:
		           if (LOC || !FOLD || !is_TRICKYFOLD_safe(p,RExC_end,UTF))
		                goto normal_default;
a9603 5
    		    case 0xDF:
    		    case 0xC3:
    		    case 0xCE:
    		           if (LOC || !FOLD || !is_TRICKYFOLD_safe(p,RExC_end,UTF))
    		                goto normal_default;		    
d9649 29
d9681 1
a9681 1
	
d9692 1
a9692 1
				    RExC_utf8 = 1;
d9707 1
a9707 2
			ender = UCHARAT(p++);
			ender = toCTRL(ender);
d9712 3
a9714 2
			  (isDIGIT(p[1]) && atoi(p) >= RExC_npar) ) {
                            I32 flags = 0;
d9717 2
a9718 11

			    /* An octal above 0xff is interpreted differently
			     * depending on if the re is in utf8 or not.  If it
			     * is in utf8, the value will be itself, otherwise
			     * it is interpreted as modulo 0x100.  It has been
			     * decided to discourage the use of octal above the
			     * single-byte range.  For now, warn only when
			     * it ends up modulo */
			    if (SIZE_ONLY && ender >= 0x100
				    && ! UTF && ! PL_encoding) {
				ckWARNregdep(p, "Use of octal value above 377 is deprecated");
d9730 1
a9730 1
			{
d9735 1
a9735 1
			    RExC_utf8 = 1;
d9743 7
a9749 2
			if (!SIZE_ONLY&& isALPHA(*p))
			    ckWARN2reg(p + 1, "Unrecognized escape \\%c passed through", UCHARAT(p));
d9762 1
a9762 1
			ender = *p++;
d9764 4
a9767 1
		}
d9770 60
a9829 3
		if (UTF && FOLD) {
		    /* Prime the casefolded buffer. */
		    ender = toFOLD_uni(ender, tmpbuf, &foldlen);
d9834 1
a9834 1
		    else if (UTF) {
d9841 4
a9844 1
				   ender = utf8_to_uvchr(foldbuf, &numlen);
d9873 1
a9873 1
		if (UTF) {
d9880 1
a9880 1
			       ender = utf8_to_uvchr(foldbuf, &numlen);
d9904 1
a9904 1
		else
d9906 1
d9908 2
a9909 1
	loopdone:
d9923 1
a9923 1
		
d9935 5
d9992 1
a9992 1
	
d10127 277
d10405 13
a10417 23
#define _C_C_T_(NAME,TEST,WORD)                         \
ANYOF_##NAME:                                           \
    if (LOC)                                            \
	ANYOF_CLASS_SET(ret, ANYOF_##NAME);             \
    else {                                              \
	for (value = 0; value < 256; value++)           \
	    if (TEST)                                   \
		ANYOF_BITMAP_SET(ret, value);           \
    }                                                   \
    yesno = '+';                                        \
    what = WORD;                                        \
    break;                                              \
case ANYOF_N##NAME:                                     \
    if (LOC)                                            \
	ANYOF_CLASS_SET(ret, ANYOF_N##NAME);            \
    else {                                              \
	for (value = 0; value < 256; value++)           \
	    if (!TEST)                                  \
		ANYOF_BITMAP_SET(ret, value);           \
    }                                                   \
    yesno = '!';                                        \
    what = WORD;                                        \
    break
d10419 7
a10425 15
#define _C_C_T_NOLOC_(NAME,TEST,WORD)                   \
ANYOF_##NAME:                                           \
	for (value = 0; value < 256; value++)           \
	    if (TEST)                                   \
		ANYOF_BITMAP_SET(ret, value);           \
    yesno = '+';                                        \
    what = WORD;                                        \
    break;                                              \
case ANYOF_N##NAME:                                     \
	for (value = 0; value < 256; value++)           \
	    if (!TEST)                                  \
		ANYOF_BITMAP_SET(ret, value);           \
    yesno = '!';                                        \
    what = WORD;                                        \
    break
d10427 1
a10427 9
/* 
   We dont use PERL_LEGACY_UNICODE_CHARCLASS_MAPPINGS as the direct test
   so that it is possible to override the option here without having to 
   rebuild the entire core. as we are required to do if we change regcomp.h
   which is where PERL_LEGACY_UNICODE_CHARCLASS_MAPPINGS is defined.
*/
#if PERL_LEGACY_UNICODE_CHARCLASS_MAPPINGS
#define BROKEN_UNICODE_CHARCLASS_MAPPINGS
#endif
d10429 7
a10435 5
#ifdef BROKEN_UNICODE_CHARCLASS_MAPPINGS
#define POSIX_CC_UNI_NAME(CCNAME) CCNAME
#else
#define POSIX_CC_UNI_NAME(CCNAME) "Posix" CCNAME
#endif
d10439 4
a10442 4
   matches the pattern or if the pattern matches a single char only and
   that char is < 256 and we are case insensitive then we produce an 
   EXACT node instead.
*/
d10457 1
d10459 5
d10465 33
a10497 1
    bool optimize_invert   = TRUE;
d10502 1
a10502 1
    UV stored = 0;  /* number of chars stored in the class */
d10519 2
a10520 1
    if (!SIZE_ONLY)
d10522 1
d10529 10
d10547 1
a10547 3
	if (FOLD)
	    ANYOF_FLAGS(ret) |= ANYOF_FOLD;
	if (LOC)
d10549 1
d10552 1
d10571 1
a10571 1
	if (!range)
d10573 2
d10620 1
a10620 1
                    if (reg_namedseq(pRExC_state, &v, NULL)) {
d10650 3
d10662 80
a10741 2
		    Perl_sv_catpvf(aTHX_ listsv, "%cutf8::%.*s\n",
			(value=='p' ? '+' : '!'), (int)n, RExC_parse);
a10743 1
		ANYOF_FLAGS(ret) |= ANYOF_UNICODE;
d10745 3
d10757 18
d10797 1
a10797 2
		value = UCHARAT(RExC_parse++);
		value = toCTRL(value);
d10800 1
a10800 1
	    case '5': case '6': case '7': case '8': case '9':
d10802 2
a10803 1
		    I32 flags = 0;
d10812 1
a10812 1
		{
d10821 2
a10822 1
		if (!SIZE_ONLY && isALPHA(value))
d10826 1
d10837 17
a10853 2
	    if (!SIZE_ONLY && !need_class)
		ANYOF_CLASS_ZERO(ret);
d10855 3
a10857 3
	    need_class = 1;

	    /* a bad range like a-\d, a-[:digit:] ? */
d10865 137
a11001 5
			       w, w, rangebegin);

		    if (prevvalue < 256) {
			ANYOF_BITMAP_SET(ret, prevvalue);
			ANYOF_BITMAP_SET(ret, '-');
d11004 7
a11010 3
			ANYOF_FLAGS(ret) |= ANYOF_UNICODE;
			Perl_sv_catpvf(aTHX_ listsv,
				       "%04"UVxf"\n%04"UVxf"\n", (UV)prevvalue, (UV) '-');
a11011 42
		}

		range = 0; /* this was not a true range */
	    }


    
	    if (!SIZE_ONLY) {
		const char *what = NULL;
		char yesno = 0;

	        if (namedclass > OOB_NAMEDCLASS)
		    optimize_invert = FALSE;
		/* Possible truncation here but in some 64-bit environments
		 * the compiler gets heartburn about switch on 64-bit values.
		 * A similar issue a little earlier when switching on value.
		 * --jhi */
		switch ((I32)namedclass) {
		
		case _C_C_T_(ALNUMC, isALNUMC(value), POSIX_CC_UNI_NAME("Alnum"));
		case _C_C_T_(ALPHA, isALPHA(value), POSIX_CC_UNI_NAME("Alpha"));
		case _C_C_T_(BLANK, isBLANK(value), POSIX_CC_UNI_NAME("Blank"));
		case _C_C_T_(CNTRL, isCNTRL(value), POSIX_CC_UNI_NAME("Cntrl"));
		case _C_C_T_(GRAPH, isGRAPH(value), POSIX_CC_UNI_NAME("Graph"));
		case _C_C_T_(LOWER, isLOWER(value), POSIX_CC_UNI_NAME("Lower"));
		case _C_C_T_(PRINT, isPRINT(value), POSIX_CC_UNI_NAME("Print"));
		case _C_C_T_(PSXSPC, isPSXSPC(value), POSIX_CC_UNI_NAME("Space"));
		case _C_C_T_(PUNCT, isPUNCT(value), POSIX_CC_UNI_NAME("Punct"));
		case _C_C_T_(UPPER, isUPPER(value), POSIX_CC_UNI_NAME("Upper"));
#ifdef BROKEN_UNICODE_CHARCLASS_MAPPINGS
		case _C_C_T_(ALNUM, isALNUM(value), "Word");
		case _C_C_T_(SPACE, isSPACE(value), "SpacePerl");
#else
		case _C_C_T_(SPACE, isSPACE(value), "PerlSpace");
		case _C_C_T_(ALNUM, isALNUM(value), "PerlWord");
#endif		
		case _C_C_T_(XDIGIT, isXDIGIT(value), "XDigit");
		case _C_C_T_NOLOC_(VERTWS, is_VERTWS_latin1(&value), "VertSpace");
		case _C_C_T_NOLOC_(HORIZWS, is_HORIZWS_latin1(&value), "HorizSpace");
		case ANYOF_ASCII:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_ASCII);
d11013 2
a11014 9
#ifndef EBCDIC
			for (value = 0; value < 128; value++)
			    ANYOF_BITMAP_SET(ret, value);
#else  /* EBCDIC */
			for (value = 0; value < 256; value++) {
			    if (isASCII(value))
			        ANYOF_BITMAP_SET(ret, value);
			}
#endif /* EBCDIC */
a11015 2
		    yesno = '+';
		    what = "ASCII";
d11017 45
a11061 3
		case ANYOF_NASCII:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_NASCII);
d11063 8
a11070 16
#ifndef EBCDIC
			for (value = 128; value < 256; value++)
			    ANYOF_BITMAP_SET(ret, value);
#else  /* EBCDIC */
			for (value = 0; value < 256; value++) {
			    if (!isASCII(value))
			        ANYOF_BITMAP_SET(ret, value);
			}
#endif /* EBCDIC */
		    }
		    yesno = '!';
		    what = "ASCII";
		    break;		
		case ANYOF_DIGIT:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_DIGIT);
d11072 2
a11073 3
			/* consecutive digits assumed */
			for (value = '0'; value <= '9'; value++)
			    ANYOF_BITMAP_SET(ret, value);
a11074 2
		    yesno = '+';
		    what = POSIX_CC_UNI_NAME("Digit");
d11076 28
a11103 13
		case ANYOF_NDIGIT:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_NDIGIT);
		    else {
			/* consecutive digits assumed */
			for (value = 0; value < '0'; value++)
			    ANYOF_BITMAP_SET(ret, value);
			for (value = '9' + 1; value < 256; value++)
			    ANYOF_BITMAP_SET(ret, value);
		    }
		    yesno = '!';
		    what = POSIX_CC_UNI_NAME("Digit");
		    break;		
d11111 1
a11111 6
		if (what) {
		    /* Strings such as "+utf8::isWord\n" */
		    Perl_sv_catpvf(aTHX_ listsv, "%cutf8::Is%s\n", yesno, what);
		}
		if (LOC)
		    ANYOF_FLAGS(ret) |= ANYOF_CLASS;
d11125 4
a11128 2
	    if (*RExC_parse == '-' && RExC_parse+1 < RExC_end &&
		RExC_parse[1] != ']') {
d11142 2
a11143 1
			ANYOF_BITMAP_SET(ret, '-');
d11150 6
a11156 1
        /*stored += (value - prevvalue + 1);*/
d11171 2
a11172 2
				stored++;
				ANYOF_BITMAP_SET(ret, i);
d11177 2
a11178 2
				stored++;
				ANYOF_BITMAP_SET(ret, i);
d11185 1
a11185 4
		        if (!ANYOF_BITMAP_TEST(ret,i)) {
		            stored++;  
			    ANYOF_BITMAP_SET(ret, i);
		        }
d11188 5
a11192 79
	  if (value > 255 || UTF) {
	        const UV prevnatvalue  = NATIVE_TO_UNI(prevvalue);
		const UV natvalue      = NATIVE_TO_UNI(value);
                stored+=2; /* can't optimize this class */
		ANYOF_FLAGS(ret) |= ANYOF_UNICODE;
		if (prevnatvalue < natvalue) { /* what about > ? */
		    Perl_sv_catpvf(aTHX_ listsv, "%04"UVxf"\t%04"UVxf"\n",
				   prevnatvalue, natvalue);
		}
		else if (prevnatvalue == natvalue) {
		    Perl_sv_catpvf(aTHX_ listsv, "%04"UVxf"\n", natvalue);
		    if (FOLD) {
			 U8 foldbuf[UTF8_MAXBYTES_CASE+1];
			 STRLEN foldlen;
			 const UV f = to_uni_fold(natvalue, foldbuf, &foldlen);

#ifdef EBCDIC /* RD t/uni/fold ff and 6b */
			 if (RExC_precomp[0] == ':' &&
			     RExC_precomp[1] == '[' &&
			     (f == 0xDF || f == 0x92)) {
			     f = NATIVE_TO_UNI(f);
                        }
#endif
			 /* If folding and foldable and a single
			  * character, insert also the folded version
			  * to the charclass. */
			 if (f != value) {
#ifdef EBCDIC /* RD tunifold ligatures s,t fb05, fb06 */
			     if ((RExC_precomp[0] == ':' &&
				  RExC_precomp[1] == '[' &&
				  (f == 0xA2 &&
				   (value == 0xFB05 || value == 0xFB06))) ?
				 foldlen == ((STRLEN)UNISKIP(f) - 1) :
				 foldlen == (STRLEN)UNISKIP(f) )
#else
			      if (foldlen == (STRLEN)UNISKIP(f))
#endif
				  Perl_sv_catpvf(aTHX_ listsv,
						 "%04"UVxf"\n", f);
			      else {
				  /* Any multicharacter foldings
				   * require the following transform:
				   * [ABCDEF] -> (?:[ABCabcDEFd]|pq|rst)
				   * where E folds into "pq" and F folds
				   * into "rst", all other characters
				   * fold to single characters.  We save
				   * away these multicharacter foldings,
				   * to be later saved as part of the
				   * additional "s" data. */
				  SV *sv;

				  if (!unicode_alternate)
				      unicode_alternate = newAV();
				  sv = newSVpvn_utf8((char*)foldbuf, foldlen,
						     TRUE);
				  av_push(unicode_alternate, sv);
			      }
			 }

			 /* If folding and the value is one of the Greek
			  * sigmas insert a few more sigmas to make the
			  * folding rules of the sigmas to work right.
			  * Note that not all the possible combinations
			  * are handled here: some of them are handled
			  * by the standard folding rules, and some of
			  * them (literal or EXACTF cases) are handled
			  * during runtime in regexec.c:S_find_byclass(). */
			 if (value == UNICODE_GREEK_SMALL_LETTER_FINAL_SIGMA) {
			      Perl_sv_catpvf(aTHX_ listsv, "%04"UVxf"\n",
					     (UV)UNICODE_GREEK_CAPITAL_LETTER_SIGMA);
			      Perl_sv_catpvf(aTHX_ listsv, "%04"UVxf"\n",
					     (UV)UNICODE_GREEK_SMALL_LETTER_SIGMA);
			 }
			 else if (value == UNICODE_GREEK_CAPITAL_LETTER_SIGMA)
			      Perl_sv_catpvf(aTHX_ listsv, "%04"UVxf"\n",
					     (UV)UNICODE_GREEK_SMALL_LETTER_SIGMA);
		    }
		}
	    }
a11200 7
    if (need_class) {
	ANYOF_FLAGS(ret) |= ANYOF_LARGE;
	if (SIZE_ONLY)
	    RExC_size += ANYOF_CLASS_ADD_SKIP;
	else
	    RExC_emit += ANYOF_CLASS_ADD_SKIP;
    }
d11207 430
a11636 5
    if( stored == 1 && (value < 128 || (value < 256 && !UTF))
        && !( ANYOF_FLAGS(ret) & ( ANYOF_FLAGS_ALL ^ ANYOF_FOLD ) )
    ) {
        /* optimize single char class to an EXACT node
           but *only* when its not a UTF/high char  */
d11638 1
d11641 37
a11677 2
        ret = reg_node(pRExC_state,
                       (U8)((ANYOF_FLAGS(ret) & ANYOF_FOLD) ? EXACTF : EXACT));
d11679 11
a11689 3
        *STRING(ret)= (char)value;
        STR_LEN(ret)= 1;
        RExC_emit += STR_SZ(1);
d11693 14
a11706 22
    /* optimize case-insensitive simple patterns (e.g. /[a-z]/i) */
    if ( /* If the only flag is folding (plus possibly inversion). */
	((ANYOF_FLAGS(ret) & (ANYOF_FLAGS_ALL ^ ANYOF_INVERT)) == ANYOF_FOLD)
       ) {
	for (value = 0; value < 256; ++value) {
	    if (ANYOF_BITMAP_TEST(ret, value)) {
		UV fold = PL_fold[value];

		if (fold != value)
		    ANYOF_BITMAP_SET(ret, fold);
	    }
	}
	ANYOF_FLAGS(ret) &= ~ANYOF_FOLD;
    }

    /* optimize inverted simple patterns (e.g. [^a-z]) */
    if (optimize_invert &&
	/* If the only flag is inversion. */
	(ANYOF_FLAGS(ret) & ANYOF_FLAGS_ALL) ==	ANYOF_INVERT) {
	for (value = 0; value < ANYOF_BITMAP_SIZE; ++value)
	    ANYOF_BITMAP(ret)[value] ^= ANYOF_FLAGS_ALL;
	ANYOF_FLAGS(ret) = ANYOF_UNICODE_ALL;
d11708 13
a11720 1
    {
d11723 27
a11749 9
	/* The 0th element stores the character class description
	 * in its textual form: used later (regexec.c:Perl_regclass_swash())
	 * to initialize the appropriate swash (which gets stored in
	 * the 1st element), and also useful for dumping the regnode.
	 * The 2nd element stores the multicharacter foldings,
	 * used later (regexec.c:S_reginclass()). */
	av_store(av, 0, listsv);
	av_store(av, 1, NULL);
	av_store(av, 2, MUTABLE_SV(unicode_alternate));
a11756 1
#undef _C_C_T_
d11794 1
a11794 1
   Advance that parse position, and optionall absorbs
d11813 5
a11817 2
	if (*RExC_parse == '(' && RExC_parse[1] == '?' &&
		RExC_parse[2] == '#') {
d11859 2
a11860 1
        Perl_croak(aTHX_ "panic: reg_node overrun trying to emit %d", op);
d11902 1
a11902 1
	
d11915 2
a11916 1
        Perl_croak(aTHX_ "panic: reg_node overrun trying to emit %d", op);
d12093 1
a12093 1
This is expermental code. The idea is to use this routine to perform 
d12127 3
a12129 2
        if (PL_regkind[OP(scan)] == EXACT)
            if (join_exact(pRExC_state,scan,&min,1,val,depth+1))
d12131 1
d12137 4
a12186 25
 - regcurly - a little FSA that accepts {\d+,?\d*}
 */
#ifndef PERL_IN_XSUB_RE
I32
Perl_regcurly(register const char *s)
{
    PERL_ARGS_ASSERT_REGCURLY;

    if (*s++ != '{')
	return FALSE;
    if (!isDIGIT(*s))
	return FALSE;
    while (isDIGIT(*s))
	s++;
    if (*s == ',')
	s++;
    while (isDIGIT(*s))
	s++;
    if (*s != '}')
	return FALSE;
    return TRUE;
}
#endif

/*
d12195 1
d12199 3
d12207 22
d12373 1
d12436 1
a12436 1
            if ( k != REF || OP(o) < NREF) {	    
a12464 2
    else if (k == FOLDCHAR)
	Perl_sv_catpvf(aTHX_ sv, "[0x%"UVXf"]", PTR2UV(ARG(o)) );
d12506 1
a12506 1
	if (flags & ANYOF_FOLD)
d12511 1
a12511 1
	
d12532 2
a12533 2
        /* output any special charclass tests (used mostly under use locale) */
	if (o->flags & ANYOF_CLASS)
d12542 4
d12547 3
a12549 1
	if (flags & ANYOF_UNICODE)
d12551 2
a12552 2
	else if (flags & ANYOF_UNICODE_ALL)
	    sv_catpvs(sv, "{unicode_all}");
d12554 2
a12555 2
	{
	    SV *lv;
d12557 4
a12560 2
	
	    if (lv) {
d12564 1
a12564 1
		    for (i = 0; i <= 256; i++) { /* just the first 256 */
d12566 8
a12573 2
			
			if (i < 256 && swash_fetch(sw, s, TRUE)) {
d12577 1
d12580 1
a12580 4
				    const U8 * const e = uvchr_to_utf8(s,rangestart);
				    U8 *p;
				    for(p = s; p < e; p++)
					put_byte(sv, *p);
d12583 1
a12583 4
				const U8 *e = uvchr_to_utf8(s,rangestart);
				U8 *p;
				for (p = s; p < e; p++)
				    put_byte(sv, *p);
d12585 1
a12585 5
				e = uvchr_to_utf8(s, i-1);
				for (p = s; p < e; p++)
				    put_byte(sv, *p);
				}
				rangestart = -1;
d12587 1
d12589 1
a12589 2
			
		    sv_catpvs(sv, "..."); /* et cetera */
d12595 1
a12595 1
		
d12598 1
a12598 1
		
d12601 5
a12605 1
			
d12607 10
a12616 1
			    if (*s == '\n')
d12618 4
d12626 1
a12626 1
			
d12629 3
a12631 1
		
d12634 1
d12684 1
a12684 1
   does is call the 'free' method of the regexp_engine associated to to 
d12738 1
a12738 1
    lightweight copy doesnt actually own any of its data except for
d12797 1
a12797 1
   this covers the *pprivate pointer which technically perldoesnt 
d12839 1
a12900 2
                        if (trie->wordlen)
                            PerlMemShared_free(trie->wordlen);
d12903 1
a12903 2
                        if (trie->nextword)
                            PerlMemShared_free(trie->nextword);
d12920 2
a12921 3
#define sv_dup_inc(s,t)	SvREFCNT_inc(sv_dup(s,t))
#define av_dup_inc(s,t)	MUTABLE_AV(SvREFCNT_inc(sv_dup((const SV *)s,t)))
#define hv_dup_inc(s,t)	MUTABLE_HV(SvREFCNT_inc(sv_dup((const SV *)s,t)))
d13014 2
a13015 1
	    /* Note we need to sue SvCUR() on our mother_re, because it, in
d13047 1
a13047 1
    int len, npar;
a13051 1
    npar = r->nparens+1;
d13073 1
a13073 1
	        /* legal options are one of: sSfpontTu
d13075 1
d13151 4
d13163 1
a13163 1
STATIC void	
d13214 1
a13214 1
    SSPUSHINT(SAVEt_RE_STATE);
d13276 8
a13283 2
    if (!isPRINT(c))
	Perl_sv_catpvf(aTHX_ sv, "\\%o", c);
d13340 1
a13340 1
	
d13388 1
a13388 1
		
d13430 1
a13430 1
	else if (op == ANYOF) {
d13432 1
a13432 1
	    node += 1 + ((ANYOF_FLAGS(node) & ANYOF_LARGE)
@


1.15
log
@- apply fix from upstream git for CVE-2009-3626, which could cause perl to
crash on certain invalid UTF-8 codes.

ok millert@@ sthen@@
@
text
@d108 1
a134 1
    HV		*charnames;		/* cache of named sequences */
d155 1
a178 1
#define RExC_charnames  (pRExC_state->charnames)
d395 1
a395 1
	SAVEDESTRUCTOR_X(clear_re,(void*)RExC_rx);			\
d426 1
a426 1
	SAVEDESTRUCTOR_X(clear_re,(void*)RExC_rx);	\
d444 1
a444 1
	SAVEDESTRUCTOR_X(clear_re,(void*)RExC_rx);	\
d463 1
a463 1
	SAVEDESTRUCTOR_X(clear_re,(void*)RExC_rx);	\
d476 1
a476 1
#define	vWARN(loc,m) STMT_START {					\
d478 2
a479 2
    Perl_warner(aTHX_ packWARN(WARN_REGEXP), "%s" REPORT_LOCATION,	\
	    m, (int)offset, RExC_precomp, RExC_precomp + offset);	\
d482 1
a482 1
#define	vWARNdep(loc,m) STMT_START {					\
d484 3
a486 3
    Perl_warner(aTHX_ packWARN2(WARN_DEPRECATED, WARN_REGEXP),		\
	    "%s" REPORT_LOCATION,					\
	    m, (int)offset, RExC_precomp, RExC_precomp + offset);	\
d489 1
a489 2

#define	vWARN2(loc, m, a1) STMT_START {					\
d491 1
a491 1
    Perl_warner(aTHX_ packWARN(WARN_REGEXP), m REPORT_LOCATION,		\
d501 6
d513 6
d3196 1
a3196 2
		    && maxcount <= REG_INFTY/3 /* Complement check for big count */
		    && ckWARN(WARN_REGEXP))
d3198 2
a3199 2
		    vWARN(RExC_parse,
			  "Quantifier unexpected on zero-length expression");
d4186 1
a4186 1
Perl_pregcomp(pTHX_ const SV * const pattern, const U32 flags)
d4212 1
a4212 1
Perl_re_compile(pTHX_ const SV * const pattern, const U32 pm_flags)
d4215 2
a4216 1
    register REGEXP *r;
d4219 1
a4219 1
    char*  exp = SvPV((SV*)pattern, plen);
d4239 1
a4239 1
    RExC_utf8 = RExC_orig_utf8 = pm_flags & RXf_UTF8;
a4268 1
    RExC_charnames = NULL;
d4327 2
a4328 1
    Newxz(r, 1, regexp);
a4343 2
    r->refcnt = 1;
    RX_PRELEN(r) = plen;
d4353 1
a4353 1
        RX_WRAPLEN(r) = plen + has_minus + has_p + has_runon
d4357 4
a4360 2
        Newx(RX_WRAPPED(r), RX_WRAPLEN(r) + 1, char );
        p = RX_WRAPPED(r);
d4384 2
a4385 1
        RX_PRECOMP(r) = p;
d4412 1
d4430 1
a4430 1
	ReREFCNT_dec(r);   
d4474 1
a4474 1
        r->extflags |= RXf_UTF8;	/* Unicode in it? */
d4872 1
a4872 1
    if (RX_PRELEN(r) == 0)
d4874 1
a4874 1
    if (r->extflags & RXf_SPLIT && RX_PRELEN(r) == 1 && RX_PRECOMP(r)[0] == ' ')
d4877 1
a4877 1
    else if (RX_PRELEN(r) == 3 && memEQ("\\s+", RX_PRECOMP(r), 3))
d4879 1
a4879 1
    else if (RX_PRELEN(r) == 1 && RXp_PRECOMP(r)[0] == '^')
d4882 1
a4882 1
    if (r->extflags & RXf_SPLIT && RX_PRELEN(r) == 1 && RX_PRECOMP(r)[0] == ' ')
d4933 1
a4933 1
    return(r);
d4984 2
a4985 1
Perl_reg_named_buff_fetch(pTHX_ REGEXP * const rx, SV * const namesv, const U32 flags)
d4989 1
d5008 1
a5008 1
                    CALLREG_NUMBUF_FETCH(rx,nums[i],ret);
d5025 1
a5025 1
Perl_reg_named_buff_exists(pTHX_ REGEXP * const rx, SV * const key,
d5028 1
d5036 1
a5036 1
	    SV *sv = CALLREG_NAMED_BUFF_FETCH(rx, key, flags);
d5050 1
a5050 1
Perl_reg_named_buff_firstkey(pTHX_ REGEXP * const rx, const U32 flags)
d5052 1
d5059 1
a5059 1
	return CALLREG_NAMED_BUFF_NEXTKEY(rx, NULL, flags & ~RXapif_FIRSTKEY);
d5066 1
a5066 1
Perl_reg_named_buff_nextkey(pTHX_ REGEXP * const rx, const U32 flags)
d5068 1
d5099 1
a5099 1
Perl_reg_named_buff_scalar(pTHX_ REGEXP * const rx, const U32 flags)
d5104 1
d5112 1
a5112 1
            ret = CALLREG_NAMED_BUFF_ALL(rx, (flags | RXapif_REGNAMES));
d5126 1
a5126 1
Perl_reg_named_buff_all(pTHX_ REGEXP * const rx, const U32 flags)
d5128 1
d5161 2
a5162 1
Perl_reg_numbered_buff_fetch(pTHX_ REGEXP * const rx, const I32 paren, SV * const sv)
d5164 1
d5254 1
a5254 1
Perl_reg_numbered_buff_length(pTHX_ REGEXP * const rx, const SV * const sv,
d5257 1
d5297 1
a5297 1
                report_uninit((SV *)sv);
d5319 4
a5322 1
	return newSVpvs("Regexp");
d6091 2
a6092 2
                            if (SIZE_ONLY && ckWARN(WARN_REGEXP))
                                vWARN(RExC_parse + 1,"Useless use of (?-p)");
d6547 5
a6551 5
    if (!SIZE_ONLY && !(flags&(HASWIDTH|POSTPONED)) && max > REG_INFTY/3 && ckWARN(WARN_REGEXP)) {
	vWARN3(RExC_parse,
	       "%.*s matches null string many times",
	       (int)(RExC_parse >= origparse ? RExC_parse - origparse : 0),
	       origparse);
d6586 1
a6586 1
   recognized'\N' and needs to handle the rest. RExC_parse is 
d6589 17
d6611 1
a6611 1
   handler a warning will be issued, and only the first char in the 
d6617 5
a6621 5
   If value is null then it is assumed that we are parsing normal text
   and inserts a new EXACT node into the program containing the resolved
   string and returns a pointer to the new node. If the string is 
   zerolength a NOTHING node is emitted.
   
d6623 1
a6623 10
   Parsing failures will generate a fatal errorvia vFAIL(...)
   
   NOTE: We cache all results from the charnames handler locally in 
   the RExC_charnames hash (created on first use) to prevent a charnames 
   handler from playing silly-buggers and returning a short string and 
   then a long string for a given pattern. Since the regexp program 
   size is calculated during an initial parse this would result
   in a buffer overrun so we cache to prevent the charname result from
   changing during the course of the parse.
   
d6626 1
a6626 1
S_reg_namedseq(pTHX_ RExC_state_t *pRExC_state, UV *valuep) 
d6628 1
a6628 6
    char * name;        /* start of the content of the name */
    char * endbrace;    /* endbrace following the name */
    SV *sv_str = NULL;  
    SV *sv_name = NULL;
    STRLEN len; /* this has various purposes throughout the code */
    bool cached = 0; /* if this is true then we shouldn't refcount dev sv_str */
d6630 6
d6638 8
d6647 23
d6671 28
a6698 1
        vFAIL("Missing braces on \\N{}");
d6700 16
a6715 7
    name = RExC_parse+1;
    endbrace = strchr(RExC_parse, '}');
    if ( ! endbrace ) {
        RExC_parse++;
        vFAIL("Missing right brace on \\N{}");
    } 
    RExC_parse = endbrace + 1;  
d6717 122
a6838 19
    
    /* RExC_parse points at the beginning brace, 
       endbrace points at the last */
    if ( name[0]=='U' && name[1]=='+' ) {
        /* its a "Unicode hex" notation {U+89AB} */
        I32 fl = PERL_SCAN_ALLOW_UNDERSCORES
            | PERL_SCAN_DISALLOW_PREFIX
            | (SIZE_ONLY ? PERL_SCAN_SILENT_ILLDIGIT : 0);
        UV cp;
        len = (STRLEN)(endbrace - name - 2);
        cp = grok_hex(name + 2, &len, &fl, NULL);
        if ( len != (STRLEN)(endbrace - name - 2) ) {
            cp = 0xFFFD;
        }    
        if ( valuep ) {
	    if (cp > 0xff) RExC_utf8 = 1;
            *valuep = cp;
            return NULL;
        }
d6840 4
a6843 12
	/* Need to convert to utf8 if either: won't fit into a byte, or the re
	 * is going to be in utf8 and the representation changes under utf8. */
	if (cp > 0xff || (RExC_utf8 && ! UNI_IS_INVARIANT(cp))) {
	    U8 string[UTF8_MAXBYTES+1];
	    U8 *tmps;
	    RExC_utf8 = 1;
	    tmps = uvuni_to_utf8(string, cp);
	    sv_str = newSVpvn_utf8((char*)string, tmps - string, TRUE);
	} else {    /* Otherwise, no need for utf8, can skip that step */
	    char string;
	    string = (char)cp;
	    sv_str= newSVpvn(&string, 1);
a6844 36
    } else {
        /* fetch the charnames handler for this scope */
        HV * const table = GvHV(PL_hintgv);
        SV **cvp= table ? 
            hv_fetchs(table, "charnames", FALSE) :
            NULL;
        SV *cv= cvp ? *cvp : NULL;
        HE *he_str;
        int count;
        /* create an SV with the name as argument */
        sv_name = newSVpvn(name, endbrace - name);
        
        if (!table || !(PL_hints & HINT_LOCALIZE_HH)) {
            vFAIL2("Constant(\\N{%s}) unknown: "
                  "(possibly a missing \"use charnames ...\")",
                  SvPVX(sv_name));
        }
        if (!cvp || !SvOK(*cvp)) { /* when $^H{charnames} = undef; */
            vFAIL2("Constant(\\N{%s}): "
                  "$^H{charnames} is not defined",SvPVX(sv_name));
        }
        
        
        
        if (!RExC_charnames) {
            /* make sure our cache is allocated */
            RExC_charnames = newHV();
            sv_2mortal(MUTABLE_SV(RExC_charnames));
        } 
            /* see if we have looked this one up before */
        he_str = hv_fetch_ent( RExC_charnames, sv_name, 0, 0 );
        if ( he_str ) {
            sv_str = HeVAL(he_str);
            cached = 1;
        } else {
            dSP ;
d6846 7
a6852 149
            ENTER ;
            SAVETMPS ;
            PUSHMARK(SP) ;
            
            XPUSHs(sv_name);
            
            PUTBACK ;
            
            count= call_sv(cv, G_SCALAR);
            
            if (count == 1) { /* XXXX is this right? dmq */
                sv_str = POPs;
                SvREFCNT_inc_simple_void(sv_str);
            } 
            
            SPAGAIN ;
            PUTBACK ;
            FREETMPS ;
            LEAVE ;
            
            if ( !sv_str || !SvOK(sv_str) ) {
                vFAIL2("Constant(\\N{%s}): Call to &{$^H{charnames}} "
                      "did not return a defined value",SvPVX(sv_name));
            }
            if (hv_store_ent( RExC_charnames, sv_name, sv_str, 0))
                cached = 1;
        }
    }
    if (valuep) {
        char *p = SvPV(sv_str, len);
        if (len) {
            STRLEN numlen = 1;
            if ( SvUTF8(sv_str) ) {
                *valuep = utf8_to_uvchr((U8*)p, &numlen);
                if (*valuep > 0x7F)
                    RExC_utf8 = 1; 
                /* XXXX
                  We have to turn on utf8 for high bit chars otherwise
                  we get failures with
                  
                   "ss" =~ /[\N{LATIN SMALL LETTER SHARP S}]/i
                   "SS" =~ /[\N{LATIN SMALL LETTER SHARP S}]/i
                
                  This is different from what \x{} would do with the same
                  codepoint, where the condition is > 0xFF.
                  - dmq
                */
                
                
            } else {
                *valuep = (UV)*p;
                /* warn if we havent used the whole string? */
            }
            if (numlen<len && SIZE_ONLY && ckWARN(WARN_REGEXP)) {
                vWARN2(RExC_parse,
                    "Ignoring excess chars from \\N{%s} in character class",
                    SvPVX(sv_name)
                );
            }        
        } else if (SIZE_ONLY && ckWARN(WARN_REGEXP)) {
            vWARN2(RExC_parse,
                    "Ignoring zero length \\N{%s} in character class",
                    SvPVX(sv_name)
                );
        }
        if (sv_name)    
            SvREFCNT_dec(sv_name);    
        if (!cached)
            SvREFCNT_dec(sv_str);    
        return len ? NULL : (regnode *)&len;
    } else if(SvCUR(sv_str)) {     
        
        char *s; 
        char *p, *pend;        
        STRLEN charlen = 1;
#ifdef DEBUGGING
        char * parse_start = name-3; /* needed for the offsets */
#endif
        GET_RE_DEBUG_FLAGS_DECL;     /* needed for the offsets */
        
        ret = reg_node(pRExC_state,
            (U8)(FOLD ? (LOC ? EXACTFL : EXACTF) : EXACT));
        s= STRING(ret);
        
        if ( RExC_utf8 && !SvUTF8(sv_str) ) {
            sv_utf8_upgrade(sv_str);
        } else if ( !RExC_utf8 && SvUTF8(sv_str) ) {
            RExC_utf8= 1;
        }
        
        p = SvPV(sv_str, len);
        pend = p + len;
        /* len is the length written, charlen is the size the char read */
        for ( len = 0; p < pend; p += charlen ) {
            if (UTF) {
                UV uvc = utf8_to_uvchr((U8*)p, &charlen);
                if (FOLD) {
                    STRLEN foldlen,numlen;
                    U8 tmpbuf[UTF8_MAXBYTES_CASE+1], *foldbuf;
                    uvc = toFOLD_uni(uvc, tmpbuf, &foldlen);
                    /* Emit all the Unicode characters. */
                    
                    for (foldbuf = tmpbuf;
                        foldlen;
                        foldlen -= numlen) 
                    {
                        uvc = utf8_to_uvchr(foldbuf, &numlen);
                        if (numlen > 0) {
                            const STRLEN unilen = reguni(pRExC_state, uvc, s);
                            s       += unilen;
                            len     += unilen;
                            /* In EBCDIC the numlen
                            * and unilen can differ. */
                            foldbuf += numlen;
                            if (numlen >= foldlen)
                                break;
                        }
                        else
                            break; /* "Can't happen." */
                    }                          
                } else {
                    const STRLEN unilen = reguni(pRExC_state, uvc, s);
        	    if (unilen > 0) {
        	       s   += unilen;
        	       len += unilen;
        	    }
        	}
	    } else {
                len++;
                REGC(*p, s++);
            }
        }
        if (SIZE_ONLY) {
            RExC_size += STR_SZ(len);
        } else {
            STR_LEN(ret) = len;
            RExC_emit += STR_SZ(len);
        }
        Set_Node_Cur_Length(ret); /* MJD */
        RExC_parse--; 
        nextchar(pRExC_state);
    } else {	/* zero length */
        ret = reg_node(pRExC_state,NOTHING);
    }
    if (!cached) {
        SvREFCNT_dec(sv_str);
    }
    if (sv_name) {
        SvREFCNT_dec(sv_name); 
d6854 1
a6855 1

d7185 1
a7185 1
            /* Handle \N{NAME} here and not below because it can be 
d7190 1
a7190 1
            ret= reg_namedseq(pRExC_state, NULL); 
d7456 12
d7481 2
a7482 2
			    if (!enc && SIZE_ONLY && ckWARN(WARN_REGEXP))
				vWARN(p, "Invalid escape in the specified encoding");
d7491 2
a7492 2
			if (!SIZE_ONLY&& isALPHA(*p) && ckWARN(WARN_REGEXP))
			    vWARN2(p + 1, "Unrecognized escape \\%c passed through", UCHARAT(p));
d7784 3
a7786 4
	    if (ckWARN(WARN_REGEXP))
		vWARN3(s+2,
			"POSIX syntax [%c %c] belongs inside character classes",
			c, c);
d7988 1
a7988 1
                    if (reg_namedseq(pRExC_state, &v)) {
d8082 3
a8084 3
		    if (!enc && SIZE_ONLY && ckWARN(WARN_REGEXP))
			vWARN(RExC_parse,
			      "Invalid escape in the specified encoding");
d8088 4
a8091 4
		if (!SIZE_ONLY && isALPHA(value) && ckWARN(WARN_REGEXP))
		    vWARN2(RExC_parse,
			   "Unrecognized escape \\%c in character class passed through",
			   (int)value);
d8110 4
a8113 5
		    if (ckWARN(WARN_REGEXP)) {
			const int w =
			    RExC_parse >= rangebegin ?
			    RExC_parse - rangebegin : 0;
			vWARN4(RExC_parse,
d8116 1
a8116 1
		    }
d8421 1
a8421 3
	if (listsv) {
	    SvREFCNT_dec(listsv);
	}
d8888 3
a8890 2
STATIC I32
S_regcurly(register const char *s)
d8908 1
a8908 1

d8914 1
a8914 1
void 
d9325 1
a9325 1
Perl_re_intuit_string(pTHX_ REGEXP * const prog)
d9328 1
d9369 6
d9376 1
d9379 2
a9380 2
    if (!r || (--r->refcnt > 0))
	return;
d9384 2
a9385 4
        CALLREGFREE_PVT(r); /* free the private data */
        if (RXp_PAREN_NAMES(r))
            SvREFCNT_dec(RXp_PAREN_NAMES(r));
        Safefree(RX_WRAPPED(r));
d9388 4
a9391 8
        if (r->anchored_substr)
            SvREFCNT_dec(r->anchored_substr);
        if (r->anchored_utf8)
            SvREFCNT_dec(r->anchored_utf8);
        if (r->float_substr)
            SvREFCNT_dec(r->float_substr);
        if (r->float_utf8)
            SvREFCNT_dec(r->float_utf8);
d9394 1
a9394 1
    RX_MATCH_COPY_FREE(r);
d9396 1
a9396 2
    if (r->saved_copy)
        SvREFCNT_dec(r->saved_copy);
a9397 1
    Safefree(r->swap);
a9398 1
    Safefree(r);
d9419 4
a9422 2
Perl_reg_temp_copy (pTHX_ REGEXP *r) {
    regexp *ret;
d9427 16
a9442 3
    (void)ReREFCNT_inc(r);
    Newx(ret, 1, regexp);
    StructCopy(r, ret, regexp);
a9444 1
    ret->refcnt = 1;
d9457 1
a9457 1
    RX_MATCH_COPIED_off(ret);
d9461 1
a9461 2
    ret->mother_re = r; 
    ret->swap = NULL;
d9463 1
a9463 1
    return ret;
d9480 1
a9480 1
Perl_regfree_internal(pTHX_ REGEXP * const r)
d9483 1
d9494 2
a9495 2
            RE_PV_QUOTED_DECL(s, RX_UTF8(r),
                dsv, RX_PRECOMP(r), RX_PRELEN(r), 60);
d9616 2
a9617 2
regexp *
Perl_re_dup(pTHX_ const regexp *r, CLONE_PARAMS *param)
a9619 1
    regexp *ret;
d9621 2
a9622 1
    U32 precomp_offset;
d9624 1
a9624 7
    PERL_ARGS_ASSERT_RE_DUP;

    if (!r)
	return (REGEXP *)NULL;

    if ((ret = (REGEXP *)ptr_table_fetch(PL_ptr_table, r)))
	return ret;
a9626 2
    Newx(ret, 1, regexp);
    StructCopy(r, ret, regexp);
a9671 4
    precomp_offset = RX_PRECOMP(ret) - ret->wrapped;

    RX_WRAPPED(ret)     = SAVEPVN(RX_WRAPPED(ret), RX_WRAPLEN(ret)+1);
    RX_PRECOMP(ret)     = ret->wrapped + precomp_offset;
d9675 1
a9675 1
	RXi_SET(ret,CALLREGDUPE_PVT(ret,param));
d9677 1
a9677 1
    if (RX_MATCH_COPIED(ret))
d9685 14
a9698 1
    ret->mother_re      = NULL;
a9699 3
    
    ptr_table_store(PL_ptr_table, r, ret);
    return ret;
d9718 1
a9718 1
Perl_regdupe_internal(pTHX_ REGEXP * const r, CLONE_PARAMS *param)
d9721 1
a9812 27
/* 
   reg_stringify() 
   
   converts a regexp embedded in a MAGIC struct to its stringified form, 
   caching the converted form in the struct and returns the cached 
   string. 

   If lp is nonnull then it is used to return the length of the 
   resulting string
   
   If flags is nonnull and the returned string contains UTF8 then 
   (*flags & 1) will be true.
   
   If haseval is nonnull then it is used to return whether the pattern 
   contains evals.
   
   Normally called via macro: 
   
        CALLREG_STRINGIFY(mg,&len,&utf8);
        
   And internally with
   
        CALLREG_AS_STR(mg,&lp,&flags,&haseval)        
    
   See sv_2pv_flags() in sv.c for an example of internal usage.
    
 */
a9813 13

char *
Perl_reg_stringify(pTHX_ MAGIC *mg, STRLEN *lp, U32 *flags, I32 *haseval ) {
    dVAR;
    const REGEXP * const re = (REGEXP *)mg->mg_obj;
    if (haseval) 
        *haseval = RX_SEEN_EVALS(re);
    if (flags)    
	*flags = RX_UTF8(re) ? 1 : 0;
    if (lp)
	*lp = RX_WRAPLEN(re);
    return RX_WRAPPED(re);
}
@


1.14
log
@Merge in perl 5.10.1
@
text
@d2823 9
a2831 5
    Currently we assume that the trie can handle unicode and ascii
    matches fold cased matches. If this proves true then the following
    define will prevent tries in this situation. 
    
    #define TRIE_TYPE_IS_SAFE (UTF || optype==EXACT)
d2833 2
a2834 1
#define TRIE_TYPE_IS_SAFE 1
@


1.13
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d5 3
a7 1
 * "A fair jaw-cracker dwarf-language must be."  --Samwise Gamgee
d62 2
a63 1
 ****    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007 by Larry Wall and others
d636 2
d684 2
d699 2
d715 2
d725 2
d740 1
d779 2
d872 1
d955 3
d1013 2
d1255 1
a1255 1
            tmp = newSVpvn(STRING(noper), STR_LEN(noper));      \
d1257 1
a1257 2
            tmp = newSVpvn( "", 0 );                            \
        if ( UTF ) SvUTF8_on( tmp );                            \
d1342 2
d1999 1
a1999 1
                                        PerlIO_printf(Perl_debug_log, (char*)ch)
d2188 2
d2306 2
d2518 1
d2520 1
a2520 1
    GET_RE_DEBUG_FLAGS_DECL;
d3349 1
a3349 3
			last_str = newSVpvn(s  + old, l);
			if (UTF)
			    SvUTF8_on(last_str);
d3728 16
a3743 5
                    const int was = (data->start_class->flags & ANYOF_EOS);

                    cl_and(data->start_class, &intrnl);
                    if (was)
                        data->start_class->flags |= ANYOF_EOS;
d4090 2
d4175 3
d4218 3
d4329 1
a4329 1
    r->prelen = plen;
d4335 2
a4336 1
	U16 reganch = (U16)((r->extflags & RXf_PMf_STD_PMMOD) >> 12);
d4339 1
a4339 1
        r->wraplen = r->prelen + has_minus + has_p + has_runon
d4343 2
a4344 2
        Newx(r->wrapped, r->wraplen + 1, char );
        p = r->wrapped;
d4367 3
a4369 3
        Copy(RExC_precomp, p, r->prelen, char);
        r->precomp = p;
        p += r->prelen;
d4428 4
a4431 1
    if ( restudied ) {
a4445 3
    } else {
        StructCopy(&zero_scan_data, &data, scan_data_t);
        copyRExC_state = RExC_state;
d4473 11
a4483 1
	/* Skip introductions and multiplicators >= 1. */
d4495 5
a4499 1
	        
d4504 2
a4505 5
		if (OP(first) == IFMATCH) {
		    first = NEXTOPER(first);
		    first += EXTRA_STEP_2ARGS;
		} else  /* XXX possible optimisation for /(?=)/  */
		    first = NEXTOPER(first);
d4849 1
a4849 1
        r->paren_names = (HV*)SvREFCNT_inc(RExC_paren_names);
d4851 1
a4851 1
        r->paren_names = NULL;
d4854 1
a4854 1
    if (r->prelen == 0)
d4856 1
a4856 1
    if (r->extflags & RXf_SPLIT && r->prelen == 1 && r->precomp[0] == ' ')
d4859 1
a4859 1
    else if (r->prelen == 3 && memEQ("\\s+", r->precomp, 3))
d4861 1
a4861 1
    else if (r->prelen == 1 && r->precomp[0] == '^')
d4864 1
a4864 1
    if (r->extflags & RXf_SPLIT && r->prelen == 1 && r->precomp[0] == ' ')
d4925 2
d4932 1
a4932 1
        Perl_croak(aTHX_ PL_no_modify);
d4952 1
d4970 3
d4976 2
a4977 2
    if (rx && rx->paren_names) {
        HE *he_str = hv_fetch_ent( rx->paren_names, namesv, 0, 0 );
d4994 1
a4994 2
                if (retarray) {
                    SvREFCNT_inc_simple_void(ret);
a4995 1
                }
d4998 1
a4998 1
                return newRV((SV*)retarray);
d5008 4
a5011 1
    if (rx && rx->paren_names) {
d5013 1
a5013 1
            return hv_exists_ent(rx->paren_names, key, 0);
d5031 5
a5035 2
    if ( rx && rx->paren_names ) {
	(void)hv_iterinit(rx->paren_names);
d5046 6
a5051 2
    if (rx && rx->paren_names) {
        HV *hv = rx->paren_names;
d5059 1
a5059 1
                if ((I32)(rx->lastcloseparen) >= nums[i] &&
d5068 1
a5068 3
                STRLEN len;
                char *pv = HePV(temphe, len);
                return newSVpvn(pv,len);
d5082 3
a5084 1
    if (rx && rx->paren_names) {
d5086 1
a5086 1
            return newSViv(HvTOTALKEYS(rx->paren_names));
d5089 1
a5089 1
            av = (AV*)SvRV(ret);
d5091 1
d5106 4
a5109 2
    if (rx && rx->paren_names) {
        HV *hv= rx->paren_names;
d5118 1
a5118 1
                if ((I32)(rx->lastcloseparen) >= nums[i] &&
d5127 1
a5127 3
                STRLEN len;
                char *pv = HePV(temphe, len);
                av_push(av, newSVpvn(pv,len));
d5132 1
a5132 1
    return newRV((SV*)av);
d5141 2
d5179 1
a5179 1
            ? (RX_MATCH_UTF8(rx)
d5181 1
a5181 1
            : (RX_MATCH_UTF8(rx)) )
d5188 1
a5188 1
            if (RX_MATCH_TAINTED(rx)) {
d5216 2
d5223 1
a5223 1
        Perl_croak(aTHX_ PL_no_modify);
d5233 2
d5269 1
a5269 1
                report_uninit((SV*)sv);
d5274 1
a5274 1
    if (i > 0 && RX_MATCH_UTF8(rx)) {
d5289 1
d5307 2
a5308 1
S_reg_scan_name(pTHX_ RExC_state_t *pRExC_state, U32 flags) {
d5311 2
d5326 3
a5328 4
        SV* sv_name = sv_2mortal(Perl_newSVpvn(aTHX_ name_start,
            (int)(RExC_parse - name_start)));
	if (UTF)
            SvUTF8_on(sv_name);
d5443 2
d5634 1
a5634 1
                            sv_2mortal((SV*)RExC_paren_names);
d5637 1
a5637 1
                            sv_2mortal((SV*)RExC_paren_name_list);
d5666 1
a5666 1
                                SvIVX(sv_dat)++;
d5672 1
a5672 1
                            SvIVX(sv_dat)= 1;
d5688 2
d6133 7
d6298 3
d6376 3
d6456 1
a6456 1
	    if (max && max < min)
d6596 3
a6598 1
    
a6618 1
	char string;
a6623 2
        if (cp > 0xff)
            RExC_utf8 = 1;
d6625 1
d6629 14
a6642 2
	string = (char)cp;
        sv_str= newSVpvn(&string, 1);
d6670 1
a6670 1
            sv_2mortal((SV*)RExC_charnames);
d6821 1
a6821 1
    } else {
d6849 1
a6849 1
    SV * const sv = sv_2mortal(newSVpvn(&value, numlen));
d6854 2
d6902 1
d7583 3
d7622 2
d7738 3
d7806 16
d7855 2
d8110 12
a8122 9
		case _C_C_T_(ALNUMC, isALNUMC(value), "Alnum");
		case _C_C_T_(ALPHA, isALPHA(value), "Alpha");
		case _C_C_T_(BLANK, isBLANK(value), "Blank");
		case _C_C_T_(CNTRL, isCNTRL(value), "Cntrl");
		case _C_C_T_(GRAPH, isGRAPH(value), "Graph");
		case _C_C_T_(LOWER, isLOWER(value), "Lower");
		case _C_C_T_(PRINT, isPRINT(value), "Print");
		case _C_C_T_(PSXSPC, isPSXSPC(value), "Space");
		case _C_C_T_(PUNCT, isPUNCT(value), "Punct");
d8124 4
a8127 1
		case _C_C_T_(UPPER, isUPPER(value), "Upper");
d8174 1
a8174 1
		    what = "Digit";
d8187 1
a8187 1
		    what = "Digit";
d8326 2
a8327 2
				  sv = newSVpvn((char*)foldbuf, foldlen);
				  SvUTF8_on(sv);
d8387 3
d8426 2
a8427 2
	av_store(av, 2, (SV*)unicode_alternate);
	rv = newRV_noinc((SV*)av);
d8453 3
d8488 2
d8526 2
d8567 2
d8619 3
d8640 2
d8724 2
d8786 1
d8788 1
a8788 1
    GET_RE_DEBUG_FLAGS_DECL;
d8859 2
d8882 2
a8883 1
S_regdump_extflags(pTHX_ const char *lead, const U32 flags) {
d8886 1
d8913 2
d8989 1
d8998 11
d9018 1
d9020 1
a9020 1
    sv_setpvn(sv, "", 0);
d9099 1
a9099 1
	if ( prog->paren_names ) {
d9101 1
a9101 1
	        AV *list= (AV *)progi->data->data[progi->name_list_idx];
d9107 2
a9108 2
                AV *list= (AV *)progi->data->data[ progi->name_list_idx ];
                SV *sv_dat=(SV*)progi->data->data[ ARG( o ) ];
d9126 1
a9126 1
                SVfARG((SV*)progi->data->data[ ARG( o ) ]));
d9134 1
d9150 2
a9151 2
	    "[:ctrl:]",
	    "[:^ctrl:]",
d9177 2
d9192 1
d9196 3
a9198 1

d9201 1
a9201 1
		if (ANYOF_CLASS_TEST(o,i))
d9203 6
a9208 1

d9221 1
a9221 1
		
d9296 2
d9333 1
a9333 1
Perl_pregfree(pTHX_ struct regexp *r)
d9344 3
a9346 3
        if (r->paren_names)
            SvREFCNT_dec(r->paren_names);
        Safefree(r->wrapped);
d9386 2
a9387 2
regexp *
Perl_reg_temp_copy (pTHX_ struct regexp *r) {
d9390 3
d9440 3
a9442 1
    
d9448 2
a9449 2
            RE_PV_QUOTED_DECL(s, (r->extflags & RXf_UTF8),
                dsv, r->precomp, r->prelen, 60);
d9470 1
a9470 1
		SvREFCNT_dec((SV*)ri->data->data[n]);
d9476 1
a9476 1
		new_comppad = (AV*)ri->data->data[n];
d9492 1
a9492 1
		SvREFCNT_dec((SV*)new_comppad);
d9551 2
a9552 2
#define av_dup_inc(s,t)	(AV*)SvREFCNT_inc(sv_dup((SV*)s,t))
#define hv_dup_inc(s,t)	(HV*)SvREFCNT_inc(sv_dup((SV*)s,t))
d9558 2
a9559 2
   This routine is expected to clone a given regexp structure. It is not
   compiler under USE_ITHREADS.
d9576 3
a9585 1
    
d9600 3
a9602 1
	const bool anchored = r->check_substr == r->anchored_substr;
d9625 6
d9634 5
a9638 3
    ret->wrapped        = SAVEPVN(ret->wrapped, ret->wraplen+1);
    ret->precomp        = ret->wrapped + (ret->precomp - ret->wrapped);
    ret->paren_names    = hv_dup_inc(ret->paren_names, param);
a9652 1
    ret->seen_evals = 0;
d9680 2
d9686 1
a9686 1
    Newxc(reti, sizeof(regexp_internal) + (len+1)*sizeof(regnode), char, regexp_internal);
d9711 1
a9711 1
		d->data[i] = sv_dup_inc((SV *)ri->data->data[i], param);
d9800 1
a9800 1
    const regexp * const re = (regexp *)mg->mg_obj;
d9802 1
a9802 1
        *haseval = re->seen_evals;
d9804 1
a9804 1
	*flags = ((re->extflags & RXf_UTF8) ? 1 : 0);
d9806 2
a9807 2
	*lp = re->wraplen;
    return re->wrapped;
d9840 2
d9902 1
a9902 1
	    for (i = 1; i <= rx->nparens; i++) {
d9923 1
a9923 1
    ReREFCNT_dec((regexp *)r);
d9931 2
d9974 3
a9976 1
    
d10042 1
a10042 1
	    AV *const trie_words = (AV *) ri->data->data[n + TRIE_WORDS_OFFSET];
d10046 1
a10046 1
            sv_setpvn(sv, "", 0);
@


1.12
log
@Fix potential heap overflow given a specially crafted regexp.
From Tavis Ormandy; adapted from fixes in the perl 5.9.x codebase.
@
text
@d33 1
a33 23
/* need to replace pregcomp et al, so enable that */
#  ifndef PERL_IN_XSUB_RE
#    define PERL_IN_XSUB_RE
#  endif
/* need access to debugger hooks */
#  if defined(PERL_EXT_RE_DEBUG) && !defined(DEBUGGING)
#    define DEBUGGING
#  endif
#endif

#ifdef PERL_IN_XSUB_RE
/* We *really* need to overwrite these symbols: */
#  define Perl_pregcomp my_regcomp
#  define Perl_regdump my_regdump
#  define Perl_regprop my_regprop
#  define Perl_pregfree my_regfree
#  define Perl_re_intuit_string my_re_intuit_string
/* *These* symbols are masked to allow static link. */
#  define Perl_regnext my_regnext
#  define Perl_save_re_context my_save_re_context
#  define Perl_reginitcolors my_reginitcolors

#  define PERL_NO_GET_CONTEXT
d60 1
a60 1
 ****    2000, 2001, 2002, 2003, 2004, 2005, 2006, by Larry Wall and others
d79 5
a83 1
#include "regcomp.h"
d105 2
a106 1
    regexp	*rx;
d112 1
d118 3
a120 1
    I32		npar;			/* () count. */
d124 12
a135 2
    I32		utf8;
    I32		orig_utf8;
d140 8
d153 1
d158 3
a160 1
#define RExC_offsets	(pRExC_state->rx->offsets) /* I am not like the others */
d163 1
d169 1
d174 9
a182 1
#define RExC_orig_utf8 (pRExC_state->orig_utf8)
d195 96
a290 4
#define	HASWIDTH	0x1	/* Known to match non-null strings. */
#define	SIMPLE		0x2	/* Simple enough to be STAR/PLUS operand. */
#define	SPSTART		0x4	/* Starts with * or +. */
#define TRYAGAIN	0x8	/* Weeded out a declaration. */
d292 1
a292 1
/* Length of a variant. */
d295 2
a296 2
    I32 len_min;
    I32 len_delta;
d300 1
a300 1
    I32 last_end;			/* min value, <0 unless valid. */
d303 10
a312 6
    SV **longest;			/* Either &l_fixed, or &l_float. */
    SV *longest_fixed;
    I32 offset_fixed;
    SV *longest_float;
    I32 offset_float_min;
    I32 offset_float_max;
d324 1
a324 1
  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
d327 2
a328 2
#define SF_BEFORE_SEOL		0x1
#define SF_BEFORE_MEOL		0x2
d345 5
a349 5
#define SF_IS_INF		0x40
#define SF_HAS_PAR		0x80
#define SF_IN_PAR		0x100
#define SF_HAS_EVAL		0x200
#define SCF_DO_SUBSTR		0x400
d355 3
d359 2
a360 2
#define LOC ((RExC_flags & PMf_LOCALE) != 0)
#define FOLD ((RExC_flags & PMf_FOLD) != 0)
d387 1
a387 21
#define	FAIL(msg) STMT_START {						\
    const char *ellipses = "";						\
    IV len = RExC_end - RExC_precomp;					\
									\
    if (!SIZE_ONLY)							\
	SAVEDESTRUCTOR_X(clear_re,(void*)RExC_rx);			\
    if (len > RegexLengthToShowInErrorMessages) {			\
	/* chop 10 shorter than the max, to ensure meaning of "..." */	\
	len = RegexLengthToShowInErrorMessages - 10;			\
	ellipses = "...";						\
    }									\
    Perl_croak(aTHX_ "%s in regex m/%.*s%s/",				\
	    msg, (int)len, RExC_precomp, ellipses);			\
} STMT_END

/*
 * Calls SAVEDESTRUCTOR_X if needed, then calls Perl_croak with the given
 * args. Show regex, up to a maximum length. If it's too long, chop and add
 * "...".
 */
#define	FAIL2(pat,msg) STMT_START {					\
d398 1
a398 2
    S_re_croak2(aTHX_ pat, " in regex m/%.*s%s/",			\
	    msg, (int)len, RExC_precomp, ellipses);			\
d401 7
d521 1
d523 15
a537 5

#define MJD_OFFSET_DEBUG(x)
/* #define MJD_OFFSET_DEBUG(x) Perl_warn_nocontext x */


d541 1
a541 1
		__LINE__, (node), (byte)));				\
d576 44
d623 1
a623 1
   Updata the longest found anchored substring and the longest found
d627 1
a627 1
S_scan_commit(pTHX_ RExC_state_t *pRExC_state, scan_data_t *data)
d631 1
d642 2
d645 1
a645 1
	else {
d650 1
a650 1
	    if ((U32)data->offset_float_max > (U32)I32_MAX)
d657 2
d664 5
a668 4
	MAGIC * const mg =
	    SvUTF8(sv) && SvMAGICAL(sv) ? mg_find(sv, PERL_MAGIC_utf8) : NULL;
	if (mg && mg->mg_len > 0)
	    mg->mg_len = 0;
d672 1
d677 1
a677 1
S_cl_anything(pTHX_ RExC_state_t *pRExC_state, struct regnode_charclass_class *cl)
d688 1
a688 1
S_cl_is_anything(pTHX_ const struct regnode_charclass_class *cl)
d697 1
a697 1
    if (!ANYOF_BITMAP_TESTALLSET(cl))
d704 1
a704 1
S_cl_init(pTHX_ RExC_state_t *pRExC_state, struct regnode_charclass_class *cl)
d712 1
a712 1
S_cl_init_zero(pTHX_ RExC_state_t *pRExC_state, struct regnode_charclass_class *cl)
d724 1
a724 1
S_cl_and(pTHX_ struct regnode_charclass_class *cl,
d727 2
d763 1
a763 1
S_cl_or(pTHX_ RExC_state_t *pRExC_state, struct regnode_charclass_class *cl, const struct regnode_charclass_class *or_with)
d820 157
d978 67
a1044 8
 * There are strange code-generation bugs caused on sparc64 by gcc-2.95.2.
 * These need to be revisited when a newer toolchain becomes available.
 */
#if defined(__sparc64__) && defined(__GNUC__)
#   if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 96)
#       undef  SPARC64_GCC_WORKAROUND
#       define SPARC64_GCC_WORKAROUND 1
#   endif
d1047 222
a1268 2
/* REx optimizer.  Converts nodes into quickier variants "in place".
   Finds fixed substrings.  */
d1270 12
a1281 2
/* Stops at toplevel WHILEM as well as at "last". At end *scanp is set
   to the position after last scanned or to NULL. */
d1284 1
a1284 4
S_study_chunk(pTHX_ RExC_state_t *pRExC_state, regnode **scanp, I32 *deltap, regnode *last, scan_data_t *data, U32 flags)
			/* scanp: Start here (read-write). */
			/* deltap: Write maxlen-minlen here. */
			/* last: Stop before this one. */
d1286 22
a1307 11
    I32 min = 0, pars = 0, code;
    regnode *scan = *scanp, *next;
    I32 delta = 0;
    int is_inf = (flags & SCF_DO_SUBSTR) && (data->flags & SF_IS_INF);
    int is_inf_internal = 0;		/* The studied chunk is infinite */
    I32 is_par = OP(scan) == OPEN ? ARG(scan) : 0;
    scan_data_t data_fake;
    struct regnode_charclass_class and_with; /* Valid if flags & SCF_DO_STCLASS_OR */

    while (scan && OP(scan) != END && scan < last) {
	/* Peephole optimizer: */
a1308 4
	if (PL_regkind[(U8)OP(scan)] == EXACT) {
	    /* Merge several consecutive EXACTish nodes into one. */
	    regnode *n = regnext(scan);
	    U32 stringok = 1;
d1310 8
a1317 1
	    regnode *stop = scan;
d1319 166
d1486 410
a1895 12
	    next = scan + NODE_SZ_STR(scan);
	    /* Skip NOTHING, merge EXACT*. */
	    while (n &&
		   ( PL_regkind[(U8)OP(n)] == NOTHING ||
		     (stringok && (OP(n) == OP(scan))))
		   && NEXT_OFF(n)
		   && NEXT_OFF(scan) + NEXT_OFF(n) < I16_MAX) {
		if (OP(n) == TAIL || n > next)
		    stringok = 0;
		if (PL_regkind[(U8)OP(n)] == NOTHING) {
		    NEXT_OFF(scan) += NEXT_OFF(n);
		    next = n + NODE_STEP_REGNODE;
d1897 120
a2016 2
		    if (stringok)
			stop = n;
d2018 1
a2018 1
		    n = regnext(n);
d2020 79
a2098 3
		else if (stringok) {
		    const int oldl = STR_LEN(scan);
		    regnode *nnext = regnext(n);
d2100 17
a2116 7
		    if (oldl + STR_LEN(n) > U8_MAX)
			break;
		    NEXT_OFF(scan) += NEXT_OFF(n);
		    STR_LEN(scan) += STR_LEN(n);
		    next = n + NODE_SZ_STR(n);
		    /* Now we can overwrite *n : */
		    Move(STRING(n), STRING(scan) + oldl, STR_LEN(n), char);
d2118 49
a2166 1
		    stop = next - 1;
a2167 3
		    n = nnext;
		}
	    }
a2168 3
	    if (UTF && OP(scan) == EXACTF && STR_LEN(scan) >= 6) {
/*
  Two problematic code points in Unicode casefolding of EXACT nodes:
d2170 66
a2235 2
   U+0390 - GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS
   U+03B0 - GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS
a2236 1
   which casefold to
d2238 10
a2247 1
   Unicode			UTF-8
d2249 9
a2257 2
   U+03B9 U+0308 U+0301		0xCE 0xB9 0xCC 0x88 0xCC 0x81
   U+03C5 U+0308 U+0301		0xCF 0x85 0xCC 0x88 0xCC 0x81
a2258 5
   This means that in case-insensitive matching (or "loose matching",
   as Unicode calls it), an EXACTF of length six (the UTF-8 encoded byte
   length of the above casefolded versions) can match a target string
   of length two (the byte length of UTF-8 encoded U+0390 or U+03B0).
   This would rather mess up the minimum length computation.
a2259 3
   What we'll do is to look for the tail four bytes, and then peek
   at the preceding two bytes to see whether we need to decrease
   the minimum length by four (six minus two).
a2260 3
   Thanks to the design of UTF-8, there cannot be false matches:
   A sequence of valid UTF-8 bytes cannot be a subsequence of
   another valid sequence of UTF-8 bytes.
a2261 14
*/
		 char *s0 = STRING(scan), *s, *t;
		 char *s1 = s0 + STR_LEN(scan) - 1, *s2 = s1 - 4;
		 const char * const t0 = "\xcc\x88\xcc\x81";
		 const char * const t1 = t0 + 3;

		 for (s = s0 + 2;
		      s < s2 && (t = ninstr(s, s1, t0, t1));
		      s = t + 4) {
		      if (((U8)t[-1] == 0xB9 && (U8)t[-2] == 0xCE) ||
			  ((U8)t[-1] == 0x85 && (U8)t[-2] == 0xCF))
			   min -= 4;
		 }
	    }
d2263 57
d2321 14
a2334 8
	    /* Allow dumping */
	    n = scan + NODE_SZ_STR(scan);
	    while (n <= stop) {
		if (PL_regkind[(U8)OP(n)] != NOTHING || OP(n) == NOTHING) {
		    OP(n) = OPTIMIZED;
		    NEXT_OFF(n) = 0;
		}
		n++;
d2336 2
d2339 172
a2510 1
	}
d2524 1
a2524 1
		   && ((PL_regkind[(U8)OP(n)] == NOTHING && (noff = NEXT_OFF(n)))
d2533 3
d2539 1
a2539 1
		   || OP(scan) == IFTHEN || OP(scan) == SUSPEND) {
d2542 1
d2544 4
a2547 1
	    if (OP(next) == code || code == IFTHEN || code == SUSPEND) {
d2550 1
d2552 2
a2553 2
		if (flags & SCF_DO_SUBSTR) /* XXXX Add !SUSPEND? */
		    scan_commit(pRExC_state, data); /* Cannot merge strings after this. */
d2556 1
d2563 1
a2563 1
		    if (data) {		
d2569 2
d2579 1
a2579 1
		    }		
d2582 1
d2584 3
a2586 2
		    minnext = study_chunk(pRExC_state, &scan, &deltanext,
					  next, &data_fake, f);
d2596 10
a2605 3
		    if (data && (data_fake.flags & SF_HAS_EVAL))
			data->flags |= SF_HAS_EVAL;
		    if (data)
d2607 1
a2609 2
		    if (code == SUSPEND)
			break;
d2624 1
a2624 1
			cl_and(data->start_class, &and_with);
d2636 2
a2637 1
			StructCopy(data->start_class, &and_with,
d2647 204
d2852 1
a2852 1
	    else if (code == BRANCHJ)	/* single branch is optimized. */
d2854 1
a2854 1
	    else			/* single branch is optimized. */
d2857 57
d2917 1
a2917 1
	    UV uc = *((U8*)STRING(scan));
d2920 4
a2923 2
		l = utf8_length((U8 *)s, (U8 *)s + l);
		uc = utf8_to_uvchr((U8 *)s, NULL);
d2935 2
a2944 2
		if (UTF)
		    SvUTF8_on(data->last_found);
d2975 1
a2975 1
		cl_and(data->start_class, &and_with);
d2979 1
a2979 1
	else if (PL_regkind[(U8)OP(scan)] == EXACT) { /* But OP != EXACT! */
d2984 4
a2987 2
	    if (flags & SCF_DO_SUBSTR)
		scan_commit(pRExC_state, data);
d2989 1
a2989 1
		U8 *s = (U8 *)STRING(scan);
d2994 1
a2994 1
	    if (data && (flags & SCF_DO_SUBSTR))
d3023 1
a3023 1
		cl_and(data->start_class, &and_with);
d3030 1
a3030 1
	    regnode *oscan = scan;
d3035 1
a3035 1
	    switch (PL_regkind[(U8)OP(scan)]) {
d3065 1
a3065 1
		    scan_commit(pRExC_state, data); /* Cannot extend fixed substrings */
d3070 9
a3078 2
		mincount = ARG1(scan);
		maxcount = ARG2(scan);
d3082 1
a3082 2

		    scan->flags = ((lp <= U8_MAX) ? lp : U8_MAX);
d3088 1
a3088 1
		    if (mincount == 0) scan_commit(pRExC_state,data); /* Cannot extend fixed substrings */
d3114 4
a3117 3
		minnext = study_chunk(pRExC_state, &scan, &deltanext, last, data,
				      mincount == 0
					? (f & ~SCF_DO_SUBSTR) : f);
d3128 2
a3129 1
			StructCopy(data->start_class, &and_with,
d3140 1
a3140 1
			cl_and(data->start_class, &and_with);
d3173 1
a3173 1
		    regnode *nxt1 = nxt;
d3181 1
a3181 1
			&& !(PL_regkind[(U8)OP(nxt)] == EXACT
d3190 4
d3198 1
d3235 4
d3241 1
d3264 2
a3265 2
			study_chunk(pRExC_state, &nxt1, &deltanext, nxt,
				    NULL, 0);
d3289 1
a3289 1
		    SV *last_str = Nullsv;
d3312 1
a3312 1
			const char *s = SvPV_const(data->last_found, l);
d3341 1
a3341 1
					mg->mg_len += CHR_SVLEN(last_str);
d3359 1
a3359 1
			scan_commit(pRExC_state,data);
d3361 7
a3367 1
			    sv_setsv(data->last_found, last_str);
d3384 1
a3384 1
		    while (PL_regkind[(U8)OP(next = regnext(oscan))] == NOTHING
d3391 1
a3391 1
		    scan_commit(pRExC_state,data);	/* Cannot expect anything... */
d3401 40
d3445 1
a3445 1
		scan_commit(pRExC_state,data);
d3454 1
a3454 1
		switch (PL_regkind[(U8)OP(scan)]) {
d3635 3
d3640 1
a3640 1
		    cl_and(data->start_class, &and_with);
d3644 1
a3644 1
	else if (PL_regkind[(U8)OP(scan)] == EOL && flags & SCF_DO_SUBSTR) {
d3649 1
a3649 1
	else if (  PL_regkind[(U8)OP(scan)] == BRANCHJ
d3653 155
a3807 45
	    /* Lookahead/lookbehind */
	    I32 deltanext, minnext, fake = 0;
	    regnode *nscan;
	    struct regnode_charclass_class intrnl;
	    int f = 0;

	    data_fake.flags = 0;
	    if (data) {		
		data_fake.whilem_c = data->whilem_c;
		data_fake.last_closep = data->last_closep;
	    }
	    else
		data_fake.last_closep = &fake;
	    if ( flags & SCF_DO_STCLASS && !scan->flags
		 && OP(scan) == IFMATCH ) { /* Lookahead */
		cl_init(pRExC_state, &intrnl);
		data_fake.start_class = &intrnl;
		f |= SCF_DO_STCLASS_AND;
	    }
	    if (flags & SCF_WHILEM_VISITED_POS)
		f |= SCF_WHILEM_VISITED_POS;
	    next = regnext(scan);
	    nscan = NEXTOPER(NEXTOPER(scan));
	    minnext = study_chunk(pRExC_state, &nscan, &deltanext, last, &data_fake, f);
	    if (scan->flags) {
		if (deltanext) {
		    vFAIL("Variable length lookbehind not implemented");
		}
		else if (minnext > U8_MAX) {
		    vFAIL2("Lookbehind longer than %"UVuf" not implemented", (UV)U8_MAX);
		}
		scan->flags = (U8)minnext;
	    }
	    if (data && data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))
		pars++;
	    if (data && (data_fake.flags & SF_HAS_EVAL))
		data->flags |= SF_HAS_EVAL;
	    if (data)
		data->whilem_c = data_fake.whilem_c;
	    if (f & SCF_DO_STCLASS_AND) {
		const int was = (data->start_class->flags & ANYOF_EOS);

		cl_and(data->start_class, &intrnl);
		if (was)
		    data->start_class->flags |= ANYOF_EOS;
d3809 1
d3812 2
a3813 1
	    pars++;
d3816 3
d3832 13
a3844 1
	else if (OP(scan) == LOGICAL && scan->flags == 2) { /* Embedded follows */
d3846 1
a3846 1
		    scan_commit(pRExC_state,data);
d3854 155
d4012 7
d4021 3
d4028 1
a4028 1
    if (is_par > U8_MAX)
d4039 7
a4045 2
	cl_and(data->start_class, &and_with);
    return min;
d4048 2
a4049 2
STATIC I32
S_add_data(pTHX_ RExC_state_t *pRExC_state, I32 n, const char *s)
d4051 12
a4062 15
    if (RExC_rx->data) {
	Renewc(RExC_rx->data,
	       sizeof(*RExC_rx->data) + sizeof(void*) * (RExC_rx->data->count + n - 1),
	       char, struct reg_data);
	Renew(RExC_rx->data->what, RExC_rx->data->count + n, U8);
	RExC_rx->data->count += n;
    }
    else {
	Newxc(RExC_rx->data, sizeof(*RExC_rx->data) + sizeof(void*) * (n - 1),
	     char, struct reg_data);
	Newx(RExC_rx->data->what, n, U8);
	RExC_rx->data->count = n;
    }
    Copy(s, RExC_rx->data->what + RExC_rx->data->count - n, n, U8);
    return RExC_rx->data->count - n;
d4065 2
d4070 1
d4092 2
d4095 9
d4120 36
a4155 2
regexp *
Perl_pregcomp(pTHX_ char *exp, char *xend, PMOP *pm)
d4157 6
a4162 1
    register regexp *r;
a4163 1
    regnode *first;
d4170 16
a4185 12
    RExC_state_t *pRExC_state = &RExC_state;

    if (exp == NULL)
	FAIL("NULL regexp argument");

    RExC_orig_utf8 = RExC_utf8 = pm->op_pmdynflags & PMdf_CMP_UTF8;

    DEBUG_r({
	 if (!PL_colorset) reginitcolors();
	 PerlIO_printf(Perl_debug_log, "%sCompiling REx%s `%s%*s%s'\n",
		       PL_colors[4],PL_colors[5],PL_colors[0],
		       (int)(xend - exp), exp, PL_colors[1]);
d4190 1
a4190 1
    RExC_flags = pm->op_pmflags;
d4204 1
d4208 11
d4223 3
a4225 2
    if (reg(pRExC_state, 0, &flags) == NULL) {
	RExC_precomp = Nullch;
d4229 26
a4254 12
    	STRLEN len = xend-exp;
    	DEBUG_r(PerlIO_printf(Perl_debug_log,
	   "UTF8 mismatch! Converting to utf8 for resizing and compile\n"));
	exp = (char*)Perl_bytes_to_utf8(aTHX_ (U8*)exp, &len);
	xend = exp + len;
	RExC_orig_utf8 = RExC_utf8;
	SAVEFREEPV(exp);
	goto redo_first_pass;
    }

    DEBUG_r(PerlIO_printf(Perl_debug_log, "size %"IVdf" ", (IV)RExC_size));

d4264 7
a4270 4
    /* Allocate space and initialize. */
    Newxc(r, sizeof(regexp) + (unsigned)RExC_size * sizeof(regnode),
	 char, regexp);
    if (r == NULL)
a4271 1

d4274 4
a4277 1
    Zero(r, sizeof(regexp) + (unsigned)RExC_size * sizeof(regnode), char);
d4279 4
d4284 47
a4330 4
    r->prelen = xend - exp;
    r->precomp = savepvn(RExC_precomp, r->prelen);
    r->subbeg = NULL;
    r->reganch = pm->op_pmflags & PMf_COMPILETIME;
d4332 7
d4340 4
a4343 9
    r->substrs = 0;			/* Useful during FAIL. */
    r->startp = 0;			/* Useful during FAIL. */
    r->endp = 0;			/* Useful during FAIL. */

    Newxz(r->offsets, 2*RExC_size+1, U32); /* MJD 20001228 */
    if (r->offsets) {
	r->offsets[0] = RExC_size;
    }
    DEBUG_r(PerlIO_printf(Perl_debug_log, 
d4345 1
a4345 1
                          r->offsets ? "Got" : "Couldn't get",
d4347 2
a4348 1

d4350 1
d4353 1
a4353 1
    RExC_flags = pm->op_pmflags;	/* don't let top level (?i) bleed */
d4358 4
a4361 2
    RExC_emit_start = r->program;
    RExC_emit = r->program;
d4363 1
a4363 1
    RExC_emit->next_off = (U16)((RExC_seen_evals > U16_MAX) ? U16_MAX : RExC_seen_evals);
d4365 2
a4366 2
    r->data = 0;
    if (reg(pRExC_state, 0, &flags) == NULL)
d4368 36
d4406 3
a4408 2
    r->reganch = pm->op_pmflags & PMf_COMPILETIME; /* Again? */
    pm->op_pmflags = RExC_flags;
d4410 2
a4411 2
        r->reganch |= ROPT_UTF8;	/* Unicode in it? */
    r->regstclass = NULL;
d4413 2
a4414 6
	r->reganch |= ROPT_NAUGHTY;
    scan = r->program + 1;		/* First BRANCH. */

    /* XXXX To minimize changes to RE engine we always allocate
       3-units-long substrs field. */
    Newxz(r->substrs, 1, struct reg_substr_data);
d4416 3
a4418 3
    StructCopy(&zero_scan_data, &data, scan_data_t);
    /* XXXX Should not we check for something else?  Usually it is OPEN1... */
    if (OP(scan) != BRANCH) {	/* Only one top-level choice. */
d4421 1
a4421 1
	struct regnode_charclass_class ch_class;
d4423 4
a4426 3
	I32 last_close = 0;

	first = scan;
d4430 3
a4432 1
	    (OP(first) == BRANCH && OP(regnext(first)) != BRANCH) ||
d4436 4
a4439 1
	    (PL_regkind[(U8)OP(first)] == CURLY && ARG1(first) > 0) ) {
d4443 7
a4449 2
		    first += regarglen[(U8)OP(first)];
		first = NEXTOPER(first);
d4454 3
a4456 1
	if (PL_regkind[(U8)OP(first)] == EXACT) {
d4458 1
a4458 1
	        ;	/* Empty, get anchored substr later. */
d4460 1
a4460 1
		r->regstclass = first;
d4462 22
d4485 7
a4491 7
	    r->regstclass = first;
	else if (PL_regkind[(U8)OP(first)] == BOUND ||
		 PL_regkind[(U8)OP(first)] == NBOUND)
	    r->regstclass = first;
	else if (PL_regkind[(U8)OP(first)] == BOL) {
	    r->reganch |= (OP(first) == MBOL
			   ? ROPT_ANCH_MBOL
d4493 2
a4494 2
			      ? ROPT_ANCH_SBOL
			      : ROPT_ANCH_BOL));
d4499 1
a4499 1
	    r->reganch |= ROPT_ANCH_GPOS;
d4503 4
a4506 3
	else if (!sawopen && (OP(first) == STAR &&
	    PL_regkind[(U8)OP(NEXTOPER(first))] == REG_ANY) &&
	    !(r->reganch & ROPT_ANCH) )
d4511 4
a4514 3
		    ? ROPT_ANCH_MBOL
		    : ROPT_ANCH_SBOL;
	    r->reganch |= type | ROPT_IMPLICIT;
d4521 1
a4521 1
	    r->reganch |= ROPT_SKIP;
d4524 14
a4537 2
	DEBUG_r(PerlIO_printf(Perl_debug_log, "first at %"IVdf"\n",
			      (IV)(first - scan + 1)));
d4549 4
a4552 5
	minlen = 0;

	data.longest_fixed = newSVpvn("",0);
	data.longest_float = newSVpvn("",0);
	data.last_found = newSVpvn("",0);
d4555 1
a4555 1
	if (!r->regstclass) {
d4562 8
a4570 2
	minlen = study_chunk(pRExC_state, &first, &fake, scan + RExC_size, /* Up to end */
			     &data, SCF_DO_SUBSTR | SCF_WHILEM_VISITED_POS | stclass_flag);
d4574 4
a4577 3
	     && (!(RExC_seen & REG_SEEN_GPOS) || (r->reganch & ROPT_ANCH_GPOS)))
	    r->reganch |= ROPT_CHECK_ALL;
	scan_commit(pRExC_state, &data);
d4580 4
d4588 3
a4590 2
		    || (RExC_flags & PMf_MULTILINE)))) {
	    int t;
d4592 1
a4592 1
	    if (SvCUR(data.longest_fixed) 			/* ok to leave SvCUR */
d4597 2
d4601 1
a4601 1
		r->float_substr = Nullsv;
d4604 1
a4604 1
		r->float_utf8 = Nullsv;
d4606 10
a4615 1
	    r->float_min_offset = data.offset_float_min;
d4617 3
d4622 1
a4622 1
			   || (RExC_flags & PMf_MULTILINE)));
d4627 1
a4627 1
	    r->float_substr = r->float_utf8 = Nullsv;
d4632 4
d4640 3
a4642 2
		    || (RExC_flags & PMf_MULTILINE)))) {
	    int t;
d4644 2
d4648 1
a4648 1
		r->anchored_substr = Nullsv;
d4651 1
a4651 1
		r->anchored_utf8 = Nullsv;
d4653 11
a4663 1
	    r->anchored_offset = data.offset_fixed;
d4666 1
a4666 1
		     || (RExC_flags & PMf_MULTILINE)));
d4670 1
a4670 1
	    r->anchored_substr = r->anchored_utf8 = Nullsv;
d4674 3
a4676 3
	if (r->regstclass
	    && (OP(r->regstclass) == REG_ANY || OP(r->regstclass) == SANY))
	    r->regstclass = NULL;
d4678 536
a5213 5
	    && stclass_flag
	    && !(data.start_class->flags & ANYOF_EOS)
	    && !cl_is_anything(data.start_class))
	{
	    const I32 n = add_data(pRExC_state, 1, "f");
d5215 7
a5221 14
	    Newx(RExC_rx->data->data[n], 1,
		struct regnode_charclass_class);
	    StructCopy(data.start_class,
		       (struct regnode_charclass_class*)RExC_rx->data->data[n],
		       struct regnode_charclass_class);
	    r->regstclass = (regnode*)RExC_rx->data->data[n];
	    r->reganch &= ~ROPT_SKIP;	/* Used in find_byclass(). */
	    PL_regdata = r->data; /* for regprop() */
	    DEBUG_r({ SV *sv = sv_newmortal();
	              regprop(sv, (regnode*)data.start_class);
		      PerlIO_printf(Perl_debug_log,
				    "synthetic stclass \"%s\".\n",
				    SvPVX_const(sv));});
	}
d5223 18
a5240 21
	/* A temporary algorithm prefers floated substr to fixed one to dig more info. */
	if (longest_fixed_length > longest_float_length) {
	    r->check_substr = r->anchored_substr;
	    r->check_utf8 = r->anchored_utf8;
	    r->check_offset_min = r->check_offset_max = r->anchored_offset;
	    if (r->reganch & ROPT_ANCH_SINGLE)
		r->reganch |= ROPT_NOSCAN;
	}
	else {
	    r->check_substr = r->float_substr;
	    r->check_utf8 = r->float_utf8;
	    r->check_offset_min = data.offset_float_min;
	    r->check_offset_max = data.offset_float_max;
	}
	/* XXXX Currently intuiting is not compatible with ANCH_GPOS.
	   This should be changed ASAP!  */
	if ((r->check_substr || r->check_utf8) && !(r->reganch & ROPT_ANCH_GPOS)) {
	    r->reganch |= RE_USE_INTUIT;
	    if (SvTAIL(r->check_substr ? r->check_substr : r->check_utf8))
		r->reganch |= RE_INTUIT_TAIL;
	}
a5241 18
    else {
	/* Several toplevels. Best we can is to set minlen. */
	I32 fake;
	struct regnode_charclass_class ch_class;
	I32 last_close = 0;
	
	DEBUG_r(PerlIO_printf(Perl_debug_log, "\n"));
	scan = r->program + 1;
	cl_init(pRExC_state, &ch_class);
	data.start_class = &ch_class;
	data.last_closep = &last_close;
	minlen = study_chunk(pRExC_state, &scan, &fake, scan + RExC_size, &data, SCF_DO_STCLASS_AND|SCF_WHILEM_VISITED_POS);
	r->check_substr = r->check_utf8 = r->anchored_substr = r->anchored_utf8
		= r->float_substr = r->float_utf8 = Nullsv;
	if (!(data.start_class->flags & ANYOF_EOS)
	    && !cl_is_anything(data.start_class))
	{
	    const I32 n = add_data(pRExC_state, 1, "f");
d5243 24
a5266 13
	    Newx(RExC_rx->data->data[n], 1,
		struct regnode_charclass_class);
	    StructCopy(data.start_class,
		       (struct regnode_charclass_class*)RExC_rx->data->data[n],
		       struct regnode_charclass_class);
	    r->regstclass = (regnode*)RExC_rx->data->data[n];
	    r->reganch &= ~ROPT_SKIP;	/* Used in find_byclass(). */
	    DEBUG_r({ SV* sv = sv_newmortal();
	              regprop(sv, (regnode*)data.start_class);
		      PerlIO_printf(Perl_debug_log,
				    "synthetic stclass \"%s\".\n",
				    SvPVX_const(sv));});
	}
d5268 38
a5306 15
    r->minlen = minlen;
    if (RExC_seen & REG_SEEN_GPOS)
	r->reganch |= ROPT_GPOS_SEEN;
    if (RExC_seen & REG_SEEN_LOOKBEHIND)
	r->reganch |= ROPT_LOOKBEHIND_SEEN;
    if (RExC_seen & REG_SEEN_EVAL)
	r->reganch |= ROPT_EVAL_SEEN;
    if (RExC_seen & REG_SEEN_CANY)
	r->reganch |= ROPT_CANY_SEEN;
    Newxz(r->startp, RExC_npar, I32);
    Newxz(r->endp, RExC_npar, I32);
    PL_regdata = r->data; /* for regprop() */
    DEBUG_r(regdump(r));
    return(r);
}
d5308 8
d5325 7
d5333 1
a5333 1
S_reg(pTHX_ RExC_state_t *pRExC_state, I32 paren, I32 *flagp)
d5336 1
d5340 1
a5340 1
    register regnode *ender = 0;
d5342 6
a5347 1
    I32 flags, oregflags = RExC_flags, have_branch = 0, open = 0;
d5352 5
a5356 5
    I32 wastedflags = 0x00,
        wasted_o    = 0x01,
        wasted_g    = 0x02,
        wasted_gc   = 0x02 | 0x04,
        wasted_c    = 0x04;
d5360 3
a5362 1
    char c;
d5369 105
d5475 1
a5475 3
	    U32 posflags = 0, negflags = 0;
	    U32 *flagsp = &posflags;
	    int logical = 0;
d5482 39
a5520 2
	    case '<':           /* (?<...) */
		RExC_seen |= REG_SEEN_LOOKBEHIND;
d5523 80
a5602 2
		if (*RExC_parse != '=' && *RExC_parse != '!')
		    goto unknown;
d5607 12
d5634 92
a5725 4
	    case 'p':           /* (?p...) */
		if (SIZE_ONLY && ckWARN2(WARN_DEPRECATED, WARN_REGEXP))
		    vWARNdep(RExC_parse, "(?p{}) is deprecated - use (??{})");
		/* FALL THROUGH*/
d5727 7
a5733 3
		logical = 1;
		if (*RExC_parse != '{')
		    goto unknown;
d5738 2
a5739 1
		I32 count = 1, n = 0;
a5741 2
		SV *sv;
		OP_4tree *sop, *rop;
d5746 4
a5749 2
		    if (c == '\\' && RExC_parse[1])
			RExC_parse++;
d5756 1
a5756 2
		if (*RExC_parse != ')')
		{
d5762 2
a5763 5
		
		    if (RExC_parse - 1 - s)
			sv = newSVpvn(s, RExC_parse - 1 - s);
		    else
			sv = newSVpvn("", 0);
d5774 3
a5776 3
		    RExC_rx->data->data[n] = (void*)rop;
		    RExC_rx->data->data[n+1] = (void*)sop;
		    RExC_rx->data->data[n+2] = (void*)pad;
d5787 4
d5792 1
a5792 1
		
d5794 1
a5794 1
		if (logical) {
d5798 1
a5798 1
		    regtail(pRExC_state, ret, reganode(pRExC_state, EVAL, n));
d5809 1
d5819 1
a5819 1
			regtail(pRExC_state, ret, reg(pRExC_state, 1, &flag));
d5823 49
d5874 1
d5881 1
d5885 2
a5886 2
		    regtail(pRExC_state, ret, reganode(pRExC_state, IFTHEN, 0));
		    br = regbranch(pRExC_state, &flags, 1);
d5890 1
a5890 1
			regtail(pRExC_state, br, reganode(pRExC_state, LONGJMP, 0));
d5895 2
d5898 2
a5899 2
			regbranch(pRExC_state, &flags, 1);
			regtail(pRExC_state, ret, lastbr);
d5909 1
a5909 1
		    regtail(pRExC_state, br, ender);
d5911 2
a5912 2
			regtail(pRExC_state, lastbr, ender);
			regtail(pRExC_state, NEXTOPER(NEXTOPER(lastbr)), ender);
d5915 4
a5918 1
			regtail(pRExC_state, ret, ender);
d5930 8
a5937 3
		--RExC_parse;
	      parse_flags:      /* (?i) */
		while (*RExC_parse && strchr("iogcmsx", *RExC_parse)) {
d5940 4
a5943 2

		    if (*RExC_parse == 'o' || *RExC_parse == 'g') {
d5945 1
a5945 1
			    I32 wflagbit = *RExC_parse == 'o' ? wasted_o : wasted_g;
d5958 3
a5960 2
		    }
		    else if (*RExC_parse == 'c') {
d5962 2
a5963 2
			    if (! (wastedflags & wasted_c) ) {
				wastedflags |= wasted_gc;
d5972 42
a6013 8
		    }
		    else { pmflag(flagsp, *RExC_parse); }

		    ++RExC_parse;
		}
		if (*RExC_parse == '-') {
		    flagsp = &negflags;
		    wastedflags = 0;  /* reset so (?g-c) warns twice */
a6014 13
		    goto parse_flags;
		}
		RExC_flags |= posflags;
		RExC_flags &= ~negflags;
		if (*RExC_parse == ':') {
		    RExC_parse++;
		    paren = ':';
		    break;
		}		
	      unknown:
		if (*RExC_parse != ')') {
		    RExC_parse++;
		    vFAIL3("Sequence (%.*s...) not recognized", RExC_parse-seqstart, seqstart);
d6016 1
a6016 4
		nextchar(pRExC_state);
		*flagp = TRYAGAIN;
		return NULL;
	    }
d6019 1
d6022 1
d6024 12
d6038 1
a6038 1
	    open = 1;
d6043 2
a6044 1

d6047 1
a6047 1
    br = regbranch(pRExC_state, &flags, 1);
d6054 1
a6054 1
	    reginsert(pRExC_state, BRANCHJ, br);
d6057 1
a6057 1
	    reginsert(pRExC_state, BRANCH, br);
d6068 2
a6069 2
    if (open) {				/* Starts with OPEN. */
	regtail(pRExC_state, ret, br);		/* OPEN -> first. */
d6073 1
a6073 1
    *flagp |= flags & (SPSTART | HASWIDTH);
d6078 1
a6078 1
	    regtail(pRExC_state, NEXTOPER(NEXTOPER(lastbr)), ender); /* Append to the previous. */
d6083 6
a6088 1
	br = regbranch(pRExC_state, &flags, 0);
d6092 1
a6092 1
	regtail(pRExC_state, lastbr, br);		/* BRANCH -> BRANCH. */
d6094 1
a6094 3
	if (flags&HASWIDTH)
	    *flagp |= HASWIDTH;
	*flagp |= flags&SPSTART;
d6105 8
d6127 4
d6133 5
a6137 1
	regtail(pRExC_state, lastbr, ender);
a6138 1
	if (have_branch) {
d6140 8
a6147 2
	    for (br = ret; br != NULL; br = regnext(br)) {
		regoptail(pRExC_state, br, ender);
d6162 1
a6162 1
	    reginsert(pRExC_state, node,ret);
d6166 1
a6166 1
	    regtail(pRExC_state, ret, reg_node(pRExC_state, TAIL));
d6187 2
a6188 1

d6198 1
a6198 1
S_regbranch(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, I32 first)
d6200 1
d6205 2
d6228 1
a6228 1
	latest = regpiece(pRExC_state, &flags);
d6236 1
a6236 1
	*flagp |= flags&HASWIDTH;
d6241 1
a6241 1
	    regtail(pRExC_state, chain, latest);
d6255 1
a6255 1
    return(ret);
d6268 1
a6268 1
S_regpiece(pTHX_ RExC_state_t *pRExC_state, I32 *flagp)
d6270 1
a6275 1
    char *maxpos;
d6279 3
d6283 1
a6283 1
    ret = regatom(pRExC_state, &flags);
d6293 1
a6295 1
	maxpos = Nullch;
d6325 1
a6325 1
		reginsert(pRExC_state, CURLY, ret);
d6330 1
a6330 1
		regnode *w = reg_node(pRExC_state, WHILEM);
d6333 1
a6333 1
		regtail(pRExC_state, ret, w);
d6335 2
a6336 2
		    reginsert(pRExC_state, LONGJMP,ret);
		    reginsert(pRExC_state, NOTHING,ret);
d6339 1
a6339 1
		reginsert(pRExC_state, CURLYX,ret);
d6347 1
a6347 1
		regtail(pRExC_state, ret, reg_node(pRExC_state, NOTHING));
d6396 1
a6396 1
	reginsert(pRExC_state, STAR, ret);
d6405 1
a6405 1
	reginsert(pRExC_state, PLUS, ret);
d6418 1
a6418 1
    if (!SIZE_ONLY && !(flags&HASWIDTH) && max > REG_INFTY/3 && ckWARN(WARN_REGEXP)) {
d6421 1
a6421 1
	       RExC_parse - origparse,
d6425 1
a6425 1
    if (*RExC_parse == '?') {
d6427 16
a6442 2
	reginsert(pRExC_state, MINMOD, ret);
	regtail(pRExC_state, ret, ret + NODE_STEP_REGNODE);
d6444 2
a6445 1
    if (ISMULT2(RExC_parse)) {
d6453 272
d6726 1
a6726 1
 - regatom - the lowest level
d6728 3
a6730 4
 * Optimization:  gobbles an entire sequence of ordinary characters so that
 * it can turn them into a single node, which is smaller to store and
 * faster to run.  Backslashed characters are exceptions, each becoming a
 * separate node; the code is simpler that way and it's not worth fixing.
d6732 47
a6778 1
 * [Yes, it is worth fixing, some scripts can run twice the speed.] */
d6780 1
a6780 1
S_regatom(pTHX_ RExC_state_t *pRExC_state, I32 *flagp)
d6782 2
a6783 1
    register regnode *ret = 0;
d6786 3
a6789 1
    *flagp = WORST;		/* Tentatively. */
d6792 1
a6792 1
    switch (*RExC_parse) {
d6796 1
a6796 1
	if (RExC_flags & PMf_MULTILINE)
d6798 1
a6798 1
	else if (RExC_flags & PMf_SINGLELINE)
d6808 1
a6808 1
	if (RExC_flags & PMf_MULTILINE)
d6810 1
a6810 1
	else if (RExC_flags & PMf_SINGLELINE)
d6818 1
a6818 1
	if (RExC_flags & PMf_SINGLELINE)
d6828 2
a6829 2
	char *oregcomp_parse = ++RExC_parse;
	ret = regclass(pRExC_state);
d6841 1
a6841 1
	ret = reg(pRExC_state, 1, &flags);
d6853 1
a6853 1
	*flagp |= flags&(HASWIDTH|SPSTART|SIMPLE);
d6876 17
d6894 18
a6911 1
	switch (*++RExC_parse) {
d6916 1
a6916 3
	    nextchar(pRExC_state);
            Set_Node_Length(ret, 2); /* MJD */
	    break;
d6921 11
a6931 3
	    nextchar(pRExC_state);
            Set_Node_Length(ret, 2); /* MJD */
	    break;
d6936 1
a6936 2
	    nextchar(pRExC_state);
	    break;
d6941 1
a6941 3
	    nextchar(pRExC_state);
            Set_Node_Length(ret, 2); /* MJD */
	    break;
d6946 1
a6946 3
	    nextchar(pRExC_state);
            Set_Node_Length(ret, 2); /* MJD */
	    break;
d6950 1
a6950 3
	    nextchar(pRExC_state);
            Set_Node_Length(ret, 2); /* MJD */
	    break;
d6954 1
a6954 3
	    nextchar(pRExC_state);
            Set_Node_Length(ret, 2); /* MJD */
	    break;
d6958 1
a6958 3
	    nextchar(pRExC_state);
            Set_Node_Length(ret, 2); /* MJD */
	    break;
d6964 1
a6964 3
	    nextchar(pRExC_state);
            Set_Node_Length(ret, 2); /* MJD */
	    break;
d6970 1
a6970 3
	    nextchar(pRExC_state);
            Set_Node_Length(ret, 2); /* MJD */
	    break;
d6974 1
a6974 3
	    nextchar(pRExC_state);
            Set_Node_Length(ret, 2); /* MJD */
	    break;
d6978 1
a6978 3
	    nextchar(pRExC_state);
            Set_Node_Length(ret, 2); /* MJD */
	    break;
d6982 1
a6982 3
	    nextchar(pRExC_state);
            Set_Node_Length(ret, 2); /* MJD */
	    break;
d6986 21
d7009 1
a7009 1
	    break;
d7013 2
a7014 1
		char* oldregxend = RExC_end;
d7016 1
d7022 1
a7022 1
		        U8 c = (U8)*RExC_parse;
d7036 1
a7036 1
		ret = regclass(pRExC_state);
d7047 47
a7093 10
	case 'n':
	case 'r':
	case 't':
	case 'f':
	case 'e':
	case 'a':
	case 'x':
	case 'c':
	case '0':
	    goto defchar;
d7097 28
a7124 3
		const I32 num = atoi(RExC_parse);

		if (num > 9 && num >= RExC_npar)
d7127 1
a7127 1
                    char * parse_start = RExC_parse - 1; /* MJD */
d7130 11
a7140 3

		    if (!SIZE_ONLY && num > (I32)RExC_rx->nparens)
			vFAIL("Reference to nonexistent group");
d7168 2
a7169 3
	if (RExC_flags & PMf_EXTENDED) {
	    while (RExC_parse < RExC_end && *RExC_parse != '\n') RExC_parse++;
	    if (RExC_parse < RExC_end)
d7174 2
a7175 1
    default: {
d7179 1
a7179 1
	    char *oldp, *s;
d7196 1
a7196 1
		oldp = p;
d7198 8
a7205 3
		if (RExC_flags & PMf_EXTENDED)
		    p = regwhite(p, RExC_end);
		switch (*p) {
d7215 35
a7249 17
		    switch (*++p) {
		    case 'A':
		    case 'C':
		    case 'X':
		    case 'G':
		    case 'Z':
		    case 'z':
		    case 'w':
		    case 'W':
		    case 'b':
		    case 'B':
		    case 's':
		    case 'S':
		    case 'd':
		    case 'D':
		    case 'p':
		    case 'P':
d7252 4
d7304 2
d7325 11
d7352 1
a7352 1
					       &numlen, 0);
d7359 2
a7360 2
		if (RExC_flags & PMf_EXTENDED)
		    p = regwhite(p, RExC_end);
d7365 1
a7365 1
		if (ISMULT2(p)) { /* Back off on ?+*. */
a7368 2
		         STRLEN unilen;

d7377 1
a7377 1
					reguni(pRExC_state, ender, s, &unilen);
d7391 1
a7391 1
			      reguni(pRExC_state, ender, s, &unilen);
a7404 2
		     STRLEN unilen;

d7413 1
a7413 1
				    reguni(pRExC_state, ender, s, &unilen);
d7427 1
a7427 1
			  reguni(pRExC_state, ender, s, &unilen);
d7452 1
a7452 2
	    if (!SIZE_ONLY)
		STR_LEN(ret) = len;
d7455 2
a7456 1
	    else
d7458 1
a7462 26
    /* If the encoding pragma is in effect recode the text of
     * any EXACT-kind nodes. */
    if (PL_encoding && PL_regkind[(U8)OP(ret)] == EXACT) {
	STRLEN oldlen = STR_LEN(ret);
	SV *sv        = sv_2mortal(newSVpvn(STRING(ret), oldlen));

	if (RExC_utf8)
	    SvUTF8_on(sv);
	if (sv_utf8_downgrade(sv, TRUE)) {
	    const char * const s = sv_recode_to_utf8(sv, PL_encoding);
	    const STRLEN newlen = SvCUR(sv);

	    if (SvUTF8(sv))
		RExC_utf8 = 1;
	    if (!SIZE_ONLY) {
		DEBUG_r(PerlIO_printf(Perl_debug_log, "recode %*s to %*s\n",
				      (int)oldlen, STRING(ret),
				      (int)newlen, s));
		Copy(s, STRING(ret), newlen, char);
		STR_LEN(ret) += newlen - oldlen;
		RExC_emit += STR_SZ(newlen) - STR_SZ(oldlen);
	    } else
		RExC_size += STR_SZ(newlen) - STR_SZ(oldlen);
	}
    }

d7467 1
a7467 1
S_regwhite(pTHX_ char *p, const char *e)
d7469 1
d7474 1
d7476 7
a7482 2
		p++;
	    } while (p < e && *p != '\n');
d7503 1
d7510 1
a7510 1
	char* s = RExC_parse++;
d7518 1
a7518 3
	    const char* t = RExC_parse++; /* skip over the c */
	    const char *posixcc;

d7522 1
d7524 1
a7524 1
  		posixcc = s + 1;
d7532 2
a7533 5
			if (memEQ(posixcc, "word", 4)) {
			    /* this is not POSIX, this is the Perl \w */;
			    namedclass
				= complement ? ANYOF_NALNUM : ANYOF_ALNUM;
			}
d7542 2
a7543 5
			    if (memEQ(posixcc, "alph", 4)) {
				/*                  a     */
				namedclass
				    = complement ? ANYOF_NALPHA : ANYOF_ALPHA;
			    }
d7546 2
a7547 5
			    if (memEQ(posixcc, "spac", 4)) {
				/*                  e     */
				namedclass
				    = complement ? ANYOF_NPSXSPC : ANYOF_PSXSPC;
			    }
d7550 2
a7551 5
			    if (memEQ(posixcc, "grap", 4)) {
				/*                  h     */
				namedclass
				    = complement ? ANYOF_NGRAPH : ANYOF_GRAPH;
			    }
d7554 2
a7555 5
			    if (memEQ(posixcc, "asci", 4)) {
				/*                  i     */
				namedclass
				    = complement ? ANYOF_NASCII : ANYOF_ASCII;
			    }
d7558 2
a7559 5
			    if (memEQ(posixcc, "blan", 4)) {
				/*                  k     */
				namedclass
				    = complement ? ANYOF_NBLANK : ANYOF_BLANK;
			    }
d7562 2
a7563 5
			    if (memEQ(posixcc, "cntr", 4)) {
				/*                  l     */
				namedclass
				    = complement ? ANYOF_NCNTRL : ANYOF_CNTRL;
			    }
d7566 2
a7567 5
			    if (memEQ(posixcc, "alnu", 4)) {
				/*                  m     */
				namedclass
				    = complement ? ANYOF_NALNUMC : ANYOF_ALNUMC;
			    }
d7570 4
a7573 10
			    if (memEQ(posixcc, "lowe", 4)) {
				/*                  r     */
				namedclass
				    = complement ? ANYOF_NLOWER : ANYOF_LOWER;
			    }
			    if (memEQ(posixcc, "uppe", 4)) {
				/*                  r     */
				namedclass
				    = complement ? ANYOF_NUPPER : ANYOF_UPPER;
			    }
d7576 6
a7581 15
			    if (memEQ(posixcc, "digi", 4)) {
				/*                  t     */
				namedclass
				    = complement ? ANYOF_NDIGIT : ANYOF_DIGIT;
			    }
			    if (memEQ(posixcc, "prin", 4)) {
				/*                  t     */
				namedclass
				    = complement ? ANYOF_NPRINT : ANYOF_PRINT;
			    }
			    if (memEQ(posixcc, "punc", 4)) {
				/*                  t     */
				namedclass
				    = complement ? ANYOF_NPUNCT : ANYOF_PUNCT;
			    }
d7586 2
a7587 4
			if (memEQ(posixcc, "xdigit", 6)) {
			    namedclass
				= complement ? ANYOF_NXDIGIT : ANYOF_XDIGIT;
			}
a7591 1
		    {
a7593 1
		    }
d7619 2
a7620 1
    if (!SIZE_ONLY && POSIXCC(UCHARAT(RExC_parse))) {
d7624 1
a7624 1
	while(*s && isALNUM(*s))
d7637 1
a7637 1
		    ;
d7644 48
d7693 1
a7693 1
S_regclass(pTHX_ RExC_state_t *pRExC_state)
d7695 1
a7695 1
    register UV value;
d7699 1
d7703 1
a7703 1
    char *rangebegin = 0;
d7705 1
a7705 2
    SV *listsv = Nullsv;
    register char *e;
d7708 1
a7708 1
    AV* unicode_alternate  = 0;
d7712 11
d7724 1
d7737 1
a7737 1
    if (SIZE_ONLY)
d7739 2
d7748 1
a7748 1
	listsv = newSVpvn("# comment\n", 10);
d7760 1
d7772 1
a7772 1
				   &numlen, 0);
d7777 1
d7785 1
a7785 1
				   &numlen, 0);
d7802 18
d7822 2
d7853 2
a7854 6
		    if (value == 'p')
			 Perl_sv_catpvf(aTHX_ listsv,
					"+utf8::%.*s\n", (int)n, RExC_parse);
		    else
			 Perl_sv_catpvf(aTHX_ listsv,
					"!utf8::%.*s\n", (int)n, RExC_parse);
d7859 1
d7872 1
a7872 1
		    e = strchr(RExC_parse++, '}');
d7886 2
d7895 18
a7912 7
            {
                I32 flags = 0;
		numlen = 3;
		value = grok_oct(--RExC_parse, &numlen, &flags, NULL);
		RExC_parse += numlen;
		break;
            }
d7936 4
a7939 1
		    if (ckWARN(WARN_REGEXP))
d7942 2
a7943 3
			       RExC_parse - rangebegin,
			       RExC_parse - rangebegin,
			       rangebegin);
d7958 2
d7971 15
a7985 66
		case ANYOF_ALNUM:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_ALNUM);
		    else {
			for (value = 0; value < 256; value++)
			    if (isALNUM(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    yesno = '+';
		    what = "Word";	
		    break;
		case ANYOF_NALNUM:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_NALNUM);
		    else {
			for (value = 0; value < 256; value++)
			    if (!isALNUM(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    yesno = '!';
		    what = "Word";
		    break;
		case ANYOF_ALNUMC:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_ALNUMC);
		    else {
			for (value = 0; value < 256; value++)
			    if (isALNUMC(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    yesno = '+';
		    what = "Alnum";
		    break;
		case ANYOF_NALNUMC:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_NALNUMC);
		    else {
			for (value = 0; value < 256; value++)
			    if (!isALNUMC(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    yesno = '!';
		    what = "Alnum";
		    break;
		case ANYOF_ALPHA:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_ALPHA);
		    else {
			for (value = 0; value < 256; value++)
			    if (isALPHA(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    yesno = '+';
		    what = "Alpha";
		    break;
		case ANYOF_NALPHA:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_NALPHA);
		    else {
			for (value = 0; value < 256; value++)
			    if (!isALPHA(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    yesno = '!';
		    what = "Alpha";
		    break;
d8019 1
a8019 45
		    break;
		case ANYOF_BLANK:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_BLANK);
		    else {
			for (value = 0; value < 256; value++)
			    if (isBLANK(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    yesno = '+';
		    what = "Blank";
		    break;
		case ANYOF_NBLANK:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_NBLANK);
		    else {
			for (value = 0; value < 256; value++)
			    if (!isBLANK(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    yesno = '!';
		    what = "Blank";
		    break;
		case ANYOF_CNTRL:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_CNTRL);
		    else {
			for (value = 0; value < 256; value++)
			    if (isCNTRL(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    yesno = '+';
		    what = "Cntrl";
		    break;
		case ANYOF_NCNTRL:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_NCNTRL);
		    else {
			for (value = 0; value < 256; value++)
			    if (!isCNTRL(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    yesno = '!';
		    what = "Cntrl";
		    break;
d8043 1
a8043 177
		    break;
		case ANYOF_GRAPH:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_GRAPH);
		    else {
			for (value = 0; value < 256; value++)
			    if (isGRAPH(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    yesno = '+';
		    what = "Graph";
		    break;
		case ANYOF_NGRAPH:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_NGRAPH);
		    else {
			for (value = 0; value < 256; value++)
			    if (!isGRAPH(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    yesno = '!';
		    what = "Graph";
		    break;
		case ANYOF_LOWER:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_LOWER);
		    else {
			for (value = 0; value < 256; value++)
			    if (isLOWER(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    yesno = '+';
		    what = "Lower";
		    break;
		case ANYOF_NLOWER:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_NLOWER);
		    else {
			for (value = 0; value < 256; value++)
			    if (!isLOWER(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    yesno = '!';
		    what = "Lower";
		    break;
		case ANYOF_PRINT:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_PRINT);
		    else {
			for (value = 0; value < 256; value++)
			    if (isPRINT(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    yesno = '+';
		    what = "Print";
		    break;
		case ANYOF_NPRINT:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_NPRINT);
		    else {
			for (value = 0; value < 256; value++)
			    if (!isPRINT(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    yesno = '!';
		    what = "Print";
		    break;
		case ANYOF_PSXSPC:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_PSXSPC);
		    else {
			for (value = 0; value < 256; value++)
			    if (isPSXSPC(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    yesno = '+';
		    what = "Space";
		    break;
		case ANYOF_NPSXSPC:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_NPSXSPC);
		    else {
			for (value = 0; value < 256; value++)
			    if (!isPSXSPC(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    yesno = '!';
		    what = "Space";
		    break;
		case ANYOF_PUNCT:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_PUNCT);
		    else {
			for (value = 0; value < 256; value++)
			    if (isPUNCT(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    yesno = '+';
		    what = "Punct";
		    break;
		case ANYOF_NPUNCT:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_NPUNCT);
		    else {
			for (value = 0; value < 256; value++)
			    if (!isPUNCT(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    yesno = '!';
		    what = "Punct";
		    break;
		case ANYOF_SPACE:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_SPACE);
		    else {
			for (value = 0; value < 256; value++)
			    if (isSPACE(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    yesno = '+';
		    what = "SpacePerl";
		    break;
		case ANYOF_NSPACE:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_NSPACE);
		    else {
			for (value = 0; value < 256; value++)
			    if (!isSPACE(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    yesno = '!';
		    what = "SpacePerl";
		    break;
		case ANYOF_UPPER:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_UPPER);
		    else {
			for (value = 0; value < 256; value++)
			    if (isUPPER(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    yesno = '+';
		    what = "Upper";
		    break;
		case ANYOF_NUPPER:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_NUPPER);
		    else {
			for (value = 0; value < 256; value++)
			    if (!isUPPER(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    yesno = '!';
		    what = "Upper";
		    break;
		case ANYOF_XDIGIT:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_XDIGIT);
		    else {
			for (value = 0; value < 256; value++)
			    if (isXDIGIT(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    yesno = '+';
		    what = "XDigit";
		    break;
		case ANYOF_NXDIGIT:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_NXDIGIT);
		    else {
			for (value = 0; value < 256; value++)
			    if (!isXDIGIT(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    yesno = '!';
		    what = "XDigit";
		    break;
d8063 2
a8064 4
		Simple_vFAIL4("Invalid [] range \"%*.*s\"",
			      RExC_parse - rangebegin,
			      RExC_parse - rangebegin,
			      rangebegin);
d8076 4
a8079 1
		    if (ckWARN(WARN_REGEXP))
d8082 2
a8083 3
			       RExC_parse - rangebegin,
			       RExC_parse - rangebegin,
			       rangebegin);
d8093 1
a8094 2
	    IV i;

d8097 1
a8097 1

d8107 2
a8108 1
			    if (isLOWER(i))
d8110 1
d8113 2
a8114 1
			    if (isUPPER(i))
d8116 1
d8121 6
a8126 2
		      for (i = prevvalue; i <= ceilvalue; i++)
			  ANYOF_BITMAP_SET(ret, i);
d8131 1
a8131 1

d8144 7
d8155 8
d8164 1
d8223 21
d8245 1
a8245 2
    if (!SIZE_ONLY &&
	 /* If the only flag is folding (plus possibly inversion). */
d8260 1
a8260 1
    if (!SIZE_ONLY && optimize_invert &&
d8267 2
a8268 3

    if (!SIZE_ONLY) {
	AV *av = newAV();
a8269 1

d8281 1
a8281 1
	RExC_rx->data->data[n] = (void*)rv;
d8284 4
d8289 28
a8316 1
    return ret;
d8319 13
d8335 1
a8335 1
    char* retval = RExC_parse++;
d8348 1
a8348 1
	if (RExC_flags & PMf_EXTENDED) {
d8354 2
a8355 3
		while (RExC_parse < RExC_end)
		    if (*RExC_parse++ == '\n') break;
		continue;
d8368 1
d8371 1
d8378 2
d8384 1
d8386 1
a8386 1
	MJD_OFFSET_DEBUG(("%s:%u: (op %s) %s %u <- %u (len %u) (max %u).\n", 
d8388 6
a8393 6
              reg_name[op],
              RExC_emit - RExC_emit_start > RExC_offsets[0] 
              ? "Overwriting end of array!\n" : "OK",
              RExC_emit - RExC_emit_start,
              RExC_parse - RExC_start,
              RExC_offsets[0])); 
d8396 1
a8396 1
            
a8397 1

d8407 1
d8410 1
d8415 14
d8431 2
d8437 1
d8439 1
a8439 1
	MJD_OFFSET_DEBUG(("%s(%d): (op %s) %s %u <- %u (max %u).\n", 
d8442 2
a8443 2
	      reg_name[op],
              RExC_emit - RExC_emit_start > RExC_offsets[0] ? 
d8445 3
a8447 3
              RExC_emit - RExC_emit_start,
              RExC_parse - RExC_start,
              RExC_offsets[0])); 
d8450 1
a8450 1
            
a8451 1

d8458 2
a8459 2
STATIC void
S_reguni(pTHX_ const RExC_state_t *pRExC_state, UV uv, char* s, STRLEN* lenp)
d8461 2
a8462 1
    *lenp = SIZE_ONLY ? UNISKIP(uv) : (uvchr_to_utf8((U8*)s, uv) - (U8*)s);
d8471 1
a8471 1
S_reginsert(pTHX_ RExC_state_t *pRExC_state, U8 op, regnode *opnd)
d8473 1
d8478 3
a8480 1

d8482 1
a8482 1

d8484 1
a8484 1
	RExC_size += NODE_STEP_REGNODE + offset;
d8489 1
a8489 1
    RExC_emit += NODE_STEP_REGNODE + offset;
d8491 19
d8512 1
d8514 1
a8514 1
	    MJD_OFFSET_DEBUG(("%s(%d): (op %s) %s copy %u -> %u (max %u).\n",
d8517 6
a8522 6
		  reg_name[op],
                  dst - RExC_emit_start > RExC_offsets[0] 
                  ? "Overwriting end of array!\n" : "OK",
                  src - RExC_emit_start,
                  dst - RExC_emit_start,
                  RExC_offsets[0])); 
d8526 1
d8531 1
d8533 1
a8533 1
	MJD_OFFSET_DEBUG(("%s(%d): (op %s) %s %u <- %u (max %u).\n", 
d8536 2
a8537 2
	      reg_name[op],
              place - RExC_emit_start > RExC_offsets[0] 
d8539 3
a8541 3
              place - RExC_emit_start,
              RExC_parse - RExC_start,
              RExC_offsets[0])); 
d8545 1
d8553 1
d8555 1
d8557 1
a8557 1
S_regtail(pTHX_ RExC_state_t *pRExC_state, regnode *p, regnode *val)
d8559 1
d8561 4
d8573 13
a8585 3
	if (temp == NULL)
	    break;
	scan = temp;
d8589 1
a8589 1
	ARG_SET(scan, val - scan);
d8592 1
a8592 1
	NEXT_OFF(scan) = val - scan;
d8596 1
d8598 12
a8609 1
- regoptail - regtail on operand of first argument; nop if operandless
d8611 4
a8614 2
STATIC void
S_regoptail(pTHX_ RExC_state_t *pRExC_state, regnode *p, regnode *val)
d8616 63
a8678 5
    /* "Operandless" and "op != BRANCH" are synonymous in practice. */
    if (p == NULL || SIZE_ONLY)
	return;
    if (PL_regkind[(U8)OP(p)] == BRANCH) {
	regtail(pRExC_state, NEXTOPER(p), val);
d8680 2
a8681 2
    else if ( PL_regkind[(U8)OP(p)] == BRANCHJ) {
	regtail(pRExC_state, NEXTOPER(NEXTOPER(p)), val);
d8683 2
a8684 2
    else
	return;
d8686 1
d8692 1
a8692 1
S_regcurly(pTHX_ register const char *s)
d8709 1
d8713 21
d8735 1
a8735 1
Perl_regdump(pTHX_ regexp *r)
d8738 5
a8742 1
    SV *sv = sv_newmortal();
d8744 1
a8744 1
    (void)dumpuntil(r->program, r->program + 1, NULL, sv, 0);
d8747 3
a8749 1
    if (r->anchored_substr)
d8751 2
a8752 6
		      "anchored \"%s%.*s%s\"%s at %"IVdf" ",
		      PL_colors[0],
		      (int)(SvCUR(r->anchored_substr) - (SvTAIL(r->anchored_substr)!=0)),
		      SvPVX_const(r->anchored_substr),
		      PL_colors[1],
		      SvTAIL(r->anchored_substr) ? "$" : "",
d8754 3
a8756 1
    else if (r->anchored_utf8)
d8758 2
a8759 6
		      "anchored utf8 \"%s%.*s%s\"%s at %"IVdf" ",
		      PL_colors[0],
		      (int)(SvCUR(r->anchored_utf8) - (SvTAIL(r->anchored_utf8)!=0)),
		      SvPVX_const(r->anchored_utf8),
		      PL_colors[1],
		      SvTAIL(r->anchored_utf8) ? "$" : "",
d8761 4
a8764 1
    if (r->float_substr)
d8766 2
a8767 6
		      "floating \"%s%.*s%s\"%s at %"IVdf"..%"UVuf" ",
		      PL_colors[0],
		      (int)(SvCUR(r->float_substr) - (SvTAIL(r->float_substr)!=0)),
		      SvPVX_const(r->float_substr),
		      PL_colors[1],
		      SvTAIL(r->float_substr) ? "$" : "",
d8769 3
a8771 1
    else if (r->float_utf8)
d8773 2
a8774 6
		      "floating utf8 \"%s%.*s%s\"%s at %"IVdf"..%"UVuf" ",
		      PL_colors[0],
		      (int)(SvCUR(r->float_utf8) - (SvTAIL(r->float_utf8)!=0)),
		      SvPVX_const(r->float_utf8),
		      PL_colors[1],
		      SvTAIL(r->float_utf8) ? "$" : "",
d8776 1
d8779 5
a8783 4
		      r->check_substr == r->float_substr
		      && r->check_utf8 == r->float_utf8
		      ? "(checking floating" : "(checking anchored");
    if (r->reganch & ROPT_NOSCAN)
d8785 1
a8785 1
    if (r->reganch & ROPT_CHECK_ALL)
d8790 3
a8792 3
    if (r->regstclass) {
	regprop(sv, r->regstclass);
	PerlIO_printf(Perl_debug_log, "stclass \"%s\" ", SvPVX_const(sv));
d8794 1
a8794 1
    if (r->reganch & ROPT_ANCH) {
d8796 1
a8796 1
	if (r->reganch & ROPT_ANCH_BOL)
d8798 1
a8798 1
	if (r->reganch & ROPT_ANCH_MBOL)
d8800 1
a8800 1
	if (r->reganch & ROPT_ANCH_SBOL)
d8802 1
a8802 1
	if (r->reganch & ROPT_ANCH_GPOS)
d8806 3
a8808 3
    if (r->reganch & ROPT_GPOS_SEEN)
	PerlIO_printf(Perl_debug_log, "GPOS ");
    if (r->reganch & ROPT_SKIP)
d8810 1
a8810 1
    if (r->reganch & ROPT_IMPLICIT)
d8812 2
a8813 2
    PerlIO_printf(Perl_debug_log, "minlen %ld ", (long) r->minlen);
    if (r->reganch & ROPT_EVAL_SEEN)
d8816 4
a8819 10
    if (r->offsets) {
      U32 i;
      const U32 len = r->offsets[0];
      PerlIO_printf(Perl_debug_log, "Offsets: [%"UVuf"]\n\t", (UV)r->offsets[0]);
      for (i = 1; i <= len; i++)
        PerlIO_printf(Perl_debug_log, "%"UVuf"[%"UVuf"] ", 
                      (UV)r->offsets[i*2-1], 
                      (UV)r->offsets[i*2]);
      PerlIO_printf(Perl_debug_log, "\n");
    }
d8827 1
a8827 1
Perl_regprop(pTHX_ SV *sv, regnode *o)
d8830 1
d8832 3
d8837 2
a8838 1
    if (OP(o) >= reg_num)		/* regnode.type is unsigned */
d8841 2
a8842 2
	Perl_croak(aTHX_ "Corrupted regexp opcode");
    sv_catpv(sv, reg_name[OP(o)]); /* Take off const! */
d8844 1
a8844 1
    k = PL_regkind[(U8)OP(o)];
d8847 60
a8906 18
	SV * const dsv = sv_2mortal(newSVpvn("", 0));
	/* Using is_utf8_string() is a crude hack but it may
	 * be the best for now since we have no flag "this EXACTish
	 * node was UTF-8" --jhi */
	const bool do_utf8 = is_utf8_string((U8*)STRING(o), STR_LEN(o));
	const char * const s = do_utf8 ?
	  pv_uni_display(dsv, (U8*)STRING(o), STR_LEN(o), 60,
			 UNI_DISPLAY_REGEX) :
	  STRING(o);
	const int len = do_utf8 ?
	  strlen(s) :
	  STR_LEN(o);
	Perl_sv_catpvf(aTHX_ sv, " <%s%.*s%s>",
		       PL_colors[0],
		       len, s,
		       PL_colors[1]);
    }
    else if (k == CURLY) {
d8913 1
a8913 1
    else if (k == REF || k == OPEN || k == CLOSE || k == GROUPP )
d8915 29
a8943 1
    else if (k == LOGICAL)
d8945 2
d8950 3
a8952 2
	const char * const anyofs[] = {	/* Should be synchronized with
					 * ANYOF_ #xdefines in regcomp.h */
d8986 1
a8986 1
	    sv_catpv(sv, "{loc}");
d8988 1
a8988 1
	    sv_catpv(sv, "{i}");
d8991 1
a8991 1
	    sv_catpv(sv, "^");
d9002 1
a9002 1
		    sv_catpv(sv, "-");
d9010 1
a9010 1
	    for (i = 0; i < sizeof(anyofs)/sizeof(char*); i++)
d9015 1
a9015 1
	    sv_catpv(sv, "{unicode}");
d9017 1
a9017 1
	    sv_catpv(sv, "{unicode_all}");
d9021 1
a9021 1
	    SV * const sw = regclass_swash(o, FALSE, &lv, 0);
d9046 1
a9046 1
				sv_catpvn(sv, "-", 1);
d9055 1
a9055 1
		    sv_catpv(sv, "..."); /* et cetera */
d9060 1
a9060 1
		    char *origs = s;
d9062 2
a9063 1
		    while(*s && *s != '\n') s++;
d9087 6
a9092 1
	Perl_sv_catpvf(aTHX_ sv, "[-%d]", o->flags);
d9097 1
a9097 1
Perl_re_intuit_string(pTHX_ regexp *prog)
d9099 5
a9103 1
    DEBUG_r(
d9122 13
d9138 2
a9139 3
#ifdef DEBUGGING
    SV *dsv = PERL_DEBUG_PAD_ZERO(0);
#endif
d9143 8
a9150 21
    DEBUG_r({
        const char *s = (r->reganch & ROPT_UTF8)
            ? pv_uni_display(dsv, (U8*)r->precomp, r->prelen, 60, UNI_DISPLAY_REGEX)
            : pv_display(dsv, r->precomp, r->prelen, 0, 60);
        const int len = SvCUR(dsv);
	 if (!PL_colorset)
	      reginitcolors();
	 PerlIO_printf(Perl_debug_log,
		       "%sFreeing REx:%s `%s%*.*s%s%s'\n",
		       PL_colors[4],PL_colors[5],PL_colors[0],
		       len, len, s,
		       PL_colors[1],
		       len > 60 ? "..." : "");
    });

    /* gcov results gave these as non-null 100% of the time, so there's no
       optimisation in checking them before calling Safefree  */
    Safefree(r->precomp);
    Safefree(r->offsets);             /* 20010421 MJD */
    if (RX_MATCH_COPIED(r))
	Safefree(r->subbeg);
d9152 8
a9159 8
	if (r->anchored_substr)
	    SvREFCNT_dec(r->anchored_substr);
	if (r->anchored_utf8)
	    SvREFCNT_dec(r->anchored_utf8);
	if (r->float_substr)
	    SvREFCNT_dec(r->float_substr);
	if (r->float_utf8)
	    SvREFCNT_dec(r->float_utf8);
d9162 96
a9257 2
    if (r->data) {
	int n = r->data->count;
d9264 1
a9264 1
	    switch (r->data->what[n]) {
d9266 3
a9268 1
		SvREFCNT_dec((SV*)r->data->data[n]);
d9271 1
a9271 1
		Safefree(r->data->data[n]);
d9274 1
a9274 1
		new_comppad = (AV*)r->data->data[n];
d9281 1
a9281 2
		    (SvTYPE(new_comppad) == SVt_PVAV) ?
		    		new_comppad : Null(PAD *)
d9284 1
a9284 1
		refcnt = OpREFCNT_dec((OP_4tree*)r->data->data[n]);
d9287 1
a9287 1
                    op_free((OP_4tree*)r->data->data[n]);
d9295 42
d9338 191
a9528 1
		Perl_croak(aTHX_ "panic: regfree data code '%c'", r->data->what[n]);
d9531 12
a9542 2
	Safefree(r->data->what);
	Safefree(r->data);
d9544 49
a9592 3
    Safefree(r->startp);
    Safefree(r->endp);
    Safefree(r);
a9596 3
 *
 * [Note, when REGALIGN is defined there are two places in regmatch()
 * that bypass this code for speed.]
d9601 1
d9604 1
a9604 1
    if (p == &PL_regdummy)
d9613 1
d9651 1
d9655 13
a9667 11
    SAVEI32(PL_reg_flags);		/* from regexec.c */
    SAVEPPTR(PL_bostr);
    SAVEPPTR(PL_reginput);		/* String-input pointer. */
    SAVEPPTR(PL_regbol);		/* Beginning of input, for ^ check. */
    SAVEPPTR(PL_regeol);		/* End of input, for $ check. */
    SAVEVPTR(PL_regstartp);		/* Pointer to startp array. */
    SAVEVPTR(PL_regendp);		/* Ditto for endp. */
    SAVEVPTR(PL_reglastparen);		/* Similarly for lastparen. */
    SAVEVPTR(PL_reglastcloseparen);	/* Similarly for lastcloseparen. */
    SAVEPPTR(PL_regtill);		/* How far we are required to go. */
    SAVEGENERICPV(PL_reg_start_tmp);		/* from regexec.c */
a9668 1
    SAVEI32(PL_reg_start_tmpl);		/* from regexec.c */
d9670 1
a9670 19
    SAVEVPTR(PL_regdata);
    SAVEI32(PL_reg_eval_set);		/* from regexec.c */
    SAVEI32(PL_regnarrate);		/* from regexec.c */
    SAVEVPTR(PL_regprogram);		/* from regexec.c */
    SAVEINT(PL_regindent);		/* from regexec.c */
    SAVEVPTR(PL_regcc);			/* from regexec.c */
    SAVEVPTR(PL_curcop);
    SAVEVPTR(PL_reg_call_cc);		/* from regexec.c */
    SAVEVPTR(PL_reg_re);		/* from regexec.c */
    SAVEPPTR(PL_reg_ganch);		/* from regexec.c */
    SAVESPTR(PL_reg_sv);		/* from regexec.c */
    SAVEBOOL(PL_reg_match_utf8);	/* from regexec.c */
    SAVEVPTR(PL_reg_magic);		/* from regexec.c */
    SAVEI32(PL_reg_oldpos);			/* from regexec.c */
    SAVEVPTR(PL_reg_oldcurpm);		/* from regexec.c */
    SAVEVPTR(PL_reg_curpm);		/* from regexec.c */
    SAVEPPTR(PL_reg_oldsaved);		/* old saved substr during match */
    PL_reg_oldsaved = Nullch;
    SAVEI32(PL_reg_oldsavedlen);	/* old length of saved substr during match */
a9671 1
    SAVEI32(PL_reg_maxiter);		/* max wait until caching pos */
a9672 1
    SAVEI32(PL_reg_leftiter);		/* wait until caching pos */
d9674 1
a9674 3
    SAVEGENERICPV(PL_reg_poscache);	/* cache of pos of WHILEM */
    PL_reg_poscache = Nullch;
    SAVEI32(PL_reg_poscache_size);	/* size of pos cache of WHILEM */
d9676 3
a9678 7
    SAVEPPTR(PL_regprecomp);		/* uncompiled string. */
    SAVEI32(PL_regnpar);		/* () count. */
    SAVEI32(PL_regsize);		/* from regexec.c */

    {
	/* Save $1..$n (#18107: UTF-8 s/(\w+)/uc($1)/e); AMS 20021106. */
	REGEXP *rx;
d9680 4
a9683 1
	if (PL_curpm && (rx = PM_GETRE(PL_curpm))) {
a9685 1
		GV *mgv;
d9687 9
a9695 3
		sprintf(digits, "%lu", (long)i);
		if ((mgv = gv_fetchpv(digits, FALSE, SVt_PV)))
		    save_scalar(mgv);
d9699 1
a9699 3

#ifdef DEBUGGING
    SAVEPPTR(PL_reg_starttry);		/* from regexec.c */
a9700 1
}
d9705 1
d9714 11
a9724 1
    if (isCNTRL(c) || c == 255 || !isPRINT(c))
d9726 6
a9731 4
    else if (c == '-' || c == ']' || c == '\\' || c == '^')
	Perl_sv_catpvf(aTHX_ sv, "\\%c", c);
    else
	Perl_sv_catpvf(aTHX_ sv, "%c", c);
d9735 12
a9746 2
STATIC regnode *
S_dumpuntil(pTHX_ regnode *start, regnode *node, regnode *last, SV* sv, I32 l)
d9748 15
a9762 2
    register U8 op = EXACT;	/* Arbitrary non-END op. */
    register regnode *next;
d9764 1
a9764 1
    while (op != END && (!last || node < last)) {
a9765 1

d9768 4
a9771 3
	if (op == CLOSE)
	    l--;	
	next = regnext(node);
d9773 9
a9781 3
	if (OP(node) == OPTIMIZED)
	    goto after_print;
	regprop(sv, node);
d9783 12
a9794 6
		      (int)(2*l + 1), "", SvPVX_const(sv));
	if (next == NULL)		/* Next ptr. */
	    PerlIO_printf(Perl_debug_log, "(0)");
	else
	    PerlIO_printf(Perl_debug_log, "(%"IVdf")", (IV)(next - start));
	(void)PerlIO_putc(Perl_debug_log, '\n');
d9797 9
a9805 6
	    register regnode *nnode = (OP(next) == LONGJMP
				       ? regnext(next)
				       : next);
	    if (last && nnode > last)
		nnode = last;
	    node = dumpuntil(start, NEXTOPER(NEXTOPER(node)), nnode, sv, l + 1);
d9808 2
a9809 1
	    node = dumpuntil(start, NEXTOPER(node), next, sv, l + 1);
d9811 51
a9861 3
	else if ( op == CURLY) {   /* "next" might be very big: optimizer */
	    node = dumpuntil(start, NEXTOPER(node) + EXTRA_STEP_2ARGS,
			     NEXTOPER(node) + EXTRA_STEP_2ARGS + 1, sv, l + 1);
d9864 2
a9865 2
	    node = dumpuntil(start, NEXTOPER(node) + EXTRA_STEP_2ARGS,
			     next, sv, l + 1);
d9868 1
a9868 1
	    node = dumpuntil(start, NEXTOPER(node), NEXTOPER(node) + 1, sv, l + 1);
d9886 1
a9886 3
	    l++;
	else if (op == WHILEM)
	    l--;
d9888 4
@


1.11
log
@merge in perl 5.8.8
@
text
@d139 1
d165 1
d1754 1
a1754 1
    RExC_utf8 = pm->op_pmdynflags & PMdf_CMP_UTF8;
a1755 1
    RExC_precomp = exp;
d1760 1
a1760 1
		       (int)(xend - exp), RExC_precomp, PL_colors[1]);
d1762 3
d1790 11
@


1.10
log
@sync in-tree perl with 5.8.6
@
text
@a57 1
/*SUPPRESS 112*/
d82 1
a82 1
 ****    2000, 2001, 2002, 2003, by Larry Wall and others
d208 2
a209 2
static scan_data_t zero_scan_data = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				      0, 0, 0, 0, 0, 0};
d270 1
a270 1
    char *ellipses = "";						\
d290 1
a290 1
    char *ellipses = "";						\
d309 1
a309 1
    IV offset = RExC_parse - RExC_precomp;				\
d327 1
a327 1
    IV offset = RExC_parse - RExC_precomp;			\
d346 1
a346 1
    IV offset = RExC_parse - RExC_precomp;			\
d364 1
a364 1
    IV offset = RExC_parse - RExC_precomp;			\
a368 10
/*
 * Like Simple_vFAIL(), but accepts five arguments.
 */
#define	Simple_vFAIL5(m, a1, a2, a3, a4) STMT_START {		\
    IV offset = RExC_parse - RExC_precomp;			\
    S_re_croak2(aTHX_ m, REPORT_LOCATION, a1, a2, a3, a4,	\
	    (int)offset, RExC_precomp, RExC_precomp + offset);	\
} STMT_END


d370 1
a370 1
    IV offset = loc - RExC_precomp;					\
d376 1
a376 1
    IV offset = loc - RExC_precomp;					\
d384 1
a384 1
    IV offset = loc - RExC_precomp;					\
d390 1
a390 1
    IV offset = loc - RExC_precomp;					\
d396 1
a396 1
    IV offset = loc - RExC_precomp;					\
d402 1
a402 1
    IV offset = loc - RExC_precomp;					\
d428 1
a428 1
	    Perl_croak(aTHX_ "value of node is %d in Offset macro", node); \
d442 1
a442 1
		__LINE__, (node), (len)));				\
d444 1
a444 1
	    Perl_croak(aTHX_ "value of node is %d in Length macro", node); \
d470 2
a471 2
    STRLEN l = CHR_SVLEN(data->last_found);
    STRLEN old_l = CHR_SVLEN(*data->longest);
d499 2
a500 2
	SV * sv = data->last_found;
	MAGIC *mg =
d522 1
a522 1
S_cl_is_anything(pTHX_ struct regnode_charclass_class *cl)
d559 1
a559 1
	 struct regnode_charclass_class *and_with)
d595 1
a595 1
S_cl_or(pTHX_ RExC_state_t *pRExC_state, struct regnode_charclass_class *cl, struct regnode_charclass_class *or_with)
d666 1
a666 1
/* Stops at toplevel WHILEM as well as at `last'. At end *scanp is set
d714 1
a714 1
		    int oldl = STR_LEN(scan);
d762 3
a764 3
		 char *t0 = "\xcc\x88\xcc\x81";
		 char *t1 = t0 + 3;
		 
d789 1
a789 1
	    int max = (reg_off_by_arg[OP(scan)]
d901 1
d913 3
a915 3
		U8 *s = (U8*)STRING(scan);
		l = utf8_length(s, s + l);
		uc = utf8_to_uvchr(s, NULL);
d928 2
a929 2
		    SV * sv = data->last_found;
		    MAGIC *mg = SvUTF8(sv) && SvMAGICAL(sv) ?
d1017 1
a1017 1
	else if (strchr((char*)PL_varies,OP(scan))) {
d1130 2
a1131 3
		if (ckWARN(WARN_REGEXP)
		       /* ? quantifier ok, except for (?{ ... }) */
		    && (next_is_eval || !(mincount == 0 && maxcount == 1))
d1134 2
a1135 1
		    && maxcount <= REG_INFTY/3) /* Complement check for big count */
d1162 1
a1162 1
		    if (!strchr((char*)PL_simple,OP(nxt))
d1268 1
a1268 1
			char *s = NULL;
d1277 1
a1277 1
			s = SvPV(data->last_found, l);
d1284 1
a1284 1
			char *s = SvPV(data->last_found, l);
d1301 2
a1302 2
					  SvPVX(last_str), l, mincount - 1);
				SvCUR(last_str) *= mincount;
d1367 1
a1367 1
	else if (strchr((char*)PL_simple,OP(scan))) {
d1616 1
a1616 1
		int was = (data->start_class->flags & ANYOF_EOS);
d1675 1
a1675 1
S_add_data(pTHX_ RExC_state_t *pRExC_state, I32 n, char *s)
d1685 1
a1685 1
	Newc(1207, RExC_rx->data, sizeof(*RExC_rx->data) + sizeof(void*) * (n - 1),
d1687 1
a1687 1
	New(1208, RExC_rx->data->what, n, U8);
d1697 1
a1697 3
    int i = 0;
    char *s = PerlEnv_getenv("PERL_RE_COLORS");
	
d1699 3
a1701 1
	PL_colors[0] = s = savepv(s);
d1703 4
a1706 4
	    s = strchr(s, '\t');
	    if (s) {
		*s = '\0';
		PL_colors[i] = ++s;
d1709 1
a1709 1
		PL_colors[i] = s = "";
d1712 1
d1714 1
a1714 1
	    PL_colors[i++] = "";
d1798 1
a1798 1
    Newc(1001, r, sizeof(regexp) + (unsigned)RExC_size * sizeof(regnode),
d1818 1
a1818 1
    Newz(1304, r->offsets, 2*RExC_size+1, U32); /* MJD 20001228 */
d1820 1
a1820 1
      r->offsets[0] = RExC_size; 
d1823 2
a1824 2
                          "%s %"UVuf" bytes for offset annotations.\n", 
                          r->offsets ? "Got" : "Couldn't get", 
d1856 1
a1856 1
    Newz(1004, r->substrs, 1, struct reg_substr_data);
d1891 1
a1891 1
	else if (strchr((char*)PL_simple,OP(first)))
d1915 4
a1918 7
	    int type = OP(NEXTOPER(first));

	    if (type == REG_ANY)
		type = ROPT_ANCH_MBOL;
	    else
		type = ROPT_ANCH_SBOL;

d2033 1
a2033 1
	    I32 n = add_data(pRExC_state, 1, "f");
d2035 1
a2035 1
	    New(1006, RExC_rx->data->data[n], 1,
d2046 2
a2047 2
				    "synthetic stclass `%s'.\n",
				    SvPVX(sv));});
d2089 1
a2089 1
	    I32 n = add_data(pRExC_state, 1, "f");
d2091 1
a2091 1
	    New(1006, RExC_rx->data->data[n], 1,
d2101 2
a2102 2
				    "synthetic stclass `%s'.\n",
				    SvPVX(sv));});
d2115 2
a2116 2
    Newz(1002, r->startp, RExC_npar, I32);
    Newz(1002, r->endp, RExC_npar, I32);
d2152 1
a2152 1
    char *oregcomp_parse = RExC_parse;
d2164 1
a2164 1
	    char *seqstart = RExC_parse;
d2297 1
a2297 1
                    
d2419 1
a2419 1
    
d2454 1
a2454 1
        
d2499 2
a2500 2
	char *p;
	static char parens[] = "=!<,>";
d2616 1
a2616 1
    char *origparse = RExC_parse;
d2681 1
a2681 1
                Set_Node_Length(ret, 
d2683 1
a2683 1
                
d2757 1
a2757 1
    if (ckWARN(WARN_REGEXP) && !SIZE_ONLY && !(flags&HASWIDTH) && max > REG_INFTY/3) {
d3022 1
a3022 1
		I32 num = atoi(RExC_parse);
d3038 1
a3038 1
                    
d3040 1
a3040 1
                    Set_Node_Offset(ret, parse_start+1); 
d3052 1
a3052 1
	    /* Do not generate `unrecognized' warnings here, we fall
a3071 1
	    STRLEN numlen;
d3073 1
a3073 1
	    U8 tmpbuf[UTF8_MAXLEN_FOLD+1], *foldbuf;
d3147 1
a3147 1
			    char* e = strchr(p, '}');
d3156 1
a3156 1
                                numlen = e - p - 1;
d3165 1
a3165 1
			    numlen = 2;
d3180 1
a3180 1
			    numlen = 3;
d3194 1
a3194 1
			if (!SIZE_ONLY && ckWARN(WARN_REGEXP) && isALPHA(*p))
d3202 1
d3225 1
d3263 1
d3327 2
a3328 2
	    char *s       = sv_recode_to_utf8(sv, PL_encoding);
	    STRLEN newlen = SvCUR(sv);
d3348 1
a3348 1
S_regwhite(pTHX_ char *p, char *e)
a3376 1
    char *posixcc = 0;
d3382 1
a3382 1
	char  c = UCHARAT(RExC_parse);
d3391 4
a3394 1
	    char* t = RExC_parse++; /* skip over the c */
d3400 2
a3401 2
		    I32 complement = *posixcc == '^' ? *posixcc++ : 0;
		    I32 skip = 5; /* the most common skip */
d3403 8
a3410 11
		    switch (*posixcc) {
		    case 'a':
			if (strnEQ(posixcc, "alnum", 5))
			    namedclass =
				complement ? ANYOF_NALNUMC : ANYOF_ALNUMC;
			else if (strnEQ(posixcc, "alpha", 5))
			    namedclass =
				complement ? ANYOF_NALPHA : ANYOF_ALPHA;
			else if (strnEQ(posixcc, "ascii", 5))
			    namedclass =
				complement ? ANYOF_NASCII : ANYOF_ASCII;
d3412 84
a3495 48
		    case 'b':
			if (strnEQ(posixcc, "blank", 5))
			    namedclass =
				complement ? ANYOF_NBLANK : ANYOF_BLANK;
			break;
		    case 'c':
			if (strnEQ(posixcc, "cntrl", 5))
			    namedclass =
				complement ? ANYOF_NCNTRL : ANYOF_CNTRL;
			break;
		    case 'd':
			if (strnEQ(posixcc, "digit", 5))
			    namedclass =
				complement ? ANYOF_NDIGIT : ANYOF_DIGIT;
			break;
		    case 'g':
			if (strnEQ(posixcc, "graph", 5))
			    namedclass =
				complement ? ANYOF_NGRAPH : ANYOF_GRAPH;
			break;
		    case 'l':
			if (strnEQ(posixcc, "lower", 5))
			    namedclass =
				complement ? ANYOF_NLOWER : ANYOF_LOWER;
			break;
		    case 'p':
			if (strnEQ(posixcc, "print", 5))
			    namedclass =
				complement ? ANYOF_NPRINT : ANYOF_PRINT;
			else if (strnEQ(posixcc, "punct", 5))
			    namedclass =
				complement ? ANYOF_NPUNCT : ANYOF_PUNCT;
			break;
		    case 's':
			if (strnEQ(posixcc, "space", 5))
			    namedclass =
				complement ? ANYOF_NPSXSPC : ANYOF_PSXSPC;
			break;
		    case 'u':
			if (strnEQ(posixcc, "upper", 5))
			    namedclass =
				complement ? ANYOF_NUPPER : ANYOF_UPPER;
 			break;
		    case 'w': /* this is not POSIX, this is the Perl \w */
			if (strnEQ(posixcc, "word", 4)) {
			    namedclass =
				complement ? ANYOF_NALNUM : ANYOF_ALNUM;
			    skip = 4;
d3498 4
a3501 5
		    case 'x':
			if (strnEQ(posixcc, "xdigit", 6)) {
			    namedclass =
				complement ? ANYOF_NXDIGIT : ANYOF_XDIGIT;
			    skip = 6;
d3505 2
a3506 3
		    if (namedclass == OOB_NAMEDCLASS ||
			posixcc[skip] != ':' ||
			posixcc[skip+1] != ']')
d3511 2
d3537 2
a3538 2
	char *s = RExC_parse;
 	char  c = *s++;
d3659 1
a3659 1
		    U8 c = (U8)value;
d3736 1
a3736 1
		if (!SIZE_ONLY && ckWARN(WARN_REGEXP) && isALPHA(value))
d3779 3
d3797 2
a3798 1
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsWord\n");	
d3808 2
a3809 1
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsWord\n");
d3819 2
a3820 1
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsAlnum\n");
d3830 2
a3831 1
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsAlnum\n");
d3841 2
a3842 1
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsAlpha\n");
d3852 2
a3853 1
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsAlpha\n");
d3869 2
a3870 1
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsASCII\n");
d3886 2
a3887 1
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsASCII\n");
d3897 2
a3898 1
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsBlank\n");
d3908 2
a3909 1
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsBlank\n");
d3919 2
a3920 1
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsCntrl\n");
d3930 2
a3931 1
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsCntrl\n");
d3941 2
a3942 1
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsDigit\n");
d3954 2
a3955 1
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsDigit\n");
d3965 2
a3966 1
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsGraph\n");
d3976 2
a3977 1
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsGraph\n");
d3987 2
a3988 1
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsLower\n");
d3998 2
a3999 1
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsLower\n");
d4009 2
a4010 1
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsPrint\n");
d4020 2
a4021 1
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsPrint\n");
d4031 2
a4032 1
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsSpace\n");
d4042 2
a4043 1
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsSpace\n");
d4053 2
a4054 1
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsPunct\n");
d4064 2
a4065 1
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsPunct\n");
d4075 2
a4076 1
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsSpacePerl\n");
d4086 2
a4087 1
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsSpacePerl\n");
d4097 2
a4098 1
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsUpper\n");
d4108 2
a4109 1
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsUpper\n");
d4119 2
a4120 1
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsXDigit\n");
d4130 2
a4131 1
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsXDigit\n");
d4140 4
d4186 1
a4186 1
	        IV ceilvalue = value < 256 ? value : 255;
d4211 2
a4212 2
	        UV prevnatvalue  = NATIVE_TO_UNI(prevvalue);
		UV natvalue      = NATIVE_TO_UNI(value);
d4222 1
a4222 1
			 U8 foldbuf[UTF8_MAXLEN_FOLD+1];
d4224 1
a4224 1
			 UV f = to_uni_fold(natvalue, foldbuf, &foldlen);
a4372 1
    register regnode *ret;
d4374 1
a4375 1
    ret = RExC_emit;
a4407 1
    register regnode *ret;
d4409 1
a4410 1
    ret = RExC_emit;
d4442 1
a4442 1
S_reguni(pTHX_ RExC_state_t *pRExC_state, UV uv, char* s, STRLEN* lenp)
d4458 1
a4458 1
    register int offset = regarglen[(U8)op];
a4513 1
    register regnode *temp;
d4521 1
a4521 1
	temp = regnext(scan);
d4558 1
a4558 1
S_regcurly(pTHX_ register char *s)
a4574 76

#ifdef DEBUGGING

STATIC regnode *
S_dumpuntil(pTHX_ regnode *start, regnode *node, regnode *last, SV* sv, I32 l)
{
    register U8 op = EXACT;	/* Arbitrary non-END op. */
    register regnode *next;

    while (op != END && (!last || node < last)) {
	/* While that wasn't END last time... */

	NODE_ALIGN(node);
	op = OP(node);
	if (op == CLOSE)
	    l--;	
	next = regnext(node);
	/* Where, what. */
	if (OP(node) == OPTIMIZED)
	    goto after_print;
	regprop(sv, node);
	PerlIO_printf(Perl_debug_log, "%4"IVdf":%*s%s", (IV)(node - start),
		      (int)(2*l + 1), "", SvPVX(sv));
	if (next == NULL)		/* Next ptr. */
	    PerlIO_printf(Perl_debug_log, "(0)");
	else
	    PerlIO_printf(Perl_debug_log, "(%"IVdf")", (IV)(next - start));
	(void)PerlIO_putc(Perl_debug_log, '\n');
      after_print:
	if (PL_regkind[(U8)op] == BRANCHJ) {
	    register regnode *nnode = (OP(next) == LONGJMP
				       ? regnext(next)
				       : next);
	    if (last && nnode > last)
		nnode = last;
	    node = dumpuntil(start, NEXTOPER(NEXTOPER(node)), nnode, sv, l + 1);
	}
	else if (PL_regkind[(U8)op] == BRANCH) {
	    node = dumpuntil(start, NEXTOPER(node), next, sv, l + 1);
	}
	else if ( op == CURLY) {   /* `next' might be very big: optimizer */
	    node = dumpuntil(start, NEXTOPER(node) + EXTRA_STEP_2ARGS,
			     NEXTOPER(node) + EXTRA_STEP_2ARGS + 1, sv, l + 1);
	}
	else if (PL_regkind[(U8)op] == CURLY && op != CURLYX) {
	    node = dumpuntil(start, NEXTOPER(node) + EXTRA_STEP_2ARGS,
			     next, sv, l + 1);
	}
	else if ( op == PLUS || op == STAR) {
	    node = dumpuntil(start, NEXTOPER(node), NEXTOPER(node) + 1, sv, l + 1);
	}
	else if (op == ANYOF) {
	    /* arglen 1 + class block */
	    node += 1 + ((ANYOF_FLAGS(node) & ANYOF_LARGE)
		    ? ANYOF_CLASS_SKIP : ANYOF_SKIP);
	    node = NEXTOPER(node);
	}
	else if (PL_regkind[(U8)op] == EXACT) {
            /* Literal string, where present. */
	    node += NODE_SZ_STR(node) - 1;
	    node = NEXTOPER(node);
	}
	else {
	    node = NEXTOPER(node);
	    node += regarglen[(U8)op];
	}
	if (op == CURLYX || op == OPEN)
	    l++;
	else if (op == WHILEM)
	    l--;
    }
    return node;
}

#endif	/* DEBUGGING */

d4589 1
a4589 1
		      "anchored `%s%.*s%s'%s at %"IVdf" ",
d4592 1
a4592 1
		      SvPVX(r->anchored_substr),
d4598 1
a4598 1
		      "anchored utf8 `%s%.*s%s'%s at %"IVdf" ",
d4601 1
a4601 1
		      SvPVX(r->anchored_utf8),
d4607 1
a4607 1
		      "floating `%s%.*s%s'%s at %"IVdf"..%"UVuf" ",
d4610 1
a4610 1
		      SvPVX(r->float_substr),
d4616 1
a4616 1
		      "floating utf8 `%s%.*s%s'%s at %"IVdf"..%"UVuf" ",
d4619 1
a4619 1
		      SvPVX(r->float_utf8),
d4637 1
a4637 1
	PerlIO_printf(Perl_debug_log, "stclass `%s' ", SvPVX(sv));
d4663 1
a4663 1
      U32 len = r->offsets[0];
a4673 15
#ifdef DEBUGGING

STATIC void
S_put_byte(pTHX_ SV *sv, int c)
{
    if (isCNTRL(c) || c == 255 || !isPRINT(c))
	Perl_sv_catpvf(aTHX_ sv, "\\%o", c);
    else if (c == '-' || c == ']' || c == '\\' || c == '^')
	Perl_sv_catpvf(aTHX_ sv, "\\%c", c);
    else
	Perl_sv_catpvf(aTHX_ sv, "%c", c);
}

#endif	/* DEBUGGING */

d4688 1
a4688 1
    sv_catpv(sv, (char*)reg_name[OP(o)]); /* Take off const! */
d4693 1
a4693 1
        SV *dsv = sv_2mortal(newSVpvn("", 0));
d4697 2
a4698 2
	bool do_utf8 = is_utf8_string((U8*)STRING(o), STR_LEN(o));
	char *s    = do_utf8 ?
d4702 1
a4702 1
	int len = do_utf8 ?
d4723 1
a4723 1
	U8 flags = ANYOF_FLAGS(o);
d4794 1
a4794 1
	    SV *sw = regclass_swash(o, FALSE, &lv, 0);
d4798 1
a4798 1
		    U8 s[UTF8_MAXLEN+1];
d4801 1
a4801 1
			U8 *e = uvchr_to_utf8(s, i);
a4806 2
			    U8 *p;
			
d4809 3
a4811 1
				    for(e = uvchr_to_utf8(s, rangestart), p = s; p < e; p++)
d4815 7
a4821 1
				for (e = uvchr_to_utf8(s, rangestart), p = s; p < e; p++)
a4822 3
				sv_catpv(sv, "-");
				    for (e = uvchr_to_utf8(s, i - 1), p = s; p < e; p++)
					put_byte(sv, *p);
d4832 1
a4832 1
		    char *s = savepv(SvPVX(lv));
d4838 1
a4838 1
			char *t = ++s;
d4867 3
a4869 3
	{   STRLEN n_a;
	    char *s = SvPV(prog->check_substr
		      ? prog->check_substr : prog->check_utf8, n_a);
d4873 1
a4873 1
		      "%sUsing REx %ssubstr:%s `%s%.60s%s%s'\n",
d4895 2
a4896 5
	 int len;
         char *s;

	 s = (r->reganch & ROPT_UTF8) ? pv_uni_display(dsv, (U8*)r->precomp,
		r->prelen, 60, UNI_DISPLAY_REGEX)
d4898 1
a4898 1
	 len = SvCUR(dsv);
d4909 4
a4912 4
    if (r->precomp)
	Safefree(r->precomp);
    if (r->offsets)             /* 20010421 MJD */
	Safefree(r->offsets);
d4930 1
d4952 4
a4955 1
		if (!OpREFCNT_dec((OP_4tree*)r->data->data[n])) {
a4956 1
		}
d5005 1
a5005 1
    char *message;
d5023 1
a5023 1
    message = SvPV(msv,l1);
a5083 2
	U32 i;
	GV *mgv;
a5084 1
	char digits[16];
d5087 1
d5089 2
d5109 96
@


1.9
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d8 10
@


1.8
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d1191 3
a1193 1
		      && !deltanext  ) {
d3659 2
a3660 1
		continue;
d4064 3
@


1.7
log
@syncronous -> synchronous
@
text
@d72 2
a73 1
 ****    Copyright (c) 1991-2002, Larry Wall
d99 1
a99 1
# if defined(BUGGY_MSC6)
d101 1
a101 1
 # pragma optimize("a",off)
d103 2
a104 2
 # pragma optimize("w",on )
# endif /* BUGGY_MSC6 */
d260 14
a273 16
#define	FAIL(msg)                                                             \
    STMT_START {                                                             \
        char *ellipses = "";                                                 \
        IV len = RExC_end - RExC_precomp;                                \
                                                                             \
	if (!SIZE_ONLY)                                                      \
	    SAVEDESTRUCTOR_X(clear_re,(void*)RExC_rx);                 \
                                                                             \
	if (len > RegexLengthToShowInErrorMessages) {                        \
            /* chop 10 shorter than the max, to ensure meaning of "..." */   \
	    len = RegexLengthToShowInErrorMessages - 10;                     \
	    ellipses = "...";                                                \
	}                                                                    \
	Perl_croak(aTHX_ "%s in regex m/%.*s%s/",                            \
		   msg, (int)len, RExC_precomp, ellipses);                  \
    } STMT_END
d280 14
a293 16
#define	FAIL2(pat,msg)                                                        \
    STMT_START {                                                             \
        char *ellipses = "";                                                 \
        IV len = RExC_end - RExC_precomp;                                \
                                                                             \
	if (!SIZE_ONLY)                                                      \
	    SAVEDESTRUCTOR_X(clear_re,(void*)RExC_rx);                 \
                                                                             \
	if (len > RegexLengthToShowInErrorMessages) {                        \
            /* chop 10 shorter than the max, to ensure meaning of "..." */   \
	    len = RegexLengthToShowInErrorMessages - 10;                     \
	    ellipses = "...";                                                \
	}                                                                    \
	S_re_croak2(aTHX_ pat, " in regex m/%.*s%s/",                        \
		    msg, (int)len, RExC_precomp, ellipses);                \
    } STMT_END
d299 5
a303 7
#define	Simple_vFAIL(m)                                                      \
    STMT_START {                                                             \
      IV offset = RExC_parse - RExC_precomp; \
                                                                             \
      Perl_croak(aTHX_ "%s" REPORT_LOCATION,               \
		 m, (int)offset, RExC_precomp, RExC_precomp + offset);     \
    } STMT_END
d308 5
a312 6
#define	vFAIL(m)                                                             \
    STMT_START {                                                             \
      if (!SIZE_ONLY)                                                        \
	    SAVEDESTRUCTOR_X(clear_re,(void*)RExC_rx);                 \
      Simple_vFAIL(m);                                                       \
    } STMT_END
d317 5
a321 7
#define	Simple_vFAIL2(m,a1)                                                  \
    STMT_START {                                                             \
      IV offset = RExC_parse - RExC_precomp; \
                                                                             \
      S_re_croak2(aTHX_ m, REPORT_LOCATION, a1,       \
		  (int)offset, RExC_precomp, RExC_precomp + offset);       \
    } STMT_END
d326 5
a330 6
#define	vFAIL2(m,a1)                                                         \
    STMT_START {                                                             \
      if (!SIZE_ONLY)                                                        \
	    SAVEDESTRUCTOR_X(clear_re,(void*)RExC_rx);                 \
      Simple_vFAIL2(m, a1);                                                  \
    } STMT_END
d336 5
a340 7
#define	Simple_vFAIL3(m, a1, a2)                                             \
    STMT_START {                                                             \
      IV offset = RExC_parse - RExC_precomp; \
                                                                             \
      S_re_croak2(aTHX_ m, REPORT_LOCATION, a1, a2,   \
		  (int)offset, RExC_precomp, RExC_precomp + offset);       \
    } STMT_END
d345 5
a349 6
#define	vFAIL3(m,a1,a2)                                                      \
    STMT_START {                                                             \
      if (!SIZE_ONLY)                                                        \
	    SAVEDESTRUCTOR_X(clear_re,(void*)RExC_rx);                 \
      Simple_vFAIL3(m, a1, a2);                                              \
    } STMT_END
d354 5
a358 7
#define	Simple_vFAIL4(m, a1, a2, a3)                                         \
    STMT_START {                                                             \
      IV offset = RExC_parse - RExC_precomp; \
                                                                             \
      S_re_croak2(aTHX_ m, REPORT_LOCATION, a1, a2, a3,\
		  (int)offset, RExC_precomp, RExC_precomp + offset);       \
    } STMT_END
d363 44
a406 55
#define	Simple_vFAIL5(m, a1, a2, a3, a4)                                     \
    STMT_START {                                                             \
      IV offset = RExC_parse - RExC_precomp; \
      S_re_croak2(aTHX_ m, REPORT_LOCATION, a1, a2, a3, a4,\
		  (int)offset, RExC_precomp, RExC_precomp + offset);       \
    } STMT_END


#define	vWARN(loc,m)                                                         \
    STMT_START {                                                             \
        IV offset = loc - RExC_precomp;          \
	Perl_warner(aTHX_ packWARN(WARN_REGEXP), "%s" REPORT_LOCATION,\
		 m, (int)offset, RExC_precomp, RExC_precomp + offset);          \
    } STMT_END                                                               \

#define	vWARNdep(loc,m)                                                         \
    STMT_START {                                                             \
        IV offset = loc - RExC_precomp;          \
	Perl_warner(aTHX_ packWARN2(WARN_DEPRECATED, WARN_REGEXP), "%s" REPORT_LOCATION,\
		 m, (int)offset, RExC_precomp, RExC_precomp + offset);          \
    } STMT_END                                                               \


#define	vWARN2(loc, m, a1)                                                   \
    STMT_START {                                                             \
        IV offset = loc - RExC_precomp;          \
	Perl_warner(aTHX_ packWARN(WARN_REGEXP), m REPORT_LOCATION,\
                 a1,                                                         \
		 (int)offset, RExC_precomp, RExC_precomp + offset);        \
    } STMT_END

#define	vWARN3(loc, m, a1, a2)                                               \
    STMT_START {                                                             \
      IV offset = loc - RExC_precomp;        \
	Perl_warner(aTHX_ packWARN(WARN_REGEXP), m REPORT_LOCATION,                    \
                 a1, a2,                                                     \
		 (int)offset, RExC_precomp, RExC_precomp + offset);        \
    } STMT_END

#define	vWARN4(loc, m, a1, a2, a3)                                           \
    STMT_START {                                                             \
      IV offset = loc - RExC_precomp;            \
	Perl_warner(aTHX_ packWARN(WARN_REGEXP), m REPORT_LOCATION,\
                 a1, a2, a3,                                                 \
		 (int)offset, RExC_precomp, RExC_precomp + offset);        \
    } STMT_END

/* used for the parse_flags section for (?c) -- japhy */
#define	vWARN5(loc, m, a1, a2, a3, a4)                                       \
  STMT_START {                                                   \
      IV offset = loc - RExC_precomp;   \
        Perl_warner(aTHX_ packWARN(WARN_REGEXP), m REPORT_LOCATION,      \
                 a1, a2, a3, a4,                                 \
                 (int)offset, RExC_precomp, RExC_precomp + offset);  \
    } STMT_END
d410 3
a412 1
#define REGC(c,s) STMT_START { if (!SIZE_ONLY) *(s) = (c); else (void)(s);} STMT_END
d421 1
a421 1
/* #define MJD_OFFSET_DEBUG(x) fprintf x */
d424 33
a456 29
#  define Set_Node_Offset_To_R(node,byte)                           \
   STMT_START {                                        \
     if (! SIZE_ONLY) {                                  \
       if((node) < 0) {                   \
         Perl_croak(aTHX_ "value of node is %d in Offset macro", node); \
       } else {                                                        \
         RExC_offsets[2*(node)-1] = (byte);                               \
       }                                                               \
     }                                                                 \
   } STMT_END

#  define Set_Node_Offset(node,byte) Set_Node_Offset_To_R((node)-RExC_emit_start, (byte)-RExC_start)
#  define Set_Cur_Node_Offset Set_Node_Offset(RExC_emit, RExC_parse)

#  define Set_Node_Length_To_R(node,len)                            \
   STMT_START {                                        \
     if (! SIZE_ONLY) {                                  \
       MJD_OFFSET_DEBUG((stderr, "** (%d) size of node %d is %d.\n", __LINE__, (node), (len))); \
       if((node) < 0) {                   \
         Perl_croak(aTHX_ "value of node is %d in Length macro", node); \
       } else {                                                        \
         RExC_offsets[2*(node)] = (len);                               \
       }                                                               \
     }                                                                 \
   } STMT_END

#  define Set_Node_Length(node,len) Set_Node_Length_To_R((node)-RExC_emit_start, len)
#  define Set_Cur_Node_Length(len)  Set_Node_Length(RExC_emit, len)
#  define Set_Node_Cur_Length(node)   Set_Node_Length(node, RExC_parse - parse_start)
d475 1
a475 1
	sv_setsv(*data->longest, data->last_found);
d499 7
d579 2
a580 1
    if (cl->flags & ANYOF_UNICODE_ALL && and_with->flags & ANYOF_UNICODE) {
d585 2
a586 1
    if (!(and_with->flags & ANYOF_UNICODE_ALL))
d588 2
a589 1
    if (!(and_with->flags & (ANYOF_UNICODE|ANYOF_UNICODE_ALL)))
d927 8
d1292 2
d1305 8
d1318 2
a1319 2
			    data->last_start_max += is_inf ? 0 : (maxcount - 1)
				* (minnext + data->pos_delta);
d2230 1
a2230 1
		    AV *av;
d2239 1
a2239 1
		    rop = sv_compile_2op(sv, &sop, "re", &av);
d2248 1
a2248 1
		    RExC_rx->data->data[n+2] = (void*)av;
d2253 1
a2253 1
			&& PL_curcop != &PL_compiling)
d2270 4
a2273 1
		return reganode(pRExC_state, EVAL, n);
d2509 2
d2791 1
a2791 1
    char *parse_start = 0;
d2978 1
a2978 1
                char* parse_start = RExC_parse;
d3002 3
a3004 1
                Set_Node_Cur_Length(ret); /* MJD */
d3054 1
a3160 5
				/* numlen is generous */
				if (numlen + len >= 127) {
				    p--;
				    goto loopdone;
				}
d3304 1
a3304 1
	    if (len == 1)
d3319 8
a3326 2
	 STRLEN oldlen = STR_LEN(ret);
	 SV *sv        = sv_2mortal(newSVpvn(STRING(ret), oldlen));
d3328 12
a3339 16
	 if (RExC_utf8)
	      SvUTF8_on(sv);
	 if (sv_utf8_downgrade(sv, TRUE)) {
	      char *s       = sv_recode_to_utf8(sv, PL_encoding);
	      STRLEN newlen = SvCUR(sv);
	 
	      if (!SIZE_ONLY) {
		   DEBUG_r(PerlIO_printf(Perl_debug_log, "recode %*s to %*s\n",
					 (int)oldlen, STRING(ret),
					 (int)newlen, s));
		   Copy(s, STRING(ret), newlen, char);
		   STR_LEN(ret) += newlen - oldlen;
		   RExC_emit += STR_SZ(newlen) - STR_SZ(oldlen);
	      } else
		   RExC_size += STR_SZ(newlen) - STR_SZ(oldlen);
	 }
d4241 1
a4241 1
	 * in its textual form: used later (regexec.c:Perl_regclass_swatch())
d4245 1
a4245 1
	 * used later (regexec.c:s_reginclasslen()). */
d4266 3
a4268 1
	    while (*RExC_parse && *RExC_parse != ')')
d4270 1
d4280 2
a4281 3
		while (*RExC_parse && *RExC_parse != '\n')
		    RExC_parse++;
		RExC_parse++;
d4309 1
a4309 1
      MJD_OFFSET_DEBUG((stderr, "%s:%u: (op %s) %s %u <- %u (len %u) (max %u).\n", 
d4317 1
a4317 1
      Set_Node_Offset(RExC_emit, RExC_parse + (op == END));
d4345 1
a4345 1
      MJD_OFFSET_DEBUG((stderr, "%s: %s %u <- %u (max %u).\n", 
d4347 2
d4354 1
a4354 1
      Set_Cur_Node_Offset;
d4397 1
a4397 1
          MJD_OFFSET_DEBUG((stderr, "%s: %s copy %u -> %u (max %u).\n", 
d4399 2
d4406 2
a4407 2
          Set_Node_Offset_To_R(dst-RExC_emit_start, Node_Offset(src));
          Set_Node_Length_To_R(dst-RExC_emit_start, Node_Length(src));
d4414 1
a4414 1
      MJD_OFFSET_DEBUG((stderr, "%s: %s %u <- %u (max %u).\n", 
d4416 2
d4423 2
a4424 1
      Set_Node_Offset(place, RExC_parse);
d4944 2
a4945 3
	AV* new_comppad = NULL;
	AV* old_comppad;
	SV** old_curpad;
d4962 5
a4966 10
		old_comppad = PL_comppad;
		old_curpad = PL_curpad;
		/* Watch out for global destruction's random ordering. */
		if (SvTYPE(new_comppad) == SVt_PVAV) {
		    PL_comppad = new_comppad;
		    PL_curpad = AvARRAY(new_comppad);
		}
		else
		    PL_curpad = NULL;

d4971 1
a4971 2
		PL_comppad = old_comppad;
		PL_curpad = old_curpad;
d5040 1
a5040 1
    buf[l1] = '\0';			/* Overwrite \n */
a5048 14
#if 0
    SAVEPPTR(RExC_precomp);		/* uncompiled string. */
    SAVEI32(RExC_npar);		/* () count. */
    SAVEI32(RExC_size);		/* Code size. */
    SAVEI32(RExC_flags);		/* are we folding, multilining? */
    SAVEVPTR(RExC_rx);		/* from regcomp.c */
    SAVEI32(RExC_seen);		/* from regcomp.c */
    SAVEI32(RExC_sawback);		/* Did we see \1, ...? */
    SAVEI32(RExC_naughty);		/* How bad is this pattern? */
    SAVEVPTR(RExC_emit);		/* Code-emit pointer; &regdummy = don't */
    SAVEPPTR(RExC_end);		/* End of input for compile */
    SAVEPPTR(RExC_parse);		/* Input-scan pointer. */
#endif

d5057 1
d5074 1
a5074 1
    SAVEI8(PL_reg_match_utf8);		/* from regexec.c */
d5079 13
d5094 17
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d4717 1
a4717 1
	const char * const anyofs[] = {	/* Should be syncronized with
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d43 1
a43 1
#  define Perl_reginitcolors my_reginitcolors 
d46 1
a46 1
#endif 
d72 1
a72 1
 ****    Copyright (c) 1991-2001, Larry Wall
d86 1
a86 5
#ifdef PERL_IN_XSUB_RE
#  if defined(PERL_CAPI) || defined(PERL_OBJECT)
#    include "XSUB.h"
#  endif
#else
d110 45
d198 1
a198 1
static scan_data_t zero_scan_data = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
d230 3
a232 4
#define RF_utf8		8
#define UTF (PL_reg_flags & RF_utf8)
#define LOC (PL_regflags & PMf_LOCALE)
#define FOLD (PL_regflags & PMf_FOLD)
d234 1
a234 2
#define OOB_CHAR8		1234
#define OOB_UTF8		123456
d249 4
a252 4
#define MARKER1 "HERE"      /* marker as it appears in the description */
#define MARKER2 " << HERE "  /* marker as it appears within the regex */
   
#define REPORT_LOCATION " before " MARKER1 " mark in regex m/%.*s" MARKER2 "%s/"
d262 1
a262 1
        unsigned len = strlen(PL_regprecomp);                                \
d265 1
a265 1
	    SAVEDESTRUCTOR_X(clear_re,(void*)PL_regcomp_rx);                 \
d273 1
a273 1
		   msg, (int)len, PL_regprecomp, ellipses);                  \
d284 1
a284 1
        unsigned len = strlen(PL_regprecomp);                                \
d287 1
a287 1
	    SAVEDESTRUCTOR_X(clear_re,(void*)PL_regcomp_rx);                 \
d295 1
a295 1
		    msg, (int)len, PL_regprecomp, ellipses);                \
d304 1
a304 1
      unsigned offset = strlen(PL_regprecomp)-(PL_regxend-PL_regcomp_parse); \
d307 1
a307 1
		 m, (int)offset, PL_regprecomp, PL_regprecomp + offset);     \
d316 1
a316 1
	    SAVEDESTRUCTOR_X(clear_re,(void*)PL_regcomp_rx);                 \
d325 1
a325 1
      unsigned offset = strlen(PL_regprecomp)-(PL_regxend-PL_regcomp_parse); \
d328 1
a328 1
		  (int)offset, PL_regprecomp, PL_regprecomp + offset);       \
d337 1
a337 1
	    SAVEDESTRUCTOR_X(clear_re,(void*)PL_regcomp_rx);                 \
d347 1
a347 1
      unsigned offset = strlen(PL_regprecomp)-(PL_regxend-PL_regcomp_parse); \
d350 1
a350 1
		  (int)offset, PL_regprecomp, PL_regprecomp + offset);       \
d359 1
a359 1
	    SAVEDESTRUCTOR_X(clear_re,(void*)PL_regcomp_rx);                 \
d368 1
a368 1
      unsigned offset = strlen(PL_regprecomp)-(PL_regxend-PL_regcomp_parse); \
d371 1
a371 1
		  (int)offset, PL_regprecomp, PL_regprecomp + offset);       \
d379 1
a379 1
      unsigned offset = strlen(PL_regprecomp)-(PL_regxend-PL_regcomp_parse); \
d381 1
a381 1
		  (int)offset, PL_regprecomp, PL_regprecomp + offset);       \
d387 10
a396 3
        unsigned offset = strlen(PL_regprecomp)-(PL_regxend-(loc));          \
	Perl_warner(aTHX_ WARN_REGEXP, "%s" REPORT_LOCATION,\
		 m, (int)offset, PL_regprecomp, PL_regprecomp + offset);          \
d402 2
a403 2
        unsigned offset = strlen(PL_regprecomp)-(PL_regxend-(loc));          \
	Perl_warner(aTHX_ WARN_REGEXP, m REPORT_LOCATION,\
d405 1
a405 1
		 (int)offset, PL_regprecomp, PL_regprecomp + offset);        \
d410 2
a411 2
      unsigned offset = strlen(PL_regprecomp) - (PL_regxend - (loc));        \
	Perl_warner(aTHX_ WARN_REGEXP, m REPORT_LOCATION,                    \
d413 1
a413 1
		 (int)offset, PL_regprecomp, PL_regprecomp + offset);        \
d418 2
a419 2
      unsigned offset = strlen(PL_regprecomp)-(PL_regxend-(loc));            \
	Perl_warner(aTHX_ WARN_REGEXP, m REPORT_LOCATION,\
d421 1
a421 1
		 (int)offset, PL_regprecomp, PL_regprecomp + offset);        \
d424 8
d435 7
a441 1
#define REGC(c,s) STMT_START { if (!SIZE_ONLY) *(s) = (c); else (s);} STMT_END
d443 39
a481 1
static void clear_re(pTHXo_ void *r);
d488 1
a488 1
S_scan_commit(pTHX_ scan_data_t *data)
d492 1
a492 1
    
d498 1
a498 1
		data->flags 
d505 2
a506 2
	    data->offset_float_max = (l 
				      ? data->last_start_max 
d508 2
d511 1
a511 1
		data->flags 
d524 1
a524 1
S_cl_anything(pTHX_ struct regnode_charclass_class *cl)
a525 2
    int value;

d527 2
a528 3
    for (value = 0; value < 256; ++value)
	ANYOF_BITMAP_SET(cl, value);
    cl->flags = ANYOF_EOS;
d542 4
a545 3
    for (value = 0; value < 256; ++value)
	if (!ANYOF_BITMAP_TEST(cl, value))
	    return 0;
d551 1
a551 1
S_cl_init(pTHX_ struct regnode_charclass_class *cl)
d555 1
a555 1
    cl_anything(cl);
d559 1
a559 1
S_cl_init_zero(pTHX_ struct regnode_charclass_class *cl)
d563 1
a563 1
    cl_anything(cl);
d590 10
d605 1
a605 1
S_cl_or(pTHX_ struct regnode_charclass_class *cl, struct regnode_charclass_class *or_with)
d626 1
a626 1
	    cl_anything(cl);
d631 1
a631 1
	     && (!(or_with->flags & ANYOF_FOLD) 
d645 1
a645 1
	    cl_anything(cl);
d650 10
d662 11
d680 1
a680 1
S_study_chunk(pTHX_ regnode **scanp, I32 *deltap, regnode *last, scan_data_t *data, U32 flags)
d693 1
a693 1
    
d703 1
a703 1
#endif 
d708 1
a708 1
		   ( PL_regkind[(U8)OP(n)] == NOTHING || 
d720 1
a720 1
#endif 
d727 1
a727 1
		    if (oldl + STR_LEN(n) > U8_MAX) 
d736 1
a736 1
#endif 
d740 44
d806 1
a806 1
	    
d815 1
a815 1
	    else 
d820 1
a820 1
	if (OP(scan) == BRANCH || OP(scan) == BRANCHJ 
d824 2
a825 2
	    
	    if (OP(next) == code || code == IFTHEN || code == SUSPEND) { 
d830 1
a830 1
		    scan_commit(data);	/* Cannot merge strings after this. */
d832 1
a832 1
		    cl_init_zero(&accum);
d834 1
a834 1
		    I32 deltanext, minnext, f = 0, fake = 0;
d839 1
a839 1
		    if (data) {		    
d850 1
a850 1
			cl_init(&this_class);
d853 1
a853 1
		    }		    
d857 3
a859 3
		    minnext = study_chunk(&scan, &deltanext, next,
					  &data_fake, f);
		    if (min1 > minnext) 
d873 2
a874 2
			cl_or(&accum, &this_class);
		    if (code == SUSPEND) 
d888 1
a888 1
		    cl_or(data->start_class, &accum);
d900 1
a900 1
			/* Switch to OR mode: cache the old value of 
d920 1
d922 3
a924 8
		unsigned char *s = (unsigned char *)STRING(scan);
		unsigned char *e = s + l;
		I32 newl = 0;
		while (s < e) {
		    newl++;
		    s += UTF8SKIP(s);
		}
		l = newl;
d933 1
a933 1
 			? I32_MAX : data->pos_min + data->pos_delta; 
d936 2
d946 3
a948 2
		if (!(data->start_class->flags & (ANYOF_CLASS | ANYOF_LOCALE)) 
		    && !ANYOF_BITMAP_TEST(data->start_class, *STRING(scan))
d950 2
a951 2
			|| !ANYOF_BITMAP_TEST(data->start_class,
					      PL_fold[*(U8*)STRING(scan)])))
d956 1
a956 1
		    ANYOF_BITMAP_SET(data->start_class, *STRING(scan));
d958 2
d963 4
a966 1
		ANYOF_BITMAP_SET(data->start_class, *STRING(scan));	
d974 1
d977 2
a978 2
	    if (flags & SCF_DO_SUBSTR) 
		scan_commit(data);
d980 3
a982 8
		unsigned char *s = (unsigned char *)STRING(scan);
		unsigned char *e = s + l;
		I32 newl = 0;
		while (s < e) {
		    newl++;
		    s += UTF8SKIP(s);
		}
		l = newl;
d991 4
a994 4
		if (!(data->start_class->flags & (ANYOF_CLASS | ANYOF_LOCALE)) 
		    && !ANYOF_BITMAP_TEST(data->start_class, *STRING(scan))
		    && !ANYOF_BITMAP_TEST(data->start_class, 
					  PL_fold[*(U8*)STRING(scan)]))
d999 1
a999 1
		    ANYOF_BITMAP_SET(data->start_class, *STRING(scan));
d1010 2
a1011 1
		    ANYOF_BITMAP_SET(data->start_class, *STRING(scan));	
d1019 1
a1019 1
	    I32 mincount, maxcount, minnext, deltanext, fl;
d1024 1
d1034 2
a1035 2
			mincount = 1; 
			maxcount = REG_INFTY; 
d1048 1
a1048 1
		    maxcount = REG_INFTY; 
d1053 1
a1053 1
		is_inf = is_inf_internal = 1; 
d1056 1
a1056 1
		    scan_commit(data);	/* Cannot extend fixed substrings */
d1061 1
a1061 1
		mincount = ARG1(scan); 
d1070 1
d1073 1
a1073 1
		    if (mincount == 0) scan_commit(data); /* Cannot extend fixed substrings */
d1083 1
a1083 1
		    cl_init(&this_class);
d1092 1
a1092 1
		   
d1099 2
a1100 2
		minnext = study_chunk(&scan, &deltanext, last, data, 
				      mincount == 0 
d1107 1
a1107 1
			cl_or(data->start_class, &this_class);
d1110 1
a1110 1
			/* Switch to OR mode: cache the old value of 
d1122 1
a1122 1
			cl_or(data->start_class, &this_class);
d1131 5
a1135 2
		if (ckWARN(WARN_REGEXP) && (minnext + deltanext == 0) 
		    && !(data->flags & (SF_HAS_PAR|SF_IN_PAR))
d1138 1
a1138 1
		    vWARN(PL_regcomp_parse,
d1143 1
a1143 1
		is_inf_internal |= ((maxcount == REG_INFTY 
d1150 1
a1150 1
		if (  OP(oscan) == CURLYX && data 
d1156 4
a1159 1
		    regnode *nxt1 = nxt, *nxt2;
d1165 1
a1165 1
			     && STR_LEN(nxt) == 1)) 
d1167 1
d1169 1
d1171 1
a1171 1
		    if (OP(nxt) != CLOSE) 
d1174 1
a1174 1
		    oscan->flags = ARG(nxt);
d1184 1
a1184 1
#endif 
d1189 1
a1189 1
		if (  OP(oscan) == CURLYX && data 
d1200 1
a1200 1
			    && (OP(nxt2) != WHILEM)) 
d1208 1
a1208 1
			if (OP(nxt) != CLOSE) 
d1210 1
a1210 1
			oscan->flags = ARG(nxt);
d1218 1
a1218 1
#endif 
d1222 1
a1222 1
			    
d1235 2
a1236 1
			study_chunk(&nxt1, &deltanext, nxt, NULL, 0);
d1254 2
a1255 2
		    PREVOPER(nxt)->flags = data->whilem_c
			| (PL_reg_whilem_seen << 4); /* On WHILEM */
d1257 1
a1257 1
		if (data && fl & (SF_HAS_PAR|SF_IN_PAR)) 
d1264 17
a1280 1
			I32 b = pos_before >= data->last_start_min 
d1285 1
d1297 1
a1297 1
				repeatcpy(SvPVX(last_str) + l, 
d1301 1
a1301 1
				SvCUR_set(data->last_found, 
d1320 1
a1320 1
			scan_commit(data);
d1324 1
a1324 1
			    data->last_start_min = 
d1326 2
a1327 2
			    data->last_start_max = is_inf 
				? I32_MAX 
d1346 1
a1346 1
		    scan_commit(data);	/* Cannot expect anything... */
d1351 1
a1351 1
		    cl_anything(data->start_class);
d1356 2
a1357 2
	else if (strchr((char*)PL_simple,OP(scan)) || PL_regkind[(U8)OP(scan)] == ANYUTF8) {
	    int value;
d1360 1
a1360 1
		scan_commit(data);
a1369 1
		case ANYUTF8:
a1370 12
		case SANYUTF8:
		case ALNUMUTF8:
		case ANYOFUTF8:
		case ALNUMLUTF8:
		case NALNUMUTF8:
		case NALNUMLUTF8:
		case SPACEUTF8:
		case NSPACEUTF8:
		case SPACELUTF8:
		case NSPACELUTF8:
		case DIGITUTF8:
		case NDIGITUTF8:
d1375 1
a1375 1
			cl_anything(data->start_class);
d1383 1
a1383 1
			cl_anything(data->start_class);
d1393 1
a1393 1
			cl_or(data->start_class,
d1411 1
a1411 1
				    ANYOF_BITMAP_SET(data->start_class, value);			    
d1440 1
a1440 1
				    ANYOF_BITMAP_SET(data->start_class, value);			    
d1469 1
a1469 1
				    ANYOF_BITMAP_SET(data->start_class, value);			    
d1498 1
a1498 1
				    ANYOF_BITMAP_SET(data->start_class, value);			    
d1529 1
a1529 1
				    ANYOF_BITMAP_SET(data->start_class, value);			    
d1546 1
a1546 1
				    ANYOF_BITMAP_SET(data->start_class, value);			    
d1572 1
a1572 1
	    if (data) {		    
d1580 1
a1580 1
		cl_init(&intrnl);
d1588 1
a1588 1
	    minnext = study_chunk(&nscan, &deltanext, last, &data_fake, f);
d1596 1
a1596 1
		scan->flags = minnext;
d1616 1
a1616 1
	    if (ARG(scan) == is_par) {
d1631 1
a1631 1
		    scan_commit(data);
d1636 1
a1636 1
		    cl_anything(data->start_class);
d1646 1
a1646 1
    if (flags & SCF_DO_SUBSTR && is_inf) 
d1664 1
a1664 1
S_add_data(pTHX_ I32 n, char *s)
d1666 3
a1668 3
    if (PL_regcomp_rx->data) {
	Renewc(PL_regcomp_rx->data, 
	       sizeof(*PL_regcomp_rx->data) + sizeof(void*) * (PL_regcomp_rx->data->count + n - 1), 
d1670 2
a1671 2
	Renew(PL_regcomp_rx->data->what, PL_regcomp_rx->data->count + n, U8);
	PL_regcomp_rx->data->count += n;
d1674 1
a1674 1
	Newc(1207, PL_regcomp_rx->data, sizeof(*PL_regcomp_rx->data) + sizeof(void*) * (n - 1),
d1676 2
a1677 2
	New(1208, PL_regcomp_rx->data->what, n, U8);
	PL_regcomp_rx->data->count = n;
d1679 2
a1680 2
    Copy(s, PL_regcomp_rx->data->what + PL_regcomp_rx->data->count - n, n, U8);
    return PL_regcomp_rx->data->count - n;
d1688 1
a1688 1
	    
d1701 1
a1701 1
	while (i < 6) 
d1734 2
d1740 1
a1740 5
    if (pm->op_pmdynflags & PMdf_UTF8) {
	PL_reg_flags |= RF_utf8;
    }
    else
	PL_reg_flags = 0;
d1742 14
a1755 12
    PL_regprecomp = exp;
    DEBUG_r(if (!PL_colorset) reginitcolors());
    DEBUG_r(PerlIO_printf(Perl_debug_log, "%sCompiling REx%s `%s%*s%s'\n",
		      PL_colors[4],PL_colors[5],PL_colors[0],
		      (int)(xend - exp), PL_regprecomp, PL_colors[1]));
    PL_regflags = pm->op_pmflags;
    PL_regsawback = 0;

    PL_regseen = 0;
    PL_seen_zerolen = *exp == '^' ? -1 : 0;
    PL_seen_evals = 0;
    PL_extralen = 0;
d1758 8
a1765 7
    PL_regcomp_parse = exp;
    PL_regxend = xend;
    PL_regnaughty = 0;
    PL_regnpar = 1;
    PL_regsize = 0L;
    PL_regcode = &PL_regdummy;
    PL_reg_whilem_seen = 0;
d1768 1
a1768 1
    REGC((U8)REG_MAGIC, (char*)PL_regcode);
d1770 2
a1771 2
    if (reg(0, &flags) == NULL) {
	PL_regprecomp = Nullch;
d1774 1
a1774 1
    DEBUG_r(PerlIO_printf(Perl_debug_log, "size %"IVdf" ", (IV)PL_regsize));
d1778 2
a1779 2
    if (PL_regsize >= 0x10000L && PL_extralen)
        PL_regsize += PL_extralen;
d1781 3
a1783 3
	PL_extralen = 0;
    if (PL_reg_whilem_seen > 15)
	PL_reg_whilem_seen = 15;
d1786 1
a1786 1
    Newc(1001, r, sizeof(regexp) + (unsigned)PL_regsize * sizeof(regnode),
d1793 1
a1793 1
    Zero(r, sizeof(regexp) + (unsigned)PL_regsize * sizeof(regnode), char);
d1797 1
a1797 1
    r->precomp = savepvn(PL_regprecomp, r->prelen);
d1800 1
a1800 1
    r->nparens = PL_regnpar - 1;	/* set early to validate backrefs */
d1806 10
a1815 1
    PL_regcomp_rx = r;
d1818 7
a1824 5
    PL_regcomp_parse = exp;
    PL_regxend = xend;
    PL_regnaughty = 0;
    PL_regnpar = 1;
    PL_regcode = r->program;
d1826 2
a1827 2
    PL_regcode->next_off = ((PL_seen_evals > U16_MAX) ? U16_MAX : PL_seen_evals);
    REGC((U8)REG_MAGIC, (char*) PL_regcode++);
d1829 1
a1829 1
    if (reg(0, &flags) == NULL)
d1834 1
a1834 1
    pm->op_pmflags = PL_regflags;
d1836 1
a1836 1
	r->reganch |= ROPT_UTF8;
d1838 1
a1838 1
    if (PL_regnaughty >= 10)	/* Probably an expensive pattern. */
d1874 3
a1876 3
	    if (OP(first) == EXACT);	/* Empty, get anchored substr later. */
	    else if ((OP(first) == EXACTF || OP(first) == EXACTFL)
		     && !UTF)
d1898 1
a1898 1
	else if ((OP(first) == STAR &&
d1905 1
a1905 1
	    if (type == REG_ANY || type == ANYUTF8)
d1914 2
a1915 2
	if (sawplus && (!sawopen || !PL_regsawback) 
	    && !(PL_regseen & REG_SEEN_EVAL)) /* May examine pos and $& */
d1920 1
a1920 1
	DEBUG_r(PerlIO_printf(Perl_debug_log, "first at %"IVdf"\n", 
d1941 1
a1941 1
	    cl_init(&ch_class);
d1948 1
a1948 1
	minlen = study_chunk(&first, &fake, scan + PL_regsize, /* Up to end */
d1950 4
a1953 4
	if ( PL_regnpar == 1 && data.longest == &(data.longest_fixed)
	     && data.last_start_min == 0 && data.last_end > 0 
	     && !PL_seen_zerolen
	     && (!(PL_regseen & REG_SEEN_GPOS) || (r->reganch & ROPT_ANCH_GPOS)))
d1955 1
a1955 1
	scan_commit(&data);
d1962 1
a1962 1
		    || (PL_regflags & PMf_MULTILINE)))) {
d1970 7
a1976 1
	    r->float_substr = data.longest_float;
d1981 2
a1982 2
			   || (PL_regflags & PMf_MULTILINE)));
	    fbm_compile(r->float_substr, t ? FBMcf_TAIL : 0);
d1986 1
a1986 1
	    r->float_substr = Nullsv;
d1995 1
a1995 1
		    || (PL_regflags & PMf_MULTILINE)))) {
d1998 7
a2004 1
	    r->anchored_substr = data.longest_fixed;
d2008 2
a2009 2
		     || (PL_regflags & PMf_MULTILINE)));
	    fbm_compile(r->anchored_substr, t ? FBMcf_TAIL : 0);
d2012 1
a2012 1
	    r->anchored_substr = Nullsv;
d2016 2
a2017 3
	if (r->regstclass 
	    && (OP(r->regstclass) == REG_ANY || OP(r->regstclass) == ANYUTF8
		|| OP(r->regstclass) == SANYUTF8 || OP(r->regstclass) == SANY))
d2019 2
a2020 1
	if ((!r->anchored_substr || r->anchored_offset) && stclass_flag
d2022 3
a2024 3
	    && !cl_is_anything(data.start_class)) {
	    SV *sv;
	    I32 n = add_data(1, "f");
d2026 1
a2026 1
	    New(1006, PL_regcomp_rx->data->data[n], 1, 
d2029 1
a2029 1
		       (struct regnode_charclass_class*)PL_regcomp_rx->data->data[n],
d2031 1
a2031 1
	    r->regstclass = (regnode*)PL_regcomp_rx->data->data[n];
d2033 6
a2038 4
	    DEBUG_r((sv = sv_newmortal(),
		     regprop(sv, (regnode*)data.start_class),
		     PerlIO_printf(Perl_debug_log, "synthetic stclass `%s'.\n",
				   SvPVX(sv))));
d2044 1
d2051 1
d2057 1
a2057 1
	if (r->check_substr && !(r->reganch & ROPT_ANCH_GPOS)) {
d2059 1
a2059 1
	    if (SvTAIL(r->check_substr))
d2071 1
a2071 1
	cl_init(&ch_class);
d2074 3
a2076 2
	minlen = study_chunk(&scan, &fake, scan + PL_regsize, &data, SCF_DO_STCLASS_AND|SCF_WHILEM_VISITED_POS);
	r->check_substr = r->anchored_substr = r->float_substr = Nullsv;
d2078 3
a2080 3
	    && !cl_is_anything(data.start_class)) {
	    SV *sv;
	    I32 n = add_data(1, "f");
d2082 1
a2082 1
	    New(1006, PL_regcomp_rx->data->data[n], 1, 
d2085 1
a2085 1
		       (struct regnode_charclass_class*)PL_regcomp_rx->data->data[n],
d2087 1
a2087 1
	    r->regstclass = (regnode*)PL_regcomp_rx->data->data[n];
d2089 5
a2093 4
	    DEBUG_r((sv = sv_newmortal(),
		     regprop(sv, (regnode*)data.start_class),
		     PerlIO_printf(Perl_debug_log, "synthetic stclass `%s'.\n",
				   SvPVX(sv))));
d2098 1
a2098 1
    if (PL_regseen & REG_SEEN_GPOS) 
d2100 1
a2100 1
    if (PL_regseen & REG_SEEN_LOOKBEHIND)
d2102 1
a2102 1
    if (PL_regseen & REG_SEEN_EVAL)
d2104 5
a2108 3
    Newz(1002, r->startp, PL_regnpar, I32);
    Newz(1002, r->endp, PL_regnpar, I32);
    PL_regdata = r->data; /* for regprop() ANYOFUTF8 */
d2123 1
a2123 1
S_reg(pTHX_ I32 paren, I32 *flagp)
d2131 13
a2143 2
    I32 flags, oregflags = PL_regflags, have_branch = 0, open = 0;
    char *oregcomp_parse = PL_regcomp_parse;
d2148 1
d2151 3
a2153 3
	if (*PL_regcomp_parse == '?') {
	    U16 posflags = 0, negflags = 0;
	    U16 *flagsp = &posflags;
d2155 1
a2155 1
	    char *seqstart = PL_regcomp_parse;
d2157 2
a2158 2
	    PL_regcomp_parse++;
	    paren = *PL_regcomp_parse++;
d2161 3
a2163 3
	    case '<':
		PL_regseen |= REG_SEEN_LOOKBEHIND;
		if (*PL_regcomp_parse == '!') 
d2165 1
a2165 1
		if (*PL_regcomp_parse != '=' && *PL_regcomp_parse != '!') 
d2167 6
a2172 6
		PL_regcomp_parse++;
	    case '=':
	    case '!':
		PL_seen_zerolen++;
	    case ':':
	    case '>':
d2174 2
a2175 2
	    case '$':
	    case '@@':
d2178 4
a2181 4
	    case '#':
		while (*PL_regcomp_parse && *PL_regcomp_parse != ')')
		    PL_regcomp_parse++;
		if (*PL_regcomp_parse != ')')
d2183 1
a2183 1
		nextchar();
d2186 3
a2188 3
	    case 'p':
		if (SIZE_ONLY)
		    vWARN(PL_regcomp_parse, "(?p{}) is deprecated - use (??{})");
d2190 1
a2190 1
	    case '?':
d2192 3
a2194 1
		paren = *PL_regcomp_parse++;
d2196 1
a2196 1
	    case '{':
d2200 1
a2200 1
		char *s = PL_regcomp_parse;
d2204 6
a2209 6
		PL_seen_zerolen++;
		PL_regseen |= REG_SEEN_EVAL;
		while (count && (c = *PL_regcomp_parse)) {
		    if (c == '\\' && PL_regcomp_parse[1])
			PL_regcomp_parse++;
		    else if (c == '{') 
d2211 1
a2211 1
		    else if (c == '}') 
d2213 1
a2213 1
		    PL_regcomp_parse++;
d2215 1
a2215 1
		if (*PL_regcomp_parse != ')')
d2217 1
a2217 1
		    PL_regcomp_parse = s;		    
d2222 3
a2224 3
		    
		    if (PL_regcomp_parse - 1 - s) 
			sv = newSVpvn(s, PL_regcomp_parse - 1 - s);
d2231 3
d2236 4
a2239 4
		    n = add_data(3, "nop");
		    PL_regcomp_rx->data->data[n] = (void*)rop;
		    PL_regcomp_rx->data->data[n+1] = (void*)sop;
		    PL_regcomp_rx->data->data[n+2] = (void*)av;
d2243 1
a2243 1
		    if (PL_reginterp_cnt < ++PL_seen_evals
d2248 1
a2248 1
		    if (PL_tainted)
d2252 1
a2252 1
		nextchar();
d2254 1
a2254 1
		    ret = reg_node(LOGICAL);
d2257 2
a2258 1
		    regtail(ret, reganode(EVAL, n));
d2261 1
a2261 1
		return reganode(EVAL, n);
d2263 1
a2263 1
	    case '(':
d2265 4
a2268 4
		if (PL_regcomp_parse[0] == '?') {
		    if (PL_regcomp_parse[1] == '=' || PL_regcomp_parse[1] == '!' 
			|| PL_regcomp_parse[1] == '<' 
			|| PL_regcomp_parse[1] == '{') { /* Lookahead or eval. */
d2271 1
a2271 1
			ret = reg_node(LOGICAL);
d2274 1
a2274 1
			regtail(ret, reg(1, &flag));
d2276 1
a2276 1
		    } 
d2278 9
a2286 7
		else if (PL_regcomp_parse[0] >= '1' && PL_regcomp_parse[0] <= '9' ) {
		    parno = atoi(PL_regcomp_parse++);

		    while (isDIGIT(*PL_regcomp_parse))
			PL_regcomp_parse++;
		    ret = reganode(GROUPP, parno);
		    if ((c = *nextchar()) != ')')
d2289 2
a2290 2
		    regtail(ret, reganode(IFTHEN, 0));
		    br = regbranch(&flags, 1);
d2292 1
a2292 1
			br = reganode(LONGJMP, 0);
d2294 2
a2295 2
			regtail(br, reganode(LONGJMP, 0));
		    c = *nextchar();
d2299 3
a2301 3
			lastbr = reganode(IFTHEN, 0); /* Fake one for optimizer. */
			regbranch(&flags, 1);
			regtail(ret, lastbr);
d2304 1
a2304 1
			c = *nextchar();
d2310 2
a2311 2
		    ender = reg_node(TAIL);
		    regtail(br, ender);
d2313 2
a2314 2
			regtail(lastbr, ender);
			regtail(NEXTOPER(NEXTOPER(lastbr)), ender);
d2317 1
a2317 1
			regtail(ret, ender);
d2321 1
a2321 1
		    vFAIL2("Unknown switch condition (?(%.2s", PL_regcomp_parse);
d2325 1
a2325 1
		PL_regcomp_parse--; /* for vFAIL to print correctly */
d2329 38
a2366 6
		--PL_regcomp_parse;
	      parse_flags:
		while (*PL_regcomp_parse && strchr("iogcmsx", *PL_regcomp_parse)) {
		    if (*PL_regcomp_parse != 'o')
			pmflag(flagsp, *PL_regcomp_parse);
		    ++PL_regcomp_parse;
d2368 1
a2368 1
		if (*PL_regcomp_parse == '-') {
d2370 2
a2371 1
		    ++PL_regcomp_parse;
d2374 4
a2377 4
		PL_regflags |= posflags;
		PL_regflags &= ~negflags;
		if (*PL_regcomp_parse == ':') {
		    PL_regcomp_parse++;
d2382 3
a2384 3
		if (*PL_regcomp_parse != ')') {
		    PL_regcomp_parse++;
		    vFAIL3("Sequence (%.*s...) not recognized", PL_regcomp_parse-seqstart, seqstart);
d2386 1
a2386 1
		nextchar();
d2391 6
a2396 4
	else {
	    parno = PL_regnpar;
	    PL_regnpar++;
	    ret = reganode(OPEN, parno);
d2400 1
a2400 1
    else
d2404 4
a2407 1
    br = regbranch(&flags, 1);
d2410 9
a2418 6
    if (*PL_regcomp_parse == '|') {
	if (!SIZE_ONLY && PL_extralen) {
	    reginsert(BRANCHJ, br);
	}
	else
	    reginsert(BRANCH, br);
d2421 1
a2421 1
	    PL_extralen += 1;		/* For BRANCHJ-BRANCH. */
d2427 1
a2427 1
	regtail(ret, br);		/* OPEN -> first. */
d2431 1
a2431 3
    if (flags&HASWIDTH)
	*flagp |= HASWIDTH;
    *flagp |= flags&SPSTART;
d2433 4
a2436 4
    while (*PL_regcomp_parse == '|') {
	if (!SIZE_ONLY && PL_extralen) {
	    ender = reganode(LONGJMP,0);
	    regtail(NEXTOPER(NEXTOPER(lastbr)), ender); /* Append to the previous. */
d2439 4
a2442 3
	    PL_extralen += 2;		/* Account for LONGJMP. */
	nextchar();
	br = regbranch(&flags, 0);
d2445 1
a2445 1
	regtail(lastbr, br);		/* BRANCH -> BRANCH. */
d2456 1
a2456 1
	    ender = reg_node(TAIL);
d2459 3
a2461 1
	    ender = reganode(CLOSE, parno);
d2470 1
a2470 1
	    ender = reg_node(SUCCEED);
d2473 1
a2473 1
	    ender = reg_node(END);
d2476 1
a2476 1
	regtail(lastbr, ender);
d2481 1
a2481 1
		regoptail(br, ender);
d2491 1
a2491 1
	    int node = ((p - parens) % 2) ? UNLESSM : IFMATCH;
d2496 1
a2496 1
	    reginsert(node,ret);
d2498 1
a2498 1
	    regtail(ret, reg_node(TAIL));
d2504 3
a2506 3
	PL_regflags = oregflags;
	if (PL_regcomp_parse >= PL_regxend || *nextchar() != ')') {
	    PL_regcomp_parse = oregcomp_parse;
d2510 3
a2512 3
    else if (!paren && PL_regcomp_parse < PL_regxend) {
	if (*PL_regcomp_parse == ')') {
	    PL_regcomp_parse++;
d2529 1
a2529 1
S_regbranch(pTHX_ I32 *flagp, I32 first)
d2536 1
a2536 1
    if (first) 
d2539 6
a2544 4
	if (!SIZE_ONLY && PL_extralen) 
	    ret = reganode(BRANCHJ,0);
	else
	    ret = reg_node(BRANCH);
d2547 3
a2549 3
    if (!first && SIZE_ONLY) 
	PL_extralen += 1;			/* BRANCHJ */
    
d2552 3
a2554 3
    PL_regcomp_parse--;
    nextchar();
    while (PL_regcomp_parse < PL_regxend && *PL_regcomp_parse != '|' && *PL_regcomp_parse != ')') {
d2556 1
a2556 1
	latest = regpiece(&flags);
d2568 2
a2569 2
	    PL_regnaughty++;
	    regtail(chain, latest);
d2575 1
a2575 1
	chain = reg_node(NOTHING);
d2596 1
a2596 1
S_regpiece(pTHX_ I32 *flagp)
d2602 1
a2602 1
    char *origparse = PL_regcomp_parse;
d2606 1
d2608 1
a2608 1
    ret = regatom(&flags);
d2615 1
a2615 1
    op = *PL_regcomp_parse;
d2617 3
a2619 2
    if (op == '{' && regcurly(PL_regcomp_parse)) {
	next = PL_regcomp_parse + 1;
d2633 2
a2634 2
	    PL_regcomp_parse++;
	    min = atoi(PL_regcomp_parse);
d2638 1
a2638 1
		maxpos = PL_regcomp_parse;
d2644 2
a2645 2
	    PL_regcomp_parse = next;
	    nextchar();
d2649 4
a2652 2
		PL_regnaughty += 2 + PL_regnaughty / 2;
		reginsert(CURLY, ret);
d2655 1
a2655 1
		regnode *w = reg_node(WHILEM);
d2658 4
a2661 4
		regtail(ret, w);
		if (!SIZE_ONLY && PL_extralen) {
		    reginsert(LONGJMP,ret);
		    reginsert(NOTHING,ret);
d2664 7
a2670 2
		reginsert(CURLYX,ret);
		if (!SIZE_ONLY && PL_extralen)
d2672 1
a2672 1
		regtail(ret, reg_node(NOTHING));
d2674 2
a2675 2
		    PL_reg_whilem_seen++, PL_extralen += 3;
		PL_regnaughty += 4 + PL_regnaughty;	/* compound interest */
d2686 2
a2687 2
		ARG1_SET(ret, min);
		ARG2_SET(ret, max);
d2713 1
a2713 1
#endif 
d2715 2
a2716 1
    nextchar();
d2721 1
a2721 1
	reginsert(STAR, ret);
d2723 1
a2723 1
	PL_regnaughty += 4;
d2730 1
a2730 1
	reginsert(PLUS, ret);
d2732 1
a2732 1
	PL_regnaughty += 3;
d2744 1
a2744 1
	vWARN3(PL_regcomp_parse,
d2746 1
a2746 1
	       PL_regcomp_parse - origparse,
d2750 4
a2753 4
    if (*PL_regcomp_parse == '?') {
	nextchar();
	reginsert(MINMOD, ret);
	regtail(ret, ret + NODE_STEP_REGNODE);
d2755 2
a2756 2
    if (ISMULT2(PL_regcomp_parse)) {
	PL_regcomp_parse++;
d2773 1
a2773 1
S_regatom(pTHX_ I32 *flagp)
d2777 1
d2782 1
a2782 1
    switch (*PL_regcomp_parse) {
d2784 6
a2789 6
	PL_seen_zerolen++;
	nextchar();
	if (PL_regflags & PMf_MULTILINE)
	    ret = reg_node(MBOL);
	else if (PL_regflags & PMf_SINGLELINE)
	    ret = reg_node(SBOL);
d2791 2
a2792 1
	    ret = reg_node(BOL);
d2795 7
a2801 7
	nextchar();
	if (*PL_regcomp_parse) 
	    PL_seen_zerolen++;
	if (PL_regflags & PMf_MULTILINE)
	    ret = reg_node(MEOL);
	else if (PL_regflags & PMf_SINGLELINE)
	    ret = reg_node(SEOL);
d2803 2
a2804 1
	    ret = reg_node(EOL);
d2807 8
a2814 16
	nextchar();
	if (UTF) {
	    if (PL_regflags & PMf_SINGLELINE)
		ret = reg_node(SANYUTF8);
	    else
		ret = reg_node(ANYUTF8);
	    *flagp |= HASWIDTH;
	}
	else {
	    if (PL_regflags & PMf_SINGLELINE)
		ret = reg_node(SANY);
	    else
		ret = reg_node(REG_ANY);
	    *flagp |= HASWIDTH|SIMPLE;
	}
	PL_regnaughty++;
d2818 4
a2821 4
	char *oregcomp_parse = ++PL_regcomp_parse;
	ret = (UTF ? regclassutf8() : regclass());
	if (*PL_regcomp_parse != ']') {
	    PL_regcomp_parse = oregcomp_parse;
d2824 1
a2824 1
	nextchar();
d2826 1
d2830 2
a2831 2
	nextchar();
	ret = reg(1, &flags);
d2834 1
a2834 1
		    if (PL_regcomp_parse == PL_regxend) {
d2855 2
a2856 2
	if (!regcurly(PL_regcomp_parse)) {
	    PL_regcomp_parse++;
d2863 1
a2863 1
	PL_regcomp_parse++;
d2867 1
a2867 1
	switch (*++PL_regcomp_parse) {
d2869 2
a2870 2
	    PL_seen_zerolen++;
	    ret = reg_node(SBOL);
d2872 2
a2873 1
	    nextchar();
d2876 2
a2877 2
	    ret = reg_node(GPOS);
	    PL_regseen |= REG_SEEN_GPOS;
d2879 2
a2880 1
	    nextchar();
d2883 1
a2883 1
	    ret = reg_node(SEOL);
d2885 2
a2886 1
	    nextchar();
d2889 1
a2889 1
	    ret = reg_node(EOS);
d2891 3
a2893 2
	    PL_seen_zerolen++;		/* Do not optimize RE away */
	    nextchar();
d2896 2
a2897 1
	    ret = reg_node(SANY);
d2899 2
a2900 1
	    nextchar();
d2903 1
a2903 1
	    ret = reg_node(CLUMP);
d2905 2
a2906 3
	    nextchar();
	    if (UTF && !PL_utf8_mark)
		is_utf8_mark((U8*)"~");		/* preload table */
d2909 1
a2909 4
	    ret = reg_node(
		UTF
		    ? (LOC ? ALNUMLUTF8 : ALNUMUTF8)
		    : (LOC ? ALNUML     : ALNUM));
d2911 2
a2912 3
	    nextchar();
	    if (UTF && !PL_utf8_alnum)
		is_utf8_alnum((U8*)"a");	/* preload table */
d2915 1
a2915 4
	    ret = reg_node(
		UTF
		    ? (LOC ? NALNUMLUTF8 : NALNUMUTF8)
		    : (LOC ? NALNUML     : NALNUM));
d2917 2
a2918 3
	    nextchar();
	    if (UTF && !PL_utf8_alnum)
		is_utf8_alnum((U8*)"a");	/* preload table */
d2921 3
a2923 6
	    PL_seen_zerolen++;
	    PL_regseen |= REG_SEEN_LOOKBEHIND;
	    ret = reg_node(
		UTF
		    ? (LOC ? BOUNDLUTF8 : BOUNDUTF8)
		    : (LOC ? BOUNDL     : BOUND));
d2925 2
a2926 3
	    nextchar();
	    if (UTF && !PL_utf8_alnum)
		is_utf8_alnum((U8*)"a");	/* preload table */
d2929 3
a2931 6
	    PL_seen_zerolen++;
	    PL_regseen |= REG_SEEN_LOOKBEHIND;
	    ret = reg_node(
		UTF
		    ? (LOC ? NBOUNDLUTF8 : NBOUNDUTF8)
		    : (LOC ? NBOUNDL     : NBOUND));
d2933 2
a2934 3
	    nextchar();
	    if (UTF && !PL_utf8_alnum)
		is_utf8_alnum((U8*)"a");	/* preload table */
d2937 1
a2937 4
	    ret = reg_node(
		UTF
		    ? (LOC ? SPACELUTF8 : SPACEUTF8)
		    : (LOC ? SPACEL     : SPACE));
d2939 2
a2940 3
	    nextchar();
	    if (UTF && !PL_utf8_space)
		is_utf8_space((U8*)" ");	/* preload table */
d2943 1
a2943 4
	    ret = reg_node(
		UTF
		    ? (LOC ? NSPACELUTF8 : NSPACEUTF8)
		    : (LOC ? NSPACEL     : NSPACE));
d2945 2
a2946 3
	    nextchar();
	    if (UTF && !PL_utf8_space)
		is_utf8_space((U8*)" ");	/* preload table */
d2949 1
a2949 1
	    ret = reg_node(UTF ? DIGITUTF8 : DIGIT);
d2951 2
a2952 3
	    nextchar();
	    if (UTF && !PL_utf8_digit)
		is_utf8_digit((U8*)"1");	/* preload table */
d2955 1
a2955 1
	    ret = reg_node(UTF ? NDIGITUTF8 : NDIGIT);
d2957 2
a2958 3
	    nextchar();
	    if (UTF && !PL_utf8_digit)
		is_utf8_digit((U8*)"1");	/* preload table */
d2962 12
a2973 9
	    {	/* a lovely hack--pretend we saw [\pX] instead */
		char* oldregxend = PL_regxend;

		if (PL_regcomp_parse[1] == '{') {
		    PL_regxend = strchr(PL_regcomp_parse, '}');
		    if (!PL_regxend) {
			PL_regcomp_parse += 2;
			PL_regxend = oldregxend;
			vFAIL("Missing right brace on \\p{}");
d2975 1
a2975 1
		    PL_regxend++;
d2977 13
a2989 9
		else
		    PL_regxend = PL_regcomp_parse + 2;
		PL_regcomp_parse--;

		ret = regclassutf8();

		PL_regxend = oldregxend;
		PL_regcomp_parse--;
		nextchar();
d3006 1
a3006 1
		I32 num = atoi(PL_regcomp_parse);
d3008 1
a3008 1
		if (num > 9 && num >= PL_regnpar)
d3011 3
a3013 2
		    while (isDIGIT(*PL_regcomp_parse))
			PL_regcomp_parse++;
d3015 1
a3015 1
		    if (!SIZE_ONLY && num > PL_regcomp_rx->nparens)
d3017 4
a3020 4
		    PL_regsawback = 1;
		    ret = reganode(FOLD
				   ? (LOC ? REFFL : REFF)
				   : REF, num);
d3022 6
a3027 2
		    PL_regcomp_parse--;
		    nextchar();
d3032 1
a3032 1
	    if (PL_regcomp_parse >= PL_regxend)
d3043 3
a3045 3
	if (PL_regflags & PMf_EXTENDED) {
	    while (PL_regcomp_parse < PL_regxend && *PL_regcomp_parse != '\n') PL_regcomp_parse++;
	    if (PL_regcomp_parse < PL_regxend)
d3056 2
d3059 3
a3061 1
	    PL_regcomp_parse++;
d3064 3
a3066 3
	    ret = reg_node(FOLD
			  ? (LOC ? EXACTFL : EXACTF)
			  : EXACT);
d3068 2
a3069 2
	    for (len = 0, p = PL_regcomp_parse - 1;
	      len < 127 && p < PL_regxend;
d3074 2
a3075 2
		if (PL_regflags & PMf_EXTENDED)
		    p = regwhite(p, PL_regxend);
d3088 2
d3122 1
a3122 5
#ifdef ASCIIish
			  ender = '\033';
#else
			  ender = '\047';
#endif
d3126 1
a3126 5
#ifdef ASCIIish
			  ender = '\007';
#else
			  ender = '\057';
#endif
d3132 1
a3132 1
	 
d3134 1
a3134 1
				PL_regcomp_parse = p + 1;
d3138 6
a3143 2
				numlen = 1;	/* allow underscores */
				ender = (UV)scan_hex(p + 1, e - p - 1, &numlen);
d3153 3
a3155 2
			    numlen = 0;		/* disallow underscores */
			    ender = (UV)scan_hex(p, 2, &numlen);
d3167 4
a3170 3
			  (isDIGIT(p[1]) && atoi(p) >= PL_regnpar) ) {
			    numlen = 0;		/* disallow underscores */
			    ender = (UV)scan_oct(p, 3, &numlen);
d3179 1
a3179 1
			if (p >= PL_regxend)
d3184 1
a3184 1
			    vWARN2(p +1, "Unrecognized escape \\%c passed through", *p);
d3191 2
a3192 2
			ender = utf8_to_uv((U8*)p, PL_regxend - p,
					   &numlen, 0);
d3199 2
a3200 2
		if (PL_regflags & PMf_EXTENDED)
		    p = regwhite(p, PL_regxend);
d3202 2
a3203 4
		    if (LOC)
			ender = toLOWER_LC_uni(ender);
		    else
			ender = toLOWER_uni(ender);
d3208 30
a3237 6
		    /* ender is a Unicode value so it can be > 0xff --
		     * in other words, do not use UTF8_IS_CONTINUED(). */
		    else if (ender >= 0x80 && UTF) {
			reguni(ender, s, &numlen);
			s += numlen;
			len += numlen;
d3241 1
a3241 1
			REGC(ender, s++);
d3245 31
a3275 6
		/* ender is a Unicode value so it can be > 0xff --
		 * in other words, do not use UTF8_IS_CONTINUED(). */
		if (ender >= 0x80 && UTF) {
		    reguni(ender, s, &numlen);
		    s += numlen;
		    len += numlen - 1;
d3278 1
a3278 1
		    REGC(ender, s++);
d3281 3
a3283 2
	    PL_regcomp_parse = p - 1;
	    nextchar();
d3297 1
a3297 1
		PL_regsize += STR_SZ(len);
d3299 1
a3299 1
		PL_regcode += STR_SZ(len);
d3304 24
d3352 6
a3357 1
   but trigger warnings because they are currently unimplemented. */
d3359 1
a3359 1
S_regpposixcc(pTHX_ I32 value)
d3364 1
a3364 1
    if (value == '[' && PL_regcomp_parse + 1 < PL_regxend &&
d3366 7
a3372 9
	(*PL_regcomp_parse == ':' ||
	 *PL_regcomp_parse == '=' ||
	 *PL_regcomp_parse == '.')) {
	char  c = *PL_regcomp_parse;
	char* s = PL_regcomp_parse++;
	    
	while (PL_regcomp_parse < PL_regxend && *PL_regcomp_parse != c)
	    PL_regcomp_parse++;
	if (PL_regcomp_parse == PL_regxend)
d3374 1
a3374 1
	    PL_regcomp_parse = s;
d3376 1
a3376 1
	    char* t = PL_regcomp_parse++; /* skip over the c */
d3378 2
a3379 2
  	    if (*PL_regcomp_parse == ']') {
  		PL_regcomp_parse++; /* skip over the ending ] */
d3465 1
a3465 1
		    /* adjust PL_regcomp_parse so the warning shows after
d3467 2
a3468 2
		    while (*PL_regcomp_parse && *PL_regcomp_parse != ']')
			PL_regcomp_parse++;
d3474 1
a3474 1
		PL_regcomp_parse = s;
d3483 1
a3483 1
S_checkposixcc(pTHX)
d3485 2
a3486 5
    if (!SIZE_ONLY && ckWARN(WARN_REGEXP) &&
	(*PL_regcomp_parse == ':' ||
	 *PL_regcomp_parse == '=' ||
	 *PL_regcomp_parse == '.')) {
	char *s = PL_regcomp_parse;
d3492 4
a3495 1
	    vWARN3(s+2, "POSIX syntax [%c %c] belongs inside character classes", c, c);
d3498 2
a3499 3
	    if (c == '=' || c == '.')
	    {
		/* adjust PL_regcomp_parse so the error shows after
d3501 1
a3501 1
		while (*PL_regcomp_parse && *PL_regcomp_parse++ != ']')
d3510 1
a3510 1
S_regclass(pTHX)
d3512 4
a3515 3
    register U32 value;
    register I32 lastvalue = OOB_CHAR8;
    register I32 range = 0;
d3518 2
a3519 2
    I32 namedclass;
    char *rangebegin;
d3521 20
a3541 1
    ret = reg_node(ANYOF);
d3543 1
a3543 1
	PL_regsize += ANYOF_SKIP;
d3545 1
a3545 3
	ret->flags = 0;
	ANYOF_BITMAP_ZERO(ret);
 	PL_regcode += ANYOF_SKIP;
d3550 2
a3551 6
    }
    if (*PL_regcomp_parse == '^') {	/* Complement of range. */
	PL_regnaughty++;
	PL_regcomp_parse++;
	if (!SIZE_ONLY)
	    ANYOF_FLAGS(ret) |= ANYOF_INVERT;
d3554 14
a3567 2
    if (!SIZE_ONLY && ckWARN(WARN_REGEXP))
	checkposixcc();
a3568 5
    if (*PL_regcomp_parse == ']' || *PL_regcomp_parse == '-')
	goto skipcond;		/* allow 1st char to be ] or - */
    while (PL_regcomp_parse < PL_regxend && *PL_regcomp_parse != ']') {
       skipcond:
	namedclass = OOB_NAMEDCLASS;
d3570 12
a3581 4
	    rangebegin = PL_regcomp_parse;
	value = UCHARAT(PL_regcomp_parse++);
	if (value == '[')
	    namedclass = regpposixcc(value);
d3583 8
a3590 1
	    value = UCHARAT(PL_regcomp_parse++);
d3592 5
a3596 2
	     * values, therefore the 'value' cannot be an UV. --jhi */
	    switch (value) {
d3603 41
d3649 2
a3650 7
#ifdef ASCIIish
	    case 'e':	value = '\033';			break;
	    case 'a':	value = '\007';			break;
#else
	    case 'e':	value = '\047';			break;
	    case 'a':	value = '\057';			break;
#endif
d3652 17
a3668 3
		numlen = 0;		/* disallow underscores */
		value = (UV)scan_hex(PL_regcomp_parse, 2, &numlen);
		PL_regcomp_parse += numlen;
d3671 1
a3671 1
		value = UCHARAT(PL_regcomp_parse++);
d3676 5
a3680 3
		numlen = 0;		/* disallow underscores */
		value = (UV)scan_oct(--PL_regcomp_parse, 3, &numlen);
		PL_regcomp_parse += numlen;
d3682 1
d3685 3
a3687 2

		    vWARN2(PL_regcomp_parse, "Unrecognized escape \\%c in character class passed through", (int)value);
d3690 9
a3698 3
	}
	if (namedclass > OOB_NAMEDCLASS) {
	    if (!need_class && !SIZE_ONLY)
d3700 1
d3702 3
a3704 1
	    if (range) { /* a-\d, a-[:digit:] */
d3707 1
a3707 1
			vWARN4(PL_regcomp_parse,
d3709 2
a3710 2
			       PL_regcomp_parse - rangebegin,
			       PL_regcomp_parse - rangebegin,
d3712 9
a3720 2
		    ANYOF_BITMAP_SET(ret, lastvalue);
		    ANYOF_BITMAP_SET(ret, '-');
d3722 2
a3723 1
		range = 0; /* this is not a true range */
d3725 1
d3727 7
a3733 1
		switch (namedclass) {
d3742 1
d3752 1
d3754 1
a3754 1
		case ANYOF_SPACE:
d3756 1
a3756 1
			ANYOF_CLASS_SET(ret, ANYOF_SPACE);
d3759 1
a3759 1
			    if (isSPACE(value))
d3762 1
a3762 27
		    break;
		case ANYOF_NSPACE:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_NSPACE);
		    else {
			for (value = 0; value < 256; value++)
			    if (!isSPACE(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    break;
		case ANYOF_DIGIT:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_DIGIT);
		    else {
			for (value = '0'; value <= '9'; value++)
			    ANYOF_BITMAP_SET(ret, value);
		    }
		    break;
		case ANYOF_NDIGIT:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_NDIGIT);
		    else {
			for (value = 0; value < '0'; value++)
			    ANYOF_BITMAP_SET(ret, value);
			for (value = '9' + 1; value < 256; value++)
			    ANYOF_BITMAP_SET(ret, value);
		    }
d3772 1
a3772 9
		    break;
		case ANYOF_ALNUMC:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_ALNUMC);
		    else {
			for (value = 0; value < 256; value++)
			    if (isALNUMC(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
d3782 1
d3792 1
d3798 1
a3798 1
#ifdef ASCIIish
d3802 1
a3802 1
			for (value = 0; value < 256; value++)
d3804 2
a3805 1
				ANYOF_BITMAP_SET(ret, value);
d3808 1
d3814 1
a3814 1
#ifdef ASCIIish
d3818 1
a3818 1
			for (value = 0; value < 256; value++)
d3820 2
a3821 1
				ANYOF_BITMAP_SET(ret, value);
d3824 1
d3834 1
d3844 1
d3854 1
a3854 1
		    lastvalue = OOB_CHAR8;
d3864 23
d3896 1
d3906 1
d3916 1
d3926 1
d3936 1
d3946 1
d3956 1
d3966 1
d3976 1
d3986 21
d4016 1
d4026 1
d4036 1
d4046 1
d4056 2
a4057 1
	}
d4059 1
a4059 1
	    if (lastvalue > value) /* b-a */ {
d4061 2
a4062 2
			      PL_regcomp_parse - rangebegin,
			      PL_regcomp_parse - rangebegin,
d4064 1
a4065 1
	    range = 0;
d4068 7
a4074 5
	    lastvalue = value;
	    if (*PL_regcomp_parse == '-' && PL_regcomp_parse+1 < PL_regxend &&
		PL_regcomp_parse[1] != ']') {
		PL_regcomp_parse++;
		if (namedclass > OOB_NAMEDCLASS) { /* \w-, [:word:]- */
d4076 1
a4076 1
			vWARN4(PL_regcomp_parse,
d4078 2
a4079 2
			       PL_regcomp_parse - rangebegin,
			       PL_regcomp_parse - rangebegin,
d4084 2
a4085 2
		    range = 1;
		continue;	/* do it next time */
d4088 1
d4091 88
a4178 13
#ifndef ASCIIish /* EBCDIC, for example. */
	    if ((isLOWER(lastvalue) && isLOWER(value)) ||
		(isUPPER(lastvalue) && isUPPER(value)))
	    {
		I32 i;
 		if (isLOWER(lastvalue)) {
 		    for (i = lastvalue; i <= value; i++)
			if (isLOWER(i))
			    ANYOF_BITMAP_SET(ret, i);
 		} else {
 		    for (i = lastvalue; i <= value; i++)
			if (isUPPER(i))
			    ANYOF_BITMAP_SET(ret, i);
d4181 2
a4182 1
	    else
a4183 2
		for ( ; lastvalue <= value; lastvalue++)
		    ANYOF_BITMAP_SET(ret, lastvalue);
d4185 2
a4186 1
	range = 0;
d4188 1
d4190 1
d4192 1
a4192 1
	    PL_regsize += ANYOF_CLASS_ADD_SKIP;
d4194 1
a4194 1
	    PL_regcode += ANYOF_CLASS_ADD_SKIP;
d4196 1
d4199 3
a4201 1
	(ANYOF_FLAGS(ret) & (ANYOF_FLAGS_ALL ^ ANYOF_INVERT)) == ANYOF_FOLD) {
d4204 4
a4207 2
		I32 cf = PL_fold[value];
		ANYOF_BITMAP_SET(ret, cf);
d4212 1
d4214 3
a4216 1
    if (!SIZE_ONLY && (ANYOF_FLAGS(ret) & ANYOF_FLAGS_ALL) == ANYOF_INVERT) {
d4219 1
a4219 1
	ANYOF_FLAGS(ret) = 0;
a4220 2
    return ret;
}
a4221 21
STATIC regnode *
S_regclassutf8(pTHX)
{
    register char *e;
    register U32 value;
    register U32 lastvalue = OOB_UTF8;
    register I32 range = 0;
    register regnode *ret;
    STRLEN numlen;
    I32 n;
    SV *listsv;
    U8 flags = 0;
    I32 namedclass;
    char *rangebegin;

    if (*PL_regcomp_parse == '^') {	/* Complement of range. */
	PL_regnaughty++;
	PL_regcomp_parse++;
	if (!SIZE_ONLY)
	    flags |= ANYOF_INVERT;
    }
d4223 2
a4224 226
	if (FOLD)
	    flags |= ANYOF_FOLD;
	if (LOC)
	    flags |= ANYOF_LOCALE;
	listsv = newSVpvn("# comment\n", 10);
    }

    if (!SIZE_ONLY && ckWARN(WARN_REGEXP))
	checkposixcc();

    if (*PL_regcomp_parse == ']' || *PL_regcomp_parse == '-')
	goto skipcond;		/* allow 1st char to be ] or - */

    while (PL_regcomp_parse < PL_regxend && *PL_regcomp_parse != ']') {
       skipcond:
	namedclass = OOB_NAMEDCLASS;
	if (!range)
	    rangebegin = PL_regcomp_parse;
	value = utf8_to_uv((U8*)PL_regcomp_parse,
			       PL_regxend - PL_regcomp_parse,
			       &numlen, 0);
	PL_regcomp_parse += numlen;
	if (value == '[')
	    namedclass = regpposixcc(value);
	else if (value == '\\') {
	    value = (U32)utf8_to_uv((U8*)PL_regcomp_parse,
					PL_regxend - PL_regcomp_parse,
					&numlen, 0);
	    PL_regcomp_parse += numlen;
	    /* Some compilers cannot handle switching on 64-bit integer
	     * values, therefore value cannot be an UV.  Yes, this will
	     * be a problem later if we want switch on Unicode.  --jhi */
	    switch (value) {
	    case 'w':		namedclass = ANYOF_ALNUM;		break;
	    case 'W':		namedclass = ANYOF_NALNUM;		break;
	    case 's':		namedclass = ANYOF_SPACE;		break;
	    case 'S':		namedclass = ANYOF_NSPACE;		break;
	    case 'd':		namedclass = ANYOF_DIGIT;		break;
	    case 'D':		namedclass = ANYOF_NDIGIT;		break;
	    case 'p':
	    case 'P':
		if (*PL_regcomp_parse == '{') {
		    e = strchr(PL_regcomp_parse++, '}');
                    if (!e)
                        vFAIL("Missing right brace on \\p{}");
		    n = e - PL_regcomp_parse;
		}
		else {
		    e = PL_regcomp_parse;
		    n = 1;
		}
		if (!SIZE_ONLY) {
		    if (value == 'p')
			Perl_sv_catpvf(aTHX_ listsv,
				       "+utf8::%.*s\n", (int)n, PL_regcomp_parse);
		    else
			Perl_sv_catpvf(aTHX_ listsv,
				       "!utf8::%.*s\n", (int)n, PL_regcomp_parse);
		}
		PL_regcomp_parse = e + 1;
		lastvalue = OOB_UTF8;
		continue;
	    case 'n':		value = '\n';		break;
	    case 'r':		value = '\r';		break;
	    case 't':		value = '\t';		break;
	    case 'f':		value = '\f';		break;
	    case 'b':		value = '\b';		break;
#ifdef ASCIIish
	    case 'e':		value = '\033';		break;
	    case 'a':		value = '\007';		break;
#else
	    case 'e':		value = '\047';		break;
	    case 'a':		value = '\057';		break;
#endif
	    case 'x':
		if (*PL_regcomp_parse == '{') {
		    e = strchr(PL_regcomp_parse++, '}');
                    if (!e) 
                        vFAIL("Missing right brace on \\x{}");
		    numlen = 1;		/* allow underscores */
		    value = (UV)scan_hex(PL_regcomp_parse,
				     e - PL_regcomp_parse,
				     &numlen);
		    PL_regcomp_parse = e + 1;
		}
		else {
		    numlen = 0;		/* disallow underscores */
		    value = (UV)scan_hex(PL_regcomp_parse, 2, &numlen);
		    PL_regcomp_parse += numlen;
		}
		break;
	    case 'c':
		value = UCHARAT(PL_regcomp_parse++);
		value = toCTRL(value);
		break;
	    case '0': case '1': case '2': case '3': case '4':
	    case '5': case '6': case '7': case '8': case '9':
		numlen = 0;		/* disallow underscores */
		value = (UV)scan_oct(--PL_regcomp_parse, 3, &numlen);
		PL_regcomp_parse += numlen;
		break;
	    default:
		if (!SIZE_ONLY && ckWARN(WARN_REGEXP) && isALPHA(value))
		    vWARN2(PL_regcomp_parse,
			   "Unrecognized escape \\%c in character class passed through",
			   (int)value);
		break;
	    }
	}
	if (namedclass > OOB_NAMEDCLASS) {
	    if (range) { /* a-\d, a-[:digit:] */
		if (!SIZE_ONLY) {
		    if (ckWARN(WARN_REGEXP))
			vWARN4(PL_regcomp_parse,
			       "False [] range \"%*.*s\"",
			       PL_regcomp_parse - rangebegin,
			       PL_regcomp_parse - rangebegin,
			       rangebegin);
		    Perl_sv_catpvf(aTHX_ listsv,
				   /* 0x002D is Unicode for '-' */
				   "%04"UVxf"\n002D\n", (UV)lastvalue);
		}
		range = 0;
	    }
	    if (!SIZE_ONLY) {
		switch (namedclass) {
		case ANYOF_ALNUM:
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsWord\n");	break;
		case ANYOF_NALNUM:
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsWord\n");	break;
		case ANYOF_ALNUMC:
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsAlnum\n");	break;
		case ANYOF_NALNUMC:
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsAlnum\n");	break;
		case ANYOF_ALPHA:
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsAlpha\n");	break;
		case ANYOF_NALPHA:
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsAlpha\n");	break;
		case ANYOF_ASCII:
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsASCII\n");	break;
		case ANYOF_NASCII:
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsASCII\n");	break;
		case ANYOF_CNTRL:
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsCntrl\n");	break;
		case ANYOF_NCNTRL:
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsCntrl\n");	break;
		case ANYOF_GRAPH:
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsGraph\n");	break;
		case ANYOF_NGRAPH:
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsGraph\n");	break;
		case ANYOF_DIGIT:
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsDigit\n");	break;
		case ANYOF_NDIGIT:
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsDigit\n");	break;
		case ANYOF_LOWER:
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsLower\n");	break;
		case ANYOF_NLOWER:
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsLower\n");	break;
		case ANYOF_PRINT:
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsPrint\n");	break;
		case ANYOF_NPRINT:
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsPrint\n");	break;
		case ANYOF_PUNCT:
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsPunct\n");	break;
		case ANYOF_NPUNCT:
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsPunct\n");	break;
		case ANYOF_SPACE:
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsSpacePerl\n");break;
		case ANYOF_NSPACE:
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsSpacePerl\n");break;
		case ANYOF_BLANK:
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsBlank\n");	break;
		case ANYOF_NBLANK:
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsBlank\n");	break;
		case ANYOF_PSXSPC:
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsSpace\n");	break;
		case ANYOF_NPSXSPC:
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsSpace\n");	break;
		case ANYOF_UPPER:
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsUpper\n");	break;
		case ANYOF_NUPPER:
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsUpper\n");	break;
		case ANYOF_XDIGIT:
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsXDigit\n");	break;
		case ANYOF_NXDIGIT:
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsXDigit\n");	break;
		}
		continue;
	    }
	}
        if (range) {
	    if (lastvalue > value) { /* b-a */
		Simple_vFAIL4("Invalid [] range \"%*.*s\"",
			      PL_regcomp_parse - rangebegin,
			      PL_regcomp_parse - rangebegin,
			      rangebegin);
	    }
	    range = 0;
	}
	else {
	    lastvalue = value;
	    if (*PL_regcomp_parse == '-' && PL_regcomp_parse+1 < PL_regxend &&
		PL_regcomp_parse[1] != ']') {
		PL_regcomp_parse++;
		if (namedclass > OOB_NAMEDCLASS) { /* \w-, [:word:]- */
		    if (ckWARN(WARN_REGEXP))
			vWARN4(PL_regcomp_parse,
			       "False [] range \"%*.*s\"",
			       PL_regcomp_parse - rangebegin,
			       PL_regcomp_parse - rangebegin,
			       rangebegin);
		    if (!SIZE_ONLY)
			Perl_sv_catpvf(aTHX_ listsv,
				       /* 0x002D is Unicode for '-' */
				       "002D\n");
		} else
		    range = 1;
		continue;	/* do it next time */
	    }
	}
	/* now is the next time */
	if (!SIZE_ONLY)
	    Perl_sv_catpvf(aTHX_ listsv, "%04"UVxf"\t%04"UVxf"\n",
			   (UV)lastvalue, (UV)value);
	range = 0;
    }
d4226 9
a4234 8
    ret = reganode(ANYOFUTF8, 0);

    if (!SIZE_ONLY) {
	SV *rv = swash_init("utf8", "", listsv, 1, 0);
#ifdef DEBUGGING
	AV *av = newAV();
	av_push(av, rv);
	av_push(av, listsv);
d4236 3
a4238 7
#else
	SvREFCNT_dec(listsv);
#endif
	n = add_data(1,"s");
	PL_regcomp_rx->data->data[n] = (void*)rv;
	ARG1_SET(ret, flags);
	ARG2_SET(ret, n);
d4245 1
a4245 1
S_nextchar(pTHX)
d4247 1
a4247 1
    char* retval = PL_regcomp_parse++;
d4250 5
a4254 5
	if (*PL_regcomp_parse == '(' && PL_regcomp_parse[1] == '?' &&
		PL_regcomp_parse[2] == '#') {
	    while (*PL_regcomp_parse && *PL_regcomp_parse != ')')
		PL_regcomp_parse++;
	    PL_regcomp_parse++;
d4257 3
a4259 3
	if (PL_regflags & PMf_EXTENDED) {
	    if (isSPACE(*PL_regcomp_parse)) {
		PL_regcomp_parse++;
d4262 4
a4265 4
	    else if (*PL_regcomp_parse == '#') {
		while (*PL_regcomp_parse && *PL_regcomp_parse != '\n')
		    PL_regcomp_parse++;
		PL_regcomp_parse++;
d4277 1
a4277 1
S_reg_node(pTHX_ U8 op)
d4282 1
a4282 1
    ret = PL_regcode;
d4284 2
a4285 2
	SIZE_ALIGN(PL_regsize);
	PL_regsize += 1;
d4292 13
a4304 1
    PL_regcode = ptr;
d4313 1
a4313 1
S_reganode(pTHX_ U8 op, U32 arg)
d4318 1
a4318 1
    ret = PL_regcode;
d4320 2
a4321 2
	SIZE_ALIGN(PL_regsize);
	PL_regsize += 2;
d4328 12
a4339 1
    PL_regcode = ptr;
d4348 1
a4348 1
S_reguni(pTHX_ UV uv, char* s, STRLEN* lenp)
d4350 1
a4350 1
    *lenp = SIZE_ONLY ? UNISKIP(uv) : (uv_to_utf8((U8*)s, uv) - (U8*)s);
d4359 1
a4359 1
S_reginsert(pTHX_ U8 op, regnode *opnd)
d4365 1
a4365 1
    
d4369 1
a4369 1
	PL_regsize += NODE_STEP_REGNODE + offset;
d4373 4
a4376 4
    src = PL_regcode;
    PL_regcode += NODE_STEP_REGNODE + offset;
    dst = PL_regcode;
    while (src > opnd)
d4378 13
d4393 10
d4412 1
a4412 1
S_regtail(pTHX_ regnode *p, regnode *val)
d4441 1
a4441 1
S_regoptail(pTHX_ regnode *p, regnode *val)
d4447 1
a4447 1
	regtail(NEXTOPER(p), val);
d4450 1
a4450 1
	regtail(NEXTOPER(NEXTOPER(p)), val);
d4478 2
a4482 1
#ifdef DEBUGGING
d4502 1
a4502 1
	else 
d4507 2
a4508 2
	    register regnode *nnode = (OP(next) == LONGJMP 
				       ? regnext(next) 
d4529 3
a4532 1
	    node += ANYOF_SKIP;
a4547 1
#endif	/* DEBUGGING */
d4551 2
d4567 1
a4567 1
		      "anchored `%s%.*s%s'%s at %"IVdf" ", 
d4570 1
a4570 1
		      SvPVX(r->anchored_substr), 
d4574 9
d4585 1
a4585 1
		      "floating `%s%.*s%s'%s at %"IVdf"..%"UVuf" ", 
d4587 1
a4587 1
		      (int)(SvCUR(r->float_substr) - (SvTAIL(r->float_substr)!=0)), 
d4592 13
a4604 3
    if (r->check_substr)
	PerlIO_printf(Perl_debug_log, 
		      r->check_substr == r->float_substr 
d4610 1
a4610 1
    if (r->check_substr)
d4639 10
d4652 2
d4657 1
a4657 1
    if (isCNTRL(c) || c == 127 || c == 255)
d4665 2
d4678 3
a4680 1
	FAIL("Corrupted regexp opcode");
d4685 18
a4702 3
    if (k == EXACT)
	Perl_sv_catpvf(aTHX_ sv, " <%s%.*s%s>", PL_colors[0],
		       STR_LEN(o), STRING(o), PL_colors[1]);
d4716 1
a4716 2
	bool anyofutf8 = OP(o) == ANYOFUTF8;
	U8 flags = anyofutf8 ? ARG1(o) : o->flags;
d4758 7
a4764 10
	if (OP(o) == ANYOF) {
	    for (i = 0; i <= 256; i++) {
		if (i < 256 && ANYOF_BITMAP_TEST(o,i)) {
		    if (rangestart == -1)
			rangestart = i;
		} else if (rangestart != -1) {
		    if (i <= rangestart + 3)
			for (; rangestart < i; rangestart++)
			    put_byte(sv, rangestart);
		    else {
d4766 4
a4769 4
			sv_catpv(sv, "-");
			put_byte(sv, i - 1);
		    }
		    rangestart = -1;
d4771 1
a4772 4
	    if (o->flags & ANYOF_CLASS)
		for (i = 0; i < sizeof(anyofs)/sizeof(char*); i++)
		    if (ANYOF_CLASS_TEST(o,i))
			sv_catpv(sv, anyofs[i]);
d4774 42
a4815 19
	else {
	    SV *rv = (SV*)PL_regdata->data[ARG2(o)];
	    AV *av = (AV*)SvRV((SV*)rv);
	    SV *sw = *av_fetch(av, 0, FALSE);
	    SV *lv = *av_fetch(av, 1, FALSE);
	    UV i;
	    U8 s[UTF8_MAXLEN+1];
	    for (i = 0; i <= 256; i++) { /* just the first 256 */
		U8 *e = uv_to_utf8(s, i);
		if (i < 256 && swash_fetch(sw, s)) {
		    if (rangestart == -1)
			rangestart = i;
		} else if (rangestart != -1) {
		    U8 *p;

		    if (i <= rangestart + 3)
			for (; rangestart < i; rangestart++) {
			    for(e = uv_to_utf8(s, rangestart), p = s; p < e; p++)
				put_byte(sv, *p);
d4817 2
a4818 8
		    else {
			for (e = uv_to_utf8(s, rangestart), p = s; p < e; p++)
			    put_byte(sv, *p);
			sv_catpv(sv, "-");
			for (e = uv_to_utf8(s, i - 1), p = s; p < e; p++)
			    put_byte(sv, *p);
		    }
		    rangestart = -1;
a4819 4
	    }
	    sv_catpv(sv, "...");
	    {
		char *s = savepv(SvPVX(lv));
d4821 18
a4838 8
		while(*s && *s != '\n') s++;
		if (*s == '\n') {
		    char *t = ++s;

		    while (*s) {
			if (*s == '\n')
			    *s = ' ';
			s++;
d4840 2
a4841 4
		    if (s[-1] == ' ')
			s[-1] = 0;

		    sv_catpv(sv, t);
d4845 1
d4858 2
a4859 1
	    char *s = SvPV(prog->check_substr,n_a);
d4863 4
a4866 2
		      "%sUsing REx substr:%s `%s%.60s%s%s'\n",
		      PL_colors[4],PL_colors[5],PL_colors[0],
d4872 1
a4872 1
    return prog->check_substr;
d4878 3
a4880 1
    DEBUG_r(if (!PL_colorset) reginitcolors());
d4884 17
a4900 6
    DEBUG_r(PerlIO_printf(Perl_debug_log,
		      "%sFreeing REx:%s `%s%.60s%s%s'\n",
		      PL_colors[4],PL_colors[5],PL_colors[0],
		      r->precomp,
		      PL_colors[1],
		      (strlen(r->precomp) > 60 ? "..." : "")));
d4904 2
d4911 2
d4915 2
d4926 1
d4949 5
a4953 1
		op_free((OP_4tree*)r->data->data[n]);
d4960 1
a4960 1
		break;
d4962 1
a4962 1
		FAIL2("panic: regfree data code '%c'", r->data->what[n]);
d5032 16
a5047 1
{                   
a5048 4
    SAVEPPTR(PL_regprecomp);		/* uncompiled string. */
    SAVEI32(PL_regnpar);		/* () count. */
    SAVEI32(PL_regsize);		/* Code size. */
    SAVEI16(PL_regflags);		/* are we folding, multilining? */
d5056 1
a5056 2
    SAVEI8(PL_regprev);			/* char before regbol, \n if none */
    SAVEGENERICPV(PL_reg_start_tmp);	/* from regexec.c */
a5060 1
    SAVEI32(PL_reg_flags);		/* from regexec.c */
a5066 7
    SAVEVPTR(PL_regcomp_rx);		/* from regcomp.c */
    SAVEI32(PL_regseen);		/* from regcomp.c */
    SAVEI32(PL_regsawback);		/* Did we see \1, ...? */
    SAVEI32(PL_regnaughty);		/* How bad is this pattern? */
    SAVEVPTR(PL_regcode);		/* Code-emit pointer; &regdummy = don't */
    SAVEPPTR(PL_regxend);		/* End of input for compile */
    SAVEPPTR(PL_regcomp_parse);		/* Input-scan pointer. */
d5071 1
d5077 1
d5079 1
a5079 1
    SAVEPPTR(PL_reg_starttry);		/* from regexec.c */    
a5082 6
#ifdef PERL_OBJECT
#include "XSUB.h"
#undef this
#define this pPerl
#endif

d5084 1
a5084 1
clear_re(pTHXo_ void *r)
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d72 1
a72 1
 ****    Copyright (c) 1991-2000, Larry Wall
a116 5
#ifdef atarist
#define	PERL_META	"^$.[()|?+*\\"
#else
#define	META	"^$.[()|?+*\\"
#endif
d149 1
d158 1
a158 1
				      0, 0, 0, 0, 0 };
d187 1
d201 179
a391 1
    dTHR;
d442 1
a442 1
    for (value = 0; value < ANYOF_MAX; value += 2)
a555 1
    dTHR;
d594 1
a594 1
		else {
d597 1
a597 1
		    
d604 1
a604 2
		    Move(STRING(n), STRING(scan) + oldl,
			 STR_LEN(n), char);
d606 1
a606 2
		    if (stringok)
			stop = next - 1;
d661 1
a661 1
		    I32 deltanext, minnext, f = 0;
d666 1
a666 1
		    if (data)
d668 4
d681 2
d845 2
a846 2
	    I32 mincount, maxcount, minnext, deltanext, pos_before, fl;
	    I32 f = flags;
d889 5
d913 8
d958 5
a962 2
		    Perl_warner(aTHX_ WARN_REGEXP,
				"Strange *+?{} on zero-length expression");
d1025 1
a1025 1
			    FAIL("panic opt close");
d1056 8
a1063 2
		else if (OP(oscan) == CURLYX && data && ++data->whilem_c < 16) {
		    /* This stays as CURLYX, and can put the count/of pair. */
d1104 5
d1377 1
a1377 1
	    I32 deltanext, minnext;
d1383 1
a1383 1
	    if (data)
d1385 4
d1393 1
a1393 1
		f = SCF_DO_STCLASS_AND;
d1395 2
d1402 1
a1402 1
		    FAIL("variable length lookbehind not implemented");
d1405 1
a1405 1
		    FAIL2("lookbehind longer than %"UVuf" not implemented", (UV)U8_MAX);
d1415 1
a1415 1
	    if (f) {
d1426 3
a1428 2
	else if (OP(scan) == CLOSE && ARG(scan) == is_par) {
	    next = regnext(scan);
d1430 5
a1434 2
	    if ( next && (OP(next) != WHILEM) && next < last)
		is_par = 0;		/* Disable optimization */
a1476 1
    dTHR;
a1496 1
    dTHR;
d1518 1
a1536 1
    dTHR;
d1555 1
a1555 1
    PL_regprecomp = savepvn(exp, xend - exp);
a1580 1
	Safefree(PL_regprecomp);
d1599 2
a1600 1
	FAIL("regexp out of space");
d1607 1
a1607 1
    r->precomp = PL_regprecomp;
d1652 1
d1745 1
d1748 1
a1748 1
			     &data, SCF_DO_SUBSTR | stclass_flag);
d1850 1
d1856 2
a1857 1
	minlen = study_chunk(&scan, &fake, scan + PL_regsize, &data, SCF_DO_STCLASS_AND);
d1887 1
a1904 1
    dTHR;
d1911 1
d1922 1
d1943 1
a1943 1
		FAIL2("Sequence (?%c...) not implemented", (int)paren);
d1955 1
a1955 2
		    Perl_warner(aTHX_ WARN_REGEXP,
				"(?p{}) is deprecated - use (??{})");
a1962 1
		dTHR;
d1981 4
a1984 1
		    FAIL("Sequence (?{...}) not terminated or not {}-balanced");
d1993 2
d1996 1
d2046 1
a2046 1
			FAIL2("Switch (?(number%c not recognized", c);
d2068 1
a2068 1
			FAIL("Switch (?(condition)... contains too many branches");
d2080 1
a2080 1
		    FAIL2("Unknown condition for (?(%.2s", PL_regcomp_parse);
d2084 2
a2085 1
                FAIL("Sequence (? incomplete");
d2108 4
a2111 2
		if (*PL_regcomp_parse != ')')
		    FAIL2("Sequence (?%c...) not recognized", *PL_regcomp_parse);
d2223 2
a2224 1
	    FAIL("unmatched () in regexp");
d2229 2
a2230 1
	    FAIL("unmatched () in regexp");
d2233 1
a2233 1
	    FAIL("junk on end of regexp");	/* "Can't happen". */
a2247 1
    dTHR;
a2312 1
    dTHR;
d2356 1
a2356 1
		FAIL2("Quantifier in {,} bigger than %d", REG_INFTY - 1);
d2390 1
a2390 1
		FAIL("Can't do {n,m} with n > m");
d2406 11
d2418 1
a2418 1
      FAIL("regexp *+ operand could be empty");
d2449 4
a2452 2
	Perl_warner(aTHX_ WARN_REGEXP, "%.*s matches null string many times",
	    PL_regcomp_parse - origparse, origparse);
d2460 4
a2463 2
    if (ISMULT2(PL_regcomp_parse))
	FAIL("nested *?+ in regexp");
d2476 1
a2476 2
 * [Yes, it is worth fixing, some scripts can run twice the speed.]
 */
a2479 1
    dTHR;
d2498 2
a2499 1
	if (PL_regcomp_parse[1]) 
a2500 1
	nextchar();
d2527 2
a2528 1
	PL_regcomp_parse++;
d2530 4
a2533 2
	if (*PL_regcomp_parse != ']')
	    FAIL("unmatched [] in regexp");
d2537 1
d2542 6
a2547 1
		if (flags & TRYAGAIN)
d2549 1
d2560 1
a2560 1
	FAIL2("internal urp in regexp at /%s/", PL_regcomp_parse);
d2572 2
a2573 1
	FAIL("?+*{} follows nothing in regexp");
d2697 5
a2701 2
		    if (!PL_regxend)
			FAIL("Missing right brace on \\p{}");
d2734 3
d2738 1
a2738 1
			FAIL("reference to nonexistent group");
a2743 2
		    while (isDIGIT(*PL_regcomp_parse))
			PL_regcomp_parse++;
d2751 1
a2751 1
		FAIL("trailing \\ in regexp");
d2769 1
a2769 1
	    register I32 len;
d2773 1
a2773 1
	    I32 numlen;
d2853 9
a2861 5
			    if (!e)
				FAIL("Missing right brace on \\x{}");
			    else if (UTF) {
				ender = (UV)scan_hex(p + 1, e - p, &numlen);
				if (numlen + len >= 127) {	/* numlen is generous */
a2866 2
			    else
				FAIL("Can't use \\x{} without 'use utf8' declaration");
d2869 1
d2883 1
d2894 1
a2894 1
			    FAIL("trailing \\ in regexp");
d2898 1
a2898 4
			    Perl_warner(aTHX_ WARN_REGEXP, 
					"/%.127s/: Unrecognized escape \\%c passed through",
					PL_regprecomp,
					*p);
d2904 3
a2906 2
		    if ((*p & 0xc0) == 0xc0 && UTF) {
			ender = utf8_to_uv((U8*)p, &numlen);
d2924 2
d2937 2
d2950 6
a2955 2
	    if (len < 0)
		FAIL("internal disaster in regexp");
a2997 1
    dTHR;
d3036 5
d3072 2
a3073 1
				complement ? ANYOF_NSPACE : ANYOF_SPACE;
d3097 5
a3101 4
			Perl_croak(aTHX_
				   "Character class [:%.*s:] unknown",
				   t - s - 1, s + 1);
		} else if (ckWARN(WARN_REGEXP) && !SIZE_ONLY)
d3103 7
a3109 2
		    Perl_warner(aTHX_ WARN_REGEXP,
				"Character class syntax [%c %c] is reserved for future extensions", c, c);
d3134 3
a3136 2
	    Perl_warner(aTHX_ WARN_REGEXP,
			"Character class syntax [%c %c] belongs inside character classes", c, c);
d3138 7
a3144 2
		Perl_warner(aTHX_ WARN_REGEXP,
			    "Character class syntax [%c %c] is reserved for future extensions", c, c);
a3151 1
    dTHR;
d3156 1
a3156 1
    I32 numlen;
d3196 1
a3196 1
	     * values, therefore value cannot be an UV. --jhi */
d3217 1
d3227 1
d3233 2
a3234 4
		    Perl_warner(aTHX_ WARN_REGEXP, 
				"/%.127s/: Unrecognized escape \\%c in character class passed through",
				PL_regprecomp,
				(int)value);
d3245 5
a3249 6
			Perl_warner(aTHX_ WARN_REGEXP,
				    "/%.127s/: false [] range \"%*.*s\" in regexp",
				    PL_regprecomp,
				    PL_regcomp_parse - rangebegin,
				    PL_regcomp_parse - rangebegin,
				    rangebegin);
d3375 18
d3466 18
d3539 1
a3539 1
		    FAIL("invalid [::] class in regexp");
d3549 4
a3552 6
		Perl_croak(aTHX_
			   "/%.127s/: invalid [] range \"%*.*s\" in regexp",
			   PL_regprecomp,
			   PL_regcomp_parse - rangebegin,
			   PL_regcomp_parse - rangebegin,
			   rangebegin);
d3563 5
a3567 6
			Perl_warner(aTHX_ WARN_REGEXP,
				    "/%.127s/: false [] range \"%*.*s\" in regexp",
				    PL_regprecomp,
				    PL_regcomp_parse - rangebegin,
				    PL_regcomp_parse - rangebegin,
				    rangebegin);
a3627 1
    dTHR;
d3633 1
a3633 1
    I32 numlen;
d3651 1
a3651 1
	listsv = newSVpvn("# comment\n",10);
d3665 3
a3667 1
	value = utf8_to_uv((U8*)PL_regcomp_parse, &numlen);
d3672 3
a3674 1
	    value = (U32)utf8_to_uv((U8*)PL_regcomp_parse, &numlen);
d3691 1
a3691 1
                        FAIL("Missing right brace on \\p{}");
d3724 3
a3726 2
                    if (!e)
                        FAIL("Missing right brace on \\x{}");
d3733 1
d3744 1
d3750 3
a3752 4
		    Perl_warner(aTHX_ WARN_REGEXP, 
				"/%.127s/: Unrecognized escape \\%c in character class passed through",
				PL_regprecomp,
				(int)value);
d3760 5
a3764 6
			Perl_warner(aTHX_ WARN_REGEXP,
				    "/%.127s/: false [] range \"%*.*s\" in regexp",
				    PL_regprecomp,
				    PL_regcomp_parse - rangebegin,
				    PL_regcomp_parse - rangebegin,
				    rangebegin);
d3814 8
d3823 1
a3823 1
		case ANYOF_NSPACE:
d3839 4
a3842 6
		Perl_croak(aTHX_
			   "/%.127s/: invalid [] range \"%*.*s\" in regexp",
			   PL_regprecomp,
			   PL_regcomp_parse - rangebegin,
			   PL_regcomp_parse - rangebegin,
			   rangebegin);
d3853 5
a3857 6
			Perl_warner(aTHX_ WARN_REGEXP,
				    "/%.127s/: false [] range \"%*.*s\" in regexp",
				    PL_regprecomp,
				    PL_regcomp_parse - rangebegin,
				    PL_regcomp_parse - rangebegin,
				    rangebegin);
d3878 6
d3885 1
a3897 1
    dTHR;
a3929 1
    dTHR;
a3953 1
    dTHR;
d3976 1
a3976 1
S_reguni(pTHX_ UV uv, char* s, I32* lenp)
d3978 1
a3978 8
    dTHR;
    if (SIZE_ONLY) {
	U8 tmpbuf[UTF8_MAXLEN];
	*lenp = uv_to_utf8(tmpbuf, uv) - tmpbuf;
    }
    else
	*lenp = uv_to_utf8((U8*)s, uv) - (U8*)s;

a3988 1
    dTHR;
a4018 1
    dTHR;
a4047 1
    dTHR;
a4160 1
    dTHR;
d4227 1
a4227 1
    if (c <= ' ' || c == 127 || c == 255)
a4241 1
    dTHR;
d4246 1
a4246 1
	FAIL("corrupted regexp opcode");
d4255 1
a4255 1
	if (OP(o) == CURLYM || OP(o) == CURLYN)
d4267 4
a4270 2
	const char * const out[] = {	/* Should be syncronized with
					   a table in regcomp.h */
d4294 1
a4294 1
	    "[:!upper:]",
d4296 5
a4300 1
	    "[:^xdigit:]"
d4303 1
a4303 1
	if (o->flags & ANYOF_LOCALE)
d4305 1
a4305 1
	if (o->flags & ANYOF_FOLD)
d4308 1
a4308 1
	if (o->flags & ANYOF_INVERT)
d4310 10
a4319 7
	for (i = 0; i <= 256; i++) {
	    if (i < 256 && ANYOF_BITMAP_TEST(o,i)) {
		if (rangestart == -1)
		    rangestart = i;
	    } else if (rangestart != -1) {
		if (i <= rangestart + 3)
		    for (; rangestart < i; rangestart++)
d4321 58
a4378 4
		else {
		    put_byte(sv, rangestart);
		    sv_catpv(sv, "-");
		    put_byte(sv, i - 1);
a4379 1
		rangestart = -1;
a4381 4
	if (o->flags & ANYOF_CLASS)
	    for (i = 0; i < sizeof(out)/sizeof(char*); i++)
		if (ANYOF_CLASS_TEST(o,i))
		    sv_catpv(sv, out[i]);
a4410 1
    dTHR;
d4455 7
a4461 2
		PL_comppad = new_comppad;
		PL_curpad = AvARRAY(new_comppad);
a4490 1
    dTHR;
a4541 1
    dTHR;
d4555 1
a4555 1
    SAVEVPTR(PL_reg_start_tmp);		/* from regexec.c */
a4556 1
    SAVEFREEPV(PL_reg_start_tmp);
d4582 1
@


1.3
log
@perl5.005_03 (stock)
@
text
@d28 1
a28 1
#  ifndef DEBUGGING
d38 2
a40 1
#  define Perl_pregfree my_regfree
d42 4
d72 1
a72 1
 ****    Copyright (c) 1991-1999, Larry Wall
d83 1
d86 5
a90 1
#ifndef PERL_IN_XSUB_RE
a134 22
/*
 * Forward declarations for pregcomp()'s friends.
 */

#ifndef PERL_OBJECT
static regnode *reg _((I32, I32 *));
static regnode *reganode _((U8, U32));
static regnode *regatom _((I32 *));
static regnode *regbranch _((I32 *, I32));
static void regc _((U8, char *));
static regnode *regclass _((void));
STATIC I32 regcurly _((char *));
static regnode *reg_node _((U8));
static regnode *regpiece _((I32 *));
static void reginsert _((U8, regnode *));
static void regoptail _((regnode *, regnode *));
static void regtail _((regnode *, regnode *));
static char* regwhite _((char *, char *));
static char* nextchar _((void));
static void re_croak2 _((const char* pat1,const char* pat2,...)) __attribute__((noreturn));
#endif

d137 1
a137 2
#ifndef PERL_OBJECT
typedef struct {
d153 2
a155 1
#endif
d157 6
a162 1
static scan_data_t zero_scan_data = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
d188 24
d214 1
a214 1
scan_commit(scan_data_t *data)
d216 3
a218 2
    STRLEN l = SvCUR(data->last_found);
    STRLEN old_l = SvCUR(*data->longest);
d229 2
a230 1
	} else {
d247 125
d376 1
a376 1
study_chunk(regnode **scanp, I32 *deltap, regnode *last, scan_data_t *data, U32 flags)
d389 1
d394 2
a395 1
	if (regkind[(U8)OP(scan)] == EXACT) {
d402 1
a402 1
	    next = scan + (*OPERAND(scan) + 2 - 1)/sizeof(regnode) + 2;
d405 1
a405 1
		   ( regkind[(U8)OP(n)] == NOTHING || 
d411 1
a411 1
		if (regkind[(U8)OP(n)] == NOTHING) {
d419 3
a421 2
		} else {
		    int oldl = *OPERAND(scan);
d424 1
a424 1
		    if (oldl + *OPERAND(n) > U8_MAX) 
d427 2
a428 2
		    *OPERAND(scan) += *OPERAND(n);
		    next = n + (*OPERAND(n) + 2 - 1)/sizeof(regnode) + 2;
d430 2
a431 2
		    Move(OPERAND(n) + 1, OPERAND(scan) + oldl + 1,
			 *OPERAND(n) + 1, char);
d441 1
a441 1
	    n = scan + (*OPERAND(scan) + 2 - 1)/sizeof(regnode) + 2;
d443 1
a443 5
		/* Purify reports a benign UMR here sometimes, because we
		 * don't initialize the OP() slot of a node when that node
		 * is occupied by just the trailing null of the string in
		 * an EXACT node */
		if (regkind[(U8)OP(n)] != NOTHING || OP(n) == NOTHING) {
d449 1
a449 2
#endif 

d451 2
d464 1
a464 1
		   && ((regkind[(U8)OP(n)] == NOTHING && (noff = NEXT_OFF(n)))
d473 2
d482 1
d484 4
a487 2
		if (flags & SCF_DO_SUBSTR)
		    scan_commit(data);
d489 2
a490 1
		    I32 deltanext, minnext;
d494 2
d500 6
a505 1
		    /* We suppose the run is continuous, last=next...*/
d507 1
a507 1
					  &data_fake, 0);
d519 4
d536 26
a561 1
	    } else if (code == BRANCHJ)	/* single branch is optimized. */
d566 14
a579 2
	} else if (OP(scan) == EXACT) {
	    min += *OPERAND(scan);
a580 2
		I32 l = *OPERAND(scan);

d588 1
a588 1
		sv_catpvn(data->last_found, (char *)(OPERAND(scan)+1), l);
d593 28
a620 1
	} else if (regkind[(U8)OP(scan)] == EXACT) {
d623 11
a633 1
	    min += *OPERAND(scan);
d635 32
a666 2
		data->pos_min += *OPERAND(scan);
	} else if (strchr(varies,OP(scan))) {
d668 1
d670 5
a674 3
	    
	    switch (regkind[(U8)OP(scan)]) {
	    case WHILEM:
d678 1
a678 1
		if (flags & SCF_DO_SUBSTR) {
d680 1
a680 1
		    if (OP(next) == EXACT) {
d693 7
d703 1
a703 1
		    scan_commit(data);
d714 1
a714 1
		    if (mincount == 0) scan_commit(data);
d723 8
d734 28
a761 1
					? (flags & ~SCF_DO_SUBSTR) : flags);
d764 1
a764 1
		if (PL_dowarn && (minnext + deltanext == 0) 
d766 3
a768 2
		    && maxcount <= 10000) /* Complement check for big count */
		    warn("Strange *+?{} on zero-length expression");
d770 3
a772 3
		is_inf_internal |= (maxcount == REG_INFTY 
				    && (minnext + deltanext) > 0
				   || deltanext == I32_MAX);
d787 3
a789 3
		    if (!strchr(simple,OP(nxt))
			&& !(regkind[(U8)OP(nxt)] == EXACT
			     && *OPERAND(nxt) == 1)) 
d858 2
a859 1
		    } else
d862 10
d883 4
d888 1
a888 1
			l -= b - data->last_start_min;
d890 1
a890 1
			last_str = newSVpv(s  +  b - data->last_start_min, l);
d911 2
d918 1
a918 1
				data->pos_min - SvCUR(last_str);
d922 1
a922 1
				- SvCUR(last_str);
d932 1
a932 1
		    while (regkind[(U8)OP(next = regnext(oscan))] == NOTHING
d937 1
a937 1
	    default:			/* REF only? */
d939 1
a939 1
		    scan_commit(data);
d943 3
d948 4
a951 1
	} else if (strchr(simple,OP(scan))) {
d957 206
a1162 1
	} else if (regkind[(U8)OP(scan)] == EOL && flags & SCF_DO_SUBSTR) {
d1166 4
a1169 2
	} else if (regkind[(U8)OP(scan)] == BRANCHJ
		   && (scan->flags || data)
d1171 1
d1174 2
d1178 8
d1188 1
a1188 1
	    minnext = study_chunk(&nscan, &deltanext, last, &data_fake, 0);
d1192 3
a1194 2
		} else if (minnext > U8_MAX) {
		    FAIL2("lookbehind longer than %d not implemented", U8_MAX);
d1202 11
a1212 1
	} else if (OP(scan) == OPEN) {
d1214 2
a1215 1
	} else if (OP(scan) == CLOSE && ARG(scan) == is_par) {
d1220 2
a1221 1
	} else if (OP(scan) == EVAL) {
d1225 10
d1249 2
a1250 1
    } else if (pars && data) {
d1254 2
d1260 1
a1260 1
add_data(I32 n, char *s)
d1269 2
a1270 1
    } else {
d1280 25
d1321 1
a1321 1
pregcomp(char *exp, char *xend, PMOP *pm)
a1325 3
    SV **longest;
    SV *longest_fixed;
    SV *longest_float;
d1331 1
d1336 6
d1343 4
a1346 2
    DEBUG_r(PerlIO_printf(Perl_debug_log, "compiling RE `%*s'\n",
			  xend - exp, PL_regprecomp));
d1362 5
a1366 1
    regc((U8)MAGIC, (char*)PL_regcode);
d1372 1
a1372 26
    DEBUG_r(PerlIO_printf(Perl_debug_log, "size %d ", PL_regsize));

    DEBUG_r(
	if (!PL_colorset) {
	    int i = 0;
	    char *s = PerlEnv_getenv("TERMCAP_COLORS");
	    
	    PL_colorset = 1;
	    if (s) {
		PL_colors[0] = s = savepv(s);
		while (++i < 4) {
		    s = strchr(s, '\t');
		    if (!s) 
			FAIL("Not enough TABs in TERMCAP_COLORS");
		    *s = '\0';
		    PL_colors[i] = ++s;
		}
	    } else {
		while (i < 4) 
		    PL_colors[i++] = "";
	    }
	    /* Reset colors: */
	    PerlIO_printf(Perl_debug_log, "%s%s%s%s", 
			  PL_colors[0],PL_colors[1],PL_colors[2],PL_colors[3]);
	}
	);
d1380 2
d1388 4
d1395 8
a1402 2
    r->subbeg = r->subbase = NULL;
    r->nparens = PL_regnpar - 1;		/* set early to validate backrefs */
d1413 1
a1413 1
    regc((U8)MAGIC, (char*) PL_regcode++);
d1419 1
a1419 1
    r->reganch = pm->op_pmflags & PMf_COMPILETIME;
d1421 2
d1424 2
a1425 1
    r->naughty = PL_regnaughty >= 10;	/* Probably an expensive pattern. */
d1432 2
a1434 1
	scan_data_t data;
d1437 2
a1439 1
	StructCopy(&zero_scan_data, &data, scan_data_t);
d1443 1
d1447 2
a1448 1
	    (regkind[(U8)OP(first)] == CURLY && ARG1(first) > 0) ) {
d1458 7
a1464 2
	if (OP(first) == EXACT);	/* Empty, get anchored substr later. */
	else if (strchr(simple+2,OP(first)))
d1466 2
a1467 2
	else if (regkind[(U8)OP(first)] == BOUND ||
		 regkind[(U8)OP(first)] == NBOUND)
d1469 6
a1474 2
	else if (regkind[(U8)OP(first)] == BOL) {
	    r->reganch |= (OP(first) == MBOL ? ROPT_ANCH_MBOL: ROPT_ANCH_BOL);
d1484 1
a1484 1
	    regkind[(U8)OP(NEXTOPER(first))] == ANY) &&
d1488 8
a1495 1
	    r->reganch |= ROPT_ANCH_BOL | ROPT_IMPLICIT;
d1499 4
a1502 2
	if (sawplus && (!sawopen || !PL_regsawback))
	    r->reganch |= ROPT_SKIP;	/* x+ must match 1st of run */
d1505 2
a1506 2
	DEBUG_r(PerlIO_printf(Perl_debug_log, "first at %d\n", 
			      first - scan + 1));
d1520 3
a1522 3
	data.longest_fixed = newSVpv("",0);
	data.longest_float = newSVpv("",0);
	data.last_found = newSVpv("",0);
d1525 7
a1531 1
	
d1533 1
a1533 1
			     &data, SCF_DO_SUBSTR);
d1542 1
a1542 1
	longest_float_length = SvCUR(data.longest_float);
d1547 3
a1549 1
	    if (SvCUR(data.longest_fixed) 
d1552 2
a1553 2
		goto remove_float;		/* Like in (a)+. */
	    
d1557 6
a1562 7
	    fbm_compile(r->float_substr, 0);
	    BmUSEFUL(r->float_substr) = 100;
	    if (data.flags & SF_FL_BEFORE_EOL /* Cannot have SEOL and MULTI */
		&& (!(data.flags & SF_FL_BEFORE_MEOL)
		    || (PL_regflags & PMf_MULTILINE))) 
		SvTAIL_on(r->float_substr);
	} else {
d1569 1
a1569 1
	longest_fixed_length = SvCUR(data.longest_fixed);
d1574 2
d1578 6
a1583 7
	    fbm_compile(r->anchored_substr, 0);
	    BmUSEFUL(r->anchored_substr) = 100;
	    if (data.flags & SF_FIX_BEFORE_EOL /* Cannot have SEOL and MULTI */
		&& (!(data.flags & SF_FIX_BEFORE_MEOL)
		    || (PL_regflags & PMf_MULTILINE)))
		SvTAIL_on(r->anchored_substr);
	} else {
d1588 22
d1617 2
a1618 1
	} else {
d1623 9
a1631 1
    } else {
d1634 1
d1638 3
a1640 1
	minlen = study_chunk(&scan, &fake, scan + PL_regsize, NULL, 0);
d1642 17
d1668 2
a1669 2
    Newz(1002, r->startp, PL_regnpar, char*);
    Newz(1002, r->endp, PL_regnpar, char*);
d1684 1
a1684 1
reg(I32 paren, I32 *flagp)
d1703 1
d1734 9
d1769 1
a1769 1
			sv = newSVpv(s, PL_regcomp_parse - 1 - s);
d1771 1
a1771 1
			sv = newSVpv("", 0);
d1775 1
a1775 1
		    n = add_data(3, "nso");
d1777 2
a1778 2
		    PL_regcomp_rx->data->data[n+1] = (void*)av;
		    PL_regcomp_rx->data->data[n+2] = (void*)sop;
d1780 4
a1783 2
		} else {		/* First pass */
		    if (PL_reginterp_cnt < ++PL_seen_evals && PL_curcop != &PL_compiling)
d1792 7
d1810 2
d1815 2
a1816 1
		} else if (PL_regcomp_parse[0] >= '1' && PL_regcomp_parse[0] <= '9' ) {
d1838 1
a1838 1
			if (flags&HASWIDTH)
d1841 2
a1842 1
		    } else
d1851 2
a1852 1
		    } else
d1855 2
a1856 1
		} else {
d1897 2
a1898 1
    } else
d1908 2
a1909 1
	} else
d1914 2
a1915 1
    } else if (paren == ':') {
d1920 2
a1921 1
    } else if (paren != '?')		/* Not Conditional */
d1994 7
a2000 3
    if (paren && (PL_regcomp_parse >= PL_regxend || *nextchar() != ')')) {
	FAIL("unmatched () in regexp");
    } else if (!paren && PL_regcomp_parse < PL_regxend) {
d2003 2
a2004 1
	} else
a2007 3
    if (paren != 0) {
	PL_regflags = oregflags;
    }
d2018 1
a2018 1
regbranch(I32 *flagp, I32 first)
d2049 2
a2050 1
	} else if (ret == NULL)
d2084 1
a2084 1
regpiece(I32 *flagp)
d2140 4
a2143 2
		PL_regnaughty += 4 + PL_regnaughty;	/* compound interest */
		regtail(ret, reg_node(WHILEM));
d2154 2
a2155 1
		    PL_extralen += 3;
d2196 2
a2197 1
    } else if (op == '+' && (flags&SIMPLE)) {
d2205 2
a2206 1
    } else if (op == '?') {
d2211 2
a2212 2
    if (PL_dowarn && !SIZE_ONLY && !(flags&HASWIDTH) && max > 10000) {
	warn("%.*s matches null string many times",
d2238 1
a2238 1
regatom(I32 *flagp)
d2271 14
a2284 4
	if (PL_regflags & PMf_SINGLELINE)
	    ret = reg_node(SANY);
	else
	    ret = reg_node(ANY);
a2285 1
	*flagp |= HASWIDTH|SIMPLE;
d2289 4
a2292 1
	ret = regclass();
d2350 12
d2363 4
a2366 1
	    ret = reg_node((PL_regflags & PMf_LOCALE) ? ALNUML : ALNUM);
d2369 2
d2373 4
a2376 1
	    ret = reg_node((PL_regflags & PMf_LOCALE) ? NALNUML : NALNUM);
d2379 2
d2384 5
a2388 1
	    ret = reg_node((PL_regflags & PMf_LOCALE) ? BOUNDL : BOUND);
d2391 2
d2396 5
a2400 1
	    ret = reg_node((PL_regflags & PMf_LOCALE) ? NBOUNDL : NBOUND);
d2403 2
d2407 4
a2410 1
	    ret = reg_node((PL_regflags & PMf_LOCALE) ? SPACEL : SPACE);
d2413 2
d2417 4
a2420 1
	    ret = reg_node((PL_regflags & PMf_LOCALE) ? NSPACEL : NSPACE);
d2423 2
d2427 1
a2427 1
	    ret = reg_node(DIGIT);
d2430 2
d2434 1
a2434 1
	    ret = reg_node(NDIGIT);
d2437 25
d2484 2
a2485 2
		    ret = reganode((PL_regflags & PMf_FOLD)
				   ? ((PL_regflags & PMf_LOCALE) ? REFFL : REFF)
d2500 2
d2516 1
a2516 1
	    register U8 ender;
d2524 2
a2525 2
	    ret = reg_node((PL_regflags & PMf_FOLD)
			  ? ((PL_regflags & PMf_LOCALE) ? EXACTFL : EXACTF)
d2527 1
a2527 2
	    s = (char *) OPERAND(ret);
	    regc(0, s++);		/* save spot for len */
d2559 2
d2580 5
a2584 1
			ender = '\033';
d2588 5
a2592 1
			ender = '\007';
d2596 20
a2615 2
			ender = scan_hex(++p, 2, &numlen);
			p += numlen;
d2626 1
a2626 1
			    ender = scan_oct(p, 3, &numlen);
d2639 6
a2644 2
			ender = *p++;
			break;
d2648 7
a2654 1
		    ender = *p++;
d2659 6
d2668 5
d2675 1
a2675 1
			regc(ender, s++);
d2679 7
a2685 1
		regc(ender, s++);
d2697 5
a2701 7
		*OPERAND(ret) = len;
	    regc('\0', s++);
	    if (SIZE_ONLY) {
		PL_regsize += (len + 2 + sizeof(regnode) - 1) / sizeof(regnode);
	    } else {
		PL_regcode += (len + 2 + sizeof(regnode) - 1) / sizeof(regnode);
	    }
d2710 1
a2710 1
regwhite(char *p, char *e)
d2726 142
d2869 1
a2869 1
regclass(void)
d2872 2
a2873 3
    register char *opnd, *s;
    register I32 Class;
    register I32 lastclass = 1234;
a2875 1
    register I32 def;
d2877 3
a2880 1
    s = opnd = (char *) OPERAND(PL_regcode);
d2882 11
a2892 2
    for (Class = 0; Class < 33; Class++)
	regc(0, s++);
d2897 1
a2897 10
	    *opnd |= ANYOF_INVERT;
    }
    if (!SIZE_ONLY) {
 	PL_regcode += ANY_SKIP;
	if (PL_regflags & PMf_FOLD)
	    *opnd |= ANYOF_FOLD;
	if (PL_regflags & PMf_LOCALE)
	    *opnd |= ANYOF_LOCALE;
    } else {
	PL_regsize += ANY_SKIP;
d2899 4
d2907 49
a2955 23
	Class = UCHARAT(PL_regcomp_parse++);
	if (Class == '[' && PL_regcomp_parse + 1 < PL_regxend &&
	    /* I smell either [: or [= or [. -- POSIX has been here, right? */
	    (*PL_regcomp_parse == ':' || *PL_regcomp_parse == '=' || *PL_regcomp_parse == '.')) {
	    char  posixccc = *PL_regcomp_parse;
	    char* posixccs = PL_regcomp_parse++;
	    
	    while (PL_regcomp_parse < PL_regxend && *PL_regcomp_parse != posixccc)
		PL_regcomp_parse++;
	    if (PL_regcomp_parse == PL_regxend)
		/* Grandfather lone [:, [=, [. */
		PL_regcomp_parse = posixccs;
	    else {
		PL_regcomp_parse++; /* skip over the posixccc */
		if (*PL_regcomp_parse == ']') {
		    /* Not Implemented Yet.
		     * (POSIX Extended Character Classes, that is)
		     * The text between e.g. [: and :] would start
		     * at posixccs + 1 and stop at regcomp_parse - 2. */
		    if (PL_dowarn && !SIZE_ONLY)
			warn("Character class syntax [%c %c] is reserved for future extensions", posixccc, posixccc);
		    PL_regcomp_parse++; /* skip over the ending ] */
		}
d2958 5
a2962 4
	if (Class == '\\') {
	    Class = UCHARAT(PL_regcomp_parse++);
	    switch (Class) {
	    case 'w':
d2964 17
a2980 2
		    if (PL_regflags & PMf_LOCALE)
			*opnd |= ANYOF_ALNUML;
d2982 3
a2984 3
			for (Class = 0; Class < 256; Class++)
			    if (isALNUM(Class))
				ANYOF_SET(opnd, Class);
d2986 213
a3198 7
		}
		lastclass = 1234;
		continue;
	    case 'W':
		if (!SIZE_ONLY) {
		    if (PL_regflags & PMf_LOCALE)
			*opnd |= ANYOF_NALNUML;
d3200 3
a3202 3
			for (Class = 0; Class < 256; Class++)
			    if (!isALNUM(Class))
				ANYOF_SET(opnd, Class);
d3204 4
a3207 7
		}
		lastclass = 1234;
		continue;
	    case 's':
		if (!SIZE_ONLY) {
		    if (PL_regflags & PMf_LOCALE)
			*opnd |= ANYOF_SPACEL;
d3209 3
a3211 3
			for (Class = 0; Class < 256; Class++)
			    if (isSPACE(Class))
				ANYOF_SET(opnd, Class);
d3213 4
a3216 7
		}
		lastclass = 1234;
		continue;
	    case 'S':
		if (!SIZE_ONLY) {
		    if (PL_regflags & PMf_LOCALE)
			*opnd |= ANYOF_NSPACEL;
d3218 3
a3220 3
			for (Class = 0; Class < 256; Class++)
			    if (!isSPACE(Class))
				ANYOF_SET(opnd, Class);
d3222 4
d3227 2
a3228 1
		lastclass = 1234;
a3229 50
	    case 'd':
		if (!SIZE_ONLY) {
		    for (Class = '0'; Class <= '9'; Class++)
			ANYOF_SET(opnd, Class);
		}
		lastclass = 1234;
		continue;
	    case 'D':
		if (!SIZE_ONLY) {
		    for (Class = 0; Class < '0'; Class++)
			ANYOF_SET(opnd, Class);
		    for (Class = '9' + 1; Class < 256; Class++)
			ANYOF_SET(opnd, Class);
		}
		lastclass = 1234;
		continue;
	    case 'n':
		Class = '\n';
		break;
	    case 'r':
		Class = '\r';
		break;
	    case 't':
		Class = '\t';
		break;
	    case 'f':
		Class = '\f';
		break;
	    case 'b':
		Class = '\b';
		break;
	    case 'e':
		Class = '\033';
		break;
	    case 'a':
		Class = '\007';
		break;
	    case 'x':
		Class = scan_hex(PL_regcomp_parse, 2, &numlen);
		PL_regcomp_parse += numlen;
		break;
	    case 'c':
		Class = UCHARAT(PL_regcomp_parse++);
		Class = toCTRL(Class);
		break;
	    case '0': case '1': case '2': case '3': case '4':
	    case '5': case '6': case '7': case '8': case '9':
		Class = scan_oct(--PL_regcomp_parse, 3, &numlen);
		PL_regcomp_parse += numlen;
		break;
d3233 8
a3240 2
	    if (lastclass > Class)
		FAIL("invalid [] range in regexp");
d3244 1
a3244 1
	    lastclass = Class;
d3246 1
a3246 1
	      PL_regcomp_parse[1] != ']') {
d3248 12
a3259 1
		range = 1;
d3263 1
d3265 7
a3271 6
#ifndef ASCIIish
	    register I32 i;
	    if ((isLOWER(lastclass) && isLOWER(Class)) ||
		(isUPPER(lastclass) && isUPPER(Class))) {
 		if (isLOWER(lastclass)) {
 		    for (i = lastclass; i <= Class; i++)
d3273 1
a3273 1
			    ANYOF_SET(opnd, i);
d3275 1
a3275 1
 		    for (i = lastclass; i <= Class; i++)
d3277 1
a3277 1
			    ANYOF_SET(opnd, i);
d3282 10
a3291 4
		for ( ; lastclass <= Class; lastclass++)
		    ANYOF_SET(opnd, lastclass);
	}
	lastclass = Class;
a3292 3
    if (*PL_regcomp_parse != ']')
	FAIL("unmatched [] in regexp");
    nextchar();
d3294 6
a3299 5
    if (!SIZE_ONLY && (*opnd & (0xFF ^ ANYOF_INVERT)) == ANYOF_FOLD) {
	for (Class = 0; Class < 256; ++Class) {
	    if (ANYOF_TEST(opnd, Class)) {
		I32 cf = fold[Class];
		ANYOF_SET(opnd, cf);
d3302 1
a3302 1
	*opnd &= ~ANYOF_FOLD;
d3305 4
a3308 4
    if (!SIZE_ONLY && (*opnd & 0xFF) == ANYOF_INVERT) {
	for (Class = 0; Class < 32; ++Class)
	    opnd[1 + Class] ^= 0xFF;
	*opnd = 0;
d3313 254
d3568 1
a3568 1
nextchar(void)
d3601 1
a3601 1
reg_node(U8 op)
d3626 1
a3626 1
reganode(U8 op, U32 arg)
d3648 1
a3648 1
- regc - emit (if appropriate) a byte of code
d3651 1
a3651 1
regc(U8 b, char* s)
d3654 7
a3660 2
    if (!SIZE_ONLY)
	*s = b;
d3669 1
a3669 1
reginsert(U8 op, regnode *opnd)
d3677 1
a3677 1
/* (regkind[(U8)op] == CURLY ? EXTRA_STEP_2ARGS : 0); */
d3700 1
a3700 1
regtail(regnode *p, regnode *val)
a3704 1
    register I32 offset;
d3720 2
a3721 1
    } else {
d3730 1
a3730 1
regoptail(regnode *p, regnode *val)
d3736 1
a3736 1
    if (regkind[(U8)OP(p)] == BRANCH) {
d3738 2
a3739 1
    } else if ( regkind[(U8)OP(p)] == BRANCHJ) {
d3741 2
a3742 1
    } else
d3750 1
a3750 1
regcurly(register char *s)
d3769 1
a3769 1
dumpuntil(regnode *start, regnode *node, regnode *last, SV* sv, I32 l)
d3772 2
a3773 2
    register char op = EXACT;	/* Arbitrary non-END op. */
    register regnode *next, *onode;
d3787 2
a3788 2
	PerlIO_printf(Perl_debug_log, "%4d:%*s%s", node - start, 
		      2*l + 1, "", SvPVX(sv));
d3792 1
a3792 1
	    PerlIO_printf(Perl_debug_log, "(%d)", next - start);
d3795 1
a3795 1
	if (regkind[(U8)op] == BRANCHJ) {
d3802 2
a3803 1
	} else if (regkind[(U8)op] == BRANCH) {
d3805 2
a3806 1
	} else if ( op == CURLY) {   /* `next' might be very big: optimizer */
d3809 2
a3810 1
	} else if (regkind[(U8)op] == CURLY && op != CURLYX) {
d3813 2
a3814 1
	} else if ( op == PLUS || op == STAR) {
d3816 2
a3817 1
	} else if (op == ANYOF) {
d3819 3
a3821 2
	    node += ANY_SKIP;
	} else if (regkind[(U8)op] == EXACT) {
d3823 1
a3823 1
	    node += ((*OPERAND(node)) + 2 + sizeof(regnode) - 1) / sizeof(regnode);
d3825 2
a3826 1
	} else {
d3843 1
a3843 1
regdump(regexp *r)
d3853 2
a3854 1
	PerlIO_printf(Perl_debug_log, "anchored `%s%s%s'%s at %d ", 
d3856 1
d3860 1
a3860 1
		      r->anchored_offset);
d3862 2
a3863 1
	PerlIO_printf(Perl_debug_log, "floating `%s%s%s'%s at %d..%u ", 
d3865 2
a3866 1
		      SvPVX(r->float_substr), 
d3869 1
a3869 1
		      r->float_min_offset, r->float_max_offset);
d3891 2
d3910 11
d3925 1
a3925 1
regprop(SV *sv, regnode *o)
d3929 1
a3929 1
    register char *p = 0;
d3932 1
a3932 177
    switch (OP(o)) {
    case BOL:
	p = "BOL";
	break;
    case MBOL:
	p = "MBOL";
	break;
    case SBOL:
	p = "SBOL";
	break;
    case EOL:
	p = "EOL";
	break;
    case EOS:
	p = "EOS";
	break;
    case MEOL:
	p = "MEOL";
	break;
    case SEOL:
	p = "SEOL";
	break;
    case ANY:
	p = "ANY";
	break;
    case SANY:
	p = "SANY";
	break;
    case ANYOF:
	p = "ANYOF";
	break;
    case BRANCH:
	p = "BRANCH";
	break;
    case EXACT:
	sv_catpvf(sv, "EXACT <%s%s%s>", PL_colors[0], OPERAND(o) + 1, PL_colors[1]);
	break;
    case EXACTF:
	sv_catpvf(sv, "EXACTF <%s%s%s>", PL_colors[0], OPERAND(o) + 1, PL_colors[1]);
	break;
    case EXACTFL:
	sv_catpvf(sv, "EXACTFL <%s%s%s>", PL_colors[0], OPERAND(o) + 1, PL_colors[1]);
	break;
    case NOTHING:
	p = "NOTHING";
	break;
    case TAIL:
	p = "TAIL";
	break;
    case BACK:
	p = "BACK";
	break;
    case END:
	p = "END";
	break;
    case BOUND:
	p = "BOUND";
	break;
    case BOUNDL:
	p = "BOUNDL";
	break;
    case NBOUND:
	p = "NBOUND";
	break;
    case NBOUNDL:
	p = "NBOUNDL";
	break;
    case CURLY:
	sv_catpvf(sv, "CURLY {%d,%d}", ARG1(o), ARG2(o));
	break;
    case CURLYM:
	sv_catpvf(sv, "CURLYM[%d] {%d,%d}", o->flags, ARG1(o), ARG2(o));
	break;
    case CURLYN:
	sv_catpvf(sv, "CURLYN[%d] {%d,%d}", o->flags, ARG1(o), ARG2(o));
	break;
    case CURLYX:
	sv_catpvf(sv, "CURLYX {%d,%d}", ARG1(o), ARG2(o));
	break;
    case REF:
	sv_catpvf(sv, "REF%d", ARG(o));
	break;
    case REFF:
	sv_catpvf(sv, "REFF%d", ARG(o));
	break;
    case REFFL:
	sv_catpvf(sv, "REFFL%d", ARG(o));
	break;
    case OPEN:
	sv_catpvf(sv, "OPEN%d", ARG(o));
	break;
    case CLOSE:
	sv_catpvf(sv, "CLOSE%d", ARG(o));
	p = NULL;
	break;
    case STAR:
	p = "STAR";
	break;
    case PLUS:
	p = "PLUS";
	break;
    case MINMOD:
	p = "MINMOD";
	break;
    case GPOS:
	p = "GPOS";
	break;
    case UNLESSM:
	sv_catpvf(sv, "UNLESSM[-%d]", o->flags);
	break;
    case IFMATCH:
	sv_catpvf(sv, "IFMATCH[-%d]", o->flags);
	break;
    case SUCCEED:
	p = "SUCCEED";
	break;
    case WHILEM:
	p = "WHILEM";
	break;
    case DIGIT:
	p = "DIGIT";
	break;
    case NDIGIT:
	p = "NDIGIT";
	break;
    case ALNUM:
	p = "ALNUM";
	break;
    case NALNUM:
	p = "NALNUM";
	break;
    case SPACE:
	p = "SPACE";
	break;
    case NSPACE:
	p = "NSPACE";
	break;
    case ALNUML:
	p = "ALNUML";
	break;
    case NALNUML:
	p = "NALNUML";
	break;
    case SPACEL:
	p = "SPACEL";
	break;
    case NSPACEL:
	p = "NSPACEL";
	break;
    case EVAL:
	p = "EVAL";
	break;
    case LONGJMP:
	p = "LONGJMP";
	break;
    case BRANCHJ:
	p = "BRANCHJ";
	break;
    case IFTHEN:
	p = "IFTHEN";
	break;
    case GROUPP:
	sv_catpvf(sv, "GROUPP%d", ARG(o));
	break;
    case LOGICAL:
	p = "LOGICAL";
	break;
    case SUSPEND:
	p = "SUSPEND";
	break;
    case RENUM:
	p = "RENUM";
	break;
    case OPTIMIZED:
	p = "OPTIMIZED";
	break;
    default:
d3934 78
d4013 2
a4014 2
    if (p)
	sv_catpv(sv, p);
d4018 19
d4038 1
a4038 1
pregfree(struct regexp *r)
d4041 2
d4045 7
d4054 2
a4055 2
    if (r->subbase)
	Safefree(r->subbase);
d4065 4
d4074 6
d4081 6
d4088 4
d4114 1
a4114 1
regnext(register regnode *p)
d4130 1
a4130 1
re_croak2(const char* pat1,const char* pat2,...)
d4136 1
d4147 2
d4150 4
a4153 1
    message = mess(buf, &args);
d4155 1
a4155 1
    l1 = strlen(message);
d4160 1
a4160 1
    croak("%s", buf);
d4162 65
@


1.2
log
@perl 5.004_04
@
text
@d22 21
d67 1
a67 1
 ****    Copyright (c) 1991-1997, Larry Wall
d79 6
a84 1
#include "INTERN.h"
d87 4
d120 1
a120 1
#define	HASWIDTH	0x1	/* Known never to match null string. */
d129 7
a135 6
static char *reg _((I32, I32 *));
static char *reganode _((char, unsigned short));
static char *regatom _((I32 *));
static char *regbranch _((I32 *));
static void regc _((char));
static char *regclass _((void));
d137 5
a141 6
static char *regnode _((char));
static char *regpiece _((I32 *));
static void reginsert _((char, char *));
static void regoptail _((char *, char *));
static void regset _((char *, I32));
static void regtail _((char *, char *));
d144 558
d719 1
a719 4
pregcomp(exp,xend,pm)
char* exp;
char* xend;
PMOP* pm;
d721 1
d723 5
a727 5
    register char *scan;
    register SV *longish;
    SV *longest;
    register I32 len;
    register char *first;
a728 3
    I32 backish;
    I32 backest;
    I32 curback;
a731 7
#define MAX_REPEAT_DEPTH 12
    struct {
	char *opcode;
	I32 count;
    } repeat_stack[MAX_REPEAT_DEPTH];
    I32 repeat_depth = 0;
    I32 repeat_count = 1;	/* We start unmultiplied. */
d734 1
a734 1
	croak("NULL regexp argument");
d736 10
a745 3
    regprecomp = savepvn(exp, xend - exp);
    regflags = pm->op_pmflags;
    regsawback = 0;
d748 7
a754 7
    regparse = exp;
    regxend = xend;
    regnaughty = 0;
    regnpar = 1;
    regsize = 0L;
    regcode = &regdummy;
    regc((char)MAGIC);
d756 2
a757 2
	Safefree(regprecomp);
	regprecomp = Nullch;
d760 1
d762 31
a792 3
    /* Small enough for pointer-storage convention? */
    if (regsize >= 32767L)		/* Probably could be 65535L. */
	FAIL("regexp too big");
d795 2
a796 1
    Newc(1001, r, sizeof(regexp) + (unsigned)regsize, char, regexp);
d799 1
d801 1
a801 1
    r->precomp = regprecomp;
d803 2
d807 9
a815 6
    regparse = exp;
    regxend = xend;
    regnaughty = 0;
    regnpar = 1;
    regcode = r->program;
    regc((char)MAGIC);
d820 14
a833 10
    pm->op_pmflags = regflags;
    r->regstart = Nullsv;	/* Worst-case defaults. */
    r->reganch = 0;
    r->regmust = Nullsv;
    r->regback = -1;
    r->regstclass = Nullch;
    r->naughty = regnaughty >= 10;	/* Probably an expensive pattern. */
    scan = r->program+1;			/* First BRANCH. */
    if (OP(regnext(scan)) == END) {/* Only one top-level choice. */
	scan = NEXTOPER(scan);
d835 1
d837 1
d852 1
a852 6
	if (OP(first) == EXACT) {
	    r->regstart = newSVpv(OPERAND(first)+1,*OPERAND(first));
	    if (SvCUR(r->regstart) > !sawstudy)
		fbm_compile(r->regstart);
	    (void)SvUPGRADE(r->regstart, SVt_PVBM);
	}
d859 1
a859 1
	    r->reganch |= ROPT_ANCH_BOL;
d877 1
a877 1
	if (sawplus && (!sawopen || !regsawback))
d880 3
a882 2
	DEBUG_r(PerlIO_printf(Perl_debug_log, "first %d next %d offset %ld\n",
	   OP(first), OP(NEXTOPER(first)), (long)(first - scan)));
d891 1
a891 1
	* it happens that curback has been invalidated, since the
a893 3
	longish = newSVpv("",0);
	longest = newSVpv("",0);
	len = 0;
a894 21
	curback = 0;
	backish = 0;
	backest = 0;
	while (OP(scan) != END) {
	    if (OP(scan) == BRANCH) {
		if (OP(regnext(scan)) == BRANCH) {
		    curback = -30000;
		    while (OP(scan) == BRANCH)
			scan = regnext(scan);
		}
		else	/* single branch is ok */
		    scan = NEXTOPER(scan);
		continue;
	    }
	    if (OP(scan) == UNLESSM) {
		curback = -30000;
		scan = regnext(scan);
		continue;
	    }
	    if (OP(scan) == EXACT) {
		char *t;
d896 80
a975 116
		first = scan;
		while ((t = regnext(scan)) && OP(t) == CLOSE)
		    scan = t;
		minlen += *OPERAND(first) * repeat_count;
		if (curback - backish == len) {
		    sv_catpvn(longish, OPERAND(first)+1,
			*OPERAND(first));
		    len += *OPERAND(first);
		    curback += *OPERAND(first);
		    first = regnext(scan);
		}
		else if (*OPERAND(first) >= len + (curback >= 0)) {
		    len = *OPERAND(first);
		    sv_setpvn(longish, OPERAND(first)+1,len);
		    backish = curback;
		    curback += len;
		    first = regnext(scan);
		}
		else
		    curback += *OPERAND(first);
	    }
	    else if (strchr(varies,OP(scan))) {
		int tcount;
		char *next;

		if (repeat_depth < MAX_REPEAT_DEPTH
		    && ((OP(scan) == PLUS
			 && (tcount = 1)
			 && (next = NEXTOPER(scan)))
			|| (regkind[(U8)OP(scan)] == CURLY
			    && (tcount = ARG1(scan))
			    && (next = NEXTOPER(scan)+4))))
		{
		    /* We treat (abc)+ as (abc)(abc)*. */

		    /* Mark the place to return back. */
		    repeat_stack[repeat_depth].opcode = regnext(scan);
		    repeat_stack[repeat_depth].count = repeat_count;
		    repeat_depth++;
		    repeat_count *= tcount;

		    /* Go deeper: */
		    scan = next;
		    continue;
		}
		else {
		    curback = -30000;
		    len = 0;
		    if (SvCUR(longish) > SvCUR(longest)) {
			sv_setsv(longest,longish);
			backest = backish;
		    }
		    sv_setpvn(longish,"",0);
		}
	    }
	    else if (strchr(simple,OP(scan))) {
		curback++;
		minlen += repeat_count;
		len = 0;
		if (SvCUR(longish) > SvCUR(longest)) {
		    sv_setsv(longest,longish);
		    backest = backish;
		}
		sv_setpvn(longish,"",0);
	    }
	    scan = regnext(scan);
	    if (!scan) {		/* Go up PLUS or CURLY. */
		if (!repeat_depth--)
		    croak("panic: re scan");
		scan = repeat_stack[repeat_depth].opcode;
		repeat_count = repeat_stack[repeat_depth].count;
		/* Need to submit the longest string found: */
		curback = -30000;
		len = 0;
		if (SvCUR(longish) > SvCUR(longest)) {
		    sv_setsv(longest,longish);
		    backest = backish;
		}
		sv_setpvn(longish,"",0);
	    }
	}

	/* Prefer earlier on tie, unless we can tail match latter */

	if (SvCUR(longish) + (first && regkind[(U8)OP(first)] == EOL)
		> SvCUR(longest))
	{
	    sv_setsv(longest,longish);
	    backest = backish;
	}
	else
	    sv_setpvn(longish,"",0);
	if (SvCUR(longest)
	    && (!r->regstart
		|| !fbm_instr((unsigned char*) SvPVX(r->regstart),
			      (unsigned char *) (SvPVX(r->regstart)
						 + SvCUR(r->regstart)),
			      longest)))
	{
	    r->regmust = longest;
	    if (backest < 0)
		backest = -1;
	    r->regback = backest;
	    if (SvCUR(longest) > !(sawstudy || 
				   (first && regkind[(U8)OP(first)] == EOL)))
		fbm_compile(r->regmust);
	    (void)SvUPGRADE(r->regmust, SVt_PVBM);
	    BmUSEFUL(r->regmust) = 100;
	    if (first && regkind[(U8)OP(first)] == EOL && SvCUR(longish))
		SvTAIL_on(r->regmust);
	}
	else {
	    SvREFCNT_dec(longest);
	    longest = Nullsv;
	}
	SvREFCNT_dec(longish);
a977 1
    r->nparens = regnpar - 1;
d979 8
a986 2
    Newz(1002, r->startp, regnpar, char*);
    Newz(1002, r->endp, regnpar, char*);
d1000 9
a1008 8
static char *
reg(paren, flagp)
I32 paren;			/* Parenthesized? */
I32 *flagp;
{
    register char *ret;
    register char *br;
    register char *ender = 0;
d1010 2
a1011 1
    I32 flags;
d1013 1
a1013 1
    *flagp = HASWIDTH;	/* Tentatively. */
d1017 7
a1023 4
	if (*regparse == '?') {
	    regparse++;
	    paren = *regparse++;
	    ret = NULL;
d1025 7
a1031 1
	    case ':':
d1034 3
d1040 1
a1040 1
		croak("Sequence (?%c...) not implemented", (int)paren);
d1043 4
a1046 4
		while (*regparse && *regparse != ')')
		    regparse++;
		if (*regparse != ')')
		    croak("Sequence (?#... not terminated");
d1050 102
d1153 1
a1153 1
                croak("Sequence (? incomplete");
d1156 22
a1177 5
		--regparse;
		while (*regparse && strchr("iogcmsx", *regparse))
		    pmflag(&regflags, *regparse++);
		if (*regparse != ')')
		    croak("Sequence (?%c...) not recognized", *regparse);
d1184 2
a1185 2
	    parno = regnpar;
	    regnpar++;
d1187 1
d1193 1
a1193 1
    br = regbranch(&flags);
d1196 14
a1209 3
    if (ret != NULL)
	regtail(ret, br);	/* OPEN -> first. */
    else
d1211 2
a1212 2
    if (!(flags&HASWIDTH))
	*flagp &= ~HASWIDTH;
d1214 8
a1221 1
    while (*regparse == '|') {
d1223 1
a1223 1
	br = regbranch(&flags);
d1226 4
a1229 3
	regtail(ret, br);	/* BRANCH -> BRANCH. */
	if (!(flags&HASWIDTH))
	    *flagp &= ~HASWIDTH;
d1233 30
a1262 16
    /* Make a closing node, and hook it on the end. */
    switch (paren) {
    case ':':
	ender = regnode(NOTHING);
	break;
    case 1:
	ender = reganode(CLOSE, parno);
	break;
    case '=':
    case '!':
	ender = regnode(SUCCEED);
	*flagp &= ~HASWIDTH;
	break;
    case 0:
	ender = regnode(END);
	break;
a1263 1
    regtail(ret, ender);
d1265 14
a1278 11
    /* Hook the tails of the branches to the closing node. */
    for (br = ret; br != NULL; br = regnext(br))
	regoptail(br, ender);

    if (paren == '=') {
	reginsert(IFMATCH,ret);
	regtail(ret, regnode(NOTHING));
    }
    else if (paren == '!') {
	reginsert(UNLESSM,ret);
	regtail(ret, regnode(NOTHING));
d1282 1
a1282 1
    if (paren && (regparse >= regxend || *nextchar() != ')')) {
d1284 2
a1285 2
    } else if (!paren && regparse < regxend) {
	if (*regparse == ')') {
d1291 3
d1303 8
a1310 8
static char *
regbranch(flagp)
I32 *flagp;
{
    register char *ret;
    register char *chain;
    register char *latest;
    I32 flags = 0;
d1312 13
a1324 1
    *flagp = WORST;		/* Tentatively. */
d1326 1
a1326 3
    ret = regnode(BRANCH);
    chain = NULL;
    regparse--;
d1328 1
a1328 1
    while (regparse < regxend && *regparse != '|' && *regparse != ')') {
d1335 2
a1336 1
	}
d1338 1
a1338 1
	if (chain == NULL)	/* First piece. */
d1341 1
a1341 1
	    regnaughty++;
d1345 9
a1354 2
    if (chain == NULL)	/* Loop ran zero times. */
	(void) regnode(NOTHING);
d1368 2
a1369 3
static char *
regpiece(flagp)
I32 *flagp;
d1371 2
a1372 1
    register char *ret;
d1376 1
a1376 1
    char *origparse = regparse;
d1379 1
a1379 1
    I32 max = 32767;
d1388 1
a1388 9
    op = *regparse;
    if (op == '(' && regparse[1] == '?' && regparse[2] == '#') {
	while (op && op != ')')
	    op = *++regparse;
	if (op) {
	    nextchar();
	    op = *regparse;
	}
    }
d1390 2
a1391 2
    if (op == '{' && regcurly(regparse)) {
	next = regparse + 1;
d1405 2
a1406 2
	    regparse++;
	    min = atoi(regparse);
d1410 1
a1410 1
		maxpos = regparse;
d1413 4
a1416 2
		max = 32767;		/* meaning "infinity" */
	    regparse = next;
d1421 1
a1421 1
		regnaughty += 2 + regnaughty / 2;
d1425 7
a1431 2
		regnaughty += 4 + regnaughty;	/* compound interest */
		regtail(ret, regnode(WHILEM));
d1433 5
a1437 1
		regtail(ret, regnode(NOTHING));
d1439 1
d1442 3
a1444 1
		*flagp = (WORST|HASWIDTH);
d1446 4
a1449 9
		croak("Can't do {n,m} with n > m");
	    if (regcode != &regdummy) {
#ifdef REGALIGN
		*(unsigned short *)(ret+3) = min;
		*(unsigned short *)(ret+5) = max;
#else
		ret[3] = min >> 8; ret[4] = min & 0377;
		ret[5] = max  >> 8; ret[6] = max  & 0377;
#endif
d1461 1
d1463 2
a1464 1
      FAIL("regexp *+ operand could be empty"); /* else may core dump */
d1468 1
a1468 1
    *flagp = (op != '+') ? (WORST|SPSTART) : (WORST|HASWIDTH);
d1472 2
a1473 1
	regnaughty += 4;
d1480 2
a1481 1
	regnaughty += 3;
d1491 1
a1491 1
    if (dowarn && regcode != &regdummy && !(flags&HASWIDTH) && max > 10000) {
d1493 1
a1493 1
	    regparse - origparse, origparse);
d1496 1
a1496 1
    if (*regparse == '?') {
d1499 1
a1499 5
#ifdef REGALIGN
	regtail(ret, ret + 4);
#else
	regtail(ret, ret + 3);
#endif
d1501 1
a1501 1
    if (ISMULT2(regparse))
d1517 2
a1518 3
static char *
regatom(flagp)
I32 *flagp;
d1520 2
a1521 1
    register char *ret = 0;
d1527 1
a1527 1
    switch (*regparse) {
d1529 1
d1531 4
a1534 4
	if (regflags & PMf_MULTILINE)
	    ret = regnode(MBOL);
	else if (regflags & PMf_SINGLELINE)
	    ret = regnode(SBOL);
d1536 1
a1536 1
	    ret = regnode(BOL);
d1539 2
d1542 4
a1545 4
	if (regflags & PMf_MULTILINE)
	    ret = regnode(MEOL);
	else if (regflags & PMf_SINGLELINE)
	    ret = regnode(SEOL);
d1547 1
a1547 1
	    ret = regnode(EOL);
d1551 2
a1552 2
	if (regflags & PMf_SINGLELINE)
	    ret = regnode(SANY);
d1554 2
a1555 2
	    ret = regnode(ANY);
	regnaughty++;
d1559 1
a1559 1
	regparse++;
d1571 1
a1571 1
	*flagp |= flags&(HASWIDTH|SPSTART);
d1579 1
a1579 1
	croak("internal urp in regexp at /%s/", regparse);
d1583 2
a1584 2
	if (!regcurly(regparse)) {
	    regparse++;
d1594 1
a1594 1
	switch (*++regparse) {
d1596 2
a1597 1
	    ret = regnode(SBOL);
d1602 2
a1603 1
	    ret = regnode(GPOS);
d1608 1
a1608 1
	    ret = regnode(SEOL);
d1612 6
d1619 1
a1619 1
	    ret = regnode((regflags & PMf_LOCALE) ? ALNUML : ALNUM);
d1624 1
a1624 1
	    ret = regnode((regflags & PMf_LOCALE) ? NALNUML : NALNUM);
d1629 2
a1630 1
	    ret = regnode((regflags & PMf_LOCALE) ? BOUNDL : BOUND);
d1635 2
a1636 1
	    ret = regnode((regflags & PMf_LOCALE) ? NBOUNDL : NBOUND);
d1641 1
a1641 1
	    ret = regnode((regflags & PMf_LOCALE) ? SPACEL : SPACE);
d1646 1
a1646 1
	    ret = regnode((regflags & PMf_LOCALE) ? NSPACEL : NSPACE);
d1651 1
a1651 1
	    ret = regnode(DIGIT);
d1656 1
a1656 1
	    ret = regnode(NDIGIT);
d1673 1
a1673 1
		I32 num = atoi(regparse);
d1675 1
a1675 1
		if (num > 9 && num >= regnpar)
d1678 5
a1682 3
		    regsawback = 1;
		    ret = reganode((regflags & PMf_FOLD)
				   ? ((regflags & PMf_LOCALE) ? REFFL : REFF)
d1685 3
a1687 3
		    while (isDIGIT(*regparse))
			regparse++;
		    regparse--;
d1693 1
a1693 1
	    if (regparse >= regxend)
d1702 3
a1704 3
	if (regflags & PMf_EXTENDED) {
	    while (regparse < regxend && *regparse != '\n') regparse++;
	    if (regparse < regxend)
d1711 1
a1711 1
	    register char ender;
d1713 1
a1713 1
	    char *oldp;
d1716 1
a1716 1
	    regparse++;
d1719 2
a1720 2
	    ret = regnode((regflags & PMf_FOLD)
			  ? ((regflags & PMf_LOCALE) ? EXACTFL : EXACTF)
d1722 4
a1725 3
	    regc(0);		/* save spot for len */
	    for (len = 0, p = regparse - 1;
	      len < 127 && p < regxend;
d1730 2
a1731 2
		if (regflags & PMf_EXTENDED)
		    p = regwhite(p, regxend);
d1746 1
d1793 1
a1793 1
			  (isDIGIT(p[1]) && atoi(p) >= regnpar) ) {
d1803 1
a1803 1
			if (p >= regxend)
d1815 2
a1816 2
		if (regflags & PMf_EXTENDED)
		    p = regwhite(p, regxend);
d1822 1
a1822 1
			regc(ender);
d1826 1
a1826 1
		regc(ender);
d1829 1
a1829 1
	    regparse = p - 1;
d1837 1
a1837 1
	    if (regcode != &regdummy)
d1839 6
a1844 1
	    regc('\0');
d1852 2
a1853 4
static char *
regwhite(p, e)
char *p;
char *e;
d1869 2
a1870 13
static void
regset(opnd, c)
char *opnd;
register I32 c;
{
    if (opnd == &regdummy)
	return;
    c &= 0xFF;
    opnd[1 + (c >> 3)] |= (1 << (c & 7));
}

static char *
regclass()
d1872 3
a1874 2
    register char *opnd;
    register I32 class;
d1877 1
a1877 1
    register char *ret;
d1881 8
a1888 8
    ret = regnode(ANYOF);
    opnd = regcode;
    for (class = 0; class < 33; class++)
	regc(0);
    if (*regparse == '^') {	/* Complement of range. */
	regnaughty++;
	regparse++;
	if (opnd != &regdummy)
d1891 3
a1893 2
    if (opnd != &regdummy) {
	if (regflags & PMf_FOLD)
d1895 1
a1895 1
	if (regflags & PMf_LOCALE)
d1897 2
d1900 1
a1900 1
    if (*regparse == ']' || *regparse == '-')
d1902 1
a1902 1
    while (regparse < regxend && *regparse != ']') {
d1904 28
a1931 4
	class = UCHARAT(regparse++);
	if (class == '\\') {
	    class = UCHARAT(regparse++);
	    switch (class) {
d1933 2
a1934 2
		if (regflags & PMf_LOCALE) {
		    if (opnd != &regdummy)
d1936 5
a1940 5
		}
		else {
		    for (class = 0; class < 256; class++)
			if (isALNUM(class))
			    regset(opnd, class);
d1945 2
a1946 2
		if (regflags & PMf_LOCALE) {
		    if (opnd != &regdummy)
d1948 5
a1952 5
		}
		else {
		    for (class = 0; class < 256; class++)
			if (!isALNUM(class))
			    regset(opnd, class);
d1957 2
a1958 2
		if (regflags & PMf_LOCALE) {
		    if (opnd != &regdummy)
d1960 5
a1964 5
		}
		else {
		    for (class = 0; class < 256; class++)
			if (isSPACE(class))
			    regset(opnd, class);
d1969 2
a1970 2
		if (regflags & PMf_LOCALE) {
		    if (opnd != &regdummy)
d1972 5
a1976 5
		}
		else {
		    for (class = 0; class < 256; class++)
			if (!isSPACE(class))
			    regset(opnd, class);
d1981 4
a1984 2
		for (class = '0'; class <= '9'; class++)
		    regset(opnd, class);
d1988 6
a1993 4
		for (class = 0; class < '0'; class++)
		    regset(opnd, class);
		for (class = '9' + 1; class < 256; class++)
		    regset(opnd, class);
d1997 1
a1997 1
		class = '\n';
d2000 1
a2000 1
		class = '\r';
d2003 1
a2003 1
		class = '\t';
d2006 1
a2006 1
		class = '\f';
d2009 1
a2009 1
		class = '\b';
d2012 1
a2012 1
		class = '\033';
d2015 1
a2015 1
		class = '\007';
d2018 2
a2019 2
		class = scan_hex(regparse, 2, &numlen);
		regparse += numlen;
d2022 2
a2023 2
		class = UCHARAT(regparse++);
		class = toCTRL(class);
d2027 2
a2028 2
		class = scan_oct(--regparse, 3, &numlen);
		regparse += numlen;
d2033 1
a2033 1
	    if (lastclass > class)
d2038 4
a2041 4
	    lastclass = class;
	    if (*regparse == '-' && regparse+1 < regxend &&
	      regparse[1] != ']') {
		regparse++;
d2046 21
a2066 3
	for ( ; lastclass <= class; lastclass++)
	    regset(opnd, lastclass);
	lastclass = class;
d2068 1
a2068 1
    if (*regparse != ']')
d2071 16
d2090 2
a2091 2
static char*
nextchar()
d2093 2
a2094 1
    char* retval = regparse++;
d2097 5
a2101 5
	if (*regparse == '(' && regparse[1] == '?' &&
		regparse[2] == '#') {
	    while (*regparse && *regparse != ')')
		regparse++;
	    regparse++;
d2104 3
a2106 3
	if (regflags & PMf_EXTENDED) {
	    if (isSPACE(*regparse)) {
		regparse++;
d2109 4
a2112 4
	    else if (*regparse == '#') {
		while (*regparse && *regparse != '\n')
		    regparse++;
		regparse++;
d2121 1
a2121 1
- regnode - emit a node
d2123 2
a2124 8
#ifdef CAN_PROTOTYPE
static char *			/* Location. */
regnode(char op)
#else
static char *			/* Location. */
regnode(op)
char op;
#endif
d2126 8
a2133 10
    register char *ret;
    register char *ptr;

    ret = regcode;
    if (ret == &regdummy) {
#ifdef REGALIGN
	if (!(regsize & 1))
	    regsize++;
#endif
	regsize += 3;
d2137 1
a2137 6
#ifdef REGALIGN
#ifndef lint
    if (!((long)ret & 1))
      *ret++ = 127;
#endif
#endif
d2139 2
a2140 4
    *ptr++ = op;
    *ptr++ = '\0';		/* Null "next" pointer. */
    *ptr++ = '\0';
    regcode = ptr;
d2148 2
a2149 9
#ifdef CAN_PROTOTYPE
static char *			/* Location. */
reganode(char op, unsigned short arg)
#else
static char *			/* Location. */
reganode(op, arg)
char op;
unsigned short arg;
#endif
d2151 8
a2158 10
    register char *ret;
    register char *ptr;

    ret = regcode;
    if (ret == &regdummy) {
#ifdef REGALIGN
	if (!(regsize & 1))
	    regsize++;
#endif
	regsize += 5;
d2162 1
a2162 6
#ifdef REGALIGN
#ifndef lint
    if (!((long)ret & 1))
      *ret++ = 127;
#endif
#endif
d2164 2
a2165 10
    *ptr++ = op;
    *ptr++ = '\0';		/* Null "next" pointer. */
    *ptr++ = '\0';
#ifdef REGALIGN
    *(unsigned short *)(ret+3) = arg;
#else
    ret[3] = arg >> 8; ret[4] = arg & 0377;
#endif
    ptr += 2;
    regcode = ptr;
d2173 2
a2174 8
#ifdef CAN_PROTOTYPE
static void
regc(char b)
#else
static void
regc(b)
char b;
#endif
d2176 3
a2178 4
    if (regcode != &regdummy)
	*regcode++ = b;
    else
	regsize++;
d2186 2
a2187 9
#ifdef CAN_PROTOTYPE
static void
reginsert(char op, char *opnd)
#else
static void
reginsert(op, opnd)
char op;
char *opnd;
#endif
d2189 10
a2198 11
    register char *src;
    register char *dst;
    register char *place;
    register int offset = (regkind[(U8)op] == CURLY ? 4 : 0);

    if (regcode == &regdummy) {
#ifdef REGALIGN
	regsize += 4 + offset;
#else
	regsize += 3 + offset;
#endif
d2202 3
a2204 7
    src = regcode;
#ifdef REGALIGN
    regcode += 4 + offset;
#else
    regcode += 3 + offset;
#endif
    dst = regcode;
d2206 1
a2206 1
	*--dst = *--src;
d2209 3
a2211 8
    *place++ = op;
    *place++ = '\0';
    *place++ = '\0';
    while (offset-- > 0)
	*place++ = '\0';
#ifdef REGALIGN
    *place++ = '\177';
#endif
d2215 1
a2215 1
- regtail - set the next-pointer at the end of a node chain
d2217 2
a2218 4
static void
regtail(p, val)
char *p;
char *val;
d2220 3
a2222 2
    register char *scan;
    register char *temp;
d2225 1
a2225 1
    if (p == &regdummy)
d2237 5
a2241 15
#ifdef REGALIGN
    offset = val - scan;
#ifndef lint
    *(short*)(scan+1) = offset;
#else
    offset = offset;
#endif
#else
    if (OP(scan) == BACK)
	offset = scan - val;
    else
	offset = val - scan;
    *(scan+1) = (offset>>8)&0377;
    *(scan+2) = offset&0377;
#endif
d2247 2
a2248 4
static void
regoptail(p, val)
char *p;
char *val;
d2250 1
d2252 7
a2258 1
    if (p == NULL || p == &regdummy || regkind[(U8)OP(p)] != BRANCH)
a2259 1
    regtail(NEXTOPER(p), val);
d2266 1
a2266 2
regcurly(s)
register char *s;
d2283 4
d2288 59
d2352 1
a2352 2
regdump(r)
regexp *r;
d2354 2
a2355 3
    register char *s;
    register char op = EXACT;	/* Arbitrary non-END op. */
    register char *next;
d2358 1
a2358 34
    s = r->program + 1;
    while (op != END) {	/* While that wasn't END last time... */
#ifdef REGALIGN
	if (!((long)s & 1))
	    s++;
#endif
	op = OP(s);
	/* where, what */
	regprop(sv, s);
	PerlIO_printf(Perl_debug_log, "%2ld%s", (long)(s - r->program), SvPVX(sv));
	next = regnext(s);
	s += regarglen[(U8)op];
	if (next == NULL)		/* Next ptr. */
	    PerlIO_printf(Perl_debug_log, "(0)");
	else 
	    PerlIO_printf(Perl_debug_log, "(%ld)", (long)(s-r->program)+(next-s));
	s += 3;
	if (op == ANYOF) {
	    s += 33;
	}
	if (regkind[(U8)op] == EXACT) {
	    /* Literal string, where present. */
	    s++;
	    (void)PerlIO_putc(Perl_debug_log, ' ');
	    (void)PerlIO_putc(Perl_debug_log, '<');
	    while (*s != '\0') {
		(void)PerlIO_putc(Perl_debug_log,*s);
		s++;
	    }
	    (void)PerlIO_putc(Perl_debug_log, '>');
	    s++;
	}
	(void)PerlIO_putc(Perl_debug_log, '\n');
    }
d2361 25
a2385 2
    if (r->regstart)
	PerlIO_printf(Perl_debug_log, "start `%s' ", SvPVX(r->regstart));
d2394 2
d2400 2
a2405 3
    if (r->regmust != NULL)
	PerlIO_printf(Perl_debug_log, "must have \"%s\" back %ld ", SvPVX(r->regmust),
	 (long) r->regback);
d2407 2
d2410 1
d2417 1
a2417 3
regprop(sv, op)
SV *sv;
char *op;
d2419 2
d2423 2
a2424 2
    sv_setpv(sv, ":");
    switch (OP(op)) {
d2437 3
d2459 1
a2459 1
	p = "EXACT";
d2462 1
a2462 1
	p = "EXACTF";
d2465 1
a2465 1
	p = "EXACTFL";
d2470 3
d2492 7
a2498 1
	sv_catpvf(sv, "CURLY {%d,%d}", ARG1(op), ARG2(op));
d2501 1
a2501 1
	sv_catpvf(sv, "CURLYX {%d,%d}", ARG1(op), ARG2(op));
d2504 1
a2504 1
	sv_catpvf(sv, "REF%d", ARG1(op));
d2507 1
a2507 1
	sv_catpvf(sv, "REFF%d", ARG1(op));
d2510 1
a2510 1
	sv_catpvf(sv, "REFFL%d", ARG1(op));
d2513 1
a2513 1
	sv_catpvf(sv, "OPEN%d", ARG1(op));
d2516 1
a2516 1
	sv_catpvf(sv, "CLOSE%d", ARG1(op));
d2532 1
a2532 1
	p = "UNLESSM";
d2535 1
a2535 1
	p = "IFMATCH";
d2573 27
d2605 1
a2606 1
#endif /* DEBUGGING */
d2609 1
a2609 2
pregfree(r)
struct regexp *r;
d2611 2
a2612 1
    if (!r)
d2614 1
a2614 1
    if (r->precomp) {
d2616 1
a2616 3
	r->precomp = Nullch;
    }
    if (r->subbase) {
d2618 25
a2642 9
	r->subbase = Nullch;
    }
    if (r->regmust) {
	SvREFCNT_dec(r->regmust);
	r->regmust = Nullsv;
    }
    if (r->regstart) {
	SvREFCNT_dec(r->regstart);
	r->regstart = Nullsv;
d2647 50
@


1.1
log
@Initial revision
@
text
@d46 1
a46 1
 ****    Copyright (c) 1991-1994, Larry Wall
d110 1
a110 1
static void regset _((char *, I32, I32));
d112 1
a135 1
    I32 fold = pm->op_pmflags & PMf_FOLD;
d149 7
d160 4
a164 1
    regflags = pm->op_pmflags;
a166 1
    regprecomp = savepvn(exp,xend-exp);
a167 1
    regsawback = 0;
d182 1
a182 1
    /* Allocate space. */
d186 3
d191 2
a192 3
    r->prelen = xend-exp;
    r->precomp = regprecomp;
    r->subbeg = r->subbase = NULL;
a193 1
    regparse = exp;
a201 1
    fold = pm->op_pmflags & PMf_FOLD;
d227 1
a227 1
	if (OP(first) == EXACTLY) {
d229 3
a231 4
	    if (SvCUR(r->regstart) > !(sawstudy|fold))
		fbm_compile(r->regstart,fold);
	    else
		sv_upgrade(r->regstart, SVt_PVBM);
d235 2
a236 1
	else if (OP(first) == BOUND || OP(first) == NBOUND)
d239 6
a244 1
	    r->reganch = ROPT_ANCH;
d246 1
a246 1
	  	goto again;
d253 1
a253 1
	    r->reganch = ROPT_ANCH | ROPT_IMPLICIT;
d255 1
a255 1
	  	goto again;
d260 2
a261 2
	DEBUG_r(fprintf(stderr,"first %d next %d offset %d\n",
	   OP(first), OP(NEXTOPER(first)), first - scan));
d296 1
a296 1
	    if (OP(scan) == EXACTLY) {
d300 1
a300 1
		while (OP(t = regnext(scan)) == CLOSE)
d302 1
a302 1
		minlen += *OPERAND(first);
d321 36
a356 1
		curback = -30000;
a362 5
		if (OP(scan) == PLUS && strchr(simple,OP(NEXTOPER(scan))))
		    minlen++;
		else if (regkind[(U8)OP(scan)] == CURLY &&
		  strchr(simple,OP(NEXTOPER(scan)+4)))
		    minlen += ARG1(scan);
d364 8
a371 3
	    else if (strchr(simple,OP(scan))) {
		curback++;
		minlen++;
a378 1
	    scan = regnext(scan);
d383 2
a384 2
	if (SvCUR(longish) + (regkind[(U8)OP(first)] == EOL) >
		SvCUR(longest))
d392 5
a396 9
	    &&
	    (!r->regstart
	     ||
	     !fbm_instr((unsigned char*) SvPVX(r->regstart),
		  (unsigned char *) SvPVX(r->regstart)
		    + SvCUR(r->regstart),
		  longest)
	    )
	   )
d402 3
a404 3
	    if (SvCUR(longest) > !(sawstudy || fold ||
			regkind[(U8)OP(first)]==EOL))
		fbm_compile(r->regmust,fold);
d407 1
a407 1
	    if (regkind[(U8)OP(first)] == EOL && SvCUR(longish))
a416 1
    r->do_folding = fold;
d460 1
a460 1
		croak("Sequence (?%c...) not implemented", paren);
d470 3
d475 1
a475 1
		while (*regparse && strchr("iogmsx", *regparse))
d703 4
d822 6
d831 1
a831 1
	FAIL("?+* follows nothing in regexp");
d841 1
a841 1
	    ret = regnode(GBOL);
d851 1
a851 1
	    ret = regnode(ALNUM);
d856 1
a856 1
	    ret = regnode(NALNUM);
d861 1
a861 1
	    ret = regnode(BOUND);
d866 1
a866 1
	    ret = regnode(NBOUND);
d871 1
a871 1
	    ret = regnode(SPACE);
d876 1
a876 1
	    ret = regnode(NSPACE);
d909 3
a911 1
		    ret = reganode(REF, num);
d947 3
a949 1
	    ret = regnode(EXACTLY);
d956 3
d1013 2
a1014 4
			ender = *p++;
			if (isLOWER(ender))
			    ender = toUPPER(ender);
			ender ^= 64;
a1036 12
		case '#':
		    if (regflags & PMf_EXTENDED) {
			while (p < regxend && *p != '\n') p++;
		    }
		    /* FALL THROUGH */
		case ' ': case '\t': case '\n': case '\r': case '\f': case '\v':
		    if (regflags & PMf_EXTENDED) {
			p++;
			len--;
			continue;
		    }
		    /* FALL THROUGH */
d1041 2
a1042 2
		if (regflags & PMf_FOLD && isUPPER(ender))
		    ender = toLOWER(ender);
d1073 19
d1093 2
a1094 3
regset(bits,def,c)
char *bits;
I32 def;
d1097 4
a1100 7
    if (regcode == &regdummy)
      return;
    c &= 255;
    if (def)
	bits[c >> 3] &= ~(1 << (c & 7));
    else
	bits[c >> 3] |=  (1 << (c & 7));
d1106 1
a1106 1
    register char *bits;
d1115 3
d1121 9
a1129 7
	def = 0;
    } else {
	def = 255;
    }
    bits = regcode;
    for (class = 0; class < 32; class++)
      regc(def);
d1139 9
a1147 3
		for (class = 0; class < 256; class++)
		  if (isALNUM(class))
		    regset(bits,def,class);
d1151 9
a1159 3
		for (class = 0; class < 256; class++)
		  if (!isALNUM(class))
		    regset(bits,def,class);
d1163 9
a1171 3
		for (class = 0; class < 256; class++)
		  if (isSPACE(class))
		    regset(bits,def,class);
d1175 9
a1183 3
		for (class = 0; class < 256; class++)
		  if (!isSPACE(class))
		    regset(bits,def,class);
d1188 1
a1188 1
		    regset(bits,def,class);
d1193 1
a1193 1
		    regset(bits,def,class);
d1195 1
a1195 1
		    regset(bits,def,class);
d1224 2
a1225 4
		class = *regparse++;
		if (isLOWER(class))
		  class = toUPPER(class);
		class ^= 64;
d1248 2
a1249 5
	for ( ; lastclass <= class; lastclass++) {
	    regset(bits,def,lastclass);
	    if (regflags & PMf_FOLD && isUPPER(lastclass))
		regset(bits,def,toLOWER(lastclass));
	}
d1522 1
a1522 1
 - regdump - dump a regexp onto stderr in vaguely comprehensible form
d1529 1
a1529 1
    register char op = EXACTLY;	/* Arbitrary non-END op. */
d1531 1
a1531 1

d1540 3
a1542 1
	fprintf(stderr,"%2d%s", s-r->program, regprop(s));	/* Where, what. */
d1546 1
a1546 1
	    fprintf(stderr,"(0)");
d1548 1
a1548 1
	    fprintf(stderr,"(%d)", (s-r->program)+(next-s));
d1551 1
a1551 1
	    s += 32;
d1553 1
a1553 1
	if (op == EXACTLY) {
d1556 2
a1557 2
	    (void)putc(' ', stderr);
	    (void)putc('<', stderr);
d1559 1
a1559 1
		(void)putc(*s, stderr);
d1562 1
a1562 1
	    (void)putc('>', stderr);
d1565 1
a1565 1
	(void)putc('\n', stderr);
d1570 13
a1582 5
	fprintf(stderr,"start `%s' ", SvPVX(r->regstart));
    if (r->regstclass)
	fprintf(stderr,"stclass `%s' ", regprop(r->regstclass));
    if (r->reganch & ROPT_ANCH)
	fprintf(stderr,"anchored ");
d1584 1
a1584 1
	fprintf(stderr,"plus ");
d1586 1
a1586 1
	fprintf(stderr,"implicit ");
d1588 1
a1588 1
	fprintf(stderr,"must have \"%s\" back %ld ", SvPVX(r->regmust),
d1590 2
a1591 2
    fprintf(stderr, "minlen %ld ", (long) r->minlen);
    fprintf(stderr,"\n");
d1597 3
a1599 2
char *
regprop(op)
d1604 1
a1604 2
    (void) strcpy(buf, ":");

d1636 8
a1643 2
    case EXACTLY:
	p = "EXACTLY";
a1653 6
    case ALNUM:
	p = "ALNUM";
	break;
    case NALNUM:
	p = "NALNUM";
	break;
d1657 3
d1663 2
a1664 11
    case SPACE:
	p = "SPACE";
	break;
    case NSPACE:
	p = "NSPACE";
	break;
    case DIGIT:
	p = "DIGIT";
	break;
    case NDIGIT:
	p = "NDIGIT";
d1667 1
a1667 2
	(void)sprintf(buf+strlen(buf), "CURLY {%d,%d}", ARG1(op),ARG2(op));
	p = NULL;
d1670 1
a1670 2
	(void)sprintf(buf+strlen(buf), "CURLYX {%d,%d}", ARG1(op),ARG2(op));
	p = NULL;
d1673 7
a1679 2
	(void)sprintf(buf+strlen(buf), "REF%d", ARG1(op));
	p = NULL;
d1682 1
a1682 2
	(void)sprintf(buf+strlen(buf), "OPEN%d", ARG1(op));
	p = NULL;
d1685 1
a1685 1
	(void)sprintf(buf+strlen(buf), "CLOSE%d", ARG1(op));
d1697 2
a1698 2
    case GBOL:
	p = "GBOL";
d1712 30
d1745 2
a1746 3
    if (p != NULL)
	(void) strcat(buf, p);
    return(buf);
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@a21 21
#ifdef PERL_EXT_RE_BUILD
/* need to replace pregcomp et al, so enable that */
#  ifndef PERL_IN_XSUB_RE
#    define PERL_IN_XSUB_RE
#  endif
/* need access to debugger hooks */
#  ifndef DEBUGGING
#    define DEBUGGING
#  endif
#endif

#ifdef PERL_IN_XSUB_RE
/* We *really* need to overwrite these symbols: */
#  define Perl_pregcomp my_regcomp
#  define Perl_regdump my_regdump
#  define Perl_regprop my_regprop
/* *These* symbols are masked to allow static link. */
#  define Perl_pregfree my_regfree
#  define Perl_regnext my_regnext
#endif 

d46 1
a46 1
 ****    Copyright (c) 1991-1999, Larry Wall
d58 1
a58 6

#ifndef PERL_IN_XSUB_RE
#  include "INTERN.h"
#endif

#define REG_COMP_C
a60 4
#ifdef op
#undef op
#endif /* op */

d90 1
a90 1
#define	HASWIDTH	0x1	/* Known to match non-null strings. */
d99 6
a104 7
#ifndef PERL_OBJECT
static regnode *reg _((I32, I32 *));
static regnode *reganode _((U8, U32));
static regnode *regatom _((I32 *));
static regnode *regbranch _((I32 *, I32));
static void regc _((U8, char *));
static regnode *regclass _((void));
d106 6
a111 6
static regnode *reg_node _((U8));
static regnode *regpiece _((I32 *));
static void reginsert _((U8, regnode *));
static void regoptail _((regnode *, regnode *));
static void regtail _((regnode *, regnode *));
static char* regwhite _((char *, char *));
a112 558
static void re_croak2 _((const char* pat1,const char* pat2,...)) __attribute__((noreturn));
#endif

/* Length of a variant. */

#ifndef PERL_OBJECT
typedef struct {
    I32 len_min;
    I32 len_delta;
    I32 pos_min;
    I32 pos_delta;
    SV *last_found;
    I32 last_end;			/* min value, <0 unless valid. */
    I32 last_start_min;
    I32 last_start_max;
    SV **longest;			/* Either &l_fixed, or &l_float. */
    SV *longest_fixed;
    I32 offset_fixed;
    SV *longest_float;
    I32 offset_float_min;
    I32 offset_float_max;
    I32 flags;
} scan_data_t;
#endif

static scan_data_t zero_scan_data = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

#define SF_BEFORE_EOL		(SF_BEFORE_SEOL|SF_BEFORE_MEOL)
#define SF_BEFORE_SEOL		0x1
#define SF_BEFORE_MEOL		0x2
#define SF_FIX_BEFORE_EOL	(SF_FIX_BEFORE_SEOL|SF_FIX_BEFORE_MEOL)
#define SF_FL_BEFORE_EOL	(SF_FL_BEFORE_SEOL|SF_FL_BEFORE_MEOL)

#ifdef NO_UNARY_PLUS
#  define SF_FIX_SHIFT_EOL	(0+2)
#  define SF_FL_SHIFT_EOL		(0+4)
#else
#  define SF_FIX_SHIFT_EOL	(+2)
#  define SF_FL_SHIFT_EOL		(+4)
#endif

#define SF_FIX_BEFORE_SEOL	(SF_BEFORE_SEOL << SF_FIX_SHIFT_EOL)
#define SF_FIX_BEFORE_MEOL	(SF_BEFORE_MEOL << SF_FIX_SHIFT_EOL)

#define SF_FL_BEFORE_SEOL	(SF_BEFORE_SEOL << SF_FL_SHIFT_EOL)
#define SF_FL_BEFORE_MEOL	(SF_BEFORE_MEOL << SF_FL_SHIFT_EOL) /* 0x20 */
#define SF_IS_INF		0x40
#define SF_HAS_PAR		0x80
#define SF_IN_PAR		0x100
#define SF_HAS_EVAL		0x200
#define SCF_DO_SUBSTR		0x400

STATIC void
scan_commit(scan_data_t *data)
{
    STRLEN l = SvCUR(data->last_found);
    STRLEN old_l = SvCUR(*data->longest);
    
    if ((l >= old_l) && ((l > old_l) || (data->flags & SF_BEFORE_EOL))) {
	sv_setsv(*data->longest, data->last_found);
	if (*data->longest == data->longest_fixed) {
	    data->offset_fixed = l ? data->last_start_min : data->pos_min;
	    if (data->flags & SF_BEFORE_EOL)
		data->flags 
		    |= ((data->flags & SF_BEFORE_EOL) << SF_FIX_SHIFT_EOL);
	    else
		data->flags &= ~SF_FIX_BEFORE_EOL;
	} else {
	    data->offset_float_min = l ? data->last_start_min : data->pos_min;
	    data->offset_float_max = (l 
				      ? data->last_start_max 
				      : data->pos_min + data->pos_delta);
	    if (data->flags & SF_BEFORE_EOL)
		data->flags 
		    |= ((data->flags & SF_BEFORE_EOL) << SF_FL_SHIFT_EOL);
	    else
		data->flags &= ~SF_FL_BEFORE_EOL;
	}
    }
    SvCUR_set(data->last_found, 0);
    data->last_end = -1;
    data->flags &= ~SF_BEFORE_EOL;
}

/* Stops at toplevel WHILEM as well as at `last'. At end *scanp is set
   to the position after last scanned or to NULL. */

STATIC I32
study_chunk(regnode **scanp, I32 *deltap, regnode *last, scan_data_t *data, U32 flags)
			/* scanp: Start here (read-write). */
			/* deltap: Write maxlen-minlen here. */
			/* last: Stop before this one. */
{
    dTHR;
    I32 min = 0, pars = 0, code;
    regnode *scan = *scanp, *next;
    I32 delta = 0;
    int is_inf = (flags & SCF_DO_SUBSTR) && (data->flags & SF_IS_INF);
    int is_inf_internal = 0;		/* The studied chunk is infinite */
    I32 is_par = OP(scan) == OPEN ? ARG(scan) : 0;
    scan_data_t data_fake;
    
    while (scan && OP(scan) != END && scan < last) {
	/* Peephole optimizer: */

	if (regkind[(U8)OP(scan)] == EXACT) {
	    regnode *n = regnext(scan);
	    U32 stringok = 1;
#ifdef DEBUGGING
	    regnode *stop = scan;
#endif 

	    next = scan + (*OPERAND(scan) + 2 - 1)/sizeof(regnode) + 2;
	    /* Skip NOTHING, merge EXACT*. */
	    while (n &&
		   ( regkind[(U8)OP(n)] == NOTHING || 
		     (stringok && (OP(n) == OP(scan))))
		   && NEXT_OFF(n)
		   && NEXT_OFF(scan) + NEXT_OFF(n) < I16_MAX) {
		if (OP(n) == TAIL || n > next)
		    stringok = 0;
		if (regkind[(U8)OP(n)] == NOTHING) {
		    NEXT_OFF(scan) += NEXT_OFF(n);
		    next = n + NODE_STEP_REGNODE;
#ifdef DEBUGGING
		    if (stringok)
			stop = n;
#endif 
		    n = regnext(n);
		} else {
		    int oldl = *OPERAND(scan);
		    regnode *nnext = regnext(n);
		    
		    if (oldl + *OPERAND(n) > U8_MAX) 
			break;
		    NEXT_OFF(scan) += NEXT_OFF(n);
		    *OPERAND(scan) += *OPERAND(n);
		    next = n + (*OPERAND(n) + 2 - 1)/sizeof(regnode) + 2;
		    /* Now we can overwrite *n : */
		    Move(OPERAND(n) + 1, OPERAND(scan) + oldl + 1,
			 *OPERAND(n) + 1, char);
#ifdef DEBUGGING
		    if (stringok)
			stop = next - 1;
#endif 
		    n = nnext;
		}
	    }
#ifdef DEBUGGING
	    /* Allow dumping */
	    n = scan + (*OPERAND(scan) + 2 - 1)/sizeof(regnode) + 2;
	    while (n <= stop) {
		/* Purify reports a benign UMR here sometimes, because we
		 * don't initialize the OP() slot of a node when that node
		 * is occupied by just the trailing null of the string in
		 * an EXACT node */
		if (regkind[(U8)OP(n)] != NOTHING || OP(n) == NOTHING) {
		    OP(n) = OPTIMIZED;
		    NEXT_OFF(n) = 0;
		}
		n++;
	    }
#endif 

	}
	if (OP(scan) != CURLYX) {
	    int max = (reg_off_by_arg[OP(scan)]
		       ? I32_MAX
		       /* I32 may be smaller than U16 on CRAYs! */
		       : (I32_MAX < U16_MAX ? I32_MAX : U16_MAX));
	    int off = (reg_off_by_arg[OP(scan)] ? ARG(scan) : NEXT_OFF(scan));
	    int noff;
	    regnode *n = scan;
	    
	    /* Skip NOTHING and LONGJMP. */
	    while ((n = regnext(n))
		   && ((regkind[(U8)OP(n)] == NOTHING && (noff = NEXT_OFF(n)))
		       || ((OP(n) == LONGJMP) && (noff = ARG(n))))
		   && off + noff < max)
		off += noff;
	    if (reg_off_by_arg[OP(scan)])
		ARG(scan) = off;
	    else 
		NEXT_OFF(scan) = off;
	}
	if (OP(scan) == BRANCH || OP(scan) == BRANCHJ 
		   || OP(scan) == IFTHEN || OP(scan) == SUSPEND) {
	    next = regnext(scan);
	    code = OP(scan);
	    
	    if (OP(next) == code || code == IFTHEN || code == SUSPEND) { 
		I32 max1 = 0, min1 = I32_MAX, num = 0;
		
		if (flags & SCF_DO_SUBSTR)
		    scan_commit(data);
		while (OP(scan) == code) {
		    I32 deltanext, minnext;

		    num++;
		    data_fake.flags = 0;
		    next = regnext(scan);
		    scan = NEXTOPER(scan);
		    if (code != BRANCH)
			scan = NEXTOPER(scan);
		    /* We suppose the run is continuous, last=next...*/
		    minnext = study_chunk(&scan, &deltanext, next,
					  &data_fake, 0);
		    if (min1 > minnext) 
			min1 = minnext;
		    if (max1 < minnext + deltanext)
			max1 = minnext + deltanext;
		    if (deltanext == I32_MAX)
			is_inf = is_inf_internal = 1;
		    scan = next;
		    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))
			pars++;
		    if (data && (data_fake.flags & SF_HAS_EVAL))
			data->flags |= SF_HAS_EVAL;
		    if (code == SUSPEND) 
			break;
		}
		if (code == IFTHEN && num < 2) /* Empty ELSE branch */
		    min1 = 0;
		if (flags & SCF_DO_SUBSTR) {
		    data->pos_min += min1;
		    data->pos_delta += max1 - min1;
		    if (max1 != min1 || is_inf)
			data->longest = &(data->longest_float);
		}
		min += min1;
		delta += max1 - min1;
	    } else if (code == BRANCHJ)	/* single branch is optimized. */
		scan = NEXTOPER(NEXTOPER(scan));
	    else			/* single branch is optimized. */
		scan = NEXTOPER(scan);
	    continue;
	} else if (OP(scan) == EXACT) {
	    min += *OPERAND(scan);
	    if (flags & SCF_DO_SUBSTR) { /* Update longest substr. */
		I32 l = *OPERAND(scan);

		/* The code below prefers earlier match for fixed
		   offset, later match for variable offset.  */
		if (data->last_end == -1) { /* Update the start info. */
		    data->last_start_min = data->pos_min;
 		    data->last_start_max = is_inf
 			? I32_MAX : data->pos_min + data->pos_delta; 
		}
		sv_catpvn(data->last_found, (char *)(OPERAND(scan)+1), l);
		data->last_end = data->pos_min + l;
		data->pos_min += l; /* As in the first entry. */
		data->flags &= ~SF_BEFORE_EOL;
	    }
	} else if (regkind[(U8)OP(scan)] == EXACT) {
	    if (flags & SCF_DO_SUBSTR) 
		scan_commit(data);
	    min += *OPERAND(scan);
	    if (data && (flags & SCF_DO_SUBSTR))
		data->pos_min += *OPERAND(scan);
	} else if (strchr(varies,OP(scan))) {
	    I32 mincount, maxcount, minnext, deltanext, pos_before, fl;
	    regnode *oscan = scan;
	    
	    switch (regkind[(U8)OP(scan)]) {
	    case WHILEM:
		scan = NEXTOPER(scan);
		goto finish;
	    case PLUS:
		if (flags & SCF_DO_SUBSTR) {
		    next = NEXTOPER(scan);
		    if (OP(next) == EXACT) {
			mincount = 1; 
			maxcount = REG_INFTY; 
			next = regnext(scan);
			scan = NEXTOPER(scan);
			goto do_curly;
		    }
		}
		if (flags & SCF_DO_SUBSTR)
		    data->pos_min++;
		min++;
		/* Fall through. */
	    case STAR:
		is_inf = is_inf_internal = 1; 
		scan = regnext(scan);
		if (flags & SCF_DO_SUBSTR) {
		    scan_commit(data);
		    data->longest = &(data->longest_float);
		}
		goto optimize_curly_tail;
	    case CURLY:
		mincount = ARG1(scan); 
		maxcount = ARG2(scan);
		next = regnext(scan);
		scan = NEXTOPER(scan) + EXTRA_STEP_2ARGS;
	      do_curly:
		if (flags & SCF_DO_SUBSTR) {
		    if (mincount == 0) scan_commit(data);
		    pos_before = data->pos_min;
		}
		if (data) {
		    fl = data->flags;
		    data->flags &= ~(SF_HAS_PAR|SF_IN_PAR|SF_HAS_EVAL);
		    if (is_inf)
			data->flags |= SF_IS_INF;
		}
		/* This will finish on WHILEM, setting scan, or on NULL: */
		minnext = study_chunk(&scan, &deltanext, last, data, 
				      mincount == 0 
					? (flags & ~SCF_DO_SUBSTR) : flags);
		if (!scan) 		/* It was not CURLYX, but CURLY. */
		    scan = next;
		if (PL_dowarn && (minnext + deltanext == 0) 
		    && !(data->flags & (SF_HAS_PAR|SF_IN_PAR))
		    && maxcount <= 10000) /* Complement check for big count */
		    warn("Strange *+?{} on zero-length expression");
		min += minnext * mincount;
		is_inf_internal |= (maxcount == REG_INFTY 
				    && (minnext + deltanext) > 0
				   || deltanext == I32_MAX);
		is_inf |= is_inf_internal;
		delta += (minnext + deltanext) * maxcount - minnext * mincount;

		/* Try powerful optimization CURLYX => CURLYN. */
		if (  OP(oscan) == CURLYX && data 
		      && data->flags & SF_IN_PAR
		      && !(data->flags & SF_HAS_EVAL)
		      && !deltanext && minnext == 1 ) {
		    /* Try to optimize to CURLYN.  */
		    regnode *nxt = NEXTOPER(oscan) + EXTRA_STEP_2ARGS;
		    regnode *nxt1 = nxt, *nxt2;

		    /* Skip open. */
		    nxt = regnext(nxt);
		    if (!strchr(simple,OP(nxt))
			&& !(regkind[(U8)OP(nxt)] == EXACT
			     && *OPERAND(nxt) == 1)) 
			goto nogo;
		    nxt2 = nxt;
		    nxt = regnext(nxt);
		    if (OP(nxt) != CLOSE) 
			goto nogo;
		    /* Now we know that nxt2 is the only contents: */
		    oscan->flags = ARG(nxt);
		    OP(oscan) = CURLYN;
		    OP(nxt1) = NOTHING;	/* was OPEN. */
#ifdef DEBUGGING
		    OP(nxt1 + 1) = OPTIMIZED; /* was count. */
		    NEXT_OFF(nxt1+ 1) = 0; /* just for consistancy. */
		    NEXT_OFF(nxt2) = 0;	/* just for consistancy with CURLY. */
		    OP(nxt) = OPTIMIZED;	/* was CLOSE. */
		    OP(nxt + 1) = OPTIMIZED; /* was count. */
		    NEXT_OFF(nxt+ 1) = 0; /* just for consistancy. */
#endif 
		}
	      nogo:

		/* Try optimization CURLYX => CURLYM. */
		if (  OP(oscan) == CURLYX && data 
		      && !(data->flags & SF_HAS_PAR)
		      && !(data->flags & SF_HAS_EVAL)
		      && !deltanext  ) {
		    /* XXXX How to optimize if data == 0? */
		    /* Optimize to a simpler form.  */
		    regnode *nxt = NEXTOPER(oscan) + EXTRA_STEP_2ARGS; /* OPEN */
		    regnode *nxt2;

		    OP(oscan) = CURLYM;
		    while ( (nxt2 = regnext(nxt)) /* skip over embedded stuff*/
			    && (OP(nxt2) != WHILEM)) 
			nxt = nxt2;
		    OP(nxt2)  = SUCCEED; /* Whas WHILEM */
		    /* Need to optimize away parenths. */
		    if (data->flags & SF_IN_PAR) {
			/* Set the parenth number.  */
			regnode *nxt1 = NEXTOPER(oscan) + EXTRA_STEP_2ARGS; /* OPEN*/

			if (OP(nxt) != CLOSE) 
			    FAIL("panic opt close");
			oscan->flags = ARG(nxt);
			OP(nxt1) = OPTIMIZED;	/* was OPEN. */
			OP(nxt) = OPTIMIZED;	/* was CLOSE. */
#ifdef DEBUGGING
			OP(nxt1 + 1) = OPTIMIZED; /* was count. */
			OP(nxt + 1) = OPTIMIZED; /* was count. */
			NEXT_OFF(nxt1 + 1) = 0; /* just for consistancy. */
			NEXT_OFF(nxt + 1) = 0; /* just for consistancy. */
#endif 
#if 0
			while ( nxt1 && (OP(nxt1) != WHILEM)) {
			    regnode *nnxt = regnext(nxt1);
			    
			    if (nnxt == nxt) {
				if (reg_off_by_arg[OP(nxt1)])
				    ARG_SET(nxt1, nxt2 - nxt1);
				else if (nxt2 - nxt1 < U16_MAX)
				    NEXT_OFF(nxt1) = nxt2 - nxt1;
				else
				    OP(nxt) = NOTHING;	/* Cannot beautify */
			    }
			    nxt1 = nnxt;
			}
#endif
			/* Optimize again: */
			study_chunk(&nxt1, &deltanext, nxt, NULL, 0);
		    } else
			oscan->flags = 0;
		}
		if (data && fl & (SF_HAS_PAR|SF_IN_PAR)) 
		    pars++;
		if (flags & SCF_DO_SUBSTR) {
		    SV *last_str = Nullsv;
		    int counted = mincount != 0;

		    if (data->last_end > 0 && mincount != 0) { /* Ends with a string. */
			I32 b = pos_before >= data->last_start_min 
			    ? pos_before : data->last_start_min;
			STRLEN l;
			char *s = SvPV(data->last_found, l);
			
			l -= b - data->last_start_min;
			/* Get the added string: */
			last_str = newSVpv(s  +  b - data->last_start_min, l);
			if (deltanext == 0 && pos_before == b) {
			    /* What was added is a constant string */
			    if (mincount > 1) {
				SvGROW(last_str, (mincount * l) + 1);
				repeatcpy(SvPVX(last_str) + l, 
					  SvPVX(last_str), l, mincount - 1);
				SvCUR(last_str) *= mincount;
				/* Add additional parts. */
				SvCUR_set(data->last_found, 
					  SvCUR(data->last_found) - l);
				sv_catsv(data->last_found, last_str);
				data->last_end += l * (mincount - 1);
			    }
			}
		    }
		    /* It is counted once already... */
		    data->pos_min += minnext * (mincount - counted);
		    data->pos_delta += - counted * deltanext +
			(minnext + deltanext) * maxcount - minnext * mincount;
		    if (mincount != maxcount) {
			scan_commit(data);
			if (mincount && last_str) {
			    sv_setsv(data->last_found, last_str);
			    data->last_end = data->pos_min;
			    data->last_start_min = 
				data->pos_min - SvCUR(last_str);
			    data->last_start_max = is_inf 
				? I32_MAX 
				: data->pos_min + data->pos_delta
				- SvCUR(last_str);
			}
			data->longest = &(data->longest_float);
		    }
		    SvREFCNT_dec(last_str);
		}
		if (data && (fl & SF_HAS_EVAL))
		    data->flags |= SF_HAS_EVAL;
	      optimize_curly_tail:
		if (OP(oscan) != CURLYX) {
		    while (regkind[(U8)OP(next = regnext(oscan))] == NOTHING
			   && NEXT_OFF(next))
			NEXT_OFF(oscan) += NEXT_OFF(next);
		}
		continue;
	    default:			/* REF only? */
		if (flags & SCF_DO_SUBSTR) {
		    scan_commit(data);
		    data->longest = &(data->longest_float);
		}
		is_inf = is_inf_internal = 1;
		break;
	    }
	} else if (strchr(simple,OP(scan))) {
	    if (flags & SCF_DO_SUBSTR) {
		scan_commit(data);
		data->pos_min++;
	    }
	    min++;
	} else if (regkind[(U8)OP(scan)] == EOL && flags & SCF_DO_SUBSTR) {
	    data->flags |= (OP(scan) == MEOL
			    ? SF_BEFORE_MEOL
			    : SF_BEFORE_SEOL);
	} else if (regkind[(U8)OP(scan)] == BRANCHJ
		   && (scan->flags || data)
		   && (OP(scan) == IFMATCH || OP(scan) == UNLESSM)) {
	    I32 deltanext, minnext;
	    regnode *nscan;

	    data_fake.flags = 0;
	    next = regnext(scan);
	    nscan = NEXTOPER(NEXTOPER(scan));
	    minnext = study_chunk(&nscan, &deltanext, last, &data_fake, 0);
	    if (scan->flags) {
		if (deltanext) {
		    FAIL("variable length lookbehind not implemented");
		} else if (minnext > U8_MAX) {
		    FAIL2("lookbehind longer than %d not implemented", U8_MAX);
		}
		scan->flags = minnext;
	    }
	    if (data && data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))
		pars++;
	    if (data && (data_fake.flags & SF_HAS_EVAL))
		data->flags |= SF_HAS_EVAL;
	} else if (OP(scan) == OPEN) {
	    pars++;
	} else if (OP(scan) == CLOSE && ARG(scan) == is_par) {
	    next = regnext(scan);

	    if ( next && (OP(next) != WHILEM) && next < last)
		is_par = 0;		/* Disable optimization */
	} else if (OP(scan) == EVAL) {
		if (data)
		    data->flags |= SF_HAS_EVAL;
	}
	/* Else: zero-length, ignore. */
	scan = regnext(scan);
    }

  finish:
    *scanp = scan;
    *deltap = is_inf_internal ? I32_MAX : delta;
    if (flags & SCF_DO_SUBSTR && is_inf) 
	data->pos_delta = I32_MAX - data->pos_min;
    if (is_par > U8_MAX)
	is_par = 0;
    if (is_par && pars==1 && data) {
	data->flags |= SF_IN_PAR;
	data->flags &= ~SF_HAS_PAR;
    } else if (pars && data) {
	data->flags |= SF_HAS_PAR;
	data->flags &= ~SF_IN_PAR;
    }
    return min;
}

STATIC I32
add_data(I32 n, char *s)
{
    dTHR;
    if (PL_regcomp_rx->data) {
	Renewc(PL_regcomp_rx->data, 
	       sizeof(*PL_regcomp_rx->data) + sizeof(void*) * (PL_regcomp_rx->data->count + n - 1), 
	       char, struct reg_data);
	Renew(PL_regcomp_rx->data->what, PL_regcomp_rx->data->count + n, U8);
	PL_regcomp_rx->data->count += n;
    } else {
	Newc(1207, PL_regcomp_rx->data, sizeof(*PL_regcomp_rx->data) + sizeof(void*) * (n - 1),
	     char, struct reg_data);
	New(1208, PL_regcomp_rx->data->what, n, U8);
	PL_regcomp_rx->data->count = n;
    }
    Copy(s, PL_regcomp_rx->data->what + PL_regcomp_rx->data->count - n, n, U8);
    return PL_regcomp_rx->data->count - n;
}
d130 4
a133 1
pregcomp(char *exp, char *xend, PMOP *pm)
d135 1
a135 1
    dTHR;
d137 5
a141 5
    regnode *scan;
    SV **longest;
    SV *longest_fixed;
    SV *longest_float;
    regnode *first;
d143 3
d151 1
a151 12
	FAIL("NULL regexp argument");

    PL_regprecomp = savepvn(exp, xend - exp);
    DEBUG_r(PerlIO_printf(Perl_debug_log, "compiling RE `%*s'\n",
			  xend - exp, PL_regprecomp));
    PL_regflags = pm->op_pmflags;
    PL_regsawback = 0;

    PL_regseen = 0;
    PL_seen_zerolen = *exp == '^' ? -1 : 0;
    PL_seen_evals = 0;
    PL_extralen = 0;
d154 10
a163 7
    PL_regcomp_parse = exp;
    PL_regxend = xend;
    PL_regnaughty = 0;
    PL_regnpar = 1;
    PL_regsize = 0L;
    PL_regcode = &PL_regdummy;
    regc((U8)MAGIC, (char*)PL_regcode);
d165 2
a166 2
	Safefree(PL_regprecomp);
	PL_regprecomp = Nullch;
a168 1
    DEBUG_r(PerlIO_printf(Perl_debug_log, "size %d ", PL_regsize));
d170 3
a172 31
    DEBUG_r(
	if (!PL_colorset) {
	    int i = 0;
	    char *s = PerlEnv_getenv("TERMCAP_COLORS");
	    
	    PL_colorset = 1;
	    if (s) {
		PL_colors[0] = s = savepv(s);
		while (++i < 4) {
		    s = strchr(s, '\t');
		    if (!s) 
			FAIL("Not enough TABs in TERMCAP_COLORS");
		    *s = '\0';
		    PL_colors[i] = ++s;
		}
	    } else {
		while (i < 4) 
		    PL_colors[i++] = "";
	    }
	    /* Reset colors: */
	    PerlIO_printf(Perl_debug_log, "%s%s%s%s", 
			  PL_colors[0],PL_colors[1],PL_colors[2],PL_colors[3]);
	}
	);

    /* Small enough for pointer-storage convention?
       If extralen==0, this means that we will not need long jumps. */
    if (PL_regsize >= 0x10000L && PL_extralen)
        PL_regsize += PL_extralen;
    else
	PL_extralen = 0;
d174 2
a175 3
    /* Allocate space and initialize. */
    Newc(1001, r, sizeof(regexp) + (unsigned)PL_regsize * sizeof(regnode),
	 char, regexp);
a177 6
    r->refcnt = 1;
    r->prelen = xend - exp;
    r->precomp = PL_regprecomp;
    r->subbeg = r->subbase = NULL;
    r->nparens = PL_regnpar - 1;		/* set early to validate backrefs */
    PL_regcomp_rx = r;
d180 8
a187 9
    PL_regcomp_parse = exp;
    PL_regxend = xend;
    PL_regnaughty = 0;
    PL_regnpar = 1;
    PL_regcode = r->program;
    /* Store the count of eval-groups for security checks: */
    PL_regcode->next_off = ((PL_seen_evals > U16_MAX) ? U16_MAX : PL_seen_evals);
    regc((U8)MAGIC, (char*) PL_regcode++);
    r->data = 0;
d192 11
a202 14
    r->reganch = pm->op_pmflags & PMf_COMPILETIME;
    pm->op_pmflags = PL_regflags;
    r->regstclass = NULL;
    r->naughty = PL_regnaughty >= 10;	/* Probably an expensive pattern. */
    scan = r->program + 1;		/* First BRANCH. */

    /* XXXX To minimize changes to RE engine we always allocate
       3-units-long substrs field. */
    Newz(1004, r->substrs, 1, struct reg_substr_data);

    if (OP(scan) != BRANCH) {	/* Only one top-level choice. */
	scan_data_t data;
	I32 fake;
	STRLEN longest_float_length, longest_fixed_length;
a203 1
	StructCopy(&zero_scan_data, &data, scan_data_t);
a204 1
	/* Skip introductions and multiplicators >= 1. */
d219 7
a225 1
	if (OP(first) == EXACT);	/* Empty, get anchored substr later. */
d228 1
a228 2
	else if (regkind[(U8)OP(first)] == BOUND ||
		 regkind[(U8)OP(first)] == NBOUND)
d231 1
a231 6
	    r->reganch |= (OP(first) == MBOL ? ROPT_ANCH_MBOL: ROPT_ANCH_BOL);
	    first = NEXTOPER(first);
	    goto again;
	}
	else if (OP(first) == GPOS) {
	    r->reganch |= ROPT_ANCH_GPOS;
d233 1
a233 1
	    goto again;
d240 1
a240 1
	    r->reganch |= ROPT_ANCH_BOL | ROPT_IMPLICIT;
d242 1
a242 1
	    goto again;
d244 1
a244 1
	if (sawplus && (!sawopen || !PL_regsawback))
d247 2
a248 3
	/* Scan is after the zeroth branch, first is atomic matcher. */
	DEBUG_r(PerlIO_printf(Perl_debug_log, "first at %d\n", 
			      first - scan + 1));
d257 1
a257 1
	* it happens that c_offset_min has been invalidated, since the
d260 3
d264 71
d336 34
a369 71
	data.longest_fixed = newSVpv("",0);
	data.longest_float = newSVpv("",0);
	data.last_found = newSVpv("",0);
	data.longest = &(data.longest_fixed);
	first = scan;
	
	minlen = study_chunk(&first, &fake, scan + PL_regsize, /* Up to end */
			     &data, SCF_DO_SUBSTR);
	if ( PL_regnpar == 1 && data.longest == &(data.longest_fixed)
	     && data.last_start_min == 0 && data.last_end > 0 
	     && !PL_seen_zerolen
	     && (!(PL_regseen & REG_SEEN_GPOS) || (r->reganch & ROPT_ANCH_GPOS)))
	    r->reganch |= ROPT_CHECK_ALL;
	scan_commit(&data);
	SvREFCNT_dec(data.last_found);

	longest_float_length = SvCUR(data.longest_float);
	if (longest_float_length
	    || (data.flags & SF_FL_BEFORE_EOL
		&& (!(data.flags & SF_FL_BEFORE_MEOL)
		    || (PL_regflags & PMf_MULTILINE)))) {
	    if (SvCUR(data.longest_fixed) 
		&& data.offset_fixed == data.offset_float_min
		&& SvCUR(data.longest_fixed) == SvCUR(data.longest_float))
		goto remove_float;		/* Like in (a)+. */
	    
	    r->float_substr = data.longest_float;
	    r->float_min_offset = data.offset_float_min;
	    r->float_max_offset = data.offset_float_max;
	    fbm_compile(r->float_substr, 0);
	    BmUSEFUL(r->float_substr) = 100;
	    if (data.flags & SF_FL_BEFORE_EOL /* Cannot have SEOL and MULTI */
		&& (!(data.flags & SF_FL_BEFORE_MEOL)
		    || (PL_regflags & PMf_MULTILINE))) 
		SvTAIL_on(r->float_substr);
	} else {
	  remove_float:
	    r->float_substr = Nullsv;
	    SvREFCNT_dec(data.longest_float);
	    longest_float_length = 0;
	}

	longest_fixed_length = SvCUR(data.longest_fixed);
	if (longest_fixed_length
	    || (data.flags & SF_FIX_BEFORE_EOL /* Cannot have SEOL and MULTI */
		&& (!(data.flags & SF_FIX_BEFORE_MEOL)
		    || (PL_regflags & PMf_MULTILINE)))) {
	    r->anchored_substr = data.longest_fixed;
	    r->anchored_offset = data.offset_fixed;
	    fbm_compile(r->anchored_substr, 0);
	    BmUSEFUL(r->anchored_substr) = 100;
	    if (data.flags & SF_FIX_BEFORE_EOL /* Cannot have SEOL and MULTI */
		&& (!(data.flags & SF_FIX_BEFORE_MEOL)
		    || (PL_regflags & PMf_MULTILINE)))
		SvTAIL_on(r->anchored_substr);
	} else {
	    r->anchored_substr = Nullsv;
	    SvREFCNT_dec(data.longest_fixed);
	    longest_fixed_length = 0;
	}

	/* A temporary algorithm prefers floated substr to fixed one to dig more info. */
	if (longest_fixed_length > longest_float_length) {
	    r->check_substr = r->anchored_substr;
	    r->check_offset_min = r->check_offset_max = r->anchored_offset;
	    if (r->reganch & ROPT_ANCH_SINGLE)
		r->reganch |= ROPT_NOSCAN;
	} else {
	    r->check_substr = r->float_substr;
	    r->check_offset_min = data.offset_float_min;
	    r->check_offset_max = data.offset_float_max;
d371 1
a371 8
    } else {
	/* Several toplevels. Best we can is to set minlen. */
	I32 fake;
	
	DEBUG_r(PerlIO_printf(Perl_debug_log, "\n"));
	scan = r->program + 1;
	minlen = study_chunk(&scan, &fake, scan + PL_regsize, NULL, 0);
	r->check_substr = r->anchored_substr = r->float_substr = Nullsv;
d374 2
d377 2
a378 8
    if (PL_regseen & REG_SEEN_GPOS) 
	r->reganch |= ROPT_GPOS_SEEN;
    if (PL_regseen & REG_SEEN_LOOKBEHIND)
	r->reganch |= ROPT_LOOKBEHIND_SEEN;
    if (PL_regseen & REG_SEEN_EVAL)
	r->reganch |= ROPT_EVAL_SEEN;
    Newz(1002, r->startp, PL_regnpar, char*);
    Newz(1002, r->endp, PL_regnpar, char*);
d392 8
a399 9
STATIC regnode *
reg(I32 paren, I32 *flagp)
    /* paren: Parenthesized? 0=top, 1=(, inside: changed to letter. */
{
    dTHR;
    register regnode *ret;		/* Will be the head of the group. */
    register regnode *br;
    register regnode *lastbr;
    register regnode *ender = 0;
d401 1
a401 2
    I32 flags, oregflags = PL_regflags, have_branch = 0, open = 0;
    char c;
d403 1
a403 1
    *flagp = 0;				/* Tentatively. */
d407 4
a410 7
	if (*PL_regcomp_parse == '?') {
	    U16 posflags = 0, negflags = 0;
	    U16 *flagsp = &posflags;

	    PL_regcomp_parse++;
	    paren = *PL_regcomp_parse++;
	    ret = NULL;			/* For look-ahead/behind. */
d412 1
a412 7
	    case '<':
		PL_regseen |= REG_SEEN_LOOKBEHIND;
		if (*PL_regcomp_parse == '!') 
		    paren = ',';
		if (*PL_regcomp_parse != '=' && *PL_regcomp_parse != '!') 
		    goto unknown;
		PL_regcomp_parse++;
a414 3
		PL_seen_zerolen++;
	    case ':':
	    case '>':
d418 1
a418 1
		FAIL2("Sequence (?%c...) not implemented", (int)paren);
d421 4
a424 4
		while (*PL_regcomp_parse && *PL_regcomp_parse != ')')
		    PL_regcomp_parse++;
		if (*PL_regcomp_parse != ')')
		    FAIL("Sequence (?#... not terminated");
a427 105
	    case '{':
	    {
		dTHR;
		I32 count = 1, n = 0;
		char c;
		char *s = PL_regcomp_parse;
		SV *sv;
		OP_4tree *sop, *rop;

		PL_seen_zerolen++;
		PL_regseen |= REG_SEEN_EVAL;
		while (count && (c = *PL_regcomp_parse)) {
		    if (c == '\\' && PL_regcomp_parse[1])
			PL_regcomp_parse++;
		    else if (c == '{') 
			count++;
		    else if (c == '}') 
			count--;
		    PL_regcomp_parse++;
		}
		if (*PL_regcomp_parse != ')')
		    FAIL("Sequence (?{...}) not terminated or not {}-balanced");
		if (!SIZE_ONLY) {
		    AV *av;
		    
		    if (PL_regcomp_parse - 1 - s) 
			sv = newSVpv(s, PL_regcomp_parse - 1 - s);
		    else
			sv = newSVpv("", 0);

		    rop = sv_compile_2op(sv, &sop, "re", &av);

		    n = add_data(3, "nso");
		    PL_regcomp_rx->data->data[n] = (void*)rop;
		    PL_regcomp_rx->data->data[n+1] = (void*)av;
		    PL_regcomp_rx->data->data[n+2] = (void*)sop;
		    SvREFCNT_dec(sv);
		} else {		/* First pass */
		    if (PL_reginterp_cnt < ++PL_seen_evals && PL_curcop != &PL_compiling)
			/* No compiled RE interpolated, has runtime
			   components ===> unsafe.  */
			FAIL("Eval-group not allowed at runtime, use re 'eval'");
		    if (PL_tainted)
			FAIL("Eval-group in insecure regular expression");
		}
		
		nextchar();
		return reganode(EVAL, n);
	    }
	    case '(':
	    {
		if (PL_regcomp_parse[0] == '?') {
		    if (PL_regcomp_parse[1] == '=' || PL_regcomp_parse[1] == '!' 
			|| PL_regcomp_parse[1] == '<' 
			|| PL_regcomp_parse[1] == '{') { /* Lookahead or eval. */
			I32 flag;
			
			ret = reg_node(LOGICAL);
			regtail(ret, reg(1, &flag));
			goto insert_if;
		    } 
		} else if (PL_regcomp_parse[0] >= '1' && PL_regcomp_parse[0] <= '9' ) {
		    parno = atoi(PL_regcomp_parse++);

		    while (isDIGIT(*PL_regcomp_parse))
			PL_regcomp_parse++;
		    ret = reganode(GROUPP, parno);
		    if ((c = *nextchar()) != ')')
			FAIL2("Switch (?(number%c not recognized", c);
		  insert_if:
		    regtail(ret, reganode(IFTHEN, 0));
		    br = regbranch(&flags, 1);
		    if (br == NULL)
			br = reganode(LONGJMP, 0);
		    else
			regtail(br, reganode(LONGJMP, 0));
		    c = *nextchar();
		    if (flags&HASWIDTH)
			*flagp |= HASWIDTH;
		    if (c == '|') {
			lastbr = reganode(IFTHEN, 0); /* Fake one for optimizer. */
			regbranch(&flags, 1);
			regtail(ret, lastbr);
			if (flags&HASWIDTH)
			    *flagp |= HASWIDTH;
			c = *nextchar();
		    } else
			lastbr = NULL;
		    if (c != ')')
			FAIL("Switch (?(condition)... contains too many branches");
		    ender = reg_node(TAIL);
		    regtail(br, ender);
		    if (lastbr) {
			regtail(lastbr, ender);
			regtail(NEXTOPER(NEXTOPER(lastbr)), ender);
		    } else
			regtail(ret, ender);
		    return ret;
		} else {
		    FAIL2("Unknown condition for (?(%.2s", PL_regcomp_parse);
		}
	    }
            case 0:
                FAIL("Sequence (? incomplete");
                break;
d429 5
a433 22
		--PL_regcomp_parse;
	      parse_flags:
		while (*PL_regcomp_parse && strchr("iogcmsx", *PL_regcomp_parse)) {
		    if (*PL_regcomp_parse != 'o')
			pmflag(flagsp, *PL_regcomp_parse);
		    ++PL_regcomp_parse;
		}
		if (*PL_regcomp_parse == '-') {
		    flagsp = &negflags;
		    ++PL_regcomp_parse;
		    goto parse_flags;
		}
		PL_regflags |= posflags;
		PL_regflags &= ~negflags;
		if (*PL_regcomp_parse == ':') {
		    PL_regcomp_parse++;
		    paren = ':';
		    break;
		}		
	      unknown:
		if (*PL_regcomp_parse != ')')
		    FAIL2("Sequence (?%c...) not recognized", *PL_regcomp_parse);
d440 2
a441 2
	    parno = PL_regnpar;
	    PL_regnpar++;
a442 1
	    open = 1;
d448 1
a448 1
    br = regbranch(&flags, 1);
d451 3
a453 14
    if (*PL_regcomp_parse == '|') {
	if (!SIZE_ONLY && PL_extralen) {
	    reginsert(BRANCHJ, br);
	} else
	    reginsert(BRANCH, br);
	have_branch = 1;
	if (SIZE_ONLY)
	    PL_extralen += 1;		/* For BRANCHJ-BRANCH. */
    } else if (paren == ':') {
	*flagp |= flags&SIMPLE;
    }
    if (open) {				/* Starts with OPEN. */
	regtail(ret, br);		/* OPEN -> first. */
    } else if (paren != '?')		/* Not Conditional */
d455 2
a456 2
    if (flags&HASWIDTH)
	*flagp |= HASWIDTH;
d458 1
a458 8
    lastbr = br;
    while (*PL_regcomp_parse == '|') {
	if (!SIZE_ONLY && PL_extralen) {
	    ender = reganode(LONGJMP,0);
	    regtail(NEXTOPER(NEXTOPER(lastbr)), ender); /* Append to the previous. */
	}
	if (SIZE_ONLY)
	    PL_extralen += 2;		/* Account for LONGJMP. */
d460 1
a460 1
	br = regbranch(&flags, 0);
d463 3
a465 4
	regtail(lastbr, br);		/* BRANCH -> BRANCH. */
	lastbr = br;
	if (flags&HASWIDTH)
	    *flagp |= HASWIDTH;
d469 22
a490 23
    if (have_branch || paren != ':') {
	/* Make a closing node, and hook it on the end. */
	switch (paren) {
	case ':':
	    ender = reg_node(TAIL);
	    break;
	case 1:
	    ender = reganode(CLOSE, parno);
	    break;
	case '<':
	case ',':
	case '=':
	case '!':
	    *flagp &= ~HASWIDTH;
	    /* FALL THROUGH */
	case '>':
	    ender = reg_node(SUCCEED);
	    break;
	case 0:
	    ender = reg_node(END);
	    break;
	}
	regtail(lastbr, ender);
d492 3
a494 6
	if (have_branch) {
	    /* Hook the tails of the branches to the closing node. */
	    for (br = ret; br != NULL; br = regnext(br)) {
		regoptail(br, ender);
	    }
	}
d496 3
a498 15

    {
	char *p;
	static char parens[] = "=!<,>";

	if (paren && (p = strchr(parens, paren))) {
	    int node = ((p - parens) % 2) ? UNLESSM : IFMATCH;
	    int flag = (p - parens) > 1;

	    if (paren == '>')
		node = SUSPEND, flag = 0;
	    reginsert(node,ret);
	    ret->flags = flag;
	    regtail(ret, reg_node(TAIL));
	}
d502 1
a502 1
    if (paren && (PL_regcomp_parse >= PL_regxend || *nextchar() != ')')) {
d504 2
a505 2
    } else if (!paren && PL_regcomp_parse < PL_regxend) {
	if (*PL_regcomp_parse == ')') {
a510 3
    if (paren != 0) {
	PL_regflags = oregflags;
    }
d520 8
a527 8
STATIC regnode *
regbranch(I32 *flagp, I32 first)
{
    dTHR;
    register regnode *ret;
    register regnode *chain = NULL;
    register regnode *latest;
    I32 flags = 0, c = 0;
d529 1
a529 13
    if (first) 
	ret = NULL;
    else {
	if (!SIZE_ONLY && PL_extralen) 
	    ret = reganode(BRANCHJ,0);
	else
	    ret = reg_node(BRANCH);
    }
	
    if (!first && SIZE_ONLY) 
	PL_extralen += 1;			/* BRANCHJ */
    
    *flagp = WORST;			/* Tentatively. */
d531 3
a533 1
    PL_regcomp_parse--;
d535 1
a535 1
    while (PL_regcomp_parse < PL_regxend && *PL_regcomp_parse != '|' && *PL_regcomp_parse != ')') {
d542 1
a542 2
	} else if (ret == NULL)
	    ret = latest;
d544 1
a544 1
	if (chain == NULL) 	/* First piece. */
d547 1
a547 1
	    PL_regnaughty++;
a550 9
	c++;
    }
    if (chain == NULL) {	/* Loop ran zero times. */
	chain = reg_node(NOTHING);
	if (ret == NULL)
	    ret = chain;
    }
    if (c == 1) {
	*flagp |= flags&SIMPLE;
d552 2
d567 3
a569 2
STATIC regnode *
regpiece(I32 *flagp)
d571 1
a571 2
    dTHR;
    register regnode *ret;
d575 1
a575 1
    char *origparse = PL_regcomp_parse;
d578 1
a578 1
    I32 max = REG_INFTY;
d587 9
a595 1
    op = *PL_regcomp_parse;
d597 2
a598 2
    if (op == '{' && regcurly(PL_regcomp_parse)) {
	next = PL_regcomp_parse + 1;
d612 2
a613 2
	    PL_regcomp_parse++;
	    min = atoi(PL_regcomp_parse);
d617 1
a617 1
		maxpos = PL_regcomp_parse;
d620 2
a621 4
		max = REG_INFTY;		/* meaning "infinity" */
	    else if (max >= REG_INFTY)
		FAIL2("Quantifier in {,} bigger than %d", REG_INFTY - 1);
	    PL_regcomp_parse = next;
d626 1
a626 1
		PL_regnaughty += 2 + PL_regnaughty / 2;
d630 2
a631 7
		PL_regnaughty += 4 + PL_regnaughty;	/* compound interest */
		regtail(ret, reg_node(WHILEM));
		if (!SIZE_ONLY && PL_extralen) {
		    reginsert(LONGJMP,ret);
		    reginsert(NOTHING,ret);
		    NEXT_OFF(ret) = 3;	/* Go over LONGJMP. */
		}
d633 1
a633 5
		if (!SIZE_ONLY && PL_extralen)
		    NEXT_OFF(ret) = 3;	/* Go over NOTHING to LONGJMP. */
		regtail(ret, reg_node(NOTHING));
		if (SIZE_ONLY)
		    PL_extralen += 3;
a634 1
	    ret->flags = 0;
d637 1
a637 3
		*flagp = WORST;
	    if (max > 0)
		*flagp |= HASWIDTH;
d639 9
a647 4
		FAIL("Can't do {n,m} with n > m");
	    if (!SIZE_ONLY) {
		ARG1_SET(ret, min);
		ARG2_SET(ret, max);
a657 6

#if 0				/* Now runtime fix should be reliable. */
    if (!(flags&HASWIDTH) && op != '?')
      FAIL("regexp *+ operand could be empty");
#endif 

d660 1
a660 1
    *flagp = (op != '+') ? (WORST|SPSTART|HASWIDTH) : (WORST|HASWIDTH);
d664 1
a664 2
	ret->flags = 0;
	PL_regnaughty += 4;
d671 1
a671 2
	ret->flags = 0;
	PL_regnaughty += 3;
d681 1
a681 1
    if (PL_dowarn && !SIZE_ONLY && !(flags&HASWIDTH) && max > 10000) {
d683 1
a683 1
	    PL_regcomp_parse - origparse, origparse);
d686 1
a686 1
    if (*PL_regcomp_parse == '?') {
d689 5
a693 1
	regtail(ret, ret + NODE_STEP_REGNODE);
d695 1
a695 1
    if (ISMULT2(PL_regcomp_parse))
d711 3
a713 2
STATIC regnode *
regatom(I32 *flagp)
d715 1
a715 2
    dTHR;
    register regnode *ret = 0;
d721 1
a721 1
    switch (*PL_regcomp_parse) {
a722 1
	PL_seen_zerolen++;
d724 4
a727 4
	if (PL_regflags & PMf_MULTILINE)
	    ret = reg_node(MBOL);
	else if (PL_regflags & PMf_SINGLELINE)
	    ret = reg_node(SBOL);
d729 1
a729 1
	    ret = reg_node(BOL);
a731 2
	if (PL_regcomp_parse[1]) 
	    PL_seen_zerolen++;
d733 4
a736 4
	if (PL_regflags & PMf_MULTILINE)
	    ret = reg_node(MEOL);
	else if (PL_regflags & PMf_SINGLELINE)
	    ret = reg_node(SEOL);
d738 1
a738 1
	    ret = reg_node(EOL);
d742 2
a743 2
	if (PL_regflags & PMf_SINGLELINE)
	    ret = reg_node(SANY);
d745 2
a746 2
	    ret = reg_node(ANY);
	PL_regnaughty++;
d750 1
a750 1
	PL_regcomp_parse++;
d762 1
a762 1
	*flagp |= flags&(HASWIDTH|SPSTART|SIMPLE);
d770 1
a770 1
	FAIL2("internal urp in regexp at /%s/", PL_regcomp_parse);
a772 6
    case '{':
	if (!regcurly(PL_regcomp_parse)) {
	    PL_regcomp_parse++;
	    goto defchar;
	}
	/* FALL THROUGH */
d776 1
a776 1
	FAIL("?+*{} follows nothing in regexp");
d779 1
a779 1
	switch (*++PL_regcomp_parse) {
d781 1
a781 2
	    PL_seen_zerolen++;
	    ret = reg_node(SBOL);
d786 1
a786 2
	    ret = reg_node(GPOS);
	    PL_regseen |= REG_SEEN_GPOS;
d791 1
a791 1
	    ret = reg_node(SEOL);
a794 6
	case 'z':
	    ret = reg_node(EOS);
	    *flagp |= SIMPLE;
	    PL_seen_zerolen++;		/* Do not optimize RE away */
	    nextchar();
	    break;
d796 1
a796 1
	    ret = reg_node((PL_regflags & PMf_LOCALE) ? ALNUML : ALNUM);
d801 1
a801 1
	    ret = reg_node((PL_regflags & PMf_LOCALE) ? NALNUML : NALNUM);
d806 1
a806 2
	    PL_seen_zerolen++;
	    ret = reg_node((PL_regflags & PMf_LOCALE) ? BOUNDL : BOUND);
d811 1
a811 2
	    PL_seen_zerolen++;
	    ret = reg_node((PL_regflags & PMf_LOCALE) ? NBOUNDL : NBOUND);
d816 1
a816 1
	    ret = reg_node((PL_regflags & PMf_LOCALE) ? SPACEL : SPACE);
d821 1
a821 1
	    ret = reg_node((PL_regflags & PMf_LOCALE) ? NSPACEL : NSPACE);
d826 1
a826 1
	    ret = reg_node(DIGIT);
d831 1
a831 1
	    ret = reg_node(NDIGIT);
d848 1
a848 1
		I32 num = atoi(PL_regcomp_parse);
d850 1
a850 1
		if (num > 9 && num >= PL_regnpar)
d853 2
a854 6
		    if (!SIZE_ONLY && num > PL_regcomp_rx->nparens)
			FAIL("reference to nonexistent group");
		    PL_regsawback = 1;
		    ret = reganode((PL_regflags & PMf_FOLD)
				   ? ((PL_regflags & PMf_LOCALE) ? REFFL : REFF)
				   : REF, num);
d856 3
a858 3
		    while (isDIGIT(*PL_regcomp_parse))
			PL_regcomp_parse++;
		    PL_regcomp_parse--;
d864 1
a864 1
	    if (PL_regcomp_parse >= PL_regxend)
d873 3
a875 3
	if (PL_regflags & PMf_EXTENDED) {
	    while (PL_regcomp_parse < PL_regxend && *PL_regcomp_parse != '\n') PL_regcomp_parse++;
	    if (PL_regcomp_parse < PL_regxend)
d882 1
a882 1
	    register U8 ender;
d884 1
a884 1
	    char *oldp, *s;
d887 1
a887 1
	    PL_regcomp_parse++;
d890 4
a893 7
	    ret = reg_node((PL_regflags & PMf_FOLD)
			  ? ((PL_regflags & PMf_LOCALE) ? EXACTFL : EXACTF)
			  : EXACT);
	    s = (char *) OPERAND(ret);
	    regc(0, s++);		/* save spot for len */
	    for (len = 0, p = PL_regcomp_parse - 1;
	      len < 127 && p < PL_regxend;
a896 3

		if (PL_regflags & PMf_EXTENDED)
		    p = regwhite(p, PL_regxend);
a910 1
		    case 'z':
d951 4
a954 2
			ender = UCHARAT(p++);
			ender = toCTRL(ender);
d959 1
a959 1
			  (isDIGIT(p[1]) && atoi(p) >= PL_regnpar) ) {
d969 1
a969 1
			if (p >= PL_regxend)
d977 12
d993 2
a994 2
		if (PL_regflags & PMf_EXTENDED)
		    p = regwhite(p, PL_regxend);
d1000 1
a1000 1
			regc(ender, s++);
d1004 1
a1004 1
		regc(ender, s++);
d1007 1
a1007 1
	    PL_regcomp_parse = p - 1;
d1015 1
a1015 1
	    if (!SIZE_ONLY)
d1017 1
a1017 6
	    regc('\0', s++);
	    if (SIZE_ONLY) {
		PL_regsize += (len + 2 + sizeof(regnode) - 1) / sizeof(regnode);
	    } else {
		PL_regcode += (len + 2 + sizeof(regnode) - 1) / sizeof(regnode);
	    }
d1025 13
a1037 15
STATIC char *
regwhite(char *p, char *e)
{
    while (p < e) {
	if (isSPACE(*p))
	    ++p;
	else if (*p == '#') {
	    do {
		p++;
	    } while (p < e && *p != '\n');
	}
	else
	    break;
    }
    return p;
d1040 2
a1041 2
STATIC regnode *
regclass(void)
d1043 2
a1044 3
    dTHR;
    register char *opnd, *s;
    register I32 Class;
d1047 1
a1047 1
    register regnode *ret;
d1051 5
a1055 16
    s = opnd = (char *) OPERAND(PL_regcode);
    ret = reg_node(ANYOF);
    for (Class = 0; Class < 33; Class++)
	regc(0, s++);
    if (*PL_regcomp_parse == '^') {	/* Complement of range. */
	PL_regnaughty++;
	PL_regcomp_parse++;
	if (!SIZE_ONLY)
	    *opnd |= ANYOF_INVERT;
    }
    if (!SIZE_ONLY) {
 	PL_regcode += ANY_SKIP;
	if (PL_regflags & PMf_FOLD)
	    *opnd |= ANYOF_FOLD;
	if (PL_regflags & PMf_LOCALE)
	    *opnd |= ANYOF_LOCALE;
d1057 1
a1057 1
	PL_regsize += ANY_SKIP;
d1059 4
a1062 1
    if (*PL_regcomp_parse == ']' || *PL_regcomp_parse == '-')
d1064 1
a1064 1
    while (PL_regcomp_parse < PL_regxend && *PL_regcomp_parse != ']') {
d1066 4
a1069 28
	Class = UCHARAT(PL_regcomp_parse++);
	if (Class == '[' && PL_regcomp_parse + 1 < PL_regxend &&
	    /* I smell either [: or [= or [. -- POSIX has been here, right? */
	    (*PL_regcomp_parse == ':' || *PL_regcomp_parse == '=' || *PL_regcomp_parse == '.')) {
	    char  posixccc = *PL_regcomp_parse;
	    char* posixccs = PL_regcomp_parse++;
	    
	    while (PL_regcomp_parse < PL_regxend && *PL_regcomp_parse != posixccc)
		PL_regcomp_parse++;
	    if (PL_regcomp_parse == PL_regxend)
		/* Grandfather lone [:, [=, [. */
		PL_regcomp_parse = posixccs;
	    else {
		PL_regcomp_parse++; /* skip over the posixccc */
		if (*PL_regcomp_parse == ']') {
		    /* Not Implemented Yet.
		     * (POSIX Extended Character Classes, that is)
		     * The text between e.g. [: and :] would start
		     * at posixccs + 1 and stop at regcomp_parse - 2. */
		    if (PL_dowarn && !SIZE_ONLY)
			warn("Character class syntax [%c %c] is reserved for future extensions", posixccc, posixccc);
		    PL_regcomp_parse++; /* skip over the ending ] */
		}
	    }
	}
	if (Class == '\\') {
	    Class = UCHARAT(PL_regcomp_parse++);
	    switch (Class) {
d1071 3
a1073 9
		if (!SIZE_ONLY) {
		    if (PL_regflags & PMf_LOCALE)
			*opnd |= ANYOF_ALNUML;
		    else {
			for (Class = 0; Class < 256; Class++)
			    if (isALNUM(Class))
				ANYOF_SET(opnd, Class);
		    }
		}
d1077 3
a1079 9
		if (!SIZE_ONLY) {
		    if (PL_regflags & PMf_LOCALE)
			*opnd |= ANYOF_NALNUML;
		    else {
			for (Class = 0; Class < 256; Class++)
			    if (!isALNUM(Class))
				ANYOF_SET(opnd, Class);
		    }
		}
d1083 3
a1085 9
		if (!SIZE_ONLY) {
		    if (PL_regflags & PMf_LOCALE)
			*opnd |= ANYOF_SPACEL;
		    else {
			for (Class = 0; Class < 256; Class++)
			    if (isSPACE(Class))
				ANYOF_SET(opnd, Class);
		    }
		}
d1089 3
a1091 9
		if (!SIZE_ONLY) {
		    if (PL_regflags & PMf_LOCALE)
			*opnd |= ANYOF_NSPACEL;
		    else {
			for (Class = 0; Class < 256; Class++)
			    if (!isSPACE(Class))
				ANYOF_SET(opnd, Class);
		    }
		}
d1095 2
a1096 4
		if (!SIZE_ONLY) {
		    for (Class = '0'; Class <= '9'; Class++)
			ANYOF_SET(opnd, Class);
		}
d1100 4
a1103 6
		if (!SIZE_ONLY) {
		    for (Class = 0; Class < '0'; Class++)
			ANYOF_SET(opnd, Class);
		    for (Class = '9' + 1; Class < 256; Class++)
			ANYOF_SET(opnd, Class);
		}
d1107 1
a1107 1
		Class = '\n';
d1110 1
a1110 1
		Class = '\r';
d1113 1
a1113 1
		Class = '\t';
d1116 1
a1116 1
		Class = '\f';
d1119 1
a1119 1
		Class = '\b';
d1122 1
a1122 1
		Class = '\033';
d1125 1
a1125 1
		Class = '\007';
d1128 2
a1129 2
		Class = scan_hex(PL_regcomp_parse, 2, &numlen);
		PL_regcomp_parse += numlen;
d1132 4
a1135 2
		Class = UCHARAT(PL_regcomp_parse++);
		Class = toCTRL(Class);
d1139 2
a1140 2
		Class = scan_oct(--PL_regcomp_parse, 3, &numlen);
		PL_regcomp_parse += numlen;
d1145 1
a1145 1
	    if (lastclass > Class)
d1150 4
a1153 4
	    lastclass = Class;
	    if (*PL_regcomp_parse == '-' && PL_regcomp_parse+1 < PL_regxend &&
	      PL_regcomp_parse[1] != ']') {
		PL_regcomp_parse++;
d1158 4
a1161 19
	if (!SIZE_ONLY) {
#ifndef ASCIIish
	    register I32 i;
	    if ((isLOWER(lastclass) && isLOWER(Class)) ||
		(isUPPER(lastclass) && isUPPER(Class))) {
 		if (isLOWER(lastclass)) {
 		    for (i = lastclass; i <= Class; i++)
			if (isLOWER(i))
			    ANYOF_SET(opnd, i);
 		} else {
 		    for (i = lastclass; i <= Class; i++)
			if (isUPPER(i))
			    ANYOF_SET(opnd, i);
		}
	    }
	    else
#endif
		for ( ; lastclass <= Class; lastclass++)
		    ANYOF_SET(opnd, lastclass);
d1163 1
a1163 1
	lastclass = Class;
d1165 1
a1165 1
    if (*PL_regcomp_parse != ']')
a1167 16
    /* optimize case-insensitive simple patterns (e.g. /[a-z]/i) */
    if (!SIZE_ONLY && (*opnd & (0xFF ^ ANYOF_INVERT)) == ANYOF_FOLD) {
	for (Class = 0; Class < 256; ++Class) {
	    if (ANYOF_TEST(opnd, Class)) {
		I32 cf = fold[Class];
		ANYOF_SET(opnd, cf);
	    }
	}
	*opnd &= ~ANYOF_FOLD;
    }
    /* optimize inverted simple patterns (e.g. [^a-z]) */
    if (!SIZE_ONLY && (*opnd & 0xFF) == ANYOF_INVERT) {
	for (Class = 0; Class < 32; ++Class)
	    opnd[1 + Class] ^= 0xFF;
	*opnd = 0;
    }
d1171 2
a1172 2
STATIC char*
nextchar(void)
d1174 1
a1174 2
    dTHR;
    char* retval = PL_regcomp_parse++;
d1177 5
a1181 5
	if (*PL_regcomp_parse == '(' && PL_regcomp_parse[1] == '?' &&
		PL_regcomp_parse[2] == '#') {
	    while (*PL_regcomp_parse && *PL_regcomp_parse != ')')
		PL_regcomp_parse++;
	    PL_regcomp_parse++;
d1184 3
a1186 3
	if (PL_regflags & PMf_EXTENDED) {
	    if (isSPACE(*PL_regcomp_parse)) {
		PL_regcomp_parse++;
d1189 4
a1192 4
	    else if (*PL_regcomp_parse == '#') {
		while (*PL_regcomp_parse && *PL_regcomp_parse != '\n')
		    PL_regcomp_parse++;
		PL_regcomp_parse++;
d1201 1
a1201 1
- reg_node - emit a node
d1203 8
a1210 2
STATIC regnode *			/* Location. */
reg_node(U8 op)
d1212 10
a1221 8
    dTHR;
    register regnode *ret;
    register regnode *ptr;

    ret = PL_regcode;
    if (SIZE_ONLY) {
	SIZE_ALIGN(PL_regsize);
	PL_regsize += 1;
d1225 6
a1230 1
    NODE_ALIGN_FILL(ret);
d1232 4
a1235 2
    FILL_ADVANCE_NODE(ptr, op);
    PL_regcode = ptr;
d1243 9
a1251 2
STATIC regnode *			/* Location. */
reganode(U8 op, U32 arg)
d1253 10
a1262 8
    dTHR;
    register regnode *ret;
    register regnode *ptr;

    ret = PL_regcode;
    if (SIZE_ONLY) {
	SIZE_ALIGN(PL_regsize);
	PL_regsize += 2;
d1266 6
a1271 1
    NODE_ALIGN_FILL(ret);
d1273 10
a1282 2
    FILL_ADVANCE_NODE_ARG(ptr, op, arg);
    PL_regcode = ptr;
d1290 8
a1297 2
STATIC void
regc(U8 b, char* s)
d1299 4
a1302 3
    dTHR;
    if (!SIZE_ONLY)
	*s = b;
d1310 9
a1318 2
STATIC void
reginsert(U8 op, regnode *opnd)
d1320 11
a1330 10
    dTHR;
    register regnode *src;
    register regnode *dst;
    register regnode *place;
    register int offset = regarglen[(U8)op];
    
/* (regkind[(U8)op] == CURLY ? EXTRA_STEP_2ARGS : 0); */

    if (SIZE_ONLY) {
	PL_regsize += NODE_STEP_REGNODE + offset;
d1334 7
a1340 3
    src = PL_regcode;
    PL_regcode += NODE_STEP_REGNODE + offset;
    dst = PL_regcode;
d1342 1
a1342 1
	StructCopy(--src, --dst, regnode);
d1345 8
a1352 3
    src = NEXTOPER(place);
    FILL_ADVANCE_NODE(place, op);
    Zero(src, offset, regnode);
d1356 1
a1356 1
- regtail - set the next-pointer at the end of a node chain of p to val.
d1358 4
a1361 2
STATIC void
regtail(regnode *p, regnode *val)
d1363 2
a1364 3
    dTHR;
    register regnode *scan;
    register regnode *temp;
d1367 1
a1367 1
    if (SIZE_ONLY)
d1379 15
a1393 5
    if (reg_off_by_arg[OP(scan)]) {
	ARG_SET(scan, val - scan);
    } else {
	NEXT_OFF(scan) = val - scan;
    }
d1399 4
a1402 2
STATIC void
regoptail(regnode *p, regnode *val)
a1403 1
    dTHR;
d1405 1
a1405 7
    if (p == NULL || SIZE_ONLY)
	return;
    if (regkind[(U8)OP(p)] == BRANCH) {
	regtail(NEXTOPER(p), val);
    } else if ( regkind[(U8)OP(p)] == BRANCHJ) {
	regtail(NEXTOPER(NEXTOPER(p)), val);
    } else
d1407 1
d1414 2
a1415 1
regcurly(register char *s)
d1432 1
d1434 6
a1439 2
STATIC regnode *
dumpuntil(regnode *start, regnode *node, regnode *last, SV* sv, I32 l)
d1441 3
a1443 3
#ifdef DEBUGGING
    register char op = EXACT;	/* Arbitrary non-END op. */
    register regnode *next, *onode;
a1444 2
    while (op != END && (!last || node < last)) {
	/* While that wasn't END last time... */
d1446 10
a1455 11
	NODE_ALIGN(node);
	op = OP(node);
	if (op == CLOSE)
	    l--;	
	next = regnext(node);
	/* Where, what. */
	if (OP(node) == OPTIMIZED)
	    goto after_print;
	regprop(sv, node);
	PerlIO_printf(Perl_debug_log, "%4d:%*s%s", node - start, 
		      2*l + 1, "", SvPVX(sv));
d1457 1
a1457 1
	    PerlIO_printf(Perl_debug_log, "(0)");
d1459 18
a1476 35
	    PerlIO_printf(Perl_debug_log, "(%d)", next - start);
	(void)PerlIO_putc(Perl_debug_log, '\n');
      after_print:
	if (regkind[(U8)op] == BRANCHJ) {
	    register regnode *nnode = (OP(next) == LONGJMP 
				       ? regnext(next) 
				       : next);
	    if (last && nnode > last)
		nnode = last;
	    node = dumpuntil(start, NEXTOPER(NEXTOPER(node)), nnode, sv, l + 1);
	} else if (regkind[(U8)op] == BRANCH) {
	    node = dumpuntil(start, NEXTOPER(node), next, sv, l + 1);
	} else if ( op == CURLY) {   /* `next' might be very big: optimizer */
	    node = dumpuntil(start, NEXTOPER(node) + EXTRA_STEP_2ARGS,
			     NEXTOPER(node) + EXTRA_STEP_2ARGS + 1, sv, l + 1);
	} else if (regkind[(U8)op] == CURLY && op != CURLYX) {
	    node = dumpuntil(start, NEXTOPER(node) + EXTRA_STEP_2ARGS,
			     next, sv, l + 1);
	} else if ( op == PLUS || op == STAR) {
	    node = dumpuntil(start, NEXTOPER(node), NEXTOPER(node) + 1, sv, l + 1);
	} else if (op == ANYOF) {
	    node = NEXTOPER(node);
	    node += ANY_SKIP;
	} else if (regkind[(U8)op] == EXACT) {
            /* Literal string, where present. */
	    node += ((*OPERAND(node)) + 2 + sizeof(regnode) - 1) / sizeof(regnode);
	    node = NEXTOPER(node);
	} else {
	    node = NEXTOPER(node);
	    node += regarglen[(U8)op];
	}
	if (op == CURLYX || op == OPEN)
	    l++;
	else if (op == WHILEM)
	    l--;
a1477 15
#endif	/* DEBUGGING */
    return node;
}

/*
 - regdump - dump a regexp onto Perl_debug_log in vaguely comprehensible form
 */
void
regdump(regexp *r)
{
#ifdef DEBUGGING
    dTHR;
    SV *sv = sv_newmortal();

    (void)dumpuntil(r->program, r->program + 1, NULL, sv, 0);
d1480 6
a1485 41
    if (r->anchored_substr)
	PerlIO_printf(Perl_debug_log, "anchored `%s%s%s'%s at %d ", 
		      PL_colors[0],
		      SvPVX(r->anchored_substr), 
		      PL_colors[1],
		      SvTAIL(r->anchored_substr) ? "$" : "",
		      r->anchored_offset);
    if (r->float_substr)
	PerlIO_printf(Perl_debug_log, "floating `%s%s%s'%s at %d..%u ", 
		      PL_colors[0],
		      SvPVX(r->float_substr), 
		      PL_colors[1],
		      SvTAIL(r->float_substr) ? "$" : "",
		      r->float_min_offset, r->float_max_offset);
    if (r->check_substr)
	PerlIO_printf(Perl_debug_log, 
		      r->check_substr == r->float_substr 
		      ? "(checking floating" : "(checking anchored");
    if (r->reganch & ROPT_NOSCAN)
	PerlIO_printf(Perl_debug_log, " noscan");
    if (r->reganch & ROPT_CHECK_ALL)
	PerlIO_printf(Perl_debug_log, " isall");
    if (r->check_substr)
	PerlIO_printf(Perl_debug_log, ") ");

    if (r->regstclass) {
	regprop(sv, r->regstclass);
	PerlIO_printf(Perl_debug_log, "stclass `%s' ", SvPVX(sv));
    }
    if (r->reganch & ROPT_ANCH) {
	PerlIO_printf(Perl_debug_log, "anchored");
	if (r->reganch & ROPT_ANCH_BOL)
	    PerlIO_printf(Perl_debug_log, "(BOL)");
	if (r->reganch & ROPT_ANCH_MBOL)
	    PerlIO_printf(Perl_debug_log, "(MBOL)");
	if (r->reganch & ROPT_ANCH_GPOS)
	    PerlIO_printf(Perl_debug_log, "(GPOS)");
	PerlIO_putc(Perl_debug_log, ' ');
    }
    if (r->reganch & ROPT_GPOS_SEEN)
	PerlIO_printf(Perl_debug_log, "GPOS ");
d1487 1
a1487 1
	PerlIO_printf(Perl_debug_log, "plus ");
d1489 6
a1494 6
	PerlIO_printf(Perl_debug_log, "implicit ");
    PerlIO_printf(Perl_debug_log, "minlen %ld ", (long) r->minlen);
    if (r->reganch & ROPT_EVAL_SEEN)
	PerlIO_printf(Perl_debug_log, "with eval ");
    PerlIO_printf(Perl_debug_log, "\n");
#endif	/* DEBUGGING */
d1500 3
a1502 2
void
regprop(SV *sv, regnode *o)
a1503 2
#ifdef DEBUGGING
    dTHR;
d1506 3
a1508 2
    sv_setpvn(sv, "", 0);
    switch (OP(o)) {
a1520 3
    case EOS:
	p = "EOS";
	break;
d1539 2
a1540 8
    case EXACT:
	sv_catpvf(sv, "EXACT <%s%s%s>", PL_colors[0], OPERAND(o) + 1, PL_colors[1]);
	break;
    case EXACTF:
	sv_catpvf(sv, "EXACTF <%s%s%s>", PL_colors[0], OPERAND(o) + 1, PL_colors[1]);
	break;
    case EXACTFL:
	sv_catpvf(sv, "EXACTFL <%s%s%s>", PL_colors[0], OPERAND(o) + 1, PL_colors[1]);
a1544 3
    case TAIL:
	p = "TAIL";
	break;
d1551 6
a1559 3
    case BOUNDL:
	p = "BOUNDL";
	break;
d1563 2
a1564 2
    case NBOUNDL:
	p = "NBOUNDL";
d1566 5
a1570 2
    case CURLY:
	sv_catpvf(sv, "CURLY {%d,%d}", ARG1(o), ARG2(o));
d1572 2
a1573 2
    case CURLYM:
	sv_catpvf(sv, "CURLYM[%d] {%d,%d}", o->flags, ARG1(o), ARG2(o));
d1575 3
a1577 2
    case CURLYN:
	sv_catpvf(sv, "CURLYN[%d] {%d,%d}", o->flags, ARG1(o), ARG2(o));
d1580 2
a1581 1
	sv_catpvf(sv, "CURLYX {%d,%d}", ARG1(o), ARG2(o));
d1584 2
a1585 7
	sv_catpvf(sv, "REF%d", ARG(o));
	break;
    case REFF:
	sv_catpvf(sv, "REFF%d", ARG(o));
	break;
    case REFFL:
	sv_catpvf(sv, "REFFL%d", ARG(o));
d1588 2
a1589 1
	sv_catpvf(sv, "OPEN%d", ARG(o));
d1592 1
a1592 1
	sv_catpvf(sv, "CLOSE%d", ARG(o));
d1604 2
a1605 2
    case GPOS:
	p = "GPOS";
d1608 1
a1608 1
	sv_catpvf(sv, "UNLESSM[-%d]", o->flags);
d1611 1
a1611 1
	sv_catpvf(sv, "IFMATCH[-%d]", o->flags);
a1618 57
    case DIGIT:
	p = "DIGIT";
	break;
    case NDIGIT:
	p = "NDIGIT";
	break;
    case ALNUM:
	p = "ALNUM";
	break;
    case NALNUM:
	p = "NALNUM";
	break;
    case SPACE:
	p = "SPACE";
	break;
    case NSPACE:
	p = "NSPACE";
	break;
    case ALNUML:
	p = "ALNUML";
	break;
    case NALNUML:
	p = "NALNUML";
	break;
    case SPACEL:
	p = "SPACEL";
	break;
    case NSPACEL:
	p = "NSPACEL";
	break;
    case EVAL:
	p = "EVAL";
	break;
    case LONGJMP:
	p = "LONGJMP";
	break;
    case BRANCHJ:
	p = "BRANCHJ";
	break;
    case IFTHEN:
	p = "IFTHEN";
	break;
    case GROUPP:
	sv_catpvf(sv, "GROUPP%d", ARG(o));
	break;
    case LOGICAL:
	p = "LOGICAL";
	break;
    case SUSPEND:
	p = "SUSPEND";
	break;
    case RENUM:
	p = "RENUM";
	break;
    case OPTIMIZED:
	p = "OPTIMIZED";
	break;
d1622 3
a1624 3
    if (p)
	sv_catpv(sv, p);
#endif	/* DEBUGGING */
d1626 1
d1629 2
a1630 1
pregfree(struct regexp *r)
d1632 1
a1632 2
    dTHR;
    if (!r || (--r->refcnt > 0))
d1634 1
a1634 1
    if (r->precomp)
d1636 3
a1638 1
    if (r->subbase)
d1640 9
a1648 25
    if (r->substrs) {
	if (r->anchored_substr)
	    SvREFCNT_dec(r->anchored_substr);
	if (r->float_substr)
	    SvREFCNT_dec(r->float_substr);
	Safefree(r->substrs);
    }
    if (r->data) {
	int n = r->data->count;
	while (--n >= 0) {
	    switch (r->data->what[n]) {
	    case 's':
		SvREFCNT_dec((SV*)r->data->data[n]);
		break;
	    case 'o':
		op_free((OP_4tree*)r->data->data[n]);
		break;
	    case 'n':
		break;
	    default:
		FAIL2("panic: regfree data code '%c'", r->data->what[n]);
	    }
	}
	Safefree(r->data->what);
	Safefree(r->data);
a1652 50
}

/*
 - regnext - dig the "next" pointer out of a node
 *
 * [Note, when REGALIGN is defined there are two places in regmatch()
 * that bypass this code for speed.]
 */
regnode *
regnext(register regnode *p)
{
    dTHR;
    register I32 offset;

    if (p == &PL_regdummy)
	return(NULL);

    offset = (reg_off_by_arg[OP(p)] ? ARG(p) : NEXT_OFF(p));
    if (offset == 0)
	return(NULL);

    return(p+offset);
}

STATIC void	
re_croak2(const char* pat1,const char* pat2,...)
{
    va_list args;
    STRLEN l1 = strlen(pat1);
    STRLEN l2 = strlen(pat2);
    char buf[512];
    char *message;

    if (l1 > 510)
	l1 = 510;
    if (l1 + l2 > 510)
	l2 = 510 - l1;
    Copy(pat1, buf, l1 , char);
    Copy(pat2, buf + l1, l2 , char);
    buf[l1 + l2] = '\n';
    buf[l1 + l2 + 1] = '\0';
    va_start(args, pat2);
    message = mess(buf, &args);
    va_end(args);
    l1 = strlen(message);
    if (l1 > 512)
	l1 = 512;
    Copy(message, buf, l1 , char);
    buf[l1] = '\0';			/* Overwrite \n */
    croak("%s", buf);
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d28 1
a28 1
#  if defined(PERL_EXT_RE_DEBUG) && !defined(DEBUGGING)
d38 1
a39 2
#  define Perl_re_intuit_string my_re_intuit_string
/* *These* symbols are masked to allow static link. */
a40 4
#  define Perl_save_re_context my_save_re_context
#  define Perl_reginitcolors my_reginitcolors 

#  define PERL_NO_GET_CONTEXT
d67 1
a67 1
 ****    Copyright (c) 1991-2000, Larry Wall
a77 1
#define PERL_IN_REGCOMP_C
d80 1
a80 5
#ifdef PERL_IN_XSUB_RE
#  if defined(PERL_CAPI) || defined(PERL_OBJECT)
#    include "XSUB.h"
#  endif
#else
d125 22
d149 2
a150 1
typedef struct scan_data_t {
a165 2
    I32 whilem_c;
    struct regnode_charclass_class *start_class;
d167 1
d169 1
a169 6
/*
 * Forward declarations for pregcomp()'s friends.
 */

static scan_data_t zero_scan_data = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
				      0, 0, 0, 0, 0 };
a194 24
#define SCF_DO_STCLASS_AND	0x0800
#define SCF_DO_STCLASS_OR	0x1000
#define SCF_DO_STCLASS		(SCF_DO_STCLASS_AND|SCF_DO_STCLASS_OR)

#define RF_utf8		8
#define UTF (PL_reg_flags & RF_utf8)
#define LOC (PL_regflags & PMf_LOCALE)
#define FOLD (PL_regflags & PMf_FOLD)

#define OOB_CHAR8		1234
#define OOB_UTF8		123456
#define OOB_NAMEDCLASS		-1

#define CHR_SVLEN(sv) (UTF ? sv_len_utf8(sv) : SvCUR(sv))
#define CHR_DIST(a,b) (UTF ? utf8_distance(a,b) : a - b)

/* Allow for side effects in s */
#define REGC(c,s) STMT_START { if (!SIZE_ONLY) *(s) = (c); else (s);} STMT_END

static void clear_re(pTHXo_ void *r);

/* Mark that we cannot extend a found fixed substring at this point.
   Updata the longest found anchored substring and the longest found
   floating substrings if needed. */
d197 1
a197 1
S_scan_commit(pTHX_ scan_data_t *data)
d199 2
a200 3
    dTHR;
    STRLEN l = CHR_SVLEN(data->last_found);
    STRLEN old_l = CHR_SVLEN(*data->longest);
d211 1
a211 2
	}
	else {
a227 125
/* Can match anything (initialization) */
STATIC void
S_cl_anything(pTHX_ struct regnode_charclass_class *cl)
{
    int value;

    ANYOF_CLASS_ZERO(cl);
    for (value = 0; value < 256; ++value)
	ANYOF_BITMAP_SET(cl, value);
    cl->flags = ANYOF_EOS;
    if (LOC)
	cl->flags |= ANYOF_LOCALE;
}

/* Can match anything (initialization) */
STATIC int
S_cl_is_anything(pTHX_ struct regnode_charclass_class *cl)
{
    int value;

    for (value = 0; value < ANYOF_MAX; value += 2)
	if (ANYOF_CLASS_TEST(cl, value) && ANYOF_CLASS_TEST(cl, value + 1))
	    return 1;
    for (value = 0; value < 256; ++value)
	if (!ANYOF_BITMAP_TEST(cl, value))
	    return 0;
    return 1;
}

/* Can match anything (initialization) */
STATIC void
S_cl_init(pTHX_ struct regnode_charclass_class *cl)
{
    Zero(cl, 1, struct regnode_charclass_class);
    cl->type = ANYOF;
    cl_anything(cl);
}

STATIC void
S_cl_init_zero(pTHX_ struct regnode_charclass_class *cl)
{
    Zero(cl, 1, struct regnode_charclass_class);
    cl->type = ANYOF;
    cl_anything(cl);
    if (LOC)
	cl->flags |= ANYOF_LOCALE;
}

/* 'And' a given class with another one.  Can create false positives */
/* We assume that cl is not inverted */
STATIC void
S_cl_and(pTHX_ struct regnode_charclass_class *cl,
	 struct regnode_charclass_class *and_with)
{
    if (!(and_with->flags & ANYOF_CLASS)
	&& !(cl->flags & ANYOF_CLASS)
	&& (and_with->flags & ANYOF_LOCALE) == (cl->flags & ANYOF_LOCALE)
	&& !(and_with->flags & ANYOF_FOLD)
	&& !(cl->flags & ANYOF_FOLD)) {
	int i;

	if (and_with->flags & ANYOF_INVERT)
	    for (i = 0; i < ANYOF_BITMAP_SIZE; i++)
		cl->bitmap[i] &= ~and_with->bitmap[i];
	else
	    for (i = 0; i < ANYOF_BITMAP_SIZE; i++)
		cl->bitmap[i] &= and_with->bitmap[i];
    } /* XXXX: logic is complicated otherwise, leave it along for a moment. */
    if (!(and_with->flags & ANYOF_EOS))
	cl->flags &= ~ANYOF_EOS;
}

/* 'OR' a given class with another one.  Can create false positives */
/* We assume that cl is not inverted */
STATIC void
S_cl_or(pTHX_ struct regnode_charclass_class *cl, struct regnode_charclass_class *or_with)
{
    if (or_with->flags & ANYOF_INVERT) {
	/* We do not use
	 * (B1 | CL1) | (!B2 & !CL2) = (B1 | !B2 & !CL2) | (CL1 | (!B2 & !CL2))
	 *   <= (B1 | !B2) | (CL1 | !CL2)
	 * which is wasteful if CL2 is small, but we ignore CL2:
	 *   (B1 | CL1) | (!B2 & !CL2) <= (B1 | CL1) | !B2 = (B1 | !B2) | CL1
	 * XXXX Can we handle case-fold?  Unclear:
	 *   (OK1(i) | OK1(i')) | !(OK1(i) | OK1(i')) =
	 *   (OK1(i) | OK1(i')) | (!OK1(i) & !OK1(i'))
	 */
	if ( (or_with->flags & ANYOF_LOCALE) == (cl->flags & ANYOF_LOCALE)
	     && !(or_with->flags & ANYOF_FOLD)
	     && !(cl->flags & ANYOF_FOLD) ) {
	    int i;

	    for (i = 0; i < ANYOF_BITMAP_SIZE; i++)
		cl->bitmap[i] |= ~or_with->bitmap[i];
	} /* XXXX: logic is complicated otherwise */
	else {
	    cl_anything(cl);
	}
    } else {
	/* (B1 | CL1) | (B2 | CL2) = (B1 | B2) | (CL1 | CL2)) */
	if ( (or_with->flags & ANYOF_LOCALE) == (cl->flags & ANYOF_LOCALE)
	     && (!(or_with->flags & ANYOF_FOLD) 
		 || (cl->flags & ANYOF_FOLD)) ) {
	    int i;

	    /* OR char bitmap and class bitmap separately */
	    for (i = 0; i < ANYOF_BITMAP_SIZE; i++)
		cl->bitmap[i] |= or_with->bitmap[i];
	    if (or_with->flags & ANYOF_CLASS) {
		for (i = 0; i < ANYOF_CLASSBITMAP_SIZE; i++)
		    cl->classflags[i] |= or_with->classflags[i];
		cl->flags |= ANYOF_CLASS;
	    }
	}
	else { /* XXXX: logic is complicated, leave it along for a moment. */
	    cl_anything(cl);
	}
    }
    if (or_with->flags & ANYOF_EOS)
	cl->flags |= ANYOF_EOS;
}

/* REx optimizer.  Converts nodes into quickier variants "in place".
   Finds fixed substrings.  */

d232 1
a232 1
S_study_chunk(pTHX_ regnode **scanp, I32 *deltap, regnode *last, scan_data_t *data, U32 flags)
a244 1
    struct regnode_charclass_class and_with; /* Valid if flags & SCF_DO_STCLASS_OR */
d249 1
a249 2
	if (PL_regkind[(U8)OP(scan)] == EXACT) {
	    /* Merge several consecutive EXACTish nodes into one. */
d256 1
a256 1
	    next = scan + NODE_SZ_STR(scan);
d259 1
a259 1
		   ( PL_regkind[(U8)OP(n)] == NOTHING || 
d265 1
a265 1
		if (PL_regkind[(U8)OP(n)] == NOTHING) {
d273 2
a274 3
		}
		else {
		    int oldl = STR_LEN(scan);
d277 1
a277 1
		    if (oldl + STR_LEN(n) > U8_MAX) 
d280 2
a281 2
		    STR_LEN(scan) += STR_LEN(n);
		    next = n + NODE_SZ_STR(n);
d283 2
a284 2
		    Move(STRING(n), STRING(scan) + oldl,
			 STR_LEN(n), char);
d294 1
a294 1
	    n = scan + NODE_SZ_STR(scan);
d296 5
a300 1
		if (PL_regkind[(U8)OP(n)] != NOTHING || OP(n) == NOTHING) {
d306 2
a307 1
#endif
a308 2
	/* Follow the next-chain of the current node and optimize
	   away all the NOTHINGs from it.  */
d320 1
a320 1
		   && ((PL_regkind[(U8)OP(n)] == NOTHING && (noff = NEXT_OFF(n)))
a328 2
	/* The principal pseudo-switch.  Cannot be a switch, since we
	   look into several different things.  */
a335 1
		struct regnode_charclass_class accum;
d337 2
a338 4
		if (flags & SCF_DO_SUBSTR) /* XXXX Add !SUSPEND? */
		    scan_commit(data);	/* Cannot merge strings after this. */
		if (flags & SCF_DO_STCLASS)
		    cl_init_zero(&accum);
d340 1
a340 2
		    I32 deltanext, minnext, f = 0;
		    struct regnode_charclass_class this_class;
a343 2
		    if (data)
			data_fake.whilem_c = data->whilem_c;
d348 1
a348 6
		    if (flags & SCF_DO_STCLASS) {
			cl_init(&this_class);
			data_fake.start_class = &this_class;
			f = SCF_DO_STCLASS_AND;
		    }		    
		    /* we suppose the run is continuous, last=next...*/
d350 1
a350 1
					  &data_fake, f);
a361 4
		    if (data)
			data->whilem_c = data_fake.whilem_c;
		    if (flags & SCF_DO_STCLASS)
			cl_or(&accum, &this_class);
d375 1
a375 26
		if (flags & SCF_DO_STCLASS_OR) {
		    cl_or(data->start_class, &accum);
		    if (min1) {
			cl_and(data->start_class, &and_with);
			flags &= ~SCF_DO_STCLASS;
		    }
		}
		else if (flags & SCF_DO_STCLASS_AND) {
		    if (min1) {
			cl_and(data->start_class, &accum);
			flags &= ~SCF_DO_STCLASS;
		    }
		    else {
			/* Switch to OR mode: cache the old value of 
			 * data->start_class */
			StructCopy(data->start_class, &and_with,
				   struct regnode_charclass_class);
			flags &= ~SCF_DO_STCLASS_AND;
			StructCopy(&accum, data->start_class,
				   struct regnode_charclass_class);
			flags |= SCF_DO_STCLASS_OR;
			data->start_class->flags |= ANYOF_EOS;
		    }
		}
	    }
	    else if (code == BRANCHJ)	/* single branch is optimized. */
d380 2
a381 14
	}
	else if (OP(scan) == EXACT) {
	    I32 l = STR_LEN(scan);
	    if (UTF) {
		unsigned char *s = (unsigned char *)STRING(scan);
		unsigned char *e = s + l;
		I32 newl = 0;
		while (s < e) {
		    newl++;
		    s += UTF8SKIP(s);
		}
		l = newl;
	    }
	    min += l;
d383 2
d392 1
a392 1
		sv_catpvn(data->last_found, STRING(scan), STR_LEN(scan));
d397 1
a397 28
	    if (flags & SCF_DO_STCLASS_AND) {
		/* Check whether it is compatible with what we know already! */
		int compat = 1;

		if (!(data->start_class->flags & (ANYOF_CLASS | ANYOF_LOCALE)) 
		    && !ANYOF_BITMAP_TEST(data->start_class, *STRING(scan))
		    && (!(data->start_class->flags & ANYOF_FOLD)
			|| !ANYOF_BITMAP_TEST(data->start_class,
					      PL_fold[*(U8*)STRING(scan)])))
		    compat = 0;
		ANYOF_CLASS_ZERO(data->start_class);
		ANYOF_BITMAP_ZERO(data->start_class);
		if (compat)
		    ANYOF_BITMAP_SET(data->start_class, *STRING(scan));
		data->start_class->flags &= ~ANYOF_EOS;
	    }
	    else if (flags & SCF_DO_STCLASS_OR) {
		/* false positive possible if the class is case-folded */
		ANYOF_BITMAP_SET(data->start_class, *STRING(scan));	
		data->start_class->flags &= ~ANYOF_EOS;
		cl_and(data->start_class, &and_with);
	    }
	    flags &= ~SCF_DO_STCLASS;
	}
	else if (PL_regkind[(U8)OP(scan)] == EXACT) { /* But OP != EXACT! */
	    I32 l = STR_LEN(scan);

	    /* Search for fixed substrings supports EXACT only. */
d400 1
a400 11
	    if (UTF) {
		unsigned char *s = (unsigned char *)STRING(scan);
		unsigned char *e = s + l;
		I32 newl = 0;
		while (s < e) {
		    newl++;
		    s += UTF8SKIP(s);
		}
		l = newl;
	    }
	    min += l;
d402 2
a403 32
		data->pos_min += l;
	    if (flags & SCF_DO_STCLASS_AND) {
		/* Check whether it is compatible with what we know already! */
		int compat = 1;

		if (!(data->start_class->flags & (ANYOF_CLASS | ANYOF_LOCALE)) 
		    && !ANYOF_BITMAP_TEST(data->start_class, *STRING(scan))
		    && !ANYOF_BITMAP_TEST(data->start_class, 
					  PL_fold[*(U8*)STRING(scan)]))
		    compat = 0;
		ANYOF_CLASS_ZERO(data->start_class);
		ANYOF_BITMAP_ZERO(data->start_class);
		if (compat) {
		    ANYOF_BITMAP_SET(data->start_class, *STRING(scan));
		    data->start_class->flags &= ~ANYOF_EOS;
		    data->start_class->flags |= ANYOF_FOLD;
		    if (OP(scan) == EXACTFL)
			data->start_class->flags |= ANYOF_LOCALE;
		}
	    }
	    else if (flags & SCF_DO_STCLASS_OR) {
		if (data->start_class->flags & ANYOF_FOLD) {
		    /* false positive possible if the class is case-folded.
		       Assume that the locale settings are the same... */
		    ANYOF_BITMAP_SET(data->start_class, *STRING(scan));	
		    data->start_class->flags &= ~ANYOF_EOS;
		}
		cl_and(data->start_class, &and_with);
	    }
	    flags &= ~SCF_DO_STCLASS;
	}
	else if (strchr((char*)PL_varies,OP(scan))) {
a404 1
	    I32 f = flags;
d406 3
a408 5
	    struct regnode_charclass_class this_class;
	    struct regnode_charclass_class *oclass = NULL;

	    switch (PL_regkind[(U8)OP(scan)]) {
	    case WHILEM:		/* End of (?:...)* . */
d412 1
a412 1
		if (flags & (SCF_DO_SUBSTR | SCF_DO_STCLASS)) {
d414 1
a414 1
		    if (OP(next) == EXACT || (flags & SCF_DO_STCLASS)) {
a426 7
		if (flags & SCF_DO_STCLASS) {
		    mincount = 0;
		    maxcount = REG_INFTY; 
		    next = regnext(scan);
		    scan = NEXTOPER(scan);
		    goto do_curly;
		}
d430 1
a430 1
		    scan_commit(data);	/* Cannot extend fixed substrings */
d441 1
a441 1
		    if (mincount == 0) scan_commit(data); /* Cannot extend fixed substrings */
a449 8
		if (flags & SCF_DO_STCLASS) {
		    cl_init(&this_class);
		    oclass = data->start_class;
		    data->start_class = &this_class;
		    f |= SCF_DO_STCLASS_AND;
		    f &= ~SCF_DO_STCLASS_OR;
		}

d453 1
a453 28
					? (f & ~SCF_DO_SUBSTR) : f);

		if (flags & SCF_DO_STCLASS)
		    data->start_class = oclass;
		if (mincount == 0 || minnext == 0) {
		    if (flags & SCF_DO_STCLASS_OR) {
			cl_or(data->start_class, &this_class);
		    }
		    else if (flags & SCF_DO_STCLASS_AND) {
			/* Switch to OR mode: cache the old value of 
			 * data->start_class */
			StructCopy(data->start_class, &and_with,
				   struct regnode_charclass_class);
			flags &= ~SCF_DO_STCLASS_AND;
			StructCopy(&this_class, data->start_class,
				   struct regnode_charclass_class);
			flags |= SCF_DO_STCLASS_OR;
			data->start_class->flags |= ANYOF_EOS;
		    }
		} else {		/* Non-zero len */
		    if (flags & SCF_DO_STCLASS_OR) {
			cl_or(data->start_class, &this_class);
			cl_and(data->start_class, &and_with);
		    }
		    else if (flags & SCF_DO_STCLASS_AND)
			cl_and(data->start_class, &this_class);
		    flags &= ~SCF_DO_STCLASS;
		}
d456 1
a456 1
		if (ckWARN(WARN_REGEXP) && (minnext + deltanext == 0) 
d458 2
a459 3
		    && maxcount <= REG_INFTY/3) /* Complement check for big count */
		    Perl_warner(aTHX_ WARN_REGEXP,
				"Strange *+?{} on zero-length expression");
d461 3
a463 3
		is_inf_internal |= ((maxcount == REG_INFTY 
				     && (minnext + deltanext) > 0)
				    || deltanext == I32_MAX);
d478 3
a480 3
		    if (!strchr((char*)PL_simple,OP(nxt))
			&& !(PL_regkind[(U8)OP(nxt)] == EXACT
			     && STR_LEN(nxt) == 1)) 
d549 1
a549 2
		    }
		    else
a551 10
		else if (OP(oscan) == CURLYX && data && ++data->whilem_c < 16) {
		    /* This stays as CURLYX, and can put the count/of pair. */
		    /* Find WHILEM (as in regexec.c) */
		    regnode *nxt = oscan + NEXT_OFF(oscan);

		    if (OP(PREVOPER(nxt)) == NOTHING) /* LONGJMP */
			nxt += ARG(nxt);
		    PREVOPER(nxt)->flags = data->whilem_c
			| (PL_reg_whilem_seen << 4); /* On WHILEM */
		}
a562 4
			I32 old = b - data->last_start_min;

			if (UTF)
			    old = utf8_hop((U8*)s, old) - (U8*)s;
d564 1
a564 1
			l -= old;
d566 1
a566 1
			last_str = newSVpvn(s  + old, l);
a586 2
			 /* Cannot extend fixed substrings found inside
			    the group.  */
d592 1
a592 1
				data->pos_min - CHR_SVLEN(last_str);
d596 1
a596 1
				- CHR_SVLEN(last_str);
d606 1
a606 1
		    while (PL_regkind[(U8)OP(next = regnext(oscan))] == NOTHING
d611 1
a611 1
	    default:			/* REF and CLUMP only? */
d613 1
a613 1
		    scan_commit(data);	/* Cannot expect anything... */
a616 3
		if (flags & SCF_DO_STCLASS_OR)
		    cl_anything(data->start_class);
		flags &= ~SCF_DO_STCLASS;
d619 1
a619 4
	}
	else if (strchr((char*)PL_simple,OP(scan)) || PL_regkind[(U8)OP(scan)] == ANYUTF8) {
	    int value;

d625 1
a625 206
	    if (flags & SCF_DO_STCLASS) {
		data->start_class->flags &= ~ANYOF_EOS;	/* No match on empty */

		/* Some of the logic below assumes that switching
		   locale on will only add false positives. */
		switch (PL_regkind[(U8)OP(scan)]) {
		case ANYUTF8:
		case SANY:
		case SANYUTF8:
		case ALNUMUTF8:
		case ANYOFUTF8:
		case ALNUMLUTF8:
		case NALNUMUTF8:
		case NALNUMLUTF8:
		case SPACEUTF8:
		case NSPACEUTF8:
		case SPACELUTF8:
		case NSPACELUTF8:
		case DIGITUTF8:
		case NDIGITUTF8:
		default:
		  do_default:
		    /* Perl_croak(aTHX_ "panic: unexpected simple REx opcode %d", OP(scan)); */
		    if (flags & SCF_DO_STCLASS_OR) /* Allow everything */
			cl_anything(data->start_class);
		    break;
		case REG_ANY:
		    if (OP(scan) == SANY)
			goto do_default;
		    if (flags & SCF_DO_STCLASS_OR) { /* Everything but \n */
			value = (ANYOF_BITMAP_TEST(data->start_class,'\n')
				 || (data->start_class->flags & ANYOF_CLASS));
			cl_anything(data->start_class);
		    }
		    if (flags & SCF_DO_STCLASS_AND || !value)
			ANYOF_BITMAP_CLEAR(data->start_class,'\n');
		    break;
		case ANYOF:
		    if (flags & SCF_DO_STCLASS_AND)
			cl_and(data->start_class,
			       (struct regnode_charclass_class*)scan);
		    else
			cl_or(data->start_class,
			      (struct regnode_charclass_class*)scan);
		    break;
		case ALNUM:
		    if (flags & SCF_DO_STCLASS_AND) {
			if (!(data->start_class->flags & ANYOF_LOCALE)) {
			    ANYOF_CLASS_CLEAR(data->start_class,ANYOF_NALNUM);
			    for (value = 0; value < 256; value++)
				if (!isALNUM(value))
				    ANYOF_BITMAP_CLEAR(data->start_class, value);
			}
		    }
		    else {
			if (data->start_class->flags & ANYOF_LOCALE)
			    ANYOF_CLASS_SET(data->start_class,ANYOF_ALNUM);
			else {
			    for (value = 0; value < 256; value++)
				if (isALNUM(value))
				    ANYOF_BITMAP_SET(data->start_class, value);			    
			}
		    }
		    break;
		case ALNUML:
		    if (flags & SCF_DO_STCLASS_AND) {
			if (data->start_class->flags & ANYOF_LOCALE)
			    ANYOF_CLASS_CLEAR(data->start_class,ANYOF_NALNUM);
		    }
		    else {
			ANYOF_CLASS_SET(data->start_class,ANYOF_ALNUM);
			data->start_class->flags |= ANYOF_LOCALE;
		    }
		    break;
		case NALNUM:
		    if (flags & SCF_DO_STCLASS_AND) {
			if (!(data->start_class->flags & ANYOF_LOCALE)) {
			    ANYOF_CLASS_CLEAR(data->start_class,ANYOF_ALNUM);
			    for (value = 0; value < 256; value++)
				if (isALNUM(value))
				    ANYOF_BITMAP_CLEAR(data->start_class, value);
			}
		    }
		    else {
			if (data->start_class->flags & ANYOF_LOCALE)
			    ANYOF_CLASS_SET(data->start_class,ANYOF_NALNUM);
			else {
			    for (value = 0; value < 256; value++)
				if (!isALNUM(value))
				    ANYOF_BITMAP_SET(data->start_class, value);			    
			}
		    }
		    break;
		case NALNUML:
		    if (flags & SCF_DO_STCLASS_AND) {
			if (data->start_class->flags & ANYOF_LOCALE)
			    ANYOF_CLASS_CLEAR(data->start_class,ANYOF_ALNUM);
		    }
		    else {
			data->start_class->flags |= ANYOF_LOCALE;
			ANYOF_CLASS_SET(data->start_class,ANYOF_NALNUM);
		    }
		    break;
		case SPACE:
		    if (flags & SCF_DO_STCLASS_AND) {
			if (!(data->start_class->flags & ANYOF_LOCALE)) {
			    ANYOF_CLASS_CLEAR(data->start_class,ANYOF_NSPACE);
			    for (value = 0; value < 256; value++)
				if (!isSPACE(value))
				    ANYOF_BITMAP_CLEAR(data->start_class, value);
			}
		    }
		    else {
			if (data->start_class->flags & ANYOF_LOCALE)
			    ANYOF_CLASS_SET(data->start_class,ANYOF_SPACE);
			else {
			    for (value = 0; value < 256; value++)
				if (isSPACE(value))
				    ANYOF_BITMAP_SET(data->start_class, value);			    
			}
		    }
		    break;
		case SPACEL:
		    if (flags & SCF_DO_STCLASS_AND) {
			if (data->start_class->flags & ANYOF_LOCALE)
			    ANYOF_CLASS_CLEAR(data->start_class,ANYOF_NSPACE);
		    }
		    else {
			data->start_class->flags |= ANYOF_LOCALE;
			ANYOF_CLASS_SET(data->start_class,ANYOF_SPACE);
		    }
		    break;
		case NSPACE:
		    if (flags & SCF_DO_STCLASS_AND) {
			if (!(data->start_class->flags & ANYOF_LOCALE)) {
			    ANYOF_CLASS_CLEAR(data->start_class,ANYOF_SPACE);
			    for (value = 0; value < 256; value++)
				if (isSPACE(value))
				    ANYOF_BITMAP_CLEAR(data->start_class, value);
			}
		    }
		    else {
			if (data->start_class->flags & ANYOF_LOCALE)
			    ANYOF_CLASS_SET(data->start_class,ANYOF_NSPACE);
			else {
			    for (value = 0; value < 256; value++)
				if (!isSPACE(value))
				    ANYOF_BITMAP_SET(data->start_class, value);			    
			}
		    }
		    break;
		case NSPACEL:
		    if (flags & SCF_DO_STCLASS_AND) {
			if (data->start_class->flags & ANYOF_LOCALE) {
			    ANYOF_CLASS_CLEAR(data->start_class,ANYOF_SPACE);
			    for (value = 0; value < 256; value++)
				if (!isSPACE(value))
				    ANYOF_BITMAP_CLEAR(data->start_class, value);
			}
		    }
		    else {
			data->start_class->flags |= ANYOF_LOCALE;
			ANYOF_CLASS_SET(data->start_class,ANYOF_NSPACE);
		    }
		    break;
		case DIGIT:
		    if (flags & SCF_DO_STCLASS_AND) {
			ANYOF_CLASS_CLEAR(data->start_class,ANYOF_NDIGIT);
			for (value = 0; value < 256; value++)
			    if (!isDIGIT(value))
				ANYOF_BITMAP_CLEAR(data->start_class, value);
		    }
		    else {
			if (data->start_class->flags & ANYOF_LOCALE)
			    ANYOF_CLASS_SET(data->start_class,ANYOF_DIGIT);
			else {
			    for (value = 0; value < 256; value++)
				if (isDIGIT(value))
				    ANYOF_BITMAP_SET(data->start_class, value);			    
			}
		    }
		    break;
		case NDIGIT:
		    if (flags & SCF_DO_STCLASS_AND) {
			ANYOF_CLASS_CLEAR(data->start_class,ANYOF_DIGIT);
			for (value = 0; value < 256; value++)
			    if (isDIGIT(value))
				ANYOF_BITMAP_CLEAR(data->start_class, value);
		    }
		    else {
			if (data->start_class->flags & ANYOF_LOCALE)
			    ANYOF_CLASS_SET(data->start_class,ANYOF_NDIGIT);
			else {
			    for (value = 0; value < 256; value++)
				if (!isDIGIT(value))
				    ANYOF_BITMAP_SET(data->start_class, value);			    
			}
		    }
		    break;
		}
		if (flags & SCF_DO_STCLASS_OR)
		    cl_and(data->start_class, &and_with);
		flags &= ~SCF_DO_STCLASS;
	    }
	}
	else if (PL_regkind[(U8)OP(scan)] == EOL && flags & SCF_DO_SUBSTR) {
d629 2
a630 4
	}
	else if (  PL_regkind[(U8)OP(scan)] == BRANCHJ
		 /* Lookbehind, or need to calculate parens/evals/stclass: */
		   && (scan->flags || data || (flags & SCF_DO_STCLASS))
a631 1
	    /* Lookahead/lookbehind */
a633 2
	    struct regnode_charclass_class intrnl;
	    int f = 0;
a635 8
	    if (data)
		data_fake.whilem_c = data->whilem_c;
	    if ( flags & SCF_DO_STCLASS && !scan->flags
		 && OP(scan) == IFMATCH ) { /* Lookahead */
		cl_init(&intrnl);
		data_fake.start_class = &intrnl;
		f = SCF_DO_STCLASS_AND;
	    }
d638 1
a638 1
	    minnext = study_chunk(&nscan, &deltanext, last, &data_fake, f);
d642 2
a643 3
		}
		else if (minnext > U8_MAX) {
		    FAIL2("lookbehind longer than %"UVuf" not implemented", (UV)U8_MAX);
d651 1
a651 11
	    if (data)
		data->whilem_c = data_fake.whilem_c;
	    if (f) {
		int was = (data->start_class->flags & ANYOF_EOS);

		cl_and(data->start_class, &intrnl);
		if (was)
		    data->start_class->flags |= ANYOF_EOS;
	    }
	}
	else if (OP(scan) == OPEN) {
d653 1
a653 2
	}
	else if (OP(scan) == CLOSE && ARG(scan) == is_par) {
d658 1
a658 2
	}
	else if (OP(scan) == EVAL) {
a661 10
	else if (OP(scan) == LOGICAL && scan->flags == 2) { /* Embedded follows */
		if (flags & SCF_DO_SUBSTR) {
		    scan_commit(data);
		    data->longest = &(data->longest_float);
		}
		is_inf = is_inf_internal = 1;
		if (flags & SCF_DO_STCLASS_OR) /* Allow everything */
		    cl_anything(data->start_class);
		flags &= ~SCF_DO_STCLASS;
	}
d676 1
a676 2
    }
    else if (pars && data) {
a679 2
    if (flags & SCF_DO_STCLASS_OR)
	cl_and(data->start_class, &and_with);
d684 1
a684 1
S_add_data(pTHX_ I32 n, char *s)
d693 1
a693 2
    }
    else {
a702 25
void
Perl_reginitcolors(pTHX)
{
    dTHR;
    int i = 0;
    char *s = PerlEnv_getenv("PERL_RE_COLORS");
	    
    if (s) {
	PL_colors[0] = s = savepv(s);
	while (++i < 6) {
	    s = strchr(s, '\t');
	    if (s) {
		*s = '\0';
		PL_colors[i] = ++s;
	    }
	    else
		PL_colors[i] = s = "";
	}
    } else {
	while (i < 6) 
	    PL_colors[i++] = "";
    }
    PL_colorset = 1;
}

d719 1
a719 1
Perl_pregcomp(pTHX_ char *exp, char *xend, PMOP *pm)
d724 3
a731 1
    scan_data_t data;
a735 6
    if (pm->op_pmdynflags & PMdf_UTF8) {
	PL_reg_flags |= RF_utf8;
    }
    else
	PL_reg_flags = 0;

d737 2
a738 4
    DEBUG_r(if (!PL_colorset) reginitcolors());
    DEBUG_r(PerlIO_printf(Perl_debug_log, "%sCompiling REx%s `%s%*s%s'\n",
		      PL_colors[4],PL_colors[5],PL_colors[0],
		      (int)(xend - exp), PL_regprecomp, PL_colors[1]));
d754 1
a754 5
    PL_reg_whilem_seen = 0;
#if 0 /* REGC() is (currently) a NOP at the first pass.
       * Clever compilers notice this and complain. --jhi */
    REGC((U8)REG_MAGIC, (char*)PL_regcode);
#endif
d760 26
a785 1
    DEBUG_r(PerlIO_printf(Perl_debug_log, "size %"IVdf" ", (IV)PL_regsize));
a792 2
    if (PL_reg_whilem_seen > 15)
	PL_reg_whilem_seen = 15;
a798 4
#ifdef DEBUGGING
    /* avoid reading uninitialized memory in DEBUGGING code in study_chunk() */
    Zero(r, sizeof(regexp) + (unsigned)PL_regsize * sizeof(regnode), char);
#endif
d802 2
a803 8
    r->subbeg = NULL;
    r->reganch = pm->op_pmflags & PMf_COMPILETIME;
    r->nparens = PL_regnpar - 1;	/* set early to validate backrefs */

    r->substrs = 0;			/* Useful during FAIL. */
    r->startp = 0;			/* Useful during FAIL. */
    r->endp = 0;			/* Useful during FAIL. */

d814 1
a814 1
    REGC((U8)REG_MAGIC, (char*) PL_regcode++);
d820 1
a820 1
    r->reganch = pm->op_pmflags & PMf_COMPILETIME; /* Again? */
a821 2
    if (UTF)
	r->reganch |= ROPT_UTF8;
d823 1
a823 2
    if (PL_regnaughty >= 10)	/* Probably an expensive pattern. */
	r->reganch |= ROPT_NAUGHTY;
a829 2
    StructCopy(&zero_scan_data, &data, scan_data_t);
    /* XXXX Should not we check for something else?  Usually it is OPEN1... */
d831 1
a833 2
	struct regnode_charclass_class ch_class;
	int stclass_flag;
d835 1
a838 1
	       /* An OR of *one* alternative - should not happen now. */
d842 1
a842 2
	       /* An {n,m} with n>0 */
	    (PL_regkind[(U8)OP(first)] == CURLY && ARG1(first) > 0) ) {
d852 2
a853 7
	if (PL_regkind[(U8)OP(first)] == EXACT) {
	    if (OP(first) == EXACT);	/* Empty, get anchored substr later. */
	    else if ((OP(first) == EXACTF || OP(first) == EXACTFL)
		     && !UTF)
		r->regstclass = first;
	}
	else if (strchr((char*)PL_simple,OP(first)))
d855 2
a856 2
	else if (PL_regkind[(U8)OP(first)] == BOUND ||
		 PL_regkind[(U8)OP(first)] == NBOUND)
d858 2
a859 6
	else if (PL_regkind[(U8)OP(first)] == BOL) {
	    r->reganch |= (OP(first) == MBOL
			   ? ROPT_ANCH_MBOL
			   : (OP(first) == SBOL
			      ? ROPT_ANCH_SBOL
			      : ROPT_ANCH_BOL));
d869 1
a869 1
	    PL_regkind[(U8)OP(NEXTOPER(first))] == REG_ANY) &&
d873 1
a873 8
	    int type = OP(NEXTOPER(first));

	    if (type == REG_ANY || type == ANYUTF8)
		type = ROPT_ANCH_MBOL;
	    else
		type = ROPT_ANCH_SBOL;

	    r->reganch |= type | ROPT_IMPLICIT;
d877 2
a878 4
	if (sawplus && (!sawopen || !PL_regsawback) 
	    && !(PL_regseen & REG_SEEN_EVAL)) /* May examine pos and $& */
	    /* x+ must match at the 1st pos of run of x's */
	    r->reganch |= ROPT_SKIP;
d881 2
a882 2
	DEBUG_r(PerlIO_printf(Perl_debug_log, "first at %"IVdf"\n", 
			      (IV)(first - scan + 1)));
d896 3
a898 3
	data.longest_fixed = newSVpvn("",0);
	data.longest_float = newSVpvn("",0);
	data.last_found = newSVpvn("",0);
d901 1
a901 7
	if (!r->regstclass) {
	    cl_init(&ch_class);
	    data.start_class = &ch_class;
	    stclass_flag = SCF_DO_STCLASS_AND;
	} else				/* XXXX Check for BOUND? */
	    stclass_flag = 0;

d903 1
a903 1
			     &data, SCF_DO_SUBSTR | stclass_flag);
d912 1
a912 1
	longest_float_length = CHR_SVLEN(data.longest_float);
d917 1
a917 3
	    int t;

	    if (SvCUR(data.longest_fixed) 			/* ok to leave SvCUR */
d920 2
a921 2
		    goto remove_float;		/* As in (a)+. */

d925 7
a931 6
	    t = (data.flags & SF_FL_BEFORE_EOL /* Can't have SEOL and MULTI */
		       && (!(data.flags & SF_FL_BEFORE_MEOL)
			   || (PL_regflags & PMf_MULTILINE)));
	    fbm_compile(r->float_substr, t ? FBMcf_TAIL : 0);
	}
	else {
d938 1
a938 1
	longest_fixed_length = CHR_SVLEN(data.longest_fixed);
a942 2
	    int t;

d945 7
a951 6
	    t = (data.flags & SF_FIX_BEFORE_EOL /* Can't have SEOL and MULTI */
		 && (!(data.flags & SF_FIX_BEFORE_MEOL)
		     || (PL_regflags & PMf_MULTILINE)));
	    fbm_compile(r->anchored_substr, t ? FBMcf_TAIL : 0);
	}
	else {
a955 22
	if (r->regstclass 
	    && (OP(r->regstclass) == REG_ANY || OP(r->regstclass) == ANYUTF8
		|| OP(r->regstclass) == SANYUTF8 || OP(r->regstclass) == SANY))
	    r->regstclass = NULL;
	if ((!r->anchored_substr || r->anchored_offset) && stclass_flag
	    && !(data.start_class->flags & ANYOF_EOS)
	    && !cl_is_anything(data.start_class)) {
	    SV *sv;
	    I32 n = add_data(1, "f");

	    New(1006, PL_regcomp_rx->data->data[n], 1, 
		struct regnode_charclass_class);
	    StructCopy(data.start_class,
		       (struct regnode_charclass_class*)PL_regcomp_rx->data->data[n],
		       struct regnode_charclass_class);
	    r->regstclass = (regnode*)PL_regcomp_rx->data->data[n];
	    r->reganch &= ~ROPT_SKIP;	/* Used in find_byclass(). */
	    DEBUG_r((sv = sv_newmortal(),
		     regprop(sv, (regnode*)data.start_class),
		     PerlIO_printf(Perl_debug_log, "synthetic stclass `%s'.\n",
				   SvPVX(sv))));
	}
d963 1
a963 2
	}
	else {
d968 1
a968 9
	/* XXXX Currently intuiting is not compatible with ANCH_GPOS.
	   This should be changed ASAP!  */
	if (r->check_substr && !(r->reganch & ROPT_ANCH_GPOS)) {
	    r->reganch |= RE_USE_INTUIT;
	    if (SvTAIL(r->check_substr))
		r->reganch |= RE_INTUIT_TAIL;
	}
    }
    else {
a970 1
	struct regnode_charclass_class ch_class;
d974 1
a974 3
	cl_init(&ch_class);
	data.start_class = &ch_class;
	minlen = study_chunk(&scan, &fake, scan + PL_regsize, &data, SCF_DO_STCLASS_AND);
a975 17
	if (!(data.start_class->flags & ANYOF_EOS)
	    && !cl_is_anything(data.start_class)) {
	    SV *sv;
	    I32 n = add_data(1, "f");

	    New(1006, PL_regcomp_rx->data->data[n], 1, 
		struct regnode_charclass_class);
	    StructCopy(data.start_class,
		       (struct regnode_charclass_class*)PL_regcomp_rx->data->data[n],
		       struct regnode_charclass_class);
	    r->regstclass = (regnode*)PL_regcomp_rx->data->data[n];
	    r->reganch &= ~ROPT_SKIP;	/* Used in find_byclass(). */
	    DEBUG_r((sv = sv_newmortal(),
		     regprop(sv, (regnode*)data.start_class),
		     PerlIO_printf(Perl_debug_log, "synthetic stclass `%s'.\n",
				   SvPVX(sv))));
	}
d985 2
a986 2
    Newz(1002, r->startp, PL_regnpar, I32);
    Newz(1002, r->endp, PL_regnpar, I32);
d1001 1
a1001 1
S_reg(pTHX_ I32 paren, I32 *flagp)
a1019 1
	    int logical = 0;
a1049 9
	    case 'p':
		if (SIZE_ONLY)
		    Perl_warner(aTHX_ WARN_REGEXP,
				"(?p{}) is deprecated - use (??{})");
		/* FALL THROUGH*/
	    case '?':
		logical = 1;
		paren = *PL_regcomp_parse++;
		/* FALL THROUGH */
d1076 1
a1076 1
			sv = newSVpvn(s, PL_regcomp_parse - 1 - s);
d1078 1
a1078 1
			sv = newSVpvn("", 0);
d1082 1
a1082 1
		    n = add_data(3, "nop");
d1084 2
a1085 2
		    PL_regcomp_rx->data->data[n+1] = (void*)sop;
		    PL_regcomp_rx->data->data[n+2] = (void*)av;
d1087 2
a1088 4
		}
		else {						/* First pass */
		    if (PL_reginterp_cnt < ++PL_seen_evals
			&& PL_curcop != &PL_compiling)
a1096 7
		if (logical) {
		    ret = reg_node(LOGICAL);
		    if (!SIZE_ONLY)
			ret->flags = 2;
		    regtail(ret, reganode(EVAL, n));
		    return ret;
		}
a1107 2
			if (!SIZE_ONLY)
			    ret->flags = 1;
d1111 1
a1111 2
		}
		else if (PL_regcomp_parse[0] >= '1' && PL_regcomp_parse[0] <= '9' ) {
d1133 1
a1133 1
		 	if (flags&HASWIDTH)
d1136 1
a1136 2
		    }
		    else
d1145 1
a1145 2
		    }
		    else
d1148 1
a1148 2
		}
		else {
d1189 2
a1190 3
    }
    else
	ret = NULL;
d1199 1
a1199 2
	}
	else
d1204 1
a1204 2
    }
    else if (paren == ':') {
d1209 1
a1209 2
    }
    else if (paren != '?')		/* Not Conditional */
d1282 3
a1284 7
    if (paren) {
	PL_regflags = oregflags;
	if (PL_regcomp_parse >= PL_regxend || *nextchar() != ')') {
	    FAIL("unmatched () in regexp");
	}
    }
    else if (!paren && PL_regcomp_parse < PL_regxend) {
d1287 1
a1287 2
	}
	else
d1291 3
d1304 1
a1304 1
S_regbranch(pTHX_ I32 *flagp, I32 first)
d1335 1
a1335 2
	}
	else if (ret == NULL)
d1369 1
a1369 1
S_regpiece(pTHX_ I32 *flagp)
d1425 2
a1426 4
		regnode *w = reg_node(WHILEM);

		w->flags = 0;
		regtail(ret, w);
d1437 1
a1437 2
		    PL_reg_whilem_seen++, PL_extralen += 3;
		PL_regnaughty += 4 + PL_regnaughty;	/* compound interest */
d1478 1
a1478 2
    }
    else if (op == '+' && (flags&SIMPLE)) {
d1486 1
a1486 2
    }
    else if (op == '?') {
d1491 2
a1492 2
    if (ckWARN(WARN_REGEXP) && !SIZE_ONLY && !(flags&HASWIDTH) && max > REG_INFTY/3) {
	Perl_warner(aTHX_ WARN_REGEXP, "%.*s matches null string many times",
d1518 1
a1518 1
S_regatom(pTHX_ I32 *flagp)
d1551 4
a1554 14
	if (UTF) {
	    if (PL_regflags & PMf_SINGLELINE)
		ret = reg_node(SANYUTF8);
	    else
		ret = reg_node(ANYUTF8);
	    *flagp |= HASWIDTH;
	}
	else {
	    if (PL_regflags & PMf_SINGLELINE)
		ret = reg_node(SANY);
	    else
		ret = reg_node(REG_ANY);
	    *flagp |= HASWIDTH|SIMPLE;
	}
d1556 1
d1560 1
a1560 4
	ret = (UTF ? regclassutf8() : regclass());
	if (*PL_regcomp_parse != ']')
	    FAIL("unmatched [] in regexp");
	nextchar();
a1617 12
	case 'C':
	    ret = reg_node(SANY);
	    *flagp |= HASWIDTH|SIMPLE;
	    nextchar();
	    break;
	case 'X':
	    ret = reg_node(CLUMP);
	    *flagp |= HASWIDTH;
	    nextchar();
	    if (UTF && !PL_utf8_mark)
		is_utf8_mark((U8*)"~");		/* preload table */
	    break;
d1619 1
a1619 4
	    ret = reg_node(
		UTF
		    ? (LOC ? ALNUMLUTF8 : ALNUMUTF8)
		    : (LOC ? ALNUML     : ALNUM));
a1621 2
	    if (UTF && !PL_utf8_alnum)
		is_utf8_alnum((U8*)"a");	/* preload table */
d1624 1
a1624 4
	    ret = reg_node(
		UTF
		    ? (LOC ? NALNUMLUTF8 : NALNUMUTF8)
		    : (LOC ? NALNUML     : NALNUM));
a1626 2
	    if (UTF && !PL_utf8_alnum)
		is_utf8_alnum((U8*)"a");	/* preload table */
d1630 1
a1630 5
	    PL_regseen |= REG_SEEN_LOOKBEHIND;
	    ret = reg_node(
		UTF
		    ? (LOC ? BOUNDLUTF8 : BOUNDUTF8)
		    : (LOC ? BOUNDL     : BOUND));
a1632 2
	    if (UTF && !PL_utf8_alnum)
		is_utf8_alnum((U8*)"a");	/* preload table */
d1636 1
a1636 5
	    PL_regseen |= REG_SEEN_LOOKBEHIND;
	    ret = reg_node(
		UTF
		    ? (LOC ? NBOUNDLUTF8 : NBOUNDUTF8)
		    : (LOC ? NBOUNDL     : NBOUND));
a1638 2
	    if (UTF && !PL_utf8_alnum)
		is_utf8_alnum((U8*)"a");	/* preload table */
d1641 1
a1641 4
	    ret = reg_node(
		UTF
		    ? (LOC ? SPACELUTF8 : SPACEUTF8)
		    : (LOC ? SPACEL     : SPACE));
a1643 2
	    if (UTF && !PL_utf8_space)
		is_utf8_space((U8*)" ");	/* preload table */
d1646 1
a1646 4
	    ret = reg_node(
		UTF
		    ? (LOC ? NSPACELUTF8 : NSPACEUTF8)
		    : (LOC ? NSPACEL     : NSPACE));
a1648 2
	    if (UTF && !PL_utf8_space)
		is_utf8_space((U8*)" ");	/* preload table */
d1651 1
a1651 1
	    ret = reg_node(UTF ? DIGITUTF8 : DIGIT);
a1653 2
	    if (UTF && !PL_utf8_digit)
		is_utf8_digit((U8*)"1");	/* preload table */
d1656 1
a1656 1
	    ret = reg_node(UTF ? NDIGITUTF8 : NDIGIT);
a1658 25
	    if (UTF && !PL_utf8_digit)
		is_utf8_digit((U8*)"1");	/* preload table */
	    break;
	case 'p':
	case 'P':
	    {	/* a lovely hack--pretend we saw [\pX] instead */
		char* oldregxend = PL_regxend;

		if (PL_regcomp_parse[1] == '{') {
		    PL_regxend = strchr(PL_regcomp_parse, '}');
		    if (!PL_regxend)
			FAIL("Missing right brace on \\p{}");
		    PL_regxend++;
		}
		else
		    PL_regxend = PL_regcomp_parse + 2;
		PL_regcomp_parse--;

		ret = regclassutf8();

		PL_regxend = oldregxend;
		PL_regcomp_parse--;
		nextchar();
		*flagp |= HASWIDTH|SIMPLE;
	    }
d1681 2
a1682 2
		    ret = reganode(FOLD
				   ? (LOC ? REFFL : REFF)
a1696 2
	    /* Do not generate `unrecognized' warnings here, we fall
	       back into the quick-grab loop below */
d1711 1
a1711 1
	    register UV ender;
d1719 2
a1720 2
	    ret = reg_node(FOLD
			  ? (LOC ? EXACTFL : EXACTF)
d1722 2
a1723 1
	    s = STRING(ret);
a1754 2
		    case 'p':
		    case 'P':
d1774 1
a1774 5
#ifdef ASCIIish
			  ender = '\033';
#else
			  ender = '\047';
#endif
d1778 1
a1778 5
#ifdef ASCIIish
			  ender = '\007';
#else
			  ender = '\057';
#endif
d1782 2
a1783 20
			if (*++p == '{') {
			    char* e = strchr(p, '}');
	 
			    if (!e)
				FAIL("Missing right brace on \\x{}");
			    else if (UTF) {
				ender = (UV)scan_hex(p + 1, e - p, &numlen);
				if (numlen + len >= 127) {	/* numlen is generous */
				    p--;
				    goto loopdone;
				}
				p = e + 1;
			    }
			    else
				FAIL("Can't use \\x{} without 'use utf8' declaration");
			}
			else {
			    ender = (UV)scan_hex(p, 2, &numlen);
			    p += numlen;
			}
d1794 1
a1794 1
			    ender = (UV)scan_oct(p, 3, &numlen);
d1807 2
a1808 6
			if (!SIZE_ONLY && ckWARN(WARN_REGEXP) && isALPHA(*p))
			    Perl_warner(aTHX_ WARN_REGEXP, 
					"/%.127s/: Unrecognized escape \\%c passed through",
					PL_regprecomp,
					*p);
			goto normal_default;
d1812 1
a1812 7
		  normal_default:
		    if ((*p & 0xc0) == 0xc0 && UTF) {
			ender = utf8_to_uv((U8*)p, &numlen);
			p += numlen;
		    }
		    else
			ender = *p++;
a1816 6
		if (UTF && FOLD) {
		    if (LOC)
			ender = toLOWER_LC_uni(ender);
		    else
			ender = toLOWER_uni(ender);
		}
a1819 5
		    else if (ender >= 0x80 && UTF) {
			reguni(ender, s, &numlen);
			s += numlen;
			len += numlen;
		    }
d1822 1
a1822 1
			REGC(ender, s++);
d1826 1
a1826 7
		if (ender >= 0x80 && UTF) {
		    reguni(ender, s, &numlen);
		    s += numlen;
		    len += numlen - 1;
		}
		else
		    REGC(ender, s++);
d1838 7
a1844 5
		STR_LEN(ret) = len;
	    if (SIZE_ONLY)
		PL_regsize += STR_SZ(len);
	    else
		PL_regcode += STR_SZ(len);
d1853 1
a1853 1
S_regwhite(pTHX_ char *p, char *e)
a1868 142
/* Parse POSIX character classes: [[:foo:]], [[=foo=]], [[.foo.]].
   Character classes ([:foo:]) can also be negated ([:^foo:]).
   Returns a named class id (ANYOF_XXX) if successful, -1 otherwise.
   Equivalence classes ([=foo=]) and composites ([.foo.]) are parsed,
   but trigger warnings because they are currently unimplemented. */
STATIC I32
S_regpposixcc(pTHX_ I32 value)
{
    dTHR;
    char *posixcc = 0;
    I32 namedclass = OOB_NAMEDCLASS;

    if (value == '[' && PL_regcomp_parse + 1 < PL_regxend &&
	/* I smell either [: or [= or [. -- POSIX has been here, right? */
	(*PL_regcomp_parse == ':' ||
	 *PL_regcomp_parse == '=' ||
	 *PL_regcomp_parse == '.')) {
	char  c = *PL_regcomp_parse;
	char* s = PL_regcomp_parse++;
	    
	while (PL_regcomp_parse < PL_regxend && *PL_regcomp_parse != c)
	    PL_regcomp_parse++;
	if (PL_regcomp_parse == PL_regxend)
	    /* Grandfather lone [:, [=, [. */
	    PL_regcomp_parse = s;
	else {
	    char* t = PL_regcomp_parse++; /* skip over the c */

  	    if (*PL_regcomp_parse == ']') {
  		PL_regcomp_parse++; /* skip over the ending ] */
  		posixcc = s + 1;
		if (*s == ':') {
		    I32 complement = *posixcc == '^' ? *posixcc++ : 0;
		    I32 skip = 5; /* the most common skip */

		    switch (*posixcc) {
		    case 'a':
			if (strnEQ(posixcc, "alnum", 5))
			    namedclass =
				complement ? ANYOF_NALNUMC : ANYOF_ALNUMC;
			else if (strnEQ(posixcc, "alpha", 5))
			    namedclass =
				complement ? ANYOF_NALPHA : ANYOF_ALPHA;
			else if (strnEQ(posixcc, "ascii", 5))
			    namedclass =
				complement ? ANYOF_NASCII : ANYOF_ASCII;
			break;
		    case 'c':
			if (strnEQ(posixcc, "cntrl", 5))
			    namedclass =
				complement ? ANYOF_NCNTRL : ANYOF_CNTRL;
			break;
		    case 'd':
			if (strnEQ(posixcc, "digit", 5))
			    namedclass =
				complement ? ANYOF_NDIGIT : ANYOF_DIGIT;
			break;
		    case 'g':
			if (strnEQ(posixcc, "graph", 5))
			    namedclass =
				complement ? ANYOF_NGRAPH : ANYOF_GRAPH;
			break;
		    case 'l':
			if (strnEQ(posixcc, "lower", 5))
			    namedclass =
				complement ? ANYOF_NLOWER : ANYOF_LOWER;
			break;
		    case 'p':
			if (strnEQ(posixcc, "print", 5))
			    namedclass =
				complement ? ANYOF_NPRINT : ANYOF_PRINT;
			else if (strnEQ(posixcc, "punct", 5))
			    namedclass =
				complement ? ANYOF_NPUNCT : ANYOF_PUNCT;
			break;
		    case 's':
			if (strnEQ(posixcc, "space", 5))
			    namedclass =
				complement ? ANYOF_NSPACE : ANYOF_SPACE;
		    case 'u':
			if (strnEQ(posixcc, "upper", 5))
			    namedclass =
				complement ? ANYOF_NUPPER : ANYOF_UPPER;
 			break;
		    case 'w': /* this is not POSIX, this is the Perl \w */
			if (strnEQ(posixcc, "word", 4)) {
			    namedclass =
				complement ? ANYOF_NALNUM : ANYOF_ALNUM;
			    skip = 4;
			}
			break;
		    case 'x':
			if (strnEQ(posixcc, "xdigit", 6)) {
			    namedclass =
				complement ? ANYOF_NXDIGIT : ANYOF_XDIGIT;
			    skip = 6;
			}
			break;
		    }
		    if (namedclass == OOB_NAMEDCLASS ||
			posixcc[skip] != ':' ||
			posixcc[skip+1] != ']')
			Perl_croak(aTHX_
				   "Character class [:%.*s:] unknown",
				   t - s - 1, s + 1);
		} else if (ckWARN(WARN_REGEXP) && !SIZE_ONLY)
		    /* [[=foo=]] and [[.foo.]] are still future. */
		    Perl_warner(aTHX_ WARN_REGEXP,
				"Character class syntax [%c %c] is reserved for future extensions", c, c);
	    } else {
		/* Maternal grandfather:
		 * "[:" ending in ":" but not in ":]" */
		PL_regcomp_parse = s;
	    }
	}
    }

    return namedclass;
}

STATIC void
S_checkposixcc(pTHX)
{
    if (!SIZE_ONLY && ckWARN(WARN_REGEXP) &&
	(*PL_regcomp_parse == ':' ||
	 *PL_regcomp_parse == '=' ||
	 *PL_regcomp_parse == '.')) {
	char *s = PL_regcomp_parse;
 	char  c = *s++;

	while(*s && isALNUM(*s))
	    s++;
	if (*s && c == *s && s[1] == ']') {
	    Perl_warner(aTHX_ WARN_REGEXP,
			"Character class syntax [%c %c] belongs inside character classes", c, c);
	    if (c == '=' || c == '.')
		Perl_warner(aTHX_ WARN_REGEXP,
			    "Character class syntax [%c %c] is reserved for future extensions", c, c);
	}
    }
}

d1870 1
a1870 1
S_regclass(pTHX)
d1873 3
a1875 2
    register U32 value;
    register I32 lastvalue = OOB_CHAR8;
d1878 1
a1879 3
    I32 namedclass;
    char *rangebegin;
    bool need_class = 0;
d1881 1
d1883 2
a1884 11
    if (SIZE_ONLY)
	PL_regsize += ANYOF_SKIP;
    else {
	ret->flags = 0;
	ANYOF_BITMAP_ZERO(ret);
 	PL_regcode += ANYOF_SKIP;
	if (FOLD)
	    ANYOF_FLAGS(ret) |= ANYOF_FOLD;
	if (LOC)
	    ANYOF_FLAGS(ret) |= ANYOF_LOCALE;
    }
d1889 10
a1898 1
	    ANYOF_FLAGS(ret) |= ANYOF_INVERT;
a1899 4

    if (!SIZE_ONLY && ckWARN(WARN_REGEXP))
	checkposixcc();

d1904 23
a1926 49
	namedclass = OOB_NAMEDCLASS;
	if (!range)
	    rangebegin = PL_regcomp_parse;
	value = UCHARAT(PL_regcomp_parse++);
	if (value == '[')
	    namedclass = regpposixcc(value);
	else if (value == '\\') {
	    value = UCHARAT(PL_regcomp_parse++);
	    /* Some compilers cannot handle switching on 64-bit integer
	     * values, therefore value cannot be an UV. --jhi */
	    switch (value) {
	    case 'w':	namedclass = ANYOF_ALNUM;	break;
	    case 'W':	namedclass = ANYOF_NALNUM;	break;
	    case 's':	namedclass = ANYOF_SPACE;	break;
	    case 'S':	namedclass = ANYOF_NSPACE;	break;
	    case 'd':	namedclass = ANYOF_DIGIT;	break;
	    case 'D':	namedclass = ANYOF_NDIGIT;	break;
	    case 'n':	value = '\n';			break;
	    case 'r':	value = '\r';			break;
	    case 't':	value = '\t';			break;
	    case 'f':	value = '\f';			break;
	    case 'b':	value = '\b';			break;
#ifdef ASCIIish
	    case 'e':	value = '\033';			break;
	    case 'a':	value = '\007';			break;
#else
	    case 'e':	value = '\047';			break;
	    case 'a':	value = '\057';			break;
#endif
	    case 'x':
		value = (UV)scan_hex(PL_regcomp_parse, 2, &numlen);
		PL_regcomp_parse += numlen;
		break;
	    case 'c':
		value = UCHARAT(PL_regcomp_parse++);
		value = toCTRL(value);
		break;
	    case '0': case '1': case '2': case '3': case '4':
	    case '5': case '6': case '7': case '8': case '9':
		value = (UV)scan_oct(--PL_regcomp_parse, 3, &numlen);
		PL_regcomp_parse += numlen;
		break;
	    default:
		if (!SIZE_ONLY && ckWARN(WARN_REGEXP) && isALPHA(value))
		    Perl_warner(aTHX_ WARN_REGEXP, 
				"/%.127s/: Unrecognized escape \\%c in character class passed through",
				PL_regprecomp,
				(int)value);
		break;
d1929 4
a1932 5
	if (namedclass > OOB_NAMEDCLASS) {
	    if (!need_class && !SIZE_ONLY)
		ANYOF_CLASS_ZERO(ret);
	    need_class = 1;
	    if (range) { /* a-\d, a-[:digit:] */
d1934 2
a1935 17
		    if (ckWARN(WARN_REGEXP))
			Perl_warner(aTHX_ WARN_REGEXP,
				    "/%.127s/: false [] range \"%*.*s\" in regexp",
				    PL_regprecomp,
				    PL_regcomp_parse - rangebegin,
				    PL_regcomp_parse - rangebegin,
				    rangebegin);
		    ANYOF_BITMAP_SET(ret, lastvalue);
		    ANYOF_BITMAP_SET(ret, '-');
		}
		range = 0; /* this is not a true range */
	    }
	    if (!SIZE_ONLY) {
		switch (namedclass) {
		case ANYOF_ALNUM:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_ALNUM);
d1937 3
a1939 3
			for (value = 0; value < 256; value++)
			    if (isALNUM(value))
				ANYOF_BITMAP_SET(ret, value);
d1941 7
a1947 4
		    break;
		case ANYOF_NALNUM:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_NALNUM);
d1949 3
a1951 3
			for (value = 0; value < 256; value++)
			    if (!isALNUM(value))
				ANYOF_BITMAP_SET(ret, value);
d1953 7
a1959 4
		    break;
		case ANYOF_SPACE:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_SPACE);
d1961 3
a1963 3
			for (value = 0; value < 256; value++)
			    if (isSPACE(value))
				ANYOF_BITMAP_SET(ret, value);
d1965 7
a1971 4
		    break;
		case ANYOF_NSPACE:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_NSPACE);
d1973 3
a1975 3
			for (value = 0; value < 256; value++)
			    if (!isSPACE(value))
				ANYOF_BITMAP_SET(ret, value);
a1976 213
		    break;
		case ANYOF_DIGIT:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_DIGIT);
		    else {
			for (value = '0'; value <= '9'; value++)
			    ANYOF_BITMAP_SET(ret, value);
		    }
		    break;
		case ANYOF_NDIGIT:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_NDIGIT);
		    else {
			for (value = 0; value < '0'; value++)
			    ANYOF_BITMAP_SET(ret, value);
			for (value = '9' + 1; value < 256; value++)
			    ANYOF_BITMAP_SET(ret, value);
		    }
		    break;
		case ANYOF_NALNUMC:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_NALNUMC);
		    else {
			for (value = 0; value < 256; value++)
			    if (!isALNUMC(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    break;
		case ANYOF_ALNUMC:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_ALNUMC);
		    else {
			for (value = 0; value < 256; value++)
			    if (isALNUMC(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    break;
		case ANYOF_ALPHA:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_ALPHA);
		    else {
			for (value = 0; value < 256; value++)
			    if (isALPHA(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    break;
		case ANYOF_NALPHA:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_NALPHA);
		    else {
			for (value = 0; value < 256; value++)
			    if (!isALPHA(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    break;
		case ANYOF_ASCII:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_ASCII);
		    else {
#ifdef ASCIIish
			for (value = 0; value < 128; value++)
			    ANYOF_BITMAP_SET(ret, value);
#else  /* EBCDIC */
			for (value = 0; value < 256; value++)
			    if (isASCII(value))
				ANYOF_BITMAP_SET(ret, value);
#endif /* EBCDIC */
		    }
		    break;
		case ANYOF_NASCII:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_NASCII);
		    else {
#ifdef ASCIIish
			for (value = 128; value < 256; value++)
			    ANYOF_BITMAP_SET(ret, value);
#else  /* EBCDIC */
			for (value = 0; value < 256; value++)
			    if (!isASCII(value))
				ANYOF_BITMAP_SET(ret, value);
#endif /* EBCDIC */
		    }
		    break;
		case ANYOF_CNTRL:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_CNTRL);
		    else {
			for (value = 0; value < 256; value++)
			    if (isCNTRL(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    lastvalue = OOB_CHAR8;
		    break;
		case ANYOF_NCNTRL:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_NCNTRL);
		    else {
			for (value = 0; value < 256; value++)
			    if (!isCNTRL(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    break;
		case ANYOF_GRAPH:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_GRAPH);
		    else {
			for (value = 0; value < 256; value++)
			    if (isGRAPH(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    break;
		case ANYOF_NGRAPH:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_NGRAPH);
		    else {
			for (value = 0; value < 256; value++)
			    if (!isGRAPH(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    break;
		case ANYOF_LOWER:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_LOWER);
		    else {
			for (value = 0; value < 256; value++)
			    if (isLOWER(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    break;
		case ANYOF_NLOWER:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_NLOWER);
		    else {
			for (value = 0; value < 256; value++)
			    if (!isLOWER(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    break;
		case ANYOF_PRINT:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_PRINT);
		    else {
			for (value = 0; value < 256; value++)
			    if (isPRINT(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    break;
		case ANYOF_NPRINT:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_NPRINT);
		    else {
			for (value = 0; value < 256; value++)
			    if (!isPRINT(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    break;
		case ANYOF_PUNCT:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_PUNCT);
		    else {
			for (value = 0; value < 256; value++)
			    if (isPUNCT(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    break;
		case ANYOF_NPUNCT:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_NPUNCT);
		    else {
			for (value = 0; value < 256; value++)
			    if (!isPUNCT(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    break;
		case ANYOF_UPPER:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_UPPER);
		    else {
			for (value = 0; value < 256; value++)
			    if (isUPPER(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    break;
		case ANYOF_NUPPER:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_NUPPER);
		    else {
			for (value = 0; value < 256; value++)
			    if (!isUPPER(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    break;
		case ANYOF_XDIGIT:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_XDIGIT);
		    else {
			for (value = 0; value < 256; value++)
			    if (isXDIGIT(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    break;
		case ANYOF_NXDIGIT:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_NXDIGIT);
		    else {
			for (value = 0; value < 256; value++)
			    if (!isXDIGIT(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    break;
		default:
		    FAIL("invalid [::] class in regexp");
		    break;
d1978 17
a1994 2
		if (LOC)
		    ANYOF_FLAGS(ret) |= ANYOF_CLASS;
d1996 34
d2033 2
a2034 8
	    if (lastvalue > value) /* b-a */ {
		Perl_croak(aTHX_
			   "/%.127s/: invalid [] range \"%*.*s\" in regexp",
			   PL_regprecomp,
			   PL_regcomp_parse - rangebegin,
			   PL_regcomp_parse - rangebegin,
			   rangebegin);
	    }
d2038 1
a2038 1
	    lastvalue = value;
d2040 1
a2040 1
		PL_regcomp_parse[1] != ']') {
d2042 1
a2042 12
		if (namedclass > OOB_NAMEDCLASS) { /* \w-, [:word:]- */
		    if (ckWARN(WARN_REGEXP))
			Perl_warner(aTHX_ WARN_REGEXP,
				    "/%.127s/: false [] range \"%*.*s\" in regexp",
				    PL_regprecomp,
				    PL_regcomp_parse - rangebegin,
				    PL_regcomp_parse - rangebegin,
				    rangebegin);
		    if (!SIZE_ONLY)
			ANYOF_BITMAP_SET(ret, '-');
		} else
		    range = 1;
a2045 1
	/* now is the next time */
d2047 6
a2052 7
#ifndef ASCIIish /* EBCDIC, for example. */
	    if ((isLOWER(lastvalue) && isLOWER(value)) ||
		(isUPPER(lastvalue) && isUPPER(value)))
	    {
		I32 i;
 		if (isLOWER(lastvalue)) {
 		    for (i = lastvalue; i <= value; i++)
d2054 1
a2054 1
			    ANYOF_BITMAP_SET(ret, i);
d2056 1
a2056 1
 		    for (i = lastvalue; i <= value; i++)
d2058 1
a2058 1
			    ANYOF_BITMAP_SET(ret, i);
d2063 4
a2066 10
		for ( ; lastvalue <= value; lastvalue++)
		    ANYOF_BITMAP_SET(ret, lastvalue);
        }
	range = 0;
    }
    if (need_class) {
	if (SIZE_ONLY)
	    PL_regsize += ANYOF_CLASS_ADD_SKIP;
	else
	    PL_regcode += ANYOF_CLASS_ADD_SKIP;
d2068 3
d2072 5
a2076 6
    if (!SIZE_ONLY &&
	(ANYOF_FLAGS(ret) & (ANYOF_FLAGS_ALL ^ ANYOF_INVERT)) == ANYOF_FOLD) {
	for (value = 0; value < 256; ++value) {
	    if (ANYOF_BITMAP_TEST(ret, value)) {
		I32 cf = PL_fold[value];
		ANYOF_BITMAP_SET(ret, cf);
d2079 1
a2079 1
	ANYOF_FLAGS(ret) &= ~ANYOF_FOLD;
d2082 4
a2085 246
    if (!SIZE_ONLY && (ANYOF_FLAGS(ret) & ANYOF_FLAGS_ALL) == ANYOF_INVERT) {
	for (value = 0; value < ANYOF_BITMAP_SIZE; ++value)
	    ANYOF_BITMAP(ret)[value] ^= ANYOF_FLAGS_ALL;
	ANYOF_FLAGS(ret) = 0;
    }
    return ret;
}

STATIC regnode *
S_regclassutf8(pTHX)
{
    dTHR;
    register char *e;
    register U32 value;
    register U32 lastvalue = OOB_UTF8;
    register I32 range = 0;
    register regnode *ret;
    I32 numlen;
    I32 n;
    SV *listsv;
    U8 flags = 0;
    I32 namedclass;
    char *rangebegin;

    if (*PL_regcomp_parse == '^') {	/* Complement of range. */
	PL_regnaughty++;
	PL_regcomp_parse++;
	if (!SIZE_ONLY)
	    flags |= ANYOF_INVERT;
    }
    if (!SIZE_ONLY) {
	if (FOLD)
	    flags |= ANYOF_FOLD;
	if (LOC)
	    flags |= ANYOF_LOCALE;
	listsv = newSVpvn("# comment\n",10);
    }

    if (!SIZE_ONLY && ckWARN(WARN_REGEXP))
	checkposixcc();

    if (*PL_regcomp_parse == ']' || *PL_regcomp_parse == '-')
	goto skipcond;		/* allow 1st char to be ] or - */

    while (PL_regcomp_parse < PL_regxend && *PL_regcomp_parse != ']') {
       skipcond:
	namedclass = OOB_NAMEDCLASS;
	if (!range)
	    rangebegin = PL_regcomp_parse;
	value = utf8_to_uv((U8*)PL_regcomp_parse, &numlen);
	PL_regcomp_parse += numlen;
	if (value == '[')
	    namedclass = regpposixcc(value);
	else if (value == '\\') {
	    value = (U32)utf8_to_uv((U8*)PL_regcomp_parse, &numlen);
	    PL_regcomp_parse += numlen;
	    /* Some compilers cannot handle switching on 64-bit integer
	     * values, therefore value cannot be an UV.  Yes, this will
	     * be a problem later if we want switch on Unicode.  --jhi */
	    switch (value) {
	    case 'w':		namedclass = ANYOF_ALNUM;		break;
	    case 'W':		namedclass = ANYOF_NALNUM;		break;
	    case 's':		namedclass = ANYOF_SPACE;		break;
	    case 'S':		namedclass = ANYOF_NSPACE;		break;
	    case 'd':		namedclass = ANYOF_DIGIT;		break;
	    case 'D':		namedclass = ANYOF_NDIGIT;		break;
	    case 'p':
	    case 'P':
		if (*PL_regcomp_parse == '{') {
		    e = strchr(PL_regcomp_parse++, '}');
                    if (!e)
                        FAIL("Missing right brace on \\p{}");
		    n = e - PL_regcomp_parse;
		}
		else {
		    e = PL_regcomp_parse;
		    n = 1;
		}
		if (!SIZE_ONLY) {
		    if (value == 'p')
			Perl_sv_catpvf(aTHX_ listsv,
				       "+utf8::%.*s\n", (int)n, PL_regcomp_parse);
		    else
			Perl_sv_catpvf(aTHX_ listsv,
				       "!utf8::%.*s\n", (int)n, PL_regcomp_parse);
		}
		PL_regcomp_parse = e + 1;
		lastvalue = OOB_UTF8;
		continue;
	    case 'n':		value = '\n';		break;
	    case 'r':		value = '\r';		break;
	    case 't':		value = '\t';		break;
	    case 'f':		value = '\f';		break;
	    case 'b':		value = '\b';		break;
#ifdef ASCIIish
	    case 'e':		value = '\033';		break;
	    case 'a':		value = '\007';		break;
#else
	    case 'e':		value = '\047';		break;
	    case 'a':		value = '\057';		break;
#endif
	    case 'x':
		if (*PL_regcomp_parse == '{') {
		    e = strchr(PL_regcomp_parse++, '}');
                    if (!e)
                        FAIL("Missing right brace on \\x{}");
		    value = (UV)scan_hex(PL_regcomp_parse,
				     e - PL_regcomp_parse,
				     &numlen);
		    PL_regcomp_parse = e + 1;
		}
		else {
		    value = (UV)scan_hex(PL_regcomp_parse, 2, &numlen);
		    PL_regcomp_parse += numlen;
		}
		break;
	    case 'c':
		value = UCHARAT(PL_regcomp_parse++);
		value = toCTRL(value);
		break;
	    case '0': case '1': case '2': case '3': case '4':
	    case '5': case '6': case '7': case '8': case '9':
		value = (UV)scan_oct(--PL_regcomp_parse, 3, &numlen);
		PL_regcomp_parse += numlen;
		break;
	    default:
		if (!SIZE_ONLY && ckWARN(WARN_REGEXP) && isALPHA(value))
		    Perl_warner(aTHX_ WARN_REGEXP, 
				"/%.127s/: Unrecognized escape \\%c in character class passed through",
				PL_regprecomp,
				(int)value);
		break;
	    }
	}
	if (namedclass > OOB_NAMEDCLASS) {
	    if (range) { /* a-\d, a-[:digit:] */
		if (!SIZE_ONLY) {
		    if (ckWARN(WARN_REGEXP))
			Perl_warner(aTHX_ WARN_REGEXP,
				    "/%.127s/: false [] range \"%*.*s\" in regexp",
				    PL_regprecomp,
				    PL_regcomp_parse - rangebegin,
				    PL_regcomp_parse - rangebegin,
				    rangebegin);
		    Perl_sv_catpvf(aTHX_ listsv,
				   /* 0x002D is Unicode for '-' */
				   "%04"UVxf"\n002D\n", (UV)lastvalue);
		}
		range = 0;
	    }
	    if (!SIZE_ONLY) {
		switch (namedclass) {
		case ANYOF_ALNUM:
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsWord\n");	break;
		case ANYOF_NALNUM:
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsWord\n");	break;
		case ANYOF_ALNUMC:
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsAlnum\n");	break;
		case ANYOF_NALNUMC:
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsAlnum\n");	break;
		case ANYOF_ALPHA:
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsAlpha\n");	break;
		case ANYOF_NALPHA:
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsAlpha\n");	break;
		case ANYOF_ASCII:
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsASCII\n");	break;
		case ANYOF_NASCII:
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsASCII\n");	break;
		case ANYOF_CNTRL:
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsCntrl\n");	break;
		case ANYOF_NCNTRL:
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsCntrl\n");	break;
		case ANYOF_GRAPH:
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsGraph\n");	break;
		case ANYOF_NGRAPH:
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsGraph\n");	break;
		case ANYOF_DIGIT:
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsDigit\n");	break;
		case ANYOF_NDIGIT:
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsDigit\n");	break;
		case ANYOF_LOWER:
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsLower\n");	break;
		case ANYOF_NLOWER:
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsLower\n");	break;
		case ANYOF_PRINT:
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsPrint\n");	break;
		case ANYOF_NPRINT:
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsPrint\n");	break;
		case ANYOF_PUNCT:
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsPunct\n");	break;
		case ANYOF_NPUNCT:
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsPunct\n");	break;
		case ANYOF_SPACE:
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsSpace\n");	break;
		case ANYOF_NSPACE:
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsSpace\n");	break;
		case ANYOF_UPPER:
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsUpper\n");	break;
		case ANYOF_NUPPER:
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsUpper\n");	break;
		case ANYOF_XDIGIT:
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsXDigit\n");	break;
		case ANYOF_NXDIGIT:
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsXDigit\n");	break;
		}
		continue;
	    }
	}
        if (range) {
	    if (lastvalue > value) { /* b-a */
		Perl_croak(aTHX_
			   "/%.127s/: invalid [] range \"%*.*s\" in regexp",
			   PL_regprecomp,
			   PL_regcomp_parse - rangebegin,
			   PL_regcomp_parse - rangebegin,
			   rangebegin);
	    }
	    range = 0;
	}
	else {
	    lastvalue = value;
	    if (*PL_regcomp_parse == '-' && PL_regcomp_parse+1 < PL_regxend &&
		PL_regcomp_parse[1] != ']') {
		PL_regcomp_parse++;
		if (namedclass > OOB_NAMEDCLASS) { /* \w-, [:word:]- */
		    if (ckWARN(WARN_REGEXP))
			Perl_warner(aTHX_ WARN_REGEXP,
				    "/%.127s/: false [] range \"%*.*s\" in regexp",
				    PL_regprecomp,
				    PL_regcomp_parse - rangebegin,
				    PL_regcomp_parse - rangebegin,
				    rangebegin);
		    if (!SIZE_ONLY)
			Perl_sv_catpvf(aTHX_ listsv,
				       /* 0x002D is Unicode for '-' */
				       "002D\n");
		} else
		    range = 1;
		continue;	/* do it next time */
	    }
	}
	/* now is the next time */
	if (!SIZE_ONLY)
	    Perl_sv_catpvf(aTHX_ listsv, "%04"UVxf"\t%04"UVxf"\n",
			   (UV)lastvalue, (UV)value);
	range = 0;
a2086 12

    ret = reganode(ANYOFUTF8, 0);

    if (!SIZE_ONLY) {
	SV *rv = swash_init("utf8", "", listsv, 1, 0);
	SvREFCNT_dec(listsv);
	n = add_data(1,"s");
	PL_regcomp_rx->data->data[n] = (void*)rv;
	ARG1_SET(ret, flags);
	ARG2_SET(ret, n);
    }

d2091 1
a2091 1
S_nextchar(pTHX)
d2124 1
a2124 1
S_reg_node(pTHX_ U8 op)
d2149 1
a2149 1
S_reganode(pTHX_ U8 op, U32 arg)
d2171 1
a2171 1
- reguni - emit (if appropriate) a Unicode character
d2174 1
a2174 1
S_reguni(pTHX_ UV uv, char* s, I32* lenp)
d2177 2
a2178 7
    if (SIZE_ONLY) {
	U8 tmpbuf[UTF8_MAXLEN];
	*lenp = uv_to_utf8(tmpbuf, uv) - tmpbuf;
    }
    else
	*lenp = uv_to_utf8((U8*)s, uv) - (U8*)s;

d2187 1
a2187 1
S_reginsert(pTHX_ U8 op, regnode *opnd)
d2195 1
a2195 1
/* (PL_regkind[(U8)op] == CURLY ? EXTRA_STEP_2ARGS : 0); */
d2218 1
a2218 1
S_regtail(pTHX_ regnode *p, regnode *val)
d2223 1
d2239 1
a2239 2
    }
    else {
d2248 1
a2248 1
S_regoptail(pTHX_ regnode *p, regnode *val)
d2254 1
a2254 1
    if (PL_regkind[(U8)OP(p)] == BRANCH) {
d2256 1
a2256 2
    }
    else if ( PL_regkind[(U8)OP(p)] == BRANCHJ) {
d2258 1
a2258 2
    }
    else
d2266 1
a2266 1
S_regcurly(pTHX_ register char *s)
d2285 1
a2285 1
S_dumpuntil(pTHX_ regnode *start, regnode *node, regnode *last, SV* sv, I32 l)
d2288 2
a2289 2
    register U8 op = EXACT;	/* Arbitrary non-END op. */
    register regnode *next;
d2303 2
a2304 2
	PerlIO_printf(Perl_debug_log, "%4"IVdf":%*s%s", (IV)(node - start),
		      (int)(2*l + 1), "", SvPVX(sv));
d2308 1
a2308 1
	    PerlIO_printf(Perl_debug_log, "(%"IVdf")", (IV)(next - start));
d2311 1
a2311 1
	if (PL_regkind[(U8)op] == BRANCHJ) {
d2318 1
a2318 2
	}
	else if (PL_regkind[(U8)op] == BRANCH) {
d2320 1
a2320 2
	}
	else if ( op == CURLY) {   /* `next' might be very big: optimizer */
d2323 1
a2323 2
	}
	else if (PL_regkind[(U8)op] == CURLY && op != CURLYX) {
d2326 1
a2326 2
	}
	else if ( op == PLUS || op == STAR) {
d2328 1
a2328 2
	}
	else if (op == ANYOF) {
d2330 2
a2331 3
	    node += ANYOF_SKIP;
	}
	else if (PL_regkind[(U8)op] == EXACT) {
d2333 1
a2333 1
	    node += NODE_SZ_STR(node) - 1;
d2335 1
a2335 2
	}
	else {
d2352 1
a2352 1
Perl_regdump(pTHX_ regexp *r)
d2362 1
a2362 2
	PerlIO_printf(Perl_debug_log,
		      "anchored `%s%.*s%s'%s at %"IVdf" ", 
a2363 1
		      (int)(SvCUR(r->anchored_substr) - (SvTAIL(r->anchored_substr)!=0)),
d2367 1
a2367 1
		      (IV)r->anchored_offset);
d2369 1
a2369 2
	PerlIO_printf(Perl_debug_log,
		      "floating `%s%.*s%s'%s at %"IVdf"..%"UVuf" ", 
d2371 1
a2371 2
		      (int)(SvCUR(r->float_substr) - (SvTAIL(r->float_substr)!=0)), 
		      SvPVX(r->float_substr),
d2374 1
a2374 1
		      (IV)r->float_min_offset, (UV)r->float_max_offset);
a2395 2
	if (r->reganch & ROPT_ANCH_SBOL)
	    PerlIO_printf(Perl_debug_log, "(SBOL)");
a2412 11
STATIC void
S_put_byte(pTHX_ SV *sv, int c)
{
    if (c <= ' ' || c == 127 || c == 255)
	Perl_sv_catpvf(aTHX_ sv, "\\%o", c);
    else if (c == '-' || c == ']' || c == '\\' || c == '^')
	Perl_sv_catpvf(aTHX_ sv, "\\%c", c);
    else
	Perl_sv_catpvf(aTHX_ sv, "%c", c);
}

d2417 1
a2417 1
Perl_regprop(pTHX_ SV *sv, regnode *o)
d2421 1
a2421 1
    register int k;
d2424 177
a2600 1
    if (OP(o) >= reg_num)		/* regnode.type is unsigned */
a2601 78
    sv_catpv(sv, (char*)reg_name[OP(o)]); /* Take off const! */

    k = PL_regkind[(U8)OP(o)];

    if (k == EXACT)
	Perl_sv_catpvf(aTHX_ sv, " <%s%.*s%s>", PL_colors[0],
		       STR_LEN(o), STRING(o), PL_colors[1]);
    else if (k == CURLY) {
	if (OP(o) == CURLYM || OP(o) == CURLYN)
	    Perl_sv_catpvf(aTHX_ sv, "[%d]", o->flags); /* Parenth number */
	Perl_sv_catpvf(aTHX_ sv, " {%d,%d}", ARG1(o), ARG2(o));
    }
    else if (k == WHILEM && o->flags)			/* Ordinal/of */
	Perl_sv_catpvf(aTHX_ sv, "[%d/%d]", o->flags & 0xf, o->flags>>4);
    else if (k == REF || k == OPEN || k == CLOSE || k == GROUPP )
	Perl_sv_catpvf(aTHX_ sv, "%d", (int)ARG(o));	/* Parenth number */
    else if (k == LOGICAL)
	Perl_sv_catpvf(aTHX_ sv, "[%d]", o->flags);	/* 2: embedded, otherwise 1 */
    else if (k == ANYOF) {
	int i, rangestart = -1;
	const char * const out[] = {	/* Should be syncronized with
					   a table in regcomp.h */
	    "\\w",
	    "\\W",
	    "\\s",
	    "\\S",
	    "\\d",
	    "\\D",
	    "[:alnum:]",
	    "[:^alnum:]",
	    "[:alpha:]",
	    "[:^alpha:]",
	    "[:ascii:]",
	    "[:^ascii:]",
	    "[:ctrl:]",
	    "[:^ctrl:]",
	    "[:graph:]",
	    "[:^graph:]",
	    "[:lower:]",
	    "[:^lower:]",
	    "[:print:]",
	    "[:^print:]",
	    "[:punct:]",
	    "[:^punct:]",
	    "[:upper:]",
	    "[:!upper:]",
	    "[:xdigit:]",
	    "[:^xdigit:]"
	};

	if (o->flags & ANYOF_LOCALE)
	    sv_catpv(sv, "{loc}");
	if (o->flags & ANYOF_FOLD)
	    sv_catpv(sv, "{i}");
	Perl_sv_catpvf(aTHX_ sv, "[%s", PL_colors[0]);
	if (o->flags & ANYOF_INVERT)
	    sv_catpv(sv, "^");
	for (i = 0; i <= 256; i++) {
	    if (i < 256 && ANYOF_BITMAP_TEST(o,i)) {
		if (rangestart == -1)
		    rangestart = i;
	    } else if (rangestart != -1) {
		if (i <= rangestart + 3)
		    for (; rangestart < i; rangestart++)
			put_byte(sv, rangestart);
		else {
		    put_byte(sv, rangestart);
		    sv_catpv(sv, "-");
		    put_byte(sv, i - 1);
		}
		rangestart = -1;
	    }
	}
	if (o->flags & ANYOF_CLASS)
	    for (i = 0; i < sizeof(out)/sizeof(char*); i++)
		if (ANYOF_CLASS_TEST(o,i))
		    sv_catpv(sv, out[i]);
	Perl_sv_catpvf(aTHX_ sv, "%s]", PL_colors[1]);
d2603 2
a2604 2
    else if (k == BRANCHJ && (OP(o) == UNLESSM || OP(o) == IFMATCH))
	Perl_sv_catpvf(aTHX_ sv, "[-%d]", o->flags);
a2607 19
SV *
Perl_re_intuit_string(pTHX_ regexp *prog)
{				/* Assume that RE_INTUIT is set */
    DEBUG_r(
	{   STRLEN n_a;
	    char *s = SvPV(prog->check_substr,n_a);

	    if (!PL_colorset) reginitcolors();
	    PerlIO_printf(Perl_debug_log,
		      "%sUsing REx substr:%s `%s%.60s%s%s'\n",
		      PL_colors[4],PL_colors[5],PL_colors[0],
		      s,
		      PL_colors[1],
		      (strlen(s) > 60 ? "..." : ""));
	} );

    return prog->check_substr;
}

d2609 1
a2609 1
Perl_pregfree(pTHX_ struct regexp *r)
a2611 2
    DEBUG_r(if (!PL_colorset) reginitcolors());

a2613 7
    DEBUG_r(PerlIO_printf(Perl_debug_log,
		      "%sFreeing REx:%s `%s%.60s%s%s'\n",
		      PL_colors[4],PL_colors[5],PL_colors[0],
		      r->precomp,
		      PL_colors[1],
		      (strlen(r->precomp) > 60 ? "..." : "")));

d2616 2
a2617 2
    if (RX_MATCH_COPIED(r))
	Safefree(r->subbeg);
a2626 4
	AV* new_comppad = NULL;
	AV* old_comppad;
	SV** old_curpad;

a2631 6
	    case 'f':
		Safefree(r->data->data[n]);
		break;
	    case 'p':
		new_comppad = (AV*)r->data->data[n];
		break;
a2632 6
		if (new_comppad == NULL)
		    Perl_croak(aTHX_ "panic: pregfree comppad");
		old_comppad = PL_comppad;
		old_curpad = PL_curpad;
		PL_comppad = new_comppad;
		PL_curpad = AvARRAY(new_comppad);
a2633 4
		PL_comppad = old_comppad;
		PL_curpad = old_curpad;
		SvREFCNT_dec((SV*)new_comppad);
		new_comppad = NULL;
d2656 1
a2656 1
Perl_regnext(pTHX_ register regnode *p)
d2672 1
a2672 1
S_re_croak2(pTHX_ const char* pat1,const char* pat2,...)
a2677 1
    SV *msv;
a2687 2
#ifdef I_STDARG
    /* ANSI variant takes additional second argument */
d2689 1
a2689 4
#else
    va_start(args);
#endif
    msv = vmess(buf, &args);
d2691 1
a2691 1
    message = SvPV(msv,l1);
d2696 1
a2696 1
    Perl_croak(aTHX_ "%s", buf);
a2697 65

/* XXX Here's a total kludge.  But we need to re-enter for swash routines. */

void
Perl_save_re_context(pTHX)
{                   
    dTHR;
    SAVEPPTR(PL_bostr);
    SAVEPPTR(PL_regprecomp);		/* uncompiled string. */
    SAVEI32(PL_regnpar);		/* () count. */
    SAVEI32(PL_regsize);		/* Code size. */
    SAVEI16(PL_regflags);		/* are we folding, multilining? */
    SAVEPPTR(PL_reginput);		/* String-input pointer. */
    SAVEPPTR(PL_regbol);		/* Beginning of input, for ^ check. */
    SAVEPPTR(PL_regeol);		/* End of input, for $ check. */
    SAVEVPTR(PL_regstartp);		/* Pointer to startp array. */
    SAVEVPTR(PL_regendp);		/* Ditto for endp. */
    SAVEVPTR(PL_reglastparen);		/* Similarly for lastparen. */
    SAVEPPTR(PL_regtill);		/* How far we are required to go. */
    SAVEI8(PL_regprev);			/* char before regbol, \n if none */
    SAVEVPTR(PL_reg_start_tmp);		/* from regexec.c */
    PL_reg_start_tmp = 0;
    SAVEFREEPV(PL_reg_start_tmp);
    SAVEI32(PL_reg_start_tmpl);		/* from regexec.c */
    PL_reg_start_tmpl = 0;
    SAVEVPTR(PL_regdata);
    SAVEI32(PL_reg_flags);		/* from regexec.c */
    SAVEI32(PL_reg_eval_set);		/* from regexec.c */
    SAVEI32(PL_regnarrate);		/* from regexec.c */
    SAVEVPTR(PL_regprogram);		/* from regexec.c */
    SAVEINT(PL_regindent);		/* from regexec.c */
    SAVEVPTR(PL_regcc);			/* from regexec.c */
    SAVEVPTR(PL_curcop);
    SAVEVPTR(PL_regcomp_rx);		/* from regcomp.c */
    SAVEI32(PL_regseen);		/* from regcomp.c */
    SAVEI32(PL_regsawback);		/* Did we see \1, ...? */
    SAVEI32(PL_regnaughty);		/* How bad is this pattern? */
    SAVEVPTR(PL_regcode);		/* Code-emit pointer; &regdummy = don't */
    SAVEPPTR(PL_regxend);		/* End of input for compile */
    SAVEPPTR(PL_regcomp_parse);		/* Input-scan pointer. */
    SAVEVPTR(PL_reg_call_cc);		/* from regexec.c */
    SAVEVPTR(PL_reg_re);		/* from regexec.c */
    SAVEPPTR(PL_reg_ganch);		/* from regexec.c */
    SAVESPTR(PL_reg_sv);		/* from regexec.c */
    SAVEVPTR(PL_reg_magic);		/* from regexec.c */
    SAVEI32(PL_reg_oldpos);			/* from regexec.c */
    SAVEVPTR(PL_reg_oldcurpm);		/* from regexec.c */
    SAVEVPTR(PL_reg_curpm);		/* from regexec.c */
#ifdef DEBUGGING
    SAVEPPTR(PL_reg_starttry);		/* from regexec.c */    
#endif
}

#ifdef PERL_OBJECT
#include "XSUB.h"
#undef this
#define this pPerl
#endif

static void
clear_re(pTHXo_ void *r)
{
    ReREFCNT_dec((regexp *)r);
}

@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d72 1
a72 1
 ****    Copyright (c) 1991-2001, Larry Wall
d117 5
a153 1
    I32 *last_closep;
d162 1
a162 1
				      0, 0, 0, 0, 0, 0};
a190 1
#define SCF_WHILEM_VISITED_POS	0x2000
a203 179

/* length of regex to show in messages that don't mark a position within */
#define RegexLengthToShowInErrorMessages 127

/*
 * If MARKER[12] are adjusted, be sure to adjust the constants at the top
 * of t/op/regmesg.t, the tests in t/op/re_tests, and those in
 * op/pragma/warn/regcomp.
 */
#define MARKER1 "HERE"      /* marker as it appears in the description */
#define MARKER2 " << HERE "  /* marker as it appears within the regex */
   
#define REPORT_LOCATION " before " MARKER1 " mark in regex m/%.*s" MARKER2 "%s/"

/*
 * Calls SAVEDESTRUCTOR_X if needed, then calls Perl_croak with the given
 * arg. Show regex, up to a maximum length. If it's too long, chop and add
 * "...".
 */
#define	FAIL(msg)                                                             \
    STMT_START {                                                             \
        char *ellipses = "";                                                 \
        unsigned len = strlen(PL_regprecomp);                                \
                                                                             \
	if (!SIZE_ONLY)                                                      \
	    SAVEDESTRUCTOR_X(clear_re,(void*)PL_regcomp_rx);                 \
                                                                             \
	if (len > RegexLengthToShowInErrorMessages) {                        \
            /* chop 10 shorter than the max, to ensure meaning of "..." */   \
	    len = RegexLengthToShowInErrorMessages - 10;                     \
	    ellipses = "...";                                                \
	}                                                                    \
	Perl_croak(aTHX_ "%s in regex m/%.*s%s/",                            \
		   msg, (int)len, PL_regprecomp, ellipses);                  \
    } STMT_END

/*
 * Calls SAVEDESTRUCTOR_X if needed, then calls Perl_croak with the given
 * args. Show regex, up to a maximum length. If it's too long, chop and add
 * "...".
 */
#define	FAIL2(pat,msg)                                                        \
    STMT_START {                                                             \
        char *ellipses = "";                                                 \
        unsigned len = strlen(PL_regprecomp);                                \
                                                                             \
	if (!SIZE_ONLY)                                                      \
	    SAVEDESTRUCTOR_X(clear_re,(void*)PL_regcomp_rx);                 \
                                                                             \
	if (len > RegexLengthToShowInErrorMessages) {                        \
            /* chop 10 shorter than the max, to ensure meaning of "..." */   \
	    len = RegexLengthToShowInErrorMessages - 10;                     \
	    ellipses = "...";                                                \
	}                                                                    \
	S_re_croak2(aTHX_ pat, " in regex m/%.*s%s/",                        \
		    msg, (int)len, PL_regprecomp, ellipses);                \
    } STMT_END


/*
 * Simple_vFAIL -- like FAIL, but marks the current location in the scan
 */
#define	Simple_vFAIL(m)                                                      \
    STMT_START {                                                             \
      unsigned offset = strlen(PL_regprecomp)-(PL_regxend-PL_regcomp_parse); \
                                                                             \
      Perl_croak(aTHX_ "%s" REPORT_LOCATION,               \
		 m, (int)offset, PL_regprecomp, PL_regprecomp + offset);     \
    } STMT_END

/*
 * Calls SAVEDESTRUCTOR_X if needed, then Simple_vFAIL()
 */
#define	vFAIL(m)                                                             \
    STMT_START {                                                             \
      if (!SIZE_ONLY)                                                        \
	    SAVEDESTRUCTOR_X(clear_re,(void*)PL_regcomp_rx);                 \
      Simple_vFAIL(m);                                                       \
    } STMT_END

/*
 * Like Simple_vFAIL(), but accepts two arguments.
 */
#define	Simple_vFAIL2(m,a1)                                                  \
    STMT_START {                                                             \
      unsigned offset = strlen(PL_regprecomp)-(PL_regxend-PL_regcomp_parse); \
                                                                             \
      S_re_croak2(aTHX_ m, REPORT_LOCATION, a1,       \
		  (int)offset, PL_regprecomp, PL_regprecomp + offset);       \
    } STMT_END

/*
 * Calls SAVEDESTRUCTOR_X if needed, then Simple_vFAIL2().
 */
#define	vFAIL2(m,a1)                                                         \
    STMT_START {                                                             \
      if (!SIZE_ONLY)                                                        \
	    SAVEDESTRUCTOR_X(clear_re,(void*)PL_regcomp_rx);                 \
      Simple_vFAIL2(m, a1);                                                  \
    } STMT_END


/*
 * Like Simple_vFAIL(), but accepts three arguments.
 */
#define	Simple_vFAIL3(m, a1, a2)                                             \
    STMT_START {                                                             \
      unsigned offset = strlen(PL_regprecomp)-(PL_regxend-PL_regcomp_parse); \
                                                                             \
      S_re_croak2(aTHX_ m, REPORT_LOCATION, a1, a2,   \
		  (int)offset, PL_regprecomp, PL_regprecomp + offset);       \
    } STMT_END

/*
 * Calls SAVEDESTRUCTOR_X if needed, then Simple_vFAIL3().
 */
#define	vFAIL3(m,a1,a2)                                                      \
    STMT_START {                                                             \
      if (!SIZE_ONLY)                                                        \
	    SAVEDESTRUCTOR_X(clear_re,(void*)PL_regcomp_rx);                 \
      Simple_vFAIL3(m, a1, a2);                                              \
    } STMT_END

/*
 * Like Simple_vFAIL(), but accepts four arguments.
 */
#define	Simple_vFAIL4(m, a1, a2, a3)                                         \
    STMT_START {                                                             \
      unsigned offset = strlen(PL_regprecomp)-(PL_regxend-PL_regcomp_parse); \
                                                                             \
      S_re_croak2(aTHX_ m, REPORT_LOCATION, a1, a2, a3,\
		  (int)offset, PL_regprecomp, PL_regprecomp + offset);       \
    } STMT_END

/*
 * Like Simple_vFAIL(), but accepts five arguments.
 */
#define	Simple_vFAIL5(m, a1, a2, a3, a4)                                     \
    STMT_START {                                                             \
      unsigned offset = strlen(PL_regprecomp)-(PL_regxend-PL_regcomp_parse); \
      S_re_croak2(aTHX_ m, REPORT_LOCATION, a1, a2, a3, a4,\
		  (int)offset, PL_regprecomp, PL_regprecomp + offset);       \
    } STMT_END


#define	vWARN(loc,m)                                                         \
    STMT_START {                                                             \
        unsigned offset = strlen(PL_regprecomp)-(PL_regxend-(loc));          \
	Perl_warner(aTHX_ WARN_REGEXP, "%s" REPORT_LOCATION,\
		 m, (int)offset, PL_regprecomp, PL_regprecomp + offset);          \
    } STMT_END                                                               \


#define	vWARN2(loc, m, a1)                                                   \
    STMT_START {                                                             \
        unsigned offset = strlen(PL_regprecomp)-(PL_regxend-(loc));          \
	Perl_warner(aTHX_ WARN_REGEXP, m REPORT_LOCATION,\
                 a1,                                                         \
		 (int)offset, PL_regprecomp, PL_regprecomp + offset);        \
    } STMT_END

#define	vWARN3(loc, m, a1, a2)                                               \
    STMT_START {                                                             \
      unsigned offset = strlen(PL_regprecomp) - (PL_regxend - (loc));        \
	Perl_warner(aTHX_ WARN_REGEXP, m REPORT_LOCATION,                    \
                 a1, a2,                                                     \
		 (int)offset, PL_regprecomp, PL_regprecomp + offset);        \
    } STMT_END

#define	vWARN4(loc, m, a1, a2, a3)                                           \
    STMT_START {                                                             \
      unsigned offset = strlen(PL_regprecomp)-(PL_regxend-(loc));            \
	Perl_warner(aTHX_ WARN_REGEXP, m REPORT_LOCATION,\
                 a1, a2, a3,                                                 \
		 (int)offset, PL_regprecomp, PL_regprecomp + offset);        \
    } STMT_END



d216 1
d267 1
a267 1
    for (value = 0; value <= ANYOF_MAX; value += 2)
d381 1
d420 1
a420 1
		else if (stringok) {
d423 1
a423 1

d430 2
a431 1
		    Move(STRING(n), STRING(scan) + oldl, STR_LEN(n), char);
d433 2
a434 1
		    stop = next - 1;
d489 1
a489 1
		    I32 deltanext, minnext, f = 0, fake = 0;
d494 1
a494 1
		    if (data) {		    
a495 4
			data_fake.last_closep = data->last_closep;
		    }
		    else
			data_fake.last_closep = &fake;
a504 2
		    if (flags & SCF_WHILEM_VISITED_POS)
			f |= SCF_WHILEM_VISITED_POS;
d667 2
a668 2
	    I32 mincount, maxcount, minnext, deltanext, fl;
	    I32 f = flags, pos_before = 0;
a710 5
		if (OP(scan) == CURLYX) {
		    I32 lp = (data ? *(data->last_closep) : 0);

		    scan->flags = ((lp <= U8_MAX) ? lp : U8_MAX);
		}
a729 8
		/* These are the cases when once a subexpression
		   fails at a particular position, it cannot succeed
		   even after backtracking at the enclosing scope.
		   
		   XXXX what if minimal match and we are at the
		        initial run of {n,m}? */
		if ((mincount != maxcount - 1) && (maxcount != REG_INFTY))
		    f &= ~SCF_WHILEM_VISITED_POS;
d767 2
a768 5
		{
		    vWARN(PL_regcomp_parse,
			  "Quantifier unexpected on zero-length expression");
		}

d831 1
a831 1
			    FAIL("Panic opt close");
d862 2
a863 8
		else if ((OP(oscan) == CURLYX)
			 && (flags & SCF_WHILEM_VISITED_POS)
			 /* See the comment on a similar expression above.
			    However, this time it not a subexpression
			    we care about, but the expression itself. */
			 && (maxcount == REG_INFTY)
			 && data && ++data->whilem_c < 16) {
		    /* This stays as CURLYX, we can put the count/of pair. */
a903 5
			} else {
			    /* start offset must point into the last copy */
			    data->last_start_min += minnext * (mincount - 1);
			    data->last_start_max += is_inf ? 0 : (maxcount - 1)
				* (minnext + data->pos_delta);
d1172 1
a1172 1
	    I32 deltanext, minnext, fake = 0;
d1178 1
a1178 1
	    if (data) {		    
a1179 4
		data_fake.last_closep = data->last_closep;
	    }
	    else
		data_fake.last_closep = &fake;
d1184 1
a1184 1
		f |= SCF_DO_STCLASS_AND;
a1185 2
	    if (flags & SCF_WHILEM_VISITED_POS)
		f |= SCF_WHILEM_VISITED_POS;
d1191 1
a1191 1
		    vFAIL("Variable length lookbehind not implemented");
d1194 1
a1194 1
		    vFAIL2("Lookbehind longer than %"UVuf" not implemented", (UV)U8_MAX);
d1204 1
a1204 1
	    if (f & SCF_DO_STCLASS_AND) {
d1215 2
a1216 3
	else if (OP(scan) == CLOSE) {
	    if (ARG(scan) == is_par) {
		next = regnext(scan);
d1218 2
a1219 5
		if ( next && (OP(next) != WHILEM) && next < last)
		    is_par = 0;		/* Disable optimization */
	    }
	    if (data)
		*(data->last_closep) = ARG(scan);
d1262 1
d1283 1
a1304 1

d1323 1
d1342 1
a1342 1
    PL_regprecomp = exp;
d1368 1
d1387 1
a1387 2
	FAIL("Regexp out of space");

d1394 1
a1394 1
    r->precomp = savepvn(PL_regprecomp, r->prelen);
a1438 1
	I32 last_close = 0;
a1530 1
	data.last_closep = &last_close;
d1533 1
a1533 1
			     &data, SCF_DO_SUBSTR | SCF_WHILEM_VISITED_POS | stclass_flag);
a1634 1
	I32 last_close = 0;
d1640 1
a1640 2
	data.last_closep = &last_close;
	minlen = study_chunk(&scan, &fake, scan + PL_regsize, &data, SCF_DO_STCLASS_AND|SCF_WHILEM_VISITED_POS);
a1669 1
    PL_regdata = r->data; /* for regprop() ANYOFUTF8 */
d1687 1
a1693 1
    char *oregcomp_parse = PL_regcomp_parse;
a1703 1
	    char *seqstart = PL_regcomp_parse;
d1724 1
a1724 1
		vFAIL2("Sequence (?%c...) not implemented", (int)paren);
d1736 2
a1737 1
		    vWARN(PL_regcomp_parse, "(?p{}) is deprecated - use (??{})");
d1745 1
d1764 1
a1764 4
		{
		    PL_regcomp_parse = s;		    
		    vFAIL("Sequence (?{...}) not terminated or not {}-balanced");
		}
a1772 2
		    ENTER;
		    Perl_save_re_context(aTHX);
a1773 1
		    LEAVE;
d1823 1
a1823 1
			vFAIL("Switch condition not recognized");
d1845 1
a1845 1
			vFAIL("Switch (?(condition)... contains too many branches");
d1857 1
a1857 1
		    vFAIL2("Unknown switch condition (?(%.2s", PL_regcomp_parse);
d1861 1
a1861 2
		PL_regcomp_parse--; /* for vFAIL to print correctly */
                vFAIL("Sequence (? incomplete");
d1884 2
a1885 4
		if (*PL_regcomp_parse != ')') {
		    PL_regcomp_parse++;
		    vFAIL3("Sequence (%.*s...) not recognized", PL_regcomp_parse-seqstart, seqstart);
		}
d1997 1
a1997 2
	    PL_regcomp_parse = oregcomp_parse;
	    vFAIL("Unmatched (");
d2002 1
a2002 2
	    PL_regcomp_parse++;
	    vFAIL("Unmatched )");
d2005 1
a2005 1
	    FAIL("Junk on end of regexp");	/* "Can't happen". */
d2020 1
d2086 1
d2130 1
a2130 1
		vFAIL2("Quantifier in {,} bigger than %d", REG_INFTY - 1);
d2164 1
a2164 1
		vFAIL("Can't do {n,m} with n > m");
a2179 11

    /* if this is reinstated, don't forget to put this back into perldiag:

	    =item Regexp *+ operand could be empty at {#} in regex m/%s/

	   (F) The part of the regexp subject to either the * or + quantifier
           could match an empty string. The {#} shows in the regular
           expression about where the problem was discovered.

    */

d2181 1
a2181 1
      vFAIL("Regexp *+ operand could be empty");
d2212 2
a2213 4
	vWARN3(PL_regcomp_parse,
	       "%.*s matches null string many times",
	       PL_regcomp_parse - origparse,
	       origparse);
d2221 2
a2222 4
    if (ISMULT2(PL_regcomp_parse)) {
	PL_regcomp_parse++;
	vFAIL("Nested quantifiers");
    }
d2235 2
a2236 1
 * [Yes, it is worth fixing, some scripts can run twice the speed.] */
d2240 1
d2259 2
a2261 2
	if (*PL_regcomp_parse) 
	    PL_seen_zerolen++;
d2288 1
a2288 2
    {
	char *oregcomp_parse = ++PL_regcomp_parse;
d2290 2
a2291 4
	if (*PL_regcomp_parse != ']') {
	    PL_regcomp_parse = oregcomp_parse;
	    vFAIL("Unmatched [");
	}
a2294 1
    }
d2299 1
a2299 6
		if (flags & TRYAGAIN) {
		    if (PL_regcomp_parse == PL_regxend) {
			 /* Make parent create an empty node if needed. */
			*flagp |= TRYAGAIN;
			return(NULL);
		    }
a2300 1
		}
d2311 1
a2311 1
	vFAIL("Internal urp");
d2323 1
a2323 2
	PL_regcomp_parse++;
	vFAIL("Quantifier follows nothing");
d2447 2
a2448 5
		    if (!PL_regxend) {
			PL_regcomp_parse += 2;
			PL_regxend = oldregxend;
			vFAIL("Missing right brace on \\p{}");
		    }
a2480 3
		    while (isDIGIT(*PL_regcomp_parse))
			PL_regcomp_parse++;

d2482 1
a2482 1
			vFAIL("Reference to nonexistent group");
d2488 2
d2497 1
a2497 1
		FAIL("Trailing \\");
d2515 1
a2515 1
	    register STRLEN len;
d2519 1
a2519 1
	    STRLEN numlen;
d2599 5
a2603 9
			    if (!e) {
				PL_regcomp_parse = p + 1;
				vFAIL("Missing right brace on \\x{}");
			    }
			    else {
				numlen = 1;	/* allow underscores */
				ender = (UV)scan_hex(p + 1, e - p - 1, &numlen);
				/* numlen is generous */
				if (numlen + len >= 127) {
d2609 2
a2612 1
			    numlen = 0;		/* disallow underscores */
a2625 1
			    numlen = 0;		/* disallow underscores */
d2636 1
a2636 1
			    FAIL("Trailing \\");
d2640 4
a2643 1
			    vWARN2(p +1, "Unrecognized escape \\%c passed through", *p);
d2649 2
a2650 3
		    if (UTF8_IS_START(*p) && UTF) {
			ender = utf8_to_uv((U8*)p, PL_regxend - p,
					   &numlen, 0);
a2667 2
		    /* ender is a Unicode value so it can be > 0xff --
		     * in other words, do not use UTF8_IS_CONTINUED(). */
a2678 2
		/* ender is a Unicode value so it can be > 0xff --
		 * in other words, do not use UTF8_IS_CONTINUED(). */
d2690 2
a2691 6
	    {
		/* len is STRLEN which is unsigned, need to copy to signed */
		IV iv = len;
		if (iv < 0)
		    vFAIL("Internal disaster");
	    }
d2734 1
a2772 5
		    case 'b':
			if (strnEQ(posixcc, "blank", 5))
			    namedclass =
				complement ? ANYOF_NBLANK : ANYOF_BLANK;
			break;
d2804 1
a2804 2
				complement ? ANYOF_NPSXSPC : ANYOF_PSXSPC;
			break;
d2828 4
a2831 5
		    {
			Simple_vFAIL3("POSIX class [:%.*s:] unknown",
				      t - s - 1, s + 1);
		    }
		} else if (!SIZE_ONLY) {
d2833 2
a2834 7

		    /* adjust PL_regcomp_parse so the warning shows after
		       the class closes */
		    while (*PL_regcomp_parse && *PL_regcomp_parse != ']')
			PL_regcomp_parse++;
		    Simple_vFAIL3("POSIX syntax [%c %c] is reserved for future extensions", c, c);
		}
d2859 2
a2860 3
	    vWARN3(s+2, "POSIX syntax [%c %c] belongs inside character classes", c, c);

	    /* [[=foo=]] and [[.foo.]] are still future. */
d2862 2
a2863 7
	    {
		/* adjust PL_regcomp_parse so the error shows after
		   the class closes */
		while (*PL_regcomp_parse && *PL_regcomp_parse++ != ']')
		    ;
		Simple_vFAIL3("POSIX syntax [%c %c] is reserved for future extensions", c, c);
	    }
d2871 1
d2876 1
a2876 1
    STRLEN numlen;
d2916 1
a2916 1
	     * values, therefore the 'value' cannot be an UV. --jhi */
a2936 1
		numlen = 0;		/* disallow underscores */
a2945 1
		numlen = 0;		/* disallow underscores */
d2951 4
a2954 2

		    vWARN2(PL_regcomp_parse, "Unrecognized escape \\%c in character class passed through", (int)value);
d2965 6
a2970 5
			vWARN4(PL_regcomp_parse,
			       "False [] range \"%*.*s\"",
			       PL_regcomp_parse - rangebegin,
			       PL_regcomp_parse - rangebegin,
			       rangebegin);
a3095 18
		case ANYOF_BLANK:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_BLANK);
		    else {
			for (value = 0; value < 256; value++)
			    if (isBLANK(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    break;
		case ANYOF_NBLANK:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_NBLANK);
		    else {
			for (value = 0; value < 256; value++)
			    if (!isBLANK(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    break;
a3168 18
		case ANYOF_PSXSPC:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_PSXSPC);
		    else {
			for (value = 0; value < 256; value++)
			    if (isPSXSPC(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    break;
		case ANYOF_NPSXSPC:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_NPSXSPC);
		    else {
			for (value = 0; value < 256; value++)
			    if (!isPSXSPC(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    break;
d3224 1
a3224 1
		    vFAIL("Invalid [::] class");
d3234 6
a3239 4
		Simple_vFAIL4("Invalid [] range \"%*.*s\"",
			      PL_regcomp_parse - rangebegin,
			      PL_regcomp_parse - rangebegin,
			      rangebegin);
d3250 6
a3255 5
			vWARN4(PL_regcomp_parse,
			       "False [] range \"%*.*s\"",
			       PL_regcomp_parse - rangebegin,
			       PL_regcomp_parse - rangebegin,
			       rangebegin);
d3316 1
d3322 1
a3322 1
    STRLEN numlen;
d3340 1
a3340 1
	listsv = newSVpvn("# comment\n", 10);
d3354 1
a3354 3
	value = utf8_to_uv((U8*)PL_regcomp_parse,
			       PL_regxend - PL_regcomp_parse,
			       &numlen, 0);
d3359 1
a3359 3
	    value = (U32)utf8_to_uv((U8*)PL_regcomp_parse,
					PL_regxend - PL_regcomp_parse,
					&numlen, 0);
d3376 1
a3376 1
                        vFAIL("Missing right brace on \\p{}");
d3409 2
a3410 3
                    if (!e) 
                        vFAIL("Missing right brace on \\x{}");
		    numlen = 1;		/* allow underscores */
a3416 1
		    numlen = 0;		/* disallow underscores */
a3426 1
		numlen = 0;		/* disallow underscores */
d3432 4
a3435 3
		    vWARN2(PL_regcomp_parse,
			   "Unrecognized escape \\%c in character class passed through",
			   (int)value);
d3443 6
a3448 5
			vWARN4(PL_regcomp_parse,
			       "False [] range \"%*.*s\"",
			       PL_regcomp_parse - rangebegin,
			       PL_regcomp_parse - rangebegin,
			       rangebegin);
d3498 1
a3498 1
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsSpacePerl\n");break;
a3499 8
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsSpacePerl\n");break;
		case ANYOF_BLANK:
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsBlank\n");	break;
		case ANYOF_NBLANK:
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsBlank\n");	break;
		case ANYOF_PSXSPC:
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsSpace\n");	break;
		case ANYOF_NPSXSPC:
d3515 6
a3520 4
		Simple_vFAIL4("Invalid [] range \"%*.*s\"",
			      PL_regcomp_parse - rangebegin,
			      PL_regcomp_parse - rangebegin,
			      rangebegin);
d3531 6
a3536 5
			vWARN4(PL_regcomp_parse,
			       "False [] range \"%*.*s\"",
			       PL_regcomp_parse - rangebegin,
			       PL_regcomp_parse - rangebegin,
			       rangebegin);
a3556 6
#ifdef DEBUGGING
	AV *av = newAV();
	av_push(av, rv);
	av_push(av, listsv);
	rv = newRV_noinc((SV*)av);
#else
a3557 1
#endif
d3570 1
d3603 1
d3628 1
d3651 1
a3651 1
S_reguni(pTHX_ UV uv, char* s, STRLEN* lenp)
d3653 8
a3660 1
    *lenp = SIZE_ONLY ? UNISKIP(uv) : (uv_to_utf8((U8*)s, uv) - (U8*)s);
d3671 1
d3702 1
d3732 1
d3846 1
d3913 1
a3913 1
    if (isCNTRL(c) || c == 127 || c == 255)
d3928 1
d3933 1
a3933 1
	FAIL("Corrupted regexp opcode");
d3942 1
a3942 1
	if (OP(o) == CURLYM || OP(o) == CURLYN || OP(o) == CURLYX)
d3954 2
a3955 4
	bool anyofutf8 = OP(o) == ANYOFUTF8;
	U8 flags = anyofutf8 ? ARG1(o) : o->flags;
	const char * const anyofs[] = {	/* Should be syncronized with
					 * ANYOF_ #xdefines in regcomp.h */
d3979 1
a3979 1
	    "[:^upper:]",
d3981 1
a3981 5
	    "[:^xdigit:]",
	    "[:space:]",
	    "[:^space:]",
	    "[:blank:]",
	    "[:^blank:]"
d3984 1
a3984 1
	if (flags & ANYOF_LOCALE)
d3986 1
a3986 1
	if (flags & ANYOF_FOLD)
d3989 1
a3989 1
	if (flags & ANYOF_INVERT)
d3991 7
a3997 10
	if (OP(o) == ANYOF) {
	    for (i = 0; i <= 256; i++) {
		if (i < 256 && ANYOF_BITMAP_TEST(o,i)) {
		    if (rangestart == -1)
			rangestart = i;
		} else if (rangestart != -1) {
		    if (i <= rangestart + 3)
			for (; rangestart < i; rangestart++)
			    put_byte(sv, rangestart);
		    else {
d3999 4
a4002 58
			sv_catpv(sv, "-");
			put_byte(sv, i - 1);
		    }
		    rangestart = -1;
		}
	    }
	    if (o->flags & ANYOF_CLASS)
		for (i = 0; i < sizeof(anyofs)/sizeof(char*); i++)
		    if (ANYOF_CLASS_TEST(o,i))
			sv_catpv(sv, anyofs[i]);
	}
	else {
	    SV *rv = (SV*)PL_regdata->data[ARG2(o)];
	    AV *av = (AV*)SvRV((SV*)rv);
	    SV *sw = *av_fetch(av, 0, FALSE);
	    SV *lv = *av_fetch(av, 1, FALSE);
	    UV i;
	    U8 s[UTF8_MAXLEN+1];
	    for (i = 0; i <= 256; i++) { /* just the first 256 */
		U8 *e = uv_to_utf8(s, i);
		if (i < 256 && swash_fetch(sw, s)) {
		    if (rangestart == -1)
			rangestart = i;
		} else if (rangestart != -1) {
		    U8 *p;

		    if (i <= rangestart + 3)
			for (; rangestart < i; rangestart++) {
			    for(e = uv_to_utf8(s, rangestart), p = s; p < e; p++)
				put_byte(sv, *p);
			}
		    else {
			for (e = uv_to_utf8(s, rangestart), p = s; p < e; p++)
			    put_byte(sv, *p);
			sv_catpv(sv, "-");
			for (e = uv_to_utf8(s, i - 1), p = s; p < e; p++)
			    put_byte(sv, *p);
		    }
		    rangestart = -1;
		}
	    }
	    sv_catpv(sv, "...");
	    {
		char *s = savepv(SvPVX(lv));

		while(*s && *s != '\n') s++;
		if (*s == '\n') {
		    char *t = ++s;

		    while (*s) {
			if (*s == '\n')
			    *s = ' ';
			s++;
		    }
		    if (s[-1] == ' ')
			s[-1] = 0;

		    sv_catpv(sv, t);
d4004 1
d4007 4
d4040 1
d4085 2
a4086 7
		/* Watch out for global destruction's random ordering. */
		if (SvTYPE(new_comppad) == SVt_PVAV) {
		    PL_comppad = new_comppad;
		    PL_curpad = AvARRAY(new_comppad);
		}
		else
		    PL_curpad = NULL;
d4116 1
d4168 1
d4182 1
a4182 1
    SAVEGENERICPV(PL_reg_start_tmp);	/* from regexec.c */
d4184 1
a4209 1
    SAVEI32(PL_regnpar);		/* () count. */
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d43 1
a43 1
#  define Perl_reginitcolors my_reginitcolors
d46 1
a46 1
#endif
d72 1
a72 1
 ****    Copyright (c) 1991-2002, Larry Wall
d86 5
a90 1
#ifndef PERL_IN_XSUB_RE
a113 45
typedef struct RExC_state_t {
    U32		flags;			/* are we folding, multilining? */
    char	*precomp;		/* uncompiled string. */
    regexp	*rx;
    char	*start;			/* Start of input for compile */
    char	*end;			/* End of input for compile */
    char	*parse;			/* Input-scan pointer. */
    I32		whilem_seen;		/* number of WHILEM in this expr */
    regnode	*emit_start;		/* Start of emitted-code area */
    regnode	*emit;			/* Code-emit pointer; &regdummy = don't = compiling */
    I32		naughty;		/* How bad is this pattern? */
    I32		sawback;		/* Did we see \1, ...? */
    U32		seen;
    I32		size;			/* Code size. */
    I32		npar;			/* () count. */
    I32		extralen;
    I32		seen_zerolen;
    I32		seen_evals;
    I32		utf8;
#if ADD_TO_REGEXEC
    char 	*starttry;		/* -Dr: where regtry was called. */
#define RExC_starttry	(pRExC_state->starttry)
#endif
} RExC_state_t;

#define RExC_flags	(pRExC_state->flags)
#define RExC_precomp	(pRExC_state->precomp)
#define RExC_rx		(pRExC_state->rx)
#define RExC_start	(pRExC_state->start)
#define RExC_end	(pRExC_state->end)
#define RExC_parse	(pRExC_state->parse)
#define RExC_whilem_seen	(pRExC_state->whilem_seen)
#define RExC_offsets	(pRExC_state->rx->offsets) /* I am not like the others */
#define RExC_emit	(pRExC_state->emit)
#define RExC_emit_start	(pRExC_state->emit_start)
#define RExC_naughty	(pRExC_state->naughty)
#define RExC_sawback	(pRExC_state->sawback)
#define RExC_seen	(pRExC_state->seen)
#define RExC_size	(pRExC_state->size)
#define RExC_npar	(pRExC_state->npar)
#define RExC_extralen	(pRExC_state->extralen)
#define RExC_seen_zerolen	(pRExC_state->seen_zerolen)
#define RExC_seen_evals	(pRExC_state->seen_evals)
#define RExC_utf8	(pRExC_state->utf8)

d157 1
a157 1
static scan_data_t zero_scan_data = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
d189 4
a192 3
#define UTF (RExC_utf8 != 0)
#define LOC ((RExC_flags & PMf_LOCALE) != 0)
#define FOLD ((RExC_flags & PMf_FOLD) != 0)
d194 2
a195 1
#define OOB_UNICODE		12345678
d210 4
a213 4
#define MARKER1 "<-- HERE"    /* marker as it appears in the description */
#define MARKER2 " <-- HERE "  /* marker as it appears within the regex */

#define REPORT_LOCATION " in regex; marked by " MARKER1 " in m/%.*s" MARKER2 "%s/"
d223 1
a223 1
        IV len = RExC_end - RExC_precomp;                                \
d226 1
a226 1
	    SAVEDESTRUCTOR_X(clear_re,(void*)RExC_rx);                 \
d234 1
a234 1
		   msg, (int)len, RExC_precomp, ellipses);                  \
d245 1
a245 1
        IV len = RExC_end - RExC_precomp;                                \
d248 1
a248 1
	    SAVEDESTRUCTOR_X(clear_re,(void*)RExC_rx);                 \
d256 1
a256 1
		    msg, (int)len, RExC_precomp, ellipses);                \
d265 1
a265 1
      IV offset = RExC_parse - RExC_precomp; \
d268 1
a268 1
		 m, (int)offset, RExC_precomp, RExC_precomp + offset);     \
d277 1
a277 1
	    SAVEDESTRUCTOR_X(clear_re,(void*)RExC_rx);                 \
d286 1
a286 1
      IV offset = RExC_parse - RExC_precomp; \
d289 1
a289 1
		  (int)offset, RExC_precomp, RExC_precomp + offset);       \
d298 1
a298 1
	    SAVEDESTRUCTOR_X(clear_re,(void*)RExC_rx);                 \
d308 1
a308 1
      IV offset = RExC_parse - RExC_precomp; \
d311 1
a311 1
		  (int)offset, RExC_precomp, RExC_precomp + offset);       \
d320 1
a320 1
	    SAVEDESTRUCTOR_X(clear_re,(void*)RExC_rx);                 \
d329 1
a329 1
      IV offset = RExC_parse - RExC_precomp; \
d332 1
a332 1
		  (int)offset, RExC_precomp, RExC_precomp + offset);       \
d340 1
a340 1
      IV offset = RExC_parse - RExC_precomp; \
d342 1
a342 1
		  (int)offset, RExC_precomp, RExC_precomp + offset);       \
d348 3
a350 10
        IV offset = loc - RExC_precomp;          \
	Perl_warner(aTHX_ packWARN(WARN_REGEXP), "%s" REPORT_LOCATION,\
		 m, (int)offset, RExC_precomp, RExC_precomp + offset);          \
    } STMT_END                                                               \

#define	vWARNdep(loc,m)                                                         \
    STMT_START {                                                             \
        IV offset = loc - RExC_precomp;          \
	Perl_warner(aTHX_ packWARN2(WARN_DEPRECATED, WARN_REGEXP), "%s" REPORT_LOCATION,\
		 m, (int)offset, RExC_precomp, RExC_precomp + offset);          \
d356 2
a357 2
        IV offset = loc - RExC_precomp;          \
	Perl_warner(aTHX_ packWARN(WARN_REGEXP), m REPORT_LOCATION,\
d359 1
a359 1
		 (int)offset, RExC_precomp, RExC_precomp + offset);        \
d364 2
a365 2
      IV offset = loc - RExC_precomp;        \
	Perl_warner(aTHX_ packWARN(WARN_REGEXP), m REPORT_LOCATION,                    \
d367 1
a367 1
		 (int)offset, RExC_precomp, RExC_precomp + offset);        \
d372 2
a373 2
      IV offset = loc - RExC_precomp;            \
	Perl_warner(aTHX_ packWARN(WARN_REGEXP), m REPORT_LOCATION,\
d375 1
a375 1
		 (int)offset, RExC_precomp, RExC_precomp + offset);        \
a377 8
/* used for the parse_flags section for (?c) -- japhy */
#define	vWARN5(loc, m, a1, a2, a3, a4)                                       \
  STMT_START {                                                   \
      IV offset = loc - RExC_precomp;   \
        Perl_warner(aTHX_ packWARN(WARN_REGEXP), m REPORT_LOCATION,      \
                 a1, a2, a3, a4,                                 \
                 (int)offset, RExC_precomp, RExC_precomp + offset);  \
    } STMT_END
d381 1
a381 7
#define REGC(c,s) STMT_START { if (!SIZE_ONLY) *(s) = (c); else (void)(s);} STMT_END

/* Macros for recording node offsets.   20001227 mjd@@plover.com 
 * Nodes are numbered 1, 2, 3, 4.  Node #n's position is recorded in
 * element 2*n-1 of the array.  Element #2n holds the byte length node #n.
 * Element 0 holds the number n.
 */
d383 1
a383 39
#define MJD_OFFSET_DEBUG(x)
/* #define MJD_OFFSET_DEBUG(x) fprintf x */


#  define Set_Node_Offset_To_R(node,byte)                           \
   STMT_START {                                        \
     if (! SIZE_ONLY) {                                  \
       if((node) < 0) {                   \
         Perl_croak(aTHX_ "value of node is %d in Offset macro", node); \
       } else {                                                        \
         RExC_offsets[2*(node)-1] = (byte);                               \
       }                                                               \
     }                                                                 \
   } STMT_END

#  define Set_Node_Offset(node,byte) Set_Node_Offset_To_R((node)-RExC_emit_start, (byte)-RExC_start)
#  define Set_Cur_Node_Offset Set_Node_Offset(RExC_emit, RExC_parse)

#  define Set_Node_Length_To_R(node,len)                            \
   STMT_START {                                        \
     if (! SIZE_ONLY) {                                  \
       MJD_OFFSET_DEBUG((stderr, "** (%d) size of node %d is %d.\n", __LINE__, (node), (len))); \
       if((node) < 0) {                   \
         Perl_croak(aTHX_ "value of node is %d in Length macro", node); \
       } else {                                                        \
         RExC_offsets[2*(node)] = (len);                               \
       }                                                               \
     }                                                                 \
   } STMT_END

#  define Set_Node_Length(node,len) Set_Node_Length_To_R((node)-RExC_emit_start, len)
#  define Set_Cur_Node_Length(len)  Set_Node_Length(RExC_emit, len)
#  define Set_Node_Cur_Length(node)   Set_Node_Length(node, RExC_parse - parse_start)

/* Get offsets and lengths */
#define Node_Offset(n) (RExC_offsets[2*((n)-RExC_emit_start)-1])
#define Node_Length(n) (RExC_offsets[2*((n)-RExC_emit_start)])

static void clear_re(pTHX_ void *r);
d390 1
a390 1
S_scan_commit(pTHX_ RExC_state_t *pRExC_state, scan_data_t *data)
d394 1
a394 1

d400 1
a400 1
		data->flags
d407 2
a408 2
	    data->offset_float_max = (l
				      ? data->last_start_max
a409 2
	    if ((U32)data->offset_float_max > (U32)I32_MAX)
		data->offset_float_max = I32_MAX;
d411 1
a411 1
		data->flags
d424 1
a424 1
S_cl_anything(pTHX_ RExC_state_t *pRExC_state, struct regnode_charclass_class *cl)
d426 2
d429 3
a431 2
    ANYOF_BITMAP_SETALL(cl);
    cl->flags = ANYOF_EOS|ANYOF_UNICODE_ALL;
d445 3
a447 4
    if (!(cl->flags & ANYOF_UNICODE_ALL))
	return 0;
    if (!ANYOF_BITMAP_TESTALLSET(cl))
	return 0;
d453 1
a453 1
S_cl_init(pTHX_ RExC_state_t *pRExC_state, struct regnode_charclass_class *cl)
d457 1
a457 1
    cl_anything(pRExC_state, cl);
d461 1
a461 1
S_cl_init_zero(pTHX_ RExC_state_t *pRExC_state, struct regnode_charclass_class *cl)
d465 1
a465 1
    cl_anything(pRExC_state, cl);
a491 10

    if (cl->flags & ANYOF_UNICODE_ALL && and_with->flags & ANYOF_UNICODE) {
	cl->flags &= ~ANYOF_UNICODE_ALL;
	cl->flags |= ANYOF_UNICODE;
	ARG_SET(cl, ARG(and_with));
    }
    if (!(and_with->flags & ANYOF_UNICODE_ALL))
	cl->flags &= ~ANYOF_UNICODE_ALL;
    if (!(and_with->flags & (ANYOF_UNICODE|ANYOF_UNICODE_ALL)))
	cl->flags &= ~ANYOF_UNICODE;
d497 1
a497 1
S_cl_or(pTHX_ RExC_state_t *pRExC_state, struct regnode_charclass_class *cl, struct regnode_charclass_class *or_with)
d518 1
a518 1
	    cl_anything(pRExC_state, cl);
d523 1
a523 1
	     && (!(or_with->flags & ANYOF_FOLD)
d537 1
a537 1
	    cl_anything(pRExC_state, cl);
a541 10

    if (cl->flags & ANYOF_UNICODE && or_with->flags & ANYOF_UNICODE &&
	ARG(cl) != ARG(or_with)) {
	cl->flags |= ANYOF_UNICODE_ALL;
	cl->flags &= ~ANYOF_UNICODE;
    }
    if (or_with->flags & ANYOF_UNICODE_ALL) {
	cl->flags |= ANYOF_UNICODE_ALL;
	cl->flags &= ~ANYOF_UNICODE;
    }
a543 11
/*
 * There are strange code-generation bugs caused on sparc64 by gcc-2.95.2.
 * These need to be revisited when a newer toolchain becomes available.
 */
#if defined(__sparc64__) && defined(__GNUC__)
#   if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 96)
#       undef  SPARC64_GCC_WORKAROUND
#       define SPARC64_GCC_WORKAROUND 1
#   endif
#endif

d551 1
a551 1
S_study_chunk(pTHX_ RExC_state_t *pRExC_state, regnode **scanp, I32 *deltap, regnode *last, scan_data_t *data, U32 flags)
d564 1
a564 1

d574 1
a574 1
#endif
d579 1
a579 1
		   ( PL_regkind[(U8)OP(n)] == NOTHING ||
d591 1
a591 1
#endif
d598 1
a598 1
		    if (oldl + STR_LEN(n) > U8_MAX)
d607 1
a607 1
#endif
a610 44

	    if (UTF && OP(scan) == EXACTF && STR_LEN(scan) >= 6) {
/*
  Two problematic code points in Unicode casefolding of EXACT nodes:

   U+0390 - GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS
   U+03B0 - GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS

   which casefold to

   Unicode			UTF-8

   U+03B9 U+0308 U+0301		0xCE 0xB9 0xCC 0x88 0xCC 0x81
   U+03C5 U+0308 U+0301		0xCF 0x85 0xCC 0x88 0xCC 0x81

   This means that in case-insensitive matching (or "loose matching",
   as Unicode calls it), an EXACTF of length six (the UTF-8 encoded byte
   length of the above casefolded versions) can match a target string
   of length two (the byte length of UTF-8 encoded U+0390 or U+03B0).
   This would rather mess up the minimum length computation.

   What we'll do is to look for the tail four bytes, and then peek
   at the preceding two bytes to see whether we need to decrease
   the minimum length by four (six minus two).

   Thanks to the design of UTF-8, there cannot be false matches:
   A sequence of valid UTF-8 bytes cannot be a subsequence of
   another valid sequence of UTF-8 bytes.

*/
		 char *s0 = STRING(scan), *s, *t;
		 char *s1 = s0 + STR_LEN(scan) - 1, *s2 = s1 - 4;
		 char *t0 = "\xcc\x88\xcc\x81";
		 char *t1 = t0 + 3;
		 
		 for (s = s0 + 2;
		      s < s2 && (t = ninstr(s, s1, t0, t1));
		      s = t + 4) {
		      if (((U8)t[-1] == 0xB9 && (U8)t[-2] == 0xCE) ||
			  ((U8)t[-1] == 0x85 && (U8)t[-2] == 0xCF))
			   min -= 4;
		 }
	    }

d633 1
a633 1
	
d642 1
a642 1
	    else
d647 1
a647 1
	if (OP(scan) == BRANCH || OP(scan) == BRANCHJ
d651 2
a652 2
	
	    if (OP(next) == code || code == IFTHEN || code == SUSPEND) {
d657 1
a657 1
		    scan_commit(pRExC_state, data); /* Cannot merge strings after this. */
d659 1
a659 1
		    cl_init_zero(pRExC_state, &accum);
d661 1
a661 1
		    I32 deltanext, minnext, f = 0, fake;
d666 1
a666 1
		    if (data) {		
d677 1
a677 1
			cl_init(pRExC_state, &this_class);
d680 1
a680 1
		    }		
d684 3
a686 3
		    minnext = study_chunk(pRExC_state, &scan, &deltanext,
					  next, &data_fake, f);
		    if (min1 > minnext)
d700 2
a701 2
			cl_or(pRExC_state, &accum, &this_class);
		    if (code == SUSPEND)
d715 1
a715 1
		    cl_or(pRExC_state, data->start_class, &accum);
d727 1
a727 1
			/* Switch to OR mode: cache the old value of
a746 1
	    UV uc = *((U8*)STRING(scan));
d748 8
a755 3
		U8 *s = (U8*)STRING(scan);
		l = utf8_length(s, s + l);
		uc = utf8_to_uvchr(s, NULL);
d764 1
a764 1
 			? I32_MAX : data->pos_min + data->pos_delta;
a766 2
		if (UTF)
		    SvUTF8_on(data->last_found);
d775 2
a776 3
		if (uc >= 0x100 ||
		    (!(data->start_class->flags & (ANYOF_CLASS | ANYOF_LOCALE))
		    && !ANYOF_BITMAP_TEST(data->start_class, uc)
d778 2
a779 2
			|| !ANYOF_BITMAP_TEST(data->start_class, PL_fold[uc])))
                    )
d784 1
a784 1
		    ANYOF_BITMAP_SET(data->start_class, uc);
a785 2
		if (uc < 0x100)
		  data->start_class->flags &= ~ANYOF_UNICODE_ALL;
d789 1
a789 4
		if (uc < 0x100)
		    ANYOF_BITMAP_SET(data->start_class, uc);
		else
		    data->start_class->flags |= ANYOF_UNICODE_ALL;
a796 1
	    UV uc = *((U8*)STRING(scan));
d799 2
a800 2
	    if (flags & SCF_DO_SUBSTR)
		scan_commit(pRExC_state, data);
d802 8
a809 3
		U8 *s = (U8 *)STRING(scan);
		l = utf8_length(s, s + l);
		uc = utf8_to_uvchr(s, NULL);
d818 4
a821 4
		if (uc >= 0x100 ||
		    (!(data->start_class->flags & (ANYOF_CLASS | ANYOF_LOCALE))
		    && !ANYOF_BITMAP_TEST(data->start_class, uc)
		     && !ANYOF_BITMAP_TEST(data->start_class, PL_fold[uc])))
d826 1
a826 1
		    ANYOF_BITMAP_SET(data->start_class, uc);
d837 1
a837 2
		    if (uc < 0x100)
			ANYOF_BITMAP_SET(data->start_class, uc);
d845 1
a845 1
	    I32 mincount, maxcount, minnext, deltanext, fl = 0;
a849 1
	    I32 next_is_eval = 0;
d859 2
a860 2
			mincount = 1;
			maxcount = REG_INFTY;
d873 1
a873 1
		    maxcount = REG_INFTY;
d878 1
a878 1
		is_inf = is_inf_internal = 1;
d881 1
a881 1
		    scan_commit(pRExC_state, data); /* Cannot extend fixed substrings */
d886 1
a886 1
		mincount = ARG1(scan);
a894 1
		next_is_eval = (OP(scan) == EVAL);
d897 1
a897 1
		    if (mincount == 0) scan_commit(pRExC_state,data); /* Cannot extend fixed substrings */
d907 1
a907 1
		    cl_init(pRExC_state, &this_class);
d916 1
a916 1
		
d923 2
a924 2
		minnext = study_chunk(pRExC_state, &scan, &deltanext, last, data,
				      mincount == 0
d931 1
a931 1
			cl_or(pRExC_state, data->start_class, &this_class);
d934 1
a934 1
			/* Switch to OR mode: cache the old value of
d946 1
a946 1
			cl_or(pRExC_state, data->start_class, &this_class);
d955 2
a956 5
		if (ckWARN(WARN_REGEXP)
		       /* ? quantifier ok, except for (?{ ... }) */
		    && (next_is_eval || !(mincount == 0 && maxcount == 1))
		    && (minnext == 0) && (deltanext == 0)
		    && data && !(data->flags & (SF_HAS_PAR|SF_IN_PAR))
d959 1
a959 1
		    vWARN(RExC_parse,
d964 1
a964 1
		is_inf_internal |= ((maxcount == REG_INFTY
d971 1
a971 1
		if (  OP(oscan) == CURLYX && data
d977 1
a977 4
		    regnode *nxt1 = nxt;
#ifdef DEBUGGING
		    regnode *nxt2;
#endif
d983 1
a983 1
			     && STR_LEN(nxt) == 1))
a984 1
#ifdef DEBUGGING
a985 1
#endif
d987 1
a987 1
		    if (OP(nxt) != CLOSE)
d990 1
a990 1
		    oscan->flags = (U8)ARG(nxt);
d1000 1
a1000 1
#endif
d1005 1
a1005 1
		if (  OP(oscan) == CURLYX && data
d1016 1
a1016 1
			    && (OP(nxt2) != WHILEM))
d1024 1
a1024 1
			if (OP(nxt) != CLOSE)
d1026 1
a1026 1
			oscan->flags = (U8)ARG(nxt);
d1034 1
a1034 1
#endif
d1038 1
a1038 1
			
d1051 1
a1051 2
			study_chunk(pRExC_state, &nxt1, &deltanext, nxt,
				    NULL, 0);
d1069 2
a1070 2
		    PREVOPER(nxt)->flags = (U8)(data->whilem_c
			| (RExC_whilem_seen << 4)); /* On WHILEM */
d1072 1
a1072 1
		if (data && fl & (SF_HAS_PAR|SF_IN_PAR))
d1079 1
a1079 17
#if defined(SPARC64_GCC_WORKAROUND)
			I32 b = 0;
			STRLEN l = 0;
			char *s = NULL;
			I32 old = 0;

			if (pos_before >= data->last_start_min)
			    b = pos_before;
			else
			    b = data->last_start_min;

			l = 0;
			s = SvPV(data->last_found, l);
			old = b - data->last_start_min;

#else
			I32 b = pos_before >= data->last_start_min
a1083 1
#endif
d1095 1
a1095 1
				repeatcpy(SvPVX(last_str) + l,
d1099 1
a1099 1
				SvCUR_set(data->last_found,
d1118 1
a1118 1
			scan_commit(pRExC_state,data);
d1122 1
a1122 1
			    data->last_start_min =
d1124 2
a1125 2
			    data->last_start_max = is_inf
				? I32_MAX
d1144 1
a1144 1
		    scan_commit(pRExC_state,data);	/* Cannot expect anything... */
d1149 1
a1149 1
		    cl_anything(pRExC_state, data->start_class);
d1154 2
a1155 2
	else if (strchr((char*)PL_simple,OP(scan))) {
	    int value = 0;
d1158 1
a1158 1
		scan_commit(pRExC_state,data);
d1168 1
d1170 12
d1186 1
a1186 1
			cl_anything(pRExC_state, data->start_class);
d1194 1
a1194 1
			cl_anything(pRExC_state, data->start_class);
d1204 1
a1204 1
			cl_or(pRExC_state, data->start_class,
d1222 1
a1222 1
				    ANYOF_BITMAP_SET(data->start_class, value);			
d1251 1
a1251 1
				    ANYOF_BITMAP_SET(data->start_class, value);			
d1280 1
a1280 1
				    ANYOF_BITMAP_SET(data->start_class, value);			
d1309 1
a1309 1
				    ANYOF_BITMAP_SET(data->start_class, value);			
d1340 1
a1340 1
				    ANYOF_BITMAP_SET(data->start_class, value);			
d1357 1
a1357 1
				    ANYOF_BITMAP_SET(data->start_class, value);			
d1383 1
a1383 1
	    if (data) {		
d1391 1
a1391 1
		cl_init(pRExC_state, &intrnl);
d1399 1
a1399 1
	    minnext = study_chunk(pRExC_state, &nscan, &deltanext, last, &data_fake, f);
d1407 1
a1407 1
		scan->flags = (U8)minnext;
d1427 1
a1427 1
	    if ((I32)ARG(scan) == is_par) {
d1442 1
a1442 1
		    scan_commit(pRExC_state,data);
d1447 1
a1447 1
		    cl_anything(pRExC_state, data->start_class);
d1457 1
a1457 1
    if (flags & SCF_DO_SUBSTR && is_inf)
d1475 1
a1475 1
S_add_data(pTHX_ RExC_state_t *pRExC_state, I32 n, char *s)
d1477 3
a1479 3
    if (RExC_rx->data) {
	Renewc(RExC_rx->data,
	       sizeof(*RExC_rx->data) + sizeof(void*) * (RExC_rx->data->count + n - 1),
d1481 2
a1482 2
	Renew(RExC_rx->data->what, RExC_rx->data->count + n, U8);
	RExC_rx->data->count += n;
d1485 1
a1485 1
	Newc(1207, RExC_rx->data, sizeof(*RExC_rx->data) + sizeof(void*) * (n - 1),
d1487 2
a1488 2
	New(1208, RExC_rx->data->what, n, U8);
	RExC_rx->data->count = n;
d1490 2
a1491 2
    Copy(s, RExC_rx->data->what + RExC_rx->data->count - n, n, U8);
    return RExC_rx->data->count - n;
d1499 1
a1499 1
	
d1512 1
a1512 1
	while (i < 6)
a1544 2
    RExC_state_t RExC_state;
    RExC_state_t *pRExC_state = &RExC_state;
d1549 5
a1553 1
    RExC_utf8 = pm->op_pmdynflags & PMdf_CMP_UTF8;
d1555 12
a1566 14
    RExC_precomp = exp;
    DEBUG_r({
	 if (!PL_colorset) reginitcolors();
	 PerlIO_printf(Perl_debug_log, "%sCompiling REx%s `%s%*s%s'\n",
		       PL_colors[4],PL_colors[5],PL_colors[0],
		       (int)(xend - exp), RExC_precomp, PL_colors[1]);
    });
    RExC_flags = pm->op_pmflags;
    RExC_sawback = 0;

    RExC_seen = 0;
    RExC_seen_zerolen = *exp == '^' ? -1 : 0;
    RExC_seen_evals = 0;
    RExC_extralen = 0;
d1569 7
a1575 8
    RExC_parse = exp;
    RExC_start = exp;
    RExC_end = xend;
    RExC_naughty = 0;
    RExC_npar = 1;
    RExC_size = 0L;
    RExC_emit = &PL_regdummy;
    RExC_whilem_seen = 0;
d1578 1
a1578 1
    REGC((U8)REG_MAGIC, (char*)RExC_emit);
d1580 2
a1581 2
    if (reg(pRExC_state, 0, &flags) == NULL) {
	RExC_precomp = Nullch;
d1584 1
a1584 1
    DEBUG_r(PerlIO_printf(Perl_debug_log, "size %"IVdf" ", (IV)RExC_size));
d1588 2
a1589 2
    if (RExC_size >= 0x10000L && RExC_extralen)
        RExC_size += RExC_extralen;
d1591 3
a1593 3
	RExC_extralen = 0;
    if (RExC_whilem_seen > 15)
	RExC_whilem_seen = 15;
d1596 1
a1596 1
    Newc(1001, r, sizeof(regexp) + (unsigned)RExC_size * sizeof(regnode),
d1603 1
a1603 1
    Zero(r, sizeof(regexp) + (unsigned)RExC_size * sizeof(regnode), char);
d1607 1
a1607 1
    r->precomp = savepvn(RExC_precomp, r->prelen);
d1610 1
a1610 1
    r->nparens = RExC_npar - 1;	/* set early to validate backrefs */
d1616 1
a1616 10
    Newz(1304, r->offsets, 2*RExC_size+1, U32); /* MJD 20001228 */
    if (r->offsets) {
      r->offsets[0] = RExC_size; 
    }
    DEBUG_r(PerlIO_printf(Perl_debug_log, 
                          "%s %"UVuf" bytes for offset annotations.\n", 
                          r->offsets ? "Got" : "Couldn't get", 
                          (UV)((2*RExC_size+1) * sizeof(U32))));

    RExC_rx = r;
d1619 5
a1623 7
    RExC_flags = pm->op_pmflags;	/* don't let top level (?i) bleed */
    RExC_parse = exp;
    RExC_end = xend;
    RExC_naughty = 0;
    RExC_npar = 1;
    RExC_emit_start = r->program;
    RExC_emit = r->program;
d1625 2
a1626 2
    RExC_emit->next_off = (U16)((RExC_seen_evals > U16_MAX) ? U16_MAX : RExC_seen_evals);
    REGC((U8)REG_MAGIC, (char*) RExC_emit++);
d1628 1
a1628 1
    if (reg(pRExC_state, 0, &flags) == NULL)
d1633 1
a1633 1
    pm->op_pmflags = RExC_flags;
d1635 1
a1635 1
        r->reganch |= ROPT_UTF8;	/* Unicode in it? */
d1637 1
a1637 1
    if (RExC_naughty >= 10)	/* Probably an expensive pattern. */
d1673 3
a1675 3
	    if (OP(first) == EXACT)
	        ;	/* Empty, get anchored substr later. */
	    else if ((OP(first) == EXACTF || OP(first) == EXACTFL))
d1697 1
a1697 1
	else if (!sawopen && (OP(first) == STAR &&
d1704 1
a1704 1
	    if (type == REG_ANY)
d1713 2
a1714 2
	if (sawplus && (!sawopen || !RExC_sawback)
	    && !(RExC_seen & REG_SEEN_EVAL)) /* May examine pos and $& */
d1719 1
a1719 1
	DEBUG_r(PerlIO_printf(Perl_debug_log, "first at %"IVdf"\n",
d1740 1
a1740 1
	    cl_init(pRExC_state, &ch_class);
d1747 1
a1747 1
	minlen = study_chunk(pRExC_state, &first, &fake, scan + RExC_size, /* Up to end */
d1749 4
a1752 4
	if ( RExC_npar == 1 && data.longest == &(data.longest_fixed)
	     && data.last_start_min == 0 && data.last_end > 0
	     && !RExC_seen_zerolen
	     && (!(RExC_seen & REG_SEEN_GPOS) || (r->reganch & ROPT_ANCH_GPOS)))
d1754 1
a1754 1
	scan_commit(pRExC_state, &data);
d1761 1
a1761 1
		    || (RExC_flags & PMf_MULTILINE)))) {
d1769 1
a1769 7
	    if (SvUTF8(data.longest_float)) {
		r->float_utf8 = data.longest_float;
		r->float_substr = Nullsv;
	    } else {
		r->float_substr = data.longest_float;
		r->float_utf8 = Nullsv;
	    }
d1774 2
a1775 2
			   || (RExC_flags & PMf_MULTILINE)));
	    fbm_compile(data.longest_float, t ? FBMcf_TAIL : 0);
d1779 1
a1779 1
	    r->float_substr = r->float_utf8 = Nullsv;
d1788 1
a1788 1
		    || (RExC_flags & PMf_MULTILINE)))) {
d1791 1
a1791 7
	    if (SvUTF8(data.longest_fixed)) {
		r->anchored_utf8 = data.longest_fixed;
		r->anchored_substr = Nullsv;
	    } else {
		r->anchored_substr = data.longest_fixed;
		r->anchored_utf8 = Nullsv;
	    }
d1795 2
a1796 2
		     || (RExC_flags & PMf_MULTILINE)));
	    fbm_compile(data.longest_fixed, t ? FBMcf_TAIL : 0);
d1799 1
a1799 1
	    r->anchored_substr = r->anchored_utf8 = Nullsv;
d1803 3
a1805 2
	if (r->regstclass
	    && (OP(r->regstclass) == REG_ANY || OP(r->regstclass) == SANY))
d1807 1
a1807 2
	if ((!(r->anchored_substr || r->anchored_utf8) || r->anchored_offset)
	    && stclass_flag
d1809 3
a1811 3
	    && !cl_is_anything(data.start_class))
	{
	    I32 n = add_data(pRExC_state, 1, "f");
d1813 1
a1813 1
	    New(1006, RExC_rx->data->data[n], 1,
d1816 1
a1816 1
		       (struct regnode_charclass_class*)RExC_rx->data->data[n],
d1818 1
a1818 1
	    r->regstclass = (regnode*)RExC_rx->data->data[n];
d1820 4
a1823 6
	    PL_regdata = r->data; /* for regprop() */
	    DEBUG_r({ SV *sv = sv_newmortal();
	              regprop(sv, (regnode*)data.start_class);
		      PerlIO_printf(Perl_debug_log,
				    "synthetic stclass `%s'.\n",
				    SvPVX(sv));});
a1828 1
	    r->check_utf8 = r->anchored_utf8;
a1834 1
	    r->check_utf8 = r->float_utf8;
d1840 1
a1840 1
	if ((r->check_substr || r->check_utf8) && !(r->reganch & ROPT_ANCH_GPOS)) {
d1842 1
a1842 1
	    if (SvTAIL(r->check_substr ? r->check_substr : r->check_utf8))
d1854 1
a1854 1
	cl_init(pRExC_state, &ch_class);
d1857 2
a1858 3
	minlen = study_chunk(pRExC_state, &scan, &fake, scan + RExC_size, &data, SCF_DO_STCLASS_AND|SCF_WHILEM_VISITED_POS);
	r->check_substr = r->check_utf8 = r->anchored_substr = r->anchored_utf8
		= r->float_substr = r->float_utf8 = Nullsv;
d1860 3
a1862 3
	    && !cl_is_anything(data.start_class))
	{
	    I32 n = add_data(pRExC_state, 1, "f");
d1864 1
a1864 1
	    New(1006, RExC_rx->data->data[n], 1,
d1867 1
a1867 1
		       (struct regnode_charclass_class*)RExC_rx->data->data[n],
d1869 1
a1869 1
	    r->regstclass = (regnode*)RExC_rx->data->data[n];
d1871 4
a1874 5
	    DEBUG_r({ SV* sv = sv_newmortal();
	              regprop(sv, (regnode*)data.start_class);
		      PerlIO_printf(Perl_debug_log,
				    "synthetic stclass `%s'.\n",
				    SvPVX(sv));});
d1879 1
a1879 1
    if (RExC_seen & REG_SEEN_GPOS)
d1881 1
a1881 1
    if (RExC_seen & REG_SEEN_LOOKBEHIND)
d1883 1
a1883 1
    if (RExC_seen & REG_SEEN_EVAL)
d1885 3
a1887 5
    if (RExC_seen & REG_SEEN_CANY)
	r->reganch |= ROPT_CANY_SEEN;
    Newz(1002, r->startp, RExC_npar, I32);
    Newz(1002, r->endp, RExC_npar, I32);
    PL_regdata = r->data; /* for regprop() */
d1902 1
a1902 1
S_reg(pTHX_ RExC_state_t *pRExC_state, I32 paren, I32 *flagp)
d1910 2
a1911 13
    I32 flags, oregflags = RExC_flags, have_branch = 0, open = 0;

    /* for (?g), (?gc), and (?o) warnings; warning
       about (?c) will warn about (?g) -- japhy    */

    I32 wastedflags = 0x00,
        wasted_o    = 0x01,
        wasted_g    = 0x02,
        wasted_gc   = 0x02 | 0x04,
        wasted_c    = 0x04;

    char * parse_start = RExC_parse; /* MJD */
    char *oregcomp_parse = RExC_parse;
a1915 1

d1918 3
a1920 3
	if (*RExC_parse == '?') { /* (?...) */
	    U32 posflags = 0, negflags = 0;
	    U32 *flagsp = &posflags;
d1922 1
a1922 1
	    char *seqstart = RExC_parse;
d1924 2
a1925 2
	    RExC_parse++;
	    paren = *RExC_parse++;
d1928 3
a1930 3
	    case '<':           /* (?<...) */
		RExC_seen |= REG_SEEN_LOOKBEHIND;
		if (*RExC_parse == '!')
d1932 1
a1932 1
		if (*RExC_parse != '=' && *RExC_parse != '!')
d1934 6
a1939 6
		RExC_parse++;
	    case '=':           /* (?=...) */
	    case '!':           /* (?!...) */
		RExC_seen_zerolen++;
	    case ':':           /* (?:...) */
	    case '>':           /* (?>...) */
d1941 2
a1942 2
	    case '$':           /* (?$...) */
	    case '@@':           /* (?@@...) */
d1945 4
a1948 4
	    case '#':           /* (?#...) */
		while (*RExC_parse && *RExC_parse != ')')
		    RExC_parse++;
		if (*RExC_parse != ')')
d1950 1
a1950 1
		nextchar(pRExC_state);
d1953 3
a1955 3
	    case 'p':           /* (?p...) */
		if (SIZE_ONLY && ckWARN2(WARN_DEPRECATED, WARN_REGEXP))
		    vWARNdep(RExC_parse, "(?p{}) is deprecated - use (??{})");
d1957 1
a1957 1
	    case '?':           /* (??...) */
d1959 1
a1959 3
		if (*RExC_parse != '{')
		    goto unknown;
		paren = *RExC_parse++;
d1961 1
a1961 1
	    case '{':           /* (?{...}) */
d1965 1
a1965 1
		char *s = RExC_parse;
d1969 6
a1974 6
		RExC_seen_zerolen++;
		RExC_seen |= REG_SEEN_EVAL;
		while (count && (c = *RExC_parse)) {
		    if (c == '\\' && RExC_parse[1])
			RExC_parse++;
		    else if (c == '{')
d1976 1
a1976 1
		    else if (c == '}')
d1978 1
a1978 1
		    RExC_parse++;
d1980 1
a1980 1
		if (*RExC_parse != ')')
d1982 1
a1982 1
		    RExC_parse = s;		
d1987 3
a1989 3
		
		    if (RExC_parse - 1 - s)
			sv = newSVpvn(s, RExC_parse - 1 - s);
a1995 3
		    sop->op_private |= OPpREFCOUNTED;
		    /* re_dup will OpREFCNT_inc */
		    OpREFCNT_set(sop, 1);
d1998 4
a2001 4
		    n = add_data(pRExC_state, 3, "nop");
		    RExC_rx->data->data[n] = (void*)rop;
		    RExC_rx->data->data[n+1] = (void*)sop;
		    RExC_rx->data->data[n+2] = (void*)av;
d2005 1
a2005 1
		    if (PL_reginterp_cnt < ++RExC_seen_evals
d2010 1
a2010 1
		    if (PL_tainting && PL_tainted)
d2014 1
a2014 1
		nextchar(pRExC_state);
d2016 1
a2016 1
		    ret = reg_node(pRExC_state, LOGICAL);
d2019 1
a2019 2
		    regtail(pRExC_state, ret, reganode(pRExC_state, EVAL, n));
                    /* deal with the length of this later - MJD */
d2022 1
a2022 1
		return reganode(pRExC_state, EVAL, n);
d2024 1
a2024 1
	    case '(':           /* (?(?{...})...) and (?(?=...)...) */
d2026 4
a2029 4
		if (RExC_parse[0] == '?') {        /* (?(?...)) */
		    if (RExC_parse[1] == '=' || RExC_parse[1] == '!'
			|| RExC_parse[1] == '<'
			|| RExC_parse[1] == '{') { /* Lookahead or eval. */
d2032 1
a2032 1
			ret = reg_node(pRExC_state, LOGICAL);
d2035 1
a2035 1
			regtail(pRExC_state, ret, reg(pRExC_state, 1, &flag));
d2037 1
a2037 1
		    }
d2039 7
a2045 9
		else if (RExC_parse[0] >= '1' && RExC_parse[0] <= '9' ) {
                    /* (?(1)...) */
		    parno = atoi(RExC_parse++);

		    while (isDIGIT(*RExC_parse))
			RExC_parse++;
                    ret = reganode(pRExC_state, GROUPP, parno);
                    
		    if ((c = *nextchar(pRExC_state)) != ')')
d2048 2
a2049 2
		    regtail(pRExC_state, ret, reganode(pRExC_state, IFTHEN, 0));
		    br = regbranch(pRExC_state, &flags, 1);
d2051 1
a2051 1
			br = reganode(pRExC_state, LONGJMP, 0);
d2053 2
a2054 2
			regtail(pRExC_state, br, reganode(pRExC_state, LONGJMP, 0));
		    c = *nextchar(pRExC_state);
d2058 3
a2060 3
			lastbr = reganode(pRExC_state, IFTHEN, 0); /* Fake one for optimizer. */
			regbranch(pRExC_state, &flags, 1);
			regtail(pRExC_state, ret, lastbr);
d2063 1
a2063 1
			c = *nextchar(pRExC_state);
d2069 2
a2070 2
		    ender = reg_node(pRExC_state, TAIL);
		    regtail(pRExC_state, br, ender);
d2072 2
a2073 2
			regtail(pRExC_state, lastbr, ender);
			regtail(pRExC_state, NEXTOPER(NEXTOPER(lastbr)), ender);
d2076 1
a2076 1
			regtail(pRExC_state, ret, ender);
d2080 1
a2080 1
		    vFAIL2("Unknown switch condition (?(%.2s", RExC_parse);
d2084 1
a2084 1
		RExC_parse--; /* for vFAIL to print correctly */
d2088 6
a2093 38
		--RExC_parse;
	      parse_flags:      /* (?i) */
		while (*RExC_parse && strchr("iogcmsx", *RExC_parse)) {
		    /* (?g), (?gc) and (?o) are useless here
		       and must be globally applied -- japhy */

		    if (*RExC_parse == 'o' || *RExC_parse == 'g') {
			if (SIZE_ONLY && ckWARN(WARN_REGEXP)) {
			    I32 wflagbit = *RExC_parse == 'o' ? wasted_o : wasted_g;
			    if (! (wastedflags & wflagbit) ) {
				wastedflags |= wflagbit;
				vWARN5(
				    RExC_parse + 1,
				    "Useless (%s%c) - %suse /%c modifier",
				    flagsp == &negflags ? "?-" : "?",
				    *RExC_parse,
				    flagsp == &negflags ? "don't " : "",
				    *RExC_parse
				);
			    }
			}
		    }
		    else if (*RExC_parse == 'c') {
			if (SIZE_ONLY && ckWARN(WARN_REGEXP)) {
			    if (! (wastedflags & wasted_c) ) {
				wastedflags |= wasted_gc;
				vWARN3(
				    RExC_parse + 1,
				    "Useless (%sc) - %suse /gc modifier",
				    flagsp == &negflags ? "?-" : "?",
				    flagsp == &negflags ? "don't " : ""
				);
			    }
			}
		    }
		    else { pmflag(flagsp, *RExC_parse); }

		    ++RExC_parse;
d2095 1
a2095 1
		if (*RExC_parse == '-') {
d2097 1
a2097 2
		    wastedflags = 0;  /* reset so (?g-c) warns twice */
		    ++RExC_parse;
d2100 4
a2103 4
		RExC_flags |= posflags;
		RExC_flags &= ~negflags;
		if (*RExC_parse == ':') {
		    RExC_parse++;
d2108 3
a2110 3
		if (*RExC_parse != ')') {
		    RExC_parse++;
		    vFAIL3("Sequence (%.*s...) not recognized", RExC_parse-seqstart, seqstart);
d2112 1
a2112 1
		nextchar(pRExC_state);
d2117 4
a2120 6
	else {                  /* (...) */
	    parno = RExC_npar;
	    RExC_npar++;
	    ret = reganode(pRExC_state, OPEN, parno);
            Set_Node_Length(ret, 1); /* MJD */
            Set_Node_Offset(ret, RExC_parse); /* MJD */
d2124 1
a2124 1
    else                        /* ! paren */
d2128 1
a2128 4
    parse_start = RExC_parse;   /* MJD */
    br = regbranch(pRExC_state, &flags, 1);
    /*     branch_len = (paren != 0); */
    
d2131 6
a2136 9
    if (*RExC_parse == '|') {
	if (!SIZE_ONLY && RExC_extralen) {
	    reginsert(pRExC_state, BRANCHJ, br);
	}
	else {                  /* MJD */
	    reginsert(pRExC_state, BRANCH, br);
            Set_Node_Length(br, paren != 0);
            Set_Node_Offset_To_R(br-RExC_emit_start, parse_start-RExC_start);
        }
d2139 1
a2139 1
	    RExC_extralen += 1;		/* For BRANCHJ-BRANCH. */
d2145 1
a2145 1
	regtail(pRExC_state, ret, br);		/* OPEN -> first. */
d2149 3
a2151 1
    *flagp |= flags & (SPSTART | HASWIDTH);
d2153 4
a2156 4
    while (*RExC_parse == '|') {
	if (!SIZE_ONLY && RExC_extralen) {
	    ender = reganode(pRExC_state, LONGJMP,0);
	    regtail(pRExC_state, NEXTOPER(NEXTOPER(lastbr)), ender); /* Append to the previous. */
d2159 3
a2161 4
	    RExC_extralen += 2;		/* Account for LONGJMP. */
	nextchar(pRExC_state);
	br = regbranch(pRExC_state, &flags, 0);
        
d2164 1
a2164 1
	regtail(pRExC_state, lastbr, br);		/* BRANCH -> BRANCH. */
d2175 1
a2175 1
	    ender = reg_node(pRExC_state, TAIL);
d2178 1
a2178 3
	    ender = reganode(pRExC_state, CLOSE, parno);
            Set_Node_Offset(ender,RExC_parse+1); /* MJD */
            Set_Node_Length(ender,1); /* MJD */
d2187 1
a2187 1
	    ender = reg_node(pRExC_state, SUCCEED);
d2190 1
a2190 1
	    ender = reg_node(pRExC_state, END);
d2193 1
a2193 1
	regtail(pRExC_state, lastbr, ender);
d2198 1
a2198 1
		regoptail(pRExC_state, br, ender);
d2208 1
a2208 1
	    U8 node = ((p - parens) % 2) ? UNLESSM : IFMATCH;
d2213 1
a2213 1
	    reginsert(pRExC_state, node,ret);
d2215 1
a2215 1
	    regtail(pRExC_state, ret, reg_node(pRExC_state, TAIL));
d2221 3
a2223 3
	RExC_flags = oregflags;
	if (RExC_parse >= RExC_end || *nextchar(pRExC_state) != ')') {
	    RExC_parse = oregcomp_parse;
d2227 3
a2229 3
    else if (!paren && RExC_parse < RExC_end) {
	if (*RExC_parse == ')') {
	    RExC_parse++;
d2246 1
a2246 1
S_regbranch(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, I32 first)
d2253 1
a2253 1
    if (first)
d2256 4
a2259 6
	if (!SIZE_ONLY && RExC_extralen)
	    ret = reganode(pRExC_state, BRANCHJ,0);
	else {
	    ret = reg_node(pRExC_state, BRANCH);
            Set_Node_Length(ret, 1);
        }
d2262 3
a2264 3
    if (!first && SIZE_ONLY)
	RExC_extralen += 1;			/* BRANCHJ */

d2267 3
a2269 3
    RExC_parse--;
    nextchar(pRExC_state);
    while (RExC_parse < RExC_end && *RExC_parse != '|' && *RExC_parse != ')') {
d2271 1
a2271 1
	latest = regpiece(pRExC_state, &flags);
d2283 2
a2284 2
	    RExC_naughty++;
	    regtail(pRExC_state, chain, latest);
d2290 1
a2290 1
	chain = reg_node(pRExC_state, NOTHING);
d2311 1
a2311 1
S_regpiece(pTHX_ RExC_state_t *pRExC_state, I32 *flagp)
d2317 1
a2317 1
    char *origparse = RExC_parse;
a2320 1
    char *parse_start;
d2322 1
a2322 1
    ret = regatom(pRExC_state, &flags);
d2329 1
a2329 1
    op = *RExC_parse;
d2331 2
a2332 3
    if (op == '{' && regcurly(RExC_parse)) {
        parse_start = RExC_parse; /* MJD */
	next = RExC_parse + 1;
d2346 2
a2347 2
	    RExC_parse++;
	    min = atoi(RExC_parse);
d2351 1
a2351 1
		maxpos = RExC_parse;
d2357 2
a2358 2
	    RExC_parse = next;
	    nextchar(pRExC_state);
d2362 2
a2363 4
		RExC_naughty += 2 + RExC_naughty / 2;
		reginsert(pRExC_state, CURLY, ret);
                Set_Node_Offset(ret, parse_start+1); /* MJD */
                Set_Node_Cur_Length(ret);
d2366 1
a2366 1
		regnode *w = reg_node(pRExC_state, WHILEM);
d2369 4
a2372 4
		regtail(pRExC_state, ret, w);
		if (!SIZE_ONLY && RExC_extralen) {
		    reginsert(pRExC_state, LONGJMP,ret);
		    reginsert(pRExC_state, NOTHING,ret);
d2375 2
a2376 7
		reginsert(pRExC_state, CURLYX,ret);
                                /* MJD hk */
                Set_Node_Offset(ret, parse_start+1);
                Set_Node_Length(ret, 
                                op == '{' ? (RExC_parse - parse_start) : 1);
                
		if (!SIZE_ONLY && RExC_extralen)
d2378 1
a2378 1
		regtail(pRExC_state, ret, reg_node(pRExC_state, NOTHING));
d2380 2
a2381 2
		    RExC_whilem_seen++, RExC_extralen += 3;
		RExC_naughty += 4 + RExC_naughty;	/* compound interest */
d2392 2
a2393 2
		ARG1_SET(ret, (U16)min);
		ARG2_SET(ret, (U16)max);
d2419 1
a2419 1
#endif
d2421 1
a2421 2
    parse_start = RExC_parse;
    nextchar(pRExC_state);
d2426 1
a2426 1
	reginsert(pRExC_state, STAR, ret);
d2428 1
a2428 1
	RExC_naughty += 4;
d2435 1
a2435 1
	reginsert(pRExC_state, PLUS, ret);
d2437 1
a2437 1
	RExC_naughty += 3;
d2449 1
a2449 1
	vWARN3(RExC_parse,
d2451 1
a2451 1
	       RExC_parse - origparse,
d2455 4
a2458 4
    if (*RExC_parse == '?') {
	nextchar(pRExC_state);
	reginsert(pRExC_state, MINMOD, ret);
	regtail(pRExC_state, ret, ret + NODE_STEP_REGNODE);
d2460 2
a2461 2
    if (ISMULT2(RExC_parse)) {
	RExC_parse++;
d2478 1
a2478 1
S_regatom(pTHX_ RExC_state_t *pRExC_state, I32 *flagp)
a2481 1
    char *parse_start = 0;
d2486 1
a2486 1
    switch (*RExC_parse) {
d2488 6
a2493 6
	RExC_seen_zerolen++;
	nextchar(pRExC_state);
	if (RExC_flags & PMf_MULTILINE)
	    ret = reg_node(pRExC_state, MBOL);
	else if (RExC_flags & PMf_SINGLELINE)
	    ret = reg_node(pRExC_state, SBOL);
d2495 1
a2495 2
	    ret = reg_node(pRExC_state, BOL);
        Set_Node_Length(ret, 1); /* MJD */
d2498 7
a2504 7
	nextchar(pRExC_state);
	if (*RExC_parse)
	    RExC_seen_zerolen++;
	if (RExC_flags & PMf_MULTILINE)
	    ret = reg_node(pRExC_state, MEOL);
	else if (RExC_flags & PMf_SINGLELINE)
	    ret = reg_node(pRExC_state, SEOL);
d2506 1
a2506 2
	    ret = reg_node(pRExC_state, EOL);
        Set_Node_Length(ret, 1); /* MJD */
d2509 16
a2524 8
	nextchar(pRExC_state);
	if (RExC_flags & PMf_SINGLELINE)
	    ret = reg_node(pRExC_state, SANY);
	else
	    ret = reg_node(pRExC_state, REG_ANY);
	*flagp |= HASWIDTH|SIMPLE;
	RExC_naughty++;
        Set_Node_Length(ret, 1); /* MJD */
d2528 4
a2531 4
	char *oregcomp_parse = ++RExC_parse;
	ret = regclass(pRExC_state);
	if (*RExC_parse != ']') {
	    RExC_parse = oregcomp_parse;
d2534 1
a2534 1
	nextchar(pRExC_state);
a2535 1
        Set_Node_Length(ret, RExC_parse - oregcomp_parse + 1); /* MJD */
d2539 2
a2540 2
	nextchar(pRExC_state);
	ret = reg(pRExC_state, 1, &flags);
d2543 1
a2543 1
		    if (RExC_parse == RExC_end) {
d2564 2
a2565 2
	if (!regcurly(RExC_parse)) {
	    RExC_parse++;
d2572 1
a2572 1
	RExC_parse++;
d2576 1
a2576 1
	switch (*++RExC_parse) {
d2578 2
a2579 2
	    RExC_seen_zerolen++;
	    ret = reg_node(pRExC_state, SBOL);
d2581 1
a2581 2
	    nextchar(pRExC_state);
            Set_Node_Length(ret, 2); /* MJD */
d2584 2
a2585 2
	    ret = reg_node(pRExC_state, GPOS);
	    RExC_seen |= REG_SEEN_GPOS;
d2587 1
a2587 2
	    nextchar(pRExC_state);
            Set_Node_Length(ret, 2); /* MJD */
d2590 1
a2590 1
	    ret = reg_node(pRExC_state, SEOL);
d2592 1
a2592 2
	    RExC_seen_zerolen++;		/* Do not optimize RE away */
	    nextchar(pRExC_state);
d2595 1
a2595 1
	    ret = reg_node(pRExC_state, EOS);
d2597 2
a2598 3
	    RExC_seen_zerolen++;		/* Do not optimize RE away */
	    nextchar(pRExC_state);
            Set_Node_Length(ret, 2); /* MJD */
d2601 1
a2601 2
	    ret = reg_node(pRExC_state, CANY);
	    RExC_seen |= REG_SEEN_CANY;
d2603 1
a2603 2
	    nextchar(pRExC_state);
            Set_Node_Length(ret, 2); /* MJD */
d2606 1
a2606 1
	    ret = reg_node(pRExC_state, CLUMP);
d2608 3
a2610 2
	    nextchar(pRExC_state);
            Set_Node_Length(ret, 2); /* MJD */
d2613 4
a2616 1
	    ret = reg_node(pRExC_state, (U8)(LOC ? ALNUML     : ALNUM));
d2618 3
a2620 2
	    nextchar(pRExC_state);
            Set_Node_Length(ret, 2); /* MJD */
d2623 4
a2626 1
	    ret = reg_node(pRExC_state, (U8)(LOC ? NALNUML    : NALNUM));
d2628 3
a2630 2
	    nextchar(pRExC_state);
            Set_Node_Length(ret, 2); /* MJD */
d2633 6
a2638 3
	    RExC_seen_zerolen++;
	    RExC_seen |= REG_SEEN_LOOKBEHIND;
	    ret = reg_node(pRExC_state, (U8)(LOC ? BOUNDL     : BOUND));
d2640 3
a2642 2
	    nextchar(pRExC_state);
            Set_Node_Length(ret, 2); /* MJD */
d2645 6
a2650 3
	    RExC_seen_zerolen++;
	    RExC_seen |= REG_SEEN_LOOKBEHIND;
	    ret = reg_node(pRExC_state, (U8)(LOC ? NBOUNDL    : NBOUND));
d2652 3
a2654 2
	    nextchar(pRExC_state);
            Set_Node_Length(ret, 2); /* MJD */
d2657 4
a2660 1
	    ret = reg_node(pRExC_state, (U8)(LOC ? SPACEL     : SPACE));
d2662 3
a2664 2
	    nextchar(pRExC_state);
            Set_Node_Length(ret, 2); /* MJD */
d2667 4
a2670 1
	    ret = reg_node(pRExC_state, (U8)(LOC ? NSPACEL    : NSPACE));
d2672 3
a2674 2
	    nextchar(pRExC_state);
            Set_Node_Length(ret, 2); /* MJD */
d2677 1
a2677 1
	    ret = reg_node(pRExC_state, DIGIT);
d2679 3
a2681 2
	    nextchar(pRExC_state);
            Set_Node_Length(ret, 2); /* MJD */
d2684 1
a2684 1
	    ret = reg_node(pRExC_state, NDIGIT);
d2686 3
a2688 2
	    nextchar(pRExC_state);
            Set_Node_Length(ret, 2); /* MJD */
d2692 9
a2700 12
	    {	
		char* oldregxend = RExC_end;
                char* parse_start = RExC_parse;

		if (RExC_parse[1] == '{') {
		  /* a lovely hack--pretend we saw [\pX] instead */
		    RExC_end = strchr(RExC_parse, '}');
		    if (!RExC_end) {
		        U8 c = (U8)*RExC_parse;
			RExC_parse += 2;
			RExC_end = oldregxend;
			vFAIL2("Missing right brace on \\%c{}", c);
d2702 1
a2702 1
		    RExC_end++;
d2704 9
a2712 13
		else {
		    RExC_end = RExC_parse + 2;
		    if (RExC_end > oldregxend)
			RExC_end = oldregxend;
		}
		RExC_parse--;

		ret = regclass(pRExC_state);

		RExC_end = oldregxend;
		RExC_parse--;
                Set_Node_Cur_Length(ret); /* MJD */
		nextchar(pRExC_state);
d2729 1
a2729 1
		I32 num = atoi(RExC_parse);
d2731 1
a2731 1
		if (num > 9 && num >= RExC_npar)
d2734 2
a2735 3
                    char * parse_start = RExC_parse - 1; /* MJD */
		    while (isDIGIT(*RExC_parse))
			RExC_parse++;
d2737 1
a2737 1
		    if (!SIZE_ONLY && num > (I32)RExC_rx->nparens)
d2739 4
a2742 4
		    RExC_sawback = 1;
		    ret = reganode(pRExC_state,
				   (U8)(FOLD ? (LOC ? REFFL : REFF) : REF),
				   num);
d2744 2
a2745 6
                    
                    /* override incorrect value set in reganode MJD */
                    Set_Node_Offset(ret, parse_start+1); 
                    Set_Node_Cur_Length(ret); /* MJD */
		    RExC_parse--;
		    nextchar(pRExC_state);
d2750 1
a2750 1
	    if (RExC_parse >= RExC_end)
d2761 3
a2763 3
	if (RExC_flags & PMf_EXTENDED) {
	    while (RExC_parse < RExC_end && *RExC_parse != '\n') RExC_parse++;
	    if (RExC_parse < RExC_end)
a2773 2
	    STRLEN foldlen;
	    U8 tmpbuf[UTF8_MAXLEN_FOLD+1], *foldbuf;
d2775 1
a2775 3
            parse_start = RExC_parse - 1;

	    RExC_parse++;
d2778 3
a2780 3
	    ender = 0;
	    ret = reg_node(pRExC_state,
			   (U8)(FOLD ? (LOC ? EXACTFL : EXACTF) : EXACT));
d2782 2
a2783 2
	    for (len = 0, p = RExC_parse - 1;
	      len < 127 && p < RExC_end;
d2788 2
a2789 2
		if (RExC_flags & PMf_EXTENDED)
		    p = regwhite(p, RExC_end);
a2801 2
		    case 'C':
		    case 'X':
d2834 5
a2838 1
			  ender = ASCII_TO_NATIVE('\033');
d2842 5
a2846 1
			  ender = ASCII_TO_NATIVE('\007');
d2852 1
a2852 1
	
d2854 1
a2854 1
				RExC_parse = p + 1;
d2858 2
a2859 6
                                I32 flags = PERL_SCAN_ALLOW_UNDERSCORES
                                    | PERL_SCAN_DISALLOW_PREFIX;
                                numlen = e - p - 1;
				ender = grok_hex(p + 1, &numlen, &flags, NULL);
				if (ender > 0xff)
				    RExC_utf8 = 1;
d2869 2
a2870 3
                            I32 flags = PERL_SCAN_DISALLOW_PREFIX;
			    numlen = 2;
			    ender = grok_hex(p, &numlen, &flags, NULL);
d2882 3
a2884 4
			  (isDIGIT(p[1]) && atoi(p) >= RExC_npar) ) {
                            I32 flags = 0;
			    numlen = 3;
			    ender = grok_oct(p, &numlen, &flags, NULL);
d2893 1
a2893 1
			if (p >= RExC_end)
d2898 1
a2898 1
			    vWARN2(p + 1, "Unrecognized escape \\%c passed through", UCHARAT(p));
d2905 2
a2906 2
			ender = utf8n_to_uvchr((U8*)p, RExC_end - p,
					       &numlen, 0);
d2913 2
a2914 2
		if (RExC_flags & PMf_EXTENDED)
		    p = regwhite(p, RExC_end);
d2916 4
a2919 2
		    /* Prime the casefolded buffer. */
		    ender = toFOLD_uni(ender, tmpbuf, &foldlen);
d2924 6
a2929 30
		    else if (UTF) {
		         STRLEN unilen;

			 if (FOLD) {
			      /* Emit all the Unicode characters. */
			      for (foldbuf = tmpbuf;
				   foldlen;
				   foldlen -= numlen) {
				   ender = utf8_to_uvchr(foldbuf, &numlen);
				   if (numlen > 0) {
					reguni(pRExC_state, ender, s, &unilen);
					s       += unilen;
					len     += unilen;
					/* In EBCDIC the numlen
					 * and unilen can differ. */
					foldbuf += numlen;
					if (numlen >= foldlen)
					     break;
				   }
				   else
					break; /* "Can't happen." */
			      }
			 }
			 else {
			      reguni(pRExC_state, ender, s, &unilen);
			      if (unilen > 0) {
				   s   += unilen;
				   len += unilen;
			      }
			 }
d2933 1
a2933 1
			REGC((char)ender, s++);
d2937 6
a2942 31
		if (UTF) {
		     STRLEN unilen;

		     if (FOLD) {
		          /* Emit all the Unicode characters. */
			  for (foldbuf = tmpbuf;
			       foldlen;
			       foldlen -= numlen) {
			       ender = utf8_to_uvchr(foldbuf, &numlen);
			       if (numlen > 0) {
				    reguni(pRExC_state, ender, s, &unilen);
				    len     += unilen;
				    s       += unilen;
				    /* In EBCDIC the numlen
				     * and unilen can differ. */
				    foldbuf += numlen;
				    if (numlen >= foldlen)
					 break;
			       }
			       else
				    break;
			  }
		     }
		     else {
			  reguni(pRExC_state, ender, s, &unilen);
			  if (unilen > 0) {
			       s   += unilen;
			       len += unilen;
			  }
		     }
		     len--;
d2945 1
a2945 1
		    REGC((char)ender, s++);
d2948 2
a2949 3
	    RExC_parse = p - 1;
            Set_Node_Cur_Length(ret); /* MJD */
	    nextchar(pRExC_state);
d2963 1
a2963 1
		RExC_size += STR_SZ(len);
d2965 1
a2965 1
		RExC_emit += STR_SZ(len);
a2969 24
    /* If the encoding pragma is in effect recode the text of
     * any EXACT-kind nodes. */
    if (PL_encoding && PL_regkind[(U8)OP(ret)] == EXACT) {
	 STRLEN oldlen = STR_LEN(ret);
	 SV *sv        = sv_2mortal(newSVpvn(STRING(ret), oldlen));

	 if (RExC_utf8)
	      SvUTF8_on(sv);
	 if (sv_utf8_downgrade(sv, TRUE)) {
	      char *s       = sv_recode_to_utf8(sv, PL_encoding);
	      STRLEN newlen = SvCUR(sv);
	 
	      if (!SIZE_ONLY) {
		   DEBUG_r(PerlIO_printf(Perl_debug_log, "recode %*s to %*s\n",
					 (int)oldlen, STRING(ret),
					 (int)newlen, s));
		   Copy(s, STRING(ret), newlen, char);
		   STR_LEN(ret) += newlen - oldlen;
		   RExC_emit += STR_SZ(newlen) - STR_SZ(oldlen);
	      } else
		   RExC_size += STR_SZ(newlen) - STR_SZ(oldlen);
	 }
    }

d2994 1
a2994 6
   but trigger failures because they are currently unimplemented. */

#define POSIXCC_DONE(c)   ((c) == ':')
#define POSIXCC_NOTYET(c) ((c) == '=' || (c) == '.')
#define POSIXCC(c) (POSIXCC_DONE(c) || POSIXCC_NOTYET(c))

d2996 1
a2996 1
S_regpposixcc(pTHX_ RExC_state_t *pRExC_state, I32 value)
d3001 1
a3001 1
    if (value == '[' && RExC_parse + 1 < RExC_end &&
d3003 9
a3011 7
	POSIXCC(UCHARAT(RExC_parse))) {
	char  c = UCHARAT(RExC_parse);
	char* s = RExC_parse++;
	
	while (RExC_parse < RExC_end && UCHARAT(RExC_parse) != c)
	    RExC_parse++;
	if (RExC_parse == RExC_end)
d3013 1
a3013 1
	    RExC_parse = s;
d3015 1
a3015 1
	    char* t = RExC_parse++; /* skip over the c */
d3017 2
a3018 2
  	    if (UCHARAT(RExC_parse) == ']') {
  		RExC_parse++; /* skip over the ending ] */
d3104 1
a3104 1
		    /* adjust RExC_parse so the warning shows after
d3106 2
a3107 2
		    while (UCHARAT(RExC_parse) && UCHARAT(RExC_parse) != ']')
			RExC_parse++;
d3113 1
a3113 1
		RExC_parse = s;
d3122 1
a3122 1
S_checkposixcc(pTHX_ RExC_state_t *pRExC_state)
d3124 5
a3128 2
    if (!SIZE_ONLY && POSIXCC(UCHARAT(RExC_parse))) {
	char *s = RExC_parse;
d3134 1
a3134 4
	    if (ckWARN(WARN_REGEXP))
		vWARN3(s+2,
			"POSIX syntax [%c %c] belongs inside character classes",
			c, c);
d3137 3
a3139 2
	    if (POSIXCC_NOTYET(c)) {
		/* adjust RExC_parse so the error shows after
d3141 1
a3141 1
		while (UCHARAT(RExC_parse) && UCHARAT(RExC_parse++) != ']')
d3150 1
a3150 1
S_regclass(pTHX_ RExC_state_t *pRExC_state)
d3152 3
a3154 4
    register UV value;
    register UV nextvalue;
    register IV prevvalue = OOB_UNICODE;
    register IV range = 0;
d3157 2
a3158 2
    IV namedclass;
    char *rangebegin = 0;
a3159 20
    SV *listsv = Nullsv;
    register char *e;
    UV n;
    bool optimize_invert   = TRUE;
    AV* unicode_alternate  = 0;
#ifdef EBCDIC
    UV literal_endpoint = 0;
#endif

    ret = reganode(pRExC_state, ANYOF, 0);

    if (!SIZE_ONLY)
	ANYOF_FLAGS(ret) = 0;

    if (UCHARAT(RExC_parse) == '^') {	/* Complement of range. */
	RExC_naughty++;
	RExC_parse++;
	if (!SIZE_ONLY)
	    ANYOF_FLAGS(ret) |= ANYOF_INVERT;
    }
d3161 1
d3163 1
a3163 1
	RExC_size += ANYOF_SKIP;
d3165 3
a3167 1
 	RExC_emit += ANYOF_SKIP;
a3171 2
	ANYOF_BITMAP_ZERO(ret);
	listsv = newSVpvn("# comment\n", 10);
d3173 6
d3180 2
a3181 14
    nextvalue = RExC_parse < RExC_end ? UCHARAT(RExC_parse) : 0;

    if (!SIZE_ONLY && POSIXCC(nextvalue))
	checkposixcc(pRExC_state);

    /* allow 1st char to be ] (allowing it to be - is dealt with later) */
    if (UCHARAT(RExC_parse) == ']')
	goto charclassloop;

    while (RExC_parse < RExC_end && UCHARAT(RExC_parse) != ']') {

    charclassloop:

	namedclass = OOB_NAMEDCLASS; /* initialize as illegal */
d3183 5
d3189 4
a3192 12
	    rangebegin = RExC_parse;
	if (UTF) {
	    value = utf8n_to_uvchr((U8*)RExC_parse,
				   RExC_end - RExC_parse,
				   &numlen, 0);
	    RExC_parse += numlen;
	}
	else
	    value = UCHARAT(RExC_parse++);
	nextvalue = RExC_parse < RExC_end ? UCHARAT(RExC_parse) : 0;
	if (value == '[' && POSIXCC(nextvalue))
	    namedclass = regpposixcc(pRExC_state, value);
d3194 1
a3194 8
	    if (UTF) {
		value = utf8n_to_uvchr((U8*)RExC_parse,
				   RExC_end - RExC_parse,
				   &numlen, 0);
		RExC_parse += numlen;
	    }
	    else
		value = UCHARAT(RExC_parse++);
d3196 2
a3197 5
	     * values, therefore value cannot be an UV.  Yes, this will
	     * be a problem later if we want switch on Unicode.
	     * A similar issue a little bit later when switching on
	     * namedclass. --jhi */
	    switch ((I32)value) {
a3203 41
	    case 'p':
	    case 'P':
		if (RExC_parse >= RExC_end)
		    vFAIL2("Empty \\%c{}", (U8)value);
		if (*RExC_parse == '{') {
		    U8 c = (U8)value;
		    e = strchr(RExC_parse++, '}');
                    if (!e)
                        vFAIL2("Missing right brace on \\%c{}", c);
		    while (isSPACE(UCHARAT(RExC_parse)))
		        RExC_parse++;
                    if (e == RExC_parse)
                        vFAIL2("Empty \\%c{}", c);
		    n = e - RExC_parse;
		    while (isSPACE(UCHARAT(RExC_parse + n - 1)))
		        n--;
		}
		else {
		    e = RExC_parse;
		    n = 1;
		}
		if (!SIZE_ONLY) {
		    if (UCHARAT(RExC_parse) == '^') {
			 RExC_parse++;
			 n--;
			 value = value == 'p' ? 'P' : 'p'; /* toggle */
			 while (isSPACE(UCHARAT(RExC_parse))) {
			      RExC_parse++;
			      n--;
			 }
		    }
		    if (value == 'p')
			 Perl_sv_catpvf(aTHX_ listsv,
					"+utf8::%.*s\n", (int)n, RExC_parse);
		    else
			 Perl_sv_catpvf(aTHX_ listsv,
					"!utf8::%.*s\n", (int)n, RExC_parse);
		}
		RExC_parse = e + 1;
		ANYOF_FLAGS(ret) |= ANYOF_UNICODE;
		continue;
d3209 7
a3215 2
	    case 'e':	value = ASCII_TO_NATIVE('\033');break;
	    case 'a':	value = ASCII_TO_NATIVE('\007');break;
d3217 3
a3219 17
		if (*RExC_parse == '{') {
                    I32 flags = PERL_SCAN_ALLOW_UNDERSCORES
                        | PERL_SCAN_DISALLOW_PREFIX;
		    e = strchr(RExC_parse++, '}');
                    if (!e)
                        vFAIL("Missing right brace on \\x{}");

		    numlen = e - RExC_parse;
		    value = grok_hex(RExC_parse, &numlen, &flags, NULL);
		    RExC_parse = e + 1;
		}
		else {
                    I32 flags = PERL_SCAN_DISALLOW_PREFIX;
		    numlen = 2;
		    value = grok_hex(RExC_parse, &numlen, &flags, NULL);
		    RExC_parse += numlen;
		}
d3222 1
a3222 1
		value = UCHARAT(RExC_parse++);
d3227 3
a3229 5
            {
                I32 flags = 0;
		numlen = 3;
		value = grok_oct(--RExC_parse, &numlen, &flags, NULL);
		RExC_parse += numlen;
a3230 1
            }
d3233 2
a3234 3
		    vWARN2(RExC_parse,
			   "Unrecognized escape \\%c in character class passed through",
			   (int)value);
d3237 3
a3239 9
	} /* end of \blah */
#ifdef EBCDIC
	else
	    literal_endpoint++;
#endif

	if (namedclass > OOB_NAMEDCLASS) { /* this is a named class \blah */

	    if (!SIZE_ONLY && !need_class)
a3240 1

d3242 1
a3242 3

	    /* a bad range like a-\d, a-[:digit:] ? */
	    if (range) {
d3245 1
a3245 1
			vWARN4(RExC_parse,
d3247 2
a3248 2
			       RExC_parse - rangebegin,
			       RExC_parse - rangebegin,
d3250 2
a3251 9
		    if (prevvalue < 256) {
			ANYOF_BITMAP_SET(ret, prevvalue);
			ANYOF_BITMAP_SET(ret, '-');
		    }
		    else {
			ANYOF_FLAGS(ret) |= ANYOF_UNICODE;
			Perl_sv_catpvf(aTHX_ listsv,
				       "%04"UVxf"\n%04"UVxf"\n", (UV)prevvalue, (UV) '-');
		    }
d3253 1
a3253 2

		range = 0; /* this was not a true range */
a3254 1

d3256 1
a3256 7
	        if (namedclass > OOB_NAMEDCLASS)
		    optimize_invert = FALSE;
		/* Possible truncation here but in some 64-bit environments
		 * the compiler gets heartburn about switch on 64-bit values.
		 * A similar issue a little earlier when switching on value.
		 * --jhi */
		switch ((I32)namedclass) {
a3264 1
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsWord\n");	
a3273 1
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsWord\n");
d3275 10
a3284 1
		case ANYOF_ALNUMC:
d3286 1
a3286 1
			ANYOF_CLASS_SET(ret, ANYOF_ALNUMC);
d3289 1
a3289 1
			    if (isALNUMC(value))
d3292 18
a3309 1
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsAlnum\n");
d3319 9
a3327 1
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsAlnum\n");
a3336 1
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsAlpha\n");
a3345 1
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsAlpha\n");
d3351 1
a3351 1
#ifndef EBCDIC
d3355 1
a3355 1
			for (value = 0; value < 256; value++) {
d3357 1
a3357 2
			        ANYOF_BITMAP_SET(ret, value);
			}
a3359 1
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsASCII\n");
d3365 1
a3365 1
#ifndef EBCDIC
d3369 1
a3369 1
			for (value = 0; value < 256; value++) {
d3371 1
a3371 2
			        ANYOF_BITMAP_SET(ret, value);
			}
a3373 1
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsASCII\n");
a3382 1
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsBlank\n");
a3391 1
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsBlank\n");
d3401 1
a3401 1
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsCntrl\n");
a3410 23
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsCntrl\n");
		    break;
		case ANYOF_DIGIT:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_DIGIT);
		    else {
			/* consecutive digits assumed */
			for (value = '0'; value <= '9'; value++)
			    ANYOF_BITMAP_SET(ret, value);
		    }
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsDigit\n");
		    break;
		case ANYOF_NDIGIT:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_NDIGIT);
		    else {
			/* consecutive digits assumed */
			for (value = 0; value < '0'; value++)
			    ANYOF_BITMAP_SET(ret, value);
			for (value = '9' + 1; value < 256; value++)
			    ANYOF_BITMAP_SET(ret, value);
		    }
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsDigit\n");
a3419 1
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsGraph\n");
a3428 1
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsGraph\n");
a3437 1
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsLower\n");
a3446 1
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsLower\n");
a3455 1
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsPrint\n");
a3464 1
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsPrint\n");
a3473 1
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsSpace\n");
a3482 1
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsSpace\n");
a3491 1
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsPunct\n");
a3500 21
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsPunct\n");
		    break;
		case ANYOF_SPACE:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_SPACE);
		    else {
			for (value = 0; value < 256; value++)
			    if (isSPACE(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsSpacePerl\n");
		    break;
		case ANYOF_NSPACE:
		    if (LOC)
			ANYOF_CLASS_SET(ret, ANYOF_NSPACE);
		    else {
			for (value = 0; value < 256; value++)
			    if (!isSPACE(value))
				ANYOF_BITMAP_SET(ret, value);
		    }
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsSpacePerl\n");
a3509 1
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsUpper\n");
a3518 1
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsUpper\n");
a3527 1
		    Perl_sv_catpvf(aTHX_ listsv, "+utf8::IsXDigit\n");
a3536 1
		    Perl_sv_catpvf(aTHX_ listsv, "!utf8::IsXDigit\n");
d3546 1
a3546 2
	} /* end of namedclass \blah */

d3548 1
a3548 1
	    if (prevvalue > (IV)value) /* b-a */ {
d3550 2
a3551 2
			      RExC_parse - rangebegin,
			      RExC_parse - rangebegin,
a3552 1
		range = 0; /* not a valid range */
d3554 1
d3557 5
a3561 7
	    prevvalue = value; /* save the beginning of the range */
	    if (*RExC_parse == '-' && RExC_parse+1 < RExC_end &&
		RExC_parse[1] != ']') {
		RExC_parse++;

		/* a bad range like \w-, [:word:]- ? */
		if (namedclass > OOB_NAMEDCLASS) {
d3563 1
a3563 1
			vWARN4(RExC_parse,
d3565 2
a3566 2
			       RExC_parse - rangebegin,
			       RExC_parse - rangebegin,
d3571 2
a3572 2
		    range = 1;	/* yeah, it's a range! */
		continue;	/* but do it the next time */
a3574 1

d3577 13
a3589 88
	    IV i;

	    if (prevvalue < 256) {
	        IV ceilvalue = value < 256 ? value : 255;

#ifdef EBCDIC
		/* In EBCDIC [\x89-\x91] should include
		 * the \x8e but [i-j] should not. */
		if (literal_endpoint == 2 &&
		    ((isLOWER(prevvalue) && isLOWER(ceilvalue)) ||
		     (isUPPER(prevvalue) && isUPPER(ceilvalue))))
		{
		    if (isLOWER(prevvalue)) {
			for (i = prevvalue; i <= ceilvalue; i++)
			    if (isLOWER(i))
				ANYOF_BITMAP_SET(ret, i);
		    } else {
			for (i = prevvalue; i <= ceilvalue; i++)
			    if (isUPPER(i))
				ANYOF_BITMAP_SET(ret, i);
		    }
		}
		else
#endif
		      for (i = prevvalue; i <= ceilvalue; i++)
			  ANYOF_BITMAP_SET(ret, i);
	  }
	  if (value > 255 || UTF) {
	        UV prevnatvalue  = NATIVE_TO_UNI(prevvalue);
		UV natvalue      = NATIVE_TO_UNI(value);

		ANYOF_FLAGS(ret) |= ANYOF_UNICODE;
		if (prevnatvalue < natvalue) { /* what about > ? */
		    Perl_sv_catpvf(aTHX_ listsv, "%04"UVxf"\t%04"UVxf"\n",
				   prevnatvalue, natvalue);
		}
		else if (prevnatvalue == natvalue) {
		    Perl_sv_catpvf(aTHX_ listsv, "%04"UVxf"\n", natvalue);
		    if (FOLD) {
			 U8 foldbuf[UTF8_MAXLEN_FOLD+1];
			 STRLEN foldlen;
			 UV f = to_uni_fold(natvalue, foldbuf, &foldlen);

			 /* If folding and foldable and a single
			  * character, insert also the folded version
			  * to the charclass. */
			 if (f != value) {
			      if (foldlen == (STRLEN)UNISKIP(f))
				  Perl_sv_catpvf(aTHX_ listsv,
						 "%04"UVxf"\n", f);
			      else {
				  /* Any multicharacter foldings
				   * require the following transform:
				   * [ABCDEF] -> (?:[ABCabcDEFd]|pq|rst)
				   * where E folds into "pq" and F folds
				   * into "rst", all other characters
				   * fold to single characters.  We save
				   * away these multicharacter foldings,
				   * to be later saved as part of the
				   * additional "s" data. */
				  SV *sv;

				  if (!unicode_alternate)
				      unicode_alternate = newAV();
				  sv = newSVpvn((char*)foldbuf, foldlen);
				  SvUTF8_on(sv);
				  av_push(unicode_alternate, sv);
			      }
			 }

			 /* If folding and the value is one of the Greek
			  * sigmas insert a few more sigmas to make the
			  * folding rules of the sigmas to work right.
			  * Note that not all the possible combinations
			  * are handled here: some of them are handled
			  * by the standard folding rules, and some of
			  * them (literal or EXACTF cases) are handled
			  * during runtime in regexec.c:S_find_byclass(). */
			 if (value == UNICODE_GREEK_SMALL_LETTER_FINAL_SIGMA) {
			      Perl_sv_catpvf(aTHX_ listsv, "%04"UVxf"\n",
					     (UV)UNICODE_GREEK_CAPITAL_LETTER_SIGMA);
			      Perl_sv_catpvf(aTHX_ listsv, "%04"UVxf"\n",
					     (UV)UNICODE_GREEK_SMALL_LETTER_SIGMA);
			 }
			 else if (value == UNICODE_GREEK_CAPITAL_LETTER_SIGMA)
			      Perl_sv_catpvf(aTHX_ listsv, "%04"UVxf"\n",
					     (UV)UNICODE_GREEK_SMALL_LETTER_SIGMA);
		    }
d3592 1
a3592 2
#ifdef EBCDIC
	    literal_endpoint = 0;
d3594 2
d3597 1
a3597 2

	range = 0; /* this range (if it was one) is done now */
a3598 1

a3599 1
	ANYOF_FLAGS(ret) |= ANYOF_LARGE;
d3601 1
a3601 1
	    RExC_size += ANYOF_CLASS_ADD_SKIP;
d3603 1
a3603 1
	    RExC_emit += ANYOF_CLASS_ADD_SKIP;
a3604 1

d3607 1
a3607 3
	 /* If the only flag is folding (plus possibly inversion). */
	((ANYOF_FLAGS(ret) & (ANYOF_FLAGS_ALL ^ ANYOF_INVERT)) == ANYOF_FOLD)
       ) {
d3610 2
a3611 4
		UV fold = PL_fold[value];

		if (fold != value)
		    ANYOF_BITMAP_SET(ret, fold);
a3615 1

d3617 1
a3617 3
    if (!SIZE_ONLY && optimize_invert &&
	/* If the only flag is inversion. */
	(ANYOF_FLAGS(ret) & ANYOF_FLAGS_ALL) ==	ANYOF_INVERT) {
d3620 252
a3871 1
	ANYOF_FLAGS(ret) = ANYOF_UNICODE_ALL;
d3874 2
d3877 2
d3880 2
a3881 11
	SV *rv;

	/* The 0th element stores the character class description
	 * in its textual form: used later (regexec.c:Perl_regclass_swatch())
	 * to initialize the appropriate swash (which gets stored in
	 * the 1st element), and also useful for dumping the regnode.
	 * The 2nd element stores the multicharacter foldings,
	 * used later (regexec.c:s_reginclasslen()). */
	av_store(av, 0, listsv);
	av_store(av, 1, NULL);
	av_store(av, 2, (SV*)unicode_alternate);
d3883 7
a3889 3
	n = add_data(pRExC_state, 1, "s");
	RExC_rx->data->data[n] = (void*)rv;
	ARG_SET(ret, n);
d3896 1
a3896 1
S_nextchar(pTHX_ RExC_state_t *pRExC_state)
d3898 1
a3898 1
    char* retval = RExC_parse++;
d3901 5
a3905 5
	if (*RExC_parse == '(' && RExC_parse[1] == '?' &&
		RExC_parse[2] == '#') {
	    while (*RExC_parse && *RExC_parse != ')')
		RExC_parse++;
	    RExC_parse++;
d3908 3
a3910 3
	if (RExC_flags & PMf_EXTENDED) {
	    if (isSPACE(*RExC_parse)) {
		RExC_parse++;
d3913 4
a3916 4
	    else if (*RExC_parse == '#') {
		while (*RExC_parse && *RExC_parse != '\n')
		    RExC_parse++;
		RExC_parse++;
d3928 1
a3928 1
S_reg_node(pTHX_ RExC_state_t *pRExC_state, U8 op)
d3933 1
a3933 1
    ret = RExC_emit;
d3935 2
a3936 2
	SIZE_ALIGN(RExC_size);
	RExC_size += 1;
d3943 1
a3943 13
    if (RExC_offsets) {         /* MJD */
      MJD_OFFSET_DEBUG((stderr, "%s:%u: (op %s) %s %u <- %u (len %u) (max %u).\n", 
              "reg_node", __LINE__, 
              reg_name[op],
              RExC_emit - RExC_emit_start > RExC_offsets[0] 
              ? "Overwriting end of array!\n" : "OK",
              RExC_emit - RExC_emit_start,
              RExC_parse - RExC_start,
              RExC_offsets[0])); 
      Set_Node_Offset(RExC_emit, RExC_parse + (op == END));
    }
            
    RExC_emit = ptr;
d3952 1
a3952 1
S_reganode(pTHX_ RExC_state_t *pRExC_state, U8 op, U32 arg)
d3957 1
a3957 1
    ret = RExC_emit;
d3959 2
a3960 2
	SIZE_ALIGN(RExC_size);
	RExC_size += 2;
d3967 1
a3967 12
    if (RExC_offsets) {         /* MJD */
      MJD_OFFSET_DEBUG((stderr, "%s: %s %u <- %u (max %u).\n", 
              "reganode",
              RExC_emit - RExC_emit_start > RExC_offsets[0] ? 
              "Overwriting end of array!\n" : "OK",
              RExC_emit - RExC_emit_start,
              RExC_parse - RExC_start,
              RExC_offsets[0])); 
      Set_Cur_Node_Offset;
    }
            
    RExC_emit = ptr;
d3976 1
a3976 1
S_reguni(pTHX_ RExC_state_t *pRExC_state, UV uv, char* s, STRLEN* lenp)
d3978 1
a3978 1
    *lenp = SIZE_ONLY ? UNISKIP(uv) : (uvchr_to_utf8((U8*)s, uv) - (U8*)s);
d3987 1
a3987 1
S_reginsert(pTHX_ RExC_state_t *pRExC_state, U8 op, regnode *opnd)
d3993 1
a3993 1

d3997 1
a3997 1
	RExC_size += NODE_STEP_REGNODE + offset;
d4001 4
a4004 4
    src = RExC_emit;
    RExC_emit += NODE_STEP_REGNODE + offset;
    dst = RExC_emit;
    while (src > opnd) {
a4005 13
        if (RExC_offsets) {     /* MJD 20010112 */
          MJD_OFFSET_DEBUG((stderr, "%s: %s copy %u -> %u (max %u).\n", 
                  "reg_insert",
                  dst - RExC_emit_start > RExC_offsets[0] 
                  ? "Overwriting end of array!\n" : "OK",
                  src - RExC_emit_start,
                  dst - RExC_emit_start,
                  RExC_offsets[0])); 
          Set_Node_Offset_To_R(dst-RExC_emit_start, Node_Offset(src));
          Set_Node_Length_To_R(dst-RExC_emit_start, Node_Length(src));
        }
    }
    
a4007 10
    if (RExC_offsets) {         /* MJD */
      MJD_OFFSET_DEBUG((stderr, "%s: %s %u <- %u (max %u).\n", 
              "reginsert",
              place - RExC_emit_start > RExC_offsets[0] 
              ? "Overwriting end of array!\n" : "OK",
              place - RExC_emit_start,
              RExC_parse - RExC_start,
              RExC_offsets[0])); 
      Set_Node_Offset(place, RExC_parse);
    }
d4017 1
a4017 1
S_regtail(pTHX_ RExC_state_t *pRExC_state, regnode *p, regnode *val)
d4046 1
a4046 1
S_regoptail(pTHX_ RExC_state_t *pRExC_state, regnode *p, regnode *val)
d4052 1
a4052 1
	regtail(pRExC_state, NEXTOPER(p), val);
d4055 1
a4055 1
	regtail(pRExC_state, NEXTOPER(NEXTOPER(p)), val);
a4082 2
#ifdef DEBUGGING

d4086 1
d4106 1
a4106 1
	else
d4111 2
a4112 2
	    register regnode *nnode = (OP(next) == LONGJMP
				       ? regnext(next)
a4132 3
	    /* arglen 1 + class block */
	    node += 1 + ((ANYOF_FLAGS(node) & ANYOF_LARGE)
		    ? ANYOF_CLASS_SKIP : ANYOF_SKIP);
d4134 1
d4150 1
a4153 2
#endif	/* DEBUGGING */

d4168 1
a4168 1
		      "anchored `%s%.*s%s'%s at %"IVdf" ",
d4171 1
a4171 1
		      SvPVX(r->anchored_substr),
a4174 9
    else if (r->anchored_utf8)
	PerlIO_printf(Perl_debug_log,
		      "anchored utf8 `%s%.*s%s'%s at %"IVdf" ",
		      PL_colors[0],
		      (int)(SvCUR(r->anchored_utf8) - (SvTAIL(r->anchored_utf8)!=0)),
		      SvPVX(r->anchored_utf8),
		      PL_colors[1],
		      SvTAIL(r->anchored_utf8) ? "$" : "",
		      (IV)r->anchored_offset);
d4177 1
a4177 1
		      "floating `%s%.*s%s'%s at %"IVdf"..%"UVuf" ",
d4179 1
a4179 1
		      (int)(SvCUR(r->float_substr) - (SvTAIL(r->float_substr)!=0)),
d4184 3
a4186 13
    else if (r->float_utf8)
	PerlIO_printf(Perl_debug_log,
		      "floating utf8 `%s%.*s%s'%s at %"IVdf"..%"UVuf" ",
		      PL_colors[0],
		      (int)(SvCUR(r->float_utf8) - (SvTAIL(r->float_utf8)!=0)),
		      SvPVX(r->float_utf8),
		      PL_colors[1],
		      SvTAIL(r->float_utf8) ? "$" : "",
		      (IV)r->float_min_offset, (UV)r->float_max_offset);
    if (r->check_substr || r->check_utf8)
	PerlIO_printf(Perl_debug_log,
		      r->check_substr == r->float_substr
		      && r->check_utf8 == r->float_utf8
d4192 1
a4192 1
    if (r->check_substr || r->check_utf8)
a4220 10
    if (r->offsets) {
      U32 i;
      U32 len = r->offsets[0];
      PerlIO_printf(Perl_debug_log, "Offsets: [%"UVuf"]\n\t", (UV)r->offsets[0]);
      for (i = 1; i <= len; i++)
        PerlIO_printf(Perl_debug_log, "%"UVuf"[%"UVuf"] ", 
                      (UV)r->offsets[i*2-1], 
                      (UV)r->offsets[i*2]);
      PerlIO_printf(Perl_debug_log, "\n");
    }
a4223 2
#ifdef DEBUGGING

d4227 1
a4227 1
    if (isCNTRL(c) || c == 255 || !isPRINT(c))
a4234 2
#endif	/* DEBUGGING */

d4246 1
a4246 3
	/* It would be nice to FAIL() here, but this may be called from
	   regexec.c, and it would be hard to supply pRExC_state. */
	Perl_croak(aTHX_ "Corrupted regexp opcode");
d4251 3
a4253 18
    if (k == EXACT) {
        SV *dsv = sv_2mortal(newSVpvn("", 0));
	/* Using is_utf8_string() is a crude hack but it may
	 * be the best for now since we have no flag "this EXACTish
	 * node was UTF-8" --jhi */
	bool do_utf8 = is_utf8_string((U8*)STRING(o), STR_LEN(o));
	char *s    = do_utf8 ?
	  pv_uni_display(dsv, (U8*)STRING(o), STR_LEN(o), 60,
			 UNI_DISPLAY_REGEX) :
	  STRING(o);
	int len = do_utf8 ?
	  strlen(s) :
	  STR_LEN(o);
	Perl_sv_catpvf(aTHX_ sv, " <%s%.*s%s>",
		       PL_colors[0],
		       len, s,
		       PL_colors[1]);
    }
d4267 2
a4268 1
	U8 flags = ANYOF_FLAGS(o);
d4310 10
a4319 7
	for (i = 0; i <= 256; i++) {
	    if (i < 256 && ANYOF_BITMAP_TEST(o,i)) {
		if (rangestart == -1)
		    rangestart = i;
	    } else if (rangestart != -1) {
		if (i <= rangestart + 3)
		    for (; rangestart < i; rangestart++)
d4321 4
a4324 4
		else {
		    put_byte(sv, rangestart);
		    sv_catpv(sv, "-");
		    put_byte(sv, i - 1);
a4325 1
		rangestart = -1;
d4327 4
d4332 19
a4350 42

	if (o->flags & ANYOF_CLASS)
	    for (i = 0; i < sizeof(anyofs)/sizeof(char*); i++)
		if (ANYOF_CLASS_TEST(o,i))
		    sv_catpv(sv, anyofs[i]);

	if (flags & ANYOF_UNICODE)
	    sv_catpv(sv, "{unicode}");
	else if (flags & ANYOF_UNICODE_ALL)
	    sv_catpv(sv, "{unicode_all}");

	{
	    SV *lv;
	    SV *sw = regclass_swash(o, FALSE, &lv, 0);
	
	    if (lv) {
		if (sw) {
		    U8 s[UTF8_MAXLEN+1];
		
		    for (i = 0; i <= 256; i++) { /* just the first 256 */
			U8 *e = uvchr_to_utf8(s, i);
			
			if (i < 256 && swash_fetch(sw, s, TRUE)) {
			    if (rangestart == -1)
				rangestart = i;
			} else if (rangestart != -1) {
			    U8 *p;
			
			    if (i <= rangestart + 3)
				for (; rangestart < i; rangestart++) {
				    for(e = uvchr_to_utf8(s, rangestart), p = s; p < e; p++)
					put_byte(sv, *p);
				}
			    else {
				for (e = uvchr_to_utf8(s, rangestart), p = s; p < e; p++)
				    put_byte(sv, *p);
				sv_catpv(sv, "-");
				    for (e = uvchr_to_utf8(s, i - 1), p = s; p < e; p++)
					put_byte(sv, *p);
				}
				rangestart = -1;
			    }
d4352 8
a4359 2
			
		    sv_catpv(sv, "..."); /* et cetera */
d4361 8
d4370 4
a4373 18
		{
		    char *s = savepv(SvPVX(lv));
		    char *origs = s;
		
		    while(*s && *s != '\n') s++;
		
		    if (*s == '\n') {
			char *t = ++s;
			
			while (*s) {
			    if (*s == '\n')
				*s = ' ';
			    s++;
			}
			if (s[-1] == ' ')
			    s[-1] = 0;
			
			sv_catpv(sv, t);
d4375 4
a4378 2
		
		    Safefree(origs);
a4381 1

d4394 1
a4394 2
	    char *s = SvPV(prog->check_substr
		      ? prog->check_substr : prog->check_utf8, n_a);
d4398 2
a4399 4
		      "%sUsing REx %ssubstr:%s `%s%.60s%s%s'\n",
		      PL_colors[4],
		      prog->check_substr ? "" : "utf8 ",
		      PL_colors[5],PL_colors[0],
d4405 1
a4405 1
    return prog->check_substr ? prog->check_substr : prog->check_utf8;
d4411 1
a4411 3
#ifdef DEBUGGING
    SV *dsv = PERL_DEBUG_PAD_ZERO(0);
#endif
d4415 6
a4420 17
    DEBUG_r({
	 int len;
         char *s;

	 s = (r->reganch & ROPT_UTF8) ? pv_uni_display(dsv, (U8*)r->precomp,
		r->prelen, 60, UNI_DISPLAY_REGEX)
            : pv_display(dsv, r->precomp, r->prelen, 0, 60);
	 len = SvCUR(dsv);
	 if (!PL_colorset)
	      reginitcolors();
	 PerlIO_printf(Perl_debug_log,
		       "%sFreeing REx:%s `%s%*.*s%s%s'\n",
		       PL_colors[4],PL_colors[5],PL_colors[0],
		       len, len, s,
		       PL_colors[1],
		       len > 60 ? "..." : "");
    });
a4423 2
    if (r->offsets)             /* 20010421 MJD */
	Safefree(r->offsets);
a4428 2
	if (r->anchored_utf8)
	    SvREFCNT_dec(r->anchored_utf8);
a4430 2
	if (r->float_utf8)
	    SvREFCNT_dec(r->float_utf8);
a4439 1
          /* If you add a ->what type here, update the comment in regcomp.h */
d4462 1
a4462 5

		if (!OpREFCNT_dec((OP_4tree*)r->data->data[n])) {
                    op_free((OP_4tree*)r->data->data[n]);
		}

d4469 1
a4469 1
	        break;
d4471 1
a4471 1
		Perl_croak(aTHX_ "panic: regfree data code '%c'", r->data->what[n]);
d4541 1
a4541 16
{
#if 0
    SAVEPPTR(RExC_precomp);		/* uncompiled string. */
    SAVEI32(RExC_npar);		/* () count. */
    SAVEI32(RExC_size);		/* Code size. */
    SAVEI32(RExC_flags);		/* are we folding, multilining? */
    SAVEVPTR(RExC_rx);		/* from regcomp.c */
    SAVEI32(RExC_seen);		/* from regcomp.c */
    SAVEI32(RExC_sawback);		/* Did we see \1, ...? */
    SAVEI32(RExC_naughty);		/* How bad is this pattern? */
    SAVEVPTR(RExC_emit);		/* Code-emit pointer; &regdummy = don't */
    SAVEPPTR(RExC_end);		/* End of input for compile */
    SAVEPPTR(RExC_parse);		/* Input-scan pointer. */
#endif

    SAVEI32(PL_reg_flags);		/* from regexec.c */
d4543 4
d4554 2
a4555 1
    SAVEGENERICPV(PL_reg_start_tmp);		/* from regexec.c */
d4560 1
d4567 7
a4577 1
    SAVEI8(PL_reg_match_utf8);		/* from regexec.c */
a4582 1
    SAVEI32(PL_regsize);		/* from regexec.c */
d4584 1
a4584 1
    SAVEPPTR(PL_reg_starttry);		/* from regexec.c */
d4588 6
d4595 1
a4595 1
clear_re(pTHX_ void *r)
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d72 1
a72 2
 ****    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 ****    2000, 2001, 2002, 2003, by Larry Wall and others
d98 1
a98 1
#  if defined(BUGGY_MSC6)
d100 1
a100 1
#    pragma optimize("a",off)
d102 2
a103 2
#    pragma optimize("w",on )
#  endif /* BUGGY_MSC6 */
d259 16
a274 14
#define	FAIL(msg) STMT_START {						\
    char *ellipses = "";						\
    IV len = RExC_end - RExC_precomp;					\
									\
    if (!SIZE_ONLY)							\
	SAVEDESTRUCTOR_X(clear_re,(void*)RExC_rx);			\
    if (len > RegexLengthToShowInErrorMessages) {			\
	/* chop 10 shorter than the max, to ensure meaning of "..." */	\
	len = RegexLengthToShowInErrorMessages - 10;			\
	ellipses = "...";						\
    }									\
    Perl_croak(aTHX_ "%s in regex m/%.*s%s/",				\
	    msg, (int)len, RExC_precomp, ellipses);			\
} STMT_END
d281 16
a296 14
#define	FAIL2(pat,msg) STMT_START {					\
    char *ellipses = "";						\
    IV len = RExC_end - RExC_precomp;					\
									\
    if (!SIZE_ONLY)							\
	SAVEDESTRUCTOR_X(clear_re,(void*)RExC_rx);			\
    if (len > RegexLengthToShowInErrorMessages) {			\
	/* chop 10 shorter than the max, to ensure meaning of "..." */	\
	len = RegexLengthToShowInErrorMessages - 10;			\
	ellipses = "...";						\
    }									\
    S_re_croak2(aTHX_ pat, " in regex m/%.*s%s/",			\
	    msg, (int)len, RExC_precomp, ellipses);			\
} STMT_END
d302 7
a308 5
#define	Simple_vFAIL(m) STMT_START {					\
    IV offset = RExC_parse - RExC_precomp;				\
    Perl_croak(aTHX_ "%s" REPORT_LOCATION,				\
	    m, (int)offset, RExC_precomp, RExC_precomp + offset);	\
} STMT_END
d313 6
a318 5
#define	vFAIL(m) STMT_START {				\
    if (!SIZE_ONLY)					\
	SAVEDESTRUCTOR_X(clear_re,(void*)RExC_rx);	\
    Simple_vFAIL(m);					\
} STMT_END
d323 7
a329 5
#define	Simple_vFAIL2(m,a1) STMT_START {			\
    IV offset = RExC_parse - RExC_precomp;			\
    S_re_croak2(aTHX_ m, REPORT_LOCATION, a1,			\
	    (int)offset, RExC_precomp, RExC_precomp + offset);	\
} STMT_END
d334 6
a339 5
#define	vFAIL2(m,a1) STMT_START {			\
    if (!SIZE_ONLY)					\
	SAVEDESTRUCTOR_X(clear_re,(void*)RExC_rx);	\
    Simple_vFAIL2(m, a1);				\
} STMT_END
d345 7
a351 5
#define	Simple_vFAIL3(m, a1, a2) STMT_START {			\
    IV offset = RExC_parse - RExC_precomp;			\
    S_re_croak2(aTHX_ m, REPORT_LOCATION, a1, a2,		\
	    (int)offset, RExC_precomp, RExC_precomp + offset);	\
} STMT_END
d356 6
a361 5
#define	vFAIL3(m,a1,a2) STMT_START {			\
    if (!SIZE_ONLY)					\
	SAVEDESTRUCTOR_X(clear_re,(void*)RExC_rx);	\
    Simple_vFAIL3(m, a1, a2);				\
} STMT_END
d366 7
a372 5
#define	Simple_vFAIL4(m, a1, a2, a3) STMT_START {		\
    IV offset = RExC_parse - RExC_precomp;			\
    S_re_croak2(aTHX_ m, REPORT_LOCATION, a1, a2, a3,		\
	    (int)offset, RExC_precomp, RExC_precomp + offset);	\
} STMT_END
d377 55
a431 44
#define	Simple_vFAIL5(m, a1, a2, a3, a4) STMT_START {		\
    IV offset = RExC_parse - RExC_precomp;			\
    S_re_croak2(aTHX_ m, REPORT_LOCATION, a1, a2, a3, a4,	\
	    (int)offset, RExC_precomp, RExC_precomp + offset);	\
} STMT_END


#define	vWARN(loc,m) STMT_START {					\
    IV offset = loc - RExC_precomp;					\
    Perl_warner(aTHX_ packWARN(WARN_REGEXP), "%s" REPORT_LOCATION,	\
	    m, (int)offset, RExC_precomp, RExC_precomp + offset);	\
} STMT_END

#define	vWARNdep(loc,m) STMT_START {					\
    IV offset = loc - RExC_precomp;					\
    Perl_warner(aTHX_ packWARN2(WARN_DEPRECATED, WARN_REGEXP),		\
	    "%s" REPORT_LOCATION,					\
	    m, (int)offset, RExC_precomp, RExC_precomp + offset);	\
} STMT_END


#define	vWARN2(loc, m, a1) STMT_START {					\
    IV offset = loc - RExC_precomp;					\
    Perl_warner(aTHX_ packWARN(WARN_REGEXP), m REPORT_LOCATION,		\
	    a1, (int)offset, RExC_precomp, RExC_precomp + offset);	\
} STMT_END

#define	vWARN3(loc, m, a1, a2) STMT_START {				\
    IV offset = loc - RExC_precomp;					\
    Perl_warner(aTHX_ packWARN(WARN_REGEXP), m REPORT_LOCATION,		\
	    a1, a2, (int)offset, RExC_precomp, RExC_precomp + offset);	\
} STMT_END

#define	vWARN4(loc, m, a1, a2, a3) STMT_START {				\
    IV offset = loc - RExC_precomp;					\
    Perl_warner(aTHX_ packWARN(WARN_REGEXP), m REPORT_LOCATION,		\
	    a1, a2, a3, (int)offset, RExC_precomp, RExC_precomp + offset); \
} STMT_END

#define	vWARN5(loc, m, a1, a2, a3, a4) STMT_START {			\
    IV offset = loc - RExC_precomp;					\
    Perl_warner(aTHX_ packWARN(WARN_REGEXP), m REPORT_LOCATION,		\
	    a1, a2, a3, a4, (int)offset, RExC_precomp, RExC_precomp + offset); \
} STMT_END
d435 1
a435 3
#define REGC(c,s) STMT_START {			\
    if (!SIZE_ONLY) *(s) = (c); else (void)(s);	\
} STMT_END
d444 1
a444 1
/* #define MJD_OFFSET_DEBUG(x) Perl_warn_nocontext x */
d447 29
a475 33
#define Set_Node_Offset_To_R(node,byte) STMT_START {			\
    if (! SIZE_ONLY) {							\
	MJD_OFFSET_DEBUG(("** (%d) offset of node %d is %d.\n",		\
		__LINE__, (node), (byte)));				\
	if((node) < 0) {						\
	    Perl_croak(aTHX_ "value of node is %d in Offset macro", node); \
	} else {							\
	    RExC_offsets[2*(node)-1] = (byte);				\
	}								\
    }									\
} STMT_END

#define Set_Node_Offset(node,byte) \
    Set_Node_Offset_To_R((node)-RExC_emit_start, (byte)-RExC_start)
#define Set_Cur_Node_Offset Set_Node_Offset(RExC_emit, RExC_parse)

#define Set_Node_Length_To_R(node,len) STMT_START {			\
    if (! SIZE_ONLY) {							\
	MJD_OFFSET_DEBUG(("** (%d) size of node %d is %d.\n",		\
		__LINE__, (node), (len)));				\
	if((node) < 0) {						\
	    Perl_croak(aTHX_ "value of node is %d in Length macro", node); \
	} else {							\
	    RExC_offsets[2*(node)] = (len);				\
	}								\
    }									\
} STMT_END

#define Set_Node_Length(node,len) \
    Set_Node_Length_To_R((node)-RExC_emit_start, len)
#define Set_Cur_Node_Length(len) Set_Node_Length(RExC_emit, len)
#define Set_Node_Cur_Length(node) \
    Set_Node_Length(node, RExC_parse - parse_start)
d494 1
a494 1
	SvSetMagicSV(*data->longest, data->last_found);
a517 7
    {
	SV * sv = data->last_found;
	MAGIC *mg =
	    SvUTF8(sv) && SvMAGICAL(sv) ? mg_find(sv, PERL_MAGIC_utf8) : NULL;
	if (mg && mg->mg_len > 0)
	    mg->mg_len = 0;
    }
d591 1
a591 2
    if (cl->flags & ANYOF_UNICODE_ALL && and_with->flags & ANYOF_UNICODE &&
	!(and_with->flags & ANYOF_INVERT)) {
d596 1
a596 2
    if (!(and_with->flags & ANYOF_UNICODE_ALL) &&
	!(and_with->flags & ANYOF_INVERT))
d598 1
a598 2
    if (!(and_with->flags & (ANYOF_UNICODE|ANYOF_UNICODE_ALL)) &&
	!(and_with->flags & ANYOF_INVERT))
a935 8
		{
		    SV * sv = data->last_found;
		    MAGIC *mg = SvUTF8(sv) && SvMAGICAL(sv) ?
			mg_find(sv, PERL_MAGIC_utf8) : NULL;
		    if (mg && mg->mg_len >= 0)
			mg->mg_len += utf8_length((U8*)STRING(scan),
						  (U8*)STRING(scan)+STR_LEN(scan));
		}
a1292 2
			if (UTF)
			    SvUTF8_on(last_str);
a1303 8
				{
				    SV * sv = data->last_found;
				    MAGIC *mg =
					SvUTF8(sv) && SvMAGICAL(sv) ?
					mg_find(sv, PERL_MAGIC_utf8) : NULL;
				    if (mg && mg->mg_len >= 0)
					mg->mg_len += CHR_SVLEN(last_str);
				}
d1309 2
a1310 2
			    data->last_start_max += is_inf ? I32_MAX
				: (maxcount - 1) * (minnext + data->pos_delta);
d2221 1
a2221 1
		    PAD *pad;
d2230 1
a2230 1
		    rop = sv_compile_2op(sv, &sop, "re", &pad);
d2239 1
a2239 1
		    RExC_rx->data->data[n+2] = (void*)pad;
d2244 1
a2244 1
			&& IN_PERL_RUNTIME)
d2261 1
a2261 4
		ret = reganode(pRExC_state, EVAL, n);
		Set_Node_Length(ret, RExC_parse - parse_start + 1);
		Set_Node_Offset(ret, parse_start);
		return ret;
a2496 2
	    Set_Node_Cur_Length(ret);
	    Set_Node_Offset(ret, parse_start + 1);
d2777 1
a2777 1
    char *parse_start = RExC_parse;
d2964 1
a2964 1
		char* parse_start = RExC_parse - 2;
d2988 1
a2988 3

		Set_Node_Offset(ret, parse_start + 2);
		Set_Node_Cur_Length(ret);
a3037 1
	    parse_start--;
d3144 5
d3292 1
a3292 1
	    if (len == 1 && UNI_IS_INVARIANT(ender))
d3307 2
a3308 8
	STRLEN oldlen = STR_LEN(ret);
	SV *sv        = sv_2mortal(newSVpvn(STRING(ret), oldlen));

	if (RExC_utf8)
	    SvUTF8_on(sv);
	if (sv_utf8_downgrade(sv, TRUE)) {
	    char *s       = sv_recode_to_utf8(sv, PL_encoding);
	    STRLEN newlen = SvCUR(sv);
d3310 16
a3325 12
	    if (SvUTF8(sv))
		RExC_utf8 = 1;
	    if (!SIZE_ONLY) {
		DEBUG_r(PerlIO_printf(Perl_debug_log, "recode %*s to %*s\n",
				      (int)oldlen, STRING(ret),
				      (int)newlen, s));
		Copy(s, STRING(ret), newlen, char);
		STR_LEN(ret) += newlen - oldlen;
		RExC_emit += STR_SZ(newlen) - STR_SZ(oldlen);
	    } else
		RExC_size += STR_SZ(newlen) - STR_SZ(oldlen);
	}
d4227 1
a4227 1
	 * in its textual form: used later (regexec.c:Perl_regclass_swash())
d4231 1
a4231 1
	 * used later (regexec.c:S_reginclass()). */
d4252 1
a4252 3
	    while (*RExC_parse != ')') {
		if (RExC_parse == RExC_end)
		    FAIL("Sequence (?#... not terminated");
a4253 1
	    }
d4263 3
a4265 2
		while (RExC_parse < RExC_end)
		    if (*RExC_parse++ == '\n') break;
d4293 1
a4293 1
	MJD_OFFSET_DEBUG(("%s:%u: (op %s) %s %u <- %u (len %u) (max %u).\n", 
d4301 1
a4301 1
	Set_Node_Offset(RExC_emit, RExC_parse + (op == END));
d4329 1
a4329 1
	MJD_OFFSET_DEBUG(("%s(%d): (op %s) %s %u <- %u (max %u).\n", 
a4330 2
	      __LINE__,
	      reg_name[op],
d4336 1
a4336 1
	Set_Cur_Node_Offset;
d4379 1
a4379 1
	    MJD_OFFSET_DEBUG(("%s(%d): (op %s) %s copy %u -> %u (max %u).\n",
a4380 2
		  __LINE__,
		  reg_name[op],
d4386 2
a4387 2
	    Set_Node_Offset_To_R(dst-RExC_emit_start, Node_Offset(src));
	    Set_Node_Length_To_R(dst-RExC_emit_start, Node_Length(src));
d4394 1
a4394 1
	MJD_OFFSET_DEBUG(("%s(%d): (op %s) %s %u <- %u (max %u).\n", 
a4395 2
	      __LINE__,
	      reg_name[op],
d4401 1
a4401 2
	Set_Node_Offset(place, RExC_parse);
	Set_Node_Length(place, 1);
d4717 1
a4717 1
	const char * const anyofs[] = {	/* Should be synchronized with
d4921 3
a4923 2
	PAD* new_comppad = NULL;
	PAD* old_comppad;
d4940 10
a4949 5
		PAD_SAVE_LOCAL(old_comppad,
		    /* Watch out for global destruction's random ordering. */
		    (SvTYPE(new_comppad) == SVt_PVAV) ?
		    		new_comppad : Null(PAD *)
		);
d4954 2
a4955 1
		PAD_RESTORE_LOCAL(old_comppad);
d5024 1
a5024 1
    buf[l1-1] = '\0';			/* Overwrite \n */
d5033 14
a5054 1
    SAVEVPTR(PL_reglastcloseparen);	/* Similarly for lastcloseparen. */
d5071 1
a5071 1
    SAVEBOOL(PL_reg_match_utf8);	/* from regexec.c */
a5075 13
    SAVEPPTR(PL_reg_oldsaved);		/* old saved substr during match */
    PL_reg_oldsaved = Nullch;
    SAVEI32(PL_reg_oldsavedlen);	/* old length of saved substr during match */
    PL_reg_oldsavedlen = 0;
    SAVEI32(PL_reg_maxiter);		/* max wait until caching pos */
    PL_reg_maxiter = 0;
    SAVEI32(PL_reg_leftiter);		/* wait until caching pos */
    PL_reg_leftiter = 0;
    SAVEGENERICPV(PL_reg_poscache);	/* cache of pos of WHILEM */
    PL_reg_poscache = Nullch;
    SAVEI32(PL_reg_poscache_size);	/* size of pos cache of WHILEM */
    PL_reg_poscache_size = 0;
    SAVEPPTR(PL_regprecomp);		/* uncompiled string. */
a5077 17

    {
	/* Save $1..$n (#18107: UTF-8 s/(\w+)/uc($1)/e); AMS 20021106. */
	U32 i;
	GV *mgv;
	REGEXP *rx;
	char digits[16];

	if (PL_curpm && (rx = PM_GETRE(PL_curpm))) {
	    for (i = 1; i <= rx->nparens; i++) {
		sprintf(digits, "%lu", (long)i);
		if ((mgv = gv_fetchpv(digits, FALSE, SVt_PV)))
		    save_scalar(mgv);
	    }
	}
    }

@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@d1191 1
a1191 3
		      && !deltanext	/* atom is fixed width */
		      && minnext != 0	/* CURLYM can't handle zero width */
		) {
d3657 1
a3657 2
		namedclass = ANYOF_MAX;  /* no official name, but it's named */
		break;
a4060 3
		    break;
		case ANYOF_MAX:
		    /* this is to handle \p and \P */
@


1.1.1.8
log
@perl 5.8.6 from CPAN
@
text
@a7 10
/* This file contains functions for compiling a regular expression.  See
 * also regexec.c which funnily enough, contains functions for executing
 * a regular expression.
 *
 * This file is also copied at build time to ext/re/re_comp.c, where
 * it's built with -DPERL_EXT_RE_BUILD -DPERL_EXT_RE_DEBUG -DPERL_EXT.
 * This causes the main functions to be compiled under new names and with
 * debugging support added, which makes "use re 'debug'" work.
 */

@


1.1.1.9
log
@perl 5.8.8 import
@
text
@d58 1
d83 1
a83 1
 ****    2000, 2001, 2002, 2003, 2004, 2005, 2006, by Larry Wall and others
d209 2
a210 2
static const scan_data_t zero_scan_data =
  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
d271 1
a271 1
    const char *ellipses = "";						\
d291 1
a291 1
    const char *ellipses = "";						\
d310 1
a310 1
    const IV offset = RExC_parse - RExC_precomp;			\
d328 1
a328 1
    const IV offset = RExC_parse - RExC_precomp;			\
d347 1
a347 1
    const IV offset = RExC_parse - RExC_precomp;		\
d365 1
a365 1
    const IV offset = RExC_parse - RExC_precomp;		\
d370 10
d381 1
a381 1
    const IV offset = loc - RExC_precomp;				\
d387 1
a387 1
    const IV offset = loc - RExC_precomp;				\
d395 1
a395 1
    const IV offset = loc - RExC_precomp;				\
d401 1
a401 1
    const IV offset = loc - RExC_precomp;				\
d407 1
a407 1
    const IV offset = loc - RExC_precomp;				\
d413 1
a413 1
    const IV offset = loc - RExC_precomp;				\
d439 1
a439 1
	    Perl_croak(aTHX_ "value of node is %d in Offset macro", (int)(node)); \
d453 1
a453 1
		__LINE__, (int)(node), (int)(len)));			\
d455 1
a455 1
	    Perl_croak(aTHX_ "value of node is %d in Length macro", (int)(node)); \
d481 2
a482 2
    const STRLEN l = CHR_SVLEN(data->last_found);
    const STRLEN old_l = CHR_SVLEN(*data->longest);
d510 2
a511 2
	SV * const sv = data->last_found;
	MAGIC * const mg =
d533 1
a533 1
S_cl_is_anything(pTHX_ const struct regnode_charclass_class *cl)
d570 1
a570 1
	const struct regnode_charclass_class *and_with)
d606 1
a606 1
S_cl_or(pTHX_ RExC_state_t *pRExC_state, struct regnode_charclass_class *cl, const struct regnode_charclass_class *or_with)
d677 1
a677 1
/* Stops at toplevel WHILEM as well as at "last". At end *scanp is set
d725 1
a725 1
		    const int oldl = STR_LEN(scan);
d773 3
a775 3
		 const char * const t0 = "\xcc\x88\xcc\x81";
		 const char * const t1 = t0 + 3;

d800 1
a800 1
	    const int max = (reg_off_by_arg[OP(scan)]
a911 1

d923 3
a925 3
		const U8 * const s = (U8*)STRING(scan);
		l = utf8_length((U8 *)s, (U8 *)s + l);
		uc = utf8_to_uvchr((U8 *)s, NULL);
d938 2
a939 2
		    SV * const sv = data->last_found;
		    MAGIC * const mg = SvUTF8(sv) && SvMAGICAL(sv) ?
d1027 1
a1027 1
	else if (strchr((const char*)PL_varies,OP(scan))) {
d1140 3
a1142 2
		if ( /* ? quantifier ok, except for (?{ ... }) */
		    (next_is_eval || !(mincount == 0 && maxcount == 1))
d1145 1
a1145 2
		    && maxcount <= REG_INFTY/3 /* Complement check for big count */
		    && ckWARN(WARN_REGEXP))
d1172 1
a1172 1
		    if (!strchr((const char*)PL_simple,OP(nxt))
d1278 1
a1278 1
			const char *s = NULL;
d1287 1
a1287 1
			s = SvPV_const(data->last_found, l);
d1294 1
a1294 1
			const char *s = SvPV_const(data->last_found, l);
d1311 2
a1312 2
					  SvPVX_const(last_str), l, mincount - 1);
				SvCUR_set(last_str, SvCUR(last_str) * mincount);
d1377 1
a1377 1
	else if (strchr((const char*)PL_simple,OP(scan))) {
d1626 1
a1626 1
		const int was = (data->start_class->flags & ANYOF_EOS);
d1685 1
a1685 1
S_add_data(pTHX_ RExC_state_t *pRExC_state, I32 n, const char *s)
d1695 1
a1695 1
	Newxc(RExC_rx->data, sizeof(*RExC_rx->data) + sizeof(void*) * (n - 1),
d1697 1
a1697 1
	Newx(RExC_rx->data->what, n, U8);
d1707 3
a1709 1
    const char * const s = PerlEnv_getenv("PERL_RE_COLORS");
d1711 1
a1711 3
	char *t = savepv(s);
	int i = 0;
	PL_colors[0] = t;
d1713 4
a1716 4
	    t = strchr(t, '\t');
	    if (t) {
		*t = '\0';
		PL_colors[i] = ++t;
d1719 1
a1719 1
		PL_colors[i] = t = (char *)"";
a1721 1
	int i = 0;
d1723 1
a1723 1
	    PL_colors[i++] = (char *)"";
d1807 1
a1807 1
    Newxc(r, sizeof(regexp) + (unsigned)RExC_size * sizeof(regnode),
d1827 1
a1827 1
    Newxz(r->offsets, 2*RExC_size+1, U32); /* MJD 20001228 */
d1829 1
a1829 1
	r->offsets[0] = RExC_size;
d1832 2
a1833 2
                          "%s %"UVuf" bytes for offset annotations.\n",
                          r->offsets ? "Got" : "Couldn't get",
d1865 1
a1865 1
    Newxz(r->substrs, 1, struct reg_substr_data);
d1900 1
a1900 1
	else if (strchr((const char*)PL_simple,OP(first)))
d1924 7
a1930 4
	    const int type =
		(OP(NEXTOPER(first)) == REG_ANY)
		    ? ROPT_ANCH_MBOL
		    : ROPT_ANCH_SBOL;
d2045 1
a2045 1
	    const I32 n = add_data(pRExC_state, 1, "f");
d2047 1
a2047 1
	    Newx(RExC_rx->data->data[n], 1,
d2058 2
a2059 2
				    "synthetic stclass \"%s\".\n",
				    SvPVX_const(sv));});
d2101 1
a2101 1
	    const I32 n = add_data(pRExC_state, 1, "f");
d2103 1
a2103 1
	    Newx(RExC_rx->data->data[n], 1,
d2113 2
a2114 2
				    "synthetic stclass \"%s\".\n",
				    SvPVX_const(sv));});
d2127 2
a2128 2
    Newxz(r->startp, RExC_npar, I32);
    Newxz(r->endp, RExC_npar, I32);
d2164 1
a2164 1
    char * const oregcomp_parse = RExC_parse;
d2176 1
a2176 1
	    const char * const seqstart = RExC_parse;
d2309 1
a2309 1

d2431 1
a2431 1

d2466 1
a2466 1

d2511 2
a2512 2
        const char *p;
        static const char parens[] = "=!<,>";
d2628 1
a2628 1
    const char * const origparse = RExC_parse;
d2693 1
a2693 1
                Set_Node_Length(ret,
d2695 1
a2695 1

d2769 1
a2769 1
    if (!SIZE_ONLY && !(flags&HASWIDTH) && max > REG_INFTY/3 && ckWARN(WARN_REGEXP)) {
d3034 1
a3034 1
		const I32 num = atoi(RExC_parse);
d3050 1
a3050 1

d3052 1
a3052 1
                    Set_Node_Offset(ret, parse_start+1);
d3064 1
a3064 1
	    /* Do not generate "unrecognized" warnings here, we fall
d3084 1
d3086 1
a3086 1
	    U8 tmpbuf[UTF8_MAXBYTES_CASE+1], *foldbuf;
d3160 1
a3160 1
			    char* const e = strchr(p, '}');
d3169 1
a3169 1
                                STRLEN numlen = e - p - 1;
d3178 1
a3178 1
			    STRLEN numlen = 2;
d3193 1
a3193 1
			    STRLEN numlen = 3;
d3207 1
a3207 1
			if (!SIZE_ONLY&& isALPHA(*p) && ckWARN(WARN_REGEXP))
a3214 1
			STRLEN numlen;
a3236 1
			      STRLEN numlen;
a3273 1
			  STRLEN numlen;
d3337 2
a3338 2
	    const char * const s = sv_recode_to_utf8(sv, PL_encoding);
	    const STRLEN newlen = SvCUR(sv);
d3358 1
a3358 1
S_regwhite(pTHX_ char *p, const char *e)
d3387 1
d3393 1
a3393 1
	const char c = UCHARAT(RExC_parse);
d3402 1
a3402 4
	    const char* t = RExC_parse++; /* skip over the c */
	    const char *posixcc;

	    assert(*t == c);
d3408 2
a3409 2
		    const I32 complement = *posixcc == '^' ? *posixcc++ : 0;
		    const I32 skip = t - posixcc;
d3411 49
a3459 8
		    /* Initially switch on the length of the name.  */
		    switch (skip) {
		    case 4:
			if (memEQ(posixcc, "word", 4)) {
			    /* this is not POSIX, this is the Perl \w */;
			    namedclass
				= complement ? ANYOF_NALNUM : ANYOF_ALNUM;
			}
d3461 10
a3470 84
		    case 5:
			/* Names all of length 5.  */
			/* alnum alpha ascii blank cntrl digit graph lower
			   print punct space upper  */
			/* Offset 4 gives the best switch position.  */
			switch (posixcc[4]) {
			case 'a':
			    if (memEQ(posixcc, "alph", 4)) {
				/*                  a     */
				namedclass
				    = complement ? ANYOF_NALPHA : ANYOF_ALPHA;
			    }
			    break;
			case 'e':
			    if (memEQ(posixcc, "spac", 4)) {
				/*                  e     */
				namedclass
				    = complement ? ANYOF_NPSXSPC : ANYOF_PSXSPC;
			    }
			    break;
			case 'h':
			    if (memEQ(posixcc, "grap", 4)) {
				/*                  h     */
				namedclass
				    = complement ? ANYOF_NGRAPH : ANYOF_GRAPH;
			    }
			    break;
			case 'i':
			    if (memEQ(posixcc, "asci", 4)) {
				/*                  i     */
				namedclass
				    = complement ? ANYOF_NASCII : ANYOF_ASCII;
			    }
			    break;
			case 'k':
			    if (memEQ(posixcc, "blan", 4)) {
				/*                  k     */
				namedclass
				    = complement ? ANYOF_NBLANK : ANYOF_BLANK;
			    }
			    break;
			case 'l':
			    if (memEQ(posixcc, "cntr", 4)) {
				/*                  l     */
				namedclass
				    = complement ? ANYOF_NCNTRL : ANYOF_CNTRL;
			    }
			    break;
			case 'm':
			    if (memEQ(posixcc, "alnu", 4)) {
				/*                  m     */
				namedclass
				    = complement ? ANYOF_NALNUMC : ANYOF_ALNUMC;
			    }
			    break;
			case 'r':
			    if (memEQ(posixcc, "lowe", 4)) {
				/*                  r     */
				namedclass
				    = complement ? ANYOF_NLOWER : ANYOF_LOWER;
			    }
			    if (memEQ(posixcc, "uppe", 4)) {
				/*                  r     */
				namedclass
				    = complement ? ANYOF_NUPPER : ANYOF_UPPER;
			    }
			    break;
			case 't':
			    if (memEQ(posixcc, "digi", 4)) {
				/*                  t     */
				namedclass
				    = complement ? ANYOF_NDIGIT : ANYOF_DIGIT;
			    }
			    if (memEQ(posixcc, "prin", 4)) {
				/*                  t     */
				namedclass
				    = complement ? ANYOF_NPRINT : ANYOF_PRINT;
			    }
			    if (memEQ(posixcc, "punc", 4)) {
				/*                  t     */
				namedclass
				    = complement ? ANYOF_NPUNCT : ANYOF_PUNCT;
			    }
			    break;
d3473 5
a3477 4
		    case 6:
			if (memEQ(posixcc, "xdigit", 6)) {
			    namedclass
				= complement ? ANYOF_NXDIGIT : ANYOF_XDIGIT;
d3481 3
a3483 2

		    if (namedclass == OOB_NAMEDCLASS)
a3487 2
		    assert (posixcc[skip] == ':');
		    assert (posixcc[skip+1] == ']');
d3512 2
a3513 2
	const char *s = RExC_parse;
	const char  c = *s++;
d3634 1
a3634 1
		    const U8 c = (U8)value;
d3711 1
a3711 1
		if (!SIZE_ONLY && isALPHA(value) && ckWARN(WARN_REGEXP))
a3753 3
		const char *what = NULL;
		char yesno = 0;

d3769 1
a3769 2
		    yesno = '+';
		    what = "Word";	
d3779 1
a3779 2
		    yesno = '!';
		    what = "Word";
d3789 1
a3789 2
		    yesno = '+';
		    what = "Alnum";
d3799 1
a3799 2
		    yesno = '!';
		    what = "Alnum";
d3809 1
a3809 2
		    yesno = '+';
		    what = "Alpha";
d3819 1
a3819 2
		    yesno = '!';
		    what = "Alpha";
d3835 1
a3835 2
		    yesno = '+';
		    what = "ASCII";
d3851 1
a3851 2
		    yesno = '!';
		    what = "ASCII";
d3861 1
a3861 2
		    yesno = '+';
		    what = "Blank";
d3871 1
a3871 2
		    yesno = '!';
		    what = "Blank";
d3881 1
a3881 2
		    yesno = '+';
		    what = "Cntrl";
d3891 1
a3891 2
		    yesno = '!';
		    what = "Cntrl";
d3901 1
a3901 2
		    yesno = '+';
		    what = "Digit";
d3913 1
a3913 2
		    yesno = '!';
		    what = "Digit";
d3923 1
a3923 2
		    yesno = '+';
		    what = "Graph";
d3933 1
a3933 2
		    yesno = '!';
		    what = "Graph";
d3943 1
a3943 2
		    yesno = '+';
		    what = "Lower";
d3953 1
a3953 2
		    yesno = '!';
		    what = "Lower";
d3963 1
a3963 2
		    yesno = '+';
		    what = "Print";
d3973 1
a3973 2
		    yesno = '!';
		    what = "Print";
d3983 1
a3983 2
		    yesno = '+';
		    what = "Space";
d3993 1
a3993 2
		    yesno = '!';
		    what = "Space";
d4003 1
a4003 2
		    yesno = '+';
		    what = "Punct";
d4013 1
a4013 2
		    yesno = '!';
		    what = "Punct";
d4023 1
a4023 2
		    yesno = '+';
		    what = "SpacePerl";
d4033 1
a4033 2
		    yesno = '!';
		    what = "SpacePerl";
d4043 1
a4043 2
		    yesno = '+';
		    what = "Upper";
d4053 1
a4053 2
		    yesno = '!';
		    what = "Upper";
d4063 1
a4063 2
		    yesno = '+';
		    what = "XDigit";
d4073 1
a4073 2
		    yesno = '!';
		    what = "XDigit";
a4081 4
		if (what) {
		    /* Strings such as "+utf8::isWord\n" */
		    Perl_sv_catpvf(aTHX_ listsv, "%cutf8::Is%s\n", yesno, what);
		}
d4124 1
a4124 1
	        const IV ceilvalue = value < 256 ? value : 255;
d4149 2
a4150 2
	        const UV prevnatvalue  = NATIVE_TO_UNI(prevvalue);
		const UV natvalue      = NATIVE_TO_UNI(value);
d4160 1
a4160 1
			 U8 foldbuf[UTF8_MAXBYTES_CASE+1];
d4162 1
a4162 1
			 const UV f = to_uni_fold(natvalue, foldbuf, &foldlen);
d4311 1
a4312 1
    regnode * const ret = RExC_emit;
d4314 1
d4347 1
a4348 1
    regnode * const ret = RExC_emit;
d4350 1
d4382 1
a4382 1
S_reguni(pTHX_ const RExC_state_t *pRExC_state, UV uv, char* s, STRLEN* lenp)
d4398 1
a4398 1
    const int offset = regarglen[(U8)op];
d4454 1
d4462 1
a4462 1
	regnode * const temp = regnext(scan);
d4499 1
a4499 1
S_regcurly(pTHX_ register const char *s)
d4516 76
d4606 1
a4606 1
		      "anchored \"%s%.*s%s\"%s at %"IVdf" ",
d4609 1
a4609 1
		      SvPVX_const(r->anchored_substr),
d4615 1
a4615 1
		      "anchored utf8 \"%s%.*s%s\"%s at %"IVdf" ",
d4618 1
a4618 1
		      SvPVX_const(r->anchored_utf8),
d4624 1
a4624 1
		      "floating \"%s%.*s%s\"%s at %"IVdf"..%"UVuf" ",
d4627 1
a4627 1
		      SvPVX_const(r->float_substr),
d4633 1
a4633 1
		      "floating utf8 \"%s%.*s%s\"%s at %"IVdf"..%"UVuf" ",
d4636 1
a4636 1
		      SvPVX_const(r->float_utf8),
d4654 1
a4654 1
	PerlIO_printf(Perl_debug_log, "stclass \"%s\" ", SvPVX_const(sv));
d4680 1
a4680 1
      const U32 len = r->offsets[0];
d4691 15
d4720 1
a4720 1
    sv_catpv(sv, reg_name[OP(o)]); /* Take off const! */
d4725 1
a4725 1
	SV * const dsv = sv_2mortal(newSVpvn("", 0));
d4729 2
a4730 2
	const bool do_utf8 = is_utf8_string((U8*)STRING(o), STR_LEN(o));
	const char * const s = do_utf8 ?
d4734 1
a4734 1
	const int len = do_utf8 ?
d4755 1
a4755 1
	const U8 flags = ANYOF_FLAGS(o);
d4826 1
a4826 1
	    SV * const sw = regclass_swash(o, FALSE, &lv, 0);
d4830 1
a4830 1
		    U8 s[UTF8_MAXBYTES_CASE+1];
d4833 1
a4833 1
			uvchr_to_utf8(s, i);
d4839 2
d4843 1
a4843 3
				    const U8 * const e = uvchr_to_utf8(s,rangestart);
				    U8 *p;
				    for(p = s; p < e; p++)
d4847 1
a4847 7
				const U8 *e = uvchr_to_utf8(s,rangestart);
				U8 *p;
				for (p = s; p < e; p++)
				    put_byte(sv, *p);
				sv_catpvn(sv, "-", 1);
				e = uvchr_to_utf8(s, i-1);
				for (p = s; p < e; p++)
d4849 3
d4861 1
a4861 1
		    char *s = savesvpv(lv);
d4867 1
a4867 1
			const char * const t = ++s;
d4896 3
a4898 3
	{
	    const char * const s = SvPV_nolen_const(prog->check_substr
		      ? prog->check_substr : prog->check_utf8);
d4902 1
a4902 1
		      "%sUsing REx %ssubstr:%s \"%s%.60s%s%s\"\n",
d4924 5
a4928 2
        const char *s = (r->reganch & ROPT_UTF8)
            ? pv_uni_display(dsv, (U8*)r->precomp, r->prelen, 60, UNI_DISPLAY_REGEX)
d4930 1
a4930 1
        const int len = SvCUR(dsv);
d4941 4
a4944 4
    /* gcov results gave these as non-null 100% of the time, so there's no
       optimisation in checking them before calling Safefree  */
    Safefree(r->precomp);
    Safefree(r->offsets);             /* 20010421 MJD */
a4961 1
	PADOFFSET refcnt;
d4983 1
a4983 4
		OP_REFCNT_LOCK;
		refcnt = OpREFCNT_dec((OP_4tree*)r->data->data[n]);
		OP_REFCNT_UNLOCK;
		if (!refcnt)
d4985 1
d5034 1
a5034 1
    const char *message;
d5052 1
a5052 1
    message = SvPV_const(msv,l1);
d5113 2
d5116 1
a5118 1
	    U32 i;
a5119 2
		GV *mgv;
		char digits[TYPE_CHARS(long)];
a5137 96
#ifdef DEBUGGING

STATIC void
S_put_byte(pTHX_ SV *sv, int c)
{
    if (isCNTRL(c) || c == 255 || !isPRINT(c))
	Perl_sv_catpvf(aTHX_ sv, "\\%o", c);
    else if (c == '-' || c == ']' || c == '\\' || c == '^')
	Perl_sv_catpvf(aTHX_ sv, "\\%c", c);
    else
	Perl_sv_catpvf(aTHX_ sv, "%c", c);
}


STATIC regnode *
S_dumpuntil(pTHX_ regnode *start, regnode *node, regnode *last, SV* sv, I32 l)
{
    register U8 op = EXACT;	/* Arbitrary non-END op. */
    register regnode *next;

    while (op != END && (!last || node < last)) {
	/* While that wasn't END last time... */

	NODE_ALIGN(node);
	op = OP(node);
	if (op == CLOSE)
	    l--;	
	next = regnext(node);
	/* Where, what. */
	if (OP(node) == OPTIMIZED)
	    goto after_print;
	regprop(sv, node);
	PerlIO_printf(Perl_debug_log, "%4"IVdf":%*s%s", (IV)(node - start),
		      (int)(2*l + 1), "", SvPVX_const(sv));
	if (next == NULL)		/* Next ptr. */
	    PerlIO_printf(Perl_debug_log, "(0)");
	else
	    PerlIO_printf(Perl_debug_log, "(%"IVdf")", (IV)(next - start));
	(void)PerlIO_putc(Perl_debug_log, '\n');
      after_print:
	if (PL_regkind[(U8)op] == BRANCHJ) {
	    register regnode *nnode = (OP(next) == LONGJMP
				       ? regnext(next)
				       : next);
	    if (last && nnode > last)
		nnode = last;
	    node = dumpuntil(start, NEXTOPER(NEXTOPER(node)), nnode, sv, l + 1);
	}
	else if (PL_regkind[(U8)op] == BRANCH) {
	    node = dumpuntil(start, NEXTOPER(node), next, sv, l + 1);
	}
	else if ( op == CURLY) {   /* "next" might be very big: optimizer */
	    node = dumpuntil(start, NEXTOPER(node) + EXTRA_STEP_2ARGS,
			     NEXTOPER(node) + EXTRA_STEP_2ARGS + 1, sv, l + 1);
	}
	else if (PL_regkind[(U8)op] == CURLY && op != CURLYX) {
	    node = dumpuntil(start, NEXTOPER(node) + EXTRA_STEP_2ARGS,
			     next, sv, l + 1);
	}
	else if ( op == PLUS || op == STAR) {
	    node = dumpuntil(start, NEXTOPER(node), NEXTOPER(node) + 1, sv, l + 1);
	}
	else if (op == ANYOF) {
	    /* arglen 1 + class block */
	    node += 1 + ((ANYOF_FLAGS(node) & ANYOF_LARGE)
		    ? ANYOF_CLASS_SKIP : ANYOF_SKIP);
	    node = NEXTOPER(node);
	}
	else if (PL_regkind[(U8)op] == EXACT) {
            /* Literal string, where present. */
	    node += NODE_SZ_STR(node) - 1;
	    node = NEXTOPER(node);
	}
	else {
	    node = NEXTOPER(node);
	    node += regarglen[(U8)op];
	}
	if (op == CURLYX || op == OPEN)
	    l++;
	else if (op == WHILEM)
	    l--;
    }
    return node;
}

#endif	/* DEBUGGING */

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
@


1.1.1.10
log
@import perl 5.10.0 from CPAN
@
text
@d33 23
a55 1
#include "re_top.h"
d82 1
a82 1
 ****    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007 by Larry Wall and others
d101 1
a101 5
#ifdef PERL_IN_XSUB_RE
#  include "re_comp.h"
#else
#  include "regcomp.h"
#endif
d123 1
a123 2
    regexp	*rx;                    /* perl core regexp structure */
    regexp_internal	*rxi;           /* internal data for regexp object pprivate field */        
a128 1
    regnode	*emit_bound;		/* First regnode outside of the allocated space */
d134 1
a134 3
    I32		npar;			/* Capture buffer count, (OPEN). */
    I32		cpar;			/* Capture buffer count, (CLOSE). */
    I32		nestroot;		/* root parens we are in - used by accept */
d138 1
a138 12
    regnode	**open_parens;		/* pointers to open parens */
    regnode	**close_parens;		/* pointers to close parens */
    regnode	*opend;			/* END node in program */
    I32		utf8;		/* whether the pattern is utf8 or not */
    I32		orig_utf8;	/* whether the pattern was originally in utf8 */
				/* XXX use this for future optimisation of case
				 * where pattern must be upgraded to utf8. */
    HV		*charnames;		/* cache of named sequences */
    HV		*paren_names;		/* Paren names */
    
    regnode	**recurse;		/* Recurse regops */
    I32		recurse_count;		/* Number of recurse regops */
a142 8
#ifdef DEBUGGING
    const char  *lastparse;
    I32         lastnum;
    AV          *paren_name_list;       /* idx -> name */
#define RExC_lastparse	(pRExC_state->lastparse)
#define RExC_lastnum	(pRExC_state->lastnum)
#define RExC_paren_name_list    (pRExC_state->paren_name_list)
#endif
a147 1
#define RExC_rxi	(pRExC_state->rxi)
d152 1
a152 3
#ifdef RE_TRACK_PATTERN_OFFSETS
#define RExC_offsets	(pRExC_state->rxi->u.offsets) /* I am not like the others */
#endif
a154 1
#define RExC_emit_bound	(pRExC_state->emit_bound)
a159 1
#define RExC_nestroot   (pRExC_state->nestroot)
a163 9
#define RExC_orig_utf8	(pRExC_state->orig_utf8)
#define RExC_charnames  (pRExC_state->charnames)
#define RExC_open_parens	(pRExC_state->open_parens)
#define RExC_close_parens	(pRExC_state->close_parens)
#define RExC_opend	(pRExC_state->opend)
#define RExC_paren_names	(pRExC_state->paren_names)
#define RExC_recurse	(pRExC_state->recurse)
#define RExC_recurse_count	(pRExC_state->recurse_count)

d176 4
a179 96
#define	HASWIDTH	0x01	/* Known to match non-null strings. */
#define	SIMPLE		0x02	/* Simple enough to be STAR/PLUS operand. */
#define	SPSTART		0x04	/* Starts with * or +. */
#define TRYAGAIN	0x08	/* Weeded out a declaration. */
#define POSTPONED	0x10    /* (?1),(?&name), (??{...}) or similar */

#define REG_NODE_NUM(x) ((x) ? (int)((x)-RExC_emit_start) : -1)

/* whether trie related optimizations are enabled */
#if PERL_ENABLE_EXTENDED_TRIE_OPTIMISATION
#define TRIE_STUDY_OPT
#define FULL_TRIE_STUDY
#define TRIE_STCLASS
#endif



#define PBYTE(u8str,paren) ((U8*)(u8str))[(paren) >> 3]
#define PBITVAL(paren) (1 << ((paren) & 7))
#define PAREN_TEST(u8str,paren) ( PBYTE(u8str,paren) & PBITVAL(paren))
#define PAREN_SET(u8str,paren) PBYTE(u8str,paren) |= PBITVAL(paren)
#define PAREN_UNSET(u8str,paren) PBYTE(u8str,paren) &= (~PBITVAL(paren))


/* About scan_data_t.

  During optimisation we recurse through the regexp program performing
  various inplace (keyhole style) optimisations. In addition study_chunk
  and scan_commit populate this data structure with information about
  what strings MUST appear in the pattern. We look for the longest 
  string that must appear for at a fixed location, and we look for the
  longest string that may appear at a floating location. So for instance
  in the pattern:
  
    /FOO[xX]A.*B[xX]BAR/
    
  Both 'FOO' and 'A' are fixed strings. Both 'B' and 'BAR' are floating
  strings (because they follow a .* construct). study_chunk will identify
  both FOO and BAR as being the longest fixed and floating strings respectively.
  
  The strings can be composites, for instance
  
     /(f)(o)(o)/
     
  will result in a composite fixed substring 'foo'.
  
  For each string some basic information is maintained:
  
  - offset or min_offset
    This is the position the string must appear at, or not before.
    It also implicitly (when combined with minlenp) tells us how many
    character must match before the string we are searching.
    Likewise when combined with minlenp and the length of the string
    tells us how many characters must appear after the string we have 
    found.
  
  - max_offset
    Only used for floating strings. This is the rightmost point that
    the string can appear at. Ifset to I32 max it indicates that the
    string can occur infinitely far to the right.
  
  - minlenp
    A pointer to the minimum length of the pattern that the string 
    was found inside. This is important as in the case of positive 
    lookahead or positive lookbehind we can have multiple patterns 
    involved. Consider
    
    /(?=FOO).*F/
    
    The minimum length of the pattern overall is 3, the minimum length
    of the lookahead part is 3, but the minimum length of the part that
    will actually match is 1. So 'FOO's minimum length is 3, but the 
    minimum length for the F is 1. This is important as the minimum length
    is used to determine offsets in front of and behind the string being 
    looked for.  Since strings can be composites this is the length of the
    pattern at the time it was commited with a scan_commit. Note that
    the length is calculated by study_chunk, so that the minimum lengths
    are not known until the full pattern has been compiled, thus the 
    pointer to the value.
  
  - lookbehind
  
    In the case of lookbehind the string being searched for can be
    offset past the start point of the final matching string. 
    If this value was just blithely removed from the min_offset it would
    invalidate some of the calculations for how many chars must match
    before or after (as they are derived from min_offset and minlen and
    the length of the string being searched for). 
    When the final pattern is compiled and the data is moved from the
    scan_data_t structure into the regexp structure the information
    about lookbehind is factored in, with the information that would 
    have been lost precalculated in the end_shift field for the 
    associated string.

  The fields pos_min and pos_delta are used to store the minimum offset
  and the delta to the maximum offset at the current point in the pattern.    
d181 1
a181 1
*/
d184 2
a185 2
    /*I32 len_min;      unused */
    /*I32 len_delta;    unused */
d189 1
a189 1
    I32 last_end;	    /* min value, <0 unless valid. */
d192 6
a197 10
    SV **longest;	    /* Either &l_fixed, or &l_float. */
    SV *longest_fixed;      /* longest fixed string found in pattern */
    I32 offset_fixed;       /* offset where it starts */
    I32 *minlen_fixed;      /* pointer to the minlen relevent to the string */
    I32 lookbehind_fixed;   /* is the position of the string modfied by LB */
    SV *longest_float;      /* longest floating string found in pattern */
    I32 offset_float_min;   /* earliest point in string it can appear */
    I32 offset_float_max;   /* latest point in string it can appear */
    I32 *minlen_float;      /* pointer to the minlen relevent to the string */
    I32 lookbehind_float;   /* is the position of the string modified by LB */
d209 1
a209 1
  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ,0};
d212 2
a213 2
#define SF_BEFORE_SEOL		0x0001
#define SF_BEFORE_MEOL		0x0002
d230 5
a234 5
#define SF_IS_INF		0x0040
#define SF_HAS_PAR		0x0080
#define SF_IN_PAR		0x0100
#define SF_HAS_EVAL		0x0200
#define SCF_DO_SUBSTR		0x0400
a239 3
#define SCF_TRIE_RESTUDY        0x4000 /* Do restudy? */
#define SCF_SEEN_ACCEPT         0x8000 

d241 2
a242 2
#define LOC ((RExC_flags & RXf_PMf_LOCALE) != 0)
#define FOLD ((RExC_flags & RXf_PMf_FOLD) != 0)
d269 21
a289 1
#define _FAIL(code) STMT_START {					\
d300 2
a301 1
    code;                                                               \
a303 7
#define	FAIL(msg) _FAIL(			    \
    Perl_croak(aTHX_ "%s in regex m/%.*s%s/",	    \
	    msg, (int)len, RExC_precomp, ellipses))

#define	FAIL2(msg,arg) _FAIL(			    \
    Perl_croak(aTHX_ msg " in regex m/%.*s%s/",	    \
	    arg, (int)len, RExC_precomp, ellipses))
a416 1
 * Position is 1 indexed.
d418 5
a422 15
#ifndef RE_TRACK_PATTERN_OFFSETS
#define Set_Node_Offset_To_R(node,byte)
#define Set_Node_Offset(node,byte)
#define Set_Cur_Node_Offset
#define Set_Node_Length_To_R(node,len)
#define Set_Node_Length(node,len)
#define Set_Node_Cur_Length(node)
#define Node_Offset(n) 
#define Node_Length(n) 
#define Set_Node_Offset_Length(node,offset,len)
#define ProgLen(ri) ri->u.proglen
#define SetProgLen(ri,x) ri->u.proglen = x
#else
#define ProgLen(ri) ri->u.offsets[0]
#define SetProgLen(ri,x) ri->u.offsets[0] = x
d426 1
a426 1
		    __LINE__, (int)(node), (int)(byte)));		\
a460 44
#define Set_Node_Offset_Length(node,offset,len) STMT_START {	\
    Set_Node_Offset_To_R((node)-RExC_emit_start, (offset));	\
    Set_Node_Length_To_R((node)-RExC_emit_start, (len));	\
} STMT_END
#endif

#if PERL_ENABLE_EXPERIMENTAL_REGEX_OPTIMISATIONS
#define EXPERIMENTAL_INPLACESCAN
#endif /*RE_TRACK_PATTERN_OFFSETS*/

#define DEBUG_STUDYDATA(str,data,depth)                              \
DEBUG_OPTIMISE_MORE_r(if(data){                                      \
    PerlIO_printf(Perl_debug_log,                                    \
        "%*s" str "Pos:%"IVdf"/%"IVdf                                \
        " Flags: 0x%"UVXf" Whilem_c: %"IVdf" Lcp: %"IVdf" %s",       \
        (int)(depth)*2, "",                                          \
        (IV)((data)->pos_min),                                       \
        (IV)((data)->pos_delta),                                     \
        (UV)((data)->flags),                                         \
        (IV)((data)->whilem_c),                                      \
        (IV)((data)->last_closep ? *((data)->last_closep) : -1),     \
        is_inf ? "INF " : ""                                         \
    );                                                               \
    if ((data)->last_found)                                          \
        PerlIO_printf(Perl_debug_log,                                \
            "Last:'%s' %"IVdf":%"IVdf"/%"IVdf" %sFixed:'%s' @@ %"IVdf \
            " %sFloat: '%s' @@ %"IVdf"/%"IVdf"",                      \
            SvPVX_const((data)->last_found),                         \
            (IV)((data)->last_end),                                  \
            (IV)((data)->last_start_min),                            \
            (IV)((data)->last_start_max),                            \
            ((data)->longest &&                                      \
             (data)->longest==&((data)->longest_fixed)) ? "*" : "",  \
            SvPVX_const((data)->longest_fixed),                      \
            (IV)((data)->offset_fixed),                              \
            ((data)->longest &&                                      \
             (data)->longest==&((data)->longest_float)) ? "*" : "",  \
            SvPVX_const((data)->longest_float),                      \
            (IV)((data)->offset_float_min),                          \
            (IV)((data)->offset_float_max)                           \
        );                                                           \
    PerlIO_printf(Perl_debug_log,"\n");                              \
});

d464 1
a464 1
   Update the longest found anchored substring and the longest found
d468 1
a468 1
S_scan_commit(pTHX_ const RExC_state_t *pRExC_state, scan_data_t *data, I32 *minlenp, int is_inf)
a471 1
    GET_RE_DEBUG_FLAGS_DECL;
a481 2
	    data->minlen_fixed=minlenp;	
	    data->lookbehind_fixed=0;
d483 1
a483 1
	else { /* *data->longest == data->longest_float */
d488 1
a488 1
	    if (is_inf || (U32)data->offset_float_max > (U32)I32_MAX)
a494 2
            data->minlen_float=minlenp;
            data->lookbehind_float=0;
d500 4
a503 5
	if (SvUTF8(sv) && SvMAGICAL(sv)) {
	    MAGIC * const mg = mg_find(sv, PERL_MAGIC_utf8);
	    if (mg)
		mg->mg_len = 0;
	}
a506 1
    DEBUG_STUDYDATA("commit: ",data,0);
d511 1
a511 1
S_cl_anything(const RExC_state_t *pRExC_state, struct regnode_charclass_class *cl)
d522 1
a522 1
S_cl_is_anything(const struct regnode_charclass_class *cl)
d531 1
a531 1
    if (!ANYOF_BITMAP_TESTALLSET((const void*)cl))
d538 1
a538 1
S_cl_init(const RExC_state_t *pRExC_state, struct regnode_charclass_class *cl)
d546 1
a546 1
S_cl_init_zero(const RExC_state_t *pRExC_state, struct regnode_charclass_class *cl)
d558 1
a558 1
S_cl_and(struct regnode_charclass_class *cl,
a560 2

    assert(and_with->type == ANYOF);
d595 1
a595 1
S_cl_or(const RExC_state_t *pRExC_state, struct regnode_charclass_class *cl, const struct regnode_charclass_class *or_with)
a651 7
#define TRIE_LIST_ITEM(state,idx) (trie->states[state].trans.list)[ idx ]
#define TRIE_LIST_CUR(state)  ( TRIE_LIST_ITEM( state, 0 ).forid )
#define TRIE_LIST_LEN(state) ( TRIE_LIST_ITEM( state, 0 ).newstate )
#define TRIE_LIST_USED(idx)  ( trie->states[state].trans.list ? (TRIE_LIST_CUR( idx ) - 1) : 0 )


#ifdef DEBUGGING
d653 9
a661 8
   dump_trie(trie,widecharmap,revcharmap)
   dump_trie_interim_list(trie,widecharmap,revcharmap,next_alloc)
   dump_trie_interim_table(trie,widecharmap,revcharmap,next_alloc)

   These routines dump out a trie in a somewhat readable format.
   The _interim_ variants are used for debugging the interim
   tables that are used to generate the final compressed
   representation which is what dump_trie expects.
d663 2
a664 2
   Part of the reason for their existance is to provide a form
   of documentation as to how the different representations function.
d666 2
a667 1
*/
d669 5
a673 8
/*
  Dumps the final compressed table form of the trie to Perl_debug_log.
  Used for debugging make_trie().
*/
 
STATIC void
S_dump_trie(pTHX_ const struct _reg_trie_data *trie, HV *widecharmap,
	    AV *revcharmap, U32 depth)
d675 8
a682 25
    U32 state;
    SV *sv=sv_newmortal();
    int colwidth= widecharmap ? 6 : 4;
    GET_RE_DEBUG_FLAGS_DECL;


    PerlIO_printf( Perl_debug_log, "%*sChar : %-6s%-6s%-4s ",
        (int)depth * 2 + 2,"",
        "Match","Base","Ofs" );

    for( state = 0 ; state < trie->uniquecharcount ; state++ ) {
	SV ** const tmp = av_fetch( revcharmap, state, 0);
        if ( tmp ) {
            PerlIO_printf( Perl_debug_log, "%*s", 
                colwidth,
                pv_pretty(sv, SvPV_nolen_const(*tmp), SvCUR(*tmp), colwidth, 
	                    PL_colors[0], PL_colors[1],
	                    (SvUTF8(*tmp) ? PERL_PV_ESCAPE_UNI : 0) |
	                    PERL_PV_ESCAPE_FIRSTCHAR 
                ) 
            );
        }
    }
    PerlIO_printf( Perl_debug_log, "\n%*sState|-----------------------",
        (int)depth * 2 + 2,"");
d684 2
a685 167
    for( state = 0 ; state < trie->uniquecharcount ; state++ )
        PerlIO_printf( Perl_debug_log, "%.*s", colwidth, "--------");
    PerlIO_printf( Perl_debug_log, "\n");

    for( state = 1 ; state < trie->statecount ; state++ ) {
	const U32 base = trie->states[ state ].trans.base;

        PerlIO_printf( Perl_debug_log, "%*s#%4"UVXf"|", (int)depth * 2 + 2,"", (UV)state);

        if ( trie->states[ state ].wordnum ) {
            PerlIO_printf( Perl_debug_log, " W%4X", trie->states[ state ].wordnum );
        } else {
            PerlIO_printf( Perl_debug_log, "%6s", "" );
        }

        PerlIO_printf( Perl_debug_log, " @@%4"UVXf" ", (UV)base );

        if ( base ) {
            U32 ofs = 0;

            while( ( base + ofs  < trie->uniquecharcount ) ||
                   ( base + ofs - trie->uniquecharcount < trie->lasttrans
                     && trie->trans[ base + ofs - trie->uniquecharcount ].check != state))
                    ofs++;

            PerlIO_printf( Perl_debug_log, "+%2"UVXf"[ ", (UV)ofs);

            for ( ofs = 0 ; ofs < trie->uniquecharcount ; ofs++ ) {
                if ( ( base + ofs >= trie->uniquecharcount ) &&
                     ( base + ofs - trie->uniquecharcount < trie->lasttrans ) &&
                     trie->trans[ base + ofs - trie->uniquecharcount ].check == state )
                {
                   PerlIO_printf( Perl_debug_log, "%*"UVXf,
                    colwidth,
                    (UV)trie->trans[ base + ofs - trie->uniquecharcount ].next );
                } else {
                    PerlIO_printf( Perl_debug_log, "%*s",colwidth,"   ." );
                }
            }

            PerlIO_printf( Perl_debug_log, "]");

        }
        PerlIO_printf( Perl_debug_log, "\n" );
    }
}    
/*
  Dumps a fully constructed but uncompressed trie in list form.
  List tries normally only are used for construction when the number of 
  possible chars (trie->uniquecharcount) is very high.
  Used for debugging make_trie().
*/
STATIC void
S_dump_trie_interim_list(pTHX_ const struct _reg_trie_data *trie,
			 HV *widecharmap, AV *revcharmap, U32 next_alloc,
			 U32 depth)
{
    U32 state;
    SV *sv=sv_newmortal();
    int colwidth= widecharmap ? 6 : 4;
    GET_RE_DEBUG_FLAGS_DECL;
    /* print out the table precompression.  */
    PerlIO_printf( Perl_debug_log, "%*sState :Word | Transition Data\n%*s%s",
        (int)depth * 2 + 2,"", (int)depth * 2 + 2,"",
        "------:-----+-----------------\n" );
    
    for( state=1 ; state < next_alloc ; state ++ ) {
        U16 charid;
    
        PerlIO_printf( Perl_debug_log, "%*s %4"UVXf" :",
            (int)depth * 2 + 2,"", (UV)state  );
        if ( ! trie->states[ state ].wordnum ) {
            PerlIO_printf( Perl_debug_log, "%5s| ","");
        } else {
            PerlIO_printf( Perl_debug_log, "W%4x| ",
                trie->states[ state ].wordnum
            );
        }
        for( charid = 1 ; charid <= TRIE_LIST_USED( state ) ; charid++ ) {
	    SV ** const tmp = av_fetch( revcharmap, TRIE_LIST_ITEM(state,charid).forid, 0);
	    if ( tmp ) {
                PerlIO_printf( Perl_debug_log, "%*s:%3X=%4"UVXf" | ",
                    colwidth,
                    pv_pretty(sv, SvPV_nolen_const(*tmp), SvCUR(*tmp), colwidth, 
	                    PL_colors[0], PL_colors[1],
	                    (SvUTF8(*tmp) ? PERL_PV_ESCAPE_UNI : 0) |
	                    PERL_PV_ESCAPE_FIRSTCHAR 
                    ) ,
                    TRIE_LIST_ITEM(state,charid).forid,
                    (UV)TRIE_LIST_ITEM(state,charid).newstate
                );
                if (!(charid % 10)) 
                    PerlIO_printf(Perl_debug_log, "\n%*s| ",
                        (int)((depth * 2) + 14), "");
            }
        }
        PerlIO_printf( Perl_debug_log, "\n");
    }
}    

/*
  Dumps a fully constructed but uncompressed trie in table form.
  This is the normal DFA style state transition table, with a few 
  twists to facilitate compression later. 
  Used for debugging make_trie().
*/
STATIC void
S_dump_trie_interim_table(pTHX_ const struct _reg_trie_data *trie,
			  HV *widecharmap, AV *revcharmap, U32 next_alloc,
			  U32 depth)
{
    U32 state;
    U16 charid;
    SV *sv=sv_newmortal();
    int colwidth= widecharmap ? 6 : 4;
    GET_RE_DEBUG_FLAGS_DECL;
    
    /*
       print out the table precompression so that we can do a visual check
       that they are identical.
     */
    
    PerlIO_printf( Perl_debug_log, "%*sChar : ",(int)depth * 2 + 2,"" );

    for( charid = 0 ; charid < trie->uniquecharcount ; charid++ ) {
	SV ** const tmp = av_fetch( revcharmap, charid, 0);
        if ( tmp ) {
            PerlIO_printf( Perl_debug_log, "%*s", 
                colwidth,
                pv_pretty(sv, SvPV_nolen_const(*tmp), SvCUR(*tmp), colwidth, 
	                    PL_colors[0], PL_colors[1],
	                    (SvUTF8(*tmp) ? PERL_PV_ESCAPE_UNI : 0) |
	                    PERL_PV_ESCAPE_FIRSTCHAR 
                ) 
            );
        }
    }

    PerlIO_printf( Perl_debug_log, "\n%*sState+-",(int)depth * 2 + 2,"" );

    for( charid=0 ; charid < trie->uniquecharcount ; charid++ ) {
        PerlIO_printf( Perl_debug_log, "%.*s", colwidth,"--------");
    }

    PerlIO_printf( Perl_debug_log, "\n" );

    for( state=1 ; state < next_alloc ; state += trie->uniquecharcount ) {

        PerlIO_printf( Perl_debug_log, "%*s%4"UVXf" : ", 
            (int)depth * 2 + 2,"",
            (UV)TRIE_NODENUM( state ) );

        for( charid = 0 ; charid < trie->uniquecharcount ; charid++ ) {
            UV v=(UV)SAFE_TRIE_NODENUM( trie->trans[ state + charid ].next );
            if (v)
                PerlIO_printf( Perl_debug_log, "%*"UVXf, colwidth, v );
            else
                PerlIO_printf( Perl_debug_log, "%*s", colwidth, "." );
        }
        if ( ! trie->states[ TRIE_NODENUM( state ) ].wordnum ) {
            PerlIO_printf( Perl_debug_log, " (%4"UVXf")\n", (UV)trie->trans[ state ].check );
        } else {
            PerlIO_printf( Perl_debug_log, " (%4"UVXf") W%4X\n", (UV)trie->trans[ state ].check,
            trie->states[ TRIE_NODENUM( state ) ].wordnum );
        }
    }
}
d687 6
d695 12
a706 262
/* make_trie(startbranch,first,last,tail,word_count,flags,depth)
  startbranch: the first branch in the whole branch sequence
  first      : start branch of sequence of branch-exact nodes.
	       May be the same as startbranch
  last       : Thing following the last branch.
	       May be the same as tail.
  tail       : item following the branch sequence
  count      : words in the sequence
  flags      : currently the OP() type we will be building one of /EXACT(|F|Fl)/
  depth      : indent depth

Inplace optimizes a sequence of 2 or more Branch-Exact nodes into a TRIE node.

A trie is an N'ary tree where the branches are determined by digital
decomposition of the key. IE, at the root node you look up the 1st character and
follow that branch repeat until you find the end of the branches. Nodes can be
marked as "accepting" meaning they represent a complete word. Eg:

  /he|she|his|hers/

would convert into the following structure. Numbers represent states, letters
following numbers represent valid transitions on the letter from that state, if
the number is in square brackets it represents an accepting state, otherwise it
will be in parenthesis.

      +-h->+-e->[3]-+-r->(8)-+-s->[9]
      |    |
      |   (2)
      |    |
     (1)   +-i->(6)-+-s->[7]
      |
      +-s->(3)-+-h->(4)-+-e->[5]

      Accept Word Mapping: 3=>1 (he),5=>2 (she), 7=>3 (his), 9=>4 (hers)

This shows that when matching against the string 'hers' we will begin at state 1
read 'h' and move to state 2, read 'e' and move to state 3 which is accepting,
then read 'r' and go to state 8 followed by 's' which takes us to state 9 which
is also accepting. Thus we know that we can match both 'he' and 'hers' with a
single traverse. We store a mapping from accepting to state to which word was
matched, and then when we have multiple possibilities we try to complete the
rest of the regex in the order in which they occured in the alternation.

The only prior NFA like behaviour that would be changed by the TRIE support is
the silent ignoring of duplicate alternations which are of the form:

 / (DUPE|DUPE) X? (?{ ... }) Y /x

Thus EVAL blocks follwing a trie may be called a different number of times with
and without the optimisation. With the optimisations dupes will be silently
ignored. This inconsistant behaviour of EVAL type nodes is well established as
the following demonstrates:

 'words'=~/(word|word|word)(?{ print $1 })[xyz]/

which prints out 'word' three times, but

 'words'=~/(word|word|word)(?{ print $1 })S/

which doesnt print it out at all. This is due to other optimisations kicking in.

Example of what happens on a structural level:

The regexp /(ac|ad|ab)+/ will produce the folowing debug output:

   1: CURLYM[1] {1,32767}(18)
   5:   BRANCH(8)
   6:     EXACT <ac>(16)
   8:   BRANCH(11)
   9:     EXACT <ad>(16)
  11:   BRANCH(14)
  12:     EXACT <ab>(16)
  16:   SUCCEED(0)
  17:   NOTHING(18)
  18: END(0)

This would be optimizable with startbranch=5, first=5, last=16, tail=16
and should turn into:

   1: CURLYM[1] {1,32767}(18)
   5:   TRIE(16)
	[Words:3 Chars Stored:6 Unique Chars:4 States:5 NCP:1]
	  <ac>
	  <ad>
	  <ab>
  16:   SUCCEED(0)
  17:   NOTHING(18)
  18: END(0)

Cases where tail != last would be like /(?foo|bar)baz/:

   1: BRANCH(4)
   2:   EXACT <foo>(8)
   4: BRANCH(7)
   5:   EXACT <bar>(8)
   7: TAIL(8)
   8: EXACT <baz>(10)
  10: END(0)

which would be optimizable with startbranch=1, first=1, last=7, tail=8
and would end up looking like:

    1: TRIE(8)
      [Words:2 Chars Stored:6 Unique Chars:5 States:7 NCP:1]
	<foo>
	<bar>
   7: TAIL(8)
   8: EXACT <baz>(10)
  10: END(0)

    d = uvuni_to_utf8_flags(d, uv, 0);

is the recommended Unicode-aware way of saying

    *(d++) = uv;
*/

#define TRIE_STORE_REVCHAR                                                 \
    STMT_START {                                                           \
	if (UTF) {							   \
	    SV *zlopp = newSV(2);					   \
	    unsigned char *flrbbbbb = (unsigned char *) SvPVX(zlopp);	   \
	    unsigned const char *const kapow = uvuni_to_utf8(flrbbbbb, uvc & 0xFF); \
	    SvCUR_set(zlopp, kapow - flrbbbbb);				   \
	    SvPOK_on(zlopp);						   \
	    SvUTF8_on(zlopp);						   \
	    av_push(revcharmap, zlopp);					   \
	} else {							   \
	    char ooooff = (char)uvc;					   	   \
	    av_push(revcharmap, newSVpvn(&ooooff, 1));			   \
	}								   \
        } STMT_END

#define TRIE_READ_CHAR STMT_START {                                           \
    wordlen++;                                                                \
    if ( UTF ) {                                                              \
	if ( folder ) {                                                       \
	    if ( foldlen > 0 ) {                                              \
	       uvc = utf8n_to_uvuni( scan, UTF8_MAXLEN, &len, uniflags );     \
	       foldlen -= len;                                                \
	       scan += len;                                                   \
	       len = 0;                                                       \
	    } else {                                                          \
		uvc = utf8n_to_uvuni( (const U8*)uc, UTF8_MAXLEN, &len, uniflags);\
		uvc = to_uni_fold( uvc, foldbuf, &foldlen );                  \
		foldlen -= UNISKIP( uvc );                                    \
		scan = foldbuf + UNISKIP( uvc );                              \
	    }                                                                 \
	} else {                                                              \
	    uvc = utf8n_to_uvuni( (const U8*)uc, UTF8_MAXLEN, &len, uniflags);\
	}                                                                     \
    } else {                                                                  \
	uvc = (U32)*uc;                                                       \
	len = 1;                                                              \
    }                                                                         \
} STMT_END



#define TRIE_LIST_PUSH(state,fid,ns) STMT_START {               \
    if ( TRIE_LIST_CUR( state ) >=TRIE_LIST_LEN( state ) ) {    \
	U32 ging = TRIE_LIST_LEN( state ) *= 2;                 \
	Renew( trie->states[ state ].trans.list, ging, reg_trie_trans_le ); \
    }                                                           \
    TRIE_LIST_ITEM( state, TRIE_LIST_CUR( state ) ).forid = fid;     \
    TRIE_LIST_ITEM( state, TRIE_LIST_CUR( state ) ).newstate = ns;   \
    TRIE_LIST_CUR( state )++;                                   \
} STMT_END

#define TRIE_LIST_NEW(state) STMT_START {                       \
    Newxz( trie->states[ state ].trans.list,               \
	4, reg_trie_trans_le );                                 \
     TRIE_LIST_CUR( state ) = 1;                                \
     TRIE_LIST_LEN( state ) = 4;                                \
} STMT_END

#define TRIE_HANDLE_WORD(state) STMT_START {                    \
    U16 dupe= trie->states[ state ].wordnum;                    \
    regnode * const noper_next = regnext( noper );              \
                                                                \
    if (trie->wordlen)                                          \
        trie->wordlen[ curword ] = wordlen;                     \
    DEBUG_r({                                                   \
        /* store the word for dumping */                        \
        SV* tmp;                                                \
        if (OP(noper) != NOTHING)                               \
            tmp = newSVpvn(STRING(noper), STR_LEN(noper));      \
        else                                                    \
            tmp = newSVpvn( "", 0 );                            \
        if ( UTF ) SvUTF8_on( tmp );                            \
        av_push( trie_words, tmp );                             \
    });                                                         \
                                                                \
    curword++;                                                  \
                                                                \
    if ( noper_next < tail ) {                                  \
        if (!trie->jump)                                        \
            trie->jump = (U16 *) PerlMemShared_calloc( word_count + 1, sizeof(U16) ); \
        trie->jump[curword] = (U16)(noper_next - convert);      \
        if (!jumper)                                            \
            jumper = noper_next;                                \
        if (!nextbranch)                                        \
            nextbranch= regnext(cur);                           \
    }                                                           \
                                                                \
    if ( dupe ) {                                               \
        /* So it's a dupe. This means we need to maintain a   */\
        /* linked-list from the first to the next.            */\
        /* we only allocate the nextword buffer when there    */\
        /* a dupe, so first time we have to do the allocation */\
        if (!trie->nextword)                                    \
            trie->nextword = (U16 *)					\
		PerlMemShared_calloc( word_count + 1, sizeof(U16));	\
        while ( trie->nextword[dupe] )                          \
            dupe= trie->nextword[dupe];                         \
        trie->nextword[dupe]= curword;                          \
    } else {                                                    \
        /* we haven't inserted this word yet.                */ \
        trie->states[ state ].wordnum = curword;                \
    }                                                           \
} STMT_END


#define TRIE_TRANS_STATE(state,base,ucharcount,charid,special)		\
     ( ( base + charid >=  ucharcount					\
         && base + charid < ubound					\
         && state == trie->trans[ base - ucharcount + charid ].check	\
         && trie->trans[ base - ucharcount + charid ].next )		\
           ? trie->trans[ base - ucharcount + charid ].next		\
           : ( state==1 ? special : 0 )					\
      )

#define MADE_TRIE       1
#define MADE_JUMP_TRIE  2
#define MADE_EXACT_TRIE 4

STATIC I32
S_make_trie(pTHX_ RExC_state_t *pRExC_state, regnode *startbranch, regnode *first, regnode *last, regnode *tail, U32 word_count, U32 flags, U32 depth)
{
    dVAR;
    /* first pass, loop through and scan words */
    reg_trie_data *trie;
    HV *widecharmap = NULL;
    AV *revcharmap = newAV();
    regnode *cur;
    const U32 uniflags = UTF8_ALLOW_DEFAULT;
    STRLEN len = 0;
    UV uvc = 0;
    U16 curword = 0;
    U32 next_alloc = 0;
    regnode *jumper = NULL;
    regnode *nextbranch = NULL;
    regnode *convert = NULL;
    /* we just use folder as a flag in utf8 */
    const U8 * const folder = ( flags == EXACTF
                       ? PL_fold
                       : ( flags == EXACTFL
                           ? PL_fold_locale
                           : NULL
                         )
                     );

d708 2
a709 13
    const U32 data_slot = add_data( pRExC_state, 4, "tuuu" );
    AV *trie_words = NULL;
    /* along with revcharmap, this only used during construction but both are
     * useful during debugging so we store them in the struct when debugging.
     */
#else
    const U32 data_slot = add_data( pRExC_state, 2, "tu" );
    STRLEN trie_charcount=0;
#endif
    SV *re_trie_maxbuff;
    GET_RE_DEBUG_FLAGS_DECL;
#ifndef DEBUGGING
    PERL_UNUSED_ARG(depth);
d711 1
a711 242

    trie = (reg_trie_data *) PerlMemShared_calloc( 1, sizeof(reg_trie_data) );
    trie->refcount = 1;
    trie->startstate = 1;
    trie->wordcount = word_count;
    RExC_rxi->data->data[ data_slot ] = (void*)trie;
    trie->charmap = (U16 *) PerlMemShared_calloc( 256, sizeof(U16) );
    if (!(UTF && folder))
	trie->bitmap = (char *) PerlMemShared_calloc( ANYOF_BITMAP_SIZE, 1 );
    DEBUG_r({
        trie_words = newAV();
    });

    re_trie_maxbuff = get_sv(RE_TRIE_MAXBUF_NAME, 1);
    if (!SvIOK(re_trie_maxbuff)) {
        sv_setiv(re_trie_maxbuff, RE_TRIE_MAXBUF_INIT);
    }
    DEBUG_OPTIMISE_r({
                PerlIO_printf( Perl_debug_log,
                  "%*smake_trie start==%d, first==%d, last==%d, tail==%d depth=%d\n",
                  (int)depth * 2 + 2, "", 
                  REG_NODE_NUM(startbranch),REG_NODE_NUM(first), 
                  REG_NODE_NUM(last), REG_NODE_NUM(tail),
                  (int)depth);
    });
   
   /* Find the node we are going to overwrite */
    if ( first == startbranch && OP( last ) != BRANCH ) {
        /* whole branch chain */
        convert = first;
    } else {
        /* branch sub-chain */
        convert = NEXTOPER( first );
    }
        
    /*  -- First loop and Setup --

       We first traverse the branches and scan each word to determine if it
       contains widechars, and how many unique chars there are, this is
       important as we have to build a table with at least as many columns as we
       have unique chars.

       We use an array of integers to represent the character codes 0..255
       (trie->charmap) and we use a an HV* to store Unicode characters. We use the
       native representation of the character value as the key and IV's for the
       coded index.

       *TODO* If we keep track of how many times each character is used we can
       remap the columns so that the table compression later on is more
       efficient in terms of memory by ensuring most common value is in the
       middle and the least common are on the outside.  IMO this would be better
       than a most to least common mapping as theres a decent chance the most
       common letter will share a node with the least common, meaning the node
       will not be compressable. With a middle is most common approach the worst
       case is when we have the least common nodes twice.

     */

    for ( cur = first ; cur < last ; cur = regnext( cur ) ) {
        regnode * const noper = NEXTOPER( cur );
        const U8 *uc = (U8*)STRING( noper );
        const U8 * const e  = uc + STR_LEN( noper );
        STRLEN foldlen = 0;
        U8 foldbuf[ UTF8_MAXBYTES_CASE + 1 ];
        const U8 *scan = (U8*)NULL;
        U32 wordlen      = 0;         /* required init */
        STRLEN chars = 0;
        bool set_bit = trie->bitmap ? 1 : 0; /*store the first char in the bitmap?*/

        if (OP(noper) == NOTHING) {
            trie->minlen= 0;
            continue;
        }
        if ( set_bit ) /* bitmap only alloced when !(UTF&&Folding) */
            TRIE_BITMAP_SET(trie,*uc); /* store the raw first byte
                                          regardless of encoding */

        for ( ; uc < e ; uc += len ) {
            TRIE_CHARCOUNT(trie)++;
            TRIE_READ_CHAR;
            chars++;
            if ( uvc < 256 ) {
                if ( !trie->charmap[ uvc ] ) {
                    trie->charmap[ uvc ]=( ++trie->uniquecharcount );
                    if ( folder )
                        trie->charmap[ folder[ uvc ] ] = trie->charmap[ uvc ];
                    TRIE_STORE_REVCHAR;
                }
                if ( set_bit ) {
                    /* store the codepoint in the bitmap, and if its ascii
                       also store its folded equivelent. */
                    TRIE_BITMAP_SET(trie,uvc);

		    /* store the folded codepoint */
		    if ( folder ) TRIE_BITMAP_SET(trie,folder[ uvc ]);

		    if ( !UTF ) {
			/* store first byte of utf8 representation of
			   codepoints in the 127 < uvc < 256 range */
			if (127 < uvc && uvc < 192) {
			    TRIE_BITMAP_SET(trie,194);
			} else if (191 < uvc ) {
			    TRIE_BITMAP_SET(trie,195);
			/* && uvc < 256 -- we know uvc is < 256 already */
			}
		    }
                    set_bit = 0; /* We've done our bit :-) */
                }
            } else {
                SV** svpp;
                if ( !widecharmap )
                    widecharmap = newHV();

                svpp = hv_fetch( widecharmap, (char*)&uvc, sizeof( UV ), 1 );

                if ( !svpp )
                    Perl_croak( aTHX_ "error creating/fetching widecharmap entry for 0x%"UVXf, uvc );

                if ( !SvTRUE( *svpp ) ) {
                    sv_setiv( *svpp, ++trie->uniquecharcount );
                    TRIE_STORE_REVCHAR;
                }
            }
        }
        if( cur == first ) {
            trie->minlen=chars;
            trie->maxlen=chars;
        } else if (chars < trie->minlen) {
            trie->minlen=chars;
        } else if (chars > trie->maxlen) {
            trie->maxlen=chars;
        }

    } /* end first pass */
    DEBUG_TRIE_COMPILE_r(
        PerlIO_printf( Perl_debug_log, "%*sTRIE(%s): W:%d C:%d Uq:%d Min:%d Max:%d\n",
                (int)depth * 2 + 2,"",
                ( widecharmap ? "UTF8" : "NATIVE" ), (int)word_count,
		(int)TRIE_CHARCOUNT(trie), trie->uniquecharcount,
		(int)trie->minlen, (int)trie->maxlen )
    );
    trie->wordlen = (U32 *) PerlMemShared_calloc( word_count, sizeof(U32) );

    /*
        We now know what we are dealing with in terms of unique chars and
        string sizes so we can calculate how much memory a naive
        representation using a flat table  will take. If it's over a reasonable
        limit (as specified by ${^RE_TRIE_MAXBUF}) we use a more memory
        conservative but potentially much slower representation using an array
        of lists.

        At the end we convert both representations into the same compressed
        form that will be used in regexec.c for matching with. The latter
        is a form that cannot be used to construct with but has memory
        properties similar to the list form and access properties similar
        to the table form making it both suitable for fast searches and
        small enough that its feasable to store for the duration of a program.

        See the comment in the code where the compressed table is produced
        inplace from the flat tabe representation for an explanation of how
        the compression works.

    */


    if ( (IV)( ( TRIE_CHARCOUNT(trie) + 1 ) * trie->uniquecharcount + 1) > SvIV(re_trie_maxbuff) ) {
        /*
            Second Pass -- Array Of Lists Representation

            Each state will be represented by a list of charid:state records
            (reg_trie_trans_le) the first such element holds the CUR and LEN
            points of the allocated array. (See defines above).

            We build the initial structure using the lists, and then convert
            it into the compressed table form which allows faster lookups
            (but cant be modified once converted).
        */

        STRLEN transcount = 1;

        DEBUG_TRIE_COMPILE_MORE_r( PerlIO_printf( Perl_debug_log, 
            "%*sCompiling trie using list compiler\n",
            (int)depth * 2 + 2, ""));
	
	trie->states = (reg_trie_state *)
	    PerlMemShared_calloc( TRIE_CHARCOUNT(trie) + 2,
				  sizeof(reg_trie_state) );
        TRIE_LIST_NEW(1);
        next_alloc = 2;

        for ( cur = first ; cur < last ; cur = regnext( cur ) ) {

	    regnode * const noper = NEXTOPER( cur );
	    U8 *uc           = (U8*)STRING( noper );
	    const U8 * const e = uc + STR_LEN( noper );
	    U32 state        = 1;         /* required init */
	    U16 charid       = 0;         /* sanity init */
	    U8 *scan         = (U8*)NULL; /* sanity init */
	    STRLEN foldlen   = 0;         /* required init */
            U32 wordlen      = 0;         /* required init */
	    U8 foldbuf[ UTF8_MAXBYTES_CASE + 1 ];

            if (OP(noper) != NOTHING) {
                for ( ; uc < e ; uc += len ) {

                    TRIE_READ_CHAR;

                    if ( uvc < 256 ) {
                        charid = trie->charmap[ uvc ];
		    } else {
                        SV** const svpp = hv_fetch( widecharmap, (char*)&uvc, sizeof( UV ), 0);
                        if ( !svpp ) {
                            charid = 0;
                        } else {
                            charid=(U16)SvIV( *svpp );
                        }
		    }
                    /* charid is now 0 if we dont know the char read, or nonzero if we do */
                    if ( charid ) {

                        U16 check;
                        U32 newstate = 0;

                        charid--;
                        if ( !trie->states[ state ].trans.list ) {
                            TRIE_LIST_NEW( state );
			}
                        for ( check = 1; check <= TRIE_LIST_USED( state ); check++ ) {
                            if ( TRIE_LIST_ITEM( state, check ).forid == charid ) {
                                newstate = TRIE_LIST_ITEM( state, check ).newstate;
                                break;
                            }
                        }
                        if ( ! newstate ) {
                            newstate = next_alloc++;
                            TRIE_LIST_PUSH( state, charid, newstate );
                            transcount++;
                        }
                        state = newstate;
                    } else {
                        Perl_croak( aTHX_ "panic! In trie construction, no char mapping for %"IVdf, uvc );
		    }
d713 3
a715 96
	    }
            TRIE_HANDLE_WORD(state);

        } /* end second pass */

        /* next alloc is the NEXT state to be allocated */
        trie->statecount = next_alloc; 
        trie->states = (reg_trie_state *)
	    PerlMemShared_realloc( trie->states,
				   next_alloc
				   * sizeof(reg_trie_state) );

        /* and now dump it out before we compress it */
        DEBUG_TRIE_COMPILE_MORE_r(dump_trie_interim_list(trie, widecharmap,
							 revcharmap, next_alloc,
							 depth+1)
        );

        trie->trans = (reg_trie_trans *)
	    PerlMemShared_calloc( transcount, sizeof(reg_trie_trans) );
        {
            U32 state;
            U32 tp = 0;
            U32 zp = 0;


            for( state=1 ; state < next_alloc ; state ++ ) {
                U32 base=0;

                /*
                DEBUG_TRIE_COMPILE_MORE_r(
                    PerlIO_printf( Perl_debug_log, "tp: %d zp: %d ",tp,zp)
                );
                */

                if (trie->states[state].trans.list) {
                    U16 minid=TRIE_LIST_ITEM( state, 1).forid;
                    U16 maxid=minid;
		    U16 idx;

                    for( idx = 2 ; idx <= TRIE_LIST_USED( state ) ; idx++ ) {
			const U16 forid = TRIE_LIST_ITEM( state, idx).forid;
			if ( forid < minid ) {
			    minid=forid;
			} else if ( forid > maxid ) {
			    maxid=forid;
			}
                    }
                    if ( transcount < tp + maxid - minid + 1) {
                        transcount *= 2;
			trie->trans = (reg_trie_trans *)
			    PerlMemShared_realloc( trie->trans,
						     transcount
						     * sizeof(reg_trie_trans) );
                        Zero( trie->trans + (transcount / 2), transcount / 2 , reg_trie_trans );
                    }
                    base = trie->uniquecharcount + tp - minid;
                    if ( maxid == minid ) {
                        U32 set = 0;
                        for ( ; zp < tp ; zp++ ) {
                            if ( ! trie->trans[ zp ].next ) {
                                base = trie->uniquecharcount + zp - minid;
                                trie->trans[ zp ].next = TRIE_LIST_ITEM( state, 1).newstate;
                                trie->trans[ zp ].check = state;
                                set = 1;
                                break;
                            }
                        }
                        if ( !set ) {
                            trie->trans[ tp ].next = TRIE_LIST_ITEM( state, 1).newstate;
                            trie->trans[ tp ].check = state;
                            tp++;
                            zp = tp;
                        }
                    } else {
                        for ( idx=1; idx <= TRIE_LIST_USED( state ) ; idx++ ) {
                            const U32 tid = base -  trie->uniquecharcount + TRIE_LIST_ITEM( state, idx ).forid;
                            trie->trans[ tid ].next = TRIE_LIST_ITEM( state, idx ).newstate;
                            trie->trans[ tid ].check = state;
                        }
                        tp += ( maxid - minid + 1 );
                    }
                    Safefree(trie->states[ state ].trans.list);
                }
                /*
                DEBUG_TRIE_COMPILE_MORE_r(
                    PerlIO_printf( Perl_debug_log, " base: %d\n",base);
                );
                */
                trie->states[ state ].trans.base=base;
            }
            trie->lasttrans = tp + 1;
        }
    } else {
        /*
           Second Pass -- Flat Table Representation.
d717 7
a723 232
           we dont use the 0 slot of either trans[] or states[] so we add 1 to each.
           We know that we will need Charcount+1 trans at most to store the data
           (one row per char at worst case) So we preallocate both structures
           assuming worst case.

           We then construct the trie using only the .next slots of the entry
           structs.

           We use the .check field of the first entry of the node  temporarily to
           make compression both faster and easier by keeping track of how many non
           zero fields are in the node.

           Since trans are numbered from 1 any 0 pointer in the table is a FAIL
           transition.

           There are two terms at use here: state as a TRIE_NODEIDX() which is a
           number representing the first entry of the node, and state as a
           TRIE_NODENUM() which is the trans number. state 1 is TRIE_NODEIDX(1) and
           TRIE_NODENUM(1), state 2 is TRIE_NODEIDX(2) and TRIE_NODENUM(3) if there
           are 2 entrys per node. eg:

             A B       A B
          1. 2 4    1. 3 7
          2. 0 3    3. 0 5
          3. 0 0    5. 0 0
          4. 0 0    7. 0 0

           The table is internally in the right hand, idx form. However as we also
           have to deal with the states array which is indexed by nodenum we have to
           use TRIE_NODENUM() to convert.

        */
        DEBUG_TRIE_COMPILE_MORE_r( PerlIO_printf( Perl_debug_log, 
            "%*sCompiling trie using table compiler\n",
            (int)depth * 2 + 2, ""));

	trie->trans = (reg_trie_trans *)
	    PerlMemShared_calloc( ( TRIE_CHARCOUNT(trie) + 1 )
				  * trie->uniquecharcount + 1,
				  sizeof(reg_trie_trans) );
        trie->states = (reg_trie_state *)
	    PerlMemShared_calloc( TRIE_CHARCOUNT(trie) + 2,
				  sizeof(reg_trie_state) );
        next_alloc = trie->uniquecharcount + 1;


        for ( cur = first ; cur < last ; cur = regnext( cur ) ) {

	    regnode * const noper   = NEXTOPER( cur );
	    const U8 *uc     = (U8*)STRING( noper );
	    const U8 * const e = uc + STR_LEN( noper );

            U32 state        = 1;         /* required init */

            U16 charid       = 0;         /* sanity init */
            U32 accept_state = 0;         /* sanity init */
            U8 *scan         = (U8*)NULL; /* sanity init */

            STRLEN foldlen   = 0;         /* required init */
            U32 wordlen      = 0;         /* required init */
            U8 foldbuf[ UTF8_MAXBYTES_CASE + 1 ];

            if ( OP(noper) != NOTHING ) {
                for ( ; uc < e ; uc += len ) {

                    TRIE_READ_CHAR;

                    if ( uvc < 256 ) {
                        charid = trie->charmap[ uvc ];
                    } else {
                        SV* const * const svpp = hv_fetch( widecharmap, (char*)&uvc, sizeof( UV ), 0);
                        charid = svpp ? (U16)SvIV(*svpp) : 0;
                    }
                    if ( charid ) {
                        charid--;
                        if ( !trie->trans[ state + charid ].next ) {
                            trie->trans[ state + charid ].next = next_alloc;
                            trie->trans[ state ].check++;
                            next_alloc += trie->uniquecharcount;
                        }
                        state = trie->trans[ state + charid ].next;
                    } else {
                        Perl_croak( aTHX_ "panic! In trie construction, no char mapping for %"IVdf, uvc );
                    }
                    /* charid is now 0 if we dont know the char read, or nonzero if we do */
                }
            }
            accept_state = TRIE_NODENUM( state );
            TRIE_HANDLE_WORD(accept_state);

        } /* end second pass */

        /* and now dump it out before we compress it */
        DEBUG_TRIE_COMPILE_MORE_r(dump_trie_interim_table(trie, widecharmap,
							  revcharmap,
							  next_alloc, depth+1));

        {
        /*
           * Inplace compress the table.*

           For sparse data sets the table constructed by the trie algorithm will
           be mostly 0/FAIL transitions or to put it another way mostly empty.
           (Note that leaf nodes will not contain any transitions.)

           This algorithm compresses the tables by eliminating most such
           transitions, at the cost of a modest bit of extra work during lookup:

           - Each states[] entry contains a .base field which indicates the
           index in the state[] array wheres its transition data is stored.

           - If .base is 0 there are no  valid transitions from that node.

           - If .base is nonzero then charid is added to it to find an entry in
           the trans array.

           -If trans[states[state].base+charid].check!=state then the
           transition is taken to be a 0/Fail transition. Thus if there are fail
           transitions at the front of the node then the .base offset will point
           somewhere inside the previous nodes data (or maybe even into a node
           even earlier), but the .check field determines if the transition is
           valid.

           XXX - wrong maybe?
           The following process inplace converts the table to the compressed
           table: We first do not compress the root node 1,and mark its all its
           .check pointers as 1 and set its .base pointer as 1 as well. This
           allows to do a DFA construction from the compressed table later, and
           ensures that any .base pointers we calculate later are greater than
           0.

           - We set 'pos' to indicate the first entry of the second node.

           - We then iterate over the columns of the node, finding the first and
           last used entry at l and m. We then copy l..m into pos..(pos+m-l),
           and set the .check pointers accordingly, and advance pos
           appropriately and repreat for the next node. Note that when we copy
           the next pointers we have to convert them from the original
           NODEIDX form to NODENUM form as the former is not valid post
           compression.

           - If a node has no transitions used we mark its base as 0 and do not
           advance the pos pointer.

           - If a node only has one transition we use a second pointer into the
           structure to fill in allocated fail transitions from other states.
           This pointer is independent of the main pointer and scans forward
           looking for null transitions that are allocated to a state. When it
           finds one it writes the single transition into the "hole".  If the
           pointer doesnt find one the single transition is appended as normal.

           - Once compressed we can Renew/realloc the structures to release the
           excess space.

           See "Table-Compression Methods" in sec 3.9 of the Red Dragon,
           specifically Fig 3.47 and the associated pseudocode.

           demq
        */
        const U32 laststate = TRIE_NODENUM( next_alloc );
	U32 state, charid;
        U32 pos = 0, zp=0;
        trie->statecount = laststate;

        for ( state = 1 ; state < laststate ; state++ ) {
            U8 flag = 0;
	    const U32 stateidx = TRIE_NODEIDX( state );
	    const U32 o_used = trie->trans[ stateidx ].check;
	    U32 used = trie->trans[ stateidx ].check;
            trie->trans[ stateidx ].check = 0;

            for ( charid = 0 ; used && charid < trie->uniquecharcount ; charid++ ) {
                if ( flag || trie->trans[ stateidx + charid ].next ) {
                    if ( trie->trans[ stateidx + charid ].next ) {
                        if (o_used == 1) {
                            for ( ; zp < pos ; zp++ ) {
                                if ( ! trie->trans[ zp ].next ) {
                                    break;
                                }
                            }
                            trie->states[ state ].trans.base = zp + trie->uniquecharcount - charid ;
                            trie->trans[ zp ].next = SAFE_TRIE_NODENUM( trie->trans[ stateidx + charid ].next );
                            trie->trans[ zp ].check = state;
                            if ( ++zp > pos ) pos = zp;
                            break;
                        }
                        used--;
                    }
                    if ( !flag ) {
                        flag = 1;
                        trie->states[ state ].trans.base = pos + trie->uniquecharcount - charid ;
                    }
                    trie->trans[ pos ].next = SAFE_TRIE_NODENUM( trie->trans[ stateidx + charid ].next );
                    trie->trans[ pos ].check = state;
                    pos++;
                }
            }
        }
        trie->lasttrans = pos + 1;
        trie->states = (reg_trie_state *)
	    PerlMemShared_realloc( trie->states, laststate
				   * sizeof(reg_trie_state) );
        DEBUG_TRIE_COMPILE_MORE_r(
                PerlIO_printf( Perl_debug_log,
		    "%*sAlloc: %d Orig: %"IVdf" elements, Final:%"IVdf". Savings of %%%5.2f\n",
		    (int)depth * 2 + 2,"",
                    (int)( ( TRIE_CHARCOUNT(trie) + 1 ) * trie->uniquecharcount + 1 ),
		    (IV)next_alloc,
		    (IV)pos,
                    ( ( next_alloc - pos ) * 100 ) / (double)next_alloc );
            );

        } /* end table compress */
    }
    DEBUG_TRIE_COMPILE_MORE_r(
            PerlIO_printf(Perl_debug_log, "%*sStatecount:%"UVxf" Lasttrans:%"UVxf"\n",
                (int)depth * 2 + 2, "",
                (UV)trie->statecount,
                (UV)trie->lasttrans)
    );
    /* resize the trans array to remove unused space */
    trie->trans = (reg_trie_trans *)
	PerlMemShared_realloc( trie->trans, trie->lasttrans
			       * sizeof(reg_trie_trans) );

    /* and now dump out the compressed format */
    DEBUG_TRIE_COMPILE_r(dump_trie(trie, widecharmap, revcharmap, depth+1));

    {   /* Modify the program and insert the new TRIE node*/ 
        U8 nodetype =(U8)(flags & 0xFF);
        char *str=NULL;
        
d725 1
a725 120
        regnode *optimize = NULL;
#ifdef RE_TRACK_PATTERN_OFFSETS

        U32 mjd_offset = 0;
        U32 mjd_nodelen = 0;
#endif /* RE_TRACK_PATTERN_OFFSETS */
#endif /* DEBUGGING */
        /*
           This means we convert either the first branch or the first Exact,
           depending on whether the thing following (in 'last') is a branch
           or not and whther first is the startbranch (ie is it a sub part of
           the alternation or is it the whole thing.)
           Assuming its a sub part we conver the EXACT otherwise we convert
           the whole branch sequence, including the first.
         */
        /* Find the node we are going to overwrite */
        if ( first != startbranch || OP( last ) == BRANCH ) {
            /* branch sub-chain */
            NEXT_OFF( first ) = (U16)(last - first);
#ifdef RE_TRACK_PATTERN_OFFSETS
            DEBUG_r({
                mjd_offset= Node_Offset((convert));
                mjd_nodelen= Node_Length((convert));
            });
#endif
            /* whole branch chain */
        }
#ifdef RE_TRACK_PATTERN_OFFSETS
        else {
            DEBUG_r({
                const  regnode *nop = NEXTOPER( convert );
                mjd_offset= Node_Offset((nop));
                mjd_nodelen= Node_Length((nop));
            });
        }
        DEBUG_OPTIMISE_r(
            PerlIO_printf(Perl_debug_log, "%*sMJD offset:%"UVuf" MJD length:%"UVuf"\n",
                (int)depth * 2 + 2, "",
                (UV)mjd_offset, (UV)mjd_nodelen)
        );
#endif
        /* But first we check to see if there is a common prefix we can 
           split out as an EXACT and put in front of the TRIE node.  */
        trie->startstate= 1;
        if ( trie->bitmap && !widecharmap && !trie->jump  ) {
            U32 state;
            for ( state = 1 ; state < trie->statecount-1 ; state++ ) {
                U32 ofs = 0;
                I32 idx = -1;
                U32 count = 0;
                const U32 base = trie->states[ state ].trans.base;

                if ( trie->states[state].wordnum )
                        count = 1;

                for ( ofs = 0 ; ofs < trie->uniquecharcount ; ofs++ ) {
                    if ( ( base + ofs >= trie->uniquecharcount ) &&
                         ( base + ofs - trie->uniquecharcount < trie->lasttrans ) &&
                         trie->trans[ base + ofs - trie->uniquecharcount ].check == state )
                    {
                        if ( ++count > 1 ) {
                            SV **tmp = av_fetch( revcharmap, ofs, 0);
			    const U8 *ch = (U8*)SvPV_nolen_const( *tmp );
                            if ( state == 1 ) break;
                            if ( count == 2 ) {
                                Zero(trie->bitmap, ANYOF_BITMAP_SIZE, char);
                                DEBUG_OPTIMISE_r(
                                    PerlIO_printf(Perl_debug_log,
					"%*sNew Start State=%"UVuf" Class: [",
                                        (int)depth * 2 + 2, "",
                                        (UV)state));
				if (idx >= 0) {
				    SV ** const tmp = av_fetch( revcharmap, idx, 0);
				    const U8 * const ch = (U8*)SvPV_nolen_const( *tmp );

                                    TRIE_BITMAP_SET(trie,*ch);
                                    if ( folder )
                                        TRIE_BITMAP_SET(trie, folder[ *ch ]);
                                    DEBUG_OPTIMISE_r(
                                        PerlIO_printf(Perl_debug_log, (char*)ch)
                                    );
				}
			    }
			    TRIE_BITMAP_SET(trie,*ch);
			    if ( folder )
				TRIE_BITMAP_SET(trie,folder[ *ch ]);
			    DEBUG_OPTIMISE_r(PerlIO_printf( Perl_debug_log,"%s", ch));
			}
                        idx = ofs;
		    }
                }
                if ( count == 1 ) {
                    SV **tmp = av_fetch( revcharmap, idx, 0);
                    STRLEN len;
                    char *ch = SvPV( *tmp, len );
                    DEBUG_OPTIMISE_r({
                        SV *sv=sv_newmortal();
                        PerlIO_printf( Perl_debug_log,
			    "%*sPrefix State: %"UVuf" Idx:%"UVuf" Char='%s'\n",
                            (int)depth * 2 + 2, "",
                            (UV)state, (UV)idx, 
                            pv_pretty(sv, SvPV_nolen_const(*tmp), SvCUR(*tmp), 6, 
	                        PL_colors[0], PL_colors[1],
	                        (SvUTF8(*tmp) ? PERL_PV_ESCAPE_UNI : 0) |
	                        PERL_PV_ESCAPE_FIRSTCHAR 
                            )
                        );
                    });
                    if ( state==1 ) {
                        OP( convert ) = nodetype;
                        str=STRING(convert);
                        STR_LEN(convert)=0;
                    }
                    STR_LEN(convert) += len;
                    while (len--)
                        *str++ = *ch++;
		} else {
#ifdef DEBUGGING	    
		    if (state>1)
			DEBUG_OPTIMISE_r(PerlIO_printf( Perl_debug_log,"]\n"));
d727 1
a727 1
		    break;
a729 147
            if (str) {
                regnode *n = convert+NODE_SZ_STR(convert);
                NEXT_OFF(convert) = NODE_SZ_STR(convert);
                trie->startstate = state;
                trie->minlen -= (state - 1);
                trie->maxlen -= (state - 1);
#ifdef DEBUGGING
               /* At least the UNICOS C compiler choked on this
                * being argument to DEBUG_r(), so let's just have
                * it right here. */
               if (
#ifdef PERL_EXT_RE_BUILD
                   1
#else
                   DEBUG_r_TEST
#endif
                   ) {
                   regnode *fix = convert;
                   U32 word = trie->wordcount;
                   mjd_nodelen++;
                   Set_Node_Offset_Length(convert, mjd_offset, state - 1);
                   while( ++fix < n ) {
                       Set_Node_Offset_Length(fix, 0, 0);
                   }
                   while (word--) {
                       SV ** const tmp = av_fetch( trie_words, word, 0 );
                       if (tmp) {
                           if ( STR_LEN(convert) <= SvCUR(*tmp) )
                               sv_chop(*tmp, SvPV_nolen(*tmp) + STR_LEN(convert));
                           else
                               sv_chop(*tmp, SvPV_nolen(*tmp) + SvCUR(*tmp));
                       }
                   }
               }
#endif
                if (trie->maxlen) {
                    convert = n;
		} else {
                    NEXT_OFF(convert) = (U16)(tail - convert);
                    DEBUG_r(optimize= n);
                }
            }
        }
        if (!jumper) 
            jumper = last; 
        if ( trie->maxlen ) {
	    NEXT_OFF( convert ) = (U16)(tail - convert);
	    ARG_SET( convert, data_slot );
	    /* Store the offset to the first unabsorbed branch in 
	       jump[0], which is otherwise unused by the jump logic. 
	       We use this when dumping a trie and during optimisation. */
	    if (trie->jump) 
	        trie->jump[0] = (U16)(nextbranch - convert);
            
            /* XXXX */
            if ( !trie->states[trie->startstate].wordnum && trie->bitmap && 
                 ( (char *)jumper - (char *)convert) >= (int)sizeof(struct regnode_charclass) )
            {
                OP( convert ) = TRIEC;
                Copy(trie->bitmap, ((struct regnode_charclass *)convert)->bitmap, ANYOF_BITMAP_SIZE, char);
                PerlMemShared_free(trie->bitmap);
                trie->bitmap= NULL;
            } else 
                OP( convert ) = TRIE;

            /* store the type in the flags */
            convert->flags = nodetype;
            DEBUG_r({
            optimize = convert 
                      + NODE_STEP_REGNODE 
                      + regarglen[ OP( convert ) ];
            });
            /* XXX We really should free up the resource in trie now, 
                   as we won't use them - (which resources?) dmq */
        }
        /* needed for dumping*/
        DEBUG_r(if (optimize) {
            regnode *opt = convert;

            while ( ++opt < optimize) {
                Set_Node_Offset_Length(opt,0,0);
            }
            /* 
                Try to clean up some of the debris left after the 
                optimisation.
             */
            while( optimize < jumper ) {
                mjd_nodelen += Node_Length((optimize));
                OP( optimize ) = OPTIMIZED;
                Set_Node_Offset_Length(optimize,0,0);
                optimize++;
            }
            Set_Node_Offset_Length(convert,mjd_offset,mjd_nodelen);
        });
    } /* end node insert */
    RExC_rxi->data->data[ data_slot + 1 ] = (void*)widecharmap;
#ifdef DEBUGGING
    RExC_rxi->data->data[ data_slot + TRIE_WORDS_OFFSET ] = (void*)trie_words;
    RExC_rxi->data->data[ data_slot + 3 ] = (void*)revcharmap;
#else
    SvREFCNT_dec(revcharmap);
#endif
    return trie->jump 
           ? MADE_JUMP_TRIE 
           : trie->startstate>1 
             ? MADE_EXACT_TRIE 
             : MADE_TRIE;
}

STATIC void
S_make_trie_failtable(pTHX_ RExC_state_t *pRExC_state, regnode *source,  regnode *stclass, U32 depth)
{
/* The Trie is constructed and compressed now so we can build a fail array now if its needed

   This is basically the Aho-Corasick algorithm. Its from exercise 3.31 and 3.32 in the
   "Red Dragon" -- Compilers, principles, techniques, and tools. Aho, Sethi, Ullman 1985/88
   ISBN 0-201-10088-6

   We find the fail state for each state in the trie, this state is the longest proper
   suffix of the current states 'word' that is also a proper prefix of another word in our
   trie. State 1 represents the word '' and is the thus the default fail state. This allows
   the DFA not to have to restart after its tried and failed a word at a given point, it
   simply continues as though it had been matching the other word in the first place.
   Consider
      'abcdgu'=~/abcdefg|cdgu/
   When we get to 'd' we are still matching the first word, we would encounter 'g' which would
   fail, which would bring use to the state representing 'd' in the second word where we would
   try 'g' and succeed, prodceding to match 'cdgu'.
 */
 /* add a fail transition */
    const U32 trie_offset = ARG(source);
    reg_trie_data *trie=(reg_trie_data *)RExC_rxi->data->data[trie_offset];
    U32 *q;
    const U32 ucharcount = trie->uniquecharcount;
    const U32 numstates = trie->statecount;
    const U32 ubound = trie->lasttrans + ucharcount;
    U32 q_read = 0;
    U32 q_write = 0;
    U32 charid;
    U32 base = trie->states[ 1 ].trans.base;
    U32 *fail;
    reg_ac_data *aho;
    const U32 data_slot = add_data( pRExC_state, 1, "T" );
    GET_RE_DEBUG_FLAGS_DECL;
#ifndef DEBUGGING
    PERL_UNUSED_ARG(depth);
#endif
d731 3
d735 2
a736 66
    ARG_SET( stclass, data_slot );
    aho = (reg_ac_data *) PerlMemShared_calloc( 1, sizeof(reg_ac_data) );
    RExC_rxi->data->data[ data_slot ] = (void*)aho;
    aho->trie=trie_offset;
    aho->states=(reg_trie_state *)PerlMemShared_malloc( numstates * sizeof(reg_trie_state) );
    Copy( trie->states, aho->states, numstates, reg_trie_state );
    Newxz( q, numstates, U32);
    aho->fail = (U32 *) PerlMemShared_calloc( numstates, sizeof(U32) );
    aho->refcount = 1;
    fail = aho->fail;
    /* initialize fail[0..1] to be 1 so that we always have
       a valid final fail state */
    fail[ 0 ] = fail[ 1 ] = 1;

    for ( charid = 0; charid < ucharcount ; charid++ ) {
	const U32 newstate = TRIE_TRANS_STATE( 1, base, ucharcount, charid, 0 );
	if ( newstate ) {
            q[ q_write ] = newstate;
            /* set to point at the root */
            fail[ q[ q_write++ ] ]=1;
        }
    }
    while ( q_read < q_write) {
	const U32 cur = q[ q_read++ % numstates ];
        base = trie->states[ cur ].trans.base;

        for ( charid = 0 ; charid < ucharcount ; charid++ ) {
	    const U32 ch_state = TRIE_TRANS_STATE( cur, base, ucharcount, charid, 1 );
	    if (ch_state) {
                U32 fail_state = cur;
                U32 fail_base;
                do {
                    fail_state = fail[ fail_state ];
                    fail_base = aho->states[ fail_state ].trans.base;
                } while ( !TRIE_TRANS_STATE( fail_state, fail_base, ucharcount, charid, 1 ) );

                fail_state = TRIE_TRANS_STATE( fail_state, fail_base, ucharcount, charid, 1 );
                fail[ ch_state ] = fail_state;
                if ( !aho->states[ ch_state ].wordnum && aho->states[ fail_state ].wordnum )
                {
                        aho->states[ ch_state ].wordnum =  aho->states[ fail_state ].wordnum;
                }
                q[ q_write++ % numstates] = ch_state;
            }
        }
    }
    /* restore fail[0..1] to 0 so that we "fall out" of the AC loop
       when we fail in state 1, this allows us to use the
       charclass scan to find a valid start char. This is based on the principle
       that theres a good chance the string being searched contains lots of stuff
       that cant be a start char.
     */
    fail[ 0 ] = fail[ 1 ] = 0;
    DEBUG_TRIE_COMPILE_r({
        PerlIO_printf(Perl_debug_log,
		      "%*sStclass Failtable (%"UVuf" states): 0", 
		      (int)(depth * 2), "", (UV)numstates
        );
        for( q_read=1; q_read<numstates; q_read++ ) {
            PerlIO_printf(Perl_debug_log, ", %"UVuf, (UV)fail[q_read]);
        }
        PerlIO_printf(Perl_debug_log, "\n");
    });
    Safefree(q);
    /*RExC_seen |= REG_SEEN_TRIEDFA;*/
}
d738 1
d740 1
a740 10
/*
 * There are strange code-generation bugs caused on sparc64 by gcc-2.95.2.
 * These need to be revisited when a newer toolchain becomes available.
 */
#if defined(__sparc64__) && defined(__GNUC__)
#   if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 96)
#       undef  SPARC64_GCC_WORKAROUND
#       define SPARC64_GCC_WORKAROUND 1
#   endif
#endif
d742 2
a743 9
#define DEBUG_PEEP(str,scan,depth) \
    DEBUG_OPTIMISE_r({if (scan){ \
       SV * const mysv=sv_newmortal(); \
       regnode *Next = regnext(scan); \
       regprop(RExC_rx, mysv, scan); \
       PerlIO_printf(Perl_debug_log, "%*s" str ">%3d: %s (%d)\n", \
       (int)depth*2, "", REG_NODE_NUM(scan), SvPV_nolen_const(mysv),\
       Next ? (REG_NODE_NUM(Next)) : 0 ); \
   }});
d745 5
d751 3
d755 3
d759 14
a773 12
#define JOIN_EXACT(scan,min,flags) \
    if (PL_regkind[OP(scan)] == EXACT) \
        join_exact(pRExC_state,(scan),(min),(flags),NULL,depth+1)

STATIC U32
S_join_exact(pTHX_ RExC_state_t *pRExC_state, regnode *scan, I32 *min, U32 flags,regnode *val, U32 depth) {
    /* Merge several consecutive EXACTish nodes into one. */
    regnode *n = regnext(scan);
    U32 stringok = 1;
    regnode *next = scan + NODE_SZ_STR(scan);
    U32 merged = 0;
    U32 stopnow = 0;
d775 9
a783 8
    regnode *stop = scan;
    GET_RE_DEBUG_FLAGS_DECL;
#else
    PERL_UNUSED_ARG(depth);
#endif
#ifndef EXPERIMENTAL_INPLACESCAN
    PERL_UNUSED_ARG(flags);
    PERL_UNUSED_ARG(val);
a784 52
    DEBUG_PEEP("join",scan,depth);
    
    /* Skip NOTHING, merge EXACT*. */
    while (n &&
           ( PL_regkind[OP(n)] == NOTHING ||
             (stringok && (OP(n) == OP(scan))))
           && NEXT_OFF(n)
           && NEXT_OFF(scan) + NEXT_OFF(n) < I16_MAX) {
        
        if (OP(n) == TAIL || n > next)
            stringok = 0;
        if (PL_regkind[OP(n)] == NOTHING) {
            DEBUG_PEEP("skip:",n,depth);
            NEXT_OFF(scan) += NEXT_OFF(n);
            next = n + NODE_STEP_REGNODE;
#ifdef DEBUGGING
            if (stringok)
                stop = n;
#endif
            n = regnext(n);
        }
        else if (stringok) {
            const unsigned int oldl = STR_LEN(scan);
            regnode * const nnext = regnext(n);
            
            DEBUG_PEEP("merg",n,depth);
            
            merged++;
            if (oldl + STR_LEN(n) > U8_MAX)
                break;
            NEXT_OFF(scan) += NEXT_OFF(n);
            STR_LEN(scan) += STR_LEN(n);
            next = n + NODE_SZ_STR(n);
            /* Now we can overwrite *n : */
            Move(STRING(n), STRING(scan) + oldl, STR_LEN(n), char);
#ifdef DEBUGGING
            stop = next - 1;
#endif
            n = nnext;
            if (stopnow) break;
        }

#ifdef EXPERIMENTAL_INPLACESCAN
	if (flags && !NEXT_OFF(n)) {
	    DEBUG_PEEP("atch", val, depth);
	    if (reg_off_by_arg[OP(n)]) {
		ARG_SET(n, val - n);
	    }
	    else {
		NEXT_OFF(n) = val - n;
	    }
	    stopnow = 1;
d786 2
a787 175
#endif
    }
    
    if (UTF && ( OP(scan) == EXACTF ) && ( STR_LEN(scan) >= 6 ) ) {
    /*
    Two problematic code points in Unicode casefolding of EXACT nodes:
    
    U+0390 - GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS
    U+03B0 - GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS
    
    which casefold to
    
    Unicode                      UTF-8
    
    U+03B9 U+0308 U+0301         0xCE 0xB9 0xCC 0x88 0xCC 0x81
    U+03C5 U+0308 U+0301         0xCF 0x85 0xCC 0x88 0xCC 0x81
    
    This means that in case-insensitive matching (or "loose matching",
    as Unicode calls it), an EXACTF of length six (the UTF-8 encoded byte
    length of the above casefolded versions) can match a target string
    of length two (the byte length of UTF-8 encoded U+0390 or U+03B0).
    This would rather mess up the minimum length computation.
    
    What we'll do is to look for the tail four bytes, and then peek
    at the preceding two bytes to see whether we need to decrease
    the minimum length by four (six minus two).
    
    Thanks to the design of UTF-8, there cannot be false matches:
    A sequence of valid UTF-8 bytes cannot be a subsequence of
    another valid sequence of UTF-8 bytes.
    
    */
         char * const s0 = STRING(scan), *s, *t;
         char * const s1 = s0 + STR_LEN(scan) - 1;
         char * const s2 = s1 - 4;
#ifdef EBCDIC /* RD tunifold greek 0390 and 03B0 */
	 const char t0[] = "\xaf\x49\xaf\x42";
#else
         const char t0[] = "\xcc\x88\xcc\x81";
#endif
         const char * const t1 = t0 + 3;
    
         for (s = s0 + 2;
              s < s2 && (t = ninstr(s, s1, t0, t1));
              s = t + 4) {
#ifdef EBCDIC
	      if (((U8)t[-1] == 0x68 && (U8)t[-2] == 0xB4) ||
		  ((U8)t[-1] == 0x46 && (U8)t[-2] == 0xB5))
#else
              if (((U8)t[-1] == 0xB9 && (U8)t[-2] == 0xCE) ||
                  ((U8)t[-1] == 0x85 && (U8)t[-2] == 0xCF))
#endif
                   *min -= 4;
         }
    }
    
#ifdef DEBUGGING
    /* Allow dumping */
    n = scan + NODE_SZ_STR(scan);
    while (n <= stop) {
        if (PL_regkind[OP(n)] != NOTHING || OP(n) == NOTHING) {
            OP(n) = OPTIMIZED;
            NEXT_OFF(n) = 0;
        }
        n++;
    }
#endif
    DEBUG_OPTIMISE_r(if (merged){DEBUG_PEEP("finl",scan,depth)});
    return stopnow;
}

/* REx optimizer.  Converts nodes into quickier variants "in place".
   Finds fixed substrings.  */

/* Stops at toplevel WHILEM as well as at "last". At end *scanp is set
   to the position after last scanned or to NULL. */

#define INIT_AND_WITHP \
    assert(!and_withp); \
    Newx(and_withp,1,struct regnode_charclass_class); \
    SAVEFREEPV(and_withp)

/* this is a chain of data about sub patterns we are processing that
   need to be handled seperately/specially in study_chunk. Its so
   we can simulate recursion without losing state.  */
struct scan_frame;
typedef struct scan_frame {
    regnode *last;  /* last node to process in this frame */
    regnode *next;  /* next node to process when last is reached */
    struct scan_frame *prev; /*previous frame*/
    I32 stop; /* what stopparen do we use */
} scan_frame;


#define SCAN_COMMIT(s, data, m) scan_commit(s, data, m, is_inf)

#define CASE_SYNST_FNC(nAmE)                                       \
case nAmE:                                                         \
    if (flags & SCF_DO_STCLASS_AND) {                              \
	    for (value = 0; value < 256; value++)                  \
		if (!is_ ## nAmE ## _cp(value))                       \
		    ANYOF_BITMAP_CLEAR(data->start_class, value);  \
    }                                                              \
    else {                                                         \
	    for (value = 0; value < 256; value++)                  \
		if (is_ ## nAmE ## _cp(value))                        \
		    ANYOF_BITMAP_SET(data->start_class, value);	   \
    }                                                              \
    break;                                                         \
case N ## nAmE:                                                    \
    if (flags & SCF_DO_STCLASS_AND) {                              \
	    for (value = 0; value < 256; value++)                   \
		if (is_ ## nAmE ## _cp(value))                         \
		    ANYOF_BITMAP_CLEAR(data->start_class, value);   \
    }                                                               \
    else {                                                          \
	    for (value = 0; value < 256; value++)                   \
		if (!is_ ## nAmE ## _cp(value))                        \
		    ANYOF_BITMAP_SET(data->start_class, value);	    \
    }                                                               \
    break



STATIC I32
S_study_chunk(pTHX_ RExC_state_t *pRExC_state, regnode **scanp,
                        I32 *minlenp, I32 *deltap,
			regnode *last,
			scan_data_t *data,
			I32 stopparen,
			U8* recursed,
			struct regnode_charclass_class *and_withp,
			U32 flags, U32 depth)
			/* scanp: Start here (read-write). */
			/* deltap: Write maxlen-minlen here. */
			/* last: Stop before this one. */
			/* data: string data about the pattern */
			/* stopparen: treat close N as END */
			/* recursed: which subroutines have we recursed into */
			/* and_withp: Valid if flags & SCF_DO_STCLASS_OR */
{
    dVAR;
    I32 min = 0, pars = 0, code;
    regnode *scan = *scanp, *next;
    I32 delta = 0;
    int is_inf = (flags & SCF_DO_SUBSTR) && (data->flags & SF_IS_INF);
    int is_inf_internal = 0;		/* The studied chunk is infinite */
    I32 is_par = OP(scan) == OPEN ? ARG(scan) : 0;
    scan_data_t data_fake;
    SV *re_trie_maxbuff = NULL;
    regnode *first_non_open = scan;
    I32 stopmin = I32_MAX;
    scan_frame *frame = NULL;

    GET_RE_DEBUG_FLAGS_DECL;

#ifdef DEBUGGING
    StructCopy(&zero_scan_data, &data_fake, scan_data_t);
#endif

    if ( depth == 0 ) {
        while (first_non_open && OP(first_non_open) == OPEN)
            first_non_open=regnext(first_non_open);
    }


  fake_study_recurse:
    while ( scan && OP(scan) != END && scan < last ){
	/* Peephole optimizer: */
	DEBUG_STUDYDATA("Peep:", data,depth);
	DEBUG_PEEP("Peep",scan,depth);
        JOIN_EXACT(scan,&min,0);

	/* Follow the next-chain of the current node and optimize
	   away all the NOTHINGs from it.  */
d799 1
a799 1
		   && ((PL_regkind[OP(n)] == NOTHING && (noff = NEXT_OFF(n)))
a807 3



d811 1
a811 1
		   || OP(scan) == IFTHEN) {
a813 1
	    /* demq: the op(next)==code check is to see if we have "branch-branch" AFAICT */
d815 1
a815 4
	    if (OP(next) == code || code == IFTHEN) {
	        /* NOTE - There is similar code to this block below for handling
	           TRIE nodes on a re-study.  If you change stuff here check there
	           too. */
a817 1
		regnode * const startbranch=scan;
d819 2
a820 2
		if (flags & SCF_DO_SUBSTR)
		    SCAN_COMMIT(pRExC_state, data, minlenp); /* Cannot merge strings after this. */
a822 1

d829 1
a829 1
		    if (data) {
a834 2

		    data_fake.pos_delta = delta;
d843 1
a843 1
		    }
a845 1

d847 2
a848 3
		    minnext = study_chunk(pRExC_state, &scan, minlenp, &deltanext,
					  next, &data_fake,
					  stopparen, recursed, NULL, f,depth+1);
d858 3
a860 10
	            if (data_fake.flags & SCF_SEEN_ACCEPT) {
	                if ( stopmin > minnext) 
	                    stopmin = min + min1;
	                flags &= ~SCF_DO_SUBSTR;
	                if (data)
	                    data->flags |= SCF_SEEN_ACCEPT;
	            }
		    if (data) {
			if (data_fake.flags & SF_HAS_EVAL)
			    data->flags |= SF_HAS_EVAL;
a861 1
		    }
d864 2
d880 1
a880 1
			cl_and(data->start_class, and_withp);
d892 1
a892 2
			INIT_AND_WITHP;
			StructCopy(data->start_class, and_withp,
a901 204
                if (PERL_ENABLE_TRIE_OPTIMISATION && OP( startbranch ) == BRANCH ) {
		/* demq.

		   Assuming this was/is a branch we are dealing with: 'scan' now
		   points at the item that follows the branch sequence, whatever
		   it is. We now start at the beginning of the sequence and look
		   for subsequences of

		   BRANCH->EXACT=>x1
		   BRANCH->EXACT=>x2
		   tail

		   which would be constructed from a pattern like /A|LIST|OF|WORDS/

		   If we can find such a subseqence we need to turn the first
		   element into a trie and then add the subsequent branch exact
		   strings to the trie.

		   We have two cases

		     1. patterns where the whole set of branch can be converted. 

		     2. patterns where only a subset can be converted.

		   In case 1 we can replace the whole set with a single regop
		   for the trie. In case 2 we need to keep the start and end
		   branchs so

		     'BRANCH EXACT; BRANCH EXACT; BRANCH X'
		     becomes BRANCH TRIE; BRANCH X;

		  There is an additional case, that being where there is a 
		  common prefix, which gets split out into an EXACT like node
		  preceding the TRIE node.

		  If x(1..n)==tail then we can do a simple trie, if not we make
		  a "jump" trie, such that when we match the appropriate word
		  we "jump" to the appopriate tail node. Essentailly we turn
		  a nested if into a case structure of sorts.

		*/
		
		    int made=0;
		    if (!re_trie_maxbuff) {
			re_trie_maxbuff = get_sv(RE_TRIE_MAXBUF_NAME, 1);
			if (!SvIOK(re_trie_maxbuff))
			    sv_setiv(re_trie_maxbuff, RE_TRIE_MAXBUF_INIT);
		    }
                    if ( SvIV(re_trie_maxbuff)>=0  ) {
                        regnode *cur;
                        regnode *first = (regnode *)NULL;
                        regnode *last = (regnode *)NULL;
                        regnode *tail = scan;
                        U8 optype = 0;
                        U32 count=0;

#ifdef DEBUGGING
                        SV * const mysv = sv_newmortal();       /* for dumping */
#endif
                        /* var tail is used because there may be a TAIL
                           regop in the way. Ie, the exacts will point to the
                           thing following the TAIL, but the last branch will
                           point at the TAIL. So we advance tail. If we
                           have nested (?:) we may have to move through several
                           tails.
                         */

                        while ( OP( tail ) == TAIL ) {
                            /* this is the TAIL generated by (?:) */
                            tail = regnext( tail );
                        }

                        
                        DEBUG_OPTIMISE_r({
                            regprop(RExC_rx, mysv, tail );
                            PerlIO_printf( Perl_debug_log, "%*s%s%s\n",
                                (int)depth * 2 + 2, "", 
                                "Looking for TRIE'able sequences. Tail node is: ", 
                                SvPV_nolen_const( mysv )
                            );
                        });
                        
                        /*

                           step through the branches, cur represents each
                           branch, noper is the first thing to be matched
                           as part of that branch and noper_next is the
                           regnext() of that node. if noper is an EXACT
                           and noper_next is the same as scan (our current
                           position in the regex) then the EXACT branch is
                           a possible optimization target. Once we have
                           two or more consequetive such branches we can
                           create a trie of the EXACT's contents and stich
                           it in place. If the sequence represents all of
                           the branches we eliminate the whole thing and
                           replace it with a single TRIE. If it is a
                           subsequence then we need to stitch it in. This
                           means the first branch has to remain, and needs
                           to be repointed at the item on the branch chain
                           following the last branch optimized. This could
                           be either a BRANCH, in which case the
                           subsequence is internal, or it could be the
                           item following the branch sequence in which
                           case the subsequence is at the end.

                        */

                        /* dont use tail as the end marker for this traverse */
                        for ( cur = startbranch ; cur != scan ; cur = regnext( cur ) ) {
                            regnode * const noper = NEXTOPER( cur );
#if defined(DEBUGGING) || defined(NOJUMPTRIE)
                            regnode * const noper_next = regnext( noper );
#endif

                            DEBUG_OPTIMISE_r({
                                regprop(RExC_rx, mysv, cur);
                                PerlIO_printf( Perl_debug_log, "%*s- %s (%d)",
                                   (int)depth * 2 + 2,"", SvPV_nolen_const( mysv ), REG_NODE_NUM(cur) );

                                regprop(RExC_rx, mysv, noper);
                                PerlIO_printf( Perl_debug_log, " -> %s",
                                    SvPV_nolen_const(mysv));

                                if ( noper_next ) {
                                  regprop(RExC_rx, mysv, noper_next );
                                  PerlIO_printf( Perl_debug_log,"\t=> %s\t",
                                    SvPV_nolen_const(mysv));
                                }
                                PerlIO_printf( Perl_debug_log, "(First==%d,Last==%d,Cur==%d)\n",
                                   REG_NODE_NUM(first), REG_NODE_NUM(last), REG_NODE_NUM(cur) );
                            });
                            if ( (((first && optype!=NOTHING) ? OP( noper ) == optype
                                         : PL_regkind[ OP( noper ) ] == EXACT )
                                  || OP(noper) == NOTHING )
#ifdef NOJUMPTRIE
                                  && noper_next == tail
#endif
                                  && count < U16_MAX)
                            {
                                count++;
                                if ( !first || optype == NOTHING ) {
                                    if (!first) first = cur;
                                    optype = OP( noper );
                                } else {
                                    last = cur;
                                }
                            } else {
/* 
    Currently we assume that the trie can handle unicode and ascii
    matches fold cased matches. If this proves true then the following
    define will prevent tries in this situation. 
    
    #define TRIE_TYPE_IS_SAFE (UTF || optype==EXACT)
*/
#define TRIE_TYPE_IS_SAFE 1
                                if ( last && TRIE_TYPE_IS_SAFE ) {
                                    make_trie( pRExC_state, 
                                            startbranch, first, cur, tail, count, 
                                            optype, depth+1 );
                                }
                                if ( PL_regkind[ OP( noper ) ] == EXACT
#ifdef NOJUMPTRIE
                                     && noper_next == tail
#endif
                                ){
                                    count = 1;
                                    first = cur;
                                    optype = OP( noper );
                                } else {
                                    count = 0;
                                    first = NULL;
                                    optype = 0;
                                }
                                last = NULL;
                            }
                        }
                        DEBUG_OPTIMISE_r({
                            regprop(RExC_rx, mysv, cur);
                            PerlIO_printf( Perl_debug_log,
                              "%*s- %s (%d) <SCAN FINISHED>\n", (int)depth * 2 + 2,
                              "", SvPV_nolen_const( mysv ),REG_NODE_NUM(cur));

                        });
                        
                        if ( last && TRIE_TYPE_IS_SAFE ) {
                            made= make_trie( pRExC_state, startbranch, first, scan, tail, count, optype, depth+1 );
#ifdef TRIE_STUDY_OPT	
                            if ( ((made == MADE_EXACT_TRIE && 
                                 startbranch == first) 
                                 || ( first_non_open == first )) && 
                                 depth==0 ) {
                                flags |= SCF_TRIE_RESTUDY;
                                if ( startbranch == first 
                                     && scan == tail ) 
                                {
                                    RExC_seen &=~REG_TOP_LEVEL_BRANCHES;
                                }
                            }
#endif
                        }
                    }
                    
                } /* do trie */
                
d903 1
a903 1
	    else if ( code == BRANCHJ ) {  /* single branch is optimized. */
d905 1
a905 1
	    } else			/* single branch is optimized. */
a907 57
	} else if (OP(scan) == SUSPEND || OP(scan) == GOSUB || OP(scan) == GOSTART) {
	    scan_frame *newframe = NULL;
	    I32 paren;
	    regnode *start;
	    regnode *end;

	    if (OP(scan) != SUSPEND) {
	    /* set the pointer */
	        if (OP(scan) == GOSUB) {
	            paren = ARG(scan);
	            RExC_recurse[ARG2L(scan)] = scan;
                    start = RExC_open_parens[paren-1];
                    end   = RExC_close_parens[paren-1];
                } else {
                    paren = 0;
                    start = RExC_rxi->program + 1;
                    end   = RExC_opend;
                }
                if (!recursed) {
                    Newxz(recursed, (((RExC_npar)>>3) +1), U8);
                    SAVEFREEPV(recursed);
                }
                if (!PAREN_TEST(recursed,paren+1)) {
		    PAREN_SET(recursed,paren+1);
                    Newx(newframe,1,scan_frame);
                } else {
                    if (flags & SCF_DO_SUBSTR) {
                        SCAN_COMMIT(pRExC_state,data,minlenp);
                        data->longest = &(data->longest_float);
                    }
                    is_inf = is_inf_internal = 1;
                    if (flags & SCF_DO_STCLASS_OR) /* Allow everything */
                        cl_anything(pRExC_state, data->start_class);
                    flags &= ~SCF_DO_STCLASS;
	        }
            } else {
	        Newx(newframe,1,scan_frame);
	        paren = stopparen;
	        start = scan+2;
	        end = regnext(scan);
	    }
	    if (newframe) {
                assert(start);
                assert(end);
	        SAVEFREEPV(newframe);
	        newframe->next = regnext(scan);
	        newframe->last = last;
	        newframe->stop = stopparen;
	        newframe->prev = frame;

	        frame = newframe;
	        scan =  start;
	        stopparen = paren;
	        last = end;

	        continue;
	    }
d911 1
a911 1
	    UV uc;
d914 2
a915 4
		l = utf8_length(s, s + l);
		uc = utf8_to_uvchr(s, NULL);
	    } else {
		uc = *((U8*)STRING(scan));
a926 2
		if (UTF)
		    SvUTF8_on(data->last_found);
d935 2
d967 1
a967 1
		cl_and(data->start_class, and_withp);
d971 1
a971 1
	else if (PL_regkind[OP(scan)] == EXACT) { /* But OP != EXACT! */
d976 2
a977 4
	    if (flags & SCF_DO_SUBSTR) {
		assert(data);
		SCAN_COMMIT(pRExC_state, data, minlenp);
	    }
d979 1
a979 1
		const U8 * const s = (U8 *)STRING(scan);
d984 1
a984 1
	    if (flags & SCF_DO_SUBSTR)
d1013 1
a1013 1
		cl_and(data->start_class, and_withp);
d1020 1
a1020 1
	    regnode * const oscan = scan;
d1025 1
a1025 1
	    switch (PL_regkind[OP(scan)]) {
d1055 1
a1055 1
		    SCAN_COMMIT(pRExC_state, data, minlenp); /* Cannot extend fixed substrings */
d1060 2
a1061 9
	        if (stopparen>0 && (OP(scan)==CURLYN || OP(scan)==CURLYM)
	            && (scan->flags == stopparen))
		{
		    mincount = 1;
		    maxcount = 1;
		} else {
		    mincount = ARG1(scan);
		    maxcount = ARG2(scan);
		}
d1065 2
a1066 1
		    scan->flags = ((lp <= (I32)U8_MAX) ? (U8)lp : U8_MAX);
d1072 1
a1072 1
		    if (mincount == 0) SCAN_COMMIT(pRExC_state,data,minlenp); /* Cannot extend fixed substrings */
d1098 3
a1100 4
		minnext = study_chunk(pRExC_state, &scan, minlenp, &deltanext, 
		                      last, data, stopparen, recursed, NULL,
				      (mincount == 0
					? (f & ~SCF_DO_SUBSTR) : f),depth+1);
d1111 1
a1111 2
			INIT_AND_WITHP;
			StructCopy(data->start_class, and_withp,
d1122 1
a1122 1
			cl_and(data->start_class, and_withp);
d1155 1
a1155 1
		    regnode * const nxt1 = nxt;
d1163 1
a1163 1
			&& !(PL_regkind[OP(nxt)] == EXACT
a1171 4
		    if (RExC_open_parens) {
			RExC_open_parens[ARG(nxt1)-1]=oscan; /*open->CURLYM*/
			RExC_close_parens[ARG(nxt1)-1]=nxt+2; /*close->while*/
		    }
a1175 1

a1211 4
			if (RExC_open_parens) {
			    RExC_open_parens[ARG(nxt1)-1]=oscan; /*open->CURLYM*/
			    RExC_close_parens[ARG(nxt1)-1]=nxt2+1; /*close->NOTHING*/
			}
a1213 1

d1236 2
a1237 2
			study_chunk(pRExC_state, &nxt1, minlenp, &deltanext, nxt,
				    NULL, stopparen, recursed, NULL, 0,depth+1);
d1261 1
a1261 1
		    SV *last_str = NULL;
d1284 1
a1284 1
			const char * const s = SvPV_const(data->last_found, l);
d1313 1
a1313 1
					mg->mg_len += CHR_SVLEN(last_str) - l;
d1331 1
a1331 1
			SCAN_COMMIT(pRExC_state,data,minlenp);
d1333 1
a1333 7
			    SV * const sv = data->last_found;
			    MAGIC * const mg = SvUTF8(sv) && SvMAGICAL(sv) ?
				mg_find(sv, PERL_MAGIC_utf8) : NULL;

			    if (mg)
				mg->mg_len = -1;
			    sv_setsv(sv, last_str);
d1350 1
a1350 1
		    while (PL_regkind[OP(next = regnext(oscan))] == NOTHING
d1357 1
a1357 1
		    SCAN_COMMIT(pRExC_state,data,minlenp);	/* Cannot expect anything... */
a1366 40
	else if (OP(scan) == LNBREAK) {
	    if (flags & SCF_DO_STCLASS) {
		int value = 0;
		data->start_class->flags &= ~ANYOF_EOS;	/* No match on empty */
    	        if (flags & SCF_DO_STCLASS_AND) {
                    for (value = 0; value < 256; value++)
                        if (!is_VERTWS_cp(value))
                            ANYOF_BITMAP_CLEAR(data->start_class, value);  
                }                                                              
                else {                                                         
                    for (value = 0; value < 256; value++)
                        if (is_VERTWS_cp(value))
                            ANYOF_BITMAP_SET(data->start_class, value);	   
                }                                                              
                if (flags & SCF_DO_STCLASS_OR)
		    cl_and(data->start_class, and_withp);
		flags &= ~SCF_DO_STCLASS;
            }
	    min += 1;
	    delta += 1;
            if (flags & SCF_DO_SUBSTR) {
    	        SCAN_COMMIT(pRExC_state,data,minlenp);	/* Cannot expect anything... */
    	        data->pos_min += 1;
	        data->pos_delta += 1;
		data->longest = &(data->longest_float);
    	    }
    	    
	}
	else if (OP(scan) == FOLDCHAR) {
	    int d = ARG(scan)==0xDF ? 1 : 2;
	    flags &= ~SCF_DO_STCLASS;
            min += 1;
            delta += d;
            if (flags & SCF_DO_SUBSTR) {
	        SCAN_COMMIT(pRExC_state,data,minlenp);	/* Cannot expect anything... */
	        data->pos_min += 1;
	        data->pos_delta += d;
		data->longest = &(data->longest_float);
	    }
	}
d1371 1
a1371 1
		SCAN_COMMIT(pRExC_state,data,minlenp);
d1380 1
a1380 1
		switch (PL_regkind[OP(scan)]) {
a1560 3
		CASE_SYNST_FNC(VERTWS);
		CASE_SYNST_FNC(HORIZWS);
		
d1563 1
a1563 1
		    cl_and(data->start_class, and_withp);
d1567 1
a1567 1
	else if (PL_regkind[OP(scan)] == EOL && flags & SCF_DO_SUBSTR) {
d1572 1
a1572 1
	else if (  PL_regkind[OP(scan)] == BRANCHJ
d1576 45
a1620 155
            if ( !PERL_ENABLE_POSITIVE_ASSERTION_STUDY 
                || OP(scan) == UNLESSM )
            {
                /* Negative Lookahead/lookbehind
                   In this case we can't do fixed string optimisation.
                */

                I32 deltanext, minnext, fake = 0;
                regnode *nscan;
                struct regnode_charclass_class intrnl;
                int f = 0;

                data_fake.flags = 0;
                if (data) {
                    data_fake.whilem_c = data->whilem_c;
                    data_fake.last_closep = data->last_closep;
		}
                else
                    data_fake.last_closep = &fake;
		data_fake.pos_delta = delta;
                if ( flags & SCF_DO_STCLASS && !scan->flags
                     && OP(scan) == IFMATCH ) { /* Lookahead */
                    cl_init(pRExC_state, &intrnl);
                    data_fake.start_class = &intrnl;
                    f |= SCF_DO_STCLASS_AND;
		}
                if (flags & SCF_WHILEM_VISITED_POS)
                    f |= SCF_WHILEM_VISITED_POS;
                next = regnext(scan);
                nscan = NEXTOPER(NEXTOPER(scan));
                minnext = study_chunk(pRExC_state, &nscan, minlenp, &deltanext, 
                    last, &data_fake, stopparen, recursed, NULL, f, depth+1);
                if (scan->flags) {
                    if (deltanext) {
			FAIL("Variable length lookbehind not implemented");
                    }
                    else if (minnext > (I32)U8_MAX) {
			FAIL2("Lookbehind longer than %"UVuf" not implemented", (UV)U8_MAX);
                    }
                    scan->flags = (U8)minnext;
                }
                if (data) {
                    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))
                        pars++;
                    if (data_fake.flags & SF_HAS_EVAL)
                        data->flags |= SF_HAS_EVAL;
                    data->whilem_c = data_fake.whilem_c;
                }
                if (f & SCF_DO_STCLASS_AND) {
                    const int was = (data->start_class->flags & ANYOF_EOS);

                    cl_and(data->start_class, &intrnl);
                    if (was)
                        data->start_class->flags |= ANYOF_EOS;
                }
	    }
#if PERL_ENABLE_POSITIVE_ASSERTION_STUDY
            else {
                /* Positive Lookahead/lookbehind
                   In this case we can do fixed string optimisation,
                   but we must be careful about it. Note in the case of
                   lookbehind the positions will be offset by the minimum
                   length of the pattern, something we won't know about
                   until after the recurse.
                */
                I32 deltanext, fake = 0;
                regnode *nscan;
                struct regnode_charclass_class intrnl;
                int f = 0;
                /* We use SAVEFREEPV so that when the full compile 
                    is finished perl will clean up the allocated 
                    minlens when its all done. This was we don't
                    have to worry about freeing them when we know
                    they wont be used, which would be a pain.
                 */
                I32 *minnextp;
                Newx( minnextp, 1, I32 );
                SAVEFREEPV(minnextp);

                if (data) {
                    StructCopy(data, &data_fake, scan_data_t);
                    if ((flags & SCF_DO_SUBSTR) && data->last_found) {
                        f |= SCF_DO_SUBSTR;
                        if (scan->flags) 
                            SCAN_COMMIT(pRExC_state, &data_fake,minlenp);
                        data_fake.last_found=newSVsv(data->last_found);
                    }
                }
                else
                    data_fake.last_closep = &fake;
                data_fake.flags = 0;
		data_fake.pos_delta = delta;
                if (is_inf)
	            data_fake.flags |= SF_IS_INF;
                if ( flags & SCF_DO_STCLASS && !scan->flags
                     && OP(scan) == IFMATCH ) { /* Lookahead */
                    cl_init(pRExC_state, &intrnl);
                    data_fake.start_class = &intrnl;
                    f |= SCF_DO_STCLASS_AND;
                }
                if (flags & SCF_WHILEM_VISITED_POS)
                    f |= SCF_WHILEM_VISITED_POS;
                next = regnext(scan);
                nscan = NEXTOPER(NEXTOPER(scan));

                *minnextp = study_chunk(pRExC_state, &nscan, minnextp, &deltanext, 
                    last, &data_fake, stopparen, recursed, NULL, f,depth+1);
                if (scan->flags) {
                    if (deltanext) {
			FAIL("Variable length lookbehind not implemented");
                    }
                    else if (*minnextp > (I32)U8_MAX) {
			FAIL2("Lookbehind longer than %"UVuf" not implemented", (UV)U8_MAX);
                    }
                    scan->flags = (U8)*minnextp;
                }

                *minnextp += min;

                if (f & SCF_DO_STCLASS_AND) {
                    const int was = (data->start_class->flags & ANYOF_EOS);

                    cl_and(data->start_class, &intrnl);
                    if (was)
                        data->start_class->flags |= ANYOF_EOS;
                }
                if (data) {
                    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))
                        pars++;
                    if (data_fake.flags & SF_HAS_EVAL)
                        data->flags |= SF_HAS_EVAL;
                    data->whilem_c = data_fake.whilem_c;
                    if ((flags & SCF_DO_SUBSTR) && data_fake.last_found) {
                        if (RExC_rx->minlen<*minnextp)
                            RExC_rx->minlen=*minnextp;
                        SCAN_COMMIT(pRExC_state, &data_fake, minnextp);
                        SvREFCNT_dec(data_fake.last_found);
                        
                        if ( data_fake.minlen_fixed != minlenp ) 
                        {
                            data->offset_fixed= data_fake.offset_fixed;
                            data->minlen_fixed= data_fake.minlen_fixed;
                            data->lookbehind_fixed+= scan->flags;
                        }
                        if ( data_fake.minlen_float != minlenp )
                        {
                            data->minlen_float= data_fake.minlen_float;
                            data->offset_float_min=data_fake.offset_float_min;
                            data->offset_float_max=data_fake.offset_float_max;
                            data->lookbehind_float+= scan->flags;
                        }
                    }
                }


a1621 1
#endif
d1624 1
a1624 2
	    if (stopparen != (I32)ARG(scan))
	        pars++;
a1626 3
	    if (stopparen == (I32)ARG(scan)) {
	        break;
	    }
d1640 1
a1640 13
	else if ( PL_regkind[OP(scan)] == ENDLIKE ) {
	    if (flags & SCF_DO_SUBSTR) {
		SCAN_COMMIT(pRExC_state,data,minlenp);
		flags &= ~SCF_DO_SUBSTR;
	    }
	    if (data && OP(scan)==ACCEPT) {
	        data->flags |= SCF_SEEN_ACCEPT;
	        if (stopmin > min)
	            stopmin = min;
	    }
	}
	else if (OP(scan) == LOGICAL && scan->flags == 2) /* Embedded follows */
	{
d1642 1
a1642 1
		    SCAN_COMMIT(pRExC_state,data,minlenp);
a1649 155
	else if (OP(scan) == GPOS) {
	    if (!(RExC_rx->extflags & RXf_GPOS_FLOAT) &&
	        !(delta || is_inf || (data && data->pos_delta))) 
	    {
	        if (!(RExC_rx->extflags & RXf_ANCH) && (flags & SCF_DO_SUBSTR))
		    RExC_rx->extflags |= RXf_ANCH_GPOS;
	        if (RExC_rx->gofs < (U32)min)
		    RExC_rx->gofs = min;
            } else {
                RExC_rx->extflags |= RXf_GPOS_FLOAT;
                RExC_rx->gofs = 0;
            }	    
	}
#ifdef TRIE_STUDY_OPT
#ifdef FULL_TRIE_STUDY
        else if (PL_regkind[OP(scan)] == TRIE) {
            /* NOTE - There is similar code to this block above for handling
               BRANCH nodes on the initial study.  If you change stuff here
               check there too. */
            regnode *trie_node= scan;
            regnode *tail= regnext(scan);
            reg_trie_data *trie = (reg_trie_data*)RExC_rxi->data->data[ ARG(scan) ];
            I32 max1 = 0, min1 = I32_MAX;
            struct regnode_charclass_class accum;

            if (flags & SCF_DO_SUBSTR) /* XXXX Add !SUSPEND? */
                SCAN_COMMIT(pRExC_state, data,minlenp); /* Cannot merge strings after this. */
            if (flags & SCF_DO_STCLASS)
                cl_init_zero(pRExC_state, &accum);
                
            if (!trie->jump) {
                min1= trie->minlen;
                max1= trie->maxlen;
            } else {
                const regnode *nextbranch= NULL;
                U32 word;
                
                for ( word=1 ; word <= trie->wordcount ; word++) 
                {
                    I32 deltanext=0, minnext=0, f = 0, fake;
                    struct regnode_charclass_class this_class;
                    
                    data_fake.flags = 0;
                    if (data) {
                        data_fake.whilem_c = data->whilem_c;
                        data_fake.last_closep = data->last_closep;
                    }
                    else
                        data_fake.last_closep = &fake;
		    data_fake.pos_delta = delta;
                    if (flags & SCF_DO_STCLASS) {
                        cl_init(pRExC_state, &this_class);
                        data_fake.start_class = &this_class;
                        f = SCF_DO_STCLASS_AND;
                    }
                    if (flags & SCF_WHILEM_VISITED_POS)
                        f |= SCF_WHILEM_VISITED_POS;
    
                    if (trie->jump[word]) {
                        if (!nextbranch)
                            nextbranch = trie_node + trie->jump[0];
                        scan= trie_node + trie->jump[word];
                        /* We go from the jump point to the branch that follows
                           it. Note this means we need the vestigal unused branches
                           even though they arent otherwise used.
                         */
                        minnext = study_chunk(pRExC_state, &scan, minlenp, 
                            &deltanext, (regnode *)nextbranch, &data_fake, 
                            stopparen, recursed, NULL, f,depth+1);
                    }
                    if (nextbranch && PL_regkind[OP(nextbranch)]==BRANCH)
                        nextbranch= regnext((regnode*)nextbranch);
                    
                    if (min1 > (I32)(minnext + trie->minlen))
                        min1 = minnext + trie->minlen;
                    if (max1 < (I32)(minnext + deltanext + trie->maxlen))
                        max1 = minnext + deltanext + trie->maxlen;
                    if (deltanext == I32_MAX)
                        is_inf = is_inf_internal = 1;
                    
                    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))
                        pars++;
                    if (data_fake.flags & SCF_SEEN_ACCEPT) {
                        if ( stopmin > min + min1) 
	                    stopmin = min + min1;
	                flags &= ~SCF_DO_SUBSTR;
	                if (data)
	                    data->flags |= SCF_SEEN_ACCEPT;
	            }
                    if (data) {
                        if (data_fake.flags & SF_HAS_EVAL)
                            data->flags |= SF_HAS_EVAL;
                        data->whilem_c = data_fake.whilem_c;
                    }
                    if (flags & SCF_DO_STCLASS)
                        cl_or(pRExC_state, &accum, &this_class);
                }
            }
            if (flags & SCF_DO_SUBSTR) {
                data->pos_min += min1;
                data->pos_delta += max1 - min1;
                if (max1 != min1 || is_inf)
                    data->longest = &(data->longest_float);
            }
            min += min1;
            delta += max1 - min1;
            if (flags & SCF_DO_STCLASS_OR) {
                cl_or(pRExC_state, data->start_class, &accum);
                if (min1) {
                    cl_and(data->start_class, and_withp);
                    flags &= ~SCF_DO_STCLASS;
                }
            }
            else if (flags & SCF_DO_STCLASS_AND) {
                if (min1) {
                    cl_and(data->start_class, &accum);
                    flags &= ~SCF_DO_STCLASS;
                }
                else {
                    /* Switch to OR mode: cache the old value of
                     * data->start_class */
		    INIT_AND_WITHP;
                    StructCopy(data->start_class, and_withp,
                               struct regnode_charclass_class);
                    flags &= ~SCF_DO_STCLASS_AND;
                    StructCopy(&accum, data->start_class,
                               struct regnode_charclass_class);
                    flags |= SCF_DO_STCLASS_OR;
                    data->start_class->flags |= ANYOF_EOS;
                }
            }
            scan= tail;
            continue;
        }
#else
	else if (PL_regkind[OP(scan)] == TRIE) {
	    reg_trie_data *trie = (reg_trie_data*)RExC_rxi->data->data[ ARG(scan) ];
	    U8*bang=NULL;
	    
	    min += trie->minlen;
	    delta += (trie->maxlen - trie->minlen);
	    flags &= ~SCF_DO_STCLASS; /* xxx */
            if (flags & SCF_DO_SUBSTR) {
    	        SCAN_COMMIT(pRExC_state,data,minlenp);	/* Cannot expect anything... */
    	        data->pos_min += trie->minlen;
    	        data->pos_delta += (trie->maxlen - trie->minlen);
		if (trie->maxlen != trie->minlen)
		    data->longest = &(data->longest_float);
    	    }
    	    if (trie->jump) /* no more substrings -- for now /grr*/
    	        flags &= ~SCF_DO_SUBSTR; 
	}
#endif /* old or new */
#endif /* TRIE_STUDY_OPT */	

a1652 7
    if (frame) {
        last = frame->last;
        scan = frame->next;
        stopparen = frame->stop;
        frame = frame->prev;
        goto fake_study_recurse;
    }
a1654 3
    assert(!frame);
    DEBUG_STUDYDATA("pre-fin:",data,depth);

d1659 1
a1659 1
    if (is_par > (I32)U8_MAX)
d1670 2
a1671 7
	cl_and(data->start_class, and_withp);
    if (flags & SCF_TRIE_RESTUDY)
        data->flags |= 	SCF_TRIE_RESTUDY;
    
    DEBUG_STUDYDATA("post-fin:",data,depth);
    
    return min < stopmin ? min : stopmin;
d1674 2
a1675 2
STATIC U32
S_add_data(RExC_state_t *pRExC_state, U32 n, const char *s)
d1677 15
a1691 12
    U32 count = RExC_rxi->data ? RExC_rxi->data->count : 0;

    Renewc(RExC_rxi->data,
	   sizeof(*RExC_rxi->data) + sizeof(void*) * (count + n - 1),
	   char, struct reg_data);
    if(count)
	Renew(RExC_rxi->data->what, count + n, U8);
    else
	Newx(RExC_rxi->data->what, n, U8);
    RExC_rxi->data->count = count + n;
    Copy(s, RExC_rxi->data->what + count, n, U8);
    return count;
a1693 2
/*XXX: todo make this not included in a non debugging perl */
#ifndef PERL_IN_XSUB_RE
a1696 1
    dVAR;
a1717 2
#endif

a1718 9
#ifdef TRIE_STUDY_OPT
#define CHECK_RESTUDY_GOTO                                  \
        if (                                                \
              (data.flags & SCF_TRIE_RESTUDY)               \
              && ! restudied++                              \
        )     goto reStudy
#else
#define CHECK_RESTUDY_GOTO
#endif        
d1735 2
a1736 13



#ifndef PERL_IN_XSUB_RE
#define RE_ENGINE_PTR &PL_core_reg_engine
#else
extern const struct regexp_engine my_reg_engine;
#define RE_ENGINE_PTR &my_reg_engine
#endif

#ifndef PERL_IN_XSUB_RE 
REGEXP *
Perl_pregcomp(pTHX_ const SV * const pattern, const U32 flags)
d1738 1
a1738 29
    dVAR;
    HV * const table = GvHV(PL_hintgv);
    /* Dispatch a request to compile a regexp to correct 
       regexp engine. */
    if (table) {
        SV **ptr= hv_fetchs(table, "regcomp", FALSE);
        GET_RE_DEBUG_FLAGS_DECL;
        if (ptr && SvIOK(*ptr) && SvIV(*ptr)) {
            const regexp_engine *eng=INT2PTR(regexp_engine*,SvIV(*ptr));
            DEBUG_COMPILE_r({
                PerlIO_printf(Perl_debug_log, "Using engine %"UVxf"\n",
                    SvIV(*ptr));
            });            
            return CALLREGCOMP_ENG(eng, pattern, flags);
        } 
    }
    return Perl_re_compile(aTHX_ pattern, flags);
}
#endif

REGEXP *
Perl_re_compile(pTHX_ const SV * const pattern, const U32 pm_flags)
{
    dVAR;
    register REGEXP *r;
    register regexp_internal *ri;
    STRLEN plen;
    char*  exp = SvPV((SV*)pattern, plen);
    char* xend = exp + plen;
d1740 1
d1747 6
a1752 17
    RExC_state_t * const pRExC_state = &RExC_state;
#ifdef TRIE_STUDY_OPT    
    int restudied= 0;
    RExC_state_t copyRExC_state;
#endif    
    GET_RE_DEBUG_FLAGS_DECL;
    DEBUG_r(if (!PL_colorset) reginitcolors());

    RExC_utf8 = RExC_orig_utf8 = pm_flags & RXf_UTF8;

    DEBUG_COMPILE_r({
        SV *dsv= sv_newmortal();
        RE_PV_QUOTED_DECL(s, RExC_utf8,
            dsv, exp, plen, 60);
        PerlIO_printf(Perl_debug_log, "%sCompiling REx%s %s\n",
		       PL_colors[4],PL_colors[5],s);
    });
a1753 1
redo_first_pass:
d1755 7
a1761 1
    RExC_flags = pm_flags;
a1774 1
    RExC_nestroot = 0;
a1777 11
    RExC_charnames = NULL;
    RExC_open_parens = NULL;
    RExC_close_parens = NULL;
    RExC_opend = NULL;
    RExC_paren_names = NULL;
#ifdef DEBUGGING
    RExC_paren_name_list = NULL;
#endif
    RExC_recurse = NULL;
    RExC_recurse_count = 0;

d1782 2
a1783 3
    DEBUG_PARSE_r(PerlIO_printf(Perl_debug_log, "Starting first pass (sizing)\n"));
    if (reg(pRExC_state, 0, &flags,1) == NULL) {
	RExC_precomp = NULL;
d1786 2
a1787 27
    if (RExC_utf8 && !RExC_orig_utf8) {
        /* It's possible to write a regexp in ascii that represents Unicode
        codepoints outside of the byte range, such as via \x{100}. If we
        detect such a sequence we have to convert the entire pattern to utf8
        and then recompile, as our sizing calculation will have been based
        on 1 byte == 1 character, but we will need to use utf8 to encode
        at least some part of the pattern, and therefore must convert the whole
        thing.
        XXX: somehow figure out how to make this less expensive...
        -- dmq */
        STRLEN len = plen;
        DEBUG_PARSE_r(PerlIO_printf(Perl_debug_log,
	    "UTF8 mismatch! Converting to utf8 for resizing and compile\n"));
        exp = (char*)Perl_bytes_to_utf8(aTHX_ (U8*)exp, &len);
        xend = exp + len;
        RExC_orig_utf8 = RExC_utf8;
        SAVEFREEPV(exp);
        goto redo_first_pass;
    }
    DEBUG_PARSE_r({
        PerlIO_printf(Perl_debug_log, 
            "Required size %"IVdf" nodes\n"
            "Starting second pass (creation)\n", 
            (IV)RExC_size);
        RExC_lastnum=0; 
        RExC_lastparse=NULL; 
    });
d1797 4
a1800 7
    /* Allocate space and zero-initialize. Note, the two step process 
       of zeroing when in debug mode, thus anything assigned has to 
       happen after that */
    Newxz(r, 1, regexp);
    Newxc(ri, sizeof(regexp_internal) + (unsigned)RExC_size * sizeof(regnode),
	 char, regexp_internal);
    if ( r == NULL || ri == NULL )
d1802 1
d1805 1
a1805 4
    Zero(ri, sizeof(regexp_internal) + (unsigned)RExC_size * sizeof(regnode), char);
#else 
    /* bulk initialize base fields with 0. */
    Zero(ri, sizeof(regexp_internal), char);        
a1806 4

    /* non-zero initialization begins here */
    RXi_SET( r, ri );
    r->engine= RE_ENGINE_PTR;
d1808 5
a1812 45
    r->prelen = plen;
    r->extflags = pm_flags;
    {
        bool has_p     = ((r->extflags & RXf_PMf_KEEPCOPY) == RXf_PMf_KEEPCOPY);
	bool has_minus = ((r->extflags & RXf_PMf_STD_PMMOD) != RXf_PMf_STD_PMMOD);
	bool has_runon = ((RExC_seen & REG_SEEN_RUN_ON_COMMENT)==REG_SEEN_RUN_ON_COMMENT);
	U16 reganch = (U16)((r->extflags & RXf_PMf_STD_PMMOD) >> 12);
	const char *fptr = STD_PAT_MODS;        /*"msix"*/
	char *p;
        r->wraplen = r->prelen + has_minus + has_p + has_runon
            + (sizeof(STD_PAT_MODS) - 1)
            + (sizeof("(?:)") - 1);

        Newx(r->wrapped, r->wraplen + 1, char );
        p = r->wrapped;
        *p++='('; *p++='?';
        if (has_p)
            *p++ = KEEPCOPY_PAT_MOD; /*'p'*/
        {
            char *r = p + (sizeof(STD_PAT_MODS) - 1) + has_minus - 1;
            char *colon = r + 1;
            char ch;

            while((ch = *fptr++)) {
                if(reganch & 1)
                    *p++ = ch;
                else
                    *r-- = ch;
                reganch >>= 1;
            }
            if(has_minus) {
                *r = '-';
                p = colon;
            }
        }

        *p++ = ':';
        Copy(RExC_precomp, p, r->prelen, char);
        r->precomp = p;
        p += r->prelen;
        if (has_runon)
            *p++ = '\n';
        *p++ = ')';
        *p = 0;
    }
d1814 7
a1820 8
    r->intflags = 0;
    r->nparens = RExC_npar - 1;	/* set early to validate backrefs */
    
    if (RExC_seen & REG_SEEN_RECURSE) {
        Newxz(RExC_open_parens, RExC_npar,regnode *);
        SAVEFREEPV(RExC_open_parens);
        Newxz(RExC_close_parens,RExC_npar,regnode *);
        SAVEFREEPV(RExC_close_parens);
d1822 1
a1822 5

    /* Useful during FAIL. */
#ifdef RE_TRACK_PATTERN_OFFSETS
    Newxz(ri->u.offsets, 2*RExC_size+1, U32); /* MJD 20001228 */
    DEBUG_OFFSETS_r(PerlIO_printf(Perl_debug_log,
d1824 1
a1824 1
                          ri->u.offsets ? "Got" : "Couldn't get",
d1826 1
a1826 2
#endif
    SetProgLen(ri,RExC_size);
a1827 1
    RExC_rxi = ri;
d1830 1
a1830 1
    RExC_flags = pm_flags;	/* don't let top level (?i) bleed */
d1835 2
a1836 4
    RExC_emit_start = ri->program;
    RExC_emit = ri->program;
    RExC_emit_bound = ri->program + RExC_size + 1;

d1838 1
a1838 1
    RExC_rx->seen_evals = RExC_seen_evals;
d1840 2
a1841 2
    if (reg(pRExC_state, 0, &flags,1) == NULL) {
	ReREFCNT_dec(r);   
a1842 36
    }
    /* XXXX To minimize changes to RE engine we always allocate
       3-units-long substrs field. */
    Newx(r->substrs, 1, struct reg_substr_data);
    if (RExC_recurse_count) {
        Newxz(RExC_recurse,RExC_recurse_count,regnode *);
        SAVEFREEPV(RExC_recurse);
    }

reStudy:
    r->minlen = minlen = sawplus = sawopen = 0;
    Zero(r->substrs, 1, struct reg_substr_data);

#ifdef TRIE_STUDY_OPT
    if ( restudied ) {
        U32 seen=RExC_seen;
        DEBUG_OPTIMISE_r(PerlIO_printf(Perl_debug_log,"Restudying\n"));
        
        RExC_state = copyRExC_state;
        if (seen & REG_TOP_LEVEL_BRANCHES) 
            RExC_seen |= REG_TOP_LEVEL_BRANCHES;
        else
            RExC_seen &= ~REG_TOP_LEVEL_BRANCHES;
        if (data.last_found) {
            SvREFCNT_dec(data.longest_fixed);
	    SvREFCNT_dec(data.longest_float);
	    SvREFCNT_dec(data.last_found);
	}
	StructCopy(&zero_scan_data, &data, scan_data_t);
    } else {
        StructCopy(&zero_scan_data, &data, scan_data_t);
        copyRExC_state = RExC_state;
    }
#else
    StructCopy(&zero_scan_data, &data, scan_data_t);
#endif    
d1845 2
a1846 3
    r->extflags = RExC_flags; /* was pm_op */
    /*dmq: removed as part of de-PMOP: pm->op_pmflags = RExC_flags; */
 
d1848 2
a1849 2
        r->extflags |= RXf_UTF8;	/* Unicode in it? */
    ri->regstclass = NULL;
d1851 6
a1856 2
	r->intflags |= PREGf_NAUGHTY;
    scan = ri->program + 1;		/* First BRANCH. */
d1858 3
a1860 3
    /* testing for BRANCH here tells us whether there is "must appear"
       data in the pattern. If there is then we can use it for optimisations */
    if (!(RExC_seen & REG_TOP_LEVEL_BRANCHES)) { /*  Only one top-level choice. */
d1863 1
a1863 1
	struct regnode_charclass_class ch_class; /* pointed to by data */
d1865 3
a1867 4
	I32 last_close = 0; /* pointed to by data */
        regnode *first= scan;
        regnode *first_next= regnext(first);
	
d1871 1
a1871 3
	    (OP(first) == BRANCH && OP(first_next) != BRANCH) ||
	    /* for now we can't handle lookbehind IFMATCH*/
	    (OP(first) == IFMATCH && !first->flags) || 
d1875 1
a1875 4
	    (PL_regkind[OP(first)] == CURLY && ARG1(first) > 0) ||
	    (OP(first) == NOTHING && PL_regkind[OP(first_next)] != END ))
	{
	        
d1879 2
a1880 7
		    first += regarglen[OP(first)];
		if (OP(first) == IFMATCH) {
		    first = NEXTOPER(first);
		    first += EXTRA_STEP_2ARGS;
		} else  /* XXX possible optimisation for /(?=)/  */
		    first = NEXTOPER(first);
		first_next= regnext(first);
d1885 1
a1885 3
        DEBUG_PEEP("first:",first,0);
        /* Ignore EXACT as we deal with it later. */
	if (PL_regkind[OP(first)] == EXACT) {
d1887 1
a1887 1
		NOOP;	/* Empty, get anchored substr later. */
d1889 1
a1889 1
		ri->regstclass = first;
a1890 22
#ifdef TRIE_STCLASS	
	else if (PL_regkind[OP(first)] == TRIE &&
	        ((reg_trie_data *)ri->data->data[ ARG(first) ])->minlen>0) 
	{
	    regnode *trie_op;
	    /* this can happen only on restudy */
	    if ( OP(first) == TRIE ) {
                struct regnode_1 *trieop = (struct regnode_1 *)
		    PerlMemShared_calloc(1, sizeof(struct regnode_1));
                StructCopy(first,trieop,struct regnode_1);
                trie_op=(regnode *)trieop;
            } else {
                struct regnode_charclass *trieop = (struct regnode_charclass *)
		    PerlMemShared_calloc(1, sizeof(struct regnode_charclass));
                StructCopy(first,trieop,struct regnode_charclass);
                trie_op=(regnode *)trieop;
            }
            OP(trie_op)+=2;
            make_trie_failtable(pRExC_state, (regnode *)first, trie_op, 0);
	    ri->regstclass = trie_op;
	}
#endif	
d1892 7
a1898 7
	    ri->regstclass = first;
	else if (PL_regkind[OP(first)] == BOUND ||
		 PL_regkind[OP(first)] == NBOUND)
	    ri->regstclass = first;
	else if (PL_regkind[OP(first)] == BOL) {
	    r->extflags |= (OP(first) == MBOL
			   ? RXf_ANCH_MBOL
d1900 2
a1901 2
			      ? RXf_ANCH_SBOL
			      : RXf_ANCH_BOL));
d1906 1
a1906 1
	    r->extflags |= RXf_ANCH_GPOS;
d1910 3
a1912 4
	else if ((!sawopen || !RExC_sawback) &&
	    (OP(first) == STAR &&
	    PL_regkind[OP(NEXTOPER(first))] == REG_ANY) &&
	    !(r->extflags & RXf_ANCH) && !(RExC_seen & REG_SEEN_EVAL))
d1917 3
a1919 4
		    ? RXf_ANCH_MBOL
		    : RXf_ANCH_SBOL;
	    r->extflags |= type;
	    r->intflags |= PREGf_IMPLICIT;
d1926 1
a1926 1
	    r->intflags |= PREGf_SKIP;
d1929 2
a1930 14
#ifdef TRIE_STUDY_OPT
	DEBUG_PARSE_r(
	    if (!restudied)
	        PerlIO_printf(Perl_debug_log, "first at %"IVdf"\n",
			      (IV)(first - scan + 1))
        );
#else
	DEBUG_PARSE_r(
	    PerlIO_printf(Perl_debug_log, "first at %"IVdf"\n",
	        (IV)(first - scan + 1))
        );
#endif


d1942 5
a1946 4
	
	data.longest_fixed = newSVpvs("");
	data.longest_float = newSVpvs("");
	data.last_found = newSVpvs("");
d1949 1
a1949 1
	if (!ri->regstclass) {
a1955 8
        
	minlen = study_chunk(pRExC_state, &first, &minlen, &fake, scan + RExC_size, /* Up to end */
            &data, -1, NULL, NULL,
            SCF_DO_SUBSTR | SCF_WHILEM_VISITED_POS | stclass_flag,0);

	
        CHECK_RESTUDY_GOTO;

d1957 2
d1962 3
a1964 4
	     && !(RExC_seen & REG_SEEN_VERBARG)
	     && (!(RExC_seen & REG_SEEN_GPOS) || (r->extflags & RXf_ANCH_GPOS)))
	    r->extflags |= RXf_CHECK_ALL;
	scan_commit(pRExC_state, &data,&minlen,0);
a1966 4
        /* Note that code very similar to this but for anchored string 
           follows immediately below, changes may need to be made to both. 
           Be careful. 
         */
d1971 2
a1972 3
		    || (RExC_flags & RXf_PMf_MULTILINE)))) 
        {
            I32 t,ml;
d1974 1
a1974 1
	    if (SvCUR(data.longest_fixed)  /* ok to leave SvCUR */
a1978 2
            /* copy the information about the longest float from the reg_scan_data
               over to the program. */
d1981 1
a1981 1
		r->float_substr = NULL;
d1984 1
a1984 1
		r->float_utf8 = NULL;
d1986 1
a1986 10
	    /* float_end_shift is how many chars that must be matched that 
	       follow this item. We calculate it ahead of time as once the
	       lookbehind offset is added in we lose the ability to correctly
	       calculate it.*/
	    ml = data.minlen_float ? *(data.minlen_float) 
	                           : (I32)longest_float_length;
	    r->float_end_shift = ml - data.offset_float_min
	        - longest_float_length + (SvTAIL(data.longest_float) != 0)
	        + data.lookbehind_float;
	    r->float_min_offset = data.offset_float_min - data.lookbehind_float;
a1987 3
	    if (data.offset_float_max < I32_MAX) /* Don't offset infinity */
	        r->float_max_offset -= data.lookbehind_float;
	    
d1990 1
a1990 1
			   || (RExC_flags & RXf_PMf_MULTILINE)));
d1995 1
a1995 1
	    r->float_substr = r->float_utf8 = NULL;
a1999 4
        /* Note that code very similar to this but for floating string 
           is immediately above, changes may need to be made to both. 
           Be careful. 
         */
d2004 2
a2005 3
		    || (RExC_flags & RXf_PMf_MULTILINE)))) 
        {
            I32 t,ml;
a2006 2
            /* copy the information about the longest fixed 
               from the reg_scan_data over to the program. */
d2009 1
a2009 1
		r->anchored_substr = NULL;
d2012 1
a2012 1
		r->anchored_utf8 = NULL;
d2014 1
a2014 11
	    /* fixed_end_shift is how many chars that must be matched that 
	       follow this item. We calculate it ahead of time as once the
	       lookbehind offset is added in we lose the ability to correctly
	       calculate it.*/
            ml = data.minlen_fixed ? *(data.minlen_fixed) 
                                   : (I32)longest_fixed_length;
            r->anchored_end_shift = ml - data.offset_fixed
	        - longest_fixed_length + (SvTAIL(data.longest_fixed) != 0)
	        + data.lookbehind_fixed;
	    r->anchored_offset = data.offset_fixed - data.lookbehind_fixed;

d2017 1
a2017 1
		     || (RExC_flags & RXf_PMf_MULTILINE)));
d2021 1
a2021 1
	    r->anchored_substr = r->anchored_utf8 = NULL;
d2025 3
a2027 3
	if (ri->regstclass
	    && (OP(ri->regstclass) == REG_ANY || OP(ri->regstclass) == SANY))
	    ri->regstclass = NULL;
d2033 1
a2033 525
	    const U32 n = add_data(pRExC_state, 1, "f");

	    Newx(RExC_rxi->data->data[n], 1,
		struct regnode_charclass_class);
	    StructCopy(data.start_class,
		       (struct regnode_charclass_class*)RExC_rxi->data->data[n],
		       struct regnode_charclass_class);
	    ri->regstclass = (regnode*)RExC_rxi->data->data[n];
	    r->intflags &= ~PREGf_SKIP;	/* Used in find_byclass(). */
	    DEBUG_COMPILE_r({ SV *sv = sv_newmortal();
	              regprop(r, sv, (regnode*)data.start_class);
		      PerlIO_printf(Perl_debug_log,
				    "synthetic stclass \"%s\".\n",
				    SvPVX_const(sv));});
	}

	/* A temporary algorithm prefers floated substr to fixed one to dig more info. */
	if (longest_fixed_length > longest_float_length) {
	    r->check_end_shift = r->anchored_end_shift;
	    r->check_substr = r->anchored_substr;
	    r->check_utf8 = r->anchored_utf8;
	    r->check_offset_min = r->check_offset_max = r->anchored_offset;
	    if (r->extflags & RXf_ANCH_SINGLE)
		r->extflags |= RXf_NOSCAN;
	}
	else {
	    r->check_end_shift = r->float_end_shift;
	    r->check_substr = r->float_substr;
	    r->check_utf8 = r->float_utf8;
	    r->check_offset_min = r->float_min_offset;
	    r->check_offset_max = r->float_max_offset;
	}
	/* XXXX Currently intuiting is not compatible with ANCH_GPOS.
	   This should be changed ASAP!  */
	if ((r->check_substr || r->check_utf8) && !(r->extflags & RXf_ANCH_GPOS)) {
	    r->extflags |= RXf_USE_INTUIT;
	    if (SvTAIL(r->check_substr ? r->check_substr : r->check_utf8))
		r->extflags |= RXf_INTUIT_TAIL;
	}
	/* XXX Unneeded? dmq (shouldn't as this is handled elsewhere)
	if ( (STRLEN)minlen < longest_float_length )
            minlen= longest_float_length;
        if ( (STRLEN)minlen < longest_fixed_length )
            minlen= longest_fixed_length;     
        */
    }
    else {
	/* Several toplevels. Best we can is to set minlen. */
	I32 fake;
	struct regnode_charclass_class ch_class;
	I32 last_close = 0;
	
	DEBUG_PARSE_r(PerlIO_printf(Perl_debug_log, "\nMulti Top Level\n"));

	scan = ri->program + 1;
	cl_init(pRExC_state, &ch_class);
	data.start_class = &ch_class;
	data.last_closep = &last_close;

        
	minlen = study_chunk(pRExC_state, &scan, &minlen, &fake, scan + RExC_size,
	    &data, -1, NULL, NULL, SCF_DO_STCLASS_AND|SCF_WHILEM_VISITED_POS,0);
        
        CHECK_RESTUDY_GOTO;

	r->check_substr = r->check_utf8 = r->anchored_substr = r->anchored_utf8
		= r->float_substr = r->float_utf8 = NULL;
	if (!(data.start_class->flags & ANYOF_EOS)
	    && !cl_is_anything(data.start_class))
	{
	    const U32 n = add_data(pRExC_state, 1, "f");

	    Newx(RExC_rxi->data->data[n], 1,
		struct regnode_charclass_class);
	    StructCopy(data.start_class,
		       (struct regnode_charclass_class*)RExC_rxi->data->data[n],
		       struct regnode_charclass_class);
	    ri->regstclass = (regnode*)RExC_rxi->data->data[n];
	    r->intflags &= ~PREGf_SKIP;	/* Used in find_byclass(). */
	    DEBUG_COMPILE_r({ SV* sv = sv_newmortal();
	              regprop(r, sv, (regnode*)data.start_class);
		      PerlIO_printf(Perl_debug_log,
				    "synthetic stclass \"%s\".\n",
				    SvPVX_const(sv));});
	}
    }

    /* Guard against an embedded (?=) or (?<=) with a longer minlen than
       the "real" pattern. */
    DEBUG_OPTIMISE_r({
	PerlIO_printf(Perl_debug_log,"minlen: %"IVdf" r->minlen:%"IVdf"\n",
		      (IV)minlen, (IV)r->minlen);
    });
    r->minlenret = minlen;
    if (r->minlen < minlen) 
        r->minlen = minlen;
    
    if (RExC_seen & REG_SEEN_GPOS)
	r->extflags |= RXf_GPOS_SEEN;
    if (RExC_seen & REG_SEEN_LOOKBEHIND)
	r->extflags |= RXf_LOOKBEHIND_SEEN;
    if (RExC_seen & REG_SEEN_EVAL)
	r->extflags |= RXf_EVAL_SEEN;
    if (RExC_seen & REG_SEEN_CANY)
	r->extflags |= RXf_CANY_SEEN;
    if (RExC_seen & REG_SEEN_VERBARG)
	r->intflags |= PREGf_VERBARG_SEEN;
    if (RExC_seen & REG_SEEN_CUTGROUP)
	r->intflags |= PREGf_CUTGROUP_SEEN;
    if (RExC_paren_names)
        r->paren_names = (HV*)SvREFCNT_inc(RExC_paren_names);
    else
        r->paren_names = NULL;

#ifdef STUPID_PATTERN_CHECKS            
    if (r->prelen == 0)
        r->extflags |= RXf_NULL;
    if (r->extflags & RXf_SPLIT && r->prelen == 1 && r->precomp[0] == ' ')
        /* XXX: this should happen BEFORE we compile */
        r->extflags |= (RXf_SKIPWHITE|RXf_WHITE); 
    else if (r->prelen == 3 && memEQ("\\s+", r->precomp, 3))
        r->extflags |= RXf_WHITE;
    else if (r->prelen == 1 && r->precomp[0] == '^')
        r->extflags |= RXf_START_ONLY;
#else
    if (r->extflags & RXf_SPLIT && r->prelen == 1 && r->precomp[0] == ' ')
            /* XXX: this should happen BEFORE we compile */
            r->extflags |= (RXf_SKIPWHITE|RXf_WHITE); 
    else {
        regnode *first = ri->program + 1;
        U8 fop = OP(first);
        U8 nop = OP(NEXTOPER(first));
        
        if (PL_regkind[fop] == NOTHING && nop == END)
            r->extflags |= RXf_NULL;
        else if (PL_regkind[fop] == BOL && nop == END)
            r->extflags |= RXf_START_ONLY;
        else if (fop == PLUS && nop ==SPACE && OP(regnext(first))==END)
            r->extflags |= RXf_WHITE;    
    }
#endif
#ifdef DEBUGGING
    if (RExC_paren_names) {
        ri->name_list_idx = add_data( pRExC_state, 1, "p" );
        ri->data->data[ri->name_list_idx] = (void*)SvREFCNT_inc(RExC_paren_name_list);
    } else
#endif
        ri->name_list_idx = 0;

    if (RExC_recurse_count) {
        for ( ; RExC_recurse_count ; RExC_recurse_count-- ) {
            const regnode *scan = RExC_recurse[RExC_recurse_count-1];
            ARG2L_SET( scan, RExC_open_parens[ARG(scan)-1] - scan );
        }
    }
    Newxz(r->offs, RExC_npar, regexp_paren_pair);
    /* assume we don't need to swap parens around before we match */

    DEBUG_DUMP_r({
        PerlIO_printf(Perl_debug_log,"Final program:\n");
        regdump(r);
    });
#ifdef RE_TRACK_PATTERN_OFFSETS
    DEBUG_OFFSETS_r(if (ri->u.offsets) {
        const U32 len = ri->u.offsets[0];
        U32 i;
        GET_RE_DEBUG_FLAGS_DECL;
        PerlIO_printf(Perl_debug_log, "Offsets: [%"UVuf"]\n\t", (UV)ri->u.offsets[0]);
        for (i = 1; i <= len; i++) {
            if (ri->u.offsets[i*2-1] || ri->u.offsets[i*2])
                PerlIO_printf(Perl_debug_log, "%"UVuf":%"UVuf"[%"UVuf"] ",
                (UV)i, (UV)ri->u.offsets[i*2-1], (UV)ri->u.offsets[i*2]);
            }
        PerlIO_printf(Perl_debug_log, "\n");
    });
#endif
    return(r);
}

#undef RE_ENGINE_PTR


SV*
Perl_reg_named_buff(pTHX_ REGEXP * const rx, SV * const key, SV * const value,
                    const U32 flags)
{
    PERL_UNUSED_ARG(value);

    if (flags & RXapif_FETCH) {
        return reg_named_buff_fetch(rx, key, flags);
    } else if (flags & (RXapif_STORE | RXapif_DELETE | RXapif_CLEAR)) {
        Perl_croak(aTHX_ PL_no_modify);
        return NULL;
    } else if (flags & RXapif_EXISTS) {
        return reg_named_buff_exists(rx, key, flags)
            ? &PL_sv_yes
            : &PL_sv_no;
    } else if (flags & RXapif_REGNAMES) {
        return reg_named_buff_all(rx, flags);
    } else if (flags & (RXapif_SCALAR | RXapif_REGNAMES_COUNT)) {
        return reg_named_buff_scalar(rx, flags);
    } else {
        Perl_croak(aTHX_ "panic: Unknown flags %d in named_buff", (int)flags);
        return NULL;
    }
}

SV*
Perl_reg_named_buff_iter(pTHX_ REGEXP * const rx, const SV * const lastkey,
                         const U32 flags)
{
    PERL_UNUSED_ARG(lastkey);

    if (flags & RXapif_FIRSTKEY)
        return reg_named_buff_firstkey(rx, flags);
    else if (flags & RXapif_NEXTKEY)
        return reg_named_buff_nextkey(rx, flags);
    else {
        Perl_croak(aTHX_ "panic: Unknown flags %d in named_buff_iter", (int)flags);
        return NULL;
    }
}

SV*
Perl_reg_named_buff_fetch(pTHX_ REGEXP * const rx, SV * const namesv, const U32 flags)
{
    AV *retarray = NULL;
    SV *ret;
    if (flags & RXapif_ALL)
        retarray=newAV();

    if (rx && rx->paren_names) {
        HE *he_str = hv_fetch_ent( rx->paren_names, namesv, 0, 0 );
        if (he_str) {
            IV i;
            SV* sv_dat=HeVAL(he_str);
            I32 *nums=(I32*)SvPVX(sv_dat);
            for ( i=0; i<SvIVX(sv_dat); i++ ) {
                if ((I32)(rx->nparens) >= nums[i]
                    && rx->offs[nums[i]].start != -1
                    && rx->offs[nums[i]].end != -1)
                {
                    ret = newSVpvs("");
                    CALLREG_NUMBUF_FETCH(rx,nums[i],ret);
                    if (!retarray)
                        return ret;
                } else {
                    ret = newSVsv(&PL_sv_undef);
                }
                if (retarray) {
                    SvREFCNT_inc_simple_void(ret);
                    av_push(retarray, ret);
                }
            }
            if (retarray)
                return newRV((SV*)retarray);
        }
    }
    return NULL;
}

bool
Perl_reg_named_buff_exists(pTHX_ REGEXP * const rx, SV * const key,
                           const U32 flags)
{
    if (rx && rx->paren_names) {
        if (flags & RXapif_ALL) {
            return hv_exists_ent(rx->paren_names, key, 0);
        } else {
	    SV *sv = CALLREG_NAMED_BUFF_FETCH(rx, key, flags);
            if (sv) {
		SvREFCNT_dec(sv);
                return TRUE;
            } else {
                return FALSE;
            }
        }
    } else {
        return FALSE;
    }
}

SV*
Perl_reg_named_buff_firstkey(pTHX_ REGEXP * const rx, const U32 flags)
{
    if ( rx && rx->paren_names ) {
	(void)hv_iterinit(rx->paren_names);

	return CALLREG_NAMED_BUFF_NEXTKEY(rx, NULL, flags & ~RXapif_FIRSTKEY);
    } else {
	return FALSE;
    }
}

SV*
Perl_reg_named_buff_nextkey(pTHX_ REGEXP * const rx, const U32 flags)
{
    if (rx && rx->paren_names) {
        HV *hv = rx->paren_names;
        HE *temphe;
        while ( (temphe = hv_iternext_flags(hv,0)) ) {
            IV i;
            IV parno = 0;
            SV* sv_dat = HeVAL(temphe);
            I32 *nums = (I32*)SvPVX(sv_dat);
            for ( i = 0; i < SvIVX(sv_dat); i++ ) {
                if ((I32)(rx->lastcloseparen) >= nums[i] &&
                    rx->offs[nums[i]].start != -1 &&
                    rx->offs[nums[i]].end != -1)
                {
                    parno = nums[i];
                    break;
                }
            }
            if (parno || flags & RXapif_ALL) {
                STRLEN len;
                char *pv = HePV(temphe, len);
                return newSVpvn(pv,len);
            }
        }
    }
    return NULL;
}

SV*
Perl_reg_named_buff_scalar(pTHX_ REGEXP * const rx, const U32 flags)
{
    SV *ret;
    AV *av;
    I32 length;

    if (rx && rx->paren_names) {
        if (flags & (RXapif_ALL | RXapif_REGNAMES_COUNT)) {
            return newSViv(HvTOTALKEYS(rx->paren_names));
        } else if (flags & RXapif_ONE) {
            ret = CALLREG_NAMED_BUFF_ALL(rx, (flags | RXapif_REGNAMES));
            av = (AV*)SvRV(ret);
            length = av_len(av);
            return newSViv(length + 1);
        } else {
            Perl_croak(aTHX_ "panic: Unknown flags %d in named_buff_scalar", (int)flags);
            return NULL;
        }
    }
    return &PL_sv_undef;
}

SV*
Perl_reg_named_buff_all(pTHX_ REGEXP * const rx, const U32 flags)
{
    AV *av = newAV();

    if (rx && rx->paren_names) {
        HV *hv= rx->paren_names;
        HE *temphe;
        (void)hv_iterinit(hv);
        while ( (temphe = hv_iternext_flags(hv,0)) ) {
            IV i;
            IV parno = 0;
            SV* sv_dat = HeVAL(temphe);
            I32 *nums = (I32*)SvPVX(sv_dat);
            for ( i = 0; i < SvIVX(sv_dat); i++ ) {
                if ((I32)(rx->lastcloseparen) >= nums[i] &&
                    rx->offs[nums[i]].start != -1 &&
                    rx->offs[nums[i]].end != -1)
                {
                    parno = nums[i];
                    break;
                }
            }
            if (parno || flags & RXapif_ALL) {
                STRLEN len;
                char *pv = HePV(temphe, len);
                av_push(av, newSVpvn(pv,len));
            }
        }
    }

    return newRV((SV*)av);
}

void
Perl_reg_numbered_buff_fetch(pTHX_ REGEXP * const rx, const I32 paren, SV * const sv)
{
    char *s = NULL;
    I32 i = 0;
    I32 s1, t1;
        
    if (!rx->subbeg) {
        sv_setsv(sv,&PL_sv_undef);
        return;
    } 
    else               
    if (paren == RX_BUFF_IDX_PREMATCH && rx->offs[0].start != -1) {
        /* $` */
	i = rx->offs[0].start;
	s = rx->subbeg;
    }
    else 
    if (paren == RX_BUFF_IDX_POSTMATCH && rx->offs[0].end != -1) {
        /* $' */
	s = rx->subbeg + rx->offs[0].end;
	i = rx->sublen - rx->offs[0].end;
    } 
    else
    if ( 0 <= paren && paren <= (I32)rx->nparens &&
        (s1 = rx->offs[paren].start) != -1 &&
        (t1 = rx->offs[paren].end) != -1)
    {
        /* $& $1 ... */
        i = t1 - s1;
        s = rx->subbeg + s1;
    } else {
        sv_setsv(sv,&PL_sv_undef);
        return;
    }          
    assert(rx->sublen >= (s - rx->subbeg) + i );
    if (i >= 0) {
        const int oldtainted = PL_tainted;
        TAINT_NOT;
        sv_setpvn(sv, s, i);
        PL_tainted = oldtainted;
        if ( (rx->extflags & RXf_CANY_SEEN)
            ? (RX_MATCH_UTF8(rx)
                        && (!i || is_utf8_string((U8*)s, i)))
            : (RX_MATCH_UTF8(rx)) )
        {
            SvUTF8_on(sv);
        }
        else
            SvUTF8_off(sv);
        if (PL_tainting) {
            if (RX_MATCH_TAINTED(rx)) {
                if (SvTYPE(sv) >= SVt_PVMG) {
                    MAGIC* const mg = SvMAGIC(sv);
                    MAGIC* mgt;
                    PL_tainted = 1;
                    SvMAGIC_set(sv, mg->mg_moremagic);
                    SvTAINT(sv);
                    if ((mgt = SvMAGIC(sv))) {
                        mg->mg_moremagic = mgt;
                        SvMAGIC_set(sv, mg);
                    }
                } else {
                    PL_tainted = 1;
                    SvTAINT(sv);
                }
            } else 
                SvTAINTED_off(sv);
        }
    } else {
        sv_setsv(sv,&PL_sv_undef);
        return;
    }
}

void
Perl_reg_numbered_buff_store(pTHX_ REGEXP * const rx, const I32 paren,
							 SV const * const value)
{
    PERL_UNUSED_ARG(rx);
    PERL_UNUSED_ARG(paren);
    PERL_UNUSED_ARG(value);

    if (!PL_localizing)
        Perl_croak(aTHX_ PL_no_modify);
}

I32
Perl_reg_numbered_buff_length(pTHX_ REGEXP * const rx, const SV * const sv,
                              const I32 paren)
{
    I32 i;
    I32 s1, t1;

    /* Some of this code was originally in C<Perl_magic_len> in F<mg.c> */
	switch (paren) {
      /* $` / ${^PREMATCH} */
      case RX_BUFF_IDX_PREMATCH:
        if (rx->offs[0].start != -1) {
			i = rx->offs[0].start;
			if (i > 0) {
				s1 = 0;
				t1 = i;
				goto getlen;
			}
	    }
        return 0;
      /* $' / ${^POSTMATCH} */
      case RX_BUFF_IDX_POSTMATCH:
	    if (rx->offs[0].end != -1) {
			i = rx->sublen - rx->offs[0].end;
			if (i > 0) {
				s1 = rx->offs[0].end;
				t1 = rx->sublen;
				goto getlen;
			}
	    }
        return 0;
      /* $& / ${^MATCH}, $1, $2, ... */
      default:
	    if (paren <= (I32)rx->nparens &&
            (s1 = rx->offs[paren].start) != -1 &&
            (t1 = rx->offs[paren].end) != -1)
	    {
            i = t1 - s1;
            goto getlen;
        } else {
            if (ckWARN(WARN_UNINITIALIZED))
                report_uninit((SV*)sv);
            return 0;
        }
    }
  getlen:
    if (i > 0 && RX_MATCH_UTF8(rx)) {
        const char * const s = rx->subbeg + s1;
        const U8 *ep;
        STRLEN el;

        i = t1 - s1;
        if (is_utf8_string_loclen((U8*)s, i, &ep, &el))
			i = el;
    }
    return i;
}
d2035 14
a2048 6
SV*
Perl_reg_qr_package(pTHX_ REGEXP * const rx)
{
	PERL_UNUSED_ARG(rx);
	return newSVpvs("Regexp");
}
d2050 40
a2089 7
/* Scans the name of a named buffer from the pattern.
 * If flags is REG_RSN_RETURN_NULL returns null.
 * If flags is REG_RSN_RETURN_NAME returns an SV* containing the name
 * If flags is REG_RSN_RETURN_DATA returns the data SV* corresponding
 * to the parsed name as looked up in the RExC_paren_names hash.
 * If there is an error throws a vFAIL().. type exception.
 */
d2091 13
a2103 18
#define REG_RSN_RETURN_NULL    0
#define REG_RSN_RETURN_NAME    1
#define REG_RSN_RETURN_DATA    2

STATIC SV*
S_reg_scan_name(pTHX_ RExC_state_t *pRExC_state, U32 flags) {
    char *name_start = RExC_parse;

    if (isIDFIRST_lazy_if(RExC_parse, UTF)) {
	 /* skip IDFIRST by using do...while */
	if (UTF)
	    do {
		RExC_parse += UTF8SKIP(RExC_parse);
	    } while (isALNUM_utf8((U8*)RExC_parse));
	else
	    do {
		RExC_parse++;
	    } while (isALNUM(*RExC_parse));
d2106 14
a2119 26
    if ( flags ) {
        SV* sv_name = sv_2mortal(Perl_newSVpvn(aTHX_ name_start,
            (int)(RExC_parse - name_start)));
	if (UTF)
            SvUTF8_on(sv_name);
        if ( flags == REG_RSN_RETURN_NAME)
            return sv_name;
        else if (flags==REG_RSN_RETURN_DATA) {
            HE *he_str = NULL;
            SV *sv_dat = NULL;
            if ( ! sv_name )      /* should not happen*/
                Perl_croak(aTHX_ "panic: no svname in reg_scan_name");
            if (RExC_paren_names)
                he_str = hv_fetch_ent( RExC_paren_names, sv_name, 0, 0 );
            if ( he_str )
                sv_dat = HeVAL(he_str);
            if ( ! sv_dat )
                vFAIL("Reference to nonexistent named group");
            return sv_dat;
        }
        else {
            Perl_croak(aTHX_ "panic: bad flag in reg_scan_name");
        }
        /* NOT REACHED */
    }
    return NULL;
a2121 45
#define DEBUG_PARSE_MSG(funcname)     DEBUG_PARSE_r({           \
    int rem=(int)(RExC_end - RExC_parse);                       \
    int cut;                                                    \
    int num;                                                    \
    int iscut=0;                                                \
    if (rem>10) {                                               \
        rem=10;                                                 \
        iscut=1;                                                \
    }                                                           \
    cut=10-rem;                                                 \
    if (RExC_lastparse!=RExC_parse)                             \
        PerlIO_printf(Perl_debug_log," >%.*s%-*s",              \
            rem, RExC_parse,                                    \
            cut + 4,                                            \
            iscut ? "..." : "<"                                 \
        );                                                      \
    else                                                        \
        PerlIO_printf(Perl_debug_log,"%16s","");                \
                                                                \
    if (SIZE_ONLY)                                              \
       num = RExC_size + 1;                                     \
    else                                                        \
       num=REG_NODE_NUM(RExC_emit);                             \
    if (RExC_lastnum!=num)                                      \
       PerlIO_printf(Perl_debug_log,"|%4d",num);                \
    else                                                        \
       PerlIO_printf(Perl_debug_log,"|%4s","");                 \
    PerlIO_printf(Perl_debug_log,"|%*s%-4s",                    \
        (int)((depth*2)), "",                                   \
        (funcname)                                              \
    );                                                          \
    RExC_lastnum=num;                                           \
    RExC_lastparse=RExC_parse;                                  \
})



#define DEBUG_PARSE(funcname)     DEBUG_PARSE_r({           \
    DEBUG_PARSE_MSG((funcname));                            \
    PerlIO_printf(Perl_debug_log,"%4s","\n");               \
})
#define DEBUG_PARSE_FMT(funcname,fmt,args)     DEBUG_PARSE_r({           \
    DEBUG_PARSE_MSG((funcname));                            \
    PerlIO_printf(Perl_debug_log,fmt "\n",args);               \
})
a2130 7
#define REGTAIL(x,y,z) regtail((x),(y),(z),depth+1)
#ifdef DEBUGGING
#define REGTAIL_STUDY(x,y,z) regtail_study((x),(y),(z),depth+1)
#else
#define REGTAIL_STUDY(x,y,z) regtail((x),(y),(z),depth+1)
#endif

d2132 1
a2132 1
S_reg(pTHX_ RExC_state_t *pRExC_state, I32 paren, I32 *flagp,U32 depth)
a2134 1
    dVAR;
d2138 1
a2138 1
    register regnode *ender = NULL;
d2140 1
a2140 6
    I32 flags;
    U32 oregflags = RExC_flags;
    bool have_branch = 0;
    bool is_open = 0;
    I32 freeze_paren = 0;
    I32 after_freeze = 0;
d2145 5
a2149 5
#define WASTED_O  0x01
#define WASTED_G  0x02
#define WASTED_C  0x04
#define WASTED_GC (0x02|0x04)
    I32 wastedflags = 0x00;
d2153 1
a2153 3

    GET_RE_DEBUG_FLAGS_DECL;
    DEBUG_PARSE("reg ");
a2159 105
        if ( *RExC_parse == '*') { /* (*VERB:ARG) */
	    char *start_verb = RExC_parse;
	    STRLEN verb_len = 0;
	    char *start_arg = NULL;
	    unsigned char op = 0;
	    int argok = 1;
	    int internal_argval = 0; /* internal_argval is only useful if !argok */
	    while ( *RExC_parse && *RExC_parse != ')' ) {
	        if ( *RExC_parse == ':' ) {
	            start_arg = RExC_parse + 1;
	            break;
	        }
	        RExC_parse++;
	    }
	    ++start_verb;
	    verb_len = RExC_parse - start_verb;
	    if ( start_arg ) {
	        RExC_parse++;
	        while ( *RExC_parse && *RExC_parse != ')' ) 
	            RExC_parse++;
	        if ( *RExC_parse != ')' ) 
	            vFAIL("Unterminated verb pattern argument");
	        if ( RExC_parse == start_arg )
	            start_arg = NULL;
	    } else {
	        if ( *RExC_parse != ')' )
	            vFAIL("Unterminated verb pattern");
	    }
	    
	    switch ( *start_verb ) {
            case 'A':  /* (*ACCEPT) */
                if ( memEQs(start_verb,verb_len,"ACCEPT") ) {
		    op = ACCEPT;
		    internal_argval = RExC_nestroot;
		}
		break;
            case 'C':  /* (*COMMIT) */
                if ( memEQs(start_verb,verb_len,"COMMIT") )
                    op = COMMIT;
                break;
            case 'F':  /* (*FAIL) */
                if ( verb_len==1 || memEQs(start_verb,verb_len,"FAIL") ) {
		    op = OPFAIL;
		    argok = 0;
		}
		break;
            case ':':  /* (*:NAME) */
	    case 'M':  /* (*MARK:NAME) */
	        if ( verb_len==0 || memEQs(start_verb,verb_len,"MARK") ) {
                    op = MARKPOINT;
                    argok = -1;
                }
                break;
            case 'P':  /* (*PRUNE) */
                if ( memEQs(start_verb,verb_len,"PRUNE") )
                    op = PRUNE;
                break;
            case 'S':   /* (*SKIP) */  
                if ( memEQs(start_verb,verb_len,"SKIP") ) 
                    op = SKIP;
                break;
            case 'T':  /* (*THEN) */
                /* [19:06] <TimToady> :: is then */
                if ( memEQs(start_verb,verb_len,"THEN") ) {
                    op = CUTGROUP;
                    RExC_seen |= REG_SEEN_CUTGROUP;
                }
                break;
	    }
	    if ( ! op ) {
	        RExC_parse++;
	        vFAIL3("Unknown verb pattern '%.*s'",
	            verb_len, start_verb);
	    }
	    if ( argok ) {
                if ( start_arg && internal_argval ) {
	            vFAIL3("Verb pattern '%.*s' may not have an argument",
	                verb_len, start_verb); 
	        } else if ( argok < 0 && !start_arg ) {
                    vFAIL3("Verb pattern '%.*s' has a mandatory argument",
	                verb_len, start_verb);    
	        } else {
	            ret = reganode(pRExC_state, op, internal_argval);
	            if ( ! internal_argval && ! SIZE_ONLY ) {
                        if (start_arg) {
                            SV *sv = newSVpvn( start_arg, RExC_parse - start_arg);
                            ARG(ret) = add_data( pRExC_state, 1, "S" );
                            RExC_rxi->data->data[ARG(ret)]=(void*)sv;
                            ret->flags = 0;
                        } else {
                            ret->flags = 1; 
                        }
                    }	            
	        }
	        if (!internal_argval)
	            RExC_seen |= REG_SEEN_VERBARG;
	    } else if ( start_arg ) {
	        vFAIL3("Verb pattern '%.*s' may not have an argument",
	                verb_len, start_verb);    
	    } else {
	        ret = reg_node(pRExC_state, op);
	    }
	    nextchar(pRExC_state);
	    return ret;
        } else 
d2161 3
a2163 1
	    bool is_logical = 0;
d2170 2
a2171 39

	    case 'P':	/* (?P...) variants for those used to PCRE/Python */
	        paren = *RExC_parse++;
		if ( paren == '<')         /* (?P<...>) named capture */
		    goto named_capture;
                else if (paren == '>') {   /* (?P>name) named recursion */
                    goto named_recursion;
                }
                else if (paren == '=') {   /* (?P=...)  named backref */
                    /* this pretty much dupes the code for \k<NAME> in regatom(), if
                       you change this make sure you change that */
                    char* name_start = RExC_parse;
		    U32 num = 0;
                    SV *sv_dat = reg_scan_name(pRExC_state,
                        SIZE_ONLY ? REG_RSN_RETURN_NULL : REG_RSN_RETURN_DATA);
                    if (RExC_parse == name_start || *RExC_parse != ')')
                        vFAIL2("Sequence %.3s... not terminated",parse_start);

                    if (!SIZE_ONLY) {
                        num = add_data( pRExC_state, 1, "S" );
                        RExC_rxi->data->data[num]=(void*)sv_dat;
                        SvREFCNT_inc_simple_void(sv_dat);
                    }
                    RExC_sawback = 1;
                    ret = reganode(pRExC_state,
                    	   (U8)(FOLD ? (LOC ? NREFFL : NREFF) : NREF),
                    	   num);
                    *flagp |= HASWIDTH;

                    Set_Node_Offset(ret, parse_start+1);
                    Set_Node_Cur_Length(ret); /* MJD */

                    nextchar(pRExC_state);
                    return ret;
                }
                RExC_parse++;
		vFAIL3("Sequence (%.*s...) not recognized", RExC_parse-seqstart, seqstart);
		/*NOTREACHED*/
            case '<':           /* (?<...) */
d2174 2
a2175 80
		else if (*RExC_parse != '=') 
              named_capture:
		{               /* (?<...>) */
		    char *name_start;
		    SV *svname;
		    paren= '>';
            case '\'':          /* (?'...') */
    		    name_start= RExC_parse;
    		    svname = reg_scan_name(pRExC_state,
    		        SIZE_ONLY ?  /* reverse test from the others */
    		        REG_RSN_RETURN_NAME : 
    		        REG_RSN_RETURN_NULL);
		    if (RExC_parse == name_start) {
		        RExC_parse++;
		        vFAIL3("Sequence (%.*s...) not recognized", RExC_parse-seqstart, seqstart);
		        /*NOTREACHED*/
                    }
		    if (*RExC_parse != paren)
		        vFAIL2("Sequence (?%c... not terminated",
		            paren=='>' ? '<' : paren);
		    if (SIZE_ONLY) {
			HE *he_str;
			SV *sv_dat = NULL;
                        if (!svname) /* shouldnt happen */
                            Perl_croak(aTHX_
                                "panic: reg_scan_name returned NULL");
                        if (!RExC_paren_names) {
                            RExC_paren_names= newHV();
                            sv_2mortal((SV*)RExC_paren_names);
#ifdef DEBUGGING
                            RExC_paren_name_list= newAV();
                            sv_2mortal((SV*)RExC_paren_name_list);
#endif
                        }
                        he_str = hv_fetch_ent( RExC_paren_names, svname, 1, 0 );
                        if ( he_str )
                            sv_dat = HeVAL(he_str);
                        if ( ! sv_dat ) {
                            /* croak baby croak */
                            Perl_croak(aTHX_
                                "panic: paren_name hash element allocation failed");
                        } else if ( SvPOK(sv_dat) ) {
                            /* (?|...) can mean we have dupes so scan to check
                               its already been stored. Maybe a flag indicating
                               we are inside such a construct would be useful,
                               but the arrays are likely to be quite small, so
                               for now we punt -- dmq */
                            IV count = SvIV(sv_dat);
                            I32 *pv = (I32*)SvPVX(sv_dat);
                            IV i;
                            for ( i = 0 ; i < count ; i++ ) {
                                if ( pv[i] == RExC_npar ) {
                                    count = 0;
                                    break;
                                }
                            }
                            if ( count ) {
                                pv = (I32*)SvGROW(sv_dat, SvCUR(sv_dat) + sizeof(I32)+1);
                                SvCUR_set(sv_dat, SvCUR(sv_dat) + sizeof(I32));
                                pv[count] = RExC_npar;
                                SvIVX(sv_dat)++;
                            }
                        } else {
                            (void)SvUPGRADE(sv_dat,SVt_PVNV);
                            sv_setpvn(sv_dat, (char *)&(RExC_npar), sizeof(I32));
                            SvIOK_on(sv_dat);
                            SvIVX(sv_dat)= 1;
                        }
#ifdef DEBUGGING
                        if (!av_store(RExC_paren_name_list, RExC_npar, SvREFCNT_inc(svname)))
                            SvREFCNT_dec(svname);
#endif

                        /*sv_dump(sv_dat);*/
                    }
                    nextchar(pRExC_state);
		    paren = 1;
		    goto capturing_parens;
		}
                RExC_seen |= REG_SEEN_LOOKBEHIND;
a2179 12
	        if (*RExC_parse == ')') {
	            ret=reg_node(pRExC_state, OPFAIL);
	            nextchar(pRExC_state);
	            return ret;
	        }
	        break;
	    case '|':           /* (?|...) */
	        /* branch reset, behave like a (?:...) except that
	           buffers in alternations share the same numbers */
	        paren = ':'; 
	        after_freeze = freeze_paren = RExC_npar;
	        break;
d2195 4
a2198 92
	    case '0' :           /* (?0) */
	    case 'R' :           /* (?R) */
		if (*RExC_parse != ')')
		    FAIL("Sequence (?R) not terminated");
		ret = reg_node(pRExC_state, GOSTART);
		*flagp |= POSTPONED;
		nextchar(pRExC_state);
		return ret;
		/*notreached*/
            { /* named and numeric backreferences */
                I32 num;
            case '&':            /* (?&NAME) */
                parse_start = RExC_parse - 1;
              named_recursion:
                {
    		    SV *sv_dat = reg_scan_name(pRExC_state,
    		        SIZE_ONLY ? REG_RSN_RETURN_NULL : REG_RSN_RETURN_DATA);
    		     num = sv_dat ? *((I32 *)SvPVX(sv_dat)) : 0;
                }
                goto gen_recurse_regop;
                /* NOT REACHED */
            case '+':
                if (!(RExC_parse[0] >= '1' && RExC_parse[0] <= '9')) {
                    RExC_parse++;
                    vFAIL("Illegal pattern");
                }
                goto parse_recursion;
                /* NOT REACHED*/
            case '-': /* (?-1) */
                if (!(RExC_parse[0] >= '1' && RExC_parse[0] <= '9')) {
                    RExC_parse--; /* rewind to let it be handled later */
                    goto parse_flags;
                } 
                /*FALLTHROUGH */
            case '1': case '2': case '3': case '4': /* (?1) */
	    case '5': case '6': case '7': case '8': case '9':
	        RExC_parse--;
              parse_recursion:
		num = atoi(RExC_parse);
  	        parse_start = RExC_parse - 1; /* MJD */
	        if (*RExC_parse == '-')
	            RExC_parse++;
		while (isDIGIT(*RExC_parse))
			RExC_parse++;
	        if (*RExC_parse!=')') 
	            vFAIL("Expecting close bracket");
			
              gen_recurse_regop:
                if ( paren == '-' ) {
                    /*
                    Diagram of capture buffer numbering.
                    Top line is the normal capture buffer numbers
                    Botton line is the negative indexing as from
                    the X (the (?-2))

                    +   1 2    3 4 5 X          6 7
                       /(a(x)y)(a(b(c(?-2)d)e)f)(g(h))/
                    -   5 4    3 2 1 X          x x

                    */
                    num = RExC_npar + num;
                    if (num < 1)  {
                        RExC_parse++;
                        vFAIL("Reference to nonexistent group");
                    }
                } else if ( paren == '+' ) {
                    num = RExC_npar + num - 1;
                }

                ret = reganode(pRExC_state, GOSUB, num);
                if (!SIZE_ONLY) {
		    if (num > (I32)RExC_rx->nparens) {
			RExC_parse++;
			vFAIL("Reference to nonexistent group");
	            }
	            ARG2L_SET( ret, RExC_recurse_count++);
                    RExC_emit++;
		    DEBUG_OPTIMISE_MORE_r(PerlIO_printf(Perl_debug_log,
			"Recurse #%"UVuf" to %"IVdf"\n", (UV)ARG(ret), (IV)ARG2L(ret)));
		} else {
		    RExC_size++;
    		}
    		RExC_seen |= REG_SEEN_RECURSE;
                Set_Node_Length(ret, 1 + regarglen[OP(ret)]); /* MJD */
		Set_Node_Offset(ret, parse_start); /* MJD */

                *flagp |= POSTPONED;
                nextchar(pRExC_state);
                return ret;
            } /* named and numeric backreferences */
            /* NOT REACHED */

d2200 3
a2202 7
		is_logical = 1;
		if (*RExC_parse != '{') {
		    RExC_parse++;
		    vFAIL3("Sequence (%.*s...) not recognized", RExC_parse-seqstart, seqstart);
		    /*NOTREACHED*/
		}
		*flagp |= POSTPONED;
d2207 1
a2207 2
		I32 count = 1;
		U32 n = 0;
d2210 2
d2216 2
a2217 4
		    if (c == '\\') {
			if (RExC_parse[1])
			    RExC_parse++;
		    }
d2224 2
a2225 1
		if (*RExC_parse != ')') {
d2231 5
a2235 2
		    OP_4tree *sop, *rop;
		    SV * const sv = newSVpvn(s, RExC_parse - 1 - s);
d2246 3
a2248 3
		    RExC_rxi->data->data[n] = (void*)rop;
		    RExC_rxi->data->data[n+1] = (void*)sop;
		    RExC_rxi->data->data[n+2] = (void*)pad;
a2258 4
#if PERL_VERSION > 8
		    if (IN_PERL_COMPILETIME)
			PL_cv_has_eval = 1;
#endif
d2260 1
a2260 1

d2262 1
a2262 1
		if (is_logical) {
d2266 1
a2266 1
                    REGTAIL(pRExC_state, ret, reganode(pRExC_state, EVAL, n));
a2276 1
	        int is_define= 0;
d2286 1
a2286 1
                        REGTAIL(pRExC_state, ret, reg(pRExC_state, 1, &flag,depth+1));
a2289 49
		else if ( RExC_parse[0] == '<'     /* (?(<NAME>)...) */
		         || RExC_parse[0] == '\'' ) /* (?('NAME')...) */
	        {
	            char ch = RExC_parse[0] == '<' ? '>' : '\'';
	            char *name_start= RExC_parse++;
	            U32 num = 0;
	            SV *sv_dat=reg_scan_name(pRExC_state,
	                SIZE_ONLY ? REG_RSN_RETURN_NULL : REG_RSN_RETURN_DATA);
	            if (RExC_parse == name_start || *RExC_parse != ch)
                        vFAIL2("Sequence (?(%c... not terminated",
                            (ch == '>' ? '<' : ch));
                    RExC_parse++;
	            if (!SIZE_ONLY) {
                        num = add_data( pRExC_state, 1, "S" );
                        RExC_rxi->data->data[num]=(void*)sv_dat;
                        SvREFCNT_inc_simple_void(sv_dat);
                    }
                    ret = reganode(pRExC_state,NGROUPP,num);
                    goto insert_if_check_paren;
		}
		else if (RExC_parse[0] == 'D' &&
		         RExC_parse[1] == 'E' &&
		         RExC_parse[2] == 'F' &&
		         RExC_parse[3] == 'I' &&
		         RExC_parse[4] == 'N' &&
		         RExC_parse[5] == 'E')
		{
		    ret = reganode(pRExC_state,DEFINEP,0);
		    RExC_parse +=6 ;
		    is_define = 1;
		    goto insert_if_check_paren;
		}
		else if (RExC_parse[0] == 'R') {
		    RExC_parse++;
		    parno = 0;
		    if (RExC_parse[0] >= '1' && RExC_parse[0] <= '9' ) {
		        parno = atoi(RExC_parse++);
		        while (isDIGIT(*RExC_parse))
			    RExC_parse++;
		    } else if (RExC_parse[0] == '&') {
		        SV *sv_dat;
		        RExC_parse++;
		        sv_dat = reg_scan_name(pRExC_state,
    		            SIZE_ONLY ? REG_RSN_RETURN_NULL : REG_RSN_RETURN_DATA);
    		        parno = sv_dat ? *((I32 *)SvPVX(sv_dat)) : 0;
		    }
		    ret = reganode(pRExC_state,INSUBP,parno); 
		    goto insert_if_check_paren;
		}
a2291 1
		    char c;
a2297 1
                 insert_if_check_paren:
d2301 2
a2302 2
                    REGTAIL(pRExC_state, ret, reganode(pRExC_state, IFTHEN, 0));
                    br = regbranch(pRExC_state, &flags, 1,depth+1);
d2306 1
a2306 1
                        REGTAIL(pRExC_state, br, reganode(pRExC_state, LONGJMP, 0));
a2310 2
		        if (is_define) 
		            vFAIL("(?(DEFINE)....) does not allow branches");
d2312 2
a2313 2
                        regbranch(pRExC_state, &flags, 1,depth+1);
                        REGTAIL(pRExC_state, ret, lastbr);
d2323 1
a2323 1
                    REGTAIL(pRExC_state, br, ender);
d2325 2
a2326 2
                        REGTAIL(pRExC_state, lastbr, ender);
                        REGTAIL(pRExC_state, NEXTOPER(NEXTOPER(lastbr)), ender);
d2329 1
a2329 4
                        REGTAIL(pRExC_state, ret, ender);
                    RExC_size++; /* XXX WHY do we need this?!!
                                    For large programs it seems to be required
                                    but I can't figure out why. -- dmq*/
d2341 3
a2343 8
	        --RExC_parse;
	        parse_flags:      /* (?i) */  
	    {
                U32 posflags = 0, negflags = 0;
	        U32 *flagsp = &posflags;

		while (*RExC_parse) {
		    /* && strchr("iogcmsx", *RExC_parse) */
d2346 2
a2347 4
                    switch (*RExC_parse) {
	            CASE_STD_PMMOD_FLAGS_PARSE_SET(flagsp);
                    case ONCE_PAT_MOD: /* 'o' */
                    case GLOBAL_PAT_MOD: /* 'g' */
d2349 1
a2349 1
			    const I32 wflagbit = *RExC_parse == 'o' ? WASTED_O : WASTED_G;
d2362 2
a2363 3
			break;
		        
		    case CONTINUE_PAT_MOD: /* 'c' */
d2365 2
a2366 2
			    if (! (wastedflags & WASTED_C) ) {
				wastedflags |= WASTED_GC;
d2375 8
a2382 42
			break;
	            case KEEPCOPY_PAT_MOD: /* 'p' */
                        if (flagsp == &negflags) {
                            if (SIZE_ONLY && ckWARN(WARN_REGEXP))
                                vWARN(RExC_parse + 1,"Useless use of (?-p)");
                        } else {
                            *flagsp |= RXf_PMf_KEEPCOPY;
                        }
	                break;
                    case '-':
                        if (flagsp == &negflags) {
                            RExC_parse++;
		            vFAIL3("Sequence (%.*s...) not recognized", RExC_parse-seqstart, seqstart);
		            /*NOTREACHED*/
		        }
			flagsp = &negflags;
		        wastedflags = 0;  /* reset so (?g-c) warns twice */
		        break;
                    case ':':
		        paren = ':';
		        /*FALLTHROUGH*/
                    case ')':
                        RExC_flags |= posflags;
                        RExC_flags &= ~negflags;
                        if (paren != ':') {
                            oregflags |= posflags;
                            oregflags &= ~negflags;
                        }
                        nextchar(pRExC_state);
		        if (paren != ':') {
		            *flagp = TRYAGAIN;
		            return NULL;
		        } else {
                            ret = NULL;
		            goto parse_rest;
		        }
		        /*NOTREACHED*/
                    default:
		        RExC_parse++;
		        vFAIL3("Sequence (%.*s...) not recognized", RExC_parse-seqstart, seqstart);
		        /*NOTREACHED*/
                    }                           
d2384 13
d2398 4
a2401 1
	    }} /* one for the default block, one for the switch */
a2403 1
	  capturing_parens:
a2405 1
	    
a2406 12
	    if (!SIZE_ONLY ){
	        if (!RExC_nestroot) 
	            RExC_nestroot = parno;
	        if (RExC_seen & REG_SEEN_RECURSE
	            && !RExC_open_parens[parno-1])
	        {
		    DEBUG_OPTIMISE_MORE_r(PerlIO_printf(Perl_debug_log,
			"Setting open paren #%"IVdf" to %d\n", 
			(IV)parno, REG_NODE_NUM(ret)));
	            RExC_open_parens[parno-1]= ret;
	        }
	    }
d2409 1
a2409 1
	    is_open = 1;
d2414 1
a2414 2
   
   parse_rest:
d2417 1
a2417 1
    br = regbranch(pRExC_state, &flags, 1,depth+1);
d2424 1
a2424 1
	    reginsert(pRExC_state, BRANCHJ, br, depth+1);
d2427 1
a2427 1
	    reginsert(pRExC_state, BRANCH, br, depth+1);
d2438 2
a2439 2
    if (is_open) {				/* Starts with OPEN. */
        REGTAIL(pRExC_state, ret, br);          /* OPEN -> first. */
d2443 1
a2443 1
    *flagp |= flags & (SPSTART | HASWIDTH | POSTPONED);
d2448 1
a2448 1
            REGTAIL(pRExC_state, NEXTOPER(NEXTOPER(lastbr)), ender); /* Append to the previous. */
d2453 1
a2453 6
	if (freeze_paren) {
	    if (RExC_npar > after_freeze)
	        after_freeze = RExC_npar;
            RExC_npar = freeze_paren;	    
        }
        br = regbranch(pRExC_state, &flags, 0, depth+1);
d2457 1
a2457 1
        REGTAIL(pRExC_state, lastbr, br);               /* BRANCH -> BRANCH. */
d2459 3
a2461 1
	*flagp |= flags & (SPSTART | HASWIDTH | POSTPONED);
a2471 8
	    if (!SIZE_ONLY && RExC_seen & REG_SEEN_RECURSE) {
		DEBUG_OPTIMISE_MORE_r(PerlIO_printf(Perl_debug_log,
			"Setting close paren #%"IVdf" to %d\n", 
			(IV)parno, REG_NODE_NUM(ender)));
	        RExC_close_parens[parno-1]= ender;
	        if (RExC_nestroot == parno) 
	            RExC_nestroot = 0;
	    }	    
a2485 4
	    if (!SIZE_ONLY) {
                assert(!RExC_opend); /* there can only be one! */
                RExC_opend = ender;
            }
d2488 1
a2488 5
        REGTAIL(pRExC_state, lastbr, ender);

	if (have_branch && !SIZE_ONLY) {
	    if (depth==1)
	        RExC_seen |= REG_TOP_LEVEL_BRANCHES;
d2490 1
d2492 2
a2493 8
	    for (br = ret; br; br = regnext(br)) {
		const U8 op = PL_regkind[OP(br)];
		if (op == BRANCH) {
                    REGTAIL_STUDY(pRExC_state, NEXTOPER(br), ender);
		}
		else if (op == BRANCHJ) {
                    REGTAIL_STUDY(pRExC_state, NEXTOPER(NEXTOPER(br)), ender);
		}
d2508 1
a2508 1
	    reginsert(pRExC_state, node,ret, depth+1);
d2512 1
a2512 1
            REGTAIL_STUDY(pRExC_state, ret, reg_node(pRExC_state, TAIL));
d2533 1
a2533 2
    if (after_freeze)
        RExC_npar = after_freeze;
d2543 1
a2543 1
S_regbranch(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, I32 first, U32 depth)
a2544 1
    dVAR;
a2548 2
    GET_RE_DEBUG_FLAGS_DECL;
    DEBUG_PARSE("brnc");
d2570 1
a2570 1
        latest = regpiece(pRExC_state, &flags,depth+1);
d2578 1
a2578 1
	*flagp |= flags&(HASWIDTH|POSTPONED);
d2583 1
a2583 1
            REGTAIL(pRExC_state, chain, latest);
d2597 1
a2597 1
    return ret;
d2610 1
a2610 1
S_regpiece(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, U32 depth)
a2611 1
    dVAR;
d2617 1
a2620 3
    const char *maxpos = NULL;
    GET_RE_DEBUG_FLAGS_DECL;
    DEBUG_PARSE("piec");
d2622 1
a2622 1
    ret = regatom(pRExC_state, &flags,depth+1);
a2631 1
	maxpos = NULL;
d2634 1
d2664 1
a2664 1
		reginsert(pRExC_state, CURLY, ret, depth+1);
d2669 1
a2669 1
		regnode * const w = reg_node(pRExC_state, WHILEM);
d2672 1
a2672 1
                REGTAIL(pRExC_state, ret, w);
d2674 2
a2675 2
		    reginsert(pRExC_state, LONGJMP,ret, depth+1);
		    reginsert(pRExC_state, NOTHING,ret, depth+1);
d2678 1
a2678 1
		reginsert(pRExC_state, CURLYX,ret, depth+1);
d2686 1
a2686 1
                REGTAIL(pRExC_state, ret, reg_node(pRExC_state, NOTHING));
d2735 1
a2735 1
	reginsert(pRExC_state, STAR, ret, depth+1);
d2744 1
a2744 1
	reginsert(pRExC_state, PLUS, ret, depth+1);
d2757 1
a2757 1
    if (!SIZE_ONLY && !(flags&(HASWIDTH|POSTPONED)) && max > REG_INFTY/3 && ckWARN(WARN_REGEXP)) {
d2760 1
a2760 1
	       (int)(RExC_parse >= origparse ? RExC_parse - origparse : 0),
d2764 1
a2764 1
    if (RExC_parse < RExC_end && *RExC_parse == '?') {
d2766 2
a2767 16
	reginsert(pRExC_state, MINMOD, ret, depth+1);
        REGTAIL(pRExC_state, ret, ret + NODE_STEP_REGNODE);
    }
#ifndef REG_ALLOW_MINMOD_SUSPEND
    else
#endif
    if (RExC_parse < RExC_end && *RExC_parse == '+') {
        regnode *ender;
        nextchar(pRExC_state);
        ender = reg_node(pRExC_state, SUCCEED);
        REGTAIL(pRExC_state, ret, ender);
        reginsert(pRExC_state, SUSPEND, ret, depth+1);
        ret->flags = 0;
        ender = reg_node(pRExC_state, TAIL);
        REGTAIL(pRExC_state, ret, ender);
        /*ret= ender;*/
d2769 1
a2769 2

    if (RExC_parse < RExC_end && ISMULT2(RExC_parse)) {
a2776 272

/* reg_namedseq(pRExC_state,UVp)
   
   This is expected to be called by a parser routine that has 
   recognized'\N' and needs to handle the rest. RExC_parse is 
   expected to point at the first char following the N at the time
   of the call.
   
   If valuep is non-null then it is assumed that we are parsing inside 
   of a charclass definition and the first codepoint in the resolved
   string is returned via *valuep and the routine will return NULL. 
   In this mode if a multichar string is returned from the charnames 
   handler a warning will be issued, and only the first char in the 
   sequence will be examined. If the string returned is zero length
   then the value of *valuep is undefined and NON-NULL will 
   be returned to indicate failure. (This will NOT be a valid pointer 
   to a regnode.)
   
   If value is null then it is assumed that we are parsing normal text
   and inserts a new EXACT node into the program containing the resolved
   string and returns a pointer to the new node. If the string is 
   zerolength a NOTHING node is emitted.
   
   On success RExC_parse is set to the char following the endbrace.
   Parsing failures will generate a fatal errorvia vFAIL(...)
   
   NOTE: We cache all results from the charnames handler locally in 
   the RExC_charnames hash (created on first use) to prevent a charnames 
   handler from playing silly-buggers and returning a short string and 
   then a long string for a given pattern. Since the regexp program 
   size is calculated during an initial parse this would result
   in a buffer overrun so we cache to prevent the charname result from
   changing during the course of the parse.
   
 */
STATIC regnode *
S_reg_namedseq(pTHX_ RExC_state_t *pRExC_state, UV *valuep) 
{
    char * name;        /* start of the content of the name */
    char * endbrace;    /* endbrace following the name */
    SV *sv_str = NULL;  
    SV *sv_name = NULL;
    STRLEN len; /* this has various purposes throughout the code */
    bool cached = 0; /* if this is true then we shouldn't refcount dev sv_str */
    regnode *ret = NULL;
    
    if (*RExC_parse != '{') {
        vFAIL("Missing braces on \\N{}");
    }
    name = RExC_parse+1;
    endbrace = strchr(RExC_parse, '}');
    if ( ! endbrace ) {
        RExC_parse++;
        vFAIL("Missing right brace on \\N{}");
    } 
    RExC_parse = endbrace + 1;  
    
    
    /* RExC_parse points at the beginning brace, 
       endbrace points at the last */
    if ( name[0]=='U' && name[1]=='+' ) {
        /* its a "Unicode hex" notation {U+89AB} */
        I32 fl = PERL_SCAN_ALLOW_UNDERSCORES
            | PERL_SCAN_DISALLOW_PREFIX
            | (SIZE_ONLY ? PERL_SCAN_SILENT_ILLDIGIT : 0);
        UV cp;
	char string;
        len = (STRLEN)(endbrace - name - 2);
        cp = grok_hex(name + 2, &len, &fl, NULL);
        if ( len != (STRLEN)(endbrace - name - 2) ) {
            cp = 0xFFFD;
        }    
        if (cp > 0xff)
            RExC_utf8 = 1;
        if ( valuep ) {
            *valuep = cp;
            return NULL;
        }
	string = (char)cp;
        sv_str= newSVpvn(&string, 1);
    } else {
        /* fetch the charnames handler for this scope */
        HV * const table = GvHV(PL_hintgv);
        SV **cvp= table ? 
            hv_fetchs(table, "charnames", FALSE) :
            NULL;
        SV *cv= cvp ? *cvp : NULL;
        HE *he_str;
        int count;
        /* create an SV with the name as argument */
        sv_name = newSVpvn(name, endbrace - name);
        
        if (!table || !(PL_hints & HINT_LOCALIZE_HH)) {
            vFAIL2("Constant(\\N{%s}) unknown: "
                  "(possibly a missing \"use charnames ...\")",
                  SvPVX(sv_name));
        }
        if (!cvp || !SvOK(*cvp)) { /* when $^H{charnames} = undef; */
            vFAIL2("Constant(\\N{%s}): "
                  "$^H{charnames} is not defined",SvPVX(sv_name));
        }
        
        
        
        if (!RExC_charnames) {
            /* make sure our cache is allocated */
            RExC_charnames = newHV();
            sv_2mortal((SV*)RExC_charnames);
        } 
            /* see if we have looked this one up before */
        he_str = hv_fetch_ent( RExC_charnames, sv_name, 0, 0 );
        if ( he_str ) {
            sv_str = HeVAL(he_str);
            cached = 1;
        } else {
            dSP ;

            ENTER ;
            SAVETMPS ;
            PUSHMARK(SP) ;
            
            XPUSHs(sv_name);
            
            PUTBACK ;
            
            count= call_sv(cv, G_SCALAR);
            
            if (count == 1) { /* XXXX is this right? dmq */
                sv_str = POPs;
                SvREFCNT_inc_simple_void(sv_str);
            } 
            
            SPAGAIN ;
            PUTBACK ;
            FREETMPS ;
            LEAVE ;
            
            if ( !sv_str || !SvOK(sv_str) ) {
                vFAIL2("Constant(\\N{%s}): Call to &{$^H{charnames}} "
                      "did not return a defined value",SvPVX(sv_name));
            }
            if (hv_store_ent( RExC_charnames, sv_name, sv_str, 0))
                cached = 1;
        }
    }
    if (valuep) {
        char *p = SvPV(sv_str, len);
        if (len) {
            STRLEN numlen = 1;
            if ( SvUTF8(sv_str) ) {
                *valuep = utf8_to_uvchr((U8*)p, &numlen);
                if (*valuep > 0x7F)
                    RExC_utf8 = 1; 
                /* XXXX
                  We have to turn on utf8 for high bit chars otherwise
                  we get failures with
                  
                   "ss" =~ /[\N{LATIN SMALL LETTER SHARP S}]/i
                   "SS" =~ /[\N{LATIN SMALL LETTER SHARP S}]/i
                
                  This is different from what \x{} would do with the same
                  codepoint, where the condition is > 0xFF.
                  - dmq
                */
                
                
            } else {
                *valuep = (UV)*p;
                /* warn if we havent used the whole string? */
            }
            if (numlen<len && SIZE_ONLY && ckWARN(WARN_REGEXP)) {
                vWARN2(RExC_parse,
                    "Ignoring excess chars from \\N{%s} in character class",
                    SvPVX(sv_name)
                );
            }        
        } else if (SIZE_ONLY && ckWARN(WARN_REGEXP)) {
            vWARN2(RExC_parse,
                    "Ignoring zero length \\N{%s} in character class",
                    SvPVX(sv_name)
                );
        }
        if (sv_name)    
            SvREFCNT_dec(sv_name);    
        if (!cached)
            SvREFCNT_dec(sv_str);    
        return len ? NULL : (regnode *)&len;
    } else if(SvCUR(sv_str)) {     
        
        char *s; 
        char *p, *pend;        
        STRLEN charlen = 1;
#ifdef DEBUGGING
        char * parse_start = name-3; /* needed for the offsets */
#endif
        GET_RE_DEBUG_FLAGS_DECL;     /* needed for the offsets */
        
        ret = reg_node(pRExC_state,
            (U8)(FOLD ? (LOC ? EXACTFL : EXACTF) : EXACT));
        s= STRING(ret);
        
        if ( RExC_utf8 && !SvUTF8(sv_str) ) {
            sv_utf8_upgrade(sv_str);
        } else if ( !RExC_utf8 && SvUTF8(sv_str) ) {
            RExC_utf8= 1;
        }
        
        p = SvPV(sv_str, len);
        pend = p + len;
        /* len is the length written, charlen is the size the char read */
        for ( len = 0; p < pend; p += charlen ) {
            if (UTF) {
                UV uvc = utf8_to_uvchr((U8*)p, &charlen);
                if (FOLD) {
                    STRLEN foldlen,numlen;
                    U8 tmpbuf[UTF8_MAXBYTES_CASE+1], *foldbuf;
                    uvc = toFOLD_uni(uvc, tmpbuf, &foldlen);
                    /* Emit all the Unicode characters. */
                    
                    for (foldbuf = tmpbuf;
                        foldlen;
                        foldlen -= numlen) 
                    {
                        uvc = utf8_to_uvchr(foldbuf, &numlen);
                        if (numlen > 0) {
                            const STRLEN unilen = reguni(pRExC_state, uvc, s);
                            s       += unilen;
                            len     += unilen;
                            /* In EBCDIC the numlen
                            * and unilen can differ. */
                            foldbuf += numlen;
                            if (numlen >= foldlen)
                                break;
                        }
                        else
                            break; /* "Can't happen." */
                    }                          
                } else {
                    const STRLEN unilen = reguni(pRExC_state, uvc, s);
        	    if (unilen > 0) {
        	       s   += unilen;
        	       len += unilen;
        	    }
        	}
	    } else {
                len++;
                REGC(*p, s++);
            }
        }
        if (SIZE_ONLY) {
            RExC_size += STR_SZ(len);
        } else {
            STR_LEN(ret) = len;
            RExC_emit += STR_SZ(len);
        }
        Set_Node_Cur_Length(ret); /* MJD */
        RExC_parse--; 
        nextchar(pRExC_state);
    } else {
        ret = reg_node(pRExC_state,NOTHING);
    }
    if (!cached) {
        SvREFCNT_dec(sv_str);
    }
    if (sv_name) {
        SvREFCNT_dec(sv_name); 
    }
    return ret;

}


d2778 1
a2778 1
 * reg_recode
d2780 4
a2783 3
 * It returns the code point in utf8 for the value in *encp.
 *    value: a code value in the source encoding
 *    encp:  a pointer to an Encode object
d2785 1
a2785 47
 * If the result from Encode is not a single character,
 * it returns U+FFFD (Replacement character) and sets *encp to NULL.
 */
STATIC UV
S_reg_recode(pTHX_ const char value, SV **encp)
{
    STRLEN numlen = 1;
    SV * const sv = sv_2mortal(newSVpvn(&value, numlen));
    const char * const s = *encp ? sv_recode_to_utf8(sv, *encp) : SvPVX(sv);
    const STRLEN newlen = SvCUR(sv);
    UV uv = UNICODE_REPLACEMENT;

    if (newlen)
	uv = SvUTF8(sv)
	     ? utf8n_to_uvchr((U8*)s, newlen, &numlen, UTF8_ALLOW_DEFAULT)
	     : *(U8*)s;

    if (!newlen || numlen != newlen) {
	uv = UNICODE_REPLACEMENT;
	*encp = NULL;
    }
    return uv;
}


/*
 - regatom - the lowest level

   Try to identify anything special at the start of the pattern. If there
   is, then handle it as required. This may involve generating a single regop,
   such as for an assertion; or it may involve recursing, such as to
   handle a () structure.

   If the string doesn't start with something special then we gobble up
   as much literal text as we can.

   Once we have been able to handle whatever type of thing started the
   sequence, we return.

   Note: we have to be careful with escapes, as they can be both literal
   and special, and in the case of \10 and friends can either, depending
   on context. Specifically there are two seperate switches for handling
   escape sequences, with the one for handling literal escapes requiring
   a dummy entry for all of the special escapes that are actually handled
   by the other.
*/

d2787 1
a2787 1
S_regatom(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, U32 depth)
d2789 1
a2789 2
    dVAR;
    register regnode *ret = NULL;
d2792 1
a2792 2
    GET_RE_DEBUG_FLAGS_DECL;
    DEBUG_PARSE("atom");
a2794 1

d2796 1
a2796 1
    switch ((U8)*RExC_parse) {
d2800 1
a2800 1
	if (RExC_flags & RXf_PMf_MULTILINE)
d2802 1
a2802 1
	else if (RExC_flags & RXf_PMf_SINGLELINE)
d2812 1
a2812 1
	if (RExC_flags & RXf_PMf_MULTILINE)
d2814 1
a2814 1
	else if (RExC_flags & RXf_PMf_SINGLELINE)
d2822 1
a2822 1
	if (RExC_flags & RXf_PMf_SINGLELINE)
d2832 2
a2833 2
	char * const oregcomp_parse = ++RExC_parse;
        ret = regclass(pRExC_state,depth+1);
d2845 1
a2845 1
        ret = reg(pRExC_state, 1, &flags,depth+1);
d2857 1
a2857 1
	*flagp |= flags&(HASWIDTH|SPSTART|SIMPLE|POSTPONED);
a2879 17
    case 0xDF:
    case 0xC3:
    case 0xCE:
        do_foldchar:
        if (!LOC && FOLD) {
            U32 len,cp;
	    len=0; /* silence a spurious compiler warning */
            if ((cp = what_len_TRICKYFOLD_safe(RExC_parse,RExC_end,UTF,len))) {
                *flagp |= HASWIDTH; /* could be SIMPLE too, but needs a handler in regexec.regrepeat */
                RExC_parse+=len-1; /* we get one from nextchar() as well. :-( */
                ret = reganode(pRExC_state, FOLDCHAR, cp);
                Set_Node_Length(ret, 1); /* MJD */
                nextchar(pRExC_state); /* kill whitespace under /x */
                return ret;
            }
        }
        goto outer_default;
d2881 1
a2881 18
	/* Special Escapes

	   This switch handles escape sequences that resolve to some kind
	   of special regop and not to literal text. Escape sequnces that
	   resolve to literal text are handled below in the switch marked
	   "Literal Escapes".

	   Every entry in this switch *must* have a corresponding entry
	   in the literal escape switch. However, the opposite is not
	   required, as the default for this switch is to jump to the
	   literal text handling code.
	*/
	switch ((U8)*++RExC_parse) {
	case 0xDF:
	case 0xC3:
	case 0xCE:
	           goto do_foldchar;	    
	/* Special Escapes */
d2886 3
a2888 1
	    goto finish_meta_pat;
d2893 3
a2895 11
	    goto finish_meta_pat;
	case 'K':
	    RExC_seen_zerolen++;
	    ret = reg_node(pRExC_state, KEEPS);
	    *flagp |= SIMPLE;
	    /* XXX:dmq : disabling in-place substitution seems to
	     * be necessary here to avoid cases of memory corruption, as
	     * with: C<$_="x" x 80; s/x\K/y/> -- rgs
	     */
	    RExC_seen |= REG_SEEN_LOOKBEHIND;
	    goto finish_meta_pat;
d2900 2
a2901 1
	    goto finish_meta_pat;
d2906 3
a2908 1
	    goto finish_meta_pat;
d2913 3
a2915 1
	    goto finish_meta_pat;
d2919 3
a2921 1
	    goto finish_meta_pat;
d2925 3
a2927 1
	    goto finish_meta_pat;
d2931 3
a2933 1
	    goto finish_meta_pat;
d2939 3
a2941 1
	    goto finish_meta_pat;
d2947 3
a2949 1
	    goto finish_meta_pat;
d2953 3
a2955 1
	    goto finish_meta_pat;
d2959 3
a2961 1
	    goto finish_meta_pat;
d2965 3
a2967 1
	    goto finish_meta_pat;
a2970 21
	    goto finish_meta_pat;
	case 'R':
	    ret = reg_node(pRExC_state, LNBREAK);
	    *flagp |= HASWIDTH|SIMPLE;
	    goto finish_meta_pat;
	case 'h':
	    ret = reg_node(pRExC_state, HORIZWS);
	    *flagp |= HASWIDTH|SIMPLE;
	    goto finish_meta_pat;
	case 'H':
	    ret = reg_node(pRExC_state, NHORIZWS);
	    *flagp |= HASWIDTH|SIMPLE;
	    goto finish_meta_pat;
	case 'v':
	    ret = reg_node(pRExC_state, VERTWS);
	    *flagp |= HASWIDTH|SIMPLE;
	    goto finish_meta_pat;
	case 'V':
	    ret = reg_node(pRExC_state, NVERTWS);
	    *flagp |= HASWIDTH|SIMPLE;
         finish_meta_pat:	    
d2973 1
a2973 1
	    break;	    
d2977 1
a2977 2
		char* const oldregxend = RExC_end;
#ifdef DEBUGGING
a2978 1
#endif
d2984 1
a2984 1
		        const U8 c = (U8)*RExC_parse;
d2998 1
a2998 1
                ret = regclass(pRExC_state,depth+1);
d3009 10
a3018 47
        case 'N': 
            /* Handle \N{NAME} here and not below because it can be 
            multicharacter. join_exact() will join them up later on. 
            Also this makes sure that things like /\N{BLAH}+/ and 
            \N{BLAH} being multi char Just Happen. dmq*/
            ++RExC_parse;
            ret= reg_namedseq(pRExC_state, NULL); 
            break;
	case 'k':    /* Handle \k<NAME> and \k'NAME' */
	parse_named_seq:
        {   
            char ch= RExC_parse[1];	    
	    if (ch != '<' && ch != '\'' && ch != '{') {
	        RExC_parse++;
	        vFAIL2("Sequence %.2s... not terminated",parse_start);
	    } else {
	        /* this pretty much dupes the code for (?P=...) in reg(), if
                   you change this make sure you change that */
		char* name_start = (RExC_parse += 2);
		U32 num = 0;
                SV *sv_dat = reg_scan_name(pRExC_state,
                    SIZE_ONLY ? REG_RSN_RETURN_NULL : REG_RSN_RETURN_DATA);
                ch= (ch == '<') ? '>' : (ch == '{') ? '}' : '\'';
                if (RExC_parse == name_start || *RExC_parse != ch)
                    vFAIL2("Sequence %.3s... not terminated",parse_start);

                if (!SIZE_ONLY) {
                    num = add_data( pRExC_state, 1, "S" );
                    RExC_rxi->data->data[num]=(void*)sv_dat;
                    SvREFCNT_inc_simple_void(sv_dat);
                }

                RExC_sawback = 1;
                ret = reganode(pRExC_state,
                	   (U8)(FOLD ? (LOC ? NREFFL : NREFF) : NREF),
                	   num);
                *flagp |= HASWIDTH;

                /* override incorrect value set in reganode MJD */
                Set_Node_Offset(ret, parse_start+1);
                Set_Node_Cur_Length(ret); /* MJD */
                nextchar(pRExC_state);

            }
            break;
	}
	case 'g': 
d3022 3
a3024 28
		I32 num;
		bool isg = *RExC_parse == 'g';
		bool isrel = 0; 
		bool hasbrace = 0;
		if (isg) {
		    RExC_parse++;
		    if (*RExC_parse == '{') {
		        RExC_parse++;
		        hasbrace = 1;
		    }
		    if (*RExC_parse == '-') {
		        RExC_parse++;
		        isrel = 1;
		    }
		    if (hasbrace && !isDIGIT(*RExC_parse)) {
		        if (isrel) RExC_parse--;
                        RExC_parse -= 2;		            
		        goto parse_named_seq;
		}   }
		num = atoi(RExC_parse);
		if (isg && num == 0)
		    vFAIL("Reference to invalid group 0");
                if (isrel) {
                    num = RExC_npar - num;
                    if (num < 1)
                        vFAIL("Reference to nonexistent or unclosed group");
                }
		if (!isg && num > 9 && num >= RExC_npar)
d3027 1
a3027 1
		    char * const parse_start = RExC_parse - 1; /* MJD */
d3030 3
a3032 11
	            if (parse_start == RExC_parse - 1) 
	                vFAIL("Unterminated \\g... pattern");
                    if (hasbrace) {
                        if (*RExC_parse != '}') 
                            vFAIL("Unterminated \\g{...} pattern");
                        RExC_parse++;
                    }    
		    if (!SIZE_ONLY) {
		        if (num > (I32)RExC_rx->nparens)
			    vFAIL("Reference to nonexistent group");
		    }
d3060 3
a3062 2
	if (RExC_flags & RXf_PMf_EXTENDED) {
	    if ( reg_skipcomment( pRExC_state ) )
d3067 1
a3067 2
    default:
        outer_default:{
d3071 1
a3071 1
	    char *s;
d3088 1
a3088 1
		char * const oldp = p;
d3090 3
a3092 8
		if (RExC_flags & RXf_PMf_EXTENDED)
		    p = regwhite( pRExC_state, p );
		switch ((U8)*p) {
		case 0xDF:
		case 0xC3:
		case 0xCE:
		           if (LOC || !FOLD || !is_TRICKYFOLD_safe(p,RExC_end,UTF))
		                goto normal_default;
d3102 17
a3118 35
		    /* Literal Escapes Switch

		       This switch is meant to handle escape sequences that
		       resolve to a literal character.

		       Every escape sequence that represents something
		       else, like an assertion or a char class, is handled
		       in the switch marked 'Special Escapes' above in this
		       routine, but also has an entry here as anything that
		       isn't explicitly mentioned here will be treated as
		       an unescaped equivalent literal.
		    */

		    switch ((U8)*++p) {
		    /* These are all the special escapes. */
    		    case 0xDF:
    		    case 0xC3:
    		    case 0xCE:
    		           if (LOC || !FOLD || !is_TRICKYFOLD_safe(p,RExC_end,UTF))
    		                goto normal_default;		    
		    case 'A':             /* Start assertion */
		    case 'b': case 'B':   /* Word-boundary assertion*/
		    case 'C':             /* Single char !DANGEROUS! */
		    case 'd': case 'D':   /* digit class */
		    case 'g': case 'G':   /* generic-backref, pos assertion */
		    case 'h': case 'H':   /* HORIZWS */
		    case 'k': case 'K':   /* named backref, keep marker */
		    case 'N':             /* named char sequence */
		    case 'p': case 'P':   /* Unicode property */
		              case 'R':   /* LNBREAK */
		    case 's': case 'S':   /* space class */
		    case 'v': case 'V':   /* VERTWS */
		    case 'w': case 'W':   /* word class */
		    case 'X':             /* eXtended Unicode "combining character sequence" */
		    case 'z': case 'Z':   /* End of line/string assertion */
a3120 4

	            /* Anything after here is an escape that resolves to a
	               literal. (Except digits, which may or may not)
	             */
a3168 2
			if (PL_encoding && ender < 0x100)
			    goto recode_encoding;
a3187 11
			if (PL_encoding && ender < 0x100)
			    goto recode_encoding;
			break;
		    recode_encoding:
			{
			    SV* enc = PL_encoding;
			    ender = reg_recode((const char)(U8)ender, &enc);
			    if (!enc && SIZE_ONLY && ckWARN(WARN_REGEXP))
				vWARN(p, "Invalid escape in the specified encoding");
			    RExC_utf8 = 1;
			}
d3204 1
a3204 1
					       &numlen, UTF8_ALLOW_DEFAULT);
d3211 2
a3212 2
		if ( RExC_flags & RXf_PMf_EXTENDED)
		    p = regwhite( pRExC_state, p );
d3217 1
a3217 1
		if (p < RExC_end && ISMULT2(p)) { /* Back off on ?+*. */
d3221 2
d3231 1
a3231 1
					const STRLEN unilen = reguni(pRExC_state, ender, s);
d3245 1
a3245 1
			      const STRLEN unilen = reguni(pRExC_state, ender, s);
d3259 2
d3269 1
a3269 1
				    const STRLEN unilen = reguni(pRExC_state, ender, s);
d3283 1
a3283 1
			  const STRLEN unilen = reguni(pRExC_state, ender, s);
d3308 2
a3309 1
		
d3312 1
a3312 2
	    else {
		STR_LEN(ret) = len;
a3313 1
            }
d3318 26
d3348 1
a3348 1
S_regwhite( RExC_state_t *pRExC_state, char *p )
a3349 1
    const char *e = RExC_end;
a3353 1
            bool ended = 0;
d3355 2
a3356 7
		if (*p++ == '\n') {
		    ended = 1;
		    break;
		}
	    } while (p < e);
	    if (!ended)
	        RExC_seen |= REG_SEEN_RUN_ON_COMMENT;
a3376 1
    dVAR;
d3383 1
a3383 1
	char* const s = RExC_parse++;
d3391 3
a3393 1
	    const char* const t = RExC_parse++; /* skip over the c */
a3396 1
		const char *posixcc = s + 1;
d3398 1
a3398 1

d3406 5
a3410 2
			if (memEQ(posixcc, "word", 4)) /* this is not POSIX, this is the Perl \w */
			    namedclass = complement ? ANYOF_NALNUM : ANYOF_ALNUM;
d3419 5
a3423 2
			    if (memEQ(posixcc, "alph", 4)) /* alpha */
				namedclass = complement ? ANYOF_NALPHA : ANYOF_ALPHA;
d3426 5
a3430 2
			    if (memEQ(posixcc, "spac", 4)) /* space */
				namedclass = complement ? ANYOF_NPSXSPC : ANYOF_PSXSPC;
d3433 5
a3437 2
			    if (memEQ(posixcc, "grap", 4)) /* graph */
				namedclass = complement ? ANYOF_NGRAPH : ANYOF_GRAPH;
d3440 5
a3444 2
			    if (memEQ(posixcc, "asci", 4)) /* ascii */
				namedclass = complement ? ANYOF_NASCII : ANYOF_ASCII;
d3447 5
a3451 2
			    if (memEQ(posixcc, "blan", 4)) /* blank */
				namedclass = complement ? ANYOF_NBLANK : ANYOF_BLANK;
d3454 5
a3458 2
			    if (memEQ(posixcc, "cntr", 4)) /* cntrl */
				namedclass = complement ? ANYOF_NCNTRL : ANYOF_CNTRL;
d3461 5
a3465 2
			    if (memEQ(posixcc, "alnu", 4)) /* alnum */
				namedclass = complement ? ANYOF_NALNUMC : ANYOF_ALNUMC;
d3468 10
a3477 4
			    if (memEQ(posixcc, "lowe", 4)) /* lower */
				namedclass = complement ? ANYOF_NLOWER : ANYOF_LOWER;
			    else if (memEQ(posixcc, "uppe", 4)) /* upper */
				namedclass = complement ? ANYOF_NUPPER : ANYOF_UPPER;
d3480 15
a3494 6
			    if (memEQ(posixcc, "digi", 4)) /* digit */
				namedclass = complement ? ANYOF_NDIGIT : ANYOF_DIGIT;
			    else if (memEQ(posixcc, "prin", 4)) /* print */
				namedclass = complement ? ANYOF_NPRINT : ANYOF_PRINT;
			    else if (memEQ(posixcc, "punc", 4)) /* punct */
				namedclass = complement ? ANYOF_NPUNCT : ANYOF_PUNCT;
d3499 4
a3502 2
			if (memEQ(posixcc, "xdigit", 6))
			    namedclass = complement ? ANYOF_NXDIGIT : ANYOF_XDIGIT;
d3507 1
d3510 1
d3536 1
a3536 2
    dVAR;
    if (POSIXCC(UCHARAT(RExC_parse))) {
d3540 1
a3540 1
	while (isALNUM(*s))
d3553 1
a3553 1
		    NOOP;
a3559 48

#define _C_C_T_(NAME,TEST,WORD)                         \
ANYOF_##NAME:                                           \
    if (LOC)                                            \
	ANYOF_CLASS_SET(ret, ANYOF_##NAME);             \
    else {                                              \
	for (value = 0; value < 256; value++)           \
	    if (TEST)                                   \
		ANYOF_BITMAP_SET(ret, value);           \
    }                                                   \
    yesno = '+';                                        \
    what = WORD;                                        \
    break;                                              \
case ANYOF_N##NAME:                                     \
    if (LOC)                                            \
	ANYOF_CLASS_SET(ret, ANYOF_N##NAME);            \
    else {                                              \
	for (value = 0; value < 256; value++)           \
	    if (!TEST)                                  \
		ANYOF_BITMAP_SET(ret, value);           \
    }                                                   \
    yesno = '!';                                        \
    what = WORD;                                        \
    break

#define _C_C_T_NOLOC_(NAME,TEST,WORD)                   \
ANYOF_##NAME:                                           \
	for (value = 0; value < 256; value++)           \
	    if (TEST)                                   \
		ANYOF_BITMAP_SET(ret, value);           \
    yesno = '+';                                        \
    what = WORD;                                        \
    break;                                              \
case ANYOF_N##NAME:                                     \
	for (value = 0; value < 256; value++)           \
	    if (!TEST)                                  \
		ANYOF_BITMAP_SET(ret, value);           \
    yesno = '!';                                        \
    what = WORD;                                        \
    break

/*
   parse a class specification and produce either an ANYOF node that
   matches the pattern or if the pattern matches a single char only and
   that char is < 256 and we are case insensitive then we produce an 
   EXACT node instead.
*/

d3561 1
a3561 1
S_regclass(pTHX_ RExC_state_t *pRExC_state, U32 depth)
d3563 1
a3563 1
    dVAR;
a3566 1
    UV value = 0; /* XXX:dmq: needs to be referenceable (unfortunately) */
d3570 1
a3570 1
    char *rangebegin = NULL;
d3572 2
a3573 1
    SV *listsv = NULL;
d3576 1
a3576 1
    AV* unicode_alternate  = NULL;
a3579 11
    UV stored = 0;  /* number of chars stored in the class */

    regnode * const orig_emit = RExC_emit; /* Save the original RExC_emit in
        case we need to change the emitted regop to an EXACT. */
    const char * orig_parse = RExC_parse;
    GET_RE_DEBUG_FLAGS_DECL;
#ifndef DEBUGGING
    PERL_UNUSED_ARG(depth);
#endif

    DEBUG_PARSE("clas");
a3580 1
    /* Assume we are going to generate an ANYOF node. */
d3593 1
a3593 1
    if (SIZE_ONLY) {
a3594 2
	listsv = &PL_sv_undef; /* For code scanners: listsv always non-NULL. */
    }
d3602 1
a3602 1
	listsv = newSVpvs("# comment\n");
a3613 1
parseit:
d3625 1
a3625 1
				   &numlen, UTF8_ALLOW_DEFAULT);
a3629 1

d3637 1
a3637 1
				   &numlen, UTF8_ALLOW_DEFAULT);
a3653 18
	    case 'v':	namedclass = ANYOF_VERTWS;	break;
	    case 'V':	namedclass = ANYOF_NVERTWS;	break;
	    case 'h':	namedclass = ANYOF_HORIZWS;	break;
	    case 'H':	namedclass = ANYOF_NHORIZWS;	break;
            case 'N':  /* Handle \N{NAME} in class */
                {
                    /* We only pay attention to the first char of 
                    multichar strings being returned. I kinda wonder
                    if this makes sense as it does change the behaviour
                    from earlier versions, OTOH that behaviour was broken
                    as well. */
                    UV v; /* value is register so we cant & it /grrr */
                    if (reg_namedseq(pRExC_state, &v)) {
                        goto parseit;
                    }
                    value= v; 
                }
                break;
a3655 2
		{
		char *e;
d3685 6
a3690 2
		    Perl_sv_catpvf(aTHX_ listsv, "%cutf8::%.*s\n",
			(value=='p' ? '+' : '!'), (int)n, RExC_parse);
a3694 1
		}
d3707 1
a3707 1
		    char * const e = strchr(RExC_parse++, '}');
a3720 2
		if (PL_encoding && value < 0x100)
		    goto recode_encoding;
d3728 7
a3734 18
		{
		    I32 flags = 0;
		    numlen = 3;
		    value = grok_oct(--RExC_parse, &numlen, &flags, NULL);
		    RExC_parse += numlen;
		    if (PL_encoding && value < 0x100)
			goto recode_encoding;
		    break;
		}
	    recode_encoding:
		{
		    SV* enc = PL_encoding;
		    value = reg_recode((const char)(U8)value, &enc);
		    if (!enc && SIZE_ONLY && ckWARN(WARN_REGEXP))
			vWARN(RExC_parse,
			      "Invalid escape in the specified encoding");
		    break;
		}
d3758 1
a3758 4
		    if (ckWARN(WARN_REGEXP)) {
			const int w =
			    RExC_parse >= rangebegin ?
			    RExC_parse - rangebegin : 0;
d3761 3
a3763 2
			       w, w, rangebegin);
		    }
a3777 2

    
d3789 66
a3854 15
		case _C_C_T_(ALNUM, isALNUM(value), "Word");
		case _C_C_T_(ALNUMC, isALNUMC(value), "Alnum");
		case _C_C_T_(ALPHA, isALPHA(value), "Alpha");
		case _C_C_T_(BLANK, isBLANK(value), "Blank");
		case _C_C_T_(CNTRL, isCNTRL(value), "Cntrl");
		case _C_C_T_(GRAPH, isGRAPH(value), "Graph");
		case _C_C_T_(LOWER, isLOWER(value), "Lower");
		case _C_C_T_(PRINT, isPRINT(value), "Print");
		case _C_C_T_(PSXSPC, isPSXSPC(value), "Space");
		case _C_C_T_(PUNCT, isPUNCT(value), "Punct");
		case _C_C_T_(SPACE, isSPACE(value), "SpacePerl");
		case _C_C_T_(UPPER, isUPPER(value), "Upper");
		case _C_C_T_(XDIGIT, isXDIGIT(value), "XDigit");
		case _C_C_T_NOLOC_(VERTWS, is_VERTWS_latin1(&value), "VertSpace");
		case _C_C_T_NOLOC_(HORIZWS, is_HORIZWS_latin1(&value), "HorizSpace");
d3888 45
a3932 1
		    break;		
d3956 177
a4132 1
		    break;		
d4152 4
a4155 2
		const int w = RExC_parse - rangebegin;
		Simple_vFAIL4("Invalid [] range \"%*.*s\"", w, w, rangebegin);
d4167 1
a4167 4
		    if (ckWARN(WARN_REGEXP)) {
			const int w =
			    RExC_parse >= rangebegin ?
			    RExC_parse - rangebegin : 0;
d4170 3
a4172 2
			       w, w, rangebegin);
		    }
a4181 1
        /*stored += (value - prevvalue + 1);*/
d4183 2
d4187 1
a4187 1
		IV i;
d4197 1
a4197 2
			    if (isLOWER(i) && !ANYOF_BITMAP_TEST(ret,i)) {
				stored++;
a4198 1
			    }
d4201 1
a4201 2
			    if (isUPPER(i) && !ANYOF_BITMAP_TEST(ret,i)) {
				stored++;
a4202 1
			    }
d4207 2
a4208 6
		      for (i = prevvalue; i <= ceilvalue; i++) {
		        if (!ANYOF_BITMAP_TEST(ret,i)) {
		            stored++;  
			    ANYOF_BITMAP_SET(ret, i);
		        }
	              }
d4213 1
a4213 1
                stored+=2; /* can't optimize this class */
a4225 7
#ifdef EBCDIC /* RD t/uni/fold ff and 6b */
			 if (RExC_precomp[0] == ':' &&
			     RExC_precomp[1] == '[' &&
			     (f == 0xDF || f == 0x92)) {
			     f = NATIVE_TO_UNI(f);
                        }
#endif
a4229 8
#ifdef EBCDIC /* RD tunifold ligatures s,t fb05, fb06 */
			     if ((RExC_precomp[0] == ':' &&
				  RExC_precomp[1] == '[' &&
				  (f == 0xA2 &&
				   (value == 0xFB05 || value == 0xFB06))) ?
				 foldlen == ((STRLEN)UNISKIP(f) - 1) :
				 foldlen == (STRLEN)UNISKIP(f) )
#else
a4230 1
#endif
a4288 21

    if (SIZE_ONLY)
        return ret;
    /****** !SIZE_ONLY AFTER HERE *********/

    if( stored == 1 && (value < 128 || (value < 256 && !UTF))
        && !( ANYOF_FLAGS(ret) & ( ANYOF_FLAGS_ALL ^ ANYOF_FOLD ) )
    ) {
        /* optimize single char class to an EXACT node
           but *only* when its not a UTF/high char  */
        const char * cur_parse= RExC_parse;
        RExC_emit = (regnode *)orig_emit;
        RExC_parse = (char *)orig_parse;
        ret = reg_node(pRExC_state,
                       (U8)((ANYOF_FLAGS(ret) & ANYOF_FOLD) ? EXACTF : EXACT));
        RExC_parse = (char *)cur_parse;
        *STRING(ret)= (char)value;
        STR_LEN(ret)= 1;
        RExC_emit += STR_SZ(1);
        return ret;
    }
d4290 2
a4291 1
    if ( /* If the only flag is folding (plus possibly inversion). */
d4306 1
a4306 1
    if (optimize_invert &&
d4313 3
a4315 2
    {
	AV * const av = newAV();
d4317 1
d4329 1
a4329 1
	RExC_rxi->data->data[n] = (void*)rv;
d4332 1
a4334 45
#undef _C_C_T_


/* reg_skipcomment()

   Absorbs an /x style # comments from the input stream.
   Returns true if there is more text remaining in the stream.
   Will set the REG_SEEN_RUN_ON_COMMENT flag if the comment
   terminates the pattern without including a newline.

   Note its the callers responsibility to ensure that we are
   actually in /x mode

*/

STATIC bool
S_reg_skipcomment(pTHX_ RExC_state_t *pRExC_state)
{
    bool ended = 0;
    while (RExC_parse < RExC_end)
        if (*RExC_parse++ == '\n') {
            ended = 1;
            break;
        }
    if (!ended) {
        /* we ran off the end of the pattern without ending
           the comment, so we have to add an \n when wrapping */
        RExC_seen |= REG_SEEN_RUN_ON_COMMENT;
        return 0;
    } else
        return 1;
}

/* nextchar()

   Advance that parse position, and optionall absorbs
   "whitespace" from the inputstream.

   Without /x "whitespace" means (?#...) style comments only,
   with /x this means (?#...) and # comments and whitespace proper.

   Returns the RExC_parse point from BEFORE the scan occurs.

   This is the /x friendly way of saying RExC_parse++.
*/
d4339 1
a4339 1
    char* const retval = RExC_parse++;
d4352 1
a4352 1
	if (RExC_flags & RXf_PMf_EXTENDED) {
d4358 3
a4360 2
	        if ( reg_skipcomment( pRExC_state ) )
	            continue;
a4372 1
    dVAR;
a4374 1
    GET_RE_DEBUG_FLAGS_DECL;
a4380 2
    if (RExC_emit >= RExC_emit_bound)
        Perl_croak(aTHX_ "panic: reg_node overrun trying to emit %d", op);
a4384 1
#ifdef RE_TRACK_PATTERN_OFFSETS
d4386 1
a4386 1
	MJD_OFFSET_DEBUG(("%s:%d: (op %s) %s %"UVuf" (len %"UVuf") (max %"UVuf").\n", 
d4388 6
a4393 6
              PL_reg_name[op],
              (UV)(RExC_emit - RExC_emit_start) > RExC_offsets[0] 
		? "Overwriting end of array!\n" : "OK",
              (UV)(RExC_emit - RExC_emit_start),
              (UV)(RExC_parse - RExC_start),
              (UV)RExC_offsets[0])); 
d4396 1
a4396 1
#endif
d4398 1
a4407 1
    dVAR;
a4409 1
    GET_RE_DEBUG_FLAGS_DECL;
a4413 14
	/* 
	   We can't do this:
	   
	   assert(2==regarglen[op]+1); 
	
	   Anything larger than this has to allocate the extra amount.
	   If we changed this to be:
	   
	   RExC_size += (1 + regarglen[op]);
	   
	   then it wouldn't matter. Its not clear what side effect
	   might come from that so its not done so far.
	   -- dmq
	*/
a4415 2
    if (RExC_emit >= RExC_emit_bound)
        Perl_croak(aTHX_ "panic: reg_node overrun trying to emit %d", op);
a4419 1
#ifdef RE_TRACK_PATTERN_OFFSETS
d4421 1
a4421 1
	MJD_OFFSET_DEBUG(("%s(%d): (op %s) %s %"UVuf" <- %"UVuf" (max %"UVuf").\n", 
d4424 2
a4425 2
	      PL_reg_name[op],
              (UV)(RExC_emit - RExC_emit_start) > RExC_offsets[0] ? 
d4427 3
a4429 3
              (UV)(RExC_emit - RExC_emit_start),
              (UV)(RExC_parse - RExC_start),
              (UV)RExC_offsets[0])); 
d4432 1
a4432 1
#endif            
d4434 1
d4441 2
a4442 2
STATIC STRLEN
S_reguni(pTHX_ const RExC_state_t *pRExC_state, UV uv, char* s)
d4444 1
a4444 2
    dVAR;
    return SIZE_ONLY ? UNISKIP(uv) : (uvchr_to_utf8((U8*)s, uv) - (U8*)s);
d4453 1
a4453 1
S_reginsert(pTHX_ RExC_state_t *pRExC_state, U8 op, regnode *opnd, U32 depth)
a4454 1
    dVAR;
d4459 1
a4459 3
    const int size = NODE_STEP_REGNODE + offset;
    GET_RE_DEBUG_FLAGS_DECL;
    PERL_UNUSED_ARG(depth);
d4461 1
a4461 1
    DEBUG_PARSE_FMT("inst"," - %s",PL_reg_name[op]);
d4463 1
a4463 1
	RExC_size += size;
d4468 1
a4468 1
    RExC_emit += size;
a4469 19
    if (RExC_open_parens) {
        int paren;
        /*DEBUG_PARSE_FMT("inst"," - %"IVdf, (IV)RExC_npar);*/
        for ( paren=0 ; paren < RExC_npar ; paren++ ) {
            if ( RExC_open_parens[paren] >= opnd ) {
                /*DEBUG_PARSE_FMT("open"," - %d",size);*/
                RExC_open_parens[paren] += size;
            } else {
                /*DEBUG_PARSE_FMT("open"," - %s","ok");*/
            }
            if ( RExC_close_parens[paren] >= opnd ) {
                /*DEBUG_PARSE_FMT("close"," - %d",size);*/
                RExC_close_parens[paren] += size;
            } else {
                /*DEBUG_PARSE_FMT("close"," - %s","ok");*/
            }
        }
    }

a4471 1
#ifdef RE_TRACK_PATTERN_OFFSETS
d4473 1
a4473 1
	    MJD_OFFSET_DEBUG(("%s(%d): (op %s) %s copy %"UVuf" -> %"UVuf" (max %"UVuf").\n",
d4476 6
a4481 6
		  PL_reg_name[op],
                  (UV)(dst - RExC_emit_start) > RExC_offsets[0] 
		    ? "Overwriting end of array!\n" : "OK",
                  (UV)(src - RExC_emit_start),
                  (UV)(dst - RExC_emit_start),
                  (UV)RExC_offsets[0])); 
a4484 1
#endif
a4488 1
#ifdef RE_TRACK_PATTERN_OFFSETS
d4490 1
a4490 1
	MJD_OFFSET_DEBUG(("%s(%d): (op %s) %s %"UVuf" <- %"UVuf" (max %"UVuf").\n", 
d4493 2
a4494 2
	      PL_reg_name[op],
              (UV)(place - RExC_emit_start) > RExC_offsets[0] 
d4496 3
a4498 3
              (UV)(place - RExC_emit_start),
              (UV)(RExC_parse - RExC_start),
              (UV)RExC_offsets[0]));
a4501 1
#endif    
a4508 1
- SEE ALSO: regtail_study
a4509 1
/* TODO: All three parms should be const */
d4511 1
a4511 1
S_regtail(pTHX_ RExC_state_t *pRExC_state, regnode *p, const regnode *val,U32 depth)
a4512 1
    dVAR;
a4513 4
    GET_RE_DEBUG_FLAGS_DECL;
#ifndef DEBUGGING
    PERL_UNUSED_ARG(depth);
#endif
d4522 3
a4524 13
        DEBUG_PARSE_r({
            SV * const mysv=sv_newmortal();
            DEBUG_PARSE_MSG((scan==p ? "tail" : ""));
            regprop(RExC_rx, mysv, scan);
            PerlIO_printf(Perl_debug_log, "~ %s (%d) %s %s\n",
                SvPV_nolen_const(mysv), REG_NODE_NUM(scan),
                    (temp == NULL ? "->" : ""),
                    (temp == NULL ? PL_reg_name[OP(val)] : "")
            );
        });
        if (temp == NULL)
            break;
        scan = temp;
d4528 1
a4528 1
        ARG_SET(scan, val - scan);
d4531 1
a4531 1
        NEXT_OFF(scan) = val - scan;
a4534 1
#ifdef DEBUGGING
d4536 1
a4536 12
- regtail_study - set the next-pointer at the end of a node chain of p to val.
- Look for optimizable sequences at the same time.
- currently only looks for EXACT chains.

This is expermental code. The idea is to use this routine to perform 
in place optimizations on branches and groups as they are constructed,
with the long term intention of removing optimization from study_chunk so
that it is purely analytical.

Currently only used when in DEBUG mode. The macro REGTAIL_STUDY() is used
to control which is which.

d4538 2
a4539 4
/* TODO: All four parms should be const */

STATIC U8
S_regtail_study(pTHX_ RExC_state_t *pRExC_state, regnode *p, const regnode *val,U32 depth)
d4541 5
a4545 63
    dVAR;
    register regnode *scan;
    U8 exact = PSEUDO;
#ifdef EXPERIMENTAL_INPLACESCAN
    I32 min = 0;
#endif

    GET_RE_DEBUG_FLAGS_DECL;


    if (SIZE_ONLY)
        return exact;

    /* Find last node. */

    scan = p;
    for (;;) {
        regnode * const temp = regnext(scan);
#ifdef EXPERIMENTAL_INPLACESCAN
        if (PL_regkind[OP(scan)] == EXACT)
            if (join_exact(pRExC_state,scan,&min,1,val,depth+1))
                return EXACT;
#endif
        if ( exact ) {
            switch (OP(scan)) {
                case EXACT:
                case EXACTF:
                case EXACTFL:
                        if( exact == PSEUDO )
                            exact= OP(scan);
                        else if ( exact != OP(scan) )
                            exact= 0;
                case NOTHING:
                    break;
                default:
                    exact= 0;
            }
        }
        DEBUG_PARSE_r({
            SV * const mysv=sv_newmortal();
            DEBUG_PARSE_MSG((scan==p ? "tsdy" : ""));
            regprop(RExC_rx, mysv, scan);
            PerlIO_printf(Perl_debug_log, "~ %s (%d) -> %s\n",
                SvPV_nolen_const(mysv),
                REG_NODE_NUM(scan),
                PL_reg_name[exact]);
        });
	if (temp == NULL)
	    break;
	scan = temp;
    }
    DEBUG_PARSE_r({
        SV * const mysv_val=sv_newmortal();
        DEBUG_PARSE_MSG("");
        regprop(RExC_rx, mysv_val, val);
        PerlIO_printf(Perl_debug_log, "~ attach to %s (%"IVdf") offset to %"IVdf"\n",
		      SvPV_nolen_const(mysv_val),
		      (IV)REG_NODE_NUM(val),
		      (IV)(val - scan)
        );
    });
    if (reg_off_by_arg[OP(scan)]) {
	ARG_SET(scan, val - scan);
d4547 2
a4548 2
    else {
	NEXT_OFF(scan) = val - scan;
d4550 2
a4551 2

    return exact;
a4552 1
#endif
d4558 1
a4558 1
S_regcurly(register const char *s)
a4574 1

a4577 21
#ifdef DEBUGGING
void 
S_regdump_extflags(pTHX_ const char *lead, const U32 flags) {
    int bit;
    int set=0;
    for (bit=0; bit<32; bit++) {
        if (flags & (1<<bit)) {
            if (!set++ && lead) 
                PerlIO_printf(Perl_debug_log, "%s",lead);
            PerlIO_printf(Perl_debug_log, "%s ",PL_reg_extflags_name[bit]);
        }	        
    }	   
    if (lead)  {
        if (set) 
            PerlIO_printf(Perl_debug_log, "\n");
        else 
            PerlIO_printf(Perl_debug_log, "%s[none-set]\n",lead);
    }            
}   
#endif

d4579 1
a4579 1
Perl_regdump(pTHX_ const regexp *r)
d4582 1
a4582 5
    dVAR;
    SV * const sv = sv_newmortal();
    SV *dsv= sv_newmortal();
    RXi_GET_DECL(r,ri);
    GET_RE_DEBUG_FLAGS_DECL;
d4584 1
a4584 1
    (void)dumpuntil(r, ri->program, ri->program + 1, NULL, NULL, sv, 0, 0);
d4587 1
a4587 3
    if (r->anchored_substr) {
	RE_PV_QUOTED_DECL(s, 0, dsv, SvPVX_const(r->anchored_substr), 
	    RE_SV_DUMPLEN(r->anchored_substr), 30);
d4589 6
a4594 2
		      "anchored %s%s at %"IVdf" ",
		      s, RE_SV_TAIL(r->anchored_substr),
d4596 1
a4596 3
    } else if (r->anchored_utf8) {
	RE_PV_QUOTED_DECL(s, 1, dsv, SvPVX_const(r->anchored_utf8), 
	    RE_SV_DUMPLEN(r->anchored_utf8), 30);
d4598 6
a4603 2
		      "anchored utf8 %s%s at %"IVdf" ",
		      s, RE_SV_TAIL(r->anchored_utf8),
d4605 1
a4605 4
    }		      
    if (r->float_substr) {
	RE_PV_QUOTED_DECL(s, 0, dsv, SvPVX_const(r->float_substr), 
	    RE_SV_DUMPLEN(r->float_substr), 30);
d4607 6
a4612 2
		      "floating %s%s at %"IVdf"..%"UVuf" ",
		      s, RE_SV_TAIL(r->float_substr),
d4614 1
a4614 3
    } else if (r->float_utf8) {
	RE_PV_QUOTED_DECL(s, 1, dsv, SvPVX_const(r->float_utf8), 
	    RE_SV_DUMPLEN(r->float_utf8), 30);
d4616 6
a4621 2
		      "floating utf8 %s%s at %"IVdf"..%"UVuf" ",
		      s, RE_SV_TAIL(r->float_utf8),
a4622 1
    }
d4625 4
a4628 5
		      (const char *)
		      (r->check_substr == r->float_substr
		       && r->check_utf8 == r->float_utf8
		       ? "(checking floating" : "(checking anchored"));
    if (r->extflags & RXf_NOSCAN)
d4630 1
a4630 1
    if (r->extflags & RXf_CHECK_ALL)
d4635 3
a4637 3
    if (ri->regstclass) {
	regprop(r, sv, ri->regstclass);
	PerlIO_printf(Perl_debug_log, "stclass %s ", SvPVX_const(sv));
d4639 1
a4639 1
    if (r->extflags & RXf_ANCH) {
d4641 1
a4641 1
	if (r->extflags & RXf_ANCH_BOL)
d4643 1
a4643 1
	if (r->extflags & RXf_ANCH_MBOL)
d4645 1
a4645 1
	if (r->extflags & RXf_ANCH_SBOL)
d4647 1
a4647 1
	if (r->extflags & RXf_ANCH_GPOS)
d4651 3
a4653 3
    if (r->extflags & RXf_GPOS_SEEN)
	PerlIO_printf(Perl_debug_log, "GPOS:%"UVuf" ", (UV)r->gofs);
    if (r->intflags & PREGf_SKIP)
d4655 1
a4655 1
    if (r->intflags & PREGf_IMPLICIT)
d4657 2
a4658 2
    PerlIO_printf(Perl_debug_log, "minlen %"IVdf" ", (IV)r->minlen);
    if (r->extflags & RXf_EVAL_SEEN)
d4661 10
a4670 4
    DEBUG_FLAGS_r(regdump_extflags("r->extflags: ",r->extflags));            
#else
    PERL_UNUSED_CONTEXT;
    PERL_UNUSED_ARG(r);
d4678 1
a4678 1
Perl_regprop(pTHX_ const regexp *prog, SV *sv, const regnode *o)
a4680 1
    dVAR;
a4681 3
    RXi_GET_DECL(prog,progi);
    GET_RE_DEBUG_FLAGS_DECL;
    
d4684 1
a4684 2

    if (OP(o) > REGNODE_MAX)		/* regnode.type is unsigned */
d4687 2
a4688 2
	Perl_croak(aTHX_ "Corrupted regexp opcode %d > %d", (int)OP(o), (int)REGNODE_MAX);
    sv_catpv(sv, PL_reg_name[OP(o)]); /* Take off const! */
d4690 1
a4690 1
    k = PL_regkind[OP(o)];
d4693 18
a4710 60
	sv_catpvs(sv, " ");
	/* Using is_utf8_string() (via PERL_PV_UNI_DETECT) 
	 * is a crude hack but it may be the best for now since 
	 * we have no flag "this EXACTish node was UTF-8" 
	 * --jhi */
	pv_pretty(sv, STRING(o), STR_LEN(o), 60, PL_colors[0], PL_colors[1],
		  PERL_PV_ESCAPE_UNI_DETECT |
		  PERL_PV_PRETTY_ELLIPSES   |
		  PERL_PV_PRETTY_LTGT       |
		  PERL_PV_PRETTY_NOCLEAR
		  );
    } else if (k == TRIE) {
	/* print the details of the trie in dumpuntil instead, as
	 * progi->data isn't available here */
        const char op = OP(o);
        const U32 n = ARG(o);
        const reg_ac_data * const ac = IS_TRIE_AC(op) ?
               (reg_ac_data *)progi->data->data[n] :
               NULL;
        const reg_trie_data * const trie
	    = (reg_trie_data*)progi->data->data[!IS_TRIE_AC(op) ? n : ac->trie];
        
        Perl_sv_catpvf(aTHX_ sv, "-%s",PL_reg_name[o->flags]);
        DEBUG_TRIE_COMPILE_r(
            Perl_sv_catpvf(aTHX_ sv,
                "<S:%"UVuf"/%"IVdf" W:%"UVuf" L:%"UVuf"/%"UVuf" C:%"UVuf"/%"UVuf">",
                (UV)trie->startstate,
                (IV)trie->statecount-1, /* -1 because of the unused 0 element */
                (UV)trie->wordcount,
                (UV)trie->minlen,
                (UV)trie->maxlen,
                (UV)TRIE_CHARCOUNT(trie),
                (UV)trie->uniquecharcount
            )
        );
        if ( IS_ANYOF_TRIE(op) || trie->bitmap ) {
            int i;
            int rangestart = -1;
            U8* bitmap = IS_ANYOF_TRIE(op) ? (U8*)ANYOF_BITMAP(o) : (U8*)TRIE_BITMAP(trie);
            sv_catpvs(sv, "[");
            for (i = 0; i <= 256; i++) {
                if (i < 256 && BITMAP_TEST(bitmap,i)) {
                    if (rangestart == -1)
                        rangestart = i;
                } else if (rangestart != -1) {
                    if (i <= rangestart + 3)
                        for (; rangestart < i; rangestart++)
                            put_byte(sv, rangestart);
                    else {
                        put_byte(sv, rangestart);
                        sv_catpvs(sv, "-");
                        put_byte(sv, i - 1);
                    }
                    rangestart = -1;
                }
            }
            sv_catpvs(sv, "]");
        } 
	 
    } else if (k == CURLY) {
d4717 1
a4717 1
    else if (k == REF || k == OPEN || k == CLOSE || k == GROUPP || OP(o)==ACCEPT) {
d4719 1
a4719 29
	if ( prog->paren_names ) {
            if ( k != REF || OP(o) < NREF) {	    
	        AV *list= (AV *)progi->data->data[progi->name_list_idx];
	        SV **name= av_fetch(list, ARG(o), 0 );
	        if (name)
	            Perl_sv_catpvf(aTHX_ sv, " '%"SVf"'", SVfARG(*name));
            }	    
            else {
                AV *list= (AV *)progi->data->data[ progi->name_list_idx ];
                SV *sv_dat=(SV*)progi->data->data[ ARG( o ) ];
                I32 *nums=(I32*)SvPVX(sv_dat);
                SV **name= av_fetch(list, nums[0], 0 );
                I32 n;
                if (name) {
                    for ( n=0; n<SvIVX(sv_dat); n++ ) {
                        Perl_sv_catpvf(aTHX_ sv, "%s%"IVdf,
			   	    (n ? "," : ""), (IV)nums[n]);
                    }
                    Perl_sv_catpvf(aTHX_ sv, " '%"SVf"'", SVfARG(*name));
                }
            }
        }            
    } else if (k == GOSUB) 
	Perl_sv_catpvf(aTHX_ sv, "%d[%+d]", (int)ARG(o),(int)ARG2L(o));	/* Paren and offset */
    else if (k == VERB) {
        if (!o->flags) 
            Perl_sv_catpvf(aTHX_ sv, ":%"SVf, 
                SVfARG((SV*)progi->data->data[ ARG( o ) ]));
    } else if (k == LOGICAL)
a4720 2
    else if (k == FOLDCHAR)
	Perl_sv_catpvf(aTHX_ sv, "[0x%"UVXf"]", PTR2UV(ARG(o)) );
d4724 2
a4725 3

	/* Should be synchronized with * ANYOF_ #xdefines in regcomp.h */
	static const char * const anyofs[] = {
d4759 1
a4759 1
	    sv_catpvs(sv, "{loc}");
d4761 1
a4761 1
	    sv_catpvs(sv, "{i}");
d4764 1
a4764 1
	    sv_catpvs(sv, "^");
d4775 1
a4775 1
		    sv_catpvs(sv, "-");
d4783 1
a4783 1
	    for (i = 0; i < (int)(sizeof(anyofs)/sizeof(char*)); i++)
d4788 1
a4788 1
	    sv_catpvs(sv, "{unicode}");
d4790 1
a4790 1
	    sv_catpvs(sv, "{unicode_all}");
d4794 1
a4794 1
	    SV * const sw = regclass_swash(prog, o, FALSE, &lv, 0);
d4819 1
a4819 1
				sv_catpvs(sv, "-");
d4828 1
a4828 1
		    sv_catpvs(sv, "..."); /* et cetera */
d4833 1
a4833 1
		    char * const origs = s;
d4835 1
a4835 2
		    while (*s && *s != '\n')
			s++;
d4859 1
a4859 6
	Perl_sv_catpvf(aTHX_ sv, "[%d]", -(o->flags));
#else
    PERL_UNUSED_CONTEXT;
    PERL_UNUSED_ARG(sv);
    PERL_UNUSED_ARG(o);
    PERL_UNUSED_ARG(prog);
d4864 1
a4864 1
Perl_re_intuit_string(pTHX_ REGEXP * const prog)
d4866 1
a4866 5
    dVAR;
    GET_RE_DEBUG_FLAGS_DECL;
    PERL_UNUSED_CONTEXT;

    DEBUG_COMPILE_r(
a4884 13
/* 
   pregfree() 
   
   handles refcounting and freeing the perl core regexp structure. When 
   it is necessary to actually free the structure the first thing it 
   does is call the 'free' method of the regexp_engine associated to to 
   the regexp, allowing the handling of the void *pprivate; member 
   first. (This routine is not overridable by extensions, which is why 
   the extensions free is called first.)
   
   See regdupe and regdupe_internal if you change anything here. 
*/
#ifndef PERL_IN_XSUB_RE
d4888 3
a4890 2
    dVAR;
    GET_RE_DEBUG_FLAGS_DECL;
d4894 21
a4914 8
    if (r->mother_re) {
        ReREFCNT_dec(r->mother_re);
    } else {
        CALLREGFREE_PVT(r); /* free the private data */
        if (r->paren_names)
            SvREFCNT_dec(r->paren_names);
        Safefree(r->wrapped);
    }        
d4916 8
a4923 8
        if (r->anchored_substr)
            SvREFCNT_dec(r->anchored_substr);
        if (r->anchored_utf8)
            SvREFCNT_dec(r->anchored_utf8);
        if (r->float_substr)
            SvREFCNT_dec(r->float_substr);
        if (r->float_utf8)
            SvREFCNT_dec(r->float_utf8);
d4926 2
a4927 96
    RX_MATCH_COPY_FREE(r);
#ifdef PERL_OLD_COPY_ON_WRITE
    if (r->saved_copy)
        SvREFCNT_dec(r->saved_copy);
#endif
    Safefree(r->swap);
    Safefree(r->offs);
    Safefree(r);
}

/*  reg_temp_copy()
    
    This is a hacky workaround to the structural issue of match results
    being stored in the regexp structure which is in turn stored in
    PL_curpm/PL_reg_curpm. The problem is that due to qr// the pattern
    could be PL_curpm in multiple contexts, and could require multiple
    result sets being associated with the pattern simultaneously, such
    as when doing a recursive match with (??{$qr})
    
    The solution is to make a lightweight copy of the regexp structure 
    when a qr// is returned from the code executed by (??{$qr}) this
    lightweight copy doesnt actually own any of its data except for
    the starp/end and the actual regexp structure itself. 
    
*/    
    
    
regexp *
Perl_reg_temp_copy (pTHX_ struct regexp *r) {
    regexp *ret;
    register const I32 npar = r->nparens+1;
    (void)ReREFCNT_inc(r);
    Newx(ret, 1, regexp);
    StructCopy(r, ret, regexp);
    Newx(ret->offs, npar, regexp_paren_pair);
    Copy(r->offs, ret->offs, npar, regexp_paren_pair);
    ret->refcnt = 1;
    if (r->substrs) {
        Newx(ret->substrs, 1, struct reg_substr_data);
	StructCopy(r->substrs, ret->substrs, struct reg_substr_data);

	SvREFCNT_inc_void(ret->anchored_substr);
	SvREFCNT_inc_void(ret->anchored_utf8);
	SvREFCNT_inc_void(ret->float_substr);
	SvREFCNT_inc_void(ret->float_utf8);

	/* check_substr and check_utf8, if non-NULL, point to either their
	   anchored or float namesakes, and don't hold a second reference.  */
    }
    RX_MATCH_COPIED_off(ret);
#ifdef PERL_OLD_COPY_ON_WRITE
    ret->saved_copy = NULL;
#endif
    ret->mother_re = r; 
    ret->swap = NULL;
    
    return ret;
}
#endif

/* regfree_internal() 

   Free the private data in a regexp. This is overloadable by 
   extensions. Perl takes care of the regexp structure in pregfree(), 
   this covers the *pprivate pointer which technically perldoesnt 
   know about, however of course we have to handle the 
   regexp_internal structure when no extension is in use. 
   
   Note this is called before freeing anything in the regexp 
   structure. 
 */
 
void
Perl_regfree_internal(pTHX_ REGEXP * const r)
{
    dVAR;
    RXi_GET_DECL(r,ri);
    GET_RE_DEBUG_FLAGS_DECL;
    
    DEBUG_COMPILE_r({
	if (!PL_colorset)
	    reginitcolors();
	{
	    SV *dsv= sv_newmortal();
            RE_PV_QUOTED_DECL(s, (r->extflags & RXf_UTF8),
                dsv, r->precomp, r->prelen, 60);
            PerlIO_printf(Perl_debug_log,"%sFreeing REx:%s %s\n", 
                PL_colors[4],PL_colors[5],s);
        }
    });
#ifdef RE_TRACK_PATTERN_OFFSETS
    if (ri->u.offsets)
        Safefree(ri->u.offsets);             /* 20010421 MJD */
#endif
    if (ri->data) {
	int n = ri->data->count;
d4934 1
a4934 1
	    switch (ri->data->what[n]) {
d4936 1
a4936 3
	    case 'S':
	    case 'u':
		SvREFCNT_dec((SV*)ri->data->data[n]);
d4939 1
a4939 1
		Safefree(ri->data->data[n]);
d4942 1
a4942 1
		new_comppad = (AV*)ri->data->data[n];
d4949 2
a4950 1
		    (SvTYPE(new_comppad) == SVt_PVAV) ? new_comppad : NULL
d4953 1
a4953 1
		refcnt = OpREFCNT_dec((OP_4tree*)ri->data->data[n]);
d4956 1
a4956 1
                    op_free((OP_4tree*)ri->data->data[n]);
a4963 42
            case 'T':	        
                { /* Aho Corasick add-on structure for a trie node.
                     Used in stclass optimization only */
                    U32 refcount;
                    reg_ac_data *aho=(reg_ac_data*)ri->data->data[n];
                    OP_REFCNT_LOCK;
                    refcount = --aho->refcount;
                    OP_REFCNT_UNLOCK;
                    if ( !refcount ) {
                        PerlMemShared_free(aho->states);
                        PerlMemShared_free(aho->fail);
			 /* do this last!!!! */
                        PerlMemShared_free(ri->data->data[n]);
                        PerlMemShared_free(ri->regstclass);
                    }
                }
                break;
	    case 't':
	        {
	            /* trie structure. */
	            U32 refcount;
	            reg_trie_data *trie=(reg_trie_data*)ri->data->data[n];
                    OP_REFCNT_LOCK;
                    refcount = --trie->refcount;
                    OP_REFCNT_UNLOCK;
                    if ( !refcount ) {
                        PerlMemShared_free(trie->charmap);
                        PerlMemShared_free(trie->states);
                        PerlMemShared_free(trie->trans);
                        if (trie->bitmap)
                            PerlMemShared_free(trie->bitmap);
                        if (trie->wordlen)
                            PerlMemShared_free(trie->wordlen);
                        if (trie->jump)
                            PerlMemShared_free(trie->jump);
                        if (trie->nextword)
                            PerlMemShared_free(trie->nextword);
                        /* do this last!!!! */
                        PerlMemShared_free(ri->data->data[n]);
		    }
		}
		break;
d4965 1
a4965 1
		Perl_croak(aTHX_ "panic: regfree data code '%c'", ri->data->what[n]);
d4968 2
a4969 2
	Safefree(ri->data->what);
	Safefree(ri->data);
d4971 3
a4973 249

    Safefree(ri);
}

#define sv_dup_inc(s,t)	SvREFCNT_inc(sv_dup(s,t))
#define av_dup_inc(s,t)	(AV*)SvREFCNT_inc(sv_dup((SV*)s,t))
#define hv_dup_inc(s,t)	(HV*)SvREFCNT_inc(sv_dup((SV*)s,t))
#define SAVEPVN(p,n)	((p) ? savepvn(p,n) : NULL)

/* 
   re_dup - duplicate a regexp. 
   
   This routine is expected to clone a given regexp structure. It is not
   compiler under USE_ITHREADS.

   After all of the core data stored in struct regexp is duplicated
   the regexp_engine.dupe method is used to copy any private data
   stored in the *pprivate pointer. This allows extensions to handle
   any duplication it needs to do.

   See pregfree() and regfree_internal() if you change anything here. 
*/
#if defined(USE_ITHREADS)
#ifndef PERL_IN_XSUB_RE
regexp *
Perl_re_dup(pTHX_ const regexp *r, CLONE_PARAMS *param)
{
    dVAR;
    regexp *ret;
    I32 npar;

    if (!r)
	return (REGEXP *)NULL;

    if ((ret = (REGEXP *)ptr_table_fetch(PL_ptr_table, r)))
	return ret;

    
    npar = r->nparens+1;
    Newx(ret, 1, regexp);
    StructCopy(r, ret, regexp);
    Newx(ret->offs, npar, regexp_paren_pair);
    Copy(r->offs, ret->offs, npar, regexp_paren_pair);
    if(ret->swap) {
        /* no need to copy these */
        Newx(ret->swap, npar, regexp_paren_pair);
    }

    if (ret->substrs) {
	/* Do it this way to avoid reading from *r after the StructCopy().
	   That way, if any of the sv_dup_inc()s dislodge *r from the L1
	   cache, it doesn't matter.  */
	const bool anchored = r->check_substr == r->anchored_substr;
        Newx(ret->substrs, 1, struct reg_substr_data);
	StructCopy(r->substrs, ret->substrs, struct reg_substr_data);

	ret->anchored_substr = sv_dup_inc(ret->anchored_substr, param);
	ret->anchored_utf8 = sv_dup_inc(ret->anchored_utf8, param);
	ret->float_substr = sv_dup_inc(ret->float_substr, param);
	ret->float_utf8 = sv_dup_inc(ret->float_utf8, param);

	/* check_substr and check_utf8, if non-NULL, point to either their
	   anchored or float namesakes, and don't hold a second reference.  */

	if (ret->check_substr) {
	    if (anchored) {
		assert(r->check_utf8 == r->anchored_utf8);
		ret->check_substr = ret->anchored_substr;
		ret->check_utf8 = ret->anchored_utf8;
	    } else {
		assert(r->check_substr == r->float_substr);
		assert(r->check_utf8 == r->float_utf8);
		ret->check_substr = ret->float_substr;
		ret->check_utf8 = ret->float_utf8;
	    }
	}
    }

    ret->wrapped        = SAVEPVN(ret->wrapped, ret->wraplen+1);
    ret->precomp        = ret->wrapped + (ret->precomp - ret->wrapped);
    ret->paren_names    = hv_dup_inc(ret->paren_names, param);

    if (ret->pprivate)
	RXi_SET(ret,CALLREGDUPE_PVT(ret,param));

    if (RX_MATCH_COPIED(ret))
	ret->subbeg  = SAVEPVN(ret->subbeg, ret->sublen);
    else
	ret->subbeg = NULL;
#ifdef PERL_OLD_COPY_ON_WRITE
    ret->saved_copy = NULL;
#endif

    ret->mother_re      = NULL;
    ret->gofs = 0;
    ret->seen_evals = 0;
    
    ptr_table_store(PL_ptr_table, r, ret);
    return ret;
}
#endif /* PERL_IN_XSUB_RE */

/*
   regdupe_internal()
   
   This is the internal complement to regdupe() which is used to copy
   the structure pointed to by the *pprivate pointer in the regexp.
   This is the core version of the extension overridable cloning hook.
   The regexp structure being duplicated will be copied by perl prior
   to this and will be provided as the regexp *r argument, however 
   with the /old/ structures pprivate pointer value. Thus this routine
   may override any copying normally done by perl.
   
   It returns a pointer to the new regexp_internal structure.
*/

void *
Perl_regdupe_internal(pTHX_ REGEXP * const r, CLONE_PARAMS *param)
{
    dVAR;
    regexp_internal *reti;
    int len, npar;
    RXi_GET_DECL(r,ri);
    
    npar = r->nparens+1;
    len = ProgLen(ri);
    
    Newxc(reti, sizeof(regexp_internal) + (len+1)*sizeof(regnode), char, regexp_internal);
    Copy(ri->program, reti->program, len+1, regnode);
    

    reti->regstclass = NULL;

    if (ri->data) {
	struct reg_data *d;
        const int count = ri->data->count;
	int i;

	Newxc(d, sizeof(struct reg_data) + count*sizeof(void *),
		char, struct reg_data);
	Newx(d->what, count, U8);

	d->count = count;
	for (i = 0; i < count; i++) {
	    d->what[i] = ri->data->what[i];
	    switch (d->what[i]) {
	        /* legal options are one of: sSfpontTu
	           see also regcomp.h and pregfree() */
	    case 's':
	    case 'S':
	    case 'p': /* actually an AV, but the dup function is identical.  */
	    case 'u': /* actually an HV, but the dup function is identical.  */
		d->data[i] = sv_dup_inc((SV *)ri->data->data[i], param);
		break;
	    case 'f':
		/* This is cheating. */
		Newx(d->data[i], 1, struct regnode_charclass_class);
		StructCopy(ri->data->data[i], d->data[i],
			    struct regnode_charclass_class);
		reti->regstclass = (regnode*)d->data[i];
		break;
	    case 'o':
		/* Compiled op trees are readonly and in shared memory,
		   and can thus be shared without duplication. */
		OP_REFCNT_LOCK;
		d->data[i] = (void*)OpREFCNT_inc((OP*)ri->data->data[i]);
		OP_REFCNT_UNLOCK;
		break;
	    case 'T':
		/* Trie stclasses are readonly and can thus be shared
		 * without duplication. We free the stclass in pregfree
		 * when the corresponding reg_ac_data struct is freed.
		 */
		reti->regstclass= ri->regstclass;
		/* Fall through */
	    case 't':
		OP_REFCNT_LOCK;
		((reg_trie_data*)ri->data->data[i])->refcount++;
		OP_REFCNT_UNLOCK;
		/* Fall through */
	    case 'n':
		d->data[i] = ri->data->data[i];
		break;
            default:
		Perl_croak(aTHX_ "panic: re_dup unknown data code '%c'", ri->data->what[i]);
	    }
	}

	reti->data = d;
    }
    else
	reti->data = NULL;

    reti->name_list_idx = ri->name_list_idx;

#ifdef RE_TRACK_PATTERN_OFFSETS
    if (ri->u.offsets) {
        Newx(reti->u.offsets, 2*len+1, U32);
        Copy(ri->u.offsets, reti->u.offsets, 2*len+1, U32);
    }
#else
    SetProgLen(reti,len);
#endif

    return (void*)reti;
}

#endif    /* USE_ITHREADS */

/* 
   reg_stringify() 
   
   converts a regexp embedded in a MAGIC struct to its stringified form, 
   caching the converted form in the struct and returns the cached 
   string. 

   If lp is nonnull then it is used to return the length of the 
   resulting string
   
   If flags is nonnull and the returned string contains UTF8 then 
   (*flags & 1) will be true.
   
   If haseval is nonnull then it is used to return whether the pattern 
   contains evals.
   
   Normally called via macro: 
   
        CALLREG_STRINGIFY(mg,&len,&utf8);
        
   And internally with
   
        CALLREG_AS_STR(mg,&lp,&flags,&haseval)        
    
   See sv_2pv_flags() in sv.c for an example of internal usage.
    
 */
#ifndef PERL_IN_XSUB_RE

char *
Perl_reg_stringify(pTHX_ MAGIC *mg, STRLEN *lp, U32 *flags, I32 *haseval ) {
    dVAR;
    const regexp * const re = (regexp *)mg->mg_obj;
    if (haseval) 
        *haseval = re->seen_evals;
    if (flags)    
	*flags = ((re->extflags & RXf_UTF8) ? 1 : 0);
    if (lp)
	*lp = re->wraplen;
    return re->wrapped;
d4978 3
a4984 1
    dVAR;
d4987 1
a4987 1
    if (!p)
a4995 1
#endif
a5032 1
#ifndef PERL_IN_XSUB_RE
d5036 11
a5046 13
    dVAR;

    struct re_save_state *state;

    SAVEVPTR(PL_curcop);
    SSGROW(SAVESTACK_ALLOC_FOR_RE_SAVE_STATE + 1);

    state = (struct re_save_state *)(PL_savestack + PL_savestack_ix);
    PL_savestack_ix += SAVESTACK_ALLOC_FOR_RE_SAVE_STATE;
    SSPUSHINT(SAVEt_RE_STATE);

    Copy(&PL_reg_state, state, 1, struct re_save_state);

d5048 1
d5050 19
a5068 1
    PL_reg_oldsaved = NULL;
d5070 1
d5072 1
d5074 3
a5076 1
    PL_reg_poscache = NULL;
d5078 7
a5084 3
#ifdef PERL_OLD_COPY_ON_WRITE
    PL_nrs = NULL;
#endif
d5086 1
a5086 4
    /* Save $1..$n (#18107: UTF-8 s/(\w+)/uc($1)/e); AMS 20021106. */
    if (PL_curpm) {
	const REGEXP * const rx = PM_GETRE(PL_curpm);
	if (rx) {
d5089 1
d5091 3
a5093 9
		const STRLEN len = my_snprintf(digits, sizeof(digits), "%lu", (long)i);
		GV *const *const gvp
		    = (GV**)hv_fetch(PL_defstash, digits, len, 0);

		if (gvp) {
		    GV * const gv = *gvp;
		    if (SvTYPE(gv) == SVt_PVGV && GvSV(gv))
			save_scalar(gv);
		}
d5097 4
a5101 1
#endif
a5105 1
    dVAR;
d5114 1
a5114 11
    /* Our definition of isPRINT() ignores locales, so only bytes that are
       not part of UTF-8 are considered printable. I assume that the same
       holds for UTF-EBCDIC.
       Also, code point 255 is not printable in either (it's E0 in EBCDIC,
       which Wikipedia says:

       EO, or Eight Ones, is an 8-bit EBCDIC character code represented as all
       ones (binary 1111 1111, hexadecimal FF). It is similar, but not
       identical, to the ASCII delete (DEL) or rubout control character.
       ) So the old condition can be simplified to !isPRINT(c)  */
    if (!isPRINT(c))
d5116 4
a5119 6
    else {
	const char string = c;
	if (c == '-' || c == ']' || c == '\\' || c == '^')
	    sv_catpvs(sv, "\\");
	sv_catpvn(sv, &string, 1);
    }
d5123 2
a5124 12
#define CLEAR_OPTSTART \
    if (optstart) STMT_START { \
	    DEBUG_OPTIMISE_r(PerlIO_printf(Perl_debug_log, " (%"IVdf" nodes)\n", (IV)(node - optstart))); \
	    optstart=NULL; \
    } STMT_END

#define DUMPUNTIL(b,e) CLEAR_OPTSTART; node=dumpuntil(r,start,(b),(e),last,sv,indent+1,depth+1);

STATIC const regnode *
S_dumpuntil(pTHX_ const regexp *r, const regnode *start, const regnode *node,
	    const regnode *last, const regnode *plast, 
	    SV* sv, I32 indent, U32 depth)
d5126 2
a5127 15
    dVAR;
    register U8 op = PSEUDO;	/* Arbitrary non-END op. */
    register const regnode *next;
    const regnode *optstart= NULL;
    
    RXi_GET_DECL(r,ri);
    GET_RE_DEBUG_FLAGS_DECL;
    
#ifdef DEBUG_DUMPUNTIL
    PerlIO_printf(Perl_debug_log, "--- %d : %d - %d - %d\n",indent,node-start,
        last ? last-start : 0,plast ? plast-start : 0);
#endif
            
    if (plast && plast < last) 
        last= plast;
d5129 1
a5129 1
    while (PL_regkind[op] != END && (!last || node < last)) {
d5131 1
d5134 3
a5136 4
	if (op == CLOSE || op == WHILEM)
	    indent--;
	next = regnext((regnode *)node);

d5138 3
a5140 9
	if (OP(node) == OPTIMIZED) {
	    if (!optstart && RE_DEBUG_FLAG(RE_DEBUG_COMPILE_OPTIMISE))
	        optstart = node;
	    else
		goto after_print;
	} else
	    CLEAR_OPTSTART;
	
	regprop(r, sv, node);
d5142 6
a5147 12
		      (int)(2*indent + 1), "", SvPVX_const(sv));
        
        if (OP(node) != OPTIMIZED) {		      
            if (next == NULL)		/* Next ptr. */
                PerlIO_printf(Perl_debug_log, " (0)");
            else if (PL_regkind[(U8)op] == BRANCH && PL_regkind[OP(next)] != BRANCH )
                PerlIO_printf(Perl_debug_log, " (FAIL)");
            else 
                PerlIO_printf(Perl_debug_log, " (%"IVdf")", (IV)(next - start));
            (void)PerlIO_putc(Perl_debug_log, '\n'); 
        }
        
d5150 6
a5155 9
	    assert(next);
	    {
                register const regnode *nnode = (OP(next) == LONGJMP
					     ? regnext((regnode *)next)
					     : next);
                if (last && nnode > last)
                    nnode = last;
                DUMPUNTIL(NEXTOPER(NEXTOPER(node)), nnode);
	    }
d5158 1
a5158 2
	    assert(next);
	    DUMPUNTIL(NEXTOPER(node), next);
d5160 3
a5162 51
	else if ( PL_regkind[(U8)op]  == TRIE ) {
	    const regnode *this_trie = node;
	    const char op = OP(node);
            const U32 n = ARG(node);
	    const reg_ac_data * const ac = op>=AHOCORASICK ?
               (reg_ac_data *)ri->data->data[n] :
               NULL;
	    const reg_trie_data * const trie =
	        (reg_trie_data*)ri->data->data[op<AHOCORASICK ? n : ac->trie];
#ifdef DEBUGGING
	    AV *const trie_words = (AV *) ri->data->data[n + TRIE_WORDS_OFFSET];
#endif
	    const regnode *nextbranch= NULL;
	    I32 word_idx;
            sv_setpvn(sv, "", 0);
	    for (word_idx= 0; word_idx < (I32)trie->wordcount; word_idx++) {
		SV ** const elem_ptr = av_fetch(trie_words,word_idx,0);
		
                PerlIO_printf(Perl_debug_log, "%*s%s ",
                   (int)(2*(indent+3)), "",
                    elem_ptr ? pv_pretty(sv, SvPV_nolen_const(*elem_ptr), SvCUR(*elem_ptr), 60,
	                    PL_colors[0], PL_colors[1],
	                    (SvUTF8(*elem_ptr) ? PERL_PV_ESCAPE_UNI : 0) |
	                    PERL_PV_PRETTY_ELLIPSES    |
	                    PERL_PV_PRETTY_LTGT
                            )
                            : "???"
                );
                if (trie->jump) {
                    U16 dist= trie->jump[word_idx+1];
		    PerlIO_printf(Perl_debug_log, "(%"UVuf")\n",
				  (UV)((dist ? this_trie + dist : next) - start));
                    if (dist) {
                        if (!nextbranch)
                            nextbranch= this_trie + trie->jump[0];    
			DUMPUNTIL(this_trie + dist, nextbranch);
                    }
                    if (nextbranch && PL_regkind[OP(nextbranch)]==BRANCH)
                        nextbranch= regnext((regnode *)nextbranch);
                } else {
                    PerlIO_printf(Perl_debug_log, "\n");
		}
	    }
	    if (last && next > last)
	        node= last;
	    else
	        node= next;
	}
	else if ( op == CURLY ) {   /* "next" might be very big: optimizer */
	    DUMPUNTIL(NEXTOPER(node) + EXTRA_STEP_2ARGS,
                    NEXTOPER(node) + EXTRA_STEP_2ARGS + 1);
d5165 2
a5166 2
	    assert(next);
	    DUMPUNTIL(NEXTOPER(node) + EXTRA_STEP_2ARGS, next);
d5169 1
a5169 1
	    DUMPUNTIL(NEXTOPER(node), NEXTOPER(node) + 1);
d5187 3
a5189 1
	    indent++;
a5190 4
    CLEAR_OPTSTART;
#ifdef DEBUG_DUMPUNTIL    
    PerlIO_printf(Perl_debug_log, "--- %d\n", (int)indent);
#endif
@


1.1.1.11
log
@import perl 5.10.1
@
text
@d5 1
a5 3
 * 'A fair jaw-cracker dwarf-language must be.'            --Samwise Gamgee
 *
 *     [p.285 of _The Lord of the Rings_, II/iii: "The Ring Goes South"]
d60 1
a60 2
 ****    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
 ****    by Larry Wall and others
a632 2
    PERL_ARGS_ASSERT_SCAN_COMMIT;

a678 2
    PERL_ARGS_ASSERT_CL_ANYTHING;

a691 2
    PERL_ARGS_ASSERT_CL_IS_ANYTHING;

a705 2
    PERL_ARGS_ASSERT_CL_INIT;

a713 2
    PERL_ARGS_ASSERT_CL_INIT_ZERO;

a726 1
    PERL_ARGS_ASSERT_CL_AND;
a764 2
    PERL_ARGS_ASSERT_CL_OR;

a855 1
    PERL_ARGS_ASSERT_DUMP_TRIE;
a937 3

    PERL_ARGS_ASSERT_DUMP_TRIE_INTERIM_LIST;

a992 2

    PERL_ARGS_ASSERT_DUMP_TRIE_INTERIM_TABLE;
d1233 1
a1233 1
            tmp = newSVpvn_utf8(STRING(noper), STR_LEN(noper), UTF);	\
d1235 2
a1236 1
            tmp = newSVpvn_utf8( "", 0, UTF );			\
a1320 2

    PERL_ARGS_ASSERT_MAKE_TRIE;
d1976 1
a1976 1
                                        PerlIO_printf(Perl_debug_log, "%s", (char*)ch)
a2164 2

    PERL_ARGS_ASSERT_MAKE_TRIE_FAILTABLE;
a2280 2

    PERL_ARGS_ASSERT_JOIN_EXACT;
d2491 1
a2493 2
    PERL_ARGS_ASSERT_STUDY_CHUNK;

d3321 3
a3323 1
			last_str = newSVpvn_utf8(s  + old, l, UTF);
d3702 5
a3706 16
		    if (flags & SCF_DO_STCLASS_OR) {
			/* OR before, AND after: ideally we would recurse with
			 * data_fake to get the AND applied by study of the
			 * remainder of the pattern, and then derecurse;
			 * *** HACK *** for now just treat as "no information".
			 * See [perl #56690].
			 */
			cl_init(pRExC_state, data->start_class);
		    }  else {
			/* AND before and after: combine and continue */
			const int was = (data->start_class->flags & ANYOF_EOS);

			cl_and(data->start_class, &intrnl);
			if (was)
			    data->start_class->flags |= ANYOF_EOS;
		    }
a4052 2
    PERL_ARGS_ASSERT_ADD_DATA;

a4135 3

    PERL_ARGS_ASSERT_PREGCOMP;

a4175 3

    PERL_ARGS_ASSERT_RE_COMPILE;

d4284 1
a4284 1
    RX_PRELEN(r) = plen;
d4290 1
a4290 2
	U16 reganch = (U16)((r->extflags & RXf_PMf_STD_PMMOD)
			    >> RXf_PMf_STD_PMMOD_SHIFT);
d4293 1
a4293 1
        RX_WRAPLEN(r) = plen + has_minus + has_p + has_runon
d4297 2
a4298 2
        Newx(RX_WRAPPED(r), RX_WRAPLEN(r) + 1, char );
        p = RX_WRAPPED(r);
d4321 3
a4323 3
        Copy(RExC_precomp, p, plen, char);
        RX_PRECOMP(r) = p;
        p += plen;
d4382 1
a4382 4
    if (!restudied) {
        StructCopy(&zero_scan_data, &data, scan_data_t);
        copyRExC_state = RExC_state;
    } else {
d4397 3
d4427 1
a4427 11
	/*
	 * Skip introductions and multiplicators >= 1
	 * so that we can extract the 'meat' of the pattern that must 
	 * match in the large if() sequence following.
	 * NOTE that EXACT is NOT covered here, as it is normally
	 * picked up by the optimiser separately. 
	 *
	 * This is unfortunate as the optimiser isnt handling lookahead
	 * properly currently.
	 *
	 */
d4439 1
a4439 5
		/* 
		 * the only op that could be a regnode is PLUS, all the rest
		 * will be regnode_1 or regnode_2.
		 *
		 */
d4444 5
a4448 2
		
		first = NEXTOPER(first);
d4792 1
a4792 1
        RXp_PAREN_NAMES(r) = MUTABLE_HV(SvREFCNT_inc(RExC_paren_names));
d4794 1
a4794 1
        RXp_PAREN_NAMES(r) = NULL;
d4797 1
a4797 1
    if (RX_PRELEN(r) == 0)
d4799 1
a4799 1
    if (r->extflags & RXf_SPLIT && RX_PRELEN(r) == 1 && RX_PRECOMP(r)[0] == ' ')
d4802 1
a4802 1
    else if (RX_PRELEN(r) == 3 && memEQ("\\s+", RX_PRECOMP(r), 3))
d4804 1
a4804 1
    else if (RX_PRELEN(r) == 1 && RXp_PRECOMP(r)[0] == '^')
d4807 1
a4807 1
    if (r->extflags & RXf_SPLIT && RX_PRELEN(r) == 1 && RX_PRECOMP(r)[0] == ' ')
a4867 2
    PERL_ARGS_ASSERT_REG_NAMED_BUFF;

d4873 1
a4873 1
        Perl_croak(aTHX_ "%s", PL_no_modify);
a4892 1
    PERL_ARGS_ASSERT_REG_NAMED_BUFF_ITER;
a4909 3

    PERL_ARGS_ASSERT_REG_NAMED_BUFF_FETCH;

d4913 2
a4914 2
    if (rx && RXp_PAREN_NAMES(rx)) {
        HE *he_str = hv_fetch_ent( RXp_PAREN_NAMES(rx), namesv, 0, 0 );
d4931 2
a4932 1
                if (retarray)
d4934 1
d4937 1
a4937 1
                return newRV_noinc(MUTABLE_SV(retarray));
d4947 1
a4947 4

    PERL_ARGS_ASSERT_REG_NAMED_BUFF_EXISTS;

    if (rx && RXp_PAREN_NAMES(rx)) {
d4949 1
a4949 1
            return hv_exists_ent(RXp_PAREN_NAMES(rx), key, 0);
d4967 2
a4968 5

    PERL_ARGS_ASSERT_REG_NAMED_BUFF_FIRSTKEY;

    if ( rx && RXp_PAREN_NAMES(rx) ) {
	(void)hv_iterinit(RXp_PAREN_NAMES(rx));
d4979 2
a4980 6
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_REG_NAMED_BUFF_NEXTKEY;

    if (rx && RXp_PAREN_NAMES(rx)) {
        HV *hv = RXp_PAREN_NAMES(rx);
d4988 1
a4988 1
                if ((I32)(rx->lastparen) >= nums[i] &&
d4997 3
a4999 1
		return newSVhek(HeKEY_hek(temphe));
d5013 1
a5013 3
    PERL_ARGS_ASSERT_REG_NAMED_BUFF_SCALAR;

    if (rx && RXp_PAREN_NAMES(rx)) {
d5015 1
a5015 1
            return newSViv(HvTOTALKEYS(RXp_PAREN_NAMES(rx)));
d5018 1
a5018 1
            av = MUTABLE_AV(SvRV(ret));
a5019 1
	    SvREFCNT_dec(ret);
d5034 2
a5035 4
    PERL_ARGS_ASSERT_REG_NAMED_BUFF_ALL;

    if (rx && RXp_PAREN_NAMES(rx)) {
        HV *hv= RXp_PAREN_NAMES(rx);
d5044 1
a5044 1
                if ((I32)(rx->lastparen) >= nums[i] &&
d5053 3
a5055 1
                av_push(av, newSVhek(HeKEY_hek(temphe)));
d5060 1
a5060 1
    return newRV_noinc(MUTABLE_SV(av));
a5068 2

    PERL_ARGS_ASSERT_REG_NUMBERED_BUFF_FETCH;
d5105 1
a5105 1
            ? (RXp_MATCH_UTF8(rx)
d5107 1
a5107 1
            : (RXp_MATCH_UTF8(rx)) )
d5114 1
a5114 1
            if (RXp_MATCH_TAINTED(rx)) {
a5141 2
    PERL_ARGS_ASSERT_REG_NUMBERED_BUFF_STORE;

d5147 1
a5147 1
        Perl_croak(aTHX_ "%s", PL_no_modify);
a5156 2
    PERL_ARGS_ASSERT_REG_NUMBERED_BUFF_LENGTH;

d5191 1
a5191 1
                report_uninit((SV *)sv);
d5196 1
a5196 1
    if (i > 0 && RXp_MATCH_UTF8(rx)) {
a5210 1
    PERL_ARGS_ASSERT_REG_QR_PACKAGE;
d5228 1
a5228 2
S_reg_scan_name(pTHX_ RExC_state_t *pRExC_state, U32 flags)
{
a5230 2
    PERL_ARGS_ASSERT_REG_SCAN_NAME;

d5244 4
a5247 3
        SV* sv_name
	    = newSVpvn_flags(name_start, (int)(RExC_parse - name_start),
			     SVs_TEMP | (UTF ? SVf_UTF8 : 0));
a5361 2

    PERL_ARGS_ASSERT_REG;
d5551 1
a5551 1
                            sv_2mortal(MUTABLE_SV(RExC_paren_names));
d5554 1
a5554 1
                            sv_2mortal(MUTABLE_SV(RExC_paren_name_list));
d5583 1
a5583 1
                                SvIV_set(sv_dat, SvIVX(sv_dat) + 1);
d5589 1
a5589 1
                            SvIV_set(sv_dat, 1);
a5604 2
		RExC_seen_zerolen++;
			break;
a6047 7

    if (freeze_paren) {
        if (RExC_npar > after_freeze)
            after_freeze = RExC_npar;
        RExC_npar = freeze_paren;
    }

a6205 3

    PERL_ARGS_ASSERT_REGBRANCH;

a6280 3

    PERL_ARGS_ASSERT_REGPIECE;

d6358 1
a6358 1
	    if (max < min)
d6498 1
a6498 3
 
    PERL_ARGS_ASSERT_REG_NAMEDSEQ;
   
d6519 1
d6525 2
a6527 1
	    if (cp > 0xff) RExC_utf8 = 1;
d6531 2
a6532 14

	/* Need to convert to utf8 if either: won't fit into a byte, or the re
	 * is going to be in utf8 and the representation changes under utf8. */
	if (cp > 0xff || (RExC_utf8 && ! UNI_IS_INVARIANT(cp))) {
	    U8 string[UTF8_MAXBYTES+1];
	    U8 *tmps;
	    RExC_utf8 = 1;
	    tmps = uvuni_to_utf8(string, cp);
	    sv_str = newSVpvn_utf8((char*)string, tmps - string, TRUE);
	} else {    /* Otherwise, no need for utf8, can skip that step */
	    char string;
	    string = (char)cp;
	    sv_str= newSVpvn(&string, 1);
	}
d6560 1
a6560 1
            sv_2mortal(MUTABLE_SV(RExC_charnames));
d6711 1
a6711 1
    } else {	/* zero length */
d6739 1
a6739 1
    SV * const sv = newSVpvn_flags(&value, numlen, SVs_TEMP);
a6743 2
    PERL_ARGS_ASSERT_REG_RECODE;

a6789 1
    PERL_ARGS_ASSERT_REGATOM;
a7469 3

    PERL_ARGS_ASSERT_REGWHITE;

a7505 2
    PERL_ARGS_ASSERT_REGPPOSIXCC;

a7619 3

    PERL_ARGS_ASSERT_CHECKPOSIXCC;

a7684 16
/* 
   We dont use PERL_LEGACY_UNICODE_CHARCLASS_MAPPINGS as the direct test
   so that it is possible to override the option here without having to 
   rebuild the entire core. as we are required to do if we change regcomp.h
   which is where PERL_LEGACY_UNICODE_CHARCLASS_MAPPINGS is defined.
*/
#if PERL_LEGACY_UNICODE_CHARCLASS_MAPPINGS
#define BROKEN_UNICODE_CHARCLASS_MAPPINGS
#endif

#ifdef BROKEN_UNICODE_CHARCLASS_MAPPINGS
#define POSIX_CC_UNI_NAME(CCNAME) CCNAME
#else
#define POSIX_CC_UNI_NAME(CCNAME) "Posix" CCNAME
#endif

a7717 2

    PERL_ARGS_ASSERT_REGCLASS;
a7970 12
		
		case _C_C_T_(ALNUMC, isALNUMC(value), POSIX_CC_UNI_NAME("Alnum"));
		case _C_C_T_(ALPHA, isALPHA(value), POSIX_CC_UNI_NAME("Alpha"));
		case _C_C_T_(BLANK, isBLANK(value), POSIX_CC_UNI_NAME("Blank"));
		case _C_C_T_(CNTRL, isCNTRL(value), POSIX_CC_UNI_NAME("Cntrl"));
		case _C_C_T_(GRAPH, isGRAPH(value), POSIX_CC_UNI_NAME("Graph"));
		case _C_C_T_(LOWER, isLOWER(value), POSIX_CC_UNI_NAME("Lower"));
		case _C_C_T_(PRINT, isPRINT(value), POSIX_CC_UNI_NAME("Print"));
		case _C_C_T_(PSXSPC, isPSXSPC(value), POSIX_CC_UNI_NAME("Space"));
		case _C_C_T_(PUNCT, isPUNCT(value), POSIX_CC_UNI_NAME("Punct"));
		case _C_C_T_(UPPER, isUPPER(value), POSIX_CC_UNI_NAME("Upper"));
#ifdef BROKEN_UNICODE_CHARCLASS_MAPPINGS
d7972 9
d7982 1
a7982 4
#else
		case _C_C_T_(SPACE, isSPACE(value), "PerlSpace");
		case _C_C_T_(ALNUM, isALNUM(value), "PerlWord");
#endif		
d8029 1
a8029 1
		    what = POSIX_CC_UNI_NAME("Digit");
d8042 1
a8042 1
		    what = POSIX_CC_UNI_NAME("Digit");
d8181 2
a8182 2
				  sv = newSVpvn_utf8((char*)foldbuf, foldlen,
						     TRUE);
a8241 3
	if (listsv) {
	    SvREFCNT_dec(listsv);
	}
d8278 2
a8279 2
	av_store(av, 2, MUTABLE_SV(unicode_alternate));
	rv = newRV_noinc(MUTABLE_SV(av));
a8304 3

    PERL_ARGS_ASSERT_REG_SKIPCOMMENT;

a8336 2
    PERL_ARGS_ASSERT_NEXTCHAR;

a8372 2
    PERL_ARGS_ASSERT_REG_NODE;

a8411 2
    PERL_ARGS_ASSERT_REGANODE;

a8461 3

    PERL_ARGS_ASSERT_REGUNI;

a8479 2

    PERL_ARGS_ASSERT_REGINSERT;
a8561 2

    PERL_ARGS_ASSERT_REGTAIL;
d8622 1
a8624 2
    PERL_ARGS_ASSERT_REGTAIL_STUDY;

a8693 2
    PERL_ARGS_ASSERT_REGCURLY;

d8715 1
a8715 2
S_regdump_extflags(pTHX_ const char *lead, const U32 flags)
{
a8717 1

a8743 2
    PERL_ARGS_ASSERT_REGDUMP;

a8817 1
    PERL_ARGS_ASSERT_REGDUMP;
a8825 11
#define EMIT_ANYOF_TEST_SEPARATOR(do_sep,sv,flags) \
STMT_START { \
        if (do_sep) {                           \
            Perl_sv_catpvf(aTHX_ sv,"%s][%s",PL_colors[1],PL_colors[0]); \
            if (flags & ANYOF_INVERT)           \
                /*make sure the invert info is in each */ \
                sv_catpvs(sv, "^");             \
            do_sep = 0;                         \
        }                                       \
} STMT_END

a8834 1
    PERL_ARGS_ASSERT_REGPROP;
d8836 1
a8836 1
    sv_setpvs(sv, "");
d8915 1
a8915 1
	if ( RXp_PAREN_NAMES(prog) ) {
d8917 1
a8917 1
	        AV *list= MUTABLE_AV(progi->data->data[progi->name_list_idx]);
d8923 2
a8924 2
                AV *list= MUTABLE_AV(progi->data->data[ progi->name_list_idx ]);
                SV *sv_dat= MUTABLE_SV(progi->data->data[ ARG( o ) ]);
d8942 1
a8942 1
			   SVfARG((MUTABLE_SV(progi->data->data[ ARG( o ) ]))));
a8949 1
	int do_sep = 0;
d8965 2
a8966 2
	    "[:cntrl:]",
	    "[:^cntrl:]",
a8991 2
	
	/* output what the standard cp 0-255 bitmap matches */
a9004 1
		do_sep = 1;
d9008 1
a9008 3
        
        EMIT_ANYOF_TEST_SEPARATOR(do_sep,sv,flags);
        /* output any special charclass tests (used mostly under use locale) */
d9011 1
a9011 1
		if (ANYOF_CLASS_TEST(o,i)) {
d9013 1
a9013 6
		    do_sep = 1;
		}
        
        EMIT_ANYOF_TEST_SEPARATOR(do_sep,sv,flags);
        
        /* output information about the unicode matching */
d9026 1
a9026 1

a9100 2

    PERL_ARGS_ASSERT_RE_INTUIT_STRING;
d9136 1
a9136 1
Perl_pregfree(pTHX_ REGEXP *r)
d9147 3
a9149 3
        if (RXp_PAREN_NAMES(r))
            SvREFCNT_dec(RXp_PAREN_NAMES(r));
        Safefree(RX_WRAPPED(r));
d9189 2
a9190 2
REGEXP *
Perl_reg_temp_copy (pTHX_ REGEXP *r) {
a9192 3

    PERL_ARGS_ASSERT_REG_TEMP_COPY;

d9240 1
a9240 3

    PERL_ARGS_ASSERT_REGFREE_INTERNAL;

d9246 2
a9247 2
            RE_PV_QUOTED_DECL(s, RX_UTF8(r),
                dsv, RX_PRECOMP(r), RX_PRELEN(r), 60);
d9268 1
a9268 1
		SvREFCNT_dec(MUTABLE_SV(ri->data->data[n]));
d9274 1
a9274 1
		new_comppad = MUTABLE_AV(ri->data->data[n]);
d9290 1
a9290 1
		SvREFCNT_dec(MUTABLE_SV(new_comppad));
d9349 2
a9350 2
#define av_dup_inc(s,t)	MUTABLE_AV(SvREFCNT_inc(sv_dup((const SV *)s,t)))
#define hv_dup_inc(s,t)	MUTABLE_HV(SvREFCNT_inc(sv_dup((const SV *)s,t)))
d9356 2
a9357 2
   This routine is expected to clone a given regexp structure. It is only
   compiled under USE_ITHREADS.
a9373 3
    U32 precomp_offset;
    
    PERL_ARGS_ASSERT_RE_DUP;
d9381 1
d9396 1
a9396 3
	const bool anchored = r->check_substr
	    ? r->check_substr == r->anchored_substr
	    : r->check_utf8 == r->anchored_utf8;
a9418 6
	} else if (ret->check_utf8) {
	    if (anchored) {
		ret->check_utf8 = ret->anchored_utf8;
	    } else {
		ret->check_utf8 = ret->float_utf8;
	    }
d9422 3
a9424 5
    precomp_offset = RX_PRECOMP(ret) - ret->wrapped;

    RX_WRAPPED(ret)     = SAVEPVN(RX_WRAPPED(ret), RX_WRAPLEN(ret)+1);
    RX_PRECOMP(ret)     = ret->wrapped + precomp_offset;
    RXp_PAREN_NAMES(ret) = hv_dup_inc(RXp_PAREN_NAMES(ret), param);
d9439 1
a9466 2

    PERL_ARGS_ASSERT_REGDUPE_INTERNAL;
d9471 1
a9471 1
    Newxc(reti, sizeof(regexp_internal) + len*sizeof(regnode), char, regexp_internal);
d9496 1
a9496 1
		d->data[i] = sv_dup_inc((const SV *)ri->data->data[i], param);
d9585 1
a9585 1
    const REGEXP * const re = (REGEXP *)mg->mg_obj;
d9587 1
a9587 1
        *haseval = RX_SEEN_EVALS(re);
d9589 1
a9589 1
	*flags = RX_UTF8(re) ? 1 : 0;
d9591 2
a9592 2
	*lp = RX_WRAPLEN(re);
    return RX_WRAPPED(re);
a9624 2
    PERL_ARGS_ASSERT_RE_CROAK2;

d9685 1
a9685 1
	    for (i = 1; i <= RX_NPARENS(rx); i++) {
d9706 1
a9706 1
    ReREFCNT_dec((REGEXP *)r);
a9713 2
    PERL_ARGS_ASSERT_PUT_BYTE;

d9755 1
a9755 3

    PERL_ARGS_ASSERT_DUMPUNTIL;

d9821 1
a9821 1
	    AV *const trie_words = MUTABLE_AV(ri->data->data[n + TRIE_WORDS_OFFSET]);
d9825 1
a9825 1
            sv_setpvs(sv, "");
@


1.1.1.12
log
@Perl 5.12.2 from CPAN
@
text
@a107 1
    REGEXP	*rx_sv;			/* The SV that is the regexp. */
d134 1
a154 1
#define RExC_rx_sv	(pRExC_state->rx_sv)
d178 1
d395 1
a395 1
	SAVEDESTRUCTOR_X(clear_re,(void*)RExC_rx_sv);			\
d426 1
a426 1
	SAVEDESTRUCTOR_X(clear_re,(void*)RExC_rx_sv);	\
d444 1
a444 1
	SAVEDESTRUCTOR_X(clear_re,(void*)RExC_rx_sv);	\
d463 1
a463 1
	SAVEDESTRUCTOR_X(clear_re,(void*)RExC_rx_sv);	\
d476 1
a476 1
#define	ckWARNreg(loc,m) STMT_START {					\
d478 2
a479 2
    Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP), m REPORT_LOCATION,	\
	    (int)offset, RExC_precomp, RExC_precomp + offset);		\
d482 1
a482 1
#define	ckWARNregdep(loc,m) STMT_START {				\
d484 3
a486 3
    Perl_ck_warner_d(aTHX_ packWARN2(WARN_DEPRECATED, WARN_REGEXP),	\
	    m REPORT_LOCATION,						\
	    (int)offset, RExC_precomp, RExC_precomp + offset);		\
d489 2
a490 1
#define	ckWARN2reg(loc, m, a1) STMT_START {				\
d492 1
a492 1
    Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP), m REPORT_LOCATION,	\
a501 6
#define	ckWARN3reg(loc, m, a1, a2) STMT_START {				\
    const IV offset = loc - RExC_precomp;				\
    Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP), m REPORT_LOCATION,	\
	    a1, a2, (int)offset, RExC_precomp, RExC_precomp + offset);	\
} STMT_END

a507 6
#define	ckWARN4reg(loc, m, a1, a2, a3) STMT_START {			\
    const IV offset = loc - RExC_precomp;				\
    Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP), m REPORT_LOCATION,	\
	    a1, a2, a3, (int)offset, RExC_precomp, RExC_precomp + offset); \
} STMT_END

d2823 6
a2828 7
    Currently we do not believe that the trie logic can
    handle case insensitive matching properly when the
    pattern is not unicode (thus forcing unicode semantics).

    If/when this is fixed the following define can be swapped
    in below to fully enable trie logic.

a2829 4

*/
#define TRIE_TYPE_IS_SAFE (UTF || optype==EXACT)

d3180 2
a3181 1
		    && maxcount <= REG_INFTY/3) /* Complement check for big count */
d3183 2
a3184 2
		    ckWARNreg(RExC_parse,
			      "Quantifier unexpected on zero-length expression");
d4171 1
a4171 1
Perl_pregcomp(pTHX_ SV * const pattern, const U32 flags)
d4197 1
a4197 1
Perl_re_compile(pTHX_ SV * const pattern, U32 pm_flags)
d4200 1
a4200 2
    REGEXP *rx;
    struct regexp *r;
d4203 1
a4203 1
    char  *exp = SvPV(pattern, plen);
d4223 1
a4223 1
    RExC_utf8 = RExC_orig_utf8 = SvUTF8(pattern);
d4253 1
d4312 1
a4312 2
    rx = (REGEXP*) newSV_type(SVt_REGEXP);
    r = (struct regexp*)SvANY(rx);
d4328 2
d4339 1
a4339 1
	const STRLEN wraplen = plen + has_minus + has_p + has_runon
d4343 2
a4344 4
	p = sv_grow(MUTABLE_SV(rx), wraplen + 1);
	SvCUR_set(rx, wraplen);
	SvPOK_on(rx);
	SvFLAGS(rx) |= SvUTF8(pattern);
d4368 1
a4368 2
	assert ((RX_WRAPPED(rx) - p) < 16);
	r->pre_prefix = p - RX_WRAPPED(rx);
a4394 1
    RExC_rx_sv = rx;
d4412 1
a4412 1
	ReREFCNT_dec(rx);   
d4456 1
a4456 1
	SvUTF8_on(rx);	/* Unicode in it? */
d4854 1
a4854 1
    if (RX_PRELEN(rx) == 0)
d4856 1
a4856 1
    if (r->extflags & RXf_SPLIT && RX_PRELEN(rx) == 1 && RX_PRECOMP(rx)[0] == ' ')
d4859 1
a4859 1
    else if (RX_PRELEN(rx) == 3 && memEQ("\\s+", RX_PRECOMP(rx), 3))
d4861 1
a4861 1
    else if (RX_PRELEN(rx) == 1 && RXp_PRECOMP(rx)[0] == '^')
d4864 1
a4864 1
    if (r->extflags & RXf_SPLIT && RX_PRELEN(rx) == 1 && RX_PRECOMP(rx)[0] == ' ')
d4915 1
a4915 1
    return rx;
d4966 1
a4966 2
Perl_reg_named_buff_fetch(pTHX_ REGEXP * const r, SV * const namesv,
			  const U32 flags)
a4969 1
    struct regexp *const rx = (struct regexp *)SvANY(r);
d4988 1
a4988 1
                    CALLREG_NUMBUF_FETCH(r,nums[i],ret);
d5005 1
a5005 1
Perl_reg_named_buff_exists(pTHX_ REGEXP * const r, SV * const key,
a5007 1
    struct regexp *const rx = (struct regexp *)SvANY(r);
d5015 1
a5015 1
	    SV *sv = CALLREG_NAMED_BUFF_FETCH(r, key, flags);
d5029 1
a5029 1
Perl_reg_named_buff_firstkey(pTHX_ REGEXP * const r, const U32 flags)
a5030 1
    struct regexp *const rx = (struct regexp *)SvANY(r);
d5037 1
a5037 1
	return CALLREG_NAMED_BUFF_NEXTKEY(r, NULL, flags & ~RXapif_FIRSTKEY);
d5044 1
a5044 1
Perl_reg_named_buff_nextkey(pTHX_ REGEXP * const r, const U32 flags)
a5045 1
    struct regexp *const rx = (struct regexp *)SvANY(r);
d5076 1
a5076 1
Perl_reg_named_buff_scalar(pTHX_ REGEXP * const r, const U32 flags)
a5080 1
    struct regexp *const rx = (struct regexp *)SvANY(r);
d5088 1
a5088 1
            ret = CALLREG_NAMED_BUFF_ALL(r, (flags | RXapif_REGNAMES));
d5102 1
a5102 1
Perl_reg_named_buff_all(pTHX_ REGEXP * const r, const U32 flags)
a5103 1
    struct regexp *const rx = (struct regexp *)SvANY(r);
d5136 1
a5136 2
Perl_reg_numbered_buff_fetch(pTHX_ REGEXP * const r, const I32 paren,
			     SV * const sv)
a5137 1
    struct regexp *const rx = (struct regexp *)SvANY(r);
d5227 1
a5227 1
Perl_reg_numbered_buff_length(pTHX_ REGEXP * const r, const SV * const sv,
a5229 1
    struct regexp *const rx = (struct regexp *)SvANY(r);
d5269 1
a5269 1
                report_uninit((const SV *)sv);
d5291 1
a5291 4
	if (0)
	    return NULL;
	else
	    return newSVpvs("Regexp");
d6060 2
a6061 2
                            if (SIZE_ONLY)
                                ckWARNreg(RExC_parse + 1,"Useless use of (?-p)");
d6516 5
a6520 5
    if (!SIZE_ONLY && !(flags&(HASWIDTH|POSTPONED)) && max > REG_INFTY/3) {
	ckWARN3reg(RExC_parse,
		   "%.*s matches null string many times",
		   (int)(RExC_parse >= origparse ? RExC_parse - origparse : 0),
		   origparse);
d6555 1
a6555 1
   recognized '\N' and needs to handle the rest. RExC_parse is
a6557 17

   The \N may be inside (indicated by valuep not being NULL) or outside a
   character class.

   \N may begin either a named sequence, or if outside a character class, mean
   to match a non-newline.  For non single-quoted regexes, the tokenizer has
   attempted to decide which, and in the case of a named sequence converted it
   into one of the forms: \N{} (if the sequence is null), or \N{U+c1.c2...},
   where c1... are the characters in the sequence.  For single-quoted regexes,
   the tokenizer passes the \N sequence through unchanged; this code will not
   attempt to determine this nor expand those.  The net effect is that if the
   beginning of the passed-in pattern isn't '{U+' or there is no '}', it
   signals that this \N occurrence means to match a non-newline.
   
   Only the \N{U+...} form should occur in a character class, for the same
   reason that '.' inside a character class means to just match a period: it
   just doesn't make sense.
d6563 1
a6563 1
   handler, a warning will be issued, and only the first char in the 
d6569 5
a6573 5
   If valuep is null then it is assumed that we are parsing normal text and a
   new EXACT node is inserted into the program containing the resolved string,
   and a pointer to the new node is returned.  But if the string is zero length
   a NOTHING node is emitted instead.

d6575 10
a6584 1
   Parsing failures will generate a fatal error via vFAIL(...)
d6587 1
a6587 1
S_reg_namedseq(pTHX_ RExC_state_t *pRExC_state, UV *valuep, I32 *flagp)
d6589 6
a6594 1
    char * endbrace;    /* '}' following the name */
a6595 6
#ifdef DEBUGGING
    char* parse_start = RExC_parse - 2;	    /* points to the '\N' */
#endif
    char* p;

    GET_RE_DEBUG_FLAGS_DECL;
a6597 8

    GET_RE_DEBUG_FLAGS;

    /* The [^\n] meaning of \N ignores spaces and comments under the /x
     * modifier.  The other meaning does not */
    p = (RExC_flags & RXf_PMf_EXTENDED)
	? regwhite( pRExC_state, RExC_parse )
	: RExC_parse;
d6599 2
a6600 15
    /* Disambiguate between \N meaning a named character versus \N meaning
     * [^\n].  The former is assumed when it can't be the latter. */
    if (*p != '{' || regcurly(p)) {
	RExC_parse = p;
	if (valuep) {
	    /* no bare \N in a charclass */
	    vFAIL("\\N in a character class must be a named character: \\N{...}");
	}
	nextchar(pRExC_state);
	ret = reg_node(pRExC_state, REG_ANY);
	*flagp |= HASWIDTH|SIMPLE;
	RExC_naughty++;
	RExC_parse--;
        Set_Node_Length(ret, 1); /* MJD */
	return ret;
d6602 27
d6630 49
a6678 1
    /* Here, we have decided it should be a named sequence */
d6680 27
a6706 6
    /* The test above made sure that the next real character is a '{', but
     * under the /x modifier, it could be separated by space (or a comment and
     * \n) and this is not allowed (for consistency with \x{...} and the
     * tokenizer handling of \N{NAME}). */
    if (*RExC_parse != '{') {
	vFAIL("Missing braces on \\N{}");
d6708 115
a6822 10

    RExC_parse++;	/* Skip past the '{' */

    if (! (endbrace = strchr(RExC_parse, '}')) /* no trailing brace */
	|| ! (endbrace == RExC_parse		/* nothing between the {} */
	      || (endbrace - RExC_parse >= 2	/* U+ (bad hex is checked below */
		  && strnEQ(RExC_parse, "U+", 2)))) /* for a better error msg) */
    {
	if (endbrace) RExC_parse = endbrace;	/* position msg's '<--HERE' */
	vFAIL("\\N{NAME} must be resolved by the lexer");
d6824 2
a6825 15

    if (endbrace == RExC_parse) {   /* empty: \N{} */
	if (! valuep) {
	    RExC_parse = endbrace + 1;  
	    return reg_node(pRExC_state,NOTHING);
	}

	if (SIZE_ONLY) {
	    ckWARNreg(RExC_parse,
		    "Ignoring zero length \\N{} in character class"
	    );
	    RExC_parse = endbrace + 1;  
	}
	*valuep = 0;
	return (regnode *) &RExC_parse; /* Invalid regnode pointer */
d6827 2
a6828 153

    RExC_utf8 = 1;	/* named sequences imply Unicode semantics */
    RExC_parse += 2;	/* Skip past the 'U+' */

    if (valuep) {   /* In a bracketed char class */
	/* We only pay attention to the first char of 
	multichar strings being returned. I kinda wonder
	if this makes sense as it does change the behaviour
	from earlier versions, OTOH that behaviour was broken
	as well. XXX Solution is to recharacterize as
	[rest-of-class]|multi1|multi2... */

	STRLEN length_of_hex;
	I32 flags = PERL_SCAN_ALLOW_UNDERSCORES
	    | PERL_SCAN_DISALLOW_PREFIX
	    | (SIZE_ONLY ? PERL_SCAN_SILENT_ILLDIGIT : 0);
    
	char * endchar = RExC_parse + strcspn(RExC_parse, ".}");
	if (endchar < endbrace) {
	    ckWARNreg(endchar, "Using just the first character returned by \\N{} in character class");
	}

	length_of_hex = (STRLEN)(endchar - RExC_parse);
	*valuep = grok_hex(RExC_parse, &length_of_hex, &flags, NULL);

	/* The tokenizer should have guaranteed validity, but it's possible to
	 * bypass it by using single quoting, so check */
	if (length_of_hex == 0
	    || length_of_hex != (STRLEN)(endchar - RExC_parse) )
	{
	    RExC_parse += length_of_hex;	/* Includes all the valid */
	    RExC_parse += (RExC_orig_utf8)	/* point to after 1st invalid */
			    ? UTF8SKIP(RExC_parse)
			    : 1;
	    /* Guard against malformed utf8 */
	    if (RExC_parse >= endchar) RExC_parse = endchar;
	    vFAIL("Invalid hexadecimal number in \\N{U+...}");
	}    

	RExC_parse = endbrace + 1;
	if (endchar == endbrace) return NULL;

        ret = (regnode *) &RExC_parse;	/* Invalid regnode pointer */
    }
    else {	/* Not a char class */
	char *s;	    /* String to put in generated EXACT node */
	STRLEN len = 0;	    /* Its current length */
	char *endchar;	    /* Points to '.' or '}' ending cur char in the input
			       stream */

	ret = reg_node(pRExC_state,
			(U8)(FOLD ? (LOC ? EXACTFL : EXACTF) : EXACT));
	s= STRING(ret);

	/* Exact nodes can hold only a U8 length's of text = 255.  Loop through
	 * the input which is of the form now 'c1.c2.c3...}' until find the
	 * ending brace or exeed length 255.  The characters that exceed this
	 * limit are dropped.  The limit could be relaxed should it become
	 * desirable by reparsing this as (?:\N{NAME}), so could generate
	 * multiple EXACT nodes, as is done for just regular input.  But this
	 * is primarily a named character, and not intended to be a huge long
	 * string, so 255 bytes should be good enough */
	while (1) {
	    STRLEN length_of_hex;
	    I32 grok_flags = PERL_SCAN_ALLOW_UNDERSCORES
			    | PERL_SCAN_DISALLOW_PREFIX
			    | (SIZE_ONLY ? PERL_SCAN_SILENT_ILLDIGIT : 0);
	    UV cp;  /* Ord of current character */

	    /* Code points are separated by dots.  If none, there is only one
	     * code point, and is terminated by the brace */
	    endchar = RExC_parse + strcspn(RExC_parse, ".}");

	    /* The values are Unicode even on EBCDIC machines */
	    length_of_hex = (STRLEN)(endchar - RExC_parse);
	    cp = grok_hex(RExC_parse, &length_of_hex, &grok_flags, NULL);
	    if ( length_of_hex == 0 
		|| length_of_hex != (STRLEN)(endchar - RExC_parse) )
	    {
		RExC_parse += length_of_hex;	    /* Includes all the valid */
		RExC_parse += (RExC_orig_utf8)	/* point to after 1st invalid */
				? UTF8SKIP(RExC_parse)
				: 1;
		/* Guard against malformed utf8 */
		if (RExC_parse >= endchar) RExC_parse = endchar;
		vFAIL("Invalid hexadecimal number in \\N{U+...}");
	    }    

	    if (! FOLD) {	/* Not folding, just append to the string */
		STRLEN unilen;

		/* Quit before adding this character if would exceed limit */
		if (len + UNISKIP(cp) > U8_MAX) break;

		unilen = reguni(pRExC_state, cp, s);
		if (unilen > 0) {
		    s   += unilen;
		    len += unilen;
		}
	    } else {	/* Folding, output the folded equivalent */
		STRLEN foldlen,numlen;
		U8 tmpbuf[UTF8_MAXBYTES_CASE+1], *foldbuf;
		cp = toFOLD_uni(cp, tmpbuf, &foldlen);

		/* Quit before exceeding size limit */
		if (len + foldlen > U8_MAX) break;
		
		for (foldbuf = tmpbuf;
		    foldlen;
		    foldlen -= numlen) 
		{
		    cp = utf8_to_uvchr(foldbuf, &numlen);
		    if (numlen > 0) {
			const STRLEN unilen = reguni(pRExC_state, cp, s);
			s       += unilen;
			len     += unilen;
			/* In EBCDIC the numlen and unilen can differ. */
			foldbuf += numlen;
			if (numlen >= foldlen)
			    break;
		    }
		    else
			break; /* "Can't happen." */
		}                          
	    }

	    /* Point to the beginning of the next character in the sequence. */
	    RExC_parse = endchar + 1;

	    /* Quit if no more characters */
	    if (RExC_parse >= endbrace) break;
	}


	if (SIZE_ONLY) {
	    if (RExC_parse < endbrace) {
		ckWARNreg(RExC_parse - 1,
			  "Using just the first characters returned by \\N{}");
	    }

	    RExC_size += STR_SZ(len);
	} else {
	    STR_LEN(ret) = len;
	    RExC_emit += STR_SZ(len);
	}

	RExC_parse = endbrace + 1;

	*flagp |= HASWIDTH; /* Not SIMPLE, as that causes the engine to fail
			       with malformed in t/re/pat_advanced.t */
	RExC_parse --;
	Set_Node_Cur_Length(ret); /* MJD */
	nextchar(pRExC_state);
d6830 1
a6831 1
    return ret;
d7161 1
a7161 1
            /* Handle \N and \N{NAME} here and not below because it can be
d7166 1
a7166 1
            ret= reg_namedseq(pRExC_state, NULL, flagp); 
a7431 12

			    /* An octal above 0xff is interpreted differently
			     * depending on if the re is in utf8 or not.  If it
			     * is in utf8, the value will be itself, otherwise
			     * it is interpreted as modulo 0x100.  It has been
			     * decided to discourage the use of octal above the
			     * single-byte range.  For now, warn only when
			     * it ends up modulo */
			    if (SIZE_ONLY && ender >= 0x100
				    && ! UTF && ! PL_encoding) {
				ckWARNregdep(p, "Use of octal value above 377 is deprecated");
			    }
d7445 2
a7446 2
			    if (!enc && SIZE_ONLY)
				ckWARNreg(p, "Invalid escape in the specified encoding");
d7455 2
a7456 2
			if (!SIZE_ONLY&& isALPHA(*p))
			    ckWARN2reg(p + 1, "Unrecognized escape \\%c passed through", UCHARAT(p));
d7748 4
a7751 3
	    ckWARN3reg(s+2,
		       "POSIX syntax [%c %c] belongs inside character classes",
		       c, c);
d7953 1
a7953 1
                    if (reg_namedseq(pRExC_state, &v, NULL)) {
d8047 3
a8049 3
		    if (!enc && SIZE_ONLY)
			ckWARNreg(RExC_parse,
				  "Invalid escape in the specified encoding");
d8053 4
a8056 4
		if (!SIZE_ONLY && isALPHA(value))
		    ckWARN2reg(RExC_parse,
			       "Unrecognized escape \\%c in character class passed through",
			       (int)value);
d8075 5
a8079 4
		    const int w =
			RExC_parse >= rangebegin ?
			RExC_parse - rangebegin : 0;
		    ckWARN4reg(RExC_parse,
d8082 1
a8082 1

d8387 3
a8389 1
	SvREFCNT_dec(listsv);
d8856 2
a8857 3
#ifndef PERL_IN_XSUB_RE
I32
Perl_regcurly(register const char *s)
d8875 1
a8875 1
#endif
d8881 1
a8881 1
static void 
d9292 1
a9292 1
Perl_re_intuit_string(pTHX_ REGEXP * const r)
a9294 1
    struct regexp *const prog = (struct regexp *)SvANY(r);
a9334 6
    SvREFCNT_dec(r);
}

void
Perl_pregfree2(pTHX_ REGEXP *rx)
{
a9335 1
    struct regexp *const r = (struct regexp *)SvANY(rx);
d9338 2
a9339 2
    PERL_ARGS_ASSERT_PREGFREE2;

d9343 4
a9346 2
        CALLREGFREE_PVT(rx); /* free the private data */
        SvREFCNT_dec(RXp_PAREN_NAMES(r));
d9349 8
a9356 4
        SvREFCNT_dec(r->anchored_substr);
        SvREFCNT_dec(r->anchored_utf8);
        SvREFCNT_dec(r->float_substr);
        SvREFCNT_dec(r->float_utf8);
d9359 1
a9359 1
    RX_MATCH_COPY_FREE(rx);
d9361 2
a9362 1
    SvREFCNT_dec(r->saved_copy);
d9364 1
d9366 1
d9387 2
a9388 4
Perl_reg_temp_copy (pTHX_ REGEXP *ret_x, REGEXP *rx)
{
    struct regexp *ret;
    struct regexp *const r = (struct regexp *)SvANY(rx);
d9393 3
a9395 16
    if (!ret_x)
	ret_x = (REGEXP*) newSV_type(SVt_REGEXP);
    ret = (struct regexp *)SvANY(ret_x);
    
    (void)ReREFCNT_inc(rx);
    /* We can take advantage of the existing "copied buffer" mechanism in SVs
       by pointing directly at the buffer, but flagging that the allocated
       space in the copy is zero. As we've just done a struct copy, it's now
       a case of zero-ing that, rather than copying the current length.  */
    SvPV_set(ret_x, RX_WRAPPED(rx));
    SvFLAGS(ret_x) |= SvFLAGS(rx) & (SVf_POK|SVp_POK|SVf_UTF8);
    memcpy(&(ret->xpv_cur), &(r->xpv_cur),
	   sizeof(regexp) - STRUCT_OFFSET(regexp, xpv_cur));
    SvLEN_set(ret_x, 0);
    SvSTASH_set(ret_x, NULL);
    SvMAGIC_set(ret_x, NULL);
d9398 1
d9411 1
a9411 1
    RX_MATCH_COPIED_off(ret_x);
d9415 2
a9416 1
    ret->mother_re = rx;
d9418 1
a9418 1
    return ret_x;
d9435 1
a9435 1
Perl_regfree_internal(pTHX_ REGEXP * const rx)
a9437 1
    struct regexp *const r = (struct regexp *)SvANY(rx);
d9448 2
a9449 2
            RE_PV_QUOTED_DECL(s, RX_UTF8(rx),
                dsv, RX_PRECOMP(rx), RX_PRELEN(rx), 60);
d9570 2
a9571 2
void
Perl_re_dup_guts(pTHX_ const REGEXP *sstr, REGEXP *dstr, CLONE_PARAMS *param)
d9574 1
d9576 1
a9576 2
    const struct regexp *r = (const struct regexp *)SvANY(sstr);
    struct regexp *ret = (struct regexp *)SvANY(dstr);
d9578 7
a9584 1
    PERL_ARGS_ASSERT_RE_DUP_GUTS;
d9587 2
d9634 4
d9641 1
a9641 1
	RXi_SET(ret,CALLREGDUPE_PVT(dstr,param));
d9643 1
a9643 1
    if (RX_MATCH_COPIED(dstr))
d9651 1
a9651 14
    if (ret->mother_re) {
	if (SvPVX_const(dstr) == SvPVX_const(ret->mother_re)) {
	    /* Our storage points directly to our mother regexp, but that's
	       1: a buffer in a different thread
	       2: something we no longer hold a reference on
	       so we need to copy it locally.  */
	    /* Note we need to sue SvCUR() on our mother_re, because it, in
	       turn, may well be pointing to its own mother_re.  */
	    SvPV_set(dstr, SAVEPVN(SvPVX_const(ret->mother_re),
				   SvCUR(ret->mother_re)+1));
	    SvLEN_set(dstr, SvCUR(ret->mother_re)+1);
	}
	ret->mother_re      = NULL;
    }
d9653 3
d9674 1
a9674 1
Perl_regdupe_internal(pTHX_ REGEXP * const rx, CLONE_PARAMS *param)
a9676 1
    struct regexp *const r = (struct regexp *)SvANY(rx);
d9768 27
d9796 13
@


1.1.1.13
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d30 1
a30 1
 * regexec to pregcomp and pregexec in order to avoid conflicts
a87 5
#include "dquote_static.c"
#ifndef PERL_IN_XSUB_RE
#  include "charclass_invlists.h"
#endif

a134 3
    I32		uni_semantics;	/* If a d charset modifier should use unicode
				   rules, even if the pattern is not in
				   utf8 */
a138 3
    I32		in_lookbehind;
    I32		contains_locale;
    I32		override_recoding;
a177 1
#define RExC_uni_semantics	(pRExC_state->uni_semantics)
a184 3
#define RExC_in_lookbehind	(pRExC_state->in_lookbehind)
#define RExC_contains_locale	(pRExC_state->contains_locale)
#define RExC_override_recoding	(pRExC_state->override_recoding)
d199 1
a199 4

/* Simple enough to be STAR/PLUS operand, in an EXACT node must be a single
 * character, and if utf8, must be invariant.  Note that this is not the same thing as REGNODE_SIMPLE */
#define	SIMPLE		0x02
a220 5
/* If not already in utf8, do a longjmp back to the beginning */
#define UTF8_LONGJMP 42 /* Choose a value not likely to ever conflict */
#define REQUIRE_UTF8	STMT_START {                                       \
                                     if (! UTF) JMPENV_JUMP(UTF8_LONGJMP); \
                        } STMT_END
d228 1
a228 1
  string that must appear at a fixed location, and we look for the
d249 2
a250 2
    characters must match before the string we are searching for.
    Likewise when combined with minlenp and the length of the string it
d256 1
a256 1
    the string can appear at. If set to I32 max it indicates that the
d273 1
a273 1
    pattern at the time it was committed with a scan_commit. Note that
d309 1
a309 1
    I32 *minlen_fixed;      /* pointer to the minlen relevant to the string */
d314 1
a314 1
    I32 *minlen_float;      /* pointer to the minlen relevant to the string */
d361 3
a363 12
#define UTF cBOOL(RExC_utf8)

/* The enums for all these are ordered so things work out correctly */
#define LOC (get_regex_charset(RExC_flags) == REGEX_LOCALE_CHARSET)
#define DEPENDS_SEMANTICS (get_regex_charset(RExC_flags) == REGEX_DEPENDS_CHARSET)
#define UNI_SEMANTICS (get_regex_charset(RExC_flags) == REGEX_UNICODE_CHARSET)
#define AT_LEAST_UNI_SEMANTICS (get_regex_charset(RExC_flags) >= REGEX_UNICODE_CHARSET)
#define ASCII_RESTRICTED (get_regex_charset(RExC_flags) == REGEX_ASCII_RESTRICTED_CHARSET)
#define MORE_ASCII_RESTRICTED (get_regex_charset(RExC_flags) == REGEX_ASCII_MORE_RESTRICTED_CHARSET)
#define AT_LEAST_ASCII_RESTRICTED (get_regex_charset(RExC_flags) >= REGEX_ASCII_RESTRICTED_CHARSET)

#define FOLD cBOOL(RExC_flags & RXf_PMf_FOLD)
a488 7
#define	ckWARN2regdep(loc,m, a1) STMT_START {				\
    const IV offset = loc - RExC_precomp;				\
    Perl_ck_warner_d(aTHX_ packWARN2(WARN_DEPRECATED, WARN_REGEXP),	\
	    m REPORT_LOCATION,						\
	    a1, (int)offset, RExC_precomp, RExC_precomp + offset);	\
} STMT_END

d598 1
a598 1
#endif /*PERL_ENABLE_EXPERIMENTAL_REGEX_OPTIMISATIONS*/
d658 1
a658 1
	    data->minlen_fixed=minlenp;
d697 1
d699 2
a700 12
    cl->flags = ANYOF_CLASS|ANYOF_EOS|ANYOF_UNICODE_ALL
		|ANYOF_LOC_NONBITMAP_FOLD|ANYOF_NON_UTF8_LATIN1_ALL;

    /* If any portion of the regex is to operate under locale rules,
     * initialization includes it.  The reason this isn't done for all regexes
     * is that the optimizer was written under the assumption that locale was
     * all-or-nothing.  Given the complexity and lack of documentation in the
     * optimizer, and that there are inadequate test cases for locale, so many
     * parts of it may not work properly, it is safest to avoid locale unless
     * necessary. */
    if (RExC_contains_locale) {
	ANYOF_CLASS_SETALL(cl);	    /* /l uses class */
a701 4
    }
    else {
	ANYOF_CLASS_ZERO(cl);	    /* Only /l uses class now */
    }
a730 1
    ARG_SET(cl, ANYOF_NONBITMAP_EMPTY);
d733 11
a743 2
/* These two functions currently do the exact same thing */
#define cl_init_zero		S_cl_init
d745 2
a746 3
/* 'AND' a given class with another one.  Can create false positives.  'cl'
 * should not be inverted.  'and_with->flags & ANYOF_CLASS' should be 0 if
 * 'and_with' is a regnode_charclass instead of a regnode_charclass_class. */
d754 2
a755 4

    /* I (khw) am not sure all these restrictions are necessary XXX */
    if (!(ANYOF_CLASS_TEST_ANY_SET(and_with))
	&& !(ANYOF_CLASS_TEST_ANY_SET(cl))
d757 2
a758 2
	&& !(and_with->flags & ANYOF_LOC_NONBITMAP_FOLD)
	&& !(cl->flags & ANYOF_LOC_NONBITMAP_FOLD)) {
d768 2
d771 12
a782 94
    if (and_with->flags & ANYOF_INVERT) {

        /* Here, the and'ed node is inverted.  Get the AND of the flags that
         * aren't affected by the inversion.  Those that are affected are
         * handled individually below */
	U8 affected_flags = cl->flags & ~INVERSION_UNAFFECTED_FLAGS;
	cl->flags &= (and_with->flags & INVERSION_UNAFFECTED_FLAGS);
	cl->flags |= affected_flags;

        /* We currently don't know how to deal with things that aren't in the
         * bitmap, but we know that the intersection is no greater than what
         * is already in cl, so let there be false positives that get sorted
         * out after the synthetic start class succeeds, and the node is
         * matched for real. */

        /* The inversion of these two flags indicate that the resulting
         * intersection doesn't have them */
	if (and_with->flags & ANYOF_UNICODE_ALL) {
	    cl->flags &= ~ANYOF_UNICODE_ALL;
	}
	if (and_with->flags & ANYOF_NON_UTF8_LATIN1_ALL) {
	    cl->flags &= ~ANYOF_NON_UTF8_LATIN1_ALL;
	}
    }
    else {   /* and'd node is not inverted */
	U8 outside_bitmap_but_not_utf8; /* Temp variable */

	if (! ANYOF_NONBITMAP(and_with)) {

            /* Here 'and_with' doesn't match anything outside the bitmap
             * (except possibly ANYOF_UNICODE_ALL), which means the
             * intersection can't either, except for ANYOF_UNICODE_ALL, in
             * which case we don't know what the intersection is, but it's no
             * greater than what cl already has, so can just leave it alone,
             * with possible false positives */
            if (! (and_with->flags & ANYOF_UNICODE_ALL)) {
                ARG_SET(cl, ANYOF_NONBITMAP_EMPTY);
		cl->flags &= ~ANYOF_NONBITMAP_NON_UTF8;
            }
	}
	else if (! ANYOF_NONBITMAP(cl)) {

	    /* Here, 'and_with' does match something outside the bitmap, and cl
	     * doesn't have a list of things to match outside the bitmap.  If
             * cl can match all code points above 255, the intersection will
             * be those above-255 code points that 'and_with' matches.  If cl
             * can't match all Unicode code points, it means that it can't
             * match anything outside the bitmap (since the 'if' that got us
             * into this block tested for that), so we leave the bitmap empty.
             */
	    if (cl->flags & ANYOF_UNICODE_ALL) {
		ARG_SET(cl, ARG(and_with));

                /* and_with's ARG may match things that don't require UTF8.
                 * And now cl's will too, in spite of this being an 'and'.  See
                 * the comments below about the kludge */
		cl->flags |= and_with->flags & ANYOF_NONBITMAP_NON_UTF8;
	    }
	}
	else {
            /* Here, both 'and_with' and cl match something outside the
             * bitmap.  Currently we do not do the intersection, so just match
             * whatever cl had at the beginning.  */
	}


        /* Take the intersection of the two sets of flags.  However, the
         * ANYOF_NONBITMAP_NON_UTF8 flag is treated as an 'or'.  This is a
         * kludge around the fact that this flag is not treated like the others
         * which are initialized in cl_anything().  The way the optimizer works
         * is that the synthetic start class (SSC) is initialized to match
         * anything, and then the first time a real node is encountered, its
         * values are AND'd with the SSC's with the result being the values of
         * the real node.  However, there are paths through the optimizer where
         * the AND never gets called, so those initialized bits are set
         * inappropriately, which is not usually a big deal, as they just cause
         * false positives in the SSC, which will just mean a probably
         * imperceptible slow down in execution.  However this bit has a
         * higher false positive consequence in that it can cause utf8.pm,
         * utf8_heavy.pl ... to be loaded when not necessary, which is a much
         * bigger slowdown and also causes significant extra memory to be used.
         * In order to prevent this, the code now takes a different tack.  The
         * bit isn't set unless some part of the regular expression needs it,
         * but once set it won't get cleared.  This means that these extra
         * modules won't get loaded unless there was some path through the
         * pattern that would have required them anyway, and  so any false
         * positives that occur by not ANDing them out when they could be
         * aren't as severe as they would be if we treated this bit like all
         * the others */
        outside_bitmap_but_not_utf8 = (cl->flags | and_with->flags)
                                      & ANYOF_NONBITMAP_NON_UTF8;
	cl->flags &= and_with->flags;
	cl->flags |= outside_bitmap_but_not_utf8;
    }
d785 2
a786 3
/* 'OR' a given class with another one.  Can create false positives.  'cl'
 * should not be inverted.  'or_with->flags & ANYOF_CLASS' should be 0 if
 * 'or_with' is a regnode_charclass instead of a regnode_charclass_class. */
a792 7

        /* Here, the or'd node is to be inverted.  This means we take the
         * complement of everything not in the bitmap, but currently we don't
         * know what that is, so give up and match anything */
	if (ANYOF_NONBITMAP(or_with)) {
	    cl_anything(pRExC_state, cl);
	}
d802 3
a804 3
	else if ( (or_with->flags & ANYOF_LOCALE) == (cl->flags & ANYOF_LOCALE)
	     && !(or_with->flags & ANYOF_LOC_NONBITMAP_FOLD)
	     && !(cl->flags & ANYOF_LOC_NONBITMAP_FOLD) ) {
d813 1
a813 15

        /* And, we can just take the union of the flags that aren't affected
         * by the inversion */
	cl->flags |= or_with->flags & INVERSION_UNAFFECTED_FLAGS;

        /* For the remaining flags:
            ANYOF_UNICODE_ALL and inverted means to not match anything above
                    255, which means that the union with cl should just be
                    what cl has in it, so can ignore this flag
            ANYOF_NON_UTF8_LATIN1_ALL and inverted means if not utf8 and ord
                    is 127-255 to match them, but then invert that, so the
                    union with cl should just be what cl has in it, so can
                    ignore this flag
         */
    } else {    /* 'or_with' is not inverted */
d816 2
a817 2
	     && (!(or_with->flags & ANYOF_LOC_NONBITMAP_FOLD)
		 || (cl->flags & ANYOF_LOC_NONBITMAP_FOLD)) ) {
d823 1
a823 1
	    if (ANYOF_CLASS_TEST_ANY_SET(or_with)) {
d832 3
d836 8
a843 25
	if (ANYOF_NONBITMAP(or_with)) {

	    /* Use the added node's outside-the-bit-map match if there isn't a
	     * conflict.  If there is a conflict (both nodes match something
	     * outside the bitmap, but what they match outside is not the same
	     * pointer, and hence not easily compared until XXX we extend
	     * inversion lists this far), give up and allow the start class to
	     * match everything outside the bitmap.  If that stuff is all above
	     * 255, can just set UNICODE_ALL, otherwise caould be anything. */
	    if (! ANYOF_NONBITMAP(cl)) {
		ARG_SET(cl, ARG(or_with));
	    }
	    else if (ARG(cl) != ARG(or_with)) {

		if ((or_with->flags & ANYOF_NONBITMAP_NON_UTF8)) {
		    cl_anything(pRExC_state, cl);
		}
		else {
		    cl->flags |= ANYOF_UNICODE_ALL;
		}
	    }
	}

        /* Take the union */
	cl->flags |= or_with->flags;
d864 1
a864 1
   Part of the reason for their existence is to provide a form
d873 1
a873 1

a880 1
    U16 word;
a949 7
    PerlIO_printf(Perl_debug_log, "%*sword_info N:(prev,len)=", (int)depth*2, "");
    for (word=1; word <= trie->wordcount; word++) {
	PerlIO_printf(Perl_debug_log, " %d:(%d,%d)",
	    (int)word, (int)(trie->wordinfo[word].prev),
	    (int)(trie->wordinfo[word].len));
    }
    PerlIO_printf(Perl_debug_log, "\n" );
a1079 1

d1128 1
a1128 1
Thus EVAL blocks following a trie may be called a different number of times with
d1130 1
a1130 1
ignored. This inconsistent behaviour of EVAL type nodes is well established as
d1143 1
a1143 1
The regexp /(ac|ad|ab)+/ will produce the following debug output:
d1197 1
a1197 1
#define TRIE_STORE_REVCHAR(val)                                            \
d1200 1
a1200 1
            SV *zlopp = newSV(7); /* XXX: optimize me */                   \
d1202 1
a1202 1
            unsigned const char *const kapow = uvuni_to_utf8(flrbbbbb, val); \
d1208 1
a1208 1
            char ooooff = (char)val;                                           \
d1213 22
a1234 25
#define TRIE_READ_CHAR STMT_START {                                                     \
    wordlen++;                                                                          \
    if ( UTF ) {                                                                        \
        /* if it is UTF then it is either already folded, or does not need folding */   \
        uvc = utf8n_to_uvuni( (const U8*) uc, UTF8_MAXLEN, &len, uniflags);             \
    }                                                                                   \
    else if (folder == PL_fold_latin1) {                                                \
        /* if we use this folder we have to obey unicode rules on latin-1 data */       \
        if ( foldlen > 0 ) {                                                            \
           uvc = utf8n_to_uvuni( (const U8*) scan, UTF8_MAXLEN, &len, uniflags );       \
           foldlen -= len;                                                              \
           scan += len;                                                                 \
           len = 0;                                                                     \
        } else {                                                                        \
            len = 1;                                                                    \
            uvc = _to_fold_latin1( (U8) *uc, foldbuf, &foldlen, 1);                     \
            skiplen = UNISKIP(uvc);                                                     \
            foldlen -= skiplen;                                                         \
            scan = foldbuf + skiplen;                                                   \
        }                                                                               \
    } else {                                                                            \
        /* raw data, will be folded later if needed */                                  \
        uvc = (U32)*uc;                                                                 \
        len = 1;                                                                        \
    }                                                                                   \
d1260 2
a1272 3
    trie->wordinfo[curword].prev   = 0;                         \
    trie->wordinfo[curword].len    = wordlen;                   \
    trie->wordinfo[curword].accept = state;                     \
d1285 10
a1294 5
        /* It's a dupe. Pre-insert into the wordinfo[].prev   */\
        /* chain, so that when the bits of chain are later    */\
        /* linked together, the dups appear in the chain      */\
	trie->wordinfo[curword].prev = trie->wordinfo[dupe].prev; \
	trie->wordinfo[dupe].prev = curword;                    \
a1331 1
    U32 *prev_states; /* temp array mapping each state to previous one */
d1333 7
a1339 1
    const U8 * folder = NULL;
a1358 11
    switch (flags) {
	case EXACT: break;
	case EXACTFA:
        case EXACTFU_SS:
        case EXACTFU_TRICKYFOLD:
	case EXACTFU: folder = PL_fold_latin1; break;
	case EXACTF:  folder = PL_fold; break;
	case EXACTFL: folder = PL_fold_locale; break;
        default: Perl_croak( aTHX_ "panic! In trie construction, unknown node type %u %s", (unsigned) flags, PL_reg_name[flags] );
    }

d1365 1
a1365 1
    if (flags == EXACT)
a1366 3
    trie->wordinfo = (reg_trie_wordinfo *) PerlMemShared_calloc(
                       trie->wordcount+1, sizeof(reg_trie_wordinfo));

d1407 1
a1407 1
       efficient in terms of memory by ensuring the most common value is in the
d1411 1
a1411 1
       will not be compressible. With a middle is most common approach the worst
a1421 1
        STRLEN skiplen = 0;
d1431 1
a1431 1
        if ( set_bit ) { /* bitmap only alloced when !(UTF&&Folding) */
d1434 1
a1434 5
            if (OP( noper ) == EXACTFU_SS) {
                /* false positives are ok, so just set this */
                TRIE_BITMAP_SET(trie,0xDF);
            }
        }
a1439 7
                if ( folder ) {
                    U8 folded= folder[ (U8) uvc ];
                    if ( !trie->charmap[ folded ] ) {
                        trie->charmap[ folded ]=( ++trie->uniquecharcount );
                        TRIE_STORE_REVCHAR( folded );
                    }
                }
d1442 3
a1444 1
                    TRIE_STORE_REVCHAR( uvc );
d1447 3
a1449 3
		    /* store the codepoint in the bitmap, and its folded
		     * equivalent. */
                    TRIE_BITMAP_SET(trie, uvc);
d1452 1
a1452 1
                    if ( folder ) TRIE_BITMAP_SET(trie, folder[(U8) uvc ]);
d1456 6
a1461 3
			   variant codepoints */
			if (! UNI_IS_INVARIANT(uvc)) {
			    TRIE_BITMAP_SET(trie, UTF8_TWO_BYTE_HI(uvc));
d1478 1
a1478 1
                    TRIE_STORE_REVCHAR(uvc);
d1483 2
a1484 2
            trie->minlen = chars;
            trie->maxlen = chars;
d1486 1
a1486 1
            trie->minlen = chars;
d1488 1
a1488 12
            trie->maxlen = chars;
        }
        if (OP( noper ) == EXACTFU_SS) {
            /* XXX: workaround - 'ss' could match "\x{DF}" so minlen could be 1 and not 2*/
	    if (trie->minlen > 1)
                trie->minlen= 1;
        }
	if (OP( noper ) == EXACTFU_TRICKYFOLD) {
	    /* XXX: workround - things like "\x{1FBE}\x{0308}\x{0301}" can match "\x{0390}" 
	     *		      - We assume that any such sequence might match a 2 byte string */
            if (trie->minlen > 2 )
                trie->minlen= 2;
d1499 1
a1522 3
    Newx(prev_states, TRIE_CHARCOUNT(trie) + 2, U32);
    prev_states[1] = 0;

d1541 1
a1541 1

a1558 1
            STRLEN skiplen   = 0;
a1592 1
			    prev_states[newstate] = state;
d1706 1
a1706 1
           We use the .check field of the first entry of the node temporarily to
a1757 1
            STRLEN skiplen   = 0;
a1759 1

a1775 2
			    prev_states[TRIE_NODENUM(next_alloc)]
				    = TRIE_NODENUM(state);
d1809 1
a1809 1
           - If .base is 0 there are no valid transitions from that node.
d1823 1
a1823 1
           table: We first do not compress the root node 1,and mark all its
d1825 3
a1827 3
           allows us to do a DFA construction from the compressed table later,
           and ensures that any .base pointers we calculate later are greater
           than 0.
d1923 4
a1926 1
    {   /* Modify the program and insert the new TRIE node */ 
d1943 1
a1943 1
           Assuming its a sub part we convert the EXACT otherwise we convert
a2054 1
	    trie->prefixlen = (state-1);
d2109 3
a2111 9
            /* If the start state is not accepting (meaning there is no empty string/NOTHING)
	     *   and there is a bitmap
	     *   and the first "jump target" node we found leaves enough room
	     * then convert the TRIE node into a TRIEC node, with the bitmap
	     * embedded inline in the opcode - this is hypothetically faster.
	     */
            if ( !trie->states[trie->startstate].wordnum
		 && trie->bitmap
		 && ( (char *)jumper - (char *)convert) >= (int)sizeof(struct regnode_charclass) )
a2149 36

    /*  Finish populating the prev field of the wordinfo array.  Walk back
     *  from each accept state until we find another accept state, and if
     *  so, point the first word's .prev field at the second word. If the
     *  second already has a .prev field set, stop now. This will be the
     *  case either if we've already processed that word's accept state,
     *  or that state had multiple words, and the overspill words were
     *  already linked up earlier.
     */
    {
	U16 word;
	U32 state;
	U16 prev;

	for (word=1; word <= trie->wordcount; word++) {
	    prev = 0;
	    if (trie->wordinfo[word].prev)
		continue;
	    state = trie->wordinfo[word].accept;
	    while (state) {
		state = prev_states[state];
		if (!state)
		    break;
		prev = trie->states[state].wordnum;
		if (prev)
		    break;
	    }
	    trie->wordinfo[word].prev = prev;
	}
	Safefree(prev_states);
    }


    /* and now dump out the compressed format */
    DEBUG_TRIE_COMPILE_r(dump_trie(trie, widecharmap, revcharmap, depth+1));

d2167 1
a2167 1
/* The Trie is constructed and compressed now so we can build a fail array if it's needed
d2174 2
a2175 2
   suffix of the current state's 'word' that is also a proper prefix of another word in our
   trie. State 1 represents the word '' and is thus the default fail state. This allows
d2181 2
a2182 2
   fail, which would bring us to the state representing 'd' in the second word where we would
   try 'g' and succeed, proceeding to match 'cdgu'.
a2295 103
/* The below joins as many adjacent EXACTish nodes as possible into a single
 * one, and looks for problematic sequences of characters whose folds vs.
 * non-folds have sufficiently different lengths, that the optimizer would be
 * fooled into rejecting legitimate matches of them, and the trie construction
 * code can't cope with them.  The joining is only done if:
 * 1) there is room in the current conglomerated node to entirely contain the
 *    next one.
 * 2) they are the exact same node type
 *
 * The adjacent nodes actually may be separated by NOTHING kind nodes, and
 * these get optimized out
 *
 * If there are problematic code sequences, *min_subtract is set to the delta
 * that the minimum size of the node can be less than its actual size.  And,
 * the node type of the result is changed to reflect that it contains these
 * sequences.
 *
 * And *has_exactf_sharp_s is set to indicate whether or not the node is EXACTF
 * and contains LATIN SMALL LETTER SHARP S
 *
 * This is as good a place as any to discuss the design of handling these
 * problematic sequences.  It's been wrong in Perl for a very long time.  There
 * are three code points in Unicode whose folded lengths differ so much from
 * the un-folded lengths that it causes problems for the optimizer and trie
 * construction.  Why only these are problematic, and not others where lengths
 * also differ is something I (khw) do not understand.  New versions of Unicode
 * might add more such code points.  Hopefully the logic in fold_grind.t that
 * figures out what to test (in part by verifying that each size-combination
 * gets tested) will catch any that do come along, so they can be added to the
 * special handling below.  The chances of new ones are actually rather small,
 * as most, if not all, of the world's scripts that have casefolding have
 * already been encoded by Unicode.  Also, a number of Unicode's decisions were
 * made to allow compatibility with pre-existing standards, and almost all of
 * those have already been dealt with.  These would otherwise be the most
 * likely candidates for generating further tricky sequences.  In other words,
 * Unicode by itself is unlikely to add new ones unless it is for compatibility
 * with pre-existing standards, and there aren't many of those left.
 *
 * The previous designs for dealing with these involved assigning a special
 * node for them.  This approach doesn't work, as evidenced by this example:
 *      "\xDFs" =~ /s\xDF/ui    # Used to fail before these patches
 * Both these fold to "sss", but if the pattern is parsed to create a node of
 * that would match just the \xDF, it won't be able to handle the case where a
 * successful match would have to cross the node's boundary.  The new approach
 * that hopefully generally solves the problem generates an EXACTFU_SS node
 * that is "sss".
 *
 * There are a number of components to the approach (a lot of work for just
 * three code points!):
 * 1)   This routine examines each EXACTFish node that could contain the
 *      problematic sequences.  It returns in *min_subtract how much to
 *      subtract from the the actual length of the string to get a real minimum
 *      for one that could match it.  This number is usually 0 except for the
 *      problematic sequences.  This delta is used by the caller to adjust the
 *      min length of the match, and the delta between min and max, so that the
 *      optimizer doesn't reject these possibilities based on size constraints.
 * 2)   These sequences are not currently correctly handled by the trie code
 *      either, so it changes the joined node type to ops that are not handled
 *      by trie's, those new ops being EXACTFU_SS and EXACTFU_TRICKYFOLD.
 * 3)   This is sufficient for the two Greek sequences (described below), but
 *      the one involving the Sharp s (\xDF) needs more.  The node type
 *      EXACTFU_SS is used for an EXACTFU node that contains at least one "ss"
 *      sequence in it.  For non-UTF-8 patterns and strings, this is the only
 *      case where there is a possible fold length change.  That means that a
 *      regular EXACTFU node without UTF-8 involvement doesn't have to concern
 *      itself with length changes, and so can be processed faster.  regexec.c
 *      takes advantage of this.  Generally, an EXACTFish node that is in UTF-8
 *      is pre-folded by regcomp.c.  This saves effort in regex matching.
 *      However, probably mostly for historical reasons, the pre-folding isn't
 *      done for non-UTF8 patterns (and it can't be for EXACTF and EXACTFL
 *      nodes, as what they fold to isn't known until runtime.)  The fold
 *      possibilities for the non-UTF8 patterns are quite simple, except for
 *      the sharp s.  All the ones that don't involve a UTF-8 target string
 *      are members of a fold-pair, and arrays are set up for all of them
 *      that quickly find the other member of the pair.  It might actually
 *      be faster to pre-fold these, but it isn't currently done, except for
 *      the sharp s.  Code elsewhere in this file makes sure that it gets
 *      folded to 'ss', even if the pattern isn't UTF-8.  This avoids the
 *      issues described in the next item.
 * 4)   A problem remains for the sharp s in EXACTF nodes.  Whether it matches
 *      'ss' or not is not knowable at compile time.  It will match iff the
 *      target string is in UTF-8, unlike the EXACTFU nodes, where it always
 *      matches; and the EXACTFL and EXACTFA nodes where it never does.  Thus
 *      it can't be folded to "ss" at compile time, unlike EXACTFU does as
 *      described in item 3).  An assumption that the optimizer part of
 *      regexec.c (probably unwittingly) makes is that a character in the
 *      pattern corresponds to at most a single character in the target string.
 *      (And I do mean character, and not byte here, unlike other parts of the
 *      documentation that have never been updated to account for multibyte
 *      Unicode.)  This assumption is wrong only in this case, as all other
 *      cases are either 1-1 folds when no UTF-8 is involved; or is true by
 *      virtue of having this file pre-fold UTF-8 patterns.   I'm
 *      reluctant to try to change this assumption, so instead the code punts.
 *      This routine examines EXACTF nodes for the sharp s, and returns a
 *      boolean indicating whether or not the node is an EXACTF node that
 *      contains a sharp s.  When it is true, the caller sets a flag that later
 *      causes the optimizer in this file to not set values for the floating
 *      and fixed string lengths, and thus avoids the optimizer code in
 *      regexec.c that makes the invalid assumption.  Thus, there is no
 *      optimization based on string lengths for EXACTF nodes that contain the
 *      sharp s.  This only happens for /id rules (which means the pattern
 *      isn't in UTF-8).
 */
d2297 3
a2299 1
#define JOIN_EXACT(scan,min_subtract,has_exactf_sharp_s, flags) \
d2301 1
a2301 1
        join_exact(pRExC_state,(scan),(min_subtract),has_exactf_sharp_s, (flags),NULL,depth+1)
d2304 1
a2304 1
S_join_exact(pTHX_ RExC_state_t *pRExC_state, regnode *scan, UV *min_subtract, bool *has_exactf_sharp_s, U32 flags,regnode *val, U32 depth) {
d2324 5
a2328 6

    /* Look through the subsequent nodes in the chain.  Skip NOTHING, merge
     * EXACT ones that are mergeable to the current one. */
    while (n
           && (PL_regkind[OP(n)] == NOTHING
               || (stringok && OP(n) == OP(scan)))
d2330 1
a2330 2
           && NEXT_OFF(scan) + NEXT_OFF(n) < I16_MAX)
    {
a2346 3

            if (oldl + STR_LEN(n) > U8_MAX)
                break;
d2349 1
d2351 2
a2352 1

d2378 33
a2410 58

    *min_subtract = 0;
    *has_exactf_sharp_s = FALSE;

    /* Here, all the adjacent mergeable EXACTish nodes have been merged.  We
     * can now analyze for sequences of problematic code points.  (Prior to
     * this final joining, sequences could have been split over boundaries, and
     * hence missed).  The sequences only happen in folding, hence for any
     * non-EXACT EXACTish node */
    if (OP(scan) != EXACT) {
        U8 *s;
        U8 * s0 = (U8*) STRING(scan);
        U8 * const s_end = s0 + STR_LEN(scan);

	/* The below is perhaps overboard, but this allows us to save a test
	 * each time through the loop at the expense of a mask.  This is
	 * because on both EBCDIC and ASCII machines, 'S' and 's' differ by a
	 * single bit.  On ASCII they are 32 apart; on EBCDIC, they are 64.
	 * This uses an exclusive 'or' to find that bit and then inverts it to
	 * form a mask, with just a single 0, in the bit position where 'S' and
	 * 's' differ. */
	const U8 S_or_s_mask = (U8) ~ ('S' ^ 's');
	const U8 s_masked = 's' & S_or_s_mask;

	/* One pass is made over the node's string looking for all the
	 * possibilities.  to avoid some tests in the loop, there are two main
	 * cases, for UTF-8 patterns (which can't have EXACTF nodes) and
	 * non-UTF-8 */
	if (UTF) {

	    /* There are two problematic Greek code points in Unicode
	     * casefolding
	     *
	     * U+0390 - GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS
	     * U+03B0 - GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS
	     *
	     * which casefold to
	     *
	     * Unicode                      UTF-8
	     *
	     * U+03B9 U+0308 U+0301         0xCE 0xB9 0xCC 0x88 0xCC 0x81
	     * U+03C5 U+0308 U+0301         0xCF 0x85 0xCC 0x88 0xCC 0x81
             *
	     * This means that in case-insensitive matching (or "loose
	     * matching", as Unicode calls it), an EXACTF of length six (the
	     * UTF-8 encoded byte length of the above casefolded versions) can
	     * match a target string of length two (the byte length of UTF-8
	     * encoded U+0390 or U+03B0).  This would rather mess up the
	     * minimum length computation.  (there are other code points that
	     * also fold to these two sequences, but the delta is smaller)
	     *
	     * If these sequences are found, the minimum length is decreased by
	     * four (six minus two).
	     *
	     * Similarly, 'ss' may match the single char and byte LATIN SMALL
	     * LETTER SHARP S.  We decrease the min length by 1 for each
	     * occurrence of 'ss' found */

d2412 12
a2423 4
#	    define U390_first_byte 0xb4
	    const U8 U390_tail[] = "\x68\xaf\x49\xaf\x42";
#	    define U3B0_first_byte 0xb5
	    const U8 U3B0_tail[] = "\x46\xaf\x49\xaf\x42";
d2425 5
a2429 108
#	    define U390_first_byte 0xce
	    const U8 U390_tail[] = "\xb9\xcc\x88\xcc\x81";
#	    define U3B0_first_byte 0xcf
	    const U8 U3B0_tail[] = "\x85\xcc\x88\xcc\x81";
#endif
	    const U8 len = sizeof(U390_tail); /* (-1 for NUL; +1 for 1st byte;
						 yields a net of 0 */
	    /* Examine the string for one of the problematic sequences */
	    for (s = s0;
		 s < s_end - 1; /* Can stop 1 before the end, as minimum length
				 * sequence we are looking for is 2 */
		 s += UTF8SKIP(s))
	    {

		/* Look for the first byte in each problematic sequence */
		switch (*s) {
		    /* We don't have to worry about other things that fold to
		     * 's' (such as the long s, U+017F), as all above-latin1
		     * code points have been pre-folded */
		    case 's':
		    case 'S':

                        /* Current character is an 's' or 'S'.  If next one is
                         * as well, we have the dreaded sequence */
			if (((*(s+1) & S_or_s_mask) == s_masked)
			    /* These two node types don't have special handling
			     * for 'ss' */
			    && OP(scan) != EXACTFL && OP(scan) != EXACTFA)
			{
			    *min_subtract += 1;
			    OP(scan) = EXACTFU_SS;
			    s++;    /* No need to look at this character again */
			}
			break;

		    case U390_first_byte:
			if (s_end - s >= len

			    /* The 1's are because are skipping comparing the
			     * first byte */
			    && memEQ(s + 1, U390_tail, len - 1))
			{
			    goto greek_sequence;
			}
			break;

		    case U3B0_first_byte:
			if (! (s_end - s >= len
			       && memEQ(s + 1, U3B0_tail, len - 1)))
			{
			    break;
			}
		      greek_sequence:
			*min_subtract += 4;

			/* This can't currently be handled by trie's, so change
			 * the node type to indicate this.  If EXACTFA and
			 * EXACTFL were ever to be handled by trie's, this
			 * would have to be changed.  If this node has already
			 * been changed to EXACTFU_SS in this loop, leave it as
			 * is.  (I (khw) think it doesn't matter in regexec.c
			 * for UTF patterns, but no need to change it */
			if (OP(scan) == EXACTFU) {
			    OP(scan) = EXACTFU_TRICKYFOLD;
			}
			s += 6;	/* We already know what this sequence is.  Skip
				   the rest of it */
			break;
		}
	    }
	}
	else if (OP(scan) != EXACTFL && OP(scan) != EXACTFA) {

	    /* Here, the pattern is not UTF-8.  We need to look only for the
	     * 'ss' sequence, and in the EXACTF case, the sharp s, which can be
	     * in the final position.  Otherwise we can stop looking 1 byte
	     * earlier because have to find both the first and second 's' */
	    const U8* upper = (OP(scan) == EXACTF) ? s_end : s_end -1;

	    for (s = s0; s < upper; s++) {
		switch (*s) {
		    case 'S':
		    case 's':
			if (s_end - s > 1
			    && ((*(s+1) & S_or_s_mask) == s_masked))
			{
			    *min_subtract += 1;

			    /* EXACTF nodes need to know that the minimum
			     * length changed so that a sharp s in the string
			     * can match this ss in the pattern, but they
			     * remain EXACTF nodes, as they are not trie'able,
			     * so don't have to invent a new node type to
			     * exclude them from the trie code */
			    if (OP(scan) != EXACTF) {
				OP(scan) = EXACTFU_SS;
			    }
			    s++;
			}
			break;
		    case LATIN_SMALL_LETTER_SHARP_S:
			if (OP(scan) == EXACTF) {
			    *has_exactf_sharp_s = TRUE;
			}
			break;
		}
	    }
	}
d2431 1
a2431 1

d2433 1
a2433 2
    /* Allow dumping but overwriting the collection of skipped
     * ops and/or strings with fake optimized ops */
d2436 4
a2439 3
	OP(n) = OPTIMIZED;
	FLAGS(n) = 0;
	NEXT_OFF(n) = 0;
d2447 1
a2447 1
/* REx optimizer.  Converts nodes into quicker variants "in place".
d2459 1
a2459 1
   need to be handled separately/specially in study_chunk. Its so
a2544 4
        UV min_subtract = 0;    /* How much to subtract from the minimum node
                                   length to get a real minimum (because the
                                   folded version may be shorter) */
	bool has_exactf_sharp_s = FALSE;
d2548 1
a2548 5

        /* Its not clear to khw or hv why this is done here, and not in the
         * clauses that deal with EXACT nodes.  khw's guess is that it's
         * because of a previous design */
        JOIN_EXACT(scan,&min_subtract, &has_exactf_sharp_s, 0);
d2560 1
a2560 1

d2582 1
a2582 1

d2590 1
a2590 1

d2700 1
a2700 1
		   If we can find such a subsequence we need to turn the first
d2706 1
a2706 1
		     1. patterns where the whole set of branches can be converted. 
d2712 1
a2712 1
		   branches so
d2723 1
a2723 1
		  we "jump" to the appropriate tail node. Essentially we turn
d2727 1
a2727 1

d2739 1
a2739 1
                        U8 trietype = 0;
d2770 20
a2789 41
                            Step through the branches
                                cur represents each branch,
                                noper is the first thing to be matched as part of that branch
                                noper_next is the regnext() of that node.

                            We normally handle a case like this /FOO[xyz]|BAR[pqr]/
                            via a "jump trie" but we also support building with NOJUMPTRIE,
                            which restricts the trie logic to structures like /FOO|BAR/.

                            If noper is a trieable nodetype then the branch is a possible optimization
                            target. If we are building under NOJUMPTRIE then we require that noper_next
                            is the same as scan (our current position in the regex program).

                            Once we have two or more consecutive such branches we can create a
                            trie of the EXACT's contents and stitch it in place into the program.

                            If the sequence represents all of the branches in the alternation we
                            replace the entire thing with a single TRIE node.

                            Otherwise when it is a subsequence we need to stitch it in place and
                            replace only the relevant branches. This means the first branch has
                            to remain as it is used by the alternation logic, and its next pointer,
                            and needs to be repointed at the item on the branch chain following
                            the last branch we have optimized away.

                            This could be either a BRANCH, in which case the subsequence is internal,
                            or it could be the item following the branch sequence in which case the
                            subsequence is at the end (which does not necessarily mean the first node
                            is the start of the alternation).

                            TRIE_TYPE(X) is a define which maps the optype to a trietype.

                                optype          |  trietype
                                ----------------+-----------
                                NOTHING         | NOTHING
                                EXACT           | EXACT
                                EXACTFU         | EXACTFU
                                EXACTFU_SS      | EXACTFU
                                EXACTFU_TRICKYFOLD | EXACTFU
                                EXACTFA         | 0

a2791 4
#define TRIE_TYPE(X) ( ( NOTHING == (X) ) ? NOTHING :   \
                       ( EXACT == (X) )   ? EXACT :        \
                       ( EXACTFU == (X) || EXACTFU_SS == (X) || EXACTFU_TRICKYFOLD == (X) ) ? EXACTFU :        \
                       0 )
a2795 2
                            U8 noper_type = OP( noper );
                            U8 noper_trietype = TRIE_TYPE( noper_type );
d2817 3
a2819 24

                            /* Is noper a trieable nodetype that can be merged with the
                             * current trie (if there is one)? */
                            if ( noper_trietype
                                  &&
                                  (
                                        /* XXX: Currently we cannot allow a NOTHING node to be the first element
                                         * of a TRIEABLE sequence, Otherwise we will overwrite the regop following
                                         * the NOTHING with the TRIE regop later on. This is because a NOTHING node
                                         * is only one regnode wide, and a TRIE is two regnodes. An example of a
                                         * problematic pattern is: "x" =~ /\A(?>(?:(?:)A|B|C?x))\z/
                                         * At a later point of time we can somewhat workaround this by handling
                                         * NOTHING -> EXACT sequences as generated by /(?:)A|(?:)B/ type patterns,
                                         * as we can effectively ignore the NOTHING regop in that case.
                                         * This clause, which allows NOTHING to start a sequence is left commented
                                         * out as a reference.
                                         * - Yves

                                           ( noper_trietype == NOTHING)
                                           || ( trietype == NOTHING )
                                        */
                                        ( noper_trietype == NOTHING && trietype )
                                        || ( trietype == noper_trietype )
                                  )
a2824 4
                                /* Handle mergable triable node
                                 * Either we are the first node in a new trieable sequence,
                                 * in which case we do some bookkeeping, otherwise we update
                                 * the end pointer. */
d2826 3
a2828 3
                                if ( !first ) {
                                    first = cur;
                                    trietype = noper_trietype;
a2829 2
                                    if ( trietype == NOTHING )
                                        trietype = noper_trietype;
d2832 18
a2849 16
                            } /* end handle mergable triable node */
                            else {
                                /* handle unmergable node -
                                 * noper may either be a triable node which can not be tried
                                 * together with the current trie, or a non triable node */
                                if ( last ) {
                                    /* If last is set and trietype is not NOTHING then we have found
                                     * at least two triable branch sequences in a row of a similar
                                     * trietype so we can turn them into a trie. If/when we
                                     * allow NOTHING to start a trie sequence this condition will be
                                     * required, and it isn't expensive so we leave it in for now. */
                                    if ( trietype != NOTHING )
                                        make_trie( pRExC_state,
                                                startbranch, first, cur, tail, count,
                                                trietype, depth+1 );
                                    last = NULL; /* note: we clear/update first, trietype etc below, so we dont do it here */
d2851 1
a2851 1
                                if ( noper_trietype
a2855 1
                                    /* noper is triable, so we can start a new trie sequence */
d2858 2
a2859 4
                                    trietype = noper_trietype;
                                } else if (first) {
                                    /* if we already saw a first but the current node is not triable then we have
                                     * to reset the first information. */
d2862 1
a2862 1
                                    trietype = 0;
d2864 3
a2866 2
                            } /* end handle unmergable node */
                        } /* loop over branches */
d2874 4
a2877 6
                        if ( last && trietype != NOTHING ) {
                            /* the last branch of the sequence was part of a trie,
                             * so we have to construct it here outside of the loop
                             */
                            made= make_trie( pRExC_state, startbranch, first, scan, tail, count, trietype, depth+1 );
#ifdef TRIE_STUDY_OPT
d2890 2
a2891 2
                        } /* end if ( last) */
                    } /* TRIE_MAXBUF is non zero */
a2963 1
		uc = utf8_to_uvchr_buf(s, s + l, NULL);
d2965 1
a2996 7

		/* If compatible, we or it in below.  It is compatible if is
		 * in the bitmp and either 1) its bit or its fold is set, or 2)
		 * it's for a locale.  Even if there isn't unicode semantics
		 * here, at runtime there may be because of matching against a
		 * utf8 string, so accept a possible false positive for
		 * latin1-range folds */
d3000 2
a3001 2
		    && (!(data->start_class->flags & ANYOF_LOC_NONBITMAP_FOLD)
			|| !ANYOF_BITMAP_TEST(data->start_class, PL_fold_latin1[uc])))
a3002 1
		{
a3003 1
		}
a3007 16
		else if (uc >= 0x100) {
		    int i;

		    /* Some Unicode code points fold to the Latin1 range; as
		     * XXX temporary code, instead of figuring out if this is
		     * one, just assume it is and set all the start class bits
		     * that could be some such above 255 code point's fold
		     * which will generate fals positives.  As the code
		     * elsewhere that does compute the fold settles down, it
		     * can be extracted out and re-used here */
		    for (i = 0; i < 256; i++){
			if (_HAS_NONLATIN1_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(i)) {
			    ANYOF_BITMAP_SET(data->start_class, i);
			}
		    }
		}
a3033 1
		uc = utf8_to_uvchr_buf(s, s + l, NULL);
d3035 1
d3037 3
a3039 18
	    else if (has_exactf_sharp_s) {
		RExC_seen |= REG_SEEN_EXACTF_SHARP_S;
	    }
	    min += l - min_subtract;
            if (min < 0) {
                min = 0;
            }
            delta += min_subtract;
	    if (flags & SCF_DO_SUBSTR) {
		data->pos_min += l - min_subtract;
		if (data->pos_min < 0) {
                    data->pos_min = 0;
                }
                data->pos_delta += min_subtract;
		if (min_subtract) {
		    data->longest = &(data->longest_float);
		}
	    }
d3043 1
d3045 3
a3047 4
		 (!(data->start_class->flags & (ANYOF_CLASS | ANYOF_LOCALE))
		  && !ANYOF_BITMAP_TEST(data->start_class, uc)
		  && !ANYOF_BITMAP_TEST(data->start_class, PL_fold_latin1[uc])))
		{
a3048 1
		}
d3054 2
a3055 5
		    data->start_class->flags |= ANYOF_LOC_NONBITMAP_FOLD;
		    if (OP(scan) == EXACTFL) {
			/* XXX This set is probably no longer necessary, and
			 * probably wrong as LOCALE now is on in the initial
			 * state */
a3056 31
		    }
		    else {

			/* Also set the other member of the fold pair.  In case
			 * that unicode semantics is called for at runtime, use
			 * the full latin1 fold.  (Can't do this for locale,
			 * because not known until runtime) */
			ANYOF_BITMAP_SET(data->start_class, PL_fold_latin1[uc]);

                        /* All other (EXACTFL handled above) folds except under
                         * /iaa that include s, S, and sharp_s also may include
                         * the others */
			if (OP(scan) != EXACTFA) {
			    if (uc == 's' || uc == 'S') {
				ANYOF_BITMAP_SET(data->start_class,
					         LATIN_SMALL_LETTER_SHARP_S);
			    }
			    else if (uc == LATIN_SMALL_LETTER_SHARP_S) {
				ANYOF_BITMAP_SET(data->start_class, 's');
				ANYOF_BITMAP_SET(data->start_class, 'S');
			    }
			}
		    }
		}
		else if (uc >= 0x100) {
		    int i;
		    for (i = 0; i < 256; i++){
			if (_HAS_NONLATIN1_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(i)) {
			    ANYOF_BITMAP_SET(data->start_class, i);
			}
		    }
d3060 1
a3060 1
		if (data->start_class->flags & ANYOF_LOC_NONBITMAP_FOLD) {
d3063 1
a3063 1
		    if (uc < 0x100) {
a3064 22
                        if (OP(scan) != EXACTFL) {

                            /* And set the other member of the fold pair, but
                             * can't do that in locale because not known until
                             * run-time */
                            ANYOF_BITMAP_SET(data->start_class,
					     PL_fold_latin1[uc]);

			    /* All folds except under /iaa that include s, S,
			     * and sharp_s also may include the others */
			    if (OP(scan) != EXACTFA) {
				if (uc == 's' || uc == 'S') {
				    ANYOF_BITMAP_SET(data->start_class,
					           LATIN_SMALL_LETTER_SHARP_S);
				}
				else if (uc == LATIN_SMALL_LETTER_SHARP_S) {
				    ANYOF_BITMAP_SET(data->start_class, 's');
				    ANYOF_BITMAP_SET(data->start_class, 'S');
				}
			    }
                        }
		    }
d3071 1
a3071 1
	else if (REGNODE_VARIES(OP(scan))) {
d3148 7
a3154 10
	        /* Exclude from super-linear cache processing any {n,m}
		   regops for which the combination of input pos and regex
		   pos is not enough information to determine if a match
		   will be possible.

		   For example, in the regex /foo(bar\s*){4,8}baz/ with the
		   regex pos at the \s*, the prospects for a match depend not
		   only on the input position but also on how many (bar\s*)
		   repeats into the {4,8} we are. */
               if ((mincount > 1) || (maxcount > 1 && maxcount != REG_INFTY))
d3223 1
a3223 1
		    if (!REGNODE_SIMPLE(OP(nxt))
d3244 2
a3245 2
		    NEXT_OFF(nxt1+ 1) = 0; /* just for consistency. */
		    NEXT_OFF(nxt2) = 0;	/* just for consistency with CURLY. */
d3248 1
a3248 1
		    NEXT_OFF(nxt+ 1) = 0; /* just for consistency. */
d3271 1
a3271 1
		    if ((data->flags & SF_IN_PAR) && OP(nxt) == CLOSE) {
d3275 2
d3288 2
a3289 2
			NEXT_OFF(nxt1 + 1) = 0; /* just for consistency. */
			NEXT_OFF(nxt + 1) = 0; /* just for consistency. */
d3294 1
d3316 1
a3316 1
			    However, this time it's not a subexpression
d3361 1
d3430 1
a3430 1
	    default:			/* REF, ANYOFV, and CLUMP only? */
d3449 3
a3451 3
                            ANYOF_BITMAP_CLEAR(data->start_class, value);
                }
                else {
d3454 2
a3455 2
                            ANYOF_BITMAP_SET(data->start_class, value);
                }
d3468 13
d3482 1
a3482 1
	else if (REGNODE_SIMPLE(OP(scan))) {
d3508 1
a3508 1
				 || ANYOF_CLASS_TEST_ANY_SET(data->start_class));
d3526 3
a3528 13
                            if (OP(scan) == ALNUMU) {
                                for (value = 0; value < 256; value++) {
                                    if (!isWORDCHAR_L1(value)) {
                                        ANYOF_BITMAP_CLEAR(data->start_class, value);
                                    }
                                }
                            } else {
                                for (value = 0; value < 256; value++) {
                                    if (!isALNUM(value)) {
                                        ANYOF_BITMAP_CLEAR(data->start_class, value);
                                    }
                                }
                            }
d3534 15
a3548 17

			/* Even if under locale, set the bits for non-locale
			 * in case it isn't a true locale-node.  This will
			 * create false positives if it truly is locale */
                        if (OP(scan) == ALNUMU) {
                            for (value = 0; value < 256; value++) {
                                if (isWORDCHAR_L1(value)) {
                                    ANYOF_BITMAP_SET(data->start_class, value);
                                }
                            }
                        } else {
                            for (value = 0; value < 256; value++) {
                                if (isALNUM(value)) {
                                    ANYOF_BITMAP_SET(data->start_class, value);
                                }
                            }
                        }
d3555 3
a3557 13
                            if (OP(scan) == NALNUMU) {
                                for (value = 0; value < 256; value++) {
                                    if (isWORDCHAR_L1(value)) {
                                        ANYOF_BITMAP_CLEAR(data->start_class, value);
                                    }
                                }
                            } else {
                                for (value = 0; value < 256; value++) {
                                    if (isALNUM(value)) {
                                        ANYOF_BITMAP_CLEAR(data->start_class, value);
                                    }
                                }
			    }
d3563 4
a3566 16

			/* Even if under locale, set the bits for non-locale in
			 * case it isn't a true locale-node.  This will create
			 * false positives if it truly is locale */
			if (OP(scan) == NALNUMU) {
			    for (value = 0; value < 256; value++) {
				if (! isWORDCHAR_L1(value)) {
				    ANYOF_BITMAP_SET(data->start_class, value);
				}
			    }
			} else {
			    for (value = 0; value < 256; value++) {
				if (! isALNUM(value)) {
				    ANYOF_BITMAP_SET(data->start_class, value);
				}
			    }
d3570 10
d3584 3
a3586 13
			    if (OP(scan) == SPACEU) {
                                for (value = 0; value < 256; value++) {
                                    if (!isSPACE_L1(value)) {
                                        ANYOF_BITMAP_CLEAR(data->start_class, value);
                                    }
                                }
                            } else {
                                for (value = 0; value < 256; value++) {
                                    if (!isSPACE(value)) {
                                        ANYOF_BITMAP_CLEAR(data->start_class, value);
                                    }
                                }
                            }
d3590 1
a3590 1
                        if (data->start_class->flags & ANYOF_LOCALE) {
d3592 4
a3595 13
                        }
                        if (OP(scan) == SPACEU) {
                            for (value = 0; value < 256; value++) {
                                if (isSPACE_L1(value)) {
                                    ANYOF_BITMAP_SET(data->start_class, value);
                                }
                            }
                        } else {
                            for (value = 0; value < 256; value++) {
                                if (isSPACE(value)) {
                                    ANYOF_BITMAP_SET(data->start_class, value);
                                }
                            }
d3599 10
d3613 3
a3615 13
                            if (OP(scan) == NSPACEU) {
                                for (value = 0; value < 256; value++) {
                                    if (isSPACE_L1(value)) {
                                        ANYOF_BITMAP_CLEAR(data->start_class, value);
                                    }
                                }
                            } else {
                                for (value = 0; value < 256; value++) {
                                    if (isSPACE(value)) {
                                        ANYOF_BITMAP_CLEAR(data->start_class, value);
                                    }
                                }
                            }
d3621 5
a3625 14
                        if (OP(scan) == NSPACEU) {
                            for (value = 0; value < 256; value++) {
                                if (!isSPACE_L1(value)) {
                                    ANYOF_BITMAP_SET(data->start_class, value);
                                }
                            }
                        }
                        else {
                            for (value = 0; value < 256; value++) {
                                if (!isSPACE(value)) {
                                    ANYOF_BITMAP_SET(data->start_class, value);
                                }
                            }
                        }
d3628 1
a3628 1
		case DIGIT:
d3630 2
a3631 2
			if (!(data->start_class->flags & ANYOF_LOCALE)) {
                            ANYOF_CLASS_CLEAR(data->start_class,ANYOF_NDIGIT);
d3633 1
a3633 1
				if (!isDIGIT(value))
d3638 12
d3652 5
a3656 3
			for (value = 0; value < 256; value++)
			    if (isDIGIT(value))
				ANYOF_BITMAP_SET(data->start_class, value);
d3661 1
a3661 2
			if (!(data->start_class->flags & ANYOF_LOCALE))
                            ANYOF_CLASS_CLEAR(data->start_class,ANYOF_DIGIT);
d3669 5
a3673 3
			for (value = 0; value < 256; value++)
			    if (!isDIGIT(value))
				ANYOF_BITMAP_SET(data->start_class, value);
d3678 1
a3678 1

d3776 1
a3776 1
                    minlens when it's all done. This way we don't
d4059 1
a4059 1
#endif /* TRIE_STUDY_OPT */
d4212 1
a4212 1
Perl_re_compile(pTHX_ SV * const pattern, U32 orig_pm_flags)
d4219 2
a4220 2
    char* VOL exp;
    char* xend;
a4223 5
    U32 pm_flags;

    /* these are all flags - maybe they should be turned
     * into a single int with different bit masks */
    I32 sawlookahead = 0;
a4225 5
    bool used_setjump = FALSE;
    regex_charset initial_charset = get_regex_charset(orig_pm_flags);

    U8 jump_ret = 0;
    dJMPENV;
d4230 1
a4230 1
    int restudied;
d4239 1
a4239 7
#ifndef PERL_IN_XSUB_RE
    /* Initialize these here instead of as-needed, as is quick and avoids
     * having to test them each time otherwise */
    if (! PL_AboveLatin1) {
	PL_AboveLatin1 = _new_invlist_C_array(AboveLatin1_invlist);
	PL_ASCII = _new_invlist_C_array(ASCII_invlist);
	PL_Latin1 = _new_invlist_C_array(Latin1_invlist);
d4241 7
a4247 124
	PL_L1PosixAlnum = _new_invlist_C_array(L1PosixAlnum_invlist);
	PL_PosixAlnum = _new_invlist_C_array(PosixAlnum_invlist);

	PL_L1PosixAlpha = _new_invlist_C_array(L1PosixAlpha_invlist);
	PL_PosixAlpha = _new_invlist_C_array(PosixAlpha_invlist);

	PL_PosixBlank = _new_invlist_C_array(PosixBlank_invlist);
	PL_XPosixBlank = _new_invlist_C_array(XPosixBlank_invlist);

	PL_L1Cased = _new_invlist_C_array(L1Cased_invlist);

	PL_PosixCntrl = _new_invlist_C_array(PosixCntrl_invlist);
	PL_XPosixCntrl = _new_invlist_C_array(XPosixCntrl_invlist);

	PL_PosixDigit = _new_invlist_C_array(PosixDigit_invlist);

	PL_L1PosixGraph = _new_invlist_C_array(L1PosixGraph_invlist);
	PL_PosixGraph = _new_invlist_C_array(PosixGraph_invlist);

	PL_L1PosixAlnum = _new_invlist_C_array(L1PosixAlnum_invlist);
	PL_PosixAlnum = _new_invlist_C_array(PosixAlnum_invlist);

	PL_L1PosixLower = _new_invlist_C_array(L1PosixLower_invlist);
	PL_PosixLower = _new_invlist_C_array(PosixLower_invlist);

	PL_L1PosixPrint = _new_invlist_C_array(L1PosixPrint_invlist);
	PL_PosixPrint = _new_invlist_C_array(PosixPrint_invlist);

	PL_L1PosixPunct = _new_invlist_C_array(L1PosixPunct_invlist);
	PL_PosixPunct = _new_invlist_C_array(PosixPunct_invlist);

	PL_PerlSpace = _new_invlist_C_array(PerlSpace_invlist);
	PL_XPerlSpace = _new_invlist_C_array(XPerlSpace_invlist);

	PL_PosixSpace = _new_invlist_C_array(PosixSpace_invlist);
	PL_XPosixSpace = _new_invlist_C_array(XPosixSpace_invlist);

	PL_L1PosixUpper = _new_invlist_C_array(L1PosixUpper_invlist);
	PL_PosixUpper = _new_invlist_C_array(PosixUpper_invlist);

	PL_VertSpace = _new_invlist_C_array(VertSpace_invlist);

	PL_PosixWord = _new_invlist_C_array(PosixWord_invlist);
	PL_L1PosixWord = _new_invlist_C_array(L1PosixWord_invlist);

	PL_PosixXDigit = _new_invlist_C_array(PosixXDigit_invlist);
	PL_XPosixXDigit = _new_invlist_C_array(XPosixXDigit_invlist);
    }
#endif

    exp = SvPV(pattern, plen);

    if (plen == 0) { /* ignore the utf8ness if the pattern is 0 length */
	RExC_utf8 = RExC_orig_utf8 = 0;
    }
    else {
	RExC_utf8 = RExC_orig_utf8 = SvUTF8(pattern);
    }
    RExC_uni_semantics = 0;
    RExC_contains_locale = 0;

    /****************** LONG JUMP TARGET HERE***********************/
    /* Longjmp back to here if have to switch in midstream to utf8 */
    if (! RExC_orig_utf8) {
	JMPENV_PUSH(jump_ret);
	used_setjump = TRUE;
    }

    if (jump_ret == 0) {    /* First time through */
	xend = exp + plen;

        DEBUG_COMPILE_r({
            SV *dsv= sv_newmortal();
            RE_PV_QUOTED_DECL(s, RExC_utf8,
                dsv, exp, plen, 60);
            PerlIO_printf(Perl_debug_log, "%sCompiling REx%s %s\n",
                           PL_colors[4],PL_colors[5],s);
        });
    }
    else {  /* longjumped back */
        STRLEN len = plen;

        /* If the cause for the longjmp was other than changing to utf8, pop
         * our own setjmp, and longjmp to the correct handler */
	if (jump_ret != UTF8_LONGJMP) {
	    JMPENV_POP;
	    JMPENV_JUMP(jump_ret);
	}

	GET_RE_DEBUG_FLAGS;

        /* It's possible to write a regexp in ascii that represents Unicode
        codepoints outside of the byte range, such as via \x{100}. If we
        detect such a sequence we have to convert the entire pattern to utf8
        and then recompile, as our sizing calculation will have been based
        on 1 byte == 1 character, but we will need to use utf8 to encode
        at least some part of the pattern, and therefore must convert the whole
        thing.
        -- dmq */
        DEBUG_PARSE_r(PerlIO_printf(Perl_debug_log,
	    "UTF8 mismatch! Converting to utf8 for resizing and compile\n"));
        exp = (char*)Perl_bytes_to_utf8(aTHX_
				        (U8*)SvPV_nomg(pattern, plen),
					&len);
        xend = exp + len;
        RExC_orig_utf8 = RExC_utf8 = 1;
        SAVEFREEPV(exp);
    }

#ifdef TRIE_STUDY_OPT
    restudied = 0;
#endif

    pm_flags = orig_pm_flags;

    if (initial_charset == REGEX_LOCALE_CHARSET) {
	RExC_contains_locale = 1;
    }
    else if (RExC_utf8 && initial_charset == REGEX_DEPENDS_CHARSET) {

	/* Set to use unicode semantics if the pattern is in utf8 and has the
	 * 'depends' charset specified, as it means unicode when utf8  */
	set_regex_charset(&pm_flags, REGEX_UNICODE_CHARSET);
    }
d4249 1
a4254 1
    RExC_in_lookbehind = 0;
a4257 1
    RExC_override_recoding = 0;
d4283 1
a4283 5
    DEBUG_PARSE_r(
	PerlIO_printf(Perl_debug_log, "Starting first pass (sizing)\n");
        RExC_lastnum=0;
        RExC_lastparse=NULL;
    );
d4288 18
a4305 4

    /* Here, finished first pass.  Get rid of any added setjmp */
    if (used_setjump) {
	JMPENV_POP;
a4306 1

a4314 8

    /* The first pass could have found things that force Unicode semantics */
    if ((RExC_utf8 || RExC_uni_semantics)
	 && get_regex_charset(pm_flags) == REGEX_DEPENDS_CHARSET)
    {
	set_regex_charset(&pm_flags, REGEX_UNICODE_CHARSET);
    }

d4347 1
a4347 7
        bool has_charset = (get_regex_charset(r->extflags) != REGEX_DEPENDS_CHARSET);

        /* The caret is output if there are any defaults: if not all the STD
         * flags are set, or if no character set specifier is needed */
        bool has_default =
                    (((r->extflags & RXf_PMf_STD_PMMOD) != RXf_PMf_STD_PMMOD)
                    || ! has_charset);
d4353 1
a4353 12
        /* Allocate for the worst case, which is all the std flags are turned
         * on.  If more precision is desired, we could do a population count of
         * the flags set.  This could be done with a small lookup table, or by
         * shifting, masking and adding, or even, when available, assembly
         * language for a machine-language population count.
         * We never output a minus, as all those are defaults, so are
         * covered by the caret */
	const STRLEN wraplen = plen + has_p + has_runon
            + has_default       /* If needs a caret */

		/* If needs a character set specifier */
	    + ((has_charset) ? MAX_CHARSET_NAME_LENGTH : 0)
d4357 2
a4358 1
        p = sv_grow(MUTABLE_SV(rx), wraplen + 1); /* +1 for the ending NUL */
a4361 11

        /* If a default, cover it using the caret */
        if (has_default) {
            *p++= DEFAULT_PAT_MOD;
        }
        if (has_charset) {
	    STRLEN len;
	    const char* const name = get_regex_charset_name(r->extflags, &len);
	    Copy(name, p, len, char);
	    p += len;
        }
d4365 2
d4368 1
d4372 2
d4376 4
a4390 1
	SvCUR_set(rx, p - SvPVX_const(rx));
d4442 1
a4442 1
    r->minlen = minlen = sawlookahead = sawplus = sawopen = 0;
d4490 1
d4506 1
a4506 1
	    (OP(first) == IFMATCH && !first->flags && (sawlookahead = 1)) ||
d4522 1
a4522 1

d4534 1
a4534 1
	    else
d4537 1
a4537 1
#ifdef TRIE_STCLASS
d4558 2
a4559 2
#endif
	else if (REGNODE_SIMPLE(OP(first)))
d4593 1
a4593 1
	if (sawplus && !sawlookahead && (!sawopen || !RExC_sawback)
d4624 1
a4624 1

d4642 1
a4642 1

d4667 3
a4669 5
            /* See comments for join_exact for why REG_SEEN_EXACTF_SHARP_S */
	    if ((RExC_seen & REG_SEEN_EXACTF_SHARP_S)
		|| (SvCUR(data.longest_fixed)  /* ok to leave SvCUR */
		    && data.offset_fixed == data.offset_float_min
		    && SvCUR(data.longest_fixed) == SvCUR(data.longest_float)))
d4712 4
a4715 7

        /* See comments for join_exact for why REG_SEEN_EXACTF_SHARP_S */
	if (! (RExC_seen & REG_SEEN_EXACTF_SHARP_S)
	    && (longest_fixed_length
	        || (data.flags & SF_FIX_BEFORE_EOL /* Cannot have SEOL and MULTI */
		    && (!(data.flags & SF_FIX_BEFORE_MEOL)
		        || (RExC_flags & RXf_PMf_MULTILINE)))) )
a4751 1

a4757 1
	    data.start_class->flags |= ANYOF_IS_SYNTHETIC;
d4808 1
a4808 1

a4823 1

a4827 1
	    data.start_class->flags |= ANYOF_IS_SYNTHETIC;
d4888 3
a4890 2

        if (PL_regkind[fop] == NOTHING && OP(NEXTOPER(first)) == END)
d4892 1
a4892 1
        else if (PL_regkind[fop] == BOL && OP(NEXTOPER(first)) == END)
d4894 1
a4894 2
        else if (fop == PLUS && OP(NEXTOPER(first)) == SPACE
			     && OP(regnext(first)) == END)
d4900 1
a4900 1
        ri->name_list_idx = add_data( pRExC_state, 1, "a" );
d4950 1
a4950 1
        Perl_croak_no_modify(aTHX);
d5012 1
a5012 2
                    if (retarray)
                        ret = newSVsv(&PL_sv_undef);
d5250 1
a5250 1
        Perl_croak_no_modify(aTHX);
d5376 1
a5376 2
            Perl_croak(aTHX_ "panic: bad flag %lx in reg_scan_name",
		       (unsigned long) flags);
d5428 2
a5429 28

/* This section of code defines the inversion list object and its methods.  The
 * interfaces are highly subject to change, so as much as possible is static to
 * this file.  An inversion list is here implemented as a malloc'd C UV array
 * with some added info that is placed as UVs at the beginning in a header
 * portion.  An inversion list for Unicode is an array of code points, sorted
 * by ordinal number.  The zeroth element is the first code point in the list.
 * The 1th element is the first element beyond that not in the list.  In other
 * words, the first range is
 *  invlist[0]..(invlist[1]-1)
 * The other ranges follow.  Thus every element whose index is divisible by two
 * marks the beginning of a range that is in the list, and every element not
 * divisible by two marks the beginning of a range not in the list.  A single
 * element inversion list that contains the single code point N generally
 * consists of two elements
 *  invlist[0] == N
 *  invlist[1] == N+1
 * (The exception is when N is the highest representable value on the
 * machine, in which case the list containing just it would be a single
 * element, itself.  By extension, if the last range in the list extends to
 * infinity, then the first element of that range will be in the inversion list
 * at a position that is divisible by two, and is the final element in the
 * list.)
 * Taking the complement (inverting) an inversion list is quite simple, if the
 * first element is 0, remove it; otherwise add a 0 element at the beginning.
 * This implementation reserves an element at the beginning of each inversion list
 * to contain 0 when the list contains 0, and contains 1 otherwise.  The actual
 * beginning of the list is either that element if 0, or the next one if 1.
d5431 1
a5431 3
 * More about inversion lists can be found in "Unicode Demystified"
 * Chapter 13 by Richard Gillam, published by Addison-Wesley.
 * More will be coming when functionality is added later.
d5433 10
a5442 7
 * The inversion list data structure is currently implemented as an SV pointing
 * to an array of UVs that the SV thinks are bytes.  This allows us to have an
 * array of UV whose memory management is automatically handled by the existing
 * facilities for SV's.
 *
 * Some of the methods should always be private to the implementation, and some
 * should eventually be made public */
d5444 3
a5446 33
#define INVLIST_LEN_OFFSET 0	/* Number of elements in the inversion list */
#define INVLIST_ITER_OFFSET 1	/* Current iteration position */

/* This is a combination of a version and data structure type, so that one
 * being passed in can be validated to be an inversion list of the correct
 * vintage.  When the structure of the header is changed, a new random number
 * in the range 2**31-1 should be generated and the new() method changed to
 * insert that at this location.  Then, if an auxiliary program doesn't change
 * correspondingly, it will be discovered immediately */
#define INVLIST_VERSION_ID_OFFSET 2
#define INVLIST_VERSION_ID 1064334010

/* For safety, when adding new elements, remember to #undef them at the end of
 * the inversion list code section */

#define INVLIST_ZERO_OFFSET 3	/* 0 or 1; must be last element in header */
/* The UV at position ZERO contains either 0 or 1.  If 0, the inversion list
 * contains the code point U+00000, and begins here.  If 1, the inversion list
 * doesn't contain U+0000, and it begins at the next UV in the array.
 * Inverting an inversion list consists of adding or removing the 0 at the
 * beginning of it.  By reserving a space for that 0, inversion can be made
 * very fast */

#define HEADER_LENGTH (INVLIST_ZERO_OFFSET + 1)

/* Internally things are UVs */
#define TO_INTERNAL_SIZE(x) ((x + HEADER_LENGTH) * sizeof(UV))
#define FROM_INTERNAL_SIZE(x) ((x / sizeof(UV)) - HEADER_LENGTH)

#define INVLIST_INITIAL_LEN 10

PERL_STATIC_INLINE UV*
S__invlist_array_init(pTHX_ SV* const invlist, const bool will_have_0)
d5448 12
a5459 7
    /* Returns a pointer to the first element in the inversion list's array.
     * This is called upon initialization of an inversion list.  Where the
     * array begins depends on whether the list has the code point U+0000
     * in it or not.  The other parameter tells it whether the code that
     * follows this call is about to put a 0 in the inversion list or not.
     * The first element is either the element with 0, if 0, or the next one,
     * if 1 */
d5461 2
a5462 1
    UV* zero = get_invlist_zero_addr(invlist);
d5464 5
a5468 1
    PERL_ARGS_ASSERT__INVLIST_ARRAY_INIT;
d5470 2
a5471 2
    /* Must be empty */
    assert(! *get_invlist_len_addr(invlist));
d5473 1
a5473 4
    /* 1^1 = 0; 1^0 = 1 */
    *zero = 1 ^ will_have_0;
    return zero + *zero;
}
d5475 2
a5476 6
PERL_STATIC_INLINE UV*
S_invlist_array(pTHX_ SV* const invlist)
{
    /* Returns the pointer to the inversion list's array.  Every time the
     * length changes, this needs to be called in case malloc or realloc moved
     * it */
d5478 1
a5478 1
    PERL_ARGS_ASSERT_INVLIST_ARRAY;
a5479 5
    /* Must not be empty.  If these fail, you probably didn't check for <len>
     * being non-zero before trying to get the array */
    assert(*get_invlist_len_addr(invlist));
    assert(*get_invlist_zero_addr(invlist) == 0
	   || *get_invlist_zero_addr(invlist) == 1);
d5481 24
a5504 1178
    /* The array begins either at the element reserved for zero if the
     * list contains 0 (that element will be set to 0), or otherwise the next
     * element (in which case the reserved element will be set to 1). */
    return (UV *) (get_invlist_zero_addr(invlist)
		   + *get_invlist_zero_addr(invlist));
}

PERL_STATIC_INLINE UV*
S_get_invlist_len_addr(pTHX_ SV* invlist)
{
    /* Return the address of the UV that contains the current number
     * of used elements in the inversion list */

    PERL_ARGS_ASSERT_GET_INVLIST_LEN_ADDR;

    return (UV *) (SvPVX(invlist) + (INVLIST_LEN_OFFSET * sizeof (UV)));
}

PERL_STATIC_INLINE UV
S_invlist_len(pTHX_ SV* const invlist)
{
    /* Returns the current number of elements stored in the inversion list's
     * array */

    PERL_ARGS_ASSERT_INVLIST_LEN;

    return *get_invlist_len_addr(invlist);
}

PERL_STATIC_INLINE void
S_invlist_set_len(pTHX_ SV* const invlist, const UV len)
{
    /* Sets the current number of elements stored in the inversion list */

    PERL_ARGS_ASSERT_INVLIST_SET_LEN;

    *get_invlist_len_addr(invlist) = len;

    assert(len <= SvLEN(invlist));

    SvCUR_set(invlist, TO_INTERNAL_SIZE(len));
    /* If the list contains U+0000, that element is part of the header,
     * and should not be counted as part of the array.  It will contain
     * 0 in that case, and 1 otherwise.  So we could flop 0=>1, 1=>0 and
     * subtract:
     *	SvCUR_set(invlist,
     *		  TO_INTERNAL_SIZE(len
     *				   - (*get_invlist_zero_addr(inv_list) ^ 1)));
     * But, this is only valid if len is not 0.  The consequences of not doing
     * this is that the memory allocation code may think that 1 more UV is
     * being used than actually is, and so might do an unnecessary grow.  That
     * seems worth not bothering to make this the precise amount.
     *
     * Note that when inverting, SvCUR shouldn't change */
}

PERL_STATIC_INLINE UV
S_invlist_max(pTHX_ SV* const invlist)
{
    /* Returns the maximum number of elements storable in the inversion list's
     * array, without having to realloc() */

    PERL_ARGS_ASSERT_INVLIST_MAX;

    return FROM_INTERNAL_SIZE(SvLEN(invlist));
}

PERL_STATIC_INLINE UV*
S_get_invlist_zero_addr(pTHX_ SV* invlist)
{
    /* Return the address of the UV that is reserved to hold 0 if the inversion
     * list contains 0.  This has to be the last element of the heading, as the
     * list proper starts with either it if 0, or the next element if not.
     * (But we force it to contain either 0 or 1) */

    PERL_ARGS_ASSERT_GET_INVLIST_ZERO_ADDR;

    return (UV *) (SvPVX(invlist) + (INVLIST_ZERO_OFFSET * sizeof (UV)));
}

#ifndef PERL_IN_XSUB_RE
SV*
Perl__new_invlist(pTHX_ IV initial_size)
{

    /* Return a pointer to a newly constructed inversion list, with enough
     * space to store 'initial_size' elements.  If that number is negative, a
     * system default is used instead */

    SV* new_list;

    if (initial_size < 0) {
	initial_size = INVLIST_INITIAL_LEN;
    }

    /* Allocate the initial space */
    new_list = newSV(TO_INTERNAL_SIZE(initial_size));
    invlist_set_len(new_list, 0);

    /* Force iterinit() to be used to get iteration to work */
    *get_invlist_iter_addr(new_list) = UV_MAX;

    /* This should force a segfault if a method doesn't initialize this
     * properly */
    *get_invlist_zero_addr(new_list) = UV_MAX;

    *get_invlist_version_id_addr(new_list) = INVLIST_VERSION_ID;
#if HEADER_LENGTH != 4
#   error Need to regenerate VERSION_ID by running perl -E 'say int(rand 2**31-1)', and then changing the #if to the new length
#endif

    return new_list;
}
#endif

STATIC SV*
S__new_invlist_C_array(pTHX_ UV* list)
{
    /* Return a pointer to a newly constructed inversion list, initialized to
     * point to <list>, which has to be in the exact correct inversion list
     * form, including internal fields.  Thus this is a dangerous routine that
     * should not be used in the wrong hands */

    SV* invlist = newSV_type(SVt_PV);

    PERL_ARGS_ASSERT__NEW_INVLIST_C_ARRAY;

    SvPV_set(invlist, (char *) list);
    SvLEN_set(invlist, 0);  /* Means we own the contents, and the system
			       shouldn't touch it */
    SvCUR_set(invlist, TO_INTERNAL_SIZE(invlist_len(invlist)));

    if (*get_invlist_version_id_addr(invlist) != INVLIST_VERSION_ID) {
        Perl_croak(aTHX_ "panic: Incorrect version for previously generated inversion list");
    }

    return invlist;
}

STATIC void
S_invlist_extend(pTHX_ SV* const invlist, const UV new_max)
{
    /* Grow the maximum size of an inversion list */

    PERL_ARGS_ASSERT_INVLIST_EXTEND;

    SvGROW((SV *)invlist, TO_INTERNAL_SIZE(new_max));
}

PERL_STATIC_INLINE void
S_invlist_trim(pTHX_ SV* const invlist)
{
    PERL_ARGS_ASSERT_INVLIST_TRIM;

    /* Change the length of the inversion list to how many entries it currently
     * has */

    SvPV_shrink_to_cur((SV *) invlist);
}

/* An element is in an inversion list iff its index is even numbered: 0, 2, 4,
 * etc */
#define ELEMENT_RANGE_MATCHES_INVLIST(i) (! ((i) & 1))
#define PREV_RANGE_MATCHES_INVLIST(i) (! ELEMENT_RANGE_MATCHES_INVLIST(i))

#define _invlist_union_complement_2nd(a, b, output) _invlist_union_maybe_complement_2nd(a, b, TRUE, output)

STATIC void
S__append_range_to_invlist(pTHX_ SV* const invlist, const UV start, const UV end)
{
   /* Subject to change or removal.  Append the range from 'start' to 'end' at
    * the end of the inversion list.  The range must be above any existing
    * ones. */

    UV* array;
    UV max = invlist_max(invlist);
    UV len = invlist_len(invlist);

    PERL_ARGS_ASSERT__APPEND_RANGE_TO_INVLIST;

    if (len == 0) { /* Empty lists must be initialized */
        array = _invlist_array_init(invlist, start == 0);
    }
    else {
	/* Here, the existing list is non-empty. The current max entry in the
	 * list is generally the first value not in the set, except when the
	 * set extends to the end of permissible values, in which case it is
	 * the first entry in that final set, and so this call is an attempt to
	 * append out-of-order */

	UV final_element = len - 1;
	array = invlist_array(invlist);
	if (array[final_element] > start
	    || ELEMENT_RANGE_MATCHES_INVLIST(final_element))
	{
	    Perl_croak(aTHX_ "panic: attempting to append to an inversion list, but wasn't at the end of the list, final=%"UVuf", start=%"UVuf", match=%c",
		       array[final_element], start,
		       ELEMENT_RANGE_MATCHES_INVLIST(final_element) ? 't' : 'f');
	}

	/* Here, it is a legal append.  If the new range begins with the first
	 * value not in the set, it is extending the set, so the new first
	 * value not in the set is one greater than the newly extended range.
	 * */
	if (array[final_element] == start) {
	    if (end != UV_MAX) {
		array[final_element] = end + 1;
	    }
	    else {
		/* But if the end is the maximum representable on the machine,
		 * just let the range that this would extend to have no end */
		invlist_set_len(invlist, len - 1);
	    }
	    return;
	}
    }

    /* Here the new range doesn't extend any existing set.  Add it */

    len += 2;	/* Includes an element each for the start and end of range */

    /* If overflows the existing space, extend, which may cause the array to be
     * moved */
    if (max < len) {
	invlist_extend(invlist, len);
	invlist_set_len(invlist, len);	/* Have to set len here to avoid assert
					   failure in invlist_array() */
	array = invlist_array(invlist);
    }
    else {
	invlist_set_len(invlist, len);
    }

    /* The next item on the list starts the range, the one after that is
     * one past the new range.  */
    array[len - 2] = start;
    if (end != UV_MAX) {
	array[len - 1] = end + 1;
    }
    else {
	/* But if the end is the maximum representable on the machine, just let
	 * the range have no end */
	invlist_set_len(invlist, len - 1);
    }
}

#ifndef PERL_IN_XSUB_RE

STATIC IV
S_invlist_search(pTHX_ SV* const invlist, const UV cp)
{
    /* Searches the inversion list for the entry that contains the input code
     * point <cp>.  If <cp> is not in the list, -1 is returned.  Otherwise, the
     * return value is the index into the list's array of the range that
     * contains <cp> */

    IV low = 0;
    IV high = invlist_len(invlist);
    const UV * const array = invlist_array(invlist);

    PERL_ARGS_ASSERT_INVLIST_SEARCH;

    /* If list is empty or the code point is before the first element, return
     * failure. */
    if (high == 0 || cp < array[0]) {
	return -1;
    }

    /* Binary search.  What we are looking for is <i> such that
     *	array[i] <= cp < array[i+1]
     * The loop below converges on the i+1. */
    while (low < high) {
	IV mid = (low + high) / 2;
	if (array[mid] <= cp) {
	    low = mid + 1;

	    /* We could do this extra test to exit the loop early.
	    if (cp < array[low]) {
		return mid;
	    }
	    */
	}
	else { /* cp < array[mid] */
	    high = mid;
	}
    }

    return high - 1;
}

void
Perl__invlist_populate_swatch(pTHX_ SV* const invlist, const UV start, const UV end, U8* swatch)
{
    /* populates a swatch of a swash the same way swatch_get() does in utf8.c,
     * but is used when the swash has an inversion list.  This makes this much
     * faster, as it uses a binary search instead of a linear one.  This is
     * intimately tied to that function, and perhaps should be in utf8.c,
     * except it is intimately tied to inversion lists as well.  It assumes
     * that <swatch> is all 0's on input */

    UV current = start;
    const IV len = invlist_len(invlist);
    IV i;
    const UV * array;

    PERL_ARGS_ASSERT__INVLIST_POPULATE_SWATCH;

    if (len == 0) { /* Empty inversion list */
        return;
    }

    array = invlist_array(invlist);

    /* Find which element it is */
    i = invlist_search(invlist, start);

    /* We populate from <start> to <end> */
    while (current < end) {
        UV upper;

	/* The inversion list gives the results for every possible code point
	 * after the first one in the list.  Only those ranges whose index is
	 * even are ones that the inversion list matches.  For the odd ones,
	 * and if the initial code point is not in the list, we have to skip
	 * forward to the next element */
        if (i == -1 || ! ELEMENT_RANGE_MATCHES_INVLIST(i)) {
            i++;
            if (i >= len) { /* Finished if beyond the end of the array */
                return;
            }
            current = array[i];
	    if (current >= end) {   /* Finished if beyond the end of what we
				       are populating */
                return;
            }
        }
        assert(current >= start);

	/* The current range ends one below the next one, except don't go past
	 * <end> */
        i++;
        upper = (i < len && array[i] < end) ? array[i] : end;

	/* Here we are in a range that matches.  Populate a bit in the 3-bit U8
	 * for each code point in it */
        for (; current < upper; current++) {
            const STRLEN offset = (STRLEN)(current - start);
            swatch[offset >> 3] |= 1 << (offset & 7);
        }

	/* Quit if at the end of the list */
        if (i >= len) {

	    /* But first, have to deal with the highest possible code point on
	     * the platform.  The previous code assumes that <end> is one
	     * beyond where we want to populate, but that is impossible at the
	     * platform's infinity, so have to handle it specially */
            if (UNLIKELY(end == UV_MAX && ELEMENT_RANGE_MATCHES_INVLIST(len-1)))
	    {
                const STRLEN offset = (STRLEN)(end - start);
                swatch[offset >> 3] |= 1 << (offset & 7);
            }
            return;
        }

	/* Advance to the next range, which will be for code points not in the
	 * inversion list */
        current = array[i];
    }

    return;
}


void
Perl__invlist_union_maybe_complement_2nd(pTHX_ SV* const a, SV* const b, bool complement_b, SV** output)
{
    /* Take the union of two inversion lists and point <output> to it.  *output
     * should be defined upon input, and if it points to one of the two lists,
     * the reference count to that list will be decremented.  The first list,
     * <a>, may be NULL, in which case a copy of the second list is returned.
     * If <complement_b> is TRUE, the union is taken of the complement
     * (inversion) of <b> instead of b itself.
     *
     * The basis for this comes from "Unicode Demystified" Chapter 13 by
     * Richard Gillam, published by Addison-Wesley, and explained at some
     * length there.  The preface says to incorporate its examples into your
     * code at your own risk.
     *
     * The algorithm is like a merge sort.
     *
     * XXX A potential performance improvement is to keep track as we go along
     * if only one of the inputs contributes to the result, meaning the other
     * is a subset of that one.  In that case, we can skip the final copy and
     * return the larger of the input lists, but then outside code might need
     * to keep track of whether to free the input list or not */

    UV* array_a;    /* a's array */
    UV* array_b;
    UV len_a;	    /* length of a's array */
    UV len_b;

    SV* u;			/* the resulting union */
    UV* array_u;
    UV len_u;

    UV i_a = 0;		    /* current index into a's array */
    UV i_b = 0;
    UV i_u = 0;

    /* running count, as explained in the algorithm source book; items are
     * stopped accumulating and are output when the count changes to/from 0.
     * The count is incremented when we start a range that's in the set, and
     * decremented when we start a range that's not in the set.  So its range
     * is 0 to 2.  Only when the count is zero is something not in the set.
     */
    UV count = 0;

    PERL_ARGS_ASSERT__INVLIST_UNION_MAYBE_COMPLEMENT_2ND;
    assert(a != b);

    /* If either one is empty, the union is the other one */
    if (a == NULL || ((len_a = invlist_len(a)) == 0)) {
	if (*output == a) {
            if (a != NULL) {
                SvREFCNT_dec(a);
            }
	}
	if (*output != b) {
	    *output = invlist_clone(b);
            if (complement_b) {
                _invlist_invert(*output);
            }
	} /* else *output already = b; */
	return;
    }
    else if ((len_b = invlist_len(b)) == 0) {
	if (*output == b) {
	    SvREFCNT_dec(b);
	}

        /* The complement of an empty list is a list that has everything in it,
         * so the union with <a> includes everything too */
        if (complement_b) {
            if (a == *output) {
                SvREFCNT_dec(a);
            }
            *output = _new_invlist(1);
            _append_range_to_invlist(*output, 0, UV_MAX);
        }
        else if (*output != a) {
            *output = invlist_clone(a);
        }
        /* else *output already = a; */
	return;
    }

    /* Here both lists exist and are non-empty */
    array_a = invlist_array(a);
    array_b = invlist_array(b);

    /* If are to take the union of 'a' with the complement of b, set it
     * up so are looking at b's complement. */
    if (complement_b) {

	/* To complement, we invert: if the first element is 0, remove it.  To
	 * do this, we just pretend the array starts one later, and clear the
	 * flag as we don't have to do anything else later */
        if (array_b[0] == 0) {
            array_b++;
            len_b--;
            complement_b = FALSE;
        }
        else {

            /* But if the first element is not zero, we unshift a 0 before the
             * array.  The data structure reserves a space for that 0 (which
             * should be a '1' right now), so physical shifting is unneeded,
             * but temporarily change that element to 0.  Before exiting the
             * routine, we must restore the element to '1' */
            array_b--;
            len_b++;
            array_b[0] = 0;
        }
    }

    /* Size the union for the worst case: that the sets are completely
     * disjoint */
    u = _new_invlist(len_a + len_b);

    /* Will contain U+0000 if either component does */
    array_u = _invlist_array_init(u, (len_a > 0 && array_a[0] == 0)
				      || (len_b > 0 && array_b[0] == 0));

    /* Go through each list item by item, stopping when exhausted one of
     * them */
    while (i_a < len_a && i_b < len_b) {
	UV cp;	    /* The element to potentially add to the union's array */
	bool cp_in_set;   /* is it in the the input list's set or not */

	/* We need to take one or the other of the two inputs for the union.
	 * Since we are merging two sorted lists, we take the smaller of the
	 * next items.  In case of a tie, we take the one that is in its set
	 * first.  If we took one not in the set first, it would decrement the
	 * count, possibly to 0 which would cause it to be output as ending the
	 * range, and the next time through we would take the same number, and
	 * output it again as beginning the next range.  By doing it the
	 * opposite way, there is no possibility that the count will be
	 * momentarily decremented to 0, and thus the two adjoining ranges will
	 * be seamlessly merged.  (In a tie and both are in the set or both not
	 * in the set, it doesn't matter which we take first.) */
	if (array_a[i_a] < array_b[i_b]
	    || (array_a[i_a] == array_b[i_b]
		&& ELEMENT_RANGE_MATCHES_INVLIST(i_a)))
	{
	    cp_in_set = ELEMENT_RANGE_MATCHES_INVLIST(i_a);
	    cp= array_a[i_a++];
	}
	else {
	    cp_in_set = ELEMENT_RANGE_MATCHES_INVLIST(i_b);
	    cp= array_b[i_b++];
	}

	/* Here, have chosen which of the two inputs to look at.  Only output
	 * if the running count changes to/from 0, which marks the
	 * beginning/end of a range in that's in the set */
	if (cp_in_set) {
	    if (count == 0) {
		array_u[i_u++] = cp;
	    }
	    count++;
	}
	else {
	    count--;
	    if (count == 0) {
		array_u[i_u++] = cp;
	    }
	}
    }

    /* Here, we are finished going through at least one of the lists, which
     * means there is something remaining in at most one.  We check if the list
     * that hasn't been exhausted is positioned such that we are in the middle
     * of a range in its set or not.  (i_a and i_b point to the element beyond
     * the one we care about.) If in the set, we decrement 'count'; if 0, there
     * is potentially more to output.
     * There are four cases:
     *	1) Both weren't in their sets, count is 0, and remains 0.  What's left
     *	   in the union is entirely from the non-exhausted set.
     *	2) Both were in their sets, count is 2.  Nothing further should
     *	   be output, as everything that remains will be in the exhausted
     *	   list's set, hence in the union; decrementing to 1 but not 0 insures
     *	   that
     *	3) the exhausted was in its set, non-exhausted isn't, count is 1.
     *	   Nothing further should be output because the union includes
     *	   everything from the exhausted set.  Not decrementing ensures that.
     *	4) the exhausted wasn't in its set, non-exhausted is, count is 1;
     *	   decrementing to 0 insures that we look at the remainder of the
     *	   non-exhausted set */
    if ((i_a != len_a && PREV_RANGE_MATCHES_INVLIST(i_a))
	|| (i_b != len_b && PREV_RANGE_MATCHES_INVLIST(i_b)))
    {
	count--;
    }

    /* The final length is what we've output so far, plus what else is about to
     * be output.  (If 'count' is non-zero, then the input list we exhausted
     * has everything remaining up to the machine's limit in its set, and hence
     * in the union, so there will be no further output. */
    len_u = i_u;
    if (count == 0) {
	/* At most one of the subexpressions will be non-zero */
	len_u += (len_a - i_a) + (len_b - i_b);
    }

    /* Set result to final length, which can change the pointer to array_u, so
     * re-find it */
    if (len_u != invlist_len(u)) {
	invlist_set_len(u, len_u);
	invlist_trim(u);
	array_u = invlist_array(u);
    }

    /* When 'count' is 0, the list that was exhausted (if one was shorter than
     * the other) ended with everything above it not in its set.  That means
     * that the remaining part of the union is precisely the same as the
     * non-exhausted list, so can just copy it unchanged.  (If both list were
     * exhausted at the same time, then the operations below will be both 0.)
     */
    if (count == 0) {
	IV copy_count; /* At most one will have a non-zero copy count */
	if ((copy_count = len_a - i_a) > 0) {
	    Copy(array_a + i_a, array_u + i_u, copy_count, UV);
	}
	else if ((copy_count = len_b - i_b) > 0) {
	    Copy(array_b + i_b, array_u + i_u, copy_count, UV);
	}
    }

    /*  We may be removing a reference to one of the inputs */
    if (a == *output || b == *output) {
	SvREFCNT_dec(*output);
    }

    /* If we've changed b, restore it */
    if (complement_b) {
        array_b[0] = 1;
    }

    *output = u;
    return;
}

void
Perl__invlist_intersection_maybe_complement_2nd(pTHX_ SV* const a, SV* const b, bool complement_b, SV** i)
{
    /* Take the intersection of two inversion lists and point <i> to it.  *i
     * should be defined upon input, and if it points to one of the two lists,
     * the reference count to that list will be decremented.
     * If <complement_b> is TRUE, the result will be the intersection of <a>
     * and the complement (or inversion) of <b> instead of <b> directly.
     *
     * The basis for this comes from "Unicode Demystified" Chapter 13 by
     * Richard Gillam, published by Addison-Wesley, and explained at some
     * length there.  The preface says to incorporate its examples into your
     * code at your own risk.  In fact, it had bugs
     *
     * The algorithm is like a merge sort, and is essentially the same as the
     * union above
     */

    UV* array_a;		/* a's array */
    UV* array_b;
    UV len_a;	/* length of a's array */
    UV len_b;

    SV* r;		     /* the resulting intersection */
    UV* array_r;
    UV len_r;

    UV i_a = 0;		    /* current index into a's array */
    UV i_b = 0;
    UV i_r = 0;

    /* running count, as explained in the algorithm source book; items are
     * stopped accumulating and are output when the count changes to/from 2.
     * The count is incremented when we start a range that's in the set, and
     * decremented when we start a range that's not in the set.  So its range
     * is 0 to 2.  Only when the count is 2 is something in the intersection.
     */
    UV count = 0;

    PERL_ARGS_ASSERT__INVLIST_INTERSECTION_MAYBE_COMPLEMENT_2ND;
    assert(a != b);

    /* Special case if either one is empty */
    len_a = invlist_len(a);
    if ((len_a == 0) || ((len_b = invlist_len(b)) == 0)) {

        if (len_a != 0 && complement_b) {

            /* Here, 'a' is not empty, therefore from the above 'if', 'b' must
             * be empty.  Here, also we are using 'b's complement, which hence
             * must be every possible code point.  Thus the intersection is
             * simply 'a'. */
            if (*i != a) {
                *i = invlist_clone(a);

                if (*i == b) {
                    SvREFCNT_dec(b);
                }
            }
            /* else *i is already 'a' */
            return;
        }

        /* Here, 'a' or 'b' is empty and not using the complement of 'b'.  The
         * intersection must be empty */
	if (*i == a) {
	    SvREFCNT_dec(a);
	}
	else if (*i == b) {
	    SvREFCNT_dec(b);
	}
	*i = _new_invlist(0);
	return;
    }

    /* Here both lists exist and are non-empty */
    array_a = invlist_array(a);
    array_b = invlist_array(b);

    /* If are to take the intersection of 'a' with the complement of b, set it
     * up so are looking at b's complement. */
    if (complement_b) {

	/* To complement, we invert: if the first element is 0, remove it.  To
	 * do this, we just pretend the array starts one later, and clear the
	 * flag as we don't have to do anything else later */
        if (array_b[0] == 0) {
            array_b++;
            len_b--;
            complement_b = FALSE;
        }
        else {

            /* But if the first element is not zero, we unshift a 0 before the
             * array.  The data structure reserves a space for that 0 (which
             * should be a '1' right now), so physical shifting is unneeded,
             * but temporarily change that element to 0.  Before exiting the
             * routine, we must restore the element to '1' */
            array_b--;
            len_b++;
            array_b[0] = 0;
        }
    }

    /* Size the intersection for the worst case: that the intersection ends up
     * fragmenting everything to be completely disjoint */
    r= _new_invlist(len_a + len_b);

    /* Will contain U+0000 iff both components do */
    array_r = _invlist_array_init(r, len_a > 0 && array_a[0] == 0
				     && len_b > 0 && array_b[0] == 0);

    /* Go through each list item by item, stopping when exhausted one of
     * them */
    while (i_a < len_a && i_b < len_b) {
	UV cp;	    /* The element to potentially add to the intersection's
		       array */
	bool cp_in_set;	/* Is it in the input list's set or not */

	/* We need to take one or the other of the two inputs for the
	 * intersection.  Since we are merging two sorted lists, we take the
	 * smaller of the next items.  In case of a tie, we take the one that
	 * is not in its set first (a difference from the union algorithm).  If
	 * we took one in the set first, it would increment the count, possibly
	 * to 2 which would cause it to be output as starting a range in the
	 * intersection, and the next time through we would take that same
	 * number, and output it again as ending the set.  By doing it the
	 * opposite of this, there is no possibility that the count will be
	 * momentarily incremented to 2.  (In a tie and both are in the set or
	 * both not in the set, it doesn't matter which we take first.) */
	if (array_a[i_a] < array_b[i_b]
	    || (array_a[i_a] == array_b[i_b]
		&& ! ELEMENT_RANGE_MATCHES_INVLIST(i_a)))
	{
	    cp_in_set = ELEMENT_RANGE_MATCHES_INVLIST(i_a);
	    cp= array_a[i_a++];
	}
	else {
	    cp_in_set = ELEMENT_RANGE_MATCHES_INVLIST(i_b);
	    cp= array_b[i_b++];
	}

	/* Here, have chosen which of the two inputs to look at.  Only output
	 * if the running count changes to/from 2, which marks the
	 * beginning/end of a range that's in the intersection */
	if (cp_in_set) {
	    count++;
	    if (count == 2) {
		array_r[i_r++] = cp;
	    }
	}
	else {
	    if (count == 2) {
		array_r[i_r++] = cp;
	    }
	    count--;
	}
    }

    /* Here, we are finished going through at least one of the lists, which
     * means there is something remaining in at most one.  We check if the list
     * that has been exhausted is positioned such that we are in the middle
     * of a range in its set or not.  (i_a and i_b point to elements 1 beyond
     * the ones we care about.)  There are four cases:
     *	1) Both weren't in their sets, count is 0, and remains 0.  There's
     *	   nothing left in the intersection.
     *	2) Both were in their sets, count is 2 and perhaps is incremented to
     *	   above 2.  What should be output is exactly that which is in the
     *	   non-exhausted set, as everything it has is also in the intersection
     *	   set, and everything it doesn't have can't be in the intersection
     *	3) The exhausted was in its set, non-exhausted isn't, count is 1, and
     *	   gets incremented to 2.  Like the previous case, the intersection is
     *	   everything that remains in the non-exhausted set.
     *	4) the exhausted wasn't in its set, non-exhausted is, count is 1, and
     *	   remains 1.  And the intersection has nothing more. */
    if ((i_a == len_a && PREV_RANGE_MATCHES_INVLIST(i_a))
	|| (i_b == len_b && PREV_RANGE_MATCHES_INVLIST(i_b)))
    {
	count++;
    }

    /* The final length is what we've output so far plus what else is in the
     * intersection.  At most one of the subexpressions below will be non-zero */
    len_r = i_r;
    if (count >= 2) {
	len_r += (len_a - i_a) + (len_b - i_b);
    }

    /* Set result to final length, which can change the pointer to array_r, so
     * re-find it */
    if (len_r != invlist_len(r)) {
	invlist_set_len(r, len_r);
	invlist_trim(r);
	array_r = invlist_array(r);
    }

    /* Finish outputting any remaining */
    if (count >= 2) { /* At most one will have a non-zero copy count */
	IV copy_count;
	if ((copy_count = len_a - i_a) > 0) {
	    Copy(array_a + i_a, array_r + i_r, copy_count, UV);
	}
	else if ((copy_count = len_b - i_b) > 0) {
	    Copy(array_b + i_b, array_r + i_r, copy_count, UV);
	}
    }

    /*  We may be removing a reference to one of the inputs */
    if (a == *i || b == *i) {
	SvREFCNT_dec(*i);
    }

    /* If we've changed b, restore it */
    if (complement_b) {
        array_b[0] = 1;
    }

    *i = r;
    return;
}

SV*
Perl__add_range_to_invlist(pTHX_ SV* invlist, const UV start, const UV end)
{
    /* Add the range from 'start' to 'end' inclusive to the inversion list's
     * set.  A pointer to the inversion list is returned.  This may actually be
     * a new list, in which case the passed in one has been destroyed.  The
     * passed in inversion list can be NULL, in which case a new one is created
     * with just the one range in it */

    SV* range_invlist;
    UV len;

    if (invlist == NULL) {
	invlist = _new_invlist(2);
	len = 0;
    }
    else {
	len = invlist_len(invlist);
    }

    /* If comes after the final entry, can just append it to the end */
    if (len == 0
	|| start >= invlist_array(invlist)
				    [invlist_len(invlist) - 1])
    {
	_append_range_to_invlist(invlist, start, end);
	return invlist;
    }

    /* Here, can't just append things, create and return a new inversion list
     * which is the union of this range and the existing inversion list */
    range_invlist = _new_invlist(2);
    _append_range_to_invlist(range_invlist, start, end);

    _invlist_union(invlist, range_invlist, &invlist);

    /* The temporary can be freed */
    SvREFCNT_dec(range_invlist);

    return invlist;
}

#endif

PERL_STATIC_INLINE SV*
S_add_cp_to_invlist(pTHX_ SV* invlist, const UV cp) {
    return _add_range_to_invlist(invlist, cp, cp);
}

#ifndef PERL_IN_XSUB_RE
void
Perl__invlist_invert(pTHX_ SV* const invlist)
{
    /* Complement the input inversion list.  This adds a 0 if the list didn't
     * have a zero; removes it otherwise.  As described above, the data
     * structure is set up so that this is very efficient */

    UV* len_pos = get_invlist_len_addr(invlist);

    PERL_ARGS_ASSERT__INVLIST_INVERT;

    /* The inverse of matching nothing is matching everything */
    if (*len_pos == 0) {
	_append_range_to_invlist(invlist, 0, UV_MAX);
	return;
    }

    /* The exclusive or complents 0 to 1; and 1 to 0.  If the result is 1, the
     * zero element was a 0, so it is being removed, so the length decrements
     * by 1; and vice-versa.  SvCUR is unaffected */
    if (*get_invlist_zero_addr(invlist) ^= 1) {
	(*len_pos)--;
    }
    else {
	(*len_pos)++;
    }
}

void
Perl__invlist_invert_prop(pTHX_ SV* const invlist)
{
    /* Complement the input inversion list (which must be a Unicode property,
     * all of which don't match above the Unicode maximum code point.)  And
     * Perl has chosen to not have the inversion match above that either.  This
     * adds a 0x110000 if the list didn't end with it, and removes it if it did
     */

    UV len;
    UV* array;

    PERL_ARGS_ASSERT__INVLIST_INVERT_PROP;

    _invlist_invert(invlist);

    len = invlist_len(invlist);

    if (len != 0) { /* If empty do nothing */
	array = invlist_array(invlist);
	if (array[len - 1] != PERL_UNICODE_MAX + 1) {
	    /* Add 0x110000.  First, grow if necessary */
	    len++;
	    if (invlist_max(invlist) < len) {
		invlist_extend(invlist, len);
		array = invlist_array(invlist);
	    }
	    invlist_set_len(invlist, len);
	    array[len - 1] = PERL_UNICODE_MAX + 1;
	}
	else {  /* Remove the 0x110000 */
	    invlist_set_len(invlist, len - 1);
	}
    }

    return;
}
#endif

PERL_STATIC_INLINE SV*
S_invlist_clone(pTHX_ SV* const invlist)
{

    /* Return a new inversion list that is a copy of the input one, which is
     * unchanged */

    /* Need to allocate extra space to accommodate Perl's addition of a
     * trailing NUL to SvPV's, since it thinks they are always strings */
    SV* new_invlist = _new_invlist(invlist_len(invlist) + 1);
    STRLEN length = SvCUR(invlist);

    PERL_ARGS_ASSERT_INVLIST_CLONE;

    SvCUR_set(new_invlist, length); /* This isn't done automatically */
    Copy(SvPVX(invlist), SvPVX(new_invlist), length, char);

    return new_invlist;
}

PERL_STATIC_INLINE UV*
S_get_invlist_iter_addr(pTHX_ SV* invlist)
{
    /* Return the address of the UV that contains the current iteration
     * position */

    PERL_ARGS_ASSERT_GET_INVLIST_ITER_ADDR;

    return (UV *) (SvPVX(invlist) + (INVLIST_ITER_OFFSET * sizeof (UV)));
}

PERL_STATIC_INLINE UV*
S_get_invlist_version_id_addr(pTHX_ SV* invlist)
{
    /* Return the address of the UV that contains the version id. */

    PERL_ARGS_ASSERT_GET_INVLIST_VERSION_ID_ADDR;

    return (UV *) (SvPVX(invlist) + (INVLIST_VERSION_ID_OFFSET * sizeof (UV)));
}

PERL_STATIC_INLINE void
S_invlist_iterinit(pTHX_ SV* invlist)	/* Initialize iterator for invlist */
{
    PERL_ARGS_ASSERT_INVLIST_ITERINIT;

    *get_invlist_iter_addr(invlist) = 0;
}

STATIC bool
S_invlist_iternext(pTHX_ SV* invlist, UV* start, UV* end)
{
    /* An C<invlist_iterinit> call on <invlist> must be used to set this up.
     * This call sets in <*start> and <*end>, the next range in <invlist>.
     * Returns <TRUE> if successful and the next call will return the next
     * range; <FALSE> if was already at the end of the list.  If the latter,
     * <*start> and <*end> are unchanged, and the next call to this function
     * will start over at the beginning of the list */

    UV* pos = get_invlist_iter_addr(invlist);
    UV len = invlist_len(invlist);
    UV *array;

    PERL_ARGS_ASSERT_INVLIST_ITERNEXT;

    if (*pos >= len) {
	*pos = UV_MAX;	/* Force iternit() to be required next time */
	return FALSE;
    }

    array = invlist_array(invlist);

    *start = array[(*pos)++];

    if (*pos >= len) {
	*end = UV_MAX;
    }
    else {
	*end = array[(*pos)++] - 1;
    }

    return TRUE;
}

#ifndef PERL_IN_XSUB_RE
SV *
Perl__invlist_contents(pTHX_ SV* const invlist)
{
    /* Get the contents of an inversion list into a string SV so that they can
     * be printed out.  It uses the format traditionally done for debug tracing
     */

    UV start, end;
    SV* output = newSVpvs("\n");

    PERL_ARGS_ASSERT__INVLIST_CONTENTS;

    invlist_iterinit(invlist);
    while (invlist_iternext(invlist, &start, &end)) {
	if (end == UV_MAX) {
	    Perl_sv_catpvf(aTHX_ output, "%04"UVXf"\tINFINITY\n", start);
	}
	else if (end != start) {
	    Perl_sv_catpvf(aTHX_ output, "%04"UVXf"\t%04"UVXf"\n",
		    start,       end);
	}
	else {
	    Perl_sv_catpvf(aTHX_ output, "%04"UVXf"\n", start);
	}
    }

    return output;
}
#endif

#if 0
void
S_invlist_dump(pTHX_ SV* const invlist, const char * const header)
{
    /* Dumps out the ranges in an inversion list.  The string 'header'
     * if present is output on a line before the first range */

    UV start, end;

    if (header && strlen(header)) {
	PerlIO_printf(Perl_debug_log, "%s\n", header);
    }
    invlist_iterinit(invlist);
    while (invlist_iternext(invlist, &start, &end)) {
	if (end == UV_MAX) {
	    PerlIO_printf(Perl_debug_log, "0x%04"UVXf" .. INFINITY\n", start);
	}
	else {
	    PerlIO_printf(Perl_debug_log, "0x%04"UVXf" .. 0x%04"UVXf"\n", start, end);
	}
    }
}
#endif

#undef HEADER_LENGTH
#undef INVLIST_INITIAL_LENGTH
#undef TO_INTERNAL_SIZE
#undef FROM_INTERNAL_SIZE
#undef INVLIST_LEN_OFFSET
#undef INVLIST_ZERO_OFFSET
#undef INVLIST_ITER_OFFSET
#undef INVLIST_VERSION_ID

/* End of inversion list object */

/*
 - reg - regular expression, i.e. main body or parenthesized thing
 *
 * Caller must absorb opening parenthesis.
 *
 * Combining parenthesis handling with the base level of regular expression
 * is a trifle forced, but the need to tie the tails of the branches to what
 * follows makes it hard to avoid.
 */
#define REGTAIL(x,y,z) regtail((x),(y),(z),depth+1)
#ifdef DEBUGGING
#define REGTAIL_STUDY(x,y,z) regtail_study((x),(y),(z),depth+1)
#else
#define REGTAIL_STUDY(x,y,z) regtail((x),(y),(z),depth+1)
#endif

STATIC regnode *
S_reg(pTHX_ RExC_state_t *pRExC_state, I32 paren, I32 *flagp,U32 depth)
    /* paren: Parenthesized? 0=top, 1=(, inside: changed to letter. */
{
    dVAR;
    register regnode *ret;		/* Will be the head of the group. */
    register regnode *br;
    register regnode *lastbr;
    register regnode *ender = NULL;
    register I32 parno = 0;
    I32 flags;
    U32 oregflags = RExC_flags;
    bool have_branch = 0;
    bool is_open = 0;
    I32 freeze_paren = 0;
    I32 after_freeze = 0;

    /* for (?g), (?gc), and (?o) warnings; warning
       about (?c) will warn about (?g) -- japhy    */

#define WASTED_O  0x01
#define WASTED_G  0x02
#define WASTED_C  0x04
#define WASTED_GC (0x02|0x04)
    I32 wastedflags = 0x00;

    char * parse_start = RExC_parse; /* MJD */
    char * const oregcomp_parse = RExC_parse;

    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_REG;
    DEBUG_PARSE("reg ");

    *flagp = 0;				/* Tentatively. */


    /* Make an OPEN node, if parenthesized. */
    if (paren) {
        if ( *RExC_parse == '*') { /* (*VERB:ARG) */
	    char *start_verb = RExC_parse;
	    STRLEN verb_len = 0;
	    char *start_arg = NULL;
	    unsigned char op = 0;
	    int argok = 1;
	    int internal_argval = 0; /* internal_argval is only useful if !argok */
	    while ( *RExC_parse && *RExC_parse != ')' ) {
	        if ( *RExC_parse == ':' ) {
	            start_arg = RExC_parse + 1;
	            break;
	        }
	        RExC_parse++;
	    }
	    ++start_verb;
	    verb_len = RExC_parse - start_verb;
	    if ( start_arg ) {
	        RExC_parse++;
	        while ( *RExC_parse && *RExC_parse != ')' ) 
	            RExC_parse++;
	        if ( *RExC_parse != ')' ) 
	            vFAIL("Unterminated verb pattern argument");
a5590 1
            bool has_use_defaults = FALSE;
d5620 3
a5622 11
		    ret = reganode(pRExC_state,
				   ((! FOLD)
				     ? NREF
				     : (MORE_ASCII_RESTRICTED)
				       ? NREFFA
                                       : (AT_LEAST_UNI_SEMANTICS)
                                         ? NREFFU
                                         : (LOC)
                                           ? NREFFL
                                           : NREFF),
				    num);
d5660 1
a5660 1
                        if (!svname) /* shouldn't happen */
a5705 1
			/* Yes this does cause a memory leak in debugging Perls */
a5716 1
		RExC_in_lookbehind++;
d5720 1
a5720 1
                break;
d5796 1
a5796 1

d5802 1
a5802 1
                    Bottom line is the negative indexing as from
d5873 1
a5873 1
		    RExC_parse = s;
d5883 1
a5883 1
		    rop = Perl_sv_compile_2op_is_broken(aTHX_ sv, &sop, "re", &pad);
d5931 1
a5931 1

a6044 8
            case DEFAULT_PAT_MOD:   /* Use default flags with the exceptions
				       that follow */
                has_use_defaults = TRUE;
                STD_PMMOD_FLAGS_CLEAR(&RExC_flags);
		set_regex_charset(&RExC_flags, (RExC_utf8 || RExC_uni_semantics)
						? REGEX_UNICODE_CHARSET
						: REGEX_DEPENDS_CHARSET);
                goto parse_flags;
a6050 7
                char has_charset_modifier = '\0';
		regex_charset cs = get_regex_charset(RExC_flags);
		if (cs == REGEX_DEPENDS_CHARSET
		    && (RExC_utf8 || RExC_uni_semantics))
		{
		    cs = REGEX_UNICODE_CHARSET;
		}
a6057 73
                    case LOCALE_PAT_MOD:
                        if (has_charset_modifier) {
			    goto excess_modifier;
			}
			else if (flagsp == &negflags) {
                            goto neg_modifier;
                        }
			cs = REGEX_LOCALE_CHARSET;
                        has_charset_modifier = LOCALE_PAT_MOD;
			RExC_contains_locale = 1;
                        break;
                    case UNICODE_PAT_MOD:
                        if (has_charset_modifier) {
			    goto excess_modifier;
			}
			else if (flagsp == &negflags) {
                            goto neg_modifier;
                        }
			cs = REGEX_UNICODE_CHARSET;
                        has_charset_modifier = UNICODE_PAT_MOD;
                        break;
                    case ASCII_RESTRICT_PAT_MOD:
                        if (flagsp == &negflags) {
                            goto neg_modifier;
                        }
                        if (has_charset_modifier) {
                            if (cs != REGEX_ASCII_RESTRICTED_CHARSET) {
                                goto excess_modifier;
                            }
			    /* Doubled modifier implies more restricted */
                            cs = REGEX_ASCII_MORE_RESTRICTED_CHARSET;
                        }
			else {
			    cs = REGEX_ASCII_RESTRICTED_CHARSET;
			}
                        has_charset_modifier = ASCII_RESTRICT_PAT_MOD;
                        break;
                    case DEPENDS_PAT_MOD:
                        if (has_use_defaults) {
                            goto fail_modifiers;
			}
			else if (flagsp == &negflags) {
                            goto neg_modifier;
			}
			else if (has_charset_modifier) {
			    goto excess_modifier;
                        }

			/* The dual charset means unicode semantics if the
			 * pattern (or target, not known until runtime) are
			 * utf8, or something in the pattern indicates unicode
			 * semantics */
			cs = (RExC_utf8 || RExC_uni_semantics)
			     ? REGEX_UNICODE_CHARSET
			     : REGEX_DEPENDS_CHARSET;
                        has_charset_modifier = DEPENDS_PAT_MOD;
                        break;
		    excess_modifier:
			RExC_parse++;
			if (has_charset_modifier == ASCII_RESTRICT_PAT_MOD) {
			    vFAIL2("Regexp modifier \"%c\" may appear a maximum of twice", ASCII_RESTRICT_PAT_MOD);
			}
			else if (has_charset_modifier == *(RExC_parse - 1)) {
			    vFAIL2("Regexp modifier \"%c\" may not appear twice", *(RExC_parse - 1));
			}
			else {
			    vFAIL3("Regexp modifiers \"%c\" and \"%c\" are mutually exclusive", has_charset_modifier, *(RExC_parse - 1));
			}
			/*NOTREACHED*/
		    neg_modifier:
			RExC_parse++;
			vFAIL2("Regexp modifier \"%c\" may not appear after the \"-\"", *(RExC_parse - 1));
			/*NOTREACHED*/
d6098 1
a6098 5
                        /* A flag is a default iff it is following a minus, so
                         * if there is a minus, it means will be trying to
                         * re-specify a default which is an error */
                        if (has_use_defaults || flagsp == &negflags) {
            fail_modifiers:
a6111 1
			set_regex_charset(&RExC_flags, cs);
a6114 1
			    set_regex_charset(&oregflags, cs);
d6165 6
d6310 1
a6310 5

    if (RExC_in_lookbehind) {
	RExC_in_lookbehind--;
    }
    if (after_freeze > RExC_npar)
d6344 1
a6344 1

a6403 1
#ifdef RE_TRACK_PATTERN_OFFSETS
a6404 1
#endif
a6422 1
#ifdef RE_TRACK_PATTERN_OFFSETS
a6423 1
#endif
a6518 1
#ifdef RE_TRACK_PATTERN_OFFSETS
a6519 1
#endif
d6583 1
a6583 1
/* reg_namedseq(pRExC_state,UVp, UV depth)
d6626 1
a6626 1
S_reg_namedseq(pTHX_ RExC_state_t *pRExC_state, UV *valuep, I32 *flagp, U32 depth)
d6630 3
d6701 1
a6701 1
    REQUIRE_UTF8;	/* named sequences imply Unicode semantics */
d6745 2
a6746 12

	/* What is done here is to convert this to a sub-pattern of the form
	 * (?:\x{char1}\x{char2}...)
	 * and then call reg recursively.  That way, it retains its atomicness,
	 * while not having to worry about special handling that some code
	 * points may have.  toke.c has converted the original Unicode values
	 * to native, so that we can just pass on the hex values unchanged.  We
	 * do have to set a flag to keep recoding from happening in the
	 * recursion */

	SV * substitute_parse = newSVpvn_flags("?:", 2, SVf_UTF8|SVs_TEMP);
	STRLEN len;
a6748 1
	char *orig_end = RExC_end;
d6750 18
a6767 1
	while (RExC_parse < endbrace) {
d6773 52
a6824 4
	    /* Convert to notation the rest of the code understands */
	    sv_catpv(substitute_parse, "\\x{");
	    sv_catpvn(substitute_parse, RExC_parse, endchar - RExC_parse);
	    sv_catpv(substitute_parse, "}");
d6828 3
a6831 1
	sv_catpv(substitute_parse, ")");
a6832 1
	RExC_parse = SvPV(substitute_parse, len);
d6834 10
a6843 3
	/* Don't allow empty number */
	if (len < 8) {
	    vFAIL("Invalid hexadecimal number in \\N{U+...}");
a6844 1
	RExC_end = RExC_parse + len;
d6846 1
a6846 8
	/* The values are Unicode, and therefore not subject to recoding */
	RExC_override_recoding = 1;

	ret = reg(pRExC_state, 1, flagp, depth+1);

	RExC_parse = endbrace;
	RExC_end = orig_end;
	RExC_override_recoding = 0;
d6848 4
d6909 1
a6909 1
   on context. Specifically there are two separate switches for handling
a6921 1
    U8 op;
d7013 17
d7044 4
d7089 1
a7089 18
	    switch (get_regex_charset(RExC_flags)) {
		case REGEX_LOCALE_CHARSET:
		    op = ALNUML;
		    break;
		case REGEX_UNICODE_CHARSET:
		    op = ALNUMU;
		    break;
		case REGEX_ASCII_RESTRICTED_CHARSET:
		case REGEX_ASCII_MORE_RESTRICTED_CHARSET:
		    op = ALNUMA;
		    break;
		case REGEX_DEPENDS_CHARSET:
		    op = ALNUM;
		    break;
		default:
		    goto bad_charset;
            }
	    ret = reg_node(pRExC_state, op);
d7093 1
a7093 18
	    switch (get_regex_charset(RExC_flags)) {
		case REGEX_LOCALE_CHARSET:
		    op = NALNUML;
		    break;
		case REGEX_UNICODE_CHARSET:
		    op = NALNUMU;
		    break;
		case REGEX_ASCII_RESTRICTED_CHARSET:
		case REGEX_ASCII_MORE_RESTRICTED_CHARSET:
		    op = NALNUMA;
		    break;
		case REGEX_DEPENDS_CHARSET:
		    op = NALNUM;
		    break;
		default:
		    goto bad_charset;
            }
	    ret = reg_node(pRExC_state, op);
d7099 1
a7099 19
	    switch (get_regex_charset(RExC_flags)) {
		case REGEX_LOCALE_CHARSET:
		    op = BOUNDL;
		    break;
		case REGEX_UNICODE_CHARSET:
		    op = BOUNDU;
		    break;
		case REGEX_ASCII_RESTRICTED_CHARSET:
		case REGEX_ASCII_MORE_RESTRICTED_CHARSET:
		    op = BOUNDA;
		    break;
		case REGEX_DEPENDS_CHARSET:
		    op = BOUND;
		    break;
		default:
		    goto bad_charset;
            }
	    ret = reg_node(pRExC_state, op);
	    FLAGS(ret) = get_regex_charset(RExC_flags);
a7100 3
	    if (! SIZE_ONLY && (U8) *(RExC_parse + 1) == '{') {
		ckWARNregdep(RExC_parse, "\"\\b{\" is deprecated; use \"\\b\\{\" instead");
	    }
d7105 1
a7105 19
	    switch (get_regex_charset(RExC_flags)) {
		case REGEX_LOCALE_CHARSET:
		    op = NBOUNDL;
		    break;
		case REGEX_UNICODE_CHARSET:
		    op = NBOUNDU;
		    break;
		case REGEX_ASCII_RESTRICTED_CHARSET:
		case REGEX_ASCII_MORE_RESTRICTED_CHARSET:
		    op = NBOUNDA;
		    break;
		case REGEX_DEPENDS_CHARSET:
		    op = NBOUND;
		    break;
		default:
		    goto bad_charset;
            }
	    ret = reg_node(pRExC_state, op);
	    FLAGS(ret) = get_regex_charset(RExC_flags);
a7106 3
	    if (! SIZE_ONLY && (U8) *(RExC_parse + 1) == '{') {
		ckWARNregdep(RExC_parse, "\"\\B{\" is deprecated; use \"\\B\\{\" instead");
	    }
d7109 1
a7109 18
	    switch (get_regex_charset(RExC_flags)) {
		case REGEX_LOCALE_CHARSET:
		    op = SPACEL;
		    break;
		case REGEX_UNICODE_CHARSET:
		    op = SPACEU;
		    break;
		case REGEX_ASCII_RESTRICTED_CHARSET:
		case REGEX_ASCII_MORE_RESTRICTED_CHARSET:
		    op = SPACEA;
		    break;
		case REGEX_DEPENDS_CHARSET:
		    op = SPACE;
		    break;
		default:
		    goto bad_charset;
            }
	    ret = reg_node(pRExC_state, op);
d7113 1
a7113 18
	    switch (get_regex_charset(RExC_flags)) {
		case REGEX_LOCALE_CHARSET:
		    op = NSPACEL;
		    break;
		case REGEX_UNICODE_CHARSET:
		    op = NSPACEU;
		    break;
		case REGEX_ASCII_RESTRICTED_CHARSET:
		case REGEX_ASCII_MORE_RESTRICTED_CHARSET:
		    op = NSPACEA;
		    break;
		case REGEX_DEPENDS_CHARSET:
		    op = NSPACE;
		    break;
		default:
		    goto bad_charset;
            }
	    ret = reg_node(pRExC_state, op);
d7117 1
a7117 16
	    switch (get_regex_charset(RExC_flags)) {
		case REGEX_LOCALE_CHARSET:
		    op = DIGITL;
		    break;
		case REGEX_ASCII_RESTRICTED_CHARSET:
		case REGEX_ASCII_MORE_RESTRICTED_CHARSET:
		    op = DIGITA;
		    break;
		case REGEX_DEPENDS_CHARSET: /* No difference between these */
		case REGEX_UNICODE_CHARSET:
		    op = DIGIT;
		    break;
		default:
		    goto bad_charset;
            }
	    ret = reg_node(pRExC_state, op);
d7121 1
a7121 16
	    switch (get_regex_charset(RExC_flags)) {
		case REGEX_LOCALE_CHARSET:
		    op = NDIGITL;
		    break;
		case REGEX_ASCII_RESTRICTED_CHARSET:
		case REGEX_ASCII_MORE_RESTRICTED_CHARSET:
		    op = NDIGITA;
		    break;
		case REGEX_DEPENDS_CHARSET: /* No difference between these */
		case REGEX_UNICODE_CHARSET:
		    op = NDIGIT;
		    break;
		default:
		    goto bad_charset;
            }
	    ret = reg_node(pRExC_state, op);
d7149 1
a7149 1
	    {
d7190 1
a7190 1
            ret= reg_namedseq(pRExC_state, NULL, flagp, depth);
d7218 2
a7219 10
                               ((! FOLD)
                                 ? NREF
				 : (MORE_ASCII_RESTRICTED)
				   ? NREFFA
                                   : (AT_LEAST_UNI_SEMANTICS)
                                     ? NREFFU
                                     : (LOC)
                                       ? NREFFL
                                       : NREFF),
                                num);
d7280 2
a7281 10
				   ((! FOLD)
				     ? REF
				     : (MORE_ASCII_RESTRICTED)
				       ? REFFA
                                       : (AT_LEAST_UNI_SEMANTICS)
                                         ? REFFU
                                         : (LOC)
                                           ? REFFL
                                           : REFF),
				    num);
d7312 1
a7312 6

            parse_start = RExC_parse - 1;

	    RExC_parse++;

	defchar: {
a7318 1
            U8 node_type;
d7320 3
a7322 3
	    /* Is this a LATIN LOWER CASE SHARP S in an EXACTFU node?  If so,
	     * it is folded to 'ss' even if not utf8 */
	    bool is_exactfu_sharp_s;
d7324 1
d7326 2
a7327 9
            node_type = ((! FOLD) ? EXACT
		        : (LOC)
			  ? EXACTFL
			  : (MORE_ASCII_RESTRICTED)
			    ? EXACTFA
			    : (AT_LEAST_UNI_SEMANTICS)
			      ? EXACTFU
			      : EXACTF);
	    ret = reg_node(pRExC_state, node_type);
a7328 19

	    /* XXX The node can hold up to 255 bytes, yet this only goes to
             * 127.  I (khw) do not know why.  Keeping it somewhat less than
             * 255 allows us to not have to worry about overflow due to
             * converting to utf8 and fold expansion, but that value is
             * 255-UTF8_MAXBYTES_CASE.  join_exact() may join adjacent nodes
             * split up by this limit into a single one using the real max of
             * 255.  Even at 127, this breaks under rare circumstances.  If
             * folding, we do not want to split a node at a character that is a
             * non-final in a multi-char fold, as an input string could just
             * happen to want to match across the node boundary.  The join
             * would solve that problem if the join actually happens.  But a
             * series of more than two nodes in a row each of 127 would cause
             * the first join to succeed to get to 254, but then there wouldn't
             * be room for the next one, which could at be one of those split
             * multi-char folds.  I don't know of any fool-proof solution.  One
             * could back off to end with only a code point that isn't such a
             * non-final, but it is possible for there not to be any in the
             * entire node. */
d7330 2
a7331 2
	         len < 127 && p < RExC_end;
	         len++)
d7338 5
d7367 5
a7416 29
		    case 'o':
			{
			    STRLEN brace_len = len;
			    UV result;
			    const char* error_msg;

			    bool valid = grok_bslash_o(p,
						       &result,
						       &brace_len,
						       &error_msg,
						       1);
			    p += brace_len;
			    if (! valid) {
				RExC_parse = p;	/* going to die anyway; point
						   to exact spot of failure */
				vFAIL(error_msg);
			    }
			    else
			    {
				ender = result;
			    }
			    if (PL_encoding && ender < 0x100) {
				goto recode_encoding;
			    }
			    if (ender > 0xff) {
				REQUIRE_UTF8;
			    }
			    break;
			}
d7420 1
a7420 1

d7431 1
a7431 1
				    REQUIRE_UTF8;
d7446 2
a7447 1
			ender = grok_bslash_c(*p++, UTF, SIZE_ONLY);
d7452 2
a7453 3
			    (isDIGIT(p[1]) && atoi(p) >= RExC_npar))
			{
			    I32 flags = PERL_SCAN_SILENT_ILLDIGIT;
d7456 11
a7466 2
			    if (ender > 0xff) {
				REQUIRE_UTF8;
d7478 1
a7478 1
			if (! RExC_override_recoding) {
d7483 1
a7483 1
			    REQUIRE_UTF8;
d7491 2
a7492 7
			if (!SIZE_ONLY&& isALPHA(*p)) {
			    /* Include any { following the alpha to emphasize
			     * that it could be part of an escape at some point
			     * in the future */
			    int len = (*(p + 1) == '{') ? 2 : 1;
			    ckWARN3reg(p + len, "Unrecognized escape \\%.*s passed through", len, p);
			}
d7505 1
a7505 1
			ender = (U8) *p++;
d7507 1
a7507 4
		} /* End of switch on the literal */

                is_exactfu_sharp_s = (node_type == EXACTFU
			              && ender == LATIN_SMALL_LETTER_SHARP_S);
d7510 3
a7512 60
		if ((UTF && FOLD) || is_exactfu_sharp_s) {
		    /* Prime the casefolded buffer.  Locale rules, which apply
		     * only to code points < 256, aren't known until execution,
		     * so for them, just output the original character using
                     * utf8.  If we start to fold non-UTF patterns, be sure to
                     * update join_exact() */
		    if (LOC && ender < 256) {
			if (UNI_IS_INVARIANT(ender)) {
			    *tmpbuf = (U8) ender;
			    foldlen = 1;
			} else {
			    *tmpbuf = UTF8_TWO_BYTE_HI(ender);
			    *(tmpbuf + 1) = UTF8_TWO_BYTE_LO(ender);
			    foldlen = 2;
			}
		    }
		    else if (isASCII(ender)) {	/* Note: Here can't also be LOC
						 */
			ender = toLOWER(ender);
			*tmpbuf = (U8) ender;
			foldlen = 1;
		    }
		    else if (! MORE_ASCII_RESTRICTED && ! LOC) {

			/* Locale and /aa require more selectivity about the
			 * fold, so are handled below.  Otherwise, here, just
			 * use the fold */
			ender = toFOLD_uni(ender, tmpbuf, &foldlen);
		    }
		    else {
			/* Under locale rules or /aa we are not to mix,
			 * respectively, ords < 256 or ASCII with non-.  So
			 * reject folds that mix them, using only the
			 * non-folded code point.  So do the fold to a
			 * temporary, and inspect each character in it. */
			U8 trialbuf[UTF8_MAXBYTES_CASE+1];
			U8* s = trialbuf;
			UV tmpender = toFOLD_uni(ender, trialbuf, &foldlen);
			U8* e = s + foldlen;
			bool fold_ok = TRUE;

			while (s < e) {
			    if (isASCII(*s)
				|| (LOC && (UTF8_IS_INVARIANT(*s)
					   || UTF8_IS_DOWNGRADEABLE_START(*s))))
			    {
				fold_ok = FALSE;
				break;
			    }
			    s += UTF8SKIP(s);
			}
			if (fold_ok) {
			    Copy(trialbuf, tmpbuf, foldlen, U8);
			    ender = tmpender;
			}
			else {
			    uvuni_to_utf8(tmpbuf, ender);
			    foldlen = UNISKIP(ender);
			}
		    }
d7517 1
a7517 1
		    else if (UTF || is_exactfu_sharp_s) {
d7524 1
a7524 4

				   /* tmpbuf has been constructed by us, so we
				    * know it is valid utf8 */
				   ender = valid_utf8_to_uvchr(foldbuf, &numlen);
d7553 1
a7553 1
                if (UTF || is_exactfu_sharp_s) {
d7560 1
a7560 1
			       ender = valid_utf8_to_uvchr(foldbuf, &numlen);
d7584 1
a7584 1
		else {
a7585 1
		}
d7587 1
a7587 2
	loopdone:   /* Jumped to when encounters something that shouldn't be in
		       the node */
d7601 1
a7601 1

a7612 5

/* Jumped to when an unrecognized character set is encountered */
bad_charset:
    Perl_croak(aTHX_ "panic: Unknown regex character set encoding: %u", get_regex_charset(RExC_flags));
    return(NULL);
d7665 1
a7665 1

a7799 38
/* Generate the code to add a full posix character <class> to the bracketed
 * character class given by <node>.  (<node> is needed only under locale rules)
 * destlist     is the inversion list for non-locale rules that this class is
 *              to be added to
 * sourcelist   is the ASCII-range inversion list to add under /a rules
 * Xsourcelist  is the full Unicode range list to use otherwise. */
#define DO_POSIX(node, class, destlist, sourcelist, Xsourcelist)           \
    if (LOC) {                                                             \
	SV* scratch_list = NULL;                                           \
                                                                           \
        /* Set this class in the node for runtime matching */              \
        ANYOF_CLASS_SET(node, class);                                      \
                                                                           \
        /* For above Latin1 code points, we use the full Unicode range */  \
        _invlist_intersection(PL_AboveLatin1,                              \
                              Xsourcelist,                                 \
                              &scratch_list);                              \
        /* And set the output to it, adding instead if there already is an \
	 * output.  Checking if <destlist> is NULL first saves an extra    \
	 * clone.  Its reference count will be decremented at the next     \
	 * union, etc, or if this is the only instance, at the end of the  \
	 * routine */                                                      \
        if (! destlist) {                                                  \
            destlist = scratch_list;                                       \
        }                                                                  \
        else {                                                             \
            _invlist_union(destlist, scratch_list, &destlist);             \
            SvREFCNT_dec(scratch_list);                                    \
        }                                                                  \
    }                                                                      \
    else {                                                                 \
        /* For non-locale, just add it to any existing list */             \
        _invlist_union(destlist,                                           \
                       (AT_LEAST_ASCII_RESTRICTED)                         \
                           ? sourcelist                                    \
                           : Xsourcelist,                                  \
                       &destlist);                                         \
    }
d7801 23
a7823 87
/* Like DO_POSIX, but matches the complement of <sourcelist> and <Xsourcelist>.
 */
#define DO_N_POSIX(node, class, destlist, sourcelist, Xsourcelist)         \
    if (LOC) {                                                             \
        SV* scratch_list = NULL;                                           \
        ANYOF_CLASS_SET(node, class);					   \
        _invlist_subtract(PL_AboveLatin1, Xsourcelist, &scratch_list);	   \
        if (! destlist) {					           \
            destlist = scratch_list;					   \
        }                                                                  \
        else {                                                             \
            _invlist_union(destlist, scratch_list, &destlist);             \
            SvREFCNT_dec(scratch_list);                                    \
        }                                                                  \
    }                                                                      \
    else {                                                                 \
        _invlist_union_complement_2nd(destlist,                            \
                                    (AT_LEAST_ASCII_RESTRICTED)            \
                                        ? sourcelist                       \
                                        : Xsourcelist,                     \
                                    &destlist);                            \
        /* Under /d, everything in the upper half of the Latin1 range      \
         * matches this complement */                                      \
        if (DEPENDS_SEMANTICS) {                                           \
            ANYOF_FLAGS(node) |= ANYOF_NON_UTF8_LATIN1_ALL;                \
        }                                                                  \
    }

/* Generate the code to add a posix character <class> to the bracketed
 * character class given by <node>.  (<node> is needed only under locale rules)
 * destlist       is the inversion list for non-locale rules that this class is
 *                to be added to
 * sourcelist     is the ASCII-range inversion list to add under /a rules
 * l1_sourcelist  is the Latin1 range list to use otherwise.
 * Xpropertyname  is the name to add to <run_time_list> of the property to
 *                specify the code points above Latin1 that will have to be
 *                determined at run-time
 * run_time_list  is a SV* that contains text names of properties that are to
 *                be computed at run time.  This concatenates <Xpropertyname>
 *                to it, apppropriately
 * This is essentially DO_POSIX, but we know only the Latin1 values at compile
 * time */
#define DO_POSIX_LATIN1_ONLY_KNOWN(node, class, destlist, sourcelist,      \
                              l1_sourcelist, Xpropertyname, run_time_list) \
    /* If not /a matching, there are going to be code points we will have  \
     * to defer to runtime to look-up */                                   \
    if (! AT_LEAST_ASCII_RESTRICTED) {                                     \
        Perl_sv_catpvf(aTHX_ run_time_list, "+utf8::%s\n", Xpropertyname); \
    }                                                                      \
    if (LOC) {                                                             \
        ANYOF_CLASS_SET(node, class);                                      \
    }                                                                      \
    else {                                                                 \
        _invlist_union(destlist,                                           \
                       (AT_LEAST_ASCII_RESTRICTED)                         \
                           ? sourcelist                                    \
                           : l1_sourcelist,                                \
                       &destlist);                                         \
    }

/* Like DO_POSIX_LATIN1_ONLY_KNOWN, but for the complement.  A combination of
 * this and DO_N_POSIX */
#define DO_N_POSIX_LATIN1_ONLY_KNOWN(node, class, destlist, sourcelist,    \
                              l1_sourcelist, Xpropertyname, run_time_list) \
    if (AT_LEAST_ASCII_RESTRICTED) {                                       \
        _invlist_union_complement_2nd(destlist, sourcelist, &destlist);    \
    }                                                                      \
    else {                                                                 \
        Perl_sv_catpvf(aTHX_ run_time_list, "!utf8::%s\n", Xpropertyname); \
	if (LOC) {                                                         \
	    ANYOF_CLASS_SET(node, namedclass);				   \
	}                                                                  \
	else {                                                             \
            SV* scratch_list = NULL;                                       \
	    _invlist_subtract(PL_Latin1, l1_sourcelist, &scratch_list);    \
	    if (! destlist) {                                              \
		destlist = scratch_list;                                   \
	    }                                                              \
	    else {                                                         \
		_invlist_union(destlist, scratch_list, &destlist);         \
		SvREFCNT_dec(scratch_list);                                \
	    }                                                              \
	    if (DEPENDS_SEMANTICS) {                                       \
		ANYOF_FLAGS(node) |= ANYOF_NON_UTF8_LATIN1_ALL;            \
	    }                                                              \
	}                                                                  \
    }
d7825 15
a7839 3
STATIC U8
S_set_regclass_bit_fold(pTHX_ RExC_state_t *pRExC_state, regnode* node, const U8 value, SV** invlist_ptr, AV** alternate_ptr)
{
d7841 9
a7849 131
    /* Handle the setting of folds in the bitmap for non-locale ANYOF nodes.
     * Locale folding is done at run-time, so this function should not be
     * called for nodes that are for locales.
     *
     * This function sets the bit corresponding to the fold of the input
     * 'value', if not already set.  The fold of 'f' is 'F', and the fold of
     * 'F' is 'f'.
     *
     * It also knows about the characters that are in the bitmap that have
     * folds that are matchable only outside it, and sets the appropriate lists
     * and flags.
     *
     * It returns the number of bits that actually changed from 0 to 1 */

    U8 stored = 0;
    U8 fold;

    PERL_ARGS_ASSERT_SET_REGCLASS_BIT_FOLD;

    fold = (AT_LEAST_UNI_SEMANTICS) ? PL_fold_latin1[value]
                                    : PL_fold[value];

    /* It assumes the bit for 'value' has already been set */
    if (fold != value && ! ANYOF_BITMAP_TEST(node, fold)) {
        ANYOF_BITMAP_SET(node, fold);
        stored++;
    }
    if (_HAS_NONLATIN1_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(value) && (! isASCII(value) || ! MORE_ASCII_RESTRICTED)) {
	/* Certain Latin1 characters have matches outside the bitmap.  To get
	 * here, 'value' is one of those characters.   None of these matches is
	 * valid for ASCII characters under /aa, which have been excluded by
	 * the 'if' above.  The matches fall into three categories:
	 * 1) They are singly folded-to or -from an above 255 character, as
	 *    LATIN SMALL LETTER Y WITH DIAERESIS and LATIN CAPITAL LETTER Y
	 *    WITH DIAERESIS;
	 * 2) They are part of a multi-char fold with another character in the
	 *    bitmap, only LATIN SMALL LETTER SHARP S => "ss" fits that bill;
	 * 3) They are part of a multi-char fold with a character not in the
	 *    bitmap, such as various ligatures.
	 * We aren't dealing fully with multi-char folds, except we do deal
	 * with the pattern containing a character that has a multi-char fold
	 * (not so much the inverse).
	 * For types 1) and 3), the matches only happen when the target string
	 * is utf8; that's not true for 2), and we set a flag for it.
	 *
	 * The code below adds to the passed in inversion list the single fold
	 * closures for 'value'.  The values are hard-coded here so that an
	 * innocent-looking character class, like /[ks]/i won't have to go out
	 * to disk to find the possible matches.  XXX It would be better to
	 * generate these via regen, in case a new version of the Unicode
	 * standard adds new mappings, though that is not really likely. */
	switch (value) {
	    case 'k':
	    case 'K':
		/* KELVIN SIGN */
		*invlist_ptr = add_cp_to_invlist(*invlist_ptr, 0x212A);
		break;
	    case 's':
	    case 'S':
		/* LATIN SMALL LETTER LONG S */
		*invlist_ptr = add_cp_to_invlist(*invlist_ptr, 0x017F);
		break;
	    case MICRO_SIGN:
		*invlist_ptr = add_cp_to_invlist(*invlist_ptr,
						 GREEK_SMALL_LETTER_MU);
		*invlist_ptr = add_cp_to_invlist(*invlist_ptr,
						 GREEK_CAPITAL_LETTER_MU);
		break;
	    case LATIN_CAPITAL_LETTER_A_WITH_RING_ABOVE:
	    case LATIN_SMALL_LETTER_A_WITH_RING_ABOVE:
		/* ANGSTROM SIGN */
		*invlist_ptr = add_cp_to_invlist(*invlist_ptr, 0x212B);
		if (DEPENDS_SEMANTICS) {    /* See DEPENDS comment below */
		    *invlist_ptr = add_cp_to_invlist(*invlist_ptr,
						     PL_fold_latin1[value]);
		}
		break;
	    case LATIN_SMALL_LETTER_Y_WITH_DIAERESIS:
		*invlist_ptr = add_cp_to_invlist(*invlist_ptr,
					LATIN_CAPITAL_LETTER_Y_WITH_DIAERESIS);
		break;
	    case LATIN_SMALL_LETTER_SHARP_S:
		*invlist_ptr = add_cp_to_invlist(*invlist_ptr,
					LATIN_CAPITAL_LETTER_SHARP_S);

		/* Under /a, /d, and /u, this can match the two chars "ss" */
		if (! MORE_ASCII_RESTRICTED) {
		    add_alternate(alternate_ptr, (U8 *) "ss", 2);

		    /* And under /u or /a, it can match even if the target is
		     * not utf8 */
		    if (AT_LEAST_UNI_SEMANTICS) {
			ANYOF_FLAGS(node) |= ANYOF_NONBITMAP_NON_UTF8;
		    }
		}
		break;
	    case 'F': case 'f':
	    case 'I': case 'i':
	    case 'L': case 'l':
	    case 'T': case 't':
	    case 'A': case 'a':
	    case 'H': case 'h':
	    case 'J': case 'j':
	    case 'N': case 'n':
	    case 'W': case 'w':
	    case 'Y': case 'y':
                /* These all are targets of multi-character folds from code
                 * points that require UTF8 to express, so they can't match
                 * unless the target string is in UTF-8, so no action here is
                 * necessary, as regexec.c properly handles the general case
                 * for UTF-8 matching */
		break;
	    default:
		/* Use deprecated warning to increase the chances of this
		 * being output */
		ckWARN2regdep(RExC_parse, "Perl folding rules are not up-to-date for 0x%x; please use the perlbug utility to report;", value);
		break;
	}
    }
    else if (DEPENDS_SEMANTICS
	    && ! isASCII(value)
	    && PL_fold_latin1[value] != value)
    {
	   /* Under DEPENDS rules, non-ASCII Latin1 characters match their
	    * folds only when the target string is in UTF-8.  We add the fold
	    * here to the list of things to match outside the bitmap, which
	    * won't be looked at unless it is UTF8 (or else if something else
	    * says to look even if not utf8, but those things better not happen
	    * under DEPENDS semantics. */
	*invlist_ptr = add_cp_to_invlist(*invlist_ptr, PL_fold_latin1[value]);
    }
d7851 5
a7855 46
    return stored;
}


PERL_STATIC_INLINE U8
S_set_regclass_bit(pTHX_ RExC_state_t *pRExC_state, regnode* node, const U8 value, SV** invlist_ptr, AV** alternate_ptr)
{
    /* This inline function sets a bit in the bitmap if not already set, and if
     * appropriate, its fold, returning the number of bits that actually
     * changed from 0 to 1 */

    U8 stored;

    PERL_ARGS_ASSERT_SET_REGCLASS_BIT;

    if (ANYOF_BITMAP_TEST(node, value)) {   /* Already set */
	return 0;
    }

    ANYOF_BITMAP_SET(node, value);
    stored = 1;

    if (FOLD && ! LOC) {	/* Locale folds aren't known until runtime */
	stored += set_regclass_bit_fold(pRExC_state, node, value, invlist_ptr, alternate_ptr);
    }

    return stored;
}

STATIC void
S_add_alternate(pTHX_ AV** alternate_ptr, U8* string, STRLEN len)
{
    /* Adds input 'string' with length 'len' to the ANYOF node's unicode
     * alternate list, pointed to by 'alternate_ptr'.  This is an array of
     * the multi-character folds of characters in the node */
    SV *sv;

    PERL_ARGS_ASSERT_ADD_ALTERNATE;

    if (! *alternate_ptr) {
	*alternate_ptr = newAV();
    }
    sv = newSVpvn_utf8((char*)string, len, TRUE);
    av_push(*alternate_ptr, sv);
    return;
}
d7859 4
a7862 4
   matches the pattern or perhaps will be optimized into an EXACTish node
   instead. The node contains a bit map for the first 256 characters, with the
   corresponding bit set if that character is in the list.  For characters
   above 255, a range list is used */
a7876 1
    bool allow_full_fold = TRUE;   /* Assume wants multi-char folding */
a7877 5
    STRLEN initial_listsv_len = 0; /* Kind of a kludge to see if it is more
				      than just initialized.  */
    SV* properties = NULL;    /* Code points that match \p{} \P{} */
    UV element_count = 0;   /* Number of distinct elements in the class.
			       Optimizations may be possible if this is tiny */
d7879 1
a7879 33

    /* Unicode properties are stored in a swash; this holds the current one
     * being parsed.  If this swash is the only above-latin1 component of the
     * character class, an optimization is to pass it directly on to the
     * execution engine.  Otherwise, it is set to NULL to indicate that there
     * are other things in the class that have to be dealt with at execution
     * time */
    SV* swash = NULL;		/* Code points that match \p{} \P{} */

    /* Set if a component of this character class is user-defined; just passed
     * on to the engine */
    UV has_user_defined_property = 0;

    /* code points this node matches that can't be stored in the bitmap */
    SV* nonbitmap = NULL;

    /* The items that are to match that aren't stored in the bitmap, but are a
     * result of things that are stored there.  This is the fold closure of
     * such a character, either because it has DEPENDS semantics and shouldn't
     * be matched unless the target string is utf8, or is a code point that is
     * too large for the bit map, as for example, the fold of the MICRO SIGN is
     * above 255.  This all is solely for performance reasons.  By having this
     * code know the outside-the-bitmap folds that the bitmapped characters are
     * involved with, we don't have to go out to disk to find the list of
     * matches, unless the character class includes code points that aren't
     * storable in the bit map.  That means that a character class with an 's'
     * in it, for example, doesn't need to go out to disk to find everything
     * that matches.  A 2nd list is used so that the 'nonbitmap' list is kept
     * empty unless there is something whose fold we don't know about, and will
     * have to go out to the disk to find. */
    SV* l1_fold_invlist = NULL;

    /* List of multi-character folds that are matched by this node */
d7884 1
a7884 1
    UV stored = 0;  /* how many chars stored in the bitmap */
d7901 1
a7901 2

    if (!SIZE_ONLY) {
a7902 1
    }
a7908 10

        /* We have decided to not allow multi-char folds in inverted character
	 * classes, due to the confusion that can happen, especially with
	 * classes that are designed for a non-Unicode world:  You have the
	 * peculiar case that:
            "s s" =~ /^[^\xDF]+$/i => Y
            "ss"  =~ /^[^\xDF]+$/i => N
         *
         * See [perl #89750] */
        allow_full_fold = FALSE;
d7917 3
a7919 1
	if (LOC) {
a7920 1
	}
a7922 1
	initial_listsv_len = SvCUR(listsv);
d7941 1
a7941 1
	if (!range) {
a7942 2
	    element_count++;
	}
d7988 1
a7988 1
                    if (reg_namedseq(pRExC_state, &v, NULL, depth)) {
a8017 3
                    SV** invlistsvp;
                    SV* invlist;
                    char* name;
d8027 2
a8028 80
                    /* Try to get the definition of the property into
                     * <invlist>.  If /i is in effect, the effective property
                     * will have its name be <__NAME_i>.  The design is
                     * discussed in commit
                     * 2f833f5208e26b208886e51e09e2c072b5eabb46 */
                    Newx(name, n + sizeof("_i__\n"), char);

                    sprintf(name, "%s%.*s%s\n",
                                    (FOLD) ? "__" : "",
                                    (int)n,
                                    RExC_parse,
                                    (FOLD) ? "_i" : ""
                    );

                    /* Look up the property name, and get its swash and
                     * inversion list, if the property is found  */
                    if (swash) {
                        SvREFCNT_dec(swash);
                    }
                    swash = _core_swash_init("utf8", name, &PL_sv_undef,
                                             1, /* binary */
                                             0, /* not tr/// */
                                             TRUE, /* this routine will handle
                                                      undefined properties */
                                             NULL, FALSE /* No inversion list */
                                            );
                    if (   ! swash
                        || ! SvROK(swash)
                        || ! SvTYPE(SvRV(swash)) == SVt_PVHV
                        || ! (invlistsvp =
				hv_fetchs(MUTABLE_HV(SvRV(swash)),
                                "INVLIST", FALSE))
                        || ! (invlist = *invlistsvp))
		    {
                        if (swash) {
                            SvREFCNT_dec(swash);
                            swash = NULL;
                        }

                        /* Here didn't find it.  It could be a user-defined
                         * property that will be available at run-time.  Add it
                         * to the list to look up then */
                        Perl_sv_catpvf(aTHX_ listsv, "%cutf8::%s\n",
                                        (value == 'p' ? '+' : '!'),
                                        name);
                        has_user_defined_property = 1;

                        /* We don't know yet, so have to assume that the
                         * property could match something in the Latin1 range,
                         * hence something that isn't utf8 */
                        ANYOF_FLAGS(ret) |= ANYOF_NONBITMAP_NON_UTF8;
                    }
                    else {

                        /* Here, did get the swash and its inversion list.  If
                         * the swash is from a user-defined property, then this
                         * whole character class should be regarded as such */
                        SV** user_defined_svp =
                                            hv_fetchs(MUTABLE_HV(SvRV(swash)),
                                                        "USER_DEFINED", FALSE);
                        if (user_defined_svp) {
                            has_user_defined_property
                                                    |= SvUV(*user_defined_svp);
                        }

                        /* Invert if asking for the complement */
                        if (value == 'P') {
			    _invlist_union_complement_2nd(properties, invlist, &properties);

                            /* The swash can't be used as-is, because we've
			     * inverted things; delay removing it to here after
			     * have copied its invlist above */
                            SvREFCNT_dec(swash);
                            swash = NULL;
                        }
                        else {
                            _invlist_union(properties, invlist, &properties);
			}
		    }
		    Safefree(name);
d8031 1
a8032 3

		/* \p means they want Unicode semantics */
		RExC_uni_semantics = 1;
a8041 18
	    case 'o':
		RExC_parse--;	/* function expects to be pointed at the 'o' */
		{
		    const char* error_msg;
		    bool valid = grok_bslash_o(RExC_parse,
					       &value,
					       &numlen,
					       &error_msg,
					       SIZE_ONLY);
		    RExC_parse += numlen;
		    if (! valid) {
			vFAIL(error_msg);
		    }
		}
		if (PL_encoding && value < 0x100) {
		    goto recode_encoding;
		}
		break;
d8064 2
a8065 1
		value = grok_bslash_c(*RExC_parse++, UTF, SIZE_ONLY);
d8068 1
a8068 1
	    case '5': case '6': case '7':
d8070 1
a8070 2
		    /* Take 1-3 octal digits */
		    I32 flags = PERL_SCAN_SILENT_ILLDIGIT;
d8079 1
a8079 1
		if (! RExC_override_recoding) {
d8088 1
a8088 2
		/* Allow \_ to not give an error */
		if (!SIZE_ONLY && isALNUM(value) && value != '_') {
a8091 1
		}
d8102 4
a8105 17
	    /* What matches in a locale is not known until runtime, so need to
	     * (one time per class) allocate extra space to pass to regexec.
	     * The space will contain a bit for each named class that is to be
	     * matched against.  This isn't needed for \p{} and pseudo-classes,
	     * as they are not affected by locale, and hence are dealt with
	     * separately */
	    if (LOC && namedclass < ANYOF_MAX && ! need_class) {
		need_class = 1;
		if (SIZE_ONLY) {
		    RExC_size += ANYOF_CLASS_SKIP - ANYOF_SKIP;
		}
		else {
		    RExC_emit += ANYOF_CLASS_SKIP - ANYOF_SKIP;
		    ANYOF_CLASS_ZERO(ret);
		}
		ANYOF_FLAGS(ret) |= ANYOF_CLASS;
	    }
d8107 1
a8107 3
	    /* a bad range like a-\d, a-[:digit:].  The '-' is taken as a
	     * literal, as is the character that began the false range, i.e.
	     * the 'a' in the examples */
a8116 2
		    stored +=
                         set_regclass_bit(pRExC_state, ret, '-', &l1_fold_invlist, &unicode_alternate);
d8118 2
a8119 132
			stored +=
                         set_regclass_bit(pRExC_state, ret, (U8) prevvalue, &l1_fold_invlist, &unicode_alternate);
		    }
		    else {
			nonbitmap = add_cp_to_invlist(nonbitmap, prevvalue);
		    }
		}

		range = 0; /* this was not a true range */
	    }

	    if (!SIZE_ONLY) {

		/* Possible truncation here but in some 64-bit environments
		 * the compiler gets heartburn about switch on 64-bit values.
		 * A similar issue a little earlier when switching on value.
		 * --jhi */
		switch ((I32)namedclass) {
		    int i;  /* loop counter */

		case ANYOF_ALNUMC: /* C's alnum, in contrast to \w */
		    DO_POSIX_LATIN1_ONLY_KNOWN(ret, namedclass, properties,
                        PL_PosixAlnum, PL_L1PosixAlnum, "XPosixAlnum", listsv);
		    break;
		case ANYOF_NALNUMC:
		    DO_N_POSIX_LATIN1_ONLY_KNOWN(ret, namedclass, properties,
                        PL_PosixAlnum, PL_L1PosixAlnum, "XPosixAlnum", listsv);
		    break;
		case ANYOF_ALPHA:
		    DO_POSIX_LATIN1_ONLY_KNOWN(ret, namedclass, properties,
                        PL_PosixAlpha, PL_L1PosixAlpha, "XPosixAlpha", listsv);
		    break;
		case ANYOF_NALPHA:
		    DO_N_POSIX_LATIN1_ONLY_KNOWN(ret, namedclass, properties,
                        PL_PosixAlpha, PL_L1PosixAlpha, "XPosixAlpha", listsv);
		    break;
		case ANYOF_ASCII:
		    if (LOC) {
			ANYOF_CLASS_SET(ret, namedclass);
		    }
                    else {
                        _invlist_union(properties, PL_ASCII, &properties);
                    }
		    break;
		case ANYOF_NASCII:
		    if (LOC) {
			ANYOF_CLASS_SET(ret, namedclass);
		    }
                    else {
                        _invlist_union_complement_2nd(properties,
                                                    PL_ASCII, &properties);
                        if (DEPENDS_SEMANTICS) {
                            ANYOF_FLAGS(ret) |= ANYOF_NON_UTF8_LATIN1_ALL;
                        }
                    }
		    break;
		case ANYOF_BLANK:
                    DO_POSIX(ret, namedclass, properties,
                                            PL_PosixBlank, PL_XPosixBlank);
		    break;
		case ANYOF_NBLANK:
                    DO_N_POSIX(ret, namedclass, properties,
                                            PL_PosixBlank, PL_XPosixBlank);
		    break;
		case ANYOF_CNTRL:
                    DO_POSIX(ret, namedclass, properties,
                                            PL_PosixCntrl, PL_XPosixCntrl);
		    break;
		case ANYOF_NCNTRL:
                    DO_N_POSIX(ret, namedclass, properties,
                                            PL_PosixCntrl, PL_XPosixCntrl);
		    break;
		case ANYOF_DIGIT:
		    /* Ignore the compiler warning for this macro, planned to
		     * be eliminated later */
		    DO_POSIX_LATIN1_ONLY_KNOWN(ret, namedclass, properties,
                        PL_PosixDigit, PL_PosixDigit, "XPosixDigit", listsv);
		    break;
		case ANYOF_NDIGIT:
		    DO_N_POSIX_LATIN1_ONLY_KNOWN(ret, namedclass, properties,
                        PL_PosixDigit, PL_PosixDigit, "XPosixDigit", listsv);
		    break;
		case ANYOF_GRAPH:
		    DO_POSIX_LATIN1_ONLY_KNOWN(ret, namedclass, properties,
                        PL_PosixGraph, PL_L1PosixGraph, "XPosixGraph", listsv);
		    break;
		case ANYOF_NGRAPH:
		    DO_N_POSIX_LATIN1_ONLY_KNOWN(ret, namedclass, properties,
                        PL_PosixGraph, PL_L1PosixGraph, "XPosixGraph", listsv);
		    break;
		case ANYOF_HORIZWS:
		    /* NBSP matches this, and needs to be added unconditionally
		     * to the bit map as it matches even under /d, unlike all
		     * the rest of the Posix-like classes (\v doesn't have any
		     * matches in the Latin1 range, so it is unaffected.) which
		     * Otherwise, we use the nonbitmap, as /d doesn't make a
		     * difference in what these match.  It turns out that \h is
		     * just a synonym for XPosixBlank */
		    _invlist_union(nonbitmap, PL_XPosixBlank, &nonbitmap);
		    stored += set_regclass_bit(pRExC_state, ret,
					       UNI_TO_NATIVE(0xA0),
					       &l1_fold_invlist,
					       &unicode_alternate);

		    break;
		case ANYOF_NHORIZWS:
                    _invlist_union_complement_2nd(nonbitmap,
                                                 PL_XPosixBlank, &nonbitmap);
		    for (i = 128; i < 256; i++) {
			if (i == 0xA0) {
			    continue;
			}
			stored += set_regclass_bit(pRExC_state, ret,
						   UNI_TO_NATIVE(i),
						   &l1_fold_invlist,
						   &unicode_alternate);
		    }
		    break;
		case ANYOF_LOWER:
		case ANYOF_NLOWER:
                {   /* These require special handling, as they differ under
		       folding, matching Cased there (which in the ASCII range
		       is the same as Alpha */

		    SV* ascii_source;
		    SV* l1_source;
		    const char *Xname;

		    if (FOLD && ! LOC) {
			ascii_source = PL_PosixAlpha;
			l1_source = PL_L1Cased;
			Xname = "Cased";
d8122 3
a8124 7
			ascii_source = PL_PosixLower;
			l1_source = PL_L1PosixLower;
			Xname = "XPosixLower";
		    }
		    if (namedclass == ANYOF_LOWER) {
			DO_POSIX_LATIN1_ONLY_KNOWN(ret, namedclass, properties,
                                    ascii_source, l1_source, Xname, listsv);
d8126 42
d8169 9
a8177 2
			DO_N_POSIX_LATIN1_ONLY_KNOWN(ret, namedclass,
                            properties, ascii_source, l1_source, Xname, listsv);
d8179 2
d8182 3
a8184 45
		}
		case ANYOF_PRINT:
		    DO_POSIX_LATIN1_ONLY_KNOWN(ret, namedclass, properties,
                        PL_PosixPrint, PL_L1PosixPrint, "XPosixPrint", listsv);
		    break;
		case ANYOF_NPRINT:
		    DO_N_POSIX_LATIN1_ONLY_KNOWN(ret, namedclass, properties,
                        PL_PosixPrint, PL_L1PosixPrint, "XPosixPrint", listsv);
		    break;
		case ANYOF_PUNCT:
		    DO_POSIX_LATIN1_ONLY_KNOWN(ret, namedclass, properties,
                        PL_PosixPunct, PL_L1PosixPunct, "XPosixPunct", listsv);
		    break;
		case ANYOF_NPUNCT:
		    DO_N_POSIX_LATIN1_ONLY_KNOWN(ret, namedclass, properties,
                        PL_PosixPunct, PL_L1PosixPunct, "XPosixPunct", listsv);
		    break;
		case ANYOF_PSXSPC:
                    DO_POSIX(ret, namedclass, properties,
                                            PL_PosixSpace, PL_XPosixSpace);
		    break;
		case ANYOF_NPSXSPC:
                    DO_N_POSIX(ret, namedclass, properties,
                                            PL_PosixSpace, PL_XPosixSpace);
		    break;
		case ANYOF_SPACE:
                    DO_POSIX(ret, namedclass, properties,
                                            PL_PerlSpace, PL_XPerlSpace);
		    break;
		case ANYOF_NSPACE:
                    DO_N_POSIX(ret, namedclass, properties,
                                            PL_PerlSpace, PL_XPerlSpace);
		    break;
		case ANYOF_UPPER:   /* Same as LOWER, above */
		case ANYOF_NUPPER:
		{
		    SV* ascii_source;
		    SV* l1_source;
		    const char *Xname;

		    if (FOLD && ! LOC) {
			ascii_source = PL_PosixAlpha;
			l1_source = PL_L1Cased;
			Xname = "Cased";
		    }
d8186 16
a8201 8
			ascii_source = PL_PosixUpper;
			l1_source = PL_L1PosixUpper;
			Xname = "XPosixUpper";
		    }
		    if (namedclass == ANYOF_UPPER) {
			DO_POSIX_LATIN1_ONLY_KNOWN(ret, namedclass, properties,
                                    ascii_source, l1_source, Xname, listsv);
		    }
d8203 3
a8205 2
			DO_N_POSIX_LATIN1_ONLY_KNOWN(ret, namedclass,
                        properties, ascii_source, l1_source, Xname, listsv);
d8207 2
d8210 13
a8222 28
		}
		case ANYOF_ALNUM:   /* Really is 'Word' */
		    DO_POSIX_LATIN1_ONLY_KNOWN(ret, namedclass, properties,
                            PL_PosixWord, PL_L1PosixWord, "XPosixWord", listsv);
		    break;
		case ANYOF_NALNUM:
		    DO_N_POSIX_LATIN1_ONLY_KNOWN(ret, namedclass, properties,
                            PL_PosixWord, PL_L1PosixWord, "XPosixWord", listsv);
		    break;
		case ANYOF_VERTWS:
		    /* For these, we use the nonbitmap, as /d doesn't make a
		     * difference in what these match.  There would be problems
		     * if these characters had folds other than themselves, as
		     * nonbitmap is subject to folding */
		    _invlist_union(nonbitmap, PL_VertSpace, &nonbitmap);
		    break;
		case ANYOF_NVERTWS:
                    _invlist_union_complement_2nd(nonbitmap,
                                                    PL_VertSpace, &nonbitmap);
		    break;
		case ANYOF_XDIGIT:
                    DO_POSIX(ret, namedclass, properties,
                                            PL_PosixXDigit, PL_XPosixXDigit);
		    break;
		case ANYOF_NXDIGIT:
                    DO_N_POSIX(ret, namedclass, properties,
                                            PL_PosixXDigit, PL_XPosixXDigit);
		    break;
d8230 6
a8235 1

d8249 2
a8250 4
	    if (RExC_parse+1 < RExC_end
		&& *RExC_parse == '-'
		&& RExC_parse[1] != ']')
	    {
d8264 1
a8264 2
			stored +=
                            set_regclass_bit(pRExC_state, ret, '-', &l1_fold_invlist, &unicode_alternate);
a8270 6
	/* non-Latin1 code point implies unicode semantics.  Must be set in
	 * pass1 so is there for the whole of pass 2 */
	if (value > 255) {
	    RExC_uni_semantics = 1;
	}

d8272 1
d8287 2
a8288 2
				stored +=
                                  set_regclass_bit(pRExC_state, ret, (U8) i, &l1_fold_invlist, &unicode_alternate);
d8293 2
a8294 2
				stored +=
                                  set_regclass_bit(pRExC_state, ret, (U8) i, &l1_fold_invlist, &unicode_alternate);
d8301 4
a8304 1
			stored += set_regclass_bit(pRExC_state, ret, (U8) i, &l1_fold_invlist, &unicode_alternate);
d8307 79
a8385 5
	  if (value > 255) {
	    const UV prevnatvalue  = NATIVE_TO_UNI(prevvalue);
	    const UV natvalue      = NATIVE_TO_UNI(value);
	    nonbitmap = _add_range_to_invlist(nonbitmap, prevnatvalue, natvalue);
	}
d8394 7
d8407 5
a8411 430
    /* If folding and there are code points above 255, we calculate all
     * characters that could fold to or from the ones already on the list */
    if (FOLD && nonbitmap) {
	UV start, end;	/* End points of code point ranges */

	SV* fold_intersection = NULL;

	/* This is a list of all the characters that participate in folds
	    * (except marks, etc in multi-char folds */
	if (! PL_utf8_foldable) {
	    SV* swash = swash_init("utf8", "Cased", &PL_sv_undef, 1, 0);
	    PL_utf8_foldable = _swash_to_invlist(swash);
            SvREFCNT_dec(swash);
	}

	/* This is a hash that for a particular fold gives all characters
	    * that are involved in it */
	if (! PL_utf8_foldclosures) {

	    /* If we were unable to find any folds, then we likely won't be
	     * able to find the closures.  So just create an empty list.
	     * Folding will effectively be restricted to the non-Unicode rules
	     * hard-coded into Perl.  (This case happens legitimately during
	     * compilation of Perl itself before the Unicode tables are
	     * generated) */
	    if (invlist_len(PL_utf8_foldable) == 0) {
		PL_utf8_foldclosures = newHV();
	    } else {
		/* If the folds haven't been read in, call a fold function
		    * to force that */
		if (! PL_utf8_tofold) {
		    U8 dummy[UTF8_MAXBYTES+1];
		    STRLEN dummy_len;

		    /* This particular string is above \xff in both UTF-8 and
		     * UTFEBCDIC */
		    to_utf8_fold((U8*) "\xC8\x80", dummy, &dummy_len);
		    assert(PL_utf8_tofold); /* Verify that worked */
		}
		PL_utf8_foldclosures = _swash_inversion_hash(PL_utf8_tofold);
	    }
	}

	/* Only the characters in this class that participate in folds need be
	 * checked.  Get the intersection of this class and all the possible
	 * characters that are foldable.  This can quickly narrow down a large
	 * class */
	_invlist_intersection(PL_utf8_foldable, nonbitmap, &fold_intersection);

	/* Now look at the foldable characters in this class individually */
	invlist_iterinit(fold_intersection);
	while (invlist_iternext(fold_intersection, &start, &end)) {
	    UV j;

	    /* Look at every character in the range */
	    for (j = start; j <= end; j++) {

		/* Get its fold */
		U8 foldbuf[UTF8_MAXBYTES_CASE+1];
		STRLEN foldlen;
		const UV f =
                    _to_uni_fold_flags(j, foldbuf, &foldlen, allow_full_fold);

		if (foldlen > (STRLEN)UNISKIP(f)) {

		    /* Any multicharacter foldings (disallowed in lookbehind
		     * patterns) require the following transform: [ABCDEF] ->
		     * (?:[ABCabcDEFd]|pq|rst) where E folds into "pq" and F
		     * folds into "rst", all other characters fold to single
		     * characters.  We save away these multicharacter foldings,
		     * to be later saved as part of the additional "s" data. */
		    if (! RExC_in_lookbehind) {
			U8* loc = foldbuf;
			U8* e = foldbuf + foldlen;

			/* If any of the folded characters of this are in the
			 * Latin1 range, tell the regex engine that this can
			 * match a non-utf8 target string.  The only multi-byte
			 * fold whose source is in the Latin1 range (U+00DF)
			 * applies only when the target string is utf8, or
			 * under unicode rules */
			if (j > 255 || AT_LEAST_UNI_SEMANTICS) {
			    while (loc < e) {

				/* Can't mix ascii with non- under /aa */
				if (MORE_ASCII_RESTRICTED
				    && (isASCII(*loc) != isASCII(j)))
				{
				    goto end_multi_fold;
				}
				if (UTF8_IS_INVARIANT(*loc)
				    || UTF8_IS_DOWNGRADEABLE_START(*loc))
				{
                                    /* Can't mix above and below 256 under LOC
                                     */
				    if (LOC) {
					goto end_multi_fold;
				    }
				    ANYOF_FLAGS(ret)
					    |= ANYOF_NONBITMAP_NON_UTF8;
				    break;
				}
				loc += UTF8SKIP(loc);
			    }
			}

			add_alternate(&unicode_alternate, foldbuf, foldlen);
		    end_multi_fold: ;
		    }

		    /* This is special-cased, as it is the only letter which
		     * has both a multi-fold and single-fold in Latin1.  All
		     * the other chars that have single and multi-folds are
		     * always in utf8, and the utf8 folding algorithm catches
		     * them */
		    if (! LOC && j == LATIN_CAPITAL_LETTER_SHARP_S) {
			stored += set_regclass_bit(pRExC_state,
					ret,
					LATIN_SMALL_LETTER_SHARP_S,
					&l1_fold_invlist, &unicode_alternate);
		    }
		}
		else {
		    /* Single character fold.  Add everything in its fold
		     * closure to the list that this node should match */
		    SV** listp;

		    /* The fold closures data structure is a hash with the keys
		     * being every character that is folded to, like 'k', and
		     * the values each an array of everything that folds to its
		     * key.  e.g. [ 'k', 'K', KELVIN_SIGN ] */
		    if ((listp = hv_fetch(PL_utf8_foldclosures,
				    (char *) foldbuf, foldlen, FALSE)))
		    {
			AV* list = (AV*) *listp;
			IV k;
			for (k = 0; k <= av_len(list); k++) {
			    SV** c_p = av_fetch(list, k, FALSE);
			    UV c;
			    if (c_p == NULL) {
				Perl_croak(aTHX_ "panic: invalid PL_utf8_foldclosures structure");
			    }
			    c = SvUV(*c_p);

			    /* /aa doesn't allow folds between ASCII and non-;
			     * /l doesn't allow them between above and below
			     * 256 */
			    if ((MORE_ASCII_RESTRICTED
				 && (isASCII(c) != isASCII(j)))
				    || (LOC && ((c < 256) != (j < 256))))
			    {
				continue;
			    }

			    if (c < 256 && AT_LEAST_UNI_SEMANTICS) {
				stored += set_regclass_bit(pRExC_state,
					ret,
					(U8) c,
					&l1_fold_invlist, &unicode_alternate);
			    }
				/* It may be that the code point is already in
				 * this range or already in the bitmap, in
				 * which case we need do nothing */
			    else if ((c < start || c > end)
					&& (c > 255
					    || ! ANYOF_BITMAP_TEST(ret, c)))
			    {
				nonbitmap = add_cp_to_invlist(nonbitmap, c);
			    }
			}
		    }
		}
	    }
	}
	SvREFCNT_dec(fold_intersection);
    }

    /* Combine the two lists into one. */
    if (l1_fold_invlist) {
	if (nonbitmap) {
	    _invlist_union(nonbitmap, l1_fold_invlist, &nonbitmap);
	    SvREFCNT_dec(l1_fold_invlist);
	}
	else {
	    nonbitmap = l1_fold_invlist;
	}
    }

    /* And combine the result (if any) with any inversion list from properties.
     * The lists are kept separate up to now because we don't want to fold the
     * properties */
    if (properties) {
	if (nonbitmap) {
	    _invlist_union(nonbitmap, properties, &nonbitmap);
	    SvREFCNT_dec(properties);
	}
	else {
	    nonbitmap = properties;
	}
    }

    /* Here, <nonbitmap> contains all the code points we can determine at
     * compile time that we haven't put into the bitmap.  Go through it, and
     * for things that belong in the bitmap, put them there, and delete from
     * <nonbitmap> */
    if (nonbitmap) {

	/* Above-ASCII code points in /d have to stay in <nonbitmap>, as they
	 * possibly only should match when the target string is UTF-8 */
	UV max_cp_to_set = (DEPENDS_SEMANTICS) ? 127 : 255;

	/* This gets set if we actually need to modify things */
	bool change_invlist = FALSE;

	UV start, end;

	/* Start looking through <nonbitmap> */
	invlist_iterinit(nonbitmap);
	while (invlist_iternext(nonbitmap, &start, &end)) {
	    UV high;
	    int i;

	    /* Quit if are above what we should change */
	    if (start > max_cp_to_set) {
		break;
	    }

	    change_invlist = TRUE;

	    /* Set all the bits in the range, up to the max that we are doing */
	    high = (end < max_cp_to_set) ? end : max_cp_to_set;
	    for (i = start; i <= (int) high; i++) {
		if (! ANYOF_BITMAP_TEST(ret, i)) {
		    ANYOF_BITMAP_SET(ret, i);
		    stored++;
		    prevvalue = value;
		    value = i;
		}
	    }
	}

        /* Done with loop; remove any code points that are in the bitmap from
         * <nonbitmap> */
	if (change_invlist) {
	    _invlist_subtract(nonbitmap,
		              (DEPENDS_SEMANTICS)
			        ? PL_ASCII
			        : PL_Latin1,
                              &nonbitmap);
	}

	/* If have completely emptied it, remove it completely */
	if (invlist_len(nonbitmap) == 0) {
	    SvREFCNT_dec(nonbitmap);
	    nonbitmap = NULL;
	}
    }

    /* Here, we have calculated what code points should be in the character
     * class.  <nonbitmap> does not overlap the bitmap except possibly in the
     * case of DEPENDS rules.
     *
     * Now we can see about various optimizations.  Fold calculation (which we
     * did above) needs to take place before inversion.  Otherwise /[^k]/i
     * would invert to include K, which under /i would match k, which it
     * shouldn't. */

    /* Optimize inverted simple patterns (e.g. [^a-z]).  Note that we haven't
     * set the FOLD flag yet, so this does optimize those.  It doesn't
     * optimize locale.  Doing so perhaps could be done as long as there is
     * nothing like \w in it; some thought also would have to be given to the
     * interaction with above 0x100 chars */
    if ((ANYOF_FLAGS(ret) & ANYOF_INVERT)
        && ! LOC
	&& ! unicode_alternate
	/* In case of /d, there are some things that should match only when in
	 * not in the bitmap, i.e., they require UTF8 to match.  These are
	 * listed in nonbitmap, but if ANYOF_NONBITMAP_NON_UTF8 is set in this
	 * case, they don't require UTF8, so can invert here */
	&& (! nonbitmap
	    || ! DEPENDS_SEMANTICS
	    || (ANYOF_FLAGS(ret) & ANYOF_NONBITMAP_NON_UTF8))
	&& SvCUR(listsv) == initial_listsv_len)
    {
	int i;
	if (! nonbitmap) {
	    for (i = 0; i < 256; ++i) {
		if (ANYOF_BITMAP_TEST(ret, i)) {
		    ANYOF_BITMAP_CLEAR(ret, i);
		}
		else {
		    ANYOF_BITMAP_SET(ret, i);
		    prevvalue = value;
		    value = i;
		}
	    }
	    /* The inversion means that everything above 255 is matched */
	    ANYOF_FLAGS(ret) |= ANYOF_UNICODE_ALL;
	}
	else {
	    /* Here, also has things outside the bitmap that may overlap with
	     * the bitmap.  We have to sync them up, so that they get inverted
	     * in both places.  Earlier, we removed all overlaps except in the
	     * case of /d rules, so no syncing is needed except for this case
	     */
	    SV *remove_list = NULL;

	    if (DEPENDS_SEMANTICS) {
		UV start, end;

		/* Set the bits that correspond to the ones that aren't in the
		 * bitmap.  Otherwise, when we invert, we'll miss these.
		 * Earlier, we removed from the nonbitmap all code points
		 * < 128, so there is no extra work here */
		invlist_iterinit(nonbitmap);
		while (invlist_iternext(nonbitmap, &start, &end)) {
		    if (start > 255) {  /* The bit map goes to 255 */
			break;
		    }
		    if (end > 255) {
			end = 255;
		    }
		    for (i = start; i <= (int) end; ++i) {
			ANYOF_BITMAP_SET(ret, i);
			prevvalue = value;
			value = i;
		    }
		}
	    }

	    /* Now invert both the bitmap and the nonbitmap.  Anything in the
	     * bitmap has to also be removed from the non-bitmap, but again,
	     * there should not be overlap unless is /d rules. */
	    _invlist_invert(nonbitmap);

	    /* Any swash can't be used as-is, because we've inverted things */
	    if (swash) {
		SvREFCNT_dec(swash);
		swash = NULL;
	    }

	    for (i = 0; i < 256; ++i) {
		if (ANYOF_BITMAP_TEST(ret, i)) {
		    ANYOF_BITMAP_CLEAR(ret, i);
		    if (DEPENDS_SEMANTICS) {
			if (! remove_list) {
			    remove_list = _new_invlist(2);
			}
			remove_list = add_cp_to_invlist(remove_list, i);
		    }
		}
		else {
		    ANYOF_BITMAP_SET(ret, i);
		    prevvalue = value;
		    value = i;
		}
	    }

	    /* And do the removal */
	    if (DEPENDS_SEMANTICS) {
		if (remove_list) {
		    _invlist_subtract(nonbitmap, remove_list, &nonbitmap);
		    SvREFCNT_dec(remove_list);
		}
	    }
	    else {
		/* There is no overlap for non-/d, so just delete anything
		 * below 256 */
		_invlist_intersection(nonbitmap, PL_AboveLatin1, &nonbitmap);
	    }
	}

	stored = 256 - stored;

	/* Clear the invert flag since have just done it here */
	ANYOF_FLAGS(ret) &= ~ANYOF_INVERT;
    }

    /* Folding in the bitmap is taken care of above, but not for locale (for
     * which we have to wait to see what folding is in effect at runtime), and
     * for some things not in the bitmap (only the upper latin folds in this
     * case, as all other single-char folding has been set above).  Set
     * run-time fold flag for these */
    if (FOLD && (LOC
		|| (DEPENDS_SEMANTICS
		    && nonbitmap
		    && ! (ANYOF_FLAGS(ret) & ANYOF_NONBITMAP_NON_UTF8))
		|| unicode_alternate))
    {
	ANYOF_FLAGS(ret) |= ANYOF_LOC_NONBITMAP_FOLD;
    }

    /* A single character class can be "optimized" into an EXACTish node.
     * Note that since we don't currently count how many characters there are
     * outside the bitmap, we are XXX missing optimization possibilities for
     * them.  This optimization can't happen unless this is a truly single
     * character class, which means that it can't be an inversion into a
     * many-character class, and there must be no possibility of there being
     * things outside the bitmap.  'stored' (only) for locales doesn't include
     * \w, etc, so have to make a special test that they aren't present
     *
     * Similarly A 2-character class of the very special form like [bB] can be
     * optimized into an EXACTFish node, but only for non-locales, and for
     * characters which only have the two folds; so things like 'fF' and 'Ii'
     * wouldn't work because they are part of the fold of 'LATIN SMALL LIGATURE
     * FI'. */
    if (! nonbitmap
	&& ! unicode_alternate
	&& SvCUR(listsv) == initial_listsv_len
	&& ! (ANYOF_FLAGS(ret) & (ANYOF_INVERT|ANYOF_UNICODE_ALL))
        && (((stored == 1 && ((! (ANYOF_FLAGS(ret) & ANYOF_LOCALE))
                              || (! ANYOF_CLASS_TEST_ANY_SET(ret)))))
	    || (stored == 2 && ((! (ANYOF_FLAGS(ret) & ANYOF_LOCALE))
				 && (! _HAS_NONLATIN1_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(value))
				 /* If the latest code point has a fold whose
				  * bit is set, it must be the only other one */
				&& ((prevvalue = PL_fold_latin1[value]) != (IV)value)
				 && ANYOF_BITMAP_TEST(ret, prevvalue)))))
    {
        /* Note that the information needed to decide to do this optimization
         * is not currently available until the 2nd pass, and that the actually
	 * used EXACTish node takes less space than the calculated ANYOF node,
	 * and hence the amount of space calculated in the first pass is larger
         * than actually used, so this optimization doesn't gain us any space.
	 * But an EXACT node is faster than an ANYOF node, and can be combined
	 * with any adjacent EXACT nodes later by the optimizer for further
	 * gains.  The speed of executing an EXACTF is similar to an ANYOF
	 * node, so the optimization advantage comes from the ability to join
	 * it to adjacent EXACT nodes */

a8412 1
	U8 op;
d8415 2
a8416 37

	if (stored == 1) {

	    /* A locale node with one point can be folded; all the other cases
	     * with folding will have two points, since we calculate them above
	     */
	    if (ANYOF_FLAGS(ret) & ANYOF_LOC_NONBITMAP_FOLD) {
		 op = EXACTFL;
	    }
	    else {
		op = EXACT;
	    }
	}
	else {   /* else 2 chars in the bit map: the folds of each other */

	    /* Use the folded value, which for the cases where we get here,
	     * is just the lower case of the current one (which may resolve to
	     * itself, or to the other one */
	    value = toLOWER_LATIN1(value);

	    /* To join adjacent nodes, they must be the exact EXACTish type.
	     * Try to use the most likely type, by using EXACTFA if possible,
	     * then EXACTFU if the regex calls for it, or is required because
	     * the character is non-ASCII.  (If <value> is ASCII, its fold is
	     * also ASCII for the cases where we get here.) */
	    if (MORE_ASCII_RESTRICTED && isASCII(value)) {
		op = EXACTFA;
	    }
	    else if (AT_LEAST_UNI_SEMANTICS || !isASCII(value)) {
		op = EXACTFU;
	    }
	    else {    /* Otherwise, more likely to be EXACTF type */
		op = EXACTF;
	    }
	}

	ret = reg_node(pRExC_state, op);
d8418 3
a8420 11
	if (UTF && ! NATIVE_IS_INVARIANT(value)) {
	    *STRING(ret)= UTF8_EIGHT_BIT_HI((U8) value);
	    *(STRING(ret) + 1)= UTF8_EIGHT_BIT_LO((U8) value);
	    STR_LEN(ret)= 2;
	    RExC_emit += STR_SZ(2);
	}
	else {
	    *STRING(ret)= (char)value;
	    STR_LEN(ret)= 1;
	    RExC_emit += STR_SZ(1);
	}
d8424 23
a8446 10

    /* If there is a swash and more than one element, we can't use the swash in
     * the optimization below. */
    if (swash && element_count > 1) {
	SvREFCNT_dec(swash);
	swash = NULL;
    }
    if (! nonbitmap
	&& SvCUR(listsv) == initial_listsv_len
	&& ! unicode_alternate)
a8447 17
	ARG_SET(ret, ANYOF_NONBITMAP_EMPTY);
	SvREFCNT_dec(listsv);
	SvREFCNT_dec(unicode_alternate);
    }
    else {
	/* av[0] stores the character class description in its textual form:
	 *       used later (regexec.c:Perl_regclass_swash()) to initialize the
	 *       appropriate swash, and is also useful for dumping the regnode.
	 * av[1] if NULL, is a placeholder to later contain the swash computed
	 *       from av[0].  But if no further computation need be done, the
	 *       swash is stored there now.
	 * av[2] stores the multicharacter foldings, used later in
	 *       regexec.c:S_reginclass().
	 * av[3] stores the nonbitmap inversion list for use in addition or
	 *       instead of av[0]; not used if av[1] isn't NULL
	 * av[4] is set if any component of the class is from a user-defined
	 *       property; not used if av[1] isn't NULL */
d8450 9
a8458 27

	av_store(av, 0, (SvCUR(listsv) == initial_listsv_len)
			? &PL_sv_undef
			: listsv);
	if (swash) {
	    av_store(av, 1, swash);
	    SvREFCNT_dec(nonbitmap);
	}
	else {
	    av_store(av, 1, NULL);
	    if (nonbitmap) {
		av_store(av, 3, nonbitmap);
		av_store(av, 4, newSVuv(has_user_defined_property));
	    }
	}

        /* Store any computed multi-char folds only if we are allowing
         * them */
        if (allow_full_fold) {
            av_store(av, 2, MUTABLE_SV(unicode_alternate));
            if (unicode_alternate) { /* This node is variable length */
                OP(ret) = ANYOFV;
            }
        }
        else {
            av_store(av, 2, NULL);
        }
d8466 1
d8504 1
a8504 1
   Advances the parse position, and optionally absorbs
d8523 2
a8524 5
	if (RExC_end - RExC_parse >= 3
	    && *RExC_parse == '('
	    && RExC_parse[1] == '?'
	    && RExC_parse[2] == '#')
	{
d8566 1
a8566 2
        Perl_croak(aTHX_ "panic: reg_node overrun trying to emit %d, %p>=%p",
		   op, RExC_emit, RExC_emit_bound);
d8608 1
a8608 1

d8621 1
a8621 2
        Perl_croak(aTHX_ "panic: reg_node overrun trying to emit %d, %p>=%p",
		   op, RExC_emit, RExC_emit_bound);
d8798 1
a8798 1
This is experimental code. The idea is to use this routine to perform 
d8832 2
a8833 3
        if (PL_regkind[OP(scan)] == EXACT) {
	    bool has_exactf_sharp_s;	/* Unexamined in this routine */
            if (join_exact(pRExC_state,scan,&min, &has_exactf_sharp_s, 1,val,depth+1))
a8834 1
	}
a8839 4
                case EXACTFA:
                case EXACTFU:
                case EXACTFU_SS:
                case EXACTFU_TRICKYFOLD:
d8886 25
a8918 1
    regex_charset cs;
a8921 3
	    if ((1<<bit) & RXf_PMf_CHARSET) {	/* Output separately, below */
		continue;
	    }
a8926 22
    if ((cs = get_regex_charset(flags)) != REGEX_DEPENDS_CHARSET) {
            if (!set++ && lead) {
                PerlIO_printf(Perl_debug_log, "%s",lead);
            }
            switch (cs) {
                case REGEX_UNICODE_CHARSET:
                    PerlIO_printf(Perl_debug_log, "UNICODE");
                    break;
                case REGEX_LOCALE_CHARSET:
                    PerlIO_printf(Perl_debug_log, "LOCALE");
                    break;
                case REGEX_ASCII_RESTRICTED_CHARSET:
                    PerlIO_printf(Perl_debug_log, "ASCII-RESTRICTED");
                    break;
                case REGEX_ASCII_MORE_RESTRICTED_CHARSET:
                    PerlIO_printf(Perl_debug_log, "ASCII-MORE_RESTRICTED");
                    break;
                default:
                    PerlIO_printf(Perl_debug_log, "UNKNOWN CHARACTER SET");
                    break;
            }
    }
a9070 1
		  PERL_PV_ESCAPE_NONASCII   |
d9133 1
a9133 1
            if ( k != REF || (OP(o) < NREF)) {
d9162 2
d9205 1
a9205 1
	if (flags & ANYOF_LOC_NONBITMAP_FOLD)
d9210 1
a9210 1

d9231 2
a9232 2
        /* output any special charclass tests (used entirely under use locale) */
	if (ANYOF_CLASS_TEST_ANY_SET(o))
a9240 4
	if (flags & ANYOF_NON_UTF8_LATIN1_ALL) {
	    sv_catpvs(sv, "{non-utf8-latin1-all}");
	}

d9242 3
a9244 1
	if (flags & ANYOF_UNICODE_ALL)
a9245 4
	else if (ANYOF_NONBITMAP(o))
	    sv_catpvs(sv, "{unicode}");
	if (flags & ANYOF_NONBITMAP_NON_UTF8)
	    sv_catpvs(sv, "{outside bitmap}");
d9247 2
a9248 2
	if (ANYOF_NONBITMAP(o)) {
	    SV *lv; /* Set if there is something outside the bit map */
d9250 2
a9251 4
            bool byte_output = FALSE;   /* If something in the bitmap has been
                                           output */

	    if (lv && lv != &PL_sv_undef) {
d9255 1
a9255 1
		    for (i = 0; i <= 256; i++) { /* Look at chars in bitmap */
d9257 2
a9258 8

			if (i < 256
                            && ! ANYOF_BITMAP_TEST(o, i)    /* Don't duplicate
                                                               things already
                                                               output as part
                                                               of the bitmap */
                            && swash_fetch(sw, s, TRUE))
                        {
a9261 1
                            byte_output = TRUE;
d9264 4
a9267 1
				    put_byte(sv, rangestart);
d9270 4
a9273 1
				put_byte(sv, rangestart);
d9275 5
a9279 1
				put_byte(sv, i-1);
a9280 1
			    rangestart = -1;
d9282 2
a9283 1
		    }
d9289 1
a9289 1

d9292 1
a9292 1

d9295 1
a9295 5

                        if (byte_output) {
                            sv_catpvs(sv, " ");
                        }

d9297 1
a9297 10
			    if (*s == '\n') {

                                /* Truncate very long output */
				if (s - origs > 256) {
				    Perl_sv_catpvf(aTHX_ sv,
						   "%.*s...",
					           (int) (s - origs - 1),
						   t);
				    goto out_dump;
				}
a9298 4
			    }
			    else if (*s == '\t') {
				*s = '-';
			    }
d9303 1
a9303 1

d9306 1
a9306 3

		out_dump:

a9308 1
		SvREFCNT_dec(lv);
d9358 1
a9358 1
   does is call the 'free' method of the regexp_engine associated to
d9412 1
a9412 1
    lightweight copy doesn't actually own any of its data except for
d9471 1
a9471 1
   this covers the *pprivate pointer which technically perl doesn't 
a9512 1
	    case 'a':
d9574 2
d9578 2
a9579 1
			PerlMemShared_free(trie->wordinfo);
d9596 3
a9598 2
#define av_dup_inc(s,t)	MUTABLE_AV(sv_dup_inc((const SV *)s,t))
#define hv_dup_inc(s,t)	MUTABLE_HV(sv_dup_inc((const SV *)s,t))
d9691 1
a9691 2
	    /* Note we need to use SvCUR(), rather than
	       SvLEN(), on our mother_re, because it, in
d9723 1
a9723 1
    int len;
d9728 1
d9750 1
a9750 1
	        /* legal options are one of: sSfpontTua
a9751 1
	    case 'a': /* actually an AV, but the dup function is identical.  */
a9826 4
    if (OP(p) > REGNODE_MAX) {		/* regnode.type is unsigned */
	Perl_croak(aTHX_ "Corrupted regexp opcode %d > %d", (int)OP(p), (int)REGNODE_MAX);
    }

d9835 1
a9835 1
STATIC void
d9886 1
a9886 1
    SSPUSHUV(SAVEt_RE_STATE);
d9948 2
a9949 8
    if (!isPRINT(c)) {
	if (c < 256) {
	    Perl_sv_catpvf(aTHX_ sv, "\\x%02x", c);
	}
	else {
	    Perl_sv_catpvf(aTHX_ sv, "\\x{%x}", c);
	}
    }
d10006 1
a10006 1

d10054 1
a10054 1

d10096 1
a10096 1
	else if (PL_regkind[(U8)op] == ANYOF) {
d10098 1
a10098 1
	    node += 1 + ((ANYOF_FLAGS(node) & ANYOF_CLASS)
@


1.1.1.14
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a83 1
extern const struct regexp_engine my_reg_engine;
d89 3
a91 7
#include "charclass_invlists.h"
#include "inline_invlist.c"
#include "unicode_constants.h"

#define HAS_NONLATIN1_FOLD_CLOSURE(i) _HAS_NONLATIN1_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(i)
#define IS_NON_FINAL_FOLD(c) _IS_NON_FINAL_FOLD_ONLY_FOR_USE_BY_REGCOMP_DOT_C(c)
#define IS_IN_SOME_FOLD_L1(c) _IS_IN_SOME_FOLD_ONLY_FOR_USE_BY_REGCOMP_DOT_C(c)
a109 1

d111 1
a111 2
    U32		flags;			/* RXf_* are we folding, multilining? */
    U32		pm_flags;		/* PMf_* stuff from the calling PMOP */
d132 1
a149 5
    I32		in_multi_char_class;
    struct reg_code_block *code_blocks;	/* positions of literal (?{})
					    within pattern */
    int		num_code_blocks;	/* size of code_blocks[] */
    int		code_index;		/* next code_blocks[] slot */
a153 1
    SV		*runtime_code_qr;	/* qr with the runtime code blocks */
a164 1
#define RExC_pm_flags	(pRExC_state->pm_flags)
d187 1
d199 1
a199 2
#define RExC_override_recoding (pRExC_state->override_recoding)
#define RExC_in_multi_char_class (pRExC_state->in_multi_char_class)
d204 1
a204 1
	((*s) == '{' && regcurly(s, FALSE)))
d215 2
a216 4
/* Simple enough to be STAR/PLUS operand; in an EXACTish node must be a single
 * character.  (There needs to be a case: in the switch statement in regexec.c
 * for any node marked SIMPLE.)  Note that this is not the same thing as
 * REGNODE_SIMPLE */
d218 3
a220 4
#define	SPSTART		0x04	/* Starts with * or + */
#define POSTPONED	0x08    /* (?1),(?&name), (??{...}) or similar */
#define TRYAGAIN	0x10	/* Weeded out a declaration. */
#define RESTART_UTF8    0x20    /* Restart, need to calcuate sizes as UTF-8 */
d239 2
d242 1
a242 4
                                     if (!UTF) {                           \
                                         *flagp = RESTART_UTF8;            \
                                         return NULL;                      \
                                     }                                     \
a244 5
/* This converts the named class defined in regcomp.h to its equivalent class
 * number defined in handy.h. */
#define namedclass_to_classnum(class)  ((int) ((class) / 2))
#define classnum_to_namedclass(classnum)  ((classnum) * 2)

d283 2
a284 2
    A pointer to the minimum number of characters of the pattern that the
    string was found inside. This is important as in the case of positive
d392 1
a393 1
#define ASCII_FOLD_RESTRICTED (get_regex_charset(RExC_flags) == REGEX_ASCII_MORE_RESTRICTED_CHARSET)
d397 1
a399 5
/* There is no code point that is out-of-bounds, so this is problematic.  But
 * its only current use is to initialize a variable that is always set before
 * looked at. */
#define OOB_UNICODE		0xDEADBEEF

d427 1
a427 1
	SAVEFREESV(RExC_rx_sv);						\
d458 1
a458 1
	SAVEFREESV(RExC_rx_sv);				\
d476 1
a476 1
	SAVEFREESV(RExC_rx_sv);				\
d495 1
a495 1
	SAVEFREESV(RExC_rx_sv);				\
a507 13
#define	vFAIL4(m,a1,a2,a3) STMT_START {			\
    if (!SIZE_ONLY)					\
	SAVEFREESV(RExC_rx_sv);				\
    Simple_vFAIL4(m, a1, a2, a3);			\
} STMT_END

/* m is not necessarily a "literal string", in this macro */
#define reg_warn_non_literal_string(loc, m) STMT_START {                \
    const IV offset = loc - RExC_precomp;                               \
    Perl_warner(aTHX_ packWARN(WARN_REGEXP), "%s" REPORT_LOCATION,      \
            m, (int)offset, RExC_precomp, RExC_precomp + offset);       \
} STMT_END

a513 13
#define	vWARN_dep(loc, m) STMT_START {				        \
    const IV offset = loc - RExC_precomp;				\
    Perl_warner(aTHX_ packWARN(WARN_DEPRECATED), m REPORT_LOCATION,	\
	    (int)offset, RExC_precomp, RExC_precomp + offset);	        \
} STMT_END

#define	ckWARNdep(loc,m) STMT_START {				        \
    const IV offset = loc - RExC_precomp;				\
    Perl_ck_warner_d(aTHX_ packWARN(WARN_DEPRECATED),	                \
	    m REPORT_LOCATION,						\
	    (int)offset, RExC_precomp, RExC_precomp + offset);		\
} STMT_END

d673 2
d704 1
a704 1
				      : (data->pos_delta == I32_MAX ? I32_MAX : data->pos_min + data->pos_delta));
a729 11
/* These macros set, clear and test whether the synthetic start class ('ssc',
 * given by the parameter) matches an empty string (EOS).  This uses the
 * 'next_off' field in the node, to save a bit in the flags field.  The ssc
 * stands alone, so there is never a next_off, so this field is otherwise
 * unused.  The EOS information is used only for compilation, but theoretically
 * it could be passed on to the execution code.  This could be used to store
 * more than one bit of information, but only this one is currently used. */
#define SET_SSC_EOS(node)   STMT_START { (node)->next_off = TRUE; } STMT_END
#define CLEAR_SSC_EOS(node) STMT_START { (node)->next_off = FALSE; } STMT_END
#define TEST_SSC_EOS(node)  cBOOL((node)->next_off)

d737 2
a738 2
    cl->flags = ANYOF_UNICODE_ALL;
    SET_SSC_EOS(cl);
d749 1
a749 1
	cl->flags |= ANYOF_LOCALE|ANYOF_CLASS|ANYOF_LOC_FOLD;
d764 1
a764 1
    for (value = 0; value < ANYOF_MAX; value += 2)
d798 1
a798 1
    assert(PL_regkind[and_with->type] == ANYOF);
d804 2
a805 2
	&& !(and_with->flags & ANYOF_LOC_FOLD)
	&& !(cl->flags & ANYOF_LOC_FOLD)) {
d938 2
a939 2
	     && !(or_with->flags & ANYOF_LOC_FOLD)
	     && !(cl->flags & ANYOF_LOC_FOLD) ) {
d965 2
a966 2
	     && (!(or_with->flags & ANYOF_LOC_FOLD)
		 || (cl->flags & ANYOF_LOC_FOLD)) ) {
d972 5
a976 3
            if (or_with->flags & ANYOF_CLASS) {
                ANYOF_CLASS_OR(or_with, cl);
            }
d1526 1
a1526 1
        case EXACT: break;
d1555 1
a1555 1
    DEBUG_TRIE_COMPILE_r({
d1597 1
a1597 1
        regnode *noper = NEXTOPER( cur );
d1599 1
a1599 1
        const U8 *e  = uc + STR_LEN( noper );
d1609 2
a1610 10
            regnode *noper_next= regnext(noper);
            if (noper_next != tail && OP(noper_next) == flags) {
                noper = noper_next;
                uc= (U8*)STRING(noper);
                e= uc + STR_LEN(noper);
		trie->minlen= STR_LEN(noper);
            } else {
		trie->minlen= 0;
		continue;
	    }
a1611 1

d1750 1
a1750 1
            regnode *noper   = NEXTOPER( cur );
d1752 1
a1752 1
            const U8 *e      = uc + STR_LEN( noper );
a1760 9
            if (OP(noper) == NOTHING) {
                regnode *noper_next= regnext(noper);
                if (noper_next != tail && OP(noper_next) == flags) {
                    noper = noper_next;
                    uc= (U8*)STRING(noper);
                    e= uc + STR_LEN(noper);
                }
            }

d1948 1
a1948 1
            regnode *noper   = NEXTOPER( cur );
d1950 1
a1950 1
            const U8 *e      = uc + STR_LEN( noper );
a1962 8
            if (OP(noper) == NOTHING) {
                regnode *noper_next= regnext(noper);
                if (noper_next != tail && OP(noper_next) == flags) {
                    noper = noper_next;
                    uc= (U8*)STRING(noper);
                    e= uc + STR_LEN(noper);
                }
            }
d2401 1
a2401 1
    SvREFCNT_dec_NN(revcharmap);
d2543 4
a2546 2
 * one.  The regop may be changed if the node(s) contain certain sequences that
 * require special handling.  The joining is only done if:
d2551 1
a2551 1
 * The adjacent nodes actually may be separated by NOTHING-kind nodes, and
d2554 4
a2557 3
 * If a node is to match under /i (folded), the number of characters it matches
 * can be different than its character length if it contains a multi-character
 * fold.  *min_subtract is set to the total delta of the input nodes.
d2563 19
a2581 5
 * multi-character fold sequences.  It's been wrong in Perl for a very long
 * time.  There are three code points in Unicode whose multi-character folds
 * were long ago discovered to mess things up.  The previous designs for
 * dealing with these involved assigning a special node for them.  This
 * approach doesn't work, as evidenced by this example:
d2583 2
a2584 2
 * Both these fold to "sss", but if the pattern is parsed to create a node that
 * would match just the \xDF, it won't be able to handle the case where a
d2589 4
a2592 5
 * It turns out that there are problems with all multi-character folds, and not
 * just these three.  Now the code is general, for all such cases, but the
 * three still have some special handling.  The approach taken is:
 * 1)   This routine examines each EXACTFish node that could contain multi-
 *      character fold sequences.  It returns in *min_subtract how much to
d2594 19
a2612 19
 *      match length; it is 0 if there are no multi-char folds.  This delta is
 *      used by the caller to adjust the min length of the match, and the delta
 *      between min and max, so that the optimizer doesn't reject these
 *      possibilities based on size constraints.
 * 2)   Certain of these sequences require special handling by the trie code,
 *      so, if found, this code changes the joined node type to special ops:
 *      EXACTFU_TRICKYFOLD and EXACTFU_SS.
 * 3)   For the sequence involving the Sharp s (\xDF), the node type EXACTFU_SS
 *      is used for an EXACTFU node that contains at least one "ss" sequence in
 *      it.  For non-UTF-8 patterns and strings, this is the only case where
 *      there is a possible fold length change.  That means that a regular
 *      EXACTFU node without UTF-8 involvement doesn't have to concern itself
 *      with length changes, and so can be processed faster.  regexec.c takes
 *      advantage of this.  Generally, an EXACTFish node that is in UTF-8 is
 *      pre-folded by regcomp.c.  This saves effort in regex matching.
 *      However, the pre-folding isn't done for non-UTF8 patterns because the
 *      fold of the MICRO SIGN requires UTF-8, and we don't want to slow things
 *      down by forcing the pattern into UTF8 unless necessary.  Also what
 *      EXACTF and EXACTFL nodes fold to isn't known until runtime.  The fold
d2614 7
a2620 6
 *      the sharp s.  All the ones that don't involve a UTF-8 target string are
 *      members of a fold-pair, and arrays are set up for all of them so that
 *      the other member of the pair can be found quickly.  Code elsewhere in
 *      this file makes sure that in EXACTFU nodes, the sharp s gets folded to
 *      'ss', even if the pattern isn't UTF-8.  This avoids the issues
 *      described in the next item.
d2625 1
a2625 1
 *      it can't be folded to "ss" at compile time, unlike EXACTFU does (as
a2696 3
            /* XXX I (khw) kind of doubt that this works on platforms where
             * U8_MAX is above 255 because of lots of other assumptions */
            /* Don't join if the sum can't fit into a single node */
d2738 13
a2750 3
        const U8 * const s0 = (U8*) STRING(scan);
        const U8 * s = s0;
        const U8 * const s_end = s0 + STR_LEN(scan);
d2758 46
a2803 5
            /* Examine the string for a multi-character fold sequence.  UTF-8
             * patterns have all characters pre-folded by the time this code is
             * executed */
            while (s < s_end - 1) /* Can stop 1 before the end, as minimum
                                     length sequence we are looking for is 2 */
a2804 6
                int count = 0;
                int len = is_MULTI_CHAR_FOLD_utf8_safe(s, s_end);
                if (! len) {    /* Not a multi-char fold: get next char */
                    s += UTF8SKIP(s);
                    continue;
                }
d2806 23
a2828 20
                /* Nodes with 'ss' require special handling, except for EXACTFL
                 * and EXACTFA for which there is no multi-char fold to this */
                if (len == 2 && *s == 's' && *(s+1) == 's'
                    && OP(scan) != EXACTFL && OP(scan) != EXACTFA)
                {
                    count = 2;
                    OP(scan) = EXACTFU_SS;
                    s += 2;
                }
                else if (len == 6   /* len is the same in both ASCII and EBCDIC for these */
                         && (memEQ(s, GREEK_SMALL_LETTER_IOTA_UTF8
                                      COMBINING_DIAERESIS_UTF8
                                      COMBINING_ACUTE_ACCENT_UTF8,
                                   6)
                             || memEQ(s, GREEK_SMALL_LETTER_UPSILON_UTF8
                                         COMBINING_DIAERESIS_UTF8
                                         COMBINING_ACUTE_ACCENT_UTF8,
                                     6)))
                {
                    count = 3;
d2830 7
a2836 14
                    /* These two folds require special handling by trie's, so
                     * change the node type to indicate this.  If EXACTFA and
                     * EXACTFL were ever to be handled by trie's, this would
                     * have to be changed.  If this node has already been
                     * changed to EXACTFU_SS in this loop, leave it as is.  (I
                     * (khw) think it doesn't matter in regexec.c for UTF
                     * patterns, but no need to change it */
                    if (OP(scan) == EXACTFU) {
                        OP(scan) = EXACTFU_TRICKYFOLD;
                    }
                    s += 6;
                }
                else { /* Here is a generic multi-char fold. */
                    const U8* multi_end  = s + len;
d2838 8
a2845 26
                    /* Count how many characters in it.  In the case of /l and
                     * /aa, no folds which contain ASCII code points are
                     * allowed, so check for those, and skip if found.  (In
                     * EXACTFL, no folds are allowed to any Latin1 code point,
                     * not just ASCII.  But there aren't any of these
                     * currently, nor ever likely, so don't take the time to
                     * test for them.  The code that generates the
                     * is_MULTI_foo() macros croaks should one actually get put
                     * into Unicode .) */
                    if (OP(scan) != EXACTFL && OP(scan) != EXACTFA) {
                        count = utf8_length(s, multi_end);
                        s = multi_end;
                    }
                    else {
                        while (s < multi_end) {
                            if (isASCII(*s)) {
                                s++;
                                goto next_iteration;
                            }
                            else {
                                s += UTF8SKIP(s);
                            }
                            count++;
                        }
                    }
                }
d2847 14
a2860 4
                /* The delta is how long the sequence is minus 1 (1 is how long
                 * the character that folds to the sequence is) */
                *min_subtract += count - 1;
            next_iteration: ;
d2865 4
a2868 7
            /* Here, the pattern is not UTF-8.  Look for the multi-char folds
             * that are all ASCII.  As in the above case, EXACTFL and EXACTFA
             * nodes can't have multi-char folds to this range (and there are
             * no existing ones in the upper latin1 range).  In the EXACTF
             * case we look also for the sharp s, which can be in the final
             * position.  Otherwise we can stop looking 1 byte earlier because
             * have to find at least two characters for a multi-fold */
d2871 8
a2878 20
            /* The below is perhaps overboard, but this allows us to save a
             * test each time through the loop at the expense of a mask.  This
             * is because on both EBCDIC and ASCII machines, 'S' and 's' differ
             * by a single bit.  On ASCII they are 32 apart; on EBCDIC, they
             * are 64.  This uses an exclusive 'or' to find that bit and then
             * inverts it to form a mask, with just a single 0, in the bit
             * position where 'S' and 's' differ. */
            const U8 S_or_s_mask = (U8) ~ ('S' ^ 's');
            const U8 s_masked = 's' & S_or_s_mask;

	    while (s < upper) {
                int len = is_MULTI_CHAR_FOLD_latin1_safe(s, s_end);
                if (! len) {    /* Not a multi-char fold. */
                    if (*s == LATIN_SMALL_LETTER_SHARP_S && OP(scan) == EXACTF)
                    {
                        *has_exactf_sharp_s = TRUE;
                    }
                    s++;
                    continue;
                }
d2880 17
a2896 13
                if (len == 2
                    && ((*s & S_or_s_mask) == s_masked)
                    && ((*(s+1) & S_or_s_mask) == s_masked))
                {

                    /* EXACTF nodes need to know that the minimum length
                     * changed so that a sharp s in the string can match this
                     * ss in the pattern, but they remain EXACTF nodes, as they
                     * won't match this unless the target string is is UTF-8,
                     * which we don't know until runtime */
                    if (OP(scan) != EXACTF) {
                        OP(scan) = EXACTFU_SS;
                    }
a2897 3

                *min_subtract += len - 1;
                s += len;
d2942 28
d2988 1
a2988 2
    I32 min = 0;    /* There must be at least this number of characters to match */
    I32 pars = 0, code;
d3015 3
a3017 3
        UV min_subtract = 0;    /* How mmany chars to subtract from the minimum
                                   node length to get a real minimum (because
                                   the folded version may be shorter) */
d3106 3
a3108 1
		    if (deltanext == I32_MAX) {
a3109 3
			max1 = I32_MAX;
		    } else if (max1 < minnext + deltanext)
			max1 = minnext + deltanext;
d3132 1
a3132 4
		    if (data->pos_delta >= I32_MAX - (max1 - min1))
		        data->pos_delta = I32_MAX;
		    else
		        data->pos_delta += max1 - min1;
d3137 1
a3137 4
		if (delta == I32_MAX || I32_MAX - delta - (max1 - min1) < 0)
		    delta = I32_MAX;
		else
		    delta += max1 - min1;
d3160 1
a3160 1
                        SET_SSC_EOS(data->start_class);
d3237 1
a3237 1
                        DEBUG_TRIE_COMPILE_r({
a3302 2
			    U8 noper_next_type = (noper_next && noper_next != tail) ? OP(noper_next) : 0;
			    U8 noper_next_trietype = (noper_next && noper_next != tail) ? TRIE_TYPE( noper_next_type ) :0;
d3305 1
a3305 1
                            DEBUG_TRIE_COMPILE_r({
d3319 2
a3320 4
                                PerlIO_printf( Perl_debug_log, "(First==%d,Last==%d,Cur==%d,tt==%s,nt==%s,nnt==%s)\n",
                                   REG_NODE_NUM(first), REG_NODE_NUM(last), REG_NODE_NUM(cur),
				   PL_reg_name[trietype], PL_reg_name[noper_trietype], PL_reg_name[noper_next_trietype] 
				);
d3328 16
a3343 2
                                        ( noper_trietype == NOTHING)
                                        || ( trietype == NOTHING )
d3355 1
d3358 1
a3358 17
				    if ( noper_trietype == NOTHING ) {
#if !defined(DEBUGGING) && !defined(NOJUMPTRIE)
					regnode * const noper_next = regnext( noper );
                                        U8 noper_next_type = (noper_next && noper_next!=tail) ? OP(noper_next) : 0;
					U8 noper_next_trietype = noper_next_type ? TRIE_TYPE( noper_next_type ) :0;
#endif

                                        if ( noper_next_trietype ) {
					    trietype = noper_next_trietype;
                                        } else if (noper_next_type)  {
                                            /* a NOTHING regop is 1 regop wide. We need at least two
                                             * for a trie so we can't merge this in */
                                            first = NULL;
                                        }
                                    } else {
                                        trietype = noper_trietype;
                                    }
a3363 2
				if (first)
				    count++;
d3375 1
a3375 1
                                    if ( trietype && trietype != NOTHING )
d3399 1
a3399 1
                        DEBUG_TRIE_COMPILE_r({
d3406 5
a3410 6
                        if ( last && trietype ) {
                            if ( trietype != NOTHING ) {
                                /* the last branch of the sequence was part of a trie,
                                 * so we have to construct it here outside of the loop
                                 */
                                made= make_trie( pRExC_state, startbranch, first, scan, tail, count, trietype, depth+1 );
d3412 9
a3420 10
                                if ( ((made == MADE_EXACT_TRIE &&
                                     startbranch == first)
                                     || ( first_non_open == first )) &&
                                     depth==0 ) {
                                    flags |= SCF_TRIE_RESTUDY;
                                    if ( startbranch == first
                                         && scan == tail )
                                    {
                                        RExC_seen &=~REG_TOP_LEVEL_BRANCHES;
                                    }
d3422 1
a3423 21
                            } else {
                                /* at this point we know whatever we have is a NOTHING sequence/branch
                                 * AND if 'startbranch' is 'first' then we can turn the whole thing into a NOTHING
                                 */
                                if ( startbranch == first ) {
                                    regnode *opt;
                                    /* the entire thing is a NOTHING sequence, something like this:
                                     * (?:|) So we can turn it into a plain NOTHING op. */
                                    DEBUG_TRIE_COMPILE_r({
                                        regprop(RExC_rx, mysv, cur);
                                        PerlIO_printf( Perl_debug_log,
                                          "%*s- %s (%d) <NOTHING BRANCH SEQUENCE>\n", (int)depth * 2 + 2,
                                          "", SvPV_nolen_const( mysv ),REG_NODE_NUM(cur));

                                    });
                                    OP(startbranch)= NOTHING;
                                    NEXT_OFF(startbranch)= tail - startbranch;
                                    for ( opt= startbranch + 1; opt < tail ; opt++ )
                                        OP(opt)= OPTIMIZED;
                                }
                            }
d3539 1
a3539 1
		    (!(data->start_class->flags & ANYOF_LOCALE)
d3541 1
a3541 1
		    && (!(data->start_class->flags & ANYOF_LOC_FOLD)
d3562 1
a3562 1
			if (HAS_NONLATIN1_FOLD_CLOSURE(i)) {
d3567 1
a3567 1
                CLEAR_SSC_EOS(data->start_class);
d3577 1
a3577 1
                CLEAR_SSC_EOS(data->start_class);
d3596 1
a3596 1
	    if (has_exactf_sharp_s) {
d3600 3
a3602 1
            assert (min >= 0);
d3618 1
a3618 1
		 (!(data->start_class->flags & ANYOF_LOCALE)
d3628 2
a3629 1
                    CLEAR_SSC_EOS(data->start_class);
d3634 1
a3634 1
			data->start_class->flags |= ANYOF_LOCALE|ANYOF_LOC_FOLD;
d3669 1
a3669 1
		if (data->start_class->flags & ANYOF_LOC_FOLD) {
d3696 1
a3696 1
                    CLEAR_SSC_EOS(data->start_class);
d3813 1
a3813 1
                        SET_SSC_EOS(data->start_class);
a3831 2
		    /* Fatal warnings may leak the regexp without this: */
		    SAVEFREESV(RExC_rx_sv);
a3833 1
		    (void)ReREFCNT_inc(RExC_rx_sv);
d3837 3
a3839 2
		is_inf_internal |= deltanext == I32_MAX
				     || (maxcount == REG_INFTY && minnext + deltanext > 0);
d3841 1
a3841 4
		if (is_inf)
		    delta = I32_MAX;
		else
		    delta += (minnext + deltanext) * maxcount - minnext * mincount;
a3892 1
                      && ! (RExC_seen & REG_SEEN_EXACTF_SHARP_S) /* Nor \xDF */
d4025 1
a4025 10
#if 0
PerlIO_printf(Perl_debug_log, "counted=%d deltanext=%d I32_MAX=%d minnext=%d maxcount=%d mincount=%d\n",
    counted, deltanext, I32_MAX, minnext, maxcount, mincount);
if (deltanext != I32_MAX)
PerlIO_printf(Perl_debug_log, "LHS=%d RHS=%d\n", -counted * deltanext + (minnext + deltanext) * maxcount - minnext * mincount, I32_MAX - data->pos_delta);
#endif
		    if (deltanext == I32_MAX || -counted * deltanext + (minnext + deltanext) * maxcount - minnext * mincount >= I32_MAX - data->pos_delta)
		        data->pos_delta = I32_MAX;
		    else
		        data->pos_delta += - counted * deltanext +
d4060 1
a4060 1
	    default:			/* REF, and CLUMP only? */
d4075 1
a4075 1
                CLEAR_SSC_EOS(data->start_class); /* No match on empty */
d4090 2
a4091 2
	    min++;
	    delta++;    /* Because of the 2 char string cr-lf */
d4108 1
a4108 2
                int loop_max = 256;
                CLEAR_SSC_EOS(data->start_class); /* No match on empty */
a4112 2
                    U8 classnum;

d4115 2
a4116 4
#ifdef DEBUGGING
                   Perl_croak(aTHX_ "panic: unexpected simple REx opcode %d", OP(scan));
#endif
                 do_default:
d4125 1
a4125 1
				|| ANYOF_CLASS_TEST_ANY_SET(data->start_class));
d4139 1
a4139 7
		case POSIXA:
                    loop_max = 128;
                    /* FALL THROUGH */
		case POSIXL:
		case POSIXD:
		case POSIXU:
                    classnum = FLAGS(scan);
d4142 12
a4153 4
			    ANYOF_CLASS_CLEAR(data->start_class, classnum_to_namedclass(classnum) + 1);
                            for (value = 0; value < loop_max; value++) {
                                if (! _generic_isCC(UNI_TO_NATIVE(value), classnum)) {
                                    ANYOF_BITMAP_CLEAR(data->start_class, UNI_TO_NATIVE(value));
d4159 2
a4160 4
			if (data->start_class->flags & ANYOF_LOCALE) {
			    ANYOF_CLASS_SET(data->start_class, classnum_to_namedclass(classnum));
                        }
                        else {
d4165 11
a4175 3
                        for (value = 0; value < loop_max; value++) {
                            if (_generic_isCC(UNI_TO_NATIVE(value), classnum)) {
                                ANYOF_BITMAP_SET(data->start_class, UNI_TO_NATIVE(value));
a4177 1
                        }
d4180 1
a4180 7
		case NPOSIXA:
                    loop_max = 128;
                    /* FALL THROUGH */
		case NPOSIXL:
		case NPOSIXU:
		case NPOSIXD:
                    classnum = FLAGS(scan);
d4183 12
a4194 4
			    ANYOF_CLASS_CLEAR(data->start_class, classnum_to_namedclass(classnum));
                            for (value = 0; value < loop_max; value++) {
                                if (_generic_isCC(UNI_TO_NATIVE(value), classnum)) {
                                    ANYOF_BITMAP_CLEAR(data->start_class, UNI_TO_NATIVE(value));
d4196 1
a4196 1
                            }
d4200 2
a4201 4
			if (data->start_class->flags & ANYOF_LOCALE) {
			    ANYOF_CLASS_SET(data->start_class, classnum_to_namedclass(classnum) + 1);
                        }
                        else {
d4206 31
a4236 3
                        for (value = 0; value < loop_max; value++) {
                            if (! _generic_isCC(UNI_TO_NATIVE(value), classnum)) {
                                ANYOF_BITMAP_SET(data->start_class, UNI_TO_NATIVE(value));
d4238 5
d4244 43
a4286 2
                        if (PL_regkind[OP(scan)] == NPOSIXD) {
                            data->start_class->flags |= ANYOF_NON_UTF8_LATIN1_ALL;
d4288 6
d4297 36
a4342 2
	    SCAN_COMMIT(pRExC_state, data, minlenp);

a4347 26
            if ( OP(scan) == UNLESSM &&
                 scan->flags == 0 &&
                 OP(NEXTOPER(NEXTOPER(scan))) == NOTHING &&
                 OP(regnext(NEXTOPER(NEXTOPER(scan)))) == SUCCEED
            ) {
                regnode *opt;
                regnode *upto= regnext(scan);
                DEBUG_PARSE_r({
                    SV * const mysv_val=sv_newmortal();
                    DEBUG_STUDYDATA("OPFAIL",data,depth);

                    /*DEBUG_PARSE_MSG("opfail");*/
                    regprop(RExC_rx, mysv_val, upto);
                    PerlIO_printf(Perl_debug_log, "~ replace with OPFAIL pointed at %s (%"IVdf") offset %"IVdf"\n",
                                  SvPV_nolen_const(mysv_val),
                                  (IV)REG_NODE_NUM(upto),
                                  (IV)(upto - scan)
                    );
                });
                OP(scan) = OPFAIL;
                NEXT_OFF(scan) = upto - scan;
                for (opt= scan + 1; opt < upto ; opt++)
                    OP(opt) = OPTIMIZED;
                scan= upto;
                continue;
            }
d4407 1
a4407 1
			const int was = TEST_SSC_EOS(data->start_class);
d4411 1
a4411 1
                            SET_SSC_EOS(data->start_class);
d4479 1
a4479 1
                    const int was = TEST_SSC_EOS(data.start_class);
d4483 1
a4483 1
                        SET_SSC_EOS(data->start_class);
d4495 1
a4495 1
                        SvREFCNT_dec_NN(data_fake.last_found);
d4512 2
d4635 3
a4637 1
                    if (deltanext == I32_MAX) {
a4638 3
                        max1 = I32_MAX;
                    } else if (max1 < (I32)(minnext + deltanext + trie->maxlen))
                        max1 = minnext + deltanext + trie->maxlen;
d4688 1
a4688 1
                    SET_SSC_EOS(data->start_class);
d4804 1
a4804 2
#define CHECK_RESTUDY_GOTO_butfirst(dOsomething)            \
    STMT_START {                                            \
d4808 1
a4808 5
        ) {                                                 \
            dOsomething;                                    \
            goto reStudy;                                   \
        }                                                   \
    } STMT_END
d4810 1
a4810 1
#define CHECK_RESTUDY_GOTO_butfirst
d4814 10
a4823 1
 * pregcomp - compile a regular expression into internal code
d4825 2
a4826 2
 * Decides which engine's compiler to call based on the hint currently in
 * scope
a4828 1
#ifndef PERL_IN_XSUB_RE 
a4829 28
/* return the currently in-scope regex engine (or the default if none)  */

regexp_engine const *
Perl_current_re_engine(pTHX)
{
    dVAR;

    if (IN_PERL_COMPILETIME) {
	HV * const table = GvHV(PL_hintgv);
	SV **ptr;

	if (!table)
	    return &PL_core_reg_engine;
	ptr = hv_fetchs(table, "regcomp", FALSE);
	if ( !(ptr && SvIOK(*ptr) && SvIV(*ptr)))
	    return &PL_core_reg_engine;
	return INT2PTR(regexp_engine*,SvIV(*ptr));
    }
    else {
	SV *ptr;
	if (!PL_curcop->cop_hints_hash)
	    return &PL_core_reg_engine;
	ptr = cop_hints_fetch_pvs(PL_curcop, "regcomp", 0);
	if ( !(ptr && SvIOK(ptr) && SvIV(ptr)))
	    return &PL_core_reg_engine;
	return INT2PTR(regexp_engine*,SvIV(ptr));
    }
}
d4831 6
d4838 1
d4843 1
a4843 2
    regexp_engine const *eng = current_re_engine();
    GET_RE_DEBUG_FLAGS_DECL;
d4847 15
a4861 6
    /* Dispatch a request to compile a regexp to correct regexp engine. */
    DEBUG_COMPILE_r({
	PerlIO_printf(Perl_debug_log, "Using engine %"UVxf"\n",
			PTR2UV(eng));
    });
    return CALLREGCOMP_ENG(eng, pattern, flags);
a4864 5
/* public(ish) entry point for the perl core's own regex compiling code.
 * It's actually a wrapper for Perl_re_op_compile that only takes an SV
 * pattern rather than a list of OPs, and uses the internal engine rather
 * than the current one */

d4866 1
a4866 1
Perl_re_compile(pTHX_ SV * const pattern, U32 rx_flags)
d4868 31
a4898 1
    SV *pat = pattern; /* defeat constness! */
a4899 8
    return Perl_re_op_compile(aTHX_ &pat, 1, NULL,
#ifdef PERL_IN_XSUB_RE
                                &my_reg_engine,
#else
                                &PL_core_reg_engine,
#endif
                                NULL, NULL, rx_flags, 0);
}
d4901 1
d4903 7
a4909 6
/* upgrade pattern pat_p of length plen_p to UTF8, and if there are code
 * blocks, recalculate the indices. Update pat_p and plen_p in-place to
 * point to the realloced string and length.
 *
 * This is essentially a copy of Perl_bytes_to_utf8() with the code index
 * stuff added */
d4911 2
a4912 10
static void
S_pat_upgrade_to_utf8(pTHX_ RExC_state_t * const pRExC_state,
		    char **pat_p, STRLEN *plen_p, int num_code_blocks)
{
    U8 *const src = (U8*)*pat_p;
    U8 *dst;
    int n=0;
    STRLEN s = 0, d = 0;
    bool do_end = 0;
    GET_RE_DEBUG_FLAGS_DECL;
d4914 2
a4915 2
    DEBUG_PARSE_r(PerlIO_printf(Perl_debug_log,
        "UTF8 mismatch! Converting to utf8 for resizing and compile\n"));
d4917 2
a4918 32
    Newx(dst, *plen_p * 2 + 1, U8);

    while (s < *plen_p) {
        const UV uv = NATIVE_TO_ASCII(src[s]);
        if (UNI_IS_INVARIANT(uv))
            dst[d]   = (U8)UTF_TO_NATIVE(uv);
        else {
            dst[d++] = (U8)UTF8_EIGHT_BIT_HI(uv);
            dst[d]   = (U8)UTF8_EIGHT_BIT_LO(uv);
        }
        if (n < num_code_blocks) {
            if (!do_end && pRExC_state->code_blocks[n].start == s) {
                pRExC_state->code_blocks[n].start = d;
                assert(dst[d] == '(');
                do_end = 1;
            }
            else if (do_end && pRExC_state->code_blocks[n].end == s) {
                pRExC_state->code_blocks[n].end = d;
                assert(dst[d] == ')');
                do_end = 0;
                n++;
            }
        }
        s++;
        d++;
    }
    dst[d] = '\0';
    *plen_p = d;
    *pat_p = (char*) dst;
    SAVEFREEPV(*pat_p);
    RExC_orig_utf8 = RExC_utf8 = 1;
}
d4920 1
d4922 2
d4925 1
a4925 76
/* S_concat_pat(): concatenate a list of args to the pattern string pat,
 * while recording any code block indices, and handling overloading,
 * nested qr// objects etc.  If pat is null, it will allocate a new
 * string, or just return the first arg, if there's only one.
 *
 * Returns the malloced/updated pat.
 * patternp and pat_count is the array of SVs to be concatted;
 * oplist is the optional list of ops that generated the SVs;
 * recompile_p is a pointer to a boolean that will be set if
 *   the regex will need to be recompiled.
 * delim, if non-null is an SV that will be inserted between each element
 */

static SV*
S_concat_pat(pTHX_ RExC_state_t * const pRExC_state,
                SV *pat, SV ** const patternp, int pat_count,
                OP *oplist, bool *recompile_p, SV *delim)
{
    SV **svp;
    int n = 0;
    bool use_delim = FALSE;
    bool alloced = FALSE;

    /* if we know we have at least two args, create an empty string,
     * then concatenate args to that. For no args, return an empty string */
    if (!pat && pat_count != 1) {
        pat = newSVpvn("", 0);
        SAVEFREESV(pat);
        alloced = TRUE;
    }

    for (svp = patternp; svp < patternp + pat_count; svp++) {
        SV *sv;
        SV *rx  = NULL;
        STRLEN orig_patlen = 0;
        bool code = 0;
        SV *msv = use_delim ? delim : *svp;

        /* if we've got a delimiter, we go round the loop twice for each
         * svp slot (except the last), using the delimiter the second
         * time round */
        if (use_delim) {
            svp--;
            use_delim = FALSE;
        }
        else if (delim)
            use_delim = TRUE;

        if (SvTYPE(msv) == SVt_PVAV) {
            /* we've encountered an interpolated array within
             * the pattern, e.g. /...@@a..../. Expand the list of elements,
             * then recursively append elements.
             * The code in this block is based on S_pushav() */

            AV *const av = (AV*)msv;
            const I32 maxarg = AvFILL(av) + 1;
            SV **array;

            if (oplist) {
                assert(oplist->op_type == OP_PADAV
                    || oplist->op_type == OP_RV2AV); 
                oplist = oplist->op_sibling;;
            }

            if (SvRMAGICAL(av)) {
                U32 i;

                Newx(array, maxarg, SV*);
                SAVEFREEPV(array);
                for (i=0; i < (U32)maxarg; i++) {
                    SV ** const svp = av_fetch(av, i, FALSE);
                    array[i] = svp ? *svp : &PL_sv_undef;
                }
            }
            else
                array = AvARRAY(av);
d4927 2
a4928 4
            pat = S_concat_pat(aTHX_ pRExC_state, pat,
                                array, maxarg, NULL, recompile_p,
                                /* $" */
                                GvSV((gv_fetchpvs("\"", GV_ADDMULTI, SVt_PV))));
d4930 2
a4931 2
            continue;
        }
d4933 2
d4936 2
a4937 41
        /* we make the assumption here that each op in the list of
         * op_siblings maps to one SV pushed onto the stack,
         * except for code blocks, with have both an OP_NULL and
         * and OP_CONST.
         * This allows us to match up the list of SVs against the
         * list of OPs to find the next code block.
         *
         * Note that       PUSHMARK PADSV PADSV ..
         * is optimised to
         *                 PADRANGE PADSV  PADSV  ..
         * so the alignment still works. */

        if (oplist) {
            if (oplist->op_type == OP_NULL
                && (oplist->op_flags & OPf_SPECIAL))
            {
                assert(n < pRExC_state->num_code_blocks);
                pRExC_state->code_blocks[n].start = pat ? SvCUR(pat) : 0;
                pRExC_state->code_blocks[n].block = oplist;
                pRExC_state->code_blocks[n].src_regex = NULL;
                n++;
                code = 1;
                oplist = oplist->op_sibling; /* skip CONST */
                assert(oplist);
            }
            oplist = oplist->op_sibling;;
        }

	/* apply magic and QR overloading to arg */

        SvGETMAGIC(msv);
        if (SvROK(msv) && SvAMAGIC(msv)) {
            SV *sv = AMG_CALLunary(msv, regexp_amg);
            if (sv) {
                if (SvROK(sv))
                    sv = SvRV(sv);
                if (SvTYPE(sv) != SVt_REGEXP)
                    Perl_croak(aTHX_ "Overloaded qr did not return a REGEXP");
                msv = sv;
            }
        }
d4939 2
a4940 43
        /* try concatenation overload ... */
        if (pat && (SvAMAGIC(pat) || SvAMAGIC(msv)) &&
                (sv = amagic_call(pat, msv, concat_amg, AMGf_assign)))
        {
            sv_setsv(pat, sv);
            /* overloading involved: all bets are off over literal
             * code. Pretend we haven't seen it */
            pRExC_state->num_code_blocks -= n;
            n = 0;
        }
        else  {
            /* ... or failing that, try "" overload */
            while (SvAMAGIC(msv)
                    && (sv = AMG_CALLunary(msv, string_amg))
                    && sv != msv
                    &&  !(   SvROK(msv)
                          && SvROK(sv)
                          && SvRV(msv) == SvRV(sv))
            ) {
                msv = sv;
                SvGETMAGIC(msv);
            }
            if (SvROK(msv) && SvTYPE(SvRV(msv)) == SVt_REGEXP)
                msv = SvRV(msv);

            if (pat) {
                /* this is a partially unrolled
                 *     sv_catsv_nomg(pat, msv);
                 * that allows us to adjust code block indices if
                 * needed */
                STRLEN dlen;
                char *dst = SvPV_force_nomg(pat, dlen);
                orig_patlen = dlen;
                if (SvUTF8(msv) && !SvUTF8(pat)) {
                    S_pat_upgrade_to_utf8(aTHX_ pRExC_state, &dst, &dlen, n);
                    sv_setpvn(pat, dst, dlen);
                    SvUTF8_on(pat);
                }
                sv_catsv_nomg(pat, msv);
                rx = msv;
            }
            else
                pat = msv;
d4942 2
a4943 3
            if (code)
                pRExC_state->code_blocks[n-1].end = SvCUR(pat)-1;
        }
d4945 2
a4946 4
        /* extract any code blocks within any embedded qr//'s */
        if (rx && SvTYPE(rx) == SVt_REGEXP
            && RX_ENGINE((REGEXP*)rx)->op_comp)
        {
d4948 2
a4949 38
            RXi_GET_DECL(ReANY((REGEXP *)rx), ri);
            if (ri->num_code_blocks) {
                int i;
                /* the presence of an embedded qr// with code means
                 * we should always recompile: the text of the
                 * qr// may not have changed, but it may be a
                 * different closure than last time */
                *recompile_p = 1;
                Renew(pRExC_state->code_blocks,
                    pRExC_state->num_code_blocks + ri->num_code_blocks,
                    struct reg_code_block);
                pRExC_state->num_code_blocks += ri->num_code_blocks;

                for (i=0; i < ri->num_code_blocks; i++) {
                    struct reg_code_block *src, *dst;
                    STRLEN offset =  orig_patlen
                        + ReANY((REGEXP *)rx)->pre_prefix;
                    assert(n < pRExC_state->num_code_blocks);
                    src = &ri->code_blocks[i];
                    dst = &pRExC_state->code_blocks[n];
                    dst->start	    = src->start + offset;
                    dst->end	    = src->end   + offset;
                    dst->block	    = src->block;
                    dst->src_regex  = (REGEXP*) SvREFCNT_inc( (SV*)
                                            src->src_regex
                                                ? src->src_regex
                                                : (REGEXP*)rx);
                    n++;
                }
            }
        }
    }
    /* avoid calling magic multiple times on a single element e.g. =~ $qr */
    if (alloced)
        SvSETMAGIC(pat);

    return pat;
}
d4951 1
d4953 2
d4956 2
a4957 25
/* see if there are any run-time code blocks in the pattern.
 * False positives are allowed */

static bool
S_has_runtime_code(pTHX_ RExC_state_t * const pRExC_state,
		    char *pat, STRLEN plen)
{
    int n = 0;
    STRLEN s;

    for (s = 0; s < plen; s++) {
	if (n < pRExC_state->num_code_blocks
	    && s == pRExC_state->code_blocks[n].start)
	{
	    s = pRExC_state->code_blocks[n].end;
	    n++;
	    continue;
	}
	/* TODO ideally should handle [..], (#..), /#.../x to reduce false
	 * positives here */
	if (pat[s] == '(' && s+2 <= plen && pat[s+1] == '?' &&
	    (pat[s+2] == '{'
                || (s + 2 <= plen && pat[s+2] == '?' && pat[s+3] == '{'))
	)
	    return 1;
d4959 1
a4959 31
    return 0;
}

/* Handle run-time code blocks. We will already have compiled any direct
 * or indirect literal code blocks. Now, take the pattern 'pat' and make a
 * copy of it, but with any literal code blocks blanked out and
 * appropriate chars escaped; then feed it into
 *
 *    eval "qr'modified_pattern'"
 *
 * For example,
 *
 *       a\bc(?{"this was literal"})def'ghi\\jkl(?{"this is runtime"})mno
 *
 * becomes
 *
 *    qr'a\\bc_______________________def\'ghi\\\\jkl(?{"this is runtime"})mno'
 *
 * After eval_sv()-ing that, grab any new code blocks from the returned qr
 * and merge them with any code blocks of the original regexp.
 *
 * If the pat is non-UTF8, while the evalled qr is UTF8, don't merge;
 * instead, just save the qr and return FALSE; this tells our caller that
 * the original pattern needs upgrading to utf8.
 */

static bool
S_compile_runtime_code(pTHX_ RExC_state_t * const pRExC_state,
    char *pat, STRLEN plen)
{
    SV *qr;
d4961 1
a4961 1
    GET_RE_DEBUG_FLAGS_DECL;
d4963 2
a4964 9
    if (pRExC_state->runtime_code_qr) {
	/* this is the second time we've been called; this should
	 * only happen if the main pattern got upgraded to utf8
	 * during compilation; re-use the qr we compiled first time
	 * round (which should be utf8 too)
	 */
	qr = pRExC_state->runtime_code_qr;
	pRExC_state->runtime_code_qr = NULL;
	assert(RExC_utf8 && SvUTF8(qr));
d4967 1
a4967 79
	int n = 0;
	STRLEN s;
	char *p, *newpat;
	int newlen = plen + 6; /* allow for "qr''x\0" extra chars */
	SV *sv, *qr_ref;
	dSP;

	/* determine how many extra chars we need for ' and \ escaping */
	for (s = 0; s < plen; s++) {
	    if (pat[s] == '\'' || pat[s] == '\\')
		newlen++;
	}

	Newx(newpat, newlen, char);
	p = newpat;
	*p++ = 'q'; *p++ = 'r'; *p++ = '\'';

	for (s = 0; s < plen; s++) {
	    if (n < pRExC_state->num_code_blocks
		&& s == pRExC_state->code_blocks[n].start)
	    {
		/* blank out literal code block */
		assert(pat[s] == '(');
		while (s <= pRExC_state->code_blocks[n].end) {
		    *p++ = '_';
		    s++;
		}
		s--;
		n++;
		continue;
	    }
	    if (pat[s] == '\'' || pat[s] == '\\')
		*p++ = '\\';
	    *p++ = pat[s];
	}
	*p++ = '\'';
	if (pRExC_state->pm_flags & RXf_PMf_EXTENDED)
	    *p++ = 'x';
	*p++ = '\0';
	DEBUG_COMPILE_r({
	    PerlIO_printf(Perl_debug_log,
		"%sre-parsing pattern for runtime code:%s %s\n",
		PL_colors[4],PL_colors[5],newpat);
	});

	sv = newSVpvn_flags(newpat, p-newpat-1, RExC_utf8 ? SVf_UTF8 : 0);
	Safefree(newpat);

	ENTER;
	SAVETMPS;
	save_re_context();
	PUSHSTACKi(PERLSI_REQUIRE);
        /* G_RE_REPARSING causes the toker to collapse \\ into \ when
         * parsing qr''; normally only q'' does this. It also alters
         * hints handling */
	eval_sv(sv, G_SCALAR|G_RE_REPARSING);
	SvREFCNT_dec_NN(sv);
	SPAGAIN;
	qr_ref = POPs;
	PUTBACK;
	{
	    SV * const errsv = ERRSV;
	    if (SvTRUE_NN(errsv))
	    {
		Safefree(pRExC_state->code_blocks);
                /* use croak_sv ? */
		Perl_croak_nocontext("%s", SvPV_nolen_const(errsv));
	    }
	}
	assert(SvROK(qr_ref));
	qr = SvRV(qr_ref);
	assert(SvTYPE(qr) == SVt_REGEXP && RX_ENGINE((REGEXP*)qr)->op_comp);
	/* the leaving below frees the tmp qr_ref.
	 * Give qr a life of its own */
	SvREFCNT_inc(qr);
	POPSTACK;
	FREETMPS;
	LEAVE;

d4969 2
d4972 5
a4976 6
    if (!RExC_utf8 && SvUTF8(qr)) {
	/* first time through; the pattern got upgraded; save the
	 * qr for the next time through */
	assert(!pRExC_state->runtime_code_qr);
	pRExC_state->runtime_code_qr = qr;
	return 0;
d4979 2
d4982 10
a4991 9
    /* extract any code blocks within the returned qr//  */


    /* merge the main (r1) and run-time (r2) code blocks into one */
    {
	RXi_GET_DECL(ReANY((REGEXP *)qr), r2);
	struct reg_code_block *new_block, *dst;
	RExC_state_t * const r1 = pRExC_state; /* convenient alias */
	int i1 = 0, i2 = 0;
d4993 5
a4997 4
	if (!r2->num_code_blocks) /* we guessed wrong */
	{
	    SvREFCNT_dec_NN(qr);
	    return 1;
d5000 1
a5000 4
	Newx(new_block,
	    r1->num_code_blocks + r2->num_code_blocks,
	    struct reg_code_block);
	dst = new_block;
d5002 16
a5017 38
	while (    i1 < r1->num_code_blocks
		|| i2 < r2->num_code_blocks)
	{
	    struct reg_code_block *src;
	    bool is_qr = 0;

	    if (i1 == r1->num_code_blocks) {
		src = &r2->code_blocks[i2++];
		is_qr = 1;
	    }
	    else if (i2 == r2->num_code_blocks)
		src = &r1->code_blocks[i1++];
	    else if (  r1->code_blocks[i1].start
	             < r2->code_blocks[i2].start)
	    {
		src = &r1->code_blocks[i1++];
		assert(src->end < r2->code_blocks[i2].start);
	    }
	    else {
		assert(  r1->code_blocks[i1].start
		       > r2->code_blocks[i2].start);
		src = &r2->code_blocks[i2++];
		is_qr = 1;
		assert(src->end < r1->code_blocks[i1].start);
	    }

	    assert(pat[src->start] == '(');
	    assert(pat[src->end]   == ')');
	    dst->start	    = src->start;
	    dst->end	    = src->end;
	    dst->block	    = src->block;
	    dst->src_regex  = is_qr ? (REGEXP*) SvREFCNT_inc( (SV*) qr)
				    : src->src_regex;
	    dst++;
	}
	r1->num_code_blocks += r2->num_code_blocks;
	Safefree(r1->code_blocks);
	r1->code_blocks = new_block;
d5020 2
a5021 194
    SvREFCNT_dec_NN(qr);
    return 1;
}


STATIC bool
S_setup_longest(pTHX_ RExC_state_t *pRExC_state, SV* sv_longest, SV** rx_utf8, SV** rx_substr, I32* rx_end_shift, I32 lookbehind, I32 offset, I32 *minlen, STRLEN longest_length, bool eol, bool meol)
{
    /* This is the common code for setting up the floating and fixed length
     * string data extracted from Perl_re_op_compile() below.  Returns a boolean
     * as to whether succeeded or not */

    I32 t,ml;

    if (! (longest_length
           || (eol /* Can't have SEOL and MULTI */
               && (! meol || (RExC_flags & RXf_PMf_MULTILINE)))
          )
            /* See comments for join_exact for why REG_SEEN_EXACTF_SHARP_S */
        || (RExC_seen & REG_SEEN_EXACTF_SHARP_S))
    {
        return FALSE;
    }

    /* copy the information about the longest from the reg_scan_data
        over to the program. */
    if (SvUTF8(sv_longest)) {
        *rx_utf8 = sv_longest;
        *rx_substr = NULL;
    } else {
        *rx_substr = sv_longest;
        *rx_utf8 = NULL;
    }
    /* end_shift is how many chars that must be matched that
        follow this item. We calculate it ahead of time as once the
        lookbehind offset is added in we lose the ability to correctly
        calculate it.*/
    ml = minlen ? *(minlen) : (I32)longest_length;
    *rx_end_shift = ml - offset
        - longest_length + (SvTAIL(sv_longest) != 0)
        + lookbehind;

    t = (eol/* Can't have SEOL and MULTI */
         && (! meol || (RExC_flags & RXf_PMf_MULTILINE)));
    fbm_compile(sv_longest, t ? FBMcf_TAIL : 0);

    return TRUE;
}

/*
 * Perl_re_op_compile - the perl internal RE engine's function to compile a
 * regular expression into internal code.
 * The pattern may be passed either as:
 *    a list of SVs (patternp plus pat_count)
 *    a list of OPs (expr)
 * If both are passed, the SV list is used, but the OP list indicates
 * which SVs are actually pre-compiled code blocks
 *
 * The SVs in the list have magic and qr overloading applied to them (and
 * the list may be modified in-place with replacement SVs in the latter
 * case).
 *
 * If the pattern hasn't changed from old_re, then old_re will be
 * returned.
 *
 * eng is the current engine. If that engine has an op_comp method, then
 * handle directly (i.e. we assume that op_comp was us); otherwise, just
 * do the initial concatenation of arguments and pass on to the external
 * engine.
 *
 * If is_bare_re is not null, set it to a boolean indicating whether the
 * arg list reduced (after overloading) to a single bare regex which has
 * been returned (i.e. /$qr/).
 *
 * orig_rx_flags contains RXf_* flags. See perlreapi.pod for more details.
 *
 * pm_flags contains the PMf_* flags, typically based on those from the
 * pm_flags field of the related PMOP. Currently we're only interested in
 * PMf_HAS_CV, PMf_IS_QR, PMf_USE_RE_EVAL.
 *
 * We can't allocate space until we know how big the compiled form will be,
 * but we can't compile it (and thus know how big it is) until we've got a
 * place to put the code.  So we cheat:  we compile it twice, once with code
 * generation turned off and size counting turned on, and once "for real".
 * This also means that we don't allocate space until we are sure that the
 * thing really will compile successfully, and we never have to move the
 * code and thus invalidate pointers into it.  (Note that it has to be in
 * one piece because free() must be able to free it all.) [NB: not true in perl]
 *
 * Beware that the optimization-preparation code in here knows about some
 * of the structure of the compiled regexp.  [I'll say.]
 */

REGEXP *
Perl_re_op_compile(pTHX_ SV ** const patternp, int pat_count,
		    OP *expr, const regexp_engine* eng, REGEXP *old_re,
		     bool *is_bare_re, U32 orig_rx_flags, U32 pm_flags)
{
    dVAR;
    REGEXP *rx;
    struct regexp *r;
    regexp_internal *ri;
    STRLEN plen;
    char *exp;
    regnode *scan;
    I32 flags;
    I32 minlen = 0;
    U32 rx_flags;
    SV *pat;
    SV *code_blocksv = NULL;
    SV** new_patternp = patternp;

    /* these are all flags - maybe they should be turned
     * into a single int with different bit masks */
    I32 sawlookahead = 0;
    I32 sawplus = 0;
    I32 sawopen = 0;
    regex_charset initial_charset = get_regex_charset(orig_rx_flags);
    bool recompile = 0;
    bool runtime_code = 0;
    scan_data_t data;
    RExC_state_t RExC_state;
    RExC_state_t * const pRExC_state = &RExC_state;
#ifdef TRIE_STUDY_OPT    
    int restudied = 0;
    RExC_state_t copyRExC_state;
#endif    
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_RE_OP_COMPILE;

    DEBUG_r(if (!PL_colorset) reginitcolors());

#ifndef PERL_IN_XSUB_RE
    /* Initialize these here instead of as-needed, as is quick and avoids
     * having to test them each time otherwise */
    if (! PL_AboveLatin1) {
	PL_AboveLatin1 = _new_invlist_C_array(AboveLatin1_invlist);
	PL_ASCII = _new_invlist_C_array(ASCII_invlist);
	PL_Latin1 = _new_invlist_C_array(Latin1_invlist);

	PL_L1Posix_ptrs[_CC_ALPHANUMERIC]
                                = _new_invlist_C_array(L1PosixAlnum_invlist);
	PL_Posix_ptrs[_CC_ALPHANUMERIC]
                                = _new_invlist_C_array(PosixAlnum_invlist);

	PL_L1Posix_ptrs[_CC_ALPHA]
                                = _new_invlist_C_array(L1PosixAlpha_invlist);
	PL_Posix_ptrs[_CC_ALPHA] = _new_invlist_C_array(PosixAlpha_invlist);

	PL_Posix_ptrs[_CC_BLANK] = _new_invlist_C_array(PosixBlank_invlist);
	PL_XPosix_ptrs[_CC_BLANK] = _new_invlist_C_array(XPosixBlank_invlist);

        /* Cased is the same as Alpha in the ASCII range */
	PL_L1Posix_ptrs[_CC_CASED] =  _new_invlist_C_array(L1Cased_invlist);
	PL_Posix_ptrs[_CC_CASED] =  _new_invlist_C_array(PosixAlpha_invlist);

	PL_Posix_ptrs[_CC_CNTRL] = _new_invlist_C_array(PosixCntrl_invlist);
	PL_XPosix_ptrs[_CC_CNTRL] = _new_invlist_C_array(XPosixCntrl_invlist);

	PL_Posix_ptrs[_CC_DIGIT] = _new_invlist_C_array(PosixDigit_invlist);
	PL_L1Posix_ptrs[_CC_DIGIT] = _new_invlist_C_array(PosixDigit_invlist);

	PL_L1Posix_ptrs[_CC_GRAPH] = _new_invlist_C_array(L1PosixGraph_invlist);
	PL_Posix_ptrs[_CC_GRAPH] = _new_invlist_C_array(PosixGraph_invlist);

	PL_L1Posix_ptrs[_CC_LOWER] = _new_invlist_C_array(L1PosixLower_invlist);
	PL_Posix_ptrs[_CC_LOWER] = _new_invlist_C_array(PosixLower_invlist);

	PL_L1Posix_ptrs[_CC_PRINT] = _new_invlist_C_array(L1PosixPrint_invlist);
	PL_Posix_ptrs[_CC_PRINT] = _new_invlist_C_array(PosixPrint_invlist);

	PL_L1Posix_ptrs[_CC_PUNCT] = _new_invlist_C_array(L1PosixPunct_invlist);
	PL_Posix_ptrs[_CC_PUNCT] = _new_invlist_C_array(PosixPunct_invlist);

	PL_Posix_ptrs[_CC_SPACE] = _new_invlist_C_array(PerlSpace_invlist);
	PL_XPosix_ptrs[_CC_SPACE] = _new_invlist_C_array(XPerlSpace_invlist);
	PL_Posix_ptrs[_CC_PSXSPC] = _new_invlist_C_array(PosixSpace_invlist);
	PL_XPosix_ptrs[_CC_PSXSPC] = _new_invlist_C_array(XPosixSpace_invlist);

	PL_L1Posix_ptrs[_CC_UPPER] = _new_invlist_C_array(L1PosixUpper_invlist);
	PL_Posix_ptrs[_CC_UPPER] = _new_invlist_C_array(PosixUpper_invlist);

        PL_XPosix_ptrs[_CC_VERTSPACE] = _new_invlist_C_array(VertSpace_invlist);

	PL_Posix_ptrs[_CC_WORDCHAR] = _new_invlist_C_array(PosixWord_invlist);
	PL_L1Posix_ptrs[_CC_WORDCHAR]
                                = _new_invlist_C_array(L1PosixWord_invlist);

	PL_Posix_ptrs[_CC_XDIGIT] = _new_invlist_C_array(PosixXDigit_invlist);
	PL_XPosix_ptrs[_CC_XDIGIT] = _new_invlist_C_array(XPosixXDigit_invlist);

        PL_HasMultiCharFold = _new_invlist_C_array(_Perl_Multi_Char_Folds_invlist);
    }
d5024 1
a5024 153
    pRExC_state->code_blocks = NULL;
    pRExC_state->num_code_blocks = 0;

    if (is_bare_re)
	*is_bare_re = FALSE;

    if (expr && (expr->op_type == OP_LIST ||
		(expr->op_type == OP_NULL && expr->op_targ == OP_LIST))) {
	/* allocate code_blocks if needed */
	OP *o;
	int ncode = 0;

	for (o = cLISTOPx(expr)->op_first; o; o = o->op_sibling)
	    if (o->op_type == OP_NULL && (o->op_flags & OPf_SPECIAL))
		ncode++; /* count of DO blocks */
	if (ncode) {
	    pRExC_state->num_code_blocks = ncode;
	    Newx(pRExC_state->code_blocks, ncode, struct reg_code_block);
	}
    }

    if (!pat_count) {
        /* compile-time pattern with just OP_CONSTs and DO blocks */

        int n;
        OP *o;

        /* find how many CONSTs there are */
        assert(expr);
        n = 0;
        if (expr->op_type == OP_CONST)
            n = 1;
        else
            for (o = cLISTOPx(expr)->op_first; o; o = o->op_sibling) {
                if (o->op_type == OP_CONST)
                    n++;
            }

        /* fake up an SV array */

        assert(!new_patternp);
        Newx(new_patternp, n, SV*);
        SAVEFREEPV(new_patternp);
        pat_count = n;

        n = 0;
        if (expr->op_type == OP_CONST)
            new_patternp[n] = cSVOPx_sv(expr);
        else
            for (o = cLISTOPx(expr)->op_first; o; o = o->op_sibling) {
                if (o->op_type == OP_CONST)
                    new_patternp[n++] = cSVOPo_sv;
            }

    }

    DEBUG_PARSE_r(PerlIO_printf(Perl_debug_log,
        "Assembling pattern from %d elements%s\n", pat_count,
            orig_rx_flags & RXf_SPLIT ? " for split" : ""));

    /* set expr to the first arg op */

    if (pRExC_state->num_code_blocks
         && expr->op_type != OP_CONST)
    {
            expr = cLISTOPx(expr)->op_first;
            assert(   expr->op_type == OP_PUSHMARK
                   || (expr->op_type == OP_NULL && expr->op_targ == OP_PUSHMARK)
                   || expr->op_type == OP_PADRANGE);
            expr = expr->op_sibling;
    }

    pat = S_concat_pat(aTHX_ pRExC_state, NULL, new_patternp, pat_count,
                        expr, &recompile, NULL);

    /* handle bare (possibly after overloading) regex: foo =~ $re */
    {
        SV *re = pat;
        if (SvROK(re))
            re = SvRV(re);
        if (SvTYPE(re) == SVt_REGEXP) {
            if (is_bare_re)
                *is_bare_re = TRUE;
            SvREFCNT_inc(re);
            Safefree(pRExC_state->code_blocks);
            DEBUG_PARSE_r(PerlIO_printf(Perl_debug_log,
                "Precompiled pattern%s\n",
                    orig_rx_flags & RXf_SPLIT ? " for split" : ""));

            return (REGEXP*)re;
        }
    }

    exp = SvPV_nomg(pat, plen);

    if (!eng->op_comp) {
	if ((SvUTF8(pat) && IN_BYTES)
		|| SvGMAGICAL(pat) || SvAMAGIC(pat))
	{
	    /* make a temporary copy; either to convert to bytes,
	     * or to avoid repeating get-magic / overloaded stringify */
	    pat = newSVpvn_flags(exp, plen, SVs_TEMP |
					(IN_BYTES ? 0 : SvUTF8(pat)));
	}
	Safefree(pRExC_state->code_blocks);
	return CALLREGCOMP_ENG(eng, pat, orig_rx_flags);
    }

    /* ignore the utf8ness if the pattern is 0 length */
    RExC_utf8 = RExC_orig_utf8 = (plen == 0 || IN_BYTES) ? 0 : SvUTF8(pat);
    RExC_uni_semantics = 0;
    RExC_contains_locale = 0;
    pRExC_state->runtime_code_qr = NULL;

    DEBUG_COMPILE_r({
            SV *dsv= sv_newmortal();
            RE_PV_QUOTED_DECL(s, RExC_utf8, dsv, exp, plen, 60);
            PerlIO_printf(Perl_debug_log, "%sCompiling REx%s %s\n",
                          PL_colors[4],PL_colors[5],s);
        });

  redo_first_pass:
    /* we jump here if we upgrade the pattern to utf8 and have to
     * recompile */

    if ((pm_flags & PMf_USE_RE_EVAL)
		/* this second condition covers the non-regex literal case,
		 * i.e.  $foo =~ '(?{})'. */
		|| (IN_PERL_COMPILETIME && (PL_hints & HINT_RE_EVAL))
    )
	runtime_code = S_has_runtime_code(aTHX_ pRExC_state, exp, plen);

    /* return old regex if pattern hasn't changed */
    /* XXX: note in the below we have to check the flags as well as the pattern.
     *
     * Things get a touch tricky as we have to compare the utf8 flag independently
     * from the compile flags.
     */

    if (   old_re
        && !recompile
        && !!RX_UTF8(old_re) == !!RExC_utf8
        && ( RX_COMPFLAGS(old_re) == ( orig_rx_flags & RXf_PMf_FLAGCOPYMASK ) )
	&& RX_PRECOMP(old_re)
	&& RX_PRELEN(old_re) == plen
        && memEQ(RX_PRECOMP(old_re), exp, plen)
	&& !runtime_code /* with runtime code, always recompile */ )
    {
        Safefree(pRExC_state->code_blocks);
        return old_re;
    }

    rx_flags = orig_rx_flags;
d5033 1
a5033 1
	set_regex_charset(&rx_flags, REGEX_UNICODE_CHARSET);
d5037 1
a5037 17
    RExC_flags = rx_flags;
    RExC_pm_flags = pm_flags;

    if (runtime_code) {
	if (TAINTING_get && TAINT_get)
	    Perl_croak(aTHX_ "Eval-group in insecure regular expression");

	if (!S_compile_runtime_code(aTHX_ pRExC_state, exp, plen)) {
	    /* whoops, we have a non-utf8 pattern, whilst run-time code
	     * got compiled as utf8. Try again with a utf8 pattern */
            S_pat_upgrade_to_utf8(aTHX_ pRExC_state, &exp, &plen,
                                    pRExC_state->num_code_blocks);
            goto redo_first_pass;
	}
    }
    assert(!pRExC_state->runtime_code_qr);

d5043 1
a5045 1
    RExC_in_multi_char_class = 0;
d5050 1
a5050 1
    RExC_end = exp + plen;
a5065 1
    pRExC_state->code_index = 0;
d5076 3
a5078 10
    /* reg may croak on us, not giving us a chance to free
       pRExC_state->code_blocks.  We cannot SAVEFREEPV it now, as we may
       need it to survive as long as the regexp (qr/(?{})/).
       We must check that code_blocksv is not already set, because we may
       have jumped back to restart the sizing pass. */
    if (pRExC_state->code_blocks && !code_blocksv) {
	code_blocksv = newSV_type(SVt_PV);
	SAVEFREESV(code_blocksv);
	SvPV_set(code_blocksv, (char *)pRExC_state->code_blocks);
	SvLEN_set(code_blocksv, 1); /*sufficient to make sv_clear free it*/
d5080 4
a5083 15
    if (reg(pRExC_state, 0, &flags,1) == NULL) {
        /* It's possible to write a regexp in ascii that represents Unicode
        codepoints outside of the byte range, such as via \x{100}. If we
        detect such a sequence we have to convert the entire pattern to utf8
        and then recompile, as our sizing calculation will have been based
        on 1 byte == 1 character, but we will need to use utf8 to encode
        at least some part of the pattern, and therefore must convert the whole
        thing.
        -- dmq */
        if (flags & RESTART_UTF8) {
            S_pat_upgrade_to_utf8(aTHX_ pRExC_state, &exp, &plen,
                                    pRExC_state->num_code_blocks);
            goto redo_first_pass;
        }
        Perl_croak(aTHX_ "panic: reg returned NULL to re_op_compile for sizing pass, flags=%#X", flags);
a5084 2
    if (code_blocksv)
	SvLEN_set(code_blocksv,0); /* no you can't have it, sv_clear */
d5097 1
a5097 1
	 && get_regex_charset(rx_flags) == REGEX_DEPENDS_CHARSET)
d5099 1
a5099 1
	set_regex_charset(&rx_flags, REGEX_UNICODE_CHARSET);
d5115 1
a5115 1
    r = ReANY(rx);
d5130 2
a5131 17
    r->engine= eng;
    r->extflags = rx_flags;
    RXp_COMPFLAGS(r) = orig_rx_flags & RXf_PMf_FLAGCOPYMASK;

    if (pm_flags & PMf_IS_QR) {
	ri->code_blocks = pRExC_state->code_blocks;
	ri->num_code_blocks = pRExC_state->num_code_blocks;
    }
    else
    {
	int n;
	for (n = 0; n < pRExC_state->num_code_blocks; n++)
	    if (pRExC_state->code_blocks[n].src_regex)
		SAVEFREESV(pRExC_state->code_blocks[n].src_regex);
	SAVEFREEPV(pRExC_state->code_blocks);
    }

d5161 3
a5163 4
        Newx(p, wraplen + 1, char); /* +1 for the ending NUL */
	r->xpv_len_u.xpvlenu_pv = p;
	if (RExC_utf8)
	    SvFLAGS(rx) |= SVf_UTF8;
d5196 1
a5196 1
	SvCUR_set(rx, p - RX_WRAPPED(rx));
d5223 1
a5223 2
    RExC_flags = rx_flags;	/* don't let top level (?i) bleed */
    RExC_pm_flags = pm_flags;
d5225 1
a5225 1
    RExC_end = exp + plen;
a5230 1
    pRExC_state->code_index = 0;
d5232 2
d5237 1
a5237 1
        Perl_croak(aTHX_ "panic: reg returned NULL to re_op_compile for generation pass, flags=%#X", flags);
d5264 5
d5386 1
a5386 1
	    !(r->extflags & RXf_ANCH) && !pRExC_state->num_code_blocks)
d5399 1
a5399 1
	    && !pRExC_state->num_code_blocks) /* May examine pos and $& */
a5433 4
	ENTER_with_name("study_chunk");
	SAVEFREESV(data.longest_fixed);
	SAVEFREESV(data.longest_float);
	SAVEFREESV(data.last_found);
d5448 1
a5448 1
        CHECK_RESTUDY_GOTO_butfirst(LEAVE_with_name("study_chunk"));
d5458 1
d5460 4
d5465 6
d5472 25
a5496 15
        if (! ((SvCUR(data.longest_fixed)  /* ok to leave SvCUR */
                   && data.offset_fixed == data.offset_float_min
                   && SvCUR(data.longest_fixed) == SvCUR(data.longest_float)))
            && S_setup_longest (aTHX_ pRExC_state,
                                    data.longest_float,
                                    &(r->float_utf8),
                                    &(r->float_substr),
                                    &(r->float_end_shift),
                                    data.lookbehind_float,
                                    data.offset_float_min,
                                    data.minlen_float,
                                    longest_float_length,
                                    cBOOL(data.flags & SF_FL_BEFORE_EOL),
                                    cBOOL(data.flags & SF_FL_BEFORE_MEOL)))
        {
d5501 5
a5505 1
	    SvREFCNT_inc_simple_void_NN(data.longest_float);
d5508 1
d5510 1
d5514 4
d5520 6
a5525 11
        if (S_setup_longest (aTHX_ pRExC_state,
                                data.longest_fixed,
                                &(r->anchored_utf8),
                                &(r->anchored_substr),
                                &(r->anchored_end_shift),
                                data.lookbehind_fixed,
                                data.offset_fixed,
                                data.minlen_fixed,
                                longest_fixed_length,
                                cBOOL(data.flags & SF_FIX_BEFORE_EOL),
                                cBOOL(data.flags & SF_FIX_BEFORE_MEOL)))
d5527 20
d5548 5
a5552 1
	    SvREFCNT_inc_simple_void_NN(data.longest_fixed);
d5556 1
a5558 2
	LEAVE_with_name("study_chunk");

d5565 1
a5565 1
	    && ! TEST_SSC_EOS(data.start_class)
d5569 1
a5569 1
	    OP(data.start_class) = ANYOF_SYNTHETIC;
d5632 1
a5632 1
        CHECK_RESTUDY_GOTO_butfirst(NOOP);
d5637 1
a5637 1
	if (! TEST_SSC_EOS(data.start_class)
d5641 1
a5641 1
	    OP(data.start_class) = ANYOF_SYNTHETIC;
d5671 2
a5672 2
        r->extflags |= RXf_NO_INPLACE_SUBST; /* inplace might break the lookbehind */
    if (pRExC_state->num_code_blocks)
a5676 1
    {
a5677 2
        r->extflags |= RXf_NO_INPLACE_SUBST; /* don't understand this! Yves */
    }
a5679 2
    if (pm_flags & PMf_USE_RE_EVAL)
	r->intflags |= PREGf_USE_RE_EVAL;
d5685 15
a5699 1
    {
a5701 2
        regnode *next = NEXTOPER(first);
        U8 nop = OP(next);
d5703 1
a5703 1
        if (PL_regkind[fop] == NOTHING && nop == END)
d5705 1
a5705 1
        else if (PL_regkind[fop] == BOL && nop == END)
d5707 3
a5709 5
        else if (fop == PLUS && PL_regkind[nop] == POSIXD && FLAGS(next) == _CC_SPACE && OP(regnext(first)) == END)
            r->extflags |= RXf_WHITE;
        else if ( r->extflags & RXf_SPLIT && fop == EXACT && STR_LEN(first) == 1 && *(STRING(first)) == ' ' && OP(regnext(first)) == END )
            r->extflags |= (RXf_SKIPWHITE|RXf_WHITE);

d5711 1
a5746 8

#ifdef USE_ITHREADS
    /* under ithreads the ?pat? PMf_USED flag on the pmop is simulated
     * by setting the regexp SV to readonly-only instead. If the
     * pattern's been recompiled, the USEDness should remain. */
    if (old_re && SvREADONLY(old_re))
        SvREADONLY_on(rx);
#endif
d5750 2
d5764 1
a5764 1
        Perl_croak_no_modify();
d5803 1
a5803 1
    struct regexp *const rx = ReANY(r);
d5843 1
a5843 1
    struct regexp *const rx = ReANY(r);
d5853 1
a5853 1
		SvREFCNT_dec_NN(sv);
d5867 1
a5867 1
    struct regexp *const rx = ReANY(r);
d5883 1
a5883 1
    struct regexp *const rx = ReANY(r);
d5919 1
a5919 1
    struct regexp *const rx = ReANY(r);
d5930 1
a5930 1
	    SvREFCNT_dec_NN(ret);
d5943 1
a5943 1
    struct regexp *const rx = ReANY(r);
d5979 1
a5979 1
    struct regexp *const rx = ReANY(r);
a5982 1
    I32 n = paren;
d5986 7
a5992 29
    if (      n == RX_BUFF_IDX_CARET_PREMATCH
           || n == RX_BUFF_IDX_CARET_FULLMATCH
           || n == RX_BUFF_IDX_CARET_POSTMATCH
       )
    {
        bool keepcopy = cBOOL(rx->extflags & RXf_PMf_KEEPCOPY);
        if (!keepcopy) {
            /* on something like
             *    $r = qr/.../;
             *    /$qr/p;
             * the KEEPCOPY is set on the PMOP rather than the regex */
            if (PL_curpm && r == PM_GETRE(PL_curpm))
                 keepcopy = cBOOL(PL_curpm->op_pmflags & PMf_KEEPCOPY);
        }
        if (!keepcopy)
            goto ret_undef;
    }

    if (!rx->subbeg)
        goto ret_undef;

    if (n == RX_BUFF_IDX_CARET_FULLMATCH)
        /* no need to distinguish between them any more */
        n = RX_BUFF_IDX_FULLMATCH;

    if ((n == RX_BUFF_IDX_PREMATCH || n == RX_BUFF_IDX_CARET_PREMATCH)
        && rx->offs[0].start != -1)
    {
        /* $`, ${^PREMATCH} */
d5997 4
a6000 6
    if ((n == RX_BUFF_IDX_POSTMATCH || n == RX_BUFF_IDX_CARET_POSTMATCH)
        && rx->offs[0].end != -1)
    {
        /* $', ${^POSTMATCH} */
	s = rx->subbeg - rx->suboffset + rx->offs[0].end;
	i = rx->sublen + rx->suboffset - rx->offs[0].end;
d6003 3
a6005 3
    if ( 0 <= n && n <= (I32)rx->nparens &&
        (s1 = rx->offs[n].start) != -1 &&
        (t1 = rx->offs[n].end) != -1)
d6007 1
a6007 1
        /* $&, ${^MATCH},  $1 ... */
d6009 1
a6009 1
        s = rx->subbeg + s1 - rx->suboffset;
d6011 2
a6012 1
        goto ret_undef;
a6013 2

    assert(s >= rx->subbeg);
d6016 1
a6016 4
#if NO_TAINT_SUPPORT
        sv_setpvn(sv, s, i);
#else
        const int oldtainted = TAINT_get;
d6019 1
a6019 2
        TAINT_set(oldtainted);
#endif
d6029 1
a6029 1
        if (TAINTING_get) {
d6034 1
a6034 1
                    TAINT;
d6042 1
a6042 1
                    TAINT;
a6048 1
      ret_undef:
d6065 1
a6065 1
        Perl_croak_no_modify();
d6072 1
a6072 1
    struct regexp *const rx = ReANY(r);
a6077 18
    if (   paren == RX_BUFF_IDX_CARET_PREMATCH
        || paren == RX_BUFF_IDX_CARET_FULLMATCH
        || paren == RX_BUFF_IDX_CARET_POSTMATCH
    )
    {
        bool keepcopy = cBOOL(rx->extflags & RXf_PMf_KEEPCOPY);
        if (!keepcopy) {
            /* on something like
             *    $r = qr/.../;
             *    /$qr/p;
             * the KEEPCOPY is set on the PMOP rather than the regex */
            if (PL_curpm && r == PM_GETRE(PL_curpm))
                 keepcopy = cBOOL(PL_curpm->op_pmflags & PMf_KEEPCOPY);
        }
        if (!keepcopy)
            goto warn_undef;
    }

d6079 3
a6081 3
    switch (paren) {
      case RX_BUFF_IDX_CARET_PREMATCH: /* ${^PREMATCH} */
      case RX_BUFF_IDX_PREMATCH:       /* $` */
d6091 2
a6092 3

      case RX_BUFF_IDX_CARET_POSTMATCH: /* ${^POSTMATCH} */
      case RX_BUFF_IDX_POSTMATCH:       /* $' */
d6102 2
a6103 2

      default: /* $& / ${^MATCH}, $1, $2, ... */
a6110 1
          warn_undef:
d6118 1
a6118 1
        const char * const s = rx->subbeg - rx->suboffset + s1;
d6164 1
a6164 1
	    } while (isWORDCHAR_utf8((U8*)RExC_parse));
d6168 1
a6168 4
	    } while (isWORDCHAR(*RExC_parse));
    } else {
	RExC_parse++; /* so the <- from the vFAIL is after the offending character */
        vFAIL("Group name must start with a non-digit word character");
d6170 1
d6194 1
a6194 1
        assert(0); /* NOT REACHED */
d6269 3
a6271 4
 * This implementation reserves an element at the beginning of each inversion
 * list to contain 0 when the list contains 0, and contains 1 otherwise.  The
 * actual beginning of the list is either that element if 0, or the next one if
 * 1.
d6285 28
a6312 3
/* The header definitions are in F<inline_invlist.c> */
#define TO_INTERNAL_SIZE(x) (((x) + HEADER_LENGTH) * sizeof(UV))
#define FROM_INTERNAL_SIZE(x) (((x)/ sizeof(UV)) - HEADER_LENGTH)
d6332 1
a6332 1
    assert(! *_get_invlist_len_addr(invlist));
d6350 1
a6350 1
    assert(*_get_invlist_len_addr(invlist));
d6361 22
d6390 1
a6390 1
    *_get_invlist_len_addr(invlist) = len;
a6409 33
PERL_STATIC_INLINE IV*
S_get_invlist_previous_index_addr(pTHX_ SV* invlist)
{
    /* Return the address of the UV that is reserved to hold the cached index
     * */

    PERL_ARGS_ASSERT_GET_INVLIST_PREVIOUS_INDEX_ADDR;

    return (IV *) (SvPVX(invlist) + (INVLIST_PREVIOUS_INDEX_OFFSET * sizeof (UV)));
}

PERL_STATIC_INLINE IV
S_invlist_previous_index(pTHX_ SV* const invlist)
{
    /* Returns cached index of previous search */

    PERL_ARGS_ASSERT_INVLIST_PREVIOUS_INDEX;

    return *get_invlist_previous_index_addr(invlist);
}

PERL_STATIC_INLINE void
S_invlist_set_previous_index(pTHX_ SV* const invlist, const IV index)
{
    /* Caches <index> for later retrieval */

    PERL_ARGS_ASSERT_INVLIST_SET_PREVIOUS_INDEX;

    assert(index == 0 || index < (int) _invlist_len(invlist));

    *get_invlist_previous_index_addr(invlist) = index;
}

d6418 1
a6418 3
    return SvLEN(invlist) == 0  /* This happens under _new_invlist_C_array */
           ? _invlist_len(invlist)
           : FROM_INTERNAL_SIZE(SvLEN(invlist));
a6459 1
    *get_invlist_previous_index_addr(new_list) = 0;
d6461 2
a6462 2
#if HEADER_LENGTH != 5
#   error Need to regenerate INVLIST_VERSION_ID by running perl -E 'say int(rand 2**31-1)', and then changing the #if to the new length
d6484 1
a6484 1
    SvCUR_set(invlist, TO_INTERNAL_SIZE(_invlist_len(invlist)));
a6489 7
    /* Initialize the iteration pointer.
     * XXX This could be done at compile time in charclass_invlists.h, but I
     * (khw) am not confident that the suffixes for specifying the C constant
     * UV_MAX are portable, e.g.  'ull' on a 32 bit machine that is configured
     * to use 64 bits; might need a Configure probe */
    invlist_iterfinish(invlist);

d6514 5
d6530 1
a6530 1
    UV len = _invlist_len(invlist);
d6602 2
a6603 2
IV
Perl__invlist_search(pTHX_ SV* const invlist, const UV cp)
d6611 2
a6612 4
    IV mid;
    IV high = _invlist_len(invlist);
    const IV highest_element = high - 1;
    const UV* array;
d6614 1
a6614 1
    PERL_ARGS_ASSERT__INVLIST_SEARCH;
d6616 3
a6618 2
    /* If list is empty, return failure. */
    if (high == 0) {
a6621 40
    /* (We can't get the array unless we know the list is non-empty) */
    array = invlist_array(invlist);

    mid = invlist_previous_index(invlist);
    assert(mid >=0 && mid <= highest_element);

    /* <mid> contains the cache of the result of the previous call to this
     * function (0 the first time).  See if this call is for the same result,
     * or if it is for mid-1.  This is under the theory that calls to this
     * function will often be for related code points that are near each other.
     * And benchmarks show that caching gives better results.  We also test
     * here if the code point is within the bounds of the list.  These tests
     * replace others that would have had to be made anyway to make sure that
     * the array bounds were not exceeded, and these give us extra information
     * at the same time */
    if (cp >= array[mid]) {
        if (cp >= array[highest_element]) {
            return highest_element;
        }

        /* Here, array[mid] <= cp < array[highest_element].  This means that
         * the final element is not the answer, so can exclude it; it also
         * means that <mid> is not the final element, so can refer to 'mid + 1'
         * safely */
        if (cp < array[mid + 1]) {
            return mid;
        }
        high--;
        low = mid + 1;
    }
    else { /* cp < aray[mid] */
        if (cp < array[0]) { /* Fail if outside the array */
            return -1;
        }
        high = mid;
        if (cp >= array[mid - 1]) {
            goto found_entry;
        }
    }

d6624 1
a6624 2
     * The loop below converges on the i+1.  Note that there may not be an
     * (i+1)th element in the array, and things work nonetheless */
d6626 2
a6627 3
	mid = (low + high) / 2;
        assert(mid <= highest_element);
	if (array[mid] <= cp) { /* cp >= array[mid] */
d6641 1
a6641 4
  found_entry:
    high--;
    invlist_set_previous_index(invlist, high);
    return high;
d6655 1
a6655 1
    const IV len = _invlist_len(invlist);
d6668 1
a6668 1
    i = _invlist_search(invlist, start);
d6687 1
a6687 9
                if (LIKELY(end < UV_MAX)) {
                    return;
                }

                /* We get here when the upper bound is the maximum
                 * representable on the machine, and we are looking for just
                 * that code point.  Have to special case it */
                i = len;
                goto join_end_of_list;
a6703 2
    join_end_of_list:

d6727 1
d6732 1
a6732 1
     * SHOULD BE DEFINED upon input, and if it points to one of the two lists,
d6776 1
a6776 1
    if (a == NULL || ((len_a = _invlist_len(a)) == 0)) {
d6779 1
a6779 1
                SvREFCNT_dec_NN(a);
d6790 1
a6790 1
    else if ((len_b = _invlist_len(b)) == 0) {
d6792 1
a6792 1
	    SvREFCNT_dec_NN(b);
d6799 1
a6799 1
                SvREFCNT_dec_NN(a);
d6874 1
a6874 1
	    cp = array_b[i_b++];
d6931 1
a6931 1
    if (len_u != _invlist_len(u)) {
d6953 5
a6962 6
    /*  We may be removing a reference to one of the inputs */
    if (a == *output || b == *output) {
        assert(! invlist_is_iterating(*output));
	SvREFCNT_dec_NN(*output);
    }

d6971 1
a6971 1
     * SHOULD BE DEFINED upon input, and if it points to one of the two lists,
d7010 2
a7011 2
    len_a = _invlist_len(a);
    if ((len_a == 0) || ((len_b = _invlist_len(b)) == 0)) {
d7023 1
a7023 1
                    SvREFCNT_dec_NN(b);
d7033 1
a7033 1
	    SvREFCNT_dec_NN(a);
d7036 1
a7036 1
	    SvREFCNT_dec_NN(b);
d7157 1
a7157 1
    if (len_r != _invlist_len(r)) {
d7174 5
a7183 6
    /*  We may be removing a reference to one of the inputs */
    if (a == *i || b == *i) {
        assert(! invlist_is_iterating(*i));
	SvREFCNT_dec_NN(*i);
    }

d7205 1
a7205 1
	len = _invlist_len(invlist);
d7208 1
a7208 2
    /* If comes after the final entry actually in the list, can just append it
     * to the end, */
d7210 2
a7211 2
	|| (! ELEMENT_RANGE_MATCHES_INVLIST(len - 1)
            && start >= invlist_array(invlist)[len - 1]))
d7225 1
a7225 1
    SvREFCNT_dec_NN(range_invlist);
d7245 1
a7245 1
    UV* len_pos = _get_invlist_len_addr(invlist);
a7248 2
    assert(! invlist_is_iterating(invlist));

d7282 1
a7282 1
    len = _invlist_len(invlist);
d7314 1
a7314 1
    SV* new_invlist = _new_invlist(_invlist_len(invlist) + 1);
a7353 16
PERL_STATIC_INLINE void
S_invlist_iterfinish(pTHX_ SV* invlist)
{
    /* Terminate iterator for invlist.  This is to catch development errors.
     * Any iteration that is interrupted before completed should call this
     * function.  Functions that add code points anywhere else but to the end
     * of an inversion list assert that they are not in the middle of an
     * iteration.  If they were, the addition would make the iteration
     * problematical: if the iteration hadn't reached the place where things
     * were being added, it would be ok */

    PERL_ARGS_ASSERT_INVLIST_ITERFINISH;

    *get_invlist_iter_addr(invlist) = UV_MAX;
}

d7365 1
a7365 1
    UV len = _invlist_len(invlist);
d7371 1
a7371 1
	*pos = UV_MAX;	/* Force iterinit() to be required next time */
a7388 38
PERL_STATIC_INLINE bool
S_invlist_is_iterating(pTHX_ SV* const invlist)
{
    PERL_ARGS_ASSERT_INVLIST_IS_ITERATING;

    return *(get_invlist_iter_addr(invlist)) < UV_MAX;
}

PERL_STATIC_INLINE UV
S_invlist_highest(pTHX_ SV* const invlist)
{
    /* Returns the highest code point that matches an inversion list.  This API
     * has an ambiguity, as it returns 0 under either the highest is actually
     * 0, or if the list is empty.  If this distinction matters to you, check
     * for emptiness before calling this function */

    UV len = _invlist_len(invlist);
    UV *array;

    PERL_ARGS_ASSERT_INVLIST_HIGHEST;

    if (len == 0) {
	return 0;
    }

    array = invlist_array(invlist);

    /* The last element in the array in the inversion list always starts a
     * range that goes to infinity.  That range may be for code points that are
     * matched in the inversion list, or it may be for ones that aren't
     * matched.  In the latter case, the highest code point in the set is one
     * less than the beginning of this range; otherwise it is the final element
     * of this range: infinity */
    return (ELEMENT_RANGE_MATCHES_INVLIST(len - 1))
           ? UV_MAX
           : array[len - 1] - 1;
}

a7401 2
    assert(! invlist_is_iterating(invlist));

d7420 1
a7420 1
#ifdef PERL_ARGS_ASSERT__INVLIST_DUMP
d7422 1
a7422 1
Perl__invlist_dump(pTHX_ SV* const invlist, const char * const header)
a7428 2
    PERL_ARGS_ASSERT__INVLIST_DUMP;

a7431 5
    if (invlist_is_iterating(invlist)) {
        PerlIO_printf(Perl_debug_log, "Can't dump because is in middle of iterating\n");
        return;
    }

a7436 4
	else if (end != start) {
	    PerlIO_printf(Perl_debug_log, "0x%04"UVXf" .. 0x%04"UVXf"\n",
		                                 start,         end);
	}
d7438 1
a7438 1
	    PerlIO_printf(Perl_debug_log, "0x%04"UVXf"\n", start);
a7443 71
#if 0
bool
S__invlistEQ(pTHX_ SV* const a, SV* const b, bool complement_b)
{
    /* Return a boolean as to if the two passed in inversion lists are
     * identical.  The final argument, if TRUE, says to take the complement of
     * the second inversion list before doing the comparison */

    UV* array_a = invlist_array(a);
    UV* array_b = invlist_array(b);
    UV len_a = _invlist_len(a);
    UV len_b = _invlist_len(b);

    UV i = 0;		    /* current index into the arrays */
    bool retval = TRUE;     /* Assume are identical until proven otherwise */

    PERL_ARGS_ASSERT__INVLISTEQ;

    /* If are to compare 'a' with the complement of b, set it
     * up so are looking at b's complement. */
    if (complement_b) {

        /* The complement of nothing is everything, so <a> would have to have
         * just one element, starting at zero (ending at infinity) */
        if (len_b == 0) {
            return (len_a == 1 && array_a[0] == 0);
        }
        else if (array_b[0] == 0) {

            /* Otherwise, to complement, we invert.  Here, the first element is
             * 0, just remove it.  To do this, we just pretend the array starts
             * one later, and clear the flag as we don't have to do anything
             * else later */

            array_b++;
            len_b--;
            complement_b = FALSE;
        }
        else {

            /* But if the first element is not zero, we unshift a 0 before the
             * array.  The data structure reserves a space for that 0 (which
             * should be a '1' right now), so physical shifting is unneeded,
             * but temporarily change that element to 0.  Before exiting the
             * routine, we must restore the element to '1' */
            array_b--;
            len_b++;
            array_b[0] = 0;
        }
    }

    /* Make sure that the lengths are the same, as well as the final element
     * before looping through the remainder.  (Thus we test the length, final,
     * and first elements right off the bat) */
    if (len_a != len_b || array_a[len_a-1] != array_b[len_a-1]) {
        retval = FALSE;
    }
    else for (i = 0; i < len_a - 1; i++) {
        if (array_a[i] != array_b[i]) {
            retval = FALSE;
            break;
        }
    }

    if (complement_b) {
        array_b[0] = 1;
    }
    return retval;
}
#endif

a7451 1
#undef INVLIST_PREVIOUS_INDEX_OFFSET
a7454 193
STATIC void
S_parse_lparen_question_flags(pTHX_ struct RExC_state_t *pRExC_state)
{
    /* This parses the flags that are in either the '(?foo)' or '(?foo:bar)'
     * constructs, and updates RExC_flags with them.  On input, RExC_parse
     * should point to the first flag; it is updated on output to point to the
     * final ')' or ':'.  There needs to be at least one flag, or this will
     * abort */

    /* for (?g), (?gc), and (?o) warnings; warning
       about (?c) will warn about (?g) -- japhy    */

#define WASTED_O  0x01
#define WASTED_G  0x02
#define WASTED_C  0x04
#define WASTED_GC (0x02|0x04)
    I32 wastedflags = 0x00;
    U32 posflags = 0, negflags = 0;
    U32 *flagsp = &posflags;
    char has_charset_modifier = '\0';
    regex_charset cs;
    bool has_use_defaults = FALSE;
    const char* const seqstart = RExC_parse - 1; /* Point to the '?' */

    PERL_ARGS_ASSERT_PARSE_LPAREN_QUESTION_FLAGS;

    /* '^' as an initial flag sets certain defaults */
    if (UCHARAT(RExC_parse) == '^') {
        RExC_parse++;
        has_use_defaults = TRUE;
        STD_PMMOD_FLAGS_CLEAR(&RExC_flags);
        set_regex_charset(&RExC_flags, (RExC_utf8 || RExC_uni_semantics)
                                        ? REGEX_UNICODE_CHARSET
                                        : REGEX_DEPENDS_CHARSET);
    }

    cs = get_regex_charset(RExC_flags);
    if (cs == REGEX_DEPENDS_CHARSET
        && (RExC_utf8 || RExC_uni_semantics))
    {
        cs = REGEX_UNICODE_CHARSET;
    }

    while (*RExC_parse) {
        /* && strchr("iogcmsx", *RExC_parse) */
        /* (?g), (?gc) and (?o) are useless here
           and must be globally applied -- japhy */
        switch (*RExC_parse) {

            /* Code for the imsx flags */
            CASE_STD_PMMOD_FLAGS_PARSE_SET(flagsp);

            case LOCALE_PAT_MOD:
                if (has_charset_modifier) {
                    goto excess_modifier;
                }
                else if (flagsp == &negflags) {
                    goto neg_modifier;
                }
                cs = REGEX_LOCALE_CHARSET;
                has_charset_modifier = LOCALE_PAT_MOD;
                RExC_contains_locale = 1;
                break;
            case UNICODE_PAT_MOD:
                if (has_charset_modifier) {
                    goto excess_modifier;
                }
                else if (flagsp == &negflags) {
                    goto neg_modifier;
                }
                cs = REGEX_UNICODE_CHARSET;
                has_charset_modifier = UNICODE_PAT_MOD;
                break;
            case ASCII_RESTRICT_PAT_MOD:
                if (flagsp == &negflags) {
                    goto neg_modifier;
                }
                if (has_charset_modifier) {
                    if (cs != REGEX_ASCII_RESTRICTED_CHARSET) {
                        goto excess_modifier;
                    }
                    /* Doubled modifier implies more restricted */
                    cs = REGEX_ASCII_MORE_RESTRICTED_CHARSET;
                }
                else {
                    cs = REGEX_ASCII_RESTRICTED_CHARSET;
                }
                has_charset_modifier = ASCII_RESTRICT_PAT_MOD;
                break;
            case DEPENDS_PAT_MOD:
                if (has_use_defaults) {
                    goto fail_modifiers;
                }
                else if (flagsp == &negflags) {
                    goto neg_modifier;
                }
                else if (has_charset_modifier) {
                    goto excess_modifier;
                }

                /* The dual charset means unicode semantics if the
                 * pattern (or target, not known until runtime) are
                 * utf8, or something in the pattern indicates unicode
                 * semantics */
                cs = (RExC_utf8 || RExC_uni_semantics)
                     ? REGEX_UNICODE_CHARSET
                     : REGEX_DEPENDS_CHARSET;
                has_charset_modifier = DEPENDS_PAT_MOD;
                break;
            excess_modifier:
                RExC_parse++;
                if (has_charset_modifier == ASCII_RESTRICT_PAT_MOD) {
                    vFAIL2("Regexp modifier \"%c\" may appear a maximum of twice", ASCII_RESTRICT_PAT_MOD);
                }
                else if (has_charset_modifier == *(RExC_parse - 1)) {
                    vFAIL2("Regexp modifier \"%c\" may not appear twice", *(RExC_parse - 1));
                }
                else {
                    vFAIL3("Regexp modifiers \"%c\" and \"%c\" are mutually exclusive", has_charset_modifier, *(RExC_parse - 1));
                }
                /*NOTREACHED*/
            neg_modifier:
                RExC_parse++;
                vFAIL2("Regexp modifier \"%c\" may not appear after the \"-\"", *(RExC_parse - 1));
                /*NOTREACHED*/
            case ONCE_PAT_MOD: /* 'o' */
            case GLOBAL_PAT_MOD: /* 'g' */
                if (SIZE_ONLY && ckWARN(WARN_REGEXP)) {
                    const I32 wflagbit = *RExC_parse == 'o' ? WASTED_O : WASTED_G;
                    if (! (wastedflags & wflagbit) ) {
                        wastedflags |= wflagbit;
                        vWARN5(
                            RExC_parse + 1,
                            "Useless (%s%c) - %suse /%c modifier",
                            flagsp == &negflags ? "?-" : "?",
                            *RExC_parse,
                            flagsp == &negflags ? "don't " : "",
                            *RExC_parse
                        );
                    }
                }
                break;

            case CONTINUE_PAT_MOD: /* 'c' */
                if (SIZE_ONLY && ckWARN(WARN_REGEXP)) {
                    if (! (wastedflags & WASTED_C) ) {
                        wastedflags |= WASTED_GC;
                        vWARN3(
                            RExC_parse + 1,
                            "Useless (%sc) - %suse /gc modifier",
                            flagsp == &negflags ? "?-" : "?",
                            flagsp == &negflags ? "don't " : ""
                        );
                    }
                }
                break;
            case KEEPCOPY_PAT_MOD: /* 'p' */
                if (flagsp == &negflags) {
                    if (SIZE_ONLY)
                        ckWARNreg(RExC_parse + 1,"Useless use of (?-p)");
                } else {
                    *flagsp |= RXf_PMf_KEEPCOPY;
                }
                break;
            case '-':
                /* A flag is a default iff it is following a minus, so
                 * if there is a minus, it means will be trying to
                 * re-specify a default which is an error */
                if (has_use_defaults || flagsp == &negflags) {
                    goto fail_modifiers;
                }
                flagsp = &negflags;
                wastedflags = 0;  /* reset so (?g-c) warns twice */
                break;
            case ':':
            case ')':
                RExC_flags |= posflags;
                RExC_flags &= ~negflags;
                set_regex_charset(&RExC_flags, cs);
                return;
                /*NOTREACHED*/
            default:
            fail_modifiers:
                RExC_parse++;
                vFAIL3("Sequence (%.*s...) not recognized",
                       RExC_parse-seqstart, seqstart);
                /*NOTREACHED*/
        }

        ++RExC_parse;
    }
}

a7470 5
/* Returns NULL, setting *flagp to TRYAGAIN at the end of (?) that only sets
   flags. Returns NULL, setting *flagp to RESTART_UTF8 if the sizing scan
   needs to be restarted.
   Otherwise would only return NULL if regbranch() returns NULL, which
   cannot happen.  */
d7473 1
a7473 4
    /* paren: Parenthesized? 0=top; 1,2=inside '(': changed to letter.
     * 2 is like 1, but indicates that nextchar() has been called to advance
     * RExC_parse beyond the '('.  Things like '(?' are indivisible tokens, and
     * this flag alerts us to the need to check for that */
d7476 5
a7480 5
    regnode *ret;		/* Will be the head of the group. */
    regnode *br;
    regnode *lastbr;
    regnode *ender = NULL;
    I32 parno = 0;
d7488 9
a7509 7

        /* Under /x, space and comments can be gobbled up between the '(' and
         * here (if paren ==2).  The forms '(*VERB' and '(?...' disallow such
         * intervening space, as the sequence is a token, and a token should be
         * indivisible */
        bool has_intervening_patws = paren == 2 && *(RExC_parse - 1) != '(';

a7516 4

            if (has_intervening_patws && SIZE_ONLY) {
                ckWARNregdep(RExC_parse + 1, "In '(*VERB...)', splitting the initial '(*' is deprecated");
            }
d7618 1
a7618 3
            if (has_intervening_patws && SIZE_ONLY) {
                ckWARNregdep(RExC_parse + 1, "In '(?...)', splitting the initial '(?' is deprecated");
            }
d7651 1
a7651 1
				     : (ASCII_FOLD_RESTRICTED)
d7744 1
a7744 1
                            SvREFCNT_dec_NN(svname);
d7780 2
a7781 6
            case '#':           /* (?#...) */
                /* XXX As soon as we disallow separating the '?' and '*' (by
                 * spaces or (?#...) comment), it is believed that this case
                 * will be unreachable and can be removed.  See
                 * [perl #117327] */
                while (*RExC_parse && *RExC_parse != ')')
d7808 1
a7808 1
                assert(0); /* NOT REACHED */
d7878 1
a7878 1
            assert(0); /* NOT REACHED */
d7892 1
d7894 2
a7895 1
		struct reg_code_block *cb;
d7898 16
a7913 14

		if (   !pRExC_state->num_code_blocks
		    || pRExC_state->code_index >= pRExC_state->num_code_blocks
		    || pRExC_state->code_blocks[pRExC_state->code_index].start
			!= (STRLEN)((RExC_parse -3 - (is_logical ? 1 : 0))
			    - RExC_start)
		) {
		    if (RExC_pm_flags & PMf_USE_RE_EVAL)
			FAIL("panic: Sequence (?{...}): no code block found\n");
		    FAIL("Eval-group not allowed at runtime, use re 'eval'");
		}
		/* this is a pre-compiled code block (?{...}) */
		cb = &pRExC_state->code_blocks[pRExC_state->code_index];
		RExC_parse = RExC_start + cb->end;
d7915 30
a7944 12
		    OP *o = cb->block;
		    if (cb->src_regex) {
			n = add_data(pRExC_state, 2, "rl");
			RExC_rxi->data->data[n] =
			    (void*)SvREFCNT_inc((SV*)cb->src_regex);
			RExC_rxi->data->data[n+1] = (void*)o;
		    }
		    else {
			n = add_data(pRExC_state, 1,
			       (RExC_pm_flags & PMf_HAS_CV) ? "L" : "l");
			RExC_rxi->data->data[n] = (void*)o;
		    }
d7946 1
a7946 1
		pRExC_state->code_index++;
a7947 1

a7948 1
                    regnode *eval;
d7950 1
a7950 2
                    eval = reganode(pRExC_state, EVAL, n);
		    if (!SIZE_ONLY) {
d7952 1
a7952 4
                        /* for later propagation into (??{}) return value */
                        eval->flags = (U8) (RExC_flags & RXf_PMf_COMPILETIME);
                    }
                    REGTAIL(pRExC_state, ret, eval);
a7968 1
                        regnode *tail;
d7973 1
a7973 7
                        
                        tail = reg(pRExC_state, 1, &flag, depth+1);
                        if (flag & RESTART_UTF8) {
                            *flagp = RESTART_UTF8;
                            return NULL;
                        }
                        REGTAIL(pRExC_state, ret, tail);
d8041 3
a8043 8
		    if (br == NULL) {
                        if (flags & RESTART_UTF8) {
                            *flagp = RESTART_UTF8;
                            return NULL;
                        }
                        FAIL2("panic: regbranch returned NULL, flags=%#X",
                              flags);
                    } else
d8052 1
a8052 8
                        if (!regbranch(pRExC_state, &flags, 1,depth+1)) {
                            if (flags & RESTART_UTF8) {
                                *flagp = RESTART_UTF8;
                                return NULL;
                            }
                            FAIL2("panic: regbranch returned NULL, flags=%#X",
                                  flags);
                        }
a8078 3
	    case '[':           /* (?[ ... ]) */
                return handle_regex_sets(pRExC_state, NULL, flagp, depth,
                                         oregcomp_parse);
d8083 9
a8091 1
	    default: /* e.g., (?i) */
d8093 172
a8264 12
              parse_flags:
		parse_lparen_question_flags(pRExC_state);
                if (UCHARAT(RExC_parse) != ':') {
                    nextchar(pRExC_state);
                    *flagp = TRYAGAIN;
                    return NULL;
                }
                paren = ':';
                nextchar(pRExC_state);
                ret = NULL;
                goto parse_rest;
            } /* end switch */
d8299 2
a8300 7
    if (br == NULL) {
        if (flags & RESTART_UTF8) {
            *flagp = RESTART_UTF8;
            return NULL;
        }
        FAIL2("panic: regbranch returned NULL, flags=%#X", flags);
    }
d8339 2
a8340 7
	if (br == NULL) {
            if (flags & RESTART_UTF8) {
                *flagp = RESTART_UTF8;
                return NULL;
            }
            FAIL2("panic: regbranch returned NULL, flags=%#X", flags);
        }
d8352 1
a8352 1
	case 1: case 2:
a8381 14
        DEBUG_PARSE_r(if (!SIZE_ONLY) {
            SV * const mysv_val1=sv_newmortal();
            SV * const mysv_val2=sv_newmortal();
            DEBUG_PARSE_MSG("lsbr");
            regprop(RExC_rx, mysv_val1, lastbr);
            regprop(RExC_rx, mysv_val2, ender);
            PerlIO_printf(Perl_debug_log, "~ tying lastbr %s (%"IVdf") to ender %s (%"IVdf") offset %"IVdf"\n",
                          SvPV_nolen_const(mysv_val1),
                          (IV)REG_NODE_NUM(lastbr),
                          SvPV_nolen_const(mysv_val2),
                          (IV)REG_NODE_NUM(ender),
                          (IV)(ender - lastbr)
            );
        });
a8384 1
            char is_nothing= 1;
a8392 2
                    if (OP(NEXTOPER(br)) != NOTHING || regnext(NEXTOPER(br)) != ender)
                        is_nothing= 0;
a8395 4
                    /* for now we always disable this optimisation * /
                    if (OP(NEXTOPER(NEXTOPER(br))) != NOTHING || regnext(NEXTOPER(NEXTOPER(br))) != ender)
                    */
                        is_nothing= 0;
a8397 27
            if (is_nothing) {
                br= PL_regkind[OP(ret)] != BRANCH ? regnext(ret) : ret;
                DEBUG_PARSE_r(if (!SIZE_ONLY) {
                    SV * const mysv_val1=sv_newmortal();
                    SV * const mysv_val2=sv_newmortal();
                    DEBUG_PARSE_MSG("NADA");
                    regprop(RExC_rx, mysv_val1, ret);
                    regprop(RExC_rx, mysv_val2, ender);
                    PerlIO_printf(Perl_debug_log, "~ converting ret %s (%"IVdf") to ender %s (%"IVdf") offset %"IVdf"\n",
                                  SvPV_nolen_const(mysv_val1),
                                  (IV)REG_NODE_NUM(ret),
                                  SvPV_nolen_const(mysv_val2),
                                  (IV)REG_NODE_NUM(ender),
                                  (IV)(ender - ret)
                    );
                });
                OP(br)= NOTHING;
                if (OP(ender) == TAIL) {
                    NEXT_OFF(br)= 0;
                    RExC_emit= br + 1;
                } else {
                    regnode *opt;
                    for ( opt= br + 1; opt < ender ; opt++ )
                        OP(opt)= OPTIMIZED;
                    NEXT_OFF(br)= ender - br;
                }
            }
d8421 1
a8421 2
        /* restore original flags, but keep (?p) */
	RExC_flags = oregflags | (RExC_flags & RXf_PMf_KEEPCOPY);
d8434 1
a8434 1
	assert(0); /* NOTREACHED */
a8448 3
 *
 * Returns NULL, setting *flagp to RESTART_UTF8 if the sizing scan needs to be
 * restarted.
d8454 3
a8456 3
    regnode *ret;
    regnode *chain = NULL;
    regnode *latest;
d8488 1
a8488 5
            if (flags & RESTART_UTF8) {
                *flagp = RESTART_UTF8;
                return NULL;
            }
            FAIL2("panic: regpiece returned NULL, flags=%#X", flags);
a8521 5
 *
 * Returns NULL, setting *flagp to TRYAGAIN if regatom() returns NULL with
 * TRYAGAIN.
 * Returns NULL, setting *flagp to RESTART_UTF8 if the sizing scan needs to be
 * restarted.
d8527 3
a8529 3
    regnode *ret;
    char op;
    char *next;
a8537 4

    /* Save the original in case we change the emitted regop to a FAIL. */
    regnode * const orig_emit = RExC_emit;

d8546 2
a8547 4
	if (flags & (TRYAGAIN|RESTART_UTF8))
	    *flagp |= flags & (TRYAGAIN|RESTART_UTF8);
        else
            FAIL2("panic: regatom returned NULL, flags=%#X", flags);
d8553 1
a8553 1
    if (op == '{' && regcurly(RExC_parse, FALSE)) {
a8583 17
            if (max < min) {    /* If can't match, warn and optimize to fail
                                   unconditionally */
                if (SIZE_ONLY) {
                    ckWARNreg(RExC_parse, "Quantifier {n,m} with n > m can't match");

                    /* We can't back off the size because we have to reserve
                     * enough space for all the things we are about to throw
                     * away, but we can shrink it by the ammount we are about
                     * to re-use here */
                    RExC_size = PREVOPER(RExC_size) - regarglen[(U8)OPFAIL];
                }
                else {
                    RExC_emit = orig_emit;
                }
                ret = reg_node(pRExC_state, OPFAIL);
                return ret;
            }
d8621 2
a8683 1
	SAVEFREESV(RExC_rx_sv); /* in case of fatal warnings */
a8687 1
	(void)ReREFCNT_inc(RExC_rx_sv);
d8718 2
a8719 5
STATIC bool
S_grok_bslash_N(pTHX_ RExC_state_t *pRExC_state, regnode** node_p, UV *valuep, I32 *flagp, U32 depth, bool in_char_class,
        const bool strict   /* Apply stricter parsing rules? */
    )
{
d8721 4
a8724 5
 /* This is expected to be called by a parser routine that has recognized '\N'
   and needs to handle the rest. RExC_parse is expected to point at the first
   char following the N at the time of the call.  On successful return,
   RExC_parse has been updated to point to just after the sequence identified
   by this routine, and <*flagp> has been updated.
d8726 1
a8726 1
   The \N may be inside (indicated by the boolean <in_char_class>) or outside a
d8731 1
a8731 1
   attempted to decide which, and in the case of a named sequence, converted it
d8735 4
a8738 5
   attempt to determine this nor expand those, instead raising a syntax error.
   The net effect is that if the beginning of the passed-in pattern isn't '{U+'
   or there is no '}', it signals that this \N occurrence means to match a
   non-newline.

d8742 15
d8758 2
a8759 20
   The function raises an error (via vFAIL), and doesn't return for various
   syntax errors.  Otherwise it returns TRUE and sets <node_p> or <valuep> on
   success; it returns FALSE otherwise. Returns FALSE, setting *flagp to
   RESTART_UTF8 if the sizing scan needs to be restarted. Such a restart is
   only possible if node_p is non-NULL.


   If <valuep> is non-null, it means the caller can accept an input sequence
   consisting of a just a single code point; <*valuep> is set to that value
   if the input is such.

   If <node_p> is non-null it signifies that the caller can accept any other
   legal sequence (i.e., one that isn't just a single code point).  <*node_p>
   is set as follows:
    1) \N means not-a-NL: points to a newly created REG_ANY node;
    2) \N{}:              points to a new NOTHING node;
    3) otherwise:         points to a new EXACT node containing the resolved
                          string.
   Note that FALSE is returned for single code point sequences if <valuep> is
   null.
d8761 3
a8763 1

d8765 1
a8766 4
    char *endchar;	/* Points to '.' or '}' ending cur char in the input
                           stream */
    bool has_multiple_chars; /* true if the input stream contains a sequence of
                                more than one character */
d8770 1
a8770 1
    PERL_ARGS_ASSERT_GROK_BSLASH_N;
a8773 2
    assert(cBOOL(node_p) ^ cBOOL(valuep));  /* Exactly one should be set */

d8779 1
a8779 1

d8782 1
a8782 1
    if (*p != '{' || regcurly(p, FALSE)) {
d8784 1
a8784 1
	if (! node_p) {
d8786 2
a8787 5
            if (in_char_class) {
                vFAIL("\\N in a character class must be a named character: \\N{...}");
            }
            return FALSE;
        }
d8789 1
a8789 1
	*node_p = reg_node(pRExC_state, REG_ANY);
d8793 2
a8794 2
        Set_Node_Length(*node_p, 1); /* MJD */
	return TRUE;
d8797 1
a8797 1
    /* Here, we have decided it should be a named character or sequence */
d8819 10
a8828 16
        bool ret = TRUE;
	if (node_p) {
	    *node_p = reg_node(pRExC_state,NOTHING);
	}
        else if (in_char_class) {
            if (SIZE_ONLY && in_char_class) {
                if (strict) {
                    RExC_parse++;   /* Position after the "}" */
                    vFAIL("Zero length \\N{}");
                }
                else {
                    ckWARNreg(RExC_parse,
                              "Ignoring zero length \\N{} in character class");
                }
            }
            ret = FALSE;
d8830 2
a8831 5
        else {
            return FALSE;
        }
        nextchar(pRExC_state);
        return ret;
d8834 1
a8834 1
    RExC_uni_semantics = 1; /* Unicode named chars imply Unicode semantics */
d8837 3
a8839 9
    endchar = RExC_parse + strcspn(RExC_parse, ".}");

    /* Code points are separated by dots.  If none, there is only one code
     * point, and is terminated by the brace */
    has_multiple_chars = (endchar < endbrace);

    if (valuep && (! has_multiple_chars || in_char_class)) {
	/* We only pay attention to the first char of
        multichar strings being returned in char classes. I kinda wonder
d8845 2
a8846 2
	STRLEN length_of_hex = (STRLEN)(endchar - RExC_parse);
	I32 grok_hex_flags = PERL_SCAN_ALLOW_UNDERSCORES
d8849 5
d8855 2
a8856 1
	*valuep = grok_hex(RExC_parse, &length_of_hex, &grok_hex_flags, NULL);
d8868 1
a8868 3
	    if (RExC_parse >= endchar) {
                RExC_parse = endchar;
            }
d8870 1
a8870 11
	}

        if (in_char_class && has_multiple_chars) {
            if (strict) {
                RExC_parse = endbrace;
                vFAIL("\\N{} in character class restricted to one character");
            }
            else {
                ckWARNreg(endchar, "Using just the first character returned by \\N{} in character class");
            }
        }
d8872 2
a8873 3
        RExC_parse = endbrace + 1;
    }
    else if (! node_p || ! has_multiple_chars) {
d8875 1
a8875 5
        /* Here, the input is legal, but not according to the caller's
         * options.  We fail without advancing the parse, so that the
         * caller can try again */
        RExC_parse = p;
        return FALSE;
d8877 1
a8877 1
    else {
d8890 2
a8892 1
        I32 flags;
d8896 4
a8906 1
	    endchar = RExC_parse + strcspn(RExC_parse, ".}");
d8921 1
a8921 9
	if (!(*node_p = reg(pRExC_state, 1, &flags, depth+1))) {
            if (flags & RESTART_UTF8) {
                *flagp = RESTART_UTF8;
                return FALSE;
            }
            FAIL2("panic: reg returned NULL to grok_bslash_N, flags=%#X",
                  flags);
        } 
	*flagp |= flags&(HASWIDTH|SPSTART|SIMPLE|POSTPONED);
d8927 1
a8927 1
        nextchar(pRExC_state);
d8930 1
a8930 1
    return TRUE;
a8966 102
PERL_STATIC_INLINE U8
S_compute_EXACTish(pTHX_ RExC_state_t *pRExC_state)
{
    U8 op;

    PERL_ARGS_ASSERT_COMPUTE_EXACTISH;

    if (! FOLD) {
        return EXACT;
    }

    op = get_regex_charset(RExC_flags);
    if (op >= REGEX_ASCII_RESTRICTED_CHARSET) {
        op--; /* /a is same as /u, and map /aa's offset to what /a's would have
                 been, so there is no hole */
    }

    return op + EXACTF;
}

PERL_STATIC_INLINE void
S_alloc_maybe_populate_EXACT(pTHX_ RExC_state_t *pRExC_state, regnode *node, I32* flagp, STRLEN len, UV code_point)
{
    /* This knows the details about sizing an EXACTish node, setting flags for
     * it (by setting <*flagp>, and potentially populating it with a single
     * character.
     *
     * If <len> (the length in bytes) is non-zero, this function assumes that
     * the node has already been populated, and just does the sizing.  In this
     * case <code_point> should be the final code point that has already been
     * placed into the node.  This value will be ignored except that under some
     * circumstances <*flagp> is set based on it.
     *
     * If <len> is zero, the function assumes that the node is to contain only
     * the single character given by <code_point> and calculates what <len>
     * should be.  In pass 1, it sizes the node appropriately.  In pass 2, it
     * additionally will populate the node's STRING with <code_point>, if <len>
     * is 0.  In both cases <*flagp> is appropriately set
     *
     * It knows that under FOLD, the Latin Sharp S and UTF characters above
     * 255, must be folded (the former only when the rules indicate it can
     * match 'ss') */

    bool len_passed_in = cBOOL(len != 0);
    U8 character[UTF8_MAXBYTES_CASE+1];

    PERL_ARGS_ASSERT_ALLOC_MAYBE_POPULATE_EXACT;

    if (! len_passed_in) {
        if (UTF) {
            if (FOLD && (! LOC || code_point > 255)) {
                _to_uni_fold_flags(NATIVE_TO_UNI(code_point),
                                   character,
                                   &len,
                                   FOLD_FLAGS_FULL | ((LOC)
                                                     ? FOLD_FLAGS_LOCALE
                                                     : (ASCII_FOLD_RESTRICTED)
                                                       ? FOLD_FLAGS_NOMIX_ASCII
                                                       : 0));
            }
            else {
                uvchr_to_utf8( character, code_point);
                len = UTF8SKIP(character);
            }
        }
        else if (! FOLD
                 || code_point != LATIN_SMALL_LETTER_SHARP_S
                 || ASCII_FOLD_RESTRICTED
                 || ! AT_LEAST_UNI_SEMANTICS)
        {
            *character = (U8) code_point;
            len = 1;
        }
        else {
            *character = 's';
            *(character + 1) = 's';
            len = 2;
        }
    }

    if (SIZE_ONLY) {
        RExC_size += STR_SZ(len);
    }
    else {
        RExC_emit += STR_SZ(len);
        STR_LEN(node) = len;
        if (! len_passed_in) {
            Copy((char *) character, STRING(node), len, char);
        }
    }

    *flagp |= HASWIDTH;

    /* A single character node is SIMPLE, except for the special-cased SHARP S
     * under /di. */
    if ((len == 1 || (UTF && len == UNISKIP(code_point)))
        && (code_point != LATIN_SMALL_LETTER_SHARP_S
            || ! FOLD || ! DEPENDS_SEMANTICS))
    {
        *flagp |= SIMPLE;
    }
}
d8983 2
a8984 40
   and special, and in the case of \10 and friends, context determines which.

   A summary of the code structure is:

   switch (first_byte) {
	cases for each special:
	    handle this special;
	    break;
	case '\\':
	    switch (2nd byte) {
		cases for each unambiguous special:
		    handle this special;
		    break;
		cases for each ambigous special/literal:
		    disambiguate;
		    if (special)  handle here
		    else goto defchar;
		default: // unambiguously literal:
		    goto defchar;
	    }
	default:  // is a literal char
	    // FALL THROUGH
	defchar:
	    create EXACTish node for literal;
	    while (more input and node isn't full) {
		switch (input_byte) {
		   cases for each special;
                       make sure parse pointer is set so that the next call to
                           regatom will see this special first
                       goto loopdone; // EXACTish node terminated by prev. char
		   default:
		       append char to EXACTISH node;
		}
	        get next input byte;
	    }
        loopdone:
   }
   return the generated node;

   Specifically there are two separate switches for handling
a8987 6

   Returns NULL, setting *flagp to TRYAGAIN if reg() returns NULL with
   TRYAGAIN.  
   Returns NULL, setting *flagp to RESTART_UTF8 if the sizing scan needs to be
   restarted.
   Otherwise does not return NULL.
d8994 2
a8995 2
    regnode *ret = NULL;
    I32 flags = 0;
a8997 2
    int invert = 0;

d8999 1
a8999 1

a9001 2
    DEBUG_PARSE("atom");

d9042 1
a9042 5
        ret = regclass(pRExC_state, flagp,depth+1,
                       FALSE, /* means parse the whole char class */
                       TRUE, /* allow multi-char folds */
                       FALSE, /* don't silence non-portable warnings. */
                       NULL);
a9046 6
        if (ret == NULL) {
            if (*flagp & RESTART_UTF8)
                return NULL;
            FAIL2("panic: regclass returned NULL to regatom, flags=%#X",
                  *flagp);
        }
d9048 1
d9054 1
a9054 1
        ret = reg(pRExC_state, 2, &flags,depth+1);
d9064 1
a9064 5
                if (flags & RESTART_UTF8) {
                    *flagp = RESTART_UTF8;
                    return NULL;
                }
                FAIL2("panic: reg returned NULL to regatom, flags=%#X", flags);
d9078 1
a9078 1
	if (!regcurly(RExC_parse, FALSE)) {
a9102 1
            U8 arg;
d9143 21
a9163 1

d9165 20
a9184 6
            invert = 1;
            /* FALLTHROUGH */
	case 'w':
            arg = ANYOF_WORDCHAR;
            goto join_posix;

d9188 16
a9203 3
	    op = BOUND + get_regex_charset(RExC_flags);
            if (op > BOUNDA) {  /* /aa is same as /a */
                op = BOUNDA;
d9209 1
a9209 1
		ckWARNdep(RExC_parse, "\"\\b{\" is deprecated; use \"\\b\\{\" or \"\\b[{]\" instead");
d9215 16
a9230 3
	    op = NBOUND + get_regex_charset(RExC_flags);
            if (op > NBOUNDA) { /* /aa is same as /a */
                op = NBOUNDA;
d9236 1
a9236 1
		ckWARNdep(RExC_parse, "\"\\B{\" is deprecated; use \"\\B\\{\" or \"\\B[{]\" instead");
d9239 19
a9257 10

	case 'D':
            invert = 1;
            /* FALLTHROUGH */
	case 'd':
            arg = ANYOF_DIGIT;
            goto join_posix;

	case 'R':
	    ret = reg_node(pRExC_state, LNBREAK);
a9259 17

	case 'H':
            invert = 1;
            /* FALLTHROUGH */
	case 'h':
	    arg = ANYOF_BLANK;
            op = POSIXU;
            goto join_posix_op_known;

	case 'V':
            invert = 1;
            /* FALLTHROUGH */
	case 'v':
	    arg = ANYOF_VERTWS;
            op = POSIXU;
            goto join_posix_op_known;

d9261 16
a9276 10
            invert = 1;
            /* FALLTHROUGH */
	case 's':
            arg = ANYOF_SPACE;

        join_posix:

	    op = POSIXD + get_regex_charset(RExC_flags);
            if (op > POSIXA) {  /* /aa is same as /a */
                op = POSIXA;
d9278 18
a9295 5

        join_posix_op_known:

            if (invert) {
                op += NPOSIXD - POSIXD;
a9296 1

a9297 4
            if (! SIZE_ONLY) {
                FLAGS(ret) = namedclass_to_classnum(arg);
            }

d9299 39
a9337 2
            /* FALL THROUGH */

d9345 1
d9350 16
d9368 1
a9368 12
                ret = regclass(pRExC_state, flagp,depth+1,
                               TRUE, /* means just parse this element */
                               FALSE, /* don't allow multi-char folds */
                               FALSE, /* don't silence non-portable warnings.
                                         It would be a bug if these returned
                                         non-portables */
                               NULL);
                /* regclass() can only return RESTART_UTF8 if multi-char folds
                   are allowed.  */
                if (!ret)
                    FAIL2("panic: regclass returned NULL to regatom, flags=%#X",
                          *flagp);
d9370 1
d9376 1
d9380 4
a9383 10
            /* Handle \N and \N{NAME} with multiple code points here and not
             * below because it can be multicharacter. join_exact() will join
             * them up later on.  Also this makes sure that things like
             * /\N{BLAH}+/ and \N{BLAH} being multi char Just Happen. dmq.
             * The options to the grok function call causes it to fail if the
             * sequence is just a single code point.  We then go treat it as
             * just another character in the current EXACT node, and hence it
             * gets uniform treatment with all the other characters.  The
             * special treatment for quantifiers is not needed for such single
             * character sequences */
d9385 1
a9385 7
            if (! grok_bslash_N(pRExC_state, &ret, NULL, flagp, depth, FALSE,
                                FALSE /* not strict */ )) {
                if (*flagp & RESTART_UTF8)
                    return NULL;
                RExC_parse--;
                goto defchar;
            }
d9415 1
a9415 1
				 : (ASCII_FOLD_RESTRICTED)
a9464 1
                    /* Probably a character specified in octal, e.g. \35 */
d9485 1
a9485 1
				     : (ASCII_FOLD_RESTRICTED)
d9529 3
a9531 3
	    STRLEN len = 0;
	    UV ender;
	    char *p;
a9532 4
#define MAX_NODE_STRING_SIZE 127
	    char foldbuf[MAX_NODE_STRING_SIZE+UTF8_MAXBYTES_CASE];
	    char *s0;
	    U8 upper_parse = MAX_NODE_STRING_SIZE;
d9534 1
a9535 2
            bool next_is_quantifier;
            char * oldp = NULL;
d9537 3
a9539 4
            /* If a folding node contains only code points that don't
             * participate in folds, it can be changed into an EXACT node,
             * which allows the optimizer more things to look for */
            bool maybe_exact;
d9542 8
a9549 1
            node_type = compute_EXACTish(pRExC_state);
d9551 1
a9551 13

            /* In pass1, folded, we use a temporary buffer instead of the
             * actual node, as the node doesn't exist yet */
	    s = (SIZE_ONLY && FOLD) ? foldbuf : STRING(ret);

            s0 = s;

	reparse:

            /* We do the EXACTFish to EXACT node only if folding, and not if in
             * locale, as whether a character folds or not isn't known until
             * runtime */
            maybe_exact = FOLD && ! LOC;
d9571 2
a9572 2
	    for (p = RExC_parse - 1;
	         len < upper_parse && p < RExC_end;
d9575 1
a9575 1
		oldp = p;
d9611 1
a9628 19
		    case 'N': /* Handle a single-code point named character. */
                        /* The options cause it to fail if a multiple code
                         * point sequence.  Handle those in the switch() above
                         * */
                        RExC_parse = p + 1;
                        if (! grok_bslash_N(pRExC_state, NULL, &ender,
                                            flagp, depth, FALSE,
                                            FALSE /* not strict */ ))
                        {
                            if (*flagp & RESTART_UTF8)
                                FAIL("panic: grok_bslash_N set RESTART_UTF8");
                            RExC_parse = p = oldp;
                            goto loopdone;
                        }
                        p = RExC_parse;
                        if (ender > 0xff) {
                            REQUIRE_UTF8;
                        }
                        break;
d9651 1
d9655 1
a9655 1
			    bool valid = grok_bslash_o(&p,
d9657 1
d9659 2
a9660 6
						       TRUE, /* out warnings */
                                                       FALSE, /* not strict */
                                                       TRUE, /* Output warnings
                                                                for non-
                                                                portables */
                                                       UTF);
d9666 4
a9669 1
                            ender = result;
d9679 2
a9680 4
			{
                            UV result = UV_MAX; /* initialize to erroneous
                                                   value */
			    const char* error_msg;
d9682 3
a9684 13
			    bool valid = grok_bslash_x(&p,
						       &result,
						       &error_msg,
						       TRUE, /* out warnings */
                                                       FALSE, /* not strict */
                                                       TRUE, /* Output warnings
                                                                for non-
                                                                portables */
                                                       UTF);
			    if (! valid) {
				RExC_parse = p;	/* going to die anyway; point
						   to exact spot of failure */
				vFAIL(error_msg);
d9686 8
a9693 4
                            ender = result;

			    if (PL_encoding && ender < 0x100) {
				goto recode_encoding;
a9694 4
			    if (ender > 0xff) {
				REQUIRE_UTF8;
			    }
			    break;
d9696 9
d9710 1
a9710 1
		    case '5': case '6': case '7':
a9720 9
                            if (SIZE_ONLY   /* like \08, \178 */
                                && numlen < 3
                                && p < RExC_end
                                && isDIGIT(*p) && ckWARN(WARN_REGEXP))
                            {
				reg_warn_non_literal_string(
                                         p + 1,
                                         form_short_octal_warning(p, numlen));
                            }
d9722 1
a9722 2
                        else {  /* Not to be treated as an octal constant, go
                                   find backref */
a9728 6
                    case '8': case '9': /* These are illegal unless backrefs */
                        if (atoi(p) <= RExC_npar) {
                            --p;   /* backup to backslash; handle as backref */
                            goto loopdone;
                        }
                        goto unrecognized;
d9743 1
a9743 2
                    unrecognized:
			if (!SIZE_ONLY&& isALPHANUMERIC(*p)) {
d9747 1
a9747 1
			    int len = (isALPHA(*p) && *(p + 1) == '{') ? 2 : 1;
d9751 1
a9751 1
		    } /* End of switch on '\' */
d9753 1
a9753 11
		default:    /* A literal character */

                    if (! SIZE_ONLY
                        && RExC_flags & RXf_PMf_EXTENDED
                        && ckWARN(WARN_DEPRECATED)
                        && is_PATWS_non_low(p, UTF))
                    {
                        vWARN_dep(p + ((UTF) ? UTF8SKIP(p) : 1),
                                "Escape literal pattern white space under /x");
                    }

d9766 2
a9767 4
		/* Here, have looked at the literal character and <ender>
		 * contains its ordinal, <p> points to the character after it
		 */

d9770 102
a9871 92

                /* If the next thing is a quantifier, it applies to this
                 * character only, which means that this character has to be in
                 * its own node and can't just be appended to the string in an
                 * existing node, so if there are already other characters in
                 * the node, close the node with just them, and set up to do
                 * this character again next time through, when it will be the
                 * only thing in its new node */
                if ((next_is_quantifier = (p < RExC_end && ISMULT2(p))) && len)
		{
                    p = oldp;
                    goto loopdone;
                }

		if (FOLD) {
                    if (UTF
                            /* See comments for join_exact() as to why we fold
                             * this non-UTF at compile time */
                        || (node_type == EXACTFU
                            && ender == LATIN_SMALL_LETTER_SHARP_S))
                    {


                        /* Prime the casefolded buffer.  Locale rules, which
                         * apply only to code points < 256, aren't known until
                         * execution, so for them, just output the original
                         * character using utf8.  If we start to fold non-UTF
                         * patterns, be sure to update join_exact() */
                        if (LOC && ender < 256) {
                            if (UNI_IS_INVARIANT(ender)) {
                                *s = (U8) ender;
                                foldlen = 1;
                            } else {
                                *s = UTF8_TWO_BYTE_HI(ender);
                                *(s + 1) = UTF8_TWO_BYTE_LO(ender);
                                foldlen = 2;
                            }
                        }
                        else {
                            UV folded = _to_uni_fold_flags(
                                           ender,
                                           (U8 *) s,
                                           &foldlen,
                                           FOLD_FLAGS_FULL
                                           | ((LOC) ?  FOLD_FLAGS_LOCALE
                                                    : (ASCII_FOLD_RESTRICTED)
                                                      ? FOLD_FLAGS_NOMIX_ASCII
                                                      : 0)
                                            );

                            /* If this node only contains non-folding code
                             * points so far, see if this new one is also
                             * non-folding */
                            if (maybe_exact) {
                                if (folded != ender) {
                                    maybe_exact = FALSE;
                                }
                                else {
                                    /* Here the fold is the original; we have
                                     * to check further to see if anything
                                     * folds to it */
                                    if (! PL_utf8_foldable) {
                                        SV* swash = swash_init("utf8",
                                                           "_Perl_Any_Folds",
                                                           &PL_sv_undef, 1, 0);
                                        PL_utf8_foldable =
                                                    _get_swash_invlist(swash);
                                        SvREFCNT_dec_NN(swash);
                                    }
                                    if (_invlist_contains_cp(PL_utf8_foldable,
                                                             ender))
                                    {
                                        maybe_exact = FALSE;
                                    }
                                }
                            }
                            ender = folded;
                        }
			s += foldlen;

			/* The loop increments <len> each time, as all but this
			 * path (and the one just below for UTF) through it add
			 * a single byte to the EXACTish node.  But this one
			 * has changed len to be the correct final value, so
			 * subtract one to cancel out the increment that
			 * follows */
			len += foldlen - 1;
                    }
                    else {
                        *(s++) = (char) ender;
                        maybe_exact &= ! IS_IN_SOME_FOLD_L1(ender);
                    }
d9873 30
a9902 9
		else if (UTF) {
                    const STRLEN unilen = reguni(pRExC_state, ender, s);
                    if (unilen > 0) {
                       s   += unilen;
                       len += unilen;
                    }

		    /* See comment just above for - 1 */
		    len--;
a9905 56
                }

		if (next_is_quantifier) {

                    /* Here, the next input is a quantifier, and to get here,
                     * the current character is the only one in the node.
                     * Also, here <len> doesn't include the final byte for this
                     * character */
                    len++;
                    goto loopdone;
		}

	    } /* End of loop through literal characters */

            /* Here we have either exhausted the input or ran out of room in
             * the node.  (If we encountered a character that can't be in the
             * node, transfer is made directly to <loopdone>, and so we
             * wouldn't have fallen off the end of the loop.)  In the latter
             * case, we artificially have to split the node into two, because
             * we just don't have enough space to hold everything.  This
             * creates a problem if the final character participates in a
             * multi-character fold in the non-final position, as a match that
             * should have occurred won't, due to the way nodes are matched,
             * and our artificial boundary.  So back off until we find a non-
             * problematic character -- one that isn't at the beginning or
             * middle of such a fold.  (Either it doesn't participate in any
             * folds, or appears only in the final position of all the folds it
             * does participate in.)  A better solution with far fewer false
             * positives, and that would fill the nodes more completely, would
             * be to actually have available all the multi-character folds to
             * test against, and to back-off only far enough to be sure that
             * this node isn't ending with a partial one.  <upper_parse> is set
             * further below (if we need to reparse the node) to include just
             * up through that final non-problematic character that this code
             * identifies, so when it is set to less than the full node, we can
             * skip the rest of this */
            if (FOLD && p < RExC_end && upper_parse == MAX_NODE_STRING_SIZE) {

                const STRLEN full_len = len;

		assert(len >= MAX_NODE_STRING_SIZE);

                /* Here, <s> points to the final byte of the final character.
                 * Look backwards through the string until find a non-
                 * problematic character */

		if (! UTF) {

                    /* These two have no multi-char folds to non-UTF characters
                     */
                    if (ASCII_FOLD_RESTRICTED || LOC) {
                        goto loopdone;
                    }

                    while (--s >= s0 && IS_NON_FINAL_FOLD(*s)) { }
                    len = s - s0 + 1;
d9907 1
a9907 115
                else {
                    if (!  PL_NonL1NonFinalFold) {
                        PL_NonL1NonFinalFold = _new_invlist_C_array(
                                        NonL1_Perl_Non_Final_Folds_invlist);
                    }

                    /* Point to the first byte of the final character */
                    s = (char *) utf8_hop((U8 *) s, -1);

                    while (s >= s0) {   /* Search backwards until find
                                           non-problematic char */
                        if (UTF8_IS_INVARIANT(*s)) {

                            /* There are no ascii characters that participate
                             * in multi-char folds under /aa.  In EBCDIC, the
                             * non-ascii invariants are all control characters,
                             * so don't ever participate in any folds. */
                            if (ASCII_FOLD_RESTRICTED
                                || ! IS_NON_FINAL_FOLD(*s))
                            {
                                break;
                            }
                        }
                        else if (UTF8_IS_DOWNGRADEABLE_START(*s)) {

                            /* No Latin1 characters participate in multi-char
                             * folds under /l */
                            if (LOC
                                || ! IS_NON_FINAL_FOLD(TWO_BYTE_UTF8_TO_UNI(
                                                                *s, *(s+1))))
                            {
                                break;
                            }
                        }
                        else if (! _invlist_contains_cp(
                                        PL_NonL1NonFinalFold,
                                        valid_utf8_to_uvchr((U8 *) s, NULL)))
                        {
                            break;
                        }

                        /* Here, the current character is problematic in that
                         * it does occur in the non-final position of some
                         * fold, so try the character before it, but have to
                         * special case the very first byte in the string, so
                         * we don't read outside the string */
                        s = (s == s0) ? s -1 : (char *) utf8_hop((U8 *) s, -1);
                    } /* End of loop backwards through the string */

                    /* If there were only problematic characters in the string,
                     * <s> will point to before s0, in which case the length
                     * should be 0, otherwise include the length of the
                     * non-problematic character just found */
                    len = (s < s0) ? 0 : s - s0 + UTF8SKIP(s);
		}

                /* Here, have found the final character, if any, that is
                 * non-problematic as far as ending the node without splitting
                 * it across a potential multi-char fold.  <len> contains the
                 * number of bytes in the node up-to and including that
                 * character, or is 0 if there is no such character, meaning
                 * the whole node contains only problematic characters.  In
                 * this case, give up and just take the node as-is.  We can't
                 * do any better */
                if (len == 0) {
                    len = full_len;
                } else {

                    /* Here, the node does contain some characters that aren't
                     * problematic.  If one such is the final character in the
                     * node, we are done */
                    if (len == full_len) {
                        goto loopdone;
                    }
                    else if (len + ((UTF) ? UTF8SKIP(s) : 1) == full_len) {

                        /* If the final character is problematic, but the
                         * penultimate is not, back-off that last character to
                         * later start a new node with it */
                        p = oldp;
                        goto loopdone;
                    }

                    /* Here, the final non-problematic character is earlier
                     * in the input than the penultimate character.  What we do
                     * is reparse from the beginning, going up only as far as
                     * this final ok one, thus guaranteeing that the node ends
                     * in an acceptable character.  The reason we reparse is
                     * that we know how far in the character is, but we don't
                     * know how to correlate its position with the input parse.
                     * An alternate implementation would be to build that
                     * correlation as we go along during the original parse,
                     * but that would entail extra work for every node, whereas
                     * this code gets executed only when the string is too
                     * large for the node, and the final two characters are
                     * problematic, an infrequent occurrence.  Yet another
                     * possible strategy would be to save the tail of the
                     * string, and the next time regatom is called, initialize
                     * with that.  The problem with this is that unless you
                     * back off one more character, you won't be guaranteed
                     * regatom will get called again, unless regbranch,
                     * regpiece ... are also changed.  If you do back off that
                     * extra character, so that there is input guaranteed to
                     * force calling regatom, you can't handle the case where
                     * just the first character in the node is acceptable.  I
                     * (khw) decided to try this method which doesn't have that
                     * pitfall; if performance issues are found, we can do a
                     * combination of the current approach plus that one */
                    upper_parse = len;
                    len = 0;
                    s = s0;
                    goto reparse;
                }
	    }   /* End of verifying node ends with an appropriate char */

a9909 17

            /* If 'maybe_exact' is still set here, means there are no
             * code points in the node that participate in folds */
            if (FOLD && maybe_exact) {
                OP(ret) = EXACT;
            }

            /* I (khw) don't know if you can get here with zero length, but the
             * old code handled this situation by creating a zero-length EXACT
             * node.  Might as well be NOTHING instead */
            if (len == 0) {
                OP(ret) = NOTHING;
            }
            else{
                alloc_maybe_populate_EXACT(pRExC_state, ret, flagp, len, ender);
            }

d9919 4
d9924 7
a9930 1
	} /* End of label 'defchar:' */
d9932 1
a9932 1
    } /* End of giant switch on input character */
d9935 5
a9968 34
STATIC char *
S_regpatws( RExC_state_t *pRExC_state, char *p , const bool recognize_comment )
{
    /* Returns the next non-pattern-white space, non-comment character (the
     * latter only if 'recognize_comment is true) in the string p, which is
     * ended by RExC_end.  If there is no line break ending a comment,
     * RExC_seen has added the REG_SEEN_RUN_ON_COMMENT flag; */
    const char *e = RExC_end;

    PERL_ARGS_ASSERT_REGPATWS;

    while (p < e) {
        STRLEN len;
	if ((len = is_PATWS_safe(p, e, UTF))) {
	    p += len;
        }
	else if (recognize_comment && *p == '#') {
            bool ended = 0;
	    do {
                p++;
                if (is_LNBREAK_safe(p, e, UTF)) {
		    ended = 1;
		    break;
		}
	    } while (p < e);
	    if (!ended)
	        RExC_seen |= REG_SEEN_RUN_ON_COMMENT;
	}
	else
	    break;
    }
    return p;
}

d9979 2
a9980 2
PERL_STATIC_INLINE I32
S_regpposixcc(pTHX_ RExC_state_t *pRExC_state, I32 value, const bool strict)
d9989 1
a9989 2
	POSIXCC(UCHARAT(RExC_parse)))
    {
d9995 1
a9995 11
	if (RExC_parse == RExC_end) {
            if (strict) {

                /* Try to give a better location for the error (than the end of
                 * the string) by looking for the matching ']' */
                RExC_parse = s;
                while (RExC_parse < RExC_end && UCHARAT(RExC_parse) != ']') {
                    RExC_parse++;
                }
                vFAIL2("Unmatched '%c' in POSIX class", c);
            }
a9997 1
        }
d10013 2
a10014 4
                        if (memEQ(posixcc, "word", 4)) /* this is not POSIX,
                                                          this is the Perl \w
                                                        */
			    namedclass = ANYOF_WORDCHAR;
d10024 1
a10024 1
				namedclass = ANYOF_ALPHA;
d10028 1
a10028 1
				namedclass = ANYOF_PSXSPC;
d10032 1
a10032 1
				namedclass = ANYOF_GRAPH;
d10036 1
a10036 1
				namedclass = ANYOF_ASCII;
d10040 1
a10040 1
				namedclass = ANYOF_BLANK;
d10044 1
a10044 1
				namedclass = ANYOF_CNTRL;
d10048 1
a10048 1
				namedclass = ANYOF_ALPHANUMERIC;
d10052 1
a10052 1
				namedclass = (FOLD) ? ANYOF_CASED : ANYOF_LOWER;
d10054 1
a10054 1
				namedclass = (FOLD) ? ANYOF_CASED : ANYOF_UPPER;
d10058 1
a10058 1
				namedclass = ANYOF_DIGIT;
d10060 1
a10060 1
				namedclass = ANYOF_PRINT;
d10062 1
a10062 1
				namedclass = ANYOF_PUNCT;
d10068 1
a10068 1
			    namedclass = ANYOF_XDIGIT;
a10074 6

                    /* The #defines are structured so each complement is +1 to
                     * the normal one */
                    if (complement) {
                        namedclass++;
                    }
d10084 1
a10084 1
		    vFAIL3("POSIX syntax [%c %c] is reserved for future extensions", c, c);
a10088 5
                if (strict) {
                    vFAIL("Unmatched '[' in POSIX class");
                }

                /* Grandfather lone [:, [=, [. */
d10097 2
a10098 2
STATIC bool
S_could_it_be_a_POSIX_class(pTHX_ RExC_state_t *pRExC_state)
d10100 3
a10102 19
    /* This applies some heuristics at the current parse position (which should
     * be at a '[') to see if what follows might be intended to be a [:posix:]
     * class.  It returns true if it really is a posix class, of course, but it
     * also can return true if it thinks that what was intended was a posix
     * class that didn't quite make it.
     *
     * It will return true for
     *      [:alphanumerics:
     *      [:alphanumerics]  (as long as the ] isn't followed immediately by a
     *                         ')' indicating the end of the (?[
     *      [:any garbage including %^&$ punctuation:]
     *
     * This is designed to be called only from S_handle_regex_sets; it could be
     * easily adapted to be called from the spot at the beginning of regclass()
     * that checks to see in a normal bracketed class if the surrounding []
     * have been omitted ([:word:] instead of [[:word:]]).  But doing so would
     * change long-standing behavior, so I (khw) didn't do that */
    char* p = RExC_parse + 1;
    char first_char = *p;
d10104 3
a10106 1
    PERL_ARGS_ASSERT_COULD_IT_BE_A_POSIX_CLASS;
d10108 6
a10113 1
    assert(*(p - 1) == '[');
d10115 9
a10123 2
    if (! POSIXCC(first_char)) {
        return FALSE;
d10125 1
d10127 38
a10164 2
    p++;
    while (p < RExC_end && isWORDCHAR(*p)) p++;
d10166 86
a10251 2
    if (p >= RExC_end) {
        return FALSE;
d10254 126
a10379 3
    if (p - RExC_parse > 2    /* Got at least 1 word character */
        && (*p == first_char
            || (*p == ']' && p + 1 < RExC_end && *(p + 1) != ')')))
d10381 7
a10387 1
        return TRUE;
d10390 2
a10391 1
    p = (char *) memchr(RExC_parse, ']', RExC_end - RExC_parse);
a10392 5
    return (p
            && p - RExC_parse > 2 /* [:] evaluates to colon;
                                      [::] is a bad posix class. */
            && first_char == *(p - 1));
}
d10394 2
a10395 3
STATIC regnode *
S_handle_regex_sets(pTHX_ RExC_state_t *pRExC_state, SV** return_invlist, I32 *flagp, U32 depth,
                   char * const oregcomp_parse)
d10397 3
a10399 1
    /* Handle the (?[...]) construct to do set operations */
d10401 1
a10401 9
    U8 curchar;
    UV start, end;	/* End points of code point ranges */
    SV* result_string;
    char *save_end, *save_parse;
    SV* final;
    STRLEN len;
    regnode* node;
    AV* stack;
    const bool save_fold = FOLD;
d10403 5
a10407 1
    GET_RE_DEBUG_FLAGS_DECL;
d10409 2
a10410 1
    PERL_ARGS_ASSERT_HANDLE_REGEX_SETS;
d10412 2
a10413 2
    if (LOC) {
        vFAIL("(?[...]) not valid in locale");
a10414 1
    RExC_uni_semantics = 1;
d10416 2
a10417 8
    /* This will return only an ANYOF regnode, or (unlikely) something smaller
     * (such as EXACT).  Thus we can skip most everything if just sizing.  We
     * call regclass to handle '[]' so as to not have to reinvent its parsing
     * rules here (throwing away the size it computes each time).  And, we exit
     * upon an unescaped ']' that isn't one ending a regclass.  To do both
     * these things, we need to realize that something preceded by a backslash
     * is escaped, so we have to keep track of backslashes */
    if (SIZE_ONLY) {
d10419 7
a10425 33
        Perl_ck_warner_d(aTHX_
            packWARN(WARN_EXPERIMENTAL__REGEX_SETS),
            "The regex_sets feature is experimental" REPORT_LOCATION,
            (int) (RExC_parse - RExC_precomp) , RExC_precomp, RExC_parse);

        while (RExC_parse < RExC_end) {
            SV* current = NULL;
            RExC_parse = regpatws(pRExC_state, RExC_parse,
                                TRUE); /* means recognize comments */
            switch (*RExC_parse) {
                default:
                    break;
                case '\\':
                    /* Skip the next byte (which could cause us to end up in
                     * the middle of a UTF-8 character, but since none of those
                     * are confusable with anything we currently handle in this
                     * switch (invariants all), it's safe.  We'll just hit the
                     * default: case next time and keep on incrementing until
                     * we find one of the invariants we do handle. */
                    RExC_parse++;
                    break;
                case '[':
                {
                    /* If this looks like it is a [:posix:] class, leave the
                     * parse pointer at the '[' to fool regclass() into
                     * thinking it is part of a '[[:posix:]]'.  That function
                     * will use strict checking to force a syntax error if it
                     * doesn't work out to a legitimate class */
                    bool is_posix_class
                                    = could_it_be_a_POSIX_class(pRExC_state);
                    if (! is_posix_class) {
                        RExC_parse++;
                    }
d10427 1
a10427 17
                    /* regclass() can only return RESTART_UTF8 if multi-char
                       folds are allowed.  */
                    if (!regclass(pRExC_state, flagp,depth+1,
                                  is_posix_class, /* parse the whole char
                                                     class only if not a
                                                     posix class */
                                  FALSE, /* don't allow multi-char folds */
                                  TRUE, /* silence non-portable warnings. */
                                  &current))
                        FAIL2("panic: regclass returned NULL to handle_sets, flags=%#X",
                              *flagp);

                    /* function call leaves parse pointing to the ']', except
                     * if we faked it */
                    if (is_posix_class) {
                        RExC_parse--;
                    }
d10429 7
a10435 3
                    SvREFCNT_dec(current);   /* In case it returned something */
                    break;
                }
d10437 6
a10442 398
                case ']':
                    RExC_parse++;
                    if (RExC_parse < RExC_end
                        && *RExC_parse == ')')
                    {
                        node = reganode(pRExC_state, ANYOF, 0);
                        RExC_size += ANYOF_SKIP;
                        nextchar(pRExC_state);
                        Set_Node_Length(node,
                                RExC_parse - oregcomp_parse + 1); /* MJD */
                        return node;
                    }
                    goto no_close;
            }
            RExC_parse++;
        }

        no_close:
        FAIL("Syntax error in (?[...])");
    }

    /* Pass 2 only after this.  Everything in this construct is a
     * metacharacter.  Operands begin with either a '\' (for an escape
     * sequence), or a '[' for a bracketed character class.  Any other
     * character should be an operator, or parenthesis for grouping.  Both
     * types of operands are handled by calling regclass() to parse them.  It
     * is called with a parameter to indicate to return the computed inversion
     * list.  The parsing here is implemented via a stack.  Each entry on the
     * stack is a single character representing one of the operators, or the
     * '('; or else a pointer to an operand inversion list. */

#define IS_OPERAND(a)  (! SvIOK(a))

    /* The stack starts empty.  It is a syntax error if the first thing parsed
     * is a binary operator; everything else is pushed on the stack.  When an
     * operand is parsed, the top of the stack is examined.  If it is a binary
     * operator, the item before it should be an operand, and both are replaced
     * by the result of doing that operation on the new operand and the one on
     * the stack.   Thus a sequence of binary operands is reduced to a single
     * one before the next one is parsed.
     *
     * A unary operator may immediately follow a binary in the input, for
     * example
     *      [a] + ! [b]
     * When an operand is parsed and the top of the stack is a unary operator,
     * the operation is performed, and then the stack is rechecked to see if
     * this new operand is part of a binary operation; if so, it is handled as
     * above.
     *
     * A '(' is simply pushed on the stack; it is valid only if the stack is
     * empty, or the top element of the stack is an operator or another '('
     * (for which the parenthesized expression will become an operand).  By the
     * time the corresponding ')' is parsed everything in between should have
     * been parsed and evaluated to a single operand (or else is a syntax
     * error), and is handled as a regular operand */

    sv_2mortal((SV *)(stack = newAV()));

    while (RExC_parse < RExC_end) {
        I32 top_index = av_tindex(stack);
        SV** top_ptr;
        SV* current = NULL;

        /* Skip white space */
        RExC_parse = regpatws(pRExC_state, RExC_parse,
                                TRUE); /* means recognize comments */
        if (RExC_parse >= RExC_end) {
            Perl_croak(aTHX_ "panic: Read past end of '(?[ ])'");
        }
        if ((curchar = UCHARAT(RExC_parse)) == ']') {
            break;
        }

        switch (curchar) {

            case '?':
                if (av_tindex(stack) >= 0   /* This makes sure that we can
                                               safely subtract 1 from
                                               RExC_parse in the next clause.
                                               If we have something on the
                                               stack, we have parsed something
                                             */
                    && UCHARAT(RExC_parse - 1) == '('
                    && RExC_parse < RExC_end)
                {
                    /* If is a '(?', could be an embedded '(?flags:(?[...])'.
                     * This happens when we have some thing like
                     *
                     *   my $thai_or_lao = qr/(?[ \p{Thai} + \p{Lao} ])/;
                     *   ...
                     *   qr/(?[ \p{Digit} & $thai_or_lao ])/;
                     *
                     * Here we would be handling the interpolated
                     * '$thai_or_lao'.  We handle this by a recursive call to
                     * ourselves which returns the inversion list the
                     * interpolated expression evaluates to.  We use the flags
                     * from the interpolated pattern. */
                    U32 save_flags = RExC_flags;
                    const char * const save_parse = ++RExC_parse;

                    parse_lparen_question_flags(pRExC_state);

                    if (RExC_parse == save_parse  /* Makes sure there was at
                                                     least one flag (or this
                                                     embedding wasn't compiled)
                                                   */
                        || RExC_parse >= RExC_end - 4
                        || UCHARAT(RExC_parse) != ':'
                        || UCHARAT(++RExC_parse) != '('
                        || UCHARAT(++RExC_parse) != '?'
                        || UCHARAT(++RExC_parse) != '[')
                    {

                        /* In combination with the above, this moves the
                         * pointer to the point just after the first erroneous
                         * character (or if there are no flags, to where they
                         * should have been) */
                        if (RExC_parse >= RExC_end - 4) {
                            RExC_parse = RExC_end;
                        }
                        else if (RExC_parse != save_parse) {
                            RExC_parse += (UTF) ? UTF8SKIP(RExC_parse) : 1;
                        }
                        vFAIL("Expecting '(?flags:(?[...'");
                    }
                    RExC_parse++;
                    (void) handle_regex_sets(pRExC_state, &current, flagp,
                                                    depth+1, oregcomp_parse);

                    /* Here, 'current' contains the embedded expression's
                     * inversion list, and RExC_parse points to the trailing
                     * ']'; the next character should be the ')' which will be
                     * paired with the '(' that has been put on the stack, so
                     * the whole embedded expression reduces to '(operand)' */
                    RExC_parse++;

                    RExC_flags = save_flags;
                    goto handle_operand;
                }
                /* FALL THROUGH */

            default:
                RExC_parse += (UTF) ? UTF8SKIP(RExC_parse) : 1;
                vFAIL("Unexpected character");

            case '\\':
                /* regclass() can only return RESTART_UTF8 if multi-char
                   folds are allowed.  */
                if (!regclass(pRExC_state, flagp,depth+1,
                              TRUE, /* means parse just the next thing */
                              FALSE, /* don't allow multi-char folds */
                              FALSE, /* don't silence non-portable warnings.  */
                              &current))
                    FAIL2("panic: regclass returned NULL to handle_sets, flags=%#X",
                          *flagp);
                /* regclass() will return with parsing just the \ sequence,
                 * leaving the parse pointer at the next thing to parse */
                RExC_parse--;
                goto handle_operand;

            case '[':   /* Is a bracketed character class */
            {
                bool is_posix_class = could_it_be_a_POSIX_class(pRExC_state);

                if (! is_posix_class) {
                    RExC_parse++;
                }

                /* regclass() can only return RESTART_UTF8 if multi-char
                   folds are allowed.  */
                if(!regclass(pRExC_state, flagp,depth+1,
                             is_posix_class, /* parse the whole char class
                                                only if not a posix class */
                             FALSE, /* don't allow multi-char folds */
                             FALSE, /* don't silence non-portable warnings.  */
                             &current))
                    FAIL2("panic: regclass returned NULL to handle_sets, flags=%#X",
                          *flagp);
                /* function call leaves parse pointing to the ']', except if we
                 * faked it */
                if (is_posix_class) {
                    RExC_parse--;
                }

                goto handle_operand;
            }

            case '&':
            case '|':
            case '+':
            case '-':
            case '^':
                if (top_index < 0
                    || ( ! (top_ptr = av_fetch(stack, top_index, FALSE)))
                    || ! IS_OPERAND(*top_ptr))
                {
                    RExC_parse++;
                    vFAIL2("Unexpected binary operator '%c' with no preceding operand", curchar);
                }
                av_push(stack, newSVuv(curchar));
                break;

            case '!':
                av_push(stack, newSVuv(curchar));
                break;

            case '(':
                if (top_index >= 0) {
                    top_ptr = av_fetch(stack, top_index, FALSE);
                    assert(top_ptr);
                    if (IS_OPERAND(*top_ptr)) {
                        RExC_parse++;
                        vFAIL("Unexpected '(' with no preceding operator");
                    }
                }
                av_push(stack, newSVuv(curchar));
                break;

            case ')':
            {
                SV* lparen;
                if (top_index < 1
                    || ! (current = av_pop(stack))
                    || ! IS_OPERAND(current)
                    || ! (lparen = av_pop(stack))
                    || IS_OPERAND(lparen)
                    || SvUV(lparen) != '(')
                {
                    SvREFCNT_dec(current);
                    RExC_parse++;
                    vFAIL("Unexpected ')'");
                }
                top_index -= 2;
                SvREFCNT_dec_NN(lparen);

                /* FALL THROUGH */
            }

              handle_operand:

                /* Here, we have an operand to process, in 'current' */

                if (top_index < 0) {    /* Just push if stack is empty */
                    av_push(stack, current);
                }
                else {
                    SV* top = av_pop(stack);
                    SV *prev = NULL;
                    char current_operator;

                    if (IS_OPERAND(top)) {
                        SvREFCNT_dec_NN(top);
                        SvREFCNT_dec_NN(current);
                        vFAIL("Operand with no preceding operator");
                    }
                    current_operator = (char) SvUV(top);
                    switch (current_operator) {
                        case '(':   /* Push the '(' back on followed by the new
                                       operand */
                            av_push(stack, top);
                            av_push(stack, current);
                            SvREFCNT_inc(top);  /* Counters the '_dec' done
                                                   just after the 'break', so
                                                   it doesn't get wrongly freed
                                                 */
                            break;

                        case '!':
                            _invlist_invert(current);

                            /* Unlike binary operators, the top of the stack,
                             * now that this unary one has been popped off, may
                             * legally be an operator, and we now have operand
                             * for it. */
                            top_index--;
                            SvREFCNT_dec_NN(top);
                            goto handle_operand;

                        case '&':
                            prev = av_pop(stack);
                            _invlist_intersection(prev,
                                                   current,
                                                   &current);
                            av_push(stack, current);
                            break;

                        case '|':
                        case '+':
                            prev = av_pop(stack);
                            _invlist_union(prev, current, &current);
                            av_push(stack, current);
                            break;

                        case '-':
                            prev = av_pop(stack);;
                            _invlist_subtract(prev, current, &current);
                            av_push(stack, current);
                            break;

                        case '^':   /* The union minus the intersection */
                        {
                            SV* i = NULL;
                            SV* u = NULL;
                            SV* element;

                            prev = av_pop(stack);
                            _invlist_union(prev, current, &u);
                            _invlist_intersection(prev, current, &i);
                            /* _invlist_subtract will overwrite current
                                without freeing what it already contains */
                            element = current;
                            _invlist_subtract(u, i, &current);
                            av_push(stack, current);
                            SvREFCNT_dec_NN(i);
                            SvREFCNT_dec_NN(u);
                            SvREFCNT_dec_NN(element);
                            break;
                        }

                        default:
                            Perl_croak(aTHX_ "panic: Unexpected item on '(?[ ])' stack");
                }
                SvREFCNT_dec_NN(top);
                SvREFCNT_dec(prev);
            }
        }

        RExC_parse += (UTF) ? UTF8SKIP(RExC_parse) : 1;
    }

    if (av_tindex(stack) < 0   /* Was empty */
        || ((final = av_pop(stack)) == NULL)
        || ! IS_OPERAND(final)
        || av_tindex(stack) >= 0)  /* More left on stack */
    {
        vFAIL("Incomplete expression within '(?[ ])'");
    }

    /* Here, 'final' is the resultant inversion list from evaluating the
     * expression.  Return it if so requested */
    if (return_invlist) {
        *return_invlist = final;
        return END;
    }

    /* Otherwise generate a resultant node, based on 'final'.  regclass() is
     * expecting a string of ranges and individual code points */
    invlist_iterinit(final);
    result_string = newSVpvs("");
    while (invlist_iternext(final, &start, &end)) {
        if (start == end) {
            Perl_sv_catpvf(aTHX_ result_string, "\\x{%"UVXf"}", start);
        }
        else {
            Perl_sv_catpvf(aTHX_ result_string, "\\x{%"UVXf"}-\\x{%"UVXf"}",
                                                     start,          end);
        }
    }

    save_parse = RExC_parse;
    RExC_parse = SvPV(result_string, len);
    save_end = RExC_end;
    RExC_end = RExC_parse + len;

    /* We turn off folding around the call, as the class we have constructed
     * already has all folding taken into consideration, and we don't want
     * regclass() to add to that */
    RExC_flags &= ~RXf_PMf_FOLD;
    /* regclass() can only return RESTART_UTF8 if multi-char folds are allowed.
     */
    node = regclass(pRExC_state, flagp,depth+1,
                    FALSE, /* means parse the whole char class */
                    FALSE, /* don't allow multi-char folds */
                    TRUE, /* silence non-portable warnings.  The above may very
                             well have generated non-portable code points, but
                             they're valid on this machine */
                    NULL);
    if (!node)
        FAIL2("panic: regclass returned NULL to handle_sets, flags=%#"UVxf,
                    PTR2UV(flagp));
    if (save_fold) {
        RExC_flags |= RXf_PMf_FOLD;
    }
    RExC_parse = save_parse + 1;
    RExC_end = save_end;
    SvREFCNT_dec_NN(final);
    SvREFCNT_dec_NN(result_string);

    nextchar(pRExC_state);
    Set_Node_Length(node, RExC_parse - oregcomp_parse + 1); /* MJD */
    return node;
}
#undef IS_OPERAND

/* The names of properties whose definitions are not known at compile time are
 * stored in this SV, after a constant heading.  So if the length has been
 * changed since initialization, then there is a run-time definition. */
#define HAS_NONLOCALE_RUNTIME_PROPERTY_DEFINITION (SvCUR(listsv) != initial_listsv_len)
d10445 2
a10446 34
S_regclass(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, U32 depth,
                 const bool stop_at_1,  /* Just parse the next thing, don't
                                           look for a full character class */
                 bool allow_multi_folds,
                 const bool silence_non_portable,   /* Don't output warnings
                                                       about too large
                                                       characters */
                 SV** ret_invlist)  /* Return an inversion list, not a node */
{
    /* parse a bracketed class specification.  Most of these will produce an
     * ANYOF node; but something like [a] will produce an EXACT node; [aA], an
     * EXACTFish node; [[:ascii:]], a POSIXA node; etc.  It is more complex
     * under /i with multi-character folds: it will be rewritten following the
     * paradigm of this example, where the <multi-fold>s are characters which
     * fold to multiple character sequences:
     *      /[abc\x{multi-fold1}def\x{multi-fold2}ghi]/i
     * gets effectively rewritten as:
     *      /(?:\x{multi-fold1}|\x{multi-fold2}|[abcdefghi]/i
     * reg() gets called (recursively) on the rewritten version, and this
     * function will return what it constructs.  (Actually the <multi-fold>s
     * aren't physically removed from the [abcdefghi], it's just that they are
     * ignored in the recursion by means of a flag:
     * <RExC_in_multi_char_class>.)
     *
     * ANYOF nodes contain a bit map for the first 256 characters, with the
     * corresponding bit set if that character is in the list.  For characters
     * above 255, a range list or swash is used.  There are extra bits for \w,
     * etc. in locale ANYOFs, as what these match is not determinable at
     * compile time
     *
     * Returns NULL, setting *flagp to RESTART_UTF8 if the sizing scan needs
     * to be restarted.  This can only happen if ret_invlist is non-NULL.
     */

d10448 5
a10452 4
    UV prevvalue = OOB_UNICODE, save_prevvalue = OOB_UNICODE;
    IV range = 0;
    UV value = OOB_UNICODE, save_value = OOB_UNICODE;
    regnode *ret;
d10454 1
a10454 1
    IV namedclass = OOB_NAMEDCLASS;
d10457 1
a10461 2
    SV* posixes = NULL;     /* Code points that match classes like, [:word:],
                               extended beyond the Latin1 range */
a10463 2
    AV * multi_char_matches = NULL; /* Code points that fold to more than one
                                       character; used under /i */
a10464 4
    char * stop_ptr = RExC_end;    /* where to stop parsing */
    const bool skip_white = cBOOL(ret_invlist); /* ignore unescaped white
                                                   space? */
    const bool strict = cBOOL(ret_invlist); /* Apply strict parsing rules? */
d10476 4
a10479 1
    bool has_user_defined_property = FALSE;
d10481 15
a10495 8
    /* inversion list of code points this node matches only when the target
     * string is in UTF-8.  (Because is under /d) */
    SV* depends_list = NULL;

    /* inversion list of code points this node matches.  For much of the
     * function, it includes only those that match regardless of the utf8ness
     * of the target string */
    SV* cp_list = NULL;
d10497 2
a10499 2
    /* In a range, counts how many 0-2 of the ends of it came from literals,
     * not escapes.  Thus we can tell if 'A' was input vs \x{C1} */
d10502 1
a10502 5
    bool invert = FALSE;    /* Is this class to be complemented */

    /* Is there any thing like \W or [:^digit:] that matches above the legal
     * Unicode range? */
    bool runtime_posix_matches_above_Unicode = FALSE;
a10506 1
    const I32 orig_size = RExC_size;
d10519 22
a10545 2
        ANYOF_FLAGS(ret) = 0;

d10550 2
a10551 1
	listsv = newSVpvs_flags("# comment\n", SVs_TEMP);
a10552 1
        SvTEMP_off(listsv); /* Grr, TEMPs and mortals are conflated.  */
d10555 1
a10555 31
    if (skip_white) {
        RExC_parse = regpatws(pRExC_state, RExC_parse,
                              FALSE /* means don't recognize comments */);
    }

    if (UCHARAT(RExC_parse) == '^') {	/* Complement of range. */
	RExC_parse++;
        invert = TRUE;
        allow_multi_folds = FALSE;
        RExC_naughty++;
        if (skip_white) {
            RExC_parse = regpatws(pRExC_state, RExC_parse,
                                  FALSE /* means don't recognize comments */);
        }
    }

    /* Check that they didn't say [:posix:] instead of [[:posix:]] */
    if (!SIZE_ONLY && RExC_parse < RExC_end && POSIXCC(UCHARAT(RExC_parse))) {
	const char *s = RExC_parse;
	const char  c = *s++;

	while (isWORDCHAR(*s))
	    s++;
	if (*s && c == *s && s[1] == ']') {
	    SAVEFREESV(RExC_rx_sv);
	    ckWARN3reg(s+2,
		       "POSIX syntax [%c %c] belongs inside character classes",
		       c, c);
	    (void)ReREFCNT_inc(RExC_rx_sv);
	}
    }
d10557 2
a10558 5
    /* If the caller wants us to just parse a single element, accomplish this
     * by faking the loop ending condition */
    if (stop_at_1 && RExC_end > RExC_parse) {
        stop_ptr = RExC_parse + 1;
    }
d10560 1
a10560 1
    /* allow 1st char to be ']' (allowing it to be '-' is dealt with later) */
d10565 1
a10565 13
    while (1) {
        if  (RExC_parse >= stop_ptr) {
            break;
        }

        if (skip_white) {
            RExC_parse = regpatws(pRExC_state, RExC_parse,
                                  FALSE /* means don't recognize comments */);
        }

        if  (UCHARAT(RExC_parse) == ']') {
            break;
        }
a10569 2
        save_value = value;
        save_prevvalue = prevvalue;
d10584 4
a10587 7
        if (value == '['
            && RExC_parse < RExC_end
            && POSIXCC(UCHARAT(RExC_parse)))
        {
            namedclass = regpposixcc(pRExC_state, value, strict);
        }
        else if (value == '\\') {
a10595 1

d10601 3
a10603 9

            /* If the \ is escaping white space when white space is being
             * skipped, it means that that white space is wanted literally, and
             * is already in 'value'.  Otherwise, need to translate the escape
             * into what it signifies. */
            if (! skip_white || ! is_PATWS_cp(value)) switch ((I32)value) {

	    case 'w':	namedclass = ANYOF_WORDCHAR;	break;
	    case 'W':	namedclass = ANYOF_NWORDCHAR;	break;
d10619 2
a10620 6
                    if (! grok_bslash_N(pRExC_state, NULL, &value, flagp, depth,
                                      TRUE, /* => charclass */
                                      strict))
                    {
                        if (*flagp & RESTART_UTF8)
                            FAIL("panic: grok_bslash_N set RESTART_UTF8");
d10623 1
a10629 4

                /* We will handle any undefined properties ourselves */
                U8 swash_init_flags = _CORE_SWASH_INIT_RETURN_IF_UNDEF;

d10650 1
a10652 1

d10656 1
a10656 5
                         /* toggle.  (The rhs xor gets the single bit that
                          * differs between P and p; the other xor inverts just
                          * that bit) */
                         value ^= 'P' ^ 'p';

d10679 1
a10679 1
                        SvREFCNT_dec_NN(swash);
d10684 3
a10686 2
                                             NULL, /* No inversion list */
                                             &swash_init_flags
d10688 8
a10695 1
                    if (! swash || ! (invlist = _get_swash_invlist(swash))) {
d10697 1
a10697 1
                            SvREFCNT_dec_NN(swash);
d10702 2
a10703 7
                         * property that will be available at run-time.  If we
                         * accept only compile-time properties, is an error;
                         * otherwise add it to the list for run-time look up */
                        if (ret_invlist) {
                            RExC_parse = e + 1;
                            vFAIL3("Property '%.*s' is unknown", (int) n, name);
                        }
d10707 1
a10707 1
                        has_user_defined_property = TRUE;
d10711 1
a10711 5
                         * hence something that isn't utf8.  Note that this
                         * would cause things in <depends_list> to match
                         * inappropriately, except that any \p{}, including
                         * this one forces Unicode semantics, which means there
                         * is <no depends_list> */
d10719 7
a10725 3
                        has_user_defined_property =
                                    (swash_init_flags
                                     & _CORE_SWASH_INIT_USER_DEFINED_PROPERTY);
d10729 1
a10729 3
			    _invlist_union_complement_2nd(properties,
                                                          invlist,
                                                          &properties);
d10734 1
a10734 1
                            SvREFCNT_dec_NN(swash);
d10744 1
a10744 2
                namedclass = ANYOF_UNIPROP;  /* no official name, but it's
                                                named */
d10761 1
a10761 1
		    bool valid = grok_bslash_o(&RExC_parse,
d10763 1
d10765 2
a10766 5
                                               SIZE_ONLY,   /* warnings in pass
                                                               1 only */
                                               strict,
                                               silence_non_portable,
                                               UTF);
d10776 16
a10791 13
		RExC_parse--;	/* function expects to be pointed at the 'x' */
		{
		    const char* error_msg;
		    bool valid = grok_bslash_x(&RExC_parse,
					       &value,
					       &error_msg,
					       TRUE, /* Output warnings */
                                               strict,
                                               silence_non_portable,
                                               UTF);
                    if (! valid) {
			vFAIL(error_msg);
		    }
d10804 2
a10805 2
                    numlen = (strict) ? 4 : 3;
                    value = grok_oct(--RExC_parse, &numlen, &flags, NULL);
a10806 18
                    if (numlen != 3) {
                        if (strict) {
                            RExC_parse += (UTF) ? UTF8SKIP(RExC_parse) : 1;
                            vFAIL("Need exactly 3 octal digits");
                        }
                        else if (! SIZE_ONLY /* like \08, \178 */
                                 && numlen < 3
                                 && RExC_parse < RExC_end
                                 && isDIGIT(*RExC_parse)
                                 && ckWARN(WARN_REGEXP))
                        {
                            SAVEFREESV(RExC_rx_sv);
                            reg_warn_non_literal_string(
                                 RExC_parse + 1,
                                 form_short_octal_warning(RExC_parse, numlen));
                            (void)ReREFCNT_inc(RExC_rx_sv);
                        }
                    }
d10815 2
a10816 6
		    if (!enc) {
                        if (strict) {
                            vFAIL("Invalid escape in the specified encoding");
                        }
                        else if (SIZE_ONLY) {
                            ckWARNreg(RExC_parse,
a10817 2
                        }
                    }
d10822 4
a10825 12
		if (!SIZE_ONLY && isWORDCHAR(value) && value != '_') {
                    if (strict) {
                        vFAIL2("Unrecognized escape \\%c in character class",
                               (int)value);
                    }
                    else {
                        SAVEFREESV(RExC_rx_sv);
                        ckWARN2reg(RExC_parse,
                            "Unrecognized escape \\%c in character class passed through",
                            (int)value);
                        (void)ReREFCNT_inc(RExC_rx_sv);
                    }
d10828 2
a10829 2
	    }   /* End of switch on char following backslash */
	} /* end of handling backslash escape sequences */
d10831 2
a10832 2
        else
            literal_endpoint++;
d10835 1
a10835 1
        /* Here, we have the current token in 'value' */
d10837 17
a10853 25
        /* What matches in a locale is not known until runtime.  This includes
         * what the Posix classes (like \w, [:space:]) match.  Room must be
         * reserved (one time per class) to store such classes, either if Perl
         * is compiled so that locale nodes always should have this space, or
         * if there is such class info to be stored.  The space will contain a
         * bit for each named class that is to be matched against.  This isn't
         * needed for \p{} and pseudo-classes, as they are not affected by
         * locale, and hence are dealt with separately */
        if (LOC
            && ! need_class
            && (ANYOF_LOCALE == ANYOF_CLASS
                || (namedclass > OOB_NAMEDCLASS && namedclass < ANYOF_MAX)))
        {
            need_class = 1;
            if (SIZE_ONLY) {
                RExC_size += ANYOF_CLASS_SKIP - ANYOF_SKIP;
            }
            else {
                RExC_emit += ANYOF_CLASS_SKIP - ANYOF_SKIP;
                ANYOF_CLASS_ZERO(ret);
            }
            ANYOF_FLAGS(ret) |= ANYOF_CLASS;
        }

	if (namedclass > OOB_NAMEDCLASS) { /* this is a named class \blah */
d10860 16
a10875 15
		    const int w = (RExC_parse >= rangebegin)
                                  ? RExC_parse - rangebegin
                                  : 0;
                    if (strict) {
                        vFAIL4("False [] range \"%*.*s\"", w, w, rangebegin);
                    }
                    else {
                        SAVEFREESV(RExC_rx_sv); /* in case of fatal warnings */
                        ckWARN4reg(RExC_parse,
                                "False [] range \"%*.*s\"",
                                w, w, rangebegin);
                        (void)ReREFCNT_inc(RExC_rx_sv);
                        cp_list = add_cp_to_invlist(cp_list, '-');
                        cp_list = add_cp_to_invlist(cp_list, prevvalue);
                    }
a10878 1
                element_count += 2; /* So counts for three values */
d10881 1
a10881 18
	    if (! SIZE_ONLY) {
                U8 classnum = namedclass_to_classnum(namedclass);
                if (namedclass >= ANYOF_MAX) {  /* If a special class */
                    if (namedclass != ANYOF_UNIPROP) { /* UNIPROP = \p and \P */

                        /* Here, should be \h, \H, \v, or \V.  Neither /d nor
                         * /l make a difference in what these match.  There
                         * would be problems if these characters had folds
                         * other than themselves, as cp_list is subject to
                         * folding. */
                        if (classnum != _CC_VERTSPACE) {
                            assert(   namedclass == ANYOF_HORIZWS
                                   || namedclass == ANYOF_NHORIZWS);

                            /* It turns out that \h is just a synonym for
                             * XPosixBlank */
                            classnum = _CC_BLANK;
                        }
d10883 29
a10911 7
                        _invlist_union_maybe_complement_2nd(
                                cp_list,
                                PL_XPosix_ptrs[classnum],
                                cBOOL(namedclass % 2), /* Complement if odd
                                                          (NHORIZWS, NVERTWS)
                                                        */
                                &cp_list);
d10913 9
a10921 20
                }
                else if (classnum == _CC_ASCII) {
#ifdef HAS_ISASCII
                    if (LOC) {
                        ANYOF_CLASS_SET(ret, namedclass);
                    }
                    else
#endif  /* Not isascii(); just use the hard-coded definition for it */
                    {
                        _invlist_union_maybe_complement_2nd(
                                posixes,
                                PL_ASCII,
                                cBOOL(namedclass % 2), /* Complement if odd
                                                          (NASCII) */
                                &posixes);

                        /* The code points 128-255 added above will be
                         * subtracted out below under /d, so the flag needs to
                         * be set */
                        if (namedclass == ANYOF_NASCII && DEPENDS_SEMANTICS) {
d10925 48
a10972 2
                }
                else {  /* Garden variety class */
d10974 137
a11110 886
                    /* The ascii range inversion list */
                    SV* ascii_source = PL_Posix_ptrs[classnum];

                    /* The full Latin1 range inversion list */
                    SV* l1_source = PL_L1Posix_ptrs[classnum];

                    /* This code is structured into two major clauses.  The
                     * first is for classes whose complete definitions may not
                     * already be known.  It not, the Latin1 definition
                     * (guaranteed to already known) is used plus code is
                     * generated to load the rest at run-time (only if needed).
                     * If the complete definition is known, it drops down to
                     * the second clause, where the complete definition is
                     * known */

                    if (classnum < _FIRST_NON_SWASH_CC) {

                        /* Here, the class has a swash, which may or not
                         * already be loaded */

                        /* The name of the property to use to match the full
                         * eXtended Unicode range swash for this character
                         * class */
                        const char *Xname = swash_property_names[classnum];

                        /* If returning the inversion list, we can't defer
                         * getting this until runtime */
                        if (ret_invlist && !  PL_utf8_swash_ptrs[classnum]) {
                            PL_utf8_swash_ptrs[classnum] =
                                _core_swash_init("utf8", Xname, &PL_sv_undef,
                                             1, /* binary */
                                             0, /* not tr/// */
                                             NULL, /* No inversion list */
                                             NULL  /* No flags */
                                            );
                            assert(PL_utf8_swash_ptrs[classnum]);
                        }
                        if ( !  PL_utf8_swash_ptrs[classnum]) {
                            if (namedclass % 2 == 0) { /* A non-complemented
                                                          class */
                                /* If not /a matching, there are code points we
                                 * don't know at compile time.  Arrange for the
                                 * unknown matches to be loaded at run-time, if
                                 * needed */
                                if (! AT_LEAST_ASCII_RESTRICTED) {
                                    Perl_sv_catpvf(aTHX_ listsv, "+utf8::%s\n",
                                                                 Xname);
                                }
                                if (LOC) {  /* Under locale, set run-time
                                               lookup */
                                    ANYOF_CLASS_SET(ret, namedclass);
                                }
                                else {
                                    /* Add the current class's code points to
                                     * the running total */
                                    _invlist_union(posixes,
                                                   (AT_LEAST_ASCII_RESTRICTED)
                                                        ? ascii_source
                                                        : l1_source,
                                                   &posixes);
                                }
                            }
                            else {  /* A complemented class */
                                if (AT_LEAST_ASCII_RESTRICTED) {
                                    /* Under /a should match everything above
                                     * ASCII, plus the complement of the set's
                                     * ASCII matches */
                                    _invlist_union_complement_2nd(posixes,
                                                                  ascii_source,
                                                                  &posixes);
                                }
                                else {
                                    /* Arrange for the unknown matches to be
                                     * loaded at run-time, if needed */
                                    Perl_sv_catpvf(aTHX_ listsv, "!utf8::%s\n",
                                                                 Xname);
                                    runtime_posix_matches_above_Unicode = TRUE;
                                    if (LOC) {
                                        ANYOF_CLASS_SET(ret, namedclass);
                                    }
                                    else {

                                        /* We want to match everything in
                                         * Latin1, except those things that
                                         * l1_source matches */
                                        SV* scratch_list = NULL;
                                        _invlist_subtract(PL_Latin1, l1_source,
                                                          &scratch_list);

                                        /* Add the list from this class to the
                                         * running total */
                                        if (! posixes) {
                                            posixes = scratch_list;
                                        }
                                        else {
                                            _invlist_union(posixes,
                                                           scratch_list,
                                                           &posixes);
                                            SvREFCNT_dec_NN(scratch_list);
                                        }
                                        if (DEPENDS_SEMANTICS) {
                                            ANYOF_FLAGS(ret)
                                                  |= ANYOF_NON_UTF8_LATIN1_ALL;
                                        }
                                    }
                                }
                            }
                            goto namedclass_done;
                        }

                        /* Here, there is a swash loaded for the class.  If no
                         * inversion list for it yet, get it */
                        if (! PL_XPosix_ptrs[classnum]) {
                            PL_XPosix_ptrs[classnum]
                             = _swash_to_invlist(PL_utf8_swash_ptrs[classnum]);
                        }
                    }

                    /* Here there is an inversion list already loaded for the
                     * entire class */

                    if (namedclass % 2 == 0) {  /* A non-complemented class,
                                                   like ANYOF_PUNCT */
                        if (! LOC) {
                            /* For non-locale, just add it to any existing list
                             * */
                            _invlist_union(posixes,
                                           (AT_LEAST_ASCII_RESTRICTED)
                                               ? ascii_source
                                               : PL_XPosix_ptrs[classnum],
                                           &posixes);
                        }
                        else {  /* Locale */
                            SV* scratch_list = NULL;

                            /* For above Latin1 code points, we use the full
                             * Unicode range */
                            _invlist_intersection(PL_AboveLatin1,
                                                  PL_XPosix_ptrs[classnum],
                                                  &scratch_list);
                            /* And set the output to it, adding instead if
                             * there already is an output.  Checking if
                             * 'posixes' is NULL first saves an extra clone.
                             * Its reference count will be decremented at the
                             * next union, etc, or if this is the only
                             * instance, at the end of the routine */
                            if (! posixes) {
                                posixes = scratch_list;
                            }
                            else {
                                _invlist_union(posixes, scratch_list, &posixes);
                                SvREFCNT_dec_NN(scratch_list);
                            }

#ifndef HAS_ISBLANK
                            if (namedclass != ANYOF_BLANK) {
#endif
                                /* Set this class in the node for runtime
                                 * matching */
                                ANYOF_CLASS_SET(ret, namedclass);
#ifndef HAS_ISBLANK
                            }
                            else {
                                /* No isblank(), use the hard-coded ASCII-range
                                 * blanks, adding them to the running total. */

                                _invlist_union(posixes, ascii_source, &posixes);
                            }
#endif
                        }
                    }
                    else {  /* A complemented class, like ANYOF_NPUNCT */
                        if (! LOC) {
                            _invlist_union_complement_2nd(
                                                posixes,
                                                (AT_LEAST_ASCII_RESTRICTED)
                                                    ? ascii_source
                                                    : PL_XPosix_ptrs[classnum],
                                                &posixes);
                            /* Under /d, everything in the upper half of the
                             * Latin1 range matches this complement */
                            if (DEPENDS_SEMANTICS) {
                                ANYOF_FLAGS(ret) |= ANYOF_NON_UTF8_LATIN1_ALL;
                            }
                        }
                        else {  /* Locale */
                            SV* scratch_list = NULL;
                            _invlist_subtract(PL_AboveLatin1,
                                              PL_XPosix_ptrs[classnum],
                                              &scratch_list);
                            if (! posixes) {
                                posixes = scratch_list;
                            }
                            else {
                                _invlist_union(posixes, scratch_list, &posixes);
                                SvREFCNT_dec_NN(scratch_list);
                            }
#ifndef HAS_ISBLANK
                            if (namedclass != ANYOF_NBLANK) {
#endif
                                ANYOF_CLASS_SET(ret, namedclass);
#ifndef HAS_ISBLANK
                            }
                            else {
                                /* Get the list of all code points in Latin1
                                 * that are not ASCII blanks, and add them to
                                 * the running total */
                                _invlist_subtract(PL_Latin1, ascii_source,
                                                  &scratch_list);
                                _invlist_union(posixes, scratch_list, &posixes);
                                SvREFCNT_dec_NN(scratch_list);
                            }
#endif
                        }
                    }
                }
              namedclass_done:
		continue;   /* Go get next character */
	    }
	} /* end of namedclass \blah */

        /* Here, we have a single value.  If 'range' is set, it is the ending
         * of a range--check its validity.  Later, we will handle each
         * individual code point in the range.  If 'range' isn't set, this
         * could be the beginning of a range, so check for that by looking
         * ahead to see if the next real character to be processed is the range
         * indicator--the minus sign */

        if (skip_white) {
            RExC_parse = regpatws(pRExC_state, RExC_parse,
                                FALSE /* means don't recognize comments */);
        }

	if (range) {
	    if (prevvalue > value) /* b-a */ {
		const int w = RExC_parse - rangebegin;
		Simple_vFAIL4("Invalid [] range \"%*.*s\"", w, w, rangebegin);
		range = 0; /* not a valid range */
	    }
	}
	else {
            prevvalue = value; /* save the beginning of the potential range */
            if (! stop_at_1     /* Can't be a range if parsing just one thing */
                && *RExC_parse == '-')
            {
                char* next_char_ptr = RExC_parse + 1;
                if (skip_white) {   /* Get the next real char after the '-' */
                    next_char_ptr = regpatws(pRExC_state,
                                             RExC_parse + 1,
                                             FALSE); /* means don't recognize
                                                        comments */
                }

                /* If the '-' is at the end of the class (just before the ']',
                 * it is a literal minus; otherwise it is a range */
                if (next_char_ptr < RExC_end && *next_char_ptr != ']') {
                    RExC_parse = next_char_ptr;

                    /* a bad range like \w-, [:word:]- ? */
                    if (namedclass > OOB_NAMEDCLASS) {
                        if (strict || ckWARN(WARN_REGEXP)) {
                            const int w =
                                RExC_parse >= rangebegin ?
                                RExC_parse - rangebegin : 0;
                            if (strict) {
                                vFAIL4("False [] range \"%*.*s\"",
                                    w, w, rangebegin);
                            }
                            else {
                                vWARN4(RExC_parse,
                                    "False [] range \"%*.*s\"",
                                    w, w, rangebegin);
                            }
                        }
                        if (!SIZE_ONLY) {
                            cp_list = add_cp_to_invlist(cp_list, '-');
                        }
                        element_count++;
                    } else
                        range = 1;	/* yeah, it's a range! */
                    continue;	/* but do it the next time */
                }
	    }
	}

        /* Here, <prevvalue> is the beginning of the range, if any; or <value>
         * if not */

	/* non-Latin1 code point implies unicode semantics.  Must be set in
	 * pass1 so is there for the whole of pass 2 */
	if (value > 255) {
	    RExC_uni_semantics = 1;
	}

        /* Ready to process either the single value, or the completed range.
         * For single-valued non-inverted ranges, we consider the possibility
         * of multi-char folds.  (We made a conscious decision to not do this
         * for the other cases because it can often lead to non-intuitive
         * results.  For example, you have the peculiar case that:
         *  "s s" =~ /^[^\xDF]+$/i => Y
         *  "ss"  =~ /^[^\xDF]+$/i => N
         *
         * See [perl #89750] */
        if (FOLD && allow_multi_folds && value == prevvalue) {
            if (value == LATIN_SMALL_LETTER_SHARP_S
                || (value > 255 && _invlist_contains_cp(PL_HasMultiCharFold,
                                                        value)))
            {
                /* Here <value> is indeed a multi-char fold.  Get what it is */

                U8 foldbuf[UTF8_MAXBYTES_CASE];
                STRLEN foldlen;

                UV folded = _to_uni_fold_flags(
                                value,
                                foldbuf,
                                &foldlen,
                                FOLD_FLAGS_FULL
                                | ((LOC) ?  FOLD_FLAGS_LOCALE
                                            : (ASCII_FOLD_RESTRICTED)
                                              ? FOLD_FLAGS_NOMIX_ASCII
                                              : 0)
                                );

                /* Here, <folded> should be the first character of the
                 * multi-char fold of <value>, with <foldbuf> containing the
                 * whole thing.  But, if this fold is not allowed (because of
                 * the flags), <fold> will be the same as <value>, and should
                 * be processed like any other character, so skip the special
                 * handling */
                if (folded != value) {

                    /* Skip if we are recursed, currently parsing the class
                     * again.  Otherwise add this character to the list of
                     * multi-char folds. */
                    if (! RExC_in_multi_char_class) {
                        AV** this_array_ptr;
                        AV* this_array;
                        STRLEN cp_count = utf8_length(foldbuf,
                                                      foldbuf + foldlen);
                        SV* multi_fold = sv_2mortal(newSVpvn("", 0));

                        Perl_sv_catpvf(aTHX_ multi_fold, "\\x{%"UVXf"}", value);


                        if (! multi_char_matches) {
                            multi_char_matches = newAV();
                        }

                        /* <multi_char_matches> is actually an array of arrays.
                         * There will be one or two top-level elements: [2],
                         * and/or [3].  The [2] element is an array, each
                         * element thereof is a character which folds to two
                         * characters; likewise for [3].  (Unicode guarantees a
                         * maximum of 3 characters in any fold.)  When we
                         * rewrite the character class below, we will do so
                         * such that the longest folds are written first, so
                         * that it prefers the longest matching strings first.
                         * This is done even if it turns out that any
                         * quantifier is non-greedy, out of programmer
                         * laziness.  Tom Christiansen has agreed that this is
                         * ok.  This makes the test for the ligature 'ffi' come
                         * before the test for 'ff' */
                        if (av_exists(multi_char_matches, cp_count)) {
                            this_array_ptr = (AV**) av_fetch(multi_char_matches,
                                                             cp_count, FALSE);
                            this_array = *this_array_ptr;
                        }
                        else {
                            this_array = newAV();
                            av_store(multi_char_matches, cp_count,
                                     (SV*) this_array);
                        }
                        av_push(this_array, multi_fold);
                    }

                    /* This element should not be processed further in this
                     * class */
                    element_count--;
                    value = save_value;
                    prevvalue = save_prevvalue;
                    continue;
                }
            }
        }

        /* Deal with this element of the class */
	if (! SIZE_ONLY) {
#ifndef EBCDIC
            cp_list = _add_range_to_invlist(cp_list, prevvalue, value);
#else
            SV* this_range = _new_invlist(1);
            _append_range_to_invlist(this_range, prevvalue, value);

            /* In EBCDIC, the ranges 'A-Z' and 'a-z' are each not contiguous.
             * If this range was specified using something like 'i-j', we want
             * to include only the 'i' and the 'j', and not anything in
             * between, so exclude non-ASCII, non-alphabetics from it.
             * However, if the range was specified with something like
             * [\x89-\x91] or [\x89-j], all code points within it should be
             * included.  literal_endpoint==2 means both ends of the range used
             * a literal character, not \x{foo} */
	    if (literal_endpoint == 2
                && (prevvalue >= 'a' && value <= 'z')
                    || (prevvalue >= 'A' && value <= 'Z'))
            {
                _invlist_intersection(this_range, PL_Posix_ptrs[_CC_ALPHA],
                                      &this_range);
            }
            _invlist_union(cp_list, this_range, &cp_list);
            literal_endpoint = 0;
#endif
        }

	range = 0; /* this range (if it was one) is done now */
    } /* End of loop through all the text within the brackets */

    /* If anything in the class expands to more than one character, we have to
     * deal with them by building up a substitute parse string, and recursively
     * calling reg() on it, instead of proceeding */
    if (multi_char_matches) {
	SV * substitute_parse = newSVpvn_flags("?:", 2, SVs_TEMP);
        I32 cp_count;
	STRLEN len;
	char *save_end = RExC_end;
	char *save_parse = RExC_parse;
        bool first_time = TRUE;     /* First multi-char occurrence doesn't get
                                       a "|" */
        I32 reg_flags;

        assert(! invert);
#if 0   /* Have decided not to deal with multi-char folds in inverted classes,
           because too confusing */
        if (invert) {
            sv_catpv(substitute_parse, "(?:");
        }
#endif

        /* Look at the longest folds first */
        for (cp_count = av_len(multi_char_matches); cp_count > 0; cp_count--) {

            if (av_exists(multi_char_matches, cp_count)) {
                AV** this_array_ptr;
                SV* this_sequence;

                this_array_ptr = (AV**) av_fetch(multi_char_matches,
                                                 cp_count, FALSE);
                while ((this_sequence = av_pop(*this_array_ptr)) !=
                                                                &PL_sv_undef)
                {
                    if (! first_time) {
                        sv_catpv(substitute_parse, "|");
                    }
                    first_time = FALSE;

                    sv_catpv(substitute_parse, SvPVX(this_sequence));
                }
            }
        }

        /* If the character class contains anything else besides these
         * multi-character folds, have to include it in recursive parsing */
        if (element_count) {
            sv_catpv(substitute_parse, "|[");
            sv_catpvn(substitute_parse, orig_parse, RExC_parse - orig_parse);
            sv_catpv(substitute_parse, "]");
        }

        sv_catpv(substitute_parse, ")");
#if 0
        if (invert) {
            /* This is a way to get the parse to skip forward a whole named
             * sequence instead of matching the 2nd character when it fails the
             * first */
            sv_catpv(substitute_parse, "(*THEN)(*SKIP)(*FAIL)|.)");
        }
#endif

	RExC_parse = SvPV(substitute_parse, len);
	RExC_end = RExC_parse + len;
        RExC_in_multi_char_class = 1;
        RExC_emit = (regnode *)orig_emit;

	ret = reg(pRExC_state, 1, &reg_flags, depth+1);

	*flagp |= reg_flags&(HASWIDTH|SIMPLE|SPSTART|POSTPONED|RESTART_UTF8);

	RExC_parse = save_parse;
	RExC_end = save_end;
	RExC_in_multi_char_class = 0;
        SvREFCNT_dec_NN(multi_char_matches);
        return ret;
    }

    /* If the character class contains only a single element, it may be
     * optimizable into another node type which is smaller and runs faster.
     * Check if this is the case for this class */
    if (element_count == 1 && ! ret_invlist) {
        U8 op = END;
        U8 arg = 0;

        if (namedclass > OOB_NAMEDCLASS) { /* this is a named class, like \w or
                                              [:digit:] or \p{foo} */

            /* All named classes are mapped into POSIXish nodes, with its FLAG
             * argument giving which class it is */
            switch ((I32)namedclass) {
                case ANYOF_UNIPROP:
                    break;

                /* These don't depend on the charset modifiers.  They always
                 * match under /u rules */
                case ANYOF_NHORIZWS:
                case ANYOF_HORIZWS:
                    namedclass = ANYOF_BLANK + namedclass - ANYOF_HORIZWS;
                    /* FALLTHROUGH */

                case ANYOF_NVERTWS:
                case ANYOF_VERTWS:
                    op = POSIXU;
                    goto join_posix;

                /* The actual POSIXish node for all the rest depends on the
                 * charset modifier.  The ones in the first set depend only on
                 * ASCII or, if available on this platform, locale */
                case ANYOF_ASCII:
                case ANYOF_NASCII:
#ifdef HAS_ISASCII
                    op = (LOC) ? POSIXL : POSIXA;
#else
                    op = POSIXA;
#endif
                    goto join_posix;

                case ANYOF_NCASED:
                case ANYOF_LOWER:
                case ANYOF_NLOWER:
                case ANYOF_UPPER:
                case ANYOF_NUPPER:
                    /* under /a could be alpha */
                    if (FOLD) {
                        if (ASCII_RESTRICTED) {
                            namedclass = ANYOF_ALPHA + (namedclass % 2);
                        }
                        else if (! LOC) {
                            break;
                        }
                    }
                    /* FALLTHROUGH */

                /* The rest have more possibilities depending on the charset.
                 * We take advantage of the enum ordering of the charset
                 * modifiers to get the exact node type, */
                default:
                    op = POSIXD + get_regex_charset(RExC_flags);
                    if (op > POSIXA) { /* /aa is same as /a */
                        op = POSIXA;
                    }
#ifndef HAS_ISBLANK
                    if (op == POSIXL
                        && (namedclass == ANYOF_BLANK
                            || namedclass == ANYOF_NBLANK))
                    {
                        op = POSIXA;
                    }
#endif

                join_posix:
                    /* The odd numbered ones are the complements of the
                     * next-lower even number one */
                    if (namedclass % 2 == 1) {
                        invert = ! invert;
                        namedclass--;
                    }
                    arg = namedclass_to_classnum(namedclass);
                    break;
            }
        }
        else if (value == prevvalue) {

            /* Here, the class consists of just a single code point */

            if (invert) {
                if (! LOC && value == '\n') {
                    op = REG_ANY; /* Optimize [^\n] */
                    *flagp |= HASWIDTH|SIMPLE;
                    RExC_naughty++;
                }
            }
            else if (value < 256 || UTF) {

                /* Optimize a single value into an EXACTish node, but not if it
                 * would require converting the pattern to UTF-8. */
                op = compute_EXACTish(pRExC_state);
            }
        } /* Otherwise is a range */
        else if (! LOC) {   /* locale could vary these */
            if (prevvalue == '0') {
                if (value == '9') {
                    arg = _CC_DIGIT;
                    op = POSIXA;
                }
            }
        }

        /* Here, we have changed <op> away from its initial value iff we found
         * an optimization */
        if (op != END) {

            /* Throw away this ANYOF regnode, and emit the calculated one,
             * which should correspond to the beginning, not current, state of
             * the parse */
            const char * cur_parse = RExC_parse;
            RExC_parse = (char *)orig_parse;
            if ( SIZE_ONLY) {
                if (! LOC) {

                    /* To get locale nodes to not use the full ANYOF size would
                     * require moving the code above that writes the portions
                     * of it that aren't in other nodes to after this point.
                     * e.g.  ANYOF_CLASS_SET */
                    RExC_size = orig_size;
                }
            }
            else {
                RExC_emit = (regnode *)orig_emit;
                if (PL_regkind[op] == POSIXD) {
                    if (invert) {
                        op += NPOSIXD - POSIXD;
                    }
                }
            }

            ret = reg_node(pRExC_state, op);

            if (PL_regkind[op] == POSIXD || PL_regkind[op] == NPOSIXD) {
                if (! SIZE_ONLY) {
                    FLAGS(ret) = arg;
                }
                *flagp |= HASWIDTH|SIMPLE;
            }
            else if (PL_regkind[op] == EXACT) {
                alloc_maybe_populate_EXACT(pRExC_state, ret, flagp, 0, value);
            }

            RExC_parse = (char *) cur_parse;

            SvREFCNT_dec(posixes);
            SvREFCNT_dec(cp_list);
            return ret;
        }
    }

    if (SIZE_ONLY)
        return ret;
    /****** !SIZE_ONLY (Pass 2) AFTER HERE *********/

    /* If folding, we calculate all characters that could fold to or from the
     * ones already on the list */
    if (FOLD && cp_list) {
	UV start, end;	/* End points of code point ranges */

	SV* fold_intersection = NULL;

        /* If the highest code point is within Latin1, we can use the
         * compiled-in Alphas list, and not have to go out to disk.  This
         * yields two false positives, the masculine and feminine ordinal
         * indicators, which are weeded out below using the
         * IS_IN_SOME_FOLD_L1() macro */
        if (invlist_highest(cp_list) < 256) {
            _invlist_intersection(PL_L1Posix_ptrs[_CC_ALPHA], cp_list,
                                                           &fold_intersection);
        }
        else {

            /* Here, there are non-Latin1 code points, so we will have to go
             * fetch the list of all the characters that participate in folds
             */
            if (! PL_utf8_foldable) {
                SV* swash = swash_init("utf8", "_Perl_Any_Folds",
                                       &PL_sv_undef, 1, 0);
                PL_utf8_foldable = _get_swash_invlist(swash);
                SvREFCNT_dec_NN(swash);
            }

            /* This is a hash that for a particular fold gives all characters
             * that are involved in it */
            if (! PL_utf8_foldclosures) {

                /* If we were unable to find any folds, then we likely won't be
                 * able to find the closures.  So just create an empty list.
                 * Folding will effectively be restricted to the non-Unicode
                 * rules hard-coded into Perl.  (This case happens legitimately
                 * during compilation of Perl itself before the Unicode tables
                 * are generated) */
                if (_invlist_len(PL_utf8_foldable) == 0) {
                    PL_utf8_foldclosures = newHV();
                }
                else {
                    /* If the folds haven't been read in, call a fold function
                     * to force that */
                    if (! PL_utf8_tofold) {
                        U8 dummy[UTF8_MAXBYTES+1];

                        /* This string is just a short named one above \xff */
                        to_utf8_fold((U8*) HYPHEN_UTF8, dummy, NULL);
                        assert(PL_utf8_tofold); /* Verify that worked */
                    }
                    PL_utf8_foldclosures =
                                    _swash_inversion_hash(PL_utf8_tofold);
                }
            }

            /* Only the characters in this class that participate in folds need
             * be checked.  Get the intersection of this class and all the
             * possible characters that are foldable.  This can quickly narrow
             * down a large class */
            _invlist_intersection(PL_utf8_foldable, cp_list,
                                  &fold_intersection);
        }

	/* Now look at the foldable characters in this class individually */
	invlist_iterinit(fold_intersection);
	while (invlist_iternext(fold_intersection, &start, &end)) {
	    UV j;

            /* Locale folding for Latin1 characters is deferred until runtime */
            if (LOC && start < 256) {
                start = 256;
            }

	    /* Look at every character in the range */
	    for (j = start; j <= end; j++) {

		U8 foldbuf[UTF8_MAXBYTES_CASE+1];
		STRLEN foldlen;
                SV** listp;

                if (j < 256) {

                    /* We have the latin1 folding rules hard-coded here so that
                     * an innocent-looking character class, like /[ks]/i won't
                     * have to go out to disk to find the possible matches.
                     * XXX It would be better to generate these via regen, in
                     * case a new version of the Unicode standard adds new
                     * mappings, though that is not really likely, and may be
                     * caught by the default: case of the switch below. */

                    if (IS_IN_SOME_FOLD_L1(j)) {

                        /* ASCII is always matched; non-ASCII is matched only
                         * under Unicode rules */
                        if (isASCII(j) || AT_LEAST_UNI_SEMANTICS) {
                            cp_list =
                                add_cp_to_invlist(cp_list, PL_fold_latin1[j]);
                        }
                        else {
                            depends_list =
                             add_cp_to_invlist(depends_list, PL_fold_latin1[j]);
                        }
                    }

                    if (HAS_NONLATIN1_FOLD_CLOSURE(j)
                        && (! isASCII(j) || ! ASCII_FOLD_RESTRICTED))
                    {
                        /* Certain Latin1 characters have matches outside
                         * Latin1.  To get here, <j> is one of those
                         * characters.   None of these matches is valid for
                         * ASCII characters under /aa, which is why the 'if'
                         * just above excludes those.  These matches only
                         * happen when the target string is utf8.  The code
                         * below adds the single fold closures for <j> to the
                         * inversion list. */
                        switch (j) {
                            case 'k':
                            case 'K':
                                cp_list =
                                    add_cp_to_invlist(cp_list, KELVIN_SIGN);
                                break;
                            case 's':
                            case 'S':
                                cp_list = add_cp_to_invlist(cp_list,
                                                    LATIN_SMALL_LETTER_LONG_S);
                                break;
                            case MICRO_SIGN:
                                cp_list = add_cp_to_invlist(cp_list,
                                                    GREEK_CAPITAL_LETTER_MU);
                                cp_list = add_cp_to_invlist(cp_list,
                                                    GREEK_SMALL_LETTER_MU);
                                break;
                            case LATIN_CAPITAL_LETTER_A_WITH_RING_ABOVE:
                            case LATIN_SMALL_LETTER_A_WITH_RING_ABOVE:
                                cp_list =
                                    add_cp_to_invlist(cp_list, ANGSTROM_SIGN);
                                break;
                            case LATIN_SMALL_LETTER_Y_WITH_DIAERESIS:
                                cp_list = add_cp_to_invlist(cp_list,
                                        LATIN_CAPITAL_LETTER_Y_WITH_DIAERESIS);
                                break;
                            case LATIN_SMALL_LETTER_SHARP_S:
                                cp_list = add_cp_to_invlist(cp_list,
                                                LATIN_CAPITAL_LETTER_SHARP_S);
                                break;
                            case 'F': case 'f':
                            case 'I': case 'i':
                            case 'L': case 'l':
                            case 'T': case 't':
                            case 'A': case 'a':
                            case 'H': case 'h':
                            case 'J': case 'j':
                            case 'N': case 'n':
                            case 'W': case 'w':
                            case 'Y': case 'y':
                                /* These all are targets of multi-character
                                 * folds from code points that require UTF8 to
                                 * express, so they can't match unless the
                                 * target string is in UTF-8, so no action here
                                 * is necessary, as regexec.c properly handles
                                 * the general case for UTF-8 matching and
                                 * multi-char folds */
                                break;
                            default:
                                /* Use deprecated warning to increase the
                                 * chances of this being output */
                                ckWARN2regdep(RExC_parse, "Perl folding rules are not up-to-date for 0x%"UVXf"; please use the perlbug utility to report;", j);
                                break;
                        }
                    }
                    continue;
                }

                /* Here is an above Latin1 character.  We don't have the rules
                 * hard-coded for it.  First, get its fold.  This is the simple
                 * fold, as the multi-character folds have been handled earlier
                 * and separated out */
		_to_uni_fold_flags(j, foldbuf, &foldlen,
                                               ((LOC)
                                               ? FOLD_FLAGS_LOCALE
                                               : (ASCII_FOLD_RESTRICTED)
                                                  ? FOLD_FLAGS_NOMIX_ASCII
                                                  : 0));

                /* Single character fold of above Latin1.  Add everything in
                 * its fold closure to the list that this node should match.
                 * The fold closures data structure is a hash with the keys
                 * being the UTF-8 of every character that is folded to, like
                 * 'k', and the values each an array of all code points that
                 * fold to its key.  e.g. [ 'k', 'K', KELVIN_SIGN ].
                 * Multi-character folds are not included */
                if ((listp = hv_fetch(PL_utf8_foldclosures,
                                      (char *) foldbuf, foldlen, FALSE)))
                {
                    AV* list = (AV*) *listp;
                    IV k;
                    for (k = 0; k <= av_len(list); k++) {
                        SV** c_p = av_fetch(list, k, FALSE);
                        UV c;
                        if (c_p == NULL) {
                            Perl_croak(aTHX_ "panic: invalid PL_utf8_foldclosures structure");
                        }
                        c = SvUV(*c_p);

                        /* /aa doesn't allow folds between ASCII and non-; /l
                         * doesn't allow them between above and below 256 */
                        if ((ASCII_FOLD_RESTRICTED
                                  && (isASCII(c) != isASCII(j)))
                            || (LOC && ((c < 256) != (j < 256))))
                        {
                            continue;
                        }

                        /* Folds involving non-ascii Latin1 characters
                         * under /d are added to a separate list */
                        if (isASCII(c) || c > 255 || AT_LEAST_UNI_SEMANTICS)
                        {
                            cp_list = add_cp_to_invlist(cp_list, c);
                        }
                        else {
                          depends_list = add_cp_to_invlist(depends_list, c);
                        }
                    }
                }
            }
	}
	SvREFCNT_dec_NN(fold_intersection);
    }
d11112 3
a11114 31
    /* And combine the result (if any) with any inversion list from posix
     * classes.  The lists are kept separate up to now because we don't want to
     * fold the classes (folding of those is automatically handled by the swash
     * fetching code) */
    if (posixes) {
        if (! DEPENDS_SEMANTICS) {
            if (cp_list) {
                _invlist_union(cp_list, posixes, &cp_list);
                SvREFCNT_dec_NN(posixes);
            }
            else {
                cp_list = posixes;
            }
        }
        else {
            /* Under /d, we put into a separate list the Latin1 things that
             * match only when the target string is utf8 */
            SV* nonascii_but_latin1_properties = NULL;
            _invlist_intersection(posixes, PL_Latin1,
                                  &nonascii_but_latin1_properties);
            _invlist_subtract(nonascii_but_latin1_properties, PL_ASCII,
                              &nonascii_but_latin1_properties);
            _invlist_subtract(posixes, nonascii_but_latin1_properties,
                              &posixes);
            if (cp_list) {
                _invlist_union(cp_list, posixes, &cp_list);
                SvREFCNT_dec_NN(posixes);
            }
            else {
                cp_list = posixes;
            }
d11116 14
a11129 10
            if (depends_list) {
                _invlist_union(depends_list, nonascii_but_latin1_properties,
                               &depends_list);
                SvREFCNT_dec_NN(nonascii_but_latin1_properties);
            }
            else {
                depends_list = nonascii_but_latin1_properties;
            }
        }
    }
d11131 18
a11148 14
    /* And combine the result (if any) with any inversion list from properties.
     * The lists are kept separate up to now so that we can distinguish the two
     * in regards to matching above-Unicode.  A run-time warning is generated
     * if a Unicode property is matched against a non-Unicode code point. But,
     * we allow user-defined properties to match anything, without any warning,
     * and we also suppress the warning if there is a portion of the character
     * class that isn't a Unicode property, and which matches above Unicode, \W
     * or [\x{110000}] for example.
     * (Note that in this case, unlike the Posix one above, there is no
     * <depends_list>, because having a Unicode property forces Unicode
     * semantics */
    if (properties) {
        bool warn_super = ! has_user_defined_property;
        if (cp_list) {
d11150 5
a11154 17
            /* If it matters to the final outcome, see if a non-property
             * component of the class matches above Unicode.  If so, the
             * warning gets suppressed.  This is true even if just a single
             * such code point is specified, as though not strictly correct if
             * another such code point is matched against, the fact that they
             * are using above-Unicode code points indicates they should know
             * the issues involved */
            if (warn_super) {
                bool non_prop_matches_above_Unicode =
                            runtime_posix_matches_above_Unicode
                            | (invlist_highest(cp_list) > PERL_UNICODE_MAX);
                if (invert) {
                    non_prop_matches_above_Unicode =
                                            !  non_prop_matches_above_Unicode;
                }
                warn_super = ! non_prop_matches_above_Unicode;
            }
d11156 40
a11195 5
            _invlist_union(properties, cp_list, &cp_list);
            SvREFCNT_dec_NN(properties);
        }
        else {
            cp_list = properties;
d11198 1
a11198 3
        if (warn_super) {
            OP(ret) = ANYOF_WARN_SUPER;
        }
a11200 8
    /* Here, we have calculated what code points should be in the character
     * class.
     *
     * Now we can see about various optimizations.  Fold calculation (which we
     * did above) needs to take place before inversion.  Otherwise /[^k]/i
     * would invert to include K, which under /i would match k, which it
     * shouldn't.  Therefore we can't invert folded locale now, as it won't be
     * folded until runtime */
a11201 10
    /* Optimize inverted simple patterns (e.g. [^a-z]) when everything is known
     * at compile time.  Besides not inverting folded locale now, we can't
     * invert if there are things such as \w, which aren't known until runtime
     * */
    if (invert
        && ! (LOC && (FOLD || (ANYOF_FLAGS(ret) & ANYOF_CLASS)))
	&& ! depends_list
	&& ! HAS_NONLOCALE_RUNTIME_PROPERTY_DEFINITION)
    {
        _invlist_invert(cp_list);
d11203 3
a11205 5
        /* Any swash can't be used as-is, because we've inverted things */
        if (swash) {
            SvREFCNT_dec_NN(swash);
            swash = NULL;
        }
d11207 4
a11210 3
	/* Clear the invert flag since have just done it here */
	invert = FALSE;
    }
d11212 1
a11212 3
    if (ret_invlist) {
        *ret_invlist = cp_list;
        SvREFCNT_dec(swash);
d11214 35
a11248 9
        /* Discard the generated node */
        if (SIZE_ONLY) {
            RExC_size = orig_size;
        }
        else {
            RExC_emit = orig_emit;
        }
        return orig_emit;
    }
d11250 5
a11254 8
    /* If we didn't do folding, it's because some information isn't available
     * until runtime; set the run-time fold flag for these.  (We don't have to
     * worry about properties folding, as that is taken care of by the swash
     * fetching) */
    if (FOLD && LOC)
    {
       ANYOF_FLAGS(ret) |= ANYOF_LOC_FOLD;
    }
d11256 4
a11259 24
    /* Some character classes are equivalent to other nodes.  Such nodes take
     * up less room and generally fewer operations to execute than ANYOF nodes.
     * Above, we checked for and optimized into some such equivalents for
     * certain common classes that are easy to test.  Getting to this point in
     * the code means that the class didn't get optimized there.  Since this
     * code is only executed in Pass 2, it is too late to save space--it has
     * been allocated in Pass 1, and currently isn't given back.  But turning
     * things into an EXACTish node can allow the optimizer to join it to any
     * adjacent such nodes.  And if the class is equivalent to things like /./,
     * expensive run-time swashes can be avoided.  Now that we have more
     * complete information, we can find things necessarily missed by the
     * earlier code.  I (khw) am not sure how much to look for here.  It would
     * be easy, but perhaps too slow, to check any candidates against all the
     * node types they could possibly match using _invlistEQ(). */

    if (cp_list
        && ! invert
        && ! depends_list
        && ! (ANYOF_FLAGS(ret) & ANYOF_CLASS)
        && ! HAS_NONLOCALE_RUNTIME_PROPERTY_DEFINITION)
    {
        UV start, end;
        U8 op = END;  /* The optimzation node-type */
        const char * cur_parse= RExC_parse;
d11261 2
a11262 2
        invlist_iterinit(cp_list);
        if (! invlist_iternext(cp_list, &start, &end)) {
d11264 5
a11268 16
            /* Here, the list is empty.  This happens, for example, when a
             * Unicode property is the only thing in the character class, and
             * it doesn't match anything.  (perluniprops.pod notes such
             * properties) */
            op = OPFAIL;
            *flagp |= HASWIDTH|SIMPLE;
        }
        else if (start == end) {    /* The range is a single code point */
            if (! invlist_iternext(cp_list, &start, &end)

                    /* Don't do this optimization if it would require changing
                     * the pattern to UTF-8 */
                && (start < 256 || UTF))
            {
                /* Here, the list contains a single code point.  Can optimize
                 * into an EXACT node */
d11270 1
a11270 1
                value = start;
d11272 40
a11311 4
                if (! FOLD) {
                    op = EXACT;
                }
                else if (LOC) {
d11313 3
a11315 6
                    /* A locale node under folding with one code point can be
                     * an EXACTFL, as its fold won't be calculated until
                     * runtime */
                    op = EXACTFL;
                }
                else {
d11317 33
a11349 24
                    /* Here, we are generally folding, but there is only one
                     * code point to match.  If we have to, we use an EXACT
                     * node, but it would be better for joining with adjacent
                     * nodes in the optimization pass if we used the same
                     * EXACTFish node that any such are likely to be.  We can
                     * do this iff the code point doesn't participate in any
                     * folds.  For example, an EXACTF of a colon is the same as
                     * an EXACT one, since nothing folds to or from a colon. */
                    if (value < 256) {
                        if (IS_IN_SOME_FOLD_L1(value)) {
                            op = EXACT;
                        }
                    }
                    else {
                        if (! PL_utf8_foldable) {
                            SV* swash = swash_init("utf8", "_Perl_Any_Folds",
                                                &PL_sv_undef, 1, 0);
                            PL_utf8_foldable = _get_swash_invlist(swash);
                            SvREFCNT_dec_NN(swash);
                        }
                        if (_invlist_contains_cp(PL_utf8_foldable, value)) {
                            op = EXACT;
                        }
                    }
d11351 9
a11359 24
                    /* If we haven't found the node type, above, it means we
                     * can use the prevailing one */
                    if (op == END) {
                        op = compute_EXACTish(pRExC_state);
                    }
                }
            }
        }
        else if (start == 0) {
            if (end == UV_MAX) {
                op = SANY;
                *flagp |= HASWIDTH|SIMPLE;
                RExC_naughty++;
            }
            else if (end == '\n' - 1
                    && invlist_iternext(cp_list, &start, &end)
                    && start == '\n' + 1 && end == UV_MAX)
            {
                op = REG_ANY;
                *flagp |= HASWIDTH|SIMPLE;
                RExC_naughty++;
            }
        }
        invlist_iterfinish(cp_list);
d11361 22
a11382 3
        if (op != END) {
            RExC_parse = (char *)orig_parse;
            RExC_emit = (regnode *)orig_emit;
d11384 10
a11393 1
            ret = reg_node(pRExC_state, op);
d11395 11
a11405 9
            RExC_parse = (char *)cur_parse;

            if (PL_regkind[op] == EXACT) {
                alloc_maybe_populate_EXACT(pRExC_state, ret, flagp, 0, value);
            }

            SvREFCNT_dec_NN(cp_list);
            return ret;
        }
d11408 2
a11409 2
    /* Here, <cp_list> contains all the code points we can determine at
     * compile time that match under all conditions.  Go through it, and
d11411 6
a11416 4
     * <cp_list>.  While we are at it, see if everything above 255 is in the
     * list, and if so, set a flag to speed up execution */
    ANYOF_BITMAP_ZERO(ret);
    if (cp_list) {
d11423 3
a11425 3
	/* Start looking through <cp_list> */
	invlist_iterinit(cp_list);
	while (invlist_iternext(cp_list, &start, &end)) {
a11428 4
            if (end == UV_MAX && start <= 256) {
                ANYOF_FLAGS(ret) |= ANYOF_UNICODE_ALL;
            }

d11430 1
a11430 1
	    if (start > 255) {
d11437 1
a11437 1
	    high = (end < 255) ? end : 255;
d11441 1
a11446 1
	invlist_iterfinish(cp_list);
d11449 1
a11449 1
         * <cp_list> */
d11451 5
a11455 1
	    _invlist_subtract(cp_list, PL_Latin1, &cp_list);
d11459 118
a11576 3
	if (_invlist_len(cp_list) == 0) {
	    SvREFCNT_dec_NN(cp_list);
	    cp_list = NULL;
d11578 5
d11585 12
a11596 2
    if (invert) {
        ANYOF_FLAGS(ret) |= ANYOF_INVERT;
d11599 85
a11683 7
    /* Here, the bitmap has been populated with all the Latin1 code points that
     * always match.  Can now add to the overall list those that match only
     * when the target string is UTF-8 (<depends_list>). */
    if (depends_list) {
	if (cp_list) {
	    _invlist_union(cp_list, depends_list, &cp_list);
	    SvREFCNT_dec_NN(depends_list);
d11686 3
a11688 1
	    cp_list = depends_list;
d11690 2
d11697 1
a11697 1
	SvREFCNT_dec_NN(swash);
d11700 3
a11702 3

    if (! cp_list
	&& ! HAS_NONLOCALE_RUNTIME_PROPERTY_DEFINITION)
d11705 2
d11715 6
a11720 4
	 * av[2] stores the cp_list inversion list for use in addition or
	 *       instead of av[0]; used only if av[1] is NULL
	 * av[3] is set if any component of the class is from a user-defined
	 *       property; used only if av[1] is NULL */
d11724 3
a11726 2
	av_store(av, 0, (HAS_NONLOCALE_RUNTIME_PROPERTY_DEFINITION)
			? SvREFCNT_inc(listsv) : &PL_sv_undef);
d11729 1
a11729 1
	    SvREFCNT_dec_NN(cp_list);
d11733 3
a11735 3
	    if (cp_list) {
		av_store(av, 2, cp_list);
		av_store(av, 3, newSVuv(has_user_defined_property));
d11739 11
a11754 2

    *flagp |= HASWIDTH|SIMPLE;
a11756 1
#undef HAS_NONLOCALE_RUNTIME_PROPERTY_DEFINITION
d11847 1
a11847 1
    regnode *ptr;
d11889 1
a11889 1
    regnode *ptr;
d11961 3
a11963 3
    regnode *src;
    regnode *dst;
    regnode *place;
d12049 1
a12049 1
    regnode *scan;
d12108 1
a12108 1
    regnode *scan;
d12349 1
a12349 47
    int k;

    /* Should be synchronized with * ANYOF_ #xdefines in regcomp.h */
    static const char * const anyofs[] = {
#if _CC_WORDCHAR != 0 || _CC_DIGIT != 1 || _CC_ALPHA != 2 || _CC_LOWER != 3 \
    || _CC_UPPER != 4 || _CC_PUNCT != 5 || _CC_PRINT != 6                   \
    || _CC_ALPHANUMERIC != 7 || _CC_GRAPH != 8 || _CC_CASED != 9            \
    || _CC_SPACE != 10 || _CC_BLANK != 11 || _CC_XDIGIT != 12               \
    || _CC_PSXSPC != 13 || _CC_CNTRL != 14 || _CC_ASCII != 15               \
    || _CC_VERTSPACE != 16
  #error Need to adjust order of anyofs[]
#endif
        "[\\w]",
        "[\\W]",
        "[\\d]",
        "[\\D]",
        "[:alpha:]",
        "[:^alpha:]",
        "[:lower:]",
        "[:^lower:]",
        "[:upper:]",
        "[:^upper:]",
        "[:punct:]",
        "[:^punct:]",
        "[:print:]",
        "[:^print:]",
        "[:alnum:]",
        "[:^alnum:]",
        "[:graph:]",
        "[:^graph:]",
        "[:cased:]",
        "[:^cased:]",
        "[\\s]",
        "[\\S]",
        "[:blank:]",
        "[:^blank:]",
        "[:xdigit:]",
        "[:^xdigit:]",
        "[:space:]",
        "[:^space:]",
        "[:cntrl:]",
        "[:^cntrl:]",
        "[:ascii:]",
        "[:^ascii:]",
        "[\\v]",
        "[\\V]"
    };
d12470 33
d12506 1
a12506 1
	if (flags & ANYOF_LOC_FOLD)
d12556 1
a12556 1
	    SV * const sw = regclass_swash(prog, o, FALSE, &lv, NULL);
d12634 1
a12634 1
		SvREFCNT_dec_NN(lv);
a12639 9
    else if (k == POSIXD || k == NPOSIXD) {
        U8 index = FLAGS(o) * 2;
        if (index > (sizeof(anyofs) / sizeof(anyofs[0]))) {
            Perl_sv_catpvf(aTHX_ sv, "[illegal type=%d])", index);
        }
        else {
            sv_catpv(sv, anyofs[index]);
        }
    }
d12654 1
a12654 1
    struct regexp *const prog = ReANY(r);
d12702 1
a12702 1
    struct regexp *const r = ReANY(rx);
a12711 1
	Safefree(r->xpv_len_u.xpvlenu_pv);
d12721 1
a12721 1
#ifdef PERL_ANY_COW
a12724 2
    SvREFCNT_dec(r->qr_anoncv);
    rx->sv_u.svu_rx = 0;
d12748 2
a12749 2
    struct regexp *const r = ReANY(rx);
    const bool islv = ret_x && SvTYPE(ret_x) == SVt_PVLV;
d12755 1
a12755 21
    else {
	SvOK_off((SV *)ret_x);
	if (islv) {
	    /* For PVLVs, SvANY points to the xpvlv body while sv_u points
	       to the regexp.  (For SVt_REGEXPs, sv_upgrade has already
	       made both spots point to the same regexp body.) */
	    REGEXP *temp = (REGEXP *)newSV_type(SVt_REGEXP);
	    assert(!SvPVX(ret_x));
	    ret_x->sv_u.svu_rx = temp->sv_any;
	    temp->sv_any = NULL;
	    SvFLAGS(temp) = (SvFLAGS(temp) & ~SVTYPEMASK) | SVt_NULL;
	    SvREFCNT_dec_NN(temp);
	    /* SvCUR still resides in the xpvlv struct, so the regexp copy-
	       ing below will not set it. */
	    SvCUR_set(ret_x, SvCUR(rx));
	}
    }
    /* This ensures that SvTHINKFIRST(sv) is true, and hence that
       sv_force_normal(sv) is called.  */
    SvFAKE_on(ret_x);
    ret = ReANY(ret_x);
d12757 7
a12763 5
    SvFLAGS(ret_x) |= SvUTF8(rx);
    /* We share the same string buffer as the original regexp, on which we
       hold a reference count, incremented when mother_re is set below.
       The string pointer is copied here, being part of the regexp struct.
     */
d12766 5
a12770 5
    if (r->offs) {
        const I32 npar = r->nparens+1;
        Newx(ret->offs, npar, regexp_paren_pair);
        Copy(r->offs, ret->offs, npar, regexp_paren_pair);
    }
d12784 1
a12784 1
#ifdef PERL_ANY_COW
d12787 1
a12787 2
    ret->mother_re = ReREFCNT_inc(r->mother_re ? r->mother_re : rx);
    SvREFCNT_inc_void(ret->qr_anoncv);
d12809 1
a12809 1
    struct regexp *const r = ReANY(rx);
a12829 7
    if (ri->code_blocks) {
	int n;
	for (n = 0; n < ri->num_code_blocks; n++)
	    SvREFCNT_dec(ri->code_blocks[n].src_regex);
	Safefree(ri->code_blocks);
    }

d12832 3
a12839 1
	    case 'r':
d12848 21
a12868 2
	    case 'l':
	    case 'L':
d12944 2
a12945 2
    const struct regexp *r = ReANY(sstr);
    struct regexp *ret = ReANY(dstr);
d12952 4
a12995 1
    ret->qr_anoncv = MUTABLE_CV(sv_dup_inc((const SV *)ret->qr_anoncv, param));
d13004 1
a13004 1
#ifdef PERL_ANY_COW
d13008 3
a13010 3
    /* Whether mother_re be set or no, we need to copy the string.  We
       cannot refrain from copying it when the storage points directly to
       our mother regexp, because that's
d13014 9
a13022 2
    RX_WRAPPED(dstr) = SAVEPVN(RX_WRAPPED(sstr), SvCUR(sstr)+1);
    ret->mother_re   = NULL;
d13045 1
a13045 1
    struct regexp *const r = ReANY(rx);
d13056 1
a13056 14

    reti->num_code_blocks = ri->num_code_blocks;
    if (ri->code_blocks) {
	int n;
	Newxc(reti->code_blocks, ri->num_code_blocks, struct reg_code_block,
		struct reg_code_block);
	Copy(ri->code_blocks, reti->code_blocks, ri->num_code_blocks,
		struct reg_code_block);
	for (n = 0; n < ri->num_code_blocks; n++)
	     reti->code_blocks[n].src_regex = (REGEXP*)
		    sv_dup_inc((SV*)(ri->code_blocks[n].src_regex), param);
    }
    else
	reti->code_blocks = NULL;
d13073 2
a13074 1
	        /* see also regcomp.h and regfree_internal() */
a13075 1
	    case 'r':
d13078 1
d13089 7
d13108 1
a13108 2
	    case 'l':
	    case 'L':
d13143 1
a13143 1
Perl_regnext(pTHX_ regnode *p)
d13146 1
a13146 1
    I32 offset;
d13218 2
a13221 2
    PL_reg_oldsavedoffset = 0;
    PL_reg_oldsavedcoffset = 0;
d13226 1
a13226 1
#ifdef PERL_ANY_COW
d13252 7
d13274 2
a13275 5
       identical, to the ASCII delete (DEL) or rubout control character. ...
       it is typically mapped to hexadecimal code 9F, in order to provide a
       unique character mapping in both directions)

       So the old condition can be simplified to !isPRINT(c)  */
d13307 2
a13308 2
    U8 op = PSEUDO;	/* Arbitrary non-END op. */
    const regnode *next;
d13359 3
a13361 3
                const regnode *nnode = (OP(next) == LONGJMP
                                       ? regnext((regnode *)next)
                                       : next);
d13461 1
a13461 1
 * indent-tabs-mode: nil
d13464 1
a13464 1
 * ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.15
log
@Import perl-5.20.1
@
text
@d84 1
a84 1
EXTERN_C const struct regexp_engine my_reg_engine;
d94 1
a94 2
#define HAS_NONLATIN1_FOLD_CLOSURE(i) \
 _HAS_NONLATIN1_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(i)
d98 13
d116 1
a116 1
struct RExC_state_t {
d122 1
a122 2
    regexp_internal	*rxi;           /* internal data for regexp object
                                           pprivate field */
d126 1
a126 1
    SSize_t	whilem_seen;		/* number of WHILEM in this expr */
d128 2
a129 8
    regnode	*emit_bound;		/* First regnode outside of the
                                           allocated space */
    regnode	*emit;			/* Code-emit pointer; if = &emit_dummy,
                                           implies compiling, so don't emit */
    regnode_ssc	emit_dummy;		/* placeholder for emit to point to;
                                           large enough for the largest
                                           non-EXACTish node, so can use it as
                                           scratch in pass1 */
d133 4
a136 6
    SSize_t	size;			/* Code size. */
    I32                npar;            /* Capture buffer count, (OPEN) plus
                                           one. ("par" 0 is the whole
                                           pattern)*/
    I32		nestroot;		/* root parens we are in - used by
                                           accept */
d150 1
a150 1

a152 3
    U8          *study_chunk_recursed;  /* bitmap of which parens we have moved
                                           through */
    U32         study_chunk_recursed_bytes;  /* bytes in bitmap */
a154 1
    I32		contains_i;
d161 1
a161 2
    SSize_t     maxlen;                        /* mininum possible number of chars in string to match */
#ifdef ADD_TO_REGEXEC
d174 1
a174 1
};
d187 1
a187 2
#define RExC_offsets	(pRExC_state->rxi->u.offsets) /* I am not like the
                                                         others */
a189 1
#define RExC_emit_dummy	(pRExC_state->emit_dummy)
a195 1
#define RExC_maxlen        (pRExC_state->maxlen)
a208 3
#define RExC_study_chunk_recursed        (pRExC_state->study_chunk_recursed)
#define RExC_study_chunk_recursed_bytes  \
                                   (pRExC_state->study_chunk_recursed_bytes)
a210 1
#define RExC_contains_i (pRExC_state->contains_i)
d219 3
a266 5
#define _invlist_union_complement_2nd(a, b, output) \
                        _invlist_union_maybe_complement_2nd(a, b, TRUE, output)
#define _invlist_intersection_complement_2nd(a, b, output) \
                 _invlist_intersection_maybe_complement_2nd(a, b, TRUE, output)

d272 1
a272 1
  what strings MUST appear in the pattern. We look for the longest
d276 1
a276 1

d278 1
a278 1

d282 1
a282 1

d284 1
a284 1

d286 1
a286 1

d288 1
a288 1

d290 1
a290 1

d296 1
a296 1
    tells us how many characters must appear after the string we have
d298 1
a298 1

d301 1
a301 1
    the string can appear at. If set to SSize_t_MAX it indicates that the
d303 1
a303 1

d307 1
a307 1
    lookahead or positive lookbehind we can have multiple patterns
d309 1
a309 1

d311 1
a311 1

d314 1
a314 1
    will actually match is 1. So 'FOO's minimum length is 3, but the
d316 1
a316 1
    is used to determine offsets in front of and behind the string being
d320 1
a320 1
    are not known until the full pattern has been compiled, thus the
d322 1
a322 1

d324 1
a324 1

d326 1
a326 1
    offset past the start point of the final matching string.
d330 1
a330 1
    the length of the string being searched for).
d333 2
a334 2
    about lookbehind is factored in, with the information that would
    have been lost precalculated in the end_shift field for the
d338 1
a338 1
  and the delta to the maximum offset at the current point in the pattern.
d345 2
a346 2
    SSize_t pos_min;
    SSize_t pos_delta;
d348 3
a350 3
    SSize_t last_end;	    /* min value, <0 unless valid. */
    SSize_t last_start_min;
    SSize_t last_start_max;
d353 2
a354 2
    SSize_t offset_fixed;   /* offset where it starts */
    SSize_t *minlen_fixed;  /* pointer to the minlen relevant to the string */
d357 4
a360 4
    SSize_t offset_float_min; /* earliest point in string it can appear */
    SSize_t offset_float_max; /* latest point in string it can appear */
    SSize_t *minlen_float;  /* pointer to the minlen relevant to the string */
    SSize_t lookbehind_float; /* is the pos of the string modified by LB */
d363 2
a364 2
    SSize_t *last_closep;
    regnode_ssc *start_class;
a366 18
/* The below is perhaps overboard, but this allows us to save a test at the
 * expense of a mask.  This is because on both EBCDIC and ASCII machines, 'A'
 * and 'a' differ by a single bit; the same with the upper and lower case of
 * all other ASCII-range alphabetics.  On ASCII platforms, they are 32 apart;
 * on EBCDIC, they are 64.  This uses an exclusive 'or' to find that bit and
 * then inverts it to form a mask, with just a single 0, in the bit position
 * where the upper- and lowercase differ.  XXX There are about 40 other
 * instances in the Perl core where this micro-optimization could be used.
 * Should decide if maintenance cost is worse, before changing those
 *
 * Returns a boolean as to whether or not 'v' is either a lowercase or
 * uppercase instance of 'c', where 'c' is in [A-Za-z].  If 'c' is a
 * compile-time constant, the generated code is better than some optimizing
 * compilers figure out, amounting to a mask and test.  The results are
 * meaningless if 'c' is not one of [A-Za-z] */
#define isARG2_lower_or_UPPER_ARG1(c, v) \
                              (((v) & ~('A' ^ 'a')) ==  ((c) & ~('A' ^ 'a')))

d380 7
a386 2
#define SF_FIX_SHIFT_EOL	(+2)
#define SF_FL_SHIFT_EOL		(+4)
d404 1
a404 2
#define SCF_SEEN_ACCEPT         0x8000
#define SCF_TRIE_DOING_RESTUDY 0x10000
d410 1
a410 2
#define DEPENDS_SEMANTICS (get_regex_charset(RExC_flags)                    \
                                                     == REGEX_DEPENDS_CHARSET)
d412 4
a415 8
#define AT_LEAST_UNI_SEMANTICS (get_regex_charset(RExC_flags)                \
                                                     >= REGEX_UNICODE_CHARSET)
#define ASCII_RESTRICTED (get_regex_charset(RExC_flags)                      \
                                            == REGEX_ASCII_RESTRICTED_CHARSET)
#define AT_LEAST_ASCII_RESTRICTED (get_regex_charset(RExC_flags)             \
                                            >= REGEX_ASCII_RESTRICTED_CHARSET)
#define ASCII_FOLD_RESTRICTED (get_regex_charset(RExC_flags)                 \
                                        == REGEX_ASCII_MORE_RESTRICTED_CHARSET)
a418 5
/* For programs that want to be strictly Unicode compatible by dying if any
 * attempt is made to match a non-Unicode code point against a Unicode
 * property.  */
#define ALWAYS_WARN_SUPER  ckDEAD(packWARN(WARN_NON_UNICODE))

d441 1
a441 6
#define REPORT_LOCATION " in regex; marked by " MARKER1    \
                        " in m/%"UTF8f MARKER2 "%"UTF8f"/"

#define REPORT_LOCATION_ARGS(offset)            \
                UTF8fARG(UTF, offset, RExC_precomp), \
                UTF8fARG(UTF, RExC_end - RExC_precomp - offset, RExC_precomp + offset)
d463 2
a464 2
    Perl_croak(aTHX_ "%s in regex m/%"UTF8f"%s/",	    \
	    msg, UTF8fARG(UTF, len, RExC_precomp), ellipses))
d467 2
a468 2
    Perl_croak(aTHX_ msg " in regex m/%"UTF8f"%s/",	    \
	    arg, UTF8fARG(UTF, len, RExC_precomp), ellipses))
d476 1
a476 1
	    m, REPORT_LOCATION_ARGS(offset));	\
d493 2
a494 2
    S_re_croak2(aTHX_ UTF, m, REPORT_LOCATION, a1,			\
                      REPORT_LOCATION_ARGS(offset));	\
d512 2
a513 2
    S_re_croak2(aTHX_ UTF, m, REPORT_LOCATION, a1, a2,		\
	    REPORT_LOCATION_ARGS(offset));	\
d530 2
a531 2
    S_re_croak2(aTHX_ UTF, m, REPORT_LOCATION, a1, a2, a3,		\
	    REPORT_LOCATION_ARGS(offset));	\
a539 10
/* A specialized version of vFAIL2 that works with UTF8f */
#define vFAIL2utf8f(m, a1) STMT_START { \
    const IV offset = RExC_parse - RExC_precomp;   \
    if (!SIZE_ONLY)                                \
        SAVEFREESV(RExC_rx_sv);                    \
    S_re_croak2(aTHX_ UTF, m, REPORT_LOCATION, a1, \
            REPORT_LOCATION_ARGS(offset));         \
} STMT_END


d544 1
a544 1
            m, REPORT_LOCATION_ARGS(offset));       \
d550 1
a550 1
	    REPORT_LOCATION_ARGS(offset));		\
d556 1
a556 1
	    REPORT_LOCATION_ARGS(offset));	        \
d563 1
a563 1
	    REPORT_LOCATION_ARGS(offset));		\
d570 1
a570 1
	    REPORT_LOCATION_ARGS(offset));		\
d573 1
a573 1
#define	ckWARN2reg_d(loc,m, a1) STMT_START {				\
d575 1
a575 1
    Perl_ck_warner_d(aTHX_ packWARN(WARN_REGEXP),			\
d577 1
a577 1
	    a1, REPORT_LOCATION_ARGS(offset));	\
d583 1
a583 1
	    a1, REPORT_LOCATION_ARGS(offset));	\
d589 1
a589 1
	    a1, a2, REPORT_LOCATION_ARGS(offset));	\
d595 1
a595 1
	    a1, a2, REPORT_LOCATION_ARGS(offset));	\
d601 1
a601 1
	    a1, a2, a3, REPORT_LOCATION_ARGS(offset)); \
d607 1
a607 1
	    a1, a2, a3, REPORT_LOCATION_ARGS(offset)); \
d613 1
a613 1
	    a1, a2, a3, a4, REPORT_LOCATION_ARGS(offset)); \
d622 1
a622 1
/* Macros for recording node offsets.   20001227 mjd@@plover.com
d634 3
a636 3
#define Set_Node_Cur_Length(node,start)
#define Node_Offset(n)
#define Node_Length(n)
d648 1
a648 2
	    Perl_croak(aTHX_ "value of node is %d in Offset macro",     \
                                         (int)(node));                  \
d664 1
a664 2
	    Perl_croak(aTHX_ "value of node is %d in Length macro",     \
                                         (int)(node));                  \
d673 3
a675 2
#define Set_Node_Cur_Length(node, start)                \
    Set_Node_Length(node, RExC_parse - start)
a690 43
#define DEBUG_RExC_seen() \
        DEBUG_OPTIMISE_MORE_r({                                             \
            PerlIO_printf(Perl_debug_log,"RExC_seen: ");                    \
                                                                            \
            if (RExC_seen & REG_ZERO_LEN_SEEN)                              \
                PerlIO_printf(Perl_debug_log,"REG_ZERO_LEN_SEEN ");         \
                                                                            \
            if (RExC_seen & REG_LOOKBEHIND_SEEN)                            \
                PerlIO_printf(Perl_debug_log,"REG_LOOKBEHIND_SEEN ");       \
                                                                            \
            if (RExC_seen & REG_GPOS_SEEN)                                  \
                PerlIO_printf(Perl_debug_log,"REG_GPOS_SEEN ");             \
                                                                            \
            if (RExC_seen & REG_CANY_SEEN)                                  \
                PerlIO_printf(Perl_debug_log,"REG_CANY_SEEN ");             \
                                                                            \
            if (RExC_seen & REG_RECURSE_SEEN)                               \
                PerlIO_printf(Perl_debug_log,"REG_RECURSE_SEEN ");          \
                                                                            \
            if (RExC_seen & REG_TOP_LEVEL_BRANCHES_SEEN)                         \
                PerlIO_printf(Perl_debug_log,"REG_TOP_LEVEL_BRANCHES_SEEN ");    \
                                                                            \
            if (RExC_seen & REG_VERBARG_SEEN)                               \
                PerlIO_printf(Perl_debug_log,"REG_VERBARG_SEEN ");          \
                                                                            \
            if (RExC_seen & REG_CUTGROUP_SEEN)                              \
                PerlIO_printf(Perl_debug_log,"REG_CUTGROUP_SEEN ");         \
                                                                            \
            if (RExC_seen & REG_RUN_ON_COMMENT_SEEN)                        \
                PerlIO_printf(Perl_debug_log,"REG_RUN_ON_COMMENT_SEEN ");   \
                                                                            \
            if (RExC_seen & REG_UNFOLDED_MULTI_SEEN)                        \
                PerlIO_printf(Perl_debug_log,"REG_UNFOLDED_MULTI_SEEN ");   \
                                                                            \
            if (RExC_seen & REG_GOSTART_SEEN)                               \
                PerlIO_printf(Perl_debug_log,"REG_GOSTART_SEEN ");          \
                                                                            \
            if (RExC_seen & REG_UNBOUNDED_QUANTIFIER_SEEN)                               \
                PerlIO_printf(Perl_debug_log,"REG_UNBOUNDED_QUANTIFIER_SEEN ");          \
                                                                            \
            PerlIO_printf(Perl_debug_log,"\n");                             \
        });

d730 1
a730 2
S_scan_commit(pTHX_ const RExC_state_t *pRExC_state, scan_data_t *data,
                    SSize_t *minlenp, int is_inf)
d754 3
a756 6
				      : (data->pos_delta == SSize_t_MAX
					 ? SSize_t_MAX
					 : data->pos_min + data->pos_delta));
	    if (is_inf
		 || (STRLEN)data->offset_float_max > (STRLEN)SSize_t_MAX)
		data->offset_float_max = SSize_t_MAX;
d780 10
a789 60
/* An SSC is just a regnode_charclass_posix with an extra field: the inversion
 * list that describes which code points it matches */

STATIC void
S_ssc_anything(pTHX_ regnode_ssc *ssc)
{
    /* Set the SSC 'ssc' to match an empty string or any code point */

    PERL_ARGS_ASSERT_SSC_ANYTHING;

    assert(is_ANYOF_SYNTHETIC(ssc));

    ssc->invlist = sv_2mortal(_new_invlist(2)); /* mortalize so won't leak */
    _append_range_to_invlist(ssc->invlist, 0, UV_MAX);
    ANYOF_FLAGS(ssc) |= ANYOF_EMPTY_STRING;    /* Plus match empty string */
}

STATIC int
S_ssc_is_anything(pTHX_ const regnode_ssc *ssc)
{
    /* Returns TRUE if the SSC 'ssc' can match the empty string and any code
     * point; FALSE otherwise.  Thus, this is used to see if using 'ssc' buys
     * us anything: if the function returns TRUE, 'ssc' hasn't been restricted
     * in any way, so there's no point in using it */

    UV start, end;
    bool ret;

    PERL_ARGS_ASSERT_SSC_IS_ANYTHING;

    assert(is_ANYOF_SYNTHETIC(ssc));

    if (! (ANYOF_FLAGS(ssc) & ANYOF_EMPTY_STRING)) {
        return FALSE;
    }

    /* See if the list consists solely of the range 0 - Infinity */
    invlist_iterinit(ssc->invlist);
    ret = invlist_iternext(ssc->invlist, &start, &end)
          && start == 0
          && end == UV_MAX;

    invlist_iterfinish(ssc->invlist);

    if (ret) {
        return TRUE;
    }

    /* If e.g., both \w and \W are set, matches everything */
    if (ANYOF_POSIXL_SSC_TEST_ANY_SET(ssc)) {
        int i;
        for (i = 0; i < ANYOF_POSIXL_MAX; i += 2) {
            if (ANYOF_POSIXL_TEST(ssc, i) && ANYOF_POSIXL_TEST(ssc, i+1)) {
                return TRUE;
            }
        }
    }

    return FALSE;
}
d791 1
d793 1
a793 1
S_ssc_init(pTHX_ const RExC_state_t *pRExC_state, regnode_ssc *ssc)
d795 1
a795 2
    /* Initializes the SSC 'ssc'.  This includes setting it to match an empty
     * string, any code point, or any posix class under locale */
d797 3
a799 6
    PERL_ARGS_ASSERT_SSC_INIT;

    Zero(ssc, 1, regnode_ssc);
    set_ANYOF_SYNTHETIC(ssc);
    ARG_SET(ssc, ANYOF_NONBITMAP_EMPTY);
    ssc_anything(ssc);
d805 1
a805 1
     * optimizer, and that there are inadequate test cases for locale, many
d809 2
a810 1
	ANYOF_POSIXL_SETALL(ssc);
d813 1
a813 1
	ANYOF_POSIXL_ZERO(ssc);
d817 1
d819 1
a819 2
S_ssc_is_cp_posixl_init(pTHX_ const RExC_state_t *pRExC_state,
                              const regnode_ssc *ssc)
d821 1
a821 3
    /* Returns TRUE if the SSC 'ssc' is in its initial state with regard only
     * to the list of code points matched, and locale posix classes; hence does
     * not check its flags) */
d823 1
a823 2
    UV start, end;
    bool ret;
d825 8
a832 20
    PERL_ARGS_ASSERT_SSC_IS_CP_POSIXL_INIT;

    assert(is_ANYOF_SYNTHETIC(ssc));

    invlist_iterinit(ssc->invlist);
    ret = invlist_iternext(ssc->invlist, &start, &end)
          && start == 0
          && end == UV_MAX;

    invlist_iterfinish(ssc->invlist);

    if (! ret) {
        return FALSE;
    }

    if (RExC_contains_locale && ! ANYOF_POSIXL_SSC_TEST_ALL_SET(ssc)) {
        return FALSE;
    }

    return TRUE;
d835 3
a837 3
STATIC SV*
S_get_ANYOF_cp_list_for_ssc(pTHX_ const RExC_state_t *pRExC_state,
                               const regnode_charclass* const node)
d839 1
a839 98
    /* Returns a mortal inversion list defining which code points are matched
     * by 'node', which is of type ANYOF.  Handles complementing the result if
     * appropriate.  If some code points aren't knowable at this time, the
     * returned list must, and will, contain every code point that is a
     * possibility. */

    SV* invlist = sv_2mortal(_new_invlist(0));
    SV* only_utf8_locale_invlist = NULL;
    unsigned int i;
    const U32 n = ARG(node);
    bool new_node_has_latin1 = FALSE;

    PERL_ARGS_ASSERT_GET_ANYOF_CP_LIST_FOR_SSC;

    /* Look at the data structure created by S_set_ANYOF_arg() */
    if (n != ANYOF_NONBITMAP_EMPTY) {
        SV * const rv = MUTABLE_SV(RExC_rxi->data->data[n]);
        AV * const av = MUTABLE_AV(SvRV(rv));
        SV **const ary = AvARRAY(av);
        assert(RExC_rxi->data->what[n] == 's');

        if (ary[1] && ary[1] != &PL_sv_undef) { /* Has compile-time swash */
            invlist = sv_2mortal(invlist_clone(_get_swash_invlist(ary[1])));
        }
        else if (ary[0] && ary[0] != &PL_sv_undef) {

            /* Here, no compile-time swash, and there are things that won't be
             * known until runtime -- we have to assume it could be anything */
            return _add_range_to_invlist(invlist, 0, UV_MAX);
        }
        else if (ary[3] && ary[3] != &PL_sv_undef) {

            /* Here no compile-time swash, and no run-time only data.  Use the
             * node's inversion list */
            invlist = sv_2mortal(invlist_clone(ary[3]));
        }

        /* Get the code points valid only under UTF-8 locales */
        if ((ANYOF_FLAGS(node) & ANYOF_LOC_FOLD)
            && ary[2] && ary[2] != &PL_sv_undef)
        {
            only_utf8_locale_invlist = ary[2];
        }
    }

    /* An ANYOF node contains a bitmap for the first 256 code points, and an
     * inversion list for the others, but if there are code points that should
     * match only conditionally on the target string being UTF-8, those are
     * placed in the inversion list, and not the bitmap.  Since there are
     * circumstances under which they could match, they are included in the
     * SSC.  But if the ANYOF node is to be inverted, we have to exclude them
     * here, so that when we invert below, the end result actually does include
     * them.  (Think about "\xe0" =~ /[^\xc0]/di;).  We have to do this here
     * before we add the unconditionally matched code points */
    if (ANYOF_FLAGS(node) & ANYOF_INVERT) {
        _invlist_intersection_complement_2nd(invlist,
                                             PL_UpperLatin1,
                                             &invlist);
    }

    /* Add in the points from the bit map */
    for (i = 0; i < 256; i++) {
        if (ANYOF_BITMAP_TEST(node, i)) {
            invlist = add_cp_to_invlist(invlist, i);
            new_node_has_latin1 = TRUE;
        }
    }

    /* If this can match all upper Latin1 code points, have to add them
     * as well */
    if (ANYOF_FLAGS(node) & ANYOF_NON_UTF8_NON_ASCII_ALL) {
        _invlist_union(invlist, PL_UpperLatin1, &invlist);
    }

    /* Similarly for these */
    if (ANYOF_FLAGS(node) & ANYOF_ABOVE_LATIN1_ALL) {
        invlist = _add_range_to_invlist(invlist, 256, UV_MAX);
    }

    if (ANYOF_FLAGS(node) & ANYOF_INVERT) {
        _invlist_invert(invlist);
    }
    else if (new_node_has_latin1 && ANYOF_FLAGS(node) & ANYOF_LOC_FOLD) {

        /* Under /li, any 0-255 could fold to any other 0-255, depending on the
         * locale.  We can skip this if there are no 0-255 at all. */
        _invlist_union(invlist, PL_Latin1, &invlist);
    }

    /* Similarly add the UTF-8 locale possible matches.  These have to be
     * deferred until after the non-UTF-8 locale ones are taken care of just
     * above, or it leads to wrong results under ANYOF_INVERT */
    if (only_utf8_locale_invlist) {
        _invlist_union_maybe_complement_2nd(invlist,
                                            only_utf8_locale_invlist,
                                            ANYOF_FLAGS(node) & ANYOF_INVERT,
                                            &invlist);
    }
d841 4
a844 1
    return invlist;
d848 1
a848 8
#define ssc_init_zero		ssc_init

#define ssc_add_cp(ssc, cp)   ssc_add_range((ssc), (cp), (cp))
#define ssc_match_all_cp(ssc) ssc_add_range(ssc, 0, UV_MAX)

/* 'AND' a given class with another one.  Can create false positives.  'ssc'
 * should not be inverted.  'and_with->flags & ANYOF_POSIXL' should be 0 if
 * 'and_with' is a regnode_charclass instead of a regnode_ssc. */
d850 3
d854 2
a855 2
S_ssc_and(pTHX_ const RExC_state_t *pRExC_state, regnode_ssc *ssc,
                const regnode_charclass *and_with)
d857 1
a857 2
    /* Accumulate into SSC 'ssc' its 'AND' with 'and_with', which is either
     * another SSC or a regular ANYOF class.  Can create false positives. */
d859 1
a859 2
    SV* anded_cp_list;
    U8  anded_flags;
d861 7
a867 33
    PERL_ARGS_ASSERT_SSC_AND;

    assert(is_ANYOF_SYNTHETIC(ssc));

    /* 'and_with' is used as-is if it too is an SSC; otherwise have to extract
     * the code point inversion list and just the relevant flags */
    if (is_ANYOF_SYNTHETIC(and_with)) {
        anded_cp_list = ((regnode_ssc *)and_with)->invlist;
        anded_flags = ANYOF_FLAGS(and_with);

        /* XXX This is a kludge around what appears to be deficiencies in the
         * optimizer.  If we make S_ssc_anything() add in the WARN_SUPER flag,
         * there are paths through the optimizer where it doesn't get weeded
         * out when it should.  And if we don't make some extra provision for
         * it like the code just below, it doesn't get added when it should.
         * This solution is to add it only when AND'ing, which is here, and
         * only when what is being AND'ed is the pristine, original node
         * matching anything.  Thus it is like adding it to ssc_anything() but
         * only when the result is to be AND'ed.  Probably the same solution
         * could be adopted for the same problem we have with /l matching,
         * which is solved differently in S_ssc_init(), and that would lead to
         * fewer false positives than that solution has.  But if this solution
         * creates bugs, the consequences are only that a warning isn't raised
         * that should be; while the consequences for having /l bugs is
         * incorrect matches */
        if (ssc_is_anything((regnode_ssc *)and_with)) {
            anded_flags |= ANYOF_WARN_SUPER;
        }
    }
    else {
        anded_cp_list = get_ANYOF_cp_list_for_ssc(pRExC_state, and_with);
        anded_flags = ANYOF_FLAGS(and_with) & ANYOF_COMMON_FLAGS;
    }
d869 60
a928 1
    ANYOF_FLAGS(ssc) &= anded_flags;
d930 11
a940 30
    /* Below, C1 is the list of code points in 'ssc'; P1, its posix classes.
     * C2 is the list of code points in 'and-with'; P2, its posix classes.
     * 'and_with' may be inverted.  When not inverted, we have the situation of
     * computing:
     *  (C1 | P1) & (C2 | P2)
     *                     =  (C1 & (C2 | P2)) | (P1 & (C2 | P2))
     *                     =  ((C1 & C2) | (C1 & P2)) | ((P1 & C2) | (P1 & P2))
     *                    <=  ((C1 & C2) |       P2)) | ( P1       | (P1 & P2))
     *                    <=  ((C1 & C2) | P1 | P2)
     * Alternatively, the last few steps could be:
     *                     =  ((C1 & C2) | (C1 & P2)) | ((P1 & C2) | (P1 & P2))
     *                    <=  ((C1 & C2) |  C1      ) | (      C2  | (P1 & P2))
     *                    <=  (C1 | C2 | (P1 & P2))
     * We favor the second approach if either P1 or P2 is non-empty.  This is
     * because these components are a barrier to doing optimizations, as what
     * they match cannot be known until the moment of matching as they are
     * dependent on the current locale, 'AND"ing them likely will reduce or
     * eliminate them.
     * But we can do better if we know that C1,P1 are in their initial state (a
     * frequent occurrence), each matching everything:
     *  (<everything>) & (C2 | P2) =  C2 | P2
     * Similarly, if C2,P2 are in their initial state (again a frequent
     * occurrence), the result is a no-op
     *  (C1 | P1) & (<everything>) =  C1 | P1
     *
     * Inverted, we have
     *  (C1 | P1) & ~(C2 | P2)  =  (C1 | P1) & (~C2 & ~P2)
     *                          =  (C1 & (~C2 & ~P2)) | (P1 & (~C2 & ~P2))
     *                         <=  (C1 & ~C2) | (P1 & ~P2)
     * */
a941 4
    if ((ANYOF_FLAGS(and_with) & ANYOF_INVERT)
        && ! is_ANYOF_SYNTHETIC(and_with))
    {
        unsigned int i;
d943 27
a969 83
        ssc_intersection(ssc,
                         anded_cp_list,
                         FALSE /* Has already been inverted */
                         );

        /* If either P1 or P2 is empty, the intersection will be also; can skip
         * the loop */
        if (! (ANYOF_FLAGS(and_with) & ANYOF_POSIXL)) {
            ANYOF_POSIXL_ZERO(ssc);
        }
        else if (ANYOF_POSIXL_SSC_TEST_ANY_SET(ssc)) {

            /* Note that the Posix class component P from 'and_with' actually
             * looks like:
             *      P = Pa | Pb | ... | Pn
             * where each component is one posix class, such as in [\w\s].
             * Thus
             *      ~P = ~(Pa | Pb | ... | Pn)
             *         = ~Pa & ~Pb & ... & ~Pn
             *        <= ~Pa | ~Pb | ... | ~Pn
             * The last is something we can easily calculate, but unfortunately
             * is likely to have many false positives.  We could do better
             * in some (but certainly not all) instances if two classes in
             * P have known relationships.  For example
             *      :lower: <= :alpha: <= :alnum: <= \w <= :graph: <= :print:
             * So
             *      :lower: & :print: = :lower:
             * And similarly for classes that must be disjoint.  For example,
             * since \s and \w can have no elements in common based on rules in
             * the POSIX standard,
             *      \w & ^\S = nothing
             * Unfortunately, some vendor locales do not meet the Posix
             * standard, in particular almost everything by Microsoft.
             * The loop below just changes e.g., \w into \W and vice versa */

            regnode_charclass_posixl temp;
            int add = 1;    /* To calculate the index of the complement */

            ANYOF_POSIXL_ZERO(&temp);
            for (i = 0; i < ANYOF_MAX; i++) {
                assert(i % 2 != 0
                       || ! ANYOF_POSIXL_TEST((regnode_charclass_posixl*) and_with, i)
                       || ! ANYOF_POSIXL_TEST((regnode_charclass_posixl*) and_with, i + 1));

                if (ANYOF_POSIXL_TEST((regnode_charclass_posixl*) and_with, i)) {
                    ANYOF_POSIXL_SET(&temp, i + add);
                }
                add = 0 - add; /* 1 goes to -1; -1 goes to 1 */
            }
            ANYOF_POSIXL_AND(&temp, ssc);

        } /* else ssc already has no posixes */
    } /* else: Not inverted.  This routine is a no-op if 'and_with' is an SSC
         in its initial state */
    else if (! is_ANYOF_SYNTHETIC(and_with)
             || ! ssc_is_cp_posixl_init(pRExC_state, (regnode_ssc *)and_with))
    {
        /* But if 'ssc' is in its initial state, the result is just 'and_with';
         * copy it over 'ssc' */
        if (ssc_is_cp_posixl_init(pRExC_state, ssc)) {
            if (is_ANYOF_SYNTHETIC(and_with)) {
                StructCopy(and_with, ssc, regnode_ssc);
            }
            else {
                ssc->invlist = anded_cp_list;
                ANYOF_POSIXL_ZERO(ssc);
                if (ANYOF_FLAGS(and_with) & ANYOF_POSIXL) {
                    ANYOF_POSIXL_OR((regnode_charclass_posixl*) and_with, ssc);
                }
            }
        }
        else if (ANYOF_POSIXL_SSC_TEST_ANY_SET(ssc)
                 || (ANYOF_FLAGS(and_with) & ANYOF_POSIXL))
        {
            /* One or the other of P1, P2 is non-empty. */
            if (ANYOF_FLAGS(and_with) & ANYOF_POSIXL) {
                ANYOF_POSIXL_AND((regnode_charclass_posixl*) and_with, ssc);
            }
            ssc_union(ssc, anded_cp_list, FALSE);
        }
        else { /* P1 = P2 = empty */
            ssc_intersection(ssc, anded_cp_list, FALSE);
        }
d973 3
d977 1
a977 2
S_ssc_or(pTHX_ const RExC_state_t *pRExC_state, regnode_ssc *ssc,
               const regnode_charclass *or_with)
d979 1
a979 3
    /* Accumulate into SSC 'ssc' its 'OR' with 'or_with', which is either
     * another SSC or a regular ANYOF class.  Can create false positives if
     * 'or_with' is to be inverted. */
d981 1
a981 2
    SV* ored_cp_list;
    U8 ored_flags;
d983 19
a1001 1
    PERL_ARGS_ASSERT_SSC_OR;
d1003 6
a1008 1
    assert(is_ANYOF_SYNTHETIC(ssc));
d1010 19
a1028 30
    /* 'or_with' is used as-is if it too is an SSC; otherwise have to extract
     * the code point inversion list and just the relevant flags */
    if (is_ANYOF_SYNTHETIC(or_with)) {
        ored_cp_list = ((regnode_ssc*) or_with)->invlist;
        ored_flags = ANYOF_FLAGS(or_with);
    }
    else {
        ored_cp_list = get_ANYOF_cp_list_for_ssc(pRExC_state, or_with);
        ored_flags = ANYOF_FLAGS(or_with) & ANYOF_COMMON_FLAGS;
    }

    ANYOF_FLAGS(ssc) |= ored_flags;

    /* Below, C1 is the list of code points in 'ssc'; P1, its posix classes.
     * C2 is the list of code points in 'or-with'; P2, its posix classes.
     * 'or_with' may be inverted.  When not inverted, we have the simple
     * situation of computing:
     *  (C1 | P1) | (C2 | P2)  =  (C1 | C2) | (P1 | P2)
     * If P1|P2 yields a situation with both a class and its complement are
     * set, like having both \w and \W, this matches all code points, and we
     * can delete these from the P component of the ssc going forward.  XXX We
     * might be able to delete all the P components, but I (khw) am not certain
     * about this, and it is better to be safe.
     *
     * Inverted, we have
     *  (C1 | P1) | ~(C2 | P2)  =  (C1 | P1) | (~C2 & ~P2)
     *                         <=  (C1 | P1) | ~C2
     *                         <=  (C1 | ~C2) | P1
     * (which results in actually simpler code than the non-inverted case)
     * */
d1030 5
a1034 16
    if ((ANYOF_FLAGS(or_with) & ANYOF_INVERT)
        && ! is_ANYOF_SYNTHETIC(or_with))
    {
        /* We ignore P2, leaving P1 going forward */
    }   /* else  Not inverted */
    else if (ANYOF_FLAGS(or_with) & ANYOF_POSIXL) {
        ANYOF_POSIXL_OR((regnode_charclass_posixl*)or_with, ssc);
        if (ANYOF_POSIXL_SSC_TEST_ANY_SET(ssc)) {
            unsigned int i;
            for (i = 0; i < ANYOF_MAX; i += 2) {
                if (ANYOF_POSIXL_TEST(ssc, i) && ANYOF_POSIXL_TEST(ssc, i + 1))
                {
                    ssc_match_all_cp(ssc);
                    ANYOF_POSIXL_CLEAR(ssc, i);
                    ANYOF_POSIXL_CLEAR(ssc, i+1);
                }
d1036 4
a1039 2
        }
    }
d1041 1
a1041 5
    ssc_union(ssc,
              ored_cp_list,
              FALSE /* Already has been inverted */
              );
}
d1043 11
a1053 4
PERL_STATIC_INLINE void
S_ssc_union(pTHX_ regnode_ssc *ssc, SV* const invlist, const bool invert2nd)
{
    PERL_ARGS_ASSERT_SSC_UNION;
d1055 8
a1062 74
    assert(is_ANYOF_SYNTHETIC(ssc));

    _invlist_union_maybe_complement_2nd(ssc->invlist,
                                        invlist,
                                        invert2nd,
                                        &ssc->invlist);
}

PERL_STATIC_INLINE void
S_ssc_intersection(pTHX_ regnode_ssc *ssc,
                         SV* const invlist,
                         const bool invert2nd)
{
    PERL_ARGS_ASSERT_SSC_INTERSECTION;

    assert(is_ANYOF_SYNTHETIC(ssc));

    _invlist_intersection_maybe_complement_2nd(ssc->invlist,
                                               invlist,
                                               invert2nd,
                                               &ssc->invlist);
}

PERL_STATIC_INLINE void
S_ssc_add_range(pTHX_ regnode_ssc *ssc, const UV start, const UV end)
{
    PERL_ARGS_ASSERT_SSC_ADD_RANGE;

    assert(is_ANYOF_SYNTHETIC(ssc));

    ssc->invlist = _add_range_to_invlist(ssc->invlist, start, end);
}

PERL_STATIC_INLINE void
S_ssc_cp_and(pTHX_ regnode_ssc *ssc, const UV cp)
{
    /* AND just the single code point 'cp' into the SSC 'ssc' */

    SV* cp_list = _new_invlist(2);

    PERL_ARGS_ASSERT_SSC_CP_AND;

    assert(is_ANYOF_SYNTHETIC(ssc));

    cp_list = add_cp_to_invlist(cp_list, cp);
    ssc_intersection(ssc, cp_list,
                     FALSE /* Not inverted */
                     );
    SvREFCNT_dec_NN(cp_list);
}

PERL_STATIC_INLINE void
S_ssc_clear_locale(pTHX_ regnode_ssc *ssc)
{
    /* Set the SSC 'ssc' to not match any locale things */

    PERL_ARGS_ASSERT_SSC_CLEAR_LOCALE;

    assert(is_ANYOF_SYNTHETIC(ssc));

    ANYOF_POSIXL_ZERO(ssc);
    ANYOF_FLAGS(ssc) &= ~ANYOF_LOCALE_FLAGS;
}

STATIC void
S_ssc_finalize(pTHX_ RExC_state_t *pRExC_state, regnode_ssc *ssc)
{
    /* The inversion list in the SSC is marked mortal; now we need a more
     * permanent copy, which is stored the same way that is done in a regular
     * ANYOF node, with the first 256 code points in a bit map */

    SV* invlist = invlist_clone(ssc->invlist);

    PERL_ARGS_ASSERT_SSC_FINALIZE;
d1064 2
a1065 17
    assert(is_ANYOF_SYNTHETIC(ssc));

    /* The code in this file assumes that all but these flags aren't relevant
     * to the SSC, except ANYOF_EMPTY_STRING, which should be cleared by the
     * time we reach here */
    assert(! (ANYOF_FLAGS(ssc) & ~ANYOF_COMMON_FLAGS));

    populate_ANYOF_from_invlist( (regnode *) ssc, &invlist);

    set_ANYOF_arg(pRExC_state, (regnode *) ssc, invlist,
                                NULL, NULL, NULL, FALSE);

    /* Make sure is clone-safe */
    ssc->invlist = NULL;

    if (ANYOF_POSIXL_SSC_TEST_ANY_SET(ssc)) {
        ANYOF_FLAGS(ssc) |= ANYOF_POSIXL;
a1066 2

    assert(! (ANYOF_FLAGS(ssc) & ANYOF_LOCALE_FLAGS) || RExC_contains_locale);
d1072 1
a1072 3
#define TRIE_LIST_USED(idx)  ( trie->states[state].trans.list         \
                               ? (TRIE_LIST_CUR( idx ) - 1)           \
                               : 0 )
d1115 1
a1115 1
            PerlIO_printf( Perl_debug_log, "%*s",
d1117 1
a1117 1
                pv_pretty(sv, SvPV_nolen_const(*tmp), SvCUR(*tmp), colwidth,
d1120 2
a1121 2
	                    PERL_PV_ESCAPE_FIRSTCHAR
                )
d1135 1
a1135 2
        PerlIO_printf( Perl_debug_log, "%*s#%4"UVXf"|",
                                       (int)depth * 2 + 2,"", (UV)state);
d1138 1
a1138 2
            PerlIO_printf( Perl_debug_log, " W%4X",
                                           trie->states[ state ].wordnum );
d1150 1
a1150 2
                     && trie->trans[ base + ofs - trie->uniquecharcount ].check
                                                                    != state))
d1156 3
a1158 5
                if ( ( base + ofs >= trie->uniquecharcount )
                        && ( base + ofs - trie->uniquecharcount
                                                        < trie->lasttrans )
                        && trie->trans[ base + ofs
                                    - trie->uniquecharcount ].check == state )
d1162 1
a1162 2
                    (UV)trie->trans[ base + ofs
                                             - trie->uniquecharcount ].next );
d1173 1
a1173 2
    PerlIO_printf(Perl_debug_log, "%*sword_info N:(prev,len)=",
                                (int)depth*2, "");
d1180 1
a1180 1
}
d1183 1
a1183 1
  List tries normally only are used for construction when the number of
d1203 1
a1203 1

d1206 1
a1206 1

d1217 1
a1217 2
	    SV ** const tmp = av_fetch( revcharmap,
                                        TRIE_LIST_ITEM(state,charid).forid, 0);
d1221 4
a1224 5
                    pv_pretty(sv, SvPV_nolen_const(*tmp), SvCUR(*tmp),
                              colwidth,
                              PL_colors[0], PL_colors[1],
                              (SvUTF8(*tmp) ? PERL_PV_ESCAPE_UNI : 0)
                              | PERL_PV_ESCAPE_FIRSTCHAR
d1229 1
a1229 1
                if (!(charid % 10))
d1236 1
a1236 1
}
d1240 2
a1241 2
  This is the normal DFA style state transition table, with a few
  twists to facilitate compression later.
d1256 1
a1256 1

d1261 1
a1261 1

d1267 1
a1267 1
            PerlIO_printf( Perl_debug_log, "%*s",
d1269 1
a1269 1
                pv_pretty(sv, SvPV_nolen_const(*tmp), SvCUR(*tmp), colwidth,
d1272 2
a1273 2
	                    PERL_PV_ESCAPE_FIRSTCHAR
                )
d1288 1
a1288 1
        PerlIO_printf( Perl_debug_log, "%*s%4"UVXf" : ",
d1300 1
a1300 2
            PerlIO_printf( Perl_debug_log, " (%4"UVXf")\n",
                                            (UV)trie->trans[ state ].check );
d1302 1
a1302 2
            PerlIO_printf( Perl_debug_log, " (%4"UVXf") W%4X\n",
                                            (UV)trie->trans[ state ].check,
d1421 1
a1421 1
    d = uvchr_to_utf8_flags(d, uv, 0);
d1433 1
a1433 1
            unsigned const char *const kapow = uvchr_to_utf8(flrbbbbb, val); \
d1444 25
a1468 22
/* This gets the next character from the input, folding it if not already
 * folded. */
#define TRIE_READ_CHAR STMT_START {                                           \
    wordlen++;                                                                \
    if ( UTF ) {                                                              \
        /* if it is UTF then it is either already folded, or does not need    \
         * folding */                                                         \
        uvc = valid_utf8_to_uvchr( (const U8*) uc, &len);                     \
    }                                                                         \
    else if (folder == PL_fold_latin1) {                                      \
        /* This folder implies Unicode rules, which in the range expressible  \
         *  by not UTF is the lower case, with the two exceptions, one of     \
         *  which should have been taken care of before calling this */       \
        assert(*uc != LATIN_SMALL_LETTER_SHARP_S);                            \
        uvc = toLOWER_L1(*uc);                                                \
        if (UNLIKELY(uvc == MICRO_SIGN)) uvc = GREEK_SMALL_LETTER_MU;         \
        len = 1;                                                              \
    } else {                                                                  \
        /* raw data, will be folded later if needed */                        \
        uvc = (U32)*uc;                                                       \
        len = 1;                                                              \
    }                                                                         \
d1511 1
a1511 2
            trie->jump = (U16 *) PerlMemShared_calloc( word_count + 1, \
                                                 sizeof(U16) ); \
d1546 1
a1546 3
S_make_trie(pTHX_ RExC_state_t *pRExC_state, regnode *startbranch,
                  regnode *first, regnode *last, regnode *tail,
                  U32 word_count, U32 flags, U32 depth)
d1554 1
d1567 1
a1567 1
    const U32 data_slot = add_data( pRExC_state, STR_WITH_LEN("tuuu"));
d1573 1
a1573 1
    const U32 data_slot = add_data( pRExC_state, STR_WITH_LEN("tu"));
d1588 1
d1591 1
d1615 6
a1620 5
        PerlIO_printf( Perl_debug_log,
          "%*smake_trie start==%d, first==%d, last==%d, tail==%d depth=%d\n",
          (int)depth * 2 + 2, "",
          REG_NODE_NUM(startbranch),REG_NODE_NUM(first),
          REG_NODE_NUM(last), REG_NODE_NUM(tail), (int)depth);
d1622 1
a1622 1

d1631 1
a1631 1

d1640 3
a1642 3
       (trie->charmap) and we use a an HV* to store Unicode characters. We use
       the native representation of the character value as the key and IV's for
       the coded index.
d1659 4
a1662 1
        int foldlen = 0;
d1664 2
a1665 4
        STRLEN minchars = 0;
        STRLEN maxchars = 0;
        bool set_bit = trie->bitmap ? 1 : 0; /*store the first char in the
                                               bitmap?*/
d1685 1
a1685 1
                TRIE_BITMAP_SET(trie, LATIN_SMALL_LETTER_SHARP_S);
d1688 1
a1688 2
        for ( ; uc < e ; uc += len ) {  /* Look at each char in the current
                                           branch */
d1691 1
a1691 64

            /* TRIE_READ_CHAR returns the current character, or its fold if /i
             * is in effect.  Under /i, this character can match itself, or
             * anything that folds to it.  If not under /i, it can match just
             * itself.  Most folds are 1-1, for example k, K, and KELVIN SIGN
             * all fold to k, and all are single characters.   But some folds
             * expand to more than one character, so for example LATIN SMALL
             * LIGATURE FFI folds to the three character sequence 'ffi'.  If
             * the string beginning at 'uc' is 'ffi', it could be matched by
             * three characters, or just by the one ligature character. (It
             * could also be matched by two characters: LATIN SMALL LIGATURE FF
             * followed by 'i', or by 'f' followed by LATIN SMALL LIGATURE FI).
             * (Of course 'I' and/or 'F' instead of 'i' and 'f' can also
             * match.)  The trie needs to know the minimum and maximum number
             * of characters that could match so that it can use size alone to
             * quickly reject many match attempts.  The max is simple: it is
             * the number of folded characters in this branch (since a fold is
             * never shorter than what folds to it. */

            maxchars++;

            /* And the min is equal to the max if not under /i (indicated by
             * 'folder' being NULL), or there are no multi-character folds.  If
             * there is a multi-character fold, the min is incremented just
             * once, for the character that folds to the sequence.  Each
             * character in the sequence needs to be added to the list below of
             * characters in the trie, but we count only the first towards the
             * min number of characters needed.  This is done through the
             * variable 'foldlen', which is returned by the macros that look
             * for these sequences as the number of bytes the sequence
             * occupies.  Each time through the loop, we decrement 'foldlen' by
             * how many bytes the current char occupies.  Only when it reaches
             * 0 do we increment 'minchars' or look for another multi-character
             * sequence. */
            if (folder == NULL) {
                minchars++;
            }
            else if (foldlen > 0) {
                foldlen -= (UTF) ? UTF8SKIP(uc) : 1;
            }
            else {
                minchars++;

                /* See if *uc is the beginning of a multi-character fold.  If
                 * so, we decrement the length remaining to look at, to account
                 * for the current character this iteration.  (We can use 'uc'
                 * instead of the fold returned by TRIE_READ_CHAR because for
                 * non-UTF, the latin1_safe macro is smart enough to account
                 * for all the unfolded characters, and because for UTF, the
                 * string will already have been folded earlier in the
                 * compilation process */
                if (UTF) {
                    if ((foldlen = is_MULTI_CHAR_FOLD_utf8_safe(uc, e))) {
                        foldlen -= UTF8SKIP(uc);
                    }
                }
                else if ((foldlen = is_MULTI_CHAR_FOLD_latin1_safe(uc, e))) {
                    foldlen--;
                }
            }

            /* The current character (and any potential folds) should be added
             * to the possible matching characters for this position in this
             * branch */
d1715 1
a1715 1
			if (! UVCHR_IS_INVARIANT(uvc)) {
a1721 8

                /* XXX We could come up with the list of code points that fold
                 * to this using PL_utf8_foldclosures, except not for
                 * multi-char folds, as there may be multiple combinations
                 * there that could work, which needs to wait until runtime to
                 * resolve (The comment about LIGATURE FFI above is such an
                 * example */

d1736 1
a1736 4
        } /* end loop through characters in this branch of the trie */

        /* We take the min and max for this branch and combine to find the min
         * and max for all branches processed so far */
d1738 17
a1754 6
            trie->minlen = minchars;
            trie->maxlen = maxchars;
        } else if (minchars < trie->minlen) {
            trie->minlen = minchars;
        } else if (maxchars > trie->maxlen) {
            trie->maxlen = maxchars;
d1756 1
d1759 1
a1759 2
        PerlIO_printf( Perl_debug_log,
                "%*sTRIE(%s): W:%d C:%d Uq:%d Min:%d Max:%d\n",
d1791 1
a1791 3
    if ( (IV)( ( TRIE_CHARCOUNT(trie) + 1 ) * trie->uniquecharcount + 1)
                                                    > SvIV(re_trie_maxbuff) )
    {
d1806 1
a1806 1
        DEBUG_TRIE_COMPILE_MORE_r( PerlIO_printf( Perl_debug_log,
d1823 2
d1826 2
d1846 1
a1846 4
                        SV** const svpp = hv_fetch( widecharmap,
                                                    (char*)&uvc,
                                                    sizeof( UV ),
                                                    0);
d1853 1
a1853 2
                    /* charid is now 0 if we dont know the char read, or
                     * nonzero if we do */
d1863 2
a1864 7
                        for ( check = 1;
                              check <= TRIE_LIST_USED( state );
                              check++ )
                        {
                            if ( TRIE_LIST_ITEM( state, check ).forid
                                                                    == charid )
                            {
d1886 1
a1886 1
        trie->statecount = next_alloc;
d1934 1
a1934 3
                        Zero( trie->trans + (transcount / 2),
                              transcount / 2,
                              reg_trie_trans );
d1942 1
a1942 2
                                trie->trans[ zp ].next = TRIE_LIST_ITEM( state,
                                                                   1).newstate;
d1949 1
a1949 2
                            trie->trans[ tp ].next = TRIE_LIST_ITEM( state,
                                                                   1).newstate;
d1956 2
a1957 5
                            const U32 tid = base
                                           - trie->uniquecharcount
                                           + TRIE_LIST_ITEM( state, idx ).forid;
                            trie->trans[ tid ].next = TRIE_LIST_ITEM( state,
                                                                idx ).newstate;
d1977 4
a1980 4
           we dont use the 0 slot of either trans[] or states[] so we add 1 to
           each.  We know that we will need Charcount+1 trans at most to store
           the data (one row per char at worst case) So we preallocate both
           structures assuming worst case.
d1985 3
a1987 3
           We use the .check field of the first entry of the node temporarily
           to make compression both faster and easier by keeping track of how
           many non zero fields are in the node.
d1992 5
a1996 5
           There are two terms at use here: state as a TRIE_NODEIDX() which is
           a number representing the first entry of the node, and state as a
           TRIE_NODENUM() which is the trans number. state 1 is TRIE_NODEIDX(1)
           and TRIE_NODENUM(1), state 2 is TRIE_NODEIDX(2) and TRIE_NODENUM(3)
           if there are 2 entrys per node. eg:
d2004 3
a2006 3
           The table is internally in the right hand, idx form. However as we
           also have to deal with the states array which is indexed by nodenum
           we have to use TRIE_NODENUM() to convert.
d2009 1
a2009 1
        DEBUG_TRIE_COMPILE_MORE_r( PerlIO_printf( Perl_debug_log,
d2033 1
d2035 1
d2037 2
d2057 1
a2057 4
                        SV* const * const svpp = hv_fetch( widecharmap,
                                                           (char*)&uvc,
                                                           sizeof( UV ),
                                                           0);
d2073 1
a2073 2
                    /* charid is now 0 if we dont know the char read, or
                     * nonzero if we do */
d2160 1
a2160 4
            for ( charid = 0;
                  used && charid < trie->uniquecharcount;
                  charid++ )
            {
d2169 2
a2170 7
                            trie->states[ state ].trans.base
                                                    = zp
                                                      + trie->uniquecharcount
                                                      - charid ;
                            trie->trans[ zp ].next
                                = SAFE_TRIE_NODENUM( trie->trans[ stateidx
                                                             + charid ].next );
d2179 1
a2179 2
                        trie->states[ state ].trans.base
                                       = pos + trie->uniquecharcount - charid ;
d2181 1
a2181 3
                    trie->trans[ pos ].next
                        = SAFE_TRIE_NODENUM(
                                       trie->trans[ stateidx + charid ].next );
d2192 7
a2198 8
            PerlIO_printf( Perl_debug_log,
                "%*sAlloc: %d Orig: %"IVdf" elements, Final:%"IVdf". Savings of %%%5.2f\n",
                (int)depth * 2 + 2,"",
                (int)( ( TRIE_CHARCOUNT(trie) + 1 ) * trie->uniquecharcount
                       + 1 ),
                (IV)next_alloc,
                (IV)pos,
                ( ( next_alloc - pos ) * 100 ) / (double)next_alloc );
d2204 1
a2204 2
            PerlIO_printf(Perl_debug_log,
                "%*sStatecount:%"UVxf" Lasttrans:%"UVxf"\n",
d2214 1
a2214 1
    {   /* Modify the program and insert the new TRIE node */
d2217 1
a2217 1

d2255 1
a2255 2
            PerlIO_printf(Perl_debug_log,
                "%*sMJD offset:%"UVuf" MJD length:%"UVuf"\n",
d2260 1
a2260 1
        /* But first we check to see if there is a common prefix we can
d2319 2
a2320 2
                            (UV)state, (UV)idx,
                            pv_pretty(sv, SvPV_nolen_const(*tmp), SvCUR(*tmp), 6,
d2323 1
a2323 1
	                        PERL_PV_ESCAPE_FIRSTCHAR
d2336 1
a2336 1
#ifdef DEBUGGING
d2387 2
a2388 2
        if (!jumper)
            jumper = last;
d2392 2
a2393 2
	    /* Store the offset to the first unabsorbed branch in
	       jump[0], which is otherwise unused by the jump logic.
d2395 1
a2395 1
	    if (trie->jump)
d2397 1
a2397 1

d2412 1
a2412 1
            } else
d2418 2
a2419 2
            optimize = convert
                      + NODE_STEP_REGNODE
d2422 1
a2422 1
            /* XXX We really should free up the resource in trie now,
d2432 2
a2433 2
            /*
                Try to clean up some of the debris left after the
d2488 4
a2491 4
    return trie->jump
           ? MADE_JUMP_TRIE
           : trie->startstate>1
             ? MADE_EXACT_TRIE
d2498 1
a2498 2
/* The Trie is constructed and compressed now so we can build a fail array if
 * it's needed
d2500 2
a2501 4
   This is basically the Aho-Corasick algorithm. Its from exercise 3.31 and
   3.32 in the
   "Red Dragon" -- Compilers, principles, techniques, and tools. Aho, Sethi,
   Ullman 1985/88
d2504 5
a2508 6
   We find the fail state for each state in the trie, this state is the longest
   proper suffix of the current state's 'word' that is also a proper prefix of
   another word in our trie. State 1 represents the word '' and is thus the
   default fail state. This allows the DFA not to have to restart after its
   tried and failed a word at a given point, it simply continues as though it
   had been matching the other word in the first place.
d2511 3
a2513 4
   When we get to 'd' we are still matching the first word, we would encounter
   'g' which would fail, which would bring us to the state representing 'd' in
   the second word where we would try 'g' and succeed, proceeding to match
   'cdgu'.
d2528 1
a2528 1
    const U32 data_slot = add_data( pRExC_state, STR_WITH_LEN("T"));
d2592 1
a2592 1
		      "%*sStclass Failtable (%"UVuf" states): 0",
d2601 1
a2601 1
    /*RExC_seen |= REG_TRIEDFA_SEEN;*/
d2605 11
d2620 1
a2620 1
       regprop(RExC_rx, mysv, scan, NULL); \
d2639 1
a2639 2
 * fold.  *min_subtract is set to the total delta number of characters of the
 * input nodes.
d2641 2
a2642 9
 * And *unfolded_multi_char is set to indicate whether or not the node contains
 * an unfolded multi-char fold.  This happens when whether the fold is valid or
 * not won't be known until runtime; namely for EXACTF nodes that contain LATIN
 * SMALL LETTER SHARP S, as only if the target string being matched against
 * turns out to be UTF-8 is that fold valid; and also for EXACTFL nodes whose
 * folding rules depend on the locale in force at runtime.  (Multi-char folds
 * whose components are all above the Latin1 range are not run-time locale
 * dependent, and have already been folded by the time this function is
 * called.)
d2649 1
a2649 1
 * approach doesn't always work, as evidenced by this example:
d2651 1
a2651 1
 * Both sides fold to "sss", but if the pattern is parsed to create a node that
d2655 1
a2655 1
 * that is "sss" in this case.
d2658 2
a2659 2
 * just these three.  Now the code is general, for all such cases.  The
 * approach taken is:
d2661 10
a2670 10
 *      character folded sequences.  Since a single character can fold into
 *      such a sequence, the minimum match length for this node is less than
 *      the number of characters in the node.  This routine returns in
 *      *min_subtract how many characters to subtract from the the actual
 *      length of the string to get a real minimum match length; it is 0 if
 *      there are no multi-char foldeds.  This delta is used by the caller to
 *      adjust the min length of the match, and the delta between min and max,
 *      so that the optimizer doesn't reject these possibilities based on size
 *      constraints.
 * 2)   For the sequence involving the Sharp s (\xDF), the node type EXACTFU_SS
d2677 5
a2681 6
 *      pre-folded by regcomp.c (except EXACTFL, some of whose folds aren't
 *      known until runtime).  This saves effort in regex matching.  However,
 *      the pre-folding isn't done for non-UTF8 patterns because the fold of
 *      the MICRO SIGN requires UTF-8, and we don't want to slow things down by
 *      forcing the pattern into UTF8 unless necessary.  Also what EXACTF (and,
 *      again, EXACTFL) nodes fold to isn't known until runtime.  The fold
d2689 24
a2712 47
 * 3)   A problem remains for unfolded multi-char folds. (These occur when the
 *      validity of the fold won't be known until runtime, and so must remain
 *      unfolded for now.  This happens for the sharp s in EXACTF and EXACTFA
 *      nodes when the pattern isn't in UTF-8.  (Note, BTW, that there cannot
 *      be an EXACTF node with a UTF-8 pattern.)  They also occur for various
 *      folds in EXACTFL nodes, regardless of the UTF-ness of the pattern.)
 *      The reason this is a problem is that the optimizer part of regexec.c
 *      (probably unwittingly, in Perl_regexec_flags()) makes an assumption
 *      that a character in the pattern corresponds to at most a single
 *      character in the target string.  (And I do mean character, and not byte
 *      here, unlike other parts of the documentation that have never been
 *      updated to account for multibyte Unicode.)  sharp s in EXACTF and
 *      EXACTFL nodes can match the two character string 'ss'; in EXACTFA nodes
 *      it can match "\x{17F}\x{17F}".  These, along with other ones in EXACTFL
 *      nodes, violate the assumption, and they are the only instances where it
 *      is violated.  I'm reluctant to try to change the assumption, as the
 *      code involved is impenetrable to me (khw), so instead the code here
 *      punts.  This routine examines EXACTFL nodes, and (when the pattern
 *      isn't UTF-8) EXACTF and EXACTFA for such unfolded folds, and returns a
 *      boolean indicating whether or not the node contains such a fold.  When
 *      it is true, the caller sets a flag that later causes the optimizer in
 *      this file to not set values for the floating and fixed string lengths,
 *      and thus avoids the optimizer code in regexec.c that makes the invalid
 *      assumption.  Thus, there is no optimization based on string lengths for
 *      EXACTFL nodes that contain these few folds, nor for non-UTF8-pattern
 *      EXACTF and EXACTFA nodes that contain the sharp s.  (The reason the
 *      assumption is wrong only in these cases is that all other non-UTF-8
 *      folds are 1-1; and, for UTF-8 patterns, we pre-fold all other folds to
 *      their expanded versions.  (Again, we can't prefold sharp s to 'ss' in
 *      EXACTF nodes because we don't know at compile time if it actually
 *      matches 'ss' or not.  For EXACTF nodes it will match iff the target
 *      string is in UTF-8.  This is in contrast to EXACTFU nodes, where it
 *      always matches; and EXACTFA where it never does.  In an EXACTFA node in
 *      a UTF-8 pattern, sharp s is folded to "\x{17F}\x{17F}, avoiding the
 *      problem; but in a non-UTF8 pattern, folding it to that above-Latin1
 *      string would require the pattern to be forced into UTF-8, the overhead
 *      of which we want to avoid.  Similarly the unfolded multi-char folds in
 *      EXACTFL nodes will match iff the locale at the time of match is a UTF-8
 *      locale.)
 *
 *      Similarly, the code that generates tries doesn't currently handle
 *      not-already-folded multi-char folds, and it looks like a pain to change
 *      that.  Therefore, trie generation of EXACTFA nodes with the sharp s
 *      doesn't work.  Instead, such an EXACTFA is turned into a new regnode,
 *      EXACTFA_NO_TRIE, which the trie code knows not to handle.  Most people
 *      using /iaa matching will be doing so almost entirely with ASCII
 *      strings, so this should rarely be encountered in practice */
d2714 1
a2714 1
#define JOIN_EXACT(scan,min_subtract,unfolded_multi_char, flags) \
d2716 1
a2716 1
        join_exact(pRExC_state,(scan),(min_subtract),unfolded_multi_char, (flags),NULL,depth+1)
d2719 1
a2719 4
S_join_exact(pTHX_ RExC_state_t *pRExC_state, regnode *scan,
                   UV *min_subtract, bool *unfolded_multi_char,
                   U32 flags,regnode *val, U32 depth)
{
d2748 1
a2748 1

d2765 2
a2766 3
            /* XXX I (khw) kind of doubt that this works on platforms (should
             * Perl ever run on one) where U8_MAX is above 255 because of lots
             * of other assumptions */
d2770 1
a2770 1

d2801 1
a2801 1
    *unfolded_multi_char = FALSE;
d2809 3
a2811 6
        U8* s0 = (U8*) STRING(scan);
        U8* s = s0;
        U8* s_end = s0 + STR_LEN(scan);

        int total_count_delta = 0;  /* Total delta number of characters that
                                       multi-char folds expand to */
d2814 1
a2814 1
	 * possibilities.  To avoid some tests in the loop, there are two main
a2817 50
            U8* folded = NULL;

            if (OP(scan) == EXACTFL) {
                U8 *d;

                /* An EXACTFL node would already have been changed to another
                 * node type unless there is at least one character in it that
                 * is problematic; likely a character whose fold definition
                 * won't be known until runtime, and so has yet to be folded.
                 * For all but the UTF-8 locale, folds are 1-1 in length, but
                 * to handle the UTF-8 case, we need to create a temporary
                 * folded copy using UTF-8 locale rules in order to analyze it.
                 * This is because our macros that look to see if a sequence is
                 * a multi-char fold assume everything is folded (otherwise the
                 * tests in those macros would be too complicated and slow).
                 * Note that here, the non-problematic folds will have already
                 * been done, so we can just copy such characters.  We actually
                 * don't completely fold the EXACTFL string.  We skip the
                 * unfolded multi-char folds, as that would just create work
                 * below to figure out the size they already are */

                Newx(folded, UTF8_MAX_FOLD_CHAR_EXPAND * STR_LEN(scan) + 1, U8);
                d = folded;
                while (s < s_end) {
                    STRLEN s_len = UTF8SKIP(s);
                    if (! is_PROBLEMATIC_LOCALE_FOLD_utf8(s)) {
                        Copy(s, d, s_len, U8);
                        d += s_len;
                    }
                    else if (is_FOLDS_TO_MULTI_utf8(s)) {
                        *unfolded_multi_char = TRUE;
                        Copy(s, d, s_len, U8);
                        d += s_len;
                    }
                    else if (isASCII(*s)) {
                        *(d++) = toFOLD(*s);
                    }
                    else {
                        STRLEN len;
                        _to_utf8_fold_flags(s, d, &len, FOLD_FLAGS_FULL);
                        d += len;
                    }
                    s += s_len;
                }

                /* Point the remainder of the routine to look at our temporary
                 * folded copy */
                s = folded;
                s_end = d;
            } /* End of creating folded copy of EXACTFL string */
d2825 1
a2825 1
                int count = 0;  /* How many characters in a multi-char fold */
d2832 2
a2833 2
                /* Nodes with 'ss' require special handling, except for
                 * EXACTFA-ish for which there is no multi-char fold to this */
d2835 1
a2835 2
                    && OP(scan) != EXACTFA
                    && OP(scan) != EXACTFA_NO_TRIE)
d2838 24
a2861 2
                    if (OP(scan) != EXACTFL) {
                        OP(scan) = EXACTFU_SS;
d2863 1
a2863 1
                    s += 2;
d2866 1
a2866 1
                    U8* multi_end  = s + len;
d2868 10
a2877 4
                    /* Count how many characters in it.  In the case of /aa, no
                     * folds which contain ASCII code points are allowed, so
                     * check for those, and skip if found. */
                    if (OP(scan) != EXACTFA && OP(scan) != EXACTFA_NO_TRIE) {
d2897 2
a2898 2
                total_count_delta += count - 1;
              next_iteration: ;
d2900 21
a2920 44

            /* We created a temporary folded copy of the string in EXACTFL
             * nodes.  Therefore we need to be sure it doesn't go below zero,
             * as the real string could be shorter */
            if (OP(scan) == EXACTFL) {
                int total_chars = utf8_length((U8*) STRING(scan),
                                           (U8*) STRING(scan) + STR_LEN(scan));
                if (total_count_delta > total_chars) {
                    total_count_delta = total_chars;
                }
            }

            *min_subtract += total_count_delta;
            Safefree(folded);
	}
	else if (OP(scan) == EXACTFA) {

            /* Non-UTF-8 pattern, EXACTFA node.  There can't be a multi-char
             * fold to the ASCII range (and there are no existing ones in the
             * upper latin1 range).  But, as outlined in the comments preceding
             * this function, we need to flag any occurrences of the sharp s.
             * This character forbids trie formation (because of added
             * complexity) */
	    while (s < s_end) {
                if (*s == LATIN_SMALL_LETTER_SHARP_S) {
                    OP(scan) = EXACTFA_NO_TRIE;
                    *unfolded_multi_char = TRUE;
                    break;
                }
                s++;
                continue;
            }
        }
	else {

            /* Non-UTF-8 pattern, not EXACTFA node.  Look for the multi-char
             * folds that are all Latin1.  As explained in the comments
             * preceding this function, we look also for the sharp s in EXACTF
             * and EXACTFL nodes; it can be in the final position.  Otherwise
             * we can stop looking 1 byte earlier because have to find at least
             * two characters for a multi-fold */
	    const U8* upper = (OP(scan) == EXACTF || OP(scan) == EXACTFL)
                              ? s_end
                              : s_end -1;
d2925 1
a2925 2
                    if (*s == LATIN_SMALL_LETTER_SHARP_S
                        && (OP(scan) == EXACTF || OP(scan) == EXACTFL))
d2927 1
a2927 1
                        *unfolded_multi_char = TRUE;
d2934 2
a2935 2
                    && isARG2_lower_or_UPPER_ARG1('s', *s)
                    && isARG2_lower_or_UPPER_ARG1('s', *(s+1)))
d2942 2
a2943 3
                     * which we don't know until runtime.  EXACTFL nodes can't
                     * transform into EXACTFU nodes */
                    if (OP(scan) != EXACTF && OP(scan) != EXACTFL) {
d2977 1
a2977 1
    Newx(and_withp,1, regnode_ssc); \
a2987 1
    U32 prev_recursed_depth;
d2992 3
a2994 1
STATIC SSize_t
d2996 1
a2996 1
                        SSize_t *minlenp, SSize_t *deltap,
d3000 2
a3001 2
                        U32 recursed_depth,
			regnode_ssc *and_withp,
d3012 1
a3012 2
    /* There must be at least this number of characters to match */
    SSize_t min = 0;
d3015 1
a3015 1
    SSize_t delta = 0;
d3022 1
a3022 1
    SSize_t stopmin = SSize_t_MAX;
d3031 1
d3043 1
a3043 1
	bool unfolded_multi_char = FALSE;
d3045 2
a3046 26
        DEBUG_OPTIMISE_MORE_r(
        {
            PerlIO_printf(Perl_debug_log,
                "%*sstudy_chunk stopparen=%ld depth=%lu recursed_depth=%lu ",
                ((int) depth*2), "", (long)stopparen,
                (unsigned long)depth, (unsigned long)recursed_depth);
            if (recursed_depth) {
                U32 i;
                U32 j;
                for ( j = 0 ; j < recursed_depth ; j++ ) {
                    PerlIO_printf(Perl_debug_log,"[");
                    for ( i = 0 ; i < (U32)RExC_npar ; i++ )
                        PerlIO_printf(Perl_debug_log,"%d",
                            PAREN_TEST(RExC_study_chunk_recursed +
                                       (j * RExC_study_chunk_recursed_bytes), i)
                            ? 1 : 0
                        );
                    PerlIO_printf(Perl_debug_log,"]");
                }
            }
            PerlIO_printf(Perl_debug_log,"\n");
        }
        );
        DEBUG_STUDYDATA("Peep:", data, depth);
        DEBUG_PEEP("Peep", scan, depth);

d3048 4
a3051 5
        /* The reason we do this here we need to deal with things like /(?:f)(?:o)(?:o)/
         * which cant be dealt with by the normal EXACT parsing code, as each (?:..) is handled
         * by a different invocation of reg() -- Yves
         */
        JOIN_EXACT(scan,&min_subtract, &unfolded_multi_char, 0);
d3084 1
a3084 2
            /* demq: the op(next)==code check is to see if we have
             * "branch-branch" AFAICT */
d3087 5
a3091 5
                /* NOTE - There is similar code to this block below for
                 * handling TRIE nodes on a re-study.  If you change stuff here
                 * check there too. */
		SSize_t max1 = 0, min1 = SSize_t_MAX, num = 0;
		regnode_ssc accum;
d3094 4
a3097 7
                if (flags & SCF_DO_SUBSTR) {
                    /* Cannot merge strings after this. */
                    scan_commit(pRExC_state, data, minlenp, is_inf);
                }

                if (flags & SCF_DO_STCLASS)
		    ssc_init_zero(pRExC_state, &accum);
d3100 2
a3101 3
		    SSize_t deltanext, minnext, fake;
		    I32 f = 0;
		    regnode_ssc this_class;
d3118 1
a3118 1
			ssc_init(pRExC_state, &this_class);
d3126 3
a3128 3
		    minnext = study_chunk(pRExC_state, &scan, minlenp,
                                      &deltanext, next, &data_fake, stopparen,
                                      recursed_depth, NULL, f,depth+1);
d3131 1
a3131 1
		    if (deltanext == SSize_t_MAX) {
d3133 1
a3133 1
			max1 = SSize_t_MAX;
d3140 1
a3140 1
	                if ( stopmin > minnext)
d3152 1
a3152 1
			ssc_or(pRExC_state, &accum, (regnode_charclass*)&this_class);
d3158 2
a3159 2
		    if (data->pos_delta >= SSize_t_MAX - (max1 - min1))
		        data->pos_delta = SSize_t_MAX;
d3166 2
a3167 3
		if (delta == SSize_t_MAX
		 || SSize_t_MAX - delta - (max1 - min1) < 0)
		    delta = SSize_t_MAX;
d3171 1
a3171 1
		    ssc_or(pRExC_state, data->start_class, (regnode_charclass*) &accum);
d3173 1
a3173 1
			ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);
d3179 1
a3179 1
			ssc_and(pRExC_state, data->start_class, (regnode_charclass *) &accum);
d3186 2
a3187 1
			StructCopy(data->start_class, and_withp, regnode_ssc);
d3189 2
a3190 1
			StructCopy(&accum, data->start_class, regnode_ssc);
d3192 1
d3196 1
a3196 3
                if (PERL_ENABLE_TRIE_OPTIMISATION &&
                        OP( startbranch ) == BRANCH )
                {
d3199 4
a3202 4
                   Assuming this was/is a branch we are dealing with: 'scan'
                   now points at the item that follows the branch sequence,
                   whatever it is. We now start at the beginning of the
                   sequence and look for subsequences of
d3208 1
a3208 2
                   which would be constructed from a pattern like
                   /A|LIST|OF|WORDS/
d3216 1
a3216 2
                     1. patterns where the whole set of branches can be
                        converted.
d3227 1
a3227 1
		  There is an additional case, that being where there is a
d3253 1
a3253 1
                        SV * const mysv = sv_newmortal();   /* for dumping */
d3268 1
a3268 1

d3270 1
a3270 1
                            regprop(RExC_rx, mysv, tail, NULL);
d3272 3
a3274 3
                              (int)depth * 2 + 2, "",
                              "Looking for TRIE'able sequences. Tail node is: ",
                              SvPV_nolen_const( mysv )
d3277 1
a3277 1

d3282 1
a3282 2
                                noper is the first thing to be matched as part
                                      of that branch
d3285 24
a3308 33
                            We normally handle a case like this
                            /FOO[xyz]|BAR[pqr]/ via a "jump trie" but we also
                            support building with NOJUMPTRIE, which restricts
                            the trie logic to structures like /FOO|BAR/.

                            If noper is a trieable nodetype then the branch is
                            a possible optimization target. If we are building
                            under NOJUMPTRIE then we require that noper_next is
                            the same as scan (our current position in the regex
                            program).

                            Once we have two or more consecutive such branches
                            we can create a trie of the EXACT's contents and
                            stitch it in place into the program.

                            If the sequence represents all of the branches in
                            the alternation we replace the entire thing with a
                            single TRIE node.

                            Otherwise when it is a subsequence we need to
                            stitch it in place and replace only the relevant
                            branches. This means the first branch has to remain
                            as it is used by the alternation logic, and its
                            next pointer, and needs to be repointed at the item
                            on the branch chain following the last branch we
                            have optimized away.

                            This could be either a BRANCH, in which case the
                            subsequence is internal, or it could be the item
                            following the branch sequence in which case the
                            subsequence is at the end (which does not
                            necessarily mean the first node is the start of the
                            alternation).
d3310 1
a3310 2
                            TRIE_TYPE(X) is a define which maps the optype to a
                            trietype.
d3318 2
a3319 1
                                EXACTFA         | EXACTFA
d3325 1
a3325 2
                       ( EXACTFU == (X) || EXACTFU_SS == (X) ) ? EXACTFU :        \
                       ( EXACTFA == (X) ) ? EXACTFA :        \
d3340 1
a3340 1
                                regprop(RExC_rx, mysv, cur, NULL);
d3344 1
a3344 1
                                regprop(RExC_rx, mysv, noper, NULL);
d3349 1
a3349 1
                                  regprop(RExC_rx, mysv, noper_next, NULL);
d3355 1
a3355 1
				   PL_reg_name[trietype], PL_reg_name[noper_trietype], PL_reg_name[noper_next_trietype]
d3359 2
a3360 2
                            /* Is noper a trieable nodetype that can be merged
                             * with the current trie (if there is one)? */
d3373 4
a3376 4
                                /* Handle mergable triable node Either we are
                                 * the first node in a new trieable sequence,
                                 * in which case we do some bookkeeping,
                                 * otherwise we update the end pointer. */
d3389 2
a3390 3
                                            /* a NOTHING regop is 1 regop wide.
                                             * We need at least two for a trie
                                             * so we can't merge this in */
d3406 2
a3407 3
                                 * noper may either be a triable node which can
                                 * not be tried together with the current trie,
                                 * or a non triable node */
d3409 5
a3413 8
                                    /* If last is set and trietype is not
                                     * NOTHING then we have found at least two
                                     * triable branch sequences in a row of a
                                     * similar trietype so we can turn them
                                     * into a trie. If/when we allow NOTHING to
                                     * start a trie sequence this condition
                                     * will be required, and it isn't expensive
                                     * so we leave it in for now. */
d3416 3
a3418 5
                                                startbranch, first, cur, tail,
                                                count, trietype, depth+1 );
                                    last = NULL; /* note: we clear/update
                                                    first, trietype etc below,
                                                    so we dont do it here */
d3425 1
a3425 2
                                    /* noper is triable, so we can start a new
                                     * trie sequence */
d3430 1
a3430 2
                                    /* if we already saw a first but the
                                     * current node is not triable then we have
d3439 1
a3439 1
                            regprop(RExC_rx, mysv, cur, NULL);
d3441 1
a3441 2
                              "%*s- %s (%d) <SCAN FINISHED>\n",
                              (int)depth * 2 + 2,
d3447 4
a3450 6
                                /* the last branch of the sequence was part of
                                 * a trie, so we have to construct it here
                                 * outside of the loop */
                                made= make_trie( pRExC_state, startbranch,
                                                 first, scan, tail, count,
                                                 trietype, depth+1 );
d3460 1
a3460 1
                                        RExC_seen &=~REG_TOP_LEVEL_BRANCHES_SEEN;
d3465 2
a3466 4
                                /* at this point we know whatever we have is a
                                 * NOTHING sequence/branch AND if 'startbranch'
                                 * is 'first' then we can turn the whole thing
                                 * into a NOTHING
d3470 2
a3471 3
                                    /* the entire thing is a NOTHING sequence,
                                     * something like this: (?:|) So we can
                                     * turn it into a plain NOTHING op. */
d3473 1
a3473 1
                                        regprop(RExC_rx, mysv, cur, NULL);
d3487 1
a3487 1

d3489 1
a3489 1

a3500 1
            U32 my_recursed_depth= recursed_depth;
d3503 1
a3503 1
                /* set the pointer */
d3514 6
a3519 15
                if (!recursed_depth
                    ||
                    !PAREN_TEST(RExC_study_chunk_recursed + ((recursed_depth-1) * RExC_study_chunk_recursed_bytes), paren)
                ) {
                    if (!recursed_depth) {
                        Zero(RExC_study_chunk_recursed, RExC_study_chunk_recursed_bytes, U8);
                    } else {
                        Copy(RExC_study_chunk_recursed + ((recursed_depth-1) * RExC_study_chunk_recursed_bytes),
                             RExC_study_chunk_recursed + (recursed_depth * RExC_study_chunk_recursed_bytes),
                             RExC_study_chunk_recursed_bytes, U8);
                    }
                    /* we havent recursed into this paren yet, so recurse into it */
	            DEBUG_STUDYDATA("set:", data,depth);
                    PAREN_SET(RExC_study_chunk_recursed + (recursed_depth * RExC_study_chunk_recursed_bytes), paren);
                    my_recursed_depth= recursed_depth + 1;
a3521 3
	            DEBUG_STUDYDATA("inf:", data,depth);
                    /* some form of infinite recursion, assume infinite length
                     * */
d3523 1
a3523 1
                        scan_commit(pRExC_state, data, minlenp, is_inf);
d3528 1
a3528 1
                        ssc_anything(data->start_class);
a3544 4
                newframe->prev_recursed_depth = recursed_depth;

                DEBUG_STUDYDATA("frame-new:",data,depth);
                DEBUG_PEEP("fnew", scan, depth);
a3549 2
                depth = depth + 1;
                recursed_depth= my_recursed_depth;
d3555 1
a3555 1
	    SSize_t l = STR_LEN(scan);
d3571 1
a3571 1
 			? SSize_t_MAX : data->pos_min + data->pos_delta;
d3582 1
a3582 1
                                              (U8*)STRING(scan)+STR_LEN(scan));
d3588 4
d3593 38
a3630 6
            /* ANDing the code point leaves at most it, and not in locale, and
             * can't match null string */
	    if (flags & SCF_DO_STCLASS_AND) {
                ssc_cp_and(data->start_class, uc);
                ANYOF_FLAGS(data->start_class) &= ~ANYOF_EMPTY_STRING;
                ssc_clear_locale(data->start_class);
d3633 7
a3639 5
                ssc_add_cp(data->start_class, uc);
		ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);

                /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a */
                ANYOF_FLAGS(data->start_class) &= ~ANYOF_EMPTY_STRING;
d3644 1
a3644 1
	    SSize_t l = STR_LEN(scan);
a3645 2
            SV* EXACTF_invlist = _new_invlist(4); /* Start out big enough for 2
                                                     separate code points */
d3650 1
a3650 1
                scan_commit(pRExC_state, data, minlenp, is_inf);
d3657 2
a3658 2
	    if (unfolded_multi_char) {
                RExC_seen |= REG_UNFOLDED_MULTI_SEEN;
d3673 22
a3694 1
            if (OP(scan) == EXACTFL) {
d3696 29
a3724 70
                /* We don't know what the folds are; it could be anything. XXX
                 * Actually, we only support UTF-8 encoding for code points
                 * above Latin1, so we could know what those folds are. */
                EXACTF_invlist = _add_range_to_invlist(EXACTF_invlist,
                                                       0,
                                                       UV_MAX);
            }
            else {  /* Non-locale EXACTFish */
                EXACTF_invlist = add_cp_to_invlist(EXACTF_invlist, uc);
                if (flags & SCF_DO_STCLASS_AND) {
                    ssc_clear_locale(data->start_class);
                }
                if (uc < 256) { /* We know what the Latin1 folds are ... */
                    if (IS_IN_SOME_FOLD_L1(uc)) {   /* For instance, we
                                                       know if anything folds
                                                       with this */
                        EXACTF_invlist = add_cp_to_invlist(EXACTF_invlist,
                                                           PL_fold_latin1[uc]);
                        if (OP(scan) != EXACTFA) { /* The folds below aren't
                                                      legal under /iaa */
                            if (isARG2_lower_or_UPPER_ARG1('s', uc)) {
                                EXACTF_invlist
                                    = add_cp_to_invlist(EXACTF_invlist,
                                                LATIN_SMALL_LETTER_SHARP_S);
                            }
                            else if (uc == LATIN_SMALL_LETTER_SHARP_S) {
                                EXACTF_invlist
                                    = add_cp_to_invlist(EXACTF_invlist, 's');
                                EXACTF_invlist
                                    = add_cp_to_invlist(EXACTF_invlist, 'S');
                            }
                        }

                        /* We also know if there are above-Latin1 code points
                         * that fold to this (none legal for ASCII and /iaa) */
                        if ((! isASCII(uc) || OP(scan) != EXACTFA)
                            && HAS_NONLATIN1_FOLD_CLOSURE(uc))
                        {
                            /* XXX We could know exactly what does fold to this
                             * if the reverse folds are loaded, as currently in
                             * S_regclass() */
                            _invlist_union(EXACTF_invlist,
                                           PL_AboveLatin1,
                                           &EXACTF_invlist);
                        }
                    }
                }
                else {  /* Non-locale, above Latin1.  XXX We don't currently
                           know what participates in folds with this, so have
                           to assume anything could */

                    /* XXX We could know exactly what does fold to this if the
                     * reverse folds are loaded, as currently in S_regclass().
                     * But we do know that under /iaa nothing in the ASCII
                     * range can participate */
                    if (OP(scan) == EXACTFA) {
                        _invlist_union_complement_2nd(EXACTF_invlist,
                                                      PL_XPosix_ptrs[_CC_ASCII],
                                                      &EXACTF_invlist);
                    }
                    else {
                        EXACTF_invlist = _add_range_to_invlist(EXACTF_invlist,
                                                               0, UV_MAX);
                    }
                }
            }
	    if (flags & SCF_DO_STCLASS_AND) {
                ANYOF_FLAGS(data->start_class) &= ~ANYOF_EMPTY_STRING;
                ANYOF_POSIXL_ZERO(data->start_class);
                ssc_intersection(data->start_class, EXACTF_invlist, FALSE);
d3727 30
a3756 5
                ssc_union(data->start_class, EXACTF_invlist, FALSE);
		ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);

                /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a */
                ANYOF_FLAGS(data->start_class) &= ~ANYOF_EMPTY_STRING;
a3758 1
            SvREFCNT_dec(EXACTF_invlist);
d3761 2
a3762 2
	    SSize_t mincount, maxcount, minnext, deltanext, pos_before = 0;
	    I32 fl = 0, f = flags;
d3764 2
a3765 2
	    regnode_ssc this_class;
	    regnode_ssc *oclass = NULL;
d3795 2
d3798 1
a3798 2
                    scan_commit(pRExC_state, data, minlenp, is_inf);
                    /* Cannot extend fixed substrings */
a3800 2
                is_inf = is_inf_internal = 1;
                scan = regnext(scan);
d3821 1
a3821 3
                    if (mincount == 0)
                        scan_commit(pRExC_state, data, minlenp, is_inf);
                    /* Cannot extend fixed substrings */
d3831 1
a3831 1
		    ssc_init(pRExC_state, &this_class);
d3850 4
a3853 6
		minnext = study_chunk(pRExC_state, &scan, minlenp, &deltanext,
                                  last, data, stopparen, recursed_depth, NULL,
                                  (mincount == 0
                                   ? (f & ~SCF_DO_SUBSTR)
                                   : f)
                                  ,depth+1);
d3859 1
a3859 1
			ssc_or(pRExC_state, data->start_class, (regnode_charclass *) &this_class);
d3865 2
a3866 1
			StructCopy(data->start_class, and_withp, regnode_ssc);
d3868 2
a3869 1
			StructCopy(&this_class, data->start_class, regnode_ssc);
d3871 1
a3871 1
                        ANYOF_FLAGS(data->start_class) |= ANYOF_EMPTY_STRING;
d3875 2
a3876 2
			ssc_or(pRExC_state, data->start_class, (regnode_charclass *) &this_class);
			ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);
d3879 1
a3879 1
			ssc_and(pRExC_state, data->start_class, (regnode_charclass *) &this_class);
d3884 2
a3885 3
		if (!(flags & SCF_TRIE_DOING_RESTUDY)
		    /* ? quantifier ok, except for (?{ ... }) */
		    && (next_is_eval || !(mincount == 0 && maxcount == 1))
d3888 1
a3888 2
                    && maxcount <= REG_INFTY/3) /* Complement check for big
                                                   count */
d3893 1
a3893 1
			    "Quantifier unexpected on zero-length expression");
d3898 2
a3899 2
		is_inf_internal |= deltanext == SSize_t_MAX
                         || (maxcount == REG_INFTY && minnext + deltanext > 0);
d3901 5
a3905 6
                if (is_inf) {
		    delta = SSize_t_MAX;
                } else {
		    delta += (minnext + deltanext) * maxcount
                             - minnext * mincount;
                }
d3956 1
a3956 4

                         /* Nor characters whose fold at run-time may be
                          * multi-character */
                      && ! (RExC_seen & REG_UNFOLDED_MULTI_SEEN)
d4003 1
a4003 1
                                    NULL, stopparen, recursed_depth, NULL, 0,depth+1);
a4027 1
                    STRLEN last_chrs = 0;
d4030 18
a4047 3
                    if (data->last_end > 0 && mincount != 0) { /* Ends with a
                                                                  string. */
			SSize_t b = pos_before >= data->last_start_min
d4051 2
a4052 1
			SSize_t old = b - data->last_start_min;
a4058 2
                        last_chrs = UTF ? utf8_length((U8*)(s + old),
                                            (U8*)(s + old + l)) : l;
a4061 1

d4064 1
a4064 2
					  SvPVX_const(last_str), l,
                                          mincount - 1);
d4076 1
a4076 1
					mg->mg_len += last_chrs * (mincount-1);
a4077 1
                                last_chrs *= mincount;
d4083 1
a4083 1
			    data->last_start_max += is_inf ? SSize_t_MAX
d4090 7
a4096 13
PerlIO_printf(Perl_debug_log, "counted=%"UVdf" deltanext=%"UVdf
                              " SSize_t_MAX=%"UVdf" minnext=%"UVdf
                              " maxcount=%"UVdf" mincount=%"UVdf"\n",
    (UV)counted, (UV)deltanext, (UV)SSize_t_MAX, (UV)minnext, (UV)maxcount,
    (UV)mincount);
if (deltanext != SSize_t_MAX)
PerlIO_printf(Perl_debug_log, "LHS=%"UVdf" RHS=%"UVdf"\n",
    (UV)(-counted * deltanext + (minnext + deltanext) * maxcount
          - minnext * mincount), (UV)(SSize_t_MAX - data->pos_delta));
#endif
		    if (deltanext == SSize_t_MAX
                        || -counted * deltanext + (minnext + deltanext) * maxcount - minnext * mincount >= SSize_t_MAX - data->pos_delta)
		        data->pos_delta = SSize_t_MAX;
d4103 1
a4103 1
                        scan_commit(pRExC_state, data, minlenp, is_inf);
d4113 2
a4114 1
			    data->last_start_min = data->pos_min - last_chrs;
d4116 3
a4118 2
				? SSize_t_MAX
				: data->pos_min + data->pos_delta - last_chrs;
d4133 1
a4133 8

	    default:
#ifdef DEBUGGING
                Perl_croak(aTHX_ "panic: unexpected varying REx opcode %d",
                                                                    OP(scan));
#endif
            case REF:
            case CLUMP:
d4135 1
a4135 2
                    /* Cannot expect anything... */
                    scan_commit(pRExC_state, data, minlenp, is_inf);
d4139 2
a4140 10
		if (flags & SCF_DO_STCLASS_OR) {
                    if (OP(scan) == CLUMP) {
                        /* Actually is any start char, but very few code points
                         * aren't start characters */
                        ssc_match_all_cp(data->start_class);
                    }
                    else {
                        ssc_anything(data->start_class);
                    }
                }
d4147 2
d4150 8
a4157 14
                    ssc_intersection(data->start_class,
                                    PL_XPosix_ptrs[_CC_VERTSPACE], FALSE);
                    ssc_clear_locale(data->start_class);
                    ANYOF_FLAGS(data->start_class) &= ~ANYOF_EMPTY_STRING;
                }
                else if (flags & SCF_DO_STCLASS_OR) {
                    ssc_union(data->start_class,
                              PL_XPosix_ptrs[_CC_VERTSPACE],
                              FALSE);
		    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);

                    /* See commit msg for
                     * 749e076fceedeb708a624933726e7989f2302f6a */
                    ANYOF_FLAGS(data->start_class) &= ~ANYOF_EMPTY_STRING;
d4159 2
d4166 1
a4166 2
                /* Cannot expect anything... */
                scan_commit(pRExC_state, data, minlenp, is_inf);
d4173 1
d4176 1
a4176 1
                scan_commit(pRExC_state, data, minlenp, is_inf);
d4181 2
a4182 6
                bool invert = 0;
                SV* my_invlist = sv_2mortal(_new_invlist(0));
                U8 namedclass;

                /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a */
                ANYOF_FLAGS(data->start_class) &= ~ANYOF_EMPTY_STRING;
d4186 2
a4187 1
		switch (OP(scan)) {
d4189 1
d4192 1
a4192 2
                   Perl_croak(aTHX_ "panic: unexpected simple REx opcode %d",
                                                                     OP(scan));
d4194 1
a4194 2
		case CANY:
		case SANY:
d4196 1
a4196 1
			ssc_match_all_cp(data->start_class);
a4197 1

d4199 6
a4204 19
                    {
                        SV* REG_ANY_invlist = _new_invlist(2);
                        REG_ANY_invlist = add_cp_to_invlist(REG_ANY_invlist,
                                                            '\n');
                        if (flags & SCF_DO_STCLASS_OR) {
                            ssc_union(data->start_class,
                                      REG_ANY_invlist,
                                      TRUE /* TRUE => invert, hence all but \n
                                            */
                                      );
                        }
                        else if (flags & SCF_DO_STCLASS_AND) {
                            ssc_intersection(data->start_class,
                                             REG_ANY_invlist,
                                             TRUE  /* TRUE => invert */
                                             );
                            ssc_clear_locale(data->start_class);
                        }
                        SvREFCNT_dec_NN(REG_ANY_invlist);
d4206 2
d4209 1
a4209 2

                case ANYOF:
d4211 2
a4212 2
			ssc_and(pRExC_state, data->start_class,
                                (regnode_charclass *) scan);
d4214 2
a4215 2
			ssc_or(pRExC_state, data->start_class,
                                                          (regnode_charclass *) scan);
d4217 2
a4218 3

		case NPOSIXL:
                    invert = 1;
a4219 1

d4221 16
a4236 8
                    namedclass = classnum_to_namedclass(FLAGS(scan)) + invert;
                    if (flags & SCF_DO_STCLASS_AND) {
                        bool was_there = cBOOL(
                                          ANYOF_POSIXL_TEST(data->start_class,
                                                                 namedclass));
                        ANYOF_POSIXL_ZERO(data->start_class);
                        if (was_there) {    /* Do an AND */
                            ANYOF_POSIXL_SET(data->start_class, namedclass);
d4238 1
a4238 6
                        /* No individual code points can now match */
                        data->start_class->invlist
                                                = sv_2mortal(_new_invlist(0));
                    }
                    else {
                        int complement = namedclass + ((invert) ? -1 : 1);
d4240 7
a4246 11
                        assert(flags & SCF_DO_STCLASS_OR);

                        /* If the complement of this class was already there,
                         * the result is that they match all code points,
                         * (\d + \D == everything).  Remove the classes from
                         * future consideration.  Locale is not relevant in
                         * this case */
                        if (ANYOF_POSIXL_TEST(data->start_class, complement)) {
                            ssc_match_all_cp(data->start_class);
                            ANYOF_POSIXL_CLEAR(data->start_class, namedclass);
                            ANYOF_POSIXL_CLEAR(data->start_class, complement);
a4247 3
                        else {  /* The usual case; just add this class to the
                                   existing set */
                            ANYOF_POSIXL_SET(data->start_class, namedclass);
d4249 4
a4252 6
                    }
                    break;

                case NPOSIXA:   /* For these, we always know the exact set of
                                   what's matched */
                    invert = 1;
d4254 2
a4255 11
		case POSIXA:
                    if (FLAGS(scan) == _CC_ASCII) {
                        my_invlist = PL_XPosix_ptrs[_CC_ASCII];
                    }
                    else {
                        _invlist_intersection(PL_XPosix_ptrs[FLAGS(scan)],
                                              PL_XPosix_ptrs[_CC_ASCII],
                                              &my_invlist);
                    }
                    goto join_posix;

d4257 16
a4272 6
		case NPOSIXU:
                    invert = 1;
                    /* FALL THROUGH */
		case POSIXD:
		case POSIXU:
                    my_invlist = invlist_clone(PL_XPosix_ptrs[FLAGS(scan)]);
d4274 14
a4287 20
                    /* NPOSIXD matches all upper Latin1 code points unless the
                     * target string being matched is UTF-8, which is
                     * unknowable until match time.  Since we are going to
                     * invert, we want to get rid of all of them so that the
                     * inversion will match all */
                    if (OP(scan) == NPOSIXD) {
                        _invlist_subtract(my_invlist, PL_UpperLatin1,
                                          &my_invlist);
                    }

                  join_posix:

                    if (flags & SCF_DO_STCLASS_AND) {
                        ssc_intersection(data->start_class, my_invlist, invert);
                        ssc_clear_locale(data->start_class);
                    }
                    else {
                        assert(flags & SCF_DO_STCLASS_OR);
                        ssc_union(data->start_class, my_invlist, invert);
                    }
d4290 1
a4290 1
		    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);
d4298 1
a4298 1
            scan_commit(pRExC_state, data, minlenp, is_inf);
d4317 5
a4321 6
                    regprop(RExC_rx, mysv_val, upto, NULL);
                    PerlIO_printf(Perl_debug_log,
                        "~ replace with OPFAIL pointed at %s (%"IVdf") offset %"IVdf"\n",
                        SvPV_nolen_const(mysv_val),
                        (IV)REG_NODE_NUM(upto),
                        (IV)(upto - scan)
d4331 1
a4331 1
            if ( !PERL_ENABLE_POSITIVE_ASSERTION_STUDY
d4338 1
a4338 1
                SSize_t deltanext, minnext, fake = 0;
d4340 1
a4340 1
                regnode_ssc intrnl;
d4353 1
a4353 1
                    ssc_init(pRExC_state, &intrnl);
d4361 2
a4362 3
                minnext = study_chunk(pRExC_state, &nscan, minlenp, &deltanext,
                                      last, &data_fake, stopparen,
                                      recursed_depth, NULL, f, depth+1);
d4368 1
a4368 2
			FAIL2("Lookbehind longer than %"UVuf" not implemented",
                              (UV)U8_MAX);
d4387 1
a4387 1
			ssc_init(pRExC_state, data->start_class);
d4389 6
a4394 5
                        /* AND before and after: combine and continue.  These
                         * assertions are zero-length, so can match an EMPTY
                         * string */
			ssc_and(pRExC_state, data->start_class, (regnode_charclass *) &intrnl);
                        ANYOF_FLAGS(data->start_class) |= ANYOF_EMPTY_STRING;
d4407 1
a4407 1
                SSize_t deltanext, fake = 0;
d4409 1
a4409 1
                regnode_ssc intrnl;
d4411 2
a4412 2
                /* We use SAVEFREEPV so that when the full compile
                    is finished perl will clean up the allocated
d4417 2
a4418 2
                SSize_t *minnextp;
                Newx( minnextp, 1, SSize_t );
d4425 2
a4426 2
                        if (scan->flags)
                            scan_commit(pRExC_state, &data_fake, minlenp, is_inf);
d4438 1
a4438 1
                    ssc_init(pRExC_state, &intrnl);
d4447 2
a4448 4
                *minnextp = study_chunk(pRExC_state, &nscan, minnextp,
                                        &deltanext, last, &data_fake,
                                        stopparen, recursed_depth, NULL,
                                        f,depth+1);
d4454 1
a4454 2
			FAIL2("Lookbehind longer than %"UVuf" not implemented",
                              (UV)U8_MAX);
d4462 5
a4466 2
                    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) &intrnl);
                    ANYOF_FLAGS(data->start_class) |= ANYOF_EMPTY_STRING;
d4477 1
a4477 1
                        scan_commit(pRExC_state, &data_fake, minnextp, is_inf);
d4479 2
a4480 2

                        if ( data_fake.minlen_fixed != minlenp )
d4521 1
a4521 1
                scan_commit(pRExC_state, data, minlenp, is_inf);
d4533 1
a4533 1
                    scan_commit(pRExC_state, data, minlenp, is_inf);
d4538 1
a4538 1
		    ssc_anything(data->start_class);
d4542 2
a4543 2
            if (!(RExC_rx->intflags & PREGf_GPOS_FLOAT) &&
	        !(delta || is_inf || (data && data->pos_delta)))
d4545 3
a4547 3
                if (!(RExC_rx->intflags & PREGf_ANCH) && (flags & SCF_DO_SUBSTR))
                    RExC_rx->intflags |= PREGf_ANCH_GPOS;
	        if (RExC_rx->gofs < (STRLEN)min)
d4550 1
a4550 1
                RExC_rx->intflags |= PREGf_GPOS_FLOAT;
d4552 1
a4552 1
            }
d4563 2
a4564 2
            SSize_t max1 = 0, min1 = SSize_t_MAX;
            regnode_ssc accum;
d4566 2
a4567 4
            if (flags & SCF_DO_SUBSTR) { /* XXXX Add !SUSPEND? */
                /* Cannot merge strings after this. */
                scan_commit(pRExC_state, data, minlenp, is_inf);
            }
d4569 2
a4570 2
                ssc_init_zero(pRExC_state, &accum);

d4577 2
a4578 2

                for ( word=1 ; word <= trie->wordcount ; word++)
d4580 3
a4582 3
                    SSize_t deltanext=0, minnext=0, f = 0, fake;
                    regnode_ssc this_class;

d4592 1
a4592 1
                        ssc_init(pRExC_state, &this_class);
d4598 1
a4598 1

d4604 6
a4609 5
                           it. Note this means we need the vestigal unused
                           branches even though they arent otherwise used. */
                        minnext = study_chunk(pRExC_state, &scan, minlenp,
                            &deltanext, (regnode *)nextbranch, &data_fake,
                            stopparen, recursed_depth, NULL, f,depth+1);
d4613 2
a4614 2

                    if (min1 > (SSize_t)(minnext + trie->minlen))
d4616 1
a4616 1
                    if (deltanext == SSize_t_MAX) {
d4618 2
a4619 2
                        max1 = SSize_t_MAX;
                    } else if (max1 < (SSize_t)(minnext + deltanext + trie->maxlen))
d4621 1
a4621 1

d4625 1
a4625 1
                        if ( stopmin > min + min1)
d4637 1
a4637 1
                        ssc_or(pRExC_state, &accum, (regnode_charclass *) &this_class);
d4649 1
a4649 1
                ssc_or(pRExC_state, data->start_class, (regnode_charclass *) &accum);
d4651 1
a4651 1
                    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);
d4657 1
a4657 1
                    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) &accum);
d4664 2
a4665 1
                    StructCopy(data->start_class, and_withp, regnode_ssc);
d4667 2
a4668 1
                    StructCopy(&accum, data->start_class, regnode_ssc);
d4670 1
d4680 1
a4680 1

d4685 1
a4685 2
                /* Cannot expect anything... */
                scan_commit(pRExC_state, data, minlenp, is_inf);
d4692 1
a4692 1
               flags &= ~SCF_DO_SUBSTR;
a4699 8
    /* If we are exiting a recursion we can unset its recursed bit
     * and allow ourselves to enter it again - no danger of an
     * infinite loop there.
    if (stopparen > -1 && recursed) {
	DEBUG_STUDYDATA("unset:", data,depth);
        PAREN_UNSET( recursed, stopparen);
    }
    */
a4700 3
        DEBUG_STUDYDATA("frame-end:",data,depth);
        DEBUG_PEEP("fend", scan, depth);
        /* restore previous context */
a4703 3
        recursed_depth = frame->prev_recursed_depth;
        depth = depth - 1;

d4713 1
a4713 2
    *deltap = is_inf_internal ? SSize_t_MAX : delta;

d4715 1
a4715 1
	data->pos_delta = SSize_t_MAX - data->pos_min;
d4727 1
a4727 1
	ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);
d4730 1
a4730 1

d4732 2
a4733 10

    {
        SSize_t final_minlen= min < stopmin ? min : stopmin;

        if (!(RExC_seen & REG_UNBOUNDED_QUANTIFIER_SEEN) && (RExC_maxlen < final_minlen + delta)) {
            RExC_maxlen = final_minlen + delta;
        }
        return final_minlen;
    }
    /* not-reached */
d4737 1
a4737 1
S_add_data(RExC_state_t* const pRExC_state, const char* const s, const U32 n)
d4798 1
a4798 1
#endif
d4807 1
a4807 1
#ifndef PERL_IN_XSUB_RE
d4820 1
a4820 1
	if (!table || !(PL_hints & HINT_LOCALIZE_HH))
d4901 3
a4903 2
        if (NATIVE_BYTE_IS_INVARIANT(src[s]))
            dst[d]   = src[s];
d4905 2
a4906 2
            dst[d++] = UTF8_EIGHT_BIT_HI(src[s]);
            dst[d]   = UTF8_EIGHT_BIT_LO(src[s]);
a4969 1
        if (!msv) msv = &PL_sv_undef;
d4988 1
a4988 1
            const SSize_t maxarg = AvFILL(av) + 1;
d4993 1
a4993 1
                    || oplist->op_type == OP_RV2AV);
d4998 1
a4998 1
                SSize_t i;
d5002 1
a5002 1
                for (i=0; i < maxarg; i++) {
d5292 1
a5292 1
		Perl_croak_nocontext("%"SVf, SVfARG(errsv));
d5383 1
a5383 4
S_setup_longest(pTHX_ RExC_state_t *pRExC_state, SV* sv_longest,
                      SV** rx_utf8, SV** rx_substr, SSize_t* rx_end_shift,
		      SSize_t lookbehind, SSize_t offset, SSize_t *minlen,
                      STRLEN longest_length, bool eol, bool meol)
d5389 1
a5389 2
    I32 t;
    SSize_t ml;
d5395 2
a5396 2
            /* See comments for join_exact for why REG_UNFOLDED_MULTI_SEEN */
        || (RExC_seen & REG_UNFOLDED_MULTI_SEEN))
d5414 1
a5414 1
    ml = minlen ? *(minlen) : (SSize_t)longest_length;
d5483 1
a5483 1
    SSize_t minlen = 0;
a5493 2
    I32 sawminmod = 0;

d5500 1
a5500 1
#ifdef TRIE_STUDY_OPT
d5503 1
a5503 1
#endif
d5515 1
d5517 53
a5569 4
	PL_UpperLatin1 = _new_invlist_C_array(UpperLatin1_invlist);
        PL_utf8_foldable = _new_invlist_C_array(_Perl_Any_Folds_invlist);
        PL_HasMultiCharFold =
                       _new_invlist_C_array(_Perl_Folds_To_Multi_Char_invlist);
a5684 1
    RExC_contains_i = 0;
d5706 1
a5706 2
    /* XXX: note in the below we have to check the flags as well as the
     * pattern.
d5708 3
a5710 2
     * Things get a touch tricky as we have to compare the utf8 flag
     * independently from the compile flags.  */
d5727 2
a5728 2
    if (rx_flags & PMf_FOLD) {
        RExC_contains_i = 1;
d5730 1
a5730 1
    if (RExC_utf8 && initial_charset == REGEX_DEPENDS_CHARSET) {
a5757 1
    RExC_maxlen = 0;
d5772 1
a5772 1
    RExC_emit = (regnode *) &RExC_emit_dummy;
a5781 2
    RExC_study_chunk_recursed = NULL;
    RExC_study_chunk_recursed_bytes= 0;
d5819 1
a5819 1
        Perl_croak(aTHX_ "panic: reg returned NULL to re_op_compile for sizing pass, flags=%#"UVxf"", (UV) flags);
d5825 1
a5825 1
        PerlIO_printf(Perl_debug_log,
d5827 1
a5827 1
            "Starting second pass (creation)\n",
d5829 2
a5830 2
        RExC_lastnum=0;
        RExC_lastparse=NULL;
d5849 2
a5850 2
    /* Allocate space and zero-initialize. Note, the two step process
       of zeroing when in debug mode, thus anything assigned has to
d5860 2
a5861 3
    Zero(ri, sizeof(regexp_internal) + (unsigned)RExC_size * sizeof(regnode),
         char);
#else
d5863 1
a5863 1
    Zero(ri, sizeof(regexp_internal), char);
d5887 1
a5887 2
        bool has_charset = (get_regex_charset(r->extflags)
                                                    != REGEX_DEPENDS_CHARSET);
d5894 1
a5894 2
        bool has_runon = ((RExC_seen & REG_RUN_ON_COMMENT_SEEN)
                                                   == REG_RUN_ON_COMMENT_SEEN);
d5955 2
a5956 4

    /* setup various meta data about recursion, this all requires
     * RExC_npar to be correctly set, and a bit later on we clear it */
    if (RExC_seen & REG_RECURSE_SEEN) {
a5961 9
    if (RExC_seen & (REG_RECURSE_SEEN | REG_GOSTART_SEEN)) {
        /* Note, RExC_npar is 1 + the number of parens in a pattern.
         * So its 1 if there are no parens. */
        RExC_study_chunk_recursed_bytes= (RExC_npar >> 3) +
                                         ((RExC_npar & 0x07) != 0);
        Newx(RExC_study_chunk_recursed,
             RExC_study_chunk_recursed_bytes * RExC_npar, U8);
        SAVEFREEPV(RExC_study_chunk_recursed);
    }
d5990 2
a5991 2
	ReREFCNT_dec(rx);
        Perl_croak(aTHX_ "panic: reg returned NULL to re_op_compile for generation pass, flags=%#"UVxf"", (UV) flags);
d6002 1
a6002 1
    r->minlen = minlen = sawlookahead = sawplus = sawopen = sawminmod = 0;
a6003 3
    if (RExC_study_chunk_recursed)
        Zero(RExC_study_chunk_recursed,
             RExC_study_chunk_recursed_bytes * RExC_npar, U8);
d6012 1
a6012 1

d6014 2
a6015 2
        if (seen & REG_TOP_LEVEL_BRANCHES_SEEN)
            RExC_seen |= REG_TOP_LEVEL_BRANCHES_SEEN;
d6017 1
a6017 1
            RExC_seen &= ~REG_TOP_LEVEL_BRANCHES_SEEN;
d6022 1
a6022 1
#endif
d6027 1
a6027 1

d6037 2
a6038 3
    if (!(RExC_seen & REG_TOP_LEVEL_BRANCHES_SEEN)) { /*  Only one top-level choice.
                                                  */
	SSize_t fake;
d6040 1
a6040 1
	regnode_ssc ch_class; /* pointed to by data */
d6042 1
a6042 1
	SSize_t last_close = 0; /* pointed to by data */
d6047 1
a6047 1
	 * so that we can extract the 'meat' of the pattern that must
d6050 1
a6050 1
	 * picked up by the optimiser separately.
d6067 1
a6067 1
		/*
a6070 1
                 * (yves doesn't think this is true)
d6074 1
a6074 3
                else {
                    if (OP(first) == MINMOD)
                        sawminmod = 1;
d6076 1
a6076 1
                }
d6093 1
a6093 1
	        ((reg_trie_data *)ri->data->data[ ARG(first) ])->minlen>0)
d6119 2
a6120 2
            r->intflags |= (OP(first) == MBOL
                           ? PREGf_ANCH_MBOL
d6122 2
a6123 2
                              ? PREGf_ANCH_SBOL
                              : PREGf_ANCH_BOL));
d6128 1
a6128 1
            r->intflags |= PREGf_ANCH_GPOS;
d6135 1
a6135 1
            !(r->intflags & PREGf_ANCH) && !pRExC_state->num_code_blocks)
d6140 4
a6143 3
                    ? PREGf_ANCH_MBOL
                    : PREGf_ANCH_SBOL;
            r->intflags |= (type | PREGf_IMPLICIT);
d6147 1
a6147 2
        if (sawplus && !sawminmod && !sawlookahead
            && (!sawopen || !RExC_sawback)
d6189 1
a6189 1
	    ssc_init(pRExC_state, &ch_class);
d6195 4
a6198 8

        DEBUG_RExC_seen();
	minlen = study_chunk(pRExC_state, &first, &minlen, &fake,
                             scan + RExC_size, /* Up to end */
            &data, -1, 0, NULL,
            SCF_DO_SUBSTR | SCF_WHILEM_VISITED_POS | stclass_flag
                          | (restudied ? SCF_TRIE_DOING_RESTUDY : 0),
            0);
d6207 2
a6208 3
             && !(RExC_seen & REG_VERBARG_SEEN)
             && !(RExC_seen & REG_GPOS_SEEN)
        ){
a6209 1
        }
d6231 1
a6231 1
	    if (data.offset_float_max < SSize_t_MAX) /* Don't offset infinity */
d6269 2
a6270 2
            && ! (ANYOF_FLAGS(data.start_class) & ANYOF_EMPTY_STRING)
	    && !ssc_is_anything(data.start_class))
d6272 2
a6273 3
	    const U32 n = add_data(pRExC_state, STR_WITH_LEN("f"));

            ssc_finalize(pRExC_state, data.start_class);
d6275 2
a6276 1
	    Newx(RExC_rxi->data->data[n], 1, regnode_ssc);
d6278 2
a6279 2
		       (regnode_ssc*)RExC_rxi->data->data[n],
		       regnode_ssc);
d6283 1
a6283 1
	              regprop(r, sv, (regnode*)data.start_class, NULL);
a6286 1
            data.start_class = NULL;
d6289 1
a6289 2
        /* A temporary algorithm prefers floated substr to fixed one to dig
         * more info. */
a6290 1
	    r->substrs->check_ix = 0;
d6295 2
a6296 2
            if (r->intflags & (PREGf_ANCH_SBOL|PREGf_ANCH_GPOS))
                r->intflags |= PREGf_NOSCAN;
a6298 1
	    r->substrs->check_ix = 1;
d6305 3
a6307 1
	if ((r->check_substr || r->check_utf8) ) {
a6311 2
        r->substrs->data[0].max_offset = r->substrs->data[0].min_offset;

d6316 1
a6316 1
            minlen= longest_fixed_length;
d6321 3
a6323 3
	SSize_t fake;
	regnode_ssc ch_class;
	SSize_t last_close = 0;
d6328 1
a6328 1
	ssc_init(pRExC_state, &ch_class);
d6332 4
a6335 8
        DEBUG_RExC_seen();
	minlen = study_chunk(pRExC_state,
            &scan, &minlen, &fake, scan + RExC_size, &data, -1, 0, NULL,
            SCF_DO_STCLASS_AND|SCF_WHILEM_VISITED_POS|(restudied
                                                      ? SCF_TRIE_DOING_RESTUDY
                                                      : 0),
            0);

d6341 5
a6345 4
        if (! (ANYOF_FLAGS(data.start_class) & ANYOF_EMPTY_STRING)
            && ! ssc_is_anything(data.start_class))
        {
	    const U32 n = add_data(pRExC_state, STR_WITH_LEN("f"));
d6347 2
a6348 3
            ssc_finalize(pRExC_state, data.start_class);

	    Newx(RExC_rxi->data->data[n], 1, regnode_ssc);
d6350 2
a6351 2
		       (regnode_ssc*)RExC_rxi->data->data[n],
		       regnode_ssc);
d6355 1
a6355 1
	              regprop(r, sv, (regnode*)data.start_class, NULL);
a6358 1
            data.start_class = NULL;
a6361 8
    if (RExC_seen & REG_UNBOUNDED_QUANTIFIER_SEEN) {
        r->extflags |= RXf_UNBOUNDED_QUANTIFIER_SEEN;
        r->maxlen = REG_INFTY;
    }
    else {
        r->maxlen = RExC_maxlen;
    }

d6365 2
a6366 2
        PerlIO_printf(Perl_debug_log,"minlen: %"IVdf" r->minlen:%"IVdf" maxlen:%ld\n",
                      (IV)minlen, (IV)r->minlen, RExC_maxlen);
d6369 1
a6369 1
    if (r->minlen < minlen)
d6371 5
a6375 6

    if (RExC_seen & REG_GPOS_SEEN)
        r->intflags |= PREGf_GPOS_SEEN;
    if (RExC_seen & REG_LOOKBEHIND_SEEN)
        r->extflags |= RXf_NO_INPLACE_SUBST; /* inplace might break the
                                                lookbehind */
d6378 3
a6380 3
    if (RExC_seen & REG_CANY_SEEN)
        r->intflags |= PREGf_CANY_SEEN;
    if (RExC_seen & REG_VERBARG_SEEN)
d6385 1
a6385 1
    if (RExC_seen & REG_CUTGROUP_SEEN)
a6393 6
    /* If we have seen an anchor in our pattern then we set the extflag RXf_IS_ANCHORED
     * so it can be used in pp.c */
    if (r->intflags & PREGf_ANCH)
        r->extflags |= RXf_IS_ANCHORED;


a6394 7
        /* this is used to identify "special" patterns that might result
         * in Perl NOT calling the regex engine and instead doing the match "itself",
         * particularly special cases in split//. By having the regex compiler
         * do this pattern matching at a regop level (instead of by inspecting the pattern)
         * we avoid weird issues with equivalent patterns resulting in different behavior,
         * AND we allow non Perl engines to get the same optimizations by the setting the
         * flags appropriately - Yves */
d6404 1
a6404 3
        else if (fop == PLUS
                 && PL_regkind[nop] == POSIXD && FLAGS(next) == _CC_SPACE
                 && OP(regnext(first)) == END)
d6406 1
a6406 5
        else if ( r->extflags & RXf_SPLIT
                  && fop == EXACT
                  && STR_LEN(first) == 1
                  && *(STRING(first)) == ' '
                  && OP(regnext(first)) == END )
a6409 5

    if (RExC_contains_locale) {
        RXp_EXTFLAGS(r) |= RXf_TAINTED;
    }

d6412 2
a6413 3
        ri->name_list_idx = add_data( pRExC_state, STR_WITH_LEN("a"));
        ri->data->data[ri->name_list_idx]
                                   = (void*)SvREFCNT_inc(RExC_paren_name_list);
a6427 1
        DEBUG_RExC_seen();
d6433 2
a6434 2
        const STRLEN len = ri->u.offsets[0];
        STRLEN i;
d6436 1
a6436 2
        PerlIO_printf(Perl_debug_log,
                      "Offsets: [%"UVuf"]\n\t", (UV)ri->u.offsets[0]);
d6496 1
a6496 2
        Perl_croak(aTHX_ "panic: Unknown flags %d in named_buff_iter",
                                            (int)flags);
d6622 1
a6622 1
    SSize_t length;
d6633 1
a6633 1
            length = av_tindex(av);
d6637 1
a6637 2
            Perl_croak(aTHX_ "panic: Unknown flags %d in named_buff_scalar",
                                                (int)flags);
d6685 2
a6686 2
    SSize_t i = 0;
    SSize_t s1, t1;
d6690 1
a6690 1

d6723 1
a6723 1
    else
d6730 1
a6730 1
    }
d6741 1
a6741 1
    }
d6744 1
a6744 1
    assert((STRLEN)rx->sublen >= (STRLEN)((s - rx->subbeg) + i) );
d6746 1
a6746 1
#ifdef NO_TAINT_SUPPORT
d6754 1
a6754 1
        if ( (rx->intflags & PREGf_CANY_SEEN)
d6779 1
a6779 1
            } else
d6914 1
a6914 3
    assert (RExC_parse <= RExC_end);
    if (RExC_parse == RExC_end) NOOP;
    else if (isIDFIRST_lazy_if(RExC_parse, UTF)) {
d6925 1
a6925 2
        RExC_parse++; /* so the <- from the vFAIL is after the offending
                         character */
d7005 5
a7009 6
 * as an SVt_INVLIST scalar.
 *
 * An inversion list for Unicode is an array of code points, sorted by ordinal
 * number.  The zeroth element is the first code point in the list.  The 1th
 * element is the first element beyond that not in the list.  In other words,
 * the first range is
d7027 3
a7029 3
 * list to always contain 0; there is an additional flag in the header which
 * indicates if the list begins at the 0, or is offset to begin at the next
 * element.
d7044 4
d7054 5
a7058 5
     * array begins depends on whether the list has the code point U+0000 in it
     * or not.  The other parameter tells it whether the code that follows this
     * call is about to put a 0 in the inversion list or not.  The first
     * element is either the element reserved for 0, if TRUE, or the element
     * after it, if FALSE */
d7060 1
a7060 2
    bool* offset = get_invlist_offset_addr(invlist);
    UV* zero_addr = (UV *) SvPVX(invlist);
d7065 1
a7065 3
    assert(! _invlist_len(invlist));

    *zero_addr = 0;
d7068 2
a7069 2
    *offset = 1 ^ will_have_0;
    return zero_addr + *offset;
d7083 9
a7091 8
    assert(_invlist_len(invlist));

    /* The very first element always contains zero, The array begins either
     * there, or if the inversion list is offset, at the element after it.
     * The offset header field determines which; it contains 0 or 1 to indicate
     * how much additionally to add */
    assert(0 == *(SvPVX(invlist)));
    return ((UV *) SvPVX(invlist) + *get_invlist_offset_addr(invlist));
d7095 1
a7095 1
S_invlist_set_len(pTHX_ SV* const invlist, const UV len, const bool offset)
d7097 1
a7097 2
    /* Sets the current number of elements stored in the inversion list.
     * Updates SvCUR correspondingly */
d7101 1
a7101 1
    assert(SvTYPE(invlist) == SVt_INVLIST);
d7103 16
a7118 5
    SvCUR_set(invlist,
              (len == 0)
               ? 0
               : TO_INTERNAL_SIZE(len + offset));
    assert(SvLEN(invlist) == 0 || SvCUR(invlist) <= SvLEN(invlist));
d7124 1
a7124 1
    /* Return the address of the IV that is reserved to hold the cached index
d7129 1
a7129 3
    assert(SvTYPE(invlist) == SVt_INVLIST);

    return &(((XINVLIST*) SvANY(invlist))->prev_index);
a7161 4
    assert(SvTYPE(invlist) == SVt_INVLIST);

    /* Assumes worst case, in which the 0 element is not counted in the
     * inversion list, so subtracts 1 for that */
d7163 2
a7164 2
           ? FROM_INTERNAL_SIZE(SvCUR(invlist)) - 1
           : FROM_INTERNAL_SIZE(SvLEN(invlist)) - 1;
d7167 16
a7182 3
#ifndef PERL_IN_XSUB_RE
SV*
Perl__new_invlist(pTHX_ IV initial_size)
d7192 1
a7192 1
	initial_size = 10;
d7196 2
a7197 1
    new_list = newSV_type(SVt_INVLIST);
d7199 2
a7200 4
    /* First 1 is in case the zero element isn't in the list; second 1 is for
     * trailing NUL */
    SvGROW(new_list, TO_INTERNAL_SIZE(initial_size + 1) + 1);
    invlist_set_len(new_list, 0, 0);
d7202 3
a7204 2
    /* Force iterinit() to be used to get iteration to work */
    *get_invlist_iter_addr(new_list) = (STRLEN) UV_MAX;
d7207 4
d7214 1
d7216 2
a7217 2
SV*
Perl__new_invlist_C_array(pTHX_ const UV* const list)
d7222 1
a7222 17
     * should not be used in the wrong hands.  The passed in 'list' contains
     * several header fields at the beginning that are not part of the
     * inversion list body proper */

    const STRLEN length = (STRLEN) list[0];
    const UV version_id =          list[1];
    const bool offset   =    cBOOL(list[2]);
#define HEADER_LENGTH 3
    /* If any of the above changes in any way, you must change HEADER_LENGTH
     * (if appropriate) and regenerate INVLIST_VERSION_ID by running
     *      perl -E 'say int(rand 2**31-1)'
     */
#define INVLIST_VERSION_ID 148565664 /* This is a combination of a version and
                                        data structure type, so that one being
                                        passed in can be validated to be an
                                        inversion list of the correct vintage.
                                       */
d7224 1
a7224 1
    SV* invlist = newSV_type(SVt_INVLIST);
d7228 1
a7228 8
    if (version_id != INVLIST_VERSION_ID) {
        Perl_croak(aTHX_ "panic: Incorrect version for previously generated inversion list");
    }

    /* The generated array passed in includes header elements that aren't part
     * of the list proper, so start it just after them */
    SvPV_set(invlist, (char *) (list + HEADER_LENGTH));

d7231 1
d7233 3
a7235 6
    *(get_invlist_offset_addr(invlist)) = offset;

    /* The 'length' passed to us is the physical number of elements in the
     * inversion list.  But if there is an offset the logical number is one
     * less than that */
    invlist_set_len(invlist, length  - offset, offset);
d7237 5
a7241 3
    invlist_set_previous_index(invlist, 0);

    /* Initialize the iteration pointer. */
a7243 2
    SvREADONLY_on(invlist);

a7245 1
#endif /* ifndef PERL_IN_XSUB_RE */
d7254 1
a7254 5
    assert(SvTYPE(invlist) == SVt_INVLIST);

    /* Add one to account for the zero element at the beginning which may not
     * be counted by the calling parameters */
    SvGROW((SV *)invlist, TO_INTERNAL_SIZE(new_max + 1));
a7261 2
    assert(SvTYPE(invlist) == SVt_INVLIST);

d7264 1
d7268 2
d7271 1
a7271 2
S__append_range_to_invlist(pTHX_ SV* const invlist,
                                 const UV start, const UV end)
a7279 1
    bool offset;
d7284 1
a7284 2
        offset = start != 0;
        array = _invlist_array_init(invlist, ! offset);
d7299 2
a7300 2
		     array[final_element], start,
		     ELEMENT_RANGE_MATCHES_INVLIST(final_element) ? 't' : 'f');
a7306 1
        offset = *get_invlist_offset_addr(invlist);
d7314 1
a7314 1
		invlist_set_len(invlist, len - 1, offset);
d7324 2
a7325 2
    /* If wll overflow the existing space, extend, which may cause the array to
     * be moved */
d7328 2
a7329 4

        /* Have to set len here to avoid assert failure in invlist_array() */
        invlist_set_len(invlist, len, offset);

d7333 1
a7333 1
	invlist_set_len(invlist, len, offset);
d7345 1
a7345 1
	invlist_set_len(invlist, len - 1, offset);
d7440 1
a7440 2
Perl__invlist_populate_swatch(pTHX_ SV* const invlist,
                                    const UV start, const UV end, U8* swatch)
d7533 1
a7533 2
Perl__invlist_union_maybe_complement_2nd(pTHX_ SV* const a, SV* const b,
                                         const bool complement_b, SV** output)
d7537 4
a7540 5
     * the reference count to that list will be decremented if not already a
     * temporary (mortal); otherwise *output will be made correspondingly
     * mortal.  The first list, <a>, may be NULL, in which case a copy of the
     * second list is returned.  If <complement_b> is TRUE, the union is taken
     * of the complement (inversion) of <b> instead of b itself.
d7555 2
a7556 2
    const UV* array_a;    /* a's array */
    const UV* array_b;
a7580 2
        bool make_temp = FALSE; /* Should we mortalize the result? */

d7583 1
a7583 3
                if (! (make_temp = cBOOL(SvTEMP(a)))) {
                    SvREFCNT_dec_NN(a);
                }
a7591 4

        if (make_temp) {
            sv_2mortal(*output);
        }
a7594 1
        bool make_temp = FALSE;
d7596 1
a7596 3
            if (! (make_temp = cBOOL(SvTEMP(b)))) {
                SvREFCNT_dec_NN(b);
            }
d7603 1
a7603 3
                if (! (make_temp = cBOOL(SvTEMP(a)))) {
                    SvREFCNT_dec_NN(a);
                }
a7611 4

        if (make_temp) {
            sv_2mortal(*output);
        }
d7624 2
a7625 1
	 * do this, we just pretend the array starts one later */
d7629 1
d7633 5
a7637 2
            /* But if the first element is not zero, we pretend the list starts
             * at the 0 that is always stored immediately before the array. */
d7640 1
d7736 1
a7736 1
	invlist_set_len(u, len_u, *get_invlist_offset_addr(u));
d7757 6
a7762 3
    /*  We may be removing a reference to one of the inputs.  If so, the output
     *  is made mortal if the input was.  (Mortal SVs shouldn't have their ref
     *  count decremented) */
d7765 1
a7765 6
        if ((SvTEMP(*output))) {
            sv_2mortal(u);
        }
        else {
            SvREFCNT_dec_NN(*output);
        }
a7768 1

d7773 1
a7773 2
Perl__invlist_intersection_maybe_complement_2nd(pTHX_ SV* const a, SV* const b,
                                               const bool complement_b, SV** i)
d7777 3
a7779 6
     * the reference count to that list will be decremented if not already a
     * temporary (mortal); otherwise *i will be made correspondingly mortal.
     * The first list, <a>, may be NULL, in which case an empty list is
     * returned.  If <complement_b> is TRUE, the result will be the
     * intersection of <a> and the complement (or inversion) of <b> instead of
     * <b> directly.
d7790 2
a7791 2
    const UV* array_a;		/* a's array */
    const UV* array_b;
d7815 1
a7815 1
    len_a = (a == NULL) ? 0 : _invlist_len(a);
a7816 1
        bool make_temp = FALSE;
d7825 2
d7828 1
a7828 3
                    if (! (make_temp = cBOOL(SvTEMP(b)))) {
                        SvREFCNT_dec_NN(b);
                    }
a7829 2

                *i = invlist_clone(a);
a7831 4

            if (make_temp) {
                sv_2mortal(*i);
            }
d7838 1
a7838 3
            if (! (make_temp = cBOOL(SvTEMP(a)))) {
                SvREFCNT_dec_NN(a);
            }
d7841 1
a7841 3
            if (! (make_temp = cBOOL(SvTEMP(b)))) {
                SvREFCNT_dec_NN(b);
            }
a7843 4
        if (make_temp) {
            sv_2mortal(*i);
        }

d7856 2
a7857 1
	 * do this, we just pretend the array starts one later */
d7861 1
d7865 5
a7869 2
            /* But if the first element is not zero, we pretend the list starts
             * at the 0 that is always stored immediately before the array. */
d7872 1
d7954 1
a7954 2
     * intersection.  At most one of the subexpressions below will be non-zero
     * */
d7963 1
a7963 1
	invlist_set_len(r, len_r, *get_invlist_offset_addr(r));
d7979 6
a7984 3
    /*  We may be removing a reference to one of the inputs.  If so, the output
     *  is made mortal if the input was.  (Mortal SVs shouldn't have their ref
     *  count decremented) */
d7987 1
a7987 6
        if (SvTEMP(*i)) {
            sv_2mortal(r);
        }
        else {
            SvREFCNT_dec_NN(*i);
        }
a7990 1

a8036 29
SV*
Perl__setup_canned_invlist(pTHX_ const STRLEN size, const UV element0,
                                 UV** other_elements_ptr)
{
    /* Create and return an inversion list whose contents are to be populated
     * by the caller.  The caller gives the number of elements (in 'size') and
     * the very first element ('element0').  This function will set
     * '*other_elements_ptr' to an array of UVs, where the remaining elements
     * are to be placed.
     *
     * Obviously there is some trust involved that the caller will properly
     * fill in the other elements of the array.
     *
     * (The first element needs to be passed in, as the underlying code does
     * things differently depending on whether it is zero or non-zero) */

    SV* invlist = _new_invlist(size);
    bool offset;

    PERL_ARGS_ASSERT__SETUP_CANNED_INVLIST;

    _append_range_to_invlist(invlist, element0, element0);
    offset = *get_invlist_offset_addr(invlist);

    invlist_set_len(invlist, size, offset);
    *other_elements_ptr = invlist_array(invlist) + 1;
    return invlist;
}

d8052 2
d8059 1
a8059 1
    if (_invlist_len(invlist) == 0) {
d8064 9
a8072 1
    *get_invlist_offset_addr(invlist) = ! *get_invlist_offset_addr(invlist);
d8075 37
d8119 1
a8119 1
     * unchanged.  The new list will not be mortal even if the old one was. */
d8124 1
a8124 2
    STRLEN physical_length = SvCUR(invlist);
    bool offset = *(get_invlist_offset_addr(invlist));
d8128 2
a8129 3
    *(get_invlist_offset_addr(new_invlist)) = offset;
    invlist_set_len(new_invlist, _invlist_len(invlist), offset);
    Copy(SvPVX(invlist), SvPVX(new_invlist), physical_length, char);
d8134 1
a8134 1
PERL_STATIC_INLINE STRLEN*
d8142 9
a8150 1
    assert(SvTYPE(invlist) == SVt_INVLIST);
d8152 1
a8152 1
    return &(((XINVLIST*) SvANY(invlist))->iterator);
d8176 1
a8176 1
    *get_invlist_iter_addr(invlist) = (STRLEN) UV_MAX;
d8189 1
a8189 1
    STRLEN* pos = get_invlist_iter_addr(invlist);
d8196 1
a8196 1
	*pos = (STRLEN) UV_MAX;	/* Force iterinit() to be required next time */
d8219 1
a8219 1
    return *(get_invlist_iter_addr(invlist)) < (STRLEN) UV_MAX;
d8285 1
a8285 1
#ifndef PERL_IN_XSUB_RE
d8287 1
a8287 2
Perl__invlist_dump(pTHX_ PerlIO *file, I32 level,
                         const char * const indent, SV* const invlist)
d8289 2
a8290 13
    /* Designed to be called only by do_sv_dump().  Dumps out the ranges of the
     * inversion list 'invlist' to 'file' at 'level'  Each line is prefixed by
     * the string 'indent'.  The output looks like this:
         [0] 0x000A .. 0x000D
         [2] 0x0085
         [4] 0x2028 .. 0x2029
         [6] 0x3104 .. INFINITY
     * This means that the first range of code points matched by the list are
     * 0xA through 0xD; the second range contains only the single code point
     * 0x85, etc.  An inversion list is an array of UVs.  Two array elements
     * are used to define each range (except if the final range extends to
     * infinity, only a single element is needed).  The array index of the
     * first element for the corresponding range is given in brackets. */
a8292 1
    STRLEN count = 0;
d8296 3
d8300 1
a8300 3
        Perl_dump_indent(aTHX_ level, file,
             "%sCan't dump inversion list because is in middle of iterating\n",
             indent);
d8307 1
a8307 3
	    Perl_dump_indent(aTHX_ level, file,
                                       "%s[%"UVuf"] 0x%04"UVXf" .. INFINITY\n",
                                   indent, (UV)count, start);
d8310 2
a8311 3
	    Perl_dump_indent(aTHX_ level, file,
                                    "%s[%"UVuf"] 0x%04"UVXf" .. 0x%04"UVXf"\n",
		                indent, (UV)count, start,         end);
d8314 1
a8314 2
	    Perl_dump_indent(aTHX_ level, file, "%s[%"UVuf"] 0x%04"UVXf"\n",
                                            indent, (UV)count, start);
a8315 1
        count += 2;
d8320 1
a8320 1
#ifdef PERL_ARGS_ASSERT__INVLISTEQ
d8322 1
a8322 1
S__invlistEQ(pTHX_ SV* const a, SV* const b, const bool complement_b)
d8328 2
a8329 2
    const UV* array_a = invlist_array(a);
    const UV* array_b = invlist_array(b);
d8351 2
a8352 1
             * one later */
d8356 1
d8360 5
a8364 2
            /* But if the first element is not zero, we pretend the list starts
             * at the 0 that is always stored immediately before the array. */
d8367 1
d8384 3
d8392 1
d8395 3
d8399 1
d8404 1
a8404 1
S_parse_lparen_question_flags(pTHX_ RExC_state_t *pRExC_state)
d8418 1
a8418 1
#define WASTED_GC (WASTED_G|WASTED_C)
d8464 1
d8518 1
a8518 2
                    vFAIL2("Regexp modifier \"%c\" may not appear twice",
                                        *(RExC_parse - 1));
d8526 1
a8526 2
                vFAIL2("Regexp modifier \"%c\" may not appear after the \"-\"",
                                    *(RExC_parse - 1));
d8531 1
a8531 3
                    const I32 wflagbit = *RExC_parse == 'o'
                                         ? WASTED_O
                                         : WASTED_G;
a8533 1
			/* diag_listed_as: Useless (?-%s) - don't use /%s modifier in regex; marked by <-- HERE in m/%s/ */
a8549 1
			/* diag_listed_as: Useless (?-%s) - don't use /%s modifier in regex; marked by <-- HERE in m/%s/ */
a8581 3
                if (RExC_flags & RXf_PMf_FOLD) {
                    RExC_contains_i = 1;
                }
d8586 3
a8588 4
                RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;
		/* diag_listed_as: Sequence (?%s...) not recognized in regex; marked by <-- HERE in m/%s/ */
                vFAIL2utf8f("Sequence (%"UTF8f"...) not recognized",
                      UTF8fARG(UTF, RExC_parse-seqstart, seqstart));
d8663 1
a8663 2
            int internal_argval = 0; /* internal_argval is only useful if
                                        !argok */
d8679 1
a8679 1
	        while ( *RExC_parse && *RExC_parse != ')' )
d8681 1
a8681 1
	        if ( *RExC_parse != ')' )
d8689 1
a8689 1

d8718 2
a8719 2
            case 'S':   /* (*SKIP) */
                if ( memEQs(start_verb,verb_len,"SKIP") )
d8726 1
a8726 1
                    RExC_seen |= REG_CUTGROUP_SEEN;
d8731 3
a8733 4
	        RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;
                vFAIL2utf8f(
                    "Unknown verb pattern '%"UTF8f"'",
                    UTF8fARG(UTF, verb_len, start_verb));
d8738 1
a8738 1
	                verb_len, start_verb);
d8741 1
a8741 1
	                verb_len, start_verb);
d8746 2
a8747 4
                            SV *sv = newSVpvn( start_arg,
                                               RExC_parse - start_arg);
                            ARG(ret) = add_data( pRExC_state,
                                                 STR_WITH_LEN("S"));
d8751 1
a8751 1
                            ret->flags = 1;
d8753 1
a8753 1
                    }
d8756 1
a8756 1
                    RExC_seen |= REG_VERBARG_SEEN;
d8759 1
a8759 1
	                verb_len, start_verb);
d8765 2
a8766 2
        }
        else if (*RExC_parse == '?') { /* (?...) */
d8786 2
a8787 3
                    /* this pretty much dupes the code for \k<NAME> in
                     * regatom(), if you change this make sure you change that
                     * */
a8792 1
                        /* diag_listed_as: Sequence ?P=... not terminated in regex; marked by <-- HERE in m/%s/ */
d8796 1
a8796 1
                        num = add_data( pRExC_state, STR_WITH_LEN("S"));
d8815 1
a8815 1
                    Set_Node_Cur_Length(ret, parse_start);
d8821 1
a8821 3
                /* diag_listed_as: Sequence (?%s...) not recognized in regex; marked by <-- HERE in m/%s/ */
		vFAIL3("Sequence (%.*s...) not recognized",
                                RExC_parse-seqstart, seqstart);
d8826 1
a8826 1
		else if (*RExC_parse != '=')
d8835 9
a8843 4
                        SIZE_ONLY    /* reverse test from the others */
                        ? REG_RSN_RETURN_NAME
                        : REG_RSN_RETURN_NULL);
		    if (RExC_parse == name_start || *RExC_parse != paren)
d8883 1
a8883 2
                                pv = (I32*)SvGROW(sv_dat,
                                                SvCUR(sv_dat) + sizeof(I32)+1);
d8890 1
a8890 2
                            sv_setpvn(sv_dat, (char *)&(RExC_npar),
                                                                sizeof(I32));
d8895 2
a8896 4
                        /* Yes this does cause a memory leak in debugging Perls
                         * */
                        if (!av_store(RExC_paren_name_list,
                                      RExC_npar, SvREFCNT_inc(svname)))
d8906 1
a8906 1
                RExC_seen |= REG_LOOKBEHIND_SEEN;
d8923 1
a8923 1
	        paren = ':';
a8949 1
                    RExC_seen |= REG_GOSTART_SEEN;
a8963 2
                if (RExC_parse == RExC_end || *RExC_parse != ')')
                    vFAIL("Sequence (?&... not terminated");
d8977 1
a8977 1
                }
d8989 1
a8989 1
	        if (*RExC_parse!=')')
d9023 1
a9023 2
			"Recurse #%"UVuf" to %"IVdf"\n",
                              (UV)ARG(ret), (IV)ARG2L(ret)));
d9027 1
a9027 1
                    RExC_seen |= REG_RECURSE_SEEN;
d9041 1
a9041 4
                    /* diag_listed_as: Sequence (?%s...) not recognized in regex; marked by <-- HERE in m/%s/ */
                    vFAIL2utf8f(
                        "Sequence (%"UTF8f"...) not recognized",
                        UTF8fARG(UTF, RExC_parse-seqstart, seqstart));
d9070 1
a9070 1
			n = add_data(pRExC_state, STR_WITH_LEN("rl"));
d9076 2
a9077 2
			n = add_data(pRExC_state,
			       (RExC_pm_flags & PMf_HAS_CV) ? "L" : "l", 1);
d9115 1
a9115 1

d9138 1
a9138 1
                        num = add_data( pRExC_state, STR_WITH_LEN("S"));
d9168 1
a9168 3
                            SIZE_ONLY
                            ? REG_RSN_RETURN_NULL
                            : REG_RSN_RETURN_DATA);
d9171 1
a9171 1
		    ret = reganode(pRExC_state,INSUBP,parno);
a9176 1
		    char *tmp;
d9184 1
a9184 6
		    if (*(tmp = nextchar(pRExC_state)) != ')') {
                        /* nextchar also skips comments, so undo its work
                         * and skip over the the next character.
                         */
                        RExC_parse = tmp;
                        RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;
a9185 1
		    }
d9194 2
a9195 2
                        FAIL2("panic: regbranch returned NULL, flags=%#"UVxf"",
                              (UV) flags);
d9197 1
a9197 2
                        REGTAIL(pRExC_state, br, reganode(pRExC_state,
                                                          LONGJMP, 0));
d9202 1
a9202 1
		        if (is_define)
d9204 1
a9204 4

                        /* Fake one for optimizer.  */
                        lastbr = reganode(pRExC_state, IFTHEN, 0);

d9210 2
a9211 2
                            FAIL2("panic: regbranch returned NULL, flags=%#"UVxf"",
                                  (UV) flags);
d9236 1
a9236 2
                    RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;
                    vFAIL("Unknown switch condition (?(...))");
d9265 1
a9265 1

d9268 1
a9268 1
	        if (!RExC_nestroot)
d9270 1
a9270 1
                if (RExC_seen & REG_RECURSE_SEEN
d9274 1
a9274 1
			"Setting open paren #%"IVdf" to %d\n",
d9286 1
a9286 1

d9299 1
a9299 1
        FAIL2("panic: regbranch returned NULL, flags=%#"UVxf"", (UV) flags);
d9327 1
a9327 3

            /* Append to the previous. */
            REGTAIL(pRExC_state, NEXTOPER(NEXTOPER(lastbr)), ender);
d9335 1
a9335 1
            RExC_npar = freeze_paren;
d9344 1
a9344 1
            FAIL2("panic: regbranch returned NULL, flags=%#"UVxf"", (UV) flags);
d9359 1
a9359 1
            if (!SIZE_ONLY && RExC_seen & REG_RECURSE_SEEN) {
d9361 1
a9361 1
			"Setting close paren #%"IVdf" to %d\n",
d9364 1
a9364 1
	        if (RExC_nestroot == parno)
d9366 1
a9366 1
	    }
d9391 2
a9392 2
            regprop(RExC_rx, mysv_val1, lastbr, NULL);
            regprop(RExC_rx, mysv_val2, ender, NULL);
d9406 1
a9406 1
                RExC_seen |= REG_TOP_LEVEL_BRANCHES_SEEN;
d9413 1
a9413 2
                    if ( OP(NEXTOPER(br)) != NOTHING
                         || regnext(NEXTOPER(br)) != ender)
d9419 1
a9419 2
                    if ( OP(NEXTOPER(NEXTOPER(br))) != NOTHING
                         || regnext(NEXTOPER(NEXTOPER(br))) != ender)
d9430 2
a9431 2
                    regprop(RExC_rx, mysv_val1, ret, NULL);
                    regprop(RExC_rx, mysv_val2, ender, NULL);
d9465 1
a9465 1
            Set_Node_Cur_Length(ret, parse_start);
d9549 1
a9549 1
            FAIL2("panic: regpiece returned NULL, flags=%#"UVxf"", (UV) flags);
d9619 1
a9619 1
            FAIL2("panic: regatom returned NULL, flags=%#"UVxf"", (UV) flags);
a9672 13
            else if (min == max
                     && RExC_parse < RExC_end
                     && (*RExC_parse == '?' || *RExC_parse == '+'))
            {
                if (SIZE_ONLY) {
                    ckWARN2reg(RExC_parse + 1,
                               "Useless use of greediness modifier '%c'",
                               *RExC_parse);
                }
                /* Absorb the modifier, so later code doesn't see nor use
                    * it */
                nextchar(pRExC_state);
            }
d9679 1
a9679 1
                Set_Node_Cur_Length(ret, parse_start);
a9713 2
            if (max == REG_INFTY)
                RExC_seen |= REG_UNBOUNDED_QUANTIFIER_SEEN;
a9750 1
        RExC_seen |= REG_UNBOUNDED_QUANTIFIER_SEEN;
a9759 1
        RExC_seen |= REG_UNBOUNDED_QUANTIFIER_SEEN;
d9772 4
a9775 6
	ckWARN2reg(RExC_parse,
		   "%"UTF8f" matches null string many times",
		   UTF8fARG(UTF, (RExC_parse >= origparse
                                 ? RExC_parse - origparse
                                 : 0),
		   origparse));
d9784 1
d9786 1
d9796 1
d9808 2
a9809 3
S_grok_bslash_N(pTHX_ RExC_state_t *pRExC_state, regnode** node_p,
                      UV *valuep, I32 *flagp, U32 depth, bool in_char_class,
                      const bool strict   /* Apply stricter parsing rules? */
d9812 1
a9812 1

d9867 1
a9867 1

d9875 1
a9875 2
     * modifier.  The other meaning does not, so use a temporary until we find
     * out which we are being called with */
d9885 1
a9885 1
	    /* no bare \N allowed in a charclass */
a9890 2
        RExC_parse--;   /* Need to back off so nextchar() doesn't skip the
                           current char */
d9895 1
d9914 2
a9915 4
              || (endbrace - RExC_parse >= 2	/* U+ (bad hex is checked below
                                                 */
                  && strnEQ(RExC_parse, "U+", 2)))) /* for a better error msg)
                                                     */
d10051 3
a10053 3
            FAIL2("panic: reg returned NULL to grok_bslash_N, flags=%#"UVxf"",
                  (UV) flags);
        }
d10121 1
a10121 3
S_alloc_maybe_populate_EXACT(pTHX_ RExC_state_t *pRExC_state,
                         regnode *node, I32* flagp, STRLEN len, UV code_point,
                         bool downgradable)
d10136 2
a10137 4
     * additionally will populate the node's STRING with <code_point> or its
     * fold if folding.
     *
     * In both cases <*flagp> is appropriately set
d10141 1
a10141 6
     * match 'ss')
     *
     * When it does the populating, it looks at the flag 'downgradable'.  If
     * true with a node that folds, it checks if the single code point
     * participates in a fold, and if not downgrades the node to an EXACT.
     * This helps the optimizer */
a10147 6
    /* Don't bother to check for downgrading in PASS1, as it doesn't make any
     * sizing difference, and is extra work that is thrown away */
    if (downgradable && ! PASS2) {
        downgradable = FALSE;
    }

d10150 2
a10151 29
            if (UNI_IS_INVARIANT(code_point)) {
                if (LOC || ! FOLD) {    /* /l defers folding until runtime */
                    *character = (U8) code_point;
                }
                else { /* Here is /i and not /l (toFOLD() is defined on just
                          ASCII, which isn't the same thing as INVARIANT on
                          EBCDIC, but it works there, as the extra invariants
                          fold to themselves) */
                    *character = toFOLD((U8) code_point);

                    /* We can downgrade to an EXACT node if this character
                     * isn't a folding one.  Note that this assumes that
                     * nothing above Latin1 folds to some other invariant than
                     * one of these alphabetics; otherwise we would also have
                     * to check:
                     *  && (! HAS_NONLATIN1_FOLD_CLOSURE(code_point)
                     *      || ASCII_FOLD_RESTRICTED))
                     */
                    if (downgradable && PL_fold[code_point] == code_point) {
                        OP(node) = EXACT;
                    }
                }
                len = 1;
            }
            else if (FOLD && (! LOC
                              || ! is_PROBLEMATIC_LOCALE_FOLD_cp(code_point)))
            {   /* Folding, and ok to do so now */
                UV folded = _to_uni_fold_flags(
                                   code_point,
d10154 5
a10158 16
                                   FOLD_FLAGS_FULL | ((ASCII_FOLD_RESTRICTED)
                                                      ? FOLD_FLAGS_NOMIX_ASCII
                                                      : 0));
                if (downgradable
                    && folded == code_point
                    && ! _invlist_contains_cp(PL_utf8_foldable, code_point))
                {
                    OP(node) = EXACT;
                }
            }
            else if (code_point <= MAX_UTF8_TWO_BYTE) {

                /* Not folding this cp, and can output it directly */
                *character = UTF8_TWO_BYTE_HI(code_point);
                *(character + 1) = UTF8_TWO_BYTE_LO(code_point);
                len = 2;
d10164 6
a10169 2
        } /* Else pattern isn't UTF8.  */
        else if (! FOLD) {
d10172 2
a10173 20
        } /* Else is folded non-UTF8 */
        else if (LIKELY(code_point != LATIN_SMALL_LETTER_SHARP_S)) {

            /* We don't fold any non-UTF8 except possibly the Sharp s  (see
             * comments at join_exact()); */
            *character = (U8) code_point;
            len = 1;

            /* Can turn into an EXACT node if we know the fold at compile time,
             * and it folds to itself and doesn't particpate in other folds */
            if (downgradable
                && ! LOC
                && PL_fold_latin1[code_point] == code_point
                && (! HAS_NONLATIN1_FOLD_CLOSURE(code_point)
                    || (isASCII(code_point) && ASCII_FOLD_RESTRICTED)))
            {
                OP(node) = EXACT;
            }
        } /* else is Sharp s.  May need to fold it */
        else if (AT_LEAST_UNI_SEMANTICS && ! ASCII_FOLD_RESTRICTED) {
a10177 4
        else {
            *character = LATIN_SMALL_LETTER_SHARP_S;
            len = 1;
        }
a10200 20

    /* The OP may not be well defined in PASS1 */
    if (PASS2 && OP(node) == EXACTFL) {
        RExC_contains_locale = 1;
    }
}


/* return atoi(p), unless it's too big to sensibly be a backref,
 * in which case return I32_MAX (rather than possibly 32-bit wrapping) */

static I32
S_backref_value(char *p)
{
    char *q = p;

    for (;isDIGIT(*q); q++); /* calculate length of num */
    if (q - p == 0 || q - p > 9)
        return I32_MAX;
    return atoi(p);
a10202 1

d10263 1
a10263 1
   TRYAGAIN.
d10337 2
a10338 2
            FAIL2("panic: regclass returned NULL to regatom, flags=%#"UVxf"",
                  (UV) *flagp);
d10360 1
a10360 2
                FAIL2("panic: reg returned NULL to regatom, flags=%#"UVxf"",
                                                                 (UV) flags);
d10408 1
a10408 1
            RExC_seen |= REG_GPOS_SEEN;
d10419 1
a10419 1
            RExC_seen |= REG_LOOKBEHIND_SEEN;
d10433 1
a10433 1
            RExC_seen |= REG_CANY_SEEN;
d10450 1
a10450 1
            RExC_seen |= REG_LOOKBEHIND_SEEN;
a10454 3
            else if (op == BOUNDL) {
                RExC_contains_locale = 1;
            }
d10459 1
a10459 2
                /* diag_listed_as: Use "%s" instead of "%s" */
	        vFAIL("Use \"\\b\\{\" instead of \"\\b{\"");
d10464 1
a10464 1
            RExC_seen |= REG_LOOKBEHIND_SEEN;
a10468 3
            else if (op == NBOUNDL) {
                RExC_contains_locale = 1;
            }
d10473 1
a10473 2
                /* diag_listed_as: Use "%s" instead of "%s" */
	        vFAIL("Use \"\\B\\{\" instead of \"\\B{\"");
a10516 3
            else if (op == POSIXL) {
                RExC_contains_locale = 1;
            }
d10532 1
a10532 1
         finish_meta_pat:
d10535 1
a10535 1
	    break;
d10555 2
a10556 2
                    FAIL2("panic: regclass returned NULL to regatom, flags=%#"UVxf"",
                          (UV) *flagp);
d10561 1
a10561 1
                Set_Node_Cur_Length(ret, parse_start);
d10565 1
a10565 1
        case 'N':
d10587 2
a10588 2
        {
            char ch= RExC_parse[1];
a10590 1
		/* diag_listed_as: Sequence \%s... not terminated in regex; marked by <-- HERE in m/%s/ */
a10600 1
                    /* diag_listed_as: Sequence \%s... not terminated in regex; marked by <-- HERE in m/%s/ */
d10604 1
a10604 1
                    num = add_data( pRExC_state, STR_WITH_LEN("S"));
d10625 1
a10625 1
                Set_Node_Cur_Length(ret, parse_start);
d10631 1
a10631 1
	case 'g':
d10636 2
d10639 1
a10639 4

		if (*RExC_parse == 'g') {
                    bool isrel = 0;

d10651 1
a10651 1
                        RExC_parse -= 2;
d10653 8
a10660 17
                    }

                    num = S_backref_value(RExC_parse);
                    if (num == 0)
                        vFAIL("Reference to invalid group 0");
                    else if (num == I32_MAX) {
                         if (isDIGIT(*RExC_parse))
			    vFAIL("Reference to nonexistent group");
                        else
                            vFAIL("Unterminated \\g... pattern");
                    }

                    if (isrel) {
                        num = RExC_npar - num;
                        if (num < 1)
                            vFAIL("Reference to nonexistent or unclosed group");
                    }
d10662 4
a10665 17
                else {
                    num = S_backref_value(RExC_parse);
                    /* bare \NNN might be backref or octal - if it is larger than or equal
                     * RExC_npar then it is assumed to be and octal escape.
                     * Note RExC_npar is +1 from the actual number of parens*/
                    if (num == I32_MAX || (num > 9 && num >= RExC_npar
                            && *RExC_parse != '8' && *RExC_parse != '9'))
                    {
                        /* Probably a character specified in octal, e.g. \35 */
                        goto defchar;
                    }
                }

                /* at this point RExC_parse definitely points to a backref
                 * number */
		{
#ifdef RE_TRACK_PATTERN_OFFSETS
a10666 1
#endif
d10669 2
d10672 1
a10672 1
                        if (*RExC_parse != '}')
d10675 1
a10675 1
                    }
d10696 1
a10696 1
                    Set_Node_Cur_Length(ret, parse_start);
d10729 1
a10729 1
	    UV ender = 0;
d10736 2
a10737 1
            U8 node_type = compute_EXACTish(pRExC_state);
a10740 13
            /* We can convert EXACTF nodes to EXACTFU if they contain only
             * characters that match identically regardless of the target
             * string's UTF8ness.  The reason to do this is that EXACTF is not
             * trie-able, EXACTFU is.
             *
             * Similarly, we can convert EXACTFL nodes to EXACTFU if they
             * contain only above-Latin1 characters (hence must be in UTF8),
             * which don't participate in folds with Latin1-range characters,
             * as the latter's folds aren't known until runtime.  (We don't
             * need to figure this out until pass 2) */
            bool maybe_exactfu = PASS2
                               && (node_type == EXACTF || node_type == EXACTFL);

d10746 2
d10758 4
a10761 3
            /* We do the EXACTFish to EXACT node only if folding.  (And we
             * don't need to figure this out until pass 2) */
            maybe_exact = FOLD && PASS2;
d10826 1
a10826 2
                    case 'X':             /* eXtended Unicode "combining
                                             character sequence" */
d10874 1
a10874 1
			  ender = '\a';
d10937 1
a10937 1
			ender = grok_bslash_c(*p++, SIZE_ONLY);
d10939 1
a10939 4
                    case '8': case '9': /* must be a backreference */
                        --p;
                        goto loopdone;
                    case '1': case '2': case '3':case '4':
d10941 2
a10942 23
                        /* When we parse backslash escapes there is ambiguity
                         * between backreferences and octal escapes. Any escape
                         * from \1 - \9 is a backreference, any multi-digit
                         * escape which does not start with 0 and which when
                         * evaluated as decimal could refer to an already
                         * parsed capture buffer is a backslash. Anything else
                         * is octal.
                         *
                         * Note this implies that \118 could be interpreted as
                         * 118 OR as "\11" . "8" depending on whether there
                         * were 118 capture buffers defined already in the
                         * pattern.  */

                        /* NOTE, RExC_npar is 1 more than the actual number of
                         * parens we have seen so far, hence the < RExC_npar below. */

                        if ( !isDIGIT(p[1]) || S_backref_value(p) < RExC_npar)
                        {  /* Not to be treated as an octal constant, go
                                   find backref */
                            --p;
                            goto loopdone;
                        }
                    case '0':
d10961 5
d10969 6
d10989 1
d11004 2
a11005 2
                        && ckWARN_d(WARN_DEPRECATED)
                        && is_PATWS_non_low_safe(p, RExC_end, UTF))
d11043 4
a11046 35
                if (! FOLD   /* The simple case, just append the literal */
                    || (LOC  /* Also don't fold for tricky chars under /l */
                        && is_PROBLEMATIC_LOCALE_FOLD_cp(ender)))
                {
                    if (UTF) {
                        const STRLEN unilen = reguni(pRExC_state, ender, s);
                        if (unilen > 0) {
                           s   += unilen;
                           len += unilen;
                        }

                        /* The loop increments <len> each time, as all but this
                         * path (and one other) through it add a single byte to
                         * the EXACTish node.  But this one has changed len to
                         * be the correct final value, so subtract one to
                         * cancel out the increment that follows */
                        len--;
                    }
                    else {
                        REGC((char)ender, s++);
                    }

                    /* Can get here if folding only if is one of the /l
                     * characters whose fold depends on the locale.  The
                     * occurrence of any of these indicate that we can't
                     * simplify things */
                    if (FOLD) {
                        maybe_exact = FALSE;
                        maybe_exactfu = FALSE;
                    }
                }
                else             /* FOLD */
                     if (! ( UTF
                        /* See comments for join_exact() as to why we fold this
                         * non-UTF at compile time */
d11048 2
a11049 23
                            && ender == LATIN_SMALL_LETTER_SHARP_S)))
                {
                    /* Here, are folding and are not UTF-8 encoded; therefore
                     * the character must be in the range 0-255, and is not /l
                     * (Not /l because we already handled these under /l in
                     * is_PROBLEMATIC_LOCALE_FOLD_cp */
                    if (IS_IN_SOME_FOLD_L1(ender)) {
                        maybe_exact = FALSE;

                        /* See if the character's fold differs between /d and
                         * /u.  This includes the multi-char fold SHARP S to
                         * 'ss' */
                        if (maybe_exactfu
                            && (PL_fold[ender] != PL_fold_latin1[ender]
                                || ender == LATIN_SMALL_LETTER_SHARP_S
                                || (len > 0
                                   && isARG2_lower_or_UPPER_ARG1('s', ender)
                                   && isARG2_lower_or_UPPER_ARG1('s',
                                                                 *(s-1)))))
                        {
                            maybe_exactfu = FALSE;
                        }
                    }
a11050 21
                    /* Even when folding, we store just the input character, as
                     * we have an array that finds its fold quickly */
                    *(s++) = (char) ender;
                }
                else {  /* FOLD and UTF */
                    /* Unlike the non-fold case, we do actually have to
                     * calculate the results here in pass 1.  This is for two
                     * reasons, the folded length may be longer than the
                     * unfolded, and we have to calculate how many EXACTish
                     * nodes it will take; and we may run out of room in a node
                     * in the middle of a potential multi-char fold, and have
                     * to back off accordingly.  (Hence we can't use REGC for
                     * the simple case just below.) */

                    UV folded;
                    if (isASCII(ender)) {
                        folded = toFOLD(ender);
                        *(s)++ = (U8) folded;
                    }
                    else {
                        STRLEN foldlen;
d11052 14
a11065 21
                        folded = _to_uni_fold_flags(
                                     ender,
                                     (U8 *) s,
                                     &foldlen,
                                     FOLD_FLAGS_FULL | ((ASCII_FOLD_RESTRICTED)
                                                        ? FOLD_FLAGS_NOMIX_ASCII
                                                        : 0));
                        s += foldlen;

                        /* The loop increments <len> each time, as all but this
                         * path (and one other) through it add a single byte to
                         * the EXACTish node.  But this one has changed len to
                         * be the correct final value, so subtract one to
                         * cancel out the increment that follows */
                        len += foldlen - 1;
                    }
                    /* If this node only contains non-folding code points so
                     * far, see if this new one is also non-folding */
                    if (maybe_exact) {
                        if (folded != ender) {
                            maybe_exact = FALSE;
d11068 36
a11103 6
                            /* Here the fold is the original; we have to check
                             * further to see if anything folds to it */
                            if (_invlist_contains_cp(PL_utf8_foldable,
                                                        ender))
                            {
                                maybe_exact = FALSE;
d11105 1
d11107 13
a11120 1
                    ender = folded;
d11122 13
d11182 3
a11184 2
                    /* This has no multi-char folds to non-UTF characters */
                    if (ASCII_FOLD_RESTRICTED) {
d11215 6
a11220 2
                            if (! IS_NON_FINAL_FOLD(TWO_BYTE_UTF8_TO_NATIVE(
                                                                  *s, *(s+1))))
d11257 1
a11257 10

                    /* If the node ends in an 's' we make sure it stays EXACTF,
                     * as if it turns into an EXACTFU, it could later get
                     * joined with another 's' that would then wrongly match
                     * the sharp s */
                    if (maybe_exactfu && isARG2_lower_or_UPPER_ARG1('s', ender))
                    {
                        maybe_exactfu = FALSE;
                    }
                } else {
d11309 6
d11321 2
a11322 20
            else {
                if (FOLD) {
                    /* If 'maybe_exact' is still set here, means there are no
                     * code points in the node that participate in folds;
                     * similarly for 'maybe_exactfu' and code points that match
                     * differently depending on UTF8ness of the target string
                     * (for /u), or depending on locale for /l */
                    if (maybe_exact) {
                        OP(ret) = EXACT;
                    }
                    else if (maybe_exactfu) {
                        OP(ret) = EXACTFU;
                    }
                }
                alloc_maybe_populate_EXACT(pRExC_state, ret, flagp, len, ender,
                                           FALSE /* Don't look to see if could
                                                    be turned into an EXACT
                                                    node, as we have already
                                                    computed that */
                                          );
d11326 1
a11326 1
            Set_Node_Cur_Length(ret, parse_start);
d11361 1
a11361 1
                RExC_seen |= REG_RUN_ON_COMMENT_SEEN;
d11375 1
a11375 1
     * RExC_seen has added the REG_RUN_ON_COMMENT_SEEN flag; */
d11395 1
a11395 1
                RExC_seen |= REG_RUN_ON_COMMENT_SEEN;
a11402 66
STATIC void
S_populate_ANYOF_from_invlist(pTHX_ regnode *node, SV** invlist_ptr)
{
    /* Uses the inversion list '*invlist_ptr' to populate the ANYOF 'node'.  It
     * sets up the bitmap and any flags, removing those code points from the
     * inversion list, setting it to NULL should it become completely empty */

    PERL_ARGS_ASSERT_POPULATE_ANYOF_FROM_INVLIST;
    assert(PL_regkind[OP(node)] == ANYOF);

    ANYOF_BITMAP_ZERO(node);
    if (*invlist_ptr) {

	/* This gets set if we actually need to modify things */
	bool change_invlist = FALSE;

	UV start, end;

	/* Start looking through *invlist_ptr */
	invlist_iterinit(*invlist_ptr);
	while (invlist_iternext(*invlist_ptr, &start, &end)) {
	    UV high;
	    int i;

            if (end == UV_MAX && start <= 256) {
                ANYOF_FLAGS(node) |= ANYOF_ABOVE_LATIN1_ALL;
            }
            else if (end >= 256) {
                ANYOF_FLAGS(node) |= ANYOF_UTF8;
            }

	    /* Quit if are above what we should change */
	    if (start > 255) {
		break;
	    }

	    change_invlist = TRUE;

	    /* Set all the bits in the range, up to the max that we are doing */
	    high = (end < 255) ? end : 255;
	    for (i = start; i <= (int) high; i++) {
		if (! ANYOF_BITMAP_TEST(node, i)) {
		    ANYOF_BITMAP_SET(node, i);
		}
	    }
	}
	invlist_iterfinish(*invlist_ptr);

        /* Done with loop; remove any code points that are in the bitmap from
         * *invlist_ptr; similarly for code points above latin1 if we have a
         * flag to match all of them anyways */
	if (change_invlist) {
	    _invlist_subtract(*invlist_ptr, PL_Latin1, invlist_ptr);
	}
        if (ANYOF_FLAGS(node) & ANYOF_ABOVE_LATIN1_ALL) {
	    _invlist_intersection(*invlist_ptr, PL_Latin1, invlist_ptr);
	}

	/* If have completely emptied it, remove it completely */
	if (_invlist_len(*invlist_ptr) == 0) {
	    SvREFCNT_dec_NN(*invlist_ptr);
	    *invlist_ptr = NULL;
	}
    }
}

d11521 2
a11522 3
			vFAIL2utf8f(
                            "POSIX class [:%"UTF8f":] unknown",
			    UTF8fARG(UTF, t - s - 1, s + 1));
d11610 2
a11611 3
S_handle_regex_sets(pTHX_ RExC_state_t *pRExC_state, SV** return_invlist,
                    I32 *flagp, U32 depth,
                    char * const oregcomp_parse)
a11641 1
        UV depth = 0; /* how many nested (?[...]) constructs */
d11646 1
a11646 4
                UTF8fARG(UTF, (RExC_parse - RExC_precomp), RExC_precomp),
                UTF8fARG(UTF,
                         RExC_end - RExC_start - (RExC_parse - RExC_precomp),
                         RExC_precomp + (RExC_parse - RExC_precomp)));
a11652 3
                case '?':
                    if (RExC_parse[1] == '[') depth++, RExC_parse++;
                    /* FALL THROUGH */
d11686 2
a11687 2
                        FAIL2("panic: regclass returned NULL to handle_sets, flags=%#"UVxf"",
                              (UV) *flagp);
a11699 1
                    if (depth--) break;
d11852 2
a11853 2
                    FAIL2("panic: regclass returned NULL to handle_sets, flags=%#"UVxf"",
                          (UV) *flagp);
d11875 2
a11876 2
                    FAIL2("panic: regclass returned NULL to handle_sets, flags=%#"UVxf"",
                          (UV) *flagp);
d12096 1
a12096 2
#define HAS_NONLOCALE_RUNTIME_PROPERTY_DEFINITION                            \
                                        (SvCUR(listsv) != initial_listsv_len)
d12146 2
a12147 10
    SV* posixes = NULL;     /* Code points that match classes like [:word:],
                               extended beyond the Latin1 range.  These have to
                               be kept separate from other code points for much
                               of this function because their handling  is
                               different under /i, and for most classes under
                               /d as well */
    SV* nposixes = NULL;    /* Similarly for [:^word:].  These are kept
                               separate for a while from the non-complemented
                               versions because of complications with /d
                               matching */
d12174 3
a12176 2
    /* Inversion list of code points this node matches regardless of things
     * like locale, folding, utf8ness of the target string */
a12178 8
    /* Like cp_list, but code points on this list need to be checked for things
     * that fold to/from them under /i */
    SV* cp_foldable_list = NULL;

    /* Like cp_list, but code points on this list are valid only when the
     * runtime locale is UTF-8 */
    SV* only_utf8_locale_list = NULL;

d12186 3
a12188 1
    bool warn_super = ALWAYS_WARN_SUPER;
d12193 1
a12193 2
    const SSize_t orig_size = RExC_size;
    bool posixl_matches_all = FALSE; /* Does /l class have both e.g. \W,\w ? */
d12214 3
d12338 1
a12338 1
                    /* We only pay attention to the first char of
d12359 1
a12359 6
                U8 swash_init_flags = _CORE_SWASH_INIT_RETURN_IF_UNDEF
                                       /* And we actually would prefer to get
                                        * the straight inversion list of the
                                        * swash, since we will be accessing it
                                        * anyway, to save a little time */
                                      |_CORE_SWASH_INIT_ACCEPT_INVLIST;
a12381 1
                    char* formatted;
d12402 8
a12409 8
                    formatted = Perl_form(aTHX_
                                          "%s%.*s%s\n",
                                          (FOLD) ? "__" : "",
                                          (int)n,
                                          RExC_parse,
                                          (FOLD) ? "_i" : ""
                                );
                    name = savepvn(formatted, strlen(formatted));
d12434 1
a12434 3
                            vFAIL2utf8f(
                                "Property '%"UTF8f"' is unknown",
                                UTF8fARG(UTF, n, name));
d12436 1
a12436 1
                        Perl_sv_catpvf(aTHX_ listsv, "%cutf8::%"UTF8f"\n",
d12438 1
a12438 1
                                        UTF8fARG(UTF, n, name));
d12447 1
a12447 1
                         * is no <depends_list> */
d12455 3
a12457 17
                        if (swash_init_flags
                            & _CORE_SWASH_INIT_USER_DEFINED_PROPERTY)
                        {
                            has_user_defined_property = TRUE;
                        }
                        else if
                            /* We warn on matching an above-Unicode code point
                             * if the match would return true, except don't
                             * warn for \p{All}, which has exactly one element
                             * = 0 */
                            (_invlist_contains_cp(invlist, 0x110000)
                                && (! (_invlist_len(invlist) == 1
                                       && *invlist_array(invlist) == 0)))
                        {
                            warn_super = TRUE;
                        }

d12491 1
a12491 1
	    case 'a':	value = '\a';                   break;
d12531 1
a12531 1
		value = grok_bslash_c(*RExC_parse++, SIZE_ONLY);
d12603 24
a12627 1
            U8 classnum;
d12638 1
a12638 3
                        vFAIL2utf8f(
                            "False [] range \"%"UTF8f"\"",
                            UTF8fARG(UTF, w, rangebegin));
d12642 3
a12644 3
                        ckWARN2reg(RExC_parse,
                            "False [] range \"%"UTF8f"\"",
                            UTF8fARG(UTF, w, rangebegin));
d12647 1
a12647 2
                        cp_foldable_list = add_cp_to_invlist(cp_foldable_list,
                                                             prevvalue);
d12655 3
a12657 78
            classnum = namedclass_to_classnum(namedclass);

	    if (LOC && namedclass < ANYOF_POSIXL_MAX
#ifndef HAS_ISASCII
                && classnum != _CC_ASCII
#endif
            ) {
                /* What the Posix classes (like \w, [:space:]) match in locale
                 * isn't knowable under locale until actual match time.  Room
                 * must be reserved (one time per outer bracketed class) to
                 * store such classes.  The space will contain a bit for each
                 * named class that is to be matched against.  This isn't
                 * needed for \p{} and pseudo-classes, as they are not affected
                 * by locale, and hence are dealt with separately */
                if (! need_class) {
                    need_class = 1;
                    if (SIZE_ONLY) {
                        RExC_size += ANYOF_POSIXL_SKIP - ANYOF_SKIP;
                    }
                    else {
                        RExC_emit += ANYOF_POSIXL_SKIP - ANYOF_SKIP;
                    }
                    ANYOF_FLAGS(ret) |= ANYOF_POSIXL;
                    ANYOF_POSIXL_ZERO(ret);
                }

                /* See if it already matches the complement of this POSIX
                 * class */
                if ((ANYOF_FLAGS(ret) & ANYOF_POSIXL)
                    && ANYOF_POSIXL_TEST(ret, namedclass + ((namedclass % 2)
                                                            ? -1
                                                            : 1)))
                {
                    posixl_matches_all = TRUE;
                    break;  /* No need to continue.  Since it matches both
                               e.g., \w and \W, it matches everything, and the
                               bracketed class can be optimized into qr/./s */
                }

                /* Add this class to those that should be checked at runtime */
                ANYOF_POSIXL_SET(ret, namedclass);

                /* The above-Latin1 characters are not subject to locale rules.
                 * Just add them, in the second pass, to the
                 * unconditionally-matched list */
                if (! SIZE_ONLY) {
                    SV* scratch_list = NULL;

                    /* Get the list of the above-Latin1 code points this
                     * matches */
                    _invlist_intersection_maybe_complement_2nd(PL_AboveLatin1,
                                          PL_XPosix_ptrs[classnum],

                                          /* Odd numbers are complements, like
                                           * NDIGIT, NASCII, ... */
                                          namedclass % 2 != 0,
                                          &scratch_list);
                    /* Checking if 'cp_list' is NULL first saves an extra
                     * clone.  Its reference count will be decremented at the
                     * next union, etc, or if this is the only instance, at the
                     * end of the routine */
                    if (! cp_list) {
                        cp_list = scratch_list;
                    }
                    else {
                        _invlist_union(cp_list, scratch_list, &cp_list);
                        SvREFCNT_dec_NN(scratch_list);
                    }
                    continue;   /* Go get next character */
                }
            }
            else if (! SIZE_ONLY) {

                /* Here, not in pass1 (in that pass we skip calculating the
                 * contents of this class), and is /l, or is a POSIX class for
                 * which /l doesn't matter (or is a Unicode property, which is
                 * skipped here). */
                if (namedclass >= ANYOF_POSIXL_MAX) {  /* If a special class */
d12660 5
a12664 3
                        /* Here, should be \h, \H, \v, or \V.  None of /d, /i
                         * nor /l make a difference in what these match,
                         * therefore we just add what they match to cp_list. */
d12677 1
a12677 1
                                namedclass % 2 != 0,    /* Complement if odd
d12683 240
a12922 11
                else {  /* Garden variety class.  If is NASCII, NDIGIT, ...
                           complement and use nposixes */
                    SV** posixes_ptr = namedclass % 2 == 0
                                       ? &posixes
                                       : &nposixes;
                    SV** source_ptr = &PL_XPosix_ptrs[classnum];
                    _invlist_union_maybe_complement_2nd(
                                                     *posixes_ptr,
                                                     *source_ptr,
                                                     namedclass % 2 != 0,
                                                     posixes_ptr);
d12924 2
a12925 1
                continue;   /* Go get next character */
d12944 1
a12944 3
                vFAIL2utf8f(
                    "Invalid [] range \"%"UTF8f"\"",
                    UTF8fARG(UTF, w, rangebegin));
d13025 5
a13029 3
                                FOLD_FLAGS_FULL | (ASCII_FOLD_RESTRICTED
                                                   ? FOLD_FLAGS_NOMIX_ASCII
                                                   : 0)
d13060 11
a13070 11
                         * element thereof is a character which folds to TWO
                         * characters; [3] is for folds to THREE characters.
                         * (Unicode guarantees a maximum of 3 characters in any
                         * fold.)  When we rewrite the character class below,
                         * we will do so such that the longest folds are
                         * written first, so that it prefers the longest
                         * matching strings first.  This is done even if it
                         * turns out that any quantifier is non-greedy, out of
                         * programmer laziness.  Tom Christiansen has agreed
                         * that this is ok.  This makes the test for the
                         * ligature 'ffi' come before the test for 'ff' */
d13097 1
a13097 2
            cp_foldable_list = _add_range_to_invlist(cp_foldable_list,
                                                     prevvalue, value);
d13111 2
a13112 2
                && ((prevvalue >= 'a' && value <= 'z')
                    || (prevvalue >= 'A' && value <= 'Z')))
d13114 1
a13114 6
                _invlist_intersection(this_range, PL_ASCII,
                                      &this_range);

                /* Since this above only contains ascii, the intersection of it
                 * with anything will still yield only ascii */
                _invlist_intersection(this_range, PL_XPosix_ptrs[_CC_ALPHA],
d13117 1
a13117 1
            _invlist_union(cp_foldable_list, this_range, &cp_foldable_list);
d13147 1
a13147 1
        for (cp_count = av_tindex(multi_char_matches); cp_count > 0; cp_count--) {
d13202 4
a13205 14
    /* Here, we've gone through the entire class and dealt with multi-char
     * folds.  We are now in a position that we can do some checks to see if we
     * can optimize this ANYOF node into a simpler one, even in Pass 1.
     * Currently we only do two checks:
     * 1) is in the unlikely event that the user has specified both, eg. \w and
     *    \W under /l, then the class matches everything.  (This optimization
     *    is done only to make the optimizer code run later work.)
     * 2) if the character class contains only a single element (including a
     *    single range), we see if there is an equivalent node for it.
     * Other checks are possible */
    if (! ret_invlist   /* Can't optimize if returning the constructed
                           inversion list */
        && (UNLIKELY(posixl_matches_all) || element_count == 1))
    {
d13209 2
a13210 6
        if (UNLIKELY(posixl_matches_all)) {
            op = SANY;
        }
        else if (namedclass > OOB_NAMEDCLASS) { /* this is a named class, like
                                                   \w or [:digit:] or \p{foo}
                                                 */
d13266 8
d13328 1
a13328 1
                     * e.g.  ANYOF_POSIXL_SET */
a13334 3
                    if (op == POSIXL) {
                        RExC_contains_locale = 1;
                    }
d13350 1
a13350 3
                alloc_maybe_populate_EXACT(pRExC_state, ret, flagp, 0, value,
                                           TRUE /* downgradable to EXACT */
                                           );
a13355 1
            SvREFCNT_dec(nposixes);
a13356 1
            SvREFCNT_dec(cp_foldable_list);
d13367 2
a13368 17
    if (cp_foldable_list) {
        if (FOLD) {
            UV start, end;	/* End points of code point ranges */

            SV* fold_intersection = NULL;
            SV** use_list;

            /* Our calculated list will be for Unicode rules.  For locale
             * matching, we have to keep a separate list that is consulted at
             * runtime only when the locale indicates Unicode rules.  For
             * non-locale, we just use to the general list */
            if (LOC) {
                use_list = &only_utf8_locale_list;
            }
            else {
                use_list = &cp_list;
            }
d13370 1
a13370 6
            /* Only the characters in this class that participate in folds need
             * be checked.  Get the intersection of this class and all the
             * possible characters that are foldable.  This can quickly narrow
             * down a large class */
            _invlist_intersection(PL_utf8_foldable, cp_foldable_list,
                                  &fold_intersection);
d13372 10
a13381 7
            /* The folds for all the Latin1 characters are hard-coded into this
             * program, but we have to go out to disk to get the others. */
            if (invlist_highest(cp_foldable_list) >= 256) {

                /* This is a hash that for a particular fold gives all
                 * characters that are involved in it */
                if (! PL_utf8_foldclosures) {
d13383 24
d13410 1
a13410 1
                        U8 dummy[UTF8_MAXBYTES_CASE+1];
d13416 2
a13417 2
                    PL_utf8_foldclosures
                                      = _swash_inversion_hash(PL_utf8_tofold);
d13421 46
a13466 36
            /* Now look at the foldable characters in this class individually */
            invlist_iterinit(fold_intersection);
            while (invlist_iternext(fold_intersection, &start, &end)) {
                UV j;

                /* Look at every character in the range */
                for (j = start; j <= end; j++) {
                    U8 foldbuf[UTF8_MAXBYTES_CASE+1];
                    STRLEN foldlen;
                    SV** listp;

                    if (j < 256) {

                        /* We have the latin1 folding rules hard-coded here so
                         * that an innocent-looking character class, like
                         * /[ks]/i won't have to go out to disk to find the
                         * possible matches.  XXX It would be better to
                         * generate these via regen, in case a new version of
                         * the Unicode standard adds new mappings, though that
                         * is not really likely, and may be caught by the
                         * default: case of the switch below. */

                        if (IS_IN_SOME_FOLD_L1(j)) {

                            /* ASCII is always matched; non-ASCII is matched
                             * only under Unicode rules (which could happen
                             * under /l if the locale is a UTF-8 one */
                            if (isASCII(j) || ! DEPENDS_SEMANTICS) {
                                *use_list = add_cp_to_invlist(*use_list,
                                                            PL_fold_latin1[j]);
                            }
                            else {
                                depends_list =
                                 add_cp_to_invlist(depends_list,
                                                   PL_fold_latin1[j]);
                            }
d13468 1
d13470 20
a13489 21
                        if (HAS_NONLATIN1_FOLD_CLOSURE(j)
                            && (! isASCII(j) || ! ASCII_FOLD_RESTRICTED))
                        {
                            /* Certain Latin1 characters have matches outside
                            * Latin1.  To get here, <j> is one of those
                            * characters.   None of these matches is valid for
                            * ASCII characters under /aa, which is why the 'if'
                            * just above excludes those.  These matches only
                            * happen when the target string is utf8.  The code
                            * below adds the single fold closures for <j> to the
                            * inversion list. */

                            switch (j) {
                                case 'k':
                                case 'K':
                                  *use_list =
                                     add_cp_to_invlist(*use_list, KELVIN_SIGN);
                                    break;
                                case 's':
                                case 'S':
                                  *use_list = add_cp_to_invlist(*use_list,
d13491 14
a13504 14
                                    break;
                                case MICRO_SIGN:
                                  *use_list = add_cp_to_invlist(*use_list,
                                                      GREEK_CAPITAL_LETTER_MU);
                                  *use_list = add_cp_to_invlist(*use_list,
                                                        GREEK_SMALL_LETTER_MU);
                                    break;
                                case LATIN_CAPITAL_LETTER_A_WITH_RING_ABOVE:
                                case LATIN_SMALL_LETTER_A_WITH_RING_ABOVE:
                                  *use_list =
                                   add_cp_to_invlist(*use_list, ANGSTROM_SIGN);
                                    break;
                                case LATIN_SMALL_LETTER_Y_WITH_DIAERESIS:
                                  *use_list = add_cp_to_invlist(*use_list,
d13506 28
a13533 29
                                    break;
                                case LATIN_SMALL_LETTER_SHARP_S:
                                  *use_list = add_cp_to_invlist(*use_list,
                                                 LATIN_CAPITAL_LETTER_SHARP_S);
                                    break;
                                case 'F': case 'f':
                                case 'I': case 'i':
                                case 'L': case 'l':
                                case 'T': case 't':
                                case 'A': case 'a':
                                case 'H': case 'h':
                                case 'J': case 'j':
                                case 'N': case 'n':
                                case 'W': case 'w':
                                case 'Y': case 'y':
                                    /* These all are targets of multi-character
                                     * folds from code points that require UTF8
                                     * to express, so they can't match unless
                                     * the target string is in UTF-8, so no
                                     * action here is necessary, as regexec.c
                                     * properly handles the general case for
                                     * UTF-8 matching and multi-char folds */
                                    break;
                                default:
                                    /* Use deprecated warning to increase the
                                    * chances of this being output */
                                    ckWARN2reg_d(RExC_parse, "Perl folding rules are not up-to-date for 0x%"UVXf"; please use the perlbug utility to report;", j);
                                    break;
                            }
a13534 1
                        continue;
d13536 2
d13539 39
a13577 28
                    /* Here is an above Latin1 character.  We don't have the
                     * rules hard-coded for it.  First, get its fold.  This is
                     * the simple fold, as the multi-character folds have been
                     * handled earlier and separated out */
                    _to_uni_fold_flags(j, foldbuf, &foldlen,
                                                        (ASCII_FOLD_RESTRICTED)
                                                        ? FOLD_FLAGS_NOMIX_ASCII
                                                        : 0);

                    /* Single character fold of above Latin1.  Add everything in
                    * its fold closure to the list that this node should match.
                    * The fold closures data structure is a hash with the keys
                    * being the UTF-8 of every character that is folded to, like
                    * 'k', and the values each an array of all code points that
                    * fold to its key.  e.g. [ 'k', 'K', KELVIN_SIGN ].
                    * Multi-character folds are not included */
                    if ((listp = hv_fetch(PL_utf8_foldclosures,
                                        (char *) foldbuf, foldlen, FALSE)))
                    {
                        AV* list = (AV*) *listp;
                        IV k;
                        for (k = 0; k <= av_tindex(list); k++) {
                            SV** c_p = av_fetch(list, k, FALSE);
                            UV c;
                            if (c_p == NULL) {
                                Perl_croak(aTHX_ "panic: invalid PL_utf8_foldclosures structure");
                            }
                            c = SvUV(*c_p);
d13579 8
a13586 25
                            /* /aa doesn't allow folds between ASCII and non- */
                            if ((ASCII_FOLD_RESTRICTED
                                && (isASCII(c) != isASCII(j))))
                            {
                                continue;
                            }

                            /* Folds under /l which cross the 255/256 boundary
                             * are added to a separate list.  (These are valid
                             * only when the locale is UTF-8.) */
                            if (c < 256 && LOC) {
                                *use_list = add_cp_to_invlist(*use_list, c);
                                continue;
                            }

                            if (isASCII(c) || c > 255 || AT_LEAST_UNI_SEMANTICS)
                            {
                                cp_list = add_cp_to_invlist(cp_list, c);
                            }
                            else {
                                /* Similarly folds involving non-ascii Latin1
                                * characters under /d are added to their list */
                                depends_list = add_cp_to_invlist(depends_list,
                                                                 c);
                            }
d13591 2
a13592 7
            SvREFCNT_dec_NN(fold_intersection);
        }

        /* Now that we have finished adding all the folds, there is no reason
         * to keep the foldable list separate */
        _invlist_union(cp_list, cp_foldable_list, &cp_list);
	SvREFCNT_dec_NN(cp_foldable_list);
d13599 1
a13599 28
    if (posixes || nposixes) {
        if (posixes && AT_LEAST_ASCII_RESTRICTED) {
            /* Under /a and /aa, nothing above ASCII matches these */
            _invlist_intersection(posixes,
                                  PL_XPosix_ptrs[_CC_ASCII],
                                  &posixes);
        }
        if (nposixes) {
            if (DEPENDS_SEMANTICS) {
                /* Under /d, everything in the upper half of the Latin1 range
                 * matches these complements */
                ANYOF_FLAGS(ret) |= ANYOF_NON_UTF8_NON_ASCII_ALL;
            }
            else if (AT_LEAST_ASCII_RESTRICTED) {
                /* Under /a and /aa, everything above ASCII matches these
                 * complements */
                _invlist_union_complement_2nd(nposixes,
                                              PL_XPosix_ptrs[_CC_ASCII],
                                              &nposixes);
            }
            if (posixes) {
                _invlist_union(posixes, nposixes, &posixes);
                SvREFCNT_dec_NN(nposixes);
            }
            else {
                posixes = nposixes;
            }
        }
d13613 1
a13613 1
            _invlist_intersection(posixes, PL_UpperLatin1,
d13615 2
d13650 1
d13661 8
a13668 2
                warn_super = ! (invert
                               ^ (invlist_highest(cp_list) > PERL_UNICODE_MAX));
d13679 1
a13679 1
            ANYOF_FLAGS(ret) |= ANYOF_WARN_SUPER;
a13691 20
    /* If we didn't do folding, it's because some information isn't available
     * until runtime; set the run-time fold flag for these.  (We don't have to
     * worry about properties folding, as that is taken care of by the swash
     * fetching).  We know to set the flag if we have a non-NULL list for UTF-8
     * locales, or the class matches at least one 0-255 range code point */
    if (LOC && FOLD) {
        if (only_utf8_locale_list) {
            ANYOF_FLAGS(ret) |= ANYOF_LOC_FOLD;
        }
        else if (cp_list) { /* Look to see if there a 0-255 code point is in
                               the list */
            UV start, end;
            invlist_iterinit(cp_list);
            if (invlist_iternext(cp_list, &start, &end) && start < 256) {
                ANYOF_FLAGS(ret) |= ANYOF_LOC_FOLD;
            }
            invlist_iterfinish(cp_list);
        }
    }

d13696 2
a13697 3
    if (cp_list
        && invert
        && ! (ANYOF_FLAGS(ret) & (ANYOF_LOCALE_FLAGS))
d13727 9
d13754 2
a13755 7
        && ! (ANYOF_FLAGS(ret) & (ANYOF_LOCALE_FLAGS))
        && ! HAS_NONLOCALE_RUNTIME_PROPERTY_DEFINITION

           /* We don't optimize if we are supposed to make sure all non-Unicode
            * code points raise a warning, as only ANYOF nodes have this check.
            * */
        && ! ((ANYOF_FLAGS(ret) | ANYOF_WARN_SUPER) && ALWAYS_WARN_SUPER))
d13779 1
a13779 1
                 * into an EXACTish node */
d13809 6
d13854 1
a13854 3
                alloc_maybe_populate_EXACT(pRExC_state, ret, flagp, 0, value,
                                           TRUE /* downgradable to EXACT */
                                          );
d13867 22
d13890 26
a13915 1
    populate_ANYOF_from_invlist(ret, &cp_list);
a13931 1
        ANYOF_FLAGS(ret) |= ANYOF_UTF8;
d13941 4
a13944 56
    set_ANYOF_arg(pRExC_state, ret, cp_list,
                  (HAS_NONLOCALE_RUNTIME_PROPERTY_DEFINITION)
                   ? listsv : NULL,
                  only_utf8_locale_list,
                  swash, has_user_defined_property);

    *flagp |= HASWIDTH|SIMPLE;

    if (ANYOF_FLAGS(ret) & ANYOF_LOCALE_FLAGS) {
        RExC_contains_locale = 1;
    }

    return ret;
}

#undef HAS_NONLOCALE_RUNTIME_PROPERTY_DEFINITION

STATIC void
S_set_ANYOF_arg(pTHX_ RExC_state_t* const pRExC_state,
                regnode* const node,
                SV* const cp_list,
                SV* const runtime_defns,
                SV* const only_utf8_locale_list,
                SV* const swash,
                const bool has_user_defined_property)
{
    /* Sets the arg field of an ANYOF-type node 'node', using information about
     * the node passed-in.  If there is nothing outside the node's bitmap, the
     * arg is set to ANYOF_NONBITMAP_EMPTY.  Otherwise, it sets the argument to
     * the count returned by add_data(), having allocated and stored an array,
     * av, that that count references, as follows:
     *  av[0] stores the character class description in its textual form.
     *        This is used later (regexec.c:Perl_regclass_swash()) to
     *        initialize the appropriate swash, and is also useful for dumping
     *        the regnode.  This is set to &PL_sv_undef if the textual
     *        description is not needed at run-time (as happens if the other
     *        elements completely define the class)
     *  av[1] if &PL_sv_undef, is a placeholder to later contain the swash
     *        computed from av[0].  But if no further computation need be done,
     *        the swash is stored here now (and av[0] is &PL_sv_undef).
     *  av[2] stores the inversion list of code points that match only if the
     *        current locale is UTF-8
     *  av[3] stores the cp_list inversion list for use in addition or instead
     *        of av[0]; used only if cp_list exists and av[1] is &PL_sv_undef.
     *        (Otherwise everything needed is already in av[0] and av[1])
     *  av[4] is set if any component of the class is from a user-defined
     *        property; used only if av[3] exists */

    UV n;

    PERL_ARGS_ASSERT_SET_ANYOF_ARG;

    if (! cp_list && ! runtime_defns && ! only_utf8_locale_list) {
        assert(! (ANYOF_FLAGS(node)
                    & (ANYOF_UTF8|ANYOF_NONBITMAP_NON_UTF8)));
	ARG_SET(node, ANYOF_NONBITMAP_EMPTY);
d13947 10
d13960 2
a13961 5
        assert(ANYOF_FLAGS(node)
                    & (ANYOF_UTF8|ANYOF_NONBITMAP_NON_UTF8|ANYOF_LOC_FOLD));

	av_store(av, 0, (runtime_defns)
			? SvREFCNT_inc(runtime_defns) : &PL_sv_undef);
d13967 1
a13967 1
	    av_store(av, 1, &PL_sv_undef);
d13969 2
a13970 2
		av_store(av, 3, cp_list);
		av_store(av, 4, newSVuv(has_user_defined_property));
a13973 7
        if (only_utf8_locale_list) {
	    av_store(av, 2, only_utf8_locale_list);
        }
        else {
	    av_store(av, 2, &PL_sv_undef);
        }

d13975 1
a13975 1
	n = add_data(pRExC_state, STR_WITH_LEN("s"));
d13977 1
a13977 1
	ARG_SET(node, n);
d13979 3
d13983 1
d13990 1
a13990 1
   Will set the REG_RUN_ON_COMMENT_SEEN flag if the comment
d14013 1
a14013 1
        RExC_seen |= REG_RUN_ON_COMMENT_SEEN;
d14094 2
a14095 3
	MJD_OFFSET_DEBUG(
              ("%s:%d: (op %s) %s %"UVuf" (len %"UVuf") (max %"UVuf").\n",
              "reg_node", __LINE__,
d14097 1
a14097 1
              (UV)(RExC_emit - RExC_emit_start) > RExC_offsets[0]
d14101 1
a14101 1
              (UV)RExC_offsets[0]));
d14125 1
a14125 1
	/*
d14127 2
a14128 2

	   assert(2==regarglen[op]+1);
d14132 1
a14132 1

d14134 1
a14134 1

d14150 1
a14150 2
	MJD_OFFSET_DEBUG(
              ("%s(%d): (op %s) %s %"UVuf" <- %"UVuf" (max %"UVuf").\n",
d14154 1
a14154 1
              (UV)(RExC_emit - RExC_emit_start) > RExC_offsets[0] ?
d14158 1
a14158 1
              (UV)RExC_offsets[0]));
d14161 1
a14161 1
#endif
d14169 1
a14169 1
PERL_STATIC_INLINE STRLEN
d14230 1
a14230 2
	    MJD_OFFSET_DEBUG(
                 ("%s(%d): (op %s) %s copy %"UVuf" -> %"UVuf" (max %"UVuf").\n",
d14234 1
a14234 1
                  (UV)(dst - RExC_emit_start) > RExC_offsets[0]
d14238 1
a14238 1
                  (UV)RExC_offsets[0]));
d14244 1
a14244 1

d14249 1
a14249 2
	MJD_OFFSET_DEBUG(
              ("%s(%d): (op %s) %s %"UVuf" <- %"UVuf" (max %"UVuf").\n",
d14253 1
a14253 1
              (UV)(place - RExC_emit_start) > RExC_offsets[0]
d14261 1
a14261 1
#endif
d14273 1
a14273 2
S_regtail(pTHX_ RExC_state_t *pRExC_state, regnode *p,
                const regnode *val,U32 depth)
d14294 1
a14294 1
            regprop(RExC_rx, mysv, scan, NULL);
d14320 1
a14320 1
This is experimental code. The idea is to use this routine to perform
d14332 1
a14332 2
S_regtail_study(pTHX_ RExC_state_t *pRExC_state, regnode *p,
                      const regnode *val,U32 depth)
d14355 2
a14356 3
	    bool unfolded_multi_char;	/* Unexamined in this routine */
            if (join_exact(pRExC_state, scan, &min,
                           &unfolded_multi_char, 1, val, depth+1))
a14363 1
                case EXACTFA_NO_TRIE:
d14367 1
d14382 1
a14382 1
            regprop(RExC_rx, mysv, scan, NULL);
d14395 2
a14396 3
        regprop(RExC_rx, mysv_val, val, NULL);
        PerlIO_printf(Perl_debug_log,
                      "~ attach to %s (%"IVdf") offset to %"IVdf"\n",
d14417 1
a14417 25

static void
S_regdump_intflags(pTHX_ const char *lead, const U32 flags)
{
    int bit;
    int set=0;

    ASSUME(REG_INTFLAGS_NAME_SIZE <= sizeof(flags)*8);

    for (bit=0; bit<REG_INTFLAGS_NAME_SIZE; bit++) {
        if (flags & (1<<bit)) {
            if (!set++ && lead)
                PerlIO_printf(Perl_debug_log, "%s",lead);
            PerlIO_printf(Perl_debug_log, "%s ",PL_reg_intflags_name[bit]);
        }
    }
    if (lead)  {
        if (set)
            PerlIO_printf(Perl_debug_log, "\n");
        else
            PerlIO_printf(Perl_debug_log, "%s[none-set]\n",lead);
    }
}

static void
d14424 1
a14424 3
    ASSUME(REG_EXTFLAGS_NAME_SIZE <= sizeof(flags)*8);

    for (bit=0; bit<REG_EXTFLAGS_NAME_SIZE; bit++) {
d14429 1
a14429 1
            if (!set++ && lead)
d14432 2
a14433 2
        }
    }
d14457 1
a14457 1
        if (set)
d14459 1
a14459 1
        else
d14461 2
a14462 2
    }
}
d14481 1
a14481 1
	RE_PV_QUOTED_DECL(s, 0, dsv, SvPVX_const(r->anchored_substr),
d14488 1
a14488 1
	RE_PV_QUOTED_DECL(s, 1, dsv, SvPVX_const(r->anchored_utf8),
d14494 1
a14494 1
    }
d14496 1
a14496 1
	RE_PV_QUOTED_DECL(s, 0, dsv, SvPVX_const(r->float_substr),
d14503 1
a14503 1
	RE_PV_QUOTED_DECL(s, 1, dsv, SvPVX_const(r->float_utf8),
d14516 1
a14516 1
    if (r->intflags & PREGf_NOSCAN)
d14524 1
a14524 1
	regprop(r, sv, ri->regstclass, NULL);
d14527 1
a14527 1
    if (r->intflags & PREGf_ANCH) {
d14529 1
a14529 1
        if (r->intflags & PREGf_ANCH_BOL)
d14531 1
a14531 1
        if (r->intflags & PREGf_ANCH_MBOL)
d14533 1
a14533 1
        if (r->intflags & PREGf_ANCH_SBOL)
d14535 1
a14535 1
        if (r->intflags & PREGf_ANCH_GPOS)
d14539 1
a14539 1
    if (r->intflags & PREGf_GPOS_SEEN)
d14549 1
a14549 4
    DEBUG_FLAGS_r({
        regdump_extflags("r->extflags: ",r->extflags);
        regdump_intflags("r->intflags: ",r->intflags);
    });
d14558 1
a14558 1
- regprop - printable representation of opcode, with run time support
d14560 10
d14572 1
a14572 1
Perl_regprop(pTHX_ const regexp *prog, SV *sv, const regnode *o, const regmatch_info *reginfo)
d14588 4
a14591 4
        "\\w",
        "\\W",
        "\\d",
        "\\D",
d14608 2
a14609 2
        "\\s",
        "\\S",
d14620 2
a14621 2
        "\\v",
        "\\V"
d14625 1
a14625 1

d14633 1
a14633 2
	Perl_croak(aTHX_ "Corrupted regexp opcode %d > %d",
                                              (int)OP(o), (int)REGNODE_MAX);
d14640 3
a14642 3
	/* Using is_utf8_string() (via PERL_PV_UNI_DETECT)
	 * is a crude hack but it may be the best for now since
	 * we have no flag "this EXACTish node was UTF-8"
d14661 1
a14661 1

d14664 10
a14673 10
          Perl_sv_catpvf(aTHX_ sv,
            "<S:%"UVuf"/%"IVdf" W:%"UVuf" L:%"UVuf"/%"UVuf" C:%"UVuf"/%"UVuf">",
            (UV)trie->startstate,
            (IV)trie->statecount-1, /* -1 because of the unused 0 element */
            (UV)trie->wordcount,
            (UV)trie->minlen,
            (UV)trie->maxlen,
            (UV)TRIE_CHARCOUNT(trie),
            (UV)trie->uniquecharcount
          );
d14676 3
d14680 16
a14695 3
            (void) put_latin1_charclass_innards(sv, IS_ANYOF_TRIE(op)
                                                   ? ANYOF_BITMAP(o)
                                                   : TRIE_BITMAP(trie));
d14697 2
a14698 2
        }

d14706 1
a14706 3
    else if (k == REF || k == OPEN || k == CLOSE
             || k == GROUPP || OP(o)==ACCEPT)
    {
d14714 1
a14714 1
            }
d14729 3
a14731 18
        }
        if ( k == REF && reginfo) {
            U32 n = ARG(o);  /* which paren pair */
            I32 ln = prog->offs[n].start;
            if (prog->lastparen < n || ln == -1)
                Perl_sv_catpvf(aTHX_ sv, ": FAIL");
            else if (ln == prog->offs[n].end)
                Perl_sv_catpvf(aTHX_ sv, ": ACCEPT - EMPTY STRING");
            else {
                const char *s = reginfo->strbeg + ln;
                Perl_sv_catpvf(aTHX_ sv, ": ");
                Perl_pv_pretty( aTHX_ sv, s, prog->offs[n].end - prog->offs[n].start, 32, 0, 0,
                    PERL_PV_ESCAPE_UNI_DETECT|PERL_PV_PRETTY_NOCLEAR|PERL_PV_PRETTY_ELLIPSES|PERL_PV_PRETTY_QUOTE );
            }
        }
    } else if (k == GOSUB)
        /* Paren and offset */
	Perl_sv_catpvf(aTHX_ sv, "%d[%+d]", (int)ARG(o),(int)ARG2L(o));
d14733 2
a14734 2
        if (!o->flags)
            Perl_sv_catpvf(aTHX_ sv, ":%"SVf,
d14737 1
a14737 2
        /* 2: embedded, otherwise 1 */
	Perl_sv_catpvf(aTHX_ sv, "[%d]", o->flags);
d14739 1
d14744 1
a14744 1
	if (flags & ANYOF_LOCALE_FLAGS)
d14753 23
a14775 8
        do_sep = put_latin1_charclass_innards(sv, ANYOF_BITMAP(o));

        /* output any special charclass tests (used entirely under use
         * locale) * */
	if (ANYOF_POSIXL_TEST_ANY_SET(o)) {
            int i;
	    for (i = 0; i < ANYOF_POSIXL_MAX; i++) {
		if (ANYOF_POSIXL_TEST(o,i)) {
d14779 52
a14830 2
            }
        }
d14832 3
a14834 31
	if ((flags & (ANYOF_ABOVE_LATIN1_ALL
                      |ANYOF_UTF8
                      |ANYOF_NONBITMAP_NON_UTF8
                      |ANYOF_LOC_FOLD)))
        {
            if (do_sep) {
                Perl_sv_catpvf(aTHX_ sv,"%s][%s",PL_colors[1],PL_colors[0]);
                if (flags & ANYOF_INVERT)
                    /*make sure the invert info is in each */
                    sv_catpvs(sv, "^");
            }

            if (flags & ANYOF_NON_UTF8_NON_ASCII_ALL) {
                sv_catpvs(sv, "{non-utf8-latin1-all}");
            }

            /* output information about the unicode matching */
            if (flags & ANYOF_ABOVE_LATIN1_ALL)
                sv_catpvs(sv, "{unicode_all}");
            else if (ARG(o) != ANYOF_NONBITMAP_EMPTY) {
                SV *lv; /* Set if there is something outside the bit map. */
                bool byte_output = FALSE;   /* If something in the bitmap has
                                               been output */
                SV *only_utf8_locale;

                /* Get the stuff that wasn't in the bitmap */
                (void) _get_regclass_nonbitmap_data(prog, o, FALSE,
                                                    &lv, &only_utf8_locale);
                if (lv && lv != &PL_sv_undef) {
                    char *s = savesvpv(lv);
                    char * const origs = s;
d14836 2
a14837 2
                    while (*s && *s != '\n')
                        s++;
d14839 2
a14840 9
                    if (*s == '\n') {
                        const char * const t = ++s;

                        if (flags & ANYOF_NONBITMAP_NON_UTF8) {
                            sv_catpvs(sv, "{outside bitmap}");
                        }
                        else {
                            sv_catpvs(sv, "{utf8}");
                        }
d14846 2
a14847 2
                        while (*s) {
                            if (*s == '\n') {
d14850 16
a14865 16
                                if (s - origs > 256) {
                                    Perl_sv_catpvf(aTHX_ sv,
                                                "%.*s...",
                                                (int) (s - origs - 1),
                                                t);
                                    goto out_dump;
                                }
                                *s = ' ';
                            }
                            else if (*s == '\t') {
                                *s = '-';
                            }
                            s++;
                        }
                        if (s[-1] == ' ')
                            s[-1] = 0;
d14867 2
a14868 2
                        sv_catpv(sv, t);
                    }
d14870 1
a14870 1
                out_dump:
d14872 4
a14875 25
                    Safefree(origs);
                    SvREFCNT_dec_NN(lv);
                }

                if ((flags & ANYOF_LOC_FOLD)
                     && only_utf8_locale
                     && only_utf8_locale != &PL_sv_undef)
                {
                    UV start, end;
                    int max_entries = 256;

                    sv_catpvs(sv, "{utf8 locale}");
                    invlist_iterinit(only_utf8_locale);
                    while (invlist_iternext(only_utf8_locale,
                                            &start, &end)) {
                        put_range(sv, start, end);
                        max_entries --;
                        if (max_entries < 0) {
                            sv_catpvs(sv, "...");
                            break;
                        }
                    }
                    invlist_iterfinish(only_utf8_locale);
                }
            }
d14882 2
a14883 8
        if (index < C_ARRAY_LENGTH(anyofs)) {
            if (*anyofs[index] != '[')  {
                sv_catpv(sv, "[");
            }
            sv_catpv(sv, anyofs[index]);
            if (*anyofs[index] != '[')  {
                sv_catpv(sv, "]");
            }
d14886 1
a14886 1
            Perl_sv_catpvf(aTHX_ sv, "[illegal type=%d])", index);
a14895 1
    PERL_UNUSED_ARG(reginfo);
a14898 2


d14928 5
a14932 5
/*
   pregfree()

   handles refcounting and freeing the perl core regexp structure. When
   it is necessary to actually free the structure the first thing it
d14934 2
a14935 2
   the regexp, allowing the handling of the void *pprivate; member
   first. (This routine is not overridable by extensions, which is why
d14937 2
a14938 2

   See regdupe and regdupe_internal if you change anything here.
d14962 1
a14962 1
    }
d14980 1
a14980 1

d14987 2
a14988 2

    The solution is to make a lightweight copy of the regexp structure
d14991 5
a14995 5
    the starp/end and the actual regexp structure itself.

*/


d15028 1
a15028 1

d15059 1
a15059 1

d15064 1
a15064 7
/* regfree_internal()

   Free the private data in a regexp. This is overloadable by
   extensions. Perl takes care of the regexp structure in pregfree(),
   this covers the *pprivate pointer which technically perl doesn't
   know about, however of course we have to handle the
   regexp_internal structure when no extension is in use.
d15066 8
a15073 2
   Note this is called before freeing anything in the regexp
   structure.
d15075 1
a15075 1

d15093 1
a15093 1
            PerlIO_printf(Perl_debug_log,"%sFreeing REx:%s %s\n",
d15127 1
a15127 1
            case 'T':
d15167 1
a15167 2
		Perl_croak(aTHX_ "panic: regfree data code '%c'",
                                                    ri->data->what[n]);
d15181 3
a15183 3
/*
   re_dup - duplicate a regexp.

d15192 1
a15192 1
   See pregfree() and regfree_internal() if you change anything here.
d15203 1
a15203 1

d15270 1
d15276 1
a15276 1

d15281 1
a15281 1
   to this and will be provided as the regexp *r argument, however
d15284 1
a15284 1

d15298 1
a15298 1

d15300 2
a15301 3

    Newxc(reti, sizeof(regexp_internal) + len*sizeof(regnode),
          char, regexp_internal);
d15343 3
a15345 2
		Newx(d->data[i], 1, regnode_ssc);
		StructCopy(ri->data->data[i], d->data[i], regnode_ssc);
d15365 1
a15365 2
		Perl_croak(aTHX_ "panic: re_dup unknown data code '%c'",
                                                           ri->data->what[i]);
d15405 1
a15405 2
	Perl_croak(aTHX_ "Corrupted regexp opcode %d > %d",
                                                (int)OP(p), (int)REGNODE_MAX);
d15417 1
a15417 1
S_re_croak2(pTHX_ bool utf8, const char* pat1,const char* pat2,...)
d15436 2
d15439 3
d15448 2
a15449 2
    /* l1-1 to avoid \n */
    Perl_croak(aTHX_ "%"UTF8f, UTF8fARG(utf8, l1-1, buf));
d15460 23
d15490 1
a15490 2
		const STRLEN len = my_snprintf(digits, sizeof(digits),
                                               "%lu", (long)i);
d15512 13
d15526 6
a15531 11
        switch (c) {
            case '\r': Perl_sv_catpvf(aTHX_ sv, "\\r"); break;
            case '\n': Perl_sv_catpvf(aTHX_ sv, "\\n"); break;
            case '\t': Perl_sv_catpvf(aTHX_ sv, "\\t"); break;
            case '\f': Perl_sv_catpvf(aTHX_ sv, "\\f"); break;
            case '\a': Perl_sv_catpvf(aTHX_ sv, "\\a"); break;

            default:
                Perl_sv_catpvf(aTHX_ sv, "\\x{%x}", c);
                break;
        }
a15540 76
STATIC void
S_put_range(pTHX_ SV *sv, UV start, UV end)
{

    /* Appends to 'sv' a displayable version of the range of code points from
     * 'start' to 'end' */

    assert(start <= end);

    PERL_ARGS_ASSERT_PUT_RANGE;

    if (end - start < 3) {  /* Individual chars in short ranges */
        for (; start <= end; start++)
            put_byte(sv, start);
    }
    else if (   end > 255
             || ! isALPHANUMERIC(start)
             || ! isALPHANUMERIC(end)
             || isDIGIT(start) != isDIGIT(end)
             || isUPPER(start) != isUPPER(end)
             || isLOWER(start) != isLOWER(end)

                /* This final test should get optimized out except on EBCDIC
                 * platforms, where it causes ranges that cross discontinuities
                 * like i/j to be shown as hex instead of the misleading,
                 * e.g. H-K (since that range includes more than H, I, J, K).
                 * */
             || (end - start) != NATIVE_TO_ASCII(end) - NATIVE_TO_ASCII(start))
    {
        Perl_sv_catpvf(aTHX_ sv, "\\x{%02" UVXf "}-\\x{%02" UVXf "}",
                       start,
                       (end < 256) ? end : 255);
    }
    else { /* Here, the ends of the range are both digits, or both uppercase,
              or both lowercase; and there's no discontinuity in the range
              (which could happen on EBCDIC platforms) */
        put_byte(sv, start);
        sv_catpvs(sv, "-");
        put_byte(sv, end);
    }
}

STATIC bool
S_put_latin1_charclass_innards(pTHX_ SV *sv, char *bitmap)
{
    /* Appends to 'sv' a displayable version of the innards of the bracketed
     * character class whose bitmap is 'bitmap';  Returns 'TRUE' if it actually
     * output anything */

    int i;
    bool has_output_anything = FALSE;

    PERL_ARGS_ASSERT_PUT_LATIN1_CHARCLASS_INNARDS;

    for (i = 0; i < 256; i++) {
        if (BITMAP_TEST((U8 *) bitmap,i)) {

            /* The character at index i should be output.  Find the next
             * character that should NOT be output */
            int j;
            for (j = i + 1; j < 256; j++) {
                if (! BITMAP_TEST((U8 *) bitmap, j)) {
                    break;
                }
            }

            /* Everything between them is a single range that should be output
             * */
            put_range(sv, i, j - 1);
            has_output_anything = TRUE;
            i = j;
        }
    }

    return has_output_anything;
}
d15543 3
a15545 4
    if (optstart) STMT_START {                                               \
        DEBUG_OPTIMISE_r(PerlIO_printf(Perl_debug_log,                       \
                              " (%"IVdf" nodes)\n", (IV)(node - optstart))); \
	optstart=NULL;                                                       \
d15548 1
a15548 3
#define DUMPUNTIL(b,e)                                                       \
                    CLEAR_OPTSTART;                                          \
                    node=dumpuntil(r,start,(b),(e),last,sv,indent+1,depth+1);
d15552 1
a15552 1
	    const regnode *last, const regnode *plast,
d15559 1
a15559 1

d15569 2
a15570 2

    if (plast && plast < last)
d15590 1
a15590 1
	regprop(r, sv, node, NULL);
d15593 2
a15594 2

        if (OP(node) != OPTIMIZED) {
d15597 1
a15597 2
            else if (PL_regkind[(U8)op] == BRANCH
                     && PL_regkind[OP(next)] != BRANCH )
d15599 1
a15599 1
            else
d15601 1
a15601 1
            (void)PerlIO_putc(Perl_debug_log, '\n');
d15603 1
a15603 1

d15630 1
a15630 2
	    AV *const trie_words
                           = MUTABLE_AV(ri->data->data[n + TRIE_WORDS_OFFSET]);
d15640 5
a15644 9
                    elem_ptr
                    ? pv_pretty(sv, SvPV_nolen_const(*elem_ptr),
                                SvCUR(*elem_ptr), 60,
                                PL_colors[0], PL_colors[1],
                                (SvUTF8(*elem_ptr)
                                 ? PERL_PV_ESCAPE_UNI
                                 : 0)
                                | PERL_PV_PRETTY_ELLIPSES
                                | PERL_PV_PRETTY_LTGT
d15646 1
a15646 1
                    : "???"
d15651 1
a15651 1
                               (UV)((dist ? this_trie + dist : next) - start));
d15654 1
a15654 1
                            nextbranch= this_trie + trie->jump[0];
d15681 2
a15682 3
	    node += 1 + ((ANYOF_FLAGS(node) & ANYOF_POSIXL)
                          ? ANYOF_POSIXL_SKIP
                          : ANYOF_SKIP);
d15698 1
a15698 1
#ifdef DEBUG_DUMPUNTIL
@


1.1.1.16
log
@Import perl-5.20.2
@
text
@d4809 1
a4809 1
                SV* my_invlist = NULL;
d4908 1
a4908 1
                        my_invlist = invlist_clone(PL_XPosix_ptrs[_CC_ASCII]);
a4944 1
                    SvREFCNT_dec(my_invlist);
d12003 1
a12003 11

                        /* Normally, we don't need the representation of the
                         * character in the sizing pass--just its size, but if
                         * folding, we have to actually put the character out
                         * even in the sizing pass, because the size could
                         * change as we juggle things at the end of this loop
                         * to avoid splitting a too-full node in the middle of
                         * a potential multi-char fold [perl #123539] */
                        const STRLEN unilen = (SIZE_ONLY && ! FOLD)
                                               ? UNISKIP(ender)
                                               : (uvchr_to_utf8((U8*)s, ender) - (U8*)s);
a12014 4
                    }
                    else if (FOLD) {
                        /* See comment above for [perl #123539] */
                        *(s++) = (char) ender;
@


1.1.1.17
log
@Import perl-5.24.2
@
text
@d89 3
a91 2
#include "dquote_inline.h"
#include "invlist_inline.h"
a95 2
#define HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(i) \
 _HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(i)
a102 29
#ifndef MIN
#define MIN(a,b) ((a) < (b) ? (a) : (b))
#endif

#ifndef MAX
#define MAX(a,b) ((a) > (b) ? (a) : (b))
#endif

/* this is a chain of data about sub patterns we are processing that
   need to be handled separately/specially in study_chunk. Its so
   we can simulate recursion without losing state.  */
struct scan_frame;
typedef struct scan_frame {
    regnode *last_regnode;      /* last node to process in this frame */
    regnode *next_regnode;      /* next node to process when last is reached */
    U32 prev_recursed_depth;
    I32 stopparen;              /* what stopparen do we use */
    U32 is_top_frame;           /* what flags do we use? */

    struct scan_frame *this_prev_frame; /* this previous frame */
    struct scan_frame *prev_frame;      /* previous frame */
    struct scan_frame *next_frame;      /* next frame */
} scan_frame;

/* Certain characters are output as a sequence with the first being a
 * backslash. */
#define isBACKSLASHED_PUNCT(c)                                              \
                    ((c) == '-' || (c) == ']' || (c) == '\\' || (c) == '^')

a107 1
    char	*precomp_end;		/* pointer to end of uncompiled string. */
a114 2
    char        *adjusted_start;        /* 'start', adjusted.  See code use */
    STRLEN      precomp_adj;            /* an offset beyond precomp.  See code use */
d138 1
a138 1
    regnode     *end_op;                /* END node in program */
d149 2
a150 2
    I32                recurse_count;                /* Number of recurse regops we have generated */
    U8          *study_chunk_recursed;  /* bitmap of which subs we have moved
a156 3
#ifdef EBCDIC
    I32		recode_x_to_native;
#endif
a162 3
    scan_frame *frame_head;
    scan_frame *frame_last;
    U32         frame_count;
a171 3
    U32         study_chunk_recursed_count;
    SV          *mysv1;
    SV          *mysv2;
a174 5
#define RExC_study_chunk_recursed_count    (pRExC_state->study_chunk_recursed_count)
#define RExC_mysv	(pRExC_state->mysv1)
#define RExC_mysv1	(pRExC_state->mysv1)
#define RExC_mysv2	(pRExC_state->mysv2)

a175 2
    bool        seen_unfolded_sharp_s;
    bool        strict;
a180 3
#define RExC_precomp_adj (pRExC_state->precomp_adj)
#define RExC_adjusted_start  (pRExC_state->adjusted_start)
#define RExC_precomp_end (pRExC_state->precomp_end)
a187 11

/* Set during the sizing pass when there is a LATIN SMALL LETTER SHARP S in any
 * EXACTF node, hence was parsed under /di rules.  If later in the parse,
 * something forces the pattern into using /ui rules, the sharp s should be
 * folded into the sequence 'ss', which takes up more space than previously
 * calculated.  This means that the sizing pass needs to be restarted.  (The
 * node also becomes an EXACTFU_SS.)  For all other characters, an EXACTF node
 * that gets converted to /ui (and EXACTFU) occupies the same amount of space,
 * so there is no need to resize [perl #125990]. */
#define RExC_seen_unfolded_sharp_s (pRExC_state->seen_unfolded_sharp_s)

d196 1
d210 1
a210 1
#define RExC_end_op	(pRExC_state->end_op)
a220 3
#ifdef EBCDIC
#   define RExC_recode_x_to_native (pRExC_state->recode_x_to_native)
#endif
d222 1
a222 18
#define RExC_frame_head (pRExC_state->frame_head)
#define RExC_frame_last (pRExC_state->frame_last)
#define RExC_frame_count (pRExC_state->frame_count)
#define RExC_strict (pRExC_state->strict)

/* Heuristic check on the complexity of the pattern: if TOO_NAUGHTY, we set
 * a flag to disable back-off on the fixed/floating substrings - if it's
 * a high complexity pattern we assume the benefit of avoiding a full match
 * is worth the cost of checking for the substrings even if they rarely help.
 */
#define RExC_naughty	(pRExC_state->naughty)
#define TOO_NAUGHTY (10)
#define MARK_NAUGHTY(add) \
    if (RExC_naughty < TOO_NAUGHTY) \
        RExC_naughty += (add)
#define MARK_NAUGHTY_EXP(exp, add) \
    if (RExC_naughty < TOO_NAUGHTY) \
        RExC_naughty += RExC_naughty / (exp) + (add)
d226 1
a226 1
	((*s) == '{' && regcurly(s)))
d242 1
a242 3
#define RESTART_PASS1   0x20    /* Need to restart sizing pass */
#define NEED_UTF8       0x40    /* In conjunction with RESTART_PASS1, need to
                                   calcuate sizes as UTF-8 */
d261 1
a261 1
#define REQUIRE_UTF8(flagp) STMT_START {                                   \
d263 1
a263 2
                                         assert(PASS1);                    \
                                         *flagp = RESTART_PASS1|NEED_UTF8; \
d266 1
a266 18
                             } STMT_END

/* Change from /d into /u rules, and restart the parse if we've already seen
 * something whose size would increase as a result, by setting *flagp and
 * returning 'restart_retval'.  RExC_uni_semantics is a flag that indicates
 * we've change to /u during the parse.  */
#define REQUIRE_UNI_RULES(flagp, restart_retval)                            \
    STMT_START {                                                            \
            if (DEPENDS_SEMANTICS) {                                        \
                assert(PASS1);                                              \
                set_regex_charset(&RExC_flags, REGEX_UNICODE_CHARSET);      \
                RExC_uni_semantics = 1;                                     \
                if (RExC_seen_unfolded_sharp_s) {                           \
                    *flagp |= RESTART_PASS1;                                \
                    return restart_retval;                                  \
                }                                                           \
            }                                                               \
    } STMT_END
d378 18
a420 12


/* SCF_DO_SUBSTR is the flag that tells the regexp analyzer to track the
 * longest substring in the pattern. When it is not set the optimiser keeps
 * track of position, but does not keep track of the actual strings seen,
 *
 * So for instance /foo/ will be parsed with SCF_DO_SUBSTR being true, but
 * /foo/i will not.
 *
 * Similarly, /foo.*(blah|erm|huh).*fnorble/ will have "foo" and "fnorble"
 * parsed with SCF_DO_SUBSTR on, but while processing the (...) it will be
 * turned off because of the alternation (BRANCH). */
a421 1

a429 4
#define SCF_IN_DEFINE          0x20000



d479 3
a481 65
/* The code in this file in places uses one level of recursion with parsing
 * rebased to an alternate string constructed by us in memory.  This can take
 * the form of something that is completely different from the input, or
 * something that uses the input as part of the alternate.  In the first case,
 * there should be no possibility of an error, as we are in complete control of
 * the alternate string.  But in the second case we don't control the input
 * portion, so there may be errors in that.  Here's an example:
 *      /[abc\x{DF}def]/ui
 * is handled specially because \x{df} folds to a sequence of more than one
 * character, 'ss'.  What is done is to create and parse an alternate string,
 * which looks like this:
 *      /(?:\x{DF}|[abc\x{DF}def])/ui
 * where it uses the input unchanged in the middle of something it constructs,
 * which is a branch for the DF outside the character class, and clustering
 * parens around the whole thing. (It knows enough to skip the DF inside the
 * class while in this substitute parse.) 'abc' and 'def' may have errors that
 * need to be reported.  The general situation looks like this:
 *
 *              sI                       tI               xI       eI
 * Input:       ----------------------------------------------------
 * Constructed:         ---------------------------------------------------
 *                      sC               tC               xC       eC     EC
 *
 * The input string sI..eI is the input pattern.  The string sC..EC is the
 * constructed substitute parse string.  The portions sC..tC and eC..EC are
 * constructed by us.  The portion tC..eC is an exact duplicate of the input
 * pattern tI..eI.  In the diagram, these are vertically aligned.  Suppose that
 * while parsing, we find an error at xC.  We want to display a message showing
 * the real input string.  Thus we need to find the point xI in it which
 * corresponds to xC.  xC >= tC, since the portion of the string sC..tC has
 * been constructed by us, and so shouldn't have errors.  We get:
 *
 *      xI = sI + (tI - sI) + (xC - tC)
 *
 * and, the offset into sI is:
 *
 *      (xI - sI) = (tI - sI) + (xC - tC)
 *
 * When the substitute is constructed, we save (tI -sI) as RExC_precomp_adj,
 * and we save tC as RExC_adjusted_start.
 *
 * During normal processing of the input pattern, everything points to that,
 * with RExC_precomp_adj set to 0, and RExC_adjusted_start set to sI.
 */

#define tI_sI           RExC_precomp_adj
#define tC              RExC_adjusted_start
#define sC              RExC_precomp
#define xI_offset(xC)   ((IV) (tI_sI + (xC - tC)))
#define xI(xC)          (sC + xI_offset(xC))
#define eC              RExC_precomp_end

#define REPORT_LOCATION_ARGS(xC)                                            \
    UTF8fARG(UTF,                                                           \
             (xI(xC) > eC) /* Don't run off end */                          \
              ? eC - sC   /* Length before the <--HERE */                   \
              : xI_offset(xC),                                              \
             sC),         /* The input pattern printed up to the <--HERE */ \
    UTF8fARG(UTF,                                                           \
             (xI(xC) > eC) ? 0 : eC - xI(xC), /* Length after <--HERE */    \
             (xI(xC) > eC) ? eC : xI(xC))     /* pattern after <--HERE */

/* Used to point after bad bytes for an error message, but avoid skipping
 * past a nul byte. */
#define SKIP_IF_CHAR(s) (!*(s) ? 0 : UTF ? UTF8SKIP(s) : 1)
d490 1
a490 1
    IV len = RExC_precomp_end - RExC_precomp;					\
d514 1
d516 1
a516 1
	    m, REPORT_LOCATION_ARGS(RExC_parse));	                \
d532 3
a534 2
    S_re_croak2(aTHX_ UTF, m, REPORT_LOCATION, a1,		\
                      REPORT_LOCATION_ARGS(RExC_parse));	\
d551 1
d553 1
a553 1
	    REPORT_LOCATION_ARGS(RExC_parse));	                \
d569 3
a571 2
    S_re_croak2(aTHX_ UTF, m, REPORT_LOCATION, a1, a2, a3,	\
	    REPORT_LOCATION_ARGS(RExC_parse));	                \
d581 6
a586 12
#define vFAIL2utf8f(m, a1) STMT_START {             \
    if (!SIZE_ONLY)                                 \
        SAVEFREESV(RExC_rx_sv);                     \
    S_re_croak2(aTHX_ UTF, m, REPORT_LOCATION, a1,  \
            REPORT_LOCATION_ARGS(RExC_parse));      \
} STMT_END

#define vFAIL3utf8f(m, a1, a2) STMT_START {             \
    if (!SIZE_ONLY)                                     \
        SAVEFREESV(RExC_rx_sv);                         \
    S_re_croak2(aTHX_ UTF, m, REPORT_LOCATION, a1, a2,  \
            REPORT_LOCATION_ARGS(RExC_parse));          \
a588 5
/* These have asserts in them because of [perl #122671] Many warnings in
 * regcomp.c can occur twice.  If they get output in pass1 and later in that
 * pass, the pattern has to be converted to UTF-8 and the pass restarted, they
 * would get output again.  So they should be output in pass2, and these
 * asserts make sure new warnings follow that paradigm. */
d592 3
a594 3
    __ASSERT_(PASS2) Perl_warner(aTHX_ packWARN(WARN_REGEXP),           \
                                       "%s" REPORT_LOCATION,            \
                                  m, REPORT_LOCATION_ARGS(loc));        \
d598 3
a600 9
    __ASSERT_(PASS2) Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP),        \
                                          m REPORT_LOCATION,	        \
	                                  REPORT_LOCATION_ARGS(loc));   \
} STMT_END

#define	vWARN(loc, m) STMT_START {				        \
    __ASSERT_(PASS2) Perl_warner(aTHX_ packWARN(WARN_REGEXP),           \
                                       m REPORT_LOCATION,               \
                                       REPORT_LOCATION_ARGS(loc));      \
d604 3
a606 3
    __ASSERT_(PASS2) Perl_warner(aTHX_ packWARN(WARN_DEPRECATED),       \
                                       m REPORT_LOCATION,               \
	                               REPORT_LOCATION_ARGS(loc));      \
d610 4
a613 3
    __ASSERT_(PASS2) Perl_ck_warner_d(aTHX_ packWARN(WARN_DEPRECATED),  \
	                                    m REPORT_LOCATION,          \
	                                    REPORT_LOCATION_ARGS(loc)); \
d616 5
a620 5
#define	ckWARNregdep(loc,m) STMT_START {				    \
    __ASSERT_(PASS2) Perl_ck_warner_d(aTHX_ packWARN2(WARN_DEPRECATED,      \
                                                      WARN_REGEXP),         \
	                                     m REPORT_LOCATION,             \
	                                     REPORT_LOCATION_ARGS(loc));    \
d623 5
a627 4
#define	ckWARN2reg_d(loc,m, a1) STMT_START {				    \
    __ASSERT_(PASS2) Perl_ck_warner_d(aTHX_ packWARN(WARN_REGEXP),          \
	                                    m REPORT_LOCATION,              \
	                                    a1, REPORT_LOCATION_ARGS(loc)); \
d630 4
a633 4
#define	ckWARN2reg(loc, m, a1) STMT_START {                                 \
    __ASSERT_(PASS2) Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP),            \
                                          m REPORT_LOCATION,	            \
                                          a1, REPORT_LOCATION_ARGS(loc));   \
d636 4
a639 4
#define	vWARN3(loc, m, a1, a2) STMT_START {				    \
    __ASSERT_(PASS2) Perl_warner(aTHX_ packWARN(WARN_REGEXP),               \
                                       m REPORT_LOCATION,                   \
	                               a1, a2, REPORT_LOCATION_ARGS(loc));  \
d642 4
a645 5
#define	ckWARN3reg(loc, m, a1, a2) STMT_START {				    \
    __ASSERT_(PASS2) Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP),            \
                                          m REPORT_LOCATION,                \
	                                  a1, a2,                           \
                                          REPORT_LOCATION_ARGS(loc));       \
d649 3
a651 4
    __ASSERT_(PASS2) Perl_warner(aTHX_ packWARN(WARN_REGEXP),           \
                                       m REPORT_LOCATION,               \
	                               a1, a2, a3,                      \
                                       REPORT_LOCATION_ARGS(loc));      \
d655 3
a657 4
    __ASSERT_(PASS2) Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP),        \
                                          m REPORT_LOCATION,            \
	                                  a1, a2, a3,                   \
                                          REPORT_LOCATION_ARGS(loc));   \
d661 9
a669 4
    __ASSERT_(PASS2) Perl_warner(aTHX_ packWARN(WARN_REGEXP),           \
                                       m REPORT_LOCATION,		\
	                               a1, a2, a3, a4,                  \
                                       REPORT_LOCATION_ARGS(loc));      \
d742 1
a742 30
#ifdef DEBUGGING
int
Perl_re_printf(pTHX_ const char *fmt, ...)
{
    va_list ap;
    int result;
    PerlIO *f= Perl_debug_log;
    PERL_ARGS_ASSERT_RE_PRINTF;
    va_start(ap, fmt);
    result = PerlIO_vprintf(f, fmt, ap);
    va_end(ap);
    return result;
}

int
Perl_re_indentf(pTHX_ const char *fmt, U32 depth, ...)
{
    va_list ap;
    int result;
    PerlIO *f= Perl_debug_log;
    PERL_ARGS_ASSERT_RE_INDENTF;
    va_start(ap, depth);
    PerlIO_printf(f, "%*s", ( (int)depth % 20 ) * 2, "");
    result = PerlIO_vprintf(f, fmt, ap);
    va_end(ap);
    return result;
}
#endif /* DEBUGGING */

#define DEBUG_RExC_seen()                                                   \
d744 1
a744 1
            Perl_re_printf( aTHX_ "RExC_seen: ");                                       \
d747 1
a747 1
                Perl_re_printf( aTHX_ "REG_ZERO_LEN_SEEN ");                            \
d750 1
a750 1
                Perl_re_printf( aTHX_ "REG_LOOKBEHIND_SEEN ");                          \
d753 4
a756 1
                Perl_re_printf( aTHX_ "REG_GPOS_SEEN ");                                \
d759 1
a759 1
                Perl_re_printf( aTHX_ "REG_RECURSE_SEEN ");                             \
d761 2
a762 2
            if (RExC_seen & REG_TOP_LEVEL_BRANCHES_SEEN)                    \
                Perl_re_printf( aTHX_ "REG_TOP_LEVEL_BRANCHES_SEEN ");                  \
d765 1
a765 1
                Perl_re_printf( aTHX_ "REG_VERBARG_SEEN ");                             \
d768 1
a768 1
                Perl_re_printf( aTHX_ "REG_CUTGROUP_SEEN ");                            \
d771 1
a771 1
                Perl_re_printf( aTHX_ "REG_RUN_ON_COMMENT_SEEN ");                      \
d774 4
a777 1
                Perl_re_printf( aTHX_ "REG_UNFOLDED_MULTI_SEEN ");                      \
d779 2
a780 2
            if (RExC_seen & REG_UNBOUNDED_QUANTIFIER_SEEN)                  \
                Perl_re_printf( aTHX_ "REG_UNBOUNDED_QUANTIFIER_SEEN ");                \
d782 1
a782 1
            Perl_re_printf( aTHX_ "\n");                                                \
a784 25
#define DEBUG_SHOW_STUDY_FLAG(flags,flag) \
  if ((flags) & flag) Perl_re_printf( aTHX_  "%s ", #flag)

#define DEBUG_SHOW_STUDY_FLAGS(flags,open_str,close_str)                    \
    if ( ( flags ) ) {                                                      \
        Perl_re_printf( aTHX_  "%s", open_str);                                         \
        DEBUG_SHOW_STUDY_FLAG(flags,SF_FL_BEFORE_SEOL);                     \
        DEBUG_SHOW_STUDY_FLAG(flags,SF_FL_BEFORE_MEOL);                     \
        DEBUG_SHOW_STUDY_FLAG(flags,SF_IS_INF);                             \
        DEBUG_SHOW_STUDY_FLAG(flags,SF_HAS_PAR);                            \
        DEBUG_SHOW_STUDY_FLAG(flags,SF_IN_PAR);                             \
        DEBUG_SHOW_STUDY_FLAG(flags,SF_HAS_EVAL);                           \
        DEBUG_SHOW_STUDY_FLAG(flags,SCF_DO_SUBSTR);                         \
        DEBUG_SHOW_STUDY_FLAG(flags,SCF_DO_STCLASS_AND);                    \
        DEBUG_SHOW_STUDY_FLAG(flags,SCF_DO_STCLASS_OR);                     \
        DEBUG_SHOW_STUDY_FLAG(flags,SCF_DO_STCLASS);                        \
        DEBUG_SHOW_STUDY_FLAG(flags,SCF_WHILEM_VISITED_POS);                \
        DEBUG_SHOW_STUDY_FLAG(flags,SCF_TRIE_RESTUDY);                      \
        DEBUG_SHOW_STUDY_FLAG(flags,SCF_SEEN_ACCEPT);                       \
        DEBUG_SHOW_STUDY_FLAG(flags,SCF_TRIE_DOING_RESTUDY);                \
        DEBUG_SHOW_STUDY_FLAG(flags,SCF_IN_DEFINE);                         \
        Perl_re_printf( aTHX_  "%s", close_str);                                        \
    }


d787 4
a790 3
    Perl_re_indentf( aTHX_  "" str "Pos:%"IVdf"/%"IVdf                           \
        " Flags: 0x%"UVXf,                                           \
        depth,                                                       \
d793 1
a793 5
        (UV)((data)->flags)                                          \
    );                                                               \
    DEBUG_SHOW_STUDY_FLAGS((data)->flags," [ ","]");                 \
    Perl_re_printf( aTHX_                                                        \
        " Whilem_c: %"IVdf" Lcp: %"IVdf" %s",                        \
d799 1
a799 1
        Perl_re_printf( aTHX_                                                    \
d816 1
a816 1
    Perl_re_printf( aTHX_ "\n");                                                 \
a818 169

/* =========================================================
 * BEGIN edit_distance stuff.
 *
 * This calculates how many single character changes of any type are needed to
 * transform a string into another one.  It is taken from version 3.1 of
 *
 * https://metacpan.org/pod/Text::Levenshtein::Damerau::XS
 */

/* Our unsorted dictionary linked list.   */
/* Note we use UVs, not chars. */

struct dictionary{
  UV key;
  UV value;
  struct dictionary* next;
};
typedef struct dictionary item;


PERL_STATIC_INLINE item*
push(UV key,item* curr)
{
    item* head;
    Newxz(head, 1, item);
    head->key = key;
    head->value = 0;
    head->next = curr;
    return head;
}


PERL_STATIC_INLINE item*
find(item* head, UV key)
{
    item* iterator = head;
    while (iterator){
        if (iterator->key == key){
            return iterator;
        }
        iterator = iterator->next;
    }

    return NULL;
}

PERL_STATIC_INLINE item*
uniquePush(item* head,UV key)
{
    item* iterator = head;

    while (iterator){
        if (iterator->key == key) {
            return head;
        }
        iterator = iterator->next;
    }

    return push(key,head);
}

PERL_STATIC_INLINE void
dict_free(item* head)
{
    item* iterator = head;

    while (iterator) {
        item* temp = iterator;
        iterator = iterator->next;
        Safefree(temp);
    }

    head = NULL;
}

/* End of Dictionary Stuff */

/* All calculations/work are done here */
STATIC int
S_edit_distance(const UV* src,
                const UV* tgt,
                const STRLEN x,             /* length of src[] */
                const STRLEN y,             /* length of tgt[] */
                const SSize_t maxDistance
)
{
    item *head = NULL;
    UV swapCount,swapScore,targetCharCount,i,j;
    UV *scores;
    UV score_ceil = x + y;

    PERL_ARGS_ASSERT_EDIT_DISTANCE;

    /* intialize matrix start values */
    Newxz(scores, ( (x + 2) * (y + 2)), UV);
    scores[0] = score_ceil;
    scores[1 * (y + 2) + 0] = score_ceil;
    scores[0 * (y + 2) + 1] = score_ceil;
    scores[1 * (y + 2) + 1] = 0;
    head = uniquePush(uniquePush(head,src[0]),tgt[0]);

    /* work loops    */
    /* i = src index */
    /* j = tgt index */
    for (i=1;i<=x;i++) {
        if (i < x)
            head = uniquePush(head,src[i]);
        scores[(i+1) * (y + 2) + 1] = i;
        scores[(i+1) * (y + 2) + 0] = score_ceil;
        swapCount = 0;

        for (j=1;j<=y;j++) {
            if (i == 1) {
                if(j < y)
                head = uniquePush(head,tgt[j]);
                scores[1 * (y + 2) + (j + 1)] = j;
                scores[0 * (y + 2) + (j + 1)] = score_ceil;
            }

            targetCharCount = find(head,tgt[j-1])->value;
            swapScore = scores[targetCharCount * (y + 2) + swapCount] + i - targetCharCount - 1 + j - swapCount;

            if (src[i-1] != tgt[j-1]){
                scores[(i+1) * (y + 2) + (j + 1)] = MIN(swapScore,(MIN(scores[i * (y + 2) + j], MIN(scores[(i+1) * (y + 2) + j], scores[i * (y + 2) + (j + 1)])) + 1));
            }
            else {
                swapCount = j;
                scores[(i+1) * (y + 2) + (j + 1)] = MIN(scores[i * (y + 2) + j], swapScore);
            }
        }

        find(head,src[i-1])->value = i;
    }

    {
        IV score = scores[(x+1) * (y + 2) + (y + 1)];
        dict_free(head);
        Safefree(scores);
        return (maxDistance != 0 && maxDistance < score)?(-1):score;
    }
}

/* END of edit_distance() stuff
 * ========================================================= */

/* is c a control character for which we have a mnemonic? */
#define isMNEMONIC_CNTRL(c) _IS_MNEMONIC_CNTRL_ONLY_FOR_USE_BY_REGCOMP_DOT_C(c)

STATIC const char *
S_cntrl_to_mnemonic(const U8 c)
{
    /* Returns the mnemonic string that represents character 'c', if one
     * exists; NULL otherwise.  The only ones that exist for the purposes of
     * this routine are a few control characters */

    switch (c) {
        case '\a':       return "\\a";
        case '\b':       return "\\b";
        case ESC_NATIVE: return "\\e";
        case '\f':       return "\\f";
        case '\n':       return "\\n";
        case '\r':       return "\\r";
        case '\t':       return "\\t";
    }

    return NULL;
}

d848 2
a849 2
                          ? data->last_start_max
                          : (data->pos_delta > SSize_t_MAX - data->pos_min
d892 1
a892 1
    ANYOF_FLAGS(ssc) |= SSC_MATCHES_EMPTY_STRING;  /* Plus matches empty */
d896 1
a896 1
S_ssc_is_anything(const regnode_ssc *ssc)
d910 1
a910 1
    if (! (ANYOF_FLAGS(ssc) & SSC_MATCHES_EMPTY_STRING)) {
d949 1
a949 1
    ARG_SET(ssc, ANYOF_ONLY_HAS_BITMAP);
d952 7
a958 7
    /* If any portion of the regex is to operate under locale rules that aren't
     * fully known at compile time, initialization includes it.  The reason
     * this isn't done for all regexes is that the optimizer was written under
     * the assumption that locale was all-or-nothing.  Given the complexity and
     * lack of documentation in the optimizer, and that there are inadequate
     * test cases for locale, many parts of it may not work properly, it is
     * safest to avoid locale unless necessary. */
d968 2
a969 2
S_ssc_is_cp_posixl_init(const RExC_state_t *pRExC_state,
                        const regnode_ssc *ssc)
d1010 1
a1010 1
    SV* invlist = NULL;
d1019 1
a1019 1
    if (n != ANYOF_ONLY_HAS_BITMAP) {
a1031 1
            invlist = sv_2mortal(_new_invlist(1));
d1042 1
a1042 1
        if ((ANYOF_FLAGS(node) & ANYOFL_FOLD)
d1049 9
a1057 14
    if (! invlist) {
        invlist = sv_2mortal(_new_invlist(0));
    }

    /* An ANYOF node contains a bitmap for the first NUM_ANYOF_CODE_POINTS
     * code points, and an inversion list for the others, but if there are code
     * points that should match only conditionally on the target string being
     * UTF-8, those are placed in the inversion list, and not the bitmap.
     * Since there are circumstances under which they could match, they are
     * included in the SSC.  But if the ANYOF node is to be inverted, we have
     * to exclude them here, so that when we invert below, the end result
     * actually does include them.  (Think about "\xe0" =~ /[^\xc0]/di;).  We
     * have to do this here before we add the unconditionally matched code
     * points */
d1065 1
a1065 1
    for (i = 0; i < NUM_ANYOF_CODE_POINTS; i++) {
d1067 1
a1067 6
            unsigned int start = i++;

            for (; i < NUM_ANYOF_CODE_POINTS && ANYOF_BITMAP_TEST(node, i); ++i) {
                /* empty */
            }
            invlist = _add_range_to_invlist(invlist, start, i-1);
d1073 2
a1074 6
     * as well.  But don't add them if inverting, as when that gets done below,
     * it would exclude all these characters, including the ones it shouldn't
     * that were added just above */
    if (! (ANYOF_FLAGS(node) & ANYOF_INVERT) && OP(node) == ANYOFD
        && (ANYOF_FLAGS(node) & ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER))
    {
d1079 2
a1080 2
    if (ANYOF_FLAGS(node) & ANYOF_MATCHES_ALL_ABOVE_BITMAP) {
        _invlist_union_complement_2nd(invlist, PL_InBitmap, &invlist);
d1086 1
a1086 1
    else if (new_node_has_latin1 && ANYOF_FLAGS(node) & ANYOFL_FOLD) {
d1113 2
a1114 2
 * should not be inverted.  'and_with->flags & ANYOF_MATCHES_POSIXL' should be
 * 0 if 'and_with' is a regnode_charclass instead of a regnode_ssc. */
d1152 1
a1152 1
            anded_flags |= ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER;
d1157 1
a1157 13
        if (OP(and_with) == ANYOFD) {
            anded_flags = ANYOF_FLAGS(and_with) & ANYOF_COMMON_FLAGS;
        }
        else {
            anded_flags = ANYOF_FLAGS(and_with)
            &( ANYOF_COMMON_FLAGS
              |ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER
              |ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP);
            if (ANYOFL_UTF8_LOCALE_REQD(ANYOF_FLAGS(and_with))) {
                anded_flags &=
                    ANYOFL_SHARED_UTF8_LOCALE_fold_HAS_MATCHES_nonfold_REQD;
            }
        }
d1205 1
a1205 1
        if (! (ANYOF_FLAGS(and_with) & ANYOF_MATCHES_POSIXL)) {
d1264 1
a1264 1
                if (ANYOF_FLAGS(and_with) & ANYOF_MATCHES_POSIXL) {
d1270 1
a1270 1
                 || (ANYOF_FLAGS(and_with) & ANYOF_MATCHES_POSIXL))
d1273 1
a1273 1
            if (ANYOF_FLAGS(and_with) & ANYOF_MATCHES_POSIXL) {
a1307 10
        if (OP(or_with) != ANYOFD) {
            ored_flags
            |= ANYOF_FLAGS(or_with)
             & ( ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER
                |ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP);
            if (ANYOFL_UTF8_LOCALE_REQD(ANYOF_FLAGS(or_with))) {
                ored_flags |=
                    ANYOFL_SHARED_UTF8_LOCALE_fold_HAS_MATCHES_nonfold_REQD;
            }
        }
d1335 1
a1335 1
    else if (ANYOF_FLAGS(or_with) & ANYOF_MATCHES_POSIXL) {
d1413 1
a1413 1
S_ssc_clear_locale(regnode_ssc *ssc)
d1416 1
a1424 58
#define NON_OTHER_COUNT   NON_OTHER_COUNT_FOR_USE_ONLY_BY_REGCOMP_DOT_C

STATIC bool
S_is_ssc_worth_it(const RExC_state_t * pRExC_state, const regnode_ssc * ssc)
{
    /* The synthetic start class is used to hopefully quickly winnow down
     * places where a pattern could start a match in the target string.  If it
     * doesn't really narrow things down that much, there isn't much point to
     * having the overhead of using it.  This function uses some very crude
     * heuristics to decide if to use the ssc or not.
     *
     * It returns TRUE if 'ssc' rules out more than half what it considers to
     * be the "likely" possible matches, but of course it doesn't know what the
     * actual things being matched are going to be; these are only guesses
     *
     * For /l matches, it assumes that the only likely matches are going to be
     *      in the 0-255 range, uniformly distributed, so half of that is 127
     * For /a and /d matches, it assumes that the likely matches will be just
     *      the ASCII range, so half of that is 63
     * For /u and there isn't anything matching above the Latin1 range, it
     *      assumes that that is the only range likely to be matched, and uses
     *      half that as the cut-off: 127.  If anything matches above Latin1,
     *      it assumes that all of Unicode could match (uniformly), except for
     *      non-Unicode code points and things in the General Category "Other"
     *      (unassigned, private use, surrogates, controls and formats).  This
     *      is a much large number. */

    U32 count = 0;      /* Running total of number of code points matched by
                           'ssc' */
    UV start, end;      /* Start and end points of current range in inversion
                           list */
    const U32 max_code_points = (LOC)
                                ?  256
                                : ((   ! UNI_SEMANTICS
                                     || invlist_highest(ssc->invlist) < 256)
                                  ? 128
                                  : NON_OTHER_COUNT);
    const U32 max_match = max_code_points / 2;

    PERL_ARGS_ASSERT_IS_SSC_WORTH_IT;

    invlist_iterinit(ssc->invlist);
    while (invlist_iternext(ssc->invlist, &start, &end)) {
        if (start >= max_code_points) {
            break;
        }
        end = MIN(end, max_code_points - 1);
        count += end - start + 1;
        if (count >= max_match) {
            invlist_iterfinish(ssc->invlist);
            return FALSE;
        }
    }

    return TRUE;
}


d1430 1
a1430 2
     * ANYOF node, with the first NUM_ANYOF_CODE_POINTS code points in a bit
     * map */
d1439 3
a1441 6
     * to the SSC, except SSC_MATCHES_EMPTY_STRING, which should be cleared
     * by the time we reach here */
    assert(! (ANYOF_FLAGS(ssc)
        & ~( ANYOF_COMMON_FLAGS
            |ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER
            |ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP)));
d1452 1
a1452 5
        ANYOF_FLAGS(ssc) |= ANYOF_MATCHES_POSIXL;
    }

    if (RExC_contains_locale) {
        OP(ssc) = ANYOFL;
d1499 3
a1501 2
    Perl_re_indentf( aTHX_  "Char : %-6s%-6s%-4s ",
        depth+1, "Match","Base","Ofs" );
d1506 1
a1506 1
            Perl_re_printf( aTHX_  "%*s",
d1516 2
a1517 2
    Perl_re_printf( aTHX_  "\n");
    Perl_re_indentf( aTHX_ "State|-----------------------", depth+1);
d1520 2
a1521 2
        Perl_re_printf( aTHX_  "%.*s", colwidth, "--------");
    Perl_re_printf( aTHX_  "\n");
d1526 2
a1527 1
        Perl_re_indentf( aTHX_  "#%4"UVXf"|", depth+1, (UV)state);
d1530 2
a1531 1
            Perl_re_printf( aTHX_  " W%4X", trie->states[ state ].wordnum );
d1533 1
a1533 1
            Perl_re_printf( aTHX_  "%6s", "" );
d1536 1
a1536 1
        Perl_re_printf( aTHX_  " @@%4"UVXf" ", (UV)base );
d1547 1
a1547 1
            Perl_re_printf( aTHX_  "+%2"UVXf"[ ", (UV)ofs);
d1556 4
a1559 3
                   Perl_re_printf( aTHX_  "%*"UVXf, colwidth,
                    (UV)trie->trans[ base + ofs - trie->uniquecharcount ].next
                   );
d1561 1
a1561 1
                    Perl_re_printf( aTHX_  "%*s",colwidth,"   ." );
d1565 1
a1565 1
            Perl_re_printf( aTHX_  "]");
d1568 1
a1568 1
        Perl_re_printf( aTHX_  "\n" );
d1570 2
a1571 2
    Perl_re_indentf( aTHX_  "word_info N:(prev,len)=",
                                depth);
d1573 1
a1573 1
        Perl_re_printf( aTHX_  " %d:(%d,%d)",
d1577 1
a1577 1
    Perl_re_printf( aTHX_  "\n" );
d1598 3
a1600 4
    Perl_re_indentf( aTHX_  "State :Word | Transition Data\n",
            depth+1 );
    Perl_re_indentf( aTHX_  "%s",
            depth+1, "------:-----+-----------------\n" );
d1605 2
a1606 2
        Perl_re_indentf( aTHX_  " %4"UVXf" :",
            depth+1, (UV)state  );
d1608 1
a1608 1
            Perl_re_printf( aTHX_  "%5s| ","");
d1610 1
a1610 1
            Perl_re_printf( aTHX_  "W%4x| ",
d1618 1
a1618 1
                Perl_re_printf( aTHX_  "%*s:%3X=%4"UVXf" | ",
d1630 1
a1630 1
                    Perl_re_printf( aTHX_  "\n%*s| ",
d1634 1
a1634 1
        Perl_re_printf( aTHX_  "\n");
d1662 1
a1662 1
    Perl_re_indentf( aTHX_  "Char : ", depth+1 );
d1667 1
a1667 1
            Perl_re_printf( aTHX_  "%*s",
d1678 1
a1678 2
    Perl_re_printf( aTHX_ "\n");
    Perl_re_indentf( aTHX_  "State+-", depth+1 );
d1681 1
a1681 1
        Perl_re_printf( aTHX_  "%.*s", colwidth,"--------");
d1684 1
a1684 1
    Perl_re_printf( aTHX_  "\n" );
d1688 2
a1689 2
        Perl_re_indentf( aTHX_  "%4"UVXf" : ",
            depth+1,
d1695 1
a1695 1
                Perl_re_printf( aTHX_  "%*"UVXf, colwidth, v );
d1697 1
a1697 1
                Perl_re_printf( aTHX_  "%*s", colwidth, "." );
d1700 1
a1700 1
            Perl_re_printf( aTHX_  " (%4"UVXf")\n",
d1703 1
a1703 1
            Perl_re_printf( aTHX_  " (%4"UVXf") W%4X\n",
d1721 1
a1721 1
  flags      : currently the OP() type we will be building one of /EXACT(|F|FA|FU|FU_SS|L|FLU8)/
d1754 1
a1754 1
rest of the regex in the order in which they occurred in the alternation.
d1833 1
a1833 1
            SV *zlopp = newSV(UTF8_MAXBYTES);				   \
d1950 1
d1986 1
a1986 1
        case EXACT: case EXACTL: break;
d1989 1
a1989 2
	case EXACTFU:
	case EXACTFLU8: folder = PL_fold_latin1; break;
d2000 1
a2000 1
    if (flags == EXACT || flags == EXACTL)
a2009 1
    assert(re_trie_maxbuff);
d2014 3
a2016 3
        Perl_re_indentf( aTHX_
          "make_trie start==%d, first==%d, last==%d, tail==%d depth=%d\n",
          depth+1,
d2055 2
a2056 2
        const U8 *uc;
        const U8 *e;
d2066 9
a2074 10
            if (noper_next < tail)
                noper= noper_next;
        }

        if ( noper < tail && ( OP(noper) == flags || ( flags == EXACTFU && OP(noper) == EXACTFU_SS ) ) ) {
            uc= (U8*)STRING(noper);
            e= uc + STR_LEN(noper);
        } else {
            trie->minlen= 0;
            continue;
a2076 1

d2219 3
a2221 3
        Perl_re_indentf( aTHX_
                "TRIE(%s): W:%d C:%d Uq:%d Min:%d Max:%d\n",
                depth+1,
d2269 3
a2271 2
        DEBUG_TRIE_COMPILE_MORE_r( Perl_re_indentf( aTHX_  "Compiling trie using list compiler\n",
            depth+1));
d2282 2
d2290 5
a2294 2
                if (noper_next < tail)
                    noper= noper_next;
d2297 1
a2297 4
            if ( noper < tail && ( OP(noper) == flags || ( flags == EXACTFU && OP(noper) == EXACTFU_SS ) ) ) {
                const U8 *uc= (U8*)STRING(noper);
                const U8 *e= uc + STR_LEN(noper);

d2379 1
a2379 1
                    Perl_re_printf( aTHX_  "tp: %d zp: %d ",tp,zp)
d2441 1
a2441 1
                    Perl_re_printf( aTHX_  " base: %d\n",base);
d2484 3
a2486 2
        DEBUG_TRIE_COMPILE_MORE_r( Perl_re_indentf( aTHX_  "Compiling trie using table compiler\n",
            depth+1));
d2501 2
d2513 5
a2517 2
                if (noper_next < tail)
                    noper= noper_next;
d2520 1
a2520 4
            if ( noper < tail && ( OP(noper) == flags || ( flags == EXACTFU && OP(noper) == EXACTFU_SS ) ) ) {
                const U8 *uc= (U8*)STRING(noper);
                const U8 *e= uc + STR_LEN(noper);

d2678 3
a2680 2
            Perl_re_indentf( aTHX_  "Alloc: %d Orig: %"IVdf" elements, Final:%"IVdf". Savings of %%%5.2f\n",
                depth+1,
d2691 3
a2693 2
            Perl_re_indentf( aTHX_  "Statecount:%"UVxf" Lasttrans:%"UVxf"\n",
                depth+1,
d2743 3
a2745 2
            Perl_re_indentf( aTHX_  "MJD offset:%"UVuf" MJD length:%"UVuf"\n",
                depth+1,
d2775 3
a2777 2
                                    Perl_re_indentf( aTHX_  "New Start State=%"UVuf" Class: [",
                                        depth+1,
d2787 1
a2787 1
                                        Perl_re_printf( aTHX_  "%s", (char*)ch)
d2794 1
a2794 1
                            DEBUG_OPTIMISE_r(Perl_re_printf( aTHX_ "%s", ch));
d2805 3
a2807 2
                        Perl_re_indentf( aTHX_  "Prefix State: %"UVuf" Idx:%"UVuf" Char='%s'\n",
                            depth+1,
d2827 1
a2827 1
                        DEBUG_OPTIMISE_r(Perl_re_printf( aTHX_ "]\n"));
d2984 2
a2985 2
STATIC regnode *
S_construct_ahocorasick_from_trie(pTHX_ RExC_state_t *pRExC_state, regnode *source, U32 depth)
a3022 1
    regnode *stclass;
d3025 1
a3025 2
    PERL_ARGS_ASSERT_CONSTRUCT_AHOCORASICK_FROM_TRIE;
    PERL_UNUSED_CONTEXT;
a3029 12
    if ( OP(source) == TRIE ) {
        struct regnode_1 *op = (struct regnode_1 *)
            PerlMemShared_calloc(1, sizeof(struct regnode_1));
        StructCopy(source,op,struct regnode_1);
        stclass = (regnode *)op;
    } else {
        struct regnode_charclass *op = (struct regnode_charclass *)
            PerlMemShared_calloc(1, sizeof(struct regnode_charclass));
        StructCopy(source,op,struct regnode_charclass);
        stclass = (regnode *)op;
    }
    OP(stclass)+=2; /* convert the TRIE type to its AHO-CORASICK equivalent */
d3085 3
a3087 2
        Perl_re_indentf( aTHX_  "Stclass Failtable (%"UVuf" states): 0",
                      depth, (UV)numstates
d3090 1
a3090 1
            Perl_re_printf( aTHX_  ", %"UVuf, (UV)fail[q_read]);
d3092 1
a3092 1
        Perl_re_printf( aTHX_  "\n");
a3095 1
    return stclass;
d3099 8
a3106 9
#define DEBUG_PEEP(str,scan,depth)         \
    DEBUG_OPTIMISE_r({if (scan){           \
       regnode *Next = regnext(scan);      \
       regprop(RExC_rx, RExC_mysv, scan, NULL, pRExC_state);\
       Perl_re_indentf( aTHX_  "" str ">%3d: %s (%d)", \
           depth, REG_NODE_NUM(scan), SvPV_nolen_const(RExC_mysv),\
           Next ? (REG_NODE_NUM(Next)) : 0 );\
       DEBUG_SHOW_STUDY_FLAGS(flags," [ ","]");\
       Perl_re_printf( aTHX_  "\n");                   \
d3109 1
a3119 8
 * XXX khw thinks this should be enhanced to fill EXACT (at least) nodes as full
 * as possible, even if that means splitting an existing node so that its first
 * part is moved to the preceeding node.  This would maximise the efficiency of
 * memEQ during matching.  Elsewhere in this file, khw proposes splitting
 * EXACTFish nodes into portions that don't change under folding vs those that
 * do.  Those portions that don't change may be the only things in the pattern that
 * could be used to find fixed and floating strings.
 *
d3327 1
a3327 1
    if (OP(scan) != EXACT && OP(scan) != EXACTL) {
d3419 3
a3421 3
                    /* Count how many characters are in it.  In the case of
                     * /aa, no folds which contain ASCII code points are
                     * allowed, so check for those, and skip if found. */
a3467 3
#if    UNICODE_MAJOR_VERSION > 3 /* no multifolds in early Unicode */   \
   || (UNICODE_MAJOR_VERSION == 3 && (   UNICODE_DOT_VERSION > 0)       \
                                      || UNICODE_DOT_DOT_VERSION > 0)
d3475 1
d3503 2
a3504 2
                    && isALPHA_FOLD_EQ(*s, 's')
                    && isALPHA_FOLD_EQ(*(s+1), 's'))
a3520 1
#endif
d3550 11
a3560 11

static void
S_unwind_scan_frames(pTHX_ const void *p)
{
    scan_frame *f= (scan_frame *)p;
    do {
        scan_frame *n= f->next_frame;
        Safefree(f);
        f= n;
    } while (f);
}
d3580 1
d3598 3
a3600 1

a3607 37
    DEBUG_r(
        RExC_study_chunk_recursed_count++;
    );
    DEBUG_OPTIMISE_MORE_r(
    {
        Perl_re_indentf( aTHX_  "study_chunk stopparen=%ld recursed_count=%lu depth=%lu recursed_depth=%lu scan=%p last=%p",
            depth, (long)stopparen,
            (unsigned long)RExC_study_chunk_recursed_count,
            (unsigned long)depth, (unsigned long)recursed_depth,
            scan,
            last);
        if (recursed_depth) {
            U32 i;
            U32 j;
            for ( j = 0 ; j < recursed_depth ; j++ ) {
                for ( i = 0 ; i < (U32)RExC_npar ; i++ ) {
                    if (
                        PAREN_TEST(RExC_study_chunk_recursed +
                                   ( j * RExC_study_chunk_recursed_bytes), i )
                        && (
                            !j ||
                            !PAREN_TEST(RExC_study_chunk_recursed +
                                   (( j - 1 ) * RExC_study_chunk_recursed_bytes), i)
                        )
                    ) {
                        Perl_re_printf( aTHX_ " %d",(int)i);
                        break;
                    }
                }
                if ( j + 1 < recursed_depth ) {
                    Perl_re_printf( aTHX_  ",");
                }
            }
        }
        Perl_re_printf( aTHX_ "\n");
    }
    );
d3614 23
d3641 3
a3643 4
        /* The reason we do this here is that we need to deal with things like
         * /(?:f)(?:o)(?:o)/ which cant be dealt with by the normal EXACT
         * parsing code, as each (?:..) is handled by a different invocation of
         * reg() -- Yves
d3670 2
d3674 2
a3675 31
        if ( OP(scan) == DEFINEP ) {
            SSize_t minlen = 0;
            SSize_t deltanext = 0;
            SSize_t fake_last_close = 0;
            I32 f = SCF_IN_DEFINE;

            StructCopy(&zero_scan_data, &data_fake, scan_data_t);
            scan = regnext(scan);
            assert( OP(scan) == IFTHEN );
            DEBUG_PEEP("expect IFTHEN", scan, depth);

            data_fake.last_closep= &fake_last_close;
            minlen = *minlenp;
            next = regnext(scan);
            scan = NEXTOPER(NEXTOPER(scan));
            DEBUG_PEEP("scan", scan, depth);
            DEBUG_PEEP("next", next, depth);

            /* we suppose the run is continuous, last=next...
             * NOTE we dont use the return here! */
            (void)study_chunk(pRExC_state, &scan, &minlen,
                              &deltanext, next, &data_fake, stopparen,
                              recursed_depth, NULL, f, depth+1);

            scan = next;
        } else
        if (
            OP(scan) == BRANCH  ||
            OP(scan) == BRANCHJ ||
            OP(scan) == IFTHEN
        ) {
d3678 2
a3680 5
            /* The op(next)==code check below is to see if we
             * have "BRANCH-BRANCH", "BRANCHJ-BRANCHJ", "IFTHEN-IFTHEN"
             * IFTHEN is special as it might not appear in pairs.
             * Not sure whether BRANCH-BRANCHJ is possible, regardless
             * we dont handle it cleanly. */
a3701 2
                    DEBUG_PEEP("Branch", scan, depth);

d3703 1
a3703 1
                    StructCopy(&zero_scan_data, &data_fake, scan_data_t);
d3713 2
a3714 3

                    scan = NEXTOPER(scan); /* everything */
                    if (code != BRANCH)    /* everything but BRANCH */
a3715 1

a3727 1

d3853 3
d3871 5
a3875 6
                            regprop(RExC_rx, RExC_mysv, tail, NULL, pRExC_state);
                            Perl_re_indentf( aTHX_  "%s %"UVuf":%s\n",
                              depth+1,
                              "Looking for TRIE'able sequences. Tail node is ",
                              (UV)(tail - RExC_emit_start),
                              SvPV_nolen_const( RExC_mysv )
a3930 2
                                EXACTL          | EXACTL
                                EXACTFLU8       | EXACTFLU8
d3934 5
a3938 13
#define TRIE_TYPE(X) ( ( NOTHING == (X) )                                   \
                       ? NOTHING                                            \
                       : ( EXACT == (X) )                                   \
                         ? EXACT                                            \
                         : ( EXACTFU == (X) || EXACTFU_SS == (X) )          \
                           ? EXACTFU                                        \
                           : ( EXACTFA == (X) )                             \
                             ? EXACTFA                                      \
                             : ( EXACTL == (X) )                            \
                               ? EXACTL                                     \
                               : ( EXACTFLU8 == (X) )                        \
                                 ? EXACTFLU8                                 \
                                 : 0 )
d3947 2
a3948 2
                            U8 noper_next_type = (noper_next && noper_next < tail) ? OP(noper_next) : 0;
                            U8 noper_next_trietype = (noper_next && noper_next < tail) ? TRIE_TYPE( noper_next_type ) :0;
d3952 7
a3958 8
                                regprop(RExC_rx, RExC_mysv, cur, NULL, pRExC_state);
                                Perl_re_indentf( aTHX_  "- %d:%s (%d)",
                                   depth+1,
                                   REG_NODE_NUM(cur), SvPV_nolen_const( RExC_mysv ), REG_NODE_NUM(cur) );

                                regprop(RExC_rx, RExC_mysv, noper, NULL, pRExC_state);
                                Perl_re_printf( aTHX_  " -> %d:%s",
                                    REG_NODE_NUM(noper), SvPV_nolen_const(RExC_mysv));
d3961 3
a3963 3
                                  regprop(RExC_rx, RExC_mysv, noper_next, NULL, pRExC_state);
                                  Perl_re_printf( aTHX_ "\t=> %d:%s\t",
                                    REG_NODE_NUM(noper_next), SvPV_nolen_const(RExC_mysv));
d3965 1
a3965 1
                                Perl_re_printf( aTHX_  "(First==%d,Last==%d,Cur==%d,tt==%s,ntt==%s,nntt==%s)\n",
d3976 1
a3976 1
                                        ( noper_trietype == NOTHING )
d3981 1
a3981 1
                                  && noper_next >= tail
d3994 1
a3994 1
                                        U8 noper_next_type = (noper_next && noper_next < tail) ? OP(noper_next) : 0;
d4041 1
a4041 1
                                     && noper_next >= tail
d4060 5
a4064 7
                            regprop(RExC_rx, RExC_mysv, cur, NULL, pRExC_state);
                            Perl_re_indentf( aTHX_  "- %s (%d) <SCAN FINISHED> ",
                              depth+1, SvPV_nolen_const( RExC_mysv ),REG_NODE_NUM(cur));
                            Perl_re_printf( aTHX_  "(First==%d, Last==%d, Cur==%d, tt==%s)\n",
                               REG_NODE_NUM(first), REG_NODE_NUM(last), REG_NODE_NUM(cur),
                               PL_reg_name[trietype]
                            );
d4082 1
a4082 1
                                         && scan >= tail )
d4100 4
a4103 4
                                        regprop(RExC_rx, RExC_mysv, cur, NULL, pRExC_state);
                                        Perl_re_indentf( aTHX_  "- %s (%d) <NOTHING BRANCH SEQUENCE>\n",
                                          depth+1,
                                          SvPV_nolen_const( RExC_mysv ),REG_NODE_NUM(cur));
d4123 5
a4127 4
        } else if (OP(scan) == SUSPEND || OP(scan) == GOSUB) {
            I32 paren = 0;
            regnode *start = NULL;
            regnode *end = NULL;
d4130 11
a4140 35
            if (OP(scan) != SUSPEND) { /* GOSUB */
                /* Do setup, note this code has side effects beyond
                 * the rest of this block. Specifically setting
                 * RExC_recurse[] must happen at least once during
                 * study_chunk(). */
                paren = ARG(scan);
                RExC_recurse[ARG2L(scan)] = scan;
                start = RExC_open_parens[paren];
                end   = RExC_close_parens[paren];

                /* NOTE we MUST always execute the above code, even
                 * if we do nothing with a GOSUB */
                if (
                    ( flags & SCF_IN_DEFINE )
                    ||
                    (
                        (is_inf_internal || is_inf || (data && data->flags & SF_IS_INF))
                        &&
                        ( (flags & (SCF_DO_STCLASS | SCF_DO_SUBSTR)) == 0 )
                    )
                ) {
                    /* no need to do anything here if we are in a define. */
                    /* or we are after some kind of infinite construct
                     * so we can skip recursing into this item.
                     * Since it is infinite we will not change the maxlen
                     * or delta, and if we miss something that might raise
                     * the minlen it will merely pessimise a little.
                     *
                     * Iow /(?(DEFINE)(?<foo>foo|food))a+(?&foo)/
                     * might result in a minlen of 1 and not of 4,
                     * but this doesn't make us mismatch, just try a bit
                     * harder than we should.
                     * */
                    scan= regnext(scan);
                    continue;
d4142 1
a4142 3

                if (
                    !recursed_depth
a4145 10
                    /* it is quite possible that there are more efficient ways
                     * to do this. We maintain a bitmap per level of recursion
                     * of which patterns we have entered so we can detect if a
                     * pattern creates a possible infinite loop. When we
                     * recurse down a level we copy the previous levels bitmap
                     * down. When we are at recursion level 0 we zero the top
                     * level bitmap. It would be nice to implement a different
                     * more efficient way of doing this. In particular the top
                     * level bitmap may be unnecessary.
                     */
d4154 1
a4154 1
                    DEBUG_STUDYDATA("gosub-set:", data,depth);
d4157 1
d4159 1
a4159 1
                    DEBUG_STUDYDATA("gosub-inf:", data,depth);
a4169 2

                    start= NULL; /* reset start so we dont recurse later on. */
d4172 1
d4174 1
a4174 1
                start = scan + 2;
d4177 2
a4178 2
            if (start) {
                scan_frame *newframe;
d4180 5
a4184 18
                if (!RExC_frame_last) {
                    Newxz(newframe, 1, scan_frame);
                    SAVEDESTRUCTOR_X(S_unwind_scan_frames, newframe);
                    RExC_frame_head= newframe;
                    RExC_frame_count++;
                } else if (!RExC_frame_last->next_frame) {
                    Newxz(newframe,1,scan_frame);
                    RExC_frame_last->next_frame= newframe;
                    newframe->prev_frame= RExC_frame_last;
                    RExC_frame_count++;
                } else {
                    newframe= RExC_frame_last->next_frame;
                }
                RExC_frame_last= newframe;

                newframe->next_regnode = regnext(scan);
                newframe->last_regnode = last;
                newframe->stopparen = stopparen;
a4185 1
                newframe->this_prev_frame= frame;
d4200 1
a4200 1
	else if (OP(scan) == EXACT || OP(scan) == EXACTL) {
d4239 1
a4239 1
                ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;
d4247 1
a4247 1
                ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;
d4251 1
a4251 2
        else if (PL_regkind[OP(scan)] == EXACT) {
            /* But OP != EXACT!, so is EXACTFish */
d4253 3
a4255 1
            const U8 * s = (U8*)STRING(scan);
d4263 2
d4283 1
d4285 9
a4293 4
            if (flags & SCF_DO_STCLASS) {
                SV* EXACTF_invlist = _make_exactf_invlist(pRExC_state, scan);

                assert(EXACTF_invlist);
d4295 1
a4295 5
                    if (OP(scan) != EXACTFL)
                        ssc_clear_locale(data->start_class);
                    ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;
                    ANYOF_POSIXL_ZERO(data->start_class);
                    ssc_intersection(data->start_class, EXACTF_invlist, FALSE);
d4297 20
a4316 3
                else {  /* SCF_DO_STCLASS_OR */
                    ssc_union(data->start_class, EXACTF_invlist, FALSE);
                    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);
d4318 31
a4348 2
                    /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a */
                    ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;
a4349 2
                flags &= ~SCF_DO_STCLASS;
                SvREFCNT_dec(EXACTF_invlist);
d4351 14
d4381 1
a4381 4
		    if (OP(next) == EXACT
                        || OP(next) == EXACTL
                        || (flags & SCF_DO_STCLASS))
                    {
d4392 1
a4392 1
		/* FALLTHROUGH */
d4480 1
a4480 2
                        ANYOF_FLAGS(data->start_class)
                                                |= SSC_MATCHES_EMPTY_STRING;
d4503 2
a4504 5
		    Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP),
			"Quantifier unexpected on zero-length expression "
			"in regex m/%"UTF8f"/",
			 UTF8fARG(UTF, RExC_precomp_end - RExC_precomp,
				  RExC_precomp));
d4543 2
a4544 2
                        RExC_open_parens[ARG(nxt1)]=oscan; /*open->CURLYM*/
                        RExC_close_parens[ARG(nxt1)]=nxt+2; /*close->while*/
d4590 2
a4591 2
                            RExC_open_parens[ARG(nxt1)]=oscan; /*open->CURLYM*/
                            RExC_close_parens[ARG(nxt1)]=nxt2+1; /*close->NOTHING*/
d4688 2
a4689 5
			    data->last_start_max =
                              is_inf
                               ? SSize_t_MAX
			       : data->last_start_max +
                                 (maxcount - 1) * (minnext + data->pos_delta);
d4695 3
a4697 3
Perl_re_printf( aTHX_  "counted=%"UVuf" deltanext=%"UVuf
                              " SSize_t_MAX=%"UVuf" minnext=%"UVuf
                              " maxcount=%"UVuf" mincount=%"UVuf"\n",
d4701 1
a4701 1
Perl_re_printf( aTHX_  "LHS=%"UVuf" RHS=%"UVuf"\n",
d4776 1
a4776 2
                    ANYOF_FLAGS(data->start_class)
                                                &= ~SSC_MATCHES_EMPTY_STRING;
d4786 1
a4786 2
                    ANYOF_FLAGS(data->start_class)
                                                &= ~SSC_MATCHES_EMPTY_STRING;
d4791 1
a4791 2
            if (delta != SSize_t_MAX)
                delta++;    /* Because of the 2 char string cr-lf */
d4813 1
a4813 1
                ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;
d4824 1
a4852 2
                case ANYOFD:
                case ANYOFL:
d4864 1
a4864 1
                    /* FALLTHROUGH */
d4905 1
a4905 1
                    /* FALLTHROUGH */
d4920 1
a4920 1
                    /* FALLTHROUGH */
d4962 28
a4989 2
		   && (OP(scan) == IFMATCH || OP(scan) == UNLESSM))
        {
d5002 1
a5002 1
                StructCopy(&zero_scan_data, &data_fake, scan_data_t);
d5054 1
a5054 2
                        ANYOF_FLAGS(data->start_class)
                                                   |= SSC_MATCHES_EMPTY_STRING;
d5126 1
a5126 1
                    ANYOF_FLAGS(data->start_class) |= SSC_MATCHES_EMPTY_STRING;
d5245 1
a5245 1
                    StructCopy(&zero_scan_data, &data_fake, scan_data_t);
d5308 1
a5308 2
            if (delta != SSize_t_MAX)
                delta += max1 - min1;
a5367 2
        depth = depth - 1;

a5369 1

d5371 3
a5373 3
        last = frame->last_regnode;
        scan = frame->next_regnode;
        stopparen = frame->stopparen;
d5375 1
d5377 1
a5377 2
        RExC_frame_last = frame->prev_frame;
        frame = frame->this_prev_frame;
d5410 2
a5411 5
        if (!(RExC_seen & REG_UNBOUNDED_QUANTIFIER_SEEN)) {
            if (final_minlen > SSize_t_MAX - delta)
                RExC_maxlen = SSize_t_MAX;
            else if (RExC_maxlen < final_minlen + delta)
                RExC_maxlen = final_minlen + delta;
d5415 1
a5415 1
    NOT_REACHED; /* NOTREACHED */
d5437 1
a5437 2
/*XXX: todo make this not included in a non debugging perl, but appears to be
 * used anyway there, in 'use re' */
d5442 1
d5496 2
d5524 1
d5532 1
a5532 1
        Perl_re_printf( aTHX_  "Using engine %"UVxf"\n",
d5571 1
a5571 1
    U8 *dst, *d;
d5573 1
a5573 1
    STRLEN s = 0;
d5577 1
a5577 1
    DEBUG_PARSE_r(Perl_re_printf( aTHX_
a5580 1
    d = dst;
d5583 6
a5588 1
        append_utf8_from_native_byte(src[s], &d);
d5591 2
a5592 2
                pRExC_state->code_blocks[n].start = d - dst - 1;
                assert(*(d - 1) == '(');
d5596 2
a5597 2
                pRExC_state->code_blocks[n].end = d - dst - 1;
                assert(*(d - 1) == ')');
d5603 1
d5605 2
a5606 2
    *d = '\0';
    *plen_p = d - dst;
d5640 1
a5640 1
        pat = newSVpvs("");
d5676 1
a5676 1
                oplist = OpSIBLING(oplist);
d5723 1
a5723 1
                oplist = OpSIBLING(oplist); /* skip CONST */
d5726 1
a5726 1
            oplist = OpSIBLING(oplist);;
a5845 2
    
    PERL_UNUSED_CONTEXT;
d5948 1
a5948 1
            Perl_re_printf( aTHX_
d6161 1
d6198 1
a6201 4
#ifdef DEBUGGING
        char * dump_len_string;
#endif

d6208 1
a6208 14

        /* This is calculated here, because the Perl program that generates the
         * static global ones doesn't currently have access to
         * NUM_ANYOF_CODE_POINTS */
	PL_InBitmap = _new_invlist(2);
	PL_InBitmap = _add_range_to_invlist(PL_InBitmap, 0,
                                                    NUM_ANYOF_CODE_POINTS - 1);
#ifdef DEBUGGING
        dump_len_string = PerlEnv_getenv("PERL_DUMP_RE_MAX_LEN");
        if (   ! dump_len_string
            || ! grok_atoUV(dump_len_string, (UV *)&PL_dump_re_max_len, NULL))
        {
            PL_dump_re_max_len = 0;
        }
a6209 1
    }
d6223 1
a6223 1
	for (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o))
d6244 1
a6244 1
            for (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o)) {
d6260 1
a6260 1
            for (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o)) {
d6267 1
a6267 1
    DEBUG_PARSE_r(Perl_re_printf( aTHX_
d6280 1
a6280 1
            expr = OpSIBLING(expr);
d6296 1
a6296 1
            DEBUG_PARSE_r(Perl_re_printf( aTHX_
a6320 1

a6321 1
    RExC_seen_unfolded_sharp_s = 0;
a6323 1
    RExC_strict = cBOOL(pm_flags & RXf_PMf_STRICT);
a6324 3
    RExC_frame_head= NULL;
    RExC_frame_last= NULL;
    RExC_frame_count= 0;
a6325 4
    DEBUG_r({
        RExC_mysv1= sv_newmortal();
        RExC_mysv2= sv_newmortal();
    });
d6329 1
a6329 1
            Perl_re_printf( aTHX_  "%sCompiling REx%s %s\n",
d6334 2
a6335 2
    /* we jump here if we have to recompile, e.g., from upgrading the pattern
     * to utf8 */
d6369 1
a6369 3
    if (   initial_charset == REGEX_DEPENDS_CHARSET
        && (RExC_utf8 ||RExC_uni_semantics))
    {
a6376 1
    RExC_precomp_adj = 0;
d6381 1
a6381 2
        assert(TAINTING_get || !TAINT_get);
	if (TAINT_get)
a6401 3
#ifdef EBCDIC
    RExC_recode_x_to_native = 0;
#endif
d6406 1
a6406 1
    RExC_start = RExC_adjusted_start = exp;
a6407 1
    RExC_precomp_end = RExC_end;
d6416 1
a6416 1
    RExC_end_op = NULL;
d6427 4
a6430 9
    /* This NUL is guaranteed because the pattern comes from an SV*, and the sv
     * code makes sure the final byte is an uncounted NUL.  But should this
     * ever not be the case, lots of things could read beyond the end of the
     * buffer: loops like
     *      while(isFOO(*RExC_parse)) RExC_parse++;
     *      strchr(RExC_parse, "foo");
     * etc.  So it is worth noting. */
    assert(*RExC_end == '\0');

d6432 1
a6432 1
        Perl_re_printf( aTHX_  "Starting first pass (sizing)\n");
d6456 2
a6457 3
        if (flags & RESTART_PASS1) {
            if (flags & NEED_UTF8) {
                S_pat_upgrade_to_utf8(aTHX_ pRExC_state, &exp, &plen,
a6458 6
            }
            else {
                DEBUG_PARSE_r(Perl_re_printf( aTHX_
                "Need to redo pass 1\n"));
            }

d6467 1
a6467 1
        Perl_re_printf( aTHX_
d6525 1
a6525 2
	if(pRExC_state->code_blocks)
	    SAVEFREEPV(pRExC_state->code_blocks); /* often null */
d6540 1
a6540 1
	U8 reganch = (U8)((r->extflags & RXf_PMf_STD_PMMOD)
d6542 1
a6542 1
	const char *fptr = STD_PAT_MODS;        /*"msixn"*/
d6544 6
a6549 3

        /* We output all the necessary flags; we never output a minus, as all
         * those are defaults, so are
a6552 1
            + PL_bitcount[reganch] /* 1 char for each set standard flag */
d6556 1
a6558 3
        /* make sure PL_bitcount bounds not exceeded */
        assert(sizeof(STD_PAT_MODS) <= 8);

d6601 18
d6622 1
a6622 1
    DEBUG_OFFSETS_r(Perl_re_printf( aTHX_
d6638 1
d6644 1
a6644 32
    *((char*) RExC_emit++) = (char) REG_MAGIC;
    /* setup various meta data about recursion, this all requires
     * RExC_npar to be correctly set, and a bit later on we clear it */
    if (RExC_seen & REG_RECURSE_SEEN) {
        DEBUG_OPTIMISE_MORE_r(Perl_re_printf( aTHX_
            "%*s%*s Setting up open/close parens\n",
                  22, "|    |", (int)(0 * 2 + 1), ""));

        /* setup RExC_open_parens, which holds the address of each
         * OPEN tag, and to make things simpler for the 0 index
         * the start of the program - this is used later for offsets */
        Newxz(RExC_open_parens, RExC_npar,regnode *);
        SAVEFREEPV(RExC_open_parens);
        RExC_open_parens[0] = RExC_emit;

        /* setup RExC_close_parens, which holds the address of each
         * CLOSE tag, and to make things simpler for the 0 index
         * the end of the program - this is used later for offsets */
        Newxz(RExC_close_parens, RExC_npar,regnode *);
        SAVEFREEPV(RExC_close_parens);
        /* we dont know where end op starts yet, so we dont
         * need to set RExC_close_parens[0] like we do RExC_open_parens[0] above */

        /* Note, RExC_npar is 1 + the number of parens in a pattern.
         * So its 1 if there are no parens. */
        RExC_study_chunk_recursed_bytes= (RExC_npar >> 3) +
                                         ((RExC_npar & 0x07) != 0);
        Newx(RExC_study_chunk_recursed,
             RExC_study_chunk_recursed_bytes * RExC_npar, U8);
        SAVEFREEPV(RExC_study_chunk_recursed);
    }
    RExC_npar = 1;
a6648 4
    DEBUG_OPTIMISE_r(
        Perl_re_printf( aTHX_  "Starting post parse optimization\n");
    );

d6657 1
a6657 1
  reStudy:
a6658 3
    DEBUG_r(
        RExC_study_chunk_recursed_count= 0;
    );
d6660 1
a6660 1
    if (RExC_study_chunk_recursed) {
a6662 2
    }

d6670 1
a6670 1
        DEBUG_OPTIMISE_r(Perl_re_printf( aTHX_ "Restudying\n"));
d6690 1
a6690 1
    if (RExC_naughty >= TOO_NAUGHTY)	/* Probably an expensive pattern. */
d6749 1
a6749 1
	    if (OP(first) == EXACT || OP(first) == EXACTL)
d6758 16
a6773 2
            /* this can happen only on restudy */
            ri->regstclass = construct_ahocorasick_from_trie(pRExC_state, (regnode *)first, 0);
d6784 3
a6786 1
                           : PREGf_ANCH_SBOL);
a6795 1
            !sawlookahead &&
d6819 1
a6819 1
                Perl_re_printf( aTHX_  "first at %"IVdf"\n",
d6824 1
a6824 1
            Perl_re_printf( aTHX_  "first at %"IVdf"\n",
d6938 2
a6939 2
            && ! (ANYOF_FLAGS(data.start_class) & SSC_MATCHES_EMPTY_STRING)
	    && is_ssc_worth_it(pRExC_state, data.start_class))
d6952 2
a6953 2
                      regprop(r, sv, (regnode*)data.start_class, NULL, pRExC_state);
                      Perl_re_printf( aTHX_
d6998 1
a6998 1
        DEBUG_PARSE_r(Perl_re_printf( aTHX_  "\nMulti Top Level\n"));
d7018 2
a7019 2
        if (! (ANYOF_FLAGS(data.start_class) & SSC_MATCHES_EMPTY_STRING)
	    && is_ssc_worth_it(pRExC_state, data.start_class))
d7032 2
a7033 2
                      regprop(r, sv, (regnode*)data.start_class, NULL, pRExC_state);
                      Perl_re_printf( aTHX_
d7051 2
a7052 2
        Perl_re_printf( aTHX_ "minlen: %"IVdf" r->minlen:%"IVdf" maxlen:%"IVdf"\n",
                      (IV)minlen, (IV)r->minlen, (IV)RExC_maxlen);
a7057 4
    if (RExC_seen & REG_RECURSE_SEEN ) {
        r->intflags |= PREGf_RECURSE_SEEN;
        Newxz(r->recurse_locinput, r->nparens + 1, char *);
    }
d7065 2
d7097 1
a7097 1
        regnode *next = regnext(first);
d7102 1
a7102 6
        else if ((fop == MBOL || (fop == SBOL && !first->flags)) && nop == END)
            /* when fop is SBOL first->flags will be true only when it was
             * produced by parsing /\A/, and not when parsing /^/. This is
             * very important for the split code as there we want to
             * treat /^/ as /^/m, but we do not want to treat /\A/ as /^/m.
             * See rt #122761 for more details. -- Yves */
d7106 1
a7106 1
                 && nop == END)
d7109 1
a7109 1
                  && (fop == EXACT || fop == EXACTL)
d7112 1
a7112 1
                  && nop == END )
d7128 1
a7128 1
    ri->name_list_idx = 0;
d7130 5
a7134 3
    while ( RExC_recurse_count > 0 ) {
        const regnode *scan = RExC_recurse[ --RExC_recurse_count ];
        ARG2L_SET( scan, RExC_open_parens[ARG(scan)] - scan );
a7135 1

d7138 1
a7138 4
    DEBUG_TEST_r({
        Perl_re_printf( aTHX_ "study_chunk_recursed_count: %lu\n",
            (unsigned long)RExC_study_chunk_recursed_count);
    });
d7141 1
a7141 1
        Perl_re_printf( aTHX_ "Final program:\n");
d7149 1
a7149 1
        Perl_re_printf( aTHX_
d7153 1
a7153 1
                Perl_re_printf( aTHX_  "%"UVuf":%"UVuf"[%"UVuf"] ",
d7156 1
a7156 1
        Perl_re_printf( aTHX_  "\n");
d7470 5
a7474 1
        if (RXp_MATCH_UTF8(rx))
d7476 1
d7633 1
a7633 2
         /* Note that the code here assumes well-formed UTF-8.  Skip IDFIRST by
          * using do...while */
d7670 1
a7670 1
        NOT_REACHED; /* NOTREACHED */
d7676 2
d7679 11
a7689 11
    if (RExC_lastparse!=RExC_parse) {                           \
        Perl_re_printf( aTHX_  "%s",                                        \
            Perl_pv_pretty(aTHX_ RExC_mysv1, RExC_parse,        \
                RExC_end - RExC_parse, 16,                      \
                "", "",                                         \
                PERL_PV_ESCAPE_UNI_DETECT |                     \
                PERL_PV_PRETTY_ELLIPSES   |                     \
                PERL_PV_PRETTY_LTGT       |                     \
                PERL_PV_ESCAPE_RE         |                     \
                PERL_PV_PRETTY_EXACTSIZE                        \
            )                                                   \
d7691 2
a7692 2
    } else                                                      \
        Perl_re_printf( aTHX_ "%16s","");                                   \
d7699 1
a7699 1
       Perl_re_printf( aTHX_ "|%4d",num);                                   \
d7701 2
a7702 2
       Perl_re_printf( aTHX_ "|%4s","");                                    \
    Perl_re_printf( aTHX_ "|%*s%-4s",                                       \
d7714 1
a7714 1
    Perl_re_printf( aTHX_ "%4s","\n");                                  \
d7716 1
a7716 1
#define DEBUG_PARSE_FMT(funcname,fmt,args)     DEBUG_PARSE_r({\
d7718 1
a7718 1
    Perl_re_printf( aTHX_ fmt "\n",args);                               \
d7763 1
a7763 1
/* The header definitions are in F<invlist_inline.h> */
d7766 1
a7766 1
S__invlist_array_init(SV* const invlist, const bool will_have_0)
d7791 21
d7817 1
a7817 1
    PERL_UNUSED_CONTEXT;
a7828 48
#ifndef PERL_IN_XSUB_RE

STATIC void
S_invlist_replace_list_destroys_src(pTHX_ SV * dest, SV * src)
{
    /* Replaces the inversion list in 'src' with the one in 'dest'.  It steals
     * the list from 'src', so 'src' is made to have a NULL list.  This is
     * similar to what SvSetMagicSV() would do, if it were implemented on
     * inversion lists, though this routine avoids a copy */

    const UV src_len          = _invlist_len(src);
    const bool src_offset     = *get_invlist_offset_addr(src);
    const STRLEN src_byte_len = SvLEN(src);
    char * array              = SvPVX(src);

    const int oldtainted = TAINT_get;

    PERL_ARGS_ASSERT_INVLIST_REPLACE_LIST_DESTROYS_SRC;

    assert(SvTYPE(src) == SVt_INVLIST);
    assert(SvTYPE(dest) == SVt_INVLIST);
    assert(! invlist_is_iterating(src));
    assert(SvCUR(src) == 0 || SvCUR(src) < SvLEN(src));

    /* Make sure it ends in the right place with a NUL, as our inversion list
     * manipulations aren't careful to keep this true, but sv_usepvn_flags()
     * asserts it */
    array[src_byte_len - 1] = '\0';

    TAINT_NOT;      /* Otherwise it breaks */
    sv_usepvn_flags(dest,
                    (char *) array,
                    src_byte_len - 1,

                    /* This flag is documented to cause a copy to be avoided */
                    SV_HAS_TRAILING_NUL);
    TAINT_set(oldtainted);
    SvPV_set(src, 0);
    SvLEN_set(src, 0);
    SvCUR_set(src, 0);

    /* Finish up copying over the other fields in an inversion list */
    *get_invlist_offset_addr(dest) = src_offset;
    invlist_set_len(dest, src_len, src_offset);
    *get_invlist_previous_index_addr(dest) = 0;
    invlist_iterfinish(dest);
}

d7830 1
a7830 1
S_get_invlist_previous_index_addr(SV* invlist)
d7834 1
d7843 1
a7843 1
S_invlist_previous_index(SV* const invlist)
d7853 1
a7853 1
S_invlist_set_previous_index(SV* const invlist, const IV index)
a7863 37
PERL_STATIC_INLINE void
S_invlist_trim(SV* invlist)
{
    /* Free the not currently-being-used space in an inversion list */

    /* But don't free up the space needed for the 0 UV that is always at the
     * beginning of the list, nor the trailing NUL */
    const UV min_size = TO_INTERNAL_SIZE(1) + 1;

    PERL_ARGS_ASSERT_INVLIST_TRIM;

    assert(SvTYPE(invlist) == SVt_INVLIST);

    SvPV_renew(invlist, MAX(min_size, SvCUR(invlist) + 1));
}

PERL_STATIC_INLINE void
S_invlist_clear(pTHX_ SV* invlist)    /* Empty the inversion list */
{
    PERL_ARGS_ASSERT_INVLIST_CLEAR;

    assert(SvTYPE(invlist) == SVt_INVLIST);

    invlist_set_len(invlist, 0, 0);
    invlist_trim(invlist);
}

#endif /* ifndef PERL_IN_XSUB_RE */

PERL_STATIC_INLINE bool
S_invlist_is_iterating(SV* const invlist)
{
    PERL_ARGS_ASSERT_INVLIST_IS_ITERATING;

    return *(get_invlist_iter_addr(invlist)) < (STRLEN) UV_MAX;
}

d7865 1
a7865 1
S_invlist_max(SV* const invlist)
d7983 12
d8083 1
a8083 1
Perl__invlist_search(SV* const invlist, const UV cp)
d8088 1
a8088 3
     * contains <cp>, that is, 'i' such that
     *	array[i] <= cp < array[i+1]
     */
d8107 1
a8107 4
    assert(mid >=0);
    if (mid > highest_element) {
        mid = highest_element;
    }
d8171 2
a8172 2
Perl__invlist_populate_swatch(SV* const invlist,
                              const UV start, const UV end, U8* swatch)
d8239 1
a8239 1
      join_end_of_list:
d8271 4
a8274 4
     * temporary (mortal); otherwise just its contents will be modified to be
     * the union.  The first list, <a>, may be NULL, in which case a copy of
     * the second list is returned.  If <complement_b> is TRUE, the union is
     * taken of the complement (inversion) of <b> instead of b itself.
d8296 1
a8296 1
    UV len_u = 0;
d8313 3
a8315 2
    len_b = _invlist_len(b);
    if (len_b == 0) {
d8317 5
a8321 12
        /* Here, 'b' is empty.  If the output is the complement of 'b', the
         * union is all possible code points, and we need not even look at 'a'.
         * It's easiest to create a new inversion list that matches everything.
         * */
        if (complement_b) {
            SV* everything = _new_invlist(1);
            _append_range_to_invlist(everything, 0, UV_MAX);

            /* If the output didn't exist, just point it at the new list */
            if (*output == NULL) {
                *output = everything;
                return;
d8323 5
a8327 29

            /* Otherwise, replace its contents with the new list */
            invlist_replace_list_destroys_src(*output, everything);
            SvREFCNT_dec_NN(everything);
            return;
        }

        /* Here, we don't want the complement of 'b', and since it is empty,
         * the union will come entirely from 'a'.  If 'a' is NULL or empty, the
         * output will be empty */

        if (a == NULL) {
            *output = _new_invlist(0);
            return;
        }

        if (_invlist_len(a) == 0) {
            invlist_clear(*output);
            return;
        }

        /* Here, 'a' is not empty, and entirely determines the union.  If the
         * output is not to overwrite 'b', we can just return 'a'. */
        if (*output != b) {

            /* If the output is to overwrite 'a', we have a no-op, as it's
             * already in 'a' */
            if (*output == a) {
                return;
d8329 1
d8331 2
a8332 3
            /* But otherwise we have to copy 'a' to the output */
            *output = invlist_clone(a);
            return;
a8333 6

        /* Here, 'b' is to be overwritten by the output, which will be 'a' */
        u = invlist_clone(a);
        invlist_replace_list_destroys_src(*output, u);
        SvREFCNT_dec_NN(u);

d8336 5
a8340 12

    if (a == NULL || ((len_a = _invlist_len(a)) == 0)) {

        /* Here, 'a' is empty (and b is not).  That means the union will come
         * entirely from 'b'.  If the output is not to overwrite 'a', we can
         * just return what's in 'b'.  */
        if (*output != a) {

            /* If the output is to overwrite 'b', it's already in 'b', but
             * otherwise we have to copy 'b' to the output */
            if (*output != b) {
                *output = invlist_clone(b);
d8342 1
d8344 7
a8350 3
            /* And if the output is to be the inversion of 'b', do that */
            if (complement_b) {
                _invlist_invert(*output);
d8352 2
a8353 2

            return;
d8355 2
a8356 6

        /* Here, 'a', which is empty or even NULL, is to be overwritten by the
         * output, which will either be 'b' or the complement of 'b' */

        if (a == NULL) {
            *output = invlist_clone(b);
d8358 1
a8358 5
        else {
            u = invlist_clone(b);
            invlist_replace_list_destroys_src(*output, u);
            SvREFCNT_dec_NN(u);
	}
d8360 2
a8361 2
        if (complement_b) {
            _invlist_invert(*output);
a8362 1

d8428 1
a8428 1
	 * beginning/end of a range that's in the set */
d8462 1
a8462 1
    if (   (i_a != len_a && PREV_RANGE_MATCHES_INVLIST(i_a))
d8478 2
a8479 3
    /* Set the result to the final length, which can change the pointer to
     * array_u, so re-find it.  (Note that it is unlikely that this will
     * change, as we are shrinking the space, not enlarging it) */
d8489 1
a8489 1
     * non-exhausted list, so can just copy it unchanged.  (If both lists were
d8502 4
a8505 14
    /* If the output is not to overwrite either of the inputs, just return the
     * calculated union */
    if (a != *output && b != *output) {
        *output = u;
    }
    else {
        /*  Here, the output is to be the same as one of the input scalars,
         *  hence replacing it.  The simple thing to do is to free the input
         *  scalar, making it instead be the output one.  But experience has
         *  shown [perl #127392] that if the input is a mortal, we can get a
         *  huge build-up of these during regex compilation before they get
         *  freed.  So for that case, replace just the input's interior with
         *  the output's, and then free the output */

d8507 2
a8508 4

        if (! SvTEMP(*output)) {
            SvREFCNT_dec_NN(*output);
            *output = u;
d8511 1
a8511 2
            invlist_replace_list_destroys_src(*output, u);
            SvREFCNT_dec_NN(u);
d8515 2
d8527 5
a8531 5
     * temporary (mortal); otherwise just its contents will be modified to be
     * the intersection.  The first list, <a>, may be NULL, in which case an
     * empty list is returned.  If <complement_b> is TRUE, the result will be
     * the intersection of <a> and the complement (or inversion) of <b> instead
     * of <b> directly.
d8549 1
a8549 1
    UV len_r = 0;
d8569 2
d8573 10
a8582 4
            /* Here, 'a' is not empty, therefore from the enclosing 'if', 'b'
             * must be empty.  Here, also we are using 'b's complement, which
             * hence must be every possible code point.  Thus the intersection
             * is simply 'a'. */
d8584 1
a8584 2
            if (*i == a) {  /* No-op */
                return;
d8586 1
d8588 2
a8589 4
            /* If not overwriting either input, just make a copy of 'a' */
            if (*i != b) {
                *i = invlist_clone(a);
                return;
a8590 5

            /* Here we are overwriting 'b' with 'a's contents */
            r = invlist_clone(a);
            invlist_replace_list_destroys_src(*i, r);
            SvREFCNT_dec_NN(r);
d8596 13
a8608 3
        if (*i == NULL) {
            *i = _new_invlist(0);
            return;
a8610 1
        invlist_clear(*i);
d8708 1
a8708 1
    if (   (i_a == len_a && PREV_RANGE_MATCHES_INVLIST(i_a))
d8722 2
a8723 3
    /* Set the result to the final length, which can change the pointer to
     * array_r, so re-find it.  (Note that it is unlikely that this will
     * change, as we are shrinking the space, not enlarging it) */
d8741 4
a8744 15
    /* If the output is not to overwrite either of the inputs, just return the
     * calculated intersection */
    if (a != *i && b != *i) {
        *i = r;
    }
    else {
        /*  Here, the output is to be the same as one of the input scalars,
         *  hence replacing it.  The simple thing to do is to free the input
         *  scalar, making it instead be the output one.  But experience has
         *  shown [perl #127392] that if the input is a mortal, we can get a
         *  huge build-up of these during regex compilation before they get
         *  freed.  So for that case, replace just the input's interior with
         *  the output's, and then free the output.  A short-cut in this case
         *  is if the output is empty, we can just set the input to be empty */

d8746 2
a8747 4

        if (! SvTEMP(*i)) {
            SvREFCNT_dec_NN(*i);
            *i = r;
d8750 1
a8750 7
            if (len_r) {
                invlist_replace_list_destroys_src(*i, r);
            }
            else {
                invlist_clear(*i);
            }
            SvREFCNT_dec_NN(r);
d8754 2
d8765 1
a8765 1
     * passed-in inversion list can be NULL, in which case a new one is created
d8790 1
a8790 7
     * which is the union of this range and the existing inversion list.  (If
     * the new range is well-behaved wrt to the old one, we could just insert
     * it, doing a Move() down on the tail of the old one (potentially growing
     * it first).  But to determine that means we would have the extra
     * (possibly throw-away) work of first finding where the new one goes and
     * whether it disrupts (splits) an existing range, so it doesn't appear to
     * me (khw) that it's worth it) */
d8884 1
a8884 1
S_get_invlist_iter_addr(SV* invlist)
d8897 1
a8897 1
S_invlist_iterinit(SV* invlist)	/* Initialize iterator for invlist */
d8905 1
a8905 1
S_invlist_iterfinish(SV* invlist)
d8921 1
a8921 1
S_invlist_iternext(SV* invlist, UV* start, UV* end)
d8955 8
d8964 1
a8964 1
S_invlist_highest(SV* const invlist)
d8993 3
a8995 2
STATIC SV *
S_invlist_contents(pTHX_ SV* const invlist, const bool traditional_style)
d8998 2
a8999 4
     * be printed out.  If 'traditional_style' is TRUE, it uses the format
     * traditionally done for debug tracing; otherwise it uses a format
     * suitable for just copying to the output, with blanks between ranges and
     * a dash between range components */
d9002 1
a9002 10
    SV* output;
    const char intra_range_delimiter = (traditional_style ? '\t' : '-');
    const char inter_range_delimiter = (traditional_style ? '\n' : ' ');

    if (traditional_style) {
        output = newSVpvs("\n");
    }
    else {
        output = newSVpvs("");
    }
d9004 1
a9004 1
    PERL_ARGS_ASSERT_INVLIST_CONTENTS;
d9011 1
a9011 3
	    Perl_sv_catpvf(aTHX_ output, "%04"UVXf"%cINFINITY%c",
                                          start, intra_range_delimiter,
                                                 inter_range_delimiter);
d9014 2
a9015 4
	    Perl_sv_catpvf(aTHX_ output, "%04"UVXf"%c%04"UVXf"%c",
		                          start,
                                                   intra_range_delimiter,
                                                  end, inter_range_delimiter);
d9018 1
a9018 2
	    Perl_sv_catpvf(aTHX_ output, "%04"UVXf"%c",
                                          start, inter_range_delimiter);
a9021 4
    if (SvCUR(output) && ! traditional_style) {/* Get rid of trailing blank */
        SvCUR_set(output, SvCUR(output) - 1);
    }

d9024 1
a9075 17

void
Perl__load_PL_utf8_foldclosures (pTHX)
{
    assert(! PL_utf8_foldclosures);

    /* If the folds haven't been read in, call a fold function
     * to force that */
    if (! PL_utf8_tofold) {
        U8 dummy[UTF8_MAXBYTES_CASE+1];

        /* This string is just a short named one above \xff */
        to_utf8_fold((U8*) HYPHEN_UTF8, dummy, NULL);
        assert(PL_utf8_tofold); /* Verify that worked */
    }
    PL_utf8_foldclosures = _swash_inversion_hash(PL_utf8_tofold);
}
d9078 1
a9078 1
#if defined(PERL_ARGS_ASSERT__INVLISTEQ) && !defined(PERL_IN_XSUB_RE)
d9080 1
a9080 1
Perl__invlistEQ(pTHX_ SV* const a, SV* const b, const bool complement_b)
d9140 9
a9148 9
/*
 * As best we can, determine the characters that can match the start of
 * the given EXACTF-ish node.
 *
 * Returns the invlist as a new SV*; it is the caller's responsibility to
 * call SvREFCNT_dec() when done with it.
 */
STATIC SV*
S__make_exactf_invlist(pTHX_ RExC_state_t *pRExC_state, regnode *node)
d9150 2
a9151 148
    const U8 * s = (U8*)STRING(node);
    SSize_t bytelen = STR_LEN(node);
    UV uc;
    /* Start out big enough for 2 separate code points */
    SV* invlist = _new_invlist(4);

    PERL_ARGS_ASSERT__MAKE_EXACTF_INVLIST;

    if (! UTF) {
        uc = *s;

        /* We punt and assume can match anything if the node begins
         * with a multi-character fold.  Things are complicated.  For
         * example, /ffi/i could match any of:
         *  "\N{LATIN SMALL LIGATURE FFI}"
         *  "\N{LATIN SMALL LIGATURE FF}I"
         *  "F\N{LATIN SMALL LIGATURE FI}"
         *  plus several other things; and making sure we have all the
         *  possibilities is hard. */
        if (is_MULTI_CHAR_FOLD_latin1_safe(s, s + bytelen)) {
            invlist = _add_range_to_invlist(invlist, 0, UV_MAX);
        }
        else {
            /* Any Latin1 range character can potentially match any
             * other depending on the locale */
            if (OP(node) == EXACTFL) {
                _invlist_union(invlist, PL_Latin1, &invlist);
            }
            else {
                /* But otherwise, it matches at least itself.  We can
                 * quickly tell if it has a distinct fold, and if so,
                 * it matches that as well */
                invlist = add_cp_to_invlist(invlist, uc);
                if (IS_IN_SOME_FOLD_L1(uc))
                    invlist = add_cp_to_invlist(invlist, PL_fold_latin1[uc]);
            }

            /* Some characters match above-Latin1 ones under /i.  This
             * is true of EXACTFL ones when the locale is UTF-8 */
            if (HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(uc)
                && (! isASCII(uc) || (OP(node) != EXACTFA
                                    && OP(node) != EXACTFA_NO_TRIE)))
            {
                add_above_Latin1_folds(pRExC_state, (U8) uc, &invlist);
            }
        }
    }
    else {  /* Pattern is UTF-8 */
        U8 folded[UTF8_MAX_FOLD_CHAR_EXPAND * UTF8_MAXBYTES_CASE + 1] = { '\0' };
        STRLEN foldlen = UTF8SKIP(s);
        const U8* e = s + bytelen;
        SV** listp;

        uc = utf8_to_uvchr_buf(s, s + bytelen, NULL);

        /* The only code points that aren't folded in a UTF EXACTFish
         * node are are the problematic ones in EXACTFL nodes */
        if (OP(node) == EXACTFL && is_PROBLEMATIC_LOCALE_FOLDEDS_START_cp(uc)) {
            /* We need to check for the possibility that this EXACTFL
             * node begins with a multi-char fold.  Therefore we fold
             * the first few characters of it so that we can make that
             * check */
            U8 *d = folded;
            int i;

            for (i = 0; i < UTF8_MAX_FOLD_CHAR_EXPAND && s < e; i++) {
                if (isASCII(*s)) {
                    *(d++) = (U8) toFOLD(*s);
                    s++;
                }
                else {
                    STRLEN len;
                    to_utf8_fold(s, d, &len);
                    d += len;
                    s += UTF8SKIP(s);
                }
            }

            /* And set up so the code below that looks in this folded
             * buffer instead of the node's string */
            e = d;
            foldlen = UTF8SKIP(folded);
            s = folded;
        }

        /* When we reach here 's' points to the fold of the first
         * character(s) of the node; and 'e' points to far enough along
         * the folded string to be just past any possible multi-char
         * fold. 'foldlen' is the length in bytes of the first
         * character in 's'
         *
         * Unlike the non-UTF-8 case, the macro for determining if a
         * string is a multi-char fold requires all the characters to
         * already be folded.  This is because of all the complications
         * if not.  Note that they are folded anyway, except in EXACTFL
         * nodes.  Like the non-UTF case above, we punt if the node
         * begins with a multi-char fold  */

        if (is_MULTI_CHAR_FOLD_utf8_safe(s, e)) {
            invlist = _add_range_to_invlist(invlist, 0, UV_MAX);
        }
        else {  /* Single char fold */

            /* It matches all the things that fold to it, which are
             * found in PL_utf8_foldclosures (including itself) */
            invlist = add_cp_to_invlist(invlist, uc);
            if (! PL_utf8_foldclosures)
                _load_PL_utf8_foldclosures();
            if ((listp = hv_fetch(PL_utf8_foldclosures,
                                (char *) s, foldlen, FALSE)))
            {
                AV* list = (AV*) *listp;
                IV k;
                for (k = 0; k <= av_tindex_nomg(list); k++) {
                    SV** c_p = av_fetch(list, k, FALSE);
                    UV c;
                    assert(c_p);

                    c = SvUV(*c_p);

                    /* /aa doesn't allow folds between ASCII and non- */
                    if ((OP(node) == EXACTFA || OP(node) == EXACTFA_NO_TRIE)
                        && isASCII(c) != isASCII(uc))
                    {
                        continue;
                    }

                    invlist = add_cp_to_invlist(invlist, c);
                }
            }
        }
    }

    return invlist;
}

#undef HEADER_LENGTH
#undef TO_INTERNAL_SIZE
#undef FROM_INTERNAL_SIZE
#undef INVLIST_VERSION_ID

/* End of inversion list object */

STATIC void
S_parse_lparen_question_flags(pTHX_ RExC_state_t *pRExC_state)
{
    /* This parses the flags that are in either the '(?foo)' or '(?foo:bar)'
     * constructs, and updates RExC_flags with them.  On input, RExC_parse
a9169 1
    int x_mod_count = 0;
d9190 1
a9190 1
    while (RExC_parse < RExC_end) {
d9196 2
a9197 2
            /* Code for the imsxn flags */
            CASE_STD_PMMOD_FLAGS_PARSE_SET(flagsp, x_mod_count);
d9255 1
a9255 1
              excess_modifier:
d9267 2
a9268 2
                NOT_REACHED; /*NOTREACHED*/
              neg_modifier:
d9272 1
a9272 1
                NOT_REACHED; /*NOTREACHED*/
d9275 1
a9275 1
                if (PASS2 && ckWARN(WARN_REGEXP)) {
d9295 1
a9295 1
                if (PASS2 && ckWARN(WARN_REGEXP)) {
d9310 1
a9310 1
                    if (PASS2)
a9333 3
                if (PASS2) {
                    STD_PMMOD_FLAGS_PARSE_X_WARN(x_mod_count);
                }
d9337 2
a9338 2
              fail_modifiers:
                RExC_parse += SKIP_IF_CHAR(RExC_parse);
d9342 1
a9342 1
                NOT_REACHED; /*NOTREACHED*/
d9345 1
a9345 1
        RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;
a9346 2

    vFAIL("Sequence (?... not terminated");
a9364 48
PERL_STATIC_INLINE regnode *
S_handle_named_backref(pTHX_ RExC_state_t *pRExC_state,
                             I32 *flagp,
                             char * parse_start,
                             char ch
                      )
{
    regnode *ret;
    char* name_start = RExC_parse;
    U32 num = 0;
    SV *sv_dat = reg_scan_name(pRExC_state, SIZE_ONLY
                                            ? REG_RSN_RETURN_NULL
                                            : REG_RSN_RETURN_DATA);
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_HANDLE_NAMED_BACKREF;

    if (RExC_parse == name_start || *RExC_parse != ch) {
        /* diag_listed_as: Sequence \%s... not terminated in regex; marked by <-- HERE in m/%s/ */
        vFAIL2("Sequence %.3s... not terminated",parse_start);
    }

    if (!SIZE_ONLY) {
        num = add_data( pRExC_state, STR_WITH_LEN("S"));
        RExC_rxi->data->data[num]=(void*)sv_dat;
        SvREFCNT_inc_simple_void(sv_dat);
    }
    RExC_sawback = 1;
    ret = reganode(pRExC_state,
                   ((! FOLD)
                     ? NREF
                     : (ASCII_FOLD_RESTRICTED)
                       ? NREFFA
                       : (AT_LEAST_UNI_SEMANTICS)
                         ? NREFFU
                         : (LOC)
                           ? NREFFL
                           : NREFF),
                    num);
    *flagp |= HASWIDTH;

    Set_Node_Offset(ret, parse_start+1);
    Set_Node_Cur_Length(ret, parse_start);

    nextchar(pRExC_state);
    return ret;
}

d9366 4
a9369 4
   flags. Returns NULL, setting *flagp to RESTART_PASS1 if the sizing scan
   needs to be restarted, or'd with NEED_UTF8 if the pattern needs to be
   upgraded to UTF-8.  Otherwise would only return NULL if regbranch() returns
   NULL, which cannot happen.  */
d9377 1
a9388 1
    I32 num; /* numeric backreferences */
a9399 7
    /* Having this true makes it feasible to have a lot fewer tests for the
     * parse pointer being in scope.  For example, we can write
     *      while(isFOO(*RExC_parse)) RExC_parse++;
     * instead of
     *      while(RExC_parse < RExC_end && isFOO(*RExC_parse)) RExC_parse++;
     */
    assert(*RExC_end == '\0');
a9409 4
        if (RExC_parse >= RExC_end) {
	    vFAIL("Unmatched (");
        }

d9411 2
a9412 2
	    char *start_verb = RExC_parse + 1;
	    STRLEN verb_len;
d9415 3
a9417 2
            int arg_required = 0;
            int internal_argval = -1; /* if >-1 we are not allowed an argument*/
d9419 2
a9420 3
            if (has_intervening_patws) {
                RExC_parse++;   /* past the '*' */
                vFAIL("In '(*VERB...)', the '(' and '*' must be adjacent");
d9422 1
a9422 1
	    while (RExC_parse < RExC_end && *RExC_parse != ')' ) {
d9427 1
a9427 1
	        RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;
d9429 1
d9432 4
a9435 8
                if (RExC_parse >= RExC_end) {
                    goto unterminated_verb_pattern;
                }
	        RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;
	        while ( RExC_parse < RExC_end && *RExC_parse != ')' )
                    RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;
	        if ( RExC_parse >= RExC_end || *RExC_parse != ')' )
                  unterminated_verb_pattern:
d9440 1
a9440 1
	        if ( RExC_parse >= RExC_end || *RExC_parse != ')' )
a9443 2
            /* Here, we know that RExC_parse < RExC_end */

d9458 1
d9465 1
a9465 1
                    arg_required = 1;
d9490 30
a9519 24
            if ( arg_required && !start_arg ) {
                vFAIL3("Verb pattern '%.*s' has a mandatory argument",
                    verb_len, start_verb);
            }
            if (internal_argval == -1) {
                ret = reganode(pRExC_state, op, 0);
            } else {
                ret = reg2Lanode(pRExC_state, op, 0, internal_argval);
            }
            RExC_seen |= REG_VERBARG_SEEN;
            if ( ! SIZE_ONLY ) {
                if (start_arg) {
                    SV *sv = newSVpvn( start_arg,
                                       RExC_parse - start_arg);
                    ARG(ret) = add_data( pRExC_state,
                                         STR_WITH_LEN("S"));
                    RExC_rxi->data->data[ARG(ret)]=(void*)sv;
                    ret->flags = 1;
                } else {
                    ret->flags = 0;
                }
                if ( internal_argval != -1 )
                    ARG2L_SET(ret, internal_argval);
            }
d9526 2
a9527 4
            const char * endptr;
            if (has_intervening_patws) {
                RExC_parse++;
                vFAIL("In '(?...)', the '(' and '?' must be adjacent");
d9530 2
a9531 7
	    RExC_parse++;           /* past the '?' */
            paren = *RExC_parse;    /* might be a trailing NUL, if not
                                       well-formed */
            RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;
            if (RExC_parse > RExC_end) {
                paren = '\0';
            }
d9536 2
a9537 6
	        paren = *RExC_parse;
		if ( paren == '<') {    /* (?P<...>) named capture */
                    RExC_parse++;
                    if (RExC_parse >= RExC_end) {
                        vFAIL("Sequence (?P<... not terminated");
                    }
a9538 1
                }
a9539 4
                    RExC_parse++;
                    if (RExC_parse >= RExC_end) {
                        vFAIL("Sequence (?P>... not terminated");
                    }
d9543 35
a9577 3
                    RExC_parse++;
                    return handle_named_backref(pRExC_state, flagp,
                                                parse_start, ')');
d9579 1
a9579 1
                RExC_parse += SKIP_IF_CHAR(RExC_parse);
d9583 1
a9583 1
		NOT_REACHED; /*NOTREACHED*/
a9592 1
                /* FALLTHROUGH */
d9594 2
a9595 2
                    name_start = RExC_parse;
                    svname = reg_scan_name(pRExC_state,
d9599 1
a9599 4
		    if (   RExC_parse == name_start
                        || RExC_parse >= RExC_end
                        || *RExC_parse != paren)
                    {
a9601 1
                    }
a9668 2
                assert(RExC_parse < RExC_end);
                /* FALLTHROUGH */
a9673 3
		/* check if we're really just a "FAIL" assertion */
                skip_to_be_ignored_text(pRExC_state, &RExC_parse,
                                        FALSE /* Don't force to /x */ );
d9675 1
a9675 1
                    ret=reganode(pRExC_state, OPFAIL, 0);
d9693 12
d9707 1
a9707 1
                if (RExC_parse == RExC_end || *RExC_parse != ')')
d9709 2
a9710 2
                num = 0;
                RExC_seen |= REG_RECURSE_SEEN;
d9712 2
a9713 1
                goto gen_recurse_regop;
d9715 2
a9716 1
            /* named and numeric backreferences */
d9725 1
a9725 1
                if (RExC_parse >= RExC_end || *RExC_parse != ')')
d9728 1
a9728 1
                /* NOTREACHED */
d9735 1
a9735 1
                /* NOTREACHED*/
d9741 1
a9741 1
                /* FALLTHROUGH */
d9744 1
a9744 1
	        RExC_parse = (char *) seqstart + 1;  /* Point to the digit */
d9746 6
a9751 20
                {
                    bool is_neg = FALSE;
                    UV unum;
                    parse_start = RExC_parse - 1; /* MJD */
                    if (*RExC_parse == '-') {
                        RExC_parse++;
                        is_neg = TRUE;
                    }
                    if (grok_atoUV(RExC_parse, &unum, &endptr)
                        && unum <= I32_MAX
                    ) {
                        num = (I32)unum;
                        RExC_parse = (char*)endptr;
                    } else
                        num = I32_MAX;
                    if (is_neg) {
                        /* Some limit for num? */
                        num = -num;
                    }
                }
a9775 8
                /* We keep track how many GOSUB items we have produced.
                   To start off the ARG2L() of the GOSUB holds its "id",
                   which is used later in conjunction with RExC_recurse
                   to calculate the offset we need to jump for the GOSUB,
                   which it will store in the final representation.
                   We have to defer the actual calculation until much later
                   as the regop may move.
                 */
d9777 1
a9777 1
                ret = reg2Lanode(pRExC_state, GOSUB, num, RExC_recurse_count);
d9783 4
a9786 4
	            RExC_recurse_count++;
                    DEBUG_OPTIMISE_MORE_r(Perl_re_printf( aTHX_
                        "%*s%*s Recurse #%"UVuf" to %"IVdf"\n",
                              22, "|    |", (int)(depth * 2 + 1), "",
d9788 4
a9791 3
                }
                RExC_seen |= REG_RECURSE_SEEN;

a9795 1
                assert(*RExC_parse == ')');
d9798 2
a9799 2

            /* NOTREACHED */
d9804 1
a9804 1
                    RExC_parse += SKIP_IF_CHAR(RExC_parse);
d9809 1
a9809 1
		    NOT_REACHED; /*NOTREACHED*/
d9812 2
a9813 3
		paren = '{';
                RExC_parse++;
		/* FALLTHROUGH */
d9854 1
a9854 8

                    eval = reg2Lanode(pRExC_state, EVAL,
                                       n,

                                       /* for later propagation into (??{})
                                        * return value */
                                       RExC_flags & RXf_PMf_COMPILETIME
                                      );
d9857 2
d9864 1
a9864 1
		ret = reg2Lanode(pRExC_state, EVAL, n, 0);
a9871 1
                const int DEFINE_len = sizeof("DEFINE") - 1;
d9873 3
a9875 6
                    if (   RExC_parse < RExC_end - 1
                        && (   RExC_parse[1] == '='
                            || RExC_parse[1] == '!'
                            || RExC_parse[1] == '<'
                            || RExC_parse[1] == '{')
                    ) { /* Lookahead or eval. */
d9884 2
a9885 2
                        if (flag & (RESTART_PASS1|NEED_UTF8)) {
                            *flagp = flag & (RESTART_PASS1|NEED_UTF8);
a9890 2
		    /* Fall through to ‘Unknown switch condition’ at the
		       end of the if/else chain. */
d9900 1
a9900 4
	            if (   RExC_parse == name_start
                        || RExC_parse >= RExC_end
                        || *RExC_parse != ch)
                    {
a9902 1
                    }
d9912 7
a9918 3
		else if (RExC_end - RExC_parse >= DEFINE_len
                        && strnEQ(RExC_parse, "DEFINE", DEFINE_len))
                {
d9920 1
a9920 1
		    RExC_parse += DEFINE_len;
a9925 4
                    /* parno == 0 => /(?(R)YES|NO)/  "in any form of recursion OR eval"
                     * parno == 1 => /(?(R0)YES|NO)/ "in GOSUB (?0) / (?R)"
                     * parno == 2 => /(?(R1)YES|NO)/ "in GOSUB (?1) (parno-1)"
                     */
d9927 4
a9930 13
                    if (RExC_parse[0] == '0') {
                        parno = 1;
                        RExC_parse++;
                    }
                    else if (RExC_parse[0] >= '1' && RExC_parse[0] <= '9' ) {
                        UV uv;
                        if (grok_atoUV(RExC_parse, &uv, &endptr)
                            && uv <= I32_MAX
                        ) {
                            parno = (I32)uv + 1;
                            RExC_parse = (char*)endptr;
                        }
                        /* else "Switch condition not recognized" below */
d9938 1
a9938 13

                        /* we should only have a false sv_dat when
                         * SIZE_ONLY is true, and we always have false
                         * sv_dat when SIZE_ONLY is true.
                         * reg_scan_name() will VFAIL() if the name is
                         * unknown when SIZE_ONLY is false, and otherwise
                         * will return something, and when SIZE_ONLY is
                         * true, reg_scan_name() just parses the string,
                         * and doesnt return anything. (in theory) */
                        assert(SIZE_ONLY ? !sv_dat : !!sv_dat);

                        if (sv_dat)
                            parno = 1 + *((I32 *)SvPVX(sv_dat));
d9946 5
a9950 10
                    UV uv;
                    if (grok_atoUV(RExC_parse, &uv, &endptr)
                        && uv <= I32_MAX
                    ) {
                        parno = (I32)uv;
                        RExC_parse = (char*)endptr;
                    }
                    else {
                        vFAIL("panic: grok_atoUV returned FALSE");
                    }
d9954 5
a9958 1
		    if (UCHARAT(RExC_parse) != ')') {
a9961 1
		    nextchar(pRExC_state);
d9966 2
a9967 2
                        if (flags & (RESTART_PASS1|NEED_UTF8)) {
                            *flagp = flags & (RESTART_PASS1|NEED_UTF8);
d9975 1
a9975 2
		    c = UCHARAT(RExC_parse);
                    nextchar(pRExC_state);
d9986 2
a9987 2
                            if (flags & (RESTART_PASS1|NEED_UTF8)) {
                                *flagp = flags & (RESTART_PASS1|NEED_UTF8);
d9996 1
a9996 2
                        c = UCHARAT(RExC_parse);
                        nextchar(pRExC_state);
d10000 2
a10001 6
                    if (c != ')') {
                        if (RExC_parse >= RExC_end)
                            vFAIL("Switch (?(condition)... not terminated");
                        else
                            vFAIL("Switch (?(condition)... contains too many branches");
                    }
d10015 4
a10018 2
                RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;
                vFAIL("Unknown switch condition (?(...))");
d10023 1
a10023 1
            case 0: /* A NUL */
d10028 1
a10028 1
	        RExC_parse = (char *) seqstart + 1;
d10032 1
a10032 2
                    if (RExC_parse < RExC_end)
                        nextchar(pRExC_state);
d10042 1
a10042 1
	else if (!(RExC_flags & RXf_PMf_NOCAPTURE)) {   /* (...) */
d10051 2
a10052 1
                if (RExC_open_parens && !RExC_open_parens[parno])
d10054 2
a10055 3
                    DEBUG_OPTIMISE_MORE_r(Perl_re_printf( aTHX_
                        "%*s%*s Setting open paren #%"IVdf" to %d\n",
                        22, "|    |", (int)(depth * 2 + 1), "",
d10057 1
a10057 1
                    RExC_open_parens[parno]= ret;
a10062 4
	} else {
            /* with RXf_PMf_NOCAPTURE treat (...) as (?:...) */
            paren = ':';
	    ret = NULL;
d10076 2
a10077 2
        if (flags & (RESTART_PASS1|NEED_UTF8)) {
            *flagp = flags & (RESTART_PASS1|NEED_UTF8);
d10123 2
a10124 2
            if (flags & (RESTART_PASS1|NEED_UTF8)) {
                *flagp = flags & (RESTART_PASS1|NEED_UTF8);
d10142 5
a10146 5
            if ( RExC_close_parens ) {
                DEBUG_OPTIMISE_MORE_r(Perl_re_printf( aTHX_
                        "%*s%*s Setting close paren #%"IVdf" to %d\n",
                        22, "|    |", (int)(depth * 2 + 1), "", (IV)parno, REG_NODE_NUM(ender)));
                RExC_close_parens[parno]= ender;
d10158 1
a10158 1
	    /* FALLTHROUGH */
d10165 2
a10166 9
                assert(!RExC_end_op); /* there can only be one! */
                RExC_end_op = ender;
                if (RExC_close_parens) {
                    DEBUG_OPTIMISE_MORE_r(Perl_re_printf( aTHX_
                        "%*s%*s Setting close paren #0 (END) to %d\n",
                        22, "|    |", (int)(depth * 2 + 1), "", REG_NODE_NUM(ender)));

                    RExC_close_parens[0]= ender;
                }
d10171 2
d10174 4
a10177 4
            regprop(RExC_rx, RExC_mysv1, lastbr, NULL, pRExC_state);
            regprop(RExC_rx, RExC_mysv2, ender, NULL, pRExC_state);
            Perl_re_printf( aTHX_  "~ tying lastbr %s (%"IVdf") to ender %s (%"IVdf") offset %"IVdf"\n",
                          SvPV_nolen_const(RExC_mysv1),
d10179 1
a10179 1
                          SvPV_nolen_const(RExC_mysv2),
d10212 2
d10215 4
a10218 4
                    regprop(RExC_rx, RExC_mysv1, ret, NULL, pRExC_state);
                    regprop(RExC_rx, RExC_mysv2, ender, NULL, pRExC_state);
                    Perl_re_printf( aTHX_  "~ converting ret %s (%"IVdf") to ender %s (%"IVdf") offset %"IVdf"\n",
                                  SvPV_nolen_const(RExC_mysv1),
d10220 1
a10220 1
                                  SvPV_nolen_const(RExC_mysv2),
d10259 1
a10259 2
        /* restore original flags, but keep (?p) and, if we've changed from /d
         * rules to /u, keep the /u */
d10261 1
a10261 4
        if (DEPENDS_SEMANTICS && RExC_uni_semantics) {
            set_regex_charset(&RExC_flags, REGEX_UNICODE_CHARSET);
        }
	if (RExC_parse >= RExC_end || UCHARAT(RExC_parse) != ')') {
a10264 1
	nextchar(pRExC_state);
d10273 1
a10273 1
	NOT_REACHED; /* NOTREACHED */
d10289 2
a10290 2
 * Returns NULL, setting *flagp to RESTART_PASS1 if the sizing scan needs to be
 * restarted, or'd with NEED_UTF8 if the pattern needs to be upgraded to UTF-8
d10295 1
d10322 2
a10323 2
    skip_to_be_ignored_text(pRExC_state, &RExC_parse,
                            FALSE /* Don't force to /x */ );
d10330 2
a10331 2
            if (flags & (RESTART_PASS1|NEED_UTF8)) {
                *flagp = flags & (RESTART_PASS1|NEED_UTF8);
d10342 1
a10342 3
	    /* FIXME adding one for every branch after the first is probably
	     * excessive now we have TRIE support. (hv) */
	    MARK_NAUGHTY(1);
d10371 2
a10372 2
 * Returns NULL, setting *flagp to RESTART_PASS1 if the sizing scan needs to be
 * restarted, or'd with NEED_UTF8 if the pattern needs to be upgraded to UTF-8
d10377 1
a10388 1
    UV uv;
d10401 2
a10402 2
	if (flags & (TRYAGAIN|RESTART_PASS1|NEED_UTF8))
	    *flagp |= flags & (TRYAGAIN|RESTART_PASS1|NEED_UTF8);
d10410 1
a10410 1
    if (op == '{' && regcurly(RExC_parse)) {
a10425 1
            const char* endptr;
d10429 1
a10429 9
            if (isDIGIT(*RExC_parse)) {
                if (!grok_atoUV(RExC_parse, &uv, &endptr))
                    vFAIL("Invalid quantifier in {,}");
                if (uv >= REG_INFTY)
                    vFAIL2("Quantifier in {,} bigger than %d", REG_INFTY - 1);
                min = (I32)uv;
            } else {
                min = 0;
            }
d10434 2
a10435 7
            if (isDIGIT(*maxpos)) {
                if (!grok_atoUV(maxpos, &uv, &endptr))
                    vFAIL("Invalid quantifier in {,}");
                if (uv >= REG_INFTY)
                    vFAIL2("Quantifier in {,} bigger than %d", REG_INFTY - 1);
                max = (I32)uv;
            } else {
d10437 2
a10438 1
            }
d10444 1
d10448 1
a10448 1
                     * away, but we can shrink it by the amount we are about
d10450 1
a10450 1
                    RExC_size += PREVOPER(RExC_size) - regarglen[(U8)OPFAIL];
a10452 1
                    ckWARNreg(RExC_parse, "Quantifier {n,m} with n > m can't match");
d10455 1
a10455 1
                ret = reganode(pRExC_state, OPFAIL, 0);
d10458 3
a10460 1
            else if (min == max && *RExC_parse == '?')
d10462 1
a10462 1
                if (PASS2) {
d10467 3
d10472 1
a10472 1
	  do_curly:
d10474 1
a10474 15
                if (min == 0 && max == REG_INFTY) {
                    reginsert(pRExC_state, STAR, ret, depth+1);
                    ret->flags = 0;
                    MARK_NAUGHTY(4);
                    RExC_seen |= REG_UNBOUNDED_QUANTIFIER_SEEN;
                    goto nest_check;
                }
                if (min == 1 && max == REG_INFTY) {
                    reginsert(pRExC_state, PLUS, ret, depth+1);
                    ret->flags = 0;
                    MARK_NAUGHTY(3);
                    RExC_seen |= REG_UNBOUNDED_QUANTIFIER_SEEN;
                    goto nest_check;
                }
                MARK_NAUGHTY_EXP(2, 2);
d10500 1
a10500 1
                MARK_NAUGHTY_EXP(1, 4);     /* compound interest */
d10547 7
a10553 1
    if (op == '*') {
d10557 6
d10583 1
a10583 1
    if (*RExC_parse == '?') {
d10588 2
a10589 1
    else if (*RExC_parse == '+') {
d10600 1
a10600 1
    if (ISMULT2(RExC_parse)) {
d10609 3
a10611 7
S_grok_bslash_N(pTHX_ RExC_state_t *pRExC_state,
                regnode ** node_p,
                UV * code_point_p,
                int * cp_count,
                I32 * flagp,
                const bool strict,
                const U32 depth
a10613 75
 /* This routine teases apart the various meanings of \N and returns
  * accordingly.  The input parameters constrain which meaning(s) is/are valid
  * in the current context.
  *
  * Exactly one of <node_p> and <code_point_p> must be non-NULL.
  *
  * If <code_point_p> is not NULL, the context is expecting the result to be a
  * single code point.  If this \N instance turns out to a single code point,
  * the function returns TRUE and sets *code_point_p to that code point.
  *
  * If <node_p> is not NULL, the context is expecting the result to be one of
  * the things representable by a regnode.  If this \N instance turns out to be
  * one such, the function generates the regnode, returns TRUE and sets *node_p
  * to point to that regnode.
  *
  * If this instance of \N isn't legal in any context, this function will
  * generate a fatal error and not return.
  *
  * On input, RExC_parse should point to the first char following the \N at the
  * time of the call.  On successful return, RExC_parse will have been updated
  * to point to just after the sequence identified by this routine.  Also
  * *flagp has been updated as needed.
  *
  * When there is some problem with the current context and this \N instance,
  * the function returns FALSE, without advancing RExC_parse, nor setting
  * *node_p, nor *code_point_p, nor *flagp.
  *
  * If <cp_count> is not NULL, the caller wants to know the length (in code
  * points) that this \N sequence matches.  This is set even if the function
  * returns FALSE, as detailed below.
  *
  * There are 5 possibilities here, as detailed in the next 5 paragraphs.
  *
  * Probably the most common case is for the \N to specify a single code point.
  * *cp_count will be set to 1, and *code_point_p will be set to that code
  * point.
  *
  * Another possibility is for the input to be an empty \N{}, which for
  * backwards compatibility we accept.  *cp_count will be set to 0. *node_p
  * will be set to a generated NOTHING node.
  *
  * Still another possibility is for the \N to mean [^\n]. *cp_count will be
  * set to 0. *node_p will be set to a generated REG_ANY node.
  *
  * The fourth possibility is that \N resolves to a sequence of more than one
  * code points.  *cp_count will be set to the number of code points in the
  * sequence. *node_p * will be set to a generated node returned by this
  * function calling S_reg().
  *
  * The final possibility is that it is premature to be calling this function;
  * that pass1 needs to be restarted.  This can happen when this changes from
  * /d to /u rules, or when the pattern needs to be upgraded to UTF-8.  The
  * latter occurs only when the fourth possibility would otherwise be in
  * effect, and is because one of those code points requires the pattern to be
  * recompiled as UTF-8.  The function returns FALSE, and sets the
  * RESTART_PASS1 and NEED_UTF8 flags in *flagp, as appropriate.  When this
  * happens, the caller needs to desist from continuing parsing, and return
  * this information to its caller.  This is not set for when there is only one
  * code point, as this can be called as part of an ANYOF node, and they can
  * store above-Latin1 code points without the pattern having to be in UTF-8.
  *
  * For non-single-quoted regexes, the tokenizer has resolved character and
  * sequence names inside \N{...} into their Unicode values, normalizing the
  * result into what we should see here: '\N{U+c1.c2...}', where c1... are the
  * hex-represented code points in the sequence.  This is done there because
  * the names can vary based on what charnames pragma is in scope at the time,
  * so we need a way to take a snapshot of what they resolve to at the time of
  * the original parse. [perl #56444].
  *
  * That parsing is skipped for single-quoted regexes, so we may here get
  * '\N{NAME}'.  This is a fatal error.  These names have to be resolved by the
  * parser.  But if the single-quoted regex is something like '\N{U+41}', that
  * is legal and handled here.  The code point is Unicode, and has to be
  * translated into the native character set for non-ASCII platforms.
  */
d10615 48
a10662 1
    char * endbrace;    /* points to '}' following the name */
d10665 2
a10666 1
    char* p = RExC_parse; /* Temporary */
d10674 1
a10674 6
    assert(cBOOL(node_p) ^ cBOOL(code_point_p));  /* Exactly one should be set */
    assert(! (node_p && cp_count));               /* At most 1 should be set */

    if (cp_count) {     /* Initialize return for the most common case */
        *cp_count = 1;
    }
d10677 1
a10677 1
     * modifier.  The other meanings do not, so use a temporary until we find
d10679 3
a10681 2
    skip_to_be_ignored_text(pRExC_state, &p,
                            FALSE /* Don't force to /x */ );
d10684 2
a10685 3
     * [^\n].  The latter is assumed when the {...} following the \N is a legal
     * quantifier, or there is no '{' at all */
    if (*p != '{' || regcurly(p)) {
a10686 4
        if (cp_count) {
            *cp_count = -1;
        }

d10688 4
d10694 3
a10696 1

d10699 1
a10699 1
	MARK_NAUGHTY(1);
d10716 1
a10716 1
    if (! (endbrace = strchr(RExC_parse, '}'))  /* no trailing brace */
d10718 4
a10721 3
              || (endbrace - RExC_parse >= 2	/* U+ (bad hex is checked... */
                  && strnEQ(RExC_parse, "U+", 2)))) /* ... below for a better
                                                       error msg) */
a10726 3
    REQUIRE_UNI_RULES(flagp, FALSE); /* Unicode named chars imply Unicode
                                        semantics */

d10728 19
a10746 6
        if (strict) {
            RExC_parse++;   /* Position after the "}" */
            vFAIL("Zero length \\N{}");
        }
        if (cp_count) {
            *cp_count = 0;
d10749 1
a10749 6
	if (! node_p) {
            return FALSE;
        }

        *node_p = reg_node(pRExC_state,NOTHING);
        return TRUE;
d10752 1
a10754 2
    /* Because toke.c has generated a special construct for us guaranteed not
     * to have NULs, we can use a str function */
d10759 1
d10761 12
a10772 9
    if (endchar >= endbrace) {
	STRLEN length_of_hex;
	I32 grok_hex_flags;

        /* Here, exactly one code point.  If that isn't what is wanted, fail */
        if (! code_point_p) {
            RExC_parse = p;
            return FALSE;
        }
d10774 1
a10774 19
        /* Convert code point from hex */
	length_of_hex = (STRLEN)(endchar - RExC_parse);
	grok_hex_flags = PERL_SCAN_ALLOW_UNDERSCORES
                           | PERL_SCAN_DISALLOW_PREFIX

                             /* No errors in the first pass (See [perl
                              * #122671].)  We let the code below find the
                              * errors when there are multiple chars. */
                           | ((SIZE_ONLY)
                              ? PERL_SCAN_SILENT_ILLDIGIT
                              : 0);

        /* This routine is the one place where both single- and double-quotish
         * \N{U+xxxx} are evaluated.  The value is a Unicode code point which
         * must be converted to native. */
	*code_point_p = UNI_TO_NATIVE(grok_hex(RExC_parse,
                                         &length_of_hex,
                                         &grok_hex_flags,
                                         NULL));
d10777 10
a10786 11
         * bypass it by using single quoting, so check.  Don't do the check
         * here when there are multiple chars; we do it below anyway. */
        if (length_of_hex == 0
            || length_of_hex != (STRLEN)(endchar - RExC_parse) )
        {
            RExC_parse += length_of_hex;	/* Includes all the valid */
            RExC_parse += (RExC_orig_utf8)	/* point to after 1st invalid */
                            ? UTF8SKIP(RExC_parse)
                            : 1;
            /* Guard against malformed utf8 */
            if (RExC_parse >= endchar) {
d10789 11
a10799 1
            vFAIL("Invalid hexadecimal number in \\N{U+...}");
a10802 1
        return TRUE;
d10804 1
a10804 6
    else {  /* Is a multiple character sequence */
	SV * substitute_parse;
	STRLEN len;
	char *orig_end = RExC_end;
	char *save_start = RExC_start;
        I32 flags;
d10806 7
a10812 20
        /* Count the code points, if desired, in the sequence */
        if (cp_count) {
            *cp_count = 0;
            while (RExC_parse < endbrace) {
                /* Point to the beginning of the next character in the sequence. */
                RExC_parse = endchar + 1;
                endchar = RExC_parse + strcspn(RExC_parse, ".}");
                (*cp_count)++;
            }
        }

        /* Fail if caller doesn't want to handle a multi-code-point sequence.
         * But don't backup up the pointer if the caller want to know how many
         * code points there are (they can then handle things) */
        if (! node_p) {
            if (! cp_count) {
                RExC_parse = p;
            }
            return FALSE;
        }
d10815 7
a10821 4
         * \x{char1}\x{char2}...  and then call reg recursively to parse it
         * (enclosing in "(?: ... )" ).  That way, it retains its atomicness,
         * while not having to worry about special handling that some code
         * points may have. */
d10823 4
a10826 1
	substitute_parse = newSVpvs("?:");
a10837 1

d10839 1
a10839 1
        sv_catpv(substitute_parse, ")");
d10841 1
a10841 2
        RExC_parse = RExC_start = RExC_adjusted_start = SvPV(substitute_parse,
                                                             len);
d10844 1
a10844 2
	if (len < (STRLEN) 8) {
            RExC_parse = endbrace;
d10849 1
a10849 3
        /* The values are Unicode, and therefore not subject to recoding, but
         * have to be converted to native on a non-Unicode (meaning non-ASCII)
         * platform. */
a10850 3
#ifdef EBCDIC
        RExC_recode_x_to_native = 1;
#endif
d10852 4
a10855 8
        if (node_p) {
            if (!(*node_p = reg(pRExC_state, 1, &flags, depth+1))) {
                if (flags & (RESTART_PASS1|NEED_UTF8)) {
                    *flagp = flags & (RESTART_PASS1|NEED_UTF8);
                    return FALSE;
                }
                FAIL2("panic: reg returned NULL to grok_bslash_N, flags=%#"UVxf"",
                    (UV) flags);
d10857 2
a10858 1
            *flagp |= flags&(HASWIDTH|SPSTART|SIMPLE|POSTPONED);
d10860 1
a10861 2
        /* Restore the saved values */
	RExC_start = RExC_adjusted_start = save_start;
a10864 3
#ifdef EBCDIC
        RExC_recode_x_to_native = 0;
#endif
a10865 1
        SvREFCNT_dec_NN(substitute_parse);
d10867 1
d10869 1
a10869 2
        return TRUE;
    }
d10884 1
a10884 1
S_reg_recode(pTHX_ const U8 value, SV **encp)
d10887 1
a10887 1
    SV * const sv = newSVpvn_flags((const char *) &value, numlen, SVs_TEMP);
d10907 1
a10907 1
S_compute_EXACTish(RExC_state_t *pRExC_state)
d10914 1
a10914 3
        return (LOC)
                ? EXACTL
                : EXACT;
d10971 1
a10971 1
            if (UVCHR_IS_INVARIANT(code_point)) {
d10975 1
a10975 1
                else { /* Here is /i and not /l. (toFOLD() is defined on just
d11006 1
a11006 4
                    && folded == code_point /* This quickly rules out many
                                               cases, avoiding the
                                               _invlist_contains_cp() overhead
                                               for those.  */
d11009 1
a11009 3
                    OP(node) = (LOC)
                               ? EXACTL
                               : EXACT;
a11027 3
#if    UNICODE_MAJOR_VERSION > 3 /* no multifolds in early Unicode */   \
   || (UNICODE_MAJOR_VERSION == 3 && (   UNICODE_DOT_VERSION > 0)       \
                                      || UNICODE_DOT_DOT_VERSION > 0)
d11029 1
a11029 3
#else
        else if (1) {
#endif
d11072 4
a11075 8
    if ((len == 1 || (UTF && len == UVCHR_SKIP(code_point)))
#if    UNICODE_MAJOR_VERSION > 3 /* no multifolds in early Unicode */   \
   || (UNICODE_MAJOR_VERSION == 3 && (   UNICODE_DOT_VERSION > 0)       \
                                      || UNICODE_DOT_DOT_VERSION > 0)
        && ( code_point != LATIN_SMALL_LETTER_SHARP_S
            || ! FOLD || ! DEPENDS_SEMANTICS)
#endif
    ) {
d11086 1
a11086 1
/* Parse backref decimal value, unless it's too big to sensibly be a backref,
d11092 6
a11097 5
    const char* endptr;
    UV val;
    if (grok_atoUV(p, &val, &endptr) && val <= I32_MAX)
        return (I32)val;
    return I32_MAX;
d11162 2
a11163 2
   Returns NULL, setting *flagp to RESTART_PASS1 if the sizing scan needs to be
   restarted, or'd with NEED_UTF8 if the pattern needs to be upgraded to UTF-8
d11170 1
d11173 1
a11173 1
    char *parse_start;
a11175 1
    U8 arg;
d11185 1
a11185 3
  tryagain:
    parse_start = RExC_parse;
    assert(RExC_parse < RExC_end);
d11192 2
d11195 1
a11195 1
	    ret = reg_node(pRExC_state, SBOL);
d11204 2
d11207 1
a11207 1
	    ret = reg_node(pRExC_state, SEOL);
d11217 1
a11217 1
	MARK_NAUGHTY(1);
a11226 3
                       (bool) RExC_strict,
                       TRUE, /* Allow an optimized regnode result */
                       NULL,
d11228 4
d11233 1
a11233 1
            if (*flagp & (RESTART_PASS1|NEED_UTF8))
a11237 4
	if (*RExC_parse != ']') {
	    RExC_parse = oregcomp_parse;
	    vFAIL("Unmatched [");
	}
d11247 1
a11247 1
		    if (RExC_parse >= RExC_end) {
d11254 2
a11255 2
                if (flags & (RESTART_PASS1|NEED_UTF8)) {
                    *flagp = flags & (RESTART_PASS1|NEED_UTF8);
d11272 6
d11297 2
a11298 2
	RExC_parse++;
	switch ((U8)*RExC_parse) {
a11302 5
            /* SBOL is shared with /^/ so we set the flags so we can tell
             * /\A/ from /^/ in split. We check ret because first pass we
             * have no regop struct to set the flags on. */
            if (PASS2)
                ret->flags = 1;
d11331 4
a11334 1
	    vFAIL("\\C no longer supported");
a11346 3
	case 'B':
            invert = 1;
            /* FALLTHROUGH */
a11347 3
          {
	    regex_charset charset = get_regex_charset(RExC_flags);

d11350 5
a11354 3
	    op = BOUND + charset;

            if (op == BOUNDL) {
a11356 1

d11358 1
d11360 14
a11373 5
	    if (RExC_parse >= RExC_end || *(RExC_parse + 1) != '{') {
                FLAGS(ret) = TRADITIONAL_BOUND;
                if (PASS2 && op > BOUNDA) {  /* /aa is same as /a */
                    OP(ret) = BOUNDA;
                }
d11375 6
a11380 76
            else {
                STRLEN length;
                char name = *RExC_parse;
                char * endbrace;
                RExC_parse += 2;
                endbrace = strchr(RExC_parse, '}');

                if (! endbrace) {
                    vFAIL2("Missing right brace on \\%c{}", name);
                }
                /* XXX Need to decide whether to take spaces or not.  Should be
                 * consistent with \p{}, but that currently is SPACE, which
                 * means vertical too, which seems wrong
                 * while (isBLANK(*RExC_parse)) {
                    RExC_parse++;
                }*/
                if (endbrace == RExC_parse) {
                    RExC_parse++;  /* After the '}' */
                    vFAIL2("Empty \\%c{}", name);
                }
                length = endbrace - RExC_parse;
                /*while (isBLANK(*(RExC_parse + length - 1))) {
                    length--;
                }*/
                switch (*RExC_parse) {
                    case 'g':
                        if (length != 1
                            && (length != 3 || strnNE(RExC_parse + 1, "cb", 2)))
                        {
                            goto bad_bound_type;
                        }
                        FLAGS(ret) = GCB_BOUND;
                        break;
                    case 'l':
                        if (length != 2 || *(RExC_parse + 1) != 'b') {
                            goto bad_bound_type;
                        }
                        FLAGS(ret) = LB_BOUND;
                        break;
                    case 's':
                        if (length != 2 || *(RExC_parse + 1) != 'b') {
                            goto bad_bound_type;
                        }
                        FLAGS(ret) = SB_BOUND;
                        break;
                    case 'w':
                        if (length != 2 || *(RExC_parse + 1) != 'b') {
                            goto bad_bound_type;
                        }
                        FLAGS(ret) = WB_BOUND;
                        break;
                    default:
                      bad_bound_type:
                        RExC_parse = endbrace;
			vFAIL2utf8f(
                            "'%"UTF8f"' is an unknown bound type",
			    UTF8fARG(UTF, length, endbrace - length));
                        NOT_REACHED; /*NOTREACHED*/
                }
                RExC_parse = endbrace;
                REQUIRE_UNI_RULES(flagp, NULL);

                if (PASS2 && op >= BOUNDA) {  /* /aa is same as /a */
                    OP(ret) = BOUNDU;
                    length += 4;

                    /* Don't have to worry about UTF-8, in this message because
                     * to get here the contents of the \b must be ASCII */
                    ckWARN4reg(RExC_parse + 1,  /* Include the '}' in msg */
                              "Using /u for '%.*s' instead of /%s",
                              (unsigned) length,
                              endbrace - length + 1,
                              (charset == REGEX_ASCII_RESTRICTED_CHARSET)
                              ? ASCII_RESTRICT_PAT_MODS
                              : ASCII_MORE_RESTRICT_PAT_MODS);
                }
a11381 4

            if (PASS2 && invert) {
                OP(ret) += NBOUND - BOUND;
            }
a11382 1
          }
d11389 1
a11389 9
            if (! DEPENDS_SEMANTICS) {
                goto join_posix;
            }

            /* \d doesn't have any matches in the upper Latin1 range, hence /d
             * is equivalent to /u.  Changing to /u saves some branches at
             * runtime */
            op = POSIXU;
            goto join_posix_op_known;
d11418 1
a11418 1
          join_posix:
d11428 1
a11428 1
          join_posix_op_known:
d11440 1
a11440 1
            /* FALLTHROUGH */
d11442 1
a11442 1
          finish_meta_pat:
d11448 19
a11466 1
            RExC_parse--;
d11468 6
a11473 23
            ret = regclass(pRExC_state, flagp,depth+1,
                           TRUE, /* means just parse this element */
                           FALSE, /* don't allow multi-char folds */
                           FALSE, /* don't silence non-portable warnings.  It
                                     would be a bug if these returned
                                     non-portables */
                           (bool) RExC_strict,
                           TRUE, /* Allow an optimized regnode result */
                           NULL,
                           NULL);
            if (*flagp & RESTART_PASS1)
                return NULL;
            /* regclass() can only return RESTART_PASS1 and NEED_UTF8 if
             * multi-char folds are allowed.  */
            if (!ret)
                FAIL2("panic: regclass returned NULL to regatom, flags=%#"UVxf"",
                      (UV) *flagp);

            RExC_parse--;

            Set_Node_Offset(ret, parse_start);
            Set_Node_Cur_Length(ret, parse_start - 2);
            nextchar(pRExC_state);
d11476 10
a11485 11
            /* Handle \N, \N{} and \N{NAMED SEQUENCE} (the latter meaning the
             * \N{...} evaluates to a sequence of more than one code points).
             * The function call below returns a regnode, which is our result.
             * The parameters cause it to fail if the \N{} evaluates to a
             * single code point; we handle those like any other literal.  The
             * reason that the multicharacter case is handled here and not as
             * part of the EXACtish code is because of quantifiers.  In
             * /\N{BLAH}+/, the '+' applies to the whole thing, and doing it
             * this way makes that Just Happen. dmq.
             * join_exact() will join this up with adjacent EXACTish nodes
             * later on, if appropriate. */
d11487 6
a11492 11
            if (grok_bslash_N(pRExC_state,
                              &ret,     /* Want a regnode returned */
                              NULL,     /* Fail if evaluates to a single code
                                           point */
                              NULL,     /* Don't need a count of how many code
                                           points */
                              flagp,
                              RExC_strict,
                              depth)
            ) {
                break;
d11494 1
a11494 8

            if (*flagp & RESTART_PASS1)
                return NULL;

            /* Here, evaluates to a single code point.  Go get that */
            RExC_parse = parse_start;
            goto defchar;

d11496 1
a11496 1
      parse_named_seq:
d11498 2
a11499 6
            char ch;
            if (   RExC_parse >= RExC_end - 1
                || ((   ch = RExC_parse[1]) != '<'
                                      && ch != '\''
                                      && ch != '{'))
            {
d11504 36
a11539 9
		RExC_parse += 2;
                ret = handle_named_backref(pRExC_state,
                                           flagp,
                                           parse_start,
                                           (ch == '<')
                                           ? '>'
                                           : (ch == '{')
                                             ? '}'
                                             : '\'');
a11567 3
                    if (RExC_parse >= RExC_end) {
                        goto unterminated_g;
                    }
a11574 1
                          unterminated_g:
d11586 5
a11590 17
                    /* bare \NNN might be backref or octal - if it is larger
                     * than or equal RExC_npar then it is assumed to be an
                     * octal escape. Note RExC_npar is +1 from the actual
                     * number of parens. */
                    /* Note we do NOT check if num == I32_MAX here, as that is
                     * handled by the RExC_npar check */

                    if (
                        /* any numeric escape < 10 is always a backref */
                        num > 9
                        /* any numeric escape < RExC_npar is a backref */
                        && num >= RExC_npar
                        /* cannot be an octal escape if it starts with 8 */
                        && *RExC_parse != '8'
                        /* cannot be an octal escape it it starts with 9 */
                        && *RExC_parse != '9'
                    )
d11592 1
a11592 5
                        /* Probably not a backref, instead likely to be an
                         * octal character escape, e.g. \35 or \777.
                         * The above logic should make it obvious why using
                         * octal escapes in patterns is problematic. - Yves */
                        RExC_parse = parse_start;
d11597 37
a11633 35
                /* At this point RExC_parse points at a numeric escape like
                 * \12 or \88 or something similar, which we should NOT treat
                 * as an octal escape. It may or may not be a valid backref
                 * escape. For instance \88888888 is unlikely to be a valid
                 * backref. */
                while (isDIGIT(*RExC_parse))
                    RExC_parse++;
                if (hasbrace) {
                    if (*RExC_parse != '}')
                        vFAIL("Unterminated \\g{...} pattern");
                    RExC_parse++;
                }
                if (!SIZE_ONLY) {
                    if (num > (I32)RExC_rx->nparens)
                        vFAIL("Reference to nonexistent group");
                }
                RExC_sawback = 1;
                ret = reganode(pRExC_state,
                               ((! FOLD)
                                 ? REF
                                 : (ASCII_FOLD_RESTRICTED)
                                   ? REFFA
                                   : (AT_LEAST_UNI_SEMANTICS)
                                     ? REFFU
                                     : (LOC)
                                       ? REFFL
                                       : REFF),
                                num);
                *flagp |= HASWIDTH;

                /* override incorrect value set in reganode MJD */
                Set_Node_Offset(ret, parse_start);
                Set_Node_Cur_Length(ret, parse_start-1);
                skip_to_be_ignored_text(pRExC_state, &RExC_parse,
                                        FALSE /* Don't force to /x */ );
d11639 1
a11639 1
	    /* FALLTHROUGH */
d11643 1
a11643 1
            RExC_parse = parse_start;
d11645 1
a11645 1
	} /* end of switch on a \foo sequence */
d11649 2
a11650 8

        /* '#' comments should have been spaced over before this function was
         * called */
        assert((RExC_flags & RXf_PMf_EXTENDED) == 0);
	/*
        if (RExC_flags & RXf_PMf_EXTENDED) {
	    RExC_parse = reg_skipcomment( pRExC_state, RExC_parse );
	    if (RExC_parse < RExC_end)
d11653 1
a11653 1
        */
d11655 1
a11655 1
	/* FALLTHROUGH */
d11657 1
a11657 2
    default:
	  defchar: {
d11659 1
a11659 4
            /* Here, we have determined that the next thing is probably a
             * literal character.  RExC_parse points to the first byte of its
             * definition.  (It still may be an escape sequence that evaluates
             * to a single character) */
d11661 1
d11679 1
a11679 1
             * Similarly, we can convert EXACTFL nodes to EXACTFLU8 if they
d11700 1
a11700 1
	  reparse:
d11702 2
a11703 7
            /* We look for the EXACTFish to EXACT node optimizaton only if
             * folding.  (And we don't need to figure this out until pass 2).
             * XXX It might actually make sense to split the node into portions
             * that are exact and ones that aren't, so that we could later use
             * the exact ones to find the longest fixed and floating strings.
             * One would want to join them back into a larger node.  One could
             * use a pseudo regnode like 'EXACT_ORIG_FOLD' */
d11724 1
a11724 6

            assert(   ! UTF     /* Is at the beginning of a character */
                   || UTF8_IS_INVARIANT(UCHARAT(RExC_parse))
                   || UTF8_IS_START(UCHARAT(RExC_parse)));

	    for (p = RExC_parse;
d11730 2
a11731 4
                /* White space has already been ignored */
                assert(   (RExC_flags & RXf_PMf_EXTENDED) == 0
                       || ! is_PATWS_safe((p), RExC_end, UTF));

d11783 3
d11787 6
a11792 20
                        if (! grok_bslash_N(pRExC_state,
                                            NULL,   /* Fail if evaluates to
                                                       anything other than a
                                                       single code point */
                                            &ender, /* The returned single code
                                                       point */
                                            NULL,   /* Don't need a count of
                                                       how many code points */
                                            flagp,
                                            RExC_strict,
                                            depth)
                        ) {
                            if (*flagp & NEED_UTF8)
                                FAIL("panic: grok_bslash_N set NEED_UTF8");
                            if (*flagp & RESTART_PASS1)
                                return NULL;

                            /* Here, it wasn't a single code point.  Go close
                             * up this EXACTish node.  The switch() prior to
                             * this switch handles the other cases */
d11798 1
a11798 1
                            REQUIRE_UTF8(flagp);
d11814 1
a11814 1
			ender = ESC_NATIVE;
d11818 1
a11818 1
			ender = '\a';
d11829 2
a11830 2
						       PASS2, /* out warnings */
                                                       (bool) RExC_strict,
d11841 1
a11841 1
			    if (IN_ENCODING && ender < 0x100) {
d11845 1
a11845 1
				REQUIRE_UTF8(flagp);
d11858 3
a11860 3
						       PASS2, /* out warnings */
                                                       (bool) RExC_strict,
                                                       TRUE, /* Silence warnings
d11871 2
a11872 10
                            if (ender < 0x100) {
#ifdef EBCDIC
                                if (RExC_recode_x_to_native) {
                                    ender = LATIN1_TO_NATIVE(ender);
                                }
                                else
#endif
                                if (IN_ENCODING) {
                                    goto recode_encoding;
                                }
d11874 2
a11875 2
                            else {
				REQUIRE_UTF8(flagp);
d11881 1
a11881 1
			ender = grok_bslash_c(*p++, PASS2);
a11884 3
                        /* we have an escape like \8 which cannot be an octal escape
                         * so we exit the loop, and let the outer loop handle this
                         * escape which may or may not be a legitimate backref. */
d11893 2
a11894 2
                         * parsed capture buffer is a back reference. Anything
                         * else is octal.
a11909 1
                        /* FALLTHROUGH */
d11916 1
a11916 1
				REQUIRE_UTF8(flagp);
d11919 1
a11919 1
                            if (PASS2   /* like \08, \178 */
d11921 1
d11929 1
a11929 1
			if (IN_ENCODING && ender < 0x100)
d11932 1
a11932 1
		      recode_encoding:
d11934 3
a11936 3
			    SV* enc = _get_encoding();
			    ender = reg_recode((U8)ender, &enc);
			    if (!enc && PASS2)
d11938 1
a11938 1
			    REQUIRE_UTF8(flagp);
d11944 1
a11944 1
			/* FALLTHROUGH */
d11947 1
a11947 1
			    /* Include any left brace following the alpha to emphasize
a11955 11
		case '{':
		    /* Currently we don't warn when the lbrace is at the start
		     * of a construct.  This catches it in the middle of a
		     * literal string, or when it's the first thing after
		     * something like "\b" */
		    if (! SIZE_ONLY
			&& (len || (p > RExC_start && isALPHA_A(*(p -1)))))
		    {
			ckWARNregdep(p + 1, "Unescaped left brace in regex is deprecated, passed through");
		    }
		    /*FALLTHROUGH*/
d11957 10
d11968 1
a11968 1
		    if (! UTF8_IS_INVARIANT(*p) && UTF) {
d11980 5
a11984 7
                 * contains its ordinal, <p> points to the character after it.
                 * We need to check if the next non-ignored thing is a
                 * quantifier.  Move <p> to after anything that should be
                 * ignored, which, as a side effect, positions <p> for the next
                 * loop iteration */
                skip_to_be_ignored_text(pRExC_state, &p,
                                        FALSE /* Don't force to /x */ );
d11993 1
a11993 3
                if ((next_is_quantifier = (   LIKELY(p < RExC_end)
                                           && UNLIKELY(ISMULT2(p))))
                    && LIKELY(len))
d11999 20
a12018 1
                /* Ready to add 'ender' to the node */
d12020 14
a12033 1
                if (! FOLD) {  /* The simple case, just append the literal */
d12035 7
a12041 30
                    /* In the sizing pass, we need only the size of the
                     * character we are appending, hence we can delay getting
                     * its representation until PASS2. */
                    if (SIZE_ONLY) {
                        if (UTF) {
                            const STRLEN unilen = UVCHR_SKIP(ender);
                            s += unilen;

                            /* We have to subtract 1 just below (and again in
                             * the corresponding PASS2 code) because the loop
                             * increments <len> each time, as all but this path
                             * (and one other) through it add a single byte to
                             * the EXACTish node.  But these paths would change
                             * len to be the correct final value, so cancel out
                             * the increment that follows */
                            len += unilen - 1;
                        }
                        else {
                            s++;
                        }
                    } else { /* PASS2 */
                      not_fold_common:
                        if (UTF) {
                            U8 * new_s = uvchr_to_utf8((U8*)s, ender);
                            len += (char *) new_s - s - 1;
                            s = (char *) new_s;
                        }
                        else {
                            *(s++) = (char) ender;
                        }
d12044 7
a12050 33
                else if (LOC && is_PROBLEMATIC_LOCALE_FOLD_cp(ender)) {

                    /* Here are folding under /l, and the code point is
                     * problematic.  First, we know we can't simplify things */
                    maybe_exact = FALSE;
                    maybe_exactfu = FALSE;

                    /* A problematic code point in this context means that its
                     * fold isn't known until runtime, so we can't fold it now.
                     * (The non-problematic code points are the above-Latin1
                     * ones that fold to also all above-Latin1.  Their folds
                     * don't vary no matter what the locale is.) But here we
                     * have characters whose fold depends on the locale.
                     * Unlike the non-folding case above, we have to keep track
                     * of these in the sizing pass, so that we can make sure we
                     * don't split too-long nodes in the middle of a potential
                     * multi-char fold.  And unlike the regular fold case
                     * handled in the else clauses below, we don't actually
                     * fold and don't have special cases to consider.  What we
                     * do for both passes is the PASS2 code for non-folding */
                    goto not_fold_common;
                }
                else /* A regular FOLD code point */
                    if (! (   UTF
#if    UNICODE_MAJOR_VERSION > 3 /* no multifolds in early Unicode */   \
   || (UNICODE_MAJOR_VERSION == 3 && (   UNICODE_DOT_VERSION > 0)       \
                                      || UNICODE_DOT_DOT_VERSION > 0)
                            /* See comments for join_exact() as to why we fold
                             * this non-UTF at compile time */
                            || (   node_type == EXACTFU
                                && ender == LATIN_SMALL_LETTER_SHARP_S)
#endif
                )) {
d12054 1
a12054 1
                     * is_PROBLEMATIC_LOCALE_FOLD_cp) */
d12061 1
a12061 5
                        if (UNLIKELY(ender == LATIN_SMALL_LETTER_SHARP_S)) {
                            RExC_seen_unfolded_sharp_s = 1;
                            maybe_exactfu = FALSE;
                        }
                        else if (maybe_exactfu
d12063 6
a12068 8
#if    UNICODE_MAJOR_VERSION > 3 /* no multifolds in early Unicode */   \
   || (UNICODE_MAJOR_VERSION == 3 && (   UNICODE_DOT_VERSION > 0)       \
                                      || UNICODE_DOT_DOT_VERSION > 0)
                                || (   len > 0
                                    && isALPHA_FOLD_EQ(ender, 's')
                                    && isALPHA_FOLD_EQ(*(s-1), 's'))
#endif
                        )) {
d12077 1
a12077 1
                else {  /* FOLD, and UTF (or sharp s) */
d12084 2
a12085 1
                     * to back off accordingly.  */
d12088 1
a12088 1
                    if (isASCII_uni(ender)) {
d12208 1
a12208 1
                            if (! IS_NON_FINAL_FOLD(EIGHT_BIT_UTF8_TO_NATIVE(
d12251 1
a12251 1
                    if (maybe_exactfu && isALPHA_FOLD_EQ(ender, 's'))
d12304 2
a12305 2
          loopdone:   /* Jumped to when encounters something that shouldn't be
                         in the node */
d12321 1
a12321 3
                        OP(ret) = (LOC)
                                  ? EXACTL
                                  : EXACT;
d12324 1
a12324 3
                        OP(ret) = (LOC)
                                  ? EXACTFLU8
                                  : EXACTFU;
d12337 1
a12337 3
	    RExC_parse = p;
            skip_to_be_ignored_text(pRExC_state, &RExC_parse,
                                    FALSE /* Don't force to /x */ );
d12352 60
d12437 5
a12441 2
            if (end == UV_MAX && start <= NUM_ANYOF_CODE_POINTS) {
                ANYOF_FLAGS(node) |= ANYOF_MATCHES_ALL_ABOVE_BITMAP;
d12445 1
a12445 1
	    if (start >= NUM_ANYOF_CODE_POINTS) {
d12452 1
a12452 3
	    high = (end < NUM_ANYOF_CODE_POINTS - 1)
                   ? end
                   : NUM_ANYOF_CODE_POINTS - 1;
d12462 2
a12463 2
         * *invlist_ptr; similarly for code points above the bitmap if we have
         * a flag to match all of them anyways */
d12465 1
a12465 1
	    _invlist_subtract(*invlist_ptr, PL_InBitmap, invlist_ptr);
d12467 2
a12468 2
        if (ANYOF_FLAGS(node) & ANYOF_MATCHES_ALL_ABOVE_BITMAP) {
	    _invlist_intersection(*invlist_ptr, PL_InBitmap, invlist_ptr);
a12487 1
#define MAYBE_POSIXCC(c) (POSIXCC(c) || (c) == '^' || (c) == ';')
d12489 5
a12493 169
#define WARNING_PREFIX              "Assuming NOT a POSIX class since "
#define NO_BLANKS_POSIX_WARNING     "no blanks are allowed in one"
#define SEMI_COLON_POSIX_WARNING    "a semi-colon was found instead of a colon"

#define NOT_MEANT_TO_BE_A_POSIX_CLASS (OOB_NAMEDCLASS - 1)

/* 'posix_warnings' and 'warn_text' are names of variables in the following
 * routine. q.v. */
#define ADD_POSIX_WARNING(p, text)  STMT_START {                            \
        if (posix_warnings) {                                               \
            if (! warn_text) warn_text = newAV();                           \
            av_push(warn_text, Perl_newSVpvf(aTHX_                          \
                                             WARNING_PREFIX                 \
                                             text                           \
                                             REPORT_LOCATION,               \
                                             REPORT_LOCATION_ARGS(p)));     \
        }                                                                   \
    } STMT_END

STATIC int
S_handle_possible_posix(pTHX_ RExC_state_t *pRExC_state,

    const char * const s,      /* Where the putative posix class begins.
                                  Normally, this is one past the '['.  This
                                  parameter exists so it can be somewhere
                                  besides RExC_parse. */
    char ** updated_parse_ptr, /* Where to set the updated parse pointer, or
                                  NULL */
    AV ** posix_warnings,      /* Where to place any generated warnings, or
                                  NULL */
    const bool check_only      /* Don't die if error */
)
{
    /* This parses what the caller thinks may be one of the three POSIX
     * constructs:
     *  1) a character class, like [:blank:]
     *  2) a collating symbol, like [. .]
     *  3) an equivalence class, like [= =]
     * In the latter two cases, it croaks if it finds a syntactically legal
     * one, as these are not handled by Perl.
     *
     * The main purpose is to look for a POSIX character class.  It returns:
     *  a) the class number
     *      if it is a completely syntactically and semantically legal class.
     *      'updated_parse_ptr', if not NULL, is set to point to just after the
     *      closing ']' of the class
     *  b) OOB_NAMEDCLASS
     *      if it appears that one of the three POSIX constructs was meant, but
     *      its specification was somehow defective.  'updated_parse_ptr', if
     *      not NULL, is set to point to the character just after the end
     *      character of the class.  See below for handling of warnings.
     *  c) NOT_MEANT_TO_BE_A_POSIX_CLASS
     *      if it  doesn't appear that a POSIX construct was intended.
     *      'updated_parse_ptr' is not changed.  No warnings nor errors are
     *      raised.
     *
     * In b) there may be errors or warnings generated.  If 'check_only' is
     * TRUE, then any errors are discarded.  Warnings are returned to the
     * caller via an AV* created into '*posix_warnings' if it is not NULL.  If
     * instead it is NULL, warnings are suppressed.  This is done in all
     * passes.  The reason for this is that the rest of the parsing is heavily
     * dependent on whether this routine found a valid posix class or not.  If
     * it did, the closing ']' is absorbed as part of the class.  If no class,
     * or an invalid one is found, any ']' will be considered the terminator of
     * the outer bracketed character class, leading to very different results.
     * In particular, a '(?[ ])' construct will likely have a syntax error if
     * the class is parsed other than intended, and this will happen in pass1,
     * before the warnings would normally be output.  This mechanism allows the
     * caller to output those warnings in pass1 just before dieing, giving a
     * much better clue as to what is wrong.
     *
     * The reason for this function, and its complexity is that a bracketed
     * character class can contain just about anything.  But it's easy to
     * mistype the very specific posix class syntax but yielding a valid
     * regular bracketed class, so it silently gets compiled into something
     * quite unintended.
     *
     * The solution adopted here maintains backward compatibility except that
     * it adds a warning if it looks like a posix class was intended but
     * improperly specified.  The warning is not raised unless what is input
     * very closely resembles one of the 14 legal posix classes.  To do this,
     * it uses fuzzy parsing.  It calculates how many single-character edits it
     * would take to transform what was input into a legal posix class.  Only
     * if that number is quite small does it think that the intention was a
     * posix class.  Obviously these are heuristics, and there will be cases
     * where it errs on one side or another, and they can be tweaked as
     * experience informs.
     *
     * The syntax for a legal posix class is:
     *
     * qr/(?xa: \[ : \^? [:lower:]{4,6} : \] )/
     *
     * What this routine considers syntactically to be an intended posix class
     * is this (the comments indicate some restrictions that the pattern
     * doesn't show):
     *
     *  qr/(?x: \[?                         # The left bracket, possibly
     *                                      # omitted
     *          \h*                         # possibly followed by blanks
     *          (?: \^ \h* )?               # possibly a misplaced caret
     *          [:;]?                       # The opening class character,
     *                                      # possibly omitted.  A typo
     *                                      # semi-colon can also be used.
     *          \h*
     *          \^?                         # possibly a correctly placed
     *                                      # caret, but not if there was also
     *                                      # a misplaced one
     *          \h*
     *          .{3,15}                     # The class name.  If there are
     *                                      # deviations from the legal syntax,
     *                                      # its edit distance must be close
     *                                      # to a real class name in order
     *                                      # for it to be considered to be
     *                                      # an intended posix class.
     *          \h*
     *          [:punct:]?                  # The closing class character,
     *                                      # possibly omitted.  If not a colon
     *                                      # nor semi colon, the class name
     *                                      # must be even closer to a valid
     *                                      # one
     *          \h*
     *          \]?                         # The right bracket, possibly
     *                                      # omitted.
     *     )/
     *
     * In the above, \h must be ASCII-only.
     *
     * These are heuristics, and can be tweaked as field experience dictates.
     * There will be cases when someone didn't intend to specify a posix class
     * that this warns as being so.  The goal is to minimize these, while
     * maximizing the catching of things intended to be a posix class that
     * aren't parsed as such.
     */

    const char* p             = s;
    const char * const e      = RExC_end;
    unsigned complement       = 0;      /* If to complement the class */
    bool found_problem        = FALSE;  /* Assume OK until proven otherwise */
    bool has_opening_bracket  = FALSE;
    bool has_opening_colon    = FALSE;
    int class_number          = OOB_NAMEDCLASS; /* Out-of-bounds until find
                                                   valid class */
    AV* warn_text             = NULL;   /* any warning messages */
    const char * possible_end = NULL;   /* used for a 2nd parse pass */
    const char* name_start;             /* ptr to class name first char */

    /* If the number of single-character typos the input name is away from a
     * legal name is no more than this number, it is considered to have meant
     * the legal name */
    int max_distance          = 2;

    /* to store the name.  The size determines the maximum length before we
     * decide that no posix class was intended.  Should be at least
     * sizeof("alphanumeric") */
    UV input_text[15];

    PERL_ARGS_ASSERT_HANDLE_POSSIBLE_POSIX;

    if (p >= e) {
        return NOT_MEANT_TO_BE_A_POSIX_CLASS;
    }

    if (*(p - 1) != '[') {
        ADD_POSIX_WARNING(p, "it doesn't start with a '['");
        found_problem = TRUE;
    }
    else {
        has_opening_bracket = TRUE;
    }
d12495 1
a12495 4
    /* They could be confused and think you can put spaces between the
     * components */
    if (isBLANK(*p)) {
        found_problem = TRUE;
d12497 3
a12499 12
        do {
            p++;
        } while (p < e && isBLANK(*p));

        ADD_POSIX_WARNING(p, NO_BLANKS_POSIX_WARNING);
    }

    /* For [. .] and [= =].  These are quite different internally from [: :],
     * so they are handled separately.  */
    if (POSIXCC_NOTYET(*p) && p < e - 3) /* 1 for the close, and 1 for the ']'
                                            and 1 for at least one char in it
                                          */
d12501 2
a12502 2
        const char open_char  = *p;
        const char * temp_ptr = p + 1;
d12504 4
a12507 40
        /* These two constructs are not handled by perl, and if we find a
         * syntactically valid one, we croak.  khw, who wrote this code, finds
         * this explanation of them very unclear:
         * http://pubs.opengroup.org/onlinepubs/009696899/basedefs/xbd_chap09.html
         * And searching the rest of the internet wasn't very helpful either.
         * It looks like just about any byte can be in these constructs,
         * depending on the locale.  But unless the pattern is being compiled
         * under /l, which is very rare, Perl runs under the C or POSIX locale.
         * In that case, it looks like [= =] isn't allowed at all, and that
         * [. .] could be any single code point, but for longer strings the
         * constituent characters would have to be the ASCII alphabetics plus
         * the minus-hyphen.  Any sensible locale definition would limit itself
         * to these.  And any portable one definitely should.  Trying to parse
         * the general case is a nightmare (see [perl #127604]).  So, this code
         * looks only for interiors of these constructs that match:
         *      qr/.|[-\w]{2,}/
         * Using \w relaxes the apparent rules a little, without adding much
         * danger of mistaking something else for one of these constructs.
         *
         * [. .] in some implementations described on the internet is usable to
         * escape a character that otherwise is special in bracketed character
         * classes.  For example [.].] means a literal right bracket instead of
         * the ending of the class
         *
         * [= =] can legitimately contain a [. .] construct, but we don't
         * handle this case, as that [. .] construct will later get parsed
         * itself and croak then.  And [= =] is checked for even when not under
         * /l, as Perl has long done so.
         *
         * The code below relies on there being a trailing NUL, so it doesn't
         * have to keep checking if the parse ptr < e.
         */
        if (temp_ptr[1] == open_char) {
            temp_ptr++;
        }
        else while (    temp_ptr < e
                    && (isWORDCHAR(*temp_ptr) || *temp_ptr == '-'))
        {
            temp_ptr++;
        }
d12509 5
a12513 8
        if (*temp_ptr == open_char) {
            temp_ptr++;
            if (*temp_ptr == ']') {
                temp_ptr++;
                if (! found_problem && ! check_only) {
                    RExC_parse = (char *) temp_ptr;
                    vFAIL3("POSIX syntax [%c %c] is reserved for future "
                            "extensions", open_char, open_char);
d12515 1
a12515 8

                /* Here, the syntax wasn't completely valid, or else the call
                 * is to check-only */
                if (updated_parse_ptr) {
                    *updated_parse_ptr = (char *) temp_ptr;
                }

                return OOB_NAMEDCLASS;
d12517 2
d12520 3
d12524 71
a12594 5
        /* If we find something that started out to look like one of these
         * constructs, but isn't, we continue below so that it can be checked
         * for being a class name with a typo of '.' or '=' instead of a colon.
         * */
    }
d12596 4
a12599 8
    /* Here, we think there is a possibility that a [: :] class was meant, and
     * we have the first real character.  It could be they think the '^' comes
     * first */
    if (*p == '^') {
        found_problem = TRUE;
        ADD_POSIX_WARNING(p + 1, "the '^' must come after the colon");
        complement = 1;
        p++;
d12601 22
a12622 2
        if (isBLANK(*p)) {
            found_problem = TRUE;
d12624 4
a12627 6
            do {
                p++;
            } while (p < e && isBLANK(*p));

            ADD_POSIX_WARNING(p, NO_BLANKS_POSIX_WARNING);
        }
d12630 2
a12631 16
    /* But the first character should be a colon, which they could have easily
     * mistyped on a qwerty keyboard as a semi-colon (and which may be hard to
     * distinguish from a colon, so treat that as a colon).  */
    if (*p == ':') {
        p++;
        has_opening_colon = TRUE;
    }
    else if (*p == ';') {
        found_problem = TRUE;
        p++;
        ADD_POSIX_WARNING(p, SEMI_COLON_POSIX_WARNING);
        has_opening_colon = TRUE;
    }
    else {
        found_problem = TRUE;
        ADD_POSIX_WARNING(p, "there must be a starting ':'");
d12633 22
a12654 6
        /* Consider an initial punctuation (not one of the recognized ones) to
         * be a left terminator */
        if (*p != '^' && *p != ']' && isPUNCT(*p)) {
            p++;
        }
    }
d12656 1
a12656 3
    /* They may think that you can put spaces between the components */
    if (isBLANK(*p)) {
        found_problem = TRUE;
d12658 1
a12658 3
        do {
            p++;
        } while (p < e && isBLANK(*p));
d12660 2
a12661 1
        ADD_POSIX_WARNING(p, NO_BLANKS_POSIX_WARNING);
d12664 2
a12665 1
    if (*p == '^') {
d12667 2
a12668 19
        /* We consider something like [^:^alnum:]] to not have been intended to
         * be a posix class, but XXX maybe we should */
        if (complement) {
            return NOT_MEANT_TO_BE_A_POSIX_CLASS;
        }

        complement = 1;
        p++;
    }

    /* Again, they may think that you can put spaces between the components */
    if (isBLANK(*p)) {
        found_problem = TRUE;

        do {
            p++;
        } while (p < e && isBLANK(*p));

        ADD_POSIX_WARNING(p, NO_BLANKS_POSIX_WARNING);
d12671 3
a12673 69
    if (*p == ']') {

        /* XXX This ']' may be a typo, and something else was meant.  But
         * treating it as such creates enough complications, that that
         * possibility isn't currently considered here.  So we assume that the
         * ']' is what is intended, and if we've already found an initial '[',
         * this leaves this construct looking like [:] or [:^], which almost
         * certainly weren't intended to be posix classes */
        if (has_opening_bracket) {
            return NOT_MEANT_TO_BE_A_POSIX_CLASS;
        }

        /* But this function can be called when we parse the colon for
         * something like qr/[alpha:]]/, so we back up to look for the
         * beginning */
        p--;

        if (*p == ';') {
            found_problem = TRUE;
            ADD_POSIX_WARNING(p, SEMI_COLON_POSIX_WARNING);
        }
        else if (*p != ':') {

            /* XXX We are currently very restrictive here, so this code doesn't
             * consider the possibility that, say, /[alpha.]]/ was intended to
             * be a posix class. */
            return NOT_MEANT_TO_BE_A_POSIX_CLASS;
        }

        /* Here we have something like 'foo:]'.  There was no initial colon,
         * and we back up over 'foo.  XXX Unlike the going forward case, we
         * don't handle typos of non-word chars in the middle */
        has_opening_colon = FALSE;
        p--;

        while (p > RExC_start && isWORDCHAR(*p)) {
            p--;
        }
        p++;

        /* Here, we have positioned ourselves to where we think the first
         * character in the potential class is */
    }

    /* Now the interior really starts.  There are certain key characters that
     * can end the interior, or these could just be typos.  To catch both
     * cases, we may have to do two passes.  In the first pass, we keep on
     * going unless we come to a sequence that matches
     *      qr/ [[:punct:]] [[:blank:]]* \] /xa
     * This means it takes a sequence to end the pass, so two typos in a row if
     * that wasn't what was intended.  If the class is perfectly formed, just
     * this one pass is needed.  We also stop if there are too many characters
     * being accumulated, but this number is deliberately set higher than any
     * real class.  It is set high enough so that someone who thinks that
     * 'alphanumeric' is a correct name would get warned that it wasn't.
     * While doing the pass, we keep track of where the key characters were in
     * it.  If we don't find an end to the class, and one of the key characters
     * was found, we redo the pass, but stop when we get to that character.
     * Thus the key character was considered a typo in the first pass, but a
     * terminator in the second.  If two key characters are found, we stop at
     * the second one in the first pass.  Again this can miss two typos, but
     * catches a single one
     *
     * In the first pass, 'possible_end' starts as NULL, and then gets set to
     * point to the first key character.  For the second pass, it starts as -1.
     * */

    name_start = p;
  parse_name:
d12675 1
a12675 397
        bool has_blank               = FALSE;
        bool has_upper               = FALSE;
        bool has_terminating_colon   = FALSE;
        bool has_terminating_bracket = FALSE;
        bool has_semi_colon          = FALSE;
        unsigned int name_len        = 0;
        int punct_count              = 0;

        while (p < e) {

            /* Squeeze out blanks when looking up the class name below */
            if (isBLANK(*p) ) {
                has_blank = TRUE;
                found_problem = TRUE;
                p++;
                continue;
            }

            /* The name will end with a punctuation */
            if (isPUNCT(*p)) {
                const char * peek = p + 1;

                /* Treat any non-']' punctuation followed by a ']' (possibly
                 * with intervening blanks) as trying to terminate the class.
                 * ']]' is very likely to mean a class was intended (but
                 * missing the colon), but the warning message that gets
                 * generated shows the error position better if we exit the
                 * loop at the bottom (eventually), so skip it here. */
                if (*p != ']') {
                    if (peek < e && isBLANK(*peek)) {
                        has_blank = TRUE;
                        found_problem = TRUE;
                        do {
                            peek++;
                        } while (peek < e && isBLANK(*peek));
                    }

                    if (peek < e && *peek == ']') {
                        has_terminating_bracket = TRUE;
                        if (*p == ':') {
                            has_terminating_colon = TRUE;
                        }
                        else if (*p == ';') {
                            has_semi_colon = TRUE;
                            has_terminating_colon = TRUE;
                        }
                        else {
                            found_problem = TRUE;
                        }
                        p = peek + 1;
                        goto try_posix;
                    }
                }

                /* Here we have punctuation we thought didn't end the class.
                 * Keep track of the position of the key characters that are
                 * more likely to have been class-enders */
                if (*p == ']' || *p == '[' || *p == ':' || *p == ';') {

                    /* Allow just one such possible class-ender not actually
                     * ending the class. */
                    if (possible_end) {
                        break;
                    }
                    possible_end = p;
                }

                /* If we have too many punctuation characters, no use in
                 * keeping going */
                if (++punct_count > max_distance) {
                    break;
                }

                /* Treat the punctuation as a typo. */
                input_text[name_len++] = *p;
                p++;
            }
            else if (isUPPER(*p)) { /* Use lowercase for lookup */
                input_text[name_len++] = toLOWER(*p);
                has_upper = TRUE;
                found_problem = TRUE;
                p++;
            } else if (! UTF || UTF8_IS_INVARIANT(*p)) {
                input_text[name_len++] = *p;
                p++;
            }
            else {
                input_text[name_len++] = utf8_to_uvchr_buf((U8 *) p, e, NULL);
                p+= UTF8SKIP(p);
            }

            /* The declaration of 'input_text' is how long we allow a potential
             * class name to be, before saying they didn't mean a class name at
             * all */
            if (name_len >= C_ARRAY_LENGTH(input_text)) {
                break;
            }
        }

        /* We get to here when the possible class name hasn't been properly
         * terminated before:
         *   1) we ran off the end of the pattern; or
         *   2) found two characters, each of which might have been intended to
         *      be the name's terminator
         *   3) found so many punctuation characters in the purported name,
         *      that the edit distance to a valid one is exceeded
         *   4) we decided it was more characters than anyone could have
         *      intended to be one. */

        found_problem = TRUE;

        /* In the final two cases, we know that looking up what we've
         * accumulated won't lead to a match, even a fuzzy one. */
        if (   name_len >= C_ARRAY_LENGTH(input_text)
            || punct_count > max_distance)
        {
            /* If there was an intermediate key character that could have been
             * an intended end, redo the parse, but stop there */
            if (possible_end && possible_end != (char *) -1) {
                possible_end = (char *) -1; /* Special signal value to say
                                               we've done a first pass */
                p = name_start;
                goto parse_name;
            }

            /* Otherwise, it can't have meant to have been a class */
            return NOT_MEANT_TO_BE_A_POSIX_CLASS;
        }

        /* If we ran off the end, and the final character was a punctuation
         * one, back up one, to look at that final one just below.  Later, we
         * will restore the parse pointer if appropriate */
        if (name_len && p == e && isPUNCT(*(p-1))) {
            p--;
            name_len--;
        }

        if (p < e && isPUNCT(*p)) {
            if (*p == ']') {
                has_terminating_bracket = TRUE;

                /* If this is a 2nd ']', and the first one is just below this
                 * one, consider that to be the real terminator.  This gives a
                 * uniform and better positioning for the warning message  */
                if (   possible_end
                    && possible_end != (char *) -1
                    && *possible_end == ']'
                    && name_len && input_text[name_len - 1] == ']')
                {
                    name_len--;
                    p = possible_end;

                    /* And this is actually equivalent to having done the 2nd
                     * pass now, so set it to not try again */
                    possible_end = (char *) -1;
                }
            }
            else {
                if (*p == ':') {
                    has_terminating_colon = TRUE;
                }
                else if (*p == ';') {
                    has_semi_colon = TRUE;
                    has_terminating_colon = TRUE;
                }
                p++;
            }
        }

    try_posix:

        /* Here, we have a class name to look up.  We can short circuit the
         * stuff below for short names that can't possibly be meant to be a
         * class name.  (We can do this on the first pass, as any second pass
         * will yield an even shorter name) */
        if (name_len < 3) {
            return NOT_MEANT_TO_BE_A_POSIX_CLASS;
        }

        /* Find which class it is.  Initially switch on the length of the name.
         * */
        switch (name_len) {
            case 4:
                if (memEQ(name_start, "word", 4)) {
                    /* this is not POSIX, this is the Perl \w */
                    class_number = ANYOF_WORDCHAR;
                }
                break;
            case 5:
                /* Names all of length 5: alnum alpha ascii blank cntrl digit
                 *                        graph lower print punct space upper
                 * Offset 4 gives the best switch position.  */
                switch (name_start[4]) {
                    case 'a':
                        if (memEQ(name_start, "alph", 4)) /* alpha */
                            class_number = ANYOF_ALPHA;
                        break;
                    case 'e':
                        if (memEQ(name_start, "spac", 4)) /* space */
                            class_number = ANYOF_SPACE;
                        break;
                    case 'h':
                        if (memEQ(name_start, "grap", 4)) /* graph */
                            class_number = ANYOF_GRAPH;
                        break;
                    case 'i':
                        if (memEQ(name_start, "asci", 4)) /* ascii */
                            class_number = ANYOF_ASCII;
                        break;
                    case 'k':
                        if (memEQ(name_start, "blan", 4)) /* blank */
                            class_number = ANYOF_BLANK;
                        break;
                    case 'l':
                        if (memEQ(name_start, "cntr", 4)) /* cntrl */
                            class_number = ANYOF_CNTRL;
                        break;
                    case 'm':
                        if (memEQ(name_start, "alnu", 4)) /* alnum */
                            class_number = ANYOF_ALPHANUMERIC;
                        break;
                    case 'r':
                        if (memEQ(name_start, "lowe", 4)) /* lower */
                            class_number = (FOLD) ? ANYOF_CASED : ANYOF_LOWER;
                        else if (memEQ(name_start, "uppe", 4)) /* upper */
                            class_number = (FOLD) ? ANYOF_CASED : ANYOF_UPPER;
                        break;
                    case 't':
                        if (memEQ(name_start, "digi", 4)) /* digit */
                            class_number = ANYOF_DIGIT;
                        else if (memEQ(name_start, "prin", 4)) /* print */
                            class_number = ANYOF_PRINT;
                        else if (memEQ(name_start, "punc", 4)) /* punct */
                            class_number = ANYOF_PUNCT;
                        break;
                }
                break;
            case 6:
                if (memEQ(name_start, "xdigit", 6))
                    class_number = ANYOF_XDIGIT;
                break;
        }

        /* If the name exactly matches a posix class name the class number will
         * here be set to it, and the input almost certainly was meant to be a
         * posix class, so we can skip further checking.  If instead the syntax
         * is exactly correct, but the name isn't one of the legal ones, we
         * will return that as an error below.  But if neither of these apply,
         * it could be that no posix class was intended at all, or that one
         * was, but there was a typo.  We tease these apart by doing fuzzy
         * matching on the name */
        if (class_number == OOB_NAMEDCLASS && found_problem) {
            const UV posix_names[][6] = {
                                                { 'a', 'l', 'n', 'u', 'm' },
                                                { 'a', 'l', 'p', 'h', 'a' },
                                                { 'a', 's', 'c', 'i', 'i' },
                                                { 'b', 'l', 'a', 'n', 'k' },
                                                { 'c', 'n', 't', 'r', 'l' },
                                                { 'd', 'i', 'g', 'i', 't' },
                                                { 'g', 'r', 'a', 'p', 'h' },
                                                { 'l', 'o', 'w', 'e', 'r' },
                                                { 'p', 'r', 'i', 'n', 't' },
                                                { 'p', 'u', 'n', 'c', 't' },
                                                { 's', 'p', 'a', 'c', 'e' },
                                                { 'u', 'p', 'p', 'e', 'r' },
                                                { 'w', 'o', 'r', 'd' },
                                                { 'x', 'd', 'i', 'g', 'i', 't' }
                                            };
            /* The names of the above all have added NULs to make them the same
             * size, so we need to also have the real lengths */
            const UV posix_name_lengths[] = {
                                                sizeof("alnum") - 1,
                                                sizeof("alpha") - 1,
                                                sizeof("ascii") - 1,
                                                sizeof("blank") - 1,
                                                sizeof("cntrl") - 1,
                                                sizeof("digit") - 1,
                                                sizeof("graph") - 1,
                                                sizeof("lower") - 1,
                                                sizeof("print") - 1,
                                                sizeof("punct") - 1,
                                                sizeof("space") - 1,
                                                sizeof("upper") - 1,
                                                sizeof("word")  - 1,
                                                sizeof("xdigit")- 1
                                            };
            unsigned int i;
            int temp_max = max_distance;    /* Use a temporary, so if we
                                               reparse, we haven't changed the
                                               outer one */

            /* Use a smaller max edit distance if we are missing one of the
             * delimiters */
            if (   has_opening_bracket + has_opening_colon < 2
                || has_terminating_bracket + has_terminating_colon < 2)
            {
                temp_max--;
            }

            /* See if the input name is close to a legal one */
            for (i = 0; i < C_ARRAY_LENGTH(posix_names); i++) {

                /* Short circuit call if the lengths are too far apart to be
                 * able to match */
                if (abs( (int) (name_len - posix_name_lengths[i]))
                    > temp_max)
                {
                    continue;
                }

                if (edit_distance(input_text,
                                  posix_names[i],
                                  name_len,
                                  posix_name_lengths[i],
                                  temp_max
                                 )
                    > -1)
                { /* If it is close, it probably was intended to be a class */
                    goto probably_meant_to_be;
                }
            }

            /* Here the input name is not close enough to a valid class name
             * for us to consider it to be intended to be a posix class.  If
             * we haven't already done so, and the parse found a character that
             * could have been terminators for the name, but which we absorbed
             * as typos during the first pass, repeat the parse, signalling it
             * to stop at that character */
            if (possible_end && possible_end != (char *) -1) {
                possible_end = (char *) -1;
                p = name_start;
                goto parse_name;
            }

            /* Here neither pass found a close-enough class name */
            return NOT_MEANT_TO_BE_A_POSIX_CLASS;
        }

    probably_meant_to_be:

        /* Here we think that a posix specification was intended.  Update any
         * parse pointer */
        if (updated_parse_ptr) {
            *updated_parse_ptr = (char *) p;
        }

        /* If a posix class name was intended but incorrectly specified, we
         * output or return the warnings */
        if (found_problem) {

            /* We set flags for these issues in the parse loop above instead of
             * adding them to the list of warnings, because we can parse it
             * twice, and we only want one warning instance */
            if (has_upper) {
                ADD_POSIX_WARNING(p, "the name must be all lowercase letters");
            }
            if (has_blank) {
                ADD_POSIX_WARNING(p, NO_BLANKS_POSIX_WARNING);
            }
            if (has_semi_colon) {
                ADD_POSIX_WARNING(p, SEMI_COLON_POSIX_WARNING);
            }
            else if (! has_terminating_colon) {
                ADD_POSIX_WARNING(p, "there is no terminating ':'");
            }
            if (! has_terminating_bracket) {
                ADD_POSIX_WARNING(p, "there is no terminating ']'");
            }

            if (warn_text) {
                if (posix_warnings) {
                    /* mortalize to avoid a leak with FATAL warnings */
                    *posix_warnings = (AV *) sv_2mortal((SV *) warn_text);
                }
                else {
                    SvREFCNT_dec_NN(warn_text);
                }
            }
        }
        else if (class_number != OOB_NAMEDCLASS) {
            /* If it is a known class, return the class.  The class number
             * #defines are structured so each complement is +1 to the normal
             * one */
            return class_number + complement;
        }
        else if (! check_only) {

            /* Here, it is an unrecognized class.  This is an error (unless the
            * call is to check only, which we've already handled above) */
            const char * const complement_string = (complement)
                                                   ? "^"
                                                   : "";
            RExC_parse = (char *) p;
            vFAIL3utf8f("POSIX class [:%s%"UTF8f":] unknown",
                        complement_string,
                        UTF8fARG(UTF, RExC_parse - name_start - 2, name_start));
        }
d12678 1
a12678 27
    return OOB_NAMEDCLASS;
}
#undef ADD_POSIX_WARNING

STATIC unsigned  int
S_regex_set_precedence(const U8 my_operator) {

    /* Returns the precedence in the (?[...]) construct of the input operator,
     * specified by its character representation.  The precedence follows
     * general Perl rules, but it extends this so that ')' and ']' have (low)
     * precedence even though they aren't really operators */

    switch (my_operator) {
        case '!':
            return 5;
        case '&':
            return 4;
        case '^':
        case '|':
        case '+':
        case '-':
            return 3;
        case ')':
            return 2;
        case ']':
            return 1;
    }
d12680 4
a12683 2
    NOT_REACHED; /* NOTREACHED */
    return 0;   /* Silence compiler warning */
d12693 9
a12701 22
    U8 curchar;                     /* Current character being parsed */
    UV start, end;	            /* End points of code point ranges */
    SV* final = NULL;               /* The end result inversion list */
    SV* result_string;              /* 'final' stringified */
    AV* stack;                      /* stack of operators and operands not yet
                                       resolved */
    AV* fence_stack = NULL;         /* A stack containing the positions in
                                       'stack' of where the undealt-with left
                                       parens would be if they were actually
                                       put there */
    /* The 'VOL' (expanding to 'volatile') is a workaround for an optimiser bug
     * in Solaris Studio 12.3. See RT #127455 */
    VOL IV fence = 0;               /* Position of where most recent undealt-
                                       with left paren in stack is; -1 if none.
                                     */
    STRLEN len;                     /* Temporary */
    regnode* node;                  /* Temporary, and final regnode returned by
                                       this function */
    const bool save_fold = FOLD;    /* Temporary */
    char *save_end, *save_parse;    /* Temporaries */
    const bool in_locale = LOC;     /* we turn off /l during processing */
    AV* posix_warnings = NULL;
d12707 2
a12708 2
    if (in_locale) {
        set_regex_charset(&RExC_flags, REGEX_UNICODE_CHARSET);
d12710 1
a12710 5

    REQUIRE_UNI_RULES(flagp, NULL);   /* The use of this operator implies /u.
                                         This is required so that the compile
                                         time values are valid in all runtime
                                         cases */
d12722 8
d12732 2
a12733 4

            skip_to_be_ignored_text(pRExC_state, &RExC_parse,
                                    TRUE /* Force /x */ );

d12737 1
a12737 1
                    /* FALLTHROUGH */
d12741 6
a12746 2
                    /* Skip past this, so the next character gets skipped, after
                     * the switch */
a12747 4
                    if (*RExC_parse == 'c') {
                            /* Skip the \cX notation for control characters */
                            RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;
                    }
a12748 1

d12751 7
a12757 10
                    /* See if this is a [:posix:] class. */
                    bool is_posix_class = (OOB_NAMEDCLASS
                            < handle_possible_posix(pRExC_state,
                                                RExC_parse + 1,
                                                NULL,
                                                NULL,
                                                TRUE /* checking only */));
                    /* If it is a posix class, leave the parse pointer at the
                     * '[' to fool regclass() into thinking it is part of a
                     * '[[:posix:]]'. */
d12762 2
a12763 2
                    /* regclass() can only return RESTART_PASS1 and NEED_UTF8
                     * if multi-char folds are allowed.  */
d12770 3
a12772 7
                                  TRUE, /* strict */
                                  FALSE, /* Require return to be an ANYOF */
                                  &current,
                                  &posix_warnings
                                 ))
                        FAIL2("panic: regclass returned NULL to handle_sets, "
                              "flags=%#"UVxf"", (UV) *flagp);
d12787 3
a12789 1
                    if (*RExC_parse == ')') {
a12794 4
                        if (in_locale) {
                            set_regex_charset(&RExC_flags, REGEX_LOCALE_CHARSET);
                        }

d12799 1
a12799 9

            RExC_parse += UTF ? UTF8SKIP(RExC_parse) : 1;
        }

      no_close:
        /* We output the messages even if warnings are off, because we'll fail
         * the very next thing, and these give a likely diagnosis for that */
        if (posix_warnings && av_tindex_nomg(posix_warnings) >= 0) {
            output_or_return_posix_warnings(pRExC_state, posix_warnings, NULL);
d12802 1
d12806 19
a12824 27
    /* Pass 2 only after this. */
    Perl_ck_warner_d(aTHX_
        packWARN(WARN_EXPERIMENTAL__REGEX_SETS),
        "The regex_sets feature is experimental" REPORT_LOCATION,
        REPORT_LOCATION_ARGS(RExC_parse));

    /* Everything in this construct is a metacharacter.  Operands begin with
     * either a '\' (for an escape sequence), or a '[' for a bracketed
     * character class.  Any other character should be an operator, or
     * parenthesis for grouping.  Both types of operands are handled by calling
     * regclass() to parse them.  It is called with a parameter to indicate to
     * return the computed inversion list.  The parsing here is implemented via
     * a stack.  Each entry on the stack is a single character representing one
     * of the operators; or else a pointer to an operand inversion list. */

#define IS_OPERATOR(a) SvIOK(a)
#define IS_OPERAND(a)  (! IS_OPERATOR(a))

    /* The stack is kept in Łukasiewicz order.  (That's pronounced similar
     * to luke-a-shave-itch (or -itz), but people who didn't want to bother
     * with pronouncing it called it Reverse Polish instead, but now that YOU
     * know how to pronounce it you can use the correct term, thus giving due
     * credit to the person who invented it, and impressing your geek friends.
     * Wikipedia says that the pronounciation of "Ł" has been changing so that
     * it is now more like an English initial W (as in wonk) than an L.)
     *
     * This means that, for example, 'a | b & c' is stored on the stack as
d12826 2
a12827 27
     * c  [4]
     * b  [3]
     * &  [2]
     * a  [1]
     * |  [0]
     *
     * where the numbers in brackets give the stack [array] element number.
     * In this implementation, parentheses are not stored on the stack.
     * Instead a '(' creates a "fence" so that the part of the stack below the
     * fence is invisible except to the corresponding ')' (this allows us to
     * replace testing for parens, by using instead subtraction of the fence
     * position).  As new operands are processed they are pushed onto the stack
     * (except as noted in the next paragraph).  New operators of higher
     * precedence than the current final one are inserted on the stack before
     * the lhs operand (so that when the rhs is pushed next, everything will be
     * in the correct positions shown above.  When an operator of equal or
     * lower precedence is encountered in parsing, all the stacked operations
     * of equal or higher precedence are evaluated, leaving the result as the
     * top entry on the stack.  This makes higher precedence operations
     * evaluate before lower precedence ones, and causes operations of equal
     * precedence to left associate.
     *
     * The only unary operator '!' is immediately pushed onto the stack when
     * encountered.  When an operand is encountered, if the top of the stack is
     * a '!", the complement is immediately performed, and the '!' popped.  The
     * resulting value is treated as a new operand, and the logic in the
     * previous paragraph is executed.  Thus in the expression
d12829 4
a12832 5
     * the stack looks like
     *
     * !
     * a
     * +
d12834 6
a12839 19
     * as 'b' gets parsed, the latter gets evaluated to '!b', and the stack
     * becomes
     *
     * !b
     * a
     * +
     *
     * A ')' is treated as an operator with lower precedence than all the
     * aforementioned ones, which causes all operations on the stack above the
     * corresponding '(' to be evaluated down to a single resultant operand.
     * Then the fence for the '(' is removed, and the operand goes through the
     * algorithm above, without the fence.
     *
     * A separate stack is kept of the fence positions, so that the position of
     * the latest so-far unbalanced '(' is at the top of it.
     *
     * The ']' ending the construct is treated as the lowest operator of all,
     * so that everything gets evaluated down to a single operand, which is the
     * result */
a12841 1
    sv_2mortal((SV *)(fence_stack = newAV()));
d12844 7
a12850 8
        I32 top_index;              /* Index of top-most element in 'stack' */
        SV** top_ptr;               /* Pointer to top 'stack' element */
        SV* current = NULL;         /* To contain the current inversion list
                                       operand */
        SV* only_to_avoid_leaks;

        skip_to_be_ignored_text(pRExC_state, &RExC_parse,
                                TRUE /* Force /x */ );
d12854 3
a12856 6

        curchar = UCHARAT(RExC_parse);

redo_curchar:

        top_index = av_tindex_nomg(stack);
a12858 6
            SV** stacked_ptr;       /* Ptr to something already on 'stack' */
            char stacked_operator;  /* The topmost operator on the 'stack'. */
            SV* lhs;                /* Operand to the left of the operator */
            SV* rhs;                /* Operand to the right of the operator */
            SV* fence_ptr;          /* Pointer to top element of the fence
                                       stack */
d12860 9
a12868 4
            case '(':

                if (   RExC_parse < RExC_end - 1
                    && (UCHARAT(RExC_parse + 1) == '?'))
d12883 1
a12883 1
                    const char * save_parse;
a12884 4
                    RExC_parse += 2;        /* Skip past the '(?' */
                    save_parse = RExC_parse;

                    /* Parse any flags for the '(?' */
d12888 3
a12890 3
                                                     least one flag (or else
                                                     this embedding wasn't
                                                     compiled) */
a12909 2

                    /* Recurse, with the meat of the embedded expression */
d12916 3
a12918 1
                     * ']'; the next character should be the ')' */
a12919 1
                    assert(UCHARAT(RExC_parse) == ')');
a12920 6
                    /* Then the ')' matching the original '(' handled by this
                     * case: statement */
                    RExC_parse++;
                    assert(UCHARAT(RExC_parse) == ')');

                    RExC_parse++;
d12924 1
d12926 3
a12928 23
                /* A regular '('.  Look behind for illegal syntax */
                if (top_index - fence >= 0) {
                    /* If the top entry on the stack is an operator, it had
                     * better be a '!', otherwise the entry below the top
                     * operand should be an operator */
                    if (   ! (top_ptr = av_fetch(stack, top_index, FALSE))
                        || (IS_OPERATOR(*top_ptr) && SvUV(*top_ptr) != '!')
                        || (   IS_OPERAND(*top_ptr)
                            && (   top_index - fence < 1
                                || ! (stacked_ptr = av_fetch(stack,
                                                             top_index - 1,
                                                             FALSE))
                                || ! IS_OPERATOR(*stacked_ptr))))
                    {
                        RExC_parse++;
                        vFAIL("Unexpected '(' with no preceding operator");
                    }
                }

                /* Stack the position of this undealt-with left paren */
                fence = top_index + 1;
                av_push(fence_stack, newSViv(fence));
                break;
d12931 2
a12932 2
                /* regclass() can only return RESTART_PASS1 and NEED_UTF8 if
                 * multi-char folds are allowed.  */
d12937 3
a12939 9
                              TRUE,  /* strict */
                              FALSE, /* Require return to be an ANYOF */
                              &current,
                              NULL))
                {
                    FAIL2("panic: regclass returned NULL to handle_sets, "
                          "flags=%#"UVxf"", (UV) *flagp);
                }

d12947 2
a12948 10
                /* See if this is a [:posix:] class. */
                bool is_posix_class = (OOB_NAMEDCLASS
                            < handle_possible_posix(pRExC_state,
                                                RExC_parse + 1,
                                                NULL,
                                                NULL,
                                                TRUE /* checking only */));
                /* If it is a posix class, leave the parse pointer at the '['
                 * to fool regclass() into thinking it is part of a
                 * '[[:posix:]]'. */
d12953 10
a12962 18
                /* regclass() can only return RESTART_PASS1 and NEED_UTF8 if
                 * multi-char folds are allowed.  */
                if (!regclass(pRExC_state, flagp,depth+1,
                                is_posix_class, /* parse the whole char
                                                    class only if not a
                                                    posix class */
                                FALSE, /* don't allow multi-char folds */
                                TRUE, /* silence non-portable warnings. */
                                TRUE, /* strict */
                                FALSE, /* Require return to be an ANYOF */
                                &current,
                                NULL
                                ))
                {
                    FAIL2("panic: regclass returned NULL to handle_sets, "
                          "flags=%#"UVxf"", (UV) *flagp);
                }

a12971 42
            case ']':
                if (top_index >= 1) {
                    goto join_operators;
                }

                /* Only a single operand on the stack: are done */
                goto done;

            case ')':
                if (av_tindex_nomg(fence_stack) < 0) {
                    RExC_parse++;
                    vFAIL("Unexpected ')'");
                }

                 /* If at least two thing on the stack, treat this as an
                  * operator */
                if (top_index - fence >= 1) {
                    goto join_operators;
                }

                /* Here only a single thing on the fenced stack, and there is a
                 * fence.  Get rid of it */
                fence_ptr = av_pop(fence_stack);
                assert(fence_ptr);
                fence = SvIV(fence_ptr) - 1;
                SvREFCNT_dec_NN(fence_ptr);
                fence_ptr = NULL;

                if (fence < 0) {
                    fence = 0;
                }

                /* Having gotten rid of the fence, we pop the operand at the
                 * stack top and process it as a newly encountered operand */
                current = av_pop(stack);
                if (IS_OPERAND(current)) {
                    goto handle_operand;
                }

                RExC_parse++;
                goto bad_syntax;

d12977 1
a12977 5

                /* These binary operators should have a left operand already
                 * parsed */
                if (   top_index - fence < 0
                    || top_index - fence == 1
d12981 2
a12982 1
                    goto unexpected_binary;
d12984 2
d12987 3
a12989 3
                /* If only the one operand is on the part of the stack visible
                 * to us, we just place this operator in the proper position */
                if (top_index - fence < 2) {
d12991 8
a12998 6
                    /* Place the operator before the operand */

                    SV* lhs = av_pop(stack);
                    av_push(stack, newSVuv(curchar));
                    av_push(stack, lhs);
                    break;
d13000 2
d13003 9
a13011 11
                /* But if there is something else on the stack, we need to
                 * process it before this new operator if and only if the
                 * stacked operation has equal or higher precedence than the
                 * new one */

             join_operators:

                /* The operator on the stack is supposed to be below both its
                 * operands */
                if (   ! (stacked_ptr = av_fetch(stack, top_index - 2, FALSE))
                    || IS_OPERAND(*stacked_ptr))
d13013 1
a13013 8
                    /* But if not, it's legal and indicates we are completely
                     * done if and only if we're currently processing a ']',
                     * which should be the final thing in the expression */
                    if (curchar == ']') {
                        goto done;
                    }

                  unexpected_binary:
d13015 1
a13015 2
                    vFAIL2("Unexpected binary operator '%c' with no "
                           "preceding operand", curchar);
d13017 2
a13018 1
                stacked_operator = (char) SvUV(*stacked_ptr);
d13020 2
a13021 11
                if (regex_set_precedence(curchar)
                    > regex_set_precedence(stacked_operator))
                {
                    /* Here, the new operator has higher precedence than the
                     * stacked one.  This means we need to add the new one to
                     * the stack to await its rhs operand (and maybe more
                     * stuff).  We put it before the lhs operand, leaving
                     * untouched the stacked operator and everything below it
                     * */
                    lhs = av_pop(stack);
                    assert(IS_OPERAND(lhs));
d13023 1
a13023 4
                    av_push(stack, newSVuv(curchar));
                    av_push(stack, lhs);
                    break;
                }
d13025 1
a13025 3
                /* Here, the new operator has equal or lower precedence than
                 * what's already there.  This means the operation already
                 * there should be performed now, before the new one. */
d13027 2
a13028 6
                rhs = av_pop(stack);
                if (! IS_OPERAND(rhs)) {

                    /* This can happen when a ! is not followed by an operand,
                     * like in /(?[\t &!])/ */
                    goto bad_syntax;
d13030 21
d13052 2
a13053 1
                lhs = av_pop(stack);
d13055 15
a13069 1
                if (! IS_OPERAND(lhs)) {
d13071 6
a13076 4
                    /* This can happen when there is an empty (), like in
                     * /(?[[0]+()+])/ */
                    goto bad_syntax;
                }
d13078 5
a13082 4
                switch (stacked_operator) {
                    case '&':
                        _invlist_intersection(lhs, rhs, &rhs);
                        break;
d13084 19
a13102 4
                    case '|':
                    case '+':
                        _invlist_union(lhs, rhs, &rhs);
                        break;
d13104 2
a13105 99
                    case '-':
                        _invlist_subtract(lhs, rhs, &rhs);
                        break;

                    case '^':   /* The union minus the intersection */
                    {
                        SV* i = NULL;
                        SV* u = NULL;
                        SV* element;

                        _invlist_union(lhs, rhs, &u);
                        _invlist_intersection(lhs, rhs, &i);
                        /* _invlist_subtract will overwrite rhs
                            without freeing what it already contains */
                        element = rhs;
                        _invlist_subtract(u, i, &rhs);
                        SvREFCNT_dec_NN(i);
                        SvREFCNT_dec_NN(u);
                        SvREFCNT_dec_NN(element);
                        break;
                    }
                }
                SvREFCNT_dec(lhs);

                /* Here, the higher precedence operation has been done, and the
                 * result is in 'rhs'.  We overwrite the stacked operator with
                 * the result.  Then we redo this code to either push the new
                 * operator onto the stack or perform any higher precedence
                 * stacked operation */
                only_to_avoid_leaks = av_pop(stack);
                SvREFCNT_dec(only_to_avoid_leaks);
                av_push(stack, rhs);
                goto redo_curchar;

            case '!':   /* Highest priority, right associative */

                /* If what's already at the top of the stack is another '!",
                 * they just cancel each other out */
                if (   (top_ptr = av_fetch(stack, top_index, FALSE))
                    && (IS_OPERATOR(*top_ptr) && SvUV(*top_ptr) == '!'))
                {
                    only_to_avoid_leaks = av_pop(stack);
                    SvREFCNT_dec(only_to_avoid_leaks);
                }
                else { /* Otherwise, since it's right associative, just push
                          onto the stack */
                    av_push(stack, newSVuv(curchar));
                }
                break;

            default:
                RExC_parse += (UTF) ? UTF8SKIP(RExC_parse) : 1;
                vFAIL("Unexpected character");

          handle_operand:

            /* Here 'current' is the operand.  If something is already on the
             * stack, we have to check if it is a !.  But first, the code above
             * may have altered the stack in the time since we earlier set
             * 'top_index'.  */

            top_index = av_tindex_nomg(stack);
            if (top_index - fence >= 0) {
                /* If the top entry on the stack is an operator, it had better
                 * be a '!', otherwise the entry below the top operand should
                 * be an operator */
                top_ptr = av_fetch(stack, top_index, FALSE);
                assert(top_ptr);
                if (IS_OPERATOR(*top_ptr)) {

                    /* The only permissible operator at the top of the stack is
                     * '!', which is applied immediately to this operand. */
                    curchar = (char) SvUV(*top_ptr);
                    if (curchar != '!') {
                        SvREFCNT_dec(current);
                        vFAIL2("Unexpected binary operator '%c' with no "
                                "preceding operand", curchar);
                    }

                    _invlist_invert(current);

                    only_to_avoid_leaks = av_pop(stack);
                    SvREFCNT_dec(only_to_avoid_leaks);

                    /* And we redo with the inverted operand.  This allows
                     * handling multiple ! in a row */
                    goto handle_operand;
                }
                          /* Single operand is ok only for the non-binary ')'
                           * operator */
                else if ((top_index - fence == 0 && curchar != ')')
                         || (top_index - fence > 0
                             && (! (stacked_ptr = av_fetch(stack,
                                                           top_index - 1,
                                                           FALSE))
                                 || IS_OPERAND(*stacked_ptr))))
                {
                    SvREFCNT_dec(current);
                    vFAIL("Operand with no preceding operator");
d13107 2
d13110 1
a13110 6

            /* Here there was nothing on the stack or the top element was
             * another operand.  Just add this new one */
            av_push(stack, current);

        } /* End of switch on next parse token */
a13112 5
    } /* End of loop parsing through the construct */

  done:
    if (av_tindex_nomg(fence_stack) >= 0) {
        vFAIL("Unmatched (");
d13115 1
a13115 1
    if (av_tindex_nomg(stack) < 0   /* Was empty */
d13118 1
a13118 2
        || SvTYPE(final) != SVt_INVLIST
        || av_tindex_nomg(stack) >= 0)  /* More left on stack */
a13119 2
      bad_syntax:
        SvREFCNT_dec(final);
a13143 2
    /* About to generate an ANYOF (or similar) node from the inversion list we
     * have calculated */
d13153 2
a13154 2
    /* regclass() can only return RESTART_PASS1 and NEED_UTF8 if multi-char
     * folds are allowed.  */
d13161 1
a13161 5
                    FALSE, /* similarly, no need for strict */
                    FALSE, /* Require return to be an ANYOF */
                    NULL,
                    NULL
                );
a13164 27

    /* Fix up the node type if we are in locale.  (We have pretended we are
     * under /u for the purposes of regclass(), as this construct will only
     * work under UTF-8 locales.  But now we change the opcode to be ANYOFL (so
     * as to cause any warnings about bad locales to be output in regexec.c),
     * and add the flag that indicates to check if not in a UTF-8 locale.  The
     * reason we above forbid optimization into something other than an ANYOF
     * node is simply to minimize the number of code changes in regexec.c.
     * Otherwise we would have to create new EXACTish node types and deal with
     * them.  This decision could be revisited should this construct become
     * popular.
     *
     * (One might think we could look at the resulting ANYOF node and suppress
     * the flag if everything is above 255, as those would be UTF-8 only,
     * but this isn't true, as the components that led to that result could
     * have been locale-affected, and just happen to cancel each other out
     * under UTF-8 locales.) */
    if (in_locale) {
        set_regex_charset(&RExC_flags, REGEX_LOCALE_CHARSET);

        assert(OP(node) == ANYOF);

        OP(node) = ANYOFL;
        ANYOF_FLAGS(node)
                |= ANYOFL_SHARED_UTF8_LOCALE_fold_HAS_MATCHES_nonfold_REQD;
    }

a13167 1

a13176 1
#undef IS_OPERATOR
a13178 162
STATIC void
S_add_above_Latin1_folds(pTHX_ RExC_state_t *pRExC_state, const U8 cp, SV** invlist)
{
    /* This hard-codes the Latin1/above-Latin1 folding rules, so that an
     * innocent-looking character class, like /[ks]/i won't have to go out to
     * disk to find the possible matches.
     *
     * This should be called only for a Latin1-range code points, cp, which is
     * known to be involved in a simple fold with other code points above
     * Latin1.  It would give false results if /aa has been specified.
     * Multi-char folds are outside the scope of this, and must be handled
     * specially.
     *
     * XXX It would be better to generate these via regen, in case a new
     * version of the Unicode standard adds new mappings, though that is not
     * really likely, and may be caught by the default: case of the switch
     * below. */

    PERL_ARGS_ASSERT_ADD_ABOVE_LATIN1_FOLDS;

    assert(HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(cp));

    switch (cp) {
        case 'k':
        case 'K':
          *invlist =
             add_cp_to_invlist(*invlist, KELVIN_SIGN);
            break;
        case 's':
        case 'S':
          *invlist = add_cp_to_invlist(*invlist, LATIN_SMALL_LETTER_LONG_S);
            break;
        case MICRO_SIGN:
          *invlist = add_cp_to_invlist(*invlist, GREEK_CAPITAL_LETTER_MU);
          *invlist = add_cp_to_invlist(*invlist, GREEK_SMALL_LETTER_MU);
            break;
        case LATIN_CAPITAL_LETTER_A_WITH_RING_ABOVE:
        case LATIN_SMALL_LETTER_A_WITH_RING_ABOVE:
          *invlist = add_cp_to_invlist(*invlist, ANGSTROM_SIGN);
            break;
        case LATIN_SMALL_LETTER_Y_WITH_DIAERESIS:
          *invlist = add_cp_to_invlist(*invlist,
                                        LATIN_CAPITAL_LETTER_Y_WITH_DIAERESIS);
            break;

#ifdef LATIN_CAPITAL_LETTER_SHARP_S /* not defined in early Unicode releases */

        case LATIN_SMALL_LETTER_SHARP_S:
          *invlist = add_cp_to_invlist(*invlist, LATIN_CAPITAL_LETTER_SHARP_S);
            break;

#endif

#if    UNICODE_MAJOR_VERSION < 3                                        \
   || (UNICODE_MAJOR_VERSION == 3 && UNICODE_DOT_VERSION == 0)

        /* In 3.0 and earlier, U+0130 folded simply to 'i'; and in 3.0.1 so did
         * U+0131.  */
        case 'i':
        case 'I':
          *invlist =
             add_cp_to_invlist(*invlist, LATIN_CAPITAL_LETTER_I_WITH_DOT_ABOVE);
#   if UNICODE_DOT_DOT_VERSION == 1
          *invlist = add_cp_to_invlist(*invlist, LATIN_SMALL_LETTER_DOTLESS_I);
#   endif
            break;
#endif

        default:
            /* Use deprecated warning to increase the chances of this being
             * output */
            if (PASS2) {
                ckWARN2reg_d(RExC_parse, "Perl folding rules are not up-to-date for 0x%02X; please use the perlbug utility to report;", cp);
            }
            break;
    }
}

STATIC void
S_output_or_return_posix_warnings(pTHX_ RExC_state_t *pRExC_state, AV* posix_warnings, AV** return_posix_warnings)
{
    /* If the final parameter is NULL, output the elements of the array given
     * by '*posix_warnings' as REGEXP warnings.  Otherwise, the elements are
     * pushed onto it, (creating if necessary) */

    SV * msg;
    const bool first_is_fatal =  ! return_posix_warnings
                                && ckDEAD(packWARN(WARN_REGEXP));

    PERL_ARGS_ASSERT_OUTPUT_OR_RETURN_POSIX_WARNINGS;

    while ((msg = av_shift(posix_warnings)) != &PL_sv_undef) {
        if (return_posix_warnings) {
            if (! *return_posix_warnings) { /* mortalize to not leak if
                                               warnings are fatal */
                *return_posix_warnings = (AV *) sv_2mortal((SV *) newAV());
            }
            av_push(*return_posix_warnings, msg);
        }
        else {
            if (first_is_fatal) {           /* Avoid leaking this */
                av_undef(posix_warnings);   /* This isn't necessary if the
                                               array is mortal, but is a
                                               fail-safe */
                (void) sv_2mortal(msg);
                if (PASS2) {
                    SAVEFREESV(RExC_rx_sv);
                }
            }
            Perl_warner(aTHX_ packWARN(WARN_REGEXP), "%s", SvPVX(msg));
            SvREFCNT_dec_NN(msg);
        }
    }
}

STATIC AV *
S_add_multi_match(pTHX_ AV* multi_char_matches, SV* multi_string, const STRLEN cp_count)
{
    /* This adds the string scalar <multi_string> to the array
     * <multi_char_matches>.  <multi_string> is known to have exactly
     * <cp_count> code points in it.  This is used when constructing a
     * bracketed character class and we find something that needs to match more
     * than a single character.
     *
     * <multi_char_matches> is actually an array of arrays.  Each top-level
     * element is an array that contains all the strings known so far that are
     * the same length.  And that length (in number of code points) is the same
     * as the index of the top-level array.  Hence, the [2] element is an
     * array, each element thereof is a string containing TWO code points;
     * while element [3] is for strings of THREE characters, and so on.  Since
     * this is for multi-char strings there can never be a [0] nor [1] element.
     *
     * When we rewrite the character class below, we will do so such that the
     * longest strings are written first, so that it prefers the longest
     * matching strings first.  This is done even if it turns out that any
     * quantifier is non-greedy, out of this programmer's (khw) laziness.  Tom
     * Christiansen has agreed that this is ok.  This makes the test for the
     * ligature 'ffi' come before the test for 'ff', for example */

    AV* this_array;
    AV** this_array_ptr;

    PERL_ARGS_ASSERT_ADD_MULTI_MATCH;

    if (! multi_char_matches) {
        multi_char_matches = newAV();
    }

    if (av_exists(multi_char_matches, cp_count)) {
        this_array_ptr = (AV**) av_fetch(multi_char_matches, cp_count, FALSE);
        this_array = *this_array_ptr;
    }
    else {
        this_array = newAV();
        av_store(multi_char_matches, cp_count,
                 (SV*) this_array);
    }
    av_push(this_array, multi_string);

    return multi_char_matches;
}

a13184 16
/* There is a restricted set of white space characters that are legal when
 * ignoring white space in a bracketed character class.  This generates the
 * code to skip them.
 *
 * There is a line below that uses the same white space criteria but is outside
 * this macro.  Both here and there must use the same definition */
#define SKIP_BRACKETED_WHITE_SPACE(do_skip, p)                          \
    STMT_START {                                                        \
        if (do_skip) {                                                  \
            while (isBLANK_A(UCHARAT(p)))                               \
            {                                                           \
                p++;                                                    \
            }                                                           \
        }                                                               \
    } STMT_END

d13193 1
a13193 6
                 const bool strict,
                 bool optimizable,                  /* ? Allow a non-ANYOF return
                                                       node */
                 SV** ret_invlist, /* Return an inversion list, not a node */
                 AV** return_posix_warnings
          )
d13210 5
a13214 5
     * ANYOF nodes contain a bit map for the first NUM_ANYOF_CODE_POINTS
     * characters, with the corresponding bit set if that character is in the
     * list.  For characters above this, a range list or swash is used.  There
     * are extra bits for \w, etc. in locale ANYOFs, as what these match is not
     * determinable at compile time
d13216 2
a13217 3
     * Returns NULL, setting *flagp to RESTART_PASS1 if the sizing scan needs
     * to be restarted, or'd with NEED_UTF8 if the pattern needs to be upgraded
     * to UTF-8.  This can only happen if ret_invlist is non-NULL.
d13220 1
d13226 1
a13226 1
    int namedclass = OOB_NAMEDCLASS;
a13242 4
    SV* simple_posixes = NULL; /* But under some conditions, the classes can be
                                  treated more simply than the general case,
                                  leading to less compilation and execution
                                  work */
d13251 1
d13266 2
a13267 3
     * string is in UTF-8.  These are all non-ASCII, < 256.  (Because is under
     * /d) */
    SV* has_upper_latin1_only_utf8_matches = NULL;
d13281 5
a13285 11
    /* In a range, if one of the endpoints is non-character-set portable,
     * meaning that it hard-codes a code point that may mean a different
     * charactger in ASCII vs. EBCDIC, as opposed to, say, a literal 'A' or a
     * mnemonic '\t' which each mean the same character no matter which
     * character set the platform is on. */
    unsigned int non_portable_endpoint = 0;

    /* Is the range unicode? which means on a platform that isn't 1-1 native
     * to Unicode (i.e. non-ASCII), each code point in it should be considered
     * to be a Unicode value.  */
    bool unicode_range = FALSE;
a13294 12

    /* This variable is used to mark where the end in the input is of something
     * that looks like a POSIX construct but isn't.  During the parse, when
     * something looks like it could be such a construct is encountered, it is
     * checked for being one, but not if we've already checked this area of the
     * input.  Only after this position is reached do we check again */
    char *not_posix_region_end = RExC_parse - 1;

    AV* posix_warnings = NULL;
    const bool do_posix_warnings =     return_posix_warnings
                                   || (PASS2 && ckWARN(WARN_REGEXP));

a13303 6
#if UNICODE_MAJOR_VERSION < 3 /* no multifolds in early Unicode */      \
    || (UNICODE_MAJOR_VERSION == 3 && UNICODE_DOT_VERSION == 0          \
                                   && UNICODE_DOT_DOT_VERSION == 0)
    allow_multi_folds = FALSE;
#endif

d13305 1
a13305 5
    ret = reganode(pRExC_state,
                   (LOC)
                    ? ANYOFL
                    : ANYOF,
                   0);
d13320 4
a13323 3
    SKIP_BRACKETED_WHITE_SPACE(skip_white, RExC_parse);

    assert(RExC_parse <= RExC_end);
d13325 1
a13325 1
    if (UCHARAT(RExC_parse) == '^') {	/* Complement the class */
d13329 5
a13333 2
        MARK_NAUGHTY(1);
        SKIP_BRACKETED_WHITE_SPACE(skip_white, RExC_parse);
d13337 13
a13349 19
    if (! ret_invlist && MAYBE_POSIXCC(UCHARAT(RExC_parse))) {
        int maybe_class = handle_possible_posix(pRExC_state,
                                                RExC_parse,
                                                &not_posix_region_end,
                                                NULL,
                                                TRUE /* checking only */);
        if (PASS2 && maybe_class >= OOB_NAMEDCLASS && do_posix_warnings) {
            SAVEFREESV(RExC_rx_sv);
            ckWARN4reg(not_posix_region_end,
                    "POSIX syntax [%c %c] belongs inside character classes%s",
                    *RExC_parse, *RExC_parse,
                    (maybe_class == OOB_NAMEDCLASS)
                    ? ((POSIXCC_NOTYET(*RExC_parse))
                        ? " (but this one isn't implemented)"
                        : " (but this one isn't fully valid)")
                    : ""
                    );
            (void)ReREFCNT_inc(RExC_rx_sv);
        }
d13362 1
a13363 15

        if (   posix_warnings
            && av_tindex_nomg(posix_warnings) >= 0
            && RExC_parse > not_posix_region_end)
        {
            /* Warnings about posix class issues are considered tentative until
             * we are far enough along in the parse that we can no longer
             * change our mind, at which point we either output them or add
             * them, if it has so specified, to what gets returned to the
             * caller.  This is done each time through the loop so that a later
             * class won't zap them before they have been dealt with. */
            output_or_return_posix_warnings(pRExC_state, posix_warnings,
                                            return_posix_warnings);
        }

d13368 4
a13371 1
        SKIP_BRACKETED_WHITE_SPACE(skip_white, RExC_parse);
d13377 1
a13377 1
      charclassloop:
a13385 1
            non_portable_endpoint = 0;
d13387 1
a13387 1
	if (UTF && ! UTF8_IS_INVARIANT(* RExC_parse)) {
d13396 3
a13398 31
        if (value == '[') {
            char * posix_class_end;
            namedclass = handle_possible_posix(pRExC_state,
                                               RExC_parse,
                                               &posix_class_end,
                                               do_posix_warnings ? &posix_warnings : NULL,
                                               FALSE    /* die if error */);
            if (namedclass > OOB_NAMEDCLASS) {

                /* If there was an earlier attempt to parse this particular
                 * posix class, and it failed, it was a false alarm, as this
                 * successful one proves */
                if (   posix_warnings
                    && av_tindex_nomg(posix_warnings) >= 0
                    && not_posix_region_end >= RExC_parse
                    && not_posix_region_end <= posix_class_end)
                {
                    av_undef(posix_warnings);
                }

                RExC_parse = posix_class_end;
            }
            else if (namedclass == OOB_NAMEDCLASS) {
                not_posix_region_end = posix_class_end;
            }
            else {
                namedclass = OOB_NAMEDCLASS;
            }
        }
        else if (   RExC_parse - 1 > not_posix_region_end
                 && MAYBE_POSIXCC(value))
d13400 1
a13400 7
            (void) handle_possible_posix(
                        pRExC_state,
                        RExC_parse - 1,  /* -1 because parse has already been
                                            advanced */
                        &not_posix_region_end,
                        do_posix_warnings ? &posix_warnings : NULL,
                        TRUE /* checking only */);
d13403 1
a13403 7
            /* Is a backslash; get the code point of the char after it */

            if (RExC_parse >= RExC_end) {
                vFAIL("Unmatched [");
            }

	    if (UTF && ! UTF8_IS_INVARIANT(UCHARAT(RExC_parse))) {
d13422 1
a13422 1
            if (! skip_white || ! isBLANK_A(value)) switch ((I32)value) {
d13436 12
a13447 57
                    const char * const backslash_N_beg = RExC_parse - 2;
                    int cp_count;

                    if (! grok_bslash_N(pRExC_state,
                                        NULL,      /* No regnode */
                                        &value,    /* Yes single value */
                                        &cp_count, /* Multiple code pt count */
                                        flagp,
                                        strict,
                                        depth)
                    ) {

                        if (*flagp & NEED_UTF8)
                            FAIL("panic: grok_bslash_N set NEED_UTF8");
                        if (*flagp & RESTART_PASS1)
                            return NULL;

                        if (cp_count < 0) {
                            vFAIL("\\N in a character class must be a named character: \\N{...}");
                        }
                        else if (cp_count == 0) {
                            if (PASS2) {
                                ckWARNreg(RExC_parse,
                                        "Ignoring zero length \\N{} in character class");
                            }
                        }
                        else { /* cp_count > 1 */
                            if (! RExC_in_multi_char_class) {
                                if (invert || range || *RExC_parse == '-') {
                                    if (strict) {
                                        RExC_parse--;
                                        vFAIL("\\N{} in inverted character class or as a range end-point is restricted to one character");
                                    }
                                    else if (PASS2) {
                                        ckWARNreg(RExC_parse, "Using just the first character returned by \\N{} in character class");
                                    }
                                    break; /* <value> contains the first code
                                              point. Drop out of the switch to
                                              process it */
                                }
                                else {
                                    SV * multi_char_N = newSVpvn(backslash_N_beg,
                                                 RExC_parse - backslash_N_beg);
                                    multi_char_matches
                                        = add_multi_match(multi_char_matches,
                                                          multi_char_N,
                                                          cp_count);
                                }
                            }
                        } /* End of cp_count != 1 */

                        /* This element should not be processed further in this
                         * class */
                        element_count--;
                        value = save_value;
                        prevvalue = save_prevvalue;
                        continue;   /* Back to top of loop to get next char */
a13448 3

                    /* Here, is a single code point, and <value> contains it */
                    unicode_range = TRUE;   /* \N{} are Unicode */
d13465 1
a13465 1
		    vFAIL2("Empty \\%c", (U8)value);
d13468 2
a13469 3
		    e = strchr(RExC_parse, '}');
                    if (!e) {
                        RExC_parse++;
d13471 2
a13472 20
                    }

                    RExC_parse++;
                    while (isSPACE(*RExC_parse)) {
                         RExC_parse++;
		    }

		    if (UCHARAT(RExC_parse) == '^') {

                        /* toggle.  (The rhs xor gets the single bit that
                         * differs between P and p; the other xor inverts just
                         * that bit) */
                        value ^= 'P' ^ 'p';

                        RExC_parse++;
                        while (isSPACE(*RExC_parse)) {
                            RExC_parse++;
                        }
                    }

a13474 1

d13476 1
a13476 1
		    while (isSPACE(*(RExC_parse + n - 1)))
d13478 2
a13479 8
		}   /* The \p isn't immediately followed by a '{' */
		else if (! isALPHA(*RExC_parse)) {
                    RExC_parse += (UTF) ? UTF8SKIP(RExC_parse) : 1;
                    vFAIL2("Character following \\%c must be '{' or a "
                           "single-character Unicode property name",
                           (U8) value);
                }
                else {
d13485 1
a13486 3
                    char* base_name;    /* name after any packages are stripped */
                    char* lookup_name = NULL;
                    const char * const colon_colon = "::";
d13488 13
d13506 8
a13513 9
                    name = savepv(Perl_form(aTHX_ "%.*s", (int)n, RExC_parse));
                    SAVEFREEPV(name);
                    if (FOLD) {
                        lookup_name = savepv(Perl_form(aTHX_ "__%s_i", name));

                        /* The function call just below that uses this can fail
                         * to return, leaking memory if we don't do this */
                        SAVEFREEPV(lookup_name);
                    }
d13517 4
a13520 6
                    SvREFCNT_dec(swash); /* Free any left-overs */
                    swash = _core_swash_init("utf8",
                                             (lookup_name)
                                              ? lookup_name
                                              : name,
                                             &PL_sv_undef,
d13527 1
a13527 9
                        HV* curpkg = (IN_PERL_COMPILETIME)
                                      ? PL_curstash
                                      : CopSTASH(PL_curcop);
                        UV final_n = n;
                        bool has_pkg;

                        if (swash) {    /* Got a swash but no inversion list.
                                           Something is likely wrong that will
                                           be sorted-out later */
d13532 5
a13536 30
                        /* Here didn't find it.  It could be a an error (like a
                         * typo) in specifying a Unicode property, or it could
                         * be a user-defined property that will be available at
                         * run-time.  The names of these must begin with 'In'
                         * or 'Is' (after any packages are stripped off).  So
                         * if not one of those, or if we accept only
                         * compile-time properties, is an error; otherwise add
                         * it to the list for run-time look up. */
                        if ((base_name = rninstr(name, name + n,
                                                 colon_colon, colon_colon + 2)))
                        { /* Has ::.  We know this must be a user-defined
                             property */
                            base_name += 2;
                            final_n -= base_name - name;
                            has_pkg = TRUE;
                        }
                        else {
                            base_name = name;
                            has_pkg = FALSE;
                        }

                        if (   final_n < 3
                            || base_name[0] != 'I'
                            || (base_name[1] != 's' && base_name[1] != 'n')
                            || ret_invlist)
                        {
                            const char * const msg
                                = (has_pkg)
                                  ? "Illegal user-defined property name"
                                  : "Can't find Unicode property definition";
d13538 3
a13540 4

                            /* diag_listed_as: Can't find Unicode property definition "%s" */
                            vFAIL3utf8f("%s \"%"UTF8f"\"",
                                msg, UTF8fARG(UTF, n, name));
d13542 1
a13542 17

                        /* If the property name doesn't already have a package
                         * name, add the current one to it so that it can be
                         * referred to outside it. [perl #121777] */
                        if (! has_pkg && curpkg) {
                            char* pkgname = HvNAME(curpkg);
                            if (strNE(pkgname, "main")) {
                                char* full_name = Perl_form(aTHX_
                                                            "%s::%s",
                                                            pkgname,
                                                            name);
                                n = strlen(full_name);
                                name = savepvn(full_name, n);
                                SAVEFREEPV(name);
                            }
                        }
                        Perl_sv_catpvf(aTHX_ listsv, "%cutf8::%s%"UTF8f"%s\n",
d13544 1
a13544 3
                                        (FOLD) ? "__" : "",
                                        UTF8fARG(UTF, n, name),
                                        (FOLD) ? "_i" : "");
a13545 2
                        optimizable = FALSE;    /* Will have to leave this an
                                                   ANYOF node */
d13547 8
a13554 3
                        /* We don't know yet what this matches, so have to flag
                         * it */
                        ANYOF_FLAGS(ret) |= ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP;
d13595 1
d13602 1
a13602 1
		REQUIRE_UNI_RULES(flagp, NULL);
d13610 1
a13610 1
	    case 'e':	value = ESC_NATIVE;             break;
d13619 2
a13620 2
                                               PASS2,   /* warnings only in
                                                           pass 2 */
d13628 1
a13628 2
                non_portable_endpoint++;
		if (IN_ENCODING && value < 0x100) {
d13639 1
a13639 1
					       PASS2, /* Output warnings */
d13647 1
a13647 2
                non_portable_endpoint++;
		if (IN_ENCODING && value < 0x100)
d13651 1
a13651 2
		value = grok_bslash_c(*RExC_parse++, PASS2);
                non_portable_endpoint++;
d13679 1
a13679 2
                    non_portable_endpoint++;
		    if (IN_ENCODING && value < 0x100)
d13683 1
a13683 1
	      recode_encoding:
d13685 2
a13686 2
		    SV* enc = _get_encoding();
		    value = reg_recode((U8)value, &enc);
d13691 1
a13691 1
                        else if (PASS2) {
d13716 4
d13777 1
a13777 1
                    ANYOF_FLAGS(ret) |= ANYOF_MATCHES_POSIXL;
a13778 6

                    /* We can't change this into some other type of node
                     * (unless this is the only element, in which case there
                     * are nodes that mean exactly this) as has runtime
                     * dependencies */
                    optimizable = FALSE;
a13780 5
                /* Coverity thinks it is possible for this to be negative; both
                 * jhi and khw think it's not, but be safer */
                assert(! (ANYOF_FLAGS(ret) & ANYOF_MATCHES_POSIXL)
                       || (namedclass + ((namedclass % 2) ? -1 : 1)) >= 0);

d13783 1
a13783 1
                if ((ANYOF_FLAGS(ret) & ANYOF_MATCHES_POSIXL)
d13856 1
a13856 20
                else if (UNI_SEMANTICS
                        || classnum == _CC_ASCII
                        || (DEPENDS_SEMANTICS && (classnum == _CC_DIGIT
                                                  || classnum == _CC_XDIGIT)))
                {
                    /* We usually have to worry about /d and /a affecting what
                     * POSIX classes match, with special code needed for /d
                     * because we won't know until runtime what all matches.
                     * But there is no extra work needed under /u, and
                     * [:ascii:] is unaffected by /a and /d; and :digit: and
                     * :xdigit: don't have runtime differences under /d.  So we
                     * can special case these, and avoid some extra work below,
                     * and at runtime. */
                    _invlist_union_maybe_complement_2nd(
                                                     simple_posixes,
                                                     PL_XPosix_ptrs[classnum],
                                                     namedclass % 2 != 0,
                                                     &simple_posixes);
                }
                else {  /* Garden variety class.  If is NUPPER, NALPHA, ...
d13861 1
d13864 1
a13864 1
                                                     PL_XPosix_ptrs[classnum],
d13868 1
d13872 11
a13882 10
        SKIP_BRACKETED_WHITE_SPACE(skip_white, RExC_parse);

        /* If 'range' is set, 'value' is the ending of a range--check its
         * validity.  (If value isn't a single code point in the case of a
         * range, we should have figured that out above in the code that
         * catches false ranges).  Later, we will handle each individual code
         * point in the range.  If 'range' isn't set, this could be the
         * beginning of a range, so check for that by looking ahead to see if
         * the next real character to be processed is the range indicator--the
         * minus sign */
a13884 11
#ifdef EBCDIC
            /* For unicode ranges, we have to test that the Unicode as opposed
             * to the native values are not decreasing.  (Above 255, there is
             * no difference between native and Unicode) */
	    if (unicode_range && prevvalue < 255 && value < 255) {
                if (NATIVE_TO_LATIN1(prevvalue) > NATIVE_TO_LATIN1(value)) {
                    goto backwards_range;
                }
            }
            else
#endif
d13886 1
a13886 5
		int w;
#ifdef EBCDIC
              backwards_range:
#endif
                w = RExC_parse - rangebegin;
d13890 1
a13890 1
                NOT_REACHED; /* NOTREACHED */
d13899 6
a13904 3

                /* Get the next real char after the '-' */
                SKIP_BRACKETED_WHITE_SPACE(skip_white, next_char_ptr);
d13913 4
a13916 4
                        if (strict || (PASS2 && ckWARN(WARN_REGEXP))) {
                            const int w = RExC_parse >= rangebegin
                                          ?  RExC_parse - rangebegin
                                          : 0;
d13921 1
a13921 1
                            else if (PASS2) {
d13938 2
a13939 7
        if (namedclass > OOB_NAMEDCLASS) {
            continue;
        }

        /* Here, we have a single value this time through the loop, and
         * <prevvalue> is the beginning of the range, if any; or <value> if
         * not. */
d13944 1
a13944 1
            REQUIRE_UNI_RULES(flagp, NULL);
d13987 2
d13991 1
a13991 1
                        SV* multi_fold = sv_2mortal(newSVpvs(""));
a13994 4
                        multi_char_matches
                                        = add_multi_match(multi_char_matches,
                                                          multi_fold,
                                                          cp_count);
d13996 29
a14036 100
        if (strict && PASS2 && ckWARN(WARN_REGEXP)) {
            if (range) {

                /* If the range starts above 255, everything is portable and
                 * likely to be so for any forseeable character set, so don't
                 * warn. */
                if (unicode_range && non_portable_endpoint && prevvalue < 256) {
                    vWARN(RExC_parse, "Both or neither range ends should be Unicode");
                }
                else if (prevvalue != value) {

                    /* Under strict, ranges that stop and/or end in an ASCII
                     * printable should have each end point be a portable value
                     * for it (preferably like 'A', but we don't warn if it is
                     * a (portable) Unicode name or code point), and the range
                     * must be be all digits or all letters of the same case.
                     * Otherwise, the range is non-portable and unclear as to
                     * what it contains */
                    if ((isPRINT_A(prevvalue) || isPRINT_A(value))
                        && (non_portable_endpoint
                            || ! ((isDIGIT_A(prevvalue) && isDIGIT_A(value))
                                   || (isLOWER_A(prevvalue) && isLOWER_A(value))
                                   || (isUPPER_A(prevvalue) && isUPPER_A(value)))))
                    {
                        vWARN(RExC_parse, "Ranges of ASCII printables should be some subset of \"0-9\", \"A-Z\", or \"a-z\"");
                    }
                    else if (prevvalue >= 0x660) { /* ARABIC_INDIC_DIGIT_ZERO */

                        /* But the nature of Unicode and languages mean we
                         * can't do the same checks for above-ASCII ranges,
                         * except in the case of digit ones.  These should
                         * contain only digits from the same group of 10.  The
                         * ASCII case is handled just above.  0x660 is the
                         * first digit character beyond ASCII.  Hence here, the
                         * range could be a range of digits.  Find out.  */
                        IV index_start = _invlist_search(PL_XPosix_ptrs[_CC_DIGIT],
                                                         prevvalue);
                        IV index_final = _invlist_search(PL_XPosix_ptrs[_CC_DIGIT],
                                                         value);

                        /* If the range start and final points are in the same
                         * inversion list element, it means that either both
                         * are not digits, or both are digits in a consecutive
                         * sequence of digits.  (So far, Unicode has kept all
                         * such sequences as distinct groups of 10, but assert
                         * to make sure).  If the end points are not in the
                         * same element, neither should be a digit. */
                        if (index_start == index_final) {
                            assert(! ELEMENT_RANGE_MATCHES_INVLIST(index_start)
                            || (invlist_array(PL_XPosix_ptrs[_CC_DIGIT])[index_start+1]
                               - invlist_array(PL_XPosix_ptrs[_CC_DIGIT])[index_start]
                               == 10)
                               /* But actually Unicode did have one group of 11
                                * 'digits' in 5.2, so in case we are operating
                                * on that version, let that pass */
                            || (invlist_array(PL_XPosix_ptrs[_CC_DIGIT])[index_start+1]
                               - invlist_array(PL_XPosix_ptrs[_CC_DIGIT])[index_start]
                                == 11
                               && invlist_array(PL_XPosix_ptrs[_CC_DIGIT])[index_start]
                                == 0x19D0)
                            );
                        }
                        else if ((index_start >= 0
                                  && ELEMENT_RANGE_MATCHES_INVLIST(index_start))
                                 || (index_final >= 0
                                     && ELEMENT_RANGE_MATCHES_INVLIST(index_final)))
                        {
                            vWARN(RExC_parse, "Ranges of digits should be from the same group of 10");
                        }
                    }
                }
            }
            if ((! range || prevvalue == value) && non_portable_endpoint) {
                if (isPRINT_A(value)) {
                    char literal[3];
                    unsigned d = 0;
                    if (isBACKSLASHED_PUNCT(value)) {
                        literal[d++] = '\\';
                    }
                    literal[d++] = (char) value;
                    literal[d++] = '\0';

                    vWARN4(RExC_parse,
                           "\"%.*s\" is more clearly written simply as \"%s\"",
                           (int) (RExC_parse - rangebegin),
                           rangebegin,
                           literal
                        );
                }
                else if isMNEMONIC_CNTRL(value) {
                    vWARN4(RExC_parse,
                           "\"%.*s\" is more clearly written simply as \"%s\"",
                           (int) (RExC_parse - rangebegin),
                           rangebegin,
                           cntrl_to_mnemonic((U8) value)
                        );
                }
            }
        }

a14038 1

d14043 14
a14056 10
            /* On non-ASCII platforms, for ranges that span all of 0..255, and
             * ones that don't require special handling, we can just add the
             * range like we do for ASCII platforms */
            if ((UNLIKELY(prevvalue == 0) && value >= 255)
                || ! (prevvalue < 256
                      && (unicode_range
                          || (! non_portable_endpoint
                              && ((isLOWER_A(prevvalue) && isLOWER_A(value))
                                  || (isUPPER_A(prevvalue)
                                      && isUPPER_A(value)))))))
d14058 7
a14064 22
                cp_foldable_list = _add_range_to_invlist(cp_foldable_list,
                                                         prevvalue, value);
            }
            else {
                /* Here, requires special handling.  This can be because it is
                 * a range whose code points are considered to be Unicode, and
                 * so must be individually translated into native, or because
                 * its a subrange of 'A-Z' or 'a-z' which each aren't
                 * contiguous in EBCDIC, but we have defined them to include
                 * only the "expected" upper or lower case ASCII alphabetics.
                 * Subranges above 255 are the same in native and Unicode, so
                 * can be added as a range */
                U8 start = NATIVE_TO_LATIN1(prevvalue);
                unsigned j;
                U8 end = (value < 256) ? NATIVE_TO_LATIN1(value) : 255;
                for (j = start; j <= end; j++) {
                    cp_foldable_list = add_cp_to_invlist(cp_foldable_list, LATIN1_TO_NATIVE(j));
                }
                if (value > 255) {
                    cp_foldable_list = _add_range_to_invlist(cp_foldable_list,
                                                             256, value);
                }
d14066 2
a14073 6

    if (   posix_warnings && av_tindex_nomg(posix_warnings) >= 0) {
        output_or_return_posix_warnings(pRExC_state, posix_warnings,
                                        return_posix_warnings);
    }

a14082 4
	char *save_start = RExC_start;
        STRLEN prefix_end = 0;      /* We copy the character class after a
                                       prefix supplied here.  This is the size
                                       + 1 of that prefix */
a14087 2
        assert(RExC_precomp_adj == 0); /* Only one level of recursion allowed */

d14096 1
a14096 4
        for (cp_count = av_tindex_nomg(multi_char_matches);
                        cp_count > 0;
                        cp_count--)
        {
a14120 1
            prefix_end = SvCUR(substitute_parse);
d14122 1
a14122 6

            /* Put in a closing ']' only if not going off the end, as otherwise
             * we are adding something that really isn't there */
            if (RExC_parse < RExC_end) {
                sv_catpv(substitute_parse, "]");
            }
d14135 1
a14135 6
        /* Set up the data structure so that any errors will be properly
         * reported.  See the comments at the definition of
         * REPORT_LOCATION_ARGS for details */
        RExC_precomp_adj = orig_parse - RExC_precomp;
	RExC_start =  RExC_parse = SvPV(substitute_parse, len);
        RExC_adjusted_start = RExC_start + prefix_end;
a14137 1
	RExC_override_recoding = 1;
d14142 1
a14142 1
	*flagp |= reg_flags&(HASWIDTH|SIMPLE|SPSTART|POSTPONED|RESTART_PASS1|NEED_UTF8);
d14144 1
a14144 4
        /* And restore so can parse the rest of the pattern */
        RExC_parse = save_parse;
	RExC_start = RExC_adjusted_start = save_start;
        RExC_precomp_adj = 0;
a14146 1
	RExC_override_recoding = 0;
d14161 2
a14162 3
    if (   optimizable
        && ! ret_invlist   /* Can't optimize if returning the constructed
                              inversion list */
d14171 3
a14173 3
        else if (namedclass > OOB_NAMEDCLASS) { /* this is a single named
                                                   class, like \w or [:digit:]
                                                   or \p{foo} */
d14195 1
a14195 1
                 * ASCII or, if available on this platform, also locale */
d14205 1
a14205 15
                /* The following don't have any matches in the upper Latin1
                 * range, hence /d is equivalent to /u for them.  Making it /u
                 * saves some branches at runtime */
                case ANYOF_DIGIT:
                case ANYOF_NDIGIT:
                case ANYOF_XDIGIT:
                case ANYOF_NXDIGIT:
                    if (! DEPENDS_SEMANTICS) {
                        goto treat_as_default;
                    }

                    op = POSIXU;
                    goto join_posix;

                /* The following change to CASED under /i */
d14210 1
d14212 6
a14217 1
                        namedclass = ANYOF_CASED + (namedclass % 2);
a14224 1
                  treat_as_default:
d14230 1
a14230 1
                  join_posix:
d14249 1
a14249 1
                    MARK_NAUGHTY(1);
a14265 24
            else if (! FOLD || ASCII_FOLD_RESTRICTED) {
                /* We can optimize A-Z or a-z, but not if they could match
                 * something like the KELVIN SIGN under /i. */
                if (prevvalue == 'A') {
                    if (value == 'Z'
#ifdef EBCDIC
                        && ! non_portable_endpoint
#endif
                    ) {
                        arg = (FOLD) ? _CC_ALPHA : _CC_UPPER;
                        op = POSIXA;
                    }
                }
                else if (prevvalue == 'a') {
                    if (value == 'z'
#ifdef EBCDIC
                        && ! non_portable_endpoint
#endif
                    ) {
                        arg = (FOLD) ? _CC_ALPHA : _CC_LOWER;
                        op = POSIXA;
                    }
                }
            }
a14316 1
            SvREFCNT_dec(simple_posixes);
d14339 1
a14339 1
             * non-locale, we just use the general list */
d14361 12
a14372 1
                    _load_PL_utf8_foldclosures();
d14389 9
d14408 3
a14410 4
                                has_upper_latin1_only_utf8_matches
                                    = add_cp_to_invlist(
                                            has_upper_latin1_only_utf8_matches,
                                            PL_fold_latin1[j]);
d14414 1
a14414 1
                        if (HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(j)
d14417 63
a14479 3
                            add_above_Latin1_folds(pRExC_state,
                                                   (U8) j,
                                                   use_list);
d14505 1
a14505 1
                        for (k = 0; k <= av_tindex_nomg(list); k++) {
d14508 3
a14510 2
                            assert(c_p);

d14535 2
a14536 4
                                has_upper_latin1_only_utf8_matches
                                        = add_cp_to_invlist(
                                           has_upper_latin1_only_utf8_matches,
                                           c);
a14554 4
    if (simple_posixes) {
        _invlist_union(cp_list, simple_posixes, &cp_list);
        SvREFCNT_dec_NN(simple_posixes);
    }
d14566 1
a14566 1
                ANYOF_FLAGS(ret) |= ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER;
d14608 3
a14610 4
            if (has_upper_latin1_only_utf8_matches) {
                _invlist_union(has_upper_latin1_only_utf8_matches,
                               nonascii_but_latin1_properties,
                               &has_upper_latin1_only_utf8_matches);
d14614 1
a14614 2
                has_upper_latin1_only_utf8_matches
                                            = nonascii_but_latin1_properties;
d14628 2
a14629 2
     * <has_upper_latin1_only_utf8_matches>, because having a Unicode property
     * forces Unicode semantics */
d14636 1
a14636 1
             * such code point is specified, as, though not strictly correct if
d14653 1
a14653 6
            ANYOF_FLAGS(ret)
             |= ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER;

            /* Because an ANYOF node is the only one that warns, this node
             * can't be optimized into something else */
            optimizable = FALSE;
a14671 13

        /* Some things on the list might be unconditionally included because of
         * other components.  Remove them, and clean up the list if it goes to
         * 0 elements */
        if (only_utf8_locale_list && cp_list) {
            _invlist_subtract(only_utf8_locale_list, cp_list,
                              &only_utf8_locale_list);

            if (_invlist_len(only_utf8_locale_list) == 0) {
                SvREFCNT_dec_NN(only_utf8_locale_list);
                only_utf8_locale_list = NULL;
            }
        }
d14673 1
a14673 3
            ANYOF_FLAGS(ret)
                 |=  ANYOFL_FOLD
                    |ANYOFL_SHARED_UTF8_LOCALE_fold_HAS_MATCHES_nonfold_REQD;
d14675 2
a14676 1
        else if (cp_list) { /* Look to see if a 0-255 code point is in list */
d14680 1
a14680 1
                ANYOF_FLAGS(ret) |= ANYOFL_FOLD;
a14685 73
#define MATCHES_ALL_NON_UTF8_NON_ASCII(ret)                                 \
    (   DEPENDS_SEMANTICS                                                   \
     && (ANYOF_FLAGS(ret)                                                   \
        & ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER))

    /* See if we can simplify things under /d */
    if (   has_upper_latin1_only_utf8_matches
        || MATCHES_ALL_NON_UTF8_NON_ASCII(ret))
    {
        /* But not if we are inverting, as that screws it up */
        if (! invert) {
            if (has_upper_latin1_only_utf8_matches) {
                if (MATCHES_ALL_NON_UTF8_NON_ASCII(ret)) {

                    /* Here, we have both the flag and inversion list.  Any
                     * character in 'has_upper_latin1_only_utf8_matches'
                     * matches when UTF-8 is in effect, but it also matches
                     * when UTF-8 is not in effect because of
                     * MATCHES_ALL_NON_UTF8_NON_ASCII.  Therefore it matches
                     * unconditionally, so can be added to the regular list,
                     * and 'has_upper_latin1_only_utf8_matches' cleared */
                    _invlist_union(cp_list,
                                   has_upper_latin1_only_utf8_matches,
                                   &cp_list);
                    SvREFCNT_dec_NN(has_upper_latin1_only_utf8_matches);
                    has_upper_latin1_only_utf8_matches = NULL;
                }
                else if (cp_list) {

                    /* Here, 'cp_list' gives chars that always match, and
                     * 'has_upper_latin1_only_utf8_matches' gives chars that
                     * were specified to match only if the target string is in
                     * UTF-8.  It may be that these overlap, so we can subtract
                     * the unconditionally matching from the conditional ones,
                     * to make the conditional list as small as possible,
                     * perhaps even clearing it, in which case more
                     * optimizations are possible later */
                    _invlist_subtract(has_upper_latin1_only_utf8_matches,
                                      cp_list,
                                      &has_upper_latin1_only_utf8_matches);
                    if (_invlist_len(has_upper_latin1_only_utf8_matches) == 0) {
                        SvREFCNT_dec_NN(has_upper_latin1_only_utf8_matches);
                        has_upper_latin1_only_utf8_matches = NULL;
                    }
                }
            }

            /* Similarly, if the unconditional matches include every upper
             * latin1 character, we can clear that flag to permit later
             * optimizations */
            if (cp_list && MATCHES_ALL_NON_UTF8_NON_ASCII(ret)) {
                SV* only_non_utf8_list = invlist_clone(PL_UpperLatin1);
                _invlist_subtract(only_non_utf8_list, cp_list,
                                  &only_non_utf8_list);
                if (_invlist_len(only_non_utf8_list) == 0) {
                    ANYOF_FLAGS(ret) &= ~ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER;
                }
                SvREFCNT_dec_NN(only_non_utf8_list);
                only_non_utf8_list = NULL;;
            }
        }

        /* If we haven't gotten rid of all conditional matching, we change the
         * regnode type to indicate that */
        if (   has_upper_latin1_only_utf8_matches
            || MATCHES_ALL_NON_UTF8_NON_ASCII(ret))
        {
            OP(ret) = ANYOFD;
            optimizable = FALSE;
        }
    }
#undef MATCHES_ALL_NON_UTF8_NON_ASCII

a14691 1
        && OP(ret) != ANYOFD
d14693 1
a14708 2
        assert(cp_list);

d14733 9
a14741 8
     * earlier code.  Another possible "optimization" that isn't done is that
     * something like [Ee] could be changed into an EXACTFU.  khw tried this
     * and found that the ANYOF is faster, including for code points not in the
     * bitmap.  This still might make sense to do, provided it got joined with
     * an adjacent node(s) to create a longer EXACTFU one.  This could be
     * accomplished by creating a pseudo ANYOF_EXACTFU node type that the join
     * routine would know is joinable.  If that didn't happen, the node type
     * could then be made a straight ANYOF */
d14743 5
a14747 1
    if (optimizable && cp_list && ! invert) {
a14749 1
        int posix_class = -1;   /* Illegal value */
d14756 3
a14758 3
             * Unicode property that doesn't match anything is the only element
             * in the character class (perluniprops.pod notes such properties).
             * */
d14775 1
a14775 3
                    op = (LOC)
                         ? EXACTL
                         : EXACT;
d14812 1
a14812 1
        }   /* End of first range contains just a single code point */
d14817 1
a14817 1
                MARK_NAUGHTY(1);
d14825 1
a14825 1
                MARK_NAUGHTY(1);
a14829 43
        if (op == END) {
            const UV cp_list_len = _invlist_len(cp_list);
            const UV* cp_list_array = invlist_array(cp_list);

            /* Here, didn't find an optimization.  See if this matches any of
             * the POSIX classes.  These run slightly faster for above-Unicode
             * code points, so don't bother with POSIXA ones nor the 2 that
             * have no above-Unicode matches.  We can avoid these checks unless
             * the ANYOF matches at least as high as the lowest POSIX one
             * (which was manually found to be \v.  The actual code point may
             * increase in later Unicode releases, if a higher code point is
             * assigned to be \v, but this code will never break.  It would
             * just mean we could execute the checks for posix optimizations
             * unnecessarily) */

            if (cp_list_array[cp_list_len-1] > 0x2029) {
                for (posix_class = 0;
                     posix_class <= _HIGHEST_REGCOMP_DOT_H_SYNC;
                     posix_class++)
                {
                    int try_inverted;
                    if (posix_class == _CC_ASCII || posix_class == _CC_CNTRL) {
                        continue;
                    }
                    for (try_inverted = 0; try_inverted < 2; try_inverted++) {

                        /* Check if matches normal or inverted */
                        if (_invlistEQ(cp_list,
                                       PL_XPosix_ptrs[posix_class],
                                       try_inverted))
                        {
                            op = (try_inverted)
                                 ? NPOSIXU
                                 : POSIXU;
                            *flagp |= HASWIDTH|SIMPLE;
                            goto found_posix;
                        }
                    }
                }
              found_posix: ;
            }
        }

d14834 1
a14834 5
            if (regarglen[op]) {
                ret = reganode(pRExC_state, op, 0);
            } else {
                ret = reg_node(pRExC_state, op);
            }
a14842 3
            else if (PL_regkind[op] == POSIXD || PL_regkind[op] == NPOSIXD) {
                FLAGS(ret) = posix_class;
            }
d14863 2
a14864 3
     * when the target string is UTF-8 (<has_upper_latin1_only_utf8_matches>).
     * */
    if (has_upper_latin1_only_utf8_matches) {
d14866 2
a14867 4
	    _invlist_union(cp_list,
                           has_upper_latin1_only_utf8_matches,
                           &cp_list);
	    SvREFCNT_dec_NN(has_upper_latin1_only_utf8_matches);
d14870 1
a14870 1
	    cp_list = has_upper_latin1_only_utf8_matches;
d14872 1
a14872 1
        ANYOF_FLAGS(ret) |= ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP;
a14881 4
    /* Note that the optimization of using 'swash' if it is the only thing in
     * the class doesn't have us change swash at all, so it can include things
     * that are also in the bitmap; otherwise we have purposely deleted that
     * duplicate information */
d14910 1
a14910 1
     * arg is set to ANYOF_ONLY_HAS_BITMAP.  Otherwise, it sets the argument to
d14936 2
a14937 2
                & ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP));
	ARG_SET(node, ANYOF_ONLY_HAS_BITMAP);
d14943 3
a14948 1
	    assert(cp_list);
a14973 39
#if !defined(PERL_IN_XSUB_RE) || defined(PLUGGABLE_RE_EXTENSION)
SV *
Perl__get_regclass_nonbitmap_data(pTHX_ const regexp *prog,
                                        const regnode* node,
                                        bool doinit,
                                        SV** listsvp,
                                        SV** only_utf8_locale_ptr,
                                        SV** output_invlist)

{
    /* For internal core use only.
     * Returns the swash for the input 'node' in the regex 'prog'.
     * If <doinit> is 'true', will attempt to create the swash if not already
     *	  done.
     * If <listsvp> is non-null, will return the printable contents of the
     *    swash.  This can be used to get debugging information even before the
     *    swash exists, by calling this function with 'doinit' set to false, in
     *    which case the components that will be used to eventually create the
     *    swash are returned  (in a printable form).
     * If <only_utf8_locale_ptr> is not NULL, it is where this routine is to
     *    store an inversion list of code points that should match only if the
     *    execution-time locale is a UTF-8 one.
     * If <output_invlist> is not NULL, it is where this routine is to store an
     *    inversion list of the code points that would be instead returned in
     *    <listsvp> if this were NULL.  Thus, what gets output in <listsvp>
     *    when this parameter is used, is just the non-code point data that
     *    will go into creating the swash.  This currently should be just
     *    user-defined properties whose definitions were not known at compile
     *    time.  Using this parameter allows for easier manipulation of the
     *    swash's data by the caller.  It is illegal to call this function with
     *    this parameter set, but not <listsvp>
     *
     * Tied intimately to how S_set_ANYOF_arg sets up the data structure.  Note
     * that, in spite of this function's name, the swash it returns may include
     * the bitmap data as well */

    SV *sw  = NULL;
    SV *si  = NULL;         /* Input swash initialization string */
    SV* invlist = NULL;
d14975 1
a14975 2
    RXi_GET_DECL(prog,progi);
    const struct reg_data * const data = prog ? progi->data : NULL;
d14977 4
a14980 2
    PERL_ARGS_ASSERT__GET_REGCLASS_NONBITMAP_DATA;
    assert(! output_invlist || listsvp);
d14982 2
a14983 2
    if (data && data->count) {
	const U32 n = ARG(node);
d14985 1
a14985 19
	if (data->what[n] == 's') {
	    SV * const rv = MUTABLE_SV(data->data[n]);
	    AV * const av = MUTABLE_AV(SvRV(rv));
	    SV **const ary = AvARRAY(av);
	    U8 swash_init_flags = _CORE_SWASH_INIT_ACCEPT_INVLIST;

	    si = *ary;	/* ary[0] = the string to initialize the swash with */

            if (av_tindex_nomg(av) >= 2) {
                if (only_utf8_locale_ptr
                    && ary[2]
                    && ary[2] != &PL_sv_undef)
                {
                    *only_utf8_locale_ptr = ary[2];
                }
                else {
                    assert(only_utf8_locale_ptr);
                    *only_utf8_locale_ptr = NULL;
                }
d14987 4
a14990 14
                /* Elements 3 and 4 are either both present or both absent. [3]
                 * is any inversion list generated at compile time; [4]
                 * indicates if that inversion list has any user-defined
                 * properties in it. */
                if (av_tindex_nomg(av) >= 3) {
                    invlist = ary[3];
                    if (SvUV(ary[4])) {
                        swash_init_flags |= _CORE_SWASH_INIT_USER_DEFINED_PROPERTY;
                    }
                }
                else {
                    invlist = NULL;
                }
	    }
d14992 1
a14992 19
	    /* Element [1] is reserved for the set-up swash.  If already there,
	     * return it; if not, create it and store it there */
	    if (ary[1] && SvROK(ary[1])) {
		sw = ary[1];
	    }
	    else if (doinit && ((si && si != &PL_sv_undef)
                                 || (invlist && invlist != &PL_sv_undef))) {
		assert(si);
		sw = _core_swash_init("utf8", /* the utf8 package */
				      "", /* nameless */
				      si,
				      1, /* binary */
				      0, /* not from tr/// */
				      invlist,
				      &swash_init_flags);
		(void)av_store(av, 1, sw);
	    }
	}
    }
d14994 4
a14997 128
    /* If requested, return a printable version of what this swash matches */
    if (listsvp) {
	SV* matches_string = NULL;

        /* The swash should be used, if possible, to get the data, as it
         * contains the resolved data.  But this function can be called at
         * compile-time, before everything gets resolved, in which case we
         * return the currently best available information, which is the string
         * that will eventually be used to do that resolving, 'si' */
	if ((! sw || (invlist = _get_swash_invlist(sw)) == NULL)
            && (si && si != &PL_sv_undef))
        {
            /* Here, we only have 'si' (and possibly some passed-in data in
             * 'invlist', which is handled below)  If the caller only wants
             * 'si', use that.  */
            if (! output_invlist) {
                matches_string = newSVsv(si);
            }
            else {
                /* But if the caller wants an inversion list of the node, we
                 * need to parse 'si' and place as much as possible in the
                 * desired output inversion list, making 'matches_string' only
                 * contain the currently unresolvable things */
                const char *si_string = SvPVX(si);
                STRLEN remaining = SvCUR(si);
                UV prev_cp = 0;
                U8 count = 0;

                /* Ignore everything before the first new-line */
                while (*si_string != '\n' && remaining > 0) {
                    si_string++;
                    remaining--;
                }
                assert(remaining > 0);

                si_string++;
                remaining--;

                while (remaining > 0) {

                    /* The data consists of just strings defining user-defined
                     * property names, but in prior incarnations, and perhaps
                     * somehow from pluggable regex engines, it could still
                     * hold hex code point definitions.  Each component of a
                     * range would be separated by a tab, and each range by a
                     * new-line.  If these are found, instead add them to the
                     * inversion list */
                    I32 grok_flags =  PERL_SCAN_SILENT_ILLDIGIT
                                     |PERL_SCAN_SILENT_NON_PORTABLE;
                    STRLEN len = remaining;
                    UV cp = grok_hex(si_string, &len, &grok_flags, NULL);

                    /* If the hex decode routine found something, it should go
                     * up to the next \n */
                    if (   *(si_string + len) == '\n') {
                        if (count) {    /* 2nd code point on line */
                            *output_invlist = _add_range_to_invlist(*output_invlist, prev_cp, cp);
                        }
                        else {
                            *output_invlist = add_cp_to_invlist(*output_invlist, cp);
                        }
                        count = 0;
                        goto prepare_for_next_iteration;
                    }

                    /* If the hex decode was instead for the lower range limit,
                     * save it, and go parse the upper range limit */
                    if (*(si_string + len) == '\t') {
                        assert(count == 0);

                        prev_cp = cp;
                        count = 1;
                      prepare_for_next_iteration:
                        si_string += len + 1;
                        remaining -= len + 1;
                        continue;
                    }

                    /* Here, didn't find a legal hex number.  Just add it from
                     * here to the next \n */

                    remaining -= len;
                    while (*(si_string + len) != '\n' && remaining > 0) {
                        remaining--;
                        len++;
                    }
                    if (*(si_string + len) == '\n') {
                        len++;
                        remaining--;
                    }
                    if (matches_string) {
                        sv_catpvn(matches_string, si_string, len - 1);
                    }
                    else {
                        matches_string = newSVpvn(si_string, len - 1);
                    }
                    si_string += len;
                    sv_catpvs(matches_string, " ");
                } /* end of loop through the text */

                assert(matches_string);
                if (SvCUR(matches_string)) {  /* Get rid of trailing blank */
                    SvCUR_set(matches_string, SvCUR(matches_string) - 1);
                }
            } /* end of has an 'si' but no swash */
	}

        /* If we have a swash in place, its equivalent inversion list was above
         * placed into 'invlist'.  If not, this variable may contain a stored
         * inversion list which is information beyond what is in 'si' */
        if (invlist) {

            /* Again, if the caller doesn't want the output inversion list, put
             * everything in 'matches-string' */
            if (! output_invlist) {
                if ( ! matches_string) {
                    matches_string = newSVpvs("\n");
                }
                sv_catsv(matches_string, invlist_contents(invlist,
                                                  TRUE /* traditional style */
                                                  ));
            }
            else if (! *output_invlist) {
                *output_invlist = invlist_clone(invlist);
            }
            else {
                _invlist_union(*output_invlist, invlist, output_invlist);
            }
d14999 8
d15008 1
a15008 6
	*listsvp = matches_string;
    }

    return sw;
}
#endif /* !defined(PERL_IN_XSUB_RE) || defined(PLUGGABLE_RE_EXTENSION) */
d15010 2
a15011 1
/* reg_skipcomment()
d15013 2
a15014 5
   Absorbs an /x style # comment from the input stream,
   returning a pointer to the first character beyond the comment, or if the
   comment terminates the pattern without anything following it, this returns
   one past the final character of the pattern (in other words, RExC_end) and
   sets the REG_RUN_ON_COMMENT_SEEN flag.
d15016 1
a15016 2
   Note it's the callers responsibility to ensure that we are
   actually in /x mode
d15018 1
d15021 2
a15022 2
PERL_STATIC_INLINE char*
S_reg_skipcomment(RExC_state_t *pRExC_state, char* p)
d15024 1
a15024 1
    PERL_ARGS_ASSERT_REG_SKIPCOMMENT;
d15026 1
a15026 30
    assert(*p == '#');

    while (p < RExC_end) {
        if (*(++p) == '\n') {
            return p+1;
        }
    }

    /* we ran off the end of the pattern without ending the comment, so we have
     * to add an \n when wrapping */
    RExC_seen |= REG_RUN_ON_COMMENT_SEEN;
    return p;
}

STATIC void
S_skip_to_be_ignored_text(pTHX_ RExC_state_t *pRExC_state,
                                char ** p,
                                const bool force_to_xmod
                         )
{
    /* If the text at the current parse position '*p' is a '(?#...)' comment,
     * or if we are under /x or 'force_to_xmod' is TRUE, and the text at '*p'
     * is /x whitespace, advance '*p' so that on exit it points to the first
     * byte past all such white space and comments */

    const bool use_xmod = force_to_xmod || (RExC_flags & RXf_PMf_EXTENDED);

    PERL_ARGS_ASSERT_SKIP_TO_BE_IGNORED_TEXT;

    assert( ! UTF || UTF8_IS_INVARIANT(**p) || UTF8_IS_START(**p));
d15029 4
a15032 4
	if (RExC_end - (*p) >= 3
	    && *(*p)     == '('
	    && *(*p + 1) == '?'
	    && *(*p + 2) == '#')
d15034 2
a15035 2
	    while (*(*p) != ')') {
		if ((*p) == RExC_end)
d15037 1
a15037 1
		(*p)++;
d15039 1
a15039 1
	    (*p)++;
d15042 9
a15050 18

	if (use_xmod) {
            const char * save_p = *p;
            while ((*p) < RExC_end) {
                STRLEN len;
                if ((len = is_PATWS_safe((*p), RExC_end, UTF))) {
                    (*p) += len;
                }
                else if (*(*p) == '#') {
                    (*p) = reg_skipcomment(pRExC_state, (*p));
                }
                else {
                    break;
                }
            }
            if (*p != save_p) {
                continue;
            }
d15052 1
a15052 2

        break;
a15053 2

    return;
d15056 2
a15057 8
/* nextchar()

   Advances the parse position by one byte, unless that byte is the beginning
   of a '(?#...)' style comment, or is /x whitespace and /x is in effect.  In
   those two cases, the parse position is advanced beyond all such comments and
   white space.

   This is the UTF, (?#...), and /x friendly way of saying RExC_parse++.
d15059 2
a15060 3

STATIC void
S_nextchar(pTHX_ RExC_state_t *pRExC_state)
d15062 2
a15063 21
    PERL_ARGS_ASSERT_NEXTCHAR;

    if (RExC_parse < RExC_end) {
        assert(   ! UTF
               || UTF8_IS_INVARIANT(*RExC_parse)
               || UTF8_IS_START(*RExC_parse));

        RExC_parse += (UTF) ? UTF8SKIP(RExC_parse) : 1;

        skip_to_be_ignored_text(pRExC_state, &RExC_parse,
                                FALSE /* Don't assume /x */ );
    }
}

STATIC regnode *
S_regnode_guts(pTHX_ RExC_state_t *pRExC_state, const U8 op, const STRLEN extra_size, const char* const name)
{
    /* Allocate a regnode for 'op' and returns it, with 'extra_size' extra
     * space.  In pass1, it aligns and increments RExC_size; in pass2,
     * RExC_emit */

d15067 1
a15067 3
    PERL_ARGS_ASSERT_REGNODE_GUTS;

    assert(extra_size >= regarglen[op]);
d15071 1
a15071 1
	RExC_size += 1 + extra_size;
d15076 1
a15076 1
		   op, (void*)RExC_emit, (void*)RExC_emit_bound);
d15079 3
a15081 3
#ifndef RE_TRACK_PATTERN_OFFSETS
    PERL_UNUSED_ARG(name);
#else
d15085 1
a15085 1
              name, __LINE__,
d15095 1
d15100 1
a15100 1
- reg_node - emit a node
d15103 1
a15103 1
S_reg_node(pTHX_ RExC_state_t *pRExC_state, U8 op)
d15105 12
a15116 1
    regnode * const ret = regnode_guts(pRExC_state, op, regarglen[op], "reg_node");
d15118 4
a15121 1
    PERL_ARGS_ASSERT_REG_NODE;
d15123 1
a15123 1
    assert(regarglen[op] == 0);
d15125 5
a15129 4
    if (PASS2) {
        regnode *ptr = ret;
        FILL_ADVANCE_NODE(ptr, op);
        RExC_emit = ptr;
d15131 3
a15133 2
    return(ret);
}
d15135 16
a15150 16
/*
- reganode - emit a node with an argument
*/
STATIC regnode *			/* Location. */
S_reganode(pTHX_ RExC_state_t *pRExC_state, U8 op, U32 arg)
{
    regnode * const ret = regnode_guts(pRExC_state, op, regarglen[op], "reganode");

    PERL_ARGS_ASSERT_REGANODE;

    assert(regarglen[op] == 1);

    if (PASS2) {
        regnode *ptr = ret;
        FILL_ADVANCE_NODE_ARG(ptr, op, arg);
        RExC_emit = ptr;
d15152 2
d15157 5
a15161 2
STATIC regnode *
S_reg2Lanode(pTHX_ RExC_state_t *pRExC_state, const U8 op, const U32 arg1, const I32 arg2)
d15163 1
a15163 3
    /* emit a node with U32 and I32 arguments */

    regnode * const ret = regnode_guts(pRExC_state, op, regarglen[op], "reg2Lanode");
d15165 1
a15165 1
    PERL_ARGS_ASSERT_REG2LANODE;
d15167 1
a15167 8
    assert(regarglen[op] == 2);

    if (PASS2) {
        regnode *ptr = ret;
        FILL_ADVANCE_NODE_2L_ARG(ptr, op, arg1, arg2);
        RExC_emit = ptr;
    }
    return(ret);
d15178 1
a15186 1
    PERL_UNUSED_CONTEXT;
a15200 3
        /* remember that RExC_npar is rex->nparens + 1,
         * iow it is 1 more than the number of parens seen in
         * the pattern so far. */
a15215 2
    if (RExC_end_op)
        RExC_end_op += size;
d15264 1
d15266 2
a15267 4
S_regtail(pTHX_ RExC_state_t * pRExC_state,
                const regnode * const p,
                const regnode * const val,
                const U32 depth)
d15269 1
d15282 1
a15282 1
    scan = (regnode *) p;
d15286 1
d15288 3
a15290 3
            regprop(RExC_rx, RExC_mysv, scan, NULL, pRExC_state);
            Perl_re_printf( aTHX_  "~ %s (%d) %s %s\n",
                SvPV_nolen_const(RExC_mysv), REG_NODE_NUM(scan),
d15329 1
a15358 1
                case EXACTL:
a15362 1
                case EXACTFLU8:
d15376 1
d15378 3
a15380 3
            regprop(RExC_rx, RExC_mysv, scan, NULL, pRExC_state);
            Perl_re_printf( aTHX_  "~ %s (%d) -> %s\n",
                SvPV_nolen_const(RExC_mysv),
d15389 1
d15391 2
a15392 2
        regprop(RExC_rx, RExC_mysv, val, NULL, pRExC_state);
        Perl_re_printf( aTHX_
d15394 1
a15394 1
		      SvPV_nolen_const(RExC_mysv),
d15426 2
a15427 2
                Perl_re_printf( aTHX_  "%s",lead);
            Perl_re_printf( aTHX_  "%s ",PL_reg_intflags_name[bit]);
d15432 1
a15432 1
            Perl_re_printf( aTHX_  "\n");
d15434 1
a15434 1
            Perl_re_printf( aTHX_  "%s[none-set]\n",lead);
d15453 2
a15454 2
                Perl_re_printf( aTHX_  "%s",lead);
            Perl_re_printf( aTHX_  "%s ",PL_reg_extflags_name[bit]);
d15459 1
a15459 1
                Perl_re_printf( aTHX_  "%s",lead);
d15463 1
a15463 1
                    Perl_re_printf( aTHX_  "UNICODE");
d15466 1
a15466 1
                    Perl_re_printf( aTHX_  "LOCALE");
d15469 1
a15469 1
                    Perl_re_printf( aTHX_  "ASCII-RESTRICTED");
d15472 1
a15472 1
                    Perl_re_printf( aTHX_  "ASCII-MORE_RESTRICTED");
d15475 1
a15475 1
                    Perl_re_printf( aTHX_  "UNKNOWN CHARACTER SET");
d15481 1
a15481 1
            Perl_re_printf( aTHX_  "\n");
d15483 1
a15483 1
            Perl_re_printf( aTHX_  "%s[none-set]\n",lead);
d15492 1
d15506 1
a15506 1
        Perl_re_printf( aTHX_
d15513 1
a15513 1
        Perl_re_printf( aTHX_
d15521 1
a15521 1
        Perl_re_printf( aTHX_
d15528 1
a15528 1
        Perl_re_printf( aTHX_
d15534 1
a15534 1
        Perl_re_printf( aTHX_
d15540 1
a15540 1
        Perl_re_printf( aTHX_  " noscan");
d15542 1
a15542 1
        Perl_re_printf( aTHX_  " isall");
d15544 1
a15544 1
        Perl_re_printf( aTHX_  ") ");
d15547 2
a15548 2
        regprop(r, sv, ri->regstclass, NULL, NULL);
        Perl_re_printf( aTHX_  "stclass %s ", SvPVX_const(sv));
d15551 3
a15553 1
        Perl_re_printf( aTHX_  "anchored");
d15555 1
a15555 1
            Perl_re_printf( aTHX_  "(MBOL)");
d15557 1
a15557 1
            Perl_re_printf( aTHX_  "(SBOL)");
d15559 2
a15560 2
            Perl_re_printf( aTHX_  "(GPOS)");
        Perl_re_printf( aTHX_ " ");
d15563 1
a15563 1
        Perl_re_printf( aTHX_  "GPOS:%"UVuf" ", (UV)r->gofs);
d15565 1
a15565 1
        Perl_re_printf( aTHX_  "plus ");
d15567 2
a15568 2
        Perl_re_printf( aTHX_  "implicit ");
    Perl_re_printf( aTHX_  "minlen %"IVdf" ", (IV)r->minlen);
d15570 2
a15571 2
        Perl_re_printf( aTHX_  "with eval ");
    Perl_re_printf( aTHX_  "\n");
a15582 47
/* Should be synchronized with ANYOF_ #defines in regcomp.h */
#ifdef DEBUGGING

#  if   _CC_WORDCHAR != 0 || _CC_DIGIT != 1        || _CC_ALPHA != 2    \
     || _CC_LOWER != 3    || _CC_UPPER != 4        || _CC_PUNCT != 5    \
     || _CC_PRINT != 6    || _CC_ALPHANUMERIC != 7 || _CC_GRAPH != 8    \
     || _CC_CASED != 9    || _CC_SPACE != 10       || _CC_BLANK != 11   \
     || _CC_XDIGIT != 12  || _CC_CNTRL != 13       || _CC_ASCII != 14   \
     || _CC_VERTSPACE != 15
#   error Need to adjust order of anyofs[]
#  endif
static const char * const anyofs[] = {
    "\\w",
    "\\W",
    "\\d",
    "\\D",
    "[:alpha:]",
    "[:^alpha:]",
    "[:lower:]",
    "[:^lower:]",
    "[:upper:]",
    "[:^upper:]",
    "[:punct:]",
    "[:^punct:]",
    "[:print:]",
    "[:^print:]",
    "[:alnum:]",
    "[:^alnum:]",
    "[:graph:]",
    "[:^graph:]",
    "[:cased:]",
    "[:^cased:]",
    "\\s",
    "\\S",
    "[:blank:]",
    "[:^blank:]",
    "[:xdigit:]",
    "[:^xdigit:]",
    "[:cntrl:]",
    "[:^cntrl:]",
    "[:ascii:]",
    "[:^ascii:]",
    "\\v",
    "\\V"
};
#endif

d15588 1
a15588 1
Perl_regprop(pTHX_ const regexp *prog, SV *sv, const regnode *o, const regmatch_info *reginfo, const RExC_state_t *pRExC_state)
d15591 1
d15593 46
d15644 1
a15644 1
    sv_setpvn(sv, "", 0);
d15694 3
a15696 8
            (void) put_charclass_bitmap_innards(sv,
                                                ((IS_ANYOF_TRIE(op))
                                                 ? ANYOF_BITMAP(o)
                                                 : TRIE_BITMAP(trie)),
                                                NULL,
                                                NULL,
                                                NULL
                                               );
a15700 1
        U32 lo = ARG1(o), hi = ARG2(o);
d15703 1
a15703 6
        Perl_sv_catpvf(aTHX_ sv, "{%u,", (unsigned) lo);
        if (hi == REG_INFTY)
            sv_catpvs(sv, "INFTY");
        else
            Perl_sv_catpvf(aTHX_ sv, "%u", (unsigned) hi);
        sv_catpvs(sv, "}");
d15710 1
a15710 3
        AV *name_list= NULL;
        U32 parno= OP(o) == ACCEPT ? (U32)ARG2L(o) : ARG(o);
        Perl_sv_catpvf(aTHX_ sv, "%"UVuf, (UV)parno);        /* Parenth number */
a15711 5
            name_list= MUTABLE_AV(progi->data->data[progi->name_list_idx]);
        } else if ( pRExC_state ) {
            name_list= RExC_paren_name_list;
        }
        if (name_list) {
d15713 2
a15714 1
                SV **name= av_fetch(name_list, parno, 0 );
d15719 2
a15720 1
                SV *sv_dat= MUTABLE_SV(progi->data->data[ parno ]);
d15722 1
a15722 1
                SV **name= av_fetch(name_list, nums[0], 0 );
d15747 1
a15747 8
    } else if (k == GOSUB) {
        AV *name_list= NULL;
        if ( RXp_PAREN_NAMES(prog) ) {
            name_list= MUTABLE_AV(progi->data->data[progi->name_list_idx]);
        } else if ( pRExC_state ) {
            name_list= RExC_paren_name_list;
        }

d15749 6
a15754 9
        Perl_sv_catpvf(aTHX_ sv, "%d[%+d:%d]", (int)ARG(o),(int)ARG2L(o),
                (int)((o + (int)ARG2L(o)) - progi->program) );
        if (name_list) {
            SV **name= av_fetch(name_list, ARG(o), 0 );
            if (name)
                Perl_sv_catpvf(aTHX_ sv, " '%"SVf"'", SVfARG(*name));
        }
    }
    else if (k == LOGICAL)
d15759 1
a15759 22
        bool do_sep = FALSE;    /* Do we need to separate various components of
                                   the output? */
        /* Set if there is still an unresolved user-defined property */
        SV *unresolved                = NULL;

        /* Things that are ignored except when the runtime locale is UTF-8 */
        SV *only_utf8_locale_invlist = NULL;

        /* Code points that don't fit in the bitmap */
        SV *nonbitmap_invlist = NULL;

        /* And things that aren't in the bitmap, but are small enough to be */
        SV* bitmap_range_not_in_bitmap = NULL;

	if (OP(o) == ANYOFL) {
            if (ANYOFL_UTF8_LOCALE_REQD(flags)) {
                sv_catpvs(sv, "{utf8-locale-reqd}");
            }
            if (flags & ANYOFL_FOLD) {
                sv_catpvs(sv, "{i}");
            }
        }
a15760 26
        /* If there is stuff outside the bitmap, get it */
        if (ARG(o) != ANYOF_ONLY_HAS_BITMAP) {
            (void) _get_regclass_nonbitmap_data(prog, o, FALSE,
                                                &unresolved,
                                                &only_utf8_locale_invlist,
                                                &nonbitmap_invlist);
            /* The non-bitmap data may contain stuff that could fit in the
             * bitmap.  This could come from a user-defined property being
             * finally resolved when this call was done; or much more likely
             * because there are matches that require UTF-8 to be valid, and so
             * aren't in the bitmap.  This is teased apart later */
            _invlist_intersection(nonbitmap_invlist,
                                  PL_InBitmap,
                                  &bitmap_range_not_in_bitmap);
            /* Leave just the things that don't fit into the bitmap */
            _invlist_subtract(nonbitmap_invlist,
                              PL_InBitmap,
                              &nonbitmap_invlist);
        }

        /* Obey this flag to add all above-the-bitmap code points */
        if (flags & ANYOF_MATCHES_ALL_ABOVE_BITMAP) {
            nonbitmap_invlist = _add_range_to_invlist(nonbitmap_invlist,
                                                      NUM_ANYOF_CODE_POINTS,
                                                      UV_MAX);
        }
d15762 4
a15765 1
        /* Ready to start outputting.  First, the initial left bracket */
d15767 17
d15785 5
a15789 11
        /* Then all the things that could fit in the bitmap */
        do_sep = put_charclass_bitmap_innards(sv,
                                              ANYOF_BITMAP(o),
                                              bitmap_range_not_in_bitmap,
                                              only_utf8_locale_invlist,
                                              o);
        SvREFCNT_dec(bitmap_range_not_in_bitmap);

        /* If there are user-defined properties which haven't been defined yet,
         * output them, in a separate [] from the bitmap range stuff */
        if (unresolved) {
d15792 37
a15828 8
            }
            if (flags & ANYOF_INVERT) {
                sv_catpvs(sv, "^");
            }
            sv_catsv(sv, unresolved);
            do_sep = TRUE;
            SvREFCNT_dec_NN(unresolved);
        }
d15830 3
a15832 3
        /* And, finally, add the above-the-bitmap stuff */
        if (nonbitmap_invlist && _invlist_len(nonbitmap_invlist)) {
            SV* contents;
d15834 2
a15835 4
            /* See if truncation size is overridden */
            const STRLEN dump_len = (PL_dump_re_max_len)
                                    ? PL_dump_re_max_len
                                    : 256;
d15837 17
a15853 4
            /* This is output in a separate [] */
            if (do_sep) {
                Perl_sv_catpvf(aTHX_ sv,"%s][%s",PL_colors[1],PL_colors[0]);
            }
d15855 2
a15856 6
            /* And, for easy of understanding, it is always output not-shown as
             * complemented */
            if (flags & ANYOF_INVERT) {
                _invlist_invert(nonbitmap_invlist);
                _invlist_subtract(nonbitmap_invlist, PL_InBitmap, &nonbitmap_invlist);
            }
d15858 1
a15858 11
            contents = invlist_contents(nonbitmap_invlist,
                                        FALSE /* output suitable for catsv */
                                       );

            /* If the output is shorter than the permissible maximum, just do it. */
            if (SvCUR(contents) <= dump_len) {
                sv_catsv(sv, contents);
            }
            else {
                const char * contents_string = SvPVX(contents);
                STRLEN i = dump_len;
d15860 2
a15861 4
                /* Otherwise, start at the permissible max and work back to the
                 * first break possibility */
                while (i > 0 && contents_string[i] != ' ') {
                    i--;
d15863 20
a15882 3
                if (i == 0) {       /* Fail-safe.  Use the max if we couldn't
                                       find a legal break */
                    i = dump_len;
a15883 3

                sv_catpvn(sv, contents_string, i);
                sv_catpvs(sv, "...");
d15885 1
a15886 5
            SvREFCNT_dec_NN(contents);
            SvREFCNT_dec_NN(nonbitmap_invlist);
        }

        /* And finally the matching, closing ']' */
a15903 12
    else if (k == BOUND || k == NBOUND) {
        /* Must be synced with order of 'bound_type' in regcomp.h */
        const char * const bounds[] = {
            "",      /* Traditional */
            "{gcb}",
            "{lb}",
            "{sb}",
            "{wb}"
        };
        assert(FLAGS(o) < C_ARRAY_LENGTH(bounds));
        sv_catpv(sv, bounds[FLAGS(o)]);
    }
a15905 8
    else if (OP(o) == SBOL)
        Perl_sv_catpvf(aTHX_ sv, " /%s/", o->flags ? "\\A" : "^");

    /* add on the verb argument if there is one */
    if ( ( k == VERB || OP(o) == ACCEPT || OP(o) == OPFAIL ) && o->flags) {
        Perl_sv_catpvf(aTHX_ sv, ":%"SVf,
                       SVfARG((MUTABLE_SV(progi->data->data[ ARG( o ) ]))));
    }
a15911 1
    PERL_UNUSED_ARG(pRExC_state);
d15920 1
d15929 2
a15930 2
	    const char * const s = SvPV_nolen_const(RX_UTF8(r)
		      ? prog->check_utf8 : prog->check_substr);
d15933 1
a15933 1
            Perl_re_printf( aTHX_
d15936 1
a15936 1
		      RX_UTF8(r) ? "utf8 " : "",
d15943 1
a15943 2
    /* use UTF8 check substring if regexp pattern itself is in UTF8 */
    return RX_UTF8(r) ? prog->check_utf8 : prog->check_substr;
d15968 1
a15993 2
    if (r->recurse_locinput)
        Safefree(r->recurse_locinput);
a16076 2
    if (r->recurse_locinput)
        Newxz(ret->recurse_locinput,r->nparens + 1,char *);
d16097 1
d16111 1
a16111 1
            Perl_re_printf( aTHX_ "%sFreeing REx:%s %s\n",
a16149 3
#ifdef USE_ITHREADS
                    dVAR;
#endif
d16158 1
a16158 10
                        /* we should only ever get called once, so
                         * assert as much, and also guard the free
                         * which /might/ happen twice. At the least
                         * it will make code anlyzers happy and it
                         * doesn't cost much. - Yves */
                        assert(ri->regstclass);
                        if (ri->regstclass) {
                            PerlMemShared_free(ri->regstclass);
                            ri->regstclass = 0;
                        }
a16166 3
#ifdef USE_ITHREADS
                    dVAR;
#endif
d16201 1
a16201 1
   re_dup_guts - duplicate a regexp.
a16268 2
    if (r->recurse_locinput)
        Newxz(ret->recurse_locinput,r->nparens + 1,char *);
a16322 1

d16372 1
a16372 1
		/* FALLTHROUGH */
d16377 1
a16377 1
		/* FALLTHROUGH */
d16383 1
a16383 1
                Perl_croak(aTHX_ "panic: re_dup_guts unknown data code '%c'",
d16417 1
d16473 1
a16473 2
    I32 nparens = -1;
    I32 i;
a16475 1

d16478 16
a16493 24
	if (rx)
            nparens = RX_NPARENS(rx);
    }

    /* RT #124109. This is a complete hack; in the SWASHNEW case we know
     * that PL_curpm will be null, but that utf8.pm and the modules it
     * loads will only use $1..$3.
     * The t/porting/re_context.t test file checks this assumption.
     */
    if (nparens == -1)
        nparens = 3;

    for (i = 1; i <= nparens; i++) {
        char digits[TYPE_CHARS(long)];
        const STRLEN len = my_snprintf(digits, sizeof(digits),
                                       "%lu", (long)i);
        GV *const *const gvp
            = (GV**)hv_fetch(PL_defstash, digits, len, 0);

        if (gvp) {
            GV * const gv = *gvp;
            if (SvTYPE(gv) == SVt_PVGV && GvSV(gv))
                save_scalar(gv);
        }
d16501 1
a16501 1
S_put_code_point(pTHX_ SV *sv, UV c)
d16503 1
a16503 1
    PERL_ARGS_ASSERT_PUT_CODE_POINT;
d16505 12
a16516 2
    if (c > 255) {
        Perl_sv_catpvf(aTHX_ sv, "\\x{%04"UVXf"}", c);
d16518 3
a16520 6
    else if (isPRINT(c)) {
	const char string = (char) c;

        /* We use {phrase} as metanotation in the class, so also escape literal
         * braces */
	if (isBACKSLASHED_PUNCT(c) || c == '{' || c == '}')
a16523 6
    else if (isMNEMONIC_CNTRL(c)) {
        Perl_sv_catpvf(aTHX_ sv, "%s", cntrl_to_mnemonic((U8) c));
    }
    else {
        Perl_sv_catpvf(aTHX_ sv, "\\x%02X", (U8) c);
    }
a16525 2
#define MAX_PRINT_A MAX_PRINT_A_FOR_USE_ONLY_BY_REGCOMP_DOT_C

d16527 1
a16527 1
S_put_range(pTHX_ SV *sv, UV start, const UV end, const bool allow_literals)
d16529 1
d16531 1
a16531 11
     * 'start' to 'end'.  Mnemonics (like '\r') are used for the few controls
     * that have them, when they occur at the beginning or end of the range.
     * It uses hex to output the remaining code points, unless 'allow_literals'
     * is true, in which case the printable ASCII ones are output as-is (though
     * some of these will be escaped by put_code_point()).
     *
     * NOTE:  This is designed only for printing ranges of code points that fit
     *        inside an ANYOF bitmap.  Higher code points are simply suppressed
     */

    const unsigned int min_range_count = 3;
d16537 28
a16564 277
    while (start <= end) {
        UV this_end;
        const char * format;

        if (end - start < min_range_count) {

            /* Output chars individually when they occur in short ranges */
            for (; start <= end; start++) {
                put_code_point(sv, start);
            }
            break;
        }

        /* If permitted by the input options, and there is a possibility that
         * this range contains a printable literal, look to see if there is
         * one. */
        if (allow_literals && start <= MAX_PRINT_A) {

            /* If the character at the beginning of the range isn't an ASCII
             * printable, effectively split the range into two parts:
             *  1) the portion before the first such printable,
             *  2) the rest
             * and output them separately. */
            if (! isPRINT_A(start)) {
                UV temp_end = start + 1;

                /* There is no point looking beyond the final possible
                 * printable, in MAX_PRINT_A */
                UV max = MIN(end, MAX_PRINT_A);

                while (temp_end <= max && ! isPRINT_A(temp_end)) {
                    temp_end++;
                }

                /* Here, temp_end points to one beyond the first printable if
                 * found, or to one beyond 'max' if not.  If none found, make
                 * sure that we use the entire range */
                if (temp_end > MAX_PRINT_A) {
                    temp_end = end + 1;
                }

                /* Output the first part of the split range: the part that
                 * doesn't have printables, with the parameter set to not look
                 * for literals (otherwise we would infinitely recurse) */
                put_range(sv, start, temp_end - 1, FALSE);

                /* The 2nd part of the range (if any) starts here. */
                start = temp_end;

                /* We do a continue, instead of dropping down, because even if
                 * the 2nd part is non-empty, it could be so short that we want
                 * to output it as individual characters, as tested for at the
                 * top of this loop.  */
                continue;
            }

            /* Here, 'start' is a printable ASCII.  If it is an alphanumeric,
             * output a sub-range of just the digits or letters, then process
             * the remaining portion as usual. */
            if (isALPHANUMERIC_A(start)) {
                UV mask = (isDIGIT_A(start))
                           ? _CC_DIGIT
                             : isUPPER_A(start)
                               ? _CC_UPPER
                               : _CC_LOWER;
                UV temp_end = start + 1;

                /* Find the end of the sub-range that includes just the
                 * characters in the same class as the first character in it */
                while (temp_end <= end && _generic_isCC_A(temp_end, mask)) {
                    temp_end++;
                }
                temp_end--;

                /* For short ranges, don't duplicate the code above to output
                 * them; just call recursively */
                if (temp_end - start < min_range_count) {
                    put_range(sv, start, temp_end, FALSE);
                }
                else {  /* Output as a range */
                    put_code_point(sv, start);
                    sv_catpvs(sv, "-");
                    put_code_point(sv, temp_end);
                }
                start = temp_end + 1;
                continue;
            }

            /* We output any other printables as individual characters */
            if (isPUNCT_A(start) || isSPACE_A(start)) {
                while (start <= end && (isPUNCT_A(start)
                                        || isSPACE_A(start)))
                {
                    put_code_point(sv, start);
                    start++;
                }
                continue;
            }
        } /* End of looking for literals */

        /* Here is not to output as a literal.  Some control characters have
         * mnemonic names.  Split off any of those at the beginning and end of
         * the range to print mnemonically.  It isn't possible for many of
         * these to be in a row, so this won't overwhelm with output */
        while (isMNEMONIC_CNTRL(start) && start <= end) {
            put_code_point(sv, start);
            start++;
        }
        if (start < end && isMNEMONIC_CNTRL(end)) {

            /* Here, the final character in the range has a mnemonic name.
             * Work backwards from the end to find the final non-mnemonic */
            UV temp_end = end - 1;
            while (isMNEMONIC_CNTRL(temp_end)) {
                temp_end--;
            }

            /* And separately output the interior range that doesn't start or
             * end with mnemonics */
            put_range(sv, start, temp_end, FALSE);

            /* Then output the mnemonic trailing controls */
            start = temp_end + 1;
            while (start <= end) {
                put_code_point(sv, start);
                start++;
            }
            break;
        }

        /* As a final resort, output the range or subrange as hex. */

        this_end = (end < NUM_ANYOF_CODE_POINTS)
                    ? end
                    : NUM_ANYOF_CODE_POINTS - 1;
#if NUM_ANYOF_CODE_POINTS > 256
        format = (this_end < 256)
                 ? "\\x%02"UVXf"-\\x%02"UVXf""
                 : "\\x{%04"UVXf"}-\\x{%04"UVXf"}";
#else
        format = "\\x%02"UVXf"-\\x%02"UVXf"";
#endif
        GCC_DIAG_IGNORE(-Wformat-nonliteral);
        Perl_sv_catpvf(aTHX_ sv, format, start, this_end);
        GCC_DIAG_RESTORE;
        break;
    }
}

STATIC void
S_put_charclass_bitmap_innards_invlist(pTHX_ SV *sv, SV* invlist)
{
    /* Concatenate onto the PV in 'sv' a displayable form of the inversion list
     * 'invlist' */

    UV start, end;
    bool allow_literals = TRUE;

    PERL_ARGS_ASSERT_PUT_CHARCLASS_BITMAP_INNARDS_INVLIST;

    /* Generally, it is more readable if printable characters are output as
     * literals, but if a range (nearly) spans all of them, it's best to output
     * it as a single range.  This code will use a single range if all but 2
     * ASCII printables are in it */
    invlist_iterinit(invlist);
    while (invlist_iternext(invlist, &start, &end)) {

        /* If the range starts beyond the final printable, it doesn't have any
         * in it */
        if (start > MAX_PRINT_A) {
            break;
        }

        /* In both ASCII and EBCDIC, a SPACE is the lowest printable.  To span
         * all but two, the range must start and end no later than 2 from
         * either end */
        if (start < ' ' + 2 && end > MAX_PRINT_A - 2) {
            if (end > MAX_PRINT_A) {
                end = MAX_PRINT_A;
            }
            if (start < ' ') {
                start = ' ';
            }
            if (end - start >= MAX_PRINT_A - ' ' - 2) {
                allow_literals = FALSE;
            }
            break;
        }
    }
    invlist_iterfinish(invlist);

    /* Here we have figured things out.  Output each range */
    invlist_iterinit(invlist);
    while (invlist_iternext(invlist, &start, &end)) {
        if (start >= NUM_ANYOF_CODE_POINTS) {
            break;
        }
        put_range(sv, start, end, allow_literals);
    }
    invlist_iterfinish(invlist);

    return;
}

STATIC SV*
S_put_charclass_bitmap_innards_common(pTHX_
        SV* invlist,            /* The bitmap */
        SV* posixes,            /* Under /l, things like [:word:], \S */
        SV* only_utf8,          /* Under /d, matches iff the target is UTF-8 */
        SV* not_utf8,           /* /d, matches iff the target isn't UTF-8 */
        SV* only_utf8_locale,   /* Under /l, matches if the locale is UTF-8 */
        const bool invert       /* Is the result to be inverted? */
)
{
    /* Create and return an SV containing a displayable version of the bitmap
     * and associated information determined by the input parameters. */

    SV * output;

    PERL_ARGS_ASSERT_PUT_CHARCLASS_BITMAP_INNARDS_COMMON;

    if (invert) {
        output = newSVpvs("^");
    }
    else {
        output = newSVpvs("");
    }

    /* First, the code points in the bitmap that are unconditionally there */
    put_charclass_bitmap_innards_invlist(output, invlist);

    /* Traditionally, these have been placed after the main code points */
    if (posixes) {
        sv_catsv(output, posixes);
    }

    if (only_utf8 && _invlist_len(only_utf8)) {
        Perl_sv_catpvf(aTHX_ output, "%s{utf8}%s", PL_colors[1], PL_colors[0]);
        put_charclass_bitmap_innards_invlist(output, only_utf8);
    }

    if (not_utf8 && _invlist_len(not_utf8)) {
        Perl_sv_catpvf(aTHX_ output, "%s{not utf8}%s", PL_colors[1], PL_colors[0]);
        put_charclass_bitmap_innards_invlist(output, not_utf8);
    }

    if (only_utf8_locale && _invlist_len(only_utf8_locale)) {
        Perl_sv_catpvf(aTHX_ output, "%s{utf8 locale}%s", PL_colors[1], PL_colors[0]);
        put_charclass_bitmap_innards_invlist(output, only_utf8_locale);

        /* This is the only list in this routine that can legally contain code
         * points outside the bitmap range.  The call just above to
         * 'put_charclass_bitmap_innards_invlist' will simply suppress them, so
         * output them here.  There's about a half-dozen possible, and none in
         * contiguous ranges longer than 2 */
        if (invlist_highest(only_utf8_locale) >= NUM_ANYOF_CODE_POINTS) {
            UV start, end;
            SV* above_bitmap = NULL;

            _invlist_subtract(only_utf8_locale, PL_InBitmap, &above_bitmap);

            invlist_iterinit(above_bitmap);
            while (invlist_iternext(above_bitmap, &start, &end)) {
                UV i;

                for (i = start; i <= end; i++) {
                    put_code_point(output, i);
                }
            }
            invlist_iterfinish(above_bitmap);
            SvREFCNT_dec_NN(above_bitmap);
        }
    }

    /* If the only thing we output is the '^', clear it */
    if (invert && SvCUR(output) == 1) {
        SvCUR_set(output, 0);
a16565 2

    return output;
d16569 1
a16569 5
S_put_charclass_bitmap_innards(pTHX_ SV *sv,
                                     char *bitmap,
                                     SV *nonbitmap_invlist,
                                     SV *only_utf8_locale_invlist,
                                     const regnode * const node)
d16572 2
a16573 28
     * character class defined by the other arguments:
     *  'bitmap' points to the bitmap.
     *  'nonbitmap_invlist' is an inversion list of the code points that are in
     *      the bitmap range, but for some reason aren't in the bitmap; NULL if
     *      none.  The reasons for this could be that they require some
     *      condition such as the target string being or not being in UTF-8
     *      (under /d), or because they came from a user-defined property that
     *      was not resolved at the time of the regex compilation (under /u)
     *  'only_utf8_locale_invlist' is an inversion list of the code points that
     *      are valid only if the runtime locale is a UTF-8 one; NULL if none
     *  'node' is the regex pattern node.  It is needed only when the above two
     *      parameters are not null, and is passed so that this routine can
     *      tease apart the various reasons for them.
     *
     * It returns TRUE if there was actually something output.  (It may be that
     * the bitmap, etc is empty.)
     *
     * When called for outputting the bitmap of a non-ANYOF node, just pass the
     * bitmap, with the succeeding parameters set to NULL.
     *
     */

    /* In general, it tries to display the 'cleanest' representation of the
     * innards, choosing whether to display them inverted or not, regardless of
     * whether the class itself is to be inverted.  However,  there are some
     * cases where it can't try inverting, as what actually matches isn't known
     * until runtime, and hence the inversion isn't either. */
    bool inverting_allowed = TRUE;
d16576 1
a16576 55
    STRLEN orig_sv_cur = SvCUR(sv);

    SV* invlist;            /* Inversion list we accumulate of code points that
                               are unconditionally matched */
    SV* only_utf8 = NULL;   /* Under /d, list of matches iff the target is
                               UTF-8 */
    SV* not_utf8 =  NULL;   /* /d, list of matches iff the target isn't UTF-8
                             */
    SV* posixes = NULL;     /* Under /l, string of things like [:word:], \D */
    SV* only_utf8_locale = NULL;    /* Under /l, list of matches if the locale
                                       is UTF-8 */

    SV* as_is_display;      /* The output string when we take the inputs
                              literally */
    SV* inverted_display;   /* The output string when we invert the inputs */

    U8 flags = (node) ? ANYOF_FLAGS(node) : 0;

    bool invert = cBOOL(flags & ANYOF_INVERT);  /* Is the input to be inverted
                                                   to match? */
    /* We are biased in favor of displaying things without them being inverted,
     * as that is generally easier to understand */
    const int bias = 5;

    PERL_ARGS_ASSERT_PUT_CHARCLASS_BITMAP_INNARDS;

    /* Start off with whatever code points are passed in.  (We clone, so we
     * don't change the caller's list) */
    if (nonbitmap_invlist) {
        assert(invlist_highest(nonbitmap_invlist) < NUM_ANYOF_CODE_POINTS);
        invlist = invlist_clone(nonbitmap_invlist);
    }
    else {  /* Worst case size is every other code point is matched */
        invlist = _new_invlist(NUM_ANYOF_CODE_POINTS / 2);
    }

    if (flags) {
        if (OP(node) == ANYOFD) {

            /* This flag indicates that the code points below 0x100 in the
             * nonbitmap list are precisely the ones that match only when the
             * target is UTF-8 (they should all be non-ASCII). */
            if (flags & ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP)
            {
                _invlist_intersection(invlist, PL_UpperLatin1, &only_utf8);
                _invlist_subtract(invlist, only_utf8, &invlist);
            }

            /* And this flag for matching all non-ASCII 0xFF and below */
            if (flags & ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER)
            {
                not_utf8 = invlist_clone(PL_UpperLatin1);
            }
        }
        else if (OP(node) == ANYOFL) {
d16578 1
a16578 6
            /* If either of these flags are set, what matches isn't
             * determinable except during execution, so don't know enough here
             * to invert */
            if (flags & (ANYOFL_FOLD|ANYOF_MATCHES_POSIXL)) {
                inverting_allowed = FALSE;
            }
d16580 2
a16581 4
            /* What the posix classes match also varies at runtime, so these
             * will be output symbolically. */
            if (ANYOF_POSIXL_TEST_ANY_SET(node)) {
                int i;
d16583 6
a16588 5
                posixes = newSVpvs("");
                for (i = 0; i < ANYOF_POSIXL_MAX; i++) {
                    if (ANYOF_POSIXL_TEST(node,i)) {
                        sv_catpv(posixes, anyofs[i]);
                    }
a16590 13
        }
    }

    /* Accumulate the bit map into the unconditional match list */
    for (i = 0; i < NUM_ANYOF_CODE_POINTS; i++) {
        if (BITMAP_TEST(bitmap, i)) {
            int start = i++;
            for (; i < NUM_ANYOF_CODE_POINTS && BITMAP_TEST(bitmap, i); i++) {
                /* empty */
            }
            invlist = _add_range_to_invlist(invlist, start, i-1);
        }
    }
d16592 5
a16596 102
    /* Make sure that the conditional match lists don't have anything in them
     * that match unconditionally; otherwise the output is quite confusing.
     * This could happen if the code that populates these misses some
     * duplication. */
    if (only_utf8) {
        _invlist_subtract(only_utf8, invlist, &only_utf8);
    }
    if (not_utf8) {
        _invlist_subtract(not_utf8, invlist, &not_utf8);
    }

    if (only_utf8_locale_invlist) {

        /* Since this list is passed in, we have to make a copy before
         * modifying it */
        only_utf8_locale = invlist_clone(only_utf8_locale_invlist);

        _invlist_subtract(only_utf8_locale, invlist, &only_utf8_locale);

        /* And, it can get really weird for us to try outputting an inverted
         * form of this list when it has things above the bitmap, so don't even
         * try */
        if (invlist_highest(only_utf8_locale) >= NUM_ANYOF_CODE_POINTS) {
            inverting_allowed = FALSE;
        }
    }

    /* Calculate what the output would be if we take the input as-is */
    as_is_display = put_charclass_bitmap_innards_common(invlist,
                                                    posixes,
                                                    only_utf8,
                                                    not_utf8,
                                                    only_utf8_locale,
                                                    invert);

    /* If have to take the output as-is, just do that */
    if (! inverting_allowed) {
        sv_catsv(sv, as_is_display);
    }
    else { /* But otherwise, create the output again on the inverted input, and
              use whichever version is shorter */

        int inverted_bias, as_is_bias;

        /* We will apply our bias to whichever of the the results doesn't have
         * the '^' */
        if (invert) {
            invert = FALSE;
            as_is_bias = bias;
            inverted_bias = 0;
        }
        else {
            invert = TRUE;
            as_is_bias = 0;
            inverted_bias = bias;
        }

        /* Now invert each of the lists that contribute to the output,
         * excluding from the result things outside the possible range */

        /* For the unconditional inversion list, we have to add in all the
         * conditional code points, so that when inverted, they will be gone
         * from it */
        _invlist_union(only_utf8, invlist, &invlist);
        _invlist_union(not_utf8, invlist, &invlist);
        _invlist_union(only_utf8_locale, invlist, &invlist);
        _invlist_invert(invlist);
        _invlist_intersection(invlist, PL_InBitmap, &invlist);

        if (only_utf8) {
            _invlist_invert(only_utf8);
            _invlist_intersection(only_utf8, PL_UpperLatin1, &only_utf8);
        }

        if (not_utf8) {
            _invlist_invert(not_utf8);
            _invlist_intersection(not_utf8, PL_UpperLatin1, &not_utf8);
        }

        if (only_utf8_locale) {
            _invlist_invert(only_utf8_locale);
            _invlist_intersection(only_utf8_locale,
                                  PL_InBitmap,
                                  &only_utf8_locale);
        }

        inverted_display = put_charclass_bitmap_innards_common(
                                            invlist,
                                            posixes,
                                            only_utf8,
                                            not_utf8,
                                            only_utf8_locale, invert);

        /* Use the shortest representation, taking into account our bias
         * against showing it inverted */
        if (SvCUR(inverted_display) + inverted_bias
            < SvCUR(as_is_display) + as_is_bias)
        {
	    sv_catsv(sv, inverted_display);
        }
        else {
	    sv_catsv(sv, as_is_display);
a16597 3

        SvREFCNT_dec_NN(as_is_display);
        SvREFCNT_dec_NN(inverted_display);
d16600 1
a16600 7
    SvREFCNT_dec_NN(invlist);
    SvREFCNT_dec(only_utf8);
    SvREFCNT_dec(not_utf8);
    SvREFCNT_dec(posixes);
    SvREFCNT_dec(only_utf8_locale);

    return SvCUR(sv) > orig_sv_cur;
d16603 1
a16603 1
#define CLEAR_OPTSTART                                                       \
d16605 1
a16605 1
        DEBUG_OPTIMISE_r(Perl_re_printf( aTHX_                                           \
d16607 1
a16607 1
        optstart=NULL;                                                       \
d16619 1
d16630 1
a16630 1
    Perl_re_printf( aTHX_  "--- %d : %d - %d - %d\n",indent,node-start,
a16637 1
        assert(node);
d16654 2
a16655 2
        regprop(r, sv, node, NULL, NULL);
        Perl_re_printf( aTHX_  "%4"IVdf":%*s%s", (IV)(node - start),
d16660 1
a16660 1
                Perl_re_printf( aTHX_  " (0)");
d16663 1
a16663 1
                Perl_re_printf( aTHX_  " (FAIL)");
d16665 2
a16666 2
                Perl_re_printf( aTHX_  " (%"IVdf")", (IV)(next - start));
            Perl_re_printf( aTHX_ "\n");
d16704 2
a16705 2
                Perl_re_indentf( aTHX_  "%s ",
                    indent+3,
d16720 1
a16720 1
                    Perl_re_printf( aTHX_  "(%"UVuf")\n",
d16730 1
a16730 1
                    Perl_re_printf( aTHX_  "\n");
d16751 1
a16751 1
	    node += 1 + ((ANYOF_FLAGS(node) & ANYOF_MATCHES_POSIXL)
d16770 1
a16770 1
    Perl_re_printf( aTHX_  "--- %d\n", (int)indent);
d16778 6
@


