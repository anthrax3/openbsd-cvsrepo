head	1.8;
access;
symbols
	OPENBSD_4_4:1.7.0.10
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.8
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.6
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	PERL_5_8_8:1.1.1.6
	OPENBSD_3_9:1.6.0.14
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.12
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.10
	OPENBSD_3_7_BASE:1.6
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.6.0.8
	OPENBSD_3_6_BASE:1.6
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.6.0.6
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;


1.8
date	2008.09.29.17.36.21;	author millert;	state dead;
branches;
next	1.7;

1.7
date	2006.03.28.19.23.13;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.38;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.36.28;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.08.44;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.44;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.06.11;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.27;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.27;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.41.59;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.59;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.26.03;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.11;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.03.28.18.49.51;	author millert;	state Exp;
branches;
next	;


desc
@@


1.8
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@#!/usr/bin/perl
# Habit . . .
#
# Extract info from Config.VMS, and add extra data here, to generate Config.sh
# Edit the static information after __END__ to reflect your site and options
# that went into your perl binary.  In addition, values which change from run
# to run may be supplied on the command line as key=val pairs.
#
# Rev. 16-Feb-1998  Charles Bailey  bailey@@newman.upenn.edu
#

#==== Locations of installed Perl components
$prefix='perl_root';
$builddir="$prefix:[000000]";
$installbin="$prefix:[000000]";
$installscript="$prefix:[000000]";
$installman1dir="$prefix:[man.man1]";
$installman3dir="$prefix:[man.man3]";
$installprivlib="$prefix:[lib]";
$installsitelib="$prefix:[lib.site_perl]";

unshift(@@INC,'lib');  # In case someone didn't define Perl_Root
                      # before the build

if ($ARGV[0] eq '-f') {
  open(ARGS,$ARGV[1]) or die "Can't read data from $ARGV[1]: $!\n";
  @@ARGV = ();
  while (<ARGS>) {
    chomp;
    push(@@ARGV,split(/\|/,$_));
  }
  close ARGS;
}

if (-f "config.vms") { $infile = "config.vms"; $outdir = "[-]"; }
elsif (-f "[.vms]config.vms") { $infile = "[.vms]config.vms"; $outdir = "[]"; }
elsif (-f "config.h") { $infile = "config.h"; $outdir = "[]";}

if ($infile) { print "Generating Config.sh from $infile . . .\n"; }
else { die <<EndOfGasp;
Can't find config.vms or config.h to read!
	Please run this script from the perl source directory or
	the VMS subdirectory in the distribution.
EndOfGasp
}
$outdir = '';
open(IN,"$infile") || die "Can't open $infile: $!\n";
open(OUT,">${outdir}Config.sh") || die "Can't open ${outdir}Config.sh: $!\n";

$time = localtime;
$cf_by = (getpwuid($<))[0];
$archsufx = `Write Sys\$Output F\$GetSyi("HW_MODEL")` > 1024 ? 'AXP' : 'VAX';
($vers = $]) =~ tr/./_/;
$installarchlib = VMS::Filespec::vmspath($installprivlib);
$installarchlib =~ s#\]#.VMS_$archsufx.$vers\]#;
$installsitearch = VMS::Filespec::vmspath($installsitelib);
$installsitearch =~ s#\]#.VMS_$archsufx\]#;
($osvers = `Write Sys\$Output F\$GetSyi("VERSION")`) =~ s/^V?(\S+)\s*\n?$/$1/;

print OUT <<EndOfIntro;
# This file generated by GenConfig.pl on a VMS system.
# Input obtained from:
#     $infile
#     $0
# Time: $time

package='perl5'
CONFIG='true'
cf_time='$time'
cf_by='$cf_by'
ccdlflags='undef'
cccdlflags='undef'
mab='undef'
libpth='/sys\$share /sys\$library'
ld='Link'
lddlflags='/Share'
ranlib='undef'
ar='undef'
eunicefix=':'
hint='none'
hintfile='undef'
useshrplib='define'
usemymalloc='n'
usevfork='true'
spitshell='write sys\$output '
dlsrc='dl_vms.c'
binexp='$installbin'
man1ext='rno'
man3ext='rno'
arch='VMS_$archsufx'
archname='VMS_$archsufx'
bincompat3='undef'
d_bincompat3='undef'
osvers='$osvers'
prefix='$prefix'
builddir='$builddir'
installbin='$installbin'
installscript='$installscript'
installman1dir='$installman1dir'
installman3dir='$installman3dir'
installprivlib='$installprivlib'
installarchlib='$installarchlib'
installsitelib='$installsitelib'
installsitearch='$installsitearch'
path_sep='|'
startperl='\$ perl 'f\$env("procedure")' 'p1' 'p2' 'p3' 'p4' 'p5' 'p6' 'p7' 'p8' !
\$ exit++ + ++\$status != 0 and \$exit = \$status = undef;'
EndOfIntro

foreach (@@ARGV) {
  ($key,$val) = split('=',$_,2);
  if ($key eq 'cc') {  # Figure out which C compiler we're using
    my($cc,$ccflags) = split('/',$val,2);
    my($d_attr);
    $ccflags = "/$ccflags";
    if ($ccflags =~s!/DECC!!ig) { 
      $cc .= '/DECC';
      $cctype = 'decc';
      $d_attr = 'undef';
    }
    elsif ($ccflags =~s!/VAXC!!ig) {
      $cc .= '/VAXC';
      $cctype = 'vaxc';
      $d_attr = 'undef';
    }
    elsif (`$val/NoObject/NoList _nla0:/Version` =~ /GNU C version (\S+)/) {
      $cctype = 'gcc';
      $d_attr = 'define';
      print OUT "gccversion='$1'\n";
    }
    elsif ($archsufx eq 'VAX' &&
           # Check exit status too, in case message is turned off
           ( `$val/NoObject/NoList /prefix=all _nla0:` =~ /IVQUAL/ ||
              $? == 0x38240 )) {
      $cctype = 'vaxc';
      $d_attr = 'undef';
    }
    else {
      $cctype = 'decc';
      $d_attr = 'undef';
    }
    print OUT "vms_cc_type='$cctype'\n";
    print OUT "d_attribute_format='$d_attr'\n";
    # XXX The following attributes may be able to use $d_attr, too.
    print OUT "d_attribute_malloc='undef'\n";
    print OUT "d_attribute_nonnull='undef'\n";
    print OUT "d_attribute_noreturn='undef'\n";
    print OUT "d_attribute_pure='undef'\n";
    print OUT "d_attribute_unused='undef'\n";
    print OUT "d_attribute_warn_unused_result='undef'\n";
    print OUT "cc='$cc'\n";
    if ( ($cctype eq 'decc' and $archsufx eq 'VAX') || $cctype eq 'gcc') {
      # gcc and DECC for VAX requires filename in /object qualifier, so we
      # have to remove it here.  Alas, this means we lose the user's
      # object file suffix if it's not .obj.
      $ccflags =~ s#/obj(?:ect)?=[^/\s]+##i;
    }
    $debug = $optimize = '';
    while ( ($qual) = $ccflags =~ m|(/(No)?Deb[^/]*)|i ) {
      $debug = $qual;
      $ccflags =~ s/$qual//;
    }
    while ( ($qual) = $ccflags =~ m|(/(No)?Opt[^/]*)|i ) {
      $optimize = $qual;
      $ccflags =~ s/$qual//;
    }
    $usethreads = ($ccflags =~ m!/DEF[^/]+USE_5005THREADS!i and
                   $ccflags !~ m!/UND[^/]+USE_5005THREADS!i);
    print OUT "usethreads='",($usethreads ? 'define' : 'undef'),"'\n";;
    $optimize = "$debug$optimize";
    print OUT "ccflags='$ccflags'\n";
    print OUT "optimize='$optimize'\n";
    $dosock = ($ccflags =~ m!/DEF[^/]+VMS_DO_SOCKETS!i and
               $ccflags !~ m!/UND[^/]+VMS_DO_SOCKETS!i);
    print OUT "d_vms_do_sockets=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "d_socket=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "d_sockpair=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "d_gethent=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "d_sethent=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "d_select=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "i_netdb=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "i_niin=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "i_neterrno=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "d_gethbyname=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "d_gethbyaddr=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "d_getpbyname=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "d_getpbynumber=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "d_getsbyname=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "d_getsbyport=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "d_endhent=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "d_getpent=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "d_setpent=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "d_endpent=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "d_getsent=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "d_setsent=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "d_endsent=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "netdb_name_type=",$dosock ? "'char *'\n" : "'undef'\n";
    print OUT "netdb_host_type=",$dosock ? "'char *'\n" : "'undef'\n";
    print OUT "netdb_hlen_type=",$dosock ? "'int'\n" : "'undef'\n";
    print OUT "d_gethostprotos=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "d_getnetprotos=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "d_getservprotos=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "d_getprotoprotos=",$dosock ? "'define'\n" : "'undef'\n";

    if ($dosock and $cctype eq 'decc' and $ccflags =~ /DECCRTL_SOCKETS/) {
      print OUT "selecttype='fd_set'\n";
      print OUT "d_getnbyaddr='define'\n";
      print OUT "d_getnbyname='define'\n";
      print OUT "d_getnent='define'\n";
      print OUT "d_setnent='define'\n";
      print OUT "d_endnent='define'\n";
      print OUT "netdb_net_type='long'\n";
    }
    else {
      print OUT "selecttype='int'\n";
      print OUT "d_getnybname='undef'\n";
      print OUT "d_getnybaddr='undef'\n";
      print OUT "d_getnent='undef'\n";
      print OUT "d_setnent='undef'\n";
      print OUT "d_endnent='undef'\n";
      print OUT "netdb_net_type='undef'\n";
    }

    if ($cctype eq 'decc') {
      $rtlhas  = 'define';
      print OUT "useposix='true'\n";
      ($ccver,$vmsver) = `$cc/VERSION` =~ /V(\S+) on .*V(\S+)$/;
      # Best guess; the may be wrong on systems which have separately
      # installed the new CRTL.
      if ($ccver >= 5.2 and $vmsver >= 7) { $rtlnew = 'define'; }
      else                                { $rtlnew = 'undef';  }
    }
    else { $rtlhas = $rtlnew = 'undef';  print OUT "useposix='false'\n"; }
    foreach (qw[ d_stdstdio d_stdio_ptr_lval d_stdio_cnt_lval d_stdiobase
                 d_locconv d_setlocale i_locale d_mbstowcs d_mbtowc
                 d_wcstombs d_wctomb d_mblen d_mktime d_strcoll d_strxfrm ]) {
      print OUT "$_='$rtlhas'\n";
    }
    print OUT "d_stdio_ptr_lval_sets_cnt='undef'\n";
    print OUT "d_stdio_ptr_lval_nochange_cnt='undef'\n";
    foreach (qw[ d_gettimeod d_uname d_truncate d_wait4 d_index
                 d_pathconf d_fpathconf d_sysconf d_sigsetjmp ]) {
      print OUT "$_='$rtlnew'\n";
    }
    next;
  }
  elsif ($key eq 'exe_ext') { 
    my($nodot) = $val;
    $nodot =~ s!\.!!;
    print OUT "so='$nodot'\ndlext='$nodot'\n";
  }
  elsif ($key eq 'obj_ext') { print OUT "dlobj='dl_vms$val'\n";     }
  print OUT "$key='$val'\n";
}

# Are there any other logicals which TCP/IP stacks use for the host name?
$myname = $ENV{'ARPANET_HOST_NAME'}  || $ENV{'INTERNET_HOST_NAME'} ||
          $ENV{'MULTINET_HOST_NAME'} || $ENV{'UCX$INET_HOST'}      ||
          $ENV{'TCPWARE_DOMAINNAME'} || $ENV{'NEWS_ADDRESS'};
if (!$myname) {
  ($myname) = `hostname` =~ /^(\S+)/;
  if ($myname =~ /IVVERB/) {
    warn "Can't determine TCP/IP hostname" if $dosock;
    $myname = '';
  }
}
$myname = $ENV{'SYS$NODE'} unless $myname;
($myhostname,$mydomain) = split(/\./,$myname,2);
print OUT "myhostname='$myhostname'\n" if $myhostname;
if ($mydomain) {
  print OUT "mydomain='.$mydomain'\n";
  print OUT "perladmin='$cf_by\@@$myhostname.$mydomain'\n";
  print OUT "cf_email='$cf_by\@@$myhostname.$mydomain'\n";
}
else {
  print OUT "perladmin='$cf_by'\n";
  print OUT "cf_email='$cf_by'\n";
}
chomp($hwname = `Write Sys\$Output F\$GetSyi("HW_NAME")`);
$hwname = $archsufx if $hwname =~ /IVKEYW/;  # *really* old VMS version
print OUT "myuname='VMS $myname $osvers $hwname'\n";

# Before we read the C header file, find out what config.sh constants are
# equivalent to the C preprocessor macros
if (open(SH,"${outdir}config_h.SH")) {
  while (<SH>) {
    next unless m%^#(?!if).*\$%;
    s/^#//; s!(.*?)\s*/\*.*!$1!;
    my(@@words) = split;
    $words[1] =~ s/\(.*//;  # Clip off args from macro
    # Did we use a shell variable for the preprocessor directive?
    if ($words[0] =~ m!^\$(\w+)!) { $pp_vars{$words[1]} = $1; }
    if (@@words > 2) {  # We may also have a shell var in the value
      shift @@words;              #  Discard preprocessor directive
      my($token) = shift @@words; #  and keep constant name
      my($word);
      foreach $word (@@words) {
        next unless $word =~ m!\$(\w+)!;
        $val_vars{$token} = $1;
        last;
      }
    }
  }
  close SH;
}
else { warn "Couldn't read ${outdir}config_h.SH: $!\n"; }
$pp_vars{UNLINK_ALL_VERSIONS} = 'd_unlink_all_versions';  # VMS_specific

# OK, now read the C header file, and retcon statements into config.sh
while (<IN>) {  # roll through the comment header in Config.VMS
  last if /config-start/;
}

while (<IN>) {
  chop;
  while (/\\\s*$/) {  # pick up contination lines
    my $line = $_;
    $line =~ s/\\\s*$//;
    $_ = <IN>;
    s/^\s*//;
    $_ = $line . $_;
  }              
  next unless my ($blocked,$un,$token,$val) =
                 m%^(\/\*)?\s*\#\s*(un)?def\w*\s+([A-Za-z0-9]\w+)\S*\s*(.*)%;
  if (/config-skip/) {
    delete $pp_vars{$token} if exists $pp_vars{$token};
    delete $val_vars{$token} if exists $val_vars{$token};
    next;
  }
  $val =~ s!\s*/\*.*!!; # strip off trailing comment
  my($had_val); # Maybe a macro with args that we just #undefd or commented
  if (!length($val) and $val_vars{$token} and ($un || $blocked)) {
    print OUT "$val_vars{$token}=''\n" unless exists $done{$val_vars{$token}};
    $done{$val_vars{$token}}++;
    delete $val_vars{$token};
    $had_val = 1;
  }
  $state = ($blocked || $un) ? 'undef' : 'define';
  if ($pp_vars{$token}) {
    print OUT "$pp_vars{$token}='$state'\n" unless exists $done{$pp_vars{$token}};
    $done{$pp_vars{$token}}++;
    delete $pp_vars{$token};
  }
  elsif (not length $val and not $had_val) {
    # Wups -- should have been shell var for C preprocessor directive
    warn "Constant $token not found in config_h.SH\n";
    $token = lc $token;
    $token = "d_$token" unless $token =~ /^i_/;
    print OUT "$token='$state'\n";
  }
  next unless length $val;
  $val =~ s/^"//; $val =~ s/"$//;               # remove end quotes
  $val =~ s/","/ /g;                            # make signal list look nice
  # Library directory; convert to VMS syntax
  $val = VMS::Filespec::vmspath($val) if ($token =~ /EXP$/);
  if ($val_vars{$token}) {
    print OUT "$val_vars{$token}='$val'\n" unless exists $done{$val_vars{$token}};
    if ($val_vars{$token} =~ s/exp$//) {
      print OUT "$val_vars{$token}='$val'\n" unless exists $done{$val_vars{$token}};;
    }
    $done{$val_vars{$token}}++;
    delete $val_vars{$token};
  }
  elsif (!$pp_vars{$token}) {  # Haven't seen it previously, either
    warn "Constant $token not found in config_h.SH (val=|$val|)\n";
    $token = lc $token;
    print OUT "$token='$val'\n";
    if ($token =~ s/exp$//) {print OUT "$token='$val'\n";}
  }
}
close IN;
# Special case -- preprocessor manifest "VMS" is defined automatically
# on VMS systems, but is also used erroneously by the Perl build process
# as the manifest for the obsolete variable $d_eunice.
print OUT "d_eunice='undef'\n";  delete $pp_vars{VMS};

# XXX temporary -- USE_5005THREADS is currently on CC command line
delete $pp_vars{'USE_5005THREADS'};

foreach (sort keys %pp_vars) {
  warn "Didn't see $_ in $infile\n";
}
foreach (sort keys %val_vars) {
  warn "Didn't see $_ in $infile(val)\n";
}

if (open(OPT,"${outdir}crtl.opt")) {
  while (<OPT>) {
    next unless m#/(sha|lib)#i;
    chomp;
    if (/crtl/i || /gcclib/i) { push(@@crtls,$_); }
    else                      { push(@@libs,$_);  }
  }
  close OPT;
  print OUT "libs='",join(' ',@@libs),"'\n";
  push(@@crtls,'(DECCRTL)') if $cctype eq 'decc';
  print OUT "libc='",join(' ',@@crtls),"'\n";
}
else { warn "Can't read ${outdir}crtl.opt - skipping 'libs' & 'libc'"; }

if (open(PL,"${outdir}patchlevel.h")) {
  while (<PL>) {
    if    (/^#define PERL_VERSION\s+(\S+)/) {
      print OUT "PERL_VERSION='$1'\n";
      print OUT "PATCHLEVEL='$1'\n";	# XXX compat
    }
    elsif (/^#define PERL_SUBVERSION\s+(\S+)/) {
      print OUT "PERL_SUBVERSION='$1'\n";
      print OUT "SUBVERSION='$1'\n";	# XXX compat
    }
  }
  close PL;
}
else { warn "Can't read ${outdir}patchlevel.h - skipping 'PATCHLEVEL'"; }

# simple pager support for perldoc                                             
if    (`most not..file` =~ /IVVERB/) {
  $pager = 'more';
  if (`more nl:` =~ /IVVERB/) { $pager = 'type/page'; }
}
else { $pager = 'most'; }
print OUT "pager='$pager'\n";

close OUT;
@


1.7
log
@merge in perl 5.8.8
@
text
@@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d143 8
a150 1
    print OUT "d_attribut='$d_attr'\n";
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d160 2
a161 2
    $usethreads = ($ccflags =~ m!/DEF[^/]+USE_THREADS!i and
                   $ccflags !~ m!/UND[^/]+USE_THREADS!i);
d370 2
a371 2
# XXX temporary -- USE_THREADS is currently on CC command line
delete $pp_vars{'USE_THREADS'};
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d232 2
@


1.3
log
@perl5.005_03 (stock)
@
text
@d394 8
a401 2
    if    (/^#define PATCHLEVEL\s+(\S+)/) { print OUT "PATCHLEVEL='$1'\n"; }
    elsif (/^#define SUBVERSION\s+(\S+)/) { print OUT "SUBVERSION='$1'\n"; }
@


1.2
log
@perl 5.004_04
@
text
@d9 1
a9 1
# Rev.  3-Dec-1996  Charles Bailey  bailey@@genetics.upenn.edu
d29 1
d71 3
a73 3
ccdlflags=''
cccdlflags=''
mab=''
d77 2
a78 2
ranlib=''
ar=''
d81 2
a82 2
hintfile=''
shrplib='define'
a84 1
useposix='false'
d92 2
d151 13
d165 1
d172 1
d174 1
d177 39
d217 10
a226 2
    if ($cctype eq 'decc') { $rtlhas  = 'define'; }
    else                   { $rtlhas  = 'undef';  }
d232 4
d367 3
@


1.1
log
@Initial revision
@
text
@d9 1
a9 1
# Rev. 13-Dec-1995  Charles Bailey  bailey@@genetics.upenn.edu
d12 10
d50 9
d69 5
a80 2
intsize='4'
alignbytes='8'
d83 2
d86 20
a107 18
$cf_by = (getpwuid($<))[0];
print OUT "cf_by='$cf_by'\n";

$hw_model = `Write Sys\$Output F\$GetSyi("HW_MODEL")`;
chomp $hw_model;
if ($hw_model > 1024) {
  print OUT "arch='VMS_AXP'\n";
  print OUT "archname='VMS_AXP'\n";
  $archsufx = "AXP";
}
else {
  print OUT "arch='VMS_VAX'\n";
  print OUT "archname='VMS_VAX'\n";
  $archsufx = 'VAX';
}
$osvers = `Write Sys\$Output F\$GetSyi("VERSION")`;
$osvers =~ s/^V?(\S+)\s*\n?$/$1/;
print OUT "osvers='$osvers'\n";
d124 1
a124 1
    elsif (`$val/NoObject/NoList _nla0:/Version` =~ /GNU/) {
d127 1
d130 3
a132 1
           `$val/NoObject/NoList /prefix=all _nla0:` =~ /IVQUAL/) {
d152 15
d169 7
a175 1
  print OUT "$key=\'$val\'\n";
d205 27
d245 15
a259 2
  next unless my ($blocked,$un,$token,$val) = m%^(\/\*)?\s*\#\s*(un)?def\w*\s*([A-za-z0-9]\w+)\S*\s*(.*)%;
  next if /config-skip/;
d261 13
a273 10
  $token =~ tr/A-Z/a-z/;
  $token =~ s/_exp$/exp/;  # Config.pm has 'privlibexp' etc. where config.h
                           # has 'privlib_exp' etc.
  # Fixup differences between Configure vars and config.h manifests
  # This isn't comprehensize; we fix 'em as we need 'em.
  $token = 'castneg'   if $token eq 'castnegfloat';
  $token = 'dlsymun'   if $token eq 'dlsym_needs_underscore';
  $token = 'stdstdio'  if $token eq 'use_stdio_ptr';
  $token = 'stdiobase'  if $token eq 'use_stdio_base';
  $val =~ s%/\*.*\*/\s*%%g;  $val =~ s/\s*$//;  # strip off trailing comment
d276 15
a290 4
  if ($val) { print OUT "$token=\'$val\'\n"; }
  else {
    $token = "d_$token" unless $token =~ /^i_/;
    print OUT "$token='$state'\n";
d294 4
d299 5
a303 6
while (<DATA>) {
  next if /^\s*#/ or /^\s*$/;
  s/#.*$//;  s/\s*$//;
  ($key,$val) = split('=',$_,2);
  print OUT "$key='$val'\n";
  eval "\$$key = '$val'";
a304 18
# Add in some of the architecture-dependent stuff which has to be consistent
print OUT "d_vms_do_sockets=",$dosock ? "'define'\n" : "'undef'\n";
print OUT "d_has_sockets=",$dosock ? "'define'\n" : "'undef'\n";
$archlib = &VMS::Filespec::vmspath($privlib);
$installarchlib = &VMS::Filespec::vmspath($installprivlib);
$sitearch = &VMS::Filespec::vmspath($sitelib);
$archlib =~ s#\]#.VMS_$archsufx\]#;
$sitearch =~ s#\]#.VMS_$archsufx\]#;
print OUT "oldarchlib='$archlib'\n";
print OUT "oldarchlibexp='$archlib'\n";
($vers = $]) =~ tr/./_/;
$archlib =~ s#\]#.$vers\]#;
$installarchlib =~ s#\]#.VMS_$archsufx.$vers\]#;
print OUT "archlib='$archlib'\n";
print OUT "archlibexp='$archlib'\n";
print OUT "installarchlib='$installarchlib'\n";
print OUT "sitearch='$sitearch'\n";
print OUT "sitearchexp='$sitearch'\n";
d329 2
a330 2
# simple pager support for perldoc
if    (`most` =~ /IVVERB/) {
a337 33
__END__

# This list is incomplete in comparison to what ends up in config.sh, but
# should contain the essentials.  Some of these definitions reflect
# options chosen when building perl or site-specific data; these should
# be hand-edited appropriately.  Someday, perhaps, we'll get this automated.

# The definitions in this block are constant across most systems, and
# should only rarely need to be changed.
ccdlflags=
cccdlflags=
usedl=true
dlobj=dl_vms.obj
dlsrc=dl_vms.c
so=exe
dlext=exe
libpth=/sys$share /sys$library
usevfork=false
castflags=0
signal_t=void
timetype=long
builddir=perl_root:[000000]
prefix=perl_root
installprivlib=perl_root:[lib]     # The *lib constants should match the
privlib=perl_root:[lib]            # equivalent *(?:ARCH)LIB_EXP constants
sitelib=perl_root:[lib.site_perl]  # in config.h
installbin=perl_root:[000000]
installman1dir=perl_root:[man.man1]
installman3dir=perl_root:[man.man3]
man1ext=rno
man3ext=rno
binexp=perl_root:[000000]  # should be same as installbin
useposix=false
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d9 1
a9 1
# Rev. 16-Feb-1998  Charles Bailey  bailey@@newman.upenn.edu
a11 10
#==== Locations of installed Perl components
$prefix='perl_root';
$builddir="$prefix:[000000]";
$installbin="$prefix:[000000]";
$installscript="$prefix:[000000]";
$installman1dir="$prefix:[man.man1]";
$installman3dir="$prefix:[man.man3]";
$installprivlib="$prefix:[lib]";
$installsitelib="$prefix:[lib.site_perl]";

a18 1
    chomp;
a39 9
$cf_by = (getpwuid($<))[0];
$archsufx = `Write Sys\$Output F\$GetSyi("HW_MODEL")` > 1024 ? 'AXP' : 'VAX';
($vers = $]) =~ tr/./_/;
$installarchlib = VMS::Filespec::vmspath($installprivlib);
$installarchlib =~ s#\]#.VMS_$archsufx.$vers\]#;
$installsitearch = VMS::Filespec::vmspath($installsitelib);
$installsitearch =~ s#\]#.VMS_$archsufx\]#;
($osvers = `Write Sys\$Output F\$GetSyi("VERSION")`) =~ s/^V?(\S+)\s*\n?$/$1/;

a49 5
cf_by='$cf_by'
ccdlflags='undef'
cccdlflags='undef'
mab='undef'
libpth='/sys\$share /sys\$library'
d52 2
a53 2
ranlib='undef'
ar='undef'
d56 4
a59 2
hintfile='undef'
useshrplib='define'
a60 1
usevfork='true'
a61 22
dlsrc='dl_vms.c'
binexp='$installbin'
man1ext='rno'
man3ext='rno'
arch='VMS_$archsufx'
archname='VMS_$archsufx'
bincompat3='undef'
d_bincompat3='undef'
osvers='$osvers'
prefix='$prefix'
builddir='$builddir'
installbin='$installbin'
installscript='$installscript'
installman1dir='$installman1dir'
installman3dir='$installman3dir'
installprivlib='$installprivlib'
installarchlib='$installarchlib'
installsitelib='$installsitelib'
installsitearch='$installsitearch'
path_sep='|'
startperl='\$ perl 'f\$env("procedure")' 'p1' 'p2' 'p3' 'p4' 'p5' 'p6' 'p7' 'p8' !
\$ exit++ + ++\$status != 0 and \$exit = \$status = undef;'
d64 18
d98 1
a98 1
    elsif (`$val/NoObject/NoList _nla0:/Version` =~ /GNU C version (\S+)/) {
a100 1
      print OUT "gccversion='$1'\n";
d103 1
a103 3
           # Check exit status too, in case message is turned off
           ( `$val/NoObject/NoList /prefix=all _nla0:` =~ /IVQUAL/ ||
              $? == 0x38240 )) {
a119 13
    $debug = $optimize = '';
    while ( ($qual) = $ccflags =~ m|(/(No)?Deb[^/]*)|i ) {
      $debug = $qual;
      $ccflags =~ s/$qual//;
    }
    while ( ($qual) = $ccflags =~ m|(/(No)?Opt[^/]*)|i ) {
      $optimize = $qual;
      $ccflags =~ s/$qual//;
    }
    $usethreads = ($ccflags =~ m!/DEF[^/]+USE_THREADS!i and
                   $ccflags !~ m!/UND[^/]+USE_THREADS!i);
    print OUT "usethreads='",($usethreads ? 'define' : 'undef'),"'\n";;
    $optimize = "$debug$optimize";
a120 1
    print OUT "optimize='$optimize'\n";
a122 68
    print OUT "d_vms_do_sockets=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "d_socket=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "d_sockpair=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "d_gethent=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "d_sethent=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "d_select=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "i_netdb=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "i_niin=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "i_neterrno=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "d_gethbyname=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "d_gethbyaddr=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "d_getpbyname=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "d_getpbynumber=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "d_getsbyname=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "d_getsbyport=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "d_endhent=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "d_getpent=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "d_setpent=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "d_endpent=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "d_getsent=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "d_setsent=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "d_endsent=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "netdb_name_type=",$dosock ? "'char *'\n" : "'undef'\n";
    print OUT "netdb_host_type=",$dosock ? "'char *'\n" : "'undef'\n";
    print OUT "netdb_hlen_type=",$dosock ? "'int'\n" : "'undef'\n";
    print OUT "d_gethostprotos=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "d_getnetprotos=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "d_getservprotos=",$dosock ? "'define'\n" : "'undef'\n";
    print OUT "d_getprotoprotos=",$dosock ? "'define'\n" : "'undef'\n";

    if ($dosock and $cctype eq 'decc' and $ccflags =~ /DECCRTL_SOCKETS/) {
      print OUT "selecttype='fd_set'\n";
      print OUT "d_getnbyaddr='define'\n";
      print OUT "d_getnbyname='define'\n";
      print OUT "d_getnent='define'\n";
      print OUT "d_setnent='define'\n";
      print OUT "d_endnent='define'\n";
      print OUT "netdb_net_type='long'\n";
    }
    else {
      print OUT "selecttype='int'\n";
      print OUT "d_getnybname='undef'\n";
      print OUT "d_getnybaddr='undef'\n";
      print OUT "d_getnent='undef'\n";
      print OUT "d_setnent='undef'\n";
      print OUT "d_endnent='undef'\n";
      print OUT "netdb_net_type='undef'\n";
    }

    if ($cctype eq 'decc') {
      $rtlhas  = 'define';
      print OUT "useposix='true'\n";
      ($ccver,$vmsver) = `$cc/VERSION` =~ /V(\S+) on .*V(\S+)$/;
      # Best guess; the may be wrong on systems which have separately
      # installed the new CRTL.
      if ($ccver >= 5.2 and $vmsver >= 7) { $rtlnew = 'define'; }
      else                                { $rtlnew = 'undef';  }
    }
    else { $rtlhas = $rtlnew = 'undef';  print OUT "useposix='false'\n"; }
    foreach (qw[ d_stdstdio d_stdio_ptr_lval d_stdio_cnt_lval d_stdiobase
                 d_locconv d_setlocale i_locale d_mbstowcs d_mbtowc
                 d_wcstombs d_wctomb d_mblen d_mktime d_strcoll d_strxfrm ]) {
      print OUT "$_='$rtlhas'\n";
    }
    foreach (qw[ d_gettimeod d_uname d_truncate d_wait4 d_index
                 d_pathconf d_fpathconf d_sysconf d_sigsetjmp ]) {
      print OUT "$_='$rtlnew'\n";
    }
d125 1
a125 7
  elsif ($key eq 'exe_ext') { 
    my($nodot) = $val;
    $nodot =~ s!\.!!;
    print OUT "so='$nodot'\ndlext='$nodot'\n";
  }
  elsif ($key eq 'obj_ext') { print OUT "dlobj='dl_vms$val'\n";     }
  print OUT "$key='$val'\n";
a154 27
# Before we read the C header file, find out what config.sh constants are
# equivalent to the C preprocessor macros
if (open(SH,"${outdir}config_h.SH")) {
  while (<SH>) {
    next unless m%^#(?!if).*\$%;
    s/^#//; s!(.*?)\s*/\*.*!$1!;
    my(@@words) = split;
    $words[1] =~ s/\(.*//;  # Clip off args from macro
    # Did we use a shell variable for the preprocessor directive?
    if ($words[0] =~ m!^\$(\w+)!) { $pp_vars{$words[1]} = $1; }
    if (@@words > 2) {  # We may also have a shell var in the value
      shift @@words;              #  Discard preprocessor directive
      my($token) = shift @@words; #  and keep constant name
      my($word);
      foreach $word (@@words) {
        next unless $word =~ m!\$(\w+)!;
        $val_vars{$token} = $1;
        last;
      }
    }
  }
  close SH;
}
else { warn "Couldn't read ${outdir}config_h.SH: $!\n"; }
$pp_vars{UNLINK_ALL_VERSIONS} = 'd_unlink_all_versions';  # VMS_specific

# OK, now read the C header file, and retcon statements into config.sh
d168 2
a169 15
  next unless my ($blocked,$un,$token,$val) =
                 m%^(\/\*)?\s*\#\s*(un)?def\w*\s+([A-Za-z0-9]\w+)\S*\s*(.*)%;
  if (/config-skip/) {
    delete $pp_vars{$token} if exists $pp_vars{$token};
    delete $val_vars{$token} if exists $val_vars{$token};
    next;
  }
  $val =~ s!\s*/\*.*!!; # strip off trailing comment
  my($had_val); # Maybe a macro with args that we just #undefd or commented
  if (!length($val) and $val_vars{$token} and ($un || $blocked)) {
    print OUT "$val_vars{$token}=''\n" unless exists $done{$val_vars{$token}};
    $done{$val_vars{$token}}++;
    delete $val_vars{$token};
    $had_val = 1;
  }
d171 14
a184 9
  if ($pp_vars{$token}) {
    print OUT "$pp_vars{$token}='$state'\n" unless exists $done{$pp_vars{$token}};
    $done{$pp_vars{$token}}++;
    delete $pp_vars{$token};
  }
  elsif (not length $val and not $had_val) {
    # Wups -- should have been shell var for C preprocessor directive
    warn "Constant $token not found in config_h.SH\n";
    $token = lc $token;
a187 19
  next unless length $val;
  $val =~ s/^"//; $val =~ s/"$//;               # remove end quotes
  $val =~ s/","/ /g;                            # make signal list look nice
  # Library directory; convert to VMS syntax
  $val = VMS::Filespec::vmspath($val) if ($token =~ /EXP$/);
  if ($val_vars{$token}) {
    print OUT "$val_vars{$token}='$val'\n" unless exists $done{$val_vars{$token}};
    if ($val_vars{$token} =~ s/exp$//) {
      print OUT "$val_vars{$token}='$val'\n" unless exists $done{$val_vars{$token}};;
    }
    $done{$val_vars{$token}}++;
    delete $val_vars{$token};
  }
  elsif (!$pp_vars{$token}) {  # Haven't seen it previously, either
    warn "Constant $token not found in config_h.SH (val=|$val|)\n";
    $token = lc $token;
    print OUT "$token='$val'\n";
    if ($token =~ s/exp$//) {print OUT "$token='$val'\n";}
  }
a189 4
# Special case -- preprocessor manifest "VMS" is defined automatically
# on VMS systems, but is also used erroneously by the Perl build process
# as the manifest for the obsolete variable $d_eunice.
print OUT "d_eunice='undef'\n";  delete $pp_vars{VMS};
d191 6
a196 8
# XXX temporary -- USE_THREADS is currently on CC command line
delete $pp_vars{'USE_THREADS'};

foreach (sort keys %pp_vars) {
  warn "Didn't see $_ in $infile\n";
}
foreach (sort keys %val_vars) {
  warn "Didn't see $_ in $infile(val)\n";
d198 18
d240 2
a241 2
# simple pager support for perldoc                                             
if    (`most not..file` =~ /IVVERB/) {
d249 33
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d394 2
a395 8
    if    (/^#define PERL_VERSION\s+(\S+)/) {
      print OUT "PERL_VERSION='$1'\n";
      print OUT "PATCHLEVEL='$1'\n";	# XXX compat
    }
    elsif (/^#define PERL_SUBVERSION\s+(\S+)/) {
      print OUT "PERL_SUBVERSION='$1'\n";
      print OUT "SUBVERSION='$1'\n";	# XXX compat
    }
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@a231 2
    print OUT "d_stdio_ptr_lval_sets_cnt='undef'\n";
    print OUT "d_stdio_ptr_lval_nochange_cnt='undef'\n";
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d160 2
a161 2
    $usethreads = ($ccflags =~ m!/DEF[^/]+USE_5005THREADS!i and
                   $ccflags !~ m!/UND[^/]+USE_5005THREADS!i);
d370 2
a371 2
# XXX temporary -- USE_5005THREADS is currently on CC command line
delete $pp_vars{'USE_5005THREADS'};
@


1.1.1.6
log
@perl 5.8.8 import
@
text
@d143 1
a143 8
    print OUT "d_attribute_format='$d_attr'\n";
    # XXX The following attributes may be able to use $d_attr, too.
    print OUT "d_attribute_malloc='undef'\n";
    print OUT "d_attribute_nonnull='undef'\n";
    print OUT "d_attribute_noreturn='undef'\n";
    print OUT "d_attribute_pure='undef'\n";
    print OUT "d_attribute_unused='undef'\n";
    print OUT "d_attribute_warn_unused_result='undef'\n";
@


