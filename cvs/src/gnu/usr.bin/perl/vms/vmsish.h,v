head	1.14;
access;
symbols
	OPENBSD_6_0:1.13.0.10
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.4
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	PERL_5_20_2:1.1.1.12
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	PERL_5_20_1:1.1.1.12
	OPENBSD_5_6:1.12.0.4
	OPENBSD_5_6_BASE:1.12
	PERL_5_18_2:1.1.1.11
	PERL:1.1.1
	OPENBSD_5_5:1.11.0.6
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.2
	OPENBSD_5_4_BASE:1.11
	PERL_5_16_3:1.1.1.10
	OPENBSD_5_3:1.10.0.14
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.12
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.10
	OPENBSD_5_0:1.10.0.8
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.6
	OPENBSD_4_9_BASE:1.10
	PERL_5_12_2:1.1.1.9
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	PERL_5_10_1:1.1.1.9
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.8.0.10
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.7.0.10
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.8
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.6
	OPENBSD_3_7_BASE:1.7
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.14
date	2017.02.05.00.32.21;	author afresh1;	state Exp;
branches;
next	1.13;
commitid	cxJ08BvJA9Pt2PTM;

1.13
date	2014.11.17.20.57.08;	author afresh1;	state Exp;
branches;
next	1.12;
commitid	QP75iYx42Uo7mMxO;

1.12
date	2014.03.24.15.05.33;	author afresh1;	state Exp;
branches;
next	1.11;

1.11
date	2013.03.25.20.41.00;	author sthen;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.12.18.30.28;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.29.17.36.21;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.28.19.23.13;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.50;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.39;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.36.30;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.08.49;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.47;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.06.22;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.30;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.30;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.42.07;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.11.01;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.26.08;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.12;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.35;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.03.28.18.49.53;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.29.17.19.04;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.10.12.18.10.47;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2013.03.25.20.09.42;	author sthen;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2014.03.24.14.59.12;	author afresh1;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.11.17.20.53.20;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.14
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*    vmsish.h
 *
 *    VMS-specific C header file for perl5.
 *
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
 *    2002, 2003, 2004, 2005, 2006, 2007 by Charles Bailey and others.
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 *    Please see Changes*.* or the Perl Repository Browser for revision history.
 */

#ifndef __vmsish_h_included
#define __vmsish_h_included

#include <descrip.h> /* for dirent struct definitions */
#include <libdef.h>  /* status codes for various places */
#include <rmsdef.h>  /* at which errno and vaxc$errno are */
#include <ssdef.h>   /* explicitly set in the perl source code */
#include <stsdef.h>  /* bitmasks for exit status testing */

/* Suppress compiler warnings from DECC for VMS-specific extensions:
 * ADDRCONSTEXT,NEEDCONSTEXT: initialization of data with non-constant values
 *                            (e.g. pointer fields of descriptors)
 */
#ifdef __DECC
#  pragma message disable (ADDRCONSTEXT,NEEDCONSTEXT)
#endif
#ifdef __DECCXX
#  pragma message informational (INTSIGNCHANGE,CASTQUALTYP,ASSCOMMEA,NOCTOBUTCONREFM,MISSINGRETURN)
#endif

/* DEC's C compilers and gcc use incompatible definitions of _to(upp|low)er() */
#ifdef _toupper
#  undef _toupper
#endif
#define _toupper(c) (((c) < 'a' || (c) > 'z') ? (c) : (c) & ~040)
#ifdef _tolower
#  undef _tolower
#endif
#define _tolower(c) (((c) < 'A' || (c) > 'Z') ? (c) : (c) | 040)

/* Assorted things to look like Unix */
#include <processes.h> /* for vfork() */
#include <unixio.h>
#include <unixlib.h>
#include <file.h>  /* it's not <sys/file.h>, so don't use I_SYS_FILE */
#if (defined(__DECC) && defined(__DECC_VER) && __DECC_VER > 20000000) || defined(__DECCXX)
#  include <unistd.h> /* DECC has this; gcc doesn't */
#endif

#ifdef NO_PERL_TYPEDEFS /* a2p; we don't want Perl's special routines */
#  define DONT_MASK_RTL_CALLS
#endif

#include <namdef.h>

/* Set the maximum filespec size here as it is larger for EFS file
 * specifications.
 */
#ifndef VMS_MAXRSS
#ifdef NAML$C_MAXRSS
#define VMS_MAXRSS (NAML$C_MAXRSS+1)
#ifndef VMS_LONGNAME_SUPPORT
#define VMS_LONGNAME_SUPPORT 1
#endif /* VMS_LONGNAME_SUPPORT */
#endif /* NAML$C_MAXRSS */
#endif /* VMS_MAXRSS */

#ifndef VMS_MAXRSS
#define VMS_MAXRSS (NAM$C_MAXRSS + 1)
#endif

#ifndef MAXPATHLEN
#define MAXPATHLEN (VMS_MAXRSS - 1)
#endif


/* Note that we do, in fact, have this */
#define HAS_GETENV_SV
#define HAS_GETENV_LEN


#ifndef PERL_FOR_X2P

#ifndef DONT_MASK_RTL_CALLS
#  ifdef getenv
#    undef getenv
#  endif
  /* getenv used for regular logical names */
#  define getenv(v) Perl_my_getenv(aTHX_ v,TRUE)
#endif
#ifdef getenv_len
#  undef getenv_len
#endif
#define getenv_len(v,l) Perl_my_getenv_len(aTHX_ v,l,TRUE)

/* DECC introduces this routine in the RTL as of VMS 7.0; for now,
 * we'll use ours, since it gives us the full VMS exit status. */
#define waitpid my_waitpid

/* Don't redeclare standard RTL routines in Perl's header files;
 * VMS history or extensions makes some of the formal protoypes
 * differ from the common Unix forms.
 */
#define DONT_DECLARE_STD 1

/* Our own contribution to PerlShr's global symbols . . . */

#if !defined(PERL_IMPLICIT_CONTEXT)
#define opendir			Perl_opendir
#define rename			Perl_rename
#define seekdir			Perl_seekdir
#define readdir			Perl_readdir
#define readdir_r		Perl_readdir_r
#else
#define opendir(a)		Perl_opendir(aTHX_ a)
#define rename(a,b)		Perl_rename(aTHX_ a,b)
#define seekdir(a,b)		Perl_seekdir(aTHX_ a,b)
#define readdir(a)		Perl_readdir(aTHX_ a)
#define readdir_r(a,b,c)	Perl_readdir_r(aTHX_ a,b,c)
#endif
#define closedir(a)		Perl_closedir(a)
#define telldir(a)		Perl_telldir(a)
#define vmsreaddirversions(a,b)	Perl_vmsreaddirversions(a,b)

#define cando_by_name(a,b,c)		Perl_cando_by_name(aTHX_ a,b,c)
#define do_rmdir(a)			Perl_do_rmdir(aTHX_ a)
#define fileify_dirspec(a,b)		Perl_fileify_dirspec(aTHX_ a,b)
#define fileify_dirspec(a,b)		Perl_fileify_dirspec(aTHX_ a,b)
#define fileify_dirspec_ts(a,b)		Perl_fileify_dirspec_ts(aTHX_ a,b)
#define fileify_dirspec_ts(a,b)		Perl_fileify_dirspec_ts(aTHX_ a,b)
#define fileify_dirspec_utf8(a,b,c)	Perl_fileify_dirspec(aTHX_ a,b,utf8)
#define fileify_dirspec_utf8_ts(a,b,c)	Perl_fileify_dirspec_ts(aTHX_ a,b,utf8)
#define flex_fstat(a,b)			Perl_flex_fstat(aTHX_ a,b)
#define flex_lstat(a,b)			Perl_flex_lstat(aTHX_ a,b)
#define flex_stat(a,b)			Perl_flex_stat(aTHX_ a,b)
#define init_os_extras			Perl_init_os_extras
#define kill_file(a)			Perl_kill_file(aTHX_ a)
#define my_chdir(a)			Perl_my_chdir(aTHX_ a)
#define my_chmod(a,b)			Perl_my_chmod(aTHX_ a,b)
#define my_crypt(a,b)			Perl_my_crypt(aTHX_ a,b)
#define my_endpwent()			Perl_my_endpwent(aTHX)
#define my_fclose(a)			Perl_my_fclose(a)
#define my_fdopen(a,b)			Perl_my_fdopen(a,b)
#define my_flush(a)			Perl_my_flush(aTHX_ a)
#define my_fwrite(a,b,c,d)		Perl_my_fwrite(a,b,c,d)
#define my_fgetname(a,b)		Perl_my_fgetname(a,b)
#define my_gconvert(a,b,c,d)		Perl_my_gconvert(a,b,c,d)
#define my_getenv(a,b)			Perl_my_getenv(aTHX_ a,b)
#define my_getenv_len(a,b,c)		Perl_my_getenv_len(aTHX_ a,b,c)
#define my_getpwent()			Perl_my_getpwent(aTHX)
#define my_getpwnam(a)			Perl_my_getpwnam(aTHX_ a)
#define my_getpwuid(a)			Perl_my_getpwuid(aTHX_ a)
#define my_gmtime(a)			Perl_my_gmtime(aTHX_ a)
#define my_localtime(a)			Perl_my_localtime(aTHX_ a)
#define my_mkdir(a,b)			Perl_my_mkdir(aTHX_ a,b)
#ifdef HAS_SYMLINK
#  define my_symlink(a,b)		Perl_my_symlink(aTHX_ a,b)
#endif
#define my_time(a)			Perl_my_time(aTHX_ a)
#define my_tmpfile			Perl_my_tmpfile
#define my_trnlnm(a,b,c)		Perl_my_trnlnm(aTHX_ a,b,c)
#define my_utime(a,b)			Perl_my_utime(aTHX_ a,b)
#define my_vfork			Perl_my_vfork
#define my_waitpid(a,b,c)		Perl_my_waitpid(aTHX_ a,b,c)
#define pathify_dirspec(a,b)		Perl_pathify_dirspec(aTHX a,b)
#define pathify_dirspec_ts(a,b)		Perl_pathify_dirspec_ts(aTHX a,b)
#define pathify_dirspec_utf8(a,b,c)	Perl_pathify_dirspec_utf8(aTHX a,b,c)
#define pathify_dirspec_utf8_ts(a,b,c)	Perl_pathify_dirspec_utf8_ts(aTHX a,b,c)
#define prime_env_iter			Perl_prime_env_iter
#define rmscopy(a,b,c)			Perl_rmscopy(aTHX_ a,b,c)
#define rmsexpand(a,b,c,d)		Perl_rmsexpand_utf8(aTHX_ a,b,c,d,NULL,NULL)
#define rmsexpand_ts(a,b,c,d)		Perl_rmsexpand_utf8_ts(aTHX_ a,b,c,d,NULL,NULL)
#define rmsexpand_utf8(a,b,c,d,e,f)	Perl_rmsexpand_utf8(aTHX_ a,b,c,d,e,f)
#define rmsexpand_utf8_ts(a,b,c,d,e,f)	Perl_rmsexpand_utf8_ts(aTHX_ a,b,c,d,e,f)
#define tounixpath(a,b)			Perl_tounixpath_utf8(aTHX_ a,b,NULL)
#define tounixpath_ts(a,b)		Perl_tounixpath_utf8_ts(aTHX_ a,b,NULL)
#define tounixpath_utf8(a,b,c)		Perl_tounixpath_utf8(aTHX_ a,b,c)
#define tounixpath_utf8_ts(a,b,c)	Perl_tounixpath_utf8_ts(aTHX_ a,b,c)
#define tounixspec(a,b)			Perl_tounixspec_utf8(aTHX_ a,b,NULL)
#define tounixspec_ts(a,b)		Perl_tounixspec_utf8_ts(aTHX_ a,b,NULL)
#define tounixspec_utf8(a,b,c)		Perl_tounixspec_utf8(aTHX_ a,b,c)
#define tounixspec_utf8_ts(a,b,c)	Perl_tounixspec_utf8_ts(aTHX_ a,b,c)
#define tovmspath(a,b)			Perl_tovmspath_utf8(aTHX_ a,b,NULL)
#define tovmspath_ts(a,b)		Perl_tovmspath_utf8_ts(aTHX_ a,b,NULL)
#define tovmspath_utf8(a,b,c)		Perl_tovmspath_utf8(aTHX_ a,b,c)
#define tovmspath_utf8_ts(a,b,c)	Perl_tovmspath_utf8_ts(aTHX_ a,b,c)
#define tovmsspec(a,b)			Perl_tovmsspec_utf8(aTHX_ a,b,NULL)
#define tovmsspec_ts(a,b)		Perl_tovmsspec_utf8_ts(aTHX_ a,b)
#define tovmsspec_utf8(a,b,c)		Perl_tovmsspec_utf8(aTHX_ a,b,c)
#define tovmsspec_utf8_ts(a,b,c)	Perl_tovmsspec_utf8_ts(aTHX_ a,b,c)
#define trim_unixpath(a,b,c)		Perl_trim_unixpath(aTHX_ a,b,c)
#define vms_do_aexec(a,b,c)		Perl_vms_do_aexec(aTHX_ a,b,c)
#define vms_do_exec(a)			Perl_vms_do_exec(aTHX_ a)
#define vms_case_tolerant(a)		Perl_vms_case_tolerant(a)
#define vms_image_init(a,b)		Perl_vms_image_init(a,b)
#define vms_realname(a,b,c)		Perl_vms_realname(aTHX_ a,b,c)
#define vms_realpath(a,b,c)		Perl_vms_realpath(aTHX_ a,b,c)
#define vmssetenv(a,b,c)		Perl_vmssetenv(aTHX_ a,b,c)
#define vmstrnenv(a,b,c,d,e)		Perl_vmstrnenv(a,b,c,d,e)
#define vmssetuserlnm(a,b)		Perl_vmssetuserlnm(a,b)

/* Delete if at all possible, changing protections if necessary. */
#define unlink(a) kill_file(a)

/* 
 * Intercept calls to fork, so we know whether subsequent calls to
 * exec should be handled in VMSish or Unixish style.
 */
#define fork my_vfork
#ifndef DONT_MASK_RTL_CALLS     /* #defined in vms.c so we see real vfork */
#  ifdef vfork
#    undef vfork
#  endif
#  define vfork my_vfork
#endif

/*
 * Toss in a shim to tmpfile which creates a plain temp file if the
 * RMS tmp mechanism won't work (e.g. if someone is relying on ACLs
 * from a specific directory to permit creation of files).
 */
#ifndef DONT_MASK_RTL_CALLS
#  define tmpfile Perl_my_tmpfile
#endif
#endif


/* BIG_TIME:
 *	This symbol is defined if Time_t is an unsigned type on this system.
 */
#define BIG_TIME

/* ACME_MESS:
 *	This symbol, if defined, indicates that error messages should be 
 *	should be generated in a format that allows the use of the Acme
 *	GUI/editor's autofind feature.
 */
#undef ACME_MESS	/**/

/* ALTERNATE_SHEBANG:
 *	This symbol, if defined, contains a "magic" string which may be used
 *	as the first line of a Perl program designed to be executed directly
 *	by name, instead of the standard Unix #!.  If ALTERNATE_SHEBANG
 *	begins with a character other then #, then Perl will only treat
 *	it as a command line if if finds the string "perl" in the first
 *	word; otherwise it's treated as the first line of code in the script.
 *	(IOW, Perl won't hand off to another interpreter via an alternate
 *	shebang sequence that might be legal Perl code.)
 */
#define ALTERNATE_SHEBANG "$"

/* Macros to set errno using the VAX thread-safe calls, if present */
#if (defined(__DECC) || defined(__DECCXX)) && !defined(__ALPHA)
#  define set_errno(v)      (cma$tis_errno_set_value(v))
   void cma$tis_errno_set_value(int __value);  /* missing in some errno.h */
#  define set_vaxc_errno(v) (vaxc$errno = (v))
#else
#  define set_errno(v)      (errno = (v))
#  define set_vaxc_errno(v) (vaxc$errno = (v))
#endif

/* Support for 'vmsish' behaviors enabled with C<use vmsish> pragma */

#define COMPLEX_STATUS	1	/* We track both "POSIX" and VMS values */

#define HINT_M_VMSISH_STATUS	0x40000000 /* system, $? return VMS status */
#define HINT_M_VMSISH_TIME	0x80000000 /* times are local, not UTC */

#ifdef PERL_IMPLICIT_CONTEXT
#  define TEST_VMSISH(h)	(my_perl && PL_curcop && (PL_curcop->cop_hints & (h)))
#else
#  define TEST_VMSISH(h)	(PL_curcop && (PL_curcop->cop_hints & (h)))
#endif
#define VMSISH_STATUS	TEST_VMSISH(HINT_M_VMSISH_STATUS)
#define VMSISH_TIME	TEST_VMSISH(HINT_M_VMSISH_TIME)

/* VMS-specific data storage */

#define HAVE_INTERP_INTERN
struct interp_intern {
    int    hushed;
    int	   posix_exit;
    double inv_rand_max;
};
#define VMSISH_HUSHED     (PL_sys_intern.hushed)
#define MY_INV_RAND_MAX   (PL_sys_intern.inv_rand_max)
#define MY_POSIX_EXIT	(PL_sys_intern.posix_exit)

/* Flags for vmstrnenv() */
#define PERL__TRNENV_SECURE 0x01
#define PERL__TRNENV_JOIN_SEARCHLIST 0x02

/* Handy way to vet calls to VMS system services and RTL routines. */
#define _ckvmssts(call) STMT_START { unsigned long int __ckvms_sts; \
  if (!((__ckvms_sts=(call))&1)) { \
  set_errno(EVMSERR); set_vaxc_errno(__ckvms_sts); \
  Perl_croak(aTHX_ "Fatal VMS error (status=%d) at %s, line %d", \
  __ckvms_sts,__FILE__,__LINE__); } } STMT_END

/* Same thing, but don't call back to Perl's croak(); useful for errors
 * occurring during startup, before Perl's state is initialized */
#define _ckvmssts_noperl(call) STMT_START { unsigned long int __ckvms_sts; \
  if (!((__ckvms_sts=(call))&1)) { \
  set_errno(EVMSERR); set_vaxc_errno(__ckvms_sts); \
  (void)fprintf(stderr,"Fatal VMS error (status=%d) at %s, line %d", \
  __ckvms_sts,__FILE__,__LINE__); (void)lib$signal(__ckvms_sts); } } STMT_END

#ifdef VMS_DO_SOCKETS
#define PERL_SOCK_SYSREAD_IS_RECV
#define PERL_SOCK_SYSWRITE_IS_SEND
#endif

#define BIT_BUCKET "/dev/null"
#define PERL_SYS_INIT_BODY(c,v)	MALLOC_CHECK_TAINT2(*c,*v) vms_image_init((c),(v)); PERLIO_INIT; MALLOC_INIT
#define PERL_SYS_TERM_BODY()    HINTS_REFCNT_TERM; OP_REFCNT_TERM;      \
                                PERLIO_TERM; MALLOC_TERM; LOCALE_TERM
#define dXSUB_SYS
#define HAS_KILL
#define HAS_WAIT

#ifndef PERL_CORE
#  define PERL_FS_VER_FMT	"%d_%d_%d"
#endif
#define PERL_FS_VERSION		STRINGIFY(PERL_REVISION) "_" \
				STRINGIFY(PERL_VERSION) "_" \
				STRINGIFY(PERL_SUBVERSION)
/* Temporary; we need to add support for this to Configure.Com */
#ifdef PERL_INC_VERSION_LIST
#  undef PERL_INC_VERSION_LIST
#endif

/* VMS:
 *	This symbol, if defined, indicates that the program is running under
 *	VMS.  It's a symbol automagically defined by all VMS C compilers I've seen.
 * Just in case, however . . . */
/* Note that code really should be using __VMS to comply with ANSI */
#ifndef VMS
#define VMS		/**/
#endif

/* HAS_IOCTL:
 *	This symbol, if defined, indicates that the ioctl() routine is
 *	available to set I/O characteristics
 */
#define	HAS_IOCTL		/**/
 
/* HAS_UTIME:
 *	This symbol, if defined, indicates that the routine utime() is
 *	available to update the access and modification times of files.
 */
#define HAS_UTIME		/**/

/* HAS_GROUP
 *	This symbol, if defined, indicates that the getgrnam() and
 *	getgrgid() routines are available to get group entries.
 *	The getgrent() has a separate definition, HAS_GETGRENT.
 */
#define HAS_GROUP		/**/

/* HAS_PASSWD
 *	This symbol, if defined, indicates that the getpwnam() and
 *	getpwuid() routines are available to get password entries.
 *	The getpwent() has a separate definition, HAS_GETPWENT.
 */
#define HAS_PASSWD		/**/

#define HAS_KILL
#define HAS_WAIT
  
/* USEMYBINMODE
 *	This symbol, if defined, indicates that the program should
 *	use the routine my_binmode(FILE *fp, char iotype, int mode) to insure
 *	that a file is in "binary" mode -- that is, that no translation
 *	of bytes occurs on read or write operations.
 */
#undef USEMYBINMODE

/* Stat_t:
 *	This symbol holds the type used to declare buffers for information
 *	returned by stat().  It's usually just struct stat.  It may be necessary
 *	to include <sys/stat.h> and <sys/types.h> to get any typedef'ed
 *	information.
 */
/* VMS:
 * We need this typedef to point to the new type even if DONT_MASK_RTL_CALLS
 * is in effect, since Perl's thread.h embeds one of these structs in its
 * thread data struct, and our struct mystat is a different size from the
 * regular struct stat (cf. note above about having to pad struct to work
 * around bug in compiler.)
 * It's OK to pass one of these to the RTL's stat(), though, since the
 * fields it fills are the same in each struct.
 */
#define Stat_t struct mystat

/* USE_STAT_RDEV:
*	This symbol is defined if this system has a stat structure declaring
*	st_rdev
*	VMS: Field exists in POSIXish version of struct stat(), but is not used.
*
*  No definition of what value an operating system or file system should
*  put in the st_rdev field has been found by me so far.  Examination of
*  LINUX source code indicates that the value is both very platform and
*  file system specific, with many filesystems just putting 1 or 0 in it.
*  J. Malmberg.
*/
#undef USE_STAT_RDEV		/**/

/*
 * fwrite1() should be a routine with the same calling sequence as fwrite(),
 * but which outputs all of the bytes requested as a single stream (unlike
 * fwrite() itself, which on some systems outputs several distinct records
 * if the number_of_items parameter is >1).
 */
#define fwrite1 my_fwrite


#ifndef DONT_MASK_RTL_CALLS
#  define fwrite my_fwrite     /* for PerlSIO_fwrite */
#  define fdopen my_fdopen
#  define fclose my_fclose
#  define fgetname(a, b) my_fgetname(a, b)
#ifdef HAS_SYMLINK
#  define symlink my_symlink
#endif
#endif


/* By default, flush data all the way to disk, not just to RMS buffers */
#define Fflush(fp) my_flush(fp)

/* Use our own rmdir() */
#ifndef DONT_MASK_RTL_CALLS
#define rmdir(name) do_rmdir(name)
#endif

/* Assorted fiddling with sigs . . . */
# include <signal.h>
#define ABORT() abort()

#ifdef I_UTIME
#include <utime.h>
#else
/* Used with our my_utime() routine in vms.c */
struct utimbuf {
  time_t actime;
  time_t modtime;
};
#endif
#ifndef DONT_MASK_RTL_CALLS
#define utime my_utime
#endif

/* tbuffer_t was replaced with struct tms in v7.0.  We no longer support
 * systems prior to v7.0, but there could be old XS code out there that
 * references tbuffer_t, so provide a compatibility macro.
 */

#define tbuffer_t struct tms

/* Substitute our own routines for gmtime(), localtime(), and time(),
 * which allow us to implement the vmsish 'time' pragma, and work
 * around absence of system-level UTC support on old versions of VMS.
 */
#define gmtime(t) my_gmtime(t)
#define localtime(t) my_localtime(t)
#define time(t) my_time(t)

/*
 * The C RTL's sigaction fails to check for invalid signal numbers so we 
 * help it out a bit.
 */
#ifndef DONT_MASK_RTL_CALLS
#    define sigaction(a,b,c) Perl_my_sigaction(aTHX_ a,b,c)
#endif
#ifdef KILL_BY_SIGPRC
#  define kill  Perl_my_kill
#endif
# define killpg  Perl_my_killpg


/* VMS doesn't use a real sys_nerr, but we need this when scanning for error
 * messages in text strings . . .
 */

#define sys_nerr EVMSERR  /* EVMSERR is as high as we can go. */

/* Look up new %ENV values on the fly */
#define DYNAMIC_ENV_FETCH 1
  /* Special getenv function for retrieving %ENV elements. */
#define ENVgetenv(v) my_getenv(v,FALSE)
#define ENVgetenv_len(v,l) my_getenv_len(v,l,FALSE)


/* Ditto for sys$hash_password() . . . */
#define crypt(a,b)  Perl_my_crypt(aTHX_ a,b)

/* Tweak arg to mkdir & chdir first, so we can tolerate trailing /. */
#define Mkdir(dir,mode) Perl_my_mkdir(aTHX_ (dir),(mode))
#define Chdir(dir) my_chdir((dir))
#ifndef DONT_MASK_RTL_CALLS
#define chmod(file_spec, mode) my_chmod((file_spec), (mode))
#endif

/* Use our own stat() clones, which handle Unix-style directory names */
#define Stat(name,bufptr) flex_stat(name,bufptr)
#define Fstat(fd,bufptr) Perl_flex_fstat(aTHX_ fd,bufptr)
#ifndef DONT_MASK_RTL_CALLS
#define lstat(name, bufptr) flex_lstat(name, bufptr)
#endif

/* Setup for the dirent routines:
 * opendir(), closedir(), readdir(), seekdir(), telldir(), and
 * vmsreaddirversions(), and preprocessor stuff on which these depend:
 *    Written by Rich $alz, <rsalz@@bbn.com> in August, 1990.
 *
 */

/* Flags for the _dirdesc structure */
#define PERL_VMSDIR_M_VERSIONS		0x02 /* Want VMS versions */
#define PERL_VMSDIR_M_UNIXSPECS		0x04 /* Want UNIX specifications */


    /* Data structure returned by READDIR(). */
struct dirent {
    char	d_name[256];		/* File name		*/
    int		d_namlen;		/* Length of d_name */
    int		vms_verscount;		/* Number of versions	*/
    int		vms_versions[20];	/* Version numbers	*/
};

    /* Handle returned by opendir(), used by the other routines.  You
     * are not supposed to care what's inside this structure. */
typedef struct _dirdesc {
    long			context;
    int				flags;
    unsigned long int           count;
    char			*pattern;
    struct dirent		entry;
    struct dsc$descriptor_s	pat;
    void			*mutex;
} DIR;


#define rewinddir(dirp)		seekdir((dirp), 0)

/* used for our emulation of getpw* */
struct passwd {
        char    *pw_name;    /* Username */
        char    *pw_passwd;
        Uid_t   pw_uid;      /* UIC member number */
        Gid_t   pw_gid;      /* UIC group  number */
        char    *pw_comment; /* Default device/directory (Unix-style) */
        char    *pw_gecos;   /* Owner */
        char    *pw_dir;     /* Default device/directory (VMS-style) */
        char    *pw_shell;   /* Default CLI name (eg. DCL) */
};
#define pw_unixdir pw_comment  /* Default device/directory (Unix-style) */
#define getpwnam my_getpwnam
#define getpwuid my_getpwuid
#define getpwent my_getpwent
#define endpwent my_endpwent
#define setpwent my_endpwent

/* Our own stat_t substitute, since we play with st_dev and st_ino -
 * we want atomic types so Unix-bound code which compares these fields
 * for two files will work most of the time under VMS.
 * N.B. 1. The st_ino hack assumes that sizeof(unsigned short[3]) ==
 * sizeof(unsigned) + sizeof(unsigned short).  We can't use a union type
 * to map the unsigned int we want and the unsigned short[3] the CRTL
 * returns into the same member, since gcc has different ideas than DECC
 * and VAXC about sizing union types.
 * N.B. 2. The routine cando() in vms.c assumes that &stat.st_ino is the
 * address of a FID.
 */
/* First, grab the system types, so we don't clobber them later */
#include <stat.h>
/* Since we've got to match the size of the CRTL's stat_t, we need
 * to mimic DECC's alignment settings.
 *
 * The simplest thing is to just put a wrapper around the stat structure
 * supplied by the CRTL and use #defines to redirect references to the
 * members to the real names.
 */

#if defined(__DECC) || defined(__DECCXX)
#  pragma __member_alignment __save
#  pragma member_alignment
#endif

typedef unsigned mydev_t;
#ifndef _LARGEFILE
typedef unsigned myino_t;
#else
typedef __ino64_t myino_t;
#endif

struct mystat
{
    struct stat crtl_stat;
    myino_t st_ino;
#ifndef _LARGEFILE
    unsigned rvn; /* FID (num,seq,rvn) + pad */
#endif
    mydev_t st_dev;
    char st_devnam[256]; /* Cache the (short) VMS name */
};

#define st_mode crtl_stat.st_mode
#define st_nlink crtl_stat.st_nlink
#define st_uid crtl_stat.st_uid
#define st_gid crtl_stat.st_gid
#define st_rdev crtl_stat.st_rdev
#define st_size crtl_stat.st_size
#define st_atime crtl_stat.st_atime
#define st_mtime crtl_stat.st_mtime
#define st_ctime crtl_stat.st_ctime
#define st_fab_rfm crtl_stat.st_fab_rfm
#define st_fab_rat crtl_stat.st_fab_rat
#define st_fab_fsz crtl_stat.st_fab_fsz
#define st_fab_mrs crtl_stat.st_fab_mrs

#ifdef _USE_STD_STAT
#define VMS_INO_T_COMPARE(__a, __b) (__a != __b)
#define VMS_INO_T_COPY(__a, __b) __a = __b
#else
#define VMS_INO_T_COMPARE(__a, __b) memcmp(&__a, &__b, 6)
#define VMS_INO_T_COPY(__a, __b) memcpy(&__a, &__b, 6)
#endif

#if defined(__DECC) || defined(__DECCXX)
#  pragma __member_alignment __restore
#endif

#ifndef DONT_MASK_RTL_CALLS  /* defined for vms.c so we can see RTL calls */
#  ifdef stat
#    undef stat
#  endif
#  define stat mystat
#  define dev_t mydev_t
#  define ino_t myino_t
#endif
/* Cons up a 'delete' bit for testing access */
#define S_IDUSR (S_IWUSR | S_IXUSR)
#define S_IDGRP (S_IWGRP | S_IXGRP)
#define S_IDOTH (S_IWOTH | S_IXOTH)


#ifndef PERL_FOR_X2P
/* Prototypes for functions unique to vms.c.  Don't include replacements
 * for routines in the mainline source files excluded by #ifndef VMS;
 * their prototypes are already in proto.h.
 */

#ifdef __cplusplus
extern "C" {
#endif

void	prime_env_iter (void);
void	init_os_extras (void);
int	Perl_vms_status_to_unix(int vms_status, int child_flag);
int	Perl_unix_status_to_vms(int unix_status);
int	Perl_vmstrnenv (const char *, char *, unsigned long int, struct dsc$descriptor_s **, unsigned long int);
char *	Perl_vms_realpath (pTHX_ const char *, char *, int *);
char *	Perl_my_getenv (pTHX_ const char *, bool);
int	Perl_my_trnlnm (pTHX_ const char *, char *, unsigned long int);
char *	Perl_tounixspec (pTHX_ const char *, char *);
char *	Perl_tounixspec_ts (pTHX_ const char *, char *);
char *	Perl_tounixspec_utf8 (pTHX_ const char *, char *, int *);
char *	Perl_tounixspec_utf8_ts (pTHX_ const char *, char *, int *);
char *	Perl_tovmsspec (pTHX_ const char *, char *);
char *	Perl_tovmsspec_ts (pTHX_ const char *, char *);
char *	Perl_tovmsspec_utf8 (pTHX_ const char *, char *, int *);
char *	Perl_tovmsspec_utf8_ts (pTHX_ const char *, char *, int *);
char *	Perl_tounixpath (pTHX_ const char *, char *);
char *	Perl_tounixpath_ts (pTHX_ const char *, char *);
char *	Perl_tounixpath_utf8 (pTHX_ const char *, char *, int *);
char *	Perl_tounixpath_utf8_ts (pTHX_ const char *, char *, int *);
char *	Perl_tovmspath (pTHX_ const char *, char *);
char *	Perl_tovmspath_ts (pTHX_ const char *, char *);
char *	Perl_tovmspath_utf8 (pTHX_ const char *, char *, int *);
char *	Perl_tovmspath_utf8_ts (pTHX_ const char *, char *, int *);
int	Perl_do_rmdir (pTHX_ const char *);
char *	Perl_fileify_dirspec (pTHX_ const char *, char *);
char *	Perl_fileify_dirspec_ts (pTHX_ const char *, char *);
char *	Perl_fileify_dirspec_utf8 (pTHX_ const char *, char *, int *);
char *	Perl_fileify_dirspec_utf8_ts (pTHX_ const char *, char *, int *);
char *	Perl_pathify_dirspec (pTHX_ const char *, char *);
char *	Perl_pathify_dirspec_ts (pTHX_ const char *, char *);
char *	Perl_pathify_dirspec_utf8 (pTHX_ const char *, char *, int *);
char *	Perl_pathify_dirspec_utf8_ts (pTHX_ const char *, char *, int *);
char *	Perl_rmsexpand (pTHX_ const char *, char *, const char *, unsigned);
char *	Perl_rmsexpand_ts (pTHX_ const char *, char *, const char *, unsigned);
char *	Perl_rmsexpand_utf8 (pTHX_ const char *, char *, const char *, unsigned, int *, int *);
char *	Perl_rmsexpand_utf8_ts (pTHX_ const char *, char *, const char *, unsigned, int *, int *);
int	Perl_trim_unixpath (pTHX_ char *, const char*, int);
DIR * Perl_opendir (pTHX_ const char *);
int	Perl_rename (pTHX_ const char *, const char *);
int	Perl_rmscopy (pTHX_ const char *, const char *, int);
int	Perl_my_mkdir (pTHX_ const char *, Mode_t);
bool	Perl_vms_do_aexec (pTHX_ SV *, SV **, SV **);
int	Perl_vms_case_tolerant(void);
char *	Perl_my_getenv_len (pTHX_ const char *, unsigned long *, bool);
int	Perl_vmssetenv (pTHX_ const char *, const char *, struct dsc$descriptor_s **);
void	Perl_vmssetuserlnm(const char *name, const char *eqv);
char *	Perl_my_crypt (pTHX_ const char *, const char *);
Pid_t	Perl_my_waitpid (pTHX_ Pid_t, int *, int);
char *	my_gconvert (double, int, int, char *);
int	Perl_kill_file (pTHX_ const char *);
int	Perl_my_chdir (pTHX_ const char *);
int	Perl_my_chmod(pTHX_ const char *, mode_t);
FILE *	Perl_my_tmpfile (void);
int	Perl_my_sigaction (pTHX_ int, const struct sigaction*, struct sigaction*);
#ifdef KILL_BY_SIGPRC
unsigned int	Perl_sig_to_vmscondition (int);
int	Perl_my_kill (int, int);
int	Perl_my_killpg (int, int);
void	Perl_csighandler_init (void);
#endif
int	Perl_my_utime (pTHX_ const char *, const struct utimbuf *);
void	Perl_vms_image_init (int *, char ***);
struct dirent *	Perl_readdir (pTHX_ DIR *);
int	Perl_readdir_r(pTHX_ DIR *, struct dirent *, struct dirent **);
long	Perl_telldir (DIR *);
void	Perl_seekdir (pTHX_ DIR *, long);
void	Perl_closedir (DIR *);
void	vmsreaddirversions (DIR *, int);
struct tm *	Perl_my_gmtime (pTHX_ const time_t *);
struct tm *	Perl_my_localtime (pTHX_ const time_t *);
time_t	Perl_my_time (pTHX_ time_t *);
I32	Perl_cando_by_name (pTHX_ I32, bool, const char *);
int	Perl_flex_fstat (pTHX_ int, Stat_t *);
int	Perl_flex_lstat (pTHX_ const char *, Stat_t *);
int	Perl_flex_stat (pTHX_ const char *, Stat_t *);
int	my_vfork (void);
bool	Perl_vms_do_exec (pTHX_ const char *);
FILE *  my_fdopen (int, const char *);
int     my_fclose (FILE *);
int     my_fwrite (const void *, size_t, size_t, FILE *);
char *  Perl_my_fgetname (FILE *fp, char *buf);
#ifdef HAS_SYMLINK
int     Perl_my_symlink(pTHX_ const char *path1, const char *path2);
#endif
int	Perl_my_flush (pTHX_ FILE *);
struct passwd *	Perl_my_getpwnam (pTHX_ const char *name);
struct passwd *	Perl_my_getpwuid (pTHX_ Uid_t uid);
void	Perl_my_endpwent (pTHX);

/*
 * The following prototypes are in math.h but for some reason they
 * are ifdefed out for C++.  So we have to repeat them here in order
 * to build the POSIX extension.
 */

#ifdef __DECCXX

double exp2(double __x);
double fdim(double __x, double __y);
double fma(double __x, double __y, double __z);
double fmax(double __x, double __y);
double fmin(double __x, double __y);
double nexttoward(double __x, long double __y);
double remainder(double __x, double __y);
double remquo(double __x, double __y, int *__quo);
double tgamma(double __x);
float exp2f(float __x);
float fdimf(float __x, float __y);
float fmaf(float __x, float __y, float __z);
float fmaxf(float __x, float __y);
float fminf(float __x, float __y);
float nexttowardf(float __x, long double __y);
float remainderf(float __x, float __y);
float remquof(float __x, float __y, int *__quo);
float tgammaf(float __x);
long double exp2l(long double __x);
long double fdiml(long double __x, long double __y);
long double fmal(long double __x, long double __y, long double __z);
long double fmaxl(long double __x, long double __y);
long double fminl(long double __x, long double __y);
long double nexttowardl(long double __x, long double __y);
long double remainderl(long double __x, long double __y);
long double remquol(long double __x, long double __y, int *__quo);
long double tgammal(long double __x);
int ilogb(double __x);
int ilogbf(float __x);
int ilogbl(long double __x);
long int lrint(double __x);
long int lrintf(float __x);
long int lrintl(long double __x);
long int lround(double __x);
long int lroundf(float __x);
long int lroundl(long double __x);

#endif


#ifdef __cplusplus
}
#endif

#endif

#ifndef VMS_DO_SOCKETS
/* This relies on tricks in perl.h to pick up that these manifest constants
 * are undefined and set up conversion routines.  It will then redefine
 * these manifest constants, so the actual values will match config.h
 */
#undef HAS_HTONS
#undef HAS_NTOHS
#undef HAS_HTONL
#undef HAS_NTOHL
#endif

/* The C RTL manual says to undef the macro for DEC C 5.2 and lower. */
#if defined(fileno) && defined(__DECC_VER) && __DECC_VER < 50300000
#  undef fileno 
#endif 

#define NO_ENVIRON_ARRAY

/* RMSEXPAND options */
#define PERL_RMSEXPAND_M_VMS		0x02 /* Force output to VMS format */
#define PERL_RMSEXPAND_M_LONG		0x04 /* Expand to long name format */
#define PERL_RMSEXPAND_M_VMS_IN		0x08 /* Assume input is VMS already */
#define PERL_RMSEXPAND_M_SYMLINK	0x20 /* Use symbolic link, not target */

/* With long doubles, NaN == NaN, which it shouldn't. */
#ifdef USE_LONG_DOUBLE
#  define NAN_COMPARE_BROKEN 1
#endif
#endif  /* __vmsish_h_included */
@


1.13
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d31 1
a31 1
#  pragma message informational (INTSIGNCHANGE,CASTQUALTYP,ASSCOMMEA,NOCTOBUTCONREFM)
a44 5
#ifdef __GNUC__
#ifndef _IOLBF /* gcc's stdio.h doesn't define this */
#define _IOLBF 1
#endif
#endif
a61 1
#ifndef __VAX
a69 1
#endif
a152 1
#define my_getlogin			Perl_my_getlogin
a158 6
#define my_sigemptyset(a)		Perl_my_sigemptyset(a)
#define my_sigfillset(a)		Perl_my_sigfillset(a)
#define my_sigaddset(a,b)		Perl_my_sigaddset(a,b)
#define my_sigdelset(a,b,c)		Perl_my_sigdelset(a,b,c)
#define my_sigismember(a,b)		Perl_my_sigismember(a,b)
#define my_sigprocmask(a,b,c)		Perl_my_sigprocmask(a,b,c)
a268 1
#define HINT_V_VMSISH		24
a270 1
#define NATIVE_HINTS		(PL_hints >> HINT_V_VMSISH)  /* used in op.c */
d273 1
a273 1
#  define TEST_VMSISH(h)	(my_perl && PL_curcop && (PL_curcop->op_private & ((h) >> HINT_V_VMSISH)))
d275 1
a275 1
#  define TEST_VMSISH(h)	(PL_curcop && (PL_curcop->op_private & ((h) >> HINT_V_VMSISH)))
d318 2
a319 1
#define PERL_SYS_TERM_BODY()		HINTS_REFCNT_TERM; OP_REFCNT_TERM; PERLIO_TERM; MALLOC_TERM
a360 1
#if __CRTL_VER >= 70302000
a361 3
#else
#undef HAS_GROUP		/**/
#endif
d481 1
a496 3
/* Thin jacket around cuserid() to match Unix' calling sequence */
#define getlogin my_getlogin

d719 1
d750 48
a797 1
char *	my_getlogin (void);
d829 4
@


1.12
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d475 3
a477 4
/* This is what times() returns, but <times.h> calls it tbuffer_t on VMS
 * prior to v7.0.  We check the DECC manifest to see whether it's already
 * done this for us, relying on the fact that perl.h #includes <time.h>
 * before it #includes "vmsish.h".
d480 1
a480 11
#ifndef __TMS
  struct tms {
    clock_t tms_utime;    /* user time */
    clock_t tms_stime;    /* system time - always 0 on VMS */
    clock_t tms_cutime;   /* user time, children */
    clock_t tms_cstime;   /* system time, children - always 0 on VMS */
  };
#else
   /* The new headers change the times() prototype to tms from tbuffer */
#  define tbuffer_t struct tms
#endif
@


1.11
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d27 1
a27 1
#if defined(__DECC) || defined(__DECCXX)
d30 3
d217 1
d313 1
a313 1
#define _ckvmssts(call) STMT_START { register unsigned long int __ckvms_sts; \
d321 1
a321 1
#define _ckvmssts_noperl(call) STMT_START { register unsigned long int __ckvms_sts; \
d324 2
a325 2
  fprintf(stderr,"Fatal VMS error (status=%d) at %s, line %d", \
  __ckvms_sts,__FILE__,__LINE__); lib$signal(__ckvms_sts); } } STMT_END
d689 4
d739 1
a739 1
void	Perl_vmssetuserlnm(pTHX_ const char *name, const char *eqv);
d782 5
@


1.10
log
@Merge in perl 5.10.1; part two
@
text
@a39 8
/* DECC 1.3 has a funny definition of abs; it's fixed in DECC 4.0, so this
 * can go away once DECC 1.3 isn't in use any more. */
#if defined(__ALPHA) && (defined(__DECC) || defined(__DECCXX))
#undef abs
#define abs(__x)        __ABS(__x)
#undef labs
#define labs(__x)        __LABS(__x)
#endif /* __ALPHA && __DECC */
d88 2
a89 12
/* All this stiff is for the x2P programs. Hopefully they'll still work */
#if defined(PERL_FOR_X2P)
#ifndef aTHX_
#define aTHX_
#endif
#ifndef pTHX_
#define pTHX_
#endif
#ifndef pTHX
#define pTHX
#endif
#endif
d114 1
a114 5
#define prime_env_iter	Perl_prime_env_iter
#define vms_image_init	Perl_vms_image_init
#define my_tmpfile		Perl_my_tmpfile
#define vmstrnenv           	Perl_vmstrnenv            
#define my_fgetname(a, b)	Perl_my_fgetname(a, b)
a115 31
#define my_getenv_len		Perl_my_getenv_len
#define vmssetenv		Perl_vmssetenv
#define my_trnlnm		Perl_my_trnlnm
#define my_setenv		Perl_my_setenv
#define my_getenv		Perl_my_getenv
#define tounixspec		Perl_tounixspec
#define tounixspec_ts		Perl_tounixspec_ts
#define tounixspec_utf8		Perl_tounixspec_utf8
#define tounixspec_utf8_ts	Perl_tounixspec_utf8_ts
#define tovmsspec		Perl_tovmsspec
#define tovmsspec_ts		Perl_tovmsspec_ts
#define tovmsspec_utf8		Perl_tovmsspec_utf8
#define tovmsspec_utf8_ts	Perl_tovmsspec_utf8_ts
#define tounixpath		Perl_tounixpath
#define tounixpath_ts		Perl_tounixpath_ts
#define tounixpath_utf8		Perl_tounixpath_utf8
#define tounixpath_utf8_ts	Perl_tounixpath_utf8_ts
#define tovmspath		Perl_tovmspath 
#define tovmspath_ts		Perl_tovmspath_ts
#define tovmspath_utf8		Perl_tovmspath_utf8
#define tovmspath_utf8_ts	Perl_tovmspath_utf8_ts
#define do_rmdir		Perl_do_rmdir
#define fileify_dirspec		Perl_fileify_dirspec
#define fileify_dirspec_ts	Perl_fileify_dirspec_ts
#define fileify_dirspec_utf8	Perl_fileify_dirspec_utf8
#define fileify_dirspec_utf8_ts	Perl_fileify_dirspec_utf8_ts
#define pathify_dirspec		Perl_pathify_dirspec
#define pathify_dirspec_ts	Perl_pathify_dirspec_ts
#define pathify_dirspec_utf8	Perl_pathify_dirspec_utf8
#define pathify_dirspec_utf8_ts	Perl_pathify_dirspec_utf8_ts
#define trim_unixpath		Perl_trim_unixpath
a117 11
#define rmscopy			Perl_rmscopy
#define my_mkdir		Perl_my_mkdir
#define vms_do_aexec		Perl_vms_do_aexec
#define vms_do_exec		Perl_vms_do_exec
#define my_waitpid		Perl_my_waitpid
#define my_crypt		Perl_my_crypt
#define kill_file		Perl_kill_file
#define my_utime		Perl_my_utime
#define my_chdir		Perl_my_chdir
#define my_chmod		Perl_my_chmod
#define do_aspawn		Perl_do_aspawn
a118 11
#define my_gmtime		Perl_my_gmtime
#define my_localtime		Perl_my_localtime
#define my_time			Perl_my_time
#define do_spawn		Perl_do_spawn
#define flex_fstat		Perl_flex_fstat
#define flex_stat		Perl_flex_stat
#define flex_lstat		Perl_flex_lstat
#define cando_by_name		Perl_cando_by_name
#define my_getpwnam		Perl_my_getpwnam
#define my_getpwuid		Perl_my_getpwuid
#define my_flush		Perl_my_flush
a121 37
#define my_getenv_len(a,b,c)	Perl_my_getenv_len(aTHX_ a,b,c)
#define vmssetenv(a,b,c)	Perl_vmssetenv(aTHX_ a,b,c)
#define my_trnlnm(a,b,c)	Perl_my_trnlnm(aTHX_ a,b,c)
#define fileify_dirspec(a,b)	Perl_fileify_dirspec(aTHX_ a,b)
#define fileify_dirspec_ts(a,b)	Perl_fileify_dirspec_ts(aTHX_ a,b)
#define my_setenv(a,b)		Perl_my_setenv(aTHX_ a,b)
#define my_getenv(a,b)		Perl_my_getenv(aTHX_ a,b)
#define tounixspec(a,b)		Perl_tounixspec_utf8(aTHX_ a,b,NULL)
#define tounixspec_ts(a,b)	Perl_tounixspec_utf8_ts(aTHX_ a,b,NULL)
#define tounixspec_utf8(a,b,c)	Perl_tounixspec_utf8(aTHX_ a,b,c)
#define tounixspec_utf8_ts(a,b,c) Perl_tounixspec_utf8_ts(aTHX_ a,b,c)
#define tovmsspec(a,b)		Perl_tovmsspec_utf8(aTHX_ a,b,NULL)
#define tovmsspec_ts(a,b)	Perl_tovmsspec_utf8_ts(aTHX_ a,b)
#define tovmsspec_utf8(a,b,c)	Perl_tovmsspec_utf8(aTHX_ a,b,c)
#define tovmsspec_utf8_ts(a,b,c) Perl_tovmsspec_utf8_ts(aTHX_ a,b,c)
#define tounixpath(a,b)		Perl_tounixpath_utf8(aTHX_ a,b,NULL)
#define tounixpath_ts(a,b)	Perl_tounixpath_utf8_ts(aTHX_ a,b,NULL)
#define tounixpath_utf8(a,b,c)	Perl_tounixpath_utf8(aTHX_ a,b,c)
#define tounixpath_utf8_ts(a,b,c) Perl_tounixpath_utf8_ts(aTHX_ a,b,c)
#define tovmspath(a,b)		Perl_tovmspath_utf8(aTHX_ a,b,NULL)
#define tovmspath_ts(a,b)	Perl_tovmspath_utf8_ts(aTHX_ a,b,NULL)
#define tovmspath_utf8(a,b,c)	Perl_tovmspath_utf8(aTHX_ a,b,c)
#define tovmspath_utf8_ts(a,b,c) Perl_tovmspath_utf8_ts(aTHX_ a,b,c)
#define do_rmdir(a)		Perl_do_rmdir(aTHX_ a)
#define fileify_dirspec(a,b)	Perl_fileify_dirspec(aTHX_ a,b)
#define fileify_dirspec_ts(a,b)	Perl_fileify_dirspec_ts(aTHX_ a,b)
#define fileify_dirspec_utf8(a,b,c) Perl_fileify_dirspec(aTHX_ a,b,utf8)
#define fileify_dirspec_utf8_ts(a,b,c) Perl_fileify_dirspec_ts(aTHX_ a,b,utf8)
#define pathify_dirspec		Perl_pathify_dirspec
#define pathify_dirspec_ts	Perl_pathify_dirspec_ts
#define pathify_dirspec_utf8	Perl_pathify_dirspec_utf8
#define pathify_dirspec_utf8_ts	Perl_pathify_dirspec_utf8_ts
#define rmsexpand(a,b,c,d)	Perl_rmsexpand_utf8(aTHX_ a,b,c,d,NULL,NULL)
#define rmsexpand_ts(a,b,c,d)	Perl_rmsexpand_utf8_ts(aTHX_ a,b,c,d,NULL,NULL)
#define rmsexpand_utf8(a,b,c,d,e,f) Perl_rmsexpand_utf8(aTHX_ a,b,c,d,e,f)
#define rmsexpand_utf8_ts(a,b,c,d,e,f) Perl_rmsexpand_utf8_ts(aTHX_ a,b,c,d,e,f)
#define trim_unixpath(a,b,c)	Perl_trim_unixpath(aTHX_ a,b,c)
a123 11
#define rmscopy(a,b,c)		Perl_rmscopy(aTHX_ a,b,c)
#define my_mkdir(a,b)		Perl_my_mkdir(aTHX_ a,b)
#define vms_do_aexec(a,b,c)	Perl_vms_do_aexec(aTHX_ a,b,c)
#define vms_do_exec(a)		Perl_vms_do_exec(aTHX_ a)
#define my_waitpid(a,b,c)	Perl_my_waitpid(aTHX_ a,b,c)
#define my_crypt(a,b)		Perl_my_crypt(aTHX_ a,b)
#define kill_file(a)		Perl_kill_file(aTHX_ a)
#define my_utime(a,b)		Perl_my_utime(aTHX_ a,b)
#define my_chdir(a)		Perl_my_chdir(aTHX_ a)
#define my_chmod(a,b)		Perl_my_chmod(aTHX_ a,b)
#define do_aspawn(a,b,c)	Perl_do_aspawn(aTHX_ a,b,c)
a124 11
#define my_gmtime(a)		Perl_my_gmtime(aTHX_ a)
#define my_localtime(a)		Perl_my_localtime(aTHX_ a)
#define my_time(a)		Perl_my_time(aTHX_ a)
#define do_spawn(a)		Perl_do_spawn(aTHX_ a)
#define flex_fstat(a,b)		Perl_flex_fstat(aTHX_ a,b)
#define cando_by_name(a,b,c)	Perl_cando_by_name(aTHX_ a,b,c)
#define flex_stat(a,b)		Perl_flex_stat(aTHX_ a,b)
#define flex_lstat(a,b)		Perl_flex_lstat(aTHX_ a,b)
#define my_getpwnam(a)		Perl_my_getpwnam(aTHX_ a)
#define my_getpwuid(a)		Perl_my_getpwuid(aTHX_ a)
#define my_flush(a)		Perl_my_flush(aTHX_ a)
d128 42
a169 17
#define my_gconvert		Perl_my_gconvert
#define telldir			Perl_telldir
#define closedir		Perl_closedir
#define vmsreaddirversions	Perl_vmsreaddirversions
#define my_sigemptyset        Perl_my_sigemptyset
#define my_sigfillset         Perl_my_sigfillset
#define my_sigaddset          Perl_my_sigaddset
#define my_sigdelset          Perl_my_sigdelset
#define my_sigismember        Perl_my_sigismember
#define my_sigprocmask        Perl_my_sigprocmask
#define my_vfork		Perl_my_vfork
#define my_fdopen               Perl_my_fdopen
#define my_fclose               Perl_my_fclose
#define my_fwrite		Perl_my_fwrite
#define my_getpwent()		Perl_my_getpwent(aTHX)
#define my_endpwent()		Perl_my_endpwent(aTHX)
#define my_getlogin		Perl_my_getlogin
d171 1
a171 1
#  define my_symlink(a, b)	Perl_my_symlink(aTHX_ a, b)
d173 41
a213 4
#define init_os_extras		Perl_init_os_extras
#define vms_realpath(a, b, c)	Perl_vms_realpath(aTHX_ a,b,c)
#define vms_realname(a, b, c)	Perl_vms_realname(aTHX_ a,b,c)
#define vms_case_tolerant(a)	Perl_vms_case_tolerant(a)
d216 1
a216 1
#define unlink kill_file
d238 1
a264 10
/* Lower case entry points for these are missing in some earlier RTLs 
 * so we borrow the defines and declares from errno.h and upcase them.
 */
#if defined(VMS_WE_ARE_CASE_SENSITIVE) && (__DECC_VER < 50500000)
#  define errno      (*CMA$TIS_ERRNO_GET_ADDR())
#  define vaxc$errno (*CMA$TIS_VMSERRNO_GET_ADDR())
   int *CMA$TIS_ERRNO_GET_ADDR     (void);   /* UNIX style error code        */
   int *CMA$TIS_VMSERRNO_GET_ADDR  (void);   /* VMS error (errno == EVMSERR) */
#endif

a323 1
#include "sockadapt.h"
a327 3
#if __CRTL_VER < 70000000
#define BIT_BUCKET "_NLA0:"
#else
a328 1
#endif
a358 1
#if defined(__CRTL_VER) && __CRTL_VER >= 70000000
a359 3
#else
#undef	HAS_IOCTL		/**/
#endif
a496 33
/* If we're using an older version of VMS whose Unix signal emulation
 * isn't very POSIXish, then roll our own.
 */
#if __VMS_VER < 70000000 || __DECC_VER < 50200000
#  define HOMEGROWN_POSIX_SIGNALS
#endif
#ifdef HOMEGROWN_POSIX_SIGNALS
#  define sigemptyset(t) my_sigemptyset(t)
#  define sigfillset(t) my_sigfillset(t)
#  define sigaddset(t, u) my_sigaddset(t, u)
#  define sigdelset(t, u) my_sigdelset(t, u)
#  define sigismember(t, u) my_sigismember(t, u)
#  define sigprocmask(t, u, v) my_sigprocmask(t, u, v)
#  ifndef _SIGSET_T
   typedef int sigset_t;
#  endif
   /* The tools for sigprocmask() are there, just not the routine itself */
#  ifndef SIG_UNBLOCK
#    define SIG_UNBLOCK 1
#  endif
#  ifndef SIG_BLOCK
#    define SIG_BLOCK 2
#  endif
#  ifndef SIG_SETMASK
#    define SIG_SETMASK 3
#  endif
#  define sigaction sigvec
#  define sa_flags sv_onstack
#  define sa_handler sv_handler
#  define sa_mask sv_mask
#  define sigsuspend(set) sigpause(*set)
#  define sigpending(a) (not_here("sigpending"),0)
#else
d501 1
a501 1
#  ifndef DONT_MASK_RTL_CALLS
a502 1
#  endif
a664 18
/*
 * DEC C previous to 6.0 corrupts the behavior of the /prefix
 * qualifier with the extern prefix pragma.  This provisional
 * hack circumvents this prefix pragma problem in previous 
 * precompilers.
 */
#if defined(__VMS_VER) && __VMS_VER >= 70000000
#  if defined(VMS_WE_ARE_CASE_SENSITIVE) && (__DECC_VER < 60000000)
#    pragma __extern_prefix save
#    pragma __extern_prefix ""  /* set to empty to prevent prefixing */
#    define geteuid decc$__unix_geteuid
#    define getuid decc$__unix_getuid
#    define stat(__p1,__p2)   decc$__utc_stat(__p1,__p2)
#    define fstat(__p1,__p2)  decc$__utc_fstat(__p1,__p2)
#    pragma __extern_prefix restore
#  endif
#endif

d679 1
a682 5
 *
 * In order to keep Gen_ShrFls.Pl happy, functions which are to be made
 * available to images linked to PerlShr.Exe must be declared between the
 * __VMS_PROTOTYPES__ and __VMS_SEPYTOTORP__ lines, and must be in the form
 *    <data type><TAB>name<WHITESPACE>(<prototype args>);
a684 19
#ifdef NO_PERL_TYPEDEFS
  /* We don't have Perl typedefs available (e.g. when building a2p), so
     we fake them here.  N.B.  There is *no* guarantee that the faked
     prototypes will actually match the real routines.  If you want to
     call Perl routines, include perl.h to get the real typedefs.  */
#  ifndef bool
#    define bool int
#    define __MY_BOOL_TYPE_FAKE
#  endif
#  ifndef I32
#    define I32  int
#    define __MY_I32_TYPE_FAKE
#  endif
#  ifndef SV
#    define SV   void   /* Since we only see SV * in prototypes */
#    define __MY_SV_TYPE_FAKE
#  endif
#endif

a688 2
/* prototype section start marker; `typedef' passes through cpp */
typedef char  __VMS_PROTOTYPES__;
a690 40
#if !defined(PERL_IMPLICIT_CONTEXT)
int	Perl_vms_case_tolerant(void);
char *	Perl_my_getenv (const char *, bool);
int	Perl_my_trnlnm (const char *, char *, unsigned long int);
char *	Perl_tounixspec (const char *, char *);
char *	Perl_tounixspec_ts (const char *, char *);
char *	Perl_tounixspec_utf8 (const char *, char *, int *);
char *	Perl_tounixspec_utf8_ts (const char *, char *, int *);
char *	Perl_tovmsspec (const char *, char *);
char *	Perl_tovmsspec_ts (const char *, char *);
char *	Perl_tovmsspec_utf8 (const char *, char *, int *);
char *	Perl_tovmsspec_utf8_ts (const char *, char *, int *);
char *	Perl_tounixpath (const char *, char *);
char *	Perl_tounixpath_ts (const char *, char *);
char *	Perl_tounixpath_utf8 (const char *, char *, int *);
char *	Perl_tounixpath_utf8_ts (const char *, char *, int *);
char *	Perl_tovmspath (const char *, char *);
char *	Perl_tovmspath_ts (const char *, char *);
char *	Perl_tovmspath_utf8 (const char *, char *, int *);
char *	Perl_tovmspath_utf8_ts (const char *, char *, int *);
int	Perl_do_rmdir (const char *);
char *	Perl_fileify_dirspec (const char *, char *);
char *	Perl_fileify_dirspec_ts (const char *, char *);
char *	Perl_fileify_dirspec_utf8 (const char *, char *, int *);
char *	Perl_fileify_dirspec_utf8_ts (const char *, char *, int *);
char *	Perl_pathify_dirspec (const char *, char *);
char *	Perl_pathify_dirspec_ts (const char *, char *);
char *	Perl_pathify_dirspec_utf8 (const char *, char *, int *);
char *	Perl_pathify_dirspec_utf8_ts (const char *, char *, int *);
char *	Perl_rmsexpand (const char *, char *, const char *, unsigned);
char *	Perl_rmsexpand_ts (const char *, char *, const char *, unsigned);
char *	Perl_rmsexpand_utf8 (const char *, char *, const char *, unsigned, int *, int *);
char *	Perl_rmsexpand_utf8_ts (const char *, char *, const char *, unsigned, int *, int *);
int	Perl_trim_unixpath (char *, const char*, int);
DIR  * Perl_opendir (const char *);
int 	Perl_rename(const char *, const char *);
int	Perl_rmscopy (const char *, const char *, int);
int	Perl_my_mkdir (const char *, Mode_t);
bool	Perl_vms_do_aexec (SV *, SV **, SV **);
#else
a727 1
#endif
a738 1
#ifndef HOMEGROWN_POSIX_SIGNALS
a739 1
#endif
a755 8
#ifdef HOMEGROWN_POSIX_SIGNALS
int     my_sigemptyset (sigset_t *);
int     my_sigfillset  (sigset_t *);
int     my_sigaddset   (sigset_t *, int);
int     my_sigdelset   (sigset_t *, int);
int     my_sigismember (sigset_t *, int);
int     my_sigprocmask (int, sigset_t *, sigset_t *);
#endif
a773 16
typedef char __VMS_SEPYTOTORP__;
/* prototype section end marker; `typedef' passes through cpp */

#ifdef NO_PERL_TYPEDEFS  /* We'll try not to scramble later files */
#  ifdef __MY_BOOL_TYPE_FAKE
#    undef bool
#    undef __MY_BOOL_TYPE_FAKE
#  endif
#  ifdef __MY_I32_TYPE_FAKE
#    undef I32
#    undef __MY_I32_TYPE_FAKE
#  endif
#  ifdef __MY_SV_TYPE_FAKE
#    undef SV
#    undef __MY_SV_TYPE_FAKE
#  endif
@


1.9
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d136 1
d280 1
a280 1
#  define my_symlink		Perl_my_symlink
d365 5
a369 1
#define TEST_VMSISH(h)	(PL_curcop->op_private & ((h) >> HINT_V_VMSISH))
d421 6
a426 1
#define PERL_FS_VER_FMT		"%d_%d_%d"
d462 3
d466 1
d529 1
a979 2
unsigned long int	Perl_do_aspawn (pTHX_ void *, void **, void **);
unsigned long int	Perl_do_spawn (pTHX_ const char *);
d983 1
d985 1
a985 1
int     my_symlink(const char *path1, const char *path2);
@


1.8
log
@merge in perl 5.8.8
@
text
@d1 1
a1 1
/*  vmsish.h
d3 1
a3 1
 * VMS-specific C header file for perl5.
d5 7
a11 2
 * Last revised: 16-Sep-1998 by Charles Bailey  bailey@@newman.upenn.edu
 * Version: 5.5.2
d67 25
d144 2
d148 2
d152 3
a154 1
#define tovmspath		Perl_tovmspath
d156 2
d161 2
d165 2
d169 1
d179 1
d181 1
a181 1
#define seekdir		Perl_seekdir
d184 1
a184 1
#define my_time		Perl_my_time
d188 1
d199 2
d203 16
a218 8
#define tounixspec(a,b)		Perl_tounixspec(aTHX_ a,b)
#define tounixspec_ts(a,b)	Perl_tounixspec_ts(aTHX_ a,b)
#define tovmsspec(a,b)		Perl_tovmsspec(aTHX_ a,b)
#define tovmsspec_t(a,b)	Perl_tovmsspec_ts(aTHX_ a,b)
#define tounixpath(a,b)		Perl_tounixpath(aTHX_ a,b)
#define tounixpath_ts(a,b)	Perl_tounixpath_ts(aTHX_ a,b)
#define tovmspath(a,b)		Perl_tovmspath(aTHX_ a,b)
#define tovmspath_ts(a,b)	Perl_tovmspath_ts(aTHX_ a,b)
d222 2
d226 6
a231 2
#define rmsexpand(a,b,c,d)	Perl_rmsexpand(aTHX_ a,b,c,d)
#define rmsexpand_ts(a,b,c,d)	Perl_rmsexpand_ts(aTHX_ a,b,c,d)
d234 1
d244 1
d254 1
d262 1
a262 1
#define telldir		Perl_telldir
d278 7
a284 1
#define init_os_extras	Perl_init_os_extras
d373 1
d378 1
d405 1
d407 5
a411 2
#define PERL_SYS_INIT(c,v)	MALLOC_CHECK_TAINT2(*c,*v) vms_image_init((c),(v)); MALLOC_INIT
#define PERL_SYS_TERM()		OP_REFCNT_TERM; MALLOC_TERM
d426 1
d493 6
d515 3
d525 1
d527 1
d533 3
d541 2
d544 1
d640 3
d647 3
d655 1
d657 6
d666 1
a666 1
    int		d_namlen;			/* Length of d_name */
d675 1
a675 1
    int				vms_wantversions;
d683 1
d719 4
d724 1
a724 2
#ifdef USE_LARGE_FILES
/* Mimic the new stat structure, filler fields, and alignment. */
d730 5
a734 40
struct mystat
{
        char *st_devnam;       /* pointer to device name */
        char *st_fill_dev;
        unsigned st_ino;        /* hack - CRTL uses unsigned short[3] for */
        unsigned short rvn;     /* FID (num,seq,rvn) */
        unsigned short st_fill_ino;
        unsigned short st_mode; /* file "mode" i.e. prot, dir, reg, etc. */
        unsigned short st_fill_mode;
        int     st_nlink;       /* for compatibility - not really used */
        unsigned st_uid;        /* from ACP - QIO uic field */
        unsigned short st_gid;  /* group number extracted from st_uid */
        unsigned short st_fill_gid;
        dev_t   st_rdev;        /* for compatibility - always zero */
        off_t   st_size;        /* file size in bytes */
        unsigned st_atime;      /* file access time; always same as st_mtime */
        unsigned st_fill_atime;
        unsigned st_mtime;      /* last modification time */
        unsigned st_fill_mtime;
        unsigned st_ctime;      /* file creation time */
        unsigned st_fill_ctime;
        char    st_fab_rfm;     /* record format */
        char    st_fab_rat;     /* record attributes */
        char    st_fab_fsz;     /* fixed header size */
        char    st_fab_fill;
        unsigned st_fab_mrs;    /* record size */
        int st_fill_expand[7];  /* will probably fill from beginning, so put our st_dev at end */
        unsigned st_dev;        /* encoded device name */
};

#else /* !defined(USE_LARGE_FILES) */

#if defined(__DECC) || defined(__DECCXX)
#  pragma __member_alignment __save
#  pragma __nomember_alignment
#endif
#if defined(__DECC) 
#  pragma __message __save
#  pragma __message disable (__MISALGNDSTRCT)
#  pragma __message disable (__MISALGNDMEM)
d739 7
a745 23
        char *st_devnam;  /* pointer to device name */
        unsigned st_ino;    /* hack - CRTL uses unsigned short[3] for */
        unsigned short rvn; /* FID (num,seq,rvn) */
        unsigned short st_mode;	/* file "mode" i.e. prot, dir, reg, etc. */
        int	st_nlink;	/* for compatibility - not really used */
        unsigned st_uid;	/* from ACP - QIO uic field */
        unsigned short st_gid;	/* group number extracted from st_uid */
        dev_t   st_rdev;	/* for compatibility - always zero */
        off_t   st_size;	/* file size in bytes */
        unsigned st_atime;	/* file access time; always same as st_mtime */
        unsigned st_mtime;	/* last modification time */
        unsigned st_ctime;	/* file creation time */
        char	st_fab_rfm;	/* record format */
        char	st_fab_rat;	/* record attributes */
        char	st_fab_fsz;	/* fixed header size */
        unsigned st_dev;	/* encoded device name */
        /* Pad struct out to integral number of longwords, since DECC 5.6/VAX
         * has a bug in dealing with offsets in structs in which are embedded
         * other structs whose size is an odd number of bytes.  (An even
         * number of bytes is enough to make it happy, but we go for natural
         * alignment anyhow.)
         */
        char	st_fill1[sizeof(void *) - (3*sizeof(unsigned short) + 3*sizeof(char))%sizeof(void *)];
d748 20
a767 2
#if defined(__DECC) 
#  pragma __message __restore
a769 2
#endif /* defined(USE_LARGE_FILES) */

a773 3
typedef unsigned mydev_t;
typedef unsigned myino_t;

d836 3
a838 1
void	init_os_extras ();
d842 1
d844 1
d847 34
a880 19
char *	Perl_tounixspec (char *, char *);
char *	Perl_tounixspec_ts (char *, char *);
char *	Perl_tovmsspec (char *, char *);
char *	Perl_tovmsspec_ts (char *, char *);
char *	Perl_tounixpath (char *, char *);
char *	Perl_tounixpath_ts (char *, char *);
char *	Perl_tovmspath (char *, char *);
char *	Perl_tovmspath_ts (char *, char *);
int	Perl_do_rmdir (char *);
char *	Perl_fileify_dirspec (char *, char *);
char *	Perl_fileify_dirspec_ts (char *, char *);
char *	Perl_pathify_dirspec (char *, char *);
char *	Perl_pathify_dirspec_ts (char *, char *);
char *	Perl_rmsexpand (char *, char *, char *, unsigned);
char *	Perl_rmsexpand_ts (char *, char *, char *, unsigned);
int	Perl_trim_unixpath (char *, char*, int);
DIR *	Perl_opendir (char *);
int	Perl_rmscopy (char *, char *, int);
int	Perl_my_mkdir (char *, Mode_t);
d885 34
a918 19
char *	Perl_tounixspec (pTHX_ char *, char *);
char *	Perl_tounixspec_ts (pTHX_ char *, char *);
char *	Perl_tovmsspec (pTHX_ char *, char *);
char *	Perl_tovmsspec_ts (pTHX_ char *, char *);
char *	Perl_tounixpath (pTHX_ char *, char *);
char *	Perl_tounixpath_ts (pTHX_ char *, char *);
char *	Perl_tovmspath (pTHX_ char *, char *);
char *	Perl_tovmspath_ts (pTHX_ char *, char *);
int	Perl_do_rmdir (pTHX_ char *);
char *	Perl_fileify_dirspec (pTHX_ char *, char *);
char *	Perl_fileify_dirspec_ts (pTHX_ char *, char *);
char *	Perl_pathify_dirspec (pTHX_ char *, char *);
char *	Perl_pathify_dirspec_ts (pTHX_ char *, char *);
char *	Perl_rmsexpand (pTHX_ char *, char *, char *, unsigned);
char *	Perl_rmsexpand_ts (pTHX_ char *, char *, char *, unsigned);
int	Perl_trim_unixpath (pTHX_ char *, char*, int);
DIR *	Perl_opendir (pTHX_ char *);
int	Perl_rmscopy (pTHX_ char *, char *, int);
int	Perl_my_mkdir (pTHX_ char *, Mode_t);
d921 1
d923 2
a924 2
int	Perl_vmssetenv (pTHX_ char *, char *, struct dsc$descriptor_s **);
void	Perl_vmssetuserlnm(pTHX_ char *name, char *eqv);
d928 4
a931 3
int	Perl_kill_file (pTHX_ char *);
int	Perl_my_chdir (pTHX_ char *);
FILE *	Perl_my_tmpfile ();
d940 1
a940 1
int	Perl_my_utime (pTHX_ char *, struct utimbuf *);
d944 1
a944 1
long	telldir (DIR *);
d946 1
a946 1
void	closedir (DIR *);
d959 1
a959 1
I32	Perl_cando_by_name (pTHX_ I32, Uid_t, char *);
d961 1
d963 2
a964 2
int	my_vfork ();
bool	Perl_vms_do_exec (pTHX_ char *);
d966 1
a966 1
unsigned long int	Perl_do_spawn (pTHX_ char *);
d969 4
a972 1
int    my_fwrite (const void *, size_t, size_t, FILE *);
d974 1
a974 1
struct passwd *	Perl_my_getpwnam (pTHX_ char *name);
d1013 6
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d211 2
a212 2
#define my_getpwent		Perl_my_getpwent
#define my_endpwent		Perl_my_endpwent
d612 39
d660 1
d687 11
a726 6
#if defined(__DECC) || defined(__DECCXX)
#  pragma __member_alignment __restore
#endif
#if defined(__DECC) 
#  pragma __message __restore
#endif
d863 2
a864 2
void	my_endpwent ();
char *	my_getlogin ();
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d149 1
d195 1
d310 1
d334 1
a334 1
#define PERL_SYS_INIT(c,v)	vms_image_init((c),(v)); MALLOC_INIT
d358 3
d362 1
d573 1
d789 1
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d66 13
d84 1
a84 1
#  define getenv(v) my_getenv(v,TRUE)
d89 1
a89 1
#define getenv_len(v,l) my_getenv_len(v,l,TRUE)
d102 5
a107 1
#define prime_env_iter	Perl_prime_env_iter
a108 1
#if !defined(PERL_IMPLICIT_CONTEXT)
a109 1
#define vmstrnenv           	Perl_vmstrnenv            
d128 21
d150 2
a152 1
#define vmstrnenv(a,b,c,d,e)	Perl_vmstrnenv(aTHX_ a,b,c,d,e)
d173 21
a194 2
#define my_crypt		Perl_my_crypt
#define my_waitpid		Perl_my_waitpid
a195 7
#define kill_file		Perl_kill_file
#define my_mkdir		Perl_my_mkdir
#define my_chdir		Perl_my_chdir
#define my_tmpfile		Perl_my_tmpfile
#define my_utime		Perl_my_utime
#define vms_image_init	Perl_vms_image_init
#define readdir		Perl_readdir
a196 1
#define seekdir		Perl_seekdir
a198 3
#define my_gmtime		Perl_my_gmtime
#define my_localtime		Perl_my_localtime
#define my_time		Perl_my_time
a204 3
#define cando_by_name		Perl_cando_by_name
#define flex_fstat		Perl_flex_fstat
#define flex_stat		Perl_flex_stat
a205 4
#define vms_do_aexec		Perl_vms_do_aexec
#define vms_do_exec		Perl_vms_do_exec
#define do_aspawn		Perl_do_aspawn
#define do_spawn		Perl_do_spawn
a208 3
#define my_flush		Perl_my_flush
#define my_getpwnam		Perl_my_getpwnam
#define my_getpwuid		Perl_my_getpwuid
d235 1
a235 1
#  define tmpfile my_tmpfile
a287 1
#define HINT_M_VMSISH_HUSHED	0x20000000 /* stifle error msgs on exit */
a292 1
#define VMSISH_HUSHED	TEST_VMSISH(HINT_M_VMSISH_HUSHED)
d296 10
d321 1
a321 1
  fprintf(Perl_debug_log,"Fatal VMS error (status=%d) at %s, line %d", \
d422 1
d503 8
d512 4
a524 1
#define ENV_HV_NAME "%EnV%VmS%"
d534 1
a534 1
#define crypt  my_crypt
d537 1
a537 1
#define Mkdir(dir,mode) my_mkdir((dir),(mode))
d542 1
a542 1
#define Fstat(fd,bufptr) flex_fstat(fd,bufptr)
d713 1
a715 1
int	Perl_vmstrnenv (const char *, char *, unsigned long int, struct dsc$descriptor_s **, unsigned long int);
d735 2
a737 1
int	Perl_vmstrnenv (pTHX_ const char *, char *, unsigned long int, struct dsc$descriptor_s **, unsigned long int);
d758 2
d761 5
a765 5
char *	my_getenv_len (const char *, unsigned long *, bool);
int	vmssetenv (char *, char *, struct dsc$descriptor_s **);
void	Perl_vmssetuserlnm(char *name, char *eqv);
char *	my_crypt (const char *, const char *);
Pid_t	my_waitpid (Pid_t, int *, int);
d767 14
a780 7
int	kill_file (char *);
int	my_mkdir (char *, Mode_t);
int	my_chdir (char *);
FILE *	my_tmpfile (void);
int	my_utime (char *, struct utimbuf *);
void	vms_image_init (int *, char ***);
struct dirent *	readdir (DIR *);
d782 1
a782 1
void	seekdir (DIR *, long);
d785 3
a787 3
struct tm *	my_gmtime (const time_t *);
struct tm *	my_localtime (const time_t *);
time_t	my_time (time_t *);
d796 3
a798 3
I32	cando_by_name (I32, Uid_t, char *);
int	flex_fstat (int, Stat_t *);
int	flex_stat (const char *, Stat_t *);
d800 4
a803 5
bool	vms_do_aexec (SV *, SV **, SV **);
bool	vms_do_exec (char *);
unsigned long int	do_aspawn (void *, void **, void **);
unsigned long int	do_spawn (char *);
FILE *  my_fdopen (int, char *);
d805 4
a808 5
int	my_fwrite (void *, size_t, size_t, FILE *);
int	my_flush (FILE *);
struct passwd *	my_getpwnam (char *name);
struct passwd *	my_getpwuid (Uid_t uid);
struct passwd *	my_getpwent ();
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d22 1
a22 1
#ifdef __DECC
d37 1
a37 1
#if defined(__ALPHA) && defined(__DECC)
d54 2
a55 7
#if defined(__DECC) && defined(__DECC_VER) && __DECC_VER > 20000000
#  include <unistd.h> /* DECC has this; VAXC and gcc don't */
#endif

/* VAXC doesn't have a unary plus operator, so we need to get there indirectly */
#if defined(VAXC) && !defined(__DECC)
#  define NO_UNARY_PLUS
a88 2
#define vmstrnenv		Perl_vmstrnenv
#define my_trnlnm		Perl_my_trnlnm
d93 2
d97 16
d114 2
d118 18
a139 1
#define do_rmdir		Perl_do_rmdir
d142 2
a144 14
#define rmsexpand	Perl_rmsexpand
#define rmsexpand_ts	Perl_rmsexpand_ts
#define fileify_dirspec	Perl_fileify_dirspec
#define fileify_dirspec_ts	Perl_fileify_dirspec_ts
#define pathify_dirspec	Perl_pathify_dirspec
#define pathify_dirspec_ts	Perl_pathify_dirspec_ts
#define tounixspec		Perl_tounixspec
#define tounixspec_ts		Perl_tounixspec_ts
#define tovmsspec		Perl_tovmsspec
#define tovmsspec_ts		Perl_tovmsspec_ts
#define tounixpath		Perl_tounixpath
#define tounixpath_ts		Perl_tounixpath_ts
#define tovmspath		Perl_tovmspath
#define tovmspath_ts		Perl_tovmspath_ts
a145 1
#define opendir		Perl_opendir
a162 1
#define trim_unixpath		Perl_trim_unixpath
d168 2
a176 1
#define rmscopy		Perl_rmscopy
d194 10
d283 2
d377 7
a392 5
    /* VAXC's signal.h doesn't #define SIG_ERR, but provides BADSIG instead. */
#if !defined(SIG_ERR) && defined(BADSIG)
#  define SIG_ERR BADSIG
#endif

d475 1
a475 1
/* Thin jacket around cuserid() tomatch Unix' calling sequence */
d478 1
a478 1
/* Ditto for sys$hash_passwrod() . . . */
d481 1
a481 1
/* Tweak arg to mkdir first, so we can tolerate trailing /. */
d483 1
d541 1
a541 1
 * N.B 2. The routine cando() in vms.c assumes that &stat.st_ino is the
a657 2
int	vmstrnenv (const char *, char *, unsigned long int, struct dsc$descriptor_s **, unsigned long int);
int	my_trnlnm (const char *, char *, unsigned long int);
d660 20
d681 1
d683 19
d705 1
a708 1
int	do_rmdir (char *);
d711 2
a713 14
char *	rmsexpand (char *, char *, char *, unsigned);
char *	rmsexpand_ts (char *, char *, char *, unsigned);
char *	fileify_dirspec (char *, char *);
char *	fileify_dirspec_ts (char *, char *);
char *	pathify_dirspec (char *, char *);
char *	pathify_dirspec_ts (char *, char *);
char *	tounixspec (char *, char *);
char *	tounixspec_ts (char *, char *);
char *	tovmsspec (char *, char *);
char *	tovmsspec_ts (char *, char *);
char *	tounixpath (char *, char *);
char *	tounixpath_ts (char *, char *);
char *	tovmspath (char *, char *);
char *	tovmspath_ts (char *, char *);
a714 1
DIR *	opendir (char *);
a733 1
int	trim_unixpath (char *, char*, int);
d739 2
a747 1
int	rmscopy (char *, char *, int);
d781 2
@


1.3
log
@perl5.005_03 (stock)
@
text
@d5 2
a6 2
 * Last revised: 18-Feb-1997 by Charles Bailey  bailey@@genetics.upenn.edu
 * Version: 5.3.28
d67 4
a70 1
    /* defined for vms.c so we can see CRTL |  defined for a2p */
d75 5
a79 1
#  define getenv(v) my_getenv(v)  /* getenv used for regular logical names */
d81 1
d94 11
a104 61
#ifdef EMBED
#  define my_trnlnm		Perl_my_trnlnm
#  define my_getenv		Perl_my_getenv
#  define prime_env_iter	Perl_prime_env_iter
#  define my_setenv		Perl_my_setenv
#  define my_crypt		Perl_my_crypt
#  define my_waitpid		Perl_my_waitpid
#  define my_gconvert		Perl_my_gconvert
#  define do_rmdir		Perl_do_rmdir
#  define kill_file		Perl_kill_file
#  define my_mkdir		Perl_my_mkdir
#  define my_utime		Perl_my_utime
#  define rmsexpand	Perl_rmsexpand
#  define rmsexpand_ts	Perl_rmsexpand_ts
#  define fileify_dirspec	Perl_fileify_dirspec
#  define fileify_dirspec_ts	Perl_fileify_dirspec_ts
#  define pathify_dirspec	Perl_pathify_dirspec
#  define pathify_dirspec_ts	Perl_pathify_dirspec_ts
#  define tounixspec		Perl_tounixspec
#  define tounixspec_ts		Perl_tounixspec_ts
#  define tovmsspec		Perl_tovmsspec
#  define tovmsspec_ts		Perl_tovmsspec_ts
#  define tounixpath		Perl_tounixpath
#  define tounixpath_ts		Perl_tounixpath_ts
#  define tovmspath		Perl_tovmspath
#  define tovmspath_ts		Perl_tovmspath_ts
#  define vms_image_init	Perl_vms_image_init
#  define opendir		Perl_opendir
#  define readdir		Perl_readdir
#  define telldir		Perl_telldir
#  define seekdir		Perl_seekdir
#  define closedir		Perl_closedir
#  define vmsreaddirversions	Perl_vmsreaddirversions
#  define my_gmtime		Perl_my_gmtime
#  define my_localtime		Perl_my_localtime
#  define my_time		Perl_my_time
#  define my_sigemptyset        Perl_my_sigemptyset
#  define my_sigfillset         Perl_my_sigfillset
#  define my_sigaddset          Perl_my_sigaddset
#  define my_sigdelset          Perl_my_sigdelset
#  define my_sigismember        Perl_my_sigismember
#  define my_sigprocmask        Perl_my_sigprocmask
#  define cando_by_name		Perl_cando_by_name
#  define flex_fstat		Perl_flex_fstat
#  define flex_stat		Perl_flex_stat
#  define trim_unixpath		Perl_trim_unixpath
#  define my_vfork		Perl_my_vfork
#  define vms_do_aexec		Perl_vms_do_aexec
#  define vms_do_exec		Perl_vms_do_exec
#  define do_aspawn		Perl_do_aspawn
#  define do_spawn		Perl_do_spawn
#  define my_fwrite		Perl_my_fwrite
#  define my_flush		Perl_my_flush
#  define my_binmode		Perl_my_binmode
#  define my_getpwnam		Perl_my_getpwnam
#  define my_getpwuid		Perl_my_getpwuid
#  define my_getpwent		Perl_my_getpwent
#  define my_endpwent		Perl_my_endpwent
#  define my_getlogin		Perl_my_getlogin
#  define rmscopy		Perl_rmscopy
#  define init_os_extras	Perl_init_os_extras
d106 55
d201 10
d226 3
a228 3
#define HINT_M_VMSISH_STATUS	0x01000000 /* system, $? return VMS status */
#define HINT_M_VMSISH_EXIT	0x02000000 /* exit(1) ==> SS$_NORMAL */
#define HINT_M_VMSISH_TIME	0x04000000 /* times are local, not UTC */
d232 1
a233 1
#define VMSISH_EXIT	TEST_VMSISH(HINT_M_VMSISH_EXIT)
d236 3
d243 1
a243 1
  croak("Fatal VMS error (status=%d) at %s, line %d", \
d260 1
a260 1
#define PERL_SYS_TERM()		MALLOC_TERM
d265 6
d310 1
a310 1
 *	use the routine my_binmode(FILE *fp, char iotype) to insure
d314 1
a314 1
#define USEMYBINMODE
d440 2
a441 1
#define ENV_getenv(v) my_getenv(v)
d554 19
d592 1
d600 1
a600 1
 *    <data type><TAB>name<WHITESPACE>_((<prototype args>));
d622 2
a623 2
void	prime_env_iter _((void));
void	init_os_extras _(());
d626 40
a665 33
int	my_trnlnm _((char *, char *, unsigned long int));
char *	my_getenv _((char *));
char *	my_crypt _((const char *, const char *));
Pid_t	my_waitpid _((Pid_t, int *, int));
char *	my_gconvert _((double, int, int, char *));
int	do_rmdir _((char *));
int	kill_file _((char *));
int	my_mkdir _((char *, Mode_t));
int	my_utime _((char *, struct utimbuf *));
char *	rmsexpand _((char *, char *, char *, unsigned));
char *	rmsexpand_ts _((char *, char *, char *, unsigned));
char *	fileify_dirspec _((char *, char *));
char *	fileify_dirspec_ts _((char *, char *));
char *	pathify_dirspec _((char *, char *));
char *	pathify_dirspec_ts _((char *, char *));
char *	tounixspec _((char *, char *));
char *	tounixspec_ts _((char *, char *));
char *	tovmsspec _((char *, char *));
char *	tovmsspec_ts _((char *, char *));
char *	tounixpath _((char *, char *));
char *	tounixpath_ts _((char *, char *));
char *	tovmspath _((char *, char *));
char *	tovmspath_ts _((char *, char *));
void	vms_image_init _((int *, char ***));
DIR *	opendir _((char *));
struct dirent *	readdir _((DIR *));
long	telldir _((DIR *));
void	seekdir _((DIR *, long));
void	closedir _((DIR *));
void	vmsreaddirversions _((DIR *, int));
struct tm *	my_gmtime _((const time_t *));
struct tm *	my_localtime _((const time_t *));
time_t	my_time _((time_t *));
d667 24
a690 25
int     my_sigemptyset _((sigset_t *));
int     my_sigfillset  _((sigset_t *));
int     my_sigaddset   _((sigset_t *, int));
int     my_sigdelset   _((sigset_t *, int));
int     my_sigismember _((sigset_t *, int));
int     my_sigprocmask _((int, sigset_t *, sigset_t *));
#endif
I32	cando_by_name _((I32, I32, char *));
int	flex_fstat _((int, Stat_t *));
int	flex_stat _((char *, Stat_t *));
int	trim_unixpath _((char *, char*, int));
int	my_vfork _(());
bool	vms_do_aexec _((SV *, SV **, SV **));
bool	vms_do_exec _((char *));
unsigned long int	do_aspawn _((void *, void **, void **));
unsigned long int	do_spawn _((char *));
int	my_fwrite _((void *, size_t, size_t, FILE *));
int	my_flush _((FILE *));
FILE *	my_binmode _((FILE *, char));
struct passwd *	my_getpwnam _((char *name));
struct passwd *	my_getpwuid _((Uid_t uid));
struct passwd *	my_getpwent _(());
void	my_endpwent _(());
char *	my_getlogin _(());
int	rmscopy _((char *, char *, int));
d720 4
a723 1
#define TMPPATH "sys$scratch:perl-eXXXXXX"
@


1.2
log
@perl 5.004_04
@
text
@a18 1
 * GLOBALEXT, NOSHAREEXT, READONLYEXT: global[dr]ef declarations
d23 1
a23 1
#  pragma message disable (GLOBALEXT,NOSHAREEXT,READONLYEXT,ADDRCONSTEXT,NEEDCONSTEXT)
d58 5
a76 5
#ifdef __PID_T
#  define Pid_t pid_t
#else
#  define Pid_t unsigned int
#endif
d79 6
a118 1
#if __VMS_VER < 70000000 || __DECC_VER < 50200000
d122 6
a127 1
#endif
a168 6
/* USE_STAT_RDEV:
 *	This symbol is defined if this system has a stat structure declaring
 *	st_rdev
 */
#define USE_STAT_RDEV 	/**/

d206 1
a206 1
#define NATIVE_HINTS		(hints >> HINT_V_VMSISH)  /* used in op.c */
d208 1
a208 1
#define TEST_VMSISH(h)	(curcop->op_private & ((h) >> HINT_V_VMSISH))
d233 2
a234 2
#define PERL_SYS_INIT(c,v)  vms_image_init((c),(v))
#define PERL_SYS_TERM()
d260 3
a262 3
 *	This symbol, if defined, indicates that the getgrnam(),
 *	getgrgid(), and getgrent() routines are available to 
 *	get group entries.
d267 3
a269 3
 *	This symbol, if defined, indicates that the getpwnam(),
 *	getpwuid(), and getpwent() routines are available to 
 *	get password entries.
d284 24
d356 3
a358 5
/* Prior to VMS 7.0, the CRTL gmtime() routine was a stub which always
 * returned NULL.  Substitute our own routine, which uses the logical
 * SYS$TIMEZONE_DIFFERENTIAL, whcih the native UTC support routines
 * in VMS 6.0 or later use.  We also add shims for time() and localtime()
 * so we can run on UTC by default.
a359 1
#if __VMS_VER < 70000000 || __DECC_VER < 50200000
d363 33
d511 7
a602 1
#ifdef my_gmtime
d606 8
a613 1
#endif /* We're assuming these three come as a package */
d615 2
a616 2
int	flex_fstat _((int, struct mystat *));
int	flex_stat _((char *, struct mystat *));
d621 1
a621 1
unsigned long int	do_aspawn _((SV *, SV **, SV **));
@


1.1
log
@Initial revision
@
text
@d5 2
a6 2
 * Last revised: 01-Oct-1995 by Charles Bailey  bailey@@genetics.upenn.edu
 * Version: 5.1.6
d16 1
d19 1
a19 10
 * GLOBALEXT, NOSHAREEXT: global[dr]ef declarations
 * ADDRCONSTEXT: initialization of data with non-constant values
 *               (e.g. pointer fields of descriptors)
 */
#ifdef __DECC
#  pragma message disable (GLOBALEXT,NOSHAREEXT,ADDRCONSTEXT)
#endif

/* Suppress compiler warnings from DECC for VMS-specific extensions:
 * GLOBALEXT, NOSHAREEXT: global[dr]ef declarations
d24 1
a24 1
#  pragma message disable (GLOBALEXT,NOSHAREEXT,ADDRCONSTEXT,NEEDCONSTEXT)
d55 24
d84 2
d87 1
a87 1
#  define waitpid		Perl_waitpid
d91 1
d93 2
d107 1
a107 1
#  define getredirection	Perl_getredirection
d114 1
a114 1
#  define getredirection	Perl_getredirection
d116 3
d123 1
d129 2
d143 39
a181 4
/*  The VMS C RTL has vfork() but not fork().  Both actually work in a way
 *  that's somewhere between Unix vfork() and VMS lib$spawn(), so it's
 *  probably not a good idea to use them much.  That said, we'll try to
 *  use vfork() in either case.
d183 1
a183 1
#define fork vfork
d188 1
d195 15
d217 8
d230 1
a230 1
#define PERL_SYS_INIT(c,v)  getredirection((c),(v))
d232 1
a232 1
#define dXSUB_SYS int dummy
d273 8
d289 3
d298 5
d311 5
a315 1
/* This is what times() returns, but <times.h> calls it tbuffer_t on VMS */
d317 11
a327 6
struct tms {
  clock_t tms_utime;    /* user time */
  clock_t tms_stime;    /* system time - always 0 on VMS */
  clock_t tms_cutime;   /* user time, children */
  clock_t tms_cstime;   /* system time, children - always 0 on VMS */
};
d332 2
a333 1
 * in VMS 6.0 or later use.*
d335 1
d337 3
d350 3
d360 3
a366 3
/* By default, flush data all the way to disk, not just to RMS buffers */
#define Fflush(fp) ((fflush(fp) || fsync(fileno(fp))) ? EOF : 0)

a370 1
 *    This code has no copyright.
a454 1
#define stat mystat
a455 1
#define dev_t mydev_t
d457 8
a464 1
#define ino_t myino_t
d485 22
d512 1
a512 1
unsigned long int	waitpid _((unsigned long int, int *, int));
d516 1
d518 2
d532 1
a532 1
void	getredirection _(());
d539 5
a543 2
void	getredirection _((int *, char ***));
struct tm *my_gmtime _((const time_t *));
d545 4
a548 3
int	flex_fstat _((int, struct stat *));
int	flex_stat _((char *, struct stat *));
int	trim_unixpath _((char *, char*));
d554 2
a561 1
void	init_os_extras _(());
d564 15
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d5 2
a6 2
 * Last revised: 18-Feb-1997 by Charles Bailey  bailey@@genetics.upenn.edu
 * Version: 5.3.28
a15 1
#include <stsdef.h>  /* bitmasks for exit status testing */
d18 10
d32 1
a32 1
#  pragma message disable (ADDRCONSTEXT,NEEDCONSTEXT)
a62 30
#if defined(__DECC) && defined(__DECC_VER) && __DECC_VER > 20000000
#  include <unistd.h> /* DECC has this; VAXC and gcc don't */
#endif

/* VAXC doesn't have a unary plus operator, so we need to get there indirectly */
#if defined(VAXC) && !defined(__DECC)
#  define NO_UNARY_PLUS
#endif

#ifdef NO_PERL_TYPEDEFS /* a2p; we don't want Perl's special routines */
#  define DONT_MASK_RTL_CALLS
#endif

    /* defined for vms.c so we can see CRTL |  defined for a2p */
#ifndef DONT_MASK_RTL_CALLS
#  ifdef getenv
#    undef getenv
#  endif
#  define getenv(v) my_getenv(v)  /* getenv used for regular logical names */
#endif

/* DECC introduces this routine in the RTL as of VMS 7.0; for now,
 * we'll use ours, since it gives us the full VMS exit status. */
#define waitpid my_waitpid

/* Don't redeclare standard RTL routines in Perl's header files;
 * VMS history or extensions makes some of the formal protoypes
 * differ from the common Unix forms.
 */
#define DONT_DECLARE_STD 1
a67 2
#  define prime_env_iter	Perl_prime_env_iter
#  define my_setenv		Perl_my_setenv
d69 1
a69 1
#  define my_waitpid		Perl_my_waitpid
a72 1
#  define my_mkdir		Perl_my_mkdir
a73 2
#  define rmsexpand	Perl_rmsexpand
#  define rmsexpand_ts	Perl_rmsexpand_ts
d86 1
a86 1
#  define vms_image_init	Perl_vms_image_init
d93 1
a94 8
#  define my_localtime		Perl_my_localtime
#  define my_time		Perl_my_time
#  define my_sigemptyset        Perl_my_sigemptyset
#  define my_sigfillset         Perl_my_sigfillset
#  define my_sigaddset          Perl_my_sigaddset
#  define my_sigdelset          Perl_my_sigdelset
#  define my_sigismember        Perl_my_sigismember
#  define my_sigprocmask        Perl_my_sigprocmask
a98 1
#  define my_vfork		Perl_my_vfork
a103 2
#  define my_flush		Perl_my_flush
#  define my_binmode		Perl_my_binmode
d116 4
a119 33
/* 
 * Intercept calls to fork, so we know whether subsequent calls to
 * exec should be handled in VMSish or Unixish style.
 */
#define fork my_vfork
#ifndef DONT_MASK_RTL_CALLS     /* #defined in vms.c so we see real vfork */
#  ifdef vfork
#    undef vfork
#  endif
#  define vfork my_vfork
#endif

/* BIG_TIME:
 *	This symbol is defined if Time_t is an unsigned type on this system.
 */
#define BIG_TIME

/* ACME_MESS:
 *	This symbol, if defined, indicates that error messages should be 
 *	should be generated in a format that allows the use of the Acme
 *	GUI/editor's autofind feature.
 */
#undef ACME_MESS	/**/

/* ALTERNATE_SHEBANG:
 *	This symbol, if defined, contains a "magic" string which may be used
 *	as the first line of a Perl program designed to be executed directly
 *	by name, instead of the standard Unix #!.  If ALTERNATE_SHEBANG
 *	begins with a character other then #, then Perl will only treat
 *	it as a command line if if finds the string "perl" in the first
 *	word; otherwise it's treated as the first line of code in the script.
 *	(IOW, Perl won't hand off to another interpreter via an alternate
 *	shebang sequence that might be legal Perl code.)
d121 1
a121 1
#define ALTERNATE_SHEBANG "$"
a125 1
   void cma$tis_errno_set_value(int __value);  /* missing in some errno.h */
a131 15
/* Support for 'vmsish' behaviors enabled with C<use vmsish> pragma */

#define COMPLEX_STATUS	1	/* We track both "POSIX" and VMS values */

#define HINT_V_VMSISH		24
#define HINT_M_VMSISH_STATUS	0x01000000 /* system, $? return VMS status */
#define HINT_M_VMSISH_EXIT	0x02000000 /* exit(1) ==> SS$_NORMAL */
#define HINT_M_VMSISH_TIME	0x04000000 /* times are local, not UTC */
#define NATIVE_HINTS		(PL_hints >> HINT_V_VMSISH)  /* used in op.c */

#define TEST_VMSISH(h)	(PL_curcop->op_private & ((h) >> HINT_V_VMSISH))
#define VMSISH_STATUS	TEST_VMSISH(HINT_M_VMSISH_STATUS)
#define VMSISH_EXIT	TEST_VMSISH(HINT_M_VMSISH_EXIT)
#define VMSISH_TIME	TEST_VMSISH(HINT_M_VMSISH_TIME)

a138 8
/* Same thing, but don't call back to Perl's croak(); useful for errors
 * occurring during startup, before Perl's state is initialized */
#define _ckvmssts_noperl(call) STMT_START { register unsigned long int __ckvms_sts; \
  if (!((__ckvms_sts=(call))&1)) { \
  set_errno(EVMSERR); set_vaxc_errno(__ckvms_sts); \
  fprintf(Perl_debug_log,"Fatal VMS error (status=%d) at %s, line %d", \
  __ckvms_sts,__FILE__,__LINE__); lib$signal(__ckvms_sts); } } STMT_END

d144 3
a146 3
#define PERL_SYS_INIT(c,v)	vms_image_init((c),(v)); MALLOC_INIT
#define PERL_SYS_TERM()		MALLOC_TERM
#define dXSUB_SYS
d171 3
a173 3
 *	This symbol, if defined, indicates that the getgrnam() and
 *	getgrgid() routines are available to get group entries.
 *	The getgrent() has a separate definition, HAS_GETGRENT.
d178 3
a180 3
 *	This symbol, if defined, indicates that the getpwnam() and
 *	getpwuid() routines are available to get password entries.
 *	The getpwent() has a separate definition, HAS_GETPWENT.
a186 32
/* USEMYBINMODE
 *	This symbol, if defined, indicates that the program should
 *	use the routine my_binmode(FILE *fp, char iotype) to insure
 *	that a file is in "binary" mode -- that is, that no translation
 *	of bytes occurs on read or write operations.
 */
#define USEMYBINMODE

/* Stat_t:
 *	This symbol holds the type used to declare buffers for information
 *	returned by stat().  It's usually just struct stat.  It may be necessary
 *	to include <sys/stat.h> and <sys/types.h> to get any typedef'ed
 *	information.
 */
/* VMS:
 * We need this typedef to point to the new type even if DONT_MASK_RTL_CALLS
 * is in effect, since Perl's thread.h embeds one of these structs in its
 * thread data struct, and our struct mystat is a different size from the
 * regular struct stat (cf. note above about having to pad struct to work
 * around bug in compiler.)
 * It's OK to pass one of these to the RTL's stat(), though, since the
 * fields it fills are the same in each struct.
 */
#define Stat_t struct mystat

/* USE_STAT_RDEV:
*	This symbol is defined if this system has a stat structure declaring
*	st_rdev
*	VMS: Field exists in POSIXish version of struct stat(), but is not used.
*/
#undef USE_STAT_RDEV		/**/

a194 3
/* By default, flush data all the way to disk, not just to RMS buffers */
#define Fflush(fp) my_flush(fp)

a200 5
    /* VAXC's signal.h doesn't #define SIG_ERR, but provides BADSIG instead. */
#if !defined(SIG_ERR) && defined(BADSIG)
#  define SIG_ERR BADSIG
#endif

d209 1
a209 5
/* This is what times() returns, but <times.h> calls it tbuffer_t on VMS
 * prior to v7.0.  We check the DECC manifest to see whether it's already
 * done this for us, relying on the fact that perl.h #includes <time.h>
 * before it #includes "vmsish.h".
 */
d211 6
a216 11
#ifndef __TMS
  struct tms {
    clock_t tms_utime;    /* user time */
    clock_t tms_stime;    /* system time - always 0 on VMS */
    clock_t tms_cutime;   /* user time, children */
    clock_t tms_cstime;   /* system time, children - always 0 on VMS */
  };
#else
   /* The new headers change the times() prototype to tms from tbuffer */
#  define tbuffer_t struct tms
#endif
d218 4
a221 3
/* Substitute our own routines for gmtime(), localtime(), and time(),
 * which allow us to implement the vmsish 'time' pragma, and work
 * around absence of system-level UTC support on old versions of VMS.
a223 36
#define localtime(t) my_localtime(t)
#define time(t) my_time(t)

/* If we're using an older version of VMS whose Unix signal emulation
 * isn't very POSIXish, then roll our own.
 */
#if __VMS_VER < 70000000 || __DECC_VER < 50200000
#  define HOMEGROWN_POSIX_SIGNALS
#endif
#ifdef HOMEGROWN_POSIX_SIGNALS
#  define sigemptyset(t) my_sigemptyset(t)
#  define sigfillset(t) my_sigfillset(t)
#  define sigaddset(t, u) my_sigaddset(t, u)
#  define sigdelset(t, u) my_sigdelset(t, u)
#  define sigismember(t, u) my_sigismember(t, u)
#  define sigprocmask(t, u, v) my_sigprocmask(t, u, v)
#  ifndef _SIGSET_T
   typedef int sigset_t;
#  endif
   /* The tools for sigprocmask() are there, just not the routine itself */
#  ifndef SIG_UNBLOCK
#    define SIG_UNBLOCK 1
#  endif
#  ifndef SIG_BLOCK
#    define SIG_BLOCK 2
#  endif
#  ifndef SIG_SETMASK
#    define SIG_SETMASK 3
#  endif
#  define sigaction sigvec
#  define sa_flags sv_onstack
#  define sa_handler sv_handler
#  define sa_mask sv_mask
#  define sigsuspend(set) sigpause(*set)
#  define sigpending(a) (not_here("sigpending"),0)
#endif
a233 3
  /* Special getenv function for retrieving %ENV elements. */
#define ENV_getenv(v) my_getenv(v)

a240 3
/* Tweak arg to mkdir first, so we can tolerate trailing /. */
#define Mkdir(dir,mode) my_mkdir((dir),(mode))

d245 3
d252 1
a335 7
        /* Pad struct out to integral number of longwords, since DECC 5.6/VAX
         * has a bug in dealing with offsets in structs in which are embedded
         * other structs whose size is an odd number of bytes.  (An even
         * number of bytes is enough to make it happy, but we go for natural
         * alignment anyhow.)
         */
        char	st_fill1[sizeof(void *) - (3*sizeof(unsigned short) + 3*sizeof(char))%sizeof(void *)];
d337 1
d339 1
d341 1
a341 8
#ifndef DONT_MASK_RTL_CALLS  /* defined for vms.c so we can see RTL calls */
#  ifdef stat
#    undef stat
#  endif
#  define stat mystat
#  define dev_t mydev_t
#  define ino_t myino_t
#endif
a361 22

#ifdef NO_PERL_TYPEDEFS
  /* We don't have Perl typedefs available (e.g. when building a2p), so
     we fake them here.  N.B.  There is *no* guarantee that the faked
     prototypes will actually match the real routines.  If you want to
     call Perl routines, include perl.h to get the real typedefs.  */
#  ifndef bool
#    define bool int
#    define __MY_BOOL_TYPE_FAKE
#  endif
#  ifndef I32
#    define I32  int
#    define __MY_I32_TYPE_FAKE
#  endif
#  ifndef SV
#    define SV   void   /* Since we only see SV * in prototypes */
#    define __MY_SV_TYPE_FAKE
#  endif
#endif

void	prime_env_iter _((void));
void	init_os_extras _(());
d367 1
a367 1
Pid_t	my_waitpid _((Pid_t, int *, int));
a370 1
int	my_mkdir _((char *, Mode_t));
a371 2
char *	rmsexpand _((char *, char *, char *, unsigned));
char *	rmsexpand_ts _((char *, char *, char *, unsigned));
d384 1
a384 1
void	vms_image_init _((int *, char ***));
d391 2
a392 11
struct tm *	my_gmtime _((const time_t *));
struct tm *	my_localtime _((const time_t *));
time_t	my_time _((time_t *));
#ifdef HOMEGROWN_POSIX_SIGNALS
int     my_sigemptyset _((sigset_t *));
int     my_sigfillset  _((sigset_t *));
int     my_sigaddset   _((sigset_t *, int));
int     my_sigdelset   _((sigset_t *, int));
int     my_sigismember _((sigset_t *, int));
int     my_sigprocmask _((int, sigset_t *, sigset_t *));
#endif
d394 3
a396 4
int	flex_fstat _((int, Stat_t *));
int	flex_stat _((char *, Stat_t *));
int	trim_unixpath _((char *, char*, int));
int	my_vfork _(());
d399 1
a399 1
unsigned long int	do_aspawn _((void *, void **, void **));
a401 2
int	my_flush _((FILE *));
FILE *	my_binmode _((FILE *, char));
d408 1
a410 15

#ifdef NO_PERL_TYPEDEFS  /* We'll try not to scramble later files */
#  ifdef __MY_BOOL_TYPE_FAKE
#    undef bool
#    undef __MY_BOOL_TYPE_FAKE
#  endif
#  ifdef __MY_I32_TYPE_FAKE
#    undef I32
#    undef __MY_I32_TYPE_FAKE
#  endif
#  ifdef __MY_SV_TYPE_FAKE
#    undef SV
#    undef __MY_SV_TYPE_FAKE
#  endif
#endif
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d5 2
a6 2
 * Last revised: 16-Sep-1998 by Charles Bailey  bailey@@newman.upenn.edu
 * Version: 5.5.2
d67 1
a67 4
/* Note that we do, in fact, have this */
#define HAS_GETENV_SV
#define HAS_GETENV_LEN

d72 1
a72 5
  /* getenv used for regular logical names */
#  define getenv(v) my_getenv(v,TRUE)
#endif
#ifdef getenv_len
#  undef getenv_len
a73 1
#define getenv_len(v,l) my_getenv_len(v,l,TRUE)
d86 61
a146 11
#define vmstrnenv		Perl_vmstrnenv
#define my_trnlnm		Perl_my_trnlnm
#define my_getenv_len		Perl_my_getenv_len
#define prime_env_iter	Perl_prime_env_iter
#define vmssetenv		Perl_vmssetenv
#if !defined(PERL_IMPLICIT_CONTEXT)
#define my_setenv		Perl_my_setenv
#define my_getenv		Perl_my_getenv
#else
#define my_setenv(a,b)		Perl_my_setenv(aTHX_ a,b)
#define my_getenv(a,b)		Perl_my_getenv(aTHX_ a,b)
a147 55
#define my_crypt		Perl_my_crypt
#define my_waitpid		Perl_my_waitpid
#define my_gconvert		Perl_my_gconvert
#define do_rmdir		Perl_do_rmdir
#define kill_file		Perl_kill_file
#define my_mkdir		Perl_my_mkdir
#define my_utime		Perl_my_utime
#define rmsexpand	Perl_rmsexpand
#define rmsexpand_ts	Perl_rmsexpand_ts
#define fileify_dirspec	Perl_fileify_dirspec
#define fileify_dirspec_ts	Perl_fileify_dirspec_ts
#define pathify_dirspec	Perl_pathify_dirspec
#define pathify_dirspec_ts	Perl_pathify_dirspec_ts
#define tounixspec		Perl_tounixspec
#define tounixspec_ts		Perl_tounixspec_ts
#define tovmsspec		Perl_tovmsspec
#define tovmsspec_ts		Perl_tovmsspec_ts
#define tounixpath		Perl_tounixpath
#define tounixpath_ts		Perl_tounixpath_ts
#define tovmspath		Perl_tovmspath
#define tovmspath_ts		Perl_tovmspath_ts
#define vms_image_init	Perl_vms_image_init
#define opendir		Perl_opendir
#define readdir		Perl_readdir
#define telldir		Perl_telldir
#define seekdir		Perl_seekdir
#define closedir		Perl_closedir
#define vmsreaddirversions	Perl_vmsreaddirversions
#define my_gmtime		Perl_my_gmtime
#define my_localtime		Perl_my_localtime
#define my_time		Perl_my_time
#define my_sigemptyset        Perl_my_sigemptyset
#define my_sigfillset         Perl_my_sigfillset
#define my_sigaddset          Perl_my_sigaddset
#define my_sigdelset          Perl_my_sigdelset
#define my_sigismember        Perl_my_sigismember
#define my_sigprocmask        Perl_my_sigprocmask
#define cando_by_name		Perl_cando_by_name
#define flex_fstat		Perl_flex_fstat
#define flex_stat		Perl_flex_stat
#define trim_unixpath		Perl_trim_unixpath
#define my_vfork		Perl_my_vfork
#define vms_do_aexec		Perl_vms_do_aexec
#define vms_do_exec		Perl_vms_do_exec
#define do_aspawn		Perl_do_aspawn
#define do_spawn		Perl_do_spawn
#define my_fwrite		Perl_my_fwrite
#define my_flush		Perl_my_flush
#define my_getpwnam		Perl_my_getpwnam
#define my_getpwuid		Perl_my_getpwuid
#define my_getpwent		Perl_my_getpwent
#define my_endpwent		Perl_my_endpwent
#define my_getlogin		Perl_my_getlogin
#define rmscopy		Perl_rmscopy
#define init_os_extras	Perl_init_os_extras
a187 10
/* Lower case entry points for these are missing in some earlier RTLs 
 * so we borrow the defines and declares from errno.h and upcase them.
 */
#if defined(VMS_WE_ARE_CASE_SENSITIVE) && (__DECC_VER < 50500000)
#  define errno      (*CMA$TIS_ERRNO_GET_ADDR())
#  define vaxc$errno (*CMA$TIS_VMSERRNO_GET_ADDR())
   int *CMA$TIS_ERRNO_GET_ADDR     (void);   /* UNIX style error code        */
   int *CMA$TIS_VMSERRNO_GET_ADDR  (void);   /* VMS error (errno == EVMSERR) */
#endif

d203 3
a205 3
#define HINT_M_VMSISH_HUSHED	0x20000000 /* stifle error msgs on exit */
#define HINT_M_VMSISH_STATUS	0x40000000 /* system, $? return VMS status */
#define HINT_M_VMSISH_TIME	0x80000000 /* times are local, not UTC */
a208 1
#define VMSISH_HUSHED	TEST_VMSISH(HINT_M_VMSISH_HUSHED)
d210 1
a212 3
/* Flags for vmstrnenv() */
#define PERL__TRNENV_SECURE 0x01

d217 1
a217 1
  Perl_croak(aTHX_ "Fatal VMS error (status=%d) at %s, line %d", \
d234 1
a234 1
#define PERL_SYS_TERM()		OP_REFCNT_TERM; MALLOC_TERM
a238 6
#define PERL_FS_VER_FMT		"%d_%d_%d"
/* Temporary; we need to add support for this to Configure.Com */
#ifdef PERL_INC_VERSION_LIST
#  undef PERL_INC_VERSION_LIST
#endif

d278 1
a278 1
 *	use the routine my_binmode(FILE *fp, char iotype, int mode) to insure
d282 1
a282 1
#undef USEMYBINMODE
d408 1
a408 2
#define ENVgetenv(v) my_getenv(v,FALSE)
#define ENVgetenv_len(v,l) my_getenv_len(v,l,FALSE)
a520 19

/*
 * DEC C previous to 6.0 corrupts the behavior of the /prefix
 * qualifier with the extern prefix pragma.  This provisional
 * hack circumvents this prefix pragma problem in previous 
 * precompilers.
 */
#if defined(__VMS_VER) && __VMS_VER >= 70000000
#  if defined(VMS_WE_ARE_CASE_SENSITIVE) && (__DECC_VER < 60000000)
#    pragma __extern_prefix save
#    pragma __extern_prefix ""  /* set to empty to prevent prefixing */
#    define geteuid decc$__unix_geteuid
#    define getuid decc$__unix_getuid
#    define stat(__p1,__p2)   decc$__utc_stat(__p1,__p2)
#    define fstat(__p1,__p2)  decc$__utc_fstat(__p1,__p2)
#    pragma __extern_prefix restore
#  endif
#endif

a539 1

d547 1
a547 1
 *    <data type><TAB>name<WHITESPACE>(<prototype args>);
d569 2
a570 2
void	prime_env_iter (void);
void	init_os_extras ();
d573 33
a605 40
int	vmstrnenv (const char *, char *, unsigned long int, struct dsc$descriptor_s **, unsigned long int);
int	my_trnlnm (const char *, char *, unsigned long int);
#if !defined(PERL_IMPLICIT_CONTEXT)
char *	Perl_my_getenv (const char *, bool);
#else
char *	Perl_my_getenv (pTHX_ const char *, bool);
#endif
char *	my_getenv_len (const char *, unsigned long *, bool);
int	vmssetenv (char *, char *, struct dsc$descriptor_s **);
char *	my_crypt (const char *, const char *);
Pid_t	my_waitpid (Pid_t, int *, int);
char *	my_gconvert (double, int, int, char *);
int	do_rmdir (char *);
int	kill_file (char *);
int	my_mkdir (char *, Mode_t);
int	my_utime (char *, struct utimbuf *);
char *	rmsexpand (char *, char *, char *, unsigned);
char *	rmsexpand_ts (char *, char *, char *, unsigned);
char *	fileify_dirspec (char *, char *);
char *	fileify_dirspec_ts (char *, char *);
char *	pathify_dirspec (char *, char *);
char *	pathify_dirspec_ts (char *, char *);
char *	tounixspec (char *, char *);
char *	tounixspec_ts (char *, char *);
char *	tovmsspec (char *, char *);
char *	tovmsspec_ts (char *, char *);
char *	tounixpath (char *, char *);
char *	tounixpath_ts (char *, char *);
char *	tovmspath (char *, char *);
char *	tovmspath_ts (char *, char *);
void	vms_image_init (int *, char ***);
DIR *	opendir (char *);
struct dirent *	readdir (DIR *);
long	telldir (DIR *);
void	seekdir (DIR *, long);
void	closedir (DIR *);
void	vmsreaddirversions (DIR *, int);
struct tm *	my_gmtime (const time_t *);
struct tm *	my_localtime (const time_t *);
time_t	my_time (time_t *);
d607 25
a631 24
int     my_sigemptyset (sigset_t *);
int     my_sigfillset  (sigset_t *);
int     my_sigaddset   (sigset_t *, int);
int     my_sigdelset   (sigset_t *, int);
int     my_sigismember (sigset_t *, int);
int     my_sigprocmask (int, sigset_t *, sigset_t *);
#endif
I32	cando_by_name (I32, Uid_t, char *);
int	flex_fstat (int, Stat_t *);
int	flex_stat (const char *, Stat_t *);
int	trim_unixpath (char *, char*, int);
int	my_vfork ();
bool	vms_do_aexec (SV *, SV **, SV **);
bool	vms_do_exec (char *);
unsigned long int	do_aspawn (void *, void **, void **);
unsigned long int	do_spawn (char *);
int	my_fwrite (void *, size_t, size_t, FILE *);
int	my_flush (FILE *);
struct passwd *	my_getpwnam (char *name);
struct passwd *	my_getpwuid (Uid_t uid);
struct passwd *	my_getpwent ();
void	my_endpwent ();
char *	my_getlogin ();
int	rmscopy (char *, char *, int);
d661 1
a661 4
/* The C RTL manual says to undef the macro for DEC C 5.2 and lower. */
#if defined(fileno) && defined(__DECC_VER) && __DECC_VER < 50300000
#  undef fileno 
#endif 
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d22 1
a22 1
#if defined(__DECC) || defined(__DECCXX)
d37 1
a37 1
#if defined(__ALPHA) && (defined(__DECC) || defined(__DECCXX))
d54 7
a60 2
#if (defined(__DECC) && defined(__DECC_VER) && __DECC_VER > 20000000) || defined(__DECCXX)
#  include <unistd.h> /* DECC has this; gcc doesn't */
d94 2
a99 2
#define my_trnlnm		Perl_my_trnlnm
#define vmstrnenv           	Perl_vmstrnenv            
a101 16
#define tounixspec		Perl_tounixspec
#define tounixspec_ts		Perl_tounixspec_ts
#define tovmsspec		Perl_tovmsspec
#define tovmsspec_ts		Perl_tovmsspec_ts
#define tounixpath		Perl_tounixpath
#define tounixpath_ts		Perl_tounixpath_ts
#define tovmspath		Perl_tovmspath
#define tovmspath_ts		Perl_tovmspath_ts
#define do_rmdir		Perl_do_rmdir
#define fileify_dirspec		Perl_fileify_dirspec
#define fileify_dirspec_ts	Perl_fileify_dirspec_ts
#define pathify_dirspec		Perl_pathify_dirspec
#define pathify_dirspec_ts	Perl_pathify_dirspec_ts
#define trim_unixpath		Perl_trim_unixpath
#define opendir			Perl_opendir
#define rmscopy			Perl_rmscopy
a102 2
#define my_trnlnm(a,b,c)	Perl_my_trnlnm(aTHX_ a,b,c)
#define vmstrnenv(a,b,c,d,e)	Perl_vmstrnenv(aTHX_ a,b,c,d,e)
a104 18
#define tounixspec(a,b)		Perl_tounixspec(aTHX_ a,b)
#define tounixspec_ts(a,b)	Perl_tounixspec_ts(aTHX_ a,b)
#define tovmsspec(a,b)		Perl_tovmsspec(aTHX_ a,b)
#define tovmsspec_t(a,b)	Perl_tovmsspec_ts(aTHX_ a,b)
#define tounixpath(a,b)		Perl_tounixpath(aTHX_ a,b)
#define tounixpath_ts(a,b)	Perl_tounixpath_ts(aTHX_ a,b)
#define tovmspath(a,b)		Perl_tovmspath(aTHX_ a,b)
#define tovmspath_ts(a,b)	Perl_tovmspath_ts(aTHX_ a,b)
#define do_rmdir(a)		Perl_do_rmdir(aTHX_ a)
#define fileify_dirspec(a,b)	Perl_fileify_dirspec(aTHX_ a,b)
#define fileify_dirspec_ts(a,b)	Perl_fileify_dirspec_ts(aTHX_ a,b)
#define pathify_dirspec		Perl_pathify_dirspec
#define pathify_dirspec_ts	Perl_pathify_dirspec_ts
#define rmsexpand(a,b,c,d)	Perl_rmsexpand(aTHX_ a,b,c,d)
#define rmsexpand_ts(a,b,c,d)	Perl_rmsexpand_ts(aTHX_ a,b,c,d)
#define trim_unixpath(a,b,c)	Perl_trim_unixpath(aTHX_ a,b,c)
#define opendir(a)		Perl_opendir(aTHX_ a)
#define rmscopy(a,b,c)		Perl_rmscopy(aTHX_ a,b,c)
d109 1
a111 2
#define my_chdir		Perl_my_chdir
#define my_tmpfile		Perl_my_tmpfile
d113 14
d128 1
d146 1
a151 2
#define my_fdopen               Perl_my_fdopen
#define my_fclose               Perl_my_fclose
d159 1
a176 10
/*
 * Toss in a shim to tmpfile which creates a plain temp file if the
 * RMS tmp mechanism won't work (e.g. if someone is relying on ACLs
 * from a specific directory to permit creation of files).
 */
#ifndef DONT_MASK_RTL_CALLS
#  define tmpfile my_tmpfile
#endif


a255 2
#define PERL_SOCK_SYSREAD_IS_RECV
#define PERL_SOCK_SYSWRITE_IS_SEND
a347 7

#ifndef DONT_MASK_RTL_CALLS
#  define fdopen my_fdopen
#  define fclose my_fclose
#endif


d357 5
d444 1
a444 1
/* Thin jacket around cuserid() to match Unix' calling sequence */
d447 1
a447 1
/* Ditto for sys$hash_password() . . . */
d450 1
a450 1
/* Tweak arg to mkdir & chdir first, so we can tolerate trailing /. */
a451 1
#define Chdir(dir) my_chdir((dir))
d509 1
a509 1
 * N.B. 2. The routine cando() in vms.c assumes that &stat.st_ino is the
d626 2
a629 20
int	Perl_vmstrnenv (const char *, char *, unsigned long int, struct dsc$descriptor_s **, unsigned long int);
int	Perl_my_trnlnm (const char *, char *, unsigned long int);
char *	Perl_tounixspec (char *, char *);
char *	Perl_tounixspec_ts (char *, char *);
char *	Perl_tovmsspec (char *, char *);
char *	Perl_tovmsspec_ts (char *, char *);
char *	Perl_tounixpath (char *, char *);
char *	Perl_tounixpath_ts (char *, char *);
char *	Perl_tovmspath (char *, char *);
char *	Perl_tovmspath_ts (char *, char *);
int	Perl_do_rmdir (char *);
char *	Perl_fileify_dirspec (char *, char *);
char *	Perl_fileify_dirspec_ts (char *, char *);
char *	Perl_pathify_dirspec (char *, char *);
char *	Perl_pathify_dirspec_ts (char *, char *);
char *	Perl_rmsexpand (char *, char *, char *, unsigned);
char *	Perl_rmsexpand_ts (char *, char *, char *, unsigned);
int	Perl_trim_unixpath (char *, char*, int);
DIR *	Perl_opendir (char *);
int	Perl_rmscopy (char *, char *, int);
a630 1
int	Perl_vmstrnenv (pTHX_ const char *, char *, unsigned long int, struct dsc$descriptor_s **, unsigned long int);
a631 19
int	Perl_my_trnlnm (pTHX_ const char *, char *, unsigned long int);
char *	Perl_tounixspec (pTHX_ char *, char *);
char *	Perl_tounixspec_ts (pTHX_ char *, char *);
char *	Perl_tovmsspec (pTHX_ char *, char *);
char *	Perl_tovmsspec_ts (pTHX_ char *, char *);
char *	Perl_tounixpath (pTHX_ char *, char *);
char *	Perl_tounixpath_ts (pTHX_ char *, char *);
char *	Perl_tovmspath (pTHX_ char *, char *);
char *	Perl_tovmspath_ts (pTHX_ char *, char *);
int	Perl_do_rmdir (pTHX_ char *);
char *	Perl_fileify_dirspec (pTHX_ char *, char *);
char *	Perl_fileify_dirspec_ts (pTHX_ char *, char *);
char *	Perl_pathify_dirspec (pTHX_ char *, char *);
char *	Perl_pathify_dirspec_ts (pTHX_ char *, char *);
char *	Perl_rmsexpand (pTHX_ char *, char *, char *, unsigned);
char *	Perl_rmsexpand_ts (pTHX_ char *, char *, char *, unsigned);
int	Perl_trim_unixpath (pTHX_ char *, char*, int);
DIR *	Perl_opendir (pTHX_ char *);
int	Perl_rmscopy (pTHX_ char *, char *, int);
a634 1
void	Perl_vmssetuserlnm(char *name, char *eqv);
d638 1
a640 2
int	my_chdir (char *);
FILE *	my_tmpfile (void);
d642 14
d657 1
d677 1
a682 2
FILE *  my_fdopen (int, char *);
int     my_fclose (FILE *);
d690 1
a723 2

#define NO_ENVIRON_ARRAY
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@a65 13
/* All this stiff is for the x2P programs. Hopefully they'll still work */
#if defined(PERL_FOR_X2P)
#ifndef aTHX_
#define aTHX_
#endif
#ifndef pTHX_
#define pTHX_
#endif
#ifndef pTHX
#define pTHX
#endif
#endif

d71 1
a71 1
#  define getenv(v) Perl_my_getenv(aTHX_ v,TRUE)
d76 1
a76 1
#define getenv_len(v,l) Perl_my_getenv_len(aTHX_ v,l,TRUE)
d89 1
d91 1
a91 3
#define vms_image_init	Perl_vms_image_init
#define my_tmpfile		Perl_my_tmpfile
#define vmstrnenv           	Perl_vmstrnenv            
a92 2
#define my_getenv_len		Perl_my_getenv_len
#define vmssetenv		Perl_vmssetenv
d94 1
a112 21
#define my_mkdir		Perl_my_mkdir
#define vms_do_aexec		Perl_vms_do_aexec
#define vms_do_exec		Perl_vms_do_exec
#define my_waitpid		Perl_my_waitpid
#define my_crypt		Perl_my_crypt
#define kill_file		Perl_kill_file
#define my_utime		Perl_my_utime
#define my_chdir		Perl_my_chdir
#define do_aspawn		Perl_do_aspawn
#define seekdir		Perl_seekdir
#define my_gmtime		Perl_my_gmtime
#define my_localtime		Perl_my_localtime
#define my_time		Perl_my_time
#define do_spawn		Perl_do_spawn
#define flex_fstat		Perl_flex_fstat
#define flex_stat		Perl_flex_stat
#define cando_by_name		Perl_cando_by_name
#define my_getpwnam		Perl_my_getpwnam
#define my_getpwuid		Perl_my_getpwuid
#define my_flush		Perl_my_flush
#define readdir			Perl_readdir
a113 2
#define my_getenv_len(a,b,c)	Perl_my_getenv_len(aTHX_ a,b,c)
#define vmssetenv(a,b,c)	Perl_vmssetenv(aTHX_ a,b,c)
d115 1
a135 21
#define my_mkdir(a,b)		Perl_my_mkdir(aTHX_ a,b)
#define vms_do_aexec(a,b,c)	Perl_vms_do_aexec(aTHX_ a,b,c)
#define vms_do_exec(a)		Perl_vms_do_exec(aTHX_ a)
#define my_waitpid(a,b,c)	Perl_my_waitpid(aTHX_ a,b,c)
#define my_crypt(a,b)		Perl_my_crypt(aTHX_ a,b)
#define kill_file(a)		Perl_kill_file(aTHX_ a)
#define my_utime(a,b)		Perl_my_utime(aTHX_ a,b)
#define my_chdir(a)		Perl_my_chdir(aTHX_ a)
#define do_aspawn(a,b,c)	Perl_do_aspawn(aTHX_ a,b,c)
#define seekdir(a,b)		Perl_seekdir(aTHX_ a,b)
#define my_gmtime(a)		Perl_my_gmtime(aTHX_ a)
#define my_localtime(a)		Perl_my_localtime(aTHX_ a)
#define my_time(a)		Perl_my_time(aTHX_ a)
#define do_spawn(a)		Perl_do_spawn(aTHX_ a)
#define flex_fstat(a,b)		Perl_flex_fstat(aTHX_ a,b)
#define cando_by_name(a,b,c)	Perl_cando_by_name(aTHX_ a,b,c)
#define flex_stat(a,b)		Perl_flex_stat(aTHX_ a,b)
#define my_getpwnam(a)		Perl_my_getpwnam(aTHX_ a)
#define my_getpwuid(a)		Perl_my_getpwuid(aTHX_ a)
#define my_flush(a)		Perl_my_flush(aTHX_ a)
#define readdir(a)		Perl_readdir(aTHX_ a)
d137 2
d140 7
d148 1
d151 3
d160 3
d164 4
d171 3
d200 1
a200 1
#  define tmpfile Perl_my_tmpfile
d253 1
d259 1
a262 10
/* VMS-specific data storage */

#define HAVE_INTERP_INTERN
struct interp_intern {
    int    hushed;
    double inv_rand_max;
};
#define VMSISH_HUSHED     (PL_sys_intern.hushed)
#define MY_INV_RAND_MAX   (PL_sys_intern.inv_rand_max)

d278 1
a278 1
  fprintf(stderr,"Fatal VMS error (status=%d) at %s, line %d", \
a378 1
#  define fwrite my_fwrite     /* for PerlSIO_fwrite */
a458 8
#else
/*
 * The C RTL's sigaction fails to check for invalid signal numbers so we 
 * help it out a bit.
 */
#  ifndef DONT_MASK_RTL_CALLS
#    define sigaction(a,b,c) Perl_my_sigaction(aTHX_ a,b,c)
#  endif
a459 4
#ifdef KILL_BY_SIGPRC
#  define kill  Perl_my_kill
#endif

d469 1
d479 1
a479 1
#define crypt(a,b)  Perl_my_crypt(aTHX_ a,b)
d482 1
a482 1
#define Mkdir(dir,mode) Perl_my_mkdir(aTHX_ (dir),(mode))
d487 1
a487 1
#define Fstat(fd,bufptr) Perl_flex_fstat(aTHX_ fd,bufptr)
a657 1
int	Perl_vmstrnenv (const char *, char *, unsigned long int, struct dsc$descriptor_s **, unsigned long int);
d660 1
a679 2
int	Perl_my_mkdir (char *, Mode_t);
bool	Perl_vms_do_aexec (SV *, SV **, SV **);
d681 1
a701 2
int	Perl_my_mkdir (pTHX_ char *, Mode_t);
bool	Perl_vms_do_aexec (pTHX_ SV *, SV **, SV **);
d703 5
a707 5
char *	Perl_my_getenv_len (pTHX_ const char *, unsigned long *, bool);
int	Perl_vmssetenv (pTHX_ char *, char *, struct dsc$descriptor_s **);
void	Perl_vmssetuserlnm(pTHX_ char *name, char *eqv);
char *	Perl_my_crypt (pTHX_ const char *, const char *);
Pid_t	Perl_my_waitpid (pTHX_ Pid_t, int *, int);
d709 7
a715 14
int	Perl_kill_file (pTHX_ char *);
int	Perl_my_chdir (pTHX_ char *);
FILE *	Perl_my_tmpfile ();
#ifndef HOMEGROWN_POSIX_SIGNALS
int	Perl_my_sigaction (pTHX_ int, const struct sigaction*, struct sigaction*);
#endif
#ifdef KILL_BY_SIGPRC
unsigned int	Perl_sig_to_vmscondition (int);
int	Perl_my_kill (int, int);
void	Perl_csighandler_init (void);
#endif
int	Perl_my_utime (pTHX_ char *, struct utimbuf *);
void	Perl_vms_image_init (int *, char ***);
struct dirent *	Perl_readdir (pTHX_ DIR *);
d717 1
a717 1
void	Perl_seekdir (pTHX_ DIR *, long);
d720 3
a722 3
struct tm *	Perl_my_gmtime (pTHX_ const time_t *);
struct tm *	Perl_my_localtime (pTHX_ const time_t *);
time_t	Perl_my_time (pTHX_ time_t *);
d731 3
a733 3
I32	Perl_cando_by_name (pTHX_ I32, Uid_t, char *);
int	Perl_flex_fstat (pTHX_ int, Stat_t *);
int	Perl_flex_stat (pTHX_ const char *, Stat_t *);
d735 5
a739 4
bool	Perl_vms_do_exec (pTHX_ char *);
unsigned long int	Perl_do_aspawn (pTHX_ void *, void **, void **);
unsigned long int	Perl_do_spawn (pTHX_ char *);
FILE *  my_fdopen (int, const char *);
d741 5
a745 4
int    my_fwrite (const void *, size_t, size_t, FILE *);
int	Perl_my_flush (pTHX_ FILE *);
struct passwd *	Perl_my_getpwnam (pTHX_ char *name);
struct passwd *	Perl_my_getpwuid (pTHX_ Uid_t uid);
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@a148 1
#define readdir_r		Perl_readdir_r
a193 1
#define readdir_r(a,b,c)	Perl_readdir_r(aTHX_ a,b,c)
a307 1
#define PERL__TRNENV_JOIN_SEARCHLIST 0x02
d331 1
a331 1
#define PERL_SYS_INIT(c,v)	MALLOC_CHECK_TAINT2(*c,*v) vms_image_init((c),(v)); MALLOC_INIT
a354 3
#if defined(__CRTL_VER) && __CRTL_VER >= 70000000
#define	HAS_IOCTL		/**/
#else
a355 1
#endif
a565 1
    void			*mutex;
a780 1
int	Perl_readdir_r(pTHX_ DIR *, struct dirent *, struct dirent **);
@


1.1.1.7
log
@perl 5.8.8 import
@
text
@d211 2
a212 2
#define my_getpwent()		Perl_my_getpwent(aTHX)
#define my_endpwent()		Perl_my_endpwent(aTHX)
a611 39
#ifdef USE_LARGE_FILES
/* Mimic the new stat structure, filler fields, and alignment. */
#if defined(__DECC) || defined(__DECCXX)
#  pragma __member_alignment __save
#  pragma member_alignment
#endif

struct mystat
{
        char *st_devnam;       /* pointer to device name */
        char *st_fill_dev;
        unsigned st_ino;        /* hack - CRTL uses unsigned short[3] for */
        unsigned short rvn;     /* FID (num,seq,rvn) */
        unsigned short st_fill_ino;
        unsigned short st_mode; /* file "mode" i.e. prot, dir, reg, etc. */
        unsigned short st_fill_mode;
        int     st_nlink;       /* for compatibility - not really used */
        unsigned st_uid;        /* from ACP - QIO uic field */
        unsigned short st_gid;  /* group number extracted from st_uid */
        unsigned short st_fill_gid;
        dev_t   st_rdev;        /* for compatibility - always zero */
        off_t   st_size;        /* file size in bytes */
        unsigned st_atime;      /* file access time; always same as st_mtime */
        unsigned st_fill_atime;
        unsigned st_mtime;      /* last modification time */
        unsigned st_fill_mtime;
        unsigned st_ctime;      /* file creation time */
        unsigned st_fill_ctime;
        char    st_fab_rfm;     /* record format */
        char    st_fab_rat;     /* record attributes */
        char    st_fab_fsz;     /* fixed header size */
        char    st_fab_fill;
        unsigned st_fab_mrs;    /* record size */
        int st_fill_expand[7];  /* will probably fill from beginning, so put our st_dev at end */
        unsigned st_dev;        /* encoded device name */
};

#else /* !defined(USE_LARGE_FILES) */

a620 1

a646 11

#if defined(__DECC) 
#  pragma __message __restore
#endif

#endif /* defined(USE_LARGE_FILES) */

#if defined(__DECC) || defined(__DECCXX)
#  pragma __member_alignment __restore
#endif

d676 6
d818 2
a819 2
void	Perl_my_endpwent (pTHX);
char *	my_getlogin (void);
@


1.1.1.8
log
@import perl 5.10.0 from CPAN
@
text
@d1 1
a1 1
/*    vmsish.h
d3 1
a3 1
 *    VMS-specific C header file for perl5.
d5 2
a6 7
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
 *    2002, 2003, 2004, 2005, 2006, 2007 by Charles Bailey and others.
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 *    Please see Changes*.* or the Perl Repository Browser for revision history.
a61 25
#include <namdef.h>

/* Set the maximum filespec size here as it is larger for EFS file
 * specifications.
 */
#ifndef __VAX
#ifndef VMS_MAXRSS
#ifdef NAML$C_MAXRSS
#define VMS_MAXRSS (NAML$C_MAXRSS+1)
#ifndef VMS_LONGNAME_SUPPORT
#define VMS_LONGNAME_SUPPORT 1
#endif /* VMS_LONGNAME_SUPPORT */
#endif /* NAML$C_MAXRSS */
#endif /* VMS_MAXRSS */
#endif

#ifndef VMS_MAXRSS
#define VMS_MAXRSS (NAM$C_MAXRSS + 1)
#endif

#ifndef MAXPATHLEN
#define MAXPATHLEN (VMS_MAXRSS - 1)
#endif


a113 2
#define tounixspec_utf8		Perl_tounixspec_utf8
#define tounixspec_utf8_ts	Perl_tounixspec_utf8_ts
a115 2
#define tovmsspec_utf8		Perl_tovmsspec_utf8
#define tovmsspec_utf8_ts	Perl_tovmsspec_utf8_ts
d118 1
a118 3
#define tounixpath_utf8		Perl_tounixpath_utf8
#define tounixpath_utf8_ts	Perl_tounixpath_utf8_ts
#define tovmspath		Perl_tovmspath 
a119 2
#define tovmspath_utf8		Perl_tovmspath_utf8
#define tovmspath_utf8_ts	Perl_tovmspath_utf8_ts
a122 2
#define fileify_dirspec_utf8	Perl_fileify_dirspec_utf8
#define fileify_dirspec_utf8_ts	Perl_fileify_dirspec_utf8_ts
a124 2
#define pathify_dirspec_utf8	Perl_pathify_dirspec_utf8
#define pathify_dirspec_utf8_ts	Perl_pathify_dirspec_utf8_ts
a126 1
#define rename			Perl_rename
a135 1
#define my_chmod		Perl_my_chmod
d137 1
a137 1
#define seekdir			Perl_seekdir
d140 1
a140 1
#define my_time			Perl_my_time
a143 1
#define flex_lstat		Perl_flex_lstat
a153 2
#define fileify_dirspec(a,b)	Perl_fileify_dirspec(aTHX_ a,b)
#define fileify_dirspec_ts(a,b)	Perl_fileify_dirspec_ts(aTHX_ a,b)
d156 8
a163 16
#define tounixspec(a,b)		Perl_tounixspec_utf8(aTHX_ a,b,NULL)
#define tounixspec_ts(a,b)	Perl_tounixspec_utf8_ts(aTHX_ a,b,NULL)
#define tounixspec_utf8(a,b,c)	Perl_tounixspec_utf8(aTHX_ a,b,c)
#define tounixspec_utf8_ts(a,b,c) Perl_tounixspec_utf8_ts(aTHX_ a,b,c)
#define tovmsspec(a,b)		Perl_tovmsspec_utf8(aTHX_ a,b,NULL)
#define tovmsspec_ts(a,b)	Perl_tovmsspec_utf8_ts(aTHX_ a,b)
#define tovmsspec_utf8(a,b,c)	Perl_tovmsspec_utf8(aTHX_ a,b,c)
#define tovmsspec_utf8_ts(a,b,c) Perl_tovmsspec_utf8_ts(aTHX_ a,b,c)
#define tounixpath(a,b)		Perl_tounixpath_utf8(aTHX_ a,b,NULL)
#define tounixpath_ts(a,b)	Perl_tounixpath_utf8_ts(aTHX_ a,b,NULL)
#define tounixpath_utf8(a,b,c)	Perl_tounixpath_utf8(aTHX_ a,b,c)
#define tounixpath_utf8_ts(a,b,c) Perl_tounixpath_utf8_ts(aTHX_ a,b,c)
#define tovmspath(a,b)		Perl_tovmspath_utf8(aTHX_ a,b,NULL)
#define tovmspath_ts(a,b)	Perl_tovmspath_utf8_ts(aTHX_ a,b,NULL)
#define tovmspath_utf8(a,b,c)	Perl_tovmspath_utf8(aTHX_ a,b,c)
#define tovmspath_utf8_ts(a,b,c) Perl_tovmspath_utf8_ts(aTHX_ a,b,c)
a166 2
#define fileify_dirspec_utf8(a,b,c) Perl_fileify_dirspec(aTHX_ a,b,utf8)
#define fileify_dirspec_utf8_ts(a,b,c) Perl_fileify_dirspec_ts(aTHX_ a,b,utf8)
d169 2
a170 6
#define pathify_dirspec_utf8	Perl_pathify_dirspec_utf8
#define pathify_dirspec_utf8_ts	Perl_pathify_dirspec_utf8_ts
#define rmsexpand(a,b,c,d)	Perl_rmsexpand_utf8(aTHX_ a,b,c,d,NULL,NULL)
#define rmsexpand_ts(a,b,c,d)	Perl_rmsexpand_utf8_ts(aTHX_ a,b,c,d,NULL,NULL)
#define rmsexpand_utf8(a,b,c,d,e,f) Perl_rmsexpand_utf8(aTHX_ a,b,c,d,e,f)
#define rmsexpand_utf8_ts(a,b,c,d,e,f) Perl_rmsexpand_utf8_ts(aTHX_ a,b,c,d,e,f)
a172 1
#define rename(a,b)		Perl_rename(aTHX_ a,b)
a181 1
#define my_chmod(a,b)		Perl_my_chmod(aTHX_ a,b)
a190 1
#define flex_lstat(a,b)		Perl_flex_lstat(aTHX_ a,b)
d198 1
a198 1
#define telldir			Perl_telldir
d214 1
a214 7
#ifdef HAS_SYMLINK
#  define my_symlink		Perl_my_symlink
#endif
#define init_os_extras		Perl_init_os_extras
#define vms_realpath(a, b, c)	Perl_vms_realpath(aTHX_ a,b,c)
#define vms_realname(a, b, c)	Perl_vms_realname(aTHX_ a,b,c)
#define vms_case_tolerant(a)	Perl_vms_case_tolerant(a)
a302 1
    int	   posix_exit;
a306 1
#define MY_POSIX_EXIT	(PL_sys_intern.posix_exit)
a332 1
#if __CRTL_VER < 70000000
d334 2
a335 5
#else
#define BIT_BUCKET "/dev/null"
#endif
#define PERL_SYS_INIT_BODY(c,v)	MALLOC_CHECK_TAINT2(*c,*v) vms_image_init((c),(v)); PERLIO_INIT; MALLOC_INIT
#define PERL_SYS_TERM_BODY()		HINTS_REFCNT_TERM; OP_REFCNT_TERM; PERLIO_TERM; MALLOC_TERM
a349 1
/* Note that code really should be using __VMS to comply with ANSI */
a415 6
*
*  No definition of what value an operating system or file system should
*  put in the st_rdev field has been found by me so far.  Examination of
*  LINUX source code indicates that the value is both very platform and
*  file system specific, with many filesystems just putting 1 or 0 in it.
*  J. Malmberg.
a431 3
#ifdef HAS_SYMLINK
#  define symlink my_symlink
#endif
a438 1
#ifndef DONT_MASK_RTL_CALLS
a439 1
#endif
a444 3
#ifdef I_UTIME
#include <utime.h>
#else
a449 2
#endif
#ifndef DONT_MASK_RTL_CALLS
a450 1
#endif
a545 3
#ifndef DONT_MASK_RTL_CALLS
#define chmod(file_spec, mode) my_chmod((file_spec), (mode))
#endif
a549 3
#ifndef DONT_MASK_RTL_CALLS
#define lstat(name, bufptr) flex_lstat(name, bufptr)
#endif
a554 1
 *
a555 6

/* Flags for the _dirdesc structure */
#define PERL_VMSDIR_M_VERSIONS		0x02 /* Want VMS versions */
#define PERL_VMSDIR_M_UNIXSPECS		0x04 /* Want UNIX specifications */


d559 1
a559 1
    int		d_namlen;		/* Length of d_name */
d568 1
a568 1
    int				flags;
a575 1

a610 4
 *
 * The simplest thing is to just put a wrapper around the stat structure
 * supplied by the CRTL and use #defines to redirect references to the
 * members to the real names.
d612 2
a613 1

d619 40
a658 5
typedef unsigned mydev_t;
#ifndef _LARGEFILE
typedef unsigned myino_t;
#else
typedef __ino64_t myino_t;
d663 23
a685 7
    struct stat crtl_stat;
    myino_t st_ino;
#ifndef _LARGEFILE
    unsigned rvn; /* FID (num,seq,rvn) + pad */
#endif
    mydev_t st_dev;
    char st_devnam[256]; /* Cache the (short) VMS name */
d688 2
a689 20
#define st_mode crtl_stat.st_mode
#define st_nlink crtl_stat.st_nlink
#define st_uid crtl_stat.st_uid
#define st_gid crtl_stat.st_gid
#define st_rdev crtl_stat.st_rdev
#define st_size crtl_stat.st_size
#define st_atime crtl_stat.st_atime
#define st_mtime crtl_stat.st_mtime
#define st_ctime crtl_stat.st_ctime
#define st_fab_rfm crtl_stat.st_fab_rfm
#define st_fab_rat crtl_stat.st_fab_rat
#define st_fab_fsz crtl_stat.st_fab_fsz
#define st_fab_mrs crtl_stat.st_fab_mrs

#ifdef _USE_STD_STAT
#define VMS_INO_T_COMPARE(__a, __b) (__a != __b)
#define VMS_INO_T_COPY(__a, __b) __a = __b
#else
#define VMS_INO_T_COMPARE(__a, __b) memcmp(&__a, &__b, 6)
#define VMS_INO_T_COPY(__a, __b) memcpy(&__a, &__b, 6)
d692 2
d698 3
d763 1
a763 3
void	init_os_extras (void);
int	Perl_vms_status_to_unix(int vms_status, int child_flag);
int	Perl_unix_status_to_vms(int unix_status);
a766 1
char *	Perl_vms_realpath (pTHX_ const char *, char *, int *);
a767 1
int	Perl_vms_case_tolerant(void);
d770 19
a788 34
char *	Perl_tounixspec (const char *, char *);
char *	Perl_tounixspec_ts (const char *, char *);
char *	Perl_tounixspec_utf8 (const char *, char *, int *);
char *	Perl_tounixspec_utf8_ts (const char *, char *, int *);
char *	Perl_tovmsspec (const char *, char *);
char *	Perl_tovmsspec_ts (const char *, char *);
char *	Perl_tovmsspec_utf8 (const char *, char *, int *);
char *	Perl_tovmsspec_utf8_ts (const char *, char *, int *);
char *	Perl_tounixpath (const char *, char *);
char *	Perl_tounixpath_ts (const char *, char *);
char *	Perl_tounixpath_utf8 (const char *, char *, int *);
char *	Perl_tounixpath_utf8_ts (const char *, char *, int *);
char *	Perl_tovmspath (const char *, char *);
char *	Perl_tovmspath_ts (const char *, char *);
char *	Perl_tovmspath_utf8 (const char *, char *, int *);
char *	Perl_tovmspath_utf8_ts (const char *, char *, int *);
int	Perl_do_rmdir (const char *);
char *	Perl_fileify_dirspec (const char *, char *);
char *	Perl_fileify_dirspec_ts (const char *, char *);
char *	Perl_fileify_dirspec_utf8 (const char *, char *, int *);
char *	Perl_fileify_dirspec_utf8_ts (const char *, char *, int *);
char *	Perl_pathify_dirspec (const char *, char *);
char *	Perl_pathify_dirspec_ts (const char *, char *);
char *	Perl_pathify_dirspec_utf8 (const char *, char *, int *);
char *	Perl_pathify_dirspec_utf8_ts (const char *, char *, int *);
char *	Perl_rmsexpand (const char *, char *, const char *, unsigned);
char *	Perl_rmsexpand_ts (const char *, char *, const char *, unsigned);
char *	Perl_rmsexpand_utf8 (const char *, char *, const char *, unsigned, int *, int *);
char *	Perl_rmsexpand_utf8_ts (const char *, char *, const char *, unsigned, int *, int *);
int	Perl_trim_unixpath (char *, const char*, int);
DIR  * Perl_opendir (const char *);
int 	Perl_rename(const char *, const char *);
int	Perl_rmscopy (const char *, const char *, int);
int	Perl_my_mkdir (const char *, Mode_t);
d793 19
a811 34
char *	Perl_tounixspec (pTHX_ const char *, char *);
char *	Perl_tounixspec_ts (pTHX_ const char *, char *);
char *	Perl_tounixspec_utf8 (pTHX_ const char *, char *, int *);
char *	Perl_tounixspec_utf8_ts (pTHX_ const char *, char *, int *);
char *	Perl_tovmsspec (pTHX_ const char *, char *);
char *	Perl_tovmsspec_ts (pTHX_ const char *, char *);
char *	Perl_tovmsspec_utf8 (pTHX_ const char *, char *, int *);
char *	Perl_tovmsspec_utf8_ts (pTHX_ const char *, char *, int *);
char *	Perl_tounixpath (pTHX_ const char *, char *);
char *	Perl_tounixpath_ts (pTHX_ const char *, char *);
char *	Perl_tounixpath_utf8 (pTHX_ const char *, char *, int *);
char *	Perl_tounixpath_utf8_ts (pTHX_ const char *, char *, int *);
char *	Perl_tovmspath (pTHX_ const char *, char *);
char *	Perl_tovmspath_ts (pTHX_ const char *, char *);
char *	Perl_tovmspath_utf8 (pTHX_ const char *, char *, int *);
char *	Perl_tovmspath_utf8_ts (pTHX_ const char *, char *, int *);
int	Perl_do_rmdir (pTHX_ const char *);
char *	Perl_fileify_dirspec (pTHX_ const char *, char *);
char *	Perl_fileify_dirspec_ts (pTHX_ const char *, char *);
char *	Perl_fileify_dirspec_utf8 (pTHX_ const char *, char *, int *);
char *	Perl_fileify_dirspec_utf8_ts (pTHX_ const char *, char *, int *);
char *	Perl_pathify_dirspec (pTHX_ const char *, char *);
char *	Perl_pathify_dirspec_ts (pTHX_ const char *, char *);
char *	Perl_pathify_dirspec_utf8 (pTHX_ const char *, char *, int *);
char *	Perl_pathify_dirspec_utf8_ts (pTHX_ const char *, char *, int *);
char *	Perl_rmsexpand (pTHX_ const char *, char *, const char *, unsigned);
char *	Perl_rmsexpand_ts (pTHX_ const char *, char *, const char *, unsigned);
char *	Perl_rmsexpand_utf8 (pTHX_ const char *, char *, const char *, unsigned, int *, int *);
char *	Perl_rmsexpand_utf8_ts (pTHX_ const char *, char *, const char *, unsigned, int *, int *);
int	Perl_trim_unixpath (pTHX_ char *, const char*, int);
DIR * Perl_opendir (pTHX_ const char *);
int	Perl_rename (pTHX_ const char *, const char *);
int	Perl_rmscopy (pTHX_ const char *, const char *, int);
int	Perl_my_mkdir (pTHX_ const char *, Mode_t);
a813 1
int	Perl_vms_case_tolerant(void);
d815 2
a816 2
int	Perl_vmssetenv (pTHX_ const char *, const char *, struct dsc$descriptor_s **);
void	Perl_vmssetuserlnm(pTHX_ const char *name, const char *eqv);
d820 3
a822 4
int	Perl_kill_file (pTHX_ const char *);
int	Perl_my_chdir (pTHX_ const char *);
int	Perl_my_chmod(pTHX_ const char *, mode_t);
FILE *	Perl_my_tmpfile (void);
d831 1
a831 1
int	Perl_my_utime (pTHX_ const char *, const struct utimbuf *);
d835 1
a835 1
long	Perl_telldir (DIR *);
d837 1
a837 1
void	Perl_closedir (DIR *);
d850 1
a850 1
I32	Perl_cando_by_name (pTHX_ I32, bool, const char *);
a851 1
int	Perl_flex_lstat (pTHX_ const char *, Stat_t *);
d853 2
a854 2
int	my_vfork (void);
bool	Perl_vms_do_exec (pTHX_ const char *);
d856 1
a856 1
unsigned long int	Perl_do_spawn (pTHX_ const char *);
d859 1
a859 4
int     my_fwrite (const void *, size_t, size_t, FILE *);
#ifdef HAS_SYMLINK
int     my_symlink(const char *path1, const char *path2);
#endif
d861 1
a861 1
struct passwd *	Perl_my_getpwnam (pTHX_ const char *name);
a899 6

/* RMSEXPAND options */
#define PERL_RMSEXPAND_M_VMS		0x02 /* Force output to VMS format */
#define PERL_RMSEXPAND_M_LONG		0x04 /* Expand to long name format */
#define PERL_RMSEXPAND_M_VMS_IN		0x08 /* Assume input is VMS already */
#define PERL_RMSEXPAND_M_SYMLINK	0x20 /* Use symbolic link, not target */
@


1.1.1.9
log
@import perl 5.10.1
@
text
@a135 1
#define my_fgetname(a, b)	Perl_my_fgetname(a, b)
d279 1
a279 1
#  define my_symlink(a, b)	Perl_my_symlink(aTHX_ a, b)
d364 1
a364 5
#ifdef PERL_IMPLICIT_CONTEXT
#  define TEST_VMSISH(h)	(my_perl && PL_curcop && (PL_curcop->op_private & ((h) >> HINT_V_VMSISH)))
#else
#  define TEST_VMSISH(h)	(PL_curcop && (PL_curcop->op_private & ((h) >> HINT_V_VMSISH)))
#endif
d416 1
a416 6
#ifndef PERL_CORE
#  define PERL_FS_VER_FMT	"%d_%d_%d"
#endif
#define PERL_FS_VERSION		STRINGIFY(PERL_REVISION) "_" \
				STRINGIFY(PERL_VERSION) "_" \
				STRINGIFY(PERL_SUBVERSION)
a451 3
#if __CRTL_VER >= 70302000
#define HAS_GROUP		/**/
#else
a452 1
#endif
a514 1
#  define fgetname(a, b) my_fgetname(a, b)
d965 2
a969 1
char *  Perl_my_fgetname (FILE *fp, char *buf);
d971 1
a971 1
int     Perl_my_symlink(pTHX_ const char *path1, const char *path2);
@


1.1.1.10
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d40 8
d96 12
a107 2

#ifndef PERL_FOR_X2P
d132 5
a136 1

d138 31
d171 11
d183 11
d197 37
d236 11
d248 11
d262 17
a278 42
#define closedir(a)		Perl_closedir(a)
#define telldir(a)		Perl_telldir(a)
#define vmsreaddirversions(a,b)	Perl_vmsreaddirversions(a,b)

#define cando_by_name(a,b,c)		Perl_cando_by_name(aTHX_ a,b,c)
#define do_rmdir(a)			Perl_do_rmdir(aTHX_ a)
#define fileify_dirspec(a,b)		Perl_fileify_dirspec(aTHX_ a,b)
#define fileify_dirspec(a,b)		Perl_fileify_dirspec(aTHX_ a,b)
#define fileify_dirspec_ts(a,b)		Perl_fileify_dirspec_ts(aTHX_ a,b)
#define fileify_dirspec_ts(a,b)		Perl_fileify_dirspec_ts(aTHX_ a,b)
#define fileify_dirspec_utf8(a,b,c)	Perl_fileify_dirspec(aTHX_ a,b,utf8)
#define fileify_dirspec_utf8_ts(a,b,c)	Perl_fileify_dirspec_ts(aTHX_ a,b,utf8)
#define flex_fstat(a,b)			Perl_flex_fstat(aTHX_ a,b)
#define flex_lstat(a,b)			Perl_flex_lstat(aTHX_ a,b)
#define flex_stat(a,b)			Perl_flex_stat(aTHX_ a,b)
#define init_os_extras			Perl_init_os_extras
#define kill_file(a)			Perl_kill_file(aTHX_ a)
#define my_chdir(a)			Perl_my_chdir(aTHX_ a)
#define my_chmod(a,b)			Perl_my_chmod(aTHX_ a,b)
#define my_crypt(a,b)			Perl_my_crypt(aTHX_ a,b)
#define my_endpwent()			Perl_my_endpwent(aTHX)
#define my_fclose(a)			Perl_my_fclose(a)
#define my_fdopen(a,b)			Perl_my_fdopen(a,b)
#define my_flush(a)			Perl_my_flush(aTHX_ a)
#define my_fwrite(a,b,c,d)		Perl_my_fwrite(a,b,c,d)
#define my_fgetname(a,b)		Perl_my_fgetname(a,b)
#define my_gconvert(a,b,c,d)		Perl_my_gconvert(a,b,c,d)
#define my_getenv(a,b)			Perl_my_getenv(aTHX_ a,b)
#define my_getenv_len(a,b,c)		Perl_my_getenv_len(aTHX_ a,b,c)
#define my_getlogin			Perl_my_getlogin
#define my_getpwent()			Perl_my_getpwent(aTHX)
#define my_getpwnam(a)			Perl_my_getpwnam(aTHX_ a)
#define my_getpwuid(a)			Perl_my_getpwuid(aTHX_ a)
#define my_gmtime(a)			Perl_my_gmtime(aTHX_ a)
#define my_localtime(a)			Perl_my_localtime(aTHX_ a)
#define my_mkdir(a,b)			Perl_my_mkdir(aTHX_ a,b)
#define my_sigemptyset(a)		Perl_my_sigemptyset(a)
#define my_sigfillset(a)		Perl_my_sigfillset(a)
#define my_sigaddset(a,b)		Perl_my_sigaddset(a,b)
#define my_sigdelset(a,b,c)		Perl_my_sigdelset(a,b,c)
#define my_sigismember(a,b)		Perl_my_sigismember(a,b)
#define my_sigprocmask(a,b,c)		Perl_my_sigprocmask(a,b,c)
d280 1
a280 1
#  define my_symlink(a,b)		Perl_my_symlink(aTHX_ a,b)
d282 4
a285 41
#define my_time(a)			Perl_my_time(aTHX_ a)
#define my_tmpfile			Perl_my_tmpfile
#define my_trnlnm(a,b,c)		Perl_my_trnlnm(aTHX_ a,b,c)
#define my_utime(a,b)			Perl_my_utime(aTHX_ a,b)
#define my_vfork			Perl_my_vfork
#define my_waitpid(a,b,c)		Perl_my_waitpid(aTHX_ a,b,c)
#define pathify_dirspec(a,b)		Perl_pathify_dirspec(aTHX a,b)
#define pathify_dirspec_ts(a,b)		Perl_pathify_dirspec_ts(aTHX a,b)
#define pathify_dirspec_utf8(a,b,c)	Perl_pathify_dirspec_utf8(aTHX a,b,c)
#define pathify_dirspec_utf8_ts(a,b,c)	Perl_pathify_dirspec_utf8_ts(aTHX a,b,c)
#define prime_env_iter			Perl_prime_env_iter
#define rmscopy(a,b,c)			Perl_rmscopy(aTHX_ a,b,c)
#define rmsexpand(a,b,c,d)		Perl_rmsexpand_utf8(aTHX_ a,b,c,d,NULL,NULL)
#define rmsexpand_ts(a,b,c,d)		Perl_rmsexpand_utf8_ts(aTHX_ a,b,c,d,NULL,NULL)
#define rmsexpand_utf8(a,b,c,d,e,f)	Perl_rmsexpand_utf8(aTHX_ a,b,c,d,e,f)
#define rmsexpand_utf8_ts(a,b,c,d,e,f)	Perl_rmsexpand_utf8_ts(aTHX_ a,b,c,d,e,f)
#define tounixpath(a,b)			Perl_tounixpath_utf8(aTHX_ a,b,NULL)
#define tounixpath_ts(a,b)		Perl_tounixpath_utf8_ts(aTHX_ a,b,NULL)
#define tounixpath_utf8(a,b,c)		Perl_tounixpath_utf8(aTHX_ a,b,c)
#define tounixpath_utf8_ts(a,b,c)	Perl_tounixpath_utf8_ts(aTHX_ a,b,c)
#define tounixspec(a,b)			Perl_tounixspec_utf8(aTHX_ a,b,NULL)
#define tounixspec_ts(a,b)		Perl_tounixspec_utf8_ts(aTHX_ a,b,NULL)
#define tounixspec_utf8(a,b,c)		Perl_tounixspec_utf8(aTHX_ a,b,c)
#define tounixspec_utf8_ts(a,b,c)	Perl_tounixspec_utf8_ts(aTHX_ a,b,c)
#define tovmspath(a,b)			Perl_tovmspath_utf8(aTHX_ a,b,NULL)
#define tovmspath_ts(a,b)		Perl_tovmspath_utf8_ts(aTHX_ a,b,NULL)
#define tovmspath_utf8(a,b,c)		Perl_tovmspath_utf8(aTHX_ a,b,c)
#define tovmspath_utf8_ts(a,b,c)	Perl_tovmspath_utf8_ts(aTHX_ a,b,c)
#define tovmsspec(a,b)			Perl_tovmsspec_utf8(aTHX_ a,b,NULL)
#define tovmsspec_ts(a,b)		Perl_tovmsspec_utf8_ts(aTHX_ a,b)
#define tovmsspec_utf8(a,b,c)		Perl_tovmsspec_utf8(aTHX_ a,b,c)
#define tovmsspec_utf8_ts(a,b,c)	Perl_tovmsspec_utf8_ts(aTHX_ a,b,c)
#define trim_unixpath(a,b,c)		Perl_trim_unixpath(aTHX_ a,b,c)
#define vms_do_aexec(a,b,c)		Perl_vms_do_aexec(aTHX_ a,b,c)
#define vms_do_exec(a)			Perl_vms_do_exec(aTHX_ a)
#define vms_case_tolerant(a)		Perl_vms_case_tolerant(a)
#define vms_image_init(a,b)		Perl_vms_image_init(a,b)
#define vms_realname(a,b,c)		Perl_vms_realname(aTHX_ a,b,c)
#define vms_realpath(a,b,c)		Perl_vms_realpath(aTHX_ a,b,c)
#define vmssetenv(a,b,c)		Perl_vmssetenv(aTHX_ a,b,c)
#define vmstrnenv(a,b,c,d,e)		Perl_vmstrnenv(a,b,c,d,e)
d288 1
a288 1
#define unlink(a) kill_file(a)
a309 1
#endif
d336 10
d405 1
d410 3
d414 1
d445 1
d447 3
d587 33
d624 1
a624 1
#ifndef DONT_MASK_RTL_CALLS
d626 1
d789 18
a820 1
#ifndef PERL_FOR_X2P
d824 5
d831 19
d854 2
d858 40
d935 1
d947 1
d949 1
d966 8
d992 16
@


1.1.1.11
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d27 1
a27 1
#ifdef __DECC
a29 3
#ifdef __DECCXX
#  pragma message informational (INTSIGNCHANGE,CASTQUALTYP,ASSCOMMEA,NOCTOBUTCONREFM)
#endif
a213 1
#define vmssetuserlnm(a,b)		Perl_vmssetuserlnm(a,b)
d309 1
a309 1
#define _ckvmssts(call) STMT_START { unsigned long int __ckvms_sts; \
d317 1
a317 1
#define _ckvmssts_noperl(call) STMT_START { unsigned long int __ckvms_sts; \
d320 2
a321 2
  (void)fprintf(stderr,"Fatal VMS error (status=%d) at %s, line %d", \
  __ckvms_sts,__FILE__,__LINE__); (void)lib$signal(__ckvms_sts); } } STMT_END
a684 4
#ifdef __cplusplus
extern "C" {
#endif

d731 1
a731 1
void	Perl_vmssetuserlnm(const char *name, const char *eqv);
a773 5

#ifdef __cplusplus
}
#endif

@


1.1.1.12
log
@Import perl-5.20.1
@
text
@d475 4
a478 3
/* tbuffer_t was replaced with struct tms in v7.0.  We no longer support
 * systems prior to v7.0, but there could be old XS code out there that
 * references tbuffer_t, so provide a compatibility macro.
d481 11
a491 1
#define tbuffer_t struct tms
@


