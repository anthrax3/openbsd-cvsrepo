head	1.9;
access;
symbols
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	PERL_5_10_1:1.1.1.7
	OPENBSD_4_6:1.7.0.6
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	PERL_5_10_0:1.1.1.6
	OPENBSD_4_4:1.6.0.24
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.22
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.20
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.18
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.16
	OPENBSD_4_0_BASE:1.6
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.6.0.14
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.12
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.10
	OPENBSD_3_7_BASE:1.6
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.6.0.8
	OPENBSD_3_6_BASE:1.6
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.6.0.6
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;


1.9
date	2010.09.24.15.00.02;	author millert;	state dead;
branches;
next	1.8;

1.8
date	2009.10.12.18.30.28;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.29.17.36.21;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.39;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.36.31;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.08.53;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.49;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.06.31;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.31;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.31;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.42.10;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.11.03;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.26.11;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.12;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.29.17.19.04;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2009.10.12.18.10.47;	author millert;	state Exp;
branches;
next	;


desc
@@


1.9
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@/* VMS::Stdio - VMS extensions to stdio routines 
 *
 * Version:  2.3
 * Author:   Charles Bailey  bailey@@newman.upenn.edu
 * Revised:  14-Jun-2007
 *
 */

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include <file.h>
#include <iodef.h>
#include <rms.h>
#include <starlet.h>

static bool
constant(name, pval)
char *name;
IV *pval;
{
    if (strnNE(name, "O_", 2)) return FALSE;

    if (strEQ(name, "O_APPEND"))
#ifdef O_APPEND
	{ *pval = O_APPEND; return TRUE; }
#else
	return FALSE;
#endif
    if (strEQ(name, "O_CREAT"))
#ifdef O_CREAT
	{ *pval = O_CREAT; return TRUE; }
#else
	return FALSE;
#endif
    if (strEQ(name, "O_EXCL"))
#ifdef O_EXCL
	{ *pval = O_EXCL; return TRUE; }
#else
	return FALSE;
#endif
    if (strEQ(name, "O_NDELAY"))
#ifdef O_NDELAY
	{ *pval = O_NDELAY; return TRUE; }
#else
	return FALSE;
#endif
    if (strEQ(name, "O_NOWAIT"))
#ifdef O_NOWAIT
	{ *pval = O_NOWAIT; return TRUE; }
#else
	return FALSE;
#endif
    if (strEQ(name, "O_RDONLY"))
#ifdef O_RDONLY
	{ *pval = O_RDONLY; return TRUE; }
#else
	return FALSE;
#endif
    if (strEQ(name, "O_RDWR"))
#ifdef O_RDWR
	{ *pval = O_RDWR; return TRUE; }
#else
	return FALSE;
#endif
    if (strEQ(name, "O_TRUNC"))
#ifdef O_TRUNC
	{ *pval = O_TRUNC; return TRUE; }
#else
	return FALSE;
#endif
    if (strEQ(name, "O_WRONLY"))
#ifdef O_WRONLY
	{ *pval = O_WRONLY; return TRUE; }
#else
	return FALSE;
#endif

    return FALSE;
}


static SV *
newFH(PerlIO *fp, char type) {
    SV *rv;
    GV **stashp, *gv = (GV *)newSV(0);
    HV *stash;
    IO *io;

    /* Find stash for VMS::Stdio.  We don't do this once at boot
     * to allow for possibility of threaded Perl with per-thread
     * symbol tables.  This code (through io = ...) is really
     * equivalent to gv_fetchpv("VMS::Stdio::__FH__",TRUE,SVt_PVIO),
     * with a little less overhead, and good exercise for me. :-) */
    stashp = (GV **)hv_fetch(PL_defstash,"VMS::",5,TRUE);
    if (!stashp || *stashp == (GV *)&PL_sv_undef) return NULL;
    if (!(stash = GvHV(*stashp))) stash = GvHV(*stashp) = newHV();
    stashp = (GV **)hv_fetch(GvHV(*stashp),"Stdio::",7,TRUE);
    if (!stashp || *stashp == (GV *)&PL_sv_undef) return NULL;
    if (!(stash = GvHV(*stashp))) stash = GvHV(*stashp) = newHV();

    /* Set up GV to point to IO, and then take reference */
    gv_init(gv,stash,"__FH__",6,0);
    io = GvIOp(gv) = newIO();
    IoIFP(io) = fp;
    if (type != '<') IoOFP(io) = fp;
    IoTYPE(io) = type;
    rv = newRV((SV *)gv);
    SvREFCNT_dec(gv);
    return sv_bless(rv,stash);
}

MODULE = VMS::Stdio  PACKAGE = VMS::Stdio

void
constant(name)
	char *	name
	PROTOTYPE: $
	CODE:
	IV i;
	if (constant(name, &i))
	    ST(0) = sv_2mortal(newSViv(i));
	else
	    ST(0) = &PL_sv_undef;

void
binmode(fh)
	SV *	fh
	PROTOTYPE: $
	CODE:
           SV *name;
	   IO *io;
	   char iotype;
	   char filespec[NAM$C_MAXRSS], *acmode, *s, *colon, *dirend = NULL;
	   int ret = 0, saverrno = errno, savevmserrno = vaxc$errno;
           SV pos;
           PerlIO *fp;
	   io = sv_2io(fh);
           fp = io ? IoOFP(io) : NULL;
	   iotype = io ? IoTYPE(io) : '\0';
	    if (fp == NULL || strchr(">was+-|",iotype) == NULL) {
	      set_errno(EBADF); set_vaxc_errno(SS$_IVCHAN); XSRETURN_UNDEF;
	    }
           if (!PerlIO_getname(fp,filespec)) XSRETURN_UNDEF;
	    for (s = filespec; *s; s++) {
	      if (*s == ':') colon = s;
	      else if (*s == ']' || *s == '>') dirend = s;
	    }
	    /* Looks like a tmpfile, which will go away if reopened */
	    if (s == dirend + 3) {
	      set_errno(EBADF); set_vaxc_errno(RMS$_IOP); XSRETURN_UNDEF;
	    }
	    /* If we've got a non-file-structured device, clip off the trailing
	     * junk, and don't lose sleep if we can't get a stream position.  */
	    if (dirend == NULL) *(colon+1) = '\0'; 
           if (iotype != '-' && (ret = PerlIO_getpos(fp, &pos)) == -1 && dirend)
	      XSRETURN_UNDEF;
	    switch (iotype) {
	      case '<': case 'r':           acmode = "rb";                      break;
	      case '>': case 'w': case '|':
	        /* use 'a' instead of 'w' to avoid creating new file;
	           fsetpos below will take care of restoring file position */
	      case 'a':                     acmode = "ab";                      break;
	      case '+':  case 's':          acmode = "rb+";                     break;
             case '-':                     acmode = PerlIO_fileno(fp) ? "ab" : "rb";  break;
	      /* iotype'll be null for the SYS$INPUT:/SYS$OUTPUT:/SYS$ERROR: files */
	      /* since we didn't really open them and can't really */
	      /* reopen them */
	      case 0:                       XSRETURN_UNDEF;
	      default:
	        if (PL_dowarn) warn("Unrecognized iotype %c for %s in binmode",
	                         iotype, filespec);
	        acmode = "rb+";
	    }
           /* appearances to the contrary, this is an freopen substitute */
           name = sv_2mortal(newSVpvn(filespec,strlen(filespec)));
           if (PerlIO_openn(aTHX_ NULL,acmode,-1,0,0,fp,1,&name) == NULL) XSRETURN_UNDEF;
           if (iotype != '-' && ret != -1 && PerlIO_setpos(fp,&pos) == -1) XSRETURN_UNDEF;
	    if (ret == -1) { set_errno(saverrno); set_vaxc_errno(savevmserrno); }
	    XSRETURN_YES;


void
flush(fp)
       PerlIO * fp
	PROTOTYPE: $
	CODE:
           FILE *stdio = PerlIO_exportFILE(fp,0);
           if (fflush(stdio)) { ST(0) = &PL_sv_undef; }
           else            { clearerr(stdio); ST(0) = &PL_sv_yes; }
           PerlIO_releaseFILE(fp,stdio);

char *
getname(fp)
	PerlIO * fp
	PROTOTYPE: $
	CODE:
            FILE *stdio = PerlIO_exportFILE(fp,0);
	    char fname[NAM$C_MAXRSS+1];
	    ST(0) = sv_newmortal();
            if (fgetname(stdio,fname) != NULL) sv_setpv(ST(0),fname);
            PerlIO_releaseFILE(fp,stdio);

void
rewind(fp)
       PerlIO * fp
	PROTOTYPE: $
	CODE:
           FILE *stdio = PerlIO_exportFILE(fp,0);
           ST(0) = rewind(stdio) ? &PL_sv_undef : &PL_sv_yes;
           PerlIO_releaseFILE(fp,stdio);

void
remove(name)
	char *name
	PROTOTYPE: $
	CODE:
	    ST(0) = remove(name) ? &PL_sv_undef : &PL_sv_yes;

void
setdef(...)
	PROTOTYPE: @@
	CODE:
	    char vmsdef[NAM$C_MAXRSS+1], es[NAM$C_MAXRSS], sep;
	    unsigned long int retsts;
	    struct FAB deffab = cc$rms_fab;
	    struct NAM defnam = cc$rms_nam;
	    struct dsc$descriptor_s dirdsc = {0, DSC$K_DTYPE_T, DSC$K_CLASS_S, 0};
	    STRLEN n_a;
	    if (items) {
		SV *defsv = ST(items-1);  /* mimic chdir() */
		ST(0) = &PL_sv_undef;
		if (!SvPOK(defsv)) { SETERRNO(EINVAL,LIB$_INVARG); XSRETURN(1); }
		if (tovmsspec(SvPV(defsv,n_a),vmsdef) == NULL) { XSRETURN(1); }
		deffab.fab$l_fna = vmsdef; deffab.fab$b_fns = strlen(vmsdef);
	    }
	    else {
		deffab.fab$l_fna = "SYS$LOGIN"; deffab.fab$b_fns = 9;
		EXTEND(sp,1);  ST(0) = &PL_sv_undef;
	    }
	    defnam.nam$l_esa = es;  defnam.nam$b_ess = sizeof es;
	    deffab.fab$l_nam = &defnam;
	    retsts = sys$parse(&deffab,0,0);
	    if (retsts & 1) {
		if (defnam.nam$v_wildcard) retsts = RMS$_WLD;
		else if (defnam.nam$b_name || defnam.nam$b_type > 1 ||
	             defnam.nam$b_ver > 1) retsts = RMS$_DIR;
		}
	    defnam.nam$b_nop |= NAM$M_SYNCHK; defnam.nam$l_rlf = NULL; deffab.fab$b_dns = 0;
	    if (!(retsts & 1)) {
		set_vaxc_errno(retsts);
		switch (retsts) {
		    case RMS$_DNF:
			set_errno(ENOENT); break;
		    case RMS$_SYN: case RMS$_DIR: case RMS$_DEV:
			set_errno(EINVAL); break;
		    case RMS$_PRV:
			set_errno(EACCES); break;
		    default:
			set_errno(EVMSERR); break;
		}
		(void) sys$parse(&deffab,0,0);  /* free up context */
		XSRETURN(1);
	    }
	    sep = *defnam.nam$l_dir;
	    *defnam.nam$l_dir = '\0';
	    my_setenv("SYS$DISK",defnam.nam$b_node ? defnam.nam$l_node : defnam.nam$l_dev);
	    *defnam.nam$l_dir = sep;
	    dirdsc.dsc$a_pointer = defnam.nam$l_dir; dirdsc.dsc$w_length = defnam.nam$b_dir;
	    if ((retsts = sys$setddir(&dirdsc,0,0)) & 1) ST(0) = &PL_sv_yes;
	    else { set_errno(EVMSERR); set_vaxc_errno(retsts); }
	    (void) sys$parse(&deffab,0,0);  /* free up context */

void
sync(fp)
       PerlIO * fp
	PROTOTYPE: $
	CODE:
           FILE *stdio = PerlIO_exportFILE(fp,0);
           if (fsync(fileno(stdio))) { ST(0) = &PL_sv_undef; }
           else                   { clearerr(stdio); ST(0) = &PL_sv_yes; }
           PerlIO_releaseFILE(fp,stdio);

char *
tmpnam()
	PROTOTYPE:
	CODE:
	    char fname[L_tmpnam];
	    ST(0) = sv_newmortal();
	    if (tmpnam(fname) != NULL) sv_setpv(ST(0),fname);

void
vmsopen(spec,...)
	char *	spec
	PROTOTYPE: @@
	CODE:
	    char *args[8],mode[3] = {'r','\0','\0'}, type = '<';
	    register int i, myargc;
	    FILE *fp;
            SV *fh;
           PerlIO *pio_fp;
	    STRLEN n_a;
	
	    if (!spec || !*spec) {
	       SETERRNO(EINVAL,LIB$_INVARG);
	       XSRETURN_UNDEF;
	    }
	    if (items > 9) croak("too many args");
	
	    /* First, set up name and mode args from perl's string */
	    if (*spec == '+') {
	      mode[1] = '+';
	      spec++;
	    }
	    if (*spec == '>') {
	      if (*(spec+1) == '>') *mode = 'a', spec += 2;
	      else *mode = 'w',  spec++;
	    }
	    else if (*spec == '<') spec++;
	    myargc = items - 1;
	    for (i = 0; i < myargc; i++) args[i] = SvPV(ST(i+1),n_a);
	    /* This hack brought to you by C's opaque arglist management */
	    switch (myargc) {
	      case 0:
	        fp = fopen(spec,mode);
	        break;
	      case 1:
	        fp = fopen(spec,mode,args[0]);
	        break;
	      case 2:
	        fp = fopen(spec,mode,args[0],args[1]);
	        break;
	      case 3:
	        fp = fopen(spec,mode,args[0],args[1],args[2]);
	        break;
	      case 4:
	        fp = fopen(spec,mode,args[0],args[1],args[2],args[3]);
	        break;
	      case 5:
	        fp = fopen(spec,mode,args[0],args[1],args[2],args[3],args[4]);
	        break;
	      case 6:
	        fp = fopen(spec,mode,args[0],args[1],args[2],args[3],args[4],args[5]);
	        break;
	      case 7:
	        fp = fopen(spec,mode,args[0],args[1],args[2],args[3],args[4],args[5],args[6]);
	        break;
	      case 8:
	        fp = fopen(spec,mode,args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7]);
	        break;
	    }
	    if (fp != NULL) {
             pio_fp = PerlIO_fdopen(fileno(fp),mode);
             fh = newFH(pio_fp,(mode[1] ? '+' : (mode[0] == 'r' ? '<' : (mode[0] == 'a' ? 'a' : '>'))));
	     ST(0) = (fh ? sv_2mortal(fh) : &PL_sv_undef);
	    }
	    else { ST(0) = &PL_sv_undef; }

void
vmssysopen(spec,mode,perm,...)
	char *	spec
	int	mode
	int	perm
	PROTOTYPE: @@
	CODE:
	    char *args[8];
	    int i, myargc, fd;
	    PerlIO *pio_fp;
	    SV *fh;
	    STRLEN n_a;
	    if (!spec || !*spec) {
	       SETERRNO(EINVAL,LIB$_INVARG);
	       XSRETURN_UNDEF;
	    }
	    if (items > 11) croak("too many args");
	    myargc = items - 3;
	    for (i = 0; i < myargc; i++) args[i] = SvPV(ST(i+3),n_a);
	    /* More fun with C calls; can't combine with above because
	       args 2,3 of different types in fopen() and open() */
	    switch (myargc) {
	      case 0:
	        fd = open(spec,mode,perm);
	        break;
	      case 1:
	        fd = open(spec,mode,perm,args[0]);
	        break;
	      case 2:
	        fd = open(spec,mode,perm,args[0],args[1]);
	        break;
	      case 3:
	        fd = open(spec,mode,perm,args[0],args[1],args[2]);
	        break;
	      case 4:
	        fd = open(spec,mode,perm,args[0],args[1],args[2],args[3]);
	        break;
	      case 5:
	        fd = open(spec,mode,perm,args[0],args[1],args[2],args[3],args[4]);
	        break;
	      case 6:
	        fd = open(spec,mode,perm,args[0],args[1],args[2],args[3],args[4],args[5]);
	        break;
	      case 7:
	        fd = open(spec,mode,perm,args[0],args[1],args[2],args[3],args[4],args[5],args[6]);
	        break;
	      case 8:
	        fd = open(spec,mode,perm,args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7]);
	        break;
	    }
	    i = mode & 3;
	    if (fd >= 0 &&
              ((pio_fp = PerlIO_fdopen(fd, &("r\000w\000r+"[2*i]))) != NULL)) {
             fh = newFH(pio_fp,"<>++"[i]);
	     ST(0) = (fh ? sv_2mortal(fh) : &PL_sv_undef);
	    }
	    else { ST(0) = &PL_sv_undef; }

void
waitfh(fp)
       PerlIO * fp
	PROTOTYPE: $
	CODE:
           FILE *stdio = PerlIO_exportFILE(fp,0);
           ST(0) = fwait(stdio) ? &PL_sv_undef : &PL_sv_yes;
           PerlIO_releaseFILE(fp,stdio);

void
writeof(mysv)
	SV *	mysv
	PROTOTYPE: $
	CODE:
	    char devnam[257], *cp;
	    unsigned long int chan, iosb[2], retsts, retsts2;
	    struct dsc$descriptor devdsc = {0, DSC$K_DTYPE_T, DSC$K_CLASS_S, devnam};
	    IO *io = sv_2io(mysv);
           PerlIO *fp = io ? IoOFP(io) : NULL;
	    if (fp == NULL || strchr(">was+-|",IoTYPE(io)) == NULL) {
	      set_errno(EBADF); set_vaxc_errno(SS$_IVCHAN); XSRETURN_UNDEF;
	    }
           if (PerlIO_getname(fp,devnam) == NULL) { ST(0) = &PL_sv_undef; XSRETURN(1); }
	    if ((cp = strrchr(devnam,':')) != NULL) *(cp+1) = '\0';
	    devdsc.dsc$w_length = strlen(devnam);
	    retsts = sys$assign(&devdsc,&chan,0,0);
	    if (retsts & 1) retsts = sys$qiow(0,chan,IO$_WRITEOF,iosb,0,0,0,0,0,0,0,0);
	    if (retsts & 1) retsts = iosb[0];
	    retsts2 = sys$dassgn(chan);  /* Be sure to deassign the channel */
	    if (retsts & 1) retsts = retsts2;
	    if (retsts & 1) { ST(0) = &PL_sv_yes; }
	    else {
	      set_vaxc_errno(retsts);
	      switch (retsts) {
	        case SS$_EXQUOTA:  case SS$_INSFMEM:  case SS$_MBFULL:
	        case SS$_MBTOOSML: case SS$_NOIOCHAN: case SS$_NOLINKS:
	        case SS$_BUFFEROVF:
	          set_errno(ENOSPC); break;
	        case SS$_ILLIOFUNC: case SS$_DEVOFFLINE: case SS$_NOSUCHDEV:
	          set_errno(EBADF);  break;
	        case SS$_NOPRIV:
	          set_errno(EACCES); break;
	        default:  /* Includes "shouldn't happen" cases that might map */
	          set_errno(EVMSERR); break;         /* to other errno values */
	      }
	      ST(0) = &PL_sv_undef;
	    }
@


1.8
log
@Merge in perl 5.10.1; part two
@
text
@@


1.7
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d96 1
a96 1
    if (!stashp || *stashp == (GV *)&PL_sv_undef) return Nullsv;
d99 1
a99 1
    if (!stashp || *stashp == (GV *)&PL_sv_undef) return Nullsv;
d134 1
a134 1
	   char filespec[NAM$C_MAXRSS], *acmode, *s, *colon, *dirend = Nullch;
d141 1
a141 1
	    if (fp == NULL || strchr(">was+-|",iotype) == Nullch) {
d155 1
a155 1
	    if (dirend == Nullch) *(colon+1) = '\0'; 
d177 1
a177 1
           if (PerlIO_openn(aTHX_ Nullch,acmode,-1,0,0,fp,1,&name) == Nullfp) XSRETURN_UNDEF;
d352 1
a352 1
           if (fp != Null(FILE*)) {
d411 1
a411 1
              ((pio_fp = PerlIO_fdopen(fd, &("r\000w\000r+"[2*i]))) != Null(PerlIO*))) {
d436 1
a436 1
	    if (fp == NULL || strchr(">was+-|",IoTYPE(io)) == Nullch) {
d439 1
a439 1
           if (PerlIO_getname(fp,devnam) == Nullch) { ST(0) = &PL_sv_undef; XSRETURN(1); }
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 1
a3 1
 * Version:  2.2
d5 1
a5 1
 * Revised:  18-Jul-1998
d86 1
a86 1
    GV **stashp, *gv = (GV *)NEWSV(0,0);
d195 1
a195 1
       PerlIO * fp
d198 1
d201 2
a202 1
           if (PerlIO_getname(fp,fname) != NULL) sv_setpv(ST(0),fname);
d353 1
a353 1
             pio_fp = PerlIO_importFILE(fp,mode);
d368 1
a368 2
	    FILE *fp;
           PerlIO *pio_fp;
d411 1
a411 2
              ((fp = fdopen(fd, &("r\000w\000r+"[2*i]))) != Null(FILE*))) {
             pio_fp = PerlIO_importFILE(fp,&("r\000w\000r+"[2*i]));
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d84 1
a84 1
newFH(FILE *fp, char type) {
d131 10
a140 6
	    IO *io = sv_2io(fh);
	    FILE *fp = io ? IoOFP(io) : NULL;
	    char iotype = io ? IoTYPE(io) : '\0';
	    char filespec[NAM$C_MAXRSS], *acmode, *s, *colon, *dirend = Nullch;
	    int ret = 0, saverrno = errno, savevmserrno = vaxc$errno;
	    fpos_t pos;
d144 1
a144 1
	    if (!fgetname(fp,filespec)) XSRETURN_UNDEF;
d156 1
a156 1
	    if (iotype != '-' && (ret = fgetpos(fp, &pos)) == -1 && dirend)
d165 1
a165 1
	      case '-':                     acmode = fileno(fp) ? "ab" : "rb";  break;
d175 4
a178 2
	    if (freopen(filespec,acmode,fp) == NULL) XSRETURN_UNDEF;
	    if (iotype != '-' && ret != -1 && fsetpos(fp,&pos) == -1) XSRETURN_UNDEF;
d185 1
a185 1
	FILE *	fp
d188 4
a191 2
	    if (fflush(fp)) { ST(0) = &PL_sv_undef; }
	    else            { clearerr(fp); ST(0) = &PL_sv_yes; }
d195 1
a195 1
	FILE *	fp
d200 1
a200 1
	    if (fgetname(fp,fname) != NULL) sv_setpv(ST(0),fname);
d204 1
a204 1
	FILE *	fp
d207 3
a209 1
	    ST(0) = rewind(fp) ? &PL_sv_undef : &PL_sv_yes;
d274 1
a274 1
	FILE *	fp
d277 4
a280 2
	    if (fsync(fileno(fp))) { ST(0) = &PL_sv_undef; }
	    else                   { clearerr(fp); ST(0) = &PL_sv_yes; }
d298 2
d350 4
a353 3
	    if (fp != Nullfp) {
	      SV *fh = newFH(fp,(mode[1] ? '+' : (mode[0] == 'r' ? '<' : (mode[0] == 'a' ? 'a' : '>'))));
	      ST(0) = (fh ? sv_2mortal(fh) : &PL_sv_undef);
d367 1
d410 4
a413 3
	       ((fp = fdopen(fd, &("r\000w\000r+"[2*i]))) != Nullfp)) {
	      SV *fh = newFH(fp,"<>++"[i]);
	      ST(0) = (fh ? sv_2mortal(fh) : &PL_sv_undef);
d419 1
a419 1
	FILE *	fp
d422 3
a424 1
	    ST(0) = fwait(fp) ? &PL_sv_undef : &PL_sv_yes;
d435 1
a435 1
	    FILE *fp = io ? IoOFP(io) : NULL;
d439 1
a439 1
	    if (fgetname(fp,devnam) == Nullch) { ST(0) = &PL_sv_undef; XSRETURN(1); }
@


1.4
log
@perl-5.6.0 + local changes
@
text
@a89 1
    dTHR;
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 3
a5 3
 * Version:  2.1
 * Author:   Charles Bailey  bailey@@genetics.upenn.edu
 * Revised:  24-Mar-1998
d128 51
d419 1
a419 2
	      set_errno(EBADF); set_vaxc_errno(SS$_IVCHAN);
	      ST(0) = &PL_sv_undef;  XSRETURN(1);
@


1.2
log
@perl 5.004_04
@
text
@d3 1
a3 1
 * Version:  2.02
d5 1
a5 1
 * Revised:  15-Feb-1997
d13 3
d90 1
d96 2
a97 2
    stashp = (GV **)hv_fetch(defstash,"VMS::",5,TRUE);
    if (!stashp || *stashp == (GV *)&sv_undef) return Nullsv;
d100 1
a100 1
    if (!stashp || *stashp == (GV *)&sv_undef) return Nullsv;
d125 1
a125 1
	    ST(0) = &sv_undef;
d128 2
a129 2
flush(sv)
	SV *	sv
d132 2
a133 4
	    FILE *fp = Nullfp;
	    if (SvOK(sv)) fp = IoIFP(sv_2io(sv));
	    if (fflush(fp)) { ST(0) = &sv_undef; }
	    else            { clearerr(fp); ST(0) = &sv_yes; }
d140 1
a140 1
	    char fname[257];
d149 1
a149 1
	    ST(0) = rewind(fp) ? &sv_undef : &sv_yes;
d156 55
a210 1
	    ST(0) = remove(name) ? &sv_undef : &sv_yes;
d217 2
a218 2
	    if (fsync(fileno(fp))) { ST(0) = &sv_undef; }
	    else                   { clearerr(fp); ST(0) = &sv_yes; }
d236 1
d255 1
a255 1
	    for (i = 0; i < myargc; i++) args[i] = SvPV(ST(i+1),na);
d288 1
a288 1
	      ST(0) = (fh ? sv_2mortal(fh) : &sv_undef);
d290 1
a290 1
	    else { ST(0) = &sv_undef; }
d303 1
d310 1
a310 1
	    for (i = 0; i < myargc; i++) args[i] = SvPV(ST(i+3),na);
d346 1
a346 1
	      ST(0) = (fh ? sv_2mortal(fh) : &sv_undef);
d348 1
a348 1
	    else { ST(0) = &sv_undef; }
d355 41
a395 1
	    ST(0) = fwait(fp) ? &sv_undef : &sv_yes;
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  2.0
d5 1
a5 1
 * Revised:  28-Feb-1996
d82 2
a83 2
    SV *rv, *gv = NEWSV(0,0);
    GV **stashp;
d103 1
a103 1
    if (type != '>') IoOFP(io) = fp;
d105 1
a105 1
    rv = newRV(gv);
d130 2
a131 1
	    ST(0) = fflush(fp) ? &sv_undef : &sv_yes;
d161 2
a162 1
	    ST(0) = fsync(fileno(fp)) ? &sv_undef : &sv_yes;
d230 1
a230 1
	      SV *fh = newFH(fp,(mode[1] ? '+' : (mode[0] == 'r' ? '<' : '>')));
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 1
 * Version:  2.1
d5 1
a5 1
 * Revised:  24-Mar-1998
a12 3
#include <iodef.h>
#include <rms.h>
#include <starlet.h>
d82 2
a83 2
    SV *rv;
    GV **stashp, *gv = (GV *)NEWSV(0,0);
a86 1
    dTHR;
d92 2
a93 2
    stashp = (GV **)hv_fetch(PL_defstash,"VMS::",5,TRUE);
    if (!stashp || *stashp == (GV *)&PL_sv_undef) return Nullsv;
d96 1
a96 1
    if (!stashp || *stashp == (GV *)&PL_sv_undef) return Nullsv;
d103 1
a103 1
    if (type != '<') IoOFP(io) = fp;
d105 1
a105 1
    rv = newRV((SV *)gv);
d121 1
a121 1
	    ST(0) = &PL_sv_undef;
d124 2
a125 2
flush(fp)
	FILE *	fp
d128 3
a130 2
	    if (fflush(fp)) { ST(0) = &PL_sv_undef; }
	    else            { clearerr(fp); ST(0) = &PL_sv_yes; }
d137 1
a137 1
	    char fname[NAM$C_MAXRSS+1];
d146 1
a146 1
	    ST(0) = rewind(fp) ? &PL_sv_undef : &PL_sv_yes;
d153 1
a153 55
	    ST(0) = remove(name) ? &PL_sv_undef : &PL_sv_yes;

void
setdef(...)
	PROTOTYPE: @@
	CODE:
	    char vmsdef[NAM$C_MAXRSS+1], es[NAM$C_MAXRSS], sep;
	    unsigned long int retsts;
	    struct FAB deffab = cc$rms_fab;
	    struct NAM defnam = cc$rms_nam;
	    struct dsc$descriptor_s dirdsc = {0, DSC$K_DTYPE_T, DSC$K_CLASS_S, 0};
	    STRLEN n_a;
	    if (items) {
		SV *defsv = ST(items-1);  /* mimic chdir() */
		ST(0) = &PL_sv_undef;
		if (!SvPOK(defsv)) { SETERRNO(EINVAL,LIB$_INVARG); XSRETURN(1); }
		if (tovmsspec(SvPV(defsv,n_a),vmsdef) == NULL) { XSRETURN(1); }
		deffab.fab$l_fna = vmsdef; deffab.fab$b_fns = strlen(vmsdef);
	    }
	    else {
		deffab.fab$l_fna = "SYS$LOGIN"; deffab.fab$b_fns = 9;
		EXTEND(sp,1);  ST(0) = &PL_sv_undef;
	    }
	    defnam.nam$l_esa = es;  defnam.nam$b_ess = sizeof es;
	    deffab.fab$l_nam = &defnam;
	    retsts = sys$parse(&deffab,0,0);
	    if (retsts & 1) {
		if (defnam.nam$v_wildcard) retsts = RMS$_WLD;
		else if (defnam.nam$b_name || defnam.nam$b_type > 1 ||
	             defnam.nam$b_ver > 1) retsts = RMS$_DIR;
		}
	    defnam.nam$b_nop |= NAM$M_SYNCHK; defnam.nam$l_rlf = NULL; deffab.fab$b_dns = 0;
	    if (!(retsts & 1)) {
		set_vaxc_errno(retsts);
		switch (retsts) {
		    case RMS$_DNF:
			set_errno(ENOENT); break;
		    case RMS$_SYN: case RMS$_DIR: case RMS$_DEV:
			set_errno(EINVAL); break;
		    case RMS$_PRV:
			set_errno(EACCES); break;
		    default:
			set_errno(EVMSERR); break;
		}
		(void) sys$parse(&deffab,0,0);  /* free up context */
		XSRETURN(1);
	    }
	    sep = *defnam.nam$l_dir;
	    *defnam.nam$l_dir = '\0';
	    my_setenv("SYS$DISK",defnam.nam$b_node ? defnam.nam$l_node : defnam.nam$l_dev);
	    *defnam.nam$l_dir = sep;
	    dirdsc.dsc$a_pointer = defnam.nam$l_dir; dirdsc.dsc$w_length = defnam.nam$b_dir;
	    if ((retsts = sys$setddir(&dirdsc,0,0)) & 1) ST(0) = &PL_sv_yes;
	    else { set_errno(EVMSERR); set_vaxc_errno(retsts); }
	    (void) sys$parse(&deffab,0,0);  /* free up context */
d160 1
a160 2
	    if (fsync(fileno(fp))) { ST(0) = &PL_sv_undef; }
	    else                   { clearerr(fp); ST(0) = &PL_sv_yes; }
a177 1
	    STRLEN n_a;
d196 1
a196 1
	    for (i = 0; i < myargc; i++) args[i] = SvPV(ST(i+1),n_a);
d228 2
a229 2
	      SV *fh = newFH(fp,(mode[1] ? '+' : (mode[0] == 'r' ? '<' : (mode[0] == 'a' ? 'a' : '>'))));
	      ST(0) = (fh ? sv_2mortal(fh) : &PL_sv_undef);
d231 1
a231 1
	    else { ST(0) = &PL_sv_undef; }
a243 1
	    STRLEN n_a;
d250 1
a250 1
	    for (i = 0; i < myargc; i++) args[i] = SvPV(ST(i+3),n_a);
d286 1
a286 1
	      ST(0) = (fh ? sv_2mortal(fh) : &PL_sv_undef);
d288 1
a288 1
	    else { ST(0) = &PL_sv_undef; }
d295 1
a295 41
	    ST(0) = fwait(fp) ? &PL_sv_undef : &PL_sv_yes;

void
writeof(mysv)
	SV *	mysv
	PROTOTYPE: $
	CODE:
	    char devnam[257], *cp;
	    unsigned long int chan, iosb[2], retsts, retsts2;
	    struct dsc$descriptor devdsc = {0, DSC$K_DTYPE_T, DSC$K_CLASS_S, devnam};
	    IO *io = sv_2io(mysv);
	    FILE *fp = io ? IoOFP(io) : NULL;
	    if (fp == NULL || strchr(">was+-|",IoTYPE(io)) == Nullch) {
	      set_errno(EBADF); set_vaxc_errno(SS$_IVCHAN);
	      ST(0) = &PL_sv_undef;  XSRETURN(1);
	    }
	    if (fgetname(fp,devnam) == Nullch) { ST(0) = &PL_sv_undef; XSRETURN(1); }
	    if ((cp = strrchr(devnam,':')) != NULL) *(cp+1) = '\0';
	    devdsc.dsc$w_length = strlen(devnam);
	    retsts = sys$assign(&devdsc,&chan,0,0);
	    if (retsts & 1) retsts = sys$qiow(0,chan,IO$_WRITEOF,iosb,0,0,0,0,0,0,0,0);
	    if (retsts & 1) retsts = iosb[0];
	    retsts2 = sys$dassgn(chan);  /* Be sure to deassign the channel */
	    if (retsts & 1) retsts = retsts2;
	    if (retsts & 1) { ST(0) = &PL_sv_yes; }
	    else {
	      set_vaxc_errno(retsts);
	      switch (retsts) {
	        case SS$_EXQUOTA:  case SS$_INSFMEM:  case SS$_MBFULL:
	        case SS$_MBTOOSML: case SS$_NOIOCHAN: case SS$_NOLINKS:
	        case SS$_BUFFEROVF:
	          set_errno(ENOSPC); break;
	        case SS$_ILLIOFUNC: case SS$_DEVOFFLINE: case SS$_NOSUCHDEV:
	          set_errno(EBADF);  break;
	        case SS$_NOPRIV:
	          set_errno(EACCES); break;
	        default:  /* Includes "shouldn't happen" cases that might map */
	          set_errno(EVMSERR); break;         /* to other errno values */
	      }
	      ST(0) = &PL_sv_undef;
	    }
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 3
a5 3
 * Version:  2.2
 * Author:   Charles Bailey  bailey@@newman.upenn.edu
 * Revised:  18-Jul-1998
a127 51
binmode(fh)
	SV *	fh
	PROTOTYPE: $
	CODE:
	    IO *io = sv_2io(fh);
	    FILE *fp = io ? IoOFP(io) : NULL;
	    char iotype = io ? IoTYPE(io) : '\0';
	    char filespec[NAM$C_MAXRSS], *acmode, *s, *colon, *dirend = Nullch;
	    int ret = 0, saverrno = errno, savevmserrno = vaxc$errno;
	    fpos_t pos;
	    if (fp == NULL || strchr(">was+-|",iotype) == Nullch) {
	      set_errno(EBADF); set_vaxc_errno(SS$_IVCHAN); XSRETURN_UNDEF;
	    }
	    if (!fgetname(fp,filespec)) XSRETURN_UNDEF;
	    for (s = filespec; *s; s++) {
	      if (*s == ':') colon = s;
	      else if (*s == ']' || *s == '>') dirend = s;
	    }
	    /* Looks like a tmpfile, which will go away if reopened */
	    if (s == dirend + 3) {
	      set_errno(EBADF); set_vaxc_errno(RMS$_IOP); XSRETURN_UNDEF;
	    }
	    /* If we've got a non-file-structured device, clip off the trailing
	     * junk, and don't lose sleep if we can't get a stream position.  */
	    if (dirend == Nullch) *(colon+1) = '\0'; 
	    if (iotype != '-' && (ret = fgetpos(fp, &pos)) == -1 && dirend)
	      XSRETURN_UNDEF;
	    switch (iotype) {
	      case '<': case 'r':           acmode = "rb";                      break;
	      case '>': case 'w': case '|':
	        /* use 'a' instead of 'w' to avoid creating new file;
	           fsetpos below will take care of restoring file position */
	      case 'a':                     acmode = "ab";                      break;
	      case '+':  case 's':          acmode = "rb+";                     break;
	      case '-':                     acmode = fileno(fp) ? "ab" : "rb";  break;
	      /* iotype'll be null for the SYS$INPUT:/SYS$OUTPUT:/SYS$ERROR: files */
	      /* since we didn't really open them and can't really */
	      /* reopen them */
	      case 0:                       XSRETURN_UNDEF;
	      default:
	        if (PL_dowarn) warn("Unrecognized iotype %c for %s in binmode",
	                         iotype, filespec);
	        acmode = "rb+";
	    }
	    if (freopen(filespec,acmode,fp) == NULL) XSRETURN_UNDEF;
	    if (iotype != '-' && ret != -1 && fsetpos(fp,&pos) == -1) XSRETURN_UNDEF;
	    if (ret == -1) { set_errno(saverrno); set_vaxc_errno(savevmserrno); }
	    XSRETURN_YES;


void
d368 2
a369 1
	      set_errno(EBADF); set_vaxc_errno(SS$_IVCHAN); XSRETURN_UNDEF;
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d90 1
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d84 1
a84 1
newFH(PerlIO *fp, char type) {
d131 6
a136 10
           SV *name;
	   IO *io;
	   char iotype;
	   char filespec[NAM$C_MAXRSS], *acmode, *s, *colon, *dirend = Nullch;
	   int ret = 0, saverrno = errno, savevmserrno = vaxc$errno;
           SV pos;
           PerlIO *fp;
	   io = sv_2io(fh);
           fp = io ? IoOFP(io) : NULL;
	   iotype = io ? IoTYPE(io) : '\0';
d140 1
a140 1
           if (!PerlIO_getname(fp,filespec)) XSRETURN_UNDEF;
d152 1
a152 1
           if (iotype != '-' && (ret = PerlIO_getpos(fp, &pos)) == -1 && dirend)
d161 1
a161 1
             case '-':                     acmode = PerlIO_fileno(fp) ? "ab" : "rb";  break;
d171 2
a172 4
           /* appearances to the contrary, this is an freopen substitute */
           name = sv_2mortal(newSVpvn(filespec,strlen(filespec)));
           if (PerlIO_openn(aTHX_ Nullch,acmode,-1,0,0,fp,1,&name) == Nullfp) XSRETURN_UNDEF;
           if (iotype != '-' && ret != -1 && PerlIO_setpos(fp,&pos) == -1) XSRETURN_UNDEF;
d179 1
a179 1
       PerlIO * fp
d182 2
a183 4
           FILE *stdio = PerlIO_exportFILE(fp,0);
           if (fflush(stdio)) { ST(0) = &PL_sv_undef; }
           else            { clearerr(stdio); ST(0) = &PL_sv_yes; }
           PerlIO_releaseFILE(fp,stdio);
d187 1
a187 1
       PerlIO * fp
d192 1
a192 1
           if (PerlIO_getname(fp,fname) != NULL) sv_setpv(ST(0),fname);
d196 1
a196 1
       PerlIO * fp
d199 1
a199 3
           FILE *stdio = PerlIO_exportFILE(fp,0);
           ST(0) = rewind(stdio) ? &PL_sv_undef : &PL_sv_yes;
           PerlIO_releaseFILE(fp,stdio);
d264 1
a264 1
       PerlIO * fp
d267 2
a268 4
           FILE *stdio = PerlIO_exportFILE(fp,0);
           if (fsync(fileno(stdio))) { ST(0) = &PL_sv_undef; }
           else                   { clearerr(stdio); ST(0) = &PL_sv_yes; }
           PerlIO_releaseFILE(fp,stdio);
a285 2
            SV *fh;
           PerlIO *pio_fp;
d336 3
a338 4
           if (fp != Null(FILE*)) {
             pio_fp = PerlIO_importFILE(fp,mode);
             fh = newFH(pio_fp,(mode[1] ? '+' : (mode[0] == 'r' ? '<' : (mode[0] == 'a' ? 'a' : '>'))));
	     ST(0) = (fh ? sv_2mortal(fh) : &PL_sv_undef);
a351 1
           PerlIO *pio_fp;
d394 3
a396 4
              ((fp = fdopen(fd, &("r\000w\000r+"[2*i]))) != Null(FILE*))) {
             pio_fp = PerlIO_importFILE(fp,&("r\000w\000r+"[2*i]));
             fh = newFH(pio_fp,"<>++"[i]);
	     ST(0) = (fh ? sv_2mortal(fh) : &PL_sv_undef);
d402 1
a402 1
       PerlIO * fp
d405 1
a405 3
           FILE *stdio = PerlIO_exportFILE(fp,0);
           ST(0) = fwait(stdio) ? &PL_sv_undef : &PL_sv_yes;
           PerlIO_releaseFILE(fp,stdio);
d416 1
a416 1
           PerlIO *fp = io ? IoOFP(io) : NULL;
d420 1
a420 1
           if (PerlIO_getname(fp,devnam) == Nullch) { ST(0) = &PL_sv_undef; XSRETURN(1); }
@


1.1.1.6
log
@import perl 5.10.0 from CPAN
@
text
@d3 1
a3 1
 * Version:  2.3
d5 1
a5 1
 * Revised:  14-Jun-2007
d86 1
a86 1
    GV **stashp, *gv = (GV *)newSV(0);
d195 1
a195 1
	PerlIO * fp
a197 1
            FILE *stdio = PerlIO_exportFILE(fp,0);
d200 1
a200 2
            if (fgetname(stdio,fname) != NULL) sv_setpv(ST(0),fname);
            PerlIO_releaseFILE(fp,stdio);
d351 1
a351 1
             pio_fp = PerlIO_fdopen(fileno(fp),mode);
d366 2
a367 1
	    PerlIO *pio_fp;
d410 2
a411 1
              ((pio_fp = PerlIO_fdopen(fd, &("r\000w\000r+"[2*i]))) != Null(PerlIO*))) {
@


1.1.1.7
log
@import perl 5.10.1
@
text
@d96 1
a96 1
    if (!stashp || *stashp == (GV *)&PL_sv_undef) return NULL;
d99 1
a99 1
    if (!stashp || *stashp == (GV *)&PL_sv_undef) return NULL;
d134 1
a134 1
	   char filespec[NAM$C_MAXRSS], *acmode, *s, *colon, *dirend = NULL;
d141 1
a141 1
	    if (fp == NULL || strchr(">was+-|",iotype) == NULL) {
d155 1
a155 1
	    if (dirend == NULL) *(colon+1) = '\0'; 
d177 1
a177 1
           if (PerlIO_openn(aTHX_ NULL,acmode,-1,0,0,fp,1,&name) == NULL) XSRETURN_UNDEF;
d352 1
a352 1
	    if (fp != NULL) {
d411 1
a411 1
              ((pio_fp = PerlIO_fdopen(fd, &("r\000w\000r+"[2*i]))) != NULL)) {
d436 1
a436 1
	    if (fp == NULL || strchr(">was+-|",IoTYPE(io)) == NULL) {
d439 1
a439 1
           if (PerlIO_getname(fp,devnam) == NULL) { ST(0) = &PL_sv_undef; XSRETURN(1); }
@


