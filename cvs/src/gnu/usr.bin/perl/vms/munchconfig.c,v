head	1.1;
branch	1.1.1;
access;
symbols
	PERL_5_24_2:1.1.1.6
	OPENBSD_6_1:1.1.1.6.0.18
	OPENBSD_6_1_BASE:1.1.1.6
	OPENBSD_6_0:1.1.1.6.0.16
	OPENBSD_6_0_BASE:1.1.1.6
	OPENBSD_5_9:1.1.1.6.0.10
	OPENBSD_5_9_BASE:1.1.1.6
	OPENBSD_5_8:1.1.1.6.0.12
	OPENBSD_5_8_BASE:1.1.1.6
	PERL_5_20_2:1.1.1.6
	OPENBSD_5_7:1.1.1.6.0.4
	OPENBSD_5_7_BASE:1.1.1.6
	PERL_5_20_1:1.1.1.6
	OPENBSD_5_6:1.1.1.6.0.8
	OPENBSD_5_6_BASE:1.1.1.6
	PERL_5_18_2:1.1.1.6
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.6.0.6
	OPENBSD_5_5_BASE:1.1.1.6
	OPENBSD_5_4:1.1.1.6.0.2
	OPENBSD_5_4_BASE:1.1.1.6
	PERL_5_16_3:1.1.1.6
	OPENBSD_5_3:1.1.1.5.0.18
	OPENBSD_5_3_BASE:1.1.1.5
	OPENBSD_5_2:1.1.1.5.0.16
	OPENBSD_5_2_BASE:1.1.1.5
	OPENBSD_5_1_BASE:1.1.1.5
	OPENBSD_5_1:1.1.1.5.0.14
	OPENBSD_5_0:1.1.1.5.0.12
	OPENBSD_5_0_BASE:1.1.1.5
	OPENBSD_4_9:1.1.1.5.0.10
	OPENBSD_4_9_BASE:1.1.1.5
	PERL_5_12_2:1.1.1.5
	OPENBSD_4_8:1.1.1.5.0.8
	OPENBSD_4_8_BASE:1.1.1.5
	OPENBSD_4_7:1.1.1.5.0.4
	OPENBSD_4_7_BASE:1.1.1.5
	PERL_5_10_1:1.1.1.5
	OPENBSD_4_6:1.1.1.5.0.6
	OPENBSD_4_6_BASE:1.1.1.5
	OPENBSD_4_5:1.1.1.5.0.2
	OPENBSD_4_5_BASE:1.1.1.5
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.1.1.4.0.24
	OPENBSD_4_4_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.22
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_2:1.1.1.4.0.20
	OPENBSD_4_2_BASE:1.1.1.4
	OPENBSD_4_1:1.1.1.4.0.18
	OPENBSD_4_1_BASE:1.1.1.4
	OPENBSD_4_0:1.1.1.4.0.16
	OPENBSD_4_0_BASE:1.1.1.4
	PERL_5_8_8:1.1.1.4
	OPENBSD_3_9:1.1.1.4.0.14
	OPENBSD_3_9_BASE:1.1.1.4
	OPENBSD_3_8:1.1.1.4.0.12
	OPENBSD_3_8_BASE:1.1.1.4
	OPENBSD_3_7:1.1.1.4.0.10
	OPENBSD_3_7_BASE:1.1.1.4
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.1.1.4.0.8
	OPENBSD_3_6_BASE:1.1.1.4
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.1.1.4.0.6
	OPENBSD_3_5_BASE:1.1.1.4
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.1.1.4.0.4
	OPENBSD_3_4_BASE:1.1.1.4
	OPENBSD_3_3:1.1.1.4.0.2
	OPENBSD_3_3_BASE:1.1.1.4
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.1.1.3.0.6
	OPENBSD_3_2_BASE:1.1.1.3
	OPENBSD_3_1:1.1.1.3.0.4
	OPENBSD_3_1_BASE:1.1.1.3
	OPENBSD_3_0:1.1.1.3.0.2
	OPENBSD_3_0_BASE:1.1.1.3
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.1.1.2.0.6
	OPENBSD_2_9_BASE:1.1.1.2
	OPENBSD_2_8:1.1.1.2.0.4
	OPENBSD_2_8_BASE:1.1.1.2
	OPENBSD_2_7:1.1.1.2.0.2
	OPENBSD_2_7_BASE:1.1.1.2
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.1.1.1.0.2
	OPENBSD_2_6_BASE:1.1.1.1
	PERL_500503:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.1
date	99.04.29.22.42.00;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.42.00;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.10.59;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.26.04;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.11;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2008.09.29.17.19.04;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2013.03.25.20.09.40;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* munchconfig.c

   A very, very (very!) simple program to process a config_h.sh file on
   non-unix systems.

   usage:
   munchconfig config.sh config_h.sh [foo=bar [baz=xyzzy [...]]] >config.h

   which is to say, it takes as its firt parameter a config.sh (or
   equivalent), as its second a config_h.sh (or equvalent), and a list of
   optional tag=value pairs.

   It spits the processed config.h out to STDOUT.

   */

#include <stdio.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

/* The failure code to exit with */
#ifndef EXIT_FAILURE
#ifdef VMS
#define EXIT_FAILURE 0
#else
#define EXIT_FAILURE -1
#endif
#endif

/* The biggest line we can read in from a file */
#define LINEBUFFERSIZE 400
#define NUMTILDESUBS 30
#define NUMCONFIGSUBS 1000
#define TOKENBUFFERSIZE 80

typedef struct {
  char Tag[TOKENBUFFERSIZE];
  char Value[512];
} Translate;

void tilde_sub(char [], Translate [], int);

int
main(int argc, char *argv[])
{
  FILE *ConfigSH, *Config_H;
  char LineBuffer[LINEBUFFERSIZE], *TempValue, *StartTilde, *EndTilde;
  char SecondaryLineBuffer[LINEBUFFERSIZE];
  char TokenBuffer[TOKENBUFFERSIZE];
  int LineBufferLength, TempLength, DummyVariable, LineBufferLoop;
  int TokenBufferLoop, ConfigSubLoop, GotIt;
  Translate TildeSub[NUMTILDESUBS];    /* Holds the tilde (~FOO~) */
                                       /* substitutions */
  Translate ConfigSub[NUMCONFIGSUBS];  /* Holds the substitutions from */
                                       /* config.sh */
  int TildeSubCount = 0, ConfigSubCount = 0; /* # of tilde substitutions */
                                             /* and config substitutions, */
                                             /* respectively */
  if (argc < 3) {
    printf("Usage: munchconfig config.sh config_h.sh [foo=bar [baz=xyzzy [...]]]\n");
    exit(EXIT_FAILURE);
  }

  
  /* First, open the input files */
  if (NULL == (ConfigSH = fopen(argv[1], "r"))) {
    printf("Error %i trying to open config.sh file %s\n", errno, argv[1]);
    exit(EXIT_FAILURE);
  }
  
  if (NULL == (Config_H = fopen(argv[2], "r"))) {
    printf("Error %i trying to open config_h.sh file %s\n", errno, argv[2]);
    exit(EXIT_FAILURE);
  }

  /* Any tag/value pairs on the command line? */
  if (argc > 3) {
    int i;
    char WorkString[80]; 
    for (i=3; i < argc && argv[i]; i++) {
      
      /* Local copy */
      strcpy(WorkString, argv[i]);
      /* Stick a NULL over the = */
      TempValue = strchr(WorkString, '=');
      *TempValue++ = '\0';

      /* Copy the tag and value into the holding array */
      strcpy(TildeSub[TildeSubCount].Tag, WorkString);
      strcpy(TildeSub[TildeSubCount].Value, TempValue);
      TildeSubCount++;
    }
  }

  /* Now read in the config.sh file. */
  while(fgets(LineBuffer, LINEBUFFERSIZE - 1, ConfigSH)) {
    /* Force a trailing null, just in case */
    LineBuffer[LINEBUFFERSIZE - 1] = '\0';

    LineBufferLength = strlen(LineBuffer);

    /* Chop trailing control characters */
    while((LineBufferLength > 0) && (LineBuffer[LineBufferLength-1] < ' ')) {
      LineBuffer[LineBufferLength - 1] = '\0';
      LineBufferLength--;
    }

    /* If it's empty, then try again */
    if (!*LineBuffer)
      continue;

    /* If the line begins with a '#' or ' ', skip */
    if ((LineBuffer[0] == ' ') || (LineBuffer[0] == '#'))
      continue;

    /* We've got something. Guess we need to actually handle it */
    /* Do the tilde substitution */
    tilde_sub(LineBuffer, TildeSub, TildeSubCount);

    /* Stick a NULL over the = */
    TempValue = strchr(LineBuffer, '=');
    *TempValue++ = '\0';
    /* And another over the leading ', which better be there */
    *TempValue++ = '\0';
    
    /* Check to see if there's a trailing ' or ". If not, add a newline to
       the buffer and grab another line. */
    TempLength = strlen(TempValue);
    while ((TempValue[TempLength-1] != '\'') &&
           (TempValue[TempLength-1] != '"'))  {
      fgets(SecondaryLineBuffer, LINEBUFFERSIZE - 1, ConfigSH);
      /* Force a trailing null, just in case */
      SecondaryLineBuffer[LINEBUFFERSIZE - 1] = '\0';
      /* Go substitute */
      tilde_sub(SecondaryLineBuffer, TildeSub, TildeSubCount);
      /* Tack a nweline on the end of our primary buffer */
      strcat(TempValue, "\n");
      /* Concat the new line we just read */
      strcat(TempValue, SecondaryLineBuffer);

      /* Refigure the length */
      TempLength = strlen(TempValue);
      
      /* Chop trailing control characters */
      while((TempLength > 0) && (TempValue[TempLength-1] < ' ')) {
        TempValue[TempLength - 1] = '\0';
        TempLength--;
      }
    }
    
    /* And finally one over the trailing ' */
    TempValue[TempLength-1] = '\0';

    /* Is there even anything left? */
    if(*TempValue) {
      /* Copy the tag over */
      strcpy(ConfigSub[ConfigSubCount].Tag, LineBuffer);
      /* Copy the value over */
      strcpy(ConfigSub[ConfigSubCount].Value, TempValue);

      /* Up the count */
      ConfigSubCount++;

    }
  }

  /* Okay, we've read in all the substititions from our config.sh */
  /* equivalent. Read in the config_h.sh equiv and start the substitution */
  
  /* First, eat all the lines until we get to one with !GROK!THIS! in it */
  while(!strstr(fgets(LineBuffer, LINEBUFFERSIZE, Config_H),
                "!GROK!THIS!")) {

    /* Dummy statement to shut up any compiler that'll whine about an empty */
    /* loop */
    DummyVariable++;
  }

  /* Right, we've read all the lines through the first one with !GROK!THIS! */
  /* in it. That gets us through the beginning stuff. Now start in earnest */
  /* with our translations, which run until we get to another !GROK!THIS! */
  while(!strstr(fgets(LineBuffer, LINEBUFFERSIZE, Config_H),
                "!GROK!THIS!")) {
    /* Force a trailing null, just in case */
    LineBuffer[LINEBUFFERSIZE - 1] = '\0';
    
    /* Tilde Substitute */
    tilde_sub(LineBuffer, TildeSub, TildeSubCount);

    LineBufferLength = strlen(LineBuffer);
    
    /* Chop trailing control characters */
    while((LineBufferLength > 0) && (LineBuffer[LineBufferLength-1] < ' ')) {
      LineBuffer[LineBufferLength - 1] = '\0';
      LineBufferLength--;
    }

    /* Right. Go looking for $s. */
    for(LineBufferLoop = 0; LineBufferLoop < LineBufferLength;
        LineBufferLoop++) {
      /* Did we find one? */
      if ('$' != LineBuffer[LineBufferLoop]) {
        /* Nope, spit out the value */
        putchar(LineBuffer[LineBufferLoop]);
      } else {
        /* Yes, we did. Is it escaped? */
        if ((LineBufferLoop > 0) && ('\\' == LineBuffer[LineBufferLoop -
                                                       1])) {
          /* Yup. Spit it out */
          putchar(LineBuffer[LineBufferLoop]);
        } else {
         /* Nope. Go grab us a token */
          TokenBufferLoop = 0;
          /* Advance to the next character in the input stream */
          LineBufferLoop++;
          while((LineBufferLoop < LineBufferLength) &&
                ((isalnum(LineBuffer[LineBufferLoop]) || ('_' ==
                                                          LineBuffer[LineBufferLoop])))) {
            TokenBuffer[TokenBufferLoop] = LineBuffer[LineBufferLoop];
            LineBufferLoop++;
            TokenBufferLoop++;
          }

          /* Trailing null on the token buffer */
          TokenBuffer[TokenBufferLoop] = '\0';

          /* Back the line buffer pointer up one */
          LineBufferLoop--;
          
          /* Right, we're done grabbing a token. Check to make sure we got */
          /* something */
          if (TokenBufferLoop) {
            /* Well, we do. Run through all the tokens we've got in the */
            /* ConfigSub array and see if any match */
            GotIt = 0;
            for(ConfigSubLoop = 0; ConfigSubLoop < ConfigSubCount;
                ConfigSubLoop++) {
              if (!strcmp(TokenBuffer, ConfigSub[ConfigSubLoop].Tag)) {
                GotIt = 1;
                printf("%s", ConfigSub[ConfigSubLoop].Value);
                break;
              }
            }

            /* Did we find something? If not, spit out what was in our */
            /* buffer */
            if (!GotIt) {
              printf("$%s", TokenBuffer);
            }
            
          } else {
            /* Just a bare $. Spit it out */
            putchar('$');
          }       
        }
      }
    }
    
    /* We're all done. Spit out an EOL */
    printf("\n");
    
    
  }
  
  /* Close the files */
  fclose(ConfigSH);
  fclose(Config_H);
}

void
tilde_sub(char LineBuffer[], Translate TildeSub[], int TildeSubCount)
{
  char TempBuffer[LINEBUFFERSIZE], TempTilde[TOKENBUFFERSIZE];
  int TildeLoop, InTilde, CopiedBufferLength, TildeBufferLength, k, GotIt;
  int TempLength;
  InTilde = 0;
  CopiedBufferLength = 0;
  TildeBufferLength = 0;
  TempLength = strlen(LineBuffer);

  /* Grovel over our input looking for ~foo~ constructs */
  for(TildeLoop = 0; TildeLoop < TempLength; TildeLoop++) {
    /* Are we in a tilde? */
    if (InTilde) {
      /* Yup. Is the current character a tilde? */
      if (LineBuffer[TildeLoop] == '~') {
        /* Yup. That means we're ready to do a substitution */
        InTilde = 0;
        GotIt = 0;
        /* Trailing null */
        TempTilde[TildeBufferLength] = '\0';
        for( k=0; k < TildeSubCount; k++) {
          if (!strcmp(TildeSub[k].Tag, TempTilde)) {
            GotIt = 1;
            /* Tack on the trailing null to the main buffer */
            TempBuffer[CopiedBufferLength] = '\0';
            /* Copy the tilde substitution over */
            strcat(TempBuffer, TildeSub[k].Value);
            CopiedBufferLength = strlen(TempBuffer);
          }
        }
        
        /* Did we find anything? */
        if (GotIt == 0) {
          /* Guess not. Copy the whole thing out verbatim */
          TempBuffer[CopiedBufferLength] = '\0';
          TempBuffer[CopiedBufferLength++] = '~';
          TempBuffer[CopiedBufferLength] = '\0';
          strcat(TempBuffer, TempTilde);
          strcat(TempBuffer, "~");
          CopiedBufferLength = strlen(TempBuffer);
        }
        
      } else {
        /* 'Kay, not a tilde. Is it a word character? */
        if (isalnum(LineBuffer[TildeLoop]) || (LineBuffer[TildeLoop] =
                                              '-') ||
            (LineBuffer[TildeLoop] == '-')) {
          TempTilde[TildeBufferLength++] = LineBuffer[TildeLoop];
        } else {
          /* No, it's not a tilde character. For shame! We've got a */
          /* bogus token. Copy a ~ into the output buffer, then append */
          /* whatever we've got in our token buffer */
          TempBuffer[CopiedBufferLength++] = '~';
          TempBuffer[CopiedBufferLength] = '\0';
          TempTilde[TildeBufferLength] = '\0';
          strcat(TempBuffer, TempTilde);
          CopiedBufferLength += TildeBufferLength;
          InTilde = 0;
        }
      }
    } else {
      /* We're not in a tilde. Do we want to be? */
      if (LineBuffer[TildeLoop] == '~') {
        /* Guess so */
        InTilde = 1;
        TildeBufferLength = 0;
      } else {
        /* Nope. Copy the character to the output buffer */
        TempBuffer[CopiedBufferLength++] = LineBuffer[TildeLoop];
      }
    }
  }
  
  /* Out of the loop. First, double-check to see if there was anything */
  /* pending. */
  if (InTilde) {
    /* bogus token. Copy a ~ into the output buffer, then append */
    /* whatever we've got in our token buffer */
    TempBuffer[CopiedBufferLength++] = '~';
    TempBuffer[CopiedBufferLength] = '\0';
    TempTilde[TildeBufferLength] = '\0';
    strcat(TempBuffer, TempTilde);
    CopiedBufferLength += TildeBufferLength;
  } else {
    /* Nope, nothing pensing. Tack on a \0 */
    TempBuffer[CopiedBufferLength] = '\0';
  }

  /* Okay, we're done. Copy the temp buffer back into the line buffer */
  strcpy(LineBuffer, TempBuffer);

}

@


1.1.1.1
log
@perl5.005_03
@
text
@@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d50 1
a50 1
  char SecondaryLineBuffer[LINEBUFFERSIZE], OutBuf[LINEBUFFERSIZE];
d53 1
a53 1
  int TokenBufferLoop, ConfigSubLoop, GotIt, OutBufPos;
a199 1
    OutBufPos = 0;
d206 1
a206 1
	OutBuf[OutBufPos++] = LineBuffer[LineBufferLoop];
d212 1
a212 1
          OutBuf[OutBufPos++] = LineBuffer[LineBufferLoop];
d241 2
a242 3
                char *cp = ConfigSub[ConfigSubLoop].Value;
		GotIt = 1;
		while (*cp) OutBuf[OutBufPos++] = *(cp++);
d250 1
a250 3
	      char *cp = TokenBuffer;
	      OutBuf[OutBufPos++] = '$';
	      while (*cp) OutBuf[OutBufPos++] = *(cp++);
d255 1
a255 1
            OutBuf[OutBufPos++] = '$';
d261 4
a264 30
    /* If we've created an #undef line, make sure we don't output anthing
     * after the "#undef FOO" besides comments.  We could do this as we
     * go by recognizing the #undef as it goes by, and thus avoid another
     * use of a fixed-length buffer, but this is simpler.
     */
    if (!strncmp(OutBuf,"#undef",6)) {
      char *cp = OutBuf;
      int i, incomment = 0;
      LineBufferLoop = 0;
      OutBuf[OutBufPos] = '\0';
      for (i = 0; i <= 1; i++) {
	while (!isspace(*cp)) LineBuffer[LineBufferLoop++] = *(cp++);
	while ( isspace(*cp)) LineBuffer[LineBufferLoop++] = *(cp++);
      }
      while (*cp) {
	while (isspace(*cp)) LineBuffer[LineBufferLoop++] = *(cp++);
	if (!incomment && *cp == '/' && *(cp+1) == '*') incomment = 1;
	while (*cp && !isspace(*cp)) {
	  if (incomment) LineBuffer[LineBufferLoop++] = *cp;
	  cp++;
	}
	if (incomment && *cp == '*' && *(cp+1) == '/') incomment = 0;
      }
      LineBuffer[LineBufferLoop] = '\0';
      puts(LineBuffer);
    }	
    else {
      OutBuf[OutBufPos] = '\0';
      puts(OutBuf);
    }
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d348 2
a349 1
        if (isalnum(LineBuffer[TildeLoop]) ||
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d33 1
a33 1
#define LINEBUFFERSIZE 1024
d81 1
a81 1
    char WorkString[LINEBUFFERSIZE]; 
@


1.1.1.5
log
@import perl 5.10.0 from CPAN
@
text
@d7 1
a7 1
   munchconfig config.sh config_h.sh [-f file] [foo=bar [baz=xyzzy [...]]] >config.h
d9 3
a11 4
   which is to say, it takes as its first parameter a config.sh (or
   equivalent), as its second a config_h.sh (or equivalent), an optional file
   containing tag=value pairs (one on each line), and an optional list of
   tag=value pairs on the command line.
a21 1
#include <unistd.h>
d48 1
a48 4
  int c, i;
  char *ifile = NULL;
  char WorkString[LINEBUFFERSIZE]; 
  FILE *ConfigSH, *Config_H, *Extra_Subs;
d62 1
a62 1
    printf("Usage: munchconfig config.sh config_h.sh [-f file] [foo=bar [baz=xyzzy [...]]]\n");
d66 1
a66 14
  optind = 3;    /* skip config.sh and config_h.sh */
  while ((c = getopt(argc, argv, "f:")) != -1) {
      switch (c) {
        case 'f':
            ifile = optarg;
            break;
        case ':':
            fprintf(stderr, "Option -%c requires an operand\n", optopt);
            break;
        case '?':
            fprintf(stderr,"Unrecognised option: -%c\n", optopt);
      }
  }

a77 5
  if (ifile != NULL && NULL == (Extra_Subs = fopen(ifile, "r"))) {
    printf("Error %i trying to open extra substitutions file %s\n", errno, ifile);
    exit(EXIT_FAILURE);
  }

d79 5
a83 2
  if (argc > optind) {
    for (i=optind; i < argc && argv[i]; i++) {
a96 29
  /* Now read in the tag/value pairs from the extra substitutions file, if any */
  while(ifile && fgets(LineBuffer, LINEBUFFERSIZE - 1, Extra_Subs)) {
    /* Force a trailing null, just in case */
    LineBuffer[LINEBUFFERSIZE - 1] = '\0';
    LineBufferLength = strlen(LineBuffer);

    /* Chop trailing control characters */
    while((LineBufferLength > 0) && (LineBuffer[LineBufferLength-1] < ' ')) {
      LineBuffer[LineBufferLength - 1] = '\0';
      LineBufferLength--;
    }

    /* If it's empty, then try again */
    if (!*LineBuffer)
      continue;

    /* Local copy */
    strcpy(WorkString, LineBuffer);
    /* Stick a NULL over the = */
    TempValue = strchr(WorkString, '=');
    *TempValue++ = '\0';

    /* Copy the tag and value into the holding array */
    strcpy(TildeSub[TildeSubCount].Tag, WorkString);
    strcpy(TildeSub[TildeSubCount].Value, TempValue);
    TildeSubCount++;
  }


a299 1
  if (ifile) fclose(Extra_Subs);
@


1.1.1.6
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d218 1
a218 1
  /* Okay, we've read in all the substitutions from our config.sh */
d314 1
a314 1
    /* If we've created an #undef line, make sure we don't output anything
@


