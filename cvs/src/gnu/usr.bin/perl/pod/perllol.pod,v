head	1.10;
access;
symbols
	OPENBSD_6_1:1.10.0.4
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.9.0.16
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.10
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.12
	OPENBSD_5_8_BASE:1.9
	PERL_5_20_2:1.1.1.8
	OPENBSD_5_7:1.9.0.4
	OPENBSD_5_7_BASE:1.9
	PERL_5_20_1:1.1.1.8
	OPENBSD_5_6:1.9.0.8
	OPENBSD_5_6_BASE:1.9
	PERL_5_18_2:1.1.1.8
	PERL:1.1.1
	OPENBSD_5_5:1.9.0.6
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	PERL_5_16_3:1.1.1.8
	OPENBSD_5_3:1.8.0.10
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.8
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.6
	OPENBSD_5_0:1.8.0.4
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8
	PERL_5_12_2:1.1.1.7
	OPENBSD_4_8:1.7.0.4
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	PERL_5_10_1:1.1.1.6
	OPENBSD_4_6:1.6.0.30
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.26
	OPENBSD_4_5_BASE:1.6
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.6.0.24
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.22
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.20
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.18
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.16
	OPENBSD_4_0_BASE:1.6
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.6.0.14
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.12
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.10
	OPENBSD_3_7_BASE:1.6
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.6.0.8
	OPENBSD_3_6_BASE:1.6
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.6.0.6
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.10
date	2017.02.05.00.32.18;	author afresh1;	state Exp;
branches;
next	1.9;
commitid	cxJ08BvJA9Pt2PTM;

1.9
date	2013.03.25.20.40.59;	author sthen;	state Exp;
branches;
next	1.8;

1.8
date	2010.09.24.15.07.04;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2009.10.12.18.24.47;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.33;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.35.57;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.07.34;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.16;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.59.18;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.02;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.02;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.40.51;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.27;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.24.41;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.05;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2009.10.12.18.10.39;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2010.09.24.14.49.11;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2013.03.25.20.09.21;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@=head1 NAME

perllol - Manipulating Arrays of Arrays in Perl

=head1 DESCRIPTION

=head2 Declaration and Access of Arrays of Arrays

The simplest two-level data structure to build in Perl is an array of
arrays, sometimes casually called a list of lists.  It's reasonably easy to
understand, and almost everything that applies here will also be applicable
later on with the fancier data structures.

An array of an array is just a regular old array @@AoA that you can
get at with two subscripts, like C<$AoA[3][2]>.  Here's a declaration
of the array:

    use 5.010;  # so we can use say()

    # assign to our array, an array of array references
    @@AoA = (
	   [ "fred", "barney", "pebbles", "bambam", "dino", ],
	   [ "george", "jane", "elroy", "judy", ],
	   [ "homer", "bart", "marge", "maggie", ],
    );
    say $AoA[2][1];
  bart

Now you should be very careful that the outer bracket type
is a round one, that is, a parenthesis.  That's because you're assigning to
an @@array, so you need parentheses.  If you wanted there I<not> to be an @@AoA,
but rather just a reference to it, you could do something more like this:

    # assign a reference to array of array references
    $ref_to_AoA = [
	[ "fred", "barney", "pebbles", "bambam", "dino", ],
	[ "george", "jane", "elroy", "judy", ],
	[ "homer", "bart", "marge", "maggie", ],
    ];
    say $ref_to_AoA->[2][1];
  bart

Notice that the outer bracket type has changed, and so our access syntax
has also changed.  That's because unlike C, in perl you can't freely
interchange arrays and references thereto.  $ref_to_AoA is a reference to an
array, whereas @@AoA is an array proper.  Likewise, C<$AoA[2]> is not an
array, but an array ref.  So how come you can write these:

    $AoA[2][2]
    $ref_to_AoA->[2][2]

instead of having to write these:

    $AoA[2]->[2]
    $ref_to_AoA->[2]->[2]

Well, that's because the rule is that on adjacent brackets only (whether
square or curly), you are free to omit the pointer dereferencing arrow.
But you cannot do so for the very first one if it's a scalar containing
a reference, which means that $ref_to_AoA always needs it.

=head2 Growing Your Own

That's all well and good for declaration of a fixed data structure,
but what if you wanted to add new elements on the fly, or build
it up entirely from scratch?

First, let's look at reading it in from a file.  This is something like
adding a row at a time.  We'll assume that there's a flat file in which
each line is a row and each word an element.  If you're trying to develop an
@@AoA array containing all these, here's the right way to do that:

    while (<>) {
	@@tmp = split;
	push @@AoA, [ @@tmp ];
    }

You might also have loaded that from a function:

    for $i ( 1 .. 10 ) {
	$AoA[$i] = [ somefunc($i) ];
    }

Or you might have had a temporary variable sitting around with the
array in it.

    for $i ( 1 .. 10 ) {
	@@tmp = somefunc($i);
	$AoA[$i] = [ @@tmp ];
    }

It's important you make sure to use the C<[ ]> array reference
constructor.  That's because this wouldn't work:

    $AoA[$i] = @@tmp;   # WRONG!

The reason that doesn't do what you want is because assigning a
named array like that to a scalar is taking an array in scalar
context, which means just counts the number of elements in @@tmp.

If you are running under C<use strict> (and if you aren't, why in
the world aren't you?), you'll have to add some declarations to
make it happy:

    use strict;
    my(@@AoA, @@tmp);
    while (<>) {
	@@tmp = split;
	push @@AoA, [ @@tmp ];
    }

Of course, you don't need the temporary array to have a name at all:

    while (<>) {
	push @@AoA, [ split ];
    }

You also don't have to use push().  You could just make a direct assignment
if you knew where you wanted to put it:

    my (@@AoA, $i, $line);
    for $i ( 0 .. 10 ) {
	$line = <>;
	$AoA[$i] = [ split " ", $line ];
    }

or even just

    my (@@AoA, $i);
    for $i ( 0 .. 10 ) {
	$AoA[$i] = [ split " ", <> ];
    }

You should in general be leery of using functions that could
potentially return lists in scalar context without explicitly stating
such.  This would be clearer to the casual reader:

    my (@@AoA, $i);
    for $i ( 0 .. 10 ) {
	$AoA[$i] = [ split " ", scalar(<>) ];
    }

If you wanted to have a $ref_to_AoA variable as a reference to an array,
you'd have to do something like this:

    while (<>) {
	push @@$ref_to_AoA, [ split ];
    }

Now you can add new rows.  What about adding new columns?  If you're
dealing with just matrices, it's often easiest to use simple assignment:

    for $x (1 .. 10) {
	for $y (1 .. 10) {
	    $AoA[$x][$y] = func($x, $y);
	}
    }

    for $x ( 3, 7, 9 ) {
	$AoA[$x][20] += func2($x);
    }

It doesn't matter whether those elements are already
there or not: it'll gladly create them for you, setting
intervening elements to C<undef> as need be.

If you wanted just to append to a row, you'd have
to do something a bit funnier looking:

    # add new columns to an existing row
    push @@{ $AoA[0] }, "wilma", "betty";   # explicit deref

=head2 Access and Printing

Now it's time to print your data structure out.  How
are you going to do that?  Well, if you want only one
of the elements, it's trivial:

    print $AoA[0][0];

If you want to print the whole thing, though, you can't
say

    print @@AoA;		# WRONG

because you'll get just references listed, and perl will never
automatically dereference things for you.  Instead, you have to
roll yourself a loop or two.  This prints the whole structure,
using the shell-style for() construct to loop across the outer
set of subscripts.

    for $aref ( @@AoA ) {
	say "\t [ @@$aref ],";
    }

If you wanted to keep track of subscripts, you might do this:

    for $i ( 0 .. $#AoA ) {
	say "\t elt $i is [ @@{$AoA[$i]} ],";
    }

or maybe even this.  Notice the inner loop.

    for $i ( 0 .. $#AoA ) {
	for $j ( 0 .. $#{$AoA[$i]} ) {
	    say "elt $i $j is $AoA[$i][$j]";
	}
    }

As you can see, it's getting a bit complicated.  That's why
sometimes is easier to take a temporary on your way through:

    for $i ( 0 .. $#AoA ) {
	$aref = $AoA[$i];
	for $j ( 0 .. $#{$aref} ) {
	    say "elt $i $j is $AoA[$i][$j]";
	}
    }

Hmm... that's still a bit ugly.  How about this:

    for $i ( 0 .. $#AoA ) {
	$aref = $AoA[$i];
	$n = @@$aref - 1;
	for $j ( 0 .. $n ) {
	    say "elt $i $j is $AoA[$i][$j]";
	}
    }

When you get tired of writing a custom print for your data structures,
you might look at the standard L<Dumpvalue> or L<Data::Dumper> modules.
The former is what the Perl debugger uses, while the latter generates
parsable Perl code.  For example:

 use v5.14;     # using the + prototype, new to v5.14

 sub show(+) {
	require Dumpvalue;
	state $prettily = new Dumpvalue::
			    tick        => q("),
			    compactDump => 1,  # comment these two lines
                                               # out
			    veryCompact => 1,  # if you want a bigger
                                               # dump
			;
	dumpValue $prettily @@_;
 }

 # Assign a list of array references to an array.
 my @@AoA = (
	   [ "fred", "barney" ],
	   [ "george", "jane", "elroy" ],
	   [ "homer", "marge", "bart" ],
 );
 push @@{ $AoA[0] }, "wilma", "betty";
 show @@AoA;

will print out:

    0  0..3  "fred" "barney" "wilma" "betty"
    1  0..2  "george" "jane" "elroy"
    2  0..2  "homer" "marge" "bart"

Whereas if you comment out the two lines I said you might wish to,
then it shows it to you this way instead:

    0  ARRAY(0x8031d0)
       0  "fred"
       1  "barney"
       2  "wilma"
       3  "betty"
    1  ARRAY(0x803d40)
       0  "george"
       1  "jane"
       2  "elroy"
    2  ARRAY(0x803e10)
       0  "homer"
       1  "marge"
       2  "bart"

=head2 Slices

If you want to get at a slice (part of a row) in a multidimensional
array, you're going to have to do some fancy subscripting.  That's
because while we have a nice synonym for single elements via the
pointer arrow for dereferencing, no such convenience exists for slices.

Here's how to do one operation using a loop.  We'll assume an @@AoA
variable as before.

    @@part = ();
    $x = 4;
    for ($y = 7; $y < 13; $y++) {
	push @@part, $AoA[$x][$y];
    }

That same loop could be replaced with a slice operation:

    @@part = @@{$AoA[4]}[7..12];

or spaced out a bit:

    @@part = @@{ $AoA[4] } [ 7..12 ];

But as you might well imagine, this can get pretty rough on the reader.

Ah, but what if you wanted a I<two-dimensional slice>, such as having
$x run from 4..8 and $y run from 7 to 12?  Hmm... here's the simple way:

    @@newAoA = ();
    for ($startx = $x = 4; $x <= 8; $x++) {
	for ($starty = $y = 7; $y <= 12; $y++) {
	    $newAoA[$x - $startx][$y - $starty] = $AoA[$x][$y];
	}
    }

We can reduce some of the looping through slices

    for ($x = 4; $x <= 8; $x++) {
	push @@newAoA, [ @@{ $AoA[$x] } [ 7..12 ] ];
    }

If you were into Schwartzian Transforms, you would probably
have selected map for that

    @@newAoA = map { [ @@{ $AoA[$_] } [ 7..12 ] ] } 4 .. 8;

Although if your manager accused you of seeking job security (or rapid
insecurity) through inscrutable code, it would be hard to argue. :-)
If I were you, I'd put that in a function:

    @@newAoA = splice_2D( \@@AoA, 4 => 8, 7 => 12 );
    sub splice_2D {
	my $lrr = shift; 	# ref to array of array refs!
	my ($x_lo, $x_hi,
	    $y_lo, $y_hi) = @@_;

	return map {
	    [ @@{ $lrr->[$_] } [ $y_lo .. $y_hi ] ]
	} $x_lo .. $x_hi;
    }


=head1 SEE ALSO

L<perldata>, L<perlref>, L<perldsc>

=head1 AUTHOR

Tom Christiansen <F<tchrist@@perl.com>>

Last update: Tue Apr 26 18:30:55 MDT 2011
@


1.9
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@a172 38
Prior to Perl 5.14, this wouldn't even compile:

    push $AoA[0], "wilma", "betty";        # implicit deref

How come?  Because once upon a time, the argument to push() had to be a
real array, not just a reference to one. That's no longer true.  In fact,
the line marked "implicit deref" above works just fine--in this
instance--to do what the one that says explicit deref did.

The reason I said "in this instance" is because that I<only> works
because C<$AoA[0]> already held an array reference.  If you try that on an
undefined variable, you'll take an exception.  That's because the implicit
derefererence will never autovivify an undefined variable the way C<@@{ }>
always will:

    my $aref = undef;
    push $aref,  qw(some more values);  # WRONG!
    push @@$aref, qw(a few more);        # ok

If you want to take advantage of this new implicit dereferencing behavior,
go right ahead: it makes code easier on the eye and wrist.  Just understand
that older releases will choke on it during compilation.  Whenever you make
use of something that works only in some given release of Perl and later,
but not earlier, you should place a prominent

    use v5.14;   # needed for implicit deref of array refs by array ops

directive at the top of the file that needs it.  That way when somebody
tries to run the new code under an old perl, rather than getting an error like

    Type of arg 1 to push must be array (not array element) at /tmp/a line 8, near ""betty";"
    Execution of /tmp/a aborted due to compilation errors.

they'll be politely informed that

    Perl v5.14.0 required--this is only v5.12.3, stopped at /tmp/a line 1.
    BEGIN failed--compilation aborted at /tmp/a line 1.

d235 1
a235 1
    use v5.14;     # using the + prototype, new to v5.14
d237 1
a237 1
    sub show(+) {
d241 4
a244 2
			    compactDump => 1,  # comment these two lines out
			    veryCompact => 1,  # if you want a bigger dump
d247 1
a247 1
    }
d249 2
a250 2
    # Assign a list of array references to an array.
    my @@AoA = (
d254 3
a256 3
    );
    push $AoA[0], "wilma", "betty";
    show @@AoA;
@


1.8
log
@merge in perl 5.12.2 plus local changes
@
text
@d9 4
a12 4
The simplest thing to build is an array of arrays (sometimes imprecisely
called a list of lists).  It's reasonably easy to understand, and
almost everything that applies here will also be applicable later
on with the fancier data structures.
d18 2
d22 3
a24 3
	   [ "fred", "barney" ],
	   [ "george", "jane", "elroy" ],
	   [ "homer", "marge", "bart" ],
d26 1
a26 2

    print $AoA[2][2];
d37 1
a38 1
	[ "george", "jane", "elroy", "judy", ],
d40 2
a41 2

    print $ref_to_AoA->[2][2];
d92 2
a93 4
It's very important that you make sure to use the C<[]> array reference
constructor.  That's because this will be very wrong:

    $AoA[$i] = @@tmp;
d95 1
a95 2
You see, assigning a named array like that to a scalar just counts the
number of elements in @@tmp, which probably isn't what you want.
d97 7
a103 2
If you are running under C<use strict>, you'll have to add some
declarations to make it happy:
d124 1
a124 1
	$AoA[$i] = [ split ' ', $line ];
d131 1
a131 1
	$AoA[$i] = [ split ' ', <> ];
d140 1
a140 1
	$AoA[$i] = [ split ' ', scalar(<>) ];
d171 20
a190 1
    push @@{ $AoA[0] }, "wilma", "betty";
d192 5
a196 1
Notice that I I<couldn't> say just:
d198 1
a198 1
    push $AoA[0], "wilma", "betty";  # WRONG!
d200 10
a209 2
In fact, that wouldn't even compile.  How come?  Because the argument
to push() must be a real array, not just a reference to such.
d231 1
a231 1
	print "\t [ @@$aref ],\n";
d237 1
a237 1
	print "\t elt $i is [ @@{$AoA[$i]} ],\n";
d244 1
a244 1
	    print "elt $i $j is $AoA[$i][$j]\n";
d254 1
a254 1
	    print "elt $i $j is $AoA[$i][$j]\n";
d264 1
a264 1
	    print "elt $i $j is $AoA[$i][$j]\n";
d268 49
a322 2
(Remember, of course, that you can always write a loop to do a slice
operation.)
d335 4
d341 1
a341 1
but as you might well imagine, this is pretty rough on the reader.
d388 1
a388 1
Last update: Thu Jun  4 16:16:23 MDT 1998
@


1.7
log
@Merge in perl 5.10.1
@
text
@d297 1
a297 1
perldata(1), perlref(1), perldsc(1)
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d279 1
a279 1
Although if your manager accused of seeking job security (or rapid
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d9 1
a9 1
The simplest thing to build an array of arrays (sometimes imprecisely
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d7 1
a7 1
=head1 Declaration and Access of Arrays of Arrays
d61 1
a61 1
=head1 Growing Your Own
d177 1
a177 1
=head1 Access and Printing
d234 1
a234 1
=head1 Slices
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
perlLoL - Manipulating Lists of Lists in Perl
d7 1
a7 1
=head1 Declaration and Access of Lists of Lists
d9 8
a16 8
The simplest thing to build is a list of lists (sometimes called an array
of arrays).  It's reasonably easy to understand, and almost everything
that applies here will also be applicable later on with the fancier data
structures.

A list of lists, or an array of an array if you would, is just a regular
old array @@LoL that you can get at with two subscripts, like C<$LoL[3][2]>.  Here's
a declaration of the array:
d18 2
a19 2
    # assign to our array a list of list references
    @@LoL = (
d25 1
a25 1
    print $LoL[2][2];
d30 1
a30 1
an @@list, so you need parentheses.  If you wanted there I<not> to be an @@LoL,
d33 2
a34 2
    # assign a reference to list of list references
    $ref_to_LoL = [
d40 1
a40 1
    print $ref_to_LoL->[2][2];
d44 2
a45 2
interchange arrays and references thereto.  $ref_to_LoL is a reference to an
array, whereas @@LoL is an array proper.  Likewise, C<$LoL[2]> is not an
d48 2
a49 2
    $LoL[2][2]
    $ref_to_LoL->[2][2]
d53 2
a54 2
    $LoL[2]->[2]
    $ref_to_LoL->[2]->[2]
d59 1
a59 1
a reference, which means that $ref_to_LoL always needs it.
d70 1
a70 1
@@LoL list containing all these, here's the right way to do that:
d74 1
a74 1
	push @@LoL, [ @@tmp ];
d80 1
a80 1
	$LoL[$i] = [ somefunc($i) ];
d84 1
a84 1
list in it.
d88 1
a88 1
	$LoL[$i] = [ @@tmp ];
d91 1
a91 1
It's very important that you make sure to use the C<[]> list reference
d94 1
a94 1
    $LoL[$i] = @@tmp;
d96 1
a96 1
You see, assigning a named list like that to a scalar just counts the
d103 1
a103 1
    my(@@LoL, @@tmp);
d106 1
a106 1
	push @@LoL, [ @@tmp ];
d112 1
a112 1
	push @@LoL, [ split ];
d118 1
a118 1
    my (@@LoL, $i, $line);
d121 1
a121 1
	$LoL[$i] = [ split ' ', $line ];
d126 1
a126 1
    my (@@LoL, $i);
d128 1
a128 1
	$LoL[$i] = [ split ' ', <> ];
d131 3
a133 3
You should in general be leery of using potential list functions
in a scalar context without explicitly stating such.
This would be clearer to the casual reader:
d135 1
a135 1
    my (@@LoL, $i);
d137 1
a137 1
	$LoL[$i] = [ split ' ', scalar(<>) ];
d140 1
a140 1
If you wanted to have a $ref_to_LoL variable as a reference to an array,
d144 1
a144 1
	push @@$ref_to_LoL, [ split ];
d152 1
a152 1
	    $LoL[$x][$y] = func($x, $y);
d157 1
a157 1
	$LoL[$x][20] += func2($x);
d168 1
a168 1
    push @@{ $LoL[0] }, "wilma", "betty";
d172 1
a172 1
    push $LoL[0], "wilma", "betty";  # WRONG!
d183 1
a183 1
    print $LoL[0][0];
d188 1
a188 1
    print @@LoL;		# WRONG
d196 1
a196 1
    for $aref ( @@LoL ) {
d202 2
a203 2
    for $i ( 0 .. $#LoL ) {
	print "\t elt $i is [ @@{$LoL[$i]} ],\n";
d208 3
a210 3
    for $i ( 0 .. $#LoL ) {
	for $j ( 0 .. $#{$LoL[$i]} ) {
	    print "elt $i $j is $LoL[$i][$j]\n";
d217 2
a218 2
    for $i ( 0 .. $#LoL ) {
	$aref = $LoL[$i];
d220 1
a220 1
	    print "elt $i $j is $LoL[$i][$j]\n";
d226 2
a227 2
    for $i ( 0 .. $#LoL ) {
	$aref = $LoL[$i];
d230 1
a230 1
	    print "elt $i $j is $LoL[$i][$j]\n";
d243 1
a243 1
Here's how to do one operation using a loop.  We'll assume an @@LoL
d249 1
a249 1
	push @@part, $LoL[$x][$y];
d254 1
a254 1
    @@part = @@{ $LoL[4] } [ 7..12 ];
d261 1
a261 1
    @@newLoL = ();
d264 1
a264 1
	    $newLoL[$x - $startx][$y - $starty] = $LoL[$x][$y];
d271 1
a271 1
	push @@newLoL, [ @@{ $LoL[$x] } [ 7..12 ] ];
d277 1
a277 1
    @@newLoL = map { [ @@{ $LoL[$_] } [ 7..12 ] ] } 4 .. 8;
d283 1
a283 1
    @@newLoL = splice_2D( \@@LoL, 4 => 8, 7 => 12 );
d285 1
a285 1
	my $lrr = shift; 	# ref to list of list refs!
@


1.2
log
@perl 5.004_04
@
text
@d29 1
a29 1
is a round one, that is, parentheses.  That's because you're assigning to
d37 1
a37 1
	[ "george", "jane", "alroy", "judy", ],
d147 1
a147 11
Actually, if you were using strict, you'd have to declare not only
$ref_to_LoL as you had to declare @@LoL, but you'd I<also> having to
initialize it to a reference to an empty list.  (This was a bug in
perl version 5.001m that's been fixed for the 5.002 release.)

    my $ref_to_LoL = [];
    while (<>) {
	push @@$ref_to_LoL, [ split ];
    }

Ok, now you can add new rows.  What about adding new columns?  If you're
d303 1
a303 1
Last udpate: Sat Oct  7 19:35:26 MDT 1995
@


1.1
log
@Initial revision
@
text
@d15 1
a15 1
old array @@LoL that you can get at with two subscripts, like $LoL[3][2].  Here's
d19 1
a19 1
    @@LoL = ( 
d30 1
a30 1
an @@list, so you need parens.  If you wanted there I<not> to be an @@LoL,
d42 1
a42 1
Notice that the outer bracket type has changed, and so our access syntax 
d44 2
a45 2
interchange arrays and references thereto.  $ref_to_LoL is a reference to an 
array, whereas @@LoL is an array proper.  Likewise, $LoL[2] is not an 
d57 2
a58 2
square or curly), you are free to omit the pointer dereferencing array.
But you need not do so for the very first one if it's a scalar containing
d75 1
a75 1
    } 
d84 1
a84 1
list in it.  
d96 2
a97 2
You see, assigning a named list like that to a scalar just counts the 
number of elements in @@tmp, which probably isn't what you want.  
d107 1
a107 1
    } 
d113 1
a113 1
    } 
d119 1
a119 1
    for $i ( 0 .. 10 ) 
d122 1
a122 1
    } 
d127 1
a127 1
    for $i ( 0 .. 10 ) 
d129 1
a129 1
    } 
d131 2
a132 2
You should in general be leary of using potential list functions
in a scalar context without explicitly stating such.  
d136 1
a136 1
    for $i ( 0 .. 10 ) 
d138 1
a138 1
    } 
d145 1
a145 1
    } 
d147 4
a150 4
Actually, if you were using strict, you'd not only have to declare $ref_to_LoL as
you had to declare @@LoL, but you'd I<also> having to initialize it to a
reference to an empty list.  (This was a bug in 5.001m that's been fixed
for the 5.002 release.)
d155 1
a155 1
    } 
d158 1
a158 1
just dealing with matrices, it's often easiest to use simple assignment:
d168 1
a168 1
    } 
d170 1
a170 1
It doesn't matter whether those elements are already 
d174 1
a174 1
If you just wanted to append to a row, you'd have
d180 1
a180 1
Notice that I I<couldn't> just say:
d189 2
a190 2
Now it's time to print your data structure out.  How 
are you going to do that?  Well, if you only want one
d196 1
a196 1
just say 
d200 2
a201 2
because you'll just get references listed, and perl will never
automatically dereference things for you.  Instead, you have to 
d204 1
a204 1
set of subscripts.  
d224 1
a224 1
As you can see, it's getting a bit complicated.  That's why 
d234 1
a234 1
Hm... that's still a bit ugly.  How about this:
d246 1
a246 1
If you want to get at a slide (part of a row) in a multidimensional
d257 1
a257 1
    $x = 4; 	
d260 1
a260 1
    } 
d269 1
a269 1
$x run from 4..8 and $y run from 7 to 12?  Hm... here's the simple way:
d273 1
a273 1
	for ($starty = $y = 7; $x <= 12; $y++) {
d276 1
a276 1
    } 
d278 1
a278 1
We can reduce some of the looping through slices 
d296 1
a296 1
	my ($x_lo, $x_hi, 
d299 2
a300 2
	return map { 
	    [ @@{ $lrr->[$_] } [ $y_lo .. $y_hi ] ] 
d302 1
a302 1
    } 
d311 1
a311 1
Tom Christiansen <tchrist@@perl.com>
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d15 1
a15 1
old array @@LoL that you can get at with two subscripts, like C<$LoL[3][2]>.  Here's
d19 1
a19 1
    @@LoL = (
d29 2
a30 2
is a round one, that is, a parenthesis.  That's because you're assigning to
an @@list, so you need parentheses.  If you wanted there I<not> to be an @@LoL,
d37 1
a37 1
	[ "george", "jane", "elroy", "judy", ],
d42 1
a42 1
Notice that the outer bracket type has changed, and so our access syntax
d44 2
a45 2
interchange arrays and references thereto.  $ref_to_LoL is a reference to an
array, whereas @@LoL is an array proper.  Likewise, C<$LoL[2]> is not an
d57 2
a58 2
square or curly), you are free to omit the pointer dereferencing arrow.
But you cannot do so for the very first one if it's a scalar containing
d75 1
a75 1
    }
d84 1
a84 1
list in it.
d96 2
a97 2
You see, assigning a named list like that to a scalar just counts the
number of elements in @@tmp, which probably isn't what you want.
d107 1
a107 1
    }
d113 1
a113 1
    }
d119 1
a119 1
    for $i ( 0 .. 10 ) {
d122 1
a122 1
    }
d127 1
a127 1
    for $i ( 0 .. 10 ) {
d129 1
a129 1
    }
d131 2
a132 2
You should in general be leery of using potential list functions
in a scalar context without explicitly stating such.
d136 1
a136 1
    for $i ( 0 .. 10 ) {
d138 1
a138 1
    }
d145 11
a155 1
    }
d157 2
a158 2
Now you can add new rows.  What about adding new columns?  If you're
dealing with just matrices, it's often easiest to use simple assignment:
d168 1
a168 1
    }
d170 1
a170 1
It doesn't matter whether those elements are already
d174 1
a174 1
If you wanted just to append to a row, you'd have
d180 1
a180 1
Notice that I I<couldn't> say just:
d189 2
a190 2
Now it's time to print your data structure out.  How
are you going to do that?  Well, if you want only one
d196 1
a196 1
say
d200 2
a201 2
because you'll get just references listed, and perl will never
automatically dereference things for you.  Instead, you have to
d204 1
a204 1
set of subscripts.
d224 1
a224 1
As you can see, it's getting a bit complicated.  That's why
d234 1
a234 1
Hmm... that's still a bit ugly.  How about this:
d246 1
a246 1
If you want to get at a slice (part of a row) in a multidimensional
d257 1
a257 1
    $x = 4;
d260 1
a260 1
    }
d269 1
a269 1
$x run from 4..8 and $y run from 7 to 12?  Hmm... here's the simple way:
d273 1
a273 1
	for ($starty = $y = 7; $y <= 12; $y++) {
d276 1
a276 1
    }
d278 1
a278 1
We can reduce some of the looping through slices
d296 1
a296 1
	my ($x_lo, $x_hi,
d299 2
a300 2
	return map {
	    [ @@{ $lrr->[$_] } [ $y_lo .. $y_hi ] ]
d302 1
a302 1
    }
d311 1
a311 1
Tom Christiansen <F<tchrist@@perl.com>>
d313 1
a313 1
Last update: Thu Jun  4 16:16:23 MDT 1998
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
perllol - Manipulating Arrays of Arrays in Perl
d7 1
a7 1
=head1 Declaration and Access of Arrays of Arrays
d9 8
a16 8
The simplest thing to build an array of arrays (sometimes imprecisely
called a list of lists).  It's reasonably easy to understand, and
almost everything that applies here will also be applicable later
on with the fancier data structures.

An array of an array is just a regular old array @@AoA that you can
get at with two subscripts, like C<$AoA[3][2]>.  Here's a declaration
of the array:
d18 2
a19 2
    # assign to our array, an array of array references
    @@AoA = (
d25 1
a25 1
    print $AoA[2][2];
d30 1
a30 1
an @@array, so you need parentheses.  If you wanted there I<not> to be an @@AoA,
d33 2
a34 2
    # assign a reference to array of array references
    $ref_to_AoA = [
d40 1
a40 1
    print $ref_to_AoA->[2][2];
d44 2
a45 2
interchange arrays and references thereto.  $ref_to_AoA is a reference to an
array, whereas @@AoA is an array proper.  Likewise, C<$AoA[2]> is not an
d48 2
a49 2
    $AoA[2][2]
    $ref_to_AoA->[2][2]
d53 2
a54 2
    $AoA[2]->[2]
    $ref_to_AoA->[2]->[2]
d59 1
a59 1
a reference, which means that $ref_to_AoA always needs it.
d70 1
a70 1
@@AoA array containing all these, here's the right way to do that:
d74 1
a74 1
	push @@AoA, [ @@tmp ];
d80 1
a80 1
	$AoA[$i] = [ somefunc($i) ];
d84 1
a84 1
array in it.
d88 1
a88 1
	$AoA[$i] = [ @@tmp ];
d91 1
a91 1
It's very important that you make sure to use the C<[]> array reference
d94 1
a94 1
    $AoA[$i] = @@tmp;
d96 1
a96 1
You see, assigning a named array like that to a scalar just counts the
d103 1
a103 1
    my(@@AoA, @@tmp);
d106 1
a106 1
	push @@AoA, [ @@tmp ];
d112 1
a112 1
	push @@AoA, [ split ];
d118 1
a118 1
    my (@@AoA, $i, $line);
d121 1
a121 1
	$AoA[$i] = [ split ' ', $line ];
d126 1
a126 1
    my (@@AoA, $i);
d128 1
a128 1
	$AoA[$i] = [ split ' ', <> ];
d131 3
a133 3
You should in general be leery of using functions that could
potentially return lists in scalar context without explicitly stating
such.  This would be clearer to the casual reader:
d135 1
a135 1
    my (@@AoA, $i);
d137 1
a137 1
	$AoA[$i] = [ split ' ', scalar(<>) ];
d140 1
a140 1
If you wanted to have a $ref_to_AoA variable as a reference to an array,
d144 1
a144 1
	push @@$ref_to_AoA, [ split ];
d152 1
a152 1
	    $AoA[$x][$y] = func($x, $y);
d157 1
a157 1
	$AoA[$x][20] += func2($x);
d168 1
a168 1
    push @@{ $AoA[0] }, "wilma", "betty";
d172 1
a172 1
    push $AoA[0], "wilma", "betty";  # WRONG!
d183 1
a183 1
    print $AoA[0][0];
d188 1
a188 1
    print @@AoA;		# WRONG
d196 1
a196 1
    for $aref ( @@AoA ) {
d202 2
a203 2
    for $i ( 0 .. $#AoA ) {
	print "\t elt $i is [ @@{$AoA[$i]} ],\n";
d208 3
a210 3
    for $i ( 0 .. $#AoA ) {
	for $j ( 0 .. $#{$AoA[$i]} ) {
	    print "elt $i $j is $AoA[$i][$j]\n";
d217 2
a218 2
    for $i ( 0 .. $#AoA ) {
	$aref = $AoA[$i];
d220 1
a220 1
	    print "elt $i $j is $AoA[$i][$j]\n";
d226 2
a227 2
    for $i ( 0 .. $#AoA ) {
	$aref = $AoA[$i];
d230 1
a230 1
	    print "elt $i $j is $AoA[$i][$j]\n";
d243 1
a243 1
Here's how to do one operation using a loop.  We'll assume an @@AoA
d249 1
a249 1
	push @@part, $AoA[$x][$y];
d254 1
a254 1
    @@part = @@{ $AoA[4] } [ 7..12 ];
d261 1
a261 1
    @@newAoA = ();
d264 1
a264 1
	    $newAoA[$x - $startx][$y - $starty] = $AoA[$x][$y];
d271 1
a271 1
	push @@newAoA, [ @@{ $AoA[$x] } [ 7..12 ] ];
d277 1
a277 1
    @@newAoA = map { [ @@{ $AoA[$_] } [ 7..12 ] ] } 4 .. 8;
d283 1
a283 1
    @@newAoA = splice_2D( \@@AoA, 4 => 8, 7 => 12 );
d285 1
a285 1
	my $lrr = shift; 	# ref to array of array refs!
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d7 1
a7 1
=head2 Declaration and Access of Arrays of Arrays
d61 1
a61 1
=head2 Growing Your Own
d177 1
a177 1
=head2 Access and Printing
d234 1
a234 1
=head2 Slices
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d9 1
a9 1
The simplest thing to build is an array of arrays (sometimes imprecisely
@


1.1.1.6
log
@import perl 5.10.1
@
text
@d279 1
a279 1
Although if your manager accused you of seeking job security (or rapid
@


1.1.1.7
log
@Perl 5.12.2 from CPAN
@
text
@d297 1
a297 1
L<perldata>, L<perlref>, L<perldsc>
@


1.1.1.8
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d9 4
a12 4
The simplest two-level data structure to build in Perl is an array of
arrays, sometimes casually called a list of lists.  It's reasonably easy to
understand, and almost everything that applies here will also be applicable
later on with the fancier data structures.
a17 2
    use 5.010;  # so we can use say()

d20 3
a22 3
	   [ "fred", "barney", "pebbles", "bambam", "dino", ],
	   [ "george", "jane", "elroy", "judy", ],
	   [ "homer", "bart", "marge", "maggie", ],
d24 2
a25 1
    say $AoA[2][1];
d36 1
a37 1
	[ "homer", "bart", "marge", "maggie", ],
d39 2
a40 2
    say $ref_to_AoA->[2][1];
  bart
d91 4
a94 2
It's important you make sure to use the C<[ ]> array reference
constructor.  That's because this wouldn't work:
d96 2
a97 1
    $AoA[$i] = @@tmp;   # WRONG!
d99 2
a100 7
The reason that doesn't do what you want is because assigning a
named array like that to a scalar is taking an array in scalar
context, which means just counts the number of elements in @@tmp.

If you are running under C<use strict> (and if you aren't, why in
the world aren't you?), you'll have to add some declarations to
make it happy:
d121 1
a121 1
	$AoA[$i] = [ split " ", $line ];
d128 1
a128 1
	$AoA[$i] = [ split " ", <> ];
d137 1
a137 1
	$AoA[$i] = [ split " ", scalar(<>) ];
d168 1
a168 20
    push @@{ $AoA[0] }, "wilma", "betty";   # explicit deref

Prior to Perl 5.14, this wouldn't even compile:

    push $AoA[0], "wilma", "betty";        # implicit deref

How come?  Because once upon a time, the argument to push() had to be a
real array, not just a reference to one. That's no longer true.  In fact,
the line marked "implicit deref" above works just fine--in this
instance--to do what the one that says explicit deref did.

The reason I said "in this instance" is because that I<only> works
because C<$AoA[0]> already held an array reference.  If you try that on an
undefined variable, you'll take an exception.  That's because the implicit
derefererence will never autovivify an undefined variable the way C<@@{ }>
always will:

    my $aref = undef;
    push $aref,  qw(some more values);  # WRONG!
    push @@$aref, qw(a few more);        # ok
d170 1
a170 5
If you want to take advantage of this new implicit dereferencing behavior,
go right ahead: it makes code easier on the eye and wrist.  Just understand
that older releases will choke on it during compilation.  Whenever you make
use of something that works only in some given release of Perl and later,
but not earlier, you should place a prominent
d172 1
a172 1
    use v5.14;   # needed for implicit deref of array refs by array ops
d174 2
a175 10
directive at the top of the file that needs it.  That way when somebody
tries to run the new code under an old perl, rather than getting an error like

    Type of arg 1 to push must be array (not array element) at /tmp/a line 8, near ""betty";"
    Execution of /tmp/a aborted due to compilation errors.

they'll be politely informed that

    Perl v5.14.0 required--this is only v5.12.3, stopped at /tmp/a line 1.
    BEGIN failed--compilation aborted at /tmp/a line 1.
d197 1
a197 1
	say "\t [ @@$aref ],";
d203 1
a203 1
	say "\t elt $i is [ @@{$AoA[$i]} ],";
d210 1
a210 1
	    say "elt $i $j is $AoA[$i][$j]";
d220 1
a220 1
	    say "elt $i $j is $AoA[$i][$j]";
d230 1
a230 1
	    say "elt $i $j is $AoA[$i][$j]";
a233 49
When you get tired of writing a custom print for your data structures,
you might look at the standard L<Dumpvalue> or L<Data::Dumper> modules.
The former is what the Perl debugger uses, while the latter generates
parsable Perl code.  For example:

    use v5.14;     # using the + prototype, new to v5.14

    sub show(+) {
	require Dumpvalue;
	state $prettily = new Dumpvalue::
			    tick        => q("),
			    compactDump => 1,  # comment these two lines out
			    veryCompact => 1,  # if you want a bigger dump
			;
	dumpValue $prettily @@_;
    }

    # Assign a list of array references to an array.
    my @@AoA = (
	   [ "fred", "barney" ],
	   [ "george", "jane", "elroy" ],
	   [ "homer", "marge", "bart" ],
    );
    push $AoA[0], "wilma", "betty";
    show @@AoA;

will print out:

    0  0..3  "fred" "barney" "wilma" "betty"
    1  0..2  "george" "jane" "elroy"
    2  0..2  "homer" "marge" "bart"

Whereas if you comment out the two lines I said you might wish to,
then it shows it to you this way instead:

    0  ARRAY(0x8031d0)
       0  "fred"
       1  "barney"
       2  "wilma"
       3  "betty"
    1  ARRAY(0x803d40)
       0  "george"
       1  "jane"
       2  "elroy"
    2  ARRAY(0x803e10)
       0  "homer"
       1  "marge"
       2  "bart"

d240 2
a253 4
    @@part = @@{$AoA[4]}[7..12];

or spaced out a bit:

d256 1
a256 1
But as you might well imagine, this can get pretty rough on the reader.
d303 1
a303 1
Last update: Tue Apr 26 18:30:55 MDT 2011
@


