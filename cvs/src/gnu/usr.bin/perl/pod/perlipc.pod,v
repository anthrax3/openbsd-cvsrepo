head	1.18;
access;
symbols
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.17.0.8
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.17.0.4
	OPENBSD_5_8_BASE:1.17
	PERL_5_20_2:1.1.1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	PERL_5_20_1:1.1.1.15
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	PERL_5_18_2:1.1.1.14
	PERL:1.1.1
	OPENBSD_5_5:1.14.0.6
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	PERL_5_16_3:1.1.1.13
	OPENBSD_5_3:1.13.0.10
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.8
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.6
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	PERL_5_12_2:1.1.1.12
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	PERL_5_10_1:1.1.1.11
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	PERL_5_10_0:1.1.1.10
	OPENBSD_4_4:1.10.0.10
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.8
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	PERL_5_8_8:1.1.1.9
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	PERL_5_8_6:1.1.1.8
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.18
date	2017.02.05.00.32.18;	author afresh1;	state Exp;
branches;
next	1.17;
commitid	cxJ08BvJA9Pt2PTM;

1.17
date	2015.04.25.19.14.48;	author afresh1;	state Exp;
branches;
next	1.16;
commitid	XRK22kO4se3v2i2I;

1.16
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.15;
commitid	QP75iYx42Uo7mMxO;

1.15
date	2014.03.24.15.05.33;	author afresh1;	state Exp;
branches;
next	1.14;

1.14
date	2013.03.25.20.40.59;	author sthen;	state Exp;
branches;
next	1.13;

1.13
date	2010.09.24.15.07.04;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.12.18.24.47;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.29.17.36.16;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.28.19.23.10;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2005.01.15.21.30.37;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.09.18.10.16;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.45;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.33;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.35.56;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.07.33;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.16;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.59.17;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.02;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.02;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.40.50;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.27;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.24.40;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.05;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.22;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.48.15;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2005.01.15.21.17.55;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2006.03.28.18.49.21;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2008.09.29.17.18.52;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2009.10.12.18.10.39;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2010.09.24.14.49.07;	author millert;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2013.03.25.20.09.21;	author sthen;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.03.24.14.59.08;	author afresh1;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2014.11.17.20.53.14;	author afresh1;	state Exp;
branches;
next	1.1.1.16;
commitid	B31cAbBIXiCqnL97;

1.1.1.16
date	2015.04.25.19.10.44;	author afresh1;	state Exp;
branches;
next	;
commitid	Wpcs5S8qILgEZC7F;


desc
@@


1.18
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@=head1 NAME

perlipc - Perl interprocess communication (signals, fifos, pipes, safe subprocesses, sockets, and semaphores)

=head1 DESCRIPTION

The basic IPC facilities of Perl are built out of the good old Unix
signals, named pipes, pipe opens, the Berkeley socket routines, and SysV
IPC calls.  Each is used in slightly different situations.

=head1 Signals

Perl uses a simple signal handling model: the %SIG hash contains names
or references of user-installed signal handlers.  These handlers will
be called with an argument which is the name of the signal that
triggered it.  A signal may be generated intentionally from a
particular keyboard sequence like control-C or control-Z, sent to you
from another process, or triggered automatically by the kernel when
special events transpire, like a child process exiting, your own process
running out of stack space, or hitting a process file-size limit.

For example, to trap an interrupt signal, set up a handler like this:

    our $shucks;

    sub catch_zap {
        my $signame = shift;
        $shucks++;
        die "Somebody sent me a SIG$signame";
    }
    $SIG{INT} = __PACKAGE__ . "::catch_zap";
    $SIG{INT} = \&catch_zap;  # best strategy

Prior to Perl 5.8.0 it was necessary to do as little as you possibly
could in your handler; notice how all we do is set a global variable
and then raise an exception.  That's because on most systems,
libraries are not re-entrant; particularly, memory allocation and I/O
routines are not.  That meant that doing nearly I<anything> in your
handler could in theory trigger a memory fault and subsequent core
dump - see L</Deferred Signals (Safe Signals)> below.

The names of the signals are the ones listed out by C<kill -l> on your
system, or you can retrieve them using the CPAN module L<IPC::Signal>.

You may also choose to assign the strings C<"IGNORE"> or C<"DEFAULT"> as
the handler, in which case Perl will try to discard the signal or do the
default thing.

On most Unix platforms, the C<CHLD> (sometimes also known as C<CLD>) signal
has special behavior with respect to a value of C<"IGNORE">.
Setting C<$SIG{CHLD}> to C<"IGNORE"> on such a platform has the effect of
not creating zombie processes when the parent process fails to C<wait()>
on its child processes (i.e., child processes are automatically reaped).
Calling C<wait()> with C<$SIG{CHLD}> set to C<"IGNORE"> usually returns
C<-1> on such platforms.

Some signals can be neither trapped nor ignored, such as the KILL and STOP
(but not the TSTP) signals. Note that ignoring signals makes them disappear.
If you only want them blocked temporarily without them getting lost you'll
have to use POSIX' sigprocmask.

Sending a signal to a negative process ID means that you send the signal
to the entire Unix process group.  This code sends a hang-up signal to all
processes in the current process group, and also sets $SIG{HUP} to C<"IGNORE">
so it doesn't kill itself:

    # block scope for local
    {
        local $SIG{HUP} = "IGNORE";
        kill HUP => -$$;
        # snazzy writing of: kill("HUP", -$$)
    }

Another interesting signal to send is signal number zero.  This doesn't
actually affect a child process, but instead checks whether it's alive
or has changed its UIDs.

    unless (kill 0 => $kid_pid) {
        warn "something wicked happened to $kid_pid";
    }

Signal number zero may fail because you lack permission to send the
signal when directed at a process whose real or saved UID is not
identical to the real or effective UID of the sending process, even
though the process is alive.  You may be able to determine the cause of
failure using C<$!> or C<%!>.

    unless (kill(0 => $pid) || $!{EPERM}) {
        warn "$pid looks dead";
    }

You might also want to employ anonymous functions for simple signal
handlers:

    $SIG{INT} = sub { die "\nOutta here!\n" };

SIGCHLD handlers require some special care.  If a second child dies
while in the signal handler caused by the first death, we won't get
another signal. So must loop here else we will leave the unreaped child
as a zombie. And the next time two children die we get another zombie.
And so on.

    use POSIX ":sys_wait_h";
    $SIG{CHLD} = sub {
        while ((my $child = waitpid(-1, WNOHANG)) > 0) {
            $Kid_Status{$child} = $?;
        }
    };
    # do something that forks...

Be careful: qx(), system(), and some modules for calling external commands
do a fork(), then wait() for the result. Thus, your signal handler
will be called. Because wait() was already called by system() or qx(),
the wait() in the signal handler will see no more zombies and will
therefore block.

The best way to prevent this issue is to use waitpid(), as in the following
example:

    use POSIX ":sys_wait_h"; # for nonblocking read

    my %children;

    $SIG{CHLD} = sub {
        # don't change $! and $? outside handler
        local ($!, $?);
        while ( (my $pid = waitpid(-1, WNOHANG)) > 0 ) {
            delete $children{$pid};
            cleanup_child($pid, $?);
        }
    };

    while (1) {
        my $pid = fork();
        die "cannot fork" unless defined $pid;
        if ($pid == 0) {
            # ...
            exit 0;
        } else {
            $children{$pid}=1;
            # ...
            system($command);
            # ...
       }
    }

Signal handling is also used for timeouts in Unix.  While safely
protected within an C<eval{}> block, you set a signal handler to trap
alarm signals and then schedule to have one delivered to you in some
number of seconds.  Then try your blocking operation, clearing the alarm
when it's done but not before you've exited your C<eval{}> block.  If it
goes off, you'll use die() to jump out of the block.

Here's an example:

    my $ALARM_EXCEPTION = "alarm clock restart";
    eval {
        local $SIG{ALRM} = sub { die $ALARM_EXCEPTION };
        alarm 10;
        flock(FH, 2)    # blocking write lock
                        || die "cannot flock: $!";
        alarm 0;
    };
    if ($@@ && $@@ !~ quotemeta($ALARM_EXCEPTION)) { die }

If the operation being timed out is system() or qx(), this technique
is liable to generate zombies.    If this matters to you, you'll
need to do your own fork() and exec(), and kill the errant child process.

For more complex signal handling, you might see the standard POSIX
module.  Lamentably, this is almost entirely undocumented, but the
F<ext/POSIX/t/sigaction.t> file from the Perl source distribution has
some examples in it.

=head2 Handling the SIGHUP Signal in Daemons

A process that usually starts when the system boots and shuts down
when the system is shut down is called a daemon (Disk And Execution
MONitor). If a daemon process has a configuration file which is
modified after the process has been started, there should be a way to
tell that process to reread its configuration file without stopping
the process. Many daemons provide this mechanism using a C<SIGHUP>
signal handler. When you want to tell the daemon to reread the file,
simply send it the C<SIGHUP> signal.

The following example implements a simple daemon, which restarts
itself every time the C<SIGHUP> signal is received. The actual code is
located in the subroutine C<code()>, which just prints some debugging
info to show that it works; it should be replaced with the real code.

  #!/usr/bin/perl

  use strict;
  use warnings;

  use POSIX ();
  use FindBin ();
  use File::Basename ();
  use File::Spec::Functions qw(catfile);

  $| = 1;

  # make the daemon cross-platform, so exec always calls the script
  # itself with the right path, no matter how the script was invoked.
  my $script = File::Basename::basename($0);
  my $SELF  = catfile($FindBin::Bin, $script);

  # POSIX unmasks the sigprocmask properly
  $SIG{HUP} = sub {
      print "got SIGHUP\n";
      exec($SELF, @@ARGV)        || die "$0: couldn't restart: $!";
  };

  code();

  sub code {
      print "PID: $$\n";
      print "ARGV: @@ARGV\n";
      my $count = 0;
      while (1) {
          sleep 2;
          print ++$count, "\n";
      }
  }


=head2 Deferred Signals (Safe Signals)

Before Perl 5.8.0, installing Perl code to deal with signals exposed you to
danger from two things.  First, few system library functions are
re-entrant.  If the signal interrupts while Perl is executing one function
(like malloc(3) or printf(3)), and your signal handler then calls the same
function again, you could get unpredictable behavior--often, a core dump.
Second, Perl isn't itself re-entrant at the lowest levels.  If the signal
interrupts Perl while Perl is changing its own internal data structures,
similarly unpredictable behavior may result.

There were two things you could do, knowing this: be paranoid or be
pragmatic.  The paranoid approach was to do as little as possible in your
signal handler.  Set an existing integer variable that already has a
value, and return.  This doesn't help you if you're in a slow system call,
which will just restart.  That means you have to C<die> to longjmp(3) out
of the handler.  Even this is a little cavalier for the true paranoiac,
who avoids C<die> in a handler because the system I<is> out to get you.
The pragmatic approach was to say "I know the risks, but prefer the
convenience", and to do anything you wanted in your signal handler,
and be prepared to clean up core dumps now and again.

Perl 5.8.0 and later avoid these problems by "deferring" signals.  That is,
when the signal is delivered to the process by the system (to the C code
that implements Perl) a flag is set, and the handler returns immediately.
Then at strategic "safe" points in the Perl interpreter (e.g. when it is
about to execute a new opcode) the flags are checked and the Perl level
handler from %SIG is executed. The "deferred" scheme allows much more
flexibility in the coding of signal handlers as we know the Perl
interpreter is in a safe state, and that we are not in a system library
function when the handler is called.  However the implementation does
differ from previous Perls in the following ways:

=over 4

=item Long-running opcodes

As the Perl interpreter looks at signal flags only when it is about
to execute a new opcode, a signal that arrives during a long-running
opcode (e.g. a regular expression operation on a very large string) will
not be seen until the current opcode completes.

If a signal of any given type fires multiple times during an opcode
(such as from a fine-grained timer), the handler for that signal will
be called only once, after the opcode completes; all other
instances will be discarded.  Furthermore, if your system's signal queue
gets flooded to the point that there are signals that have been raised
but not yet caught (and thus not deferred) at the time an opcode
completes, those signals may well be caught and deferred during
subsequent opcodes, with sometimes surprising results.  For example, you
may see alarms delivered even after calling C<alarm(0)> as the latter
stops the raising of alarms but does not cancel the delivery of alarms
raised but not yet caught.  Do not depend on the behaviors described in
this paragraph as they are side effects of the current implementation and
may change in future versions of Perl.

=item Interrupting IO

When a signal is delivered (e.g., SIGINT from a control-C) the operating
system breaks into IO operations like I<read>(2), which is used to
implement Perl's readline() function, the C<< <> >> operator. On older
Perls the handler was called immediately (and as C<read> is not "unsafe",
this worked well). With the "deferred" scheme the handler is I<not> called
immediately, and if Perl is using the system's C<stdio> library that
library may restart the C<read> without returning to Perl to give it a
chance to call the %SIG handler. If this happens on your system the
solution is to use the C<:perlio> layer to do IO--at least on those handles
that you want to be able to break into with signals. (The C<:perlio> layer
checks the signal flags and calls %SIG handlers before resuming IO
operation.)

The default in Perl 5.8.0 and later is to automatically use
the C<:perlio> layer.

Note that it is not advisable to access a file handle within a signal
handler where that signal has interrupted an I/O operation on that same
handle. While perl will at least try hard not to crash, there are no
guarantees of data integrity; for example, some data might get dropped or
written twice.

Some networking library functions like gethostbyname() are known to have
their own implementations of timeouts which may conflict with your
timeouts.  If you have problems with such functions, try using the POSIX
sigaction() function, which bypasses Perl safe signals.  Be warned that
this does subject you to possible memory corruption, as described above.

Instead of setting C<$SIG{ALRM}>:

   local $SIG{ALRM} = sub { die "alarm" };

try something like the following:

 use POSIX qw(SIGALRM);
 POSIX::sigaction(SIGALRM,
                  POSIX::SigAction->new(sub { die "alarm" }))
          || die "Error setting SIGALRM handler: $!\n";

Another way to disable the safe signal behavior locally is to use
the C<Perl::Unsafe::Signals> module from CPAN, which affects
all signals.

=item Restartable system calls

On systems that supported it, older versions of Perl used the
SA_RESTART flag when installing %SIG handlers.  This meant that
restartable system calls would continue rather than returning when
a signal arrived.  In order to deliver deferred signals promptly,
Perl 5.8.0 and later do I<not> use SA_RESTART.  Consequently,
restartable system calls can fail (with $! set to C<EINTR>) in places
where they previously would have succeeded.

The default C<:perlio> layer retries C<read>, C<write>
and C<close> as described above; interrupted C<wait> and
C<waitpid> calls will always be retried.

=item Signals as "faults"

Certain signals like SEGV, ILL, and BUS are generated by virtual memory
addressing errors and similar "faults". These are normally fatal: there is
little a Perl-level handler can do with them.  So Perl delivers them
immediately rather than attempting to defer them.

=item Signals triggered by operating system state

On some operating systems certain signal handlers are supposed to "do
something" before returning. One example can be CHLD or CLD, which
indicates a child process has completed. On some operating systems the
signal handler is expected to C<wait> for the completed child
process. On such systems the deferred signal scheme will not work for
those signals: it does not do the C<wait>. Again the failure will
look like a loop as the operating system will reissue the signal because
there are completed child processes that have not yet been C<wait>ed for.

=back

If you want the old signal behavior back despite possible
memory corruption, set the environment variable C<PERL_SIGNALS> to
C<"unsafe">.  This feature first appeared in Perl 5.8.1.

=head1 Named Pipes

A named pipe (often referred to as a FIFO) is an old Unix IPC
mechanism for processes communicating on the same machine.  It works
just like regular anonymous pipes, except that the
processes rendezvous using a filename and need not be related.

To create a named pipe, use the C<POSIX::mkfifo()> function.

    use POSIX qw(mkfifo);
    mkfifo($path, 0700)     ||  die "mkfifo $path failed: $!";

You can also use the Unix command mknod(1), or on some
systems, mkfifo(1).  These may not be in your normal path, though.

    # system return val is backwards, so && not ||
    #
    $ENV{PATH} .= ":/etc:/usr/etc";
    if  (      system("mknod",  $path, "p")
            && system("mkfifo", $path) )
    {
        die "mk{nod,fifo} $path failed";
    }


A fifo is convenient when you want to connect a process to an unrelated
one.  When you open a fifo, the program will block until there's something
on the other end.

For example, let's say you'd like to have your F<.signature> file be a
named pipe that has a Perl program on the other end.  Now every time any
program (like a mailer, news reader, finger program, etc.) tries to read
from that file, the reading program will read the new signature from your
program.  We'll use the pipe-checking file-test operator, B<-p>, to find
out whether anyone (or anything) has accidentally removed our fifo.

    chdir();    # go home
    my $FIFO = ".signature";

    while (1) {
        unless (-p $FIFO) {
            unlink $FIFO;   # discard any failure, will catch later
            require POSIX;  # delayed loading of heavy module
            POSIX::mkfifo($FIFO, 0700)
                                || die "can't mkfifo $FIFO: $!";
        }

        # next line blocks till there's a reader
        open (FIFO, "> $FIFO")  || die "can't open $FIFO: $!";
        print FIFO "John Smith (smith\@@host.org)\n", `fortune -s`;
        close(FIFO)             || die "can't close $FIFO: $!";
        sleep 2;                # to avoid dup signals
    }

=head1 Using open() for IPC

Perl's basic open() statement can also be used for unidirectional
interprocess communication by either appending or prepending a pipe
symbol to the second argument to open().  Here's how to start
something up in a child process you intend to write to:

    open(SPOOLER, "| cat -v | lpr -h 2>/dev/null")
                        || die "can't fork: $!";
    local $SIG{PIPE} = sub { die "spooler pipe broke" };
    print SPOOLER "stuff\n";
    close SPOOLER       || die "bad spool: $! $?";

And here's how to start up a child process you intend to read from:

    open(STATUS, "netstat -an 2>&1 |")
                        || die "can't fork: $!";
    while (<STATUS>) {
        next if /^(tcp|udp)/;
        print;
    }
    close STATUS        || die "bad netstat: $! $?";

If one can be sure that a particular program is a Perl script expecting
filenames in @@ARGV, the clever programmer can write something like this:

    % program f1 "cmd1|" - f2 "cmd2|" f3 < tmpfile

and no matter which sort of shell it's called from, the Perl program will
read from the file F<f1>, the process F<cmd1>, standard input (F<tmpfile>
in this case), the F<f2> file, the F<cmd2> command, and finally the F<f3>
file.  Pretty nifty, eh?

You might notice that you could use backticks for much the
same effect as opening a pipe for reading:

    print grep { !/^(tcp|udp)/ } `netstat -an 2>&1`;
    die "bad netstatus ($?)" if $?;

While this is true on the surface, it's much more efficient to process the
file one line or record at a time because then you don't have to read the
whole thing into memory at once.  It also gives you finer control of the
whole process, letting you kill off the child process early if you'd like.

Be careful to check the return values from both open() and close().  If
you're I<writing> to a pipe, you should also trap SIGPIPE.  Otherwise,
think of what happens when you start up a pipe to a command that doesn't
exist: the open() will in all likelihood succeed (it only reflects the
fork()'s success), but then your output will fail--spectacularly.  Perl
can't know whether the command worked, because your command is actually
running in a separate process whose exec() might have failed.  Therefore,
while readers of bogus commands return just a quick EOF, writers
to bogus commands will get hit with a signal, which they'd best be prepared
to handle.  Consider:

    open(FH, "|bogus")      || die "can't fork: $!";
    print FH "bang\n";      #  neither necessary nor sufficient
                            #  to check print retval!
    close(FH)               || die "can't close: $!";

The reason for not checking the return value from print() is because of
pipe buffering; physical writes are delayed.  That won't blow up until the
close, and it will blow up with a SIGPIPE.  To catch it, you could use
this:

    $SIG{PIPE} = "IGNORE";
    open(FH, "|bogus")  || die "can't fork: $!";
    print FH "bang\n";
    close(FH)           || die "can't close: status=$?";

=head2 Filehandles

Both the main process and any child processes it forks share the same
STDIN, STDOUT, and STDERR filehandles.  If both processes try to access
them at once, strange things can happen.  You may also want to close
or reopen the filehandles for the child.  You can get around this by
opening your pipe with open(), but on some systems this means that the
child process cannot outlive the parent.

=head2 Background Processes

You can run a command in the background with:

    system("cmd &");

The command's STDOUT and STDERR (and possibly STDIN, depending on your
shell) will be the same as the parent's.  You won't need to catch
SIGCHLD because of the double-fork taking place; see below for details.

=head2 Complete Dissociation of Child from Parent

In some cases (starting server processes, for instance) you'll want to
completely dissociate the child process from the parent.  This is
often called daemonization.  A well-behaved daemon will also chdir()
to the root directory so it doesn't prevent unmounting the filesystem
containing the directory from which it was launched, and redirect its
standard file descriptors from and to F</dev/null> so that random
output doesn't wind up on the user's terminal.

 use POSIX "setsid";

 sub daemonize {
     chdir("/")                  || die "can't chdir to /: $!";
     open(STDIN,  "< /dev/null") || die "can't read /dev/null: $!";
     open(STDOUT, "> /dev/null") || die "can't write to /dev/null: $!";
     defined(my $pid = fork())   || die "can't fork: $!";
     exit if $pid;               # non-zero now means I am the parent
     (setsid() != -1)            || die "Can't start a new session: $!";
     open(STDERR, ">&STDOUT")    || die "can't dup stdout: $!";
 }

The fork() has to come before the setsid() to ensure you aren't a
process group leader; the setsid() will fail if you are.  If your
system doesn't have the setsid() function, open F</dev/tty> and use the
C<TIOCNOTTY> ioctl() on it instead.  See tty(4) for details.

Non-Unix users should check their C<< I<Your_OS>::Process >> module for
other possible solutions.

=head2 Safe Pipe Opens

Another interesting approach to IPC is making your single program go
multiprocess and communicate between--or even amongst--yourselves.  The
open() function will accept a file argument of either C<"-|"> or C<"|-">
to do a very interesting thing: it forks a child connected to the
filehandle you've opened.  The child is running the same program as the
parent.  This is useful for safely opening a file when running under an
assumed UID or GID, for example.  If you open a pipe I<to> minus, you can
write to the filehandle you opened and your kid will find it in I<his>
STDIN.  If you open a pipe I<from> minus, you can read from the filehandle
you opened whatever your kid writes to I<his> STDOUT.

    use English;
    my $PRECIOUS = "/path/to/some/safe/file";
    my $sleep_count;
    my $pid;

    do {
        $pid = open(KID_TO_WRITE, "|-");
        unless (defined $pid) {
            warn "cannot fork: $!";
            die "bailing out" if $sleep_count++ > 6;
            sleep 10;
        }
    } until defined $pid;

    if ($pid) {                 # I am the parent
        print KID_TO_WRITE @@some_data;
        close(KID_TO_WRITE)     || warn "kid exited $?";
    } else {                    # I am the child
        # drop permissions in setuid and/or setgid programs:
        ($EUID, $EGID) = ($UID, $GID);
        open (OUTFILE, "> $PRECIOUS")
                                || die "can't open $PRECIOUS: $!";
        while (<STDIN>) {
            print OUTFILE;      # child's STDIN is parent's KID_TO_WRITE
        }
        close(OUTFILE)          || die "can't close $PRECIOUS: $!";
        exit(0);                # don't forget this!!
    }

Another common use for this construct is when you need to execute
something without the shell's interference.  With system(), it's
straightforward, but you can't use a pipe open or backticks safely.
That's because there's no way to stop the shell from getting its hands on
your arguments.   Instead, use lower-level control to call exec() directly.

Here's a safe backtick or pipe open for read:

    my $pid = open(KID_TO_READ, "-|");
    defined($pid)           || die "can't fork: $!";

    if ($pid) {             # parent
        while (<KID_TO_READ>) {
                            # do something interesting
        }
        close(KID_TO_READ)  || warn "kid exited $?";

    } else {                # child
        ($EUID, $EGID) = ($UID, $GID); # suid only
        exec($program, @@options, @@args)
                            || die "can't exec program: $!";
        # NOTREACHED
    }

And here's a safe pipe open for writing:

    my $pid = open(KID_TO_WRITE, "|-");
    defined($pid)           || die "can't fork: $!";

    $SIG{PIPE} = sub { die "whoops, $program pipe broke" };

    if ($pid) {             # parent
        print KID_TO_WRITE @@data;
        close(KID_TO_WRITE) || warn "kid exited $?";

    } else {                # child
        ($EUID, $EGID) = ($UID, $GID);
        exec($program, @@options, @@args)
                            || die "can't exec program: $!";
        # NOTREACHED
    }

It is very easy to dead-lock a process using this form of open(), or
indeed with any use of pipe() with multiple subprocesses.  The
example above is "safe" because it is simple and calls exec().  See
L</"Avoiding Pipe Deadlocks"> for general safety principles, but there
are extra gotchas with Safe Pipe Opens.

In particular, if you opened the pipe using C<open FH, "|-">, then you
cannot simply use close() in the parent process to close an unwanted
writer.  Consider this code:

    my $pid = open(WRITER, "|-");        # fork open a kid
    defined($pid)               || die "first fork failed: $!";
    if ($pid) {
        if (my $sub_pid = fork()) {
            defined($sub_pid)   || die "second fork failed: $!";
            close(WRITER)       || die "couldn't close WRITER: $!";
            # now do something else...
        }
        else {
            # first write to WRITER
            # ...
            # then when finished
            close(WRITER)       || die "couldn't close WRITER: $!";
            exit(0);
        }
    }
    else {
        # first do something with STDIN, then
        exit(0);
    }

In the example above, the true parent does not want to write to the WRITER
filehandle, so it closes it.  However, because WRITER was opened using
C<open FH, "|-">, it has a special behavior: closing it calls
waitpid() (see L<perlfunc/waitpid>), which waits for the subprocess
to exit.  If the child process ends up waiting for something happening
in the section marked "do something else", you have deadlock.

This can also be a problem with intermediate subprocesses in more
complicated code, which will call waitpid() on all open filehandles
during global destruction--in no predictable order.

To solve this, you must manually use pipe(), fork(), and the form of
open() which sets one file descriptor to another, as shown below:

    pipe(READER, WRITER)        || die "pipe failed: $!";
    $pid = fork();
    defined($pid)               || die "first fork failed: $!";
    if ($pid) {
        close READER;
        if (my $sub_pid = fork()) {
            defined($sub_pid)   || die "first fork failed: $!";
            close(WRITER)       || die "can't close WRITER: $!";
        }
        else {
            # write to WRITER...
            # ...
            # then  when finished
            close(WRITER)       || die "can't close WRITER: $!";
            exit(0);
        }
        # write to WRITER...
    }
    else {
        open(STDIN, "<&READER") || die "can't reopen STDIN: $!";
        close(WRITER)           || die "can't close WRITER: $!";
        # do something...
        exit(0);
    }

Since Perl 5.8.0, you can also use the list form of C<open> for pipes.
This is preferred when you wish to avoid having the shell interpret
metacharacters that may be in your command string.

So for example, instead of using:

    open(PS_PIPE, "ps aux|")    || die "can't open ps pipe: $!";

One would use either of these:

    open(PS_PIPE, "-|", "ps", "aux")
                                || die "can't open ps pipe: $!";

    @@ps_args = qw[ ps aux ];
    open(PS_PIPE, "-|", @@ps_args)
                                || die "can't open @@ps_args|: $!";

Because there are more than three arguments to open(), forks the ps(1)
command I<without> spawning a shell, and reads its standard output via the
C<PS_PIPE> filehandle.  The corresponding syntax to I<write> to command
pipes is to use C<"|-"> in place of C<"-|">.

This was admittedly a rather silly example, because you're using string
literals whose content is perfectly safe.  There is therefore no cause to
resort to the harder-to-read, multi-argument form of pipe open().  However,
whenever you cannot be assured that the program arguments are free of shell
metacharacters, the fancier form of open() should be used.  For example:

    @@grep_args = ("egrep", "-i", $some_pattern, @@many_files);
    open(GREP_PIPE, "-|", @@grep_args)
                        || die "can't open @@grep_args|: $!";

Here the multi-argument form of pipe open() is preferred because the
pattern and indeed even the filenames themselves might hold metacharacters.

Be aware that these operations are full Unix forks, which means they may
not be correctly implemented on all alien systems.

=head2 Avoiding Pipe Deadlocks

Whenever you have more than one subprocess, you must be careful that each
closes whichever half of any pipes created for interprocess communication
it is not using.  This is because any child process reading from the pipe
and expecting an EOF will never receive it, and therefore never exit. A
single process closing a pipe is not enough to close it; the last process
with the pipe open must close it for it to read EOF.

Certain built-in Unix features help prevent this most of the time.  For
instance, filehandles have a "close on exec" flag, which is set I<en masse>
under control of the C<$^F> variable.  This is so any filehandles you
didn't explicitly route to the STDIN, STDOUT or STDERR of a child
I<program> will be automatically closed.

Always explicitly and immediately call close() on the writable end of any
pipe, unless that process is actually writing to it.  Even if you don't
explicitly call close(), Perl will still close() all filehandles during
global destruction.  As previously discussed, if those filehandles have
been opened with Safe Pipe Open, this will result in calling waitpid(),
which may again deadlock.

=head2 Bidirectional Communication with Another Process

While this works reasonably well for unidirectional communication, what
about bidirectional communication?  The most obvious approach doesn't work:

    # THIS DOES NOT WORK!!
    open(PROG_FOR_READING_AND_WRITING, "| some program |")

If you forget to C<use warnings>, you'll miss out entirely on the
helpful diagnostic message:

    Can't do bidirectional pipe at -e line 1.

If you really want to, you can use the standard open2() from the
C<IPC::Open2> module to catch both ends.  There's also an open3() in
C<IPC::Open3> for tridirectional I/O so you can also catch your child's
STDERR, but doing so would then require an awkward select() loop and
wouldn't allow you to use normal Perl input operations.

If you look at its source, you'll see that open2() uses low-level
primitives like the pipe() and exec() syscalls to create all the
connections.  Although it might have been more efficient by using
socketpair(), this would have been even less portable than it already
is. The open2() and open3() functions are unlikely to work anywhere
except on a Unix system, or at least one purporting POSIX compliance.

=for TODO
Hold on, is this even true?  First it says that socketpair() is avoided
for portability, but then it says it probably won't work except on
Unixy systems anyway.  Which one of those is true?

Here's an example of using open2():

    use FileHandle;
    use IPC::Open2;
    $pid = open2(*Reader, *Writer, "cat -un");
    print Writer "stuff\n";
    $got = <Reader>;

The problem with this is that buffering is really going to ruin your
day.  Even though your C<Writer> filehandle is auto-flushed so the process
on the other end gets your data in a timely manner, you can't usually do
anything to force that process to give its data to you in a similarly quick
fashion.  In this special case, we could actually so, because we gave
I<cat> a B<-u> flag to make it unbuffered.  But very few commands are
designed to operate over pipes, so this seldom works unless you yourself
wrote the program on the other end of the double-ended pipe.

A solution to this is to use a library which uses pseudottys to make your
program behave more reasonably.  This way you don't have to have control
over the source code of the program you're using.  The C<Expect> module
from CPAN also addresses this kind of thing.  This module requires two
other modules from CPAN, C<IO::Pty> and C<IO::Stty>.  It sets up a pseudo
terminal to interact with programs that insist on talking to the terminal
device driver.  If your system is supported, this may be your best bet.

=head2 Bidirectional Communication with Yourself

If you want, you may make low-level pipe() and fork() syscalls to stitch
this together by hand.  This example only talks to itself, but you could
reopen the appropriate handles to STDIN and STDOUT and call other processes.
(The following example lacks proper error checking.)

 #!/usr/bin/perl -w
 # pipe1 - bidirectional communication using two pipe pairs
 #         designed for the socketpair-challenged
 use IO::Handle;             # thousands of lines just for autoflush :-(
 pipe(PARENT_RDR, CHILD_WTR);  # XXX: check failure?
 pipe(CHILD_RDR,  PARENT_WTR); # XXX: check failure?
 CHILD_WTR->autoflush(1);
 PARENT_WTR->autoflush(1);

 if ($pid = fork()) {
     close PARENT_RDR;
     close PARENT_WTR;
     print CHILD_WTR "Parent Pid $$ is sending this\n";
     chomp($line = <CHILD_RDR>);
     print "Parent Pid $$ just read this: '$line'\n";
     close CHILD_RDR; close CHILD_WTR;
     waitpid($pid, 0);
 } else {
     die "cannot fork: $!" unless defined $pid;
     close CHILD_RDR;
     close CHILD_WTR;
     chomp($line = <PARENT_RDR>);
     print "Child Pid $$ just read this: '$line'\n";
     print PARENT_WTR "Child Pid $$ is sending this\n";
     close PARENT_RDR;
     close PARENT_WTR;
     exit(0);
 }

But you don't actually have to make two pipe calls.  If you
have the socketpair() system call, it will do this all for you.

 #!/usr/bin/perl -w
 # pipe2 - bidirectional communication using socketpair
 #   "the best ones always go both ways"

 use Socket;
 use IO::Handle;  # thousands of lines just for autoflush :-(

 # We say AF_UNIX because although *_LOCAL is the
 # POSIX 1003.1g form of the constant, many machines
 # still don't have it.
 socketpair(CHILD, PARENT, AF_UNIX, SOCK_STREAM, PF_UNSPEC)
                             ||  die "socketpair: $!";

 CHILD->autoflush(1);
 PARENT->autoflush(1);

 if ($pid = fork()) {
     close PARENT;
     print CHILD "Parent Pid $$ is sending this\n";
     chomp($line = <CHILD>);
     print "Parent Pid $$ just read this: '$line'\n";
     close CHILD;
     waitpid($pid, 0);
 } else {
     die "cannot fork: $!" unless defined $pid;
     close CHILD;
     chomp($line = <PARENT>);
     print "Child Pid $$ just read this: '$line'\n";
     print PARENT "Child Pid $$ is sending this\n";
     close PARENT;
     exit(0);
 }

=head1 Sockets: Client/Server Communication

While not entirely limited to Unix-derived operating systems (e.g., WinSock
on PCs provides socket support, as do some VMS libraries), you might not have
sockets on your system, in which case this section probably isn't going to
do you much good.  With sockets, you can do both virtual circuits like TCP
streams and datagrams like UDP packets.  You may be able to do even more
depending on your system.

The Perl functions for dealing with sockets have the same names as
the corresponding system calls in C, but their arguments tend to differ
for two reasons.  First, Perl filehandles work differently than C file
descriptors.  Second, Perl already knows the length of its strings, so you
don't need to pass that information.

One of the major problems with ancient, antemillennial socket code in Perl
was that it used hard-coded values for some of the constants, which
severely hurt portability.  If you ever see code that does anything like
explicitly setting C<$AF_INET = 2>, you know you're in for big trouble.
An immeasurably superior approach is to use the C<Socket> module, which more
reliably grants access to the various constants and functions you'll need.

If you're not writing a server/client for an existing protocol like
NNTP or SMTP, you should give some thought to how your server will
know when the client has finished talking, and vice-versa.  Most
protocols are based on one-line messages and responses (so one party
knows the other has finished when a "\n" is received) or multi-line
messages and responses that end with a period on an empty line
("\n.\n" terminates a message/response).

=head2 Internet Line Terminators

The Internet line terminator is "\015\012".  Under ASCII variants of
Unix, that could usually be written as "\r\n", but under other systems,
"\r\n" might at times be "\015\015\012", "\012\012\015", or something
completely different.  The standards specify writing "\015\012" to be
conformant (be strict in what you provide), but they also recommend
accepting a lone "\012" on input (be lenient in what you require).
We haven't always been very good about that in the code in this manpage,
but unless you're on a Mac from way back in its pre-Unix dark ages, you'll
probably be ok.

=head2 Internet TCP Clients and Servers

Use Internet-domain sockets when you want to do client-server
communication that might extend to machines outside of your own system.

Here's a sample TCP client using Internet-domain sockets:

    #!/usr/bin/perl -w
    use strict;
    use Socket;
    my ($remote, $port, $iaddr, $paddr, $proto, $line);

    $remote  = shift || "localhost";
    $port    = shift || 2345;  # random port
    if ($port =~ /\D/) { $port = getservbyname($port, "tcp") }
    die "No port" unless $port;
    $iaddr   = inet_aton($remote)       || die "no host: $remote";
    $paddr   = sockaddr_in($port, $iaddr);

    $proto   = getprotobyname("tcp");
    socket(SOCK, PF_INET, SOCK_STREAM, $proto)  || die "socket: $!";
    connect(SOCK, $paddr)               || die "connect: $!";
    while ($line = <SOCK>) {
        print $line;
    }

    close (SOCK)                        || die "close: $!";
    exit(0);

And here's a corresponding server to go along with it.  We'll
leave the address as C<INADDR_ANY> so that the kernel can choose
the appropriate interface on multihomed hosts.  If you want sit
on a particular interface (like the external side of a gateway
or firewall machine), fill this in with your real address instead.

 #!/usr/bin/perl -Tw
 use strict;
 BEGIN { $ENV{PATH} = "/usr/bin:/bin" }
 use Socket;
 use Carp;
 my $EOL = "\015\012";

 sub logmsg { print "$0 $$: @@_ at ", scalar localtime(), "\n" }

 my $port  = shift || 2345;
 die "invalid port" unless $port =~ /^ \d+ $/x;

 my $proto = getprotobyname("tcp");

 socket(Server, PF_INET, SOCK_STREAM, $proto)   || die "socket: $!";
 setsockopt(Server, SOL_SOCKET, SO_REUSEADDR, pack("l", 1))
                                                || die "setsockopt: $!";
 bind(Server, sockaddr_in($port, INADDR_ANY))   || die "bind: $!";
 listen(Server, SOMAXCONN)                      || die "listen: $!";

 logmsg "server started on port $port";

 my $paddr;

 for ( ; $paddr = accept(Client, Server); close Client) {
     my($port, $iaddr) = sockaddr_in($paddr);
     my $name = gethostbyaddr($iaddr, AF_INET);

     logmsg "connection from $name [",
             inet_ntoa($iaddr), "]
             at port $port";

     print Client "Hello there, $name, it's now ",
                     scalar localtime(), $EOL;
 }

And here's a multitasking version.  It's multitasked in that
like most typical servers, it spawns (fork()s) a slave server to
handle the client request so that the master server can quickly
go back to service a new client.

 #!/usr/bin/perl -Tw
 use strict;
 BEGIN { $ENV{PATH} = "/usr/bin:/bin" }
 use Socket;
 use Carp;
 my $EOL = "\015\012";

 sub spawn;  # forward declaration
 sub logmsg { print "$0 $$: @@_ at ", scalar localtime(), "\n" }

 my $port  = shift || 2345;
 die "invalid port" unless $port =~ /^ \d+ $/x;

 my $proto = getprotobyname("tcp");

 socket(Server, PF_INET, SOCK_STREAM, $proto)   || die "socket: $!";
 setsockopt(Server, SOL_SOCKET, SO_REUSEADDR, pack("l", 1))
                                                || die "setsockopt: $!";
 bind(Server, sockaddr_in($port, INADDR_ANY))   || die "bind: $!";
 listen(Server, SOMAXCONN)                      || die "listen: $!";

 logmsg "server started on port $port";

 my $waitedpid = 0;
 my $paddr;

 use POSIX ":sys_wait_h";
 use Errno;

 sub REAPER {
     local $!;   # don't let waitpid() overwrite current error
     while ((my $pid = waitpid(-1, WNOHANG)) > 0 && WIFEXITED($?)) {
         logmsg "reaped $waitedpid" . ($? ? " with exit $?" : "");
     }
     $SIG{CHLD} = \&REAPER;  # loathe SysV
 }

 $SIG{CHLD} = \&REAPER;

 while (1) {
     $paddr = accept(Client, Server) || do {
         # try again if accept() returned because got a signal
         next if $!{EINTR};
         die "accept: $!";
     };
     my ($port, $iaddr) = sockaddr_in($paddr);
     my $name = gethostbyaddr($iaddr, AF_INET);

     logmsg "connection from $name [",
            inet_ntoa($iaddr),
            "] at port $port";

     spawn sub {
         $| = 1;
         print "Hello there, $name, it's now ",
               scalar localtime(),
               $EOL;
         exec "/usr/games/fortune"       # XXX: "wrong" line terminators
             or confess "can't exec fortune: $!";
     };
     close Client;
 }

 sub spawn {
     my $coderef = shift;

     unless (@@_ == 0 && $coderef && ref($coderef) eq "CODE") {
         confess "usage: spawn CODEREF";
     }

     my $pid;
     unless (defined($pid = fork())) {
         logmsg "cannot fork: $!";
         return;
     }
     elsif ($pid) {
         logmsg "begat $pid";
         return; # I'm the parent
     }
     # else I'm the child -- go spawn

     open(STDIN,  "<&Client")    || die "can't dup client to stdin";
     open(STDOUT, ">&Client")    || die "can't dup client to stdout";
     ## open(STDERR, ">&STDOUT") || die "can't dup stdout to stderr";
     exit($coderef->());
 }

This server takes the trouble to clone off a child version via fork()
for each incoming request.  That way it can handle many requests at
once, which you might not always want.  Even if you don't fork(), the
listen() will allow that many pending connections.  Forking servers
have to be particularly careful about cleaning up their dead children
(called "zombies" in Unix parlance), because otherwise you'll quickly
fill up your process table.  The REAPER subroutine is used here to
call waitpid() for any child processes that have finished, thereby
ensuring that they terminate cleanly and don't join the ranks of the
living dead.

Within the while loop we call accept() and check to see if it returns
a false value.  This would normally indicate a system error needs
to be reported.  However, the introduction of safe signals (see
L</Deferred Signals (Safe Signals)> above) in Perl 5.8.0 means that
accept() might also be interrupted when the process receives a signal.
This typically happens when one of the forked subprocesses exits and
notifies the parent process with a CHLD signal.

If accept() is interrupted by a signal, $! will be set to EINTR.
If this happens, we can safely continue to the next iteration of
the loop and another call to accept().  It is important that your
signal handling code not modify the value of $!, or else this test
will likely fail.  In the REAPER subroutine we create a local version
of $! before calling waitpid().  When waitpid() sets $! to ECHILD as
it inevitably does when it has no more children waiting, it
updates the local copy and leaves the original unchanged.

You should use the B<-T> flag to enable taint checking (see L<perlsec>)
even if we aren't running setuid or setgid.  This is always a good idea
for servers or any program run on behalf of someone else (like CGI
scripts), because it lessens the chances that people from the outside will
be able to compromise your system.

Let's look at another TCP client.  This one connects to the TCP "time"
service on a number of different machines and shows how far their clocks
differ from the system on which it's being run:

    #!/usr/bin/perl  -w
    use strict;
    use Socket;

    my $SECS_OF_70_YEARS = 2208988800;
    sub ctime { scalar localtime(shift() || time()) }

    my $iaddr = gethostbyname("localhost");
    my $proto = getprotobyname("tcp");
    my $port = getservbyname("time", "tcp");
    my $paddr = sockaddr_in(0, $iaddr);
    my($host);

    $| = 1;
    printf "%-24s %8s %s\n", "localhost", 0, ctime();

    foreach $host (@@ARGV) {
        printf "%-24s ", $host;
        my $hisiaddr = inet_aton($host)     || die "unknown host";
        my $hispaddr = sockaddr_in($port, $hisiaddr);
        socket(SOCKET, PF_INET, SOCK_STREAM, $proto)
                                            || die "socket: $!";
        connect(SOCKET, $hispaddr)          || die "connect: $!";
        my $rtime = pack("C4", ());
        read(SOCKET, $rtime, 4);
        close(SOCKET);
        my $histime = unpack("N", $rtime) - $SECS_OF_70_YEARS;
        printf "%8d %s\n", $histime - time(), ctime($histime);
    }

=head2 Unix-Domain TCP Clients and Servers

That's fine for Internet-domain clients and servers, but what about local
communications?  While you can use the same setup, sometimes you don't
want to.  Unix-domain sockets are local to the current host, and are often
used internally to implement pipes.  Unlike Internet domain sockets, Unix
domain sockets can show up in the file system with an ls(1) listing.

    % ls -l /dev/log
    srw-rw-rw-  1 root            0 Oct 31 07:23 /dev/log

You can test for these with Perl's B<-S> file test:

    unless (-S "/dev/log") {
        die "something's wicked with the log system";
    }

Here's a sample Unix-domain client:

    #!/usr/bin/perl -w
    use Socket;
    use strict;
    my ($rendezvous, $line);

    $rendezvous = shift || "catsock";
    socket(SOCK, PF_UNIX, SOCK_STREAM, 0)     || die "socket: $!";
    connect(SOCK, sockaddr_un($rendezvous))   || die "connect: $!";
    while (defined($line = <SOCK>)) {
        print $line;
    }
    exit(0);

And here's a corresponding server.  You don't have to worry about silly
network terminators here because Unix domain sockets are guaranteed
to be on the localhost, and thus everything works right.

    #!/usr/bin/perl -Tw
    use strict;
    use Socket;
    use Carp;

    BEGIN { $ENV{PATH} = "/usr/bin:/bin" }
    sub spawn;  # forward declaration
    sub logmsg { print "$0 $$: @@_ at ", scalar localtime(), "\n" }

    my $NAME = "catsock";
    my $uaddr = sockaddr_un($NAME);
    my $proto = getprotobyname("tcp");

    socket(Server, PF_UNIX, SOCK_STREAM, 0) || die "socket: $!";
    unlink($NAME);
    bind  (Server, $uaddr)                  || die "bind: $!";
    listen(Server, SOMAXCONN)               || die "listen: $!";

    logmsg "server started on $NAME";

    my $waitedpid;

    use POSIX ":sys_wait_h";
    sub REAPER {
        my $child;
        while (($waitedpid = waitpid(-1, WNOHANG)) > 0) {
            logmsg "reaped $waitedpid" . ($? ? " with exit $?" : "");
        }
        $SIG{CHLD} = \&REAPER;  # loathe SysV
    }

    $SIG{CHLD} = \&REAPER;


    for ( $waitedpid = 0;
          accept(Client, Server) || $waitedpid;
          $waitedpid = 0, close Client)
    {
        next if $waitedpid;
        logmsg "connection on $NAME";
        spawn sub {
            print "Hello there, it's now ", scalar localtime(), "\n";
            exec("/usr/games/fortune")  || die "can't exec fortune: $!";
        };
    }

    sub spawn {
        my $coderef = shift();

        unless (@@_ == 0 && $coderef && ref($coderef) eq "CODE") {
            confess "usage: spawn CODEREF";
        }

        my $pid;
        unless (defined($pid = fork())) {
            logmsg "cannot fork: $!";
            return;
        }
        elsif ($pid) {
            logmsg "begat $pid";
            return; # I'm the parent
        }
        else {
            # I'm the child -- go spawn
        }

        open(STDIN,  "<&Client")    || die "can't dup client to stdin";
        open(STDOUT, ">&Client")    || die "can't dup client to stdout";
        ## open(STDERR, ">&STDOUT") || die "can't dup stdout to stderr";
        exit($coderef->());
    }

As you see, it's remarkably similar to the Internet domain TCP server, so
much so, in fact, that we've omitted several duplicate functions--spawn(),
logmsg(), ctime(), and REAPER()--which are the same as in the other server.

So why would you ever want to use a Unix domain socket instead of a
simpler named pipe?  Because a named pipe doesn't give you sessions.  You
can't tell one process's data from another's.  With socket programming,
you get a separate session for each client; that's why accept() takes two
arguments.

For example, let's say that you have a long-running database server daemon
that you want folks to be able to access from the Web, but only
if they go through a CGI interface.  You'd have a small, simple CGI
program that does whatever checks and logging you feel like, and then acts
as a Unix-domain client and connects to your private server.

=head1 TCP Clients with IO::Socket

For those preferring a higher-level interface to socket programming, the
IO::Socket module provides an object-oriented approach.  If for some reason
you lack this module, you can just fetch IO::Socket from CPAN, where you'll also
find modules providing easy interfaces to the following systems: DNS, FTP,
Ident (RFC 931), NIS and NISPlus, NNTP, Ping, POP3, SMTP, SNMP, SSLeay,
Telnet, and Time--to name just a few.

=head2 A Simple Client

Here's a client that creates a TCP connection to the "daytime"
service at port 13 of the host name "localhost" and prints out everything
that the server there cares to provide.

    #!/usr/bin/perl -w
    use IO::Socket;
    $remote = IO::Socket::INET->new(
                        Proto    => "tcp",
                        PeerAddr => "localhost",
                        PeerPort => "daytime(13)",
                    )
                 || die "can't connect to daytime service on localhost";
    while (<$remote>) { print }

When you run this program, you should get something back that
looks like this:

    Wed May 14 08:40:46 MDT 1997

Here are what those parameters to the new() constructor mean:

=over 4

=item C<Proto>

This is which protocol to use.  In this case, the socket handle returned
will be connected to a TCP socket, because we want a stream-oriented
connection, that is, one that acts pretty much like a plain old file.
Not all sockets are this of this type.  For example, the UDP protocol
can be used to make a datagram socket, used for message-passing.

=item C<PeerAddr>

This is the name or Internet address of the remote host the server is
running on.  We could have specified a longer name like C<"www.perl.com">,
or an address like C<"207.171.7.72">.  For demonstration purposes, we've
used the special hostname C<"localhost">, which should always mean the
current machine you're running on.  The corresponding Internet address
for localhost is C<"127.0.0.1">, if you'd rather use that.

=item C<PeerPort>

This is the service name or port number we'd like to connect to.
We could have gotten away with using just C<"daytime"> on systems with a
well-configured system services file,[FOOTNOTE: The system services file
is found in I</etc/services> under Unixy systems.] but here we've specified the
port number (13) in parentheses.  Using just the number would have also
worked, but numeric literals make careful programmers nervous.

=back

Notice how the return value from the C<new> constructor is used as
a filehandle in the C<while> loop?  That's what's called an I<indirect
filehandle>, a scalar variable containing a filehandle.  You can use
it the same way you would a normal filehandle.  For example, you
can read one line from it this way:

    $line = <$handle>;

all remaining lines from is this way:

    @@lines = <$handle>;

and send a line of data to it this way:

    print $handle "some data\n";

=head2 A Webget Client

Here's a simple client that takes a remote host to fetch a document
from, and then a list of files to get from that host.  This is a
more interesting client than the previous one because it first sends
something to the server before fetching the server's response.

    #!/usr/bin/perl -w
    use IO::Socket;
    unless (@@ARGV > 1) { die "usage: $0 host url ..." }
    $host = shift(@@ARGV);
    $EOL = "\015\012";
    $BLANK = $EOL x 2;
    for my $document (@@ARGV) {
        $remote = IO::Socket::INET->new( Proto     => "tcp",
                                         PeerAddr  => $host,
                                         PeerPort  => "http(80)",
                  )     || die "cannot connect to httpd on $host";
        $remote->autoflush(1);
        print $remote "GET $document HTTP/1.0" . $BLANK;
        while ( <$remote> ) { print }
        close $remote;
    }

The web server handling the HTTP service is assumed to be at
its standard port, number 80.  If the server you're trying to
connect to is at a different port, like 1080 or 8080, you should specify it
as the named-parameter pair, C<< PeerPort => 8080 >>.  The C<autoflush>
method is used on the socket because otherwise the system would buffer
up the output we sent it.  (If you're on a prehistoric Mac, you'll also
need to change every C<"\n"> in your code that sends data over the network
to be a C<"\015\012"> instead.)

Connecting to the server is only the first part of the process: once you
have the connection, you have to use the server's language.  Each server
on the network has its own little command language that it expects as
input.  The string that we send to the server starting with "GET" is in
HTTP syntax.  In this case, we simply request each specified document.
Yes, we really are making a new connection for each document, even though
it's the same host.  That's the way you always used to have to speak HTTP.
Recent versions of web browsers may request that the remote server leave
the connection open a little while, but the server doesn't have to honor
such a request.

Here's an example of running that program, which we'll call I<webget>:

    % webget www.perl.com /guanaco.html
    HTTP/1.1 404 File Not Found
    Date: Thu, 08 May 1997 18:02:32 GMT
    Server: Apache/1.2b6
    Connection: close
    Content-type: text/html

    <HEAD><TITLE>404 File Not Found</TITLE></HEAD>
    <BODY><H1>File Not Found</H1>
    The requested URL /guanaco.html was not found on this server.<P>
    </BODY>

Ok, so that's not very interesting, because it didn't find that
particular document.  But a long response wouldn't have fit on this page.

For a more featureful version of this program, you should look to
the I<lwp-request> program included with the LWP modules from CPAN.

=head2 Interactive Client with IO::Socket

Well, that's all fine if you want to send one command and get one answer,
but what about setting up something fully interactive, somewhat like
the way I<telnet> works?  That way you can type a line, get the answer,
type a line, get the answer, etc.

This client is more complicated than the two we've done so far, but if
you're on a system that supports the powerful C<fork> call, the solution
isn't that rough.  Once you've made the connection to whatever service
you'd like to chat with, call C<fork> to clone your process.  Each of
these two identical process has a very simple job to do: the parent
copies everything from the socket to standard output, while the child
simultaneously copies everything from standard input to the socket.
To accomplish the same thing using just one process would be I<much>
harder, because it's easier to code two processes to do one thing than it
is to code one process to do two things.  (This keep-it-simple principle
a cornerstones of the Unix philosophy, and good software engineering as
well, which is probably why it's spread to other systems.)

Here's the code:

    #!/usr/bin/perl -w
    use strict;
    use IO::Socket;
    my ($host, $port, $kidpid, $handle, $line);

    unless (@@ARGV == 2) { die "usage: $0 host port" }
    ($host, $port) = @@ARGV;

    # create a tcp connection to the specified host and port
    $handle = IO::Socket::INET->new(Proto     => "tcp",
                                    PeerAddr  => $host,
                                    PeerPort  => $port)
               || die "can't connect to port $port on $host: $!";

    $handle->autoflush(1);       # so output gets there right away
    print STDERR "[Connected to $host:$port]\n";

    # split the program into two processes, identical twins
    die "can't fork: $!" unless defined($kidpid = fork());

    # the if{} block runs only in the parent process
    if ($kidpid) {
        # copy the socket to standard output
        while (defined ($line = <$handle>)) {
            print STDOUT $line;
        }
        kill("TERM", $kidpid);   # send SIGTERM to child
    }
    # the else{} block runs only in the child process
    else {
        # copy standard input to the socket
        while (defined ($line = <STDIN>)) {
            print $handle $line;
        }
        exit(0);                # just in case
    }

The C<kill> function in the parent's C<if> block is there to send a
signal to our child process, currently running in the C<else> block,
as soon as the remote server has closed its end of the connection.

If the remote server sends data a byte at time, and you need that
data immediately without waiting for a newline (which might not happen),
you may wish to replace the C<while> loop in the parent with the
following:

    my $byte;
    while (sysread($handle, $byte, 1) == 1) {
        print STDOUT $byte;
    }

Making a system call for each byte you want to read is not very efficient
(to put it mildly) but is the simplest to explain and works reasonably
well.

=head1 TCP Servers with IO::Socket

As always, setting up a server is little bit more involved than running a client.
The model is that the server creates a special kind of socket that
does nothing but listen on a particular port for incoming connections.
It does this by calling the C<< IO::Socket::INET->new() >> method with
slightly different arguments than the client did.

=over 4

=item Proto

This is which protocol to use.  Like our clients, we'll
still specify C<"tcp"> here.

=item LocalPort

We specify a local
port in the C<LocalPort> argument, which we didn't do for the client.
This is service name or port number for which you want to be the
server. (Under Unix, ports under 1024 are restricted to the
superuser.)  In our sample, we'll use port 9000, but you can use
any port that's not currently in use on your system.  If you try
to use one already in used, you'll get an "Address already in use"
message.  Under Unix, the C<netstat -a> command will show
which services current have servers.

=item Listen

The C<Listen> parameter is set to the maximum number of
pending connections we can accept until we turn away incoming clients.
Think of it as a call-waiting queue for your telephone.
The low-level Socket module has a special symbol for the system maximum, which
is SOMAXCONN.

=item Reuse

The C<Reuse> parameter is needed so that we restart our server
manually without waiting a few minutes to allow system buffers to
clear out.

=back

Once the generic server socket has been created using the parameters
listed above, the server then waits for a new client to connect
to it.  The server blocks in the C<accept> method, which eventually accepts a
bidirectional connection from the remote client.  (Make sure to autoflush
this handle to circumvent buffering.)

To add to user-friendliness, our server prompts the user for commands.
Most servers don't do this.  Because of the prompt without a newline,
you'll have to use the C<sysread> variant of the interactive client above.

This server accepts one of five different commands, sending output back to
the client.  Unlike most network servers, this one handles only one
incoming client at a time.  Multitasking servers are covered in
Chapter 16 of the Camel.

Here's the code.  We'll

 #!/usr/bin/perl -w
 use IO::Socket;
 use Net::hostent;      # for OOish version of gethostbyaddr

 $PORT = 9000;          # pick something not in use

 $server = IO::Socket::INET->new( Proto     => "tcp",
                                  LocalPort => $PORT,
                                  Listen    => SOMAXCONN,
                                  Reuse     => 1);

 die "can't setup server" unless $server;
 print "[Server $0 accepting clients]\n";

 while ($client = $server->accept()) {
   $client->autoflush(1);
   print $client "Welcome to $0; type help for command list.\n";
   $hostinfo = gethostbyaddr($client->peeraddr);
   printf "[Connect from %s]\n",
          $hostinfo ? $hostinfo->name : $client->peerhost;
   print $client "Command? ";
   while ( <$client>) {
     next unless /\S/;     # blank line
     if    (/quit|exit/i)  { last                                      }
     elsif (/date|time/i)  { printf $client "%s\n", scalar localtime() }
     elsif (/who/i )       { print  $client `who 2>&1`                 }
     elsif (/cookie/i )    { print  $client `/usr/games/fortune 2>&1`  }
     elsif (/motd/i )      { print  $client `cat /etc/motd 2>&1`       }
     else {
       print $client "Commands: quit date who cookie motd\n";
     }
   } continue {
      print $client "Command? ";
   }
   close $client;
 }

=head1 UDP: Message Passing

Another kind of client-server setup is one that uses not connections, but
messages.  UDP communications involve much lower overhead but also provide
less reliability, as there are no promises that messages will arrive at
all, let alone in order and unmangled.  Still, UDP offers some advantages
over TCP, including being able to "broadcast" or "multicast" to a whole
bunch of destination hosts at once (usually on your local subnet).  If you
find yourself overly concerned about reliability and start building checks
into your message system, then you probably should use just TCP to start
with.

UDP datagrams are I<not> a bytestream and should not be treated as such.
This makes using I/O mechanisms with internal buffering like stdio (i.e.
print() and friends) especially cumbersome. Use syswrite(), or better
send(), like in the example below.

Here's a UDP program similar to the sample Internet TCP client given
earlier.  However, instead of checking one host at a time, the UDP version
will check many of them asynchronously by simulating a multicast and then
using select() to do a timed-out wait for I/O.  To do something similar
with TCP, you'd have to use a different socket handle for each host.

 #!/usr/bin/perl -w
 use strict;
 use Socket;
 use Sys::Hostname;

 my ( $count, $hisiaddr, $hispaddr, $histime,
      $host, $iaddr, $paddr, $port, $proto,
      $rin, $rout, $rtime, $SECS_OF_70_YEARS);

 $SECS_OF_70_YEARS = 2_208_988_800;

 $iaddr = gethostbyname(hostname());
 $proto = getprotobyname("udp");
 $port = getservbyname("time", "udp");
 $paddr = sockaddr_in(0, $iaddr); # 0 means let kernel pick

 socket(SOCKET, PF_INET, SOCK_DGRAM, $proto)   || die "socket: $!";
 bind(SOCKET, $paddr)                          || die "bind: $!";

 $| = 1;
 printf "%-12s %8s %s\n",  "localhost", 0, scalar localtime();
 $count = 0;
 for $host (@@ARGV) {
     $count++;
     $hisiaddr = inet_aton($host)              || die "unknown host";
     $hispaddr = sockaddr_in($port, $hisiaddr);
     defined(send(SOCKET, 0, 0, $hispaddr))    || die "send $host: $!";
 }

 $rin = "";
 vec($rin, fileno(SOCKET), 1) = 1;

 # timeout after 10.0 seconds
 while ($count && select($rout = $rin, undef, undef, 10.0)) {
     $rtime = "";
     $hispaddr = recv(SOCKET, $rtime, 4, 0)    || die "recv: $!";
     ($port, $hisiaddr) = sockaddr_in($hispaddr);
     $host = gethostbyaddr($hisiaddr, AF_INET);
     $histime = unpack("N", $rtime) - $SECS_OF_70_YEARS;
     printf "%-12s ", $host;
     printf "%8d %s\n", $histime - time(), scalar localtime($histime);
     $count--;
 }

This example does not include any retries and may consequently fail to
contact a reachable host. The most prominent reason for this is congestion
of the queues on the sending host if the number of hosts to contact is
sufficiently large.

=head1 SysV IPC

While System V IPC isn't so widely used as sockets, it still has some
interesting uses.  However, you cannot use SysV IPC or Berkeley mmap() to
have a variable shared amongst several processes.  That's because Perl
would reallocate your string when you weren't wanting it to.  You might
look into the C<IPC::Shareable> or C<threads::shared> modules for that.

Here's a small example showing shared memory usage.

    use IPC::SysV qw(IPC_PRIVATE IPC_RMID S_IRUSR S_IWUSR);

    $size = 2000;
    $id = shmget(IPC_PRIVATE, $size, S_IRUSR | S_IWUSR);
    defined($id)                    || die "shmget: $!";
    print "shm key $id\n";

    $message = "Message #1";
    shmwrite($id, $message, 0, 60)  || die "shmwrite: $!";
    print "wrote: '$message'\n";
    shmread($id, $buff, 0, 60)      || die "shmread: $!";
    print "read : '$buff'\n";

    # the buffer of shmread is zero-character end-padded.
    substr($buff, index($buff, "\0")) = "";
    print "un" unless $buff eq $message;
    print "swell\n";

    print "deleting shm $id\n";
    shmctl($id, IPC_RMID, 0)        || die "shmctl: $!";

Here's an example of a semaphore:

    use IPC::SysV qw(IPC_CREAT);

    $IPC_KEY = 1234;
    $id = semget($IPC_KEY, 10, 0666 | IPC_CREAT);
    defined($id)                    || die "semget: $!";
    print "sem id $id\n";

Put this code in a separate file to be run in more than one process.
Call the file F<take>:

    # create a semaphore

    $IPC_KEY = 1234;
    $id = semget($IPC_KEY, 0, 0);
    defined($id)                    || die "semget: $!";

    $semnum  = 0;
    $semflag = 0;

    # "take" semaphore
    # wait for semaphore to be zero
    $semop = 0;
    $opstring1 = pack("s!s!s!", $semnum, $semop, $semflag);

    # Increment the semaphore count
    $semop = 1;
    $opstring2 = pack("s!s!s!", $semnum, $semop,  $semflag);
    $opstring  = $opstring1 . $opstring2;

    semop($id, $opstring)   || die "semop: $!";

Put this code in a separate file to be run in more than one process.
Call this file F<give>:

    # "give" the semaphore
    # run this in the original process and you will see
    # that the second process continues

    $IPC_KEY = 1234;
    $id = semget($IPC_KEY, 0, 0);
    die unless defined($id);

    $semnum  = 0;
    $semflag = 0;

    # Decrement the semaphore count
    $semop = -1;
    $opstring = pack("s!s!s!", $semnum, $semop, $semflag);

    semop($id, $opstring)   || die "semop: $!";

The SysV IPC code above was written long ago, and it's definitely
clunky looking.  For a more modern look, see the IPC::SysV module.

A small example demonstrating SysV message queues:

    use IPC::SysV qw(IPC_PRIVATE IPC_RMID IPC_CREAT S_IRUSR S_IWUSR);

    my $id = msgget(IPC_PRIVATE, IPC_CREAT | S_IRUSR | S_IWUSR);
    defined($id)                || die "msgget failed: $!";

    my $sent      = "message";
    my $type_sent = 1234;

    msgsnd($id, pack("l! a*", $type_sent, $sent), 0)
                                || die "msgsnd failed: $!";

    msgrcv($id, my $rcvd_buf, 60, 0, 0)
                                || die "msgrcv failed: $!";

    my($type_rcvd, $rcvd) = unpack("l! a*", $rcvd_buf);

    if ($rcvd eq $sent) {
        print "okay\n";
    } else {
        print "not okay\n";
    }

    msgctl($id, IPC_RMID, 0)    || die "msgctl failed: $!\n";

=head1 NOTES

Most of these routines quietly but politely return C<undef> when they
fail instead of causing your program to die right then and there due to
an uncaught exception.  (Actually, some of the new I<Socket> conversion
functions do croak() on bad arguments.)  It is therefore essential to
check return values from these functions.  Always begin your socket
programs this way for optimal success, and don't forget to add the B<-T>
taint-checking flag to the C<#!> line for servers:

    #!/usr/bin/perl -Tw
    use strict;
    use sigtrap;
    use Socket;

=head1 BUGS

These routines all create system-specific portability problems.  As noted
elsewhere, Perl is at the mercy of your C libraries for much of its system
behavior.  It's probably safest to assume broken SysV semantics for
signals and to stick with simple TCP and UDP socket operations; e.g., don't
try to pass open file descriptors over a local UDP datagram socket if you
want your code to stand a chance of being portable.

=head1 AUTHOR

Tom Christiansen, with occasional vestiges of Larry Wall's original
version and suggestions from the Perl Porters.

=head1 SEE ALSO

There's a lot more to networking than this, but this should get you
started.

For intrepid programmers, the indispensable textbook is I<Unix Network
Programming, 2nd Edition, Volume 1> by W. Richard Stevens (published by
Prentice-Hall).  Most books on networking address the subject from the
perspective of a C programmer; translation to Perl is left as an exercise
for the reader.

The IO::Socket(3) manpage describes the object library, and the Socket(3)
manpage describes the low-level interface to sockets.  Besides the obvious
functions in L<perlfunc>, you should also check out the F<modules> file at
your nearest CPAN site, especially
L<http://www.cpan.org/modules/00modlist.long.html#ID5_Networking_>.
See L<perlmodlib> or best yet, the F<Perl FAQ> for a description
of what CPAN is and where to get it if the previous link doesn't work
for you.

Section 5 of CPAN's F<modules> file is devoted to "Networking, Device
Control (modems), and Interprocess Communication", and contains numerous
unbundled modules numerous networking modules, Chat and Expect operations,
CGI programming, DCE, FTP, IPC, NNTP, Proxy, Ptty, RPC, SNMP, SMTP, Telnet,
Threads, and ToolTalk--to name just a few.
@


1.17
log
@Fix merge issues, remove excess files - match perl-5.20.2 dist
@
text
@d171 3
a173 3
module.  Lamentably, this is almost entirely undocumented, but
the F<t/lib/posix.t> file from the Perl source distribution has some
examples in it.
d319 3
a321 2
  use POSIX qw(SIGALRM);
  POSIX::sigaction(SIGALRM, POSIX::SigAction->new(sub { die "alarm" }))
d519 1
a519 1
    use POSIX "setsid";
d521 9
a529 9
    sub daemonize {
        chdir("/")                      || die "can't chdir to /: $!";
        open(STDIN,  "< /dev/null")     || die "can't read /dev/null: $!";
        open(STDOUT, "> /dev/null")     || die "can't write to /dev/null: $!";
        defined(my $pid = fork())       || die "can't fork: $!";
        exit if $pid;                   # non-zero now means I am the parent
        (setsid() != -1)                || die "Can't start a new session: $!";
        open(STDERR, ">&STDOUT")        || die "can't dup stdout: $!";
    }
d816 28
a843 28
    #!/usr/bin/perl -w
    # pipe1 - bidirectional communication using two pipe pairs
    #         designed for the socketpair-challenged
    use IO::Handle;               # thousands of lines just for autoflush :-(
    pipe(PARENT_RDR, CHILD_WTR);  # XXX: check failure?
    pipe(CHILD_RDR,  PARENT_WTR); # XXX: check failure?
    CHILD_WTR->autoflush(1);
    PARENT_WTR->autoflush(1);

    if ($pid = fork()) {
        close PARENT_RDR;
        close PARENT_WTR;
        print CHILD_WTR "Parent Pid $$ is sending this\n";
        chomp($line = <CHILD_RDR>);
        print "Parent Pid $$ just read this: '$line'\n";
        close CHILD_RDR; close CHILD_WTR;
        waitpid($pid, 0);
    } else {
        die "cannot fork: $!" unless defined $pid;
        close CHILD_RDR;
        close CHILD_WTR;
        chomp($line = <PARENT_RDR>);
        print "Child Pid $$ just read this: '$line'\n";
        print PARENT_WTR "Child Pid $$ is sending this\n";
        close PARENT_RDR;
        close PARENT_WTR;
        exit(0);
    }
d848 3
a850 3
    #!/usr/bin/perl -w
    # pipe2 - bidirectional communication using socketpair
    #   "the best ones always go both ways"
d852 2
a853 2
    use Socket;
    use IO::Handle;  # thousands of lines just for autoflush :-(
d855 25
a879 25
    # We say AF_UNIX because although *_LOCAL is the
    # POSIX 1003.1g form of the constant, many machines
    # still don't have it.
    socketpair(CHILD, PARENT, AF_UNIX, SOCK_STREAM, PF_UNSPEC)
                                ||  die "socketpair: $!";

    CHILD->autoflush(1);
    PARENT->autoflush(1);

    if ($pid = fork()) {
        close PARENT;
        print CHILD "Parent Pid $$ is sending this\n";
        chomp($line = <CHILD>);
        print "Parent Pid $$ just read this: '$line'\n";
        close CHILD;
        waitpid($pid, 0);
    } else {
        die "cannot fork: $!" unless defined $pid;
        close CHILD;
        chomp($line = <PARENT>);
        print "Child Pid $$ just read this: '$line'\n";
        print PARENT "Child Pid $$ is sending this\n";
        close PARENT;
        exit(0);
    }
d958 6
a963 6
    #!/usr/bin/perl -Tw
    use strict;
    BEGIN { $ENV{PATH} = "/usr/bin:/bin" }
    use Socket;
    use Carp;
    my $EOL = "\015\012";
d965 1
a965 1
    sub logmsg { print "$0 $$: @@_ at ", scalar localtime(), "\n" }
d967 2
a968 2
    my $port  = shift || 2345;
    die "invalid port" unless if $port =~ /^ \d+ $/x;
d970 1
a970 1
    my $proto = getprotobyname("tcp");
d972 5
a976 5
    socket(Server, PF_INET, SOCK_STREAM, $proto)    || die "socket: $!";
    setsockopt(Server, SOL_SOCKET, SO_REUSEADDR, pack("l", 1))
                                                    || die "setsockopt: $!";
    bind(Server, sockaddr_in($port, INADDR_ANY))    || die "bind: $!";
    listen(Server, SOMAXCONN)                       || die "listen: $!";
d978 1
a978 1
    logmsg "server started on port $port";
d980 1
a980 1
    my $paddr;
d982 3
a984 1
    $SIG{CHLD} = \&REAPER;
d986 3
a988 7
    for ( ; $paddr = accept(Client, Server); close Client) {
        my($port, $iaddr) = sockaddr_in($paddr);
        my $name = gethostbyaddr($iaddr, AF_INET);

        logmsg "connection from $name [",
                inet_ntoa($iaddr), "]
                at port $port";
d990 3
a992 3
        print Client "Hello there, $name, it's now ",
                        scalar localtime(), $EOL;
    }
d999 36
a1034 6
    #!/usr/bin/perl -Tw
    use strict;
    BEGIN { $ENV{PATH} = "/usr/bin:/bin" }
    use Socket;
    use Carp;
    my $EOL = "\015\012";
d1036 1
a1036 2
    sub spawn;  # forward declaration
    sub logmsg { print "$0 $$: @@_ at ", scalar localtime(), "\n" }
d1038 23
a1060 4
    my $port  = shift || 2345;
    die "invalid port" unless $port =~ /^ \d+ $/x;

    my $proto = getprotobyname("tcp");
d1062 2
a1063 5
    socket(Server, PF_INET, SOCK_STREAM, $proto)    || die "socket: $!";
    setsockopt(Server, SOL_SOCKET, SO_REUSEADDR, pack("l", 1))
                                                    || die "setsockopt: $!";
    bind(Server, sockaddr_in($port, INADDR_ANY))    || die "bind: $!";
    listen(Server, SOMAXCONN)                       || die "listen: $!";
d1065 3
a1067 1
    logmsg "server started on port $port";
d1069 10
a1078 2
    my $waitedpid = 0;
    my $paddr;
d1080 5
a1084 58
    use POSIX ":sys_wait_h";
    use Errno;

    sub REAPER {
        local $!;   # don't let waitpid() overwrite current error
        while ((my $pid = waitpid(-1, WNOHANG)) > 0 && WIFEXITED($?)) {
            logmsg "reaped $waitedpid" . ($? ? " with exit $?" : "");
        }
        $SIG{CHLD} = \&REAPER;  # loathe SysV
    }

    $SIG{CHLD} = \&REAPER;

    while (1) {
        $paddr = accept(Client, Server) || do {
            # try again if accept() returned because got a signal
            next if $!{EINTR};
            die "accept: $!";
        };
        my ($port, $iaddr) = sockaddr_in($paddr);
        my $name = gethostbyaddr($iaddr, AF_INET);

        logmsg "connection from $name [",
               inet_ntoa($iaddr),
               "] at port $port";

        spawn sub {
            $| = 1;
            print "Hello there, $name, it's now ", scalar localtime(), $EOL;
            exec "/usr/games/fortune"       # XXX: "wrong" line terminators
                or confess "can't exec fortune: $!";
        };
        close Client;
    }

    sub spawn {
        my $coderef = shift;

        unless (@@_ == 0 && $coderef && ref($coderef) eq "CODE") {
            confess "usage: spawn CODEREF";
        }

        my $pid;
        unless (defined($pid = fork())) {
            logmsg "cannot fork: $!";
            return;
        }
        elsif ($pid) {
            logmsg "begat $pid";
            return; # I'm the parent
        }
        # else I'm the child -- go spawn

        open(STDIN,  "<&Client")    || die "can't dup client to stdin";
        open(STDOUT, ">&Client")    || die "can't dup client to stdout";
        ## open(STDERR, ">&STDOUT") || die "can't dup stdout to stderr";
        exit($coderef->());
    }
d1300 1
a1300 1
                  || die "can't connect to daytime service on localhost";
d1575 2
a1576 1
   printf "[Connect from %s]\n", $hostinfo ? $hostinfo->name : $client->peerhost;
d1579 6
a1584 6
     next unless /\S/;       # blank line
     if    (/quit|exit/i)    { last                                      }
     elsif (/date|time/i)    { printf $client "%s\n", scalar localtime() }
     elsif (/who/i )         { print  $client `who 2>&1`                 }
     elsif (/cookie/i )      { print  $client `/usr/games/fortune 2>&1`  }
     elsif (/motd/i )        { print  $client `cat /etc/motd 2>&1`       }
d1617 28
a1644 4
    #!/usr/bin/perl -w
    use strict;
    use Socket;
    use Sys::Hostname;
d1646 2
a1647 3
    my ( $count, $hisiaddr, $hispaddr, $histime,
         $host, $iaddr, $paddr, $port, $proto,
         $rin, $rout, $rtime, $SECS_OF_70_YEARS);
d1649 11
a1659 34
    $SECS_OF_70_YEARS = 2_208_988_800;

    $iaddr = gethostbyname(hostname());
    $proto = getprotobyname("udp");
    $port = getservbyname("time", "udp");
    $paddr = sockaddr_in(0, $iaddr); # 0 means let kernel pick

    socket(SOCKET, PF_INET, SOCK_DGRAM, $proto)   || die "socket: $!";
    bind(SOCKET, $paddr)                          || die "bind: $!";

    $| = 1;
    printf "%-12s %8s %s\n",  "localhost", 0, scalar localtime();
    $count = 0;
    for $host (@@ARGV) {
        $count++;
        $hisiaddr = inet_aton($host)              || die "unknown host";
        $hispaddr = sockaddr_in($port, $hisiaddr);
        defined(send(SOCKET, 0, 0, $hispaddr))    || die "send $host: $!";
    }

    $rin = "";
    vec($rin, fileno(SOCKET), 1) = 1;

    # timeout after 10.0 seconds
    while ($count && select($rout = $rin, undef, undef, 10.0)) {
        $rtime = "";
        $hispaddr = recv(SOCKET, $rtime, 4, 0)    || die "recv: $!";
        ($port, $hisiaddr) = sockaddr_in($hispaddr);
        $host = gethostbyaddr($hisiaddr, AF_INET);
        $histime = unpack("N", $rtime) - $SECS_OF_70_YEARS;
        printf "%-12s ", $host;
        printf "%8d %s\n", $histime - time(), scalar localtime($histime);
        $count--;
    }
@


1.16
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d31 1
a31 1
    $SIG{INT} = __PACKAGE__ . "::catch_zap";  
d64 1
a64 1
processes in the current process group, and also sets $SIG{HUP} to C<"IGNORE"> 
d191 4
a194 1
  #!/usr/bin/perl -w
d199 1
a199 1
  use File::Spec::Functions;
d220 1
a220 1
      while (++$count) {
d222 1
a222 1
          print "$count\n";
d269 1
a269 1
If a signal of any given type fires multiple times during an opcode 
d333 1
a333 1
Perl 5.8.0 and later do I<not> use SA_RESTART.  Consequently, 
d338 1
a338 1
and C<close> as described above; interrupted C<wait> and 
d475 1
a475 1
    print FH "bang\n";      #  neither necessary nor sufficient 
d535 1
a535 1
Non-Unix users should check their C<< I<Your_OS>::Process >> module for 
d565 1
a565 1
    if ($pid) {                 # I am the parent 
d570 2
a571 2
        ($EUID, $EGID) = ($UID, $GID);  
        open (OUTFILE, "> $PRECIOUS") 
d623 1
a623 1
indeed with any use of pipe() with multiple subprocesses.  The 
d702 1
a702 1
    open(PS_PIPE, "-|", "ps", "aux") 
d712 1
a712 1
pipes is to use C<"|-"> in place of C<"-|">.  
d780 1
a780 1
for portability, but then it says it probably won't work except on 
d825 1
a825 1
        close PARENT_RDR; 
d834 1
a834 1
        close CHILD_RDR; 
d839 1
a839 1
        close PARENT_RDR; 
d898 1
a898 1
explicitly setting C<$AF_INET = 2>, you know you're in for big trouble.  
d919 1
a919 1
but unless you're on a Mac from way back in its pre-Unix dark ages, you'll 
d972 1
a972 1
    setsockopt(Server, SOL_SOCKET, SO_REUSEADDR, pack("l", 1))    
d1016 1
a1016 1
    setsockopt(Server, SOL_SOCKET, SO_REUSEADDR, pack("l", 1))         
d1072 1
a1072 1
        } 
d1102 1
a1102 1
notifies the parent process with a CHLD signal.  
d1107 1
a1107 1
signal handling code not modify the value of $!, or else this test 
d1110 1
a1110 1
it inevitably does when it has no more children waiting, it 
d1143 1
a1143 1
        socket(SOCKET, PF_INET, SOCK_STREAM, $proto)   
d1246 1
a1246 1
        } 
d1250 1
a1250 1
        } 
d1821 1
a1821 1
L<http://www.cpan.org/modules/00modlist.long.html#ID5_Networking_>.  
d1823 1
a1823 1
of what CPAN is and where to get it if the previous link doesn't work 
@


1.15
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d127 4
a130 5
        my $pid = waitpid(-1, WNOHANG);
        return if $pid == -1;
        return unless defined $children{$pid};
        delete $children{$pid};
        cleanup_child($pid, $?);
d548 1
a548 1
    use English qw[ -no_match_vars ];
d725 1
a725 3
not be correctly implemented on all alien systems.  Additionally, these are
not true multithreading.  To learn more about threading, see the F<modules>
file mentioned below in the SEE ALSO section.
d992 1
a992 1
And here's a multithreaded version.  It's multithreaded in that
d1008 1
a1008 1
    die "invalid port" unless if $port =~ /^ \d+ $/x;
d1548 1
a1548 1
incoming client at a time.  Multithreaded servers are covered in 
@


1.14
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d34 1
a34 1
Prior to Perl 5.7.3 it was necessary to do as little as you possibly
d227 1
a227 1
Before Perl 5.7.3, installing Perl code to deal with signals exposed you to
d247 1
a247 1
Perl 5.7.3 and later avoid these problems by "deferring" signals.  That is,
d296 1
a296 1
The default in Perl 5.7.3 and later is to automatically use
d331 1
a331 1
Perl 5.7.3 and later do I<not> use SA_RESTART.  Consequently, 
d524 1
a524 1
        (setsid() != -1)                || die "Can't start a new session: $!" 
d1099 1
a1099 1
L</Deferred Signals (Safe Signals)> above) in Perl 5.7.3 means that
d1280 2
a1281 4
IO::Socket module provides an object-oriented approach.  IO::Socket has
been included in the standard Perl distribution ever since Perl 5.004.  If
you're running an earlier version of Perl (in which case, how are you
reading this manpage?), just fetch IO::Socket from CPAN, where you'll also
d1701 2
a1702 2
    defined($id)                    || die "shmget: $!";
    print "shm key $id\n";
d1711 1
a1711 1
    defined($id)                    || die "shmget: $!";
d1749 1
a1749 2
clunky looking.  For a more modern look, see the IPC::SysV module
which is included with Perl starting from Perl 5.005.
@


1.13
log
@merge in perl 5.12.2 plus local changes
@
text
@d19 2
a20 2
special events transpire, like a child process exiting, your process
running out of stack space, or hitting file size limit.
d24 2
d27 3
a29 3
	my $signame = shift;
	$shucks++;
	die "Somebody sent me a SIG$signame";
d31 1
a31 1
    $SIG{INT} = 'catch_zap';  # could fail in modules
d43 1
a43 11
system, or you can retrieve them from the Config module.  Set up an
@@signame list indexed by number to get the name and a %signo table
indexed by name to get the number:

    use Config;
    defined $Config{sig_name} || die "No sigs?";
    foreach $name (split(' ', $Config{sig_name})) {
	$signo{$name} = $i;
	$signame[$i] = $name;
	$i++;
    }
d45 1
a45 8
So to check whether signal 17 and SIGALRM were the same, do just this:

    print "signal #17 = $signame[17]\n";
    if ($signo{ALRM}) {
	print "SIGALRM is $signo{ALRM}\n";
    }

You may also choose to assign the strings C<'IGNORE'> or C<'DEFAULT'> as
d50 2
a51 2
has special behavior with respect to a value of C<'IGNORE'>.
Setting C<$SIG{CHLD}> to C<'IGNORE'> on such a platform has the effect of
d53 2
a54 2
on its child processes (i.e. child processes are automatically reaped).
Calling C<wait()> with C<$SIG{CHLD}> set to C<'IGNORE'> usually returns
d57 4
a60 13
Some signals can be neither trapped nor ignored, such as
the KILL and STOP (but not the TSTP) signals.  One strategy for
temporarily ignoring signals is to use a local() statement, which will be
automatically restored once your block is exited.  (Remember that local()
values are "inherited" by functions called from within that block.)

    sub precious {
	local $SIG{INT} = 'IGNORE';
	&more_functions;
    }
    sub more_functions {
	# interrupts still ignored, for now...
    }
d63 3
a65 3
to the entire Unix process-group.  This code sends a hang-up signal to all
processes in the current process group (and sets $SIG{HUP} to IGNORE so
it doesn't kill itself):
d67 1
d69 3
a71 3
	local $SIG{HUP} = 'IGNORE';
	kill HUP => -$$;
	# snazzy writing of: kill('HUP', -$$)
d76 1
a76 1
or has changed its UID.
d79 1
a79 1
	warn "something wicked happened to $kid_pid";
d82 5
a86 4
When directed at a process whose UID is not identical to that
of the sending process, signal number zero may fail because
you lack permission to send the signal, even though the process is alive.
You may be able to determine the cause of failure using C<%!>.
d88 2
a89 2
    unless (kill 0 => $pid or $!{EPERM}) {
	warn "$pid looks dead";
d97 5
a101 18
But that will be problematic for the more complicated handlers that need
to reinstall themselves.  Because Perl's signal mechanism is currently
based on the signal(3) function from the C library, you may sometimes be so
unfortunate as to run on systems where that function is "broken", that
is, it behaves in the old unreliable SysV way rather than the newer, more
reasonable BSD and POSIX fashion.  So you'll see defensive people writing
signal handlers like this:

    sub REAPER {
	$waitedpid = wait;
	# loathe SysV: it makes us not only reinstate
	# the handler, but place it after the wait
	$SIG{CHLD} = \&REAPER;
    }
    $SIG{CHLD} = \&REAPER;
    # now do something that forks...

or better still:
d104 5
a108 12
    sub REAPER {
	my $child;
	# If a second child dies while in the signal handler caused by the
	# first death, we won't get another signal. So must loop here else
	# we will leave the unreaped child as a zombie. And the next time
	# two children die we get another zombie. And so on.
        while (($child = waitpid(-1,WNOHANG)) > 0) {
	    $Kid_Status{$child} = $?;
	}
	$SIG{CHLD} = \&REAPER;  # still loathe SysV
    }
    $SIG{CHLD} = \&REAPER;
d111 5
a115 5
Note: qx(), system() and some modules for calling external commands do a
fork() and wait() for the result. Thus, your signal handler (REAPER in the
example) will be called. Since wait() was already called by system() or qx()
the wait() in the signal handler will not see any more zombies and therefore
block.
d117 1
a117 1
The best way to prevent this issue is to use waitpid, as in the following
d126 1
a126 1
        local ($!,$?);
d136 1
d141 1
a141 1
        $children{$pid}=1;
d153 1
a153 2
goes off, you'll use die() to jump out of the block, much as you might
using longjmp() or throw() in other languages.
d157 1
d159 1
a159 1
        local $SIG{ALRM} = sub { die "alarm clock restart" };
d161 2
a162 1
        flock(FH, 2);   # blocking write lock
d165 1
a165 1
    if ($@@ and $@@ !~ /alarm clock restart/) { die }
d182 4
a185 10
tell that process to re-read its configuration file, without stopping
the process. Many daemons provide this mechanism using the C<SIGHUP>
signal handler. When you want to tell the daemon to re-read the file
you simply send it the C<SIGHUP> signal.

Not all platforms automatically reinstall their (native) signal
handlers after a signal delivery.  This means that the handler works
only the first time the signal is sent. The solution to this problem
is to use C<POSIX> signal handlers if available, their behaviour
is well-defined.
d189 2
a190 2
located in the subroutine C<code()>, which simply prints some debug
info to show that it works and should be replaced with the real code.
d199 1
a199 1
  $|=1;
d204 1
a204 1
  my $SELF = catfile $FindBin::Bin, $script;
d207 1
a207 7
  my $sigset = POSIX::SigSet->new();
  my $action = POSIX::SigAction->new('sigHUP_handler',
                                     $sigset,
                                     &POSIX::SA_NODEFER);
  POSIX::sigaction(&POSIX::SIGHUP, $action);

  sub sigHUP_handler {
d209 2
a210 2
      exec($SELF, @@ARGV) or die "Couldn't restart: $!\n";
  }
d217 2
a218 2
      my $c = 0;
      while (++$c) {
d220 1
a220 1
          print "$c\n";
a222 2
  __END__

a223 53
=head1 Named Pipes

A named pipe (often referred to as a FIFO) is an old Unix IPC
mechanism for processes communicating on the same machine.  It works
just like a regular, connected anonymous pipes, except that the
processes rendezvous using a filename and don't have to be related.

To create a named pipe, use the C<POSIX::mkfifo()> function.

    use POSIX qw(mkfifo);
    mkfifo($path, 0700) or die "mkfifo $path failed: $!";

You can also use the Unix command mknod(1) or on some
systems, mkfifo(1).  These may not be in your normal path.

    # system return val is backwards, so && not ||
    #
    $ENV{PATH} .= ":/etc:/usr/etc";
    if  (      system('mknod',  $path, 'p')
	    && system('mkfifo', $path) )
    {
	die "mk{nod,fifo} $path failed";
    }


A fifo is convenient when you want to connect a process to an unrelated
one.  When you open a fifo, the program will block until there's something
on the other end.

For example, let's say you'd like to have your F<.signature> file be a
named pipe that has a Perl program on the other end.  Now every time any
program (like a mailer, news reader, finger program, etc.) tries to read
from that file, the reading program will block and your program will
supply the new signature.  We'll use the pipe-checking file test B<-p>
to find out whether anyone (or anything) has accidentally removed our fifo.

    chdir; # go home
    $FIFO = '.signature';

    while (1) {
	unless (-p $FIFO) {
	    unlink $FIFO;
	    require POSIX;
	    POSIX::mkfifo($FIFO, 0700)
		or die "can't mkfifo $FIFO: $!";
	}

	# next line blocks until there's a reader
	open (FIFO, "> $FIFO") || die "can't write $FIFO: $!";
	print FIFO "John Smith (smith\@@host.org)\n", `fortune -s`;
	close FIFO;
	sleep 2;    # to avoid dup signals
    }
d227 8
a234 9
In Perls before Perl 5.7.3 by installing Perl code to deal with
signals, you were exposing yourself to danger from two things.  First,
few system library functions are re-entrant.  If the signal interrupts
while Perl is executing one function (like malloc(3) or printf(3)),
and your signal handler then calls the same function again, you could
get unpredictable behavior--often, a core dump.  Second, Perl isn't
itself re-entrant at the lowest levels.  If the signal interrupts Perl
while Perl is changing its own internal data structures, similarly
unpredictable behaviour may result.
d247 10
a256 11
Perl 5.7.3 and later avoid these problems by "deferring" signals.
That is, when the signal is delivered to the process by
the system (to the C code that implements Perl) a flag is set, and the
handler returns immediately. Then at strategic "safe" points in the
Perl interpreter (e.g. when it is about to execute a new opcode) the
flags are checked and the Perl level handler from %SIG is
executed. The "deferred" scheme allows much more flexibility in the
coding of signal handler as we know Perl interpreter is in a safe
state, and that we are not in a system library function when the
handler is called.  However the implementation does differ from
previous Perls in the following ways:
d262 1
a262 1
As the Perl interpreter only looks at the signal flags when it is about
d267 1
a267 1
N.B. If a signal of any given type fires multiple times during an opcode 
d269 1
a269 1
only be called once after the opcode completes, and all the other
a280 1

d283 12
a294 11
When a signal is delivered (e.g. INT control-C) the operating system
breaks into IO operations like C<read> (used to implement Perls
E<lt>E<gt> operator). On older Perls the handler was called
immediately (and as C<read> is not "unsafe" this worked well). With
the "deferred" scheme the handler is not called immediately, and if
Perl is using system's C<stdio> library that library may re-start the
C<read> without returning to Perl and giving it a chance to call the
%SIG handler. If this happens on your system the solution is to use
C<:perlio> layer to do IO - at least on those handles which you want
to be able to break into with signals. (The C<:perlio> layer checks
the signal flags and calls %SIG handlers before resuming IO operation.)
d296 1
a296 1
Note that the default in Perl 5.7.3 and later is to automatically use
d299 13
a311 7
Note that some networking library functions like gethostbyname() are
known to have their own implementations of timeouts which may conflict
with your timeouts.  If you are having problems with such functions,
you can try using the POSIX sigaction() function, which bypasses the
Perl safe signals (note that this means subjecting yourself to
possible memory corruption, as described above).  Instead of setting
C<$SIG{ALRM}>:
d317 3
a319 4
    use POSIX qw(SIGALRM);
    POSIX::sigaction(SIGALRM,
                     POSIX::SigAction->new(sub { die "alarm" }))
          or die "Error setting SIGALRM handler: $!\n";
d322 2
a323 2
the C<Perl::Unsafe::Signals> module from CPAN (which will affect
all signals).
d335 2
a336 2
Note that the default C<:perlio> layer will retry C<read>, C<write>
and C<close> as described above and that interrupted C<wait> and 
d341 3
a343 3
Certain signals, e.g. SEGV, ILL, and BUS, are generated as a result of
virtual memory or other "faults". These are normally fatal and there is
little a Perl-level handler can do with them, so Perl now delivers them
d349 1
a349 1
something" before returning. One example can be CHLD or CLD which
d353 3
a355 3
those signals (it does not do the C<wait>). Again the failure will
look like a loop as the operating system will re-issue the signal as
there are un-waited-for completed child processes.
d359 1
a359 1
If you want the old signal behaviour back regardless of possible
d361 55
a415 1
C<"unsafe"> (a new feature since Perl 5.8.1).
d425 1
a425 1
		    || die "can't fork: $!";
d428 1
a428 1
    close SPOOLER || die "bad spool: $! $?";
d433 1
a433 1
		    || die "can't fork: $!";
d435 2
a436 2
	next if /^(tcp|udp)/;
	print;
d438 1
a438 1
    close STATUS || die "bad netstat: $! $?";
d440 2
a441 3
If one can be sure that a particular program is a Perl script that is
expecting filenames in @@ARGV, the clever programmer can write something
like this:
d445 1
a445 1
and irrespective of which shell it's called from, the Perl program will
d454 1
a454 1
    die "bad netstat" if $?;
d459 1
a459 2
whole process, letting you to kill off the child process early if you'd
like.
d461 1
a461 1
Be careful to check both the open() and the close() return values.  If
d466 1
a466 1
can't know whether the command worked because your command is actually
d468 18
a485 15
while readers of bogus commands return just a quick end of file, writers
to bogus command will trigger a signal they'd better be prepared to
handle.  Consider:

    open(FH, "|bogus")	or die "can't fork: $!";
    print FH "bang\n"	or die "can't write: $!";
    close FH		or die "can't close: $!";

That won't blow up until the close, and it will blow up with a SIGPIPE.
To catch it, you could use this:

    $SIG{PIPE} = 'IGNORE';
    open(FH, "|bogus")  or die "can't fork: $!";
    print FH "bang\n"   or die "can't write: $!";
    close FH            or die "can't close: status=$?";
d504 1
a504 2
SIGCHLD because of the double-fork taking place (see below for more
details).
d510 5
a514 5
often called daemonization.  A well behaved daemon will also chdir()
to the root directory (so it doesn't prevent unmounting the filesystem
containing the directory from which it was launched) and redirect its
standard file descriptors from and to F</dev/null> (so that random
output doesn't wind up on the user's terminal).
d516 1
a516 1
    use POSIX 'setsid';
d519 7
a525 8
	chdir '/'		or die "Can't chdir to /: $!";
	open STDIN, '/dev/null' or die "Can't read /dev/null: $!";
	open STDOUT, '>/dev/null'
				or die "Can't write to /dev/null: $!";
	defined(my $pid = fork)	or die "Can't fork: $!";
	exit if $pid;
	die "Can't start a new session: $!" if setsid == -1;
	open STDERR, '>&STDOUT'	or die "Can't dup stdout: $!";
d528 2
a529 2
The fork() has to come before the setsid() to ensure that you aren't a
process group leader (the setsid() will fail if you are).  If your
d533 2
a534 2
Non-Unix users should check their Your_OS::Process module for other
solutions.
d539 1
a539 1
multiprocess and communicate between (or even amongst) yourselves.  The
d545 1
a545 1
write to the filehandle you opened and your kid will find it in his
d547 1
a547 1
you opened whatever your kid writes to his STDOUT.
d549 4
a552 2
    use English '-no_match_vars';
    my $sleep_count = 0;
d555 6
a560 6
	$pid = open(KID_TO_WRITE, "|-");
	unless (defined $pid) {
	    warn "cannot fork: $!";
	    die "bailing out" if $sleep_count++ > 6;
	    sleep 10;
	}
d563 13
a575 11
    if ($pid) {  # parent
	print KID_TO_WRITE @@some_data;
	close(KID_TO_WRITE) || warn "kid exited $?";
    } else {     # child
	($EUID, $EGID) = ($UID, $GID); # suid progs only
	open (FILE, "> /safe/file")
	    || die "can't open /safe/file: $!";
	while (<STDIN>) {
	    print FILE; # child's STDIN is parent's KID_TO_WRITE
	}
	exit;  # don't forget this
d586 8
a593 2
    # add error processing as above
    $pid = open(KID_TO_READ, "-|");
d595 5
a599 11
    if ($pid) {   # parent
	while (<KID_TO_READ>) {
	    # do something interesting
	}
	close(KID_TO_READ) || warn "kid exited $?";

    } else {      # child
	($EUID, $EGID) = ($UID, $GID); # suid only
	exec($program, @@options, @@args)
	    || die "can't exec program: $!";
	# NOTREACHED
d602 1
d604 2
a605 1
And here's a safe pipe open for writing:
a606 2
    # add error processing as above
    $pid = open(KID_TO_WRITE, "|-");
d609 9
a617 11
    if ($pid) {  # parent
	for (@@data) {
	    print KID_TO_WRITE;
	}
	close(KID_TO_WRITE) || warn "kid exited $?";

    } else {     # child
	($EUID, $EGID) = ($UID, $GID);
	exec($program, @@options, @@args)
	    || die "can't exec program: $!";
	# NOTREACHED
d621 2
a622 2
indeed any use of pipe() and multiple sub-processes.  The above
example is 'safe' because it is simple and calls exec().  See
d630 2
a631 2
    $pid = open WRITER, "|-";
    defined $pid or die "fork failed; $!";
d634 3
a636 2
            close WRITER;
            # do something else...
d639 5
a643 2
            # write to WRITER...
	    exit;
d647 2
a648 2
        # do something with STDIN...
	exit;
d651 1
a651 1
In the above, the true parent does not want to write to the WRITER
d653 2
a654 2
C<open FH, "|-">, it has a special behaviour: closing it will call
waitpid() (see L<perlfunc/waitpid>), which waits for the sub-process
d656 1
a656 1
in the section marked "do something else", then you have a deadlock.
d658 1
a658 1
This can also be a problem with intermediate sub-processes in more
d660 1
a660 1
during global destruction; in no predictable order.
d663 1
a663 1
open() which sets one file descriptor to another, as below:
d665 1
a665 1
    pipe(READER, WRITER);
d667 1
a667 1
    defined $pid or die "fork failed; $!";
d669 1
a669 1
	close READER;
d671 2
a672 1
            close WRITER;
d676 4
a679 1
	    exit;
d684 2
a685 2
        open STDIN, "<&READER";
        close WRITER;
d687 1
a687 1
        exit;
d690 3
a692 2
Since Perl 5.8.0, you can also use the list form of C<open> for pipes :
the syntax
d694 1
a694 1
    open KID_PS, "-|", "ps", "aux" or die $!;
d696 1
a696 4
forks the ps(1) command (without spawning a shell, as there are more than
three arguments to open()), and reads its standard output via the
C<KID_PS> filehandle.  The corresponding syntax to write to command
pipes (with C<"|-"> in place of C<"-|">) is also implemented.
d698 31
a728 4
Note that these operations are full Unix forks, which means they may not be
correctly implemented on alien systems.  Additionally, these are not true
multithreading.  If you'd like to learn more about threading, see the
F<modules> file mentioned below in the SEE ALSO section.
d732 19
a750 21
In general, if you have more than one sub-process, you need to be very
careful that any process which does not need the writer half of any
pipe you create for inter-process communication does not have it open.

The reason for this is that any child process which is reading from
the pipe and expecting an EOF will never receive it, and therefore
never exit.  A single process closing a pipe is not enough to close it;
the last process with the pipe open must close it for it to read EOF.

Certain built-in Unix features help prevent this most of
the time.  For instance, filehandles have a 'close on exec' flag (set
I<en masse> with Perl using the C<$^F> L<perlvar>), so that any
filehandles which you didn't explicitly route to the STDIN, STDOUT or
STDERR of a child I<program> will automatically be closed for you.

So, always explicitly and immediately call close() on the writable end
of any pipe, unless that process is actually writing to it.  If you
don't explicitly call close() then be warned Perl will still close()
all the filehandles during global destruction.  As warned above, if
those filehandles were opened with Safe Pipe Open, they will also call
waitpid() and you might again deadlock.
d755 1
a755 2
about bidirectional communication?  The obvious thing you'd like to do
doesn't actually work:
d757 1
d760 2
a761 2
and if you forget to use the C<use warnings> pragma or the B<-w> flag,
then you'll miss out entirely on the diagnostic message:
d765 5
a769 5
If you really want to, you can use the standard open2() library function
to catch both ends.  There's also an open3() for tridirectional I/O so you
can also catch your child's STDERR, but doing so would then require an
awkward select() loop and wouldn't allow you to use normal Perl input
operations.
d772 10
a781 5
primitives like Unix pipe() and exec() calls to create all the connections.
While it might have been slightly more efficient by using socketpair(), it
would have then been even less portable than it already is.  The open2()
and open3() functions are  unlikely to work anywhere except on a Unix
system or some other one purporting to be POSIX compliant.
d787 1
a787 1
    $pid = open2(*Reader, *Writer, "cat -u -n" );
d791 16
a806 31
The problem with this is that Unix buffering is really going to
ruin your day.  Even though your C<Writer> filehandle is auto-flushed,
and the process on the other end will get your data in a timely manner,
you can't usually do anything to force it to give it back to you
in a similarly quick fashion.  In this case, we could, because we
gave I<cat> a B<-u> flag to make it unbuffered.  But very few Unix
commands are designed to operate over pipes, so this seldom works
unless you yourself wrote the program on the other end of the
double-ended pipe.

A solution to this is the nonstandard F<Comm.pl> library.  It uses
pseudo-ttys to make your program behave more reasonably:

    require 'Comm.pl';
    $ph = open_proc('cat -n');
    for (1..10) {
	print $ph "a line\n";
	print "got back ", scalar <$ph>;
    }

This way you don't have to have control over the source code of the
program you're using.  The F<Comm> library also has expect()
and interact() functions.  Find the library (and we hope its
successor F<IPC::Chat>) at your nearest CPAN archive as detailed
in the SEE ALSO section below.

The newer Expect.pm module from CPAN also addresses this kind of thing.
This module requires two other modules from CPAN: IO::Pty and IO::Stty.
It sets up a pseudo-terminal to interact with programs that insist on
using talking to the terminal device driver.  If your system is
amongst those supported, this may be your best bet.
d810 4
a813 4
If you want, you may make low-level pipe() and fork()
to stitch this together by hand.  This example only
talks to itself, but you could reopen the appropriate
handles to STDIN and STDOUT and call other processes.
d818 3
a820 3
    use IO::Handle;	# thousands of lines just for autoflush :-(
    pipe(PARENT_RDR, CHILD_WTR);		# XXX: failure?
    pipe(CHILD_RDR,  PARENT_WTR);		# XXX: failure?
d824 8
a831 7
    if ($pid = fork) {
	close PARENT_RDR; close PARENT_WTR;
	print CHILD_WTR "Parent Pid $$ is sending this\n";
	chomp($line = <CHILD_RDR>);
	print "Parent Pid $$ just read this: `$line'\n";
	close CHILD_RDR; close CHILD_WTR;
	waitpid($pid,0);
d833 9
a841 7
	die "cannot fork: $!" unless defined $pid;
	close CHILD_RDR; close CHILD_WTR;
	chomp($line = <PARENT_RDR>);
	print "Child Pid $$ just read this: `$line'\n";
	print PARENT_WTR "Child Pid $$ is sending this\n";
	close PARENT_RDR; close PARENT_WTR;
	exit;
d852 2
a853 1
    use IO::Handle;	# thousands of lines just for autoflush :-(
d858 1
a858 1
				or  die "socketpair: $!";
d863 7
a869 7
    if ($pid = fork) {
	close PARENT;
	print CHILD "Parent Pid $$ is sending this\n";
	chomp($line = <CHILD>);
	print "Parent Pid $$ just read this: `$line'\n";
	close CHILD;
	waitpid($pid,0);
d871 7
a877 7
	die "cannot fork: $!" unless defined $pid;
	close CHILD;
	chomp($line = <PARENT>);
	print "Child Pid $$ just read this: `$line'\n";
	print PARENT "Child Pid $$ is sending this\n";
	close PARENT;
	exit;
d882 5
a886 5
While not limited to Unix-derived operating systems (e.g., WinSock on PCs
provides socket support, as do some VMS libraries), you may not have
sockets on your system, in which case this section probably isn't going to do
you much good.  With sockets, you can do both virtual circuits (i.e., TCP
streams) and datagrams (i.e., UDP packets).  You may be able to do even more
d889 1
a889 1
The Perl function calls for dealing with sockets have the same names as
d891 1
a891 1
for two reasons: first, Perl filehandles work differently than C file
d895 6
a900 6
One of the major problems with old socket code in Perl was that it used
hard-coded values for some of the constants, which severely hurt
portability.  If you ever see code that does anything like explicitly
setting C<$AF_INET = 2>, you know you're in for big trouble:  An
immeasurably superior approach is to use the C<Socket> module, which more
reliably grants access to various constants and functions you'll need.
d917 1
a917 1
accepting a lone "\012" on input (but be lenient in what you require).
d919 2
a920 1
but unless you're on a Mac, you'll probably be ok.
d932 1
a932 1
    my ($remote,$port, $iaddr, $paddr, $proto, $line);
d934 1
a934 1
    $remote  = shift || 'localhost';
d936 1
a936 1
    if ($port =~ /\D/) { $port = getservbyname($port, 'tcp') }
d938 1
a938 1
    $iaddr   = inet_aton($remote) 		|| die "no host: $remote";
d941 5
a945 5
    $proto   = getprotobyname('tcp');
    socket(SOCK, PF_INET, SOCK_STREAM, $proto)	|| die "socket: $!";
    connect(SOCK, $paddr)    || die "connect: $!";
    while (defined($line = <SOCK>)) {
	print $line;
d948 2
a949 2
    close (SOCK)	    || die "close: $!";
    exit;
d952 1
a952 1
leave the address as INADDR_ANY so that the kernel can choose
d955 1
a955 2
or firewall machine), you should fill this in with your real address
instead.
d959 1
a959 1
    BEGIN { $ENV{PATH} = '/usr/ucb:/bin' }
d964 1
a964 1
    sub logmsg { print "$0 $$: @@_ at ", scalar localtime, "\n" }
d966 2
a967 2
    my $port = shift || 2345;
    my $proto = getprotobyname('tcp');
d969 1
a969 1
    ($port) = $port =~ /^(\d+)$/                        or die "invalid port";
d971 5
a975 5
    socket(Server, PF_INET, SOCK_STREAM, $proto)	|| die "socket: $!";
    setsockopt(Server, SOL_SOCKET, SO_REUSEADDR,
					pack("l", 1)) 	|| die "setsockopt: $!";
    bind(Server, sockaddr_in($port, INADDR_ANY))	|| die "bind: $!";
    listen(Server,SOMAXCONN) 				|| die "listen: $!";
d983 3
a985 7
    for ( ; $paddr = accept(Client,Server); close Client) {
	my($port,$iaddr) = sockaddr_in($paddr);
	my $name = gethostbyaddr($iaddr,AF_INET);

	logmsg "connection from $name [",
		inet_ntoa($iaddr), "]
		at port $port";
d987 6
a992 2
	print Client "Hello there, $name, it's now ",
			scalar localtime, $EOL;
d996 1
a996 1
like most typical servers, it spawns (forks) a slave server to
d1002 1
a1002 1
    BEGIN { $ENV{PATH} = '/usr/ucb:/bin' }
d1008 1
a1008 1
    sub logmsg { print "$0 $$: @@_ at ", scalar localtime, "\n" }
d1010 2
a1011 2
    my $port = shift || 2345;
    my $proto = getprotobyname('tcp');
d1013 1
a1013 1
    ($port) = $port =~ /^(\d+)$/                        or die "invalid port";
d1015 5
a1019 5
    socket(Server, PF_INET, SOCK_STREAM, $proto)	|| die "socket: $!";
    setsockopt(Server, SOL_SOCKET, SO_REUSEADDR,
					pack("l", 1)) 	|| die "setsockopt: $!";
    bind(Server, sockaddr_in($port, INADDR_ANY))	|| die "bind: $!";
    listen(Server,SOMAXCONN) 				|| die "listen: $!";
d1031 2
a1032 2
        while ((my $pid = waitpid(-1,WNOHANG)) > 0 && WIFEXITED($?)) {
            logmsg "reaped $waitedpid" . ($? ? " with exit $?" : '');
d1039 1
a1039 1
    while(1) {
d1041 1
a1041 1
            # try again if accept() returned because a signal was received
d1053 3
a1055 3
            $|=1;
            print "Hello there, $name, it's now ", scalar localtime, $EOL;
            exec '/usr/games/fortune'       # XXX: `wrong' line terminators
d1064 1
a1064 1
        unless (@@_ == 0 && $coderef && ref($coderef) eq 'CODE') {
d1069 1
a1069 1
        if (! defined($pid = fork)) {
d1079 2
a1080 2
        open(STDIN,  "<&Client")   || die "can't dup client to stdin";
        open(STDOUT, ">&Client")   || die "can't dup client to stdout";
d1082 1
a1082 1
        exit &$coderef();
d1097 2
a1098 2
a false value.  This would normally indicate a system error that needs
to be reported.  However the introduction of safe signals (see
d1100 2
a1101 2
accept() may also be interrupted when the process receives a signal.
This typically happens when one of the forked sub-processes exits and
d1104 2
a1105 2
If accept() is interrupted by a signal then $! will be set to EINTR.
If this happens then we can safely continue to the next iteration of
d1107 5
a1111 5
signal handling code doesn't modify the value of $! or this test will
most likely fail.  In the REAPER subroutine we create a local version
of $! before calling waitpid().  When waitpid() sets $! to ECHILD (as
it inevitably does when it has no more children waiting), it will
update the local copy leaving the original unchanged.
d1113 1
a1113 1
We suggest that you use the B<-T> flag to use taint checking (see L<perlsec>)
d1115 1
a1115 1
for servers and other programs run on behalf of someone else (like CGI
d1127 2
a1128 2
    my $SECS_of_70_YEARS = 2208988800;
    sub ctime { scalar localtime(shift) }
d1130 3
a1132 3
    my $iaddr = gethostbyname('localhost');
    my $proto = getprotobyname('tcp');
    my $port = getservbyname('time', 'tcp');
d1137 1
a1137 1
    printf "%-24s %8s %s\n",  "localhost", 0, ctime(time());
d1140 11
a1150 10
	printf "%-24s ", $host;
	my $hisiaddr = inet_aton($host)     || die "unknown host";
	my $hispaddr = sockaddr_in($port, $hisiaddr);
	socket(SOCKET, PF_INET, SOCK_STREAM, $proto)   || die "socket: $!";
	connect(SOCKET, $hispaddr)          || die "connect: $!";
	my $rtime = '    ';
	read(SOCKET, $rtime, 4);
	close(SOCKET);
	my $histime = unpack("N", $rtime) - $SECS_of_70_YEARS;
	printf "%8d %s\n", $histime - time, ctime($histime);
d1166 2
a1167 2
    unless ( -S '/dev/log' ) {
	die "something's wicked with the log system";
d1177 3
a1179 3
    $rendezvous = shift || 'catsock';
    socket(SOCK, PF_UNIX, SOCK_STREAM, 0)	|| die "socket: $!";
    connect(SOCK, sockaddr_un($rendezvous))	|| die "connect: $!";
d1181 1
a1181 1
	print $line;
d1183 1
a1183 1
    exit;
d1194 1
a1194 1
    BEGIN { $ENV{PATH} = '/usr/ucb:/bin' }
d1196 1
a1196 1
    sub logmsg { print "$0 $$: @@_ at ", scalar localtime, "\n" }
d1198 1
a1198 1
    my $NAME = 'catsock';
d1200 1
a1200 1
    my $proto = getprotobyname('tcp');
d1202 1
a1202 1
    socket(Server,PF_UNIX,SOCK_STREAM,0) 	|| die "socket: $!";
d1204 2
a1205 2
    bind  (Server, $uaddr) 			|| die "bind: $!";
    listen(Server,SOMAXCONN)			|| die "listen: $!";
d1213 5
a1217 5
	my $child;
        while (($waitedpid = waitpid(-1,WNOHANG)) > 0) {
	    logmsg "reaped $waitedpid" . ($? ? " with exit $?" : '');
	}
	$SIG{CHLD} = \&REAPER;  # loathe SysV
d1224 2
a1225 2
	  accept(Client,Server) || $waitedpid;
	  $waitedpid = 0, close Client)
d1227 6
a1232 6
	next if $waitedpid;
	logmsg "connection on $NAME";
	spawn sub {
	    print "Hello there, it's now ", scalar localtime, "\n";
	    exec '/usr/games/fortune' or die "can't exec fortune: $!";
	};
d1236 1
a1236 1
	my $coderef = shift;
d1238 21
a1258 18
	unless (@@_ == 0 && $coderef && ref($coderef) eq 'CODE') {
	    confess "usage: spawn CODEREF";
	}

	my $pid;
	if (!defined($pid = fork)) {
	    logmsg "cannot fork: $!";
	    return;
	} elsif ($pid) {
	    logmsg "begat $pid";
	    return; # I'm the parent
	}
	# else I'm the child -- go spawn

	open(STDIN,  "<&Client")   || die "can't dup client to stdin";
	open(STDOUT, ">&Client")   || die "can't dup client to stdout";
	## open(STDERR, ">&STDOUT") || die "can't dup stdout to stderr";
	exit &$coderef();
d1263 1
a1263 2
logmsg(), ctime(), and REAPER()--which are exactly the same as in the
other server.
d1268 1
a1268 1
you get a separate session for each client: that's why accept() takes two
d1271 2
a1272 2
For example, let's say that you have a long running database server daemon
that you want folks from the World Wide Web to be able to access, but only
d1280 7
a1286 7
IO::Socket module provides an object-oriented approach.  IO::Socket is
included as part of the standard Perl distribution as of the 5.004
release.  If you're running an earlier version of Perl, just fetch
IO::Socket from CPAN, where you'll also find modules providing easy
interfaces to the following systems: DNS, FTP, Ident (RFC 931), NIS and
NISPlus, NNTP, Ping, POP3, SMTP, SNMP, SSLeay, Telnet, and Time--just
to name a few.
d1297 6
a1302 6
			Proto    => "tcp",
			PeerAddr => "localhost",
			PeerPort => "daytime(13)",
		    )
		  or die "cannot connect to daytime port at localhost";
    while ( <$remote> ) { print }
d1309 1
a1309 1
Here are what those parameters to the C<new> constructor mean:
d1325 1
a1325 1
or an address like C<"204.148.40.9">.  For demonstration purposes, we've
d1328 1
a1328 1
for localhost is C<"127.1">, if you'd rather use that.
d1335 3
a1337 3
is in I</etc/services> under Unix] but just in case, we've specified the
port number (13) in parentheses.  Using just the number would also have
worked, but constant numbers make careful programmers nervous.
d1342 2
a1343 2
a filehandle in the C<while> loop?  That's what's called an indirect
filehandle, a scalar variable containing a filehandle.  You can use
d1360 1
a1360 1
from, and then a list of documents to get from that host.  This is a
d1366 1
a1366 1
    unless (@@ARGV > 1) { die "usage: $0 host document ..." }
d1370 9
a1378 10
    foreach $document ( @@ARGV ) {
	$remote = IO::Socket::INET->new( Proto     => "tcp",
					 PeerAddr  => $host,
					 PeerPort  => "http(80)",
				        );
	unless ($remote) { die "cannot connect to http daemon on $host" }
	$remote->autoflush(1);
	print $remote "GET $document HTTP/1.0" . $BLANK;
	while ( <$remote> ) { print }
	close $remote;
d1381 3
a1383 3
The web server handing the "http" service, which is assumed to be at
its standard port, number 80.  If the web server you're trying to
connect to is at a different port (like 1080 or 8080), you should specify
d1386 3
a1388 3
up the output we sent it.  (If you're on a Mac, you'll also need to
change every C<"\n"> in your code that sends data over the network to
be a C<"\015\012"> instead.)
d1418 1
a1418 1
For a more fully-featured version of this program, you should look to
d1453 3
a1455 3
				    PeerAddr  => $host,
				    PeerPort  => $port)
	   or die "can't connect to port $port on $host: $!";
d1457 1
a1457 1
    $handle->autoflush(1);		# so output gets there right away
d1465 5
a1469 5
	# copy the socket to standard output
	while (defined ($line = <$handle>)) {
	    print STDOUT $line;
	}
	kill("TERM", $kidpid);  		# send SIGTERM to child
d1473 5
a1477 4
	# copy standard input to the socket
	while (defined ($line = <STDIN>)) {
	    print $handle $line;
	}
d1481 1
a1481 1
signal to our child process (current running in the C<else> block)
d1491 1
a1491 1
	print STDOUT $byte;
d1551 4
a1554 4
This server accepts one of five different commands, sending output
back to the client.  Note that unlike most network servers, this one
only handles one incoming client at a time.  Multithreaded servers are
covered in Chapter 6 of the Camel.
d1560 1
a1560 1
 use Net::hostent;		# for OO version of gethostbyaddr
d1562 1
a1562 1
 $PORT = 9000;			# pick something not in use
d1564 1
a1564 1
 $server = IO::Socket::INET->new( Proto     => 'tcp',
d1579 6
a1584 6
     next unless /\S/;	     # blank line
     if    (/quit|exit/i)    { last;                                     }
     elsif (/date|time/i)    { printf $client "%s\n", scalar localtime;  }
     elsif (/who/i )         { print  $client `who 2>&1`;                }
     elsif (/cookie/i )      { print  $client `/usr/games/fortune 2>&1`; }
     elsif (/motd/i )        { print  $client `cat /etc/motd 2>&1`;      }
d1606 4
a1609 4
Note that UDP datagrams are I<not> a bytestream and should not be treated
as such. This makes using I/O mechanisms with internal buffering
like stdio (i.e. print() and friends) especially cumbersome. Use syswrite(),
or better send(), like in the example below.
d1623 2
a1624 2
	 $host, $iaddr, $paddr, $port, $proto,
	 $rin, $rout, $rtime, $SECS_of_70_YEARS);
d1626 1
a1626 1
    $SECS_of_70_YEARS      = 2208988800;
d1629 2
a1630 2
    $proto = getprotobyname('udp');
    $port = getservbyname('time', 'udp');
d1637 1
a1637 1
    printf "%-12s %8s %s\n",  "localhost", 0, scalar localtime time;
d1640 4
a1643 4
	$count++;
	$hisiaddr = inet_aton($host) 	|| die "unknown host";
	$hispaddr = sockaddr_in($port, $hisiaddr);
	defined(send(SOCKET, 0, 0, $hispaddr))    || die "send $host: $!";
d1646 1
a1646 1
    $rin = '';
d1651 8
a1658 8
	$rtime = '';
	($hispaddr = recv(SOCKET, $rtime, 4, 0)) 	|| die "recv: $!";
	($port, $hisiaddr) = sockaddr_in($hispaddr);
	$host = gethostbyaddr($hisiaddr, AF_INET);
	$histime = unpack("N", $rtime) - $SECS_of_70_YEARS;
	printf "%-12s ", $host;
	printf "%8d %s\n", $histime - time, scalar localtime($histime);
	$count--;
d1661 4
a1664 4
Note that this example does not include any retries and may consequently
fail to contact a reachable host. The most prominent reason for this
is congestion of the queues on the sending host if the number of
list of hosts to contact is sufficiently large.
d1669 4
a1672 4
interesting uses.  You can't, however, effectively use SysV IPC or
Berkeley mmap() to have shared memory so as to share a variable amongst
several processes.  That's because Perl would reallocate your string when
you weren't wanting it to.
d1679 2
a1680 1
    $id = shmget(IPC_PRIVATE, $size, S_IRUSR|S_IWUSR) // die "$!";
d1684 1
a1684 1
    shmwrite($id, $message, 0, 60) || die "$!";
d1686 1
a1686 1
    shmread($id, $buff, 0, 60) || die "$!";
d1690 1
a1690 1
    substr($buff, index($buff, "\0")) = '';
d1695 1
a1695 1
    shmctl($id, IPC_RMID, 0) || die "$!";
d1702 2
a1703 1
    $id = semget($IPC_KEY, 10, 0666 | IPC_CREAT ) // die "$!";
d1712 2
a1713 2
    $id = semget($IPC_KEY,  0 , 0 );
    die if !defined($id);
d1715 1
a1715 1
    $semnum = 0;
d1718 1
a1718 1
    # 'take' semaphore
d1726 1
a1726 1
    $opstring = $opstring1 . $opstring2;
d1728 1
a1728 1
    semop($id,$opstring) || die "$!";
d1733 1
a1733 1
    # 'give' the semaphore
d1739 1
a1739 1
    die if !defined($id);
d1741 1
a1741 1
    $semnum = 0;
d1748 1
a1748 1
    semop($id,$opstring) || die "$!";
d1759 1
d1761 1
a1761 1
    my $sent = "message";
a1762 2
    my $rcvd;
    my $type_rcvd;
d1764 10
a1773 16
    if (defined $id) {
        if (msgsnd($id, pack("l! a*", $type_sent, $sent), 0)) {
            if (msgrcv($id, $rcvd, 60, 0, 0)) {
                ($type_rcvd, $rcvd) = unpack("l! a*", $rcvd);
                if ($rcvd eq $sent) {
                    print "okay\n";
                } else {
                    print "not okay\n";
                }
            } else {
                die "# msgrcv failed\n";
            }
        } else {
            die "# msgsnd failed\n";
        }
        msgctl($id, IPC_RMID, 0) || die "# msgctl failed: $!\n";
d1775 1
a1775 1
        die "# msgget failed\n";
d1778 2
d1785 1
a1785 1
functions  croak() on bad arguments.)  It is therefore essential to
d1787 2
a1788 2
programs this way for optimal success, and don't forget to add B<-T>
taint checking flag to the #! line for servers:
d1797 1
a1797 1
All these routines create system-specific portability problems.  As noted
d1799 1
a1799 1
behaviour.  It's probably safest to assume broken SysV semantics for
d1814 5
a1818 5
For intrepid programmers, the indispensable textbook is I<Unix
Network Programming, 2nd Edition, Volume 1> by W. Richard Stevens
(published by Prentice-Hall).  Note that most books on networking
address the subject from the perspective of a C programmer; translation
to Perl is left as an exercise for the reader.
d1822 12
a1833 9
functions in L<perlfunc>, you should also check out the F<modules> file
at your nearest CPAN site.  (See L<perlmodlib> or best yet, the F<Perl
FAQ> for a description of what CPAN is and where to get it.)

Section 5 of the F<modules> file is devoted to "Networking, Device Control
(modems), and Interprocess Communication", and contains numerous unbundled
modules numerous networking modules, Chat and Expect operations, CGI
programming, DCE, FTP, IPC, NNTP, Proxy, Ptty, RPC, SNMP, SMTP, Telnet,
Threads, and ToolTalk--just to name a few.
@


1.12
log
@Merge in perl 5.10.1
@
text
@d153 37
a189 1
Signal handling is also used for timeouts in Unix,   While safely
d355 2
a356 2
In Perl 5.7.3 and later to avoid these problems signals are
"deferred"-- that is when the signal is delivered to the process by
d757 1
a757 1
There are some features built-in to unix to help prevent this most of
d1168 1
a1168 1
	connect(SOCKET, $hispaddr)          || die "bind: $!";
d1700 1
a1700 1
    $id = shmget(IPC_PRIVATE, $size, S_IRUSR|S_IWUSR) || die "$!";
d1722 1
a1722 1
    $id = semget($IPC_KEY, 10, 0666 | IPC_CREAT ) || die "$!";
@


1.11
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d129 1
a129 1
	# loathe sysV: it makes us not only reinstate
d148 1
a148 1
	$SIG{CHLD} = \&REAPER;  # still loathe sysV
d539 1
a539 1
	setsid			or die "Can't start a new session: $!";
d584 1
a584 1
	    print FILE; # child's STDIN is parent's KID
d633 62
d710 24
d1022 1
a1022 1
        $SIG{CHLD} = \&REAPER;  # loathe sysV
d1204 1
a1204 1
	$SIG{CHLD} = \&REAPER;  # loathe sysV
@


1.10
log
@merge in perl 5.8.8
@
text
@d122 1
a122 1
misfortunate as to run on systems where that function is "broken", that
d312 1
a312 1
which will just restart.  That means you have to C<die> to longjump(3) out
d333 20
a352 1
=item Long running opcodes
a353 4
As Perl interpreter only looks at the signal flags when it about to
execute a new opcode if a signal arrives during a long running opcode
(e.g. a regular expression operation on a very large string) then
signal will not be seen until operation completes.
d389 4
d409 4
a412 12
Certain signals e.g. SEGV, ILL, BUS are generated as a result of
virtual memory or other "faults". These are normally fatal and there
is little a Perl-level handler can do with them. (In particular the
old signal scheme was particularly unsafe in such cases.)  However if
a %SIG handler is set the new scheme simply sets a flag and returns as
described above. This may cause the operating system to try the
offending machine instruction again and - as nothing has changed - it
will generate the signal again. The result of this is a rather odd
"loop". In future Perl's signal mechanism may be changed to avoid this
- perhaps by simply disallowing %SIG handlers on signals of that
type. Until then the work-round is not to set a %SIG handler on those
signals. (Which signals they are is operating system dependent.)
d546 1
a546 1
C<TIOCNOTTY> ioctl() on it instead.  See L<tty(4)> for details.
d929 2
d932 5
a936 5
	my $child;
        while (($waitedpid = waitpid(-1,WNOHANG)) > 0) {
	    logmsg "reaped $waitedpid" . ($? ? " with exit $?" : '');
	}
	$SIG{CHLD} = \&REAPER;  # loathe sysV
d941 20
a960 19
    for ( $waitedpid = 0;
	  ($paddr = accept(Client,Server)) || $waitedpid;
	  $waitedpid = 0, close Client)
    {
	next if $waitedpid and not $paddr;
	my($port,$iaddr) = sockaddr_in($paddr);
	my $name = gethostbyaddr($iaddr,AF_INET);

	logmsg "connection from $name [",
		inet_ntoa($iaddr), "]
		at port $port";

	spawn sub {
	    $|=1;
	    print "Hello there, $name, it's now ", scalar localtime, $EOL;
	    exec '/usr/games/fortune'		# XXX: `wrong' line terminators
		or confess "can't exec fortune: $!";
	};

d964 1
a964 21
	my $coderef = shift;

	unless (@@_ == 0 && $coderef && ref($coderef) eq 'CODE') {
	    confess "usage: spawn CODEREF";
	}

	my $pid;
	if (!defined($pid = fork)) {
	    logmsg "cannot fork: $!";
	    return;
	} elsif ($pid) {
	    logmsg "begat $pid";
	    return; # I'm the parent
	}
	# else I'm the child -- go spawn

	open(STDIN,  "<&Client")   || die "can't dup client to stdin";
	open(STDOUT, ">&Client")   || die "can't dup client to stdout";
	## open(STDERR, ">&STDOUT") || die "can't dup stdout to stderr";
	exit &$coderef();
    }
d966 48
a1013 7
This server takes the trouble to clone off a child version via fork() for
each incoming request.  That way it can handle many requests at once,
which you might not always want.  Even if you don't fork(), the listen()
will allow that many pending connections.  Forking servers have to be
particularly careful about cleaning up their dead children (called
"zombies" in Unix parlance), because otherwise you'll quickly fill up your
process table.
d1575 1
a1575 1
    use IPC::SysV qw(IPC_PRIVATE IPC_RMID S_IRWXU);
d1578 1
a1578 1
    $id = shmget(IPC_PRIVATE, $size, S_IRWXU) || die "$!";
d1653 1
a1653 1
    use IPC::SysV qw(IPC_PRIVATE IPC_RMID IPC_CREAT S_IRWXU);
d1655 1
a1655 1
    my $id = msgget(IPC_PRIVATE, IPC_CREAT | S_IRWXU);
@


1.9
log
@sync in-tree perl with 5.8.6
@
text
@d249 6
a254 1
To create a named pipe, use the Unix command mknod(1) or on some
a279 1
    $ENV{PATH} .= ":/etc:/usr/games";
d284 3
a286 2
	    system('mknod', $FIFO, 'p')
		&& die "can't mknod $FIFO: $!";
d315 2
a316 2
The pragmatic approach was to say ``I know the risks, but prefer the
convenience'', and to do anything you wanted in your signal handler,
d629 1
a629 1
C<KID_PS> filehandle.  The corresponding syntax to read from command
d1015 1
a1015 1
	my $histime = unpack("N", $rtime) - $SECS_of_70_YEARS ;
d1519 1
a1519 1
	$histime = unpack("N", $rtime) - $SECS_of_70_YEARS ;
@


1.8
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d358 1
a358 1
C<$SIG{ALRM}> try something like the following:
d360 8
a367 3
    use POSIX;
    sigaction SIGALRM, new POSIX::SigAction sub { die "alarm\n" }
        or die "Error setting SIGALRM handler: $!\n";
d396 1
a396 1
signals. (Which signals they are is operating system dependant.)
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d1033 1
a1033 1
    $rendezvous = shift || '/tmp/catsock';
d1054 1
a1054 1
    my $NAME = '/tmp/catsock';
d1613 1
a1613 1
    my $type = 1234;
a1659 9

As mentioned in the signals section, because few vendors provide C
libraries that are safely re-entrant, the prudent programmer will do
little else within a handler beyond setting a numeric variable that
already exists; or, if locked into a slow (restarting) system call,
using die() to raise an exception and longjmp(3) out.  In fact, even
these may in some cases cause a core dump.  It's probably best to avoid
signals except where they are absolutely inevitable.  This
will be addressed in a future release of Perl.
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d38 1
a38 1
dump - see L<Deferred Signals> below.
d98 1
a98 1
actually affect another process, but instead checks whether it's alive
d105 9
d291 1
a291 1
=head2 Deferred Signals
d352 26
d406 4
d597 1
a597 1
    $SIG{ALRM} = sub { die "whoops, $program pipe broke" };
d1430 1
a1430 1
   printf "[Connect from %s]\n", $hostinfo->name || $client->peerhost;
d1680 5
a1684 4
For intrepid programmers, the indispensable textbook is I<Unix Network
Programming> by W. Richard Stevens (published by Addison-Wesley).  Note
that most books on networking address networking from the perspective of
a C programmer; translation to Perl is left as an exercise for the reader.
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d13 10
a22 15
Perl uses a simple signal handling model: the %SIG hash contains names or
references of user-installed signal handlers.  These handlers will be called
with an argument which is the name of the signal that triggered it.  A
signal may be generated intentionally from a particular keyboard sequence like
control-C or control-Z, sent to you from another process, or
triggered automatically by the kernel when special events transpire, like
a child process exiting, your process running out of stack space, or
hitting file size limit.

For example, to trap an interrupt signal, set up a handler like this.
Do as little as you possibly can in your handler; notice how all we do is
set a global variable and then raise an exception.  That's because on most
systems, libraries are not re-entrant; particularly, memory allocation and
I/O routines are not.  That means that doing nearly I<anything> in your
handler could in theory trigger a memory fault and subsequent core dump.
d32 8
d127 1
a127 1
or even the more elaborate:
d132 4
d171 62
d282 1
a282 1
=head2 WARNING
d284 9
a292 8
By installing Perl code to deal with signals, you're exposing yourself
to danger from two things.  First, few system library functions are
re-entrant.  If the signal interrupts while Perl is executing one function
(like malloc(3) or printf(3)), and your signal handler then calls the
same function again, you could get unpredictable behavior--often, a
core dump.  Second, Perl isn't itself re-entrant at the lowest levels.
If the signal interrupts Perl while Perl is changing its own internal
data structures, similarly unpredictable behaviour may result.
d294 2
a295 2
There are two things you can do, knowing this: be paranoid or be
pragmatic.  The paranoid approach is to do as little as possible in your
d301 15
a315 7
The pragmatic approach is to say ``I know the risks, but prefer the
convenience'', and to do anything you want in your signal handler,
prepared to clean up core dumps now and again.

To forbid signal handlers altogether would bars you from
many interesting programs, including virtually everything in this manpage,
since you could no longer even write SIGCHLD handlers.  
d317 53
d373 4
a376 4
Perl's basic open() statement can also be used for unidirectional interprocess
communication by either appending or prepending a pipe symbol to the second
argument to open().  Here's how to start something up in a child process you
intend to write to:
d504 1
a504 1
    use English;
d573 10
d651 1
a651 1
using talking to the terminal device driver.  If your system is 
d687 1
a687 1
But you don't actually have to make two pipe calls.  If you 
d868 1
d870 4
a873 1
	$waitedpid = wait;
a874 1
	logmsg "reaped $waitedpid" . ($? ? " with exit $?" : '');
d1028 1
d1030 4
a1033 1
	$waitedpid = wait;
a1034 1
	logmsg "reaped $waitedpid" . ($? ? " with exit $?" : '');
d1358 2
a1359 2
to it.  The server blocks in the C<accept> method, which eventually an
bidirectional connection to the remote client.  (Make sure to autoflush
d1628 1
a1628 1
signals except where they are absolutely inevitable.  This 
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d237 1
a237 2
since you could no longer even write SIGCHLD handlers.  Their dodginess
is expected to be addresses in the 5.005 release.
d663 1
a663 1
    $EOL = "\015\012";
d669 2
a670 1
    $port = $1 if $port =~ /(\d+)/; # untaint port number
d706 1
a706 1
    $EOL = "\015\012";
d713 2
a714 1
    $port = $1 if $port =~ /(\d+)/; # untaint port number
d748 1
d840 1
a840 1
	die "something's wicked with the print system";
d868 1
d905 23
d951 1
a951 1
IO::Socket from CPAN, where you'll also find find modules providing easy
d979 1
a979 1
=over
d1051 1
a1051 1
its standard port, number 80.  If your the web server you're trying to
d1174 1
a1174 1
=over
d1274 5
d1328 5
@


1.3
log
@perl5.005_03 (stock)
@
text
@d61 1
a61 1
On most UNIX platforms, the C<CHLD> (sometimes also known as C<CLD>) signal
d129 1
a129 1
        while ($child = waitpid(-1,WNOHANG)) {
d155 4
d283 1
a283 1
whole thing into memory at once. It also gives you finer control of the
d314 1
a314 2
them at once, strange things can happen.  You'll certainly want to any
stdio flush output buffers before forking.  You may also want to close
d456 2
a457 2
and if you forget to use the B<-w> flag, then you'll miss out
entirely on the diagnostic message:
a478 1
    Writer->autoflush(); # default here, actually
d1027 1
a1027 1
as the named-parameter pair, C<PeerPort =E<gt> 8080>.  The C<autoflush>
d1145 1
a1145 1
It does this by calling the C<IO::Socket::INET-E<gt>new()> method with
d1164 1
a1164 1
message. Under Unix, the C<netstat -a> command will show
d1308 1
a1308 1
    use IPC::SysV qw(IPC_PRIVATE IPC_RMID S_IRWXU S_IRWXG S_IRWXO);
d1311 2
a1312 2
    $key = shmget(IPC_PRIVATE, $size, S_IRWXU|S_IRWXG|S_IRWXO) || die "$!";
    print "shm key $key\n";
d1315 1
a1315 1
    shmwrite($key, $message, 0, 60) || die "$!";
d1317 1
a1317 1
    shmread($key, $buff, 0, 60) || die "$!";
d1325 2
a1326 2
    print "deleting shm $key\n";
    shmctl($key, IPC_RMID, 0) || die "$!";
d1333 2
a1334 2
    $key = semget($IPC_KEY, 10, 0666 | IPC_CREAT ) || die "$!";
    print "shm key $key\n";
d1342 2
a1343 2
    $key = semget($IPC_KEY,  0 , 0 );
    die if !defined($key);
d1351 1
a1351 1
    $opstring1 = pack("sss", $semnum, $semop, $semflag);
d1355 1
a1355 1
    $opstring2 = pack("sss", $semnum, $semop,  $semflag);
d1358 1
a1358 1
    semop($key,$opstring) || die "$!";
d1368 2
a1369 2
    $key = semget($IPC_KEY, 0, 0);
    die if !defined($key);
d1376 1
a1376 1
    $opstring = pack("sss", $semnum, $semop, $semflag);
d1378 1
a1378 1
    semop($key,$opstring) || die "$!";
d1383 31
@


1.2
log
@perl 5.004_04
@
text
@d59 11
a69 1
default thing.  Some signals can be neither trapped nor ignored, such as
d176 1
a176 1
	die "mk{nod,fifo} $path failed;
d209 27
d264 1
a264 1
    $ program f1 "cmd1|" - f2 "cmd2|" f3 < tmpfile
d294 11
a304 3
    open(FH, "|bogus");
    print FH "bang\n";
    close FH;
d308 7
a314 6
Both the main process and the child process share the same STDIN,
STDOUT and STDERR filehandles.  If both processes try to access them
at once, strange things can happen.  You may want to close or reopen
the filehandles for the child.  You can get around this by opening
your pipe with open(), but on some systems this means that the child
process cannot outlive the parent.
d330 24
a353 19
complete dissociate the child process from the parent.  The following
process is reported to work on most Unixish systems.  Non-Unix users
should check their Your_OS::Process module for other solutions.

=over 4

=item *

Open /dev/tty and use the TIOCNOTTY ioctl on it.  See L<tty(4)>
for details.

=item *

Change directory to /

=item *

Reopen STDIN, STDOUT, and STDERR so they're not connected to the old
tty.
d355 2
a356 7
=item *

Background yourself like this:

    fork && exit;

=back
d465 1
a465 1
primitives like Unix pipe() and exec() to create all the connections.
d475 1
a475 1
    $pid = open2( \*Reader, \*Writer, "cat -u -n" );
d506 74
d610 11
a628 1
    require 5.002;
a657 1
    require 5.002;
d662 1
d691 1
a691 1
			scalar localtime, "\n";
a699 1
    require 5.002;
d704 1
d745 2
a746 2
	    print "Hello there, $name, it's now ", scalar localtime, "\n";
	    exec '/usr/games/fortune'
a793 1
    require 5.002;
d830 1
a830 1
    $ ls -l /dev/log
a841 1
    require 5.002;
d854 3
a856 1
And here's a corresponding server.
a858 1
    require 5.002;
d864 1
d877 8
d887 1
d1008 2
d1017 1
a1017 1
	print $remote "GET $document HTTP/1.0\n\n";
d1044 1
a1044 1
    shell_prompt$ webget www.perl.com /guanaco.html
d1079 2
a1080 3
is one of the cornerstones of the Unix philosophy, and good software
engineering as well, which is probably why it's spread to other systems
as well.)
a1123 3
The C<kill> at the end of the parent's block is there to eliminate the
child process as soon as the server we connect to closes its end.

d1140 1
a1140 1
Setting up server is little bit more involved than running a client.
d1194 1
a1194 1
covered in Chapter 6 of the Camel or in the perlipc(1) manpage.
a1253 1
    require 5.002;
d1306 2
a1307 2
    $IPC_PRIVATE = 0;
    $IPC_RMID = 0;
d1309 2
a1310 2
    $key = shmget($IPC_PRIVATE, $size , 0777 );
    die unless defined $key;
d1313 9
a1321 2
    shmwrite($key, $message, 0, 60 ) || die "$!";
    shmread($key,$buff,0,60) || die "$!";
d1323 2
a1324 1
    print $buff,"\n";
d1326 1
a1326 2
    print "deleting $key\n";
    shmctl($key ,$IPC_RMID, 0) || die "$!";
d1328 1
a1328 1
Here's an example of a semaphore:
d1331 2
a1332 5
    $IPC_RMID = 0;
    $IPC_CREATE = 0001000;
    $key = semget($IPC_KEY, $nsems , 0666 | $IPC_CREATE );
    die if !defined($key);
    print "$key\n";
d1379 2
a1380 3
clunky looking.  It should at the very least be made to C<use strict>
and C<require "sys/ipc.ph">.  Better yet, check out the IPC::SysV modules
on CPAN.
d1384 7
a1390 13
If you are running under version 5.000 (dubious) or 5.001, you can still
use most of the examples in this document.  You may have to remove the
C<use strict> and some of the my() statements for 5.000, and for both
you'll have to load in version 1.2 or older of the F<Socket.pm> module, which
is included in I<perl5.002>.

Most of these routines quietly but politely return C<undef> when they fail
instead of causing your program to die right then and there due to an
uncaught exception.  (Actually, some of the new I<Socket> conversion
functions  croak() on bad arguments.)  It is therefore essential
that you should check the return values of these functions.  Always begin
your socket programs this way for optimal success, and don't forget to add
B<-T> taint checking flag to the pound-bang line for servers:
d1392 1
a1392 2
    #!/usr/bin/perl -w
    require 5.002;
d1406 8
a1413 8
Because few vendors provide C libraries that are safely re-entrant,
the prudent programmer will do little else within a handler beyond
setting a numeric variable that already exists; or, if locked into
a slow (restarting) system call, using die() to raise an exception
and longjmp(3) out.  In fact, even these may in some cases cause a
core dump.  It's probably best to avoid signals except where they are
absolutely inevitable.  This perilous problems will be addressed in a
future release of Perl.
d1425 4
a1428 4
For intrepid programmers, the classic textbook I<Unix Network Programming>
by Richard Stevens (published by Addison-Wesley).  Note that most books
on networking address networking from the perspective of a C programmer;
translation to Perl is left as an exercise for the reader.
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
perlipc - Perl interprocess communication (signals, fifos, pipes, safe subprocceses, sockets, and semaphores)
d17 1
a17 1
control-C or control-Z, sent to you from an another process, or
d19 1
a19 1
a child process exiting, your process running out of stack space, or 
d23 5
a27 5
Notice how all we do is set with a global variable and then raise an
exception.  That's because on most systems libraries are not
re-entrant, so calling any print() functions (or even anything that needs to
malloc(3) more memory) could in theory trigger a memory fault
and subsequent core dump.
d33 1
a33 1
    } 
d48 1
a48 1
    }   
d50 1
a50 1
So to check whether signal 17 and SIGALRM were the same, just do this:
d53 1
a53 1
    if ($signo{ALRM}) { 
d55 1
a55 1
    }   
d68 1
a68 1
    } 
d71 1
a71 1
    } 
d74 3
a76 3
to the entire Unix process-group.  This code send a hang-up signal to all
processes in the current process group I<except for> the current process
itself:
d86 1
a86 1
or has changed its UID.  
d90 1
a90 1
    } 
d98 2
a99 2
to re-install themselves.  Because Perl's signal mechanism is currently
based on the signal(3) function from the C library, you may somtimes be so
d105 1
a105 2
    sub REAPER { 
	$SIG{CHLD} = \&REAPER;  # loathe sysV
d107 3
d116 2
a117 2
    use POSIX "wait_h";
    sub REAPER { 
a118 1
	$SIG{CHLD} = \&REAPER;  # loathe sysV
d121 2
a122 1
	} 
d137 1
a137 1
    eval { 
d139 1
a139 1
        alarm 10; 
d141 1
a141 1
        alarm 0; 
d154 1
a154 1
just like a regular, connected anonymous pipes, except that the 
d163 1
a163 1
    if  (      system('mknod',  $path, 'p') 
d167 1
a167 1
    } 
d172 1
a172 1
on the other end.  
d176 1
a176 1
program (like a mailer, newsreader, finger program, etc.) tries to read
d178 1
a178 1
supply the the new signature.  We'll use the pipe-checking file test B<-p>
d188 1
a188 1
	    system('mknod', $FIFO, 'p') 
d190 1
a190 1
	} 
d196 1
a196 1
	sleep 2;    # to avoid dup sigs
d204 1
a204 1
argument to open().  Here's how to start something up a child process you
d207 1
a207 1
    open(SPOOLER, "| cat -v | lpr -h 2>/dev/null") 
d220 2
a221 2
    } 
    close SPOOLER || die "bad netstat: $! $?";
d253 1
a253 1
while readers of bogus commands just return a quick end of file, writers
d261 51
d328 1
a328 1
    do { 
d334 1
a334 1
	} 
d342 1
a342 1
	open (FILE, "> /safe/file") 
d346 1
a346 1
	} 
d348 1
a348 1
    } 
d352 1
a352 1
straigh-forward, but you can't use a pipe open or backticks safely.
d364 1
a364 1
	} 	  
d372 1
a372 1
    } 
d384 1
a384 1
	} 
d392 1
a392 1
    } 
d397 1
a397 1
F<modules> file mentioned below in the L<SEE ALSO> section.
d399 1
a399 1
=head2 Bidirectional Communication
d407 1
a407 1
and if you forget to use the B<-w> flag, then you'll miss out 
d434 2
a435 2
The problem with this is that Unix buffering is going to really
ruin your day.  Even though your C<Writer> filehandle is autoflushed,
d437 2
a438 2
you can't usually do anything to force it to actually give it back to you
in a similarly quick fashion.  In this case, we could, because we 
d441 1
a441 1
unless you yourself wrote the program on the other end of the 
d444 1
a444 1
A solution to this is the non-standard F<Comm.pl> library.  It uses
d455 2
a456 2
program you're using.  The F<Comm> library also has expect() 
and interact() functions.  Find the library (and hopefully its 
d458 1
a458 1
in the L<SEE ALSO> section below.
d462 1
a462 1
While not limited to Unix-derived operating systems (e.g. WinSock on PCs
d464 3
a466 3
sockets on your system, in which this section probably isn't going to do
you much good.  With sockets, you can do both virtual circuits (i.e. TCP
streams) and datagrams (i.e. UDP packets).  You may be able to do even more
d482 8
d513 1
a513 1
    while ($line = <SOCK>) {
d515 1
a515 1
    } 
d534 1
a534 1
    sub logmsg { print "$0 $$: @@_ at ", scalar localtime, "\n" } 
d538 2
d541 1
a541 1
    setsockopt(Server, SOL_SOCKET, SO_REUSEADDR, 
d556 2
a557 2
	logmsg "connection from $name [", 
		inet_ntoa($iaddr), "] 
d560 1
a560 1
	print CLIENT "Hello there, $name, it's now ", 
d562 1
a562 1
    } 
d565 1
a565 1
like most typical servers, it spawns (forks) a slave server to 
d577 1
a577 1
    sub logmsg { print "$0 $$: @@_ at ", scalar localtime, "\n" } 
d581 2
d584 1
a584 1
    setsockopt(Server, SOL_SOCKET, SO_REUSEADDR, 
d594 2
a595 1
    sub REAPER { 
a596 1
	$waitedpid = wait;
d602 3
a604 3
    for ( $waitedpid = 0; 
	  ($paddr = accept(Client,Server)) || $waitedpid; 
	  $waitedpid = 0, close Client) 
d606 1
a606 1
	next if $waitedpid;
d610 2
a611 2
	logmsg "connection from $name [", 
		inet_ntoa($iaddr), "] 
d614 1
a614 1
	spawn sub { 
d616 1
a616 1
	    exec '/usr/games/fortune' 
d620 1
a620 1
    } 
d625 1
a625 1
	unless (@@_ == 0 && $coderef && ref($coderef) eq 'CODE') { 
d635 1
a635 1
	    return; # i'm the parent
d637 1
a637 1
	# else i'm the child -- go spawn
d643 1
a643 1
    } 
d669 1
a669 1
    sub ctime { scalar localtime(shift) } 
d671 3
a673 3
    my $iaddr = gethostbyname('localhost'); 
    my $proto = getprotobyname('tcp');   
    my $port = getservbyname('time', 'tcp');  
d695 1
a695 1
That's fine for Internet-domain clients and servers, but what local
d698 1
a698 1
used internally to implement pipes.  Unlike Internet domain sockets, UNIX
d708 1
a708 1
    } 
d720 2
a721 2
    connect(SOCK, sockaddr_un($remote))		|| die "connect: $!";
    while ($line = <SOCK>) {
d723 1
a723 1
    } 
d726 1
a726 1
And here's a corresponding server.  
d749 3
a751 3
    for ( $waitedpid = 0; 
	  accept(Client,Server) || $waitedpid; 
	  $waitedpid = 0, close Client) 
d755 1
a755 1
	spawn sub { 
d759 1
a759 1
    } 
d778 320
a1097 1
=head2 UDP: Message Passing
d1106 1
a1106 1
into your message system, then you probably should just use TCP to start
d1110 1
a1110 1
above.  However, instead of checking one host at a time, the UDP version
d1121 2
a1122 2
    my ( $count, $hisiaddr, $hispaddr, $histime, 
	 $host, $iaddr, $paddr, $port, $proto, 
d1168 1
a1168 2

Here's a small example showing shared memory usage.  
d1194 1
a1194 1
Put this code in a separate file to be run in more that one process
d1218 1
a1218 1
Put this code in a separate file to be run in more that one process
d1238 4
a1241 12
=head1 WARNING

The SysV IPC code above was written long ago, and it's definitely clunky
looking.  It should at the very least be made to C<use strict> and
C<require "sys/ipc.ph">.  Better yet, perhaps someone should create an
C<IPC::SysV> module the way we have the C<Socket> module for normal
client-server communications.

(... time passes)  

Voila!  Check out the IPC::SysV modules written by Jack Shirazi.  You can
find them at a CPAN store near you.
d1248 2
a1249 2
you'll have to load in version 1.2 of the F<Socket.pm> module, which
was/is/shall-be included in I<perl5.001o>.
d1255 1
a1255 1
that you should check the return values fo these functions.  Always begin
d1270 2
a1271 2
signals and to stick with simple TCP and UDP socket operations; e.g. don't
try to pass open filedescriptors over a local UDP datagram socket if you
d1274 8
a1281 3
Because few vendors provide C libraries that are safely 
re-entrant, the prudent programmer will do little else within 
a handler beyond die() to raise an exception and longjmp(3) out.
d1286 1
a1286 1
version.
d1290 14
a1303 3
Besides the obvious functions in L<perlfunc>, you should also check out
the F<modules> file at your nearest CPAN site.  (See L<perlmod> or best
yet, the F<Perl FAQ> for a description of what CPAN is and where to get it.)
d1305 1
a1305 1
(modems) and Interprocess Communication", and contains numerous unbundled
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 1
perlipc - Perl interprocess communication (signals, fifos, pipes, safe subprocesses, sockets, and semaphores)
d17 1
a17 1
control-C or control-Z, sent to you from another process, or
d19 1
a19 1
a child process exiting, your process running out of stack space, or
d23 5
a27 5
Do as little as you possibly can in your handler; notice how all we do is
set a global variable and then raise an exception.  That's because on most
systems, libraries are not re-entrant; particularly, memory allocation and
I/O routines are not.  That means that doing nearly I<anything> in your
handler could in theory trigger a memory fault and subsequent core dump.
d33 1
a33 1
    }
d48 1
a48 1
    }
d50 1
a50 1
So to check whether signal 17 and SIGALRM were the same, do just this:
d53 1
a53 1
    if ($signo{ALRM}) {
d55 1
a55 1
    }
d59 1
a59 11
default thing.

On most UNIX platforms, the C<CHLD> (sometimes also known as C<CLD>) signal
has special behavior with respect to a value of C<'IGNORE'>.
Setting C<$SIG{CHLD}> to C<'IGNORE'> on such a platform has the effect of
not creating zombie processes when the parent process fails to C<wait()>
on its child processes (i.e. child processes are automatically reaped).
Calling C<wait()> with C<$SIG{CHLD}> set to C<'IGNORE'> usually returns
C<-1> on such platforms.

Some signals can be neither trapped nor ignored, such as
d68 1
a68 1
    }
d71 1
a71 1
    }
d74 3
a76 3
to the entire Unix process-group.  This code sends a hang-up signal to all
processes in the current process group (and sets $SIG{HUP} to IGNORE so
it doesn't kill itself):
d86 1
a86 1
or has changed its UID.
d90 1
a90 1
    }
d98 2
a99 2
to reinstall themselves.  Because Perl's signal mechanism is currently
based on the signal(3) function from the C library, you may sometimes be so
d105 2
a106 1
    sub REAPER {
a107 3
	# loathe sysV: it makes us not only reinstate
	# the handler, but place it after the wait
	$SIG{CHLD} = \&REAPER;
d114 2
a115 2
    use POSIX ":sys_wait_h";
    sub REAPER {
d117 1
d120 1
a120 2
	}
	$SIG{CHLD} = \&REAPER;  # still loathe sysV
d135 1
a135 1
    eval {
d137 1
a137 1
        alarm 10;
d139 1
a139 1
        alarm 0;
d152 1
a152 1
just like a regular, connected anonymous pipes, except that the
d161 1
a161 1
    if  (      system('mknod',  $path, 'p')
d164 2
a165 2
	die "mk{nod,fifo} $path failed";
    }
d170 1
a170 1
on the other end.
d174 1
a174 1
program (like a mailer, news reader, finger program, etc.) tries to read
d176 1
a176 1
supply the new signature.  We'll use the pipe-checking file test B<-p>
d186 1
a186 1
	    system('mknod', $FIFO, 'p')
d188 1
a188 1
	}
d194 1
a194 1
	sleep 2;    # to avoid dup signals
a196 27
=head2 WARNING

By installing Perl code to deal with signals, you're exposing yourself
to danger from two things.  First, few system library functions are
re-entrant.  If the signal interrupts while Perl is executing one function
(like malloc(3) or printf(3)), and your signal handler then calls the
same function again, you could get unpredictable behavior--often, a
core dump.  Second, Perl isn't itself re-entrant at the lowest levels.
If the signal interrupts Perl while Perl is changing its own internal
data structures, similarly unpredictable behaviour may result.

There are two things you can do, knowing this: be paranoid or be
pragmatic.  The paranoid approach is to do as little as possible in your
signal handler.  Set an existing integer variable that already has a
value, and return.  This doesn't help you if you're in a slow system call,
which will just restart.  That means you have to C<die> to longjump(3) out
of the handler.  Even this is a little cavalier for the true paranoiac,
who avoids C<die> in a handler because the system I<is> out to get you.
The pragmatic approach is to say ``I know the risks, but prefer the
convenience'', and to do anything you want in your signal handler,
prepared to clean up core dumps now and again.

To forbid signal handlers altogether would bars you from
many interesting programs, including virtually everything in this manpage,
since you could no longer even write SIGCHLD handlers.  Their dodginess
is expected to be addresses in the 5.005 release.

d202 1
a202 1
argument to open().  Here's how to start something up in a child process you
d205 1
a205 1
    open(SPOOLER, "| cat -v | lpr -h 2>/dev/null")
d218 2
a219 2
    }
    close STATUS || die "bad netstat: $! $?";
d225 1
a225 1
    % program f1 "cmd1|" - f2 "cmd2|" f3 < tmpfile
d251 1
a251 1
while readers of bogus commands return just a quick end of file, writers
d255 3
a257 63
    open(FH, "|bogus")	or die "can't fork: $!";
    print FH "bang\n"	or die "can't write: $!";
    close FH		or die "can't close: $!";

That won't blow up until the close, and it will blow up with a SIGPIPE.
To catch it, you could use this:

    $SIG{PIPE} = 'IGNORE';
    open(FH, "|bogus")  or die "can't fork: $!";
    print FH "bang\n"   or die "can't write: $!";
    close FH            or die "can't close: status=$?";

=head2 Filehandles

Both the main process and any child processes it forks share the same
STDIN, STDOUT, and STDERR filehandles.  If both processes try to access
them at once, strange things can happen.  You'll certainly want to any
stdio flush output buffers before forking.  You may also want to close
or reopen the filehandles for the child.  You can get around this by
opening your pipe with open(), but on some systems this means that the
child process cannot outlive the parent.

=head2 Background Processes

You can run a command in the background with:

    system("cmd &");

The command's STDOUT and STDERR (and possibly STDIN, depending on your
shell) will be the same as the parent's.  You won't need to catch
SIGCHLD because of the double-fork taking place (see below for more
details).

=head2 Complete Dissociation of Child from Parent

In some cases (starting server processes, for instance) you'll want to
completely dissociate the child process from the parent.  This is
often called daemonization.  A well behaved daemon will also chdir()
to the root directory (so it doesn't prevent unmounting the filesystem
containing the directory from which it was launched) and redirect its
standard file descriptors from and to F</dev/null> (so that random
output doesn't wind up on the user's terminal).

    use POSIX 'setsid';

    sub daemonize {
	chdir '/'		or die "Can't chdir to /: $!";
	open STDIN, '/dev/null' or die "Can't read /dev/null: $!";
	open STDOUT, '>/dev/null'
				or die "Can't write to /dev/null: $!";
	defined(my $pid = fork)	or die "Can't fork: $!";
	exit if $pid;
	setsid			or die "Can't start a new session: $!";
	open STDERR, '>&STDOUT'	or die "Can't dup stdout: $!";
    }

The fork() has to come before the setsid() to ensure that you aren't a
process group leader (the setsid() will fail if you are).  If your
system doesn't have the setsid() function, open F</dev/tty> and use the
C<TIOCNOTTY> ioctl() on it instead.  See L<tty(4)> for details.

Non-Unix users should check their Your_OS::Process module for other
solutions.
d275 1
a275 1
    do {
d281 1
a281 1
	}
d289 1
a289 1
	open (FILE, "> /safe/file")
d293 1
a293 1
	}
d295 1
a295 1
    }
d299 1
a299 1
straightforward, but you can't use a pipe open or backticks safely.
d311 1
a311 1
	}
d319 1
a319 1
    }
d331 1
a331 1
	}
d339 1
a339 1
    }
d344 1
a344 1
F<modules> file mentioned below in the SEE ALSO section.
d346 1
a346 1
=head2 Bidirectional Communication with Another Process
d354 1
a354 1
and if you forget to use the B<-w> flag, then you'll miss out
d366 1
a366 1
primitives like Unix pipe() and exec() calls to create all the connections.
d376 1
a376 1
    $pid = open2(*Reader, *Writer, "cat -u -n" );
d381 2
a382 2
The problem with this is that Unix buffering is really going to
ruin your day.  Even though your C<Writer> filehandle is auto-flushed,
d384 2
a385 2
you can't usually do anything to force it to give it back to you
in a similarly quick fashion.  In this case, we could, because we
d388 1
a388 1
unless you yourself wrote the program on the other end of the
d391 1
a391 1
A solution to this is the nonstandard F<Comm.pl> library.  It uses
d402 2
a403 2
program you're using.  The F<Comm> library also has expect()
and interact() functions.  Find the library (and we hope its
d405 1
a405 75
in the SEE ALSO section below.

The newer Expect.pm module from CPAN also addresses this kind of thing.
This module requires two other modules from CPAN: IO::Pty and IO::Stty.
It sets up a pseudo-terminal to interact with programs that insist on
using talking to the terminal device driver.  If your system is 
amongst those supported, this may be your best bet.

=head2 Bidirectional Communication with Yourself

If you want, you may make low-level pipe() and fork()
to stitch this together by hand.  This example only
talks to itself, but you could reopen the appropriate
handles to STDIN and STDOUT and call other processes.

    #!/usr/bin/perl -w
    # pipe1 - bidirectional communication using two pipe pairs
    #         designed for the socketpair-challenged
    use IO::Handle;	# thousands of lines just for autoflush :-(
    pipe(PARENT_RDR, CHILD_WTR);		# XXX: failure?
    pipe(CHILD_RDR,  PARENT_WTR);		# XXX: failure?
    CHILD_WTR->autoflush(1);
    PARENT_WTR->autoflush(1);

    if ($pid = fork) {
	close PARENT_RDR; close PARENT_WTR;
	print CHILD_WTR "Parent Pid $$ is sending this\n";
	chomp($line = <CHILD_RDR>);
	print "Parent Pid $$ just read this: `$line'\n";
	close CHILD_RDR; close CHILD_WTR;
	waitpid($pid,0);
    } else {
	die "cannot fork: $!" unless defined $pid;
	close CHILD_RDR; close CHILD_WTR;
	chomp($line = <PARENT_RDR>);
	print "Child Pid $$ just read this: `$line'\n";
	print PARENT_WTR "Child Pid $$ is sending this\n";
	close PARENT_RDR; close PARENT_WTR;
	exit;
    }

But you don't actually have to make two pipe calls.  If you 
have the socketpair() system call, it will do this all for you.

    #!/usr/bin/perl -w
    # pipe2 - bidirectional communication using socketpair
    #   "the best ones always go both ways"

    use Socket;
    use IO::Handle;	# thousands of lines just for autoflush :-(
    # We say AF_UNIX because although *_LOCAL is the
    # POSIX 1003.1g form of the constant, many machines
    # still don't have it.
    socketpair(CHILD, PARENT, AF_UNIX, SOCK_STREAM, PF_UNSPEC)
				or  die "socketpair: $!";

    CHILD->autoflush(1);
    PARENT->autoflush(1);

    if ($pid = fork) {
	close PARENT;
	print CHILD "Parent Pid $$ is sending this\n";
	chomp($line = <CHILD>);
	print "Parent Pid $$ just read this: `$line'\n";
	close CHILD;
	waitpid($pid,0);
    } else {
	die "cannot fork: $!" unless defined $pid;
	close CHILD;
	chomp($line = <PARENT>);
	print "Child Pid $$ just read this: `$line'\n";
	print PARENT "Child Pid $$ is sending this\n";
	close PARENT;
	exit;
    }
d409 1
a409 1
While not limited to Unix-derived operating systems (e.g., WinSock on PCs
d411 3
a413 3
sockets on your system, in which case this section probably isn't going to do
you much good.  With sockets, you can do both virtual circuits (i.e., TCP
streams) and datagrams (i.e., UDP packets).  You may be able to do even more
a428 19
If you're not writing a server/client for an existing protocol like
NNTP or SMTP, you should give some thought to how your server will
know when the client has finished talking, and vice-versa.  Most
protocols are based on one-line messages and responses (so one party
knows the other has finished when a "\n" is received) or multi-line
messages and responses that end with a period on an empty line
("\n.\n" terminates a message/response).

=head2 Internet Line Terminators

The Internet line terminator is "\015\012".  Under ASCII variants of
Unix, that could usually be written as "\r\n", but under other systems,
"\r\n" might at times be "\015\015\012", "\012\012\015", or something
completely different.  The standards specify writing "\015\012" to be
conformant (be strict in what you provide), but they also recommend
accepting a lone "\012" on input (but be lenient in what you require).
We haven't always been very good about that in the code in this manpage,
but unless you're on a Mac, you'll probably be ok.

d437 1
d452 1
a452 1
    while (defined($line = <SOCK>)) {
d454 1
a454 1
    }
d467 1
a471 1
    $EOL = "\015\012";
d473 1
a473 1
    sub logmsg { print "$0 $$: @@_ at ", scalar localtime, "\n" }
a476 2
    $port = $1 if $port =~ /(\d+)/; # untaint port number

d478 1
a478 1
    setsockopt(Server, SOL_SOCKET, SO_REUSEADDR,
d493 2
a494 2
	logmsg "connection from $name [",
		inet_ntoa($iaddr), "]
d497 3
a499 3
	print Client "Hello there, $name, it's now ",
			scalar localtime, $EOL;
    }
d502 1
a502 1
like most typical servers, it spawns (forks) a slave server to
d507 1
a511 1
    $EOL = "\015\012";
d514 1
a514 1
    sub logmsg { print "$0 $$: @@_ at ", scalar localtime, "\n" }
a517 2
    $port = $1 if $port =~ /(\d+)/; # untaint port number

d519 1
a519 1
    setsockopt(Server, SOL_SOCKET, SO_REUSEADDR,
d529 2
a530 1
    sub REAPER {
a531 1
	$SIG{CHLD} = \&REAPER;  # loathe sysV
d537 3
a539 3
    for ( $waitedpid = 0;
	  ($paddr = accept(Client,Server)) || $waitedpid;
	  $waitedpid = 0, close Client)
d541 1
a541 1
	next if $waitedpid and not $paddr;
d545 2
a546 2
	logmsg "connection from $name [",
		inet_ntoa($iaddr), "]
d549 3
a551 3
	spawn sub {
	    print "Hello there, $name, it's now ", scalar localtime, $EOL;
	    exec '/usr/games/fortune'		# XXX: `wrong' line terminators
d555 1
a555 1
    }
d560 1
a560 1
	unless (@@_ == 0 && $coderef && ref($coderef) eq 'CODE') {
d570 1
a570 1
	    return; # I'm the parent
d572 1
a572 1
	# else I'm the child -- go spawn
d578 1
a578 1
    }
d599 1
d604 1
a604 1
    sub ctime { scalar localtime(shift) }
d606 3
a608 3
    my $iaddr = gethostbyname('localhost');
    my $proto = getprotobyname('tcp');
    my $port = getservbyname('time', 'tcp');
d630 1
a630 1
That's fine for Internet-domain clients and servers, but what about local
d633 1
a633 1
used internally to implement pipes.  Unlike Internet domain sockets, Unix
d636 1
a636 1
    % ls -l /dev/log
d643 1
a643 1
    }
d648 1
d655 2
a656 2
    connect(SOCK, sockaddr_un($rendezvous))	|| die "connect: $!";
    while (defined($line = <SOCK>)) {
d658 1
a658 1
    }
d661 1
a661 3
And here's a corresponding server.  You don't have to worry about silly
network terminators here because Unix domain sockets are guaranteed
to be on the localhost, and thus everything works right.
d664 1
a669 1
    sub logmsg { print "$0 $$: @@_ at ", scalar localtime, "\n" }
a681 8
    my $waitedpid;

    sub REAPER {
	$waitedpid = wait;
	$SIG{CHLD} = \&REAPER;  # loathe sysV
	logmsg "reaped $waitedpid" . ($? ? " with exit $?" : '');
    }

d684 3
a686 4

    for ( $waitedpid = 0;
	  accept(Client,Server) || $waitedpid;
	  $waitedpid = 0, close Client)
d690 1
a690 1
	spawn sub {
d694 1
a694 1
    }
d713 1
a713 318
=head1 TCP Clients with IO::Socket

For those preferring a higher-level interface to socket programming, the
IO::Socket module provides an object-oriented approach.  IO::Socket is
included as part of the standard Perl distribution as of the 5.004
release.  If you're running an earlier version of Perl, just fetch
IO::Socket from CPAN, where you'll also find find modules providing easy
interfaces to the following systems: DNS, FTP, Ident (RFC 931), NIS and
NISPlus, NNTP, Ping, POP3, SMTP, SNMP, SSLeay, Telnet, and Time--just
to name a few.

=head2 A Simple Client

Here's a client that creates a TCP connection to the "daytime"
service at port 13 of the host name "localhost" and prints out everything
that the server there cares to provide.

    #!/usr/bin/perl -w
    use IO::Socket;
    $remote = IO::Socket::INET->new(
			Proto    => "tcp",
			PeerAddr => "localhost",
			PeerPort => "daytime(13)",
		    )
		  or die "cannot connect to daytime port at localhost";
    while ( <$remote> ) { print }

When you run this program, you should get something back that
looks like this:

    Wed May 14 08:40:46 MDT 1997

Here are what those parameters to the C<new> constructor mean:

=over

=item C<Proto>

This is which protocol to use.  In this case, the socket handle returned
will be connected to a TCP socket, because we want a stream-oriented
connection, that is, one that acts pretty much like a plain old file.
Not all sockets are this of this type.  For example, the UDP protocol
can be used to make a datagram socket, used for message-passing.

=item C<PeerAddr>

This is the name or Internet address of the remote host the server is
running on.  We could have specified a longer name like C<"www.perl.com">,
or an address like C<"204.148.40.9">.  For demonstration purposes, we've
used the special hostname C<"localhost">, which should always mean the
current machine you're running on.  The corresponding Internet address
for localhost is C<"127.1">, if you'd rather use that.

=item C<PeerPort>

This is the service name or port number we'd like to connect to.
We could have gotten away with using just C<"daytime"> on systems with a
well-configured system services file,[FOOTNOTE: The system services file
is in I</etc/services> under Unix] but just in case, we've specified the
port number (13) in parentheses.  Using just the number would also have
worked, but constant numbers make careful programmers nervous.

=back

Notice how the return value from the C<new> constructor is used as
a filehandle in the C<while> loop?  That's what's called an indirect
filehandle, a scalar variable containing a filehandle.  You can use
it the same way you would a normal filehandle.  For example, you
can read one line from it this way:

    $line = <$handle>;

all remaining lines from is this way:

    @@lines = <$handle>;

and send a line of data to it this way:

    print $handle "some data\n";

=head2 A Webget Client

Here's a simple client that takes a remote host to fetch a document
from, and then a list of documents to get from that host.  This is a
more interesting client than the previous one because it first sends
something to the server before fetching the server's response.

    #!/usr/bin/perl -w
    use IO::Socket;
    unless (@@ARGV > 1) { die "usage: $0 host document ..." }
    $host = shift(@@ARGV);
    $EOL = "\015\012";
    $BLANK = $EOL x 2;
    foreach $document ( @@ARGV ) {
	$remote = IO::Socket::INET->new( Proto     => "tcp",
					 PeerAddr  => $host,
					 PeerPort  => "http(80)",
				        );
	unless ($remote) { die "cannot connect to http daemon on $host" }
	$remote->autoflush(1);
	print $remote "GET $document HTTP/1.0" . $BLANK;
	while ( <$remote> ) { print }
	close $remote;
    }

The web server handing the "http" service, which is assumed to be at
its standard port, number 80.  If your the web server you're trying to
connect to is at a different port (like 1080 or 8080), you should specify
as the named-parameter pair, C<PeerPort =E<gt> 8080>.  The C<autoflush>
method is used on the socket because otherwise the system would buffer
up the output we sent it.  (If you're on a Mac, you'll also need to
change every C<"\n"> in your code that sends data over the network to
be a C<"\015\012"> instead.)

Connecting to the server is only the first part of the process: once you
have the connection, you have to use the server's language.  Each server
on the network has its own little command language that it expects as
input.  The string that we send to the server starting with "GET" is in
HTTP syntax.  In this case, we simply request each specified document.
Yes, we really are making a new connection for each document, even though
it's the same host.  That's the way you always used to have to speak HTTP.
Recent versions of web browsers may request that the remote server leave
the connection open a little while, but the server doesn't have to honor
such a request.

Here's an example of running that program, which we'll call I<webget>:

    % webget www.perl.com /guanaco.html
    HTTP/1.1 404 File Not Found
    Date: Thu, 08 May 1997 18:02:32 GMT
    Server: Apache/1.2b6
    Connection: close
    Content-type: text/html

    <HEAD><TITLE>404 File Not Found</TITLE></HEAD>
    <BODY><H1>File Not Found</H1>
    The requested URL /guanaco.html was not found on this server.<P>
    </BODY>

Ok, so that's not very interesting, because it didn't find that
particular document.  But a long response wouldn't have fit on this page.

For a more fully-featured version of this program, you should look to
the I<lwp-request> program included with the LWP modules from CPAN.

=head2 Interactive Client with IO::Socket

Well, that's all fine if you want to send one command and get one answer,
but what about setting up something fully interactive, somewhat like
the way I<telnet> works?  That way you can type a line, get the answer,
type a line, get the answer, etc.

This client is more complicated than the two we've done so far, but if
you're on a system that supports the powerful C<fork> call, the solution
isn't that rough.  Once you've made the connection to whatever service
you'd like to chat with, call C<fork> to clone your process.  Each of
these two identical process has a very simple job to do: the parent
copies everything from the socket to standard output, while the child
simultaneously copies everything from standard input to the socket.
To accomplish the same thing using just one process would be I<much>
harder, because it's easier to code two processes to do one thing than it
is to code one process to do two things.  (This keep-it-simple principle
a cornerstones of the Unix philosophy, and good software engineering as
well, which is probably why it's spread to other systems.)

Here's the code:

    #!/usr/bin/perl -w
    use strict;
    use IO::Socket;
    my ($host, $port, $kidpid, $handle, $line);

    unless (@@ARGV == 2) { die "usage: $0 host port" }
    ($host, $port) = @@ARGV;

    # create a tcp connection to the specified host and port
    $handle = IO::Socket::INET->new(Proto     => "tcp",
				    PeerAddr  => $host,
				    PeerPort  => $port)
	   or die "can't connect to port $port on $host: $!";

    $handle->autoflush(1);		# so output gets there right away
    print STDERR "[Connected to $host:$port]\n";

    # split the program into two processes, identical twins
    die "can't fork: $!" unless defined($kidpid = fork());

    # the if{} block runs only in the parent process
    if ($kidpid) {
	# copy the socket to standard output
	while (defined ($line = <$handle>)) {
	    print STDOUT $line;
	}
	kill("TERM", $kidpid);  		# send SIGTERM to child
    }
    # the else{} block runs only in the child process
    else {
	# copy standard input to the socket
	while (defined ($line = <STDIN>)) {
	    print $handle $line;
	}
    }

The C<kill> function in the parent's C<if> block is there to send a
signal to our child process (current running in the C<else> block)
as soon as the remote server has closed its end of the connection.

If the remote server sends data a byte at time, and you need that
data immediately without waiting for a newline (which might not happen),
you may wish to replace the C<while> loop in the parent with the
following:

    my $byte;
    while (sysread($handle, $byte, 1) == 1) {
	print STDOUT $byte;
    }

Making a system call for each byte you want to read is not very efficient
(to put it mildly) but is the simplest to explain and works reasonably
well.

=head1 TCP Servers with IO::Socket

As always, setting up a server is little bit more involved than running a client.
The model is that the server creates a special kind of socket that
does nothing but listen on a particular port for incoming connections.
It does this by calling the C<IO::Socket::INET-E<gt>new()> method with
slightly different arguments than the client did.

=over

=item Proto

This is which protocol to use.  Like our clients, we'll
still specify C<"tcp"> here.

=item LocalPort

We specify a local
port in the C<LocalPort> argument, which we didn't do for the client.
This is service name or port number for which you want to be the
server. (Under Unix, ports under 1024 are restricted to the
superuser.)  In our sample, we'll use port 9000, but you can use
any port that's not currently in use on your system.  If you try
to use one already in used, you'll get an "Address already in use"
message. Under Unix, the C<netstat -a> command will show
which services current have servers.

=item Listen

The C<Listen> parameter is set to the maximum number of
pending connections we can accept until we turn away incoming clients.
Think of it as a call-waiting queue for your telephone.
The low-level Socket module has a special symbol for the system maximum, which
is SOMAXCONN.

=item Reuse

The C<Reuse> parameter is needed so that we restart our server
manually without waiting a few minutes to allow system buffers to
clear out.

=back

Once the generic server socket has been created using the parameters
listed above, the server then waits for a new client to connect
to it.  The server blocks in the C<accept> method, which eventually an
bidirectional connection to the remote client.  (Make sure to autoflush
this handle to circumvent buffering.)

To add to user-friendliness, our server prompts the user for commands.
Most servers don't do this.  Because of the prompt without a newline,
you'll have to use the C<sysread> variant of the interactive client above.

This server accepts one of five different commands, sending output
back to the client.  Note that unlike most network servers, this one
only handles one incoming client at a time.  Multithreaded servers are
covered in Chapter 6 of the Camel.

Here's the code.  We'll

 #!/usr/bin/perl -w
 use IO::Socket;
 use Net::hostent;		# for OO version of gethostbyaddr

 $PORT = 9000;			# pick something not in use

 $server = IO::Socket::INET->new( Proto     => 'tcp',
                                  LocalPort => $PORT,
                                  Listen    => SOMAXCONN,
                                  Reuse     => 1);

 die "can't setup server" unless $server;
 print "[Server $0 accepting clients]\n";

 while ($client = $server->accept()) {
   $client->autoflush(1);
   print $client "Welcome to $0; type help for command list.\n";
   $hostinfo = gethostbyaddr($client->peeraddr);
   printf "[Connect from %s]\n", $hostinfo->name || $client->peerhost;
   print $client "Command? ";
   while ( <$client>) {
     next unless /\S/;	     # blank line
     if    (/quit|exit/i)    { last;                                     }
     elsif (/date|time/i)    { printf $client "%s\n", scalar localtime;  }
     elsif (/who/i )         { print  $client `who 2>&1`;                }
     elsif (/cookie/i )      { print  $client `/usr/games/fortune 2>&1`; }
     elsif (/motd/i )        { print  $client `cat /etc/motd 2>&1`;      }
     else {
       print $client "Commands: quit date who cookie motd\n";
     }
   } continue {
      print $client "Command? ";
   }
   close $client;
 }

=head1 UDP: Message Passing
d722 1
a722 1
into your message system, then you probably should use just TCP to start
d726 1
a726 1
earlier.  However, instead of checking one host at a time, the UDP version
d733 1
d737 2
a738 2
    my ( $count, $hisiaddr, $hispaddr, $histime,
	 $host, $iaddr, $paddr, $port, $proto,
a783 1
Here's a small example showing shared memory usage.
d785 1
a785 1
    use IPC::SysV qw(IPC_PRIVATE IPC_RMID S_IRWXU S_IRWXG S_IRWXO);
d787 2
d790 2
a791 2
    $key = shmget(IPC_PRIVATE, $size, S_IRWXU|S_IRWXG|S_IRWXO) || die "$!";
    print "shm key $key\n";
d794 4
a797 9
    shmwrite($key, $message, 0, 60) || die "$!";
    print "wrote: '$message'\n";
    shmread($key, $buff, 0, 60) || die "$!";
    print "read : '$buff'\n";

    # the buffer of shmread is zero-character end-padded.
    substr($buff, index($buff, "\0")) = '';
    print "un" unless $buff eq $message;
    print "swell\n";
d799 2
a800 2
    print "deleting shm $key\n";
    shmctl($key, IPC_RMID, 0) || die "$!";
a803 2
    use IPC::SysV qw(IPC_CREAT);

d805 5
a809 2
    $key = semget($IPC_KEY, 10, 0666 | IPC_CREAT ) || die "$!";
    print "shm key $key\n";
d811 1
a811 1
Put this code in a separate file to be run in more than one process.
d835 1
a835 1
Put this code in a separate file to be run in more than one process.
d855 12
a866 3
The SysV IPC code above was written long ago, and it's definitely
clunky looking.  For a more modern look, see the IPC::SysV module
which is included with Perl starting from Perl 5.005.
d870 13
a882 7
Most of these routines quietly but politely return C<undef> when they
fail instead of causing your program to die right then and there due to
an uncaught exception.  (Actually, some of the new I<Socket> conversion
functions  croak() on bad arguments.)  It is therefore essential to
check return values from these functions.  Always begin your socket
programs this way for optimal success, and don't forget to add B<-T>
taint checking flag to the #! line for servers:
d884 2
a885 1
    #!/usr/bin/perl -Tw
d895 2
a896 2
signals and to stick with simple TCP and UDP socket operations; e.g., don't
try to pass open file descriptors over a local UDP datagram socket if you
d899 3
a901 8
As mentioned in the signals section, because few vendors provide C
libraries that are safely re-entrant, the prudent programmer will do
little else within a handler beyond setting a numeric variable that
already exists; or, if locked into a slow (restarting) system call,
using die() to raise an exception and longjmp(3) out.  In fact, even
these may in some cases cause a core dump.  It's probably best to avoid
signals except where they are absolutely inevitable.  This 
will be addressed in a future release of Perl.
d906 1
a906 1
version and suggestions from the Perl Porters.
d910 3
a912 14
There's a lot more to networking than this, but this should get you
started.

For intrepid programmers, the indispensable textbook is I<Unix Network
Programming> by W. Richard Stevens (published by Addison-Wesley).  Note
that most books on networking address networking from the perspective of
a C programmer; translation to Perl is left as an exercise for the reader.

The IO::Socket(3) manpage describes the object library, and the Socket(3)
manpage describes the low-level interface to sockets.  Besides the obvious
functions in L<perlfunc>, you should also check out the F<modules> file
at your nearest CPAN site.  (See L<perlmodlib> or best yet, the F<Perl
FAQ> for a description of what CPAN is and where to get it.)

d914 1
a914 1
(modems), and Interprocess Communication", and contains numerous unbundled
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d61 1
a61 1
On most Unix platforms, the C<CHLD> (sometimes also known as C<CLD>) signal
d129 1
a129 1
        while (($child = waitpid(-1,WNOHANG)) > 0) {
a154 4
If the operation being timed out is system() or qx(), this technique
is liable to generate zombies.    If this matters to you, you'll
need to do your own fork() and exec(), and kill the errant child process.

d279 1
a279 1
whole thing into memory at once.  It also gives you finer control of the
d310 2
a311 1
them at once, strange things can happen.  You may also want to close
d453 2
a454 2
and if you forget to use the C<use warnings> pragma or the B<-w> flag,
then you'll miss out entirely on the diagnostic message:
d476 1
d1025 1
a1025 1
as the named-parameter pair, C<< PeerPort => 8080 >>.  The C<autoflush>
d1143 1
a1143 1
It does this by calling the C<< IO::Socket::INET->new() >> method with
d1162 1
a1162 1
message.  Under Unix, the C<netstat -a> command will show
d1306 1
a1306 1
    use IPC::SysV qw(IPC_PRIVATE IPC_RMID S_IRWXU);
d1309 2
a1310 2
    $id = shmget(IPC_PRIVATE, $size, S_IRWXU) || die "$!";
    print "shm key $id\n";
d1313 1
a1313 1
    shmwrite($id, $message, 0, 60) || die "$!";
d1315 1
a1315 1
    shmread($id, $buff, 0, 60) || die "$!";
d1323 2
a1324 2
    print "deleting shm $id\n";
    shmctl($id, IPC_RMID, 0) || die "$!";
d1331 2
a1332 2
    $id = semget($IPC_KEY, 10, 0666 | IPC_CREAT ) || die "$!";
    print "shm key $id\n";
d1340 2
a1341 2
    $id = semget($IPC_KEY,  0 , 0 );
    die if !defined($id);
d1349 1
a1349 1
    $opstring1 = pack("s!s!s!", $semnum, $semop, $semflag);
d1353 1
a1353 1
    $opstring2 = pack("s!s!s!", $semnum, $semop,  $semflag);
d1356 1
a1356 1
    semop($id,$opstring) || die "$!";
d1366 2
a1367 2
    $id = semget($IPC_KEY, 0, 0);
    die if !defined($id);
d1374 1
a1374 1
    $opstring = pack("s!s!s!", $semnum, $semop, $semflag);
d1376 1
a1376 1
    semop($id,$opstring) || die "$!";
a1380 31

A small example demonstrating SysV message queues:

    use IPC::SysV qw(IPC_PRIVATE IPC_RMID IPC_CREAT S_IRWXU);

    my $id = msgget(IPC_PRIVATE, IPC_CREAT | S_IRWXU);

    my $sent = "message";
    my $type = 1234;
    my $rcvd;
    my $type_rcvd;

    if (defined $id) {
        if (msgsnd($id, pack("l! a*", $type_sent, $sent), 0)) {
            if (msgrcv($id, $rcvd, 60, 0, 0)) {
                ($type_rcvd, $rcvd) = unpack("l! a*", $rcvd);
                if ($rcvd eq $sent) {
                    print "okay\n";
                } else {
                    print "not okay\n";
                }
            } else {
                die "# msgrcv failed\n";
            }
        } else {
            die "# msgsnd failed\n";
        }
        msgctl($id, IPC_RMID, 0) || die "# msgctl failed: $!\n";
    } else {
        die "# msgget failed\n";
    }
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d237 2
a238 1
since you could no longer even write SIGCHLD handlers.  
d664 1
a664 1
    my $EOL = "\015\012";
d670 1
a670 2

    ($port) = $port =~ /^(\d+)$/                        or die "invalid port";
d706 1
a706 1
    my $EOL = "\015\012";
d713 1
a713 2

    ($port) = $port =~ /^(\d+)$/                        or die "invalid port";
a746 1
	    $|=1;
d838 1
a838 1
	die "something's wicked with the log system";
a865 1
    sub spawn;  # forward declaration
a901 23
    sub spawn {
	my $coderef = shift;

	unless (@@_ == 0 && $coderef && ref($coderef) eq 'CODE') {
	    confess "usage: spawn CODEREF";
	}

	my $pid;
	if (!defined($pid = fork)) {
	    logmsg "cannot fork: $!";
	    return;
	} elsif ($pid) {
	    logmsg "begat $pid";
	    return; # I'm the parent
	}
	# else I'm the child -- go spawn

	open(STDIN,  "<&Client")   || die "can't dup client to stdin";
	open(STDOUT, ">&Client")   || die "can't dup client to stdout";
	## open(STDERR, ">&STDOUT") || die "can't dup stdout to stderr";
	exit &$coderef();
    }

d925 1
a925 1
IO::Socket from CPAN, where you'll also find modules providing easy
d953 1
a953 1
=over 4
d1025 1
a1025 1
its standard port, number 80.  If the web server you're trying to
d1148 1
a1148 1
=over 4
a1247 5
Note that UDP datagrams are I<not> a bytestream and should not be treated
as such. This makes using I/O mechanisms with internal buffering
like stdio (i.e. print() and friends) especially cumbersome. Use syswrite(),
or better send(), like in the example below.

a1296 5

Note that this example does not include any retries and may consequently
fail to contact a reachable host. The most prominent reason for this
is congestion of the queues on the sending host if the number of
list of hosts to contact is sufficiently large.
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d13 15
a27 10
Perl uses a simple signal handling model: the %SIG hash contains names
or references of user-installed signal handlers.  These handlers will
be called with an argument which is the name of the signal that
triggered it.  A signal may be generated intentionally from a
particular keyboard sequence like control-C or control-Z, sent to you
from another process, or triggered automatically by the kernel when
special events transpire, like a child process exiting, your process
running out of stack space, or hitting file size limit.

For example, to trap an interrupt signal, set up a handler like this:
a36 8
Prior to Perl 5.7.3 it was necessary to do as little as you possibly
could in your handler; notice how all we do is set a global variable
and then raise an exception.  That's because on most systems,
libraries are not re-entrant; particularly, memory allocation and I/O
routines are not.  That meant that doing nearly I<anything> in your
handler could in theory trigger a memory fault and subsequent core
dump - see L<Deferred Signals> below.

d124 1
a124 1
or better still:
a128 4
	# If a second child dies while in the signal handler caused by the
	# first death, we won't get another signal. So must loop here else
	# we will leave the unreaped child as a zombie. And the next time
	# two children die we get another zombie. And so on.
a163 62
=head2 Handling the SIGHUP Signal in Daemons

A process that usually starts when the system boots and shuts down
when the system is shut down is called a daemon (Disk And Execution
MONitor). If a daemon process has a configuration file which is
modified after the process has been started, there should be a way to
tell that process to re-read its configuration file, without stopping
the process. Many daemons provide this mechanism using the C<SIGHUP>
signal handler. When you want to tell the daemon to re-read the file
you simply send it the C<SIGHUP> signal.

Not all platforms automatically reinstall their (native) signal
handlers after a signal delivery.  This means that the handler works
only the first time the signal is sent. The solution to this problem
is to use C<POSIX> signal handlers if available, their behaviour
is well-defined.

The following example implements a simple daemon, which restarts
itself every time the C<SIGHUP> signal is received. The actual code is
located in the subroutine C<code()>, which simply prints some debug
info to show that it works and should be replaced with the real code.

  #!/usr/bin/perl -w

  use POSIX ();
  use FindBin ();
  use File::Basename ();
  use File::Spec::Functions;

  $|=1;

  # make the daemon cross-platform, so exec always calls the script
  # itself with the right path, no matter how the script was invoked.
  my $script = File::Basename::basename($0);
  my $SELF = catfile $FindBin::Bin, $script;

  # POSIX unmasks the sigprocmask properly
  my $sigset = POSIX::SigSet->new();
  my $action = POSIX::SigAction->new('sigHUP_handler',
                                     $sigset,
                                     &POSIX::SA_NODEFER);
  POSIX::sigaction(&POSIX::SIGHUP, $action);

  sub sigHUP_handler {
      print "got SIGHUP\n";
      exec($SELF, @@ARGV) or die "Couldn't restart: $!\n";
  }

  code();

  sub code {
      print "PID: $$\n";
      print "ARGV: @@ARGV\n";
      my $c = 0;
      while (++$c) {
          sleep 2;
          print "$c\n";
      }
  }
  __END__


d213 1
a213 1
=head2 Deferred Signals
d215 8
a222 9
In Perls before Perl 5.7.3 by installing Perl code to deal with
signals, you were exposing yourself to danger from two things.  First,
few system library functions are re-entrant.  If the signal interrupts
while Perl is executing one function (like malloc(3) or printf(3)),
and your signal handler then calls the same function again, you could
get unpredictable behavior--often, a core dump.  Second, Perl isn't
itself re-entrant at the lowest levels.  If the signal interrupts Perl
while Perl is changing its own internal data structures, similarly
unpredictable behaviour may result.
d224 2
a225 2
There were two things you could do, knowing this: be paranoid or be
pragmatic.  The paranoid approach was to do as little as possible in your
d231 7
a237 15
The pragmatic approach was to say ``I know the risks, but prefer the
convenience'', and to do anything you wanted in your signal handler,
and be prepared to clean up core dumps now and again.

In Perl 5.7.3 and later to avoid these problems signals are
"deferred"-- that is when the signal is delivered to the process by
the system (to the C code that implements Perl) a flag is set, and the
handler returns immediately. Then at strategic "safe" points in the
Perl interpreter (e.g. when it is about to execute a new opcode) the
flags are checked and the Perl level handler from %SIG is
executed. The "deferred" scheme allows much more flexibility in the
coding of signal handler as we know Perl interpreter is in a safe
state, and that we are not in a system library function when the
handler is called.  However the implementation does differ from
previous Perls in the following ways:
a238 53
=over 4

=item Long running opcodes

As Perl interpreter only looks at the signal flags when it about to
execute a new opcode if a signal arrives during a long running opcode
(e.g. a regular expression operation on a very large string) then
signal will not be seen until operation completes.

=item Interrupting IO

When a signal is delivered (e.g. INT control-C) the operating system
breaks into IO operations like C<read> (used to implement Perls
E<lt>E<gt> operator). On older Perls the handler was called
immediately (and as C<read> is not "unsafe" this worked well). With
the "deferred" scheme the handler is not called immediately, and if
Perl is using system's C<stdio> library that library may re-start the
C<read> without returning to Perl and giving it a chance to call the
%SIG handler. If this happens on your system the solution is to use
C<:perlio> layer to do IO - at least on those handles which you want
to be able to break into with signals. (The C<:perlio> layer checks
the signal flags and calls %SIG handlers before resuming IO operation.)

Note that the default in Perl 5.7.3 and later is to automatically use
the C<:perlio> layer.

=item Signals as "faults"

Certain signals e.g. SEGV, ILL, BUS are generated as a result of
virtual memory or other "faults". These are normally fatal and there
is little a Perl-level handler can do with them. (In particular the
old signal scheme was particularly unsafe in such cases.)  However if
a %SIG handler is set the new scheme simply sets a flag and returns as
described above. This may cause the operating system to try the
offending machine instruction again and - as nothing has changed - it
will generate the signal again. The result of this is a rather odd
"loop". In future Perl's signal mechanism may be changed to avoid this
- perhaps by simply disallowing %SIG handlers on signals of that
type. Until then the work-round is not to set a %SIG handler on those
signals. (Which signals they are is operating system dependant.)

=item Signals triggered by operating system state

On some operating systems certain signal handlers are supposed to "do
something" before returning. One example can be CHLD or CLD which
indicates a child process has completed. On some operating systems the
signal handler is expected to C<wait> for the completed child
process. On such systems the deferred signal scheme will not work for
those signals (it does not do the C<wait>). Again the failure will
look like a loop as the operating system will re-issue the signal as
there are un-waited-for completed child processes.

=back
d242 4
a245 4
Perl's basic open() statement can also be used for unidirectional
interprocess communication by either appending or prepending a pipe
symbol to the second argument to open().  Here's how to start
something up in a child process you intend to write to:
d373 1
a373 1
    use English '-no_match_vars';
a441 10
Since Perl 5.8.0, you can also use the list form of C<open> for pipes :
the syntax

    open KID_PS, "-|", "ps", "aux" or die $!;

forks the ps(1) command (without spawning a shell, as there are more than
three arguments to open()), and reads its standard output via the
C<KID_PS> filehandle.  The corresponding syntax to read from command
pipes (with C<"|-"> in place of C<"-|">) is also implemented.

d510 1
a510 1
using talking to the terminal device driver.  If your system is
d546 1
a546 1
But you don't actually have to make two pipe calls.  If you
a726 1
    use POSIX ":sys_wait_h";
d728 1
a728 4
	my $child;
        while (($waitedpid = waitpid(-1,WNOHANG)) > 0) {
	    logmsg "reaped $waitedpid" . ($? ? " with exit $?" : '');
	}
d730 1
a883 1
    use POSIX ":sys_wait_h";
d885 1
a885 4
	my $child;
        while (($waitedpid = waitpid(-1,WNOHANG)) > 0) {
	    logmsg "reaped $waitedpid" . ($? ? " with exit $?" : '');
	}
d887 1
d1211 2
a1212 2
to it.  The server blocks in the C<accept> method, which eventually accepts a
bidirectional connection from the remote client.  (Make sure to autoflush
d1481 1
a1481 1
signals except where they are absolutely inevitable.  This
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d38 1
a38 1
dump - see L</Deferred Signals (Safe Signals)> below.
d98 1
a98 1
actually affect a child process, but instead checks whether it's alive
a104 9
When directed at a process whose UID is not identical to that
of the sending process, signal number zero may fail because
you lack permission to send the signal, even though the process is alive.
You may be able to determine the cause of failure using C<%!>.

    unless (kill 0 => $pid or $!{EPERM}) {
	warn "$pid looks dead";
    }

d282 1
a282 1
=head2 Deferred Signals (Safe Signals)
a342 26
Note that some networking library functions like gethostbyname() are
known to have their own implementations of timeouts which may conflict
with your timeouts.  If you are having problems with such functions,
you can try using the POSIX sigaction() function, which bypasses the
Perl safe signals (note that this means subjecting yourself to
possible memory corruption, as described above).  Instead of setting
C<$SIG{ALRM}> try something like the following:

    use POSIX;
    sigaction SIGALRM, new POSIX::SigAction sub { die "alarm\n" }
        or die "Error setting SIGALRM handler: $!\n";

=item Restartable system calls

On systems that supported it, older versions of Perl used the
SA_RESTART flag when installing %SIG handlers.  This meant that
restartable system calls would continue rather than returning when
a signal arrived.  In order to deliver deferred signals promptly,
Perl 5.7.3 and later do I<not> use SA_RESTART.  Consequently, 
restartable system calls can fail (with $! set to C<EINTR>) in places
where they previously would have succeeded.

Note that the default C<:perlio> layer will retry C<read>, C<write>
and C<close> as described above and that interrupted C<wait> and 
C<waitpid> calls will always be retried.

a370 4
If you want the old signal behaviour back regardless of possible
memory corruption, set the environment variable C<PERL_SIGNALS> to
C<"unsafe"> (a new feature since Perl 5.8.1).

d558 1
a558 1
    $SIG{PIPE} = sub { die "whoops, $program pipe broke" };
d1391 1
a1391 1
   printf "[Connect from %s]\n", $hostinfo ? $hostinfo->name : $client->peerhost;
d1641 4
a1644 5
For intrepid programmers, the indispensable textbook is I<Unix
Network Programming, 2nd Edition, Volume 1> by W. Richard Stevens
(published by Prentice-Hall).  Note that most books on networking
address the subject from the perspective of a C programmer; translation
to Perl is left as an exercise for the reader.
@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@d1033 1
a1033 1
    $rendezvous = shift || 'catsock';
d1054 1
a1054 1
    my $NAME = 'catsock';
d1613 1
a1613 1
    my $type_sent = 1234;
d1660 9
@


1.1.1.8
log
@perl 5.8.6 from CPAN
@
text
@d358 1
a358 1
C<$SIG{ALRM}>:
d360 3
a362 8
   local $SIG{ALRM} = sub { die "alarm" };

try something like the following:

    use POSIX qw(SIGALRM);
    POSIX::sigaction(SIGALRM,
                     POSIX::SigAction->new(sub { die "alarm" }))
          or die "Error setting SIGALRM handler: $!\n";
d391 1
a391 1
signals. (Which signals they are is operating system dependent.)
@


1.1.1.9
log
@perl 5.8.8 import
@
text
@d249 1
a249 6
To create a named pipe, use the C<POSIX::mkfifo()> function.

    use POSIX qw(mkfifo);
    mkfifo($path, 0700) or die "mkfifo $path failed: $!";

You can also use the Unix command mknod(1) or on some
d275 1
d280 2
a281 3
	    require POSIX;
	    POSIX::mkfifo($FIFO, 0700)
		or die "can't mkfifo $FIFO: $!";
d310 2
a311 2
The pragmatic approach was to say "I know the risks, but prefer the
convenience", and to do anything you wanted in your signal handler,
d624 1
a624 1
C<KID_PS> filehandle.  The corresponding syntax to write to command
d1010 1
a1010 1
	my $histime = unpack("N", $rtime) - $SECS_of_70_YEARS;
d1514 1
a1514 1
	$histime = unpack("N", $rtime) - $SECS_of_70_YEARS;
@


1.1.1.10
log
@import perl 5.10.0 from CPAN
@
text
@d122 1
a122 1
unfortunate as to run on systems where that function is "broken", that
d312 1
a312 1
which will just restart.  That means you have to C<die> to longjmp(3) out
d333 1
a333 20
=item Long-running opcodes

As the Perl interpreter only looks at the signal flags when it is about
to execute a new opcode, a signal that arrives during a long-running
opcode (e.g. a regular expression operation on a very large string) will
not be seen until the current opcode completes.

N.B. If a signal of any given type fires multiple times during an opcode 
(such as from a fine-grained timer), the handler for that signal will
only be called once after the opcode completes, and all the other
instances will be discarded.  Furthermore, if your system's signal queue
gets flooded to the point that there are signals that have been raised
but not yet caught (and thus not deferred) at the time an opcode
completes, those signals may well be caught and deferred during
subsequent opcodes, with sometimes surprising results.  For example, you
may see alarms delivered even after calling C<alarm(0)> as the latter
stops the raising of alarms but does not cancel the delivery of alarms
raised but not yet caught.  Do not depend on the behaviors described in
this paragraph as they are side effects of the current implementation and
may change in future versions of Perl.
d335 4
a373 4
Another way to disable the safe signal behavior locally is to use
the C<Perl::Unsafe::Signals> module from CPAN (which will affect
all signals).

d390 12
a401 4
Certain signals, e.g. SEGV, ILL, and BUS, are generated as a result of
virtual memory or other "faults". These are normally fatal and there is
little a Perl-level handler can do with them, so Perl now delivers them
immediately rather than attempting to defer them.
d535 1
a535 1
C<TIOCNOTTY> ioctl() on it instead.  See tty(4) for details.
a917 2
    use Errno;

d919 5
a923 5
        local $!;   # don't let waitpid() overwrite current error
        while ((my $pid = waitpid(-1,WNOHANG)) > 0 && WIFEXITED($?)) {
            logmsg "reaped $waitedpid" . ($? ? " with exit $?" : '');
        }
        $SIG{CHLD} = \&REAPER;  # loathe sysV
d928 19
a946 20
    while(1) {
        $paddr = accept(Client, Server) || do {
            # try again if accept() returned because a signal was received
            next if $!{EINTR};
            die "accept: $!";
        };
        my ($port, $iaddr) = sockaddr_in($paddr);
        my $name = gethostbyaddr($iaddr, AF_INET);

        logmsg "connection from $name [",
               inet_ntoa($iaddr),
               "] at port $port";

        spawn sub {
            $|=1;
            print "Hello there, $name, it's now ", scalar localtime, $EOL;
            exec '/usr/games/fortune'       # XXX: `wrong' line terminators
                or confess "can't exec fortune: $!";
        };
        close Client;
d950 21
a970 1
        my $coderef = shift;
d972 7
a978 48
        unless (@@_ == 0 && $coderef && ref($coderef) eq 'CODE') {
            confess "usage: spawn CODEREF";
        }

        my $pid;
        if (! defined($pid = fork)) {
            logmsg "cannot fork: $!";
            return;
        } 
        elsif ($pid) {
            logmsg "begat $pid";
            return; # I'm the parent
        }
        # else I'm the child -- go spawn

        open(STDIN,  "<&Client")   || die "can't dup client to stdin";
        open(STDOUT, ">&Client")   || die "can't dup client to stdout";
        ## open(STDERR, ">&STDOUT") || die "can't dup stdout to stderr";
        exit &$coderef();
    }

This server takes the trouble to clone off a child version via fork()
for each incoming request.  That way it can handle many requests at
once, which you might not always want.  Even if you don't fork(), the
listen() will allow that many pending connections.  Forking servers
have to be particularly careful about cleaning up their dead children
(called "zombies" in Unix parlance), because otherwise you'll quickly
fill up your process table.  The REAPER subroutine is used here to
call waitpid() for any child processes that have finished, thereby
ensuring that they terminate cleanly and don't join the ranks of the
living dead.

Within the while loop we call accept() and check to see if it returns
a false value.  This would normally indicate a system error that needs
to be reported.  However the introduction of safe signals (see
L</Deferred Signals (Safe Signals)> above) in Perl 5.7.3 means that
accept() may also be interrupted when the process receives a signal.
This typically happens when one of the forked sub-processes exits and
notifies the parent process with a CHLD signal.  

If accept() is interrupted by a signal then $! will be set to EINTR.
If this happens then we can safely continue to the next iteration of
the loop and another call to accept().  It is important that your
signal handling code doesn't modify the value of $! or this test will
most likely fail.  In the REAPER subroutine we create a local version
of $! before calling waitpid().  When waitpid() sets $! to ECHILD (as
it inevitably does when it has no more children waiting), it will
update the local copy leaving the original unchanged.
d1540 1
a1540 1
    use IPC::SysV qw(IPC_PRIVATE IPC_RMID S_IRUSR S_IWUSR);
d1543 1
a1543 1
    $id = shmget(IPC_PRIVATE, $size, S_IRUSR|S_IWUSR) || die "$!";
d1618 1
a1618 1
    use IPC::SysV qw(IPC_PRIVATE IPC_RMID IPC_CREAT S_IRUSR S_IWUSR);
d1620 1
a1620 1
    my $id = msgget(IPC_PRIVATE, IPC_CREAT | S_IRUSR | S_IWUSR);
@


1.1.1.11
log
@import perl 5.10.1
@
text
@d129 1
a129 1
	# loathe SysV: it makes us not only reinstate
d148 1
a148 1
	$SIG{CHLD} = \&REAPER;  # still loathe SysV
d539 1
a539 1
	die "Can't start a new session: $!" if setsid == -1;
d584 1
a584 1
	    print FILE; # child's STDIN is parent's KID_TO_WRITE
a632 62
It is very easy to dead-lock a process using this form of open(), or
indeed any use of pipe() and multiple sub-processes.  The above
example is 'safe' because it is simple and calls exec().  See
L</"Avoiding Pipe Deadlocks"> for general safety principles, but there
are extra gotchas with Safe Pipe Opens.

In particular, if you opened the pipe using C<open FH, "|-">, then you
cannot simply use close() in the parent process to close an unwanted
writer.  Consider this code:

    $pid = open WRITER, "|-";
    defined $pid or die "fork failed; $!";
    if ($pid) {
        if (my $sub_pid = fork()) {
            close WRITER;
            # do something else...
        }
        else {
            # write to WRITER...
	    exit;
        }
    }
    else {
        # do something with STDIN...
	exit;
    }

In the above, the true parent does not want to write to the WRITER
filehandle, so it closes it.  However, because WRITER was opened using
C<open FH, "|-">, it has a special behaviour: closing it will call
waitpid() (see L<perlfunc/waitpid>), which waits for the sub-process
to exit.  If the child process ends up waiting for something happening
in the section marked "do something else", then you have a deadlock.

This can also be a problem with intermediate sub-processes in more
complicated code, which will call waitpid() on all open filehandles
during global destruction; in no predictable order.

To solve this, you must manually use pipe(), fork(), and the form of
open() which sets one file descriptor to another, as below:

    pipe(READER, WRITER);
    $pid = fork();
    defined $pid or die "fork failed; $!";
    if ($pid) {
	close READER;
        if (my $sub_pid = fork()) {
            close WRITER;
        }
        else {
            # write to WRITER...
	    exit;
        }
        # write to WRITER...
    }
    else {
        open STDIN, "<&READER";
        close WRITER;
        # do something...
        exit;
    }

a647 24
=head2 Avoiding Pipe Deadlocks

In general, if you have more than one sub-process, you need to be very
careful that any process which does not need the writer half of any
pipe you create for inter-process communication does not have it open.

The reason for this is that any child process which is reading from
the pipe and expecting an EOF will never receive it, and therefore
never exit.  A single process closing a pipe is not enough to close it;
the last process with the pipe open must close it for it to read EOF.

There are some features built-in to unix to help prevent this most of
the time.  For instance, filehandles have a 'close on exec' flag (set
I<en masse> with Perl using the C<$^F> L<perlvar>), so that any
filehandles which you didn't explicitly route to the STDIN, STDOUT or
STDERR of a child I<program> will automatically be closed for you.

So, always explicitly and immediately call close() on the writable end
of any pipe, unless that process is actually writing to it.  If you
don't explicitly call close() then be warned Perl will still close()
all the filehandles during global destruction.  As warned above, if
those filehandles were opened with Safe Pipe Open, they will also call
waitpid() and you might again deadlock.

d936 1
a936 1
        $SIG{CHLD} = \&REAPER;  # loathe SysV
d1118 1
a1118 1
	$SIG{CHLD} = \&REAPER;  # loathe SysV
@


1.1.1.12
log
@Perl 5.12.2 from CPAN
@
text
@d153 1
a153 37
Note: qx(), system() and some modules for calling external commands do a
fork() and wait() for the result. Thus, your signal handler (REAPER in the
example) will be called. Since wait() was already called by system() or qx()
the wait() in the signal handler will not see any more zombies and therefore
block.

The best way to prevent this issue is to use waitpid, as in the following
example:

    use POSIX ":sys_wait_h"; # for nonblocking read

    my %children;

    $SIG{CHLD} = sub {
        # don't change $! and $? outside handler
        local ($!,$?);
        my $pid = waitpid(-1, WNOHANG);
        return if $pid == -1;
        return unless defined $children{$pid};
        delete $children{$pid};
        cleanup_child($pid, $?);
    };

    while (1) {
        my $pid = fork();
        if ($pid == 0) {
            # ...
            exit 0;
        } else {
        $children{$pid}=1;
            # ...
            system($command);
            # ...
       }
    }

Signal handling is also used for timeouts in Unix.  While safely
d319 2
a320 2
Perl 5.7.3 and later avoid these problems by "deferring" signals.
That is, when the signal is delivered to the process by
d721 1
a721 1
Certain built-in Unix features help prevent this most of
d1132 1
a1132 1
	connect(SOCKET, $hispaddr)          || die "connect: $!";
d1664 1
a1664 1
    $id = shmget(IPC_PRIVATE, $size, S_IRUSR|S_IWUSR) // die "$!";
d1686 1
a1686 1
    $id = semget($IPC_KEY, 10, 0666 | IPC_CREAT ) // die "$!";
@


1.1.1.13
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d19 2
a20 2
special events transpire, like a child process exiting, your own process
running out of stack space, or hitting a process file-size limit.
a23 2
    our $shucks;

d25 3
a27 3
        my $signame = shift;
        $shucks++;
        die "Somebody sent me a SIG$signame";
d29 1
a29 1
    $SIG{INT} = __PACKAGE__ . "::catch_zap";  
d41 11
a51 1
system, or you can retrieve them using the CPAN module L<IPC::Signal>.
d53 8
a60 1
You may also choose to assign the strings C<"IGNORE"> or C<"DEFAULT"> as
d65 2
a66 2
has special behavior with respect to a value of C<"IGNORE">.
Setting C<$SIG{CHLD}> to C<"IGNORE"> on such a platform has the effect of
d68 2
a69 2
on its child processes (i.e., child processes are automatically reaped).
Calling C<wait()> with C<$SIG{CHLD}> set to C<"IGNORE"> usually returns
d72 13
a84 4
Some signals can be neither trapped nor ignored, such as the KILL and STOP
(but not the TSTP) signals. Note that ignoring signals makes them disappear.
If you only want them blocked temporarily without them getting lost you'll
have to use POSIX' sigprocmask.
d87 3
a89 3
to the entire Unix process group.  This code sends a hang-up signal to all
processes in the current process group, and also sets $SIG{HUP} to C<"IGNORE"> 
so it doesn't kill itself:
a90 1
    # block scope for local
d92 3
a94 3
        local $SIG{HUP} = "IGNORE";
        kill HUP => -$$;
        # snazzy writing of: kill("HUP", -$$)
d99 1
a99 1
or has changed its UIDs.
d102 1
a102 1
        warn "something wicked happened to $kid_pid";
d105 4
a108 5
Signal number zero may fail because you lack permission to send the
signal when directed at a process whose real or saved UID is not
identical to the real or effective UID of the sending process, even
though the process is alive.  You may be able to determine the cause of
failure using C<$!> or C<%!>.
d110 2
a111 2
    unless (kill(0 => $pid) || $!{EPERM}) {
        warn "$pid looks dead";
d119 18
a136 5
SIGCHLD handlers require some special care.  If a second child dies
while in the signal handler caused by the first death, we won't get
another signal. So must loop here else we will leave the unreaped child
as a zombie. And the next time two children die we get another zombie.
And so on.
d139 12
a150 5
    $SIG{CHLD} = sub {
        while ((my $child = waitpid(-1, WNOHANG)) > 0) {
            $Kid_Status{$child} = $?;
        }
    };
d153 5
a157 5
Be careful: qx(), system(), and some modules for calling external commands
do a fork(), then wait() for the result. Thus, your signal handler
will be called. Because wait() was already called by system() or qx(),
the wait() in the signal handler will see no more zombies and will
therefore block.
d159 1
a159 1
The best way to prevent this issue is to use waitpid(), as in the following
d168 1
a168 1
        local ($!, $?);
a177 1
        die "cannot fork" unless defined $pid;
d182 1
a182 1
            $children{$pid}=1;
d194 2
a195 1
goes off, you'll use die() to jump out of the block.
a198 1
    my $ALARM_EXCEPTION = "alarm clock restart";
d200 1
a200 1
        local $SIG{ALRM} = sub { die $ALARM_EXCEPTION };
d202 1
a202 2
        flock(FH, 2)    # blocking write lock
                        || die "cannot flock: $!";
d205 1
a205 1
    if ($@@ && $@@ !~ quotemeta($ALARM_EXCEPTION)) { die }
d222 10
a231 4
tell that process to reread its configuration file without stopping
the process. Many daemons provide this mechanism using a C<SIGHUP>
signal handler. When you want to tell the daemon to reread the file,
simply send it the C<SIGHUP> signal.
d235 2
a236 2
located in the subroutine C<code()>, which just prints some debugging
info to show that it works; it should be replaced with the real code.
d245 1
a245 1
  $| = 1;
d250 1
a250 1
  my $SELF  = catfile($FindBin::Bin, $script);
d253 7
a259 1
  $SIG{HUP} = sub {
d261 2
a262 2
      exec($SELF, @@ARGV)        || die "$0: couldn't restart: $!";
  };
d269 2
a270 2
      my $count = 0;
      while (++$count) {
d272 1
a272 1
          print "$count\n";
d275 2
d278 53
d334 9
a342 8
Before Perl 5.7.3, installing Perl code to deal with signals exposed you to
danger from two things.  First, few system library functions are
re-entrant.  If the signal interrupts while Perl is executing one function
(like malloc(3) or printf(3)), and your signal handler then calls the same
function again, you could get unpredictable behavior--often, a core dump.
Second, Perl isn't itself re-entrant at the lowest levels.  If the signal
interrupts Perl while Perl is changing its own internal data structures,
similarly unpredictable behavior may result.
d355 11
a365 10
Perl 5.7.3 and later avoid these problems by "deferring" signals.  That is,
when the signal is delivered to the process by the system (to the C code
that implements Perl) a flag is set, and the handler returns immediately.
Then at strategic "safe" points in the Perl interpreter (e.g. when it is
about to execute a new opcode) the flags are checked and the Perl level
handler from %SIG is executed. The "deferred" scheme allows much more
flexibility in the coding of signal handlers as we know the Perl
interpreter is in a safe state, and that we are not in a system library
function when the handler is called.  However the implementation does
differ from previous Perls in the following ways:
d371 1
a371 1
As the Perl interpreter looks at signal flags only when it is about
d376 1
a376 1
If a signal of any given type fires multiple times during an opcode 
d378 1
a378 1
be called only once, after the opcode completes; all other
d390 1
d393 11
a403 12
When a signal is delivered (e.g., SIGINT from a control-C) the operating
system breaks into IO operations like I<read>(2), which is used to
implement Perl's readline() function, the C<< <> >> operator. On older
Perls the handler was called immediately (and as C<read> is not "unsafe",
this worked well). With the "deferred" scheme the handler is I<not> called
immediately, and if Perl is using the system's C<stdio> library that
library may restart the C<read> without returning to Perl to give it a
chance to call the %SIG handler. If this happens on your system the
solution is to use the C<:perlio> layer to do IO--at least on those handles
that you want to be able to break into with signals. (The C<:perlio> layer
checks the signal flags and calls %SIG handlers before resuming IO
operation.)
d405 1
a405 1
The default in Perl 5.7.3 and later is to automatically use
d408 7
a414 13
Note that it is not advisable to access a file handle within a signal
handler where that signal has interrupted an I/O operation on that same
handle. While perl will at least try hard not to crash, there are no
guarantees of data integrity; for example, some data might get dropped or
written twice.

Some networking library functions like gethostbyname() are known to have
their own implementations of timeouts which may conflict with your
timeouts.  If you have problems with such functions, try using the POSIX
sigaction() function, which bypasses Perl safe signals.  Be warned that
this does subject you to possible memory corruption, as described above.

Instead of setting C<$SIG{ALRM}>:
d420 4
a423 3
  use POSIX qw(SIGALRM);
  POSIX::sigaction(SIGALRM, POSIX::SigAction->new(sub { die "alarm" }))
          || die "Error setting SIGALRM handler: $!\n";
d426 2
a427 2
the C<Perl::Unsafe::Signals> module from CPAN, which affects
all signals.
d439 2
a440 2
The default C<:perlio> layer retries C<read>, C<write>
and C<close> as described above; interrupted C<wait> and 
d445 3
a447 3
Certain signals like SEGV, ILL, and BUS are generated by virtual memory
addressing errors and similar "faults". These are normally fatal: there is
little a Perl-level handler can do with them.  So Perl delivers them
d453 1
a453 1
something" before returning. One example can be CHLD or CLD, which
d457 3
a459 3
those signals: it does not do the C<wait>. Again the failure will
look like a loop as the operating system will reissue the signal because
there are completed child processes that have not yet been C<wait>ed for.
d463 1
a463 1
If you want the old signal behavior back despite possible
d465 1
a465 55
C<"unsafe">.  This feature first appeared in Perl 5.8.1.

=head1 Named Pipes

A named pipe (often referred to as a FIFO) is an old Unix IPC
mechanism for processes communicating on the same machine.  It works
just like regular anonymous pipes, except that the
processes rendezvous using a filename and need not be related.

To create a named pipe, use the C<POSIX::mkfifo()> function.

    use POSIX qw(mkfifo);
    mkfifo($path, 0700)     ||  die "mkfifo $path failed: $!";

You can also use the Unix command mknod(1), or on some
systems, mkfifo(1).  These may not be in your normal path, though.

    # system return val is backwards, so && not ||
    #
    $ENV{PATH} .= ":/etc:/usr/etc";
    if  (      system("mknod",  $path, "p")
            && system("mkfifo", $path) )
    {
        die "mk{nod,fifo} $path failed";
    }


A fifo is convenient when you want to connect a process to an unrelated
one.  When you open a fifo, the program will block until there's something
on the other end.

For example, let's say you'd like to have your F<.signature> file be a
named pipe that has a Perl program on the other end.  Now every time any
program (like a mailer, news reader, finger program, etc.) tries to read
from that file, the reading program will read the new signature from your
program.  We'll use the pipe-checking file-test operator, B<-p>, to find
out whether anyone (or anything) has accidentally removed our fifo.

    chdir();    # go home
    my $FIFO = ".signature";

    while (1) {
        unless (-p $FIFO) {
            unlink $FIFO;   # discard any failure, will catch later
            require POSIX;  # delayed loading of heavy module
            POSIX::mkfifo($FIFO, 0700)
                                || die "can't mkfifo $FIFO: $!";
        }

        # next line blocks till there's a reader
        open (FIFO, "> $FIFO")  || die "can't open $FIFO: $!";
        print FIFO "John Smith (smith\@@host.org)\n", `fortune -s`;
        close(FIFO)             || die "can't close $FIFO: $!";
        sleep 2;                # to avoid dup signals
    }
d475 1
a475 1
                        || die "can't fork: $!";
d478 1
a478 1
    close SPOOLER       || die "bad spool: $! $?";
d483 1
a483 1
                        || die "can't fork: $!";
d485 2
a486 2
        next if /^(tcp|udp)/;
        print;
d488 1
a488 1
    close STATUS        || die "bad netstat: $! $?";
d490 3
a492 2
If one can be sure that a particular program is a Perl script expecting
filenames in @@ARGV, the clever programmer can write something like this:
d496 1
a496 1
and no matter which sort of shell it's called from, the Perl program will
d505 1
a505 1
    die "bad netstatus ($?)" if $?;
d510 2
a511 1
whole process, letting you kill off the child process early if you'd like.
d513 1
a513 1
Be careful to check the return values from both open() and close().  If
d518 1
a518 1
can't know whether the command worked, because your command is actually
d520 15
a534 18
while readers of bogus commands return just a quick EOF, writers
to bogus commands will get hit with a signal, which they'd best be prepared
to handle.  Consider:

    open(FH, "|bogus")      || die "can't fork: $!";
    print FH "bang\n";      #  neither necessary nor sufficient 
                            #  to check print retval!
    close(FH)               || die "can't close: $!";

The reason for not checking the return value from print() is because of
pipe buffering; physical writes are delayed.  That won't blow up until the
close, and it will blow up with a SIGPIPE.  To catch it, you could use
this:

    $SIG{PIPE} = "IGNORE";
    open(FH, "|bogus")  || die "can't fork: $!";
    print FH "bang\n";
    close(FH)           || die "can't close: status=$?";
d553 2
a554 1
SIGCHLD because of the double-fork taking place; see below for details.
d560 5
a564 5
often called daemonization.  A well-behaved daemon will also chdir()
to the root directory so it doesn't prevent unmounting the filesystem
containing the directory from which it was launched, and redirect its
standard file descriptors from and to F</dev/null> so that random
output doesn't wind up on the user's terminal.
d566 1
a566 1
    use POSIX "setsid";
d569 8
a576 7
        chdir("/")                      || die "can't chdir to /: $!";
        open(STDIN,  "< /dev/null")     || die "can't read /dev/null: $!";
        open(STDOUT, "> /dev/null")     || die "can't write to /dev/null: $!";
        defined(my $pid = fork())       || die "can't fork: $!";
        exit if $pid;                   # non-zero now means I am the parent
        (setsid() != -1)                || die "Can't start a new session: $!" 
        open(STDERR, ">&STDOUT")        || die "can't dup stdout: $!";
d579 2
a580 2
The fork() has to come before the setsid() to ensure you aren't a
process group leader; the setsid() will fail if you are.  If your
d584 2
a585 2
Non-Unix users should check their C<< I<Your_OS>::Process >> module for 
other possible solutions.
d590 1
a590 1
multiprocess and communicate between--or even amongst--yourselves.  The
d596 1
a596 1
write to the filehandle you opened and your kid will find it in I<his>
d598 1
a598 1
you opened whatever your kid writes to I<his> STDOUT.
d600 2
a601 4
    use English qw[ -no_match_vars ];
    my $PRECIOUS = "/path/to/some/safe/file";
    my $sleep_count;
    my $pid;
d604 6
a609 6
        $pid = open(KID_TO_WRITE, "|-");
        unless (defined $pid) {
            warn "cannot fork: $!";
            die "bailing out" if $sleep_count++ > 6;
            sleep 10;
        }
d612 11
a622 13
    if ($pid) {                 # I am the parent 
        print KID_TO_WRITE @@some_data;
        close(KID_TO_WRITE)     || warn "kid exited $?";
    } else {                    # I am the child
        # drop permissions in setuid and/or setgid programs:
        ($EUID, $EGID) = ($UID, $GID);  
        open (OUTFILE, "> $PRECIOUS") 
                                || die "can't open $PRECIOUS: $!";
        while (<STDIN>) {
            print OUTFILE;      # child's STDIN is parent's KID_TO_WRITE
        }
        close(OUTFILE)          || die "can't close $PRECIOUS: $!";
        exit(0);                # don't forget this!!
d633 2
a634 2
    my $pid = open(KID_TO_READ, "-|");
    defined($pid)           || die "can't fork: $!";
d636 12
a647 5
    if ($pid) {             # parent
        while (<KID_TO_READ>) {
                            # do something interesting
        }
        close(KID_TO_READ)  || warn "kid exited $?";
a648 6
    } else {                # child
        ($EUID, $EGID) = ($UID, $GID); # suid only
        exec($program, @@options, @@args)
                            || die "can't exec program: $!";
        # NOTREACHED
    }
d652 2
a653 3
    my $pid = open(KID_TO_WRITE, "|-");
    defined($pid)           || die "can't fork: $!";

d656 11
a666 9
    if ($pid) {             # parent
        print KID_TO_WRITE @@data;
        close(KID_TO_WRITE) || warn "kid exited $?";

    } else {                # child
        ($EUID, $EGID) = ($UID, $GID);
        exec($program, @@options, @@args)
                            || die "can't exec program: $!";
        # NOTREACHED
d670 2
a671 2
indeed with any use of pipe() with multiple subprocesses.  The 
example above is "safe" because it is simple and calls exec().  See
d679 2
a680 2
    my $pid = open(WRITER, "|-");        # fork open a kid
    defined($pid)               || die "first fork failed: $!";
d683 2
a684 3
            defined($sub_pid)   || die "second fork failed: $!";
            close(WRITER)       || die "couldn't close WRITER: $!";
            # now do something else...
d687 2
a688 5
            # first write to WRITER
            # ...
            # then when finished
            close(WRITER)       || die "couldn't close WRITER: $!";
            exit(0);
d692 2
a693 2
        # first do something with STDIN, then
        exit(0);
d696 1
a696 1
In the example above, the true parent does not want to write to the WRITER
d698 2
a699 2
C<open FH, "|-">, it has a special behavior: closing it calls
waitpid() (see L<perlfunc/waitpid>), which waits for the subprocess
d701 1
a701 1
in the section marked "do something else", you have deadlock.
d703 1
a703 1
This can also be a problem with intermediate subprocesses in more
d705 1
a705 1
during global destruction--in no predictable order.
d708 1
a708 1
open() which sets one file descriptor to another, as shown below:
d710 1
a710 1
    pipe(READER, WRITER)        || die "pipe failed: $!";
d712 1
a712 1
    defined($pid)               || die "first fork failed: $!";
d714 1
a714 1
        close READER;
d716 1
a716 2
            defined($sub_pid)   || die "first fork failed: $!";
            close(WRITER)       || die "can't close WRITER: $!";
d720 1
a720 4
            # ...
            # then  when finished
            close(WRITER)       || die "can't close WRITER: $!";
            exit(0);
d725 2
a726 2
        open(STDIN, "<&READER") || die "can't reopen STDIN: $!";
        close(WRITER)           || die "can't close WRITER: $!";
d728 1
a728 1
        exit(0);
d731 2
a732 3
Since Perl 5.8.0, you can also use the list form of C<open> for pipes.
This is preferred when you wish to avoid having the shell interpret
metacharacters that may be in your command string.
d734 1
a734 1
So for example, instead of using:
d736 4
a739 1
    open(PS_PIPE, "ps aux|")    || die "can't open ps pipe: $!";
d741 4
a744 31
One would use either of these:

    open(PS_PIPE, "-|", "ps", "aux") 
                                || die "can't open ps pipe: $!";

    @@ps_args = qw[ ps aux ];
    open(PS_PIPE, "-|", @@ps_args)
                                || die "can't open @@ps_args|: $!";

Because there are more than three arguments to open(), forks the ps(1)
command I<without> spawning a shell, and reads its standard output via the
C<PS_PIPE> filehandle.  The corresponding syntax to I<write> to command
pipes is to use C<"|-"> in place of C<"-|">.  

This was admittedly a rather silly example, because you're using string
literals whose content is perfectly safe.  There is therefore no cause to
resort to the harder-to-read, multi-argument form of pipe open().  However,
whenever you cannot be assured that the program arguments are free of shell
metacharacters, the fancier form of open() should be used.  For example:

    @@grep_args = ("egrep", "-i", $some_pattern, @@many_files);
    open(GREP_PIPE, "-|", @@grep_args)
                        || die "can't open @@grep_args|: $!";

Here the multi-argument form of pipe open() is preferred because the
pattern and indeed even the filenames themselves might hold metacharacters.

Be aware that these operations are full Unix forks, which means they may
not be correctly implemented on all alien systems.  Additionally, these are
not true multithreading.  To learn more about threading, see the F<modules>
file mentioned below in the SEE ALSO section.
d748 21
a768 19
Whenever you have more than one subprocess, you must be careful that each
closes whichever half of any pipes created for interprocess communication
it is not using.  This is because any child process reading from the pipe
and expecting an EOF will never receive it, and therefore never exit. A
single process closing a pipe is not enough to close it; the last process
with the pipe open must close it for it to read EOF.

Certain built-in Unix features help prevent this most of the time.  For
instance, filehandles have a "close on exec" flag, which is set I<en masse>
under control of the C<$^F> variable.  This is so any filehandles you
didn't explicitly route to the STDIN, STDOUT or STDERR of a child
I<program> will be automatically closed.

Always explicitly and immediately call close() on the writable end of any
pipe, unless that process is actually writing to it.  Even if you don't
explicitly call close(), Perl will still close() all filehandles during
global destruction.  As previously discussed, if those filehandles have
been opened with Safe Pipe Open, this will result in calling waitpid(),
which may again deadlock.
d773 2
a774 1
about bidirectional communication?  The most obvious approach doesn't work:
a775 1
    # THIS DOES NOT WORK!!
d778 2
a779 2
If you forget to C<use warnings>, you'll miss out entirely on the
helpful diagnostic message:
d783 5
a787 5
If you really want to, you can use the standard open2() from the
C<IPC::Open2> module to catch both ends.  There's also an open3() in
C<IPC::Open3> for tridirectional I/O so you can also catch your child's
STDERR, but doing so would then require an awkward select() loop and
wouldn't allow you to use normal Perl input operations.
d790 5
a794 10
primitives like the pipe() and exec() syscalls to create all the
connections.  Although it might have been more efficient by using
socketpair(), this would have been even less portable than it already
is. The open2() and open3() functions are unlikely to work anywhere
except on a Unix system, or at least one purporting POSIX compliance.

=for TODO
Hold on, is this even true?  First it says that socketpair() is avoided
for portability, but then it says it probably won't work except on 
Unixy systems anyway.  Which one of those is true?
d800 1
a800 1
    $pid = open2(*Reader, *Writer, "cat -un");
d804 31
a834 16
The problem with this is that buffering is really going to ruin your
day.  Even though your C<Writer> filehandle is auto-flushed so the process
on the other end gets your data in a timely manner, you can't usually do
anything to force that process to give its data to you in a similarly quick
fashion.  In this special case, we could actually so, because we gave
I<cat> a B<-u> flag to make it unbuffered.  But very few commands are
designed to operate over pipes, so this seldom works unless you yourself
wrote the program on the other end of the double-ended pipe.

A solution to this is to use a library which uses pseudottys to make your
program behave more reasonably.  This way you don't have to have control
over the source code of the program you're using.  The C<Expect> module
from CPAN also addresses this kind of thing.  This module requires two
other modules from CPAN, C<IO::Pty> and C<IO::Stty>.  It sets up a pseudo
terminal to interact with programs that insist on talking to the terminal
device driver.  If your system is supported, this may be your best bet.
d838 4
a841 4
If you want, you may make low-level pipe() and fork() syscalls to stitch
this together by hand.  This example only talks to itself, but you could
reopen the appropriate handles to STDIN and STDOUT and call other processes.
(The following example lacks proper error checking.)
d846 3
a848 3
    use IO::Handle;               # thousands of lines just for autoflush :-(
    pipe(PARENT_RDR, CHILD_WTR);  # XXX: check failure?
    pipe(CHILD_RDR,  PARENT_WTR); # XXX: check failure?
d852 7
a858 8
    if ($pid = fork()) {
        close PARENT_RDR; 
        close PARENT_WTR;
        print CHILD_WTR "Parent Pid $$ is sending this\n";
        chomp($line = <CHILD_RDR>);
        print "Parent Pid $$ just read this: '$line'\n";
        close CHILD_RDR; close CHILD_WTR;
        waitpid($pid, 0);
d860 7
a866 9
        die "cannot fork: $!" unless defined $pid;
        close CHILD_RDR; 
        close CHILD_WTR;
        chomp($line = <PARENT_RDR>);
        print "Child Pid $$ just read this: '$line'\n";
        print PARENT_WTR "Child Pid $$ is sending this\n";
        close PARENT_RDR; 
        close PARENT_WTR;
        exit(0);
d877 1
a877 2
    use IO::Handle;  # thousands of lines just for autoflush :-(

d882 1
a882 1
                                ||  die "socketpair: $!";
d887 7
a893 7
    if ($pid = fork()) {
        close PARENT;
        print CHILD "Parent Pid $$ is sending this\n";
        chomp($line = <CHILD>);
        print "Parent Pid $$ just read this: '$line'\n";
        close CHILD;
        waitpid($pid, 0);
d895 7
a901 7
        die "cannot fork: $!" unless defined $pid;
        close CHILD;
        chomp($line = <PARENT>);
        print "Child Pid $$ just read this: '$line'\n";
        print PARENT "Child Pid $$ is sending this\n";
        close PARENT;
        exit(0);
d906 5
a910 5
While not entirely limited to Unix-derived operating systems (e.g., WinSock
on PCs provides socket support, as do some VMS libraries), you might not have
sockets on your system, in which case this section probably isn't going to
do you much good.  With sockets, you can do both virtual circuits like TCP
streams and datagrams like UDP packets.  You may be able to do even more
d913 1
a913 1
The Perl functions for dealing with sockets have the same names as
d915 1
a915 1
for two reasons.  First, Perl filehandles work differently than C file
d919 6
a924 6
One of the major problems with ancient, antemillennial socket code in Perl
was that it used hard-coded values for some of the constants, which
severely hurt portability.  If you ever see code that does anything like
explicitly setting C<$AF_INET = 2>, you know you're in for big trouble.  
An immeasurably superior approach is to use the C<Socket> module, which more
reliably grants access to the various constants and functions you'll need.
d941 1
a941 1
accepting a lone "\012" on input (be lenient in what you require).
d943 1
a943 2
but unless you're on a Mac from way back in its pre-Unix dark ages, you'll 
probably be ok.
d955 1
a955 1
    my ($remote, $port, $iaddr, $paddr, $proto, $line);
d957 1
a957 1
    $remote  = shift || "localhost";
d959 1
a959 1
    if ($port =~ /\D/) { $port = getservbyname($port, "tcp") }
d961 1
a961 1
    $iaddr   = inet_aton($remote)       || die "no host: $remote";
d964 5
a968 5
    $proto   = getprotobyname("tcp");
    socket(SOCK, PF_INET, SOCK_STREAM, $proto)  || die "socket: $!";
    connect(SOCK, $paddr)               || die "connect: $!";
    while ($line = <SOCK>) {
        print $line;
d971 2
a972 2
    close (SOCK)                        || die "close: $!";
    exit(0);
d975 1
a975 1
leave the address as C<INADDR_ANY> so that the kernel can choose
d978 2
a979 1
or firewall machine), fill this in with your real address instead.
d983 1
a983 1
    BEGIN { $ENV{PATH} = "/usr/bin:/bin" }
d988 1
a988 1
    sub logmsg { print "$0 $$: @@_ at ", scalar localtime(), "\n" }
d990 2
a991 2
    my $port  = shift || 2345;
    die "invalid port" unless if $port =~ /^ \d+ $/x;
d993 1
a993 1
    my $proto = getprotobyname("tcp");
d995 5
a999 5
    socket(Server, PF_INET, SOCK_STREAM, $proto)    || die "socket: $!";
    setsockopt(Server, SOL_SOCKET, SO_REUSEADDR, pack("l", 1))    
                                                    || die "setsockopt: $!";
    bind(Server, sockaddr_in($port, INADDR_ANY))    || die "bind: $!";
    listen(Server, SOMAXCONN)                       || die "listen: $!";
d1007 7
a1013 3
    for ( ; $paddr = accept(Client, Server); close Client) {
        my($port, $iaddr) = sockaddr_in($paddr);
        my $name = gethostbyaddr($iaddr, AF_INET);
d1015 2
a1016 6
        logmsg "connection from $name [",
                inet_ntoa($iaddr), "]
                at port $port";

        print Client "Hello there, $name, it's now ",
                        scalar localtime(), $EOL;
d1020 1
a1020 1
like most typical servers, it spawns (fork()s) a slave server to
d1026 1
a1026 1
    BEGIN { $ENV{PATH} = "/usr/bin:/bin" }
d1032 1
a1032 1
    sub logmsg { print "$0 $$: @@_ at ", scalar localtime(), "\n" }
d1034 2
a1035 2
    my $port  = shift || 2345;
    die "invalid port" unless if $port =~ /^ \d+ $/x;
d1037 1
a1037 1
    my $proto = getprotobyname("tcp");
d1039 5
a1043 5
    socket(Server, PF_INET, SOCK_STREAM, $proto)    || die "socket: $!";
    setsockopt(Server, SOL_SOCKET, SO_REUSEADDR, pack("l", 1))         
                                                    || die "setsockopt: $!";
    bind(Server, sockaddr_in($port, INADDR_ANY))    || die "bind: $!";
    listen(Server, SOMAXCONN)                       || die "listen: $!";
d1055 2
a1056 2
        while ((my $pid = waitpid(-1, WNOHANG)) > 0 && WIFEXITED($?)) {
            logmsg "reaped $waitedpid" . ($? ? " with exit $?" : "");
d1063 1
a1063 1
    while (1) {
d1065 1
a1065 1
            # try again if accept() returned because got a signal
d1077 3
a1079 3
            $| = 1;
            print "Hello there, $name, it's now ", scalar localtime(), $EOL;
            exec "/usr/games/fortune"       # XXX: "wrong" line terminators
d1088 1
a1088 1
        unless (@@_ == 0 && $coderef && ref($coderef) eq "CODE") {
d1093 1
a1093 1
        unless (defined($pid = fork())) {
d1103 2
a1104 2
        open(STDIN,  "<&Client")    || die "can't dup client to stdin";
        open(STDOUT, ">&Client")    || die "can't dup client to stdout";
d1106 1
a1106 1
        exit($coderef->());
d1121 2
a1122 2
a false value.  This would normally indicate a system error needs
to be reported.  However, the introduction of safe signals (see
d1124 2
a1125 2
accept() might also be interrupted when the process receives a signal.
This typically happens when one of the forked subprocesses exits and
d1128 2
a1129 2
If accept() is interrupted by a signal, $! will be set to EINTR.
If this happens, we can safely continue to the next iteration of
d1131 5
a1135 5
signal handling code not modify the value of $!, or else this test 
will likely fail.  In the REAPER subroutine we create a local version
of $! before calling waitpid().  When waitpid() sets $! to ECHILD as
it inevitably does when it has no more children waiting, it 
updates the local copy and leaves the original unchanged.
d1137 1
a1137 1
You should use the B<-T> flag to enable taint checking (see L<perlsec>)
d1139 1
a1139 1
for servers or any program run on behalf of someone else (like CGI
d1151 2
a1152 2
    my $SECS_OF_70_YEARS = 2208988800;
    sub ctime { scalar localtime(shift() || time()) }
d1154 3
a1156 3
    my $iaddr = gethostbyname("localhost");
    my $proto = getprotobyname("tcp");
    my $port = getservbyname("time", "tcp");
d1161 1
a1161 1
    printf "%-24s %8s %s\n", "localhost", 0, ctime();
d1164 10
a1173 11
        printf "%-24s ", $host;
        my $hisiaddr = inet_aton($host)     || die "unknown host";
        my $hispaddr = sockaddr_in($port, $hisiaddr);
        socket(SOCKET, PF_INET, SOCK_STREAM, $proto)   
                                            || die "socket: $!";
        connect(SOCKET, $hispaddr)          || die "connect: $!";
        my $rtime = pack("C4", ());
        read(SOCKET, $rtime, 4);
        close(SOCKET);
        my $histime = unpack("N", $rtime) - $SECS_OF_70_YEARS;
        printf "%8d %s\n", $histime - time(), ctime($histime);
d1189 2
a1190 2
    unless (-S "/dev/log") {
        die "something's wicked with the log system";
d1200 3
a1202 3
    $rendezvous = shift || "catsock";
    socket(SOCK, PF_UNIX, SOCK_STREAM, 0)     || die "socket: $!";
    connect(SOCK, sockaddr_un($rendezvous))   || die "connect: $!";
d1204 1
a1204 1
        print $line;
d1206 1
a1206 1
    exit(0);
d1217 1
a1217 1
    BEGIN { $ENV{PATH} = "/usr/bin:/bin" }
d1219 1
a1219 1
    sub logmsg { print "$0 $$: @@_ at ", scalar localtime(), "\n" }
d1221 1
a1221 1
    my $NAME = "catsock";
d1223 1
a1223 1
    my $proto = getprotobyname("tcp");
d1225 1
a1225 1
    socket(Server, PF_UNIX, SOCK_STREAM, 0) || die "socket: $!";
d1227 2
a1228 2
    bind  (Server, $uaddr)                  || die "bind: $!";
    listen(Server, SOMAXCONN)               || die "listen: $!";
d1236 5
a1240 5
        my $child;
        while (($waitedpid = waitpid(-1, WNOHANG)) > 0) {
            logmsg "reaped $waitedpid" . ($? ? " with exit $?" : "");
        }
        $SIG{CHLD} = \&REAPER;  # loathe SysV
d1247 2
a1248 2
          accept(Client, Server) || $waitedpid;
          $waitedpid = 0, close Client)
d1250 6
a1255 6
        next if $waitedpid;
        logmsg "connection on $NAME";
        spawn sub {
            print "Hello there, it's now ", scalar localtime(), "\n";
            exec("/usr/games/fortune")  || die "can't exec fortune: $!";
        };
d1259 1
a1259 1
        my $coderef = shift();
d1261 18
a1278 21
        unless (@@_ == 0 && $coderef && ref($coderef) eq "CODE") {
            confess "usage: spawn CODEREF";
        }

        my $pid;
        unless (defined($pid = fork())) {
            logmsg "cannot fork: $!";
            return;
        } 
        elsif ($pid) {
            logmsg "begat $pid";
            return; # I'm the parent
        } 
        else {
            # I'm the child -- go spawn
        }

        open(STDIN,  "<&Client")    || die "can't dup client to stdin";
        open(STDOUT, ">&Client")    || die "can't dup client to stdout";
        ## open(STDERR, ">&STDOUT") || die "can't dup stdout to stderr";
        exit($coderef->());
d1283 2
a1284 1
logmsg(), ctime(), and REAPER()--which are the same as in the other server.
d1289 1
a1289 1
you get a separate session for each client; that's why accept() takes two
d1292 2
a1293 2
For example, let's say that you have a long-running database server daemon
that you want folks to be able to access from the Web, but only
d1301 7
a1307 7
IO::Socket module provides an object-oriented approach.  IO::Socket has
been included in the standard Perl distribution ever since Perl 5.004.  If
you're running an earlier version of Perl (in which case, how are you
reading this manpage?), just fetch IO::Socket from CPAN, where you'll also
find modules providing easy interfaces to the following systems: DNS, FTP,
Ident (RFC 931), NIS and NISPlus, NNTP, Ping, POP3, SMTP, SNMP, SSLeay,
Telnet, and Time--to name just a few.
d1318 6
a1323 6
                        Proto    => "tcp",
                        PeerAddr => "localhost",
                        PeerPort => "daytime(13)",
                    )
                  || die "can't connect to daytime service on localhost";
    while (<$remote>) { print }
d1330 1
a1330 1
Here are what those parameters to the new() constructor mean:
d1346 1
a1346 1
or an address like C<"207.171.7.72">.  For demonstration purposes, we've
d1349 1
a1349 1
for localhost is C<"127.0.0.1">, if you'd rather use that.
d1356 3
a1358 3
is found in I</etc/services> under Unixy systems.] but here we've specified the
port number (13) in parentheses.  Using just the number would have also
worked, but numeric literals make careful programmers nervous.
d1363 2
a1364 2
a filehandle in the C<while> loop?  That's what's called an I<indirect
filehandle>, a scalar variable containing a filehandle.  You can use
d1381 1
a1381 1
from, and then a list of files to get from that host.  This is a
d1387 1
a1387 1
    unless (@@ARGV > 1) { die "usage: $0 host url ..." }
d1391 10
a1400 9
    for my $document (@@ARGV) {
        $remote = IO::Socket::INET->new( Proto     => "tcp",
                                         PeerAddr  => $host,
                                         PeerPort  => "http(80)",
                  )     || die "cannot connect to httpd on $host";
        $remote->autoflush(1);
        print $remote "GET $document HTTP/1.0" . $BLANK;
        while ( <$remote> ) { print }
        close $remote;
d1403 3
a1405 3
The web server handling the HTTP service is assumed to be at
its standard port, number 80.  If the server you're trying to
connect to is at a different port, like 1080 or 8080, you should specify it
d1408 3
a1410 3
up the output we sent it.  (If you're on a prehistoric Mac, you'll also
need to change every C<"\n"> in your code that sends data over the network
to be a C<"\015\012"> instead.)
d1440 1
a1440 1
For a more featureful version of this program, you should look to
d1475 3
a1477 3
                                    PeerAddr  => $host,
                                    PeerPort  => $port)
               || die "can't connect to port $port on $host: $!";
d1479 1
a1479 1
    $handle->autoflush(1);       # so output gets there right away
d1487 5
a1491 5
        # copy the socket to standard output
        while (defined ($line = <$handle>)) {
            print STDOUT $line;
        }
        kill("TERM", $kidpid);   # send SIGTERM to child
d1495 4
a1498 5
        # copy standard input to the socket
        while (defined ($line = <STDIN>)) {
            print $handle $line;
        }
        exit(0);                # just in case
d1502 1
a1502 1
signal to our child process, currently running in the C<else> block,
d1512 1
a1512 1
        print STDOUT $byte;
d1572 4
a1575 4
This server accepts one of five different commands, sending output back to
the client.  Unlike most network servers, this one handles only one
incoming client at a time.  Multithreaded servers are covered in 
Chapter 16 of the Camel.
d1581 1
a1581 1
 use Net::hostent;      # for OOish version of gethostbyaddr
d1583 1
a1583 1
 $PORT = 9000;          # pick something not in use
d1585 1
a1585 1
 $server = IO::Socket::INET->new( Proto     => "tcp",
d1600 6
a1605 6
     next unless /\S/;       # blank line
     if    (/quit|exit/i)    { last                                      }
     elsif (/date|time/i)    { printf $client "%s\n", scalar localtime() }
     elsif (/who/i )         { print  $client `who 2>&1`                 }
     elsif (/cookie/i )      { print  $client `/usr/games/fortune 2>&1`  }
     elsif (/motd/i )        { print  $client `cat /etc/motd 2>&1`       }
d1627 4
a1630 4
UDP datagrams are I<not> a bytestream and should not be treated as such.
This makes using I/O mechanisms with internal buffering like stdio (i.e.
print() and friends) especially cumbersome. Use syswrite(), or better
send(), like in the example below.
d1644 2
a1645 2
         $host, $iaddr, $paddr, $port, $proto,
         $rin, $rout, $rtime, $SECS_OF_70_YEARS);
d1647 1
a1647 1
    $SECS_OF_70_YEARS = 2_208_988_800;
d1650 2
a1651 2
    $proto = getprotobyname("udp");
    $port = getservbyname("time", "udp");
d1658 1
a1658 1
    printf "%-12s %8s %s\n",  "localhost", 0, scalar localtime();
d1661 4
a1664 4
        $count++;
        $hisiaddr = inet_aton($host)              || die "unknown host";
        $hispaddr = sockaddr_in($port, $hisiaddr);
        defined(send(SOCKET, 0, 0, $hispaddr))    || die "send $host: $!";
d1667 1
a1667 1
    $rin = "";
d1672 8
a1679 8
        $rtime = "";
        $hispaddr = recv(SOCKET, $rtime, 4, 0)    || die "recv: $!";
        ($port, $hisiaddr) = sockaddr_in($hispaddr);
        $host = gethostbyaddr($hisiaddr, AF_INET);
        $histime = unpack("N", $rtime) - $SECS_OF_70_YEARS;
        printf "%-12s ", $host;
        printf "%8d %s\n", $histime - time(), scalar localtime($histime);
        $count--;
d1682 4
a1685 4
This example does not include any retries and may consequently fail to
contact a reachable host. The most prominent reason for this is congestion
of the queues on the sending host if the number of hosts to contact is
sufficiently large.
d1690 4
a1693 4
interesting uses.  However, you cannot use SysV IPC or Berkeley mmap() to
have a variable shared amongst several processes.  That's because Perl
would reallocate your string when you weren't wanting it to.  You might
look into the C<IPC::Shareable> or C<threads::shared> modules for that.
d1700 1
a1700 2
    $id = shmget(IPC_PRIVATE, $size, S_IRUSR | S_IWUSR);
    defined($id)                    || die "shmget: $!";
d1704 1
a1704 1
    shmwrite($id, $message, 0, 60)  || die "shmwrite: $!";
d1706 1
a1706 1
    shmread($id, $buff, 0, 60)      || die "shmread: $!";
d1710 1
a1710 1
    substr($buff, index($buff, "\0")) = "";
d1715 1
a1715 1
    shmctl($id, IPC_RMID, 0)        || die "shmctl: $!";
d1722 1
a1722 2
    $id = semget($IPC_KEY, 10, 0666 | IPC_CREAT);
    defined($id)                    || die "shmget: $!";
d1731 2
a1732 2
    $id = semget($IPC_KEY, 0, 0);
    defined($id)                    || die "shmget: $!";
d1734 1
a1734 1
    $semnum  = 0;
d1737 1
a1737 1
    # "take" semaphore
d1745 1
a1745 1
    $opstring  = $opstring1 . $opstring2;
d1747 1
a1747 1
    semop($id, $opstring)   || die "semop: $!";
d1752 1
a1752 1
    # "give" the semaphore
d1758 1
a1758 1
    die unless defined($id);
d1760 1
a1760 1
    $semnum  = 0;
d1767 1
a1767 1
    semop($id, $opstring)   || die "semop: $!";
a1777 1
    defined($id)                || die "msgget failed: $!";
d1779 1
a1779 1
    my $sent      = "message";
d1781 2
d1784 16
a1799 10
    msgsnd($id, pack("l! a*", $type_sent, $sent), 0)
                                || die "msgsnd failed: $!";

    msgrcv($id, my $rcvd_buf, 60, 0, 0)
                                || die "msgrcv failed: $!";

    my($type_rcvd, $rcvd) = unpack("l! a*", $rcvd_buf);

    if ($rcvd eq $sent) {
        print "okay\n";
d1801 1
a1801 1
        print "not okay\n";
a1803 2
    msgctl($id, IPC_RMID, 0)    || die "msgctl failed: $!\n";

d1809 1
a1809 1
functions do croak() on bad arguments.)  It is therefore essential to
d1811 2
a1812 2
programs this way for optimal success, and don't forget to add the B<-T>
taint-checking flag to the C<#!> line for servers:
d1821 1
a1821 1
These routines all create system-specific portability problems.  As noted
d1823 1
a1823 1
behavior.  It's probably safest to assume broken SysV semantics for
d1838 5
a1842 5
For intrepid programmers, the indispensable textbook is I<Unix Network
Programming, 2nd Edition, Volume 1> by W. Richard Stevens (published by
Prentice-Hall).  Most books on networking address the subject from the
perspective of a C programmer; translation to Perl is left as an exercise
for the reader.
d1846 9
a1854 12
functions in L<perlfunc>, you should also check out the F<modules> file at
your nearest CPAN site, especially
L<http://www.cpan.org/modules/00modlist.long.html#ID5_Networking_>.  
See L<perlmodlib> or best yet, the F<Perl FAQ> for a description
of what CPAN is and where to get it if the previous link doesn't work 
for you.

Section 5 of CPAN's F<modules> file is devoted to "Networking, Device
Control (modems), and Interprocess Communication", and contains numerous
unbundled modules numerous networking modules, Chat and Expect operations,
CGI programming, DCE, FTP, IPC, NNTP, Proxy, Ptty, RPC, SNMP, SMTP, Telnet,
Threads, and ToolTalk--to name just a few.
@


1.1.1.14
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d34 1
a34 1
Prior to Perl 5.8.0 it was necessary to do as little as you possibly
d227 1
a227 1
Before Perl 5.8.0, installing Perl code to deal with signals exposed you to
d247 1
a247 1
Perl 5.8.0 and later avoid these problems by "deferring" signals.  That is,
d296 1
a296 1
The default in Perl 5.8.0 and later is to automatically use
d331 1
a331 1
Perl 5.8.0 and later do I<not> use SA_RESTART.  Consequently, 
d524 1
a524 1
        (setsid() != -1)                || die "Can't start a new session: $!";
d1099 1
a1099 1
L</Deferred Signals (Safe Signals)> above) in Perl 5.8.0 means that
d1280 4
a1283 2
IO::Socket module provides an object-oriented approach.  If for some reason
you lack this module, you can just fetch IO::Socket from CPAN, where you'll also
d1703 2
a1704 2
    defined($id)                    || die "semget: $!";
    print "sem id $id\n";
d1713 1
a1713 1
    defined($id)                    || die "semget: $!";
d1751 2
a1752 1
clunky looking.  For a more modern look, see the IPC::SysV module.
@


1.1.1.15
log
@Import perl-5.20.1
@
text
@d127 5
a131 4
        while ( (my $pid = waitpid(-1, WNOHANG)) > 0 ) {
            delete $children{$pid};
            cleanup_child($pid, $?);
        }
d549 1
a549 1
    use English;
d726 3
a728 1
not be correctly implemented on all alien systems.
d995 1
a995 1
And here's a multitasking version.  It's multitasked in that
d1011 1
a1011 1
    die "invalid port" unless $port =~ /^ \d+ $/x;
d1551 1
a1551 1
incoming client at a time.  Multitasking servers are covered in
@


1.1.1.16
log
@Import perl-5.20.2
@
text
@d31 1
a31 1
    $SIG{INT} = __PACKAGE__ . "::catch_zap";
d64 1
a64 1
processes in the current process group, and also sets $SIG{HUP} to C<"IGNORE">
d191 1
a191 4
  #!/usr/bin/perl

  use strict;
  use warnings;
d196 1
a196 1
  use File::Spec::Functions qw(catfile);
d217 1
a217 1
      while (1) {
d219 1
a219 1
          print ++$count, "\n";
d266 1
a266 1
If a signal of any given type fires multiple times during an opcode
d330 1
a330 1
Perl 5.8.0 and later do I<not> use SA_RESTART.  Consequently,
d335 1
a335 1
and C<close> as described above; interrupted C<wait> and
d472 1
a472 1
    print FH "bang\n";      #  neither necessary nor sufficient
d532 1
a532 1
Non-Unix users should check their C<< I<Your_OS>::Process >> module for
d562 1
a562 1
    if ($pid) {                 # I am the parent
d567 2
a568 2
        ($EUID, $EGID) = ($UID, $GID);
        open (OUTFILE, "> $PRECIOUS")
d620 1
a620 1
indeed with any use of pipe() with multiple subprocesses.  The
d699 1
a699 1
    open(PS_PIPE, "-|", "ps", "aux")
d709 1
a709 1
pipes is to use C<"|-"> in place of C<"-|">.
d777 1
a777 1
for portability, but then it says it probably won't work except on
d822 1
a822 1
        close PARENT_RDR;
d831 1
a831 1
        close CHILD_RDR;
d836 1
a836 1
        close PARENT_RDR;
d895 1
a895 1
explicitly setting C<$AF_INET = 2>, you know you're in for big trouble.
d916 1
a916 1
but unless you're on a Mac from way back in its pre-Unix dark ages, you'll
d969 1
a969 1
    setsockopt(Server, SOL_SOCKET, SO_REUSEADDR, pack("l", 1))
d1013 1
a1013 1
    setsockopt(Server, SOL_SOCKET, SO_REUSEADDR, pack("l", 1))
d1069 1
a1069 1
        }
d1099 1
a1099 1
notifies the parent process with a CHLD signal.
d1104 1
a1104 1
signal handling code not modify the value of $!, or else this test
d1107 1
a1107 1
it inevitably does when it has no more children waiting, it
d1140 1
a1140 1
        socket(SOCKET, PF_INET, SOCK_STREAM, $proto)
d1243 1
a1243 1
        }
d1247 1
a1247 1
        }
d1818 1
a1818 1
L<http://www.cpan.org/modules/00modlist.long.html#ID5_Networking_>.
d1820 1
a1820 1
of what CPAN is and where to get it if the previous link doesn't work
@


