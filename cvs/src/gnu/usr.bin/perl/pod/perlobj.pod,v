head	1.16;
access;
symbols
	OPENBSD_6_2:1.16.0.2
	OPENBSD_6_2_BASE:1.16
	PERL_5_24_2:1.1.1.15
	OPENBSD_6_1:1.16.0.4
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.15.0.10
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.4
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.6
	OPENBSD_5_8_BASE:1.15
	PERL_5_20_2:1.1.1.14
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	PERL_5_20_1:1.1.1.14
	OPENBSD_5_6:1.14.0.4
	OPENBSD_5_6_BASE:1.14
	PERL_5_18_2:1.1.1.13
	PERL:1.1.1
	OPENBSD_5_5:1.13.0.6
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	PERL_5_16_3:1.1.1.12
	OPENBSD_5_3:1.12.0.10
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.8
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.6
	OPENBSD_5_0:1.12.0.4
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	PERL_5_12_2:1.1.1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	PERL_5_10_1:1.1.1.10
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	PERL_5_10_0:1.1.1.9
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	PERL_5_8_8:1.1.1.8
	OPENBSD_3_9:1.8.0.8
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.6
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	PERL_5_8_6:1.1.1.7
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.6.0.6
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.16
date	2017.02.05.00.32.18;	author afresh1;	state Exp;
branches;
next	1.15;
commitid	cxJ08BvJA9Pt2PTM;

1.15
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.14;
commitid	QP75iYx42Uo7mMxO;

1.14
date	2014.03.24.15.05.33;	author afresh1;	state Exp;
branches;
next	1.13;

1.13
date	2013.03.25.20.40.59;	author sthen;	state Exp;
branches;
next	1.12;

1.12
date	2010.09.24.15.07.04;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.12.18.24.47;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.29.17.36.17;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.28.19.23.11;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.09.18.10.16;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2004.04.07.21.33.08;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.33;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.35.57;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.07.35;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.17;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.59.21;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.03;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.03;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.40.55;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.28;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.24.43;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.06;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.04.07.21.13.34;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.48.16;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2006.03.28.18.49.22;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2008.09.29.17.18.52;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2009.10.12.18.10.38;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2010.09.24.14.49.08;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2013.03.25.20.09.21;	author sthen;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2014.03.24.14.59.08;	author afresh1;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.11.17.20.53.15;	author afresh1;	state Exp;
branches;
next	1.1.1.15;
commitid	B31cAbBIXiCqnL97;

1.1.1.15
date	2017.08.14.13.46.20;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.16
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@=encoding utf8

=for comment
Consistent formatting of this file is achieved with:
  perl ./Porting/podtidy pod/perlobj.pod

=head1 NAME
X<object> X<OOP>

perlobj - Perl object reference

=head1 DESCRIPTION

This document provides a reference for Perl's object orientation
features. If you're looking for an introduction to object-oriented
programming in Perl, please see L<perlootut>.

In order to understand Perl objects, you first need to understand
references in Perl. See L<perlref> for details.

This document describes all of Perl's object-oriented (OO) features
from the ground up. If you're just looking to write some
object-oriented code of your own, you are probably better served by
using one of the object systems from CPAN described in L<perlootut>.

If you're looking to write your own object system, or you need to
maintain code which implements objects from scratch then this document
will help you understand exactly how Perl does object orientation.

There are a few basic principles which define object oriented Perl:

=over 4

=item 1.

An object is simply a data structure that knows to which class it
belongs.

=item 2.

A class is simply a package. A class provides methods that expect to
operate on objects.

=item 3.

A method is simply a subroutine that expects a reference to an object
(or a package name, for class methods) as the first argument.

=back

Let's look at each of these principles in depth.

=head2 An Object is Simply a Data Structure
X<object> X<bless> X<constructor> X<new>

Unlike many other languages which support object orientation, Perl does
not provide any special syntax for constructing an object. Objects are
merely Perl data structures (hashes, arrays, scalars, filehandles,
etc.) that have been explicitly associated with a particular class.

That explicit association is created by the built-in C<bless> function,
which is typically used within the I<constructor> subroutine of the
class.

Here is a simple constructor:

  package File;

  sub new {
      my $class = shift;

      return bless {}, $class;
  }

The name C<new> isn't special. We could name our constructor something
else:

  package File;

  sub load {
      my $class = shift;

      return bless {}, $class;
  }

The modern convention for OO modules is to always use C<new> as the
name for the constructor, but there is no requirement to do so. Any
subroutine that blesses a data structure into a class is a valid
constructor in Perl.

In the previous examples, the C<{}> code creates a reference to an
empty anonymous hash. The C<bless> function then takes that reference
and associates the hash with the class in C<$class>. In the simplest
case, the C<$class> variable will end up containing the string "File".

We can also use a variable to store a reference to the data structure
that is being blessed as our object:

  sub new {
      my $class = shift;

      my $self = {};
      bless $self, $class;

      return $self;
  }

Once we've blessed the hash referred to by C<$self> we can start
calling methods on it. This is useful if you want to put object
initialization in its own separate method:

  sub new {
      my $class = shift;

      my $self = {};
      bless $self, $class;

      $self->_initialize();

      return $self;
  }

Since the object is also a hash, you can treat it as one, using it to
store data associated with the object. Typically, code inside the class
can treat the hash as an accessible data structure, while code outside
the class should always treat the object as opaque. This is called
B<encapsulation>. Encapsulation means that the user of an object does
not have to know how it is implemented. The user simply calls
documented methods on the object.

Note, however, that (unlike most other OO languages) Perl does not
ensure or enforce encapsulation in any way. If you want objects to
actually I<be> opaque you need to arrange for that yourself. This can
be done in a variety of ways, including using L<"Inside-Out objects">
or modules from CPAN.

=head3 Objects Are Blessed; Variables Are Not

When we bless something, we are not blessing the variable which
contains a reference to that thing, nor are we blessing the reference
that the variable stores; we are blessing the thing that the variable
refers to (sometimes known as the I<referent>). This is best
demonstrated with this code:

  use Scalar::Util 'blessed';

  my $foo = {};
  my $bar = $foo;

  bless $foo, 'Class';
  print blessed( $bar ) // 'not blessed';    # prints "Class"

  $bar = "some other value";
  print blessed( $bar ) // 'not blessed';    # prints "not blessed"

When we call C<bless> on a variable, we are actually blessing the
underlying data structure that the variable refers to. We are not
blessing the reference itself, nor the variable that contains that
reference. That's why the second call to C<blessed( $bar )> returns
false. At that point C<$bar> is no longer storing a reference to an
object.

You will sometimes see older books or documentation mention "blessing a
reference" or describe an object as a "blessed reference", but this is
incorrect. It isn't the reference that is blessed as an object; it's
the thing the reference refers to (i.e. the referent).

=head2 A Class is Simply a Package
X<class> X<package> X<@@ISA> X<inheritance>

Perl does not provide any special syntax for class definitions. A
package is simply a namespace containing variables and subroutines. The
only difference is that in a class, the subroutines may expect a
reference to an object or the name of a class as the first argument.
This is purely a matter of convention, so a class may contain both
methods and subroutines which I<don't> operate on an object or class.

Each package contains a special array called C<@@ISA>. The C<@@ISA> array
contains a list of that class's parent classes, if any. This array is
examined when Perl does method resolution, which we will cover later.

It is possible to manually set C<@@ISA>, and you may see this in older
Perl code. Much older code also uses the L<base> pragma. For new code,
we recommend that you use the L<parent> pragma to declare your parents.
This pragma will take care of setting C<@@ISA>. It will also load the
parent classes and make sure that the package doesn't inherit from
itself.

However the parent classes are set, the package's C<@@ISA> variable will
contain a list of those parents. This is simply a list of scalars, each
of which is a string that corresponds to a package name.

All classes inherit from the L<UNIVERSAL> class implicitly. The
L<UNIVERSAL> class is implemented by the Perl core, and provides
several default methods, such as C<isa()>, C<can()>, and C<VERSION()>.
The C<UNIVERSAL> class will I<never> appear in a package's C<@@ISA>
variable.

Perl I<only> provides method inheritance as a built-in feature.
Attribute inheritance is left up the class to implement. See the
L</Writing Accessors> section for details.

=head2 A Method is Simply a Subroutine
X<method>

Perl does not provide any special syntax for defining a method. A
method is simply a regular subroutine, and is declared with C<sub>.
What makes a method special is that it expects to receive either an
object or a class name as its first argument.

Perl I<does> provide special syntax for method invocation, the C<< ->
>> operator. We will cover this in more detail later.

Most methods you write will expect to operate on objects:

  sub save {
      my $self = shift;

      open my $fh, '>', $self->path() or die $!;
      print {$fh} $self->data()       or die $!;
      close $fh                       or die $!;
  }

=head2 Method Invocation
X<invocation> X<method> X<arrow> X<< -> >>

Calling a method on an object is written as C<< $object->method >>.

The left hand side of the method invocation (or arrow) operator is the
object (or class name), and the right hand side is the method name.

  my $pod = File->new( 'perlobj.pod', $data );
  $pod->save();

The C<< -> >> syntax is also used when dereferencing a reference. It
looks like the same operator, but these are two different operations.

When you call a method, the thing on the left side of the arrow is
passed as the first argument to the method. That means when we call C<<
Critter->new() >>, the C<new()> method receives the string C<"Critter">
as its first argument. When we call C<< $fred->speak() >>, the C<$fred>
variable is passed as the first argument to C<speak()>.

Just as with any Perl subroutine, all of the arguments passed in C<@@_>
are aliases to the original argument. This includes the object itself.
If you assign directly to C<$_[0]> you will change the contents of the
variable that holds the reference to the object. We recommend that you
don't do this unless you know exactly what you're doing.

Perl knows what package the method is in by looking at the left side of
the arrow. If the left hand side is a package name, it looks for the
method in that package. If the left hand side is an object, then Perl
looks for the method in the package that the object has been blessed
into.

If the left hand side is neither a package name nor an object, then the
method call will cause an error, but see the section on L</Method Call
Variations> for more nuances.

=head2 Inheritance
X<inheritance>

We already talked about the special C<@@ISA> array and the L<parent>
pragma.

When a class inherits from another class, any methods defined in the
parent class are available to the child class. If you attempt to call a
method on an object that isn't defined in its own class, Perl will also
look for that method in any parent classes it may have.

  package File::MP3;
  use parent 'File';    # sets @@File::MP3::ISA = ('File');

  my $mp3 = File::MP3->new( 'Andvari.mp3', $data );
  $mp3->save();

Since we didn't define a C<save()> method in the C<File::MP3> class,
Perl will look at the C<File::MP3> class's parent classes to find the
C<save()> method. If Perl cannot find a C<save()> method anywhere in
the inheritance hierarchy, it will die.

In this case, it finds a C<save()> method in the C<File> class. Note
that the object passed to C<save()> in this case is still a
C<File::MP3> object, even though the method is found in the C<File>
class.

We can override a parent's method in a child class. When we do so, we
can still call the parent class's method with the C<SUPER>
pseudo-class.

  sub save {
      my $self = shift;

      say 'Prepare to rock';
      $self->SUPER::save();
  }

The C<SUPER> modifier can I<only> be used for method calls. You can't
use it for regular subroutine calls or class methods:

  SUPER::save($thing);     # FAIL: looks for save() sub in package SUPER

  SUPER->save($thing);     # FAIL: looks for save() method in class
                           #       SUPER

  $thing->SUPER::save();   # Okay: looks for save() method in parent
                           #       classes


=head3 How SUPER is Resolved
X<SUPER>

The C<SUPER> pseudo-class is resolved from the package where the call
is made. It is I<not> resolved based on the object's class. This is
important, because it lets methods at different levels within a deep
inheritance hierarchy each correctly call their respective parent
methods.

  package A;

  sub new {
      return bless {}, shift;
  }

  sub speak {
      my $self = shift;

      say 'A';
  }

  package B;

  use parent -norequire, 'A';

  sub speak {
      my $self = shift;

      $self->SUPER::speak();

      say 'B';
  }

  package C;

  use parent -norequire, 'B';

  sub speak {
      my $self = shift;

      $self->SUPER::speak();

      say 'C';
  }

  my $c = C->new();
  $c->speak();

In this example, we will get the following output:

  A
  B
  C

This demonstrates how C<SUPER> is resolved. Even though the object is
blessed into the C<C> class, the C<speak()> method in the C<B> class
can still call C<SUPER::speak()> and expect it to correctly look in the
parent class of C<B> (i.e the class the method call is in), not in the
parent class of C<C> (i.e. the class the object belongs to).

There are rare cases where this package-based resolution can be a
problem. If you copy a subroutine from one package to another, C<SUPER>
resolution will be done based on the original package.

=head3 Multiple Inheritance
X<multiple inheritance>

Multiple inheritance often indicates a design problem, but Perl always
gives you enough rope to hang yourself with if you ask for it.

To declare multiple parents, you simply need to pass multiple class
names to C<use parent>:

  package MultiChild;

  use parent 'Parent1', 'Parent2';

=head3 Method Resolution Order
X<method resolution order> X<mro>

Method resolution order only matters in the case of multiple
inheritance. In the case of single inheritance, Perl simply looks up
the inheritance chain to find a method:

  Grandparent
    |
  Parent
    |
  Child

If we call a method on a C<Child> object and that method is not defined
in the C<Child> class, Perl will look for that method in the C<Parent>
class and then, if necessary, in the C<Grandparent> class.

If Perl cannot find the method in any of these classes, it will die
with an error message.

When a class has multiple parents, the method lookup order becomes more
complicated.

By default, Perl does a depth-first left-to-right search for a method.
That means it starts with the first parent in the C<@@ISA> array, and
then searches all of its parents, grandparents, etc. If it fails to
find the method, it then goes to the next parent in the original
class's C<@@ISA> array and searches from there.

            SharedGreatGrandParent
            /                    \
  PaternalGrandparent       MaternalGrandparent
            \                    /
             Father        Mother
                   \      /
                    Child

So given the diagram above, Perl will search C<Child>, C<Father>,
C<PaternalGrandparent>, C<SharedGreatGrandParent>, C<Mother>, and
finally C<MaternalGrandparent>. This may be a problem because now we're
looking in C<SharedGreatGrandParent> I<before> we've checked all its
derived classes (i.e. before we tried C<Mother> and
C<MaternalGrandparent>).

It is possible to ask for a different method resolution order with the
L<mro> pragma.

  package Child;

  use mro 'c3';
  use parent 'Father', 'Mother';

This pragma lets you switch to the "C3" resolution order. In simple
terms, "C3" order ensures that shared parent classes are never searched
before child classes, so Perl will now search: C<Child>, C<Father>,
C<PaternalGrandparent>, C<Mother> C<MaternalGrandparent>, and finally
C<SharedGreatGrandParent>. Note however that this is not
"breadth-first" searching: All the C<Father> ancestors (except the
common ancestor) are searched before any of the C<Mother> ancestors are
considered.

The C3 order also lets you call methods in sibling classes with the
C<next> pseudo-class. See the L<mro> documentation for more details on
this feature.

=head3 Method Resolution Caching

When Perl searches for a method, it caches the lookup so that future
calls to the method do not need to search for it again. Changing a
class's parent class or adding subroutines to a class will invalidate
the cache for that class.

The L<mro> pragma provides some functions for manipulating the method
cache directly.

=head2 Writing Constructors
X<constructor>

As we mentioned earlier, Perl provides no special constructor syntax.
This means that a class must implement its own constructor. A
constructor is simply a class method that returns a reference to a new
object.

The constructor can also accept additional parameters that define the
object. Let's write a real constructor for the C<File> class we used
earlier:

  package File;

  sub new {
      my $class = shift;
      my ( $path, $data ) = @@_;

      my $self = bless {
          path => $path,
          data => $data,
      }, $class;

      return $self;
  }

As you can see, we've stored the path and file data in the object
itself. Remember, under the hood, this object is still just a hash.
Later, we'll write accessors to manipulate this data.

For our File::MP3 class, we can check to make sure that the path we're
given ends with ".mp3":

  package File::MP3;

  sub new {
      my $class = shift;
      my ( $path, $data ) = @@_;

      die "You cannot create a File::MP3 without an mp3 extension\n"
          unless $path =~ /\.mp3\z/;

      return $class->SUPER::new(@@_);
  }

This constructor lets its parent class do the actual object
construction.

=head2 Attributes
X<attribute>

An attribute is a piece of data belonging to a particular object.
Unlike most object-oriented languages, Perl provides no special syntax
or support for declaring and manipulating attributes.

Attributes are often stored in the object itself. For example, if the
object is an anonymous hash, we can store the attribute values in the
hash using the attribute name as the key.

While it's possible to refer directly to these hash keys outside of the
class, it's considered a best practice to wrap all access to the
attribute with accessor methods.

This has several advantages. Accessors make it easier to change the
implementation of an object later while still preserving the original
API.

An accessor lets you add additional code around attribute access. For
example, you could apply a default to an attribute that wasn't set in
the constructor, or you could validate that a new value for the
attribute is acceptable.

Finally, using accessors makes inheritance much simpler. Subclasses can
use the accessors rather than having to know how a parent class is
implemented internally.

=head3 Writing Accessors
X<accessor>

As with constructors, Perl provides no special accessor declaration
syntax, so classes must provide explicitly written accessor methods.
There are two common types of accessors, read-only and read-write.

A simple read-only accessor simply gets the value of a single
attribute:

  sub path {
      my $self = shift;

      return $self->{path};
  }

A read-write accessor will allow the caller to set the value as well as
get it:

  sub path {
      my $self = shift;

      if (@@_) {
          $self->{path} = shift;
      }

      return $self->{path};
  }

=head2 An Aside About Smarter and Safer Code

Our constructor and accessors are not very smart. They don't check that
a C<$path> is defined, nor do they check that a C<$path> is a valid
filesystem path.

Doing these checks by hand can quickly become tedious. Writing a bunch
of accessors by hand is also incredibly tedious. There are a lot of
modules on CPAN that can help you write safer and more concise code,
including the modules we recommend in L<perlootut>.

=head2 Method Call Variations
X<method>

Perl supports several other ways to call methods besides the C<<
$object->method() >> usage we've seen so far.

=head3 Method Names as Strings

Perl lets you use a scalar variable containing a string as a method
name:

  my $file = File->new( $path, $data );

  my $method = 'save';
  $file->$method();

This works exactly like calling C<< $file->save() >>. This can be very
useful for writing dynamic code. For example, it allows you to pass a
method name to be called as a parameter to another method.

=head3 Class Names as Strings

Perl also lets you use a scalar containing a string as a class name:

  my $class = 'File';

  my $file = $class->new( $path, $data );

Again, this allows for very dynamic code.

=head3 Subroutine References as Methods

You can also use a subroutine reference as a method:

  my $sub = sub {
      my $self = shift;

      $self->save();
  };

  $file->$sub();

This is exactly equivalent to writing C<< $sub->($file) >>. You may see
this idiom in the wild combined with a call to C<can>:

  if ( my $meth = $object->can('foo') ) {
      $object->$meth();
  }

=head3 Deferencing Method Call

Perl also lets you use a dereferenced scalar reference in a method
call. That's a mouthful, so let's look at some code:

  $file->${ \'save' };
  $file->${ returns_scalar_ref() };
  $file->${ \( returns_scalar() ) };
  $file->${ returns_ref_to_sub_ref() };

This works if the dereference produces a string I<or> a subroutine
reference.

=head3 Method Calls on Filehandles

Under the hood, Perl filehandles are instances of the C<IO::Handle> or
C<IO::File> class. Once you have an open filehandle, you can call
methods on it. Additionally, you can call methods on the C<STDIN>,
C<STDOUT>, and C<STDERR> filehandles.

  open my $fh, '>', 'path/to/file';
  $fh->autoflush();
  $fh->print('content');

  STDOUT->autoflush();

=head2 Invoking Class Methods
X<invocation>

Because Perl allows you to use barewords for package names and
subroutine names, it sometimes interprets a bareword's meaning
incorrectly. For example, the construct C<< Class->new() >> can be
interpreted as either C<< 'Class'->new() >> or C<< Class()->new() >>.
In English, that second interpretation reads as "call a subroutine
named Class(), then call new() as a method on the return value of
Class()". If there is a subroutine named C<Class()> in the current
namespace, Perl will always interpret C<< Class->new() >> as the second
alternative: a call to C<new()> on the object  returned by a call to
C<Class()>

You can force Perl to use the first interpretation (i.e. as a method
call on the class named "Class") in two ways. First, you can append a
C<::> to the class name:

    Class::->new()

Perl will always interpret this as a method call.

Alternatively, you can quote the class name:

    'Class'->new()

Of course, if the class name is in a scalar Perl will do the right
thing as well:

    my $class = 'Class';
    $class->new();

=head3 Indirect Object Syntax
X<indirect object>

B<Outside of the file handle case, use of this syntax is discouraged as
it can confuse the Perl interpreter. See below for more details.>

Perl supports another method invocation syntax called "indirect object"
notation. This syntax is called "indirect" because the method comes
before the object it is being invoked on.

This syntax can be used with any class or object method:

    my $file = new File $path, $data;
    save $file;

We recommend that you avoid this syntax, for several reasons.

First, it can be confusing to read. In the above example, it's not
clear if C<save> is a method provided by the C<File> class or simply a
subroutine that expects a file object as its first argument.

When used with class methods, the problem is even worse. Because Perl
allows subroutine names to be written as barewords, Perl has to guess
whether the bareword after the method is a class name or subroutine
name. In other words, Perl can resolve the syntax as either C<<
File->new( $path, $data ) >> B<or> C<< new( File( $path, $data ) ) >>.

To parse this code, Perl uses a heuristic based on what package names
it has seen, what subroutines exist in the current package, what
barewords it has previously seen, and other input. Needless to say,
heuristics can produce very surprising results!

Older documentation (and some CPAN modules) encouraged this syntax,
particularly for constructors, so you may still find it in the wild.
However, we encourage you to avoid using it in new code.

You can force Perl to interpret the bareword as a class name by
appending "::" to it, like we saw earlier:

  my $file = new File:: $path, $data;

=head2 C<bless>, C<blessed>, and C<ref>

As we saw earlier, an object is simply a data structure that has been
blessed into a class via the C<bless> function. The C<bless> function
can take either one or two arguments:

  my $object = bless {}, $class;
  my $object = bless {};

In the first form, the anonymous hash is being blessed into the class
in C<$class>. In the second form, the anonymous hash is blessed into
the current package.

The second form is strongly discouraged, because it breaks the ability
of a subclass to reuse the parent's constructor, but you may still run
across it in existing code.

If you want to know whether a particular scalar refers to an object,
you can use the C<blessed> function exported by L<Scalar::Util>, which
is shipped with the Perl core.

  use Scalar::Util 'blessed';

  if ( defined blessed($thing) ) { ... }

If C<$thing> refers to an object, then this function returns the name
of the package the object has been blessed into. If C<$thing> doesn't
contain a reference to a blessed object, the C<blessed> function
returns C<undef>.

Note that C<blessed($thing)> will also return false if C<$thing> has
been blessed into a class named "0". This is a possible, but quite
pathological. Don't create a class named "0" unless you know what
you're doing.

Similarly, Perl's built-in C<ref> function treats a reference to a
blessed object specially. If you call C<ref($thing)> and C<$thing>
holds a reference to an object, it will return the name of the class
that the object has been blessed into.

If you simply want to check that a variable contains an object
reference, we recommend that you use C<defined blessed($object)>, since
C<ref> returns true values for all references, not just objects.

=head2 The UNIVERSAL Class
X<UNIVERSAL>

All classes automatically inherit from the L<UNIVERSAL> class, which is
built-in to the Perl core. This class provides a number of methods, all
of which can be called on either a class or an object. You can also
choose to override some of these methods in your class. If you do so,
we recommend that you follow the built-in semantics described below.

=over 4

=item isa($class)
X<isa>

The C<isa> method returns I<true> if the object is a member of the
class in C<$class>, or a member of a subclass of C<$class>.

If you override this method, it should never throw an exception.

=item DOES($role)
X<DOES>

The C<DOES> method returns I<true> if its object claims to perform the
role C<$role>. By default, this is equivalent to C<isa>. This method is
provided for use by object system extensions that implement roles, like
C<Moose> and C<Role::Tiny>.

You can also override C<DOES> directly in your own classes. If you
override this method, it should never throw an exception.

=item can($method)
X<can>

The C<can> method checks to see if the class or object it was called on
has a method named C<$method>. This checks for the method in the class
and all of its parents. If the method exists, then a reference to the
subroutine is returned. If it does not then C<undef> is returned.

If your class responds to method calls via C<AUTOLOAD>, you may want to
overload C<can> to return a subroutine reference for methods which your
C<AUTOLOAD> method handles.

If you override this method, it should never throw an exception.

=item VERSION($need)
X<VERSION>

The C<VERSION> method returns the version number of the class
(package).

If the C<$need> argument is given then it will check that the current
version (as defined by the $VERSION variable in the package) is greater
than or equal to C<$need>; it will die if this is not the case. This
method is called automatically by the C<VERSION> form of C<use>.

    use Package 1.2 qw(some imported subs);
    # implies:
    Package->VERSION(1.2);

We recommend that you use this method to access another package's
version, rather than looking directly at C<$Package::VERSION>. The
package you are looking at could have overridden the C<VERSION> method.

We also recommend using this method to check whether a module has a
sufficient version. The internal implementation uses the L<version>
module to make sure that different types of version numbers are
compared correctly.

=back

=head2 AUTOLOAD
X<AUTOLOAD>

If you call a method that doesn't exist in a class, Perl will throw an
error. However, if that class or any of its parent classes defines an
C<AUTOLOAD> method, that C<AUTOLOAD> method is called instead.

C<AUTOLOAD> is called as a regular method, and the caller will not know
the difference. Whatever value your C<AUTOLOAD> method returns is
returned to the caller.

The fully qualified method name that was called is available in the
C<$AUTOLOAD> package global for your class. Since this is a global, if
you want to refer to do it without a package name prefix under C<strict
'vars'>, you need to declare it.

  # XXX - this is a terrible way to implement accessors, but it makes
  # for a simple example.
  our $AUTOLOAD;
  sub AUTOLOAD {
      my $self = shift;

      # Remove qualifier from original method name...
      my $called =  $AUTOLOAD =~ s/.*:://r;

      # Is there an attribute of that name?
      die "No such attribute: $called"
          unless exists $self->{$called};

      # If so, return it...
      return $self->{$called};
  }

  sub DESTROY { } # see below

Without the C<our $AUTOLOAD> declaration, this code will not compile
under the L<strict> pragma.

As the comment says, this is not a good way to implement accessors.
It's slow and too clever by far. However, you may see this as a way to
provide accessors in older Perl code. See L<perlootut> for
recommendations on OO coding in Perl.

If your class does have an C<AUTOLOAD> method, we strongly recommend
that you override C<can> in your class as well. Your overridden C<can>
method should return a subroutine reference for any method that your
C<AUTOLOAD> responds to.

=head2 Destructors
X<destructor> X<DESTROY>

When the last reference to an object goes away, the object is
destroyed. If you only have one reference to an object stored in a
lexical scalar, the object is destroyed when that scalar goes out of
scope. If you store the object in a package global, that object may not
go out of scope until the program exits.

If you want to do something when the object is destroyed, you can
define a C<DESTROY> method in your class. This method will always be
called by Perl at the appropriate time, unless the method is empty.

This is called just like any other method, with the object as the first
argument. It does not receive any additional arguments. However, the
C<$_[0]> variable will be read-only in the destructor, so you cannot
assign a value to it.

If your C<DESTROY> method throws an error, this error will be ignored.
It will not be sent to C<STDERR> and it will not cause the program to
die. However, if your destructor is running inside an C<eval {}> block,
then the error will change the value of C<$@@>.

Because C<DESTROY> methods can be called at any time, you should
localize any global variables you might update in your C<DESTROY>. In
particular, if you use C<eval {}> you should localize C<$@@>, and if you
use C<system> or backticks you should localize C<$?>.

If you define an C<AUTOLOAD> in your class, then Perl will call your
C<AUTOLOAD> to handle the C<DESTROY> method. You can prevent this by
defining an empty C<DESTROY>, like we did in the autoloading example.
You can also check the value of C<$AUTOLOAD> and return without doing
anything when called to handle C<DESTROY>.

=head3 Global Destruction

The order in which objects are destroyed during the global destruction
before the program exits is unpredictable. This means that any objects
contained by your object may already have been destroyed. You should
check that a contained object is defined before calling a method on it:

  sub DESTROY {
      my $self = shift;

      $self->{handle}->close() if $self->{handle};
  }

You can use the C<${^GLOBAL_PHASE}> variable to detect if you are
currently in the global destruction phase:

  sub DESTROY {
      my $self = shift;

      return if ${^GLOBAL_PHASE} eq 'DESTRUCT';

      $self->{handle}->close();
  }

Note that this variable was added in Perl 5.14.0. If you want to detect
the global destruction phase on older versions of Perl, you can use the
C<Devel::GlobalDestruction> module on CPAN.

If your C<DESTROY> method issues a warning during global destruction,
the Perl interpreter will append the string " during global
destruction" to the warning.

During global destruction, Perl will always garbage collect objects
before unblessed references. See L<perlhacktips/PERL_DESTRUCT_LEVEL>
for more information about global destruction.

=head2 Non-Hash Objects

All the examples so far have shown objects based on a blessed hash.
However, it's possible to bless any type of data structure or referent,
including scalars, globs, and subroutines. You may see this sort of
thing when looking at code in the wild.

Here's an example of a module as a blessed scalar:

  package Time;

  use strict;
  use warnings;

  sub new {
      my $class = shift;

      my $time = time;
      return bless \$time, $class;
  }

  sub epoch {
      my $self = shift;
      return ${ $self };
  }

  my $time = Time->new();
  print $time->epoch();

=head2 Inside-Out objects

In the past, the Perl community experimented with a technique called
"inside-out objects". An inside-out object stores its data outside of
the object's reference, indexed on a unique property of the object,
such as its memory address, rather than in the object itself. This has
the advantage of enforcing the encapsulation of object attributes,
since their data is not stored in the object itself.

This technique was popular for a while (and was recommended in Damian
Conway's I<Perl Best Practices>), but never achieved universal
adoption. The L<Object::InsideOut> module on CPAN provides a
comprehensive implementation of this technique, and you may see it or
other inside-out modules in the wild.

Here is a simple example of the technique, using the
L<Hash::Util::FieldHash> core module. This module was added to the core
to support inside-out object implementations.

  package Time;

  use strict;
  use warnings;

  use Hash::Util::FieldHash 'fieldhash';

  fieldhash my %time_for;

  sub new {
      my $class = shift;

      my $self = bless \( my $object ), $class;

      $time_for{$self} = time;

      return $self;
  }

  sub epoch {
      my $self = shift;

      return $time_for{$self};
  }

  my $time = Time->new;
  print $time->epoch;

=head2 Pseudo-hashes

The pseudo-hash feature was an experimental feature introduced in
earlier versions of Perl and removed in 5.10.0. A pseudo-hash is an
array reference which can be accessed using named keys like a hash. You
may run in to some code in the wild which uses it. See the L<fields>
pragma for more information.

=head1 SEE ALSO

A kinder, gentler tutorial on object-oriented programming in Perl can
be found in L<perlootut>. You should also check out L<perlmodlib> for
some style guides on constructing both modules and classes.

@


1.15
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d151 1
a151 1
  print blessed( $bar );      # prints "Class"
d154 1
a154 1
  print blessed( $bar );      # prints undef
d952 1
a952 1
destruction" the warning.
@


1.14
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d134 1
a134 1
be done in a varierty of ways, including using L<"Inside-Out objects">
d691 1
a691 1
Perl suports another method invocation syntax called "indirect object"
@


1.13
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d185 1
a185 1
This pragma will take care of setting C<@@ISA>.  It will also load the
d235 1
a235 1
The C<< -> >> syntax is also used when dereferencing a reference.  It
a327 2
      $self->SUPER::speak();

d333 1
a333 1
  use parent 'A';
d345 1
a345 1
  use parent 'B';
d635 1
a635 1
  $file->${ returns_sub_ref() };
d688 2
a689 2
B<Outside of the file handle case, use of this syntax is discouraged,
as it can confuse the Perl interpreter. See below for more details.>
d878 1
a878 1
As the comment says, this is not a good way to implement accessors. 
d914 1
a914 1
use C<system> or backticks, you should localize C<$?>.
@


1.12
log
@merge in perl 5.12.2 plus local changes
@
text
@d1 6
d10 1
a10 1
perlobj - Perl objects
d14 15
a28 4
First you need to understand what references are in Perl.
See L<perlref> for that.  Second, if you still find the following
reference work too complicated, a tutorial on object-oriented programming
in Perl can be found in L<perltoot> and L<perltooc>.
d30 1
a30 2
If you're still with us, then
here are three very simple definitions that you should find reassuring.
d36 2
a37 2
An object is simply a reference that happens to know which class it
belongs to.
d41 2
a42 2
A class is simply a package that happens to provide methods to deal
with object references.
d46 2
a47 2
A method is simply a subroutine that expects an object reference (or
a package name, for class methods) as the first argument.
d51 1
a51 1
We'll cover these points now in more depth.
d53 1
a53 1
=head2 An Object is Simply a Reference
d56 42
a97 99
Unlike say C++, Perl doesn't provide any special syntax for
constructors.  A constructor is merely a subroutine that returns a
reference to something "blessed" into a class, generally the
class that the subroutine is defined in.  Here is a typical
constructor:

    package Critter;
    sub new { bless {} }

That word C<new> isn't special.  You could have written
a construct this way, too:

    package Critter;
    sub spawn { bless {} }

This might even be preferable, because the C++ programmers won't
be tricked into thinking that C<new> works in Perl as it does in C++.
It doesn't.  We recommend that you name your constructors whatever
makes sense in the context of the problem you're solving.  For example,
constructors in the Tk extension to Perl are named after the widgets
they create.

One thing that's different about Perl constructors compared with those in
C++ is that in Perl, they have to allocate their own memory.  (The other
things is that they don't automatically call overridden base-class
constructors.)  The C<{}> allocates an anonymous hash containing no
key/value pairs, and returns it  The bless() takes that reference and
tells the object it references that it's now a Critter, and returns
the reference.  This is for convenience, because the referenced object
itself knows that it has been blessed, and the reference to it could
have been returned directly, like this:

    sub new {
	my $self = {};
	bless $self;
	return $self;
    }

You often see such a thing in more complicated constructors
that wish to call methods in the class as part of the construction:

    sub new {
	my $self = {};
	bless $self;
	$self->initialize();
	return $self;
    }

If you care about inheritance (and you should; see
L<perlmodlib/"Modules: Creation, Use, and Abuse">),
then you want to use the two-arg form of bless
so that your constructors may be inherited:

    sub new {
	my $class = shift;
	my $self = {};
	bless $self, $class;
	$self->initialize();
	return $self;
    }

Or if you expect people to call not just C<< CLASS->new() >> but also
C<< $obj->new() >>, then use something like the following.  (Note that using
this to call new() on an instance does not automatically perform any
copying.  If you want a shallow or deep copy of an object, you'll have to
specifically allow for that.)  The initialize() method used will be of
whatever $class we blessed the object into:

    sub new {
	my $this = shift;
	my $class = ref($this) || $this;
	my $self = {};
	bless $self, $class;
	$self->initialize();
	return $self;
    }

Within the class package, the methods will typically deal with the
reference as an ordinary reference.  Outside the class package,
the reference is generally treated as an opaque value that may
be accessed only through the class's methods.

Although a constructor can in theory re-bless a referenced object
currently belonging to another class, this is almost certainly going
to get you into trouble.  The new class is responsible for all
cleanup later.  The previous blessing is forgotten, as an object
may belong to only one class at a time.  (Although of course it's
free to inherit methods from many classes.)  If you find yourself
having to do this, the parent class is probably misbehaving, though.

A clarification:  Perl objects are blessed.  References are not.  Objects
know which package they belong to.  References do not.  The bless()
function uses the reference to find the object.  Consider
the following example:

    $a = {};
    $b = $a;
    bless $a, BLAH;
    print "\$b is a ", ref($b), "\n";
d99 2
a100 2
This reports $b as being a BLAH, so obviously bless()
operated on the object and not on the reference.
d102 47
a148 2
=head2 A Class is Simply a Package
X<class> X<package> X<@@ISA> X<inheritance>
d150 2
a151 30
Unlike say C++, Perl doesn't provide any special syntax for class
definitions.  You use a package as a class by putting method
definitions into the class.

There is a special array within each package called @@ISA, which says
where else to look for a method if you can't find it in the current
package.  This is how Perl implements inheritance.  Each element of the
@@ISA array is just the name of another package that happens to be a
class package.  The classes are searched for missing methods in
depth-first, left-to-right order by default (see L<mro> for alternative
search order and other in-depth information).  The classes accessible
through @@ISA are known as base classes of the current class.

All classes implicitly inherit from class C<UNIVERSAL> as their
last base class.  Several commonly used methods are automatically
supplied in the UNIVERSAL class; see L<"Default UNIVERSAL methods"> or
L<UNIVERSAL|UNIVERSAL> for more details.
X<UNIVERSAL> X<base class> X<class, base>

If a missing method is found in a base class, it is cached
in the current class for efficiency.  Changing @@ISA or defining new
subroutines invalidates the cache and causes Perl to do the lookup again.

If neither the current class, its named base classes, nor the UNIVERSAL
class contains the requested method, these three places are searched
all over again, this time looking for a method named AUTOLOAD().  If an
AUTOLOAD is found, this method is called on behalf of the missing method,
setting the package global $AUTOLOAD to be the fully qualified name of
the method that was intended to be called.
X<AUTOLOAD>
d153 2
a154 1
If none of that works, Perl finally gives up and complains.
d156 6
a161 2
If you want to stop the AUTOLOAD inheritance say simply
X<AUTOLOAD>
d163 4
a166 1
	sub AUTOLOAD;
d168 2
a169 1
and the call will die using the name of the sub being called.
d171 31
a201 14
Perl classes do method inheritance only.  Data inheritance is left up
to the class itself.  By and large, this is not a problem in Perl,
because most classes model the attributes of their object using an
anonymous hash, which serves as its own little namespace to be carved up
by the various classes that might want to do something with the object.
The only problem with this is that you can't sure that you aren't using
a piece of the hash that isn't already used.  A reasonable workaround
is to prepend your fieldname in the hash with the package name.
X<inheritance, method> X<inheritance, data>

    sub bump {
	my $self = shift;
	$self->{ __PACKAGE__ . ".count"}++;
    } 
d206 17
a222 34
Unlike say C++, Perl doesn't provide any special syntax for method
definition.  (It does provide a little syntax for method invocation
though.  More on that later.)  A method expects its first argument
to be the object (reference) or package (string) it is being invoked
on.  There are two ways of calling methods, which we'll call class
methods and instance methods.  

A class method expects a class name as the first argument.  It
provides functionality for the class as a whole, not for any
individual object belonging to the class.  Constructors are often
class methods, but see L<perltoot> and L<perltooc> for alternatives.
Many class methods simply ignore their first argument, because they
already know what package they're in and don't care what package
they were invoked via.  (These aren't necessarily the same, because
class methods follow the inheritance tree just like ordinary instance
methods.)  Another typical use for class methods is to look up an
object by name:

    sub find {
	my ($class, $name) = @@_;
	$objtable{$name};
    }

An instance method expects an object reference as its first argument.
Typically it shifts the first argument into a "self" or "this" variable,
and then uses that as an ordinary reference.

    sub display {
	my $self = shift;
	my @@keys = @@_ ? @@_ : sort keys %$self;
	foreach $key (@@keys) {
	    print "\t$key => $self->{$key}\n";
	}
    }
d227 84
a310 39
For various historical and other reasons, Perl offers two equivalent
ways to write a method call.  The simpler and more common way is to use
the arrow notation:

    my $fred = Critter->find("Fred");
    $fred->display("Height", "Weight");

You should already be familiar with the use of the C<< -> >> operator with
references.  In fact, since C<$fred> above is a reference to an object,
you could think of the method call as just another form of
dereferencing.

Whatever is on the left side of the arrow, whether a reference or a
class name, is passed to the method subroutine as its first argument.
So the above code is mostly equivalent to:

    my $fred = Critter::find("Critter", "Fred");
    Critter::display($fred, "Height", "Weight");

How does Perl know which package the subroutine is in?  By looking at
the left side of the arrow, which must be either a package name or a
reference to an object, i.e. something that has been blessed to a
package.  Either way, that's the package where Perl starts looking.  If
that package has no subroutine with that name, Perl starts looking for
it in any base classes of that package, and so on.

If you need to, you I<can> force Perl to start looking in some other package:

    my $barney = MyCritter->Critter::find("Barney");
    $barney->Critter::display("Height", "Weight");

Here C<MyCritter> is presumably a subclass of C<Critter> that defines
its own versions of find() and display().  We haven't specified what
those methods do, but that doesn't matter above since we've forced Perl
to start looking for the subroutines in C<Critter>.

As a special case of the above, you may use the C<SUPER> pseudo-class to
tell Perl to start looking for the method in the packages named in the
current class's C<@@ISA> list.  
d313 189
a501 2
    package MyCritter;
    use base 'Critter';    # sets @@MyCritter::ISA = ('Critter');
d503 177
a679 11
    sub display { 
        my ($self, @@args) = @@_;
        $self->SUPER::display("Name", @@args);
    }

It is important to note that C<SUPER> refers to the superclass(es) of the
I<current package> and not to the superclass(es) of the object. Also, the
C<SUPER> pseudo-class can only currently be used as a modifier to a method
name, but not in any of the other ways that class names are normally used,
eg:
X<SUPER>
d681 2
a682 3
    something->SUPER::method(...);	# OK
    SUPER::method(...);			# WRONG
    SUPER->method(...);			# WRONG
d684 2
a685 3
Instead of a class name or an object reference, you can also use any
expression that returns either of those on the left side of the arrow.
So the following statement is valid:
d687 2
a688 1
    Critter->find("Fred")->display("Height", "Weight");
d690 2
a691 1
and so is the following:
d693 3
a695 1
    my $fred = (reverse "rettirC")->find(reverse "derF");
d697 1
a697 3
The right side of the arrow typically is the method name, but a simple 
scalar variable containing either the method name or a subroutine 
reference can also be used.
d699 2
a700 6
If the right side of the arrow is a scalar containing a reference
to a subroutine, then this is equivalent to calling the referenced
subroutine directly with the class name or object on the left side
of the arrow as its first argument. No lookup is done and there is
no requirement that the subroutine be defined in any package related
to the class name or object on the left side of the arrow.
d702 1
a702 1
For example, the following calls to $display are equivalent:
d704 3
a706 3
    my $display = sub { my $self = shift; ... };
    $fred->$display("Height", "Weight");
    $display->($fred, "Height", "Weight");
d708 5
a712 2
=head2 Indirect Object Syntax
X<indirect object syntax> X<invocation, indirect> X<indirect>
d714 4
a717 3
The other way to invoke a method is by using the so-called "indirect
object" notation.  This syntax was available in Perl 4 long before
objects were introduced, and is still used with filehandles like this:
d719 3
a721 1
   print STDERR "help!!!\n";
d723 2
a724 1
The same syntax can be used to call either object or class methods.
d726 1
a726 2
   my $fred = find Critter "Fred";
   display $fred "Height", "Weight";
d728 1
a728 3
Notice that there is no comma between the object or class name and the
parameters.  This is how Perl can tell you want an indirect method call
instead of an ordinary subroutine call.
d730 3
a732 5
But what if there are no arguments?  In that case, Perl must guess what
you want.  Even worse, it must make that guess I<at compile time>.
Usually Perl gets it right, but when it doesn't you get a function
call compiled as a method, or vice versa.  This can introduce subtle bugs
that are hard to detect.
d734 2
a735 7
For example, a call to a method C<new> in indirect notation (as C++
programmers are wont to make) can be miscompiled into a subroutine
call if there's already a C<new> function in scope.  You'd end up
calling the current package's C<new> as a subroutine, rather than the
desired class's method.  The compiler tries to cheat by remembering
bareword C<require>s, but the grief when it messes up just isn't worth the
years of debugging it will take you to track down such subtle bugs.
d737 3
a739 7
There is another problem with this syntax: the indirect object is
limited to a name, a scalar variable, or a block, because it would have
to do too much lookahead otherwise, just like any other postfix
dereference in the language.  (These are the same quirky rules as are
used for the filehandle slot in functions like C<print> and C<printf>.)
This can lead to horribly confusing precedence problems, as in these
next two lines:
d741 3
a743 2
    move $obj->{FIELD};                 # probably wrong!
    move $ary[$i];                      # probably wrong!
d745 3
a747 1
Those actually parse as the very surprising:
d749 1
a749 2
    $obj->move->{FIELD};                # Well, lookee here
    $ary->move([$i]);                   # Didn't expect this one, eh?
d751 1
a751 1
Rather than what you might have expected:
d753 4
a756 2
    $obj->{FIELD}->move();              # You should be so lucky.
    $ary[$i]->move;                     # Yeah, sure.
d758 4
a761 2
To get the correct behavior with indirect object syntax, you would have
to use a block around the indirect object:
d763 4
a766 2
    move {$obj->{FIELD}};
    move {$ary[$i]};
d768 3
a770 6
Even then, you still have the same potential problem if there happens to
be a function named C<move> in the current package.  B<The C<< -> >>
notation suffers from neither of these disturbing ambiguities, so we
recommend you use it exclusively.>  However, you may still end up having
to read code using the indirect object notation, so it's important to be
familiar with it.
d772 1
a772 1
=head2 Default UNIVERSAL methods
d775 5
a779 2
The C<UNIVERSAL> package automatically contains the following methods that
are inherited by all other classes:
d783 1
a783 1
=item isa(CLASS)
d786 4
a789 1
C<isa> returns I<true> if its object is blessed into a subclass of C<CLASS>
d791 1
a791 1
=item DOES(ROLE)
d794 4
a797 2
C<DOES> returns I<true> if its object claims to perform the role C<ROLE>.  By
default, this is equivalent to C<isa>.
d799 4
a802 1
=item can(METHOD)
d805 10
a814 3
C<can> checks to see if its object has a method called C<METHOD>,
if it does then a reference to the sub is returned, if it does not then
C<undef> is returned.
d816 1
a816 1
=item VERSION( [NEED] )
d819 7
a825 5
C<VERSION> returns the version number of the class (package).  If the
NEED argument is given then it will check that the current version (as
defined by the $VERSION variable in the given package) not less than
NEED; it will die if this is not the case.  This method is called automatically
by the C<VERSION> form of C<use>.
d831 9
d842 48
d894 149
a1042 148
automatically destroyed.  (This may even be after you exit, if you've
stored references in global variables.)  If you want to capture control
just before the object is freed, you may define a DESTROY method in
your class.  It will automatically be called at the appropriate moment,
and you can do any extra cleanup you need to do.  Perl passes a reference
to the object under destruction as the first (and only) argument.  Beware
that the reference is a read-only value, and cannot be modified by
manipulating C<$_[0]> within the destructor.  The object itself (i.e.
the thingy the reference points to, namely C<${$_[0]}>, C<@@{$_[0]}>, 
C<%{$_[0]}> etc.) is not similarly constrained.

Since DESTROY methods can be called at unpredictable times, it is
important that you localise any global variables that the method may
update.  In particular, localise C<$@@> if you use C<eval {}> and
localise C<$?> if you use C<system> or backticks.

If you arrange to re-bless the reference before the destructor returns,
perl will again call the DESTROY method for the re-blessed object after
the current one returns.  This can be used for clean delegation of
object destruction, or for ensuring that destructors in the base classes
of your choosing get called.  Explicitly calling DESTROY is also possible,
but is usually never needed.

DESTROY is subject to AUTOLOAD lookup, just like any other method. Hence, if
your class has an AUTOLOAD method, but does not need any DESTROY actions,
you probably want to provide a DESTROY method anyway, to prevent an
expensive call to AUTOLOAD each time an object is freed. As this technique
makes empty DESTROY methods common, the implementation is optimised so that
a DESTROY method that is an empty or constant subroutine, and hence could
have no side effects anyway, is not actually called.
X<AUTOLOAD> X<DESTROY>

Do not confuse the previous discussion with how objects I<CONTAINED> in the current
one are destroyed.  Such objects will be freed and destroyed automatically
when the current object is freed, provided no other references to them exist
elsewhere.

=head2 Summary

That's about all there is to it.  Now you need just to go off and buy a
book about object-oriented design methodology, and bang your forehead
with it for the next six months or so.

=head2 Two-Phased Garbage Collection
X<garbage collection> X<GC> X<circular reference>
X<reference, circular> X<DESTROY> X<destructor>

For most purposes, Perl uses a fast and simple, reference-based
garbage collection system.  That means there's an extra
dereference going on at some level, so if you haven't built
your Perl executable using your C compiler's C<-O> flag, performance
will suffer.  If you I<have> built Perl with C<cc -O>, then this
probably won't matter.

A more serious concern is that unreachable memory with a non-zero
reference count will not normally get freed.  Therefore, this is a bad
idea:

    {
	my $a;
	$a = \$a;
    }

Even thought $a I<should> go away, it can't.  When building recursive data
structures, you'll have to break the self-reference yourself explicitly
if you don't care to leak.  For example, here's a self-referential
node such as one might use in a sophisticated tree structure:

    sub new_node {
	my $class = shift;
	my $node  = {};
	$node->{LEFT} = $node->{RIGHT} = $node;
	$node->{DATA} = [ @@_ ];
	return bless $node => $class;
    }

If you create nodes like that, they (currently) won't go away unless you
break their self reference yourself.  (In other words, this is not to be
construed as a feature, and you shouldn't depend on it.)

Almost.

When an interpreter thread finally shuts down (usually when your program
exits), then a rather costly but complete mark-and-sweep style of garbage
collection is performed, and everything allocated by that thread gets
destroyed.  This is essential to support Perl as an embedded or a
multithreadable language.  For example, this program demonstrates Perl's
two-phased garbage collection:

    #!/usr/bin/perl
    package Subtle;

    sub new {
	my $test;
	$test = \$test;
	warn "CREATING " . \$test;
	return bless \$test;
    }

    sub DESTROY {
	my $self = shift;
	warn "DESTROYING $self";
    }

    package main;

    warn "starting program";
    {
	my $a = Subtle->new;
	my $b = Subtle->new;
	$$a = 0;  # break selfref
	warn "leaving block";
    }

    warn "just exited block";
    warn "time to die...";
    exit;

When run as F</foo/test>, the following output is produced:

    starting program at /foo/test line 18.
    CREATING SCALAR(0x8e5b8) at /foo/test line 7.
    CREATING SCALAR(0x8e57c) at /foo/test line 7.
    leaving block at /foo/test line 23.
    DESTROYING Subtle=SCALAR(0x8e5b8) at /foo/test line 13.
    just exited block at /foo/test line 26.
    time to die... at /foo/test line 27.
    DESTROYING Subtle=SCALAR(0x8e57c) during global destruction.

Notice that "global destruction" bit there?  That's the thread
garbage collector reaching the unreachable.

Objects are always destructed, even when regular refs aren't.  Objects
are destructed in a separate pass before ordinary refs just to 
prevent object destructors from using refs that have been themselves
destructed.  Plain refs are only garbage-collected if the destruct level
is greater than 0.  You can test the higher levels of global destruction
by setting the PERL_DESTRUCT_LEVEL environment variable, presuming
C<-DDEBUGGING> was enabled during perl build time.
See L<perlhack/PERL_DESTRUCT_LEVEL> for more information.

A more complete garbage collection strategy will be implemented
at a future date.

In the meantime, the best solution is to create a non-recursive container
class that holds a pointer to the self-referential data structure.
Define a DESTROY method for the containing object's class that manually
breaks the circularities in the self-referential structure.
d1047 3
a1049 4
be found in L<perltoot>, L<perlboot> and L<perltooc>.  You should
also check out L<perlbot> for other object tricks, traps, and tips, as
well as L<perlmodlib> for some style guides on constructing both
modules and classes.
@


1.11
log
@Merge in perl 5.10.1
@
text
@d353 2
a354 2
For example, a call to a method C<new> in indirect notation -- as C++
programmers are wont to make -- can be miscompiled into a subroutine
d462 9
@


1.10
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d161 2
a162 2
supplied in the UNIVERSAL class; see L<"Default UNIVERSAL methods"> for
more details.
d316 13
d408 2
a409 11
You can also call C<UNIVERSAL::isa> as a subroutine with two arguments.  Of
course, this will do the wrong thing if someone has overridden C<isa> in a
class, so don't do it.

If you need to determine whether you've received a valid invocant, use the
C<blessed> function from L<Scalar::Util>:
X<invocant> X<blessed>

    if (blessed($ref) && $ref->isa( 'Some::Class')) {
        # ...
    }
d411 2
a412 2
C<blessed> returns the name of the package the argument has been
blessed into, or C<undef>.
d419 1
a419 5
I<undef> is returned.

C<UNIVERSAL::can> can also be called as a subroutine with two arguments.  It'll
always return I<undef> if its first argument isn't an object or a class name.
The same caveats for calling C<UNIVERSAL::isa> directly apply here, too.
d427 2
a428 3
NEED; it will die if this is not the case.  This method is normally
called as a class method.  This method is called automatically by the
C<VERSION> form of C<use>.
d430 1
a430 1
    use A 1.2 qw(some imported subs);
d432 1
a432 1
    A->VERSION(1.2);
a434 8

B<NOTE:> C<can> directly uses Perl's internal code for method lookup, and
C<isa> uses a very similar method and cache-ing strategy. This may cause
strange effects if the Perl code dynamically changes @@ISA in any package.

You may add other methods to the UNIVERSAL class via Perl or XS code.
You do not need to C<use UNIVERSAL> to make these methods
available to your program (and you should not do so).
@


1.9
log
@merge in perl 5.8.8
@
text
@d154 3
a156 2
class package.  The classes are searched (depth first) for missing
methods in the order that they occur in @@ISA.  The classes accessible
@


1.8
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d2 1
d38 1
d144 1
d162 1
d174 1
d179 1
d193 1
d201 1
d239 1
d280 1
d295 1
d311 4
d316 1
d382 1
d390 1
d394 7
a400 4
You can also call C<UNIVERSAL::isa> as a subroutine with two arguments.
The first does not need to be an object or even a reference.  This
allows you to check what a reference points to, or whether
something is a reference of a given type. Example
d402 2
a403 2
    if(UNIVERSAL::isa($ref, 'ARRAY')) {
    	#...
d406 2
a407 3
To determine if a reference is a blessed object, you can write

    print "It's an object\n" if UNIVERSAL::isa($val, 'UNIVERSAL');
d410 1
d416 3
a418 15
C<UNIVERSAL::can> can also be called as a subroutine with two arguments.
It'll always return I<undef> if its first argument isn't an object or a
class name.    So here's another way to check if a reference is a
blessed object

    print "It's still an object\n" if UNIVERSAL::can($val, 'can');

You can also use the C<blessed> function of Scalar::Util:

    use Scalar::Util 'blessed';

    my $blessing = blessed $suspected_object;

C<blessed> returns the name of the package the argument has been
blessed into, or C<undef>.
d421 1
d445 1
d459 5
d483 2
@


1.7
log
@merge local changes into perl-5.8.3
@
text
@d100 5
a104 3
C<< $obj->new() >>, then use something like this.  The initialize()
method used will be of whatever $class we blessed the
object into:
d490 2
a491 3
	my $self = shift;
	my $class = ref($self) || $self;
	my $node = {};
d539 1
a539 1
When run as F</tmp/test>, the following output is produced:
d541 7
a547 7
    starting program at /tmp/test line 18.
    CREATING SCALAR(0x8e5b8) at /tmp/test line 7.
    CREATING SCALAR(0x8e57c) at /tmp/test line 7.
    leaving block at /tmp/test line 23.
    DESTROYING Subtle=SCALAR(0x8e5b8) at /tmp/test line 13.
    just exited block at /tmp/test line 26.
    time to die... at /tmp/test line 27.
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d278 10
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d10 1
a10 1
in Perl can be found in L<perltoot> and L<perltootc>.
d203 1
a203 1
class methods, but see L<perltoot> and L<perltootc> for alternatives.
d230 3
a232 3
There are two ways to invoke a method, one of which you're already
familiar with, and the other of which will look familiar.  Perl 4
already had an "indirect object" syntax that you use when you say
d234 2
a235 1
    print STDERR "help!!!\n";
d237 4
a240 3
This same syntax can be used to call either class or instance methods.
We'll use the two methods defined above, the class method to lookup
an object reference and the instance method to print out its attributes.
d242 3
a244 2
    $fred = find Critter "Fred";
    display $fred 'Height', 'Weight';
d246 2
a247 2
These could be combined into one statement by using a BLOCK in the
indirect object slot:
d249 6
a254 1
    display {find Critter "Fred"} 'Height', 'Weight';
d256 1
a256 2
For C++ fans, there's also a syntax using -> notation that does exactly
the same thing.  The parentheses are required if there are any arguments.
d258 2
a259 2
    $fred = Critter->find("Fred");
    $fred->display('Height', 'Weight');
d261 4
a264 1
or in one statement,
d266 3
a268 1
    Critter->find("Fred")->display('Height', 'Weight');
d270 2
a271 8
There are times when one syntax is more readable, and times when the
other syntax is more readable.  The indirect object syntax is less
cluttered, but it has the same ambiguity as ordinary list operators.
Indirect object method calls are usually parsed using the same rule as list
operators: "If it looks like a function, it is a function".  (Presuming
for the moment that you think two words in a row can look like a
function name.  C++ programmers seem to think so with some regularity,
especially when the first word is "new".)  Thus, the parentheses of
d273 4
a276 25
    new Critter ('Barney', 1.5, 70)

are assumed to surround ALL the arguments of the method call, regardless
of what comes after.  Saying

    new Critter ('Bam' x 2), 1.4, 45

would be equivalent to

    Critter->new('Bam' x 2), 1.4, 45

which is unlikely to do what you want.  Confusingly, however, this
rule applies only when the indirect object is a bareword package name,
not when it's a scalar, a BLOCK, or a C<Package::> qualified package name.
In those cases, the arguments are parsed in the same way as an
indirect object list operator like print, so

    new Critter:: ('Bam' x 2), 1.4, 45

is the same as

   Critter::->new(('Bam' x 2), 1.4, 45)

For more reasons why the indirect object syntax is ambiguous, see
L<"WARNING"> below.
d278 3
a280 3
There are times when you wish to specify which class's method to use.
Here you can call your method as an ordinary subroutine
call, being sure to pass the requisite first argument explicitly:
d282 1
a282 2
    $fred =  MyCritter::find("Critter", "Fred");
    MyCritter::display($fred, 'Height', 'Weight');
d284 1
a284 4
Unlike method calls, function calls don't consider inheritance.  If you wish
merely to specify that Perl should I<START> looking for a method in a
particular package, use an ordinary method call, but qualify the method
name with the package like this:
d286 1
a286 2
    $fred = Critter->MyCritter::find("Fred");
    $fred->MyCritter::display('Height', 'Weight');
d288 1
a288 4
If you're trying to control where the method search begins I<and> you're
executing in the class itself, then you may use the SUPER pseudo class,
which says to start looking in your base class's @@ISA list without having
to name it explicitly:
d290 3
a292 1
    $self->SUPER::display('Height', 'Weight');
d294 1
a294 2
Please note that the C<SUPER::> construct is meaningful I<only> within the
class.
d296 1
a296 4
Sometimes you want to call a method when you don't know the method name
ahead of time.  You can use the arrow form, replacing the method name
with a simple scalar variable containing the method name or a
reference to the function.
d298 2
a299 2
    $method = $fast ? "findfirst" : "findbest";
    $fred->$method(@@args);  	    # call by name
d301 3
a303 3
    if ($coderef = $fred->can($parent . "::findbest")) {
	$self->$coderef(@@args);	    # call by coderef
    }
d305 5
a309 1
=head2 WARNING
d311 7
a317 2
While indirect object syntax may well be appealing to English speakers and
to C++ programmers, be not seduced!  It suffers from two grave problems.
d319 7
a325 6
The first problem is that an indirect object is limited to a name,
a scalar variable, or a block, because it would have to do too much
lookahead otherwise, just like any other postfix dereference in the
language.  (These are the same quirky rules as are used for the filehandle
slot in functions like C<print> and C<printf>.)  This can lead to horribly
confusing precedence problems, as in these next two lines:
d340 2
a341 2
The left side of ``->'' is not so limited, because it's an infix operator,
not a postfix operator.  
d343 2
a344 12
As if that weren't bad enough, think about this: Perl must guess I<at
compile time> whether C<name> and C<move> above are functions or methods.
Usually Perl gets it right, but when it doesn't it, you get a function
call compiled as a method, or vice versa.  This can introduce subtle
bugs that are hard to unravel.  For example, calling a method C<new>
in indirect notation--as C++ programmers are so wont to do--can
be miscompiled into a subroutine call if there's already a C<new>
function in scope.  You'd end up calling the current package's C<new>
as a subroutine, rather than the desired class's method.  The compiler
tries to cheat by remembering bareword C<require>s, but the grief if it
messes up just isn't worth the years of debugging it would likely take
you to track such subtle bugs down.
d346 6
a351 2
The infix arrow notation using ``C<< -> >>'' doesn't suffer from either
of these disturbing ambiguities, so we recommend you use it exclusively.
d364 4
a367 4
C<isa> is also exportable and can be called as a sub with two arguments. This
allows the ability to check what a reference points to. Example

    use UNIVERSAL qw(isa);
d369 1
a369 1
    if(isa($ref, 'ARRAY')) {
d373 4
d383 16
d420 1
a420 2
available to your program.  This is necessary only if you wish to
have C<isa> available as a plain subroutine in the current package.
d549 1
d562 1
a562 1
be found in L<perltoot>, L<perlbootc> and L<perltootc>.  You should
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d171 6
d562 5
a566 5
A kinder, gentler tutorial on object-oriented programming in Perl
can be found in L<perltoot> and L<perltootc>.  You should also check
out L<perlbot> for other object tricks, traps, and tips, as well
as L<perlmodlib> for some style guides on constructing both modules
and classes.
@


1.3
log
@perl5.005_03 (stock)
@
text
@d7 1
a7 1
First of all, you need to understand what references are in Perl.
d10 1
a10 1
in Perl can be found in L<perltoot>.
d53 1
a53 1
In fact, this might even be preferable, because the C++ programmers won't
d76 1
a76 1
In fact, you often see such a thing in more complicated constructors
d99 2
a100 2
Or if you expect people to call not just C<CLASS-E<gt>new()> but also
C<$obj-E<gt>new()>, then use something like this.  The initialize()
d118 7
a124 6
A constructor may re-bless a referenced object currently belonging to
another class, but then the new class is responsible for all cleanup
later.  The previous blessing is forgotten, as an object may belong
to only one class at a time.  (Although of course it's free to
inherit methods from many classes.)  If you find yourself having to 
do this, the parent class is probably misbehaving, though.
d158 1
a158 1
If a missing method is found in one of the base classes, it is cached
d190 3
a192 4
to be the object (reference) or package (string) it is being invoked on.  There are just two
types of methods, which we'll call class and instance.
(Sometimes you'll hear these called static and virtual, in honor of
the two C++ method types they most closely resemble.)
d195 5
a199 4
provides functionality for the class as a whole, not for any individual
object belonging to the class.  Constructors are typically class
methods.  Many class methods simply ignore their first argument, because
they already know what package they're in, and don't care what package
d242 1
a242 1
For C++ fans, there's also a syntax using -E<gt> notation that does exactly
d288 1
a288 1
In this case, you can call your method as an ordinary subroutine
d294 1
a294 1
Note however, that this does not do any inheritance.  If you wish
d314 2
a315 1
with a simple scalar variable containing the method name:
d318 49
a366 1
    $fred->$method(@@args);
d414 1
a414 1
You do not need to C<use UNIVERSAL> in order to make these methods
d439 1
a439 1
Do not confuse the foregoing with how objects I<CONTAINED> in the current
a443 44
=head2 WARNING

While indirect object syntax may well be appealing to English speakers and
to C++ programmers, be not seduced!  It suffers from two grave problems.

The first problem is that an indirect object is limited to a name,
a scalar variable, or a block, because it would have to do too much
lookahead otherwise, just like any other postfix dereference in the
language.  (These are the same quirky rules as are used for the filehandle
slot in functions like C<print> and C<printf>.)  This can lead to horribly
confusing precedence problems, as in these next two lines:

    move $obj->{FIELD};                 # probably wrong!
    move $ary[$i];                      # probably wrong!

Those actually parse as the very surprising:

    $obj->move->{FIELD};                # Well, lookee here
    $ary->move->[$i];                   # Didn't expect this one, eh?

Rather than what you might have expected:

    $obj->{FIELD}->move();              # You should be so lucky.
    $ary[$i]->move;                     # Yeah, sure.

The left side of ``-E<gt>'' is not so limited, because it's an infix operator,
not a postfix operator.  

As if that weren't bad enough, think about this: Perl must guess I<at
compile time> whether C<name> and C<move> above are functions or methods.
Usually Perl gets it right, but when it doesn't it, you get a function
call compiled as a method, or vice versa.  This can introduce subtle
bugs that are hard to unravel.  For example, calling a method C<new>
in indirect notation--as C++ programmers are so wont to do--can
be miscompiled into a subroutine call if there's already a C<new>
function in scope.  You'd end up calling the current package's C<new>
as a subroutine, rather than the desired class's method.  The compiler
tries to cheat by remembering bareword C<require>s, but the grief if it
messes up just isn't worth the years of debugging it would likely take
you to to track such subtle bugs down.

The infix arrow notation using ``C<-E<gt>>'' doesn't suffer from either
of these disturbing ambiguities, so we recommend you use it exclusively.

d452 2
a453 2
For most purposes, Perl uses a fast and simple reference-based
garbage collection system.  For this reason, there's an extra
d538 2
a539 2
Objects are always destructed, even when regular refs aren't and in fact
are destructed in a separate pass before ordinary refs just to try to
d556 4
a559 4
A kinder, gentler tutorial on object-oriented programming in Perl can
be found in L<perltoot>.
You should also check out L<perlbot> for other object tricks, traps, and tips,
as well as L<perlmodlib> for some style guides on constructing both modules
@


1.2
log
@perl 5.004_04
@
text
@d47 22
a68 6
The C<{}> constructs a reference to an anonymous hash containing no
key/value pairs.  The bless() takes that reference and tells the object
it references that it's now a Critter, and returns the reference.
This is for convenience, because the referenced object itself knows that
it has been blessed, and the reference to it could have been returned
directly, like this:
d80 1
a80 1
	my $self = {}
d87 1
a87 1
L<perlmod/"Modules: Creation, Use, and Abuse">),
d94 1
a94 1
	bless $self, $class
d108 1
a108 1
	bless $self, $class
d122 2
a123 1
inherit methods from many classes.)
d144 1
a144 1
There is a special array within each package called @@ISA which says
d152 5
d161 17
a177 2
If a method isn't found, but an AUTOLOAD routine is found, then
that is called on behalf of the missing method.
d179 4
a182 13
If neither a method nor an AUTOLOAD routine is found in @@ISA, then one
last try is made for the method (or an AUTOLOAD routine) in a class
called UNIVERSAL.  (Several commonly used methods are automatically
supplied in the UNIVERSAL class; see L<"Default UNIVERSAL methods"> for
more details.)  If that doesn't work, Perl finally gives up and
complains.

Perl classes do only method inheritance.  Data inheritance is left
up to the class itself.  By and large, this is not a problem in Perl,
because most classes model the attributes of their object using
an anonymous hash, which serves as its own little namespace to be
carved up by the various classes that might want to do something
with the object.
d189 1
a189 1
to be the object or package it is being invoked on.  There are just two
d254 1
a254 1
Indirect object method calls are parsed using the same rule as list
d271 14
a284 1
which is unlikely to do what you want.
d335 1
a335 1
    	...
d375 18
a392 1
and you can do any extra cleanup you need to do.
d394 4
a397 6
Perl doesn't do nested destruction for you.  If your constructor
re-blessed a reference from one of your base classes, your DESTROY may
need to call DESTROY for any base classes that need it.  But this applies
to only re-blessed objects--an object reference that is merely
I<CONTAINED> in the current object will be freed and destroyed
automatically when the current object is freed.
d399 35
a433 1
=head2 WARNING
d435 2
a436 12
An indirect object is limited to a name, a scalar variable, or a block,
because it would have to do too much lookahead otherwise, just like any
other postfix dereference in the language.  The left side of -E<gt> is not so
limited, because it's an infix operator, not a postfix operator.

That means that in the following, A and B are equivalent to each other, and
C and D are equivalent, but A/B and C/D are different:

    A: method $obref->{"fieldname"}
    B: (method $obref)->{"fieldname"}
    C: $obref->{"fieldname"}->method()
    D: method {$obref->{"fieldname"}}
d542 5
@


1.1
log
@Initial revision
@
text
@d7 4
a10 2
First of all, you need to understand what references are in Perl.  See
L<perlref> for that.  
d12 2
a13 1
Here are three very simple definitions that you should find reassuring.
d30 1
a30 1
a package name, for static methods) as the first argument.
d47 1
a47 1
The C<{}> constructs a reference to an anonymous hash containing no 
d50 2
a51 2
This is for convenience, since the referenced object itself knows that
it has been blessed, and its reference to it could have been returned 
d70 3
a72 2
If you care about inheritance (and you should; see L<perlmod/"Modules:
Creation, Use and Abuse">), then you want to use the two-arg form of bless
d85 1
a85 1
method used will be of whatever $class we blessed the 
d100 1
a100 1
only be accessed through the class's methods.
d104 2
a105 2
later.  The previous blessing is forgotten, as an object may only
belong to one class at a time.  (Although of course it's free to 
d110 1
a110 1
function simply uses the reference in order to find the object.  Consider
d118 1
a118 1
This reports $b as being a BLAH, so obviously bless() 
d124 1
a124 1
definitions.  You just use a package as a class by putting method
d133 1
a133 1
through @@ISA are known as base classes of the current class. 
d144 3
a146 1
called UNIVERSAL.  If that doesn't work, Perl finally gives up and
d149 1
a149 1
Perl classes only do method inheritance.  Data inheritance is left
d162 3
a164 2
types of methods, which we'll call static and virtual, in honor of
the two C++ method types they most closely resemble.
d166 1
a166 1
A static method expects a class name as the first argument.  It
d168 2
a169 2
object belonging to the class.  Constructors are typically static
methods.  Many static methods simply ignore their first argument, since
d171 3
a173 3
they were invoked via.  (These aren't necessarily the same, since
static methods follow the inheritance tree just like ordinary virtual
methods.)  Another typical use for static methods is to look up an
d181 1
a181 1
A virtual method expects an object reference as its first argument.
d201 3
a203 3
This same syntax can be used to call either static or virtual methods.
We'll use the two methods defined above, the static method to lookup
an object reference and the virtual method to print out its attributes.
d230 1
a230 1
especially when the first word is "new".)  Thus, the parens of
d252 2
a253 2
Note however, that this does not do any inheritance.  If you merely
wish to specify that Perl should I<START> looking for a method in a
d261 1
a261 1
executing in the class itself, then you may use the SUPER pseudoclass,
d263 1
a263 1
to explicitly name it:
d267 1
a267 1
Please note that the C<SUPER::> construct is I<only> meaningful within the
d277 50
d337 3
a339 3
reblessed a reference from one of your base classes, your DESTROY may
need to call DESTROY for any base classes that need it.  But this only
applies to reblessed objects--an object reference that is merely
d348 1
a348 1
limited, because it's an infix operator, not a postfix operator.  
d350 2
a351 2
That means that below, A and B are equivalent to each other, and C and D
are equivalent, but AB and CD are different:
d353 1
a353 1
    A: method $obref->{"fieldname"} 
d355 1
a355 1
    C: $obref->{"fieldname"}->method() 
d360 1
a360 1
That's about all there is to it.  Now you just need to go off and buy a
d375 1
a375 1
idea:  
d380 1
a380 1
    } 
d394 1
a394 1
    } 
d409 1
a409 1
    #!/usr/bin/perl 
d417 1
a417 1
    } 
d422 1
a422 1
    } 
d432 1
a432 1
    } 
d450 1
a450 1
garbage collector reaching the unreachable.  
d455 1
a455 1
destructed.  Plain refs are only garbage collected if the destruct level
d465 4
a468 2
You should also check out L<perlbot> for other object tricks, traps, and tips, 
as well as L<perlmod> for some style guides on constructing both modules
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d7 2
a8 4
First of all, you need to understand what references are in Perl.
See L<perlref> for that.  Second, if you still find the following
reference work too complicated, a tutorial on object-oriented programming
in Perl can be found in L<perltoot>.
d10 1
a10 2
If you're still with us, then
here are three very simple definitions that you should find reassuring.
d27 1
a27 1
a package name, for class methods) as the first argument.
d44 6
a49 22
That word C<new> isn't special.  You could have written
a construct this way, too:

    package Critter;
    sub spawn { bless {} }

In fact, this might even be preferable, because the C++ programmers won't
be tricked into thinking that C<new> works in Perl as it does in C++.
It doesn't.  We recommend that you name your constructors whatever
makes sense in the context of the problem you're solving.  For example,
constructors in the Tk extension to Perl are named after the widgets
they create.

One thing that's different about Perl constructors compared with those in
C++ is that in Perl, they have to allocate their own memory.  (The other
things is that they don't automatically call overridden base-class
constructors.)  The C<{}> allocates an anonymous hash containing no
key/value pairs, and returns it  The bless() takes that reference and
tells the object it references that it's now a Critter, and returns
the reference.  This is for convenience, because the referenced object
itself knows that it has been blessed, and the reference to it could
have been returned directly, like this:
d61 1
a61 1
	my $self = {};
d67 2
a68 3
If you care about inheritance (and you should; see
L<perlmodlib/"Modules: Creation, Use, and Abuse">),
then you want to use the two-arg form of bless
d74 1
a74 1
	bless $self, $class;
d81 1
a81 1
method used will be of whatever $class we blessed the
d88 1
a88 1
	bless $self, $class;
d96 1
a96 1
be accessed only through the class's methods.
d100 3
a102 4
later.  The previous blessing is forgotten, as an object may belong
to only one class at a time.  (Although of course it's free to
inherit methods from many classes.)  If you find yourself having to 
do this, the parent class is probably misbehaving, though.
d106 1
a106 1
function uses the reference to find the object.  Consider
d114 1
a114 1
This reports $b as being a BLAH, so obviously bless()
d120 1
a120 1
definitions.  You use a package as a class by putting method
d123 1
a123 1
There is a special array within each package called @@ISA, which says
d129 1
a129 6
through @@ISA are known as base classes of the current class.

All classes implicitly inherit from class C<UNIVERSAL> as their
last base class.  Several commonly used methods are automatically
supplied in the UNIVERSAL class; see L<"Default UNIVERSAL methods"> for
more details.
d135 2
a136 17
If neither the current class, its named base classes, nor the UNIVERSAL
class contains the requested method, these three places are searched
all over again, this time looking for a method named AUTOLOAD().  If an
AUTOLOAD is found, this method is called on behalf of the missing method,
setting the package global $AUTOLOAD to be the fully qualified name of
the method that was intended to be called.

If none of that works, Perl finally gives up and complains.

Perl classes do method inheritance only.  Data inheritance is left up
to the class itself.  By and large, this is not a problem in Perl,
because most classes model the attributes of their object using an
anonymous hash, which serves as its own little namespace to be carved up
by the various classes that might want to do something with the object.
The only problem with this is that you can't sure that you aren't using
a piece of the hash that isn't already used.  A reasonable workaround
is to prepend your fieldname in the hash with the package name.
d138 11
a148 4
    sub bump {
	my $self = shift;
	$self->{ __PACKAGE__ . ".count"}++;
    } 
d155 3
a157 4
to be the object (reference) or package (string) it is being invoked on.  There are just two
types of methods, which we'll call class and instance.
(Sometimes you'll hear these called static and virtual, in honor of
the two C++ method types they most closely resemble.)
d159 1
a159 1
A class method expects a class name as the first argument.  It
d161 2
a162 2
object belonging to the class.  Constructors are typically class
methods.  Many class methods simply ignore their first argument, because
d164 3
a166 3
they were invoked via.  (These aren't necessarily the same, because
class methods follow the inheritance tree just like ordinary instance
methods.)  Another typical use for class methods is to look up an
d174 1
a174 1
An instance method expects an object reference as its first argument.
d194 3
a196 3
This same syntax can be used to call either class or instance methods.
We'll use the two methods defined above, the class method to lookup
an object reference and the instance method to print out its attributes.
d219 1
a219 1
Indirect object method calls are usually parsed using the same rule as list
d223 1
a223 1
especially when the first word is "new".)  Thus, the parentheses of
d236 1
a236 14
which is unlikely to do what you want.  Confusingly, however, this
rule applies only when the indirect object is a bareword package name,
not when it's a scalar, a BLOCK, or a C<Package::> qualified package name.
In those cases, the arguments are parsed in the same way as an
indirect object list operator like print, so

    new Critter:: ('Bam' x 2), 1.4, 45

is the same as

   Critter::->new(('Bam' x 2), 1.4, 45)

For more reasons why the indirect object syntax is ambiguous, see
L<"WARNING"> below.
d245 2
a246 2
Note however, that this does not do any inheritance.  If you wish
merely to specify that Perl should I<START> looking for a method in a
d254 1
a254 1
executing in the class itself, then you may use the SUPER pseudo class,
d256 1
a256 1
to name it explicitly:
d260 1
a260 1
Please note that the C<SUPER::> construct is meaningful I<only> within the
a269 50
=head2 Default UNIVERSAL methods

The C<UNIVERSAL> package automatically contains the following methods that
are inherited by all other classes:

=over 4

=item isa(CLASS)

C<isa> returns I<true> if its object is blessed into a subclass of C<CLASS>

C<isa> is also exportable and can be called as a sub with two arguments. This
allows the ability to check what a reference points to. Example

    use UNIVERSAL qw(isa);

    if(isa($ref, 'ARRAY')) {
    	#...
    }

=item can(METHOD)

C<can> checks to see if its object has a method called C<METHOD>,
if it does then a reference to the sub is returned, if it does not then
I<undef> is returned.

=item VERSION( [NEED] )

C<VERSION> returns the version number of the class (package).  If the
NEED argument is given then it will check that the current version (as
defined by the $VERSION variable in the given package) not less than
NEED; it will die if this is not the case.  This method is normally
called as a class method.  This method is called automatically by the
C<VERSION> form of C<use>.

    use A 1.2 qw(some imported subs);
    # implies:
    A->VERSION(1.2);

=back

B<NOTE:> C<can> directly uses Perl's internal code for method lookup, and
C<isa> uses a very similar method and cache-ing strategy. This may cause
strange effects if the Perl code dynamically changes @@ISA in any package.

You may add other methods to the UNIVERSAL class via Perl or XS code.
You do not need to C<use UNIVERSAL> in order to make these methods
available to your program.  This is necessary only if you wish to
have C<isa> available as a plain subroutine in the current package.

d277 8
a284 18
and you can do any extra cleanup you need to do.  Perl passes a reference
to the object under destruction as the first (and only) argument.  Beware
that the reference is a read-only value, and cannot be modified by
manipulating C<$_[0]> within the destructor.  The object itself (i.e.
the thingy the reference points to, namely C<${$_[0]}>, C<@@{$_[0]}>, 
C<%{$_[0]}> etc.) is not similarly constrained.

If you arrange to re-bless the reference before the destructor returns,
perl will again call the DESTROY method for the re-blessed object after
the current one returns.  This can be used for clean delegation of
object destruction, or for ensuring that destructors in the base classes
of your choosing get called.  Explicitly calling DESTROY is also possible,
but is usually never needed.

Do not confuse the foregoing with how objects I<CONTAINED> in the current
one are destroyed.  Such objects will be freed and destroyed automatically
when the current object is freed, provided no other references to them exist
elsewhere.
d288 12
a299 41
While indirect object syntax may well be appealing to English speakers and
to C++ programmers, be not seduced!  It suffers from two grave problems.

The first problem is that an indirect object is limited to a name,
a scalar variable, or a block, because it would have to do too much
lookahead otherwise, just like any other postfix dereference in the
language.  (These are the same quirky rules as are used for the filehandle
slot in functions like C<print> and C<printf>.)  This can lead to horribly
confusing precedence problems, as in these next two lines:

    move $obj->{FIELD};                 # probably wrong!
    move $ary[$i];                      # probably wrong!

Those actually parse as the very surprising:

    $obj->move->{FIELD};                # Well, lookee here
    $ary->move->[$i];                   # Didn't expect this one, eh?

Rather than what you might have expected:

    $obj->{FIELD}->move();              # You should be so lucky.
    $ary[$i]->move;                     # Yeah, sure.

The left side of ``-E<gt>'' is not so limited, because it's an infix operator,
not a postfix operator.  

As if that weren't bad enough, think about this: Perl must guess I<at
compile time> whether C<name> and C<move> above are functions or methods.
Usually Perl gets it right, but when it doesn't it, you get a function
call compiled as a method, or vice versa.  This can introduce subtle
bugs that are hard to unravel.  For example, calling a method C<new>
in indirect notation--as C++ programmers are so wont to do--can
be miscompiled into a subroutine call if there's already a C<new>
function in scope.  You'd end up calling the current package's C<new>
as a subroutine, rather than the desired class's method.  The compiler
tries to cheat by remembering bareword C<require>s, but the grief if it
messes up just isn't worth the years of debugging it would likely take
you to to track such subtle bugs down.

The infix arrow notation using ``C<-E<gt>>'' doesn't suffer from either
of these disturbing ambiguities, so we recommend you use it exclusively.
d303 1
a303 1
That's about all there is to it.  Now you need just to go off and buy a
d318 1
a318 1
idea:
d323 1
a323 1
    }
d337 1
a337 1
    }
d352 1
a352 1
    #!/usr/bin/perl
d360 1
a360 1
    }
d365 1
a365 1
    }
d375 1
a375 1
    }
d393 1
a393 1
garbage collector reaching the unreachable.
d398 1
a398 1
destructed.  Plain refs are only garbage-collected if the destruct level
a405 5
In the meantime, the best solution is to create a non-recursive container
class that holds a pointer to the self-referential data structure.
Define a DESTROY method for the containing object's class that manually
breaks the circularities in the self-referential structure.

d408 2
a409 4
A kinder, gentler tutorial on object-oriented programming in Perl can
be found in L<perltoot>.
You should also check out L<perlbot> for other object tricks, traps, and tips,
as well as L<perlmodlib> for some style guides on constructing both modules
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d7 1
a7 1
First you need to understand what references are in Perl.
d10 1
a10 1
in Perl can be found in L<perltoot> and L<perltootc>.
d53 1
a53 1
This might even be preferable, because the C++ programmers won't
d76 1
a76 1
You often see such a thing in more complicated constructors
d99 2
a100 2
Or if you expect people to call not just C<< CLASS->new() >> but also
C<< $obj->new() >>, then use something like this.  The initialize()
d118 6
a123 7
Although a constructor can in theory re-bless a referenced object
currently belonging to another class, this is almost certainly going
to get you into trouble.  The new class is responsible for all
cleanup later.  The previous blessing is forgotten, as an object
may belong to only one class at a time.  (Although of course it's
free to inherit methods from many classes.)  If you find yourself
having to do this, the parent class is probably misbehaving, though.
d157 1
a157 1
If a missing method is found in a base class, it is cached
d189 4
a192 3
to be the object (reference) or package (string) it is being invoked
on.  There are two ways of calling methods, which we'll call class
methods and instance methods.  
d195 4
a198 5
provides functionality for the class as a whole, not for any
individual object belonging to the class.  Constructors are often
class methods, but see L<perltoot> and L<perltootc> for alternatives.
Many class methods simply ignore their first argument, because they
already know what package they're in and don't care what package
d241 1
a241 1
For C++ fans, there's also a syntax using -> notation that does exactly
d287 1
a287 1
Here you can call your method as an ordinary subroutine
d293 1
a293 1
Unlike method calls, function calls don't consider inheritance.  If you wish
d313 1
a313 2
with a simple scalar variable containing the method name or a
reference to the function.
d316 1
a316 49
    $fred->$method(@@args);  	    # call by name

    if ($coderef = $fred->can($parent . "::findbest")) {
	$self->$coderef(@@args);	    # call by coderef
    }

=head2 WARNING

While indirect object syntax may well be appealing to English speakers and
to C++ programmers, be not seduced!  It suffers from two grave problems.

The first problem is that an indirect object is limited to a name,
a scalar variable, or a block, because it would have to do too much
lookahead otherwise, just like any other postfix dereference in the
language.  (These are the same quirky rules as are used for the filehandle
slot in functions like C<print> and C<printf>.)  This can lead to horribly
confusing precedence problems, as in these next two lines:

    move $obj->{FIELD};                 # probably wrong!
    move $ary[$i];                      # probably wrong!

Those actually parse as the very surprising:

    $obj->move->{FIELD};                # Well, lookee here
    $ary->move([$i]);                   # Didn't expect this one, eh?

Rather than what you might have expected:

    $obj->{FIELD}->move();              # You should be so lucky.
    $ary[$i]->move;                     # Yeah, sure.

The left side of ``->'' is not so limited, because it's an infix operator,
not a postfix operator.  

As if that weren't bad enough, think about this: Perl must guess I<at
compile time> whether C<name> and C<move> above are functions or methods.
Usually Perl gets it right, but when it doesn't it, you get a function
call compiled as a method, or vice versa.  This can introduce subtle
bugs that are hard to unravel.  For example, calling a method C<new>
in indirect notation--as C++ programmers are so wont to do--can
be miscompiled into a subroutine call if there's already a C<new>
function in scope.  You'd end up calling the current package's C<new>
as a subroutine, rather than the desired class's method.  The compiler
tries to cheat by remembering bareword C<require>s, but the grief if it
messes up just isn't worth the years of debugging it would likely take
you to track such subtle bugs down.

The infix arrow notation using ``C<< -> >>'' doesn't suffer from either
of these disturbing ambiguities, so we recommend you use it exclusively.
d364 1
a364 1
You do not need to C<use UNIVERSAL> to make these methods
d389 1
a389 1
Do not confuse the previous discussion with how objects I<CONTAINED> in the current
d394 44
d446 2
a447 2
For most purposes, Perl uses a fast and simple, reference-based
garbage collection system.  That means there's an extra
d532 2
a533 2
Objects are always destructed, even when regular refs aren't.  Objects
are destructed in a separate pass before ordinary refs just to 
d550 4
a553 4
A kinder, gentler tutorial on object-oriented programming in Perl
can be found in L<perltoot> and L<perltootc>.  You should also check
out L<perlbot> for other object tricks, traps, and tips, as well
as L<perlmodlib> for some style guides on constructing both modules
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@a170 6
If you want to stop the AUTOLOAD inheritance say simply

	sub AUTOLOAD;

and the call will die using the name of the sub being called.

d556 5
a560 5
A kinder, gentler tutorial on object-oriented programming in Perl can
be found in L<perltoot>, L<perlbootc> and L<perltootc>.  You should
also check out L<perlbot> for other object tricks, traps, and tips, as
well as L<perlmodlib> for some style guides on constructing both
modules and classes.
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d10 1
a10 1
in Perl can be found in L<perltoot> and L<perltooc>.
d203 1
a203 1
class methods, but see L<perltoot> and L<perltooc> for alternatives.
d230 3
a232 3
For various historical and other reasons, Perl offers two equivalent
ways to write a method call.  The simpler and more common way is to use
the arrow notation:
d234 1
a234 2
    my $fred = Critter->find("Fred");
    $fred->display("Height", "Weight");
d236 3
a238 4
You should already be familiar with the use of the C<< -> >> operator with
references.  In fact, since C<$fred> above is a reference to an object,
you could think of the method call as just another form of
dereferencing.
d240 2
a241 3
Whatever is on the left side of the arrow, whether a reference or a
class name, is passed to the method subroutine as its first argument.
So the above code is mostly equivalent to:
d243 2
a244 2
    my $fred = Critter::find("Critter", "Fred");
    Critter::display($fred, "Height", "Weight");
d246 1
a246 6
How does Perl know which package the subroutine is in?  By looking at
the left side of the arrow, which must be either a package name or a
reference to an object, i.e. something that has been blessed to a
package.  Either way, that's the package where Perl starts looking.  If
that package has no subroutine with that name, Perl starts looking for
it in any base classes of that package, and so on.
d248 2
a249 1
If you need to, you I<can> force Perl to start looking in some other package:
d251 2
a252 2
    my $barney = MyCritter->Critter::find("Barney");
    $barney->Critter::display("Height", "Weight");
d254 1
a254 4
Here C<MyCritter> is presumably a subclass of C<Critter> that defines
its own versions of find() and display().  We haven't specified what
those methods do, but that doesn't matter above since we've forced Perl
to start looking for the subroutines in C<Critter>.
d256 1
a256 3
As a special case of the above, you may use the C<SUPER> pseudo-class to
tell Perl to start looking for the method in the packages named in the
current class's C<@@ISA> list.  
d258 8
a265 2
    package MyCritter;
    use base 'Critter';    # sets @@MyCritter::ISA = ('Critter');
d267 25
a291 4
    sub display { 
        my ($self, @@args) = @@_;
        $self->SUPER::display("Name", @@args);
    }
d293 3
a295 3
Instead of a class name or an object reference, you can also use any
expression that returns either of those on the left side of the arrow.
So the following statement is valid:
d297 2
a298 1
    Critter->find("Fred")->display("Height", "Weight");
d300 4
a303 1
and so is the following:
d305 2
a306 1
    my $fred = (reverse "rettirC")->find(reverse "derF");
d308 4
a311 1
=head2 Indirect Object Syntax
d313 1
a313 3
The other way to invoke a method is by using the so-called "indirect
object" notation.  This syntax was available in Perl 4 long before
objects were introduced, and is still used with filehandles like this:
d315 2
a316 1
   print STDERR "help!!!\n";
d318 4
a321 1
The same syntax can be used to call either object or class methods.
d323 2
a324 2
   my $fred = find Critter "Fred";
   display $fred "Height", "Weight";
d326 3
a328 3
Notice that there is no comma between the object or class name and the
parameters.  This is how Perl can tell you want an indirect method call
instead of an ordinary subroutine call.
d330 1
a330 5
But what if there are no arguments?  In that case, Perl must guess what
you want.  Even worse, it must make that guess I<at compile time>.
Usually Perl gets it right, but when it doesn't you get a function
call compiled as a method, or vice versa.  This can introduce subtle bugs
that are hard to detect.
d332 2
a333 7
For example, a call to a method C<new> in indirect notation -- as C++
programmers are wont to make -- can be miscompiled into a subroutine
call if there's already a C<new> function in scope.  You'd end up
calling the current package's C<new> as a subroutine, rather than the
desired class's method.  The compiler tries to cheat by remembering
bareword C<require>s, but the grief when it messes up just isn't worth the
years of debugging it will take you to track down such subtle bugs.
d335 6
a340 7
There is another problem with this syntax: the indirect object is
limited to a name, a scalar variable, or a block, because it would have
to do too much lookahead otherwise, just like any other postfix
dereference in the language.  (These are the same quirky rules as are
used for the filehandle slot in functions like C<print> and C<printf>.)
This can lead to horribly confusing precedence problems, as in these
next two lines:
d355 2
a356 2
To get the correct behavior with indirect object syntax, you would have
to use a block around the indirect object:
d358 12
a369 2
    move {$obj->{FIELD}};
    move {$ary[$i]};
d371 2
a372 6
Even then, you still have the same potential problem if there happens to
be a function named C<move> in the current package.  B<The C<< -> >>
notation suffers from neither of these disturbing ambiguities, so we
recommend you use it exclusively.>  However, you may still end up having
to read code using the indirect object notation, so it's important to be
familiar with it.
d385 4
a388 4
You can also call C<UNIVERSAL::isa> as a subroutine with two arguments.
The first does not need to be an object or even a reference.  This
allows you to check what a reference points to, or whether
something is a reference of a given type. Example
d390 1
a390 1
    if(UNIVERSAL::isa($ref, 'ARRAY')) {
a393 4
To determine if a reference is a blessed object, you can write

    print "It's an object\n" if UNIVERSAL::isa($val, 'UNIVERSAL');

a399 16
C<UNIVERSAL::can> can also be called as a subroutine with two arguments.
It'll always return I<undef> if its first argument isn't an object or a
class name.    So here's another way to check if a reference is a
blessed object

    print "It's still an object\n" if UNIVERSAL::can($val, 'can');

You can also use the C<blessed> function of Scalar::Util:

    use Scalar::Util 'blessed';

    my $blessing = blessed $suspected_object;

C<blessed> returns the name of the package the argument has been
blessed into, or C<undef>.

d421 2
a422 1
available to your program (and you should not do so).
a550 1
See L<perlhack/PERL_DESTRUCT_LEVEL> for more information.
d563 1
a563 1
be found in L<perltoot>, L<perlboot> and L<perltooc>.  You should
@


1.1.1.6
log
@perl 5.8.3 from CPAN
@
text
@a277 10
It is important to note that C<SUPER> refers to the superclass(es) of the
I<current package> and not to the superclass(es) of the object. Also, the
C<SUPER> pseudo-class can only currently be used as a modifier to a method
name, but not in any of the other ways that class names are normally used,
eg:

    something->SUPER::method(...);	# OK
    SUPER::method(...);			# WRONG
    SUPER->method(...);			# WRONG

@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@d100 3
a102 5
C<< $obj->new() >>, then use something like the following.  (Note that using
this to call new() on an instance does not automatically perform any
copying.  If you want a shallow or deep copy of an object, you'll have to
specifically allow for that.)  The initialize() method used will be of
whatever $class we blessed the object into:
d488 3
a490 2
	my $class = shift;
	my $node  = {};
d538 1
a538 1
When run as F</foo/test>, the following output is produced:
d540 7
a546 7
    starting program at /foo/test line 18.
    CREATING SCALAR(0x8e5b8) at /foo/test line 7.
    CREATING SCALAR(0x8e57c) at /foo/test line 7.
    leaving block at /foo/test line 23.
    DESTROYING Subtle=SCALAR(0x8e5b8) at /foo/test line 13.
    just exited block at /foo/test line 26.
    time to die... at /foo/test line 27.
@


1.1.1.8
log
@perl 5.8.8 import
@
text
@a1 1
X<object> X<OOP>
a36 1
X<object> X<bless> X<constructor> X<new>
a141 1
X<class> X<package> X<@@ISA> X<inheritance>
a158 1
X<UNIVERSAL> X<base class> X<class, base>
a169 1
X<AUTOLOAD>
a173 1
X<AUTOLOAD>
a186 1
X<inheritance, method> X<inheritance, data>
a193 1
X<method>
a230 1
X<invocation> X<method> X<arrow> X<< -> >>
a270 1
X<SUPER>
a284 1
X<SUPER>
a299 4
The right side of the arrow typically is the method name, but a simple 
scalar variable containing either the method name or a subroutine 
reference can also be used.

a300 1
X<indirect object syntax> X<invocation, indirect> X<indirect>
a365 1
X<UNIVERSAL>
a372 1
X<isa>
d376 4
a379 7
You can also call C<UNIVERSAL::isa> as a subroutine with two arguments.  Of
course, this will do the wrong thing if someone has overridden C<isa> in a
class, so don't do it.

If you need to determine whether you've received a valid invocant, use the
C<blessed> function from L<Scalar::Util>:
X<invocant> X<blessed>
d381 2
a382 2
    if (blessed($ref) && $ref->isa( 'Some::Class')) {
        # ...
d385 3
a387 2
C<blessed> returns the name of the package the argument has been
blessed into, or C<undef>.
a389 1
X<can>
d395 15
a409 3
C<UNIVERSAL::can> can also be called as a subroutine with two arguments.  It'll
always return I<undef> if its first argument isn't an object or a class name.
The same caveats for calling C<UNIVERSAL::isa> directly apply here, too.
a411 1
X<VERSION>
a434 1
X<destructor> X<DESTROY>
a447 5
Since DESTROY methods can be called at unpredictable times, it is
important that you localise any global variables that the method may
update.  In particular, localise C<$@@> if you use C<eval {}> and
localise C<$?> if you use C<system> or backticks.

a466 2
X<garbage collection> X<GC> X<circular reference>
X<reference, circular> X<DESTROY> X<destructor>
@


1.1.1.9
log
@import perl 5.10.0 from CPAN
@
text
@d154 2
a155 3
class package.  The classes are searched for missing methods in
depth-first, left-to-right order by default (see L<mro> for alternative
search order and other in-depth information).  The classes accessible
@


1.1.1.10
log
@import perl 5.10.1
@
text
@d161 2
a162 2
supplied in the UNIVERSAL class; see L<"Default UNIVERSAL methods"> or
L<UNIVERSAL|UNIVERSAL> for more details.
a315 13
If the right side of the arrow is a scalar containing a reference
to a subroutine, then this is equivalent to calling the referenced
subroutine directly with the class name or object on the left side
of the arrow as its first argument. No lookup is done and there is
no requirement that the subroutine be defined in any package related
to the class name or object on the left side of the arrow.

For example, the following calls to $display are equivalent:

    my $display = sub { my $self = shift; ... };
    $fred->$display("Height", "Weight");
    $display->($fred, "Height", "Weight");

d395 11
a405 2
=item DOES(ROLE)
X<DOES>
d407 2
a408 2
C<DOES> returns I<true> if its object claims to perform the role C<ROLE>.  By
default, this is equivalent to C<isa>.
d415 5
a419 1
C<undef> is returned.
d427 3
a429 2
NEED; it will die if this is not the case.  This method is called automatically
by the C<VERSION> form of C<use>.
d431 1
a431 1
    use Package 1.2 qw(some imported subs);
d433 1
a433 1
    Package->VERSION(1.2);
d436 8
@


1.1.1.11
log
@Perl 5.12.2 from CPAN
@
text
@d353 2
a354 2
For example, a call to a method C<new> in indirect notation (as C++
programmers are wont to make) can be miscompiled into a subroutine
a461 9

DESTROY is subject to AUTOLOAD lookup, just like any other method. Hence, if
your class has an AUTOLOAD method, but does not need any DESTROY actions,
you probably want to provide a DESTROY method anyway, to prevent an
expensive call to AUTOLOAD each time an object is freed. As this technique
makes empty DESTROY methods common, the implementation is optimised so that
a DESTROY method that is an empty or constant subroutine, and hence could
have no side effects anyway, is not actually called.
X<AUTOLOAD> X<DESTROY>
@


1.1.1.12
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a0 6
=encoding utf8

=for comment
Consistent formatting of this file is achieved with:
  perl ./Porting/podtidy pod/perlobj.pod

d4 1
a4 1
perlobj - Perl object reference
d8 4
a11 15
This document provides a reference for Perl's object orientation
features. If you're looking for an introduction to object-oriented
programming in Perl, please see L<perlootut>.

In order to understand Perl objects, you first need to understand
references in Perl. See L<perlref> for details.

This document describes all of Perl's object-oriented (OO) features
from the ground up. If you're just looking to write some
object-oriented code of your own, you are probably better served by
using one of the object systems from CPAN described in L<perlootut>.

If you're looking to write your own object system, or you need to
maintain code which implements objects from scratch then this document
will help you understand exactly how Perl does object orientation.
d13 2
a14 1
There are a few basic principles which define object oriented Perl:
d20 2
a21 2
An object is simply a data structure that knows to which class it
belongs.
d25 2
a26 2
A class is simply a package. A class provides methods that expect to
operate on objects.
d30 2
a31 2
A method is simply a subroutine that expects a reference to an object
(or a package name, for class methods) as the first argument.
d35 1
a35 1
Let's look at each of these principles in depth.
d37 1
a37 1
=head2 An Object is Simply a Data Structure
d40 99
a138 4
Unlike many other languages which support object orientation, Perl does
not provide any special syntax for constructing an object. Objects are
merely Perl data structures (hashes, arrays, scalars, filehandles,
etc.) that have been explicitly associated with a particular class.
d140 2
a141 3
That explicit association is created by the built-in C<bless> function,
which is typically used within the I<constructor> subroutine of the
class.
d143 2
a144 1
Here is a simple constructor:
d146 30
a175 1
  package File;
d177 1
a177 2
  sub new {
      my $class = shift;
d179 2
a180 77
      return bless {}, $class;
  }

The name C<new> isn't special. We could name our constructor something
else:

  package File;

  sub load {
      my $class = shift;

      return bless {}, $class;
  }

The modern convention for OO modules is to always use C<new> as the
name for the constructor, but there is no requirement to do so. Any
subroutine that blesses a data structure into a class is a valid
constructor in Perl.

In the previous examples, the C<{}> code creates a reference to an
empty anonymous hash. The C<bless> function then takes that reference
and associates the hash with the class in C<$class>. In the simplest
case, the C<$class> variable will end up containing the string "File".

We can also use a variable to store a reference to the data structure
that is being blessed as our object:

  sub new {
      my $class = shift;

      my $self = {};
      bless $self, $class;

      return $self;
  }

Once we've blessed the hash referred to by C<$self> we can start
calling methods on it. This is useful if you want to put object
initialization in its own separate method:

  sub new {
      my $class = shift;

      my $self = {};
      bless $self, $class;

      $self->_initialize();

      return $self;
  }

Since the object is also a hash, you can treat it as one, using it to
store data associated with the object. Typically, code inside the class
can treat the hash as an accessible data structure, while code outside
the class should always treat the object as opaque. This is called
B<encapsulation>. Encapsulation means that the user of an object does
not have to know how it is implemented. The user simply calls
documented methods on the object.

Note, however, that (unlike most other OO languages) Perl does not
ensure or enforce encapsulation in any way. If you want objects to
actually I<be> opaque you need to arrange for that yourself. This can
be done in a varierty of ways, including using L<"Inside-Out objects">
or modules from CPAN.

=head3 Objects Are Blessed; Variables Are Not

When we bless something, we are not blessing the variable which
contains a reference to that thing, nor are we blessing the reference
that the variable stores; we are blessing the thing that the variable
refers to (sometimes known as the I<referent>). This is best
demonstrated with this code:

  use Scalar::Util 'blessed';

  my $foo = {};
  my $bar = $foo;
d182 1
a182 2
  bless $foo, 'Class';
  print blessed( $bar );      # prints "Class"
d184 1
a184 2
  $bar = "some other value";
  print blessed( $bar );      # prints undef
d186 14
a199 46
When we call C<bless> on a variable, we are actually blessing the
underlying data structure that the variable refers to. We are not
blessing the reference itself, nor the variable that contains that
reference. That's why the second call to C<blessed( $bar )> returns
false. At that point C<$bar> is no longer storing a reference to an
object.

You will sometimes see older books or documentation mention "blessing a
reference" or describe an object as a "blessed reference", but this is
incorrect. It isn't the reference that is blessed as an object; it's
the thing the reference refers to (i.e. the referent).

=head2 A Class is Simply a Package
X<class> X<package> X<@@ISA> X<inheritance>

Perl does not provide any special syntax for class definitions. A
package is simply a namespace containing variables and subroutines. The
only difference is that in a class, the subroutines may expect a
reference to an object or the name of a class as the first argument.
This is purely a matter of convention, so a class may contain both
methods and subroutines which I<don't> operate on an object or class.

Each package contains a special array called C<@@ISA>. The C<@@ISA> array
contains a list of that class's parent classes, if any. This array is
examined when Perl does method resolution, which we will cover later.

It is possible to manually set C<@@ISA>, and you may see this in older
Perl code. Much older code also uses the L<base> pragma. For new code,
we recommend that you use the L<parent> pragma to declare your parents.
This pragma will take care of setting C<@@ISA>.  It will also load the
parent classes and make sure that the package doesn't inherit from
itself.

However the parent classes are set, the package's C<@@ISA> variable will
contain a list of those parents. This is simply a list of scalars, each
of which is a string that corresponds to a package name.

All classes inherit from the L<UNIVERSAL> class implicitly. The
L<UNIVERSAL> class is implemented by the Perl core, and provides
several default methods, such as C<isa()>, C<can()>, and C<VERSION()>.
The C<UNIVERSAL> class will I<never> appear in a package's C<@@ISA>
variable.

Perl I<only> provides method inheritance as a built-in feature.
Attribute inheritance is left up the class to implement. See the
L</Writing Accessors> section for details.
d204 34
a237 17
Perl does not provide any special syntax for defining a method. A
method is simply a regular subroutine, and is declared with C<sub>.
What makes a method special is that it expects to receive either an
object or a class name as its first argument.

Perl I<does> provide special syntax for method invocation, the C<< ->
>> operator. We will cover this in more detail later.

Most methods you write will expect to operate on objects:

  sub save {
      my $self = shift;

      open my $fh, '>', $self->path() or die $!;
      print {$fh} $self->data()       or die $!;
      close $fh                       or die $!;
  }
d242 40
a281 81
Calling a method on an object is written as C<< $object->method >>.

The left hand side of the method invocation (or arrow) operator is the
object (or class name), and the right hand side is the method name.

  my $pod = File->new( 'perlobj.pod', $data );
  $pod->save();

The C<< -> >> syntax is also used when dereferencing a reference.  It
looks like the same operator, but these are two different operations.

When you call a method, the thing on the left side of the arrow is
passed as the first argument to the method. That means when we call C<<
Critter->new() >>, the C<new()> method receives the string C<"Critter">
as its first argument. When we call C<< $fred->speak() >>, the C<$fred>
variable is passed as the first argument to C<speak()>.

Just as with any Perl subroutine, all of the arguments passed in C<@@_>
are aliases to the original argument. This includes the object itself.
If you assign directly to C<$_[0]> you will change the contents of the
variable that holds the reference to the object. We recommend that you
don't do this unless you know exactly what you're doing.

Perl knows what package the method is in by looking at the left side of
the arrow. If the left hand side is a package name, it looks for the
method in that package. If the left hand side is an object, then Perl
looks for the method in the package that the object has been blessed
into.

If the left hand side is neither a package name nor an object, then the
method call will cause an error, but see the section on L</Method Call
Variations> for more nuances.

=head2 Inheritance
X<inheritance>

We already talked about the special C<@@ISA> array and the L<parent>
pragma.

When a class inherits from another class, any methods defined in the
parent class are available to the child class. If you attempt to call a
method on an object that isn't defined in its own class, Perl will also
look for that method in any parent classes it may have.

  package File::MP3;
  use parent 'File';    # sets @@File::MP3::ISA = ('File');

  my $mp3 = File::MP3->new( 'Andvari.mp3', $data );
  $mp3->save();

Since we didn't define a C<save()> method in the C<File::MP3> class,
Perl will look at the C<File::MP3> class's parent classes to find the
C<save()> method. If Perl cannot find a C<save()> method anywhere in
the inheritance hierarchy, it will die.

In this case, it finds a C<save()> method in the C<File> class. Note
that the object passed to C<save()> in this case is still a
C<File::MP3> object, even though the method is found in the C<File>
class.

We can override a parent's method in a child class. When we do so, we
can still call the parent class's method with the C<SUPER>
pseudo-class.

  sub save {
      my $self = shift;

      say 'Prepare to rock';
      $self->SUPER::save();
  }

The C<SUPER> modifier can I<only> be used for method calls. You can't
use it for regular subroutine calls or class methods:

  SUPER::save($thing);     # FAIL: looks for save() sub in package SUPER

  SUPER->save($thing);     # FAIL: looks for save() method in class
                           #       SUPER

  $thing->SUPER::save();   # Okay: looks for save() method in parent
                           #       classes
d283 2
d286 10
a295 1
=head3 How SUPER is Resolved
d298 3
a300 192
The C<SUPER> pseudo-class is resolved from the package where the call
is made. It is I<not> resolved based on the object's class. This is
important, because it lets methods at different levels within a deep
inheritance hierarchy each correctly call their respective parent
methods.

  package A;

  sub new {
      return bless {}, shift;
  }

  sub speak {
      my $self = shift;

      $self->SUPER::speak();

      say 'A';
  }

  package B;

  use parent 'A';

  sub speak {
      my $self = shift;

      $self->SUPER::speak();

      say 'B';
  }

  package C;

  use parent 'B';

  sub speak {
      my $self = shift;

      $self->SUPER::speak();

      say 'C';
  }

  my $c = C->new();
  $c->speak();

In this example, we will get the following output:

  A
  B
  C

This demonstrates how C<SUPER> is resolved. Even though the object is
blessed into the C<C> class, the C<speak()> method in the C<B> class
can still call C<SUPER::speak()> and expect it to correctly look in the
parent class of C<B> (i.e the class the method call is in), not in the
parent class of C<C> (i.e. the class the object belongs to).

There are rare cases where this package-based resolution can be a
problem. If you copy a subroutine from one package to another, C<SUPER>
resolution will be done based on the original package.

=head3 Multiple Inheritance
X<multiple inheritance>

Multiple inheritance often indicates a design problem, but Perl always
gives you enough rope to hang yourself with if you ask for it.

To declare multiple parents, you simply need to pass multiple class
names to C<use parent>:

  package MultiChild;

  use parent 'Parent1', 'Parent2';

=head3 Method Resolution Order
X<method resolution order> X<mro>

Method resolution order only matters in the case of multiple
inheritance. In the case of single inheritance, Perl simply looks up
the inheritance chain to find a method:

  Grandparent
    |
  Parent
    |
  Child

If we call a method on a C<Child> object and that method is not defined
in the C<Child> class, Perl will look for that method in the C<Parent>
class and then, if necessary, in the C<Grandparent> class.

If Perl cannot find the method in any of these classes, it will die
with an error message.

When a class has multiple parents, the method lookup order becomes more
complicated.

By default, Perl does a depth-first left-to-right search for a method.
That means it starts with the first parent in the C<@@ISA> array, and
then searches all of its parents, grandparents, etc. If it fails to
find the method, it then goes to the next parent in the original
class's C<@@ISA> array and searches from there.

            SharedGreatGrandParent
            /                    \
  PaternalGrandparent       MaternalGrandparent
            \                    /
             Father        Mother
                   \      /
                    Child

So given the diagram above, Perl will search C<Child>, C<Father>,
C<PaternalGrandparent>, C<SharedGreatGrandParent>, C<Mother>, and
finally C<MaternalGrandparent>. This may be a problem because now we're
looking in C<SharedGreatGrandParent> I<before> we've checked all its
derived classes (i.e. before we tried C<Mother> and
C<MaternalGrandparent>).

It is possible to ask for a different method resolution order with the
L<mro> pragma.

  package Child;

  use mro 'c3';
  use parent 'Father', 'Mother';

This pragma lets you switch to the "C3" resolution order. In simple
terms, "C3" order ensures that shared parent classes are never searched
before child classes, so Perl will now search: C<Child>, C<Father>,
C<PaternalGrandparent>, C<Mother> C<MaternalGrandparent>, and finally
C<SharedGreatGrandParent>. Note however that this is not
"breadth-first" searching: All the C<Father> ancestors (except the
common ancestor) are searched before any of the C<Mother> ancestors are
considered.

The C3 order also lets you call methods in sibling classes with the
C<next> pseudo-class. See the L<mro> documentation for more details on
this feature.

=head3 Method Resolution Caching

When Perl searches for a method, it caches the lookup so that future
calls to the method do not need to search for it again. Changing a
class's parent class or adding subroutines to a class will invalidate
the cache for that class.

The L<mro> pragma provides some functions for manipulating the method
cache directly.

=head2 Writing Constructors
X<constructor>

As we mentioned earlier, Perl provides no special constructor syntax.
This means that a class must implement its own constructor. A
constructor is simply a class method that returns a reference to a new
object.

The constructor can also accept additional parameters that define the
object. Let's write a real constructor for the C<File> class we used
earlier:

  package File;

  sub new {
      my $class = shift;
      my ( $path, $data ) = @@_;

      my $self = bless {
          path => $path,
          data => $data,
      }, $class;

      return $self;
  }

As you can see, we've stored the path and file data in the object
itself. Remember, under the hood, this object is still just a hash.
Later, we'll write accessors to manipulate this data.

For our File::MP3 class, we can check to make sure that the path we're
given ends with ".mp3":

  package File::MP3;

  sub new {
      my $class = shift;
      my ( $path, $data ) = @@_;

      die "You cannot create a File::MP3 without an mp3 extension\n"
          unless $path =~ /\.mp3\z/;
d302 3
a304 2
      return $class->SUPER::new(@@_);
  }
d306 1
a306 2
This constructor lets its parent class do the actual object
construction.
d308 1
a308 2
=head2 Attributes
X<attribute>
d310 1
a310 3
An attribute is a piece of data belonging to a particular object.
Unlike most object-oriented languages, Perl provides no special syntax
or support for declaring and manipulating attributes.
d312 3
a314 3
Attributes are often stored in the object itself. For example, if the
object is an anonymous hash, we can store the attribute values in the
hash using the attribute name as the key.
d316 6
a321 3
While it's possible to refer directly to these hash keys outside of the
class, it's considered a best practice to wrap all access to the
attribute with accessor methods.
d323 1
a323 3
This has several advantages. Accessors make it easier to change the
implementation of an object later while still preserving the original
API.
d325 3
a327 4
An accessor lets you add additional code around attribute access. For
example, you could apply a default to an attribute that wasn't set in
the constructor, or you could validate that a new value for the
attribute is acceptable.
d329 2
a330 3
Finally, using accessors makes inheritance much simpler. Subclasses can
use the accessors rather than having to know how a parent class is
implemented internally.
d332 3
a334 2
=head3 Writing Accessors
X<accessor>
d336 1
a336 3
As with constructors, Perl provides no special accessor declaration
syntax, so classes must provide explicitly written accessor methods.
There are two common types of accessors, read-only and read-write.
d338 1
a338 2
A simple read-only accessor simply gets the value of a single
attribute:
d340 2
a341 2
  sub path {
      my $self = shift;
d343 3
a345 2
      return $self->{path};
  }
d347 5
a351 2
A read-write accessor will allow the caller to set the value as well as
get it:
d353 7
a359 2
  sub path {
      my $self = shift;
d361 7
a367 3
      if (@@_) {
          $self->{path} = shift;
      }
d369 2
a370 2
      return $self->{path};
  }
d372 1
a372 1
=head2 An Aside About Smarter and Safer Code
d374 2
a375 3
Our constructor and accessors are not very smart. They don't check that
a C<$path> is defined, nor do they check that a C<$path> is a valid
filesystem path.
d377 1
a377 4
Doing these checks by hand can quickly become tedious. Writing a bunch
of accessors by hand is also incredibly tedious. There are a lot of
modules on CPAN that can help you write safer and more concise code,
including the modules we recommend in L<perlootut>.
d379 2
a380 168
=head2 Method Call Variations
X<method>

Perl supports several other ways to call methods besides the C<<
$object->method() >> usage we've seen so far.

=head3 Method Names as Strings

Perl lets you use a scalar variable containing a string as a method
name:

  my $file = File->new( $path, $data );

  my $method = 'save';
  $file->$method();

This works exactly like calling C<< $file->save() >>. This can be very
useful for writing dynamic code. For example, it allows you to pass a
method name to be called as a parameter to another method.

=head3 Class Names as Strings

Perl also lets you use a scalar containing a string as a class name:

  my $class = 'File';

  my $file = $class->new( $path, $data );

Again, this allows for very dynamic code.

=head3 Subroutine References as Methods

You can also use a subroutine reference as a method:

  my $sub = sub {
      my $self = shift;

      $self->save();
  };

  $file->$sub();

This is exactly equivalent to writing C<< $sub->($file) >>. You may see
this idiom in the wild combined with a call to C<can>:

  if ( my $meth = $object->can('foo') ) {
      $object->$meth();
  }

=head3 Deferencing Method Call

Perl also lets you use a dereferenced scalar reference in a method
call. That's a mouthful, so let's look at some code:

  $file->${ \'save' };
  $file->${ returns_scalar_ref() };
  $file->${ \( returns_scalar() ) };
  $file->${ returns_sub_ref() };

This works if the dereference produces a string I<or> a subroutine
reference.

=head3 Method Calls on Filehandles

Under the hood, Perl filehandles are instances of the C<IO::Handle> or
C<IO::File> class. Once you have an open filehandle, you can call
methods on it. Additionally, you can call methods on the C<STDIN>,
C<STDOUT>, and C<STDERR> filehandles.

  open my $fh, '>', 'path/to/file';
  $fh->autoflush();
  $fh->print('content');

  STDOUT->autoflush();

=head2 Invoking Class Methods
X<invocation>

Because Perl allows you to use barewords for package names and
subroutine names, it sometimes interprets a bareword's meaning
incorrectly. For example, the construct C<< Class->new() >> can be
interpreted as either C<< 'Class'->new() >> or C<< Class()->new() >>.
In English, that second interpretation reads as "call a subroutine
named Class(), then call new() as a method on the return value of
Class()". If there is a subroutine named C<Class()> in the current
namespace, Perl will always interpret C<< Class->new() >> as the second
alternative: a call to C<new()> on the object  returned by a call to
C<Class()>

You can force Perl to use the first interpretation (i.e. as a method
call on the class named "Class") in two ways. First, you can append a
C<::> to the class name:

    Class::->new()

Perl will always interpret this as a method call.

Alternatively, you can quote the class name:

    'Class'->new()

Of course, if the class name is in a scalar Perl will do the right
thing as well:

    my $class = 'Class';
    $class->new();

=head3 Indirect Object Syntax
X<indirect object>

B<Outside of the file handle case, use of this syntax is discouraged,
as it can confuse the Perl interpreter. See below for more details.>

Perl suports another method invocation syntax called "indirect object"
notation. This syntax is called "indirect" because the method comes
before the object it is being invoked on.

This syntax can be used with any class or object method:

    my $file = new File $path, $data;
    save $file;

We recommend that you avoid this syntax, for several reasons.

First, it can be confusing to read. In the above example, it's not
clear if C<save> is a method provided by the C<File> class or simply a
subroutine that expects a file object as its first argument.

When used with class methods, the problem is even worse. Because Perl
allows subroutine names to be written as barewords, Perl has to guess
whether the bareword after the method is a class name or subroutine
name. In other words, Perl can resolve the syntax as either C<<
File->new( $path, $data ) >> B<or> C<< new( File( $path, $data ) ) >>.

To parse this code, Perl uses a heuristic based on what package names
it has seen, what subroutines exist in the current package, what
barewords it has previously seen, and other input. Needless to say,
heuristics can produce very surprising results!

Older documentation (and some CPAN modules) encouraged this syntax,
particularly for constructors, so you may still find it in the wild.
However, we encourage you to avoid using it in new code.

You can force Perl to interpret the bareword as a class name by
appending "::" to it, like we saw earlier:

  my $file = new File:: $path, $data;

=head2 C<bless>, C<blessed>, and C<ref>

As we saw earlier, an object is simply a data structure that has been
blessed into a class via the C<bless> function. The C<bless> function
can take either one or two arguments:

  my $object = bless {}, $class;
  my $object = bless {};

In the first form, the anonymous hash is being blessed into the class
in C<$class>. In the second form, the anonymous hash is blessed into
the current package.

The second form is strongly discouraged, because it breaks the ability
of a subclass to reuse the parent's constructor, but you may still run
across it in existing code.

If you want to know whether a particular scalar refers to an object,
you can use the C<blessed> function exported by L<Scalar::Util>, which
is shipped with the Perl core.
d382 2
a383 1
  use Scalar::Util 'blessed';
d385 2
a386 1
  if ( defined blessed($thing) ) { ... }
d388 6
a393 4
If C<$thing> refers to an object, then this function returns the name
of the package the object has been blessed into. If C<$thing> doesn't
contain a reference to a blessed object, the C<blessed> function
returns C<undef>.
d395 1
a395 15
Note that C<blessed($thing)> will also return false if C<$thing> has
been blessed into a class named "0". This is a possible, but quite
pathological. Don't create a class named "0" unless you know what
you're doing.

Similarly, Perl's built-in C<ref> function treats a reference to a
blessed object specially. If you call C<ref($thing)> and C<$thing>
holds a reference to an object, it will return the name of the class
that the object has been blessed into.

If you simply want to check that a variable contains an object
reference, we recommend that you use C<defined blessed($object)>, since
C<ref> returns true values for all references, not just objects.

=head2 The UNIVERSAL Class
d398 2
a399 5
All classes automatically inherit from the L<UNIVERSAL> class, which is
built-in to the Perl core. This class provides a number of methods, all
of which can be called on either a class or an object. You can also
choose to override some of these methods in your class. If you do so,
we recommend that you follow the built-in semantics described below.
d403 1
a403 1
=item isa($class)
d406 1
a406 4
The C<isa> method returns I<true> if the object is a member of the
class in C<$class>, or a member of a subclass of C<$class>.

If you override this method, it should never throw an exception.
d408 1
a408 1
=item DOES($role)
d411 2
a412 4
The C<DOES> method returns I<true> if its object claims to perform the
role C<$role>. By default, this is equivalent to C<isa>. This method is
provided for use by object system extensions that implement roles, like
C<Moose> and C<Role::Tiny>.
d414 1
a414 4
You can also override C<DOES> directly in your own classes. If you
override this method, it should never throw an exception.

=item can($method)
d417 3
a419 10
The C<can> method checks to see if the class or object it was called on
has a method named C<$method>. This checks for the method in the class
and all of its parents. If the method exists, then a reference to the
subroutine is returned. If it does not then C<undef> is returned.

If your class responds to method calls via C<AUTOLOAD>, you may want to
overload C<can> to return a subroutine reference for methods which your
C<AUTOLOAD> method handles.

If you override this method, it should never throw an exception.
d421 1
a421 1
=item VERSION($need)
d424 5
a428 7
The C<VERSION> method returns the version number of the class
(package).

If the C<$need> argument is given then it will check that the current
version (as defined by the $VERSION variable in the package) is greater
than or equal to C<$need>; it will die if this is not the case. This
method is called automatically by the C<VERSION> form of C<use>.
a433 9
We recommend that you use this method to access another package's
version, rather than looking directly at C<$Package::VERSION>. The
package you are looking at could have overridden the C<VERSION> method.

We also recommend using this method to check whether a module has a
sufficient version. The internal implementation uses the L<version>
module to make sure that different types of version numbers are
compared correctly.

a435 48
=head2 AUTOLOAD
X<AUTOLOAD>

If you call a method that doesn't exist in a class, Perl will throw an
error. However, if that class or any of its parent classes defines an
C<AUTOLOAD> method, that C<AUTOLOAD> method is called instead.

C<AUTOLOAD> is called as a regular method, and the caller will not know
the difference. Whatever value your C<AUTOLOAD> method returns is
returned to the caller.

The fully qualified method name that was called is available in the
C<$AUTOLOAD> package global for your class. Since this is a global, if
you want to refer to do it without a package name prefix under C<strict
'vars'>, you need to declare it.

  # XXX - this is a terrible way to implement accessors, but it makes
  # for a simple example.
  our $AUTOLOAD;
  sub AUTOLOAD {
      my $self = shift;

      # Remove qualifier from original method name...
      my $called =  $AUTOLOAD =~ s/.*:://r;

      # Is there an attribute of that name?
      die "No such attribute: $called"
          unless exists $self->{$called};

      # If so, return it...
      return $self->{$called};
  }

  sub DESTROY { } # see below

Without the C<our $AUTOLOAD> declaration, this code will not compile
under the L<strict> pragma.

As the comment says, this is not a good way to implement accessors. 
It's slow and too clever by far. However, you may see this as a way to
provide accessors in older Perl code. See L<perlootut> for
recommendations on OO coding in Perl.

If your class does have an C<AUTOLOAD> method, we strongly recommend
that you override C<can> in your class as well. Your overridden C<can>
method should return a subroutine reference for any method that your
C<AUTOLOAD> responds to.

d440 148
a587 149
destroyed. If you only have one reference to an object stored in a
lexical scalar, the object is destroyed when that scalar goes out of
scope. If you store the object in a package global, that object may not
go out of scope until the program exits.

If you want to do something when the object is destroyed, you can
define a C<DESTROY> method in your class. This method will always be
called by Perl at the appropriate time, unless the method is empty.

This is called just like any other method, with the object as the first
argument. It does not receive any additional arguments. However, the
C<$_[0]> variable will be read-only in the destructor, so you cannot
assign a value to it.

If your C<DESTROY> method throws an error, this error will be ignored.
It will not be sent to C<STDERR> and it will not cause the program to
die. However, if your destructor is running inside an C<eval {}> block,
then the error will change the value of C<$@@>.

Because C<DESTROY> methods can be called at any time, you should
localize any global variables you might update in your C<DESTROY>. In
particular, if you use C<eval {}> you should localize C<$@@>, and if you
use C<system> or backticks, you should localize C<$?>.

If you define an C<AUTOLOAD> in your class, then Perl will call your
C<AUTOLOAD> to handle the C<DESTROY> method. You can prevent this by
defining an empty C<DESTROY>, like we did in the autoloading example.
You can also check the value of C<$AUTOLOAD> and return without doing
anything when called to handle C<DESTROY>.

=head3 Global Destruction

The order in which objects are destroyed during the global destruction
before the program exits is unpredictable. This means that any objects
contained by your object may already have been destroyed. You should
check that a contained object is defined before calling a method on it:

  sub DESTROY {
      my $self = shift;

      $self->{handle}->close() if $self->{handle};
  }

You can use the C<${^GLOBAL_PHASE}> variable to detect if you are
currently in the global destruction phase:

  sub DESTROY {
      my $self = shift;

      return if ${^GLOBAL_PHASE} eq 'DESTRUCT';

      $self->{handle}->close();
  }

Note that this variable was added in Perl 5.14.0. If you want to detect
the global destruction phase on older versions of Perl, you can use the
C<Devel::GlobalDestruction> module on CPAN.

If your C<DESTROY> method issues a warning during global destruction,
the Perl interpreter will append the string " during global
destruction" the warning.

During global destruction, Perl will always garbage collect objects
before unblessed references. See L<perlhacktips/PERL_DESTRUCT_LEVEL>
for more information about global destruction.

=head2 Non-Hash Objects

All the examples so far have shown objects based on a blessed hash.
However, it's possible to bless any type of data structure or referent,
including scalars, globs, and subroutines. You may see this sort of
thing when looking at code in the wild.

Here's an example of a module as a blessed scalar:

  package Time;

  use strict;
  use warnings;

  sub new {
      my $class = shift;

      my $time = time;
      return bless \$time, $class;
  }

  sub epoch {
      my $self = shift;
      return ${ $self };
  }

  my $time = Time->new();
  print $time->epoch();

=head2 Inside-Out objects

In the past, the Perl community experimented with a technique called
"inside-out objects". An inside-out object stores its data outside of
the object's reference, indexed on a unique property of the object,
such as its memory address, rather than in the object itself. This has
the advantage of enforcing the encapsulation of object attributes,
since their data is not stored in the object itself.

This technique was popular for a while (and was recommended in Damian
Conway's I<Perl Best Practices>), but never achieved universal
adoption. The L<Object::InsideOut> module on CPAN provides a
comprehensive implementation of this technique, and you may see it or
other inside-out modules in the wild.

Here is a simple example of the technique, using the
L<Hash::Util::FieldHash> core module. This module was added to the core
to support inside-out object implementations.

  package Time;

  use strict;
  use warnings;

  use Hash::Util::FieldHash 'fieldhash';

  fieldhash my %time_for;

  sub new {
      my $class = shift;

      my $self = bless \( my $object ), $class;

      $time_for{$self} = time;

      return $self;
  }

  sub epoch {
      my $self = shift;

      return $time_for{$self};
  }

  my $time = Time->new;
  print $time->epoch;

=head2 Pseudo-hashes

The pseudo-hash feature was an experimental feature introduced in
earlier versions of Perl and removed in 5.10.0. A pseudo-hash is an
array reference which can be accessed using named keys like a hash. You
may run in to some code in the wild which uses it. See the L<fields>
pragma for more information.
d592 4
a595 3
be found in L<perlootut>. You should also check out L<perlmodlib> for
some style guides on constructing both modules and classes.

@


1.1.1.13
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d185 1
a185 1
This pragma will take care of setting C<@@ISA>. It will also load the
d235 1
a235 1
The C<< -> >> syntax is also used when dereferencing a reference. It
d328 2
d335 1
a335 1
  use parent -norequire, 'A';
d347 1
a347 1
  use parent -norequire, 'B';
d637 1
a637 1
  $file->${ returns_ref_to_sub_ref() };
d690 2
a691 2
B<Outside of the file handle case, use of this syntax is discouraged as
it can confuse the Perl interpreter. See below for more details.>
d880 1
a880 1
As the comment says, this is not a good way to implement accessors.
d916 1
a916 1
use C<system> or backticks you should localize C<$?>.
@


1.1.1.14
log
@Import perl-5.20.1
@
text
@d134 1
a134 1
be done in a variety of ways, including using L<"Inside-Out objects">
d691 1
a691 1
Perl supports another method invocation syntax called "indirect object"
@


1.1.1.15
log
@Import perl-5.24.2
@
text
@d151 1
a151 1
  print blessed( $bar ) // 'not blessed';    # prints "Class"
d154 1
a154 1
  print blessed( $bar ) // 'not blessed';    # prints "not blessed"
d952 1
a952 1
destruction" to the warning.
@


