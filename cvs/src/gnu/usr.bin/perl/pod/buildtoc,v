head	1.16;
access;
symbols
	OPENBSD_6_0:1.15.0.10
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.4
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.6
	OPENBSD_5_8_BASE:1.15
	PERL_5_20_2:1.1.1.12
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	PERL_5_20_1:1.1.1.12
	OPENBSD_5_6:1.14.0.8
	OPENBSD_5_6_BASE:1.14
	PERL_5_18_2:1.1.1.11
	PERL:1.1.1
	OPENBSD_5_5:1.14.0.6
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	PERL_5_16_3:1.1.1.11
	OPENBSD_5_3:1.13.0.10
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.8
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.6
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	PERL_5_12_2:1.1.1.10
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	PERL_5_10_1:1.1.1.9
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.16
date	2017.02.05.00.32.18;	author afresh1;	state Exp;
branches;
next	1.15;
commitid	cxJ08BvJA9Pt2PTM;

1.15
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.14;
commitid	QP75iYx42Uo7mMxO;

1.14
date	2013.03.25.20.40.56;	author sthen;	state Exp;
branches;
next	1.13;

1.13
date	2010.09.24.15.07.03;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.12.18.55.12;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.12.18.24.47;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.29.17.36.16;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.28.19.23.09;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2005.01.15.21.30.34;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2004.04.07.21.33.07;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.03.03.12.05;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.35.50;	author millert;	state dead;
branches;
next	1.4;

1.4
date	2000.04.06.17.07.17;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.07;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.58.56;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.55;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.55;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.40.32;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.19;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.12.03.02.44.19;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.04.07.21.13.31;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2005.01.15.21.17.46;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.03.28.18.49.13;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.29.17.18.50;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.10.12.18.10.40;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2010.09.24.14.49.11;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2013.03.25.20.09.12;	author sthen;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.11.17.20.53.12;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.16
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!/usr/bin/perl -w

use strict;
use vars qw($Quiet);
use File::Spec;
use FindBin;
use Text::Wrap;
use Getopt::Long;

no locale;

# Assumption is that we're either already being run from the top level (*nix,
# VMS), or have absolute paths in @@INC (Win32, pod/Makefile)
BEGIN {
  my $Top = File::Spec->catdir($FindBin::Bin, File::Spec->updir);
  chdir $Top or die "Can't chdir to $Top: $!";
  require 'Porting/pod_lib.pl';
}

die "$0: Usage: $0 [--quiet]\n"
    unless GetOptions (quiet => \$Quiet) && !@@ARGV;

my $state = get_pod_metadata(0, sub { warn @@_ if @@_ }, 'pod/perltoc.pod');

my $found = pods_to_install();

my_die "Can't find any pods!\n" unless %$found;

# Accumulating everything into a lexical before writing to disk dates from the
# time when this script also provided the functionality of regen/pod_rules.pl
# and this code was in a subroutine do_toc(). In turn, the use of a file scoped
# lexical instead of a parameter or return value is because the code dates back
# further still, and used *only* to create pod/perltoc.pod by printing direct

my $OUT;
my $roffitall;

($_= <<"EOPOD2B") =~ s/^\t//gm and $OUT .= $_;

	# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
	# This file is autogenerated by buildtoc from all the other pods.
	# Edit those files and run $0 to effect changes.

	=encoding UTF-8

	=head1 NAME

	perltoc - perl documentation table of contents

	=head1 DESCRIPTION

	This page provides a brief table of contents for the rest of the Perl
	documentation set.  It is meant to be scanned quickly or grepped
	through to locate the proper section you're looking for.

	=head1 BASIC DOCUMENTATION

EOPOD2B

# All the things in the master list that happen to be pod filenames
foreach (grep {!$_->[2]{toc_omit}} @@{$state->{master}}) {
    $roffitall .= "    \$mandir/$_->[0].1 \\\n";
    podset($_->[0], $_->[1]);
}

foreach my $type (qw(PRAGMA MODULE)) {
    ($_= <<"EOPOD2B") =~ s/^\t//gm and $OUT .= $_;



	=head1 $type DOCUMENTATION

EOPOD2B

    foreach my $name (sort keys %{$found->{$type}}) {
        $roffitall .= "    \$libdir/$name.3 \\\n";
        podset($name, $found->{$type}{$name});
    }
}

$_= <<"EOPOD2B";


	=head1 AUXILIARY DOCUMENTATION

	Here should be listed all the extra programs' documentation, but they
	don't all have manual pages yet:

	=over 4

EOPOD2B

$_ .=  join "\n", map {"\t=item $_\n"} @@{$state->{aux}};
$_ .= <<"EOPOD2B" ;

	=back

	=head1 AUTHOR

	Larry Wall <F<larry\@@wall.org>>, with the help of oodles
	of other folks.


EOPOD2B

s/^\t//gm;
$OUT .= "$_\n";

$OUT =~ s/\n\s+\n/\n\n/gs;
$OUT =~ s/\n{3,}/\n\n/g;

$OUT =~ s/([^\n]+)/wrap('', '', $1)/ge;

write_or_die('pod/perltoc.pod', $OUT);

write_or_die('pod/roffitall', <<'EOH' . $roffitall . <<'EOT');
#!/bin/sh
#
# Usage: roffitall [-nroff|-psroff|-groff]
#
# Authors: Tom Christiansen, Raphael Manfredi

me=roffitall
tmp=.

if test -f ../config.sh; then
	. ../config.sh
fi

mandir=$installman1dir
libdir=$installman3dir

test -d $mandir || mandir=/usr/new/man/man1
test -d $libdir || libdir=/usr/new/man/man3

case "$1" in
-nroff) cmd="nroff -man"; ext='txt';;
-psroff) cmd="psroff -t"; ext='ps';;
-groff) cmd="groff -man"; ext='ps';;
*)
	echo "Usage: roffitall [-nroff|-psroff|-groff]" >&2
	exit 1
	;;
esac

toroff=`
	echo		\
EOH
    | perl -ne 'map { -r && print "$_ " } split'`

    # Bypass internal shell buffer limit -- can't use case
    if perl -e '$a = shift; exit($a =~ m|/|)' $toroff; then
	echo "$me: empty file list -- did you run install?" >&2
	exit 1
    fi

    #psroff -t -man -rC1 -rD1 -rF1 > $tmp/PerlDoc.ps 2>$tmp/PerlTOC.raw
    #nroff -man -rC1 -rD1 -rF1 > $tmp/PerlDoc.txt 2>$tmp/PerlTOC.nr.raw

    # First, create the raw data
    run="$cmd -rC1 -rD1 -rF1 >$tmp/PerlDoc.$ext 2>$tmp/PerlTOC.$ext.raw"
    echo "$me: running $run"
    eval $run $toroff

    #Now create the TOC
    echo "$me: parsing TOC"
    perl rofftoc $tmp/PerlTOC.$ext.raw > $tmp/PerlTOC.tmp.man
    run="$cmd $tmp/PerlTOC.tmp.man >$tmp/PerlTOC.$ext"
    echo "$me: running $run"
    eval $run

    # Finally, recreate the Doc, without the blank page 0
    run="$cmd -rC1 -rD1 >$tmp/PerlDoc.$ext 2>$tmp/PerlTOC.$ext.raw"
    echo "$me: running $run"
    eval $run $toroff
    rm -f $tmp/PerlTOC.tmp.man $tmp/PerlTOC.$ext.raw
    echo "$me: leaving you with $tmp/PerlDoc.$ext and $tmp/PerlTOC.$ext"
EOT

exit(0);

# Below are all the auxiliary routines for generating perltoc.pod

my ($inhead1, $inhead2, $initem);

sub podset {
    my ($pod, $file) = @@_;

    open my $fh, '<', $file or my_die "Can't open file '$file' for $pod: $!";

    local *_;
    my $found_pod;
    while (<$fh>) {
        if (/^=head1\s+NAME\b/) {
            ++$found_pod;
            last;
        }
    }

    unless ($found_pod) {
	warn "$0: NOTE: cannot find '=head1 NAME' in:\n  $file\n" unless $Quiet;
        return;
    }

    seek $fh, 0, 0 or my_die "Can't rewind file '$file': $!";
    local $/ = '';

    while(<$fh>) {
	tr/\015//d;
	if (s/^=head1 (NAME)\s*/=head2 /) {
	    unhead1();
	    $OUT .= "\n\n=head2 ";
	    $_ = <$fh>;
	    # Remove svn keyword expansions from the Perl FAQ
	    s/ \(\$Revision: \d+ \$\)//g;
	    if ( /^\s*\Q$pod\E\b/ ) {
		s/$pod\.pm/$pod/;       # '.pm' in NAME !?
	    } else {
		s/^/$pod, /;
	    }
	}
	elsif (s/^=head1 (.*)/=item $1/) {
	    unhead2();
	    $OUT .= "=over 4\n\n" unless $inhead1;
	    $inhead1 = 1;
	    $_ .= "\n";
	}
	elsif (s/^=head2 (.*)/=item $1/) {
	    unitem();
	    $OUT .= "=over 4\n\n" unless $inhead2;
	    $inhead2 = 1;
	    $_ .= "\n";
	}
	elsif (s/^=item ([^=].*)/$1/) {
	    next if $pod eq 'perldiag';
	    s/^\s*\*\s*$// && next;
	    s/^\s*\*\s*//;
	    s/\n/ /g;
	    s/\s+$//;
	    next if /^[\d.]+$/;
	    next if $pod eq 'perlmodlib' && /^ftp:/;
	    $OUT .= ", " if $initem;
	    $initem = 1;
	    s/\.$//;
	    s/^-X\b/-I<X>/;
	}
	else {
	    unhead1() if /^=cut\s*\n/;
	    next;
	}
	$OUT .= $_;
    }
}

sub unhead1 {
    unhead2();
    if ($inhead1) {
	$OUT .= "\n\n=back\n\n";
    }
    $inhead1 = 0;
}

sub unhead2 {
    unitem();
    if ($inhead2) {
	$OUT .= "\n\n=back\n\n";
    }
    $inhead2 = 0;
}

sub unitem {
    if ($initem) {
	$OUT .= "\n\n";
    }
    $initem = 0;
}

# ex: set ts=8 sts=4 sw=4 et:
@


1.15
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@a277 5
# Local variables:
# cperl-indent-level: 4
# indent-tabs-mode: nil
# End:
#
@


1.14
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d44 2
@


1.13
log
@merge in perl 5.12.2 plus local changes
@
text
@d4 1
a4 3
use vars qw($masterpodfile %Build %Targets $Verbose $Quiet $Up %Ignore
	    @@Master %Readmes %Pods %Aux %Readmepods %Pragmata %Modules
	    %Copies %Generated);
a5 1
use File::Find;
a6 1
use Text::Tabs;
a8 1
use Carp;
d12 6
a17 213
$Up = File::Spec->updir;
$masterpodfile = File::Spec->catfile($Up, "pod.lst");

# Generate any/all of these files
# --verbose gives slightly more output
# --quiet suppresses routine warnings
# --build-all tries to build everything
# --build-foo updates foo as follows
# --showfiles shows the files to be changed

%Targets
  = (
     toc => "perltoc.pod",
     manifest => File::Spec->catdir($Up, "MANIFEST"),
     perlpod => "perl.pod",
     vms => File::Spec->catfile($Up, "vms", "descrip_mms.template"),
     nmake => File::Spec->catfile($Up, "win32", "Makefile"),
     dmake => File::Spec->catfile($Up, "win32", "makefile.mk"),
     podmak => File::Spec->catfile($Up, "win32", "pod.mak"),
     # plan9 =>  File::Spec->catdir($Up, "plan9", "mkfile"),
     unix => File::Spec->catfile($Up, "Makefile.SH"),
     # TODO: add roffitall
    );

{
  my @@files = keys %Targets;
  my $filesopts = join(" | ", map { "--build-$_" } "all", sort @@files);
  my $showfiles;
  die <<__USAGE__
$0: Usage: $0 [--verbose] [--showfiles] $filesopts
__USAGE__
  unless @@ARGV
	&& GetOptions (verbose => \$Verbose,
		       quiet => \$Quiet,
		       showfiles => \$showfiles,
		       map {+"build-$_", \$Build{$_}} @@files, 'all');
  # Set them all to true
  @@Build{@@files} = @@files if ($Build{all});
  if ($showfiles) {
      print
	  join(" ",
	       sort { lc $a cmp lc $b }
	       map {
		   my ($v, $d, $f) = File::Spec->splitpath($_);
		   my @@d;
		   @@d = defined $d ? File::Spec->splitdir($d) : ();
		   shift @@d if @@d;
		   File::Spec->catfile(@@d ?
				       (@@d == 1 && $d[0] eq '' ? () : @@d)
				       : "pod", $f);
	       } @@Targets{grep { $_ ne 'all' && $Build{$_} } keys %Build}),
          "\n";
      exit(0);
  }
}

# Don't copy these top level READMEs
%Ignore
  = (
     micro => 1,
#     vms => 1,
     );

if ($Verbose) {
  print "I'm building $_\n" foreach grep {$Build{$_}} keys %Build;
}

chdir $FindBin::Bin or die "$0: Can't chdir $FindBin::Bin: $!";

open MASTER, $masterpodfile or die "$0: Can't open $masterpodfile: $!";

my ($delta_source, $delta_target);

foreach (<MASTER>) {
  next if /^\#/;

  # At least one upper case letter somewhere in the first group
  if (/^(\S+)\s(.*)/ && $1 =~ tr/h//) {
    # it's a heading
    my $flags = $1;
    $flags =~ tr/h//d;
    my %flags = (header => 1);
    $flags{toc_omit} = 1 if $flags =~ tr/o//d;
    $flags{aux} = 1 if $flags =~ tr/a//d;
    die "$0: Unknown flag found in heading line: $_" if length $flags;
    push @@Master, [\%flags, $2];

  } elsif (/^(\S*)\s+(\S+)\s+(.*)/) {
    # it's a section
    my ($flags, $filename, $desc) = ($1, $2, $3);

    my %flags = (indent => 0);
    $flags{indent} = $1 if $flags =~ s/(\d+)//;
    $flags{toc_omit} = 1 if $flags =~ tr/o//d; 
    $flags{aux} = 1 if $flags =~ tr/a//d;

    if ($flags =~ tr/D//d) {
      $flags{perlpod_omit} = 1;
      $delta_source = "$filename.pod";
    }
    if ($flags =~ tr/d//d) {
      $flags{manifest_omit} = 1;
      $delta_target = "$filename.pod";
    }
    $Generated{"$filename.pod"}++ if $flags =~ tr/g//d;

    if ($flags =~ tr/r//d) {
      my $readme = $filename;
      $readme =~ s/^perl//;
      $Readmepods{$filename} = $Readmes{$readme} = $desc;
      $flags{readme} = 1;
    } elsif ($flags{aux}) {
      $Aux{$filename} = $desc;
    } else {
      $Pods{$filename} = $desc;
    }
    die "$0: Unknown flag found in section line: $_" if length $flags;
    push @@Master, [\%flags, $filename, $desc];
  } elsif (/^$/) {
    push @@Master, undef;
  } else {
    die "$0: Malformed line: $_" if $1 =~ tr/A-Z//;
  }
}
if (defined $delta_source) {
  if (defined $delta_target) {
    # This way round so that keys can act as a MANIFEST skip list
    # Targets will aways be in the pod directory. Currently we can only cope
    # with sources being in the same directory.
    $Copies{$delta_target} = $delta_source;
  } else {
    die "$0: delta source defined but not target";
  }
} elsif (defined $delta_target) {
  die "$0: delta target defined but not target";
}

close MASTER;

# Sanity cross check
{
  my (%disk_pods, @@disk_pods);
  my (@@manipods, %manipods);
  my (@@manireadmes, %manireadmes);
  my (@@perlpods, %perlpods);
  my (%our_pods);
  my (%sources);

  # Convert these to a list of filenames.
  foreach (keys %Pods, keys %Readmepods) {
    $our_pods{"$_.pod"}++;
  }

  # None of these filenames will be boolean false
  @@disk_pods = glob("*.pod");
  @@disk_pods{@@disk_pods} = @@disk_pods;

  # Things we copy from won't be in perl.pod
  # Things we copy to won't be in MANIFEST
  @@sources{values %Copies} = ();

  open(MANI, "../MANIFEST") || die "$0: opening ../MANIFEST failed: $!";
  while (<MANI>) {
    if (m!^pod/([^.]+\.pod)\s+!i) {
      push @@manipods, $1;
    } elsif (m!^README\.(\S+)\s+!i) {
      next if $Ignore{$1};
      push @@manireadmes, "perl$1.pod";
    }
  }
  close(MANI);
  @@manipods{@@manipods} = @@manipods;
  @@manireadmes{@@manireadmes} = @@manireadmes;

  open(PERLPOD, "perl.pod") || die "$0: opening perl.pod failed: $!\n";
  while (<PERLPOD>) {
    if (/^For ease of access, /../^\(If you're intending /) {
      if (/^\s+(perl\S*)\s+\w/) {
	push @@perlpods, "$1.pod";
      }
    }
  }
  close(PERLPOD);
  die "$0: could not find the pod listing of perl.pod\n"
    unless @@perlpods;
  @@perlpods{@@perlpods} = @@perlpods;

  foreach my $i (sort keys %disk_pods) {
    warn "$0: $i exists but is unknown by buildtoc\n"
      unless $our_pods{$i};
    warn "$0: $i exists but is unknown by ../MANIFEST\n"
      if !$manipods{$i} && !$manireadmes{$i} && !$Copies{$i} && !$Generated{$i};
    warn "$0: $i exists but is unknown by perl.pod\n"
	if !$perlpods{$i} && !exists $sources{$i};
  }
  my @@BuildTargets = grep {defined} @@Targets{grep $_ ne 'all', keys %Build};
  my %BuildFiles;
  @@BuildFiles{@@BuildTargets} = @@BuildTargets;
  
  foreach my $i (sort keys %our_pods) {
    warn "$0: $i is known by buildtoc but does not exist\n"
      unless $disk_pods{$i} or $BuildFiles{$i};
  }
  foreach my $i (sort keys %manipods) {
    warn "$0: $i is known by ../MANIFEST but does not exist\n"
      unless $disk_pods{$i};
    warn "$0: $i is known by ../MANIFEST but is marked as generated\n"
      if $Generated{$i};
  }
  foreach my $i (sort keys %perlpods) {
    warn "$0: $i is known by perl.pod but does not exist\n"
      unless $disk_pods{$i} or $BuildFiles{$i};
  }
d20 2
a21 55
# Find all the modules
{
  my @@modpods;
  find \&getpods => qw(../lib ../ext);

  sub getpods {
    if (/\.p(od|m)$/) {
      my $file = $File::Find::name;
      return if $file eq '../lib/Pod/Functions.pm'; # Used only by pod itself
      return if $file =~ m!(?:^|/)t/!;
      return if $file =~ m!lib/Attribute/Handlers/demo/!;
      return if $file =~ m!lib/Net/FTP/.+\.pm!; # Hi, Graham! :-)
      return if $file =~ m!lib/Math/BigInt/t/!;
      return if $file =~ m!/Devel/PPPort/[Hh]arness|lib/Devel/Harness!i;
      return if $file =~ m!XS/(?:APItest|Typemap)!;
      my $pod = $file;
      return if $pod =~ s/pm$/pod/ && -e $pod;
      die "$0: tut $File::Find::name" if $file =~ /TUT/;
      unless (open (F, "< $_\0")) {
	warn "$0: bogus <$file>: $!";
	system "ls", "-l", $file;
      }
      else {
	my $line;
	while ($line = <F>) {
	  if ($line =~ /^=head1\s+NAME\b/) {
	    push @@modpods, $file;
	    #warn "GOOD $file\n";
	    close F;
	    return;
	  }
	}
	close F;
	warn "$0: $file: cannot find =head1 NAME\n" unless $Quiet;
      }
    }
  }

  die "$0: no pods" unless @@modpods;

  my %done;
  for (@@modpods) {
    #($name) = /(\w+)\.p(m|od)$/;
    my $name = path2modname($_);
    if ($name =~ /^[a-z]/) {
      $Pragmata{$name} = $_;
    } else {
      if ($done{$name}++) {
	# warn "already did $_\n";
	next;
      }
      $Modules{$name} = $_;
    }
  }
}
d23 1
a23 2
# OK. Now a lot of ancillary function definitions follow
# Main program returns at "Do stuff"
d25 1
a25 8
sub path2modname {
    local $_ = shift;
    s/\.p(m|od)$//;
    s-.*?/(lib|ext)/--;
    s-/-::-g;
    s/(\w+)::\1/$1/;
    return $_;
}
d27 1
a27 1
sub output ($);
d29 5
a33 2
sub output_perltoc {
  open(OUT, ">perltoc.pod") || die "$0: creating perltoc.pod failed: $!";
d35 2
a36 1
  local $/ = '';
d38 1
a38 1
  ($_= <<"EOPOD2B") =~ s/^\t//gm && output($_);
d42 1
a42 1
	# Edit those files and run buildtoc --build-toc to effect changes.
a56 1
#' make emacs happy
d58 5
a62 2
  # All the things in the master list that happen to be pod filenames
  podset(map {"$_->[1].pod"} grep {defined $_ && @@$_ == 3 && !$_->[0]{toc_omit}} @@Master);
d64 2
a66 1
  ($_= <<"EOPOD2B") =~ s/^\t//gm && output($_);
d69 1
a69 2

	=head1 PRAGMA DOCUMENTATION
d73 5
a77 4
  podset(sort values %Pragmata);

  ($_= <<"EOPOD2B") =~ s/^\t//gm && output($_);

d79 1
a79 8

	=head1 MODULE DOCUMENTATION

EOPOD2B

  podset( @@Modules{ sort keys %Modules } );

  $_= <<"EOPOD2B";
d91 2
a92 2
  $_ .=  join "\n", map {"\t=item $_\n"} sort keys %Aux;
  $_ .= <<"EOPOD2B" ;
d104 75
a178 5
  s/^\t//gm;
  output $_;
  output "\n";                    # flush $LINE
  close OUT;
}
d185 1
a185 2
    local @@ARGV = @@_;
    my $pod;
d187 1
a187 1
    return unless scalar(@@ARGV);
d189 18
a206 1
    while(<>) {
a208 1
	    $pod = path2modname($ARGV);
d210 2
a211 2
	    output "\n \n\n=head2 ";
	    $_ = <>;
d213 2
a214 2
	    s/ \(\045Revision: \d+ \045\)//g;
	    if ( /^\s*$pod\b/ ) {
a215 1
		output $_;
a217 1
		output $_;
a218 1
	    next;
d220 1
a220 1
	if (s/^=head1 (.*)/=item $1/) {
d222 1
a222 1
	    output "=over 4\n\n" unless $inhead1;
d224 1
a224 1
	    output $_; nl(); next;
d226 1
a226 1
	if (s/^=head2 (.*)/=item $1/) {
d228 1
a228 1
	    output "=over 4\n\n" unless $inhead2;
d230 1
a230 1
	    output $_; nl(); next;
d232 1
a232 1
	if (s/^=item ([^=].*)/$1/) {
d240 1
a240 2
	    ##print "=over 4\n\n" unless $initem;
	    output ", " if $initem;
a243 1
	    output $_; next;
d245 2
a246 2
	if (s/^=cut\s*\n//) {
	    unhead1();
d249 1
d256 1
a256 1
	output "\n\n=back\n\n";
d264 1
a264 1
	output "\n\n=back\n\n";
d271 1
a271 2
	output "\n\n";
	##print "\n\n=back\n\n";
d276 6
a281 303
sub nl {
    output "\n";
}

my $NEWLINE = 0;	# how many newlines have we seen recently
my $LINE;		# what remains to be printed

sub output ($) {
    for (split /(\n)/, shift) {
	if ($_ eq "\n") {
	    if ($LINE) {
		print OUT wrap('', '', $LINE);
		$LINE = '';
	    }
	    if (($NEWLINE) < 2) {
		print OUT;
		$NEWLINE++;
	    }
	}
	elsif (/\S/ && length) {
	    $LINE .= $_;
	    $NEWLINE = 0;
	}
    }
}

# End of original buildtoc. From here on are routines to generate new sections
# for and inplace edit other files

sub generate_perlpod {
  my @@output;
  my $maxlength = 0;
  foreach (@@Master) {
    my $flags = $_->[0];
    next if $flags->{aux};
    next if $flags->{perlpod_omit};

    if (@@$_ == 2) {
      # Heading
      push @@output, "=head2 $_->[1]\n";
    } elsif (@@$_ == 3) {
      # Section
      my $start = " " x (4 + $flags->{indent}) . $_->[1];
      $maxlength = length $start if length ($start) > $maxlength;
      push @@output, [$start, $_->[2]];
    } elsif (@@$_ == 0) {
      # blank line
      push @@output, "\n";
    } else {
      die "$0: Illegal length " . scalar @@$_;
    }
  }
  # want at least 2 spaces padding
  $maxlength += 2;
  $maxlength = ($maxlength + 3) & ~3;
  # sprintf gives $1.....$2 where ... are spaces:
  return unexpand (map {ref $_ ? sprintf "%-${maxlength}s%s\n", @@$_ : $_}
		   @@output);
}


sub generate_manifest {
  # Annyoingly unexpand doesn't consider it good form to replace a single
  # space before a tab with a tab
  # Annoyingly (2) it returns read only values.
  my @@temp = unexpand (map {sprintf "%-32s%s\n", @@$_} @@_);
  map {s/ \t/\t\t/g; $_} @@temp;
}
sub generate_manifest_pod {
  generate_manifest map {["pod/$_.pod", $Pods{$_}]}
    sort grep {!$Copies{"$_.pod"}} grep {!$Generated{"$_.pod"}} keys %Pods;
}
sub generate_manifest_readme {
  generate_manifest sort {$a->[0] cmp $b->[0]}
    ["README.vms", "Notes about installing the VMS port"],
      map {["README.$_", $Readmes{$_}]} keys %Readmes;
}

sub generate_roffitall {
  (map ({"\t\$maindir/$_.1\t\\"}sort keys %Pods),
   "\t\t\\",
   map ({"\t\$maindir/$_.1\t\\"}sort keys %Aux),
   "\t\t\\",
   map ({"\t\$libdir/$_.3\t\\"}sort keys %Pragmata),
   "\t\t\\",
   map ({"\t\$libdir/$_.3\t\\"}sort keys %Modules),
  )
}

sub generate_descrip_mms_1 {
  local $Text::Wrap::columns = 150;
  my $count = 0;
  my @@lines = map {"pod" . $count++ . " = $_"}
    split /\n/, wrap('', '', join " ", map "[.lib.pods]$_.pod",
		     sort keys %Pods, keys %Readmepods);
  @@lines, "pod = " . join ' ', map {"\$(pod$_)"} 0 .. $count - 1;
}

sub generate_descrip_mms_2 {
  map {<<"SNIP"}
[.lib.pods]$_.pod : [.pod]$_.pod
	\@@ If F\$Search("[.lib]pods.dir").eqs."" Then Create/Directory [.lib.pods]
	Copy/NoConfirm/Log \$(MMS\$SOURCE) [.lib.pods]
SNIP
   sort keys %Pods, keys %Readmepods;
}

sub generate_descrip_mms_3 {
  map qq{\t- If F\$Search("[.pod]$_").nes."" Then Delete/NoConfirm/Log [.pod]$_;*},
    sort keys %Generated, keys %Copies;
}

sub generate_nmake_1 {
  # XXX Fix this with File::Spec
  (map {sprintf "\tcopy ..\\README.%-8s ..\\pod\\perl$_.pod\n", $_}
    sort keys %Readmes),
      (map {"\tcopy ..\\pod\\$Copies{$_} ..\\pod\\$_\n"} sort keys %Copies);
}

# This doesn't have a trailing newline
sub generate_nmake_2 {
  # Spot the special case
  local $Text::Wrap::columns = 76;
  my $line = wrap ("\t    ", "\t    ",
		   join " ", sort keys %Copies, keys %Generated,
				  map {"perl$_.pod"} keys %Readmes);
  $line =~ s/$/ \\/mg;
  $line;
}

sub generate_pod_mak {
  my $variable = shift;
  my @@lines;
  my $line = join "\\\n", "\U$variable = ",
    map {"\t$_.$variable\t"} sort keys %Pods;
  # Special case
  $line =~ s/.*perltoc.html.*\n//m;
  $line;
}

sub verify_contiguous {
  my ($name, $content, $what) = @@_;
  my $sections = () = $content =~ m/\0+/g;
  croak("$0: $name contains no $what") if $sections < 1;
  croak("$0: $name contains discontiguous $what") if $sections > 1;
}

sub do_manifest {
  my $name = shift;
  my @@manifest =
    grep {! m!^pod/[^.]+\.pod.*\n!}
      grep {! m!^README\.(\S+)! || $Ignore{$1}} @@_;
  # Dictionary order - fold and handle non-word chars as nothing
  map  { $_->[0] }
  sort { $a->[1] cmp $b->[1] || $a->[0] cmp $b->[0] }
  map  { my $f = lc $_; $f =~ s/[^a-z0-9\s]//g; [ $_, $f ] }
    @@manifest,
      &generate_manifest_pod(),
	&generate_manifest_readme();
}

sub do_nmake {
  my $name = shift;
  my $makefile = join '', @@_;
  die "$0: $name contains NUL bytes" if $makefile =~ /\0/;
  $makefile =~ s/^\tcopy \.\.\\README.*\n/\0/gm;
  verify_contiguous($name, $makefile, 'README copies');
  # Now remove the other copies that follow
  1 while $makefile =~ s/\0\tcopy .*\n/\0/gm;
  $makefile =~ s/\0+/join ("", &generate_nmake_1)/se;

  $makefile =~ s{(del /f [^\n]+podchecker[^\n]+).*?(pod2html)}
    {"$1\n" . &generate_nmake_2."\n\t    $2"}se;
  $makefile;
}

# shut up used only once warning
*do_dmake = *do_dmake = \&do_nmake;

sub do_perlpod {
  my $name = shift;
  my $pod = join '', @@_;

  unless ($pod =~ s{(For\ ease\ of\ access,\ .*\n)
		    (?:\s+[a-z]{4,}.*\n	#   fooo
		    |=head.*\n		# =head foo
		    |\s*\n		# blank line
		   )+
		  }
	  {$1 . join "", &generate_perlpod}mxe) {
    die "$0: Failed to insert amendments in do_perlpod";
  }
  $pod;
}

sub do_podmak {
  my $name = shift;
  my $body = join '', @@_;
  foreach my $variable (qw(pod man html tex)) {
    die "$0: could not find $variable in $name"
      unless $body =~ s{\n\U$variable\E = (?:[^\n]*\\\n)*[^\n]*}
	{"\n" . generate_pod_mak ($variable)}se;
  }
  $body;
}

sub do_vms {
  my $name = shift;
  my $makefile = join '', @@_;
  die "$0: $name contains NUL bytes" if $makefile =~ /\0/;
  $makefile =~ s/\npod\d* =[^\n]*/\0/gs;
  verify_contiguous($name, $makefile, 'pod assignments');
  $makefile =~ s/\0+/join "\n", '', &generate_descrip_mms_1/se;

  die "$0: $name contains NUL bytes" if $makefile =~ /\0/;

# Looking for rules like this
# [.lib.pods]perl.pod : [.pod]perl.pod
#	@@ If F$Search("[.lib]pods.dir").eqs."" Then Create/Directory [.lib.pods]
#	Copy/NoConfirm/Log $(MMS$SOURCE) [.lib.pods]

  $makefile =~ s/\n\Q[.lib.pods]\Eperl[^\n\.]*\.pod[^\n]+\n
		 [^\n]+\n	# Another line
		 [^\n]+\Q[.lib.pods]\E\n		# ends [.lib.pods]
		    /\0/gsx;
  verify_contiguous($name, $makefile, 'copy rules');
  $makefile =~ s/\0+/join "\n", '', &generate_descrip_mms_2/se;

# Looking for rules like this:
#	- If F$Search("[.pod]perldelta.pod").nes."" Then Delete/NoConfirm/Log [.pod]perldelta.pod;*
  $makefile =~ s!(?:\t- If F\$Search\("\[\.pod\]perl[a-z]+\Q.pod").nes."" Then Delete/NoConfirm/Log [.pod]perl\E[a-z]+\.pod;\*\n)+!\0!sg;
  verify_contiguous($name, $makefile, 'delete rules');
  $makefile =~ s/\0+/join "\n", &generate_descrip_mms_3, ''/se;

  $makefile;
}

sub do_unix {
  my $name = shift;
  my $makefile_SH = join '', @@_;
  die "$0: $name contains NUL bytes" if $makefile_SH =~ /\0/;

  $makefile_SH =~ s{^(perltoc_pod_prereqs = extra.pods).*}
		   {join ' ', $1, map "pod/$_",
			sort keys %Copies, grep {!/perltoc/} keys %Generated
		    }mge;

# pod/perldelta.pod: pod/perl511delta.pod
# 	cd pod && $(LNS) perl511delta.pod perldelta.pod

  $makefile_SH =~ s!(
pod/perl[a-z0-9_]+\.pod: pod/perl[a-z0-9_]+\.pod
	\$\(LNS\) perl[a-z0-9_]+\.pod pod/perl[a-z0-9_]+\.pod
)+!\0!gm;

  verify_contiguous($name, $makefile_SH, 'copy rules');

  my @@copy_rules = map "
pod/$_: pod/$Copies{$_}
	\$(LNS) $Copies{$_} pod/$_
", keys %Copies;

  $makefile_SH =~ s/\0+/join '', @@copy_rules/se;
  $makefile_SH;

}

# Do stuff

my $built;
while (my ($target, $name) = each %Targets) {
  print "Working on target $target\n" if $Verbose;
  next unless $Build{$target};
  $built++;
  if ($target eq "toc") {
    print "Now processing $name\n" if $Verbose;
    &output_perltoc;
    print "Finished\n" if $Verbose;
    next;
  }
  print "Now processing $name\n" if $Verbose;
  open THING, $name or die "Can't open $name: $!";
  binmode THING;
  my @@orig = <THING>;
  my $orig = join '', @@orig;
  close THING;
  my @@new = do {
    no strict 'refs';
    &{"do_$target"}($target, @@orig);
  };
  my $new = join '', @@new;
  if ($new eq $orig) {
    print "Was not modified\n" if $Verbose;
    next;
  }
  rename $name, "$name.old" or die "$0: Can't rename $name to $name.old: $!";
  open THING, ">$name" or die "$0: Can't open $name for writing: $!";
  binmode THING;
  print THING $new or die "$0: print to $name failed: $!";
  close THING or die "$0: close $name failed: $!";
}

warn "$0: was not instructed to build anything\n" unless $built;
@


1.12
log
@Undo keywork expansion by escaping the dollar signs as octal
@
text
@d212 1
a212 1
  my @@BuildTargets = grep {defined} @@Targets{keys %Build};
d740 1
d751 1
d766 1
d768 1
a768 1
  close THING or die die "$0: close $name failed: $!";
@


1.11
log
@Merge in perl 5.10.1
@
text
@d401 1
a401 1
	    s/ \(\$Revision: \d+ \$\)//g;
@


1.10
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d4 1
a4 1
use vars qw($masterpodfile %Build %Targets $Verbose $Up %Ignore
d6 1
a6 1
	    %Copies);
d13 1
d18 1
a18 1
$masterpodfile = File::Spec->catdir($Up, "pod.lst");
d22 1
d32 4
a35 4
     vms => File::Spec->catdir($Up, "vms", "descrip_mms.template"),
     nmake => File::Spec->catdir($Up, "win32", "Makefile"),
     dmake => File::Spec->catdir($Up, "win32", "makefile.mk"),
     podmak => File::Spec->catdir($Up, "win32", "pod.mak"),
d37 1
a37 1
     unix => File::Spec->catdir($Up, "Makefile.SH"),
d50 1
d121 1
d145 1
a145 2
    # with sources being in the same directory. Fix this and do perlvms.pod
    # with this?
d208 1
a208 1
      if !$manipods{$i} && !$manireadmes{$i} && !$Copies{$i};
d212 4
d218 1
a218 1
      unless $disk_pods{$i};
d223 2
d228 1
a228 1
      unless $disk_pods{$i};
d232 1
a232 1
# Find all the mdoules
d260 1
d264 2
a265 1
	warn "$0: $file: cannot find =head1 NAME\n";
d380 1
d391 2
d539 1
a539 1
    grep {!$Copies{"$_.pod"}} sort keys %Pods;
d542 3
a544 1
  generate_manifest map {["README.$_", $Readmes{$_}]} sort keys %Readmes;
d568 4
a571 4
  map {sprintf <<'SNIP', $_, $_ eq 'perlvms' ? 'vms' : 'pod', $_}
[.lib.pods]%s.pod : [.%s]%s.pod
	@@ If F$Search("[.lib]pods.dir").eqs."" Then Create/Directory [.lib.pods]
	Copy/NoConfirm/Log $(MMS$SOURCE) [.lib.pods]
d576 5
d593 2
a594 2
		   join " ", sort keys %Copies,
				  map {"perl$_.pod"} "vms", keys %Readmes);
d609 7
d635 1
a635 3
  my $sections = () = $makefile =~ m/\0+/g;
  die "$0: $name contains no README copies" if $sections < 1;
  die "$0: $name contains discontiguous README copies" if $sections > 1;
d640 1
a640 1
  $makefile =~ s{(del /f [^\n]+checkpods[^\n]+).*?(pod2html)}
d680 1
a680 4
  my $sections = () = $makefile =~ m/\0+/g;
  die "$0: $name contains no pod assignments" if $sections < 1;
  die "$0: $name contains $sections discontigous pod assignments"
    if $sections > 1;
d694 1
a694 4
  $sections = () = $makefile =~ m/\0+/g;
  die "$0: $name contains no copy rules" if $sections < 1;
  die "$0: $name contains $sections discontigous copy rules"
    if $sections > 1;
d696 7
d711 19
a729 10
  $makefile_SH =~ s/\n\s+-\@@test -f \S+ && cd pod && \$\(LNS\) \S+ \S+ && cd \.\. && echo "\S+" >> extra.pods \# See buildtoc\n/\0/gm;

  my $sections = () = $makefile_SH =~ m/\0+/g;

  die "$0: $name contains no copy rules" if $sections < 1;
  die "$0: $name contains $sections discontigous copy rules"
    if $sections > 1;

  my @@copy_rules = map "\t-\@@test -f pod/$Copies{$_} && cd pod && \$(LNS) $Copies{$_} $_ && cd .. && echo \"pod/$_\" >> extra.pods # See buildtoc",
    keys %Copies;
d731 1
a731 1
  $makefile_SH =~ s/\0+/join "\n", '', @@copy_rules, ''/se;
@


1.9
log
@merge in perl 5.8.8
@
text
@d36 1
a72 1
     Y2K => 1,
d277 1
a277 1
# OK. Now a lot of ancillay function definitions follow
d386 2
d633 1
a633 1
    die "$0: Failed to insert ammendments in do_perlpod";
@


1.8
log
@sync in-tree perl with 5.8.6
@
text
@d544 1
a544 1
    split /\n/, wrap('', '', join " ", map "[.lib.pod]$_.pod",
d551 3
a553 3
[.lib.pod]%s.pod : [.%s]%s.pod
	@@ If F$Search("[.lib]pod.dir").eqs."" Then Create/Directory [.lib.pod]
	Copy/NoConfirm/Log $(MMS$SOURCE) [.lib.pod]
d661 3
a663 3
# [.lib.pod]perl.pod : [.pod]perl.pod
#	@@ If F$Search("[.lib]pod.dir").eqs."" Then Create/Directory [.lib.pod]
#	Copy/NoConfirm/Log $(MMS$SOURCE) [.lib.pod]
d665 1
a665 1
  $makefile =~ s/\n\Q[.lib.pod]\Eperl[^\n\.]*\.pod[^\n]+\n
d667 1
a667 1
		 [^\n]+\Q[.lib.pod]\E\n		# ends [.lib.pod]
@


1.7
log
@merge local changes into perl-5.8.3
@
text
@d35 1
d675 21
@


1.6
log
@Add back these dead files for 5.8.2
@
text
@d5 2
a6 1
	    @@Master %Readmes %Pods %Aux %Readmepods %Pragmata %Modules);
d84 2
d90 1
a90 1
  if (/^(\S+)\s(.*)/ && $1 =~ tr/A-Z//) {
d93 1
d95 2
a96 3
    $flags{toc_omit} = 1 if $flags =~ tr/O//d;
    $flags{include} = 1 if $flags =~ tr/I//d;
    $flags{aux} = 1 if $flags =~ tr/A//d;
d106 1
a106 1
    $flags{toc_omit} = 1 if $flags =~ tr/o//d;
d108 10
d136 13
d159 1
d170 4
d204 1
a204 1
      if !$manipods{$i} && !$manireadmes{$i};
d206 1
a206 1
	unless $perlpods{$i};
d293 1
a293 1
  $/ = '';
d487 1
d521 2
a522 1
  generate_manifest map {["pod/$_.pod", $Pods{$_}]} sort keys %Pods;
d558 4
a561 2
  map {sprintf "\tcopy ..\\README.%-8s .\\perl$_.pod\n", $_}
    sort keys %Readmes;
d569 2
a570 1
		   join " ", sort map {"perl$_.pod"} "vms", keys %Readmes);
d607 3
a609 1
  $makefile =~ s/\0+/join "", &generate_nmake_1/se;
d611 1
a611 1
  $makefile =~ s{(cd \$\(PODDIR\) && del /f [^\n]+).*?(pod2html)}
d638 1
a638 1
  foreach my $variable qw(pod man html tex) {
d683 1
d685 1
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d1 6
d8 2
a9 1
use Cwd;
d11 1
d13 1
a13 1
sub output ($);
d15 2
a16 12
@@pods = qw(
	   perl perlfaq perlfaq1 perlfaq2 perlfaq3 perlfaq4 perlfaq5
	   perlfaq6 perlfaq7 perlfaq8 perlfaq9 perldelta perldata
	   perlsyn perlop perlre perlrun perlfunc perlvar perlsub
	   perlmod perlmodlib perlmodinstall perlfork perlform perllocale 
	   perlref perlreftut perldsc
	   perllol perlboot perltoot perltootc perlobj perltie perlbot perlipc
	   perldbmfilter perldebug perlnumber perldebguts
	   perldiag perlsec perltrap perlport perlstyle perlpod perlbook
	   perlembed perlapio perlxs perlxstut perlguts perlcall perlcompile
	   perlapi perlintern perlhist
	  );
d18 48
a65 1
for (@@pods) { s/$/.pod/ }
d67 7
a73 2
$/ = '';
@@ARGV = @@pods;
d75 3
a77 1
($_= <<EOPOD2B) =~ s/^\t//gm && output($_);
d79 1
a79 1
	=head1 NAME
d81 1
a81 1
	perltoc - perl documentation table of contents
d83 2
a84 1
	=head1 DESCRIPTION
d86 37
a122 3
	This page provides a brief table of contents for the rest of the Perl
	documentation set.  It is meant to be scanned quickly or grepped
	through to locate the proper section you're looking for.
d124 1
a124 1
	=head1 BASIC DOCUMENTATION
d126 64
a189 2
EOPOD2B
#' make emacs happy
d191 4
a194 1
podset(@@pods);
d196 1
a196 3
find \&getpods => qw(../lib ../ext);

sub getpods {
d198 23
a220 20
	# Skip .pm files that have corresponding .pod files, and Functions.pm.
	return if /(.*)\.pm$/ && -f "$1.pod";
	my $file = $File::Find::name;
	return if $file eq '../lib/Pod/Functions.pm'; # Used only by pod itself

	die "tut $name" if $file =~ /TUT/;
	unless (open (F, "< $_\0")) {
	    warn "bogus <$file>: $!";
	    system "ls", "-l", $file;
	}
	else {
	    my $line;
	    while ($line = <F>) {
		if ($line =~ /^=head1\s+NAME\b/) {
		    push @@modpods, $file;
		    #warn "GOOD $file\n";
		    return;
		}
	    }
	    warn "EVIL $file\n";
d222 2
d225 1
a225 1
}
d227 1
a227 1
die "no pods" unless @@modpods;
d229 2
a230 1
for (@@modpods) {
d232 1
a232 1
    $name = path2modname($_);
d234 1
a234 1
	push @@pragmata, $_;
d236 5
a240 6
	if ($done{$name}++) {
	    # warn "already did $_\n";
	    next;
	}
	push @@modules, $_;
	push @@modname, $name;
d242 1
d245 2
a246 1
($_= <<EOPOD2B) =~ s/^\t//gm && output($_);
d248 25
d274 1
d276 5
a280 1
	=head1 PRAGMA DOCUMENTATION
d283 4
a287 1
podset(sort @@pragmata);
d289 1
a289 1
($_= <<EOPOD2B) =~ s/^\t//gm && output($_);
d293 1
a293 1
	=head1 MODULE DOCUMENTATION
d297 1
a297 1
podset( @@modules[ sort { $modname[$a] cmp $modname[$b] } 0 .. $#modules ] );
d299 1
a299 1
($_= <<EOPOD2B) =~ s/^\t//gm;
a301 1
	=head1 AUXILIARY DOCUMENTATION
d303 1
a303 2
	Here should be listed all the extra programs' documentation, but they
	don't all have manual pages yet:
d305 1
a305 1
	=over
d307 1
a307 1
	=item a2p
d309 1
a309 1
	=item s2p
a310 1
	=item find2perl
d312 1
a312 1
	=item h2ph
d314 2
a315 1
	=item c2ph
d317 1
a317 1
	=item h2xs
d319 1
a319 1
	=item xsubpp
d321 2
a322 3
	=item pod2man

	=item wrapsuid
d333 9
a341 3
output $_;
output "\n";                    # flush $LINE
exit;
d345 1
d348 1
d365 1
a365 1
	    output "=over\n\n" unless $inhead1;
d371 1
a371 1
	    output "=over\n\n" unless $inhead2;
d375 1
a375 1
	if (s/^=item ([^=].*)\n/$1/) {
d379 1
d383 1
a383 1
	    ##print "=over\n\n" unless $initem;
a396 9
sub path2modname {
    local $_ = shift;
    s/\.p(m|od)$//;
    s-.*?/(lib|ext)/--;
    s-/-::-g;
    s/(\w+)::\1/$1/;
    return $_;
}

d425 2
a426 2
my $NEWLINE;	# how many newlines have we seen recently
my $LINE;	# what remains to be printed
d432 1
a432 1
		print wrap('', '', $LINE);
d435 2
a436 2
	    if ($NEWLINE < 2) {
		print;
d446 223
@


1.4
log
@perl-5.6.0 + local changes
@
text
@@


1.3
log
@perl5.005_03 (stock)
@
text
@d9 6
a14 4
	   perlfaq6 perlfaq7 perlfaq8 perlfaq9 perldelta perldata perlopentut
	   perlsyn perlop perlre perlreftut perlrun perlfunc perlvar perlsub
	   perlmod perlmodlib perlmodinstall perlform perllocale perlref perldsc
	   perllol perltoot perlobj perltie perlthrtut perlbot perlipc perldebug
d16 2
a17 2
	   perlembed perlapio perlxs perlxstut perlguts perlcall
	   perlhist
d117 2
d137 1
d156 1
a156 2
	    unitem();
	    unhead2();
d169 3
a171 1
	    unitem(); unhead2();
a178 1

d194 4
d210 8
d219 1
a223 1
    $initem  = 0;
@


1.2
log
@perl 5.004_04
@
text
@d9 5
a13 5
	   perlfaq6 perlfaq7 perlfaq8 perlfaq9 perldelta perldata
	   perlsyn perlop perlre perlrun perlfunc perlvar perlsub
	   perlmod perlmodlib perlform perllocale perlref perldsc
	   perllol perltoot perlobj perltie perlbot perlipc perldebug
	   perldiag perlsec perltrap perlstyle perlpod perlbook
d15 1
d175 1
a175 1
	if (s/^=item (.*)\n/$1/) {
@


1.1
log
@Initial revision
@
text
@d3 1
d5 13
a17 8
@@pods = qw{
	    perl perldata perlsyn perlop perlre perlrun perlfunc perlvar
	    perlsub perlmod perlref perldsc perllol perlobj perltie
	    perlbot perldebug perldiag perlform perlipc perlsec perltrap
	    perlstyle perlxs perlxstut perlguts perlcall perlembed perlpod
	    perlbook 
	};
for (@@pods) { s/$/.pod/ } 
d22 1
a22 1
($_= <<EOPOD2B) =~ s/^\t//gm && print;
d30 2
a31 2
	This page provides a brief table of contents for the rest of the Perl 
	documentation set.  It is meant to be be quickly scanned or grepped 
d37 1
d42 1
d44 1
a44 2
    if (/\.p(od|m)$/) { 
	my $tmp;
d46 3
a48 2
	return if (($tmp = $_) =~ s/\.pm$/.pod/ && -f $tmp);
	return if ($_ eq '../lib/Pod/Functions.pm');####Used only by pod itself
a49 1
	my $file = $File::Find::name;
d54 2
a55 1
	}  else { 
d62 2
a63 2
		} 
	    } 
d80 1
a80 1
	} 
d83 4
a86 2
    } 
} 
a87 2
($_= <<EOPOD2B) =~ s/^\t//gm && print;
 
d96 2
a97 2
($_= <<EOPOD2B) =~ s/^\t//gm && print;
 
d107 1
a107 1
 
d111 2
a112 2
	Here should be listed all the extra program's docs, but they
	don't all have man pages yet:
d119 1
a119 1
	
d121 1
a121 1
	
d128 1
a128 1
	=item pod2man 
d135 1
a135 1
	Larry Wall E<lt>F<lwall\@@sems.com>E<gt>, with the help of oodles 
d140 2
a141 2
print;

d150 3
a152 10
	    sub path2modname {
		local $_ = shift;
		s/\.p(m|od)$//;
		s-.*?/(lib|ext)/--;
		s-/-::-g;
		s/(\w+)::\1/$1/;
		return $_;
	    }
	    unitem(); unhead2();
	    print "\n \n\n=head2 ";
d155 2
a156 1
		print;
d159 2
a160 2
		print;
	    } 
d165 2
a166 2
	    print; nl(); next;
	} 
d169 1
a169 1
	    print "=over\n\n" unless $inhead2;
d171 1
a171 1
	    print; nl(); next;
d173 1
a173 1
	} 
d180 1
a180 1
	    next if $pod eq 'perlmod' && /^ftp:/;
d182 1
a182 1
	    print ", " if $initem;
d185 5
a189 3
	    print; next;
	} 
    } 
d191 8
a198 1
} 
d202 5
a206 5
	print "\n\n=back\n\n";
    } 
    $inhead2 = 0; 
    $initem = 0;
} 
d210 1
a210 1
	print "\n\n";
d212 1
a212 1
    } 
d214 1
a214 1
} 
d217 24
a240 2
    print "\n";
} 
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@a2 1
use Text::Wrap;
d4 8
a11 14
sub output ($);

@@pods = qw(
	   perl perlfaq perlfaq1 perlfaq2 perlfaq3 perlfaq4 perlfaq5
	   perlfaq6 perlfaq7 perlfaq8 perlfaq9 perldelta perldata perlopentut
	   perlsyn perlop perlre perlreftut perlrun perlfunc perlvar perlsub
	   perlmod perlmodlib perlmodinstall perlform perllocale perlref perldsc
	   perllol perltoot perlobj perltie perlthrtut perlbot perlipc perldebug
	   perldiag perlsec perltrap perlport perlstyle perlpod perlbook
	   perlembed perlapio perlxs perlxstut perlguts perlcall
	   perlhist
	  );

for (@@pods) { s/$/.pod/ }
d16 1
a16 1
($_= <<EOPOD2B) =~ s/^\t//gm && output($_);
d24 2
a25 2
	This page provides a brief table of contents for the rest of the Perl
	documentation set.  It is meant to be scanned quickly or grepped
a30 1
#' make emacs happy
a34 1

d36 2
a37 1
    if (/\.p(od|m)$/) {
d39 3
a41 1
	return if /(.*)\.pm$/ && -f "$1.pod";
a42 2
	return if $file eq '../lib/Pod/Functions.pm'; # Used only by pod itself

d47 1
a47 2
	}
	else {
d54 2
a55 2
		}
	    }
d72 1
a72 1
	}
d75 2
a76 4
    }
}

($_= <<EOPOD2B) =~ s/^\t//gm && output($_);
d78 2
d88 2
a89 2
($_= <<EOPOD2B) =~ s/^\t//gm && output($_);

d99 1
a99 1

d103 2
a104 2
	Here should be listed all the extra programs' documentation, but they
	don't all have manual pages yet:
d111 1
a111 1

d113 1
a113 1

d120 1
a120 1
	=item pod2man
d127 1
a127 1
	Larry Wall <F<larry\@@wall.org>>, with the help of oodles
d132 2
a133 2
output $_;
output "\n";                    # flush $LINE
d142 10
a151 3
	    unitem();
	    unhead2();
	    output "\n \n\n=head2 ";
d154 1
a154 2
		s/$pod\.pm/$pod/;       # '.pm' in NAME !?
		output $_;
d157 2
a158 2
		output $_;
	    }
d163 2
a164 2
	    output $_; nl(); next;
	}
d167 1
a167 1
	    output "=over\n\n" unless $inhead2;
d169 1
a169 1
	    output $_; nl(); next;
d171 2
a172 2
	}
	if (s/^=item ([^=].*)\n/$1/) {
d178 1
a178 1
	    next if $pod eq 'perlmodlib' && /^ftp:/;
d180 1
a180 1
	    output ", " if $initem;
d183 3
a185 5
	    s/^-X\b/-I<X>/;
	    output $_; next;
	}
    }
}
d187 1
a187 8
sub path2modname {
    local $_ = shift;
    s/\.p(m|od)$//;
    s-.*?/(lib|ext)/--;
    s-/-::-g;
    s/(\w+)::\1/$1/;
    return $_;
}
d191 5
a195 5
	output "\n\n=back\n\n";
    }
    $inhead2 = 0;
    $initem  = 0;
}
d199 1
a199 1
	output "\n\n";
d201 1
a201 1
    }
d203 1
a203 1
}
d206 2
a207 24
    output "\n";
}

my $NEWLINE;	# how many newlines have we seen recently
my $LINE;	# what remains to be printed

sub output ($) {
    for (split /(\n)/, shift) {
	if ($_ eq "\n") {
	    if ($LINE) {
		print wrap('', '', $LINE);
		$LINE = '';
	    }
	    if ($NEWLINE < 2) {
		print;
		$NEWLINE++;
	    }
	}
	elsif (/\S/ && length) {
	    $LINE .= $_;
	    $NEWLINE = 0;
	}
    }
}
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d9 4
a12 6
	   perlfaq6 perlfaq7 perlfaq8 perlfaq9 perldelta perldata
	   perlsyn perlop perlre perlrun perlfunc perlvar perlsub
	   perlmod perlmodlib perlmodinstall perlfork perlform perllocale 
	   perlref perlreftut perldsc
	   perllol perlboot perltoot perltootc perlobj perltie perlbot perlipc
	   perldbmfilter perldebug perlnumber perldebguts
d14 2
a15 2
	   perlembed perlapio perlxs perlxstut perlguts perlcall perlcompile
	   perlapi perlintern perlhist
a114 2
	=over

a132 1
	=back
d151 2
a152 1
	    unhead1();
d165 1
a165 3
	    unhead2();
	    output "=over\n\n" unless $inhead1;
	    $inhead1 = 1;
d173 1
a188 4
	if (s/^=cut\s*\n//) {
	    unhead1();
	    next;
	}
a200 8
sub unhead1 {
    unhead2();
    if ($inhead1) {
	output "\n\n=back\n\n";
    }
    $inhead1 = 0;
}

a201 1
    unitem();
d206 1
@


1.1.1.4
log
@perl 5.8.2 from CPAN
@
text
@a0 6
#!/usr/bin/perl -w

use strict;
use vars qw($masterpodfile %Build %Targets $Verbose $Up %Ignore
	    @@Master %Readmes %Pods %Aux %Readmepods %Pragmata %Modules);
use File::Spec;
d2 1
a2 2
use FindBin;
use Text::Tabs;
a3 1
use Getopt::Long;
d5 1
a5 1
no locale;
d7 12
a18 2
$Up = File::Spec->updir;
$masterpodfile = File::Spec->catdir($Up, "pod.lst");
d20 1
a20 48
# Generate any/all of these files
# --verbose gives slightly more output
# --build-all tries to build everything
# --build-foo updates foo as follows
# --showfiles shows the files to be changed

%Targets
  = (
     toc => "perltoc.pod",
     manifest => File::Spec->catdir($Up, "MANIFEST"),
     perlpod => "perl.pod",
     vms => File::Spec->catdir($Up, "vms", "descrip_mms.template"),
     nmake => File::Spec->catdir($Up, "win32", "Makefile"),
     dmake => File::Spec->catdir($Up, "win32", "makefile.mk"),
     podmak => File::Spec->catdir($Up, "win32", "pod.mak"),
     # plan9 =>  File::Spec->catdir($Up, "plan9", "mkfile"),
    );

{
  my @@files = keys %Targets;
  my $filesopts = join(" | ", map { "--build-$_" } "all", sort @@files);
  my $showfiles;
  die <<__USAGE__
$0: Usage: $0 [--verbose] [--showfiles] $filesopts
__USAGE__
  unless @@ARGV
	&& GetOptions (verbose => \$Verbose,
		       showfiles => \$showfiles,
		       map {+"build-$_", \$Build{$_}} @@files, 'all');
  # Set them all to true
  @@Build{@@files} = @@files if ($Build{all});
  if ($showfiles) {
      print
	  join(" ",
	       sort { lc $a cmp lc $b }
	       map {
		   my ($v, $d, $f) = File::Spec->splitpath($_);
		   my @@d;
		   @@d = defined $d ? File::Spec->splitdir($d) : ();
		   shift @@d if @@d;
		   File::Spec->catfile(@@d ?
				       (@@d == 1 && $d[0] eq '' ? () : @@d)
				       : "pod", $f);
	       } @@Targets{grep { $_ ne 'all' && $Build{$_} } keys %Build}),
          "\n";
      exit(0);
  }
}
d22 2
a23 7
# Don't copy these top level READMEs
%Ignore
  = (
     Y2K => 1,
     micro => 1,
#     vms => 1,
     );
d25 1
a25 3
if ($Verbose) {
  print "I'm building $_\n" foreach grep {$Build{$_}} keys %Build;
}
d27 1
a27 1
chdir $FindBin::Bin or die "$0: Can't chdir $FindBin::Bin: $!";
d29 1
a29 1
open MASTER, $masterpodfile or die "$0: Can't open $masterpodfile: $!";
d31 1
a31 2
foreach (<MASTER>) {
  next if /^\#/;
d33 3
a35 37
  # At least one upper case letter somewhere in the first group
  if (/^(\S+)\s(.*)/ && $1 =~ tr/A-Z//) {
    # it's a heading
    my $flags = $1;
    my %flags = (header => 1);
    $flags{toc_omit} = 1 if $flags =~ tr/O//d;
    $flags{include} = 1 if $flags =~ tr/I//d;
    $flags{aux} = 1 if $flags =~ tr/A//d;
    die "$0: Unknown flag found in heading line: $_" if length $flags;
    push @@Master, [\%flags, $2];

  } elsif (/^(\S*)\s+(\S+)\s+(.*)/) {
    # it's a section
    my ($flags, $filename, $desc) = ($1, $2, $3);

    my %flags = (indent => 0);
    $flags{indent} = $1 if $flags =~ s/(\d+)//;
    $flags{toc_omit} = 1 if $flags =~ tr/o//d;
    $flags{aux} = 1 if $flags =~ tr/a//d;
    if ($flags =~ tr/r//d) {
      my $readme = $filename;
      $readme =~ s/^perl//;
      $Readmepods{$filename} = $Readmes{$readme} = $desc;
      $flags{readme} = 1;
    } elsif ($flags{aux}) {
      $Aux{$filename} = $desc;
    } else {
      $Pods{$filename} = $desc;
    }
    die "$0: Unknown flag found in section line: $_" if length $flags;
    push @@Master, [\%flags, $filename, $desc];
  } elsif (/^$/) {
    push @@Master, undef;
  } else {
    die "$0: Malformed line: $_" if $1 =~ tr/A-Z//;
  }
}
d37 1
a37 1
close MASTER;
d39 4
a42 64
# Sanity cross check
{
  my (%disk_pods, @@disk_pods);
  my (@@manipods, %manipods);
  my (@@manireadmes, %manireadmes);
  my (@@perlpods, %perlpods);
  my (%our_pods);

  # Convert these to a list of filenames.
  foreach (keys %Pods, keys %Readmepods) {
    $our_pods{"$_.pod"}++;
  }

  # None of these filenames will be boolean false
  @@disk_pods = glob("*.pod");
  @@disk_pods{@@disk_pods} = @@disk_pods;

  open(MANI, "../MANIFEST") || die "$0: opening ../MANIFEST failed: $!";
  while (<MANI>) {
    if (m!^pod/([^.]+\.pod)\s+!i) {
      push @@manipods, $1;
    } elsif (m!^README\.(\S+)\s+!i) {
      next if $Ignore{$1};
      push @@manireadmes, "perl$1.pod";
    }
  }
  close(MANI);
  @@manipods{@@manipods} = @@manipods;
  @@manireadmes{@@manireadmes} = @@manireadmes;

  open(PERLPOD, "perl.pod") || die "$0: opening perl.pod failed: $!\n";
  while (<PERLPOD>) {
    if (/^For ease of access, /../^\(If you're intending /) {
      if (/^\s+(perl\S*)\s+\w/) {
	push @@perlpods, "$1.pod";
      }
    }
  }
  close(PERLPOD);
  die "$0: could not find the pod listing of perl.pod\n"
    unless @@perlpods;
  @@perlpods{@@perlpods} = @@perlpods;

  foreach my $i (sort keys %disk_pods) {
    warn "$0: $i exists but is unknown by buildtoc\n"
      unless $our_pods{$i};
    warn "$0: $i exists but is unknown by ../MANIFEST\n"
      if !$manipods{$i} && !$manireadmes{$i};
    warn "$0: $i exists but is unknown by perl.pod\n"
	unless $perlpods{$i};
  }
  foreach my $i (sort keys %our_pods) {
    warn "$0: $i is known by buildtoc but does not exist\n"
      unless $disk_pods{$i};
  }
  foreach my $i (sort keys %manipods) {
    warn "$0: $i is known by ../MANIFEST but does not exist\n"
      unless $disk_pods{$i};
  }
  foreach my $i (sort keys %perlpods) {
    warn "$0: $i is known by perl.pod but does not exist\n"
      unless $disk_pods{$i};
  }
}
d44 1
a44 4
# Find all the mdoules
{
  my @@modpods;
  find \&getpods => qw(../lib ../ext);
d46 1
a46 1
  sub getpods {
d48 20
a67 23
      my $file = $File::Find::name;
      return if $file eq '../lib/Pod/Functions.pm'; # Used only by pod itself
      return if $file =~ m!(?:^|/)t/!;
      return if $file =~ m!lib/Attribute/Handlers/demo/!;
      return if $file =~ m!lib/Net/FTP/.+\.pm!; # Hi, Graham! :-)
      return if $file =~ m!lib/Math/BigInt/t/!;
      return if $file =~ m!/Devel/PPPort/[Hh]arness|lib/Devel/Harness!i;
      return if $file =~ m!XS/(?:APItest|Typemap)!;
      my $pod = $file;
      return if $pod =~ s/pm$/pod/ && -e $pod;
      die "$0: tut $File::Find::name" if $file =~ /TUT/;
      unless (open (F, "< $_\0")) {
	warn "$0: bogus <$file>: $!";
	system "ls", "-l", $file;
      }
      else {
	my $line;
	while ($line = <F>) {
	  if ($line =~ /^=head1\s+NAME\b/) {
	    push @@modpods, $file;
	    #warn "GOOD $file\n";
	    return;
	  }
a68 2
	warn "$0: $file: cannot find =head1 NAME\n";
      }
d70 1
a70 1
  }
d72 1
a72 1
  die "$0: no pods" unless @@modpods;
d74 1
a74 2
  my %done;
  for (@@modpods) {
d76 1
a76 1
    my $name = path2modname($_);
d78 1
a78 1
      $Pragmata{$name} = $_;
d80 6
a85 5
      if ($done{$name}++) {
	# warn "already did $_\n";
	next;
      }
      $Modules{$name} = $_;
a86 1
  }
d89 1
a89 2
# OK. Now a lot of ancillay function definitions follow
# Main program returns at "Do stuff"
a90 8
sub path2modname {
    local $_ = shift;
    s/\.p(m|od)$//;
    s-.*?/(lib|ext)/--;
    s-/-::-g;
    s/(\w+)::\1/$1/;
    return $_;
}
a91 1
sub output ($);
d93 1
a93 2
sub output_perltoc {
  open(OUT, ">perltoc.pod") || die "$0: creating perltoc.pod failed: $!";
d95 1
a95 1
  $/ = '';
d97 1
a97 1
  ($_= <<"EOPOD2B") =~ s/^\t//gm && output($_);
d99 1
a99 3
	# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
	# This file is autogenerated by buildtoc from all the other pods.
	# Edit those files and run buildtoc --build-toc to effect changes.
a100 1
	=head1 NAME
a101 1
	perltoc - perl documentation table of contents
d103 1
a103 7
	=head1 DESCRIPTION

	This page provides a brief table of contents for the rest of the Perl
	documentation set.  It is meant to be scanned quickly or grepped
	through to locate the proper section you're looking for.

	=head1 BASIC DOCUMENTATION
a105 1
#' make emacs happy
d107 1
a107 2
  # All the things in the master list that happen to be pod filenames
  podset(map {"$_->[1].pod"} grep {defined $_ && @@$_ == 3 && !$_->[0]{toc_omit}} @@Master);
d109 1
a110 1
  ($_= <<"EOPOD2B") =~ s/^\t//gm && output($_);
d112 1
d114 2
d117 1
a117 9
	=head1 PRAGMA DOCUMENTATION

EOPOD2B

  podset(sort values %Pragmata);

  ($_= <<"EOPOD2B") =~ s/^\t//gm && output($_);


d119 1
a119 3
	=head1 MODULE DOCUMENTATION

EOPOD2B
d121 1
a121 1
  podset( @@Modules{ sort keys %Modules } );
d123 1
a123 1
  $_= <<"EOPOD2B";
d125 1
d127 1
a127 1
	=head1 AUXILIARY DOCUMENTATION
d129 1
a129 2
	Here should be listed all the extra programs' documentation, but they
	don't all have manual pages yet:
d131 1
a131 1
	=over 4
d133 1
a133 1
EOPOD2B
d135 1
a135 2
  $_ .=  join "\n", map {"\t=item $_\n"} sort keys %Aux;
  $_ .= <<"EOPOD2B" ;
d146 3
a148 9

  s/^\t//gm;
  output $_;
  output "\n";                    # flush $LINE
}

# Below are all the auxiliary routines for generating perltoc.pod

my ($inhead1, $inhead2, $initem);
a151 1
    my $pod;
a153 1
	tr/\015//d;
d170 1
a170 1
	    output "=over 4\n\n" unless $inhead1;
d176 1
a176 1
	    output "=over 4\n\n" unless $inhead2;
d180 1
a180 1
	if (s/^=item ([^=].*)/$1/) {
a183 1
	    s/\n/ /g;
d187 1
a187 1
	    ##print "=over 4\n\n" unless $initem;
d201 9
d238 2
a239 2
my $NEWLINE = 0;	# how many newlines have we seen recently
my $LINE;		# what remains to be printed
d245 1
a245 1
		print OUT wrap('', '', $LINE);
d248 2
a249 2
	    if (($NEWLINE) < 2) {
		print OUT;
a258 223

# End of original buildtoc. From here on are routines to generate new sections
# for and inplace edit other files

sub generate_perlpod {
  my @@output;
  my $maxlength = 0;
  foreach (@@Master) {
    my $flags = $_->[0];
    next if $flags->{aux};

    if (@@$_ == 2) {
      # Heading
      push @@output, "=head2 $_->[1]\n";
    } elsif (@@$_ == 3) {
      # Section
      my $start = " " x (4 + $flags->{indent}) . $_->[1];
      $maxlength = length $start if length ($start) > $maxlength;
      push @@output, [$start, $_->[2]];
    } elsif (@@$_ == 0) {
      # blank line
      push @@output, "\n";
    } else {
      die "$0: Illegal length " . scalar @@$_;
    }
  }
  # want at least 2 spaces padding
  $maxlength += 2;
  $maxlength = ($maxlength + 3) & ~3;
  # sprintf gives $1.....$2 where ... are spaces:
  return unexpand (map {ref $_ ? sprintf "%-${maxlength}s%s\n", @@$_ : $_}
		   @@output);
}


sub generate_manifest {
  # Annyoingly unexpand doesn't consider it good form to replace a single
  # space before a tab with a tab
  # Annoyingly (2) it returns read only values.
  my @@temp = unexpand (map {sprintf "%-32s%s\n", @@$_} @@_);
  map {s/ \t/\t\t/g; $_} @@temp;
}
sub generate_manifest_pod {
  generate_manifest map {["pod/$_.pod", $Pods{$_}]} sort keys %Pods;
}
sub generate_manifest_readme {
  generate_manifest map {["README.$_", $Readmes{$_}]} sort keys %Readmes;
}

sub generate_roffitall {
  (map ({"\t\$maindir/$_.1\t\\"}sort keys %Pods),
   "\t\t\\",
   map ({"\t\$maindir/$_.1\t\\"}sort keys %Aux),
   "\t\t\\",
   map ({"\t\$libdir/$_.3\t\\"}sort keys %Pragmata),
   "\t\t\\",
   map ({"\t\$libdir/$_.3\t\\"}sort keys %Modules),
  )
}

sub generate_descrip_mms_1 {
  local $Text::Wrap::columns = 150;
  my $count = 0;
  my @@lines = map {"pod" . $count++ . " = $_"}
    split /\n/, wrap('', '', join " ", map "[.lib.pod]$_.pod",
		     sort keys %Pods, keys %Readmepods);
  @@lines, "pod = " . join ' ', map {"\$(pod$_)"} 0 .. $count - 1;
}

sub generate_descrip_mms_2 {
  map {sprintf <<'SNIP', $_, $_ eq 'perlvms' ? 'vms' : 'pod', $_}
[.lib.pod]%s.pod : [.%s]%s.pod
	@@ If F$Search("[.lib]pod.dir").eqs."" Then Create/Directory [.lib.pod]
	Copy/NoConfirm/Log $(MMS$SOURCE) [.lib.pod]
SNIP
   sort keys %Pods, keys %Readmepods;
}

sub generate_nmake_1 {
  map {sprintf "\tcopy ..\\README.%-8s .\\perl$_.pod\n", $_}
    sort keys %Readmes;
}

# This doesn't have a trailing newline
sub generate_nmake_2 {
  # Spot the special case
  local $Text::Wrap::columns = 76;
  my $line = wrap ("\t    ", "\t    ",
		   join " ", sort map {"perl$_.pod"} "vms", keys %Readmes);
  $line =~ s/$/ \\/mg;
  $line;
}

sub generate_pod_mak {
  my $variable = shift;
  my @@lines;
  my $line = join "\\\n", "\U$variable = ",
    map {"\t$_.$variable\t"} sort keys %Pods;
  # Special case
  $line =~ s/.*perltoc.html.*\n//m;
  $line;
}

sub do_manifest {
  my $name = shift;
  my @@manifest =
    grep {! m!^pod/[^.]+\.pod.*\n!}
      grep {! m!^README\.(\S+)! || $Ignore{$1}} @@_;
  # Dictionary order - fold and handle non-word chars as nothing
  map  { $_->[0] }
  sort { $a->[1] cmp $b->[1] || $a->[0] cmp $b->[0] }
  map  { my $f = lc $_; $f =~ s/[^a-z0-9\s]//g; [ $_, $f ] }
    @@manifest,
      &generate_manifest_pod(),
	&generate_manifest_readme();
}

sub do_nmake {
  my $name = shift;
  my $makefile = join '', @@_;
  die "$0: $name contains NUL bytes" if $makefile =~ /\0/;
  $makefile =~ s/^\tcopy \.\.\\README.*\n/\0/gm;
  my $sections = () = $makefile =~ m/\0+/g;
  die "$0: $name contains no README copies" if $sections < 1;
  die "$0: $name contains discontiguous README copies" if $sections > 1;
  $makefile =~ s/\0+/join "", &generate_nmake_1/se;

  $makefile =~ s{(cd \$\(PODDIR\) && del /f [^\n]+).*?(pod2html)}
    {"$1\n" . &generate_nmake_2."\n\t    $2"}se;
  $makefile;
}

# shut up used only once warning
*do_dmake = *do_dmake = \&do_nmake;

sub do_perlpod {
  my $name = shift;
  my $pod = join '', @@_;

  unless ($pod =~ s{(For\ ease\ of\ access,\ .*\n)
		    (?:\s+[a-z]{4,}.*\n	#   fooo
		    |=head.*\n		# =head foo
		    |\s*\n		# blank line
		   )+
		  }
	  {$1 . join "", &generate_perlpod}mxe) {
    die "$0: Failed to insert ammendments in do_perlpod";
  }
  $pod;
}

sub do_podmak {
  my $name = shift;
  my $body = join '', @@_;
  foreach my $variable qw(pod man html tex) {
    die "$0: could not find $variable in $name"
      unless $body =~ s{\n\U$variable\E = (?:[^\n]*\\\n)*[^\n]*}
	{"\n" . generate_pod_mak ($variable)}se;
  }
  $body;
}

sub do_vms {
  my $name = shift;
  my $makefile = join '', @@_;
  die "$0: $name contains NUL bytes" if $makefile =~ /\0/;
  $makefile =~ s/\npod\d* =[^\n]*/\0/gs;
  my $sections = () = $makefile =~ m/\0+/g;
  die "$0: $name contains no pod assignments" if $sections < 1;
  die "$0: $name contains $sections discontigous pod assignments"
    if $sections > 1;
  $makefile =~ s/\0+/join "\n", '', &generate_descrip_mms_1/se;

  die "$0: $name contains NUL bytes" if $makefile =~ /\0/;

# Looking for rules like this
# [.lib.pod]perl.pod : [.pod]perl.pod
#	@@ If F$Search("[.lib]pod.dir").eqs."" Then Create/Directory [.lib.pod]
#	Copy/NoConfirm/Log $(MMS$SOURCE) [.lib.pod]

  $makefile =~ s/\n\Q[.lib.pod]\Eperl[^\n\.]*\.pod[^\n]+\n
		 [^\n]+\n	# Another line
		 [^\n]+\Q[.lib.pod]\E\n		# ends [.lib.pod]
		    /\0/gsx;
  $sections = () = $makefile =~ m/\0+/g;
  die "$0: $name contains no copy rules" if $sections < 1;
  die "$0: $name contains $sections discontigous copy rules"
    if $sections > 1;
  $makefile =~ s/\0+/join "\n", '', &generate_descrip_mms_2/se;
  $makefile;
}

# Do stuff

my $built;
while (my ($target, $name) = each %Targets) {
  next unless $Build{$target};
  $built++;
  if ($target eq "toc") {
    &output_perltoc;
    next;
  }
  print "Now processing $name\n" if $Verbose;
  open THING, $name or die "Can't open $name: $!";
  my @@orig = <THING>;
  my $orig = join '', @@orig;
  close THING;
  my @@new = do {
    no strict 'refs';
    &{"do_$target"}($target, @@orig);
  };
  my $new = join '', @@new;
  if ($new eq $orig) {
    print "Was not modified\n" if $Verbose;
    next;
  }
  rename $name, "$name.old" or die "$0: Can't rename $name to $name.old: $!";
  open THING, ">$name" or die "$0: Can't open $name for writing: $!";
  print THING $new or die "$0: print to $name failed: $!";
  close THING or die die "$0: close $name failed: $!";
}

warn "$0: was not instructed to build anything\n" unless $built;
@


1.1.1.5
log
@perl 5.8.3 from CPAN
@
text
@d5 1
a5 2
	    @@Master %Readmes %Pods %Aux %Readmepods %Pragmata %Modules
	    %Copies);
a82 2
my ($delta_source, $delta_target);

d87 1
a87 1
  if (/^(\S+)\s(.*)/ && $1 =~ tr/h//) {
a89 1
    $flags =~ tr/h//d;
d91 3
a93 2
    $flags{toc_omit} = 1 if $flags =~ tr/o//d;
    $flags{aux} = 1 if $flags =~ tr/a//d;
d103 1
a103 1
    $flags{toc_omit} = 1 if $flags =~ tr/o//d; 
a104 10

    if ($flags =~ tr/D//d) {
      $flags{perlpod_omit} = 1;
      $delta_source = "$filename.pod";
    }
    if ($flags =~ tr/d//d) {
      $flags{manifest_omit} = 1;
      $delta_target = "$filename.pod";
    }

a122 13
if (defined $delta_source) {
  if (defined $delta_target) {
    # This way round so that keys can act as a MANIFEST skip list
    # Targets will aways be in the pod directory. Currently we can only cope
    # with sources being in the same directory. Fix this and do perlvms.pod
    # with this?
    $Copies{$delta_target} = $delta_source;
  } else {
    die "$0: delta source defined but not target";
  }
} elsif (defined $delta_target) {
  die "$0: delta target defined but not target";
}
a132 1
  my (%sources);
a142 4
  # Things we copy from won't be in perl.pod
  # Things we copy to won't be in MANIFEST
  @@sources{values %Copies} = ();

d173 1
a173 1
      if !$manipods{$i} && !$manireadmes{$i} && !$Copies{$i};
d175 1
a175 1
	if !$perlpods{$i} && !exists $sources{$i};
d262 1
a262 1
  local $/ = '';
a455 1
    next if $flags->{perlpod_omit};
d489 1
a489 2
  generate_manifest map {["pod/$_.pod", $Pods{$_}]}
    grep {!$Copies{"$_.pod"}} sort keys %Pods;
d525 2
a526 4
  # XXX Fix this with File::Spec
  (map {sprintf "\tcopy ..\\README.%-8s ..\\pod\\perl$_.pod\n", $_}
    sort keys %Readmes),
      (map {"\tcopy ..\\pod\\$Copies{$_} ..\\pod\\$_\n"} sort keys %Copies);
d534 1
a534 2
		   join " ", sort keys %Copies,
				  map {"perl$_.pod"} "vms", keys %Readmes);
d571 1
a571 3
  # Now remove the other copies that follow
  1 while $makefile =~ s/\0\tcopy .*\n/\0/gm;
  $makefile =~ s/\0+/join ("", &generate_nmake_1)/se;
d573 1
a573 1
  $makefile =~ s{(del /f [^\n]+checkpods[^\n]+).*?(pod2html)}
d600 1
a600 1
  foreach my $variable (qw(pod man html tex)) {
a644 1
    print "Now processing $name\n" if $Verbose;
a645 1
    print "Finished\n" if $Verbose;
@


1.1.1.6
log
@perl 5.8.6 from CPAN
@
text
@a34 1
     unix => File::Spec->catdir($Up, "Makefile.SH"),
a673 21
}

sub do_unix {
  my $name = shift;
  my $makefile_SH = join '', @@_;
  die "$0: $name contains NUL bytes" if $makefile_SH =~ /\0/;

  $makefile_SH =~ s/\n\s+-\@@test -f \S+ && cd pod && \$\(LNS\) \S+ \S+ && cd \.\. && echo "\S+" >> extra.pods \# See buildtoc\n/\0/gm;

  my $sections = () = $makefile_SH =~ m/\0+/g;

  die "$0: $name contains no copy rules" if $sections < 1;
  die "$0: $name contains $sections discontigous copy rules"
    if $sections > 1;

  my @@copy_rules = map "\t-\@@test -f pod/$Copies{$_} && cd pod && \$(LNS) $Copies{$_} $_ && cd .. && echo \"pod/$_\" >> extra.pods # See buildtoc",
    keys %Copies;

  $makefile_SH =~ s/\0+/join "\n", '', @@copy_rules, ''/se;
  $makefile_SH;

@


1.1.1.7
log
@perl 5.8.8 import
@
text
@d544 1
a544 1
    split /\n/, wrap('', '', join " ", map "[.lib.pods]$_.pod",
d551 3
a553 3
[.lib.pods]%s.pod : [.%s]%s.pod
	@@ If F$Search("[.lib]pods.dir").eqs."" Then Create/Directory [.lib.pods]
	Copy/NoConfirm/Log $(MMS$SOURCE) [.lib.pods]
d661 3
a663 3
# [.lib.pods]perl.pod : [.pod]perl.pod
#	@@ If F$Search("[.lib]pods.dir").eqs."" Then Create/Directory [.lib.pods]
#	Copy/NoConfirm/Log $(MMS$SOURCE) [.lib.pods]
d665 1
a665 1
  $makefile =~ s/\n\Q[.lib.pods]\Eperl[^\n\.]*\.pod[^\n]+\n
d667 1
a667 1
		 [^\n]+\Q[.lib.pods]\E\n		# ends [.lib.pods]
@


1.1.1.8
log
@import perl 5.10.0 from CPAN
@
text
@a35 1
     # TODO: add roffitall
d72 1
d277 1
a277 1
# OK. Now a lot of ancillary function definitions follow
a385 2
	    # Remove svn keyword expansions from the Perl FAQ
	    s/ \(\$Revision: \d+ \$\)//g;
d631 1
a631 1
    die "$0: Failed to insert amendments in do_perlpod";
@


1.1.1.9
log
@import perl 5.10.1
@
text
@d4 1
a4 1
use vars qw($masterpodfile %Build %Targets $Verbose $Quiet $Up %Ignore
d6 1
a6 1
	    %Copies %Generated);
a12 1
use Carp;
d17 1
a17 1
$masterpodfile = File::Spec->catfile($Up, "pod.lst");
a20 1
# --quiet suppresses routine warnings
d30 4
a33 4
     vms => File::Spec->catfile($Up, "vms", "descrip_mms.template"),
     nmake => File::Spec->catfile($Up, "win32", "Makefile"),
     dmake => File::Spec->catfile($Up, "win32", "makefile.mk"),
     podmak => File::Spec->catfile($Up, "win32", "pod.mak"),
d35 1
a35 1
     unix => File::Spec->catfile($Up, "Makefile.SH"),
a47 1
		       quiet => \$Quiet,
a117 1
    $Generated{"$filename.pod"}++ if $flags =~ tr/g//d;
d141 2
a142 1
    # with sources being in the same directory.
d205 1
a205 1
      if !$manipods{$i} && !$manireadmes{$i} && !$Copies{$i} && !$Generated{$i};
a208 4
  my @@BuildTargets = grep {defined} @@Targets{keys %Build};
  my %BuildFiles;
  @@BuildFiles{@@BuildTargets} = @@BuildTargets;
  
d211 1
a211 1
      unless $disk_pods{$i} or $BuildFiles{$i};
a215 2
    warn "$0: $i is known by ../MANIFEST but is marked as generated\n"
      if $Generated{$i};
d219 1
a219 1
      unless $disk_pods{$i} or $BuildFiles{$i};
d223 1
a223 1
# Find all the modules
a250 1
	    close F;
d254 1
a254 2
	close F;
	warn "$0: $file: cannot find =head1 NAME\n" unless $Quiet;
a368 1
  close OUT;
a378 2
    return unless scalar(@@ARGV);

d525 1
a525 1
    sort grep {!$Copies{"$_.pod"}} grep {!$Generated{"$_.pod"}} keys %Pods;
d528 1
a528 3
  generate_manifest sort {$a->[0] cmp $b->[0]}
    ["README.vms", "Notes about installing the VMS port"],
      map {["README.$_", $Readmes{$_}]} keys %Readmes;
d552 4
a555 4
  map {<<"SNIP"}
[.lib.pods]$_.pod : [.pod]$_.pod
	\@@ If F\$Search("[.lib]pods.dir").eqs."" Then Create/Directory [.lib.pods]
	Copy/NoConfirm/Log \$(MMS\$SOURCE) [.lib.pods]
a559 5
sub generate_descrip_mms_3 {
  map qq{\t- If F\$Search("[.pod]$_").nes."" Then Delete/NoConfirm/Log [.pod]$_;*},
    sort keys %Generated, keys %Copies;
}

d572 2
a573 2
		   join " ", sort keys %Copies, keys %Generated,
				  map {"perl$_.pod"} keys %Readmes);
a587 7
sub verify_contiguous {
  my ($name, $content, $what) = @@_;
  my $sections = () = $content =~ m/\0+/g;
  croak("$0: $name contains no $what") if $sections < 1;
  croak("$0: $name contains discontiguous $what") if $sections > 1;
}

d607 3
a609 1
  verify_contiguous($name, $makefile, 'README copies');
d614 1
a614 1
  $makefile =~ s{(del /f [^\n]+podchecker[^\n]+).*?(pod2html)}
d654 4
a657 1
  verify_contiguous($name, $makefile, 'pod assignments');
d671 4
a674 1
  verify_contiguous($name, $makefile, 'copy rules');
a675 7

# Looking for rules like this:
#	- If F$Search("[.pod]perldelta.pod").nes."" Then Delete/NoConfirm/Log [.pod]perldelta.pod;*
  $makefile =~ s!(?:\t- If F\$Search\("\[\.pod\]perl[a-z]+\Q.pod").nes."" Then Delete/NoConfirm/Log [.pod]perl\E[a-z]+\.pod;\*\n)+!\0!sg;
  verify_contiguous($name, $makefile, 'delete rules');
  $makefile =~ s/\0+/join "\n", &generate_descrip_mms_3, ''/se;

d684 10
a693 19
  $makefile_SH =~ s{^(perltoc_pod_prereqs = extra.pods).*}
		   {join ' ', $1, map "pod/$_",
			sort keys %Copies, grep {!/perltoc/} keys %Generated
		    }mge;

# pod/perldelta.pod: pod/perl511delta.pod
# 	cd pod && $(LNS) perl511delta.pod perldelta.pod

  $makefile_SH =~ s!(
pod/perl[a-z0-9_]+\.pod: pod/perl[a-z0-9_]+\.pod
	\$\(LNS\) perl[a-z0-9_]+\.pod pod/perl[a-z0-9_]+\.pod
)+!\0!gm;

  verify_contiguous($name, $makefile_SH, 'copy rules');

  my @@copy_rules = map "
pod/$_: pod/$Copies{$_}
	\$(LNS) $Copies{$_} pod/$_
", keys %Copies;
d695 1
a695 1
  $makefile_SH =~ s/\0+/join '', @@copy_rules/se;
@


1.1.1.10
log
@Perl 5.12.2 from CPAN
@
text
@d212 1
a212 1
  my @@BuildTargets = grep {defined} @@Targets{grep $_ ne 'all', keys %Build};
a739 1
  print "Working on target $target\n" if $Verbose;
a749 1
  binmode THING;
a763 1
  binmode THING;
d765 1
a765 1
  close THING or die "$0: close $name failed: $!";
@


1.1.1.11
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d4 3
a6 1
use vars qw($Quiet);
d8 1
d10 1
d13 1
d17 213
a229 6
# Assumption is that we're either already being run from the top level (*nix,
# VMS), or have absolute paths in @@INC (Win32, pod/Makefile)
BEGIN {
  my $Top = File::Spec->catdir($FindBin::Bin, File::Spec->updir);
  chdir $Top or die "Can't chdir to $Top: $!";
  require 'Porting/pod_lib.pl';
d232 55
a286 2
die "$0: Usage: $0 [--quiet]\n"
    unless GetOptions (quiet => \$Quiet) && !@@ARGV;
d288 2
a289 1
my $state = get_pod_metadata(0, sub { warn @@_ if @@_ }, 'pod/perltoc.pod');
d291 8
a298 1
my $found = pods_to_install();
d300 1
a300 1
my_die "Can't find any pods!\n" unless %$found;
d302 2
a303 5
# Accumulating everything into a lexical before writing to disk dates from the
# time when this script also provided the functionality of regen/pod_rules.pl
# and this code was in a subroutine do_toc(). In turn, the use of a file scoped
# lexical instead of a parameter or return value is because the code dates back
# further still, and used *only* to create pod/perltoc.pod by printing direct
d305 1
a305 2
my $OUT;
my $roffitall;
d307 1
a307 1
($_= <<"EOPOD2B") =~ s/^\t//gm and $OUT .= $_;
d311 1
a311 1
	# Edit those files and run $0 to effect changes.
d326 11
d338 3
a340 5
# All the things in the master list that happen to be pod filenames
foreach (grep {!$_->[2]{toc_omit}} @@{$state->{master}}) {
    $roffitall .= "    \$mandir/$_->[0].1 \\\n";
    podset($_->[0], $_->[1]);
}
d342 1
a342 2
foreach my $type (qw(PRAGMA MODULE)) {
    ($_= <<"EOPOD2B") =~ s/^\t//gm and $OUT .= $_;
d346 1
a346 1
	=head1 $type DOCUMENTATION
d350 1
a350 5
    foreach my $name (sort keys %{$found->{$type}}) {
        $roffitall .= "    \$libdir/$name.3 \\\n";
        podset($name, $found->{$type}{$name});
    }
}
d352 1
a352 1
$_= <<"EOPOD2B";
d364 2
a365 2
$_ .=  join "\n", map {"\t=item $_\n"} @@{$state->{aux}};
$_ .= <<"EOPOD2B" ;
d377 5
a381 75
s/^\t//gm;
$OUT .= "$_\n";

$OUT =~ s/\n\s+\n/\n\n/gs;
$OUT =~ s/\n{3,}/\n\n/g;

$OUT =~ s/([^\n]+)/wrap('', '', $1)/ge;

write_or_die('pod/perltoc.pod', $OUT);

write_or_die('pod/roffitall', <<'EOH' . $roffitall . <<'EOT');
#!/bin/sh
#
# Usage: roffitall [-nroff|-psroff|-groff]
#
# Authors: Tom Christiansen, Raphael Manfredi

me=roffitall
tmp=.

if test -f ../config.sh; then
	. ../config.sh
fi

mandir=$installman1dir
libdir=$installman3dir

test -d $mandir || mandir=/usr/new/man/man1
test -d $libdir || libdir=/usr/new/man/man3

case "$1" in
-nroff) cmd="nroff -man"; ext='txt';;
-psroff) cmd="psroff -t"; ext='ps';;
-groff) cmd="groff -man"; ext='ps';;
*)
	echo "Usage: roffitall [-nroff|-psroff|-groff]" >&2
	exit 1
	;;
esac

toroff=`
	echo		\
EOH
    | perl -ne 'map { -r && print "$_ " } split'`

    # Bypass internal shell buffer limit -- can't use case
    if perl -e '$a = shift; exit($a =~ m|/|)' $toroff; then
	echo "$me: empty file list -- did you run install?" >&2
	exit 1
    fi

    #psroff -t -man -rC1 -rD1 -rF1 > $tmp/PerlDoc.ps 2>$tmp/PerlTOC.raw
    #nroff -man -rC1 -rD1 -rF1 > $tmp/PerlDoc.txt 2>$tmp/PerlTOC.nr.raw

    # First, create the raw data
    run="$cmd -rC1 -rD1 -rF1 >$tmp/PerlDoc.$ext 2>$tmp/PerlTOC.$ext.raw"
    echo "$me: running $run"
    eval $run $toroff

    #Now create the TOC
    echo "$me: parsing TOC"
    perl rofftoc $tmp/PerlTOC.$ext.raw > $tmp/PerlTOC.tmp.man
    run="$cmd $tmp/PerlTOC.tmp.man >$tmp/PerlTOC.$ext"
    echo "$me: running $run"
    eval $run

    # Finally, recreate the Doc, without the blank page 0
    run="$cmd -rC1 -rD1 >$tmp/PerlDoc.$ext 2>$tmp/PerlTOC.$ext.raw"
    echo "$me: running $run"
    eval $run $toroff
    rm -f $tmp/PerlTOC.tmp.man $tmp/PerlTOC.$ext.raw
    echo "$me: leaving you with $tmp/PerlDoc.$ext and $tmp/PerlTOC.$ext"
EOT

exit(0);
d388 2
a389 1
    my ($pod, $file) = @@_;
d391 1
a391 1
    open my $fh, '<', $file or my_die "Can't open file '$file' for $pod: $!";
d393 1
a393 18
    local *_;
    my $found_pod;
    while (<$fh>) {
        if (/^=head1\s+NAME\b/) {
            ++$found_pod;
            last;
        }
    }

    unless ($found_pod) {
	warn "$0: NOTE: cannot find '=head1 NAME' in:\n  $file\n" unless $Quiet;
        return;
    }

    seek $fh, 0, 0 or my_die "Can't rewind file '$file': $!";
    local $/ = '';

    while(<$fh>) {
d396 1
d398 2
a399 2
	    $OUT .= "\n\n=head2 ";
	    $_ = <$fh>;
d402 1
a402 1
	    if ( /^\s*\Q$pod\E\b/ ) {
d404 1
d407 1
d409 1
d411 1
a411 1
	elsif (s/^=head1 (.*)/=item $1/) {
d413 1
a413 1
	    $OUT .= "=over 4\n\n" unless $inhead1;
d415 1
a415 1
	    $_ .= "\n";
d417 1
a417 1
	elsif (s/^=head2 (.*)/=item $1/) {
d419 1
a419 1
	    $OUT .= "=over 4\n\n" unless $inhead2;
d421 1
a421 1
	    $_ .= "\n";
d423 1
a423 1
	elsif (s/^=item ([^=].*)/$1/) {
d431 2
a432 1
	    $OUT .= ", " if $initem;
d436 1
d438 2
a439 2
	else {
	    unhead1() if /^=cut\s*\n/;
a441 1
	$OUT .= $_;
d448 1
a448 1
	$OUT .= "\n\n=back\n\n";
d456 1
a456 1
	$OUT .= "\n\n=back\n\n";
d463 2
a464 1
	$OUT .= "\n\n";
d469 303
a771 6
# Local variables:
# cperl-indent-level: 4
# indent-tabs-mode: nil
# End:
#
# ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.12
log
@Import perl-5.20.1
@
text
@a43 2
	=encoding UTF-8

@


