head	1.19;
access;
symbols
	OPENBSD_6_2:1.19.0.2
	OPENBSD_6_2_BASE:1.19
	PERL_5_24_2:1.1.1.18
	OPENBSD_6_1:1.19.0.4
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.18.0.8
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.18.0.4
	OPENBSD_5_8_BASE:1.18
	PERL_5_20_2:1.1.1.17
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	PERL_5_20_1:1.1.1.16
	OPENBSD_5_6:1.16.0.4
	OPENBSD_5_6_BASE:1.16
	PERL_5_18_2:1.1.1.15
	PERL:1.1.1
	OPENBSD_5_5:1.15.0.6
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.2
	OPENBSD_5_4_BASE:1.15
	PERL_5_16_3:1.1.1.14
	OPENBSD_5_3:1.14.0.10
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.8
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.6
	OPENBSD_5_0:1.14.0.4
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	PERL_5_12_2:1.1.1.13
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	PERL_5_10_1:1.1.1.12
	OPENBSD_4_6:1.12.0.6
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.2
	OPENBSD_4_5_BASE:1.12
	PERL_5_10_0:1.1.1.11
	OPENBSD_4_4:1.11.0.10
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.8
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.6
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.4
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	PERL_5_8_8:1.1.1.10
	OPENBSD_3_9:1.10.0.6
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.4
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	PERL_5_8_6:1.1.1.9
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	PERL_5_8_5:1.1.1.8
	PERL_5_8_3:1.1.1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.19
date	2017.02.05.00.32.18;	author afresh1;	state Exp;
branches;
next	1.18;
commitid	cxJ08BvJA9Pt2PTM;

1.18
date	2015.04.25.19.14.47;	author afresh1;	state Exp;
branches;
next	1.17;
commitid	XRK22kO4se3v2i2I;

1.17
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.16;
commitid	QP75iYx42Uo7mMxO;

1.16
date	2014.03.24.15.05.32;	author afresh1;	state Exp;
branches;
next	1.15;

1.15
date	2013.03.25.20.40.58;	author sthen;	state Exp;
branches;
next	1.14;

1.14
date	2010.09.24.15.07.03;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2009.10.12.18.24.47;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2008.09.29.17.36.16;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.28.19.23.09;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.15.21.30.35;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.08.09.18.10.15;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.07.21.33.08;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.44;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.32;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.35.52;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.07.23;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.09;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.59.04;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.57;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.57;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.40.38;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.22;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.24.32;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.04;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.20;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.04.07.21.13.32;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.08.09.17.48.07;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2005.01.15.21.17.48;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2006.03.28.18.49.16;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2008.09.29.17.18.51;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2009.10.12.18.10.40;	author millert;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2010.09.24.14.49.09;	author millert;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2013.03.25.20.09.18;	author sthen;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2014.03.24.14.59.07;	author afresh1;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	2014.11.17.20.53.13;	author afresh1;	state Exp;
branches;
next	1.1.1.17;
commitid	B31cAbBIXiCqnL97;

1.1.1.17
date	2015.04.25.19.10.43;	author afresh1;	state Exp;
branches;
next	1.1.1.18;
commitid	Wpcs5S8qILgEZC7F;

1.1.1.18
date	2017.08.14.13.46.19;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.19
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@=head1 NAME

perldiag - various Perl diagnostics

=head1 DESCRIPTION

These messages are classified as follows (listed in increasing order of
desperation):

    (W) A warning (optional).
    (D) A deprecation (enabled by default).
    (S) A severe warning (enabled by default).
    (F) A fatal error (trappable).
    (P) An internal error you should never see (trappable).
    (X) A very fatal error (nontrappable).
    (A) An alien error message (not generated by Perl).

The majority of messages from the first three classifications above
(W, D & S) can be controlled using the C<warnings> pragma.

If a message can be controlled by the C<warnings> pragma, its warning
category is included with the classification letter in the description
below.  E.g. C<(W closed)> means a warning in the C<closed> category.

Optional warnings are enabled by using the C<warnings> pragma or the B<-w>
and B<-W> switches.  Warnings may be captured by setting C<$SIG{__WARN__}>
to a reference to a routine that will be called on each warning instead
of printing it.  See L<perlvar>.

Severe warnings are always enabled, unless they are explicitly disabled
with the C<warnings> pragma or the B<-X> switch.

Trappable errors may be trapped using the eval operator.  See
L<perlfunc/eval>.  In almost all cases, warnings may be selectively
disabled or promoted to fatal errors using the C<warnings> pragma.
See L<warnings>.

The messages are in alphabetical order, without regard to upper or
lower-case.  Some of these messages are generic.  Spots that vary are
denoted with a %s or other printf-style escape.  These escapes are
ignored by the alphabetical order, as are all characters other than
letters.  To look up your message, just ignore anything that is not a
letter.

=over 4

=item accept() on closed socket %s

(W closed) You tried to do an accept on a closed socket.  Did you forget
to check the return value of your socket() call?  See
L<perlfunc/accept>.

=item Aliasing via reference is experimental

(S experimental::refaliasing) This warning is emitted if you use
a reference constructor on the left-hand side of an assignment to
alias one variable to another.  Simply suppress the warning if you
want to use the feature, but know that in doing so you are taking
the risk of using an experimental feature which may change or be
removed in a future Perl version:

    no warnings "experimental::refaliasing";
    use feature "refaliasing";
    \$x = \$y;

=item Allocation too large: %x

(X) You can't allocate more than 64K on an MS-DOS machine.

=item '%c' allowed only after types %s in %s

(F) The modifiers '!', '<' and '>' are allowed in pack() or unpack() only
after certain types.  See L<perlfunc/pack>.

=item alpha->numify() is lossy

(W numeric) An alpha version can not be numified without losing
information.

=item Ambiguous call resolved as CORE::%s(), qualify as such or use &

(W ambiguous) A subroutine you have declared has the same name as a Perl
keyword, and you have used the name without qualification for calling
one or the other.  Perl decided to call the builtin because the
subroutine is not imported.

To force interpretation as a subroutine call, either put an ampersand
before the subroutine name, or qualify the name with its package.
Alternatively, you can import the subroutine (or pretend that it's
imported with the C<use subs> pragma).

To silently interpret it as the Perl operator, use the C<CORE::> prefix
on the operator (e.g. C<CORE::log($x)>) or declare the subroutine
to be an object method (see L<perlsub/"Subroutine Attributes"> or
L<attributes>).

=item Ambiguous range in transliteration operator

(F) You wrote something like C<tr/a-z-0//> which doesn't mean anything at
all.  To include a C<-> character in a transliteration, put it either
first or last.  (In the past, C<tr/a-z-0//> was synonymous with
C<tr/a-y//>, which was probably not what you would have expected.)

=item Ambiguous use of %s resolved as %s

(S ambiguous) You said something that may not be interpreted the way
you thought.  Normally it's pretty easy to disambiguate it by supplying
a missing quote, operator, parenthesis pair or declaration.

=item Ambiguous use of -%s resolved as -&%s()

(S ambiguous) You wrote something like C<-foo>, which might be the
string C<"-foo">, or a call to the function C<foo>, negated.  If you meant
the string, just write C<"-foo">.  If you meant the function call,
write C<-foo()>.

=item Ambiguous use of %c resolved as operator %c

(S ambiguous) C<%>, C<&>, and C<*> are both infix operators (modulus,
bitwise and, and multiplication) I<and> initial special characters
(denoting hashes, subroutines and typeglobs), and you said something
like C<*foo * foo> that might be interpreted as either of them.  We
assumed you meant the infix operator, but please try to make it more
clear -- in the example given, you might write C<*foo * foo()> if you
really meant to multiply a glob by the result of calling a function.

=item Ambiguous use of %c{%s} resolved to %c%s

(W ambiguous) You wrote something like C<@@{foo}>, which might be
asking for the variable C<@@foo>, or it might be calling a function
named foo, and dereferencing it as an array reference.  If you wanted
the variable, you can just write C<@@foo>.  If you wanted to call the
function, write C<@@{foo()}> ... or you could just not have a variable
and a function with the same name, and save yourself a lot of trouble.

=item Ambiguous use of %c{%s[...]} resolved to %c%s[...]

=item Ambiguous use of %c{%s{...}} resolved to %c%s{...}

(W ambiguous) You wrote something like C<${foo[2]}> (where foo represents
the name of a Perl keyword), which might be looking for element number
2 of the array named C<@@foo>, in which case please write C<$foo[2]>, or you
might have meant to pass an anonymous arrayref to the function named
foo, and then do a scalar deref on the value it returns.  If you meant
that, write C<${foo([2])}>.

In regular expressions, the C<${foo[2]}> syntax is sometimes necessary
to disambiguate between array subscripts and character classes.
C</$length[2345]/>, for instance, will be interpreted as C<$length> followed
by the character class C<[2345]>.  If an array subscript is what you
want, you can avoid the warning by changing C</${length[2345]}/> to the
unsightly C</${\$length[2345]}/>, by renaming your array to something
that does not coincide with a built-in keyword, or by simply turning
off warnings with C<no warnings 'ambiguous';>.

=item '|' and '<' may not both be specified on command line

(F) An error peculiar to VMS.  Perl does its own command line
redirection, and found that STDIN was a pipe, and that you also tried to
redirect STDIN using '<'.  Only one STDIN stream to a customer, please.

=item '|' and '>' may not both be specified on command line

(F) An error peculiar to VMS.  Perl does its own command line
redirection, and thinks you tried to redirect stdout both to a file and
into a pipe to another command.  You need to choose one or the other,
though nothing's stopping you from piping into a program or Perl script
which 'splits' output into two streams, such as

    open(OUT,">$ARGV[0]") or die "Can't write to $ARGV[0]: $!";
    while (<STDIN>) {
        print;
        print OUT;
    }
    close OUT;

=item Applying %s to %s will act on scalar(%s)

(W misc) The pattern match (C<//>), substitution (C<s///>), and
transliteration (C<tr///>) operators work on scalar values.  If you apply
one of them to an array or a hash, it will convert the array or hash to
a scalar value (the length of an array, or the population info of a
hash) and then work on that scalar value.  This is probably not what
you meant to do.  See L<perlfunc/grep> and L<perlfunc/map> for
alternatives.

=item Arg too short for msgsnd

(F) msgsnd() requires a string at least as long as sizeof(long).

=item Argument "%s" isn't numeric%s

(W numeric) The indicated string was fed as an argument to an operator
that expected a numeric value instead.  If you're fortunate the message
will identify which operator was so unfortunate.

Note that for the C<Inf> and C<NaN> (infinity and not-a-number) the
definition of "numeric" is somewhat unusual: the strings themselves
(like "Inf") are considered numeric, and anything following them is
considered non-numeric.

=item Argument list not closed for PerlIO layer "%s"

(W layer) When pushing a layer with arguments onto the Perl I/O
system you forgot the ) that closes the argument list.  (Layers
take care of transforming data between external and internal
representations.)  Perl stopped parsing the layer list at this
point and did not attempt to push this layer.  If your program
didn't explicitly request the failing operation, it may be the
result of the value of the environment variable PERLIO.

=item Argument "%s" treated as 0 in increment (++)

(W numeric) The indicated string was fed as an argument to the C<++>
operator which expects either a number or a string matching
C</^[a-zA-Z]*[0-9]*\z/>.  See L<perlop/Auto-increment and
Auto-decrement> for details.

=item Array passed to stat will be coerced to a scalar%s

(W syntax) You called stat() on an array, but the array will be
coerced to a scalar - the number of elements in the array.

=item assertion botched: %s

(X) The malloc package that comes with Perl had an internal failure.

=item Assertion %s failed: file "%s", line %d

(X) A general assertion failed.  The file in question must be examined.

=item Assigned value is not a reference

(F) You tried to assign something that was not a reference to an lvalue
reference (e.g., C<\$x = $y>).  If you meant to make $x an alias to $y, use
C<\$x = \$y>.

=item Assigned value is not %s reference

(F) You tried to assign a reference to a reference constructor, but the
two references were not of the same type.  You cannot alias a scalar to
an array, or an array to a hash; the two types must match.

    \$x = \@@y;  # error
    \@@x = \%y;  # error
     $y = [];
    \$x = $y;   # error; did you mean \$y?

=item Assigning non-zero to $[ is no longer possible

(F) When the "array_base" feature is disabled (e.g., under C<use v5.16;>)
the special variable C<$[>, which is deprecated, is now a fixed zero value.

=item Assignment to both a list and a scalar

(F) If you assign to a conditional operator, the 2nd and 3rd arguments
must either both be scalars or both be lists.  Otherwise Perl won't
know which context to supply to the right side.

=item Assuming NOT a POSIX class since %s in regex; marked by S<<-- HERE> in m/%s/

(W regexp) You had something like these:

 [[:alnum]]
 [[:digit:xyz]

They look like they might have been meant to be the POSIX classes
C<[:alnum:]> or C<[:digit:]>.  If so, they should be written:

 [[:alnum:]]
 [[:digit:]xyz]

Since these aren't legal POSIX class specifications, but are legal
bracketed character classes, Perl treats them as the latter.  In the
first example, it matches the characters C<":">, C<"[">, C<"a">, C<"l">,
C<"m">, C<"n">, and C<"u">.

If these weren't meant to be POSIX classes, this warning message is
spurious, and can be suppressed by reordering things, such as

 [[al:num]]

or

 [[:munla]]

=item <> at require-statement should be quotes

(F) You wrote C<< require <file> >> when you should have written
C<require 'file'>.

=item Attempt to access disallowed key '%s' in a restricted hash

(F) The failing code has attempted to get or set a key which is not in
the current set of allowed keys of a restricted hash.

=item Attempt to bless into a freed package

(F) You wrote C<bless $foo> with one argument after somehow causing
the current package to be freed.  Perl cannot figure out what to
do, so it throws up in hands in despair.

=item Attempt to bless into a reference

(F) The CLASSNAME argument to the bless() operator is expected to be
the name of the package to bless the resulting object into.  You've
supplied instead a reference to something: perhaps you wrote

    bless $self, $proto;

when you intended

    bless $self, ref($proto) || $proto;

If you actually want to bless into the stringified version
of the reference supplied, you need to stringify it yourself, for
example by:

    bless $self, "$proto";

=item Attempt to clear deleted array

(S debugging) An array was assigned to when it was being freed.
Freed values are not supposed to be visible to Perl code.  This
can also happen if XS code calls C<av_clear> from a custom magic
callback on the array.

=item Attempt to delete disallowed key '%s' from a restricted hash

(F) The failing code attempted to delete from a restricted hash a key
which is not in its key set.

=item Attempt to delete readonly key '%s' from a restricted hash

(F) The failing code attempted to delete a key whose value has been
declared readonly from a restricted hash.

=item Attempt to free non-arena SV: 0x%x

(S internal) All SV objects are supposed to be allocated from arenas
that will be garbage collected on exit.  An SV was discovered to be
outside any of those arenas.

=item Attempt to free nonexistent shared string '%s'%s

(S internal) Perl maintains a reference-counted internal table of
strings to optimize the storage and access of hash keys and other
strings.  This indicates someone tried to decrement the reference count
of a string that can no longer be found in the table.

=item Attempt to free temp prematurely: SV 0x%x

(S debugging) Mortalized values are supposed to be freed by the
free_tmps() routine.  This indicates that something else is freeing the
SV before the free_tmps() routine gets a chance, which means that the
free_tmps() routine will be freeing an unreferenced scalar when it does
try to free it.

=item Attempt to free unreferenced glob pointers

(S internal) The reference counts got screwed up on symbol aliases.

=item Attempt to free unreferenced scalar: SV 0x%x

(S internal) Perl went to decrement the reference count of a scalar to
see if it would go to 0, and discovered that it had already gone to 0
earlier, and should have been freed, and in fact, probably was freed.
This could indicate that SvREFCNT_dec() was called too many times, or
that SvREFCNT_inc() was called too few times, or that the SV was
mortalized when it shouldn't have been, or that memory has been
corrupted.

=item Attempt to pack pointer to temporary value

(W pack) You tried to pass a temporary value (like the result of a
function, or a computed expression) to the "p" pack() template.  This
means the result contains a pointer to a location that could become
invalid anytime, even before the end of the current statement.  Use
literals or global values as arguments to the "p" pack() template to
avoid this warning.

=item Attempt to reload %s aborted.

(F) You tried to load a file with C<use> or C<require> that failed to
compile once already.  Perl will not try to compile this file again
unless you delete its entry from %INC.  See L<perlfunc/require> and
L<perlvar/%INC>.

=item Attempt to set length of freed array

(W misc) You tried to set the length of an array which has
been freed.  You can do this by storing a reference to the
scalar representing the last index of an array and later
assigning through that reference.  For example

    $r = do {my @@a; \$#a};
    $$r = 503

=item Attempt to use reference as lvalue in substr

(W substr) You supplied a reference as the first argument to substr()
used as an lvalue, which is pretty strange.  Perhaps you forgot to
dereference it first.  See L<perlfunc/substr>.

=item Attribute "locked" is deprecated

(D deprecated) You have used the attributes pragma to modify the
"locked" attribute on a code reference.  The :locked attribute is
obsolete, has had no effect since 5005 threads were removed, and
will be removed in a future release of Perl 5.

=item Attribute prototype(%s) discards earlier prototype attribute in same sub

(W misc) A sub was declared as sub foo : prototype(A) : prototype(B) {}, for
example.  Since each sub can only have one prototype, the earlier
declaration(s) are discarded while the last one is applied.

=item Attribute "unique" is deprecated

(D deprecated) You have used the attributes pragma to modify
the "unique" attribute on an array, hash or scalar reference.
The :unique attribute has had no effect since Perl 5.8.8, and
will be removed in a future release of Perl 5.

=item av_reify called on tied array

(S debugging) This indicates that something went wrong and Perl got I<very>
confused about C<@@_> or C<@@DB::args> being tied.

=item Bad arg length for %s, is %u, should be %d

(F) You passed a buffer of the wrong size to one of msgctl(), semctl()
or shmctl().  In C parlance, the correct sizes are, respectively,
S<sizeof(struct msqid_ds *)>, S<sizeof(struct semid_ds *)>, and
S<sizeof(struct shmid_ds *)>.

=item Bad evalled substitution pattern

(F) You've used the C</e> switch to evaluate the replacement for a
substitution, but perl found a syntax error in the code to evaluate,
most likely an unexpected right brace '}'.

=item Bad filehandle: %s

(F) A symbol was passed to something wanting a filehandle, but the
symbol has no filehandle associated with it.  Perhaps you didn't do an
open(), or did it in another package.

=item Bad free() ignored

(S malloc) An internal routine called free() on something that had never
been malloc()ed in the first place.  Mandatory, but can be disabled by
setting environment variable C<PERL_BADFREE> to 0.

This message can be seen quite often with DB_File on systems with "hard"
dynamic linking, like C<AIX> and C<OS/2>.  It is a bug of C<Berkeley DB>
which is left unnoticed if C<DB> uses I<forgiving> system malloc().

=item Bad hash

(P) One of the internal hash routines was passed a null HV pointer.

=item Badly placed ()'s

(A) You've accidentally run your script through B<csh> instead
of Perl.  Check the #! line, or manually feed your script into
Perl yourself.

=item Bad name after %s

(F) You started to name a symbol by using a package prefix, and then
didn't finish the symbol.  In particular, you can't interpolate outside
of quotes, so

    $var = 'myvar';
    $sym = mypack::$var;

is not the same as

    $var = 'myvar';
    $sym = "mypack::$var";

=item Bad plugin affecting keyword '%s'

(F) An extension using the keyword plugin mechanism violated the
plugin API.

=item Bad realloc() ignored

(S malloc) An internal routine called realloc() on something that
had never been malloc()ed in the first place.  Mandatory, but can
be disabled by setting the environment variable C<PERL_BADFREE> to 1.

=item Bad symbol for array

(P) An internal request asked to add an array entry to something that
wasn't a symbol table entry.

=item Bad symbol for dirhandle

(P) An internal request asked to add a dirhandle entry to something
that wasn't a symbol table entry.

=item Bad symbol for filehandle

(P) An internal request asked to add a filehandle entry to something
that wasn't a symbol table entry.

=item Bad symbol for hash

(P) An internal request asked to add a hash entry to something that
wasn't a symbol table entry.

=item Bad symbol for scalar

(P) An internal request asked to add a scalar entry to something that
wasn't a symbol table entry.

=item Bareword found in conditional

(W bareword) The compiler found a bareword where it expected a
conditional, which often indicates that an || or && was parsed as part
of the last argument of the previous construct, for example:

    open FOO || die;

It may also indicate a misspelled constant that has been interpreted as
a bareword:

    use constant TYPO => 1;
    if (TYOP) { print "foo" }

The C<strict> pragma is useful in avoiding such errors.

=item Bareword "%s" not allowed while "strict subs" in use

(F) With "strict subs" in use, a bareword is only allowed as a
subroutine identifier, in curly brackets or to the left of the "=>"
symbol.  Perhaps you need to predeclare a subroutine?

=item Bareword "%s" refers to nonexistent package

(W bareword) You used a qualified bareword of the form C<Foo::>, but the
compiler saw no other uses of that namespace before that point.  Perhaps
you need to predeclare a package?

=item BEGIN failed--compilation aborted

(F) An untrapped exception was raised while executing a BEGIN
subroutine.  Compilation stops immediately and the interpreter is
exited.

=item BEGIN not safe after errors--compilation aborted

(F) Perl found a C<BEGIN {}> subroutine (or a C<use> directive, which
implies a C<BEGIN {}>) after one or more compilation errors had already
occurred.  Since the intended environment for the C<BEGIN {}> could not
be guaranteed (due to the errors), and since subsequent code likely
depends on its correct operation, Perl just gave up.

=item \%d better written as $%d

(W syntax) Outside of patterns, backreferences live on as variables.
The use of backslashes is grandfathered on the right-hand side of a
substitution, but stylistically it's better to use the variable form
because other Perl programmers will expect it, and it works better if
there are more than 9 backreferences.

=item Binary number > 0b11111111111111111111111111111111 non-portable

(W portable) The binary number you specified is larger than 2**32-1
(4294967295) and therefore non-portable between systems.  See
L<perlport> for more on portability concerns.

=item bind() on closed socket %s

(W closed) You tried to do a bind on a closed socket.  Did you forget to
check the return value of your socket() call?  See L<perlfunc/bind>.

=item binmode() on closed filehandle %s

(W unopened) You tried binmode() on a filehandle that was never opened.
Check your control flow and number of arguments.

=item Bit vector size > 32 non-portable

(W portable) Using bit vector sizes larger than 32 is non-portable.

=item Bizarre copy of %s

(P) Perl detected an attempt to copy an internal value that is not
copiable.

=item Bizarre SvTYPE [%d]

(P) When starting a new thread or returning values from a thread, Perl
encountered an invalid data type.

=item Both or neither range ends should be Unicode in regex; marked by
S<<-- HERE> in m/%s/

(W regexp) (only under C<S<use re 'strict'>> or within C<(?[...])>)

In a bracketed character class in a regular expression pattern, you
had a range which has exactly one end of it specified using C<\N{}>, and
the other end is specified using a non-portable mechanism.  Perl treats
the range as a Unicode range, that is, all the characters in it are
considered to be the Unicode characters, and which may be different code
points on some platforms Perl runs on.  For example, C<[\N{U+06}-\x08]>
is treated as if you had instead said C<[\N{U+06}-\N{U+08}]>, that is it
matches the characters whose code points in Unicode are 6, 7, and 8.
But that C<\x08> might indicate that you meant something different, so
the warning gets raised.

=item Buffer overflow in prime_env_iter: %s

(W internal) A warning peculiar to VMS.  While Perl was preparing to
iterate over %ENV, it encountered a logical name or symbol definition
which was too long, so it was truncated to the string shown.

=item Callback called exit

(F) A subroutine invoked from an external package via call_sv()
exited by calling exit.

=item %s() called too early to check prototype

(W prototype) You've called a function that has a prototype before the
parser saw a definition or declaration for it, and Perl could not check
that the call conforms to the prototype.  You need to either add an
early prototype declaration for the subroutine in question, or move the
subroutine definition ahead of the call to get proper prototype
checking.  Alternatively, if you are certain that you're calling the
function correctly, you may put an ampersand before the name to avoid
the warning.  See L<perlsub>.

=item Calling POSIX::%s() is deprecated

(D deprecated) You called a function whose use is deprecated.  See
the function's name in L<POSIX> for details.

=item Cannot chr %f

(F) You passed an invalid number (like an infinity or not-a-number) to C<chr>.

=item Cannot compress %f in pack

(F) You tried compressing an infinity or not-a-number as an unsigned
integer with BER, which makes no sense.

=item Cannot compress integer in pack

(F) An argument to pack("w",...) was too large to compress.
The BER compressed integer format can only be used with positive
integers, and you attempted to compress a very large number (> 1e308).
See L<perlfunc/pack>.

=item Cannot compress negative numbers in pack

(F) An argument to pack("w",...) was negative.  The BER compressed integer
format can only be used with positive integers.  See L<perlfunc/pack>.

=item Cannot convert a reference to %s to typeglob

(F) You manipulated Perl's symbol table directly, stored a reference
in it, then tried to access that symbol via conventional Perl syntax.
The access triggers Perl to autovivify that typeglob, but it there is
no legal conversion from that type of reference to a typeglob.

=item Cannot copy to %s

(P) Perl detected an attempt to copy a value to an internal type that cannot
be directly assigned to.

=item Cannot find encoding "%s"

(S io) You tried to apply an encoding that did not exist to a filehandle,
either with open() or binmode().

=item Cannot pack %f with '%c'

(F) You tried converting an infinity or not-a-number to an integer,
which makes no sense.

=item Cannot printf %f with '%c'

(F) You tried printing an infinity or not-a-number as a character (%c),
which makes no sense.  Maybe you meant '%s', or just stringifying it?

=item Cannot set tied @@DB::args

(F) C<caller> tried to set C<@@DB::args>, but found it tied.  Tying C<@@DB::args>
is not supported.  (Before this error was added, it used to crash.)

=item Cannot tie unreifiable array

(P) You somehow managed to call C<tie> on an array that does not
keep a reference count on its arguments and cannot be made to
do so.  Such arrays are not even supposed to be accessible to
Perl code, but are only used internally.

=item Cannot yet reorder sv_catpvfn() arguments from va_list

(F) Some XS code tried to use C<sv_catpvfn()> or a related function with a
format string that specifies explicit indexes for some of the elements, and
using a C-style variable-argument list (a C<va_list>). This is not currently
supported. XS authors wanting to do this must instead construct a C array of
C<SV*> scalars containing the arguments.

=item Can only compress unsigned integers in pack

(F) An argument to pack("w",...) was not an integer.  The BER compressed
integer format can only be used with positive integers, and you attempted
to compress something else.  See L<perlfunc/pack>.

=item Can't bless non-reference value

(F) Only hard references may be blessed.  This is how Perl "enforces"
encapsulation of objects.  See L<perlobj>.

=item Can't "break" in a loop topicalizer

(F) You called C<break>, but you're in a C<foreach> block rather than
a C<given> block.  You probably meant to use C<next> or C<last>.

=item Can't "break" outside a given block

(F) You called C<break>, but you're not inside a C<given> block.

=item Can't call method "%s" on an undefined value

(F) You used the syntax of a method call, but the slot filled by the
object reference or package name contains an undefined value.  Something
like this will reproduce the error:

    $BADREF = undef;
    process $BADREF 1,2,3;
    $BADREF->process(1,2,3);

=item Can't call method "%s" on unblessed reference

(F) A method call must know in what package it's supposed to run.  It
ordinarily finds this out from the object reference you supply, but you
didn't supply an object reference in this case.  A reference isn't an
object reference until it has been blessed.  See L<perlobj>.

=item Can't call method "%s" without a package or object reference

(F) You used the syntax of a method call, but the slot filled by the
object reference or package name contains an expression that returns a
defined value which is neither an object reference nor a package name.
Something like this will reproduce the error:

    $BADREF = 42;
    process $BADREF 1,2,3;
    $BADREF->process(1,2,3);

=item Can't call mro_isa_changed_in() on anonymous symbol table

(P) Perl got confused as to whether a hash was a plain hash or a
symbol table hash when trying to update @@ISA caches.

=item Can't call mro_method_changed_in() on anonymous symbol table

(F) An XS module tried to call C<mro_method_changed_in> on a hash that was
not attached to the symbol table.

=item Can't chdir to %s

(F) You called C<perl -x/foo/bar>, but F</foo/bar> is not a directory
that you can chdir to, possibly because it doesn't exist.

=item Can't check filesystem of script "%s" for nosuid

(P) For some reason you can't check the filesystem of the script for
nosuid.

=item Can't coerce %s to %s in %s

(F) Certain types of SVs, in particular real symbol table entries
(typeglobs), can't be forced to stop being what they are.  So you can't
say things like:

    *foo += 1;

You CAN say

    $foo = *foo;
    $foo += 1;

but then $foo no longer contains a glob.

=item Can't "continue" outside a when block

(F) You called C<continue>, but you're not inside a C<when>
or C<default> block.

=item Can't create pipe mailbox

(P) An error peculiar to VMS.  The process is suffering from exhausted
quotas or other plumbing problems.

=item Can't declare %s in "%s"

(F) Only scalar, array, and hash variables may be declared as "my", "our" or
"state" variables.  They must have ordinary identifiers as names.

=item Can't "default" outside a topicalizer

(F) You have used a C<default> block that is neither inside a
C<foreach> loop nor a C<given> block.  (Note that this error is
issued on exit from the C<default> block, so you won't get the
error if you use an explicit C<continue>.)

=item Can't do inplace edit: %s is not a regular file

(S inplace) You tried to use the B<-i> switch on a special file, such as
a file in /dev, a FIFO or an uneditable directory.  The file was ignored.

=item Can't do inplace edit on %s: %s

(S inplace) The creation of the new file failed for the indicated
reason.

=item Can't do inplace edit without backup

(F) You're on a system such as MS-DOS that gets confused if you try
reading from a deleted (but still opened) file.  You have to say
C<-i.bak>, or some such.

=item Can't do inplace edit: %s would not be unique

(S inplace) Your filesystem does not support filenames longer than 14
characters and Perl was unable to create a unique filename during
inplace editing with the B<-i> switch.  The file was ignored.

=item Can't do %s("%s") on non-UTF-8 locale; resolved to "%s".

(W locale) You are 1) running under "C<use locale>"; 2) the current
locale is not a UTF-8 one; 3) you tried to do the designated case-change
operation on the specified Unicode character; and 4) the result of this
operation would mix Unicode and locale rules, which likely conflict.
Mixing of different rule types is forbidden, so the operation was not
done; instead the result is the indicated value, which is the best
available that uses entirely Unicode rules.  That turns out to almost
always be the original character, unchanged.

It is generally a bad idea to mix non-UTF-8 locales and Unicode, and
this issue is one of the reasons why.  This warning is raised when
Unicode rules would normally cause the result of this operation to
contain a character that is in the range specified by the locale,
0..255, and hence is subject to the locale's rules, not Unicode's.

If you are using locale purely for its characteristics related to things
like its numeric and time formatting (and not C<LC_CTYPE>), consider
using a restricted form of the locale pragma (see L<perllocale/The "use
locale" pragma>) like "S<C<use locale ':not_characters'>>".

Note that failed case-changing operations done as a result of
case-insensitive C</i> regular expression matching will show up in this
warning as having the C<fc> operation (as that is what the regular
expression engine calls behind the scenes.)

=item Can't do waitpid with flags

(F) This machine doesn't have either waitpid() or wait4(), so only
waitpid() without flags is emulated.

=item Can't emulate -%s on #! line

(F) The #! line specifies a switch that doesn't make sense at this
point.  For example, it'd be kind of silly to put a B<-x> on the #!
line.

=item Can't %s %s-endian %ss on this platform

(F) Your platform's byte-order is neither big-endian nor little-endian,
or it has a very strange pointer size.  Packing and unpacking big- or
little-endian floating point values and pointers may not be possible.
See L<perlfunc/pack>.

=item Can't exec "%s": %s

(W exec) A system(), exec(), or piped open call could not execute the
named program for the indicated reason.  Typical reasons include: the
permissions were wrong on the file, the file wasn't found in
C<$ENV{PATH}>, the executable in question was compiled for another
architecture, or the #! line in a script points to an interpreter that
can't be run for similar reasons.  (Or maybe your system doesn't support
#! at all.)

=item Can't exec %s

(F) Perl was trying to execute the indicated program for you because
that's what the #! line said.  If that's not what you wanted, you may
need to mention "perl" on the #! line somewhere.

=item Can't execute %s

(F) You used the B<-S> switch, but the copies of the script to execute
found in the PATH did not have correct permissions.

=item Can't find an opnumber for "%s"

(F) A string of a form C<CORE::word> was given to prototype(), but there
is no builtin with the name C<word>.

=item Can't find label %s

(F) You said to goto a label that isn't mentioned anywhere that it's
possible for us to go to.  See L<perlfunc/goto>.

=item Can't find %s on PATH

(F) You used the B<-S> switch, but the script to execute could not be
found in the PATH.

=item Can't find %s on PATH, '.' not in PATH

(F) You used the B<-S> switch, but the script to execute could not be
found in the PATH, or at least not with the correct permissions.  The
script exists in the current directory, but PATH prohibits running it.

=item Can't find string terminator %s anywhere before EOF

(F) Perl strings can stretch over multiple lines.  This message means
that the closing delimiter was omitted.  Because bracketed quotes count
nesting levels, the following is missing its final parenthesis:

    print q(The character '(' starts a side comment.);

If you're getting this error from a here-document, you may have
included unseen whitespace before or after your closing tag or there
may not be a linebreak after it.  A good programmer's editor will have
a way to help you find these characters (or lack of characters).  See
L<perlop> for the full details on here-documents.

=item Can't find Unicode property definition "%s"

=item Can't find Unicode property definition "%s" in regex; marked by <-- HERE in m/%s/

(F) The named property which you specified via C<\p> or C<\P> is not one
known to Perl.  Perhaps you misspelled the name?  See
L<perluniprops/Properties accessible through \p{} and \P{}>
for a complete list of available official
properties.  If it is a
L<user-defined property|perlunicode/User-Defined Character Properties>
it must have been defined by the time the regular expression is
matched.

If you didn't mean to use a Unicode property, escape the C<\p>, either
by C<\\p> (just the C<\p>) or by C<\Q\p> (the rest of the string, or
until C<\E>).

=item Can't fork: %s

(F) A fatal error occurred while trying to fork while opening a
pipeline.

=item Can't fork, trying again in 5 seconds

(W pipe) A fork in a piped open failed with EAGAIN and will be retried
after five seconds.

=item Can't get filespec - stale stat buffer?

(S) A warning peculiar to VMS.  This arises because of the difference
between access checks under VMS and under the Unix model Perl assumes.
Under VMS, access checks are done by filename, rather than by bits in
the stat buffer, so that ACLs and other protections can be taken into
account.  Unfortunately, Perl assumes that the stat buffer contains all
the necessary information, and passes it, instead of the filespec, to
the access-checking routine.  It will try to retrieve the filespec using
the device name and FID present in the stat buffer, but this works only
if you haven't made a subsequent call to the CRTL stat() routine,
because the device name is overwritten with each call.  If this warning
appears, the name lookup failed, and the access-checking routine gave up
and returned FALSE, just to be conservative.  (Note: The access-checking
routine knows about the Perl C<stat> operator and file tests, so you
shouldn't ever see this warning in response to a Perl command; it arises
only if some internal code takes stat buffers lightly.)

=item Can't get pipe mailbox device name

(P) An error peculiar to VMS.  After creating a mailbox to act as a
pipe, Perl can't retrieve its name for later use.

=item Can't get SYSGEN parameter value for MAXBUF

(P) An error peculiar to VMS.  Perl asked $GETSYI how big you want your
mailbox buffers to be, and didn't get an answer.

=item Can't "goto" into the middle of a foreach loop

(F) A "goto" statement was executed to jump into the middle of a foreach
loop.  You can't get there from here.  See L<perlfunc/goto>.

=item Can't "goto" out of a pseudo block

(F) A "goto" statement was executed to jump out of what might look like
a block, except that it isn't a proper block.  This usually occurs if
you tried to jump out of a sort() block or subroutine, which is a no-no.
See L<perlfunc/goto>.

=item Can't goto subroutine from an eval-%s

(F) The "goto subroutine" call can't be used to jump out of an eval
"string" or block.

=item Can't goto subroutine from a sort sub (or similar callback)

(F) The "goto subroutine" call can't be used to jump out of the
comparison sub for a sort(), or from a similar callback (such
as the reduce() function in List::Util).

=item Can't goto subroutine outside a subroutine

(F) The deeply magical "goto subroutine" call can only replace one
subroutine call for another.  It can't manufacture one out of whole
cloth.  In general you should be calling it out of only an AUTOLOAD
routine anyway.  See L<perlfunc/goto>.

=item Can't ignore signal CHLD, forcing to default

(W signal) Perl has detected that it is being run with the SIGCHLD
signal (sometimes known as SIGCLD) disabled.  Since disabling this
signal will interfere with proper determination of exit status of child
processes, Perl has reset the signal to its default value.  This
situation typically indicates that the parent program under which Perl
may be running (e.g. cron) is being very careless.

=item Can't kill a non-numeric process ID

(F) Process identifiers must be (signed) integers.  It is a fatal error to
attempt to kill() an undefined, empty-string or otherwise non-numeric
process identifier.

=item Can't "last" outside a loop block

(F) A "last" statement was executed to break out of the current block,
except that there's this itty bitty problem called there isn't a current
block.  Note that an "if" or "else" block doesn't count as a "loopish"
block, as doesn't a block given to sort(), map() or grep().  You can
usually double the curlies to get the same effect though, because the
inner curlies will be considered a block that loops once.  See
L<perlfunc/last>.

=item Can't linearize anonymous symbol table

(F) Perl tried to calculate the method resolution order (MRO) of a
package, but failed because the package stash has no name.

=item Can't load '%s' for module %s

(F) The module you tried to load failed to load a dynamic extension.
This may either mean that you upgraded your version of perl to one
that is incompatible with your old dynamic extensions (which is known
to happen between major versions of perl), or (more likely) that your
dynamic extension was built against an older version of the library
that is installed on your system.  You may need to rebuild your old
dynamic extensions.

=item Can't localize lexical variable %s

(F) You used local on a variable name that was previously declared as a
lexical variable using "my" or "state".  This is not allowed.  If you
want to localize a package variable of the same name, qualify it with
the package name.

=item Can't localize through a reference

(F) You said something like C<local $$ref>, which Perl can't currently
handle, because when it goes to restore the old value of whatever $ref
pointed to after the scope of the local() is finished, it can't be sure
that $ref will still be a reference.

=item Can't locate %s

(F) You said to C<do> (or C<require>, or C<use>) a file that couldn't be found.
Perl looks for the file in all the locations mentioned in @@INC, unless
the file name included the full path to the file.  Perhaps you need
to set the PERL5LIB or PERL5OPT environment variable to say where the
extra library is, or maybe the script needs to add the library name
to @@INC.  Or maybe you just misspelled the name of the file.  See
L<perlfunc/require> and L<lib>.

=item Can't locate auto/%s.al in @@INC

(F) A function (or method) was called in a package which allows
autoload, but there is no function to autoload.  Most probable causes
are a misprint in a function/method name or a failure to C<AutoSplit>
the file, say, by doing C<make install>.

=item Can't locate loadable object for module %s in @@INC

(F) The module you loaded is trying to load an external library, like
for example, F<foo.so> or F<bar.dll>, but the L<DynaLoader> module was
unable to locate this library.  See L<DynaLoader>.

=item Can't locate object method "%s" via package "%s"

(F) You called a method correctly, and it correctly indicated a package
functioning as a class, but that package doesn't define that particular
method, nor does any of its base classes.  See L<perlobj>.

=item Can't locate object method "%s" via package "%s" (perhaps you forgot
to load "%s"?)

(F) You called a method on a class that did not exist, and the method
could not be found in UNIVERSAL.  This often means that a method
requires a package that has not been loaded.

=item Can't locate package %s for @@%s::ISA

(W syntax) The @@ISA array contained the name of another package that
doesn't seem to exist.

=item Can't locate PerlIO%s

(F) You tried to use in open() a PerlIO layer that does not exist,
e.g. open(FH, ">:nosuchlayer", "somefile").

=item Can't make list assignment to %ENV on this system

(F) List assignment to %ENV is not supported on some systems, notably
VMS.

=item Can't make loaded symbols global on this platform while loading %s

(S) A module passed the flag 0x01 to DynaLoader::dl_load_file() to request
that symbols from the stated file are made available globally within the
process, but that functionality is not available on this platform.  Whilst
the module likely will still work, this may prevent the perl interpreter
from loading other XS-based extensions which need to link directly to
functions defined in the C or XS code in the stated file.

=item Can't modify %s in %s

(F) You aren't allowed to assign to the item indicated, or otherwise try
to change it, such as with an auto-increment.

=item Can't modify nonexistent substring

(P) The internal routine that does assignment to a substr() was handed
a NULL.

=item Can't modify non-lvalue subroutine call of &%s

(F) Subroutines meant to be used in lvalue context should be declared as
such.  See L<perlsub/"Lvalue subroutines">.

=item Can't modify reference to %s in %s assignment

(F) Only a limited number of constructs can be used as the argument to a
reference constructor on the left-hand side of an assignment, and what
you used was not one of them.  See L<perlref/Assigning to References>.

=item Can't modify reference to localized parenthesized array in list
assignment

(F) Assigning to C<\local(@@array)> or C<\(local @@array)> is not supported, as
it is not clear exactly what it should do.  If you meant to make @@array
refer to some other array, use C<\@@array = \@@other_array>.  If you want to
make the elements of @@array aliases of the scalars referenced on the
right-hand side, use C<\(@@array) = @@scalar_refs>.

=item Can't modify reference to parenthesized hash in list assignment

(F) Assigning to C<\(%hash)> is not supported.  If you meant to make %hash
refer to some other hash, use C<\%hash = \%other_hash>.  If you want to
make the elements of %hash into aliases of the scalars referenced on the
right-hand side, use a hash slice: C<\@@hash{@@keys} = @@those_scalar_refs>.

=item Can't msgrcv to read-only var

(F) The target of a msgrcv must be modifiable to be used as a receive
buffer.

=item Can't "next" outside a loop block

(F) A "next" statement was executed to reiterate the current block, but
there isn't a current block.  Note that an "if" or "else" block doesn't
count as a "loopish" block, as doesn't a block given to sort(), map() or
grep().  You can usually double the curlies to get the same effect
though, because the inner curlies will be considered a block that loops
once.  See L<perlfunc/next>.

=item Can't open %s: %s

(S inplace) The implicit opening of a file through use of the C<< <> >>
filehandle, either implicitly under the C<-n> or C<-p> command-line
switches, or explicitly, failed for the indicated reason.  Usually
this is because you don't have read permission for a file which
you named on the command line.

(F) You tried to call perl with the B<-e> switch, but F</dev/null> (or
your operating system's equivalent) could not be opened.

=item Can't open a reference

(W io) You tried to open a scalar reference for reading or writing,
using the 3-arg open() syntax:

    open FH, '>', $ref;

but your version of perl is compiled without perlio, and this form of
open is not supported.

=item Can't open bidirectional pipe

(W pipe) You tried to say C<open(CMD, "|cmd|")>, which is not supported.
You can try any of several modules in the Perl library to do this, such
as IPC::Open2.  Alternately, direct the pipe's output to a file using
">", and then read it in under a different file handle.

=item Can't open error file %s as stderr

(F) An error peculiar to VMS.  Perl does its own command line
redirection, and couldn't open the file specified after '2>' or '2>>' on
the command line for writing.

=item Can't open input file %s as stdin

(F) An error peculiar to VMS.  Perl does its own command line
redirection, and couldn't open the file specified after '<' on the
command line for reading.

=item Can't open output file %s as stdout

(F) An error peculiar to VMS.  Perl does its own command line
redirection, and couldn't open the file specified after '>' or '>>' on
the command line for writing.

=item Can't open output pipe (name: %s)

(P) An error peculiar to VMS.  Perl does its own command line
redirection, and couldn't open the pipe into which to send data destined
for stdout.

=item Can't open perl script "%s": %s

(F) The script you specified can't be opened for the indicated reason.

If you're debugging a script that uses #!, and normally relies on the
shell's $PATH search, the -S option causes perl to do that search, so
you don't have to type the path or C<`which $scriptname`>.

=item Can't read CRTL environ

(S) A warning peculiar to VMS.  Perl tried to read an element of %ENV
from the CRTL's internal environment array and discovered the array was
missing.  You need to figure out where your CRTL misplaced its environ
or define F<PERL_ENV_TABLES> (see L<perlvms>) so that environ is not
searched.

=item Can't redeclare "%s" in "%s"

(F) A "my", "our" or "state" declaration was found within another declaration,
such as C<my ($x, my($y), $z)> or C<our (my $x)>.

=item Can't "redo" outside a loop block

(F) A "redo" statement was executed to restart the current block, but
there isn't a current block.  Note that an "if" or "else" block doesn't
count as a "loopish" block, as doesn't a block given to sort(), map()
or grep().  You can usually double the curlies to get the same effect
though, because the inner curlies will be considered a block that
loops once.  See L<perlfunc/redo>.

=item Can't remove %s: %s, skipping file

(S inplace) You requested an inplace edit without creating a backup
file.  Perl was unable to remove the original file to replace it with
the modified file.  The file was left unmodified.

=item Can't rename %s to %s: %s, skipping file

(S inplace) The rename done by the B<-i> switch failed for some reason,
probably because you don't have write permission to the directory.

=item Can't reopen input pipe (name: %s) in binary mode

(P) An error peculiar to VMS.  Perl thought stdin was a pipe, and tried
to reopen it to accept binary data.  Alas, it failed.

=item Can't represent character for Ox%X on this platform

(F) There is a hard limit to how big a character code point can be due
to the fundamental properties of UTF-8, especially on EBCDIC
platforms.  The given code point exceeds that.  The only work-around is
to not use such a large code point.

=item Can't reset %ENV on this system

(F) You called C<reset('E')> or similar, which tried to reset
all variables in the current package beginning with "E".  In
the main package, that includes %ENV.  Resetting %ENV is not
supported on some systems, notably VMS.

=item Can't resolve method "%s" overloading "%s" in package "%s"

(F)(P) Error resolving overloading specified by a method name (as
opposed to a subroutine reference): no such method callable via the
package.  If the method name is C<???>, this is an internal error.

=item Can't return %s from lvalue subroutine

(F) Perl detected an attempt to return illegal lvalues (such as
temporary or readonly values) from a subroutine used as an lvalue.  This
is not allowed.

=item Can't return outside a subroutine

(F) The return statement was executed in mainline code, that is, where
there was no subroutine call to return out of.  See L<perlsub>.

=item Can't return %s to lvalue scalar context

(F) You tried to return a complete array or hash from an lvalue
subroutine, but you called the subroutine in a way that made Perl
think you meant to return only one value.  You probably meant to
write parentheses around the call to the subroutine, which tell
Perl that the call should be in list context.

=item Can't stat script "%s"

(P) For some reason you can't fstat() the script even though you have it
open already.  Bizarre.

=item Can't take log of %g

(F) For ordinary real numbers, you can't take the logarithm of a
negative number or zero.  There's a Math::Complex package that comes
standard with Perl, though, if you really want to do that for the
negative numbers.

=item Can't take sqrt of %g

(F) For ordinary real numbers, you can't take the square root of a
negative number.  There's a Math::Complex package that comes standard
with Perl, though, if you really want to do that.

=item Can't undef active subroutine

(F) You can't undefine a routine that's currently running.  You can,
however, redefine it while it's running, and you can even undef the
redefined subroutine while the old routine is running.  Go figure.

=item Can't upgrade %s (%d) to %d

(P) The internal sv_upgrade routine adds "members" to an SV, making it
into a more specialized kind of SV.  The top several SV types are so
specialized, however, that they cannot be interconverted.  This message
indicates that such a conversion was attempted.

=item Can't use '%c' after -mname

(F) You tried to call perl with the B<-m> switch, but you put something
other than "=" after the module name.

=item Can't use a hash as a reference

(F) You tried to use a hash as a reference, as in
C<< %foo->{"bar"} >> or C<< %$ref->{"hello"} >>.  Versions of perl
<= 5.22.0 used to allow this syntax, but shouldn't
have.  This was deprecated in perl 5.6.1.

=item Can't use an array as a reference

(F) You tried to use an array as a reference, as in
C<< @@foo->[23] >> or C<< @@$ref->[99] >>.  Versions of perl <= 5.22.0
used to allow this syntax, but shouldn't have.  This
was deprecated in perl 5.6.1.

=item Can't use anonymous symbol table for method lookup

(F) The internal routine that does method lookup was handed a symbol
table that doesn't have a name.  Symbol tables can become anonymous
for example by undefining stashes: C<undef %Some::Package::>.

=item Can't use an undefined value as %s reference

(F) A value used as either a hard reference or a symbolic reference must
be a defined value.  This helps to delurk some insidious errors.

=item Can't use bareword ("%s") as %s ref while "strict refs" in use

(F) Only hard references are allowed by "strict refs".  Symbolic
references are disallowed.  See L<perlref>.

=item Can't use %! because Errno.pm is not available

(F) The first time the C<%!> hash is used, perl automatically loads the
Errno.pm module.  The Errno module is expected to tie the %! hash to
provide symbolic names for C<$!> errno values.

=item Can't use both '<' and '>' after type '%c' in %s

(F) A type cannot be forced to have both big-endian and little-endian
byte-order at the same time, so this combination of modifiers is not
allowed.  See L<perlfunc/pack>.

=item Can't use 'defined(@@array)' (Maybe you should just omit the defined()?)

(F) defined() is not useful on arrays because it
checks for an undefined I<scalar> value.  If you want to see if the
array is empty, just use C<if (@@array) { # not empty }> for example.

=item Can't use 'defined(%hash)' (Maybe you should just omit the defined()?)

(F) C<defined()> is not usually right on hashes.

Although C<defined %hash> is false on a plain not-yet-used hash, it
becomes true in several non-obvious circumstances, including iterators,
weak references, stash names, even remaining true after C<undef %hash>.
These things make C<defined %hash> fairly useless in practice, so it now
generates a fatal error.

If a check for non-empty is what you wanted then just put it in boolean
context (see L<perldata/Scalar values>):

    if (%hash) {
       # not empty
    }

If you had C<defined %Foo::Bar::QUUX> to check whether such a package
variable exists then that's never really been reliable, and isn't
a good way to enquire about the features of a package, or whether
it's loaded, etc.

=item Can't use %s for loop variable

(P) The parser got confused when trying to parse a C<foreach> loop.

=item Can't use global %s in "%s"

(F) You tried to declare a magical variable as a lexical variable.  This
is not allowed, because the magic can be tied to only one location
(namely the global variable) and it would be incredibly confusing to
have variables in your program that looked like magical variables but
weren't.

=item Can't use '%c' in a group with different byte-order in %s

(F) You attempted to force a different byte-order on a type
that is already inside a group with a byte-order modifier.
For example you cannot force little-endianness on a type that
is inside a big-endian group.

=item Can't use "my %s" in sort comparison

(F) The global variables $a and $b are reserved for sort comparisons.
You mentioned $a or $b in the same line as the <=> or cmp operator,
and the variable had earlier been declared as a lexical variable.
Either qualify the sort variable with the package name, or rename the
lexical variable.

=item Can't use %s ref as %s ref

(F) You've mixed up your reference types.  You have to dereference a
reference of the type needed.  You can use the ref() function to
test the type of the reference, if need be.

=item Can't use string ("%s") as %s ref while "strict refs" in use

=item Can't use string ("%s"...) as %s ref while "strict refs" in use

(F) You've told Perl to dereference a string, something which
C<use strict> blocks to prevent it happening accidentally.  See
L<perlref/"Symbolic references">.  This can be triggered by an C<@@> or C<$>
in a double-quoted string immediately before interpolating a variable,
for example in C<"user @@$twitter_id">, which says to treat the contents
of C<$twitter_id> as an array reference; use a C<\> to have a literal C<@@>
symbol followed by the contents of C<$twitter_id>: C<"user \@@$twitter_id">.

=item Can't use subscript on %s

(F) The compiler tried to interpret a bracketed expression as a
subscript.  But to the left of the brackets was an expression that
didn't look like a hash or array reference, or anything else subscriptable.

=item Can't use \%c to mean $%c in expression

(W syntax) In an ordinary expression, backslash is a unary operator that
creates a reference to its argument.  The use of backslash to indicate a
backreference to a matched substring is valid only as part of a regular
expression pattern.  Trying to do this in ordinary Perl code produces a
value that prints out looking like SCALAR(0xdecaf).  Use the $1 form
instead.

=item Can't weaken a nonreference

(F) You attempted to weaken something that was not a reference.  Only
references can be weakened.

=item Can't "when" outside a topicalizer

(F) You have used a when() block that is neither inside a C<foreach>
loop nor a C<given> block.  (Note that this error is issued on exit
from the C<when> block, so you won't get the error if the match fails,
or if you use an explicit C<continue>.)

=item Can't x= to read-only value

(F) You tried to repeat a constant value (often the undefined value)
with an assignment operator, which implies modifying the value itself.
Perhaps you need to copy the value to a temporary, and repeat that.

=item Character following "\c" must be printable ASCII

(F) In C<\cI<X>>, I<X> must be a printable (non-control) ASCII character.

Note that ASCII characters that don't map to control characters are
discouraged, and will generate the warning (when enabled)
L</""\c%c" is more clearly written simply as "%s"">.

=item Character following \%c must be '{' or a single-character Unicode property name in regex; marked by <-- HERE in m/%s/

(F) (In the above the C<%c> is replaced by either C<p> or C<P>.)  You
specified something that isn't a legal Unicode property name.  Most
Unicode properties are specified by C<\p{...}>.  But if the name is a
single character one, the braces may be omitted.

=item Character in 'C' format wrapped in pack

(W pack) You said

    pack("C", $x)

where $x is either less than 0 or more than 255; the C<"C"> format is
only for encoding native operating system characters (ASCII, EBCDIC,
and so on) and not for Unicode characters, so Perl behaved as if you meant

    pack("C", $x & 255)

If you actually want to pack Unicode codepoints, use the C<"U"> format
instead.

=item Character in 'c' format wrapped in pack

(W pack) You said

    pack("c", $x)

where $x is either less than -128 or more than 127; the C<"c"> format
is only for encoding native operating system characters (ASCII, EBCDIC,
and so on) and not for Unicode characters, so Perl behaved as if you meant

    pack("c", $x & 255);

If you actually want to pack Unicode codepoints, use the C<"U"> format
instead.

=item Character in '%c' format wrapped in unpack

(W unpack) You tried something like

   unpack("H", "\x{2a1}")

where the format expects to process a byte (a character with a value
below 256), but a higher value was provided instead.  Perl uses the
value modulus 256 instead, as if you had provided:

   unpack("H", "\x{a1}")

=item Character in 'W' format wrapped in pack

(W pack) You said

    pack("U0W", $x)

where $x is either less than 0 or more than 255.  However, C<U0>-mode
expects all values to fall in the interval [0, 255], so Perl behaved
as if you meant:

    pack("U0W", $x & 255)

=item Character(s) in '%c' format wrapped in pack

(W pack) You tried something like

   pack("u", "\x{1f3}b")

where the format expects to process a sequence of bytes (character with a
value below 256), but some of the characters had a higher value.  Perl
uses the character values modulus 256 instead, as if you had provided:

   pack("u", "\x{f3}b")

=item Character(s) in '%c' format wrapped in unpack

(W unpack) You tried something like

   unpack("s", "\x{1f3}b")

where the format expects to process a sequence of bytes (character with a
value below 256), but some of the characters had a higher value.  Perl
uses the character values modulus 256 instead, as if you had provided:

   unpack("s", "\x{f3}b")

=item charnames alias definitions may not contain a sequence of multiple spaces

(F) You defined a character name which had multiple space characters
in a row.  Change them to single spaces.  Usually these names are
defined in the C<:alias> import argument to C<use charnames>, but they
could be defined by a translator installed into C<$^H{charnames}>.  See
L<charnames/CUSTOM ALIASES>.

=item charnames alias definitions may not contain trailing white-space

(F) You defined a character name which ended in a space
character.  Remove the trailing space(s).  Usually these names are
defined in the C<:alias> import argument to C<use charnames>, but they
could be defined by a translator installed into C<$^H{charnames}>.
See L<charnames/CUSTOM ALIASES>.

=item chdir() on unopened filehandle %s

(W unopened) You tried chdir() on a filehandle that was never opened.

=item "\c%c" is more clearly written simply as "%s"

(W syntax) The C<\cI<X>> construct is intended to be a way to specify
non-printable characters.  You used it for a printable one, which
is better written as simply itself, perhaps preceded by a backslash
for non-word characters.  Doing it the way you did is not portable
between ASCII and EBCDIC platforms.

=item Cloning substitution context is unimplemented

(F) Creating a new thread inside the C<s///> operator is not supported.

=item closedir() attempted on invalid dirhandle %s

(W io) The dirhandle you tried to close is either closed or not really
a dirhandle.  Check your control flow.

=item close() on unopened filehandle %s

(W unopened) You tried to close a filehandle that was never opened.

=item Closure prototype called

(F) If a closure has attributes, the subroutine passed to an attribute
handler is the prototype that is cloned when a new closure is created.
This subroutine cannot be called.

=item \C no longer supported in regex; marked by S<<-- HERE> in m/%s/

(F) The \C character class used to allow a match of single byte
within a multi-byte utf-8 character, but was removed in v5.24 as
it broke encapsulation and its implementation was extremely buggy.
If you really need to process the individual bytes, you probably
want to convert your string to one where each underlying byte is
stored as a character, with utf8::encode().

=item Code missing after '/'

(F) You had a (sub-)template that ends with a '/'.  There must be
another template code following the slash.  See L<perlfunc/pack>.

=item Code point 0x%X is not Unicode, and not portable

(S non_unicode) You had a code point that has never been in any
standard, so it is likely that languages other than Perl will NOT
understand it.  At one time, it was legal in some standards to have code
points up to 0x7FFF_FFFF, but not higher, and this code point is higher.

Acceptance of these code points is a Perl extension, and you should
expect that nothing other than Perl can handle them; Perl itself on
EBCDIC platforms before v5.24 does not handle them.

Code points above 0xFFFF_FFFF require larger than a 32 bit word.

Perl also makes no guarantees that the representation of these code
points won't change at some point in the future, say when machines
become available that have larger than a 64-bit word.  At that time,
files written by an older Perl would require conversion before being
readable by a newer Perl.

=item Code point 0x%X is not Unicode, may not be portable

(S non_unicode) You had a code point above the Unicode maximum
of U+10FFFF.

Perl allows strings to contain a superset of Unicode code points, but
these may not be accepted by other languages/systems.  Further, even if
these languages/systems accept these large code points, they may have
chosen a different representation for them than the UTF-8-like one that
Perl has, which would mean files are not exchangeable between them and
Perl.

On EBCDIC platforms, code points above 0x3FFF_FFFF have a different
representation in Perl v5.24 than before, so any file containing these
that was written before that version will require conversion before
being readable by a later Perl.

=item %s: Command not found

(A) You've accidentally run your script through B<csh> or another shell
instead of Perl.  Check the #! line, or manually feed your script into
Perl yourself.  The #! line at the top of your file could look like

  #!/usr/bin/perl -w

=item Compilation failed in require

(F) Perl could not compile a file specified in a C<require> statement.
Perl uses this generic message when none of the errors that it
encountered were severe enough to halt compilation immediately.

=item Complex regular subexpression recursion limit (%d) exceeded

(W regexp) The regular expression engine uses recursion in complex
situations where back-tracking is required.  Recursion depth is limited
to 32766, or perhaps less in architectures where the stack cannot grow
arbitrarily.  ("Simple" and "medium" situations are handled without
recursion and are not subject to a limit.)  Try shortening the string
under examination; looping in Perl code (e.g. with C<while>) rather than
in the regular expression engine; or rewriting the regular expression so
that it is simpler or backtracks less.  (See L<perlfaq2> for information
on I<Mastering Regular Expressions>.)

=item connect() on closed socket %s

(W closed) You tried to do a connect on a closed socket.  Did you forget
to check the return value of your socket() call?  See
L<perlfunc/connect>.

=item Constant(%s): Call to &{$^H{%s}} did not return a defined value

(F) The subroutine registered to handle constant overloading
(see L<overload>) or a custom charnames handler (see
L<charnames/CUSTOM TRANSLATORS>) returned an undefined value.

=item Constant(%s): $^H{%s} is not defined

(F) The parser found inconsistencies while attempting to define an
overloaded constant.  Perhaps you forgot to load the corresponding
L<overload> pragma?

=item Constant is not %s reference

(F) A constant value (perhaps declared using the C<use constant> pragma)
is being dereferenced, but it amounts to the wrong type of reference.
The message indicates the type of reference that was expected.  This
usually indicates a syntax error in dereferencing the constant value.
See L<perlsub/"Constant Functions"> and L<constant>.

=item Constants from lexical variables potentially modified elsewhere are
deprecated

(D deprecated) You wrote something like

    my $var;
    $sub = sub () { $var };

but $var is referenced elsewhere and could be modified after the C<sub>
expression is evaluated.  Either it is explicitly modified elsewhere
(C<$var = 3>) or it is passed to a subroutine or to an operator like
C<printf> or C<map>, which may or may not modify the variable.

Traditionally, Perl has captured the value of the variable at that
point and turned the subroutine into a constant eligible for inlining.
In those cases where the variable can be modified elsewhere, this
breaks the behavior of closures, in which the subroutine captures
the variable itself, rather than its value, so future changes to the
variable are reflected in the subroutine's return value.

This usage is deprecated, because the behavior is likely to change
in a future version of Perl.

If you intended for the subroutine to be eligible for inlining, then
make sure the variable is not referenced elsewhere, possibly by
copying it:

    my $var2 = $var;
    $sub = sub () { $var2 };

If you do want this subroutine to be a closure that reflects future
changes to the variable that it closes over, add an explicit C<return>:

    my $var;
    $sub = sub () { return $var };

=item Constant subroutine %s redefined

(W redefine)(S) You redefined a subroutine which had previously
been eligible for inlining.  See L<perlsub/"Constant Functions">
for commentary and workarounds.

=item Constant subroutine %s undefined

(W misc) You undefined a subroutine which had previously been eligible
for inlining.  See L<perlsub/"Constant Functions"> for commentary and
workarounds.

=item Constant(%s) unknown

(F) The parser found inconsistencies either while attempting
to define an overloaded constant, or when trying to find the
character name specified in the C<\N{...}> escape.  Perhaps you
forgot to load the corresponding L<overload> pragma?

=item :const is experimental

(S experimental::const_attr) The "const" attribute is experimental.
If you want to use the feature, disable the warning with C<no warnings
'experimental::const_attr'>, but know that in doing so you are taking
the risk that your code may break in a future Perl version.

=item :const is not permitted on named subroutines

(F) The "const" attribute causes an anonymous subroutine to be run and
its value captured at the time that it is cloned.  Named subroutines are
not cloned like this, so the attribute does not make sense on them.

=item Copy method did not return a reference

(F) The method which overloads "=" is buggy.  See
L<overload/Copy Constructor>.

=item &CORE::%s cannot be called directly

(F) You tried to call a subroutine in the C<CORE::> namespace
with C<&foo> syntax or through a reference.  Some subroutines
in this package cannot yet be called that way, but must be
called as barewords.  Something like this will work:

    BEGIN { *shove = \&CORE::push; }
    shove @@array, 1,2,3; # pushes on to @@array

=item CORE::%s is not a keyword

(F) The CORE:: namespace is reserved for Perl keywords.

=item Corrupted regexp opcode %d > %d

(P) This is either an error in Perl, or, if you're using
one, your L<custom regular expression engine|perlreapi>.  If not the
latter, report the problem through the L<perlbug> utility.

=item corrupted regexp pointers

(P) The regular expression engine got confused by what the regular
expression compiler gave it.

=item corrupted regexp program

(P) The regular expression engine got passed a regexp program without a
valid magic number.

=item Corrupt malloc ptr 0x%x at 0x%x

(P) The malloc package that comes with Perl had an internal failure.

=item Count after length/code in unpack

(F) You had an unpack template indicating a counted-length string, but
you have also specified an explicit size for the string.  See
L<perlfunc/pack>.

=for comment
The following are used in lib/diagnostics.t for testing two =items that
share the same description.  Changes here need to be propagated to there

=item Deep recursion on anonymous subroutine

=item Deep recursion on subroutine "%s"

(W recursion) This subroutine has called itself (directly or indirectly)
100 times more than it has returned.  This probably indicates an
infinite recursion, unless you're writing strange benchmark programs, in
which case it indicates something else.

This threshold can be changed from 100, by recompiling the F<perl> binary,
setting the C pre-processor macro C<PERL_SUB_DEPTH_WARN> to the desired value.

=item (?(DEFINE)....) does not allow branches in regex; marked by
S<<-- HERE> in m/%s/

(F) You used something like C<(?(DEFINE)...|..)> which is illegal.  The
most likely cause of this error is that you left out a parenthesis inside
of the C<....> part.

The S<<-- HERE> shows whereabouts in the regular expression the problem was
discovered.

=item %s defines neither package nor VERSION--version check failed

(F) You said something like "use Module 42" but in the Module file
there are neither package declarations nor a C<$VERSION>.

=item delete argument is index/value array slice, use array slice

(F) You used index/value array slice syntax (C<%array[...]>) as
the argument to C<delete>.  You probably meant C<@@array[...]> with
an @@ symbol instead.

=item delete argument is key/value hash slice, use hash slice

(F) You used key/value hash slice syntax (C<%hash{...}>) as the argument to
C<delete>.  You probably meant C<@@hash{...}> with an @@ symbol instead.

=item delete argument is not a HASH or ARRAY element or slice

(F) The argument to C<delete> must be either a hash or array element,
such as:

    $foo{$bar}
    $ref->{"susie"}[12]

or a hash or array slice, such as:

    @@foo[$bar, $baz, $xyzzy]
    @@{$ref->[12]}{"susie", "queue"}

=item Delimiter for here document is too long

(F) In a here document construct like C<<<FOO>, the label C<FOO> is too
long for Perl to handle.  You have to be seriously twisted to write code
that triggers this error.

=item Deprecated use of my() in false conditional

(D deprecated) You used a declaration similar to C<my $x if 0>.  There
has been a long-standing bug in Perl that causes a lexical variable
not to be cleared at scope exit when its declaration includes a false
conditional.  Some people have exploited this bug to achieve a kind of
static variable.  Since we intend to fix this bug, we don't want people
relying on this behavior.  You can achieve a similar static effect by
declaring the variable in a separate block outside the function, eg

    sub f { my $x if 0; return $x++ }

becomes

    { my $x; sub f { return $x++ } }

Beginning with perl 5.10.0, you can also use C<state> variables to have
lexicals that are initialized only once (see L<feature>):

    sub f { state $x; return $x++ }

=item DESTROY created new reference to dead object '%s'

(F) A DESTROY() method created a new reference to the object which is
just being DESTROYed.  Perl is confused, and prefers to abort rather
than to create a dangling reference.

=item Did not produce a valid header

See Server error.

=item %s did not return a true value

(F) A required (or used) file must return a true value to indicate that
it compiled correctly and ran its initialization code correctly.  It's
traditional to end such a file with a "1;", though any true value would
do.  See L<perlfunc/require>.

=item (Did you mean &%s instead?)

(W misc) You probably referred to an imported subroutine &FOO as $FOO or
some such.

=item (Did you mean "local" instead of "our"?)

(W misc) Remember that "our" does not localize the declared global
variable.  You have declared it again in the same lexical scope, which
seems superfluous.

=item (Did you mean $ or @@ instead of %?)

(W) You probably said %hash{$key} when you meant $hash{$key} or
@@hash{@@keys}.  On the other hand, maybe you just meant %hash and got
carried away.

=item Died

(F) You passed die() an empty string (the equivalent of C<die "">) or
you called it with no args and C<$@@> was empty.

=item Document contains no data

See Server error.

=item %s does not define %s::VERSION--version check failed

(F) You said something like "use Module 42" but the Module did not
define a C<$VERSION>.

=item '/' does not take a repeat count

(F) You cannot put a repeat count of any kind right after the '/' code.
See L<perlfunc/pack>.

=item Don't know how to get file name

(P) C<PerlIO_getname>, a perl internal I/O function specific to VMS, was
somehow called on another platform.  This should not happen.

=item Don't know how to handle magic of type \%o

(P) The internal handling of magical variables has been cursed.

=item do_study: out of memory

(P) This should have been caught by safemalloc() instead.

=item (Do you need to predeclare %s?)

(S syntax) This is an educated guess made in conjunction with the message
"%s found where operator expected".  It often means a subroutine or module
name is being referenced that hasn't been declared yet.  This may be
because of ordering problems in your file, or because of a missing
"sub", "package", "require", or "use" statement.  If you're referencing
something that isn't defined yet, you don't actually have to define the
subroutine or package before the current location.  You can use an empty
"sub foo;" or "package FOO;" to enter a "forward" declaration.

=item dump() better written as CORE::dump()

(W misc) You used the obsolescent C<dump()> built-in function, without fully
qualifying it as C<CORE::dump()>.  Maybe it's a typo.  See L<perlfunc/dump>.

=item dump is not supported

(F) Your machine doesn't support dump/undump.

=item Duplicate free() ignored

(S malloc) An internal routine called free() on something that had
already been freed.

=item Duplicate modifier '%c' after '%c' in %s

(W unpack) You have applied the same modifier more than once after a
type in a pack template.  See L<perlfunc/pack>.

=item elseif should be elsif

(S syntax) There is no keyword "elseif" in Perl because Larry thinks
it's ugly.  Your code will be interpreted as an attempt to call a method
named "elseif" for the class returned by the following block.  This is
unlikely to be what you want.

=item Empty \%c in regex; marked by S<<-- HERE> in m/%s/

=item Empty \%c{} in regex; marked by S<<-- HERE> in m/%s/

(F) C<\p> and C<\P> are used to introduce a named Unicode property, as
described in L<perlunicode> and L<perlre>.  You used C<\p> or C<\P> in
a regular expression without specifying the property name.

=item entering effective %s failed

(F) While under the C<use filetest> pragma, switching the real and
effective uids or gids failed.

=item %ENV is aliased to %s

(F) You're running under taint mode, and the C<%ENV> variable has been
aliased to another hash, so it doesn't reflect anymore the state of the
program's environment.  This is potentially insecure.

=item Error converting file specification %s

(F) An error peculiar to VMS.  Because Perl may have to deal with file
specifications in either VMS or Unix syntax, it converts them to a
single form when it must operate on them directly.  Either you've passed
an invalid file specification to Perl, or you've found a case the
conversion routines don't handle.  Drat.

=item Eval-group in insecure regular expression

(F) Perl detected tainted data when trying to compile a regular
expression that contains the C<(?{ ... })> zero-width assertion, which
is unsafe.  See L<perlre/(?{ code })>, and L<perlsec>.

=item Eval-group not allowed at runtime, use re 'eval' in regex m/%s/

(F) Perl tried to compile a regular expression containing the
C<(?{ ... })> zero-width assertion at run time, as it would when the
pattern contains interpolated values.  Since that is a security risk,
it is not allowed.  If you insist, you may still do this by using the
C<re 'eval'> pragma or by explicitly building the pattern from an
interpolated string at run time and using that in an eval().  See
L<perlre/(?{ code })>.

=item Eval-group not allowed, use re 'eval' in regex m/%s/

(F) A regular expression contained the C<(?{ ... })> zero-width
assertion, but that construct is only allowed when the C<use re 'eval'>
pragma is in effect.  See L<perlre/(?{ code })>.

=item EVAL without pos change exceeded limit in regex; marked by
S<<-- HERE> in m/%s/

(F) You used a pattern that nested too many EVAL calls without consuming
any text.  Restructure the pattern so that text is consumed.

The S<<-- HERE> shows whereabouts in the regular expression the problem was
discovered.

=item Excessively long <> operator

(F) The contents of a <> operator may not exceed the maximum size of a
Perl identifier.  If you're just trying to glob a long list of
filenames, try using the glob() operator, or put the filenames into a
variable and glob that.

=item exec? I'm not *that* kind of operating system

(F) The C<exec> function is not implemented on some systems, e.g., Symbian
OS.  See L<perlport>.

=item Execution of %s aborted due to compilation errors.

(F) The final summary message when a Perl compilation fails.

=item exists argument is not a HASH or ARRAY element or a subroutine

(F) The argument to C<exists> must be a hash or array element or a
subroutine with an ampersand, such as:

    $foo{$bar}
    $ref->{"susie"}[12]
    &do_something

=item exists argument is not a subroutine name

(F) The argument to C<exists> for C<exists &sub> must be a subroutine name,
and not a subroutine call.  C<exists &sub()> will generate this error.

=item Exiting eval via %s

(W exiting) You are exiting an eval by unconventional means, such as a
goto, or a loop control statement.

=item Exiting format via %s

(W exiting) You are exiting a format by unconventional means, such as a
goto, or a loop control statement.

=item Exiting pseudo-block via %s

(W exiting) You are exiting a rather special block construct (like a
sort block or subroutine) by unconventional means, such as a goto, or a
loop control statement.  See L<perlfunc/sort>.

=item Exiting subroutine via %s

(W exiting) You are exiting a subroutine by unconventional means, such
as a goto, or a loop control statement.

=item Exiting substitution via %s

(W exiting) You are exiting a substitution by unconventional means, such
as a return, a goto, or a loop control statement.

=item Expecting close bracket in regex; marked by S<<-- HERE> in m/%s/

(F) You wrote something like

 (?13

to denote a capturing group of the form
L<C<(?I<PARNO>)>|perlre/(?PARNO) (?-PARNO) (?+PARNO) (?R) (?0)>,
but omitted the C<")">.

=item Expecting '(?flags:(?[...' in regex; marked by S<<-- HERE> in m/%s/

(F) The C<(?[...])> extended character class regular expression construct
only allows character classes (including character class escapes like
C<\d>), operators, and parentheses.  The one exception is C<(?flags:...)>
containing at least one flag and exactly one C<(?[...])> construct.
This allows a regular expression containing just C<(?[...])> to be
interpolated.  If you see this error message, then you probably
have some other C<(?...)> construct inside your character class.  See
L<perlrecharclass/Extended Bracketed Character Classes>.

=item Experimental aliasing via reference not enabled

(F) To do aliasing via references, you must first enable the feature:

    no warnings "experimental::refaliasing";
    use feature "refaliasing";
    \$x = \$y;

=item Experimental %s on scalar is now forbidden

(F) An experimental feature added in Perl 5.14 allowed C<each>, C<keys>,
C<push>, C<pop>, C<shift>, C<splice>, C<unshift>, and C<values> to be called with a
scalar argument.  This experiment is considered unsuccessful, and
has been removed.  The C<postderef> feature may meet your needs better.

=item Experimental subroutine signatures not enabled

(F) To use subroutine signatures, you must first enable them:

    no warnings "experimental::signatures";
    use feature "signatures";
    sub foo ($left, $right) { ... }

=item Experimental "%s" subs not enabled

(F) To use lexical subs, you must first enable them:

    no warnings 'experimental::lexical_subs';
    use feature 'lexical_subs';
    my sub foo { ... }

=item Explicit blessing to '' (assuming package main)

(W misc) You are blessing a reference to a zero length string.  This has
the effect of blessing the reference into the package main.  This is
usually not what you want.  Consider providing a default target package,
e.g. bless($ref, $p || 'MyPackage');

=item %s: Expression syntax

(A) You've accidentally run your script through B<csh> instead of Perl.
Check the #! line, or manually feed your script into Perl yourself.

=item %s failed--call queue aborted

(F) An untrapped exception was raised while executing a UNITCHECK,
CHECK, INIT, or END subroutine.  Processing of the remainder of the
queue of such routines has been prematurely ended.

=item Failed to close in-place edit file %s: %s

(F) Closing an output file from in-place editing, as with the C<-i>
command-line switch, failed.

=item False [] range "%s" in regex; marked by S<<-- HERE> in m/%s/

(W regexp)(F) A character class range must start and end at a literal
character, not another character class like C<\d> or C<[:alpha:]>.  The "-"
in your false range is interpreted as a literal "-".  In a C<(?[...])>
construct, this is an error, rather than a warning.  Consider quoting
the "-", "\-".  The S<<-- HERE> shows whereabouts in the regular expression
the problem was discovered.  See L<perlre>.

=item Fatal VMS error (status=%d) at %s, line %d

(P) An error peculiar to VMS.  Something untoward happened in a VMS
system service or RTL routine; Perl's exit status should provide more
details.  The filename in "at %s" and the line number in "line %d" tell
you which section of the Perl source code is distressed.

=item fcntl is not implemented

(F) Your machine apparently doesn't implement fcntl().  What is this, a
PDP-11 or something?

=item FETCHSIZE returned a negative value

(F) A tied array claimed to have a negative number of elements, which
is not possible.

=item Field too wide in 'u' format in pack

(W pack) Each line in an uuencoded string starts with a length indicator
which can't encode values above 63.  So there is no point in asking for
a line length bigger than that.  Perl will behave as if you specified
C<u63> as the format.

=item Filehandle %s opened only for input

(W io) You tried to write on a read-only filehandle.  If you intended
it to be a read-write filehandle, you needed to open it with "+<" or
"+>" or "+>>" instead of with "<" or nothing.  If you intended only to
write the file, use ">" or ">>".  See L<perlfunc/open>.

=item Filehandle %s opened only for output

(W io) You tried to read from a filehandle opened only for writing, If
you intended it to be a read/write filehandle, you needed to open it
with "+<" or "+>" or "+>>" instead of with ">".  If you intended only to
read from the file, use "<".  See L<perlfunc/open>.  Another possibility
is that you attempted to open filedescriptor 0 (also known as STDIN) for
output (maybe you closed STDIN earlier?).

=item Filehandle %s reopened as %s only for input

(W io) You opened for reading a filehandle that got the same filehandle id
as STDOUT or STDERR.  This occurred because you closed STDOUT or STDERR
previously.

=item Filehandle STDIN reopened as %s only for output

(W io) You opened for writing a filehandle that got the same filehandle id
as STDIN.  This occurred because you closed STDIN previously.

=item Final $ should be \$ or $name

(F) You must now decide whether the final $ in a string was meant to be
a literal dollar sign, or was meant to introduce a variable name that
happens to be missing.  So you have to put either the backslash or the
name.

=item flock() on closed filehandle %s

(W closed) The filehandle you're attempting to flock() got itself closed
some time before now.  Check your control flow.  flock() operates on
filehandles.  Are you attempting to call flock() on a dirhandle by the
same name?

=item Format not terminated

(F) A format must be terminated by a line with a solitary dot.  Perl got
to the end of your file without finding such a line.

=item Format %s redefined

(W redefine) You redefined a format.  To suppress this warning, say

    {
	no warnings 'redefine';
	eval "format NAME =...";
    }

=item Found = in conditional, should be ==

(W syntax) You said

    if ($foo = 123)

when you meant

    if ($foo == 123)

(or something like that).

=item %s found where operator expected

(S syntax) The Perl lexer knows whether to expect a term or an operator.
If it sees what it knows to be a term when it was expecting to see an
operator, it gives you this warning.  Usually it indicates that an
operator or delimiter was omitted, such as a semicolon.

=item gdbm store returned %d, errno %d, key "%s"

(S) A warning from the GDBM_File extension that a store failed.

=item gethostent not implemented

(F) Your C library apparently doesn't implement gethostent(), probably
because if it did, it'd feel morally obligated to return every hostname
on the Internet.

=item get%sname() on closed socket %s

(W closed) You tried to get a socket or peer socket name on a closed
socket.  Did you forget to check the return value of your socket() call?

=item getpwnam returned invalid UIC %#o for user "%s"

(S) A warning peculiar to VMS.  The call to C<sys$getuai> underlying the
C<getpwnam> operator returned an invalid UIC.

=item getsockopt() on closed socket %s

(W closed) You tried to get a socket option on a closed socket.  Did you
forget to check the return value of your socket() call?  See
L<perlfunc/getsockopt>.

=item given is experimental

(S experimental::smartmatch) C<given> depends on smartmatch, which
is experimental, so its behavior may change or even be removed
in any future release of perl.  See the explanation under
L<perlsyn/Experimental Details on given and when>.

=item Global symbol "%s" requires explicit package name (did you forget to
declare "my %s"?)

(F) You've said "use strict" or "use strict vars", which indicates 
that all variables must either be lexically scoped (using "my" or "state"), 
declared beforehand using "our", or explicitly qualified to say 
which package the global variable is in (using "::").

=item glob failed (%s)

(S glob) Something went wrong with the external program(s) used
for C<glob> and C<< <*.c> >>.  Usually, this means that you supplied a C<glob>
pattern that caused the external program to fail and exit with a
nonzero status.  If the message indicates that the abnormal exit
resulted in a coredump, this may also mean that your csh (C shell)
is broken.  If so, you should change all of the csh-related variables
in config.sh:  If you have tcsh, make the variables refer to it as
if it were csh (e.g. C<full_csh='/usr/bin/tcsh'>); otherwise, make them
all empty (except that C<d_csh> should be C<'undef'>) so that Perl will
think csh is missing.  In either case, after editing config.sh, run
C<./Configure -S> and rebuild Perl.

=item Glob not terminated

(F) The lexer saw a left angle bracket in a place where it was expecting
a term, so it's looking for the corresponding right angle bracket, and
not finding it.  Chances are you left some needed parentheses out
earlier in the line, and you really meant a "less than".

=item gmtime(%f) failed

(W overflow) You called C<gmtime> with a number that it could not handle:
too large, too small, or NaN.  The returned value is C<undef>.

=item gmtime(%f) too large

(W overflow) You called C<gmtime> with a number that was larger than
it can reliably handle and C<gmtime> probably returned the wrong
date.  This warning is also triggered with NaN (the special
not-a-number value).

=item gmtime(%f) too small

(W overflow) You called C<gmtime> with a number that was smaller than
it can reliably handle and C<gmtime> probably returned the wrong date.

=item Got an error from DosAllocMem

(P) An error peculiar to OS/2.  Most probably you're using an obsolete
version of Perl, and this should not happen anyway.

=item goto must have label

(F) Unlike with "next" or "last", you're not allowed to goto an
unspecified destination.  See L<perlfunc/goto>.

=item Goto undefined subroutine%s

(F) You tried to call a subroutine with C<goto &sub> syntax, but
the indicated subroutine hasn't been defined, or if it was, it
has since been undefined.

=item Group name must start with a non-digit word character in regex; marked by 
S<<-- HERE> in m/%s/

(F) Group names must follow the rules for perl identifiers, meaning
they must start with a non-digit word character.  A common cause of
this error is using (?&0) instead of (?0).  See L<perlre>.

=item ()-group starts with a count

(F) A ()-group started with a count.  A count is supposed to follow
something: a template character or a ()-group.  See L<perlfunc/pack>.

=item %s had compilation errors.

(F) The final summary message when a C<perl -c> fails.

=item Had to create %s unexpectedly

(S internal) A routine asked for a symbol from a symbol table that ought
to have existed already, but for some reason it didn't, and had to be
created on an emergency basis to prevent a core dump.

=item %s has too many errors

(F) The parser has given up trying to parse the program after 10 errors.
Further error messages would likely be uninformative.

=item Having more than one /%c regexp modifier is deprecated

(D deprecated, regexp) You used the indicated regular expression pattern
modifier at least twice in a string of modifiers.  It is deprecated to
do this with this particular modifier, to allow future extensions to the
Perl language.

=item Hexadecimal float: exponent overflow

(W overflow) The hexadecimal floating point has a larger exponent
than the floating point supports.

=item Hexadecimal float: exponent underflow

(W overflow) The hexadecimal floating point has a smaller exponent
than the floating point supports.

=item Hexadecimal float: internal error (%s)

(F) Something went horribly bad in hexadecimal float handling.

=item Hexadecimal float: mantissa overflow

(W overflow) The hexadecimal floating point literal had more bits in
the mantissa (the part between the 0x and the exponent, also known as
the fraction or the significand) than the floating point supports.

=item Hexadecimal float: precision loss

(W overflow) The hexadecimal floating point had internally more
digits than could be output.  This can be caused by unsupported
long double formats, or by 64-bit integers not being available
(needed to retrieve the digits under some configurations).

=item Hexadecimal float: unsupported long double format

(F) You have configured Perl to use long doubles but
the internals of the long double format are unknown;
therefore the hexadecimal float output is impossible.

=item Hexadecimal number > 0xffffffff non-portable

(W portable) The hexadecimal number you specified is larger than 2**32-1
(4294967295) and therefore non-portable between systems.  See
L<perlport> for more on portability concerns.

=item Identifier too long

(F) Perl limits identifiers (names for variables, functions, etc.) to
about 250 characters for simple names, and somewhat more for compound
names (like C<$A::B>).  You've exceeded Perl's limits.  Future versions
of Perl are likely to eliminate these arbitrary limitations.

=item Ignoring zero length \N{} in character class in regex; marked by
S<<-- HERE> in m/%s/

(W regexp) Named Unicode character escapes (C<\N{...}>) may return a
zero-length sequence.  When such an escape is used in a character
class its behavior is not well defined.  Check that the correct
escape has been used, and the correct charname handler is in scope.

=item Illegal binary digit %s

(F) You used a digit other than 0 or 1 in a binary number.

=item Illegal binary digit %s ignored

(W digit) You may have tried to use a digit other than 0 or 1 in a
binary number.  Interpretation of the binary number stopped before the
offending digit.

=item Illegal character after '_' in prototype for %s : %s

(W illegalproto) An illegal character was found in a prototype
declaration.  The '_' in a prototype must be followed by a ';',
indicating the rest of the parameters are optional, or one of '@@'
or '%', since those two will accept 0 or more final parameters.

=item Illegal character \%o (carriage return)

(F) Perl normally treats carriage returns in the program text as it
would any other whitespace, which means you should never see this error
when Perl was built using standard options.  For some reason, your
version of Perl appears to have been built without this support.  Talk
to your Perl administrator.

=item Illegal character in prototype for %s : %s

(W illegalproto) An illegal character was found in a prototype declaration.
Legal characters in prototypes are $, @@, %, *, ;, [, ], &, \, and +.
Perhaps you were trying to write a subroutine signature but didn't enable
that feature first (C<use feature 'signatures'>), so your signature was
instead interpreted as a bad prototype.

=item Illegal declaration of anonymous subroutine

(F) When using the C<sub> keyword to construct an anonymous subroutine,
you must always specify a block of code.  See L<perlsub>.

=item Illegal declaration of subroutine %s

(F) A subroutine was not declared correctly.  See L<perlsub>.

=item Illegal division by zero

(F) You tried to divide a number by 0.  Either something was wrong in
your logic, or you need to put a conditional in to guard against
meaningless input.

=item Illegal hexadecimal digit %s ignored

(W digit) You may have tried to use a character other than 0 - 9 or
A - F, a - f in a hexadecimal number.  Interpretation of the hexadecimal
number stopped before the illegal character.

=item Illegal modulus zero

(F) You tried to divide a number by 0 to get the remainder.  Most
numbers don't take to this kindly.

=item Illegal number of bits in vec

(F) The number of bits in vec() (the third argument) must be a power of
two from 1 to 32 (or 64, if your platform supports that).

=item Illegal octal digit %s

(F) You used an 8 or 9 in an octal number.

=item Illegal octal digit %s ignored

(W digit) You may have tried to use an 8 or 9 in an octal number.
Interpretation of the octal number stopped before the 8 or 9.

=item Illegal pattern in regex; marked by S<<-- HERE> in m/%s/

(F) You wrote something like

 (?+foo)

The C<"+"> is valid only when followed by digits, indicating a
capturing group.  See
L<C<(?I<PARNO>)>|perlre/(?PARNO) (?-PARNO) (?+PARNO) (?R) (?0)>.

=item Illegal suidscript

(F) The script run under suidperl was somehow illegal.

=item Illegal switch in PERL5OPT: -%c

(X) The PERL5OPT environment variable may only be used to set the
following switches: B<-[CDIMUdmtw]>.

=item Illegal user-defined property name

(F) You specified a Unicode-like property name in a regular expression
pattern (using C<\p{}> or C<\P{}>) that Perl knows isn't an official
Unicode property, and was likely meant to be a user-defined property
name, but it can't be one of those, as they must begin with either C<In>
or C<Is>.  Check the spelling.  See also
L</Can't find Unicode property definition "%s">.

=item Ill-formed CRTL environ value "%s"

(W internal) A warning peculiar to VMS.  Perl tried to read the CRTL's
internal environ array, and encountered an element without the C<=>
delimiter used to separate keys from values.  The element is ignored.

=item Ill-formed message in prime_env_iter: |%s|

(W internal) A warning peculiar to VMS.  Perl tried to read a logical
name or CLI symbol definition when preparing to iterate over %ENV, and
didn't see the expected delimiter between key and value, so the line was
ignored.

=item (in cleanup) %s

(W misc) This prefix usually indicates that a DESTROY() method raised
the indicated exception.  Since destructors are usually called by the
system at arbitrary points during execution, and often a vast number of
times, the warning is issued only once for any number of failures that
would otherwise result in the same message being repeated.

Failure of user callbacks dispatched using the C<G_KEEPERR> flag could
also result in this warning.  See L<perlcall/G_KEEPERR>.

=item Incomplete expression within '(?[ ])' in regex; marked by S<<-- HERE>
in m/%s/

(F) There was a syntax error within the C<(?[ ])>.  This can happen if the
expression inside the construct was completely empty, or if there are
too many or few operands for the number of operators.  Perl is not smart
enough to give you a more precise indication as to what is wrong.

=item Inconsistent hierarchy during C3 merge of class '%s': merging failed on 
parent '%s'

(F) The method resolution order (MRO) of the given class is not
C3-consistent, and you have enabled the C3 MRO for this class.  See the C3
documentation in L<mro> for more information.

=item Infinite recursion in regex

(F) You used a pattern that references itself without consuming any input
text.  You should check the pattern to ensure that recursive patterns
either consume text or fail.

=item Initialization of state variables in list context currently forbidden

(F) Currently the implementation of "state" only permits the
initialization of scalar variables in scalar context.  Re-write
C<state ($a) = 42> as C<state $a = 42> to change from list to scalar
context.  Constructions such as C<state (@@a) = foo()> will be
supported in a future perl release.

=item %%s[%s] in scalar context better written as $%s[%s]

(W syntax) In scalar context, you've used an array index/value slice
(indicated by %) to select a single element of an array.  Generally
it's better to ask for a scalar value (indicated by $).  The difference
is that C<$foo[&bar]> always behaves like a scalar, both in the value it
returns and when evaluating its argument, while C<%foo[&bar]> provides
a list context to its subscript, which can do weird things if you're
expecting only one subscript.  When called in list context, it also
returns the index (what C<&bar> returns) in addition to the value.

=item %%s{%s} in scalar context better written as $%s{%s}

(W syntax) In scalar context, you've used a hash key/value slice
(indicated by %) to select a single element of a hash.  Generally it's
better to ask for a scalar value (indicated by $).  The difference
is that C<$foo{&bar}> always behaves like a scalar, both in the value
it returns and when evaluating its argument, while C<@@foo{&bar}> and
provides a list context to its subscript, which can do weird things
if you're expecting only one subscript.  When called in list context,
it also returns the key in addition to the value.

=item Insecure dependency in %s

(F) You tried to do something that the tainting mechanism didn't like.
The tainting mechanism is turned on when you're running setuid or
setgid, or when you specify B<-T> to turn it on explicitly.  The
tainting mechanism labels all data that's derived directly or indirectly
from the user, who is considered to be unworthy of your trust.  If any
such data is used in a "dangerous" operation, you get this error.  See
L<perlsec> for more information.

=item Insecure directory in %s

(F) You can't use system(), exec(), or a piped open in a setuid or
setgid script if C<$ENV{PATH}> contains a directory that is writable by
the world.  Also, the PATH must not contain any relative directory.
See L<perlsec>.

=item Insecure $ENV{%s} while running %s

(F) You can't use system(), exec(), or a piped open in a setuid or
setgid script if any of C<$ENV{PATH}>, C<$ENV{IFS}>, C<$ENV{CDPATH}>,
C<$ENV{ENV}>, C<$ENV{BASH_ENV}> or C<$ENV{TERM}> are derived from data
supplied (or potentially supplied) by the user.  The script must set
the path to a known value, using trustworthy data.  See L<perlsec>.

=item Insecure user-defined property %s

(F) Perl detected tainted data when trying to compile a regular
expression that contains a call to a user-defined character property
function, i.e. C<\p{IsFoo}> or C<\p{InFoo}>.
See L<perlunicode/User-Defined Character Properties> and L<perlsec>.

=item Integer overflow in format string for %s

(F) The indexes and widths specified in the format string of C<printf()>
or C<sprintf()> are too large.  The numbers must not overflow the size of
integers for your architecture.

=item Integer overflow in %s number

(S overflow) The hexadecimal, octal or binary number you have specified
either as a literal or as an argument to hex() or oct() is too big for
your architecture, and has been converted to a floating point number.
On a 32-bit architecture the largest hexadecimal, octal or binary number
representable without overflow is 0xFFFFFFFF, 037777777777, or
0b11111111111111111111111111111111 respectively.  Note that Perl
transparently promotes all numbers to a floating point representation
internally--subject to loss of precision errors in subsequent
operations.

=item Integer overflow in srand

(S overflow) The number you have passed to srand is too big to fit
in your architecture's integer representation.  The number has been
replaced with the largest integer supported (0xFFFFFFFF on 32-bit
architectures).  This means you may be getting less randomness than
you expect, because different random seeds above the maximum will
return the same sequence of random numbers.

=item Integer overflow in version

=item Integer overflow in version %d

(W overflow) Some portion of a version initialization is too large for
the size of integers for your architecture.  This is not a warning
because there is no rational reason for a version to try and use an
element larger than typically 2**32.  This is usually caused by trying
to use some odd mathematical operation as a version, like 100/9.

=item Internal disaster in regex; marked by S<<-- HERE> in m/%s/

(P) Something went badly wrong in the regular expression parser.
The S<<-- HERE> shows whereabouts in the regular expression the problem was
discovered.

=item Internal inconsistency in tracking vforks

(S) A warning peculiar to VMS.  Perl keeps track of the number of times
you've called C<fork> and C<exec>, to determine whether the current call
to C<exec> should affect the current script or a subprocess (see
L<perlvms/"exec LIST">).  Somehow, this count has become scrambled, so
Perl is making a guess and treating this C<exec> as a request to
terminate the Perl script and execute the specified command.

=item internal %<num>p might conflict with future printf extensions

(S internal) Perl's internal routine that handles C<printf> and C<sprintf>
formatting follows a slightly different set of rules when called from
C or XS code.  Specifically, formats consisting of digits followed
by "p" (e.g., "%7p") are reserved for future use.  If you see this
message, then an XS module tried to call that routine with one such
reserved format.

=item Internal urp in regex; marked by S<<-- HERE> in m/%s/

(P) Something went badly awry in the regular expression parser.  The
S<<-- HERE> shows whereabouts in the regular expression the problem was
discovered.

=item %s (...) interpreted as function

(W syntax) You've run afoul of the rule that says that any list operator
followed by parentheses turns into a function, with all the list
operators arguments found inside the parentheses.  See
L<perlop/Terms and List Operators (Leftward)>.

=item In '(?...)', the '(' and '?' must be adjacent in regex;
marked by S<<-- HERE> in m/%s/

(F) The two-character sequence C<"(?"> in this context in a regular
expression pattern should be an indivisible token, with nothing
intervening between the C<"("> and the C<"?">, but you separated them
with whitespace.

=item Invalid %s attribute: %s

(F) The indicated attribute for a subroutine or variable was not recognized
by Perl or by a user-supplied handler.  See L<attributes>.

=item Invalid %s attributes: %s

(F) The indicated attributes for a subroutine or variable were not
recognized by Perl or by a user-supplied handler.  See L<attributes>.

=item Invalid character in charnames alias definition; marked by
S<<-- HERE> in '%s

(F) You tried to create a custom alias for a character name, with
the C<:alias> option to C<use charnames> and the specified character in
the indicated name isn't valid.  See L<charnames/CUSTOM ALIASES>.

=item Invalid \0 character in %s for %s: %s\0%s

(W syscalls) Embedded \0 characters in pathnames or other system call
arguments produce a warning as of 5.20.  The parts after the \0 were
formerly ignored by system calls.

=item Invalid character in \N{...}; marked by S<<-- HERE> in \N{%s}

(F) Only certain characters are valid for character names.  The
indicated one isn't.  See L<charnames/CUSTOM ALIASES>.

=item Invalid conversion in %s: "%s"

(W printf) Perl does not understand the given format conversion.  See
L<perlfunc/sprintf>.

=item Invalid escape in the specified encoding in regex; marked by
S<<-- HERE> in m/%s/

(W regexp)(F) The numeric escape (for example C<\xHH>) of value < 256
didn't correspond to a single character through the conversion
from the encoding specified by the encoding pragma.
The escape was replaced with REPLACEMENT CHARACTER (U+FFFD)
instead, except within S<C<(?[   ])>>, where it is a fatal error.
The S<<-- HERE> shows whereabouts in the regular expression the
escape was discovered.

=item Invalid hexadecimal number in \N{U+...}

=item Invalid hexadecimal number in \N{U+...} in regex; marked by
S<<-- HERE> in m/%s/

(F) The character constant represented by C<...> is not a valid hexadecimal
number.  Either it is empty, or you tried to use a character other than
0 - 9 or A - F, a - f in a hexadecimal number.

=item Invalid module name %s with -%c option: contains single ':'

(F) The module argument to perl's B<-m> and B<-M> command-line options
cannot contain single colons in the module name, but only in the
arguments after "=".  In other words, B<-MFoo::Bar=:baz> is ok, but
B<-MFoo:Bar=baz> is not.

=item Invalid mro name: '%s'

(F) You tried to C<mro::set_mro("classname", "foo")> or C<use mro 'foo'>,
where C<foo> is not a valid method resolution order (MRO).  Currently,
the only valid ones supported are C<dfs> and C<c3>, unless you have loaded
a module that is a MRO plugin.  See L<mro> and L<perlmroapi>.

=item Invalid negative number (%s) in chr

(W utf8) You passed a negative number to C<chr>.  Negative numbers are
not valid character numbers, so it returns the Unicode replacement
character (U+FFFD).

=item Invalid number '%s' for -C option.

(F) You supplied a number to the -C option that either has extra leading
zeroes or overflows perl's unsigned integer representation.

=item invalid option -D%c, use -D'' to see choices

(S debugging) Perl was called with invalid debugger flags.  Call perl
with the B<-D> option with no flags to see the list of acceptable values.
See also L<perlrun/-Dletters>.

=item Invalid quantifier in {,} in regex; marked by S<<-- HERE> in m/%s/

(F) The pattern looks like a {min,max} quantifier, but the min or max
could not be parsed as a valid number - either it has leading zeroes,
or it represents too big a number to cope with.  The S<<-- HERE> shows
where in the regular expression the problem was discovered.  See L<perlre>.

=item Invalid [] range "%s" in regex; marked by S<<-- HERE> in m/%s/

(F) The range specified in a character class had a minimum character
greater than the maximum character.  One possibility is that you forgot the
C<{}> from your ending C<\x{}> - C<\x> without the curly braces can go only
up to C<ff>.  The S<<-- HERE> shows whereabouts in the regular expression the
problem was discovered.  See L<perlre>.

=item Invalid range "%s" in transliteration operator

(F) The range specified in the tr/// or y/// operator had a minimum
character greater than the maximum character.  See L<perlop>.

=item Invalid separator character %s in attribute list

(F) Something other than a colon or whitespace was seen between the
elements of an attribute list.  If the previous attribute had a
parenthesised parameter list, perhaps that list was terminated too soon.
See L<attributes>.

=item Invalid separator character %s in PerlIO layer specification %s

(W layer) When pushing layers onto the Perl I/O system, something other
than a colon or whitespace was seen between the elements of a layer list.
If the previous attribute had a parenthesised parameter list, perhaps that
list was terminated too soon.

=item Invalid strict version format (%s)

(F) A version number did not meet the "strict" criteria for versions.
A "strict" version number is a positive decimal number (integer or
decimal-fraction) without exponentiation or else a dotted-decimal
v-string with a leading 'v' character and at least three components.
The parenthesized text indicates which criteria were not met.
See the L<version> module for more details on allowed version formats.

=item Invalid type '%s' in %s

(F) The given character is not a valid pack or unpack type.
See L<perlfunc/pack>.

(W) The given character is not a valid pack or unpack type but used to be
silently ignored.

=item Invalid version format (%s)

(F) A version number did not meet the "lax" criteria for versions.
A "lax" version number is a positive decimal number (integer or
decimal-fraction) without exponentiation or else a dotted-decimal
v-string.  If the v-string has fewer than three components, it
must have a leading 'v' character.  Otherwise, the leading 'v' is
optional.  Both decimal and dotted-decimal versions may have a
trailing "alpha" component separated by an underscore character
after a fractional or dotted-decimal component.  The parenthesized
text indicates which criteria were not met.  See the L<version> module
for more details on allowed version formats.

=item Invalid version object

(F) The internal structure of the version object was invalid.
Perhaps the internals were modified directly in some way or
an arbitrary reference was blessed into the "version" class.

=item In '(*VERB...)', the '(' and '*' must be adjacent in regex;
marked by S<<-- HERE> in m/%s/

(F) The two-character sequence C<"(*"> in
this context in a regular expression pattern should be an
indivisible token, with nothing intervening between the C<"(">
and the C<"*">, but you separated them.

=item ioctl is not implemented

(F) Your machine apparently doesn't implement ioctl(), which is pretty
strange for a machine that supports C.

=item ioctl() on unopened %s

(W unopened) You tried ioctl() on a filehandle that was never opened.
Check your control flow and number of arguments.

=item IO layers (like '%s') unavailable

(F) Your Perl has not been configured to have PerlIO, and therefore
you cannot use IO layers.  To have PerlIO, Perl must be configured
with 'useperlio'.

=item IO::Socket::atmark not implemented on this architecture

(F) Your machine doesn't implement the sockatmark() functionality,
neither as a system call nor an ioctl call (SIOCATMARK).

=item '%s' is an unknown bound type in regex; marked by S<<-- HERE> in m/%s/

(F) You used C<\b{...}> or C<\B{...}> and the C<...> is not known to
Perl.  The current valid ones are given in
L<perlrebackslash/\b{}, \b, \B{}, \B>.

=item %s() is deprecated on :utf8 handles

(W deprecated) The sysread(), recv(), syswrite() and send() operators are
deprecated on handles that have the C<:utf8> layer, either explicitly, or
implicitly, eg., with the C<:encoding(UTF-16LE)> layer.

Both sysread() and recv() currently use only the C<:utf8> flag for the stream,
ignoring the actual layers.  Since sysread() and recv() do no UTF-8
validation they can end up creating invalidly encoded scalars.

Similarly, syswrite() and send() use only the C<:utf8> flag, otherwise ignoring
any layers.  If the flag is set, both write the value UTF-8 encoded, even if
the layer is some different encoding, such as the example above.

Ideally, all of these operators would completely ignore the C<:utf8> state,
working only with bytes, but this would result in silently breaking existing
code.  To avoid this a future version of perl will throw an exception when
any of sysread(), recv(), syswrite() or send() are called on handle with the
C<:utf8> layer.

=item "%s" is more clearly written simply as "%s" in regex; marked by S<<-- HERE> in m/%s/

(W regexp) (only under C<S<use re 'strict'>> or within C<(?[...])>)

You specified a character that has the given plainer way of writing it,
and which is also portable to platforms running with different character
sets.

=item $* is no longer supported

(D deprecated, syntax) The special variable C<$*>, deprecated in older
perls, has been removed as of 5.10.0 and is no longer supported.  In
previous versions of perl the use of C<$*> enabled or disabled multi-line
matching within a string.

Instead of using C<$*> you should use the C</m> (and maybe C</s>) regexp
modifiers.  You can enable C</m> for a lexical scope (even a whole file)
with C<use re '/m'>.  (In older versions: when C<$*> was set to a true value
then all regular expressions behaved as if they were written using C</m>.)

=item $# is no longer supported

(D deprecated, syntax) The special variable C<$#>, deprecated in older
perls, has been removed as of 5.10.0 and is no longer supported.  You
should use the printf/sprintf functions instead.

=item '%s' is not a code reference

(W overload) The second (fourth, sixth, ...) argument of
overload::constant needs to be a code reference.  Either
an anonymous subroutine, or a reference to a subroutine.

=item '%s' is not an overloadable type

(W overload) You tried to overload a constant type the overload package is
unaware of.

=item -i used with no filenames on the command line, reading from STDIN

(S inplace) The C<-i> option was passed on the command line, indicating
that the script is intended to edit files in place, but no files were
given.  This is usually a mistake, since editing STDIN in place doesn't
make sense, and can be confusing because it can make perl look like
it is hanging when it is really just trying to read from STDIN.  You
should either pass a filename to edit, or remove C<-i> from the command
line.  See L<perlrun> for more details.

=item Junk on end of regexp in regex m/%s/

(P) The regular expression parser is confused.

=item Label not found for "last %s"

(F) You named a loop to break out of, but you're not currently in a loop
of that name, not even if you count where you were called from.  See
L<perlfunc/last>.

=item Label not found for "next %s"

(F) You named a loop to continue, but you're not currently in a loop of
that name, not even if you count where you were called from.  See
L<perlfunc/last>.

=item Label not found for "redo %s"

(F) You named a loop to restart, but you're not currently in a loop of
that name, not even if you count where you were called from.  See
L<perlfunc/last>.

=item leaving effective %s failed

(F) While under the C<use filetest> pragma, switching the real and
effective uids or gids failed.

=item length/code after end of string in unpack

(F) While unpacking, the string buffer was already used up when an unpack
length/code combination tried to obtain more data.  This results in
an undefined value for the length.  See L<perlfunc/pack>.

=item length() used on %s (did you mean "scalar(%s)"?)

(W syntax) You used length() on either an array or a hash when you
probably wanted a count of the items.

Array size can be obtained by doing:

    scalar(@@array);

The number of items in a hash can be obtained by doing:

    scalar(keys %hash);

=item Lexing code attempted to stuff non-Latin-1 character into Latin-1 input

(F) An extension is attempting to insert text into the current parse
(using L<lex_stuff_pvn|perlapi/lex_stuff_pvn> or similar), but tried to insert a character that
couldn't be part of the current input.  This is an inherent pitfall
of the stuffing mechanism, and one of the reasons to avoid it.  Where
it is necessary to stuff, stuffing only plain ASCII is recommended.

=item Lexing code internal error (%s)

(F) Lexing code supplied by an extension violated the lexer's API in a
detectable way.

=item listen() on closed socket %s

(W closed) You tried to do a listen on a closed socket.  Did you forget
to check the return value of your socket() call?  See
L<perlfunc/listen>.

=item List form of piped open not implemented

(F) On some platforms, notably Windows, the three-or-more-arguments
form of C<open> does not support pipes, such as C<open($pipe, '|-', @@args)>.
Use the two-argument C<open($pipe, '|prog arg1 arg2...')> form instead.

=item %s: loadable library and perl binaries are mismatched (got handshake key %p, needed %p)

(P) A dynamic loading library C<.so> or C<.dll> was being loaded into the
process that was built against a different build of perl than the
said library was compiled against.  Reinstalling the XS module will
likely fix this error.

=item Locale '%s' may not work well.%s

(W locale) You are using the named locale, which is a non-UTF-8 one, and
which perl has determined is not fully compatible with what it can
handle.  The second C<%s> gives a reason.

By far the most common reason is that the locale has characters in it
that are represented by more than one byte.  The only such locales that
Perl can handle are the UTF-8 locales.  Most likely the specified locale
is a non-UTF-8 one for an East Asian language such as Chinese or
Japanese.  If the locale is a superset of ASCII, the ASCII portion of it
may work in Perl.

Some essentially obsolete locales that aren't supersets of ASCII, mainly
those in ISO 646 or other 7-bit locales, such as ASMO 449, can also have
problems, depending on what portions of the ASCII character set get
changed by the locale and are also used by the program.
The warning message lists the determinable conflicting characters.

Note that not all incompatibilities are found.

If this happens to you, there's not much you can do except switch to use a
different locale or use L<Encode> to translate from the locale into
UTF-8; if that's impracticable, you have been warned that some things
may break.

This message is output once each time a bad locale is switched into
within the scope of C<S<use locale>>, or on the first possibly-affected
operation if the C<S<use locale>> inherits a bad one.  It is not raised
for any operations from the L<POSIX> module.

=item localtime(%f) failed

(W overflow) You called C<localtime> with a number that it could not handle:
too large, too small, or NaN.  The returned value is C<undef>.

=item localtime(%f) too large

(W overflow) You called C<localtime> with a number that was larger
than it can reliably handle and C<localtime> probably returned the
wrong date.  This warning is also triggered with NaN (the special
not-a-number value).

=item localtime(%f) too small

(W overflow) You called C<localtime> with a number that was smaller
than it can reliably handle and C<localtime> probably returned the
wrong date.

=item Lookbehind longer than %d not implemented in regex m/%s/

(F) There is currently a limit on the length of string which lookbehind can
handle.  This restriction may be eased in a future release. 

=item Lost precision when %s %f by 1

(W imprecision) The value you attempted to increment or decrement by one
is too large for the underlying floating point representation to store
accurately, hence the target of C<++> or C<--> is unchanged.  Perl issues this
warning because it has already switched from integers to floating point
when values are too large for integers, and now even floating point is
insufficient.  You may wish to switch to using L<Math::BigInt> explicitly.

=item lstat() on filehandle%s

(W io) You tried to do an lstat on a filehandle.  What did you mean
by that?  lstat() makes sense only on filenames.  (Perl did a fstat()
instead on the filehandle.)

=item lvalue attribute %s already-defined subroutine

(W misc) Although L<attributes.pm|attributes> allows this, turning the lvalue
attribute on or off on a Perl subroutine that is already defined
does not always work properly.  It may or may not do what you
want, depending on what code is inside the subroutine, with exact
details subject to change between Perl versions.  Only do this
if you really know what you are doing.

=item lvalue attribute ignored after the subroutine has been defined

(W misc) Using the C<:lvalue> declarative syntax to make a Perl
subroutine an lvalue subroutine after it has been defined is
not permitted.  To make the subroutine an lvalue subroutine,
add the lvalue attribute to the definition, or put the C<sub
foo :lvalue;> declaration before the definition.

See also L<attributes.pm|attributes>.

=item Magical list constants are not supported

(F) You assigned a magical array to a stash element, and then tried
to use the subroutine from the same slot.  You are asking Perl to do
something it cannot do, details subject to change between Perl versions.

=item Malformed integer in [] in pack

(F) Between the brackets enclosing a numeric repeat count only digits
are permitted.  See L<perlfunc/pack>.

=item Malformed integer in [] in unpack

(F) Between the brackets enclosing a numeric repeat count only digits
are permitted.  See L<perlfunc/pack>.

=item Malformed PERLLIB_PREFIX

(F) An error peculiar to OS/2.  PERLLIB_PREFIX should be of the form

    prefix1;prefix2

or
    prefix1 prefix2

with nonempty prefix1 and prefix2.  If C<prefix1> is indeed a prefix of
a builtin library search path, prefix2 is substituted.  The error may
appear if components are not found, or are too long.  See
"PERLLIB_PREFIX" in L<perlos2>.

=item Malformed prototype for %s: %s

(F) You tried to use a function with a malformed prototype.  The
syntax of function prototypes is given a brief compile-time check for
obvious errors like invalid characters.  A more rigorous check is run
when the function is called.
Perhaps the function's author was trying to write a subroutine signature
but didn't enable that feature first (C<use feature 'signatures'>),
so the signature was instead interpreted as a bad prototype.

=item Malformed UTF-8 character (%s)

(S utf8)(F) Perl detected a string that didn't comply with UTF-8
encoding rules, even though it had the UTF8 flag on.

One possible cause is that you set the UTF8 flag yourself for data that
you thought to be in UTF-8 but it wasn't (it was for example legacy
8-bit data).  To guard against this, you can use Encode::decode_utf8.

If you use the C<:encoding(UTF-8)> PerlIO layer for input, invalid byte
sequences are handled gracefully, but if you use C<:utf8>, the flag is
set without validating the data, possibly resulting in this error
message.

See also L<Encode/"Handling Malformed Data">.

=item Malformed UTF-8 character immediately after '%s'

(F) You said C<use utf8>, but the program file doesn't comply with UTF-8
encoding rules.  The message prints out the properly encoded characters
just before the first bad one.  If C<utf8> warnings are enabled, a
warning is generated that gives more details about the type of
malformation.

=item Malformed UTF-8 returned by \N{%s} immediately after '%s'

(F) The charnames handler returned malformed UTF-8.

=item Malformed UTF-8 string in '%c' format in unpack

(F) You tried to unpack something that didn't comply with UTF-8 encoding
rules and perl was unable to guess how to make more progress.

=item Malformed UTF-8 string in pack

(F) You tried to pack something that didn't comply with UTF-8 encoding
rules and perl was unable to guess how to make more progress.

=item Malformed UTF-8 string in unpack

(F) You tried to unpack something that didn't comply with UTF-8 encoding
rules and perl was unable to guess how to make more progress.

=item Malformed UTF-16 surrogate

(F) Perl thought it was reading UTF-16 encoded character data but while
doing it Perl met a malformed Unicode surrogate.

=item Mandatory parameter follows optional parameter

(F) In a subroutine signature, you wrote something like "$a = undef,
$b", making an earlier parameter optional and a later one mandatory.
Parameters are filled from left to right, so it's impossible for the
caller to omit an earlier one and pass a later one.  If you want to act
as if the parameters are filled from right to left, declare the rightmost
optional and then shuffle the parameters around in the subroutine's body.

=item Matched non-Unicode code point 0x%X against Unicode property; may
not be portable

(S non_unicode) Perl allows strings to contain a superset of
Unicode code points; each code point may be as large as what is storable
in an unsigned integer on your system, but these may not be accepted by
other languages/systems.  This message occurs when you matched a string
containing such a code point against a regular expression pattern, and
the code point was matched against a Unicode property, C<\p{...}> or
C<\P{...}>.  Unicode properties are only defined on Unicode code points,
so the result of this match is undefined by Unicode, but Perl (starting
in v5.20) treats non-Unicode code points as if they were typical
unassigned Unicode ones, and matched this one accordingly.  Whether a
given property matches these code points or not is specified in
L<perluniprops/Properties accessible through \p{} and \P{}>.

This message is suppressed (unless it has been made fatal) if it is
immaterial to the results of the match if the code point is Unicode or
not.  For example, the property C<\p{ASCII_Hex_Digit}> only can match
the 22 characters C<[0-9A-Fa-f]>, so obviously all other code points,
Unicode or not, won't match it.  (And C<\P{ASCII_Hex_Digit}> will match
every code point except these 22.)

Getting this message indicates that the outcome of the match arguably
should have been the opposite of what actually happened.  If you think
that is the case, you may wish to make the C<non_unicode> warnings
category fatal; if you agree with Perl's decision, you may wish to turn
off this category.

See L<perlunicode/Beyond Unicode code points> for more information.

=item %s matches null string many times in regex; marked by S<<-- HERE> in
m/%s/

(W regexp) The pattern you've specified would be an infinite loop if the
regular expression engine didn't specifically check for that.  The S<<-- HERE>
shows whereabouts in the regular expression the problem was discovered.
See L<perlre>.

=item Maximal count of pending signals (%u) exceeded

(F) Perl aborted due to too high a number of signals pending.  This
usually indicates that your operating system tried to deliver signals
too fast (with a very high priority), starving the perl process from
resources it would need to reach a point where it can process signals
safely.  (See L<perlipc/"Deferred Signals (Safe Signals)">.)

=item "%s" may clash with future reserved word

(W) This warning may be due to running a perl5 script through a perl4
interpreter, especially if the word that is being warned about is
"use" or "my".

=item '%' may not be used in pack

(F) You can't pack a string by supplying a checksum, because the
checksumming process loses information, and you can't go the other way.
See L<perlfunc/unpack>.

=item Method for operation %s not found in package %s during blessing

(F) An attempt was made to specify an entry in an overloading table that
doesn't resolve to a valid subroutine.  See L<overload>.

=item Method %s not permitted

See Server error.

=item Might be a runaway multi-line %s string starting on line %d

(S) An advisory indicating that the previous error may have been caused
by a missing delimiter on a string or pattern, because it eventually
ended earlier on the current line.

=item Misplaced _ in number

(W syntax) An underscore (underbar) in a numeric constant did not
separate two digits.

=item Missing argument in %s

(W missing) You called a function with fewer arguments than other
arguments you supplied indicated would be needed.

Currently only emitted when a printf-type format required more
arguments than were supplied, but might be used in the future for
other cases where we can statically determine that arguments to
functions are missing, e.g. for the L<perlfunc/pack> function.

=item Missing argument to -%c

(F) The argument to the indicated command line switch must follow
immediately after the switch, without intervening spaces.

=item Missing braces on \N{}

=item Missing braces on \N{} in regex; marked by S<<-- HERE> in m/%s/

(F) Wrong syntax of character name literal C<\N{charname}> within
double-quotish context.  This can also happen when there is a space
(or comment) between the C<\N> and the C<{> in a regex with the C</x> modifier.
This modifier does not change the requirement that the brace immediately
follow the C<\N>.

=item Missing braces on \o{}

(F) A C<\o> must be followed immediately by a C<{> in double-quotish context.

=item Missing comma after first argument to %s function

(F) While certain functions allow you to specify a filehandle or an
"indirect object" before the argument list, this ain't one of them.

=item Missing command in piped open

(W pipe) You used the C<open(FH, "| command")> or
C<open(FH, "command |")> construction, but the command was missing or
blank.

=item Missing control char name in \c

(F) A double-quoted string ended with "\c", without the required control
character name.

=item Missing ']' in prototype for %s : %s

(W illegalproto) A grouping was started with C<[> but never closed with C<]>.

=item Missing name in "%s sub"

(F) The syntax for lexically scoped subroutines requires that
they have a name with which they can be found.

=item Missing $ on loop variable

(F) Apparently you've been programming in B<csh> too much.  Variables
are always mentioned with the $ in Perl, unlike in the shells, where it
can vary from one line to the next.

=item (Missing operator before %s?)

(S syntax) This is an educated guess made in conjunction with the message
"%s found where operator expected".  Often the missing operator is a comma.

=item Missing or undefined argument to require

(F) You tried to call require with no argument or with an undefined
value as an argument.  Require expects either a package name or a
file-specification as an argument.  See L<perlfunc/require>.

=item Missing right brace on \%c{} in regex; marked by S<<-- HERE> in m/%s/

(F) Missing right brace in C<\x{...}>, C<\p{...}>, C<\P{...}>, or C<\N{...}>.

=item Missing right brace on \N{}

=item Missing right brace on \N{} or unescaped left brace after \N

(F) C<\N> has two meanings.

The traditional one has it followed by a name enclosed in braces,
meaning the character (or sequence of characters) given by that
name.  Thus C<\N{ASTERISK}> is another way of writing C<*>, valid in both
double-quoted strings and regular expression patterns.  In patterns,
it doesn't have the meaning an unescaped C<*> does.

Starting in Perl 5.12.0, C<\N> also can have an additional meaning (only)
in patterns, namely to match a non-newline character.  (This is short
for C<[^\n]>, and like C<.> but is not affected by the C</s> regex modifier.)

This can lead to some ambiguities.  When C<\N> is not followed immediately
by a left brace, Perl assumes the C<[^\n]> meaning.  Also, if the braces
form a valid quantifier such as C<\N{3}> or C<\N{5,}>, Perl assumes that this
means to match the given quantity of non-newlines (in these examples,
3; and 5 or more, respectively).  In all other case, where there is a
C<\N{> and a matching C<}>, Perl assumes that a character name is desired.

However, if there is no matching C<}>, Perl doesn't know if it was
mistakenly omitted, or if C<[^\n]{> was desired, and raises this error.
If you meant the former, add the right brace; if you meant the latter,
escape the brace with a backslash, like so: C<\N\{>

=item Missing right curly or square bracket

(F) The lexer counted more opening curly or square brackets than closing
ones.  As a general rule, you'll find it's missing near the place you
were last editing.

=item (Missing semicolon on previous line?)

(S syntax) This is an educated guess made in conjunction with the message
"%s found where operator expected".  Don't automatically put a semicolon on
the previous line just because you saw this message.

=item Modification of a read-only value attempted

(F) You tried, directly or indirectly, to change the value of a
constant.  You didn't, of course, try "2 = 1", because the compiler
catches that.  But an easy way to do the same thing is:

    sub mod { $_[0] = 1 }
    mod(2);

Another way is to assign to a substr() that's off the end of the string.

Yet another way is to assign to a C<foreach> loop I<VAR> when I<VAR>
is aliased to a constant in the look I<LIST>:

    $x = 1;
    foreach my $n ($x, 2) {
        $n *= 2; # modifies the $x, but fails on attempt to
    }            # modify the 2

=item Modification of non-creatable array value attempted, %s

(F) You tried to make an array value spring into existence, and the
subscript was probably negative, even counting from end of the array
backwards.

=item Modification of non-creatable hash value attempted, %s

(P) You tried to make a hash value spring into existence, and it
couldn't be created for some peculiar reason.

=item Module name must be constant

(F) Only a bare module name is allowed as the first argument to a "use".

=item Module name required with -%c option

(F) The C<-M> or C<-m> options say that Perl should load some module, but
you omitted the name of the module.  Consult L<perlrun> for full details
about C<-M> and C<-m>.

=item More than one argument to '%s' open

(F) The C<open> function has been asked to open multiple files.  This
can happen if you are trying to open a pipe to a command that takes a
list of arguments, but have forgotten to specify a piped open mode.
See L<perlfunc/open> for details.

=item mprotect for COW string %p %u failed with %d

(S) You compiled perl with B<-D>PERL_DEBUG_READONLY_COW (see
L<perlguts/"Copy on Write">), but a shared string buffer
could not be made read-only.

=item mprotect for %p %u failed with %d

(S) You compiled perl with B<-D>PERL_DEBUG_READONLY_OPS (see L<perlhacktips>),
but an op tree could not be made read-only.

=item mprotect RW for COW string %p %u failed with %d

(S) You compiled perl with B<-D>PERL_DEBUG_READONLY_COW (see
L<perlguts/"Copy on Write">), but a read-only shared string
buffer could not be made mutable.

=item mprotect RW for %p %u failed with %d

(S) You compiled perl with B<-D>PERL_DEBUG_READONLY_OPS (see
L<perlhacktips>), but a read-only op tree could not be made
mutable before freeing the ops.

=item msg%s not implemented

(F) You don't have System V message IPC on your system.

=item Multidimensional syntax %s not supported

(W syntax) Multidimensional arrays aren't written like C<$foo[1,2,3]>.
They're written like C<$foo[1][2][3]>, as in C.

=item '/' must follow a numeric type in unpack

(F) You had an unpack template that contained a '/', but this did not
follow some unpack specification producing a numeric value.
See L<perlfunc/pack>.

=item %s must not be a named sequence in transliteration operator

(F) Transliteration (C<tr///> and C<y///>) transliterates individual
characters.  But a named sequence by definition is more than an
individual charater, and hence doing this operation on it doesn't make
sense.

=item "my sub" not yet implemented

(F) Lexically scoped subroutines are not yet implemented.  Don't try
that yet.

=item "my" subroutine %s can't be in a package

(F) Lexically scoped subroutines aren't in a package, so it doesn't make
sense to try to declare one with a package qualifier on the front.

=item "my %s" used in sort comparison

(W syntax) The package variables $a and $b are used for sort comparisons.
You used $a or $b in as an operand to the C<< <=> >> or C<cmp> operator inside a
sort comparison block, and the variable had earlier been declared as a
lexical variable.  Either qualify the sort variable with the package
name, or rename the lexical variable.

=item "my" variable %s can't be in a package

(F) Lexically scoped variables aren't in a package, so it doesn't make
sense to try to declare one with a package qualifier on the front.  Use
local() if you want to localize a package variable.

=item Name "%s::%s" used only once: possible typo

(W once) Typographical errors often show up as unique variable
names.  If you had a good reason for having a unique name, then
just mention it again somehow to suppress the message.  The C<our>
declaration is also provided for this purpose.

NOTE: This warning detects package symbols that have been used
only once.  This means lexical variables will never trigger this
warning.  It also means that all of the package variables $c, @@c,
%c, as well as *c, &c, sub c{}, c(), and c (the filehandle or
format) are considered the same; if a program uses $c only once
but also uses any of the others it will not trigger this warning.
Symbols beginning with an underscore and symbols using special
identifiers (q.v. L<perldata>) are exempt from this warning.

=item Need exactly 3 octal digits in regex; marked by S<<-- HERE> in m/%s/

(F) Within S<C<(?[   ])>>, all constants interpreted as octal need to be
exactly 3 digits long.  This helps catch some ambiguities.  If your
constant is too short, add leading zeros, like

 (?[ [ \078 ] ])     # Syntax error!
 (?[ [ \0078 ] ])    # Works
 (?[ [ \007 8 ] ])   # Clearer

The maximum number this construct can express is C<\777>.  If you
need a larger one, you need to use L<\o{}|perlrebackslash/Octal escapes> instead.  If you meant
two separate things, you need to separate them:

 (?[ [ \7776 ] ])        # Syntax error!
 (?[ [ \o{7776} ] ])     # One meaning
 (?[ [ \777 6 ] ])       # Another meaning
 (?[ [ \777 \006 ] ])    # Still another

=item Negative '/' count in unpack

(F) The length count obtained from a length/code unpack operation was
negative.  See L<perlfunc/pack>.

=item Negative length

(F) You tried to do a read/write/send/recv operation with a buffer
length that is less than 0.  This is difficult to imagine.

=item Negative offset to vec in lvalue context

(F) When C<vec> is called in an lvalue context, the second argument must be
greater than or equal to zero.

=item Negative repeat count does nothing

(W numeric) You tried to execute the
L<C<x>|perlop/Multiplicative Operators> repetition operator fewer than 0
times, which doesn't make sense.

=item Nested quantifiers in regex; marked by S<<-- HERE> in m/%s/

(F) You can't quantify a quantifier without intervening parentheses.
So things like ** or +* or ?* are illegal.  The S<<-- HERE> shows
whereabouts in the regular expression the problem was discovered.

Note that the minimal matching quantifiers, C<*?>, C<+?>, and
C<??> appear to be nested quantifiers, but aren't.  See L<perlre>.

=item %s never introduced

(S internal) The symbol in question was declared but somehow went out of
scope before it could possibly have been used.

=item next::method/next::can/maybe::next::method cannot find enclosing method

(F) C<next::method> needs to be called within the context of a
real method in a real package, and it could not find such a context.
See L<mro>.

=item \N in a character class must be a named character: \N{...} in regex; 
marked by S<<-- HERE> in m/%s/

(F) The new (as of Perl 5.12) meaning of C<\N> as C<[^\n]> is not valid in a
bracketed character class, for the same reason that C<.> in a character
class loses its specialness: it matches almost everything, which is
probably not what you want.

=item \N{} in inverted character class or as a range end-point is restricted to one character in regex; marked by <-- HERE in m/%s/

(F) Named Unicode character escapes (C<\N{...}>) may return a
multi-character sequence.  Even though a character class is
supposed to match just one character of input, perl will match the
whole thing correctly, except when the class is inverted (C<[^...]>),
or the escape is the beginning or final end point of a range.  The
mathematically logical behavior for what matches when inverting
is very different from what people expect, so we have decided to
forbid it.  Similarly unclear is what should be generated when the
C<\N{...}> is used as one of the end points of the range, such as in

 [\x{41}-\N{ARABIC SEQUENCE YEH WITH HAMZA ABOVE WITH AE}]

What is meant here is unclear, as the C<\N{...}> escape is a sequence
of code points, so this is made an error.

=item \N{NAME} must be resolved by the lexer in regex; marked by
S<<-- HERE> in m/%s/

(F) When compiling a regex pattern, an unresolved named character or
sequence was encountered.  This can happen in any of several ways that
bypass the lexer, such as using single-quotish context, or an extra
backslash in double-quotish:

    $re = '\N{SPACE}';	# Wrong!
    $re = "\\N{SPACE}";	# Wrong!
    /$re/;

Instead, use double-quotes with a single backslash:

    $re = "\N{SPACE}";	# ok
    /$re/;

The lexer can be bypassed as well by creating the pattern from smaller
components:

    $re = '\N';
    /${re}{SPACE}/;	# Wrong!

It's not a good idea to split a construct in the middle like this, and
it doesn't work here.  Instead use the solution above.

Finally, the message also can happen under the C</x> regex modifier when the
C<\N> is separated by spaces from the C<{>, in which case, remove the spaces.

    /\N {SPACE}/x;	# Wrong!
    /\N{SPACE}/x;	# ok

=item No %s allowed while running setuid

(F) Certain operations are deemed to be too insecure for a setuid or
setgid script to even be allowed to attempt.  Generally speaking there
will be another way to do what you want that is, if not secure, at least
securable.  See L<perlsec>.

=item NO-BREAK SPACE in a charnames alias definition is deprecated

(D deprecated) You defined a character name which contained a no-break
space character.  Change it to a regular space.  Usually these names are
defined in the C<:alias> import argument to C<use charnames>, but they
could be defined by a translator installed into C<$^H{charnames}>.  See
L<charnames/CUSTOM ALIASES>.

=item No code specified for -%c

(F) Perl's B<-e> and B<-E> command-line options require an argument.  If
you want to run an empty program, pass the empty string as a separate
argument or run a program consisting of a single 0 or 1:

    perl -e ""
    perl -e0
    perl -e1

=item No comma allowed after %s

(F) A list operator that has a filehandle or "indirect object" is
not allowed to have a comma between that and the following arguments.
Otherwise it'd be just another one of the arguments.

One possible cause for this is that you expected to have imported
a constant to your name space with B<use> or B<import> while no such
importing took place, it may for example be that your operating
system does not support that particular constant.  Hopefully you did
use an explicit import list for the constants you expect to see;
please see L<perlfunc/use> and L<perlfunc/import>.  While an
explicit import list would probably have caught this error earlier
it naturally does not remedy the fact that your operating system
still does not support that constant.  Maybe you have a typo in
the constants of the symbol import list of B<use> or B<import> or in the
constant name at the line where this error was triggered?

=item No command into which to pipe on command line

(F) An error peculiar to VMS.  Perl handles its own command line
redirection, and found a '|' at the end of the command line, so it
doesn't know where you want to pipe the output from this command.

=item No DB::DB routine defined

(F) The currently executing code was compiled with the B<-d> switch, but
for some reason the current debugger (e.g. F<perl5db.pl> or a C<Devel::>
module) didn't define a routine to be called at the beginning of each
statement.

=item No dbm on this machine

(P) This is counted as an internal error, because every machine should
supply dbm nowadays, because Perl comes with SDBM.  See L<SDBM_File>.

=item No DB::sub routine defined

(F) The currently executing code was compiled with the B<-d> switch, but
for some reason the current debugger (e.g. F<perl5db.pl> or a C<Devel::>
module) didn't define a C<DB::sub> routine to be called at the beginning
of each ordinary subroutine call.

=item No directory specified for -I

(F) The B<-I> command-line switch requires a directory name as part of the
I<same> argument.  Use B<-Ilib>, for instance.  B<-I lib> won't work.

=item No error file after 2> or 2>> on command line

(F) An error peculiar to VMS.  Perl handles its own command line
redirection, and found a '2>' or a '2>>' on the command line, but can't
find the name of the file to which to write data destined for stderr.

=item No group ending character '%c' found in template

(F) A pack or unpack template has an opening '(' or '[' without its
matching counterpart.  See L<perlfunc/pack>.

=item No input file after < on command line

(F) An error peculiar to VMS.  Perl handles its own command line
redirection, and found a '<' on the command line, but can't find the
name of the file from which to read data for stdin.

=item No next::method '%s' found for %s

(F) C<next::method> found no further instances of this method name
in the remaining packages of the MRO of this class.  If you don't want
it throwing an exception, use C<maybe::next::method>
or C<next::can>.  See L<mro>.

=item Non-finite repeat count does nothing

(W numeric) You tried to execute the
L<C<x>|perlop/Multiplicative Operators> repetition operator C<Inf> (or
C<-Inf>) or C<NaN> times, which doesn't make sense.

=item Non-hex character in regex; marked by S<<-- HERE> in m/%s/

(F) In a regular expression, there was a non-hexadecimal character where
a hex one was expected, like

 (?[ [ \xDG ] ])
 (?[ [ \x{DEKA} ] ])

=item Non-octal character in regex; marked by S<<-- HERE> in m/%s/

(F) In a regular expression, there was a non-octal character where
an octal one was expected, like

 (?[ [ \o{1278} ] ])

=item Non-octal character '%c'.  Resolved as "%s"

(W digit) In parsing an octal numeric constant, a character was
unexpectedly encountered that isn't octal.  The resulting value
is as indicated.

=item "no" not allowed in expression

(F) The "no" keyword is recognized and executed at compile time, and
returns no useful value.  See L<perlmod>.

=item Non-string passed as bitmask

(W misc) A number has been passed as a bitmask argument to select().
Use the vec() function to construct the file descriptor bitmasks for
select.  See L<perlfunc/select>.

=item No output file after > on command line

(F) An error peculiar to VMS.  Perl handles its own command line
redirection, and found a lone '>' at the end of the command line, so it
doesn't know where you wanted to redirect stdout.

=item No output file after > or >> on command line

(F) An error peculiar to VMS.  Perl handles its own command line
redirection, and found a '>' or a '>>' on the command line, but can't
find the name of the file to which to write data destined for stdout.

=item No package name allowed for variable %s in "our"

(F) Fully qualified variable names are not allowed in "our"
declarations, because that doesn't make much sense under existing
rules.  Such syntax is reserved for future extensions.

=item No Perl script found in input

(F) You called C<perl -x>, but no line was found in the file beginning
with #! and containing the word "perl".

=item No setregid available

(F) Configure didn't find anything resembling the setregid() call for
your system.

=item No setreuid available

(F) Configure didn't find anything resembling the setreuid() call for
your system.

=item No such class %s

(F) You provided a class qualifier in a "my", "our" or "state"
declaration, but this class doesn't exist at this point in your program.

=item No such class field "%s" in variable %s of type %s

(F) You tried to access a key from a hash through the indicated typed
variable but that key is not allowed by the package of the same type.
The indicated package has restricted the set of allowed keys using the
L<fields> pragma.

=item No such hook: %s

(F) You specified a signal hook that was not recognized by Perl.
Currently, Perl accepts C<__DIE__> and C<__WARN__> as valid signal hooks.

=item No such pipe open

(P) An error peculiar to VMS.  The internal routine my_pclose() tried to
close a pipe which hadn't been opened.  This should have been caught
earlier as an attempt to close an unopened filehandle.

=item No such signal: SIG%s

(W signal) You specified a signal name as a subscript to %SIG that was
not recognized.  Say C<kill -l> in your shell to see the valid signal
names on your system.

=item Not a CODE reference

(F) Perl was trying to evaluate a reference to a code value (that is, a
subroutine), but found a reference to something else instead.  You can
use the ref() function to find out what kind of ref it really was.  See
also L<perlref>.

=item Not a GLOB reference

(F) Perl was trying to evaluate a reference to a "typeglob" (that is, a
symbol table entry that looks like C<*foo>), but found a reference to
something else instead.  You can use the ref() function to find out what
kind of ref it really was.  See L<perlref>.

=item Not a HASH reference

(F) Perl was trying to evaluate a reference to a hash value, but found a
reference to something else instead.  You can use the ref() function to
find out what kind of ref it really was.  See L<perlref>.

=item Not an ARRAY reference

(F) Perl was trying to evaluate a reference to an array value, but found
a reference to something else instead.  You can use the ref() function
to find out what kind of ref it really was.  See L<perlref>.

=item Not an unblessed ARRAY reference

(F) You passed a reference to a blessed array to C<push>, C<shift> or
another array function.  These only accept unblessed array references
or arrays beginning explicitly with C<@@>.

=item Not a SCALAR reference

(F) Perl was trying to evaluate a reference to a scalar value, but found
a reference to something else instead.  You can use the ref() function
to find out what kind of ref it really was.  See L<perlref>.

=item Not a subroutine reference

(F) Perl was trying to evaluate a reference to a code value (that is, a
subroutine), but found a reference to something else instead.  You can
use the ref() function to find out what kind of ref it really was.  See
also L<perlref>.

=item Not a subroutine reference in overload table

(F) An attempt was made to specify an entry in an overloading table that
doesn't somehow point to a valid subroutine.  See L<overload>.

=item Not enough arguments for %s

(F) The function requires more arguments than you specified.

=item Not enough format arguments

(W syntax) A format specified more picture fields than the next line
supplied.  See L<perlform>.

=item %s: not found

(A) You've accidentally run your script through the Bourne shell instead
of Perl.  Check the #! line, or manually feed your script into Perl
yourself.

=item (?[...]) not valid in locale in regex; marked by S<<-- HERE> in m/%s/

(F) C<(?[...])> cannot be used within the scope of a C<S<use locale>> or with
an C</l> regular expression modifier, as that would require deferring
to run-time the calculation of what it should evaluate to, and it is
regex compile-time only.

=item no UTC offset information; assuming local time is UTC

(S) A warning peculiar to VMS.  Perl was unable to find the local
timezone offset, so it's assuming that local system time is equivalent
to UTC.  If it's not, define the logical name
F<SYS$TIMEZONE_DIFFERENTIAL> to translate to the number of seconds which
need to be added to UTC to get local time.

=item NULL OP IN RUN

(S debugging) Some internal routine called run() with a null opcode
pointer.

=item Null picture in formline

(F) The first argument to formline must be a valid format picture
specification.  It was found to be empty, which probably means you
supplied it an uninitialized value.  See L<perlform>.

=item Null realloc

(P) An attempt was made to realloc NULL.

=item NULL regexp argument

(P) The internal pattern matching routines blew it big time.

=item NULL regexp parameter

(P) The internal pattern matching routines are out of their gourd.

=item Number too long

(F) Perl limits the representation of decimal numbers in programs to
about 250 characters.  You've exceeded that length.  Future
versions of Perl are likely to eliminate this arbitrary limitation.  In
the meantime, try using scientific notation (e.g. "1e6" instead of
"1_000_000").

=item Number with no digits

(F) Perl was looking for a number but found nothing that looked like
a number.  This happens, for example with C<\o{}>, with no number between
the braces.

=item Octal number > 037777777777 non-portable

(W portable) The octal number you specified is larger than 2**32-1
(4294967295) and therefore non-portable between systems.  See
L<perlport> for more on portability concerns.

=item Odd name/value argument for subroutine

(F) A subroutine using a slurpy hash parameter in its signature
received an odd number of arguments to populate the hash.  It requires
the arguments to be paired, with the same number of keys as values.
The caller of the subroutine is presumably at fault.  Inconveniently,
this error will be reported at the location of the subroutine, not that
of the caller.

=item Odd number of arguments for overload::constant

(W overload) The call to overload::constant contained an odd number of
arguments.  The arguments should come in pairs.

=item Odd number of elements in anonymous hash

(W misc) You specified an odd number of elements to initialize a hash,
which is odd, because hashes come in key/value pairs.

=item Odd number of elements in hash assignment

(W misc) You specified an odd number of elements to initialize a hash,
which is odd, because hashes come in key/value pairs.

=item Offset outside string

(F)(W layer) You tried to do a read/write/send/recv/seek operation
with an offset pointing outside the buffer.  This is difficult to
imagine.  The sole exceptions to this are that zero padding will
take place when going past the end of the string when either
C<sysread()>ing a file, or when seeking past the end of a scalar opened
for I/O (in anticipation of future reads and to imitate the behavior
with real files).

=item %s() on unopened %s

(W unopened) An I/O operation was attempted on a filehandle that was
never initialized.  You need to do an open(), a sysopen(), or a socket()
call, or call a constructor from the FileHandle package.

=item -%s on unopened filehandle %s

(W unopened) You tried to invoke a file test operator on a filehandle
that isn't open.  Check your control flow.  See also L<perlfunc/-X>.

=item oops: oopsAV

(S internal) An internal warning that the grammar is screwed up.

=item oops: oopsHV

(S internal) An internal warning that the grammar is screwed up.

=item Opening dirhandle %s also as a file

(D io, deprecated) You used open() to associate a filehandle to
a symbol (glob or scalar) that already holds a dirhandle.
Although legal, this idiom might render your code confusing
and is deprecated.

=item Opening filehandle %s also as a directory

(D io, deprecated) You used opendir() to associate a dirhandle to
a symbol (glob or scalar) that already holds a filehandle.
Although legal, this idiom might render your code confusing
and is deprecated.

=item Operand with no preceding operator in regex; marked by S<<-- HERE> in
m/%s/

(F) You wrote something like

 (?[ \p{Digit} \p{Thai} ])

There are two operands, but no operator giving how you want to combine
them.

=item Operation "%s": no method found, %s

(F) An attempt was made to perform an overloaded operation for which no
handler was defined.  While some handlers can be autogenerated in terms
of other handlers, there is no default handler for any operation, unless
the C<fallback> overloading key is specified to be true.  See L<overload>.

=item Operation "%s" returns its argument for non-Unicode code point 0x%X

(S non_unicode) You performed an operation requiring Unicode rules
on a code point that is not in Unicode, so what it should do is not
defined.  Perl has chosen to have it do nothing, and warn you.

If the operation shown is "ToFold", it means that case-insensitive
matching in a regular expression was done on the code point.

If you know what you are doing you can turn off this warning by
C<no warnings 'non_unicode';>.

=item Operation "%s" returns its argument for UTF-16 surrogate U+%X

(S surrogate) You performed an operation requiring Unicode
rules on a Unicode surrogate.  Unicode frowns upon the use
of surrogates for anything but storing strings in UTF-16, but
rules are (reluctantly) defined for the surrogates, and
they are to do nothing for this operation.  Because the use of
surrogates can be dangerous, Perl warns.

If the operation shown is "ToFold", it means that case-insensitive
matching in a regular expression was done on the code point.

If you know what you are doing you can turn off this warning by
C<no warnings 'surrogate';>.

=item Operator or semicolon missing before %s

(S ambiguous) You used a variable or subroutine call where the parser
was expecting an operator.  The parser has assumed you really meant to
use an operator, but this is highly likely to be incorrect.  For
example, if you say "*foo *foo" it will be interpreted as if you said
"*foo * 'foo'".

=item Optional parameter lacks default expression

(F) In a subroutine signature, you wrote something like "$a =", making a
named optional parameter without a default value.  A nameless optional
parameter is permitted to have no default value, but a named one must
have a specific default.  You probably want "$a = undef".

=item "our" variable %s redeclared

(W misc) You seem to have already declared the same global once before
in the current lexical scope.

=item Out of memory!

(X) The malloc() function returned 0, indicating there was insufficient
remaining memory (or virtual memory) to satisfy the request.  Perl has
no option but to exit immediately.

At least in Unix you may be able to get past this by increasing your
process datasize limits: in csh/tcsh use C<limit> and
C<limit datasize n> (where C<n> is the number of kilobytes) to check
the current limits and change them, and in ksh/bash/zsh use C<ulimit -a>
and C<ulimit -d n>, respectively.

=item Out of memory during %s extend

(X) An attempt was made to extend an array, a list, or a string beyond
the largest possible memory allocation.

=item Out of memory during "large" request for %s

(F) The malloc() function returned 0, indicating there was insufficient
remaining memory (or virtual memory) to satisfy the request.  However,
the request was judged large enough (compile-time default is 64K), so a
possibility to shut down by trapping this error is granted.

=item Out of memory during request for %s

(X)(F) The malloc() function returned 0, indicating there was
insufficient remaining memory (or virtual memory) to satisfy the
request.

The request was judged to be small, so the possibility to trap it
depends on the way perl was compiled.  By default it is not trappable.
However, if compiled for this, Perl may use the contents of C<$^M> as an
emergency pool after die()ing with this message.  In this case the error
is trappable I<once>, and the error message will include the line and file
where the failed request happened.

=item Out of memory during ridiculously large request

(F) You can't allocate more than 2^31+"small amount" bytes.  This error
is most likely to be caused by a typo in the Perl program. e.g.,
C<$arr[time]> instead of C<$arr[$time]>.

=item Out of memory for yacc stack

(F) The yacc parser wanted to grow its stack so it could continue
parsing, but realloc() wouldn't give it more memory, virtual or
otherwise.

=item '.' outside of string in pack

(F) The argument to a '.' in your template tried to move the working
position to before the start of the packed string being built.

=item '@@' outside of string in unpack

(F) You had a template that specified an absolute position outside
the string being unpacked.  See L<perlfunc/pack>.

=item '@@' outside of string with malformed UTF-8 in unpack

(F) You had a template that specified an absolute position outside
the string being unpacked.  The string being unpacked was also invalid
UTF-8.  See L<perlfunc/pack>.

=item overload arg '%s' is invalid

(W overload) The L<overload> pragma was passed an argument it did not
recognize.  Did you mistype an operator?

=item Overloaded dereference did not return a reference

(F) An object with an overloaded dereference operator was dereferenced,
but the overloaded operation did not return a reference.  See
L<overload>.

=item Overloaded qr did not return a REGEXP

(F) An object with a C<qr> overload was used as part of a match, but the
overloaded operation didn't return a compiled regexp.  See L<overload>.

=item %s package attribute may clash with future reserved word: %s

(W reserved) A lowercase attribute name was used that had a
package-specific handler.  That name might have a meaning to Perl itself
some day, even though it doesn't yet.  Perhaps you should use a
mixed-case attribute name, instead.  See L<attributes>.

=item pack/unpack repeat count overflow

(F) You can't specify a repeat count so large that it overflows your
signed integers.  See L<perlfunc/pack>.

=item page overflow

(W io) A single call to write() produced more lines than can fit on a
page.  See L<perlform>.

=item panic: %s

(P) An internal error.

=item panic: attempt to call %s in %s

(P) One of the file test operators entered a code branch that calls
an ACL related-function, but that function is not available on this
platform.  Earlier checks mean that it should not be possible to
enter this branch on this platform.

=item panic: child pseudo-process was never scheduled

(P) A child pseudo-process in the ithreads implementation on Windows
was not scheduled within the time period allowed and therefore was not
able to initialize properly.

=item panic: ck_grep, type=%u

(P) Failed an internal consistency check trying to compile a grep.

=item panic: ck_split, type=%u

(P) Failed an internal consistency check trying to compile a split.

=item panic: corrupt saved stack index %ld

(P) The savestack was requested to restore more localized values than
there are in the savestack.

=item panic: del_backref

(P) Failed an internal consistency check while trying to reset a weak
reference.

=item panic: do_subst

(P) The internal pp_subst() routine was called with invalid operational
data.

=item panic: do_trans_%s

(P) The internal do_trans routines were called with invalid operational
data.

=item panic: fold_constants JMPENV_PUSH returned %d

(P) While attempting folding constants an exception other than an C<eval>
failure was caught.

=item panic: frexp: %f

(P) The library function frexp() failed, making printf("%f") impossible.

=item panic: goto, type=%u, ix=%ld

(P) We popped the context stack to a context with the specified label,
and then discovered it wasn't a context we know how to do a goto in.

=item panic: gp_free failed to free glob pointer

(P) The internal routine used to clear a typeglob's entries tried
repeatedly, but each time something re-created entries in the glob.
Most likely the glob contains an object with a reference back to
the glob and a destructor that adds a new object to the glob.

=item panic: INTERPCASEMOD, %s

(P) The lexer got into a bad state at a case modifier.

=item panic: INTERPCONCAT, %s

(P) The lexer got into a bad state parsing a string with brackets.

=item panic: kid popen errno read

(F) A forked child returned an incomprehensible message about its errno.

=item panic: last, type=%u

(P) We popped the context stack to a block context, and then discovered
it wasn't a block context.

=item panic: leave_scope clearsv

(P) A writable lexical variable became read-only somehow within the
scope.

=item panic: leave_scope inconsistency %u

(P) The savestack probably got out of sync.  At least, there was an
invalid enum on the top of it.

=item panic: magic_killbackrefs

(P) Failed an internal consistency check while trying to reset all weak
references to an object.

=item panic: malloc, %s

(P) Something requested a negative number of bytes of malloc.

=item panic: memory wrap

(P) Something tried to allocate either more memory than possible or a
negative amount.

=item panic: pad_alloc, %p!=%p

(P) The compiler got confused about which scratch pad it was allocating
and freeing temporaries and lexicals from.

=item panic: pad_free curpad, %p!=%p

(P) The compiler got confused about which scratch pad it was allocating
and freeing temporaries and lexicals from.

=item panic: pad_free po

(P) A zero scratch pad offset was detected internally.  An attempt was
made to free a target that had not been allocated to begin with.

=item panic: pad_reset curpad, %p!=%p

(P) The compiler got confused about which scratch pad it was allocating
and freeing temporaries and lexicals from.

=item panic: pad_sv po

(P) A zero scratch pad offset was detected internally.  Most likely
an operator needed a target but that target had not been allocated
for whatever reason.

=item panic: pad_swipe curpad, %p!=%p

(P) The compiler got confused about which scratch pad it was allocating
and freeing temporaries and lexicals from.

=item panic: pad_swipe po

(P) An invalid scratch pad offset was detected internally.

=item panic: pp_iter, type=%u

(P) The foreach iterator got called in a non-loop context frame.

=item panic: pp_match%s

(P) The internal pp_match() routine was called with invalid operational
data.

=item panic: pp_split, pm=%p, s=%p

(P) Something terrible went wrong in setting up for the split.

=item panic: realloc, %s

(P) Something requested a negative number of bytes of realloc.

=item panic: reference miscount on nsv in sv_replace() (%d != 1)

(P) The internal sv_replace() function was handed a new SV with a
reference count other than 1.

=item panic: restartop in %s

(P) Some internal routine requested a goto (or something like it), and
didn't supply the destination.

=item panic: return, type=%u

(P) We popped the context stack to a subroutine or eval context, and
then discovered it wasn't a subroutine or eval context.

=item panic: scan_num, %s

(P) scan_num() got called on something that wasn't a number.

=item panic: Sequence (?{...}): no code block found in regex m/%s/

(P) While compiling a pattern that has embedded (?{}) or (??{}) code
blocks, perl couldn't locate the code block that should have already been
seen and compiled by perl before control passed to the regex compiler.

=item panic: strxfrm() gets absurd - a => %u, ab => %u

(P) The interpreter's sanity check of the C function strxfrm() failed.
In your current locale the returned transformation of the string "ab"
is shorter than that of the string "a", which makes no sense.

=item panic: sv_chop %s

(P) The sv_chop() routine was passed a position that is not within the
scalar's string buffer.

=item panic: sv_insert, midend=%p, bigend=%p

(P) The sv_insert() routine was told to remove more string than there
was string.

=item panic: top_env

(P) The compiler attempted to do a goto, or something weird like that.

=item panic: unimplemented op %s (#%d) called

(P) The compiler is screwed up and attempted to use an op that isn't
permitted at run time.

=item panic: utf16_to_utf8: odd bytelen

(P) Something tried to call utf16_to_utf8 with an odd (as opposed
to even) byte length.

=item panic: utf16_to_utf8_reversed: odd bytelen

(P) Something tried to call utf16_to_utf8_reversed with an odd (as opposed
to even) byte length.

=item panic: yylex, %s

(P) The lexer got into a bad state while processing a case modifier.

=item Parentheses missing around "%s" list

(W parenthesis) You said something like

    my $foo, $bar = @@_;

when you meant

    my ($foo, $bar) = @@_;

Remember that "my", "our", "local" and "state" bind tighter than comma.

=item Parsing code internal error (%s)

(F) Parsing code supplied by an extension violated the parser's API in
a detectable way.

=item Passing malformed UTF-8 to "%s" is deprecated

(D deprecated, utf8) This message indicates a bug either in the Perl
core or in XS code.  Such code was trying to find out if a character,
allegedly stored internally encoded as UTF-8, was of a given type, such
as being punctuation or a digit.  But the character was not encoded in
legal UTF-8.  The C<%s> is replaced by a string that can be used by
knowledgeable people to determine what the type being checked against
was.  If C<utf8> warnings are enabled, a further message is raised,
giving details of the malformation.

=item Pattern subroutine nesting without pos change exceeded limit in regex

(F) You used a pattern that uses too many nested subpattern calls without
consuming any text.  Restructure the pattern so text is consumed before
the nesting limit is exceeded.

=item C<-p> destination: %s

(F) An error occurred during the implicit output invoked by the C<-p>
command-line switch.  (This output goes to STDOUT unless you've
redirected it with select().)

=item Perl API version %s of %s does not match %s

(F) The XS module in question was compiled against a different incompatible
version of Perl than the one that has loaded the XS module.

=item Perl folding rules are not up-to-date for 0x%X; please use the perlbug
utility to report; in regex; marked by S<<-- HERE> in m/%s/

(S regexp) You used a regular expression with case-insensitive matching,
and there is a bug in Perl in which the built-in regular expression
folding rules are not accurate.  This may lead to incorrect results.
Please report this as a bug using the L<perlbug> utility.

=item PerlIO layer ':win32' is experimental

(S experimental::win32_perlio) The C<:win32> PerlIO layer is
experimental.  If you want to take the risk of using this layer,
simply disable this warning:

    no warnings "experimental::win32_perlio";

=item Perl_my_%s() not available

(F) Your platform has very uncommon byte-order and integer size,
so it was not possible to set up some or all fixed-width byte-order
conversion functions.  This is only a problem when you're using the
'<' or '>' modifiers in (un)pack templates.  See L<perlfunc/pack>.

=item Perl %s required (did you mean %s?)--this is only %s, stopped

(F) The code you are trying to run has asked for a newer version of
Perl than you are running.  Perhaps C<use 5.10> was written instead
of C<use 5.010> or C<use v5.10>.  Without the leading C<v>, the number is
interpreted as a decimal, with every three digits after the
decimal point representing a part of the version number.  So 5.10
is equivalent to v5.100.

=item Perl %s required--this is only %s, stopped

(F) The module in question uses features of a version of Perl more
recent than the currently running version.  How long has it been since
you upgraded, anyway?  See L<perlfunc/require>.

=item PERL_SH_DIR too long

(F) An error peculiar to OS/2.  PERL_SH_DIR is the directory to find the
C<sh>-shell in.  See "PERL_SH_DIR" in L<perlos2>.

=item PERL_SIGNALS illegal: "%s"

(X) See L<perlrun/PERL_SIGNALS> for legal values.

=item Perls since %s too modern--this is %s, stopped

(F) The code you are trying to run claims it will not run
on the version of Perl you are using because it is too new.
Maybe the code needs to be updated, or maybe it is simply
wrong and the version check should just be removed.

=item perl: warning: Non hex character in '$ENV{PERL_HASH_SEED}', seed only partially set

(S) PERL_HASH_SEED should match /^\s*(?:0x)?[0-9a-fA-F]+\s*\z/ but it
contained a non hex character.  This could mean you are not using the
hash seed you think you are.

=item perl: warning: Setting locale failed.

(S) The whole warning message will look something like:

	perl: warning: Setting locale failed.
	perl: warning: Please check that your locale settings:
	        LC_ALL = "En_US",
	        LANG = (unset)
	    are supported and installed on your system.
	perl: warning: Falling back to the standard locale ("C").

Exactly what were the failed locale settings varies.  In the above the
settings were that the LC_ALL was "En_US" and the LANG had no value.
This error means that Perl detected that you and/or your operating
system supplier and/or system administrator have set up the so-called
locale system but Perl could not use those settings.  This was not
dead serious, fortunately: there is a "default locale" called "C" that
Perl can and will use, and the script will be run.  Before you really
fix the problem, however, you will get the same error message each
time you run Perl.  How to really fix the problem can be found in
L<perllocale> section B<LOCALE PROBLEMS>.

=item perl: warning: strange setting in '$ENV{PERL_PERTURB_KEYS}': '%s'

(S) Perl was run with the environment variable PERL_PERTURB_KEYS defined
but containing an unexpected value.  The legal values of this setting
are as follows.

  Numeric | String        | Result
  --------+---------------+-----------------------------------------
  0       | NO            | Disables key traversal randomization
  1       | RANDOM        | Enables full key traversal randomization
  2       | DETERMINISTIC | Enables repeatable key traversal
          |               | randomization

Both numeric and string values are accepted, but note that string values are
case sensitive.  The default for this setting is "RANDOM" or 1.

=item pid %x not a child

(W exec) A warning peculiar to VMS.  Waitpid() was asked to wait for a
process which isn't a subprocess of the current process.  While this is
fine from VMS' perspective, it's probably not what you intended.

=item 'P' must have an explicit size in unpack

(F) The unpack format P must have an explicit size, not "*".

=item POSIX class [:%s:] unknown in regex; marked by S<<-- HERE> in m/%s/

(F) The class in the character class [: :] syntax is unknown.  The S<<-- HERE>
shows whereabouts in the regular expression the problem was discovered.
Note that the POSIX character classes do B<not> have the C<is> prefix
the corresponding C interfaces have: in other words, it's C<[[:print:]]>,
not C<isprint>.  See L<perlre>.

=item POSIX getpgrp can't take an argument

(F) Your system has POSIX getpgrp(), which takes no argument, unlike
the BSD version, which takes a pid.

=item POSIX syntax [%c %c] belongs inside character classes%s in regex; marked by
S<<-- HERE> in m/%s/

(W regexp) Perl thinks that you intended to write a POSIX character
class, but didn't use enough brackets.  These POSIX class constructs [:
:], [= =], and [. .]  go I<inside> character classes, the [] are part of
the construct, for example: C<qr/[012[:alpha:]345]/>.  What the regular
expression pattern compiled to is probably not what you were intending.
For example, C<qr/[:alpha:]/> compiles to a regular bracketed character
class consisting of the four characters C<":">,  C<"a">,  C<"l">,
C<"h">, and C<"p">.  To specify the POSIX class, it should have been
written C<qr/[[:alpha:]]/>.

Note that [= =] and [. .] are not currently
implemented; they are simply placeholders for future extensions and
will cause fatal errors.  The S<<-- HERE> shows whereabouts in the regular
expression the problem was discovered.  See L<perlre>.

If the specification of the class was not completely valid, the message
indicates that.

=item POSIX syntax [. .] is reserved for future extensions in regex; marked by 
S<<-- HERE> in m/%s/

(F) Within regular expression character classes ([]) the syntax beginning
with "[." and ending with ".]" is reserved for future extensions.  If you
need to represent those character sequences inside a regular expression
character class, just quote the square brackets with the backslash: "\[."
and ".\]".  The S<<-- HERE> shows whereabouts in the regular expression the
problem was discovered.  See L<perlre>.

=item POSIX syntax [= =] is reserved for future extensions in regex; marked by 
S<<-- HERE> in m/%s/

(F) Within regular expression character classes ([]) the syntax beginning
with "[=" and ending with "=]" is reserved for future extensions.  If you
need to represent those character sequences inside a regular expression
character class, just quote the square brackets with the backslash: "\[="
and "=\]".  The S<<-- HERE> shows whereabouts in the regular expression the
problem was discovered.  See L<perlre>.

=item Possible attempt to put comments in qw() list

(W qw) qw() lists contain items separated by whitespace; as with literal
strings, comment characters are not ignored, but are instead treated as
literal data.  (You may have used different delimiters than the
parentheses shown here; braces are also frequently used.)

You probably wrote something like this:

    @@list = qw(
	a # a comment
        b # another comment
    );

when you should have written this:

    @@list = qw(
	a
        b
    );

If you really want comments, build your list the
old-fashioned way, with quotes and commas:

    @@list = (
        'a',    # a comment
        'b',    # another comment
    );

=item Possible attempt to separate words with commas

(W qw) qw() lists contain items separated by whitespace; therefore
commas aren't needed to separate the items.  (You may have used
different delimiters than the parentheses shown here; braces are also
frequently used.)

You probably wrote something like this:

    qw! a, b, c !;

which puts literal commas into some of the list items.  Write it without
commas if you don't want them to appear in your data:

    qw! a b c !;

=item Possible memory corruption: %s overflowed 3rd argument

(F) An ioctl() or fcntl() returned more than Perl was bargaining for.
Perl guesses a reasonable buffer size, but puts a sentinel byte at the
end of the buffer just in case.  This sentinel byte got clobbered, and
Perl assumes that memory is now corrupted.  See L<perlfunc/ioctl>.

=item Possible precedence issue with control flow operator

(W syntax) There is a possible problem with the mixing of a control
flow operator (e.g. C<return>) and a low-precedence operator like
C<or>.  Consider:

    sub { return $a or $b; }

This is parsed as:

    sub { (return $a) or $b; }

Which is effectively just:

    sub { return $a; }

Either use parentheses or the high-precedence variant of the operator.

Note this may be also triggered for constructs like:

    sub { 1 if die; }

=item Possible precedence problem on bitwise %s operator

(W precedence) Your program uses a bitwise logical operator in conjunction
with a numeric comparison operator, like this :

    if ($x & $y == 0) { ... }

This expression is actually equivalent to C<$x & ($y == 0)>, due to the
higher precedence of C<==>.  This is probably not what you want.  (If you
really meant to write this, disable the warning, or, better, put the
parentheses explicitly and write C<$x & ($y == 0)>).

=item Possible unintended interpolation of $\ in regex

(W ambiguous) You said something like C<m/$\/> in a regex.
The regex C<m/foo$\s+bar/m> translates to: match the word 'foo', the output
record separator (see L<perlvar/$\>) and the letter 's' (one time or more)
followed by the word 'bar'.

If this is what you intended then you can silence the warning by using 
C<m/${\}/> (for example: C<m/foo${\}s+bar/>).

If instead you intended to match the word 'foo' at the end of the line
followed by whitespace and the word 'bar' on the next line then you can use
C<m/$(?)\/> (for example: C<m/foo$(?)\s+bar/>).

=item Possible unintended interpolation of %s in string

(W ambiguous) You said something like '@@foo' in a double-quoted string
but there was no array C<@@foo> in scope at the time.  If you wanted a
literal @@foo, then write it as \@@foo; otherwise find out what happened
to the array you apparently lost track of.

=item Precedence problem: open %s should be open(%s)

(S precedence) The old irregular construct

    open FOO || die;

is now misinterpreted as

    open(FOO || die);

because of the strict regularization of Perl 5's grammar into unary and
list operators.  (The old open was a little of both.)  You must put
parentheses around the filehandle, or use the new "or" operator instead
of "||".

=item Premature end of script headers

See Server error.

=item printf() on closed filehandle %s

(W closed) The filehandle you're writing to got itself closed sometime
before now.  Check your control flow.

=item print() on closed filehandle %s

(W closed) The filehandle you're printing on got itself closed sometime
before now.  Check your control flow.

=item Process terminated by SIG%s

(W) This is a standard message issued by OS/2 applications, while *nix
applications die in silence.  It is considered a feature of the OS/2
port.  One can easily disable this by appropriate sighandlers, see
L<perlipc/"Signals">.  See also "Process terminated by SIGTERM/SIGINT"
in L<perlos2>.

=item Prototype after '%c' for %s : %s

(W illegalproto) A character follows % or @@ in a prototype.  This is
useless, since % and @@ gobble the rest of the subroutine arguments.

=item Prototype mismatch: %s vs %s

(S prototype) The subroutine being declared or defined had previously been
declared or defined with a different function prototype.

=item Prototype not terminated

(F) You've omitted the closing parenthesis in a function prototype
definition.

=item Prototype '%s' overridden by attribute 'prototype(%s)' in %s

(W prototype) A prototype was declared in both the parentheses after
the sub name and via the prototype attribute.  The prototype in
parentheses is useless, since it will be replaced by the prototype
from the attribute before it's ever used.

=item Quantifier follows nothing in regex; marked by S<<-- HERE> in m/%s/

(F) You started a regular expression with a quantifier.  Backslash it if
you meant it literally.  The S<<-- HERE> shows whereabouts in the regular
expression the problem was discovered.  See L<perlre>.

=item Quantifier in {,} bigger than %d in regex; marked by S<<-- HERE> in m/%s/

(F) There is currently a limit to the size of the min and max values of
the {min,max} construct.  The S<<-- HERE> shows whereabouts in the regular
expression the problem was discovered.  See L<perlre>.

=item Quantifier {n,m} with n > m can't match in regex

=item Quantifier {n,m} with n > m can't match in regex; marked by
S<<-- HERE> in m/%s/

(W regexp) Minima should be less than or equal to maxima.  If you really
want your regexp to match something 0 times, just put {0}.

=item Quantifier unexpected on zero-length expression in regex m/%s/

(W regexp) You applied a regular expression quantifier in a place where
it makes no sense, such as on a zero-width assertion.  Try putting the
quantifier inside the assertion instead.  For example, the way to match
"abc" provided that it is followed by three repetitions of "xyz" is
C</abc(?=(?:xyz){3})/>, not C</abc(?=xyz){3}/>.

=item Range iterator outside integer range

(F) One (or both) of the numeric arguments to the range operator ".."
are outside the range which can be represented by integers internally.
One possible workaround is to force Perl to use magical string increment
by prepending "0" to your numbers.

=item Ranges of ASCII printables should be some subset of "0-9", "A-Z", or
"a-z" in regex; marked by S<<-- HERE> in m/%s/

(W regexp) (only under C<S<use re 'strict'>> or within C<(?[...])>)

Stricter rules help to find typos and other errors.  Perhaps you didn't
even intend a range here, if the C<"-"> was meant to be some other
character, or should have been escaped (like C<"\-">).  If you did
intend a range, the one that was used is not portable between ASCII and
EBCDIC platforms, and doesn't have an obvious meaning to a casual
reader.

 [3-7]    # OK; Obvious and portable
 [d-g]    # OK; Obvious and portable
 [A-Y]    # OK; Obvious and portable
 [A-z]    # WRONG; Not portable; not clear what is meant
 [a-Z]    # WRONG; Not portable; not clear what is meant
 [%-.]    # WRONG; Not portable; not clear what is meant
 [\x41-Z] # WRONG; Not portable; not obvious to non-geek

(You can force portability by specifying a Unicode range, which means that
the endpoints are specified by
L<C<\N{...}>|perlrecharclass/Character Ranges>, but the meaning may
still not be obvious.)
The stricter rules require that ranges that start or stop with an ASCII
character that is not a control have all their endpoints be the literal
character, and not some escape sequence (like C<"\x41">), and the ranges
must be all digits, or all uppercase letters, or all lowercase letters.

=item Ranges of digits should be from the same group in regex; marked by
S<<-- HERE> in m/%s/

(W regexp) (only under C<S<use re 'strict'>> or within C<(?[...])>)

Stricter rules help to find typos and other errors.  You included a
range, and at least one of the end points is a decimal digit.  Under the
stricter rules, when this happens, both end points should be digits in
the same group of 10 consecutive digits.

=item readdir() attempted on invalid dirhandle %s

(W io) The dirhandle you're reading from is either closed or not really
a dirhandle.  Check your control flow.

=item readline() on closed filehandle %s

(W closed) The filehandle you're reading from got itself closed sometime
before now.  Check your control flow.

=item read() on closed filehandle %s

(W closed) You tried to read from a closed filehandle.

=item read() on unopened filehandle %s

(W unopened) You tried to read from a filehandle that was never opened.

=item Reallocation too large: %x

(F) You can't allocate more than 64K on an MS-DOS machine.

=item realloc() of freed memory ignored

(S malloc) An internal routine called realloc() on something that had
already been freed.

=item Recompile perl with B<-D>DEBUGGING to use B<-D> switch

(S debugging) You can't use the B<-D> option unless the code to produce
the desired output is compiled into Perl, which entails some overhead,
which is why it's currently left out of your copy.

=item Recursive call to Perl_load_module in PerlIO_find_layer

(P) It is currently not permitted to load modules when creating
a filehandle inside an %INC hook.  This can happen with C<open my
$fh, '<', \$scalar>, which implicitly loads PerlIO::scalar.  Try
loading PerlIO::scalar explicitly first.

=item Recursive inheritance detected in package '%s'

(F) While calculating the method resolution order (MRO) of a package, Perl
believes it found an infinite loop in the C<@@ISA> hierarchy.  This is a
crude check that bails out after 100 levels of C<@@ISA> depth.

=item Redundant argument in %s

(W redundant) You called a function with more arguments than other
arguments you supplied indicated would be needed.  Currently only
emitted when a printf-type format required fewer arguments than were
supplied, but might be used in the future for e.g. L<perlfunc/pack>.

=item refcnt_dec: fd %d%s

=item refcnt: fd %d%s

=item refcnt_inc: fd %d%s

(P) Perl's I/O implementation failed an internal consistency check.  If
you see this message, something is very wrong.

=item Reference found where even-sized list expected

(W misc) You gave a single reference where Perl was expecting a list
with an even number of elements (for assignment to a hash).  This
usually means that you used the anon hash constructor when you meant
to use parens.  In any case, a hash requires key/value B<pairs>.

    %hash = { one => 1, two => 2, };	# WRONG
    %hash = [ qw/ an anon array / ];	# WRONG
    %hash = ( one => 1, two => 2, );	# right
    %hash = qw( one 1 two 2 );			# also fine

=item Reference is already weak

(W misc) You have attempted to weaken a reference that is already weak.
Doing so has no effect.

=item Reference to invalid group 0 in regex; marked by S<<-- HERE> in m/%s/

(F) You used C<\g0> or similar in a regular expression.  You may refer
to capturing parentheses only with strictly positive integers
(normal backreferences) or with strictly negative integers (relative
backreferences).  Using 0 does not make sense.

=item Reference to nonexistent group in regex; marked by S<<-- HERE> in
m/%s/

(F) You used something like C<\7> in your regular expression, but there are
not at least seven sets of capturing parentheses in the expression.  If
you wanted to have the character with ordinal 7 inserted into the regular
expression, prepend zeroes to make it three digits long: C<\007>

The S<<-- HERE> shows whereabouts in the regular expression the problem was
discovered.

=item Reference to nonexistent named group in regex; marked by S<<-- HERE>
in m/%s/

(F) You used something like C<\k'NAME'> or C<< \k<NAME> >> in your regular
expression, but there is no corresponding named capturing parentheses
such as C<(?'NAME'...)> or C<< (?<NAME>...) >>.  Check if the name has been
spelled correctly both in the backreference and the declaration.

The S<<-- HERE> shows whereabouts in the regular expression the problem was
discovered.

=item Reference to nonexistent or unclosed group in regex; marked by
S<<-- HERE> in m/%s/

(F) You used something like C<\g{-7}> in your regular expression, but there
are not at least seven sets of closed capturing parentheses in the
expression before where the C<\g{-7}> was located.

The S<<-- HERE> shows whereabouts in the regular expression the problem was
discovered.

=item regexp memory corruption

(P) The regular expression engine got confused by what the regular
expression compiler gave it.

=item Regexp modifier "/%c" may appear a maximum of twice

=item Regexp modifier "%c" may appear a maximum of twice in regex; marked
by S<<-- HERE> in m/%s/

(F) The regular expression pattern had too many occurrences
of the specified modifier.  Remove the extraneous ones.

=item Regexp modifier "%c" may not appear after the "-" in regex; marked by <-- 
HERE in m/%s/

(F) Turning off the given modifier has the side effect of turning on
another one.  Perl currently doesn't allow this.  Reword the regular
expression to use the modifier you want to turn on (and place it before
the minus), instead of the one you want to turn off.

=item Regexp modifier "/%c" may not appear twice

=item Regexp modifier "%c" may not appear twice in regex; marked by <--
HERE in m/%s/

(F) The regular expression pattern had too many occurrences
of the specified modifier.  Remove the extraneous ones.

=item Regexp modifiers "/%c" and "/%c" are mutually exclusive

=item Regexp modifiers "%c" and "%c" are mutually exclusive in regex;
marked by S<<-- HERE> in m/%s/

(F) The regular expression pattern had more than one of these
mutually exclusive modifiers.  Retain only the modifier that is
supposed to be there.

=item Regexp out of space in regex m/%s/

(P) A "can't happen" error, because safemalloc() should have caught it
earlier.

=item Repeated format line will never terminate (~~ and @@#)

(F) Your format contains the ~~ repeat-until-blank sequence and a
numeric field that will never go blank so that the repetition never
terminates.  You might use ^# instead.  See L<perlform>.

=item Replacement list is longer than search list

(W misc) You have used a replacement list that is longer than the
search list.  So the additional elements in the replacement list
are meaningless.

=item '%s' resolved to '\o{%s}%d'

(W misc, regexp)  You wrote something like C<\08>, or C<\179> in a
double-quotish string.  All but the last digit is treated as a single
character, specified in octal.  The last digit is the next character in
the string.  To tell Perl that this is indeed what you want, you can use
the C<\o{ }> syntax, or use exactly three digits to specify the octal
for the character.

=item Reversed %s= operator

(W syntax) You wrote your assignment operator backwards.  The = must
always come last, to avoid ambiguity with subsequent unary operators.

=item rewinddir() attempted on invalid dirhandle %s

(W io) The dirhandle you tried to do a rewinddir() on is either closed
or not really a dirhandle.  Check your control flow.

=item Scalars leaked: %d

(S internal) Something went wrong in Perl's internal bookkeeping
of scalars: not all scalar variables were deallocated by the time
Perl exited.  What this usually indicates is a memory leak, which
is of course bad, especially if the Perl program is intended to be
long-running.

=item Scalar value @@%s[%s] better written as $%s[%s]

(W syntax) You've used an array slice (indicated by @@) to select a
single element of an array.  Generally it's better to ask for a scalar
value (indicated by $).  The difference is that C<$foo[&bar]> always
behaves like a scalar, both when assigning to it and when evaluating its
argument, while C<@@foo[&bar]> behaves like a list when you assign to it,
and provides a list context to its subscript, which can do weird things
if you're expecting only one subscript.

On the other hand, if you were actually hoping to treat the array
element as a list, you need to look into how references work, because
Perl will not magically convert between scalars and lists for you.  See
L<perlref>.

=item Scalar value @@%s{%s} better written as $%s{%s}

(W syntax) You've used a hash slice (indicated by @@) to select a single
element of a hash.  Generally it's better to ask for a scalar value
(indicated by $).  The difference is that C<$foo{&bar}> always behaves
like a scalar, both when assigning to it and when evaluating its
argument, while C<@@foo{&bar}> behaves like a list when you assign to it,
and provides a list context to its subscript, which can do weird things
if you're expecting only one subscript.

On the other hand, if you were actually hoping to treat the hash element
as a list, you need to look into how references work, because Perl will
not magically convert between scalars and lists for you.  See
L<perlref>.

=item Search pattern not terminated

(F) The lexer couldn't find the final delimiter of a // or m{}
construct.  Remember that bracketing delimiters count nesting level.
Missing the leading C<$> from a variable C<$m> may cause this error.

Note that since Perl 5.10.0 a // can also be the I<defined-or>
construct, not just the empty search pattern.  Therefore code written
in Perl 5.10.0 or later that uses the // as the I<defined-or> can be
misparsed by pre-5.10.0 Perls as a non-terminated search pattern.

=item seekdir() attempted on invalid dirhandle %s

(W io) The dirhandle you are doing a seekdir() on is either closed or not
really a dirhandle.  Check your control flow.

=item %sseek() on unopened filehandle

(W unopened) You tried to use the seek() or sysseek() function on a
filehandle that was either never opened or has since been closed.

=item select not implemented

(F) This machine doesn't implement the select() system call.

=item Self-ties of arrays and hashes are not supported

(F) Self-ties are of arrays and hashes are not supported in
the current implementation.

=item Semicolon seems to be missing

(W semicolon) A nearby syntax error was probably caused by a missing
semicolon, or possibly some other missing operator, such as a comma.

=item semi-panic: attempt to dup freed string

(S internal) The internal newSVsv() routine was called to duplicate a
scalar that had previously been marked as free.

=item sem%s not implemented

(F) You don't have System V semaphore IPC on your system.

=item send() on closed socket %s

(W closed) The socket you're sending to got itself closed sometime
before now.  Check your control flow.

=item Sequence "\c{" invalid

(F) These three characters may not appear in sequence in a
double-quotish context.  This message is raised only on non-ASCII
platforms (a different error message is output on ASCII ones).  If you
were intending to specify a control character with this sequence, you'll
have to use a different way to specify it.

=item Sequence (? incomplete in regex; marked by S<<-- HERE> in m/%s/

(F) A regular expression ended with an incomplete extension (?.  The
S<<-- HERE> shows whereabouts in the regular expression the problem was
discovered.  See L<perlre>.

=item Sequence (?%c...) not implemented in regex; marked by S<<-- HERE> in
m/%s/

(F) A proposed regular expression extension has the character reserved
but has not yet been written.  The S<<-- HERE> shows whereabouts in the
regular expression the problem was discovered.  See L<perlre>.

=item Sequence (?%s...) not recognized in regex; marked by S<<-- HERE> in
m/%s/

(F) You used a regular expression extension that doesn't make sense.
The S<<-- HERE> shows whereabouts in the regular expression the problem was
discovered.  This may happen when using the C<(?^...)> construct to tell
Perl to use the default regular expression modifiers, and you
redundantly specify a default modifier.  For other
causes, see L<perlre>.

=item Sequence (?#... not terminated in regex m/%s/

(F) A regular expression comment must be terminated by a closing
parenthesis.  Embedded parentheses aren't allowed.  See
L<perlre>.

=item Sequence (?&... not terminated in regex; marked by S<<-- HERE> in
m/%s/

(F) A named reference of the form C<(?&...)> was missing the final
closing parenthesis after the name.  The S<<-- HERE> shows whereabouts
in the regular expression the problem was discovered.

=item Sequence (?%c... not terminated in regex; marked by S<<-- HERE>
in m/%s/

(F) A named group of the form C<(?'...')> or C<< (?<...>) >> was missing the final
closing quote or angle bracket.  The S<<-- HERE> shows whereabouts in the
regular expression the problem was discovered.

=item Sequence (?(%c... not terminated in regex; marked by S<<-- HERE>
in m/%s/

(F) A named reference of the form C<(?('...')...)> or C<< (?(<...>)...) >> was
missing the final closing quote or angle bracket after the name.  The
S<<-- HERE> shows whereabouts in the regular expression the problem was
discovered.

=item Sequence (?... not terminated in regex; marked by S<<-- HERE> in
m/%s/

(F) There was no matching closing parenthesis for the '('.  The
S<<-- HERE> shows whereabouts in the regular expression the problem was
discovered.

=item Sequence \%s... not terminated in regex; marked by S<<-- HERE> in
m/%s/

(F) The regular expression expects a mandatory argument following the escape
sequence and this has been omitted or incorrectly written.

=item Sequence (?{...}) not terminated with ')'

(F) The end of the perl code contained within the {...} must be
followed immediately by a ')'.

=item Sequence (?PE<gt>... not terminated in regex; marked by S<<-- HERE> in m/%s/

(F) A named reference of the form C<(?PE<gt>...)> was missing the final
closing parenthesis after the name.  The S<<-- HERE> shows whereabouts
in the regular expression the problem was discovered.

=item Sequence (?PE<lt>... not terminated in regex; marked by S<<-- HERE> in m/%s/

(F) A named group of the form C<(?PE<lt>...E<gt>')> was missing the final
closing angle bracket.  The S<<-- HERE> shows whereabouts in the
regular expression the problem was discovered.

=item Sequence ?P=... not terminated in regex; marked by S<<-- HERE> in
m/%s/

(F) A named reference of the form C<(?P=...)> was missing the final
closing parenthesis after the name.  The S<<-- HERE> shows whereabouts
in the regular expression the problem was discovered.

=item Sequence (?R) not terminated in regex m/%s/

(F) An C<(?R)> or C<(?0)> sequence in a regular expression was missing the
final parenthesis.

=item Server error (a.k.a. "500 Server error")

(A) This is the error message generally seen in a browser window
when trying to run a CGI program (including SSI) over the web.  The
actual error text varies widely from server to server.  The most
frequently-seen variants are "500 Server error", "Method (something)
not permitted", "Document contains no data", "Premature end of script
headers", and "Did not produce a valid header".

B<This is a CGI error, not a Perl error>.

You need to make sure your script is executable, is accessible by
the user CGI is running the script under (which is probably not the
user account you tested it under), does not rely on any environment
variables (like PATH) from the user it isn't running under, and isn't
in a location where the CGI server can't find it, basically, more or
less.  Please see the following for more information:

	http://www.perl.org/CGI_MetaFAQ.html
	http://www.htmlhelp.org/faq/cgifaq.html
	http://www.w3.org/Security/Faq/

You should also look at L<perlfaq9>.

=item setegid() not implemented

(F) You tried to assign to C<$)>, and your operating system doesn't
support the setegid() system call (or equivalent), or at least Configure
didn't think so.

=item seteuid() not implemented

(F) You tried to assign to C<< $> >>, and your operating system doesn't
support the seteuid() system call (or equivalent), or at least Configure
didn't think so.

=item setpgrp can't take arguments

(F) Your system has the setpgrp() from BSD 4.2, which takes no
arguments, unlike POSIX setpgid(), which takes a process ID and process
group ID.

=item setrgid() not implemented

(F) You tried to assign to C<$(>, and your operating system doesn't
support the setrgid() system call (or equivalent), or at least Configure
didn't think so.

=item setruid() not implemented

(F) You tried to assign to C<$<>, and your operating system doesn't
support the setruid() system call (or equivalent), or at least Configure
didn't think so.

=item setsockopt() on closed socket %s

(W closed) You tried to set a socket option on a closed socket.  Did you
forget to check the return value of your socket() call?  See
L<perlfunc/setsockopt>.

=item Setting ${^ENCODING} is deprecated

(D deprecated) You assigned a non-C<undef> value to C<${^ENCODING}>.
This is deprecated; see C<L<perlvar/${^ENCODING}>> for details.

=item Setting $/ to a reference to %s as a form of slurp is deprecated, treating as undef

(D deprecated) You assigned a reference to a scalar to C<$/> where the
referenced item is not a positive integer.  In older perls this B<appeared>
to work the same as setting it to C<undef> but was in fact internally
different, less efficient and with very bad luck could have resulted in
your file being split by a stringified form of the reference.

In Perl 5.20.0 this was changed so that it would be B<exactly> the same as
setting C<$/> to undef, with the exception that this warning would be
thrown.

You are recommended to change your code to set C<$/> to C<undef> explicitly
if you wish to slurp the file. In future versions of Perl assigning
a reference to will throw a fatal error.

=item Setting $/ to %s reference is forbidden

(F) You tried to assign a reference to a non integer to C<$/>.  In older
Perls this would have behaved similarly to setting it to a reference to
a positive integer, where the integer was the address of the reference.
As of Perl 5.20.0 this is a fatal error, to allow future versions of Perl
to use non-integer refs for more interesting purposes.

=item shm%s not implemented

(F) You don't have System V shared memory IPC on your system.

=item !=~ should be !~

(W syntax) The non-matching operator is !~, not !=~.  !=~ will be
interpreted as the != (numeric not equal) and ~ (1's complement)
operators: probably not what you intended.

=item /%s/ should probably be written as "%s"

(W syntax) You have used a pattern where Perl expected to find a string,
as in the first argument to C<join>.  Perl will treat the true or false
result of matching the pattern against $_ as the string, which is
probably not what you had in mind.

=item shutdown() on closed socket %s

(W closed) You tried to do a shutdown on a closed socket.  Seems a bit
superfluous.

=item SIG%s handler "%s" not defined

(W signal) The signal handler named in %SIG doesn't, in fact, exist.
Perhaps you put it into the wrong package?

=item Slab leaked from cv %p

(S) If you see this message, then something is seriously wrong with the
internal bookkeeping of op trees.  An op tree needed to be freed after
a compilation error, but could not be found, so it was leaked instead.

=item sleep(%u) too large

(W overflow) You called C<sleep> with a number that was larger than
it can reliably handle and C<sleep> probably slept for less time than
requested.

=item Slurpy parameter not last

(F) In a subroutine signature, you put something after a slurpy (array or
hash) parameter.  The slurpy parameter takes all the available arguments,
so there can't be any left to fill later parameters.

=item Smart matching a non-overloaded object breaks encapsulation

(F) You should not use the C<~~> operator on an object that does not
overload it: Perl refuses to use the object's underlying structure
for the smart match.

=item Smartmatch is experimental

(S experimental::smartmatch) This warning is emitted if you
use the smartmatch (C<~~>) operator.  This is currently an experimental
feature, and its details are subject to change in future releases of
Perl.  Particularly, its current behavior is noticed for being
unnecessarily complex and unintuitive, and is very likely to be
overhauled.

=item sort is now a reserved word

(F) An ancient error message that almost nobody ever runs into anymore.
But before sort was a keyword, people sometimes used it as a filehandle.

=item Source filters apply only to byte streams

(F) You tried to activate a source filter (usually by loading a
source filter module) within a string passed to C<eval>.  This is
not permitted under the C<unicode_eval> feature.  Consider using
C<evalbytes> instead.  See L<feature>.

=item splice() offset past end of array

(W misc) You attempted to specify an offset that was past the end of
the array passed to splice().  Splicing will instead commence at the
end of the array, rather than past it.  If this isn't what you want,
try explicitly pre-extending the array by assigning $#array = $offset.
See L<perlfunc/splice>.

=item Split loop

(P) The split was looping infinitely.  (Obviously, a split shouldn't
iterate more times than there are characters of input, which is what
happened.)  See L<perlfunc/split>.

=item Statement unlikely to be reached

(W exec) You did an exec() with some statement after it other than a
die().  This is almost always an error, because exec() never returns
unless there was a failure.  You probably wanted to use system()
instead, which does return.  To suppress this warning, put the exec() in
a block by itself.

=item "state" subroutine %s can't be in a package

(F) Lexically scoped subroutines aren't in a package, so it doesn't make
sense to try to declare one with a package qualifier on the front.

=item "state %s" used in sort comparison

(W syntax) The package variables $a and $b are used for sort comparisons.
You used $a or $b in as an operand to the C<< <=> >> or C<cmp> operator inside a
sort comparison block, and the variable had earlier been declared as a
lexical variable.  Either qualify the sort variable with the package
name, or rename the lexical variable.

=item "state" variable %s can't be in a package

(F) Lexically scoped variables aren't in a package, so it doesn't make
sense to try to declare one with a package qualifier on the front.  Use
local() if you want to localize a package variable.

=item stat() on unopened filehandle %s

(W unopened) You tried to use the stat() function on a filehandle that
was either never opened or has since been closed.

=item Strings with code points over 0xFF may not be mapped into in-memory file handles

(W utf8) You tried to open a reference to a scalar for read or append
where the scalar contained code points over 0xFF.  In-memory files
model on-disk files and can only contain bytes.

=item Stub found while resolving method "%s" overloading "%s" in package "%s"

(P) Overloading resolution over @@ISA tree may be broken by importation
stubs.  Stubs should never be implicitly created, but explicit calls to
C<can> may break this.

=item Subroutine "&%s" is not available

(W closure) During compilation, an inner named subroutine or eval is
attempting to capture an outer lexical subroutine that is not currently
available.  This can happen for one of two reasons.  First, the lexical
subroutine may be declared in an outer anonymous subroutine that has
not yet been created.  (Remember that named subs are created at compile
time, while anonymous subs are created at run-time.)  For example,

    sub { my sub a {...} sub f { \&a } }

At the time that f is created, it can't capture the current "a" sub,
since the anonymous subroutine hasn't been created yet.  Conversely, the
following won't give a warning since the anonymous subroutine has by now
been created and is live:

    sub { my sub a {...} eval 'sub f { \&a }' }->();

The second situation is caused by an eval accessing a lexical subroutine
that has gone out of scope, for example,

    sub f {
	my sub a {...}
	sub { eval '\&a' }
    }
    f()->();

Here, when the '\&a' in the eval is being compiled, f() is not currently
being executed, so its &a is not available for capture.

=item "%s" subroutine &%s masks earlier declaration in same %s

(W misc) A "my" or "state" subroutine has been redeclared in the
current scope or statement, effectively eliminating all access to
the previous instance.  This is almost always a typographical error.
Note that the earlier subroutine will still exist until the end of
the scope or until all closure references to it are destroyed.

=item Subroutine %s redefined

(W redefine) You redefined a subroutine.  To suppress this warning, say

    {
	no warnings 'redefine';
	eval "sub name { ... }";
    }

=item Subroutine "%s" will not stay shared

(W closure) An inner (nested) I<named> subroutine is referencing a "my"
subroutine defined in an outer named subroutine.

When the inner subroutine is called, it will see the value of the outer
subroutine's lexical subroutine as it was before and during the *first*
call to the outer subroutine; in this case, after the first call to the
outer subroutine is complete, the inner and outer subroutines will no
longer share a common value for the lexical subroutine.  In other words,
it will no longer be shared.  This will especially make a difference
if the lexical subroutines accesses lexical variables declared in its
surrounding scope.

This problem can usually be solved by making the inner subroutine
anonymous, using the C<sub {}> syntax.  When inner anonymous subs that
reference lexical subroutines in outer subroutines are created, they
are automatically rebound to the current values of such lexical subs.

=item Substitution loop

(P) The substitution was looping infinitely.  (Obviously, a substitution
shouldn't iterate more times than there are characters of input, which
is what happened.)  See the discussion of substitution in
L<perlop/"Regexp Quote-Like Operators">.

=item Substitution pattern not terminated

(F) The lexer couldn't find the interior delimiter of an s/// or s{}{}
construct.  Remember that bracketing delimiters count nesting level.
Missing the leading C<$> from variable C<$s> may cause this error.

=item Substitution replacement not terminated

(F) The lexer couldn't find the final delimiter of an s/// or s{}{}
construct.  Remember that bracketing delimiters count nesting level.
Missing the leading C<$> from variable C<$s> may cause this error.

=item substr outside of string

(W substr)(F) You tried to reference a substr() that pointed outside of
a string.  That is, the absolute value of the offset was larger than the
length of the string.  See L<perlfunc/substr>.  This warning is fatal if
substr is used in an lvalue context (as the left hand side of an
assignment or as a subroutine argument for example).

=item sv_upgrade from type %d down to type %d

(P) Perl tried to force the upgrade of an SV to a type which was actually
inferior to its current type.

=item SWASHNEW didn't return an HV ref

(P) Something went wrong internally when Perl was trying to look up
Unicode characters.

=item Switch (?(condition)... contains too many branches in regex; marked by 
S<<-- HERE> in m/%s/

(F) A (?(condition)if-clause|else-clause) construct can have at most
two branches (the if-clause and the else-clause).  If you want one or
both to contain alternation, such as using C<this|that|other>, enclose
it in clustering parentheses:

    (?(condition)(?:this|that|other)|else-clause)

The S<<-- HERE> shows whereabouts in the regular expression the problem
was discovered.  See L<perlre>.

=item Switch condition not recognized in regex; marked by S<<-- HERE> in
m/%s/

(F) The condition part of a (?(condition)if-clause|else-clause) construct
is not known.  The condition must be one of the following:

 (1) (2) ...        true if 1st, 2nd, etc., capture matched
 (<NAME>) ('NAME')  true if named capture matched
 (?=...) (?<=...)   true if subpattern matches
 (?!...) (?<!...)   true if subpattern fails to match
 (?{ CODE })        true if code returns a true value
 (R)                true if evaluating inside recursion
 (R1) (R2) ...      true if directly inside capture group 1, 2, etc.
 (R&NAME)           true if directly inside named capture
 (DEFINE)           always false; for defining named subpatterns

The S<<-- HERE> shows whereabouts in the regular expression the problem was
discovered.  See L<perlre>.

=item Switch (?(condition)... not terminated in regex; marked by
S<<-- HERE> in m/%s/

(F) You omitted to close a (?(condition)...) block somewhere
in the pattern.  Add a closing parenthesis in the appropriate
position.  See L<perlre>.

=item switching effective %s is not implemented

(F) While under the C<use filetest> pragma, we cannot switch the real
and effective uids or gids.

=item syntax error

(F) Probably means you had a syntax error.  Common reasons include:

    A keyword is misspelled.
    A semicolon is missing.
    A comma is missing.
    An opening or closing parenthesis is missing.
    An opening or closing brace is missing.
    A closing quote is missing.

Often there will be another error message associated with the syntax
error giving more information.  (Sometimes it helps to turn on B<-w>.)
The error message itself often tells you where it was in the line when
it decided to give up.  Sometimes the actual error is several tokens
before this, because Perl is good at understanding random input.
Occasionally the line number may be misleading, and once in a blue moon
the only way to figure out what's triggering the error is to call
C<perl -c> repeatedly, chopping away half the program each time to see
if the error went away.  Sort of the cybernetic version of S<20 questions>.

=item syntax error at line %d: '%s' unexpected

(A) You've accidentally run your script through the Bourne shell instead
of Perl.  Check the #! line, or manually feed your script into Perl
yourself.

=item syntax error in file %s at line %d, next 2 tokens "%s"

(F) This error is likely to occur if you run a perl5 script through
a perl4 interpreter, especially if the next 2 tokens are "use strict"
or "my $var" or "our $var".

=item Syntax error in (?[...]) in regex m/%s/

(F) Perl could not figure out what you meant inside this construct; this
notifies you that it is giving up trying.

=item %s syntax OK

(F) The final summary message when a C<perl -c> succeeds.

=item sysread() on closed filehandle %s

(W closed) You tried to read from a closed filehandle.

=item sysread() on unopened filehandle %s

(W unopened) You tried to read from a filehandle that was never opened.

=item System V %s is not implemented on this machine

(F) You tried to do something with a function beginning with "sem",
"shm", or "msg" but that System V IPC is not implemented in your
machine.  In some machines the functionality can exist but be
unconfigured.  Consult your system support.

=item syswrite() on closed filehandle %s

(W closed) The filehandle you're writing to got itself closed sometime
before now.  Check your control flow.

=item C<-T> and C<-B> not implemented on filehandles

(F) Perl can't peek at the stdio buffer of filehandles when it doesn't
know about your kind of stdio.  You'll have to use a filename instead.

=item Target of goto is too deeply nested

(F) You tried to use C<goto> to reach a label that was too deeply nested
for Perl to reach.  Perl is doing you a favor by refusing.

=item telldir() attempted on invalid dirhandle %s

(W io) The dirhandle you tried to telldir() is either closed or not really
a dirhandle.  Check your control flow.

=item tell() on unopened filehandle

(W unopened) You tried to use the tell() function on a filehandle that
was either never opened or has since been closed.

=item That use of $[ is unsupported

(F) Assignment to C<$[> is now strictly circumscribed, and interpreted
as a compiler directive.  You may say only one of

    $[ = 0;
    $[ = 1;
    ...
    local $[ = 0;
    local $[ = 1;
    ...

This is to prevent the problem of one module changing the array base out
from under another module inadvertently.  See L<perlvar/$[> and L<arybase>.

=item The bitwise feature is experimental

(S experimental::bitwise) This warning is emitted if you use bitwise
operators (C<& | ^ ~ &. |. ^. ~.>) with the "bitwise" feature enabled.
Simply suppress the warning if you want to use the feature, but know
that in doing so you are taking the risk of using an experimental
feature which may change or be removed in a future Perl version:

    no warnings "experimental::bitwise";
    use feature "bitwise";
    $x |.= $y;

=item The crypt() function is unimplemented due to excessive paranoia.

(F) Configure couldn't find the crypt() function on your machine,
probably because your vendor didn't supply it, probably because they
think the U.S. Government thinks it's a secret, or at least that they
will continue to pretend that it is.  And if you quote me on that, I
will deny it.

=item The %s function is unimplemented

(F) The function indicated isn't implemented on this architecture,
according to the probings of Configure.

=item The lexical_subs feature is experimental

(S experimental::lexical_subs) This warning is emitted if you
declare a sub with C<my> or C<state>.  Simply suppress the warning
if you want to use the feature, but know that in doing so you
are taking the risk of using an experimental feature which may
change or be removed in a future Perl version:

    no warnings "experimental::lexical_subs";
    use feature "lexical_subs";
    my sub foo { ... }

=item The regex_sets feature is experimental

(S experimental::regex_sets) This warning is emitted if you
use the syntax S<C<(?[   ])>> in a regular expression.
The details of this feature are subject to change.
if you want to use it, but know that in doing so you
are taking the risk of using an experimental feature which may
change in a future Perl version, you can do this to silence the
warning:

    no warnings "experimental::regex_sets";

=item The signatures feature is experimental

(S experimental::signatures) This warning is emitted if you unwrap a
subroutine's arguments using a signature.  Simply suppress the warning
if you want to use the feature, but know that in doing so you are taking
the risk of using an experimental feature which may change or be removed
in a future Perl version:

    no warnings "experimental::signatures";
    use feature "signatures";
    sub foo ($left, $right) { ... }

=item The stat preceding %s wasn't an lstat

(F) It makes no sense to test the current stat buffer for symbolic
linkhood if the last stat that wrote to the stat buffer already went
past the symlink to get to the real file.  Use an actual filename
instead.

=item The 'unique' attribute may only be applied to 'our' variables

(F) This attribute was never supported on C<my> or C<sub> declarations.

=item This Perl can't reset CRTL environ elements (%s)

=item This Perl can't set CRTL environ elements (%s=%s)

(W internal) Warnings peculiar to VMS.  You tried to change or delete an
element of the CRTL's internal environ array, but your copy of Perl
wasn't built with a CRTL that contained the setenv() function.  You'll
need to rebuild Perl with a CRTL that does, or redefine
F<PERL_ENV_TABLES> (see L<perlvms>) so that the environ array isn't the
target of the change to
%ENV which produced the warning.

=item This Perl has not been built with support for randomized hash key traversal but something called Perl_hv_rand_set().

(F) Something has attempted to use an internal API call which
depends on Perl being compiled with the default support for randomized hash
key traversal, but this Perl has been compiled without it.  You should
report this warning to the relevant upstream party, or recompile perl
with default options.

=item times not implemented

(F) Your version of the C library apparently doesn't do times().  I
suspect you're not running on Unix.

=item "-T" is on the #! line, it must also be used on the command line

(X) The #! line (or local equivalent) in a Perl script contains
the B<-T> option (or the B<-t> option), but Perl was not invoked with
B<-T> in its command line.  This is an error because, by the time
Perl discovers a B<-T> in a script, it's too late to properly taint
everything from the environment.  So Perl gives up.

If the Perl script is being executed as a command using the #!
mechanism (or its local equivalent), this error can usually be
fixed by editing the #! line so that the B<-%c> option is a part of
Perl's first argument: e.g. change C<perl -n -%c> to C<perl -%c -n>.

If the Perl script is being executed as C<perl scriptname>, then the
B<-%c> option must appear on the command line: C<perl -%c scriptname>.

=item To%s: illegal mapping '%s'

(F) You tried to define a customized To-mapping for lc(), lcfirst,
uc(), or ucfirst() (or their string-inlined versions), but you
specified an illegal mapping.
See L<perlunicode/"User-Defined Character Properties">.

=item Too deeply nested ()-groups

(F) Your template contains ()-groups with a ridiculously deep nesting level.

=item Too few args to syscall

(F) There has to be at least one argument to syscall() to specify the
system call to call, silly dilly.

=item Too few arguments for subroutine

(F) A subroutine using a signature received fewer arguments than required
by the signature.  The caller of the subroutine is presumably at fault.
Inconveniently, this error will be reported at the location of the
subroutine, not that of the caller.

=item Too late for "-%s" option

(X) The #! line (or local equivalent) in a Perl script contains the
B<-M>, B<-m> or B<-C> option.

In the case of B<-M> and B<-m>, this is an error because those options
are not intended for use inside scripts.  Use the C<use> pragma instead.

The B<-C> option only works if it is specified on the command line as
well (with the same sequence of letters or numbers following).  Either
specify this option on the command line, or, if your system supports
it, make your script executable and run it directly instead of passing
it to perl.

=item Too late to run %s block

(W void) A CHECK or INIT block is being defined during run time proper,
when the opportunity to run them has already passed.  Perhaps you are
loading a file with C<require> or C<do> when you should be using C<use>
instead.  Or perhaps you should put the C<require> or C<do> inside a
BEGIN block.

=item Too many args to syscall

(F) Perl supports a maximum of only 14 args to syscall().

=item Too many arguments for %s

(F) The function requires fewer arguments than you specified.

=item Too many arguments for subroutine

(F) A subroutine using a signature received more arguments than required
by the signature.  The caller of the subroutine is presumably at fault.
Inconveniently, this error will be reported at the location of the
subroutine, not that of the caller.

=item Too many )'s

(A) You've accidentally run your script through B<csh> instead of Perl.
Check the #! line, or manually feed your script into Perl yourself.

=item Too many ('s

(A) You've accidentally run your script through B<csh> instead of Perl.
Check the #! line, or manually feed your script into Perl yourself.

=item Trailing \ in regex m/%s/

(F) The regular expression ends with an unbackslashed backslash.
Backslash it.   See L<perlre>.

=item Transliteration pattern not terminated

(F) The lexer couldn't find the interior delimiter of a tr/// or tr[][]
or y/// or y[][] construct.  Missing the leading C<$> from variables
C<$tr> or C<$y> may cause this error.

=item Transliteration replacement not terminated

(F) The lexer couldn't find the final delimiter of a tr///, tr[][],
y/// or y[][] construct.

=item '%s' trapped by operation mask

(F) You tried to use an operator from a Safe compartment in which it's
disallowed.  See L<Safe>.

=item truncate not implemented

(F) Your machine doesn't implement a file truncation mechanism that
Configure knows about.

=item Type of arg %d to &CORE::%s must be %s

(F) The subroutine in question in the CORE package requires its argument
to be a hard reference to data of the specified type.  Overloading is
ignored, so a reference to an object that is not the specified type, but
nonetheless has overloading to handle it, will still not be accepted.

=item Type of arg %d to %s must be %s (not %s)

(F) This function requires the argument in that position to be of a
certain type.  Arrays must be @@NAME or C<@@{EXPR}>.  Hashes must be
%NAME or C<%{EXPR}>.  No implicit dereferencing is allowed--use the
{EXPR} forms as an explicit dereference.  See L<perlref>.

=item umask not implemented

(F) Your machine doesn't implement the umask function and you tried to
use it to restrict permissions for yourself (EXPR & 0700).

=item Unbalanced context: %d more PUSHes than POPs

(S internal) The exit code detected an internal inconsistency in how
many execution contexts were entered and left.

=item Unbalanced saves: %d more saves than restores

(S internal) The exit code detected an internal inconsistency in how
many values were temporarily localized.

=item Unbalanced scopes: %d more ENTERs than LEAVEs

(S internal) The exit code detected an internal inconsistency in how
many blocks were entered and left.

=item Unbalanced string table refcount: (%d) for "%s"

(S internal) On exit, Perl found some strings remaining in the shared
string table used for copy on write and for hash keys.  The entries
should have been freed, so this indicates a bug somewhere.

=item Unbalanced tmps: %d more allocs than frees

(S internal) The exit code detected an internal inconsistency in how
many mortal scalars were allocated and freed.

=item Undefined format "%s" called

(F) The format indicated doesn't seem to exist.  Perhaps it's really in
another package?  See L<perlform>.

=item Undefined sort subroutine "%s" called

(F) The sort comparison routine specified doesn't seem to exist.
Perhaps it's in a different package?  See L<perlfunc/sort>.

=item Undefined subroutine &%s called

(F) The subroutine indicated hasn't been defined, or if it was, it has
since been undefined.

=item Undefined subroutine called

(F) The anonymous subroutine you're trying to call hasn't been defined,
or if it was, it has since been undefined.

=item Undefined subroutine in sort

(F) The sort comparison routine specified is declared but doesn't seem
to have been defined yet.  See L<perlfunc/sort>.

=item Undefined top format "%s" called

(F) The format indicated doesn't seem to exist.  Perhaps it's really in
another package?  See L<perlform>.

=item Undefined value assigned to typeglob

(W misc) An undefined value was assigned to a typeglob, a la
C<*foo = undef>.  This does nothing.  It's possible that you really mean
C<undef *foo>.

=item %s: Undefined variable

(A) You've accidentally run your script through B<csh> instead of Perl.
Check the #! line, or manually feed your script into Perl yourself.

=item Unescaped left brace in regex is deprecated, passed through in regex;
marked by S<<-- HERE> in m/%s/

(D deprecated, regexp) You used a literal C<"{"> character in a regular
expression pattern.  You should change to use C<"\{"> instead, because a
future version of Perl (tentatively v5.26) will consider this to be a
syntax error.  If the pattern delimiters are also braces, any matching
right brace (C<"}">) should also be escaped to avoid confusing the parser,
for example,

    qr{abc\{def\}ghi}

=item unexec of %s into %s failed!

(F) The unexec() routine failed for some reason.  See your local FSF
representative, who probably put it there in the first place.

=item Unexpected binary operator '%c' with no preceding operand in regex;
marked by S<<-- HERE> in m/%s/

(F) You had something like this:

 (?[ | \p{Digit} ])

where the C<"|"> is a binary operator with an operand on the right, but
no operand on the left.

=item Unexpected character in regex; marked by S<<-- HERE> in m/%s/

(F) You had something like this:

 (?[ z ])

Within C<(?[ ])>, no literal characters are allowed unless they are
within an inner pair of square brackets, like

 (?[ [ z ] ])

Another possibility is that you forgot a backslash.  Perl isn't smart
enough to figure out what you really meant.

=item Unexpected constant lvalue entersub entry via type/targ %d:%d

(P) When compiling a subroutine call in lvalue context, Perl failed an
internal consistency check.  It encountered a malformed op tree.

=item Unexpected exit %u

(S) exit() was called or the script otherwise finished gracefully when
C<PERL_EXIT_WARN> was set in C<PL_exit_flags>.

=item Unexpected exit failure %d

(S) An uncaught die() was called when C<PERL_EXIT_WARN> was set in
C<PL_exit_flags>.

=item Unexpected ')' in regex; marked by S<<-- HERE> in m/%s/

(F) You had something like this:

 (?[ ( \p{Digit} + ) ])

The C<")"> is out-of-place.  Something apparently was supposed to
be combined with the digits, or the C<"+"> shouldn't be there, or
something like that.  Perl can't figure out what was intended.

=item Unexpected '(' with no preceding operator in regex; marked by
S<<-- HERE> in m/%s/

(F) You had something like this:

 (?[ \p{Digit} ( \p{Lao} + \p{Thai} ) ])

There should be an operator before the C<"(">, as there's
no indication as to how the digits are to be combined
with the characters in the Lao and Thai scripts.

=item Unicode non-character U+%X is not recommended for open interchange

(S nonchar) Certain codepoints, such as U+FFFE and U+FFFF, are
defined by the Unicode standard to be non-characters.  Those
are legal codepoints, but are reserved for internal use; so,
applications shouldn't attempt to exchange them.  An application
may not be expecting any of these characters at all, and receiving
them may lead to bugs.  If you know what you are doing you can
turn off this warning by C<no warnings 'nonchar';>.

This is not really a "severe" error, but it is supposed to be
raised by default even if warnings are not enabled, and currently
the only way to do that in Perl is to mark it as serious.

=item Unicode surrogate U+%X is illegal in UTF-8

(S surrogate) You had a UTF-16 surrogate in a context where they are
not considered acceptable.  These code points, between U+D800 and
U+DFFF (inclusive), are used by Unicode only for UTF-16.  However, Perl
internally allows all unsigned integer code points (up to the size limit
available on your platform), including surrogates.  But these can cause
problems when being input or output, which is likely where this message
came from.  If you really really know what you are doing you can turn
off this warning by C<no warnings 'surrogate';>.

=item Unknown charname '' is deprecated

(D deprecated) You had a C<\N{}> with nothing between the braces.  This
usage is deprecated, and will be made a syntax error in a future Perl
version.

=item Unknown charname '%s'

(F) The name you used inside C<\N{}> is unknown to Perl.  Check the
spelling.  You can say C<use charnames ":loose"> to not have to be
so precise about spaces, hyphens, and capitalization on standard Unicode
names.  (Any custom aliases that have been created must be specified
exactly, regardless of whether C<:loose> is used or not.)  This error may
also happen if the C<\N{}> is not in the scope of the corresponding
C<S<use charnames>>.

=item Unknown error

(P) Perl was about to print an error message in C<$@@>, but the C<$@@> variable
did not exist, even after an attempt to create it.

=item Unknown open() mode '%s'

(F) The second argument of 3-argument open() is not among the list
of valid modes: C<< < >>, C<< > >>, C<<< >> >>>, C<< +< >>,
C<< +> >>, C<<< +>> >>>, C<-|>, C<|->, C<< <& >>, C<< >& >>.

=item Unknown PerlIO layer "%s"

(W layer) An attempt was made to push an unknown layer onto the Perl I/O
system.  (Layers take care of transforming data between external and
internal representations.)  Note that some layers, such as C<mmap>,
are not supported in all environments.  If your program didn't
explicitly request the failing operation, it may be the result of the
value of the environment variable PERLIO.

=item Unknown process %x sent message to prime_env_iter: %s

(P) An error peculiar to VMS.  Perl was reading values for %ENV before
iterating over it, and someone else stuck a message in the stream of
data Perl expected.  Someone's very confused, or perhaps trying to
subvert Perl's population of %ENV for nefarious purposes.

=item Unknown regex modifier "%s"

(F) Alphanumerics immediately following the closing delimiter
of a regular expression pattern are interpreted by Perl as modifier
flags for the regex.  One of the ones you specified is invalid.  One way
this can happen is if you didn't put in white space between the end of
the regex and a following alphanumeric operator:

 if ($a =~ /foo/and $bar == 3) { ... }

The C<"a"> is a valid modifier flag, but the C<"n"> is not, and raises
this error.  Likely what was meant instead was:

 if ($a =~ /foo/ and $bar == 3) { ... }

=item Unknown "re" subpragma '%s' (known ones are: %s)

(W) You tried to use an unknown subpragma of the "re" pragma.

=item Unknown switch condition (?(...)) in regex; marked by S<<-- HERE> in
m/%s/

(F) The condition part of a (?(condition)if-clause|else-clause) construct
is not known.  The condition must be one of the following:

 (1) (2) ...        true if 1st, 2nd, etc., capture matched
 (<NAME>) ('NAME')  true if named capture matched
 (?=...) (?<=...)   true if subpattern matches
 (?!...) (?<!...)   true if subpattern fails to match
 (?{ CODE })        true if code returns a true value
 (R)                true if evaluating inside recursion
 (R1) (R2) ...      true if directly inside capture group 1, 2, etc.
 (R&NAME)           true if directly inside named capture
 (DEFINE)           always false; for defining named subpatterns

The S<<-- HERE> shows whereabouts in the regular expression the problem was
discovered.  See L<perlre>.

=item Unknown Unicode option letter '%c'

(F) You specified an unknown Unicode option.  See L<perlrun> documentation
of the C<-C> switch for the list of known options.

=item Unknown Unicode option value %d

(F) You specified an unknown Unicode option.  See L<perlrun> documentation
of the C<-C> switch for the list of known options.

=item Unknown verb pattern '%s' in regex; marked by S<<-- HERE> in m/%s/

(F) You either made a typo or have incorrectly put a C<*> quantifier
after an open brace in your pattern.  Check the pattern and review
L<perlre> for details on legal verb patterns.

=item Unknown warnings category '%s'

(F) An error issued by the C<warnings> pragma.  You specified a warnings
category that is unknown to perl at this point.

Note that if you want to enable a warnings category registered by a
module (e.g. C<use warnings 'File::Find'>), you must have loaded this
module first.

=item Unmatched [ in regex; marked by S<<-- HERE> in m/%s/

(F) The brackets around a character class must match.  If you wish to
include a closing bracket in a character class, backslash it or put it
first.  The S<<-- HERE> shows whereabouts in the regular expression the
problem was discovered.  See L<perlre>.

=item Unmatched ( in regex; marked by S<<-- HERE> in m/%s/

=item Unmatched ) in regex; marked by S<<-- HERE> in m/%s/

(F) Unbackslashed parentheses must always be balanced in regular
expressions.  If you're a vi user, the % key is valuable for finding
the matching parenthesis.  The S<<-- HERE> shows whereabouts in the
regular expression the problem was discovered.  See L<perlre>.

=item Unmatched right %s bracket

(F) The lexer counted more closing curly or square brackets than opening
ones, so you're probably missing a matching opening bracket.  As a
general rule, you'll find the missing one (so to speak) near the place
you were last editing.

=item Unquoted string "%s" may clash with future reserved word

(W reserved) You used a bareword that might someday be claimed as a
reserved word.  It's best to put such a word in quotes, or capitalize it
somehow, or insert an underbar into it.  You might also declare it as a
subroutine.

=item Unrecognized character %s; marked by S<<-- HERE> after %s near column
%d

(F) The Perl parser has no idea what to do with the specified character
in your Perl script (or eval) near the specified column.  Perhaps you
tried  to run a compressed script, a binary program, or a directory as
a Perl program.

=item Unrecognized escape \%c in character class in regex; marked by
S<<-- HERE> in m/%s/

(F) You used a backslash-character combination which is not
recognized by Perl inside character classes.  This is a fatal
error when the character class is used within C<(?[ ])>.

=item Unrecognized escape \%c in character class passed through in regex; 
marked by S<<-- HERE> in m/%s/

(W regexp) You used a backslash-character combination which is not
recognized by Perl inside character classes.  The character was
understood literally, but this may change in a future version of Perl.
The S<<-- HERE> shows whereabouts in the regular expression the
escape was discovered.

=item Unrecognized escape \%c passed through

(W misc) You used a backslash-character combination which is not
recognized by Perl.  The character was understood literally, but this may
change in a future version of Perl.

=item Unrecognized escape \%s passed through in regex; marked by
S<<-- HERE> in m/%s/

(W regexp) You used a backslash-character combination which is not
recognized by Perl.  The character(s) were understood literally, but
this may change in a future version of Perl.  The S<<-- HERE> shows
whereabouts in the regular expression the escape was discovered.

=item Unrecognized signal name "%s"

(F) You specified a signal name to the kill() function that was not
recognized.  Say C<kill -l> in your shell to see the valid signal names
on your system.

=item Unrecognized switch: -%s  (-h will show valid options)

(F) You specified an illegal option to Perl.  Don't do that.  (If you
think you didn't do that, check the #! line to see if it's supplying the
bad switch on your behalf.)

=item Unsuccessful %s on filename containing newline

(W newline) A file operation was attempted on a filename, and that
operation failed, PROBABLY because the filename contained a newline,
PROBABLY because you forgot to chomp() it off.  See L<perlfunc/chomp>.

=item Unsupported directory function "%s" called

(F) Your machine doesn't support opendir() and readdir().

=item Unsupported function %s

(F) This machine doesn't implement the indicated function, apparently.
At least, Configure doesn't think so.

=item Unsupported function fork

(F) Your version of executable does not support forking.

Note that under some systems, like OS/2, there may be different flavors
of Perl executables, some of which may support fork, some not.  Try
changing the name you call Perl by to C<perl_>, C<perl__>, and so on.

=item Unsupported script encoding %s

(F) Your program file begins with a Unicode Byte Order Mark (BOM) which
declares it to be in a Unicode encoding that Perl cannot read.

=item Unsupported socket function "%s" called

(F) Your machine doesn't support the Berkeley socket mechanism, or at
least that's what Configure thought.

=item Unterminated attribute list

(F) The lexer found something other than a simple identifier at the
start of an attribute, and it wasn't a semicolon or the start of a
block.  Perhaps you terminated the parameter list of the previous
attribute too soon.  See L<attributes>.

=item Unterminated attribute parameter in attribute list

(F) The lexer saw an opening (left) parenthesis character while parsing
an attribute list, but the matching closing (right) parenthesis
character was not found.  You may need to add (or remove) a backslash
character to get your parentheses to balance.  See L<attributes>.

=item Unterminated compressed integer

(F) An argument to unpack("w",...) was incompatible with the BER
compressed integer format and could not be converted to an integer.
See L<perlfunc/pack>.

=item Unterminated delimiter for here document

(F) This message occurs when a here document label has an initial
quotation mark but the final quotation mark is missing.  Perhaps
you wrote:

    <<"foo

instead of:

    <<"foo"

=item Unterminated \g... pattern in regex; marked by S<<-- HERE> in m/%s/

=item Unterminated \g{...} pattern in regex; marked by S<<-- HERE> in m/%s/

(F) In a regular expression, you had a C<\g> that wasn't followed by a
proper group reference.  In the case of C<\g{>, the closing brace is
missing; otherwise the C<\g> must be followed by an integer.  Fix the
pattern and retry.

=item Unterminated <> operator

(F) The lexer saw a left angle bracket in a place where it was expecting
a term, so it's looking for the corresponding right angle bracket, and
not finding it.  Chances are you left some needed parentheses out
earlier in the line, and you really meant a "less than".

=item Unterminated verb pattern argument in regex; marked by S<<-- HERE> in
m/%s/

(F) You used a pattern of the form C<(*VERB:ARG)> but did not terminate
the pattern with a C<)>.  Fix the pattern and retry.

=item Unterminated verb pattern in regex; marked by S<<-- HERE> in m/%s/

(F) You used a pattern of the form C<(*VERB)> but did not terminate
the pattern with a C<)>.  Fix the pattern and retry.

=item untie attempted while %d inner references still exist

(W untie) A copy of the object returned from C<tie> (or C<tied>) was
still valid when C<untie> was called.

=item Usage: POSIX::%s(%s)

(F) You called a POSIX function with incorrect arguments.
See L<POSIX/FUNCTIONS> for more information.

=item Usage: Win32::%s(%s)

(F) You called a Win32 function with incorrect arguments.
See L<Win32> for more information.

=item $[ used in %s (did you mean $] ?)

(W syntax) You used C<$[> in a comparison, such as:

    if ($[ > 5.006) {
	...
    }

You probably meant to use C<$]> instead.  C<$[> is the base for indexing
arrays.  C<$]> is the Perl version number in decimal.

=item Use "%s" instead of "%s"

(F) The second listed construct is no longer legal.  Use the first one
instead.

=item Useless assignment to a temporary

(W misc) You assigned to an lvalue subroutine, but what
the subroutine returned was a temporary scalar about to
be discarded, so the assignment had no effect.

=item Useless (?-%s) - don't use /%s modifier in regex; marked by
S<<-- HERE> in m/%s/

(W regexp) You have used an internal modifier such as (?-o) that has no
meaning unless removed from the entire regexp:

    if ($string =~ /(?-o)$pattern/o) { ... }

must be written as

    if ($string =~ /$pattern/) { ... }

The S<<-- HERE> shows whereabouts in the regular expression the problem was
discovered.  See L<perlre>.

=item Useless localization of %s

(W syntax) The localization of lvalues such as C<local($x=10)> is legal,
but in fact the local() currently has no effect.  This may change at
some point in the future, but in the meantime such code is discouraged.

=item Useless (?%s) - use /%s modifier in regex; marked by S<<-- HERE> in
m/%s/

(W regexp) You have used an internal modifier such as (?o) that has no
meaning unless applied to the entire regexp:

    if ($string =~ /(?o)$pattern/) { ... }

must be written as

    if ($string =~ /$pattern/o) { ... }

The S<<-- HERE> shows whereabouts in the regular expression the problem was
discovered.  See L<perlre>.

=item Useless use of attribute "const"

(W misc) The C<const> attribute has no effect except
on anonymous closure prototypes.  You applied it to
a subroutine via L<attributes.pm|attributes>.  This is only useful
inside an attribute handler for an anonymous subroutine.

=item Useless use of /d modifier in transliteration operator

(W misc) You have used the /d modifier where the searchlist has the
same length as the replacelist.  See L<perlop> for more information
about the /d modifier.

=item Useless use of \E

(W misc) You have a \E in a double-quotish string without a C<\U>,
C<\L> or C<\Q> preceding it.

=item Useless use of greediness modifier '%c' in regex; marked by S<<-- HERE> in m/%s/

(W regexp) You specified something like these:

 qr/a{3}?/
 qr/b{1,1}+/

The C<"?"> and C<"+"> don't have any effect, as they modify whether to
match more or fewer when there is a choice, and by specifying to match
exactly a given numer, there is no room left for a choice.

=item Useless use of %s in void context

(W void) You did something without a side effect in a context that does
nothing with the return value, such as a statement that doesn't return a
value from a block, or the left side of a scalar comma operator.  Very
often this points not to stupidity on your part, but a failure of Perl
to parse your program the way you thought it would.  For example, you'd
get this if you mixed up your C precedence with Python precedence and
said

    $one, $two = 1, 2;

when you meant to say

    ($one, $two) = (1, 2);

Another common error is to use ordinary parentheses to construct a list
reference when you should be using square or curly brackets, for
example, if you say

    $array = (1,2);

when you should have said

    $array = [1,2];

The square brackets explicitly turn a list value into a scalar value,
while parentheses do not.  So when a parenthesized list is evaluated in
a scalar context, the comma is treated like C's comma operator, which
throws away the left argument, which is not what you want.  See
L<perlref> for more on this.

This warning will not be issued for numerical constants equal to 0 or 1
since they are often used in statements like

    1 while sub_with_side_effects();

String constants that would normally evaluate to 0 or 1 are warned
about.

=item Useless use of (?-p) in regex; marked by S<<-- HERE> in m/%s/

(W regexp) The C<p> modifier cannot be turned off once set.  Trying to do
so is futile.

=item Useless use of "re" pragma

(W) You did C<use re;> without any arguments.  That isn't very useful.

=item Useless use of sort in scalar context

(W void) You used sort in scalar context, as in :

    my $x = sort @@y;

This is not very useful, and perl currently optimizes this away.

=item Useless use of %s with no values

(W syntax) You used the push() or unshift() function with no arguments
apart from the array, like C<push(@@x)> or C<unshift(@@foo)>.  That won't
usually have any effect on the array, so is completely useless.  It's
possible in principle that push(@@tied_array) could have some effect
if the array is tied to a class which implements a PUSH method.  If so,
you can write it as C<push(@@tied_array,())> to avoid this warning.

=item "use" not allowed in expression

(F) The "use" keyword is recognized and executed at compile time, and
returns no useful value.  See L<perlmod>.

=item Use of assignment to $[ is deprecated

(D deprecated) The C<$[> variable (index of the first element in an array)
is deprecated.  See L<perlvar/"$[">.

=item Use of bare << to mean <<"" is deprecated

(D deprecated) You are now encouraged to use the explicitly quoted
form if you wish to use an empty line as the terminator of the
here-document.

=item Use of /c modifier is meaningless in s///

(W regexp) You used the /c modifier in a substitution.  The /c
modifier is not presently meaningful in substitutions.

=item Use of /c modifier is meaningless without /g

(W regexp) You used the /c modifier with a regex operand, but didn't
use the /g modifier.  Currently, /c is meaningful only when /g is
used.  (This may change in the future.)

=item Use of code point 0x%s is deprecated; the permissible max is 0x%s

(D deprecated) You used a code point that will not be allowed in a
future perl version, because it is too large.  Unicode only allows code
points up to 0x10FFFF, but Perl allows much larger ones.  However, the
largest possible ones break the perl interpreter in some constructs,
including causing it to hang in a few cases.  The known problem areas
are in C<tr///>, regular expression pattern matching using quantifiers,
and as the upper limits in loops.

If your code is to run on various platforms, keep in mind that the upper
limit depends on the platform.  It is much larger on 64-bit word sizes
than 32-bit ones.

=item Use of comma-less variable list is deprecated

(D deprecated) The values you give to a format should be
separated by commas, not just aligned on a line.

=item Use of each() on hash after insertion without resetting hash iterator results in undefined behavior

(S internal) The behavior of C<each()> after insertion is undefined;
it may skip items, or visit items more than once.  Consider using
C<keys()> instead of C<each()>.

=item Use of := for an empty attribute list is not allowed

(F) The construction C<my $x := 42> used to parse as equivalent to
C<my $x : = 42> (applying an empty attribute list to C<$x>).
This construct was deprecated in 5.12.0, and has now been made a syntax
error, so C<:=> can be reclaimed as a new operator in the future.

If you need an empty attribute list, for example in a code generator, add
a space before the C<=>.

=item Use of %s for non-UTF-8 locale is wrong.  Assuming a UTF-8 locale

(W locale)  You are matching a regular expression using locale rules,
and the specified construct was encountered.  This construct is only
valid for UTF-8 locales, which the current locale isn't.  This doesn't
make sense.  Perl will continue, assuming a Unicode (UTF-8) locale, but
the results are likely to be wrong.

=item Use of freed value in iteration

(F) Perhaps you modified the iterated array within the loop?
This error is typically caused by code like the following:

    @@a = (3,4);
    @@a = () for (1,2,@@a);

You are not supposed to modify arrays while they are being iterated over.
For speed and efficiency reasons, Perl internally does not do full
reference-counting of iterated items, hence deleting such an item in the
middle of an iteration causes Perl to see a freed value.

=item Use of *glob{FILEHANDLE} is deprecated

(D deprecated) You are now encouraged to use the shorter *glob{IO} form
to access the filehandle slot within a typeglob.

=item Use of /g modifier is meaningless in split

(W regexp) You used the /g modifier on the pattern for a C<split>
operator.  Since C<split> always tries to match the pattern
repeatedly, the C</g> has no effect.

=item Use of "goto" to jump into a construct is deprecated

(D deprecated) Using C<goto> to jump from an outer scope into an inner
scope is deprecated and should be avoided.

=item Use of inherited AUTOLOAD for non-method %s() is deprecated

(D deprecated) As an (ahem) accidental feature, C<AUTOLOAD>
subroutines are looked up as methods (using the C<@@ISA> hierarchy)
even when the subroutines to be autoloaded were called as plain
functions (e.g. C<Foo::bar()>), not as methods (e.g. C<< Foo->bar() >> or
C<< $obj->bar() >>).

This bug will be rectified in future by using method lookup only for
methods' C<AUTOLOAD>s.  However, there is a significant base of existing
code that may be using the old behavior.  So, as an interim step, Perl
currently issues an optional warning when non-methods use inherited
C<AUTOLOAD>s.

The simple rule is:  Inheritance will not work when autoloading
non-methods.  The simple fix for old code is:  In any module that used
to depend on inheriting C<AUTOLOAD> for non-methods from a base class
named C<BaseClass>, execute C<*AUTOLOAD = \&BaseClass::AUTOLOAD> during
startup.

In code that currently says C<use AutoLoader; @@ISA = qw(AutoLoader);>
you should remove AutoLoader from @@ISA and change C<use AutoLoader;> to
C<use AutoLoader 'AUTOLOAD';>.

=item Use of %s in printf format not supported

(F) You attempted to use a feature of printf that is accessible from
only C.  This usually means there's a better way to do it in Perl.

=item Use of %s is deprecated

(D deprecated) The construct indicated is no longer recommended for use,
generally because there's a better way to do it, and also because the
old way has bad side effects.

=item Use of literal control characters in variable names is deprecated

=item Use of literal non-graphic characters in variable names is deprecated

(D deprecated) Using literal non-graphic (including control)
characters in the source to refer to the ^FOO variables, like C<$^X> and
C<${^GLOBAL_PHASE}> is now deprecated.  (We use C<^X> and C<^G> here for
legibility.  They actually represent the non-printable control
characters, code points 0x18 and 0x07, respectively; C<^A> would mean
the control character whose code point is 0x01.) This only affects
code like C<$\cT>, where C<\cT> is a control in the source code; C<${"\cT"}> and
C<$^T> remain valid.  Things that are non-controls and also not graphic
are NO-BREAK SPACE and SOFT HYPHEN, which were previously only allowed
for historical reasons.

=item Use of -l on filehandle%s

(W io) A filehandle represents an opened file, and when you opened the file
it already went past any symlink you are presumably trying to look for.
The operation returned C<undef>.  Use a filename instead.

=item Use of %s on a handle without * is deprecated

(D deprecated) You used C<tie>, C<tied> or C<untie> on a scalar but that scalar
happens to hold a typeglob, which means its filehandle will be tied.  If
you mean to tie a handle, use an explicit * as in C<tie *$handle>.

This was a long-standing bug that was removed in Perl 5.16, as there was
no way to tie the scalar itself when it held a typeglob, and no way to
untie a scalar that had had a typeglob assigned to it.  If you see this
message, you must be using an older version.

=item Use of reference "%s" as array index

(W misc) You tried to use a reference as an array index; this probably
isn't what you mean, because references in numerical context tend
to be huge numbers, and so usually indicates programmer error.

If you really do mean it, explicitly numify your reference, like so:
C<$array[0+$ref]>.  This warning is not given for overloaded objects,
however, because you can overload the numification and stringification
operators and then you presumably know what you are doing.

=item Use of state $_ is experimental

(S experimental::lexical_topic) Lexical $_ is an experimental feature and
its behavior may change or even be removed in any future release of perl.
See the explanation under L<perlvar/$_>.

=item Use of strings with code points over 0xFF as arguments to %s
operator is deprecated

(D deprecated) You tried to use one of the string bitwise operators
(C<&> or C<|> or C<^> or C<~>) on a string containing a code point over
0xFF.  The string bitwise operators treat their operands as strings of
bytes, and values beyond 0xFF are nonsensical in this context.

=item Use of tainted arguments in %s is deprecated

(W taint, deprecated) You have supplied C<system()> or C<exec()> with multiple
arguments and at least one of them is tainted.  This used to be allowed
but will become a fatal error in a future version of perl.  Untaint your
arguments.  See L<perlsec>.

=item Use of uninitialized value%s

(W uninitialized) An undefined value was used as if it were already
defined.  It was interpreted as a "" or a 0, but maybe it was a mistake.
To suppress this warning assign a defined value to your variables.

To help you figure out what was undefined, perl will try to tell you
the name of the variable (if any) that was undefined.  In some cases
it cannot do this, so it also tells you what operation you used the
undefined value in.  Note, however, that perl optimizes your program
and the operation displayed in the warning may not necessarily appear
literally in your program.  For example, C<"that $foo"> is usually
optimized into C<"that " . $foo>, and the warning will refer to the
C<concatenation (.)> operator, even though there is no C<.> in
your program.

=item "use re 'strict'" is experimental

(S experimental::re_strict) The things that are different when a regular
expression pattern is compiled under C<'strict'> are subject to change
in future Perl releases in incompatible ways.  This means that a pattern
that compiles today may not in a future Perl release.  This warning is
to alert you to that risk.

=item Use \x{...} for more than two hex characters in regex; marked by
S<<-- HERE> in m/%s/

(F) In a regular expression, you said something like

 (?[ [ \xBEEF ] ])

Perl isn't sure if you meant this

 (?[ [ \x{BEEF} ] ])

or if you meant this

 (?[ [ \x{BE} E F ] ])

You need to add either braces or blanks to disambiguate.

=item Using just the first character returned by \N{} in character class in 
regex; marked by S<<-- HERE> in m/%s/

(W regexp) Named Unicode character escapes C<(\N{...})> may return
a multi-character sequence.  Even though a character class is
supposed to match just one character of input, perl will match
the whole thing correctly, except when the class is inverted
(C<[^...]>), or the escape is the beginning or final end point of
a range.  For these, what should happen isn't clear at all.  In
these circumstances, Perl discards all but the first character
of the returned sequence, which is not likely what you want.

=item Using /u for '%s' instead of /%s in regex; marked by S<<-- HERE> in m/%s/

(W regexp) You used a Unicode boundary (C<\b{...}> or C<\B{...}>) in a
portion of a regular expression where the character set modifiers C</a>
or C</aa> are in effect.  These two modifiers indicate an ASCII
interpretation, and this doesn't make sense for a Unicode defintion.
The generated regular expression will compile so that the boundary uses
all of Unicode.  No other portion of the regular expression is affected.

=item Using !~ with %s doesn't make sense

(F) Using the C<!~> operator with C<s///r>, C<tr///r> or C<y///r> is
currently reserved for future use, as the exact behavior has not
been decided.  (Simply returning the boolean opposite of the
modified string is usually not particularly useful.)

=item UTF-16 surrogate U+%X

(S surrogate) You had a UTF-16 surrogate in a context where they are
not considered acceptable.  These code points, between U+D800 and
U+DFFF (inclusive), are used by Unicode only for UTF-16.  However, Perl
internally allows all unsigned integer code points (up to the size limit
available on your platform), including surrogates.  But these can cause
problems when being input or output, which is likely where this message
came from.  If you really really know what you are doing you can turn
off this warning by C<no warnings 'surrogate';>.

=item Value of %s can be "0"; test with defined()

(W misc) In a conditional expression, you used <HANDLE>, <*> (glob),
C<each()>, or C<readdir()> as a boolean value.  Each of these constructs
can return a value of "0"; that would make the conditional expression
false, which is probably not what you intended.  When using these
constructs in conditional expressions, test their values with the
C<defined> operator.

=item Value of CLI symbol "%s" too long

(W misc) A warning peculiar to VMS.  Perl tried to read the value of an
%ENV element from a CLI symbol table, and found a resultant string
longer than 1024 characters.  The return value has been truncated to
1024 characters.

=item Variable "%s" is not available

(W closure) During compilation, an inner named subroutine or eval is
attempting to capture an outer lexical that is not currently available.
This can happen for one of two reasons.  First, the outer lexical may be
declared in an outer anonymous subroutine that has not yet been created.
(Remember that named subs are created at compile time, while anonymous
subs are created at run-time.)  For example,

    sub { my $a; sub f { $a } }

At the time that f is created, it can't capture the current value of $a,
since the anonymous subroutine hasn't been created yet.  Conversely,
the following won't give a warning since the anonymous subroutine has by
now been created and is live:

    sub { my $a; eval 'sub f { $a }' }->();

The second situation is caused by an eval accessing a variable that has
gone out of scope, for example,

    sub f {
	my $a;
	sub { eval '$a' }
    }
    f()->();

Here, when the '$a' in the eval is being compiled, f() is not currently
being executed, so its $a is not available for capture.

=item Variable "%s" is not imported%s

(S misc) With "use strict" in effect, you referred to a global variable
that you apparently thought was imported from another module, because
something else of the same name (usually a subroutine) is exported by
that module.  It usually means you put the wrong funny character on the
front of your variable.

=item Variable length lookbehind not implemented in regex m/%s/

(F) Lookbehind is allowed only for subexpressions whose length is fixed and
known at compile time.  For positive lookbehind, you can use the C<\K>
regex construct as a way to get the equivalent functionality.  See
L<perlre/(?<=pattern) \K>.

There are non-obvious Unicode rules under C</i> that can match variably,
but which you might not think could.  For example, the substring C<"ss">
can match the single character LATIN SMALL LETTER SHARP S.  There are
other sequences of ASCII characters that can match single ligature
characters, such as LATIN SMALL LIGATURE FFI matching C<qr/ffi/i>.
Starting in Perl v5.16, if you only care about ASCII matches, adding the
C</aa> modifier to the regex will exclude all these non-obvious matches,
thus getting rid of this message.  You can also say C<S<use re qw(/aa)>>
to apply C</aa> to all regular expressions compiled within its scope.
See L<re>.

=item "%s" variable %s masks earlier declaration in same %s

(W misc) A "my", "our" or "state" variable has been redeclared in the
current scope or statement, effectively eliminating all access to the
previous instance.  This is almost always a typographical error.  Note
that the earlier variable will still exist until the end of the scope
or until all closure references to it are destroyed.

=item Variable syntax

(A) You've accidentally run your script through B<csh> instead
of Perl.  Check the #! line, or manually feed your script into
Perl yourself.

=item Variable "%s" will not stay shared

(W closure) An inner (nested) I<named> subroutine is referencing a
lexical variable defined in an outer named subroutine.

When the inner subroutine is called, it will see the value of
the outer subroutine's variable as it was before and during the *first*
call to the outer subroutine; in this case, after the first call to the
outer subroutine is complete, the inner and outer subroutines will no
longer share a common value for the variable.  In other words, the
variable will no longer be shared.

This problem can usually be solved by making the inner subroutine
anonymous, using the C<sub {}> syntax.  When inner anonymous subs that
reference variables in outer subroutines are created, they
are automatically rebound to the current values of such variables.

=item vector argument not supported with alpha versions

(S printf) The %vd (s)printf format does not support version objects
with alpha parts.

=item Verb pattern '%s' has a mandatory argument in regex; marked by
S<<-- HERE> in m/%s/ 

(F) You used a verb pattern that requires an argument.  Supply an
argument or check that you are using the right verb.

=item Verb pattern '%s' may not have an argument in regex; marked by
S<<-- HERE> in m/%s/ 

(F) You used a verb pattern that is not allowed an argument.  Remove the 
argument or check that you are using the right verb.

=item Version number must be a constant number

(P) The attempt to translate a C<use Module n.n LIST> statement into
its equivalent C<BEGIN> block found an internal inconsistency with
the version number.

=item Version string '%s' contains invalid data; ignoring: '%s'

(W misc) The version string contains invalid characters at the end, which
are being ignored.

=item Warning: something's wrong

(W) You passed warn() an empty string (the equivalent of C<warn "">) or
you called it with no args and C<$@@> was empty.

=item Warning: unable to close filehandle %s properly

(S) The implicit close() done by an open() got an error indication on
the close().  This usually indicates your file system ran out of disk
space.

=item Warning: unable to close filehandle properly: %s

=item Warning: unable to close filehandle %s properly: %s

(S io) There were errors during the implicit close() done on a filehandle
when its reference count reached zero while it was still open, e.g.:

    {
        open my $fh, '>', $file  or die "open: '$file': $!\n";
        print $fh $data or die "print: $!";
    } # implicit close here

Because various errors may only be detected by close() (e.g. buffering could
allow the C<print> in this example to return true even when the disk is full),
it is dangerous to ignore its result. So when it happens implicitly, perl will
signal errors by warning.

B<Prior to version 5.22.0, perl ignored such errors>, so the common idiom shown
above was liable to cause B<silent data loss>.

=item Warning: Use of "%s" without parentheses is ambiguous

(S ambiguous) You wrote a unary operator followed by something that
looks like a binary operator that could also have been interpreted as a
term or unary operator.  For instance, if you know that the rand
function has a default argument of 1.0, and you write

    rand + 5;

you may THINK you wrote the same thing as

    rand() + 5;

but in actual fact, you got

    rand(+5);

So put in parentheses to say what you really mean.

=item when is experimental

(S experimental::smartmatch) C<when> depends on smartmatch, which is
experimental.  Additionally, it has several special cases that may
not be immediately obvious, and their behavior may change or
even be removed in any future release of perl.  See the explanation
under L<perlsyn/Experimental Details on given and when>.

=item Wide character in %s

(S utf8) Perl met a wide character (>255) when it wasn't expecting
one.  This warning is by default on for I/O (like print).  The easiest
way to quiet this warning is simply to add the C<:utf8> layer to the
output, e.g. C<binmode STDOUT, ':utf8'>.  Another way to turn off the
warning is to add C<no warnings 'utf8';> but that is often closer to
cheating.  In general, you are supposed to explicitly mark the
filehandle with an encoding, see L<open> and L<perlfunc/binmode>.

=item Wide character (U+%X) in %s

(W locale) While in a single-byte locale (I<i.e.>, a non-UTF-8
one), a multi-byte character was encountered.   Perl considers this
character to be the specified Unicode code point.  Combining non-UTF-8
locales and Unicode is dangerous.  Almost certainly some characters
will have two different representations.  For example, in the ISO 8859-7
(Greek) locale, the code point 0xC3 represents a Capital Gamma.  But so
also does 0x393.  This will make string comparisons unreliable.

You likely need to figure out how this multi-byte character got mixed up
with your single-byte locale (or perhaps you thought you had a UTF-8
locale, but Perl disagrees).

=item Within []-length '%c' not allowed

(F) The count in the (un)pack template may be replaced by C<[TEMPLATE]>
only if C<TEMPLATE> always matches the same amount of packed bytes that
can be determined from the template alone.  This is not possible if
it contains any of the codes @@, /, U, u, w or a *-length.  Redesign
the template.

=item %s() with negative argument

(S misc) Certain operations make no sense with negative arguments.
Warning is given and the operation is not done.

=item write() on closed filehandle %s

(W closed) The filehandle you're writing to got itself closed sometime
before now.  Check your control flow.

=item %s "\x%X" does not map to Unicode

(S utf8) When reading in different encodings, Perl tries to
map everything into Unicode characters.  The bytes you read
in are not legal in this encoding.  For example

    utf8 "\xE4" does not map to Unicode

if you try to read in the a-diaereses Latin-1 as UTF-8.

=item 'X' outside of string

(F) You had a (un)pack template that specified a relative position before
the beginning of the string being (un)packed.  See L<perlfunc/pack>.

=item 'x' outside of string in unpack

(F) You had a pack template that specified a relative position after
the end of the string being unpacked.  See L<perlfunc/pack>.

=item YOU HAVEN'T DISABLED SET-ID SCRIPTS IN THE KERNEL YET!

(F) And you probably never will, because you probably don't have the
sources to your kernel, and your vendor probably doesn't give a rip
about what you want.  Your best bet is to put a setuid C wrapper around
your script.

=item You need to quote "%s"

(W syntax) You assigned a bareword as a signal handler name.
Unfortunately, you already have a subroutine of that name declared,
which means that Perl 5 will try to call the subroutine when the
assignment is executed, which is probably not what you want.  (If it IS
what you want, put an & in front.)

=item Your random numbers are not that random

(F) When trying to initialize the random seed for hashes, Perl could
not get any randomness out of your system.  This usually indicates
Something Very Wrong.

=item Zero length \N{} in regex; marked by S<<-- HERE> in m/%s/

(F) Named Unicode character escapes (C<\N{...}>) may return a zero-length
sequence.  Such an escape was used in an extended character class, i.e.
C<(?[...])>, or under C<use re 'strict'>, which is not permitted.  Check
that the correct escape has been used, and the correct charnames handler
is in scope.  The S<<-- HERE> shows whereabouts in the regular
expression the problem was discovered.

=back

=head1 SEE ALSO

L<warnings>, L<diagnostics>.

=cut
@


1.18
log
@Fix merge issues, remove excess files - match perl-5.20.2 dist
@
text
@d53 13
d75 5
d197 5
d212 1
a212 1
=item Array @@%s missing the @@ in argument %d of %s()
d214 4
a217 2
(D deprecated) Really old Perl let you omit the @@ on array names in some
spots.  This is now heavily deprecated.
d219 1
a219 1
=item A sequence of multiple spaces in a charnames alias definition is deprecated
d221 2
a222 5
(D deprecated) You defined a character name which had multiple space
characters in a row.  Change them to single spaces.  Usually these
names are defined in the C<:alias> import argument to C<use charnames>, but
they could be defined by a translator installed into C<$^H{charnames}>.
See L<charnames/CUSTOM ALIASES>.
d232 17
d260 32
a584 12
=item "\b{" is deprecated; use "\b\{" or "\b[{]" instead in regex; marked
by S<<-- HERE> in m/%s/

=item "\B{" is deprecated; use "\B\{" or "\B[{]" instead in regex; marked
by S<<-- HERE> in m/%s/

(D deprecated) Use of an unescaped "{" immediately following
a C<\b> or C<\B> is now deprecated so as to reserve its use for Perl
itself in a future release.  You can either precede the brace
with a backslash, or enclose it in square brackets; the latter
is the way to go if the pattern delimiters are C<{}>.

d599 16
d642 9
d653 3
a655 3
(F) An argument to pack("w",...) was too large to compress.  The BER
compressed integer format can only be used with positive integers, and you
attempted to compress Infinity or a very large number (> 1e308).
d680 10
d702 8
d837 27
a907 7
=item Can't find %s character property "%s"

(F) You used C<\p{}> or C<\P{}> but the character property by that name
could not be found.  Maybe you misspelled the name of the property?
See L<perluniprops/Properties accessible through \p{} and \P{}>
for a complete list of available official properties.

d940 4
a943 3
(F) You may have tried to use C<\p> which means a Unicode
property (for example C<\p{Lu}> matches all uppercase
letters).  If you did mean to use a Unicode property, see
d945 8
a952 3
for a complete list of available properties.  If you didn't
mean to use a Unicode property, escape the C<\p>, either by
C<\\p> (just the C<\p>) or by C<\Q\p> (the rest of the string, or
d1147 1
a1147 1
=item Can't modify non-lvalue subroutine call
d1152 22
a1187 6
=item Can't open %s

(F) You tried to run a perl built with MAD support with
the PERL_XMLDUMP environment variable set, but the file
named by that variable could not be opened.

d1256 5
d1286 7
d1361 14
d1403 28
d1433 1
a1433 2
(F) Only a simple scalar variable may be used as a loop variable on a
foreach.
d1511 1
a1511 6
(F)(D deprecated, syntax) In C<\cI<X>>, I<X> must be a printable
(non-control) ASCII character.  This is fatal starting in v5.20 for
non-ASCII characters, and it is planned to make this fatal in all
instances in Perl v5.22.  In
the cases where it isn't fatal, the character this evaluates to is
derived by exclusive or'ing the code point of this character with 0x40.
d1514 1
a1514 1
discouraged here as well, and will generate the warning (when enabled)
d1517 7
d1602 20
d1649 9
d1663 19
d1687 11
a1697 6
Perl allows strings to contain a superset of Unicode code points, up
to the limit of what is storable in an unsigned integer on your system,
but these may not be accepted by other languages/systems.  At one time,
it was legal in some standards to have code points up to 0x7FFF_FFFF,
but not higher.  Code points above 0xFFFF_FFFF require larger than a
32 bit word.
d1702 2
a1703 2
instead of Perl.  Check the #! line, or manually feed your script
into Perl yourself.  The #! line at the top of your file could look like
d1751 36
d1804 14
a1817 1
forgot to load the corresponding L<overload> pragma?.
a1879 29
=item defined(@@array) is deprecated

(D deprecated) defined() is not usually useful on arrays because it
checks for an undefined I<scalar> value.  If you want to see if the
array is empty, just use C<if (@@array) { # not empty }> for example.

=item defined(%hash) is deprecated

(D deprecated) C<defined()> is not usually right on hashes and has been
discouraged since 5.004.

Although C<defined %hash> is false on a plain not-yet-used hash, it
becomes true in several non-obvious circumstances, including iterators,
weak references, stash names, even remaining true after C<undef %hash>.
These things make C<defined %hash> fairly useless in practice.

If a check for non-empty is what you wanted then just put it in boolean
context (see L<perldata/Scalar values>):

    if (%hash) {
       # not empty
    }

If you had C<defined %Foo::Bar::QUUX> to check whether such a package
variable exists then that's never really been reliable, and isn't
a good way to enquire about the features of a package, or whether
it's loaded, etc.


d1887 1
a1887 1
The <-- HERE shows whereabouts in the regular expression the problem was
a2041 8
=item each on reference is experimental

(S experimental::autoderef) C<each> with a scalar argument is experimental
and may change or be removed in a future Perl version.  If you want to
take the risk of using this feature, simply disable this warning:

    no warnings "experimental::autoderef";

d2049 2
a2075 17
=item Escape literal pattern white space under /x

(D deprecated) You compiled a regular expression pattern with C</x> to
ignore white space, and you used, as a literal, one of the characters
that Perl plans to eventually treat as white space.  The character must
be escaped somehow, or it will work differently on a future Perl that
does treat it as white space.  The easiest way is to insert a backslash
immediately before it, or to enclose it with square brackets.  This
change is to bring Perl into conformance with Unicode recommendations.
Here are the five characters that generate this warning:
U+0085 NEXT LINE,
U+200E LEFT-TO-RIGHT MARK,
U+200F RIGHT-TO-LEFT MARK,
U+2028 LINE SEPARATOR,
and
U+2029 PARAGRAPH SEPARATOR.

d2104 1
a2104 1
The <-- HERE shows whereabouts in the regular expression the problem was
d2184 15
d2233 5
d2378 2
a2379 1
=item Global symbol "%s" requires explicit package name
a2461 5
=item Hash %%s missing the % in argument %d of %s()

(D deprecated) Really old Perl let you omit the % on hash names in some
spots.  This is now heavily deprecated.

d2467 40
d2524 3
a2526 3
zero-length sequence.  When such an escape is used in a character class
its behaviour is not well defined.  Check that the correct escape has
been used, and the correct charname handler is in scope.
d2611 4
d2620 9
a2667 6
=item In EBCDIC the v-string components cannot exceed 2147483647

(F) An error peculiar to EBCDIC.  Internally, v-strings are stored as
Unicode code points, and encoded in EBCDIC as UTF-EBCDIC.  The UTF-EBCDIC
encoding is limited to code points no larger than 2147483647 (0x7FFFFFFF).

a2735 11
=item In '(?...)', splitting the initial '(?' is deprecated in regex;
marked by S<<-- HERE> in m/%s/

(D regexp, deprecated) The two-character sequence C<"(?"> in
this context in a regular expression pattern should be an
indivisible token, with nothing intervening between the C<"(">
and the C<"?">, but you separated them.  Due to an accident of
implementation, this prohibition was not enforced, but we do
plan to forbid it in a future Perl version.  This message
serves as giving you fair warning of this pending change.

d2810 8
d2891 5
d2902 7
d2972 1
a2972 1
=item In '(*VERB...)', splitting the initial '(*' is deprecated in regex;
d2975 1
a2975 1
(D regexp, deprecated) The two-character sequence C<"(*"> in
d2978 1
a2978 4
and the C<"*">, but you separated them.  Due to an accident of
implementation, this prohibition was not enforced, but we do
plan to forbid it in a future Perl version.  This message
serves as giving you fair warning of this pending change.
d3001 34
a3077 8
=item keys on reference is experimental

(S experimental::autoderef) C<keys> with a scalar argument is experimental
and may change or be removed in a future Perl version.  If you want to
take the risk of using this feature, simply disable this warning:

    no warnings "experimental::autoderef";

d3145 38
d3418 7
a3424 2
(W uninitialized) A printf-type format required more arguments than were
supplied.
d3481 6
d3616 7
d3628 5
d3654 4
a3657 4
NOTE: This warning detects package symbols that have been used only
once. This means lexical variables will never trigger this warning.
It also means that all of the package variables $c, @@c, %c, as well
as *c, &c, sub c{}, c(), and c (the filehandle or
d3697 6
d3731 1
a3731 2
=item \N{} in character class restricted to one character in regex; marked
by S<<-- HERE> in m/%s/
d3734 13
a3746 5
multi-character sequence.  Such an escape may not be used in
a character class, because character classes always match one
character of input.  Check that the correct escape has been used,
and the correct charname handler is in scope.  The S<<-- HERE> shows
whereabouts in the regular expression the problem was discovered.
d3787 8
d3877 6
d3931 1
a3931 1
semantics.  Such syntax is reserved for future extensions.
a4056 5
=item Null filename used

(F) You can't require the null filename, especially because on many
machines that means the current directory!  See L<perlfunc/require>.

d4131 1
a4131 1
for I/O (in anticipation of future reads and to imitate the behaviour
d4186 1
a4186 1
(S non_unicode) You performed an operation requiring Unicode semantics
d4199 1
a4199 1
semantics on a Unicode surrogate.  Unicode frowns upon the use
d4201 1
a4201 1
semantics are (reluctantly) defined for the surrogates, and
a4363 5
=item panic: die %s

(P) We popped the context stack to an eval context, and then discovered
it wasn't an eval context.

d4379 1
a4379 1
=item panic: frexp
d4448 2
a4449 1
(P) An invalid scratch pad offset was detected internally.
d4458 3
a4460 1
(P) An invalid scratch pad offset was detected internally.
d4592 6
a4597 1
=item Perl folding rules are not up-to-date for 0x%X; please use the perlbug 
d4605 8
d4705 1
a4705 9
=item pop on reference is experimental

(S experimental::autoderef) C<pop> with a scalar argument is experimental
and may change or be removed in a future Perl version.  If you want to
take the risk of using this feature, simply disable this warning:

    no warnings "experimental::autoderef";

=item POSIX class [:%s:] unknown in regex; marked by S<< <-- HERE in m/%s/ >>
d4718 1
a4718 1
=item POSIX syntax [%c %c] belongs inside character classes in regex; marked by 
d4721 11
a4731 3
(W regexp) The character class constructs [: :], [= =], and [. .]  go
I<inside> character classes, the [] are part of the construct, for example:
/[012[:alpha:]345]/.  Note that [= =] and [. .] are not currently
d4736 3
d4833 1
a4833 1
=item Possible precedence problem on bitwise %c operator
a4865 15
=item Postfix dereference is experimental

(S experimental::postderef) This warning is emitted if you use
the experimental postfix dereference syntax.  Simply suppress the
warning if you want to use the feature, but know that in doing
so you are taking the risk of using an experimental feature which
may change or be removed in a future Perl version:

    no warnings "experimental::postderef";
    use feature "postderef", "postderef_qq";
    $ref->$*;
    $aref->@@*;
    $aref->@@[@@indices];
    ... etc ...

a4902 10
=item Property '%s' is unknown in regex; marked by S<<-- HERE> in m/%s/

(F) The named property which you specified via C<\p> or C<\P> is not one
known to Perl.  Perhaps you misspelled the name?  See
L<perluniprops/Properties accessible through \p{} and \P{}>
for a complete list of available official
properties.  If it is a L<user-defined property|perlunicode/User-Defined Character Properties>
it must have been defined by the time the regular expression is
compiled.

d4925 1
a4925 33
=item \p{} uses Unicode rules, not locale rules

(W) You compiled a regular expression that contained a Unicode property
match (C<\p> or C<\P>), but the regular expression is also being told to
use the run-time locale, not Unicode.  Instead, use a POSIX character
class, which should know about the locale's rules.
(See L<perlrecharclass/POSIX Character Classes>.)

Even if the run-time locale is ISO 8859-1 (Latin1), which is a subset of
Unicode, some properties will give results that are not valid for that
subset.

Here are a couple of examples to help you see what's going on.  If the
locale is ISO 8859-7, the character at code point 0xD7 is the "GREEK
CAPITAL LETTER CHI".  But in Unicode that code point means the
"MULTIPLICATION SIGN" instead, and C<\p> always uses the Unicode
meaning.  That means that C<\p{Alpha}> won't match, but C<[[:alpha:]]>
should.  Only in the Latin1 locale are all the characters in the same
positions as they are in Unicode.  But, even here, some properties give
incorrect results.  An example is C<\p{Changes_When_Uppercased}> which
is true for "LATIN SMALL LETTER Y WITH DIAERESIS", but since the upper
case of that character is not in Latin1, in that locale it doesn't
change when upper cased.

=item push on reference is experimental

(S experimental::autoderef) C<push> with a scalar argument is experimental
and may change or be removed in a future Perl version.  If you want to
take the risk of using this feature, simply disable this warning:

    no warnings "experimental::autoderef";

=item Quantifier follows nothing in regex; marked by S<< <-- HERE in m/%s/ >>
d4931 1
a4931 2
=item Quantifier in {,} bigger than %d in regex; marked by S<<-- HERE> in
m/%s/
d4945 1
a4945 2
=item Quantifier unexpected on zero-length expression in regex; marked by <-- 
HERE in m/%s/
a4952 3
The <-- HERE shows whereabouts in the regular expression the problem was
discovered.

d4960 39
d5045 7
d5093 1
a5093 1
The <-- HERE shows whereabouts in the regular expression the problem was
d5104 1
a5104 1
The <-- HERE shows whereabouts in the regular expression the problem was
d5114 1
a5114 1
The <-- HERE shows whereabouts in the regular expression the problem was
a5239 10
=item Search pattern not terminated or ternary operator parsed as search pattern

(F) The lexer couldn't find the final delimiter of a C<?PATTERN?>
construct.

The question mark is also used as part of the ternary operator (as in
C<foo ? 0 : 1>) leading to some ambiguous constructions being wrongly
parsed.  One way to disambiguate the parsing is to put parentheses around
the conditional expression, i.e. C<(foo) ? 0 : 1>.

d5278 8
d5337 7
d5355 12
d5439 5
d5446 1
a5446 1
(W deprecated) You assigned a reference to a scalar to C<$/> where the
a5467 8
=item shift on reference is experimental

(S experimental::autoderef) C<shift> with a scalar argument is experimental
and may change or be removed in a future Perl version.  If you want to
take the risk of using this feature, simply disable this warning:

    no warnings "experimental::autoderef";

a5477 5
=item <> should be quotes

(F) You wrote C<< require <file> >> when you should have written
C<require 'file'>.

a5532 5
=item Sort subroutine didn't return single value

(F) A sort comparison subroutine written in XS must return exactly one
item.  See L<perlfunc/sort>.

a5547 9
=item splice on reference is experimental

(S experimental::autoderef) C<splice> with a scalar argument
is experimental and may change or be removed in a future
Perl version.  If you want to take the risk of using this
feature, simply disable this warning:

    no warnings "experimental::autoderef";

d5562 5
d5645 19
d5730 1
a5730 1
The <-- HERE shows whereabouts in the regular expression the problem was
d5733 7
d5842 12
a6029 8
=item Trailing white-space in a charnames alias definition is deprecated

(D deprecated) You defined a character name which ended in a space
character.  Remove the trailing space(s).  Usually these names are
defined in the C<:alias> import argument to C<use charnames>, but they
could be defined by a translator installed into C<$^H{charnames}>.
See L<charnames/CUSTOM ALIASES>.

a6064 5
=item Type of argument to %s must be unblessed hashref or arrayref

(F) You called C<keys>, C<values> or C<each> with a scalar argument that
was not a reference to an unblessed hash or array.

d6137 12
d6214 1
a6214 1
=item Unicode non-character U+%X is illegal for open interchange
d6217 10
a6226 10
defined by the Unicode standard to be non-characters.  Those are
legal codepoints, but are reserved for internal use; so, applications
shouldn't attempt to exchange them.  An application may not be
expecting any of these characters at all, and receiving them
may lead to bugs.  If you know what you are doing
you can turn off this warning by C<no warnings 'nonchar';>.

This is not really a "serious" error, but it is supposed to be raised
by default even if warnings are not enabled, and currently the only
way to do that in Perl is to mark it as serious.
d6239 6
d6317 1
a6317 1
The <-- HERE shows whereabouts in the regular expression the problem was
a6344 21
=item Unmatched '[' in POSIX class in regex; marked by S<<-- HERE> in m/%s/

(F) You had something like this:

 (?[ [:digit: ])

That should be written:

 (?[ [:digit:] ])

=item Unmatched '%c' in POSIX class in regex; marked by S<<-- HERE> in
m/%s/

(F) You had something like this:

 (?[ [:alnum] ])

There should be a second C<":">, like this:

 (?[ [:alnum:] ])

a6424 9
=item unshift on reference is experimental

(S experimental::autoderef) C<unshift> with a scalar argument
is experimental and may change or be removed in a future
Perl version.  If you want to take the risk of using this
feature, simply disable this warning:

    no warnings "experimental::autoderef";

d6566 1
a6566 1
The <-- HERE shows whereabouts in the regular expression the problem was
d6587 1
a6587 1
The <-- HERE shows whereabouts in the regular expression the problem was
d6590 7
a6602 25
=item Useless use of '\'; doesn't escape metacharacter '%c'

(D deprecated) You wrote a regular expression pattern something like
one of these:

 m{ \x\{FF\} }x
 m{foo\{1,3\}}
 qr(foo\(bar\))
 s[foo\[a-z\]bar][baz]

The interior braces, square brackets, and parentheses are treated as
metacharacters even though they are backslashed; instead write:

 m{ \x{FF} }x
 m{foo{1,3}}
 qr(foo(bar))
 s[foo[a-z]bar][baz]

The backslashes have no effect when a regular expression pattern is
delimited by C<{}>, C<[]>, or C<()>, which ordinarily are
metacharacters, and the delimiters are also used, paired, within the
interior of the pattern.  It is planned that a future Perl release will
change the meaning of constructs like these so that the backslashes
will have an effect, so remove them from your code.

a6700 10
=item Use of chdir('') or chdir(undef) as chdir() deprecated

(D deprecated) chdir() with no arguments is documented to change to
$ENV{HOME} or $ENV{LOGDIR}.  chdir(undef) and chdir('') share this
behavior, but that has been deprecated.  In future versions they
will simply fail.

Be careful to check that what you pass to chdir() is defined and not
blank, else you might find yourself in your home directory.

d6712 14
d6747 8
d6821 12
a6832 4
(D deprecated) Using literal control characters in the source to refer
to the ^FOO variables, like C<$^X> and C<${^GLOBAL_PHASE}> is now
deprecated.  This only affects code like C<$\cT>, where \cT is a control in
the source code: C<${"\cT"}> and C<$^T> remain valid.
a6839 6
=item Use of my $_ is experimental

(S experimental::lexical_topic) Lexical $_ is an experimental feature and
its behavior may change or even be removed in any future release of perl.
See the explanation under L<perlvar/$_>.

a6850 9
=item Use of ?PATTERN? without explicit operator is deprecated

(D deprecated) You have written something like C<?\w?>, for a regular
expression that matches only once.  Starting this term directly with
the question mark delimiter is now deprecated, so that the question mark
will be available for use in new operators in the future.  Write C<m?\w?>
instead, explicitly using the C<m> operator: the question mark delimiter
still invokes match-once behaviour.

d6868 8
d6899 8
a6923 14
=item Using a hash as a reference is deprecated

(D deprecated) You tried to use a hash as a reference, as in
C<< %foo->{"bar"} >> or C<< %$ref->{"hello"} >>.  Versions of perl <= 5.6.1
used to allow this syntax, but shouldn't have.  It is now
deprecated, and will be removed in a future version.

=item Using an array as a reference is deprecated

(D deprecated) You tried to use an array as a reference, as in
C<< @@foo->[23] >> or C<< @@$ref->[99] >>.  Versions of perl <= 5.6.1 used to
allow this syntax, but shouldn't have.  It is now deprecated,
and will be removed in a future version.

d6927 17
a6943 3
(W regexp) A charnames handler may return a sequence of more than one
character.  Currently all but the first one are discarded when used in
a regular expression pattern bracketed character class.
d6948 1
a6948 1
currently reserved for future use, as the exact behaviour has not
a6978 9
=item values on reference is experimental

(S experimental::autoderef) C<values> with a scalar argument
is experimental and may change or be removed in a future
Perl version.  If you want to take the risk of using this
feature, simply disable this warning:

    no warnings "experimental::autoderef";

d7105 20
d7162 14
d7184 5
d7239 4
a7242 3
C<(?[...])>, which is not permitted.  Check that the correct escape has
been used, and the correct charnames handler is in scope.  The S<<-- HERE>
shows whereabouts in the regular expression the problem was discovered.
@


1.17
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d443 5
d978 7
d1406 4
a1409 3
non-printable characters.  You used it for a printable one, which is better
written as simply itself, perhaps preceded by a backslash for non-word
characters.
d2218 1
a2218 1
(W regexp) Named Unicode character escapes C<(\N{...})> may return a
d2579 1
a2579 1
not valid characters numbers, so it return the Unicode replacement
d3098 2
d3323 1
a3323 1
(F) Named Unicode character escapes C<(\N{...})> may return a
a4166 6
=item (perhaps you forgot to load "%s"?)

(F) This is an educated guess made in conjunction with the message
"Can't locate object method \"%s\" via package \"%s\"".  It often means
that a method requires a package that has not been loaded.

d6766 1
a6766 1
(F) Named Unicode character escapes C<(\N{...})> may return a zero-length
@


1.16
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d57 1
a57 1
=item '%c' allowed only after types %s
d92 7
a137 7
=item Ambiguous use of -%s resolved as -&%s()

(S ambiguous) You wrote something like C<-foo>, which might be the
string C<"-foo">, or a call to the function C<foo>, negated.  If you meant
the string, just write C<"-foo">.  If you meant the function call,
write C<-foo()>.

a172 28
=item %s argument is not a HASH or ARRAY element or a subroutine

(F) The argument to exists() must be a hash or array element or a
subroutine with an ampersand, such as:

    $foo{$bar}
    $ref->{"susie"}[12]
    &do_something

=item %s argument is not a HASH or ARRAY element or slice

(F) The argument to delete() must be either a hash or array element,
such as:

    $foo{$bar}
    $ref->{"susie"}[12]

or a hash or array slice, such as:

    @@foo[$bar, $baz, $xyzzy]
    @@{$ref->[12]}{"susie", "queue"}

=item %s argument is not a subroutine name

(F) The argument to exists() for C<exists &sub> must be a subroutine
name, and not a subroutine call.  C<exists &sub()> will generate this
error.

d196 5
a200 5
(D) You defined a character name which had multiple space characters in
a row.  Change them to single spaces.  Usually these names are defined
in the C<:alias> import argument to C<use charnames>, but they could be
defined by a translator installed into C<$^H{charnames}>.  See
L<charnames/CUSTOM ALIASES>.
d206 1
a206 1
=item Assertion failed: file "%s"
a220 8
=item A thread exited while %d threads were running

(W threads)(S) When using threaded Perl, a thread (not necessarily
the main thread) exited while there were still other threads running.
Usually it's a good idea first to collect the return values of the
created threads by joining them, and only then to exit from the main
thread.  See L<threads>.

d226 6
a301 6
=item Attempt to join self

(F) You tried to join a thread from within itself, which is an
impossible task.  You may be joining the wrong thread, or you may need
to move the join() to some other thread.

d341 6
d485 1
a485 1
=item \1 better written as $1
d509 2
a510 1
=item "\b{" is deprecated; use "\b\{" or "\b[{]" instead in regex; marked by <-- HERE in m/%s/
d512 2
a513 1
=item "\B{" is deprecated; use "\B\{" or "\B[{]" instead in regex; marked by <-- HERE in m/%s/
d515 5
a519 5
(W deprecated) Use of an unescaped "{" immediately following a
C<\b> or C<\B> is now deprecated so as to reserve its use for Perl
itself in a future release.  You can either precede the brace with a
backslash, or enclose it in square brackets; the latter is the way to go
if the pattern delimiters are C<{}>.
d530 5
a540 5
=item Bizarre SvTYPE [%d]

(P) When starting a new thread or return values from a thread, Perl
encountered an invalid data type.

d557 5
d651 10
d872 5
a882 5
=item Can't goto subroutine from an eval-%s

(F) The "goto subroutine" call can't be used to jump out of an eval
"string" or block.

d990 1
a990 1
(W) A module passed the flag 0x01 to DynaLoader::dl_load_file() to request
d1257 2
d1300 1
a1300 1
=item Character following "\c" must be ASCII
d1302 5
a1306 3
(F)(W deprecated, syntax) In C<\cI<X>>, I<X> must be an ASCII character.
It is planned to make this fatal in all instances in Perl v5.20.  In the
cases where it isn't fatal, the character this evaluates to is
d1309 3
a1311 2
Note that non-alphabetic ASCII characters are discouraged here as well,
and using non-printable ones will be deprecated starting in v5.18.
a1327 12
=item Character in 'W' format wrapped in pack

(W pack) You said

    pack("U0W", $x)

where $x is either less than 0 or more than 255.  However, C<U0>-mode
expects all values to fall in the interval [0, 255], so Perl behaved
as if you meant:

    pack("U0W", $x & 255)

d1355 12
a1390 8
=item "\c{" is deprecated and is more clearly written as ";"

(D deprecated, syntax) The C<\cI<X>> construct is intended to be a way
to specify non-printable characters.  You used it with a "{" which
evaluates to ";", which is printable.  It is planned to remove the
ability to specify a semi-colon this way in Perl 5.20.  Just use a
semi-colon or a backslash-semi-colon without the "\c".

a1401 4
=item close() on unopened filehandle %s

(W unopened) You tried to close a filehandle that was never opened.

d1407 4
d1424 1
a1424 4
=item Code point 0x%X is not Unicode, all \p{} matches fail; all \P{} matches 
succeed

(S utf8, non_unicode) You had a code point above the Unicode maximum
a1433 21
None of the Unicode or Perl-defined properties will match a non-Unicode
code point.  For example,

    chr(0x7FF_FFFF) =~ /\p{Any}/

will not match, because the code point is not in Unicode.  But

    chr(0x7FF_FFFF) =~ /\P{Any}/

will match.

This may be counterintuitive at times, as both these fail:

 chr(0x110000) =~ /\p{ASCII_Hex_Digit=True}/      # Fails.
 chr(0x110000) =~ /\p{ASCII_Hex_Digit=False}/     # Also fails!

and both these succeed:

 chr(0x110000) =~ /\P{ASCII_Hex_Digit=True}/      # Succeeds.
 chr(0x110000) =~ /\P{ASCII_Hex_Digit=False}/     # Also succeeds!

d1437 1
a1437 1
shell instead of Perl.  Check the #! line, or manually feed your script
a1459 22
=item cond_broadcast() called on unlocked variable

(W threads) Within a thread-enabled program, you tried to
call cond_broadcast() on a variable which wasn't locked.
The cond_broadcast() function is used to wake up another thread
that is waiting in a cond_wait().  To ensure that the signal isn't
sent before the other thread has a chance to enter the wait, it
is usual for the signaling thread first to wait for a lock on
variable.  This lock attempt will only succeed after the other
thread has entered cond_wait() and thus relinquished the lock.

=item cond_signal() called on unlocked variable

(W threads) Within a thread-enabled program, you tried to
call cond_signal() on a variable which wasn't locked.  The
cond_signal() function is used to wake up another thread that
is waiting in a cond_wait().  To ensure that the signal isn't
sent before the other thread has a chance to enter the wait, it
is usual for the signaling thread first to wait for a lock on
variable.  This lock attempt will only succeed after the other
thread has entered cond_wait() and thus relinquished the lock.

d1476 1
a1476 8
L<overload> pragma?.

=item Constant(%s) unknown

(F) The parser found inconsistencies either while attempting to define
an overloaded constant, or when trying to find the character name
specified in the C<\N{...}> escape.  Perhaps you forgot to load the
corresponding L<overload> pragma?.
d1498 7
d1524 6
a1543 7
=item Corrupted regexp opcode %d > %d

(F)
This is either an error in Perl, or, if you're using one, your
L<custom regular expression engine|perlreapi>.  If not the latter,
report the problem through the L<perlbug> utility.

d1550 4
d1595 2
a1596 2
=item (?(DEFINE)....) does not allow branches in regex; marked by <-- HERE in 
m/%s/
d1610 24
d1656 1
a1656 1
Beginning with perl 5.9.4, you can also use C<state> variables to have
d1714 6
a1719 1
=item Don't know how to handle magic of type '%s'
d1757 8
d1772 1
a1772 1
=item Empty \%c{} in regex; marked by <-- HERE in m/%s/
d1836 2
a1837 2
=item EVAL without pos change exceeded limit in regex; marked by <-- HERE in 
m/%s/
d1861 14
d1901 1
a1901 1
=item Expecting close bracket in regex; marked by <-- HERE in m/%s/
d1903 1
a1903 2
(F)
You wrote something like
d1911 19
d1956 1
a1956 1
=item False [] range "%s" in regex; marked by <-- HERE in m/%s/
d1958 1
a1958 1
(W regexp) A character class range must start and end at a literal
d1960 4
a1963 3
in your false range is interpreted as a literal "-".  Consider quoting the
"-", "\-".  The <-- HERE shows whereabouts in the regular expression the
problem was discovered.  See L<perlre>.
d2091 4
a2094 4
(S experimental::smartmatch) C<given> depends on both a lexical C<$_> and
smartmatch, both of which are experimental, so its behavior may change or
even be removed in any future release of perl.
See the explanation under L<perlsyn/Experimental Details on given and when>.
d2124 5
d2157 7
a2168 7
=item Group name must start with a non-digit word character in regex; marked by 
<-- HERE in m/%s/

(F) Group names must follow the rules for perl identifiers, meaning
they must start with a non-digit word character. A common cause of
this error is using (?&0) instead of (?0). See L<perlre>.

a2194 10
=item -i used with no filenames on the command line, reading from STDIN

(S inplace) The C<-i> option was passed on the command line, indicating
that the script is intended to edit files inplace, but no files were
given.  This is usually a mistake, since editing STDIN inplace doesn't
make sense, and can be confusing because it can make perl look like
it is hanging when it is really just trying to read from STDIN.  You
should either pass a filename to edit, or remove C<-i> from the command
line.  See L<perlrun> for more details.

d2202 2
a2203 1
=item Ignoring zero length \N{} in character class in regex; marked by <-- HERE in m/%s/
d2205 3
a2207 3
(W regexp) Named Unicode character escapes C<(\N{...})> may return a zero-length
sequence.  When such an escape is used in a character class its
behaviour is not well defined.  Check that the correct escape has
d2222 4
a2225 2
(W illegalproto) An illegal character was found in a prototype declaration.
Legal characters in prototypes are $, @@, %, *, ;, [, ], &, \, and +.
d2239 3
d2283 1
a2283 1
=item Illegal pattern in regex; marked by <-- HERE in m/%s/
d2285 1
a2285 2
(F)
You wrote something like
d2322 2
a2323 9
=item In '(*VERB...)', splitting the initial '(*' is deprecated in regex; marked by <-- HERE in m/%s/

(D regexp, deprecated)
The two-character sequence C<"(*"> in this context in a regular
expression pattern should be an indivisible token, with nothing
intervening between the C<"("> and the C<"*">, but you separated them.
Due to an accident of implementation, this prohibition was not enforced,
but we do plan to forbid it in a future Perl version.  This message
serves as giving you fair warning of this pending change.
d2325 1
a2325 14
=item In '(?...)', splitting the initial '(?' is deprecated in regex; marked by <-- HERE in m/%s/

(D regexp, deprecated)
The two-character sequence C<"(?"> in this context in a regular
expression pattern should be an indivisible token, with nothing
intervening between the C<"("> and the C<"?">, but you separated them.
Due to an accident of implementation, this prohibition was not enforced,
but we do plan to forbid it in a future Perl version.  This message
serves as giving you fair warning of this pending change.

=item Incomplete expression within '(?[ ])' in regex; marked by <-- HERE in m/%s/

(F)
There was a syntax error within the C<(?[ ])>.  This can happen if the
d2343 1
a2343 1
=item Infinite recursion in regex; marked by <-- HERE in m/%s/
a2348 3
The <-- HERE shows whereabouts in the regular expression the problem was
discovered.

d2357 22
d2411 11
d2459 1
a2459 1
=item Internal disaster in regex; marked by <-- HERE in m/%s/
d2462 1
a2462 1
The <-- HERE shows whereabouts in the regular expression the problem was
d2474 10
a2483 1
=item Internal urp in regex; marked by <-- HERE in m/%s/
d2486 1
a2486 1
<-- HERE shows whereabouts in the regular expression the problem was
d2506 2
a2507 1
=item Invalid [] range "%*.*s" in regex; marked by <-- HERE in m/%s/
d2509 3
a2511 2
(F)
You wrote something like
d2513 1
a2513 1
 [z-a]
d2515 3
a2517 2
in a regular expression pattern.  Ranges must be specified with the
lowest code point first.  Instead write
d2519 1
a2519 3
 [a-z]

=item Invalid character in \N{...}; marked by <-- HERE in \N{%s}
a2523 6
=item Invalid character in charnames alias definition; marked by <-- HERE in '%s

(F) You tried to create a custom alias for a character name, with
the C<:alias> option to C<use charnames> and the specified character in
the indicated name isn't valid.  See L<charnames/CUSTOM ALIASES>.

d2529 2
a2530 2
=item Invalid escape in the specified encoding in regex; marked by <-- HERE in 
m/%s/
d2532 1
a2532 1
(W regexp) The numeric escape (for example C<\xHH>) of value < 256
d2535 3
a2537 2
The escape was replaced with REPLACEMENT CHARACTER (U+FFFD) instead.
The <-- HERE shows whereabouts in the regular expression the
d2542 2
a2543 2
=item Invalid hexadecimal number in \N{U+...} in regex; marked by <-- HERE in 
m/%s/
d2575 1
a2575 1
=item Invalid [] range "%s" in regex; marked by <-- HERE in m/%s/
d2580 1
a2580 1
up to C<ff>.  The <-- HERE shows whereabouts in the regular expression the
d2638 11
d2673 1
a2673 1
perls, has been removed as of 5.9.0 and is no longer supported.  In
d2685 1
a2685 1
perls, has been removed as of 5.9.3 and is no longer supported.  You
d2699 10
d2713 8
d2750 1
a2750 1
=item length() used on %s
d2788 5
d2845 6
d2881 3
d2933 42
a2974 1
=item %s matches null string many times in regex; marked by <-- HERE in m/%s/
d2977 1
a2977 1
regular expression engine didn't specifically check for that.  The <-- HERE
d3033 1
a3033 1
=item Missing braces on \N{} in regex; marked by <-- HERE in m/%s/
d3061 4
d3067 1
a3067 1
(F) The reserved syntax for lexically scoped subroutines requires that
d3081 1
a3081 1
=item Missing right brace on \%c{} in regex; marked by <-- HERE in m/%s/
d3170 23
d3213 8
d3229 13
a3241 9
(W once) Typographical errors often show up as unique variable names.
If you had a good reason for having a unique name, then just mention it
again somehow to suppress the message.  The C<our> declaration is
provided for this purpose.

NOTE: This warning detects symbols that have been used only once so $c, @@c,
%c, *c, &c, sub c{}, c(), and c (the filehandle or format) are considered
the same; if a program uses $c only once but also uses any of the others it
will not trigger this warning.
d3243 1
a3243 2
=item \N in a character class must be a named character: \N{...} in regex; 
marked by <-- HERE in m/%s/
d3245 3
a3247 4
(F) The new (5.12) meaning of C<\N> as C<[^\n]> is not valid in a bracketed
character class, for the same reason that C<.> in a character class loses
its specialness: it matches almost everything, which is probably not
what you want.
d3249 2
a3250 39
=item \N{NAME} must be resolved by the lexer in regex; marked by <-- HERE in m/%s/

(F) When compiling a regex pattern, an unresolved named character or
sequence was encountered.  This can happen in any of several ways that
bypass the lexer, such as using single-quotish context, or an extra
backslash in double-quotish:

    $re = '\N{SPACE}';	# Wrong!
    $re = "\\N{SPACE}";	# Wrong!
    /$re/;

Instead, use double-quotes with a single backslash:

    $re = "\N{SPACE}";	# ok
    /$re/;

The lexer can be bypassed as well by creating the pattern from smaller
components:

    $re = '\N';
    /${re}{SPACE}/;	# Wrong!

It's not a good idea to split a construct in the middle like this, and it
doesn't work here.  Instead use the solution above.

Finally, the message also can happen under the C</x> regex modifier when the
C<\N> is separated by spaces from the C<{>, in which case, remove the spaces.

    /\N {SPACE}/x;	# Wrong!
    /\N{SPACE}/x;	# ok

=item Need exactly 3 octal digits in regex; marked by <-- HERE in m/%s/

(F) Within S<C<(?[   ])>>, all constants interpreted as octal need to be
exactly 3 digits long.  This helps catch some ambiguities.  If your
constant is too short, add leading zeros, like

 (?[ [ \078 ] ])     # Syntax error!
 (?[ [ \0078 ] ])    # Works
d3254 2
a3255 2
need a larger one, you need to use L<\o{}|perlrebackslash/Octal escapes>
instead.  If you meant two separate things, you need to separate them
d3277 1
a3277 1
=item Nested quantifiers in regex; marked by <-- HERE in m/%s/
d3280 1
a3280 1
So things like ** or +* or ?* are illegal.  The <-- HERE shows
d3297 50
d3436 21
d3462 6
d3501 5
a3512 5
=item No such class %s

(F) You provided a class qualifier in a "my", "our" or "state"
declaration, but this class doesn't exist at this point in your program.

d3595 7
a3609 37
=item Non-hex character in regex; marked by <-- HERE in m/%s/

(F)
In a regular expression, there was a non-hexadecimal character where
a hex one was expected, like

 (?[ [ \xDG ] ])
 (?[ [ \x{DEKA} ] ])

=item Non-octal character '%c'.  Resolved as "%s"

(W digit) In parsing an octal numeric constant, a character was
unexpectedly encountered that isn't octal.  The resulting value
is as indicated.

=item Non-octal character in regex; marked by <-- HERE in m/%s/

(F)
In a regular expression, there was a non-octal character where
an octal one was expected, like

 (?[ [ \o{1278} ] ])

=item Non-string passed as bitmask

(W misc) A number has been passed as a bitmask argument to select().
Use the vec() function to construct the file descriptor bitmasks for
select.  See L<perlfunc/select>.

=item (?[...]) not valid in locale in regex; marked by <-- HERE in m/%s/

(F)
C<(?[...])> cannot be used within the scope of a C<S<use locale>> or
with an C</l> regular expression modifier, as that would require
deferring to run-time the calculation of what it should evaluate to, and
it is regex compile-time only.

a3651 8
=item "my %s" used in sort comparison

(W syntax) The package variables $a and $b are used for sort comparisons.
You used $a or $b in as an operand to the C<< <=> >> or C<cmp> operator inside a
sort comparison block, and the variable had earlier been declared as a
lexical variable.  Either qualify the sort variable with the package
name, or rename the lexical variable.

d3658 9
a3702 6
=item Strings with code points over 0xFF may not be mapped into in-memory file handles

(W utf8) You tried to open a reference to a scalar for read or append
where the scalar contained code points over 0xFF.  In-memory files
model on-disk files and can only contain bytes.

d3725 2
a3726 1
=item Operand with no preceding operator in regex; marked by <-- HERE in m/%s/
d3728 1
a3728 2
(F)
You wrote something like
d3744 3
a3746 3
(S utf8, non_unicode) You performed an operation requiring Unicode
semantics on a code point that is not in Unicode, so what it should do
is not defined.  Perl has chosen to have it do nothing, and warn you.
d3756 6
a3761 6
(S utf8, surrogate) You performed an operation requiring Unicode
semantics on a Unicode surrogate.  Unicode frowns upon the use of
surrogates for anything but storing strings in UTF-16, but semantics
are (reluctantly) defined for the surrogates, and they are to do
nothing for this operation.  Because the use of surrogates can be
dangerous, Perl warns.
d3777 7
d3968 1
a3968 1
(F) forked child returned an incomprehensible message about its errno.
d3996 2
a3997 1
(P) Something tried to allocate more memory than possible.
d4067 1
a4067 1
=item panic: Sequence (?{...}): no code block found
d4069 1
a4069 1
(P) while compiling a pattern that has embedded (?{}) or (??{}) code
d4073 6
a4088 6
=item panic: strxfrm() gets absurd - a => %u, ab => %u

(P) The interpreter's sanity check of the C function strxfrm() failed.
In your current locale the returned transformation of the string "ab" is
shorter than that of the string "a", which makes no sense.

d4140 1
a4140 2
=item Pattern subroutine nesting without pos change exceeded limit in regex; 
marked by <-- HERE in m/%s/
a4145 3
The <-- HERE shows whereabouts in the regular expression the problem was
discovered.

d4159 1
a4159 1
utility to report; in regex; marked by <-- HERE in m/%s/
d4161 4
a4164 6
(D regexp, deprecated) You used a regular expression with
case-insensitive matching, and there is a bug in Perl in which the
built-in regular expression folding rules are not accurate.  This may
lead to incorrect results.  Please report this as a bug using the
L<perlbug> utility.  (This message is marked deprecated, so that it by
default will be turned-on.)
d4182 1
a4182 1
=item Perl %s required--this is only version %s, stopped
d4204 5
a4231 6
=item perl: warning: Non hex character in '$ENV{PERL_HASH_SEED}', seed only partially set

(W) PERL_HASH_SEED should match /^\s*(?:0x)?[0-9a-fA-F]+\s*\z/ but it
contained a non hex character. This could mean you are not using the hash
seed you think you are.

d4234 2
a4235 2
(W) Perl was run with the environment variable PERL_PERTURB_KEYS defined
but containing an unexpected value. The legal values of this setting
d4242 2
a4243 1
  2       | DETERMINISTIC | Enables repeatable key traversal randomization
d4246 1
a4246 1
case sensitive. The default for this setting is "RANDOM" or 1.
d4258 9
a4266 1
=item POSIX class [:%s:] unknown in regex; marked by <-- HERE in m/%s/
d4268 1
a4268 1
(F) The class in the character class [: :] syntax is unknown.  The <-- HERE
d4280 1
a4280 1
<-- HERE in m/%s/
d4286 1
a4286 1
will cause fatal errors.  The <-- HERE shows whereabouts in the regular
d4290 1
a4290 1
<-- HERE in m/%s/
d4296 1
a4296 1
and ".\]".  The <-- HERE shows whereabouts in the regular expression the
d4300 1
a4300 1
<-- HERE in m/%s/
d4306 1
a4306 1
and "=\]".  The <-- HERE shows whereabouts in the regular expression the
d4361 22
d4416 15
d4468 1
a4468 1
=item Property '%s' is unknown in regex; marked by <-- HERE in m/%s/
d4470 1
a4470 2
(F)
The named property which you specified via C<\p> or C<\P> is not one
d4473 2
a4474 2
for a complete list of available official properties.  If it is a
L<user-defined property|perlunicode/User-Defined Character Properties>
d4493 7
d4524 5
a4528 1
=item Quantifier {n,m} with n > m can't match in regex
d4530 1
a4530 2
(W regexp) Minima should be less than or equal to maxima.  If you really
want your regexp to match something 0 times, just put {0}.
d4532 1
a4532 1
=item Quantifier follows nothing in regex; marked by <-- HERE in m/%s/
d4535 1
a4535 1
you meant it literally.  The <-- HERE shows whereabouts in the regular
d4538 2
a4539 1
=item Quantifier in {,} bigger than %d in regex; marked by <-- HERE in m/%s/
d4542 1
a4542 1
the {min,max} construct.  The <-- HERE shows whereabouts in the regular
d4545 8
a4564 5
=item Quantifier {n,m} with n > m can't match in regex; marked by <-- HERE in m/%s/

(W regexp) Minima should be less than or equal to maxima.  If you really
want your regexp to match something 0 times, just put {0}.

d4644 1
a4644 1
=item Reference to invalid group 0 in regex; marked by <-- HERE in m/%s/
d4651 2
a4652 1
=item Reference to nonexistent group in regex; marked by <-- HERE in m/%s/
d4662 2
a4663 1
=item Reference to nonexistent named group in regex; marked by <-- HERE in m/%s/
d4673 2
a4674 2
=item Reference to nonexistent or unclosed group in regex; marked by <-- HERE 
in m/%s/
d4690 2
a4691 1
=item Regexp modifier "/%c" may not appear twice
d4693 1
a4693 1
(F syntax, regexp) The regular expression pattern had too many occurrences
d4704 8
d4714 4
a4717 1
(F syntax, regexp) The regular expression pattern had more than one of these
d4726 1
a4726 1
=item Repeated format line will never terminate (~~ and @@# incompatible)
d4754 2
a4755 2
(W io) The dirhandle you tried to do a rewinddir() on is either closed or not
really a dirhandle.  Check your control flow.
d4801 1
a4801 1
Note that since Perl 5.9.0 a // can also be the I<defined-or>
d4803 2
a4804 2
in Perl 5.9.0 or later that uses the // as the I<defined-or> can be
misparsed by pre-5.9.0 Perls as a non-terminated search pattern.
d4854 1
a4854 1
=item Sequence (? incomplete in regex; marked by <-- HERE in m/%s/
d4857 1
a4857 1
<-- HERE shows whereabouts in the regular expression the problem was
d4860 2
a4861 1
=item Sequence (?%s...) not implemented in regex; marked by <-- HERE in m/%s/
d4864 1
a4864 1
but has not yet been written.  The <-- HERE shows whereabouts in the
d4867 2
a4868 1
=item Sequence (?%s...) not recognized in regex; marked by <-- HERE in m/%s/
d4870 3
a4872 3
(F) You used a regular expression extension that doesn't make sense.  The
<-- HERE shows whereabouts in the regular expression the problem was
discovered.  This happens when using the C<(?^...)> construct to tell
a4876 5
=item Sequence \%s... not terminated in regex; marked by <-- HERE in m/%s/

(F) The regular expression expects a mandatory argument following the escape
sequence and this has been omitted or incorrectly written.

d4883 28
d4916 8
a4923 1
=item Z<>500 Server error
d4925 2
a4926 1
See Server error.
d4928 1
a4928 1
=item Server error
d4988 32
d5064 12
a5084 6
=item Smart matching a non-overloaded object breaks encapsulation

(F) You should not use the C<~~> operator on an object that does not
overload it: Perl refuses to use the object's underlying structure for
the smart match.

d5110 9
a5132 6
=item "state" variable %s can't be in a package

(F) Lexically scoped variables aren't in a package, so it doesn't make
sense to try to declare one with a package qualifier on the front.  Use
local() if you want to localize a package variable.

d5141 6
d5152 6
d5169 3
a5171 3
subroutine may be declared in an outer anonymous subroutine that has not
yet been created.  (Remember that named subs are created at compile time,
while anonymous subs are created at run-time.)  For example,
d5175 1
a5175 1
At the time that f is created, it can't capture the current the "a" sub,
d5182 2
a5183 2
The second situation is caused by an eval accessing a variable that has
gone out of scope, for example,
d5243 5
d5249 1
a5249 1
<-- HERE in m/%s/
d5258 1
a5258 1
The <-- HERE shows whereabouts in the regular expression the problem
d5261 2
a5262 1
=item Switch condition not recognized in regex; marked by <-- HERE in m/%s/
d5264 15
a5278 3
(F) If the argument to the (?(...)if-clause|else-clause) construct is
a number, it can be only a number.  The <-- HERE shows whereabouts in
the regular expression the problem was discovered.  See L<perlre>.
a5284 4
=item %s syntax OK

(F) The final summary message when a C<perl -c> succeeds.

d5318 9
a5334 6
=item Syntax error in (?[...]) in regex m/%s/

(F)
Perl could not figure out what you meant inside this construct; this
notifies you that it is giving up trying.

d5390 5
d5419 1
a5419 12
=item The %s feature is experimental

(S experimental) This warning is emitted if you enable an experimental
feature via C<use feature>.  Simply suppress the warning if you want
to use the feature, but know that in doing so you are taking the risk
of using an experimental feature which may change or be removed in a
future Perl version:

    no warnings "experimental::lexical_subs";
    use feature "lexical_subs";

=item The %s function is unimplemented
d5421 9
a5429 2
(F) The function indicated isn't implemented on this architecture, according
to the probings of Configure.
d5458 1
a5458 1
key traversal, but this Perl has been compiled without it. You should
a5461 4
=item thread failed to start: %s

(W threads)(S) The entry point function of threads->create() failed for some reason.

d5499 7
d5536 7
d5560 4
a5563 4
(D) You defined a character name which ended in a space character.
Remove the trailing space(s).  Usually these names are defined in the
C<:alias> import argument to C<use charnames>, but they could be defined
by a translator installed into C<$^H{charnames}>.
d5683 2
a5684 6
=item Unexpected '(' with no preceding operator in regex; marked by <-- HERE in m/%s/

(F)
You had something like this:

 (?[ \p{Digit} ( \p{Lao} + \p{Thai} ) ])
d5686 1
a5686 19
There should be an operator before the C<"(">, as there's no indication
as to how the digits are to be combined with the characters in the Lao
and Thai scripts.

=item Unexpected ')' in regex; marked by <-- HERE in m/%s/

(F)
You had something like this:

 (?[ ( \p{Digit} + ) ])

The C<")"> is out-of-place.  Something apparently was supposed to be
combined with the digits, or the C<"+"> shouldn't be there, or something
like that.  Perl can't figure out what was intended.

=item Unexpected binary operator '%c' with no preceding operand in regex; marked by <-- HERE in m/%s/

(F)
You had something like this:
d5693 1
a5693 1
=item Unexpected character in regex; marked by <-- HERE in m/%s/
d5695 1
a5695 2
(F)
You had something like this:
d5712 31
d5745 1
a5745 1
(S utf8, nonchar) Certain codepoints, such as U+FFFE and U+FFFF, are
d5748 3
a5750 1
shouldn't attempt to exchange them.  If you know what you are doing
d5753 4
d5759 1
a5759 1
(S utf8, surrogate) You had a UTF-16 surrogate in a context where they are
a5767 5
=item Unknown BYTEORDER

(F) There are no byte-swapping functions for a machine with this byte
order.

a5804 4
=item Unknown "re" subpragma '%s' (known ones are: %s)

(W) You tried to use an unknown subpragma of the "re" pragma.

d5820 6
a5825 1
=item Unknown switch condition (?(%s in regex; marked by <-- HERE in m/%s/
d5848 1
a5848 1
=item Unknown Unicode option value %x
d5853 1
a5853 1
=item Unknown verb pattern '%s' in regex; marked by <-- HERE in m/%s/
d5868 9
a5876 1
=item Unmatched '%c' in POSIX class in regex; marked by <-- HERE in m/%s/
d5878 4
a5881 1
You had something like this:
d5889 1
a5889 1
=item Unmatched [ in regex; marked by <-- HERE in m/%s/
d5893 1
a5893 1
first.  The <-- HERE shows whereabouts in the regular expression the
d5896 1
a5896 8
=item Unmatched '[' in POSIX class in regex; marked by <-- HERE in m/%s/

(F)
You had something like this:

 (?[ [:digit: ])

That should be written:
d5898 1
a5898 5
 (?[ [:digit:] ])

=item Unmatched ( in regex; marked by <-- HERE in m/%s/

=item Unmatched ) in regex; marked by <-- HERE in m/%s/
d5902 1
a5902 1
the matching parenthesis.  The <-- HERE shows whereabouts in the
d5919 2
a5920 1
=item Unrecognized character %s; marked by <-- HERE after %s near column %d
d5923 10
a5932 9
in your Perl script (or eval) near the specified column.  Perhaps you tried 
to run a compressed script, a binary program, or a directory as a Perl program.

=item Unrecognized escape \%c in character class in regex; marked by <-- HERE in m/%s/

(F)
You used a backslash-character combination which is not recognized by
Perl inside character classes.  This is a fatal error when the character
class is used within C<(?[ ])>.
d5935 1
a5935 1
marked by <-- HERE in m/%s/
d5940 1
a5940 1
The <-- HERE shows whereabouts in the regular expression the
d5949 2
a5950 1
=item Unrecognized escape \%s passed through in regex; marked by <-- HERE in m/%s/
d5954 1
a5954 1
this may change in a future version of Perl.  The <-- HERE shows
d5969 9
d6043 1
a6043 1
=item Unterminated \g{...} pattern in regex; marked by <-- HERE in m/%s/
d6045 6
a6050 2
(F) You missed a close brace on a \g{..} pattern (group reference) in
a regular expression.  Fix the pattern and retry.
d6059 2
a6060 1
=item Unterminated verb pattern argument in regex; marked by <-- HERE in m/%s/
d6065 1
a6065 1
=item Unterminated verb pattern in regex; marked by <-- HERE in m/%s/
d6096 1
a6096 1
=item Use \\x{...} for more than two hex characters in regex; marked by <-- HERE in m/%s/
d6098 2
a6099 20
(F)
In a regular expression, you said something like

 (?[ [ \xBEEF ] ])

Perl isn't sure if you meant this

 (?[ [ \x{BEEF} ] ])

or if you meant this

 (?[ [ \x{BE} E F ] ])

You need to add either braces or blanks to disambiguate.

=item Use of each() on hash after insertion without resetting hash iterator results in undefined behavior

(S internal) The behavior of C<each()> after insertion is undefined, it may
skip items, or visit items more than once. Consider using C<keys()> instead
of C<each()>.
d6107 2
a6108 2
=item Useless (?-%s) - don't use /%s modifier in regex; marked by <-- HERE in 
m/%s/
d6128 2
a6129 1
=item Useless (?%s) - use /%s modifier in regex; marked by <-- HERE in m/%s/
d6168 1
a6168 1
delimitted by C<{}>, C<[]>, or C<()>, which ordinarily are
d6179 11
d6230 5
a6246 6
=item Useless use of (?-p) in regex; marked by <-- HERE in m/%s/

(W regexp)
The C<p> modifier cannot be turned off once set.  Trying to do so is
futile.

a6255 14
=item Useless (%s%c) - %suse /%c modifier in regex; marked by <-- HERE in m/%s/

(W regexp)
The C</g> and C</o> regular expression modifiers are global and can't be
turned off once set; hence things like C<(?g)> or C<(?-o:)> do nothing.

=item Useless (%sc) - %suse /gc modifier in regex; marked by <-- HERE in m/%s/

(W regexp)
The C</c> regular expression modifier is global, can't be turned off
once set, and doesn't do anything without the C</g> modifier being
specified as well; hence things like C<(?c)> or C<(?-c:)> do nothing,
nor do thing like C<(?gc)> nor C<(?-gc:)> .

d6269 2
a6270 6
form if you wish to use an empty line as the terminator of the here-document.

=item Use of comma-less variable list is deprecated

(D deprecated) The values you give to a format should be
separated by commas, not just aligned on a line.
d6293 11
d6378 8
a6385 1
=item Use of -l on filehandle %s
d6451 1
a6451 1
anid the operation displayed in the warning may not necessarily appear
d6457 17
d6478 1
a6478 1
used to allow this syntax, but shouldn't have.   It is now
d6489 1
a6489 1
regex; marked by <-- HERE in m/%s/
d6504 1
a6504 1
(S utf8, surrogate) You had a UTF-16 surrogate in a context where they are
d6529 9
d6565 2
a6566 2
Here, when the '$a' in the eval is being compiled, f() is not currently being
executed, so its $a is not available for capture.
d6579 14
a6592 1
known at compile time.  See L<perlre>.
d6630 2
a6631 2
=item Verb pattern '%s' has a mandatory argument in regex; marked by <-- HERE 
in m/%s/ 
d6636 2
a6637 2
=item Verb pattern '%s' may not have an argument in regex; marked by <-- HERE 
in m/%s/ 
d6688 2
a6689 2
even be removed in any future release of perl.
See the explanation under L<perlsyn/Experimental Details on given and when>.
d6716 3
a6718 3
(F) When reading in different encodings, Perl tries to map everything
into Unicode characters.  The bytes you read in are not legal in
this encoding.  For example
d6751 1
a6751 1
(F) When trying to initialise the random seed for hashes, Perl could
d6755 8
d6767 1
a6767 1
L<warnings>, L<perllexwarn>, L<diagnostics>.
@


1.15
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d23 1
a23 1
below.
d88 1
a88 1
(W ambiguous)(S) You said something that may not be interpreted the way
d94 1
a94 1
(W ambiguous) C<%>, C<&>, and C<*> are both infix operators (modulus,
d133 1
a133 1
(W ambiguous) You wrote something like C<-foo>, which might be the
a137 14
=item Ambiguous use of 's//le...' resolved as 's// le...'; Rewrite as 's//el' if you meant 'use locale rules and evaluate rhs as an expression'.  In Perl 5.18, it will be resolved the other way

(W deprecated, ambiguous) You wrote a pattern match with substitution
immediately followed by "le".  In Perl 5.16 and earlier, this is
resolved as meaning to take the result of the substitution, and see if
it is stringwise less-than-or-equal-to what follows in the expression.
Having the "le" immediately following a pattern is deprecated behavior,
so in Perl 5.18, this expression will be resolved as meaning to do the
pattern match using the rules of the current locale, and evaluate the
rhs as an expression when doing the substitution.  In 5.14, and 5.16 if
you want the latter interpretation, you can simply write "el" instead.
But note that the C</l> modifier should not be used explicitly anyway;
you should use C<use locale> instead.  See L<perllocale>.

d222 8
d324 1
a324 1
(W internal) Perl went to decrement the reference count of a scalar to
d356 4
a359 3
(W) You tried to set the length of an array which has been freed.  You
can do this by storing a reference to the scalar representing the last index
of an array and later assigning through that reference.  For example
d539 1
a539 1
=item "\b{" is deprecated; use "\b\{" instead
d541 1
a541 1
=item "\B{" is deprecated; use "\B\{" instead
d543 1
a543 1
(W deprecated, regexp) Use of an unescaped "{" immediately following a
d545 3
a547 1
itself in a future release.
d676 1
a676 1
(F) You called C<perl -x/foo/bar>, but C</foo/bar> is not a directory
d724 1
a724 1
a file in /dev, or a FIFO.  The file was ignored.
a742 7
=item Can't do {n,m} with n > m in regex; marked by <-- HERE in m/%s/

(F) Minima must be less than or equal to maxima.  If you really
want your regexp to match something 0 times, just put {0}.  The
<-- HERE shows in the regular expression about where the problem
was discovered.  See L<perlre>.

d792 1
a792 1
for a complete list of available properties.
d1001 9
d1270 7
a1276 2
(F) Only hard references are allowed by "strict refs".  Symbolic
references are disallowed.  See L<perlref>.
d1314 1
a1314 1
It is planned to make this fatal in all instances in Perl 5.18.  In the
d1318 2
a1319 1
Note that non-alphabetic ASCII characters are discouraged here as well.
d1404 1
a1404 1
ability to specify a semi-colon this way in Perl 5.18.  Just use a
d1440 2
a1441 1
=item Code point 0x%X is not Unicode, all \p{} matches fail; all \P{} matches succeed
d1443 1
a1443 1
(W utf8, non_unicode) You had a code point above the Unicode maximum
d1466 2
a1467 2
 chr(0x110000) =~ \p{ASCII_Hex_Digit=True}      # Fails.
 chr(0x110000) =~ \p{ASCII_Hex_Digit=False}     # Also fails!
d1471 2
a1472 2
 chr(0x110000) =~ \P{ASCII_Hex_Digit=True}      # Succeeds.
 chr(0x110000) =~ \P{ASCII_Hex_Digit=False}     # Also succeeds!
d1528 13
a1540 1
=item Constant(%s)%s: %s
a1546 5
=item Constant(%s)%s: %s in regex; marked by <-- HERE in m/%s/

(F) The parser found inconsistencies while attempting to find
the character name specified in the C<\N{...}> escape.

d1600 7
d1654 2
a1655 1
=item (?(DEFINE)....) does not allow branches in regex; marked by <-- HERE in m/%s/
d1661 1
a1661 1
The <-- HERE shows in the regular expression about where the problem was
a1674 8
=item Deprecated character in \N{...}; marked by <-- HERE  in \N{%s<-- HERE %s

(D deprecated) Just about anything is legal for the C<...> in C<\N{...}>.
But starting in 5.12, non-reasonable ones that don't look like names
are deprecated.  A reasonable name begins with an alphabetic character
and continues with any combination of alphanumerics, dashes, spaces,
parentheses or colons.

d1742 1
a1742 1
define a C<$VERSION.>
d1784 2
a1785 2
(W) You have applied the same modifier more than once after a type
in a pack template.  See L<perlfunc/pack>.
d1794 1
a1794 1
=item Empty %s
d1819 18
a1836 1
=item %s: Eval-group in insecure regular expression
d1842 1
a1842 1
=item %s: Eval-group not allowed at runtime, use re 'eval'
d1852 1
a1852 1
=item %s: Eval-group not allowed, use re 'eval'
d1858 2
a1859 1
=item EVAL without pos change exceeded limit in regex; marked by <-- HERE in m/%s/
d1864 1
a1864 1
The <-- HERE shows in the regular expression about where the problem was
d1909 19
d1951 1
a1951 1
"-", "\-".  The <-- HERE shows in the regular expression about where the
d1973 1
a1973 1
(W pack) Each line in an uuencoded string start with a length indicator
d2078 7
d2146 7
a2172 21
=item Having no space between pattern and following word is deprecated

(D syntax)

You had a word that isn't a regex modifier immediately following
a pattern without an intervening space.  If you are trying to use
the C</le> flags on a substitution, use C</el> instead.  Otherwise, add
white space between the pattern and following word to eliminate
the warning.  As an example of the latter, the two constructs:


 $a =~ m/$foo/sand $bar
 $a =~ m/$foo/s and $bar

both currently mean the same thing, but it is planned to disallow
the first form in Perl 5.18.  And,

 $a =~ m/$foo/and $bar

will be disallowed too.

d2179 10
d2196 1
a2196 1
=item Ignoring zero length \N{} in character class
d2198 1
a2198 1
(W) Named Unicode character escapes C<(\N{...})> may return a zero-length
d2271 11
d2311 30
a2340 1
=item Inconsistent hierarchy during C3 merge of class '%s': merging failed on parent '%s'
d2358 1
a2358 1
The <-- HERE shows in the regular expression about where the problem was
d2409 1
a2409 1
(W overflow) The hexadecimal, octal or binary number you have specified
d2419 9
d2430 7
a2436 6
(F) Some portion of a version initialization is too large for the
size of integers for your architecture.  This is not a warning
because there is no rational reason for a version to try and use a
element larger than typically 2**32.  This is usually caused by
trying to use some odd mathematical operation as a version, like
100/9.
d2441 1
a2441 1
The <-- HERE shows in the regular expression about where the problem was
d2456 1
a2456 1
<-- HERE shows in the regular expression about where the problem was
d2476 23
d2504 2
a2505 1
=item Invalid escape in the specified encoding in regex; marked by <-- HERE in m/%s/
d2511 1
a2511 1
The <-- HERE shows in the regular expression about where the
d2516 3
d2537 6
d2545 3
a2547 3
(F) Perl was called with invalid debugger flags.  Call perl with
the B<-D> option with no flags to see the list of acceptable values.
See also L<< perlrun/B<-D>I<letters> >>.
d2554 1
a2554 1
up to C<ff>.  The <-- HERE shows in the regular expression about where the
d2662 1
a2662 1
=item junk on end of regexp
d2753 6
a2758 6
(W) The value you attempted to increment or decrement by one is too large
for the underlying floating point representation to store accurately,
hence the target of C<++> or C<--> is unchanged.  Perl issues this warning
because it has already switched from integers to floating point when values
are too large for integers, and now even floating point is insufficient.
You may wish to switch to using L<Math::BigInt> explicitly.
d2832 9
a2840 1
=item Malformed UTF-8 returned by \N
d2868 1
a2868 1
shows in the regular expression about where the problem was discovered.
d2923 2
d2951 1
a2951 1
=item Missing name in "my sub"
d2967 1
a2967 1
=item Missing right brace on %s
d3094 2
a3095 1
=item \N in a character class must be a named character: \N{...}
d3102 1
a3102 1
=item \N{NAME} must be resolved by the lexer
d3133 19
d3170 2
a3171 2
So things like ** or +* or ?* are illegal.  The <-- HERE shows in the
regular expression about where the problem was discovered.
a3349 5
=item Not a format reference

(F) I'm not sure how you managed to generate a reference to an anonymous
format, but this indicates you did, and that it didn't exist.

d3416 9
d3431 8
d3445 8
d3495 8
d3545 6
d3561 1
a3561 1
(W io, deprecated) You used open() to associate a filehandle to
d3568 1
a3568 1
(W io, deprecated) You used opendir() to associate a dirhandle to
d3573 10
d3592 1
a3592 1
(W utf8, non_unicode) You performed an operation requiring Unicode
d3604 1
a3604 1
(W utf8, surrogate) You performed an operation requiring Unicode
d3739 6
d3907 6
d3952 12
d3969 13
a3981 1
=item Pattern subroutine nesting without pos change exceeded limit in regex; marked by <-- HERE in m/%s/
d3987 1
a3987 1
The <-- HERE shows in the regular expression about where the problem was
a3989 12
=item Parentheses missing around "%s" list

(W parenthesis) You said something like

    my $foo, $bar = @@_;

when you meant

    my ($foo, $bar) = @@_;

Remember that "my", "our", "local" and "state" bind tighter than comma.

d4002 2
a4003 1
=item Perl folding rules are not up-to-date for 0x%x; please use the perlbug utility to report
d4005 1
a4005 1
(W regex, deprecated) You used a regular expression with
d4009 1
a4009 1
"perlbug" utility.  (This message is marked deprecated, so that it by
d4041 1
a4041 1
See L<perlrun/PERL_SIGNALS> for legal values.
d4050 1
d4073 21
d4107 1
a4107 1
shows in the regular expression about where the problem was discovered.
d4117 2
a4118 1
=item POSIX syntax [%s] belongs inside character classes in regex; marked by <-- HERE in m/%s/
d4123 3
a4125 12
implemented; they are simply placeholders for future extensions and will
cause fatal errors.  The <-- HERE shows in the regular expression about
where the problem was discovered.  See L<perlre>.

=item POSIX syntax [. .] is reserved for future extensions in regex; marked by <-- HERE in m/%s/

(F regexp) Within regular expression character classes ([]) the syntax
beginning with "[." and ending with ".]" is reserved for future extensions.
If you need to represent those character sequences inside a regular
expression character class, just quote the square brackets with the
backslash: "\[." and ".\]".  The <-- HERE shows in the regular expression
about where the problem was discovered.  See L<perlre>.
d4127 12
a4138 1
=item POSIX syntax [= =] is reserved for future extensions in regex; marked by <-- HERE in m/%s/
d4144 1
a4144 1
and "=\]".  The <-- HERE shows in the regular expression about where the
d4269 11
d4319 5
d4327 2
a4328 2
you meant it literally.  The <-- HERE shows in the regular expression
about where the problem was discovered.  See L<perlre>.
d4333 2
a4334 2
the {min,max} construct.  The <-- HERE shows in the regular expression
about where the problem was discovered.  See L<perlre>.
d4336 2
a4337 1
=item Quantifier unexpected on zero-length expression; marked by <-- HERE in m/%s/
d4345 1
a4345 1
The <-- HERE shows in the regular expression about where the problem was
d4348 5
d4389 1
a4389 1
(F debugging) You can't use the B<-D> option unless the code to produce
d4432 1
a4432 1
=item Reference to invalid group 0
d4446 1
a4446 1
The <-- HERE shows in the regular expression about where the problem was
d4456 1
a4456 1
The <-- HERE shows in the regular expression about where the problem was
d4459 2
a4460 1
=item Reference to nonexistent or unclosed group in regex; marked by <-- HERE in m/%s/
d4466 1
a4466 1
The <-- HERE shows in the regular expression about where the problem was
d4481 2
a4482 1
=item Regexp modifier "%c" may not appear after the "-"
d4484 2
a4485 2
(F regexp) Turning off the given modifier has the side effect of turning
on another one.  Perl currently doesn't allow this.  Reword the regular
d4495 1
a4495 1
=item Regexp out of space
d4512 9
d4533 5
a4537 4
(P) Something went wrong in Perl's internal bookkeeping of scalars:
not all scalar variables were deallocated by the time Perl exited.
What this usually indicates is a memory leak, which is of course bad,
especially if the Perl program is intended to be long-running.
d4631 1
a4631 1
<-- HERE shows in the regular expression about where the problem was
d4637 2
a4638 2
but has not yet been written.  The <-- HERE shows in the regular
expression about where the problem was discovered.  See L<perlre>.
d4643 1
a4643 1
<-- HERE shows in the regular expression about where the problem was
d4654 1
a4654 1
=item Sequence (?#... not terminated in regex; marked by <-- HERE in m/%s/
d4657 1
a4657 2
parenthesis.  Embedded parentheses aren't allowed.  The <-- HERE shows in
the regular expression about where the problem was discovered.  See
d4660 1
a4660 1
=item Sequence (?{...}) not terminated or not {}-balanced in regex; marked by <-- HERE in m/%s/
d4662 2
a4663 4
(F) If the contents of a (?{...}) clause contain braces, they
must balance for Perl to detect the end of the clause properly.
The <-- HERE shows in the regular expression about where the
problem was discovered.  See L<perlre>.
d4761 21
d4795 2
a4796 2
(F) A sort comparison subroutine may not return a list value with more
or less than one element.  See L<perlfunc/sort>.
d4833 8
d4852 38
d4931 2
a4932 1
=item Switch (?(condition)... contains too many branches in regex; marked by <-- HERE in m/%s/
d4941 1
a4941 1
The <-- HERE shows in the regular expression about where the problem
d4947 2
a4948 2
a number, it can be only a number.  The <-- HERE shows in the regular
expression about where the problem was discovered.  See L<perlre>.
d5000 6
d5053 1
a5053 1
=item The crypt() function is unimplemented due to excessive paranoia
d5061 35
d5124 8
d5218 8
a5270 4
=item Unable to create sub named "%s"

(F) You attempted to create or access a subroutine with an illegal name.

d5273 1
a5273 1
(W internal) The exit code detected an internal inconsistency in how
d5278 1
a5278 1
(W internal) The exit code detected an internal inconsistency in how
d5283 1
a5283 1
(W internal) The exit code detected an internal inconsistency in how
d5288 1
a5288 1
(W internal) On exit, Perl found some strings remaining in the shared
d5294 1
a5294 1
(W internal) The exit code detected an internal inconsistency in how
d5343 47
d5397 1
a5397 1
(W utf8, nonchar) Certain codepoints, such as U+FFFE and U+FFFF, are
d5405 1
a5405 1
(W utf8, surrogate) You had a UTF-16 surrogate in a context where they are
d5419 10
d5460 15
d5490 1
a5490 1
The <-- HERE shows in the regular expression about where the problem was
d5518 11
a5528 1
=item unmatched [ in regex; marked by <-- HERE in m/%s/
d5532 1
a5532 1
first.  The <-- HERE shows in the regular expression about where the
d5535 14
a5548 1
=item unmatched ( in regex; marked by <-- HERE in m/%s/
d5552 2
a5553 2
the matching parenthesis.  The <-- HERE shows in the regular expression
about where the problem was discovered.  See L<perlre>.
d5575 9
a5583 1
=item Unrecognized escape \%c in character class passed through in regex; marked by <-- HERE in m/%s/
d5588 1
a5588 1
The <-- HERE shows in the regular expression about where the
d5601 2
a5602 2
this may change in a future version of Perl.  The <-- HERE shows in
the regular expression about where the escape was discovered.
d5669 12
d5729 23
d5758 2
a5759 1
=item Useless (?-%s) - don't use /%s modifier in regex; marked by <-- HERE in m/%s/
d5770 2
a5771 2
The <-- HERE shows in the regular expression about
where the problem was discovered.  See L<perlre>.
d5790 2
a5791 2
The <-- HERE shows in the regular expression about
where the problem was discovered.  See L<perlre>.
d5799 25
d5881 6
d5896 14
d6031 6
a6056 11
=item Use of qw(...) as parentheses is deprecated

(D deprecated) You have something like C<foreach $x qw(a b c) {...}>,
using a C<qw(...)> list literal where a parenthesised expression is
expected.  Historically the parser fooled itself into thinking that
C<qw(...)> literals were always enclosed in parentheses, and as a result
you could sometimes omit parentheses around them.  (You could never do
the C<foreach qw(a b c) {...}> that you might have expected, though.)
The parser no longer lies to itself in this way.  Wrap the list literal
in parentheses, like C<foreach $x (qw(a b c)) {...}>.

d6068 1
a6068 1
=item Use of reserved word "%s" is deprecated
d6070 3
a6072 6
(D deprecated) The indicated bareword is a reserved word.  Future
versions of perl may use it as a keyword, so you're better off either
explicitly quoting the word in a manner appropriate for its context of
use, or using a different name altogether.  The warning can be
suppressed for subroutine names by either adding a C<&> prefix, or using
a package qualifier, e.g. C<&our()>, or C<Foo::our()>.
d6111 2
a6112 1
=item Using just the first character returned by \N{} in character class
d6114 3
a6116 3
(W) A charnames handler may return a sequence of more than one character.
Currently all but the first one are discarded when used in a regular
expression pattern bracketed character class.
d6127 1
a6127 1
(W utf8, surrogate) You had a UTF-16 surrogate in a context where they are
d6184 1
a6184 1
(W misc) With "use strict" in effect, you referred to a global variable
d6190 1
a6190 1
=item Variable length lookbehind not implemented in m/%s/
d6201 1
a6201 1
or until all closure referents to it are destroyed.
d6228 1
a6228 1
(W internal) The %vd (s)printf format does not support version objects
d6231 2
a6232 1
=item Verb pattern '%s' has a mandatory argument in regex; marked by <-- HERE in m/%s/ 
d6237 2
a6238 1
=item Verb pattern '%s' may not have an argument in regex; marked by <-- HERE in m/%s/ 
d6284 8
d6317 1
a6317 1
(F) When reading in different encodings Perl tries to map everything
d6319 1
a6319 1
this encoding, for example
@


1.14
log
@merge in perl 5.12.2 plus local changes
@
text
@d26 1
a26 1
and B<-W> switches. Warnings may be captured by setting C<$SIG{__WARN__}>
d53 1
a53 1
=item Allocation too large: %lx
d92 60
a182 7
=item Args must match #! line

(F) The setuid emulator requires that the arguments Perl was invoked
with match the arguments specified on the #! line.  Since some systems
impose a one-argument limit on the #! line, try combining switches;
for example, turn C<-w -U> into C<-wU>.

d223 7
a229 6
(W layer) When pushing a layer with arguments onto the Perl I/O system you
forgot the ) that closes the argument list.  (Layers take care of transforming
data between external and internal representations.)  Perl stopped parsing
the layer list at this point and did not attempt to push this layer.
If your program didn't explicitly request the failing operation, it may be
the result of the value of the environment variable PERLIO.
d238 1
a238 1
(P) The malloc package that comes with Perl had an internal failure.
d242 6
a247 1
(P) A general assertion failed.  The file in question must be examined.
d257 4
a260 4
(W threads)(S) When using threaded Perl, a thread (not necessarily the main
thread) exited while there were still other threads running.
Usually it's a good idea to first collect the return values of the
created threads by joining them, and only then exit from the main
d271 1
a271 1
the name of the package to bless the resulting object into. You've
d286 7
d303 1
a303 1
=item Attempt to free non-arena SV: 0x%lx
d305 1
a305 1
(P internal) All SV objects are supposed to be allocated from arenas
d309 1
a309 1
=item Attempt to free nonexistent shared string
d311 1
a311 1
(P internal) Perl maintains a reference counted internal table of
d316 1
a316 1
=item Attempt to free temp prematurely
d318 1
a318 1
(W debugging) Mortalized values are supposed to be freed by the
d326 1
a326 1
(P internal) The reference counts got screwed up on symbol aliases.
d328 1
a328 1
=item Attempt to free unreferenced scalar
d364 1
a364 1
of an array and later assigning through that reference. For example
d377 4
a380 4
(D deprecated) You have used the attributes pragam to modify the "locked"
attribute on a code reference. The :locked attribute is obsolete, has had no
effect since 5005 threads were removed, and will be removed in the next major
release of Perl 5.
d384 4
a387 4
(D deprecated) You have used the attributes pragam to modify the "unique"
attribute on an array, hash or scalar reference. The :unique attribute has
had no effect since Perl 5.8.8, and will be removed in the next major
release of Perl 5.
d389 6
a394 1
=item Bad arg length for %s, is %d, should be %d
d416 1
a416 1
been malloc()ed in the first place. Mandatory, but can be disabled by
d420 1
a420 1
dynamic linking, like C<AIX> and C<OS/2>. It is a bug of C<Berkeley DB>
d433 1
a433 1
=item Bad name after %s::
d454 3
a456 3
(S malloc) An internal routine called realloc() on something that had
never been malloc()ed in the first place. Mandatory, but can be disabled
by setting environment variable C<PERL_BADFREE> to 1.
a467 1

d542 9
a550 1
Check you control flow and number of arguments.
d556 1
a556 1
=item Bizarre copy of %s in %s
d559 1
a559 1
copyable.
d567 5
d602 4
a605 4
(F) You manipulated Perl's symbol table directly, stored a reference in it,
then tried to access that symbol via conventional Perl syntax. The access
triggers Perl to autovivify that typeglob, but it there is no legal conversion
from that type of reference to a typeglob.
d607 1
a607 1
=item Cannot copy to %s in %s
d610 1
a610 1
be directly assigned not.
d617 12
d643 1
a643 1
a C<given> block. You probably meant to use C<next> or C<last>.
a648 6
=item Can't call method "%s" in empty package "%s"

(F) You called a method correctly, and it correctly indicated a package
functioning as a class, but that package doesn't have ANYTHING defined
in it, let alone methods.  See L<perlobj>.

d687 1
a687 7
=item Can't coerce array into hash

(F) You used an array where a hash was expected, but the array has no
information on how to map from keys to array indices.  You can do that
only with arrays that have a hash reference at index 0.

=item Can't coerce %s to integer in %s
a701 10
=item Can't coerce %s to number in %s

(F) Certain types of SVs, in particular real symbol table entries
(typeglobs), can't be forced to stop being what they are.

=item Can't coerce %s to string in %s

(F) Certain types of SVs, in particular real symbol table entries
(typeglobs), can't be forced to stop being what they are.

a711 6
=item Can't declare class for non-scalar %s in "%s"

(F) Currently, only scalar variables can be declared with a specific
class qualifier in a "my", "our" or "state" declaration.  The semantics may be
extended for other types of variables in future.

d717 7
d748 4
a751 3
(F) Minima must be less than or equal to maxima. If you really want your
regexp to match something 0 times, just put {0}. The <-- HERE shows in the
regular expression about where the problem was discovered. See L<perlre>.
d800 1
a800 1
could not be found. Maybe you misspelled the name of the property?
d828 5
a832 3
If you're getting this error from a here-document, you may have included
unseen whitespace before or after your closing tag. A good programmer's
editor will have a way to help you find these characters.
d836 3
a838 3
(F) You may have tried to use C<\p> which means a Unicode property (for
example C<\p{Lu}> matches all uppercase letters).  If you did mean to use a
Unicode property, see
d840 4
a843 4
for a complete list of available properties.
If you didn't mean to use a Unicode property, escape the C<\p>, either
by C<\\p> (just the C<\p>) or by C<\Q\p> (the rest of the string, until
possible C<\E>).
d863 1
a863 1
the access checking routine.  It will try to retrieve the filespec using
d867 2
a868 2
appears, the name lookup failed, and the access checking routine gave up
and returned FALSE, just to be conservative.  (Note: The access checking
d945 7
a951 7
(F) The module you tried to load failed to load a dynamic extension. This
may either mean that you upgraded your version of perl to one that is
incompatible with your old dynamic extensions (which is known to happen
between major versions of perl), or (more likely) that your dynamic
extension was built against an older version of the library that is
installed on your system. You may need to rebuild your old dynamic
extensions.
d956 3
a958 3
lexical variable using "my" or "state".  This is not allowed.  If you want to
localize a package variable of the same name, qualify it with the
package name.
d969 5
a973 5
(F) You said to C<do> (or C<require>, or C<use>) a file that couldn't be
found. Perl looks for the file in all the locations mentioned in @@INC,
unless the file name included the full path to the file.  Perhaps you
need to set the PERL5LIB or PERL5OPT environment variable to say where
the extra library is, or maybe the script needs to add the library name
d987 1
a987 1
for example, C<foo.so> or C<bar.dll>, but the L<DynaLoader> module was
d1006 1
a1006 1
=item Can't make list assignment to \%ENV on this system
d1024 1
a1024 1
such, see L<perlsub/"Lvalue subroutines">.
d1040 6
d1050 6
a1055 3
switches, or explicitly, failed for the indicated reason.  Usually this
is because you don't have read permission for a file which you named on
the command line.
d1060 1
a1060 1
using the 3-arg open() syntax :
d1098 1
a1098 1
=item Can't open perl script%s
d1139 7
d1148 3
a1150 3
(F|P) Error resolving overloading specified by a method name (as opposed
to a subroutine reference): no such method callable via the package. If
method name is C<???>, this is an internal error.
d1165 5
a1169 5
(F) You tried to return a complete array or hash from an lvalue subroutine,
but you called the subroutine in a way that made Perl think you meant
to return only one value. You probably meant to write parentheses around
the call to the subroutine, which tell Perl that the call should be in
list context.
d1179 1
a1179 1
negative number or zero. There's a Math::Complex package that comes
a1194 5
=item Can't unshift

(F) You tried to unshift an "unreal" array that can't be unshifted, such
as the main Perl stack.

d1202 5
d1225 2
a1226 2
(F) The first time the %! hash is used, perl automatically loads the
Errno.pm module. The Errno module is expected to tie the %! hash to
d1289 6
a1294 1
=item Can't use "when" outside a topicalizer
d1297 1
a1297 1
loop nor a C<given> block. (Note that this error is issued on exit
a1300 5
=item Can't weaken a nonreference

(F) You attempted to weaken something that was not a reference.  Only
references can be weakened.

d1307 9
d1337 3
a1339 3
where $x is either less than 0 or more than 255. However, C<U0>-mode expects
all values to fall in the interval [0, 255], so Perl behaved as if you
meant:
d1365 2
a1366 2
below 256), but a higher value was provided instead. Perl uses the value
modulus 256 instead, as if you had provided:
d1377 1
a1377 1
value below 256), but some of the characters had a higher value. Perl
d1389 1
a1389 1
value below 256), but some of the characters had a higher value. Perl
d1394 19
d1422 6
d1430 37
a1466 2
(F) You had a (sub-)template that ends with a '/'. There must be another
template code following the slash. See L<perlfunc/pack>.
d1470 5
a1474 2
(A) You've accidentally run your script through B<csh> instead of Perl.
Check the #! line, or manually feed your script into Perl yourself.
d1496 8
a1503 8
(W threads) Within a thread-enabled program, you tried to call
cond_broadcast() on a variable which wasn't locked. The cond_broadcast()
function  is used to wake up another thread that is waiting in a
cond_wait(). To ensure that the signal isn't sent before the other thread
has a chance to enter the wait, it is usual for the signaling thread to
first wait for a lock on variable. This lock attempt will only succeed
after the other thread has entered cond_wait() and thus relinquished the
lock.
d1507 8
a1514 8
(W threads) Within a thread-enabled program, you tried to call
cond_signal() on a variable which wasn't locked. The cond_signal()
function  is used to wake up another thread that is waiting in a
cond_wait(). To ensure that the signal isn't sent before the other thread
has a chance to enter the wait, it is usual for the signaling thread to
first wait for a lock on variable. This lock attempt will only succeed
after the other thread has entered cond_wait() and thus relinquished the
lock.
d1527 1
a1527 2
corresponding C<overload> or C<charnames> pragma?  See L<charnames> and
L<overload>.
d1532 1
a1532 4
the character name specified in the C<\N{...}> escape.  Perhaps you
forgot to load the corresponding C<charnames> pragma?
See L<charnames>.

d1538 1
a1538 1
The message indicates the type of reference that was expected. This
d1544 3
a1546 3
(S) You redefined a subroutine which had previously been
eligible for inlining.  See L<perlsub/"Constant Functions"> for
commentary and workarounds.
d1556 1
a1556 1
(F) The method which overloads "=" is buggy. See
d1559 10
d1583 1
a1583 1
=item Corrupt malloc ptr 0x%lx at 0x%lx
d1593 2
d1613 29
a1641 3
(D deprecated) defined() is not usually useful on hashes because it
checks for an undefined I<scalar> value.  If you want to see if the hash
is empty, just use C<if (%hash) { # not empty }> for example.
d1654 1
a1654 1
=item Deprecated character(s) in \\N{...} starting at '%s'
d1657 4
a1660 4
But starting in 5.12, non-reasonable ones that don't look like names are
deprecated.  A reasonable name begins with an alphabetic character and
continues with any combination of alphanumerics, dashes, spaces, parentheses or
colons.
d1664 2
a1665 2
(D deprecated) You used a declaration similar to C<my $x if 0>.
There has been a long-standing bug in Perl that causes a lexical variable
d1667 3
a1669 3
conditional. Some people have exploited this bug to achieve a kind of
static variable. Since we intend to fix this bug, we don't want people
relying on this behavior. You can achieve a similar static effect by
d1678 2
a1679 2
Beginning with perl 5.9.4, you can also use C<state> variables to
have lexicals that are initialized only once (see L<feature>):
d1686 2
a1687 2
just being DESTROYed. Perl is confused, and prefers to abort rather than
to create a dangling reference.
d1702 2
a1703 2
(W) You probably referred to an imported subroutine &FOO as $FOO or some
such.
d1720 1
a1720 1
you called it with no args and both C<$@@> and C<$_> were empty.
d1776 3
a1778 3
(S syntax) There is no keyword "elseif" in Perl because Larry thinks it's
ugly. Your code will be interpreted as an attempt to call a method named
"elseif" for the class returned by the following block.  This is
d1784 1
a1784 1
described in L<perlunicode> and L<perlre>. You used C<\p> or C<\P> in
d1796 1
a1796 1
program's environment. This is potentially insecure.
d1816 5
a1820 4
pattern contains interpolated values.  Since that is a security risk, it
is not allowed.  If you insist, you may still do this by explicitly
building the pattern from an interpolated string at run time and using
that in an eval().  See L<perlre/(?{ code })>.
d1831 1
a1831 1
any text. Restructure the pattern so that text is consumed.
d1845 2
a1846 1
(F) The C<exec> function is not implemented in MacPerl. See L<perlport>.
d1904 1
a1904 1
=item Fatal VMS error at %s, line %d
d1924 3
a1926 3
which can't encode values above 63. So there is no point in asking for
a line length bigger than that. Perl will behave as if you specified
C<u63> as format.
d1939 4
a1942 4
with "+<" or "+>" or "+>>" instead of with "<" or nothing.  If you
intended only to read from the file, use "<".  See L<perlfunc/open>.
Another possibility is that you attempted to open filedescriptor 0
(also known as STDIN) for output (maybe you closed STDIN earlier?).
d1947 1
a1947 1
as STDOUT or STDERR. This occurred because you closed STDOUT or STDERR
d1953 1
a1953 1
as STDIN. This occurred because you closed STDIN previously.
d2037 3
a2039 3
(W glob) Something went wrong with the external program(s) used for
C<glob> and C<< <*.c> >>.  Usually, this means that you supplied a
C<glob> pattern that caused the external program to fail and exit with a
d2041 5
a2045 5
resulted in a coredump, this may also mean that your csh (C shell) is
broken.  If so, you should change all of the csh-related variables in
config.sh:  If you have tcsh, make the variables refer to it as if it
were csh (e.g.  C<full_csh='/usr/bin/tcsh'>); otherwise, make them all
empty (except that C<d_csh> should be C<'undef'>) so that Perl will
d2056 1
a2056 1
=item gmtime(%.0f) too large
d2058 1
a2058 1
(W overflow) You called C<gmtime> with an number that was larger than
d2060 1
a2060 1
date. This warning is also triggered with nan (the special
d2063 1
a2063 1
=item gmtime(%.0f) too small
d2065 2
a2066 4
(W overflow) You called C<gmtime> with an number that was smaller than
it can reliably handle and C<gmtime> probably returned the wrong
date. This warning is also triggered with nan (the special
not-a-number value).
d2078 6
d2086 2
a2087 3
(F) A ()-group started with a count.  A count is
supposed to follow something: a template character or a ()-group.
 See L<perlfunc/pack>.
d2109 21
d2145 3
a2147 3
(W) Named Unicode character escapes (\N{...}) may return a
zero length sequence.  When such an escape is used in a character class
its behaviour is not well defined. Check that the correct escape has
d2160 6
a2165 1
=item Illegal character %s (carriage return)
d2176 1
a2176 1
Legal characters in prototypes are $, @@, %, *, ;, [, ], &, and \.
d2181 1
a2181 1
you must always specify a block of code. See L<perlsub>.
d2185 1
a2185 1
(F) A subroutine was not declared correctly. See L<perlsub>.
d2262 1
a2262 1
text. You should check the pattern to ensure that recursive patterns
d2270 5
a2274 4
(F) Currently the implementation of "state" only permits the initialization
of scalar variables in scalar context. Re-write C<state ($a) = 42> as
C<state $a = 42> to change from list to scalar context. Constructions such
as C<state (@@a) = foo()> will be supported in a future perl release.
d2301 13
a2325 6
=item Integer overflow in format string for %s

(F) The indexes and widths specified in the format string of C<printf()>
or C<sprintf()> are too large.  The numbers must not overflow the size of
integers for your architecture.

d2352 1
a2352 1
(P) Something went badly awry in the regular expression parser. The
d2365 1
a2365 1
The indicated attribute for a subroutine or variable was not recognized
d2370 1
a2370 1
The indicated attributes for a subroutine or variable were not
d2387 13
d2402 10
a2411 3
(F) You tried to C<mro::set_mro("classname", "foo")>
or C<use mro 'foo'>, where C<foo> is not a valid method resolution order (MRO).
(Currently, the only valid ones are C<dfs> and C<c3>). See L<mro>.
d2435 2
a2436 2
(W layer) When pushing layers onto the Perl I/O system, something other than a
colon or whitespace was seen between the elements of a layer list.
d2440 9
d2453 1
d2457 1
a2457 5
=item Invalid version format (multiple underscores)

(F) Versions may contain at most a single underscore, which signals
that the version is a beta release.  See L<version> for the allowed
version formats.
d2459 16
a2474 4
=item Invalid version format (underscores before decimal)

(F) Versions may not contain decimals after the optional underscore.
See L<version> for the allowed version formats.
d2484 1
a2484 1
Check you control flow and number of arguments.
d2489 1
a2489 1
you cannot use IO layers.  To have PerlIO Perl must be configured
d2495 1
a2495 1
neither as a system call or an ioctl call (SIOCATMARK).
d2499 4
a2502 3
(D deprecated, syntax) The special variable C<$*>, deprecated in older perls, has
been removed as of 5.9.0 and is no longer supported. In previous versions of perl the use of
C<$*> enabled or disabled multi-line matching within a string.
d2505 3
a2507 2
modifiers. (In older versions: when C<$*> was set to a true value then all regular
expressions behaved as if they were written using C</m>.)
d2511 3
a2513 3
(D deprecated, syntax) The special variable C<$#>, deprecated in older perls, has
been removed as of 5.9.3 and is no longer supported. You should use the
printf/sprintf functions instead.
d2515 1
a2515 1
=item `%s' is not a code reference
d2517 3
a2519 3
(W overload) The second (fourth, sixth, ...) argument of overload::constant
needs to be a code reference. Either an anonymous subroutine, or a reference
to a subroutine.
d2521 1
a2521 1
=item `%s' is not an overloadable type
d2556 15
a2570 2
length/code combination tried to obtain more data. This results in
an undefined value for the length. See L<perlfunc/pack>.
d2575 4
a2578 5
(using L<lex_stuff_pvn_flags|perlapi/lex_stuff_pvn_flags> or similar), but
tried to insert a character that couldn't be part of the current input.
This is an inherent pitfall of the stuffing mechanism, and one of the
reasons to avoid it.  Where it is necessary to stuff, stuffing only
plain ASCII is recommended.
d2591 7
a2597 1
=item localtime(%.0f) too large
d2599 1
a2599 1
(W overflow) You called C<localtime> with an number that was larger
d2601 1
a2601 1
wrong date. This warning is also triggered with nan (the special
d2604 1
a2604 1
=item localtime(%.0f) too small
d2606 1
a2606 1
(W overflow) You called C<localtime> with an number that was smaller
d2608 1
a2608 2
wrong date. This warning is also triggered with nan (the special
not-a-number value).
d2613 1
a2613 1
handle. This restriction may be eased in a future release. 
d2619 1
a2619 1
hence the target of C<++> or C<--> is unchanged. Perl issues this warning
d2624 1
a2624 1
=item lstat() on filehandle %s
d2630 9
d2641 5
a2645 5
(W misc) Making a subroutine an lvalue subroutine after it has been defined
by declaring the subroutine with a lvalue attribute is not
possible. To make the the subroutine a lvalue subroutine add the
lvalue attribute to the definition, or put the the declaration before
the definition.
d2647 1
a2647 1
=item Lvalue subs returning %s not implemented yet
d2649 1
a2649 3
(F) Due to limitations in the current implementation, array and hash
values cannot be returned in subroutines used in lvalue context.  See
L<perlsub/"Lvalue subroutines">.
d2651 1
a2651 3
=item Malformed integer in [] in  pack

(F) Between the  brackets enclosing a numeric repeat count only digits
d2656 1
a2656 1
(F) Between the  brackets enclosing a numeric repeat count only digits
d2682 1
a2682 1
(S utf8) (F) Perl detected a string that didn't comply with UTF-8
d2687 1
a2687 1
8-bit data). To guard against this, you can use Encode::decode_utf8.
d2696 1
a2696 1
=item Malformed UTF-16 surrogate
d2698 1
a2698 2
(F) Perl thought it was reading UTF-16 encoded character data but while
doing it Perl met a malformed Unicode surrogate.
d2700 1
a2700 1
=item Malformed UTF-8 returned by \N
d2702 2
a2703 1
(F) The charnames handler returned malformed UTF-8.
d2715 1
a2715 1
=item Malformed UTF-8 string in '%c' format in unpack
d2717 2
a2718 10
(F) You tried to unpack something that didn't comply with UTF-8 encoding
rules and perl was unable to guess how to make more progress.

=item Maximal count of pending signals (%d) exceeded

(F) Perl aborted due to a too high number of signals pending. This
usually indicates that your operating system tried to deliver signals
too fast (with a very high priority), starving the perl process from
resources it would need to reach a point where it can process signals
safely. (See L<perlipc/"Deferred Signals (Safe Signals)">.)
d2727 8
d2741 1
a2741 1
=item % may not be used in pack
d2780 8
a2787 4
double-quotish context.  This can also happen when there is a space (or
comment) between the C<\N> and the C<{> in a regex with the C</x> modifier.
This modifier does not change the requirement that the brace immediately follow
the C<\N>.
d2825 1
a2825 1
=item Missing right brace on \\N{} or unescaped left brace after \\N
d2827 1
a2827 2
(F)
C<\N> has two meanings.
d2829 21
a2849 21
The traditional one has it followed by a name enclosed
in braces, meaning the character (or sequence of characters) given by that name.
Thus C<\N{ASTERISK}> is another way of writing C<*>, valid in both
double-quoted strings and regular expression patterns.  In patterns, it doesn't
have the meaning an unescaped C<*> does.

Starting in Perl 5.12.0, C<\N> also can have an additional meaning (only) in
patterns, namely to match a non-newline character.  (This is short for
C<[^\n]>, and like C<.> but is not affected by the C</s> regex modifier.)

This can lead to some ambiguities.  When C<\N> is not followed immediately by a
left brace, Perl assumes the C<[^\n]> meaning.  Also, if
the braces form a valid quantifier such as C<\N{3}> or C<\N{5,}>, Perl assumes
that this means to match the given quantity of non-newlines (in these examples,
3; and 5 or more, respectively).  In all other case, where there is a C<\N{>
and a matching C<}>, Perl assumes that a character name is desired.

However, if there is no matching C<}>, Perl doesn't know if it was mistakenly
omitted, or if C<[^\n]{> was desired, and
raises this error.  If you meant the former, add the right brace; if you meant
the latter, escape the brace with a backslash, like so: C<\N\{>
d2877 4
a2880 4
        $x = 1;
        foreach my $n ($x, 2) {
            $n *= 2; # modifies the $x, but fails on attempt to modify the 2
        }
d2905 1
a2905 1
(F) The C<open> function has been asked to open multiple files. This
d2930 1
a2930 1
=item "%s" variable %s can't be in a package
d2936 6
a2941 1
=item \\N in a character class must be a named character: \\N{...}
d2943 4
a2946 3
(F) The new (5.12) meaning of C<\N> as C<[^\n]> is not valid in a bracketed
character class, for the same reason that C<.> in a character class loses its
specialness: it matches almost everything, which is probably not what you want.
d2948 1
a2948 1
=item \\N{NAME} must be resolved by the lexer
d2950 11
a2960 3
(F) When compiling a regex pattern, an unresolved named character or sequence
was encountered.  This can happen in any of several ways that bypass the lexer,
such as using single-quotish context, or an extra backslash in double quotish:
a2985 18
=item Name "%s::%s" used only once: possible typo

(W once) Typographical errors often show up as unique variable names.
If you had a good reason for having a unique name, then just mention it
again somehow to suppress the message.  The C<our> declaration is
provided for this purpose.

NOTE: This warning detects symbols that have been used only once so $c, @@c,
%c, *c, &c, sub c{}, c(), and c (the filehandle or format) are considered
the same; if a program uses $c only once but also uses any of the others it
will not trigger this warning.

=item Invalid hexadecimal number in \\N{U+...}

(F) The character constant represented by C<...> is not a valid hexadecimal
number.  Either it is empty, or you tried to use a character other than 0 - 9
or A - F, a - f in a hexadecimal number.

d3003 3
a3005 3
(F) You can't quantify a quantifier without intervening parentheses. So
things like ** or +* or ?* are illegal. The <-- HERE shows in the regular
expression about where the problem was discovered.
d3028 10
d3040 2
a3041 2
(F) A list operator that has a filehandle or "indirect object" is not
allowed to have a comma between that and the following arguments.
d3044 11
a3054 11
One possible cause for this is that you expected to have imported a
constant to your name space with B<use> or B<import> while no such
importing took place, it may for example be that your operating system
does not support that particular constant. Hopefully you did use an
explicit import list for the constants you expect to see, please see
L<perlfunc/use> and L<perlfunc/import>. While an explicit import list
would probably have caught this error earlier it naturally does not
remedy the fact that your operating system still does not support that
constant. Maybe you have a typo in the constants of the symbol import
list of B<use> or B<import> or in the constant name at the line where
this error was triggered?
d3065 1
a3065 1
for some reason the  current debugger (e.g. F<perl5db.pl> or a C<Devel::>
d3081 1
a3081 1
=item No B<-e> allowed in setuid scripts
d3083 2
a3084 1
(F) A setuid script can't be specified by the user.
d3095 1
a3095 1
matching counterpart. See L<perlfunc/pack>.
a3102 5
=item No #! line

(F) The setuid emulator requires that scripts have a well-formed #! line
even on machines that don't support the #! construct.

d3108 1
a3108 1
or C<next::can>. See L<mro>.
a3147 5
=item No %s specified for -%c

(F) The indicated command line switch needs a mandatory argument, but
you haven't specified one.

d3150 4
a3153 3
(F) You tried to access a key from a hash through the indicated typed variable
but that key is not allowed by the package of the same type.  The indicated
package has restricted the set of allowed keys using the L<fields> pragma.
d3157 2
a3158 2
(F) You provided a class qualifier in a "my", "our" or "state" declaration, but
this class doesn't exist at this point in your program.
d3162 2
a3163 2
(F) You specified a signal hook that was not recognized by Perl.  Currently, Perl
accepts C<__DIE__> and C<__WARN__> as valid signal hooks
d3208 1
a3208 1
=item Not a perl script
d3210 3
a3212 3
(F) The setuid emulator requires that scripts have a well-formed #! line
even on machines that don't support the #! construct.  The line must
mention perl.
d3255 6
d3265 1
a3265 1
select. See L<perlfunc/select>
d3274 1
a3274 1
(P debugging) Some internal routine called run() with a null opcode
d3303 1
a3303 1
=item Octal number in vector unsupported
d3305 3
a3307 3
(F) Numbers with a leading C<0> are not currently allowed in vectors.
The octal number interpretation of such numbers may be supported in a
future version.
a3314 2
See also L<perlport> for writing portable code.

d3318 1
a3318 1
arguments. The arguments should come in pairs.
d3332 1
a3332 1
(F, W layer) You tried to do a read/write/send/recv/seek operation
d3361 1
a3361 1
(W io deprecated) You used open() to associate a filehandle to
d3368 1
a3368 1
(W io deprecated) You used opendir() to associate a dirhandle to
d3378 28
a3405 1
C<fallback> overloading key is specified to be true.  See L<overload>.
d3440 1
a3440 1
remaining memory (or virtual memory) to satisfy the request. However,
d3446 1
a3446 1
(X|F) The malloc() function returned 0, indicating there was
d3482 7
a3488 2
the string being unpacked. The string being unpacked was also invalid
UTF-8. See L<perlfunc/pack>.
d3493 1
a3493 1
but the overloaded operation did not return a reference. See
d3499 1
a3499 1
overloaded operation didn't return a compiled regexp. See L<overload>.
d3529 1
a3529 1
=item panic: ck_grep
d3533 1
a3533 1
=item panic: ck_split
d3537 1
a3537 1
=item panic: corrupt saved stack index
a3546 7
=item panic: Devel::DProf inconsistent subroutine return

(P) Devel::DProf called a subroutine that exited using goto(LABEL),
last(LABEL) or next(LABEL). Leaving that way a subroutine called from
an XSUB will lead very probably to a crash of the interpreter. This is
a bug that will hopefully one day get fixed.

d3571 1
a3571 1
=item panic: goto
d3576 1
a3576 1
=item panic: hfreeentries failed to free hash
d3578 4
a3581 4
(P) The internal routine used to clear a hashes entries tried repeatedly,
but each time something added more entries to the hash. Most likely the hash
contains an object with a reference back to the hash and a destructor that
adds a new object to the hash.
d3583 1
a3583 1
=item panic: INTERPCASEMOD
d3587 1
a3587 1
=item panic: INTERPCONCAT
d3595 1
a3595 1
=item panic: last
d3605 1
a3605 1
=item panic: leave_scope inconsistency
d3615 1
a3615 1
=item panic: malloc
d3623 1
a3623 1
=item panic: pad_alloc
d3628 1
a3628 1
=item panic: pad_free curpad
d3637 1
a3637 1
=item panic: pad_reset curpad
d3646 1
a3646 1
=item panic: pad_swipe curpad
d3655 1
a3655 1
=item panic: pp_iter
d3664 1
a3664 1
=item panic: pp_split
d3668 1
a3668 1
=item panic: realloc
d3672 6
a3677 1
=item panic: restartop
d3682 1
a3682 1
=item panic: return
d3687 1
a3687 1
=item panic: scan_num
d3696 1
a3696 1
=item panic: sv_insert
d3701 6
d3713 2
a3714 2
(P) The compiler is screwed up and attempted to use an op that isn't permitted
at run time.
d3726 1
a3726 1
=item panic: yylex
d3730 5
d3738 2
a3739 2
consuming any text. Restructure the pattern so text is consumed before the
nesting limit is exceeded.
d3768 9
d3784 1
a3784 1
=item Perl_pmflag() is deprecated, and will be removed from the XS API
d3786 6
a3791 4
(D deprecated) XS code called the C function C<Perl_pmflag>. This was part of
Perl's listed public API for extending or embedding the perl interpreter. It has
now been removed from the public API, and will be removed in a future release,
hence XS code should be re-written not to use it.
d3801 1
a3801 1
(F) An error peculiar to OS/2. PERL_SH_DIR is the directory to find the
d3808 7
d3832 3
a3834 3
Perl can and will use, the script will be run.  Before you really fix
the problem, however, you will get the same error message each time
you run Perl.  How to really fix the problem can be found in
d3947 1
a3947 1
higher precedence of C<==>. This is probably not what you want. (If you
a3950 7
=item Possible unintended interpolation of %s in string

(W ambiguous) You said something like `@@foo' in a double-quoted string
but there was no array C<@@foo> in scope at the time. If you wanted a
literal @@foo, then write it as \@@foo; otherwise find out what happened
to the array you apparently lost track of.

d3965 7
d4011 2
a4012 2
(W illegalproto) A character follows % or @@ in a prototype. This is useless,
since % and @@ gobble the rest of the subroutine arguments.
d4024 24
d4050 3
a4052 3
(F) You started a regular expression with a quantifier. Backslash it if you
meant it literally. The <-- HERE shows in the regular expression about
where the problem was discovered. See L<perlre>.
d4056 3
a4058 3
(F) There is currently a limit to the size of the min and max values of the
{min,max} construct. The <-- HERE shows in the regular expression about where
the problem was discovered. See L<perlre>.
d4096 1
a4096 1
=item Reallocation too large: %lx
d4111 7
d4124 1
a4124 1
=item Recursive inheritance detected while looking for method %s
d4126 6
a4131 3
(F) More than 100 levels of inheritance were encountered while invoking
a method.  Probably indicates an unintended loop in your inheritance
hierarchy.
d4136 3
a4138 3
with an even number of elements (for assignment to a hash). This usually
means that you used the anon hash constructor when you meant to use
parens. In any case, a hash requires key/value B<pairs>.
a4149 5
=item Reference miscount in sv_replace()

(W internal) The internal sv_replace() function was handed a new SV with
a reference count of other than 1.

d4152 4
a4155 4
(F) You used C<\g0> or similar in a regular expression. You may refer to
capturing parentheses only with strictly positive integers (normal
backreferences) or with strictly negative integers (relative
backreferences), but using 0 does not make sense.
d4160 3
a4162 12
not at least seven sets of capturing parentheses in the expression. If you
wanted to have the character with value 7 inserted into the regular expression,
prepend a zero to make the number at least two digits: C<\07>

The <-- HERE shows in the regular expression about where the problem was
discovered.

=item Reference to nonexistent or unclosed group in regex; marked by <-- HERE in m/%s/

(F) You used something like C<\g{-7}> in your regular expression, but there are
not at least seven sets of closed capturing parentheses in the expression before
where the C<\g{-7}> was located.
d4170 3
a4172 3
expression, but there is no corresponding named capturing parentheses such
as C<(?'NAME'...)> or C<(?<NAME>...). Check if the name has been spelled
correctly both in the backreference and the declaration.
d4177 1
a4177 1
=item (?(DEFINE)....) does not allow branches in regex; marked by <-- HERE in m/%s/
d4179 3
a4181 3
(F) You used something like C<(?(DEFINE)...|..)> which is illegal. The
most likely cause of this error is that you left out a parenthesis inside
of the C<....> part.
d4191 20
d4220 1
a4220 1
terminates. You might use ^# instead.  See L<perlform>.
d4225 1
a4225 1
search list. So the additional elements in the replacement list
d4231 1
a4231 1
always comes last, to avoid ambiguity with subsequent unary operators.
d4293 1
a4293 1
parsed. One way to disambiguate the parsing is to put parentheses around
d4296 5
a4305 5
=item seekdir() attempted on invalid dirhandle %s

(W io) The dirhandle you are doing a seekdir() on is either closed or not
really a dirhandle.  Check your control flow.

d4336 3
a4338 3
(F) A regular expression ended with an incomplete extension (?. The <-- HERE
shows in the regular expression about where the problem was discovered. See
L<perlre>.
d4342 3
a4344 3
(F) A proposed regular expression extension has the character reserved but
has not yet been written. The <-- HERE shows in the regular expression about
where the problem was discovered. See L<perlre>.
d4350 4
a4353 1
discovered.  See L<perlre>.
d4355 1
a4355 1
=item Sequence \\%s... not terminated in regex; marked by <-- HERE in m/%s/
d4364 1
a4364 1
the regular expression about where the problem was discovered. See
d4369 4
a4372 4
(F) If the contents of a (?{...}) clause contains braces, they must balance
for Perl to properly detect the end of the clause. The <-- HERE shows in
the regular expression about where the problem was discovered. See
L<perlre>.
d4374 1
a4374 1
=item 500 Server error
d4380 6
a4385 6
This is the error message generally seen in a browser window when trying
to run a CGI program (including SSI) over the web. The actual error text
varies widely from server to server. The most frequently-seen variants
are "500 Server error", "Method (something) not permitted", "Document
contains no data", "Premature end of script headers", and "Did not
produce a valid header".
d4389 6
a4394 6
You need to make sure your script is executable, is accessible by the
user CGI is running the script under (which is probably not the user
account you tested it under), does not rely on any environment variables
(like PATH) from the user it isn't running under, and isn't in a
location where the CGI server can't find it, basically, more or less.
Please see the following for more information:
a4437 10
=item Setuid/gid script is writable by world

(F) The setuid emulator won't run a script that is writable by the
world, because the world might have written on it already.

=item Setuid script not plain file

(F) The setuid emulator won't run a script that isn't read from a file,
but from a socket, a pipe or another device.

d4486 7
d4496 4
a4499 4
the array passed to splice(). Splicing will instead commence at the end
of the array, rather than past it. If this isn't what you want, try
explicitly pre-extending the array by assigning $#array = $offset. See
L<perlfunc/splice>.
d4505 1
a4505 1
happened.) See L<perlfunc/split>.
d4515 6
d4562 1
a4562 1
(W substr),(F) You tried to reference a substr() that pointed outside of
d4570 1
a4570 1
(P) Perl tried to force the upgrade an SV to a type which was actually
d4575 4
a4578 4
(F) A (?(condition)if-clause|else-clause) construct can have at most two
branches (the if-clause and the else-clause). If you want one or both to
contain alternation, such as using C<this|that|other>, enclose it in
clustering parentheses:
d4582 2
a4583 2
The <-- HERE shows in the regular expression about where the problem was
discovered. See L<perlre>.
d4587 3
a4589 3
(F) If the argument to the (?(...)if-clause|else-clause) construct is a
number, it can be only a number. The <-- HERE shows in the regular expression
about where the problem was discovered. See L<perlre>.
d4596 1
a4596 1
=item %s syntax
d4619 1
a4619 2
if the error went away.  Sort of the cybernetic version of S<20
questions>.
d4621 1
a4621 1
=item syntax error at line %d: `%s' unexpected
d4663 5
a4672 5
=item telldir() attempted on invalid dirhandle %s

(W io) The dirhandle you tried to telldir() is either closed or not really
a dirhandle.  Check your control flow.

d4686 1
a4686 1
from under another module inadvertently.  See L<perlvar/$[>.
d4698 1
a4698 1
The function indicated isn't implemented on this architecture, according
d4735 5
a4739 5
(X) The #! line (or local equivalent) in a Perl script contains the
B<-T> option (or the B<-t> option), but Perl was not invoked with B<-T> in its command line.
This is an error because, by the time Perl discovers a B<-T> in a
script, it's too late to properly taint everything from the environment.
So Perl gives up.
d4742 3
a4744 3
mechanism (or its local equivalent), this error can usually be fixed by
editing the #! line so that the B<-%c> option is a part of Perl's first
argument: e.g. change C<perl -n -%c> to C<perl -%c -n>.
d4770 2
a4771 2
In the case of B<-M> and B<-m>, this is an error because those options are
not intended for use inside scripts.  Use the C<use> pragma instead.
d4773 5
a4777 4
The B<-C> option only works if it is specified on the command line as well
(with the same sequence of letters or numbers following). Either specify
this option on the command line, or, if your system supports it, make your
script executable and run it directly instead of passing it to perl. 
d4824 1
a4824 1
disallowed. See L<Safe>.
d4831 7
d4845 5
d4874 6
d4931 4
a4934 1
=item Unicode non-character %s is illegal for interchange
d4936 18
a4953 8
(W utf8) Certain codepoints, such as U+FFFE and U+FFFF, are defined by the
Unicode standard to be non-characters. Those are legal codepoints, but are
reserved for internal use; so, applications shouldn't attempt to exchange
them.  In some cases, this message is also given if you use a codepoint that
isn't in Unicode--that is it is above the legal maximum of U+10FFFF.  These
aren't legal at all in Unicode, so they are illegal for interchange, but can be
used internally in a Perl program.  If you know what you are doing you can turn
off this warning by C<no warnings 'utf8';>.
d4960 5
d4989 1
a4989 1
You tried to use an unknown subpragma of the "re" pragma.
d4991 1
a4991 1
=item Unknown switch condition (?(%.2s in regex; marked by <-- HERE in m/%s/
d4994 11
a5004 5
is not known. The condition may be lookahead or lookbehind (the condition
is true if the lookahead or lookbehind is true), a (?{...})  construct (the
condition is true if the code evaluates to a true value), or a number (the
condition is true if the set of capturing parentheses named by the number
matched).
d5011 1
a5011 1
You specified an unknown Unicode option.  See L<perlrun> documentation
d5016 1
a5016 1
You specified an unknown Unicode option.  See L<perlrun> documentation
a5018 8
=item Unknown warnings category '%s'

(F) An error issued by the C<warnings> pragma. You specified a warnings
category that is unknown to perl at this point.

Note that if you want to enable a warnings category registered by a module
(e.g. C<use warnings 'File::Find'>), you must have imported this module

d5025 8
a5032 1
first.
d5036 1
a5036 1
(F) The brackets around a character class must match. If you wish to
d5038 2
a5039 2
first. The <-- HERE shows in the regular expression about where the problem
was discovered. See L<perlre>.
d5044 3
a5046 3
expressions. If you're a vi user, the % key is valuable for finding the
matching parenthesis. The <-- HERE shows in the regular expression about
where the problem was discovered. See L<perlre>.
d5068 1
a5068 1
=item Unrecognized escape \\%c in character class passed through in regex; marked by <-- HERE in m/%s/
d5076 1
a5076 1
=item Unrecognized escape \\%c passed through
d5082 1
a5082 1
=item Unrecognized escape \\%c passed through in regex; marked by <-- HERE in m/%s/
d5085 3
a5087 4
recognized by Perl.  The character was understood literally, but this may
change in a future version of Perl.
The <-- HERE shows in the regular expression about where the
escape was discovered.
d5121 1
a5121 1
of Perl executables, some of which may support fork, some not. Try
a5153 10
=item Unterminated verb pattern in regex; marked by <-- HERE in m/%s/

(F) You used a pattern of the form C<(*VERB)> but did not terminate
the pattern with a C<)>. Fix the pattern and retry.

=item Unterminated verb pattern argument in regex; marked by <-- HERE in m/%s/

(F) You used a pattern of the form C<(*VERB:ARG)> but did not terminate
the pattern with a C<)>. Fix the pattern and retry.

d5157 1
a5157 1
a regular expression. Fix the pattern and retry.
d5166 10
d5191 17
d5220 1
a5220 1
where the problem was discovered. See L<perlre>.
d5224 2
a5225 2
(W syntax) The localization of lvalues such as C<local($x=10)> is
legal, but in fact the local() currently has no effect. This may change at
d5240 1
a5240 1
where the problem was discovered. See L<perlre>.
d5245 1
a5245 1
same length as the replacelist. See L<perlop> for more information
d5248 5
d5295 1
a5295 1
(W) You did C<use re;> without any arguments.   That isn't very useful.
d5308 2
a5309 2
apart from the array, like C<push(@@x)> or C<unshift(@@foo)>. That won't
usually have any effect on the array, so is completely useless. It's
d5311 1
a5311 1
if the array is tied to a class which implements a PUSH method. If so,
d5322 1
a5322 1
is deprecated. See L<perlvar/"$[">.
d5355 6
a5360 1
=item Use of := for an empty attribute list is deprecated
d5362 2
a5363 5
(D deprecated) The construction C<my $x := 42> currently
parses correctly in perl, being equivalent to C<my $x : = 42>
(applying an empty attribute list to C<$x>). This useless
construct is now deprecated, so C<:=> can be reclaimed as a new
operator in the future.
d5396 5
a5400 5
(D deprecated) As an (ahem) accidental feature, C<AUTOLOAD> subroutines
are looked up as methods (using the C<@@ISA> hierarchy) even when the
subroutines to be autoloaded were called as plain functions (e.g.
C<Foo::bar()>), not as methods (e.g. C<< Foo->bar() >> or C<<
$obj->bar() >>).
a5417 9
=item Use of octal value above 377 is deprecated

(D deprecated, W regexp) There is a constant in the regular expression whose
value is interpeted by Perl as octal and larger than 377 (255 decimal, 0xFF
hex).  Perl may take this to mean different things depending on the rest of
the regular expression.  If you meant such an octal value, convert it to
hexadecimal and use C<\xHH> or C<\x{HH}> instead.  If you meant to have
part of it mean a backreference, use C<\g> for that.  See L<perlre>.

d5435 1
a5435 1
=item Use of "package" with no arguments is deprecated
d5437 28
a5464 4
(D deprecated) You used the C<package> keyword without specifying a package
name. So no namespace is current at all. Using this can cause many
otherwise reasonable constructs to fail in baffling ways. C<use strict;>
instead.
d5474 2
a5475 2
either, because you can overload the numification and stringification
operators and then you assumably know what you are doing.
d5499 9
a5507 8
To help you figure out what was undefined, perl will try to tell you the
name of the variable (if any) that was undefined. In some cases it cannot
do this, so it also tells you what operation you used the undefined value
in.  Note, however, that perl optimizes your program and the operation
displayed in the warning may not necessarily appear literally in your
program.  For example, C<"that $foo"> is usually optimized into C<"that "
. $foo>, and the warning will refer to the C<concatenation (.)> operator,
even though there is no C<.> in your program.
d5513 2
a5514 2
used to allow this syntax, but shouldn't have. It is now deprecated, and will
be removed in a future version.
d5520 2
a5521 2
allow this syntax, but shouldn't have. It is now deprecated, and will be
removed in a future version.
d5529 1
a5529 1
=item Using just the first characters returned by \N{}
d5531 15
a5545 15
(W) A charnames handler may return a sequence of characters.  There is a finite
limit as to the number of characters that can be used, which this sequence
exceeded.  In the message, the characters in the sequence are separated by
dots, and each is shown by its ordinal in hex.  Anything to the left of the
C<HERE> was retained; anything to the right was discarded.

=item UTF-16 surrogate %s

(W utf8) You tried to generate half of a UTF-16 surrogate by
requesting a Unicode character between the code points 0xD800 and
0xDFFF (inclusive).  That range is reserved exclusively for the use of
UTF-16 encoding (by having two 16-bit UCS-2 characters); but Perl
encodes its characters in UTF-8, so what you got is a very illegal
character.  If you really really know what you are doing you can turn off
this warning by C<no warnings 'utf8';>.
d5567 1
a5567 1
This can happen for one of two reasons. First, the outer lexical may be
d5570 1
a5570 1
subs are created at run-time.) For example,
d5575 1
a5575 1
since the anonymous subroutine hasn't been created yet. Conversely,
d5595 2
a5596 2
(F) While "use strict" in effect, you referred to a global variable that
you apparently thought was imported from another module, because
d5608 5
a5612 5
(W misc) A "my", "our" or "state" variable has been redeclared in the current
scope or statement, effectively eliminating all access to the previous
instance.  This is almost always a typographical error.  Note that the
earlier variable will still exist until the end of the scope or until
all closure referents to it are destroyed.
d5637 5
d5644 2
a5645 2
(F) You used a verb pattern that requires an argument. Supply an argument
or check that you are using the right verb.
d5649 1
a5649 1
(F) You used a verb pattern that is not allowed an argument. Remove the 
d5705 5
a5709 4
(F) The count in the (un)pack template may be replaced by C<[TEMPLATE]> only if
C<TEMPLATE> always matches the same amount of packed bytes that can be
determined from the template alone. This is not possible if it contains an
of the codes @@, /, U, u, w or a *-length. Redesign the template.
d5716 1
a5716 1
=item %s "\x%s" does not map to Unicode
d5718 1
a5718 1
When reading in different encodings Perl tries to map everything
d5761 1
a5761 1
L<warnings>, L<perllexwarn>.
@


1.13
log
@Merge in perl 5.10.1
@
text
@d11 1
a11 1
    (D) A deprecation (optional).
d118 2
a119 2
a scalar value -- the length of an array, or the population info of a
hash -- and then work on that scalar value.  This is probably not what
d309 15
a323 1
=item Bad arg length for %s, is %d, should be %s
d376 5
d529 5
a677 18
=item Can't do setegid!

(P) The setegid() call failed for some reason in the setuid emulator of
suidperl.

=item Can't do seteuid!

(P) The setuid emulator of suidperl failed for some reason.

=item Can't do setuid

(F) This typically means that ordinary perl tried to exec suidperl to do
setuid emulation, but couldn't exec it.  It looks for a name of the form
sperl5.000 in the same directory that the perl executable resides under
the name perl5.000, typically /usr/local/bin on Unix machines.  If the
file is there, check the execute permissions.  If it isn't, ask your
sysadmin why he and/or she removed it.

d725 3
a727 3
could not be found. Maybe you misspelled the name of the property
(remember that the names of character properties consist only of
alphanumeric characters), or maybe you forgot the C<Is> or C<In> prefix?
d760 4
a763 2
example C<\p{Lu}> is all uppercase letters).  If you did mean to use a
Unicode property, see L<perlunicode> for the list of known properties.
d768 1
a768 1
=item Can't fork
d773 5
d845 6
d1053 1
a1053 1
=item Can't resolve method `%s' overloading `%s' in package `%s'
a1058 5
=item Can't reswap uid and euid

(P) The setreuid() call failed for some reason in the setuid emulator of
suidperl.

a1082 5
=item Can't swap uid and euid

(P) The setreuid() call failed for some reason in the setuid emulator of
suidperl.

d1455 8
d1647 1
a1647 1
=item Execution of %s aborted due to compilation errors
d1855 14
d1885 1
a1885 1
=item %s had compilation errors
d1918 1
a1918 1
=item Ignoring %s in character class in regex; marked by <-- HERE in m/%s/
d1920 2
a1921 2
(W) Named Unicode character escapes (\N{...}) may return multi-char
or zero length sequences. When such an escape is used in a character class
d1945 2
a1946 2
(W syntax) An illegal character was found in a prototype declaration.  Legal
characters in prototypes are $, @@, %, *, ;, [, ], &, and \.
d1988 1
a1988 1
=item Illegal switch in PERL5OPT: %s
d2210 1
a2210 1
=item IO layers (like "%s") unavailable
d2223 1
a2223 1
(S deprecated, syntax) The special variable C<$*>, deprecated in older perls, has
d2233 1
a2233 1
(S deprecated, syntax) The special variable C<$#>, deprecated in older perls, has
d2281 14
d2301 14
d2320 9
d2335 8
d2398 1
a2398 1
Perl thought it was reading UTF-16 encoded character data but while
d2401 4
d2420 1
a2420 1
=item Maximal count of pending signals (%s) exceeded
d2422 1
a2422 1
(F) Perl aborted due to a too important number of signals pending. This
d2467 5
d2477 1
a2477 1
=item Missing %sbrace%s on \N{}
d2480 4
a2483 1
double-quotish context.
d2519 28
a2546 1
(F) Missing right brace in C<\x{...}>, C<\p{...}> or C<\P{...}>.
d2600 1
a2600 1
=item More than one argument to open
d2633 36
d2681 6
d3153 11
d3380 5
d3429 7
a3472 4
=item Permission denied

(F) The setuid emulator in suidperl decided you were up to no good.

a3482 5
=item B<-P> not allowed for setuid/setgid script

(F) The script would have to be opened by the C preprocessor by name,
which provides a race condition that breaks security.

d3594 1
a3594 14
=item pragma "attrs" is deprecated, use "sub NAME : ATTRS" instead

(D deprecated) You have written something like this:

    sub doit
    {
        use attrs qw(locked);
    }

You should use the new declaration syntax instead.

    sub doit : locked
    {
        ...
d3596 11
a3606 2
The C<use attrs> pragma is now obsolete, and is only provided for
backward-compatibility. See L<perlsub/"Subroutine Attributes">.
d3645 5
d3818 6
a3833 8
=item Runaway format

(F) Your format contained the ~~ repeat-until-blank sequence, but it
produced 200 lines at once, and the 200th line looked exactly like the
199th line.  Apparently you didn't arrange for the arguments to exhaust
themselves, either by using ^ instead of @@ (for scalar variables), or by
shifting or popping (for array variables).  See L<perlform>.

a3870 5
=item Script is not setuid/setgid in suidperl

(F) Oddly, the suidperl program was invoked on a script without a setuid
or setgid bit set.  This doesn't make much sense.

a4083 6
=item Sort subroutine didn't return a numeric value

(F) A sort comparison routine must return a number.  You probably blew
it by not using C<< <=> >> or C<cmp>, or by not using them correctly.
See L<perlfunc/sort>.

d4116 1
a4116 1
=item Stub found while resolving method "%s" overloading "%s"
a4157 5
=item suidperl is no longer needed since %s

(F) Your Perl was compiled with B<-D>SETUID_SCRIPTS_ARE_SECURE_NOW, but
a version of the setuid emulator somehow got run anyway.

d4327 1
a4327 1
B<-T> option, but Perl was not invoked with B<-T> in its command line.
d4334 2
a4335 2
editing the #! line so that the B<-T> option is a part of Perl's first
argument: e.g. change C<perl -n -T> to C<perl -T -n>.
d4338 1
a4338 1
B<-T> option must appear on the command line: C<perl -T scriptname>.
d4503 1
a4503 1
=item Unicode character %s is illegal
d4505 8
a4512 3
(W utf8) Certain Unicode characters have been designated off-limits by
the Unicode standard and should not be generated.  If you really know
what you are doing you can turn off this warning by C<no warnings 'utf8';>.
d4611 1
a4611 1
=item Unrecognized character %s in column %d
d4614 1
a4614 1
in your Perl script (or eval) at the specified column.  Perhaps you tried 
d4621 1
a4621 1
understood literally.
d4628 2
a4629 1
recognized by Perl.  The character was understood literally.
d4634 2
a4635 1
recognized by Perl.  The character was understood literally.
d4775 6
d4847 5
d4854 1
a4854 1
(D deprecated, W syntax) You are now encouraged to use the explicitly quoted
d4859 1
a4859 1
(D deprecated, W syntax) The values you give to a format should be
d4883 8
d4915 1
a4915 1
=item Use of implicit split to @@_ is deprecated
d4917 2
a4918 3
(D deprecated, W syntax) It makes a lot of work for the compiler when you
clobber a subroutine's argument list, so it's better if you assign the results
of a split() explicitly to an array (or list).
d4944 9
d5033 14
d5049 1
a5049 1
(W utf8) You tried to generate half of an UTF-16 surrogate by
d5054 1
a5054 1
character.  If you really know what you are doing you can turn off
@


1.12
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d134 1
a134 1
=item %s argument is not a HASH or ARRAY element
a904 7
=item Can't locate package %s for the parents of %s

(W syntax) You did not define (or require/use) the first package,
which is named as a (possibly indirect) parent of the second by
C<@@ISA> inheritance.  Perl will treat this as if the undefined
package had an empty C<@@ISA>.

d1420 3
d1596 1
a1596 1
=item %s: Eval-group not allowed at run time
d2193 6
a2198 2
been removed as of 5.9.0 and is no longer supported. You should use the
C<//m> and C<//s> regexp modifiers instead.
d2431 1
a2431 1
(F) Missing right brace in C<\p{...}> or C<\P{...}>.
d2702 5
d3188 5
d3908 6
d4205 9
a4213 2
B<-M>, B<-m> or B<-C> option.  This is an error because those options
are not intended for use inside scripts.  Use the C<use> pragma instead.
d4682 7
a4688 2
(D deprecated) You are now encouraged to use the explicitly quoted form
if you wish to use an empty line as the terminator of the here-document.
d4737 2
a4738 2
(D deprecated) It makes a lot of work for the compiler when you clobber
a subroutine's argument list, so it's better if you assign the results
a4965 12
=item v-string in use/require is non-portable

(W portable) The use of v-strings is non-portable to older, pre-5.6, Perls.
If you want your scripts to be backward portable, use the floating
point version number: for example, instead of C<use 5.6.1> say
C<use 5.006_001>. This of course won't make older Perls suddenly start
understanding newer features, but at least they will show a sensible
error message indicating the required minimum version.

This warning is suppressed if the C<use 5.x.y> is preceded by a
C<use 5.006> (see C<use VERSION> in L<perlfunc/use>).

d4998 1
a4998 1
(W utf8) Perl met a wide character (>255) when it wasn't expecting
@


1.11
log
@merge in perl 5.8.8
@
text
@d12 1
a12 1
    (S) A severe warning (default).
d30 1
a30 1
Default warnings are always enabled unless they are explicitly disabled
d57 1
a57 1
=item '!' allowed only after types %s
d59 2
a60 2
(F) The '!' is allowed in pack() or unpack() only after certain types.
See L<perlfunc/pack>.
d136 2
a137 1
(F) The argument to exists() must be a hash or array element, such as:
d141 1
d287 7
a341 6
=item Bad index while coercing array into hash

(F) The index looked up in the hash found as the 0'th element of a
pseudo-hash is not legal.  Index values must be at 1 or greater.
See L<perlref>.

d373 6
d498 12
d521 9
d605 5
d618 1
a618 1
class qualifier in a "my" or "our" declaration.  The semantics may be
d623 2
a624 2
(F) Only scalar, array, and hash variables may be declared as "my" or
"our" variables.  They must have ordinary identifiers as names.
d683 7
a738 9
=item Can't find %s property definition %s

(F) You may have tried to use C<\p> which means a Unicode property (for
example C<\p{Lu}> is all uppercase letters).  If you did mean to use a
Unicode property, see L<perlunicode> for the list of known properties.
If you didn't mean to use a Unicode property, escape the C<\p>, either
by C<\\p> (just the C<\p>) or by C<\Q\p> (the rest of the string, until
possible C<\E>).

d751 9
d805 6
d842 5
d860 1
a860 1
lexical variable using "my".  This is not allowed.  If you want to
a863 7
=item Can't localize pseudo-hash element

(F) You said something like C<< local $ar->{'key'} >>, where $ar is a
reference to a pseudo-hash.  That hasn't been implemented yet, but you
can get a similar effect by localizing the corresponding array element
directly -- C<< local $ar->[$ar->[0]{'key'}] >>.

d905 7
a1015 7
=item Can't redefine active sort subroutine %s

(F) Perl optimizes the internal handling of sort subroutines and keeps
pointers into them.  You tried to redefine one such sort subroutine when
it was currently active, which is not allowed.  If you really want to do
this, you should write C<sort { &func } @@x> instead of C<sort func @@x>.

d1105 1
a1105 1
=item Can't upgrade that kind of scalar
a1111 6
=item Can't upgrade to undef

(P) The undefined SV is the bottom of the totem pole, in the scheme of
upgradability.  Upgrading to undef indicates an error in the code
calling sv_upgrade.

d1134 6
d1145 1
a1145 1
=item Can't use global %s in "my"
d1153 7
d1194 7
d1212 1
a1212 1
=item Character in "C" format wrapped in pack
d1227 13
a1239 1
=item Character in "c" format wrapped in pack
d1254 36
d1294 5
d1363 8
d1450 21
d1548 4
d1615 8
d1678 3
a1680 3
(F) An untrapped exception was raised while executing a CHECK, INIT, or
END subroutine.  Processing of the remainder of the queue of such
routines has been prematurely ended.
d1702 12
d1816 4
a1819 4
(F) You've said "use strict vars", which indicates that all variables
must either be lexically scoped (using "my"), declared beforehand using
"our", or explicitly qualified to say which package the global variable
is in (using "::").
d1891 7
d1964 1
a1964 1
following switches: B<-[DIMUdmtw]>.
d1990 6
d2002 16
d2055 15
d2113 15
d2162 11
d2194 12
d2256 1
a2256 1
=item Lookbehind longer than %d not implemented in regex; marked by <-- HERE in m/%s/
d2259 1
a2259 2
handle. This restriction may be eased in a future release. The <-- HERE
shows in the regular expression about where the problem was discovered.
d2306 11
a2316 2
(S utf8) (F) Perl detected something that didn't comply with UTF-8
encoding rules.
d2318 1
a2318 3
One possible cause is that you read in data that you thought to be in
UTF-8 but it wasn't (it was for example legacy 8-bit data).  Another
possibility is careless use of utf8::upgrade().
d2325 23
a2500 6
=item '/' must be followed by 'a*', 'A*' or 'Z*'

(F) You had a pack template indicating a counted-length string,
Currently the only things that can have their length counted are a*, A*
or Z*.  See L<perlfunc/pack>.

d2512 1
a2512 1
=item "my" variable %s can't be in a package
d2559 1
a2559 1
=item Newline in left-justified string for %s
d2561 3
a2563 6
(W printf) There is a newline in a string to be left justified by 
C<printf> or C<sprintf>.

The padding spaces will appear after the newline, which is probably not
what you wanted.  Usually you should remove the newline from the string 
and put formatting characters in the C<sprintf> format.
d2641 7
d2691 6
d2699 1
a2699 1
(F) You provided a class qualifier in a "my" or "our" declaration, but
a2707 13
=item No such pseudo-hash field "%s"

(F) You tried to access an array as a hash, but the field name used is
not defined.  The hash at index 0 should map all valid field names to
array indices for that to work.

=item No such pseudo-hash field "%s" in variable %s of type %s

(F) You tried to access a field of a typed variable where the type does
not know about the field name.  The field names are looked up in the
%FIELDS hash in the type package at compile time.  The %FIELDS hash is
%usually set up with the 'fields' pragma.

d2865 7
a2871 4
(F) You tried to do a read/write/send/recv operation with an offset
pointing outside the buffer.  This is difficult to imagine.  The sole
exception to this is that C<sysread()>ing past the buffer will extend
the buffer and zero pad the new area.
d2892 14
d2975 5
d2985 6
d3012 7
d3059 5
d3073 7
a3115 4
=item panic: mapstart

(P) The compiler is screwed up with respect to the map() function.

a3119 4
=item panic: null array

(P) One of the internal array routines was passed a null AV pointer.

d3192 5
d3206 9
d3225 1
a3225 1
Remember that "my", "our", and "local" bind tighter than comma.
d3239 7
a3412 5
=item Possible Y2K bug: %s

(W y2k) You are concatenating the number 19 with another number, which
could be a potential Year 2000 problem.

a3477 6
=item Pseudo-hashes are deprecated

(D deprecated)  Pseudo-hashes were deprecated in Perl 5.8.0 and they
will be removed in Perl 5.10.0, see L<perl58delta> for more details.
You can continue to use the C<fields> pragma.

d3508 5
d3543 3
a3545 2
(F) More than 100 levels of inheritance were used.  Probably indicates
an unintended loop in your inheritance hierarchy.
d3575 7
d3592 28
d3641 5
d3722 5
d3773 5
d3870 6
d3961 1
a3961 1
L<perlop/"Quote and Quote-like Operators">.
d3988 5
d4089 5
d4131 1
a4131 2
(F) Currently this attribute is not supported on C<my> or C<sub>
declarations.  See L<perlfunc/our>.
a4148 6
=item 5.005 threads are deprecated

(D deprecated)  The 5.005-style threads (activated by C<use Thread;>)
are deprecated and one should use the new ithreads instead,
see L<perl58delta> for more details.

d4179 1
a4179 1
(F) Your template contains ()-groups with a ridiculously deep nesting level. 
d4189 1
a4189 1
B<-M> or B<-m> option.  This is an error because B<-M> and B<-m> options
d4392 7
d4429 1
a4429 1
=item Unrecognized character %s
d4432 2
a4433 2
in your Perl script (or eval).  Perhaps you tried to run a compressed
script, a binary program, or a directory as a Perl program.
d4435 1
a4435 1
=item /%s/: Unrecognized escape \\%c in character class passed through
d4440 2
d4446 1
a4446 1
recognized by Perl.
d4451 2
a4452 3
recognized by Perl. This combination appears in an interpolated variable or
a C<'>-delimited regular expression. The character was understood
literally. The <-- HERE shows in the regular expression about where the
d4520 15
d4571 6
a4741 12
=item Use of $* is deprecated

(D deprecated) This variable magically turned on multi-line pattern
matching, both for you and for any luckless subroutine that you happen
to call.  You should use the new C<//m> and C<//s> modifiers now to do
that without the dangerous action-at-a-distance effects of C<$*>.

=item Use of $# is deprecated

(D deprecated) This was an ill-advised attempt to emulate a poorly
defined B<awk> feature.  Use an explicit printf() or sprintf() instead.

d4770 1
a4770 1
operators and then you assumedly know what you are doing.
d4794 8
a4801 7
To help you figure out what was undefined, perl tells you what operation
you used the undefined value in.  Note, however, that perl optimizes your
program and the operation displayed in the warning may not necessarily
appear literally in your program.  For example, C<"that $foo"> is
usually optimized into C<"that " . $foo>, and the warning will refer to
the C<concatenation (.)> operator, even though there is no C<.> in your
program.
d4843 30
d4881 1
a4881 1
=item Variable length lookbehind not implemented in regex; marked by <-- HERE in m/%s/
d4884 1
a4884 2
known at compile time. The <-- HERE shows in the regular expression about
where the problem was discovered. See L<perlre>.
d4888 1
a4888 1
(W misc) A "my" or "our" variable has been redeclared in the current
a4893 21
=item Variable "%s" may be unavailable

(W closure) An inner (nested) I<anonymous> subroutine is inside a
I<named> subroutine, and outside that is another subroutine; and the
anonymous (innermost) subroutine is referencing a lexical variable
defined in the outermost subroutine.  For example:

   sub outermost { my $a; sub middle { sub { $a } } }

If the anonymous subroutine is called or referenced (directly or
indirectly) from the outermost subroutine, it will share the variable as
you would expect.  But if the anonymous subroutine is called or
referenced when the outermost subroutine is not active, it will see the
value of the shared variable as it was before and during the *first*
call to the outermost subroutine, which is probably not what you want.

In these circumstances, it is usually best to make the middle subroutine
anonymous, using the C<sub {}> syntax.  Perl has specific support for
shared variables in nested anonymous subroutines; a named subroutine in
between interferes with this feature.

d4903 1
a4903 1
lexical variable defined in an outer subroutine.
d4905 1
a4905 1
When the inner subroutine is called, it will probably see the value of
a4911 4
Furthermore, if the outer subroutine is anonymous and references a
lexical variable outside itself, then the outer and inner subroutines
will I<never> share the given variable.

d4914 1
a4914 1
reference variables in outer subroutines are called or referenced, they
d4917 10
d4933 17
d4953 1
a4953 1
you called it with no args and C<$_> was empty.
d5044 4
@


1.10
log
@sync in-tree perl with 5.8.6
@
text
@d196 1
a196 1
(W) When using threaded Perl, a thread (not necessarily the main
d285 9
d763 1
a763 1
=item Can't goto subroutine from an eval-string
d766 1
a766 2
"string".  (You can use it to jump out of an eval {BLOCK}, but you
probably don't want to.)
d1074 1
a1074 1
(P) The internal routine that does method lookup was handed a symbol
d1130 1
a1130 1
didn't look like an array reference, or anything else subscriptable.
d1411 5
d1434 6
d1567 1
a1567 1
as STDOUT or STDERR. This occured because you closed STDOUT or STDERR
d1573 1
a1573 1
as STDIN. This occured because you closed STDIN previously.
d1998 1
a1998 1
(F) While unpacking, the string buffer was alread used up when an unpack
d2059 2
a2060 1
(W utf8) Perl detected something that didn't comply with UTF-8 encoding rules.
d2331 3
a2333 4
for some reason the perl5db.pl file (or some facsimile thereof) didn't
define a routine to be called at the beginning of each statement.  Which
is odd, because the file should have been required automatically, and
should have blown up the require if it didn't parse right.
d2340 1
a2340 1
=item No DBsub routine
d2342 4
a2345 4
(F) The currently executing code was compiled with the B<-d> switch,
but for some reason the perl5db.pl file (or some facsimile thereof)
didn't define a DB::sub routine to be called at the beginning of each
ordinary subroutine call.
d2524 6
d2621 1
a2621 1
=item Operation `%s': no method found, %s
d3274 1
a3274 1
(F) Your format containes the ~~ repeat-until-blank sequence and a
d3344 10
d3488 5
d3562 1
a3562 1
=item Stub found while resolving method `%s' overloading %s
d3759 1
a3759 1
(F) The entry point function of threads->create() failed for some reason.
d4215 1
a4215 1
    1 while sub_with_side_effects() ;
a4589 10

=item Xsub "%s" called in sort

(F) The use of an external subroutine as a sort comparison is not yet
supported.

=item Xsub called in sort

(F) The use of an external subroutine as a sort comparison is not yet
supported.
@


1.9
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d786 10
d834 6
d943 4
d1818 2
a1819 1
the world.  See L<perlsec>.
d2040 1
a2040 1
Perl detected something that didn't comply with UTF-8 encoding rules.
d2090 5
a2391 5
=item No space allowed after -%c

(F) The argument to the indicated command line switch must follow
immediately after the switch, without intervening spaces.

d2628 5
a2639 5
=item Out of memory during %s extend

(X) An attempt was made to extend an array, a list, or a string beyond
the largest possible memory allocation.

a3726 6
=item Tied variable freed while still in use

(F) An access method for a tied variable (e.g. FETCH) did something to
free the variable.  Since continuing the current operation is likely
to result in a coredump, Perl is bailing out instead.

d3732 16
a3768 16

=item Too late for "B<-T>" option

(X) The #! line (or local equivalent) in a Perl script contains the
B<-T> option, but Perl was not invoked with B<-T> in its command line.
This is an error because, by the time Perl discovers a B<-T> in a
script, it's too late to properly taint everything from the environment.
So Perl gives up.

If the Perl script is being executed as a command using the #!
mechanism (or its local equivalent), this error can usually be fixed by
editing the #! line so that the B<-T> option is a part of Perl's first
argument: e.g. change C<perl -n -T> to C<perl -T -n>.

If the Perl script is being executed as C<perl scriptname>, then the
B<-T> option must appear on the command line: C<perl -T scriptname>.
@


1.8
log
@merge local changes into perl-5.8.3
@
text
@d1364 2
a1365 2
(S) This is an educated guess made in conjunction with the message "%s
found where operator expected".  It often means a subroutine or module
d1385 2
a1386 2
(S) There is no keyword "elseif" in Perl because Larry thinks it's ugly.
Your code will be interpreted as an attempt to call a method named
d1578 2
a1579 2
(S) The Perl lexer knows whether to expect a term or an operator.  If it
sees what it knows to be a term when it was expecting to see an
d1714 4
d2103 2
a2104 2
(S) This is an educated guess made in conjunction with the message "%s
found where operator expected".  Often the missing operator is a comma.
d2118 2
a2119 2
(S) This is an educated guess made in conjunction with the message "%s
found where operator expected".  Don't automatically put a semicolon on
d2614 5
d2759 4
d3226 6
d3679 5
d3794 2
a3795 2
(F) The lexer couldn't find the final delimiter of a tr/// or tr[][]
construct.
d4045 1
a4045 1
=item Unsupported script encoding
d4048 1
a4048 1
declares it to be in a Unicode encoding that Perl cannot yet read.
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d1301 6
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@a46 8
=item A thread exited while %d other threads were still running

(W) When using threaded Perl, a thread (not necessarily the main
thread) exited while there were still other threads running.
Usually it's a good idea to first collect the return values of the
created threads by joining them, and only then exit from the main
thread.  See L<threads>.

d59 1
a59 1
(F) The '!' is allowed in pack() and unpack() only after certain types.
d166 9
d194 8
a206 16
=item Attempt to clear a restricted hash

(F) It is currently not allowed to clear a restricted hash, even if the
new hash would contain the same keys as before.  This may change in
the future.

=item Attempt to delete readonly key '%s' from a restricted hash

(F) The failing code attempted to delete a key whose value has been
declared readonly from a restricted hash.

=item Attempt to delete disallowed key '%s' from a restricted hash

(F) The failing code attempted to delete from a restricted hash a key
which is not in its key set.

d225 10
a445 5
=item B<-P> not allowed for setuid/setgid script

(F) The script would have to be opened by the C preprocessor by name,
which provides a race condition that breaks security.

d468 8
a475 1
=item / cannot take a count
d477 8
a484 3
(F) You had an unpack template indicating a counted-length string, but
you have also specified an explicit size for the string.  See
L<perlfunc/pack>.
d688 9
a708 9
=item Can't find %s property definition %s

(F) You may have tried to use C<\p> which means a Unicode property (for
example C<\p{Lu}> is all uppercase letters).  If you did mean to use a
Unicode property, see L<perlunicode> for the list of known properties.
If you didn't mean to use a Unicode property, escape the C<\p>, either
by C<\\p> (just the C<\p>) or by C<\Q\p> (the rest of the string, until
possible C<\E>).

d830 5
a839 11
=item (perhaps you forgot to load "%s"?)

(F) This is an educated guess made in conjunction with the message
"Can't locate object method \"%s\" via package \"%s\"".  It often means
that a method requires a package that has not been loaded.

=item Can't locate package %s for @@%s::ISA

(W syntax) The @@ISA array contained the name of another package that
doesn't seem to exist.

d923 1
a923 1
=item Can't open perl script%s: %s
d984 5
a996 5
=item Can't return outside a subroutine

(F) The return statement was executed in mainline code, that is, where
there was no subroutine call to return out of.  See L<perlsub>.

a1043 5
=item Can't use an undefined value as %s reference

(F) A value used as either a hard reference or a symbolic reference must
be a defined value.  This helps to delurk some insidious errors.

d1050 5
d1124 1
a1124 1
=item Character in "C" format wrapped
d1139 1
a1139 1
=item Character in "c" format wrapped
d1158 5
a1196 1

d1265 1
a1265 1
=item C<-p> destination: %s
d1267 3
a1269 8
(F) An error occurred during the implicit output invoked by the C<-p>
command-line switch.  (This output goes to STDOUT unless you've
redirected it with select().)

=item C<-T> and C<-B> not implemented on filehandles

(F) Perl can't peek at the stdio buffer of filehandles when it doesn't
know about your kind of stdio.  You'll have to use a filename instead.
d1343 5
d1505 4
a1508 10
(W io) You tried to write on a read-only filehandle.  If you intended it
to be a read-write filehandle, you needed to open it with "+<" or "+>"
or "+>>" instead of with "<" or nothing.  If you intended only to write
the file, use ">" or ">>".  See L<perlfunc/open>.
The warning will also occur if STDOUT (file descriptor 1) or STDERR
(file descriptor 2) is opened for input, this is a pre-emptive warning in
case some other part of your program or a child process is expecting STDOUT
and STDERR to be writable. This can happen accidentally if you
C<close(STDOUT)> or STDERR and then C<open> an unrelated handle which
will resuse the lowest numbered available descriptor.
d1512 2
a1513 2
(W io) You tried to read from a filehandle opened only for writing.
If you intended it to be a read/write filehandle, you needed to open it
d1516 13
a1528 6
The warning will also occur if STDIN (file descriptor 0) is opened
for output - this is a pre-emptive warning in case some other part of your
program or a child process is expecting STDIN to be readable.
This can happen accidentally if you C<close(STDIN)> and then C<open> an
unrelated handle which will resuse the lowest numbered available
descriptor.
a1536 7
=item Final @@ should be \@@ or @@name

(F) You must now decide whether the final @@ in a string was meant to be
a literal "at" sign, or was meant to introduce a variable name that
happens to be missing.  So you have to put either the backslash or the
name.

a1543 8
=item Quantifier follows nothing in regex;

marked by <-- HERE in m/%s/

(F) You started a regular expression with a quantifier. Backslash it if you
meant it literally. The <-- HERE shows in the regular expression about
where the problem was discovered. See L<perlre>.

d1641 1
a1641 1
=item %s-group starts with a count
d1643 1
a1643 1
(F) In pack/unpack a ()-group started with a count.  A count is
d1645 1
d1703 5
d1794 3
a1796 3
C<$ENV{ENV}> or C<$ENV{BASH_ENV}> are derived from data supplied (or
potentially supplied) by the user.  The script must set the path to a
known value, using trustworthy data.  See L<perlsec>.
d1861 1
a1861 1
=item Invalid [] range "%s" in transliteration operator
d1873 1
a1873 1
=item Invalid type in pack: '%s'
d1875 4
a1878 3
(F) The given character is not a valid pack type.  See L<perlfunc/pack>.
(W pack) The given character is not a valid pack type but used to be
silently ignored.
d1880 1
a1880 1
=item Invalid type in unpack: '%s'
d1882 3
a1884 3
(F) The given character is not a valid unpack type.  See
L<perlfunc/unpack>.
(W unpack) The given character is not a valid unpack type but used to be
d1897 6
d1946 6
d1958 6
d1976 1
a1976 1
=item Lookbehind longer than %d not implemented in regex;
d1978 2
a1979 1
marked by <-- HERE in m/%s/
d1981 4
a1984 3
(F) There is currently a limit on the length of string which lookbehind can
handle. This restriction may be eased in a future release. The <-- HERE
shows in the regular expression about where the problem was discovered.
d2020 1
a2020 3
=item %s matches null string many times in regex;

marked by <-- HERE in m/%s/
d2033 1
a2033 1
=item % may only be used in unpack
d2075 5
d2168 1
a2168 1
=item / must be followed by a*, A* or Z*
d2174 1
a2174 1
=item / must be followed by a, A or Z
d2176 3
a2178 8
(F) You had an unpack template indicating a counted-length string, which
must be followed by one of the letters a, A or Z to indicate what sort
of string is to be unpacked.  See L<perlfunc/pack>.

=item / must follow a numeric type

(F) You had an unpack template that contained a '#', but this did not
follow some numeric unpack specification.  See L<perlfunc/pack>.
d2198 10
d2232 9
a2247 4
=item No B<-e> allowed in setuid scripts

(F) A setuid script can't be specified by the user.

d2292 4
d2302 5
a2465 6
=item %s not allowed in length fields

(F) The count in the (un)pack template may be replaced by C<[TEMPLATE]> only if
C<TEMPLATE> always matches the same amount of packed bytes.  Redesign
the template.

a2545 5
=item -%s on unopened filehandle %s

(W unopened) You tried to invoke a file test operator on a filehandle
that isn't open.  Check your control flow.  See also L<perlfunc/-X>.

d2552 5
d2591 6
d2629 1
a2629 1
=item @@ outside of string
d2631 1
a2631 1
(F) You had a pack template that specified an absolute position outside
d2641 5
d2673 7
a2684 5
=item panic: pp_match%s

(P) The internal pp_match() routine was called with invalid operational
data.

d2784 5
a2819 4
=item panic: yylex

(P) The lexer got into a bad state while processing a case modifier.

d2825 4
d2841 12
d2864 4
d2890 3
a2892 1
=item perlio: argument list not closed for layer "%s"
d2894 1
a2894 6
(W layer) When pushing a layer with arguments onto the Perl I/O system you
forgot the ) that closes the argument list.  (Layers take care of transforming
data between external and internal representations.)  Perl stopped parsing
the layer list at this point and did not attempt to push this layer.
If your program didn't explicitly request the failing operation, it may be
the result of the value of the environment variable PERLIO.
d2896 3
a2898 1
=item perlio: invalid separator character %s in layer specification list %s
d2900 1
a2900 4
(W layer) When pushing layers onto the Perl I/O system, something other than a
colon or whitespace was seen between the elements of a layer list.
If the previous attribute had a parenthesised parameter list, perhaps that
list was terminated too soon.
d2902 1
a2902 1
=item perlio: unknown layer "%s"
d2904 1
a2904 6
(W layer) An attempt was made to push an unknown layer onto the Perl I/O
system.  (Layers take care of transforming data between external and
internal representations.)  Note that some layers, such as C<mmap>,
are not supported in all environments.  If your program didn't
explicitly request the failing operation, it may be the result of the
value of the environment variable PERLIO.
d2906 2
a2907 1
=item Permission denied
d2909 1
a2909 1
(F) The setuid emulator in suidperl decided you were up to no good.
d2911 5
a2915 1
=item pid %x not a child
d2917 1
a2917 3
(W exec) A warning peculiar to VMS.  Waitpid() was asked to wait for a
process which isn't a subprocess of the current process.  While this is
fine from VMS' perspective, it's probably not what you intended.
d2919 2
a2920 1
=item P must have an explicit size
d2922 1
a2922 5
(F) The unpack format P must have an explicit size, not "*".

=item POSIX syntax [%s] belongs inside character classes in regex;

marked by <-- HERE in m/%s/
d2931 1
a2931 3
=item POSIX syntax [. .] is reserved for future extensions in regex;

marked by <-- HERE in m/%s/
d2940 1
a2940 3
=item POSIX syntax [= =] is reserved for future extensions in regex;

marked by <-- HERE in m/%s/
a2948 15
=item POSIX class [:%s:] unknown in regex;

marked by <-- HERE in m/%s/

(F) The class in the character class [: :] syntax is unknown.  The <-- HERE
shows in the regular expression about where the problem was discovered.
Note that the POSIX character classes do B<not> have the C<is> prefix
the corresponding C interfaces have: in other words, it's C<[[:print:]]>,
not C<isprint>.  See L<perlre>.

=item POSIX getpgrp can't take an argument

(F) Your system has POSIX getpgrp(), which takes no argument, unlike
the BSD version, which takes a pid.

d3001 12
d3090 11
a3100 1
=item Quantifier in {,} bigger than %d in regex;
d3102 1
a3102 1
marked by <-- HERE in m/%s/
d3108 1
a3108 3
=item Quantifier unexpected on zero-length expression;

marked by <-- HERE in m/%s/
d3131 8
d3187 1
a3187 3
=item Reference to nonexistent group in regex;

marked by <-- HERE in m/%s/
a3206 10
=item Repeat count in pack overflows

(F) You can't specify a repeat count so large that it overflows your
signed integers.  See L<perlfunc/pack>.

=item Repeat count in unpack overflows

(F) You can't specify a repeat count so large that it overflows your
signed integers.  See L<perlfunc/unpack>.

d3220 7
a3256 7
=item Scalars leaked: %d

(P) Something went wrong in Perl's internal bookkeeping of scalars:
not all scalar variables were deallocated by the time Perl exited.
What this usually indicates is a memory leak, which is of course bad,
especially if the Perl program is intended to be long-running.

d3268 5
d3312 1
a3312 12
=item Sequence (?{...}) not terminated or not {}-balanced in regex;

marked by <-- HERE in m/%s/

(F) If the contents of a (?{...}) clause contains braces, they must balance
for Perl to properly detect the end of the clause. The <-- HERE shows in
the regular expression about where the problem was discovered. See
L<perlre>.

=item Sequence (?%s...) not implemented in regex;

marked by <-- HERE in m/%s/
d3318 1
a3318 3
=item Sequence (?%s...) not recognized in regex;

marked by <-- HERE in m/%s/
d3324 1
a3324 3
=item Sequence (?#... not terminated in regex;

marked by <-- HERE in m/%s/
d3331 7
d3523 1
a3523 3
=item Switch (?(condition)... contains too many branches in regex;

marked by <-- HERE in m/%s/
d3535 1
a3535 3
=item Switch condition not recognized in regex;

marked by <-- HERE in m/%s/
d3546 4
d3584 1
a3584 1
=item %s syntax OK
d3586 5
a3590 1
(F) The final summary message when a C<perl -c> succeeds.
d3604 5
d3670 12
d3687 11
d3703 6
a3724 6
=item Too late for "-%s" option

(X) The #! line (or local equivalent) in a Perl script contains the
B<-M> or B<-m> option.  This is an error because B<-M> and B<-m> options
are not intended for use inside scripts.  Use the C<use> pragma instead.

d3743 3
d3767 5
d3870 22
d3896 1
a3896 3
=item Unknown switch condition (?(%.2s in regex;

marked by <-- HERE in m/%s/
d3908 1
a3908 1
=item Unknown open() mode '%s'
d3910 2
a3911 3
(F) The second argument of 3-argument open() is not among the list
of valid modes: C<< < >>, C<< > >>, C<<< >> >>>, C<< +< >>,
C<< +> >>, C<<< +>> >>>, C<-|>, C<|->, C<< <& >>, C<< >& >>.
d3913 1
a3913 1
=item Unknown process %x sent message to prime_env_iter: %s
d3915 2
a3916 4
(P) An error peculiar to VMS.  Perl was reading values for %ENV before
iterating over it, and someone else stuck a message in the stream of
data Perl expected.  Someone's very confused, or perhaps trying to
subvert Perl's population of %ENV for nefarious purposes.
d3967 1
a3967 1
=item Unrecognized escape \\%c passed through in regex;
d3969 4
a3972 1
marked by <-- HERE in m/%s/
a3979 5
=item Unrecognized escape \\%c passed through

(W misc) You used a backslash-character combination which is not
recognized by Perl.

d4057 1
a4057 1
=item Useless (?%s) - use /%s modifier in regex;
d4059 2
a4060 1
marked by <-- HERE in m/%s/
d4062 9
a4070 2
(W regexp) You have used an internal modifier such as (?o) that has no
meaning unless applied to the entire regexp:
d4072 1
a4072 1
    if ($string =~ /(?o)$pattern/) { ... }
d4076 1
a4076 1
    if ($string =~ /$pattern/o) { ... }
d4081 1
a4081 1
=item Useless (?-%s) - don't use /%s modifier in regex;
d4083 2
a4084 1
marked by <-- HERE in m/%s/
d4086 1
a4086 4
(W regexp) You have used an internal modifier such as (?-o) that has no
meaning unless removed from the entire regexp:

    if ($string =~ /(?-o)$pattern/o) { ... }
d4090 1
a4090 1
    if ($string =~ /$pattern/) { ... }
d4166 10
d4187 7
a4193 1
=item Use of /g modifier is meaningless in split
d4195 4
a4198 3
(W regexp) You used the /g modifier on the pattern for a C<split>
operator.  Since C<split> always tries to match the pattern
repeatedly, the C</g> has no effect.
d4205 1
a4205 1
=item Use of chdir('') or chdir(undef) as chdir() deprecated
d4207 3
a4209 7
(D deprecated) chdir() with no arguments is documented to change to
$ENV{HOME} or $ENV{LOGDIR}.  chdir(undef) and chdir('') share this
behavior, but that has been deprecated.  In future versions they
will simply fail.

Be careful to check that what you pass to chdir() is defined and not
blank, else you might find yourself in your home directory.
a4240 13
=item Use of -l on filehandle %s

(W io) A filehandle represents an opened file, and when you opened the file
it already went past any symlink you are presumably trying to look for.
The operation returned C<undef>.  Use a filename instead.

=item Use of "package" with no arguments is deprecated

(D deprecated) You used the C<package> keyword without specifying a package
name. So no namespace is current at all. Using this can cause many
otherwise reasonable constructs to fail in baffling ways. C<use strict;>
instead.

d4253 5
d4264 7
a4270 1
=item Use of $# is deprecated
d4272 4
a4275 2
(D deprecated) This was an ill-advised attempt to emulate a poorly
defined B<awk> feature.  Use an explicit printf() or sprintf() instead.
d4366 6
a4427 8
=item Variable length lookbehind not implemented in regex;

marked by <-- HERE in m/%s/

(F) Lookbehind is allowed only for subexpressions whose length is fixed and
known at compile time. The <-- HERE shows in the regular expression about
where the problem was discovered. See L<perlre>.

a4433 10
=item v-string in use/require is non-portable

(W portable) The use of v-strings is non-portable to older, pre-5.6, Perls.
If you want your scripts to be backward portable, use the floating
point version number: for example, instead of C<use 5.6.1> say
C<use 5.006_001>.  This of course won't help: the older Perls
won't suddenly start understanding newer features, but at least
they will show a sensible error message indicating the required
minimum version.

d4467 13
a4479 3
one.  This warning is by default on for I/O (like print) but can be
turned off by C<no warnings 'utf8';>.  You are supposed to explicitly
mark the filehandle with an encoding, see L<open> and L<perlfunc/binmode>.
d4486 7
a4492 1
=item X outside of string
d4494 1
a4494 2
(F) You had a pack template that specified a relative position before
the beginning of the string being unpacked.  See L<perlfunc/pack>.
d4496 6
a4501 1
=item x outside of string
d4530 6
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d19 1
a19 1
(W, D & S) can be controlled using the C<warnings> pragma. 
d47 8
d83 1
a83 1
on the operator (e.g. C<CORE::log($x)>) or by declaring the subroutine
d87 7
d123 2
a124 2
(W misc) The pattern match (//), substitution (s///), and
transliteration (tr///) operators work on scalar values.  If you apply
d193 36
a228 1
=item Negative offset to vec in lvalue context
d230 1
a230 2
(F) When vec is called in an lvalue context, the second argument must be
greater than or equal to zero.
d288 1
a288 1
=item Bad arg length for %s, is %d, should be %d
d297 1
a297 1
(F) You've used the /e switch to evaluate the replacement for a
d429 5
d563 3
a565 3
(S) Currently, only scalar variables can declared with a specific class
qualifier in a "my" or "our" declaration.  The semantics may be extended
for other types of variables in future.
d594 1
a594 1
=item Can't do {n,m} with n > m before << HERE in regex m/%s/
d597 1
a597 1
regexp to match something 0 times, just put {0}. The << HERE shows in the
d631 1
a631 1
(W exec) An system(), exec(), or piped open call could not execute the
d655 7
d690 1
a690 1
=item Can't find %s property definition %s 
d692 5
a696 3
(F) You may have tried to use C<\p> which means a Unicode property for
example \p{Lu} is all uppercase letters.  Escape the C<\p>, either
C<\\p> (just the C<\p>) or by C<\Q\p> (the rest of the string, until
d795 1
a795 1
that $ref will still be a reference.  
d820 5
d878 10
d919 1
a919 1
=item Can't open perl script "%s": %s
d947 1
a947 1
=item Can't remove %s: %s, skipping file 
d1045 6
d1120 20
a1139 1
=item chmod() mode argument is missing initial 0
d1141 3
a1143 1
(W chmod) A novice will sometimes say
d1145 1
a1145 1
    chmod 777, $filename
d1147 2
a1148 3
not realizing that 777 will be interpreted as a decimal number,
equivalent to 01411.  Octal constants are introduced with a leading 0 in
Perl, as in C.
d1177 23
d1224 1
a1224 1
(S|W redefine) You redefined a subroutine which had previously been
d1236 1
a1236 1
(F) The method which overloads "=" is buggy. See 
d1279 1
a1279 1
array is empty, just use C<if (@@array) { # not empty }> for example.  
d1285 6
a1290 1
is empty, just use C<if (%hash) { # not empty }> for example.  
d1335 5
d1359 5
d1376 6
d1423 4
d1438 1
a1438 1
(W exiting) You are exiting an eval by unconventional means, such as a
d1475 1
a1475 1
=item false [] range "%s" in regexp
d1478 4
a1481 3
character, not another character class like C<\d> or C<[:alpha:]>.  The
"-" in your false range is interpreted as a literal "-".  Consider
quoting the "-",  "\-".  See L<perlre>.
d1501 6
d1510 2
a1511 2
(W io) You tried to read from a filehandle opened only for writing.  If
you intended it to be a read/write filehandle, you needed to open it
d1514 6
d1538 1
a1538 1
some time before now.  Check your logic flow.  flock() operates on
d1542 3
a1544 1
=item Quantifier follows nothing before << HERE in regex m/%s/
d1547 2
a1548 2
meant it literally. The << HERE shows in the regular expression about where the
problem was discovered. See L<perlre>.
d1560 1
a1560 1
	no warnings;
d1647 5
d1703 5
d1732 1
a1732 1
(F) You used an 8 or 9 in a octal number.
d1736 1
a1736 1
(W digit) You may have tried to use an 8 or 9 in a octal number.
d1742 1
a1742 1
following switches: B<-[DIMUdmw]>.
d1768 6
d1810 1
a1810 1
=item Internal disaster before << HERE in regex m/%s/
d1813 1
a1813 1
The << HERE shows in the regular expression about where the problem was
a1815 1

d1825 1
a1825 4
=item Internal urp before << HERE in regex m/%s/

(P) Something went badly awry in the regular expression parser. The <<<HERE
shows in the regular expression about where the problem was discovered.
d1827 3
d1835 1
a1835 1
operators arguments found inside the parentheses.  See 
d1853 1
a1853 1
=item invalid [] range "%s" in regexp
d1856 9
a1864 1
greater than the maximum character.  See L<perlre>.
d1891 10
d1903 2
a1904 2
(W) The second (fourth, sixth, ...) argument of overload::constant needs
to be a code reference. Either an anonymous subroutine, or a reference
d1909 2
a1910 1
(W) You tried to overload a constant type the overload package is unaware of.
d1945 1
a1945 1
=item Lookbehind longer than %d not implemented at {#} mark in regex %s
d1947 3
a1949 2
There is an upper limit to the depth of lookbehind in the (?<=
regular expression construct.
d1957 3
a1959 1
=item Lookbehind longer than %d not implemented before << HERE %s
d1962 2
a1963 2
handle. This restriction may be eased in a future release. The << HERE shows in
the regular expression about where the problem was discovered.
a1971 1

d1979 7
d1990 4
d1999 3
a2001 1
=item %s matches null string many times
d2004 9
a2012 2
regular expression engine didn't specifically check for that.  See
L<perlre>.
d2037 2
a2038 1
(W syntax) An underline in a decimal constant wasn't on a 3-digit boundary.
d2072 4
d2105 1
a2105 1
        } 
d2128 7
d2184 6
a2189 1
=item Nested quantifiers before << HERE in regex m/%s/
d2192 1
a2192 1
things like ** or +* or ?* are illegal. The << HERE shows in the regular
d2195 1
a2195 1
Note, however, that the minimal matching quantifiers, C<*?>, C<+?>, and
a2197 1

d2323 5
d2423 6
d2468 1
a2468 1
about about 250 characters.  You've exceeded that length.  Future
d2489 7
a2495 2
(W) The call to overload::constant contained an odd number of arguments.
The arguments should come in pairs.
d2512 1
a2512 1
that isn't open.  Check your logic.  See also L<perlfunc/-X>.
d2514 1
a2514 1
=item %s() on unopened %s %s
d2630 1
a2630 1
=item panic: pp_match
d2772 1
a2772 1
to even) byte length. 
d2819 25
d2854 7
a2860 1
=item POSIX syntax [%s] belongs inside character classes
d2862 6
a2867 5
(W unsafe) The character class constructs [: :], [= =], and [. .]  go
I<inside> character classes, the [] are part of the construct, for
example: /[012[:alpha:]345]/.  Note that [= =] and [. .] are not
currently implemented; they are simply placeholders for future
extensions and will cause fatal errors.
d2869 3
a2871 1
=item POSIX  syntax [. .] is reserved for future extensions
d2874 16
a2889 12
beginning with "[." and ending with ".]" is reserved for future
extensions.  If you need to represent those character sequences inside
a regular expression character class, just quote the square brackets
with the backslash: "\[." and ".\]".

=item POSIX syntax [= =] is reserved for future extensions

(F) Within regular expression character classes ([]) the syntax
beginning with "[=" and ending with "=]" is reserved for future
extensions.  If you need to represent those character sequences inside
a regular expression character class, just quote the square brackets
with the backslash: "\[=" and "=\]".
d2891 1
a2891 1
=item POSIX class [:%s:] unknown
d2893 7
a2899 2
(F) The class in the character class [: :] syntax is unknown.  See
L<perlre>.
d2958 7
d2972 1
a2972 1
(W deprecated) You have written something like this:
d3010 1
a3010 1
before now.  Check your logic flow.
d3015 1
a3015 1
before now.  Check your logic flow.
d3027 1
a3027 1
(S unsafe) The subroutine being declared or defined had previously been
d3030 8
a3037 1
=item Quantifier in {,} bigger than %d before << HERE in regex m/%s/
d3040 1
a3040 1
{min,max} construct. The << HERE shows in the regular expression about where
d3043 3
a3045 1
=item Quantifier unexpected on zero-length expression before << HERE %s
d3053 3
d3066 1
a3066 1
before now.  Check your logic flow.
d3116 3
a3118 1
=item Reference to nonexistent group before << HERE in regex m/%s/
d3125 1
a3125 1
The << HERE shows in the regular expression about where the problem was
d3218 5
d3240 1
a3240 1
before now.  Check your logic flow.
d3242 1
a3242 1
=item Sequence (? incomplete before << HERE mark in regex m/%s/
d3244 1
a3244 1
(F) A regular expression ended with an incomplete extension (?. The <<<HERE
d3248 3
a3250 1
=item Sequence (?{...}) not terminated or not {}-balanced in %s
d3253 5
a3257 1
for Perl to properly detect the end of the clause. See L<perlre>.
d3259 1
a3259 1
=item Sequence (?%s...) not implemented before << HERE mark in %s
d3262 1
a3262 1
has not yet been written. The << HERE shows in the regular expression about
d3265 1
a3265 1
=item Sequence (?%s...) not recognized before << HERE mark in %s
d3267 7
a3273 4
(F) You used a regular expression extension that doesn't make sense.
The << HERE shows in the regular expression about
where the problem was discovered. 
See L<perlre>.
d3275 1
a3275 1
=item Sequence (?#... not terminated in regex m/%s/
d3278 3
a3280 1
parenthesis.  Embedded parentheses aren't allowed.  See L<perlre>.
d3304 3
a3306 5
	http://www.perl.com/CPAN/doc/FAQs/cgi/idiots-guide.html
	http://www.perl.com/CPAN/doc/FAQs/cgi/perl-cgi-faq.html
	ftp://rtfm.mit.edu/pub/usenet/news.answers/www/cgi-faq
	http://hoohoo.ncsa.uiuc.edu/cgi/interface.html
	http://www-genome.wi.mit.edu/WWW/faqs/www-security-faq.html
d3393 8
d3431 1
a3431 1
	no warnings;
d3444 1
a3444 1
(F) The lexer couldn't find the interior delimiter of a s/// or s{}{}
d3450 1
a3450 1
(F) The lexer couldn't find the final delimiter of a s/// or s{}{}
d3467 3
a3469 1
=item Switch (?(condition)... contains too many branches before << HE%s
d3478 1
a3478 1
The << HERE shows in the regular expression about where the problem was
d3481 3
a3483 1
=item Switch condition not recognized before << HERE in regex m/%s/
d3486 1
a3486 1
number, it can be only a number. The << HERE shows in the regular expression
d3522 6
d3542 1
a3542 1
before now.  Check your logic flow.
d3582 1
a3582 1
=item The stat preceding C<-l _> wasn't an lstat
d3601 4
d3655 2
d3660 1
a3660 3
=item Too many ('s

=item trailing \ in regexp
a3687 5
=item umask: argument is missing initial 0

(W umask) A umask of 222 is incorrect.  It should be 0222, because octal
literals always start with 0 in Perl, as in C.

d3763 5
d3774 7
a3780 1
=item Unknown switch condition (?(%.2s before << HERE in regex m/%s/
d3782 6
a3787 5
(F) The condition of a (?(condition)if-clause|else-clause) construct is not
known. The condition may be lookaround (the condition is true if the
lookaround is true), a (?{...}) construct (the condition is true if the
code evaluates to a true value), or a number (the condition is true if the
set of capturing parentheses named by the number is defined).
d3789 1
a3789 1
The << HERE shows in the regular expression about where the problem was
d3796 1
a3796 1
C<< +> >>, C<<< +>> >>>, C<-|>, C<|->.
d3805 10
a3814 1
=item unmatched [ before << HERE mark in regex m/%s/
d3818 2
a3819 2
first. See L<perlre>. The << HERE shows in the regular expression about
where the escape was discovered.
d3821 1
a3821 1
=item unmatched ( in regexp before << HERE mark in regex m/%s/
d3824 3
a3826 2
expressions.  If you're a vi user, the % key is valuable for finding the
matching parenthesis.  See L<perlre>.
d3854 3
a3856 1
=item Unrecognized escape \\%c passed through before << HERE in m/%s/
d3861 2
a3862 3
literally. The << HERE shows in the regular expression about where the escape
was discovered.

d3946 32
d4010 8
d4022 17
d4049 32
d4111 13
d4147 11
d4167 7
d4188 24
d4292 3
a4294 1
=item Variable length lookbehind not implemented before << HERE in %s
d4297 2
a4298 2
known at compile time. The << HERE shows in the regular expression about where
the problem was discovered.
d4306 10
d4348 4
a4351 1
(F) Perl met a wide character (>255) when it wasn't expecting one.
d4356 1
a4356 1
before now.  Check your logic flow.
a4377 6
=item You can't use C<-l> on a filehandle

(F) A filehandle represents an opened file, and when you opened the file
it already went past any symlink you are presumably trying to look for.
Use a filename instead.

d4382 2
a4383 2
about what you want.  Your best bet is to use the wrapsuid script in the
eg directory to put a setuid C wrapper around your script.
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d18 2
a19 2
The majority of messages from the first three classifications above (W,
D & S) can be controlled using the C<warnings> pragma. 
d38 6
a43 4
Some of these messages are generic.  Spots that vary are denoted with a %s,
just as in a printf format.  Note that some messages start with a %s!
Since the messages are listed in alphabetical order, the symbols
C<"%(-?@@> sort before the letters, while C<[> and C<\> sort after.
d47 1
a47 1
=item "%s" variable %s masks earlier declaration in same %s
d49 3
a51 5
(W misc) A "my" or "our" variable has been redeclared in the current scope or statement,
effectively eliminating all access to the previous instance.  This is almost
always a typographical error.  Note that the earlier variable will still exist
until the end of the scope or until all closure referents to it are
destroyed.
d53 1
a53 1
=item "my sub" not yet implemented
d55 1
a55 23
(F) Lexically scoped subroutines are not yet implemented.  Don't try that
yet.

=item "my" variable %s can't be in a package

(F) Lexically scoped variables aren't in a package, so it doesn't make sense
to try to declare one with a package qualifier on the front.  Use local()
if you want to localize a package variable.

=item "no" not allowed in expression

(F) The "no" keyword is recognized and executed at compile time, and returns
no useful value.  See L<perlmod>.

=item "our" variable %s redeclared

(W misc) You seem to have already declared the same global once before in the
current lexical scope.

=item "use" not allowed in expression

(F) The "use" keyword is recognized and executed at compile time, and returns
no useful value.  See L<perlmod>.
d62 1
a62 1
=item / cannot take a count
d64 4
a67 3
(F) You had an unpack template indicating a counted-length string,
but you have also specified an explicit size for the string.
See L<perlfunc/pack>.
d69 4
a72 1
=item / must be followed by a, A or Z
d74 4
a77 4
(F) You had an unpack template indicating a counted-length string,
which must be followed by one of the letters a, A or Z
to indicate what sort of string is to be unpacked.
See L<perlfunc/pack>.
d79 1
a79 1
=item / must be followed by a*, A* or Z*
d81 3
a83 3
(F) You had a pack template indicating a counted-length string,
Currently the only things that can have their length counted are a*, A* or Z*.
See L<perlfunc/pack>.
d85 1
a85 1
=item / must follow a numeric type
d87 3
a89 3
(F) You had an unpack template that contained a '#',
but this did not follow some numeric unpack specification.
See L<perlfunc/pack>.
d91 1
a91 1
=item % may only be used in unpack
d93 5
a97 3
(F) You can't pack a string by supplying a checksum, because the
checksumming process loses information, and you can't go the other
way.  See L<perlfunc/unpack>.
d99 6
a104 1
=item /%s/: Unrecognized escape \\%c passed through
d106 1
a106 3
(W regexp) You used a backslash-character combination which is not recognized
by Perl.  This combination appears in an interpolated variable or a 
C<'>-delimited regular expression.  The character was understood literally.
d108 7
a114 1
=item /%s/: Unrecognized escape \\%c in character class passed through
d116 1
a116 2
(W regexp) You used a backslash-character combination which is not recognized
by Perl inside character classes.  The character was understood literally.
d118 4
a121 1
=item /%s/ should probably be written as "%s"
d123 1
a123 4
(W syntax) You have used a pattern where Perl expected to find a string,
as in the first argument to C<join>.  Perl will treat the true
or false result of matching the pattern against $_ as the string,
which is probably not what you had in mind.
d125 1
a125 15
=item %s (...) interpreted as function

(W syntax) You've run afoul of the rule that says that any list operator followed
by parentheses turns into a function, with all the list operators arguments
found inside the parentheses.  See L<perlop/Terms and List Operators (Leftward)>.

=item %s() called too early to check prototype

(W prototype) You've called a function that has a prototype before the parser saw a
definition or declaration for it, and Perl could not check that the call
conforms to the prototype.  You need to either add an early prototype
declaration for the subroutine in question, or move the subroutine
definition ahead of the call to get proper prototype checking.  Alternatively,
if you are certain that you're calling the function correctly, you may put
an ampersand before the name to avoid the warning.  See L<perlsub>.
d136 2
a137 1
(F) The argument to delete() must be either a hash or array element, such as:
d150 2
a151 174
name, and not a subroutine call.  C<exists &sub()> will generate this error.

=item %s did not return a true value

(F) A required (or used) file must return a true value to indicate that
it compiled correctly and ran its initialization code correctly.  It's
traditional to end such a file with a "1;", though any true value would
do.  See L<perlfunc/require>.

=item %s found where operator expected

(S) The Perl lexer knows whether to expect a term or an operator.  If it
sees what it knows to be a term when it was expecting to see an operator,
it gives you this warning.  Usually it indicates that an operator or
delimiter was omitted, such as a semicolon.

=item %s had compilation errors

(F) The final summary message when a C<perl -c> fails.

=item %s has too many errors

(F) The parser has given up trying to parse the program after 10 errors.
Further error messages would likely be uninformative.

=item %s matches null string many times

(W regexp) The pattern you've specified would be an infinite loop if the
regular expression engine didn't specifically check for that.  See L<perlre>.

=item %s never introduced

(S internal) The symbol in question was declared but somehow went out of scope
before it could possibly have been used.

=item %s package attribute may clash with future reserved word: %s

(W reserved) A lowercase attribute name was used that had a package-specific handler.
That name might have a meaning to Perl itself some day, even though it
doesn't yet.  Perhaps you should use a mixed-case attribute name, instead.
See L<attributes>.

=item %s syntax OK

(F) The final summary message when a C<perl -c> succeeds.

=item %s: Command not found

(A) You've accidentally run your script through B<csh> instead
of Perl.  Check the #! line, or manually feed your script into
Perl yourself.

=item %s: Expression syntax

(A) You've accidentally run your script through B<csh> instead
of Perl.  Check the #! line, or manually feed your script into
Perl yourself.

=item %s: Undefined variable

(A) You've accidentally run your script through B<csh> instead
of Perl.  Check the #! line, or manually feed your script into
Perl yourself.

=item %s: not found

(A) You've accidentally run your script through the Bourne shell
instead of Perl.  Check the #! line, or manually feed your script
into Perl yourself.

=item (in cleanup) %s

(W misc) This prefix usually indicates that a DESTROY() method raised
the indicated exception.  Since destructors are usually called by
the system at arbitrary points during execution, and often a vast
number of times, the warning is issued only once for any number
of failures that would otherwise result in the same message being
repeated.

Failure of user callbacks dispatched using the C<G_KEEPERR> flag
could also result in this warning.  See L<perlcall/G_KEEPERR>.

=item (Missing semicolon on previous line?)

(S) This is an educated guess made in conjunction with the message "%s
found where operator expected".  Don't automatically put a semicolon on
the previous line just because you saw this message.

=item B<-P> not allowed for setuid/setgid script

(F) The script would have to be opened by the C preprocessor by name,
which provides a race condition that breaks security.

=item C<-T> and C<-B> not implemented on filehandles

(F) Perl can't peek at the stdio buffer of filehandles when it doesn't
know about your kind of stdio.  You'll have to use a filename instead.

=item C<-p> destination: %s

(F) An error occurred during the implicit output invoked by the C<-p>
command-line switch.  (This output goes to STDOUT unless you've
redirected it with select().)

=item 500 Server error

See Server error.

=item ?+* follows nothing in regexp

(F) You started a regular expression with a quantifier.  Backslash it
if you meant it literally.   See L<perlre>.

=item @@ outside of string

(F) You had a pack template that specified an absolute position outside
the string being unpacked.  See L<perlfunc/pack>.

=item <> should be quotes

(F) You wrote C<< require <file> >> when you should have written
C<require 'file'>.

=item accept() on closed socket %s

(W closed) You tried to do an accept on a closed socket.  Did you forget to check
the return value of your socket() call?  See L<perlfunc/accept>.

=item Allocation too large: %lx

(X) You can't allocate more than 64K on an MS-DOS machine.

=item Applying %s to %s will act on scalar(%s)

(W misc) The pattern match (//), substitution (s///), and transliteration (tr///)
operators work on scalar values.  If you apply one of them to an array
or a hash, it will convert the array or hash to a scalar value -- the
length of an array, or the population info of a hash -- and then work on
that scalar value.  This is probably not what you meant to do.  See
L<perlfunc/grep> and L<perlfunc/map> for alternatives.

=item Arg too short for msgsnd

(F) msgsnd() requires a string at least as long as sizeof(long).

=item Ambiguous use of %s resolved as %s

(W ambiguous)(S) You said something that may not be interpreted the way
you thought.  Normally it's pretty easy to disambiguate it by supplying
a missing quote, operator, parenthesis pair or declaration.

=item Ambiguous call resolved as CORE::%s(), qualify as such or use &

(W ambiguous) A subroutine you have declared has the same name as a Perl keyword,
and you have used the name without qualification for calling one or the
other.  Perl decided to call the builtin because the subroutine is
not imported.

To force interpretation as a subroutine call, either put an ampersand
before the subroutine name, or qualify the name with its package.
Alternatively, you can import the subroutine (or pretend that it's
imported with the C<use subs> pragma).

To silently interpret it as the Perl operator, use the C<CORE::> prefix
on the operator (e.g. C<CORE::log($x)>) or by declaring the subroutine
to be an object method (see L<perlsub/"Subroutine Attributes">
or L<attributes>).

=item Args must match #! line

(F) The setuid emulator requires that the arguments Perl was invoked
with match the arguments specified on the #! line.  Since some systems
impose a one-argument limit on the #! line, try combining switches;
for example, turn C<-w -U> into C<-wU>.
d155 2
a156 2
(W numeric) The indicated string was fed as an argument to an operator that
expected a numeric value instead.  If you're fortunate the message
d161 2
a162 2
(D deprecated) Really old Perl let you omit the @@ on array names in some spots.  This
is now heavily deprecated.
d178 5
d185 3
a187 3
(P internal) All SV objects are supposed to be allocated from arenas that will
be garbage collected on exit.  An SV was discovered to be outside any
of those arenas.
d191 4
a194 4
(P internal) Perl maintains a reference counted internal table of strings to
optimize the storage and access of hash keys and other strings.  This
indicates someone tried to decrement the reference count of a string
that can no longer be found in the table.
d198 5
a202 5
(W debugging) Mortalized values are supposed to be freed by the free_tmps()
routine.  This indicates that something else is freeing the SV before
the free_tmps() routine gets a chance, which means that the free_tmps()
routine will be freeing an unreferenced scalar when it does try to free
it.
d210 7
a216 6
(W internal) Perl went to decrement the reference count of a scalar to see if it
would go to 0, and discovered that it had already gone to 0 earlier,
and should have been freed, and in fact, probably was freed.  This
could indicate that SvREFCNT_dec() was called too many times, or that
SvREFCNT_inc() was called too few times, or that the SV was mortalized
when it shouldn't have been, or that memory has been corrupted.
d221 2
a222 2
impossible task.  You may be joining the wrong thread, or you may
need to move the join() to some other thread.
d235 2
a236 2
(W substr) You supplied a reference as the first argument to substr() used
as an lvalue, which is pretty strange.  Perhaps you forgot to
d241 2
a242 2
(F) You passed a buffer of the wrong size to one of msgctl(), semctl() or
shmctl().  In C parlance, the correct sizes are, respectively,
d254 3
a256 3
(F) A symbol was passed to something wanting a filehandle, but the symbol
has no filehandle associated with it.  Perhaps you didn't do an open(), or
did it in another package.
d260 7
a266 8
(S malloc) An internal routine called free() on something that had never been
malloc()ed in the first place. Mandatory, but can be disabled by
setting environment variable C<PERL_BADFREE> to 1.

This message can be quite often seen with DB_File on systems with
"hard" dynamic linking, like C<AIX> and C<OS/2>. It is a bug of
C<Berkeley DB> which is left unnoticed if C<DB> uses I<forgiving>
system malloc().
d278 6
d286 3
a288 3
(F) You started to name a symbol by using a package prefix, and then didn't
finish the symbol.  In particular, you can't interpolate outside of quotes,
so
d300 3
a302 3
(S malloc) An internal routine called realloc() on something that had never been
malloc()ed in the first place. Mandatory, but can be disabled by
setting environment variable C<PERL_BADFREE> to 1.
d311 2
a312 2
(P) An internal request asked to add a filehandle entry to something that
wasn't a symbol table entry.
a318 18
=item Badly placed ()'s

(A) You've accidentally run your script through B<csh> instead
of Perl.  Check the #! line, or manually feed your script into
Perl yourself.

=item Bareword "%s" not allowed while "strict subs" in use

(F) With "strict subs" in use, a bareword is only allowed as a
subroutine identifier, in curly brackets or to the left of the "=>" symbol.
Perhaps you need to predeclare a subroutine?

=item Bareword "%s" refers to nonexistent package

(W bareword) You used a qualified bareword of the form C<Foo::>, but
the compiler saw no other uses of that namespace before that point.
Perhaps you need to predeclare a package?

d321 3
a323 3
(W bareword) The compiler found a bareword where it expected a conditional,
which often indicates that an || or && was parsed as part of the
last argument of the previous construct, for example:
d327 2
a328 2
It may also indicate a misspelled constant that has been interpreted
as a bareword:
d335 12
d349 3
a351 2
(F) An untrapped exception was raised while executing a BEGIN subroutine.
Compilation stops immediately and the interpreter is exited.
d356 12
a367 4
implies a C<BEGIN {}>) after one or more compilation errors had
already occurred.  Since the intended environment for the C<BEGIN {}>
could not be guaranteed (due to the errors), and since subsequent code
likely depends on its correct operation, Perl just gave up.
d377 2
a378 2
(W closed) You tried to do a bind on a closed socket.  Did you forget to check
the return value of your socket() call?  See L<perlfunc/bind>.
d386 7
a392 1
(P) Perl detected an attempt to copy an internal value that is not copiable.
d396 3
a398 3
(W internal) A warning peculiar to VMS.  While Perl was preparing to iterate over
%ENV, it encountered a logical name or symbol definition which was too long,
so it was truncated to the string shown.
d405 1
a405 1
=item Can't "goto" out of a pseudo block
d407 8
a414 4
(F) A "goto" statement was executed to jump out of what might look
like a block, except that it isn't a proper block.  This usually
occurs if you tried to jump out of a sort() block or subroutine, which
is a no-no.  See L<perlfunc/goto>.
d416 1
a416 23
=item Can't "goto" into the middle of a foreach loop

(F) A "goto" statement was executed to jump into the middle of a
foreach loop.  You can't get there from here.  See L<perlfunc/goto>.

=item Can't "last" outside a loop block

(F) A "last" statement was executed to break out of the current block,
except that there's this itty bitty problem called there isn't a
current block.  Note that an "if" or "else" block doesn't count as a
"loopish" block, as doesn't a block given to sort(), map() or grep().
You can usually double the curlies to get the same effect though,
because the inner curlies will be considered a block that loops once.
See L<perlfunc/last>.

=item Can't "next" outside a loop block

(F) A "next" statement was executed to reiterate the current block, but
there isn't a current block.  Note that an "if" or "else" block doesn't
count as a "loopish" block, as doesn't a block given to sort(), map()
or grep().  You can usually double the curlies to get the same effect
though, because the inner curlies will be considered a block that
loops once.  See L<perlfunc/next>.
d418 3
a420 15
=item Can't read CRTL environ

(S) A warning peculiar to VMS.  Perl tried to read an element of %ENV
from the CRTL's internal environment array and discovered the array was
missing.  You need to figure out where your CRTL misplaced its environ
or define F<PERL_ENV_TABLES> (see L<perlvms>) so that environ is not searched.

=item Can't "redo" outside a loop block

(F) A "redo" statement was executed to restart the current block, but
there isn't a current block.  Note that an "if" or "else" block doesn't
count as a "loopish" block, as doesn't a block given to sort(), map()
or grep().  You can usually double the curlies to get the same effect
though, because the inner curlies will be considered a block that
loops once.  See L<perlfunc/redo>.
a426 6
=item Can't break at that line

(S internal) A warning intended to only be printed while running within the debugger, indicating
the line number specified wasn't the location of a statement that could
be stopped at.

d433 10
d446 3
a448 3
ordinarily finds this out from the object reference you supply, but
you didn't supply an object reference in this case.  A reference isn't
an object reference until it has been blessed.  See L<perlobj>.
d453 2
a454 2
object reference or package name contains an expression that returns
a defined value which is neither an object reference nor a package name.
a460 10
=item Can't call method "%s" on an undefined value

(F) You used the syntax of a method call, but the slot filled by the
object reference or package name contains an undefined value.
Something like this will reproduce the error:

    $BADREF = undef;
    process $BADREF 1,2,3;
    $BADREF->process(1,2,3);

d468 9
a476 2
(P) For some reason you can't check the filesystem of the script for nosuid.

a501 6
=item Can't coerce array into hash

(F) You used an array where a hash was expected, but the array has no
information on how to map from keys to array indices.  You can do that
only with arrays that have a hash reference at index 0.

d504 2
a505 2
(P) An error peculiar to VMS.  The process is suffering from exhausted quotas
or other plumbing problems.
d518 5
d525 2
a526 1
(S inplace) The creation of the new file failed for the indicated reason.
d530 3
a532 3
(F) You're on a system such as MS-DOS that gets confused if you try reading
from a deleted (but still opened) file.  You have to say C<-i.bak>, or some
such.
d540 1
a540 1
=item Can't do inplace edit: %s is not a regular file
d542 3
a544 2
(S inplace) You tried to use the B<-i> switch on a special file, such as a file in
/dev, or a FIFO.  The file was ignored.
d548 2
a549 2
(P) The setegid() call failed for some reason in the setuid emulator
of suidperl.
d557 6
a562 6
(F) This typically means that ordinary perl tried to exec suidperl to
do setuid emulation, but couldn't exec it.  It looks for a name of the
form sperl5.000 in the same directory that the perl executable resides
under the name perl5.000, typically /usr/local/bin on Unix machines.
If the file is there, check the execute permissions.  If it isn't, ask
your sysadmin why he and/or she removed it.
d566 2
a567 7
(F) This machine doesn't have either waitpid() or wait4(), so only waitpid()
without flags is emulated.

=item Can't do {n,m} with n > m

(F) Minima must be less than or equal to maxima.  If you really want
your regexp to match something 0 times, just put {0}.  See L<perlre>.
d571 3
a573 2
(F) The #! line specifies a switch that doesn't make sense at this point.
For example, it'd be kind of silly to put a B<-x> on the #! line.
d577 7
a583 6
(W exec) An system(), exec(), or piped open call could not execute the named
program for the indicated reason.  Typical reasons include: the permissions
were wrong on the file, the file wasn't found in C<$ENV{PATH}>, the
executable in question was compiled for another architecture, or the
#! line in a script points to an interpreter that can't be run for
similar reasons.  (Or maybe your system doesn't support #! at all.)
d587 3
a589 3
(F) Perl was trying to execute the indicated program for you because that's
what the #! line said.  If that's not what you wanted, you may need to
mention "perl" on the #! line somewhere.
d593 7
a599 2
(F) You used the B<-S> switch, but the copies of the script to execute found
in the PATH did not have correct permissions.
d601 1
a601 1
=item Can't find %s on PATH, '.' not in PATH
d603 2
a604 3
(F) You used the B<-S> switch, but the script to execute could not be found
in the PATH, or at least not with the correct permissions.  The script
exists in the current directory, but PATH prohibits running it.
d608 2
a609 2
(F) You used the B<-S> switch, but the script to execute could not be found
in the PATH.
d611 1
a611 1
=item Can't find label %s
d613 3
a615 2
(F) You said to goto a label that isn't mentioned anywhere that it's possible
for us to go to.  See L<perlfunc/goto>.
d619 3
a621 3
(F) Perl strings can stretch over multiple lines.  This message means that
the closing delimiter was omitted.  Because bracketed quotes count nesting
levels, the following is missing its final parenthesis:
d625 10
a634 3
If you're getting this error from a here-document, you may have 
included unseen whitespace before or after your closing tag. A good 
programmer's editor will have a way to help you find these characters.
d638 2
a639 1
(F) A fatal error occurred while trying to fork while opening a pipeline.
d643 15
a657 14
(S) A warning peculiar to VMS.  This arises because of the difference between
access checks under VMS and under the Unix model Perl assumes.  Under VMS,
access checks are done by filename, rather than by bits in the stat buffer, so
that ACLs and other protections can be taken into account.  Unfortunately, Perl
assumes that the stat buffer contains all the necessary information, and passes
it, instead of the filespec, to the access checking routine.  It will try to
retrieve the filespec using the device name and FID present in the stat buffer,
but this works only if you haven't made a subsequent call to the CRTL stat()
routine, because the device name is overwritten with each call.  If this warning
appears, the name lookup failed, and the access checking routine gave up and
returned FALSE, just to be conservative.  (Note: The access checking routine
knows about the Perl C<stat> operator and file tests, so you shouldn't ever
see this warning in response to a Perl command; it arises only if some internal
code takes stat buffers lightly.)
d661 2
a662 2
(P) An error peculiar to VMS.  After creating a mailbox to act as a pipe, Perl
can't retrieve its name for later use.
d669 6
a674 1
=item Can't goto subroutine outside a subroutine
d676 4
a679 4
(F) The deeply magical "goto subroutine" call can only replace one subroutine
call for another.  It can't manufacture one out of whole cloth.  In general
you should be calling it out of only an AUTOLOAD routine anyway.  See
L<perlfunc/goto>.
d683 10
a692 2
(F) The "goto subroutine" call can't be used to jump out of an eval "string".
(You can use it to jump out of an eval {BLOCK}, but you probably don't want to.)
d696 6
a701 6
(W signal) Perl has detected that it is being run with the SIGCHLD signal
(sometimes known as SIGCLD) disabled.  Since disabling this signal
will interfere with proper determination of exit status of child
processes, Perl has reset the signal to its default value.
This situation typically indicates that the parent program under
which Perl may be running (e.g. cron) is being very careless.
d703 1
a703 1
=item Can't localize through a reference
d705 7
a711 4
(F) You said something like C<local $$ref>, which Perl can't currently
handle, because when it goes to restore the old value of whatever $ref
pointed to after the scope of the local() is finished, it can't be
sure that $ref will still be a reference.  
d722 4
a725 4
(F) You said something like C<< local $ar->{'key'} >>, where $ar is
a reference to a pseudo-hash.  That hasn't been implemented yet, but
you can get a similar effect by localizing the corresponding array
element directly -- C<< local $ar->[$ar->[0]{'key'}] >>.
d727 1
a727 1
=item Can't locate auto/%s.al in @@INC
d729 4
a732 4
(F) A function (or method) was called in a package which allows autoload,
but there is no function to autoload.  Most probable causes are a misprint
in a function/method name or a failure to C<AutoSplit> the file, say, by
doing C<make install>.
d738 12
a749 5
unless the file name included the full path to the file.  Perhaps you need
to set the PERL5LIB or PERL5OPT environment variable to say where the extra
library is, or maybe the script needs to add the library name to @@INC.  Or
maybe you just misspelled the name of the file.  See L<perlfunc/require>
and L<lib>.
d757 6
d765 2
a766 2
(W syntax) The @@ISA array contained the name of another package that doesn't seem
to exist.
d770 2
a771 1
(F) List assignment to %ENV is not supported on some systems, notably VMS.
d775 7
a781 2
(F) You aren't allowed to assign to the item indicated, or otherwise try to
change it, such as with an auto-increment.
a787 5
=item Can't modify nonexistent substring

(P) The internal routine that does assignment to a substr() was handed
a NULL.

d793 9
d807 2
a808 2
is because you don't have read permission for a file which you named
on the command line.
d812 4
a815 4
(W pipe) You tried to say C<open(CMD, "|cmd|")>, which is not supported.  You can
try any of several modules in the Perl library to do this, such as
IPC::Open2.  Alternately, direct the pipe's output to a file using ">",
and then read it in under a different file handle.
d819 3
a821 3
(F) An error peculiar to VMS.  Perl does its own command line redirection, and
couldn't open the file specified after '2>' or '2>>' on the
command line for writing.
d825 3
a827 2
(F) An error peculiar to VMS.  Perl does its own command line redirection, and
couldn't open the file specified after '<' on the command line for reading.
d831 3
a833 3
(F) An error peculiar to VMS.  Perl does its own command line redirection, and
couldn't open the file specified after '>' or '>>' on the command
line for writing.
d837 3
a839 2
(P) An error peculiar to VMS.  Perl does its own command line redirection, and
couldn't open the pipe into which to send data destined for stdout.
d845 8
d856 2
a857 2
pointers into them.  You tried to redefine one such sort subroutine when it
was currently active, which is not allowed.  If you really want to do
d860 9
d871 3
a873 3
(S inplace) You requested an inplace edit without creating a backup file.  Perl
was unable to remove the original file to replace it with the modified
file.  The file was left unmodified.
d882 8
a889 2
(P) An error peculiar to VMS.  Perl thought stdin was a pipe, and tried to
reopen it to accept binary data.  Alas, it failed.
d893 16
a908 2
(P) The setreuid() call failed for some reason in the setuid emulator
of suidperl.
a914 6
=item Can't return %s from lvalue subroutine

(F) Perl detected an attempt to return illegal lvalues (such
as temporary or readonly values) from a subroutine used as an lvalue.
This is not allowed.

d917 2
a918 2
(P) For some reason you can't fstat() the script even though you have
it open already.  Bizarre.
d922 2
a923 2
(P) The setreuid() call failed for some reason in the setuid emulator
of suidperl.
d929 2
a930 2
standard with Perl, though, if you really want to do that for
the negative numbers.
d951 4
a954 4
(P) The internal sv_upgrade routine adds "members" to an SV, making
it into a more specialized kind of SV.  The top several SV types are
so specialized, however, that they cannot be interconverted.  This
message indicates that such a conversion was attempted.
d958 13
a970 3
(P) The undefined SV is the bottom of the totem pole, in the scheme
of upgradability.  Upgrading to undef indicates an error in the
code calling sv_upgrade.
d972 1
a972 1
=item Can't use %%! because Errno.pm is not available
d978 13
a998 4
=item Can't use %s for loop variable

(F) Only a simple scalar variable may be used as a loop variable on a foreach.

a1004 13
=item Can't use \%c to mean $%c in expression

(W syntax) In an ordinary expression, backslash is a unary operator that creates
a reference to its argument.  The use of backslash to indicate a backreference
to a matched substring is valid only as part of a regular expression pattern.
Trying to do this in ordinary Perl code produces a value that prints
out looking like SCALAR(0xdecaf).  Use the $1 form instead.

=item Can't use bareword ("%s") as %s ref while "strict refs" in use

(F) Only hard references are allowed by "strict refs".  Symbolic references
are disallowed.  See L<perlref>.

d1007 2
a1008 15
(F) Only hard references are allowed by "strict refs".  Symbolic references
are disallowed.  See L<perlref>.

=item Can't use an undefined value as %s reference

(F) A value used as either a hard reference or a symbolic reference must
be a defined value.  This helps to delurk some insidious errors.

=item Can't use global %s in "my"

(F) You tried to declare a magical variable as a lexical variable.  This is
not allowed, because the magic can be tied to only one location (namely
the global variable) and it would be incredibly confusing to have
variables in your program that looked like magical variables but
weren't.
d1016 9
d1032 2
a1033 2
(F) You tried to repeat a constant value (often the undefined value) with
an assignment operator, which implies modifying the value itself.
a1035 40
=item Can't find an opnumber for "%s"

(F) A string of a form C<CORE::word> was given to prototype(), but
there is no builtin with the name C<word>.

=item Can't resolve method `%s' overloading `%s' in package `%s'

(F|P) Error resolving overloading specified by a method name (as
opposed to a subroutine reference): no such method callable via the
package. If method name is C<???>, this is an internal error.

=item Character class [:%s:] unknown

(F) The class in the character class [: :] syntax is unknown.
See L<perlre>.

=item Character class syntax [%s] belongs inside character classes

(W unsafe) The character class constructs [: :], [= =], and [. .]  go
I<inside> character classes, the [] are part of the construct,
for example: /[012[:alpha:]345]/.  Note that [= =] and [. .]
are not currently implemented; they are simply placeholders for
future extensions.

=item Character class syntax [. .] is reserved for future extensions

(W regexp) Within regular expression character classes ([]) the syntax beginning
with "[." and ending with ".]" is reserved for future extensions.
If you need to represent those character sequences inside a regular
expression character class, just quote the square brackets with the
backslash: "\[." and ".\]".

=item Character class syntax [= =] is reserved for future extensions

(W regexp) Within regular expression character classes ([]) the syntax
beginning with "[=" and ending with "=]" is reserved for future extensions.
If you need to represent those character sequences inside a regular
expression character class, just quote the square brackets with the
backslash: "\[=" and "=\]".

d1042 3
a1044 2
not realizing that 777 will be interpreted as a decimal number, equivalent
to 01411.  Octal constants are introduced with a leading 0 in Perl, as in C.
d1046 1
a1046 1
=item Close on unopened file <%s>
d1050 5
d1058 2
a1059 2
Perl uses this generic message when none of the errors that it encountered
were severe enough to halt compilation immediately.
d1063 3
a1065 3
(W regexp) The regular expression engine uses recursion in complex situations
where back-tracking is required.  Recursion depth is limited to 32766,
or perhaps less in architectures where the stack cannot grow
d1068 4
a1071 4
under examination; looping in Perl code (e.g. with C<while>) rather
than in the regular expression engine; or rewriting the regular
expression so that it is simpler or backtracks less.  (See L<perlbook>
for information on I<Mastering Regular Expressions>.)
d1075 11
a1085 2
(W closed) You tried to do a connect on a closed socket.  Did you forget to check
the return value of your socket() call?  See L<perlfunc/connect>.
d1090 3
a1092 3
is being dereferenced, but it amounts to the wrong type of reference.  The
message indicates the type of reference that was expected. This usually
indicates a syntax error in dereferencing the constant value.
d1097 3
a1099 3
(S|W redefine) You redefined a subroutine which had previously been eligible for
inlining.  See L<perlsub/"Constant Functions"> for commentary and
workarounds.
d1103 2
a1104 2
(W misc) You undefined a subroutine which had previously been eligible for
inlining.  See L<perlsub/"Constant Functions"> for commentary and
a1106 7
=item constant(%s): %s

(F) The parser found inconsistencies either while attempting to define an
overloaded constant, or when trying to find the character name specified
in the C<\N{...}> escape.  Perhaps you forgot to load the corresponding
C<overload> or C<charnames> pragma?  See L<charnames> and L<overload>.

d1109 2
a1110 1
(F) The method which overloads "=" is buggy. See L<overload/Copy Constructor>.
d1116 10
d1130 1
a1130 1
=item corrupted regexp pointers
d1132 3
a1134 2
(P) The regular expression engine got confused by what the regular
expression compiler gave it.
d1136 1
a1136 1
=item corrupted regexp program
d1138 2
a1139 2
(P) The regular expression engine got passed a regexp program without
a valid magic number.
d1143 4
a1146 4
(W recursion) This subroutine has called itself (directly or indirectly) 100
times more than it has returned.  This probably indicates an infinite
recursion, unless you're writing strange benchmark programs, in which
case it indicates something else.
d1150 3
a1152 3
(D deprecated) defined() is not usually useful on arrays because it checks for an
undefined I<scalar> value.  If you want to see if the array is empty,
just use C<if (@@array) { # not empty }> for example.  
d1156 3
a1158 3
(D deprecated) defined() is not usually useful on hashes because it checks for an
undefined I<scalar> value.  If you want to see if the hash is empty,
just use C<if (%hash) { # not empty }> for example.  
d1162 3
a1164 3
(F) In a here document construct like C<<<FOO>, the label
C<FOO> is too long for Perl to handle.  You have to be seriously
twisted to write code that triggers this error.
d1170 7
d1179 2
a1180 1
(W) You probably referred to an imported subroutine &FOO as $FOO or some such.
d1184 3
a1186 2
(W misc) Remember that "our" does not localize the declared global variable.
You have declared it again in the same lexical scope, which seems superfluous.
d1190 3
a1192 2
(W) You probably said %hash{$key} when you meant $hash{$key} or @@hash{@@keys}.
On the other hand, maybe you just meant %hash and got carried away.
a1198 12
=item (Do you need to predeclare %s?)

(S) This is an educated guess made in conjunction with the message "%s
found where operator expected".  It often means a subroutine or module
name is being referenced that hasn't been declared yet.  This may be
because of ordering problems in your file, or because of a missing
"sub", "package", "require", or "use" statement.  If you're
referencing something that isn't defined yet, you don't actually have
to define the subroutine or package before the current location.  You
can use an empty "sub foo;" or "package FOO;" to enter a "forward"
declaration.

d1211 11
d1224 2
a1225 2
(S malloc) An internal routine called free() on something that had already
been freed.
d1229 3
a1231 3
(S) There is no keyword "elseif" in Perl because Larry thinks it's
ugly.  Your code will be interpreted as an attempt to call a method
named "elseif" for the class returned by the following block.  This is
a1233 6
=item %s failed--call queue aborted

(F) An untrapped exception was raised while executing a CHECK, INIT, or
END subroutine.  Processing of the remainder of the queue of such
routines has been prematurely ended.

d1243 3
a1245 3
single form when it must operate on them directly.  Either you've
passed an invalid file specification to Perl, or you've found a
case the conversion routines don't handle.  Drat.
d1249 3
a1251 3
(F) Perl detected tainted data when trying to compile a regular expression
that contains the C<(?{ ... })> zero-width assertion, which is unsafe.
See L<perlre/(?{ code })>, and L<perlsec>.
d1253 1
a1253 1
=item %s: Eval-group not allowed, use re 'eval'
d1255 6
a1260 3
(F) A regular expression contained the C<(?{ ... })> zero-width assertion,
but that construct is only allowed when the C<use re 'eval'> pragma is
in effect.  See L<perlre/(?{ code })>.
d1262 1
a1262 1
=item %s: Eval-group not allowed at run time
d1264 3
a1266 6
(F) Perl tried to compile a regular expression containing the C<(?{ ... })>
zero-width assertion at run time, as it would when the pattern contains
interpolated values.  Since that is a security risk, it is not allowed.
If you insist, you may still do this by explicitly building the pattern
from an interpolated string at run time and using that in an eval().
See L<perlre/(?{ code })>.
d1281 2
a1282 2
(W exiting) You are exiting an eval by unconventional means, such as
a goto, or a loop control statement.
d1286 2
a1287 2
(W exiting) You are exiting an eval by unconventional means, such as
a goto, or a loop control statement.
d1291 3
a1293 3
(W exiting) You are exiting a rather special block construct (like a sort block or
subroutine) by unconventional means, such as a goto, or a loop control
statement.  See L<perlfunc/sort>.
d1297 2
a1298 2
(W exiting) You are exiting a subroutine by unconventional means, such as
a goto, or a loop control statement.
d1302 2
a1303 2
(W exiting) You are exiting a substitution by unconventional means, such as
a return, a goto, or a loop control statement.
d1309 13
a1321 2
usually not what you want.  Consider providing a default target
package, e.g. bless($ref, $p || 'MyPackage');
d1325 4
a1328 4
(W regexp) A character class range must start and end at a literal character, not
another character class like C<\d> or C<[:alpha:]>.  The "-" in your false
range is interpreted as a literal "-".  Consider quoting the "-",  "\-".
See L<perlre>.
d1332 4
a1335 4
(P) An error peculiar to VMS.  Something untoward happened in a VMS system
service or RTL routine; Perl's exit status should provide more details.  The
filename in "at %s" and the line number in "line %d" tell you which section of
the Perl source code is distressed.
a1341 6
=item Filehandle %s never opened

(W unopened) An I/O operation was attempted on a filehandle that was never initialized.
You need to do an open() or a socket() call, or call a constructor from
the FileHandle package.

d1344 4
a1347 5
(W io) You tried to write on a read-only filehandle.  If you
intended it to be a read-write filehandle, you needed to open it with
"+<" or "+>" or "+>>" instead of with "<" or nothing.  If
you intended only to write the file, use ">" or ">>".  See
L<perlfunc/open>.
d1351 4
a1354 5
(W io) You tried to read from a filehandle opened only for writing.  If you
intended it to be a read/write filehandle, you needed to open it with
"+<" or "+>" or "+>>" instead of with "<" or nothing.  If
you intended only to read from the file, use "<".  See
L<perlfunc/open>.
d1359 3
a1361 3
a literal dollar sign, or was meant to introduce a variable name
that happens to be missing.  So you have to put either the backslash or
the name.
d1366 3
a1368 3
a literal "at" sign, or was meant to introduce a variable name
that happens to be missing.  So you have to put either the backslash or
the name.
d1372 15
a1386 3
(W closed) The filehandle you're attempting to flock() got itself closed some
time before now.  Check your logic flow.  flock() operates on filehandles.
Are you attempting to call flock() on a dirhandle by the same name?
a1396 5
=item Format not terminated

(F) A format must be terminated by a line with a solitary dot.  Perl got
to the end of your file without finding such a line.

d1409 7
d1428 2
a1429 2
(W closed) You tried to get a socket or peer socket name on a closed socket.
Did you forget to check the return value of your socket() call?
d1436 13
d1451 11
a1461 11
(W glob) Something went wrong with the external program(s) used for C<glob>
and C<< <*.c> >>.  Usually, this means that you supplied a C<glob>
pattern that caused the external program to fail and exit with a nonzero
status.  If the message indicates that the abnormal exit resulted in a
coredump, this may also mean that your csh (C shell) is broken.  If so,
you should change all of the csh-related variables in config.sh:  If you
have tcsh, make the variables refer to it as if it were csh (e.g.
C<full_csh='/usr/bin/tcsh'>); otherwise, make them all empty (except that
C<d_csh> should be C<'undef'>) so that Perl will think csh is missing.
In either case, after editing config.sh, run C<./Configure -S> and
rebuild Perl.
d1466 3
a1468 3
a term, so it's looking for the corresponding right angle bracket, and not
finding it.  Chances are you left some needed parentheses out earlier in
the line, and you really meant a "less than".
d1470 1
a1470 1
=item Global symbol "%s" requires explicit package name
d1472 2
a1473 4
(F) You've said "use strict vars", which indicates that all variables
must either be lexically scoped (using "my"), declared beforehand using
"our", or explicitly qualified to say which package the global variable
is in (using "::").
d1480 4
d1486 3
a1488 3
(S internal) A routine asked for a symbol from a symbol table that ought to have
existed already, but for some reason it didn't, and had to be created on
an emergency basis to prevent a core dump.
d1492 7
a1498 2
(D deprecated) Really old Perl let you omit the % on hash names in some spots.  This
is now heavily deprecated.
d1510 2
a1511 2
names (like C<$A::B>).  You've exceeded Perl's limits.  Future
versions of Perl are likely to eliminate these arbitrary limitations.
d1513 1
a1513 1
=item Ill-formed CRTL environ value "%s"
d1515 1
a1515 3
(W internal) A warning peculiar to VMS.  Perl tried to read the CRTL's internal
environ array, and encountered an element without the C<=> delimiter
used to spearate keys from values.  The element is ignored.
d1517 1
a1517 1
=item Ill-formed message in prime_env_iter: |%s|
d1519 3
a1521 4
(W internal) A warning peculiar to VMS.  Perl tried to read a logical name
or CLI symbol definition when preparing to iterate over %ENV, and
didn't see the expected delimiter between key and value, so the
line was ignored.
d1526 4
a1529 4
would any other whitespace, which means you should never see this
error when Perl was built using standard options.  For some reason,
your version of Perl appears to have been built without this support.
Talk to your Perl administrator.
d1533 9
a1541 2
(F) You tried to divide a number by 0.  Either something was wrong in your
logic, or you need to put a conditional in to guard against meaningless input.
d1545 2
a1546 2
(F) You tried to divide a number by 0 to get the remainder.  Most numbers
don't take to this kindly.
d1548 1
a1548 1
=item Illegal binary digit %s
d1550 2
a1551 1
(F) You used a digit other than 0 or 1 in a binary number.
a1556 5
=item Illegal binary digit %s ignored

(W digit) You may have tried to use a digit other than 0 or 1 in a binary number.
Interpretation of the binary number stopped before the offending digit.

d1559 2
a1560 2
(W digit) You may have tried to use an 8 or 9 in a octal number.  Interpretation
of the octal number stopped before the 8 or 9.
d1562 4
a1565 1
=item Illegal hexadecimal digit %s ignored
d1567 1
a1567 3
(W digit) You may have tried to use a character other than 0 - 9 or A - F, a - f
in a hexadecimal number.  Interpretation of the hexadecimal number stopped
before the illegal character.
d1569 3
a1571 1
=item Illegal number of bits in vec
d1573 1
a1573 2
(F) The number of bits in vec() (the third argument) must be a power of
two from 1 to 32 (or 64, if your platform supports that).
d1575 4
a1578 1
=item Illegal switch in PERL5OPT: %s
d1580 1
a1580 2
(X) The PERL5OPT environment variable may only be used to set the
following switches: B<-[DIMUdmw]>.
d1582 5
a1586 1
=item In string, @@%s now must be written as \@@%s
d1588 2
a1589 7
(F) It used to be that Perl would try to guess whether you wanted an
array interpolated or a literal @@.  It did this when the string was first
used at runtime.  Now strings are parsed at compile time, and ambiguous
instances of @@ must be disambiguated, either by prepending a backslash to
indicate a literal, or by declaring (or using) the array within the
program before the string (lexically).  (Someday it will simply assume
that an unbackslashed @@ interpolates an array.)
d1594 6
a1599 6
The tainting mechanism is turned on when you're running setuid or setgid,
or when you specify B<-T> to turn it on explicitly.  The tainting mechanism
labels all data that's derived directly or indirectly from the user,
who is considered to be unworthy of your trust.  If any such data is
used in a "dangerous" operation, you get this error.  See L<perlsec>
for more information.
d1603 3
a1605 3
(F) You can't use system(), exec(), or a piped open in a setuid or setgid
script if C<$ENV{PATH}> contains a directory that is writable by the world.
See L<perlsec>.
d1617 4
a1620 4
(W overflow) The hexadecimal, octal or binary number you have specified either
as a literal or as an argument to hex() or oct() is too big for your
architecture, and has been converted to a floating point number.  On a
32-bit architecture the largest hexadecimal, octal or binary number
d1627 7
d1636 8
a1643 7
(S) A warning peculiar to VMS.  Perl keeps track of the number
of times you've called C<fork> and C<exec>, to determine
whether the current call to C<exec> should affect the current
script or a subprocess (see L<perlvms/"exec LIST">).  Somehow, this count
has become scrambled, so Perl is making a guess and treating
this C<exec> as a request to terminate the Perl script
and execute the specified command.
d1645 2
a1646 1
=item internal disaster in regexp
a1647 1
(P) Something went badly wrong in the regular expression parser.
d1649 1
a1649 1
=item internal urp in regexp at /%s/
d1651 4
a1654 1
(P) Something went badly awry in the regular expression parser.
d1663 7
a1669 2
The indicated attributes for a subroutine or variable were not recognized
by Perl or by a user-supplied handler.  See L<attributes>.
a1675 5
=item Invalid conversion in %s: "%s"

(W printf) Perl does not understand the given format conversion.
See L<perlfunc/sprintf>.

d1679 3
a1681 3
elements of an attribute list.  If the previous attribute
had a parenthesised parameter list, perhaps that list was terminated
too soon.  See L<attributes>.
d1686 2
a1687 2
(W pack) The given character is not a valid pack type but used to be silently
ignored.
d1691 4
a1694 3
(F) The given character is not a valid unpack type.  See L<perlfunc/unpack>.
(W unpack) The given character is not a valid unpack type but used to be silently
ignored.
d1701 10
d1717 3
a1719 3
(F) You named a loop to break out of, but you're not currently in a
loop of that name, not even if you count where you were called from.
See L<perlfunc/last>.
d1740 8
a1747 2
(W closed) You tried to do a listen on a closed socket.  Did you forget to check
the return value of your socket() call?  See L<perlfunc/listen>.
d1752 44
a1795 2
values cannot be returned in subroutines used in lvalue context.
See L<perlsub/"Lvalue subroutines">.
a1815 6
=item Missing $ on loop variable

(F) Apparently you've been programming in B<csh> too much.  Variables are always
mentioned with the $ in Perl, unlike in the shells, where it can vary from
one line to the next.

d1828 14
a1841 2
(W pipe) You used the C<open(FH, "| command")> or C<open(FH, "command |")>
construction, but the command was missing or blank.
d1850 9
a1858 3
(F) The lexer counted more opening curly or square brackets than
closing ones.  As a general rule, you'll find it's missing near the place
you were last editing.
d1871 9
a1879 1
=item Modification of non-creatable array value attempted, subscript %d
d1885 1
a1885 1
=item Modification of non-creatable hash value attempted, subscript "%s"
d1887 2
a1888 2
(P) You tried to make a hash value spring into existence, and it couldn't
be created for some peculiar reason.
d1894 6
d1906 19
a1924 2
(W syntax) Multidimensional arrays aren't written like C<$foo[1,2,3]>.  They're written
like C<$foo[1][2][3]>, as in C.
d1926 6
a1931 1
=item Missing name in "my sub"
d1933 3
a1935 2
(F) The reserved syntax for lexically scoped subroutines requires that they
have a name with which they can be found.
d1940 2
a1941 2
If you had a good reason for having a unique name, then just mention
it again somehow to suppress the message.  The C<our> declaration is
d1946 4
a1949 2
(F) You tried to do a read/write/send/recv operation with a buffer length
that is less than 0.  This is difficult to imagine.
d1951 3
a1953 1
=item nested *?+ in regexp
d1955 2
a1956 2
(F) You can't quantify a quantifier without intervening parentheses.  So
things like ** or +* or ?* are illegal.
a1957 2
Note, however, that the minimal matching quantifiers, C<*?>, C<+?>, and C<??> appear
to be nested quantifiers, but aren't.  See L<perlre>.
d1959 1
a1959 1
=item No #! line
d1961 2
a1962 2
(F) The setuid emulator requires that scripts have a well-formed #! line
even on machines that don't support the #! construct.
d1966 4
a1969 4
(F) Certain operations are deemed to be too insecure for a setuid or setgid
script to even be allowed to attempt.  Generally speaking there will be
another way to do what you want that is, if not secure, at least securable.
See L<perlsec>.
a1974 5
=item No %s specified for -%c

(F) The indicated command line switch needs a mandatory argument, but
you haven't specified one.

d1995 3
a1997 3
(F) An error peculiar to VMS.  Perl handles its own command line redirection,
and found a '|' at the end of the command line, so it doesn't know where you
want to pipe the output from this command.
d2001 5
a2005 6
(F) The currently executing code was compiled with the B<-d> switch,
but for some reason the perl5db.pl file (or some facsimile thereof)
didn't define a routine to be called at the beginning of each
statement.  Which is odd, because the file should have been required
automatically, and should have blown up the require if it didn't parse
right.
d2021 3
a2023 3
(F) An error peculiar to VMS.  Perl handles its own command line redirection,
and found a '2>' or a '2>>' on the command line, but can't find
the name of the file to which to write data destined for stderr.
d2027 13
a2039 3
(F) An error peculiar to VMS.  Perl handles its own command line redirection,
and found a '<' on the command line, but can't find the name of the file
from which to read data for stdin.
d2043 3
a2045 3
(F) An error peculiar to VMS.  Perl handles its own command line redirection,
and found a lone '>' at the end of the command line, so it doesn't know
where you wanted to redirect stdout.
d2049 3
a2051 3
(F) An error peculiar to VMS.  Perl handles its own command line redirection,
and found a '>' or a '>>' on the command line, but can't find the
name of the file to which to write data destined for stdout.
d2055 3
a2057 3
(F) Fully qualified variable names are not allowed in "our" declarations,
because that doesn't make much sense under existing semantics.  Such
syntax is reserved for future extensions.
d2076 13
a2088 2
(F) The argument to the indicated command line switch must follow immediately
after the switch, without intervening spaces.
d2098 4
a2101 10
(F) You tried to access a field of a typed variable where the type
does not know about the field name.  The field names are looked up in
the %FIELDS hash in the type package at compile time.  The %FIELDS hash
is usually set up with the 'fields' pragma.

=item No such pipe open

(P) An error peculiar to VMS.  The internal routine my_pclose() tried to
close a pipe which hadn't been opened.  This should have been caught earlier as
an attempt to close an unopened filehandle.
d2105 3
a2107 10
(W signal) You specified a signal name as a subscript to %SIG that was not recognized.
Say C<kill -l> in your shell to see the valid signal names on your system.

=item no UTC offset information; assuming local time is UTC

(S) A warning peculiar to VMS.  Perl was unable to find the local
timezone offset, so it's assuming that local system time is equivalent
to UTC.  If it's not, define the logical name F<SYS$TIMEZONE_DIFFERENTIAL>
to translate to the number of seconds which need to be added to UTC to
get local time.
d2113 2
a2114 2
use the ref() function to find out what kind of ref it really was.
See also L<perlref>.
d2123 4
a2126 4
(F) Perl was trying to evaluate a reference to a "typeglob" (that is,
a symbol table entry that looks like C<*foo>), but found a reference to
something else instead.  You can use the ref() function to find out
what kind of ref it really was.  See L<perlref>.
d2130 9
a2138 3
(F) Perl was trying to evaluate a reference to a hash value, but
found a reference to something else instead.  You can use the ref()
function to find out what kind of ref it really was.  See L<perlref>.
d2148 3
a2150 3
(F) Perl was trying to evaluate a reference to a scalar value, but
found a reference to something else instead.  You can use the ref()
function to find out what kind of ref it really was.  See L<perlref>.
d2156 2
a2157 2
use the ref() function to find out what kind of ref it really was.
See also L<perlref>.
a2163 6
=item Not an ARRAY reference

(F) Perl was trying to evaluate a reference to an array value, but
found a reference to something else instead.  You can use the ref()
function to find out what kind of ref it really was.  See L<perlref>.

d2170 16
a2185 2
(W syntax) A format specified more picture fields than the next line supplied.
See L<perlform>.
d2189 7
a2195 2
(F) You can't require the null filename, especially because on many machines
that means the current directory!  See L<perlfunc/require>.
a2202 4
=item NULL OP IN RUN

(P debugging) Some internal routine called run() with a null opcode pointer.

d2217 11
a2227 4
(F) Perl limits the representation of decimal numbers in programs to about
about 250 characters.  You've exceeded that length.  Future versions of
Perl are likely to eliminate this arbitrary limitation.  In the meantime,
try using scientific notation (e.g. "1e6" instead of "1_000_000").
d2231 3
a2233 3
(W portable) The octal number you specified is larger than 2**32-1 (4294967295)
and therefore non-portable between systems.  See L<perlport> for more
on portability concerns.
d2237 1
a2237 1
=item Octal number in vector unsupported
d2239 2
a2240 3
(F) Numbers with a leading C<0> are not currently allowed in vectors.  The
octal number interpretation of such numbers may be supported in a future
version.
d2244 2
a2245 2
(W misc) You specified an odd number of elements to initialize a hash, which
is odd, because hashes come in key/value pairs.
d2250 14
a2263 3
pointing outside the buffer.  This is difficult to imagine.
The sole exception to this is that C<sysread()>ing past the buffer
will extend the buffer and zero pad the new area.
d2275 4
a2278 5
(F) An attempt was made to perform an overloaded operation for which
no handler was defined.  While some handlers can be autogenerated in
terms of other handlers, there is no default handler for any
operation, unless C<fallback> overloading key is specified to be
true.  See L<overload>.
d2282 10
a2291 5
(S ambiguous) You used a variable or subroutine call where the parser was
expecting an operator.  The parser has assumed you really meant
to use an operator, but this is highly likely to be incorrect.
For example, if you say "*foo *foo" it will be interpreted as
if you said "*foo * 'foo'".
d2296 2
a2297 2
remaining memory (or virtual memory) to satisfy the request.  Perl
has no option but to exit immediately.
d2299 1
a2299 1
=item Out of memory for yacc stack
d2301 4
a2304 2
(F) The yacc parser wanted to grow its stack so it could continue parsing,
but realloc() wouldn't give it more memory, virtual or otherwise.
d2308 3
a2310 2
(X|F) The malloc() function returned 0, indicating there was insufficient
remaining memory (or virtual memory) to satisfy the request.
d2314 4
a2317 3
However, if compiled for this, Perl may use the contents of C<$^M> as
an emergency pool after die()ing with this message.  In this case the
error is trappable I<once>.
d2319 13
a2331 1
=item Out of memory during "large" request for %s
d2333 2
a2334 4
(F) The malloc() function returned 0, indicating there was insufficient
remaining memory (or virtual memory) to satisfy the request. However,
the request was judged large enough (compile-time default is 64K), so
a possibility to shut down by trapping this error is granted.
d2336 1
a2336 1
=item Out of memory during ridiculously large request
d2338 4
a2341 3
(F) You can't allocate more than 2^31+"small amount" bytes.  This error
is most likely to be caused by a typo in the Perl program. e.g., C<$arr[time]>
instead of C<$arr[$time]>.
d2345 6
a2350 2
(W io) A single call to write() produced more lines than can fit on a page.
See L<perlform>.
d2362 2
a2363 2
(P) The savestack was requested to restore more localized values than there
are in the savestack.
d2375 1
a2375 1
=item panic: do_match
d2377 2
a2378 5
(P) The internal pp_match() routine was called with invalid operational data.

=item panic: do_split

(P) Something terrible went wrong in setting up for the split.
d2382 2
a2383 1
(P) The internal pp_subst() routine was called with invalid operational data.
d2385 1
a2385 1
=item panic: do_trans
d2387 2
a2388 1
(P) The internal do_trans() routine was called with invalid operational data.
d2418 2
a2419 1
(P) A writable lexical variable became read-only somehow within the scope.
a2425 4
=item panic: malloc

(P) Something requested a negative number of bytes of malloc.

d2431 4
d2479 4
d2514 1
a2514 1
=item panic: %s
d2516 2
a2517 1
(P) An internal error.
d2531 21
a2551 1
=item Perl %3.3f required--this is only version %s, stopped
d2553 10
a2562 3
(F) The module in question uses features of a version of Perl more recent
than the currently running version.  How long has it been since you upgraded,
anyway?  See L<perlfunc/require>.
d2570 32
a2601 3
(W exec) A warning peculiar to VMS.  Waitpid() was asked to wait for a process which
isn't a subprocess of the current process.  While this is fine from VMS'
perspective, it's probably not what you intended.
a2607 5
=item Possible Y2K bug: %s

(W y2k) You are concatenating the number 19 with another number, which
could be a potential Year 2000 problem.

d2611 2
a2612 2
strings, comment characters are not ignored, but are instead treated
as literal data.  (You may have used different delimiters than the
d2639 4
a2642 4
(W qw) qw() lists contain items separated by whitespace; therefore commas
aren't needed to separate the items.  (You may have used different
delimiters than the parentheses shown here; braces are also frequently
used.)
d2660 5
d2667 1
a2667 1
(W deprecated) You have written somehing like this:
d2693 4
a2696 4
because of the strict regularization of Perl 5's grammar into unary
and list operators.  (The old open was a little of both.)  You must
put parentheses around the filehandle, or use the new "or" operator
instead of "||".
d2702 5
d2709 12
a2720 4
(W closed) The filehandle you're printing on got itself closed sometime before now.
Check your logic flow.

=item printf() on closed filehandle %s
d2722 2
a2723 2
(W closed) The filehandle you're writing to got itself closed sometime before now.
Check your logic flow.
d2725 1
a2725 1
=item Prototype mismatch: %s vs %s
d2727 11
a2737 2
(S unsafe) The subroutine being declared or defined had previously been declared
or defined with a different function prototype.
d2743 2
a2744 2
One possible workaround is to force Perl to use magical string
increment by prepending "0" to your numbers.
d2748 2
a2749 2
(W closed) The filehandle you're reading from got itself closed sometime before now.
Check your logic flow.
d2751 1
a2751 1
=item realloc() of freed memory ignored
d2753 1
a2753 2
(S malloc) An internal routine called realloc() on something that had already
been freed.
d2755 1
a2755 1
=item Reallocation too large: %lx
d2757 2
a2758 1
(F) You can't allocate more than 64K on an MS-DOS machine.
d2762 2
a2763 2
(F debugging) You can't use the B<-D> option unless the code to produce the
desired output is compiled into Perl, which entails some overhead,
d2771 1
a2771 1
=item Recursive inheritance detected while looking for method '%s' in package '%s'
d2773 3
a2775 2
(F) More than 100 levels of inheritance were encountered while invoking a
method.  Probably indicates an unintended loop in your inheritance hierarchy.
d2779 4
a2782 4
(W misc) You gave a single reference where Perl was expecting a list with
an even number of elements (for assignment to a hash). This
usually means that you used the anon hash constructor when you meant 
to use parens. In any case, a hash requires key/value B<pairs>.
d2796 2
a2797 2
(W internal) The internal sv_replace() function was handed a new SV with a
reference count of other than 1.
d2799 1
a2799 1
=item regexp *+ operand could be empty
d2801 7
a2807 2
(F) The part of the regexp subject to either the * or + quantifier
could match an empty string.
d2814 1
a2814 1
=item regexp out of space
d2816 2
a2817 1
(P) A "can't happen" error, because safemalloc() should have caught it earlier.
d2821 2
a2822 2
(F) You can't specify a repeat count so large that it overflows
your signed integers.  See L<perlfunc/pack>.
d2826 2
a2827 2
(F) You can't specify a repeat count so large that it overflows
your signed integers.  See L<perlfunc/unpack>.
d2831 2
a2832 2
(W syntax) You wrote your assignment operator backwards.  The = must always
comes last, to avoid ambiguity with subsequent unary operators.
d2844 7
a2850 6
(W syntax) You've used an array slice (indicated by @@) to select a single element of
an array.  Generally it's better to ask for a scalar value (indicated by $).
The difference is that C<$foo[&bar]> always behaves like a scalar, both when
assigning to it and when evaluating its argument, while C<@@foo[&bar]> behaves
like a list when you assign to it, and provides a list context to its
subscript, which can do weird things if you're expecting only one subscript.
d2859 14
a2872 6
(W syntax) You've used a hash slice (indicated by @@) to select a single element of
a hash.  Generally it's better to ask for a scalar value (indicated by $).
The difference is that C<$foo{&bar}> always behaves like a scalar, both when
assigning to it and when evaluating its argument, while C<@@foo{&bar}> behaves
like a list when you assign to it, and provides a list context to its
subscript, which can do weird things if you're expecting only one subscript.
d2874 4
a2877 4
On the other hand, if you were actually hoping to treat the hash
element as a list, you need to look into how references work, because
Perl will not magically convert between scalars and lists for you.  See
L<perlref>.
d2890 1
a2890 1
=item %sseek() on unopened file
d2892 2
a2893 2
(W unopened) You tried to use the seek() or sysseek() function on a filehandle that
was either never opened or has since been closed.
d2899 1
a2899 1
=item sem%s not implemented
d2901 2
a2902 1
(F) You don't have System V semaphore IPC on your system.
d2906 2
a2907 2
(S internal) The internal newSVsv() routine was called to duplicate a scalar
that had previously been marked as free.
d2909 1
a2909 1
=item Semicolon seems to be missing
d2911 1
a2911 2
(W semicolon) A nearby syntax error was probably caused by a missing semicolon,
or possibly some other missing operator, such as a comma.
d2915 2
a2916 2
(W closed) The socket you're sending to got itself closed sometime before now.
Check your logic flow.
d2918 1
a2918 1
=item Sequence (? incomplete
d2920 3
a2922 2
(F) A regular expression ended with an incomplete extension (?.
See L<perlre>.
d2924 1
a2924 1
=item Sequence (?#... not terminated
d2926 2
a2927 2
(F) A regular expression comment must be terminated by a closing
parenthesis.  Embedded parentheses aren't allowed.  See L<perlre>.
d2929 1
a2929 1
=item Sequence (?%s...) not implemented
d2931 3
a2933 2
(F) A proposed regular expression extension has the character reserved
but has not yet been written.  See L<perlre>.
d2935 1
a2935 1
=item Sequence (?%s...) not recognized
d2938 2
d2942 9
d2954 5
a2958 5
to run a CGI program (including SSI) over the web. The actual error
text varies widely from server to server. The most frequently-seen
variants are "500 Server error", "Method (something) not permitted",
"Document contains no data", "Premature end of script headers", and
"Did not produce a valid header".
d2962 6
a2967 6
You need to make sure your script is executable, is accessible by the user
CGI is running the script under (which is probably not the user account you
tested it under), does not rely on any environment variables (like PATH)
from the user it isn't running under, and isn't in a location where the CGI
server can't find it, basically, more or less.  Please see the following
for more information:
d2979 3
a2981 3
(F) You tried to assign to C<$)>, and your operating system doesn't support
the setegid() system call (or equivalent), or at least Configure didn't
think so.
d2985 3
a2987 3
(F) You tried to assign to C<< $> >>, and your operating system doesn't support
the seteuid() system call (or equivalent), or at least Configure didn't
think so.
d2991 3
a2993 2
(F) Your system has the setpgrp() from BSD 4.2, which takes no arguments,
unlike POSIX setpgid(), which takes a process ID and process group ID.
d2997 3
a2999 3
(F) You tried to assign to C<$(>, and your operating system doesn't support
the setrgid() system call (or equivalent), or at least Configure didn't
think so.
d3003 9
a3011 3
(F) You tried to assign to C<$<>, and your operating system doesn't support
the setruid() system call (or equivalent), or at least Configure didn't
think so.
d3015 2
a3016 2
(F) The setuid emulator won't run a script that is writable by the world,
because the world might have written on it already.
d3022 12
d3036 2
a3037 1
(W closed) You tried to do a shutdown on a closed socket.  Seems a bit superfluous.
d3041 2
a3042 2
(W signal) The signal handler named in %SIG doesn't, in fact, exist.  Perhaps you
put it into the wrong package?
d3062 11
a3072 3
(P) The split was looping infinitely.  (Obviously, a split shouldn't iterate
more times than there are characters of input, which is what happened.)
See L<perlfunc/split>.
d3074 1
a3074 1
=item Stat on unopened file <%s>
d3076 2
a3077 2
(W unopened) You tried to use the stat() function (or an equivalent file test)
on a filehandle that was either never opened or has since been closed.
d3079 1
a3079 1
=item Statement unlikely to be reached
d3081 3
a3083 19
(W exec) You did an exec() with some statement after it other than a die().
This is almost always an error, because exec() never returns unless
there was a failure.  You probably wanted to use system() instead,
which does return.  To suppress this warning, put the exec() in a block
by itself.

=item Strange *+?{} on zero-length expression

(W regexp) You applied a regular expression quantifier in a place where it
makes no sense, such as on a zero-width assertion.
Try putting the quantifier inside the assertion instead.  For example,
the way to match "abc" provided that it is followed by three
repetitions of "xyz" is C</abc(?=(?:xyz){3})/>, not C</abc(?=xyz){3}/>.

=item Stub found while resolving method `%s' overloading `%s' in package `%s'

(P) Overloading resolution over @@ISA tree may be broken by importation stubs.
Stubs should never be implicitely created, but explicit calls to C<can>
may break this.
d3096 3
a3098 3
(P) The substitution was looping infinitely.  (Obviously, a
substitution shouldn't iterate more times than there are characters of
input, which is what happened.)  See the discussion of substitution in
d3115 5
a3119 5
(W substr),(F) You tried to reference a substr() that pointed outside of a
string.  That is, the absolute value of the offset was larger than the
length of the string.  See L<perlfunc/substr>.  This warning is
fatal if substr is used in an lvalue context (as the left hand side
of an assignment or as a subroutine argument for example).
d3123 20
a3142 2
(F) Your Perl was compiled with B<-D>SETUID_SCRIPTS_ARE_SECURE_NOW, but a
version of the setuid emulator somehow got run anyway.
d3146 2
a3147 2
(F) While under the C<use filetest> pragma, we cannot switch the
real and effective uids or gids.
d3168 2
a3169 1
if the error went away.  Sort of the cybernetic version of S<20 questions>.
d3173 7
a3179 3
(A) You've accidentally run your script through the Bourne shell
instead of Perl.  Check the #! line, or manually feed your script
into Perl yourself.
d3190 2
a3191 2
(W closed) The filehandle you're writing to got itself closed sometime before now.
Check your logic flow.
d3195 2
a3196 2
(F) You tried to use C<goto> to reach a label that was too deeply
nested for Perl to reach.  Perl is doing you a favor by refusing.
d3198 1
a3198 1
=item tell() on unopened file
d3200 2
a3201 7
(W unopened) You tried to use the tell() function on a filehandle that was either
never opened or has since been closed.

=item Test on unopened file <%s>

(W unopened) You tried to invoke a file test operator on a filehandle that isn't
open.  Check your logic.  See also L<perlfunc/-X>.
d3205 2
a3206 2
(F) Assignment to C<$[> is now strictly circumscribed, and interpreted as
a compiler directive.  You may say only one of
d3215 2
a3216 7
This is to prevent the problem of one module changing the array base
out from under another module inadvertently.  See L<perlvar/$[>.

=item The %s function is unimplemented

The function indicated isn't implemented on this architecture, according
to the probings of Configure.
d3226 5
d3233 4
a3236 3
(F) It makes no sense to test the current stat buffer for symbolic linkhood
if the last stat that wrote to the stat buffer already went past
the symlink to get to the real file.  Use an actual filename instead.
d3242 6
a3247 5
(W internal) Warnings peculiar to VMS.  You tried to change or delete an element
of the CRTL's internal environ array, but your copy of Perl wasn't
built with a CRTL that contained the setenv() function.  You'll need to
rebuild Perl with a CRTL that does, or redefine F<PERL_ENV_TABLES> (see
L<perlvms>) so that the environ array isn't the target of the change to
d3252 2
a3253 2
(F) Your version of the C library apparently doesn't do times().  I suspect
you're not running on Unix.
d3269 3
a3271 3
mechanism (or its local equivalent), this error can usually be fixed
by editing the #! line so that the B<-T> option is a part of Perl's
first argument: e.g. change C<perl -n -T> to C<perl -T -n>.
d3286 3
a3288 11
loading a file with C<require> or C<do> when you should be using
C<use> instead.  Or perhaps you should put the C<require> or C<do>
inside a BEGIN block.

=item Too many ('s

=item Too many )'s

(A) You've accidentally run your script through B<csh> instead
of Perl.  Check the #! line, or manually feed your script into
Perl yourself.
d3298 7
d3307 2
a3308 2
(F) The regular expression ends with an unbackslashed backslash.  Backslash
it.   See L<perlre>.
d3340 2
a3341 2
(F) Your machine doesn't implement the umask function and you tried
to use it to restrict permissions for yourself (EXPR & 0700).
d3349 2
a3350 2
(W internal) The exit code detected an internal inconsistency in how many execution
contexts were entered and left.
d3354 2
a3355 2
(W internal) The exit code detected an internal inconsistency in how many
values were temporarily localized.
d3359 2
a3360 2
(W internal) The exit code detected an internal inconsistency in how many blocks
were entered and left.
d3364 2
a3365 2
(W internal) The exit code detected an internal inconsistency in how many mortal
scalars were allocated and freed.
d3374 2
a3375 2
(F) The sort comparison routine specified doesn't seem to exist.  Perhaps
it's in a different package?  See L<perlfunc/sort>.
d3379 2
a3380 2
(F) The subroutine indicated hasn't been defined, or if it was, it
has since been undefined.
d3389 2
a3390 2
(F) The sort comparison routine specified is declared but doesn't seem to
have been defined yet.  See L<perlfunc/sort>.
d3399 8
a3406 2
(W misc) An undefined value was assigned to a typeglob, a la C<*foo = undef>.
This does nothing.  It's possible that you really mean C<undef *foo>.
d3413 1
d3416 13
a3428 1
(F) There are no byte-swapping functions for a machine with this byte order.
d3443 8
a3450 1
=item unmatched () in regexp
d3453 2
a3454 2
expressions.  If you're a vi user, the % key is valuable for finding
the matching parenthesis.  See L<perlre>.
d3458 4
a3461 10
(F) The lexer counted more closing curly or square brackets than
opening ones, so you're probably missing a matching opening bracket.
As a general rule, you'll find the missing one (so to speak) near the
place you were last editing.

=item unmatched [] in regexp

(F) The brackets around a character class must match.  If you wish to
include a closing bracket in a character class, backslash it or put it first.
See L<perlre>.
d3465 4
a3468 3
(W reserved) You used a bareword that might someday be claimed as a reserved word.
It's best to put such a word in quotes, or capitalize it somehow, or insert
an underbar into it.  You might also declare it as a subroutine.
d3476 15
d3493 2
a3494 2
(W misc) You used a backslash-character combination which is not recognized
by Perl.
d3498 3
a3500 2
(F) You specified a signal name to the kill() function that was not recognized.
Say C<kill -l> in your shell to see the valid signal names on your system.
d3504 3
a3506 3
(F) You specified an illegal option to Perl.  Don't do that.
(If you think you didn't do that, check the #! line to see if it's
supplying the bad switch on your behalf.)
d3510 3
a3512 3
(W newline) A file operation was attempted on a filename, and that operation
failed, PROBABLY because the filename contained a newline, PROBABLY
because you forgot to chop() or chomp() it off.  See L<perlfunc/chomp>.
d3518 5
d3527 3
a3529 3
Note that under some systems, like OS/2, there may be different flavors of
Perl executables, some of which may support fork, some not. Try changing
the name you call Perl by to C<perl_>, C<perl__>, and so on.
d3531 1
a3531 1
=item Unsupported function %s
d3533 2
a3534 2
(F) This machine doesn't implement the indicated function, apparently.
At least, Configure doesn't think so.
d3541 1
a3541 1
=item Unterminated <> operator
d3543 4
a3546 4
(F) The lexer saw a left angle bracket in a place where it was expecting
a term, so it's looking for the corresponding right angle bracket, and not
finding it.  Chances are you left some needed parentheses out earlier in
the line, and you really meant a "less than".
d3550 2
a3551 2
(F) The lexer saw an opening (left) parenthesis character while parsing an
attribute list, but the matching closing (right) parenthesis
d3555 14
a3568 1
=item Unterminated attribute list
d3570 2
a3571 4
(F) The lexer found something other than a simple identifier at the start
of an attribute, and it wasn't a semicolon or the start of a
block.  Perhaps you terminated the parameter list of the previous attribute
too soon.  See L<attributes>.
d3573 1
a3573 1
=item Use of $# is deprecated
d3575 7
a3581 2
(D deprecated) This was an ill-advised attempt to emulate a poorly defined B<awk> feature.
Use an explicit printf() or sprintf() instead.
d3583 1
a3583 1
=item Use of $* is deprecated
d3585 1
a3585 4
(D deprecated) This variable magically turned on multi-line pattern matching, both for
you and for any luckless subroutine that you happen to call.  You should
use the new C<//m> and C<//s> modifiers now to do that without the dangerous
action-at-a-distance effects of C<$*>.
d3587 1
a3587 1
=item Use of %s in printf format not supported
d3589 3
a3591 2
(F) You attempted to use a feature of printf that is accessible from
only C.  This usually means there's a better way to do it in Perl.
d3593 1
a3593 1
=item Use of bare << to mean <<"" is deprecated
d3595 1
a3595 2
(D deprecated) You are now encouraged to use the explicitly quoted form if you
wish to use an empty line as the terminator of the here-document.
d3597 1
a3597 1
=item Use of implicit split to @@_ is deprecated
d3599 5
a3603 3
(D deprecated) It makes a lot of work for the compiler when you clobber a
subroutine's argument list, so it's better if you assign the results of
a split() explicitly to an array (or list).
d3605 1
a3605 1
=item Use of inherited AUTOLOAD for non-method %s() is deprecated
d3607 1
a3607 10
(D deprecated) As an (ahem) accidental feature, C<AUTOLOAD> subroutines are
looked up as methods (using the C<@@ISA> hierarchy) even when the subroutines
to be autoloaded were called as plain functions (e.g.  C<Foo::bar()>),
not as methods (e.g. C<< Foo->bar() >> or C<< $obj->bar() >>).

This bug will be rectified in Perl 5.005, which will use method lookup
only for methods' C<AUTOLOAD>s.  However, there is a significant base
of existing code that may be using the old behavior.  So, as an
interim step, Perl 5.004 issues an optional warning when non-methods
use inherited C<AUTOLOAD>s.
d3609 1
a3609 4
The simple rule is:  Inheritance will not work when autoloading
non-methods.  The simple fix for old code is:  In any module that used to
depend on inheriting C<AUTOLOAD> for non-methods from a base class named
C<BaseClass>, execute C<*AUTOLOAD = \&BaseClass::AUTOLOAD> during startup.
d3611 2
a3612 3
In code that currently says C<use AutoLoader; @@ISA = qw(AutoLoader);> you
should remove AutoLoader from @@ISA and change C<use AutoLoader;> to
C<use AutoLoader 'AUTOLOAD';>.
d3614 1
a3614 1
=item Use of reserved word "%s" is deprecated
d3616 2
a3617 6
(D deprecated) The indicated bareword is a reserved word.  Future versions of perl
may use it as a keyword, so you're better off either explicitly quoting
the word in a manner appropriate for its context of use, or using a
different name altogether.  The warning can be suppressed for subroutine
names by either adding a C<&> prefix, or using a package qualifier,
e.g. C<&our()>, or C<Foo::our()>.
d3619 1
a3619 1
=item Use of %s is deprecated
d3621 3
a3623 3
(D deprecated) The construct indicated is no longer recommended for use, generally
because there's a better way to do it, and also because the old way has
bad side effects.
d3625 1
a3625 1
=item Use of uninitialized value%s
d3627 11
a3637 3
(W uninitialized) An undefined value was used as if it were already defined.  It was
interpreted as a "" or a 0, but maybe it was a mistake.  To suppress this
warning assign a defined value to your variables.
d3639 5
a3643 1
=item Useless use of "re" pragma
d3645 3
a3647 1
(W) You did C<use re;> without any arguments.   That isn't very useful.
d3649 1
a3649 1
=item Useless use of %s in void context
d3651 2
a3652 6
(W void) You did something without a side effect in a context that does nothing
with the return value, such as a statement that doesn't return a value
from a block, or the left side of a scalar comma operator.  Very often
this points not to stupidity on your part, but a failure of Perl to parse
your program the way you thought it would.  For example, you'd get this
if you mixed up your C precedence with Python precedence and said
d3654 1
a3654 1
    $one, $two = 1, 2;
d3656 4
a3659 1
when you meant to say
d3661 1
a3661 1
    ($one, $two) = (1, 2);
d3663 3
a3665 3
Another common error is to use ordinary parentheses to construct a list
reference when you should be using square or curly brackets, for
example, if you say
d3667 1
a3667 1
    $array = (1,2);
d3669 2
a3670 1
when you should have said
d3672 1
a3672 1
    $array = [1,2];
d3674 6
a3679 5
The square brackets explicitly turn a list value into a scalar value,
while parentheses do not.  So when a parenthesized list is evaluated in
a scalar context, the comma is treated like C's comma operator, which
throws away the left argument, which is not what you want.  See
L<perlref> for more on this.
d3681 1
a3681 1
=item untie attempted while %d inner references still exist
d3683 11
a3693 2
(W untie) A copy of the object returned from C<tie> (or C<tied>) was still
valid when C<untie> was called.
d3697 6
a3702 5
(W misc) In a conditional expression, you used <HANDLE>, <*> (glob), C<each()>,
or C<readdir()> as a boolean value.  Each of these constructs can return a
value of "0"; that would make the conditional expression false, which is
probably not what you intended.  When using these constructs in conditional
expressions, test their values with the C<defined> operator.
d3706 4
a3709 4
(W misc) A warning peculiar to VMS.  Perl tried to read the value of an %ENV
element from a CLI symbol table, and found a resultant string longer
than 1024 characters.  The return value has been truncated to 1024
characters.
d3713 13
a3725 5
(F) While "use strict" in effect, you referred to a global variable
that you apparently thought was imported from another module, because
something else of the same name (usually a subroutine) is exported
by that module.  It usually means you put the wrong funny character
on the front of your variable.
d3729 4
a3732 4
(W closure) An inner (nested) I<anonymous> subroutine is inside a I<named>
subroutine, and outside that is another subroutine; and the anonymous
(innermost) subroutine is referencing a lexical variable defined in
the outermost subroutine.  For example:
d3737 16
a3752 11
indirectly) from the outermost subroutine, it will share the variable
as you would expect.  But if the anonymous subroutine is called or
referenced when the outermost subroutine is not active, it will see
the value of the shared variable as it was before and during the
*first* call to the outermost subroutine, which is probably not what
you want.

In these circumstances, it is usually best to make the middle
subroutine anonymous, using the C<sub {}> syntax.  Perl has specific
support for shared variables in nested anonymous subroutines; a named
subroutine in between interferes with this feature.
d3756 2
a3757 2
(W closure) An inner (nested) I<named> subroutine is referencing a lexical
variable defined in an outer subroutine.
d3760 5
a3764 5
the outer subroutine's variable as it was before and during the
*first* call to the outer subroutine; in this case, after the first
call to the outer subroutine is complete, the inner and outer
subroutines will no longer share a common value for the variable.  In
other words, the variable will no longer be shared.
d3772 2
a3773 3
reference variables in outer subroutines are called or referenced,
they are automatically rebound to the current values of such
variables.
d3775 1
a3775 1
=item Variable syntax
d3777 3
a3779 3
(A) You've accidentally run your script through B<csh> instead
of Perl.  Check the #! line, or manually feed your script into
Perl yourself.
a3786 21
=item perl: warning: Setting locale failed.

(S) The whole warning message will look something like:

	perl: warning: Setting locale failed.
	perl: warning: Please check that your locale settings:
	        LC_ALL = "En_US",
	        LANG = (unset)
	    are supported and installed on your system.
	perl: warning: Falling back to the standard locale ("C").

Exactly what were the failed locale settings varies.  In the above the
settings were that the LC_ALL was "En_US" and the LANG had no value.
This error means that Perl detected that you and/or your system
administrator have set up the so-called variable system but Perl could
not use those settings.  This was not dead serious, fortunately: there
is a "default locale" called "C" that Perl can and will use, the
script will be run.  Before you really fix the problem, however, you
will get the same error message each time you run Perl.  How to really
fix the problem can be found in L<perllocale> section B<LOCALE PROBLEMS>.

d3794 3
a3796 2
(S) The implicit close() done by an open() got an error indication on the
close().  This usually indicates your file system ran out of disk space.
d3800 4
a3803 4
(S ambiguous) You wrote a unary operator followed by something that looks like a
binary operator that could also have been interpreted as a term or
unary operator.  For instance, if you know that the rand function
has a default argument of 1.0, and you write
d3817 4
d3823 2
a3824 2
(W closed) The filehandle you're writing to got itself closed sometime before now.
Check your logic flow.
d3838 2
a3839 1
(F) The use of an external subroutine as a sort comparison is not yet supported.
d3843 2
a3844 1
(F) The use of an external subroutine as a sort comparison is not yet supported.
d3848 2
a3849 2
(F) A filehandle represents an opened file, and when you opened the file it
already went past any symlink you are presumably trying to look for.
d3856 2
a3857 2
about what you want.  Your best bet is to use the wrapsuid script in
the eg directory to put a setuid C wrapper around your script.
d3861 5
a3865 72
(W syntax) You assigned a bareword as a signal handler name.  Unfortunately, you
already have a subroutine of that name declared, which means that Perl 5
will try to call the subroutine when the assignment is executed, which is
probably not what you want.  (If it IS what you want, put an & in front.)

=item %cetsockopt() on closed socket %s

(W closed) You tried to get or set a socket option on a closed socket.
Did you forget to check the return value of your socket() call?
See L<perlfunc/getsockopt> and L<perlfunc/setsockopt>.

=item \1 better written as $1

(W syntax) Outside of patterns, backreferences live on as variables.  The use
of backslashes is grandfathered on the right-hand side of a
substitution, but stylistically it's better to use the variable form
because other Perl programmers will expect it, and it works better
if there are more than 9 backreferences.

=item '|' and '<' may not both be specified on command line

(F) An error peculiar to VMS.  Perl does its own command line redirection, and
found that STDIN was a pipe, and that you also tried to redirect STDIN using
'<'.  Only one STDIN stream to a customer, please.

=item '|' and '>' may not both be specified on command line

(F) An error peculiar to VMS.  Perl does its own command line redirection, and
thinks you tried to redirect stdout both to a file and into a pipe to another
command.  You need to choose one or the other, though nothing's stopping you
from piping into a program or Perl script which 'splits' output into two
streams, such as

    open(OUT,">$ARGV[0]") or die "Can't write to $ARGV[0]: $!";
    while (<STDIN>) {
        print;
        print OUT;
    }
    close OUT;

=item Got an error from DosAllocMem

(P) An error peculiar to OS/2.  Most probably you're using an obsolete
version of Perl, and this should not happen anyway.

=item Malformed PERLLIB_PREFIX

(F) An error peculiar to OS/2.  PERLLIB_PREFIX should be of the form

    prefix1;prefix2

or

    prefix1 prefix2

with nonempty prefix1 and prefix2.  If C<prefix1> is indeed a prefix
of a builtin library search path, prefix2 is substituted.  The error
may appear if components are not found, or are too long.  See
"PERLLIB_PREFIX" in F<README.os2>.

=item PERL_SH_DIR too long

(F) An error peculiar to OS/2. PERL_SH_DIR is the directory to find the
C<sh>-shell in.  See "PERL_SH_DIR" in F<README.os2>.

=item Process terminated by SIG%s

(W) This is a standard message issued by OS/2 applications, while *nix
applications die in silence.  It is considered a feature of the OS/2
port.  One can easily disable this by appropriate sighandlers, see
L<perlipc/"Signals">.  See also "Process terminated by SIGTERM/SIGINT"
in F<README.os2>.
@


1.3
log
@perl5.005_03 (stock)
@
text
@d12 1
a12 1
    (S) A severe warning (mandatory).
d18 15
a32 3
Optional warnings are enabled by using the B<-w> switch.  Warnings may
be captured by setting C<$SIG{__WARN__}> to a reference to a routine that
will be called on each warning instead of printing it.  See L<perlvar>.
d34 3
a36 1
L<perlfunc/eval>.
d40 2
a41 1
The symbols C<"%(-?@@> sort before the letters, while C<[> and C<\> sort after.
d45 13
a63 8
=item "my" variable %s masks earlier declaration in same %s

(W) A lexical variable has been redeclared in the current scope or statement,
effectively eliminating all access to the previous instance.  This is almost
always a typographical error.  Note that the earlier variable will still exist
until the end of the scope or until all closure referents to it are
destroyed.

d69 5
d79 30
d115 18
d135 1
a135 1
(W) You've run afoul of the rule that says that any list operator followed
d139 11
a149 1
=item %s argument is not a HASH element
d151 1
a151 1
(F) The argument to exists() must be a hash element, such as
d154 1
a154 1
    $ref->[12]->{"susie"}
d156 1
a156 1
=item %s argument is not a HASH element or slice
d158 1
a158 1
(F) The argument to delete() must be either a hash element, such as
d161 1
a161 1
    $ref->[12]->{"susie"}
d163 1
a163 1
or a hash slice, such as
d165 1
a165 1
    @@foo{$bar, $baz, $xyzzy}
d168 5
d198 1
a198 1
(W) The pattern you've specified would be an infinite loop if the
d203 1
a203 1
(S) The symbol in question was declared but somehow went out of scope
d206 7
d241 1
a241 1
=item         (in cleanup) %s
d243 1
a243 1
(W) This prefix usually indicates that a DESTROY() method raised
d253 1
a253 1
=item         (Missing semicolon on previous line?)
d289 1
a289 1
=item accept() on closed fd
d291 6
a296 1
(W) You tried to do an accept on a closed socket.  Did you forget to check
d305 1
a305 1
(W) The pattern match (//), substitution (s///), and transliteration (tr///)
d318 1
a318 1
(W)(S) You said something that may not be interpreted the way
d324 1
a324 1
(W) A subroutine you have declared has the same name as a Perl keyword,
d336 2
a337 1
to be an object method (see L<attrs>).
d348 1
a348 1
(W) The indicated string was fed as an argument to an operator that
d354 1
a354 1
(D) Really old Perl let you omit the @@ on array names in some spots.  This
d373 1
a373 1
(P) All SV objects are supposed to be allocated from arenas that will
d379 1
a379 1
(P) Perl maintains a reference counted internal table of strings to
d386 1
a386 1
(W) Mortalized values are supposed to be freed by the free_tmps()
d394 1
a394 1
(P) The reference counts got screwed up on symbol aliases.
d398 1
a398 1
(W) Perl went to decrement the reference count of a scalar to see if it
d405 6
d413 1
a413 1
(W) You tried to pass a temporary value (like the result of a
d422 1
a422 1
(W) You supplied a reference as the first argument to substr() used
d433 6
d447 1
a447 1
(S) An internal routine called free() on something that had never been
d480 6
d515 1
a515 1
(W) You used a qualified bareword of the form C<Foo::>, but
d519 16
d548 7
a554 1
=item bind() on closed fd
d556 1
a556 1
(W) You tried to do a bind on a closed socket.  Did you forget to check
d559 4
d567 6
d575 1
a575 1
(F) A subroutine invoked from an external package via perl_call_sv()
d578 1
a578 1
=item Can't "goto" outside a block
d590 1
a590 1
=item Can't "last" outside a block
d595 4
a598 3
"loopish" block, as doesn't a block given to sort().  You can usually double
the curlies to get the same effect though, because the inner curlies
will be considered a block that loops once.  See L<perlfunc/last>.
d600 1
a600 1
=item Can't "next" outside a block
d604 11
a614 3
count as a "loopish" block, as doesn't a block given to sort().  You can
usually double the curlies to get the same effect though, because the inner
curlies will be considered a block that loops once.  See L<perlfunc/next>.
d616 1
a616 1
=item Can't "redo" outside a block
d620 4
a623 3
count as a "loopish" block, as doesn't a block given to sort().  You can
usually double the curlies to get the same effect though, because the inner
curlies will be considered a block that loops once.  See L<perlfunc/redo>.
d632 1
a632 1
(S) A warning intended to only be printed while running within the debugger, indicating
d715 5
a719 1
=item Can't declare %s in my
d721 4
a724 2
(F) Only scalar, array, and hash variables may be declared as lexical variables.
They must have ordinary identifiers as names.
d728 1
a728 1
(S) The creation of the new file failed for the indicated reason.
d736 1
a736 1
=item Can't do inplace edit: %s E<gt> 14 characters
d738 3
a740 1
(S) There isn't enough room in the filename to make a backup name for the file.
d744 1
a744 1
(S) You tried to use the B<-i> switch on a special file, such as a file in
d770 1
a770 1
=item Can't do {n,m} with n E<gt> m
d782 1
a782 1
(W) An system(), exec(), or piped open call could not execute the named
d871 9
d896 1
a896 1
(F) You said something like C<local $ar-E<gt>{'key'}>, where $ar is
d899 1
a899 1
element directly -- C<local $ar-E<gt>[$ar-E<gt>[0]{'key'}]>.
d908 1
a908 1
=item Can't locate %s in @@INC
d910 7
a916 5
(F) You said to do (or require, or use) a file that couldn't be found
in any of the libraries mentioned in @@INC.  Perhaps you need to set the
PERL5LIB or PERL5OPT environment variable to say where the extra library
is, or maybe the script needs to add the library name to @@INC.  Or maybe
you just misspelled the name of the file.  See L<perlfunc/require>.
d926 1
a926 1
(W) The @@ISA array contained the name of another package that doesn't seem
d938 5
d955 1
a955 1
(S) The implicit opening of a file through use of the C<E<lt>E<gt>>
d963 1
a963 1
(W) You tried to say C<open(CMD, "|cmd|")>, which is not supported.  You can
d965 1
a965 1
IPC::Open2.  Alternately, direct the pipe's output to a file using "E<gt>",
d971 1
a971 1
couldn't open the file specified after '2E<gt>' or '2E<gt>E<gt>' on the
d977 1
a977 1
couldn't open the file specified after 'E<lt>' on the command line for reading.
d982 1
a982 1
couldn't open the file specified after 'E<gt>' or 'E<gt>E<gt>' on the command
d1001 6
d1009 2
a1010 2
(S) The rename done by the B<-i> switch failed for some reason, probably because
you don't have write permission to the directory.
d1027 6
d1089 1
a1089 1
You mentioned $a or $b in the same line as the E<lt>=E<gt> or cmp operator,
d1104 1
a1104 1
=item Can't use \1 to mean $1 in expression
d1106 1
a1106 1
(W) In an ordinary expression, backslash is a unary operator that creates
d1112 1
a1112 1
=item Can't use bareword ("%s") as %s ref while \"strict refs\" in use
d1141 5
d1152 1
a1152 1
=item Cannot find an opnumber for "%s"
d1157 1
a1157 1
=item Cannot resolve method `%s' overloading `%s' in package `%s'
d1163 13
d1178 1
a1178 1
(W) Within regular expression character classes ([]) the syntax beginning
a1183 8
=item Character class syntax [: :] is reserved for future extensions

(W) Within regular expression character classes ([]) the syntax beginning
with "[:" and ending with ":]" is reserved for future extensions.
If you need to represent those character sequences inside a regular
expression character class, just quote the square brackets with the
backslash: "\[:" and ":\]".

d1186 1
a1186 1
(W) Within regular expression character classes ([]) the syntax
d1192 1
a1192 1
=item chmod: mode argument is missing initial 0
d1194 1
a1194 1
(W) A novice will sometimes say
d1201 1
a1201 1
=item Close on unopened file E<lt>%sE<gt>
d1203 1
a1203 1
(W) You tried to close a filehandle that was never opened.
d1213 1
a1213 1
(W) The regular expression engine uses recursion in complex situations
d1223 1
a1223 1
=item connect() on closed fd
d1225 1
a1225 1
(W) You tried to do a connect on a closed socket.  Did you forget to check
d1238 1
a1238 1
(S) You redefined a subroutine which had previously been eligible for
d1244 1
a1244 1
(S) You undefined a subroutine which had previously been eligible for
d1248 7
d1259 4
d1279 1
a1279 1
(W) This subroutine has called itself (directly or indirectly) 100
d1284 12
d1298 1
a1298 1
(F) In a here document construct like C<E<lt>E<lt>FOO>, the label
d1302 5
a1306 1
=item Did you mean &%s instead?
d1310 6
a1315 1
=item Did you mean $ or @@ instead of %?
d1325 1
a1325 1
=item Do you need to predeclare %s?
d1337 4
d1351 1
a1351 1
(S) An internal routine called free() on something that had already
d1361 7
a1367 1
=item END failed--cleanup aborted
d1369 2
a1370 2
(F) An untrapped exception was raised while executing an END subroutine.
The interpreter is immediately exited.
d1414 6
a1419 1
(W) You are exiting an eval by unconventional means, such as
d1424 1
a1424 1
(W) You are exiting a rather special block construct (like a sort block or
d1430 1
a1430 1
(W) You are exiting a subroutine by unconventional means, such as
d1435 1
a1435 1
(W) You are exiting a substitution by unconventional means, such as
d1440 1
a1440 1
(W) You are blessing a reference to a zero length string.  This has
d1445 7
d1466 1
a1466 1
(W) An I/O operation was attempted on a filehandle that was never initialized.
d1470 1
a1470 1
=item Filehandle %s opened for only input
d1472 1
a1472 1
(W) You tried to write on a read-only filehandle.  If you
d1474 2
a1475 2
"+E<lt>" or "+E<gt>" or "+E<gt>E<gt>" instead of with "E<lt>" or nothing.  If
you intended only to write the file, use "E<gt>" or "E<gt>E<gt>".  See
d1478 1
a1478 1
=item Filehandle opened for only input
d1480 4
a1483 4
(W) You tried to write on a read-only filehandle.  If you
intended it to be a read-write filehandle, you needed to open it with
"+E<lt>" or "+E<gt>" or "+E<gt>E<gt>" instead of with "E<lt>" or nothing.  If
you intended only to write the file, use "E<gt>" or "E<gt>E<gt>".  See
d1500 6
d1508 1
a1508 1
(W) You redefined a format.  To suppress this warning, say
d1511 1
a1511 1
	local $^W = 0;
d1522 1
a1522 1
(W) You said
d1542 1
a1542 1
=item get{sock,peer}name() on closed fd
d1544 1
a1544 1
(W) You tried to get a socket or peer socket name on a closed socket.
d1552 14
d1576 3
a1578 2
must either be lexically scoped (using "my"), or explicitly qualified to
say which package the global variable is in (using "::").
d1587 1
a1587 1
(S) A routine asked for a symbol from a symbol table that ought to have
d1593 1
a1593 1
(D) Really old Perl let you omit the % on hash names in some spots.  This
d1596 6
d1609 1
a1609 1
=item Ill-formed logical name |%s| in prime_env_iter
d1611 10
a1620 6
(W) A warning peculiar to VMS.  A logical name was encountered when preparing
to iterate over %ENV which violates the syntactic rules governing logical
names.  Because it cannot be translated normally, it is skipped, and will not
appear in %ENV.  This may be a benign occurrence, as some software packages
might directly modify logical name tables and introduce nonstandard names,
or it may indicate that a logical name table has been corrupted.
d1624 5
a1628 16
(F) A carriage return character was found in the input.  This is an
error, and not a warning, because carriage return characters can break
multi-line strings, including here documents (e.g., C<print E<lt>E<lt>EOF;>).

Under Unix, this error is usually caused by executing Perl code --
either the main program, a module, or an eval'd string -- that was
transferred over a network connection from a non-Unix system without
properly converting the text file format.

Under systems that use something other than '\n' to delimit lines of
text, this error can also be caused by reading Perl code from a file
handle that is in binary mode (as set by the C<binmode> operator).

In either case, the Perl code in question will probably need to be
converted with something like C<s/\x0D\x0A?/\n/g> before it can be
executed.
d1640 5
a1644 1
=item Illegal octal digit
d1648 1
a1648 1
=item Illegal octal digit ignored
d1650 6
a1655 1
(W) You may have tried to use an 8 or 9 in a octal number.  Interpretation
d1658 1
a1658 1
=item Illegal hex digit ignored
d1660 2
a1661 2
(W) You may have tried to use a character other than 0 - 9 or A - F in a
hexadecimal number.  Interpretation of the hexadecimal number stopped
d1664 5
d1708 1
a1708 1
=item Integer overflow in hex number
d1710 9
a1718 9
(S) The literal hex number you have specified is too big for your
architecture. On a 32-bit architecture the largest hex literal is
0xFFFFFFFF.

=item Integer overflow in octal number

(S) The literal octal number you have specified is too big for your
architecture. On a 32-bit architecture the largest octal literal is
037777777777.
d1734 5
a1738 1
=item glob failed (%s)
d1740 2
a1741 11
(W) Something went wrong with the external program(s) used for C<glob>
and C<E<lt>*.cE<gt>>.  Usually, this means that you supplied a C<glob>
pattern that caused the external program to fail and exit with a nonzero
status.  If the message indicates that the abnormal exit resulted in a
coredump, this may also mean that your csh (C shell) is broken.  If so,
you should change all of the csh-related variables in config.sh:  If you
have tcsh, make the variables refer to it as if it were csh (e.g.
C<full_csh='/usr/bin/tcsh'>); otherwise, make them all empty (except that
C<d_csh> should be C<'undef'>) so that Perl will think csh is missing.
In either case, after editing config.sh, run C<./Configure -S> and
rebuild Perl.
d1743 1
a1743 1
=item internal urp in regexp at /%s/
d1745 2
a1746 1
(P) Something went badly awry in the regular expression parser.
d1748 1
a1748 1
=item invalid [] range in regexp
d1755 1
a1755 1
(W) Perl does not understand the given format conversion.
d1758 7
d1768 1
a1768 1
(W) The given character is not a valid pack type but used to be silently
d1774 1
a1774 1
(W) The given character is not a valid unpack type but used to be silently
d1804 6
a1809 1
=item listen() on closed fd
d1811 1
a1811 1
(W) You tried to do a listen on a closed socket.  Did you forget to check
d1814 6
d1825 4
d1837 1
a1837 1
(W) An underline in a decimal constant wasn't on a 3-digit boundary.
d1845 5
d1855 6
a1860 1
=item Missing operator before %s?
d1865 1
a1865 1
=item Missing right bracket
d1867 3
a1869 3
(F) The lexer counted more opening curly brackets (braces) than closing ones.
As a general rule, you'll find it's missing near the place you were last
editing.
d1903 1
a1903 1
(W) Multidimensional arrays aren't written like C<$foo[1,2,3]>.  They're written
d1906 5
d1913 1
a1913 1
(W) Typographical errors often show up as unique variable names.
d1915 2
a1916 2
it again somehow to suppress the message.  The C<use vars> pragma is
provided for just this purpose.
d1947 5
d1997 1
a1997 1
=item No error file after 2E<gt> or 2E<gt>E<gt> on command line
d2000 1
a2000 1
and found a '2E<gt>' or a '2E<gt>E<gt>' on the command line, but can't find
d2003 1
a2003 1
=item No input file after E<lt> on command line
d2006 1
a2006 1
and found a 'E<lt>' on the command line, but can't find the name of the file
d2009 1
a2009 1
=item No output file after E<gt> on command line
d2012 1
a2012 1
and found a lone 'E<gt>' at the end of the command line, so it doesn't know
d2015 1
a2015 1
=item No output file after E<gt> or E<gt>E<gt> on command line
d2018 1
a2018 1
and found a 'E<gt>' or a 'E<gt>E<gt>' on the command line, but can't find the
d2021 6
d2042 1
a2042 1
=item No space allowed after B<-I>
d2044 2
a2045 2
(F) The argument to B<-I> must follow the B<-I> immediately with no
intervening space.
d2047 1
a2047 1
=item No such array field
d2053 1
a2053 1
=item No such field "%s" in variable %s of type %s
d2068 1
a2068 1
(W) You specified a signal name as a subscript to %SIG that was not recognized.
d2071 8
d2140 1
a2140 1
(W) A format specified more picture fields than the next line supplied.
d2156 1
a2156 1
(P) Some internal routine called run() with a null opcode pointer.
d2177 14
d2193 1
a2193 1
(S) You specified an odd number of elements to initialize a hash, which
d2205 1
a2205 1
(S) An internal warning that the grammar is screwed up.
d2209 1
a2209 1
(S) An internal warning that the grammar is screwed up.
d2221 1
a2221 1
(S) You used a variable or subroutine call where the parser was
d2227 6
d2264 1
a2264 1
(W) A single call to write() produced more lines than can fit on a page.
d2280 5
d2323 4
d2345 5
d2425 4
d2431 1
a2431 1
(W) You said something like
d2439 1
a2439 1
Remember that "my" and "local" bind closer than comma.
d2451 1
a2451 1
=item pid %d not a child
d2453 1
a2453 1
(W) A warning peculiar to VMS.  Waitpid() was asked to wait for a process which
d2459 1
a2459 1
(F) Your C compiler uses POSIX getpgrp(), which takes no argument, unlike
d2462 5
d2469 1
a2469 1
(W) qw() lists contain items separated by whitespace; as with literal
d2498 1
a2498 1
(W) qw() lists contain items separated by whitespace; therefore commas
d2519 18
d2539 1
a2539 1
(S) The old irregular construct
d2552 1
a2552 1
=item print on closed filehandle %s
d2554 1
a2554 2
(W) The filehandle you're printing on got itself closed sometime before now.
Check your logic flow.
d2556 1
a2556 1
=item printf on closed filehandle %s
d2558 1
a2558 1
(W) The filehandle you're writing to got itself closed sometime before now.
d2561 1
a2561 1
=item Probable precedence problem on %s
d2563 2
a2564 5
(W) The compiler found a bareword where it expected a conditional,
which often indicates that an || or && was parsed as part of the
last argument of the previous construct, for example:

    open FOO || die;
d2568 1
a2568 1
(S) The subroutine being declared or defined had previously been declared
d2578 1
a2578 1
=item Read on closed filehandle E<lt>%sE<gt>
d2580 1
a2580 1
(W) The filehandle you're reading from got itself closed sometime before now.
d2583 5
d2594 1
a2594 1
(F) You can't use the B<-D> option unless the code to produce the
d2610 1
a2610 1
(W) You gave a single reference where Perl was expecting a list with
d2620 5
d2627 1
a2627 1
(W) The internal sv_replace() function was handed a new SV with a
d2644 6
a2649 1
=item regexp too big
d2651 2
a2652 5
(F) The current implementation of regular expressions uses shorts as
address offsets within a string.  Unfortunately this means that if
the regular expression compiles to longer than 32767, it'll blow up.
Usually when you want a regular expression this big, there is a better
way to do it with multiple statements.  See L<perlre>.
d2656 1
a2656 1
(W) You wrote your assignment operator backwards.  The = must always
d2669 1
a2669 1
(W) You've used an array slice (indicated by @@) to select a single element of
d2683 1
a2683 1
(W) You've used a hash slice (indicated by @@) to select a single element of
d2708 1
a2708 1
(W) You tried to use the seek() or sysseek() function on a filehandle that
d2721 1
a2721 1
(S) The internal newSVsv() routine was called to duplicate a scalar
d2726 1
a2726 1
(W) A nearby syntax error was probably caused by a missing semicolon,
d2729 1
a2729 1
=item Send on closed socket
d2731 1
a2731 1
(W) The filehandle you're sending to got itself closed sometime before now.
d2756 6
a2761 1
Also known as "500 Server error".
d2788 1
a2788 1
(F) You tried to assign to C<$E<gt>>, and your operating system doesn't support
d2792 5
d2805 1
a2805 1
(F) You tried to assign to C<$E<lt>>, and your operating system doesn't support
d2818 1
a2818 1
=item shutdown() on closed fd
d2820 1
a2820 1
(W) You tried to do a shutdown on a closed socket.  Seems a bit superfluous.
d2824 1
a2824 1
(W) The signal handler named in %SIG doesn't, in fact, exist.  Perhaps you
d2835 1
a2835 1
it by not using C<E<lt>=E<gt>> or C<cmp>, or by not using them correctly.
d2849 1
a2849 1
=item Stat on unopened file E<lt>%sE<gt>
d2851 1
a2851 1
(W) You tried to use the stat() function (or an equivalent file test)
d2856 1
a2856 1
(W) You did an exec() with some statement after it other than a die().
d2864 1
a2864 1
(W) You applied a regular expression quantifier in a place where it
d2878 1
a2878 1
(W) You redefined a subroutine.  To suppress this warning, say
d2881 1
a2881 1
	local $^W = 0;
d2906 1
a2906 1
(S),(W) You tried to reference a substr() that pointed outside of a
d2909 1
a2909 1
mandatory if substr is used in an lvalue context (as the left hand side
d2917 5
d2956 1
a2956 1
=item Syswrite on closed filehandle
d2958 1
a2958 1
(W) The filehandle you're writing to got itself closed sometime before now.
d2968 1
a2968 1
(W) You tried to use the tell() function on a filehandle that was either
d2971 1
a2971 1
=item Test on unopened file E<lt>%sE<gt>
d2973 1
a2973 1
(W) You tried to invoke a file test operator on a filehandle that isn't
d3010 11
d3053 8
d3107 1
a3107 1
(W) A umask of 222 is incorrect.  It should be 0222, because octal
d3121 1
a3121 1
(W) The exit code detected an internal inconsistency in how many execution
d3126 1
a3126 1
(W) The exit code detected an internal inconsistency in how many
d3131 1
a3131 1
(W) The exit code detected an internal inconsistency in how many blocks
d3136 1
a3136 1
(W) The exit code detected an internal inconsistency in how many mortal
d3171 1
a3171 1
(W) An undefined value was assigned to a typeglob, a la C<*foo = undef>.
d3183 13
d3202 1
a3202 1
=item Unmatched right bracket
d3204 4
a3207 4
(F) The lexer counted more closing curly brackets (braces) than opening
ones, so you're probably missing an opening bracket.  As a general
rule, you'll find the missing one (so to speak) near the place you were
last editing.
d3217 1
a3217 1
(W) You used a bareword that might someday be claimed as a reserved word.
d3227 5
d3245 1
a3245 1
(W) A file operation was attempted on a filename, and that operation
d3271 1
a3271 1
=item Unterminated E<lt>E<gt> operator
d3278 1
a3278 1
=item Use of "$$<digit>" to mean "${$}<digit>" is deprecated
d3280 11
a3290 9
(D) Perl versions before 5.004 misinterpreted any type marker followed
by "$" and a digit.  For example, "$$0" was incorrectly taken to mean
"${$}0" instead of "${$0}".  This bug is (mostly) fixed in Perl 5.004.

However, the developers of Perl 5.004 could not fix this bug completely,
because at least two widely-used modules depend on the old meaning of
"$$0" in a string.  So Perl 5.004 still interprets "$$<digit>" in the
old (broken) way inside strings; but it generates this message as a
warning.  And in Perl 5.005, this special treatment will cease.
d3294 1
a3294 1
(D) This was an ill-advised attempt to emulate a poorly defined B<awk> feature.
d3299 1
a3299 1
(D) This variable magically turned on multi-line pattern matching, both for
d3309 1
a3309 1
=item Use of bare E<lt>E<lt> to mean E<lt>E<lt>"" is deprecated
d3311 1
a3311 1
(D) You are now encouraged to use the explicitly quoted form if you
d3316 1
a3316 1
(D) It makes a lot of work for the compiler when you clobber a
d3322 4
a3325 4
(D) As an (ahem) accidental feature, C<AUTOLOAD> subroutines are looked
up as methods (using the C<@@ISA> hierarchy) even when the subroutines to
be autoloaded were called as plain functions (e.g. C<Foo::bar()>), not
as methods (e.g. C<Foo-E<gt>bar()> or C<$obj-E<gt>bar()>).
d3344 1
a3344 1
(D) The indicated bareword is a reserved word.  Future versions of perl
d3353 1
a3353 1
(D) The construct indicated is no longer recommended for use, generally
d3357 1
a3357 1
=item Use of uninitialized value
d3359 1
a3359 1
(W) An undefined value was used as if it were already defined.  It was
d3361 1
a3361 1
warning assign an initial value to your variables.
d3369 1
a3369 1
(W) You did something without a side effect in a context that does nothing
d3400 1
a3400 1
(W) A copy of the object returned from C<tie> (or C<tied>) was still
d3405 1
a3405 1
(W) In a conditional expression, you used <HANDLE>, <*> (glob), C<each()>,
d3411 7
d3428 1
a3428 1
(W) An inner (nested) I<anonymous> subroutine is inside a I<named>
d3450 1
a3450 1
(W) An inner (nested) I<named> subroutine is referencing a lexical
d3476 6
d3515 1
a3515 1
(S) You wrote a unary operator followed by something that looks like a
d3532 1
a3532 1
=item Write on closed filehandle
d3534 1
a3534 1
(W) The filehandle you're writing to got itself closed sometime before now.
d3570 1
a3570 1
(W) You assigned a bareword as a signal handler name.  Unfortunately, you
d3575 1
a3575 1
=item [gs]etsockopt() on closed fd
d3577 1
a3577 1
(W) You tried to get or set a socket option on a closed socket.
d3579 1
a3579 1
See L<perlfunc/getsockopt>.
d3583 1
a3583 1
(W) Outside of patterns, backreferences live on as variables.  The use
d3589 1
a3589 1
=item '|' and 'E<lt>' may not both be specified on command line
d3593 1
a3593 1
'E<lt>'.  Only one STDIN stream to a customer, please.
d3595 1
a3595 1
=item '|' and 'E<gt>' may not both be specified on command line
d3645 1
@


1.2
log
@perl 5.004_04
@
text
@d36 1
a36 1
=item "my" variable %s masks earlier declaration in same scope
d38 3
a40 3
(W) A lexical variable has been redeclared in the same scope, effectively
eliminating all access to the previous instance.  This is almost always
a typographical error.  Note that the earlier variable will still exist
d146 12
a202 4
=item Allocation too large

(F) You can't allocate more than 2^31+"small amount" bytes.

d205 1
a205 1
(W) The pattern match (//), substitution (s///), and translation (tr///)
d222 16
d347 6
d391 1
a391 1
subroutine identifier, in curly braces or to the left of the "=>" symbol.
d394 6
d492 11
a502 1
neither an object reference nor a package name.  (Perhaps it's null?)
d514 4
d543 6
d697 5
d716 7
a752 5
=item Can't mktemp()

(F) The mktemp() routine failed for some reason while trying to process
a B<-e> switch.  Maybe your /tmp partition is full, or clobbered.

d883 6
a943 5
=item Can't write to temp file for B<-e>: %s

(F) The write routine failed for some reason while trying to process
a B<-e> switch.  Maybe your /tmp partition is full, or clobbered.

d950 1
a950 1
=item Cannot open temporary file
d952 2
a953 2
(F) The create routine failed for some reason while trying to process
a B<-e> switch.  Maybe your /tmp partition is full, or clobbered.
d961 24
d1004 12
d1021 8
d1131 21
d1184 7
a1284 1

d1368 6
d1405 1
a1405 1
=item Insecure PATH
d1408 2
a1409 1
setgid script if C<$ENV{PATH}> is derived from data supplied (or
d1430 1
a1430 1
script or a subprocess (see L<perlvms/exec>).  Somehow, this count
d1439 1
a1439 1
=item internal error: glob failed
d1441 11
a1451 8
(P) Something went wrong with the external program(s) used for C<glob>
and C<E<lt>*.cE<gt>>.  This may mean that your csh (C shell) is
broken.  If so, you should change all of the csh-related variables in
config.sh:  If you have tcsh, make the variables refer to it as if it
were csh (e.g. C<full_csh='/usr/bin/tcsh'>); otherwise, make them all
empty (except that C<d_csh> should be C<'undef'>) so that Perl will
think csh is missing.  In either case, after editing config.sh, run
C<./Configure -S> and rebuild Perl.
d1559 1
a1559 1
=item Modification of noncreatable array value attempted, subscript %d
d1565 1
a1565 1
=item Modification of noncreatable hash value attempted, subscript "%s"
d1567 1
a1567 1
(F) You tried to make a hash value spring into existence, and it couldn't
d1708 13
d1830 1
a1830 1
=item Odd number of elements in hash list
d1832 2
a1833 2
(S) You specified an odd number of elements to a hash list, which is odd,
because hash lists come in key/value pairs.
d1850 1
a1850 1
=item Operation `%s': no method found,%s
d1871 1
a1871 1
=item Out of memory!
d1882 1
a1882 1
=item Out of memory during request for %s
d1889 6
d2044 1
a2044 1
=item Pareneses missing around "%s" list
d2082 1
a2082 2
exclamation marks parentheses shown here; braces are also frequently
used.)
d2167 7
d2189 1
a2189 1
=item Recursive inheritance detected
d2194 17
d2319 1
d2351 2
a2352 2
	http://www.perl.com/perl/faq/idiots-guide.html
	http://www.perl.com/perl/faq/perl-cgi-faq.html
d2357 2
d2436 8
d2518 1
a2518 1
=item System V IPC is not implemented on this machine
d2520 4
a2523 2
(F) You tried to do something with a function beginning with "sem", "shm",
or "msg".  See L<perlfunc/semctl>, for example.
d2632 1
a2632 1
=item Translation pattern not terminated
d2638 1
a2638 1
=item Translation replacement not terminated
d2657 7
a2663 2
(W) A umask of 222 is incorrect.  It should be 0222, because octal literals
always start with 0 in Perl, as in C.
d2719 5
d2795 1
a2795 1
(F) This machines doesn't implement the indicated function, apparently.
d2855 1
a2855 1
as methods (e.g. C<Foo->bar()> or C<$obj->bar()>).
d2870 10
a2879 1
C<C<use AutoLoader 'AUTOLOAD';>.
d2893 4
d2998 21
@


1.1
log
@Initial revision
@
text
@d15 1
a15 1
    (X) A very fatal error (non-trappable).
d19 2
a20 2
be captured by setting C<$^Q> to a reference to a routine that will be
called on each warning instead of printing it.  See L<perlvar>.
d25 2
a26 2
just as in a printf format.  Note that some message start with a %s!
The symbols C<"%-?@@> sort before the letters, while C<[> and C<\> sort after.
d36 8
d56 1
a56 1
(F) You can't pack a string by supplying a checksum, since the
d63 2
a64 2
by parentheses turns into a function, with all the list operators arguments 
found inside the parens.  See L<perlop/Terms and List Operators (Leftward)>.
d68 8
a75 1
(F) The argument to delete() or exists() must be a hash element, such as
d80 5
d99 1
a99 1
=item %s had compilation errors.
d103 1
a103 1
=item %s has too many errors.
d122 1
a122 1
=item %s: Command not found.
d125 2
a126 2
of Perl.  Check the <#!> line, or manually feed your script
into Perl yourself.
d128 1
a128 1
=item %s: Expression syntax.
d131 2
a132 2
of Perl.  Check the <#!> line, or manually feed your script
into Perl yourself.
d134 1
a134 1
=item %s: Undefined variable.
d137 2
a138 2
of Perl.  Check the <#!> line, or manually feed your script
into Perl yourself.
d142 2
a143 2
(A) You've accidentally run your script through the Bourne shell 
instead of Perl.  Check the <#!> line, or manually feed your script
d146 6
d162 6
d179 1
a179 1
(F) You had a pack template that specified an absolution position outside
d189 14
a202 1
(F) You can't allocate more than 64K on an MSDOS machine.
d212 1
a212 1
a missing quote, operator, paren pair or declaration.
d217 3
a219 1
with match the arguments specified on the #! line.
d221 1
a221 1
=item Argument "%s" isn't numeric
d252 7
d280 15
d298 2
a299 2
shmctl().  In C parlance, the correct sized are, respectively,
S<sizeof(struct msqid_ds *)>, S<sizeof(struct semid_ds *)> and
a301 4
=item Bad associative array

(P) One of the internal hash routines was passed a null HV pointer.

d311 11
a321 1
malloc()ed in the first place.
d352 1
a352 1
=item Badly places ()'s
d355 8
a362 2
of Perl.  Check the <#!> line, or manually feed your script
into Perl yourself.
d369 8
d391 12
d408 3
a410 3
"loopish" block.  You can usually double the curlies to get the same
effect though, since the inner curlies will be considered a block
that loops once.  See L<perlfunc/last>.
d416 3
a418 3
count as a "loopish" block.  You can usually double the curlies to get
the same effect though, since the inner curlies will be considered a block
that loops once.  See L<perlfunc/last>.
d424 3
a426 3
count as a "loopish" block.  You can usually double the curlies to get
the same effect though, since the inner curlies will be considered a block
that loops once.  See L<perlfunc/last>.
d435 1
a435 1
(S) A warning intended for while running within the debugger, indicating
d447 1
a447 1
(F) A method call must know what package it's supposed to run in.  It
d471 1
a471 1
(type GLOB), can't be forced to stop being what they are.  So you can't
d486 1
a486 1
(type GLOB), can't be forced to stop being what they are.
d491 1
a491 1
(type GLOB), can't be forced to stop being what they are.
d500 1
a500 1
(F) Only scalar, array and hash variables may be declared as lexical variables.
d509 2
a510 2
(F) You're on a system such as MSDOS that gets confused if you try reading
from a deleted (but still opened) file.  You have to say B<-i>C<.bak>, or some
d513 1
a513 1
=item Can't do inplace edit: %s > 14 characters
d545 1
a545 1
=item Can't do {n,m} with n > m
d557 1
a557 1
(W) An system(), exec() or piped open call could not execute the named
d572 11
d584 1
a584 1
in the PATH, or at least not with the correct permissions.
d594 1
a594 1
the closing delimiter was omitted.  Since bracketed quotes count nesting
d597 5
a601 1
    print q(The character '(' starts a side comment.)
d617 1
a617 1
routine, since the device name is overwritten with each call.  If this warning
d638 1
a638 1
you should only be calling it out of an AUTOLOAD routine anyway.  See
d641 1
a641 1
=item Can't localize a reference
d643 4
a646 4
(F) You said something like C<local $$ref>, which is not allowed because
the compiler can't determine whether $ref will end up pointing to anything
with a symbol table entry, and a symbol table entry is necessary to
do a local.
d650 1
a650 1
(F) You used local on a variable name that was previous declared as a
d655 7
d665 3
a667 3
in any of the libraries mentioned in @@INC.  Perhaps you need to set
the PERL5LIB environment variable to say where the extra library is,
or maybe the script needs to add the library name to @@INC.  Or maybe
d674 1
a674 1
method, nor does any of it's base classes.  See L<perlobj>.
d681 4
d693 1
a693 1
change it, such as with an autoincrement.
d695 1
a695 1
=item Can't modify non-existent substring
d700 1
a700 1
=item Can't msgrcv to readonly var
d702 1
a702 1
(F) The target of a msgrcv must be modifiable in order to be used as a receive
d707 5
a711 2
(S) An inplace edit couldn't open the original file for the indicated reason.
Usually this is because you don't have read permission for the file.
d717 1
a717 1
"open2.pl".  Alternately, direct the pipe's output to a file using ">",
d723 2
a724 2
couldn't open the file specified after '2>' or '2>>' on the command line for
writing.
d729 1
a729 1
couldn't open the file specified after '<' on the command line for reading.
d734 2
a735 2
couldn't open the file specified after '>' or '>>' on the command line for
writing.
d746 7
d785 4
a788 1
(F) Logarithms are only defined on positive real numbers.
d793 2
a794 2
negative number.  There's a Complex package available for Perl, though,
if you really want to do that.
d823 1
a823 1
You mentioned $a or $b in the same line as the <=> or cmp operator,
d842 1
a842 1
to a matched substring is only valid as part of a regular expression pattern.
d846 5
d859 1
a859 6
be a defined value.  This helps to de-lurk some insidious errors.

=item Can't use delimiter brackets within expression

(F) The ${name} construct is for disambiguating identifiers in strings, not
in ordinary code.
d864 1
a864 1
not allowed, because the magic can only be tied to one location (namely
d880 1
a880 1
=item Can't x= to readonly value
d888 1
a888 1
(F) The create routine failed for some reaon while trying to process
d891 6
d906 1
a906 1
=item Close on unopened file <%s>
d910 6
d921 16
d954 1
a954 1
times than it has returned.  This probably indicates an infinite
d958 6
d973 5
d1017 1
a1017 1
(F) An error peculiar to VMS.  Since Perl may have to deal with file
d1023 8
a1030 1
=item Execution of %s aborted due to compilation errors.
d1036 1
a1036 1
(W) You are exiting an eval by unconventional means, such as a
d1039 6
d1047 1
a1047 1
(W) You are exiting a subroutine by unconventional means, such as a
d1052 1
a1052 1
(W) You are exiting a substitution by unconventional means, such as a
d1073 1
a1073 1
=item Filehandle %s opened only for input
d1077 3
a1079 2
"+<" or "+>" or "+>>" instead of with "<" or nothing.  If you only
intended to write the file, use ">" or ">>".  See L<perlfunc/open>.
d1081 1
a1081 1
=item Filehandle only opened for input
d1085 3
a1087 2
"+<" or "+>" or "+>>" instead of with "<" or nothing.  If you only
intended to write the file, use ">" or ">>".  See L<perlfunc/open>.
d1159 2
a1160 2
(F) You've said "use strict vars", which indicates that all variables must
either be lexically scoped (using "my"), or explicitly qualified to
d1179 1
a1179 1
=item Identifier "%s::%s" used only once: possible typo
d1181 32
a1212 3
(W) Typographical errors often show up as unique identifiers.  If you
had a good reason for having a unique identifier, then just mention it
again somehow to suppress the message.
d1233 15
d1250 1
a1250 1
(F) You tried to do something that the tainting mechanism didn't like. 
d1261 1
a1261 1
script if $ENV{PATH} contains a directory that is writable by the world.
d1267 1
a1267 1
setgid script if $ENV{PATH} is derived from data supplied (or
d1271 12
d1286 2
a1287 2
of times you've called C<fork> and C<exec>, in order to determine
whether the current call to C<exec> should be affect the current
d1297 11
d1317 17
a1365 10
=item Literal @@%s now requires backslash

(F) It used to be that Perl would try to guess whether you wanted an
array interpolated or a literal @@.  It did this when the string was
first used at runtime.  Now strings are parsed at compile time, and
ambiguous instances of @@ must be disambiguated, either by putting a
backslash to indicate a literal, or by declaring (or using) the array
within the program before the string (lexically).  (Someday it will simply
assume that an unbackslashed @@ interpolates an array.)

d1369 1
a1369 1
doesn't somehow point to a valid method.  See L<perlovl>.
d1383 2
a1384 2
(F) Apparently you've been programming in csh too much.  Variables are always
mentioned with the $ in Perl, unlike in the shells, where it can vary from 
a1402 6
=item Missing semicolon on previous line?

(S) This is an educated guess made in conjunction with the message "%s
found where operator expected".  Don't automatically put a semicolon on
the previous line just because you saw this message.

d1406 1
a1406 1
constant.  You didn't, of course, try "2 = 1", since the compiler
d1414 1
a1414 1
=item Modification of non-creatable array value attempted, subscript %d
d1420 1
a1420 1
=item Modification of non-creatable hash value attempted, subscript "%s"
d1435 9
a1443 2
(W) Multidimensional arrays aren't written like $foo[1,2,3].  They're written
like $foo[1][2][3], as in C.
d1452 1
a1452 1
(F) You can't quantify a quantifier without intervening parens.  So
d1455 1
a1455 1
Note, however, that the minimal matching quantifiers, *?, +? and ?? appear
d1480 12
d1495 1
a1495 1
and found a '|' at the end of the command line, so it doesn't know whither you
d1510 1
a1510 1
supply dbm nowadays, since Perl comes with SDBM.  See L<SDBM_File>.
d1519 1
a1519 1
=item No error file after 2> or 2>> on command line
d1522 2
a1523 2
and found a '2>' or a '2>>' on the command line, but can't find the name of the
file to which to write data destined for stderr.
d1525 1
a1525 1
=item No input file after < on command line
d1528 2
a1529 2
and found a '<' on the command line, but can't find the name of the file from
which to read data for stdin.
d1531 1
a1531 1
=item No output file after > on command line
d1534 2
a1535 2
and found a lone '>' at the end of the command line, so it doesn't know whither
you wanted to redirect stdout.
d1537 1
a1537 1
=item No output file after > or >> on command line
d1540 2
a1541 2
and found a '>' or a '>>' on the command line, but can't find the name of the
file to which to write data destined for stdout.
d1588 1
a1588 1
(F) Perl was trying to evaluate a reference to a "type glob" (that is,
d1618 1
a1618 1
=item Not a subroutine reference in %OVERLOAD
d1621 1
a1621 1
doesn't somehow point to a valid subroutine.  See L<perlovl>.
d1640 1
a1640 1
(F) You can't require the null filename, especially since on many machines
d1643 6
d1659 1
a1659 1
(P) The internal pattern matching routines blew it bigtime.
d1665 7
d1675 8
a1682 1
since hash lists come in key/value pairs.
d1692 1
a1692 1
=item Operation `%s' %s: no method found,
d1694 5
a1698 2
(F) An attempt was made to use an entry in an overloading table that
somehow no longer points to a valid method.  See L<perlovl>.
d1715 1
a1715 1
(X) The malloc() function returned 0, indicating there was insufficient
d1718 13
d1770 4
d1794 1
a1794 1
(P) A writable lexical variable became readonly somehow within the scope.
d1880 1
a1880 1
=item Parens missing around "%s" list
d1913 46
d1976 4
a1979 3
because of the strict regularization of Perl 5's grammar into unary and
list operators.  (The old open was a little of both.) You must put
parens around the filehandle, or use the new "or" operator instead of "||".
d1993 1
a1993 1
(W) The compiler found a bare word where it expected a conditional,
d1999 1
a1999 1
=item Prototype mismatch: (%s) vs (%s)
d2001 2
a2002 2
(S) The subroutine being defined had a predeclared (forward) declaration
with a different function prototype.
d2004 1
a2004 1
=item Read on closed filehandle <%s>
d2011 1
a2011 1
(F) You can't allocate more than 64K on an MSDOS machine.
d2029 5
d2045 1
a2045 1
(F) The current implementation of regular expression uses shorts as
d2066 1
a2066 1
(W) You've used an array slice (indicated by @@) to select a single value of
d2068 2
a2069 2
The difference is that $foo[&bar] always behaves like a scalar, both when
assigning to it and when evaluating its argument, while @@foo[&bar] behaves
d2071 1
a2071 1
subscript, which can do weird things if you're only expecting one subscript.
d2074 15
a2088 1
element as a list, you need to look into how references work, since
d2094 1
a2094 1
(F) Oddly, the suidperl program was invoked on a script with its setuid
d2101 1
d2103 1
a2103 1
=item seek() on unopened file
d2105 2
a2106 2
(W) You tried to use the seek() function on a filehandle that was either
never opened or has been closed since.
d2131 4
d2138 1
a2138 1
parenthesis.  Embedded parens aren't allowed.  See L<perlre>.
d2152 16
a2167 6
Also known as "500 Server error".  This is a CGI error, not a Perl
error.  You need to make sure your script is executable, is accessible
by the user CGI is running the script under (which is probably not
the user account you tested it under), does not rely on any environment
variables (like PATH) from the user it isn't running under, and isn't
in a location where the CGI server can't find it, basically, more or less.
d2171 1
a2171 1
(F) You tried to assign to $), and your operating system doesn't support
d2177 1
a2177 1
(F) You tried to assign to $>, and your operating system doesn't support
d2183 1
a2183 1
(F) You tried to assign to $(, and your operating system doesn't support
d2189 1
a2189 1
(F) You tried to assign to $<, and your operating system doesn't support
d2206 1
a2206 1
=item SIG%s handler "%s" not defined.
d2233 1
a2233 1
=item Stat on unopened file <%s>
d2236 1
a2236 1
on a filehandle that was either never opened or has been closed since.
d2246 6
d2265 2
a2266 2
input, which is what happened.) See the discussion of substitution in
L<perlop/"Quote and Quotelike Operators">.
d2272 1
d2278 1
d2282 5
a2286 3
(W) You tried to reference a substr() that pointed outside of a string.
That is, the absolute value of the offset was larger than the length of
the string.  See L<perlfunc/substr>.
d2288 1
a2288 1
=item suidperl is no longer needed since...
d2308 1
a2308 1
before this, since Perl is good at understanding random input.
d2316 2
a2317 2
(A) You've accidentally run your script through the Bourne shell 
instead of Perl.  Check the <#!> line, or manually feed your script
d2322 1
a2322 1
(F) You tried to do something with a function beginning with "sem", "shm"
d2330 5
d2338 1
a2338 1
never opened or has been closed since.
d2340 1
a2340 1
=item Test on unopened file <%s>
d2347 2
a2348 2
(F) Assignment to $[ is now strictly circumscribed, and interpreted as
a compiler directive.  You may only say one of
d2365 1
a2365 1
=item The crypt() function is unimplemented due to excessive paranoia.
d2369 1
a2369 1
think the U.S. Govermnment thinks it's a secret, or at least that they
d2389 22
d2416 2
a2417 2
of Perl.  Check the <#!> line, or manually feed your script
into Perl yourself.
d2421 1
a2421 1
(F) Perl only supports a maximum of 14 args to syscall().
d2435 2
a2436 1
construct.
d2451 2
a2452 2
certain type.  Arrays must be @@NAME or @@{EXPR}.  Hashes must be
%NAME or %{EXPR}.  No implicit dereferencing is allowed--use the
d2457 1
a2457 1
(W) A umask of 222 is incorrect.  It should be 0222, since octal literals
d2521 1
a2521 1
(F) There are no byteswapping functions for a machine with this byte order.
d2527 1
a2527 1
the matching paren.  See L<perlre>.
d2544 1
a2544 1
(W) You used a bare word that might someday be claimed as a reserved word.
d2548 1
a2548 1
=item Unrecognized character \%03o ignored
d2550 3
a2552 2
(S) A garbage character was found in the input, and ignored, in case it's
a weird control character on an EBCDIC machine, or some such.
d2559 1
a2559 1
=item Unrecognized switch: -%s
d2569 1
a2569 1
because you forgot to chop() or chomp() it off.  See L<perlfunc/chop>.
d2575 8
d2593 1
a2593 1
=item Unterminated <> operator
d2600 12
d2614 1
a2614 1
(D) This was an ill-advised attempt to emulate a poorly defined awk feature.
d2619 1
a2619 1
(D) This variable magically turned on multiline pattern matching, both for
d2626 2
a2627 2
(F) You attempted to use a feature of printf that is accessible only
from C.  This usually means there's a better way to do it in Perl.
d2629 1
a2629 7
=item Use of %s is deprecated

(D) The construct indicated is no longer recommended for use, generally
because there's a better way to do it, and also because the old way has
bad side effects.

=item Use of bare << to mean <<"" is deprecated
d2632 1
a2632 1
wish to use a blank line as the terminator of the here-document.
d2640 28
d2705 14
a2718 1
=item Variable "%s" is not exported
d2726 45
a2770 1
=item Variable syntax.
d2773 7
a2779 2
of Perl.  Check the <#!> line, or manually feed your script
into Perl yourself.
d2781 1
a2781 1
=item Warning: unable to close filehandle %s properly.
d2783 2
a2784 2
(S) The implicit close() done by an open() got an error indication on the 
close(0.  This usually indicates your filesystem ran out of disk space.
d2786 1
a2786 1
=item Warning: Use of "%s" without parens is ambiguous
d2803 1
a2803 1
So put in parens to say what you really mean.
d2836 1
a2836 1
(F) And you probably never will, since you probably don't have the
d2857 1
a2857 1
of backslashes is grandfathered on the righthand side of a
d2862 1
a2862 1
=item '|' and '<' may not both be specified on command line
d2866 1
a2866 1
'<'.  Only one STDIN stream to a customer, please.
d2868 1
a2868 1
=item '|' and '>' may not both be specified on command line
d2882 33
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d15 1
a15 1
    (X) A very fatal error (nontrappable).
d19 2
a20 2
be captured by setting C<$SIG{__WARN__}> to a reference to a routine that
will be called on each warning instead of printing it.  See L<perlvar>.
d25 2
a26 2
just as in a printf format.  Note that some messages start with a %s!
The symbols C<"%(-?@@> sort before the letters, while C<[> and C<\> sort after.
a35 8
=item "my" variable %s masks earlier declaration in same %s

(W) A lexical variable has been redeclared in the current scope or statement,
effectively eliminating all access to the previous instance.  This is almost
always a typographical error.  Note that the earlier variable will still exist
until the end of the scope or until all closure referents to it are
destroyed.

d48 1
a48 1
(F) You can't pack a string by supplying a checksum, because the
d55 2
a56 2
by parentheses turns into a function, with all the list operators arguments
found inside the parentheses.  See L<perlop/Terms and List Operators (Leftward)>.
d60 1
a60 8
(F) The argument to exists() must be a hash element, such as

    $foo{$bar}
    $ref->[12]->{"susie"}

=item %s argument is not a HASH element or slice

(F) The argument to delete() must be either a hash element, such as
a64 5
or a hash slice, such as

    @@foo{$bar, $baz, $xyzzy}
    @@{$ref->[12]}{"susie", "queue"}

d79 1
a79 1
=item %s had compilation errors
d83 1
a83 1
=item %s has too many errors
d102 1
a102 1
=item %s: Command not found
d105 2
a106 2
of Perl.  Check the #! line, or manually feed your script into
Perl yourself.
d108 1
a108 1
=item %s: Expression syntax
d111 2
a112 2
of Perl.  Check the #! line, or manually feed your script into
Perl yourself.
d114 1
a114 1
=item %s: Undefined variable
d117 2
a118 2
of Perl.  Check the #! line, or manually feed your script into
Perl yourself.
d122 2
a123 2
(A) You've accidentally run your script through the Bourne shell
instead of Perl.  Check the #! line, or manually feed your script
a125 18
=item         (in cleanup) %s

(W) This prefix usually indicates that a DESTROY() method raised
the indicated exception.  Since destructors are usually called by
the system at arbitrary points during execution, and often a vast
number of times, the warning is issued only once for any number
of failures that would otherwise result in the same message being
repeated.

Failure of user callbacks dispatched using the C<G_KEEPERR> flag
could also result in this warning.  See L<perlcall/G_KEEPERR>.

=item         (Missing semicolon on previous line?)

(S) This is an educated guess made in conjunction with the message "%s
found where operator expected".  Don't automatically put a semicolon on
the previous line just because you saw this message.

a135 6
=item C<-p> destination: %s

(F) An error occurred during the implicit output invoked by the C<-p>
command-line switch.  (This output goes to STDOUT unless you've
redirected it with select().)

d147 1
a147 1
(F) You had a pack template that specified an absolute position outside
d157 1
a157 10
(X) You can't allocate more than 64K on an MS-DOS machine.

=item Applying %s to %s will act on scalar(%s)

(W) The pattern match (//), substitution (s///), and transliteration (tr///)
operators work on scalar values.  If you apply one of them to an array
or a hash, it will convert the array or hash to a scalar value -- the
length of an array, or the population info of a hash -- and then work on
that scalar value.  This is probably not what you meant to do.  See
L<perlfunc/grep> and L<perlfunc/map> for alternatives.
d167 1
a167 17
a missing quote, operator, parenthesis pair or declaration.

=item Ambiguous call resolved as CORE::%s(), qualify as such or use &

(W) A subroutine you have declared has the same name as a Perl keyword,
and you have used the name without qualification for calling one or the
other.  Perl decided to call the builtin because the subroutine is
not imported.

To force interpretation as a subroutine call, either put an ampersand
before the subroutine name, or qualify the name with its package.
Alternatively, you can import the subroutine (or pretend that it's
imported with the C<use subs> pragma).

To silently interpret it as the Perl operator, use the C<CORE::> prefix
on the operator (e.g. C<CORE::log($x)>) or by declaring the subroutine
to be an object method (see L<attrs>).
d172 1
a172 3
with match the arguments specified on the #! line.  Since some systems
impose a one-argument limit on the #! line, try combining switches;
for example, turn C<-w -U> into C<-wU>.
d174 1
a174 1
=item Argument "%s" isn't numeric%s
a204 7
=item Attempt to free nonexistent shared string

(P) Perl maintains a reference counted internal table of strings to
optimize the storage and access of hash keys and other strings.  This
indicates someone tried to decrement the reference count of a string
that can no longer be found in the table.

a225 15
=item Attempt to pack pointer to temporary value

(W) You tried to pass a temporary value (like the result of a
function, or a computed expression) to the "p" pack() template.  This
means the result contains a pointer to a location that could become
invalid anytime, even before the end of the current statement.  Use
literals or global values as arguments to the "p" pack() template to
avoid this warning.

=item Attempt to use reference as lvalue in substr

(W) You supplied a reference as the first argument to substr() used
as an lvalue, which is pretty strange.  Perhaps you forgot to
dereference it first.  See L<perlfunc/substr>.

d229 2
a230 2
shmctl().  In C parlance, the correct sizes are, respectively,
S<sizeof(struct msqid_ds *)>, S<sizeof(struct semid_ds *)>, and
d233 4
d246 1
a246 17
malloc()ed in the first place. Mandatory, but can be disabled by
setting environment variable C<PERL_BADFREE> to 1.

This message can be quite often seen with DB_File on systems with
"hard" dynamic linking, like C<AIX> and C<OS/2>. It is a bug of
C<Berkeley DB> which is left unnoticed if C<DB> uses I<forgiving>
system malloc().

=item Bad hash

(P) One of the internal hash routines was passed a null HV pointer.

=item Bad index while coercing array into hash

(F) The index looked up in the hash found as the 0'th element of a
pseudo-hash is not legal.  Index values must be at 1 or greater.
See L<perlref>.
d277 1
a277 1
=item Badly placed ()'s
d280 2
a281 14
of Perl.  Check the #! line, or manually feed your script into
Perl yourself.

=item Bareword "%s" not allowed while "strict subs" in use

(F) With "strict subs" in use, a bareword is only allowed as a
subroutine identifier, in curly brackets or to the left of the "=>" symbol.
Perhaps you need to predeclare a subroutine?

=item Bareword "%s" refers to nonexistent package

(W) You used a qualified bareword of the form C<Foo::>, but
the compiler saw no other uses of that namespace before that point.
Perhaps you need to predeclare a package?
a287 8
=item BEGIN not safe after errors--compilation aborted

(F) Perl found a C<BEGIN {}> subroutine (or a C<use> directive, which
implies a C<BEGIN {}>) after one or more compilation errors had
already occurred.  Since the intended environment for the C<BEGIN {}>
could not be guaranteed (due to the errors), and since subsequent code
likely depends on its correct operation, Perl just gave up.

a301 12
=item Can't "goto" outside a block

(F) A "goto" statement was executed to jump out of what might look
like a block, except that it isn't a proper block.  This usually
occurs if you tried to jump out of a sort() block or subroutine, which
is a no-no.  See L<perlfunc/goto>.

=item Can't "goto" into the middle of a foreach loop

(F) A "goto" statement was executed to jump into the middle of a
foreach loop.  You can't get there from here.  See L<perlfunc/goto>.

d307 3
a309 3
"loopish" block, as doesn't a block given to sort().  You can usually double
the curlies to get the same effect though, because the inner curlies
will be considered a block that loops once.  See L<perlfunc/last>.
d315 3
a317 3
count as a "loopish" block, as doesn't a block given to sort().  You can
usually double the curlies to get the same effect though, because the inner
curlies will be considered a block that loops once.  See L<perlfunc/next>.
d323 3
a325 3
count as a "loopish" block, as doesn't a block given to sort().  You can
usually double the curlies to get the same effect though, because the inner
curlies will be considered a block that loops once.  See L<perlfunc/redo>.
d334 1
a334 1
(S) A warning intended to only be printed while running within the debugger, indicating
d346 1
a346 1
(F) A method call must know in what package it's supposed to run.  It
d355 1
a355 11
a defined value which is neither an object reference nor a package name.
Something like this will reproduce the error:

    $BADREF = 42;
    process $BADREF 1,2,3;
    $BADREF->process(1,2,3);

=item Can't call method "%s" on an undefined value

(F) You used the syntax of a method call, but the slot filled by the
object reference or package name contains an undefined value.
a366 4
=item Can't check filesystem of script "%s" for nosuid

(P) For some reason you can't check the filesystem of the script for nosuid.

d370 1
a370 1
(typeglobs), can't be forced to stop being what they are.  So you can't
d385 1
a385 1
(typeglobs), can't be forced to stop being what they are.
d390 1
a390 7
(typeglobs), can't be forced to stop being what they are.

=item Can't coerce array into hash

(F) You used an array where a hash was expected, but the array has no
information on how to map from keys to array indices.  You can do that
only with arrays that have a hash reference at index 0.
d399 1
a399 1
(F) Only scalar, array, and hash variables may be declared as lexical variables.
d408 2
a409 2
(F) You're on a system such as MS-DOS that gets confused if you try reading
from a deleted (but still opened) file.  You have to say C<-i.bak>, or some
d412 1
a412 1
=item Can't do inplace edit: %s E<gt> 14 characters
d444 1
a444 1
=item Can't do {n,m} with n E<gt> m
d456 1
a456 1
(W) An system(), exec(), or piped open call could not execute the named
a470 5
(F) You used the B<-S> switch, but the copies of the script to execute found
in the PATH did not have correct permissions.

=item Can't find %s on PATH, '.' not in PATH

d472 1
a472 7
in the PATH, or at least not with the correct permissions.  The script
exists in the current directory, but PATH prohibits running it.

=item Can't find %s on PATH

(F) You used the B<-S> switch, but the script to execute could not be found
in the PATH.
d482 1
a482 1
the closing delimiter was omitted.  Because bracketed quotes count nesting
d485 1
a485 5
    print q(The character '(' starts a side comment.);

If you're getting this error from a here-document, you may have 
included unseen whitespace before or after your closing tag. A good 
programmer's editor will have a way to help you find these characters.
d501 1
a501 1
routine, because the device name is overwritten with each call.  If this warning
d522 1
a522 1
you should be calling it out of only an AUTOLOAD routine anyway.  See
d525 1
a525 1
=item Can't goto subroutine from an eval-string
d527 4
a530 9
(F) The "goto subroutine" call can't be used to jump out of an eval "string".
(You can use it to jump out of an eval {BLOCK}, but you probably don't want to.)

=item Can't localize through a reference

(F) You said something like C<local $$ref>, which Perl can't currently
handle, because when it goes to restore the old value of whatever $ref
pointed to after the scope of the local() is finished, it can't be
sure that $ref will still be a reference.  
d534 1
a534 1
(F) You used local on a variable name that was previously declared as a
a538 14
=item Can't localize pseudo-hash element

(F) You said something like C<local $ar-E<gt>{'key'}>, where $ar is
a reference to a pseudo-hash.  That hasn't been implemented yet, but
you can get a similar effect by localizing the corresponding array
element directly -- C<local $ar-E<gt>[$ar-E<gt>[0]{'key'}]>.

=item Can't locate auto/%s.al in @@INC

(F) A function (or method) was called in a package which allows autoload,
but there is no function to autoload.  Most probable causes are a misprint
in a function/method name or a failure to C<AutoSplit> the file, say, by
doing C<make install>.

d542 3
a544 3
in any of the libraries mentioned in @@INC.  Perhaps you need to set the
PERL5LIB or PERL5OPT environment variable to say where the extra library
is, or maybe the script needs to add the library name to @@INC.  Or maybe
d551 1
a551 1
method, nor does any of its base classes.  See L<perlobj>.
d558 1
a558 1
=item Can't make list assignment to \%ENV on this system
d560 2
a561 1
(F) List assignment to %ENV is not supported on some systems, notably VMS.
d566 1
a566 1
change it, such as with an auto-increment.
d568 1
a568 1
=item Can't modify nonexistent substring
d573 1
a573 1
=item Can't msgrcv to read-only var
d575 1
a575 1
(F) The target of a msgrcv must be modifiable to be used as a receive
d580 2
a581 5
(S) The implicit opening of a file through use of the C<E<lt>E<gt>>
filehandle, either implicitly under the C<-n> or C<-p> command-line
switches, or explicitly, failed for the indicated reason.  Usually this
is because you don't have read permission for a file which you named
on the command line.
d587 1
a587 1
IPC::Open2.  Alternately, direct the pipe's output to a file using "E<gt>",
d593 2
a594 2
couldn't open the file specified after '2E<gt>' or '2E<gt>E<gt>' on the
command line for writing.
d599 1
a599 1
couldn't open the file specified after 'E<lt>' on the command line for reading.
d604 2
a605 2
couldn't open the file specified after 'E<gt>' or 'E<gt>E<gt>' on the command
line for writing.
a615 7
=item Can't redefine active sort subroutine %s

(F) Perl optimizes the internal handling of sort subroutines and keeps
pointers into them.  You tried to redefine one such sort subroutine when it
was currently active, which is not allowed.  If you really want to do
this, you should write C<sort { &func } @@x> instead of C<sort func @@x>.

d648 1
a648 4
(F) For ordinary real numbers, you can't take the logarithm of a
negative number or zero. There's a Math::Complex package that comes
standard with Perl, though, if you really want to do that for
the negative numbers.
d653 2
a654 2
negative number.  There's a Math::Complex package that comes standard
with Perl, though, if you really want to do that.
a679 6
=item Can't use %%! because Errno.pm is not available

(F) The first time the %! hash is used, perl automatically loads the
Errno.pm module. The Errno module is expected to tie the %! hash to
provide symbolic names for C<$!> errno values.

d683 1
a683 1
You mentioned $a or $b in the same line as the E<lt>=E<gt> or cmp operator,
d702 1
a702 1
to a matched substring is valid only as part of a regular expression pattern.
a705 5
=item Can't use bareword ("%s") as %s ref while \"strict refs\" in use

(F) Only hard references are allowed by "strict refs".  Symbolic references
are disallowed.  See L<perlref>.

d714 6
a719 1
be a defined value.  This helps to delurk some insidious errors.
d724 1
a724 1
not allowed, because the magic can be tied to only one location (namely
d735 6
a740 1
=item Can't x= to read-only value
d746 1
a746 12
=item Cannot find an opnumber for "%s"

(F) A string of a form C<CORE::word> was given to prototype(), but
there is no builtin with the name C<word>.

=item Cannot resolve method `%s' overloading `%s' in package `%s'

(F|P) Error resolving overloading specified by a method name (as
opposed to a subroutine reference): no such method callable via the
package. If method name is C<???>, this is an internal error.

=item Character class syntax [. .] is reserved for future extensions
d748 2
a749 21
(W) Within regular expression character classes ([]) the syntax beginning
with "[." and ending with ".]" is reserved for future extensions.
If you need to represent those character sequences inside a regular
expression character class, just quote the square brackets with the
backslash: "\[." and ".\]".

=item Character class syntax [: :] is reserved for future extensions

(W) Within regular expression character classes ([]) the syntax beginning
with "[:" and ending with ":]" is reserved for future extensions.
If you need to represent those character sequences inside a regular
expression character class, just quote the square brackets with the
backslash: "\[:" and ":\]".

=item Character class syntax [= =] is reserved for future extensions

(W) Within regular expression character classes ([]) the syntax
beginning with "[=" and ending with "=]" is reserved for future extensions.
If you need to represent those character sequences inside a regular
expression character class, just quote the square brackets with the
backslash: "\[=" and "=\]".
d760 1
a760 1
=item Close on unopened file E<lt>%sE<gt>
a763 18
=item Compilation failed in require

(F) Perl could not compile a file specified in a C<require> statement.
Perl uses this generic message when none of the errors that it encountered
were severe enough to halt compilation immediately.

=item Complex regular subexpression recursion limit (%d) exceeded

(W) The regular expression engine uses recursion in complex situations
where back-tracking is required.  Recursion depth is limited to 32766,
or perhaps less in architectures where the stack cannot grow
arbitrarily.  ("Simple" and "medium" situations are handled without
recursion and are not subject to a limit.)  Try shortening the string
under examination; looping in Perl code (e.g. with C<while>) rather
than in the regular expression engine; or rewriting the regular
expression so that it is simpler or backtracks less.  (See L<perlbook>
for information on I<Mastering Regular Expressions>.)

a768 24
=item Constant is not %s reference

(F) A constant value (perhaps declared using the C<use constant> pragma)
is being dereferenced, but it amounts to the wrong type of reference.  The
message indicates the type of reference that was expected. This usually
indicates a syntax error in dereferencing the constant value.
See L<perlsub/"Constant Functions"> and L<constant>.

=item Constant subroutine %s redefined

(S) You redefined a subroutine which had previously been eligible for
inlining.  See L<perlsub/"Constant Functions"> for commentary and
workarounds.

=item Constant subroutine %s undefined

(S) You undefined a subroutine which had previously been eligible for
inlining.  See L<perlsub/"Constant Functions"> for commentary and
workarounds.

=item Copy method did not return a reference

(F) The method which overloads "=" is buggy. See L<overload/Copy Constructor>.

d786 1
a786 1
times more than it has returned.  This probably indicates an infinite
a789 6
=item Delimiter for here document is too long

(F) In a here document construct like C<E<lt>E<lt>FOO>, the label
C<FOO> is too long for Perl to handle.  You have to be seriously
twisted to write code that triggers this error.

a798 5
=item Died

(F) You passed die() an empty string (the equivalent of C<die "">) or
you called it with no args and both C<$@@> and C<$_> were empty.

d838 1
a838 1
(F) An error peculiar to VMS.  Because Perl may have to deal with file
d844 1
a844 29
=item %s: Eval-group in insecure regular expression

(F) Perl detected tainted data when trying to compile a regular expression
that contains the C<(?{ ... })> zero-width assertion, which is unsafe.
See L<perlre/(?{ code })>, and L<perlsec>.

=item %s: Eval-group not allowed, use re 'eval'

(F) A regular expression contained the C<(?{ ... })> zero-width assertion,
but that construct is only allowed when the C<use re 'eval'> pragma is
in effect.  See L<perlre/(?{ code })>.

=item %s: Eval-group not allowed at run time

(F) Perl tried to compile a regular expression containing the C<(?{ ... })>
zero-width assertion at run time, as it would when the pattern contains
interpolated values.  Since that is a security risk, it is not allowed.
If you insist, you may still do this by explicitly building the pattern
from an interpolated string at run time and using that in an eval().
See L<perlre/(?{ code })>.

=item Excessively long <> operator

(F) The contents of a <> operator may not exceed the maximum size of a
Perl identifier.  If you're just trying to glob a long list of
filenames, try using the glob() operator, or put the filenames into a
variable and glob that.

=item Execution of %s aborted due to compilation errors
d850 1
a850 1
(W) You are exiting an eval by unconventional means, such as
a852 6
=item Exiting pseudo-block via %s

(W) You are exiting a rather special block construct (like a sort block or
subroutine) by unconventional means, such as a goto, or a loop control
statement.  See L<perlfunc/sort>.

d855 1
a855 1
(W) You are exiting a subroutine by unconventional means, such as
d860 1
a860 1
(W) You are exiting a substitution by unconventional means, such as
a862 7
=item Explicit blessing to '' (assuming package main)

(W) You are blessing a reference to a zero length string.  This has
the effect of blessing the reference into the package main.  This is
usually not what you want.  Consider providing a default target
package, e.g. bless($ref, $p || 'MyPackage');

d881 1
a881 1
=item Filehandle %s opened for only input
d885 2
a886 3
"+E<lt>" or "+E<gt>" or "+E<gt>E<gt>" instead of with "E<lt>" or nothing.  If
you intended only to write the file, use "E<gt>" or "E<gt>E<gt>".  See
L<perlfunc/open>.
d888 1
a888 1
=item Filehandle opened for only input
d892 2
a893 3
"+E<lt>" or "+E<gt>" or "+E<gt>E<gt>" instead of with "E<lt>" or nothing.  If
you intended only to write the file, use "E<gt>" or "E<gt>E<gt>".  See
L<perlfunc/open>.
d955 1
d965 2
a966 2
(F) You've said "use strict vars", which indicates that all variables
must either be lexically scoped (using "my"), or explicitly qualified to
d985 1
a985 1
=item Identifier too long
d987 3
a989 32
(F) Perl limits identifiers (names for variables, functions, etc.) to
about 250 characters for simple names, and somewhat more for compound
names (like C<$A::B>).  You've exceeded Perl's limits.  Future
versions of Perl are likely to eliminate these arbitrary limitations.

=item Ill-formed logical name |%s| in prime_env_iter

(W) A warning peculiar to VMS.  A logical name was encountered when preparing
to iterate over %ENV which violates the syntactic rules governing logical
names.  Because it cannot be translated normally, it is skipped, and will not
appear in %ENV.  This may be a benign occurrence, as some software packages
might directly modify logical name tables and introduce nonstandard names,
or it may indicate that a logical name table has been corrupted.

=item Illegal character %s (carriage return)

(F) A carriage return character was found in the input.  This is an
error, and not a warning, because carriage return characters can break
multi-line strings, including here documents (e.g., C<print E<lt>E<lt>EOF;>).

Under Unix, this error is usually caused by executing Perl code --
either the main program, a module, or an eval'd string -- that was
transferred over a network connection from a non-Unix system without
properly converting the text file format.

Under systems that use something other than '\n' to delimit lines of
text, this error can also be caused by reading Perl code from a file
handle that is in binary mode (as set by the C<binmode> operator).

In either case, the Perl code in question will probably need to be
converted with something like C<s/\x0D\x0A?/\n/g> before it can be
executed.
a1009 21
=item Illegal hex digit ignored

(W) You may have tried to use a character other than 0 - 9 or A - F in a
hexadecimal number.  Interpretation of the hexadecimal number stopped
before the illegal character.

=item Illegal switch in PERL5OPT: %s

(X) The PERL5OPT environment variable may only be used to set the
following switches: B<-[DIMUdmw]>.

=item In string, @@%s now must be written as \@@%s

(F) It used to be that Perl would try to guess whether you wanted an
array interpolated or a literal @@.  It did this when the string was first
used at runtime.  Now strings are parsed at compile time, and ambiguous
instances of @@ must be disambiguated, either by prepending a backslash to
indicate a literal, or by declaring (or using) the array within the
program before the string (lexically).  (Someday it will simply assume
that an unbackslashed @@ interpolates an array.)

d1012 1
a1012 1
(F) You tried to do something that the tainting mechanism didn't like.
d1023 1
a1023 1
script if C<$ENV{PATH}> contains a directory that is writable by the world.
d1026 1
a1026 1
=item Insecure $ENV{%s} while running %s
d1029 1
a1029 2
setgid script if any of C<$ENV{PATH}>, C<$ENV{IFS}>, C<$ENV{CDPATH}>,
C<$ENV{ENV}> or C<$ENV{BASH_ENV}> are derived from data supplied (or
a1032 12
=item Integer overflow in hex number

(S) The literal hex number you have specified is too big for your
architecture. On a 32-bit architecture the largest hex literal is
0xFFFFFFFF.

=item Integer overflow in octal number

(S) The literal octal number you have specified is too big for your
architecture. On a 32-bit architecture the largest octal literal is
037777777777.

d1036 3
a1038 3
of times you've called C<fork> and C<exec>, to determine
whether the current call to C<exec> should affect the current
script or a subprocess (see L<perlvms/"exec LIST">).  Somehow, this count
a1046 14
=item glob failed (%s)

(W) Something went wrong with the external program(s) used for C<glob>
and C<E<lt>*.cE<gt>>.  Usually, this means that you supplied a C<glob>
pattern that caused the external program to fail and exit with a nonzero
status.  If the message indicates that the abnormal exit resulted in a
coredump, this may also mean that your csh (C shell) is broken.  If so,
you should change all of the csh-related variables in config.sh:  If you
have tcsh, make the variables refer to it as if it were csh (e.g.
C<full_csh='/usr/bin/tcsh'>); otherwise, make them all empty (except that
C<d_csh> should be C<'undef'>) so that Perl will think csh is missing.
In either case, after editing config.sh, run C<./Configure -S> and
rebuild Perl.

a1055 17
=item Invalid conversion in %s: "%s"

(W) Perl does not understand the given format conversion.
See L<perlfunc/sprintf>.

=item Invalid type in pack: '%s'

(F) The given character is not a valid pack type.  See L<perlfunc/pack>.
(W) The given character is not a valid pack type but used to be silently
ignored.

=item Invalid type in unpack: '%s'

(F) The given character is not a valid unpack type.  See L<perlfunc/unpack>.
(W) The given character is not a valid unpack type but used to be silently
ignored.

d1088 10
d1101 1
a1101 1
doesn't resolve to a valid subroutine.  See L<overload>.
d1115 2
a1116 2
(F) Apparently you've been programming in B<csh> too much.  Variables are always
mentioned with the $ in Perl, unlike in the shells, where it can vary from
d1135 6
d1144 1
a1144 1
constant.  You didn't, of course, try "2 = 1", because the compiler
d1160 1
a1160 1
(P) You tried to make a hash value spring into existence, and it couldn't
d1173 2
a1174 9
(W) Multidimensional arrays aren't written like C<$foo[1,2,3]>.  They're written
like C<$foo[1][2][3]>, as in C.

=item Name "%s::%s" used only once: possible typo

(W) Typographical errors often show up as unique variable names.
If you had a good reason for having a unique name, then just mention
it again somehow to suppress the message.  The C<use vars> pragma is
provided for just this purpose.
d1183 1
a1183 1
(F) You can't quantify a quantifier without intervening parentheses.  So
d1186 1
a1186 1
Note, however, that the minimal matching quantifiers, C<*?>, C<+?>, and C<??> appear
a1210 12
One possible cause for this is that you expected to have imported a
constant to your name space with B<use> or B<import> while no such
importing took place, it may for example be that your operating system
does not support that particular constant. Hopefully you did use an
explicit import list for the constants you expect to see, please see
L<perlfunc/use> and L<perlfunc/import>. While an explicit import list
would probably have caught this error earlier it naturally does not
remedy the fact that your operating system still does not support that
constant. Maybe you have a typo in the constants of the symbol import
list of B<use> or B<import> or in the constant name at the line where
this error was triggered?

d1214 1
a1214 1
and found a '|' at the end of the command line, so it doesn't know where you
d1229 1
a1229 1
supply dbm nowadays, because Perl comes with SDBM.  See L<SDBM_File>.
d1238 1
a1238 1
=item No error file after 2E<gt> or 2E<gt>E<gt> on command line
d1241 2
a1242 2
and found a '2E<gt>' or a '2E<gt>E<gt>' on the command line, but can't find
the name of the file to which to write data destined for stderr.
d1244 1
a1244 1
=item No input file after E<lt> on command line
d1247 2
a1248 2
and found a 'E<lt>' on the command line, but can't find the name of the file
from which to read data for stdin.
d1250 1
a1250 1
=item No output file after E<gt> on command line
d1253 2
a1254 2
and found a lone 'E<gt>' at the end of the command line, so it doesn't know
where you wanted to redirect stdout.
d1256 1
a1256 1
=item No output file after E<gt> or E<gt>E<gt> on command line
d1259 2
a1260 2
and found a 'E<gt>' or a 'E<gt>E<gt>' on the command line, but can't find the
name of the file to which to write data destined for stdout.
a1281 13
=item No such array field

(F) You tried to access an array as a hash, but the field name used is
not defined.  The hash at index 0 should map all valid field names to
array indices for that to work.

=item No such field "%s" in variable %s of type %s

(F) You tried to access a field of a typed variable where the type
does not know about the field name.  The field names are looked up in
the %FIELDS hash in the type package at compile time.  The %FIELDS hash
is usually set up with the 'fields' pragma.

d1307 1
a1307 1
(F) Perl was trying to evaluate a reference to a "typeglob" (that is,
d1337 1
a1337 1
=item Not a subroutine reference in overload table
d1340 1
a1340 1
doesn't somehow point to a valid subroutine.  See L<overload>.
d1359 1
a1359 1
(F) You can't require the null filename, especially because on many machines
a1361 6
=item Null picture in formline

(F) The first argument to formline must be a valid format picture
specification.  It was found to be empty, which probably means you
supplied it an uninitialized value.  See L<perlform>.

d1372 1
a1372 1
(P) The internal pattern matching routines blew it big time.
d1378 1
a1378 8
=item Number too long

(F) Perl limits the representation of decimal numbers in programs to about
about 250 characters.  You've exceeded that length.  Future versions of
Perl are likely to eliminate this arbitrary limitation.  In the meantime,
try using scientific notation (e.g. "1e6" instead of "1_000_000").

=item Odd number of elements in hash assignment
d1380 2
a1381 9
(S) You specified an odd number of elements to initialize a hash, which
is odd, because hashes come in key/value pairs.

=item Offset outside string

(F) You tried to do a read/write/send/recv operation with an offset
pointing outside the buffer.  This is difficult to imagine.
The sole exception to this is that C<sysread()>ing past the buffer
will extend the buffer and zero pad the new area.
d1391 1
a1391 1
=item Operation `%s': no method found, %s
d1393 2
a1394 5
(F) An attempt was made to perform an overloaded operation for which
no handler was defined.  While some handlers can be autogenerated in
terms of other handlers, there is no default handler for any
operation, unless C<fallback> overloading key is specified to be
true.  See L<overload>.
d1409 1
a1409 1
=item Out of memory during request for %s
d1411 1
a1411 1
(X|F) The malloc() function returned 0, indicating there was insufficient
a1413 19
The request was judged to be small, so the possibility to trap it
depends on the way perl was compiled.  By default it is not trappable.
However, if compiled for this, Perl may use the contents of C<$^M> as
an emergency pool after die()ing with this message.  In this case the
error is trappable I<once>.

=item Out of memory during "large" request for %s

(F) The malloc() function returned 0, indicating there was insufficient
remaining memory (or virtual memory) to satisfy the request. However,
the request was judged large enough (compile-time default is 64K), so
a possibility to shut down by trapping this error is granted.

=item Out of memory during ridiculously large request

(F) You can't allocate more than 2^31+"small amount" bytes.  This error
is most likely to be caused by a typo in the Perl program. e.g., C<$arr[time]>
instead of C<$arr[$time]>.

a1452 4
=item panic: frexp

(P) The library function frexp() failed, making printf("%f") impossible.

d1473 1
a1473 1
(P) A writable lexical variable became read-only somehow within the scope.
d1559 1
a1559 1
=item Parentheses missing around "%s" list
a1591 45
=item Possible attempt to put comments in qw() list

(W) qw() lists contain items separated by whitespace; as with literal
strings, comment characters are not ignored, but are instead treated
as literal data.  (You may have used different delimiters than the
parentheses shown here; braces are also frequently used.)

You probably wrote something like this:

    @@list = qw(
	a # a comment
        b # another comment
    );

when you should have written this:

    @@list = qw(
	a
        b
    );

If you really want comments, build your list the
old-fashioned way, with quotes and commas:

    @@list = (
        'a',    # a comment
        'b',    # another comment
    );

=item Possible attempt to separate words with commas

(W) qw() lists contain items separated by whitespace; therefore commas
aren't needed to separate the items.  (You may have used different
delimiters than the parentheses shown here; braces are also frequently
used.)

You probably wrote something like this:

    qw! a, b, c !;

which puts literal commas into some of the list items.  Write it without
commas if you don't want them to appear in your data:

    qw! a b c !;

d1609 3
a1611 4
because of the strict regularization of Perl 5's grammar into unary
and list operators.  (The old open was a little of both.)  You must
put parentheses around the filehandle, or use the new "or" operator
instead of "||".
d1625 1
a1625 1
(W) The compiler found a bareword where it expected a conditional,
d1631 1
a1631 4
=item Prototype mismatch: %s vs %s

(S) The subroutine being declared or defined had previously been declared
or defined with a different function prototype.
d1633 2
a1634 1
=item Range iterator outside integer range
d1636 1
a1636 6
(F) One (or both) of the numeric arguments to the range operator ".."
are outside the range which can be represented by integers internally.
One possible workaround is to force Perl to use magical string
increment by prepending "0" to your numbers.

=item Read on closed filehandle E<lt>%sE<gt>
d1643 1
a1643 1
(F) You can't allocate more than 64K on an MS-DOS machine.
d1651 1
a1651 1
=item Recursive inheritance detected in package '%s'
a1655 17
=item Recursive inheritance detected while looking for method '%s' in package '%s'

(F) More than 100 levels of inheritance were encountered while invoking a
method.  Probably indicates an unintended loop in your inheritance hierarchy.

=item Reference found where even-sized list expected

(W) You gave a single reference where Perl was expecting a list with
an even number of elements (for assignment to a hash). This
usually means that you used the anon hash constructor when you meant 
to use parens. In any case, a hash requires key/value B<pairs>.

    %hash = { one => 1, two => 2, };	# WRONG
    %hash = [ qw/ an anon array / ];	# WRONG
    %hash = ( one => 1, two => 2, );	# right
    %hash = qw( one 1 two 2 );			# also fine

a1660 5
=item regexp *+ operand could be empty

(F) The part of the regexp subject to either the * or + quantifier
could match an empty string.

d1672 1
a1672 1
(F) The current implementation of regular expressions uses shorts as
d1693 1
a1693 1
(W) You've used an array slice (indicated by @@) to select a single element of
d1695 2
a1696 2
The difference is that C<$foo[&bar]> always behaves like a scalar, both when
assigning to it and when evaluating its argument, while C<@@foo[&bar]> behaves
d1698 1
a1698 1
subscript, which can do weird things if you're expecting only one subscript.
d1701 1
a1701 15
element as a list, you need to look into how references work, because
Perl will not magically convert between scalars and lists for you.  See
L<perlref>.

=item Scalar value @@%s{%s} better written as $%s{%s}

(W) You've used a hash slice (indicated by @@) to select a single element of
a hash.  Generally it's better to ask for a scalar value (indicated by $).
The difference is that C<$foo{&bar}> always behaves like a scalar, both when
assigning to it and when evaluating its argument, while C<@@foo{&bar}> behaves
like a list when you assign to it, and provides a list context to its
subscript, which can do weird things if you're expecting only one subscript.

On the other hand, if you were actually hoping to treat the hash
element as a list, you need to look into how references work, because
d1707 1
a1707 1
(F) Oddly, the suidperl program was invoked on a script without a setuid
a1713 1
Missing the leading C<$> from a variable C<$m> may cause this error.
d1715 1
a1715 1
=item %sseek() on unopened file
d1717 2
a1718 2
(W) You tried to use the seek() or sysseek() function on a filehandle that
was either never opened or has since been closed.
a1742 5
=item Sequence (? incomplete

(F) A regular expression ended with an incomplete extension (?.
See L<perlre>.

d1746 1
a1746 1
parenthesis.  Embedded parentheses aren't allowed.  See L<perlre>.
d1760 6
a1765 18
Also known as "500 Server error".

B<This is a CGI error, not a Perl error>.

You need to make sure your script is executable, is accessible by the user
CGI is running the script under (which is probably not the user account you
tested it under), does not rely on any environment variables (like PATH)
from the user it isn't running under, and isn't in a location where the CGI
server can't find it, basically, more or less.  Please see the following
for more information:

	http://www.perl.com/CPAN/doc/FAQs/cgi/idiots-guide.html
	http://www.perl.com/CPAN/doc/FAQs/cgi/perl-cgi-faq.html
	ftp://rtfm.mit.edu/pub/usenet/news.answers/www/cgi-faq
	http://hoohoo.ncsa.uiuc.edu/cgi/interface.html
	http://www-genome.wi.mit.edu/WWW/faqs/www-security-faq.html

You should also look at L<perlfaq9>.
d1769 1
a1769 1
(F) You tried to assign to C<$)>, and your operating system doesn't support
d1775 1
a1775 1
(F) You tried to assign to C<$E<gt>>, and your operating system doesn't support
d1781 1
a1781 1
(F) You tried to assign to C<$(>, and your operating system doesn't support
d1787 1
a1787 1
(F) You tried to assign to C<$E<lt>>, and your operating system doesn't support
d1804 1
a1804 1
=item SIG%s handler "%s" not defined
d1831 1
a1831 1
=item Stat on unopened file E<lt>%sE<gt>
d1834 1
a1834 1
on a filehandle that was either never opened or has since been closed.
a1843 14
=item Strange *+?{} on zero-length expression

(W) You applied a regular expression quantifier in a place where it
makes no sense, such as on a zero-width assertion.
Try putting the quantifier inside the assertion instead.  For example,
the way to match "abc" provided that it is followed by three
repetitions of "xyz" is C</abc(?=(?:xyz){3})/>, not C</abc(?=xyz){3}/>.

=item Stub found while resolving method `%s' overloading `%s' in package `%s'

(P) Overloading resolution over @@ISA tree may be broken by importation stubs.
Stubs should never be implicitely created, but explicit calls to C<can>
may break this.

d1857 2
a1858 2
input, which is what happened.)  See the discussion of substitution in
L<perlop/"Quote and Quote-like Operators">.
a1863 1
Missing the leading C<$> from variable C<$s> may cause this error.
a1868 1
Missing the leading C<$> from variable C<$s> may cause this error.
d1872 3
a1874 5
(S),(W) You tried to reference a substr() that pointed outside of a
string.  That is, the absolute value of the offset was larger than the
length of the string.  See L<perlfunc/substr>.  This warning is
mandatory if substr is used in an lvalue context (as the left hand side
of an assignment or as a subroutine argument for example).
d1876 1
a1876 1
=item suidperl is no longer needed since %s
d1896 1
a1896 1
before this, because Perl is good at understanding random input.
d1904 2
a1905 2
(A) You've accidentally run your script through the Bourne shell
instead of Perl.  Check the #! line, or manually feed your script
d1908 1
a1908 1
=item System V %s is not implemented on this machine
d1910 2
a1911 4
(F) You tried to do something with a function beginning with "sem",
"shm", or "msg" but that System V IPC is not implemented in your
machine.  In some machines the functionality can exist but be
unconfigured.  Consult your system support.
a1917 5
=item Target of goto is too deeply nested

(F) You tried to use C<goto> to reach a label that was too deeply
nested for Perl to reach.  Perl is doing you a favor by refusing.

d1921 1
a1921 1
never opened or has since been closed.
d1923 1
a1923 1
=item Test on unopened file E<lt>%sE<gt>
d1930 2
a1931 2
(F) Assignment to C<$[> is now strictly circumscribed, and interpreted as
a compiler directive.  You may say only one of
d1948 1
a1948 1
=item The crypt() function is unimplemented due to excessive paranoia
d1952 1
a1952 1
think the U.S. Government thinks it's a secret, or at least that they
a1971 22
=item Too late for "B<-T>" option

(X) The #! line (or local equivalent) in a Perl script contains the
B<-T> option, but Perl was not invoked with B<-T> in its command line.
This is an error because, by the time Perl discovers a B<-T> in a
script, it's too late to properly taint everything from the environment.
So Perl gives up.

If the Perl script is being executed as a command using the #!
mechanism (or its local equivalent), this error can usually be fixed
by editing the #! line so that the B<-T> option is a part of Perl's
first argument: e.g. change C<perl -n -T> to C<perl -T -n>.

If the Perl script is being executed as C<perl scriptname>, then the
B<-T> option must appear on the command line: C<perl -T scriptname>.

=item Too late for "-%s" option

(X) The #! line (or local equivalent) in a Perl script contains the
B<-M> or B<-m> option.  This is an error because B<-M> and B<-m> options
are not intended for use inside scripts.  Use the C<use> pragma instead.

d1977 2
a1978 2
of Perl.  Check the #! line, or manually feed your script into
Perl yourself.
d1982 1
a1982 1
(F) Perl supports a maximum of only 14 args to syscall().
d1993 1
a1993 1
=item Transliteration pattern not terminated
d1996 1
a1996 2
or y/// or y[][] construct.  Missing the leading C<$> from variables
C<$tr> or C<$y> may cause this error.
d1998 1
a1998 1
=item Transliteration replacement not terminated
d2011 2
a2012 2
certain type.  Arrays must be @@NAME or C<@@{EXPR}>.  Hashes must be
%NAME or C<%{EXPR}>.  No implicit dereferencing is allowed--use the
d2017 2
a2018 7
(W) A umask of 222 is incorrect.  It should be 0222, because octal
literals always start with 0 in Perl, as in C.

=item umask not implemented

(F) Your machine doesn't implement the umask function and you tried
to use it to restrict permissions for yourself (EXPR & 0700).
a2073 5
=item Undefined value assigned to typeglob

(W) An undefined value was assigned to a typeglob, a la C<*foo = undef>.
This does nothing.  It's possible that you really mean C<undef *foo>.

d2081 1
a2081 1
(F) There are no byte-swapping functions for a machine with this byte order.
d2087 1
a2087 1
the matching parenthesis.  See L<perlre>.
d2104 1
a2104 1
(W) You used a bareword that might someday be claimed as a reserved word.
d2108 1
a2108 1
=item Unrecognized character %s
d2110 2
a2111 3
(F) The Perl parser has no idea what to do with the specified character
in your Perl script (or eval).  Perhaps you tried to run a compressed
script, a binary program, or a directory as a Perl program.
d2118 1
a2118 1
=item Unrecognized switch: -%s  (-h will show valid options)
d2128 1
a2128 1
because you forgot to chop() or chomp() it off.  See L<perlfunc/chomp>.
a2133 8
=item Unsupported function fork

(F) Your version of executable does not support forking.

Note that under some systems, like OS/2, there may be different flavors of
Perl executables, some of which may support fork, some not. Try changing
the name you call Perl by to C<perl_>, C<perl__>, and so on.

d2136 1
a2136 1
(F) This machine doesn't implement the indicated function, apparently.
d2144 1
a2144 1
=item Unterminated E<lt>E<gt> operator
a2150 12
=item Use of "$$<digit>" to mean "${$}<digit>" is deprecated

(D) Perl versions before 5.004 misinterpreted any type marker followed
by "$" and a digit.  For example, "$$0" was incorrectly taken to mean
"${$}0" instead of "${$0}".  This bug is (mostly) fixed in Perl 5.004.

However, the developers of Perl 5.004 could not fix this bug completely,
because at least two widely-used modules depend on the old meaning of
"$$0" in a string.  So Perl 5.004 still interprets "$$<digit>" in the
old (broken) way inside strings; but it generates this message as a
warning.  And in Perl 5.005, this special treatment will cease.

d2153 1
a2153 1
(D) This was an ill-advised attempt to emulate a poorly defined B<awk> feature.
d2158 1
a2158 1
(D) This variable magically turned on multi-line pattern matching, both for
d2165 2
a2166 2
(F) You attempted to use a feature of printf that is accessible from
only C.  This usually means there's a better way to do it in Perl.
d2168 7
a2174 1
=item Use of bare E<lt>E<lt> to mean E<lt>E<lt>"" is deprecated
d2177 1
a2177 1
wish to use an empty line as the terminator of the here-document.
a2184 37
=item Use of inherited AUTOLOAD for non-method %s() is deprecated

(D) As an (ahem) accidental feature, C<AUTOLOAD> subroutines are looked
up as methods (using the C<@@ISA> hierarchy) even when the subroutines to
be autoloaded were called as plain functions (e.g. C<Foo::bar()>), not
as methods (e.g. C<Foo-E<gt>bar()> or C<$obj-E<gt>bar()>).

This bug will be rectified in Perl 5.005, which will use method lookup
only for methods' C<AUTOLOAD>s.  However, there is a significant base
of existing code that may be using the old behavior.  So, as an
interim step, Perl 5.004 issues an optional warning when non-methods
use inherited C<AUTOLOAD>s.

The simple rule is:  Inheritance will not work when autoloading
non-methods.  The simple fix for old code is:  In any module that used to
depend on inheriting C<AUTOLOAD> for non-methods from a base class named
C<BaseClass>, execute C<*AUTOLOAD = \&BaseClass::AUTOLOAD> during startup.

In code that currently says C<use AutoLoader; @@ISA = qw(AutoLoader);> you
should remove AutoLoader from @@ISA and change C<use AutoLoader;> to
C<use AutoLoader 'AUTOLOAD';>.

=item Use of reserved word "%s" is deprecated

(D) The indicated bareword is a reserved word.  Future versions of perl
may use it as a keyword, so you're better off either explicitly quoting
the word in a manner appropriate for its context of use, or using a
different name altogether.  The warning can be suppressed for subroutine
names by either adding a C<&> prefix, or using a package qualifier,
e.g. C<&our()>, or C<Foo::our()>.

=item Use of %s is deprecated

(D) The construct indicated is no longer recommended for use, generally
because there's a better way to do it, and also because the old way has
bad side effects.

a2190 4
=item Useless use of "re" pragma

(W) You did C<use re;> without any arguments.   That isn't very useful.

d2222 1
a2222 14
=item untie attempted while %d inner references still exist

(W) A copy of the object returned from C<tie> (or C<tied>) was still
valid when C<untie> was called.

=item Value of %s can be "0"; test with defined()

(W) In a conditional expression, you used <HANDLE>, <*> (glob), C<each()>,
or C<readdir()> as a boolean value.  Each of these constructs can return a
value of "0"; that would make the conditional expression false, which is
probably not what you intended.  When using these constructs in conditional
expressions, test their values with the C<defined> operator.

=item Variable "%s" is not imported%s
d2230 1
a2230 45
=item Variable "%s" may be unavailable

(W) An inner (nested) I<anonymous> subroutine is inside a I<named>
subroutine, and outside that is another subroutine; and the anonymous
(innermost) subroutine is referencing a lexical variable defined in
the outermost subroutine.  For example:

   sub outermost { my $a; sub middle { sub { $a } } }

If the anonymous subroutine is called or referenced (directly or
indirectly) from the outermost subroutine, it will share the variable
as you would expect.  But if the anonymous subroutine is called or
referenced when the outermost subroutine is not active, it will see
the value of the shared variable as it was before and during the
*first* call to the outermost subroutine, which is probably not what
you want.

In these circumstances, it is usually best to make the middle
subroutine anonymous, using the C<sub {}> syntax.  Perl has specific
support for shared variables in nested anonymous subroutines; a named
subroutine in between interferes with this feature.

=item Variable "%s" will not stay shared

(W) An inner (nested) I<named> subroutine is referencing a lexical
variable defined in an outer subroutine.

When the inner subroutine is called, it will probably see the value of
the outer subroutine's variable as it was before and during the
*first* call to the outer subroutine; in this case, after the first
call to the outer subroutine is complete, the inner and outer
subroutines will no longer share a common value for the variable.  In
other words, the variable will no longer be shared.

Furthermore, if the outer subroutine is anonymous and references a
lexical variable outside itself, then the outer and inner subroutines
will I<never> share the given variable.

This problem can usually be solved by making the inner subroutine
anonymous, using the C<sub {}> syntax.  When inner anonymous subs that
reference variables in outer subroutines are called or referenced,
they are automatically rebound to the current values of such
variables.

=item Variable syntax
d2233 2
a2234 13
of Perl.  Check the #! line, or manually feed your script into
Perl yourself.

=item perl: warning: Setting locale failed.

(S) The whole warning message will look something like:

	perl: warning: Setting locale failed.
	perl: warning: Please check that your locale settings:
	        LC_ALL = "En_US",
	        LANG = (unset)
	    are supported and installed on your system.
	perl: warning: Falling back to the standard locale ("C").
d2236 1
a2236 9
Exactly what were the failed locale settings varies.  In the above the
settings were that the LC_ALL was "En_US" and the LANG had no value.
This error means that Perl detected that you and/or your system
administrator have set up the so-called variable system but Perl could
not use those settings.  This was not dead serious, fortunately: there
is a "default locale" called "C" that Perl can and will use, the
script will be run.  Before you really fix the problem, however, you
will get the same error message each time you run Perl.  How to really
fix the problem can be found in L<perllocale> section B<LOCALE PROBLEMS>.
d2238 2
a2239 1
=item Warning: something's wrong
d2241 1
a2241 9
(W) You passed warn() an empty string (the equivalent of C<warn "">) or
you called it with no args and C<$_> was empty.

=item Warning: unable to close filehandle %s properly

(S) The implicit close() done by an open() got an error indication on the
close().  This usually indicates your file system ran out of disk space.

=item Warning: Use of "%s" without parentheses is ambiguous
d2258 1
a2258 1
So put in parentheses to say what you really mean.
d2291 1
a2291 1
(F) And you probably never will, because you probably don't have the
d2312 1
a2312 1
of backslashes is grandfathered on the right-hand side of a
d2317 1
a2317 1
=item '|' and 'E<lt>' may not both be specified on command line
d2321 1
a2321 1
'E<lt>'.  Only one STDIN stream to a customer, please.
d2323 1
a2323 1
=item '|' and 'E<gt>' may not both be specified on command line
a2336 33

=item Got an error from DosAllocMem

(P) An error peculiar to OS/2.  Most probably you're using an obsolete
version of Perl, and this should not happen anyway.

=item Malformed PERLLIB_PREFIX

(F) An error peculiar to OS/2.  PERLLIB_PREFIX should be of the form

    prefix1;prefix2

or

    prefix1 prefix2

with nonempty prefix1 and prefix2.  If C<prefix1> is indeed a prefix
of a builtin library search path, prefix2 is substituted.  The error
may appear if components are not found, or are too long.  See
"PERLLIB_PREFIX" in F<README.os2>.

=item PERL_SH_DIR too long

(F) An error peculiar to OS/2. PERL_SH_DIR is the directory to find the
C<sh>-shell in.  See "PERL_SH_DIR" in F<README.os2>.

=item Process terminated by SIG%s

(W) This is a standard message issued by OS/2 applications, while *nix
applications die in silence.  It is considered a feature of the OS/2
port.  One can easily disable this by appropriate sighandlers, see
L<perlipc/"Signals">.  See also "Process terminated by SIGTERM/SIGINT"
in F<README.os2>.
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d12 1
a12 1
    (S) A severe warning (default).
d18 3
a20 15
The majority of messages from the first three classifications above (W,
D & S) can be controlled using the C<warnings> pragma. 

If a message can be controlled by the C<warnings> pragma, its warning
category is included with the classification letter in the description
below.

Optional warnings are enabled by using the C<warnings> pragma or the B<-w>
and B<-W> switches. Warnings may be captured by setting C<$SIG{__WARN__}>
to a reference to a routine that will be called on each warning instead
of printing it.  See L<perlvar>.

Default warnings are always enabled unless they are explicitly disabled
with the C<warnings> pragma or the B<-X> switch.

d22 1
a22 3
L<perlfunc/eval>.  In almost all cases, warnings may be selectively
disabled or promoted to fatal errors using the C<warnings> pragma.
See L<warnings>.
d26 1
a26 2
Since the messages are listed in alphabetical order, the symbols
C<"%(-?@@> sort before the letters, while C<[> and C<\> sort after.
d30 5
a34 1
=item "%s" variable %s masks earlier declaration in same %s
d36 3
a38 1
(W misc) A "my" or "our" variable has been redeclared in the current scope or statement,
a43 11
=item "my sub" not yet implemented

(F) Lexically scoped subroutines are not yet implemented.  Don't try that
yet.

=item "my" variable %s can't be in a package

(F) Lexically scoped variables aren't in a package, so it doesn't make sense
to try to declare one with a package qualifier on the front.  Use local()
if you want to localize a package variable.

a48 5
=item "our" variable %s redeclared

(W misc) You seem to have already declared the same global once before in the
current lexical scope.

a53 30
=item '!' allowed only after types %s

(F) The '!' is allowed in pack() and unpack() only after certain types.
See L<perlfunc/pack>.

=item / cannot take a count

(F) You had an unpack template indicating a counted-length string,
but you have also specified an explicit size for the string.
See L<perlfunc/pack>.

=item / must be followed by a, A or Z

(F) You had an unpack template indicating a counted-length string,
which must be followed by one of the letters a, A or Z
to indicate what sort of string is to be unpacked.
See L<perlfunc/pack>.

=item / must be followed by a*, A* or Z*

(F) You had a pack template indicating a counted-length string,
Currently the only things that can have their length counted are a*, A* or Z*.
See L<perlfunc/pack>.

=item / must follow a numeric type

(F) You had an unpack template that contained a '#',
but this did not follow some numeric unpack specification.
See L<perlfunc/pack>.

a59 18
=item /%s/: Unrecognized escape \\%c passed through

(W regexp) You used a backslash-character combination which is not recognized
by Perl.  This combination appears in an interpolated variable or a 
C<'>-delimited regular expression.  The character was understood literally.

=item /%s/: Unrecognized escape \\%c in character class passed through

(W regexp) You used a backslash-character combination which is not recognized
by Perl inside character classes.  The character was understood literally.

=item /%s/ should probably be written as "%s"

(W syntax) You have used a pattern where Perl expected to find a string,
as in the first argument to C<join>.  Perl will treat the true
or false result of matching the pattern against $_ as the string,
which is probably not what you had in mind.

d62 1
a62 1
(W syntax) You've run afoul of the rule that says that any list operator followed
d66 1
a66 11
=item %s() called too early to check prototype

(W prototype) You've called a function that has a prototype before the parser saw a
definition or declaration for it, and Perl could not check that the call
conforms to the prototype.  You need to either add an early prototype
declaration for the subroutine in question, or move the subroutine
definition ahead of the call to get proper prototype checking.  Alternatively,
if you are certain that you're calling the function correctly, you may put
an ampersand before the name to avoid the warning.  See L<perlsub>.

=item %s argument is not a HASH or ARRAY element
d68 1
a68 1
(F) The argument to exists() must be a hash or array element, such as:
d71 1
a71 1
    $ref->{"susie"}[12]
d73 1
a73 1
=item %s argument is not a HASH or ARRAY element or slice
d75 1
a75 1
(F) The argument to delete() must be either a hash or array element, such as:
d78 1
a78 1
    $ref->{"susie"}[12]
d80 1
a80 1
or a hash or array slice, such as:
d82 1
a82 1
    @@foo[$bar, $baz, $xyzzy]
a84 5
=item %s argument is not a subroutine name

(F) The argument to exists() for C<exists &sub> must be a subroutine
name, and not a subroutine call.  C<exists &sub()> will generate this error.

d110 1
a110 1
(W regexp) The pattern you've specified would be an infinite loop if the
d115 1
a115 1
(S internal) The symbol in question was declared but somehow went out of scope
a117 7
=item %s package attribute may clash with future reserved word: %s

(W reserved) A lowercase attribute name was used that had a package-specific handler.
That name might have a meaning to Perl itself some day, even though it
doesn't yet.  Perhaps you should use a mixed-case attribute name, instead.
See L<attributes>.

d146 1
a146 1
=item (in cleanup) %s
d148 1
a148 1
(W misc) This prefix usually indicates that a DESTROY() method raised
d158 1
a158 1
=item (Missing semicolon on previous line?)
d194 1
a194 1
=item <> should be quotes
d196 1
a196 6
(F) You wrote C<< require <file> >> when you should have written
C<require 'file'>.

=item accept() on closed socket %s

(W closed) You tried to do an accept on a closed socket.  Did you forget to check
d205 1
a205 1
(W misc) The pattern match (//), substitution (s///), and transliteration (tr///)
d218 1
a218 1
(W ambiguous)(S) You said something that may not be interpreted the way
d224 1
a224 1
(W ambiguous) A subroutine you have declared has the same name as a Perl keyword,
d236 1
a236 2
to be an object method (see L<perlsub/"Subroutine Attributes">
or L<attributes>).
d247 1
a247 1
(W numeric) The indicated string was fed as an argument to an operator that
d253 1
a253 1
(D deprecated) Really old Perl let you omit the @@ on array names in some spots.  This
d272 1
a272 1
(P internal) All SV objects are supposed to be allocated from arenas that will
d278 1
a278 1
(P internal) Perl maintains a reference counted internal table of strings to
d285 1
a285 1
(W debugging) Mortalized values are supposed to be freed by the free_tmps()
d293 1
a293 1
(P internal) The reference counts got screwed up on symbol aliases.
d297 1
a297 1
(W internal) Perl went to decrement the reference count of a scalar to see if it
a303 6
=item Attempt to join self

(F) You tried to join a thread from within itself, which is an
impossible task.  You may be joining the wrong thread, or you may
need to move the join() to some other thread.

d306 1
a306 1
(W pack) You tried to pass a temporary value (like the result of a
d315 1
a315 1
(W substr) You supplied a reference as the first argument to substr() used
a325 6
=item Bad evalled substitution pattern

(F) You've used the /e switch to evaluate the replacement for a
substitution, but perl found a syntax error in the code to evaluate,
most likely an unexpected right brace '}'.

d334 1
a334 1
(S malloc) An internal routine called free() on something that had never been
a366 6
=item Bad realloc() ignored

(S malloc) An internal routine called realloc() on something that had never been
malloc()ed in the first place. Mandatory, but can be disabled by
setting environment variable C<PERL_BADFREE> to 1.

d396 1
a396 1
(W bareword) You used a qualified bareword of the form C<Foo::>, but
a399 16
=item Bareword found in conditional

(W bareword) The compiler found a bareword where it expected a conditional,
which often indicates that an || or && was parsed as part of the
last argument of the previous construct, for example:

    open FOO || die;

It may also indicate a misspelled constant that has been interpreted
as a bareword:

    use constant TYPO => 1;
    if (TYOP) { print "foo" }

The C<strict> pragma is useful in avoiding such errors.

d413 1
a413 7
=item Binary number > 0b11111111111111111111111111111111 non-portable

(W portable) The binary number you specified is larger than 2**32-1
(4294967295) and therefore non-portable between systems.  See
L<perlport> for more on portability concerns.

=item bind() on closed socket %s
d415 1
a415 1
(W closed) You tried to do a bind on a closed socket.  Did you forget to check
a417 4
=item Bit vector size > 32 non-portable

(W portable) Using bit vector sizes larger than 32 is non-portable.

a421 6
=item Buffer overflow in prime_env_iter: %s

(W internal) A warning peculiar to VMS.  While Perl was preparing to iterate over
%ENV, it encountered a logical name or symbol definition which was too long,
so it was truncated to the string shown.

d424 1
a424 1
(F) A subroutine invoked from an external package via call_sv()
d427 1
a427 1
=item Can't "goto" out of a pseudo block
d439 1
a439 1
=item Can't "last" outside a loop block
d444 3
a446 4
"loopish" block, as doesn't a block given to sort(), map() or grep().
You can usually double the curlies to get the same effect though,
because the inner curlies will be considered a block that loops once.
See L<perlfunc/last>.
d448 1
a448 1
=item Can't "next" outside a loop block
d452 3
a454 11
count as a "loopish" block, as doesn't a block given to sort(), map()
or grep().  You can usually double the curlies to get the same effect
though, because the inner curlies will be considered a block that
loops once.  See L<perlfunc/next>.

=item Can't read CRTL environ

(S) A warning peculiar to VMS.  Perl tried to read an element of %ENV
from the CRTL's internal environment array and discovered the array was
missing.  You need to figure out where your CRTL misplaced its environ
or define F<PERL_ENV_TABLES> (see L<perlvms>) so that environ is not searched.
d456 1
a456 1
=item Can't "redo" outside a loop block
d460 3
a462 4
count as a "loopish" block, as doesn't a block given to sort(), map()
or grep().  You can usually double the curlies to get the same effect
though, because the inner curlies will be considered a block that
loops once.  See L<perlfunc/redo>.
d471 1
a471 1
(S internal) A warning intended to only be printed while running within the debugger, indicating
d554 1
a554 5
=item Can't declare class for non-scalar %s in "%s"

(S) Currently, only scalar variables can declared with a specific class
qualifier in a "my" or "our" declaration.  The semantics may be extended
for other types of variables in future.
d556 2
a557 4
=item Can't declare %s in "%s"

(F) Only scalar, array, and hash variables may be declared as "my" or
"our" variables.  They must have ordinary identifiers as names.
d561 1
a561 1
(S inplace) The creation of the new file failed for the indicated reason.
d569 1
a569 1
=item Can't do inplace edit: %s would not be unique
d571 1
a571 3
(S inplace) Your filesystem does not support filenames longer than 14
characters and Perl was unable to create a unique filename during
inplace editing with the B<-i> switch.  The file was ignored.
d575 1
a575 1
(S inplace) You tried to use the B<-i> switch on a special file, such as a file in
d601 1
a601 1
=item Can't do {n,m} with n > m
d613 1
a613 1
(W exec) An system(), exec(), or piped open call could not execute the named
a701 9
=item Can't ignore signal CHLD, forcing to default

(W signal) Perl has detected that it is being run with the SIGCHLD signal
(sometimes known as SIGCLD) disabled.  Since disabling this signal
will interfere with proper determination of exit status of child
processes, Perl has reset the signal to its default value.
This situation typically indicates that the parent program under
which Perl may be running (e.g. cron) is being very careless.

d718 1
a718 1
(F) You said something like C<< local $ar->{'key'} >>, where $ar is
d721 1
a721 1
element directly -- C<< local $ar->[$ar->[0]{'key'}] >>.
d730 1
a730 1
=item Can't locate %s
d732 5
a736 7
(F) You said to C<do> (or C<require>, or C<use>) a file that couldn't be
found. Perl looks for the file in all the locations mentioned in @@INC,
unless the file name included the full path to the file.  Perhaps you need
to set the PERL5LIB or PERL5OPT environment variable to say where the extra
library is, or maybe the script needs to add the library name to @@INC.  Or
maybe you just misspelled the name of the file.  See L<perlfunc/require>
and L<lib>.
d746 1
a746 1
(W syntax) The @@ISA array contained the name of another package that doesn't seem
a757 5
=item Can't modify non-lvalue subroutine call

(F) Subroutines meant to be used in lvalue context should be declared as
such, see L<perlsub/"Lvalue subroutines">.

d770 1
a770 1
(S inplace) The implicit opening of a file through use of the C<< <> >>
d778 1
a778 1
(W pipe) You tried to say C<open(CMD, "|cmd|")>, which is not supported.  You can
d780 1
a780 1
IPC::Open2.  Alternately, direct the pipe's output to a file using ">",
d786 1
a786 1
couldn't open the file specified after '2>' or '2>>' on the
d792 1
a792 1
couldn't open the file specified after '<' on the command line for reading.
d797 1
a797 1
couldn't open the file specified after '>' or '>>' on the command
a815 6
=item Can't remove %s: %s, skipping file 

(S inplace) You requested an inplace edit without creating a backup file.  Perl
was unable to remove the original file to replace it with the modified
file.  The file was left unmodified.

d818 2
a819 2
(S inplace) The rename done by the B<-i> switch failed for some reason,
probably because you don't have write permission to the directory.
a835 6
=item Can't return %s from lvalue subroutine

(F) Perl detected an attempt to return illegal lvalues (such
as temporary or readonly values) from a subroutine used as an lvalue.
This is not allowed.

d892 1
a892 1
You mentioned $a or $b in the same line as the <=> or cmp operator,
d907 1
a907 1
=item Can't use \%c to mean $%c in expression
d909 1
a909 1
(W syntax) In an ordinary expression, backslash is a unary operator that creates
d915 1
a915 1
=item Can't use bareword ("%s") as %s ref while "strict refs" in use
a943 5
=item Can't weaken a nonreference

(F) You attempted to weaken something that was not a reference.  Only
references can be weakened.

d950 1
a950 1
=item Can't find an opnumber for "%s"
d955 1
a955 1
=item Can't resolve method `%s' overloading `%s' in package `%s'
a960 13
=item Character class [:%s:] unknown

(F) The class in the character class [: :] syntax is unknown.
See L<perlre>.

=item Character class syntax [%s] belongs inside character classes

(W unsafe) The character class constructs [: :], [= =], and [. .]  go
I<inside> character classes, the [] are part of the construct,
for example: /[012[:alpha:]345]/.  Note that [= =] and [. .]
are not currently implemented; they are simply placeholders for
future extensions.

d963 1
a963 1
(W regexp) Within regular expression character classes ([]) the syntax beginning
d969 8
d979 1
a979 1
(W regexp) Within regular expression character classes ([]) the syntax
d985 1
a985 1
=item chmod() mode argument is missing initial 0
d987 1
a987 1
(W chmod) A novice will sometimes say
d994 1
a994 1
=item Close on unopened file <%s>
d996 1
a996 1
(W unopened) You tried to close a filehandle that was never opened.
d1006 1
a1006 1
(W regexp) The regular expression engine uses recursion in complex situations
d1016 1
a1016 1
=item connect() on closed socket %s
d1018 1
a1018 1
(W closed) You tried to do a connect on a closed socket.  Did you forget to check
d1031 1
a1031 1
(S|W redefine) You redefined a subroutine which had previously been eligible for
d1037 1
a1037 1
(W misc) You undefined a subroutine which had previously been eligible for
a1040 7
=item constant(%s): %s

(F) The parser found inconsistencies either while attempting to define an
overloaded constant, or when trying to find the character name specified
in the C<\N{...}> escape.  Perhaps you forgot to load the corresponding
C<overload> or C<charnames> pragma?  See L<charnames> and L<overload>.

a1044 4
=item CORE::%s is not a keyword

(F) The CORE:: namespace is reserved for Perl keywords.

d1061 1
a1061 1
(W recursion) This subroutine has called itself (directly or indirectly) 100
a1065 12
=item defined(@@array) is deprecated

(D deprecated) defined() is not usually useful on arrays because it checks for an
undefined I<scalar> value.  If you want to see if the array is empty,
just use C<if (@@array) { # not empty }> for example.  

=item defined(%hash) is deprecated

(D deprecated) defined() is not usually useful on hashes because it checks for an
undefined I<scalar> value.  If you want to see if the hash is empty,
just use C<if (%hash) { # not empty }> for example.  

d1068 1
a1068 1
(F) In a here document construct like C<<<FOO>, the label
d1072 1
a1072 5
=item Did not produce a valid header

See Server error.

=item (Did you mean &%s instead?)
d1076 1
a1076 6
=item (Did you mean "local" instead of "our"?)

(W misc) Remember that "our" does not localize the declared global variable.
You have declared it again in the same lexical scope, which seems superfluous.

=item (Did you mean $ or @@ instead of %?)
d1086 1
a1086 1
=item (Do you need to predeclare %s?)
a1097 4
=item Document contains no data

See Server error.

d1108 1
a1108 1
(S malloc) An internal routine called free() on something that had already
d1118 1
a1118 7
=item %s failed--call queue aborted

(F) An untrapped exception was raised while executing a CHECK, INIT, or
END subroutine.  Processing of the remainder of the queue of such
routines has been prematurely ended.

=item entering effective %s failed
d1120 2
a1121 2
(F) While under the C<use filetest> pragma, switching the real and
effective uids or gids failed.
d1165 1
a1165 6
(W exiting) You are exiting an eval by unconventional means, such as
a goto, or a loop control statement.

=item Exiting format via %s

(W exiting) You are exiting an eval by unconventional means, such as
d1170 1
a1170 1
(W exiting) You are exiting a rather special block construct (like a sort block or
d1176 1
a1176 1
(W exiting) You are exiting a subroutine by unconventional means, such as
d1181 1
a1181 1
(W exiting) You are exiting a substitution by unconventional means, such as
d1186 1
a1186 1
(W misc) You are blessing a reference to a zero length string.  This has
a1190 7
=item false [] range "%s" in regexp

(W regexp) A character class range must start and end at a literal character, not
another character class like C<\d> or C<[:alpha:]>.  The "-" in your false
range is interpreted as a literal "-".  Consider quoting the "-",  "\-".
See L<perlre>.

d1205 1
a1205 1
(W unopened) An I/O operation was attempted on a filehandle that was never initialized.
d1209 1
a1209 1
=item Filehandle %s opened only for input
d1211 1
a1211 1
(W io) You tried to write on a read-only filehandle.  If you
d1213 2
a1214 2
"+<" or "+>" or "+>>" instead of with "<" or nothing.  If
you intended only to write the file, use ">" or ">>".  See
d1217 1
a1217 1
=item Filehandle %s opened only for output
d1219 4
a1222 4
(W io) You tried to read from a filehandle opened only for writing.  If you
intended it to be a read/write filehandle, you needed to open it with
"+<" or "+>" or "+>>" instead of with "<" or nothing.  If
you intended only to read from the file, use "<".  See
a1238 6
=item flock() on closed filehandle %s

(W closed) The filehandle you're attempting to flock() got itself closed some
time before now.  Check your logic flow.  flock() operates on filehandles.
Are you attempting to call flock() on a dirhandle by the same name?

d1241 1
a1241 1
(W redefine) You redefined a format.  To suppress this warning, say
d1244 1
a1244 1
	no warnings;
d1255 1
a1255 1
(W syntax) You said
d1275 1
a1275 1
=item get%sname() on closed socket %s
d1277 1
a1277 1
(W closed) You tried to get a socket or peer socket name on a closed socket.
a1284 14
=item glob failed (%s)

(W glob) Something went wrong with the external program(s) used for C<glob>
and C<< <*.c> >>.  Usually, this means that you supplied a C<glob>
pattern that caused the external program to fail and exit with a nonzero
status.  If the message indicates that the abnormal exit resulted in a
coredump, this may also mean that your csh (C shell) is broken.  If so,
you should change all of the csh-related variables in config.sh:  If you
have tcsh, make the variables refer to it as if it were csh (e.g.
C<full_csh='/usr/bin/tcsh'>); otherwise, make them all empty (except that
C<d_csh> should be C<'undef'>) so that Perl will think csh is missing.
In either case, after editing config.sh, run C<./Configure -S> and
rebuild Perl.

d1295 2
a1296 3
must either be lexically scoped (using "my"), declared beforehand using
"our", or explicitly qualified to say which package the global variable
is in (using "::").
d1305 1
a1305 1
(S internal) A routine asked for a symbol from a symbol table that ought to have
d1311 1
a1311 1
(D deprecated) Really old Perl let you omit the % on hash names in some spots.  This
a1313 6
=item Hexadecimal number > 0xffffffff non-portable

(W portable) The hexadecimal number you specified is larger than 2**32-1
(4294967295) and therefore non-portable between systems.  See
L<perlport> for more on portability concerns.

d1321 1
a1321 1
=item Ill-formed CRTL environ value "%s"
d1323 6
a1328 10
(W internal) A warning peculiar to VMS.  Perl tried to read the CRTL's internal
environ array, and encountered an element without the C<=> delimiter
used to spearate keys from values.  The element is ignored.

=item Ill-formed message in prime_env_iter: |%s|

(W internal) A warning peculiar to VMS.  Perl tried to read a logical name
or CLI symbol definition when preparing to iterate over %ENV, and
didn't see the expected delimiter between key and value, so the
line was ignored.
d1332 16
a1347 5
(F) Perl normally treats carriage returns in the program text as it
would any other whitespace, which means you should never see this
error when Perl was built using standard options.  For some reason,
your version of Perl appears to have been built without this support.
Talk to your Perl administrator.
d1359 1
a1359 5
=item Illegal binary digit %s

(F) You used a digit other than 0 or 1 in a binary number.

=item Illegal octal digit %s
d1363 1
a1363 1
=item Illegal binary digit %s ignored
d1365 1
a1365 6
(W digit) You may have tried to use a digit other than 0 or 1 in a binary number.
Interpretation of the binary number stopped before the offending digit.

=item Illegal octal digit %s ignored

(W digit) You may have tried to use an 8 or 9 in a octal number.  Interpretation
d1368 1
a1368 1
=item Illegal hexadecimal digit %s ignored
d1370 2
a1371 2
(W digit) You may have tried to use a character other than 0 - 9 or A - F, a - f
in a hexadecimal number.  Interpretation of the hexadecimal number stopped
a1373 5
=item Illegal number of bits in vec

(F) The number of bits in vec() (the third argument) must be a power of
two from 1 to 32 (or 64, if your platform supports that).

d1413 1
a1413 1
=item Integer overflow in %s number
d1415 9
a1423 9
(W overflow) The hexadecimal, octal or binary number you have specified either
as a literal or as an argument to hex() or oct() is too big for your
architecture, and has been converted to a floating point number.  On a
32-bit architecture the largest hexadecimal, octal or binary number
representable without overflow is 0xFFFFFFFF, 037777777777, or
0b11111111111111111111111111111111 respectively.  Note that Perl
transparently promotes all numbers to a floating point representation
internally--subject to loss of precision errors in subsequent
operations.
d1439 14
d1457 1
a1457 11
=item Invalid %s attribute: %s

The indicated attribute for a subroutine or variable was not recognized
by Perl or by a user-supplied handler.  See L<attributes>.

=item Invalid %s attributes: %s

The indicated attributes for a subroutine or variable were not recognized
by Perl or by a user-supplied handler.  See L<attributes>.

=item invalid [] range "%s" in regexp
d1464 1
a1464 1
(W printf) Perl does not understand the given format conversion.
a1466 7
=item Invalid separator character %s in attribute list

(F) Something other than a colon or whitespace was seen between the
elements of an attribute list.  If the previous attribute
had a parenthesised parameter list, perhaps that list was terminated
too soon.  See L<attributes>.

d1470 1
a1470 1
(W pack) The given character is not a valid pack type but used to be silently
d1476 1
a1476 1
(W unpack) The given character is not a valid unpack type but used to be silently
d1506 1
a1506 6
=item leaving effective %s failed

(F) While under the C<use filetest> pragma, switching the real and
effective uids or gids failed.

=item listen() on closed socket %s
d1508 1
a1508 1
(W closed) You tried to do a listen on a closed socket.  Did you forget to check
a1510 6
=item Lvalue subs returning %s not implemented yet

(F) Due to limitations in the current implementation, array and hash
values cannot be returned in subroutines used in lvalue context.
See L<perlsub/"Lvalue subroutines">.

a1515 4
=item Method %s not permitted

See Server error.

d1524 1
a1524 1
(W syntax) An underline in a decimal constant wasn't on a 3-digit boundary.
a1531 5
=item Missing %sbrace%s on \N{}

(F) Wrong syntax of character name literal C<\N{charname}> within
double-quotish context.

d1537 1
a1537 6
=item Missing command in piped open

(W pipe) You used the C<open(FH, "| command")> or C<open(FH, "command |")>
construction, but the command was missing or blank.

=item (Missing operator before %s?)
d1542 1
a1542 1
=item Missing right curly or square bracket
d1544 3
a1546 3
(F) The lexer counted more opening curly or square brackets than
closing ones.  As a general rule, you'll find it's missing near the place
you were last editing.
d1580 1
a1580 1
(W syntax) Multidimensional arrays aren't written like C<$foo[1,2,3]>.  They're written
a1582 5
=item Missing name in "my sub"

(F) The reserved syntax for lexically scoped subroutines requires that they
have a name with which they can be found.

d1585 1
a1585 1
(W once) Typographical errors often show up as unique variable names.
d1587 2
a1588 2
it again somehow to suppress the message.  The C<our> declaration is
provided for this purpose.
a1618 5
=item No %s specified for -%c

(F) The indicated command line switch needs a mandatory argument, but
you haven't specified one.

d1664 1
a1664 1
=item No error file after 2> or 2>> on command line
d1667 1
a1667 1
and found a '2>' or a '2>>' on the command line, but can't find
d1670 1
a1670 1
=item No input file after < on command line
d1673 1
a1673 1
and found a '<' on the command line, but can't find the name of the file
d1676 1
a1676 1
=item No output file after > on command line
d1679 1
a1679 1
and found a lone '>' at the end of the command line, so it doesn't know
d1682 1
a1682 1
=item No output file after > or >> on command line
d1685 1
a1685 1
and found a '>' or a '>>' on the command line, but can't find the
a1687 6
=item No package name allowed for variable %s in "our"

(F) Fully qualified variable names are not allowed in "our" declarations,
because that doesn't make much sense under existing semantics.  Such
syntax is reserved for future extensions.

d1703 1
a1703 1
=item No space allowed after -%c
d1705 2
a1706 2
(F) The argument to the indicated command line switch must follow immediately
after the switch, without intervening spaces.
d1708 1
a1708 1
=item No such pseudo-hash field "%s"
d1714 1
a1714 1
=item No such pseudo-hash field "%s" in variable %s of type %s
d1729 1
a1729 1
(W signal) You specified a signal name as a subscript to %SIG that was not recognized.
a1731 8
=item no UTC offset information; assuming local time is UTC

(S) A warning peculiar to VMS.  Perl was unable to find the local
timezone offset, so it's assuming that local system time is equivalent
to UTC.  If it's not, define the logical name F<SYS$TIMEZONE_DIFFERENTIAL>
to translate to the number of seconds which need to be added to UTC to
get local time.

d1793 1
a1793 1
(W syntax) A format specified more picture fields than the next line supplied.
d1809 1
a1809 1
(P debugging) Some internal routine called run() with a null opcode pointer.
a1829 14
=item Octal number > 037777777777 non-portable

(W portable) The octal number you specified is larger than 2**32-1 (4294967295)
and therefore non-portable between systems.  See L<perlport> for more
on portability concerns.

See also L<perlport> for writing portable code.

=item Octal number in vector unsupported

(F) Numbers with a leading C<0> are not currently allowed in vectors.  The
octal number interpretation of such numbers may be supported in a future
version.

d1832 1
a1832 1
(W misc) You specified an odd number of elements to initialize a hash, which
d1844 1
a1844 1
(S internal) An internal warning that the grammar is screwed up.
d1848 1
a1848 1
(S internal) An internal warning that the grammar is screwed up.
d1860 1
a1860 1
(S ambiguous) You used a variable or subroutine call where the parser was
a1865 6
=item Out of memory!

(X) The malloc() function returned 0, indicating there was insufficient
remaining memory (or virtual memory) to satisfy the request.  Perl
has no option but to exit immediately.

d1897 1
a1897 1
(W io) A single call to write() produced more lines than can fit on a page.
a1912 5
=item panic: del_backref

(P) Failed an internal consistency check while trying to reset a weak
reference.

a1950 4
=item panic: kid popen errno read

(F) forked child returned an incomprehensible message about its errno.

a1968 5
=item panic: magic_killbackrefs

(P) Failed an internal consistency check while trying to reset all weak
references to an object.

a2043 4
=item panic: %s

(P) An internal error.

d2046 1
a2046 1
(W parenthesis) You said something like
d2054 1
a2054 1
Remember that "my", "our", and "local" bind tighter than comma.
d2066 1
a2066 1
=item pid %x not a child
d2068 1
a2068 1
(W exec) A warning peculiar to VMS.  Waitpid() was asked to wait for a process which
d2074 1
a2074 1
(F) Your system has POSIX getpgrp(), which takes no argument, unlike
a2076 5
=item Possible Y2K bug: %s

(W y2k) You are concatenating the number 19 with another number, which
could be a potential Year 2000 problem.

d2079 1
a2079 1
(W qw) qw() lists contain items separated by whitespace; as with literal
d2108 1
a2108 1
(W qw) qw() lists contain items separated by whitespace; therefore commas
a2128 18
=item pragma "attrs" is deprecated, use "sub NAME : ATTRS" instead

(W deprecated) You have written somehing like this:

    sub doit
    {
        use attrs qw(locked);
    }

You should use the new declaration syntax instead.

    sub doit : locked
    {
        ...

The C<use attrs> pragma is now obsolete, and is only provided for
backward-compatibility. See L<perlsub/"Subroutine Attributes">.

d2131 1
a2131 1
(S precedence) The old irregular construct
d2144 1
a2144 1
=item Premature end of script headers
d2146 2
a2147 1
See Server error.
d2149 1
a2149 1
=item print() on closed filehandle %s
d2151 1
a2151 1
(W closed) The filehandle you're printing on got itself closed sometime before now.
d2154 1
a2154 1
=item printf() on closed filehandle %s
d2156 5
a2160 2
(W closed) The filehandle you're writing to got itself closed sometime before now.
Check your logic flow.
d2164 1
a2164 1
(S unsafe) The subroutine being declared or defined had previously been declared
d2174 1
a2174 1
=item readline() on closed filehandle %s
d2176 1
a2176 1
(W closed) The filehandle you're reading from got itself closed sometime before now.
a2178 5
=item realloc() of freed memory ignored

(S malloc) An internal routine called realloc() on something that had already
been freed.

d2185 1
a2185 1
(F debugging) You can't use the B<-D> option unless the code to produce the
d2201 1
a2201 1
(W misc) You gave a single reference where Perl was expecting a list with
a2210 5
=item Reference is already weak

(W misc) You have attempted to weaken a reference that is already weak.
Doing so has no effect.

d2213 1
a2213 1
(W internal) The internal sv_replace() function was handed a new SV with a
d2230 1
a2230 6
=item Repeat count in pack overflows

(F) You can't specify a repeat count so large that it overflows
your signed integers.  See L<perlfunc/pack>.

=item Repeat count in unpack overflows
d2232 5
a2236 2
(F) You can't specify a repeat count so large that it overflows
your signed integers.  See L<perlfunc/unpack>.
d2240 1
a2240 1
(W syntax) You wrote your assignment operator backwards.  The = must always
d2253 1
a2253 1
(W syntax) You've used an array slice (indicated by @@) to select a single element of
d2267 1
a2267 1
(W syntax) You've used a hash slice (indicated by @@) to select a single element of
d2292 1
a2292 1
(W unopened) You tried to use the seek() or sysseek() function on a filehandle that
d2305 1
a2305 1
(S internal) The internal newSVsv() routine was called to duplicate a scalar
d2310 1
a2310 1
(W semicolon) A nearby syntax error was probably caused by a missing semicolon,
d2313 1
a2313 1
=item send() on closed socket %s
d2315 1
a2315 1
(W closed) The socket you're sending to got itself closed sometime before now.
d2340 1
a2340 6
This is the error message generally seen in a browser window when trying
to run a CGI program (including SSI) over the web. The actual error
text varies widely from server to server. The most frequently-seen
variants are "500 Server error", "Method (something) not permitted",
"Document contains no data", "Premature end of script headers", and
"Did not produce a valid header".
d2367 1
a2367 1
(F) You tried to assign to C<< $> >>, and your operating system doesn't support
a2370 5
=item setpgrp can't take arguments

(F) Your system has the setpgrp() from BSD 4.2, which takes no arguments,
unlike POSIX setpgid(), which takes a process ID and process group ID.

d2379 1
a2379 1
(F) You tried to assign to C<$<>, and your operating system doesn't support
d2392 1
a2392 1
=item shutdown() on closed socket %s
d2394 1
a2394 1
(W closed) You tried to do a shutdown on a closed socket.  Seems a bit superfluous.
d2398 1
a2398 1
(W signal) The signal handler named in %SIG doesn't, in fact, exist.  Perhaps you
d2409 1
a2409 1
it by not using C<< <=> >> or C<cmp>, or by not using them correctly.
d2423 1
a2423 1
=item Stat on unopened file <%s>
d2425 1
a2425 1
(W unopened) You tried to use the stat() function (or an equivalent file test)
d2430 1
a2430 1
(W exec) You did an exec() with some statement after it other than a die().
d2438 1
a2438 1
(W regexp) You applied a regular expression quantifier in a place where it
d2452 1
a2452 1
(W redefine) You redefined a subroutine.  To suppress this warning, say
d2455 1
a2455 1
	no warnings;
d2480 1
a2480 1
(W substr),(F) You tried to reference a substr() that pointed outside of a
d2483 1
a2483 1
fatal if substr is used in an lvalue context (as the left hand side
a2490 5
=item switching effective %s is not implemented

(F) While under the C<use filetest> pragma, we cannot switch the
real and effective uids or gids.

d2525 1
a2525 1
=item syswrite() on closed filehandle %s
d2527 1
a2527 1
(W closed) The filehandle you're writing to got itself closed sometime before now.
d2537 1
a2537 1
(W unopened) You tried to use the tell() function on a filehandle that was either
d2540 1
a2540 1
=item Test on unopened file <%s>
d2542 1
a2542 1
(W unopened) You tried to invoke a file test operator on a filehandle that isn't
a2578 11
=item This Perl can't reset CRTL environ elements (%s)

=item This Perl can't set CRTL environ elements (%s=%s)

(W internal) Warnings peculiar to VMS.  You tried to change or delete an element
of the CRTL's internal environ array, but your copy of Perl wasn't
built with a CRTL that contained the setenv() function.  You'll need to
rebuild Perl with a CRTL that does, or redefine F<PERL_ENV_TABLES> (see
L<perlvms>) so that the environ array isn't the target of the change to
%ENV which produced the warning.

a2610 8
=item Too late to run %s block

(W void) A CHECK or INIT block is being defined during run time proper,
when the opportunity to run them has already passed.  Perhaps you are
loading a file with C<require> or C<do> when you should be using
C<use> instead.  Or perhaps you should put the C<require> or C<do>
inside a BEGIN block.

d2657 1
a2657 1
(W umask) A umask of 222 is incorrect.  It should be 0222, because octal
d2671 1
a2671 1
(W internal) The exit code detected an internal inconsistency in how many execution
d2676 1
a2676 1
(W internal) The exit code detected an internal inconsistency in how many
d2681 1
a2681 1
(W internal) The exit code detected an internal inconsistency in how many blocks
d2686 1
a2686 1
(W internal) The exit code detected an internal inconsistency in how many mortal
d2721 1
a2721 1
(W misc) An undefined value was assigned to a typeglob, a la C<*foo = undef>.
a2732 13
=item Unknown open() mode '%s'

(F) The second argument of 3-argument open() is not among the list
of valid modes: C<< < >>, C<< > >>, C<<< >> >>>, C<< +< >>,
C<< +> >>, C<<< +>> >>>, C<-|>, C<|->.

=item Unknown process %x sent message to prime_env_iter: %s

(P) An error peculiar to VMS.  Perl was reading values for %ENV before
iterating over it, and someone else stuck a message in the stream of
data Perl expected.  Someone's very confused, or perhaps trying to
subvert Perl's population of %ENV for nefarious purposes.

d2739 1
a2739 1
=item Unmatched right %s bracket
d2741 4
a2744 4
(F) The lexer counted more closing curly or square brackets than
opening ones, so you're probably missing a matching opening bracket.
As a general rule, you'll find the missing one (so to speak) near the
place you were last editing.
d2754 1
a2754 1
(W reserved) You used a bareword that might someday be claimed as a reserved word.
a2763 5
=item Unrecognized escape \\%c passed through

(W misc) You used a backslash-character combination which is not recognized
by Perl.

d2777 1
a2777 1
(W newline) A file operation was attempted on a filename, and that operation
d2803 1
a2803 1
=item Unterminated <> operator
d2810 1
a2810 1
=item Unterminated attribute parameter in attribute list
d2812 9
a2820 11
(F) The lexer saw an opening (left) parenthesis character while parsing an
attribute list, but the matching closing (right) parenthesis
character was not found.  You may need to add (or remove) a backslash
character to get your parentheses to balance.  See L<attributes>.

=item Unterminated attribute list

(F) The lexer found something other than a simple identifier at the start
of an attribute, and it wasn't a semicolon or the start of a
block.  Perhaps you terminated the parameter list of the previous attribute
too soon.  See L<attributes>.
d2824 1
a2824 1
(D deprecated) This was an ill-advised attempt to emulate a poorly defined B<awk> feature.
d2829 1
a2829 1
(D deprecated) This variable magically turned on multi-line pattern matching, both for
d2839 1
a2839 1
=item Use of bare << to mean <<"" is deprecated
d2841 1
a2841 1
(D deprecated) You are now encouraged to use the explicitly quoted form if you
d2846 1
a2846 1
(D deprecated) It makes a lot of work for the compiler when you clobber a
d2852 4
a2855 4
(D deprecated) As an (ahem) accidental feature, C<AUTOLOAD> subroutines are
looked up as methods (using the C<@@ISA> hierarchy) even when the subroutines
to be autoloaded were called as plain functions (e.g.  C<Foo::bar()>),
not as methods (e.g. C<< Foo->bar() >> or C<< $obj->bar() >>).
d2874 1
a2874 1
(D deprecated) The indicated bareword is a reserved word.  Future versions of perl
d2883 1
a2883 1
(D deprecated) The construct indicated is no longer recommended for use, generally
d2887 1
a2887 1
=item Use of uninitialized value%s
d2889 1
a2889 1
(W uninitialized) An undefined value was used as if it were already defined.  It was
d2891 1
a2891 1
warning assign a defined value to your variables.
d2899 1
a2899 1
(W void) You did something without a side effect in a context that does nothing
d2930 1
a2930 1
(W untie) A copy of the object returned from C<tie> (or C<tied>) was still
d2935 1
a2935 1
(W misc) In a conditional expression, you used <HANDLE>, <*> (glob), C<each()>,
a2940 7
=item Value of CLI symbol "%s" too long

(W misc) A warning peculiar to VMS.  Perl tried to read the value of an %ENV
element from a CLI symbol table, and found a resultant string longer
than 1024 characters.  The return value has been truncated to 1024
characters.

d2951 1
a2951 1
(W closure) An inner (nested) I<anonymous> subroutine is inside a I<named>
d2973 1
a2973 1
(W closure) An inner (nested) I<named> subroutine is referencing a lexical
a2998 6
=item Version number must be a constant number

(P) The attempt to translate a C<use Module n.n LIST> statement into
its equivalent C<BEGIN> block found an internal inconsistency with
the version number.

d3032 1
a3032 1
(S ambiguous) You wrote a unary operator followed by something that looks like a
d3049 1
a3049 1
=item write() on closed filehandle %s
d3051 1
a3051 1
(W closed) The filehandle you're writing to got itself closed sometime before now.
d3087 1
a3087 1
(W syntax) You assigned a bareword as a signal handler name.  Unfortunately, you
d3092 1
a3092 1
=item %cetsockopt() on closed socket %s
d3094 1
a3094 1
(W closed) You tried to get or set a socket option on a closed socket.
d3096 1
a3096 1
See L<perlfunc/getsockopt> and L<perlfunc/setsockopt>.
d3100 1
a3100 1
(W syntax) Outside of patterns, backreferences live on as variables.  The use
d3106 1
a3106 1
=item '|' and '<' may not both be specified on command line
d3110 1
a3110 1
'<'.  Only one STDIN stream to a customer, please.
d3112 1
a3112 1
=item '|' and '>' may not both be specified on command line
a3161 1
=cut
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d18 2
a19 2
The majority of messages from the first three classifications above
(W, D & S) can be controlled using the C<warnings> pragma. 
d38 4
a41 6
The messages are in alphabetical order, without regard to upper or
lower-case.  Some of these messages are generic.  Spots that vary are
denoted with a %s or other printf-style escape.  These escapes are
ignored by the alphabetical order, as are all characters other than
letters.  To look up your message, just ignore anything that is not a
letter.
d45 25
a69 1
=item accept() on closed socket %s
d71 2
a72 3
(W closed) You tried to do an accept on a closed socket.  Did you forget
to check the return value of your socket() call?  See
L<perlfunc/accept>.
d74 1
a74 1
=item Allocation too large: %lx
d76 2
a77 1
(X) You can't allocate more than 64K on an MS-DOS machine.
d84 12
a95 1
=item Ambiguous call resolved as CORE::%s(), qualify as such or use &
d97 1
a97 4
(W ambiguous) A subroutine you have declared has the same name as a Perl
keyword, and you have used the name without qualification for calling
one or the other.  Perl decided to call the builtin because the
subroutine is not imported.
d99 3
a101 4
To force interpretation as a subroutine call, either put an ampersand
before the subroutine name, or qualify the name with its package.
Alternatively, you can import the subroutine (or pretend that it's
imported with the C<use subs> pragma).
d103 1
a103 4
To silently interpret it as the Perl operator, use the C<CORE::> prefix
on the operator (e.g. C<CORE::log($x)>) or by declaring the subroutine
to be an object method (see L<perlsub/"Subroutine Attributes"> or
L<attributes>).
d105 3
a107 1
=item Ambiguous use of %s resolved as %s
d109 1
a109 3
(W ambiguous)(S) You said something that may not be interpreted the way
you thought.  Normally it's pretty easy to disambiguate it by supplying
a missing quote, operator, parenthesis pair or declaration.
d111 3
a113 1
=item '|' and '<' may not both be specified on command line
d115 1
a115 3
(F) An error peculiar to VMS.  Perl does its own command line
redirection, and found that STDIN was a pipe, and that you also tried to
redirect STDIN using '<'.  Only one STDIN stream to a customer, please.
d117 3
a119 1
=item '|' and '>' may not both be specified on command line
d121 1
a121 5
(F) An error peculiar to VMS.  Perl does its own command line
redirection, and thinks you tried to redirect stdout both to a file and
into a pipe to another command.  You need to choose one or the other,
though nothing's stopping you from piping into a program or Perl script
which 'splits' output into two streams, such as
d123 2
a124 6
    open(OUT,">$ARGV[0]") or die "Can't write to $ARGV[0]: $!";
    while (<STDIN>) {
        print;
        print OUT;
    }
    close OUT;
d126 1
a126 1
=item Applying %s to %s will act on scalar(%s)
d128 4
a131 7
(W misc) The pattern match (//), substitution (s///), and
transliteration (tr///) operators work on scalar values.  If you apply
one of them to an array or a hash, it will convert the array or hash to
a scalar value -- the length of an array, or the population info of a
hash -- and then work on that scalar value.  This is probably not what
you meant to do.  See L<perlfunc/grep> and L<perlfunc/map> for
alternatives.
d133 1
a133 1
=item Args must match #! line
d135 3
a137 4
(F) The setuid emulator requires that the arguments Perl was invoked
with match the arguments specified on the #! line.  Since some systems
impose a one-argument limit on the #! line, try combining switches;
for example, turn C<-w -U> into C<-wU>.
d139 1
a139 1
=item Arg too short for msgsnd
d141 7
a147 1
(F) msgsnd() requires a string at least as long as sizeof(long).
d158 1
a158 2
(F) The argument to delete() must be either a hash or array element,
such as:
d171 174
a344 2
name, and not a subroutine call.  C<exists &sub()> will generate this
error.
d348 2
a349 2
(W numeric) The indicated string was fed as an argument to an operator
that expected a numeric value instead.  If you're fortunate the message
d354 2
a355 2
(D deprecated) Really old Perl let you omit the @@ on array names in some
spots.  This is now heavily deprecated.
a370 5
=item Negative offset to vec in lvalue context

(F) When vec is called in an lvalue context, the second argument must be
greater than or equal to zero.

d373 3
a375 3
(P internal) All SV objects are supposed to be allocated from arenas
that will be garbage collected on exit.  An SV was discovered to be
outside any of those arenas.
d379 4
a382 4
(P internal) Perl maintains a reference counted internal table of
strings to optimize the storage and access of hash keys and other
strings.  This indicates someone tried to decrement the reference count
of a string that can no longer be found in the table.
d386 5
a390 5
(W debugging) Mortalized values are supposed to be freed by the
free_tmps() routine.  This indicates that something else is freeing the
SV before the free_tmps() routine gets a chance, which means that the
free_tmps() routine will be freeing an unreferenced scalar when it does
try to free it.
d398 6
a403 7
(W internal) Perl went to decrement the reference count of a scalar to
see if it would go to 0, and discovered that it had already gone to 0
earlier, and should have been freed, and in fact, probably was freed.
This could indicate that SvREFCNT_dec() was called too many times, or
that SvREFCNT_inc() was called too few times, or that the SV was
mortalized when it shouldn't have been, or that memory has been
corrupted.
d408 2
a409 2
impossible task.  You may be joining the wrong thread, or you may need
to move the join() to some other thread.
d422 2
a423 2
(W substr) You supplied a reference as the first argument to substr()
used as an lvalue, which is pretty strange.  Perhaps you forgot to
d428 2
a429 2
(F) You passed a buffer of the wrong size to one of msgctl(), semctl()
or shmctl().  In C parlance, the correct sizes are, respectively,
d441 3
a443 3
(F) A symbol was passed to something wanting a filehandle, but the
symbol has no filehandle associated with it.  Perhaps you didn't do an
open(), or did it in another package.
d447 8
a454 7
(S malloc) An internal routine called free() on something that had never
been malloc()ed in the first place. Mandatory, but can be disabled by
setting environment variable C<PERL_BADFREE> to 0.

This message can be seen quite often with DB_File on systems with "hard"
dynamic linking, like C<AIX> and C<OS/2>. It is a bug of C<Berkeley DB>
which is left unnoticed if C<DB> uses I<forgiving> system malloc().
a465 6
=item Badly placed ()'s

(A) You've accidentally run your script through B<csh> instead
of Perl.  Check the #! line, or manually feed your script into
Perl yourself.

d468 3
a470 3
(F) You started to name a symbol by using a package prefix, and then
didn't finish the symbol.  In particular, you can't interpolate outside
of quotes, so
d482 3
a484 3
(S malloc) An internal routine called realloc() on something that had
never been malloc()ed in the first place. Mandatory, but can be disabled
by setting environment variable C<PERL_BADFREE> to 1.
d493 2
a494 2
(P) An internal request asked to add a filehandle entry to something
that wasn't a symbol table entry.
d501 18
d521 3
a523 3
(W bareword) The compiler found a bareword where it expected a
conditional, which often indicates that an || or && was parsed as part
of the last argument of the previous construct, for example:
d527 2
a528 2
It may also indicate a misspelled constant that has been interpreted as
a bareword:
a534 12
=item Bareword "%s" not allowed while "strict subs" in use

(F) With "strict subs" in use, a bareword is only allowed as a
subroutine identifier, in curly brackets or to the left of the "=>"
symbol.  Perhaps you need to predeclare a subroutine?

=item Bareword "%s" refers to nonexistent package

(W bareword) You used a qualified bareword of the form C<Foo::>, but the
compiler saw no other uses of that namespace before that point.  Perhaps
you need to predeclare a package?

d537 2
a538 3
(F) An untrapped exception was raised while executing a BEGIN
subroutine.  Compilation stops immediately and the interpreter is
exited.
d543 4
a546 12
implies a C<BEGIN {}>) after one or more compilation errors had already
occurred.  Since the intended environment for the C<BEGIN {}> could not
be guaranteed (due to the errors), and since subsequent code likely
depends on its correct operation, Perl just gave up.

=item \1 better written as $1

(W syntax) Outside of patterns, backreferences live on as variables.
The use of backslashes is grandfathered on the right-hand side of a
substitution, but stylistically it's better to use the variable form
because other Perl programmers will expect it, and it works better if
there are more than 9 backreferences.
d556 2
a557 2
(W closed) You tried to do a bind on a closed socket.  Did you forget to
check the return value of your socket() call?  See L<perlfunc/bind>.
d565 1
a565 7
(P) Perl detected an attempt to copy an internal value that is not
copyable.

=item B<-P> not allowed for setuid/setgid script

(F) The script would have to be opened by the C preprocessor by name,
which provides a race condition that breaks security.
d569 3
a571 3
(W internal) A warning peculiar to VMS.  While Perl was preparing to
iterate over %ENV, it encountered a logical name or symbol definition
which was too long, so it was truncated to the string shown.
d578 30
a607 1
=item %s() called too early to check prototype
d609 1
a609 8
(W prototype) You've called a function that has a prototype before the
parser saw a definition or declaration for it, and Perl could not check
that the call conforms to the prototype.  You need to either add an
early prototype declaration for the subroutine in question, or move the
subroutine definition ahead of the call to get proper prototype
checking.  Alternatively, if you are certain that you're calling the
function correctly, you may put an ampersand before the name to avoid
the warning.  See L<perlsub>.
d611 4
a614 1
=item / cannot take a count
d616 8
a623 3
(F) You had an unpack template indicating a counted-length string, but
you have also specified an explicit size for the string.  See
L<perlfunc/pack>.
d630 6
d642 8
a649 1
=item Can't call method "%s" on an undefined value
d652 3
a654 2
object reference or package name contains an undefined value.  Something
like this will reproduce the error:
d656 1
a656 1
    $BADREF = undef;
d660 1
a660 8
=item Can't call method "%s" on unblessed reference

(F) A method call must know in what package it's supposed to run.  It
ordinarily finds this out from the object reference you supply, but you
didn't supply an object reference in this case.  A reference isn't an
object reference until it has been blessed.  See L<perlobj>.

=item Can't call method "%s" without a package or object reference
d663 1
a663 2
object reference or package name contains an expression that returns a
defined value which is neither an object reference nor a package name.
d666 1
a666 1
    $BADREF = 42;
d677 1
a677 8
(P) For some reason you can't check the filesystem of the script for
nosuid.

=item Can't coerce array into hash

(F) You used an array where a hash was expected, but the array has no
information on how to map from keys to array indices.  You can do that
only with arrays that have a hash reference at index 0.
d702 7
a708 1
(typeglobs), can't be forced to stop being what they are.
d712 2
a713 2
(P) An error peculiar to VMS.  The process is suffering from exhausted
quotas or other plumbing problems.
a725 5
=item Can't do inplace edit: %s is not a regular file

(S inplace) You tried to use the B<-i> switch on a special file, such as
a file in /dev, or a FIFO.  The file was ignored.

d728 1
a728 2
(S inplace) The creation of the new file failed for the indicated
reason.
d732 3
a734 3
(F) You're on a system such as MS-DOS that gets confused if you try
reading from a deleted (but still opened) file.  You have to say
C<-i.bak>, or some such.
d742 1
a742 1
=item Can't do {n,m} with n > m before << HERE in regex m/%s/
d744 2
a745 3
(F) Minima must be less than or equal to maxima. If you really want your
regexp to match something 0 times, just put {0}. The << HERE shows in the
regular expression about where the problem was discovered. See L<perlre>.
d749 2
a750 2
(P) The setegid() call failed for some reason in the setuid emulator of
suidperl.
d758 6
a763 6
(F) This typically means that ordinary perl tried to exec suidperl to do
setuid emulation, but couldn't exec it.  It looks for a name of the form
sperl5.000 in the same directory that the perl executable resides under
the name perl5.000, typically /usr/local/bin on Unix machines.  If the
file is there, check the execute permissions.  If it isn't, ask your
sysadmin why he and/or she removed it.
d767 7
a773 2
(F) This machine doesn't have either waitpid() or wait4(), so only
waitpid() without flags is emulated.
d777 2
a778 3
(F) The #! line specifies a switch that doesn't make sense at this
point.  For example, it'd be kind of silly to put a B<-x> on the #!
line.
d782 6
a787 7
(W exec) An system(), exec(), or piped open call could not execute the
named program for the indicated reason.  Typical reasons include: the
permissions were wrong on the file, the file wasn't found in
C<$ENV{PATH}>, the executable in question was compiled for another
architecture, or the #! line in a script points to an interpreter that
can't be run for similar reasons.  (Or maybe your system doesn't support
#! at all.)
d791 3
a793 3
(F) Perl was trying to execute the indicated program for you because
that's what the #! line said.  If that's not what you wanted, you may
need to mention "perl" on the #! line somewhere.
d797 2
a798 2
(F) You used the B<-S> switch, but the copies of the script to execute
found in the PATH did not have correct permissions.
d800 1
a800 6
=item Can't find an opnumber for "%s"

(F) A string of a form C<CORE::word> was given to prototype(), but there
is no builtin with the name C<word>.

=item Can't find label %s
d802 3
a804 2
(F) You said to goto a label that isn't mentioned anywhere that it's
possible for us to go to.  See L<perlfunc/goto>.
d808 2
a809 2
(F) You used the B<-S> switch, but the script to execute could not be
found in the PATH.
d811 1
a811 1
=item Can't find %s on PATH, '.' not in PATH
d813 2
a814 3
(F) You used the B<-S> switch, but the script to execute could not be
found in the PATH, or at least not with the correct permissions.  The
script exists in the current directory, but PATH prohibits running it.
d818 3
a820 3
(F) Perl strings can stretch over multiple lines.  This message means
that the closing delimiter was omitted.  Because bracketed quotes count
nesting levels, the following is missing its final parenthesis:
d824 3
a826 10
If you're getting this error from a here-document, you may have included
unseen whitespace before or after your closing tag. A good programmer's
editor will have a way to help you find these characters.

=item Can't find %s property definition %s 

(F) You may have tried to use C<\p> which means a Unicode property for
example \p{Lu} is all uppercase letters.  Escape the C<\p>, either
C<\\p> (just the C<\p>) or by C<\Q\p> (the rest of the string, until
possible C<\E>).
d830 1
a830 2
(F) A fatal error occurred while trying to fork while opening a
pipeline.
d834 14
a847 15
(S) A warning peculiar to VMS.  This arises because of the difference
between access checks under VMS and under the Unix model Perl assumes.
Under VMS, access checks are done by filename, rather than by bits in
the stat buffer, so that ACLs and other protections can be taken into
account.  Unfortunately, Perl assumes that the stat buffer contains all
the necessary information, and passes it, instead of the filespec, to
the access checking routine.  It will try to retrieve the filespec using
the device name and FID present in the stat buffer, but this works only
if you haven't made a subsequent call to the CRTL stat() routine,
because the device name is overwritten with each call.  If this warning
appears, the name lookup failed, and the access checking routine gave up
and returned FALSE, just to be conservative.  (Note: The access checking
routine knows about the Perl C<stat> operator and file tests, so you
shouldn't ever see this warning in response to a Perl command; it arises
only if some internal code takes stat buffers lightly.)
d851 2
a852 2
(P) An error peculiar to VMS.  After creating a mailbox to act as a
pipe, Perl can't retrieve its name for later use.
d859 1
a859 6
=item Can't "goto" into the middle of a foreach loop

(F) A "goto" statement was executed to jump into the middle of a foreach
loop.  You can't get there from here.  See L<perlfunc/goto>.

=item Can't "goto" out of a pseudo block
d861 4
a864 4
(F) A "goto" statement was executed to jump out of what might look like
a block, except that it isn't a proper block.  This usually occurs if
you tried to jump out of a sort() block or subroutine, which is a no-no.
See L<perlfunc/goto>.
d868 2
a869 10
(F) The "goto subroutine" call can't be used to jump out of an eval
"string".  (You can use it to jump out of an eval {BLOCK}, but you
probably don't want to.)

=item Can't goto subroutine outside a subroutine

(F) The deeply magical "goto subroutine" call can only replace one
subroutine call for another.  It can't manufacture one out of whole
cloth.  In general you should be calling it out of only an AUTOLOAD
routine anyway.  See L<perlfunc/goto>.
d873 6
a878 6
(W signal) Perl has detected that it is being run with the SIGCHLD
signal (sometimes known as SIGCLD) disabled.  Since disabling this
signal will interfere with proper determination of exit status of child
processes, Perl has reset the signal to its default value.  This
situation typically indicates that the parent program under which Perl
may be running (e.g. cron) is being very careless.
d880 1
a880 1
=item Can't "last" outside a loop block
d882 4
a885 7
(F) A "last" statement was executed to break out of the current block,
except that there's this itty bitty problem called there isn't a current
block.  Note that an "if" or "else" block doesn't count as a "loopish"
block, as doesn't a block given to sort(), map() or grep().  You can
usually double the curlies to get the same effect though, because the
inner curlies will be considered a block that loops once.  See
L<perlfunc/last>.
d896 4
a899 4
(F) You said something like C<< local $ar->{'key'} >>, where $ar is a
reference to a pseudo-hash.  That hasn't been implemented yet, but you
can get a similar effect by localizing the corresponding array element
directly -- C<< local $ar->[$ar->[0]{'key'}] >>.
d901 1
a901 1
=item Can't localize through a reference
d903 4
a906 4
(F) You said something like C<local $$ref>, which Perl can't currently
handle, because when it goes to restore the old value of whatever $ref
pointed to after the scope of the local() is finished, it can't be sure
that $ref will still be a reference.  
d912 5
a916 12
unless the file name included the full path to the file.  Perhaps you
need to set the PERL5LIB or PERL5OPT environment variable to say where
the extra library is, or maybe the script needs to add the library name
to @@INC.  Or maybe you just misspelled the name of the file.  See
L<perlfunc/require> and L<lib>.

=item Can't locate auto/%s.al in @@INC

(F) A function (or method) was called in a package which allows
autoload, but there is no function to autoload.  Most probable causes
are a misprint in a function/method name or a failure to C<AutoSplit>
the file, say, by doing C<make install>.
a923 6
=item (perhaps you forgot to load "%s"?)

(F) This is an educated guess made in conjunction with the message
"Can't locate object method \"%s\" via package \"%s\"".  It often means
that a method requires a package that has not been loaded.

d926 2
a927 2
(W syntax) The @@ISA array contained the name of another package that
doesn't seem to exist.
d931 1
a931 2
(F) List assignment to %ENV is not supported on some systems, notably
VMS.
d935 7
a941 2
(F) You aren't allowed to assign to the item indicated, or otherwise try
to change it, such as with an auto-increment.
a947 5
=item Can't modify non-lvalue subroutine call

(F) Subroutines meant to be used in lvalue context should be declared as
such, see L<perlsub/"Lvalue subroutines">.

a952 9
=item Can't "next" outside a loop block

(F) A "next" statement was executed to reiterate the current block, but
there isn't a current block.  Note that an "if" or "else" block doesn't
count as a "loopish" block, as doesn't a block given to sort(), map() or
grep().  You can usually double the curlies to get the same effect
though, because the inner curlies will be considered a block that loops
once.  See L<perlfunc/next>.

d958 2
a959 2
is because you don't have read permission for a file which you named on
the command line.
d963 4
a966 4
(W pipe) You tried to say C<open(CMD, "|cmd|")>, which is not supported.
You can try any of several modules in the Perl library to do this, such
as IPC::Open2.  Alternately, direct the pipe's output to a file using
">", and then read it in under a different file handle.
d970 3
a972 3
(F) An error peculiar to VMS.  Perl does its own command line
redirection, and couldn't open the file specified after '2>' or '2>>' on
the command line for writing.
d976 2
a977 3
(F) An error peculiar to VMS.  Perl does its own command line
redirection, and couldn't open the file specified after '<' on the
command line for reading.
d981 3
a983 3
(F) An error peculiar to VMS.  Perl does its own command line
redirection, and couldn't open the file specified after '>' or '>>' on
the command line for writing.
d987 2
a988 3
(P) An error peculiar to VMS.  Perl does its own command line
redirection, and couldn't open the pipe into which to send data destined
for stdout.
a993 8
=item Can't read CRTL environ

(S) A warning peculiar to VMS.  Perl tried to read an element of %ENV
from the CRTL's internal environment array and discovered the array was
missing.  You need to figure out where your CRTL misplaced its environ
or define F<PERL_ENV_TABLES> (see L<perlvms>) so that environ is not
searched.

d997 2
a998 2
pointers into them.  You tried to redefine one such sort subroutine when
it was currently active, which is not allowed.  If you really want to do
a1000 9
=item Can't "redo" outside a loop block

(F) A "redo" statement was executed to restart the current block, but
there isn't a current block.  Note that an "if" or "else" block doesn't
count as a "loopish" block, as doesn't a block given to sort(), map()
or grep().  You can usually double the curlies to get the same effect
though, because the inner curlies will be considered a block that
loops once.  See L<perlfunc/redo>.

d1003 3
a1005 3
(S inplace) You requested an inplace edit without creating a backup
file.  Perl was unable to remove the original file to replace it with
the modified file.  The file was left unmodified.
d1014 2
a1015 8
(P) An error peculiar to VMS.  Perl thought stdin was a pipe, and tried
to reopen it to accept binary data.  Alas, it failed.

=item Can't resolve method `%s' overloading `%s' in package `%s'

(F|P) Error resolving overloading specified by a method name (as opposed
to a subroutine reference): no such method callable via the package. If
method name is C<???>, this is an internal error.
d1019 2
a1020 16
(P) The setreuid() call failed for some reason in the setuid emulator of
suidperl.

=item Can't return %s from lvalue subroutine

(F) Perl detected an attempt to return illegal lvalues (such as
temporary or readonly values) from a subroutine used as an lvalue.  This
is not allowed.

=item Can't return %s to lvalue scalar context

(F) You tried to return a complete array or hash from an lvalue subroutine,
but you called the subroutine in a way that made Perl think you meant
to return only one value. You probably meant to write parentheses around
the call to the subroutine, which tell Perl that the call should be in
list context.
d1027 6
d1035 2
a1036 2
(P) For some reason you can't fstat() the script even though you have it
open already.  Bizarre.
d1040 2
a1041 2
(P) The setreuid() call failed for some reason in the setuid emulator of
suidperl.
d1047 2
a1048 2
standard with Perl, though, if you really want to do that for the
negative numbers.
d1069 4
a1072 4
(P) The internal sv_upgrade routine adds "members" to an SV, making it
into a more specialized kind of SV.  The top several SV types are so
specialized, however, that they cannot be interconverted.  This message
indicates that such a conversion was attempted.
d1076 3
a1078 10
(P) The undefined SV is the bottom of the totem pole, in the scheme of
upgradability.  Upgrading to undef indicates an error in the code
calling sv_upgrade.

=item Can't use an undefined value as %s reference

(F) A value used as either a hard reference or a symbolic reference must
be a defined value.  This helps to delurk some insidious errors.

=item Can't use bareword ("%s") as %s ref while "strict refs" in use
d1080 1
a1080 4
(F) Only hard references are allowed by "strict refs".  Symbolic
references are disallowed.  See L<perlref>.

=item Can't use %! because Errno.pm is not available
a1085 13
=item Can't use %s for loop variable

(F) Only a simple scalar variable may be used as a loop variable on a
foreach.

=item Can't use global %s in "my"

(F) You tried to declare a magical variable as a lexical variable.  This
is not allowed, because the magic can be tied to only one location
(namely the global variable) and it would be incredibly confusing to
have variables in your program that looked like magical variables but
weren't.

d1094 4
d1104 13
d1119 15
a1133 2
(F) Only hard references are allowed by "strict refs".  Symbolic
references are disallowed.  See L<perlref>.
a1140 9
=item Can't use \%c to mean $%c in expression

(W syntax) In an ordinary expression, backslash is a unary operator that
creates a reference to its argument.  The use of backslash to indicate a
backreference to a matched substring is valid only as part of a regular
expression pattern.  Trying to do this in ordinary Perl code produces a
value that prints out looking like SCALAR(0xdecaf).  Use the $1 form
instead.

d1148 2
a1149 2
(F) You tried to repeat a constant value (often the undefined value)
with an assignment operator, which implies modifying the value itself.
d1152 40
d1198 2
a1199 3
not realizing that 777 will be interpreted as a decimal number,
equivalent to 01411.  Octal constants are introduced with a leading 0 in
Perl, as in C.
d1201 1
a1201 1
=item close() on unopened filehandle %s
a1204 5
=item %s: Command not found

(A) You've accidentally run your script through B<csh> instead of Perl.
Check the #! line, or manually feed your script into Perl yourself.

d1208 2
a1209 2
Perl uses this generic message when none of the errors that it
encountered were severe enough to halt compilation immediately.
d1213 3
a1215 3
(W regexp) The regular expression engine uses recursion in complex
situations where back-tracking is required.  Recursion depth is limited
to 32766, or perhaps less in architectures where the stack cannot grow
d1218 4
a1221 4
under examination; looping in Perl code (e.g. with C<while>) rather than
in the regular expression engine; or rewriting the regular expression so
that it is simpler or backtracks less.  (See L<perlfaq2> for information
on I<Mastering Regular Expressions>.)
d1225 2
a1226 11
(W closed) You tried to do a connect on a closed socket.  Did you forget
to check the return value of your socket() call?  See
L<perlfunc/connect>.

=item Constant(%s)%s: %s

(F) The parser found inconsistencies either while attempting to define
an overloaded constant, or when trying to find the character name
specified in the C<\N{...}> escape.  Perhaps you forgot to load the
corresponding C<overload> or C<charnames> pragma?  See L<charnames> and
L<overload>.
d1231 3
a1233 3
is being dereferenced, but it amounts to the wrong type of reference.
The message indicates the type of reference that was expected. This
usually indicates a syntax error in dereferencing the constant value.
d1238 3
a1240 3
(S|W redefine) You redefined a subroutine which had previously been
eligible for inlining.  See L<perlsub/"Constant Functions"> for
commentary and workarounds.
d1244 2
a1245 2
(W misc) You undefined a subroutine which had previously been eligible
for inlining.  See L<perlsub/"Constant Functions"> for commentary and
d1248 7
d1257 1
a1257 2
(F) The method which overloads "=" is buggy. See 
L<overload/Copy Constructor>.
d1263 4
d1274 2
a1275 17
(P) The regular expression engine got passed a regexp program without a
valid magic number.

=item Corrupt malloc ptr 0x%lx at 0x%lx

(P) The malloc package that comes with Perl had an internal failure.

=item C<-p> destination: %s

(F) An error occurred during the implicit output invoked by the C<-p>
command-line switch.  (This output goes to STDOUT unless you've
redirected it with select().)

=item C<-T> and C<-B> not implemented on filehandles

(F) Perl can't peek at the stdio buffer of filehandles when it doesn't
know about your kind of stdio.  You'll have to use a filename instead.
d1279 4
a1282 4
(W recursion) This subroutine has called itself (directly or indirectly)
100 times more than it has returned.  This probably indicates an
infinite recursion, unless you're writing strange benchmark programs, in
which case it indicates something else.
d1286 3
a1288 3
(D deprecated) defined() is not usually useful on arrays because it
checks for an undefined I<scalar> value.  If you want to see if the
array is empty, just use C<if (@@array) { # not empty }> for example.  
d1292 3
a1294 3
(D deprecated) defined() is not usually useful on hashes because it
checks for an undefined I<scalar> value.  If you want to see if the hash
is empty, just use C<if (%hash) { # not empty }> for example.  
d1298 3
a1300 3
(F) In a here document construct like C<<<FOO>, the label C<FOO> is too
long for Perl to handle.  You have to be seriously twisted to write code
that triggers this error.
a1305 7
=item %s did not return a true value

(F) A required (or used) file must return a true value to indicate that
it compiled correctly and ran its initialization code correctly.  It's
traditional to end such a file with a "1;", though any true value would
do.  See L<perlfunc/require>.

d1308 1
a1308 2
(W) You probably referred to an imported subroutine &FOO as $FOO or some
such.
d1312 2
a1313 3
(W misc) Remember that "our" does not localize the declared global
variable.  You have declared it again in the same lexical scope, which
seems superfluous.
d1317 2
a1318 3
(W) You probably said %hash{$key} when you meant $hash{$key} or
@@hash{@@keys}.  On the other hand, maybe you just meant %hash and got
carried away.
d1325 12
a1348 11
=item (Do you need to predeclare %s?)

(S) This is an educated guess made in conjunction with the message "%s
found where operator expected".  It often means a subroutine or module
name is being referenced that hasn't been declared yet.  This may be
because of ordering problems in your file, or because of a missing
"sub", "package", "require", or "use" statement.  If you're referencing
something that isn't defined yet, you don't actually have to define the
subroutine or package before the current location.  You can use an empty
"sub foo;" or "package FOO;" to enter a "forward" declaration.

d1351 2
a1352 2
(S malloc) An internal routine called free() on something that had
already been freed.
d1356 3
a1358 3
(S) There is no keyword "elseif" in Perl because Larry thinks it's ugly.
Your code will be interpreted as an attempt to call a method named
"elseif" for the class returned by the following block.  This is
d1361 6
d1376 3
a1378 3
single form when it must operate on them directly.  Either you've passed
an invalid file specification to Perl, or you've found a case the
conversion routines don't handle.  Drat.
d1382 3
a1384 3
(F) Perl detected tainted data when trying to compile a regular
expression that contains the C<(?{ ... })> zero-width assertion, which
is unsafe.  See L<perlre/(?{ code })>, and L<perlsec>.
d1386 1
a1386 1
=item %s: Eval-group not allowed at run time
d1388 3
a1390 6
(F) Perl tried to compile a regular expression containing the
C<(?{ ... })> zero-width assertion at run time, as it would when the
pattern contains interpolated values.  Since that is a security risk, it
is not allowed.  If you insist, you may still do this by explicitly
building the pattern from an interpolated string at run time and using
that in an eval().  See L<perlre/(?{ code })>.
d1392 1
a1392 1
=item %s: Eval-group not allowed, use re 'eval'
d1394 6
a1399 3
(F) A regular expression contained the C<(?{ ... })> zero-width
assertion, but that construct is only allowed when the C<use re 'eval'>
pragma is in effect.  See L<perlre/(?{ code })>.
d1414 2
a1415 2
(W exiting) You are exiting an eval by unconventional means, such as a
goto, or a loop control statement.
d1419 2
a1420 2
(W exiting) You are exiting an eval by unconventional means, such as a
goto, or a loop control statement.
d1424 3
a1426 3
(W exiting) You are exiting a rather special block construct (like a
sort block or subroutine) by unconventional means, such as a goto, or a
loop control statement.  See L<perlfunc/sort>.
d1430 2
a1431 2
(W exiting) You are exiting a subroutine by unconventional means, such
as a goto, or a loop control statement.
d1435 2
a1436 2
(W exiting) You are exiting a substitution by unconventional means, such
as a return, a goto, or a loop control statement.
d1442 2
a1443 13
usually not what you want.  Consider providing a default target package,
e.g. bless($ref, $p || 'MyPackage');

=item %s: Expression syntax

(A) You've accidentally run your script through B<csh> instead of Perl.
Check the #! line, or manually feed your script into Perl yourself.

=item %s failed--call queue aborted

(F) An untrapped exception was raised while executing a CHECK, INIT, or
END subroutine.  Processing of the remainder of the queue of such
routines has been prematurely ended.
d1447 4
a1450 4
(W regexp) A character class range must start and end at a literal
character, not another character class like C<\d> or C<[:alpha:]>.  The
"-" in your false range is interpreted as a literal "-".  Consider
quoting the "-",  "\-".  See L<perlre>.
d1454 4
a1457 4
(P) An error peculiar to VMS.  Something untoward happened in a VMS
system service or RTL routine; Perl's exit status should provide more
details.  The filename in "at %s" and the line number in "line %d" tell
you which section of the Perl source code is distressed.
d1464 6
d1472 5
a1476 4
(W io) You tried to write on a read-only filehandle.  If you intended it
to be a read-write filehandle, you needed to open it with "+<" or "+>"
or "+>>" instead of with "<" or nothing.  If you intended only to write
the file, use ">" or ">>".  See L<perlfunc/open>.
d1480 5
a1484 4
(W io) You tried to read from a filehandle opened only for writing.  If
you intended it to be a read/write filehandle, you needed to open it
with "+<" or "+>" or "+>>" instead of with "<" or nothing.  If you
intended only to read from the file, use "<".  See L<perlfunc/open>.
d1489 3
a1491 3
a literal dollar sign, or was meant to introduce a variable name that
happens to be missing.  So you have to put either the backslash or the
name.
d1496 3
a1498 3
a literal "at" sign, or was meant to introduce a variable name that
happens to be missing.  So you have to put either the backslash or the
name.
d1502 3
a1504 15
(W closed) The filehandle you're attempting to flock() got itself closed
some time before now.  Check your logic flow.  flock() operates on
filehandles.  Are you attempting to call flock() on a dirhandle by the
same name?

=item Quantifier follows nothing before << HERE in regex m/%s/

(F) You started a regular expression with a quantifier. Backslash it if you
meant it literally. The << HERE shows in the regular expression about where the
problem was discovered. See L<perlre>.

=item Format not terminated

(F) A format must be terminated by a line with a solitary dot.  Perl got
to the end of your file without finding such a line.
d1515 5
a1531 7
=item %s found where operator expected

(S) The Perl lexer knows whether to expect a term or an operator.  If it
sees what it knows to be a term when it was expecting to see an
operator, it gives you this warning.  Usually it indicates that an
operator or delimiter was omitted, such as a semicolon.

d1544 2
a1545 2
(W closed) You tried to get a socket or peer socket name on a closed
socket.  Did you forget to check the return value of your socket() call?
d1552 15
a1566 1
=item getsockopt() on closed socket %s
d1568 4
a1571 3
(W closed) You tried to get a socket option on a closed socket.  Did you
forget to check the return value of your socket() call?  See
L<perlfunc/getsockopt>.
a1579 26
=item glob failed (%s)

(W glob) Something went wrong with the external program(s) used for
C<glob> and C<< <*.c> >>.  Usually, this means that you supplied a
C<glob> pattern that caused the external program to fail and exit with a
nonzero status.  If the message indicates that the abnormal exit
resulted in a coredump, this may also mean that your csh (C shell) is
broken.  If so, you should change all of the csh-related variables in
config.sh:  If you have tcsh, make the variables refer to it as if it
were csh (e.g.  C<full_csh='/usr/bin/tcsh'>); otherwise, make them all
empty (except that C<d_csh> should be C<'undef'>) so that Perl will
think csh is missing.  In either case, after editing config.sh, run
C<./Configure -S> and rebuild Perl.

=item Glob not terminated

(F) The lexer saw a left angle bracket in a place where it was expecting
a term, so it's looking for the corresponding right angle bracket, and
not finding it.  Chances are you left some needed parentheses out
earlier in the line, and you really meant a "less than".

=item Got an error from DosAllocMem

(P) An error peculiar to OS/2.  Most probably you're using an obsolete
version of Perl, and this should not happen anyway.

a1584 4
=item %s had compilation errors

(F) The final summary message when a C<perl -c> fails.

d1587 3
a1589 3
(S internal) A routine asked for a symbol from a symbol table that ought
to have existed already, but for some reason it didn't, and had to be
created on an emergency basis to prevent a core dump.
d1593 2
a1594 7
(D deprecated) Really old Perl let you omit the % on hash names in some
spots.  This is now heavily deprecated.

=item %s has too many errors

(F) The parser has given up trying to parse the program after 10 errors.
Further error messages would likely be uninformative.
d1606 2
a1607 2
names (like C<$A::B>).  You've exceeded Perl's limits.  Future versions
of Perl are likely to eliminate these arbitrary limitations.
d1609 1
a1609 1
=item Illegal binary digit %s
d1611 3
a1613 1
(F) You used a digit other than 0 or 1 in a binary number.
d1615 1
a1615 1
=item Illegal binary digit %s ignored
d1617 4
a1620 3
(W digit) You may have tried to use a digit other than 0 or 1 in a
binary number.  Interpretation of the binary number stopped before the
offending digit.
d1625 4
a1628 4
would any other whitespace, which means you should never see this error
when Perl was built using standard options.  For some reason, your
version of Perl appears to have been built without this support.  Talk
to your Perl administrator.
d1632 13
a1644 3
(F) You tried to divide a number by 0.  Either something was wrong in
your logic, or you need to put a conditional in to guard against
meaningless input.
d1646 8
a1653 1
=item Illegal hexadecimal digit %s ignored
d1655 2
a1656 3
(W digit) You may have tried to use a character other than 0 - 9 or
A - F, a - f in a hexadecimal number.  Interpretation of the hexadecimal
number stopped before the illegal character.
d1658 1
a1658 1
=item Illegal modulus zero
d1660 3
a1662 2
(F) You tried to divide a number by 0 to get the remainder.  Most
numbers don't take to this kindly.
a1668 9
=item Illegal octal digit %s

(F) You used an 8 or 9 in a octal number.

=item Illegal octal digit %s ignored

(W digit) You may have tried to use an 8 or 9 in a octal number.
Interpretation of the octal number stopped before the 8 or 9.

d1674 1
a1674 20
=item Ill-formed CRTL environ value "%s"

(W internal) A warning peculiar to VMS.  Perl tried to read the CRTL's
internal environ array, and encountered an element without the C<=>
delimiter used to separate keys from values.  The element is ignored.

=item Ill-formed message in prime_env_iter: |%s|

(W internal) A warning peculiar to VMS.  Perl tried to read a logical
name or CLI symbol definition when preparing to iterate over %ENV, and
didn't see the expected delimiter between key and value, so the line was
ignored.

=item (in cleanup) %s

(W misc) This prefix usually indicates that a DESTROY() method raised
the indicated exception.  Since destructors are usually called by the
system at arbitrary points during execution, and often a vast number of
times, the warning is issued only once for any number of failures that
would otherwise result in the same message being repeated.
d1676 7
a1682 2
Failure of user callbacks dispatched using the C<G_KEEPERR> flag could
also result in this warning.  See L<perlcall/G_KEEPERR>.
d1687 6
a1692 6
The tainting mechanism is turned on when you're running setuid or
setgid, or when you specify B<-T> to turn it on explicitly.  The
tainting mechanism labels all data that's derived directly or indirectly
from the user, who is considered to be unworthy of your trust.  If any
such data is used in a "dangerous" operation, you get this error.  See
L<perlsec> for more information.
d1696 3
a1698 3
(F) You can't use system(), exec(), or a piped open in a setuid or
setgid script if C<$ENV{PATH}> contains a directory that is writable by
the world.  See L<perlsec>.
d1710 4
a1713 4
(W overflow) The hexadecimal, octal or binary number you have specified
either as a literal or as an argument to hex() or oct() is too big for
your architecture, and has been converted to a floating point number.
On a 32-bit architecture the largest hexadecimal, octal or binary number
a1719 7
=item Internal disaster before << HERE in regex m/%s/

(P) Something went badly wrong in the regular expression parser.
The << HERE shows in the regular expression about where the problem was
discovered.


d1722 7
a1728 6
(S) A warning peculiar to VMS.  Perl keeps track of the number of times
you've called C<fork> and C<exec>, to determine whether the current call
to C<exec> should affect the current script or a subprocess (see
L<perlvms/"exec LIST">).  Somehow, this count has become scrambled, so
Perl is making a guess and treating this C<exec> as a request to
terminate the Perl script and execute the specified command.
d1730 1
a1730 1
=item Internal urp before << HERE in regex m/%s/
d1732 1
a1732 2
(P) Something went badly awry in the regular expression parser. The <<<HERE
shows in the regular expression about where the problem was discovered.
d1734 1
d1736 1
a1736 6
=item %s (...) interpreted as function

(W syntax) You've run afoul of the rule that says that any list operator
followed by parentheses turns into a function, with all the list
operators arguments found inside the parentheses.  See 
L<perlop/Terms and List Operators (Leftward)>.
d1745 2
a1746 7
The indicated attributes for a subroutine or variable were not
recognized by Perl or by a user-supplied handler.  See L<attributes>.

=item Invalid conversion in %s: "%s"

(W printf) Perl does not understand the given format conversion.  See
L<perlfunc/sprintf>.
d1753 5
d1761 3
a1763 3
elements of an attribute list.  If the previous attribute had a
parenthesised parameter list, perhaps that list was terminated too soon.
See L<attributes>.
d1768 2
a1769 2
(W pack) The given character is not a valid pack type but used to be
silently ignored.
d1773 3
a1775 4
(F) The given character is not a valid unpack type.  See
L<perlfunc/unpack>.
(W unpack) The given character is not a valid unpack type but used to be
silently ignored.
a1781 10
=item `%s' is not a code reference

(W) The second (fourth, sixth, ...) argument of overload::constant needs
to be a code reference. Either an anonymous subroutine, or a reference
to a subroutine.

=item `%s' is not an overloadable type

(W) You tried to overload a constant type the overload package is unaware of.

d1788 3
a1790 3
(F) You named a loop to break out of, but you're not currently in a loop
of that name, not even if you count where you were called from.  See
L<perlfunc/last>.
d1811 2
a1812 8
(W closed) You tried to do a listen on a closed socket.  Did you forget
to check the return value of your socket() call?  See
L<perlfunc/listen>.

=item Lookbehind longer than %d not implemented at {#} mark in regex %s

There is an upper limit to the depth of lookbehind in the (?<=
regular expression construct.
d1817 2
a1818 44
values cannot be returned in subroutines used in lvalue context.  See
L<perlsub/"Lvalue subroutines">.

=item Lookbehind longer than %d not implemented before << HERE %s

(F) There is currently a limit on the length of string which lookbehind can
handle. This restriction may be eased in a future release. The << HERE shows in
the regular expression about where the problem was discovered.

=item Malformed PERLLIB_PREFIX

(F) An error peculiar to OS/2.  PERLLIB_PREFIX should be of the form

    prefix1;prefix2

or

    prefix1 prefix2

with nonempty prefix1 and prefix2.  If C<prefix1> is indeed a prefix of
a builtin library search path, prefix2 is substituted.  The error may
appear if components are not found, or are too long.  See
"PERLLIB_PREFIX" in L<perlos2>.

=item Malformed UTF-8 character (%s)

Perl detected something that didn't comply with UTF-8 encoding rules.

=item Malformed UTF-16 surrogate

Perl thought it was reading UTF-16 encoded character data but while
doing it Perl met a malformed Unicode surrogate.

=item %s matches null string many times

(W regexp) The pattern you've specified would be an infinite loop if the
regular expression engine didn't specifically check for that.  See
L<perlre>.

=item % may only be used in unpack

(F) You can't pack a string by supplying a checksum, because the
checksumming process loses information, and you can't go the other way.
See L<perlfunc/unpack>.
d1839 6
d1857 2
a1858 14
(W pipe) You used the C<open(FH, "| command")> or
C<open(FH, "command |")> construction, but the command was missing or
blank.

=item Missing name in "my sub"

(F) The reserved syntax for lexically scoped subroutines requires that
they have a name with which they can be found.

=item Missing $ on loop variable

(F) Apparently you've been programming in B<csh> too much.  Variables
are always mentioned with the $ in Perl, unlike in the shells, where it
can vary from one line to the next.
d1867 3
a1869 9
(F) The lexer counted more opening curly or square brackets than closing
ones.  As a general rule, you'll find it's missing near the place you
were last editing.

=item (Missing semicolon on previous line?)

(S) This is an educated guess made in conjunction with the message "%s
found where operator expected".  Don't automatically put a semicolon on
the previous line just because you saw this message.
d1882 1
a1882 9
Yet another way is to assign to a C<foreach> loop I<VAR> when I<VAR>
is aliased to a constant in the look I<LIST>:

        $x = 1;
        foreach my $n ($x, 2) {
            $n *= 2; # modifies the $x, but fails on attempt to modify the 2
        } 

=item Modification of non-creatable array value attempted, %s
d1888 1
a1888 1
=item Modification of non-creatable hash value attempted, %s
d1890 2
a1891 2
(P) You tried to make a hash value spring into existence, and it
couldn't be created for some peculiar reason.
a1896 6
=item Module name required with -%c option

(F) The C<-M> or C<-m> options say that Perl should load some module, but
you omitted the name of the module.  Consult L<perlrun> for full details
about C<-M> and C<-m>.

d1903 2
a1904 2
(W syntax) Multidimensional arrays aren't written like C<$foo[1,2,3]>.
They're written like C<$foo[1][2][3]>, as in C.
d1906 1
a1906 18
=item / must be followed by a*, A* or Z*

(F) You had a pack template indicating a counted-length string,
Currently the only things that can have their length counted are a*, A*
or Z*.  See L<perlfunc/pack>.

=item / must be followed by a, A or Z

(F) You had an unpack template indicating a counted-length string, which
must be followed by one of the letters a, A or Z to indicate what sort
of string is to be unpacked.  See L<perlfunc/pack>.

=item / must follow a numeric type

(F) You had an unpack template that contained a '#', but this did not
follow some numeric unpack specification.  See L<perlfunc/pack>.

=item "my sub" not yet implemented
d1908 2
a1909 8
(F) Lexically scoped subroutines are not yet implemented.  Don't try
that yet.

=item "my" variable %s can't be in a package

(F) Lexically scoped variables aren't in a package, so it doesn't make
sense to try to declare one with a package qualifier on the front.  Use
local() if you want to localize a package variable.
d1914 2
a1915 2
If you had a good reason for having a unique name, then just mention it
again somehow to suppress the message.  The C<our> declaration is
d1920 2
a1921 2
(F) You tried to do a read/write/send/recv operation with a buffer
length that is less than 0.  This is difficult to imagine.
d1923 1
a1923 1
=item Nested quantifiers before << HERE in regex m/%s/
d1925 2
a1926 3
(F) You can't quantify a quantifier without intervening parentheses. So
things like ** or +* or ?* are illegal. The << HERE shows in the regular
expression about where the problem was discovered.
d1928 2
a1929 2
Note, however, that the minimal matching quantifiers, C<*?>, C<+?>, and
C<??> appear to be nested quantifiers, but aren't.  See L<perlre>.
d1931 1
d1933 2
a1934 4
=item %s never introduced

(S internal) The symbol in question was declared but somehow went out of
scope before it could possibly have been used.
d1938 4
a1941 4
(F) Certain operations are deemed to be too insecure for a setuid or
setgid script to even be allowed to attempt.  Generally speaking there
will be another way to do what you want that is, if not secure, at least
securable.  See L<perlsec>.
d1947 5
d1972 3
a1974 3
(F) An error peculiar to VMS.  Perl handles its own command line
redirection, and found a '|' at the end of the command line, so it
doesn't know where you want to pipe the output from this command.
d1978 6
a1983 5
(F) The currently executing code was compiled with the B<-d> switch, but
for some reason the perl5db.pl file (or some facsimile thereof) didn't
define a routine to be called at the beginning of each statement.  Which
is odd, because the file should have been required automatically, and
should have blown up the require if it didn't parse right.
d1999 3
a2001 3
(F) An error peculiar to VMS.  Perl handles its own command line
redirection, and found a '2>' or a '2>>' on the command line, but can't
find the name of the file to which to write data destined for stderr.
d2005 3
a2007 13
(F) An error peculiar to VMS.  Perl handles its own command line
redirection, and found a '<' on the command line, but can't find the
name of the file from which to read data for stdin.

=item No #! line

(F) The setuid emulator requires that scripts have a well-formed #! line
even on machines that don't support the #! construct.

=item "no" not allowed in expression

(F) The "no" keyword is recognized and executed at compile time, and
returns no useful value.  See L<perlmod>.
d2011 3
a2013 3
(F) An error peculiar to VMS.  Perl handles its own command line
redirection, and found a lone '>' at the end of the command line, so it
doesn't know where you wanted to redirect stdout.
d2017 3
a2019 3
(F) An error peculiar to VMS.  Perl handles its own command line
redirection, and found a '>' or a '>>' on the command line, but can't
find the name of the file to which to write data destined for stdout.
d2023 3
a2025 3
(F) Fully qualified variable names are not allowed in "our"
declarations, because that doesn't make much sense under existing
semantics.  Such syntax is reserved for future extensions.
d2044 2
a2045 13
(F) The argument to the indicated command line switch must follow
immediately after the switch, without intervening spaces.

=item No %s specified for -%c

(F) The indicated command line switch needs a mandatory argument, but
you haven't specified one.

=item No such pipe open

(P) An error peculiar to VMS.  The internal routine my_pclose() tried to
close a pipe which hadn't been opened.  This should have been caught
earlier as an attempt to close an unopened filehandle.
d2055 10
a2064 4
(F) You tried to access a field of a typed variable where the type does
not know about the field name.  The field names are looked up in the
%FIELDS hash in the type package at compile time.  The %FIELDS hash is
%usually set up with the 'fields' pragma.
d2068 10
a2077 3
(W signal) You specified a signal name as a subscript to %SIG that was
not recognized.  Say C<kill -l> in your shell to see the valid signal
names on your system.
d2083 2
a2084 2
use the ref() function to find out what kind of ref it really was.  See
also L<perlref>.
d2093 4
a2096 4
(F) Perl was trying to evaluate a reference to a "typeglob" (that is, a
symbol table entry that looks like C<*foo>), but found a reference to
something else instead.  You can use the ref() function to find out what
kind of ref it really was.  See L<perlref>.
d2100 3
a2102 9
(F) Perl was trying to evaluate a reference to a hash value, but found a
reference to something else instead.  You can use the ref() function to
find out what kind of ref it really was.  See L<perlref>.

=item Not an ARRAY reference

(F) Perl was trying to evaluate a reference to an array value, but found
a reference to something else instead.  You can use the ref() function
to find out what kind of ref it really was.  See L<perlref>.
d2112 3
a2114 3
(F) Perl was trying to evaluate a reference to a scalar value, but found
a reference to something else instead.  You can use the ref() function
to find out what kind of ref it really was.  See L<perlref>.
d2120 2
a2121 2
use the ref() function to find out what kind of ref it really was.  See
also L<perlref>.
d2128 6
d2140 2
a2141 16
(W syntax) A format specified more picture fields than the next line
supplied.  See L<perlform>.

=item %s: not found

(A) You've accidentally run your script through the Bourne shell instead
of Perl.  Check the #! line, or manually feed your script into Perl
yourself.

=item no UTC offset information; assuming local time is UTC

(S) A warning peculiar to VMS.  Perl was unable to find the local
timezone offset, so it's assuming that local system time is equivalent
to UTC.  If it's not, define the logical name
F<SYS$TIMEZONE_DIFFERENTIAL> to translate to the number of seconds which
need to be added to UTC to get local time.
d2145 2
a2146 7
(F) You can't require the null filename, especially because on many
machines that means the current directory!  See L<perlfunc/require>.

=item NULL OP IN RUN

(P debugging) Some internal routine called run() with a null opcode
pointer.
d2154 4
d2172 4
a2175 11
(F) Perl limits the representation of decimal numbers in programs to
about about 250 characters.  You've exceeded that length.  Future
versions of Perl are likely to eliminate this arbitrary limitation.  In
the meantime, try using scientific notation (e.g. "1e6" instead of
"1_000_000").

=item Octal number in vector unsupported

(F) Numbers with a leading C<0> are not currently allowed in vectors.
The octal number interpretation of such numbers may be supported in a
future version.
d2179 3
a2181 3
(W portable) The octal number you specified is larger than 2**32-1
(4294967295) and therefore non-portable between systems.  See
L<perlport> for more on portability concerns.
d2185 1
a2185 1
=item Odd number of arguments for overload::constant
d2187 3
a2189 2
(W) The call to overload::constant contained an odd number of arguments.
The arguments should come in pairs.
d2193 2
a2194 2
(W misc) You specified an odd number of elements to initialize a hash,
which is odd, because hashes come in key/value pairs.
d2199 3
a2201 14
pointing outside the buffer.  This is difficult to imagine.  The sole
exception to this is that C<sysread()>ing past the buffer will extend
the buffer and zero pad the new area.

=item -%s on unopened filehandle %s

(W unopened) You tried to invoke a file test operator on a filehandle
that isn't open.  Check your logic.  See also L<perlfunc/-X>.

=item %s() on unopened %s %s

(W unopened) An I/O operation was attempted on a filehandle that was
never initialized.  You need to do an open(), a sysopen(), or a socket()
call, or call a constructor from the FileHandle package.
d2213 5
a2217 4
(F) An attempt was made to perform an overloaded operation for which no
handler was defined.  While some handlers can be autogenerated in terms
of other handlers, there is no default handler for any operation, unless
C<fallback> overloading key is specified to be true.  See L<overload>.
d2221 5
a2225 10
(S ambiguous) You used a variable or subroutine call where the parser
was expecting an operator.  The parser has assumed you really meant to
use an operator, but this is highly likely to be incorrect.  For
example, if you say "*foo *foo" it will be interpreted as if you said
"*foo * 'foo'".

=item "our" variable %s redeclared

(W misc) You seem to have already declared the same global once before
in the current lexical scope.
d2230 2
a2231 2
remaining memory (or virtual memory) to satisfy the request.  Perl has
no option but to exit immediately.
d2233 1
a2233 1
=item Out of memory during "large" request for %s
d2235 2
a2236 4
(F) The malloc() function returned 0, indicating there was insufficient
remaining memory (or virtual memory) to satisfy the request. However,
the request was judged large enough (compile-time default is 64K), so a
possibility to shut down by trapping this error is granted.
d2240 2
a2241 3
(X|F) The malloc() function returned 0, indicating there was
insufficient remaining memory (or virtual memory) to satisfy the
request.
d2245 10
a2254 4
However, if compiled for this, Perl may use the contents of C<$^M> as an
emergency pool after die()ing with this message.  In this case the error
is trappable I<once>, and the error message will include the line and file
where the failed request happened.
d2259 2
a2260 20
is most likely to be caused by a typo in the Perl program. e.g.,
C<$arr[time]> instead of C<$arr[$time]>.

=item Out of memory for yacc stack

(F) The yacc parser wanted to grow its stack so it could continue
parsing, but realloc() wouldn't give it more memory, virtual or
otherwise.

=item @@ outside of string

(F) You had a pack template that specified an absolute position outside
the string being unpacked.  See L<perlfunc/pack>.

=item %s package attribute may clash with future reserved word: %s

(W reserved) A lowercase attribute name was used that had a
package-specific handler.  That name might have a meaning to Perl itself
some day, even though it doesn't yet.  Perhaps you should use a
mixed-case attribute name, instead.  See L<attributes>.
d2264 2
a2265 6
(W io) A single call to write() produced more lines than can fit on a
page.  See L<perlform>.

=item panic: %s

(P) An internal error.
d2277 2
a2278 2
(P) The savestack was requested to restore more localized values than
there are in the savestack.
d2290 5
a2294 1
=item panic: pp_match
d2296 1
a2296 2
(P) The internal pp_match() routine was called with invalid operational
data.
d2300 1
a2300 2
(P) The internal pp_subst() routine was called with invalid operational
data.
d2302 1
a2302 1
=item panic: do_trans_%s
d2304 1
a2304 2
(P) The internal do_trans routines were called with invalid operational
data.
d2334 1
a2334 2
(P) A writable lexical variable became read-only somehow within the
scope.
d2341 4
a2349 4
=item panic: malloc

(P) Something requested a negative number of bytes of malloc.

a2393 4
=item panic: pp_split

(P) Something terrible went wrong in setting up for the split.

d2425 1
a2425 1
=item panic: utf16_to_utf8: odd bytelen
d2427 1
a2427 2
(P) Something tried to call utf16_to_utf8 with an odd (as opposed
to even) byte length. 
d2441 1
a2441 21
=item Perl %s required--this is only version %s, stopped

(F) The module in question uses features of a version of Perl more
recent than the currently running version.  How long has it been since
you upgraded, anyway?  See L<perlfunc/require>.

=item PERL_SH_DIR too long

(F) An error peculiar to OS/2. PERL_SH_DIR is the directory to find the
C<sh>-shell in.  See "PERL_SH_DIR" in L<perlos2>.

=item perl: warning: Setting locale failed.

(S) The whole warning message will look something like:

	perl: warning: Setting locale failed.
	perl: warning: Please check that your locale settings:
	        LC_ALL = "En_US",
	        LANG = (unset)
	    are supported and installed on your system.
	perl: warning: Falling back to the standard locale ("C").
d2443 3
a2445 10
Exactly what were the failed locale settings varies.  In the above the
settings were that the LC_ALL was "En_US" and the LANG had no value.
This error means that Perl detected that you and/or your operating
system supplier and/or system administrator have set up the so-called
locale system but Perl could not use those settings.  This was not
dead serious, fortunately: there is a "default locale" called "C" that
Perl can and will use, the script will be run.  Before you really fix
the problem, however, you will get the same error message each time
you run Perl.  How to really fix the problem can be found in
L<perllocale> section B<LOCALE PROBLEMS>.
d2453 3
a2455 32
(W exec) A warning peculiar to VMS.  Waitpid() was asked to wait for a
process which isn't a subprocess of the current process.  While this is
fine from VMS' perspective, it's probably not what you intended.

=item POSIX syntax [%s] belongs inside character classes

(W unsafe) The character class constructs [: :], [= =], and [. .]  go
I<inside> character classes, the [] are part of the construct, for
example: /[012[:alpha:]345]/.  Note that [= =] and [. .] are not
currently implemented; they are simply placeholders for future
extensions and will cause fatal errors.

=item POSIX  syntax [. .] is reserved for future extensions

(F regexp) Within regular expression character classes ([]) the syntax
beginning with "[." and ending with ".]" is reserved for future
extensions.  If you need to represent those character sequences inside
a regular expression character class, just quote the square brackets
with the backslash: "\[." and ".\]".

=item POSIX syntax [= =] is reserved for future extensions

(F) Within regular expression character classes ([]) the syntax
beginning with "[=" and ending with "=]" is reserved for future
extensions.  If you need to represent those character sequences inside
a regular expression character class, just quote the square brackets
with the backslash: "\[=" and "=\]".

=item POSIX class [:%s:] unknown

(F) The class in the character class [: :] syntax is unknown.  See
L<perlre>.
d2462 5
d2470 2
a2471 2
strings, comment characters are not ignored, but are instead treated as
literal data.  (You may have used different delimiters than the
d2498 4
a2501 4
(W qw) qw() lists contain items separated by whitespace; therefore
commas aren't needed to separate the items.  (You may have used
different delimiters than the parentheses shown here; braces are also
frequently used.)
a2518 5
=item Possible Y2K bug: %s

(W y2k) You are concatenating the number 19 with another number, which
could be a potential Year 2000 problem.

d2521 1
a2521 1
(W deprecated) You have written something like this:
d2547 4
a2550 4
because of the strict regularization of Perl 5's grammar into unary and
list operators.  (The old open was a little of both.)  You must put
parentheses around the filehandle, or use the new "or" operator instead
of "||".
a2555 5
=item printf() on closed filehandle %s

(W closed) The filehandle you're writing to got itself closed sometime
before now.  Check your logic flow.

d2558 2
a2559 10
(W closed) The filehandle you're printing on got itself closed sometime
before now.  Check your logic flow.

=item Process terminated by SIG%s

(W) This is a standard message issued by OS/2 applications, while *nix
applications die in silence.  It is considered a feature of the OS/2
port.  One can easily disable this by appropriate sighandlers, see
L<perlipc/"Signals">.  See also "Process terminated by SIGTERM/SIGINT"
in L<perlos2>.
d2561 1
a2561 1
=item Prototype mismatch: %s vs %s
d2563 2
a2564 2
(S unsafe) The subroutine being declared or defined had previously been
declared or defined with a different function prototype.
d2566 1
a2566 1
=item Quantifier in {,} bigger than %d before << HERE in regex m/%s/
d2568 2
a2569 11
(F) There is currently a limit to the size of the min and max values of the
{min,max} construct. The << HERE shows in the regular expression about where
the problem was discovered. See L<perlre>.

=item Quantifier unexpected on zero-length expression before << HERE %s

(W regexp) You applied a regular expression quantifier in a place where
it makes no sense, such as on a zero-width assertion.  Try putting the
quantifier inside the assertion instead.  For example, the way to match
"abc" provided that it is followed by three repetitions of "xyz" is
C</abc(?=(?:xyz){3})/>, not C</abc(?=xyz){3}/>.
d2575 2
a2576 2
One possible workaround is to force Perl to use magical string increment
by prepending "0" to your numbers.
d2580 7
a2586 2
(W closed) The filehandle you're reading from got itself closed sometime
before now.  Check your logic flow.
a2591 5
=item realloc() of freed memory ignored

(S malloc) An internal routine called realloc() on something that had
already been freed.

d2594 2
a2595 2
(F debugging) You can't use the B<-D> option unless the code to produce
the desired output is compiled into Perl, which entails some overhead,
d2603 1
a2603 1
=item Recursive inheritance detected while looking for method %s
d2605 2
a2606 3
(F) More than 100 levels of inheritance were encountered while invoking
a method.  Probably indicates an unintended loop in your inheritance
hierarchy.
d2610 4
a2613 4
(W misc) You gave a single reference where Perl was expecting a list
with an even number of elements (for assignment to a hash). This usually
means that you used the anon hash constructor when you meant to use
parens. In any case, a hash requires key/value B<pairs>.
d2627 2
a2628 2
(W internal) The internal sv_replace() function was handed a new SV with
a reference count of other than 1.
d2630 1
a2630 1
=item Reference to nonexistent group before << HERE in regex m/%s/
d2632 2
a2633 7
(F) You used something like C<\7> in your regular expression, but there are
not at least seven sets of capturing parentheses in the expression. If you
wanted to have the character with value 7 inserted into the regular expression,
prepend a zero to make the number at least two digits: C<\07>

The << HERE shows in the regular expression about where the problem was
discovered.
d2640 1
a2640 1
=item Regexp out of space
d2642 1
a2642 2
(P) A "can't happen" error, because safemalloc() should have caught it
earlier.
d2646 2
a2647 2
(F) You can't specify a repeat count so large that it overflows your
signed integers.  See L<perlfunc/pack>.
d2651 2
a2652 2
(F) You can't specify a repeat count so large that it overflows your
signed integers.  See L<perlfunc/unpack>.
d2656 2
a2657 2
(W syntax) You wrote your assignment operator backwards.  The = must
always comes last, to avoid ambiguity with subsequent unary operators.
d2669 6
a2674 7
(W syntax) You've used an array slice (indicated by @@) to select a
single element of an array.  Generally it's better to ask for a scalar
value (indicated by $).  The difference is that C<$foo[&bar]> always
behaves like a scalar, both when assigning to it and when evaluating its
argument, while C<@@foo[&bar]> behaves like a list when you assign to it,
and provides a list context to its subscript, which can do weird things
if you're expecting only one subscript.
d2683 10
a2692 11
(W syntax) You've used a hash slice (indicated by @@) to select a single
element of a hash.  Generally it's better to ask for a scalar value
(indicated by $).  The difference is that C<$foo{&bar}> always behaves
like a scalar, both when assigning to it and when evaluating its
argument, while C<@@foo{&bar}> behaves like a list when you assign to it,
and provides a list context to its subscript, which can do weird things
if you're expecting only one subscript.

On the other hand, if you were actually hoping to treat the hash element
as a list, you need to look into how references work, because Perl will
not magically convert between scalars and lists for you.  See
a2694 7
=item Scalars leaked: %d

(P) Something went wrong in Perl's internal bookkeeping of scalars:
not all scalar variables were deallocated by the time Perl exited.
What this usually indicates is a memory leak, which is of course bad,
especially if the Perl program is intended to be long-running.

d2706 1
a2706 1
=item %sseek() on unopened filehandle
d2708 2
a2709 2
(W unopened) You tried to use the seek() or sysseek() function on a
filehandle that was either never opened or has since been closed.
d2715 1
a2715 1
=item Semicolon seems to be missing
d2717 1
a2717 2
(W semicolon) A nearby syntax error was probably caused by a missing
semicolon, or possibly some other missing operator, such as a comma.
d2721 2
a2722 2
(S internal) The internal newSVsv() routine was called to duplicate a
scalar that had previously been marked as free.
d2724 1
a2724 1
=item sem%s not implemented
d2726 2
a2727 1
(F) You don't have System V semaphore IPC on your system.
d2731 2
a2732 2
(W closed) The socket you're sending to got itself closed sometime
before now.  Check your logic flow.
d2734 1
a2734 1
=item Sequence (? incomplete before << HERE mark in regex m/%s/
d2736 2
a2737 3
(F) A regular expression ended with an incomplete extension (?. The <<<HERE
shows in the regular expression about where the problem was discovered. See
L<perlre>.
d2739 1
a2739 1
=item Sequence (?{...}) not terminated or not {}-balanced in %s
d2741 2
a2742 2
(F) If the contents of a (?{...}) clause contains braces, they must balance
for Perl to properly detect the end of the clause. See L<perlre>.
d2744 1
a2744 1
=item Sequence (?%s...) not implemented before << HERE mark in %s
d2746 2
a2747 3
(F) A proposed regular expression extension has the character reserved but
has not yet been written. The << HERE shows in the regular expression about
where the problem was discovered. See L<perlre>.
d2749 1
a2749 1
=item Sequence (?%s...) not recognized before << HERE mark in %s
a2751 2
The << HERE shows in the regular expression about
where the problem was discovered. 
a2753 9
=item Sequence (?#... not terminated in regex m/%s/

(F) A regular expression comment must be terminated by a closing
parenthesis.  Embedded parentheses aren't allowed.  See L<perlre>.

=item 500 Server error

See Server error.

d2757 5
a2761 5
to run a CGI program (including SSI) over the web. The actual error text
varies widely from server to server. The most frequently-seen variants
are "500 Server error", "Method (something) not permitted", "Document
contains no data", "Premature end of script headers", and "Did not
produce a valid header".
d2765 6
a2770 6
You need to make sure your script is executable, is accessible by the
user CGI is running the script under (which is probably not the user
account you tested it under), does not rely on any environment variables
(like PATH) from the user it isn't running under, and isn't in a
location where the CGI server can't find it, basically, more or less.
Please see the following for more information:
d2782 3
a2784 3
(F) You tried to assign to C<$)>, and your operating system doesn't
support the setegid() system call (or equivalent), or at least Configure
didn't think so.
d2788 3
a2790 3
(F) You tried to assign to C<< $> >>, and your operating system doesn't
support the seteuid() system call (or equivalent), or at least Configure
didn't think so.
d2794 2
a2795 3
(F) Your system has the setpgrp() from BSD 4.2, which takes no
arguments, unlike POSIX setpgid(), which takes a process ID and process
group ID.
d2799 3
a2801 3
(F) You tried to assign to C<$(>, and your operating system doesn't
support the setrgid() system call (or equivalent), or at least Configure
didn't think so.
d2805 3
a2807 9
(F) You tried to assign to C<$<>, and your operating system doesn't
support the setruid() system call (or equivalent), or at least Configure
didn't think so.

=item setsockopt() on closed socket %s

(W closed) You tried to set a socket option on a closed socket.  Did you
forget to check the return value of your socket() call?  See
L<perlfunc/setsockopt>.
d2811 2
a2812 2
(F) The setuid emulator won't run a script that is writable by the
world, because the world might have written on it already.
a2817 12
=item <> should be quotes

(F) You wrote C<< require <file> >> when you should have written
C<require 'file'>.

=item /%s/ should probably be written as "%s"

(W syntax) You have used a pattern where Perl expected to find a string,
as in the first argument to C<join>.  Perl will treat the true or false
result of matching the pattern against $_ as the string, which is
probably not what you had in mind.

d2820 1
a2820 2
(W closed) You tried to do a shutdown on a closed socket.  Seems a bit
superfluous.
d2824 2
a2825 2
(W signal) The signal handler named in %SIG doesn't, in fact, exist.
Perhaps you put it into the wrong package?
d2845 3
a2847 5
(P) The split was looping infinitely.  (Obviously, a split shouldn't
iterate more times than there are characters of input, which is what
happened.) See L<perlfunc/split>.

=item Statement unlikely to be reached
d2849 1
a2849 5
(W exec) You did an exec() with some statement after it other than a
die().  This is almost always an error, because exec() never returns
unless there was a failure.  You probably wanted to use system()
instead, which does return.  To suppress this warning, put the exec() in
a block by itself.
d2851 2
a2852 1
=item stat() on unopened filehandle %s
d2854 1
a2854 4
(W unopened) You tried to use the stat() function on a filehandle that
was either never opened or has since been closed.

=item Stub found while resolving method `%s' overloading %s
d2856 19
a2874 3
(P) Overloading resolution over @@ISA tree may be broken by importation
stubs.  Stubs should never be implicitly created, but explicit calls to
C<can> may break this.
d2887 3
a2889 3
(P) The substitution was looping infinitely.  (Obviously, a substitution
shouldn't iterate more times than there are characters of input, which
is what happened.)  See the discussion of substitution in
d2906 5
a2910 5
(W substr),(F) You tried to reference a substr() that pointed outside of
a string.  That is, the absolute value of the offset was larger than the
length of the string.  See L<perlfunc/substr>.  This warning is fatal if
substr is used in an lvalue context (as the left hand side of an
assignment or as a subroutine argument for example).
d2914 2
a2915 20
(F) Your Perl was compiled with B<-D>SETUID_SCRIPTS_ARE_SECURE_NOW, but
a version of the setuid emulator somehow got run anyway.

=item Switch (?(condition)... contains too many branches before << HE%s

(F) A (?(condition)if-clause|else-clause) construct can have at most two
branches (the if-clause and the else-clause). If you want one or both to
contain alternation, such as using C<this|that|other>, enclose it in
clustering parentheses:

    (?(condition)(?:this|that|other)|else-clause)

The << HERE shows in the regular expression about where the problem was
discovered. See L<perlre>.

=item Switch condition not recognized before << HERE in regex m/%s/

(F) If the argument to the (?(...)if-clause|else-clause) construct is a
number, it can be only a number. The << HERE shows in the regular expression
about where the problem was discovered. See L<perlre>.
d2919 2
a2920 2
(F) While under the C<use filetest> pragma, we cannot switch the real
and effective uids or gids.
d2941 1
a2941 2
if the error went away.  Sort of the cybernetic version of S<20
questions>.
d2945 3
a2947 7
(A) You've accidentally run your script through the Bourne shell instead
of Perl.  Check the #! line, or manually feed your script into Perl
yourself.

=item %s syntax OK

(F) The final summary message when a C<perl -c> succeeds.
d2958 2
a2959 2
(W closed) The filehandle you're writing to got itself closed sometime
before now.  Check your logic flow.
d2963 7
a2969 2
(F) You tried to use C<goto> to reach a label that was too deeply nested
for Perl to reach.  Perl is doing you a favor by refusing.
d2971 1
a2971 1
=item tell() on unopened filehandle
d2973 2
a2974 2
(W unopened) You tried to use the tell() function on a filehandle that
was either never opened or has since been closed.
d2978 2
a2979 2
(F) Assignment to C<$[> is now strictly circumscribed, and interpreted
as a compiler directive.  You may say only one of
d2988 7
a2994 2
This is to prevent the problem of one module changing the array base out
from under another module inadvertently.  See L<perlvar/$[>.
a3003 5
=item The %s function is unimplemented

The function indicated isn't implemented on this architecture, according
to the probings of Configure.

d3006 3
a3008 4
(F) It makes no sense to test the current stat buffer for symbolic
linkhood if the last stat that wrote to the stat buffer already went
past the symlink to get to the real file.  Use an actual filename
instead.
d3014 5
a3018 6
(W internal) Warnings peculiar to VMS.  You tried to change or delete an
element of the CRTL's internal environ array, but your copy of Perl
wasn't built with a CRTL that contained the setenv() function.  You'll
need to rebuild Perl with a CRTL that does, or redefine
F<PERL_ENV_TABLES> (see L<perlvms>) so that the environ array isn't the
target of the change to
d3023 2
a3024 2
(F) Your version of the C library apparently doesn't do times().  I
suspect you're not running on Unix.
d3040 3
a3042 3
mechanism (or its local equivalent), this error can usually be fixed by
editing the #! line so that the B<-T> option is a part of Perl's first
argument: e.g. change C<perl -n -T> to C<perl -T -n>.
d3057 11
a3067 3
loading a file with C<require> or C<do> when you should be using C<use>
instead.  Or perhaps you should put the C<require> or C<do> inside a
BEGIN block.
a3076 7
=item Too many )'s

(A) You've accidentally run your script through B<csh> instead of Perl.
Check the #! line, or manually feed your script into Perl yourself.

=item Too many ('s

d3079 2
a3080 2
(F) The regular expression ends with an unbackslashed backslash.
Backslash it.   See L<perlre>.
d3112 2
a3113 2
(F) Your machine doesn't implement the umask function and you tried to
use it to restrict permissions for yourself (EXPR & 0700).
d3121 2
a3122 2
(W internal) The exit code detected an internal inconsistency in how
many execution contexts were entered and left.
d3126 2
a3127 2
(W internal) The exit code detected an internal inconsistency in how
many values were temporarily localized.
d3131 2
a3132 2
(W internal) The exit code detected an internal inconsistency in how
many blocks were entered and left.
d3136 2
a3137 2
(W internal) The exit code detected an internal inconsistency in how
many mortal scalars were allocated and freed.
d3146 2
a3147 2
(F) The sort comparison routine specified doesn't seem to exist.
Perhaps it's in a different package?  See L<perlfunc/sort>.
d3151 2
a3152 2
(F) The subroutine indicated hasn't been defined, or if it was, it has
since been undefined.
d3161 2
a3162 2
(F) The sort comparison routine specified is declared but doesn't seem
to have been defined yet.  See L<perlfunc/sort>.
d3171 2
a3172 8
(W misc) An undefined value was assigned to a typeglob, a la
C<*foo = undef>.  This does nothing.  It's possible that you really mean
C<undef *foo>.

=item %s: Undefined variable

(A) You've accidentally run your script through B<csh> instead of Perl.
Check the #! line, or manually feed your script into Perl yourself.
a3178 1

d3181 1
a3181 13
(F) There are no byte-swapping functions for a machine with this byte
order.

=item Unknown switch condition (?(%.2s before << HERE in regex m/%s/

(F) The condition of a (?(condition)if-clause|else-clause) construct is not
known. The condition may be lookaround (the condition is true if the
lookaround is true), a (?{...}) construct (the condition is true if the
code evaluates to a true value), or a number (the condition is true if the
set of capturing parentheses named by the number is defined).

The << HERE shows in the regular expression about where the problem was
discovered.  See L<perlre>.
d3196 1
a3196 1
=item unmatched [ before << HERE mark in regex m/%s/
d3198 3
a3200 4
(F) The brackets around a character class must match. If you wish to
include a closing bracket in a character class, backslash it or put it
first. See L<perlre>. The << HERE shows in the regular expression about
where the escape was discovered.
d3202 1
a3202 1
=item unmatched ( in regexp before << HERE mark in regex m/%s/
d3204 4
a3207 3
(F) Unbackslashed parentheses must always be balanced in regular
expressions.  If you're a vi user, the % key is valuable for finding the
matching parenthesis.  See L<perlre>.
d3209 1
a3209 1
=item Unmatched right %s bracket
d3211 3
a3213 4
(F) The lexer counted more closing curly or square brackets than opening
ones, so you're probably missing a matching opening bracket.  As a
general rule, you'll find the missing one (so to speak) near the place
you were last editing.
d3217 3
a3219 4
(W reserved) You used a bareword that might someday be claimed as a
reserved word.  It's best to put such a word in quotes, or capitalize it
somehow, or insert an underbar into it.  You might also declare it as a
subroutine.
a3226 15
=item /%s/: Unrecognized escape \\%c in character class passed through

(W regexp) You used a backslash-character combination which is not
recognized by Perl inside character classes.  The character was
understood literally.

=item Unrecognized escape \\%c passed through before << HERE in m/%s/

(W regexp) You used a backslash-character combination which is not
recognized by Perl. This combination appears in an interpolated variable or
a C<'>-delimited regular expression. The character was understood
literally. The << HERE shows in the regular expression about where the escape
was discovered.


d3229 2
a3230 2
(W misc) You used a backslash-character combination which is not
recognized by Perl.
d3234 2
a3235 3
(F) You specified a signal name to the kill() function that was not
recognized.  Say C<kill -l> in your shell to see the valid signal names
on your system.
d3239 3
a3241 3
(F) You specified an illegal option to Perl.  Don't do that.  (If you
think you didn't do that, check the #! line to see if it's supplying the
bad switch on your behalf.)
d3245 3
a3247 3
(W newline) A file operation was attempted on a filename, and that
operation failed, PROBABLY because the filename contained a newline,
PROBABLY because you forgot to chomp() it off.  See L<perlfunc/chomp>.
a3252 5
=item Unsupported function %s

(F) This machine doesn't implement the indicated function, apparently.
At least, Configure doesn't think so.

d3257 3
a3259 3
Note that under some systems, like OS/2, there may be different flavors
of Perl executables, some of which may support fork, some not. Try
changing the name you call Perl by to C<perl_>, C<perl__>, and so on.
d3261 1
a3261 1
=item Unsupported script encoding
d3263 2
a3264 2
(F) Your program file begins with a Unicode Byte Order Mark (BOM) which
declares it to be in a Unicode encoding that Perl cannot yet read.
d3271 1
a3271 1
=item Unterminated attribute list
d3273 4
a3276 4
(F) The lexer found something other than a simple identifier at the
start of an attribute, and it wasn't a semicolon or the start of a
block.  Perhaps you terminated the parameter list of the previous
attribute too soon.  See L<attributes>.
d3280 2
a3281 2
(F) The lexer saw an opening (left) parenthesis character while parsing
an attribute list, but the matching closing (right) parenthesis
d3285 1
a3285 1
=item Unterminated compressed integer
d3287 4
a3290 3
(F) An argument to unpack("w",...) was incompatible with the BER
compressed integer format and could not be converted to an integer.
See L<perlfunc/pack>.
d3292 1
a3292 1
=item Unterminated <> operator
d3294 2
a3295 4
(F) The lexer saw a left angle bracket in a place where it was expecting
a term, so it's looking for the corresponding right angle bracket, and
not finding it.  Chances are you left some needed parentheses out
earlier in the line, and you really meant a "less than".
d3297 1
a3297 1
=item untie attempted while %d inner references still exist
d3299 4
a3302 2
(W untie) A copy of the object returned from C<tie> (or C<tied>) was
still valid when C<untie> was called.
d3304 1
a3304 1
=item Useless use of %s in void context
d3306 2
a3307 7
(W void) You did something without a side effect in a context that does
nothing with the return value, such as a statement that doesn't return a
value from a block, or the left side of a scalar comma operator.  Very
often this points not to stupidity on your part, but a failure of Perl
to parse your program the way you thought it would.  For example, you'd
get this if you mixed up your C precedence with Python precedence and
said
d3309 1
a3309 1
    $one, $two = 1, 2;
d3311 2
a3312 1
when you meant to say
d3314 1
a3314 1
    ($one, $two) = (1, 2);
d3316 3
a3318 3
Another common error is to use ordinary parentheses to construct a list
reference when you should be using square or curly brackets, for
example, if you say
d3320 1
a3320 1
    $array = (1,2);
d3322 10
a3331 1
when you should have said
d3333 4
a3336 1
    $array = [1,2];
d3338 3
a3340 5
The square brackets explicitly turn a list value into a scalar value,
while parentheses do not.  So when a parenthesized list is evaluated in
a scalar context, the comma is treated like C's comma operator, which
throws away the left argument, which is not what you want.  See
L<perlref> for more on this.
d3342 1
a3342 1
=item Useless use of "re" pragma
d3344 6
a3349 1
(W) You did C<use re;> without any arguments.   That isn't very useful.
d3351 1
a3351 1
=item "use" not allowed in expression
d3353 3
a3355 2
(F) The "use" keyword is recognized and executed at compile time, and
returns no useful value.  See L<perlmod>.
d3357 1
a3357 1
=item Use of bare << to mean <<"" is deprecated
d3359 3
a3361 2
(D deprecated) You are now encouraged to use the explicitly quoted form
if you wish to use an empty line as the terminator of the here-document.
d3363 1
a3363 1
=item Use of implicit split to @@_ is deprecated
d3365 1
a3365 3
(D deprecated) It makes a lot of work for the compiler when you clobber
a subroutine's argument list, so it's better if you assign the results
of a split() explicitly to an array (or list).
d3367 1
a3367 1
=item Use of inherited AUTOLOAD for non-method %s() is deprecated
d3369 6
a3374 11
(D deprecated) As an (ahem) accidental feature, C<AUTOLOAD> subroutines
are looked up as methods (using the C<@@ISA> hierarchy) even when the
subroutines to be autoloaded were called as plain functions (e.g.
C<Foo::bar()>), not as methods (e.g. C<< Foo->bar() >> or C<<
$obj->bar() >>).

This bug will be rectified in future by using method lookup only for
methods' C<AUTOLOAD>s.  However, there is a significant base of existing
code that may be using the old behavior.  So, as an interim step, Perl
currently issues an optional warning when non-methods use inherited
C<AUTOLOAD>s.
d3376 1
a3376 5
The simple rule is:  Inheritance will not work when autoloading
non-methods.  The simple fix for old code is:  In any module that used
to depend on inheriting C<AUTOLOAD> for non-methods from a base class
named C<BaseClass>, execute C<*AUTOLOAD = \&BaseClass::AUTOLOAD> during
startup.
d3378 1
a3378 3
In code that currently says C<use AutoLoader; @@ISA = qw(AutoLoader);>
you should remove AutoLoader from @@ISA and change C<use AutoLoader;> to
C<use AutoLoader 'AUTOLOAD';>.
d3380 1
a3380 1
=item Use of %s in printf format not supported
d3382 3
a3384 2
(F) You attempted to use a feature of printf that is accessible from
only C.  This usually means there's a better way to do it in Perl.
d3386 1
a3386 1
=item Use of $* is deprecated
d3388 1
a3388 4
(D deprecated) This variable magically turned on multi-line pattern
matching, both for you and for any luckless subroutine that you happen
to call.  You should use the new C<//m> and C<//s> modifiers now to do
that without the dangerous action-at-a-distance effects of C<$*>.
d3390 1
a3390 1
=item Use of %s is deprecated
d3392 5
a3396 3
(D deprecated) The construct indicated is no longer recommended for use,
generally because there's a better way to do it, and also because the
old way has bad side effects.
d3398 1
a3398 6
=item Use of $# is deprecated

(D deprecated) This was an ill-advised attempt to emulate a poorly
defined B<awk> feature.  Use an explicit printf() or sprintf() instead.

=item Use of reserved word "%s" is deprecated
d3400 2
a3401 20
(D deprecated) The indicated bareword is a reserved word.  Future
versions of perl may use it as a keyword, so you're better off either
explicitly quoting the word in a manner appropriate for its context of
use, or using a different name altogether.  The warning can be
suppressed for subroutine names by either adding a C<&> prefix, or using
a package qualifier, e.g. C<&our()>, or C<Foo::our()>.

=item Use of uninitialized value%s

(W uninitialized) An undefined value was used as if it were already
defined.  It was interpreted as a "" or a 0, but maybe it was a mistake.
To suppress this warning assign a defined value to your variables.

To help you figure out what was undefined, perl tells you what operation
you used the undefined value in.  Note, however, that perl optimizes your
program and the operation displayed in the warning may not necessarily
appear literally in your program.  For example, C<"that $foo"> is
usually optimized into C<"that " . $foo>, and the warning will refer to
the C<concatenation (.)> operator, even though there is no C<.> in your
program.
d3405 5
a3409 6
(W misc) In a conditional expression, you used <HANDLE>, <*> (glob),
C<each()>, or C<readdir()> as a boolean value.  Each of these constructs
can return a value of "0"; that would make the conditional expression
false, which is probably not what you intended.  When using these
constructs in conditional expressions, test their values with the
C<defined> operator.
d3413 4
a3416 4
(W misc) A warning peculiar to VMS.  Perl tried to read the value of an
%ENV element from a CLI symbol table, and found a resultant string
longer than 1024 characters.  The return value has been truncated to
1024 characters.
d3420 5
a3424 13
(F) While "use strict" in effect, you referred to a global variable that
you apparently thought was imported from another module, because
something else of the same name (usually a subroutine) is exported by
that module.  It usually means you put the wrong funny character on the
front of your variable.

=item "%s" variable %s masks earlier declaration in same %s

(W misc) A "my" or "our" variable has been redeclared in the current
scope or statement, effectively eliminating all access to the previous
instance.  This is almost always a typographical error.  Note that the
earlier variable will still exist until the end of the scope or until
all closure referents to it are destroyed.
d3428 4
a3431 4
(W closure) An inner (nested) I<anonymous> subroutine is inside a
I<named> subroutine, and outside that is another subroutine; and the
anonymous (innermost) subroutine is referencing a lexical variable
defined in the outermost subroutine.  For example:
d3436 11
a3446 16
indirectly) from the outermost subroutine, it will share the variable as
you would expect.  But if the anonymous subroutine is called or
referenced when the outermost subroutine is not active, it will see the
value of the shared variable as it was before and during the *first*
call to the outermost subroutine, which is probably not what you want.

In these circumstances, it is usually best to make the middle subroutine
anonymous, using the C<sub {}> syntax.  Perl has specific support for
shared variables in nested anonymous subroutines; a named subroutine in
between interferes with this feature.

=item Variable syntax

(A) You've accidentally run your script through B<csh> instead
of Perl.  Check the #! line, or manually feed your script into
Perl yourself.
d3450 2
a3451 2
(W closure) An inner (nested) I<named> subroutine is referencing a
lexical variable defined in an outer subroutine.
d3454 5
a3458 5
the outer subroutine's variable as it was before and during the *first*
call to the outer subroutine; in this case, after the first call to the
outer subroutine is complete, the inner and outer subroutines will no
longer share a common value for the variable.  In other words, the
variable will no longer be shared.
d3466 3
a3468 2
reference variables in outer subroutines are called or referenced, they
are automatically rebound to the current values of such variables.
d3470 1
a3470 1
=item Variable length lookbehind not implemented before << HERE in %s
d3472 3
a3474 3
(F) Lookbehind is allowed only for subexpressions whose length is fixed and
known at compile time. The << HERE shows in the regular expression about where
the problem was discovered.
d3482 21
d3510 2
a3511 3
(S) The implicit close() done by an open() got an error indication on
the close().  This usually indicates your file system ran out of disk
space.
d3515 4
a3518 4
(S ambiguous) You wrote a unary operator followed by something that
looks like a binary operator that could also have been interpreted as a
term or unary operator.  For instance, if you know that the rand
function has a default argument of 1.0, and you write
a3531 4
=item Wide character in %s

(F) Perl met a wide character (>255) when it wasn't expecting one.

d3534 2
a3535 2
(W closed) The filehandle you're writing to got itself closed sometime
before now.  Check your logic flow.
d3549 1
a3549 2
(F) The use of an external subroutine as a sort comparison is not yet
supported.
d3553 1
a3553 2
(F) The use of an external subroutine as a sort comparison is not yet
supported.
d3557 2
a3558 2
(F) A filehandle represents an opened file, and when you opened the file
it already went past any symlink you are presumably trying to look for.
d3565 2
a3566 2
about what you want.  Your best bet is to use the wrapsuid script in the
eg directory to put a setuid C wrapper around your script.
d3570 72
a3641 5
(W syntax) You assigned a bareword as a signal handler name.
Unfortunately, you already have a subroutine of that name declared,
which means that Perl 5 will try to call the subroutine when the
assignment is executed, which is probably not what you want.  (If it IS
what you want, put an & in front.)
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d19 1
a19 1
(W, D & S) can be controlled using the C<warnings> pragma.
a46 8
=item A thread exited while %d other threads were still running

(W) When using threaded Perl, a thread (not necessarily the main
thread) exited while there were still other threads running.
Usually it's a good idea to first collect the return values of the
created threads by joining them, and only then exit from the main
thread.  See L<threads>.

d75 1
a75 1
on the operator (e.g. C<CORE::log($x)>) or declare the subroutine
a78 7
=item Ambiguous range in transliteration operator

(F) You wrote something like C<tr/a-z-0//> which doesn't mean anything at
all.  To include a C<-> character in a transliteration, put it either
first or last.  (In the past, C<tr/a-z-0//> was synonymous with
C<tr/a-y//>, which was probably not what you would have expected.)

d108 2
a109 2
(W misc) The pattern match (C<//>), substitution (C<s///>), and
transliteration (C<tr///>) operators work on scalar values.  If you apply
d178 1
a178 1
=item Attempt to access disallowed key '%s' in a restricted hash
d180 2
a181 36
(F) The failing code has attempted to get or set a key which is not in
the current set of allowed keys of a restricted hash.

=item Attempt to clear a restricted hash

(F) It is currently not allowed to clear a restricted hash, even if the
new hash would contain the same keys as before.  This may change in
the future.

=item Attempt to delete readonly key '%s' from a restricted hash

(F) The failing code attempted to delete a key whose value has been
declared readonly from a restricted hash.

=item Attempt to delete disallowed key '%s' from a restricted hash

(F) The failing code attempted to delete from a restricted hash a key
which is not in its key set.

=item Attempt to bless into a reference

(F) The CLASSNAME argument to the bless() operator is expected to be
the name of the package to bless the resulting object into. You've
supplied instead a reference to something: perhaps you wrote

    bless $self, $proto;

when you intended

    bless $self, ref($proto) || $proto;

If you actually want to bless into the stringified version
of the reference supplied, you need to stringify it yourself, for
example by:

    bless $self, "$proto";
d239 1
a239 1
=item Bad arg length for %s, is %d, should be %s
d248 1
a248 1
(F) You've used the C</e> switch to evaluate the replacement for a
a379 5
=item binmode() on closed filehandle %s

(W unopened) You tried binmode() on a filehandle that was never opened.
Check you control flow and number of arguments.

d509 3
a511 3
(F) Currently, only scalar variables can be declared with a specific
class qualifier in a "my" or "our" declaration.  The semantics may be
extended for other types of variables in future.
d540 1
a540 1
=item Can't do {n,m} with n > m in regex; marked by <-- HERE in m/%s/
d543 1
a543 1
regexp to match something 0 times, just put {0}. The <-- HERE shows in the
d577 1
a577 1
(W exec) A system(), exec(), or piped open call could not execute the
a600 7
=item Can't find %s character property "%s"

(F) You used C<\p{}> or C<\P{}> but the character property by that name
could not be found. Maybe you misspelled the name of the property
(remember that the names of character properties consist only of
alphanumeric characters), or maybe you forgot the C<Is> or C<In> prefix?

d629 1
a629 1
=item Can't find %s property definition %s
d631 3
a633 5
(F) You may have tried to use C<\p> which means a Unicode property (for
example C<\p{Lu}> is all uppercase letters).  If you did mean to use a
Unicode property, see L<perlunicode> for the list of known properties.
If you didn't mean to use a Unicode property, escape the C<\p>, either
by C<\\p> (just the C<\p>) or by C<\Q\p> (the rest of the string, until
d732 1
a732 1
that $ref will still be a reference.
a756 5
=item Can't locate PerlIO%s

(F) You tried to use in open() a PerlIO layer that does not exist,
e.g. open(FH, ">:nosuchlayer", "somefile").

a809 10
=item Can't open a reference

(W io) You tried to open a scalar reference for reading or writing,
using the 3-arg open() syntax :

    open FH, '>', $ref;

but your version of perl is compiled without perlio, and this form of
open is not supported.

d841 1
a841 1
=item Can't open perl script%s: %s
d869 1
a869 1
=item Can't remove %s: %s, skipping file
a966 6
=item Can't use anonymous symbol table for method lookup

(P) The internal routine that does method lookup was handed a symbol
table that doesn't have a name.  Symbol tables can become anonymous
for example by undefining stashes: C<undef %Some::Package::>.

d1036 1
a1036 20
=item Character in "C" format wrapped

(W pack) You said

    pack("C", $x)

where $x is either less than 0 or more than 255; the C<"C"> format is
only for encoding native operating system characters (ASCII, EBCDIC,
and so on) and not for Unicode characters, so Perl behaved as if you meant

    pack("C", $x & 255)

If you actually want to pack Unicode codepoints, use the C<"U"> format
instead.

=item Character in "c" format wrapped

(W pack) You said

    pack("c", $x)
d1038 1
a1038 3
where $x is either less than -128 or more than 127; the C<"c"> format
is only for encoding native operating system characters (ASCII, EBCDIC,
and so on) and not for Unicode characters, so Perl behaved as if you meant
d1040 1
a1040 1
    pack("c", $x & 255);
d1042 3
a1044 2
If you actually want to pack Unicode codepoints, use the C<"U"> format
instead.
a1072 23
=item cond_broadcast() called on unlocked variable

(W threads) Within a thread-enabled program, you tried to call
cond_broadcast() on a variable which wasn't locked. The cond_broadcast()
function  is used to wake up another thread that is waiting in a
cond_wait(). To ensure that the signal isn't sent before the other thread
has a chance to enter the wait, it is usual for the signaling thread to
first wait for a lock on variable. This lock attempt will only succeed
after the other thread has entered cond_wait() and thus relinquished the
lock.


=item cond_signal() called on unlocked variable

(W threads) Within a thread-enabled program, you tried to call
cond_signal() on a variable which wasn't locked. The cond_signal()
function  is used to wake up another thread that is waiting in a
cond_wait(). To ensure that the signal isn't sent before the other thread
has a chance to enter the wait, it is usual for the signaling thread to
first wait for a lock on variable. This lock attempt will only succeed
after the other thread has entered cond_wait() and thus relinquished the
lock.

d1097 1
a1097 1
(S) You redefined a subroutine which had previously been
d1109 1
a1109 1
(F) The method which overloads "=" is buggy. See
d1152 1
a1152 1
array is empty, just use C<if (@@array) { # not empty }> for example.
d1158 1
a1158 6
is empty, just use C<if (%hash) { # not empty }> for example.

=item %s defines neither package nor VERSION--version check failed

(F) You said something like "use Module 42" but in the Module file
there are neither package declarations nor a C<$VERSION>.
a1202 5
=item %s does not define %s::VERSION--version check failed

(F) You said something like "use Module 42" but the Module did not
define a C<$VERSION.>

a1221 5
=item dump() better written as CORE::dump()

(W misc) You used the obsolescent C<dump()> built-in function, without fully
qualifying it as C<CORE::dump()>.  Maybe it's a typo.  See L<perlfunc/dump>.

a1233 6
=item Empty %s

(F) C<\p> and C<\P> are used to introduce a named Unicode property, as
described in L<perlunicode> and L<perlre>. You used C<\p> or C<\P> in
a regular expression without specifying the property name.

a1274 4
=item exec? I'm not *that* kind of operating system

(F) The C<exec> function is not implemented in MacPerl. See L<perlport>.

d1286 1
a1286 1
(W exiting) You are exiting a format by unconventional means, such as a
d1323 1
a1323 1
=item False [] range "%s" in regex; marked by <-- HERE in m/%s/
d1326 3
a1328 4
character, not another character class like C<\d> or C<[:alpha:]>.  The "-"
in your false range is interpreted as a literal "-".  Consider quoting the
"-", "\-".  The <-- HERE shows in the regular expression about where the
problem was discovered.  See L<perlre>.
a1347 6
The warning will also occur if STDOUT (file descriptor 1) or STDERR
(file descriptor 2) is opened for input, this is a pre-emptive warning in
case some other part of your program or a child process is expecting STDOUT
and STDERR to be writable. This can happen accidentally if you
C<close(STDOUT)> or STDERR and then C<open> an unrelated handle which
will resuse the lowest numbered available descriptor.
d1351 2
a1352 2
(W io) You tried to read from a filehandle opened only for writing.
If you intended it to be a read/write filehandle, you needed to open it
a1354 6
The warning will also occur if STDIN (file descriptor 0) is opened
for output - this is a pre-emptive warning in case some other part of your
program or a child process is expecting STDIN to be readable.
This can happen accidentally if you C<close(STDIN)> and then C<open> an
unrelated handle which will resuse the lowest numbered available
descriptor.
d1373 1
a1373 1
some time before now.  Check your control flow.  flock() operates on
d1377 1
a1377 3
=item Quantifier follows nothing in regex;

marked by <-- HERE in m/%s/
d1380 2
a1381 2
meant it literally. The <-- HERE shows in the regular expression about
where the problem was discovered. See L<perlre>.
d1393 1
a1393 1
	no warnings 'redefine';
a1479 5
=item %s-group starts with a count

(F) In pack/unpack a ()-group started with a count.  A count is
supposed to follow something: a template character or a ()-group.

a1530 5
=item Illegal character in prototype for %s : %s

(W syntax) An illegal character was found in a prototype declaration.  Legal
characters in prototypes are $, @@, %, *, ;, [, ], &, and \.

d1555 1
a1555 1
(F) You used an 8 or 9 in an octal number.
d1559 1
a1559 1
(W digit) You may have tried to use an 8 or 9 in an octal number.
d1565 1
a1565 1
following switches: B<-[DIMUdmtw]>.
a1590 6
=item In EBCDIC the v-string components cannot exceed 2147483647

(F) An error peculiar to EBCDIC.  Internally, v-strings are stored as
Unicode code points, and encoded in EBCDIC as UTF-EBCDIC.  The UTF-EBCDIC
encoding is limited to code points no larger than 2147483647 (0x7FFFFFFF).

d1627 1
a1627 1
=item Internal disaster in regex; marked by <-- HERE in m/%s/
d1630 1
a1630 1
The <-- HERE shows in the regular expression about where the problem was
d1633 1
d1643 4
a1646 1
=item Internal urp in regex; marked by <-- HERE in m/%s/
a1647 3
(P) Something went badly awry in the regular expression parser. The
<-- HERE shows in the regular expression about where the problem was
discovered.
d1653 1
a1653 1
operators arguments found inside the parentheses.  See
d1671 1
a1671 1
=item Invalid [] range "%s" in regex; marked by <-- HERE in m/%s/
d1674 1
a1674 9
greater than the maximum character.  One possibility is that you forgot the
C<{}> from your ending C<\x{}> - C<\x> without the curly braces can go only
up to C<ff>.  The <-- HERE shows in the regular expression about where the
problem was discovered.  See L<perlre>.

=item Invalid [] range "%s" in transliteration operator

(F) The range specified in the tr/// or y/// operator had a minimum
character greater than the maximum character.  See L<perlop>.
a1700 10
=item ioctl() on unopened %s

(W unopened) You tried ioctl() on a filehandle that was never opened.
Check you control flow and number of arguments.

=item IO::Socket::atmark not implemented on this architecture

(F) Your machine doesn't implement the sockatmark() functionality,
neither as a system call or an ioctl call (SIOCATMARK).

d1703 2
a1704 2
(W overload) The second (fourth, sixth, ...) argument of overload::constant
needs to be a code reference. Either an anonymous subroutine, or a reference
d1709 1
a1709 2
(W overload) You tried to overload a constant type the overload package is
unaware of.
d1744 1
a1744 1
=item lstat() on filehandle %s
d1746 2
a1747 3
(W io) You tried to do an lstat on a filehandle.  What did you mean
by that?  lstat() makes sense only on filenames.  (Perl did a fstat()
instead on the filehandle.)
d1755 1
a1755 3
=item Lookbehind longer than %d not implemented in regex;

marked by <-- HERE in m/%s/
d1758 2
a1759 2
handle. This restriction may be eased in a future release. The <-- HERE
shows in the regular expression about where the problem was discovered.
d1768 1
a1775 7
=item Malformed prototype for %s: %s

(F) You tried to use a function with a malformed prototype.  The
syntax of function prototypes is given a brief compile-time check for
obvious errors like invalid characters.  A more rigorous check is run
when the function is called.

a1779 4
One possible cause is that you read in data that you thought to be in
UTF-8 but it wasn't (it was for example legacy 8-bit data).  Another
possibility is careless use of utf8::upgrade().

d1785 1
a1785 3
=item %s matches null string many times in regex;

marked by <-- HERE in m/%s/
d1788 2
a1789 9
regular expression engine didn't specifically check for that.  The <-- HERE
shows in the regular expression about where the problem was discovered.
See L<perlre>.

=item "%s" may clash with future reserved word

(W) This warning may be due to running a perl5 script through a perl4
interpreter, especially if the word that is being warned about is
"use" or "my".
d1814 1
a1814 2
(W syntax) An underscore (underbar) in a numeric constant did not
separate two digits.
a1847 4
=item Missing right brace on %s

(F) Missing right brace in C<\p{...}> or C<\P{...}>.

d1877 1
a1877 1
        }
a1899 7
=item More than one argument to open

(F) The C<open> function has been asked to open multiple files. This
can happen if you are trying to open a pipe to a command that takes a
list of arguments, but have forgotten to specify a piped open mode.
See L<perlfunc/open> for details.

d1949 1
a1949 6
=item Negative offset to vec in lvalue context

(F) When C<vec> is called in an lvalue context, the second argument must be
greater than or equal to zero.

=item Nested quantifiers in regex; marked by <-- HERE in m/%s/
d1952 1
a1952 1
things like ** or +* or ?* are illegal. The <-- HERE shows in the regular
d1955 1
a1955 1
Note that the minimal matching quantifiers, C<*?>, C<+?>, and
d1958 1
a2083 5
=item No such class %s

(F) You provided a class qualifier in a "my" or "our" declaration, but
this class doesn't exist at this point in your program.

a2178 6
=item %s not allowed in length fields

(F) The count in the (un)pack template may be replaced by C<[TEMPLATE]> only if
C<TEMPLATE> always matches the same amount of packed bytes.  Redesign
the template.

d2218 1
a2218 1
about 250 characters.  You've exceeded that length.  Future
d2239 2
a2240 7
(W overload) The call to overload::constant contained an odd number of
arguments. The arguments should come in pairs.

=item Odd number of elements in anonymous hash

(W misc) You specified an odd number of elements to initialize a hash,
which is odd, because hashes come in key/value pairs.
d2257 1
a2257 1
that isn't open.  Check your control flow.  See also L<perlfunc/-X>.
d2259 1
a2259 1
=item %s() on unopened %s
d2375 1
a2375 1
=item panic: pp_match%s
d2517 1
a2517 1
to even) byte length.
a2563 25
=item perlio: argument list not closed for layer "%s"

(W layer) When pushing a layer with arguments onto the Perl I/O system you
forgot the ) that closes the argument list.  (Layers take care of transforming
data between external and internal representations.)  Perl stopped parsing
the layer list at this point and did not attempt to push this layer.
If your program didn't explicitly request the failing operation, it may be
the result of the value of the environment variable PERLIO.

=item perlio: invalid separator character %s in layer specification list %s

(W layer) When pushing layers onto the Perl I/O system, something other than a
colon or whitespace was seen between the elements of a layer list.
If the previous attribute had a parenthesised parameter list, perhaps that
list was terminated too soon.

=item perlio: unknown layer "%s"

(W layer) An attempt was made to push an unknown layer onto the Perl I/O
system.  (Layers take care of transforming data between external and
internal representations.)  Note that some layers, such as C<mmap>,
are not supported in all environments.  If your program didn't
explicitly request the failing operation, it may be the result of the
value of the environment variable PERLIO.

d2574 1
a2574 7
=item P must have an explicit size

(F) The unpack format P must have an explicit size, not "*".

=item POSIX syntax [%s] belongs inside character classes in regex;

marked by <-- HERE in m/%s/
d2576 5
a2580 6
(W regexp) The character class constructs [: :], [= =], and [. .]  go
I<inside> character classes, the [] are part of the construct, for example:
/[012[:alpha:]345]/.  Note that [= =] and [. .] are not currently
implemented; they are simply placeholders for future extensions and will
cause fatal errors.  The <-- HERE shows in the regular expression about
where the problem was discovered.  See L<perlre>.
d2582 1
a2582 3
=item POSIX syntax [. .] is reserved for future extensions in regex;

marked by <-- HERE in m/%s/
d2585 12
a2596 5
beginning with "[." and ending with ".]" is reserved for future extensions.
If you need to represent those character sequences inside a regular
expression character class, just quote the square brackets with the
backslash: "\[." and ".\]".  The <-- HERE shows in the regular expression
about where the problem was discovered.  See L<perlre>.
d2598 1
a2598 1
=item POSIX syntax [= =] is reserved for future extensions in regex;
d2600 2
a2601 18
marked by <-- HERE in m/%s/

(F) Within regular expression character classes ([]) the syntax beginning
with "[=" and ending with "=]" is reserved for future extensions.  If you
need to represent those character sequences inside a regular expression
character class, just quote the square brackets with the backslash: "\[="
and "=\]".  The <-- HERE shows in the regular expression about where the
problem was discovered.  See L<perlre>.

=item POSIX class [:%s:] unknown in regex;

marked by <-- HERE in m/%s/

(F) The class in the character class [: :] syntax is unknown.  The <-- HERE
shows in the regular expression about where the problem was discovered.
Note that the POSIX character classes do B<not> have the C<is> prefix
the corresponding C interfaces have: in other words, it's C<[[:print:]]>,
not C<isprint>.  See L<perlre>.
a2659 7
=item Possible unintended interpolation of %s in string

(W ambiguous) You said something like `@@foo' in a double-quoted string
but there was no array C<@@foo> in scope at the time. If you wanted a
literal @@foo, then write it as \@@foo; otherwise find out what happened
to the array you apparently lost track of.

d2667 1
a2667 1
(D deprecated) You have written something like this:
d2705 1
a2705 1
before now.  Check your control flow.
d2710 1
a2710 1
before now.  Check your control flow.
d2722 1
a2722 1
(S prototype) The subroutine being declared or defined had previously been
d2725 1
a2725 8
=item Prototype not terminated

(F) You've omitted the closing parenthesis in a function prototype
definition.

=item Quantifier in {,} bigger than %d in regex;

marked by <-- HERE in m/%s/
d2728 1
a2728 1
{min,max} construct. The <-- HERE shows in the regular expression about where
d2731 1
a2731 3
=item Quantifier unexpected on zero-length expression;

marked by <-- HERE in m/%s/
a2738 3
The <-- HERE shows in the regular expression about where the problem was
discovered.

d2749 1
a2749 1
before now.  Check your control flow.
d2799 1
a2799 3
=item Reference to nonexistent group in regex;

marked by <-- HERE in m/%s/
d2806 1
a2806 1
The <-- HERE shows in the regular expression about where the problem was
a2898 5
=item Self-ties of arrays and hashes are not supported

(F) Self-ties are of arrays and hashes are not supported in
the current implementation.

d2916 1
a2916 1
before now.  Check your control flow.
d2918 1
a2918 1
=item Sequence (? incomplete in regex; marked by <-- HERE in m/%s/
d2920 1
a2920 1
(F) A regular expression ended with an incomplete extension (?. The <-- HERE
d2924 1
a2924 3
=item Sequence (?{...}) not terminated or not {}-balanced in regex;

marked by <-- HERE in m/%s/
d2927 1
a2927 5
for Perl to properly detect the end of the clause. The <-- HERE shows in
the regular expression about where the problem was discovered. See
L<perlre>.

=item Sequence (?%s...) not implemented in regex;
d2929 1
a2929 1
marked by <-- HERE in m/%s/
d2932 1
a2932 1
has not yet been written. The <-- HERE shows in the regular expression about
d2935 1
a2935 1
=item Sequence (?%s...) not recognized in regex;
d2937 4
a2940 5
marked by <-- HERE in m/%s/

(F) You used a regular expression extension that doesn't make sense.  The
<-- HERE shows in the regular expression about where the problem was
discovered.  See L<perlre>.
d2942 1
a2942 3
=item Sequence (?#... not terminated in regex;

marked by <-- HERE in m/%s/
d2945 1
a2945 3
parenthesis.  Embedded parentheses aren't allowed.  The <-- HERE shows in
the regular expression about where the problem was discovered. See
L<perlre>.
d2969 5
a2973 3
	http://www.perl.org/CGI_MetaFAQ.html
	http://www.htmlhelp.org/faq/cgifaq.html
	http://www.w3.org/Security/Faq/
a3059 8
=item splice() offset past end of array

(W misc) You attempted to specify an offset that was past the end of
the array passed to splice(). Splicing will instead commence at the end
of the array, rather than past it. If this isn't what you want, try
explicitly pre-extending the array by assigning $#array = $offset. See
L<perlfunc/splice>.

d3090 1
a3090 1
	no warnings 'redefine';
d3103 1
a3103 1
(F) The lexer couldn't find the interior delimiter of an s/// or s{}{}
d3109 1
a3109 1
(F) The lexer couldn't find the final delimiter of an s/// or s{}{}
d3126 1
a3126 3
=item Switch (?(condition)... contains too many branches in regex;

marked by <-- HERE in m/%s/
d3135 1
a3135 1
The <-- HERE shows in the regular expression about where the problem was
d3138 1
a3138 3
=item Switch condition not recognized in regex;

marked by <-- HERE in m/%s/
d3141 1
a3141 1
number, it can be only a number. The <-- HERE shows in the regular expression
a3176 6
=item syntax error in file %s at line %d, next 2 tokens "%s"

(F) This error is likely to occur if you run a perl5 script through
a perl4 interpreter, especially if the next 2 tokens are "use strict"
or "my $var" or "our $var".

d3191 1
a3191 1
before now.  Check your control flow.
d3231 1
a3231 1
=item The stat preceding %s wasn't an lstat
a3249 4
=item thread failed to start: %s

(F) The entry point function of threads->create() failed for some reason.

a3299 2
=item Too many ('s

d3303 3
a3305 1
=item Trailing \ in regex m/%s/
d3333 5
a3412 5
=item Unicode character %s is illegal

(W utf8) Certain Unicode characters have been designated off-limits by
the Unicode standard and should not be generated.  If you really know
what you are doing you can turn off this warning by C<no warnings 'utf8';>.
d3419 1
a3419 7
=item Unknown "re" subpragma '%s' (known ones are: %s)

You tried to use an unknown subpragma of the "re" pragma.

=item Unknown switch condition (?(%.2s in regex;

marked by <-- HERE in m/%s/
d3421 5
a3425 6
(F) The condition part of a (?(condition)if-clause|else-clause) construct
is not known. The condition may be lookahead or lookbehind (the condition
is true if the lookahead or lookbehind is true), a (?{...})  construct (the
condition is true if the code evaluates to a true value), or a number (the
condition is true if the set of capturing parentheses named by the number
matched).
d3427 1
a3427 1
The <-- HERE shows in the regular expression about where the problem was
d3434 1
a3434 1
C<< +> >>, C<<< +>> >>>, C<-|>, C<|->, C<< <& >>, C<< >& >>.
d3443 1
a3443 10
=item Unknown warnings category '%s'

(F) An error issued by the C<warnings> pragma. You specified a warnings
category that is unknown to perl at this point.

Note that if you want to enable a warnings category registered by a module
(e.g. C<use warnings 'File::Find'>), you must have imported this module
first.

=item unmatched [ in regex; marked by <-- HERE in m/%s/
d3447 2
a3448 2
first. The <-- HERE shows in the regular expression about where the problem
was discovered. See L<perlre>.
d3450 1
a3450 1
=item unmatched ( in regex; marked by <-- HERE in m/%s/
d3453 2
a3454 3
expressions. If you're a vi user, the % key is valuable for finding the
matching parenthesis. The <-- HERE shows in the regular expression about
where the problem was discovered. See L<perlre>.
d3482 1
a3482 3
=item Unrecognized escape \\%c passed through in regex;

marked by <-- HERE in m/%s/
d3487 3
a3489 2
literally. The <-- HERE shows in the regular expression about where the
escape was discovered.
a3572 32
=item Useless (?%s) - use /%s modifier in regex;

marked by <-- HERE in m/%s/

(W regexp) You have used an internal modifier such as (?o) that has no
meaning unless applied to the entire regexp:

    if ($string =~ /(?o)$pattern/) { ... }

must be written as

    if ($string =~ /$pattern/o) { ... }

The <-- HERE shows in the regular expression about
where the problem was discovered. See L<perlre>.

=item Useless (?-%s) - don't use /%s modifier in regex;

marked by <-- HERE in m/%s/

(W regexp) You have used an internal modifier such as (?-o) that has no
meaning unless removed from the entire regexp:

    if ($string =~ /(?-o)$pattern/o) { ... }

must be written as

    if ($string =~ /$pattern/) { ... }

The <-- HERE shows in the regular expression about
where the problem was discovered. See L<perlre>.

a3604 8
This warning will not be issued for numerical constants equal to 0 or 1
since they are often used in statements like

    1 while sub_with_side_effects() ;

String constants that would normally evaluate to 0 or 1 are warned
about.

a3608 17
=item Useless use of sort in scalar context

(W void) You used sort in scalar context, as in :

    my $x = sort @@y;

This is not very useful, and perl currently optimizes this away.

=item Useless use of %s with no values

(W syntax) You used the push() or unshift() function with no arguments
apart from the array, like C<push(@@x)> or C<unshift(@@foo)>. That won't
usually have any effect on the array, so is completely useless. It's
possible in principle that push(@@tied_array) could have some effect
if the array is tied to a class which implements a PUSH method. If so,
you can write it as C<push(@@tied_array,())> to avoid this warning.

a3618 32
=item Use of /c modifier is meaningless in s///

(W regexp) You used the /c modifier in a substitution.  The /c
modifier is not presently meaningful in substitutions.

=item Use of /c modifier is meaningless without /g

(W regexp) You used the /c modifier with a regex operand, but didn't
use the /g modifier.  Currently, /c is meaningful only when /g is
used.  (This may change in the future.)

=item Use of /g modifier is meaningless in split

(W regexp) You used the /g modifier on the pattern for a C<split>
operator.  Since C<split> always tries to match the pattern
repeatedly, the C</g> has no effect.

=item Use of *glob{FILEHANDLE} is deprecated

(D deprecated) You are now encouraged to use the shorter *glob{IO} form
to access the filehandle slot within a typeglob.

=item Use of chdir('') or chdir(undef) as chdir() deprecated

(D deprecated) chdir() with no arguments is documented to change to
$ENV{HOME} or $ENV{LOGDIR}.  chdir(undef) and chdir('') share this
behavior, but that has been deprecated.  In future versions they
will simply fail.

Be careful to check that what you pass to chdir() is defined and not
blank, else you might find yourself in your home directory.

a3648 13
=item Use of -l on filehandle %s

(W io) A filehandle represents an opened file, and when you opened the file
it already went past any symlink you are presumably trying to look for.
The operation returned C<undef>.  Use a filename instead.

=item Use of "package" with no arguments is deprecated

(D deprecated) You used the C<package> keyword without specifying a package
name. So no namespace is current at all. Using this can cause many
otherwise reasonable constructs to fail in baffling ways. C<use strict;>
instead.

a3671 11
=item Use of reference "%s" as array index

(W misc) You tried to use a reference as an array index; this probably
isn't what you mean, because references in numerical context tend
to be huge numbers, and so usually indicates programmer error.

If you really do mean it, explicitly numify your reference, like so:
C<$array[0+$ref]>.  This warning is not given for overloaded objects,
either, because you can overload the numification and stringification
operators and then you assumedly know what you are doing.

a3680 7
=item Use of tainted arguments in %s is deprecated

(W taint, deprecated) You have supplied C<system()> or C<exec()> with multiple
arguments and at least one of them is tainted.  This used to be allowed
but will become a fatal error in a future version of perl.  Untaint your
arguments.  See L<perlsec>.

a3694 24
=item Using a hash as a reference is deprecated

(D deprecated) You tried to use a hash as a reference, as in
C<< %foo->{"bar"} >> or C<< %$ref->{"hello"} >>.  Versions of perl <= 5.6.1
used to allow this syntax, but shouldn't have. It is now deprecated, and will
be removed in a future version.

=item Using an array as a reference is deprecated

(D deprecated) You tried to use an array as a reference, as in
C<< @@foo->[23] >> or C<< @@$ref->[99] >>.  Versions of perl <= 5.6.1 used to
allow this syntax, but shouldn't have. It is now deprecated, and will be
removed in a future version.

=item UTF-16 surrogate %s

(W utf8) You tried to generate half of an UTF-16 surrogate by
requesting a Unicode character between the code points 0xD800 and
0xDFFF (inclusive).  That range is reserved exclusively for the use of
UTF-16 encoding (by having two 16-bit UCS-2 characters); but Perl
encodes its characters in UTF-8, so what you got is a very illegal
character.  If you really know what you are doing you can turn off
this warning by C<no warnings 'utf8';>.

d3775 1
a3775 3
=item Variable length lookbehind not implemented in regex;

marked by <-- HERE in m/%s/
d3778 2
a3779 2
known at compile time. The <-- HERE shows in the regular expression about
where the problem was discovered. See L<perlre>.
a3786 10
=item v-string in use/require is non-portable

(W portable) The use of v-strings is non-portable to older, pre-5.6, Perls.
If you want your scripts to be backward portable, use the floating
point version number: for example, instead of C<use 5.6.1> say
C<use 5.006_001>.  This of course won't help: the older Perls
won't suddenly start understanding newer features, but at least
they will show a sensible error message indicating the required
minimum version.

d3819 1
a3819 4
(W utf8) Perl met a wide character (>255) when it wasn't expecting
one.  This warning is by default on for I/O (like print) but can be
turned off by C<no warnings 'utf8';>.  You are supposed to explicitly
mark the filehandle with an encoding, see L<open> and L<perlfunc/binmode>.
d3824 1
a3824 1
before now.  Check your control flow.
d3846 6
d3856 2
a3857 2
about what you want.  Your best bet is to put a setuid C wrapper around
your script.
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d47 8
d67 1
a67 1
(F) The '!' is allowed in pack() or unpack() only after certain types.
a173 9
=item Argument list not closed for PerlIO layer "%s"

(W layer) When pushing a layer with arguments onto the Perl I/O system you
forgot the ) that closes the argument list.  (Layers take care of transforming
data between external and internal representations.)  Perl stopped parsing
the layer list at this point and did not attempt to push this layer.
If your program didn't explicitly request the failing operation, it may be
the result of the value of the environment variable PERLIO.

a192 8
=item A thread exited while %d threads were running

(W) When using threaded Perl, a thread (not necessarily the main
thread) exited while there were still other threads running.
Usually it's a good idea to first collect the return values of the
created threads by joining them, and only then exit from the main
thread.  See L<threads>.

d198 16
a231 10
=item Attempt to delete disallowed key '%s' from a restricted hash

(F) The failing code attempted to delete from a restricted hash a key
which is not in its key set.

=item Attempt to delete readonly key '%s' from a restricted hash

(F) The failing code attempted to delete a key whose value has been
declared readonly from a restricted hash.

d443 5
d470 1
a470 1
=item Cannot compress integer in pack
d472 3
a474 15
(F) An argument to pack("w",...) was too large to compress.  The BER
compressed integer format can only be used with positive integers, and you
attempted to compress Infinity or a very large number (> 1e308).
See L<perlfunc/pack>.

=item Cannot compress negative numbers in pack

(F) An argument to pack("w",...) was negative.  The BER compressed integer
format can only be used with positive integers.  See L<perlfunc/pack>.

=item Can only compress unsigned integers in pack

(F) An argument to pack("w",...) was not an integer.  The BER compressed
integer format can only be used with positive integers, and you attempted
to compress something else.  See L<perlfunc/pack>.
a677 9
=item Can't find %s property definition %s

(F) You may have tried to use C<\p> which means a Unicode property (for
example C<\p{Lu}> is all uppercase letters).  If you did mean to use a
Unicode property, see L<perlunicode> for the list of known properties.
If you didn't mean to use a Unicode property, escape the C<\p>, either
by C<\\p> (just the C<\p>) or by C<\Q\p> (the rest of the string, until
possible C<\E>).

d690 9
d820 11
a835 5
=item Can't locate PerlIO%s

(F) You tried to use in open() a PerlIO layer that does not exist,
e.g. open(FH, ">:nosuchlayer", "somefile").

d919 1
a919 1
=item Can't open perl script%s
a979 5
=item Can't return outside a subroutine

(F) The return statement was executed in mainline code, that is, where
there was no subroutine call to return out of.  See L<perlsub>.

d988 5
d1040 5
a1050 5
=item Can't use an undefined value as %s reference

(F) A value used as either a hard reference or a symbolic reference must
be a defined value.  This helps to delurk some insidious errors.

d1120 1
a1120 1
=item Character in "C" format wrapped in pack
d1135 1
a1135 1
=item Character in "c" format wrapped in pack
a1153 5
=item Code missing after '/'

(F) You had a (sub-)template that ends with a '/'. There must be another
template code following the slash. See L<perlfunc/pack>.

d1188 1
d1257 7
a1263 1
=item Count after length/code in unpack
d1265 2
a1266 3
(F) You had an unpack template indicating a counted-length string, but
you have also specified an explicit size for the string.  See
L<perlfunc/pack>.
a1339 5
=item '/' does not take a repeat count

(F) You cannot put a repeat count of any kind right after the '/' code.
See L<perlfunc/pack>.

d1497 10
a1506 4
(W io) You tried to write on a read-only filehandle.  If you intended
it to be a read-write filehandle, you needed to open it with "+<" or
"+>" or "+>>" instead of with "<" or nothing.  If you intended only to
write the file, use ">" or ">>".  See L<perlfunc/open>.
d1510 2
a1511 2
(W io) You tried to read from a filehandle opened only for writing, If
you intended it to be a read/write filehandle, you needed to open it
d1514 6
a1519 13
Another possibility is that you attempted to open filedescriptor 0
(also known as STDIN) for output (maybe you closed STDIN earlier?).

=item Filehandle %s reopened as %s only for input

(W io) You opened for reading a filehandle that got the same filehandle id
as STDOUT or STDERR. This occured because you closed STDOUT or STDERR
previously.

=item Filehandle STDIN reopened as %s only for output

(W io) You opened for writing a filehandle that got the same filehandle id
as STDIN. This occured because you closed STDIN previously.
d1528 7
d1542 8
d1647 1
a1647 1
=item ()-group starts with a count
d1649 1
a1649 1
(F) A ()-group started with a count.  A count is
a1650 1
 See L<perlfunc/pack>.
a1707 5
=item Illegal declaration of anonymous subroutine

(F) When using the C<sub> keyword to construct an anonymous subroutine,
you must always specify a block of code. See L<perlsub>.

d1794 3
a1796 3
C<$ENV{ENV}>, C<$ENV{BASH_ENV}> or C<$ENV{TERM}> are derived from data
supplied (or potentially supplied) by the user.  The script must set
the path to a known value, using trustworthy data.  See L<perlsec>.
d1861 1
a1861 1
=item Invalid range "%s" in transliteration operator
d1873 1
a1873 1
=item Invalid separator character %s in PerlIO layer specification %s
d1875 3
a1877 4
(W layer) When pushing layers onto the Perl I/O system, something other than a
colon or whitespace was seen between the elements of a layer list.
If the previous attribute had a parenthesised parameter list, perhaps that
list was terminated too soon.
d1879 1
a1879 1
=item Invalid type '%s' in %s
d1881 3
a1883 3
(F) The given character is not a valid pack or unpack type.
See L<perlfunc/pack>.
(W) The given character is not a valid pack or unpack type but used to be
a1895 6
=item IO layers (like "%s") unavailable

(F) Your Perl has not been configured to have PerlIO, and therefore
you cannot use IO layers.  To have PerlIO Perl must be configured
with 'useperlio'.

a1938 6
=item length/code after end of string in unpack

(F) While unpacking, the string buffer was alread used up when an unpack
length/code combination tried to obtain more data. This results in
an undefined value for the length. See L<perlfunc/pack>.

a1944 6
=item Lookbehind longer than %d not implemented in regex; marked by <-- HERE in m/%s/

(F) There is currently a limit on the length of string which lookbehind can
handle. This restriction may be eased in a future release. The <-- HERE
shows in the regular expression about where the problem was discovered.

d1957 1
a1957 1
=item Malformed integer in [] in  pack
d1959 1
a1959 2
(F) Between the  brackets enclosing a numeric repeat count only digits
are permitted.  See L<perlfunc/pack>.
d1961 3
a1963 4
=item Malformed integer in [] in unpack

(F) Between the  brackets enclosing a numeric repeat count only digits
are permitted.  See L<perlfunc/pack>.
d1999 3
a2001 1
=item %s matches null string many times in regex; marked by <-- HERE in m/%s/
d2014 1
a2014 1
=item % may not be used in pack
a2055 5
=item Missing control char name in \c

(F) A double-quoted string ended with "\c", without the required control
character name.

d2144 1
a2144 1
=item '/' must be followed by 'a*', 'A*' or 'Z*'
d2150 5
a2154 1
=item '/' must follow a numeric type in unpack
d2156 4
a2159 3
(F) You had an unpack template that contained a '/', but this did not
follow some unpack specification producing a numeric value.
See L<perlfunc/pack>.
a2178 10
NOTE: This warning detects symbols that have been used only once so $c, @@c,
%c, *c, &c, sub c{}, c(), and c (the filehandle or format) are considered
the same; if a program uses $c only once but also uses any of the others it
will not trigger this warning.

=item Negative '/' count in unpack

(F) The length count obtained from a length/code unpack operation was
negative.  See L<perlfunc/pack>.

a2202 9
=item Newline in left-justified string for %s

(W printf) There is a newline in a string to be left justified by 
C<printf> or C<sprintf>.

The padding spaces will appear after the newline, which is probably not
what you wanted.  Usually you should remove the newline from the string 
and put formatting characters in the C<sprintf> format.

d2210 4
a2257 4
=item No B<-e> allowed in setuid scripts

(F) A setuid script can't be specified by the user.

a2263 5
=item No group ending character '%c' found in template

(F) A pack or unpack template has an opening '(' or '[' without its
matching counterpart. See L<perlfunc/pack>.

d2423 6
d2509 5
a2519 5
=item -%s on unopened filehandle %s

(W unopened) You tried to invoke a file test operator on a filehandle
that isn't open.  Check your control flow.  See also L<perlfunc/-X>.

a2553 6
At least in Unix you may be able to get past this by increasing your
process datasize limits: in csh/tcsh use C<limit> and
C<limit datasize n> (where C<n> is the number of kilobytes) to check
the current limits and change them, and in ksh/bash/zsh use C<ulimit -a>
and C<ulimit -d n>, respectively.

d2586 1
a2586 1
=item '@@' outside of string in unpack
d2588 1
a2588 1
(F) You had a template that specified an absolute position outside
a2597 5
=item pack/unpack repeat count overflow

(F) You can't specify a repeat count so large that it overflows your
signed integers.  See L<perlfunc/pack>.

a2624 7
=item panic: Devel::DProf inconsistent subroutine return

(P) Devel::DProf called a subroutine that exited using goto(LABEL),
last(LABEL) or next(LABEL). Leaving that way a subroutine called from
an XSUB will lead very probably to a crash of the interpreter. This is
a bug that will hopefully one day get fixed.

d2630 5
a2733 5
=item panic: pp_match%s

(P) The internal pp_match() routine was called with invalid operational
data.

d2765 4
a2773 4
=item panic: yylex

(P) The lexer got into a bad state while processing a case modifier.

a2785 12
=item C<-p> destination: %s

(F) An error occurred during the implicit output invoked by the C<-p>
command-line switch.  (This output goes to STDOUT unless you've
redirected it with select().)

=item (perhaps you forgot to load "%s"?)

(F) This is an educated guess made in conjunction with the message
"Can't locate object method \"%s\" via package \"%s\"".  It often means
that a method requires a package that has not been loaded.

a2796 4
=item PERL_SIGNALS illegal: "%s"

See L<perlrun/PERL_SIGNALS> for legal values.

d2819 1
a2819 1
=item Permission denied
d2821 6
a2826 1
(F) The setuid emulator in suidperl decided you were up to no good.
d2828 1
a2828 1
=item pid %x not a child
d2830 4
a2833 3
(W exec) A warning peculiar to VMS.  Waitpid() was asked to wait for a
process which isn't a subprocess of the current process.  While this is
fine from VMS' perspective, it's probably not what you intended.
d2835 1
a2835 1
=item 'P' must have an explicit size in unpack
d2837 8
a2844 1
(F) The unpack format P must have an explicit size, not "*".
d2846 1
a2846 1
=item B<-P> not allowed for setuid/setgid script
d2848 1
a2848 2
(F) The script would have to be opened by the C preprocessor by name,
which provides a race condition that breaks security.
d2850 3
a2852 1
=item POSIX class [:%s:] unknown in regex; marked by <-- HERE in m/%s/
d2854 1
a2854 5
(F) The class in the character class [: :] syntax is unknown.  The <-- HERE
shows in the regular expression about where the problem was discovered.
Note that the POSIX character classes do B<not> have the C<is> prefix
the corresponding C interfaces have: in other words, it's C<[[:print:]]>,
not C<isprint>.  See L<perlre>.
d2856 1
a2856 1
=item POSIX getpgrp can't take an argument
d2858 1
a2858 2
(F) Your system has POSIX getpgrp(), which takes no argument, unlike
the BSD version, which takes a pid.
d2860 1
a2860 1
=item POSIX syntax [%s] belongs inside character classes in regex; marked by <-- HERE in m/%s/
d2869 3
a2871 1
=item POSIX syntax [. .] is reserved for future extensions in regex; marked by <-- HERE in m/%s/
d2880 3
a2882 1
=item POSIX syntax [= =] is reserved for future extensions in regex; marked by <-- HERE in m/%s/
d2891 15
a2957 12
=item Possible precedence problem on bitwise %c operator

(W precedence) Your program uses a bitwise logical operator in conjunction
with a numeric comparison operator, like this :

    if ($x & $y == 0) { ... }

This expression is actually equivalent to C<$x & ($y == 0)>, due to the
higher precedence of C<==>. This is probably not what you want. (If you
really meant to write this, disable the warning, or, better, put the
parentheses explicitly and write C<$x & ($y == 0)>).

d3035 1
a3035 5
=item Pseudo-hashes are deprecated

(D deprecated)  Pseudo-hashes were deprecated in Perl 5.8.0 and they
will be removed in Perl 5.10.0, see L<perl58delta> for more details.
You can continue to use the C<fields> pragma.
d3037 1
a3037 7
=item Quantifier follows nothing in regex; marked by <-- HERE in m/%s/

(F) You started a regular expression with a quantifier. Backslash it if you
meant it literally. The <-- HERE shows in the regular expression about
where the problem was discovered. See L<perlre>.

=item Quantifier in {,} bigger than %d in regex; marked by <-- HERE in m/%s/
d3043 3
a3045 1
=item Quantifier unexpected on zero-length expression; marked by <-- HERE in m/%s/
a3067 8
=item read() on closed filehandle %s

(W closed) You tried to read from a closed filehandle.

=item read() on unopened filehandle %s

(W unopened) You tried to read from a filehandle that was never opened.

d3116 3
a3118 1
=item Reference to nonexistent group in regex; marked by <-- HERE in m/%s/
d3138 10
a3160 7
=item Scalars leaked: %d

(P) Something went wrong in Perl's internal bookkeeping of scalars:
not all scalar variables were deallocated by the time Perl exited.
What this usually indicates is a memory leak, which is of course bad,
especially if the Perl program is intended to be long-running.

d3191 7
a3208 5
Note that since Perl 5.9.0 a // can also be the I<defined-or>
construct, not just the empty search pattern.  Therefore code written
in Perl 5.9.0 or later that uses the // as the I<defined-or> can be
misparsed by pre-5.9.0 Perls as a non-terminated search pattern.

d3248 12
a3259 1
=item Sequence (?%s...) not implemented in regex; marked by <-- HERE in m/%s/
d3265 3
a3267 1
=item Sequence (?%s...) not recognized in regex; marked by <-- HERE in m/%s/
d3273 3
a3275 1
=item Sequence (?#... not terminated in regex; marked by <-- HERE in m/%s/
a3281 7
=item Sequence (?{...}) not terminated or not {}-balanced in regex; marked by <-- HERE in m/%s/

(F) If the contents of a (?{...}) clause contains braces, they must balance
for Perl to properly detect the end of the clause. The <-- HERE shows in
the regular expression about where the problem was discovered. See
L<perlre>.

d3467 3
a3469 1
=item Switch (?(condition)... contains too many branches in regex; marked by <-- HERE in m/%s/
d3481 3
a3483 1
=item Switch condition not recognized in regex; marked by <-- HERE in m/%s/
a3493 4
=item %s syntax

(F) The final summary message when a C<perl -c> succeeds.

d3528 1
a3528 1
=item sysread() on closed filehandle %s
d3530 1
a3530 5
(W closed) You tried to read from a closed filehandle.

=item sysread() on unopened filehandle %s

(W unopened) You tried to read from a filehandle that was never opened.
a3543 5
=item C<-T> and C<-B> not implemented on filehandles

(F) Perl can't peek at the stdio buffer of filehandles when it doesn't
know about your kind of stdio.  You'll have to use a filename instead.

a3604 12
=item 5.005 threads are deprecated

(D deprecated)  The 5.005-style threads (activated by C<use Thread;>)
are deprecated and one should use the new ithreads instead,
see L<perl58delta> for more details.

=item Tied variable freed while still in use

(F) An access method for a tied variable (e.g. FETCH) did something to
free the variable.  Since continuing the current operation is likely
to result in a coredump, Perl is bailing out instead.

a3609 11
=item To%s: illegal mapping '%s'

(F) You tried to define a customized To-mapping for lc(), lcfirst,
uc(), or ucfirst() (or their string-inlined versions), but you
specified an illegal mapping.
See L<perlunicode/"User-Defined Character Properties">.

=item Too deeply nested ()-groups

(F) Your template contains ()-groups with a ridiculously deep nesting level. 

a3614 6
=item Too late for "-%s" option

(X) The #! line (or local equivalent) in a Perl script contains the
B<-M> or B<-m> option.  This is an error because B<-M> and B<-m> options
are not intended for use inside scripts.  Use the C<use> pragma instead.

d3631 6
a3654 3
(A) You've accidentally run your script through B<csh> instead of Perl.
Check the #! line, or manually feed your script into Perl yourself.

a3675 5
=item '%s' trapped by operation mask

(F) You tried to use an operator from a Safe compartment in which it's
disallowed. See L<Safe>.

a3773 22
=item Unknown open() mode '%s'

(F) The second argument of 3-argument open() is not among the list
of valid modes: C<< < >>, C<< > >>, C<<< >> >>>, C<< +< >>,
C<< +> >>, C<<< +>> >>>, C<-|>, C<|->, C<< <& >>, C<< >& >>.

=item Unknown PerlIO layer "%s"

(W layer) An attempt was made to push an unknown layer onto the Perl I/O
system.  (Layers take care of transforming data between external and
internal representations.)  Note that some layers, such as C<mmap>,
are not supported in all environments.  If your program didn't
explicitly request the failing operation, it may be the result of the
value of the environment variable PERLIO.

=item Unknown process %x sent message to prime_env_iter: %s

(P) An error peculiar to VMS.  Perl was reading values for %ENV before
iterating over it, and someone else stuck a message in the stream of
data Perl expected.  Someone's very confused, or perhaps trying to
subvert Perl's population of %ENV for nefarious purposes.

d3778 3
a3780 1
=item Unknown switch condition (?(%.2s in regex; marked by <-- HERE in m/%s/
d3792 1
a3792 1
=item Unknown Unicode option letter '%c'
d3794 3
a3796 2
You specified an unknown Unicode option.  See L<perlrun> documentation
of the C<-C> switch for the list of known options.
d3798 1
a3798 1
=item Unknown Unicode option value %x
d3800 4
a3803 2
You specified an unknown Unicode option.  See L<perlrun> documentation
of the C<-C> switch for the list of known options.
d3854 1
a3854 1
=item Unrecognized escape \\%c passed through
d3856 1
a3856 4
(W misc) You used a backslash-character combination which is not
recognized by Perl.

=item Unrecognized escape \\%c passed through in regex; marked by <-- HERE in m/%s/
d3864 5
d3946 1
a3946 1
=item Usage: POSIX::%s(%s)
d3948 1
a3948 2
(F) You called a POSIX function with incorrect arguments.
See L<POSIX/FUNCTIONS> for more information.
d3950 2
a3951 1
=item Usage: Win32::%s(%s)
d3953 1
a3953 9
(F) You called a Win32 function with incorrect arguments.
See L<Win32> for more information.

=item Useless (?-%s) - don't use /%s modifier in regex; marked by <-- HERE in m/%s/

(W regexp) You have used an internal modifier such as (?-o) that has no
meaning unless removed from the entire regexp:

    if ($string =~ /(?-o)$pattern/o) { ... }
d3957 1
a3957 1
    if ($string =~ /$pattern/) { ... }
d3962 1
a3962 1
=item Useless (?%s) - use /%s modifier in regex; marked by <-- HERE in m/%s/
d3964 4
a3967 2
(W regexp) You have used an internal modifier such as (?o) that has no
meaning unless applied to the entire regexp:
d3969 1
a3969 1
    if ($string =~ /(?o)$pattern/) { ... }
d3973 1
a3973 1
    if ($string =~ /$pattern/o) { ... }
a4048 10
=item Use of chdir('') or chdir(undef) as chdir() deprecated

(D deprecated) chdir() with no arguments is documented to change to
$ENV{HOME} or $ENV{LOGDIR}.  chdir(undef) and chdir('') share this
behavior, but that has been deprecated.  In future versions they
will simply fail.

Be careful to check that what you pass to chdir() is defined and not
blank, else you might find yourself in your home directory.

d4060 1
a4060 1
=item Use of freed value in iteration
d4062 3
a4064 10
(F) Perhaps you modified the iterated array within the loop?
This error is typically caused by code like the following:

    @@a = (3,4);
    @@a = () for (1,2,@@a);

You are not supposed to modify arrays while they are being iterated over.
For speed and efficiency reasons, Perl internally does not do full
reference-counting of iterated items, hence deleting such an item in the
middle of an iteration causes Perl to see a freed value.
d4071 6
a4076 1
=item Use of /g modifier is meaningless in split
d4078 2
a4079 3
(W regexp) You used the /g modifier on the pattern for a C<split>
operator.  Since C<split> always tries to match the pattern
repeatedly, the C</g> has no effect.
d4111 13
a4135 5
=item Use of $# is deprecated

(D deprecated) This was an ill-advised attempt to emulate a poorly
defined B<awk> feature.  Use an explicit printf() or sprintf() instead.

d4142 1
a4142 1
=item Use of -l on filehandle %s
d4144 2
a4145 10
(W io) A filehandle represents an opened file, and when you opened the file
it already went past any symlink you are presumably trying to look for.
The operation returned C<undef>.  Use a filename instead.

=item Use of "package" with no arguments is deprecated

(D deprecated) You used the C<package> keyword without specifying a package
name. So no namespace is current at all. Using this can cause many
otherwise reasonable constructs to fail in baffling ways. C<use strict;>
instead.
a4235 6
=item Variable length lookbehind not implemented in regex; marked by <-- HERE in m/%s/

(F) Lookbehind is allowed only for subexpressions whose length is fixed and
known at compile time. The <-- HERE shows in the regular expression about
where the problem was discovered. See L<perlre>.

d4292 8
d4306 10
d4349 3
a4351 13
one.  This warning is by default on for I/O (like print).  The easiest
way to quiet this warning is simply to add the C<:utf8> layer to the
output, e.g. C<binmode STDOUT, ':utf8'>.  Another way to turn off the
warning is to add C<no warnings 'utf8';> but that is often closer to
cheating.  In general, you are supposed to explicitly mark the
filehandle with an encoding, see L<open> and L<perlfunc/binmode>.

=item Within []-length '%c' not allowed

(F) The count in the (un)pack template may be replaced by C<[TEMPLATE]> only if
C<TEMPLATE> always matches the same amount of packed bytes that can be
determined from the template alone. This is not possible if it contains an
of the codes @@, /, U, u, w or a *-length. Redesign the template.
d4358 1
a4358 7
=item %s "\x%s" does not map to Unicode

When reading in different encodings Perl tries to map everything
into Unicode characters.  The bytes you read in are not legal in
this encoding, for example

    utf8 "\xE4" does not map to Unicode
d4360 2
a4361 1
if you try to read in the a-diaereses Latin-1 as UTF-8.
d4363 1
a4363 6
=item 'X' outside of string

(F) You had a (un)pack template that specified a relative position before
the beginning of the string being (un)packed.  See L<perlfunc/pack>.

=item 'x' outside of string in unpack
a4391 6

=item Your random numbers are not that random

(F) When trying to initialise the random seed for hashes, Perl could
not get any randomness out of your system.  This usually indicates
Something Very Wrong.
@


1.1.1.7
log
@perl 5.8.3 from CPAN
@
text
@a1300 6
=item DESTROY created new reference to dead object '%s'

(F) A DESTROY() method created a new reference to the object which is
just being DESTROYed. Perl is confused, and prefers to abort rather than
to create a dangling reference.

@


1.1.1.8
log
@Import of stock perl 5.8.5
@
text
@d1364 2
a1365 2
(S syntax) This is an educated guess made in conjunction with the message
"%s found where operator expected".  It often means a subroutine or module
d1385 2
a1386 2
(S syntax) There is no keyword "elseif" in Perl because Larry thinks it's
ugly. Your code will be interpreted as an attempt to call a method named
d1578 2
a1579 2
(S syntax) The Perl lexer knows whether to expect a term or an operator.
If it sees what it knows to be a term when it was expecting to see an
a1713 4
=item Illegal declaration of subroutine %s

(F) A subroutine was not declared correctly. See L<perlsub>.

d2099 2
a2100 2
(S syntax) This is an educated guess made in conjunction with the message
"%s found where operator expected".  Often the missing operator is a comma.
d2114 2
a2115 2
(S syntax) This is an educated guess made in conjunction with the message
"%s found where operator expected".  Don't automatically put a semicolon on
a2609 5
=item Out of memory during %s extend

(X) An attempt was made to extend an array, a list, or a string beyond
the largest possible memory allocation.

a2749 4
=item panic: memory wrap

(P) Something tried to allocate more memory than possible.

a3212 6
=item Repeated format line will never terminate (~~ and @@# incompatible)

(F) Your format containes the ~~ repeat-until-blank sequence and a
numeric field that will never go blank so that the repetition never
terminates. You might use ^# instead.  See L<perlform>.

a3659 5
=item The 'unique' attribute may only be applied to 'our' variables

(F) Currently this attribute is not supported on C<my> or C<sub>
declarations.  See L<perlfunc/our>.

d3770 2
a3771 2
(F) The lexer couldn't find the final delimiter of a tr///, tr[][],
y/// or y[][] construct.
d4021 1
a4021 1
=item Unsupported script encoding %s
d4024 1
a4024 1
declares it to be in a Unicode encoding that Perl cannot read.
@


1.1.1.9
log
@perl 5.8.6 from CPAN
@
text
@a785 10
=item Can't load '%s' for module %s

(F) The module you tried to load failed to load a dynamic extension. This
may either mean that you upgraded your version of perl to one that is
incompatible with your old dynamic extensions (which is known to happen
between major versions of perl), or (more likely) that your dynamic
extension was built against an older version of the library that is
installed on your system. You may need to rebuild your old dynamic
extensions.

a823 6
=item Can't locate loadable object for module %s in @@INC

(F) The module you loaded is trying to load an external library, like
for example, C<foo.so> or C<bar.dll>, but the L<DynaLoader> module was
unable to locate this library.  See L<DynaLoader>.

a926 4
If you're debugging a script that uses #!, and normally relies on the
shell's $PATH search, the -S option causes perl to do that search, so
you don't have to type the path or C<`which $scriptname`>.

d1798 1
a1798 2
the world.  Also, the PATH must not contain any relative directory.
See L<perlsec>.
d2019 1
a2019 1
(W utf8) Perl detected something that didn't comply with UTF-8 encoding rules.
a2068 5
=item Missing argument to -%c

(F) The argument to the indicated command line switch must follow
immediately after the switch, without intervening spaces.

d2366 5
a2606 5
=item Out of memory during %s extend

(X) An attempt was made to extend an array, a list, or a string beyond
the largest possible memory allocation.

d2614 5
d3706 6
a3716 16
=item "-T" is on the #! line, it must also be used on the command line

(X) The #! line (or local equivalent) in a Perl script contains the
B<-T> option, but Perl was not invoked with B<-T> in its command line.
This is an error because, by the time Perl discovers a B<-T> in a
script, it's too late to properly taint everything from the environment.
So Perl gives up.

If the Perl script is being executed as a command using the #!
mechanism (or its local equivalent), this error can usually be fixed by
editing the #! line so that the B<-T> option is a part of Perl's first
argument: e.g. change C<perl -n -T> to C<perl -T -n>.

If the Perl script is being executed as C<perl scriptname>, then the
B<-T> option must appear on the command line: C<perl -T scriptname>.

d3738 16
@


1.1.1.10
log
@perl 5.8.8 import
@
text
@d196 1
a196 1
(W threads)(S) When using threaded Perl, a thread (not necessarily the main
a284 9
=item Attempt to set length of freed array

(W) You tried to set the length of an array which has been freed.  You
can do this by storing a reference to the scalar representing the last index
of an array and later assigning through that reference. For example

    $r = do {my @@a; \$#a};
    $$r = 503

d754 1
a754 1
=item Can't goto subroutine from an eval-%s
d757 2
a758 1
"string" or block.
d1066 1
a1066 1
(F) The internal routine that does method lookup was handed a symbol
d1122 1
a1122 1
didn't look like a hash or array reference, or anything else subscriptable.
a1402 5
=item Duplicate modifier '%c' after '%c' in %s

(W) You have applied the same modifier more than once after a type
in a pack template.  See L<perlfunc/pack>.

a1420 6
=item %ENV is aliased to %s

(F) You're running under taint mode, and the C<%ENV> variable has been
aliased to another hash, so it doesn't reflect anymore the state of the
program's environment. This is potentially insecure.

d1548 1
a1548 1
as STDOUT or STDERR. This occurred because you closed STDOUT or STDERR
d1554 1
a1554 1
as STDIN. This occurred because you closed STDIN previously.
d1979 1
a1979 1
(F) While unpacking, the string buffer was already used up when an unpack
d2040 1
a2040 2
(S utf8) (F) Perl detected something that didn't comply with UTF-8
encoding rules.
d2311 4
a2314 3
for some reason the  current debugger (e.g. F<perl5db.pl> or a C<Devel::>
module) didn't define a routine to be called at the beginning of each
statement.
d2321 1
a2321 1
=item No DB::sub routine defined
d2323 4
a2326 4
(F) The currently executing code was compiled with the B<-d> switch, but
for some reason the current debugger (e.g. F<perl5db.pl> or a C<Devel::>
module) didn't define a C<DB::sub> routine to be called at the beginning
of each ordinary subroutine call.
a2504 6
=item Non-string passed as bitmask

(W misc) A number has been passed as a bitmask argument to select().
Use the vec() function to construct the file descriptor bitmasks for
select. See L<perlfunc/select>

d2596 1
a2596 1
=item Operation "%s": no method found, %s
d3249 1
a3249 1
(F) Your format contains the ~~ repeat-until-blank sequence and a
a3318 10
=item Search pattern not terminated or ternary operator parsed as search pattern

(F) The lexer couldn't find the final delimiter of a C<?PATTERN?>
construct.

The question mark is also used as part of the ternary operator (as in
C<foo ? 0 : 1>) leading to some ambiguous constructions being wrongly
parsed. One way to disambiguate the parsing is to put parentheses around
the conditional expression, i.e. C<(foo) ? 0 : 1>.

a3452 5
=item Setuid script not plain file

(F) The setuid emulator won't run a script that isn't read from a file,
but from a socket, a pipe or another device.

d3522 1
a3522 1
=item Stub found while resolving method "%s" overloading "%s"
d3719 1
a3719 1
(W threads)(S) The entry point function of threads->create() failed for some reason.
d4175 1
a4175 1
    1 while sub_with_side_effects();
d4550 10
@


1.1.1.11
log
@import perl 5.10.0 from CPAN
@
text
@d12 1
a12 1
    (S) A severe warning (enabled by default).
d30 1
a30 1
Severe warnings are always enabled, unless they are explicitly disabled
d57 1
a57 1
=item '%c' allowed only after types %s
d59 2
a60 2
(F) The modifiers '!', '<' and '>' are allowed in pack() or unpack() only
after certain types.  See L<perlfunc/pack>.
d136 1
a136 2
(F) The argument to exists() must be a hash or array element or a
subroutine with an ampersand, such as:
a139 1
    &do_something
a284 7
=item Attempt to reload %s aborted.

(F) You tried to load a file with C<use> or C<require> that failed to
compile once already.  Perl will not try to compile this file again
unless you delete its entry from %INC.  See L<perlfunc/require> and
L<perlvar/%INC>.

d333 6
a369 6
=item Bad symbol for dirhandle

(P) An internal request asked to add a dirhandle entry to something
that wasn't a symbol table entry.


a488 12
=item Cannot convert a reference to %s to typeglob

(F) You manipulated Perl's symbol table directly, stored a reference in it,
then tried to access that symbol via conventional Perl syntax. The access
triggers Perl to autovivify that typeglob, but it there is no legal conversion
from that type of reference to a typeglob.

=item Cannot copy to %s in %s

(P) Perl detected an attempt to copy a value to an internal type that cannot
be directly assigned not.

a499 9
=item Can't "break" in a loop topicalizer

(F) You called C<break>, but you're in a C<foreach> block rather than
a C<given> block. You probably meant to use C<next> or C<last>.

=item Can't "break" outside a given block

(F) You called C<break>, but you're not inside a C<given> block.

a574 5
=item Can't "continue" outside a when block

(F) You called C<continue>, but you're not inside a C<when>
or C<default> block.

d583 1
a583 1
class qualifier in a "my", "our" or "state" declaration.  The semantics may be
d588 2
a589 2
(F) Only scalar, array, and hash variables may be declared as "my", "our" or
"state" variables.  They must have ordinary identifiers as names.
a647 7
=item Can't %s %s-endian %ss on this platform

(F) Your platform's byte-order is neither big-endian nor little-endian,
or it has a very strange pointer size.  Packing and unpacking big- or
little-endian floating point values and pointers may not be possible.
See L<perlfunc/pack>.

d697 9
a717 9
=item Can't find Unicode property definition "%s"

(F) You may have tried to use C<\p> which means a Unicode property (for
example C<\p{Lu}> is all uppercase letters).  If you did mean to use a
Unicode property, see L<perlunicode> for the list of known properties.
If you didn't mean to use a Unicode property, escape the C<\p>, either
by C<\\p> (just the C<\p>) or by C<\Q\p> (the rest of the string, until
possible C<\E>).

a762 6
=item Can't goto subroutine from a sort sub (or similar callback)

(F) The "goto subroutine" call can't be used to jump out of the
comparison sub for a sort(), or from a similar callback (such
as the reduce() function in List::Util).

a793 5
=item Can't linearize anonymous symbol table

(F) Perl tried to calculate the method resolution order (MRO) of a
package, but failed because the package stash has no name.

d807 1
a807 1
lexical variable using "my" or "state".  This is not allowed.  If you want to
d811 7
a858 7
=item Can't locate package %s for the parents of %s

(W syntax) You did not define (or require/use) the first package,
which is named as a (possibly indirect) parent of the second by
C<@@ISA> inheritance.  Perl will treat this as if the undefined
package had an empty C<@@ISA>.

d963 7
d1059 1
a1059 1
=item Can't upgrade %s (%d) to %d
d1066 6
a1093 6
=item Can't use both '<' and '>' after type '%c' in %s

(F) A type cannot be forced to have both big-endian and little-endian
byte-order at the same time, so this combination of modifiers is not
allowed.  See L<perlfunc/pack>.

d1099 1
a1099 1
=item Can't use global %s in "%s"
a1106 7
=item Can't use '%c' in a group with different byte-order in %s

(F) You attempted to force a different byte-order on a type
that is already inside a group with a byte-order modifier.
For example you cannot force little-endianness on a type that
is inside a big-endian group.

a1140 7
=item Can't use "when" outside a topicalizer

(F) You have used a when() block that is neither inside a C<foreach>
loop nor a C<given> block. (Note that this error is issued on exit
from the C<when> block, so you won't get the error if the match fails,
or if you use an explicit C<continue>.)

d1152 1
a1152 1
=item Character in 'C' format wrapped in pack
d1167 1
a1167 13
=item Character in 'W' format wrapped in pack

(W pack) You said

    pack("U0W", $x)

where $x is either less than 0 or more than 255. However, C<U0>-mode expects
all values to fall in the interval [0, 255], so Perl behaved as if you
meant:

    pack("U0W", $x & 255)

=item Character in 'c' format wrapped in pack
a1181 36
=item Character in '%c' format wrapped in unpack

(W unpack) You tried something like

   unpack("H", "\x{2a1}")

where the format expects to process a byte (a character with a value
below 256), but a higher value was provided instead. Perl uses the value
modulus 256 instead, as if you had provided:

   unpack("H", "\x{a1}")

=item Character(s) in '%c' format wrapped in pack

(W pack) You tried something like

   pack("u", "\x{1f3}b")

where the format expects to process a sequence of bytes (character with a
value below 256), but some of the characters had a higher value. Perl
uses the character values modulus 256 instead, as if you had provided:

   pack("u", "\x{f3}b")

=item Character(s) in '%c' format wrapped in unpack

(W unpack) You tried something like

   unpack("s", "\x{1f3}b")

where the format expects to process a sequence of bytes (character with a
value below 256), but some of the characters had a higher value. Perl
uses the character values modulus 256 instead, as if you had provided:

   unpack("s", "\x{f3}b")

a1185 5
=item closedir() attempted on invalid dirhandle %s

(W io) The dirhandle you tried to close is either closed or not really
a dirhandle.  Check your control flow.

a1249 8
=item Constant(%s)%s: %s in regex; marked by <-- HERE in m/%s/

(F) The parser found inconsistencies while attempting to find
the character name specified in the C<\N{...}> escape.  Perhaps you
forgot to load the corresponding C<charnames> pragma?
See L<charnames>.


a1328 21
=item Deprecated use of my() in false conditional

(D deprecated) You used a declaration similar to C<my $x if 0>.
There has been a long-standing bug in Perl that causes a lexical variable
not to be cleared at scope exit when its declaration includes a false
conditional. Some people have exploited this bug to achieve a kind of
static variable. Since we intend to fix this bug, we don't want people
relying on this behavior. You can achieve a similar static effect by
declaring the variable in a separate block outside the function, eg

    sub f { my $x if 0; return $x++ }

becomes

    { my $x; sub f { return $x++ } }

Beginning with perl 5.9.4, you can also use C<state> variables to
have lexicals that are initialized only once (see L<feature>):

    sub f { state $x; return $x++ }

a1405 4
=item dump is not supported

(F) Your machine doesn't support dump/undump.

a1468 8
=item EVAL without pos change exceeded limit in regex; marked by <-- HERE in m/%s/

(F) You used a pattern that nested too many EVAL calls without consuming
any text. Restructure the pattern so that text is consumed.

The <-- HERE shows in the regular expression about where the problem was
discovered.

d1524 3
a1526 3
(F) An untrapped exception was raised while executing a UNITCHECK,
CHECK, INIT, or END subroutine.  Processing of the remainder of the
queue of such routines has been prematurely ended.
a1547 12
=item FETCHSIZE returned a negative value

(F) A tied array claimed to have a negative number of elements, which
is not possible.

=item Field too wide in 'u' format in pack

(W pack) Each line in an uuencoded string start with a length indicator
which can't encode values above 63. So there is no point in asking for
a line length bigger than that. Perl will behave as if you specified
C<u63> as format.

d1650 4
a1653 4
(F) You've said "use strict" or "use strict vars", which indicates 
that all variables must either be lexically scoped (using "my" or "state"), 
declared beforehand using "our", or explicitly qualified to say 
which package the global variable is in (using "::").
a1724 7
=item Ignoring %s in character class in regex; marked by <-- HERE in m/%s/

(W) Named Unicode character escapes (\N{...}) may return multi-char
or zero length sequences. When such an escape is used in a character class
its behaviour is not well defined. Check that the correct escape has
been used, and the correct charname handler is in scope.

d1791 1
a1791 1
following switches: B<-[CDIMUdmtw]>.
a1816 6
=item Inconsistent hierarchy during C3 merge of class '%s': merging failed on parent '%s'

(F) The method resolution order (MRO) of the given class is not
C3-consistent, and you have enabled the C3 MRO for this class.  See the C3
documentation in L<mro> for more information.

a1822 16
=item Infinite recursion in regex; marked by <-- HERE in m/%s/

(F) You used a pattern that references itself without consuming any input
text. You should check the pattern to ensure that recursive patterns
either consume text or fail.

The <-- HERE shows in the regular expression about where the problem was
discovered.

=item Initialization of state variables in list context currently forbidden

(F) Currently the implementation of "state" only permits the initialization
of scalar variables in scalar context. Re-write C<state ($a) = 42> as
C<state $a = 42> to change from list to scalar context. Constructions such
as C<state (@@a) = foo()> will be supported in a future perl release.

a1859 15
=item Integer overflow in format string for %s

(F) The indexes and widths specified in the format string of C<printf()>
or C<sprintf()> are too large.  The numbers must not overflow the size of
integers for your architecture.

=item Integer overflow in version

(F) Some portion of a version initialization is too large for the
size of integers for your architecture.  This is not a warning
because there is no rational reason for a version to try and use a
element larger than typically 2**32.  This is usually caused by
trying to use some odd mathematical operation as a version, like
100/9.

a1902 15
=item Invalid escape in the specified encoding in regex; marked by <-- HERE in m/%s/

(W regexp) The numeric escape (for example C<\xHH>) of value < 256
didn't correspond to a single character through the conversion
from the encoding specified by the encoding pragma.
The escape was replaced with REPLACEMENT CHARACTER (U+FFFD) instead.
The <-- HERE shows in the regular expression about where the
escape was discovered.

=item Invalid mro name: '%s'

(F) You tried to C<mro::set_mro("classname", "foo")>
or C<use mro 'foo'>, where C<foo> is not a valid method resolution order (MRO).
(Currently, the only valid ones are C<dfs> and C<c3>). See L<mro>.

a1936 11
=item Invalid version format (multiple underscores)

(F) Versions may contain at most a single underscore, which signals
that the version is a beta release.  See L<version> for the allowed
version formats.

=item Invalid version format (underscores before decimal)

(F) Versions may not contain decimals after the optional underscore.
See L<version> for the allowed version formats.

a1957 12
=item $* is no longer supported

(S deprecated, syntax) The special variable C<$*>, deprecated in older perls, has
been removed as of 5.9.0 and is no longer supported. You should use the
C<//m> and C<//s> regexp modifiers instead.

=item $# is no longer supported

(S deprecated, syntax) The special variable C<$#>, deprecated in older perls, has
been removed as of 5.9.3 and is no longer supported. You should use the
printf/sprintf functions instead.

d2008 1
a2008 1
=item Lookbehind longer than %d not implemented in regex m/%s/
d2011 2
a2012 1
handle. This restriction may be eased in a future release. 
d2059 2
a2060 11
(S utf8) (F) Perl detected a string that didn't comply with UTF-8
encoding rules, even though it had the UTF8 flag on.

One possible cause is that you set the UTF8 flag yourself for data that
you thought to be in UTF-8 but it wasn't (it was for example legacy
8-bit data). To guard against this, you can use Encode::decode_utf8.

If you use the C<:encoding(UTF-8)> PerlIO layer for input, invalid byte
sequences are handled gracefully, but if you use C<:utf8>, the flag is
set without validating the data, possibly resulting in this error
message.
d2062 3
a2064 1
See also L<Encode/"Handling Malformed Data">.
a2070 23
=item Malformed UTF-8 string in pack

(F) You tried to pack something that didn't comply with UTF-8 encoding
rules and perl was unable to guess how to make more progress.

=item Malformed UTF-8 string in unpack

(F) You tried to unpack something that didn't comply with UTF-8 encoding
rules and perl was unable to guess how to make more progress.

=item Malformed UTF-8 string in '%c' format in unpack

(F) You tried to unpack something that didn't comply with UTF-8 encoding
rules and perl was unable to guess how to make more progress.

=item Maximal count of pending signals (%s) exceeded

(F) Perl aborted due to a too important number of signals pending. This
usually indicates that your operating system tried to deliver signals
too fast (with a very high priority), starving the perl process from
resources it would need to reach a point where it can process signals
safely. (See L<perlipc/"Deferred Signals (Safe Signals)">.)

d2224 6
d2241 1
a2241 1
=item "%s" variable %s can't be in a package
d2288 1
a2288 1
=item next::method/next::can/maybe::next::method cannot find enclosing method
d2290 6
a2295 3
(F) C<next::method> needs to be called within the context of a
real method in a real package, and it could not find such a context.
See L<mro>.
a2372 7
=item No next::method '%s' found for %s

(F) C<next::method> found no further instances of this method name
in the remaining packages of the MRO of this class.  If you don't want
it throwing an exception, use C<maybe::next::method>
or C<next::can>. See L<mro>.

a2415 6
=item No such class field "%s" in variable %s of type %s

(F) You tried to access a key from a hash through the indicated typed variable
but that key is not allowed by the package of the same type.  The indicated
package has restricted the set of allowed keys using the L<fields> pragma.

d2418 1
a2418 1
(F) You provided a class qualifier in a "my", "our" or "state" declaration, but
d2427 13
d2597 4
a2600 7
(F, W layer) You tried to do a read/write/send/recv/seek operation
with an offset pointing outside the buffer.  This is difficult to
imagine.  The sole exceptions to this are that zero padding will
take place when going past the end of the string when either
C<sysread()>ing a file, or when seeking past the end of a scalar opened
for I/O (in anticipation of future reads and to imitate the behaviour
with real files).
a2620 14
=item Opening dirhandle %s also as a file

(W io deprecated) You used open() to associate a filehandle to
a symbol (glob or scalar) that already holds a dirhandle.
Although legal, this idiom might render your code confusing
and is deprecated.

=item Opening filehandle %s also as a directory

(W io deprecated) You used opendir() to associate a dirhandle to
a symbol (glob or scalar) that already holds a filehandle.
Although legal, this idiom might render your code confusing
and is deprecated.

a2689 5
=item '.' outside of string in pack

(F) The argument to a '.' in your template tried to move the working
position to before the start of the packed string being built.

a2694 6
=item '@@' outside of string with malformed UTF-8 in unpack

(F) You had a template that specified an absolute position outside
the string being unpacked. The string being unpacked was also invalid
UTF-8. See L<perlfunc/pack>.

a2715 7
=item panic: attempt to call %s in %s

(P) One of the file test operators entered a code branch that calls
an ACL related-function, but that function is not available on this
platform.  Earlier checks mean that it should not be possible to
enter this branch on this platform.

a2755 5
=item panic: fold_constants JMPENV_PUSH returned %d

(P) While attempting folding constants an exception other than an C<eval>
failure was caught.

a2764 7
=item panic: hfreeentries failed to free hash

(P) The internal routine used to clear a hashes entries tried repeatedly,
but each time something added more entries to the hash. Most likely the hash
contains an object with a reference back to the hash and a destructor that
adds a new object to the hash.

d2801 4
d2809 4
a2884 5
=item panic: unimplemented op %s (#%d) called

(P) The compiler is screwed up and attempted to use an op that isn't permitted
at run time.

a2893 9
=item Pattern subroutine nesting without pos change exceeded limit in regex; marked by <-- HERE in m/%s/

(F) You used a pattern that uses too many nested subpattern calls without
consuming any text. Restructure the pattern so text is consumed before the
nesting limit is exceeded.

The <-- HERE shows in the regular expression about where the problem was
discovered.

d2904 1
a2904 1
Remember that "my", "our", "local" and "state" bind tighter than comma.
a2917 7
=item Perl_my_%s() not available

(F) Your platform has very uncommon byte-order and integer size,
so it was not possible to set up some or all fixed-width byte-order
conversion functions.  This is only a problem when you're using the
'<' or '>' modifiers in (un)pack templates.  See L<perlfunc/pack>.

d3085 5
d3155 6
a3190 5
=item readdir() attempted on invalid dirhandle %s

(W io) The dirhandle you're reading from is either closed or not really
a dirhandle.  Check your control flow.

d3221 2
a3222 3
(F) While calculating the method resolution order (MRO) of a package, Perl
believes it found an infinite loop in the C<@@ISA> hierarchy.  This is a
crude check that bails out after 100 levels of C<@@ISA> depth.
a3251 7
=item Reference to invalid group 0

(F) You used C<\g0> or similar in a regular expression. You may refer to
capturing parentheses only with strictly positive integers (normal
backreferences) or with strictly negative integers (relative
backreferences), but using 0 does not make sense.

a3261 28
=item Reference to nonexistent or unclosed group in regex; marked by <-- HERE in m/%s/

(F) You used something like C<\g{-7}> in your regular expression, but there are
not at least seven sets of closed capturing parentheses in the expression before
where the C<\g{-7}> was located.

The <-- HERE shows in the regular expression about where the problem was
discovered.

=item Reference to nonexistent named group in regex; marked by <-- HERE in m/%s/

(F) You used something like C<\k'NAME'> or C<< \k<NAME> >> in your regular
expression, but there is no corresponding named capturing parentheses such
as C<(?'NAME'...)> or C<(?<NAME>...). Check if the name has been spelled
correctly both in the backreference and the declaration.

The <-- HERE shows in the regular expression about where the problem was
discovered.

=item (?(DEFINE)....) does not allow branches in regex; marked by <-- HERE in m/%s/

(F) You used something like C<(?(DEFINE)...|..)> which is illegal. The
most likely cause of this error is that you left out a parenthesis inside
of the C<....> part.

The <-- HERE shows in the regular expression about where the problem was
discovered.

a3282 5
=item rewinddir() attempted on invalid dirhandle %s

(W io) The dirhandle you tried to do a rewinddir() on is either closed or not
really a dirhandle.  Check your control flow.

a3358 5
=item seekdir() attempted on invalid dirhandle %s

(W io) The dirhandle you are doing a seekdir() on is either closed or not
really a dirhandle.  Check your control flow.

a3404 5
=item Sequence \\%s... not terminated in regex; marked by <-- HERE in m/%s/

(F) The regular expression expects a mandatory argument following the escape
sequence and this has been omitted or incorrectly written.

a3496 6
=item !=~ should be !~

(W syntax) The non-matching operator is !~, not !=~.  !=~ will be
interpreted as the != (numeric not equal) and ~ (1's complement)
operators: probably not what you intended.

d3582 1
a3582 1
L<perlop/"Regexp Quote-Like Operators">.
a3608 5
=item sv_upgrade from type %d down to type %d

(P) Perl tried to force the upgrade an SV to a type which was actually
inferior to its current type.

a3704 5
=item telldir() attempted on invalid dirhandle %s

(W io) The dirhandle you tried to telldir() is either closed or not really
a dirhandle.  Check your control flow.

d3742 2
a3743 1
(F) This attribute was never supported on C<my> or C<sub> declarations.
d3761 6
d3797 1
a3797 1
(F) Your template contains ()-groups with a ridiculously deep nesting level.
d3807 1
a3807 1
B<-M>, B<-m> or B<-C> option.  This is an error because those options
a4009 7

=item Unknown verb pattern '%s' in regex; marked by <-- HERE in m/%s/

(F) You either made a typo or have incorrectly put a C<*> quantifier
after an open brace in your pattern.  Check the pattern and review
L<perlre> for details on legal verb patterns.

d4040 1
a4040 1
=item Unrecognized character %s in column %d
d4043 2
a4044 2
in your Perl script (or eval) at the specified column.  Perhaps you tried 
to run a compressed script, a binary program, or a directory as a Perl program.
d4046 1
a4046 1
=item Unrecognized escape \\%c in character class passed through in regex; marked by <-- HERE in m/%s/
a4050 2
The <-- HERE shows in the regular expression about where the
escape was discovered.
d4055 1
a4055 1
recognized by Perl.  The character was understood literally.
d4060 3
a4062 2
recognized by Perl.  The character was understood literally.
The <-- HERE shows in the regular expression about where the
a4129 15
=item Unterminated verb pattern in regex; marked by <-- HERE in m/%s/

(F) You used a pattern of the form C<(*VERB)> but did not terminate
the pattern with a C<)>. Fix the pattern and retry.

=item Unterminated verb pattern argument in regex; marked by <-- HERE in m/%s/

(F) You used a pattern of the form C<(*VERB:ARG)> but did not terminate
the pattern with a C<)>. Fix the pattern and retry.

=item Unterminated \g{...} pattern in regex; marked by <-- HERE in m/%s/

(F) You missed a close brace on a \g{..} pattern (group reference) in
a regular expression. Fix the pattern and retry.

a4165 6
=item Useless localization of %s

(W syntax) The localization of lvalues such as C<local($x=10)> is
legal, but in fact the local() currently has no effect. This may change at
some point in the future, but in the meantime such code is discouraged.

d4331 12
d4371 1
a4371 1
operators and then you assumably know what you are doing.
d4395 7
a4401 8
To help you figure out what was undefined, perl will try to tell you the
name of the variable (if any) that was undefined. In some cases it cannot
do this, so it also tells you what operation you used the undefined value
in.  Note, however, that perl optimizes your program and the operation
displayed in the warning may not necessarily appear literally in your
program.  For example, C<"that $foo"> is usually optimized into C<"that "
. $foo>, and the warning will refer to the C<concatenation (.)> operator,
even though there is no C<.> in your program.
a4442 30
=item Variable "%s" is not available

(W closure) During compilation, an inner named subroutine or eval is
attempting to capture an outer lexical that is not currently available.
This can happen for one of two reasons. First, the outer lexical may be
declared in an outer anonymous subroutine that has not yet been created.
(Remember that named subs are created at compile time, while anonymous
subs are created at run-time.) For example,

    sub { my $a; sub f { $a } }

At the time that f is created, it can't capture the current value of $a,
since the anonymous subroutine hasn't been created yet. Conversely,
the following won't give a warning since the anonymous subroutine has by
now been created and is live:

    sub { my $a; eval 'sub f { $a }' }->();

The second situation is caused by an eval accessing a variable that has
gone out of scope, for example,

    sub f {
	my $a;
	sub { eval '$a' }
    }
    f()->();

Here, when the '$a' in the eval is being compiled, f() is not currently being
executed, so its $a is not available for capture.

d4451 1
a4451 1
=item Variable length lookbehind not implemented in m/%s/
d4454 2
a4455 1
known at compile time.  See L<perlre>.
d4459 1
a4459 1
(W misc) A "my", "our" or "state" variable has been redeclared in the current
d4465 21
d4495 1
a4495 1
lexical variable defined in an outer named subroutine.
d4497 1
a4497 1
When the inner subroutine is called, it will see the value of
d4504 4
d4510 1
a4510 1
reference variables in outer subroutines are created, they
a4512 10
=item Verb pattern '%s' has a mandatory argument in regex; marked by <-- HERE in m/%s/ 

(F) You used a verb pattern that requires an argument. Supply an argument
or check that you are using the right verb.

=item Verb pattern '%s' may not have an argument in regex; marked by <-- HERE in m/%s/ 

(F) You used a verb pattern that is not allowed an argument. Remove the 
argument or check that you are using the right verb.

a4518 17
=item Version string '%s' contains invalid data; ignoring: '%s'

(W misc) The version string contains invalid characters at the end, which
are being ignored.

=item v-string in use/require is non-portable

(W portable) The use of v-strings is non-portable to older, pre-5.6, Perls.
If you want your scripts to be backward portable, use the floating
point version number: for example, instead of C<use 5.6.1> say
C<use 5.006_001>. This of course won't make older Perls suddenly start
understanding newer features, but at least they will show a sensible
error message indicating the required minimum version.

This warning is suppressed if the C<use 5.x.y> is preceded by a
C<use 5.006> (see C<use VERSION> in L<perlfunc/use>).

d4522 1
a4522 1
you called it with no args and C<$@@> was empty.
a4612 4

=head1 SEE ALSO

L<warnings>, L<perllexwarn>.
@


1.1.1.12
log
@import perl 5.10.1
@
text
@d134 1
a134 1
=item %s argument is not a HASH or ARRAY element or a subroutine
d905 7
a1426 3
This threshold can be changed from 100, by recompiling the F<perl> binary,
setting the C pre-processor macro C<PERL_SUB_DEPTH_WARN> to the desired value.

d1600 1
a1600 1
=item %s: Eval-group not allowed at runtime, use re 'eval'
d2197 2
a2198 6
been removed as of 5.9.0 and is no longer supported. In previous versions of perl the use of
C<$*> enabled or disabled multi-line matching within a string.

Instead of using C<$*> you should use the C</m> (and maybe C</s>) regexp
modifiers. (In older versions: when C<$*> was set to a true value then all regular
expressions behaved as if they were written using C</m>.)
d2431 1
a2431 1
(F) Missing right brace in C<\x{...}>, C<\p{...}> or C<\P{...}>.
a2701 5
=item No such hook: %s

(F) You specified a signal hook that was not recognized by Perl.  Currently, Perl
accepts C<__DIE__> and C<__WARN__> as valid signal hooks

a3182 5
=item panic: sv_chop %s

(P) The sv_chop() routine was passed a position that is not within the
scalar's string buffer.

a3897 6
=item Smart matching a non-overloaded object breaks encapsulation

(F) You should not use the C<~~> operator on an object that does not
overload it: Perl refuses to use the object's underlying structure for
the smart match.

d4189 2
a4190 9
B<-M>, B<-m> or B<-C> option.

In the case of B<-M> and B<-m>, this is an error because those options are
not intended for use inside scripts.  Use the C<use> pragma instead.

The B<-C> option only works if it is specified on the command line as well
(with the same sequence of letters or numbers following). Either specify
this option on the command line, or, if your system supports it, make your
script executable and run it directly instead of passing it to perl. 
d4659 2
a4660 7
(D deprecated, W syntax) You are now encouraged to use the explicitly quoted
form if you wish to use an empty line as the terminator of the here-document.

=item Use of comma-less variable list is deprecated

(D deprecated, W syntax) The values you give to a format should be
separated by commas, not just aligned on a line.
d4709 2
a4710 2
(D deprecated, W syntax) It makes a lot of work for the compiler when you
clobber a subroutine's argument list, so it's better if you assign the results
d4938 12
d4982 1
a4982 1
(S utf8) Perl met a wide character (>255) when it wasn't expecting
@


1.1.1.13
log
@Perl 5.12.2 from CPAN
@
text
@d11 1
a11 1
    (D) A deprecation (enabled by default).
d118 2
a119 2
a scalar value (the length of an array, or the population info of a
hash) and then work on that scalar value.  This is probably not what
d309 1
a309 15
=item Attribute "locked" is deprecated

(D deprecated) You have used the attributes pragam to modify the "locked"
attribute on a code reference. The :locked attribute is obsolete, has had no
effect since 5005 threads were removed, and will be removed in the next major
release of Perl 5.

=item Attribute "unique" is deprecated

(D deprecated) You have used the attributes pragam to modify the "unique"
attribute on an array, hash or scalar reference. The :unique attribute has
had no effect since Perl 5.8.8, and will be removed in the next major
release of Perl 5.

=item Bad arg length for %s, is %d, should be %d
a361 5
=item Bad plugin affecting keyword '%s'

(F) An extension using the keyword plugin mechanism violated the
plugin API.

a509 5
=item Cannot find encoding "%s"

(S io) You tried to apply an encoding that did not exist to a filehandle,
either with open() or binmode().

d654 18
d719 3
a721 3
could not be found. Maybe you misspelled the name of the property?
See L<perluniprops/Properties accessible through \p{} and \P{}>
for a complete list of available properties.
d754 2
a755 4
example C<\p{Lu}> matches all uppercase letters).  If you did mean to use a
Unicode property, see
L<perluniprops/Properties accessible through \p{} and \P{}>
for a complete list of available properties.
d760 1
a760 1
=item Can't fork: %s
a764 5
=item Can't fork, trying again in 5 seconds

(W pipe) A fork in a piped open failed with EAGAIN and will be retried
after five seconds.

a831 6
=item Can't kill a non-numeric process ID

(F) Process identifiers must be (signed) integers.  It is a fatal error to
attempt to kill() an undefined, empty-string or otherwise non-numeric
process identifier.

d1034 1
a1034 1
=item Can't resolve method "%s" overloading "%s" in package "%s"
d1040 5
d1069 5
a1445 8
=item Deprecated character(s) in \\N{...} starting at '%s'

(D deprecated) Just about anything is legal for the C<...> in C<\N{...}>.
But starting in 5.12, non-reasonable ones that don't look like names are
deprecated.  A reasonable name begins with an alphabetic character and
continues with any combination of alphanumerics, dashes, spaces, parentheses or
colons.

d1630 1
a1630 1
=item Execution of %s aborted due to compilation errors.
a1837 14
=item gmtime(%.0f) too large

(W overflow) You called C<gmtime> with an number that was larger than
it can reliably handle and C<gmtime> probably returned the wrong
date. This warning is also triggered with nan (the special
not-a-number value).

=item gmtime(%.0f) too small

(W overflow) You called C<gmtime> with an number that was smaller than
it can reliably handle and C<gmtime> probably returned the wrong
date. This warning is also triggered with nan (the special
not-a-number value).

d1854 1
a1854 1
=item %s had compilation errors.
d1887 1
a1887 1
=item Ignoring zero length \N{} in character class
d1889 2
a1890 2
(W) Named Unicode character escapes (\N{...}) may return a
zero length sequence.  When such an escape is used in a character class
d1914 2
a1915 2
(W illegalproto) An illegal character was found in a prototype declaration.
Legal characters in prototypes are $, @@, %, *, ;, [, ], &, and \.
d1957 1
a1957 1
=item Illegal switch in PERL5OPT: -%c
d2179 1
a2179 1
=item IO layers (like '%s') unavailable
d2192 1
a2192 1
(D deprecated, syntax) The special variable C<$*>, deprecated in older perls, has
d2202 1
a2202 1
(D deprecated, syntax) The special variable C<$#>, deprecated in older perls, has
a2249 14
=item Lexing code attempted to stuff non-Latin-1 character into Latin-1 input

(F) An extension is attempting to insert text into the current parse
(using L<lex_stuff_pvn_flags|perlapi/lex_stuff_pvn_flags> or similar), but
tried to insert a character that couldn't be part of the current input.
This is an inherent pitfall of the stuffing mechanism, and one of the
reasons to avoid it.  Where it is necessary to stuff, stuffing only
plain ASCII is recommended.

=item Lexing code internal error (%s)

(F) Lexing code supplied by an extension violated the lexer's API in a
detectable way.

a2255 14
=item localtime(%.0f) too large

(W overflow) You called C<localtime> with an number that was larger
than it can reliably handle and C<localtime> probably returned the
wrong date. This warning is also triggered with nan (the special
not-a-number value).

=item localtime(%.0f) too small

(W overflow) You called C<localtime> with an number that was smaller
than it can reliably handle and C<localtime> probably returned the
wrong date. This warning is also triggered with nan (the special
not-a-number value).

a2260 9
=item Lost precision when %s %f by 1

(W) The value you attempted to increment or decrement by one is too large
for the underlying floating point representation to store accurately,
hence the target of C<++> or C<--> is unchanged. Perl issues this warning
because it has already switched from integers to floating point when values
are too large for integers, and now even floating point is insufficient.
You may wish to switch to using L<Math::BigInt> explicitly.

a2266 8
=item lvalue attribute ignored after the subroutine has been defined

(W misc) Making a subroutine an lvalue subroutine after it has been defined
by declaring the subroutine with a lvalue attribute is not
possible. To make the the subroutine a lvalue subroutine add the
lvalue attribute to the definition, or put the the declaration before
the definition.

d2322 1
a2322 1
(F) Perl thought it was reading UTF-16 encoded character data but while
a2324 4
=item Malformed UTF-8 returned by \N

(F) The charnames handler returned malformed UTF-8.

d2340 1
a2340 1
=item Maximal count of pending signals (%d) exceeded
d2342 1
a2342 1
(F) Perl aborted due to a too high number of signals pending. This
a2386 5
=item Missing argument in %s

(W uninitialized) A printf-type format required more arguments than were
supplied.

d2392 1
a2392 1
=item Missing braces on \N{}
d2395 1
a2395 4
double-quotish context.  This can also happen when there is a space (or
comment) between the C<\N> and the C<{> in a regex with the C</x> modifier.
This modifier does not change the requirement that the brace immediately follow
the C<\N>.
d2431 1
a2431 28
(F) Missing right brace in C<\x{...}>, C<\p{...}>, C<\P{...}>, or C<\N{...}>.

=item Missing right brace on \\N{} or unescaped left brace after \\N

(F)
C<\N> has two meanings.

The traditional one has it followed by a name enclosed
in braces, meaning the character (or sequence of characters) given by that name.
Thus C<\N{ASTERISK}> is another way of writing C<*>, valid in both
double-quoted strings and regular expression patterns.  In patterns, it doesn't
have the meaning an unescaped C<*> does.

Starting in Perl 5.12.0, C<\N> also can have an additional meaning (only) in
patterns, namely to match a non-newline character.  (This is short for
C<[^\n]>, and like C<.> but is not affected by the C</s> regex modifier.)

This can lead to some ambiguities.  When C<\N> is not followed immediately by a
left brace, Perl assumes the C<[^\n]> meaning.  Also, if
the braces form a valid quantifier such as C<\N{3}> or C<\N{5,}>, Perl assumes
that this means to match the given quantity of non-newlines (in these examples,
3; and 5 or more, respectively).  In all other case, where there is a C<\N{>
and a matching C<}>, Perl assumes that a character name is desired.

However, if there is no matching C<}>, Perl doesn't know if it was mistakenly
omitted, or if C<[^\n]{> was desired, and
raises this error.  If you meant the former, add the right brace; if you meant
the latter, escape the brace with a backslash, like so: C<\N\{>
d2485 1
a2485 1
=item More than one argument to '%s' open
a2517 36
=item \\N in a character class must be a named character: \\N{...}

(F) The new (5.12) meaning of C<\N> as C<[^\n]> is not valid in a bracketed
character class, for the same reason that C<.> in a character class loses its
specialness: it matches almost everything, which is probably not what you want.

=item \\N{NAME} must be resolved by the lexer

(F) When compiling a regex pattern, an unresolved named character or sequence
was encountered.  This can happen in any of several ways that bypass the lexer,
such as using single-quotish context, or an extra backslash in double quotish:

    $re = '\N{SPACE}';	# Wrong!
    $re = "\\N{SPACE}";	# Wrong!
    /$re/;

Instead, use double-quotes with a single backslash:

    $re = "\N{SPACE}";	# ok
    /$re/;

The lexer can be bypassed as well by creating the pattern from smaller
components:

    $re = '\N';
    /${re}{SPACE}/;	# Wrong!

It's not a good idea to split a construct in the middle like this, and it
doesn't work here.  Instead use the solution above.

Finally, the message also can happen under the C</x> regex modifier when the
C<\N> is separated by spaces from the C<{>, in which case, remove the spaces.

    /\N {SPACE}/x;	# Wrong!
    /\N{SPACE}/x;	# ok

a2529 6
=item Invalid hexadecimal number in \\N{U+...}

(F) The character constant represented by C<...> is not a valid hexadecimal
number.  Either it is empty, or you tried to use a character other than 0 - 9
or A - F, a - f in a hexadecimal number.

a2995 11
=item Overloaded dereference did not return a reference

(F) An object with an overloaded dereference operator was dereferenced,
but the overloaded operation did not return a reference. See
L<overload>.

=item Overloaded qr did not return a REGEXP

(F) An object with a C<qr> overload was used as part of a match, but the
overloaded operation didn't return a compiled regexp. See L<overload>.

a3211 5
=item panic: utf16_to_utf8_reversed: odd bytelen

(P) Something tried to call utf16_to_utf8_reversed with an odd (as opposed
to even) byte length.

a3255 7
=item Perl_pmflag() is deprecated, and will be removed from the XS API

(D deprecated) XS code called the C function C<Perl_pmflag>. This was part of
Perl's listed public API for extending or embedding the perl interpreter. It has
now been removed from the public API, and will be removed in a future release,
hence XS code should be re-written not to use it.

d3293 4
d3307 5
d3423 14
a3436 1
=item Possible unintended interpolation of $\ in regex
d3438 2
a3439 11
(W ambiguous) You said something like C<m/$\/> in a regex.
The regex C<m/foo$\s+bar/m> translates to: match the word 'foo', the output
record separator (see L<perlvar/$\>) and the letter 's' (one time or more)
followed by the word 'bar'.

If this is what you intended then you can silence the warning by using 
C<m/${\}/> (for example: C<m/foo${\}s+bar/>).

If instead you intended to match the word 'foo' at the end of the line
followed by whitespace and the word 'bar' on the next line then you can use
C<m/$(?)\/> (for example: C<m/foo$(?)\s+bar/>).
a3477 5
=item Prototype after '%c' for %s : %s

(W illegalproto) A character follows % or @@ in a prototype. This is useless,
since % and @@ gobble the rest of the subroutine arguments.

a3645 6
=item Replacement list is longer than search list

(W misc) You have used a replacement list that is longer than the
search list. So the additional elements in the replacement list
are meaningless.

d3656 8
d3701 5
d3919 6
d3957 1
a3957 1
=item Stub found while resolving method "%s" overloading "%s" in package "%s"
d3999 5
d4173 1
a4173 1
B<-T> option (or the B<-t> option), but Perl was not invoked with B<-T> in its command line.
d4180 2
a4181 2
editing the #! line so that the B<-%c> option is a part of Perl's first
argument: e.g. change C<perl -n -%c> to C<perl -%c -n>.
d4184 1
a4184 1
B<-%c> option must appear on the command line: C<perl -%c scriptname>.
d4349 1
a4349 1
=item Unicode non-character %s is illegal for interchange
d4351 3
a4353 8
(W utf8) Certain codepoints, such as U+FFFE and U+FFFF, are defined by the
Unicode standard to be non-characters. Those are legal codepoints, but are
reserved for internal use; so, applications shouldn't attempt to exchange
them.  In some cases, this message is also given if you use a codepoint that
isn't in Unicode--that is it is above the legal maximum of U+10FFFF.  These
aren't legal at all in Unicode, so they are illegal for interchange, but can be
used internally in a Perl program.  If you know what you are doing you can turn
off this warning by C<no warnings 'utf8';>.
d4452 1
a4452 1
=item Unrecognized character %s; marked by <-- HERE after %s near column %d
d4455 1
a4455 1
in your Perl script (or eval) near the specified column.  Perhaps you tried 
d4462 1
a4462 1
understood literally, but this may change in a future version of Perl.
d4469 1
a4469 2
recognized by Perl.  The character was understood literally, but this may
change in a future version of Perl.
d4474 1
a4474 2
recognized by Perl.  The character was understood literally, but this may
change in a future version of Perl.
a4613 6
=item Useless use of /d modifier in transliteration operator

(W misc) You have used the /d modifier where the searchlist has the
same length as the replacelist. See L<perlop> for more information
about the /d modifier.

a4679 5
=item Use of assignment to $[ is deprecated

(D deprecated) The C<$[> variable (index of the first element in an array)
is deprecated. See L<perlvar/"$[">.

d4682 1
a4682 1
(D deprecated) You are now encouraged to use the explicitly quoted
d4687 1
a4687 1
(D deprecated) The values you give to a format should be
a4710 8
=item Use of := for an empty attribute list is deprecated

(D deprecated) The construction C<my $x := 42> currently
parses correctly in perl, being equivalent to C<my $x : = 42>
(applying an empty attribute list to C<$x>). This useless
construct is now deprecated, so C<:=> can be reclaimed as a new
operator in the future.

d4735 1
a4735 1
=item Use of "goto" to jump into a construct is deprecated
d4737 3
a4739 2
(D deprecated) Using C<goto> to jump from an outer scope into an inner
scope is deprecated and should be avoided.
a4764 9
=item Use of octal value above 377 is deprecated

(D deprecated, W regexp) There is a constant in the regular expression whose
value is interpeted by Perl as octal and larger than 377 (255 decimal, 0xFF
hex).  Perl may take this to mean different things depending on the rest of
the regular expression.  If you meant such an octal value, convert it to
hexadecimal and use C<\xHH> or C<\x{HH}> instead.  If you meant to have
part of it mean a backreference, use C<\g> for that.  See L<perlre>.

a4844 14
=item Using just the first character returned by \N{} in character class

(W) A charnames handler may return a sequence of more than one character.
Currently all but the first one are discarded when used in a regular
expression pattern bracketed character class.

=item Using just the first characters returned by \N{}

(W) A charnames handler may return a sequence of characters.  There is a finite
limit as to the number of characters that can be used, which this sequence
exceeded.  In the message, the characters in the sequence are separated by
dots, and each is shown by its ordinal in hex.  Anything to the left of the
C<HERE> was retained; anything to the right was discarded.

d4847 1
a4847 1
(W utf8) You tried to generate half of a UTF-16 surrogate by
d4852 1
a4852 1
character.  If you really really know what you are doing you can turn off
@


1.1.1.14
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d26 1
a26 1
and B<-W> switches.  Warnings may be captured by setting C<$SIG{__WARN__}>
d53 1
a53 1
=item Allocation too large: %x
a91 60
=item Ambiguous use of %c resolved as operator %c

(W ambiguous) C<%>, C<&>, and C<*> are both infix operators (modulus,
bitwise and, and multiplication) I<and> initial special characters
(denoting hashes, subroutines and typeglobs), and you said something
like C<*foo * foo> that might be interpreted as either of them.  We
assumed you meant the infix operator, but please try to make it more
clear -- in the example given, you might write C<*foo * foo()> if you
really meant to multiply a glob by the result of calling a function.

=item Ambiguous use of %c{%s} resolved to %c%s

(W ambiguous) You wrote something like C<@@{foo}>, which might be
asking for the variable C<@@foo>, or it might be calling a function
named foo, and dereferencing it as an array reference.  If you wanted
the variable, you can just write C<@@foo>.  If you wanted to call the
function, write C<@@{foo()}> ... or you could just not have a variable
and a function with the same name, and save yourself a lot of trouble.

=item Ambiguous use of %c{%s[...]} resolved to %c%s[...]

=item Ambiguous use of %c{%s{...}} resolved to %c%s{...}

(W ambiguous) You wrote something like C<${foo[2]}> (where foo represents
the name of a Perl keyword), which might be looking for element number
2 of the array named C<@@foo>, in which case please write C<$foo[2]>, or you
might have meant to pass an anonymous arrayref to the function named
foo, and then do a scalar deref on the value it returns.  If you meant
that, write C<${foo([2])}>.

In regular expressions, the C<${foo[2]}> syntax is sometimes necessary
to disambiguate between array subscripts and character classes.
C</$length[2345]/>, for instance, will be interpreted as C<$length> followed
by the character class C<[2345]>.  If an array subscript is what you
want, you can avoid the warning by changing C</${length[2345]}/> to the
unsightly C</${\$length[2345]}/>, by renaming your array to something
that does not coincide with a built-in keyword, or by simply turning
off warnings with C<no warnings 'ambiguous';>.

=item Ambiguous use of -%s resolved as -&%s()

(W ambiguous) You wrote something like C<-foo>, which might be the
string C<"-foo">, or a call to the function C<foo>, negated.  If you meant
the string, just write C<"-foo">.  If you meant the function call,
write C<-foo()>.

=item Ambiguous use of 's//le...' resolved as 's// le...'; Rewrite as 's//el' if you meant 'use locale rules and evaluate rhs as an expression'.  In Perl 5.18, it will be resolved the other way

(W deprecated, ambiguous) You wrote a pattern match with substitution
immediately followed by "le".  In Perl 5.16 and earlier, this is
resolved as meaning to take the result of the substitution, and see if
it is stringwise less-than-or-equal-to what follows in the expression.
Having the "le" immediately following a pattern is deprecated behavior,
so in Perl 5.18, this expression will be resolved as meaning to do the
pattern match using the rules of the current locale, and evaluate the
rhs as an expression when doing the substitution.  In 5.14, and 5.16 if
you want the latter interpretation, you can simply write "el" instead.
But note that the C</l> modifier should not be used explicitly anyway;
you should use C<use locale> instead.  See L<perllocale>.

d123 7
d170 6
a175 7
(W layer) When pushing a layer with arguments onto the Perl I/O
system you forgot the ) that closes the argument list.  (Layers
take care of transforming data between external and internal
representations.)  Perl stopped parsing the layer list at this
point and did not attempt to push this layer.  If your program
didn't explicitly request the failing operation, it may be the
result of the value of the environment variable PERLIO.
d184 1
a184 1
(X) The malloc package that comes with Perl had an internal failure.
d188 1
a188 6
(X) A general assertion failed.  The file in question must be examined.

=item Assigning non-zero to $[ is no longer possible

(F) When the "array_base" feature is disabled (e.g., under C<use v5.16;>)
the special variable C<$[>, which is deprecated, is now a fixed zero value.
d198 4
a201 4
(W threads)(S) When using threaded Perl, a thread (not necessarily
the main thread) exited while there were still other threads running.
Usually it's a good idea first to collect the return values of the
created threads by joining them, and only then to exit from the main
d212 1
a212 1
the name of the package to bless the resulting object into.  You've
a226 7
=item Attempt to clear deleted array

(S debugging) An array was assigned to when it was being freed.
Freed values are not supposed to be visible to Perl code.  This
can also happen if XS code calls C<av_clear> from a custom magic
callback on the array.

d237 1
a237 1
=item Attempt to free non-arena SV: 0x%x
d239 1
a239 1
(S internal) All SV objects are supposed to be allocated from arenas
d243 1
a243 1
=item Attempt to free nonexistent shared string '%s'%s
d245 1
a245 1
(S internal) Perl maintains a reference-counted internal table of
d250 1
a250 1
=item Attempt to free temp prematurely: SV 0x%x
d252 1
a252 1
(S debugging) Mortalized values are supposed to be freed by the
d260 1
a260 1
(S internal) The reference counts got screwed up on symbol aliases.
d262 1
a262 1
=item Attempt to free unreferenced scalar: SV 0x%x
d298 1
a298 1
of an array and later assigning through that reference.  For example
d311 4
a314 4
(D deprecated) You have used the attributes pragma to modify the
"locked" attribute on a code reference.  The :locked attribute is
obsolete, has had no effect since 5005 threads were removed, and
will be removed in a future release of Perl 5.
d318 4
a321 4
(D deprecated) You have used the attributes pragma to modify
the "unique" attribute on an array, hash or scalar reference.
The :unique attribute has had no effect since Perl 5.8.8, and
will be removed in a future release of Perl 5.
d323 1
a323 6
=item av_reify called on tied array

(S debugging) This indicates that something went wrong and Perl got I<very>
confused about C<@@_> or C<@@DB::args> being tied.

=item Bad arg length for %s, is %u, should be %d
d345 1
a345 1
been malloc()ed in the first place.  Mandatory, but can be disabled by
d349 1
a349 1
dynamic linking, like C<AIX> and C<OS/2>.  It is a bug of C<Berkeley DB>
d362 1
a362 1
=item Bad name after %s
d383 3
a385 3
(S malloc) An internal routine called realloc() on something that
had never been malloc()ed in the first place.  Mandatory, but can
be disabled by setting the environment variable C<PERL_BADFREE> to 1.
d397 1
d472 1
a472 9
Check your control flow and number of arguments.

=item "\b{" is deprecated; use "\b\{" instead

=item "\B{" is deprecated; use "\B\{" instead

(W deprecated, regexp) Use of an unescaped "{" immediately following a
C<\b> or C<\B> is now deprecated so as to reserve its use for Perl
itself in a future release.
d478 1
a478 1
=item Bizarre copy of %s
d481 1
a481 1
copiable.
a488 5
=item Bizarre SvTYPE [%d]

(P) When starting a new thread or return values from a thread, Perl
encountered an invalid data type.

d519 4
a522 4
(F) You manipulated Perl's symbol table directly, stored a reference
in it, then tried to access that symbol via conventional Perl syntax.
The access triggers Perl to autovivify that typeglob, but it there is
no legal conversion from that type of reference to a typeglob.
d524 1
a524 1
=item Cannot copy to %s
d527 1
a527 1
be directly assigned to.
a533 12
=item Cannot set tied @@DB::args

(F) C<caller> tried to set C<@@DB::args>, but found it tied.  Tying C<@@DB::args>
is not supported.  (Before this error was added, it used to crash.)

=item Cannot tie unreifiable array

(P) You somehow managed to call C<tie> on an array that does not
keep a reference count on its arguments and cannot be made to
do so.  Such arrays are not even supposed to be accessible to
Perl code, but are only used internally.

d548 1
a548 1
a C<given> block.  You probably meant to use C<next> or C<last>.
d554 6
d598 7
a604 1
=item Can't coerce %s to %s in %s
d619 10
d639 6
a649 7
=item Can't "default" outside a topicalizer

(F) You have used a C<default> block that is neither inside a
C<foreach> loop nor a C<given> block.  (Note that this error is
issued on exit from the C<default> block, so you won't get the
error if you use an explicit C<continue>.)

d674 3
a676 4
(F) Minima must be less than or equal to maxima.  If you really
want your regexp to match something 0 times, just put {0}.  The
<-- HERE shows in the regular expression about where the problem
was discovered.  See L<perlre>.
d725 1
a725 1
could not be found.  Maybe you misspelled the name of the property?
d753 3
a755 5
If you're getting this error from a here-document, you may have
included unseen whitespace before or after your closing tag or there
may not be a linebreak after it.  A good programmer's editor will have
a way to help you find these characters (or lack of characters).  See
L<perlop> for the full details on here-documents.
d759 3
a761 3
(F) You may have tried to use C<\p> which means a Unicode
property (for example C<\p{Lu}> matches all uppercase
letters).  If you did mean to use a Unicode property, see
d763 4
a766 4
for a complete list of available properties.  If you didn't
mean to use a Unicode property, escape the C<\p>, either by
C<\\p> (just the C<\p>) or by C<\Q\p> (the rest of the string, or
until C<\E>).
d786 1
a786 1
the access-checking routine.  It will try to retrieve the filespec using
d790 2
a791 2
appears, the name lookup failed, and the access-checking routine gave up
and returned FALSE, just to be conservative.  (Note: The access-checking
d868 7
a874 7
(F) The module you tried to load failed to load a dynamic extension.
This may either mean that you upgraded your version of perl to one
that is incompatible with your old dynamic extensions (which is known
to happen between major versions of perl), or (more likely) that your
dynamic extension was built against an older version of the library
that is installed on your system.  You may need to rebuild your old
dynamic extensions.
d879 3
a881 3
lexical variable using "my" or "state".  This is not allowed.  If you
want to localize a package variable of the same name, qualify it with
the package name.
d892 5
a896 5
(F) You said to C<do> (or C<require>, or C<use>) a file that couldn't be found.
Perl looks for the file in all the locations mentioned in @@INC, unless
the file name included the full path to the file.  Perhaps you need
to set the PERL5LIB or PERL5OPT environment variable to say where the
extra library is, or maybe the script needs to add the library name
d910 1
a910 1
for example, F<foo.so> or F<bar.dll>, but the L<DynaLoader> module was
d929 1
a929 1
=item Can't make list assignment to %ENV on this system
d947 1
a947 1
such.  See L<perlsub/"Lvalue subroutines">.
a962 6
=item Can't open %s

(F) You tried to run a perl built with MAD support with
the PERL_XMLDUMP environment variable set, but the file
named by that variable could not be opened.

d967 3
a969 6
switches, or explicitly, failed for the indicated reason.  Usually
this is because you don't have read permission for a file which
you named on the command line.

(F) You tried to call perl with the B<-e> switch, but F</dev/null> (or
your operating system's equivalent) could not be opened.
d974 1
a974 1
using the 3-arg open() syntax:
d1012 1
a1012 1
=item Can't open perl script "%s": %s
a1052 7
=item Can't reset %ENV on this system

(F) You called C<reset('E')> or similar, which tried to reset
all variables in the current package beginning with "E".  In
the main package, that includes %ENV.  Resetting %ENV is not
supported on some systems, notably VMS.

d1055 3
a1057 3
(F)(P) Error resolving overloading specified by a method name (as
opposed to a subroutine reference): no such method callable via the
package.  If the method name is C<???>, this is an internal error.
d1072 5
a1076 5
(F) You tried to return a complete array or hash from an lvalue
subroutine, but you called the subroutine in a way that made Perl
think you meant to return only one value.  You probably meant to
write parentheses around the call to the subroutine, which tell
Perl that the call should be in list context.
d1086 1
a1086 1
negative number or zero.  There's a Math::Complex package that comes
d1102 5
a1113 5
=item Can't use '%c' after -mname

(F) You tried to call perl with the B<-m> switch, but you put something
other than "=" after the module name.

d1132 2
a1133 2
(F) The first time the C<%!> hash is used, perl automatically loads the
Errno.pm module.  The Errno module is expected to tie the %! hash to
d1196 7
a1207 7
=item Can't "when" outside a topicalizer

(F) You have used a when() block that is neither inside a C<foreach>
loop nor a C<given> block.  (Note that this error is issued on exit
from the C<when> block, so you won't get the error if the match fails,
or if you use an explicit C<continue>.)

a1213 9
=item Character following "\c" must be ASCII

(F)(W deprecated, syntax) In C<\cI<X>>, I<X> must be an ASCII character.
It is planned to make this fatal in all instances in Perl 5.18.  In the
cases where it isn't fatal, the character this evaluates to is
derived by exclusive or'ing the code point of this character with 0x40.

Note that non-alphabetic ASCII characters are discouraged here as well.

d1235 3
a1237 3
where $x is either less than 0 or more than 255.  However, C<U0>-mode
expects all values to fall in the interval [0, 255], so Perl behaved
as if you meant:
d1263 2
a1264 2
below 256), but a higher value was provided instead.  Perl uses the
value modulus 256 instead, as if you had provided:
d1275 1
a1275 1
value below 256), but some of the characters had a higher value.  Perl
d1287 1
a1287 1
value below 256), but some of the characters had a higher value.  Perl
a1291 19
=item "\c{" is deprecated and is more clearly written as ";"

(D deprecated, syntax) The C<\cI<X>> construct is intended to be a way
to specify non-printable characters.  You used it with a "{" which
evaluates to ";", which is printable.  It is planned to remove the
ability to specify a semi-colon this way in Perl 5.18.  Just use a
semi-colon or a backslash-semi-colon without the "\c".

=item "\c%c" is more clearly written simply as "%s"

(W syntax) The C<\cI<X>> construct is intended to be a way to specify
non-printable characters.  You used it for a printable one, which is better
written as simply itself, perhaps preceded by a backslash for non-word
characters.

=item Cloning substitution context is unimplemented

(F) Creating a new thread inside the C<s///> operator is not supported.

a1300 6
=item Closure prototype called

(F) If a closure has attributes, the subroutine passed to an attribute
handler is the prototype that is cloned when a new closure is created.
This subroutine cannot be called.

d1303 2
a1304 37
(F) You had a (sub-)template that ends with a '/'.  There must be
another template code following the slash.  See L<perlfunc/pack>.

=item Code point 0x%X is not Unicode, may not be portable

=item Code point 0x%X is not Unicode, all \p{} matches fail; all \P{} matches succeed

(W utf8, non_unicode) You had a code point above the Unicode maximum
of U+10FFFF.

Perl allows strings to contain a superset of Unicode code points, up
to the limit of what is storable in an unsigned integer on your system,
but these may not be accepted by other languages/systems.  At one time,
it was legal in some standards to have code points up to 0x7FFF_FFFF,
but not higher.  Code points above 0xFFFF_FFFF require larger than a
32 bit word.

None of the Unicode or Perl-defined properties will match a non-Unicode
code point.  For example,

    chr(0x7FF_FFFF) =~ /\p{Any}/

will not match, because the code point is not in Unicode.  But

    chr(0x7FF_FFFF) =~ /\P{Any}/

will match.

This may be counterintuitive at times, as both these fail:

 chr(0x110000) =~ \p{ASCII_Hex_Digit=True}      # Fails.
 chr(0x110000) =~ \p{ASCII_Hex_Digit=False}     # Also fails!

and both these succeed:

 chr(0x110000) =~ \P{ASCII_Hex_Digit=True}      # Succeeds.
 chr(0x110000) =~ \P{ASCII_Hex_Digit=False}     # Also succeeds!
d1308 2
a1309 5
(A) You've accidentally run your script through B<csh> or another shell
shell instead of Perl.  Check the #! line, or manually feed your script
into Perl yourself.  The #! line at the top of your file could look like

  #!/usr/bin/perl -w
d1331 8
a1338 8
(W threads) Within a thread-enabled program, you tried to
call cond_broadcast() on a variable which wasn't locked.
The cond_broadcast() function is used to wake up another thread
that is waiting in a cond_wait().  To ensure that the signal isn't
sent before the other thread has a chance to enter the wait, it
is usual for the signaling thread first to wait for a lock on
variable.  This lock attempt will only succeed after the other
thread has entered cond_wait() and thus relinquished the lock.
d1342 8
a1349 8
(W threads) Within a thread-enabled program, you tried to
call cond_signal() on a variable which wasn't locked.  The
cond_signal() function is used to wake up another thread that
is waiting in a cond_wait().  To ensure that the signal isn't
sent before the other thread has a chance to enter the wait, it
is usual for the signaling thread first to wait for a lock on
variable.  This lock attempt will only succeed after the other
thread has entered cond_wait() and thus relinquished the lock.
d1362 2
a1363 1
corresponding L<overload> pragma?.
d1368 4
a1371 1
the character name specified in the C<\N{...}> escape.
d1377 1
a1377 1
The message indicates the type of reference that was expected.  This
d1383 3
a1385 3
(W redefine)(S) You redefined a subroutine which had previously
been eligible for inlining.  See L<perlsub/"Constant Functions">
for commentary and workarounds.
d1395 1
a1395 1
(F) The method which overloads "=" is buggy.  See
a1397 10
=item &CORE::%s cannot be called directly

(F) You tried to call a subroutine in the C<CORE::> namespace
with C<&foo> syntax or through a reference.  Some subroutines
in this package cannot yet be called that way, but must be
called as barewords.  Something like this will work:

    BEGIN { *shove = \&CORE::push; }
    shove @@array, 1,2,3; # pushes on to @@array

d1412 1
a1412 1
=item Corrupt malloc ptr 0x%x at 0x%x
a1421 2
=item Deep recursion on anonymous subroutine

d1440 3
a1442 29
(D deprecated) C<defined()> is not usually right on hashes and has been
discouraged since 5.004.

Although C<defined %hash> is false on a plain not-yet-used hash, it
becomes true in several non-obvious circumstances, including iterators,
weak references, stash names, even remaining true after C<undef %hash>.
These things make C<defined %hash> fairly useless in practice.

If a check for non-empty is what you wanted then just put it in boolean
context (see L<perldata/Scalar values>):

    if (%hash) {
       # not empty
    }

If you had C<defined %Foo::Bar::QUUX> to check whether such a package
variable exists then that's never really been reliable, and isn't
a good way to enquire about the features of a package, or whether
it's loaded, etc.


=item (?(DEFINE)....) does not allow branches in regex; marked by <-- HERE in m/%s/

(F) You used something like C<(?(DEFINE)...|..)> which is illegal.  The
most likely cause of this error is that you left out a parenthesis inside
of the C<....> part.

The <-- HERE shows in the regular expression about where the problem was
discovered.
d1455 1
a1455 1
=item Deprecated character in \N{...}; marked by <-- HERE  in \N{%s<-- HERE %s
d1458 4
a1461 4
But starting in 5.12, non-reasonable ones that don't look like names
are deprecated.  A reasonable name begins with an alphabetic character
and continues with any combination of alphanumerics, dashes, spaces,
parentheses or colons.
d1465 2
a1466 2
(D deprecated) You used a declaration similar to C<my $x if 0>.  There
has been a long-standing bug in Perl that causes a lexical variable
d1468 3
a1470 3
conditional.  Some people have exploited this bug to achieve a kind of
static variable.  Since we intend to fix this bug, we don't want people
relying on this behavior.  You can achieve a similar static effect by
d1479 2
a1480 2
Beginning with perl 5.9.4, you can also use C<state> variables to have
lexicals that are initialized only once (see L<feature>):
d1487 2
a1488 2
just being DESTROYed.  Perl is confused, and prefers to abort rather
than to create a dangling reference.
d1503 2
a1504 2
(W misc) You probably referred to an imported subroutine &FOO as $FOO or
some such.
d1521 1
a1521 1
you called it with no args and C<$@@> was empty.
d1577 3
a1579 3
(S syntax) There is no keyword "elseif" in Perl because Larry thinks
it's ugly.  Your code will be interpreted as an attempt to call a method
named "elseif" for the class returned by the following block.  This is
d1585 1
a1585 1
described in L<perlunicode> and L<perlre>.  You used C<\p> or C<\P> in
d1597 1
a1597 1
program's environment.  This is potentially insecure.
d1617 4
a1620 5
pattern contains interpolated values.  Since that is a security risk,
it is not allowed.  If you insist, you may still do this by using the
C<re 'eval'> pragma or by explicitly building the pattern from an
interpolated string at run time and using that in an eval().  See
L<perlre/(?{ code })>.
d1631 1
a1631 1
any text.  Restructure the pattern so that text is consumed.
d1645 1
a1645 2
(F) The C<exec> function is not implemented on some systems, e.g., Symbian
OS.  See L<perlport>.
d1703 1
a1703 1
=item Fatal VMS error (status=%d) at %s, line %d
d1723 3
a1725 3
which can't encode values above 63.  So there is no point in asking for
a line length bigger than that.  Perl will behave as if you specified
C<u63> as the format.
d1738 4
a1741 4
with "+<" or "+>" or "+>>" instead of with ">".  If you intended only to
read from the file, use "<".  See L<perlfunc/open>.  Another possibility
is that you attempted to open filedescriptor 0 (also known as STDIN) for
output (maybe you closed STDIN earlier?).
d1746 1
a1746 1
as STDOUT or STDERR.  This occurred because you closed STDOUT or STDERR
d1752 1
a1752 1
as STDIN.  This occurred because you closed STDIN previously.
d1836 3
a1838 3
(S glob) Something went wrong with the external program(s) used
for C<glob> and C<< <*.c> >>.  Usually, this means that you supplied a C<glob>
pattern that caused the external program to fail and exit with a
d1840 5
a1844 5
resulted in a coredump, this may also mean that your csh (C shell)
is broken.  If so, you should change all of the csh-related variables
in config.sh:  If you have tcsh, make the variables refer to it as
if it were csh (e.g. C<full_csh='/usr/bin/tcsh'>); otherwise, make them
all empty (except that C<d_csh> should be C<'undef'>) so that Perl will
d1855 1
a1855 1
=item gmtime(%f) too large
d1857 1
a1857 1
(W overflow) You called C<gmtime> with a number that was larger than
d1859 1
a1859 1
date.  This warning is also triggered with NaN (the special
d1862 1
a1862 1
=item gmtime(%f) too small
d1864 4
a1867 2
(W overflow) You called C<gmtime> with a number that was smaller than
it can reliably handle and C<gmtime> probably returned the wrong date.
a1878 6
=item Goto undefined subroutine%s

(F) You tried to call a subroutine with C<goto &sub> syntax, but
the indicated subroutine hasn't been defined, or if it was, it
has since been undefined.

d1881 3
a1883 2
(F) A ()-group started with a count.  A count is supposed to follow
something: a template character or a ()-group.  See L<perlfunc/pack>.
a1904 21
=item Having no space between pattern and following word is deprecated

(D syntax)

You had a word that isn't a regex modifier immediately following
a pattern without an intervening space.  If you are trying to use
the C</le> flags on a substitution, use C</el> instead.  Otherwise, add
white space between the pattern and following word to eliminate
the warning.  As an example of the latter, the two constructs:


 $a =~ m/$foo/sand $bar
 $a =~ m/$foo/s and $bar

both currently mean the same thing, but it is planned to disallow
the first form in Perl 5.18.  And,

 $a =~ m/$foo/and $bar

will be disallowed too.

d1920 3
a1922 3
(W) Named Unicode character escapes C<(\N{...})> may return a zero-length
sequence.  When such an escape is used in a character class its
behaviour is not well defined.  Check that the correct escape has
d1935 1
a1935 6
=item Illegal character after '_' in prototype for %s : %s

(W illegalproto) An illegal character was found in a prototype declaration.
Legal characters in prototypes are $, @@, %, *, ;, [, ], &, \, and +.

=item Illegal character \%o (carriage return)
d1946 1
a1946 1
Legal characters in prototypes are $, @@, %, *, ;, [, ], &, \, and +.
d1951 1
a1951 1
you must always specify a block of code.  See L<perlsub>.
d1955 1
a1955 1
(F) A subroutine was not declared correctly.  See L<perlsub>.
d2032 1
a2032 1
text.  You should check the pattern to ensure that recursive patterns
d2040 4
a2043 5
(F) Currently the implementation of "state" only permits the
initialization of scalar variables in scalar context.  Re-write
C<state ($a) = 42> as C<state $a = 42> to change from list to scalar
context.  Constructions such as C<state (@@a) = foo()> will be
supported in a future perl release.
a2069 13
=item Insecure user-defined property %s

(F) Perl detected tainted data when trying to compile a regular
expression that contains a call to a user-defined character property
function, i.e. C<\p{IsFoo}> or C<\p{InFoo}>.
See L<perlunicode/User-Defined Character Properties> and L<perlsec>.

=item Integer overflow in format string for %s

(F) The indexes and widths specified in the format string of C<printf()>
or C<sprintf()> are too large.  The numbers must not overflow the size of
integers for your architecture.

d2082 6
d2114 1
a2114 1
(P) Something went badly awry in the regular expression parser.  The
d2127 1
a2127 1
(F) The indicated attribute for a subroutine or variable was not recognized
d2132 1
a2132 1
(F) The indicated attributes for a subroutine or variable were not
a2148 13
=item Invalid hexadecimal number in \N{U+...}

(F) The character constant represented by C<...> is not a valid hexadecimal
number.  Either it is empty, or you tried to use a character other than
0 - 9 or A - F, a - f in a hexadecimal number.

=item Invalid module name %s with -%c option: contains single ':'

(F) The module argument to perl's B<-m> and B<-M> command-line options
cannot contain single colons in the module name, but only in the
arguments after "=".  In other words, B<-MFoo::Bar=:baz> is ok, but
B<-MFoo:Bar=baz> is not.

d2151 3
a2153 10
(F) You tried to C<mro::set_mro("classname", "foo")> or C<use mro 'foo'>,
where C<foo> is not a valid method resolution order (MRO).  Currently,
the only valid ones supported are C<dfs> and C<c3>, unless you have loaded
a module that is a MRO plugin.  See L<mro> and L<perlmroapi>.

=item invalid option -D%c, use -D'' to see choices

(F) Perl was called with invalid debugger flags.  Call perl with
the B<-D> option with no flags to see the list of acceptable values.
See also L<< perlrun/B<-D>I<letters> >>.
d2177 2
a2178 2
(W layer) When pushing layers onto the Perl I/O system, something other
than a colon or whitespace was seen between the elements of a layer list.
a2181 9
=item Invalid strict version format (%s)

(F) A version number did not meet the "strict" criteria for versions.
A "strict" version number is a positive decimal number (integer or
decimal-fraction) without exponentiation or else a dotted-decimal
v-string with a leading 'v' character and at least three components.
The parenthesized text indicates which criteria were not met.
See the L<version> module for more details on allowed version formats.

a2185 1

d2189 5
a2193 1
=item Invalid version format (%s)
d2195 4
a2198 16
(F) A version number did not meet the "lax" criteria for versions.
A "lax" version number is a positive decimal number (integer or
decimal-fraction) without exponentiation or else a dotted-decimal
v-string.  If the v-string has fewer than three components, it
must have a leading 'v' character.  Otherwise, the leading 'v' is
optional.  Both decimal and dotted-decimal versions may have a
trailing "alpha" component separated by an underscore character
after a fractional or dotted-decimal component.  The parenthesized
text indicates which criteria were not met.  See the L<version> module
for more details on allowed version formats.

=item Invalid version object

(F) The internal structure of the version object was invalid.
Perhaps the internals were modified directly in some way or
an arbitrary reference was blessed into the "version" class.
d2208 1
a2208 1
Check your control flow and number of arguments.
d2213 1
a2213 1
you cannot use IO layers.  To have PerlIO, Perl must be configured
d2219 1
a2219 1
neither as a system call nor an ioctl call (SIOCATMARK).
d2223 3
a2225 4
(D deprecated, syntax) The special variable C<$*>, deprecated in older
perls, has been removed as of 5.9.0 and is no longer supported.  In
previous versions of perl the use of C<$*> enabled or disabled multi-line
matching within a string.
d2228 2
a2229 3
modifiers.  You can enable C</m> for a lexical scope (even a whole file)
with C<use re '/m'>.  (In older versions: when C<$*> was set to a true value
then all regular expressions behaved as if they were written using C</m>.)
d2233 3
a2235 3
(D deprecated, syntax) The special variable C<$#>, deprecated in older
perls, has been removed as of 5.9.3 and is no longer supported.  You
should use the printf/sprintf functions instead.
d2237 1
a2237 1
=item '%s' is not a code reference
d2239 3
a2241 3
(W overload) The second (fourth, sixth, ...) argument of
overload::constant needs to be a code reference.  Either
an anonymous subroutine, or a reference to a subroutine.
d2243 1
a2243 1
=item '%s' is not an overloadable type
d2278 2
a2279 15
length/code combination tried to obtain more data.  This results in
an undefined value for the length.  See L<perlfunc/pack>.

=item length() used on %s

(W syntax) You used length() on either an array or a hash when you
probably wanted a count of the items.

Array size can be obtained by doing:

    scalar(@@array);

The number of items in a hash can be obtained by doing:

    scalar(keys %hash);
d2284 5
a2288 4
(using L<lex_stuff_pvn|perlapi/lex_stuff_pvn> or similar), but tried to insert a character that
couldn't be part of the current input.  This is an inherent pitfall
of the stuffing mechanism, and one of the reasons to avoid it.  Where
it is necessary to stuff, stuffing only plain ASCII is recommended.
d2301 1
a2301 7
=item List form of piped open not implemented

(F) On some platforms, notably Windows, the three-or-more-arguments
form of C<open> does not support pipes, such as C<open($pipe, '|-', @@args)>.
Use the two-argument C<open($pipe, '|prog arg1 arg2...')> form instead.

=item localtime(%f) too large
d2303 1
a2303 1
(W overflow) You called C<localtime> with a number that was larger
d2305 1
a2305 1
wrong date.  This warning is also triggered with NaN (the special
d2308 1
a2308 1
=item localtime(%f) too small
d2310 1
a2310 1
(W overflow) You called C<localtime> with a number that was smaller
d2312 2
a2313 1
wrong date.
d2318 1
a2318 1
handle.  This restriction may be eased in a future release. 
d2324 1
a2324 1
hence the target of C<++> or C<--> is unchanged.  Perl issues this warning
d2329 1
a2329 1
=item lstat() on filehandle%s
d2335 1
a2335 8
=item lvalue attribute %s already-defined subroutine

(W misc) Although L<attributes.pm|attributes> allows this, turning the lvalue
attribute on or off on a Perl subroutine that is already defined
does not always work properly.  It may or may not do what you
want, depending on what code is inside the subroutine, with exact
details subject to change between Perl versions.  Only do this
if you really know what you are doing.
d2337 5
a2341 1
=item lvalue attribute ignored after the subroutine has been defined
d2343 1
a2343 5
(W misc) Using the C<:lvalue> declarative syntax to make a Perl
subroutine an lvalue subroutine after it has been defined is
not permitted.  To make the subroutine an lvalue subroutine,
add the lvalue attribute to the definition, or put the C<sub
foo :lvalue;> declaration before the definition.
d2345 3
a2347 1
See also L<attributes.pm|attributes>.
d2349 1
a2349 1
=item Malformed integer in [] in pack
d2351 1
a2351 1
(F) Between the brackets enclosing a numeric repeat count only digits
d2356 1
a2356 1
(F) Between the brackets enclosing a numeric repeat count only digits
d2382 1
a2382 1
(S utf8)(F) Perl detected a string that didn't comply with UTF-8
d2387 1
a2387 1
8-bit data).  To guard against this, you can use Encode::decode_utf8.
d2396 5
d2405 1
a2405 1
=item Malformed UTF-8 string in '%c' format in unpack
d2407 1
a2407 1
(F) You tried to unpack something that didn't comply with UTF-8 encoding
d2410 1
a2410 1
=item Malformed UTF-8 string in pack
d2412 1
a2412 1
(F) You tried to pack something that didn't comply with UTF-8 encoding
d2415 1
a2415 1
=item Malformed UTF-8 string in unpack
d2420 1
a2420 1
=item Malformed UTF-16 surrogate
d2422 5
a2426 2
(F) Perl thought it was reading UTF-16 encoded character data but while
doing it Perl met a malformed Unicode surrogate.
a2434 8
=item Maximal count of pending signals (%u) exceeded

(F) Perl aborted due to too high a number of signals pending.  This
usually indicates that your operating system tried to deliver signals
too fast (with a very high priority), starving the perl process from
resources it would need to reach a point where it can process signals
safely.  (See L<perlipc/"Deferred Signals (Safe Signals)">.)

d2441 1
a2441 1
=item '%' may not be used in pack
d2480 4
a2483 8
double-quotish context.  This can also happen when there is a space
(or comment) between the C<\N> and the C<{> in a regex with the C</x> modifier.
This modifier does not change the requirement that the brace immediately
follow the C<\N>.

=item Missing braces on \o{}

(F) A C<\o> must be followed immediately by a C<{> in double-quotish context.
d2521 1
a2521 1
=item Missing right brace on \N{} or unescaped left brace after \N
d2523 2
a2524 1
(F) C<\N> has two meanings.
d2526 21
a2546 21
The traditional one has it followed by a name enclosed in braces,
meaning the character (or sequence of characters) given by that
name.  Thus C<\N{ASTERISK}> is another way of writing C<*>, valid in both
double-quoted strings and regular expression patterns.  In patterns,
it doesn't have the meaning an unescaped C<*> does.

Starting in Perl 5.12.0, C<\N> also can have an additional meaning (only)
in patterns, namely to match a non-newline character.  (This is short
for C<[^\n]>, and like C<.> but is not affected by the C</s> regex modifier.)

This can lead to some ambiguities.  When C<\N> is not followed immediately
by a left brace, Perl assumes the C<[^\n]> meaning.  Also, if the braces
form a valid quantifier such as C<\N{3}> or C<\N{5,}>, Perl assumes that this
means to match the given quantity of non-newlines (in these examples,
3; and 5 or more, respectively).  In all other case, where there is a
C<\N{> and a matching C<}>, Perl assumes that a character name is desired.

However, if there is no matching C<}>, Perl doesn't know if it was
mistakenly omitted, or if C<[^\n]{> was desired, and raises this error.
If you meant the former, add the right brace; if you meant the latter,
escape the brace with a backslash, like so: C<\N\{>
d2574 4
a2577 4
    $x = 1;
    foreach my $n ($x, 2) {
        $n *= 2; # modifies the $x, but fails on attempt to
    }            # modify the 2
d2602 1
a2602 1
(F) The C<open> function has been asked to open multiple files.  This
d2627 1
a2627 1
=item "my" variable %s can't be in a package
d2633 1
a2633 1
=item Name "%s::%s" used only once: possible typo
d2635 3
a2637 4
(W once) Typographical errors often show up as unique variable names.
If you had a good reason for having a unique name, then just mention it
again somehow to suppress the message.  The C<our> declaration is
provided for this purpose.
d2639 1
a2639 6
NOTE: This warning detects symbols that have been used only once so $c, @@c,
%c, *c, &c, sub c{}, c(), and c (the filehandle or format) are considered
the same; if a program uses $c only once but also uses any of the others it
will not trigger this warning.

=item \N in a character class must be a named character: \N{...}
d2641 3
a2643 11
(F) The new (5.12) meaning of C<\N> as C<[^\n]> is not valid in a bracketed
character class, for the same reason that C<.> in a character class loses
its specialness: it matches almost everything, which is probably not
what you want.

=item \N{NAME} must be resolved by the lexer

(F) When compiling a regex pattern, an unresolved named character or
sequence was encountered.  This can happen in any of several ways that
bypass the lexer, such as using single-quotish context, or an extra
backslash in double-quotish:
d2669 18
d2704 3
a2706 3
(F) You can't quantify a quantifier without intervening parentheses.
So things like ** or +* or ?* are illegal.  The <-- HERE shows in the
regular expression about where the problem was discovered.
a2728 10
=item No code specified for -%c

(F) Perl's B<-e> and B<-E> command-line options require an argument.  If
you want to run an empty program, pass the empty string as a separate
argument or run a program consisting of a single 0 or 1:

    perl -e ""
    perl -e0
    perl -e1

d2731 2
a2732 2
(F) A list operator that has a filehandle or "indirect object" is
not allowed to have a comma between that and the following arguments.
d2735 11
a2745 11
One possible cause for this is that you expected to have imported
a constant to your name space with B<use> or B<import> while no such
importing took place, it may for example be that your operating
system does not support that particular constant.  Hopefully you did
use an explicit import list for the constants you expect to see;
please see L<perlfunc/use> and L<perlfunc/import>.  While an
explicit import list would probably have caught this error earlier
it naturally does not remedy the fact that your operating system
still does not support that constant.  Maybe you have a typo in
the constants of the symbol import list of B<use> or B<import> or in the
constant name at the line where this error was triggered?
d2756 1
a2756 1
for some reason the current debugger (e.g. F<perl5db.pl> or a C<Devel::>
d2772 1
a2772 1
=item No directory specified for -I
d2774 1
a2774 2
(F) The B<-I> command-line switch requires a directory name as part of the
I<same> argument.  Use B<-Ilib>, for instance.  B<-I lib> won't work.
d2785 1
a2785 1
matching counterpart.  See L<perlfunc/pack>.
d2793 5
d2803 1
a2803 1
or C<next::can>.  See L<mro>.
d2843 5
d2850 3
a2852 4
(F) You tried to access a key from a hash through the indicated typed
variable but that key is not allowed by the package of the same type.
The indicated package has restricted the set of allowed keys using the
L<fields> pragma.
d2856 2
a2857 2
(F) You provided a class qualifier in a "my", "our" or "state"
declaration, but this class doesn't exist at this point in your program.
d2861 2
a2862 2
(F) You specified a signal hook that was not recognized by Perl.
Currently, Perl accepts C<__DIE__> and C<__WARN__> as valid signal hooks.
d2907 1
a2907 1
=item Not an unblessed ARRAY reference
d2909 3
a2911 3
(F) You passed a reference to a blessed array to C<push>, C<shift> or
another array function.  These only accept unblessed array references
or arrays beginning explicitly with C<@@>.
a2953 6
=item Non-octal character '%c'.  Resolved as "%s"

(W digit) In parsing an octal numeric constant, a character was
unexpectedly encountered that isn't octal.  The resulting value
is as indicated.

d2958 1
a2958 1
select.  See L<perlfunc/select>.
d2967 1
a2967 1
(S debugging) Some internal routine called run() with a null opcode
d2996 1
a2996 1
=item Number with no digits
d2998 3
a3000 3
(F) Perl was looking for a number but found nothing that looked like
a number.  This happens, for example with C<\o{}>, with no number between
the braces.
d3008 2
d3013 1
a3013 1
arguments.  The arguments should come in pairs.
d3027 1
a3027 1
(F)(W layer) You tried to do a read/write/send/recv/seek operation
d3056 1
a3056 1
(W io, deprecated) You used open() to associate a filehandle to
d3063 1
a3063 1
(W io, deprecated) You used opendir() to associate a dirhandle to
d3073 1
a3073 28
the C<fallback> overloading key is specified to be true.  See L<overload>.

=item Operation "%s" returns its argument for non-Unicode code point 0x%X

(W utf8, non_unicode) You performed an operation requiring Unicode
semantics on a code point that is not in Unicode, so what it should do
is not defined.  Perl has chosen to have it do nothing, and warn you.

If the operation shown is "ToFold", it means that case-insensitive
matching in a regular expression was done on the code point.

If you know what you are doing you can turn off this warning by
C<no warnings 'non_unicode';>.

=item Operation "%s" returns its argument for UTF-16 surrogate U+%X

(W utf8, surrogate) You performed an operation requiring Unicode
semantics on a Unicode surrogate.  Unicode frowns upon the use of
surrogates for anything but storing strings in UTF-16, but semantics
are (reluctantly) defined for the surrogates, and they are to do
nothing for this operation.  Because the use of surrogates can be
dangerous, Perl warns.

If the operation shown is "ToFold", it means that case-insensitive
matching in a regular expression was done on the code point.

If you know what you are doing you can turn off this warning by
C<no warnings 'surrogate';>.
d3108 1
a3108 1
remaining memory (or virtual memory) to satisfy the request.  However,
d3114 1
a3114 1
(X)(F) The malloc() function returned 0, indicating there was
d3150 2
a3151 7
the string being unpacked.  The string being unpacked was also invalid
UTF-8.  See L<perlfunc/pack>.

=item overload arg '%s' is invalid

(W overload) The L<overload> pragma was passed an argument it did not
recognize.  Did you mistype an operator?
d3156 1
a3156 1
but the overloaded operation did not return a reference.  See
d3162 1
a3162 1
overloaded operation didn't return a compiled regexp.  See L<overload>.
d3192 1
a3192 1
=item panic: ck_grep, type=%u
d3196 1
a3196 1
=item panic: ck_split, type=%u
d3200 1
a3200 1
=item panic: corrupt saved stack index %ld
d3210 7
d3241 1
a3241 1
=item panic: goto, type=%u, ix=%ld
d3246 1
a3246 1
=item panic: gp_free failed to free glob pointer
d3248 4
a3251 4
(P) The internal routine used to clear a typeglob's entries tried
repeatedly, but each time something re-created entries in the glob.
Most likely the glob contains an object with a reference back to
the glob and a destructor that adds a new object to the glob.
d3253 1
a3253 1
=item panic: INTERPCASEMOD, %s
d3257 1
a3257 1
=item panic: INTERPCONCAT, %s
d3265 1
a3265 1
=item panic: last, type=%u
d3275 1
a3275 1
=item panic: leave_scope inconsistency %u
d3285 1
a3285 1
=item panic: malloc, %s
d3293 1
a3293 1
=item panic: pad_alloc, %p!=%p
d3298 1
a3298 1
=item panic: pad_free curpad, %p!=%p
d3307 1
a3307 1
=item panic: pad_reset curpad, %p!=%p
d3316 1
a3316 1
=item panic: pad_swipe curpad, %p!=%p
d3325 1
a3325 1
=item panic: pp_iter, type=%u
d3334 1
a3334 1
=item panic: pp_split, pm=%p, s=%p
d3338 1
a3338 1
=item panic: realloc, %s
d3342 1
a3342 6
=item panic: reference miscount on nsv in sv_replace() (%d != 1)

(P) The internal sv_replace() function was handed a new SV with a
reference count other than 1.

=item panic: restartop in %s
d3347 1
a3347 1
=item panic: return, type=%u
d3352 1
a3352 1
=item panic: scan_num, %s
d3361 1
a3361 1
=item panic: sv_insert, midend=%p, bigend=%p
a3365 6
=item panic: strxfrm() gets absurd - a => %u, ab => %u

(P) The interpreter's sanity check of the C function strxfrm() failed.
In your current locale the returned transformation of the string "ab" is
shorter than that of the string "a", which makes no sense.

d3372 2
a3373 2
(P) The compiler is screwed up and attempted to use an op that isn't
permitted at run time.
d3385 1
a3385 1
=item panic: yylex, %s
a3388 5
=item Parsing code internal error (%s)

(F) Parsing code supplied by an extension violated the parser's API in
a detectable way.

d3392 2
a3393 2
consuming any text.  Restructure the pattern so text is consumed before
the nesting limit is exceeded.
a3421 9
=item Perl folding rules are not up-to-date for 0x%x; please use the perlbug utility to report

(W regex, deprecated) You used a regular expression with
case-insensitive matching, and there is a bug in Perl in which the
built-in regular expression folding rules are not accurate.  This may
lead to incorrect results.  Please report this as a bug using the
"perlbug" utility.  (This message is marked deprecated, so that it by
default will be turned-on.)

d3429 1
a3429 1
=item Perl %s required (did you mean %s?)--this is only %s, stopped
d3431 4
a3434 6
(F) The code you are trying to run has asked for a newer version of
Perl than you are running.  Perhaps C<use 5.10> was written instead
of C<use 5.010> or C<use v5.10>.  Without the leading C<v>, the number is
interpreted as a decimal, with every three digits after the
decimal point representing a part of the version number.  So 5.10
is equivalent to v5.100.
d3444 1
a3444 1
(F) An error peculiar to OS/2.  PERL_SH_DIR is the directory to find the
a3450 7
=item Perls since %s too modern--this is %s, stopped

(F) The code you are trying to run claims it will not run
on the version of Perl you are using because it is too new.
Maybe the code needs to be updated, or maybe it is simply
wrong and the version check should just be removed.

d3468 3
a3470 3
Perl can and will use, and the script will be run.  Before you really
fix the problem, however, you will get the same error message each
time you run Perl.  How to really fix the problem can be found in
d3583 1
a3583 1
higher precedence of C<==>.  This is probably not what you want.  (If you
d3587 7
a3607 7
=item Possible unintended interpolation of %s in string

(W ambiguous) You said something like '@@foo' in a double-quoted string
but there was no array C<@@foo> in scope at the time.  If you wanted a
literal @@foo, then write it as \@@foo; otherwise find out what happened
to the array you apparently lost track of.

d3647 2
a3648 2
(W illegalproto) A character follows % or @@ in a prototype.  This is
useless, since % and @@ gobble the rest of the subroutine arguments.
a3659 24
=item \p{} uses Unicode rules, not locale rules

(W) You compiled a regular expression that contained a Unicode property
match (C<\p> or C<\P>), but the regular expression is also being told to
use the run-time locale, not Unicode.  Instead, use a POSIX character
class, which should know about the locale's rules.
(See L<perlrecharclass/POSIX Character Classes>.)

Even if the run-time locale is ISO 8859-1 (Latin1), which is a subset of
Unicode, some properties will give results that are not valid for that
subset.

Here are a couple of examples to help you see what's going on.  If the
locale is ISO 8859-7, the character at code point 0xD7 is the "GREEK
CAPITAL LETTER CHI".  But in Unicode that code point means the
"MULTIPLICATION SIGN" instead, and C<\p> always uses the Unicode
meaning.  That means that C<\p{Alpha}> won't match, but C<[[:alpha:]]>
should.  Only in the Latin1 locale are all the characters in the same
positions as they are in Unicode.  But, even here, some properties give
incorrect results.  An example is C<\p{Changes_When_Uppercased}> which
is true for "LATIN SMALL LETTER Y WITH DIAERESIS", but since the upper
case of that character is not in Latin1, in that locale it doesn't
change when upper cased.

d3662 3
a3664 3
(F) You started a regular expression with a quantifier.  Backslash it if
you meant it literally.  The <-- HERE shows in the regular expression
about where the problem was discovered.  See L<perlre>.
d3668 3
a3670 3
(F) There is currently a limit to the size of the min and max values of
the {min,max} construct.  The <-- HERE shows in the regular expression
about where the problem was discovered.  See L<perlre>.
d3708 1
a3708 1
=item Reallocation too large: %x
a3722 7
=item Recursive call to Perl_load_module in PerlIO_find_layer

(P) It is currently not permitted to load modules when creating
a filehandle inside an %INC hook.  This can happen with C<open my
$fh, '<', \$scalar>, which implicitly loads PerlIO::scalar.  Try
loading PerlIO::scalar explicitly first.

d3729 1
a3729 1
=item refcnt_dec: fd %d%s
d3731 3
a3733 6
=item refcnt: fd %d%s

=item refcnt_inc: fd %d%s

(P) Perl's I/O implementation failed an internal consistency check.  If
you see this message, something is very wrong.
d3738 3
a3740 3
with an even number of elements (for assignment to a hash).  This
usually means that you used the anon hash constructor when you meant
to use parens.  In any case, a hash requires key/value B<pairs>.
d3752 5
d3759 4
a3762 4
(F) You used C<\g0> or similar in a regular expression.  You may refer
to capturing parentheses only with strictly positive integers
(normal backreferences) or with strictly negative integers (relative
backreferences).  Using 0 does not make sense.
d3767 12
a3778 3
not at least seven sets of capturing parentheses in the expression.  If
you wanted to have the character with ordinal 7 inserted into the regular
expression, prepend zeroes to make it three digits long: C<\007>
d3786 3
a3788 3
expression, but there is no corresponding named capturing parentheses
such as C<(?'NAME'...)> or C<< (?<NAME>...) >>.  Check if the name has been
spelled correctly both in the backreference and the declaration.
d3793 1
a3793 1
=item Reference to nonexistent or unclosed group in regex; marked by <-- HERE in m/%s/
d3795 3
a3797 3
(F) You used something like C<\g{-7}> in your regular expression, but there
are not at least seven sets of closed capturing parentheses in the
expression before where the C<\g{-7}> was located.
a3806 20
=item Regexp modifier "/%c" may appear a maximum of twice

=item Regexp modifier "/%c" may not appear twice

(F syntax, regexp) The regular expression pattern had too many occurrences
of the specified modifier.  Remove the extraneous ones.

=item Regexp modifier "%c" may not appear after the "-"

(F regexp) Turning off the given modifier has the side effect of turning
on another one.  Perl currently doesn't allow this.  Reword the regular
expression to use the modifier you want to turn on (and place it before
the minus), instead of the one you want to turn off.

=item Regexp modifiers "/%c" and "/%c" are mutually exclusive

(F syntax, regexp) The regular expression pattern had more than one of these
mutually exclusive modifiers.  Retain only the modifier that is
supposed to be there.

d3816 1
a3816 1
terminates.  You might use ^# instead.  See L<perlform>.
d3821 1
a3821 1
search list.  So the additional elements in the replacement list
d3827 1
a3827 1
always come last, to avoid ambiguity with subsequent unary operators.
d3889 1
a3889 1
parsed.  One way to disambiguate the parsing is to put parentheses around
d3892 5
a3901 5
=item %sseek() on unopened filehandle

(W unopened) You tried to use the seek() or sysseek() function on a
filehandle that was either never opened or has since been closed.

d3932 3
a3934 3
(F) A regular expression ended with an incomplete extension (?.  The
<-- HERE shows in the regular expression about where the problem was
discovered.  See L<perlre>.
d3938 3
a3940 3
(F) A proposed regular expression extension has the character reserved
but has not yet been written.  The <-- HERE shows in the regular
expression about where the problem was discovered.  See L<perlre>.
d3946 1
a3946 4
discovered.  This happens when using the C<(?^...)> construct to tell
Perl to use the default regular expression modifiers, and you
redundantly specify a default modifier.  For other
causes, see L<perlre>.
d3948 1
a3948 1
=item Sequence \%s... not terminated in regex; marked by <-- HERE in m/%s/
d3957 1
a3957 1
the regular expression about where the problem was discovered.  See
d3962 4
a3965 4
(F) If the contents of a (?{...}) clause contain braces, they
must balance for Perl to detect the end of the clause properly.
The <-- HERE shows in the regular expression about where the
problem was discovered.  See L<perlre>.
d3967 1
a3967 1
=item Z<>500 Server error
d3973 6
a3978 6
(A) This is the error message generally seen in a browser window
when trying to run a CGI program (including SSI) over the web.  The
actual error text varies widely from server to server.  The most
frequently-seen variants are "500 Server error", "Method (something)
not permitted", "Document contains no data", "Premature end of script
headers", and "Did not produce a valid header".
d3982 6
a3987 6
You need to make sure your script is executable, is accessible by
the user CGI is running the script under (which is probably not the
user account you tested it under), does not rely on any environment
variables (like PATH) from the user it isn't running under, and isn't
in a location where the CGI server can't find it, basically, more or
less.  Please see the following for more information:
d4031 10
a4088 7
=item Source filters apply only to byte streams

(F) You tried to activate a source filter (usually by loading a
source filter module) within a string passed to C<eval>.  This is
not permitted under the C<unicode_eval> feature.  Consider using
C<evalbytes> instead.  See L<feature>.

d4092 4
a4095 4
the array passed to splice().  Splicing will instead commence at the
end of the array, rather than past it.  If this isn't what you want,
try explicitly pre-extending the array by assigning $#array = $offset.
See L<perlfunc/splice>.
d4101 1
a4101 1
happened.)  See L<perlfunc/split>.
a4110 6
=item "state" variable %s can't be in a package

(F) Lexically scoped variables aren't in a package, so it doesn't make
sense to try to declare one with a package qualifier on the front.  Use
local() if you want to localize a package variable.

d4152 1
a4152 1
(W substr)(F) You tried to reference a substr() that pointed outside of
d4160 1
a4160 1
(P) Perl tried to force the upgrade of an SV to a type which was actually
d4165 4
a4168 4
(F) A (?(condition)if-clause|else-clause) construct can have at most
two branches (the if-clause and the else-clause).  If you want one or
both to contain alternation, such as using C<this|that|other>, enclose
it in clustering parentheses:
d4172 2
a4173 2
The <-- HERE shows in the regular expression about where the problem
was discovered.  See L<perlre>.
d4177 3
a4179 3
(F) If the argument to the (?(...)if-clause|else-clause) construct is
a number, it can be only a number.  The <-- HERE shows in the regular
expression about where the problem was discovered.  See L<perlre>.
d4186 1
a4186 1
=item %s syntax OK
d4209 2
a4210 1
if the error went away.  Sort of the cybernetic version of S<20 questions>.
d4212 1
a4212 1
=item syntax error at line %d: '%s' unexpected
d4254 5
a4263 5
=item tell() on unopened filehandle

(W unopened) You tried to use the tell() function on a filehandle that
was either never opened or has since been closed.

d4277 1
a4277 1
from under another module inadvertently.  See L<perlvar/$[> and L<arybase>.
d4289 1
a4289 1
(F) The function indicated isn't implemented on this architecture, according
d4326 5
a4330 5
(X) The #! line (or local equivalent) in a Perl script contains
the B<-T> option (or the B<-t> option), but Perl was not invoked with
B<-T> in its command line.  This is an error because, by the time
Perl discovers a B<-T> in a script, it's too late to properly taint
everything from the environment.  So Perl gives up.
d4333 3
a4335 3
mechanism (or its local equivalent), this error can usually be
fixed by editing the #! line so that the B<-%c> option is a part of
Perl's first argument: e.g. change C<perl -n -%c> to C<perl -%c -n>.
d4361 2
a4362 2
In the case of B<-M> and B<-m>, this is an error because those options
are not intended for use inside scripts.  Use the C<use> pragma instead.
d4364 4
a4367 5
The B<-C> option only works if it is specified on the command line as
well (with the same sequence of letters or numbers following).  Either
specify this option on the command line, or, if your system supports
it, make your script executable and run it directly instead of passing
it to perl.
d4414 1
a4414 1
disallowed.  See L<Safe>.
a4420 7
=item Type of arg %d to &CORE::%s must be %s

(F) The subroutine in question in the CORE package requires its argument
to be a hard reference to data of the specified type.  Overloading is
ignored, so a reference to an object that is not the specified type, but
nonetheless has overloading to handle it, will still not be accepted.

a4427 5
=item Type of argument to %s must be unblessed hashref or arrayref

(F) You called C<keys>, C<values> or C<each> with a scalar argument that
was not a reference to an unblessed hash or array.

a4451 6
=item Unbalanced string table refcount: (%d) for "%s"

(W internal) On exit, Perl found some strings remaining in the shared
string table used for copy on write and for hash keys.  The entries
should have been freed, so this indicates a bug somewhere.

d4503 1
a4503 4
=item Unexpected constant lvalue entersub entry via type/targ %d:%d

(P) When compiling a subroutine call in lvalue context, Perl failed an
internal consistency check.  It encountered a malformed op tree.
d4505 8
a4512 18
=item Unicode non-character U+%X is illegal for open interchange

(W utf8, nonchar) Certain codepoints, such as U+FFFE and U+FFFF, are
defined by the Unicode standard to be non-characters.  Those are
legal codepoints, but are reserved for internal use; so, applications
shouldn't attempt to exchange them.  If you know what you are doing
you can turn off this warning by C<no warnings 'nonchar';>.

=item Unicode surrogate U+%X is illegal in UTF-8

(W utf8, surrogate) You had a UTF-16 surrogate in a context where they are
not considered acceptable.  These code points, between U+D800 and
U+DFFF (inclusive), are used by Unicode only for UTF-16.  However, Perl
internally allows all unsigned integer code points (up to the size limit
available on your platform), including surrogates.  But these can cause
problems when being input or output, which is likely where this message
came from.  If you really really know what you are doing you can turn
off this warning by C<no warnings 'surrogate';>.
a4518 5
=item Unknown error

(P) Perl was about to print an error message in C<$@@>, but the C<$@@> variable
did not exist, even after an attempt to create it.

d4543 1
a4543 1
(W) You tried to use an unknown subpragma of the "re" pragma.
d4545 1
a4545 1
=item Unknown switch condition (?(%s in regex; marked by <-- HERE in m/%s/
d4548 5
a4552 11
is not known.  The condition must be one of the following:

 (1) (2) ...        true if 1st, 2nd, etc., capture matched
 (<NAME>) ('NAME')  true if named capture matched
 (?=...) (?<=...)   true if subpattern matches
 (?!...) (?<!...)   true if subpattern fails to match
 (?{ CODE })        true if code returns a true value
 (R)                true if evaluating inside recursion
 (R1) (R2) ...      true if directly inside capture group 1, 2, etc.
 (R&NAME)           true if directly inside named capture
 (DEFINE)           always false; for defining named subpatterns
d4559 1
a4559 1
(F) You specified an unknown Unicode option.  See L<perlrun> documentation
d4564 1
a4564 1
(F) You specified an unknown Unicode option.  See L<perlrun> documentation
d4567 8
d4581 1
a4581 8
=item Unknown warnings category '%s'

(F) An error issued by the C<warnings> pragma.  You specified a warnings
category that is unknown to perl at this point.

Note that if you want to enable a warnings category registered by a
module (e.g. C<use warnings 'File::Find'>), you must have loaded this
module first.
d4585 1
a4585 1
(F) The brackets around a character class must match.  If you wish to
d4587 2
a4588 2
first.  The <-- HERE shows in the regular expression about where the
problem was discovered.  See L<perlre>.
d4593 3
a4595 3
expressions.  If you're a vi user, the % key is valuable for finding
the matching parenthesis.  The <-- HERE shows in the regular expression
about where the problem was discovered.  See L<perlre>.
d4617 1
a4617 1
=item Unrecognized escape \%c in character class passed through in regex; marked by <-- HERE in m/%s/
d4625 1
a4625 1
=item Unrecognized escape \%c passed through
d4631 1
a4631 1
=item Unrecognized escape \%s passed through in regex; marked by <-- HERE in m/%s/
d4634 4
a4637 3
recognized by Perl.  The character(s) were understood literally, but
this may change in a future version of Perl.  The <-- HERE shows in
the regular expression about where the escape was discovered.
d4671 1
a4671 1
of Perl executables, some of which may support fork, some not.  Try
d4704 10
d4717 1
a4717 1
a regular expression.  Fix the pattern and retry.
a4725 10
=item Unterminated verb pattern argument in regex; marked by <-- HERE in m/%s/

(F) You used a pattern of the form C<(*VERB:ARG)> but did not terminate
the pattern with a C<)>.  Fix the pattern and retry.

=item Unterminated verb pattern in regex; marked by <-- HERE in m/%s/

(F) You used a pattern of the form C<(*VERB)> but did not terminate
the pattern with a C<)>.  Fix the pattern and retry.

a4740 17
=item $[ used in %s (did you mean $] ?)

(W syntax) You used C<$[> in a comparison, such as:

    if ($[ > 5.006) {
	...
    }

You probably meant to use C<$]> instead.  C<$[> is the base for indexing
arrays.  C<$]> is the Perl version number in decimal.

=item Useless assignment to a temporary

(W misc) You assigned to an lvalue subroutine, but what
the subroutine returned was a temporary scalar about to
be discarded, so the assignment had no effect.

d4753 1
a4753 1
where the problem was discovered.  See L<perlre>.
d4757 2
a4758 2
(W syntax) The localization of lvalues such as C<local($x=10)> is legal,
but in fact the local() currently has no effect.  This may change at
d4773 1
a4773 1
where the problem was discovered.  See L<perlre>.
d4778 1
a4778 1
same length as the replacelist.  See L<perlop> for more information
a4780 5
=item Useless use of \E

(W misc) You have a \E in a double-quotish string without a C<\U>,
C<\L> or C<\Q> preceding it.

d4823 1
a4823 1
(W) You did C<use re;> without any arguments.  That isn't very useful.
d4836 2
a4837 2
apart from the array, like C<push(@@x)> or C<unshift(@@foo)>.  That won't
usually have any effect on the array, so is completely useless.  It's
d4839 1
a4839 1
if the array is tied to a class which implements a PUSH method.  If so,
d4850 1
a4850 1
is deprecated.  See L<perlvar/"$[">.
d4883 1
a4883 6
=item Use of := for an empty attribute list is not allowed

(F) The construction C<my $x := 42> used to parse as equivalent to
C<my $x : = 42> (applying an empty attribute list to C<$x>).
This construct was deprecated in 5.12.0, and has now been made a syntax
error, so C<:=> can be reclaimed as a new operator in the future.
d4885 5
a4889 2
If you need an empty attribute list, for example in a code generator, add
a space before the C<=>.
d4922 5
a4926 5
(D deprecated) As an (ahem) accidental feature, C<AUTOLOAD>
subroutines are looked up as methods (using the C<@@ISA> hierarchy)
even when the subroutines to be autoloaded were called as plain
functions (e.g. C<Foo::bar()>), not as methods (e.g. C<< Foo->bar() >> or
C<< $obj->bar() >>).
d4944 9
d4970 1
a4970 1
=item Use of %s on a handle without * is deprecated
d4972 4
a4975 28
(D deprecated) You used C<tie>, C<tied> or C<untie> on a scalar but that scalar
happens to hold a typeglob, which means its filehandle will be tied.  If
you mean to tie a handle, use an explicit * as in C<tie *$handle>.

This was a long-standing bug that was removed in Perl 5.16, as there was
no way to tie the scalar itself when it held a typeglob, and no way to
untie a scalar that had had a typeglob assigned to it.  If you see this
message, you must be using an older version.

=item Use of ?PATTERN? without explicit operator is deprecated

(D deprecated) You have written something like C<?\w?>, for a regular
expression that matches only once.  Starting this term directly with
the question mark delimiter is now deprecated, so that the question mark
will be available for use in new operators in the future.  Write C<m?\w?>
instead, explicitly using the C<m> operator: the question mark delimiter
still invokes match-once behaviour.

=item Use of qw(...) as parentheses is deprecated

(D deprecated) You have something like C<foreach $x qw(a b c) {...}>,
using a C<qw(...)> list literal where a parenthesised expression is
expected.  Historically the parser fooled itself into thinking that
C<qw(...)> literals were always enclosed in parentheses, and as a result
you could sometimes omit parentheses around them.  (You could never do
the C<foreach qw(a b c) {...}> that you might have expected, though.)
The parser no longer lies to itself in this way.  Wrap the list literal
in parentheses, like C<foreach $x (qw(a b c)) {...}>.
d4985 2
a4986 2
however, because you can overload the numification and stringification
operators and then you presumably know what you are doing.
d5010 8
a5017 9
To help you figure out what was undefined, perl will try to tell you
the name of the variable (if any) that was undefined.  In some cases
it cannot do this, so it also tells you what operation you used the
undefined value in.  Note, however, that perl optimizes your program
anid the operation displayed in the warning may not necessarily appear
literally in your program.  For example, C<"that $foo"> is usually
optimized into C<"that " . $foo>, and the warning will refer to the
C<concatenation (.)> operator, even though there is no C<.> in
your program.
d5023 2
a5024 2
used to allow this syntax, but shouldn't have.   It is now
deprecated, and will be removed in a future version.
d5030 2
a5031 2
allow this syntax, but shouldn't have.  It is now deprecated,
and will be removed in a future version.
d5039 1
a5039 1
=item Using !~ with %s doesn't make sense
d5041 15
a5055 15
(F) Using the C<!~> operator with C<s///r>, C<tr///r> or C<y///r> is
currently reserved for future use, as the exact behaviour has not
been decided.  (Simply returning the boolean opposite of the
modified string is usually not particularly useful.)

=item UTF-16 surrogate U+%X

(W utf8, surrogate) You had a UTF-16 surrogate in a context where they are
not considered acceptable.  These code points, between U+D800 and
U+DFFF (inclusive), are used by Unicode only for UTF-16.  However, Perl
internally allows all unsigned integer code points (up to the size limit
available on your platform), including surrogates.  But these can cause
problems when being input or output, which is likely where this message
came from.  If you really really know what you are doing you can turn
off this warning by C<no warnings 'surrogate';>.
d5077 1
a5077 1
This can happen for one of two reasons.  First, the outer lexical may be
d5080 1
a5080 1
subs are created at run-time.)  For example,
d5085 1
a5085 1
since the anonymous subroutine hasn't been created yet.  Conversely,
d5105 2
a5106 2
(W misc) With "use strict" in effect, you referred to a global variable
that you apparently thought was imported from another module, because
d5118 5
a5122 5
(W misc) A "my", "our" or "state" variable has been redeclared in the
current scope or statement, effectively eliminating all access to the
previous instance.  This is almost always a typographical error.  Note
that the earlier variable will still exist until the end of the scope
or until all closure referents to it are destroyed.
a5146 5
=item vector argument not supported with alpha versions

(W internal) The %vd (s)printf format does not support version objects
with alpha parts.

d5149 2
a5150 2
(F) You used a verb pattern that requires an argument.  Supply an
argument or check that you are using the right verb.
d5154 1
a5154 1
(F) You used a verb pattern that is not allowed an argument.  Remove the 
d5210 4
a5213 5
(F) The count in the (un)pack template may be replaced by C<[TEMPLATE]>
only if C<TEMPLATE> always matches the same amount of packed bytes that
can be determined from the template alone.  This is not possible if
it contains any of the codes @@, /, U, u, w or a *-length.  Redesign
the template.
d5220 1
a5220 1
=item %s "\x%X" does not map to Unicode
d5222 1
a5222 1
(F) When reading in different encodings Perl tries to map everything
d5265 1
a5265 1
L<warnings>, L<perllexwarn>, L<diagnostics>.
@


1.1.1.15
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d23 1
a23 1
below.  E.g. C<(W closed)> means a warning in the C<closed> category.
d88 1
a88 1
(S ambiguous) You said something that may not be interpreted the way
d94 1
a94 1
(S ambiguous) C<%>, C<&>, and C<*> are both infix operators (modulus,
d133 1
a133 1
(S ambiguous) You wrote something like C<-foo>, which might be the
d138 14
a235 8
=item A sequence of multiple spaces in a charnames alias definition is deprecated

(D) You defined a character name which had multiple space characters in
a row.  Change them to single spaces.  Usually these names are defined
in the C<:alias> import argument to C<use charnames>, but they could be
defined by a translator installed into C<$^H{charnames}>.  See
L<charnames/CUSTOM ALIASES>.

d330 1
a330 1
(S internal) Perl went to decrement the reference count of a scalar to
d362 3
a364 4
(W misc) You tried to set the length of an array which has
been freed.  You can do this by storing a reference to the
scalar representing the last index of an array and later
assigning through that reference.  For example
d544 1
a544 1
=item "\b{" is deprecated; use "\b\{" or "\b[{]" instead in regex; marked by <-- HERE in m/%s/
d546 1
a546 1
=item "\B{" is deprecated; use "\B\{" or "\B[{]" instead in regex; marked by <-- HERE in m/%s/
d548 1
a548 1
(W deprecated) Use of an unescaped "{" immediately following a
d550 1
a550 3
itself in a future release.  You can either precede the brace with a
backslash, or enclose it in square brackets; the latter is the way to go
if the pattern delimiters are C<{}>.
d679 1
a679 1
(F) You called C<perl -x/foo/bar>, but F</foo/bar> is not a directory
d727 1
a727 1
a file in /dev, a FIFO or an uneditable directory.  The file was ignored.
d746 7
d802 1
a802 1
for a complete list of available official properties.
a1010 9
=item Can't make loaded symbols global on this platform while loading %s

(W) A module passed the flag 0x01 to DynaLoader::dl_load_file() to request
that symbols from the stated file are made available globally within the
process, but that functionality is not available on this platform.  Whilst
the module likely will still work, this may prevent the perl interpreter
from loading other XS-based extensions which need to link directly to
functions defined in the C or XS code in the stated file.

d1271 2
a1272 7
(F) You've told Perl to dereference a string, something which
C<use strict> blocks to prevent it happening accidentally.  See
L<perlref/"Symbolic references">.  This can be triggered by an C<@@> or C<$>
in a double-quoted string immediately before interpolating a variable,
for example in C<"user @@$twitter_id">, which says to treat the contents
of C<$twitter_id> as an array reference; use a C<\> to have a literal C<@@>
symbol followed by the contents of C<$twitter_id>: C<"user \@@$twitter_id">.
d1310 1
a1310 1
It is planned to make this fatal in all instances in Perl v5.20.  In the
d1314 1
a1314 2
Note that non-alphabetic ASCII characters are discouraged here as well,
and using non-printable ones will be deprecated starting in v5.18.
d1399 1
a1399 1
ability to specify a semi-colon this way in Perl 5.20.  Just use a
d1435 1
a1435 2
=item Code point 0x%X is not Unicode, all \p{} matches fail; all \P{} matches 
succeed
d1437 1
a1437 1
(S utf8, non_unicode) You had a code point above the Unicode maximum
d1460 2
a1461 2
 chr(0x110000) =~ /\p{ASCII_Hex_Digit=True}/      # Fails.
 chr(0x110000) =~ /\p{ASCII_Hex_Digit=False}/     # Also fails!
d1465 2
a1466 2
 chr(0x110000) =~ /\P{ASCII_Hex_Digit=True}/      # Succeeds.
 chr(0x110000) =~ /\P{ASCII_Hex_Digit=False}/     # Also succeeds!
d1522 1
a1522 13
=item Constant(%s): Call to &{$^H{%s}} did not return a defined value

(F) The subroutine registered to handle constant overloading
(see L<overload>) or a custom charnames handler (see
L<charnames/CUSTOM TRANSLATORS>) returned an undefined value.

=item Constant(%s): $^H{%s} is not defined

(F) The parser found inconsistencies while attempting to define an
overloaded constant.  Perhaps you forgot to load the corresponding
L<overload> pragma?.

=item Constant(%s) unknown
d1529 5
a1586 7
=item Corrupted regexp opcode %d > %d

(F)
This is either an error in Perl, or, if you're using one, your
L<custom regular expression engine|perlreapi>.  If not the latter,
report the problem through the L<perlbug> utility.

d1634 1
a1634 2
=item (?(DEFINE)....) does not allow branches in regex; marked by <-- HERE in 
m/%s/
d1640 1
a1640 1
The <-- HERE shows whereabouts in the regular expression the problem was
d1654 8
d1729 1
a1729 1
define a C<$VERSION>.
d1771 2
a1772 2
(W unpack) You have applied the same modifier more than once after a
type in a pack template.  See L<perlfunc/pack>.
d1781 1
a1781 1
=item Empty \%c{} in regex; marked by <-- HERE in m/%s/
d1806 1
a1806 18
=item Escape literal pattern white space under /x

(D deprecated) You compiled a regular expression pattern with C</x> to
ignore white space, and you used, as a literal, one of the characters
that Perl plans to eventually treat as white space.  The character must
be escaped somehow, or it will work differently on a future Perl that
does treat it as white space.  The easiest way is to insert a backslash
immediately before it, or to enclose it with square brackets.  This
change is to bring Perl into conformance with Unicode recommendations.
Here are the five characters that generate this warning:
U+0085 NEXT LINE,
U+200E LEFT-TO-RIGHT MARK,
U+200F RIGHT-TO-LEFT MARK,
U+2028 LINE SEPARATOR,
and
U+2029 PARAGRAPH SEPARATOR.

=item Eval-group in insecure regular expression
d1812 1
a1812 1
=item Eval-group not allowed at runtime, use re 'eval' in regex m/%s/
d1822 1
a1822 1
=item Eval-group not allowed, use re 'eval' in regex m/%s/
d1828 1
a1828 2
=item EVAL without pos change exceeded limit in regex; marked by <-- HERE in 
m/%s/
d1833 1
a1833 1
The <-- HERE shows whereabouts in the regular expression the problem was
a1877 19
=item Expecting close bracket in regex; marked by <-- HERE in m/%s/

(F)
You wrote something like

 (?13

to denote a capturing group of the form
L<C<(?I<PARNO>)>|perlre/(?PARNO) (?-PARNO) (?+PARNO) (?R) (?0)>,
but omitted the C<")">.

=item Experimental "%s" subs not enabled

(F) To use lexical subs, you must first enable them:

    no warnings 'experimental::lexical_subs';
    use feature 'lexical_subs';
    my sub foo { ... }

d1901 1
a1901 1
"-", "\-".  The <-- HERE shows whereabouts in the regular expression the
d1923 1
a1923 1
(W pack) Each line in an uuencoded string starts with a length indicator
a2027 7
=item given is experimental

(S experimental::smartmatch) C<given> depends on both a lexical C<$_> and
smartmatch, both of which are experimental, so its behavior may change or
even be removed in any future release of perl.
See the explanation under L<perlsyn/Experimental Details on given and when>.

a2088 7
=item Group name must start with a non-digit word character in regex; marked by 
<-- HERE in m/%s/

(F) Group names must follow the rules for perl identifiers, meaning
they must start with a non-digit word character. A common cause of
this error is using (?&0) instead of (?0). See L<perlre>.

d2109 21
a2135 10
=item -i used with no filenames on the command line, reading from STDIN

(S inplace) The C<-i> option was passed on the command line, indicating
that the script is intended to edit files inplace, but no files were
given.  This is usually a mistake, since editing STDIN inplace doesn't
make sense, and can be confusing because it can make perl look like
it is hanging when it is really just trying to read from STDIN.  You
should either pass a filename to edit, or remove C<-i> from the command
line.  See L<perlrun> for more details.

d2143 1
a2143 1
=item Ignoring zero length \N{} in character class in regex; marked by <-- HERE in m/%s/
d2145 1
a2145 1
(W regexp) Named Unicode character escapes C<(\N{...})> may return a zero-length
a2217 11
=item Illegal pattern in regex; marked by <-- HERE in m/%s/

(F)
You wrote something like

 (?+foo)

The C<"+"> is valid only when followed by digits, indicating a
capturing group.  See
L<C<(?I<PARNO>)>|perlre/(?PARNO) (?-PARNO) (?+PARNO) (?R) (?0)>.

d2247 1
a2247 30
=item In '(*VERB...)', splitting the initial '(*' is deprecated in regex; marked by <-- HERE in m/%s/

(D regexp, deprecated)
The two-character sequence C<"(*"> in this context in a regular
expression pattern should be an indivisible token, with nothing
intervening between the C<"("> and the C<"*">, but you separated them.
Due to an accident of implementation, this prohibition was not enforced,
but we do plan to forbid it in a future Perl version.  This message
serves as giving you fair warning of this pending change.

=item In '(?...)', splitting the initial '(?' is deprecated in regex; marked by <-- HERE in m/%s/

(D regexp, deprecated)
The two-character sequence C<"(?"> in this context in a regular
expression pattern should be an indivisible token, with nothing
intervening between the C<"("> and the C<"?">, but you separated them.
Due to an accident of implementation, this prohibition was not enforced,
but we do plan to forbid it in a future Perl version.  This message
serves as giving you fair warning of this pending change.

=item Incomplete expression within '(?[ ])' in regex; marked by <-- HERE in m/%s/

(F)
There was a syntax error within the C<(?[ ])>.  This can happen if the
expression inside the construct was completely empty, or if there are
too many or few operands for the number of operators.  Perl is not smart
enough to give you a more precise indication as to what is wrong.

=item Inconsistent hierarchy during C3 merge of class '%s': merging failed on 
parent '%s'
d2265 1
a2265 1
The <-- HERE shows whereabouts in the regular expression the problem was
d2316 1
a2316 1
(S overflow) The hexadecimal, octal or binary number you have specified
a2325 9
=item Integer overflow in srand

(S overflow) The number you have passed to srand is too big to fit
in your architecture's integer representation.  The number has been
replaced with the largest integer supported (0xFFFFFFFF on 32-bit
architectures).  This means you may be getting less randomness than
you expect, because different random seeds above the maximum will
return the same sequence of random numbers.

d2328 6
a2333 7
=item Integer overflow in version %d

(W overflow) Some portion of a version initialization is too large for
the size of integers for your architecture.  This is not a warning
because there is no rational reason for a version to try and use an
element larger than typically 2**32.  This is usually caused by trying
to use some odd mathematical operation as a version, like 100/9.
d2338 1
a2338 1
The <-- HERE shows whereabouts in the regular expression the problem was
d2353 1
a2353 1
<-- HERE shows whereabouts in the regular expression the problem was
a2372 23
=item Invalid [] range "%*.*s" in regex; marked by <-- HERE in m/%s/

(F)
You wrote something like

 [z-a]

in a regular expression pattern.  Ranges must be specified with the
lowest code point first.  Instead write

 [a-z]

=item Invalid character in \N{...}; marked by <-- HERE in \N{%s}

(F) Only certain characters are valid for character names.  The
indicated one isn't.  See L<charnames/CUSTOM ALIASES>.

=item Invalid character in charnames alias definition; marked by <-- HERE in '%s

(F) You tried to create a custom alias for a character name, with
the C<:alias> option to C<use charnames> and the specified character in
the indicated name isn't valid.  See L<charnames/CUSTOM ALIASES>.

d2378 1
a2378 2
=item Invalid escape in the specified encoding in regex; marked by <-- HERE in 
m/%s/
d2384 1
a2384 1
The <-- HERE shows whereabouts in the regular expression the
a2388 3
=item Invalid hexadecimal number in \N{U+...} in regex; marked by <-- HERE in 
m/%s/

a2406 6
=item Invalid negative number (%s) in chr

(W utf8) You passed a negative number to C<chr>.  Negative numbers are
not valid characters numbers, so it return the Unicode replacement
character (U+FFFD).

d2409 3
a2411 3
(S debugging) Perl was called with invalid debugger flags.  Call perl
with the B<-D> option with no flags to see the list of acceptable values.
See also L<perlrun/-Dletters>.
d2418 1
a2418 1
up to C<ff>.  The <-- HERE shows whereabouts in the regular expression the
d2526 1
a2526 1
=item Junk on end of regexp in regex m/%s/
d2617 6
a2622 6
(W imprecision) The value you attempted to increment or decrement by one
is too large for the underlying floating point representation to store
accurately, hence the target of C<++> or C<--> is unchanged.  Perl issues this
warning because it has already switched from integers to floating point
when values are too large for integers, and now even floating point is
insufficient.  You may wish to switch to using L<Math::BigInt> explicitly.
d2696 1
a2696 9
=item Malformed UTF-8 character immediately after '%s'

(F) You said C<use utf8>, but the program file doesn't comply with UTF-8
encoding rules.  The message prints out the properly encoded characters
just before the first bad one.  If C<utf8> warnings are enabled, a
warning is generated that gives more details about the type of
malformation.

=item Malformed UTF-8 returned by \N{%s} immediately after '%s'
d2724 1
a2724 1
shows whereabouts in the regular expression the problem was discovered.
a2778 2
=item Missing braces on \N{} in regex; marked by <-- HERE in m/%s/

d2805 1
a2805 1
=item Missing name in "%s sub"
d2821 1
a2821 1
=item Missing right brace on \%c{} in regex; marked by <-- HERE in m/%s/
d2948 1
a2948 2
=item \N in a character class must be a named character: \N{...} in regex; 
marked by <-- HERE in m/%s/
d2955 1
a2955 1
=item \N{NAME} must be resolved by the lexer in regex; marked by <-- HERE in m/%s/
a2985 19
=item Need exactly 3 octal digits in regex; marked by <-- HERE in m/%s/

(F) Within S<C<(?[   ])>>, all constants interpreted as octal need to be
exactly 3 digits long.  This helps catch some ambiguities.  If your
constant is too short, add leading zeros, like

 (?[ [ \078 ] ])     # Syntax error!
 (?[ [ \0078 ] ])    # Works
 (?[ [ \007 8 ] ])   # Clearer

The maximum number this construct can express is C<\777>.  If you
need a larger one, you need to use L<\o{}|perlrebackslash/Octal escapes>
instead.  If you meant two separate things, you need to separate them

 (?[ [ \7776 ] ])        # Syntax error!
 (?[ [ \o{7776} ] ])     # One meaning
 (?[ [ \777 6 ] ])       # Another meaning
 (?[ [ \777 \006 ] ])    # Still another

d3004 2
a3005 2
So things like ** or +* or ?* are illegal.  The <-- HERE shows
whereabouts in the regular expression the problem was discovered.
d3184 5
a3254 9
=item Non-hex character in regex; marked by <-- HERE in m/%s/

(F)
In a regular expression, there was a non-hexadecimal character where
a hex one was expected, like

 (?[ [ \xDG ] ])
 (?[ [ \x{DEKA} ] ])

a3260 8
=item Non-octal character in regex; marked by <-- HERE in m/%s/

(F)
In a regular expression, there was a non-octal character where
an octal one was expected, like

 (?[ [ \o{1278} ] ])

a3266 8
=item (?[...]) not valid in locale in regex; marked by <-- HERE in m/%s/

(F)
C<(?[...])> cannot be used within the scope of a C<S<use locale>> or
with an C</l> regular expression modifier, as that would require
deferring to run-time the calculation of what it should evaluate to, and
it is regex compile-time only.

a3308 8
=item "my %s" used in sort comparison

(W syntax) The package variables $a and $b are used for sort comparisons.
You used $a or $b in as an operand to the C<< <=> >> or C<cmp> operator inside a
sort comparison block, and the variable had earlier been declared as a
lexical variable.  Either qualify the sort variable with the package
name, or rename the lexical variable.

a3350 6
=item Strings with code points over 0xFF may not be mapped into in-memory file handles

(W utf8) You tried to open a reference to a scalar for read or append
where the scalar contained code points over 0xFF.  In-memory files
model on-disk files and can only contain bytes.

d3361 1
a3361 1
(D io, deprecated) You used open() to associate a filehandle to
d3368 1
a3368 1
(D io, deprecated) You used opendir() to associate a dirhandle to
a3372 10
=item Operand with no preceding operator in regex; marked by <-- HERE in m/%s/

(F)
You wrote something like

 (?[ \p{Digit} \p{Thai} ])

There are two operands, but no operator giving how you want to combine
them.

d3382 1
a3382 1
(S utf8, non_unicode) You performed an operation requiring Unicode
d3394 1
a3394 1
(S utf8, surrogate) You performed an operation requiring Unicode
a3528 6
=item panic: child pseudo-process was never scheduled

(P) A child pseudo-process in the ithreads implementation on Windows
was not scheduled within the time period allowed and therefore was not
able to initialize properly.

a3690 6
=item panic: Sequence (?{...}): no code block found

(P) while compiling a pattern that has embedded (?{}) or (??{}) code
blocks, perl couldn't locate the code block that should have already been
seen and compiled by perl before control passed to the regex compiler.

d3730 14
a3755 26
=item Parsing code internal error (%s)

(F) Parsing code supplied by an extension violated the parser's API in
a detectable way.

=item Passing malformed UTF-8 to "%s" is deprecated

(D deprecated, utf8) This message indicates a bug either in the Perl
core or in XS code.  Such code was trying to find out if a character,
allegedly stored internally encoded as UTF-8, was of a given type, such
as being punctuation or a digit.  But the character was not encoded in
legal UTF-8.  The C<%s> is replaced by a string that can be used by
knowledgeable people to determine what the type being checked against
was.  If C<utf8> warnings are enabled, a further message is raised,
giving details of the malformation.

=item Pattern subroutine nesting without pos change exceeded limit in regex; 
marked by <-- HERE in m/%s/

(F) You used a pattern that uses too many nested subpattern calls without
consuming any text.  Restructure the pattern so text is consumed before
the nesting limit is exceeded.

The <-- HERE shows whereabouts in the regular expression the problem was
discovered.

d3768 1
a3768 2
=item Perl folding rules are not up-to-date for 0x%X; please use the perlbug 
utility to report; in regex; marked by <-- HERE in m/%s/
d3770 1
a3770 1
(D regexp, deprecated) You used a regular expression with
d3774 1
a3774 1
L<perlbug> utility.  (This message is marked deprecated, so that it by
d3806 1
a3806 1
(X) See L<perlrun/PERL_SIGNALS> for legal values.
a3814 1

a3836 21
=item perl: warning: Non hex character in '$ENV{PERL_HASH_SEED}', seed only partially set

(W) PERL_HASH_SEED should match /^\s*(?:0x)?[0-9a-fA-F]+\s*\z/ but it
contained a non hex character. This could mean you are not using the hash
seed you think you are.

=item perl: warning: strange setting in '$ENV{PERL_PERTURB_KEYS}': '%s'

(W) Perl was run with the environment variable PERL_PERTURB_KEYS defined
but containing an unexpected value. The legal values of this setting
are as follows.

  Numeric | String        | Result
  --------+---------------+-----------------------------------------
  0       | NO            | Disables key traversal randomization
  1       | RANDOM        | Enables full key traversal randomization
  2       | DETERMINISTIC | Enables repeatable key traversal randomization

Both numeric and string values are accepted, but note that string values are
case sensitive. The default for this setting is "RANDOM" or 1.

d3850 1
a3850 1
shows whereabouts in the regular expression the problem was discovered.
d3860 1
a3860 2
=item POSIX syntax [%c %c] belongs inside character classes in regex; marked by 
<-- HERE in m/%s/
d3865 12
a3876 3
implemented; they are simply placeholders for future extensions and
will cause fatal errors.  The <-- HERE shows whereabouts in the regular
expression the problem was discovered.  See L<perlre>.
d3878 1
a3878 12
=item POSIX syntax [. .] is reserved for future extensions in regex; marked by 
<-- HERE in m/%s/

(F) Within regular expression character classes ([]) the syntax beginning
with "[." and ending with ".]" is reserved for future extensions.  If you
need to represent those character sequences inside a regular expression
character class, just quote the square brackets with the backslash: "\[."
and ".\]".  The <-- HERE shows whereabouts in the regular expression the
problem was discovered.  See L<perlre>.

=item POSIX syntax [= =] is reserved for future extensions in regex; marked by 
<-- HERE in m/%s/
d3884 1
a3884 1
and "=\]".  The <-- HERE shows whereabouts in the regular expression the
a4008 11
=item Property '%s' is unknown in regex; marked by <-- HERE in m/%s/

(F)
The named property which you specified via C<\p> or C<\P> is not one
known to Perl.  Perhaps you misspelled the name?  See
L<perluniprops/Properties accessible through \p{} and \P{}>
for a complete list of available official properties.  If it is a
L<user-defined property|perlunicode/User-Defined Character Properties>
it must have been defined by the time the regular expression is
compiled.

a4047 5
=item Quantifier {n,m} with n > m can't match in regex

(W regexp) Minima should be less than or equal to maxima.  If you really
want your regexp to match something 0 times, just put {0}.

d4051 2
a4052 2
you meant it literally.  The <-- HERE shows whereabouts in the regular
expression the problem was discovered.  See L<perlre>.
d4057 2
a4058 2
the {min,max} construct.  The <-- HERE shows whereabouts in the regular
expression the problem was discovered.  See L<perlre>.
d4060 1
a4060 2
=item Quantifier unexpected on zero-length expression in regex; marked by <-- 
HERE in m/%s/
d4068 1
a4068 1
The <-- HERE shows whereabouts in the regular expression the problem was
a4070 5
=item Quantifier {n,m} with n > m can't match in regex; marked by <-- HERE in m/%s/

(W regexp) Minima should be less than or equal to maxima.  If you really
want your regexp to match something 0 times, just put {0}.

d4107 1
a4107 1
(S debugging) You can't use the B<-D> option unless the code to produce
d4150 1
a4150 1
=item Reference to invalid group 0 in regex; marked by <-- HERE in m/%s/
d4164 1
a4164 1
The <-- HERE shows whereabouts in the regular expression the problem was
d4174 1
a4174 1
The <-- HERE shows whereabouts in the regular expression the problem was
d4177 1
a4177 2
=item Reference to nonexistent or unclosed group in regex; marked by <-- HERE 
in m/%s/
d4183 1
a4183 1
The <-- HERE shows whereabouts in the regular expression the problem was
d4198 1
a4198 2
=item Regexp modifier "%c" may not appear after the "-" in regex; marked by <-- 
HERE in m/%s/
d4200 2
a4201 2
(F) Turning off the given modifier has the side effect of turning on
another one.  Perl currently doesn't allow this.  Reword the regular
d4211 1
a4211 1
=item Regexp out of space in regex m/%s/
a4227 9
=item '%s' resolved to '\o{%s}%d'

(W misc, regexp)  You wrote something like C<\08>, or C<\179> in a
double-quotish string.  All but the last digit is treated as a single
character, specified in octal.  The last digit is the next character in
the string.  To tell Perl that this is indeed what you want, you can use
the C<\o{ }> syntax, or use exactly three digits to specify the octal
for the character.

d4240 4
a4243 5
(S internal) Something went wrong in Perl's internal bookkeeping
of scalars: not all scalar variables were deallocated by the time
Perl exited.  What this usually indicates is a memory leak, which
is of course bad, especially if the Perl program is intended to be
long-running.
d4337 1
a4337 1
<-- HERE shows whereabouts in the regular expression the problem was
d4343 2
a4344 2
but has not yet been written.  The <-- HERE shows whereabouts in the
regular expression the problem was discovered.  See L<perlre>.
d4349 1
a4349 1
<-- HERE shows whereabouts in the regular expression the problem was
d4360 1
a4360 1
=item Sequence (?#... not terminated in regex m/%s/
d4363 2
a4364 1
parenthesis.  Embedded parentheses aren't allowed.  See
d4367 1
a4367 1
=item Sequence (?{...}) not terminated with ')'
d4369 4
a4372 2
(F) The end of the perl code contained within the {...} must be
followed immediately by a ')'.
a4469 21
=item Slab leaked from cv %p

(S) If you see this message, then something is seriously wrong with the
internal bookkeeping of op trees.  An op tree needed to be freed after
a compilation error, but could not be found, so it was leaked instead.

=item sleep(%u) too large

(W overflow) You called C<sleep> with a number that was larger than
it can reliably handle and C<sleep> probably slept for less time than
requested.

=item Smartmatch is experimental

(S experimental::smartmatch) This warning is emitted if you
use the smartmatch (C<~~>) operator.  This is currently an experimental
feature, and its details are subject to change in future releases of
Perl.  Particularly, its current behavior is noticed for being
unnecessarily complex and unintuitive, and is very likely to be
overhauled.

d4483 2
a4484 2
(F) A sort comparison subroutine written in XS must return exactly one
item.  See L<perlfunc/sort>.
a4520 8
=item "state %s" used in sort comparison

(W syntax) The package variables $a and $b are used for sort comparisons.
You used $a or $b in as an operand to the C<< <=> >> or C<cmp> operator inside a
sort comparison block, and the variable had earlier been declared as a
lexical variable.  Either qualify the sort variable with the package
name, or rename the lexical variable.

a4531 38
=item Subroutine "&%s" is not available

(W closure) During compilation, an inner named subroutine or eval is
attempting to capture an outer lexical subroutine that is not currently
available.  This can happen for one of two reasons.  First, the lexical
subroutine may be declared in an outer anonymous subroutine that has not
yet been created.  (Remember that named subs are created at compile time,
while anonymous subs are created at run-time.)  For example,

    sub { my sub a {...} sub f { \&a } }

At the time that f is created, it can't capture the current the "a" sub,
since the anonymous subroutine hasn't been created yet.  Conversely, the
following won't give a warning since the anonymous subroutine has by now
been created and is live:

    sub { my sub a {...} eval 'sub f { \&a }' }->();

The second situation is caused by an eval accessing a variable that has
gone out of scope, for example,

    sub f {
	my sub a {...}
	sub { eval '\&a' }
    }
    f()->();

Here, when the '\&a' in the eval is being compiled, f() is not currently
being executed, so its &a is not available for capture.

=item "%s" subroutine &%s masks earlier declaration in same %s

(W misc) A "my" or "state" subroutine has been redeclared in the
current scope or statement, effectively eliminating all access to
the previous instance.  This is almost always a typographical error.
Note that the earlier subroutine will still exist until the end of
the scope or until all closure references to it are destroyed.

d4573 1
a4573 2
=item Switch (?(condition)... contains too many branches in regex; marked by 
<-- HERE in m/%s/
d4582 1
a4582 1
The <-- HERE shows whereabouts in the regular expression the problem
d4588 2
a4589 2
a number, it can be only a number.  The <-- HERE shows whereabouts in
the regular expression the problem was discovered.  See L<perlre>.
a4640 6
=item Syntax error in (?[...]) in regex m/%s/

(F)
Perl could not figure out what you meant inside this construct; this
notifies you that it is giving up trying.

d4688 1
a4688 1
=item The crypt() function is unimplemented due to excessive paranoia.
a4695 35
=item The lexical_subs feature is experimental

(S experimental::lexical_subs) This warning is emitted if you
declare a sub with C<my> or C<state>.  Simply suppress the warning
if you want to use the feature, but know that in doing so you
are taking the risk of using an experimental feature which may
change or be removed in a future Perl version:

    no warnings "experimental::lexical_subs";
    use feature "lexical_subs";
    my sub foo { ... }

=item The regex_sets feature is experimental

(S experimental::regex_sets) This warning is emitted if you
use the syntax S<C<(?[   ])>> in a regular expression.
The details of this feature are subject to change.
if you want to use it, but know that in doing so you
are taking the risk of using an experimental feature which may
change in a future Perl version, you can do this to silence the
warning:

    no warnings "experimental::regex_sets";

=item The %s feature is experimental

(S experimental) This warning is emitted if you enable an experimental
feature via C<use feature>.  Simply suppress the warning if you want
to use the feature, but know that in doing so you are taking the risk
of using an experimental feature which may change or be removed in a
future Perl version:

    no warnings "experimental::lexical_subs";
    use feature "lexical_subs";

a4723 8
=item This Perl has not been built with support for randomized hash key traversal but something called Perl_hv_rand_set().

(F) Something has attempted to use an internal API call which
depends on Perl being compiled with the default support for randomized hash
key traversal, but this Perl has been compiled without it. You should
report this warning to the relevant upstream party, or recompile perl
with default options.

a4809 8
=item Trailing white-space in a charnames alias definition is deprecated

(D) You defined a character name which ended in a space character.
Remove the trailing space(s).  Usually these names are defined in the
C<:alias> import argument to C<use charnames>, but they could be defined
by a translator installed into C<$^H{charnames}>.
See L<charnames/CUSTOM ALIASES>.

d4855 4
d4861 1
a4861 1
(S internal) The exit code detected an internal inconsistency in how
d4866 1
a4866 1
(S internal) The exit code detected an internal inconsistency in how
d4871 1
a4871 1
(S internal) The exit code detected an internal inconsistency in how
d4876 1
a4876 1
(S internal) On exit, Perl found some strings remaining in the shared
d4882 1
a4882 1
(S internal) The exit code detected an internal inconsistency in how
a4930 47
=item Unexpected '(' with no preceding operator in regex; marked by <-- HERE in m/%s/

(F)
You had something like this:

 (?[ \p{Digit} ( \p{Lao} + \p{Thai} ) ])

There should be an operator before the C<"(">, as there's no indication
as to how the digits are to be combined with the characters in the Lao
and Thai scripts.

=item Unexpected ')' in regex; marked by <-- HERE in m/%s/

(F)
You had something like this:

 (?[ ( \p{Digit} + ) ])

The C<")"> is out-of-place.  Something apparently was supposed to be
combined with the digits, or the C<"+"> shouldn't be there, or something
like that.  Perl can't figure out what was intended.

=item Unexpected binary operator '%c' with no preceding operand in regex; marked by <-- HERE in m/%s/

(F)
You had something like this:

 (?[ | \p{Digit} ])

where the C<"|"> is a binary operator with an operand on the right, but
no operand on the left.

=item Unexpected character in regex; marked by <-- HERE in m/%s/

(F)
You had something like this:

 (?[ z ])

Within C<(?[ ])>, no literal characters are allowed unless they are
within an inner pair of square brackets, like

 (?[ [ z ] ])

Another possibility is that you forgot a backslash.  Perl isn't smart
enough to figure out what you really meant.

d4938 1
a4938 1
(S utf8, nonchar) Certain codepoints, such as U+FFFE and U+FFFF, are
d4946 1
a4946 1
(S utf8, surrogate) You had a UTF-16 surrogate in a context where they are
a4959 10
=item Unknown charname '%s'

(F) The name you used inside C<\N{}> is unknown to Perl.  Check the
spelling.  You can say C<use charnames ":loose"> to not have to be
so precise about spaces, hyphens, and capitalization on standard Unicode
names.  (Any custom aliases that have been created must be specified
exactly, regardless of whether C<:loose> is used or not.)  This error may
also happen if the C<\N{}> is not in the scope of the corresponding
C<S<use charnames>>.

a4990 15
=item Unknown regex modifier "%s"

(F) Alphanumerics immediately following the closing delimiter
of a regular expression pattern are interpreted by Perl as modifier
flags for the regex.  One of the ones you specified is invalid.  One way
this can happen is if you didn't put in white space between the end of
the regex and a following alphanumeric operator:

 if ($a =~ /foo/and $bar == 3) { ... }

The C<"a"> is a valid modifier flag, but the C<"n"> is not, and raises
this error.  Likely what was meant instead was:

 if ($a =~ /foo/ and $bar == 3) { ... }

d5006 1
a5006 1
The <-- HERE shows whereabouts in the regular expression the problem was
d5034 1
a5034 11
=item Unmatched '%c' in POSIX class in regex; marked by <-- HERE in m/%s/

You had something like this:

 (?[ [:alnum] ])

There should be a second C<":">, like this:

 (?[ [:alnum:] ])

=item Unmatched [ in regex; marked by <-- HERE in m/%s/
d5038 1
a5038 1
first.  The <-- HERE shows whereabouts in the regular expression the
d5041 1
a5041 14
=item Unmatched '[' in POSIX class in regex; marked by <-- HERE in m/%s/

(F)
You had something like this:

 (?[ [:digit: ])

That should be written:

 (?[ [:digit:] ])

=item Unmatched ( in regex; marked by <-- HERE in m/%s/

=item Unmatched ) in regex; marked by <-- HERE in m/%s/
d5045 2
a5046 2
the matching parenthesis.  The <-- HERE shows whereabouts in the
regular expression the problem was discovered.  See L<perlre>.
d5068 1
a5068 9
=item Unrecognized escape \%c in character class in regex; marked by <-- HERE in m/%s/

(F)
You used a backslash-character combination which is not recognized by
Perl inside character classes.  This is a fatal error when the character
class is used within C<(?[ ])>.

=item Unrecognized escape \%c in character class passed through in regex; 
marked by <-- HERE in m/%s/
d5073 1
a5073 1
The <-- HERE shows whereabouts in the regular expression the
d5086 2
a5087 2
this may change in a future version of Perl.  The <-- HERE shows
whereabouts in the regular expression the escape was discovered.
a5153 12
=item Unterminated delimiter for here document

(F) This message occurs when a here document label has an initial
quotation mark but the final quotation mark is missing.  Perhaps
you wrote:

    <<"foo

instead of:

    <<"foo"

a5201 23
=item Use \\x{...} for more than two hex characters in regex; marked by <-- HERE in m/%s/

(F)
In a regular expression, you said something like

 (?[ [ \xBEEF ] ])

Perl isn't sure if you meant this

 (?[ [ \x{BEEF} ] ])

or if you meant this

 (?[ [ \x{BE} E F ] ])

You need to add either braces or blanks to disambiguate.

=item Use of each() on hash after insertion without resetting hash iterator results in undefined behavior

(S internal) The behavior of C<each()> after insertion is undefined, it may
skip items, or visit items more than once. Consider using C<keys()> instead
of C<each()>.

d5208 1
a5208 2
=item Useless (?-%s) - don't use /%s modifier in regex; marked by <-- HERE in 
m/%s/
d5219 2
a5220 2
The <-- HERE shows whereabouts in the regular expression the problem was
discovered.  See L<perlre>.
d5239 2
a5240 2
The <-- HERE shows whereabouts in the regular expression the problem was
discovered.  See L<perlre>.
a5247 25
=item Useless use of '\'; doesn't escape metacharacter '%c'

(D deprecated) You wrote a regular expression pattern something like
one of these:

 m{ \x\{FF\} }x
 m{foo\{1,3\}}
 qr(foo\(bar\))
 s[foo\[a-z\]bar][baz]

The interior braces, square brackets, and parentheses are treated as
metacharacters even though they are backslashed; instead write:

 m{ \x{FF} }x
 m{foo{1,3}}
 qr(foo(bar))
 s[foo[a-z]bar][baz]

The backslashes have no effect when a regular expression pattern is
delimitted by C<{}>, C<[]>, or C<()>, which ordinarily are
metacharacters, and the delimiters are also used, paired, within the
interior of the pattern.  It is planned that a future Perl release will
change the meaning of constructs like these so that the backslashes
will have an effect, so remove them from your code.

a5304 6
=item Useless use of (?-p) in regex; marked by <-- HERE in m/%s/

(W regexp)
The C<p> modifier cannot be turned off once set.  Trying to do so is
futile.

a5313 14
=item Useless (%s%c) - %suse /%c modifier in regex; marked by <-- HERE in m/%s/

(W regexp)
The C</g> and C</o> regular expression modifiers are global and can't be
turned off once set; hence things like C<(?g)> or C<(?-o:)> do nothing.

=item Useless (%sc) - %suse /gc modifier in regex; marked by <-- HERE in m/%s/

(W regexp)
The C</c> regular expression modifier is global, can't be turned off
once set, and doesn't do anything without the C</g> modifier being
specified as well; hence things like C<(?c)> or C<(?-c:)> do nothing,
nor do thing like C<(?gc)> nor C<(?-gc:)> .

a5434 6
=item Use of my $_ is experimental

(S experimental::lexical_topic) Lexical $_ is an experimental feature and
its behavior may change or even be removed in any future release of perl.
See the explanation under L<perlvar/$_>.

d5455 11
d5477 1
a5477 1
=item Use of state $_ is experimental
d5479 6
a5484 3
(S experimental::lexical_topic) Lexical $_ is an experimental feature and
its behavior may change or even be removed in any future release of perl.
See the explanation under L<perlvar/$_>.
d5523 1
a5523 2
=item Using just the first character returned by \N{} in character class in 
regex; marked by <-- HERE in m/%s/
d5525 3
a5527 3
(W regexp) A charnames handler may return a sequence of more than one
character.  Currently all but the first one are discarded when used in
a regular expression pattern bracketed character class.
d5538 1
a5538 1
(S utf8, surrogate) You had a UTF-16 surrogate in a context where they are
d5595 1
a5595 1
(S misc) With "use strict" in effect, you referred to a global variable
d5601 1
a5601 1
=item Variable length lookbehind not implemented in regex m/%s/
d5612 1
a5612 1
or until all closure references to it are destroyed.
d5639 1
a5639 1
(S printf) The %vd (s)printf format does not support version objects
d5642 1
a5642 2
=item Verb pattern '%s' has a mandatory argument in regex; marked by <-- HERE 
in m/%s/ 
d5647 1
a5647 2
=item Verb pattern '%s' may not have an argument in regex; marked by <-- HERE 
in m/%s/ 
a5692 8
=item when is experimental

(S experimental::smartmatch) C<when> depends on smartmatch, which is
experimental.  Additionally, it has several special cases that may
not be immediately obvious, and their behavior may change or
even be removed in any future release of perl.
See the explanation under L<perlsyn/Experimental Details on given and when>.

d5718 1
a5718 1
(F) When reading in different encodings, Perl tries to map everything
d5720 1
a5720 1
this encoding.  For example
@


1.1.1.16
log
@Import perl-5.20.1
@
text
@d57 1
a57 1
=item '%c' allowed only after types %s in %s
a91 7
=item Ambiguous use of -%s resolved as -&%s()

(S ambiguous) You wrote something like C<-foo>, which might be the
string C<"-foo">, or a call to the function C<foo>, negated.  If you meant
the string, just write C<"-foo">.  If you meant the function call,
write C<-foo()>.

d131 7
d173 28
d224 5
a228 5
(D deprecated) You defined a character name which had multiple space
characters in a row.  Change them to single spaces.  Usually these
names are defined in the C<:alias> import argument to C<use charnames>, but
they could be defined by a translator installed into C<$^H{charnames}>.
See L<charnames/CUSTOM ALIASES>.
d234 1
a234 1
=item Assertion %s failed: file "%s", line %d
d249 8
a261 6
=item Attempt to bless into a freed package

(F) You wrote C<bless $foo> with one argument after somehow causing
the current package to be freed.  Perl cannot figure out what to
do, so it throws up in hands in despair.

d332 6
a376 6
=item Attribute prototype(%s) discards earlier prototype attribute in same sub

(W misc) A sub was declared as sub foo : prototype(A) : prototype(B) {}, for
example.  Since each sub can only have one prototype, the earlier
declaration(s) are discarded while the last one is applied.

d515 1
a515 1
=item \%d better written as $%d
d539 1
a539 2
=item "\b{" is deprecated; use "\b\{" or "\b[{]" instead in regex; marked
by S<<-- HERE> in m/%s/
d541 1
a541 2
=item "\B{" is deprecated; use "\B\{" or "\B[{]" instead in regex; marked
by S<<-- HERE> in m/%s/
d543 5
a547 5
(D deprecated) Use of an unescaped "{" immediately following
a C<\b> or C<\B> is now deprecated so as to reserve its use for Perl
itself in a future release.  You can either precede the brace
with a backslash, or enclose it in square brackets; the latter
is the way to go if the pattern delimiters are C<{}>.
a557 5
=item Bizarre SvTYPE [%d]

(P) When starting a new thread or returning values from a thread, Perl
encountered an invalid data type.

d564 5
a584 5
=item Calling POSIX::%s() is deprecated

(D deprecated) You called a function whose use is deprecated.  See
the function's name in L<POSIX> for details.

a673 10
=item Can't call mro_isa_changed_in() on anonymous symbol table

(P) Perl got confused as to whether a hash was a plain hash or a
symbol table hash when trying to update @@ISA caches.

=item Can't call mro_method_changed_in() on anonymous symbol table

(F) An XS module tried to call C<mro_method_changed_in> on a hash that was
not attached to the symbol table.

a884 5
=item Can't goto subroutine from an eval-%s

(F) The "goto subroutine" call can't be used to jump out of an eval
"string" or block.

d891 5
d1003 1
a1003 1
(S) A module passed the flag 0x01 to DynaLoader::dl_load_file() to request
a1269 2
=item Can't use string ("%s"...) as %s ref while "strict refs" in use

d1311 1
a1311 1
=item Character following "\c" must be printable ASCII
d1313 3
a1315 5
(F)(D deprecated, syntax) In C<\cI<X>>, I<X> must be a printable
(non-control) ASCII character.  This is fatal starting in v5.20 for
non-ASCII characters, and it is planned to make this fatal in all
instances in Perl v5.22.  In
the cases where it isn't fatal, the character this evaluates to is
d1318 2
a1319 3
Note that ASCII characters that don't map to control characters are
discouraged here as well, and will generate the warning (when enabled)
L</""\c%c" is more clearly written simply as "%s"">.
d1336 12
a1374 12
=item Character in 'W' format wrapped in pack

(W pack) You said

    pack("U0W", $x)

where $x is either less than 0 or more than 255.  However, C<U0>-mode
expects all values to fall in the interval [0, 255], so Perl behaved
as if you meant:

    pack("U0W", $x & 255)

d1399 8
d1418 4
a1426 4
=item close() on unopened filehandle %s

(W unopened) You tried to close a filehandle that was never opened.

d1440 4
a1443 1
(S non_unicode) You had a code point above the Unicode maximum
d1453 21
d1477 1
a1477 1
instead of Perl.  Check the #! line, or manually feed your script
d1500 22
d1538 8
a1545 1
L<overload> pragma?
a1566 7
=item Constant(%s) unknown

(F) The parser found inconsistencies either while attempting
to define an overloaded constant, or when trying to find the
character name specified in the C<\N{...}> escape.  Perhaps you
forgot to load the corresponding L<overload> pragma?.

a1585 6
=item Corrupted regexp opcode %d > %d

(P) This is either an error in Perl, or, if you're using
one, your L<custom regular expression engine|perlreapi>.  If not the
latter, report the problem through the L<perlbug> utility.

d1600 7
a1612 4
=for comment
The following are used in lib/diagnostics.t for testing two =items that
share the same description.  Changes here need to be propagated to there

d1654 2
a1655 2
=item (?(DEFINE)....) does not allow branches in regex; marked by
S<<-- HERE> in m/%s/
a1668 24
=item delete argument is index/value array slice, use array slice

(F) You used index/value array slice syntax (C<%array[...]>) as
the argument to C<delete>.  You probably meant C<@@array[...]> with
an @@ symbol instead.

=item delete argument is key/value hash slice, use hash slice

(F) You used key/value hash slice syntax (C<%hash{...}>) as the argument to
C<delete>.  You probably meant C<@@hash{...}> with an @@ symbol instead.

=item delete argument is not a HASH or ARRAY element or slice

(F) The argument to C<delete> must be either a hash or array element,
such as:

    $foo{$bar}
    $ref->{"susie"}[12]

or a hash or array slice, such as:

    @@foo[$bar, $baz, $xyzzy]
    @@{$ref->[12]}{"susie", "queue"}

d1691 1
a1691 1
Beginning with perl 5.10.0, you can also use C<state> variables to have
d1749 1
a1749 6
=item Don't know how to get file name

(P) C<PerlIO_getname>, a perl internal I/O function specific to VMS, was
somehow called on another platform.  This should not happen.

=item Don't know how to handle magic of type \%o
a1786 8
=item each on reference is experimental

(S experimental::autoderef) C<each> with a scalar argument is experimental
and may change or be removed in a future Perl version.  If you want to
take the risk of using this feature, simply disable this warning:

    no warnings "experimental::autoderef";

d1794 1
a1794 1
=item Empty \%c{} in regex; marked by S<<-- HERE> in m/%s/
d1858 2
a1859 2
=item EVAL without pos change exceeded limit in regex; marked by
S<<-- HERE> in m/%s/
a1882 14
=item exists argument is not a HASH or ARRAY element or a subroutine

(F) The argument to C<exists> must be a hash or array element or a
subroutine with an ampersand, such as:

    $foo{$bar}
    $ref->{"susie"}[12]
    &do_something

=item exists argument is not a subroutine name

(F) The argument to C<exists> for C<exists &sub> must be a subroutine name,
and not a subroutine call.  C<exists &sub()> will generate this error.

d1909 1
a1909 1
=item Expecting close bracket in regex; marked by S<<-- HERE> in m/%s/
d1911 2
a1912 1
(F) You wrote something like
a1919 19
=item Expecting '(?flags:(?[...' in regex; marked by S<<-- HERE> in m/%s/

(F) The C<(?[...])> extended character class regular expression construct
only allows character classes (including character class escapes like
C<\d>), operators, and parentheses.  The one exception is C<(?flags:...)>
containing at least one flag and exactly one C<(?[...])> construct.
This allows a regular expression containing just C<(?[...])> to be
interpolated.  If you see this error message, then you probably
have some other C<(?...)> construct inside your character class.  See
L<perlrecharclass/Extended Bracketed Character Classes>.

=item Experimental subroutine signatures not enabled

(F) To use subroutine signatures, you must first enable them:

    no warnings "experimental::signatures";
    use feature "signatures";
    sub foo ($left, $right) { ... }

d1946 1
a1946 1
=item False [] range "%s" in regex; marked by S<<-- HERE> in m/%s/
d1948 1
a1948 1
(W regexp)(F) A character class range must start and end at a literal
d1950 3
a1952 4
in your false range is interpreted as a literal "-".  In a C<(?[...])>
construct, this is an error, rather than a warning.  Consider quoting
the "-", "\-".  The S<<-- HERE> shows whereabouts in the regular expression
the problem was discovered.  See L<perlre>.
d2080 4
a2083 4
(S experimental::smartmatch) C<given> depends on smartmatch, which
is experimental, so its behavior may change or even be removed
in any future release of perl.  See the explanation under
L<perlsyn/Experimental Details on given and when>.
a2112 5
=item gmtime(%f) failed

(W overflow) You called C<gmtime> with a number that it could not handle:
too large, too small, or NaN.  The returned value is C<undef>.

a2140 7
=item Group name must start with a non-digit word character in regex; marked by 
S<<-- HERE> in m/%s/

(F) Group names must follow the rules for perl identifiers, meaning
they must start with a non-digit word character.  A common cause of
this error is using (?&0) instead of (?0).  See L<perlre>.

d2146 7
d2179 10
d2196 1
a2196 2
=item Ignoring zero length \N{} in character class in regex; marked by
S<<-- HERE> in m/%s/
d2198 3
a2200 3
(W regexp) Named Unicode character escapes C<(\N{...})> may return a
zero-length sequence.  When such an escape is used in a character class
its behaviour is not well defined.  Check that the correct escape has
d2215 2
a2216 4
(W illegalproto) An illegal character was found in a prototype
declaration.  The '_' in a prototype must be followed by a ';',
indicating the rest of the parameters are optional, or one of '@@'
or '%', since those two will accept 0 or more final parameters.
a2229 3
Perhaps you were trying to write a subroutine signature but didn't enable
that feature first (C<use feature 'signatures'>), so your signature was
instead interpreted as a bad prototype.
d2271 1
a2271 1
=item Illegal pattern in regex; marked by S<<-- HERE> in m/%s/
d2273 2
a2274 1
(F) You wrote something like
d2311 21
a2331 2
=item Incomplete expression within '(?[ ])' in regex; marked by S<<-- HERE>
in m/%s/
d2333 2
a2334 1
(F) There was a syntax error within the C<(?[ ])>.  This can happen if the
d2352 1
a2352 1
=item Infinite recursion in regex
d2358 3
a2368 22
=item %%s[%s] in scalar context better written as $%s[%s]

(W syntax) In scalar context, you've used an array index/value slice
(indicated by %) to select a single element of an array.  Generally
it's better to ask for a scalar value (indicated by $).  The difference
is that C<$foo[&bar]> always behaves like a scalar, both in the value it
returns and when evaluating its argument, while C<%foo[&bar]> provides
a list context to its subscript, which can do weird things if you're
expecting only one subscript.  When called in list context, it also
returns the index (what C<&bar> returns) in addition to the value.

=item %%s{%s} in scalar context better written as $%s{%s}

(W syntax) In scalar context, you've used a hash key/value slice
(indicated by %) to select a single element of a hash.  Generally it's
better to ask for a scalar value (indicated by $).  The difference
is that C<$foo{&bar}> always behaves like a scalar, both in the value
it returns and when evaluating its argument, while C<@@foo{&bar}> and
provides a list context to its subscript, which can do weird things
if you're expecting only one subscript.  When called in list context,
it also returns the key in addition to the value.

a2400 11
=item In '(?...)', splitting the initial '(?' is deprecated in regex;
marked by S<<-- HERE> in m/%s/

(D regexp, deprecated) The two-character sequence C<"(?"> in
this context in a regular expression pattern should be an
indivisible token, with nothing intervening between the C<"(">
and the C<"?">, but you separated them.  Due to an accident of
implementation, this prohibition was not enforced, but we do
plan to forbid it in a future Perl version.  This message
serves as giving you fair warning of this pending change.

d2438 1
a2438 1
=item Internal disaster in regex; marked by S<<-- HERE> in m/%s/
d2441 1
a2441 1
The S<<-- HERE> shows whereabouts in the regular expression the problem was
d2453 1
a2453 10
=item internal %<num>p might conflict with future printf extensions

(S internal) Perl's internal routine that handles C<printf> and C<sprintf>
formatting follows a slightly different set of rules when called from
C or XS code.  Specifically, formats consisting of digits followed
by "p" (e.g., "%7p") are reserved for future use.  If you see this
message, then an XS module tried to call that routine with one such
reserved format.

=item Internal urp in regex; marked by S<<-- HERE> in m/%s/
d2456 1
a2456 1
S<<-- HERE> shows whereabouts in the regular expression the problem was
d2476 4
a2479 2
=item Invalid character in charnames alias definition; marked by
S<<-- HERE> in '%s
d2481 1
a2481 3
(F) You tried to create a custom alias for a character name, with
the C<:alias> option to C<use charnames> and the specified character in
the indicated name isn't valid.  See L<charnames/CUSTOM ALIASES>.
d2483 2
a2484 1
=item Invalid \0 character in %s for %s: %s\0%s
d2486 1
a2486 3
(W syscalls) Embedded \0 characters in pathnames or other system call
arguments produce a warning as of 5.20.  The parts after the \0 were
formerly ignored by system calls.
d2488 1
a2488 1
=item Invalid character in \N{...}; marked by S<<-- HERE> in \N{%s}
d2493 6
d2504 2
a2505 2
=item Invalid escape in the specified encoding in regex; marked by
S<<-- HERE> in m/%s/
d2507 1
a2507 1
(W regexp)(F) The numeric escape (for example C<\xHH>) of value < 256
d2510 2
a2511 3
The escape was replaced with REPLACEMENT CHARACTER (U+FFFD)
instead, except within S<C<(?[   ])>>, where it is a fatal error.
The S<<-- HERE> shows whereabouts in the regular expression the
d2516 2
a2517 2
=item Invalid hexadecimal number in \N{U+...} in regex; marked by
S<<-- HERE> in m/%s/
d2549 1
a2549 1
=item Invalid [] range "%s" in regex; marked by S<<-- HERE> in m/%s/
d2554 1
a2554 1
up to C<ff>.  The S<<-- HERE> shows whereabouts in the regular expression the
a2611 11
=item In '(*VERB...)', splitting the initial '(*' is deprecated in regex;
marked by S<<-- HERE> in m/%s/

(D regexp, deprecated) The two-character sequence C<"(*"> in
this context in a regular expression pattern should be an
indivisible token, with nothing intervening between the C<"(">
and the C<"*">, but you separated them.  Due to an accident of
implementation, this prohibition was not enforced, but we do
plan to forbid it in a future Perl version.  This message
serves as giving you fair warning of this pending change.

d2636 1
a2636 1
perls, has been removed as of 5.10.0 and is no longer supported.  In
d2648 1
a2648 1
perls, has been removed as of 5.10.0 and is no longer supported.  You
a2661 10
=item -i used with no filenames on the command line, reading from STDIN

(S inplace) The C<-i> option was passed on the command line, indicating
that the script is intended to edit files in place, but no files were
given.  This is usually a mistake, since editing STDIN in place doesn't
make sense, and can be confusing because it can make perl look like
it is hanging when it is really just trying to read from STDIN.  You
should either pass a filename to edit, or remove C<-i> from the command
line.  See L<perlrun> for more details.

a2665 8
=item keys on reference is experimental

(S experimental::autoderef) C<keys> with a scalar argument is experimental
and may change or be removed in a future Perl version.  If you want to
take the risk of using this feature, simply disable this warning:

    no warnings "experimental::autoderef";

d2695 1
a2695 1
=item length() used on %s (did you mean "scalar(%s)"?)
a2732 5
=item localtime(%f) failed

(W overflow) You called C<localtime> with a number that it could not handle:
too large, too small, or NaN.  The returned value is C<undef>.

a2784 6
=item Magical list constants are not supported

(F) You assigned a magical array to a stash element, and then tried
to use the subroutine from the same slot.  You are asking Perl to do
something it cannot do, details subject to change between Perl versions.

a2814 3
Perhaps the function's author was trying to write a subroutine signature
but didn't enable that feature first (C<use feature 'signatures'>),
so the signature was instead interpreted as a bad prototype.
d2864 1
a2864 42
=item Mandatory parameter follows optional parameter

(F) In a subroutine signature, you wrote something like "$a = undef,
$b", making an earlier parameter optional and a later one mandatory.
Parameters are filled from left to right, so it's impossible for the
caller to omit an earlier one and pass a later one.  If you want to act
as if the parameters are filled from right to left, declare the rightmost
optional and then shuffle the parameters around in the subroutine's body.

=item Matched non-Unicode code point 0x%X against Unicode property; may
not be portable

(S non_unicode) Perl allows strings to contain a superset of
Unicode code points; each code point may be as large as what is storable
in an unsigned integer on your system, but these may not be accepted by
other languages/systems.  This message occurs when you matched a string
containing such a code point against a regular expression pattern, and
the code point was matched against a Unicode property, C<\p{...}> or
C<\P{...}>.  Unicode properties are only defined on Unicode code points,
so the result of this match is undefined by Unicode, but Perl (starting
in v5.20) treats non-Unicode code points as if they were typical
unassigned Unicode ones, and matched this one accordingly.  Whether a
given property matches these code points or not is specified in
L<perluniprops/Properties accessible through \p{} and \P{}>.

This message is suppressed (unless it has been made fatal) if it is
immaterial to the results of the match if the code point is Unicode or
not.  For example, the property C<\p{ASCII_Hex_Digit}> only can match
the 22 characters C<[0-9A-Fa-f]>, so obviously all other code points,
Unicode or not, won't match it.  (And C<\P{ASCII_Hex_Digit}> will match
every code point except these 22.)

Getting this message indicates that the outcome of the match arguably
should have been the opposite of what actually happened.  If you think
that is the case, you may wish to make the C<non_unicode> warnings
category fatal; if you agree with Perl's decision, you may wish to turn
off this category.

See L<perlunicode/Beyond Unicode code points> for more information.

=item %s matches null string many times in regex; marked by S<<-- HERE> in
m/%s/
d2867 1
a2867 1
regular expression engine didn't specifically check for that.  The S<<-- HERE>
d2923 1
a2923 1
=item Missing braces on \N{} in regex; marked by S<<-- HERE> in m/%s/
a2950 4
=item Missing ']' in prototype for %s : %s

(W illegalproto) A grouping was started with C<[> but never closed with C<]>.

d2953 1
a2953 1
(F) The syntax for lexically scoped subroutines requires that
d2967 1
a2967 1
=item Missing right brace on \%c{} in regex; marked by S<<-- HERE> in m/%s/
a3055 23
=item mprotect for COW string %p %u failed with %d

(S) You compiled perl with B<-D>PERL_DEBUG_READONLY_COW (see
L<perlguts/"Copy on Write">), but a shared string buffer
could not be made read-only.

=item mprotect for %p %u failed with %d

(S) You compiled perl with B<-D>PERL_DEBUG_READONLY_OPS (see L<perlhacktips>),
but an op tree could not be made read-only.

=item mprotect RW for COW string %p %u failed with %d

(S) You compiled perl with B<-D>PERL_DEBUG_READONLY_COW (see
L<perlguts/"Copy on Write">), but a read-only shared string
buffer could not be made mutable.

=item mprotect RW for %p %u failed with %d

(S) You compiled perl with B<-D>PERL_DEBUG_READONLY_OPS (see
L<perlhacktips>), but a read-only op tree could not be made
mutable before freeing the ops.

a3075 8
=item "my %s" used in sort comparison

(W syntax) The package variables $a and $b are used for sort comparisons.
You used $a or $b in as an operand to the C<< <=> >> or C<cmp> operator inside a
sort comparison block, and the variable had earlier been declared as a
lexical variable.  Either qualify the sort variable with the package
name, or rename the lexical variable.

d3084 12
a3095 13
(W once) Typographical errors often show up as unique variable
names.  If you had a good reason for having a unique name, then
just mention it again somehow to suppress the message.  The C<our>
declaration is also provided for this purpose.

NOTE: This warning detects package symbols that have been used only
once. This means lexical variables will never trigger this warning.
It also means that all of the package variables $c, @@c, %c, as well
as *c, &c, sub c{}, c(), and c (the filehandle or
format) are considered the same; if a program uses $c only once
but also uses any of the others it will not trigger this warning.
Symbols beginning with an underscore and symbols using special
identifiers (q.v. L<perldata>) are exempt from this warning.
d3097 4
a3100 1
=item Need exactly 3 octal digits in regex; marked by S<<-- HERE> in m/%s/
d3102 36
a3137 3
(F) Within S<C<(?[   ])>>, all constants interpreted as octal need to be
exactly 3 digits long.  This helps catch some ambiguities.  If your
constant is too short, add leading zeros, like
d3144 2
a3145 2
need a larger one, you need to use L<\o{}|perlrebackslash/Octal escapes> instead.  If you meant
two separate things, you need to separate them:
d3167 1
a3167 1
=item Nested quantifiers in regex; marked by S<<-- HERE> in m/%s/
d3170 1
a3170 1
So things like ** or +* or ?* are illegal.  The S<<-- HERE> shows
a3186 50
=item \N in a character class must be a named character: \N{...} in regex; 
marked by S<<-- HERE> in m/%s/

(F) The new (as of Perl 5.12) meaning of C<\N> as C<[^\n]> is not valid in a
bracketed character class, for the same reason that C<.> in a character
class loses its specialness: it matches almost everything, which is
probably not what you want.

=item \N{} in character class restricted to one character in regex; marked
by S<<-- HERE> in m/%s/

(F) Named Unicode character escapes C<(\N{...})> may return a
multi-character sequence.  Such an escape may not be used in
a character class, because character classes always match one
character of input.  Check that the correct escape has been used,
and the correct charname handler is in scope.  The S<<-- HERE> shows
whereabouts in the regular expression the problem was discovered.

=item \N{NAME} must be resolved by the lexer in regex; marked by
S<<-- HERE> in m/%s/

(F) When compiling a regex pattern, an unresolved named character or
sequence was encountered.  This can happen in any of several ways that
bypass the lexer, such as using single-quotish context, or an extra
backslash in double-quotish:

    $re = '\N{SPACE}';	# Wrong!
    $re = "\\N{SPACE}";	# Wrong!
    /$re/;

Instead, use double-quotes with a single backslash:

    $re = "\N{SPACE}";	# ok
    /$re/;

The lexer can be bypassed as well by creating the pattern from smaller
components:

    $re = '\N';
    /${re}{SPACE}/;	# Wrong!

It's not a good idea to split a construct in the middle like this, and
it doesn't work here.  Instead use the solution above.

Finally, the message also can happen under the C</x> regex modifier when the
C<\N> is separated by spaces from the C<{>, in which case, remove the spaces.

    /\N {SPACE}/x;	# Wrong!
    /\N{SPACE}/x;	# ok

a3275 21
=item Non-hex character in regex; marked by S<<-- HERE> in m/%s/

(F) In a regular expression, there was a non-hexadecimal character where
a hex one was expected, like

 (?[ [ \xDG ] ])
 (?[ [ \x{DEKA} ] ])

=item Non-octal character in regex; marked by S<<-- HERE> in m/%s/

(F) In a regular expression, there was a non-octal character where
an octal one was expected, like

 (?[ [ \o{1278} ] ])

=item Non-octal character '%c'.  Resolved as "%s"

(W digit) In parsing an octal numeric constant, a character was
unexpectedly encountered that isn't octal.  The resulting value
is as indicated.

a3280 6
=item Non-string passed as bitmask

(W misc) A number has been passed as a bitmask argument to select().
Use the vec() function to construct the file descriptor bitmasks for
select.  See L<perlfunc/select>.

a3313 5
=item No such class %s

(F) You provided a class qualifier in a "my", "our" or "state"
declaration, but this class doesn't exist at this point in your program.

d3321 5
a3407 7
=item (?[...]) not valid in locale in regex; marked by S<<-- HERE> in m/%s/

(F) C<(?[...])> cannot be used within the scope of a C<S<use locale>> or with
an C</l> regular expression modifier, as that would require deferring
to run-time the calculation of what it should evaluate to, and it is
regex compile-time only.

d3416 37
d3495 8
a3508 9
=item Odd name/value argument for subroutine

(F) A subroutine using a slurpy hash parameter in its signature
received an odd number of arguments to populate the hash.  It requires
the arguments to be paired, with the same number of keys as values.
The caller of the subroutine is presumably at fault.  Inconveniently,
this error will be reported at the location of the subroutine, not that
of the caller.

d3545 6
d3573 1
a3573 2
=item Operand with no preceding operator in regex; marked by S<<-- HERE> in
m/%s/
d3575 2
a3576 1
(F) You wrote something like
d3592 3
a3594 3
(S non_unicode) You performed an operation requiring Unicode semantics
on a code point that is not in Unicode, so what it should do is not
defined.  Perl has chosen to have it do nothing, and warn you.
d3604 6
a3609 6
(S surrogate) You performed an operation requiring Unicode
semantics on a Unicode surrogate.  Unicode frowns upon the use
of surrogates for anything but storing strings in UTF-16, but
semantics are (reluctantly) defined for the surrogates, and
they are to do nothing for this operation.  Because the use of
surrogates can be dangerous, Perl warns.
a3624 7
=item Optional parameter lacks default expression

(F) In a subroutine signature, you wrote something like "$a =", making a
named optional parameter without a default value.  A nameless optional
parameter is permitted to have no default value, but a named one must
have a specific default.  You probably want "$a = undef".

d3809 1
a3809 1
(F) A forked child returned an incomprehensible message about its errno.
d3837 1
a3837 2
(P) Something tried to allocate either more memory than possible or a
negative amount.
d3907 1
a3907 1
=item panic: Sequence (?{...}): no code block found in regex m/%s/
d3909 1
a3909 1
(P) While compiling a pattern that has embedded (?{}) or (??{}) code
a3912 6
=item panic: strxfrm() gets absurd - a => %u, ab => %u

(P) The interpreter's sanity check of the C function strxfrm() failed.
In your current locale the returned transformation of the string "ab"
is shorter than that of the string "a", which makes no sense.

d3923 6
d3980 2
a3981 1
=item Pattern subroutine nesting without pos change exceeded limit in regex
d3987 3
d4003 1
a4003 1
utility to report; in regex; marked by S<<-- HERE> in m/%s/
d4005 6
a4010 4
(S regexp) You used a regular expression with case-insensitive matching,
and there is a bug in Perl in which the built-in regular expression
folding rules are not accurate.  This may lead to incorrect results.
Please report this as a bug using the L<perlbug> utility.
d4028 1
a4028 1
=item Perl %s required--this is only %s, stopped
a4049 5
=item perl: warning: Non hex character in '$ENV{PERL_HASH_SEED}', seed only partially set

(S) PERL_HASH_SEED should match /^\s*(?:0x)?[0-9a-fA-F]+\s*\z/ but it
contained a non hex character.  This could mean you are not using the
hash seed you think you are.
d4073 6
d4081 2
a4082 2
(S) Perl was run with the environment variable PERL_PERTURB_KEYS defined
but containing an unexpected value.  The legal values of this setting
d4089 1
a4089 2
  2       | DETERMINISTIC | Enables repeatable key traversal
          |               | randomization
d4092 1
a4092 1
case sensitive.  The default for this setting is "RANDOM" or 1.
d4104 1
a4104 7
=item pop on reference is experimental

(S experimental::autoderef) C<pop> with a scalar argument is experimental
and may change or be removed in a future Perl version.  If you want to
take the risk of using this feature, simply disable this warning:

    no warnings "experimental::autoderef";
d4106 1
a4106 3
=item POSIX class [:%s:] unknown in regex; marked by S<< <-- HERE in m/%s/ >>

(F) The class in the character class [: :] syntax is unknown.  The S<<-- HERE>
d4118 1
a4118 1
S<<-- HERE> in m/%s/
d4124 1
a4124 1
will cause fatal errors.  The S<<-- HERE> shows whereabouts in the regular
d4128 1
a4128 1
S<<-- HERE> in m/%s/
d4134 1
a4134 1
and ".\]".  The S<<-- HERE> shows whereabouts in the regular expression the
d4138 1
a4138 1
S<<-- HERE> in m/%s/
d4144 1
a4144 1
and "=\]".  The S<<-- HERE> shows whereabouts in the regular expression the
a4198 22
=item Possible precedence issue with control flow operator

(W syntax) There is a possible problem with the mixing of a control
flow operator (e.g. C<return>) and a low-precedence operator like
C<or>.  Consider:

    sub { return $a or $b; }

This is parsed as:

    sub { (return $a) or $b; }

Which is effectively just:

    sub { return $a; }

Either use parentheses or the high-precedence variant of the operator.

Note this may be also triggered for constructs like:

    sub { 1 if die; }

a4231 15
=item Postfix dereference is experimental

(S experimental::postderef) This warning is emitted if you use
the experimental postfix dereference syntax.  Simply suppress the
warning if you want to use the feature, but know that in doing
so you are taking the risk of using an experimental feature which
may change or be removed in a future Perl version:

    no warnings "experimental::postderef";
    use feature "postderef", "postderef_qq";
    $ref->$*;
    $aref->@@*;
    $aref->@@[@@indices];
    ... etc ...

d4269 1
a4269 1
=item Property '%s' is unknown in regex; marked by S<<-- HERE> in m/%s/
d4271 2
a4272 1
(F) The named property which you specified via C<\p> or C<\P> is not one
d4275 2
a4276 2
for a complete list of available official
properties.  If it is a L<user-defined property|perlunicode/User-Defined Character Properties>
a4294 7
=item Prototype '%s' overridden by attribute 'prototype(%s)' in %s

(W prototype) A prototype was declared in both the parentheses after
the sub name and via the prototype attribute.  The prototype in
parentheses is useless, since it will be replaced by the prototype
from the attribute before it's ever used.

d4319 1
a4319 1
=item push on reference is experimental
d4321 2
a4322 5
(S experimental::autoderef) C<push> with a scalar argument is experimental
and may change or be removed in a future Perl version.  If you want to
take the risk of using this feature, simply disable this warning:

    no warnings "experimental::autoderef";
d4324 1
a4324 1
=item Quantifier follows nothing in regex; marked by S<< <-- HERE in m/%s/ >>
d4327 1
a4327 1
you meant it literally.  The S<<-- HERE> shows whereabouts in the regular
d4330 1
a4330 2
=item Quantifier in {,} bigger than %d in regex; marked by S<<-- HERE> in
m/%s/
d4333 1
a4333 1
the {min,max} construct.  The S<<-- HERE> shows whereabouts in the regular
a4335 8
=item Quantifier {n,m} with n > m can't match in regex

=item Quantifier {n,m} with n > m can't match in regex; marked by
S<<-- HERE> in m/%s/

(W regexp) Minima should be less than or equal to maxima.  If you really
want your regexp to match something 0 times, just put {0}.

d4348 5
d4432 1
a4432 1
=item Reference to invalid group 0 in regex; marked by S<<-- HERE> in m/%s/
d4439 1
a4439 2
=item Reference to nonexistent group in regex; marked by S<<-- HERE> in
m/%s/
d4449 1
a4449 2
=item Reference to nonexistent named group in regex; marked by S<<-- HERE>
in m/%s/
d4459 2
a4460 2
=item Reference to nonexistent or unclosed group in regex; marked by
S<<-- HERE> in m/%s/
d4476 1
a4476 2
=item Regexp modifier "%c" may appear a maximum of twice in regex; marked
by S<<-- HERE> in m/%s/
d4478 1
a4478 1
(F) The regular expression pattern had too many occurrences
a4488 8
=item Regexp modifier "/%c" may not appear twice

=item Regexp modifier "%c" may not appear twice in regex; marked by <--
HERE in m/%s/

(F) The regular expression pattern had too many occurrences
of the specified modifier.  Remove the extraneous ones.

d4491 1
a4491 4
=item Regexp modifiers "%c" and "%c" are mutually exclusive in regex;
marked by S<<-- HERE> in m/%s/

(F) The regular expression pattern had more than one of these
d4500 1
a4500 1
=item Repeated format line will never terminate (~~ and @@#)
d4528 2
a4529 2
(W io) The dirhandle you tried to do a rewinddir() on is either closed
or not really a dirhandle.  Check your control flow.
d4575 1
a4575 1
Note that since Perl 5.10.0 a // can also be the I<defined-or>
d4577 2
a4578 2
in Perl 5.10.0 or later that uses the // as the I<defined-or> can be
misparsed by pre-5.10.0 Perls as a non-terminated search pattern.
d4628 1
a4628 1
=item Sequence (? incomplete in regex; marked by S<<-- HERE> in m/%s/
d4631 1
a4631 1
S<<-- HERE> shows whereabouts in the regular expression the problem was
d4634 1
a4634 2
=item Sequence (?%c...) not implemented in regex; marked by S<<-- HERE> in
m/%s/
d4637 1
a4637 1
but has not yet been written.  The S<<-- HERE> shows whereabouts in the
d4640 1
a4640 2
=item Sequence (?%s...) not recognized in regex; marked by S<<-- HERE> in
m/%s/
d4642 3
a4644 3
(F) You used a regular expression extension that doesn't make sense.
The S<<-- HERE> shows whereabouts in the regular expression the problem was
discovered.  This may happen when using the C<(?^...)> construct to tell
d4649 5
a4659 28
=item Sequence (?&... not terminated in regex; marked by S<<-- HERE> in
m/%s/

(F) A named reference of the form C<(?&...)> was missing the final
closing parenthesis after the name.  The S<<-- HERE> shows whereabouts
in the regular expression the problem was discovered.

=item Sequence (?%c... not terminated in regex; marked by S<<-- HERE>
in m/%s/

(F) A named group of the form C<(?'...')> or C<< (?<...>) >> was missing the final
closing quote or angle bracket.  The S<<-- HERE> shows whereabouts in the
regular expression the problem was discovered.

=item Sequence (?(%c... not terminated in regex; marked by S<<-- HERE>
in m/%s/

(F) A named reference of the form C<(?('...')...)> or C<< (?(<...>)...) >> was
missing the final closing quote or angle bracket after the name.  The
S<<-- HERE> shows whereabouts in the regular expression the problem was
discovered.

=item Sequence \%s... not terminated in regex; marked by S<<-- HERE> in
m/%s/

(F) The regular expression expects a mandatory argument following the escape
sequence and this has been omitted or incorrectly written.

d4665 1
a4665 2
=item Sequence ?P=... not terminated in regex; marked by S<<-- HERE> in
m/%s/
d4667 1
a4667 3
(F) A named reference of the form C<(?P=...)> was missing the final
closing parenthesis after the name.  The S<<-- HERE> shows whereabouts
in the regular expression the problem was discovered.
d4669 1
a4669 6
=item Sequence (?R) not terminated in regex m/%s/

(F) An C<(?R)> or C<(?0)> sequence in a regular expression was missing the
final parenthesis.

=item Server error (a.k.a. "500 Server error")
a4728 32
=item Setting $/ to a reference to %s as a form of slurp is deprecated, treating as undef

(W deprecated) You assigned a reference to a scalar to C<$/> where the
referenced item is not a positive integer.  In older perls this B<appeared>
to work the same as setting it to C<undef> but was in fact internally
different, less efficient and with very bad luck could have resulted in
your file being split by a stringified form of the reference.

In Perl 5.20.0 this was changed so that it would be B<exactly> the same as
setting C<$/> to undef, with the exception that this warning would be
thrown.

You are recommended to change your code to set C<$/> to C<undef> explicitly
if you wish to slurp the file. In future versions of Perl assigning
a reference to will throw a fatal error.

=item Setting $/ to %s reference is forbidden

(F) You tried to assign a reference to a non integer to C<$/>.  In older
Perls this would have behaved similarly to setting it to a reference to
a positive integer, where the integer was the address of the reference.
As of Perl 5.20.0 this is a fatal error, to allow future versions of Perl
to use non-integer refs for more interesting purposes.

=item shift on reference is experimental

(S experimental::autoderef) C<shift> with a scalar argument is experimental
and may change or be removed in a future Perl version.  If you want to
take the risk of using this feature, simply disable this warning:

    no warnings "experimental::autoderef";

a4772 12
=item Slurpy parameter not last

(F) In a subroutine signature, you put something after a slurpy (array or
hash) parameter.  The slurpy parameter takes all the available arguments,
so there can't be any left to fill later parameters.

=item Smart matching a non-overloaded object breaks encapsulation

(F) You should not use the C<~~> operator on an object that does not
overload it: Perl refuses to use the object's underlying structure
for the smart match.

d4782 6
a4812 9
=item splice on reference is experimental

(S experimental::autoderef) C<splice> with a scalar argument
is experimental and may change or be removed in a future
Perl version.  If you want to take the risk of using this
feature, simply disable this warning:

    no warnings "experimental::autoderef";

d4827 6
a4840 6
=item "state" variable %s can't be in a package

(F) Lexically scoped variables aren't in a package, so it doesn't make
sense to try to declare one with a package qualifier on the front.  Use
local() if you want to localize a package variable.

a4845 6
=item Strings with code points over 0xFF may not be mapped into in-memory file handles

(W utf8) You tried to open a reference to a scalar for read or append
where the scalar contained code points over 0xFF.  In-memory files
model on-disk files and can only contain bytes.

d4857 3
a4859 3
subroutine may be declared in an outer anonymous subroutine that has
not yet been created.  (Remember that named subs are created at compile
time, while anonymous subs are created at run-time.)  For example,
d4863 1
a4863 1
At the time that f is created, it can't capture the current "a" sub,
d4870 2
a4871 2
The second situation is caused by an eval accessing a lexical subroutine
that has gone out of scope, for example,
a4930 5
=item SWASHNEW didn't return an HV ref

(P) Something went wrong internally when Perl was trying to look up
Unicode characters.

d4932 1
a4932 1
S<<-- HERE> in m/%s/
d4941 1
a4941 1
The S<<-- HERE> shows whereabouts in the regular expression the problem
d4944 1
a4944 15
=item Switch condition not recognized in regex; marked by S<<-- HERE> in
m/%s/

(F) The condition part of a (?(condition)if-clause|else-clause) construct
is not known.  The condition must be one of the following:

 (1) (2) ...        true if 1st, 2nd, etc., capture matched
 (<NAME>) ('NAME')  true if named capture matched
 (?=...) (?<=...)   true if subpattern matches
 (?!...) (?<!...)   true if subpattern fails to match
 (?{ CODE })        true if code returns a true value
 (R)                true if evaluating inside recursion
 (R1) (R2) ...      true if directly inside capture group 1, 2, etc.
 (R&NAME)           true if directly inside named capture
 (DEFINE)           always false; for defining named subpatterns
d4946 3
a4948 2
The <-- HERE shows whereabouts in the regular expression the problem was
discovered.  See L<perlre>.
d4955 4
a4991 9
=item Syntax error in (?[...]) in regex m/%s/

(F) Perl could not figure out what you meant inside this construct; this
notifies you that it is giving up trying.

=item %s syntax OK

(F) The final summary message when a C<perl -c> succeeds.

d5000 6
a5060 5
=item The %s function is unimplemented

(F) The function indicated isn't implemented on this architecture,
according to the probings of Configure.

d5085 12
a5096 1
=item The signatures feature is experimental
d5098 2
a5099 9
(S experimental::signatures) This warning is emitted if you unwrap a
subroutine's arguments using a signature.  Simply suppress the warning
if you want to use the feature, but know that in doing so you are taking
the risk of using an experimental feature which may change or be removed
in a future Perl version:

    no warnings "experimental::signatures";
    use feature "signatures";
    sub foo ($left, $right) { ... }
d5128 1
a5128 1
key traversal, but this Perl has been compiled without it.  You should
d5132 4
a5172 7
=item Too few arguments for subroutine

(F) A subroutine using a signature received fewer arguments than required
by the signature.  The caller of the subroutine is presumably at fault.
Inconveniently, this error will be reported at the location of the
subroutine, not that of the caller.

a5202 7
=item Too many arguments for subroutine

(F) A subroutine using a signature received more arguments than required
by the signature.  The caller of the subroutine is presumably at fault.
Inconveniently, this error will be reported at the location of the
subroutine, not that of the caller.

d5220 4
a5223 4
(D deprecated) You defined a character name which ended in a space
character.  Remove the trailing space(s).  Usually these names are
defined in the C<:alias> import argument to C<use charnames>, but they
could be defined by a translator installed into C<$^H{charnames}>.
d5343 1
a5343 2
=item Unexpected binary operator '%c' with no preceding operand in regex;
marked by S<<-- HERE> in m/%s/
d5345 24
a5368 1
(F) You had something like this:
d5375 1
a5375 1
=item Unexpected character in regex; marked by S<<-- HERE> in m/%s/
d5377 2
a5378 1
(F) You had something like this:
a5394 31
=item Unexpected exit %u

(S) exit() was called or the script otherwise finished gracefully when
C<PERL_EXIT_WARN> was set in C<PL_exit_flags>.

=item Unexpected exit failure %d

(S) An uncaught die() was called when C<PERL_EXIT_WARN> was set in
C<PL_exit_flags>.

=item Unexpected ')' in regex; marked by S<<-- HERE> in m/%s/

(F) You had something like this:

 (?[ ( \p{Digit} + ) ])

The C<")"> is out-of-place.  Something apparently was supposed to
be combined with the digits, or the C<"+"> shouldn't be there, or
something like that.  Perl can't figure out what was intended.

=item Unexpected '(' with no preceding operator in regex; marked by
S<<-- HERE> in m/%s/

(F) You had something like this:

 (?[ \p{Digit} ( \p{Lao} + \p{Thai} ) ])

There should be an operator before the C<"(">, as there's
no indication as to how the digits are to be combined
with the characters in the Lao and Thai scripts.

d5397 1
a5397 1
(S nonchar) Certain codepoints, such as U+FFFE and U+FFFF, are
d5400 1
a5400 3
shouldn't attempt to exchange them.  An application may not be
expecting any of these characters at all, and receiving them
may lead to bugs.  If you know what you are doing
a5402 4
This is not really a "serious" error, but it is supposed to be raised
by default even if warnings are not enabled, and currently the only
way to do that in Perl is to mark it as serious.

d5405 1
a5405 1
(S surrogate) You had a UTF-16 surrogate in a context where they are
d5414 5
d5456 4
d5475 1
a5475 6
=item Unknown "re" subpragma '%s' (known ones are: %s)

(W) You tried to use an unknown subpragma of the "re" pragma.

=item Unknown switch condition (?(...)) in regex; marked by S<<-- HERE> in
m/%s/
d5498 1
a5498 1
=item Unknown Unicode option value %d
d5503 1
a5503 1
=item Unknown verb pattern '%s' in regex; marked by S<<-- HERE> in m/%s/
d5518 1
a5518 1
=item Unmatched '[' in POSIX class in regex; marked by S<<-- HERE> in m/%s/
d5520 1
a5520 12
(F) You had something like this:

 (?[ [:digit: ])

That should be written:

 (?[ [:digit:] ])

=item Unmatched '%c' in POSIX class in regex; marked by S<<-- HERE> in
m/%s/

(F) You had something like this:
d5528 1
a5528 1
=item Unmatched [ in regex; marked by S<<-- HERE> in m/%s/
d5532 1
a5532 1
first.  The S<<-- HERE> shows whereabouts in the regular expression the
d5535 10
a5544 1
=item Unmatched ( in regex; marked by S<<-- HERE> in m/%s/
d5546 3
a5548 1
=item Unmatched ) in regex; marked by S<<-- HERE> in m/%s/
d5552 1
a5552 1
the matching parenthesis.  The S<<-- HERE> shows whereabouts in the
d5569 1
a5569 2
=item Unrecognized character %s; marked by S<<-- HERE> after %s near column
%d
d5572 9
a5580 10
in your Perl script (or eval) near the specified column.  Perhaps you
tried  to run a compressed script, a binary program, or a directory as
a Perl program.

=item Unrecognized escape \%c in character class in regex; marked by
S<<-- HERE> in m/%s/

(F) You used a backslash-character combination which is not
recognized by Perl inside character classes.  This is a fatal
error when the character class is used within C<(?[ ])>.
d5583 1
a5583 1
marked by S<<-- HERE> in m/%s/
d5588 1
a5588 1
The S<<-- HERE> shows whereabouts in the regular expression the
d5597 1
a5597 2
=item Unrecognized escape \%s passed through in regex; marked by
S<<-- HERE> in m/%s/
d5601 1
a5601 1
this may change in a future version of Perl.  The S<<-- HERE> shows
a5615 9
=item unshift on reference is experimental

(S experimental::autoderef) C<unshift> with a scalar argument
is experimental and may change or be removed in a future
Perl version.  If you want to take the risk of using this
feature, simply disable this warning:

    no warnings "experimental::autoderef";

d5681 1
a5681 3
=item Unterminated \g... pattern in regex; marked by S<<-- HERE> in m/%s/

=item Unterminated \g{...} pattern in regex; marked by S<<-- HERE> in m/%s/
d5683 2
a5684 4
(F) In a regular expression, you had a C<\g> that wasn't followed by a
proper group reference.  In the case of C<\g{>, the closing brace is
missing; otherwise the C<\g> must be followed by an integer.  Fix the
pattern and retry.
d5693 1
a5693 2
=item Unterminated verb pattern argument in regex; marked by S<<-- HERE> in
m/%s/
d5698 1
a5698 1
=item Unterminated verb pattern in regex; marked by S<<-- HERE> in m/%s/
d5729 18
a5746 1
=item Use "%s" instead of "%s"
d5748 3
a5750 2
(F) The second listed construct is no longer legal.  Use the first one
instead.
d5758 2
a5759 2
=item Useless (?-%s) - don't use /%s modifier in regex; marked by
S<<-- HERE> in m/%s/
d5779 1
a5779 2
=item Useless (?%s) - use /%s modifier in regex; marked by S<<-- HERE> in
m/%s/
d5818 1
a5818 1
delimited by C<{}>, C<[]>, or C<()>, which ordinarily are
a5828 11
=item Useless use of greediness modifier '%c' in regex; marked by S<<-- HERE> in m/%s/

(W regexp) You specified something like these:

 qr/a{3}?/
 qr/b{1,1}+/

The C<"?"> and C<"+"> don't have any effect, as they modify whether to
match more or fewer when there is a choice, and by specifying to match
exactly a given numer, there is no room left for a choice.

a5868 5
=item Useless use of (?-p) in regex; marked by S<<-- HERE> in m/%s/

(W regexp) The C<p> modifier cannot be turned off once set.  Trying to do
so is futile.

d5881 6
d5896 14
d5923 6
a5928 2
form if you wish to use an empty line as the terminator of the
here-document.
a5950 11
=item Use of comma-less variable list is deprecated

(D deprecated) The values you give to a format should be
separated by commas, not just aligned on a line.

=item Use of each() on hash after insertion without resetting hash iterator results in undefined behavior

(S internal) The behavior of C<each()> after insertion is undefined;
it may skip items, or visit items more than once.  Consider using
C<keys()> instead of C<each()>.

d6025 1
a6025 8
=item Use of literal control characters in variable names is deprecated

(D deprecated) Using literal control characters in the source to refer
to the ^FOO variables, like C<$^X> and C<${^GLOBAL_PHASE}> is now
deprecated.  This only affects code like C<$\cT>, where \cT is a control in
the source code: C<${"\cT"}> and C<$^T> remain valid.

=item Use of -l on filehandle%s
d6091 1
a6091 1
and the operation displayed in the warning may not necessarily appear
a6096 17
=item Use \x{...} for more than two hex characters in regex; marked by
S<<-- HERE> in m/%s/

(F) In a regular expression, you said something like

 (?[ [ \xBEEF ] ])

Perl isn't sure if you meant this

 (?[ [ \x{BEEF} ] ])

or if you meant this

 (?[ [ \x{BE} E F ] ])

You need to add either braces or blanks to disambiguate.

d6101 1
a6101 1
used to allow this syntax, but shouldn't have.  It is now
d6112 1
a6112 1
regex; marked by S<<-- HERE> in m/%s/
d6127 1
a6127 1
(S surrogate) You had a UTF-16 surrogate in a context where they are
a6151 9
=item values on reference is experimental

(S experimental::autoderef) C<values> with a scalar argument
is experimental and may change or be removed in a future
Perl version.  If you want to take the risk of using this
feature, simply disable this warning:

    no warnings "experimental::autoderef";

d6179 2
a6180 2
Here, when the '$a' in the eval is being compiled, f() is not currently
being executed, so its $a is not available for capture.
d6193 1
a6193 14
known at compile time.  For positive lookbehind, you can use the C<\K>
regex construct as a way to get the equivalent functionality.  See
L<perlre/(?<=pattern) \K>.

There are non-obvious Unicode rules under C</i> that can match variably,
but which you might not think could.  For example, the substring C<"ss">
can match the single character LATIN SMALL LETTER SHARP S.  There are
other sequences of ASCII characters that can match single ligature
characters, such as LATIN SMALL LIGATURE FFI matching C<qr/ffi/i>.
Starting in Perl v5.16, if you only care about ASCII matches, adding the
C</aa> modifier to the regex will exclude all these non-obvious matches,
thus getting rid of this message.  You can also say C<S<use re qw(/aa)>>
to apply C</aa> to all regular expressions compiled within its scope.
See L<re>.
d6231 2
a6232 2
=item Verb pattern '%s' has a mandatory argument in regex; marked by
S<<-- HERE> in m/%s/ 
d6237 2
a6238 2
=item Verb pattern '%s' may not have an argument in regex; marked by
S<<-- HERE> in m/%s/ 
d6289 2
a6290 2
even be removed in any future release of perl.  See the explanation
under L<perlsyn/Experimental Details on given and when>.
d6317 3
a6319 3
(S utf8) When reading in different encodings, Perl tries to
map everything into Unicode characters.  The bytes you read
in are not legal in this encoding.  For example
d6352 1
a6352 1
(F) When trying to initialize the random seed for hashes, Perl could
a6355 8
=item Zero length \N{} in regex; marked by S<<-- HERE> in m/%s/

(F) Named Unicode character escapes C<(\N{...})> may return a zero-length
sequence.  Such an escape was used in an extended character class, i.e.
C<(?[...])>, which is not permitted.  Check that the correct escape has
been used, and the correct charnames handler is in scope.  The S<<-- HERE>
shows whereabouts in the regular expression the problem was discovered.

d6360 1
a6360 1
L<warnings>, L<diagnostics>.
@


1.1.1.17
log
@Import perl-5.20.2
@
text
@a442 5
=item Bad symbol for scalar

(P) An internal request asked to add a scalar entry to something that
wasn't a symbol table entry.

a972 7
=item Can't locate object method "%s" via package "%s" (perhaps you forgot
to load "%s"?)

(F) You called a method on a class that did not exist, and the method
could not be found in UNIVERSAL.  This often means that a method
requires a package that has not been loaded.

d1394 3
a1396 4
non-printable characters.  You used it for a printable one, which
is better written as simply itself, perhaps preceded by a backslash
for non-word characters.  Doing it the way you did is not portable
between ASCII and EBCDIC platforms.
d2205 1
a2205 1
(W regexp) Named Unicode character escapes (C<\N{...}>) may return a
d2566 1
a2566 1
not valid character numbers, so it returns the Unicode replacement
a3084 2
=item Missing right brace on \N{}

d3308 1
a3308 1
(F) Named Unicode character escapes (C<\N{...}>) may return a
d4152 6
d6757 1
a6757 1
(F) Named Unicode character escapes (C<\N{...}>) may return a zero-length
@


1.1.1.18
log
@Import perl-5.24.2
@
text
@a52 13
=item Aliasing via reference is experimental

(S experimental::refaliasing) This warning is emitted if you use
a reference constructor on the left-hand side of an assignment to
alias one variable to another.  Simply suppress the warning if you
want to use the feature, but know that in doing so you are taking
the risk of using an experimental feature which may change or be
removed in a future Perl version:

    no warnings "experimental::refaliasing";
    use feature "refaliasing";
    \$x = \$y;

a61 5
=item alpha->numify() is lossy

(W numeric) An alpha version can not be numified without losing
information.

a178 5
Note that for the C<Inf> and C<NaN> (infinity and not-a-number) the
definition of "numeric" is somewhat unusual: the strings themselves
(like "Inf") are considered numeric, and anything following them is
considered non-numeric.

d189 1
a189 1
=item Argument "%s" treated as 0 in increment (++)
d191 2
a192 4
(W numeric) The indicated string was fed as an argument to the C<++>
operator which expects either a number or a string matching
C</^[a-zA-Z]*[0-9]*\z/>.  See L<perlop/Auto-increment and
Auto-decrement> for details.
d194 1
a194 1
=item Array passed to stat will be coerced to a scalar%s
d196 5
a200 2
(W syntax) You called stat() on an array, but the array will be
coerced to a scalar - the number of elements in the array.
a209 17
=item Assigned value is not a reference

(F) You tried to assign something that was not a reference to an lvalue
reference (e.g., C<\$x = $y>).  If you meant to make $x an alias to $y, use
C<\$x = \$y>.

=item Assigned value is not %s reference

(F) You tried to assign a reference to a reference constructor, but the
two references were not of the same type.  You cannot alias a scalar to
an array, or an array to a hash; the two types must match.

    \$x = \@@y;  # error
    \@@x = \%y;  # error
     $y = [];
    \$x = $y;   # error; did you mean \$y?

a220 32
=item Assuming NOT a POSIX class since %s in regex; marked by S<<-- HERE> in m/%s/

(W regexp) You had something like these:

 [[:alnum]]
 [[:digit:xyz]

They look like they might have been meant to be the POSIX classes
C<[:alnum:]> or C<[:digit:]>.  If so, they should be written:

 [[:alnum:]]
 [[:digit:]xyz]

Since these aren't legal POSIX class specifications, but are legal
bracketed character classes, Perl treats them as the latter.  In the
first example, it matches the characters C<":">, C<"[">, C<"a">, C<"l">,
C<"m">, C<"n">, and C<"u">.

If these weren't meant to be POSIX classes, this warning message is
spurious, and can be suppressed by reordering things, such as

 [[al:num]]

or

 [[:munla]]

=item <> at require-statement should be quotes

(F) You wrote C<< require <file> >> when you should have written
C<require 'file'>.

d514 12
a539 16
=item Both or neither range ends should be Unicode in regex; marked by
S<<-- HERE> in m/%s/

(W regexp) (only under C<S<use re 'strict'>> or within C<(?[...])>)

In a bracketed character class in a regular expression pattern, you
had a range which has exactly one end of it specified using C<\N{}>, and
the other end is specified using a non-portable mechanism.  Perl treats
the range as a Unicode range, that is, all the characters in it are
considered to be the Unicode characters, and which may be different code
points on some platforms Perl runs on.  For example, C<[\N{U+06}-\x08]>
is treated as if you had instead said C<[\N{U+06}-\N{U+08}]>, that is it
matches the characters whose code points in Unicode are 6, 7, and 8.
But that C<\x08> might indicate that you meant something different, so
the warning gets raised.

a566 9
=item Cannot chr %f

(F) You passed an invalid number (like an infinity or not-a-number) to C<chr>.

=item Cannot compress %f in pack

(F) You tried compressing an infinity or not-a-number as an unsigned
integer with BER, which makes no sense.

d569 3
a571 3
(F) An argument to pack("w",...) was too large to compress.
The BER compressed integer format can only be used with positive
integers, and you attempted to compress a very large number (> 1e308).
a595 10
=item Cannot pack %f with '%c'

(F) You tried converting an infinity or not-a-number to an integer,
which makes no sense.

=item Cannot printf %f with '%c'

(F) You tried printing an infinity or not-a-number as a character (%c),
which makes no sense.  Maybe you meant '%s', or just stringifying it?

a607 8
=item Cannot yet reorder sv_catpvfn() arguments from va_list

(F) Some XS code tried to use C<sv_catpvfn()> or a related function with a
format string that specifies explicit indexes for some of the elements, and
using a C-style variable-argument list (a C<va_list>). This is not currently
supported. XS authors wanting to do this must instead construct a C array of
C<SV*> scalars containing the arguments.

a734 27
=item Can't do %s("%s") on non-UTF-8 locale; resolved to "%s".

(W locale) You are 1) running under "C<use locale>"; 2) the current
locale is not a UTF-8 one; 3) you tried to do the designated case-change
operation on the specified Unicode character; and 4) the result of this
operation would mix Unicode and locale rules, which likely conflict.
Mixing of different rule types is forbidden, so the operation was not
done; instead the result is the indicated value, which is the best
available that uses entirely Unicode rules.  That turns out to almost
always be the original character, unchanged.

It is generally a bad idea to mix non-UTF-8 locales and Unicode, and
this issue is one of the reasons why.  This warning is raised when
Unicode rules would normally cause the result of this operation to
contain a character that is in the range specified by the locale,
0..255, and hence is subject to the locale's rules, not Unicode's.

If you are using locale purely for its characteristics related to things
like its numeric and time formatting (and not C<LC_CTYPE>), consider
using a restricted form of the locale pragma (see L<perllocale/The "use
locale" pragma>) like "S<C<use locale ':not_characters'>>".

Note that failed case-changing operations done as a result of
case-insensitive C</i> regular expression matching will show up in this
warning as having the C<fc> operation (as that is what the regular
expression engine calls behind the scenes.)

d779 7
d818 3
a820 4
=item Can't find Unicode property definition "%s" in regex; marked by <-- HERE in m/%s/

(F) The named property which you specified via C<\p> or C<\P> is not one
known to Perl.  Perhaps you misspelled the name?  See
d822 3
a824 8
for a complete list of available official
properties.  If it is a
L<user-defined property|perlunicode/User-Defined Character Properties>
it must have been defined by the time the regular expression is
matched.

If you didn't mean to use a Unicode property, escape the C<\p>, either
by C<\\p> (just the C<\p>) or by C<\Q\p> (the rest of the string, or
d1019 1
a1019 1
=item Can't modify non-lvalue subroutine call of &%s
a1023 22
=item Can't modify reference to %s in %s assignment

(F) Only a limited number of constructs can be used as the argument to a
reference constructor on the left-hand side of an assignment, and what
you used was not one of them.  See L<perlref/Assigning to References>.

=item Can't modify reference to localized parenthesized array in list
assignment

(F) Assigning to C<\local(@@array)> or C<\(local @@array)> is not supported, as
it is not clear exactly what it should do.  If you meant to make @@array
refer to some other array, use C<\@@array = \@@other_array>.  If you want to
make the elements of @@array aliases of the scalars referenced on the
right-hand side, use C<\(@@array) = @@scalar_refs>.

=item Can't modify reference to parenthesized hash in list assignment

(F) Assigning to C<\(%hash)> is not supported.  If you meant to make %hash
refer to some other hash, use C<\%hash = \%other_hash>.  If you want to
make the elements of %hash into aliases of the scalars referenced on the
right-hand side, use a hash slice: C<\@@hash{@@keys} = @@those_scalar_refs>.

d1038 6
a1111 5
=item Can't redeclare "%s" in "%s"

(F) A "my", "our" or "state" declaration was found within another declaration,
such as C<my ($x, my($y), $z)> or C<our (my $x)>.

a1136 7
=item Can't represent character for Ox%X on this platform

(F) There is a hard limit to how big a character code point can be due
to the fundamental properties of UTF-8, especially on EBCDIC
platforms.  The given code point exceeds that.  The only work-around is
to not use such a large code point.

a1204 14
=item Can't use a hash as a reference

(F) You tried to use a hash as a reference, as in
C<< %foo->{"bar"} >> or C<< %$ref->{"hello"} >>.  Versions of perl
<= 5.22.0 used to allow this syntax, but shouldn't
have.  This was deprecated in perl 5.6.1.

=item Can't use an array as a reference

(F) You tried to use an array as a reference, as in
C<< @@foo->[23] >> or C<< @@$ref->[99] >>.  Versions of perl <= 5.22.0
used to allow this syntax, but shouldn't have.  This
was deprecated in perl 5.6.1.

a1232 28
=item Can't use 'defined(@@array)' (Maybe you should just omit the defined()?)

(F) defined() is not useful on arrays because it
checks for an undefined I<scalar> value.  If you want to see if the
array is empty, just use C<if (@@array) { # not empty }> for example.

=item Can't use 'defined(%hash)' (Maybe you should just omit the defined()?)

(F) C<defined()> is not usually right on hashes.

Although C<defined %hash> is false on a plain not-yet-used hash, it
becomes true in several non-obvious circumstances, including iterators,
weak references, stash names, even remaining true after C<undef %hash>.
These things make C<defined %hash> fairly useless in practice, so it now
generates a fatal error.

If a check for non-empty is what you wanted then just put it in boolean
context (see L<perldata/Scalar values>):

    if (%hash) {
       # not empty
    }

If you had C<defined %Foo::Bar::QUUX> to check whether such a package
variable exists then that's never really been reliable, and isn't
a good way to enquire about the features of a package, or whether
it's loaded, etc.

d1235 2
a1236 1
(P) The parser got confused when trying to parse a C<foreach> loop.
d1314 6
a1319 1
(F) In C<\cI<X>>, I<X> must be a printable (non-control) ASCII character.
d1322 1
a1322 1
discouraged, and will generate the warning (when enabled)
a1324 7
=item Character following \%c must be '{' or a single-character Unicode property name in regex; marked by <-- HERE in m/%s/

(F) (In the above the C<%c> is replaced by either C<p> or C<P>.)  You
specified something that isn't a legal Unicode property name.  Most
Unicode properties are specified by C<\p{...}>.  But if the name is a
single character one, the braces may be omitted.

a1402 20
=item charnames alias definitions may not contain a sequence of multiple spaces

(F) You defined a character name which had multiple space characters
in a row.  Change them to single spaces.  Usually these names are
defined in the C<:alias> import argument to C<use charnames>, but they
could be defined by a translator installed into C<$^H{charnames}>.  See
L<charnames/CUSTOM ALIASES>.

=item charnames alias definitions may not contain trailing white-space

(F) You defined a character name which ended in a space
character.  Remove the trailing space(s).  Usually these names are
defined in the C<:alias> import argument to C<use charnames>, but they
could be defined by a translator installed into C<$^H{charnames}>.
See L<charnames/CUSTOM ALIASES>.

=item chdir() on unopened filehandle %s

(W unopened) You tried chdir() on a filehandle that was never opened.

a1429 9
=item \C no longer supported in regex; marked by S<<-- HERE> in m/%s/

(F) The \C character class used to allow a match of single byte
within a multi-byte utf-8 character, but was removed in v5.24 as
it broke encapsulation and its implementation was extremely buggy.
If you really need to process the individual bytes, you probably
want to convert your string to one where each underlying byte is
stored as a character, with utf8::encode().

a1434 19
=item Code point 0x%X is not Unicode, and not portable

(S non_unicode) You had a code point that has never been in any
standard, so it is likely that languages other than Perl will NOT
understand it.  At one time, it was legal in some standards to have code
points up to 0x7FFF_FFFF, but not higher, and this code point is higher.

Acceptance of these code points is a Perl extension, and you should
expect that nothing other than Perl can handle them; Perl itself on
EBCDIC platforms before v5.24 does not handle them.

Code points above 0xFFFF_FFFF require larger than a 32 bit word.

Perl also makes no guarantees that the representation of these code
points won't change at some point in the future, say when machines
become available that have larger than a 64-bit word.  At that time,
files written by an older Perl would require conversion before being
readable by a newer Perl.

d1440 6
a1445 11
Perl allows strings to contain a superset of Unicode code points, but
these may not be accepted by other languages/systems.  Further, even if
these languages/systems accept these large code points, they may have
chosen a different representation for them than the UTF-8-like one that
Perl has, which would mean files are not exchangeable between them and
Perl.

On EBCDIC platforms, code points above 0x3FFF_FFFF have a different
representation in Perl v5.24 than before, so any file containing these
that was written before that version will require conversion before
being readable by a later Perl.
d1450 2
a1451 2
instead of Perl.  Check the #! line, or manually feed your script into
Perl yourself.  The #! line at the top of your file could look like
a1498 36
=item Constants from lexical variables potentially modified elsewhere are
deprecated

(D deprecated) You wrote something like

    my $var;
    $sub = sub () { $var };

but $var is referenced elsewhere and could be modified after the C<sub>
expression is evaluated.  Either it is explicitly modified elsewhere
(C<$var = 3>) or it is passed to a subroutine or to an operator like
C<printf> or C<map>, which may or may not modify the variable.

Traditionally, Perl has captured the value of the variable at that
point and turned the subroutine into a constant eligible for inlining.
In those cases where the variable can be modified elsewhere, this
breaks the behavior of closures, in which the subroutine captures
the variable itself, rather than its value, so future changes to the
variable are reflected in the subroutine's return value.

This usage is deprecated, because the behavior is likely to change
in a future version of Perl.

If you intended for the subroutine to be eligible for inlining, then
make sure the variable is not referenced elsewhere, possibly by
copying it:

    my $var2 = $var;
    $sub = sub () { $var2 };

If you do want this subroutine to be a closure that reflects future
changes to the variable that it closes over, add an explicit C<return>:

    my $var;
    $sub = sub () { return $var };

d1516 1
a1516 14
forgot to load the corresponding L<overload> pragma?

=item :const is experimental

(S experimental::const_attr) The "const" attribute is experimental.
If you want to use the feature, disable the warning with C<no warnings
'experimental::const_attr'>, but know that in doing so you are taking
the risk that your code may break in a future Perl version.

=item :const is not permitted on named subroutines

(F) The "const" attribute causes an anonymous subroutine to be run and
its value captured at the time that it is cloned.  Named subroutines are
not cloned like this, so the attribute does not make sense on them.
d1579 29
d1615 1
a1615 1
The S<<-- HERE> shows whereabouts in the regular expression the problem was
d1770 8
a1784 2
=item Empty \%c in regex; marked by S<<-- HERE> in m/%s/

d1810 17
d1855 1
a1855 1
The S<<-- HERE> shows whereabouts in the regular expression the problem was
a1934 15
=item Experimental aliasing via reference not enabled

(F) To do aliasing via references, you must first enable the feature:

    no warnings "experimental::refaliasing";
    use feature "refaliasing";
    \$x = \$y;

=item Experimental %s on scalar is now forbidden

(F) An experimental feature added in Perl 5.14 allowed C<each>, C<keys>,
C<push>, C<pop>, C<shift>, C<splice>, C<unshift>, and C<values> to be called with a
scalar argument.  This experiment is considered unsuccessful, and
has been removed.  The C<postderef> feature may meet your needs better.

a1968 5
=item Failed to close in-place edit file %s: %s

(F) Closing an output file from in-place editing, as with the C<-i>
command-line switch, failed.

d2109 1
a2109 2
=item Global symbol "%s" requires explicit package name (did you forget to
declare "my %s"?)
d2192 5
a2201 40
=item Having more than one /%c regexp modifier is deprecated

(D deprecated, regexp) You used the indicated regular expression pattern
modifier at least twice in a string of modifiers.  It is deprecated to
do this with this particular modifier, to allow future extensions to the
Perl language.

=item Hexadecimal float: exponent overflow

(W overflow) The hexadecimal floating point has a larger exponent
than the floating point supports.

=item Hexadecimal float: exponent underflow

(W overflow) The hexadecimal floating point has a smaller exponent
than the floating point supports.

=item Hexadecimal float: internal error (%s)

(F) Something went horribly bad in hexadecimal float handling.

=item Hexadecimal float: mantissa overflow

(W overflow) The hexadecimal floating point literal had more bits in
the mantissa (the part between the 0x and the exponent, also known as
the fraction or the significand) than the floating point supports.

=item Hexadecimal float: precision loss

(W overflow) The hexadecimal floating point had internally more
digits than could be output.  This can be caused by unsupported
long double formats, or by 64-bit integers not being available
(needed to retrieve the digits under some configurations).

=item Hexadecimal float: unsupported long double format

(F) You have configured Perl to use long doubles but
the internals of the long double format are unknown;
therefore the hexadecimal float output is impossible.

d2219 3
a2221 3
zero-length sequence.  When such an escape is used in a character
class its behavior is not well defined.  Check that the correct
escape has been used, and the correct charname handler is in scope.
a2305 4
=item Illegal suidscript

(F) The script run under suidperl was somehow illegal.

a2310 9
=item Illegal user-defined property name

(F) You specified a Unicode-like property name in a regular expression
pattern (using C<\p{}> or C<\P{}>) that Perl knows isn't an official
Unicode property, and was likely meant to be a user-defined property
name, but it can't be one of those, as they must begin with either C<In>
or C<Is>.  Check the spelling.  See also
L</Can't find Unicode property definition "%s">.

d2350 6
d2424 11
a2508 8
=item In '(?...)', the '(' and '?' must be adjacent in regex;
marked by S<<-- HERE> in m/%s/

(F) The two-character sequence C<"(?"> in this context in a regular
expression pattern should be an indivisible token, with nothing
intervening between the C<"("> and the C<"?">, but you separated them
with whitespace.

a2581 5
=item Invalid number '%s' for -C option.

(F) You supplied a number to the -C option that either has extra leading
zeroes or overflows perl's unsigned integer representation.

a2587 7
=item Invalid quantifier in {,} in regex; marked by S<<-- HERE> in m/%s/

(F) The pattern looks like a {min,max} quantifier, but the min or max
could not be parsed as a valid number - either it has leading zeroes,
or it represents too big a number to cope with.  The S<<-- HERE> shows
where in the regular expression the problem was discovered.  See L<perlre>.

d2651 1
a2651 1
=item In '(*VERB...)', the '(' and '*' must be adjacent in regex;
d2654 1
a2654 1
(F) The two-character sequence C<"(*"> in
d2657 4
a2660 1
and the C<"*">, but you separated them.
a2682 34
=item '%s' is an unknown bound type in regex; marked by S<<-- HERE> in m/%s/

(F) You used C<\b{...}> or C<\B{...}> and the C<...> is not known to
Perl.  The current valid ones are given in
L<perlrebackslash/\b{}, \b, \B{}, \B>.

=item %s() is deprecated on :utf8 handles

(W deprecated) The sysread(), recv(), syswrite() and send() operators are
deprecated on handles that have the C<:utf8> layer, either explicitly, or
implicitly, eg., with the C<:encoding(UTF-16LE)> layer.

Both sysread() and recv() currently use only the C<:utf8> flag for the stream,
ignoring the actual layers.  Since sysread() and recv() do no UTF-8
validation they can end up creating invalidly encoded scalars.

Similarly, syswrite() and send() use only the C<:utf8> flag, otherwise ignoring
any layers.  If the flag is set, both write the value UTF-8 encoded, even if
the layer is some different encoding, such as the example above.

Ideally, all of these operators would completely ignore the C<:utf8> state,
working only with bytes, but this would result in silently breaking existing
code.  To avoid this a future version of perl will throw an exception when
any of sysread(), recv(), syswrite() or send() are called on handle with the
C<:utf8> layer.

=item "%s" is more clearly written simply as "%s" in regex; marked by S<<-- HERE> in m/%s/

(W regexp) (only under C<S<use re 'strict'>> or within C<(?[...])>)

You specified a character that has the given plainer way of writing it,
and which is also portable to platforms running with different character
sets.

d2726 8
a2800 38
=item %s: loadable library and perl binaries are mismatched (got handshake key %p, needed %p)

(P) A dynamic loading library C<.so> or C<.dll> was being loaded into the
process that was built against a different build of perl than the
said library was compiled against.  Reinstalling the XS module will
likely fix this error.

=item Locale '%s' may not work well.%s

(W locale) You are using the named locale, which is a non-UTF-8 one, and
which perl has determined is not fully compatible with what it can
handle.  The second C<%s> gives a reason.

By far the most common reason is that the locale has characters in it
that are represented by more than one byte.  The only such locales that
Perl can handle are the UTF-8 locales.  Most likely the specified locale
is a non-UTF-8 one for an East Asian language such as Chinese or
Japanese.  If the locale is a superset of ASCII, the ASCII portion of it
may work in Perl.

Some essentially obsolete locales that aren't supersets of ASCII, mainly
those in ISO 646 or other 7-bit locales, such as ASMO 449, can also have
problems, depending on what portions of the ASCII character set get
changed by the locale and are also used by the program.
The warning message lists the determinable conflicting characters.

Note that not all incompatibilities are found.

If this happens to you, there's not much you can do except switch to use a
different locale or use L<Encode> to translate from the locale into
UTF-8; if that's impracticable, you have been warned that some things
may break.

This message is output once each time a bad locale is switched into
within the scope of C<S<use locale>>, or on the first possibly-affected
operation if the C<S<use locale>> inherits a bad one.  It is not raised
for any operations from the L<POSIX> module.

d3036 2
a3037 7
(W missing) You called a function with fewer arguments than other
arguments you supplied indicated would be needed.

Currently only emitted when a printf-type format required more
arguments than were supplied, but might be used in the future for
other cases where we can statically determine that arguments to
functions are missing, e.g. for the L<perlfunc/pack> function.
a3093 6
=item Missing or undefined argument to require

(F) You tried to call require with no argument or with an undefined
value as an argument.  Require expects either a package name or a
file-specification as an argument.  See L<perlfunc/require>.

a3222 7
=item %s must not be a named sequence in transliteration operator

(F) Transliteration (C<tr///> and C<y///>) transliterates individual
characters.  But a named sequence by definition is more than an
individual charater, and hence doing this operation on it doesn't make
sense.

a3227 5
=item "my" subroutine %s can't be in a package

(F) Lexically scoped subroutines aren't in a package, so it doesn't make
sense to try to declare one with a package qualifier on the front.

d3249 4
a3252 4
NOTE: This warning detects package symbols that have been used
only once.  This means lexical variables will never trigger this
warning.  It also means that all of the package variables $c, @@c,
%c, as well as *c, &c, sub c{}, c(), and c (the filehandle or
a3291 6
=item Negative repeat count does nothing

(W numeric) You tried to execute the
L<C<x>|perlop/Multiplicative Operators> repetition operator fewer than 0
times, which doesn't make sense.

d3320 2
a3321 1
=item \N{} in inverted character class or as a range end-point is restricted to one character in regex; marked by <-- HERE in m/%s/
d3324 5
a3328 13
multi-character sequence.  Even though a character class is
supposed to match just one character of input, perl will match the
whole thing correctly, except when the class is inverted (C<[^...]>),
or the escape is the beginning or final end point of a range.  The
mathematically logical behavior for what matches when inverting
is very different from what people expect, so we have decided to
forbid it.  Similarly unclear is what should be generated when the
C<\N{...}> is used as one of the end points of the range, such as in

 [\x{41}-\N{ARABIC SEQUENCE YEH WITH HAMZA ABOVE WITH AE}]

What is meant here is unclear, as the C<\N{...}> escape is a sequence
of code points, so this is made an error.
a3368 8
=item NO-BREAK SPACE in a charnames alias definition is deprecated

(D deprecated) You defined a character name which contained a no-break
space character.  Change it to a regular space.  Usually these names are
defined in the C<:alias> import argument to C<use charnames>, but they
could be defined by a translator installed into C<$^H{charnames}>.  See
L<charnames/CUSTOM ALIASES>.

a3450 6
=item Non-finite repeat count does nothing

(W numeric) You tried to execute the
L<C<x>|perlop/Multiplicative Operators> repetition operator C<Inf> (or
C<-Inf>) or C<NaN> times, which doesn't make sense.

d3499 1
a3499 1
rules.  Such syntax is reserved for future extensions.
d3625 5
d3704 1
a3704 1
for I/O (in anticipation of future reads and to imitate the behavior
d3759 1
a3759 1
(S non_unicode) You performed an operation requiring Unicode rules
d3772 1
a3772 1
rules on a Unicode surrogate.  Unicode frowns upon the use
d3774 1
a3774 1
rules are (reluctantly) defined for the surrogates, and
d3937 5
d3957 1
a3957 1
=item panic: frexp: %f
d4026 1
a4026 2
(P) A zero scratch pad offset was detected internally.  An attempt was
made to free a target that had not been allocated to begin with.
d4035 1
a4035 3
(P) A zero scratch pad offset was detected internally.  Most likely
an operator needed a target but that target had not been allocated
for whatever reason.
d4167 1
a4167 6
=item Perl API version %s of %s does not match %s

(F) The XS module in question was compiled against a different incompatible
version of Perl than the one that has loaded the XS module.

=item Perl folding rules are not up-to-date for 0x%X; please use the perlbug
a4174 8
=item PerlIO layer ':win32' is experimental

(S experimental::win32_perlio) The C<:win32> PerlIO layer is
experimental.  If you want to take the risk of using this layer,
simply disable this warning:

    no warnings "experimental::win32_perlio";

d4267 9
a4275 1
=item POSIX class [:%s:] unknown in regex; marked by S<<-- HERE> in m/%s/
d4288 1
a4288 1
=item POSIX syntax [%c %c] belongs inside character classes%s in regex; marked by
d4291 3
a4293 11
(W regexp) Perl thinks that you intended to write a POSIX character
class, but didn't use enough brackets.  These POSIX class constructs [:
:], [= =], and [. .]  go I<inside> character classes, the [] are part of
the construct, for example: C<qr/[012[:alpha:]345]/>.  What the regular
expression pattern compiled to is probably not what you were intending.
For example, C<qr/[:alpha:]/> compiles to a regular bracketed character
class consisting of the four characters C<":">,  C<"a">,  C<"l">,
C<"h">, and C<"p">.  To specify the POSIX class, it should have been
written C<qr/[[:alpha:]]/>.

Note that [= =] and [. .] are not currently
a4297 3
If the specification of the class was not completely valid, the message
indicates that.

d4392 1
a4392 1
=item Possible precedence problem on bitwise %s operator
d4425 15
d4477 10
d4509 33
a4541 1
=item Quantifier follows nothing in regex; marked by S<<-- HERE> in m/%s/
d4547 2
a4548 1
=item Quantifier in {,} bigger than %d in regex; marked by S<<-- HERE> in m/%s/
d4562 2
a4563 1
=item Quantifier unexpected on zero-length expression in regex m/%s/
d4571 3
a4580 39
=item Ranges of ASCII printables should be some subset of "0-9", "A-Z", or
"a-z" in regex; marked by S<<-- HERE> in m/%s/

(W regexp) (only under C<S<use re 'strict'>> or within C<(?[...])>)

Stricter rules help to find typos and other errors.  Perhaps you didn't
even intend a range here, if the C<"-"> was meant to be some other
character, or should have been escaped (like C<"\-">).  If you did
intend a range, the one that was used is not portable between ASCII and
EBCDIC platforms, and doesn't have an obvious meaning to a casual
reader.

 [3-7]    # OK; Obvious and portable
 [d-g]    # OK; Obvious and portable
 [A-Y]    # OK; Obvious and portable
 [A-z]    # WRONG; Not portable; not clear what is meant
 [a-Z]    # WRONG; Not portable; not clear what is meant
 [%-.]    # WRONG; Not portable; not clear what is meant
 [\x41-Z] # WRONG; Not portable; not obvious to non-geek

(You can force portability by specifying a Unicode range, which means that
the endpoints are specified by
L<C<\N{...}>|perlrecharclass/Character Ranges>, but the meaning may
still not be obvious.)
The stricter rules require that ranges that start or stop with an ASCII
character that is not a control have all their endpoints be the literal
character, and not some escape sequence (like C<"\x41">), and the ranges
must be all digits, or all uppercase letters, or all lowercase letters.

=item Ranges of digits should be from the same group in regex; marked by
S<<-- HERE> in m/%s/

(W regexp) (only under C<S<use re 'strict'>> or within C<(?[...])>)

Stricter rules help to find typos and other errors.  You included a
range, and at least one of the end points is a decimal digit.  Under the
stricter rules, when this happens, both end points should be digits in
the same group of 10 consecutive digits.

a4626 7
=item Redundant argument in %s

(W redundant) You called a function with more arguments than other
arguments you supplied indicated would be needed.  Currently only
emitted when a printf-type format required fewer arguments than were
supplied, but might be used in the future for e.g. L<perlfunc/pack>.

d4668 1
a4668 1
The S<<-- HERE> shows whereabouts in the regular expression the problem was
d4679 1
a4679 1
The S<<-- HERE> shows whereabouts in the regular expression the problem was
d4689 1
a4689 1
The S<<-- HERE> shows whereabouts in the regular expression the problem was
d4815 10
a4862 8
=item Sequence "\c{" invalid

(F) These three characters may not appear in sequence in a
double-quotish context.  This message is raised only on non-ASCII
platforms (a different error message is output on ASCII ones).  If you
were intending to specify a control character with this sequence, you'll
have to use a different way to specify it.

a4913 7
=item Sequence (?... not terminated in regex; marked by S<<-- HERE> in
m/%s/

(F) There was no matching closing parenthesis for the '('.  The
S<<-- HERE> shows whereabouts in the regular expression the problem was
discovered.

a4924 12
=item Sequence (?PE<gt>... not terminated in regex; marked by S<<-- HERE> in m/%s/

(F) A named reference of the form C<(?PE<gt>...)> was missing the final
closing parenthesis after the name.  The S<<-- HERE> shows whereabouts
in the regular expression the problem was discovered.

=item Sequence (?PE<lt>... not terminated in regex; marked by S<<-- HERE> in m/%s/

(F) A named group of the form C<(?PE<lt>...E<gt>')> was missing the final
closing angle bracket.  The S<<-- HERE> shows whereabouts in the
regular expression the problem was discovered.

a4996 5
=item Setting ${^ENCODING} is deprecated

(D deprecated) You assigned a non-C<undef> value to C<${^ENCODING}>.
This is deprecated; see C<L<perlvar/${^ENCODING}>> for details.

d4999 1
a4999 1
(D deprecated) You assigned a reference to a scalar to C<$/> where the
d5021 8
d5039 5
d5099 5
d5119 9
a5141 5
=item "state" subroutine %s can't be in a package

(F) Lexically scoped subroutines aren't in a package, so it doesn't make
sense to try to declare one with a package qualifier on the front.

a5219 19
=item Subroutine "%s" will not stay shared

(W closure) An inner (nested) I<named> subroutine is referencing a "my"
subroutine defined in an outer named subroutine.

When the inner subroutine is called, it will see the value of the outer
subroutine's lexical subroutine as it was before and during the *first*
call to the outer subroutine; in this case, after the first call to the
outer subroutine is complete, the inner and outer subroutines will no
longer share a common value for the lexical subroutine.  In other words,
it will no longer be shared.  This will especially make a difference
if the lexical subroutines accesses lexical variables declared in its
surrounding scope.

This problem can usually be solved by making the inner subroutine
anonymous, using the C<sub {}> syntax.  When inner anonymous subs that
reference lexical subroutines in outer subroutines are created, they
are automatically rebound to the current values of such lexical subs.

d5286 1
a5286 1
The S<<-- HERE> shows whereabouts in the regular expression the problem was
a5288 7
=item Switch (?(condition)... not terminated in regex; marked by
S<<-- HERE> in m/%s/

(F) You omitted to close a (?(condition)...) block somewhere
in the pattern.  Add a closing parenthesis in the appropriate
position.  See L<perlre>.

a5390 12
=item The bitwise feature is experimental

(S experimental::bitwise) This warning is emitted if you use bitwise
operators (C<& | ^ ~ &. |. ^. ~.>) with the "bitwise" feature enabled.
Simply suppress the warning if you want to use the feature, but know
that in doing so you are taking the risk of using an experimental
feature which may change or be removed in a future Perl version:

    no warnings "experimental::bitwise";
    use feature "bitwise";
    $x |.= $y;

d5567 8
d5610 5
a5686 12
=item Unescaped left brace in regex is deprecated, passed through in regex;
marked by S<<-- HERE> in m/%s/

(D deprecated, regexp) You used a literal C<"{"> character in a regular
expression pattern.  You should change to use C<"\{"> instead, because a
future version of Perl (tentatively v5.26) will consider this to be a
syntax error.  If the pattern delimiters are also braces, any matching
right brace (C<"}">) should also be escaped to avoid confusing the parser,
for example,

    qr{abc\{def\}ghi}

d5752 1
a5752 1
=item Unicode non-character U+%X is not recommended for open interchange
d5755 10
a5764 10
defined by the Unicode standard to be non-characters.  Those
are legal codepoints, but are reserved for internal use; so,
applications shouldn't attempt to exchange them.  An application
may not be expecting any of these characters at all, and receiving
them may lead to bugs.  If you know what you are doing you can
turn off this warning by C<no warnings 'nonchar';>.

This is not really a "severe" error, but it is supposed to be
raised by default even if warnings are not enabled, and currently
the only way to do that in Perl is to mark it as serious.
a5776 6
=item Unknown charname '' is deprecated

(D deprecated) You had a C<\N{}> with nothing between the braces.  This
usage is deprecated, and will be made a syntax error in a future Perl
version.

d5849 1
a5849 1
The S<<-- HERE> shows whereabouts in the regular expression the problem was
d5877 21
d5978 9
d6128 1
a6128 1
The S<<-- HERE> shows whereabouts in the regular expression the problem was
d6149 1
a6149 1
The S<<-- HERE> shows whereabouts in the regular expression the problem was
a6151 7
=item Useless use of attribute "const"

(W misc) The C<const> attribute has no effect except
on anonymous closure prototypes.  You applied it to
a subroutine via L<attributes.pm|attributes>.  This is only useful
inside an attribute handler for an anonymous subroutine.

d6158 25
d6281 10
a6301 14
=item Use of code point 0x%s is deprecated; the permissible max is 0x%s

(D deprecated) You used a code point that will not be allowed in a
future perl version, because it is too large.  Unicode only allows code
points up to 0x10FFFF, but Perl allows much larger ones.  However, the
largest possible ones break the perl interpreter in some constructs,
including causing it to hang in a few cases.  The known problem areas
are in C<tr///>, regular expression pattern matching using quantifiers,
and as the upper limits in loops.

If your code is to run on various platforms, keep in mind that the upper
limit depends on the platform.  It is much larger on 64-bit word sizes
than 32-bit ones.

a6322 8
=item Use of %s for non-UTF-8 locale is wrong.  Assuming a UTF-8 locale

(W locale)  You are matching a regular expression using locale rules,
and the specified construct was encountered.  This construct is only
valid for UTF-8 locales, which the current locale isn't.  This doesn't
make sense.  Perl will continue, assuming a Unicode (UTF-8) locale, but
the results are likely to be wrong.

d6389 4
a6392 12
=item Use of literal non-graphic characters in variable names is deprecated

(D deprecated) Using literal non-graphic (including control)
characters in the source to refer to the ^FOO variables, like C<$^X> and
C<${^GLOBAL_PHASE}> is now deprecated.  (We use C<^X> and C<^G> here for
legibility.  They actually represent the non-printable control
characters, code points 0x18 and 0x07, respectively; C<^A> would mean
the control character whose code point is 0x01.) This only affects
code like C<$\cT>, where C<\cT> is a control in the source code; C<${"\cT"}> and
C<$^T> remain valid.  Things that are non-controls and also not graphic
are NO-BREAK SPACE and SOFT HYPHEN, which were previously only allowed
for historical reasons.
d6400 6
d6417 9
a6442 8
=item Use of strings with code points over 0xFF as arguments to %s
operator is deprecated

(D deprecated) You tried to use one of the string bitwise operators
(C<&> or C<|> or C<^> or C<~>) on a string containing a code point over
0xFF.  The string bitwise operators treat their operands as strings of
bytes, and values beyond 0xFF are nonsensical in this context.

a6465 8
=item "use re 'strict'" is experimental

(S experimental::re_strict) The things that are different when a regular
expression pattern is compiled under C<'strict'> are subject to change
in future Perl releases in incompatible ways.  This means that a pattern
that compiles today may not in a future Perl release.  This warning is
to alert you to that risk.

d6483 14
d6500 3
a6502 17
(W regexp) Named Unicode character escapes C<(\N{...})> may return
a multi-character sequence.  Even though a character class is
supposed to match just one character of input, perl will match
the whole thing correctly, except when the class is inverted
(C<[^...]>), or the escape is the beginning or final end point of
a range.  For these, what should happen isn't clear at all.  In
these circumstances, Perl discards all but the first character
of the returned sequence, which is not likely what you want.

=item Using /u for '%s' instead of /%s in regex; marked by S<<-- HERE> in m/%s/

(W regexp) You used a Unicode boundary (C<\b{...}> or C<\B{...}>) in a
portion of a regular expression where the character set modifiers C</a>
or C</aa> are in effect.  These two modifiers indicate an ASCII
interpretation, and this doesn't make sense for a Unicode defintion.
The generated regular expression will compile so that the boundary uses
all of Unicode.  No other portion of the regular expression is affected.
d6507 1
a6507 1
currently reserved for future use, as the exact behavior has not
d6538 9
a6672 20
=item Warning: unable to close filehandle properly: %s

=item Warning: unable to close filehandle %s properly: %s

(S io) There were errors during the implicit close() done on a filehandle
when its reference count reached zero while it was still open, e.g.:

    {
        open my $fh, '>', $file  or die "open: '$file': $!\n";
        print $fh $data or die "print: $!";
    } # implicit close here

Because various errors may only be detected by close() (e.g. buffering could
allow the C<print> in this example to return true even when the disk is full),
it is dangerous to ignore its result. So when it happens implicitly, perl will
signal errors by warning.

B<Prior to version 5.22.0, perl ignored such errors>, so the common idiom shown
above was liable to cause B<silent data loss>.

a6709 14
=item Wide character (U+%X) in %s

(W locale) While in a single-byte locale (I<i.e.>, a non-UTF-8
one), a multi-byte character was encountered.   Perl considers this
character to be the specified Unicode code point.  Combining non-UTF-8
locales and Unicode is dangerous.  Almost certainly some characters
will have two different representations.  For example, in the ISO 8859-7
(Greek) locale, the code point 0xC3 represents a Capital Gamma.  But so
also does 0x393.  This will make string comparisons unreliable.

You likely need to figure out how this multi-byte character got mixed up
with your single-byte locale (or perhaps you thought you had a UTF-8
locale, but Perl disagrees).

a6717 5
=item %s() with negative argument

(S misc) Certain operations make no sense with negative arguments.
Warning is given and the operation is not done.

d6768 3
a6770 4
C<(?[...])>, or under C<use re 'strict'>, which is not permitted.  Check
that the correct escape has been used, and the correct charnames handler
is in scope.  The S<<-- HERE> shows whereabouts in the regular
expression the problem was discovered.
@


