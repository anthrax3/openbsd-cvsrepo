head	1.10;
access;
symbols
	OPENBSD_6_0:1.10.0.10
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.4
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.6
	OPENBSD_5_8_BASE:1.10
	PERL_5_20_2:1.1.1.9
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	PERL_5_20_1:1.1.1.9
	OPENBSD_5_6:1.9.0.4
	OPENBSD_5_6_BASE:1.9
	PERL_5_18_2:1.1.1.8
	PERL:1.1.1
	OPENBSD_5_5:1.8.0.6
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	PERL_5_16_3:1.1.1.7
	OPENBSD_5_3:1.7.0.14
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.12
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.10
	OPENBSD_5_0:1.7.0.8
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.6
	OPENBSD_4_9_BASE:1.7
	PERL_5_12_2:1.1.1.6
	OPENBSD_4_8:1.7.0.4
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	PERL_5_10_1:1.1.1.6
	OPENBSD_4_6:1.6.0.16
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.12
	OPENBSD_4_5_BASE:1.6
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.6.0.10
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.8
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.6
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.4
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.5.0.8
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.6
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.4
	OPENBSD_3_7_BASE:1.5
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.3
	OPENBSD_3_5:1.4.0.6
	OPENBSD_3_5_BASE:1.4
	PERL_5_8_2:1.1.1.3
	OPENBSD_3_4:1.4.0.4
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.2
	OPENBSD_3_3_BASE:1.4
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.3.0.14
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.12
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.10
	OPENBSD_3_0_BASE:1.3
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.3.0.8
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.6
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.4
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.10
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.9;
commitid	QP75iYx42Uo7mMxO;

1.9
date	2014.03.24.15.05.33;	author afresh1;	state Exp;
branches;
next	1.8;

1.8
date	2013.03.25.20.40.58;	author sthen;	state Exp;
branches;
next	1.7;

1.7
date	2009.10.12.18.24.47;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2006.03.28.19.23.10;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.09.18.10.15;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.10.27.22.25.33;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.12;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.59.13;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.59;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.59;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.40.45;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.27.22.15.05;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.08.09.17.48.13;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.03.28.18.49.19;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2009.10.12.18.10.40;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2013.03.25.20.09.19;	author sthen;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2014.03.24.14.59.07;	author afresh1;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2014.11.17.20.53.13;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.10
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@=head1 NAME
X<format> X<report> X<chart>

perlform - Perl formats

=head1 DESCRIPTION

Perl has a mechanism to help you generate simple reports and charts.  To
facilitate this, Perl helps you code up your output page close to how it
will look when it's printed.  It can keep track of things like how many
lines are on a page, what page you're on, when to print page headers,
etc.  Keywords are borrowed from FORTRAN: format() to declare and write()
to execute; see their entries in L<perlfunc>.  Fortunately, the layout is
much more legible, more like BASIC's PRINT USING statement.  Think of it
as a poor man's nroff(1).
X<nroff>

Formats, like packages and subroutines, are declared rather than
executed, so they may occur at any point in your program.  (Usually it's
best to keep them all together though.) They have their own namespace
apart from all the other "types" in Perl.  This means that if you have a
function named "Foo", it is not the same thing as having a format named
"Foo".  However, the default name for the format associated with a given
filehandle is the same as the name of the filehandle.  Thus, the default
format for STDOUT is named "STDOUT", and the default format for filehandle
TEMP is named "TEMP".  They just look the same.  They aren't.

Output record formats are declared as follows:

    format NAME =
    FORMLIST
    .

If the name is omitted, format "STDOUT" is defined. A single "." in 
column 1 is used to terminate a format.  FORMLIST consists of a sequence 
of lines, each of which may be one of three types:

=over 4

=item 1.

A comment, indicated by putting a '#' in the first column.

=item 2.

A "picture" line giving the format for one output line.

=item 3.

An argument line supplying values to plug into the previous picture line.

=back

Picture lines contain output field definitions, intermingled with
literal text. These lines do not undergo any kind of variable interpolation.
Field definitions are made up from a set of characters, for starting and
extending a field to its desired width. This is the complete set of
characters for field definitions:
X<format, picture line>
X<@@> X<^> X<< < >> X<< | >> X<< > >> X<#> X<0> X<.> X<...>
X<@@*> X<^*> X<~> X<~~>

   @@    start of regular field
   ^    start of special field
   <    pad character for left justification
   |    pad character for centering
   >    pad character for right justification
   #    pad character for a right-justified numeric field
   0    instead of first #: pad number with leading zeroes
   .    decimal point within a numeric field
   ...  terminate a text field, show "..." as truncation evidence
   @@*   variable width field for a multi-line value
   ^*   variable width field for next line of a multi-line value
   ~    suppress line with all fields empty
   ~~   repeat line until all fields are exhausted

Each field in a picture line starts with either "@@" (at) or "^" (caret),
indicating what we'll call, respectively, a "regular" or "special" field.
The choice of pad characters determines whether a field is textual or
numeric. The tilde operators are not part of a field.  Let's look at
the various possibilities in detail.


=head2 Text Fields
X<format, text field>

The length of the field is supplied by padding out the field with multiple 
"E<lt>", "E<gt>", or "|" characters to specify a non-numeric field with,
respectively, left justification, right justification, or centering. 
For a regular field, the value (up to the first newline) is taken and
printed according to the selected justification, truncating excess characters.
If you terminate a text field with "...", three dots will be shown if
the value is truncated. A special text field may be used to do rudimentary 
multi-line text block filling; see L</Using Fill Mode> for details.

   Example:
      format STDOUT =
      @@<<<<<<   @@||||||   @@>>>>>>
      "left",   "middle", "right"
      .
   Output:
      left      middle    right


=head2 Numeric Fields
X<#> X<format, numeric field>

Using "#" as a padding character specifies a numeric field, with
right justification. An optional "." defines the position of the
decimal point. With a "0" (zero) instead of the first "#", the
formatted number will be padded with leading zeroes if necessary.
A special numeric field is blanked out if the value is undefined.
If the resulting value would exceed the width specified the field is
filled with "#" as overflow evidence.

   Example:
      format STDOUT =
      @@###   @@.###   @@##.###  @@###   @@###   ^####
       42,   3.1415,  undef,    0, 10000,   undef
      .
   Output:
        42   3.142     0.000     0   ####


=head2 The Field @@* for Variable-Width Multi-Line Text
X<@@*>

The field "@@*" can be used for printing multi-line, nontruncated
values; it should (but need not) appear by itself on a line. A final
line feed is chomped off, but all other characters are emitted verbatim.


=head2 The Field ^* for Variable-Width One-line-at-a-time Text
X<^*>

Like "@@*", this is a variable-width field. The value supplied must be a 
scalar variable. Perl puts the first line (up to the first "\n") of the 
text into the field, and then chops off the front of the string so that 
the next time the variable is referenced, more of the text can be printed. 
The variable will I<not> be restored.

   Example:
      $text = "line 1\nline 2\nline 3";
      format STDOUT =
      Text: ^*
            $text
      ~~    ^*
            $text
      .
   Output:
      Text: line 1
            line 2
            line 3


=head2 Specifying Values
X<format, specifying values>

The values are specified on the following format line in the same order as
the picture fields.  The expressions providing the values must be
separated by commas.  They are all evaluated in a list context
before the line is processed, so a single list expression could produce
multiple list elements.  The expressions may be spread out to more than
one line if enclosed in braces.  If so, the opening brace must be the first
token on the first line.  If an expression evaluates to a number with a
decimal part, and if the corresponding picture specifies that the decimal
part should appear in the output (that is, any picture except multiple "#"
characters B<without> an embedded "."), the character used for the decimal
point is determined by the current LC_NUMERIC locale if C<use locale> is in
effect.  This means that, if, for example, the run-time environment happens
to specify a German locale, "," will be used instead of the default ".".  See
L<perllocale> and L<"WARNINGS"> for more information.


=head2 Using Fill Mode
X<format, fill mode>

On text fields the caret enables a kind of fill mode.  Instead of an
arbitrary expression, the value supplied must be a scalar variable
that contains a text string.  Perl puts the next portion of the text into
the field, and then chops off the front of the string so that the next time
the variable is referenced, more of the text can be printed.  (Yes, this
means that the variable itself is altered during execution of the write()
call, and is not restored.)  The next portion of text is determined by
a crude line-breaking algorithm. You may use the carriage return character
(C<\r>) to force a line break. You can change which characters are legal 
to break on by changing the variable C<$:> (that's 
$FORMAT_LINE_BREAK_CHARACTERS if you're using the English module) to a 
list of the desired characters.

Normally you would use a sequence of fields in a vertical stack associated 
with the same scalar variable to print out a block of text. You might wish 
to end the final field with the text "...", which will appear in the output 
if the text was too long to appear in its entirety.  


=head2 Suppressing Lines Where All Fields Are Void
X<format, suppressing lines>

Using caret fields can produce lines where all fields are blank. You can
suppress such lines by putting a "~" (tilde) character anywhere in the
line.  The tilde will be translated to a space upon output.


=head2 Repeating Format Lines
X<format, repeating lines>

If you put two contiguous tilde characters "~~" anywhere into a line,
the line will be repeated until all the fields on the line are exhausted,
i.e. undefined. For special (caret) text fields this will occur sooner or
later, but if you use a text field of the at variety, the  expression you
supply had better not give the same value every time forever! (C<shift(@@f)>
is a simple example that would work.)  Don't use a regular (at) numeric 
field in such lines, because it will never go blank.


=head2 Top of Form Processing
X<format, top of form> X<top> X<header>

Top-of-form processing is by default handled by a format with the
same name as the current filehandle with "_TOP" concatenated to it.
It's triggered at the top of each page.  See L<perlfunc/write>.

Examples:

 # a report on the /etc/passwd file
 format STDOUT_TOP =
                         Passwd File
 Name                Login    Office   Uid   Gid Home
 ------------------------------------------------------------------
 .
 format STDOUT =
 @@<<<<<<<<<<<<<<<<<< @@||||||| @@<<<<<<@@>>>> @@>>>> @@<<<<<<<<<<<<<<<<<
 $name,              $login,  $office,$uid,$gid, $home
 .


 # a report from a bug report form
 format STDOUT_TOP =
                         Bug Reports
 @@<<<<<<<<<<<<<<<<<<<<<<<     @@|||         @@>>>>>>>>>>>>>>>>>>>>>>>
 $system,                      $%,         $date
 ------------------------------------------------------------------
 .
 format STDOUT =
 Subject: @@<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
          $subject
 Index: @@<<<<<<<<<<<<<<<<<<<<<<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        $index,                       $description
 Priority: @@<<<<<<<<<< Date: @@<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
           $priority,        $date,   $description
 From: @@<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
       $from,                         $description
 Assigned to: @@<<<<<<<<<<<<<<<<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
              $programmer,            $description
 ~                                    ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                                      $description
 ~                                    ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                                      $description
 ~                                    ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                                      $description
 ~                                    ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                                      $description
 ~                                    ^<<<<<<<<<<<<<<<<<<<<<<<...
                                      $description
 .

It is possible to intermix print()s with write()s on the same output
channel, but you'll have to handle C<$-> (C<$FORMAT_LINES_LEFT>)
yourself.

=head2 Format Variables
X<format variables>
X<format, variables>

The current format name is stored in the variable C<$~> (C<$FORMAT_NAME>),
and the current top of form format name is in C<$^> (C<$FORMAT_TOP_NAME>).
The current output page number is stored in C<$%> (C<$FORMAT_PAGE_NUMBER>),
and the number of lines on the page is in C<$=> (C<$FORMAT_LINES_PER_PAGE>).
Whether to autoflush output on this handle is stored in C<$|>
(C<$OUTPUT_AUTOFLUSH>).  The string output before each top of page (except
the first) is stored in C<$^L> (C<$FORMAT_FORMFEED>).  These variables are
set on a per-filehandle basis, so you'll need to select() into a different
one to affect them:

    select((select(OUTF),
	    $~ = "My_Other_Format",
	    $^ = "My_Top_Format"
	   )[0]);

Pretty ugly, eh?  It's a common idiom though, so don't be too surprised
when you see it.  You can at least use a temporary variable to hold
the previous filehandle: (this is a much better approach in general,
because not only does legibility improve, you now have an intermediary
stage in the expression to single-step the debugger through):

    $ofh = select(OUTF);
    $~ = "My_Other_Format";
    $^ = "My_Top_Format";
    select($ofh);

If you use the English module, you can even read the variable names:

    use English;
    $ofh = select(OUTF);
    $FORMAT_NAME     = "My_Other_Format";
    $FORMAT_TOP_NAME = "My_Top_Format";
    select($ofh);

But you still have those funny select()s.  So just use the FileHandle
module.  Now, you can access these special variables using lowercase
method names instead:

    use FileHandle;
    format_name     OUTF "My_Other_Format";
    format_top_name OUTF "My_Top_Format";

Much better!

=head1 NOTES

Because the values line may contain arbitrary expressions (for at fields,
not caret fields), you can farm out more sophisticated processing
to other functions, like sprintf() or one of your own.  For example:

    format Ident =
	@@<<<<<<<<<<<<<<<
	&commify($n)
    .

To get a real at or caret into the field, do this:

    format Ident =
    I have an @@ here.
	    "@@"
    .

To center a whole line of text, do something like this:

    format Ident =
    @@|||||||||||||||||||||||||||||||||||||||||||||||
	    "Some text line"
    .

There is no builtin way to say "float this to the right hand side
of the page, however wide it is."  You have to specify where it goes.
The truly desperate can generate their own format on the fly, based
on the current number of columns, and then eval() it:

    $format  = "format STDOUT = \n"
             . '^' . '<' x $cols . "\n"
             . '$entry' . "\n"
             . "\t^" . "<" x ($cols-8) . "~~\n"
             . '$entry' . "\n"
             . ".\n";
    print $format if $Debugging;
    eval $format;
    die $@@ if $@@;

Which would generate a format looking something like this:

 format STDOUT =
 ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 $entry
         ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~~
 $entry
 .

Here's a little program that's somewhat like fmt(1):

 format =
 ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ~~
 $_

 .

 $/ = '';
 while (<>) {
     s/\s*\n\s*/ /g;
     write;
 }

=head2 Footers
X<format, footer> X<footer>

While $FORMAT_TOP_NAME contains the name of the current header format,
there is no corresponding mechanism to automatically do the same thing
for a footer.  Not knowing how big a format is going to be until you
evaluate it is one of the major problems.  It's on the TODO list.

Here's one strategy:  If you have a fixed-size footer, you can get footers
by checking $FORMAT_LINES_LEFT before each write() and print the footer
yourself if necessary.

Here's another strategy: Open a pipe to yourself, using C<open(MYSELF, "|-")>
(see L<perlfunc/open>) and always write() to MYSELF instead of STDOUT.
Have your child process massage its STDIN to rearrange headers and footers
however you like.  Not very convenient, but doable.

=head2 Accessing Formatting Internals
X<format, internals>

For low-level access to the formatting mechanism, you may use formline()
and access C<$^A> (the $ACCUMULATOR variable) directly.

For example:

    $str = formline <<'END', 1,2,3;
    @@<<<  @@|||  @@>>>
    END

    print "Wow, I just stored '$^A' in the accumulator!\n";

Or to make an swrite() subroutine, which is to write() what sprintf()
is to printf(), do this:

    use Carp;
    sub swrite {
	croak "usage: swrite PICTURE ARGS" unless @@_;
	my $format = shift;
	$^A = "";
	formline($format,@@_);
	return $^A;
    }

    $string = swrite(<<'END', 1, 2, 3);
 Check me out
 @@<<<  @@|||  @@>>>
 END
    print $string;

=head1 WARNINGS

The lone dot that ends a format can also prematurely end a mail
message passing through a misconfigured Internet mailer (and based on
experience, such misconfiguration is the rule, not the exception).  So
when sending format code through mail, you should indent it so that
the format-ending dot is not on the left margin; this will prevent
SMTP cutoff.

Lexical variables (declared with "my") are not visible within a
format unless the format is declared within the scope of the lexical
variable.

If a program's environment specifies an LC_NUMERIC locale and C<use
locale> is in effect when the format is declared, the locale is used
to specify the decimal point character in formatted output.  Formatted
output cannot be controlled by C<use locale> at the time when write()
is called. See L<perllocale> for further discussion of locale handling.

Within strings that are to be displayed in a fixed-length text field,
each control character is substituted by a space. (But remember the
special meaning of C<\r> when using fill mode.) This is done to avoid
misalignment when control characters "disappear" on some output media.

@


1.9
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d304 1
a304 1
    use English '-no_match_vars';
@


1.8
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d403 1
a403 1
For low-level access to the formatting mechanism.  you may use formline()
d443 1
a443 1
variable.  (They weren't visible at all before version 5.001.)
@


1.7
log
@Merge in perl 5.10.1
@
text
@d68 1
a68 1
   #    pad character for a right justified numeric field
d125 1
a125 1
=head2 The Field @@* for Variable Width Multi-Line Text
d133 1
a133 1
=head2 The Field ^* for Variable Width One-line-at-a-time Text
d136 1
a136 1
Like "@@*", this is a variable width field. The value supplied must be a 
d169 3
a171 3
point is B<always> determined by the current LC_NUMERIC locale.  This
means that, if, for example, the run-time environment happens to specify a
German locale, "," will be used instead of the default ".".  See
d185 1
a185 1
a crude line breaking algorithm. You may use the carriage return character
d294 1
a294 1
because not only does legibility improve, you now have intermediary
d396 1
a396 1
(see L<perlfunc/open()>) and always write() to MYSELF instead of STDOUT.
d412 1
a412 1
    print "Wow, I just stored `$^A' in the accumulator!\n";
d445 5
a449 9
Formats are the only part of Perl that unconditionally use information
from a program's locale; if a program's environment specifies an
LC_NUMERIC locale, it is always used to specify the decimal point
character in formatted output.  Perl ignores all other aspects of locale
handling unless the C<use locale> pragma is in effect.  Formatted output
cannot be controlled by C<use locale> because the pragma is tied to the
block structure of the program, and, for historical reasons, formats
exist outside that block structure.  See L<perllocale> for further
discussion of locale handling.
d451 1
a451 1
Within strings that are to be displayed in a fixed length text field,
@


1.6
log
@merge in perl 5.8.8
@
text
@d62 1
a62 1
  
d65 1
a65 1
   <    pad character for left adjustification
d67 1
a67 1
   >    pad character for right adjustificat
@


1.5
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d2 1
d16 1
d59 3
d85 1
d106 1
d126 1
d134 1
d157 1
d176 1
d198 1
d206 1
d218 1
d273 2
d384 1
d401 1
@


1.4
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d32 3
a34 2
If name is omitted, format "STDOUT" is defined.  FORMLIST consists of
a sequence of lines, each of which may be one of three types:
d52 100
a151 23
Picture lines are printed exactly as they look, except for certain fields
that substitute values into the line.  Each field in a picture line starts
with either "@@" (at) or "^" (caret).  These lines do not undergo any kind
of variable interpolation.  The at field (not to be confused with the array
marker @@) is the normal kind of field; the other kind, caret fields, are used
to do rudimentary multi-line text block filling.  The length of the field
is supplied by padding out the field with multiple "E<lt>", "E<gt>", or "|"
characters to specify, respectively, left justification, right
justification, or centering.  If the variable would exceed the width
specified, it is truncated.

As an alternate form of right justification, you may also use "#"
characters (with an optional ".") to specify a numeric field. This way
you can line up the decimal points. With a "0" (zero) instead of the
first "#", the formatted number will be padded with leading zeroes if
necessary. If any value supplied for these fields contains a newline,
only the text up to the newline is printed. Finally, the special field
"@@*" can be used for printing multi-line, nontruncated values; it
should appear by itself on a line.

The values are specified on the following line in the same order as
the picture fields.  The expressions providing the values should be
separated by commas.  The expressions are all evaluated in a list context
d164 7
a170 6
Picture fields that begin with ^ rather than @@ are treated specially.
With a # field, the field is blanked out if the value is undefined.  For
other field types, the caret enables a kind of fill mode.  Instead of an
arbitrary expression, the value supplied must be a scalar variable name
that contains a text string.  Perl puts as much text as it can into the
field, and then chops off the front of the string so that the next time
d173 5
a177 6
call, and is not returned.)  Normally you would use a sequence of fields
in a vertical stack to print out a block of text.  You might wish to end
the final field with the text "...", which will appear in the output if
the text was too long to appear in its entirety.  You can change which
characters are legal to break on by changing the variable C<$:> (that's
$FORMAT_LINE_BREAK_CHARACTERS if you're using the English module) to a
d180 25
a204 7
Using caret fields can produce variable length records.  If the text
to be formatted is short, you can suppress blank lines by putting a
"~" (tilde) character anywhere in the line.  The tilde will be translated
to a space upon output.  If you put a second tilde contiguous to the
first, the line will be repeated until all the fields on the line are
exhausted.  (If you use a field of the at variety, the expression you
supply had better not give the same value every time forever!)
d437 4
a440 5
Inside of an expression, the whitespace characters \n, \t and \f are
considered to be equivalent to a single space.  Thus, you could think
of this filter being applied to each value in the format:

 $value =~ tr/\n\t\f/ /;
a441 2
The remaining whitespace character, \r, forces the printing of a new
line if allowed by the picture line.
@


1.3
log
@perl5.005_03 (stock)
@
text
@d63 7
a69 5
characters (with an optional ".") to specify a numeric field.  This way
you can line up the decimal points.  If any value supplied for these
fields contains a newline, only the text up to the newline is printed.
Finally, the special field "@@*" can be used for printing multi-line,
nontruncated values; it should appear by itself on a line.
d192 1
a192 1
    use English;
@


1.2
log
@perl 5.004_04
@
text
@d23 2
a24 2
format for STDOUT is name "STDOUT", and the default format for filehandle
TEMP is name "TEMP".  They just look the same.  They aren't.
d236 5
a240 5
    $format  = "format STDOUT = \n";
             . '^' . '<' x $cols . "\n";
             . '$entry' . "\n";
             . "\t^" . "<" x ($cols-8) . "~~\n";
             . '$entry' . "\n";
d298 1
a298 1
Or to make an swrite() subroutine which is to write() what sprintf()
d318 1
a318 1
The lone dot that ends a format can also prematurely end an email
d321 1
a321 1
when sending format code through email, you should indent it so that
d323 1
a323 1
email cutoff.
d329 1
a329 1
Formats are the only part of Perl which unconditionally use information
d338 9
@


1.1
log
@Initial revision
@
text
@d8 14
a21 14
facilitate this, Perl helps you code up your output page 
close to how it will look when it's printed.  It can keep
track of things like how many lines on a page, what page you're on, when to
print page headers, etc.  Keywords are borrowed from FORTRAN:
format() to declare and write() to execute; see their entries in
L<perlfunc>.  Fortunately, the layout is much more legible, more like
BASIC's PRINT USING statement.  Think of it as a poor man's nroff(1).

Formats, like packages and subroutines, are declared rather than executed,
so they may occur at any point in your program.  (Usually it's best to
keep them all together though.) They have their own namespace apart from
all the other "types" in Perl.  This means that if you have a function
named "Foo", it is not the same thing as having a format named "Foo".
However, the default name for the format associated with a given
d32 2
a33 2
If name is omitted, format "STDOUT" is defined.  FORMLIST consists of a
sequence of lines, each of which may be of one of three types:
d57 1
a57 1
is supplied by padding out the field with multiple "<", ">", or "|"
d67 1
a67 1
non-truncated values; it should appear by itself on a line.
d75 8
a82 1
token on the first line.
d108 1
a108 1
Top-of-form processing is by default handled by a format with the 
d110 1
a110 1
It's triggered at the top of each page.  See <perlfunc/write()>.
d157 1
a157 1
channel, but you'll have to handle $- ($FORMAT_LINES_LEFT)
d162 4
a165 4
The current format name is stored in the variable C<$~> ($FORMAT_NAME),
and the current top of form format name is in C<$^> ($FORMAT_TOP_NAME).
The current output page number is stored in C<$%> ($FORMAT_PAGE_NUMBER),
and the number of lines on the page is in C<$=> ($FORMAT_LINES_PER_PAGE).
d167 2
a168 2
($OUTPUT_AUTOFLUSH).  The string output before each top of page (except
the first) is stored in C<$^L> ($FORMAT_FORMFEED).  These variables are
d172 1
a172 1
    select((select(OUTF), 
d197 1
a197 1
module.  Now, you can access these special variables using lower-case
d208 1
a208 1
Since the values line may contain arbitrary expressions (for at fields, 
d212 1
a212 1
    format Ident = 
d219 1
a219 1
    format Ident = 
d226 1
a226 1
    format Ident = 
d243 1
a243 1
    eval $format; 
d248 1
a248 1
 format STDOUT = 
d257 1
a257 1
 format = 
d267 1
a267 1
 } 
d280 4
a283 4
Here's another strategy; open a pipe to yourself, using C<open(MESELF, "|-")> 
(see L<perlfunc/open()>) and always write() to MESELF instead of
STDOUT.  Have your child process postprocesses its STDIN to rearrange
headers and footers however you like.  Not very convenient, but doable.
d308 1
a308 1
    } 
d316 8
a323 1
=head1 WARNING
d327 11
a337 3
variable.  (They weren't visible at all before version 5.001.)  Furthermore,
lexical aliases will not be compiled correctly: see
L<perlfunc/my> for other issues.
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d8 14
a21 14
facilitate this, Perl helps you code up your output page close to how it
will look when it's printed.  It can keep track of things like how many
lines are on a page, what page you're on, when to print page headers,
etc.  Keywords are borrowed from FORTRAN: format() to declare and write()
to execute; see their entries in L<perlfunc>.  Fortunately, the layout is
much more legible, more like BASIC's PRINT USING statement.  Think of it
as a poor man's nroff(1).

Formats, like packages and subroutines, are declared rather than
executed, so they may occur at any point in your program.  (Usually it's
best to keep them all together though.) They have their own namespace
apart from all the other "types" in Perl.  This means that if you have a
function named "Foo", it is not the same thing as having a format named
"Foo".  However, the default name for the format associated with a given
d23 2
a24 2
format for STDOUT is named "STDOUT", and the default format for filehandle
TEMP is named "TEMP".  They just look the same.  They aren't.
d32 2
a33 2
If name is omitted, format "STDOUT" is defined.  FORMLIST consists of
a sequence of lines, each of which may be one of three types:
d57 1
a57 1
is supplied by padding out the field with multiple "E<lt>", "E<gt>", or "|"
d67 1
a67 1
nontruncated values; it should appear by itself on a line.
d75 1
a75 8
token on the first line.  If an expression evaluates to a number with a
decimal part, and if the corresponding picture specifies that the decimal
part should appear in the output (that is, any picture except multiple "#"
characters B<without> an embedded "."), the character used for the decimal
point is B<always> determined by the current LC_NUMERIC locale.  This
means that, if, for example, the run-time environment happens to specify a
German locale, "," will be used instead of the default ".".  See
L<perllocale> and L<"WARNINGS"> for more information.
d101 1
a101 1
Top-of-form processing is by default handled by a format with the
d103 1
a103 1
It's triggered at the top of each page.  See L<perlfunc/write>.
d150 1
a150 1
channel, but you'll have to handle C<$-> (C<$FORMAT_LINES_LEFT>)
d155 4
a158 4
The current format name is stored in the variable C<$~> (C<$FORMAT_NAME>),
and the current top of form format name is in C<$^> (C<$FORMAT_TOP_NAME>).
The current output page number is stored in C<$%> (C<$FORMAT_PAGE_NUMBER>),
and the number of lines on the page is in C<$=> (C<$FORMAT_LINES_PER_PAGE>).
d160 2
a161 2
(C<$OUTPUT_AUTOFLUSH>).  The string output before each top of page (except
the first) is stored in C<$^L> (C<$FORMAT_FORMFEED>).  These variables are
d165 1
a165 1
    select((select(OUTF),
d190 1
a190 1
module.  Now, you can access these special variables using lowercase
d201 1
a201 1
Because the values line may contain arbitrary expressions (for at fields,
d205 1
a205 1
    format Ident =
d212 1
a212 1
    format Ident =
d219 1
a219 1
    format Ident =
d229 5
a233 5
    $format  = "format STDOUT = \n"
             . '^' . '<' x $cols . "\n"
             . '$entry' . "\n"
             . "\t^" . "<" x ($cols-8) . "~~\n"
             . '$entry' . "\n"
d236 1
a236 1
    eval $format;
d241 1
a241 1
 format STDOUT =
d250 1
a250 1
 format =
d260 1
a260 1
 }
d273 4
a276 4
Here's another strategy: Open a pipe to yourself, using C<open(MYSELF, "|-")>
(see L<perlfunc/open()>) and always write() to MYSELF instead of STDOUT.
Have your child process massage its STDIN to rearrange headers and footers
however you like.  Not very convenient, but doable.
d291 1
a291 1
Or to make an swrite() subroutine, which is to write() what sprintf()
d301 1
a301 1
    }
d309 1
a309 8
=head1 WARNINGS

The lone dot that ends a format can also prematurely end a mail
message passing through a misconfigured Internet mailer (and based on
experience, such misconfiguration is the rule, not the exception).  So
when sending format code through mail, you should indent it so that
the format-ending dot is not on the left margin; this will prevent
SMTP cutoff.
d313 3
a315 20
variable.  (They weren't visible at all before version 5.001.)

Formats are the only part of Perl that unconditionally use information
from a program's locale; if a program's environment specifies an
LC_NUMERIC locale, it is always used to specify the decimal point
character in formatted output.  Perl ignores all other aspects of locale
handling unless the C<use locale> pragma is in effect.  Formatted output
cannot be controlled by C<use locale> because the pragma is tied to the
block structure of the program, and, for historical reasons, formats
exist outside that block structure.  See L<perllocale> for further
discussion of locale handling.

Inside of an expression, the whitespace characters \n, \t and \f are
considered to be equivalent to a single space.  Thus, you could think
of this filter being applied to each value in the format:

 $value =~ tr/\n\t\f/ /;

The remaining whitespace character, \r, forces the printing of a new
line if allowed by the picture line.
@


1.1.1.3
log
@stock perl 5.8.0 from CPAN
@
text
@d63 5
a67 7
characters (with an optional ".") to specify a numeric field. This way
you can line up the decimal points. With a "0" (zero) instead of the
first "#", the formatted number will be padded with leading zeroes if
necessary. If any value supplied for these fields contains a newline,
only the text up to the newline is printed. Finally, the special field
"@@*" can be used for printing multi-line, nontruncated values; it
should appear by itself on a line.
d190 1
a190 1
    use English '-no_match_vars';
@


1.1.1.4
log
@Import of stock perl 5.8.5
@
text
@d32 2
a33 3
If the name is omitted, format "STDOUT" is defined. A single "." in 
column 1 is used to terminate a format.  FORMLIST consists of a sequence 
of lines, each of which may be one of three types:
d51 23
a73 100
Picture lines contain output field definitions, intermingled with
literal text. These lines do not undergo any kind of variable interpolation.
Field definitions are made up from a set of characters, for starting and
extending a field to its desired width. This is the complete set of
characters for field definitions:
  
   @@    start of regular field
   ^    start of special field
   <    pad character for left adjustification
   |    pad character for centering
   >    pad character for right adjustificat
   #    pad character for a right justified numeric field
   0    instead of first #: pad number with leading zeroes
   .    decimal point within a numeric field
   ...  terminate a text field, show "..." as truncation evidence
   @@*   variable width field for a multi-line value
   ^*   variable width field for next line of a multi-line value
   ~    suppress line with all fields empty
   ~~   repeat line until all fields are exhausted

Each field in a picture line starts with either "@@" (at) or "^" (caret),
indicating what we'll call, respectively, a "regular" or "special" field.
The choice of pad characters determines whether a field is textual or
numeric. The tilde operators are not part of a field.  Let's look at
the various possibilities in detail.


=head2 Text Fields

The length of the field is supplied by padding out the field with multiple 
"E<lt>", "E<gt>", or "|" characters to specify a non-numeric field with,
respectively, left justification, right justification, or centering. 
For a regular field, the value (up to the first newline) is taken and
printed according to the selected justification, truncating excess characters.
If you terminate a text field with "...", three dots will be shown if
the value is truncated. A special text field may be used to do rudimentary 
multi-line text block filling; see L</Using Fill Mode> for details.

   Example:
      format STDOUT =
      @@<<<<<<   @@||||||   @@>>>>>>
      "left",   "middle", "right"
      .
   Output:
      left      middle    right


=head2 Numeric Fields

Using "#" as a padding character specifies a numeric field, with
right justification. An optional "." defines the position of the
decimal point. With a "0" (zero) instead of the first "#", the
formatted number will be padded with leading zeroes if necessary.
A special numeric field is blanked out if the value is undefined.
If the resulting value would exceed the width specified the field is
filled with "#" as overflow evidence.

   Example:
      format STDOUT =
      @@###   @@.###   @@##.###  @@###   @@###   ^####
       42,   3.1415,  undef,    0, 10000,   undef
      .
   Output:
        42   3.142     0.000     0   ####


=head2 The Field @@* for Variable Width Multi-Line Text

The field "@@*" can be used for printing multi-line, nontruncated
values; it should (but need not) appear by itself on a line. A final
line feed is chomped off, but all other characters are emitted verbatim.


=head2 The Field ^* for Variable Width One-line-at-a-time Text

Like "@@*", this is a variable width field. The value supplied must be a 
scalar variable. Perl puts the first line (up to the first "\n") of the 
text into the field, and then chops off the front of the string so that 
the next time the variable is referenced, more of the text can be printed. 
The variable will I<not> be restored.

   Example:
      $text = "line 1\nline 2\nline 3";
      format STDOUT =
      Text: ^*
            $text
      ~~    ^*
            $text
      .
   Output:
      Text: line 1
            line 2
            line 3


=head2 Specifying Values

The values are specified on the following format line in the same order as
the picture fields.  The expressions providing the values must be
separated by commas.  They are all evaluated in a list context
d86 6
a91 7

=head2 Using Fill Mode

On text fields the caret enables a kind of fill mode.  Instead of an
arbitrary expression, the value supplied must be a scalar variable
that contains a text string.  Perl puts the next portion of the text into
the field, and then chops off the front of the string so that the next time
d94 6
a99 5
call, and is not restored.)  The next portion of text is determined by
a crude line breaking algorithm. You may use the carriage return character
(C<\r>) to force a line break. You can change which characters are legal 
to break on by changing the variable C<$:> (that's 
$FORMAT_LINE_BREAK_CHARACTERS if you're using the English module) to a 
d102 7
a108 25
Normally you would use a sequence of fields in a vertical stack associated 
with the same scalar variable to print out a block of text. You might wish 
to end the final field with the text "...", which will appear in the output 
if the text was too long to appear in its entirety.  


=head2 Suppressing Lines Where All Fields Are Void

Using caret fields can produce lines where all fields are blank. You can
suppress such lines by putting a "~" (tilde) character anywhere in the
line.  The tilde will be translated to a space upon output.


=head2 Repeating Format Lines

If you put two contiguous tilde characters "~~" anywhere into a line,
the line will be repeated until all the fields on the line are exhausted,
i.e. undefined. For special (caret) text fields this will occur sooner or
later, but if you use a text field of the at variety, the  expression you
supply had better not give the same value every time forever! (C<shift(@@f)>
is a simple example that would work.)  Don't use a regular (at) numeric 
field in such lines, because it will never go blank.


=head2 Top of Form Processing
d341 5
a345 4
Within strings that are to be displayed in a fixed length text field,
each control character is substituted by a space. (But remember the
special meaning of C<\r> when using fill mode.) This is done to avoid
misalignment when control characters "disappear" on some output media.
d347 2
@


1.1.1.5
log
@perl 5.8.8 import
@
text
@a1 1
X<format> X<report> X<chart>
a14 1
X<nroff>
a56 3
X<format, picture line>
X<@@> X<^> X<< < >> X<< | >> X<< > >> X<#> X<0> X<.> X<...>
X<@@*> X<^*> X<~> X<~~>
a79 1
X<format, text field>
a99 1
X<#> X<format, numeric field>
a118 1
X<@@*>
a125 1
X<^*>
a147 1
X<format, specifying values>
a165 1
X<format, fill mode>
a186 1
X<format, suppressing lines>
a193 1
X<format, repeating lines>
a204 1
X<format, top of form> X<top> X<header>
a258 2
X<format variables>
X<format, variables>
a367 1
X<format, footer> X<footer>
a383 1
X<format, internals>
@


1.1.1.6
log
@import perl 5.10.1
@
text
@d62 1
a62 1

d65 1
a65 1
   <    pad character for left justification
d67 1
a67 1
   >    pad character for right justification
@


1.1.1.7
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d68 1
a68 1
   #    pad character for a right-justified numeric field
d125 1
a125 1
=head2 The Field @@* for Variable-Width Multi-Line Text
d133 1
a133 1
=head2 The Field ^* for Variable-Width One-line-at-a-time Text
d136 1
a136 1
Like "@@*", this is a variable-width field. The value supplied must be a 
d169 3
a171 3
point is determined by the current LC_NUMERIC locale if C<use locale> is in
effect.  This means that, if, for example, the run-time environment happens
to specify a German locale, "," will be used instead of the default ".".  See
d185 1
a185 1
a crude line-breaking algorithm. You may use the carriage return character
d294 1
a294 1
because not only does legibility improve, you now have an intermediary
d396 1
a396 1
(see L<perlfunc/open>) and always write() to MYSELF instead of STDOUT.
d412 1
a412 1
    print "Wow, I just stored '$^A' in the accumulator!\n";
d445 9
a453 5
If a program's environment specifies an LC_NUMERIC locale and C<use
locale> is in effect when the format is declared, the locale is used
to specify the decimal point character in formatted output.  Formatted
output cannot be controlled by C<use locale> at the time when write()
is called. See L<perllocale> for further discussion of locale handling.
d455 1
a455 1
Within strings that are to be displayed in a fixed-length text field,
@


1.1.1.8
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d403 1
a403 1
For low-level access to the formatting mechanism, you may use formline()
d443 1
a443 1
variable.
@


1.1.1.9
log
@Import perl-5.20.1
@
text
@d304 1
a304 1
    use English;
@


