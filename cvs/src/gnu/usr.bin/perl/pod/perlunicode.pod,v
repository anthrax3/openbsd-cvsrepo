head	1.2;
access;
symbols
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.13.0.10
	OPENBSD_6_0_BASE:1.1.1.13
	OPENBSD_5_9:1.1.1.13.0.4
	OPENBSD_5_9_BASE:1.1.1.13
	OPENBSD_5_8:1.1.1.13.0.6
	OPENBSD_5_8_BASE:1.1.1.13
	PERL_5_20_2:1.1.1.13
	OPENBSD_5_7:1.1.1.13.0.2
	OPENBSD_5_7_BASE:1.1.1.13
	PERL_5_20_1:1.1.1.13
	OPENBSD_5_6:1.1.1.12.0.4
	OPENBSD_5_6_BASE:1.1.1.12
	PERL_5_18_2:1.1.1.12
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.11.0.6
	OPENBSD_5_5_BASE:1.1.1.11
	OPENBSD_5_4:1.1.1.11.0.2
	OPENBSD_5_4_BASE:1.1.1.11
	PERL_5_16_3:1.1.1.11
	OPENBSD_5_3:1.1.1.10.0.10
	OPENBSD_5_3_BASE:1.1.1.10
	OPENBSD_5_2:1.1.1.10.0.8
	OPENBSD_5_2_BASE:1.1.1.10
	OPENBSD_5_1_BASE:1.1.1.10
	OPENBSD_5_1:1.1.1.10.0.6
	OPENBSD_5_0:1.1.1.10.0.4
	OPENBSD_5_0_BASE:1.1.1.10
	OPENBSD_4_9:1.1.1.10.0.2
	OPENBSD_4_9_BASE:1.1.1.10
	PERL_5_12_2:1.1.1.10
	OPENBSD_4_8:1.1.1.9.0.4
	OPENBSD_4_8_BASE:1.1.1.9
	OPENBSD_4_7:1.1.1.9.0.2
	OPENBSD_4_7_BASE:1.1.1.9
	PERL_5_10_1:1.1.1.9
	OPENBSD_4_6:1.1.1.8.0.6
	OPENBSD_4_6_BASE:1.1.1.8
	OPENBSD_4_5:1.1.1.8.0.2
	OPENBSD_4_5_BASE:1.1.1.8
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.1.1.7.0.10
	OPENBSD_4_4_BASE:1.1.1.7
	OPENBSD_4_3:1.1.1.7.0.8
	OPENBSD_4_3_BASE:1.1.1.7
	OPENBSD_4_2:1.1.1.7.0.6
	OPENBSD_4_2_BASE:1.1.1.7
	OPENBSD_4_1:1.1.1.7.0.4
	OPENBSD_4_1_BASE:1.1.1.7
	OPENBSD_4_0:1.1.1.7.0.2
	OPENBSD_4_0_BASE:1.1.1.7
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.1.1.6.0.8
	OPENBSD_3_9_BASE:1.1.1.6
	OPENBSD_3_8:1.1.1.6.0.6
	OPENBSD_3_8_BASE:1.1.1.6
	OPENBSD_3_7:1.1.1.6.0.4
	OPENBSD_3_7_BASE:1.1.1.6
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.1.1.6.0.2
	OPENBSD_3_6_BASE:1.1.1.6
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.1.1.4.0.2
	OPENBSD_3_5_BASE:1.1.1.4
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.1.1.3.0.4
	OPENBSD_3_4_BASE:1.1.1.3
	OPENBSD_3_3:1.1.1.3.0.2
	OPENBSD_3_3_BASE:1.1.1.3
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.1.1.2.0.6
	OPENBSD_3_2_BASE:1.1.1.2
	OPENBSD_3_1:1.1.1.2.0.4
	OPENBSD_3_1_BASE:1.1.1.2
	OPENBSD_3_0:1.1.1.2.0.2
	OPENBSD_3_0_BASE:1.1.1.2
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.1.1.1.0.6
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	PERL_5_6_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.19;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2000.04.06.16.10.33;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.06.16.10.33;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.05.24.18.24.53;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.27.22.15.08;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.12.03.02.44.28;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.04.07.21.13.40;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.08.09.17.48.29;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.03.28.18.49.37;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.29.17.18.57;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.10.12.18.10.38;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2010.09.24.14.49.13;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2013.03.25.20.09.26;	author sthen;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.03.24.14.59.08;	author afresh1;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2014.11.17.20.53.15;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@=head1 NAME

perlunicode - Unicode support in Perl

=head1 DESCRIPTION

If you haven't already, before reading this document, you should become
familiar with both L<perlunitut> and L<perluniintro>.

Unicode aims to B<UNI>-fy the en-B<CODE>-ings of all the world's
character sets into a single Standard.   For quite a few of the various
coding standards that existed when Unicode was first created, converting
from each to Unicode essentially meant adding a constant to each code
point in the original standard, and converting back meant just
subtracting that same constant.  For ASCII and ISO-8859-1, the constant
is 0.  For ISO-8859-5, (Cyrillic) the constant is 864; for Hebrew
(ISO-8859-8), it's 1488; Thai (ISO-8859-11), 3424; and so forth.  This
made it easy to do the conversions, and facilitated the adoption of
Unicode.

And it worked; nowadays, those legacy standards are rarely used.  Most
everyone uses Unicode.

Unicode is a comprehensive standard.  It specifies many things outside
the scope of Perl, such as how to display sequences of characters.  For
a full discussion of all aspects of Unicode, see
L<http://www.unicode.org>.

=head2 Important Caveats

Even though some of this section may not be understandable to you on
first reading, we think it's important enough to highlight some of the
gotchas before delving further, so here goes:

Unicode support is an extensive requirement. While Perl does not
implement the Unicode standard or the accompanying technical reports
from cover to cover, Perl does support many Unicode features.

Also, the use of Unicode may present security issues that aren't obvious.
Read L<Unicode Security Considerations|http://www.unicode.org/reports/tr36>.

=over 4

=item Safest if you C<use feature 'unicode_strings'>

In order to preserve backward compatibility, Perl does not turn
on full internal Unicode support unless the pragma
L<S<C<use feature 'unicode_strings'>>|feature/The 'unicode_strings' feature>
is specified.  (This is automatically
selected if you S<C<use 5.012>> or higher.)  Failure to do this can
trigger unexpected surprises.  See L</The "Unicode Bug"> below.

This pragma doesn't affect I/O.  Nor does it change the internal
representation of strings, only their interpretation.  There are still
several places where Unicode isn't fully supported, such as in
filenames.

=item Input and Output Layers

Use the C<:encoding(...)> layer  to read from and write to
filehandles using the specified encoding.  (See L<open>.)

=item You should convert your non-ASCII, non-UTF-8 Perl scripts to be
UTF-8.

See L<encoding>.

=item C<use utf8> still needed to enable L<UTF-8|/Unicode Encodings> in scripts

If your Perl script is itself encoded in L<UTF-8|/Unicode Encodings>,
the S<C<use utf8>> pragma must be explicitly included to enable
recognition of that (in string or regular expression literals, or in
identifier names).  B<This is the only time when an explicit S<C<use
utf8>> is needed.>  (See L<utf8>).

=item C<BOM>-marked scripts and L<UTF-16|/Unicode Encodings> scripts autodetected

However, if a Perl script begins with the Unicode C<BOM> (UTF-16LE,
UTF16-BE, or UTF-8), or if the script looks like non-C<BOM>-marked
UTF-16 of either endianness, Perl will correctly read in the script as
the appropriate Unicode encoding.  (C<BOM>-less UTF-8 cannot be
effectively recognized or differentiated from ISO 8859-1 or other
eight-bit encodings.)

=back

=head2 Byte and Character Semantics

Before Unicode, most encodings used 8 bits (a single byte) to encode
each character.  Thus a character was a byte, and a byte was a
character, and there could be only 256 or fewer possible characters.
"Byte Semantics" in the title of this section refers to
this behavior.  There was no need to distinguish between "Byte" and
"Character".

Then along comes Unicode which has room for over a million characters
(and Perl allows for even more).  This means that a character may
require more than a single byte to represent it, and so the two terms
are no longer equivalent.  What matter are the characters as whole
entities, and not usually the bytes that comprise them.  That's what the
term "Character Semantics" in the title of this section refers to.

Perl had to change internally to decouple "bytes" from "characters".
It is important that you too change your ideas, if you haven't already,
so that "byte" and "character" no longer mean the same thing in your
mind.

The basic building block of Perl strings has always been a "character".
The changes basically come down to that the implementation no longer
thinks that a character is always just a single byte.

There are various things to note:

=over 4

=item *

String handling functions, for the most part, continue to operate in
terms of characters.  C<length()>, for example, returns the number of
characters in a string, just as before.  But that number no longer is
necessarily the same as the number of bytes in the string (there may be
more bytes than characters).  The other such functions include
C<chop()>, C<chomp()>, C<substr()>, C<pos()>, C<index()>, C<rindex()>,
C<sort()>, C<sprintf()>, and C<write()>.

The exceptions are:

=over 4

=item *

the bit-oriented C<vec>

E<nbsp>

=item *

the byte-oriented C<pack>/C<unpack> C<"C"> format

However, the C<W> specifier does operate on whole characters, as does the
C<U> specifier.

=item *

some operators that interact with the platform's operating system

Operators dealing with filenames are examples.

=item *

when the functions are called from within the scope of the
S<C<L<use bytes|bytes>>> pragma

Likely, you should use this only for debugging anyway.

=back

=item *

Strings--including hash keys--and regular expression patterns may
contain characters that have ordinal values larger than 255.

If you use a Unicode editor to edit your program, Unicode characters may
occur directly within the literal strings in UTF-8 encoding, or UTF-16.
(The former requires a C<BOM> or C<use utf8>, the latter requires a C<BOM>.)

L<perluniintro/Creating Unicode> gives other ways to place non-ASCII
characters in your strings.

=item *

The C<chr()> and C<ord()> functions work on whole characters.

=item *

Regular expressions match whole characters.  For example, C<"."> matches
a whole character instead of only a single byte.

=item *

The C<tr///> operator translates whole characters.  (Note that the
C<tr///CU> functionality has been removed.  For similar functionality to
that, see C<pack('U0', ...)> and C<pack('C0', ...)>).

=item *

C<scalar reverse()> reverses by character rather than by byte.

=item *

The bit string operators, C<& | ^ ~> and (starting in v5.22)
C<&. |. ^.  ~.> can operate on characters that don't fit into a byte.
However, the current behavior is likely to change.  You should not use
these operators on strings that are encoded in UTF-8.  If you're not
sure about the encoding of a string, downgrade it before using any of
these operators; you can use
L<C<utf8::utf8_downgrade()>|utf8/Utility functions>.

=back

The bottom line is that Perl has always practiced "Character Semantics",
but with the advent of Unicode, that is now different than "Byte
Semantics".

=head2 ASCII Rules versus Unicode Rules

Before Unicode, when a character was a byte was a character,
Perl knew only about the 128 characters defined by ASCII, code points 0
through 127 (except for under S<C<use locale>>).  That left the code
points 128 to 255 as unassigned, and available for whatever use a
program might want.  The only semantics they have is their ordinal
numbers, and that they are members of none of the non-negative character
classes.  None are considered to match C<\w> for example, but all match
C<\W>.

Unicode, of course, assigns each of those code points a particular
meaning (along with ones above 255).  To preserve backward
compatibility, Perl only uses the Unicode meanings when there is some
indication that Unicode is what is intended; otherwise the non-ASCII
code points remain treated as if they are unassigned.

Here are the ways that Perl knows that a string should be treated as
Unicode:

=over

=item *

Within the scope of S<C<use utf8>>

If the whole program is Unicode (signified by using 8-bit B<U>nicode
B<T>ransformation B<F>ormat), then all strings within it must be
Unicode.

=item *

Within the scope of
L<S<C<use feature 'unicode_strings'>>|feature/The 'unicode_strings' feature>

This pragma was created so you can explicitly tell Perl that operations
executed within its scope are to use Unicode rules.  More operations are
affected with newer perls.  See L</The "Unicode Bug">.

=item *

Within the scope of S<C<use 5.012>> or higher

This implicitly turns on S<C<use feature 'unicode_strings'>>.

=item *

Within the scope of
L<S<C<use locale 'not_characters'>>|perllocale/Unicode and UTF-8>,
or L<S<C<use locale>>|perllocale> and the current
locale is a UTF-8 locale.

The former is defined to imply Unicode handling; and the latter
indicates a Unicode locale, hence a Unicode interpretation of all
strings within it.

=item *

When the string contains a Unicode-only code point

Perl has never accepted code points above 255 without them being
Unicode, so their use implies Unicode for the whole string.

=item *

When the string contains a Unicode named code point C<\N{...}>

The C<\N{...}> construct explicitly refers to a Unicode code point,
even if it is one that is also in ASCII.  Therefore the string
containing it must be Unicode.

=item *

When the string has come from an external source marked as
Unicode

The L<C<-C>|perlrun/-C [numberE<sol>list]> command line option can
specify that certain inputs to the program are Unicode, and the values
of this can be read by your Perl code, see L<perlvar/"${^UNICODE}">.

=item * When the string has been upgraded to UTF-8

The function L<C<utf8::utf8_upgrade()>|utf8/Utility functions>
can be explicitly used to permanently (unless a subsequent
C<utf8::utf8_downgrade()> is called) cause a string to be treated as
Unicode.

=item * There are additional methods for regular expression patterns

A pattern that is compiled with the C<< /u >> or C<< /a >> modifiers is
treated as Unicode (though there are some restrictions with C<< /a >>).
Under the C<< /d >> and C<< /l >> modifiers, there are several other
indications for Unicode; see L<perlre/Character set modifiers>.

=back

Note that all of the above are overridden within the scope of
C<L<use bytes|bytes>>; but you should be using this pragma only for
debugging.

Note also that some interactions with the platform's operating system
never use Unicode rules.

When Unicode rules are in effect:

=over 4

=item *

Case translation operators use the Unicode case translation tables.

Note that C<uc()>, or C<\U> in interpolated strings, translates to
uppercase, while C<ucfirst>, or C<\u> in interpolated strings,
translates to titlecase in languages that make the distinction (which is
equivalent to uppercase in languages without the distinction).

There is a CPAN module, C<L<Unicode::Casing>>, which allows you to
define your own mappings to be used in C<lc()>, C<lcfirst()>, C<uc()>,
C<ucfirst()>, and C<fc> (or their double-quoted string inlined versions
such as C<\U>).  (Prior to Perl 5.16, this functionality was partially
provided in the Perl core, but suffered from a number of insurmountable
drawbacks, so the CPAN module was written instead.)

=item *

Character classes in regular expressions match based on the character
properties specified in the Unicode properties database.

C<\w> can be used to match a Japanese ideograph, for instance; and
C<[[:digit:]]> a Bengali number.

=item *

Named Unicode properties, scripts, and block ranges may be used (like
bracketed character classes) by using the C<\p{}> "matches property"
construct and the C<\P{}> negation, "doesn't match property".

See L</"Unicode Character Properties"> for more details.

You can define your own character properties and use them
in the regular expression with the C<\p{}> or C<\P{}> construct.
See L</"User-Defined Character Properties"> for more details.

=back

=head2 Extended Grapheme Clusters (Logical characters)

Consider a character, say C<H>.  It could appear with various marks around it,
such as an acute accent, or a circumflex, or various hooks, circles, arrows,
I<etc.>, above, below, to one side or the other, I<etc>.  There are many
possibilities among the world's languages.  The number of combinations is
astronomical, and if there were a character for each combination, it would
soon exhaust Unicode's more than a million possible characters.  So Unicode
took a different approach: there is a character for the base C<H>, and a
character for each of the possible marks, and these can be variously combined
to get a final logical character.  So a logical character--what appears to be a
single character--can be a sequence of more than one individual characters.
The Unicode standard calls these "extended grapheme clusters" (which
is an improved version of the no-longer much used "grapheme cluster");
Perl furnishes the C<\X> regular expression construct to match such
sequences in their entirety.

But Unicode's intent is to unify the existing character set standards and
practices, and several pre-existing standards have single characters that
mean the same thing as some of these combinations, like ISO-8859-1,
which has quite a few of them. For example, C<"LATIN CAPITAL LETTER E
WITH ACUTE"> was already in this standard when Unicode came along.
Unicode therefore added it to its repertoire as that single character.
But this character is considered by Unicode to be equivalent to the
sequence consisting of the character C<"LATIN CAPITAL LETTER E">
followed by the character C<"COMBINING ACUTE ACCENT">.

C<"LATIN CAPITAL LETTER E WITH ACUTE"> is called a "pre-composed"
character, and its equivalence with the "E" and the "COMBINING ACCENT"
sequence is called canonical equivalence.  All pre-composed characters
are said to have a decomposition (into the equivalent sequence), and the
decomposition type is also called canonical.  A string may be comprised
as much as possible of precomposed characters, or it may be comprised of
entirely decomposed characters.  Unicode calls these respectively,
"Normalization Form Composed" (NFC) and "Normalization Form Decomposed".
The C<L<Unicode::Normalize>> module contains functions that convert
between the two.  A string may also have both composed characters and
decomposed characters; this module can be used to make it all one or the
other.

You may be presented with strings in any of these equivalent forms.
There is currently nothing in Perl 5 that ignores the differences.  So
you'll have to specially hanlde it.  The usual advice is to convert your
inputs to C<NFD> before processing further.

For more detailed information, see L<http://unicode.org/reports/tr15/>.

=head2 Unicode Character Properties

(The only time that Perl considers a sequence of individual code
points as a single logical character is in the C<\X> construct, already
mentioned above.   Therefore "character" in this discussion means a single
Unicode code point.)

Very nearly all Unicode character properties are accessible through
regular expressions by using the C<\p{}> "matches property" construct
and the C<\P{}> "doesn't match property" for its negation.

For instance, C<\p{Uppercase}> matches any single character with the Unicode
C<"Uppercase"> property, while C<\p{L}> matches any character with a
C<General_Category> of C<"L"> (letter) property (see
L</General_Category> below).  Brackets are not
required for single letter property names, so C<\p{L}> is equivalent to C<\pL>.

More formally, C<\p{Uppercase}> matches any single character whose Unicode
C<Uppercase> property value is C<True>, and C<\P{Uppercase}> matches any character
whose C<Uppercase> property value is C<False>, and they could have been written as
C<\p{Uppercase=True}> and C<\p{Uppercase=False}>, respectively.

This formality is needed when properties are not binary; that is, if they can
take on more values than just C<True> and C<False>.  For example, the
C<Bidi_Class> property (see L</"Bidirectional Character Types"> below),
can take on several different
values, such as C<Left>, C<Right>, C<Whitespace>, and others.  To match these, one needs
to specify both the property name (C<Bidi_Class>), AND the value being
matched against
(C<Left>, C<Right>, I<etc.>).  This is done, as in the examples above, by having the
two components separated by an equal sign (or interchangeably, a colon), like
C<\p{Bidi_Class: Left}>.

All Unicode-defined character properties may be written in these compound forms
of C<\p{I<property>=I<value>}> or C<\p{I<property>:I<value>}>, but Perl provides some
additional properties that are written only in the single form, as well as
single-form short-cuts for all binary properties and certain others described
below, in which you may omit the property name and the equals or colon
separator.

Most Unicode character properties have at least two synonyms (or aliases if you
prefer): a short one that is easier to type and a longer one that is more
descriptive and hence easier to understand.  Thus the C<"L"> and
C<"Letter"> properties above are equivalent and can be used
interchangeably.  Likewise, C<"Upper"> is a synonym for C<"Uppercase">,
and we could have written C<\p{Uppercase}> equivalently as C<\p{Upper}>.
Also, there are typically various synonyms for the values the property
can be.   For binary properties, C<"True"> has 3 synonyms: C<"T">,
C<"Yes">, and C<"Y">; and C<"False"> has correspondingly C<"F">,
C<"No">, and C<"N">.  But be careful.  A short form of a value for one
property may not mean the same thing as the same short form for another.
Thus, for the C<L</General_Category>> property, C<"L"> means
C<"Letter">, but for the L<C<Bidi_Class>|/Bidirectional Character Types>
property, C<"L"> means C<"Left">.  A complete list of properties and
synonyms is in L<perluniprops>.

Upper/lower case differences in property names and values are irrelevant;
thus C<\p{Upper}> means the same thing as C<\p{upper}> or even C<\p{UpPeR}>.
Similarly, you can add or subtract underscores anywhere in the middle of a
word, so that these are also equivalent to C<\p{U_p_p_e_r}>.  And white space
is irrelevant adjacent to non-word characters, such as the braces and the equals
or colon separators, so C<\p{   Upper  }> and C<\p{ Upper_case : Y }> are
equivalent to these as well.  In fact, white space and even
hyphens can usually be added or deleted anywhere.  So even C<\p{ Up-per case = Yes}> is
equivalent.  All this is called "loose-matching" by Unicode.  The few places
where stricter matching is used is in the middle of numbers, and in the Perl
extension properties that begin or end with an underscore.  Stricter matching
cares about white space (except adjacent to non-word characters),
hyphens, and non-interior underscores.

You can also use negation in both C<\p{}> and C<\P{}> by introducing a caret
(C<^>) between the first brace and the property name: C<\p{^Tamil}> is
equal to C<\P{Tamil}>.

Almost all properties are immune to case-insensitive matching.  That is,
adding a C</i> regular expression modifier does not change what they
match.  There are two sets that are affected.
The first set is
C<Uppercase_Letter>,
C<Lowercase_Letter>,
and C<Titlecase_Letter>,
all of which match C<Cased_Letter> under C</i> matching.
And the second set is
C<Uppercase>,
C<Lowercase>,
and C<Titlecase>,
all of which match C<Cased> under C</i> matching.
This set also includes its subsets C<PosixUpper> and C<PosixLower> both
of which under C</i> match C<PosixAlpha>.
(The difference between these sets is that some things, such as Roman
numerals, come in both upper and lower case so they are C<Cased>, but
aren't considered letters, so they aren't C<Cased_Letter>'s.)

See L</Beyond Unicode code points> for special considerations when
matching Unicode properties against non-Unicode code points.

=head3 B<General_Category>

Every Unicode character is assigned a general category, which is the "most
usual categorization of a character" (from
L<http://www.unicode.org/reports/tr44>).

The compound way of writing these is like C<\p{General_Category=Number}>
(short: C<\p{gc:n}>).  But Perl furnishes shortcuts in which everything up
through the equal or colon separator is omitted.  So you can instead just write
C<\pN>.

Here are the short and long forms of the values the C<General Category> property
can have:

    Short       Long

    L           Letter
    LC, L&      Cased_Letter (that is: [\p{Ll}\p{Lu}\p{Lt}])
    Lu          Uppercase_Letter
    Ll          Lowercase_Letter
    Lt          Titlecase_Letter
    Lm          Modifier_Letter
    Lo          Other_Letter

    M           Mark
    Mn          Nonspacing_Mark
    Mc          Spacing_Mark
    Me          Enclosing_Mark

    N           Number
    Nd          Decimal_Number (also Digit)
    Nl          Letter_Number
    No          Other_Number

    P           Punctuation (also Punct)
    Pc          Connector_Punctuation
    Pd          Dash_Punctuation
    Ps          Open_Punctuation
    Pe          Close_Punctuation
    Pi          Initial_Punctuation
                (may behave like Ps or Pe depending on usage)
    Pf          Final_Punctuation
                (may behave like Ps or Pe depending on usage)
    Po          Other_Punctuation

    S           Symbol
    Sm          Math_Symbol
    Sc          Currency_Symbol
    Sk          Modifier_Symbol
    So          Other_Symbol

    Z           Separator
    Zs          Space_Separator
    Zl          Line_Separator
    Zp          Paragraph_Separator

    C           Other
    Cc          Control (also Cntrl)
    Cf          Format
    Cs          Surrogate
    Co          Private_Use
    Cn          Unassigned

Single-letter properties match all characters in any of the
two-letter sub-properties starting with the same letter.
C<LC> and C<L&> are special: both are aliases for the set consisting of everything matched by C<Ll>, C<Lu>, and C<Lt>.

=head3 B<Bidirectional Character Types>

Because scripts differ in their directionality (Hebrew and Arabic are
written right to left, for example) Unicode supplies a C<Bidi_Class> property.
Some of the values this property can have are:

    Value       Meaning

    L           Left-to-Right
    LRE         Left-to-Right Embedding
    LRO         Left-to-Right Override
    R           Right-to-Left
    AL          Arabic Letter
    RLE         Right-to-Left Embedding
    RLO         Right-to-Left Override
    PDF         Pop Directional Format
    EN          European Number
    ES          European Separator
    ET          European Terminator
    AN          Arabic Number
    CS          Common Separator
    NSM         Non-Spacing Mark
    BN          Boundary Neutral
    B           Paragraph Separator
    S           Segment Separator
    WS          Whitespace
    ON          Other Neutrals

This property is always written in the compound form.
For example, C<\p{Bidi_Class:R}> matches characters that are normally
written right to left.  Unlike the
C<L</General_Category>> property, this
property can have more values added in a future Unicode release.  Those
listed above comprised the complete set for many Unicode releases, but
others were added in Unicode 6.3; you can always find what the
current ones are in L<perluniprops>.  And
L<http://www.unicode.org/reports/tr9/> describes how to use them.

=head3 B<Scripts>

The world's languages are written in many different scripts.  This sentence
(unless you're reading it in translation) is written in Latin, while Russian is
written in Cyrillic, and Greek is written in, well, Greek; Japanese mainly in
Hiragana or Katakana.  There are many more.

The Unicode C<Script> and C<Script_Extensions> properties give what script a
given character is in.  Either property can be specified with the
compound form like
C<\p{Script=Hebrew}> (short: C<\p{sc=hebr}>), or
C<\p{Script_Extensions=Javanese}> (short: C<\p{scx=java}>).
In addition, Perl furnishes shortcuts for all
C<Script> property names.  You can omit everything up through the equals
(or colon), and simply write C<\p{Latin}> or C<\P{Cyrillic}>.
(This is not true for C<Script_Extensions>, which is required to be
written in the compound form.)

The difference between these two properties involves characters that are
used in multiple scripts.  For example the digits '0' through '9' are
used in many parts of the world.  These are placed in a script named
C<Common>.  Other characters are used in just a few scripts.  For
example, the C<"KATAKANA-HIRAGANA DOUBLE HYPHEN"> is used in both Japanese
scripts, Katakana and Hiragana, but nowhere else.  The C<Script>
property places all characters that are used in multiple scripts in the
C<Common> script, while the C<Script_Extensions> property places those
that are used in only a few scripts into each of those scripts; while
still using C<Common> for those used in many scripts.  Thus both these
match:

 "0" =~ /\p{sc=Common}/     # Matches
 "0" =~ /\p{scx=Common}/    # Matches

and only the first of these match:

 "\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}" =~ /\p{sc=Common}  # Matches
 "\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}" =~ /\p{scx=Common} # No match

And only the last two of these match:

 "\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}" =~ /\p{sc=Hiragana}  # No match
 "\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}" =~ /\p{sc=Katakana}  # No match
 "\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}" =~ /\p{scx=Hiragana} # Matches
 "\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}" =~ /\p{scx=Katakana} # Matches

C<Script_Extensions> is thus an improved C<Script>, in which there are
fewer characters in the C<Common> script, and correspondingly more in
other scripts.  It is new in Unicode version 6.0, and its data are likely
to change significantly in later releases, as things get sorted out.
New code should probably be using C<Script_Extensions> and not plain
C<Script>.

(Actually, besides C<Common>, the C<Inherited> script, contains
characters that are used in multiple scripts.  These are modifier
characters which inherit the script value
of the controlling character.  Some of these are used in many scripts,
and so go into C<Inherited> in both C<Script> and C<Script_Extensions>.
Others are used in just a few scripts, so are in C<Inherited> in
C<Script>, but not in C<Script_Extensions>.)

It is worth stressing that there are several different sets of digits in
Unicode that are equivalent to 0-9 and are matchable by C<\d> in a
regular expression.  If they are used in a single language only, they
are in that language's C<Script> and C<Script_Extension>.  If they are
used in more than one script, they will be in C<sc=Common>, but only
if they are used in many scripts should they be in C<scx=Common>.

A complete list of scripts and their shortcuts is in L<perluniprops>.

=head3 B<Use of the C<"Is"> Prefix>

For backward compatibility (with Perl 5.6), all properties writable
without using the compound form mentioned
so far may have C<Is> or C<Is_> prepended to their name, so C<\P{Is_Lu}>, for
example, is equal to C<\P{Lu}>, and C<\p{IsScript:Arabic}> is equal to
C<\p{Arabic}>.

=head3 B<Blocks>

In addition to B<scripts>, Unicode also defines B<blocks> of
characters.  The difference between scripts and blocks is that the
concept of scripts is closer to natural languages, while the concept
of blocks is more of an artificial grouping based on groups of Unicode
characters with consecutive ordinal values. For example, the C<"Basic Latin">
block is all the characters whose ordinals are between 0 and 127, inclusive; in
other words, the ASCII characters.  The C<"Latin"> script contains some letters
from this as well as several other blocks, like C<"Latin-1 Supplement">,
C<"Latin Extended-A">, I<etc.>, but it does not contain all the characters from
those blocks. It does not, for example, contain the digits 0-9, because
those digits are shared across many scripts, and hence are in the
C<Common> script.

For more about scripts versus blocks, see UAX#24 "Unicode Script Property":
L<http://www.unicode.org/reports/tr24>

The C<Script> or C<Script_Extensions> properties are likely to be the
ones you want to use when processing
natural language; the C<Block> property may occasionally be useful in working
with the nuts and bolts of Unicode.

Block names are matched in the compound form, like C<\p{Block: Arrows}> or
C<\p{Blk=Hebrew}>.  Unlike most other properties, only a few block names have a
Unicode-defined short name.

Perl also defines single form synonyms for the block property in cases
where these do not conflict with something else.  But don't use any of
these, because they are unstable.  Since these are Perl extensions, they
are subordinate to official Unicode property names; Unicode doesn't know
nor care about Perl's extensions.  It may happen that a name that
currently means the Perl extension will later be changed without warning
to mean a different Unicode property in a future version of the perl
interpreter that uses a later Unicode release, and your code would no
longer work.  The extensions are mentioned here for completeness:  Take
the block name and prefix it with one of: C<In> (for example
C<\p{Blk=Arrows}> can currently be written as C<\p{In_Arrows}>); or
sometimes C<Is> (like C<\p{Is_Arrows}>); or sometimes no prefix at all
(C<\p{Arrows}>).  As of this writing (Unicode 8.0) there are no
conflicts with using the C<In_> prefix, but there are plenty with the
other two forms.  For example, C<\p{Is_Hebrew}> and C<\p{Hebrew}> mean
C<\p{Script=Hebrew}> which is NOT the same thing as C<\p{Blk=Hebrew}>.  Our
advice used to be to use the C<In_> prefix as a single form way of
specifying a block.  But Unicode 8.0 added properties whose names begin
with C<In>, and it's now clear that it's only luck that's so far
prevented a conflict.  Using C<In> is only marginally less typing than
C<Blk:>, and the latter's meaning is clearer anyway, and guaranteed to
never conflict.  So don't take chances.  Use C<\p{Blk=foo}> for new
code.  And be sure that block is what you really really want to do.  In
most cases scripts are what you want instead.

A complete list of blocks is in L<perluniprops>.

=head3 B<Other Properties>

There are many more properties than the very basic ones described here.
A complete list is in L<perluniprops>.

Unicode defines all its properties in the compound form, so all single-form
properties are Perl extensions.  Most of these are just synonyms for the
Unicode ones, but some are genuine extensions, including several that are in
the compound form.  And quite a few of these are actually recommended by Unicode
(in L<http://www.unicode.org/reports/tr18>).

This section gives some details on all extensions that aren't just
synonyms for compound-form Unicode properties
(for those properties, you'll have to refer to the
L<Unicode Standard|http://www.unicode.org/reports/tr44>.

=over

=item B<C<\p{All}>>

This matches every possible code point.  It is equivalent to C<qr/./s>.
Unlike all the other non-user-defined C<\p{}> property matches, no
warning is ever generated if this is property is matched against a
non-Unicode code point (see L</Beyond Unicode code points> below).

=item B<C<\p{Alnum}>>

This matches any C<\p{Alphabetic}> or C<\p{Decimal_Number}> character.

=item B<C<\p{Any}>>

This matches any of the 1_114_112 Unicode code points.  It is a synonym
for C<\p{Unicode}>.

=item B<C<\p{ASCII}>>

This matches any of the 128 characters in the US-ASCII character set,
which is a subset of Unicode.

=item B<C<\p{Assigned}>>

This matches any assigned code point; that is, any code point whose L<general
category|/General_Category> is not C<Unassigned> (or equivalently, not C<Cn>).

=item B<C<\p{Blank}>>

This is the same as C<\h> and C<\p{HorizSpace}>:  A character that changes the
spacing horizontally.

=item B<C<\p{Decomposition_Type: Non_Canonical}>>    (Short: C<\p{Dt=NonCanon}>)

Matches a character that has a non-canonical decomposition.

The L</Extended Grapheme Clusters (Logical characters)> section above
talked about canonical decompositions.  However, many more characters
have a different type of decomposition, a "compatible" or
"non-canonical" decomposition.  The sequences that form these
decompositions are not considered canonically equivalent to the
pre-composed character.  An example is the C<"SUPERSCRIPT ONE">.  It is
somewhat like a regular digit 1, but not exactly; its decomposition into
the digit 1 is called a "compatible" decomposition, specifically a
"super" decomposition.  There are several such compatibility
decompositions (see L<http://www.unicode.org/reports/tr44>), including
one called "compat", which means some miscellaneous type of
decomposition that doesn't fit into the other decomposition categories
that Unicode has chosen.

Note that most Unicode characters don't have a decomposition, so their
decomposition type is C<"None">.

For your convenience, Perl has added the C<Non_Canonical> decomposition
type to mean any of the several compatibility decompositions.

=item B<C<\p{Graph}>>

Matches any character that is graphic.  Theoretically, this means a character
that on a printer would cause ink to be used.

=item B<C<\p{HorizSpace}>>

This is the same as C<\h> and C<\p{Blank}>:  a character that changes the
spacing horizontally.

=item B<C<\p{In=*}>>

This is a synonym for C<\p{Present_In=*}>

=item B<C<\p{PerlSpace}>>

This is the same as C<\s>, restricted to ASCII, namely C<S<[ \f\n\r\t]>>
and starting in Perl v5.18, a vertical tab.

Mnemonic: Perl's (original) space

=item B<C<\p{PerlWord}>>

This is the same as C<\w>, restricted to ASCII, namely C<[A-Za-z0-9_]>

Mnemonic: Perl's (original) word.

=item B<C<\p{Posix...}>>

There are several of these, which are equivalents, using the C<\p{}>
notation, for Posix classes and are described in
L<perlrecharclass/POSIX Character Classes>.

=item B<C<\p{Present_In: *}>>    (Short: C<\p{In=*}>)

This property is used when you need to know in what Unicode version(s) a
character is.

The "*" above stands for some two digit Unicode version number, such as
C<1.1> or C<4.0>; or the "*" can also be C<Unassigned>.  This property will
match the code points whose final disposition has been settled as of the
Unicode release given by the version number; C<\p{Present_In: Unassigned}>
will match those code points whose meaning has yet to be assigned.

For example, C<U+0041> C<"LATIN CAPITAL LETTER A"> was present in the very first
Unicode release available, which is C<1.1>, so this property is true for all
valid "*" versions.  On the other hand, C<U+1EFF> was not assigned until version
5.1 when it became C<"LATIN SMALL LETTER Y WITH LOOP">, so the only "*" that
would match it are 5.1, 5.2, and later.

Unicode furnishes the C<Age> property from which this is derived.  The problem
with Age is that a strict interpretation of it (which Perl takes) has it
matching the precise release a code point's meaning is introduced in.  Thus
C<U+0041> would match only 1.1; and C<U+1EFF> only 5.1.  This is not usually what
you want.

Some non-Perl implementations of the Age property may change its meaning to be
the same as the Perl C<Present_In> property; just be aware of that.

Another confusion with both these properties is that the definition is not
that the code point has been I<assigned>, but that the meaning of the code point
has been I<determined>.  This is because 66 code points will always be
unassigned, and so the C<Age> for them is the Unicode version in which the decision
to make them so was made.  For example, C<U+FDD0> is to be permanently
unassigned to a character, and the decision to do that was made in version 3.1,
so C<\p{Age=3.1}> matches this character, as also does C<\p{Present_In: 3.1}> and up.

=item B<C<\p{Print}>>

This matches any character that is graphical or blank, except controls.

=item B<C<\p{SpacePerl}>>

This is the same as C<\s>, including beyond ASCII.

Mnemonic: Space, as modified by Perl.  (It doesn't include the vertical tab
until v5.18, which both the Posix standard and Unicode consider white space.)

=item B<C<\p{Title}>> and  B<C<\p{Titlecase}>>

Under case-sensitive matching, these both match the same code points as
C<\p{General Category=Titlecase_Letter}> (C<\p{gc=lt}>).  The difference
is that under C</i> caseless matching, these match the same as
C<\p{Cased}>, whereas C<\p{gc=lt}> matches C<\p{Cased_Letter>).

=item B<C<\p{Unicode}>>

This matches any of the 1_114_112 Unicode code points.
C<\p{Any}>.

=item B<C<\p{VertSpace}>>

This is the same as C<\v>:  A character that changes the spacing vertically.

=item B<C<\p{Word}>>

This is the same as C<\w>, including over 100_000 characters beyond ASCII.

=item B<C<\p{XPosix...}>>

There are several of these, which are the standard Posix classes
extended to the full Unicode range.  They are described in
L<perlrecharclass/POSIX Character Classes>.

=back


=head2 User-Defined Character Properties

You can define your own binary character properties by defining subroutines
whose names begin with C<"In"> or C<"Is">.  (The experimental feature
L<perlre/(?[ ])> provides an alternative which allows more complex
definitions.)  The subroutines can be defined in any
package.  The user-defined properties can be used in the regular expression
C<\p{}> and C<\P{}> constructs; if you are using a user-defined property from a
package other than the one you are in, you must specify its package in the
C<\p{}> or C<\P{}> construct.

    # assuming property Is_Foreign defined in Lang::
    package main;  # property package name required
    if ($txt =~ /\p{Lang::IsForeign}+/) { ... }

    package Lang;  # property package name not required
    if ($txt =~ /\p{IsForeign}+/) { ... }


Note that the effect is compile-time and immutable once defined.
However, the subroutines are passed a single parameter, which is 0 if
case-sensitive matching is in effect and non-zero if caseless matching
is in effect.  The subroutine may return different values depending on
the value of the flag, and one set of values will immutably be in effect
for all case-sensitive matches, and the other set for all case-insensitive
matches.

Note that if the regular expression is tainted, then Perl will die rather
than calling the subroutine when the name of the subroutine is
determined by the tainted data.

The subroutines must return a specially-formatted string, with one
or more newline-separated lines.  Each line must be one of the following:

=over 4

=item *

A single hexadecimal number denoting a code point to include.

=item *

Two hexadecimal numbers separated by horizontal whitespace (space or
tabular characters) denoting a range of code points to include.

=item *

Something to include, prefixed by C<"+">: a built-in character
property (prefixed by C<"utf8::">) or a fully qualified (including package
name) user-defined character property,
to represent all the characters in that property; two hexadecimal code
points for a range; or a single hexadecimal code point.

=item *

Something to exclude, prefixed by C<"-">: an existing character
property (prefixed by C<"utf8::">) or a fully qualified (including package
name) user-defined character property,
to represent all the characters in that property; two hexadecimal code
points for a range; or a single hexadecimal code point.

=item *

Something to negate, prefixed C<"!">: an existing character
property (prefixed by C<"utf8::">) or a fully qualified (including package
name) user-defined character property,
to represent all the characters in that property; two hexadecimal code
points for a range; or a single hexadecimal code point.

=item *

Something to intersect with, prefixed by C<"&">: an existing character
property (prefixed by C<"utf8::">) or a fully qualified (including package
name) user-defined character property,
for all the characters except the characters in the property; two
hexadecimal code points for a range; or a single hexadecimal code point.

=back

For example, to define a property that covers both the Japanese
syllabaries (hiragana and katakana), you can define

    sub InKana {
        return <<END;
    3040\t309F
    30A0\t30FF
    END
    }

Imagine that the here-doc end marker is at the beginning of the line.
Now you can use C<\p{InKana}> and C<\P{InKana}>.

You could also have used the existing block property names:

    sub InKana {
        return <<'END';
    +utf8::InHiragana
    +utf8::InKatakana
    END
    }

Suppose you wanted to match only the allocated characters,
not the raw block ranges: in other words, you want to remove
the unassigned characters:

    sub InKana {
        return <<'END';
    +utf8::InHiragana
    +utf8::InKatakana
    -utf8::IsCn
    END
    }

The negation is useful for defining (surprise!) negated classes.

    sub InNotKana {
        return <<'END';
    !utf8::InHiragana
    -utf8::InKatakana
    +utf8::IsCn
    END
    }

This will match all non-Unicode code points, since every one of them is
not in Kana.  You can use intersection to exclude these, if desired, as
this modified example shows:

    sub InNotKana {
        return <<'END';
    !utf8::InHiragana
    -utf8::InKatakana
    +utf8::IsCn
    &utf8::Any
    END
    }

C<&utf8::Any> must be the last line in the definition.

Intersection is used generally for getting the common characters matched
by two (or more) classes.  It's important to remember not to use C<"&"> for
the first set; that would be intersecting with nothing, resulting in an
empty set.

Unlike non-user-defined C<\p{}> property matches, no warning is ever
generated if these properties are matched against a non-Unicode code
point (see L</Beyond Unicode code points> below).

=head2 User-Defined Case Mappings (for serious hackers only)

B<This feature has been removed as of Perl 5.16.>
The CPAN module C<L<Unicode::Casing>> provides better functionality without
the drawbacks that this feature had.  If you are using a Perl earlier
than 5.16, this feature was most fully documented in the 5.14 version of
this pod:
L<http://perldoc.perl.org/5.14.0/perlunicode.html#User-Defined-Case-Mappings-%28for-serious-hackers-only%29>

=head2 Character Encodings for Input and Output

See L<Encode>.

=head2 Unicode Regular Expression Support Level

The following list of Unicode supported features for regular expressions describes
all features currently directly supported by core Perl.  The references to "Level N"
and the section numbers refer to the Unicode Technical Standard #18,
"Unicode Regular Expressions", version 13, from August 2008.

=over 4

=item *

Level 1 - Basic Unicode Support

 RL1.1   Hex Notation                     - done          [1]
 RL1.2   Properties                       - done          [2][3]
 RL1.2a  Compatibility Properties         - done          [4]
 RL1.3   Subtraction and Intersection     - experimental  [5]
 RL1.4   Simple Word Boundaries           - done          [6]
 RL1.5   Simple Loose Matches             - done          [7]
 RL1.6   Line Boundaries                  - MISSING       [8][9]
 RL1.7   Supplementary Code Points        - done          [10]

=over 4

=item [1] C<\N{U+...}> and C<\x{...}>

=item [2] C<\p{...}> C<\P{...}>

=item [3] supports not only minimal list, but all Unicode character
properties (see Unicode Character Properties above)

=item [4] C<\d> C<\D> C<\s> C<\S> C<\w> C<\W> C<\X> C<[:I<prop>:]>
C<[:^I<prop>:]>

=item [5] The experimental feature starting in v5.18 C<"(?[...])"> accomplishes
this.

See L<perlre/(?[ ])>.  If you don't want to use an experimental
feature, you can use one of the following:

=over 4

=item *

Regular expression lookahead

You can mimic class subtraction using lookahead.
For example, what UTS#18 might write as

    [{Block=Greek}-[{UNASSIGNED}]]

in Perl can be written as:

    (?!\p{Unassigned})\p{Block=Greek}
    (?=\p{Assigned})\p{Block=Greek}

But in this particular example, you probably really want

    \p{Greek}

which will match assigned characters known to be part of the Greek script.

=item *

CPAN module C<L<Unicode::Regex::Set>>

It does implement the full UTS#18 grouping, intersection, union, and
removal (subtraction) syntax.

=item *

L</"User-Defined Character Properties">

C<"+"> for union, C<"-"> for removal (set-difference), C<"&"> for intersection

=back

=item [6] C<\b> C<\B>

=item [7]
Note that Perl does Full case-folding in matching, not Simple:

For example C<U+1F88> is equivalent to C<U+1F00 U+03B9>, instead of just
C<U+1F80>.  This difference matters mainly for certain Greek capital
letters with certain modifiers: the Full case-folding decomposes the
letter, while the Simple case-folding would map it to a single
character.

=item [8]
Perl treats C<\n> as the start- and end-line delimiter.  Unicode
specifies more characters that should be so-interpreted.

These are:

 VT   U+000B  (\v in C)
 FF   U+000C  (\f)
 CR   U+000D  (\r)
 NEL  U+0085
 LS   U+2028
 PS   U+2029

C<^> and C<$> in regular expression patterns are supposed to match all
these, but don't.
These characters also don't, but should, affect C<< <> >> C<$.>, and
script line numbers.

Also, lines should not be split within C<CRLF> (i.e. there is no
empty line between C<\r> and C<\n>).  For C<CRLF>, try the C<:crlf>
layer (see L<PerlIO>).

=item [9] But C<qr/\b{lb}/> and C<L<Unicode::LineBreak>> are available.

L<C<qrE<sol>\b{lb}E<sol>>|perlrebackslash/\b{lb}> supplies default line
breaking conformant with
L<UAX#14 "Unicode Line Breaking Algorithm"|http://www.unicode.org/reports/tr14>.

And, the module C<L<Unicode::LineBreak>> also conformant with UAX#14,
provides customizable line breaking.

=item [10]
UTF-8/UTF-EBDDIC used in Perl allows not only C<U+10000> to
C<U+10FFFF> but also beyond C<U+10FFFF>

=back

=item *

Level 2 - Extended Unicode Support

 RL2.1   Canonical Equivalents           - MISSING       [10][11]
 RL2.2   Default Grapheme Clusters       - MISSING       [12]
 RL2.3   Default Word Boundaries         - DONE          [14]
 RL2.4   Default Loose Matches           - MISSING       [15]
 RL2.5   Name Properties                 - DONE
 RL2.6   Wildcard Properties             - MISSING

 [10] see UAX#15 "Unicode Normalization Forms"
 [11] have Unicode::Normalize but not integrated to regexes
 [12] have \X and \b{gcb} but we don't have a "Grapheme Cluster
      Mode"
 [14] see UAX#29, Word Boundaries
 [15] This is covered in Chapter 3.13 (in Unicode 6.0)

=item *

Level 3 - Tailored Support

 RL3.1   Tailored Punctuation            - MISSING
 RL3.2   Tailored Grapheme Clusters      - MISSING       [17][18]
 RL3.3   Tailored Word Boundaries        - MISSING
 RL3.4   Tailored Loose Matches          - MISSING
 RL3.5   Tailored Ranges                 - MISSING
 RL3.6   Context Matching                - MISSING       [19]
 RL3.7   Incremental Matches             - MISSING
      ( RL3.8   Unicode Set Sharing )
 RL3.9   Possible Match Sets             - MISSING
 RL3.10  Folded Matching                 - MISSING       [20]
 RL3.11  Submatchers                     - MISSING

 [17] see UAX#10 "Unicode Collation Algorithms"
 [18] have Unicode::Collate but not integrated to regexes
 [19] have (?<=x) and (?=x), but lookaheads or lookbehinds
      should see outside of the target substring
 [20] need insensitive matching for linguistic features other
      than case; for example, hiragana to katakana, wide and
      narrow, simplified Han to traditional Han (see UTR#30
      "Character Foldings")

=back

=head2 Unicode Encodings

Unicode characters are assigned to I<code points>, which are abstract
numbers.  To use these numbers, various encodings are needed.

=over 4

=item *

UTF-8

UTF-8 is a variable-length (1 to 4 bytes), byte-order independent
encoding.  In most of Perl's documentation, including elsewhere in this
document, the term "UTF-8" means also "UTF-EBCDIC".  But in this section,
"UTF-8" refers only to the encoding used on ASCII platforms.  It is a
superset of 7-bit US-ASCII, so anything encoded in ASCII has the
identical representation when encoded in UTF-8.

The following table is from Unicode 3.2.

 Code Points            1st Byte  2nd Byte  3rd Byte 4th Byte

   U+0000..U+007F       00..7F
   U+0080..U+07FF     * C2..DF    80..BF
   U+0800..U+0FFF       E0      * A0..BF    80..BF
   U+1000..U+CFFF       E1..EC    80..BF    80..BF
   U+D000..U+D7FF       ED        80..9F    80..BF
   U+D800..U+DFFF       +++++ utf16 surrogates, not legal utf8 +++++
   U+E000..U+FFFF       EE..EF    80..BF    80..BF
  U+10000..U+3FFFF      F0      * 90..BF    80..BF    80..BF
  U+40000..U+FFFFF      F1..F3    80..BF    80..BF    80..BF
 U+100000..U+10FFFF     F4        80..8F    80..BF    80..BF

Note the gaps marked by "*" before several of the byte entries above.  These are
caused by legal UTF-8 avoiding non-shortest encodings: it is technically
possible to UTF-8-encode a single code point in different ways, but that is
explicitly forbidden, and the shortest possible encoding should always be used
(and that is what Perl does).

Another way to look at it is via bits:

                Code Points  1st Byte  2nd Byte  3rd Byte  4th Byte

                   0aaaaaaa  0aaaaaaa
           00000bbbbbaaaaaa  110bbbbb  10aaaaaa
           ccccbbbbbbaaaaaa  1110cccc  10bbbbbb  10aaaaaa
 00000dddccccccbbbbbbaaaaaa  11110ddd  10cccccc  10bbbbbb  10aaaaaa

As you can see, the continuation bytes all begin with C<"10">, and the
leading bits of the start byte tell how many bytes there are in the
encoded character.

The original UTF-8 specification allowed up to 6 bytes, to allow
encoding of numbers up to C<0x7FFF_FFFF>.  Perl continues to allow those,
and has extended that up to 13 bytes to encode code points up to what
can fit in a 64-bit word.  However, Perl will warn if you output any of
these as being non-portable; and under strict UTF-8 input protocols,
they are forbidden.  In addition, it is deprecated to use a code point
larger than what a signed integer variable on your system can hold.  On
32-bit ASCII systems, this means C<0x7FFF_FFFF> is the legal maximum
going forward (much higher on 64-bit systems).

=item *

UTF-EBCDIC

Like UTF-8, but EBCDIC-safe, in the way that UTF-8 is ASCII-safe.
This means that all the basic characters (which includes all
those that have ASCII equivalents (like C<"A">, C<"0">, C<"%">, I<etc.>)
are the same in both EBCDIC and UTF-EBCDIC.)

UTF-EBCDIC is used on EBCDIC platforms.  It generally requires more
bytes to represent a given code point than UTF-8 does; the largest
Unicode code points take 5 bytes to represent (instead of 4 in UTF-8),
and, extended for 64-bit words, it uses 14 bytes instead of 13 bytes in
UTF-8.

=item *

UTF-16, UTF-16BE, UTF-16LE, Surrogates, and C<BOM>'s (Byte Order Marks)

The followings items are mostly for reference and general Unicode
knowledge, Perl doesn't use these constructs internally.

Like UTF-8, UTF-16 is a variable-width encoding, but where
UTF-8 uses 8-bit code units, UTF-16 uses 16-bit code units.
All code points occupy either 2 or 4 bytes in UTF-16: code points
C<U+0000..U+FFFF> are stored in a single 16-bit unit, and code
points C<U+10000..U+10FFFF> in two 16-bit units.  The latter case is
using I<surrogates>, the first 16-bit unit being the I<high
surrogate>, and the second being the I<low surrogate>.

Surrogates are code points set aside to encode the C<U+10000..U+10FFFF>
range of Unicode code points in pairs of 16-bit units.  The I<high
surrogates> are the range C<U+D800..U+DBFF> and the I<low surrogates>
are the range C<U+DC00..U+DFFF>.  The surrogate encoding is

    $hi = ($uni - 0x10000) / 0x400 + 0xD800;
    $lo = ($uni - 0x10000) % 0x400 + 0xDC00;

and the decoding is

    $uni = 0x10000 + ($hi - 0xD800) * 0x400 + ($lo - 0xDC00);

Because of the 16-bitness, UTF-16 is byte-order dependent.  UTF-16
itself can be used for in-memory computations, but if storage or
transfer is required either UTF-16BE (big-endian) or UTF-16LE
(little-endian) encodings must be chosen.

This introduces another problem: what if you just know that your data
is UTF-16, but you don't know which endianness?  Byte Order Marks, or
C<BOM>'s, are a solution to this.  A special character has been reserved
in Unicode to function as a byte order marker: the character with the
code point C<U+FEFF> is the C<BOM>.

The trick is that if you read a C<BOM>, you will know the byte order,
since if it was written on a big-endian platform, you will read the
bytes C<0xFE 0xFF>, but if it was written on a little-endian platform,
you will read the bytes C<0xFF 0xFE>.  (And if the originating platform
was writing in ASCII platform UTF-8, you will read the bytes
C<0xEF 0xBB 0xBF>.)

The way this trick works is that the character with the code point
C<U+FFFE> is not supposed to be in input streams, so the
sequence of bytes C<0xFF 0xFE> is unambiguously "C<BOM>, represented in
little-endian format" and cannot be C<U+FFFE>, represented in big-endian
format".

Surrogates have no meaning in Unicode outside their use in pairs to
represent other code points.  However, Perl allows them to be
represented individually internally, for example by saying
C<chr(0xD801)>, so that all code points, not just those valid for open
interchange, are
representable.  Unicode does define semantics for them, such as their
C<L</General_Category>> is C<"Cs">.  But because their use is somewhat dangerous,
Perl will warn (using the warning category C<"surrogate">, which is a
sub-category of C<"utf8">) if an attempt is made
to do things like take the lower case of one, or match
case-insensitively, or to output them.  (But don't try this on Perls
before 5.14.)

=item *

UTF-32, UTF-32BE, UTF-32LE

The UTF-32 family is pretty much like the UTF-16 family, except that
the units are 32-bit, and therefore the surrogate scheme is not
needed.  UTF-32 is a fixed-width encoding.  The C<BOM> signatures are
C<0x00 0x00 0xFE 0xFF> for BE and C<0xFF 0xFE 0x00 0x00> for LE.

=item *

UCS-2, UCS-4

Legacy, fixed-width encodings defined by the ISO 10646 standard.  UCS-2 is a 16-bit
encoding.  Unlike UTF-16, UCS-2 is not extensible beyond C<U+FFFF>,
because it does not use surrogates.  UCS-4 is a 32-bit encoding,
functionally identical to UTF-32 (the difference being that
UCS-4 forbids neither surrogates nor code points larger than C<0x10_FFFF>).

=item *

UTF-7

A seven-bit safe (non-eight-bit) encoding, which is useful if the
transport or storage is not eight-bit safe.  Defined by RFC 2152.

=back

=head2 Noncharacter code points

66 code points are set aside in Unicode as "noncharacter code points".
These all have the C<Unassigned> (C<Cn>) C<L</General_Category>>, and
no character will ever be assigned to any of them.  They are the 32 code
points between C<U+FDD0> and C<U+FDEF> inclusive, and the 34 code
points:

 U+FFFE   U+FFFF
 U+1FFFE  U+1FFFF
 U+2FFFE  U+2FFFF
 ...
 U+EFFFE  U+EFFFF
 U+FFFFE  U+FFFFF
 U+10FFFE U+10FFFF

Until Unicode 7.0, the noncharacters were "B<forbidden> for use in open
interchange of Unicode text data", so that code that processed those
streams could use these code points as sentinels that could be mixed in
with character data, and would always be distinguishable from that data.
(Emphasis above and in the next paragraph are added in this document.)

Unicode 7.0 changed the wording so that they are "B<not recommended> for
use in open interchange of Unicode text data".  The 7.0 Standard goes on
to say:

=over 4

"If a noncharacter is received in open interchange, an application is
not required to interpret it in any way.  It is good practice, however,
to recognize it as a noncharacter and to take appropriate action, such
as replacing it with C<U+FFFD> replacement character, to indicate the
problem in the text.  It is not recommended to simply delete
noncharacter code points from such text, because of the potential
security issues caused by deleting uninterpreted characters.  (See
conformance clause C7 in Section 3.2, Conformance Requirements, and
L<Unicode Technical Report #36, "Unicode Security
Considerations"|http://www.unicode.org/reports/tr36/#Substituting_for_Ill_Formed_Subsequences>)."

=back

This change was made because it was found that various commercial tools
like editors, or for things like source code control, had been written
so that they would not handle program files that used these code points,
effectively precluding their use almost entirely!  And that was never
the intent.  They've always been meant to be usable within an
application, or cooperating set of applications, at will.

If you're writing code, such as an editor, that is supposed to be able
to handle any Unicode text data, then you shouldn't be using these code
points yourself, and instead allow them in the input.  If you need
sentinels, they should instead be something that isn't legal Unicode.
For UTF-8 data, you can use the bytes 0xC1 and 0xC2 as sentinels, as
they never appear in well-formed UTF-8.  (There are equivalents for
UTF-EBCDIC).  You can also store your Unicode code points in integer
variables and use negative values as sentinels.

If you're not writing such a tool, then whether you accept noncharacters
as input is up to you (though the Standard recommends that you not).  If
you do strict input stream checking with Perl, these code points
continue to be forbidden.  This is to maintain backward compatibility
(otherwise potential security holes could open up, as an unsuspecting
application that was written assuming the noncharacters would be
filtered out before getting to it, could now, without warning, start
getting them).  To do strict checking, you can use the layer
C<:encoding('UTF-8')>.

Perl continues to warn (using the warning category C<"nonchar">, which
is a sub-category of C<"utf8">) if an attempt is made to output
noncharacters.

=head2 Beyond Unicode code points

The maximum Unicode code point is C<U+10FFFF>, and Unicode only defines
operations on code points up through that.  But Perl works on code
points up to the maximum permissible unsigned number available on the
platform.  However, Perl will not accept these from input streams unless
lax rules are being used, and will warn (using the warning category
C<"non_unicode">, which is a sub-category of C<"utf8">) if any are output.

Since Unicode rules are not defined on these code points, if a
Unicode-defined operation is done on them, Perl uses what we believe are
sensible rules, while generally warning, using the C<"non_unicode">
category.  For example, C<uc("\x{11_0000}")> will generate such a
warning, returning the input parameter as its result, since Perl defines
the uppercase of every non-Unicode code point to be the code point
itself.  (All the case changing operations, not just uppercasing, work
this way.)

The situation with matching Unicode properties in regular expressions,
the C<\p{}> and C<\P{}> constructs, against these code points is not as
clear cut, and how these are handled has changed as we've gained
experience.

One possibility is to treat any match against these code points as
undefined.  But since Perl doesn't have the concept of a match being
undefined, it converts this to failing or C<FALSE>.  This is almost, but
not quite, what Perl did from v5.14 (when use of these code points
became generally reliable) through v5.18.  The difference is that Perl
treated all C<\p{}> matches as failing, but all C<\P{}> matches as
succeeding.

One problem with this is that it leads to unexpected, and confusting
results in some cases:

 chr(0x110000) =~ \p{ASCII_Hex_Digit=True}      # Failed on <= v5.18
 chr(0x110000) =~ \p{ASCII_Hex_Digit=False}     # Failed! on <= v5.18

That is, it treated both matches as undefined, and converted that to
false (raising a warning on each).  The first case is the expected
result, but the second is likely counterintuitive: "How could both be
false when they are complements?"  Another problem was that the
implementation optimized many Unicode property matches down to already
existing simpler, faster operations, which don't raise the warning.  We
chose to not forgo those optimizations, which help the vast majority of
matches, just to generate a warning for the unlikely event that an
above-Unicode code point is being matched against.

As a result of these problems, starting in v5.20, what Perl does is
to treat non-Unicode code points as just typical unassigned Unicode
characters, and matches accordingly.  (Note: Unicode has atypical
unassigned code points.  For example, it has noncharacter code points,
and ones that, when they do get assigned, are destined to be written
Right-to-left, as Arabic and Hebrew are.  Perl assumes that no
non-Unicode code point has any atypical properties.)

Perl, in most cases, will raise a warning when matching an above-Unicode
code point against a Unicode property when the result is C<TRUE> for
C<\p{}>, and C<FALSE> for C<\P{}>.  For example:

 chr(0x110000) =~ \p{ASCII_Hex_Digit=True}      # Fails, no warning
 chr(0x110000) =~ \p{ASCII_Hex_Digit=False}     # Succeeds, with warning

In both these examples, the character being matched is non-Unicode, so
Unicode doesn't define how it should match.  It clearly isn't an ASCII
hex digit, so the first example clearly should fail, and so it does,
with no warning.  But it is arguable that the second example should have
an undefined, hence C<FALSE>, result.  So a warning is raised for it.

Thus the warning is raised for many fewer cases than in earlier Perls,
and only when what the result is could be arguable.  It turns out that
none of the optimizations made by Perl (or are ever likely to be made)
cause the warning to be skipped, so it solves both problems of Perl's
earlier approach.  The most commonly used property that is affected by
this change is C<\p{Unassigned}> which is a short form for
C<\p{General_Category=Unassigned}>.  Starting in v5.20, all non-Unicode
code points are considered C<Unassigned>.  In earlier releases the
matches failed because the result was considered undefined.

The only place where the warning is not raised when it might ought to
have been is if optimizations cause the whole pattern match to not even
be attempted.  For example, Perl may figure out that for a string to
match a certain regular expression pattern, the string has to contain
the substring C<"foobar">.  Before attempting the match, Perl may look
for that substring, and if not found, immediately fail the match without
actually trying it; so no warning gets generated even if the string
contains an above-Unicode code point.

This behavior is more "Do what I mean" than in earlier Perls for most
applications.  But it catches fewer issues for code that needs to be
strictly Unicode compliant.  Therefore there is an additional mode of
operation available to accommodate such code.  This mode is enabled if a
regular expression pattern is compiled within the lexical scope where
the C<"non_unicode"> warning class has been made fatal, say by:

 use warnings FATAL => "non_unicode"

(see L<warnings>).  In this mode of operation, Perl will raise the
warning for all matches against a non-Unicode code point (not just the
arguable ones), and it skips the optimizations that might cause the
warning to not be output.  (It currently still won't warn if the match
isn't even attempted, like in the C<"foobar"> example above.)

In summary, Perl now normally treats non-Unicode code points as typical
Unicode unassigned code points for regular expression matches, raising a
warning only when it is arguable what the result should be.  However, if
this warning has been made fatal, it isn't skipped.

There is one exception to all this.  C<\p{All}> looks like a Unicode
property, but it is a Perl extension that is defined to be true for all
possible code points, Unicode or not, so no warning is ever generated
when matching this against a non-Unicode code point.  (Prior to v5.20,
it was an exact synonym for C<\p{Any}>, matching code points C<0>
through C<0x10FFFF>.)

=head2 Security Implications of Unicode

First, read
L<Unicode Security Considerations|http://www.unicode.org/reports/tr36>.

Also, note the following:

=over 4

=item *

Malformed UTF-8

Unfortunately, the original specification of UTF-8 leaves some room for
interpretation of how many bytes of encoded output one should generate
from one input Unicode character.  Strictly speaking, the shortest
possible sequence of UTF-8 bytes should be generated,
because otherwise there is potential for an input buffer overflow at
the receiving end of a UTF-8 connection.  Perl always generates the
shortest length UTF-8, and with warnings on, Perl will warn about
non-shortest length UTF-8 along with other malformations, such as the
surrogates, which are not Unicode code points valid for interchange.

=item *

Regular expression pattern matching may surprise you if you're not
accustomed to Unicode.  Starting in Perl 5.14, several pattern
modifiers are available to control this, called the character set
modifiers.  Details are given in L<perlre/Character set modifiers>.

=back

As discussed elsewhere, Perl has one foot (two hooves?) planted in
each of two worlds: the old world of ASCII and single-byte locales, and
the new world of Unicode, upgrading when necessary.
If your legacy code does not explicitly use Unicode, no automatic
switch-over to Unicode should happen.

=head2 Unicode in Perl on EBCDIC

Unicode is supported on EBCDIC platforms.  See L<perlebcdic>.

Unless ASCII vs. EBCDIC issues are specifically being discussed,
references to UTF-8 encoding in this document and elsewhere should be
read as meaning UTF-EBCDIC on EBCDIC platforms.
See L<perlebcdic/Unicode and UTF>.

Because UTF-EBCDIC is so similar to UTF-8, the differences are mostly
hidden from you; S<C<use utf8>> (and NOT something like
S<C<use utfebcdic>>) declares the the script is in the platform's
"native" 8-bit encoding of Unicode.  (Similarly for the C<":utf8">
layer.)

=head2 Locales

See L<perllocale/Unicode and UTF-8>

=head2 When Unicode Does Not Happen

There are still many places where Unicode (in some encoding or
another) could be given as arguments or received as results, or both in
Perl, but it is not, in spite of Perl having extensive ways to input and
output in Unicode, and a few other "entry points" like the C<@@ARGV>
array (which can sometimes be interpreted as UTF-8).

The following are such interfaces.  Also, see L</The "Unicode Bug">.
For all of these interfaces Perl
currently (as of v5.16.0) simply assumes byte strings both as arguments
and results, or UTF-8 strings if the (deprecated) C<encoding> pragma has been used.

One reason that Perl does not attempt to resolve the role of Unicode in
these situations is that the answers are highly dependent on the operating
system and the file system(s).  For example, whether filenames can be
in Unicode and in exactly what kind of encoding, is not exactly a
portable concept.  Similarly for C<qx> and C<system>: how well will the
"command-line interface" (and which of them?) handle Unicode?

=over 4

=item *

C<chdir>, C<chmod>, C<chown>, C<chroot>, C<exec>, C<link>, C<lstat>, C<mkdir>,
C<rename>, C<rmdir>, C<stat>, C<symlink>, C<truncate>, C<unlink>, C<utime>, C<-X>

=item *

C<%ENV>

=item *

C<glob> (aka the C<E<lt>*E<gt>>)

=item *

C<open>, C<opendir>, C<sysopen>

=item *

C<qx> (aka the backtick operator), C<system>

=item *

C<readdir>, C<readlink>

=back

=head2 The "Unicode Bug"

The term, "Unicode bug" has been applied to an inconsistency with the
code points in the C<Latin-1 Supplement> block, that is, between
128 and 255.  Without a locale specified, unlike all other characters or
code points, these characters can have very different semantics
depending on the rules in effect.  (Characters whose code points are
above 255 force Unicode rules; whereas the rules for ASCII characters
are the same under both ASCII and Unicode rules.)

Under Unicode rules, these upper-Latin1 characters are interpreted as
Unicode code points, which means they have the same semantics as Latin-1
(ISO-8859-1) and C1 controls.

As explained in L</ASCII Rules versus Unicode Rules>, under ASCII rules,
they are considered to be unassigned characters.

This can lead to unexpected results.  For example, a string's
semantics can suddenly change if a code point above 255 is appended to
it, which changes the rules from ASCII to Unicode.  As an
example, consider the following program and its output:

 $ perl -le'
     no feature 'unicode_strings';
     $s1 = "\xC2";
     $s2 = "\x{2660}";
     for ($s1, $s2, $s1.$s2) {
         print /\w/ || 0;
     }
 '
 0
 0
 1

If there's no C<\w> in C<s1> nor in C<s2>, why does their concatenation
have one?

This anomaly stems from Perl's attempt to not disturb older programs that
didn't use Unicode, along with Perl's desire to add Unicode support
seamlessly.  But the result turned out to not be seamless.  (By the way,
you can choose to be warned when things like this happen.  See
C<L<encoding::warnings>>.)

L<S<C<use feature 'unicode_strings'>>|feature/The 'unicode_strings' feature>
was added, starting in Perl v5.12, to address this problem.  It affects
these things:

=over 4

=item *

Changing the case of a scalar, that is, using C<uc()>, C<ucfirst()>, C<lc()>,
and C<lcfirst()>, or C<\L>, C<\U>, C<\u> and C<\l> in double-quotish
contexts, such as regular expression substitutions.

Under C<unicode_strings> starting in Perl 5.12.0, Unicode rules are
generally used.  See L<perlfunc/lc> for details on how this works
in combination with various other pragmas.

=item *

Using caseless (C</i>) regular expression matching.

Starting in Perl 5.14.0, regular expressions compiled within
the scope of C<unicode_strings> use Unicode rules
even when executed or compiled into larger
regular expressions outside the scope.

=item *

Matching any of several properties in regular expressions.

These properties are C<\b> (without braces), C<\B> (without braces),
C<\s>, C<\S>, C<\w>, C<\W>, and all the Posix character classes
I<except> C<[[:ascii:]]>.

Starting in Perl 5.14.0, regular expressions compiled within
the scope of C<unicode_strings> use Unicode rules
even when executed or compiled into larger
regular expressions outside the scope.

=item *

In C<quotemeta> or its inline equivalent C<\Q>.

Starting in Perl 5.16.0, consistent quoting rules are used within the
scope of C<unicode_strings>, as described in L<perlfunc/quotemeta>.
Prior to that, or outside its scope, no code points above 127 are quoted
in UTF-8 encoded strings, but in byte encoded strings, code points
between 128-255 are always quoted.

=back

You can see from the above that the effect of C<unicode_strings>
increased over several Perl releases.  (And Perl's support for Unicode
continues to improve; it's best to use the latest available release in
order to get the most complete and accurate results possible.)  Note that
C<unicode_strings> is automatically chosen if you S<C<use 5.012>> or
higher.

For Perls earlier than those described above, or when a string is passed
to a function outside the scope of C<unicode_strings>, see the next section.

=head2 Forcing Unicode in Perl (Or Unforcing Unicode in Perl)

Sometimes (see L</"When Unicode Does Not Happen"> or L</The "Unicode Bug">)
there are situations where you simply need to force a byte
string into UTF-8, or vice versa.  The standard module L<Encode> can be
used for this, or the low-level calls
L<C<utf8::upgrade($bytestring)>|utf8/Utility functions> and
L<C<utf8::downgrade($utf8string[, FAIL_OK])>|utf8/Utility functions>.

Note that C<utf8::downgrade()> can fail if the string contains characters
that don't fit into a byte.

Calling either function on a string that already is in the desired state is a
no-op.

L</ASCII Rules versus Unicode Rules> gives all the ways that a string is
made to use Unicode rules.

=head2 Using Unicode in XS

See L<perlguts/"Unicode Support"> for an introduction to Unicode at
the XS level, and L<perlapi/Unicode Support> for the API details.

=head2 Hacking Perl to work on earlier Unicode versions (for very serious hackers only)

Perl by default comes with the latest supported Unicode version built-in, but
the goal is to allow you to change to use any earlier one.  In Perls
v5.20 and v5.22, however, the earliest usable version is Unicode 5.1.
Perl v5.18 is able to handle all earlier versions.

Download the files in the desired version of Unicode from the Unicode web
site L<http://www.unicode.org>).  These should replace the existing files in
F<lib/unicore> in the Perl source tree.  Follow the instructions in
F<README.perl> in that directory to change some of their names, and then build
perl (see L<INSTALL>).

=head2 Porting code from perl-5.6.X

Perls starting in 5.8 have a different Unicode model from 5.6. In 5.6 the
programmer was required to use the C<utf8> pragma to declare that a
given scope expected to deal with Unicode data and had to make sure that
only Unicode data were reaching that scope. If you have code that is
working with 5.6, you will need some of the following adjustments to
your code. The examples are written such that the code will continue to
work under 5.6, so you should be safe to try them out.

=over 3

=item *

A filehandle that should read or write UTF-8

  if ($] > 5.008) {
    binmode $fh, ":encoding(utf8)";
  }

=item *

A scalar that is going to be passed to some extension

Be it C<Compress::Zlib>, C<Apache::Request> or any extension that has no
mention of Unicode in the manpage, you need to make sure that the
UTF8 flag is stripped off. Note that at the time of this writing
(January 2012) the mentioned modules are not UTF-8-aware. Please
check the documentation to verify if this is still true.

  if ($] > 5.008) {
    require Encode;
    $val = Encode::encode_utf8($val); # make octets
  }

=item *

A scalar we got back from an extension

If you believe the scalar comes back as UTF-8, you will most likely
want the UTF8 flag restored:

  if ($] > 5.008) {
    require Encode;
    $val = Encode::decode_utf8($val);
  }

=item *

Same thing, if you are really sure it is UTF-8

  if ($] > 5.008) {
    require Encode;
    Encode::_utf8_on($val);
  }

=item *

A wrapper for L<DBI> C<fetchrow_array> and C<fetchrow_hashref>

When the database contains only UTF-8, a wrapper function or method is
a convenient way to replace all your C<fetchrow_array> and
C<fetchrow_hashref> calls. A wrapper function will also make it easier to
adapt to future enhancements in your database driver. Note that at the
time of this writing (January 2012), the DBI has no standardized way
to deal with UTF-8 data. Please check the L<DBI documentation|DBI> to verify if
that is still true.

  sub fetchrow {
    # $what is one of fetchrow_{array,hashref}
    my($self, $sth, $what) = @@_;
    if ($] < 5.008) {
      return $sth->$what;
    } else {
      require Encode;
      if (wantarray) {
        my @@arr = $sth->$what;
        for (@@arr) {
          defined && /[^\000-\177]/ && Encode::_utf8_on($_);
        }
        return @@arr;
      } else {
        my $ret = $sth->$what;
        if (ref $ret) {
          for my $k (keys %$ret) {
            defined
            && /[^\000-\177]/
            && Encode::_utf8_on($_) for $ret->{$k};
          }
          return $ret;
        } else {
          defined && /[^\000-\177]/ && Encode::_utf8_on($_) for $ret;
          return $ret;
        }
      }
    }
  }


=item *

A large scalar that you know can only contain ASCII

Scalars that contain only ASCII and are marked as UTF-8 are sometimes
a drag to your program. If you recognize such a situation, just remove
the UTF8 flag:

  utf8::downgrade($val) if $] > 5.008;

=back

=head1 BUGS

See also L</The "Unicode Bug"> above.

=head2 Interaction with Extensions

When Perl exchanges data with an extension, the extension should be
able to understand the UTF8 flag and act accordingly. If the
extension doesn't recognize that flag, it's likely that the extension
will return incorrectly-flagged data.

So if you're working with Unicode data, consult the documentation of
every module you're using if there are any issues with Unicode data
exchange. If the documentation does not talk about Unicode at all,
suspect the worst and probably look at the source to learn how the
module is implemented. Modules written completely in Perl shouldn't
cause problems. Modules that directly or indirectly access code written
in other programming languages are at risk.

For affected functions, the simple strategy to avoid data corruption is
to always make the encoding of the exchanged data explicit. Choose an
encoding that you know the extension can handle. Convert arguments passed
to the extensions to that encoding and convert results back from that
encoding. Write wrapper functions that do the conversions for you, so
you can later change the functions when the extension catches up.

To provide an example, let's say the popular C<Foo::Bar::escape_html>
function doesn't deal with Unicode data yet. The wrapper function
would convert the argument to raw UTF-8 and convert the result back to
Perl's internal representation like so:

    sub my_escape_html ($) {
        my($what) = shift;
        return unless defined $what;
        Encode::decode_utf8(Foo::Bar::escape_html(
                                         Encode::encode_utf8($what)));
    }

Sometimes, when the extension does not convert data but just stores
and retrieves it, you will be able to use the otherwise
dangerous L<C<Encode::_utf8_on()>|Encode/_utf8_on> function. Let's say
the popular C<Foo::Bar> extension, written in C, provides a C<param>
method that lets you store and retrieve data according to these prototypes:

    $self->param($name, $value);            # set a scalar
    $value = $self->param($name);           # retrieve a scalar

If it does not yet provide support for any encoding, one could write a
derived class with such a C<param> method:

    sub param {
      my($self,$name,$value) = @@_;
      utf8::upgrade($name);     # make sure it is UTF-8 encoded
      if (defined $value) {
        utf8::upgrade($value);  # make sure it is UTF-8 encoded
        return $self->SUPER::param($name,$value);
      } else {
        my $ret = $self->SUPER::param($name);
        Encode::_utf8_on($ret); # we know, it is UTF-8 encoded
        return $ret;
      }
    }

Some extensions provide filters on data entry/exit points, such as
C<DB_File::filter_store_key> and family. Look out for such filters in
the documentation of your extensions; they can make the transition to
Unicode data much easier.

=head2 Speed

Some functions are slower when working on UTF-8 encoded strings than
on byte encoded strings.  All functions that need to hop over
characters such as C<length()>, C<substr()> or C<index()>, or matching
regular expressions can work B<much> faster when the underlying data are
byte-encoded.

In Perl 5.8.0 the slowness was often quite spectacular; in Perl 5.8.1
a caching scheme was introduced which improved the situation.  In general,
operations with UTF-8 encoded strings are still slower. As an example,
the Unicode properties (character classes) like C<\p{Nd}> are known to
be quite a bit slower (5-20 times) than their simpler counterparts
like C<[0-9]> (then again, there are hundreds of Unicode characters matching
C<Nd> compared with the 10 ASCII characters matching C<[0-9]>).

=head1 SEE ALSO

L<perlunitut>, L<perluniintro>, L<perluniprops>, L<Encode>, L<open>, L<utf8>, L<bytes>,
L<perlretut>, L<perlvar/"${^UNICODE}">,
L<http://www.unicode.org/reports/tr44>).

=cut
@


1.1
log
@Initial revision
@
text
@d7 2
a8 1
=head2 Important Caveat
d10 28
a37 1
WARNING: The implementation of Unicode support in Perl is incomplete.
d39 185
a223 1
The following areas need further work.
d227 77
a303 1
=item Input and Output Disciplines
d305 2
a306 3
There is currently no easy way to mark data read from a file or other
external source as being utf8.  This will be one of the major areas of
focus in the near future.
d308 1
a308 1
=item Regular Expressions
d310 1
a310 6
The existing regular expression compiler does not produce polymorphic
opcodes.  This means that the determination on whether to match Unicode
characters is made when the pattern is compiled, based on whether the
pattern contains Unicode characters, and not when the matching happens
at run time.  This needs to be changed to adaptively match Unicode if
the string to be matched is Unicode.
d312 17
a328 1
=item C<use utf8> still needed to enable a few features
d330 2
a331 3
The C<utf8> pragma implements the tables used for Unicode support.  These
tables are automatically loaded on demand, so the C<utf8> pragma need not
normally be used.
d333 14
a346 3
However, as a compatibility measure, this pragma must be explicitly used
to enable recognition of UTF-8 encoded literals and identifiers in the
source text.
d350 470
a819 1
=head2 Byte and Character semantics
d821 1
a821 3
Beginning with version 5.6, Perl uses logically wide characters to
represent strings internally.  This internal representation of strings
uses the UTF-8 encoding.
d823 1
a823 2
In future, Perl-level operations can be expected to work with characters
rather than bytes, in general.
d825 1
a825 7
However, as strictly an interim compatibility measure, Perl v5.6 aims to
provide a safe migration path from byte semantics to character semantics
for programs.  For operations where Perl can unambiguously decide that the
input data is characters, Perl now switches to character semantics.
For operations where this determination cannot be made without additional
information from the user, Perl decides in favor of compatibility, and
chooses to use byte semantics.
d827 1
a827 6
This behavior preserves compatibility with earlier versions of Perl,
which allowed byte semantics in Perl operations, but only as long as
none of the program's inputs are marked as being as source of Unicode
character data.  Such data may come from filehandles, from calls to
external programs, from information provided by the system (such as %ENV),
or from literals and constants in the source text.
d829 1
a829 4
If the C<-C> command line switch is used, (or the ${^WIDE_SYSTEM_CALLS}
global flag is set to C<1>), all system calls will use the
corresponding wide character APIs.  This is currently only implemented
on Windows.
d831 3
a833 2
Regardless of the above, the C<bytes> pragma can always be used to force
byte semantics in a particular lexical scope.  See L<bytes>.
d835 1
a835 6
The C<utf8> pragma is primarily a compatibility device that enables
recognition of UTF-8 in literals encountered by the parser.  It may also
be used for enabling some of the more experimental Unicode support features.
Note that this pragma is only required until a future version of Perl
in which character semantics will become the default.  This pragma may
then become a no-op.  See L<utf8>.
d837 2
a838 8
Unless mentioned otherwise, Perl operators will use character semantics
when they are dealing with Unicode data, and byte semantics otherwise.
Thus, character semantics for these operations apply transparently; if
the input data came from a Unicode source (for example, by adding a
character encoding discipline to the filehandle whence it came, or a
literal UTF-8 string constant in the program), character semantics
apply; otherwise, byte semantics are in effect.  To force byte semantics
on Unicode data, the C<bytes> pragma should be used.
d840 5
a844 10
Under character semantics, many operations that formerly operated on
bytes change to operating on characters.  For ASCII data this makes
no difference, because UTF-8 stores ASCII in single bytes, but for
any character greater than C<chr(127)>, the character may be stored in
a sequence of two or more bytes, all of which have the high bit set.
But by and large, the user need not worry about this, because Perl
hides it from the user.  A character in Perl is logically just a number
ranging from 0 to 2**32 or so.  Larger characters encode to longer
sequences of bytes internally, but again, this is just an internal
detail which is hidden at the Perl level.
d846 5
a850 1
=head2 Effects of character semantics
d852 90
a941 1
Character semantics have the following effects:
d947 1
a947 2
Strings and patterns may contain characters that have an ordinal value
larger than 255.
d949 4
a952 12
Presuming you use a Unicode editor to edit your program, such characters
will typically occur directly within the literal strings as UTF-8
characters, but you can also specify a particular character with an
extension of the C<\x> notation.  UTF-8 characters are specified by
putting the hexadecimal code within curlies after the C<\x>.  For instance,
a Unicode smiley face is C<\x{263A}>.  A character in the Latin-1 range
(128..255) should be written C<\x{ab}> rather than C<\xab>, since the
former will turn into a two-byte UTF-8 code, while the latter will
continue to be interpreted as generating a 8-bit byte rather than a
character.  In fact, if the C<use warnings> pragma of the C<-w> switch
is turned on, it will produce a warning
that you might be generating invalid UTF-8.
d956 5
a960 4
Identifiers within the Perl script may contain Unicode alphanumeric
characters, including ideographs.  (You are currently on your own when
it comes to using the canonical forms of characters--Perl doesn't (yet)
attempt to canonicalize variable names for you.)
d964 5
a968 4
Regular expressions match characters instead of bytes.  For instance,
"." matches a character instead of a byte.  (However, the C<\C> pattern
is provided to force a match a single byte ("C<char>" in C, hence
C<\C>).)
d972 5
a976 4
Character classes in regular expressions match characters instead of
bytes, and match against the character properties specified in the
Unicode properties database.  So C<\w> can be used to match an ideograph,
for instance.
d980 130
a1109 7
Named Unicode properties and block ranges make be used as character
classes via the new C<\p{}> (matches property) and C<\P{}> (doesn't
match property) constructs.  For instance, C<\p{Lu}> matches any
character with the Unicode uppercase property, while C<\p{M}> matches
any mark character.  Single letter properties may omit the brackets, so
that can be written C<\pM> also.  Many predefined character classes are
available, such as C<\p{IsMirrored}> and  C<\p{InTibetan}>.
d1113 17
a1129 5
The special pattern C<\X> match matches any extended Unicode sequence
(a "combining character sequence" in Standardese), where the first
character is a base character and subsequent characters are mark
characters that apply to the base character.  It is equivalent to
C<(?:\PM\pM*)>.
d1133 272
a1404 3
The C<tr///> operator translates characters instead of bytes.  It can also
be forced to translate between 8-bit codes and UTF-8.  For instance, if you
know your input in Latin-1, you can say:
d1406 441
a1846 4
    while (<>) {
	tr/\0-\xff//CU;		# latin1 char to utf8
	...
    }
d1848 1
a1848 1
Similarly you could translate your output with
d1850 1
a1850 1
    tr/\0-\x{ff}//UC;		# utf8 to latin1 char
d1852 5
a1856 1
No, C<s///> doesn't take /U or /C (yet?).
d1860 12
a1871 5
Case translation operators use the Unicode case translation tables
when provided character input.  Note that C<uc()> translates to
uppercase, while C<ucfirst> translates to titlecase (for languages
that make the distinction).  Naturally the corresponding backslash
sequences have the same semantics.
d1875 9
a1883 8
Most operators that deal with positions or lengths in the string will
automatically switch to using character positions, including C<chop()>,
C<substr()>, C<pos()>, C<index()>, C<rindex()>, C<sprintf()>,
C<write()>, and C<length()>.  Operators that specifically don't switch
include C<vec()>, C<pack()>, and C<unpack()>.  Operators that really
don't care include C<chomp()>, as well as any other operator that
treats a string as a bucket of bits, such as C<sort()>, and the
operators dealing with filenames.
d1887 6
a1892 5
The C<pack()>/C<unpack()> letters "C<c>" and "C<C>" do I<not> change,
since they're often used for byte-oriented formats.  (Again, think
"C<char>" in the C language.)  However, there is a new "C<U>" specifier
that will convert between UTF-8 characters and integers.  (It works
outside of the utf8 pragma too.)
d1896 40
a1935 4
The C<chr()> and C<ord()> functions work on characters.  This is like
C<pack("U")> and C<unpack("U")>, not like C<pack("C")> and
C<unpack("C")>.  In fact, the latter are how you now emulate
byte-oriented C<chr()> and C<ord()> under utf8.
d1939 7
a1945 1
And finally, C<scalar reverse()> reverses by character rather than by byte.
d1949 1
a1949 1
=head2 Character encodings for input and output
d1951 1
a1951 1
[XXX: This feature is not yet implemented.]
d1953 1
a1953 1
=head1 CAVEATS
d1955 31
a1985 3
As of yet, there is no method for automatically coercing input and
output to some encoding other than UTF-8.  This is planned in the near
future, however.
d1987 24
a2010 2
Whether an arbitrary piece of data will be treated as "characters" or
"bytes" by internal operations cannot be divined at the current time.
d2012 20
a2031 5
Use of locales with utf8 may lead to odd results.  Currently there is
some attempt to apply 8-bit locale info to characters in the range
0..255, but this is demonstrably incorrect for locales that use
characters above that range (when mapped into Unicode).  It will also
tend to run slower.  Avoidance of locales is strongly encouraged.
d2035 3
a2037 1
L<bytes>, L<utf8>, L<perlvar/"${^WIDE_SYSTEM_CALLS}">
@


1.1.1.1
log
@virgin perl 5.6.0
@
text
@@


1.1.1.2
log
@stock perl 5.6.1
@
text
@d3 1
a3 1
perlunicode - Unicode support in Perl (EXPERIMENTAL, subject to change)
d9 1
a9 2
    WARNING:  As of the 5.6.1 release, the implementation of Unicode
    support in Perl is incomplete, and continues to be highly experimental.
d11 1
a11 2
The following areas need further work.  They are being rapidly addressed
in the 5.7.x development branch.
d13 1
a13 1
=over 4
d117 7
a123 1
a Unicode smiley face is C<\x{263A}>.
d166 14
a179 4
The C<tr///> operator translates characters instead of bytes.  Note
that the C<tr///CU> functionality has been removed, as the interface
was a mistake.  For similar functionality see pack('U0', ...) and
pack('C0', ...).
a213 12

=item *

The bit string operators C<& | ^ ~> can operate on character data.
However, for backward compatibility reasons (bit string operations
when the characters all are less than 256 in ordinal value) one cannot
mix C<~> (the bit complement) and characters both less than 256 and
equal or greater than 256.  Most importantly, the DeMorgan's laws
(C<~($x|$y) eq ~$x&~$y>, C<~($x&$y) eq ~$x|~$y>) won't hold.
Another way to look at this is that the complement cannot return
B<both> the 8-bit (byte) wide bit complement, and the full character
wide bit complement.
@


1.1.1.3
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
perlunicode - Unicode support in Perl
d7 1
a7 1
=head2 Important Caveats
d9 5
a13 3
Unicode support is an extensive requirement. While Perl does not
implement the Unicode standard or the accompanying technical reports
from cover to cover, Perl does support many Unicode features.
d17 5
a21 1
=item Input and Output Layers
d23 1
a23 5
Perl knows when a filehandle uses Perl's internal Unicode encodings
(UTF-8, or UTF-EBCDIC if in EBCDIC) if the filehandle is opened with
the ":utf8" layer.  Other encodings can be converted to Perl's
encoding on input or from Perl's encoding on output by use of the
":encoding(...)"  layer.  See L<open>.
d25 6
a30 2
To indicate that Perl source itself is using a particular encoding,
see L<encoding>.
d32 1
a32 1
=item Regular Expressions
d34 3
a36 13
The regular expression compiler produces polymorphic opcodes.  That is,
the pattern adapts to the data and automatically switches to the Unicode
character scheme when presented with Unicode data--or instead uses
a traditional byte scheme when presented with byte data.

=item C<use utf8> still needed to enable UTF-8/UTF-EBCDIC in scripts

As a compatibility measure, the C<use utf8> pragma must be explicitly
included to enable recognition of UTF-8 in the Perl scripts themselves
(in string or regular expression literals, or in identifier names) on
ASCII-based machines or to recognize UTF-EBCDIC on EBCDIC-based
machines.  B<These are the only times when an explicit C<use utf8>
is needed.>  See L<utf8>.
d38 3
a40 2
You can also use the C<encoding> pragma to change the default encoding
of the data in your script; see L<encoding>.
d44 1
a44 1
=head2 Byte and Character Semantics
d46 3
a48 2
Beginning with version 5.6, Perl uses logically-wide characters to
represent strings internally.
d50 2
a51 2
In future, Perl-level operations will be expected to work with
characters rather than bytes.
d53 7
a59 7
However, as an interim compatibility measure, Perl aims to
provide a safe migration path from byte semantics to character
semantics for programs.  For operations where Perl can unambiguously
decide that the input data are characters, Perl switches to
character semantics.  For operations where this determination cannot
be made without additional information from the user, Perl decides in
favor of compatibility and chooses to use byte semantics.
d62 2
a63 2
which allowed byte semantics in Perl operations only if
none of the program's inputs were marked as being as source of Unicode
d68 4
a71 6
On Windows platforms, if the C<-C> command line switch is used or the
${^WIDE_SYSTEM_CALLS} global flag is set to C<1>, all system calls
will use the corresponding wide-character APIs.  This feature is
available only on Windows to conform to the API standard already
established for that platform--and there are very few non-Windows
platforms that have Unicode-aware APIs.
d73 2
a74 2
The C<bytes> pragma will always, regardless of platform, force byte
semantics in a particular lexical scope.  See L<bytes>.
d77 14
a90 21
recognition of UTF-(8|EBCDIC) in literals encountered by the parser.
Note that this pragma is only required while Perl defaults to byte
semantics; when character semantics become the default, this pragma
may become a no-op.  See L<utf8>.

Unless explicitly stated, Perl operators use character semantics
for Unicode data and byte semantics for non-Unicode data.
The decision to use character semantics is made transparently.  If
input data comes from a Unicode source--for example, if a character
encoding layer is added to a filehandle or a literal Unicode
string constant appears in a program--character semantics apply.
Otherwise, byte semantics are in effect.  The C<bytes> pragma should
be used to force byte semantics on Unicode data.

If strings operating under byte semantics and strings with Unicode
character data are concatenated, the new string will be upgraded to
I<ISO 8859-1 (Latin-1)>, even if the old Unicode string used EBCDIC.
This translation is done without regard to the system's native 8-bit
encoding, so to change this for systems with non-Latin-1 and 
non-EBCDIC native encodings use the C<encoding> pragma.  See
L<encoding>.
d93 9
a101 5
bytes now operate on characters. A character in Perl is
logically just a number ranging from 0 to 2**31 or so. Larger
characters may encode into longer sequences of bytes internally, but
this internal detail is mostly hidden for Perl code.
See L<perluniintro> for more.
d103 1
a103 1
=head2 Effects of Character Semantics
d111 2
a112 21
Strings--including hash keys--and regular expression patterns may
contain characters that have an ordinal value larger than 255.

If you use a Unicode editor to edit your program, Unicode characters
may occur directly within the literal strings in one of the various
Unicode encodings (UTF-8, UTF-EBCDIC, UCS-2, etc.), but will be recognized
as such and converted to Perl's internal representation only if the
appropriate L<encoding> is specified.

Unicode characters can also be added to a string by using the
C<\x{...}> notation.  The Unicode code for the desired character, in
hexadecimal, should be placed in the braces. For instance, a smiley
face is C<\x{263A}>.  This encoding scheme only works for characters
with a code of 0x100 or above.

Additionally, if you

   use charnames ':full';

you can use the C<\N{...}> notation and put the official Unicode
character name within the braces, such as C<\N{WHITE SMILING FACE}>.
d114 6
d123 4
a126 4
If an appropriate L<encoding> is specified, identifiers within the
Perl script may contain Unicode alphanumeric characters, including
ideographs.  Perl does not currently attempt to canonicalize variable
names.
d130 4
a133 3
Regular expressions match characters instead of bytes.  "." matches
a character instead of a byte.  The C<\C> pattern is provided to force
a match a single byte--a C<char> in C, hence C<\C>.
d138 3
a140 3
bytes and match against the character properties specified in the
Unicode properties database.  C<\w> can be used to match a Japanese
ideograph, for instance.
d144 7
a150 356
Named Unicode properties, scripts, and block ranges may be used like
character classes via the C<\p{}> "matches property" construct and
the  C<\P{}> negation, "doesn't match property".

For instance, C<\p{Lu}> matches any character with the Unicode "Lu"
(Letter, uppercase) property, while C<\p{M}> matches any character
with an "M" (mark--accents and such) property.  Brackets are not
required for single letter properties, so C<\p{M}> is equivalent to
C<\pM>. Many predefined properties are available, such as
C<\p{Mirrored}> and C<\p{Tibetan}>.

The official Unicode script and block names have spaces and dashes as
separators, but for convenience you can use dashes, spaces, or
underbars, and case is unimportant. It is recommended, however, that
for consistency you use the following naming: the official Unicode
script, property, or block name (see below for the additional rules
that apply to block names) with whitespace and dashes removed, and the
words "uppercase-first-lowercase-rest". C<Latin-1 Supplement> thus
becomes C<Latin1Supplement>.

You can also use negation in both C<\p{}> and C<\P{}> by introducing a caret
(^) between the first brace and the property name: C<\p{^Tamil}> is
equal to C<\P{Tamil}>.

Here are the basic Unicode General Category properties, followed by their
long form.  You can use either; C<\p{Lu}> and C<\p{LowercaseLetter}>,
for instance, are identical.

    Short       Long

    L           Letter
    Lu          UppercaseLetter
    Ll          LowercaseLetter
    Lt          TitlecaseLetter
    Lm          ModifierLetter
    Lo          OtherLetter

    M           Mark
    Mn          NonspacingMark
    Mc          SpacingMark
    Me          EnclosingMark

    N           Number
    Nd          DecimalNumber
    Nl          LetterNumber
    No          OtherNumber

    P           Punctuation
    Pc          ConnectorPunctuation
    Pd          DashPunctuation
    Ps          OpenPunctuation
    Pe          ClosePunctuation
    Pi          InitialPunctuation
                (may behave like Ps or Pe depending on usage)
    Pf          FinalPunctuation
                (may behave like Ps or Pe depending on usage)
    Po          OtherPunctuation

    S           Symbol
    Sm          MathSymbol
    Sc          CurrencySymbol
    Sk          ModifierSymbol
    So          OtherSymbol

    Z           Separator
    Zs          SpaceSeparator
    Zl          LineSeparator
    Zp          ParagraphSeparator

    C           Other
    Cc          Control
    Cf          Format
    Cs          Surrogate   (not usable)
    Co          PrivateUse
    Cn          Unassigned

Single-letter properties match all characters in any of the
two-letter sub-properties starting with the same letter.
C<L&> is a special case, which is an alias for C<Ll>, C<Lu>, and C<Lt>.

Because Perl hides the need for the user to understand the internal
representation of Unicode characters, there is no need to implement
the somewhat messy concept of surrogates. C<Cs> is therefore not
supported.

Because scripts differ in their directionality--Hebrew is
written right to left, for example--Unicode supplies these properties:

    Property    Meaning

    BidiL       Left-to-Right
    BidiLRE     Left-to-Right Embedding
    BidiLRO     Left-to-Right Override
    BidiR       Right-to-Left
    BidiAL      Right-to-Left Arabic
    BidiRLE     Right-to-Left Embedding
    BidiRLO     Right-to-Left Override
    BidiPDF     Pop Directional Format
    BidiEN      European Number
    BidiES      European Number Separator
    BidiET      European Number Terminator
    BidiAN      Arabic Number
    BidiCS      Common Number Separator
    BidiNSM     Non-Spacing Mark
    BidiBN      Boundary Neutral
    BidiB       Paragraph Separator
    BidiS       Segment Separator
    BidiWS      Whitespace
    BidiON      Other Neutrals

For example, C<\p{BidiR}> matches characters that are normally
written right to left.

=back

=head2 Scripts

The script names which can be used by C<\p{...}> and C<\P{...}>,
such as in C<\p{Latin}> or C<\p{Cyrillic}>, are as follows:

    Arabic
    Armenian
    Bengali
    Bopomofo
    Buhid
    CanadianAboriginal
    Cherokee
    Cyrillic
    Deseret
    Devanagari
    Ethiopic
    Georgian
    Gothic
    Greek
    Gujarati
    Gurmukhi
    Han
    Hangul
    Hanunoo
    Hebrew
    Hiragana
    Inherited
    Kannada
    Katakana
    Khmer
    Lao
    Latin
    Malayalam
    Mongolian
    Myanmar
    Ogham
    OldItalic
    Oriya
    Runic
    Sinhala
    Syriac
    Tagalog
    Tagbanwa
    Tamil
    Telugu
    Thaana
    Thai
    Tibetan
    Yi

Extended property classes can supplement the basic
properties, defined by the F<PropList> Unicode database:

    ASCIIHexDigit
    BidiControl
    Dash
    Deprecated
    Diacritic
    Extender
    GraphemeLink
    HexDigit
    Hyphen
    Ideographic
    IDSBinaryOperator
    IDSTrinaryOperator
    JoinControl
    LogicalOrderException
    NoncharacterCodePoint
    OtherAlphabetic
    OtherDefaultIgnorableCodePoint
    OtherGraphemeExtend
    OtherLowercase
    OtherMath
    OtherUppercase
    QuotationMark
    Radical
    SoftDotted
    TerminalPunctuation
    UnifiedIdeograph
    WhiteSpace

and there are further derived properties:

    Alphabetic      Lu + Ll + Lt + Lm + Lo + OtherAlphabetic
    Lowercase       Ll + OtherLowercase
    Uppercase       Lu + OtherUppercase
    Math            Sm + OtherMath

    ID_Start        Lu + Ll + Lt + Lm + Lo + Nl
    ID_Continue     ID_Start + Mn + Mc + Nd + Pc

    Any             Any character
    Assigned        Any non-Cn character (i.e. synonym for \P{Cn})
    Unassigned      Synonym for \p{Cn}
    Common          Any character (or unassigned code point)
                    not explicitly assigned to a script

For backward compatibility (with Perl 5.6), all properties mentioned
so far may have C<Is> prepended to their name, so C<\P{IsLu}>, for
example, is equal to C<\P{Lu}>.

=head2 Blocks

In addition to B<scripts>, Unicode also defines B<blocks> of
characters.  The difference between scripts and blocks is that the
concept of scripts is closer to natural languages, while the concept
of blocks is more of an artificial grouping based on groups of 256
Unicode characters. For example, the C<Latin> script contains letters
from many blocks but does not contain all the characters from those
blocks. It does not, for example, contain digits, because digits are
shared across many scripts. Digits and similar groups, like
punctuation, are in a category called C<Common>.

For more about scripts, see the UTR #24:

   http://www.unicode.org/unicode/reports/tr24/

For more about blocks, see:

   http://www.unicode.org/Public/UNIDATA/Blocks.txt

Block names are given with the C<In> prefix. For example, the
Katakana block is referenced via C<\p{InKatakana}>.  The C<In>
prefix may be omitted if there is no naming conflict with a script
or any other property, but it is recommended that C<In> always be used
for block tests to avoid confusion.

These block names are supported:

    InAlphabeticPresentationForms
    InArabic
    InArabicPresentationFormsA
    InArabicPresentationFormsB
    InArmenian
    InArrows
    InBasicLatin
    InBengali
    InBlockElements
    InBopomofo
    InBopomofoExtended
    InBoxDrawing
    InBraillePatterns
    InBuhid
    InByzantineMusicalSymbols
    InCJKCompatibility
    InCJKCompatibilityForms
    InCJKCompatibilityIdeographs
    InCJKCompatibilityIdeographsSupplement
    InCJKRadicalsSupplement
    InCJKSymbolsAndPunctuation
    InCJKUnifiedIdeographs
    InCJKUnifiedIdeographsExtensionA
    InCJKUnifiedIdeographsExtensionB
    InCherokee
    InCombiningDiacriticalMarks
    InCombiningDiacriticalMarksforSymbols
    InCombiningHalfMarks
    InControlPictures
    InCurrencySymbols
    InCyrillic
    InCyrillicSupplementary
    InDeseret
    InDevanagari
    InDingbats
    InEnclosedAlphanumerics
    InEnclosedCJKLettersAndMonths
    InEthiopic
    InGeneralPunctuation
    InGeometricShapes
    InGeorgian
    InGothic
    InGreekExtended
    InGreekAndCoptic
    InGujarati
    InGurmukhi
    InHalfwidthAndFullwidthForms
    InHangulCompatibilityJamo
    InHangulJamo
    InHangulSyllables
    InHanunoo
    InHebrew
    InHighPrivateUseSurrogates
    InHighSurrogates
    InHiragana
    InIPAExtensions
    InIdeographicDescriptionCharacters
    InKanbun
    InKangxiRadicals
    InKannada
    InKatakana
    InKatakanaPhoneticExtensions
    InKhmer
    InLao
    InLatin1Supplement
    InLatinExtendedA
    InLatinExtendedAdditional
    InLatinExtendedB
    InLetterlikeSymbols
    InLowSurrogates
    InMalayalam
    InMathematicalAlphanumericSymbols
    InMathematicalOperators
    InMiscellaneousMathematicalSymbolsA
    InMiscellaneousMathematicalSymbolsB
    InMiscellaneousSymbols
    InMiscellaneousTechnical
    InMongolian
    InMusicalSymbols
    InMyanmar
    InNumberForms
    InOgham
    InOldItalic
    InOpticalCharacterRecognition
    InOriya
    InPrivateUseArea
    InRunic
    InSinhala
    InSmallFormVariants
    InSpacingModifierLetters
    InSpecials
    InSuperscriptsAndSubscripts
    InSupplementalArrowsA
    InSupplementalArrowsB
    InSupplementalMathematicalOperators
    InSupplementaryPrivateUseAreaA
    InSupplementaryPrivateUseAreaB
    InSyriac
    InTagalog
    InTagbanwa
    InTags
    InTamil
    InTelugu
    InThaana
    InThai
    InTibetan
    InUnifiedCanadianAboriginalSyllabics
    InVariationSelectors
    InYiRadicals
    InYiSyllables

=over 4
d154 4
a157 4
The special pattern C<\X> matches any extended Unicode
sequence--"a combining character sequence" in Standardese--where the
first character is a base character and subsequent characters are mark
characters that apply to the base character.  C<\X> is equivalent to
d163 3
a165 2
that the C<tr///CU> functionality has been removed.  For similar
functionality see pack('U0', ...) and pack('C0', ...).
d170 4
a173 4
when character input is provided.  Note that C<uc()>, or C<\U> in
interpolated strings, translates to uppercase, while C<ucfirst>,
or C<\u> in interpolated strings, translates to titlecase in languages
that make the distinction.
d177 8
a184 8
Most operators that deal with positions or lengths in a string will
automatically switch to using character positions, including
C<chop()>, C<substr()>, C<pos()>, C<index()>, C<rindex()>,
C<sprintf()>, C<write()>, and C<length()>.  Operators that
specifically do not switch include C<vec()>, C<pack()>, and
C<unpack()>.  Operators that really don't care include C<chomp()>,
operators that treats strings as a bucket of bits such as C<sort()>,
and operators dealing with filenames.
d188 5
a192 6
The C<pack()>/C<unpack()> letters C<c> and C<C> do I<not> change,
since they are often used for byte-oriented formats.  Again, think
C<char> in the C language.

There is a new C<U> specifier that converts between Unicode characters
and code points.
d196 4
a199 6
The C<chr()> and C<ord()> functions work on characters, similar to
C<pack("U")> and C<unpack("U")>, I<not> C<pack("C")> and
C<unpack("C")>.  C<pack("C")> and C<unpack("C")> are methods for
emulating byte-oriented C<chr()> and C<ord()> on Unicode strings.
While these methods reveal the internal encoding of Unicode strings,
that is not something one normally needs to care about at all.
d203 9
a211 43
The bit string operators, C<& | ^ ~>, can operate on character data.
However, for backward compatibility, such as when using bit string
operations when characters are all less than 256 in ordinal value, one
should not use C<~> (the bit complement) with characters of both
values less than 256 and values greater than 256.  Most importantly,
DeMorgan's laws (C<~($x|$y) eq ~$x&~$y> and C<~($x&$y) eq ~$x|~$y>)
will not hold.  The reason for this mathematical I<faux pas> is that
the complement cannot return B<both> the 8-bit (byte-wide) bit
complement B<and> the full character-wide bit complement.

=item *

lc(), uc(), lcfirst(), and ucfirst() work for the following cases:

=over 8

=item *

the case mapping is from a single Unicode character to another
single Unicode character, or

=item *

the case mapping is from a single Unicode character to more
than one Unicode character.

=back

The following cases do not yet work:

=over 8

=item *

the "final sigma" (Greek), and

=item *

anything to with locales (Lithuanian, Turkish, Azeri).

=back

See the Unicode Technical Report #21, Case Mappings, for more details.
d219 1
a219 142
=head2 User-Defined Character Properties

You can define your own character properties by defining subroutines
whose names begin with "In" or "Is".  The subroutines must be
visible in the package that uses the properties.  The user-defined
properties can be used in the regular expression C<\p> and C<\P>
constructs.

The subroutines must return a specially-formatted string, with one
or more newline-separated lines.  Each line must be one of the following:

=over 4

=item *

Two hexadecimal numbers separated by horizontal whitespace (space or
tabular characters) denoting a range of Unicode code points to include.

=item *

Something to include, prefixed by "+": a built-in character
property (prefixed by "utf8::"), to represent all the characters in that
property; two hexadecimal code points for a range; or a single
hexadecimal code point.

=item *

Something to exclude, prefixed by "-": an existing character
property (prefixed by "utf8::"), for all the characters in that
property; two hexadecimal code points for a range; or a single
hexadecimal code point.

=item *

Something to negate, prefixed "!": an existing character
property (prefixed by "utf8::") for all the characters except the
characters in the property; two hexadecimal code points for a range;
or a single hexadecimal code point.

=back

For example, to define a property that covers both the Japanese
syllabaries (hiragana and katakana), you can define

    sub InKana {
	return <<END;
    3040\t309F
    30A0\t30FF
    END
    }

Imagine that the here-doc end marker is at the beginning of the line.
Now you can use C<\p{InKana}> and C<\P{InKana}>.

You could also have used the existing block property names:

    sub InKana {
	return <<'END';
    +utf8::InHiragana
    +utf8::InKatakana
    END
    }

Suppose you wanted to match only the allocated characters,
not the raw block ranges: in other words, you want to remove
the non-characters:

    sub InKana {
	return <<'END';
    +utf8::InHiragana
    +utf8::InKatakana
    -utf8::IsCn
    END
    }

The negation is useful for defining (surprise!) negated classes.

    sub InNotKana {
	return <<'END';
    !utf8::InHiragana
    -utf8::InKatakana
    +utf8::IsCn
    END
    }

=head2 Character Encodings for Input and Output

See L<Encode>.

=head2 Unicode Regular Expression Support Level

The following list of Unicode support for regular expressions describes
all the features currently supported.  The references to "Level N"
and the section numbers refer to the Unicode Technical Report 18,
"Unicode Regular Expression Guidelines".

=over 4

=item *

Level 1 - Basic Unicode Support

        2.1 Hex Notation                        - done          [1]
            Named Notation                      - done          [2]
        2.2 Categories                          - done          [3][4]
        2.3 Subtraction                         - MISSING       [5][6]
        2.4 Simple Word Boundaries              - done          [7]
        2.5 Simple Loose Matches                - done          [8]
        2.6 End of Line                         - MISSING       [9][10]

        [ 1] \x{...}
        [ 2] \N{...}
        [ 3] . \p{...} \P{...}
        [ 4] now scripts (see UTR#24 Script Names) in addition to blocks
        [ 5] have negation
        [ 6] can use regular expression look-ahead [a]
             or user-defined character properties [b] to emulate subtraction
        [ 7] include Letters in word characters
        [ 8] note that Perl does Full case-folding in matching, not Simple:
             for example U+1F88 is equivalent with U+1F000 U+03B9,
             not with 1F80.  This difference matters for certain Greek
             capital letters with certain modifiers: the Full case-folding
             decomposes the letter, while the Simple case-folding would map
             it to a single character.
        [ 9] see UTR#13 Unicode Newline Guidelines
        [10] should do ^ and $ also on \x{85}, \x{2028} and \x{2029})
             (should also affect <>, $., and script line numbers)
             (the \x{85}, \x{2028} and \x{2029} do match \s)

[a] You can mimic class subtraction using lookahead.
For example, what TR18 might write as

    [{Greek}-[{UNASSIGNED}]]

in Perl can be written as:

    (?!\p{Unassigned})\p{InGreekAndCoptic}
    (?=\p{Assigned})\p{InGreekAndCoptic}

But in this particular example, you probably really want

    \p{GreekAndCoptic}
d221 1
a221 355
which will match assigned characters known to be part of the Greek script.

[b] See L</"User-Defined Character Properties">.

=item *

Level 2 - Extended Unicode Support

        3.1 Surrogates                          - MISSING
        3.2 Canonical Equivalents               - MISSING       [11][12]
        3.3 Locale-Independent Graphemes        - MISSING       [13]
        3.4 Locale-Independent Words            - MISSING       [14]
        3.5 Locale-Independent Loose Matches    - MISSING       [15]

        [11] see UTR#15 Unicode Normalization
        [12] have Unicode::Normalize but not integrated to regexes
        [13] have \X but at this level . should equal that
        [14] need three classes, not just \w and \W
        [15] see UTR#21 Case Mappings

=item *

Level 3 - Locale-Sensitive Support

        4.1 Locale-Dependent Categories         - MISSING
        4.2 Locale-Dependent Graphemes          - MISSING       [16][17]
        4.3 Locale-Dependent Words              - MISSING
        4.4 Locale-Dependent Loose Matches      - MISSING
        4.5 Locale-Dependent Ranges             - MISSING

        [16] see UTR#10 Unicode Collation Algorithms
        [17] have Unicode::Collate but not integrated to regexes

=back

=head2 Unicode Encodings

Unicode characters are assigned to I<code points>, which are abstract
numbers.  To use these numbers, various encodings are needed.

=over 4

=item *

UTF-8

UTF-8 is a variable-length (1 to 6 bytes, current character allocations
require 4 bytes), byte-order independent encoding. For ASCII (and we
really do mean 7-bit ASCII, not another 8-bit encoding), UTF-8 is
transparent.

The following table is from Unicode 3.2.

 Code Points            1st Byte  2nd Byte  3rd Byte  4th Byte

   U+0000..U+007F       00..7F
   U+0080..U+07FF       C2..DF    80..BF
   U+0800..U+0FFF       E0        A0..BF    80..BF
   U+1000..U+CFFF       E1..EC    80..BF    80..BF
   U+D000..U+D7FF       ED        80..9F    80..BF
   U+D800..U+DFFF       ******* ill-formed *******
   U+E000..U+FFFF       EE..EF    80..BF    80..BF
  U+10000..U+3FFFF      F0        90..BF    80..BF    80..BF
  U+40000..U+FFFFF      F1..F3    80..BF    80..BF    80..BF
 U+100000..U+10FFFF     F4        80..8F    80..BF    80..BF

Note the C<A0..BF> in C<U+0800..U+0FFF>, the C<80..9F> in
C<U+D000...U+D7FF>, the C<90..B>F in C<U+10000..U+3FFFF>, and the
C<80...8F> in C<U+100000..U+10FFFF>.  The "gaps" are caused by legal
UTF-8 avoiding non-shortest encodings: it is technically possible to
UTF-8-encode a single code point in different ways, but that is
explicitly forbidden, and the shortest possible encoding should always
be used.  So that's what Perl does.

Another way to look at it is via bits:

 Code Points                    1st Byte   2nd Byte  3rd Byte  4th Byte

                    0aaaaaaa     0aaaaaaa
            00000bbbbbaaaaaa     110bbbbb  10aaaaaa
            ccccbbbbbbaaaaaa     1110cccc  10bbbbbb  10aaaaaa
  00000dddccccccbbbbbbaaaaaa     11110ddd  10cccccc  10bbbbbb  10aaaaaa

As you can see, the continuation bytes all begin with C<10>, and the
leading bits of the start byte tell how many bytes the are in the
encoded character.

=item *

UTF-EBCDIC

Like UTF-8 but EBCDIC-safe, in the way that UTF-8 is ASCII-safe.

=item *

UTF-16, UTF-16BE, UTF16-LE, Surrogates, and BOMs (Byte Order Marks)

The followings items are mostly for reference and general Unicode
knowledge, Perl doesn't use these constructs internally.

UTF-16 is a 2 or 4 byte encoding.  The Unicode code points
C<U+0000..U+FFFF> are stored in a single 16-bit unit, and the code
points C<U+10000..U+10FFFF> in two 16-bit units.  The latter case is
using I<surrogates>, the first 16-bit unit being the I<high
surrogate>, and the second being the I<low surrogate>.

Surrogates are code points set aside to encode the C<U+10000..U+10FFFF>
range of Unicode code points in pairs of 16-bit units.  The I<high
surrogates> are the range C<U+D800..U+DBFF>, and the I<low surrogates>
are the range C<U+DC00..U+DFFF>.  The surrogate encoding is

	$hi = ($uni - 0x10000) / 0x400 + 0xD800;
	$lo = ($uni - 0x10000) % 0x400 + 0xDC00;

and the decoding is

	$uni = 0x10000 + ($hi - 0xD800) * 0x400 + ($lo - 0xDC00);

If you try to generate surrogates (for example by using chr()), you
will get a warning if warnings are turned on, because those code
points are not valid for a Unicode character.

Because of the 16-bitness, UTF-16 is byte-order dependent.  UTF-16
itself can be used for in-memory computations, but if storage or
transfer is required either UTF-16BE (big-endian) or UTF-16LE
(little-endian) encodings must be chosen.

This introduces another problem: what if you just know that your data
is UTF-16, but you don't know which endianness?  Byte Order Marks, or
BOMs, are a solution to this.  A special character has been reserved
in Unicode to function as a byte order marker: the character with the
code point C<U+FEFF> is the BOM.

The trick is that if you read a BOM, you will know the byte order,
since if it was written on a big-endian platform, you will read the
bytes C<0xFE 0xFF>, but if it was written on a little-endian platform,
you will read the bytes C<0xFF 0xFE>.  (And if the originating platform
was writing in UTF-8, you will read the bytes C<0xEF 0xBB 0xBF>.)

The way this trick works is that the character with the code point
C<U+FFFE> is guaranteed not to be a valid Unicode character, so the
sequence of bytes C<0xFF 0xFE> is unambiguously "BOM, represented in
little-endian format" and cannot be C<U+FFFE>, represented in big-endian
format".

=item *

UTF-32, UTF-32BE, UTF32-LE

The UTF-32 family is pretty much like the UTF-16 family, expect that
the units are 32-bit, and therefore the surrogate scheme is not
needed.  The BOM signatures will be C<0x00 0x00 0xFE 0xFF> for BE and
C<0xFF 0xFE 0x00 0x00> for LE.

=item *

UCS-2, UCS-4

Encodings defined by the ISO 10646 standard.  UCS-2 is a 16-bit
encoding.  Unlike UTF-16, UCS-2 is not extensible beyond C<U+FFFF>,
because it does not use surrogates.  UCS-4 is a 32-bit encoding,
functionally identical to UTF-32.

=item *

UTF-7

A seven-bit safe (non-eight-bit) encoding, which is useful if the
transport or storage is not eight-bit safe.  Defined by RFC 2152.

=back

=head2 Security Implications of Unicode

=over 4

=item *

Malformed UTF-8

Unfortunately, the specification of UTF-8 leaves some room for
interpretation of how many bytes of encoded output one should generate
from one input Unicode character.  Strictly speaking, the shortest
possible sequence of UTF-8 bytes should be generated,
because otherwise there is potential for an input buffer overflow at
the receiving end of a UTF-8 connection.  Perl always generates the
shortest length UTF-8, and with warnings on Perl will warn about
non-shortest length UTF-8 along with other malformations, such as the
surrogates, which are not real Unicode code points.

=item *

Regular expressions behave slightly differently between byte data and
character (Unicode) data.  For example, the "word character" character
class C<\w> will work differently depending on if data is eight-bit bytes
or Unicode.

In the first case, the set of C<\w> characters is either small--the
default set of alphabetic characters, digits, and the "_"--or, if you
are using a locale (see L<perllocale>), the C<\w> might contain a few
more letters according to your language and country.

In the second case, the C<\w> set of characters is much, much larger.
Most importantly, even in the set of the first 256 characters, it will
probably match different characters: unlike most locales, which are
specific to a language and country pair, Unicode classifies all the
characters that are letters I<somewhere> as C<\w>.  For example, your
locale might not think that LATIN SMALL LETTER ETH is a letter (unless
you happen to speak Icelandic), but Unicode does.

As discussed elsewhere, Perl has one foot (two hooves?) planted in
each of two worlds: the old world of bytes and the new world of
characters, upgrading from bytes to characters when necessary.
If your legacy code does not explicitly use Unicode, no automatic
switch-over to characters should happen.  Characters shouldn't get
downgraded to bytes, either.  It is possible to accidentally mix bytes
and characters, however (see L<perluniintro>), in which case C<\w> in
regular expressions might start behaving differently.  Review your
code.  Use warnings and the C<strict> pragma.

=back

=head2 Unicode in Perl on EBCDIC

The way Unicode is handled on EBCDIC platforms is still
experimental.  On such platforms, references to UTF-8 encoding in this
document and elsewhere should be read as meaning the UTF-EBCDIC
specified in Unicode Technical Report 16, unless ASCII vs. EBCDIC issues
are specifically discussed. There is no C<utfebcdic> pragma or
":utfebcdic" layer; rather, "utf8" and ":utf8" are reused to mean
the platform's "natural" 8-bit encoding of Unicode. See L<perlebcdic>
for more discussion of the issues.

=head2 Locales

Usually locale settings and Unicode do not affect each other, but
there are a couple of exceptions:

=over 4

=item *

If your locale environment variables (LANGUAGE, LC_ALL, LC_CTYPE, LANG)
contain the strings 'UTF-8' or 'UTF8' (case-insensitive matching),
the default encodings of your STDIN, STDOUT, and STDERR, and of
B<any subsequent file open>, are considered to be UTF-8.

=item *

Perl tries really hard to work both with Unicode and the old
byte-oriented world. Most often this is nice, but sometimes Perl's
straddling of the proverbial fence causes problems.

=back

=head2 Using Unicode in XS

If you want to handle Perl Unicode in XS extensions, you may find
the following C APIs useful.  See L<perlapi> for details.

=over 4

=item *

C<DO_UTF8(sv)> returns true if the C<UTF8> flag is on and the bytes
pragma is not in effect.  C<SvUTF8(sv)> returns true is the C<UTF8>
flag is on; the bytes pragma is ignored.  The C<UTF8> flag being on
does B<not> mean that there are any characters of code points greater
than 255 (or 127) in the scalar or that there are even any characters
in the scalar.  What the C<UTF8> flag means is that the sequence of
octets in the representation of the scalar is the sequence of UTF-8
encoded code points of the characters of a string.  The C<UTF8> flag
being off means that each octet in this representation encodes a
single character with code point 0..255 within the string.  Perl's
Unicode model is not to use UTF-8 until it is absolutely necessary.

=item *

C<uvuni_to_utf8(buf, chr>) writes a Unicode character code point into
a buffer encoding the code point as UTF-8, and returns a pointer
pointing after the UTF-8 bytes.

=item *

C<utf8_to_uvuni(buf, lenp)> reads UTF-8 encoded bytes from a buffer and
returns the Unicode character code point and, optionally, the length of
the UTF-8 byte sequence.

=item *

C<utf8_length(start, end)> returns the length of the UTF-8 encoded buffer
in characters.  C<sv_len_utf8(sv)> returns the length of the UTF-8 encoded
scalar.

=item *

C<sv_utf8_upgrade(sv)> converts the string of the scalar to its UTF-8
encoded form.  C<sv_utf8_downgrade(sv)> does the opposite, if
possible.  C<sv_utf8_encode(sv)> is like sv_utf8_upgrade except that
it does not set the C<UTF8> flag.  C<sv_utf8_decode()> does the
opposite of C<sv_utf8_encode()>.  Note that none of these are to be
used as general-purpose encoding or decoding interfaces: C<use Encode>
for that.  C<sv_utf8_upgrade()> is affected by the encoding pragma
but C<sv_utf8_downgrade()> is not (since the encoding pragma is
designed to be a one-way street).

=item *

C<is_utf8_char(s)> returns true if the pointer points to a valid UTF-8
character.

=item *

C<is_utf8_string(buf, len)> returns true if C<len> bytes of the buffer
are valid UTF-8.

=item *

C<UTF8SKIP(buf)> will return the number of bytes in the UTF-8 encoded
character in the buffer.  C<UNISKIP(chr)> will return the number of bytes
required to UTF-8-encode the Unicode character code point.  C<UTF8SKIP()>
is useful for example for iterating over the characters of a UTF-8
encoded buffer; C<UNISKIP()> is useful, for example, in computing
the size required for a UTF-8 encoded buffer.

=item *

C<utf8_distance(a, b)> will tell the distance in characters between the
two pointers pointing to the same UTF-8 encoded buffer.

=item *

C<utf8_hop(s, off)> will return a pointer to an UTF-8 encoded buffer
that is C<off> (positive or negative) Unicode characters displaced
from the UTF-8 buffer C<s>.  Be careful not to overstep the buffer:
C<utf8_hop()> will merrily run off the end or the beginning of the
buffer if told to do so.

=item *

C<pv_uni_display(dsv, spv, len, pvlim, flags)> and
C<sv_uni_display(dsv, ssv, pvlim, flags)> are useful for debugging the
output of Unicode strings and scalars.  By default they are useful
only for debugging--they display B<all> characters as hexadecimal code
points--but with the flags C<UNI_DISPLAY_ISPRINT>,
C<UNI_DISPLAY_BACKSLASH>, and C<UNI_DISPLAY_QQ> you can make the
output more readable.

=item *

C<ibcmp_utf8(s1, pe1, u1, l1, u1, s2, pe2, l2, u2)> can be used to
compare two strings case-insensitively in Unicode.  For case-sensitive
comparisons you can just use C<memEQ()> and C<memNE()> as usual.

=back
d223 1
a223 2
For more information, see L<perlapi>, and F<utf8.c> and F<utf8.h>
in the Perl source code distribution.
d225 3
a227 1
=head1 BUGS
d229 2
a230 1
=head2 Interaction with Locales
d232 5
a236 125
Use of locales with Unicode data may lead to odd results.  Currently,
Perl attempts to attach 8-bit locale info to characters in the range
0..255, but this technique is demonstrably incorrect for locales that
use characters above that range when mapped into Unicode.  Perl's
Unicode support will also tend to run slower.  Use of locales with
Unicode is discouraged.

=head2 Interaction with Extensions

When Perl exchanges data with an extension, the extension should be
able to understand the UTF-8 flag and act accordingly. If the
extension doesn't know about the flag, it's likely that the extension
will return incorrectly-flagged data.

So if you're working with Unicode data, consult the documentation of
every module you're using if there are any issues with Unicode data
exchange. If the documentation does not talk about Unicode at all,
suspect the worst and probably look at the source to learn how the
module is implemented. Modules written completely in Perl shouldn't
cause problems. Modules that directly or indirectly access code written
in other programming languages are at risk.

For affected functions, the simple strategy to avoid data corruption is
to always make the encoding of the exchanged data explicit. Choose an
encoding that you know the extension can handle. Convert arguments passed
to the extensions to that encoding and convert results back from that
encoding. Write wrapper functions that do the conversions for you, so
you can later change the functions when the extension catches up.

To provide an example, let's say the popular Foo::Bar::escape_html
function doesn't deal with Unicode data yet. The wrapper function
would convert the argument to raw UTF-8 and convert the result back to
Perl's internal representation like so:

    sub my_escape_html ($) {
      my($what) = shift;
      return unless defined $what;
      Encode::decode_utf8(Foo::Bar::escape_html(Encode::encode_utf8($what)));
    }

Sometimes, when the extension does not convert data but just stores
and retrieves them, you will be in a position to use the otherwise
dangerous Encode::_utf8_on() function. Let's say the popular
C<Foo::Bar> extension, written in C, provides a C<param> method that
lets you store and retrieve data according to these prototypes:

    $self->param($name, $value);            # set a scalar
    $value = $self->param($name);           # retrieve a scalar

If it does not yet provide support for any encoding, one could write a
derived class with such a C<param> method:

    sub param {
      my($self,$name,$value) = @@_;
      utf8::upgrade($name);     # make sure it is UTF-8 encoded
      if (defined $value)
        utf8::upgrade($value);  # make sure it is UTF-8 encoded
        return $self->SUPER::param($name,$value);
      } else {
        my $ret = $self->SUPER::param($name);
        Encode::_utf8_on($ret); # we know, it is UTF-8 encoded
        return $ret;
      }
    }

Some extensions provide filters on data entry/exit points, such as
DB_File::filter_store_key and family. Look out for such filters in
the documentation of your extensions, they can make the transition to
Unicode data much easier.

=head2 Speed

Some functions are slower when working on UTF-8 encoded strings than
on byte encoded strings.  All functions that need to hop over
characters such as length(), substr() or index() can work B<much>
faster when the underlying data are byte-encoded. Witness the
following benchmark:

  % perl -e '
  use Benchmark;
  use strict;
  our $l = 10000;
  our $u = our $b = "x" x $l;
  substr($u,0,1) = "\x{100}";
  timethese(-2,{
  LENGTH_B => q{ length($b) },
  LENGTH_U => q{ length($u) },
  SUBSTR_B => q{ substr($b, $l/4, $l/2) },
  SUBSTR_U => q{ substr($u, $l/4, $l/2) },
  });
  '
  Benchmark: running LENGTH_B, LENGTH_U, SUBSTR_B, SUBSTR_U for at least 2 CPU seconds...
    LENGTH_B:  2 wallclock secs ( 2.36 usr +  0.00 sys =  2.36 CPU) @@ 5649983.05/s (n=13333960)
    LENGTH_U:  2 wallclock secs ( 2.11 usr +  0.00 sys =  2.11 CPU) @@ 12155.45/s (n=25648)
    SUBSTR_B:  3 wallclock secs ( 2.16 usr +  0.00 sys =  2.16 CPU) @@ 374480.09/s (n=808877)
    SUBSTR_U:  2 wallclock secs ( 2.11 usr +  0.00 sys =  2.11 CPU) @@ 6791.00/s (n=14329)

The numbers show an incredible slowness on long UTF-8 strings.  You
should carefully avoid using these functions in tight loops. If you
want to iterate over characters, the superior coding technique would
split the characters into an array instead of using substr, as the following
benchmark shows:

  % perl -e '
  use Benchmark;
  use strict;
  our $l = 10000;
  our $u = our $b = "x" x $l;
  substr($u,0,1) = "\x{100}";
  timethese(-5,{
  SPLIT_B => q{ for my $c (split //, $b){}  },
  SPLIT_U => q{ for my $c (split //, $u){}  },
  SUBSTR_B => q{ for my $i (0..length($b)-1){my $c = substr($b,$i,1);} },
  SUBSTR_U => q{ for my $i (0..length($u)-1){my $c = substr($u,$i,1);} },
  });
  '
  Benchmark: running SPLIT_B, SPLIT_U, SUBSTR_B, SUBSTR_U for at least 5 CPU seconds...
     SPLIT_B:  6 wallclock secs ( 5.29 usr +  0.00 sys =  5.29 CPU) @@ 56.14/s (n=297)
     SPLIT_U:  5 wallclock secs ( 5.17 usr +  0.01 sys =  5.18 CPU) @@ 55.21/s (n=286)
    SUBSTR_B:  5 wallclock secs ( 5.34 usr +  0.00 sys =  5.34 CPU) @@ 123.22/s (n=658)
    SUBSTR_U:  7 wallclock secs ( 6.20 usr +  0.00 sys =  6.20 CPU) @@  0.81/s (n=5)

Even though the algorithm based on C<substr()> is faster than
C<split()> for byte-encoded data, it pales in comparison to the speed
of C<split()> when used with UTF-8 data.
d240 1
a240 2
L<perluniintro>, L<encoding>, L<Encode>, L<open>, L<utf8>, L<bytes>,
L<perlretut>, L<perlvar/"${^WIDE_SYSTEM_CALLS}">
@


1.1.1.4
log
@perl 5.8.2 from CPAN
@
text
@d70 7
a186 4
B<NOTE: the properties, scripts, and blocks listed here are as of
Unicode 3.2.0, March 2002, or Perl 5.8.0, July 2002.  Unicode 4.0.0
came out in April 2003, and Perl 5.8.1 in September 2003.>

d188 1
a188 1
long form.  You can use either; C<\p{Lu}> and C<\p{UppercaseLetter}>,
d601 5
a605 2
Things to do with locales (Lithuanian, Turkish, Azeri) do B<not> work
since Perl does not understand the concept of Unicode locales.
d607 5
a611 1
See the Unicode Technical Report #21, Case Mappings, for more details.
d615 1
a615 1
=over 4
d626 4
a629 4
whose names begin with "In" or "Is".  The subroutines must be defined
in the C<main> package.  The user-defined properties can be used in the
regular expression C<\p> and C<\P> constructs.  Note that the effect
is compile-time and immutable once defined.
a707 50
You can also define your own mappings to be used in the lc(),
lcfirst(), uc(), and ucfirst() (or their string-inlined versions).
The principle is the same: define subroutines in the C<main> package
with names like C<ToLower> (for lc() and lcfirst()), C<ToTitle> (for
the first character in ucfirst()), and C<ToUpper> (for uc(), and the
rest of the characters in ucfirst()).

The string returned by the subroutines needs now to be three
hexadecimal numbers separated by tabulators: start of the source
range, end of the source range, and start of the destination range.
For example:

    sub ToUpper {
	return <<END;
    0061\t0063\t0041
    END
    }

defines an uc() mapping that causes only the characters "a", "b", and
"c" to be mapped to "A", "B", "C", all other characters will remain
unchanged.

If there is no source range to speak of, that is, the mapping is from
a single character to another single character, leave the end of the
source range empty, but the two tabulator characters are still needed.
For example:

    sub ToLower {
	return <<END;
    0041\t\t0061
    END
    }

defines a lc() mapping that causes only "A" to be mapped to "a", all
other characters will remain unchanged.

(For serious hackers only)  If you want to introspect the default
mappings, you can find the data in the directory
C<$Config{privlib}>/F<unicore/To/>.  The mapping data is returned as
the here-document, and the C<utf8::ToSpecFoo> are special exception
mappings derived from <$Config{privlib}>/F<unicore/SpecialCasing.txt>.
The C<Digit> and C<Fold> mappings that one can see in the directory
are not directly user-accessible, one can use either the
C<Unicode::UCD> module, or just match case-insensitively (that's when
the C<Fold> mapping is used).

A final note on the user-defined property tests and mappings: they
will be used only if the scalar has been marked as having Unicode
characters.  Old byte-style strings will not be affected.

d717 1
a717 2
"Unicode Regular Expression Guidelines", version 6 (Unicode 3.2.0,
Perl 5.8.0).
d742 1
a742 1
             for example U+1F88 is equivalent with U+1F00 U+03B9,
d747 2
a748 2
        [ 9] see UTR #13 Unicode Newline Guidelines
        [10] should do ^ and $ also on \x{85}, \x{2028} and \x{2029}
d753 1
a753 1
For example, what UTR #18 might write as
a767 3
Also see the Unicode::Regex::Set module, it does implement the full
UTR #18 grouping, intersection, union, and removal (subtraction) syntax.

d774 11
a784 13
        3.1 Surrogates                          - MISSING	[11]
        3.2 Canonical Equivalents               - MISSING       [12][13]
        3.3 Locale-Independent Graphemes        - MISSING       [14]
        3.4 Locale-Independent Words            - MISSING       [15]
        3.5 Locale-Independent Loose Matches    - MISSING       [16]

        [11] Surrogates are solely a UTF-16 concept and Perl's internal
             representation is UTF-8.  The Encode module does UTF-16, though.
        [12] see UTR#15 Unicode Normalization
        [13] have Unicode::Normalize but not integrated to regexes
        [14] have \X but at this level . should equal that
        [15] need three classes, not just \w and \W
        [16] see UTR#21 Case Mappings
d861 1
a861 1
UTF-16, UTF-16BE, UTF-16LE, Surrogates, and BOMs (Byte Order Marks)
d913 1
a913 1
UTF-32, UTF-32BE, UTF-32LE
d1008 4
a1011 4
You can enable automatic UTF-8-ification of your standard file
handles, default C<open()> layer, and C<@@ARGV> by using either
the C<-C> command line switch or the C<PERL_UNICODE> environment
variable, see L<perlrun> for the documentation of the C<-C> switch.
a1020 60
=head2 When Unicode Does Not Happen

While Perl does have extensive ways to input and output in Unicode,
and few other 'entry points' like the @@ARGV which can be interpreted
as Unicode (UTF-8), there still are many places where Unicode (in some
encoding or another) could be given as arguments or received as
results, or both, but it is not.

The following are such interfaces.  For all of these Perl currently
(as of 5.8.1) simply assumes byte strings both as arguments and results.

One reason why Perl does not attempt to resolve the role of Unicode in
this cases is that the answers are highly dependent on the operating
system and the file system(s).  For example, whether filenames can be
in Unicode, and in exactly what kind of encoding, is not exactly a
portable concept.  Similarly for the qx and system: how well will the
'command line interface' (and which of them?) handle Unicode?

=over 4

=item *

chmod, chmod, chown, chroot, exec, link, mkdir
rename, rmdir stat, symlink, truncate, unlink, utime

=item *

%ENV

=item *

glob (aka the <*>)

=item *

open, opendir, sysopen

=item *

qx (aka the backtick operator), system

=item *

readdir, readlink

=back

=head2 Forcing Unicode in Perl (Or Unforcing Unicode in Perl)

Sometimes (see L</"When Unicode Does Not Happen">) there are
situations where you simply need to force Perl to believe that a byte
string is UTF-8, or vice versa.  The low-level calls
utf8::upgrade($bytestring) and utf8::downgrade($utf8string) are
the answers.

Do not use them without careful thought, though: Perl may easily get
very confused, angry, or even crash, if you suddenly change the 'nature'
of scalar like that.  Especially careful you have to be if you use the
utf8::upgrade(): any random byte string is not valid UTF-8.

d1023 2
a1024 4
If you want to handle Perl Unicode in XS extensions, you may find the
following C APIs useful.  See also L<perlguts/"Unicode Support"> for an
explanation about Unicode at the XS level, and L<perlapi> for the API
details.
d1044 1
a1044 1
C<uvuni_to_utf8(buf, chr)> writes a Unicode character code point into
d1203 51
a1253 120
characters such as length(), substr() or index(), or matching regular
expressions can work B<much> faster when the underlying data are
byte-encoded.

In Perl 5.8.0 the slowness was often quite spectacular; in Perl 5.8.1
a caching scheme was introduced which will hopefully make the slowness
somewhat less spectacular, at least for some operations.  In general,
operations with UTF-8 encoded strings are still slower. As an example,
the Unicode properties (character classes) like C<\p{Nd}> are known to
be quite a bit slower (5-20 times) than their simpler counterparts
like C<\d> (then again, there 268 Unicode characters matching C<Nd>
compared with the 10 ASCII characters matching C<d>).

=head2 Porting code from perl-5.6.X

Perl 5.8 has a different Unicode model from 5.6. In 5.6 the programmer
was required to use the C<utf8> pragma to declare that a given scope
expected to deal with Unicode data and had to make sure that only
Unicode data were reaching that scope. If you have code that is
working with 5.6, you will need some of the following adjustments to
your code. The examples are written such that the code will continue
to work under 5.6, so you should be safe to try them out.

=over 4

=item *

A filehandle that should read or write UTF-8

  if ($] > 5.007) {
    binmode $fh, ":utf8";
  }

=item *

A scalar that is going to be passed to some extension

Be it Compress::Zlib, Apache::Request or any extension that has no
mention of Unicode in the manpage, you need to make sure that the
UTF-8 flag is stripped off. Note that at the time of this writing
(October 2002) the mentioned modules are not UTF-8-aware. Please
check the documentation to verify if this is still true.

  if ($] > 5.007) {
    require Encode;
    $val = Encode::encode_utf8($val); # make octets
  }

=item *

A scalar we got back from an extension

If you believe the scalar comes back as UTF-8, you will most likely
want the UTF-8 flag restored:

  if ($] > 5.007) {
    require Encode;
    $val = Encode::decode_utf8($val);
  }

=item *

Same thing, if you are really sure it is UTF-8

  if ($] > 5.007) {
    require Encode;
    Encode::_utf8_on($val);
  }

=item *

A wrapper for fetchrow_array and fetchrow_hashref

When the database contains only UTF-8, a wrapper function or method is
a convenient way to replace all your fetchrow_array and
fetchrow_hashref calls. A wrapper function will also make it easier to
adapt to future enhancements in your database driver. Note that at the
time of this writing (October 2002), the DBI has no standardized way
to deal with UTF-8 data. Please check the documentation to verify if
that is still true.

  sub fetchrow {
    my($self, $sth, $what) = @@_; # $what is one of fetchrow_{array,hashref}
    if ($] < 5.007) {
      return $sth->$what;
    } else {
      require Encode;
      if (wantarray) {
        my @@arr = $sth->$what;
        for (@@arr) {
          defined && /[^\000-\177]/ && Encode::_utf8_on($_);
        }
        return @@arr;
      } else {
        my $ret = $sth->$what;
        if (ref $ret) {
          for my $k (keys %$ret) {
            defined && /[^\000-\177]/ && Encode::_utf8_on($_) for $ret->{$k};
          }
          return $ret;
        } else {
          defined && /[^\000-\177]/ && Encode::_utf8_on($_) for $ret;
          return $ret;
        }
      }
    }
  }


=item *

A large scalar that you know can only contain ASCII

Scalars that contain only ASCII and are marked as UTF-8 are sometimes
a drag to your program. If you recognize such a situation, just remove
the UTF-8 flag:

  utf8::downgrade($val) if $] > 5.007;

=back
d1258 1
a1258 1
L<perlretut>, L<perlvar/"${^UNICODE}">
@


1.1.1.5
log
@perl 5.8.3 from CPAN
@
text
@a44 15
=item C<use encoding> needed to upgrade non-Latin-1 byte strings

By default, there is a fundamental asymmetry in Perl's unicode model:
implicit upgrading from byte strings to Unicode strings assumes that
they were encoded in I<ISO 8859-1 (Latin-1)>, but Unicode strings are
downgraded with UTF-8 encoding.  This happens because the first 256
codepoints in Unicode happens to agree with Latin-1.  

If you wish to interpret byte strings as UTF-8 instead, use the
C<encoding> pragma:

    use encoding 'utf8';

See L</"Byte and Character Semantics"> for more details.

d89 6
a94 6
character data are concatenated, the new string will be created by
decoding the byte strings as I<ISO 8859-1 (Latin-1)>, even if the
old Unicode string used EBCDIC.  This translation is done without
regard to the system's native 8-bit encoding.  To change this for
systems with non-Latin-1 and non-EBCDIC native encodings, use the
C<encoding> pragma.  See L<encoding>.
a153 4
(However, and as a limitation of the current implementation, using
C<\w> or C<\W> I<inside> a C<[...]> character class will still match
with byte semantics.)

d1075 2
a1076 3
The following are such interfaces.  For all of these interfaces Perl
currently (as of 5.8.3) simply assumes byte strings both as arguments
and results, or UTF-8 strings if the C<encoding> pragma has been used.
d1089 2
a1090 2
chmod, chmod, chown, chroot, exec, link, lstat, mkdir, 
rename, rmdir, stat, symlink, truncate, unlink, utime, -X
@


1.1.1.6
log
@Import of stock perl 5.8.5
@
text
@a44 8
=item BOM-marked scripts and UTF-16 scripts autodetected

If a Perl script begins marked with the Unicode BOM (UTF-16LE, UTF16-BE,
or UTF-8), or if the script looks like non-BOM-marked UTF-16 of either
endianness, Perl will correctly read in the script as Unicode.
(BOMless UTF-8 cannot be effectively recognized or differentiated from
ISO 8859-1 or other eight-bit encodings.)

a209 1
    LC          CasedLetter
d257 1
a257 2
C<LC> and C<L&> are special cases, which are aliases for the set of
C<Ll>, C<Lu>, and C<Lt>.
d265 1
a265 2
written right to left, for example--Unicode supplies these properties in
the BidiClass class:
d269 19
a287 19
    L           Left-to-Right
    LRE         Left-to-Right Embedding
    LRO         Left-to-Right Override
    R           Right-to-Left
    AL          Right-to-Left Arabic
    RLE         Right-to-Left Embedding
    RLO         Right-to-Left Override
    PDF         Pop Directional Format
    EN          European Number
    ES          European Number Separator
    ET          European Number Terminator
    AN          Arabic Number
    CS          Common Number Separator
    NSM         Non-Spacing Mark
    BN          Boundary Neutral
    B           Paragraph Separator
    S           Segment Separator
    WS          Whitespace
    ON          Other Neutrals
d289 1
a289 1
For example, C<\p{BidiClass:R}> matches characters that are normally
d562 1
a562 1
C<chop()>, C<chomp()>, C<substr()>, C<pos()>, C<index()>, C<rindex()>,
d565 1
a565 1
C<unpack()>.  Operators that really don't care include
d635 4
a638 15
whose names begin with "In" or "Is".  The subroutines can be defined in
any package.  The user-defined properties can be used in the regular
expression C<\p> and C<\P> constructs; if you are using a user-defined
property from a package other than the one you are in, you must specify
its package in the C<\p> or C<\P> construct.

    # assuming property IsForeign defined in Lang::
    package main;  # property package name required
    if ($txt =~ /\p{Lang::IsForeign}+/) { ... }

    package Lang;  # property package name not required
    if ($txt =~ /\p{IsForeign}+/) { ... }


Note that the effect is compile-time and immutable once defined.
d653 3
a655 3
property (prefixed by "utf8::") or a user-defined character property,
to represent all the characters in that property; two hexadecimal code
points for a range; or a single hexadecimal code point.
d660 3
a662 3
property (prefixed by "utf8::") or a user-defined character property,
to represent all the characters in that property; two hexadecimal code
points for a range; or a single hexadecimal code point.
d667 3
a669 10
property (prefixed by "utf8::") or a user-defined character property,
to represent all the characters in that property; two hexadecimal code
points for a range; or a single hexadecimal code point.

=item *

Something to intersect with, prefixed by "&": an existing character
property (prefixed by "utf8::") or a user-defined character property,
for all the characters except the characters in the property; two
hexadecimal code points for a range; or a single hexadecimal code point.
a716 13
Intersection is useful for getting the common characters matched by
two (or more) classes.

    sub InFooAndBar {
        return <<'END';
    +main::Foo
    &main::Bar
    END
    }

It's important to remember not to use "&" for the first set -- that
would be intersecting with nothing (resulting in an empty set).

d796 1
a796 3
        [ 4] support for scripts (see UTR#24 Script Names), blocks,
             binary properties, enumerated non-binary properties, and
             numeric properties (as listed in UTR#18 Other Properties)
@


1.1.1.7
log
@perl 5.8.8 import
@
text
@d1153 1
a1153 1
chdir, chmod, chown, chroot, exec, link, lstat, mkdir, 
@


1.1.1.8
log
@import perl 5.10.0 from CPAN
@
text
@a12 4
People who want to learn to use Unicode in Perl, should probably read
L<the Perl Unicode tutorial|perlunitut> before reading this reference
document.

d23 2
a24 1
To indicate that Perl source itself is in UTF-8, use C<use utf8;>.
d30 2
a31 3
character scheme when presented with data that is internally encoded in
UTF-8 -- or instead uses a traditional byte scheme when presented with
byte data.
d42 3
d55 1
a55 1
By default, there is a fundamental asymmetry in Perl's Unicode model:
d61 5
d115 3
a117 1
regard to the system's native 8-bit encoding. 
d137 11
a147 10
If you use a Unicode editor to edit your program, Unicode characters may
occur directly within the literal strings in UTF-8 encoding, or UTF-16.
(The former requires a BOM or C<use utf8>, the latter requires a BOM.)

Unicode characters can also be added to a string by using the C<\x{...}>
notation.  The Unicode code for the desired character, in hexadecimal,
should be placed in the braces. For instance, a smiley face is
C<\x{263A}>.  This encoding scheme only works for all characters, but
for characters under 0x100, note that Perl may use an 8 bit encoding
internally, for optimization and/or backward compatibility.
d156 1
d167 2
a168 1
a character instead of a byte.
d177 3
a179 26
=item *

Named Unicode properties, scripts, and block ranges may be used like
character classes via the C<\p{}> "matches property" construct and
the C<\P{}> negation, "doesn't match property".

See L</"Unicode Character Properties"> for more details.

You can define your own character properties and use them
in the regular expression with the C<\p{}> or C<\P{}> construct.

See L</"User-Defined Character Properties"> for more details.

=item *

The special pattern C<\X> matches any extended Unicode
sequence--"a combining character sequence" in Standardese--where the
first character is a base character and subsequent characters are mark
characters that apply to the base character.  C<\X> is equivalent to
C<(?:\PM\pM*)>.

=item *

The C<tr///> operator translates characters instead of bytes.  Note
that the C<tr///CU> functionality has been removed.  For similar
functionality see pack('U0', ...) and pack('C0', ...).
a182 86
Case translation operators use the Unicode case translation tables
when character input is provided.  Note that C<uc()>, or C<\U> in
interpolated strings, translates to uppercase, while C<ucfirst>,
or C<\u> in interpolated strings, translates to titlecase in languages
that make the distinction.

=item *

Most operators that deal with positions or lengths in a string will
automatically switch to using character positions, including
C<chop()>, C<chomp()>, C<substr()>, C<pos()>, C<index()>, C<rindex()>,
C<sprintf()>, C<write()>, and C<length()>.  An operator that
specifically does not switch is C<vec()>.  Operators that really don't 
care include operators that treat strings as a bucket of bits such as 
C<sort()>, and operators dealing with filenames.

=item *

The C<pack()>/C<unpack()> letter C<C> does I<not> change, since it is often 
used for byte-oriented formats.  Again, think C<char> in the C language.

There is a new C<U> specifier that converts between Unicode characters
and code points. There is also a C<W> specifier that is the equivalent of
C<chr>/C<ord> and properly handles character values even if they are above 255.

=item *

The C<chr()> and C<ord()> functions work on characters, similar to
C<pack("W")> and C<unpack("W")>, I<not> C<pack("C")> and
C<unpack("C")>.  C<pack("C")> and C<unpack("C")> are methods for
emulating byte-oriented C<chr()> and C<ord()> on Unicode strings.
While these methods reveal the internal encoding of Unicode strings,
that is not something one normally needs to care about at all.

=item *

The bit string operators, C<& | ^ ~>, can operate on character data.
However, for backward compatibility, such as when using bit string
operations when characters are all less than 256 in ordinal value, one
should not use C<~> (the bit complement) with characters of both
values less than 256 and values greater than 256.  Most importantly,
DeMorgan's laws (C<~($x|$y) eq ~$x&~$y> and C<~($x&$y) eq ~$x|~$y>)
will not hold.  The reason for this mathematical I<faux pas> is that
the complement cannot return B<both> the 8-bit (byte-wide) bit
complement B<and> the full character-wide bit complement.

=item *

lc(), uc(), lcfirst(), and ucfirst() work for the following cases:

=over 8

=item *

the case mapping is from a single Unicode character to another
single Unicode character, or

=item *

the case mapping is from a single Unicode character to more
than one Unicode character.

=back

Things to do with locales (Lithuanian, Turkish, Azeri) do B<not> work
since Perl does not understand the concept of Unicode locales.

See the Unicode Technical Report #21, Case Mappings, for more details.

But you can also define your own mappings to be used in the lc(),
lcfirst(), uc(), and ucfirst() (or their string-inlined versions).

See L</"User-Defined Case Mappings"> for more details.

=back

=over 4

=item *

And finally, C<scalar reverse()> reverses by character rather than by byte.

=back

=head2 Unicode Character Properties

d185 1
a185 1
the C<\P{}> negation, "doesn't match property".
d208 2
a209 5
Unicode 5.0.0 in July 2006.>

=over 4

=item General Category
a273 2
=item Bidirectional Character Types

d303 3
a305 1
=item Scripts
a311 1
    Balinese
a313 2
    Braille
    Buginese
a316 3
    Coptic
    Cuneiform
    Cypriot
a321 1
    Glagolitic
a333 1
    Kharoshthi
a336 2
    Limbu
    LinearB
a339 2
    NewTaiLue
    Nko
a341 1
    OldPersian
a342 3
    Osmanya
    PhagsPa
    Phoenician
a343 1
    Shavian
a344 1
    SylotiNagri
a347 1
    TaiLe
a352 2
    Tifinagh
    Ugaritic
a354 2
=item Extended property classes

d364 1
a375 2
    OtherIDStart
    OtherIDContinue
a378 2
    PatternSyntax
    PatternWhiteSpace
a381 1
    STerm
a383 1
    VariationSelector
d388 13
a400 22
    Alphabetic  =  Lu + Ll + Lt + Lm + Lo + Nl + OtherAlphabetic
    Lowercase   =  Ll + OtherLowercase
    Uppercase   =  Lu + OtherUppercase
    Math        =  Sm + OtherMath

    IDStart     =  Lu + Ll + Lt + Lm + Lo + Nl + OtherIDStart
    IDContinue  =  IDStart + Mn + Mc + Nd + Pc + OtherIDContinue

    DefaultIgnorableCodePoint
                =  OtherDefaultIgnorableCodePoint
                   + Cf + Cc + Cs + Noncharacters + VariationSelector
                   - WhiteSpace - FFF9..FFFB (Annotation Characters)

    Any         =  Any code points (i.e. U+0000 to U+10FFFF)
    Assigned    =  Any non-Cn code points (i.e. synonym for \P{Cn})
    Unassigned  =  Synonym for \p{Cn}
    ASCII       =  ASCII (i.e. U+0000 to U+007F)

    Common      =  Any character (or unassigned code point)
                   not explicitly assigned to a script

=item Use of "Is" Prefix
d406 1
a406 1
=item Blocks
d418 1
a418 1
For more about scripts, see the UAX#24 "Script Names":
d420 1
a420 1
   http://www.unicode.org/reports/tr24/
a433 1
    InAegeanNumbers
a434 2
    InAncientGreekMusicalNotation
    InAncientGreekNumbers
a437 1
    InArabicSupplement
a439 1
    InBalinese
a446 1
    InBuginese
a453 1
    InCJKStrokes
a459 1
    InCombiningDiacriticalMarksSupplement
a462 4
    InCoptic
    InCountingRodNumerals
    InCuneiform
    InCuneiformNumbersAndPunctuation
a463 1
    InCypriotSyllabary
d465 1
a465 1
    InCyrillicSupplement
a471 2
    InEthiopicExtended
    InEthiopicSupplement
a474 2
    InGeorgianSupplement
    InGlagolitic
a495 1
    InKharoshthi
a496 1
    InKhmerSymbols
a501 2
    InLatinExtendedC
    InLatinExtendedD
a502 3
    InLimbu
    InLinearBIdeograms
    InLinearBSyllabary
a509 1
    InMiscellaneousSymbolsAndArrows
a510 1
    InModifierToneLetters
a513 2
    InNKo
    InNewTaiLue
a516 1
    InOldPersian
a518 5
    InOsmanya
    InPhagspa
    InPhoenician
    InPhoneticExtensions
    InPhoneticExtensionsSupplement
a520 1
    InShavian
a528 1
    InSupplementalPunctuation
a530 1
    InSylotiNagri
a534 2
    InTaiLe
    InTaiXuanJingSymbols
a539 2
    InTifinagh
    InUgaritic
a541 2
    InVariationSelectorsSupplement
    InVerticalForms
d544 96
a639 1
    InYijingHexagramSymbols
a668 4
A single hexadecimal number denoting a Unicode code point to include.

=item *

a758 2
=head2 User-Defined Case Mappings

d761 1
a761 2
The principle is similar to that of user-defined character
properties: to define subroutines in the C<main> package
d805 3
a807 3
A final note on the user-defined case mappings: they will be used
only if the scalar has been marked as having Unicode characters.
Old byte-style strings will not be affected.
d817 3
a819 2
and the section numbers refer to the Unicode Technical Standard #18,
"Unicode Regular Expressions", version 11, in May 2005.
d827 19
a845 21
        RL1.1   Hex Notation                        - done          [1]
        RL1.2   Properties                          - done          [2][3]
        RL1.2a  Compatibility Properties            - done          [4]
        RL1.3   Subtraction and Intersection        - MISSING       [5]
        RL1.4   Simple Word Boundaries              - done          [6]
        RL1.5   Simple Loose Matches                - done          [7]
        RL1.6   Line Boundaries                     - MISSING       [8]
        RL1.7   Supplementary Code Points           - done          [9]

        [1]  \x{...}
        [2]  \p{...} \P{...}
        [3]  supports not only minimal list (general category, scripts,
             Alphabetic, Lowercase, Uppercase, WhiteSpace,
             NoncharacterCodePoint, DefaultIgnorableCodePoint, Any,
             ASCII, Assigned), but also bidirectional types, blocks, etc.
             (see L</"Unicode Character Properties">)
        [4]  \d \D \s \S \w \W \X [:prop:] [:^prop:]
        [5]  can use regular expression look-ahead [a] or
             user-defined character properties [b] to emulate set operations
        [6]  \b \B
        [7]  note that Perl does Full case-folding in matching, not Simple:
d851 4
a854 7
        [8]  should do ^ and $ also on U+000B (\v in C), FF (\f), CR (\r),
             CRLF (\r\n), NEL (U+0085), LS (U+2028), and PS (U+2029);
             should also affect <>, $., and script line numbers;
             should not split lines within CRLF [c] (i.e. there is no empty
             line between \r and \n)
        [9]  UTF-8/UTF-EBDDIC used in perl allows not only U+10000 to U+10FFFF
             but also beyond U+10FFFF [d]
d857 1
a857 1
For example, what UTS#18 might write as
d873 1
a873 1
UTS#18 grouping, intersection, union, and removal (subtraction) syntax.
d875 1
a875 7
[b] '+' for union, '-' for removal (set-difference), '&' for intersection
(see L</"User-Defined Character Properties">)

[c] Try the C<:crlf> layer (see L<PerlIO>).

[d] Avoid C<use warning 'utf8';> (or say C<no warning 'utf8';>) to allow
U+FFFF (C<\x{FFFF}>).
d881 13
a893 18
        RL2.1   Canonical Equivalents           - MISSING       [10][11]
        RL2.2   Default Grapheme Clusters       - MISSING       [12][13]
        RL2.3   Default Word Boundaries         - MISSING       [14]
        RL2.4   Default Loose Matches           - MISSING       [15]
        RL2.5   Name Properties                 - MISSING       [16]
        RL2.6   Wildcard Properties             - MISSING

        [10] see UAX#15 "Unicode Normalization Forms"
        [11] have Unicode::Normalize but not integrated to regexes
        [12] have \X but at this level . should equal that
        [13] UAX#29 "Text Boundaries" considers CRLF and Hangul syllable
             clusters as a single grapheme cluster.
        [14] see UAX#29, Word Boundaries
        [15] see UAX#21 "Case Mappings"
        [16] have \N{...} but neither compute names of CJK Ideographs
             and Hangul Syllables nor use a loose match [e]

[e] C<\N{...}> allows namespaces (see L<charnames>).
d897 10
a906 21
Level 3 - Tailored Support

        RL3.1   Tailored Punctuation            - MISSING
        RL3.2   Tailored Grapheme Clusters      - MISSING       [17][18]
        RL3.3   Tailored Word Boundaries        - MISSING
        RL3.4   Tailored Loose Matches          - MISSING
        RL3.5   Tailored Ranges                 - MISSING
        RL3.6   Context Matching                - MISSING       [19]
        RL3.7   Incremental Matches             - MISSING
      ( RL3.8   Unicode Set Sharing )
        RL3.9   Possible Match Sets             - MISSING
        RL3.10  Folded Matching                 - MISSING       [20]
        RL3.11  Submatchers                     - MISSING

        [17] see UAX#10 "Unicode Collation Algorithms"
        [18] have Unicode::Collate but not integrated to regexes
        [19] have (?<=x) and (?=x), but look-aheads or look-behinds should see
             outside of the target substring
        [20] need insensitive matching for linguistic features other than case;
             for example, hiragana to katakana, wide and narrow, simplified Han
             to traditional Han (see UTR#30 "Character Foldings")
d1311 1
a1311 1
able to understand the UTF8 flag and act accordingly. If the
d1356 1
a1356 1
      if (defined $value) {
d1405 1
a1405 1
    binmode $fh, ":encoding(utf8)";
d1414 1
a1414 1
UTF8 flag is stripped off. Note that at the time of this writing
d1428 1
a1428 1
want the UTF8 flag restored:
d1490 1
a1490 1
the UTF8 flag:
d1498 1
a1498 1
L<perlunitut>, L<perluniintro>, L<Encode>, L<open>, L<utf8>, L<bytes>,
@


1.1.1.9
log
@import perl 5.10.1
@
text
@d14 2
a15 2
L<the Perl Unicode tutorial, perlunitut|perlunitut>, before reading
this reference document.
a81 10
Under byte semantics, when C<use locale> is in effect, Perl uses the 
semantics associated with the current locale.  Absent a C<use locale>, Perl
currently uses US-ASCII (or Basic Latin in Unicode terminology) byte semantics,
meaning that characters whose ordinal numbers are in the range 128 - 255 are
undefined except for their ordinal numbers.  This means that none have case
(upper and lower), nor are any a member of character classes, like C<[:alpha:]>
or C<\w>.
(But all do belong to the C<\W> class or the Perl regular expression extension
C<[:^alpha:]>.)

d108 4
a111 2
character data are concatenated, the new string will have 
character semantics.  This can cause surprises: See L</BUGS>, below
d138 1
a138 1
C<\x{263A}>.  This encoding scheme works for all characters, but
d187 1
a187 1
C<< (?>\PM\pM*) >>.
d936 1
a936 1
             (see "Unicode Character Properties")
d942 2
a943 2
             for example U+1F88 is equivalent to U+1F00 U+03B9,
             not with 1F80.  This difference matters mainly for certain Greek
d1302 3
a1304 3
situations where you simply need to force a byte
string into UTF-8, or vice versa.  The low-level calls
utf8::upgrade($bytestring) and utf8::downgrade($utf8string[, FAIL_OK]) are
d1307 4
a1310 2
Note that utf8::downgrade() can fail if the string contains characters
that don't fit into a byte.
d1324 1
a1324 1
pragma is not in effect.  C<SvUTF8(sv)> returns true if the C<UTF8>
d1337 1
a1337 1
C<uvchr_to_utf8(buf, chr)> writes a Unicode character code point into
d1339 1
a1339 1
pointing after the UTF-8 bytes.  It works appropriately on EBCDIC machines.
d1343 1
a1343 1
C<utf8_to_uvchr(buf, lenp)> reads UTF-8 encoded bytes from a buffer and
d1345 1
a1345 1
the UTF-8 byte sequence.  It works appropriately on EBCDIC machines.
d1391 1
a1391 1
C<utf8_hop(s, off)> will return a pointer to a UTF-8 encoded buffer
d1409 1
a1409 1
C<ibcmp_utf8(s1, pe1, l1, u1, s2, pe2, l2, u2)> can be used to
a1428 22
=head2 Problems with characters whose ordinal numbers are in the range 128 - 255 with no Locale specified

Without a locale specified, unlike all other characters or code points,
these characters have very different semantics in byte semantics versus
character semantics.
In character semantics they are interpreted as Unicode code points, which means
they are viewed as Latin-1 (ISO-8859-1).
In byte semantics, they are considered to be unassigned characters,
meaning that the only semantics they have is their
ordinal numbers, and that they are not members of various character classes.
None are considered to match C<\w> for example, but all match C<\W>.
Besides these class matches,
the known operations that this affects are those that change the case,
regular expression matching while ignoring case,
and B<quotemeta()>.
This can lead to unexpected results in which a string's semantics suddenly
change if a code point above 255 is appended to or removed from it,
which changes the string's semantics from byte to character or vice versa.
This behavior is scheduled to change in version 5.12, but in the meantime,
a workaround is to always call utf8::upgrade($string), or to use the
standard modules L<Encode> or L<charnames>.

a1507 9

=head2 Possible problems on EBCDIC platforms

In earlier versions, when byte and character data were concatenated,
the new string was sometimes created by
decoding the byte strings as I<ISO 8859-1 (Latin-1)>, even if the
old Unicode string used EBCDIC.

If you find any of these, please report them as bugs.
@


1.1.1.10
log
@Perl 5.12.2 from CPAN
@
text
@d34 1
a34 1
UTF-8, or instead uses a traditional byte scheme when presented with
d60 1
a60 1
codepoints in Unicode happens to agree with Latin-1.
d82 9
a90 8
Under byte semantics, when C<use locale> is in effect, Perl uses the
semantics associated with the current locale.  Absent a C<use locale>, and
absent a C<use feature 'unicode_strings'> pragma, Perl currently uses US-ASCII
(or Basic Latin in Unicode terminology) byte semantics, meaning that characters
whose ordinal numbers are in the range 128 - 255 are undefined except for their
ordinal numbers.  This means that none have case (upper and lower), nor are any
a member of character classes, like C<[:alpha:]> or C<\w>.  (But all do belong
to the C<\W> class or the Perl regular expression extension C<[:^alpha:]>.)
d94 1
a94 1
none of the program's inputs were marked as being a source of Unicode
a101 5
The C<use feature 'unicode_strings'> pragma is intended to always, regardless
of platform, force Unicode semantics in a particular lexical scope.  In
release 5.12, it is partially implemented, applying only to case changes.
See L</The "Unicode Bug"> below.

d115 1
a115 3
be used to force byte semantics on Unicode data, and the C<use feature
'unicode_strings'> pragma to force Unicode semantics on byte data (though in
5.12 it isn't fully implemented).
d118 2
a119 3
character data are concatenated, the new string will have
character semantics.  This can cause surprises: See L</BUGS>, below.
You can choose to be warned when this happens.  See L<encoding::warnings>.
d143 1
a143 1
Unicode characters can also be added to a string by using the C<\N{U+...}>
d145 4
a148 8
should be placed in the braces, after the C<U>. For instance, a smiley face is
C<\N{U+263A}>.

Alternatively, you can use the C<\x{...}> notation for characters 0x100 and
above.  For characters below 0x100 you may get byte semantics instead of
character semantics;  see L</The "Unicode Bug">.  On EBCDIC machines there is
the additional problem that the value for such characters gives the EBCDIC
character rather than the Unicode one.
a155 1
See L<charnames>.
d181 1
d186 1
d191 5
a195 5
The special pattern C<\X> matches a logical character, an "extended grapheme
cluster" in Standardese.  In Unicode what appears to the user to be a single
character, for example an accented C<G>, may in fact be composed of a sequence
of characters, in this case a C<G> followed by an accent character.  C<\X>
will match the entire sequence.
d209 1
a209 2
that make the distinction (which is equivalent to uppercase in languages
without the distinction).
d217 2
a218 2
specifically does not switch is C<vec()>.  Operators that really don't
care include operators that treat strings as a bucket of bits such as
d223 1
a223 1
The C<pack()>/C<unpack()> letter C<C> does I<not> change, since it is often
d253 22
a274 1
You can define your own mappings to be used in lc(),
d276 1
d291 19
a309 57
Most Unicode character properties are accessible by using regular expressions.
They are used like character classes via the C<\p{}> "matches property"
construct and the C<\P{}> negation, "doesn't match property".

For instance, C<\p{Uppercase}> matches any character with the Unicode
"Uppercase" property, while C<\p{L}> matches any character with a
General_Category of "L" (letter) property.  Brackets are not
required for single letter properties, so C<\p{L}> is equivalent to C<\pL>.

More formally, C<\p{Uppercase}> matches any character whose Unicode Uppercase
property value is True, and C<\P{Uppercase}> matches any character whose
Uppercase property value is False, and they could have been written as
C<\p{Uppercase=True}> and C<\p{Uppercase=False}>, respectively

This formality is needed when properties are not binary, that is if they can
take on more values than just True and False.  For example, the Bidi_Class (see
L</"Bidirectional Character Types"> below), can take on a number of different
values, such as Left, Right, Whitespace, and others.  To match these, one needs
to specify the property name (Bidi_Class), and the value being matched against
(Left, Right, I<etc.>).  This is done, as in the examples above, by having the
two components separated by an equal sign (or interchangeably, a colon), like
C<\p{Bidi_Class: Left}>.

All Unicode-defined character properties may be written in these compound forms
of C<\p{property=value}> or C<\p{property:value}>, but Perl provides some
additional properties that are written only in the single form, as well as
single-form short-cuts for all binary properties and certain others described
below, in which you may omit the property name and the equals or colon
separator.

Most Unicode character properties have at least two synonyms (or aliases if you
prefer), a short one that is easier to type, and a longer one which is more
descriptive and hence it is easier to understand what it means.  Thus the "L"
and "Letter" above are equivalent and can be used interchangeably.  Likewise,
"Upper" is a synonym for "Uppercase", and we could have written
C<\p{Uppercase}> equivalently as C<\p{Upper}>.  Also, there are typically
various synonyms for the values the property can be.   For binary properties,
"True" has 3 synonyms: "T", "Yes", and "Y"; and "False has correspondingly "F",
"No", and "N".  But be careful.  A short form of a value for one property may
not mean the same thing as the same short form for another.  Thus, for the
General_Category property, "L" means "Letter", but for the Bidi_Class property,
"L" means "Left".  A complete list of properties and synonyms is in
L<perluniprops>.

Upper/lower case differences in the property names and values are irrelevant,
thus C<\p{Upper}> means the same thing as C<\p{upper}> or even C<\p{UpPeR}>.
Similarly, you can add or subtract underscores anywhere in the middle of a
word, so that these are also equivalent to C<\p{U_p_p_e_r}>.  And white space
is irrelevant adjacent to non-word characters, such as the braces and the equals
or colon separators so C<\p{   Upper  }> and C<\p{ Upper_case : Y }> are
equivalent to these as well.  In fact, in most cases, white space and even
hyphens can be added or deleted anywhere.  So even C<\p{ Up-per case = Yes}> is
equivalent.  All this is called "loose-matching" by Unicode.  The few places
where stricter matching is employed is in the middle of numbers, and the Perl
extension properties that begin or end with an underscore.  Stricter matching
cares about white space (except adjacent to the non-word characters) and
hyphens, and non-interior underscores.
d315 4
a318 1
=head3 B<General_Category>
d320 1
a320 8
Every Unicode character is assigned a general category, which is the "most
usual categorization of a character" (from
L<http://www.unicode.org/reports/tr44>).

The compound way of writing these is like C<\p{General_Category=Number}>
(short, C<\p{gc:n}>).  But Perl furnishes shortcuts in which everything up
through the equal or colon separator is omitted.  So you can instead just write
C<\pN>.
d322 3
a324 1
Here are the short and long forms of the General Category properties:
d329 6
a334 6
    LC, L&      Cased_Letter (that is: [\p{Ll}\p{Lu}\p{Lt}])
    Lu          Uppercase_Letter
    Ll          Lowercase_Letter
    Lt          Titlecase_Letter
    Lm          Modifier_Letter
    Lo          Other_Letter
d337 3
a339 3
    Mn          Nonspacing_Mark
    Mc          Spacing_Mark
    Me          Enclosing_Mark
d342 10
a351 10
    Nd          Decimal_Number (also Digit)
    Nl          Letter_Number
    No          Other_Number

    P           Punctuation (also Punct)
    Pc          Connector_Punctuation
    Pd          Dash_Punctuation
    Ps          Open_Punctuation
    Pe          Close_Punctuation
    Pi          Initial_Punctuation
d353 1
a353 1
    Pf          Final_Punctuation
d355 1
a355 1
    Po          Other_Punctuation
d358 4
a361 4
    Sm          Math_Symbol
    Sc          Currency_Symbol
    Sk          Modifier_Symbol
    So          Other_Symbol
d364 3
a366 3
    Zs          Space_Separator
    Zl          Line_Separator
    Zp          Paragraph_Separator
d369 1
a369 1
    Cc          Control	(also Cntrl)
d372 1
a372 1
    Co          Private_Use
d385 1
a385 1
=head3 B<Bidirectional Character Types>
d389 1
a389 1
the Bidi_Class class:
d397 1
a397 1
    AL          Arabic Letter
d402 2
a403 2
    ES          European Separator
    ET          European Terminator
d405 1
a405 1
    CS          Common Separator
d413 1
a413 2
This property is always written in the compound form.
For example, C<\p{Bidi_Class:R}> matches characters that are normally
d416 1
a416 1
=head3 B<Scripts>
d418 2
a419 10
The world's languages are written in a number of scripts.  This sentence
(unless you're reading it in translation) is written in Latin, while Russian is
written in Cyrllic, and Greek is written in, well, Greek; Japanese mainly in
Hiragana or Katakana.  There are many more.

The Unicode Script property gives what script a given character is in,
and can be matched with the compound form like C<\p{Script=Hebrew}> (short:
C<\p{sc=hebr}>).  Perl furnishes shortcuts for all script names.  You can omit
everything up through the equals (or colon), and simply write C<\p{Latin}> or
C<\P{Cyrillic}>.
d421 123
a543 1
A complete list of scripts and their shortcuts is in L<perluniprops>.
d545 4
a548 1
=head3 B<Use of "Is" Prefix>
d551 2
a552 3
so far may have C<Is> or C<Is_> prepended to their name, so C<\P{Is_Lu}>, for
example, is equal to C<\P{Lu}>, and C<\p{IsScript:Arabic}> is equal to
C<\p{Arabic}>.
d554 1
a554 1
=head3 B<Blocks>
d559 177
a735 273
of blocks is more of an artificial grouping based on groups of Unicode
characters with consecutive ordinal values. For example, the "Basic Latin"
block is all characters whose ordinals are between 0 and 127, inclusive, in
other words, the ASCII characters.  The "Latin" script contains some letters
from this block as well as several more, like "Latin-1 Supplement",
"Latin Extended-A", I<etc.>, but it does not contain all the characters from
those blocks. It does not, for example, contain digits, because digits are
shared across many scripts. Digits and similar groups, like punctuation, are in
the script called C<Common>.  There is also a script called C<Inherited> for
characters that modify other characters, and inherit the script value of the
controlling character.

For more about scripts versus blocks, see UAX#24 "Unicode Script Property":
L<http://www.unicode.org/reports/tr24>

The Script property is likely to be the one you want to use when processing
natural language; the Block property may be useful in working with the nuts and
bolts of Unicode.

Block names are matched in the compound form, like C<\p{Block: Arrows}> or
C<\p{Blk=Hebrew}>.  Unlike most other properties only a few block names have a
Unicode-defined short name.  But Perl does provide a (slight) shortcut:  You
can say, for example C<\p{In_Arrows}> or C<\p{In_Hebrew}>.  For backwards
compatibility, the C<In> prefix may be omitted if there is no naming conflict
with a script or any other property, and you can even use an C<Is> prefix
instead in those cases.  But it is not a good idea to do this, for a couple
reasons:

=over 4

=item 1

It is confusing.  There are many naming conflicts, and you may forget some.
For example, C<\p{Hebrew}> means the I<script> Hebrew, and NOT the I<block>
Hebrew.  But would you remember that 6 months from now?

=item 2

It is unstable.  A new version of Unicode may pre-empt the current meaning by
creating a property with the same name.  There was a time in very early Unicode
releases when C<\p{Hebrew}> would have matched the I<block> Hebrew; now it
doesn't.

=back

Some people just prefer to always use C<\p{Block: foo}> and C<\p{Script: bar}>
instead of the shortcuts, for clarity, and because they can't remember the
difference between 'In' and 'Is' anyway (or aren't confident that those who
eventually will read their code will know).

A complete list of blocks and their shortcuts is in L<perluniprops>.

=head3 B<Other Properties>

There are many more properties than the very basic ones described here.
A complete list is in L<perluniprops>.

Unicode defines all its properties in the compound form, so all single-form
properties are Perl extensions.  A number of these are just synonyms for the
Unicode ones, but some are genunine extensions, including a couple that are in
the compound form.  And quite a few of these are actually recommended by Unicode
(in L<http://www.unicode.org/reports/tr18>).

This section gives some details on all the extensions that aren't synonyms for
compound-form Unicode properties (for those, you'll have to refer to the
L<Unicode Standard|http://www.unicode.org/reports/tr44>.

=over

=item B<C<\p{All}>>

This matches any of the 1_114_112 Unicode code points.  It is a synonym for
C<\p{Any}>.

=item B<C<\p{Alnum}>>

This matches any C<\p{Alphabetic}> or C<\p{Decimal_Number}> character.

=item B<C<\p{Any}>>

This matches any of the 1_114_112 Unicode code points.  It is a synonym for
C<\p{All}>.

=item B<C<\p{Assigned}>>

This matches any assigned code point; that is, any code point whose general
category is not Unassigned (or equivalently, not Cn).

=item B<C<\p{Blank}>>

This is the same as C<\h> and C<\p{HorizSpace}>:  A character that changes the
spacing horizontally.

=item B<C<\p{Decomposition_Type: Non_Canonical}>>    (Short: C<\p{Dt=NonCanon}>)

Matches a character that has a non-canonical decomposition.

To understand the use of this rarely used property=value combination, it is
necessary to know some basics about decomposition.
Consider a character, say H.  It could appear with various marks around it,
such as an acute accent, or a circumflex, or various hooks, circles, arrows,
I<etc.>, above, below, to one side and/or the other, I<etc.>  There are many
possibilities among the world's languages.  The number of combinations is
astronomical, and if there were a character for each combination, it would
soon exhaust Unicode's more than a million possible characters.  So Unicode
took a different approach: there is a character for the base H, and a
character for each of the possible marks, and they can be combined variously
to get a final logical character.  So a logical character--what appears to be a
single character--can be a sequence of more than one individual characters.
This is called an "extended grapheme cluster".  (Perl furnishes the C<\X>
construct to match such sequences.)

But Unicode's intent is to unify the existing character set standards and
practices, and a number of pre-existing standards have single characters that
mean the same thing as some of these combinations.  An example is ISO-8859-1,
which has quite a few of these in the Latin-1 range, an example being "LATIN
CAPITAL LETTER E WITH ACUTE".  Because this character was in this pre-existing
standard, Unicode added it to its repertoire.  But this character is considered
by Unicode to be equivalent to the sequence consisting of first the character
"LATIN CAPITAL LETTER E", then the character "COMBINING ACUTE ACCENT".

"LATIN CAPITAL LETTER E WITH ACUTE" is called a "pre-composed" character, and
the equivalence with the sequence is called canonical equivalence.  All
pre-composed characters are said to have a decomposition (into the equivalent
sequence) and the decomposition type is also called canonical.

However, many more characters have a different type of decomposition, a
"compatible" or "non-canonical" decomposition.  The sequences that form these
decompositions are not considered canonically equivalent to the pre-composed
character.  An example, again in the Latin-1 range, is the "SUPERSCRIPT ONE".
It is kind of like a regular digit 1, but not exactly; its decomposition
into the digit 1 is called a "compatible" decomposition, specifically a
"super" decomposition.  There are several such compatibility
decompositions (see L<http://www.unicode.org/reports/tr44>), including one
called "compat" which means some miscellaneous type of decomposition
that doesn't fit into the decomposition categories that Unicode has chosen. 

Note that most Unicode characters don't have a decomposition, so their
decomposition type is "None".

Perl has added the C<Non_Canonical> type, for your convenience, to mean any of
the compatibility decompositions.

=item B<C<\p{Graph}>>

Matches any character that is graphic.  Theoretically, this means a character
that on a printer would cause ink to be used.

=item B<C<\p{HorizSpace}>>

This is the same as C<\h> and C<\p{Blank}>:  A character that changes the
spacing horizontally.

=item B<C<\p{In=*}>> 

This is a synonym for C<\p{Present_In=*}>

=item B<C<\p{PerlSpace}>>

This is the same as C<\s>, restricted to ASCII, namely C<S<[ \f\n\r\t]>>.

Mnemonic: Perl's (original) space

=item B<C<\p{PerlWord}>>

This is the same as C<\w>, restricted to ASCII, namely C<[A-Za-z0-9_]>

Mnemonic: Perl's (original) word.

=item B<C<\p{PosixAlnum}>>

This matches any alphanumeric character in the ASCII range, namely
C<[A-Za-z0-9]>.

=item B<C<\p{PosixAlpha}>>

This matches any alphabetic character in the ASCII range, namely C<[A-Za-z]>.

=item B<C<\p{PosixBlank}>>

This matches any blank character in the ASCII range, namely C<S<[ \t]>>.

=item B<C<\p{PosixCntrl}>>

This matches any control character in the ASCII range, namely C<[\x00-\x1F\x7F]>

=item B<C<\p{PosixDigit}>>

This matches any digit character in the ASCII range, namely C<[0-9]>.

=item B<C<\p{PosixGraph}>>

This matches any graphical character in the ASCII range, namely C<[\x21-\x7E]>.

=item B<C<\p{PosixLower}>>

This matches any lowercase character in the ASCII range, namely C<[a-z]>.

=item B<C<\p{PosixPrint}>>

This matches any printable character in the ASCII range, namely C<[\x20-\x7E]>.
These are the graphical characters plus SPACE.

=item B<C<\p{PosixPunct}>>

This matches any punctuation character in the ASCII range, namely
C<[\x21-\x2F\x3A-\x40\x5B-\x60\x7B-\x7E]>.  These are the
graphical characters that aren't word characters.  Note that the Posix standard
includes in its definition of punctuation, those characters that Unicode calls
"symbols."

=item B<C<\p{PosixSpace}>>

This matches any space character in the ASCII range, namely
C<S<[ \f\n\r\t\x0B]>> (the last being a vertical tab).

=item B<C<\p{PosixUpper}>>

This matches any uppercase character in the ASCII range, namely C<[A-Z]>.

=item B<C<\p{Present_In: *}>>    (Short: C<\p{In=*}>)

This property is used when you need to know in what Unicode version(s) a
character is.

The "*" above stands for some two digit Unicode version number, such as
C<1.1> or C<4.0>; or the "*" can also be C<Unassigned>.  This property will
match the code points whose final disposition has been settled as of the
Unicode release given by the version number; C<\p{Present_In: Unassigned}>
will match those code points whose meaning has yet to be assigned.

For example, C<U+0041> "LATIN CAPITAL LETTER A" was present in the very first
Unicode release available, which is C<1.1>, so this property is true for all
valid "*" versions.  On the other hand, C<U+1EFF> was not assigned until version
5.1 when it became "LATIN SMALL LETTER Y WITH LOOP", so the only "*" that
would match it are 5.1, 5.2, and later.

Unicode furnishes the C<Age> property from which this is derived.  The problem
with Age is that a strict interpretation of it (which Perl takes) has it
matching the precise release a code point's meaning is introduced in.  Thus
C<U+0041> would match only 1.1; and C<U+1EFF> only 5.1.  This is not usually what
you want.

Some non-Perl implementations of the Age property may change its meaning to be
the same as the Perl Present_In property; just be aware of that.

Another confusion with both these properties is that the definition is not
that the code point has been assigned, but that the meaning of the code point
has been determined.  This is because 66 code points will always be
unassigned, and, so the Age for them is the Unicode version the decision to
make them so was made in.  For example, C<U+FDD0> is to be permanently
unassigned to a character, and the decision to do that was made in version 3.1,
so C<\p{Age=3.1}> matches this character and C<\p{Present_In: 3.1}> and up
matches as well.

=item B<C<\p{Print}>>

This matches any character that is graphical or blank, except controls.

=item B<C<\p{SpacePerl}>>

This is the same as C<\s>, including beyond ASCII.

Mnemonic: Space, as modified by Perl.  (It doesn't include the vertical tab
which both the Posix standard and Unicode consider to be space.)

=item B<C<\p{VertSpace}>>

This is the same as C<\v>:  A character that changes the spacing vertically.

=item B<C<\p{Word}>>

This is the same as C<\w>, including beyond ASCII.
d741 6
a746 6
You can define your own binary character properties by defining subroutines
whose names begin with "In" or "Is".  The subroutines can be defined in any
package.  The user-defined properties can be used in the regular expression
C<\p> and C<\P> constructs; if you are using a user-defined property from a
package other than the one you are in, you must specify its package in the
C<\p> or C<\P> construct.
d748 1
a748 1
    # assuming property Is_Foreign defined in Lang::
d856 1
a856 1
It's important to remember not to use "&" for the first set; that
d864 1
a864 1
properties: to define subroutines
d869 4
a872 3
The string returned by the subroutines needs to be two hexadecimal numbers
separated by two tabulators: the two numbers being, respectively, the source
code point and the destination code point.  For example:
d876 1
a876 1
    0061\t\t0041
d880 14
a893 2
defines an uc() mapping that causes only the character "a"
to be mapped to "A"; all other characters will remain unchanged.
d895 2
a896 13
(For serious hackers only)  The above means you have to furnish a complete
mapping; you can't just override a couple of characters and leave the rest
unchanged.  You can find all the mappings in the directory
C<$Config{privlib}>/F<unicore/To/>.  The mapping data is returned as the
here-document, and the C<utf8::ToSpecFoo> are special exception mappings
derived from <$Config{privlib}>/F<unicore/SpecialCasing.txt>.  The "Digit" and
"Fold" mappings that one can see in the directory are not directly
user-accessible, one can use either the C<Unicode::UCD> module, or just match
case-insensitively (that's when the "Fold" mapping is used).

The mappings will only take effect on scalars that have been marked as having
Unicode characters, for example by using C<utf8::upgrade()>.
Old byte-style strings are not affected.
d898 13
a910 1
The mappings are in effect for the package they are defined in.
d940 5
a944 2
	[3]  supports not only minimal list, but all Unicode character
	     properties (see L</Unicode Character Properties>)
d949 2
a950 2
	[7]  note that Perl does Full case-folding in matching (but with bugs),
	     not Simple: for example U+1F88 is equivalent to U+1F00 U+03B9,
d987 2
a988 2
[d] U+FFFF will currently generate a warning message if 'utf8' warnings are
    enabled
d995 1
a995 1
        RL2.2   Default Grapheme Clusters       - MISSING       [12]
d1003 3
a1005 1
        [12] have \X but we don't have a "Grapheme Cluster Mode"
d1057 1
a1057 1
 Code Points		1st Byte  2nd Byte  3rd Byte  4th Byte
d1059 3
a1061 3
   U+0000..U+007F	00..7F
   U+0080..U+07FF     * C2..DF    80..BF
   U+0800..U+0FFF	E0      * A0..BF    80..BF
d1064 1
a1064 1
   U+D800..U+DFFF       +++++++ utf16 surrogates, not legal utf8 +++++++
d1066 11
a1076 9
  U+10000..U+3FFFF	F0      * 90..BF    80..BF    80..BF
  U+40000..U+FFFFF	F1..F3    80..BF    80..BF    80..BF
 U+100000..U+10FFFF	F4        80..8F    80..BF    80..BF

Note the gaps before several of the byte entries above marked by '*'.  These are
caused by legal UTF-8 avoiding non-shortest encodings: it is technically
possible to UTF-8-encode a single code point in different ways, but that is
explicitly forbidden, and the shortest possible encoding should always be used
(and that is what Perl does).
d1087 2
a1088 2
As you can see, the continuation bytes all begin with "10", and the
leading bits of the start byte tell how many bytes there are in the
d1112 1
a1112 1
surrogates> are the range C<U+D800..U+DBFF> and the I<low surrogates>
d1123 1
a1123 1
will get a warning, if warnings are turned on, because those code
d1147 1
a1147 3
format".  (Actually, C<U+FFFE> is legal for use by your program, even for
input/output, but better not use it if you need a BOM.  But it is "illegal for
interchange", so that an unsuspecting program won't get confused.)
a1177 3
Read L<Unicode Security Considerations|http://www.unicode.org/reports/tr36>.
Also, note the following:

d1190 1
a1190 1
shortest length UTF-8, and with warnings on, Perl will warn about
d1267 1
a1267 2
The following are such interfaces.  Also, see L</The "Unicode Bug">.
For all of these interfaces Perl
d1272 1
a1272 1
these cases is that the answers are highly dependent on the operating
d1282 1
a1282 1
chdir, chmod, chown, chroot, exec, link, lstat, mkdir,
a1306 85
=head2 The "Unicode Bug"

The term, the "Unicode bug" has been applied to an inconsistency with the
Unicode characters whose ordinals are in the Latin-1 Supplement block, that
is, between 128 and 255.  Without a locale specified, unlike all other
characters or code points, these characters have very different semantics in
byte semantics versus character semantics.

In character semantics they are interpreted as Unicode code points, which means
they have the same semantics as Latin-1 (ISO-8859-1).

In byte semantics, they are considered to be unassigned characters, meaning
that the only semantics they have is their ordinal numbers, and that they are
not members of various character classes.  None are considered to match C<\w>
for example, but all match C<\W>.  (On EBCDIC platforms, the behavior may
be different from this, depending on the underlying C language library
functions.)

The behavior is known to have effects on these areas:

=over 4

=item *

Changing the case of a scalar, that is, using C<uc()>, C<ucfirst()>, C<lc()>,
and C<lcfirst()>, or C<\L>, C<\U>, C<\u> and C<\l> in regular expression
substitutions.

=item *

Using caseless (C</i>) regular expression matching

=item *

Matching a number of properties in regular expressions, such as C<\w>

=item *

User-defined case change mappings.  You can create a C<ToUpper()> function, for
example, which overrides Perl's built-in case mappings.  The scalar must be
encoded in utf8 for your function to actually be invoked.

=back

This behavior can lead to unexpected results in which a string's semantics
suddenly change if a code point above 255 is appended to or removed from it,
which changes the string's semantics from byte to character or vice versa.  As
an example, consider the following program and its output:

 $ perl -le'
     $s1 = "\xC2";
     $s2 = "\x{2660}";
     for ($s1, $s2, $s1.$s2) {
         print /\w/ || 0;
     }
 '
 0
 0
 1

If there's no C<\w> in C<s1> or in C<s2>, why does their concatenation have one?

This anomaly stems from Perl's attempt to not disturb older programs that
didn't use Unicode, and hence had no semantics for characters outside of the
ASCII range (except in a locale), along with Perl's desire to add Unicode
support seamlessly.  The result wasn't seamless: these characters were
orphaned.

Work is being done to correct this, but only some of it was complete in time
for the 5.12 release.  What has been finished is the important part of the case
changing component.  Due to concerns, and some evidence, that older code might
have come to rely on the existing behavior, the new behavior must be explicitly
enabled by the feature C<unicode_strings> in the L<feature> pragma, even though
no new syntax is involved.

See L<perlfunc/lc> for details on how this pragma works in combination with
various others for casing.  Even though the pragma only affects casing
operations in the 5.12 release, it is planned to have it affect all the
problematic behaviors in later releases: you can't have one without them all.

In the meantime, a workaround is to always call utf8::upgrade($string), or to
use the standard module L<Encode>.   Also, a scalar that has any characters
whose ordinal is above 0x100, or which were specified using either of the
C<\N{...}> notations will automatically have character semantics.

d1309 2
a1310 2
Sometimes (see L</"When Unicode Does Not Happen"> or L</The "Unicode Bug">)
there are situations where you simply need to force a byte
a1317 3
Calling either function on a string that already is in the desired state is a
no-op.

a1423 18
=head2 Hacking Perl to work on earlier Unicode versions (for very serious hackers only)

Perl by default comes with the latest supported Unicode version built in, but
you can change to use any earlier one.

Download the files in the version of Unicode that you want from the Unicode web
site L<http://www.unicode.org>).  These should replace the existing files in
C<\$Config{privlib}>/F<unicore>.  (C<\%Config> is available from the Config
module.)  Follow the instructions in F<README.perl> in that directory to change
some of their names, and then run F<make>.

It is even possible to download them to a different directory, and then change
F<utf8_heavy.pl> in the directory C<\$Config{privlib}> to point to the new
directory, or maybe make a copy of that directory before making the change, and
using C<@@INC> or the C<-I> run-time flag to switch between versions at will
(but because of caching, not in the middle of a process), but all this is
beyond the scope of these instructions.

d1435 1
a1435 1
=head2 Problems with characters in the Latin-1 Supplement range
d1437 19
a1455 9
See L</The "Unicode Bug">

=head2 Problems with case-insensitive regular expression matching

There are problems with case-insensitive matches, including those involving
character classes (enclosed in [square brackets]), characters whose fold
is to multiple characters (such as the single character LATIN SMALL LIGATURE
FFL matches case-insensitively with the 3-character string C<ffl>), and
characters in the Latin-1 Supplement.
d1537 1
a1537 4
=head2 Problems on EBCDIC platforms

There are a number of known problems with Perl on EBCDIC platforms.  If you
want to use Perl there, send email to perlbug@@perl.org.
d1656 1
a1656 1
L<perlunitut>, L<perluniintro>, L<perluniprops>, L<Encode>, L<open>, L<utf8>, L<bytes>,
a1657 1
L<http://www.unicode.org/reports/tr44>).
@


1.1.1.11
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d14 1
a14 2
the L<Perl Unicode tutorial, perlunitut|perlunitut> and
L<perluniintro>, before reading
a16 3
Also, the use of Unicode may present security issues that aren't obvious.
Read L<Unicode Security Considerations|http://www.unicode.org/reports/tr36>.

a18 11
=item Safest if you "use feature 'unicode_strings'"

In order to preserve backward compatibility, Perl does not turn
on full internal Unicode support unless the pragma
C<use feature 'unicode_strings'> is specified.  (This is automatically
selected if you use C<use 5.012> or higher.)  Failure to do this can
trigger unexpected surprises.  See L</The "Unicode Bug"> below.

This pragma doesn't affect I/O, and there are still several places
where Unicode isn't fully supported, such as in filenames.

d23 1
a23 1
the ":encoding(utf8)" layer.  Other encodings can be converted to Perl's
d29 8
d71 14
a84 27
Starting in Perl 5.14, Perl-level operations work with
characters rather than bytes within the scope of a
C<L<use feature 'unicode_strings'|feature>> (or equivalently
C<use 5.012> or higher).  (This is not true if bytes have been
explicitly requested by C<L<use bytes|bytes>>, nor necessarily true
for interactions with the platform's operating system.)

For earlier Perls, and when C<unicode_strings> is not in effect, Perl
provides a fairly safe environment that can handle both types of
semantics in programs.  For operations where Perl can unambiguously
decide that the input data are characters, Perl switches to character
semantics.  For operations where this determination cannot be made
without additional information from the user, Perl decides in favor of
compatibility and chooses to use byte semantics.

When C<use locale> (but not C<use locale ':not_characters'>) is in
effect, Perl uses the semantics associated with the current locale.
(C<use locale> overrides C<use feature 'unicode_strings'> in the same scope;
while C<use locale ':not_characters'> effectively also selects
C<use feature 'unicode_strings'> in its scope; see L<perllocale>.)
Otherwise, Perl uses the platform's native
byte semantics for characters whose code points are less than 256, and
Unicode semantics for those greater than 255.  On EBCDIC platforms, this
is almost seamless, as the EBCDIC code pages that Perl handles are
equivalent to Unicode's first 256 code points.  (The exception is that
EBCDIC regular expression case-insensitive matching rules are not as
as robust as Unicode's.)   But on ASCII platforms, Perl uses US-ASCII
d98 8
d112 11
d159 1
a159 2
character rather than the Unicode one, thus it is more portable to use
C<\N{U+...}> instead.
d161 1
a161 6
Additionally, you can use the C<\N{...}> notation and put the official
Unicode character name within the braces, such as
C<\N{WHITE SMILING FACE}>.  This automatically loads the L<charnames>
module with the C<:full> and C<:short> options.  If you prefer different
options for this module, you can instead, before the C<\N{...}>,
explicitly load it with your desired options; for example,
d163 5
a167 1
   use charnames ':loose';
d183 1
a183 1
Bracketed character classes in regular expressions match characters instead of
d190 2
a191 2
Named Unicode properties, scripts, and block ranges may be used (like bracketed
character classes) by using the C<\p{}> "matches property" construct and
d264 3
a266 7
There is a CPAN module, L<Unicode::Casing>, which allows you to define
your own mappings to be used in C<lc()>, C<lcfirst()>, C<uc()>,
C<ucfirst()>, and C<fc> (or their double-quoted string inlined
versions such as C<\U>).
(Prior to Perl 5.16, this functionality was partially provided
in the Perl core, but suffered from a number of insurmountable
drawbacks, so the CPAN module was written instead.)
d280 3
a282 8
(The only time that Perl considers a sequence of individual code
points as a single logical character is in the C<\X> construct, already
mentioned above.   Therefore "character" in this discussion means a single
Unicode code point.)

Very nearly all Unicode character properties are accessible through
regular expressions by using the C<\p{}> "matches property" construct
and the C<\P{}> "doesn't match property" for its negation.
d284 1
a284 1
For instance, C<\p{Uppercase}> matches any single character with the Unicode
d287 1
a287 1
required for single letter property names, so C<\p{L}> is equivalent to C<\pL>.
d289 4
a292 4
More formally, C<\p{Uppercase}> matches any single character whose Unicode
Uppercase property value is True, and C<\P{Uppercase}> matches any character
whose Uppercase property value is False, and they could have been written as
C<\p{Uppercase=True}> and C<\p{Uppercase=False}>, respectively.
d294 1
a294 1
This formality is needed when properties are not binary; that is, if they can
d296 1
a296 1
L</"Bidirectional Character Types"> below), can take on several different
d298 2
a299 3
to specify both the property name (Bidi_Class), AND the value being
matched against
(Left, Right, etc.).  This is done, as in the examples above, by having the
d311 3
a313 3
prefer): a short one that is easier to type and a longer one that is more
descriptive and hence easier to understand.  Thus the "L" and "Letter" properties
above are equivalent and can be used interchangeably.  Likewise,
d324 1
a324 1
Upper/lower case differences in property names and values are irrelevant;
d329 3
a331 3
or colon separators, so C<\p{   Upper  }> and C<\p{ Upper_case : Y }> are
equivalent to these as well.  In fact, white space and even
hyphens can usually be added or deleted anywhere.  So even C<\p{ Up-per case = Yes}> is
d333 1
a333 1
where stricter matching is used is in the middle of numbers, and in the Perl
d335 1
a335 1
cares about white space (except adjacent to non-word characters),
a341 27
Almost all properties are immune to case-insensitive matching.  That is,
adding a C</i> regular expression modifier does not change what they
match.  There are two sets that are affected.
The first set is
C<Uppercase_Letter>,
C<Lowercase_Letter>,
and C<Titlecase_Letter>,
all of which match C<Cased_Letter> under C</i> matching.
And the second set is
C<Uppercase>,
C<Lowercase>,
and C<Titlecase>,
all of which match C<Cased> under C</i> matching.
This set also includes its subsets C<PosixUpper> and C<PosixLower> both
of which under C</i> matching match C<PosixAlpha>.
(The difference between these sets is that some things, such as Roman
numerals, come in both upper and lower case so they are C<Cased>, but aren't considered
letters, so they aren't C<Cased_Letter>s.)

The result is undefined if you try to match a non-Unicode code point
(that is, one above 0x10FFFF) against a Unicode property.  Currently, a
warning is raised, and the match will fail.  In some cases, this is
counterintuitive, as both these fail:

 chr(0x110000) =~ \p{ASCII_Hex_Digit=True}      # Fails.
 chr(0x110000) =~ \p{ASCII_Hex_Digit=False}     # Fails!

d398 1
a398 1
    Cc          Control (also Cntrl)
d400 1
a400 1
    Cs          Surrogate
d406 7
a412 1
C<LC> and C<L&> are special: both are aliases for the set consisting of everything matched by C<Ll>, C<Lu>, and C<Lt>.
d416 2
a417 2
Because scripts differ in their directionality (Hebrew and Arabic are
written right to left, for example) Unicode supplies these properties in
d448 1
a448 1
The world's languages are written in many different scripts.  This sentence
d450 1
a450 1
written in Cyrillic, and Greek is written in, well, Greek; Japanese mainly in
d453 5
a457 57
The Unicode Script and Script_Extensions properties give what script a
given character is in.  Either property can be specified with the
compound form like
C<\p{Script=Hebrew}> (short: C<\p{sc=hebr}>), or
C<\p{Script_Extensions=Javanese}> (short: C<\p{scx=java}>).
In addition, Perl furnishes shortcuts for all
C<Script> property names.  You can omit everything up through the equals
(or colon), and simply write C<\p{Latin}> or C<\P{Cyrillic}>.
(This is not true for C<Script_Extensions>, which is required to be
written in the compound form.)

The difference between these two properties involves characters that are
used in multiple scripts.  For example the digits '0' through '9' are
used in many parts of the world.  These are placed in a script named
C<Common>.  Other characters are used in just a few scripts.  For
example, the "KATAKANA-HIRAGANA DOUBLE HYPHEN" is used in both Japanese
scripts, Katakana and Hiragana, but nowhere else.  The C<Script>
property places all characters that are used in multiple scripts in the
C<Common> script, while the C<Script_Extensions> property places those
that are used in only a few scripts into each of those scripts; while
still using C<Common> for those used in many scripts.  Thus both these
match:

 "0" =~ /\p{sc=Common}/     # Matches
 "0" =~ /\p{scx=Common}/    # Matches

and only the first of these match:

 "\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}" =~ /\p{sc=Common}  # Matches
 "\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}" =~ /\p{scx=Common} # No match

And only the last two of these match:

 "\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}" =~ /\p{sc=Hiragana}  # No match
 "\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}" =~ /\p{sc=Katakana}  # No match
 "\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}" =~ /\p{scx=Hiragana} # Matches
 "\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}" =~ /\p{scx=Katakana} # Matches

C<Script_Extensions> is thus an improved C<Script>, in which there are
fewer characters in the C<Common> script, and correspondingly more in
other scripts.  It is new in Unicode version 6.0, and its data are likely
to change significantly in later releases, as things get sorted out.

(Actually, besides C<Common>, the C<Inherited> script, contains
characters that are used in multiple scripts.  These are modifier
characters which modify other characters, and inherit the script value
of the controlling character.  Some of these are used in many scripts,
and so go into C<Inherited> in both C<Script> and C<Script_Extensions>.
Others are used in just a few scripts, so are in C<Inherited> in
C<Script>, but not in C<Script_Extensions>.)

It is worth stressing that there are several different sets of digits in
Unicode that are equivalent to 0-9 and are matchable by C<\d> in a
regular expression.  If they are used in a single language only, they
are in that language's C<Script> and C<Script_Extension>.  If they are
used in more than one script, they will be in C<sc=Common>, but only
if they are used in many scripts should they be in C<scx=Common>.
d475 1
a475 1
block is all characters whose ordinals are between 0 and 127, inclusive; in
d477 7
a483 5
from this as well as several other blocks, like "Latin-1 Supplement",
"Latin Extended-A", etc., but it does not contain all the characters from
those blocks. It does not, for example, contain the digits 0-9, because
those digits are shared across many scripts, and hence are in the
C<Common> script.
d488 3
a490 4
The C<Script> or C<Script_Extensions> properties are likely to be the
ones you want to use when processing
natural language; the Block property may occasionally be useful in working
with the nuts and bolts of Unicode.
d493 1
a493 1
C<\p{Blk=Hebrew}>.  Unlike most other properties, only a few block names have a
d518 4
a521 4
Some people prefer to always use C<\p{Block: foo}> and C<\p{Script: bar}>
instead of the shortcuts, whether for clarity, because they can't remember the
difference between 'In' and 'Is' anyway, or they aren't confident that those who
eventually will read their code will know that difference.
d531 2
a532 2
properties are Perl extensions.  Most of these are just synonyms for the
Unicode ones, but some are genuine extensions, including several that are in
d536 2
a537 3
This section gives some details on all extensions that aren't just
synonyms for compound-form Unicode properties
(for those properties, you'll have to refer to the
a555 5
=item B<C<\p{ASCII}>>

This matches any of the 128 characters in the US-ASCII character set,
which is a subset of Unicode.

d574 1
a574 1
I<etc.>, above, below, to one side or the other, etc.  There are many
d579 1
a579 1
character for each of the possible marks, and these can be variously combined
d582 2
a583 2
This is called an "extended grapheme cluster";  Perl furnishes the C<\X>
regular expression construct to match such sequences.
d586 1
a586 1
practices, and several pre-existing standards have single characters that
d591 2
a592 2
by Unicode to be equivalent to the sequence consisting of the character
"LATIN CAPITAL LETTER E" followed by the character "COMBINING ACUTE ACCENT".
d595 1
a595 1
its equivalence with the sequence is called canonical equivalence.  All
d597 1
a597 1
sequence), and the decomposition type is also called canonical.
d603 1
a603 1
It is somewhat like a regular digit 1, but not exactly; its decomposition
d607 2
a608 2
called "compat", which means some miscellaneous type of decomposition
that doesn't fit into the decomposition categories that Unicode has chosen.
d613 2
a614 2
For your convenience, Perl has added the C<Non_Canonical> decomposition
type to mean any of the several compatibility decompositions.
d623 1
a623 1
This is the same as C<\h> and C<\p{Blank}>:  a character that changes the
d626 1
a626 1
=item B<C<\p{In=*}>>
d642 12
a653 1
=item B<C<\p{Posix...}>>
d655 37
a691 3
There are several of these, which are equivalents using the C<\p>
notation for Posix classes and are described in
L<perlrecharclass/POSIX Character Classes>.
d720 4
a723 4
that the code point has been I<assigned>, but that the meaning of the code point
has been I<determined>.  This is because 66 code points will always be
unassigned, and so the Age for them is the Unicode version in which the decision
to make them so was made.  For example, C<U+FDD0> is to be permanently
d725 2
a726 1
so C<\p{Age=3.1}> matches this character, as also does C<\p{Present_In: 3.1}> and up.
d737 1
a737 8
which both the Posix standard and Unicode consider white space.)

=item B<C<\p{Title}>> and  B<C<\p{Titlecase}>>

Under case-sensitive matching, these both match the same code points as
C<\p{General Category=Titlecase_Letter}> (C<\p{gc=lt}>).  The difference
is that under C</i> caseless matching, these match the same as
C<\p{Cased}>, whereas C<\p{gc=lt}> matches C<\p{Cased_Letter>).
d745 1
a745 7
This is the same as C<\w>, including over 100_000 characters beyond ASCII.

=item B<C<\p{XPosix...}>>

There are several of these, which are the standard Posix classes
extended to the full Unicode range.  They are described in
L<perlrecharclass/POSIX Character Classes>.
a766 10
However, the subroutines are passed a single parameter, which is 0 if
case-sensitive matching is in effect and non-zero if caseless matching
is in effect.  The subroutine may return different values depending on
the value of the flag, and one set of values will immutably be in effect
for all case-sensitive matches, and the other set for all case-insensitive
matches.

Note that if the regular expression is tainted, then Perl will die rather
than calling the subroutine, where the name of the subroutine is
determined by the tainted data.
d785 1
a785 2
property (prefixed by "utf8::") or a fully qualified (including package
name) user-defined character property,
d792 1
a792 2
property (prefixed by "utf8::") or a fully qualified (including package
name) user-defined character property,
d799 1
a799 2
property (prefixed by "utf8::") or a fully qualified (including package
name) user-defined character property,
d806 1
a806 2
property (prefixed by "utf8::") or a fully qualified (including package
name) user-defined character property,
d816 1
a816 1
        return <<END;
d828 1
a828 1
        return <<'END';
d839 1
a839 1
        return <<'END';
d849 1
a849 1
        return <<'END';
d856 2
a857 3
This will match all non-Unicode code points, since every one of them is
not in Kana.  You can use intersection to exclude these, if desired, as
this modified example shows:
d859 1
a859 1
    sub InNotKana {
d861 25
a885 4
    !utf8::InHiragana
    -utf8::InKatakana
    +utf8::IsCn
    &utf8::Any
d889 2
a890 1
C<&utf8::Any> must be the last line in the definition.
d892 15
a906 17
Intersection is used generally for getting the common characters matched
by two (or more) classes.  It's important to remember not to use "&" for
the first set; that would be intersecting with nothing, resulting in an
empty set.

(Note that official Unicode properties differ from these in that they
automatically exclude non-Unicode code points and a warning is raised if
a match is attempted on one of those.)

=head2 User-Defined Case Mappings (for serious hackers only)

B<This feature has been removed as of Perl 5.16.>
The CPAN module L<Unicode::Casing> provides better functionality without
the drawbacks that this feature had.  If you are using a Perl earlier
than 5.16, this feature was most fully documented in the 5.14 version of
this pod:
L<http://perldoc.perl.org/5.14.0/perlunicode.html#User-Defined-Case-Mappings-%28for-serious-hackers-only%29>
d914 2
a915 2
The following list of Unicode supported features for regular expressions describes
all features currently directly supported by core Perl.  The references to "Level N"
d917 1
a917 1
"Unicode Regular Expressions", version 13, from August 2008.
d925 30
a954 35
 RL1.1   Hex Notation                     - done          [1]
 RL1.2   Properties                       - done          [2][3]
 RL1.2a  Compatibility Properties         - done          [4]
 RL1.3   Subtraction and Intersection     - MISSING       [5]
 RL1.4   Simple Word Boundaries           - done          [6]
 RL1.5   Simple Loose Matches             - done          [7]
 RL1.6   Line Boundaries                  - MISSING       [8][9]
 RL1.7   Supplementary Code Points        - done          [10]

 [1]  \x{...}
 [2]  \p{...} \P{...}
 [3]  supports not only minimal list, but all Unicode character
      properties (see Unicode Character Properties above)
 [4]  \d \D \s \S \w \W \X [:prop:] [:^prop:]
 [5]  can use regular expression look-ahead [a] or
      user-defined character properties [b] to emulate set
      operations
 [6]  \b \B
 [7]  note that Perl does Full case-folding in matching (but with
      bugs), not Simple: for example U+1F88 is equivalent to
      U+1F00 U+03B9, instead of just U+1F80.  This difference
      matters mainly for certain Greek capital letters with certain
      modifiers: the Full case-folding decomposes the letter,
      while the Simple case-folding would map it to a single
      character.
 [8]  should do ^ and $ also on U+000B (\v in C), FF (\f), CR
      (\r), CRLF (\r\n), NEL (U+0085), LS (U+2028), and PS
      (U+2029); should also affect <>, $., and script line
      numbers; should not split lines within CRLF [c] (i.e. there
      is no empty line between \r and \n)
 [9]  Linebreaking conformant with UAX#14 "Unicode Line Breaking
      Algorithm" is available through the Unicode::LineBreaking
      module.
 [10] UTF-8/UTF-EBDDIC used in Perl allows not only U+10000 to
      U+10FFFF but also beyond U+10FFFF
d972 1
a972 1
Also see the L<Unicode::Regex::Set> module; it does implement the full
d980 3
d987 16
a1002 12
 RL2.1   Canonical Equivalents           - MISSING       [10][11]
 RL2.2   Default Grapheme Clusters       - MISSING       [12]
 RL2.3   Default Word Boundaries         - MISSING       [14]
 RL2.4   Default Loose Matches           - MISSING       [15]
 RL2.5   Name Properties                 - DONE
 RL2.6   Wildcard Properties             - MISSING

 [10] see UAX#15 "Unicode Normalization Forms"
 [11] have Unicode::Normalize but not integrated to regexes
 [12] have \X but we don't have a "Grapheme Cluster Mode"
 [14] see UAX#29, Word Boundaries
 [15] This is covered in Chapter 3.13 (in Unicode 6.0)
d1008 7
a1014 7
 RL3.1   Tailored Punctuation            - MISSING
 RL3.2   Tailored Grapheme Clusters      - MISSING       [17][18]
 RL3.3   Tailored Word Boundaries        - MISSING
 RL3.4   Tailored Loose Matches          - MISSING
 RL3.5   Tailored Ranges                 - MISSING
 RL3.6   Context Matching                - MISSING       [19]
 RL3.7   Incremental Matches             - MISSING
d1016 11
a1026 12
 RL3.9   Possible Match Sets             - MISSING
 RL3.10  Folded Matching                 - MISSING       [20]
 RL3.11  Submatchers                     - MISSING

 [17] see UAX#10 "Unicode Collation Algorithms"
 [18] have Unicode::Collate but not integrated to regexes
 [19] have (?<=x) and (?=x), but look-aheads or look-behinds
      should see outside of the target substring
 [20] need insensitive matching for linguistic features other
      than case; for example, hiragana to katakana, wide and
      narrow, simplified Han to traditional Han (see UTR#30
      "Character Foldings")
d1041 4
a1044 3
UTF-8 is a variable-length (1 to 4 bytes), byte-order independent
encoding. For ASCII (and we really do mean 7-bit ASCII, not another
8-bit encoding), UTF-8 is transparent.
d1048 1
a1048 1
 Code Points            1st Byte  2nd Byte  3rd Byte 4th Byte
d1050 1
a1050 1
   U+0000..U+007F       00..7F
d1052 1
a1052 1
   U+0800..U+0FFF       E0      * A0..BF    80..BF
d1055 1
a1055 1
   U+D800..U+DFFF       +++++ utf16 surrogates, not legal utf8 +++++
d1057 3
a1059 3
  U+10000..U+3FFFF      F0      * 90..BF    80..BF    80..BF
  U+40000..U+FFFFF      F1..F3    80..BF    80..BF    80..BF
 U+100000..U+10FFFF     F4        80..8F    80..BF    80..BF
d1061 1
a1061 1
Note the gaps marked by "*" before several of the byte entries above.  These are
d1069 1
a1069 1
                Code Points  1st Byte  2nd Byte  3rd Byte  4th Byte
d1071 4
a1074 4
                   0aaaaaaa  0aaaaaaa
           00000bbbbbaaaaaa  110bbbbb  10aaaaaa
           ccccbbbbbbaaaaaa  1110cccc  10bbbbbb  10aaaaaa
 00000dddccccccbbbbbbaaaaaa  11110ddd  10cccccc  10bbbbbb  10aaaaaa
a1079 10
The original UTF-8 specification allowed up to 6 bytes, to allow
encoding of numbers up to 0x7FFF_FFFF.  Perl continues to allow those,
and has extended that up to 13 bytes to encode code points up to what
can fit in a 64-bit word.  However, Perl will warn if you output any of
these as being non-portable; and under strict UTF-8 input protocols,
they are forbidden.

The Unicode non-character code points are also disallowed in UTF-8 in
"open interchange".  See L</Non-character code points>.

d1093 2
a1094 4
Like UTF-8, UTF-16 is a variable-width encoding, but where
UTF-8 uses 8-bit code units, UTF-16 uses 16-bit code units.
All code points occupy either 2 or 4 bytes in UTF-16: code points
C<U+0000..U+FFFF> are stored in a single 16-bit unit, and code
d1104 2
a1105 2
    $hi = ($uni - 0x10000) / 0x400 + 0xD800;
    $lo = ($uni - 0x10000) % 0x400 + 0xDC00;
d1109 5
a1113 1
    $uni = 0x10000 + ($hi - 0xD800) * 0x400 + ($lo - 0xDC00);
d1133 1
a1133 1
C<U+FFFE> is not supposed to be in input streams, so the
d1136 3
a1138 14
format".

Surrogates have no meaning in Unicode outside their use in pairs to
represent other code points.  However, Perl allows them to be
represented individually internally, for example by saying
C<chr(0xD801)>, so that all code points, not just those valid for open
interchange, are
representable.  Unicode does define semantics for them, such as their
General Category is "Cs".  But because their use is somewhat dangerous,
Perl will warn (using the warning category "surrogate", which is a
sub-category of "utf8") if an attempt is made
to do things like take the lower case of one, or match
case-insensitively, or to output them.  (But don't try this on Perls
before 5.14.)
d1146 2
a1147 2
needed.  UTF-32 is a fixed-width encoding.  The BOM signatures are
C<0x00 0x00 0xFE 0xFF> for BE and C<0xFF 0xFE 0x00 0x00> for LE.
d1153 1
a1153 1
Legacy, fixed-width encodings defined by the ISO 10646 standard.  UCS-2 is a 16-bit
d1156 1
a1156 2
functionally identical to UTF-32 (the difference being that
UCS-4 forbids neither surrogates nor code points larger than 0x10_FFFF).
a1166 30
=head2 Non-character code points

66 code points are set aside in Unicode as "non-character code points".
These all have the Unassigned (Cn) General Category, and they never will
be assigned.  These are never supposed to be in legal Unicode input
streams, so that code can use them as sentinels that can be mixed in
with character data, and they always will be distinguishable from that data.
To keep them out of Perl input streams, strict UTF-8 should be
specified, such as by using the layer C<:encoding('UTF-8')>.  The
non-character code points are the 32 between U+FDD0 and U+FDEF, and the
34 code points U+FFFE, U+FFFF, U+1FFFE, U+1FFFF, ... U+10FFFE, U+10FFFF.
Some people are under the mistaken impression that these are "illegal",
but that is not true.  An application or cooperating set of applications
can legally use them at will internally; but these code points are
"illegal for open interchange".  Therefore, Perl will not accept these
from input streams unless lax rules are being used, and will warn
(using the warning category "nonchar", which is a sub-category of "utf8") if
an attempt is made to output them.

=head2 Beyond Unicode code points

The maximum Unicode code point is U+10FFFF.  But Perl accepts code
points up to the maximum permissible unsigned number available on the
platform.  However, Perl will not accept these from input streams unless
lax rules are being used, and will warn (using the warning category
"non_unicode", which is a sub-category of "utf8") if an attempt is made to
operate on or output them.  For example, C<uc(0x11_0000)> will generate
this warning, returning the input parameter as its result, as the upper
case of every non-Unicode code point is the code point itself.

d1178 1
a1178 1
Unfortunately, the original specification of UTF-8 leaves some room for
d1186 1
a1186 1
surrogates, which are not Unicode code points valid for interchange.
d1190 17
a1206 6
Regular expression pattern matching may surprise you if you're not
accustomed to Unicode.  Starting in Perl 5.14, several pattern
modifiers are available to control this, called the character set
modifiers.  Details are given in L<perlre/Character set modifiers>.

=back
d1215 4
a1218 2
regular expressions might start behaving differently (unless the C</a>
modifier is in effect).  Review your code.  Use warnings and the C<strict> pragma.
d1233 19
a1251 1
See L<perllocale/Unicode and UTF-8>
d1256 3
a1258 3
and a few other "entry points" like the @@ARGV array (which can sometimes be
interpreted as UTF-8), there are still many places where Unicode
(in some encoding or another) could be given as arguments or received as
d1264 1
a1264 1
and results, or UTF-8 strings if the (problematic) C<encoding> pragma has been used.
d1266 2
a1267 2
One reason that Perl does not attempt to resolve the role of Unicode in
these situations is that the answers are highly dependent on the operating
d1269 3
a1271 3
in Unicode and in exactly what kind of encoding, is not exactly a
portable concept.  Similarly for C<qx> and C<system>: how well will the
"command-line interface" (and which of them?) handle Unicode?
d1304 2
a1305 3
The term, "Unicode bug" has been applied to an inconsistency
on ASCII platforms with the
Unicode code points in the Latin-1 Supplement block, that
d1308 1
a1308 3
byte semantics versus character semantics, unless
C<use feature 'unicode_strings'> is specified, directly or indirectly.
(It is indirectly specified by a C<use v5.12> or higher.)
d1310 1
a1310 2
In character semantics these upper-Latin1 characters are interpreted as
Unicode code points, which means
d1313 2
a1314 3
In byte semantics (without C<unicode_strings>), they are considered to
be unassigned characters, meaning that the only semantics they have is
their ordinal numbers, and that they are
d1316 3
a1318 7
for example, but all match C<\W>.

Perl 5.12.0 added C<unicode_strings> to force character semantics on
these code points in some circumstances, which fixed portions of the
bug; Perl 5.14.0 fixed almost all of it; and Perl 5.16.0 fixed the
remainder (so far as we know, anyway).  The lesson here is to enable
C<unicode_strings> to avoid the headaches described below.
d1320 1
a1320 1
The old, problematic behavior affects these areas:
d1327 2
a1328 5
and C<lcfirst()>, or C<\L>, C<\U>, C<\u> and C<\l> in double-quotish
contexts, such as regular expression substitutions.
Under C<unicode_strings> starting in Perl 5.12.0, character semantics are
generally used.  See L<perlfunc/lc> for details on how this works
in combination with various other pragmas.
d1332 1
a1332 5
Using caseless (C</i>) regular expression matching.
Starting in Perl 5.14.0, regular expressions compiled within
the scope of C<unicode_strings> use character semantics
even when executed or compiled into larger
regular expressions outside the scope.
d1336 1
a1336 7
Matching any of several properties in regular expressions, namely C<\b>,
C<\B>, C<\s>, C<\S>, C<\w>, C<\W>, and all the Posix character classes
I<except> C<[[:ascii:]]>.
Starting in Perl 5.14.0, regular expressions compiled within
the scope of C<unicode_strings> use character semantics
even when executed or compiled into larger
regular expressions outside the scope.
d1340 3
a1342 5
In C<quotemeta> or its inline equivalent C<\Q>, no code points above 127
are quoted in UTF-8 encoded strings, but in byte encoded strings, code
points between 128-255 are always quoted.
Starting in Perl 5.16.0, consistent quoting rules are used within the
scope of C<unicode_strings>, as described in L<perlfunc/quotemeta>.
a1351 1
     no feature 'unicode_strings';
d1370 14
a1383 4
For Perls earlier than those described above, or when a string is passed
to a function outside the subpragma's scope, a workaround is to always
call C<utf8::upgrade($string)>,
or to use the standard module L<Encode>.   Also, a scalar that has any characters
d1385 1
a1385 1
C<\N{...}> notations, will automatically have character semantics.
d1432 1
a1432 2
C<utf8_to_uvchr_buf(buf, bufend, lenp)> reads UTF-8 encoded bytes from a
buffer and
d1456 2
a1457 2
C<is_utf8_string(buf, len)> returns true if C<len> bytes of the buffer
are valid UTF-8.
d1461 2
a1462 3
C<is_utf8_char(s)> returns true if the pointer points to a valid UTF-8
character.  However, this function should not be used because of
security concerns.  Instead, use C<is_utf8_string()>.
d1498 1
a1498 1
C<foldEQ_utf8(s1, pe1, l1, u1, s2, pe2, l2, u2)> can be used to
d1500 1
a1500 2
comparisons you can just use C<memEQ()> and C<memNE()> as usual, except
if one string is in utf8 and the other isn't.
d1512 1
a1512 1
Download the files in the desired version of Unicode from the Unicode web
d1514 10
a1523 3
F<lib/unicore> in the Perl source tree.  Follow the instructions in
F<README.perl> in that directory to change some of their names, and then build
perl (see L<INSTALL>).
d1529 6
a1534 1
See L<perllocale/Unicode and UTF-8>
d1540 8
d1552 1
a1552 1
extension doesn't recognize that flag, it's likely that the extension
d1576 3
a1578 4
        my($what) = shift;
        return unless defined $what;
        Encode::decode_utf8(Foo::Bar::escape_html(
                                         Encode::encode_utf8($what)));
d1582 1
a1582 1
and retrieves them, you will be able to use the otherwise
d1625 1
a1625 1
like C<\d> (then again, there are hundreds of Unicode characters matching C<Nd>
d1630 1
a1630 1
There are several known problems with Perl on EBCDIC platforms.  If you
d1650 1
a1650 1
=over 3
d1709 1
a1709 2
    # $what is one of fetchrow_{array,hashref}
    my($self, $sth, $what) = @@_;
d1724 1
a1724 3
            defined
            && /[^\000-\177]/
            && Encode::_utf8_on($_) for $ret->{$k};
@


1.1.1.12
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d31 2
a32 4
This pragma doesn't affect I/O.  Nor does it change the internal
representation of strings, only their interpretation.  There are still
several places where Unicode isn't fully supported, such as in
filenames.
d75 2
a76 1
Perl uses logically-wide characters to represent strings internally.
d100 7
a106 2
Unicode semantics for those greater than 255.  That means that non-ASCII
characters are undefined except for their
d723 1
a723 2
This is the same as C<\s>, restricted to ASCII, namely C<S<[ \f\n\r\t]>>
and starting in Perl v5.18, experimentally, a vertical tab.
d810 1
a810 3
whose names begin with "In" or "Is".  (The experimental feature
L<perlre/(?[ ])> provides an alternative which allows more complex
definitions.)  The subroutines can be defined in any
d981 1
a981 1
 RL1.3   Subtraction and Intersection     - experimental  [5]
d987 26
a1012 15
=over 4

=item [1]

\x{...}

=item [2]

\p{...} \P{...}

=item [3]

supports not only minimal list, but all Unicode character properties (see Unicode Character Properties above)

=item [4]
d1014 1
a1014 13
\d \D \s \S \w \W \X [:prop:] [:^prop:]

=item [5]

The experimental feature in v5.18 "(?[...])" accomplishes this.  See
L<perlre/(?[ ])>.  If you don't want to use an experimental feature,
you can use one of the following:

=over 4

=item * Regular expression look-ahead

You can mimic class subtraction using lookahead.
d1017 1
a1017 1
    [{Block=Greek}-[{UNASSIGNED}]]
d1021 2
a1022 2
    (?!\p{Unassigned})\p{Block=Greek}
    (?=\p{Assigned})\p{Block=Greek}
d1026 1
a1026 1
    \p{Greek}
d1030 2
a1031 4
=item * CPAN module L<Unicode::Regex::Set>

It does implement the full UTS#18 grouping, intersection, union, and
removal (subtraction) syntax.
d1033 2
a1034 1
=item * L</"User-Defined Character Properties">
d1036 1
a1036 30
'+' for union, '-' for removal (set-difference), '&' for intersection

=back

=item [6]

\b \B

=item [7]

Note that Perl does Full case-folding in matching (but with bugs), not Simple: for example U+1F88 is equivalent to U+1F00 U+03B9, instead of just U+1F80.  This difference matters mainly for certain Greek capital letters with certain modifiers: the Full case-folding decomposes the letter, while the Simple case-folding would map it to a single character.

=item [8]

Should do ^ and $ also on U+000B (\v in C), FF (\f), CR (\r), CRLF
(\r\n), NEL (U+0085), LS (U+2028), and PS (U+2029); should also affect
<>, $., and script line numbers; should not split lines within CRLF
(i.e. there is no empty line between \r and \n).  For CRLF, try the
C<:crlf> layer (see L<PerlIO>).

=item [9]

Linebreaking conformant with UAX#14 "Unicode Line Breaking Algorithm" is available through the Unicode::LineBreaking module.

=item [10]

UTF-8/UTF-EBDDIC used in Perl allows not only U+10000 to
U+10FFFF but also beyond U+10FFFF

=back
d1333 1
a1333 1
currently (as of v5.16.0) simply assumes byte strings both as arguments
d1547 3
a1549 2
C<is_utf8_char_buf(buf, buf_end)> returns true if the pointer points to
a valid UTF-8 character.
d1725 1
a1725 1
  if ($] > 5.008) {
d1736 1
a1736 1
(January 2012) the mentioned modules are not UTF-8-aware. Please
d1739 1
a1739 1
  if ($] > 5.008) {
d1751 1
a1751 1
  if ($] > 5.008) {
d1760 1
a1760 1
  if ($] > 5.008) {
d1773 1
a1773 1
time of this writing (January 2012), the DBI has no standardized way
d1780 1
a1780 1
    if ($] < 5.008) {
d1816 1
a1816 1
  utf8::downgrade($val) if $] > 5.008;
@


1.1.1.13
log
@Import perl-5.20.1
@
text
@d23 1
a23 1
=item Safest if you C<use feature 'unicode_strings'>
d40 1
a40 1
the C<:encoding(utf8)> layer.  Other encodings can be converted to Perl's
d42 1
a42 1
C<:encoding(...)>  layer.  See L<open>.
d55 1
a55 1
=item C<BOM>-marked scripts and UTF-16 scripts autodetected
d57 2
a58 2
If a Perl script begins marked with the Unicode C<BOM> (UTF-16LE, UTF16-BE,
or UTF-8), or if the script looks like non-C<BOM>-marked UTF-16 of either
d60 1
a60 1
(C<BOM>less UTF-8 cannot be effectively recognized or differentiated from
d95 1
a95 1
effect, Perl uses the rules associated with the current locale.
d101 1
a101 1
Unicode rules for those greater than 255.  That means that non-ASCII
d111 1
a111 1
external programs, from information provided by the system (such as C<%ENV>),
d123 1
a123 1
You can choose to be warned when this happens.  See C<L<encoding::warnings>>.
d145 1
a145 1
(The former requires a C<BOM> or C<use utf8>, the latter requires a C<BOM>.)
d152 2
a153 2
Alternatively, you can use the C<\x{...}> notation for characters C<0x100> and
above.  For characters below C<0x100> you may get byte semantics instead of
d177 1
a177 1
Regular expressions match characters instead of bytes.  C<"."> matches
d263 1
a263 1
There is a CPAN module, C<L<Unicode::Casing>>, which allows you to define
d293 2
a294 3
C<"Uppercase"> property, while C<\p{L}> matches any character with a
C<General_Category> of C<"L"> (letter) property (see
L</General_Category> below).  Brackets are not
d298 2
a299 2
C<Uppercase> property value is C<True>, and C<\P{Uppercase}> matches any character
whose C<Uppercase> property value is C<False>, and they could have been written as
d303 4
a306 5
take on more values than just C<True> and C<False>.  For example, the
C<Bidi_Class> property (see L</"Bidirectional Character Types"> below),
can take on several different
values, such as C<Left>, C<Right>, C<Whitespace>, and others.  To match these, one needs
to specify both the property name (C<Bidi_Class>), AND the value being
d308 1
a308 1
(C<Left>, C<Right>, etc.).  This is done, as in the examples above, by having the
d313 1
a313 1
of C<\p{I<property>=I<value>}> or C<\p{I<property>:I<value>}>, but Perl provides some
d321 11
a331 13
descriptive and hence easier to understand.  Thus the C<"L"> and
C<"Letter"> properties above are equivalent and can be used
interchangeably.  Likewise, C<"Upper"> is a synonym for C<"Uppercase">,
and we could have written C<\p{Uppercase}> equivalently as C<\p{Upper}>.
Also, there are typically various synonyms for the values the property
can be.   For binary properties, C<"True"> has 3 synonyms: C<"T">,
C<"Yes">, and C<"Y">; and C<"False"> has correspondingly C<"F">,
C<"No">, and C<"N">.  But be careful.  A short form of a value for one
property may not mean the same thing as the same short form for another.
Thus, for the C<L</General_Category>> property, C<"L"> means
C<"Letter">, but for the L<C<Bidi_Class>|/Bidirectional Character Types>
property, C<"L"> means C<"Left">.  A complete list of properties and
synonyms is in L<perluniprops>.
d348 1
a348 1
(C<^>) between the first brace and the property name: C<\p{^Tamil}> is
d365 1
a365 1
of which under C</i> match C<PosixAlpha>.
d370 7
a376 2
See L</Beyond Unicode code points> for special considerations when
matching Unicode properties against non-Unicode code points.
d389 1
a389 2
Here are the short and long forms of the values the C<General Category> property
can have:
d447 2
a448 2
written right to left, for example) Unicode supplies a C<Bidi_Class> property.
Some of the values this property can have are:
d450 1
a450 1
    Value       Meaning
d474 1
a474 7
written right to left.  Unlike the
C<L</General_Category>> property, this
property can have more values added in a future Unicode release.  Those
listed above comprised the complete set for many Unicode releases, but
others were added in Unicode 6.3; you can always find what the
current ones are in in L<perluniprops>.  And
L<http://www.unicode.org/reports/tr9/> describes how to use them.
d498 1
a498 1
example, the C<"KATAKANA-HIRAGANA DOUBLE HYPHEN"> is used in both Japanese
d543 1
a543 1
=head3 B<Use of the C<"Is"> Prefix>
d556 1
a556 1
characters with consecutive ordinal values. For example, the C<"Basic Latin">
d558 3
a560 3
other words, the ASCII characters.  The C<"Latin"> script contains some letters
from this as well as several other blocks, like C<"Latin-1 Supplement">,
C<"Latin Extended-A">, etc., but it does not contain all the characters from
d570 1
a570 1
natural language; the C<Block> property may occasionally be useful in working
d592 1
a592 1
It is unstable.  A new version of Unicode may preempt the current meaning by
d626 2
a627 4
This matches every possible code point.  It is equivalent to C<qr/./s>.
Unlike all the other non-user-defined C<\p{}> property matches, no
warning is ever generated if this is property is matched against a
non-Unicode code point (see L</Beyond Unicode code points> below).
d635 2
a636 2
This matches any of the 1_114_112 Unicode code points.  It is a synonym
for C<\p{Unicode}>.
d645 2
a646 2
This matches any assigned code point; that is, any code point whose L<general
category|/General_Category> is not C<Unassigned> (or equivalently, not C<Cn>).
d657 1
a657 1
To understand the use of this rarely used I<property=value> combination, it is
d675 2
a676 2
which has quite a few of these in the Latin-1 range, an example being C<"LATIN
CAPITAL LETTER E WITH ACUTE">.  Because this character was in this pre-existing
d679 1
a679 1
C<"LATIN CAPITAL LETTER E"> followed by the character C<"COMBINING ACUTE ACCENT">.
d681 1
a681 1
C<"LATIN CAPITAL LETTER E WITH ACUTE"> is called a "pre-composed" character, and
d689 1
a689 1
character.  An example, again in the Latin-1 range, is the C<"SUPERSCRIPT ONE">.
d698 1
a698 1
decomposition type is C<"None">.
d732 1
a732 1
There are several of these, which are equivalents using the C<\p{}>
d747 1
a747 1
For example, C<U+0041> C<"LATIN CAPITAL LETTER A"> was present in the very first
d750 1
a750 1
5.1 when it became C<"LATIN SMALL LETTER Y WITH LOOP">, so the only "*" that
d760 1
a760 1
the same as the Perl C<Present_In> property; just be aware of that.
d765 1
a765 1
unassigned, and so the C<Age> for them is the Unicode version in which the decision
a787 5
=item B<C<\p{Unicode}>>

This matches any of the 1_114_112 Unicode code points.
C<\p{Any}>.

a803 1

d807 1
a807 1
whose names begin with C<"In"> or C<"Is">.  (The experimental feature
d811 1
a811 1
C<\p{}> and C<\P{}> constructs; if you are using a user-defined property from a
d813 1
a813 1
C<\p{}> or C<\P{}> construct.
d832 1
a832 1
than calling the subroutine when the name of the subroutine is
d842 1
a842 1
A single hexadecimal number denoting a code point to include.
d847 1
a847 1
tabular characters) denoting a range of code points to include.
d851 2
a852 2
Something to include, prefixed by C<"+">: a built-in character
property (prefixed by C<"utf8::">) or a fully qualified (including package
d859 2
a860 2
Something to exclude, prefixed by C<"-">: an existing character
property (prefixed by C<"utf8::">) or a fully qualified (including package
d867 2
a868 2
Something to negate, prefixed C<"!">: an existing character
property (prefixed by C<"utf8::">) or a fully qualified (including package
d875 2
a876 2
Something to intersect with, prefixed by C<"&">: an existing character
property (prefixed by C<"utf8::">) or a fully qualified (including package
d943 1
a943 1
by two (or more) classes.  It's important to remember not to use C<"&"> for
d947 3
a949 3
Unlike non-user-defined C<\p{}> property matches, no warning is ever
generated if these properties are matched against a non-Unicode code
point (see L</Beyond Unicode code points> below).
d954 1
a954 1
The CPAN module C<L<Unicode::Casing>> provides better functionality without
d990 1
a990 1
C<\x{...}>
d994 1
a994 1
C<\p{...}> C<\P{...}>
d1002 1
a1002 1
C<\d> C<\D> C<\s> C<\S> C<\w> C<\W> C<\X> C<[:I<prop>:]> C<[:^I<prop>:]>
d1006 1
a1006 1
The experimental feature in v5.18 C<"(?[...])"> accomplishes this.  See
d1030 1
a1030 1
=item * CPAN module C<L<Unicode::Regex::Set>>
d1037 1
a1037 1
C<"+"> for union, C<"-"> for removal (set-difference), C<"&"> for intersection
d1043 1
a1043 1
C<\b> C<\B>
d1047 1
a1047 6
Note that Perl does Full case-folding in matching (but with bugs), not
Simple: for example C<U+1F88> is equivalent to C<U+1F00 U+03B9>, instead of
just C<U+1F80>.  This difference matters mainly for certain Greek capital
letters with certain modifiers: the Full case-folding decomposes the
letter, while the Simple case-folding would map it to a single
character.
d1051 4
a1054 5
Should do C<^> and C<$> also on C<U+000B> (C<\v> in C), C<FF> (C<\f>),
C<CR> (C<\r>), C<CRLF> (C<\r\n>), C<NEL> (C<U+0085>), C<LS> (C<U+2028>),
and C<PS> (C<U+2029>); should also affect C<E<lt>E<gt>>, C<$.>, and
script line numbers; should not split lines within C<CRLF> (i.e. there
is no empty line between C<\r> and C<\n>).  For C<CRLF>, try the
d1059 1
a1059 3
Linebreaking conformant with L<UAX#14 "Unicode Line Breaking
Algorithm"|http://www.unicode.org/reports/tr14>
is available through the C<L<Unicode::LineBreak>> module.
d1063 2
a1064 2
UTF-8/UTF-EBDDIC used in Perl allows not only C<U+10000> to
C<U+10FFFF> but also beyond C<U+10FFFF>
d1157 1
a1157 1
As you can see, the continuation bytes all begin with C<"10">, and the
d1162 1
a1162 1
encoding of numbers up to C<0x7FFF_FFFF>.  Perl continues to allow those,
d1179 1
a1179 1
UTF-16, UTF-16BE, UTF-16LE, Surrogates, and C<BOM>s (Byte Order Marks)
d1211 1
a1211 1
C<BOM>s, are a solution to this.  A special character has been reserved
d1213 1
a1213 1
code point C<U+FEFF> is the C<BOM>.
d1215 1
a1215 1
The trick is that if you read a C<BOM>, you will know the byte order,
d1223 1
a1223 1
sequence of bytes C<0xFF 0xFE> is unambiguously "C<BOM>, represented in
d1233 3
a1235 3
C<L</General_Category>> is C<"Cs">.  But because their use is somewhat dangerous,
Perl will warn (using the warning category C<"surrogate">, which is a
sub-category of C<"utf8">) if an attempt is made
d1246 1
a1246 1
needed.  UTF-32 is a fixed-width encoding.  The C<BOM> signatures are
d1257 1
a1257 1
UCS-4 forbids neither surrogates nor code points larger than C<0x10_FFFF>).
d1271 1
a1271 2
These all have the C<Unassigned> (C<Cn>) C<L</General_Category>>, and
they never will
d1277 2
a1278 2
non-character code points are the 32 between C<U+FDD0> and C<U+FDEF>, and the
34 code points C<U+FFFE>, C<U+FFFF>, C<U+1FFFE>, C<U+1FFFF>, ... C<U+10FFFE>, C<U+10FFFF>.
d1284 1
a1284 1
(using the warning category C<"nonchar">, which is a sub-category of C<"utf8">) if
d1289 1
a1289 2
The maximum Unicode code point is C<U+10FFFF>, and Unicode only defines
operations on code points up through that.  But Perl works on code
d1293 4
a1296 106
C<"non_unicode">, which is a sub-category of C<"utf8">) if any are output.

Since Unicode rules are not defined on these code points, if a
Unicode-defined operation is done on them, Perl uses what we believe are
sensible rules, while generally warning, using the C<"non_unicode">
category.  For example, C<uc("\x{11_0000}")> will generate such a
warning, returning the input parameter as its result, since Perl defines
the uppercase of every non-Unicode code point to be the code point
itself.  In fact, all the case changing operations, not just
uppercasing, work this way.

The situation with matching Unicode properties in regular expressions,
the C<\p{}> and C<\P{}> constructs, against these code points is not as
clear cut, and how these are handled has changed as we've gained
experience.

One possibility is to treat any match against these code points as
undefined.  But since Perl doesn't have the concept of a match being
undefined, it converts this to failing or C<FALSE>.  This is almost, but
not quite, what Perl did from v5.14 (when use of these code points
became generally reliable) through v5.18.  The difference is that Perl
treated all C<\p{}> matches as failing, but all C<\P{}> matches as
succeeding.

One problem with this is that it leads to unexpected, and confusting
results in some cases:

 chr(0x110000) =~ \p{ASCII_Hex_Digit=True}      # Failed on <= v5.18
 chr(0x110000) =~ \p{ASCII_Hex_Digit=False}     # Failed! on <= v5.18

That is, it treated both matches as undefined, and converted that to
false (raising a warning on each).  The first case is the expected
result, but the second is likely counterintuitive: "How could both be
false when they are complements?"  Another problem was that the
implementation optimized many Unicode property matches down to already
existing simpler, faster operations, which don't raise the warning.  We
chose to not forgo those optimizations, which help the vast majority of
matches, just to generate a warning for the unlikely event that an
above-Unicode code point is being matched against.

As a result of these problems, starting in v5.20, what Perl does is
to treat non-Unicode code points as just typical unassigned Unicode
characters, and matches accordingly.  (Note: Unicode has atypical
unassigned code points.  For example, it has non-character code points,
and ones that, when they do get assigned, are destined to be written
Right-to-left, as Arabic and Hebrew are.  Perl assumes that no
non-Unicode code point has any atypical properties.)

Perl, in most cases, will raise a warning when matching an above-Unicode
code point against a Unicode property when the result is C<TRUE> for
C<\p{}>, and C<FALSE> for C<\P{}>.  For example:

 chr(0x110000) =~ \p{ASCII_Hex_Digit=True}      # Fails, no warning
 chr(0x110000) =~ \p{ASCII_Hex_Digit=False}     # Succeeds, with warning

In both these examples, the character being matched is non-Unicode, so
Unicode doesn't define how it should match.  It clearly isn't an ASCII
hex digit, so the first example clearly should fail, and so it does,
with no warning.  But it is arguable that the second example should have
an undefined, hence C<FALSE>, result.  So a warning is raised for it.

Thus the warning is raised for many fewer cases than in earlier Perls,
and only when what the result is could be arguable.  It turns out that
none of the optimizations made by Perl (or are ever likely to be made)
cause the warning to be skipped, so it solves both problems of Perl's
earlier approach.  The most commonly used property that is affected by
this change is C<\p{Unassigned}> which is a short form for
C<\p{General_Category=Unassigned}>.  Starting in v5.20, all non-Unicode
code points are considered C<Unassigned>.  In earlier releases the
matches failed because the result was considered undefined.

The only place where the warning is not raised when it might ought to
have been is if optimizations cause the whole pattern match to not even
be attempted.  For example, Perl may figure out that for a string to
match a certain regular expression pattern, the string has to contain
the substring C<"foobar">.  Before attempting the match, Perl may look
for that substring, and if not found, immediately fail the match without
actually trying it; so no warning gets generated even if the string
contains an above-Unicode code point.

This behavior is more "Do what I mean" than in earlier Perls for most
applications.  But it catches fewer issues for code that needs to be
strictly Unicode compliant.  Therefore there is an additional mode of
operation available to accommodate such code.  This mode is enabled if a
regular expression pattern is compiled within the lexical scope where
the C<"non_unicode"> warning class has been made fatal, say by:

 use warnings FATAL => "non_unicode"

(see L<warnings>).  In this mode of operation, Perl will raise the
warning for all matches against a non-Unicode code point (not just the
arguable ones), and it skips the optimizations that might cause the
warning to not be output.  (It currently still won't warn if the match
isn't even attempted, like in the C<"foobar"> example above.)

In summary, Perl now normally treats non-Unicode code points as typical
Unicode unassigned code points for regular expression matches, raising a
warning only when it is arguable what the result should be.  However, if
this warning has been made fatal, it isn't skipped.

There is one exception to all this.  C<\p{All}> looks like a Unicode
property, but it is a Perl extension that is defined to be true for all
possible code points, Unicode or not, so no warning is ever generated
when matching this against a non-Unicode code point.  (Prior to v5.20,
it was an exact synonym for C<\p{Any}>, matching code points C<0>
through C<0x10FFFF>.)
d1345 1
a1345 1
C<":utfebcdic"> layer; rather, C<"utf8"> and C<":utf8"> are reused to mean
d1356 1
a1356 1
and a few other "entry points" like the C<@@ARGV> array (which can sometimes be
d1377 2
a1378 2
C<chdir>, C<chmod>, C<chown>, C<chroot>, C<exec>, C<link>, C<lstat>, C<mkdir>,
C<rename>, C<rmdir>, C<stat>, C<symlink>, C<truncate>, C<unlink>, C<utime>, C<-X>
d1382 1
a1382 1
C<%ENV>
d1386 1
a1386 1
C<glob> (aka the C<E<lt>*E<gt>>)
d1390 1
a1390 1
C<open>, C<opendir>, C<sysopen>
d1394 1
a1394 1
C<qx> (aka the backtick operator), C<system>
d1398 1
a1398 1
C<readdir>, C<readlink>
d1406 1
a1406 1
Unicode code points in the C<Latin-1 Supplement> block, that
d1497 1
a1497 1
call L<C<utf8::upgrade($string)>|utf8/Utility functions>,
d1499 1
a1499 1
whose ordinal is C<0x100> or above, or which were specified using either of the
d1507 1
a1507 2
L<C<utf8::upgrade($bytestring)>|utf8/Utility functions> and
L<C<utf8::downgrade($utf8string[, FAIL_OK])>|utf8/Utility functions> are
d1510 1
a1510 1
Note that C<utf8::downgrade()> can fail if the string contains characters
d1529 1
a1529 1
flag is on; the C<bytes> pragma is ignored.  The C<UTF8> flag being on
d1667 1
a1667 1
To provide an example, let's say the popular C<Foo::Bar::escape_html>
d1681 3
a1683 3
dangerous L<C<Encode::_utf8_on()>|Encode/_utf8_on> function. Let's say
the popular C<Foo::Bar> extension, written in C, provides a C<param>
method that lets you store and retrieve data according to these prototypes:
d1705 1
a1705 1
C<DB_File::filter_store_key> and family. Look out for such filters in
d1713 2
a1714 2
characters such as C<length()>, C<substr()> or C<index()>, or matching
regular expressions can work B<much> faster when the underlying data are
d1762 1
a1762 1
Be it C<Compress::Zlib>, C<Apache::Request> or any extension that has no
d1796 1
a1796 1
A wrapper for L<DBI> C<fetchrow_array> and C<fetchrow_hashref>
d1799 2
a1800 2
a convenient way to replace all your C<fetchrow_array> and
C<fetchrow_hashref> calls. A wrapper function will also make it easier to
d1803 1
a1803 1
to deal with UTF-8 data. Please check the L<DBI documentation|DBI> to verify if
@


