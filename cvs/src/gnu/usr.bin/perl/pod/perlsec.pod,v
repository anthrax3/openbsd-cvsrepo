head	1.18;
access;
symbols
	OPENBSD_6_2_BASE:1.18
	PERL_5_24_2:1.1.1.17
	OPENBSD_6_1:1.18.0.4
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.17.0.8
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.17.0.4
	OPENBSD_5_8_BASE:1.17
	PERL_5_20_2:1.1.1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	PERL_5_20_1:1.1.1.15
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	PERL_5_18_2:1.1.1.14
	PERL:1.1.1
	OPENBSD_5_5:1.14.0.6
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	PERL_5_16_3:1.1.1.13
	OPENBSD_5_3:1.13.0.10
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.8
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.6
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	PERL_5_12_2:1.1.1.12
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	PERL_5_10_1:1.1.1.11
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	PERL_5_10_0:1.1.1.10
	OPENBSD_4_4:1.10.0.10
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.8
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	PERL_5_8_8:1.1.1.9
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	PERL_5_8_6:1.1.1.8
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.18
date	2017.02.05.00.32.19;	author afresh1;	state Exp;
branches;
next	1.17;
commitid	cxJ08BvJA9Pt2PTM;

1.17
date	2015.04.25.19.14.48;	author afresh1;	state Exp;
branches;
next	1.16;
commitid	XRK22kO4se3v2i2I;

1.16
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.15;
commitid	QP75iYx42Uo7mMxO;

1.15
date	2014.03.24.15.05.33;	author afresh1;	state Exp;
branches;
next	1.14;

1.14
date	2013.03.25.20.40.59;	author sthen;	state Exp;
branches;
next	1.13;

1.13
date	2010.09.24.15.07.04;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.12.18.24.47;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.29.17.36.17;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.28.19.23.11;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2005.01.15.21.30.37;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.07.21.33.09;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.46;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.34;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.35.58;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.07.38;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.19;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.59.27;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.04;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.04;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.40.59;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.30;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.24.47;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.06;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.24;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.04.07.21.13.35;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2005.01.15.21.18.01;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2006.03.28.18.49.24;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2008.09.29.17.18.53;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2009.10.12.18.10.40;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2010.09.24.14.49.07;	author millert;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2013.03.25.20.09.25;	author sthen;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.03.24.14.59.08;	author afresh1;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2014.11.17.20.53.15;	author afresh1;	state Exp;
branches;
next	1.1.1.16;
commitid	B31cAbBIXiCqnL97;

1.1.1.16
date	2015.04.25.19.10.44;	author afresh1;	state Exp;
branches;
next	1.1.1.17;
commitid	Wpcs5S8qILgEZC7F;

1.1.1.17
date	2017.08.14.13.46.21;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.18
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@=head1 NAME

perlsec - Perl security

=head1 DESCRIPTION

Perl is designed to make it easy to program securely even when running
with extra privileges, like setuid or setgid programs.  Unlike most
command line shells, which are based on multiple substitution passes on
each line of the script, Perl uses a more conventional evaluation scheme
with fewer hidden snags.  Additionally, because the language has more
builtin functionality, it can rely less upon external (and possibly
untrustworthy) programs to accomplish its purposes.

=head1 SECURITY VULNERABILITY CONTACT INFORMATION

If you believe you have found a security vulnerability in Perl, please
email the details to perl5-security-report@@perl.org. This creates a new
Request Tracker ticket in a special queue which isn't initially publicly
accessible. The email will also be copied to a closed subscription
unarchived mailing list which includes all the core committers, who will
be able to help assess the impact of issues, figure out a resolution, and
help co-ordinate the release of patches to mitigate or fix the problem
across all platforms on which Perl is supported. Please only use this
address for security issues in the Perl core, not for modules
independently distributed on CPAN.

When sending an initial request to the security email address, please
don't Cc any other parties, because if they reply to all, the reply will
generate yet another new ticket. Once you have received an initial reply
with a C<[perl #NNNNNN]> ticket number in  the headline, it's okay to Cc
subsequent replies to third parties: all emails to the
perl5-security-report address with the ticket number in the subject line
will be added to the ticket; without it, a new ticket will be created.

=head1 SECURITY MECHANISMS AND CONCERNS

=head2 Taint mode

Perl automatically enables a set of special security checks, called I<taint
mode>, when it detects its program running with differing real and effective
user or group IDs.  The setuid bit in Unix permissions is mode 04000, the
setgid bit mode 02000; either or both may be set.  You can also enable taint
mode explicitly by using the B<-T> command line flag.  This flag is
I<strongly> suggested for server programs and any program run on behalf of
someone else, such as a CGI script.  Once taint mode is on, it's on for
the remainder of your script.

While in this mode, Perl takes special precautions called I<taint
checks> to prevent both obvious and subtle traps.  Some of these checks
are reasonably simple, such as verifying that path directories aren't
writable by others; careful programmers have always used checks like
these.  Other checks, however, are best supported by the language itself,
and it is these checks especially that contribute to making a set-id Perl
program more secure than the corresponding C program.

You may not use data derived from outside your program to affect
something else outside your program--at least, not by accident.  All
command line arguments, environment variables, locale information (see
L<perllocale>), results of certain system calls (C<readdir()>,
C<readlink()>, the variable of C<shmread()>, the messages returned by
C<msgrcv()>, the password, gcos and shell fields returned by the
C<getpwxxx()> calls), and all file input are marked as "tainted".
Tainted data may not be used directly or indirectly in any command
that invokes a sub-shell, nor in any command that modifies files,
directories, or processes, B<with the following exceptions>:

=over 4

=item *

Arguments to C<print> and C<syswrite> are B<not> checked for taintedness.

=item *

Symbolic methods

    $obj->$method(@@args);

and symbolic sub references

    &{$foo}(@@args);
    $foo->(@@args);

are not checked for taintedness.  This requires extra carefulness
unless you want external data to affect your control flow.  Unless
you carefully limit what these symbolic values are, people are able
to call functions B<outside> your Perl code, such as POSIX::system,
in which case they are able to run arbitrary external code.

=item *

Hash keys are B<never> tainted.

=back

For efficiency reasons, Perl takes a conservative view of
whether data is tainted.  If an expression contains tainted data,
any subexpression may be considered tainted, even if the value
of the subexpression is not itself affected by the tainted data.

Because taintedness is associated with each scalar value, some
elements of an array or hash can be tainted and others not.
The keys of a hash are B<never> tainted.

For example:

    $arg = shift;		# $arg is tainted
    $hid = $arg . 'bar';	# $hid is also tainted
    $line = <>;			# Tainted
    $line = <STDIN>;		# Also tainted
    open FOO, "/home/me/bar" or die $!;
    $line = <FOO>;		# Still tainted
    $path = $ENV{'PATH'};	# Tainted, but see below
    $data = 'abc';		# Not tainted

    system "echo $arg";		# Insecure
    system "/bin/echo", $arg;	# Considered insecure
				# (Perl doesn't know about /bin/echo)
    system "echo $hid";		# Insecure
    system "echo $data";	# Insecure until PATH set

    $path = $ENV{'PATH'};	# $path now tainted

    $ENV{'PATH'} = '/bin:/usr/bin';
    delete @@ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

    $path = $ENV{'PATH'};	# $path now NOT tainted
    system "echo $data";	# Is secure now!

    open(FOO, "< $arg");	# OK - read-only file
    open(FOO, "> $arg"); 	# Not OK - trying to write

    open(FOO,"echo $arg|");	# Not OK
    open(FOO,"-|")
	or exec 'echo', $arg;	# Also not OK

    $shout = `echo $arg`;	# Insecure, $shout now tainted

    unlink $data, $arg;		# Insecure
    umask $arg;			# Insecure

    exec "echo $arg";		# Insecure
    exec "echo", $arg;		# Insecure
    exec "sh", '-c', $arg;	# Very insecure!

    @@files = <*.c>;		# insecure (uses readdir() or similar)
    @@files = glob('*.c');	# insecure (uses readdir() or similar)

    # In either case, the results of glob are tainted, since the list of
    # filenames comes from outside of the program.

    $bad = ($arg, 23);		# $bad will be tainted
    $arg, `true`;		# Insecure (although it isn't really)

If you try to do something insecure, you will get a fatal error saying
something like "Insecure dependency" or "Insecure $ENV{PATH}".

The exception to the principle of "one tainted value taints the whole
expression" is with the ternary conditional operator C<?:>.  Since code
with a ternary conditional

    $result = $tainted_value ? "Untainted" : "Also untainted";

is effectively

    if ( $tainted_value ) {
        $result = "Untainted";
    } else {
        $result = "Also untainted";
    }

it doesn't make sense for C<$result> to be tainted.

=head2 Laundering and Detecting Tainted Data

To test whether a variable contains tainted data, and whose use would
thus trigger an "Insecure dependency" message, you can use the
C<tainted()> function of the Scalar::Util module, available in your
nearby CPAN mirror, and included in Perl starting from the release 5.8.0.
Or you may be able to use the following C<is_tainted()> function.

    sub is_tainted {
        local $@@;   # Don't pollute caller's value.
        return ! eval { eval("#" . substr(join("", @@_), 0, 0)); 1 };
    }

This function makes use of the fact that the presence of tainted data
anywhere within an expression renders the entire expression tainted.  It
would be inefficient for every operator to test every argument for
taintedness.  Instead, the slightly more efficient and conservative
approach is used that if any tainted value has been accessed within the
same expression, the whole expression is considered tainted.

But testing for taintedness gets you only so far.  Sometimes you have just
to clear your data's taintedness.  Values may be untainted by using them
as keys in a hash; otherwise the only way to bypass the tainting
mechanism is by referencing subpatterns from a regular expression match.
Perl presumes that if you reference a substring using $1, $2, etc. in a
non-tainting pattern, that
you knew what you were doing when you wrote that pattern.  That means using
a bit of thought--don't just blindly untaint anything, or you defeat the
entire mechanism.  It's better to verify that the variable has only good
characters (for certain values of "good") rather than checking whether it
has any bad characters.  That's because it's far too easy to miss bad
characters that you never thought of.

Here's a test to make sure that the data contains nothing but "word"
characters (alphabetics, numerics, and underscores), a hyphen, an at sign,
or a dot.

    if ($data =~ /^([-\@@\w.]+)$/) {
	$data = $1; 			# $data now untainted
    } else {
	die "Bad data in '$data'"; 	# log this somewhere
    }

This is fairly secure because C</\w+/> doesn't normally match shell
metacharacters, nor are dot, dash, or at going to mean something special
to the shell.  Use of C</.+/> would have been insecure in theory because
it lets everything through, but Perl doesn't check for that.  The lesson
is that when untainting, you must be exceedingly careful with your patterns.
Laundering data using regular expression is the I<only> mechanism for
untainting dirty data, unless you use the strategy detailed below to fork
a child of lesser privilege.

The example does not untaint C<$data> if C<use locale> is in effect,
because the characters matched by C<\w> are determined by the locale.
Perl considers that locale definitions are untrustworthy because they
contain data from outside the program.  If you are writing a
locale-aware program, and want to launder data with a regular expression
containing C<\w>, put C<no locale> ahead of the expression in the same
block.  See L<perllocale/SECURITY> for further discussion and examples.

=head2 Switches On the "#!" Line

When you make a script executable, in order to make it usable as a
command, the system will pass switches to perl from the script's #!
line.  Perl checks that any command line switches given to a setuid
(or setgid) script actually match the ones set on the #! line.  Some
Unix and Unix-like environments impose a one-switch limit on the #!
line, so you may need to use something like C<-wU> instead of C<-w -U>
under such systems.  (This issue should arise only in Unix or
Unix-like environments that support #! and setuid or setgid scripts.)

=head2 Taint mode and @@INC

When the taint mode (C<-T>) is in effect, the "." directory is removed
from C<@@INC>, and the environment variables C<PERL5LIB> and C<PERLLIB>
are ignored by Perl.  You can still adjust C<@@INC> from outside the
program by using the C<-I> command line option as explained in
L<perlrun>.  The two environment variables are ignored because
they are obscured, and a user running a program could be unaware that
they are set, whereas the C<-I> option is clearly visible and
therefore permitted.

Another way to modify C<@@INC> without modifying the program, is to use
the C<lib> pragma, e.g.:

  perl -Mlib=/foo program

The benefit of using C<-Mlib=/foo> over C<-I/foo>, is that the former
will automagically remove any duplicated directories, while the latter
will not.

Note that if a tainted string is added to C<@@INC>, the following
problem will be reported:

  Insecure dependency in require while running with -T switch

=head2 Cleaning Up Your Path

For "Insecure C<$ENV{PATH}>" messages, you need to set C<$ENV{'PATH'}> to
a known value, and each directory in the path must be absolute and
non-writable by others than its owner and group.  You may be surprised to
get this message even if the pathname to your executable is fully
qualified.  This is I<not> generated because you didn't supply a full path
to the program; instead, it's generated because you never set your PATH
environment variable, or you didn't set it to something that was safe.
Because Perl can't guarantee that the executable in question isn't itself
going to turn around and execute some other program that is dependent on
your PATH, it makes sure you set the PATH.

The PATH isn't the only environment variable which can cause problems.
Because some shells may use the variables IFS, CDPATH, ENV, and
BASH_ENV, Perl checks that those are either empty or untainted when
starting subprocesses.  You may wish to add something like this to your
setid and taint-checking scripts.

    delete @@ENV{qw(IFS CDPATH ENV BASH_ENV)};   # Make %ENV safer

It's also possible to get into trouble with other operations that don't
care whether they use tainted values.  Make judicious use of the file
tests in dealing with any user-supplied filenames.  When possible, do
opens and such B<after> properly dropping any special user (or group!)
privileges.  Perl doesn't prevent you from
opening tainted filenames for reading,
so be careful what you print out.  The tainting mechanism is intended to
prevent stupid mistakes, not to remove the need for thought.

Perl does not call the shell to expand wild cards when you pass C<system>
and C<exec> explicit parameter lists instead of strings with possible shell
wildcards in them.  Unfortunately, the C<open>, C<glob>, and
backtick functions provide no such alternate calling convention, so more
subterfuge will be required.

Perl provides a reasonably safe way to open a file or pipe from a setuid
or setgid program: just create a child process with reduced privilege who
does the dirty work for you.  First, fork a child using the special
C<open> syntax that connects the parent and child by a pipe.  Now the
child resets its ID set and any other per-process attributes, like
environment variables, umasks, current working directories, back to the
originals or known safe values.  Then the child process, which no longer
has any special permissions, does the C<open> or other system call.
Finally, the child passes the data it managed to access back to the
parent.  Because the file or pipe was opened in the child while running
under less privilege than the parent, it's not apt to be tricked into
doing something it shouldn't.

Here's a way to do backticks reasonably safely.  Notice how the C<exec> is
not called with a string that the shell could expand.  This is by far the
best way to call something that might be subjected to shell escapes: just
never call the shell at all.  

        use English;
        die "Can't fork: $!" unless defined($pid = open(KID, "-|"));
        if ($pid) {           # parent
            while (<KID>) {
                # do something
            }
            close KID;
        } else {
            my @@temp     = ($EUID, $EGID);
            my $orig_uid = $UID;
            my $orig_gid = $GID;
            $EUID = $UID;
            $EGID = $GID;
            # Drop privileges
            $UID  = $orig_uid;
            $GID  = $orig_gid;
            # Make sure privs are really gone
            ($EUID, $EGID) = @@temp;
            die "Can't drop privileges"
                unless $UID == $EUID  && $GID eq $EGID;
            $ENV{PATH} = "/bin:/usr/bin"; # Minimal PATH.
	    # Consider sanitizing the environment even more.
            exec 'myprog', 'arg1', 'arg2'
                or die "can't exec myprog: $!";
        }

A similar strategy would work for wildcard expansion via C<glob>, although
you can use C<readdir> instead.

Taint checking is most useful when although you trust yourself not to have
written a program to give away the farm, you don't necessarily trust those
who end up using it not to try to trick it into doing something bad.  This
is the kind of security checking that's useful for set-id programs and
programs launched on someone else's behalf, like CGI programs.

This is quite different, however, from not even trusting the writer of the
code not to try to do something evil.  That's the kind of trust needed
when someone hands you a program you've never seen before and says, "Here,
run this."  For that kind of safety, you might want to check out the Safe
module, included standard in the Perl distribution.  This module allows the
programmer to set up special compartments in which all system operations
are trapped and namespace access is carefully controlled.  Safe should
not be considered bullet-proof, though: it will not prevent the foreign
code to set up infinite loops, allocate gigabytes of memory, or even
abusing perl bugs to make the host interpreter crash or behave in
unpredictable ways.  In any case it's better avoided completely if you're
really concerned about security.

=head2 Security Bugs

Beyond the obvious problems that stem from giving special privileges to
systems as flexible as scripts, on many versions of Unix, set-id scripts
are inherently insecure right from the start.  The problem is a race
condition in the kernel.  Between the time the kernel opens the file to
see which interpreter to run and when the (now-set-id) interpreter turns
around and reopens the file to interpret it, the file in question may have
changed, especially if you have symbolic links on your system.

Fortunately, sometimes this kernel "feature" can be disabled.
Unfortunately, there are two ways to disable it.  The system can simply
outlaw scripts with any set-id bit set, which doesn't help much.
Alternately, it can simply ignore the set-id bits on scripts.

However, if the kernel set-id script feature isn't disabled, Perl will
complain loudly that your set-id script is insecure.  You'll need to
either disable the kernel set-id script feature, or put a C wrapper around
the script.  A C wrapper is just a compiled program that does nothing
except call your Perl program.   Compiled programs are not subject to the
kernel bug that plagues set-id scripts.  Here's a simple wrapper, written
in C:

    #define REAL_PATH "/path/to/script"
    main(ac, av)
	char **av;
    {
	execv(REAL_PATH, av);
    }

Compile this wrapper into a binary executable and then make I<it> rather
than your script setuid or setgid.

In recent years, vendors have begun to supply systems free of this
inherent security bug.  On such systems, when the kernel passes the name
of the set-id script to open to the interpreter, rather than using a
pathname subject to meddling, it instead passes I</dev/fd/3>.  This is a
special file already opened on the script, so that there can be no race
condition for evil scripts to exploit.  On these systems, Perl should be
compiled with C<-DSETUID_SCRIPTS_ARE_SECURE_NOW>.  The F<Configure>
program that builds Perl tries to figure this out for itself, so you
should never have to specify this yourself.  Most modern releases of
SysVr4 and BSD 4.4 use this approach to avoid the kernel race condition.

=head2 Protecting Your Programs

There are a number of ways to hide the source to your Perl programs,
with varying levels of "security".

First of all, however, you I<can't> take away read permission, because
the source code has to be readable in order to be compiled and
interpreted.  (That doesn't mean that a CGI script's source is
readable by people on the web, though.)  So you have to leave the
permissions at the socially friendly 0755 level.  This lets 
people on your local system only see your source.

Some people mistakenly regard this as a security problem.  If your program does
insecure things, and relies on people not knowing how to exploit those
insecurities, it is not secure.  It is often possible for someone to
determine the insecure things and exploit them without viewing the
source.  Security through obscurity, the name for hiding your bugs
instead of fixing them, is little security indeed.

You can try using encryption via source filters (Filter::* from CPAN,
or Filter::Util::Call and Filter::Simple since Perl 5.8).
But crackers might be able to decrypt it.  You can try using the byte
code compiler and interpreter described below, but crackers might be
able to de-compile it.  You can try using the native-code compiler
described below, but crackers might be able to disassemble it.  These
pose varying degrees of difficulty to people wanting to get at your
code, but none can definitively conceal it (this is true of every
language, not just Perl).

If you're concerned about people profiting from your code, then the
bottom line is that nothing but a restrictive license will give you
legal security.  License your software and pepper it with threatening
statements like "This is unpublished proprietary software of XYZ Corp.
Your access to it does not give you permission to use it blah blah
blah."  You should see a lawyer to be sure your license's wording will
stand up in court.

=head2 Unicode

Unicode is a new and complex technology and one may easily overlook
certain security pitfalls.  See L<perluniintro> for an overview and
L<perlunicode> for details, and L<perlunicode/"Security Implications
of Unicode"> for security implications in particular.

=head2 Algorithmic Complexity Attacks

Certain internal algorithms used in the implementation of Perl can
be attacked by choosing the input carefully to consume large amounts
of either time or space or both.  This can lead into the so-called
I<Denial of Service> (DoS) attacks.

=over 4

=item *

Hash Algorithm - Hash algorithms like the one used in Perl are well
known to be vulnerable to collision attacks on their hash function.
Such attacks involve constructing a set of keys which collide into
the same bucket producing inefficient behavior.  Such attacks often
depend on discovering the seed of the hash function used to map the
keys to buckets.  That seed is then used to brute-force a key set which
can be used to mount a denial of service attack.  In Perl 5.8.1 changes
were introduced to harden Perl to such attacks, and then later in
Perl 5.18.0 these features were enhanced and additional protections
added.

At the time of this writing, Perl 5.18.0 is considered to be
well-hardened against algorithmic complexity attacks on its hash
implementation.  This is largely owed to the following measures
mitigate attacks:

=over 4

=item Hash Seed Randomization

In order to make it impossible to know what seed to generate an attack
key set for, this seed is randomly initialized at process start.  This
may be overridden by using the PERL_HASH_SEED environment variable, see
L<perlrun/PERL_HASH_SEED>.  This environment variable controls how
items are actually stored, not how they are presented via
C<keys>, C<values> and C<each>.

=item Hash Traversal Randomization

Independent of which seed is used in the hash function, C<keys>,
C<values>, and C<each> return items in a per-hash randomized order.
Modifying a hash by insertion will change the iteration order of that hash.
This behavior can be overridden by using C<hash_traversal_mask()> from
L<Hash::Util> or by using the PERL_PERTURB_KEYS environment variable,
see L<perlrun/PERL_PERTURB_KEYS>.  Note that this feature controls the
"visible" order of the keys, and not the actual order they are stored in.

=item Bucket Order Perturbance

When items collide into a given hash bucket the order they are stored in
the chain is no longer predictable in Perl 5.18.  This
has the intention to make it harder to observe a
collision.  This behavior can be overridden by using
the PERL_PERTURB_KEYS environment variable, see L<perlrun/PERL_PERTURB_KEYS>.

=item New Default Hash Function

The default hash function has been modified with the intention of making
it harder to infer the hash seed.

=item Alternative Hash Functions

The source code includes multiple hash algorithms to choose from.  While we
believe that the default perl hash is robust to attack, we have included the
hash function Siphash as a fall-back option.  At the time of release of
Perl 5.18.0 Siphash is believed to be of cryptographic strength.  This is
not the default as it is much slower than the default hash.

=back

Without compiling a special Perl, there is no way to get the exact same
behavior of any versions prior to Perl 5.18.0.  The closest one can get
is by setting PERL_PERTURB_KEYS to 0 and setting the PERL_HASH_SEED
to a known value.  We do not advise those settings for production use
due to the above security considerations.

B<Perl has never guaranteed any ordering of the hash keys>, and
the ordering has already changed several times during the lifetime of
Perl 5.  Also, the ordering of hash keys has always been, and continues
to be, affected by the insertion order and the history of changes made
to the hash over its lifetime.

Also note that while the order of the hash elements might be
randomized, this "pseudo-ordering" should B<not> be used for
applications like shuffling a list randomly (use C<List::Util::shuffle()>
for that, see L<List::Util>, a standard core module since Perl 5.8.0;
or the CPAN module C<Algorithm::Numerical::Shuffle>), or for generating
permutations (use e.g. the CPAN modules C<Algorithm::Permute> or
C<Algorithm::FastPermute>), or for any cryptographic applications.

Tied hashes may have their own ordering and algorithmic complexity
attacks.

=item *

Regular expressions - Perl's regular expression engine is so called NFA
(Non-deterministic Finite Automaton), which among other things means that
it can rather easily consume large amounts of both time and space if the
regular expression may match in several ways.  Careful crafting of the
regular expressions can help but quite often there really isn't much
one can do (the book "Mastering Regular Expressions" is required
reading, see L<perlfaq2>).  Running out of space manifests itself by
Perl running out of memory.

=item *

Sorting - the quicksort algorithm used in Perls before 5.8.0 to
implement the sort() function is very easy to trick into misbehaving
so that it consumes a lot of time.  Starting from Perl 5.8.0 a different
sorting algorithm, mergesort, is used by default.  Mergesort cannot
misbehave on any input.

=back

See L<http://www.cs.rice.edu/~scrosby/hash/> for more information,
and any computer science textbook on algorithmic complexity.

=head1 SEE ALSO

L<perlrun> for its description of cleaning up environment variables.
@


1.17
log
@Fix merge issues, remove excess files - match perl-5.20.2 dist
@
text
@d17 18
a34 5
If you believe you have found a security vulnerability in Perl, please email
perl5-security-report@@perl.org with details.  This points to a closed
subscription, unarchived mailing list.  Please only use this address for
security issues in the Perl core, not for modules independently distributed on
CPAN.
@


1.16
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d31 1
a31 1
mode explicitly by using the B<-T> command line flag. This flag is
d33 1
a33 1
someone else, such as a CGI script. Once taint mode is on, it's on for
d237 1
a237 1
are ignored by Perl. You can still adjust C<@@INC> from outside the
d239 1
a239 1
L<perlrun>. The two environment variables are ignored because
d250 1
a250 1
will automagically remove any duplicated directories, while the later
d274 1
a274 1
starting subprocesses. You may wish to add something like this to your
d283 2
a284 1
privileges. Perl doesn't prevent you from opening tainted filenames for reading,
d357 1
a357 1
unpredictable ways. In any case it's better avoided completely if you're
d462 1
a462 1
the same bucket producing inefficient behavior. Such attacks often
d464 2
a465 2
keys to buckets. That seed is then used to brute-force a key set which
can be used to mount a denial of service attack. In Perl 5.8.1 changes
d472 1
a472 1
implementation. This is largely owed to the following measures
d480 1
a480 1
key set for, this seed is randomly initialized at process start. This
d482 1
a482 1
L<perlrun/PERL_HASH_SEED>. This environment variable controls how
d493 1
a493 1
see L<perlrun/PERL_PERTURB_KEYS>. Note that this feature controls the
d499 3
a501 2
the chain is no longer predictable in Perl 5.18. This has the intention
to make it harder to observe a collisions. This behavior can be overridden by using
d513 1
a513 1
hash function Siphash as a fall-back option. At the time of release of
d520 1
a520 1
behavior of any versions prior to Perl 5.18.0. The closest one can get
d522 1
a522 1
to a known value. We do not advise those settings for production use
@


1.15
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d186 3
a188 2
Perl presumes that if you reference a substring using $1, $2, etc., that
you knew what you were doing when you wrote the pattern.  That means using
d311 1
a311 1
        use English '-no_match_vars';
d536 3
@


1.14
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d96 1
a96 1
    $hid = $arg, 'bar';		# $hid is also tainted
d137 2
a138 4
    # In Perl releases older than 5.6.0 the <*.c> and glob('*.c') would
    # have used an external program to do the filename expansion; but in
    # either case the result is tainted since the list of filenames comes
    # from outside of the program.
d457 70
a526 27
Hash Function - the algorithm used to "order" hash elements has been
changed several times during the development of Perl, mainly to be
reasonably fast.  In Perl 5.8.1 also the security aspect was taken
into account.

In Perls before 5.8.1 one could rather easily generate data that as
hash keys would cause Perl to consume large amounts of time because
internal structure of hashes would badly degenerate.  In Perl 5.8.1
the hash function is randomly perturbed by a pseudorandom seed which
makes generating such naughty hash keys harder.
See L<perlrun/PERL_HASH_SEED> for more information.

In Perl 5.8.1 the random perturbation was done by default, but as of
5.8.2 it is only used on individual hashes if the internals detect the
insertion of pathological data. If one wants for some reason emulate the
old behaviour (and expose oneself to DoS attacks) one can set the
environment variable PERL_HASH_SEED to zero to disable the protection
(or any other integer to force a known perturbation, rather than random). 
One possible reason for wanting to emulate the old behaviour is that in the
new behaviour consecutive runs of Perl will order hash keys differently,
which may confuse some applications (like Data::Dumper: the outputs of two
different runs are no longer identical).

B<Perl has never guaranteed any ordering of the hash keys>, and the
ordering has already changed several times during the lifetime of
Perl 5.  Also, the ordering of hash keys has always been, and
continues to be, affected by the insertion order.
d529 2
a530 2
randomised, this "pseudoordering" should B<not> be used for
applications like shuffling a list randomly (use List::Util::shuffle()
d532 3
a534 3
or the CPAN module Algorithm::Numerical::Shuffle), or for generating
permutations (use e.g. the CPAN modules Algorithm::Permute or
Algorithm::FastPermute), or for any cryptographic applications.
@


1.13
log
@merge in perl 5.12.2 plus local changes
@
text
@d173 1
@


1.12
log
@Merge in perl 5.10.1
@
text
@d349 2
a350 2
run this."  For that kind of safety, check out the Safe module,
included standard in the Perl distribution.  This module allows the
d352 6
a357 1
are trapped and namespace access is carefully controlled.
d372 1
a372 9
Alternately, it can simply ignore the set-id bits on scripts.  If the
latter is true, Perl can emulate the setuid and setgid mechanism when it
notices the otherwise useless setuid/gid bits on Perl scripts.  It does
this via a special executable called F<suidperl> that is automatically
invoked for you if it's needed.

B<The use of suidperl is considered deprecated>, and will be removed
in Perl 5.12.0.  It is I<strongly> recommended that all code uses
the simplier and more secure C-wrappers described below.
d374 1
a374 1
If the kernel set-id script feature isn't disabled, Perl will
a401 4

Prior to release 5.6.1 of Perl, bugs in the code of F<suidperl> could
introduce a security hole.  The use of F<suidperl> is considered
deprecated, and will be removed in Perl 5.12.0.
@


1.11
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d15 12
d373 5
a377 1
However, if the kernel set-id script feature isn't disabled, Perl will
d407 2
a408 1
introduce a security hole.
d440 1
a440 1
bottom line is that nothing but a restrictive licence will give you
d444 1
a444 1
blah."  You should see a lawyer to be sure your licence's wording will
d477 10
a486 7
The random perturbation is done by default but if one wants for some
reason emulate the old behaviour one can set the environment variable
PERL_HASH_SEED to zero (or any other integer).  One possible reason
for wanting to emulate the old behaviour is that in the new behaviour
consecutive runs of Perl will order hash keys differently, which may
confuse some applications (like Data::Dumper: the outputs of two
different runs are no more identical).
d516 3
a518 4
so that it consumes a lot of time.  Nothing more is required than
resorting a list already sorted.  Starting from Perl 5.8.0 a different
sorting algorithm, mergesort, is used.  Mergesort is insensitive to
its input data, so it cannot be similarly fooled.
d523 1
a523 1
and any computer science textbook on the algorithmic complexity.
@


1.10
log
@merge in perl 5.8.8
@
text
@d66 4
d79 1
a79 1
The keys of a hash are never tainted.
d483 3
a485 3
Regular expressions - Perl's regular expression engine is so called
NFA (Non-Finite Automaton), which among other things means that it can
rather easily consume large amounts of both time and space if the
d504 1
a504 1
and any computer science text book on the algorithmic complexity.
@


1.9
log
@sync in-tree perl with 5.8.6
@
text
@d237 5
@


1.8
log
@merge local changes into perl-5.8.3
@
text
@d35 4
a38 4
L<perllocale>), results of certain system calls (readdir(),
readlink(), the variable of shmread(), the messages returned by
msgrcv(), the password, gcos and shell fields returned by the
getpwxxx() calls), and all file input are marked as "tainted".
d132 16
d152 1
a152 1
tainted() function of the Scalar::Util module, available in your
d198 1
a198 1
The example does not untaint $data if C<use locale> is in effect,
d239 10
a248 10
For "Insecure C<$ENV{PATH}>" messages, you need to set C<$ENV{'PATH'}> to a
known value, and each directory in the path must be non-writable by others
than its owner and group.  You may be surprised to get this message even
if the pathname to your executable is fully qualified.  This is I<not>
generated because you didn't supply a full path to the program; instead,
it's generated because you never set your PATH environment variable, or
you didn't set it to something that was safe.  Because Perl can't
guarantee that the executable in question isn't itself going to turn
around and execute some other program that is dependent on your PATH, it
makes sure you set the PATH.
d266 3
a268 3
Perl does not call the shell to expand wild cards when you pass B<system>
and B<exec> explicit parameter lists instead of strings with possible shell
wildcards in them.  Unfortunately, the B<open>, B<glob>, and
d275 1
a275 1
B<open> syntax that connects the parent and child by a pipe.  Now the
d279 1
a279 1
has any special permissions, does the B<open> or other system call.
d285 1
a285 1
Here's a way to do backticks reasonably safely.  Notice how the B<exec> is
d349 1
a349 1
this via a special executable called B<suidperl> that is automatically
d376 1
a376 1
compiled with C<-DSETUID_SCRIPTS_ARE_SECURE_NOW>.  The B<Configure>
d381 1
a381 1
Prior to release 5.6.1 of Perl, bugs in the code of B<suidperl> could
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d68 4
a71 3
The value of an expression containing tainted data will itself be
tainted, even if it is logically impossible for the tainted data to
affect the value.
d74 2
a75 1
elements of an array can be tainted and others not.
d138 1
a138 1
Or you may be able to use the following I<is_tainted()> function.
d152 2
a153 1
to clear your data's taintedness.  The only way to bypass the tainting
d200 20
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@a46 8
If you pass more than one argument to either C<system> or C<exec>,
the arguments are checked for taintedness B<but> the operation will still
be attempted, emitting an optional warning.  This will be fatal in a 
future version of perl so do not rely on it to bypass the tainting 
mechanism.

=item *

d87 1
a87 1
    system "/bin/echo", $arg;	# Allowed but considered insecure
d105 1
a105 1
	or exec 'echo', $arg;	# Allowed but not really OK
d113 2
a114 2
    exec "echo", $arg;		# Allowed but considered insecure
    exec "sh", '-c', $arg;	# Considered secure, alas!
d128 1
a128 4
something like "Insecure dependency" or "Insecure $ENV{PATH}".  Note that you
can still write an insecure B<system> or B<exec>, but only by explicitly
doing something like the "considered secure" example above.  This will not
be possible in a future version of Perl.
d167 1
a167 1
	die "Bad data in $data"; 	# log this somewhere
d388 69
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d47 5
a51 2
If you pass a list of arguments to either C<system> or C<exec>,
the elements of that list are B<not> checked for taintedness.
d57 17
d76 4
a79 3
Any variable set to a value
derived from tainted data will itself be tainted, even if it is
logically impossible for the tainted data to alter the variable.
d95 2
a96 1
    system "/bin/echo", $arg;	# Secure (doesn't use sh)
d111 1
a111 1
    open(FOO,"echo $arg|");	# Not OK, but...
d113 1
a113 1
	or exec 'echo', $arg;	# OK
d121 1
a121 1
    exec "echo", $arg;		# Secure (doesn't use the shell)
d127 8
d138 2
a139 1
doing something like the "considered secure" example above.
d143 5
a147 4
To test whether a variable contains tainted data, and whose use would thus
trigger an "Insecure dependency" message, check your nearby CPAN mirror
for the F<Taint.pm> module, which should become available around November
1997.  Or you may be able to use the following I<is_tainted()> function.
d150 1
a150 4
	return ! eval {
	    join('',@@_), kill 0;
	    1;
	};
d262 1
a262 1
        use English;
d375 5
a379 4
You can try using encryption via source filters (Filter::* from CPAN).
But crackers might be able to decrypt it.  You can try using the
byte code compiler and interpreter described below, but crackers might
be able to de-compile it.  You can try using the native-code compiler
d392 7
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d41 16
a56 3
directories, or processes. (B<Important exception>: If you pass a list
of arguments to either C<system> or C<exec>, the elements of that list
are B<NOT> checked for taintedness.) Any variable set to a value
d233 25
a257 19
    use English;
    die "Can't fork: $!" unless defined $pid = open(KID, "-|");
    if ($pid) {	          # parent
	while (<KID>) {
	    # do something
	}
	close KID;
    } else {
	my @@temp = ($EUID, $EGID);
	$EUID = $UID;
	$EGID = $GID;    # 	initgroups() also called!
	# Make sure privs are really gone
	($EUID, $EGID) = @@temp;
	die "Can't drop privileges" 
		unless $UID == $EUID  && $GID eq $EGID;	
	$ENV{PATH} = "/bin:/usr/bin";
	exec 'myprog', 'arg1', 'arg2' 
	    or die "can't exec myprog: $!";
    }
a312 6
See the program B<wrapsuid> in the F<eg> directory of your Perl
distribution for a convenient way to do this automatically for all your
setuid Perl programs.  It moves setuid scripts into files with the same
name plus a leading dot, and then compiles a wrapper like the one above
for each of them.

d324 2
a325 3
Prior to release 5.003 of Perl, a bug in the code of B<suidperl> could
introduce a security hole in systems compiled with strict POSIX
compliance.
@


1.3
log
@perl5.005_03 (stock)
@
text
@d35 13
a47 11
L<perllocale>), results of certain system calls (readdir, readlink,
the gecos field of getpw* calls), and all file input are marked as
"tainted".  Tainted data may not be used directly or indirectly in any
command that invokes a sub-shell, nor in any command that modifies
files, directories, or processes. (B<Important exception>: If you pass
a list of arguments to either C<system> or C<exec>, the elements of
that list are B<NOT> checked for taintedness.) Any variable set
to a value derived from tainted data will itself be tainted,
even if it is logically impossible for the tainted data
to alter the variable.  Because taintedness is associated with each
scalar value, some elements of an array can be tainted and others not.
d89 2
a90 2
    @@files = <*.c>;		# Always insecure (uses csh)
    @@files = glob('*.c');	# Always insecure (uses csh)
d144 1
a144 1
Laundering data using regular expression is the I<ONLY> mechanism for
@


1.2
log
@perl 5.004_04
@
text
@d39 3
a41 1
files, directories, or processes.  Any variable set
d91 1
a91 1
something like "Insecure dependency" or "Insecure PATH".  Note that you
d93 1
a93 1
doing something like the last example above.
d178 8
d228 1
a228 1
	$EGID = $GID;    # XXX: initgroups() not called
d231 2
a232 3
	die "Can't drop privileges" unless
	    $UID == $EUID and
	    $GID eq $EGID;	# String test
d234 2
a235 2
	exec 'myprog', 'arg1', 'arg2' or
	die "can't exec myprog: $!";
d322 2
a323 1
permissions at the socially friendly 0755 level.
d325 1
a325 1
Some people regard this as a security problem.  If your program does
d348 4
@


1.1
log
@Initial revision
@
text
@d7 37
a43 7
Perl is designed to make it easy to write secure setuid and setgid
scripts.  Unlike shells, which are based on multiple substitution
passes on each line of the script, Perl uses a more conventional
evaluation scheme with fewer hidden "gotchas".  Additionally, since the
language has more built-in functionality, it has to rely less upon
external (and possibly untrustworthy) programs to accomplish its
purposes.
a44 43
Beyond the obvious problems that stem from giving special privileges to
such flexible systems as scripts, on many operating systems, setuid
scripts are inherently insecure right from the start.  This is because
that between the time that the kernel opens up the file to see what to
run, and when the now setuid interpreter it ran turns around and reopens
the file so it can interpret it, things may have changed, especially if
you have symbolic links on your system.

Fortunately, sometimes this kernel "feature" can be disabled.
Unfortunately, there are two ways to disable it.  The system can simply
outlaw scripts with the setuid bit set, which doesn't help much.
Alternately, it can simply ignore the setuid bit on scripts.  If the
latter is true, Perl can emulate the setuid and setgid mechanism when it
notices the otherwise useless setuid/gid bits on Perl scripts.  It does
this via a special executable called B<suidperl> that is automatically
invoked for you if it's needed.

If, however, the kernel setuid script feature isn't disabled, Perl will
complain loudly that your setuid script is insecure.  You'll need to
either disable the kernel setuid script feature, or put a C wrapper around
the script.  See the program B<wrapsuid> in the F<eg> directory of your
Perl distribution for how to go about doing this.

There are some systems on which setuid scripts are free of this inherent
security bug.  For example, recent releases of Solaris are like this.  On
such systems, when the kernel passes the name of the setuid script to open
to the interpreter, rather than using a pathname subject to mettling, it
instead passes /dev/fd/3.  This is a special file already opened on the
script, so that there can be no race condition for evil scripts to
exploit.  On these systems, Perl should be compiled with
C<-DSETUID_SCRIPTS_ARE_SECURE_NOW>.  The B<Configure> program that builds
Perl tries to figure this out for itself.

When executing a setuid script, or when you have turned on taint checking
explicitly using the B<-T> flag, Perl takes special precautions to
prevent you from falling into any obvious traps.  (In some ways, a Perl
script is more secure than the corresponding C program.)  Any command line
argument, environment variable, or input is marked as "tainted", and may
not be used, directly or indirectly, in any command that invokes a
subshell, or in any command that modifies files, directories, or
processes.  Any variable that is set within an expression that has
previously referenced a tainted value also becomes tainted (even if it is
logically impossible for the tainted value to influence the variable).
d47 6
a52 3
    $foo = shift;		# $foo is tainted
    $bar = $foo,'bar';		# $bar is also tainted
    $xxx = <>;			# Tainted
d54 6
a59 1
    $abc = 'abc';		# Not tainted
d61 1
a61 4
    system "echo $foo";		# Insecure
    system "/bin/echo", $foo;	# Secure (doesn't use sh)
    system "echo $bar";		# Insecure
    system "echo $abc";		# Insecure until PATH set
d64 1
a64 1
    $ENV{'IFS'} = '' if $ENV{'IFS'} ne '';
d66 2
a67 2
    $path = $ENV{'PATH'};	# Not tainted
    system "echo $abc";		# Is secure now!
d69 2
a70 2
    open(FOO,"$foo");		# OK
    open(FOO,">$foo"); 		# Not OK
d72 3
a74 2
    open(FOO,"echo $foo|");	# Not OK, but...
    open(FOO,"-|") || exec 'echo', $foo;	# OK
d76 1
a76 1
    $zzz = `echo $foo`;		# Insecure, zzz tainted
d78 2
a79 2
    unlink $abc,$foo;		# Insecure
    umask $foo;			# Insecure
d81 3
a83 3
    exec "echo $foo";		# Insecure
    exec "echo", $foo;		# Secure (doesn't use sh)
    exec "sh", '-c', $foo;	# Considered secure, alas
d85 2
a86 2
The taintedness is associated with each scalar value, so some elements
of an array can be tainted, and others not.
d90 85
a174 21
can still write an insecure system call or exec, but only by explicitly
doing something like the last example above.  You can also bypass the
tainting mechanism by referencing subpatterns--Perl presumes that if
you reference a substring using $1, $2, etc, you knew what you were
doing when you wrote the pattern:

    $ARGV[0] =~ /^-P(\w+)$/;
    $printer = $1;		# Not tainted

This is fairly secure since C<\w+> doesn't match shell metacharacters.
Use of C</.+/> would have been insecure, but Perl doesn't check for that,
so you must be careful with your patterns.  This is the I<ONLY> mechanism
for untainting user supplied filenames if you want to do file operations
on them (unless you make C<$E<gt>> equal to C<$E<lt>> ).

For "Insecure $ENV{PATH}" messages, you need to set C<$ENV{'PATH'}> to a known
value, and each directory in the path must be non-writable by the world.
A frequently voiced gripe is that you can get this message even
if the pathname to an executable is fully qualified.  But Perl can't
know that the executable in question isn't going to execute some other
program depending on the PATH.
d179 2
a180 2
opens and such after setting C<$E<gt> = $E<lt>>.  (Remember group IDs,
too!) Perl doesn't prevent you from opening tainted filenames for reading,
d184 23
a206 5
This gives us a reasonably safe way to open a file or pipe: just reset the
id set to the original IDs.  Here's a way to do backticks reasonably
safely.  Notice how the exec() is not called with a string that the shell
could expand.  By the time we get to the exec(), tainting is turned off,
however, so be careful what you call and what you pass it.
d208 2
a209 1
    die unless defined $pid = open(KID, "-|");
d213 1
a213 1
	} 
d216 48
a263 5
	$> = $<; 
	$) = $(;  # BUG: initgroups() not called
	exec 'program', 'arg1', 'arg2';
	die "can't exec program: $!";
    } 
d265 73
a337 2
For those even more concerned about safety, see the I<Safe> and I<Safe CGI> 
modules at a CPAN site near you.  See L<perlmod> for a list of CPAN sites.
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d7 7
a13 39
Perl is designed to make it easy to program securely even when running
with extra privileges, like setuid or setgid programs.  Unlike most
command line shells, which are based on multiple substitution passes on
each line of the script, Perl uses a more conventional evaluation scheme
with fewer hidden snags.  Additionally, because the language has more
builtin functionality, it can rely less upon external (and possibly
untrustworthy) programs to accomplish its purposes.

Perl automatically enables a set of special security checks, called I<taint
mode>, when it detects its program running with differing real and effective
user or group IDs.  The setuid bit in Unix permissions is mode 04000, the
setgid bit mode 02000; either or both may be set.  You can also enable taint
mode explicitly by using the B<-T> command line flag. This flag is
I<strongly> suggested for server programs and any program run on behalf of
someone else, such as a CGI script. Once taint mode is on, it's on for
the remainder of your script.

While in this mode, Perl takes special precautions called I<taint
checks> to prevent both obvious and subtle traps.  Some of these checks
are reasonably simple, such as verifying that path directories aren't
writable by others; careful programmers have always used checks like
these.  Other checks, however, are best supported by the language itself,
and it is these checks especially that contribute to making a set-id Perl
program more secure than the corresponding C program.

You may not use data derived from outside your program to affect
something else outside your program--at least, not by accident.  All
command line arguments, environment variables, locale information (see
L<perllocale>), results of certain system calls (readdir, readlink,
the gecos field of getpw* calls), and all file input are marked as
"tainted".  Tainted data may not be used directly or indirectly in any
command that invokes a sub-shell, nor in any command that modifies
files, directories, or processes. (B<Important exception>: If you pass
a list of arguments to either C<system> or C<exec>, the elements of
that list are B<NOT> checked for taintedness.) Any variable set
to a value derived from tainted data will itself be tainted,
even if it is logically impossible for the tainted data
to alter the variable.  Because taintedness is associated with each
scalar value, some elements of an array can be tainted and others not.
d15 43
d60 3
a62 6
    $arg = shift;		# $arg is tainted
    $hid = $arg, 'bar';		# $hid is also tainted
    $line = <>;			# Tainted
    $line = <STDIN>;		# Also tainted
    open FOO, "/home/me/bar" or die $!;
    $line = <FOO>;		# Still tainted
d64 1
a64 6
    $data = 'abc';		# Not tainted

    system "echo $arg";		# Insecure
    system "/bin/echo", $arg;	# Secure (doesn't use sh)
    system "echo $hid";		# Insecure
    system "echo $data";	# Insecure until PATH set
d66 4
a69 1
    $path = $ENV{'PATH'};	# $path now tainted
d72 1
a72 1
    delete @@ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};
d74 2
a75 2
    $path = $ENV{'PATH'};	# $path now NOT tainted
    system "echo $data";	# Is secure now!
d77 2
a78 2
    open(FOO, "< $arg");	# OK - read-only file
    open(FOO, "> $arg"); 	# Not OK - trying to write
d80 2
a81 3
    open(FOO,"echo $arg|");	# Not OK, but...
    open(FOO,"-|")
	or exec 'echo', $arg;	# OK
d83 1
a83 1
    $shout = `echo $arg`;	# Insecure, $shout now tainted
d85 2
a86 2
    unlink $data, $arg;		# Insecure
    umask $arg;			# Insecure
d88 3
a90 3
    exec "echo $arg";		# Insecure
    exec "echo", $arg;		# Secure (doesn't use the shell)
    exec "sh", '-c', $arg;	# Considered secure, alas!
d92 2
a93 2
    @@files = <*.c>;		# Always insecure (uses csh)
    @@files = glob('*.c');	# Always insecure (uses csh)
d96 22
a117 94
something like "Insecure dependency" or "Insecure $ENV{PATH}".  Note that you
can still write an insecure B<system> or B<exec>, but only by explicitly
doing something like the "considered secure" example above.

=head2 Laundering and Detecting Tainted Data

To test whether a variable contains tainted data, and whose use would thus
trigger an "Insecure dependency" message, check your nearby CPAN mirror
for the F<Taint.pm> module, which should become available around November
1997.  Or you may be able to use the following I<is_tainted()> function.

    sub is_tainted {
	return ! eval {
	    join('',@@_), kill 0;
	    1;
	};
    }

This function makes use of the fact that the presence of tainted data
anywhere within an expression renders the entire expression tainted.  It
would be inefficient for every operator to test every argument for
taintedness.  Instead, the slightly more efficient and conservative
approach is used that if any tainted value has been accessed within the
same expression, the whole expression is considered tainted.

But testing for taintedness gets you only so far.  Sometimes you have just
to clear your data's taintedness.  The only way to bypass the tainting
mechanism is by referencing subpatterns from a regular expression match.
Perl presumes that if you reference a substring using $1, $2, etc., that
you knew what you were doing when you wrote the pattern.  That means using
a bit of thought--don't just blindly untaint anything, or you defeat the
entire mechanism.  It's better to verify that the variable has only good
characters (for certain values of "good") rather than checking whether it
has any bad characters.  That's because it's far too easy to miss bad
characters that you never thought of.

Here's a test to make sure that the data contains nothing but "word"
characters (alphabetics, numerics, and underscores), a hyphen, an at sign,
or a dot.

    if ($data =~ /^([-\@@\w.]+)$/) {
	$data = $1; 			# $data now untainted
    } else {
	die "Bad data in $data"; 	# log this somewhere
    }

This is fairly secure because C</\w+/> doesn't normally match shell
metacharacters, nor are dot, dash, or at going to mean something special
to the shell.  Use of C</.+/> would have been insecure in theory because
it lets everything through, but Perl doesn't check for that.  The lesson
is that when untainting, you must be exceedingly careful with your patterns.
Laundering data using regular expression is the I<ONLY> mechanism for
untainting dirty data, unless you use the strategy detailed below to fork
a child of lesser privilege.

The example does not untaint $data if C<use locale> is in effect,
because the characters matched by C<\w> are determined by the locale.
Perl considers that locale definitions are untrustworthy because they
contain data from outside the program.  If you are writing a
locale-aware program, and want to launder data with a regular expression
containing C<\w>, put C<no locale> ahead of the expression in the same
block.  See L<perllocale/SECURITY> for further discussion and examples.

=head2 Switches On the "#!" Line

When you make a script executable, in order to make it usable as a
command, the system will pass switches to perl from the script's #!
line.  Perl checks that any command line switches given to a setuid
(or setgid) script actually match the ones set on the #! line.  Some
Unix and Unix-like environments impose a one-switch limit on the #!
line, so you may need to use something like C<-wU> instead of C<-w -U>
under such systems.  (This issue should arise only in Unix or
Unix-like environments that support #! and setuid or setgid scripts.)

=head2 Cleaning Up Your Path

For "Insecure C<$ENV{PATH}>" messages, you need to set C<$ENV{'PATH'}> to a
known value, and each directory in the path must be non-writable by others
than its owner and group.  You may be surprised to get this message even
if the pathname to your executable is fully qualified.  This is I<not>
generated because you didn't supply a full path to the program; instead,
it's generated because you never set your PATH environment variable, or
you didn't set it to something that was safe.  Because Perl can't
guarantee that the executable in question isn't itself going to turn
around and execute some other program that is dependent on your PATH, it
makes sure you set the PATH.

The PATH isn't the only environment variable which can cause problems.
Because some shells may use the variables IFS, CDPATH, ENV, and
BASH_ENV, Perl checks that those are either empty or untainted when
starting subprocesses. You may wish to add something like this to your
setid and taint-checking scripts.

    delete @@ENV{qw(IFS CDPATH ENV BASH_ENV)};   # Make %ENV safer
d122 2
a123 2
opens and such B<after> properly dropping any special user (or group!)
privileges. Perl doesn't prevent you from opening tainted filenames for reading,
d127 5
a131 23
Perl does not call the shell to expand wild cards when you pass B<system>
and B<exec> explicit parameter lists instead of strings with possible shell
wildcards in them.  Unfortunately, the B<open>, B<glob>, and
backtick functions provide no such alternate calling convention, so more
subterfuge will be required.

Perl provides a reasonably safe way to open a file or pipe from a setuid
or setgid program: just create a child process with reduced privilege who
does the dirty work for you.  First, fork a child using the special
B<open> syntax that connects the parent and child by a pipe.  Now the
child resets its ID set and any other per-process attributes, like
environment variables, umasks, current working directories, back to the
originals or known safe values.  Then the child process, which no longer
has any special permissions, does the B<open> or other system call.
Finally, the child passes the data it managed to access back to the
parent.  Because the file or pipe was opened in the child while running
under less privilege than the parent, it's not apt to be tricked into
doing something it shouldn't.

Here's a way to do backticks reasonably safely.  Notice how the B<exec> is
not called with a string that the shell could expand.  This is by far the
best way to call something that might be subjected to shell escapes: just
never call the shell at all.  
d133 1
a133 2
    use English;
    die "Can't fork: $!" unless defined $pid = open(KID, "-|");
d137 1
a137 1
	}
d140 5
a144 124
	my @@temp = ($EUID, $EGID);
	$EUID = $UID;
	$EGID = $GID;    # 	initgroups() also called!
	# Make sure privs are really gone
	($EUID, $EGID) = @@temp;
	die "Can't drop privileges" 
		unless $UID == $EUID  && $GID eq $EGID;	
	$ENV{PATH} = "/bin:/usr/bin";
	exec 'myprog', 'arg1', 'arg2' 
	    or die "can't exec myprog: $!";
    }

A similar strategy would work for wildcard expansion via C<glob>, although
you can use C<readdir> instead.

Taint checking is most useful when although you trust yourself not to have
written a program to give away the farm, you don't necessarily trust those
who end up using it not to try to trick it into doing something bad.  This
is the kind of security checking that's useful for set-id programs and
programs launched on someone else's behalf, like CGI programs.

This is quite different, however, from not even trusting the writer of the
code not to try to do something evil.  That's the kind of trust needed
when someone hands you a program you've never seen before and says, "Here,
run this."  For that kind of safety, check out the Safe module,
included standard in the Perl distribution.  This module allows the
programmer to set up special compartments in which all system operations
are trapped and namespace access is carefully controlled.

=head2 Security Bugs

Beyond the obvious problems that stem from giving special privileges to
systems as flexible as scripts, on many versions of Unix, set-id scripts
are inherently insecure right from the start.  The problem is a race
condition in the kernel.  Between the time the kernel opens the file to
see which interpreter to run and when the (now-set-id) interpreter turns
around and reopens the file to interpret it, the file in question may have
changed, especially if you have symbolic links on your system.

Fortunately, sometimes this kernel "feature" can be disabled.
Unfortunately, there are two ways to disable it.  The system can simply
outlaw scripts with any set-id bit set, which doesn't help much.
Alternately, it can simply ignore the set-id bits on scripts.  If the
latter is true, Perl can emulate the setuid and setgid mechanism when it
notices the otherwise useless setuid/gid bits on Perl scripts.  It does
this via a special executable called B<suidperl> that is automatically
invoked for you if it's needed.

However, if the kernel set-id script feature isn't disabled, Perl will
complain loudly that your set-id script is insecure.  You'll need to
either disable the kernel set-id script feature, or put a C wrapper around
the script.  A C wrapper is just a compiled program that does nothing
except call your Perl program.   Compiled programs are not subject to the
kernel bug that plagues set-id scripts.  Here's a simple wrapper, written
in C:

    #define REAL_PATH "/path/to/script"
    main(ac, av)
	char **av;
    {
	execv(REAL_PATH, av);
    }

Compile this wrapper into a binary executable and then make I<it> rather
than your script setuid or setgid.

See the program B<wrapsuid> in the F<eg> directory of your Perl
distribution for a convenient way to do this automatically for all your
setuid Perl programs.  It moves setuid scripts into files with the same
name plus a leading dot, and then compiles a wrapper like the one above
for each of them.

In recent years, vendors have begun to supply systems free of this
inherent security bug.  On such systems, when the kernel passes the name
of the set-id script to open to the interpreter, rather than using a
pathname subject to meddling, it instead passes I</dev/fd/3>.  This is a
special file already opened on the script, so that there can be no race
condition for evil scripts to exploit.  On these systems, Perl should be
compiled with C<-DSETUID_SCRIPTS_ARE_SECURE_NOW>.  The B<Configure>
program that builds Perl tries to figure this out for itself, so you
should never have to specify this yourself.  Most modern releases of
SysVr4 and BSD 4.4 use this approach to avoid the kernel race condition.

Prior to release 5.003 of Perl, a bug in the code of B<suidperl> could
introduce a security hole in systems compiled with strict POSIX
compliance.

=head2 Protecting Your Programs

There are a number of ways to hide the source to your Perl programs,
with varying levels of "security".

First of all, however, you I<can't> take away read permission, because
the source code has to be readable in order to be compiled and
interpreted.  (That doesn't mean that a CGI script's source is
readable by people on the web, though.)  So you have to leave the
permissions at the socially friendly 0755 level.  This lets 
people on your local system only see your source.

Some people mistakenly regard this as a security problem.  If your program does
insecure things, and relies on people not knowing how to exploit those
insecurities, it is not secure.  It is often possible for someone to
determine the insecure things and exploit them without viewing the
source.  Security through obscurity, the name for hiding your bugs
instead of fixing them, is little security indeed.

You can try using encryption via source filters (Filter::* from CPAN).
But crackers might be able to decrypt it.  You can try using the
byte code compiler and interpreter described below, but crackers might
be able to de-compile it.  You can try using the native-code compiler
described below, but crackers might be able to disassemble it.  These
pose varying degrees of difficulty to people wanting to get at your
code, but none can definitively conceal it (this is true of every
language, not just Perl).

If you're concerned about people profiting from your code, then the
bottom line is that nothing but a restrictive licence will give you
legal security.  License your software and pepper it with threatening
statements like "This is unpublished proprietary software of XYZ Corp.
Your access to it does not give you permission to use it blah blah
blah."  You should see a lawyer to be sure your licence's wording will
stand up in court.

=head1 SEE ALSO
d146 2
a147 1
L<perlrun> for its description of cleaning up environment variables.
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d35 11
a45 13
L<perllocale>), results of certain system calls (readdir(),
readlink(), the variable of shmread(), the messages returned by
msgrcv(), the password, gcos and shell fields returned by the
getpwxxx() calls), and all file input are marked as "tainted".
Tainted data may not be used directly or indirectly in any command
that invokes a sub-shell, nor in any command that modifies files,
directories, or processes. (B<Important exception>: If you pass a list
of arguments to either C<system> or C<exec>, the elements of that list
are B<NOT> checked for taintedness.) Any variable set to a value
derived from tainted data will itself be tainted, even if it is
logically impossible for the tainted data to alter the variable.
Because taintedness is associated with each scalar value, some
elements of an array can be tainted and others not.
d87 2
a88 2
    @@files = <*.c>;		# insecure (uses readdir() or similar)
    @@files = glob('*.c');	# insecure (uses readdir() or similar)
d142 1
a142 1
Laundering data using regular expression is the I<only> mechanism for
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d41 3
a43 16
directories, or processes, B<with the following exceptions>:

=over 4

=item *

If you pass a list of arguments to either C<system> or C<exec>,
the elements of that list are B<not> checked for taintedness.

=item *

Arguments to C<print> and C<syswrite> are B<not> checked for taintedness.

=back

Any variable set to a value
d220 19
a238 25
        use English;
        die "Can't fork: $!" unless defined($pid = open(KID, "-|"));
        if ($pid) {           # parent
            while (<KID>) {
                # do something
            }
            close KID;
        } else {
            my @@temp     = ($EUID, $EGID);
            my $orig_uid = $UID;
            my $orig_gid = $GID;
            $EUID = $UID;
            $EGID = $GID;
            # Drop privileges
            $UID  = $orig_uid;
            $GID  = $orig_gid;
            # Make sure privs are really gone
            ($EUID, $EGID) = @@temp;
            die "Can't drop privileges"
                unless $UID == $EUID  && $GID eq $EGID;
            $ENV{PATH} = "/bin:/usr/bin"; # Minimal PATH.
	    # Consider sanitizing the environment even more.
            exec 'myprog', 'arg1', 'arg2'
                or die "can't exec myprog: $!";
        }
d294 6
d311 3
a313 2
Prior to release 5.6.1 of Perl, bugs in the code of B<suidperl> could
introduce a security hole.
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d47 2
a48 5
If you pass more than one argument to either C<system> or C<exec>,
the arguments are checked for taintedness B<but> the operation will still
be attempted, emitting an optional warning.  This will be fatal in a 
future version of perl so do not rely on it to bypass the tainting 
mechanism.
a53 17
=item *

Symbolic methods

    $obj->$method(@@args);

and symbolic sub references

    &{$foo}(@@args);
    $foo->(@@args);

are not checked for taintedness.  This requires extra carefulness
unless you want external data to affect your control flow.  Unless
you carefully limit what these symbolic values are, people are able
to call functions B<outside> your Perl code, such as POSIX::system,
in which case they are able to run arbitrary external code.

d56 3
a58 4
The value of an expression containing tainted data will itself be
tainted, even if it is logically impossible for the tainted data to
affect the value.

d74 1
a74 2
    system "/bin/echo", $arg;	# Allowed but considered insecure
				# (Perl doesn't know about /bin/echo)
d89 1
a89 1
    open(FOO,"echo $arg|");	# Not OK
d91 1
a91 1
	or exec 'echo', $arg;	# Allowed but not really OK
d99 1
a99 1
    exec "echo", $arg;		# Allowed but considered insecure
a104 8
    # In Perl releases older than 5.6.0 the <*.c> and glob('*.c') would
    # have used an external program to do the filename expansion; but in
    # either case the result is tainted since the list of filenames comes
    # from outside of the program.

    $bad = ($arg, 23);		# $bad will be tainted
    $arg, `true`;		# Insecure (although it isn't really)

d108 1
a108 2
doing something like the "considered secure" example above.  This will not
be possible in a future version of Perl.
d112 4
a115 5
To test whether a variable contains tainted data, and whose use would
thus trigger an "Insecure dependency" message, you can use the
tainted() function of the Scalar::Util module, available in your
nearby CPAN mirror, and included in Perl starting from the release 5.8.0.
Or you may be able to use the following I<is_tainted()> function.
d118 4
a121 1
        return ! eval { eval("#" . substr(join("", @@_), 0, 0)); 1 };
d233 1
a233 1
        use English '-no_match_vars';
d346 4
a349 5
You can try using encryption via source filters (Filter::* from CPAN,
or Filter::Util::Call and Filter::Simple since Perl 5.8).
But crackers might be able to decrypt it.  You can try using the byte
code compiler and interpreter described below, but crackers might be
able to de-compile it.  You can try using the native-code compiler
a361 7

=head2 Unicode

Unicode is a new and complex technology and one may easily overlook
certain security pitfalls.  See L<perluniintro> for an overview and
L<perlunicode> for details, and L<perlunicode/"Security Implications
of Unicode"> for security implications in particular.
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d47 8
d95 1
a95 1
    system "/bin/echo", $arg;	# Considered insecure
d113 1
a113 1
	or exec 'echo', $arg;	# Also not OK
d121 2
a122 2
    exec "echo", $arg;		# Insecure
    exec "sh", '-c', $arg;	# Very insecure!
d136 4
a139 1
something like "Insecure dependency" or "Insecure $ENV{PATH}".
d178 1
a178 1
	die "Bad data in '$data'"; 	# log this somewhere
a398 69

=head2 Algorithmic Complexity Attacks

Certain internal algorithms used in the implementation of Perl can
be attacked by choosing the input carefully to consume large amounts
of either time or space or both.  This can lead into the so-called
I<Denial of Service> (DoS) attacks.

=over 4

=item *

Hash Function - the algorithm used to "order" hash elements has been
changed several times during the development of Perl, mainly to be
reasonably fast.  In Perl 5.8.1 also the security aspect was taken
into account.

In Perls before 5.8.1 one could rather easily generate data that as
hash keys would cause Perl to consume large amounts of time because
internal structure of hashes would badly degenerate.  In Perl 5.8.1
the hash function is randomly perturbed by a pseudorandom seed which
makes generating such naughty hash keys harder.
See L<perlrun/PERL_HASH_SEED> for more information.

The random perturbation is done by default but if one wants for some
reason emulate the old behaviour one can set the environment variable
PERL_HASH_SEED to zero (or any other integer).  One possible reason
for wanting to emulate the old behaviour is that in the new behaviour
consecutive runs of Perl will order hash keys differently, which may
confuse some applications (like Data::Dumper: the outputs of two
different runs are no more identical).

B<Perl has never guaranteed any ordering of the hash keys>, and the
ordering has already changed several times during the lifetime of
Perl 5.  Also, the ordering of hash keys has always been, and
continues to be, affected by the insertion order.

Also note that while the order of the hash elements might be
randomised, this "pseudoordering" should B<not> be used for
applications like shuffling a list randomly (use List::Util::shuffle()
for that, see L<List::Util>, a standard core module since Perl 5.8.0;
or the CPAN module Algorithm::Numerical::Shuffle), or for generating
permutations (use e.g. the CPAN modules Algorithm::Permute or
Algorithm::FastPermute), or for any cryptographic applications.

=item *

Regular expressions - Perl's regular expression engine is so called
NFA (Non-Finite Automaton), which among other things means that it can
rather easily consume large amounts of both time and space if the
regular expression may match in several ways.  Careful crafting of the
regular expressions can help but quite often there really isn't much
one can do (the book "Mastering Regular Expressions" is required
reading, see L<perlfaq2>).  Running out of space manifests itself by
Perl running out of memory.

=item *

Sorting - the quicksort algorithm used in Perls before 5.8.0 to
implement the sort() function is very easy to trick into misbehaving
so that it consumes a lot of time.  Nothing more is required than
resorting a list already sorted.  Starting from Perl 5.8.0 a different
sorting algorithm, mergesort, is used.  Mergesort is insensitive to
its input data, so it cannot be similarly fooled.

=back

See L<http://www.cs.rice.edu/~scrosby/hash/> for more information,
and any computer science text book on the algorithmic complexity.
@


1.1.1.7
log
@perl 5.8.3 from CPAN
@
text
@d68 3
a70 4
For efficiency reasons, Perl takes a conservative view of
whether data is tainted.  If an expression contains tainted data,
any subexpression may be considered tainted, even if the value
of the subexpression is not itself affected by the tainted data.
d73 1
a73 2
elements of an array or hash can be tainted and others not.
The keys of a hash are never tainted.
d136 1
a136 1
Or you may be able to use the following C<is_tainted()> function.
d150 1
a150 2
to clear your data's taintedness.  Values may be untainted by using them
as keys in a hash; otherwise the only way to bypass the tainting
a196 20

=head2 Taint mode and @@INC

When the taint mode (C<-T>) is in effect, the "." directory is removed
from C<@@INC>, and the environment variables C<PERL5LIB> and C<PERLLIB>
are ignored by Perl. You can still adjust C<@@INC> from outside the
program by using the C<-I> command line option as explained in
L<perlrun>. The two environment variables are ignored because
they are obscured, and a user running a program could be unaware that
they are set, whereas the C<-I> option is clearly visible and
therefore permitted.

Another way to modify C<@@INC> without modifying the program, is to use
the C<lib> pragma, e.g.:

  perl -Mlib=/foo program

The benefit of using C<-Mlib=/foo> over C<-I/foo>, is that the former
will automagically remove any duplicated directories, while the later
will not.
@


1.1.1.8
log
@perl 5.8.6 from CPAN
@
text
@d35 4
a38 4
L<perllocale>), results of certain system calls (C<readdir()>,
C<readlink()>, the variable of C<shmread()>, the messages returned by
C<msgrcv()>, the password, gcos and shell fields returned by the
C<getpwxxx()> calls), and all file input are marked as "tainted".
a131 16
The exception to the principle of "one tainted value taints the whole
expression" is with the ternary conditional operator C<?:>.  Since code
with a ternary conditional

    $result = $tainted_value ? "Untainted" : "Also untainted";

is effectively

    if ( $tainted_value ) {
        $result = "Untainted";
    } else {
        $result = "Also untainted";
    }

it doesn't make sense for C<$result> to be tainted.

d136 1
a136 1
C<tainted()> function of the Scalar::Util module, available in your
d182 1
a182 1
The example does not untaint C<$data> if C<use locale> is in effect,
d223 10
a232 10
For "Insecure C<$ENV{PATH}>" messages, you need to set C<$ENV{'PATH'}> to
a known value, and each directory in the path must be absolute and
non-writable by others than its owner and group.  You may be surprised to
get this message even if the pathname to your executable is fully
qualified.  This is I<not> generated because you didn't supply a full path
to the program; instead, it's generated because you never set your PATH
environment variable, or you didn't set it to something that was safe.
Because Perl can't guarantee that the executable in question isn't itself
going to turn around and execute some other program that is dependent on
your PATH, it makes sure you set the PATH.
d250 3
a252 3
Perl does not call the shell to expand wild cards when you pass C<system>
and C<exec> explicit parameter lists instead of strings with possible shell
wildcards in them.  Unfortunately, the C<open>, C<glob>, and
d259 1
a259 1
C<open> syntax that connects the parent and child by a pipe.  Now the
d263 1
a263 1
has any special permissions, does the C<open> or other system call.
d269 1
a269 1
Here's a way to do backticks reasonably safely.  Notice how the C<exec> is
d333 1
a333 1
this via a special executable called F<suidperl> that is automatically
d360 1
a360 1
compiled with C<-DSETUID_SCRIPTS_ARE_SECURE_NOW>.  The F<Configure>
d365 1
a365 1
Prior to release 5.6.1 of Perl, bugs in the code of F<suidperl> could
@


1.1.1.9
log
@perl 5.8.8 import
@
text
@a236 5
Note that if a tainted string is added to C<@@INC>, the following
problem will be reported:

  Insecure dependency in require while running with -T switch

@


1.1.1.10
log
@import perl 5.10.0 from CPAN
@
text
@a65 4
=item *

Hash keys are B<never> tainted.

d75 1
a75 1
The keys of a hash are B<never> tainted.
d479 3
a481 3
Regular expressions - Perl's regular expression engine is so called NFA
(Non-deterministic Finite Automaton), which among other things means that
it can rather easily consume large amounts of both time and space if the
d500 1
a500 1
and any computer science textbook on the algorithmic complexity.
@


1.1.1.11
log
@import perl 5.10.1
@
text
@a14 12
=head1 SECURITY VULNERABILITY CONTACT INFORMATION

If you believe you have found a security vulnerability in Perl, please email
perl5-security-report@@perl.org with details.  This points to a closed
subscription, unarchived mailing list.  Please only use this address for
security issues in the Perl core, not for modules independently distributed on
CPAN.

=head1 SECURITY MECHANISMS AND CONCERNS

=head2 Taint mode

d361 1
a361 5
B<The use of suidperl is considered deprecated>, and will be removed
in Perl 5.12.0.  It is I<strongly> recommended that all code uses
the simplier and more secure C-wrappers described below.

If the kernel set-id script feature isn't disabled, Perl will
d391 1
a391 2
introduce a security hole.  The use of F<suidperl> is considered
deprecated, and will be removed in Perl 5.12.0.
d423 1
a423 1
bottom line is that nothing but a restrictive license will give you
d427 1
a427 1
blah."  You should see a lawyer to be sure your license's wording will
d460 7
a466 10
In Perl 5.8.1 the random perturbation was done by default, but as of
5.8.2 it is only used on individual hashes if the internals detect the
insertion of pathological data. If one wants for some reason emulate the
old behaviour (and expose oneself to DoS attacks) one can set the
environment variable PERL_HASH_SEED to zero to disable the protection
(or any other integer to force a known perturbation, rather than random). 
One possible reason for wanting to emulate the old behaviour is that in the
new behaviour consecutive runs of Perl will order hash keys differently,
which may confuse some applications (like Data::Dumper: the outputs of two
different runs are no longer identical).
d496 4
a499 3
so that it consumes a lot of time.  Starting from Perl 5.8.0 a different
sorting algorithm, mergesort, is used by default.  Mergesort cannot
misbehave on any input.
d504 1
a504 1
and any computer science textbook on algorithmic complexity.
@


1.1.1.12
log
@Perl 5.12.2 from CPAN
@
text
@d349 2
a350 2
run this."  For that kind of safety, you might want to check out the Safe
module, included standard in the Perl distribution.  This module allows the
d352 1
a352 6
are trapped and namespace access is carefully controlled.  Safe should
not be considered bullet-proof, though: it will not prevent the foreign
code to set up infinite loops, allocate gigabytes of memory, or even
abusing perl bugs to make the host interpreter crash or behave in
unpredictable ways. In any case it's better avoided completely if you're
really concerned about security.
d367 9
a375 1
Alternately, it can simply ignore the set-id bits on scripts.
d377 1
a377 1
However, if the kernel set-id script feature isn't disabled, Perl will
d405 4
@


1.1.1.13
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a172 1
        local $@@;   # Don't pollute caller's value.
@


1.1.1.14
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d96 1
a96 1
    $hid = $arg . 'bar';	# $hid is also tainted
d137 4
a140 2
    # In either case, the results of glob are tainted, since the list of
    # filenames comes from outside of the program.
d459 27
a485 70
Hash Algorithm - Hash algorithms like the one used in Perl are well
known to be vulnerable to collision attacks on their hash function.
Such attacks involve constructing a set of keys which collide into
the same bucket producing inefficient behavior. Such attacks often
depend on discovering the seed of the hash function used to map the
keys to buckets. That seed is then used to brute-force a key set which
can be used to mount a denial of service attack. In Perl 5.8.1 changes
were introduced to harden Perl to such attacks, and then later in
Perl 5.18.0 these features were enhanced and additional protections
added.

At the time of this writing, Perl 5.18.0 is considered to be
well-hardened against algorithmic complexity attacks on its hash
implementation. This is largely owed to the following measures
mitigate attacks:

=over 4

=item Hash Seed Randomization

In order to make it impossible to know what seed to generate an attack
key set for, this seed is randomly initialized at process start. This
may be overridden by using the PERL_HASH_SEED environment variable, see
L<perlrun/PERL_HASH_SEED>. This environment variable controls how
items are actually stored, not how they are presented via
C<keys>, C<values> and C<each>.

=item Hash Traversal Randomization

Independent of which seed is used in the hash function, C<keys>,
C<values>, and C<each> return items in a per-hash randomized order.
Modifying a hash by insertion will change the iteration order of that hash.
This behavior can be overridden by using C<hash_traversal_mask()> from
L<Hash::Util> or by using the PERL_PERTURB_KEYS environment variable,
see L<perlrun/PERL_PERTURB_KEYS>. Note that this feature controls the
"visible" order of the keys, and not the actual order they are stored in.

=item Bucket Order Perturbance

When items collide into a given hash bucket the order they are stored in
the chain is no longer predictable in Perl 5.18. This has the intention
to make it harder to observe a collisions. This behavior can be overridden by using
the PERL_PERTURB_KEYS environment variable, see L<perlrun/PERL_PERTURB_KEYS>.

=item New Default Hash Function

The default hash function has been modified with the intention of making
it harder to infer the hash seed.

=item Alternative Hash Functions

The source code includes multiple hash algorithms to choose from.  While we
believe that the default perl hash is robust to attack, we have included the
hash function Siphash as a fall-back option. At the time of release of
Perl 5.18.0 Siphash is believed to be of cryptographic strength.  This is
not the default as it is much slower than the default hash.

=back

Without compiling a special Perl, there is no way to get the exact same
behavior of any versions prior to Perl 5.18.0. The closest one can get
is by setting PERL_PERTURB_KEYS to 0 and setting the PERL_HASH_SEED
to a known value. We do not advise those settings for production use
due to the above security considerations.

B<Perl has never guaranteed any ordering of the hash keys>, and
the ordering has already changed several times during the lifetime of
Perl 5.  Also, the ordering of hash keys has always been, and continues
to be, affected by the insertion order and the history of changes made
to the hash over its lifetime.
d488 2
a489 2
randomized, this "pseudo-ordering" should B<not> be used for
applications like shuffling a list randomly (use C<List::Util::shuffle()>
d491 3
a493 3
or the CPAN module C<Algorithm::Numerical::Shuffle>), or for generating
permutations (use e.g. the CPAN modules C<Algorithm::Permute> or
C<Algorithm::FastPermute>), or for any cryptographic applications.
@


1.1.1.15
log
@Import perl-5.20.1
@
text
@d186 2
a187 3
Perl presumes that if you reference a substring using $1, $2, etc. in a
non-tainting pattern, that
you knew what you were doing when you wrote that pattern.  That means using
d310 1
a310 1
        use English;
a534 3

Tied hashes may have their own ordering and algorithmic complexity
attacks.
@


1.1.1.16
log
@Import perl-5.20.2
@
text
@d31 1
a31 1
mode explicitly by using the B<-T> command line flag.  This flag is
d33 1
a33 1
someone else, such as a CGI script.  Once taint mode is on, it's on for
d237 1
a237 1
are ignored by Perl.  You can still adjust C<@@INC> from outside the
d239 1
a239 1
L<perlrun>.  The two environment variables are ignored because
d250 1
a250 1
will automagically remove any duplicated directories, while the latter
d274 1
a274 1
starting subprocesses.  You may wish to add something like this to your
d283 1
a283 2
privileges.  Perl doesn't prevent you from
opening tainted filenames for reading,
d356 1
a356 1
unpredictable ways.  In any case it's better avoided completely if you're
d461 1
a461 1
the same bucket producing inefficient behavior.  Such attacks often
d463 2
a464 2
keys to buckets.  That seed is then used to brute-force a key set which
can be used to mount a denial of service attack.  In Perl 5.8.1 changes
d471 1
a471 1
implementation.  This is largely owed to the following measures
d479 1
a479 1
key set for, this seed is randomly initialized at process start.  This
d481 1
a481 1
L<perlrun/PERL_HASH_SEED>.  This environment variable controls how
d492 1
a492 1
see L<perlrun/PERL_PERTURB_KEYS>.  Note that this feature controls the
d498 2
a499 3
the chain is no longer predictable in Perl 5.18.  This
has the intention to make it harder to observe a
collision.  This behavior can be overridden by using
d511 1
a511 1
hash function Siphash as a fall-back option.  At the time of release of
d518 1
a518 1
behavior of any versions prior to Perl 5.18.0.  The closest one can get
d520 1
a520 1
to a known value.  We do not advise those settings for production use
@


1.1.1.17
log
@Import perl-5.24.2
@
text
@d17 5
a21 18
If you believe you have found a security vulnerability in Perl, please
email the details to perl5-security-report@@perl.org. This creates a new
Request Tracker ticket in a special queue which isn't initially publicly
accessible. The email will also be copied to a closed subscription
unarchived mailing list which includes all the core committers, who will
be able to help assess the impact of issues, figure out a resolution, and
help co-ordinate the release of patches to mitigate or fix the problem
across all platforms on which Perl is supported. Please only use this
address for security issues in the Perl core, not for modules
independently distributed on CPAN.

When sending an initial request to the security email address, please
don't Cc any other parties, because if they reply to all, the reply will
generate yet another new ticket. Once you have received an initial reply
with a C<[perl #NNNNNN]> ticket number in  the headline, it's okay to Cc
subsequent replies to third parties: all emails to the
perl5-security-report address with the ticket number in the subject line
will be added to the ticket; without it, a new ticket will be created.
@


