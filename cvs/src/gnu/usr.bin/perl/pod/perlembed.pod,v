head	1.16;
access;
symbols
	OPENBSD_6_2_BASE:1.16
	PERL_5_24_2:1.1.1.15
	OPENBSD_6_1:1.16.0.4
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.15.0.10
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.4
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.6
	OPENBSD_5_8_BASE:1.15
	PERL_5_20_2:1.1.1.14
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	PERL_5_20_1:1.1.1.14
	OPENBSD_5_6:1.14.0.4
	OPENBSD_5_6_BASE:1.14
	PERL_5_18_2:1.1.1.13
	PERL:1.1.1
	OPENBSD_5_5:1.13.0.6
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	PERL_5_16_3:1.1.1.12
	OPENBSD_5_3:1.12.0.10
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.8
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.6
	OPENBSD_5_0:1.12.0.4
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	PERL_5_12_2:1.1.1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	PERL_5_10_1:1.1.1.10
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	PERL_5_10_0:1.1.1.9
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	PERL_5_8_8:1.1.1.8
	OPENBSD_3_9:1.8.0.8
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.6
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	PERL_5_8_6:1.1.1.7
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.16
date	2017.02.05.00.32.18;	author afresh1;	state Exp;
branches;
next	1.15;
commitid	cxJ08BvJA9Pt2PTM;

1.15
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.14;
commitid	QP75iYx42Uo7mMxO;

1.14
date	2014.03.24.15.05.32;	author afresh1;	state Exp;
branches;
next	1.13;

1.13
date	2013.03.25.20.40.58;	author sthen;	state Exp;
branches;
next	1.12;

1.12
date	2010.09.24.15.07.03;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.12.18.24.47;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.29.17.36.16;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.28.19.23.10;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.07.21.33.08;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.44;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.32;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.35.53;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.07.24;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.10;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.59.06;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.59;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.59;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.40.40;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.22;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.24.33;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.04;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.21;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.04.07.21.13.32;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2006.03.28.18.49.17;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2008.09.29.17.18.51;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2009.10.12.18.10.38;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2010.09.24.14.49.08;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2013.03.25.20.09.19;	author sthen;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2014.03.24.14.59.07;	author afresh1;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.11.17.20.53.13;	author afresh1;	state Exp;
branches;
next	1.1.1.15;
commitid	B31cAbBIXiCqnL97;

1.1.1.15
date	2017.08.14.13.46.19;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.16
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@=head1 NAME

perlembed - how to embed perl in your C program

=head1 DESCRIPTION

=head2 PREAMBLE

Do you want to:

=over 5

=item B<Use C from Perl?>

Read L<perlxstut>, L<perlxs>, L<h2xs>, L<perlguts>, and L<perlapi>.

=item B<Use a Unix program from Perl?>

Read about back-quotes and about C<system> and C<exec> in L<perlfunc>.

=item B<Use Perl from Perl?>

Read about L<perlfunc/do> and L<perlfunc/eval> and L<perlfunc/require>
and L<perlfunc/use>.

=item B<Use C from C?>

Rethink your design.

=item B<Use Perl from C?>

Read on...

=back

=head2 ROADMAP

=over 5

=item *

Compiling your C program

=item *

Adding a Perl interpreter to your C program

=item *

Calling a Perl subroutine from your C program

=item *

Evaluating a Perl statement from your C program

=item *

Performing Perl pattern matches and substitutions from your C program

=item *

Fiddling with the Perl stack from your C program

=item *

Maintaining a persistent interpreter

=item *

Maintaining multiple interpreter instances

=item *

Using Perl modules, which themselves use C libraries, from your C program

=item *

Embedding Perl under Win32

=back

=head2 Compiling your C program

If you have trouble compiling the scripts in this documentation,
you're not alone.  The cardinal rule: COMPILE THE PROGRAMS IN EXACTLY
THE SAME WAY THAT YOUR PERL WAS COMPILED.  (Sorry for yelling.)

Also, every C program that uses Perl must link in the I<perl library>.
What's that, you ask?  Perl is itself written in C; the perl library
is the collection of compiled C programs that were used to create your
perl executable (I</usr/bin/perl> or equivalent).  (Corollary: you
can't use Perl from your C program unless Perl has been compiled on
your machine, or installed properly--that's why you shouldn't blithely
copy Perl executables from machine to machine without also copying the
I<lib> directory.)

When you use Perl from C, your C program will--usually--allocate,
"run", and deallocate a I<PerlInterpreter> object, which is defined by
the perl library.

If your copy of Perl is recent enough to contain this documentation
(version 5.002 or later), then the perl library (and I<EXTERN.h> and
I<perl.h>, which you'll also need) will reside in a directory
that looks like this:

    /usr/local/lib/perl5/your_architecture_here/CORE

or perhaps just

    /usr/local/lib/perl5/CORE

or maybe something like

    /usr/opt/perl5/CORE

Execute this statement for a hint about where to find CORE:

    perl -MConfig -e 'print $Config{archlib}'

Here's how you'd compile the example in the next section,
L<Adding a Perl interpreter to your C program>, on my Linux box:

    % gcc -O2 -Dbool=char -DHAS_BOOL -I/usr/local/include
    -I/usr/local/lib/perl5/i586-linux/5.003/CORE
    -L/usr/local/lib/perl5/i586-linux/5.003/CORE
    -o interp interp.c -lperl -lm

(That's all one line.)  On my DEC Alpha running old 5.003_05, the
incantation is a bit different:

    % cc -O2 -Olimit 2900 -DSTANDARD_C -I/usr/local/include
    -I/usr/local/lib/perl5/alpha-dec_osf/5.00305/CORE
    -L/usr/local/lib/perl5/alpha-dec_osf/5.00305/CORE -L/usr/local/lib
    -D__LANGUAGE_C__ -D_NO_PROTO -o interp interp.c -lperl -lm

How can you figure out what to add?  Assuming your Perl is post-5.001,
execute a C<perl -V> command and pay special attention to the "cc" and
"ccflags" information.

You'll have to choose the appropriate compiler (I<cc>, I<gcc>, et al.) for
your machine: C<perl -MConfig -e 'print $Config{cc}'> will tell you what
to use.

You'll also have to choose the appropriate library directory
(I</usr/local/lib/...>) for your machine.  If your compiler complains
that certain functions are undefined, or that it can't locate
I<-lperl>, then you need to change the path following the C<-L>.  If it
complains that it can't find I<EXTERN.h> and I<perl.h>, you need to
change the path following the C<-I>.

You may have to add extra libraries as well.  Which ones?
Perhaps those printed by

   perl -MConfig -e 'print $Config{libs}'

Provided your perl binary was properly configured and installed the
B<ExtUtils::Embed> module will determine all of this information for
you:

   % cc -o interp interp.c `perl -MExtUtils::Embed -e ccopts -e ldopts`

If the B<ExtUtils::Embed> module isn't part of your Perl distribution,
you can retrieve it from
http://www.perl.com/perl/CPAN/modules/by-module/ExtUtils/
(If this documentation came from your Perl distribution, then you're
running 5.004 or better and you already have it.)

The B<ExtUtils::Embed> kit on CPAN also contains all source code for
the examples in this document, tests, additional examples and other
information you may find useful.

=head2 Adding a Perl interpreter to your C program

In a sense, perl (the C program) is a good example of embedding Perl
(the language), so I'll demonstrate embedding with I<miniperlmain.c>,
included in the source distribution.  Here's a bastardized, non-portable
version of I<miniperlmain.c> containing the essentials of embedding:

 #include <EXTERN.h>               /* from the Perl distribution     */
 #include <perl.h>                 /* from the Perl distribution     */

 static PerlInterpreter *my_perl;  /***    The Perl interpreter    ***/

 int main(int argc, char **argv, char **env)
 {
	PERL_SYS_INIT3(&argc,&argv,&env);
        my_perl = perl_alloc();
        perl_construct(my_perl);
	PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
        perl_parse(my_perl, NULL, argc, argv, (char **)NULL);
        perl_run(my_perl);
        perl_destruct(my_perl);
        perl_free(my_perl);
	PERL_SYS_TERM();
 }

Notice that we don't use the C<env> pointer.  Normally handed to
C<perl_parse> as its final argument, C<env> here is replaced by
C<NULL>, which means that the current environment will be used.

The macros PERL_SYS_INIT3() and PERL_SYS_TERM() provide system-specific
tune up of the C runtime environment necessary to run Perl interpreters;
they should only be called once regardless of how many interpreters you
create or destroy. Call PERL_SYS_INIT3() before you create your first
interpreter, and PERL_SYS_TERM() after you free your last interpreter.

Since PERL_SYS_INIT3() may change C<env>, it may be more appropriate to
provide C<env> as an argument to perl_parse().

Also notice that no matter what arguments you pass to perl_parse(),
PERL_SYS_INIT3() must be invoked on the C main() argc, argv and env and
only once.

Now compile this program (I'll call it I<interp.c>) into an executable:

    % cc -o interp interp.c `perl -MExtUtils::Embed -e ccopts -e ldopts`

After a successful compilation, you'll be able to use I<interp> just
like perl itself:

    % interp
    print "Pretty Good Perl \n";
    print "10890 - 9801 is ", 10890 - 9801;
    <CTRL-D>
    Pretty Good Perl
    10890 - 9801 is 1089

or

    % interp -e 'printf("%x", 3735928559)'
    deadbeef

You can also read and execute Perl statements from a file while in the
midst of your C program, by placing the filename in I<argv[1]> before
calling I<perl_run>.

=head2 Calling a Perl subroutine from your C program

To call individual Perl subroutines, you can use any of the B<call_*>
functions documented in L<perlcall>.
In this example we'll use C<call_argv>.

That's shown below, in a program I'll call I<showtime.c>.

    #include <EXTERN.h>
    #include <perl.h>

    static PerlInterpreter *my_perl;

    int main(int argc, char **argv, char **env)
    {
        char *args[] = { NULL };
	PERL_SYS_INIT3(&argc,&argv,&env);
        my_perl = perl_alloc();
        perl_construct(my_perl);

        perl_parse(my_perl, NULL, argc, argv, NULL);
	PL_exit_flags |= PERL_EXIT_DESTRUCT_END;

        /*** skipping perl_run() ***/

        call_argv("showtime", G_DISCARD | G_NOARGS, args);

        perl_destruct(my_perl);
        perl_free(my_perl);
	PERL_SYS_TERM();
    }

where I<showtime> is a Perl subroutine that takes no arguments (that's the
I<G_NOARGS>) and for which I'll ignore the return value (that's the
I<G_DISCARD>).  Those flags, and others, are discussed in L<perlcall>.

I'll define the I<showtime> subroutine in a file called I<showtime.pl>:

 print "I shan't be printed.";

 sub showtime {
     print time;
 }

Simple enough. Now compile and run:

 % cc -o showtime showtime.c \
     `perl -MExtUtils::Embed -e ccopts -e ldopts`
 % showtime showtime.pl
 818284590

yielding the number of seconds that elapsed between January 1, 1970
(the beginning of the Unix epoch), and the moment I began writing this
sentence.

In this particular case we don't have to call I<perl_run>, as we set
the PL_exit_flag PERL_EXIT_DESTRUCT_END which executes END blocks in
perl_destruct.

If you want to pass arguments to the Perl subroutine, you can add
strings to the C<NULL>-terminated C<args> list passed to
I<call_argv>.  For other data types, or to examine return values,
you'll need to manipulate the Perl stack.  That's demonstrated in
L<Fiddling with the Perl stack from your C program>.

=head2 Evaluating a Perl statement from your C program

Perl provides two API functions to evaluate pieces of Perl code.
These are L<perlapi/eval_sv> and L<perlapi/eval_pv>.

Arguably, these are the only routines you'll ever need to execute
snippets of Perl code from within your C program.  Your code can be as
long as you wish; it can contain multiple statements; it can employ
L<perlfunc/use>, L<perlfunc/require>, and L<perlfunc/do> to
include external Perl files.

I<eval_pv> lets us evaluate individual Perl strings, and then
extract variables for coercion into C types.  The following program,
I<string.c>, executes three Perl strings, extracting an C<int> from
the first, a C<float> from the second, and a C<char *> from the third.

 #include <EXTERN.h>
 #include <perl.h>

 static PerlInterpreter *my_perl;

 main (int argc, char **argv, char **env)
 {
     char *embedding[] = { "", "-e", "0" };

     PERL_SYS_INIT3(&argc,&argv,&env);
     my_perl = perl_alloc();
     perl_construct( my_perl );

     perl_parse(my_perl, NULL, 3, embedding, NULL);
     PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
     perl_run(my_perl);

     /** Treat $a as an integer **/
     eval_pv("$a = 3; $a **= 2", TRUE);
     printf("a = %d\n", SvIV(get_sv("a", 0)));

     /** Treat $a as a float **/
     eval_pv("$a = 3.14; $a **= 2", TRUE);
     printf("a = %f\n", SvNV(get_sv("a", 0)));

     /** Treat $a as a string **/
     eval_pv(
       "$a = 'rekcaH lreP rehtonA tsuJ'; $a = reverse($a);", TRUE);
     printf("a = %s\n", SvPV_nolen(get_sv("a", 0)));

     perl_destruct(my_perl);
     perl_free(my_perl);
     PERL_SYS_TERM();
 }

All of those strange functions with I<sv> in their names help convert Perl
scalars to C types.  They're described in L<perlguts> and L<perlapi>.

If you compile and run I<string.c>, you'll see the results of using
I<SvIV()> to create an C<int>, I<SvNV()> to create a C<float>, and
I<SvPV()> to create a string:

   a = 9
   a = 9.859600
   a = Just Another Perl Hacker

In the example above, we've created a global variable to temporarily
store the computed value of our eval'ed expression.  It is also
possible and in most cases a better strategy to fetch the return value
from I<eval_pv()> instead.  Example:

   ...
   SV *val = eval_pv("reverse 'rekcaH lreP rehtonA tsuJ'", TRUE);
   printf("%s\n", SvPV_nolen(val));
   ...

This way, we avoid namespace pollution by not creating global
variables and we've simplified our code as well.

=head2 Performing Perl pattern matches and substitutions from your C program

The I<eval_sv()> function lets us evaluate strings of Perl code, so we can
define some functions that use it to "specialize" in matches and
substitutions: I<match()>, I<substitute()>, and I<matches()>.

   I32 match(SV *string, char *pattern);

Given a string and a pattern (e.g., C<m/clasp/> or C</\b\w*\b/>, which
in your C program might appear as "/\\b\\w*\\b/"), match()
returns 1 if the string matches the pattern and 0 otherwise.

   int substitute(SV **string, char *pattern);

Given a pointer to an C<SV> and an C<=~> operation (e.g.,
C<s/bob/robert/g> or C<tr[A-Z][a-z]>), substitute() modifies the string
within the C<SV> as according to the operation, returning the number of
substitutions made.

   SSize_t matches(SV *string, char *pattern, AV **matches);

Given an C<SV>, a pattern, and a pointer to an empty C<AV>,
matches() evaluates C<$string =~ $pattern> in a list context, and
fills in I<matches> with the array elements, returning the number of matches
found.

Here's a sample program, I<match.c>, that uses all three (long lines have
been wrapped here):

 #include <EXTERN.h>
 #include <perl.h>

 static PerlInterpreter *my_perl;

 /** my_eval_sv(code, error_check)
 ** kinda like eval_sv(),
 ** but we pop the return value off the stack
 **/
 SV* my_eval_sv(SV *sv, I32 croak_on_error)
 {
     dSP;
     SV* retval;


     PUSHMARK(SP);
     eval_sv(sv, G_SCALAR);

     SPAGAIN;
     retval = POPs;
     PUTBACK;

     if (croak_on_error && SvTRUE(ERRSV))
 	croak(SvPVx_nolen(ERRSV));

     return retval;
 }

 /** match(string, pattern)
 **
 ** Used for matches in a scalar context.
 **
 ** Returns 1 if the match was successful; 0 otherwise.
 **/

 I32 match(SV *string, char *pattern)
 {
     SV *command = newSV(0), *retval;

     sv_setpvf(command, "my $string = '%s'; $string =~ %s",
 	      SvPV_nolen(string), pattern);

     retval = my_eval_sv(command, TRUE);
     SvREFCNT_dec(command);

     return SvIV(retval);
 }

 /** substitute(string, pattern)
 **
 ** Used for =~ operations that
 ** modify their left-hand side (s/// and tr///)
 **
 ** Returns the number of successful matches, and
 ** modifies the input string if there were any.
 **/

 I32 substitute(SV **string, char *pattern)
 {
     SV *command = newSV(0), *retval;

     sv_setpvf(command, "$string = '%s'; ($string =~ %s)",
 	      SvPV_nolen(*string), pattern);

     retval = my_eval_sv(command, TRUE);
     SvREFCNT_dec(command);

     *string = get_sv("string", 0);
     return SvIV(retval);
 }

 /** matches(string, pattern, matches)
 **
 ** Used for matches in a list context.
 **
 ** Returns the number of matches,
 ** and fills in **matches with the matching substrings
 **/

 SSize_t matches(SV *string, char *pattern, AV **match_list)
 {
     SV *command = newSV(0);
     SSize_t num_matches;

     sv_setpvf(command, "my $string = '%s'; @@array = ($string =~ %s)",
 	      SvPV_nolen(string), pattern);

     my_eval_sv(command, TRUE);
     SvREFCNT_dec(command);

     *match_list = get_av("array", 0);
     num_matches = av_top_index(*match_list) + 1;

     return num_matches;
 }

 main (int argc, char **argv, char **env)
 {
     char *embedding[] = { "", "-e", "0" };
     AV *match_list;
     I32 num_matches, i;
     SV *text;

     PERL_SYS_INIT3(&argc,&argv,&env);
     my_perl = perl_alloc();
     perl_construct(my_perl);
     perl_parse(my_perl, NULL, 3, embedding, NULL);
     PL_exit_flags |= PERL_EXIT_DESTRUCT_END;

     text = newSV(0);
     sv_setpv(text, "When he is at a convenience store and the "
	"bill comes to some amount like 76 cents, Maynard is "
	"aware that there is something he *should* do, something "
	"that will enable him to get back a quarter, but he has "
	"no idea *what*.  He fumbles through his red squeezey "
	"changepurse and gives the boy three extra pennies with "
	"his dollar, hoping that he might luck into the correct "
	"amount.  The boy gives him back two of his own pennies "
	"and then the big shiny quarter that is his prize. "
	"-RICHH");

     if (match(text, "m/quarter/")) /** Does text contain 'quarter'? **/
 	printf("match: Text contains the word 'quarter'.\n\n");
     else
 	printf("match: Text doesn't contain the word 'quarter'.\n\n");

     if (match(text, "m/eighth/")) /** Does text contain 'eighth'? **/
 	printf("match: Text contains the word 'eighth'.\n\n");
     else
 	printf("match: Text doesn't contain the word 'eighth'.\n\n");

     /** Match all occurrences of /wi../ **/
     num_matches = matches(text, "m/(wi..)/g", &match_list);
     printf("matches: m/(wi..)/g found %d matches...\n", num_matches);

     for (i = 0; i < num_matches; i++)
         printf("match: %s\n",
                  SvPV_nolen(*av_fetch(match_list, i, FALSE)));
     printf("\n");

     /** Remove all vowels from text **/
     num_matches = substitute(&text, "s/[aeiou]//gi");
     if (num_matches) {
 	printf("substitute: s/[aeiou]//gi...%lu substitutions made.\n",
 	       (unsigned long)num_matches);
 	printf("Now text is: %s\n\n", SvPV_nolen(text));
     }

     /** Attempt a substitution **/
     if (!substitute(&text, "s/Perl/C/")) {
 	printf("substitute: s/Perl/C...No substitution made.\n\n");
     }

     SvREFCNT_dec(text);
     PL_perl_destruct_level = 1;
     perl_destruct(my_perl);
     perl_free(my_perl);
     PERL_SYS_TERM();
 }

which produces the output (again, long lines have been wrapped here)

  match: Text contains the word 'quarter'.

  match: Text doesn't contain the word 'eighth'.

  matches: m/(wi..)/g found 2 matches...
  match: will
  match: with

  substitute: s/[aeiou]//gi...139 substitutions made.
  Now text is: Whn h s t  cnvnnc str nd th bll cms t sm mnt lk 76 cnts,
  Mynrd s wr tht thr s smthng h *shld* d, smthng tht wll nbl hm t gt
  bck qrtr, bt h hs n d *wht*.  H fmbls thrgh hs rd sqzy chngprs nd
  gvs th by thr xtr pnns wth hs dllr, hpng tht h mght lck nt th crrct
  mnt.  Th by gvs hm bck tw f hs wn pnns nd thn th bg shny qrtr tht s
  hs prz. -RCHH

  substitute: s/Perl/C...No substitution made.

=head2 Fiddling with the Perl stack from your C program

When trying to explain stacks, most computer science textbooks mumble
something about spring-loaded columns of cafeteria plates: the last
thing you pushed on the stack is the first thing you pop off.  That'll
do for our purposes: your C program will push some arguments onto "the Perl
stack", shut its eyes while some magic happens, and then pop the
results--the return value of your Perl subroutine--off the stack.

First you'll need to know how to convert between C types and Perl
types, with newSViv() and sv_setnv() and newAV() and all their
friends.  They're described in L<perlguts> and L<perlapi>.

Then you'll need to know how to manipulate the Perl stack.  That's
described in L<perlcall>.

Once you've understood those, embedding Perl in C is easy.

Because C has no builtin function for integer exponentiation, let's
make Perl's ** operator available to it (this is less useful than it
sounds, because Perl implements ** with C's I<pow()> function).  First
I'll create a stub exponentiation function in I<power.pl>:

    sub expo {
        my ($a, $b) = @@_;
        return $a ** $b;
    }

Now I'll create a C program, I<power.c>, with a function
I<PerlPower()> that contains all the perlguts necessary to push the
two arguments into I<expo()> and to pop the return value out.  Take a
deep breath...

 #include <EXTERN.h>
 #include <perl.h>

 static PerlInterpreter *my_perl;

 static void
 PerlPower(int a, int b)
 {
   dSP;                            /* initialize stack pointer      */
   ENTER;                          /* everything created after here */
   SAVETMPS;                       /* ...is a temporary variable.   */
   PUSHMARK(SP);                   /* remember the stack pointer    */
   XPUSHs(sv_2mortal(newSViv(a))); /* push the base onto the stack  */
   XPUSHs(sv_2mortal(newSViv(b))); /* push the exponent onto stack  */
   PUTBACK;                      /* make local stack pointer global */
   call_pv("expo", G_SCALAR);      /* call the function             */
   SPAGAIN;                        /* refresh stack pointer         */
                                 /* pop the return value from stack */
   printf ("%d to the %dth power is %d.\n", a, b, POPi);
   PUTBACK;
   FREETMPS;                       /* free that return value        */
   LEAVE;                       /* ...and the XPUSHed "mortal" args.*/
 }

 int main (int argc, char **argv, char **env)
 {
   char *my_argv[] = { "", "power.pl" };

   PERL_SYS_INIT3(&argc,&argv,&env);
   my_perl = perl_alloc();
   perl_construct( my_perl );

   perl_parse(my_perl, NULL, 2, my_argv, (char **)NULL);
   PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
   perl_run(my_perl);

   PerlPower(3, 4);                      /*** Compute 3 ** 4 ***/

   perl_destruct(my_perl);
   perl_free(my_perl);
   PERL_SYS_TERM();
 }



Compile and run:

    % cc -o power power.c `perl -MExtUtils::Embed -e ccopts -e ldopts`

    % power
    3 to the 4th power is 81.

=head2 Maintaining a persistent interpreter

When developing interactive and/or potentially long-running
applications, it's a good idea to maintain a persistent interpreter
rather than allocating and constructing a new interpreter multiple
times.  The major reason is speed: since Perl will only be loaded into
memory once.

However, you have to be more cautious with namespace and variable
scoping when using a persistent interpreter.  In previous examples
we've been using global variables in the default package C<main>.  We
knew exactly what code would be run, and assumed we could avoid
variable collisions and outrageous symbol table growth.

Let's say your application is a server that will occasionally run Perl
code from some arbitrary file.  Your server has no way of knowing what
code it's going to run.  Very dangerous.

If the file is pulled in by C<perl_parse()>, compiled into a newly
constructed interpreter, and subsequently cleaned out with
C<perl_destruct()> afterwards, you're shielded from most namespace
troubles.

One way to avoid namespace collisions in this scenario is to translate
the filename into a guaranteed-unique package name, and then compile
the code into that package using L<perlfunc/eval>.  In the example
below, each file will only be compiled once.  Or, the application
might choose to clean out the symbol table associated with the file
after it's no longer needed.  Using L<perlapi/call_argv>, We'll
call the subroutine C<Embed::Persistent::eval_file> which lives in the
file C<persistent.pl> and pass the filename and boolean cleanup/cache
flag as arguments.

Note that the process will continue to grow for each file that it
uses.  In addition, there might be C<AUTOLOAD>ed subroutines and other
conditions that cause Perl's symbol table to grow.  You might want to
add some logic that keeps track of the process size, or restarts
itself after a certain number of requests, to ensure that memory
consumption is minimized.  You'll also want to scope your variables
with L<perlfunc/my> whenever possible.


 package Embed::Persistent;
 #persistent.pl

 use strict;
 our %Cache;
 use Symbol qw(delete_package);

 sub valid_package_name {
     my($string) = @@_;
     $string =~ s/([^A-Za-z0-9\/])/sprintf("_%2x",unpack("C",$1))/eg;
     # second pass only for words starting with a digit
     $string =~ s|/(\d)|sprintf("/_%2x",unpack("C",$1))|eg;

     # Dress it up as a real package name
     $string =~ s|/|::|g;
     return "Embed" . $string;
 }

 sub eval_file {
     my($filename, $delete) = @@_;
     my $package = valid_package_name($filename);
     my $mtime = -M $filename;
     if(defined $Cache{$package}{mtime}
        &&
        $Cache{$package}{mtime} <= $mtime)
     {
        # we have compiled this subroutine already,
        # it has not been updated on disk, nothing left to do
        print STDERR "already compiled $package->handler\n";
     }
     else {
        local *FH;
        open FH, $filename or die "open '$filename' $!";
        local($/) = undef;
        my $sub = <FH>;
        close FH;

        #wrap the code into a subroutine inside our unique package
        my $eval = qq{package $package; sub handler { $sub; }};
        {
            # hide our variables within this block
            my($filename,$mtime,$package,$sub);
            eval $eval;
        }
        die $@@ if $@@;

        #cache it unless we're cleaning out each time
        $Cache{$package}{mtime} = $mtime unless $delete;
     }

     eval {$package->handler;};
     die $@@ if $@@;

     delete_package($package) if $delete;

     #take a look if you want
     #print Devel::Symdump->rnew($package)->as_string, $/;
 }

 1;

 __END__

 /* persistent.c */
 #include <EXTERN.h>
 #include <perl.h>

 /* 1 = clean out filename's symbol table after each request,
    0 = don't
 */
 #ifndef DO_CLEAN
 #define DO_CLEAN 0
 #endif

 #define BUFFER_SIZE 1024

 static PerlInterpreter *my_perl = NULL;

 int
 main(int argc, char **argv, char **env)
 {
     char *embedding[] = { "", "persistent.pl" };
     char *args[] = { "", DO_CLEAN, NULL };
     char filename[BUFFER_SIZE];
     int exitstatus = 0;

     PERL_SYS_INIT3(&argc,&argv,&env);
     if((my_perl = perl_alloc()) == NULL) {
        fprintf(stderr, "no memory!");
        exit(1);
     }
     perl_construct(my_perl);

     PL_origalen = 1; /* don't let $0 assignment update the
                         proctitle or embedding[0] */
     exitstatus = perl_parse(my_perl, NULL, 2, embedding, NULL);
     PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
     if(!exitstatus) {
        exitstatus = perl_run(my_perl);

        while(printf("Enter file name: ") &&
              fgets(filename, BUFFER_SIZE, stdin)) {

            filename[strlen(filename)-1] = '\0'; /* strip \n */
            /* call the subroutine,
                     passing it the filename as an argument */
            args[0] = filename;
            call_argv("Embed::Persistent::eval_file",
                           G_DISCARD | G_EVAL, args);

            /* check $@@ */
            if(SvTRUE(ERRSV))
                fprintf(stderr, "eval error: %s\n", SvPV_nolen(ERRSV));
        }
     }

     PL_perl_destruct_level = 0;
     perl_destruct(my_perl);
     perl_free(my_perl);
     PERL_SYS_TERM();
     exit(exitstatus);
 }

Now compile:

 % cc -o persistent persistent.c \
        `perl -MExtUtils::Embed -e ccopts -e ldopts`

Here's an example script file:

 #test.pl
 my $string = "hello";
 foo($string);

 sub foo {
     print "foo says: @@_\n";
 }

Now run:

 % persistent
 Enter file name: test.pl
 foo says: hello
 Enter file name: test.pl
 already compiled Embed::test_2epl->handler
 foo says: hello
 Enter file name: ^C

=head2 Execution of END blocks

Traditionally END blocks have been executed at the end of the perl_run.
This causes problems for applications that never call perl_run. Since
perl 5.7.2 you can specify C<PL_exit_flags |= PERL_EXIT_DESTRUCT_END>
to get the new behaviour. This also enables the running of END blocks if
the perl_parse fails and C<perl_destruct> will return the exit value.

=head2 $0 assignments

When a perl script assigns a value to $0 then the perl runtime will
try to make this value show up as the program name reported by "ps" by
updating the memory pointed to by the argv passed to perl_parse() and
also calling API functions like setproctitle() where available.  This
behaviour might not be appropriate when embedding perl and can be
disabled by assigning the value C<1> to the variable C<PL_origalen>
before perl_parse() is called.

The F<persistent.c> example above is for instance likely to segfault
when $0 is assigned to if the C<PL_origalen = 1;> assignment is
removed.  This because perl will try to write to the read only memory
of the C<embedding[]> strings.

=head2 Maintaining multiple interpreter instances

Some rare applications will need to create more than one interpreter
during a session.  Such an application might sporadically decide to
release any resources associated with the interpreter.

The program must take care to ensure that this takes place I<before>
the next interpreter is constructed.  By default, when perl is not
built with any special options, the global variable
C<PL_perl_destruct_level> is set to C<0>, since extra cleaning isn't
usually needed when a program only ever creates a single interpreter
in its entire lifetime.

Setting C<PL_perl_destruct_level> to C<1> makes everything squeaky clean:

 while(1) {
     ...
     /* reset global variables here with PL_perl_destruct_level = 1 */
     PL_perl_destruct_level = 1;
     perl_construct(my_perl);
     ...
     /* clean and reset _everything_ during perl_destruct */
     PL_perl_destruct_level = 1;
     perl_destruct(my_perl);
     perl_free(my_perl);
     ...
     /* let's go do it again! */
 }

When I<perl_destruct()> is called, the interpreter's syntax parse tree
and symbol tables are cleaned up, and global variables are reset.  The
second assignment to C<PL_perl_destruct_level> is needed because
perl_construct resets it to C<0>.

Now suppose we have more than one interpreter instance running at the
same time.  This is feasible, but only if you used the Configure option
C<-Dusemultiplicity> or the options C<-Dusethreads -Duseithreads> when
building perl.  By default, enabling one of these Configure options
sets the per-interpreter global variable C<PL_perl_destruct_level> to
C<1>, so that thorough cleaning is automatic and interpreter variables
are initialized correctly.  Even if you don't intend to run two or
more interpreters at the same time, but to run them sequentially, like
in the above example, it is recommended to build perl with the
C<-Dusemultiplicity> option otherwise some interpreter variables may
not be initialized correctly between consecutive runs and your
application may crash.

See also L<perlxs/Thread-aware system interfaces>.

Using C<-Dusethreads -Duseithreads> rather than C<-Dusemultiplicity>
is more appropriate if you intend to run multiple interpreters
concurrently in different threads, because it enables support for
linking in the thread libraries of your system with the interpreter.

Let's give it a try:


 #include <EXTERN.h>
 #include <perl.h>

 /* we're going to embed two interpreters */

 #define SAY_HELLO "-e", "print qq(Hi, I'm $^X\n)"

 int main(int argc, char **argv, char **env)
 {
     PerlInterpreter *one_perl, *two_perl;
     char *one_args[] = { "one_perl", SAY_HELLO };
     char *two_args[] = { "two_perl", SAY_HELLO };

     PERL_SYS_INIT3(&argc,&argv,&env);
     one_perl = perl_alloc();
     two_perl = perl_alloc();

     PERL_SET_CONTEXT(one_perl);
     perl_construct(one_perl);
     PERL_SET_CONTEXT(two_perl);
     perl_construct(two_perl);

     PERL_SET_CONTEXT(one_perl);
     perl_parse(one_perl, NULL, 3, one_args, (char **)NULL);
     PERL_SET_CONTEXT(two_perl);
     perl_parse(two_perl, NULL, 3, two_args, (char **)NULL);

     PERL_SET_CONTEXT(one_perl);
     perl_run(one_perl);
     PERL_SET_CONTEXT(two_perl);
     perl_run(two_perl);

     PERL_SET_CONTEXT(one_perl);
     perl_destruct(one_perl);
     PERL_SET_CONTEXT(two_perl);
     perl_destruct(two_perl);

     PERL_SET_CONTEXT(one_perl);
     perl_free(one_perl);
     PERL_SET_CONTEXT(two_perl);
     perl_free(two_perl);
     PERL_SYS_TERM();
 }

Note the calls to PERL_SET_CONTEXT().  These are necessary to initialize
the global state that tracks which interpreter is the "current" one on
the particular process or thread that may be running it.  It should
always be used if you have more than one interpreter and are making
perl API calls on both interpreters in an interleaved fashion.

PERL_SET_CONTEXT(interp) should also be called whenever C<interp> is
used by a thread that did not create it (using either perl_alloc(), or
the more esoteric perl_clone()).

Compile as usual:

 % cc -o multiplicity multiplicity.c \
  `perl -MExtUtils::Embed -e ccopts -e ldopts`

Run it, Run it:

 % multiplicity
 Hi, I'm one_perl
 Hi, I'm two_perl

=head2 Using Perl modules, which themselves use C libraries, from your C
program

If you've played with the examples above and tried to embed a script
that I<use()>s a Perl module (such as I<Socket>) which itself uses a C or C++
library, this probably happened:


 Can't load module Socket, dynamic loading not available in this perl.
  (You may need to build a new perl executable which either supports
  dynamic loading or has the Socket module statically linked into it.)


What's wrong?

Your interpreter doesn't know how to communicate with these extensions
on its own.  A little glue will help.  Up until now you've been
calling I<perl_parse()>, handing it NULL for the second argument:

 perl_parse(my_perl, NULL, argc, my_argv, NULL);

That's where the glue code can be inserted to create the initial contact
between Perl and linked C/C++ routines. Let's take a look some pieces of
I<perlmain.c> to see how Perl does this:

 static void xs_init (pTHX);

 EXTERN_C void boot_DynaLoader (pTHX_ CV* cv);
 EXTERN_C void boot_Socket (pTHX_ CV* cv);


 EXTERN_C void
 xs_init(pTHX)
 {
        char *file = __FILE__;
        /* DynaLoader is a special case */
        newXS("DynaLoader::boot_DynaLoader", boot_DynaLoader, file);
        newXS("Socket::bootstrap", boot_Socket, file);
 }

Simply put: for each extension linked with your Perl executable
(determined during its initial configuration on your
computer or when adding a new extension),
a Perl subroutine is created to incorporate the extension's
routines.  Normally, that subroutine is named
I<Module::bootstrap()> and is invoked when you say I<use Module>.  In
turn, this hooks into an XSUB, I<boot_Module>, which creates a Perl
counterpart for each of the extension's XSUBs.  Don't worry about this
part; leave that to the I<xsubpp> and extension authors.  If your
extension is dynamically loaded, DynaLoader creates I<Module::bootstrap()>
for you on the fly.  In fact, if you have a working DynaLoader then there
is rarely any need to link in any other extensions statically.


Once you have this code, slap it into the second argument of I<perl_parse()>:


 perl_parse(my_perl, xs_init, argc, my_argv, NULL);


Then compile:

 % cc -o interp interp.c `perl -MExtUtils::Embed -e ccopts -e ldopts`

 % interp
   use Socket;
   use SomeDynamicallyLoadedModule;

   print "Now I can use extensions!\n"'

B<ExtUtils::Embed> can also automate writing the I<xs_init> glue code.

 % perl -MExtUtils::Embed -e xsinit -- -o perlxsi.c
 % cc -c perlxsi.c `perl -MExtUtils::Embed -e ccopts`
 % cc -c interp.c  `perl -MExtUtils::Embed -e ccopts`
 % cc -o interp perlxsi.o interp.o `perl -MExtUtils::Embed -e ldopts`

Consult L<perlxs>, L<perlguts>, and L<perlapi> for more details.

=head2 Using embedded Perl with POSIX locales

(See L<perllocale> for information about these.)
When a Perl interpreter normally starts up, it tells the system it wants
to use the system's default locale.  This is often, but not necessarily,
the "C" or "POSIX" locale.  Absent a S<C<"use locale">> within the perl
code, this mostly has no effect (but see L<perllocale/Not within the
scope of "use locale">).  Also, there is not a problem if the
locale you want to use in your embedded Perl is the same as the system
default.  However, this doesn't work if you have set up and want to use
a locale that isn't the system default one.  Starting in Perl v5.20, you
can tell the embedded Perl interpreter that the locale is already
properly set up, and to skip doing its own normal initialization.  It
skips if the environment variable C<PERL_SKIP_LOCALE_INIT> is set (even
if set to 0 or C<"">).  A Perl that has this capability will define the
C pre-processor symbol C<HAS_SKIP_LOCALE_INIT>.  This allows code that
has to work with multiple Perl versions to do some sort of work-around
when confronted with an earlier Perl.

=head1 Hiding Perl_

If you completely hide the short forms of the Perl public API,
add -DPERL_NO_SHORT_NAMES to the compilation flags.  This means that
for example instead of writing

    warn("%d bottles of beer on the wall", bottlecount);

you will have to write the explicit full form

    Perl_warn(aTHX_ "%d bottles of beer on the wall", bottlecount);

(See L<perlguts/"Background and PERL_IMPLICIT_CONTEXT"> for the explanation
of the C<aTHX_>. )  Hiding the short forms is very useful for avoiding
all sorts of nasty (C preprocessor or otherwise) conflicts with other
software packages (Perl defines about 2400 APIs with these short names,
take or leave few hundred, so there certainly is room for conflict.)

=head1 MORAL

You can sometimes I<write faster code> in C, but
you can always I<write code faster> in Perl.  Because you can use
each from the other, combine them as you wish.


=head1 AUTHOR

Jon Orwant <F<orwant@@media.mit.edu>> and Doug MacEachern
<F<dougm@@covalent.net>>, with small contributions from Tim Bunce, Tom
Christiansen, Guy Decoux, Hallvard Furuseth, Dov Grobgeld, and Ilya
Zakharevich.

Doug MacEachern has an article on embedding in Volume 1, Issue 4 of
The Perl Journal ( http://www.tpj.com/ ).  Doug is also the developer of the
most widely-used Perl embedding: the mod_perl system
(perl.apache.org), which embeds Perl in the Apache web server.
Oracle, Binary Evolution, ActiveState, and Ben Sugars's nsapi_perl
have used this model for Oracle, Netscape and Internet Information
Server Perl plugins.

=head1 COPYRIGHT

Copyright (C) 1995, 1996, 1997, 1998 Doug MacEachern and Jon Orwant.  All
Rights Reserved.

This document may be distributed under the same terms as Perl itself.
@


1.15
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d1092 1
a1092 1
scope of any "use locale" variant>).  Also, there is not a problem if the
@


1.14
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d23 1
a23 1
Read about L<perlfunc/do> and L<perlfunc/eval> and L<perlfunc/require> 
d80 1
a80 1
=back 
d128 1
a128 1
(That's all one line.)  On my DEC Alpha running old 5.003_05, the 
d179 2
a180 2
    #include <EXTERN.h>               /* from the Perl distribution     */
    #include <perl.h>                 /* from the Perl distribution     */
d182 1
a182 1
    static PerlInterpreter *my_perl;  /***    The Perl interpreter    ***/
d184 2
a185 2
    int main(int argc, char **argv, char **env)
    {
d195 1
a195 1
    }
d275 1
a275 1
    print "I shan't be printed.";
d277 3
a279 3
    sub showtime {
        print time;
    }
d281 1
a281 1
Simple enough.  Now compile and run:
d283 4
a286 4
    % cc -o showtime showtime.c `perl -MExtUtils::Embed -e ccopts -e ldopts`

    % showtime showtime.pl
    818284590
d292 1
a292 1
In this particular case we don't have to call I<perl_run>, as we set 
d318 2
a319 2
   #include <EXTERN.h>
   #include <perl.h>
d321 1
a321 1
   static PerlInterpreter *my_perl;
d323 3
a325 3
   main (int argc, char **argv, char **env)
   {
       char *embedding[] = { "", "-e", "0" };
d327 3
a329 3
       PERL_SYS_INIT3(&argc,&argv,&env);
       my_perl = perl_alloc();
       perl_construct( my_perl );
d331 3
a333 3
       perl_parse(my_perl, NULL, 3, embedding, NULL);
       PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
       perl_run(my_perl);
d335 12
a346 3
       /** Treat $a as an integer **/
       eval_pv("$a = 3; $a **= 2", TRUE);
       printf("a = %d\n", SvIV(get_sv("a", 0)));
d348 4
a351 3
       /** Treat $a as a float **/
       eval_pv("$a = 3.14; $a **= 2", TRUE);
       printf("a = %f\n", SvNV(get_sv("a", 0)));
d353 2
a354 10
       /** Treat $a as a string **/
       eval_pv("$a = 'rekcaH lreP rehtonA tsuJ'; $a = reverse($a);", TRUE);
       printf("a = %s\n", SvPV_nolen(get_sv("a", 0)));

       perl_destruct(my_perl);
       perl_free(my_perl);
       PERL_SYS_TERM();
   }

All of those strange functions with I<sv> in their names help convert Perl scalars to C types.  They're described in L<perlguts> and L<perlapi>.
d393 2
a394 2
within the C<SV> as according to the operation, returning the number of substitutions
made.
d396 1
a396 1
   int matches(SV *string, char *pattern, AV **matches);
d400 2
a401 1
fills in I<matches> with the array elements, returning the number of matches found.
d412 2
a413 2
 ** kinda like eval_sv(), 
 ** but we pop the return value off the stack 
d456 2
a457 1
 ** Used for =~ operations that modify their left-hand side (s/// and tr///)
d485 1
a485 1
 I32 matches(SV *string, char *pattern, AV **match_list)
d488 1
a488 1
     I32 num_matches;
d542 2
a543 1
 	printf("match: %s\n", SvPV_nolen(*av_fetch(match_list, i, FALSE)));
d549 2
a550 2
 	printf("substitute: s/[aeiou]//gi...%d substitutions made.\n",
 	       num_matches);
d568 1
a568 1
   match: Text contains the word 'quarter'.
d570 1
a570 1
   match: Text doesn't contain the word 'eighth'.
d572 11
a582 10
   matches: m/(wi..)/g found 2 matches...
   match: will
   match: with

   substitute: s/[aeiou]//gi...139 substitutions made.
   Now text is: Whn h s t  cnvnnc str nd th bll cms t sm mnt lk 76 cnts,
   Mynrd s wr tht thr s smthng h *shld* d, smthng tht wll nbl hm t gt bck
   qrtr, bt h hs n d *wht*.  H fmbls thrgh hs rd sqzy chngprs nd gvs th by
   thr xtr pnns wth hs dllr, hpng tht h mght lck nt th crrct mnt.  Th by gvs
   hm bck tw f hs wn pnns nd thn th bg shny qrtr tht s hs prz. -RCHH
d584 1
a584 1
   substitute: s/Perl/C...No substitution made.
d619 2
a620 2
    #include <EXTERN.h>
    #include <perl.h>
d622 1
a622 1
    static PerlInterpreter *my_perl;
d624 18
a641 18
    static void
    PerlPower(int a, int b)
    {
      dSP;                            /* initialize stack pointer      */
      ENTER;                          /* everything created after here */
      SAVETMPS;                       /* ...is a temporary variable.   */
      PUSHMARK(SP);                   /* remember the stack pointer    */
      XPUSHs(sv_2mortal(newSViv(a))); /* push the base onto the stack  */
      XPUSHs(sv_2mortal(newSViv(b))); /* push the exponent onto stack  */
      PUTBACK;                      /* make local stack pointer global */
      call_pv("expo", G_SCALAR);      /* call the function             */
      SPAGAIN;                        /* refresh stack pointer         */
                                    /* pop the return value from stack */
      printf ("%d to the %dth power is %d.\n", a, b, POPi);
      PUTBACK;
      FREETMPS;                       /* free that return value        */
      LEAVE;                       /* ...and the XPUSHed "mortal" args.*/
    }
d643 3
a645 3
    int main (int argc, char **argv, char **env)
    {
      char *my_argv[] = { "", "power.pl" };
d647 3
a649 3
      PERL_SYS_INIT3(&argc,&argv,&env);
      my_perl = perl_alloc();
      perl_construct( my_perl );
d651 3
a653 3
      perl_parse(my_perl, NULL, 2, my_argv, (char **)NULL);
      PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
      perl_run(my_perl);
d655 1
a655 1
      PerlPower(3, 4);                      /*** Compute 3 ** 4 ***/
d657 4
a660 4
      perl_destruct(my_perl);
      perl_free(my_perl);
      PERL_SYS_TERM();
    }
d780 3
a782 1
 /* 1 = clean out filename's symbol table after each request, 0 = don't */
d806 2
a807 1
     PL_origalen = 1; /* don't let $0 assignment update the proctitle or embedding[0] */
d817 2
a818 1
            /* call the subroutine, passing it the filename as an argument */
d838 2
a839 1
 % cc -o persistent persistent.c `perl -MExtUtils::Embed -e ccopts -e ldopts`
d997 2
a998 1
 % cc -o multiplicity multiplicity.c `perl -MExtUtils::Embed -e ccopts -e ldopts`
d1006 2
a1007 1
=head2 Using Perl modules, which themselves use C libraries, from your C program
d1010 2
a1011 2
that I<use()>s a Perl module (such as I<Socket>) which itself uses a C or C++ library,
this probably happened:
d1027 3
a1029 3
That's where the glue code can be inserted to create the initial contact between
Perl and linked C/C++ routines.  Let's take a look some pieces of I<perlmain.c>
to see how Perl does this:
d1084 19
@


1.13
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d493 1
a493 1
     num_matches = av_len(*match_list) + 1;
@


1.12
log
@merge in perl 5.12.2 plus local changes
@
text
@d493 1
a493 1
     num_matches = av_len(*match_list) + 1; /** assume $[ is 0 **/
a933 1
 /* we're going to embed two interpreters */
a1071 28
=head1 Embedding Perl under Win32

In general, all of the source code shown here should work unmodified under
Windows.

However, there are some caveats about the command-line examples shown.
For starters, backticks won't work under the Win32 native command shell.
The ExtUtils::Embed kit on CPAN ships with a script called
B<genmake>, which generates a simple makefile to build a program from
a single C source file.  It can be used like this:

 C:\ExtUtils-Embed\eg> perl genmake interp.c
 C:\ExtUtils-Embed\eg> nmake
 C:\ExtUtils-Embed\eg> interp -e "print qq{I'm embedded in Win32!\n}"

You may wish to use a more robust environment such as the Microsoft
Developer Studio.  In this case, run this to generate perlxsi.c:

 perl -MExtUtils::Embed -e xsinit

Create a new project and Insert -> Files into Project: perlxsi.c,
perl.lib, and your own source files, e.g. interp.c.  Typically you'll
find perl.lib in B<C:\perl\lib\CORE>, if not, you should see the
B<CORE> directory relative to C<perl -V:archlib>.  The studio will
also need this path so it knows where to find Perl include files.
This path can be added via the Tools -> Options -> Directories menu.
Finally, select Build -> Build interp.exe and you're ready to go.

d1084 2
a1085 2
(See L<perlguts/Background and PERL_IMPLICIT_CONTEXT for the explanation
of the C<aTHX_>.> )  Hiding the short forms is very useful for avoiding
d1117 1
a1117 15
Permission is granted to make and distribute verbatim copies of this
documentation provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
documentation under the conditions for verbatim copying, provided also
that they are marked clearly as modified versions, that the authors'
names and title are unchanged (though subtitles and additional
authors' names may be added), and that the entire resulting derived
work is distributed under the terms of a permission notice identical
to this one.

Permission is granted to copy and distribute translations of this
documentation into another language, under the above conditions for
modified versions.
@


1.11
log
@Merge in perl 5.10.1
@
text
@d1103 1
a1103 1
If you completely hide the short forms forms of the Perl public API,
@


1.10
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d199 14
a212 5
C<NULL>, which means that the current environment will be used.  The macros
PERL_SYS_INIT3() and PERL_SYS_TERM() provide system-specific tune up 
of the C runtime environment necessary to run Perl interpreters; since
PERL_SYS_INIT3() may change C<env>, it may be more appropriate to provide
C<env> as an argument to perl_parse().
a324 1
       STRLEN n_a;
d337 1
a337 1
       printf("a = %d\n", SvIV(get_sv("a", FALSE)));
d341 1
a341 1
       printf("a = %f\n", SvNV(get_sv("a", FALSE)));
d345 1
a345 1
       printf("a = %s\n", SvPV(get_sv("a", FALSE), n_a));
a367 1
   STRLEN n_a;
d369 1
a369 1
   printf("%s\n", SvPV(val,n_a));
d416 1
a416 1
     STRLEN n_a;
d426 1
a426 1
 	croak(SvPVx(ERRSV, n_a));
a440 1
     STRLEN n_a;
d443 1
a443 1
 	      SvPV(string,n_a), pattern);
a461 1
     STRLEN n_a;
d464 1
a464 1
 	      SvPV(*string,n_a), pattern);
d469 1
a469 1
     *string = get_sv("string", FALSE);
a484 1
     STRLEN n_a;
d487 1
a487 1
 	      SvPV(string,n_a), pattern);
d492 1
a492 1
     *match_list = get_av("array", FALSE);
a503 1
     STRLEN n_a;
d538 1
a538 1
 	printf("match: %s\n", SvPV(*av_fetch(match_list, i, FALSE),n_a));
d546 1
a546 1
 	printf("Now text is: %s\n\n", SvPV(text,n_a));
a789 1
     STRLEN n_a;
d815 1
a815 1
                fprintf(stderr, "eval error: %s\n", SvPV(ERRSV,n_a));
@


1.9
log
@merge in perl 5.8.8
@
text
@d176 1
a176 1
included in the source distribution.  Here's a bastardized, nonportable
d355 1
a355 1
store the computed value of our eval'd expression.  It is also
d433 1
a433 1
     SV *command = NEWSV(1099, 0), *retval;
d455 1
a455 1
     SV *command = NEWSV(1099, 0), *retval;
d478 1
a478 1
     SV *command = NEWSV(1099, 0);
d508 1
a508 1
     text = NEWSV(1099,0);
d796 1
d856 15
d917 2
@


1.8
log
@merge local changes into perl-5.8.3
@
text
@a1120 2
July 22, 1998

@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d509 10
a518 1
     sv_setpv(text, "When he is at a convenience store and the bill comes to some amount like 76 cents, Maynard is aware that there is something he *should* do, something that will enable him to get back a quarter, but he has no idea *what*.  He fumbles through his red squeezey changepurse and gives the boy three extra pennies with his dollar, hoping that he might luck into the correct amount.  The boy gives him back two of his own pennies and then the big shiny quarter that is his prize. -RICHH");
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d186 1
d194 1
d199 5
a203 1
C<NULL>, which means that the current environment will be used.
d244 1
d257 1
d319 1
d341 1
d384 1
a384 1
within the C<AV> at according to the operation, returning the number of substitutions
d399 2
a495 1
     PerlInterpreter *my_perl = perl_alloc();
d499 1
a499 1
     SV *text = NEWSV(1099,0);
d502 2
d508 1
d546 1
d629 1
d641 1
d767 3
a769 1
 static PerlInterpreter *perl = NULL;
d776 1
a776 1
     char filename [1024];
d780 2
a781 1
     if((perl = perl_alloc()) == NULL) {
d785 1
a785 1
     perl_construct(perl);
d787 1
a787 1
     exitstatus = perl_parse(perl, NULL, 2, embedding, NULL);
d790 1
a790 1
        exitstatus = perl_run(perl);
d792 2
a793 1
        while(printf("Enter file name: ") && gets(filename)) {
d795 1
d808 3
a810 2
     perl_destruct(perl);
     perl_free(perl);
d844 1
a844 1
the perl_prase fails and C<perl_destruct> will return the exit value.
a860 2
 PL_perl_destruct_level = 1;

d864 1
d868 1
d876 3
a878 1
and symbol tables are cleaned up, and global variables are reset.
d883 1
a883 1
building Perl.  By default, enabling one of these Configure options
d885 7
a891 1
C<1>, so that thorough cleaning is automatic.
d911 1
a911 3
     PerlInterpreter
         *one_perl = perl_alloc(),
         *two_perl = perl_alloc();
d915 4
d943 1
d1072 18
d1099 2
a1100 2
Jon Orwant <F<orwant@@tpj.com>> and Doug MacEachern
<F<dougm@@osf.org>>, with small contributions from Tim Bunce, Tom
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d164 2
a165 2
http://www.perl.com/perl/CPAN/modules/by-module/ExtUtils/.  (If
this documentation came from your Perl distribution, then you're
d188 1
d242 1
d275 3
a277 4
In this particular case we don't have to call I<perl_run>, but in
general it's considered good practice to ensure proper initialization
of library code, including execution of all object C<DESTROY> methods
and package C<END {}> blocks.
d315 1
d493 1
d618 1
d768 1
a768 1

d795 1
a795 1
Here's a example script file:
d815 8
d1053 1
a1053 1
The Perl Journal (http://tpj.com).  Doug is also the developer of the
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d40 1
a40 1
L<Compiling your C program>
d42 1
a42 1
L<Adding a Perl interpreter to your C program>
d44 1
a44 1
L<Calling a Perl subroutine from your C program>
d46 1
a46 1
L<Evaluating a Perl statement from your C program>
d48 1
a48 1
L<Performing Perl pattern matches and substitutions from your C program>
d50 1
a50 1
L<Fiddling with the Perl stack from your C program>
d52 1
a52 1
L<Maintaining a persistent interpreter>
d54 1
a54 1
L<Maintaining multiple interpreter instances>
d56 1
a56 1
L<Using Perl modules, which themselves use C libraries, from your C program>
d58 21
a78 1
L<Embedding Perl under Win32>
d281 2
a282 3
you'll need to manipulate the Perl stack.  That's demonstrated in the
last section of this document: L<Fiddling with the Perl stack from
your C program>.
d378 1
a378 1
matches() evaluates C<$string =~ $pattern> in an array context, and
d456 1
a456 1
 ** Used for matches in an array context.
d818 2
a819 1
the next interpreter is constructed.  By default, the global variable
d821 2
a822 1
needed when a program has only one interpreter.
d844 10
a853 3
same time.  This is feasible, but only if you used the
C<-DMULTIPLICITY> flag when building Perl.  By default, that sets
C<PL_perl_destruct_level> to C<1>.
d874 1
d876 1
d879 1
d881 1
d884 1
d886 1
d889 1
d891 1
d894 1
d896 1
d900 9
d944 1
d946 2
a947 10
 #ifdef __cplusplus
 #  define EXTERN_C extern "C"
 #else
 #  define EXTERN_C extern
 #endif

 static void xs_init (void);

 EXTERN_C void boot_DynaLoader (CV* cv);
 EXTERN_C void boot_Socket (CV* cv);
d951 1
a951 1
 xs_init()
d1000 2
a1001 11
At the time of this writing (5.004), there are two versions of Perl
which run under Win32.  (The two versions are merging in 5.005.)
Interfacing to ActiveState's Perl library is quite different from the
examples in this documentation, as significant changes were made to
the internal Perl API.  However, it is possible to embed ActiveState's
Perl runtime.  For details, see the Perl for Win32 FAQ at
http://www.perl.com/CPAN/doc/FAQs/win32/perlwin32faq.html.

With the "official" Perl version 5.004 or higher, all the examples
within this documentation will compile and run untouched, although
the build process is slightly different between Unix and Win32.  
d1003 2
a1004 1
For starters, backticks don't work under the Win32 native command shell.
@


1.3
log
@perl5.005_03 (stock)
@
text
@d15 1
a15 1
Read L<perlxstut>, L<perlxs>, L<h2xs>, and L<perlguts>.
d203 1
a203 1
To call individual Perl subroutines, you can use any of the B<perl_call_*>
d205 1
a205 1
In this example we'll use C<perl_call_argv>.
d224 1
a224 1
        perl_call_argv("showtime", G_DISCARD | G_NOARGS, args);
d260 1
a260 1
I<perl_call_argv>.  For other data types, or to examine return values,
d268 1
a268 1
These are L<perlguts/perl_eval_sv> and L<perlguts/perl_eval_pv>.
d276 1
a276 1
I<perl_eval_pv> lets us evaluate individual Perl strings, and then
d283 1
a283 1
   
d285 1
a285 1
   
d290 1
a290 1
   
d293 1
a293 1
   
d296 1
a296 1
   
d298 3
a300 3
       perl_eval_pv("$a = 3; $a **= 2", TRUE);
       printf("a = %d\n", SvIV(perl_get_sv("a", FALSE)));
   
d302 3
a304 3
       perl_eval_pv("$a = 3.14; $a **= 2", TRUE);
       printf("a = %f\n", SvNV(perl_get_sv("a", FALSE)));
   
d306 3
a308 3
       perl_eval_pv("$a = 'rekcaH lreP rehtonA tsuJ'; $a = reverse($a);", TRUE);
       printf("a = %s\n", SvPV(perl_get_sv("a", FALSE), n_a));
   
d313 1
a313 1
All of those strange functions with I<sv> in their names help convert Perl scalars to C types.  They're described in L<perlguts>.
d326 1
a326 1
from I<perl_eval_pv()> instead.  Example:
d330 1
a330 1
   SV *val = perl_eval_pv("reverse 'rekcaH lreP rehtonA tsuJ'", TRUE);
d339 1
a339 1
The I<perl_eval_sv()> function lets us evaluate strings of Perl code, so we can
d367 3
a369 3
 
 /** my_perl_eval_sv(code, error_check)
 ** kinda like perl_eval_sv(), 
d372 1
a372 1
 SV* my_perl_eval_sv(SV *sv, I32 croak_on_error)
d377 1
a377 1
 
d379 2
a380 2
     perl_eval_sv(sv, G_SCALAR);
 
d384 1
a384 1
 
d387 1
a387 1
 
d390 1
a390 1
 
d397 1
a397 1
 
d402 1
a402 1
 
d405 2
a406 2
 
     retval = my_perl_eval_sv(command, TRUE);
d408 1
a408 1
 
d411 1
a411 1
 
d419 1
a419 1
 
d424 1
a424 1
 
d427 2
a428 2
 
     retval = my_perl_eval_sv(command, TRUE);
d430 2
a431 2
 
     *string = perl_get_sv("string", FALSE);
d434 1
a434 1
 
d442 1
a442 1
 
d448 1
a448 1
 
d451 2
a452 2
 
     my_perl_eval_sv(command, TRUE);
d454 2
a455 2
 
     *match_list = perl_get_av("array", FALSE);
d457 1
a457 1
 
d460 1
a460 1
 
d469 1
a469 1
 
d472 1
a472 1
 
d474 1
a474 1
 
d479 1
a479 1
 
d484 1
a484 1
 
d488 1
a488 1
 
d492 1
a492 1
 
d500 1
a500 1
 
d505 1
a505 1
 
d542 1
a542 1
friends.  They're described in L<perlguts>.
d579 1
a579 1
      perl_call_pv("expo", G_SCALAR); /* call the function             */
d641 1
a641 1
after it's no longer needed.  Using L<perlcall/perl_call_argv>, We'll
d659 1
a659 1
 use vars '%Cache';
d753 1
a753 1
            perl_call_argv("Embed::Persistent::eval_file",
d904 1
a904 1
 static void xs_init _((void));
d906 2
a907 2
 EXTERN_C void boot_DynaLoader _((CV* cv));
 EXTERN_C void boot_Socket _((CV* cv));
d956 1
a956 1
Consult L<perlxs> and L<perlguts> for more details.
@


1.2
log
@perl 5.004_04
@
text
@d15 1
a15 1
Read L<perlcall> and L<perlxs>.
d23 1
a23 1
Read about L<perlfunc/do> and L<perlfunc/eval> and L<perlfunc/require>
d38 2
a41 2
There's one example in each of the nine sections:

d60 2
d108 2
a109 2
(That's all one line.)  On my DEC Alpha running 5.003_05, the incantation
is a bit different:
d144 1
a144 1
http://www.perl.com/perl/CPAN/modules/by-module/ExtUtils::Embed.  (If
d156 1
a156 1
from the source distribution.  Here's a bastardized, nonportable
d199 1
a199 1
calling I<perl_run()>.
d204 2
a205 2
functions documented in the L<perlcall> manpage.
In this example we'll use I<perl_call_argv>.
d268 1
a268 1
These are L<perlguts/perl_eval_sv()> and L<perlguts/perl_eval_pv()>.
d271 4
a274 4
snippets of Perl code from within your C program.  Your code can be
as long as you wish; it can contain multiple statements; it can employ
L<perlfunc/use>, L<perlfunc/require> and L<perlfunc/do> to include
external Perl files.
d276 1
a276 1
I<perl_eval_pv()> lets us evaluate individual Perl strings, and then
d288 1
d307 1
a307 1
       printf("a = %s\n", SvPV(perl_get_sv("a", FALSE), na));
d326 1
a326 1
from L<perl_eval_pv> instead.  Example:
d329 1
d331 1
a331 1
   printf("%s\n", SvPV(val,na));
d339 1
a339 1
The I<perl_eval_sv()> function lets us evaluate chunks of Perl code, so we can
d343 1
a343 1
   char match(SV *string, char *pattern);
d376 1
d378 1
a378 1
     PUSHMARK(sp);
d385 2
a386 2
     if (croak_on_error && SvTRUE(GvSV(errgv)))
 	croak(SvPVx(GvSV(errgv), na));
d400 2
a401 1
     SV *command = newSV(0), *retval;
d404 1
a404 1
 	      SvPV(string,na), pattern);
d422 2
a423 1
     SV *command = newSV(0), *retval;
d426 1
a426 1
 	      SvPV(*string,na), pattern);
d445 1
a445 1
     SV *command = newSV(0);
d447 1
d450 1
a450 1
 	      SvPV(string,na), pattern);
d467 2
a468 1
     SV *text = newSV(0);
d490 1
a490 1
 	printf("match: %s\n", SvPV(*av_fetch(match_list, i, FALSE),na));
d498 1
a498 1
 	printf("Now text is: %s\n\n", SvPV(text,na));
d507 1
a507 1
     perl_destruct_level = 1;
d575 1
a575 1
      PUSHMARK(sp);                   /* remember the stack pointer    */
d660 1
a672 14
 #borrowed from Safe.pm
 sub delete_package {
     my $pkg = shift;
     my ($stem, $leaf);

     no strict 'refs';
     $pkg = "main::$pkg\::";    # expand to full symbol table name
     ($stem, $leaf) = $pkg =~ m/(.*::)(\w+::)$/;

     my $stem_symtab = *{$stem}{HASH};

     delete $stem_symtab->{$leaf};
 }

d736 1
d757 2
a758 2
            if(SvTRUE(GvSV(errgv)))
                fprintf(stderr, "eval error: %s\n", SvPV(GvSV(errgv),na));
d762 1
a762 1
     perl_destruct_level = 0;
d800 1
a800 1
C<perl_destruct_level> is set to C<0>, since extra cleaning isn't
d803 1
a803 1
Setting C<perl_destruct_level> to C<1> makes everything squeaky clean:
d805 1
a805 1
 perl_destruct_level = 1;
d809 1
a809 1
     /* reset global variables here with perl_destruct_level = 1 */
d825 1
a825 1
C<perl_destruct_level> to C<1>.
d960 7
a966 6
At the time of this writing, there are two versions of Perl which run
under Win32.  Interfacing to Activeware's Perl library is quite
different from the examples in this documentation, as significant
changes were made to the internal Perl API.  However, it is possible
to embed Activeware's Perl runtime, see the Perl for Win32 FAQ:
http://www.perl.com/perl/faq/win32/Perl_for_Win32_FAQ.html
d969 1
a969 1
within this documentation will compile and run untouched, although,
d972 1
a972 1
For starters, backticks don't work under the Win32 native command shell!
d975 1
a975 1
a single C source file.  It can be used like so:
d981 2
a982 2
You may wish to use a more robust environment such as the MS Developer
stdio.  In this case, to generate perlxsi.c run:
d986 7
a992 8
Create a new project, Insert -> Files into Project: perlxsi.c, perl.lib,
and your own source files, e.g. interp.c.  Typically you'll find
perl.lib in B<C:\perl\lib\CORE>, if not, you should see the B<CORE>
directory relative to C<perl -V:archlib>.
The studio will also need this path so it knows where to find Perl
include files.  This path can be added via the Tools -> Options ->
Directories menu.  Finnally, select Build -> Build interp.exe and
you're ready to go!
d1003 14
a1016 12
Jon Orwant and <F<orwant@@tpj.com>> and Doug MacEachern <F<dougm@@osf.org>>,
with small contributions from Tim Bunce, Tom Christiansen, Hallvard Furuseth,
Dov Grobgeld, and Ilya Zakharevich.

Check out Doug's article on embedding in Volume 1, Issue 4 of The Perl
Journal.  Info about TPJ is available from http://tpj.com.

July 17, 1997

Some of this material is excerpted from Jon Orwant's book: I<Perl 5
Interactive>, Waite Group Press, 1996 (ISBN 1-57169-064-6) and appears
courtesy of Waite Group Press.
d1020 1
a1020 1
Copyright (C) 1995, 1996, 1997 Doug MacEachern and Jon Orwant.  All
d1023 15
a1037 7
Although destined for release with the standard Perl distribution,
this document is not public domain, nor is any of Perl and its
documentation.  Permission is granted to freely distribute verbatim
copies of this document provided that no modifications outside of
formatting be made, and that this notice remain intact.  You are
permitted and encouraged to use its code and derivatives thereof in
your own source code for fun or for profit as you see fit.
@


1.1
log
@Initial revision
@
text
@d13 1
a13 1
=item B<Use C from Perl?>  
d17 1
a17 1
=item B<Use a UNIX program from Perl?>  
d19 1
a19 1
Read about backquotes and L<perlfunc/system> and L<perlfunc/exec>.
d21 1
a21 1
=item B<Use Perl from Perl?>  
d23 2
a24 2
Read about L<perlfunc/do> and L<perlfunc/eval> and L<perlmod/use> 
and L<perlmod/require>.
d26 1
a26 1
=item B<Use C from C?>  
d30 1
a30 1
=item B<Use Perl from C?>  
d40 1
a40 1
There's one example in each of the five sections:
d52 7
a58 1
This documentation is UNIX specific.
d62 3
a64 1
Every C program that uses Perl must link in the I<perl library>.  
d66 1
d75 3
a77 2
Your C program will--usually--allocate, "run", and deallocate a
I<PerlInterpreter> object, which is defined in the perl library.  
d80 3
a82 3
(5.002 or later), then the perl library (and I<EXTERN.h> and
I<perl.h>, which you'll also need) will
reside in a directory resembling this:
d96 1
a96 1
    perl -e 'use Config; print $Config{archlib}'
d98 30
a127 13
Here's how you might compile the example in the next section,
L<Adding a Perl interpreter to your C program>,
on a DEC Alpha running the OSF operating system:

    % cc -o interp interp.c -L/usr/local/lib/perl5/alpha-dec_osf/CORE 
    -I/usr/local/lib/perl5/alpha-dec_osf/CORE -lperl -lm

You'll have to choose the appropriate compiler (I<cc>, I<gcc>, et al.)  and
library directory (I</usr/local/lib/...>)  for your machine.  If your
compiler complains that certain functions are undefined, or that it
can't locate I<-lperl>, then you need to change the path following the
-L.  If it complains that it can't find I<EXTERN.h> or I<perl.h>, you need
to change the path following the -I.  
d130 7
a136 1
Perhaps those printed by 
d138 11
a148 1
   perl -e 'use Config; print $Config{libs}'
d154 2
a155 2
from the source distribution.  Here's a bastardized, non-portable version of
I<miniperlmain.c> containing the essentials of embedding:
a156 1
    #include <stdio.h>
d159 1
a159 1
    
d161 1
a161 1
   
d166 1
a166 1
        perl_parse(my_perl, NULL, argc, argv, env);
d172 4
d178 1
a178 2
    % cc -o interp interp.c -L/usr/local/lib/perl5/alpha-dec_osf/CORE 
    -I/usr/local/lib/perl5/alpha-dec_osf/CORE -lperl -lm
d197 1
a197 1
calling I<perl_run()>.  
d201 3
a203 2
To call individual Perl subroutines, you'll need to remove the call to
I<perl_run()> and replace it with a call to I<perl_call_argv()>.
a206 1
    #include <stdio.h>
d208 4
a211 4
    #include <perl.h>                 
    
    static PerlInterpreter *my_perl;  
    
d214 1
d217 7
a223 5
    
        perl_parse(my_perl, NULL, argc, argv, env);
    
                                     /*** This replaces perl_run() ***/
        perl_call_argv("showtime", G_DISCARD | G_NOARGS, argv);
d229 1
a229 1
I<G_NOARGS>) and for which I'll ignore the return value (that's the 
d235 1
a235 1
    
d242 2
a243 3
    % cc -o showtime showtime.c -L/usr/local/lib/perl5/alpha-dec_osf/CORE 
    -I/usr/local/lib/perl5/alpha-dec_osf/CORE -lperl -lm
    
d248 1
a248 1
(the beginning of the UNIX epoch), and the moment I began writing this
d251 11
a261 4
If you want to pass some arguments to the Perl subroutine, or
you want to access the return value, you'll need to manipulate the
Perl stack, demonstrated in the last section of this document: 
L<Fiddling with the Perl stack from your C program>
d265 2
a266 13
NOTE: This section, and the next, employ some very brittle techniques
for evaluting strings of Perl code.  Perl 5.002 contains some nifty
features that enable A Better Way (such as with L<perlguts/perl_eval_sv>).
Look for updates to this document soon.

One way to evaluate a Perl string is to define a function (we'll call 
ours I<perl_eval()>) that wraps around Perl's L<perlfunc/eval>.

Arguably, this is the only routine you'll ever need to execute
snippets of Perl code from within your C program.  Your string can be
as long as you wish; it can contain multiple statements; it can
use L<perlmod/require> or L<perlfunc/do> to include external Perl
files.  
d268 8
a275 2
Our I<perl_eval()> lets us evaluate individual Perl strings, and then 
extract variables for coercion into C types.  The following program, 
a278 1
   #include <stdio.h>
a283 8
   int perl_eval(char *string)
   {
     char *argv[2];
     argv[0] = string;
     argv[1] = NULL;
     perl_call_argv("_eval_", 0, argv);
   }
   
d286 1
a286 2
     char *embedding[] = { "", "-e", "sub _eval_ { eval $_[0] }" };
     STRLEN length;
d288 2
a289 2
     my_perl = perl_alloc();
     perl_construct( my_perl );
d291 2
a292 1
     perl_parse(my_perl, NULL, 3, embedding, env);
d294 3
a296 3
                                       /** Treat $a as an integer **/
     perl_eval("$a = 3; $a **= 2");
     printf("a = %d\n", SvIV(perl_get_sv("a", FALSE)));
d298 3
a300 3
                                       /** Treat $a as a float **/
     perl_eval("$a = 3.14; $a **= 2");
     printf("a = %f\n", SvNV(perl_get_sv("a", FALSE)));
d302 3
a304 3
                                       /** Treat $a as a string **/
     perl_eval("$a = 'rekcaH lreP rehtonA tsuJ'; $a = reverse($a); ");
     printf("a = %s\n", SvPV(perl_get_sv("a", FALSE), length));
d306 2
a307 2
     perl_destruct(my_perl);
     perl_free(my_perl);
d320 12
d335 1
a335 1
Our I<perl_eval()> lets us evaluate strings of Perl code, so we can
d339 1
a339 1
   char match(char *string, char *pattern); 
d341 2
a342 2
Given a string and a pattern (e.g. "m/clasp/" or "/\b\w*\b/", which in
your program might be represented as C<"/\\b\\w*\\b/">),
d345 1
d347 92
a438 78
   int substitute(char *string[], char *pattern);

Given a pointer to a string and an "=~" operation (e.g. "s/bob/robert/g" or 
"tr[A-Z][a-z]"), modifies the string according to the operation,
returning the number of substitutions made.

   int matches(char *string, char *pattern, char **matches[]);

Given a string, a pattern, and a pointer to an empty array of strings,
evaluates C<$string =~ $pattern> in an array context, and fills in
I<matches> with the array elements (allocating memory as it does so), 
returning the number of matches found.

Here's a sample program, I<match.c>, that uses all three:

   #include <stdio.h>
   #include <EXTERN.h>
   #include <perl.h>
   
   static PerlInterpreter *my_perl;
   
   int eval(char *string)
   {
     char *argv[2];
     argv[0] = string;
     argv[1] = NULL;
     perl_call_argv("_eval_", 0, argv);
   }
   
   /** match(string, pattern)
    ** 
    ** Used for matches in a scalar context.
    **
    ** Returns 1 if the match was successful; 0 otherwise. 
    **/
   char match(char *string, char *pattern) 
   {
     char *command;
     command = malloc(sizeof(char) * strlen(string) + strlen(pattern) + 37);
     sprintf(command, "$string = '%s'; $return = $string =~ %s", 
	string, pattern); 
     perl_eval(command);
     free(command);
     return SvIV(perl_get_sv("return", FALSE));
   }
   
   /** substitute(string, pattern)
    **
    ** Used for =~ operations that modify their left-hand side (s/// and tr///)
    **
    ** Returns the number of successful matches, and
    ** modifies the input string if there were any.
    **/
   int substitute(char *string[], char *pattern) 
   {
     char *command;
     STRLEN length;
     command = malloc(sizeof(char) * strlen(*string) + strlen(pattern) + 35);
     sprintf(command, "$string = '%s'; $ret = ($string =~ %s)", 
	*string, pattern); 
     perl_eval(command);
     free(command);
     *string = SvPV(perl_get_sv("string", FALSE), length);
     return SvIV(perl_get_sv("ret", FALSE));
   }
   
   /** matches(string, pattern, matches)
    ** 
    ** Used for matches in an array context.
    **
    ** Returns the number of matches, 
    ** and fills in **matches with the matching substrings (allocates memory!)
    **/
   int matches(char *string, char *pattern, char **matches[]) 
   {
     char *command;
     SV *current_match;
     AV *array;
d440 10
a449 15
     STRLEN length;
     int i;
   
     command = malloc(sizeof(char) * strlen(string) + strlen(pattern) + 38);
     sprintf(command, "$string = '%s'; @@array = ($string =~ %s)", 
	string, pattern); 
     perl_eval(command);
     free(command);
     array = perl_get_av("array", FALSE);
     num_matches = av_len(array) + 1; /** assume $[ is 0 **/
     *matches = (char **) malloc(sizeof(char *) * num_matches);
     for (i = 0; i <= num_matches; i++) {  
       current_match = av_shift(array);
       (*matches)[i] = SvPV(current_match, length);
     }
d451 31
a481 33
   }
   
   main (int argc, char **argv, char **env)
   {
     char *embedding[] = { "", "-e", "sub _eval_ { eval $_[0] }" };
     char *text, **matches;
     int num_matches, i;
     int j;
   
     my_perl = perl_alloc();
     perl_construct( my_perl );
   
     perl_parse(my_perl, NULL, 3, embedding, env);
   
     text = (char *) malloc(sizeof(char) * 486); /** A long string follows! **/
     sprintf(text, "%s", "When he is at a convenience store and the bill comes to some amount like 76 cents, Maynard is aware that there is something he *should* do, something that will enable him to get back a quarter, but he has no idea *what*.  He fumbles through his red squeezey changepurse and gives the boy three extra pennies with his dollar, hoping that he might luck into the correct amount.  The boy gives him back two of his own pennies and then the big shiny quarter that is his prize. -RICHH");  
   
     if (perl_match(text, "m/quarter/")) /** Does text contain 'quarter'? **/
       printf("perl_match: Text contains the word 'quarter'.\n\n");
     else 
       printf("perl_match: Text doesn't contain the word 'quarter'.\n\n");
   
     if (perl_match(text, "m/eighth/")) /** Does text contain 'eighth'? **/
       printf("perl_match: Text contains the word 'eighth'.\n\n");
     else 
       printf("perl_match: Text doesn't contain the word 'eighth'.\n\n");
   
	                               /** Match all occurrences of /wi../ **/
     num_matches = perl_matches(text, "m/(wi..)/g", &matches);
     
     printf("perl_matches: m/(wi..)/g found %d matches...\n", num_matches);
     for (i = 0; i < num_matches; i++) 
       printf("match: %s\n", matches[i]);
d483 3
a485 7
     for (i = 0; i < num_matches; i++) {
       free(matches[i]);
     }
     free(matches);
   
                                       /** Remove all vowels from text **/
     num_matches = perl_substitute(&text, "s/[aeiou]//gi");
d487 3
a489 3
       printf("perl_substitute: s/[aeiou]//gi...%d substitutions made.\n", 
	num_matches);
       printf("Now text is: %s\n\n", text);
d491 4
a494 4
   
                                       /** Attempt a substitution
     if (!perl_substitute(&text, "s/Perl/C/")) {
       printf("perl_substitute: s/Perl/C...No substitution made.\n\n");
d496 3
a498 3
   
     free(text);
   
d501 5
a505 1
   }
d507 1
a507 1
which produces the output
d509 1
a509 5
   perl_match: Text contains the word 'quarter'.
   
   perl_match: Text doesn't contain the word 'eighth'.
   
   perl_matches: m/(wi..)/g found 2 matches...
d512 10
a521 6
   
   perl_substitute: s/[aeiou]//gi...139 substitutions made.
   Now text is: Whn h s t  cnvnnc str nd th bll cms t sm mnt lk 76 cnts, Mynrd s wr tht thr s smthng h *shld* d, smthng tht wll nbl hm t gt bck  qrtr, bt h hs n d *wht*.  H fmbls thrgh hs rd sqzy chngprs nd gvs th by thr xtr pnns wth hs dllr, hpng tht h mght lck nt th crrct mnt.  Th by gvs hm bck tw f hs wn pnns nd thn th bg shny qrtr tht s hs prz. -RCHH
   
   perl_substitute: s/Perl/C...No substitution made.
      
d530 1
a530 1
   
d538 1
a538 1
Once you've understood those, embedding Perl in C is easy.  
d540 1
a540 1
Since C has no built-in function for integer exponentiation, let's
d542 1
a542 1
sounds, since Perl implements ** with C's I<pow()> function).  First
a554 1
    #include <stdio.h>
d557 1
a557 1
    
d559 1
a559 1
    
d574 1
a574 1
      PUTBACK;                               
d578 2
a579 2
    
    int main (int argc, char **argv, char **env) 
d581 2
a582 2
      char *my_argv[2];
    
d585 4
a588 6
    
      my_argv[1] = (char *) malloc(10);
      sprintf(my_argv[1], "power.pl");
    
      perl_parse(my_perl, NULL, argc, my_argv, env);
      
d590 1
a590 1
    
d594 1
a594 1
    
d599 3
a601 4
    % cc -o power power.c -L/usr/local/lib/perl5/alpha-dec_osf/CORE 
    -I/usr/local/lib/perl5/alpha-dec_osf/CORE -lperl -lm
    
    % power 
d604 393
d1000 1
a1000 1
you can always I<write code faster> in Perl.  Since you can use
d1006 6
a1011 2
Jon Orwant F<E<lt>orwant@@media.mit.eduE<gt>>, with contributions from
Tim Bunce, Tom Christiansen, Dov Grobgeld, and Ilya Zakharevich.
d1013 1
a1013 1
December 18, 1995
d1015 2
a1016 2
Some of this material is excerpted from my book: I<Perl 5 Interactive>, 
Waite Group Press, 1996 (ISBN 1-57169-064-6) and appears
d1019 12
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d13 1
a13 1
=item B<Use C from Perl?>
d15 1
a15 1
Read L<perlxstut>, L<perlxs>, L<h2xs>, and L<perlguts>.
d17 1
a17 1
=item B<Use a Unix program from Perl?>
d19 1
a19 1
Read about back-quotes and about C<system> and C<exec> in L<perlfunc>.
d21 1
a21 1
=item B<Use Perl from Perl?>
d23 2
a24 2
Read about L<perlfunc/do> and L<perlfunc/eval> and L<perlfunc/require> 
and L<perlfunc/use>.
d26 1
a26 1
=item B<Use C from C?>
d30 1
a30 1
=item B<Use Perl from C?>
d38 1
a38 1
=over 5
d40 1
a40 1
L<Compiling your C program>
d52 1
a52 9
L<Maintaining a persistent interpreter>

L<Maintaining multiple interpreter instances>

L<Using Perl modules, which themselves use C libraries, from your C program>

L<Embedding Perl under Win32>

=back 
d56 1
a56 3
If you have trouble compiling the scripts in this documentation,
you're not alone.  The cardinal rule: COMPILE THE PROGRAMS IN EXACTLY
THE SAME WAY THAT YOUR PERL WAS COMPILED.  (Sorry for yelling.)
a57 1
Also, every C program that uses Perl must link in the I<perl library>.
d66 2
a67 3
When you use Perl from C, your C program will--usually--allocate,
"run", and deallocate a I<PerlInterpreter> object, which is defined by
the perl library.
d70 3
a72 3
(version 5.002 or later), then the perl library (and I<EXTERN.h> and
I<perl.h>, which you'll also need) will reside in a directory
that looks like this:
d86 1
a86 1
    perl -MConfig -e 'print $Config{archlib}'
d88 13
a100 30
Here's how you'd compile the example in the next section,
L<Adding a Perl interpreter to your C program>, on my Linux box:

    % gcc -O2 -Dbool=char -DHAS_BOOL -I/usr/local/include
    -I/usr/local/lib/perl5/i586-linux/5.003/CORE
    -L/usr/local/lib/perl5/i586-linux/5.003/CORE
    -o interp interp.c -lperl -lm

(That's all one line.)  On my DEC Alpha running old 5.003_05, the 
incantation is a bit different:

    % cc -O2 -Olimit 2900 -DSTANDARD_C -I/usr/local/include
    -I/usr/local/lib/perl5/alpha-dec_osf/5.00305/CORE
    -L/usr/local/lib/perl5/alpha-dec_osf/5.00305/CORE -L/usr/local/lib
    -D__LANGUAGE_C__ -D_NO_PROTO -o interp interp.c -lperl -lm

How can you figure out what to add?  Assuming your Perl is post-5.001,
execute a C<perl -V> command and pay special attention to the "cc" and
"ccflags" information.

You'll have to choose the appropriate compiler (I<cc>, I<gcc>, et al.) for
your machine: C<perl -MConfig -e 'print $Config{cc}'> will tell you what
to use.

You'll also have to choose the appropriate library directory
(I</usr/local/lib/...>) for your machine.  If your compiler complains
that certain functions are undefined, or that it can't locate
I<-lperl>, then you need to change the path following the C<-L>.  If it
complains that it can't find I<EXTERN.h> and I<perl.h>, you need to
change the path following the C<-I>.
d103 1
a103 7
Perhaps those printed by

   perl -MConfig -e 'print $Config{libs}'

Provided your perl binary was properly configured and installed the
B<ExtUtils::Embed> module will determine all of this information for
you:
d105 1
a105 11
   % cc -o interp interp.c `perl -MExtUtils::Embed -e ccopts -e ldopts`

If the B<ExtUtils::Embed> module isn't part of your Perl distribution,
you can retrieve it from
http://www.perl.com/perl/CPAN/modules/by-module/ExtUtils/.  (If
this documentation came from your Perl distribution, then you're
running 5.004 or better and you already have it.)

The B<ExtUtils::Embed> kit on CPAN also contains all source code for
the examples in this document, tests, additional examples and other
information you may find useful.
d111 2
a112 2
included in the source distribution.  Here's a bastardized, nonportable
version of I<miniperlmain.c> containing the essentials of embedding:
d114 1
d117 1
a117 1

d119 1
a119 1

d124 1
a124 1
        perl_parse(my_perl, NULL, argc, argv, (char **)NULL);
a129 4
Notice that we don't use the C<env> pointer.  Normally handed to
C<perl_parse> as its final argument, C<env> here is replaced by
C<NULL>, which means that the current environment will be used.

d132 2
a133 1
    % cc -o interp interp.c `perl -MExtUtils::Embed -e ccopts -e ldopts`
d152 1
a152 1
calling I<perl_run>.
d156 2
a157 3
To call individual Perl subroutines, you can use any of the B<perl_call_*>
functions documented in L<perlcall>.
In this example we'll use C<perl_call_argv>.
d161 1
d163 4
a166 4
    #include <perl.h>

    static PerlInterpreter *my_perl;

a168 1
        char *args[] = { NULL };
d171 5
a175 7

        perl_parse(my_perl, NULL, argc, argv, NULL);

        /*** skipping perl_run() ***/

        perl_call_argv("showtime", G_DISCARD | G_NOARGS, args);

d181 1
a181 1
I<G_NOARGS>) and for which I'll ignore the return value (that's the
d187 1
a187 1

d194 3
a196 2
    % cc -o showtime showtime.c `perl -MExtUtils::Embed -e ccopts -e ldopts`

d201 1
a201 1
(the beginning of the Unix epoch), and the moment I began writing this
d204 4
a207 11
In this particular case we don't have to call I<perl_run>, but in
general it's considered good practice to ensure proper initialization
of library code, including execution of all object C<DESTROY> methods
and package C<END {}> blocks.

If you want to pass arguments to the Perl subroutine, you can add
strings to the C<NULL>-terminated C<args> list passed to
I<perl_call_argv>.  For other data types, or to examine return values,
you'll need to manipulate the Perl stack.  That's demonstrated in the
last section of this document: L<Fiddling with the Perl stack from
your C program>.
d211 13
a223 2
Perl provides two API functions to evaluate pieces of Perl code.
These are L<perlguts/perl_eval_sv> and L<perlguts/perl_eval_pv>.
d225 2
a226 8
Arguably, these are the only routines you'll ever need to execute
snippets of Perl code from within your C program.  Your code can be as
long as you wish; it can contain multiple statements; it can employ
L<perlfunc/use>, L<perlfunc/require>, and L<perlfunc/do> to
include external Perl files.

I<perl_eval_pv> lets us evaluate individual Perl strings, and then
extract variables for coercion into C types.  The following program,
d230 1
d236 8
d246 2
a247 2
       STRLEN n_a;
       char *embedding[] = { "", "-e", "0" };
d249 2
a250 2
       my_perl = perl_alloc();
       perl_construct( my_perl );
d252 1
a252 2
       perl_parse(my_perl, NULL, 3, embedding, NULL);
       perl_run(my_perl);
d254 3
a256 3
       /** Treat $a as an integer **/
       perl_eval_pv("$a = 3; $a **= 2", TRUE);
       printf("a = %d\n", SvIV(perl_get_sv("a", FALSE)));
d258 3
a260 3
       /** Treat $a as a float **/
       perl_eval_pv("$a = 3.14; $a **= 2", TRUE);
       printf("a = %f\n", SvNV(perl_get_sv("a", FALSE)));
d262 3
a264 3
       /** Treat $a as a string **/
       perl_eval_pv("$a = 'rekcaH lreP rehtonA tsuJ'; $a = reverse($a);", TRUE);
       printf("a = %s\n", SvPV(perl_get_sv("a", FALSE), n_a));
d266 2
a267 2
       perl_destruct(my_perl);
       perl_free(my_perl);
a279 13
In the example above, we've created a global variable to temporarily
store the computed value of our eval'd expression.  It is also
possible and in most cases a better strategy to fetch the return value
from I<perl_eval_pv()> instead.  Example:

   ...
   STRLEN n_a;
   SV *val = perl_eval_pv("reverse 'rekcaH lreP rehtonA tsuJ'", TRUE);
   printf("%s\n", SvPV(val,n_a));
   ...

This way, we avoid namespace pollution by not creating global
variables and we've simplified our code as well.
d283 1
a283 1
The I<perl_eval_sv()> function lets us evaluate strings of Perl code, so we can
d287 1
a287 1
   I32 match(SV *string, char *pattern);
d289 2
a290 2
Given a string and a pattern (e.g., C<m/clasp/> or C</\b\w*\b/>, which
in your C program might appear as "/\\b\\w*\\b/"), match()
a292 1
   int substitute(SV **string, char *pattern);
d294 78
a371 95
Given a pointer to an C<SV> and an C<=~> operation (e.g.,
C<s/bob/robert/g> or C<tr[A-Z][a-z]>), substitute() modifies the string
within the C<AV> at according to the operation, returning the number of substitutions
made.

   int matches(SV *string, char *pattern, AV **matches);

Given an C<SV>, a pattern, and a pointer to an empty C<AV>,
matches() evaluates C<$string =~ $pattern> in an array context, and
fills in I<matches> with the array elements, returning the number of matches found.

Here's a sample program, I<match.c>, that uses all three (long lines have
been wrapped here):

 #include <EXTERN.h>
 #include <perl.h>
 
 /** my_perl_eval_sv(code, error_check)
 ** kinda like perl_eval_sv(), 
 ** but we pop the return value off the stack 
 **/
 SV* my_perl_eval_sv(SV *sv, I32 croak_on_error)
 {
     dSP;
     SV* retval;
     STRLEN n_a;
 
     PUSHMARK(SP);
     perl_eval_sv(sv, G_SCALAR);
 
     SPAGAIN;
     retval = POPs;
     PUTBACK;
 
     if (croak_on_error && SvTRUE(ERRSV))
 	croak(SvPVx(ERRSV, n_a));
 
     return retval;
 }
 
 /** match(string, pattern)
 **
 ** Used for matches in a scalar context.
 **
 ** Returns 1 if the match was successful; 0 otherwise.
 **/
 
 I32 match(SV *string, char *pattern)
 {
     SV *command = NEWSV(1099, 0), *retval;
     STRLEN n_a;
 
     sv_setpvf(command, "my $string = '%s'; $string =~ %s",
 	      SvPV(string,n_a), pattern);
 
     retval = my_perl_eval_sv(command, TRUE);
     SvREFCNT_dec(command);
 
     return SvIV(retval);
 }
 
 /** substitute(string, pattern)
 **
 ** Used for =~ operations that modify their left-hand side (s/// and tr///)
 **
 ** Returns the number of successful matches, and
 ** modifies the input string if there were any.
 **/
 
 I32 substitute(SV **string, char *pattern)
 {
     SV *command = NEWSV(1099, 0), *retval;
     STRLEN n_a;
 
     sv_setpvf(command, "$string = '%s'; ($string =~ %s)",
 	      SvPV(*string,n_a), pattern);
 
     retval = my_perl_eval_sv(command, TRUE);
     SvREFCNT_dec(command);
 
     *string = perl_get_sv("string", FALSE);
     return SvIV(retval);
 }
 
 /** matches(string, pattern, matches)
 **
 ** Used for matches in an array context.
 **
 ** Returns the number of matches,
 ** and fills in **matches with the matching substrings
 **/
 
 I32 matches(SV *string, char *pattern, AV **match_list)
 {
     SV *command = NEWSV(1099, 0);
d373 15
a387 11
     STRLEN n_a;
 
     sv_setpvf(command, "my $string = '%s'; @@array = ($string =~ %s)",
 	      SvPV(string,n_a), pattern);
 
     my_perl_eval_sv(command, TRUE);
     SvREFCNT_dec(command);
 
     *match_list = perl_get_av("array", FALSE);
     num_matches = av_len(*match_list) + 1; /** assume $[ is 0 **/
 
d389 33
a421 32
 }
 
 main (int argc, char **argv, char **env)
 {
     PerlInterpreter *my_perl = perl_alloc();
     char *embedding[] = { "", "-e", "0" };
     AV *match_list;
     I32 num_matches, i;
     SV *text = NEWSV(1099,0);
     STRLEN n_a;
 
     perl_construct(my_perl);
     perl_parse(my_perl, NULL, 3, embedding, NULL);
 
     sv_setpv(text, "When he is at a convenience store and the bill comes to some amount like 76 cents, Maynard is aware that there is something he *should* do, something that will enable him to get back a quarter, but he has no idea *what*.  He fumbles through his red squeezey changepurse and gives the boy three extra pennies with his dollar, hoping that he might luck into the correct amount.  The boy gives him back two of his own pennies and then the big shiny quarter that is his prize. -RICHH");
 
     if (match(text, "m/quarter/")) /** Does text contain 'quarter'? **/
 	printf("match: Text contains the word 'quarter'.\n\n");
     else
 	printf("match: Text doesn't contain the word 'quarter'.\n\n");
 
     if (match(text, "m/eighth/")) /** Does text contain 'eighth'? **/
 	printf("match: Text contains the word 'eighth'.\n\n");
     else
 	printf("match: Text doesn't contain the word 'eighth'.\n\n");
 
     /** Match all occurrences of /wi../ **/
     num_matches = matches(text, "m/(wi..)/g", &match_list);
     printf("matches: m/(wi..)/g found %d matches...\n", num_matches);
 
     for (i = 0; i < num_matches; i++)
 	printf("match: %s\n", SvPV(*av_fetch(match_list, i, FALSE),n_a));
d423 7
a429 3
 
     /** Remove all vowels from text **/
     num_matches = substitute(&text, "s/[aeiou]//gi");
d431 3
a433 3
 	printf("substitute: s/[aeiou]//gi...%d substitutions made.\n",
 	       num_matches);
 	printf("Now text is: %s\n\n", SvPV(text,n_a));
d435 4
a438 4
 
     /** Attempt a substitution **/
     if (!substitute(&text, "s/Perl/C/")) {
 	printf("substitute: s/Perl/C...No substitution made.\n\n");
d440 3
a442 3
 
     SvREFCNT_dec(text);
     PL_perl_destruct_level = 1;
d445 1
a445 1
 }
d447 1
a447 1
which produces the output (again, long lines have been wrapped here)
d449 5
a453 5
   match: Text contains the word 'quarter'.

   match: Text doesn't contain the word 'eighth'.

   matches: m/(wi..)/g found 2 matches...
d456 6
a461 10

   substitute: s/[aeiou]//gi...139 substitutions made.
   Now text is: Whn h s t  cnvnnc str nd th bll cms t sm mnt lk 76 cnts,
   Mynrd s wr tht thr s smthng h *shld* d, smthng tht wll nbl hm t gt bck
   qrtr, bt h hs n d *wht*.  H fmbls thrgh hs rd sqzy chngprs nd gvs th by
   thr xtr pnns wth hs dllr, hpng tht h mght lck nt th crrct mnt.  Th by gvs
   hm bck tw f hs wn pnns nd thn th bg shny qrtr tht s hs prz. -RCHH

   substitute: s/Perl/C...No substitution made.

d470 1
a470 1

d478 1
a478 1
Once you've understood those, embedding Perl in C is easy.
d480 1
a480 1
Because C has no builtin function for integer exponentiation, let's
d482 1
a482 1
sounds, because Perl implements ** with C's I<pow()> function).  First
d495 1
d498 1
a498 1

d500 1
a500 1

d507 1
a507 1
      PUSHMARK(SP);                   /* remember the stack pointer    */
d515 1
a515 1
      PUTBACK;
d519 2
a520 2

    int main (int argc, char **argv, char **env)
d522 2
a523 2
      char *my_argv[] = { "", "power.pl" };

d526 6
a531 4

      perl_parse(my_perl, NULL, 2, my_argv, (char **)NULL);
      perl_run(my_perl);

d533 1
a533 1

d537 1
a537 1

d542 4
a545 3
    % cc -o power power.c `perl -MExtUtils::Embed -e ccopts -e ldopts`

    % power
a547 381
=head2 Maintaining a persistent interpreter

When developing interactive and/or potentially long-running
applications, it's a good idea to maintain a persistent interpreter
rather than allocating and constructing a new interpreter multiple
times.  The major reason is speed: since Perl will only be loaded into
memory once.

However, you have to be more cautious with namespace and variable
scoping when using a persistent interpreter.  In previous examples
we've been using global variables in the default package C<main>.  We
knew exactly what code would be run, and assumed we could avoid
variable collisions and outrageous symbol table growth.

Let's say your application is a server that will occasionally run Perl
code from some arbitrary file.  Your server has no way of knowing what
code it's going to run.  Very dangerous.

If the file is pulled in by C<perl_parse()>, compiled into a newly
constructed interpreter, and subsequently cleaned out with
C<perl_destruct()> afterwards, you're shielded from most namespace
troubles.

One way to avoid namespace collisions in this scenario is to translate
the filename into a guaranteed-unique package name, and then compile
the code into that package using L<perlfunc/eval>.  In the example
below, each file will only be compiled once.  Or, the application
might choose to clean out the symbol table associated with the file
after it's no longer needed.  Using L<perlcall/perl_call_argv>, We'll
call the subroutine C<Embed::Persistent::eval_file> which lives in the
file C<persistent.pl> and pass the filename and boolean cleanup/cache
flag as arguments.

Note that the process will continue to grow for each file that it
uses.  In addition, there might be C<AUTOLOAD>ed subroutines and other
conditions that cause Perl's symbol table to grow.  You might want to
add some logic that keeps track of the process size, or restarts
itself after a certain number of requests, to ensure that memory
consumption is minimized.  You'll also want to scope your variables
with L<perlfunc/my> whenever possible.


 package Embed::Persistent;
 #persistent.pl

 use strict;
 use vars '%Cache';
 use Symbol qw(delete_package);

 sub valid_package_name {
     my($string) = @@_;
     $string =~ s/([^A-Za-z0-9\/])/sprintf("_%2x",unpack("C",$1))/eg;
     # second pass only for words starting with a digit
     $string =~ s|/(\d)|sprintf("/_%2x",unpack("C",$1))|eg;

     # Dress it up as a real package name
     $string =~ s|/|::|g;
     return "Embed" . $string;
 }

 sub eval_file {
     my($filename, $delete) = @@_;
     my $package = valid_package_name($filename);
     my $mtime = -M $filename;
     if(defined $Cache{$package}{mtime}
        &&
        $Cache{$package}{mtime} <= $mtime)
     {
        # we have compiled this subroutine already,
        # it has not been updated on disk, nothing left to do
        print STDERR "already compiled $package->handler\n";
     }
     else {
        local *FH;
        open FH, $filename or die "open '$filename' $!";
        local($/) = undef;
        my $sub = <FH>;
        close FH;

        #wrap the code into a subroutine inside our unique package
        my $eval = qq{package $package; sub handler { $sub; }};
        {
            # hide our variables within this block
            my($filename,$mtime,$package,$sub);
            eval $eval;
        }
        die $@@ if $@@;

        #cache it unless we're cleaning out each time
        $Cache{$package}{mtime} = $mtime unless $delete;
     }

     eval {$package->handler;};
     die $@@ if $@@;

     delete_package($package) if $delete;

     #take a look if you want
     #print Devel::Symdump->rnew($package)->as_string, $/;
 }

 1;

 __END__

 /* persistent.c */
 #include <EXTERN.h>
 #include <perl.h>

 /* 1 = clean out filename's symbol table after each request, 0 = don't */
 #ifndef DO_CLEAN
 #define DO_CLEAN 0
 #endif

 static PerlInterpreter *perl = NULL;

 int
 main(int argc, char **argv, char **env)
 {
     char *embedding[] = { "", "persistent.pl" };
     char *args[] = { "", DO_CLEAN, NULL };
     char filename [1024];
     int exitstatus = 0;
     STRLEN n_a;

     if((perl = perl_alloc()) == NULL) {
        fprintf(stderr, "no memory!");
        exit(1);
     }
     perl_construct(perl);

     exitstatus = perl_parse(perl, NULL, 2, embedding, NULL);

     if(!exitstatus) {
        exitstatus = perl_run(perl);

        while(printf("Enter file name: ") && gets(filename)) {

            /* call the subroutine, passing it the filename as an argument */
            args[0] = filename;
            perl_call_argv("Embed::Persistent::eval_file",
                           G_DISCARD | G_EVAL, args);

            /* check $@@ */
            if(SvTRUE(ERRSV))
                fprintf(stderr, "eval error: %s\n", SvPV(ERRSV,n_a));
        }
     }

     PL_perl_destruct_level = 0;
     perl_destruct(perl);
     perl_free(perl);
     exit(exitstatus);
 }

Now compile:

 % cc -o persistent persistent.c `perl -MExtUtils::Embed -e ccopts -e ldopts`

Here's a example script file:

 #test.pl
 my $string = "hello";
 foo($string);

 sub foo {
     print "foo says: @@_\n";
 }

Now run:

 % persistent
 Enter file name: test.pl
 foo says: hello
 Enter file name: test.pl
 already compiled Embed::test_2epl->handler
 foo says: hello
 Enter file name: ^C

=head2 Maintaining multiple interpreter instances

Some rare applications will need to create more than one interpreter
during a session.  Such an application might sporadically decide to
release any resources associated with the interpreter.

The program must take care to ensure that this takes place I<before>
the next interpreter is constructed.  By default, the global variable
C<PL_perl_destruct_level> is set to C<0>, since extra cleaning isn't
needed when a program has only one interpreter.

Setting C<PL_perl_destruct_level> to C<1> makes everything squeaky clean:

 PL_perl_destruct_level = 1;

 while(1) {
     ...
     /* reset global variables here with PL_perl_destruct_level = 1 */
     perl_construct(my_perl);
     ...
     /* clean and reset _everything_ during perl_destruct */
     perl_destruct(my_perl);
     perl_free(my_perl);
     ...
     /* let's go do it again! */
 }

When I<perl_destruct()> is called, the interpreter's syntax parse tree
and symbol tables are cleaned up, and global variables are reset.

Now suppose we have more than one interpreter instance running at the
same time.  This is feasible, but only if you used the
C<-DMULTIPLICITY> flag when building Perl.  By default, that sets
C<PL_perl_destruct_level> to C<1>.

Let's give it a try:


 #include <EXTERN.h>
 #include <perl.h>

 /* we're going to embed two interpreters */
 /* we're going to embed two interpreters */

 #define SAY_HELLO "-e", "print qq(Hi, I'm $^X\n)"

 int main(int argc, char **argv, char **env)
 {
     PerlInterpreter
         *one_perl = perl_alloc(),
         *two_perl = perl_alloc();
     char *one_args[] = { "one_perl", SAY_HELLO };
     char *two_args[] = { "two_perl", SAY_HELLO };

     perl_construct(one_perl);
     perl_construct(two_perl);

     perl_parse(one_perl, NULL, 3, one_args, (char **)NULL);
     perl_parse(two_perl, NULL, 3, two_args, (char **)NULL);

     perl_run(one_perl);
     perl_run(two_perl);

     perl_destruct(one_perl);
     perl_destruct(two_perl);

     perl_free(one_perl);
     perl_free(two_perl);
 }


Compile as usual:

 % cc -o multiplicity multiplicity.c `perl -MExtUtils::Embed -e ccopts -e ldopts`

Run it, Run it:

 % multiplicity
 Hi, I'm one_perl
 Hi, I'm two_perl

=head2 Using Perl modules, which themselves use C libraries, from your C program

If you've played with the examples above and tried to embed a script
that I<use()>s a Perl module (such as I<Socket>) which itself uses a C or C++ library,
this probably happened:


 Can't load module Socket, dynamic loading not available in this perl.
  (You may need to build a new perl executable which either supports
  dynamic loading or has the Socket module statically linked into it.)


What's wrong?

Your interpreter doesn't know how to communicate with these extensions
on its own.  A little glue will help.  Up until now you've been
calling I<perl_parse()>, handing it NULL for the second argument:

 perl_parse(my_perl, NULL, argc, my_argv, NULL);

That's where the glue code can be inserted to create the initial contact between
Perl and linked C/C++ routines.  Let's take a look some pieces of I<perlmain.c>
to see how Perl does this:


 #ifdef __cplusplus
 #  define EXTERN_C extern "C"
 #else
 #  define EXTERN_C extern
 #endif

 static void xs_init _((void));

 EXTERN_C void boot_DynaLoader _((CV* cv));
 EXTERN_C void boot_Socket _((CV* cv));


 EXTERN_C void
 xs_init()
 {
        char *file = __FILE__;
        /* DynaLoader is a special case */
        newXS("DynaLoader::boot_DynaLoader", boot_DynaLoader, file);
        newXS("Socket::bootstrap", boot_Socket, file);
 }

Simply put: for each extension linked with your Perl executable
(determined during its initial configuration on your
computer or when adding a new extension),
a Perl subroutine is created to incorporate the extension's
routines.  Normally, that subroutine is named
I<Module::bootstrap()> and is invoked when you say I<use Module>.  In
turn, this hooks into an XSUB, I<boot_Module>, which creates a Perl
counterpart for each of the extension's XSUBs.  Don't worry about this
part; leave that to the I<xsubpp> and extension authors.  If your
extension is dynamically loaded, DynaLoader creates I<Module::bootstrap()>
for you on the fly.  In fact, if you have a working DynaLoader then there
is rarely any need to link in any other extensions statically.


Once you have this code, slap it into the second argument of I<perl_parse()>:


 perl_parse(my_perl, xs_init, argc, my_argv, NULL);


Then compile:

 % cc -o interp interp.c `perl -MExtUtils::Embed -e ccopts -e ldopts`

 % interp
   use Socket;
   use SomeDynamicallyLoadedModule;

   print "Now I can use extensions!\n"'

B<ExtUtils::Embed> can also automate writing the I<xs_init> glue code.

 % perl -MExtUtils::Embed -e xsinit -- -o perlxsi.c
 % cc -c perlxsi.c `perl -MExtUtils::Embed -e ccopts`
 % cc -c interp.c  `perl -MExtUtils::Embed -e ccopts`
 % cc -o interp perlxsi.o interp.o `perl -MExtUtils::Embed -e ldopts`

Consult L<perlxs> and L<perlguts> for more details.

=head1 Embedding Perl under Win32

At the time of this writing (5.004), there are two versions of Perl
which run under Win32.  (The two versions are merging in 5.005.)
Interfacing to ActiveState's Perl library is quite different from the
examples in this documentation, as significant changes were made to
the internal Perl API.  However, it is possible to embed ActiveState's
Perl runtime.  For details, see the Perl for Win32 FAQ at
http://www.perl.com/CPAN/doc/FAQs/win32/perlwin32faq.html.

With the "official" Perl version 5.004 or higher, all the examples
within this documentation will compile and run untouched, although
the build process is slightly different between Unix and Win32.  

For starters, backticks don't work under the Win32 native command shell.
The ExtUtils::Embed kit on CPAN ships with a script called
B<genmake>, which generates a simple makefile to build a program from
a single C source file.  It can be used like this:

 C:\ExtUtils-Embed\eg> perl genmake interp.c
 C:\ExtUtils-Embed\eg> nmake
 C:\ExtUtils-Embed\eg> interp -e "print qq{I'm embedded in Win32!\n}"

You may wish to use a more robust environment such as the Microsoft
Developer Studio.  In this case, run this to generate perlxsi.c:

 perl -MExtUtils::Embed -e xsinit

Create a new project and Insert -> Files into Project: perlxsi.c,
perl.lib, and your own source files, e.g. interp.c.  Typically you'll
find perl.lib in B<C:\perl\lib\CORE>, if not, you should see the
B<CORE> directory relative to C<perl -V:archlib>.  The studio will
also need this path so it knows where to find Perl include files.
This path can be added via the Tools -> Options -> Directories menu.
Finally, select Build -> Build interp.exe and you're ready to go.

d551 1
a551 1
you can always I<write code faster> in Perl.  Because you can use
d557 9
a565 35
Jon Orwant <F<orwant@@tpj.com>> and Doug MacEachern
<F<dougm@@osf.org>>, with small contributions from Tim Bunce, Tom
Christiansen, Guy Decoux, Hallvard Furuseth, Dov Grobgeld, and Ilya
Zakharevich.

Doug MacEachern has an article on embedding in Volume 1, Issue 4 of
The Perl Journal (http://tpj.com).  Doug is also the developer of the
most widely-used Perl embedding: the mod_perl system
(perl.apache.org), which embeds Perl in the Apache web server.
Oracle, Binary Evolution, ActiveState, and Ben Sugars's nsapi_perl
have used this model for Oracle, Netscape and Internet Information
Server Perl plugins.

July 22, 1998

=head1 COPYRIGHT

Copyright (C) 1995, 1996, 1997, 1998 Doug MacEachern and Jon Orwant.  All
Rights Reserved.

Permission is granted to make and distribute verbatim copies of this
documentation provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
documentation under the conditions for verbatim copying, provided also
that they are marked clearly as modified versions, that the authors'
names and title are unchanged (though subtitles and additional
authors' names may be added), and that the entire resulting derived
work is distributed under the terms of a permission notice identical
to this one.

Permission is granted to copy and distribute translations of this
documentation into another language, under the above conditions for
modified versions.
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d15 1
a15 1
Read L<perlxstut>, L<perlxs>, L<h2xs>, L<perlguts>, and L<perlapi>.
d203 1
a203 1
To call individual Perl subroutines, you can use any of the B<call_*>
d205 1
a205 1
In this example we'll use C<call_argv>.
d224 1
a224 1
        call_argv("showtime", G_DISCARD | G_NOARGS, args);
d260 1
a260 1
I<call_argv>.  For other data types, or to examine return values,
d268 1
a268 1
These are L<perlapi/eval_sv> and L<perlapi/eval_pv>.
d276 1
a276 1
I<eval_pv> lets us evaluate individual Perl strings, and then
d283 1
a283 1

d285 1
a285 1

d290 1
a290 1

d293 1
a293 1

d296 1
a296 1

d298 3
a300 3
       eval_pv("$a = 3; $a **= 2", TRUE);
       printf("a = %d\n", SvIV(get_sv("a", FALSE)));

d302 3
a304 3
       eval_pv("$a = 3.14; $a **= 2", TRUE);
       printf("a = %f\n", SvNV(get_sv("a", FALSE)));

d306 3
a308 3
       eval_pv("$a = 'rekcaH lreP rehtonA tsuJ'; $a = reverse($a);", TRUE);
       printf("a = %s\n", SvPV(get_sv("a", FALSE), n_a));

d313 1
a313 1
All of those strange functions with I<sv> in their names help convert Perl scalars to C types.  They're described in L<perlguts> and L<perlapi>.
d326 1
a326 1
from I<eval_pv()> instead.  Example:
d330 1
a330 1
   SV *val = eval_pv("reverse 'rekcaH lreP rehtonA tsuJ'", TRUE);
d339 1
a339 1
The I<eval_sv()> function lets us evaluate strings of Perl code, so we can
d367 3
a369 3

 /** my_eval_sv(code, error_check)
 ** kinda like eval_sv(), 
d372 1
a372 1
 SV* my_eval_sv(SV *sv, I32 croak_on_error)
d377 1
a377 1

d379 2
a380 2
     eval_sv(sv, G_SCALAR);

d384 1
a384 1

d387 1
a387 1

d390 1
a390 1

d397 1
a397 1

d402 1
a402 1

d405 2
a406 2

     retval = my_eval_sv(command, TRUE);
d408 1
a408 1

d411 1
a411 1

d419 1
a419 1

d424 1
a424 1

d427 2
a428 2

     retval = my_eval_sv(command, TRUE);
d430 2
a431 2

     *string = get_sv("string", FALSE);
d434 1
a434 1

d442 1
a442 1

d448 1
a448 1

d451 2
a452 2

     my_eval_sv(command, TRUE);
d454 2
a455 2

     *match_list = get_av("array", FALSE);
d457 1
a457 1

d460 1
a460 1

d469 1
a469 1

d472 1
a472 1

d474 1
a474 1

d479 1
a479 1

d484 1
a484 1

d488 1
a488 1

d492 1
a492 1

d500 1
a500 1

d505 1
a505 1

d542 1
a542 1
friends.  They're described in L<perlguts> and L<perlapi>.
d579 1
a579 1
      call_pv("expo", G_SCALAR);      /* call the function             */
d641 1
a641 1
after it's no longer needed.  Using L<perlapi/call_argv>, We'll
d659 1
a659 1
 our %Cache;
d753 1
a753 1
            call_argv("Embed::Persistent::eval_file",
d904 1
a904 1
 static void xs_init (void);
d906 2
a907 2
 EXTERN_C void boot_DynaLoader (CV* cv);
 EXTERN_C void boot_Socket (CV* cv);
d956 1
a956 1
Consult L<perlxs>, L<perlguts>, and L<perlapi> for more details.
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d40 1
a40 1
=item *
d42 1
a42 1
Compiling your C program
d44 1
a44 1
=item *
d46 1
a46 1
Adding a Perl interpreter to your C program
d48 1
a48 1
=item *
d50 1
a50 1
Calling a Perl subroutine from your C program
d52 1
a52 1
=item *
d54 1
a54 1
Evaluating a Perl statement from your C program
d56 1
a56 1
=item *
d58 1
a58 21
Performing Perl pattern matches and substitutions from your C program

=item *

Fiddling with the Perl stack from your C program

=item *

Maintaining a persistent interpreter

=item *

Maintaining multiple interpreter instances

=item *

Using Perl modules, which themselves use C libraries, from your C program

=item *

Embedding Perl under Win32
d261 3
a263 2
you'll need to manipulate the Perl stack.  That's demonstrated in
L<Fiddling with the Perl stack from your C program>.
d359 1
a359 1
matches() evaluates C<$string =~ $pattern> in a list context, and
d437 1
a437 1
 ** Used for matches in a list context.
d799 1
a799 2
the next interpreter is constructed.  By default, when perl is not
built with any special options, the global variable
d801 1
a801 2
usually needed when a program only ever creates a single interpreter
in its entire lifetime.
d823 3
a825 10
same time.  This is feasible, but only if you used the Configure option
C<-Dusemultiplicity> or the options C<-Dusethreads -Duseithreads> when
building Perl.  By default, enabling one of these Configure options
sets the per-interpreter global variable C<PL_perl_destruct_level> to
C<1>, so that thorough cleaning is automatic.

Using C<-Dusethreads -Duseithreads> rather than C<-Dusemultiplicity>
is more appropriate if you intend to run multiple interpreters
concurrently in different threads, because it enables support for
linking in the thread libraries of your system with the interpreter.
a845 1
     PERL_SET_CONTEXT(one_perl);
a846 1
     PERL_SET_CONTEXT(two_perl);
a848 1
     PERL_SET_CONTEXT(one_perl);
a849 1
     PERL_SET_CONTEXT(two_perl);
a851 1
     PERL_SET_CONTEXT(one_perl);
a852 1
     PERL_SET_CONTEXT(two_perl);
a854 1
     PERL_SET_CONTEXT(one_perl);
a855 1
     PERL_SET_CONTEXT(two_perl);
a857 1
     PERL_SET_CONTEXT(one_perl);
a858 1
     PERL_SET_CONTEXT(two_perl);
a861 9
Note the calls to PERL_SET_CONTEXT().  These are necessary to initialize
the global state that tracks which interpreter is the "current" one on
the particular process or thread that may be running it.  It should
always be used if you have more than one interpreter and are making
perl API calls on both interpreters in an interleaved fashion.

PERL_SET_CONTEXT(interp) should also be called whenever C<interp> is
used by a thread that did not create it (using either perl_alloc(), or
the more esoteric perl_clone()).
a896 1
 static void xs_init (pTHX);
d898 10
a907 2
 EXTERN_C void boot_DynaLoader (pTHX_ CV* cv);
 EXTERN_C void boot_Socket (pTHX_ CV* cv);
d911 1
a911 1
 xs_init(pTHX)
d960 11
a970 2
In general, all of the source code shown here should work unmodified under
Windows.
d972 1
a972 2
However, there are some caveats about the command-line examples shown.
For starters, backticks won't work under the Win32 native command shell.
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d164 2
a165 2
http://www.perl.com/perl/CPAN/modules/by-module/ExtUtils/
(If this documentation came from your Perl distribution, then you're
a187 1
	PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
a240 1
	PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
d273 4
a276 3
In this particular case we don't have to call I<perl_run>, as we set 
the PL_exit_flag PERL_EXIT_DESTRUCT_END which executes END blocks in
perl_destruct.
a313 1
       PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
a490 1
     PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
a614 1
      PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
d764 1
a764 1
     PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
d791 1
a791 1
Here's an example script file:
a810 8
=head2 Execution of END blocks

Traditionally END blocks have been executed at the end of the perl_run.
This causes problems for applications that never call perl_run. Since
perl 5.7.2 you can specify C<PL_exit_flags |= PERL_EXIT_DESTRUCT_END>
to get the new behaviour. This also enables the running of END blocks if
the perl_prase fails and C<perl_destruct> will return the exit value.

d1041 1
a1041 1
The Perl Journal ( http://www.tpj.com/ ).  Doug is also the developer of the
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@a185 1
	PERL_SYS_INIT3(&argc,&argv,&env);
a192 1
	PERL_SYS_TERM();
d197 1
a197 5
C<NULL>, which means that the current environment will be used.  The macros
PERL_SYS_INIT3() and PERL_SYS_TERM() provide system-specific tune up 
of the C runtime environment necessary to run Perl interpreters; since
PERL_SYS_INIT3() may change C<env>, it may be more appropriate to provide
C<env> as an argument to perl_parse().
a237 1
	PERL_SYS_INIT3(&argc,&argv,&env);
a249 1
	PERL_SYS_TERM();
a310 1
       PERL_SYS_INIT3(&argc,&argv,&env);
a331 1
       PERL_SYS_TERM();
d374 1
a374 1
within the C<SV> as according to the operation, returning the number of substitutions
a388 2
 static PerlInterpreter *my_perl;

d484 1
d488 1
a488 1
     SV *text;
a490 2
     PERL_SYS_INIT3(&argc,&argv,&env);
     my_perl = perl_alloc();
a494 1
     text = NEWSV(1099,0);
a531 1
     PERL_SYS_TERM();
a613 1
      PERL_SYS_INIT3(&argc,&argv,&env);
a624 1
      PERL_SYS_TERM();
d750 1
a750 3
 #define BUFFER_SIZE 1024

 static PerlInterpreter *my_perl = NULL;
d757 1
a757 1
     char filename[BUFFER_SIZE];
d761 1
a761 2
     PERL_SYS_INIT3(&argc,&argv,&env);
     if((my_perl = perl_alloc()) == NULL) {
d765 1
a765 1
     perl_construct(my_perl);
d767 1
a767 1
     exitstatus = perl_parse(my_perl, NULL, 2, embedding, NULL);
d770 1
a770 1
        exitstatus = perl_run(my_perl);
d772 1
a772 2
        while(printf("Enter file name: ") &&
              fgets(filename, BUFFER_SIZE, stdin)) {
a773 1
            filename[strlen(filename)-1] = '\0'; /* strip \n */
d786 2
a787 3
     perl_destruct(my_perl);
     perl_free(my_perl);
     PERL_SYS_TERM();
d821 1
a821 1
the perl_parse fails and C<perl_destruct> will return the exit value.
d838 2
a842 1
     PL_perl_destruct_level = 1;
a845 1
     PL_perl_destruct_level = 1;
d853 1
a853 3
and symbol tables are cleaned up, and global variables are reset.  The
second assignment to C<PL_perl_destruct_level> is needed because
perl_construct resets it to C<0>.
d858 1
a858 1
building perl.  By default, enabling one of these Configure options
d860 1
a860 7
C<1>, so that thorough cleaning is automatic and interpreter variables
are initialized correctly.  Even if you don't intend to run two or
more interpreters at the same time, but to run them sequentially, like
in the above example, it is recommended to build perl with the
C<-Dusemultiplicity> option otherwise some interpreter variables may
not be initialized correctly between consecutive runs and your
application may crash.
d880 3
a882 1
     PerlInterpreter *one_perl, *two_perl;
a885 4
     PERL_SYS_INIT3(&argc,&argv,&env);
     one_perl = perl_alloc();
     two_perl = perl_alloc();

a909 1
     PERL_SYS_TERM();
a1037 18
=head1 Hiding Perl_

If you completely hide the short forms forms of the Perl public API,
add -DPERL_NO_SHORT_NAMES to the compilation flags.  This means that
for example instead of writing

    warn("%d bottles of beer on the wall", bottlecount);

you will have to write the explicit full form

    Perl_warn(aTHX_ "%d bottles of beer on the wall", bottlecount);

(See L<perlguts/Background and PERL_IMPLICIT_CONTEXT for the explanation
of the C<aTHX_>.> )  Hiding the short forms is very useful for avoiding
all sorts of nasty (C preprocessor or otherwise) conflicts with other
software packages (Perl defines about 2400 APIs with these short names,
take or leave few hundred, so there certainly is room for conflict.)

d1047 2
a1048 2
Jon Orwant <F<orwant@@media.mit.edu>> and Doug MacEachern
<F<dougm@@covalent.net>>, with small contributions from Tim Bunce, Tom
@


1.1.1.7
log
@perl 5.8.3 from CPAN
@
text
@d509 1
a509 10
     sv_setpv(text, "When he is at a convenience store and the "
	"bill comes to some amount like 76 cents, Maynard is "
	"aware that there is something he *should* do, something "
	"that will enable him to get back a quarter, but he has "
	"no idea *what*.  He fumbles through his red squeezey "
	"changepurse and gives the boy three extra pennies with "
	"his dollar, hoping that he might luck into the correct "
	"amount.  The boy gives him back two of his own pennies "
	"and then the big shiny quarter that is his prize. "
	"-RICHH");
@


1.1.1.8
log
@perl 5.8.8 import
@
text
@d1121 2
@


1.1.1.9
log
@import perl 5.10.0 from CPAN
@
text
@d176 1
a176 1
included in the source distribution.  Here's a bastardized, non-portable
d355 1
a355 1
store the computed value of our eval'ed expression.  It is also
d433 1
a433 1
     SV *command = newSV(0), *retval;
d455 1
a455 1
     SV *command = newSV(0), *retval;
d478 1
a478 1
     SV *command = newSV(0);
d508 1
a508 1
     text = newSV(0);
a795 1
     PL_origalen = 1; /* don't let $0 assignment update the proctitle or embedding[0] */
a854 15
=head2 $0 assignments

When a perl script assigns a value to $0 then the perl runtime will
try to make this value show up as the program name reported by "ps" by
updating the memory pointed to by the argv passed to perl_parse() and
also calling API functions like setproctitle() where available.  This
behaviour might not be appropriate when embedding perl and can be
disabled by assigning the value C<1> to the variable C<PL_origalen>
before perl_parse() is called.

The F<persistent.c> example above is for instance likely to segfault
when $0 is assigned to if the C<PL_origalen = 1;> assignment is
removed.  This because perl will try to write to the read only memory
of the C<embedding[]> strings.

a900 2

See also L<perlxs/Thread-aware system interfaces>.
@


1.1.1.10
log
@import perl 5.10.1
@
text
@d199 5
a203 14
C<NULL>, which means that the current environment will be used.

The macros PERL_SYS_INIT3() and PERL_SYS_TERM() provide system-specific
tune up of the C runtime environment necessary to run Perl interpreters;
they should only be called once regardless of how many interpreters you
create or destroy. Call PERL_SYS_INIT3() before you create your first
interpreter, and PERL_SYS_TERM() after you free your last interpreter.

Since PERL_SYS_INIT3() may change C<env>, it may be more appropriate to
provide C<env> as an argument to perl_parse().

Also notice that no matter what arguments you pass to perl_parse(),
PERL_SYS_INIT3() must be invoked on the C main() argc, argv and env and
only once.
d316 1
d329 1
a329 1
       printf("a = %d\n", SvIV(get_sv("a", 0)));
d333 1
a333 1
       printf("a = %f\n", SvNV(get_sv("a", 0)));
d337 1
a337 1
       printf("a = %s\n", SvPV_nolen(get_sv("a", 0)));
d360 1
d362 1
a362 1
   printf("%s\n", SvPV_nolen(val));
d409 1
a409 1

d419 1
a419 1
 	croak(SvPVx_nolen(ERRSV));
d434 1
d437 1
a437 1
 	      SvPV_nolen(string), pattern);
d456 1
d459 1
a459 1
 	      SvPV_nolen(*string), pattern);
d464 1
a464 1
     *string = get_sv("string", 0);
d480 1
d483 1
a483 1
 	      SvPV_nolen(string), pattern);
d488 1
a488 1
     *match_list = get_av("array", 0);
d500 1
d535 1
a535 1
 	printf("match: %s\n", SvPV_nolen(*av_fetch(match_list, i, FALSE)));
d543 1
a543 1
 	printf("Now text is: %s\n\n", SvPV_nolen(text));
d787 1
d813 1
a813 1
                fprintf(stderr, "eval error: %s\n", SvPV_nolen(ERRSV));
@


1.1.1.11
log
@Perl 5.12.2 from CPAN
@
text
@d1103 1
a1103 1
If you completely hide the short forms of the Perl public API,
@


1.1.1.12
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d493 1
a493 1
     num_matches = av_len(*match_list) + 1;
d934 1
d1073 28
d1113 2
a1114 2
(See L<perlguts/"Background and PERL_IMPLICIT_CONTEXT"> for the explanation
of the C<aTHX_>. )  Hiding the short forms is very useful for avoiding
d1146 15
a1160 1
This document may be distributed under the same terms as Perl itself.
@


1.1.1.13
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d493 1
a493 1
     num_matches = av_top_index(*match_list) + 1;
@


1.1.1.14
log
@Import perl-5.20.1
@
text
@d23 1
a23 1
Read about L<perlfunc/do> and L<perlfunc/eval> and L<perlfunc/require>
d80 1
a80 1
=back
d128 1
a128 1
(That's all one line.)  On my DEC Alpha running old 5.003_05, the
d179 2
a180 2
 #include <EXTERN.h>               /* from the Perl distribution     */
 #include <perl.h>                 /* from the Perl distribution     */
d182 1
a182 1
 static PerlInterpreter *my_perl;  /***    The Perl interpreter    ***/
d184 2
a185 2
 int main(int argc, char **argv, char **env)
 {
d195 1
a195 1
 }
d275 5
a279 1
 print "I shan't be printed.";
d281 1
a281 3
 sub showtime {
     print time;
 }
d283 1
a283 1
Simple enough. Now compile and run:
d285 2
a286 4
 % cc -o showtime showtime.c \
     `perl -MExtUtils::Embed -e ccopts -e ldopts`
 % showtime showtime.pl
 818284590
d292 1
a292 1
In this particular case we don't have to call I<perl_run>, as we set
d318 8
a325 2
 #include <EXTERN.h>
 #include <perl.h>
d327 3
a329 1
 static PerlInterpreter *my_perl;
d331 3
a333 3
 main (int argc, char **argv, char **env)
 {
     char *embedding[] = { "", "-e", "0" };
d335 3
a337 3
     PERL_SYS_INIT3(&argc,&argv,&env);
     my_perl = perl_alloc();
     perl_construct( my_perl );
d339 3
a341 3
     perl_parse(my_perl, NULL, 3, embedding, NULL);
     PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
     perl_run(my_perl);
d343 3
a345 12
     /** Treat $a as an integer **/
     eval_pv("$a = 3; $a **= 2", TRUE);
     printf("a = %d\n", SvIV(get_sv("a", 0)));

     /** Treat $a as a float **/
     eval_pv("$a = 3.14; $a **= 2", TRUE);
     printf("a = %f\n", SvNV(get_sv("a", 0)));

     /** Treat $a as a string **/
     eval_pv(
       "$a = 'rekcaH lreP rehtonA tsuJ'; $a = reverse($a);", TRUE);
     printf("a = %s\n", SvPV_nolen(get_sv("a", 0)));
d347 4
a350 4
     perl_destruct(my_perl);
     perl_free(my_perl);
     PERL_SYS_TERM();
 }
d352 1
a352 2
All of those strange functions with I<sv> in their names help convert Perl
scalars to C types.  They're described in L<perlguts> and L<perlapi>.
d391 2
a392 2
within the C<SV> as according to the operation, returning the number of
substitutions made.
d394 1
a394 1
   SSize_t matches(SV *string, char *pattern, AV **matches);
d398 1
a398 2
fills in I<matches> with the array elements, returning the number of matches
found.
d409 2
a410 2
 ** kinda like eval_sv(),
 ** but we pop the return value off the stack
d453 1
a453 2
 ** Used for =~ operations that
 ** modify their left-hand side (s/// and tr///)
d481 1
a481 1
 SSize_t matches(SV *string, char *pattern, AV **match_list)
d484 1
a484 1
     SSize_t num_matches;
d538 1
a538 2
         printf("match: %s\n",
                  SvPV_nolen(*av_fetch(match_list, i, FALSE)));
d544 2
a545 2
 	printf("substitute: s/[aeiou]//gi...%lu substitutions made.\n",
 	       (unsigned long)num_matches);
d563 1
a563 1
  match: Text contains the word 'quarter'.
d565 1
a565 1
  match: Text doesn't contain the word 'eighth'.
d567 10
a576 11
  matches: m/(wi..)/g found 2 matches...
  match: will
  match: with

  substitute: s/[aeiou]//gi...139 substitutions made.
  Now text is: Whn h s t  cnvnnc str nd th bll cms t sm mnt lk 76 cnts,
  Mynrd s wr tht thr s smthng h *shld* d, smthng tht wll nbl hm t gt
  bck qrtr, bt h hs n d *wht*.  H fmbls thrgh hs rd sqzy chngprs nd
  gvs th by thr xtr pnns wth hs dllr, hpng tht h mght lck nt th crrct
  mnt.  Th by gvs hm bck tw f hs wn pnns nd thn th bg shny qrtr tht s
  hs prz. -RCHH
d578 1
a578 1
  substitute: s/Perl/C...No substitution made.
d613 2
a614 2
 #include <EXTERN.h>
 #include <perl.h>
d616 1
a616 1
 static PerlInterpreter *my_perl;
d618 18
a635 18
 static void
 PerlPower(int a, int b)
 {
   dSP;                            /* initialize stack pointer      */
   ENTER;                          /* everything created after here */
   SAVETMPS;                       /* ...is a temporary variable.   */
   PUSHMARK(SP);                   /* remember the stack pointer    */
   XPUSHs(sv_2mortal(newSViv(a))); /* push the base onto the stack  */
   XPUSHs(sv_2mortal(newSViv(b))); /* push the exponent onto stack  */
   PUTBACK;                      /* make local stack pointer global */
   call_pv("expo", G_SCALAR);      /* call the function             */
   SPAGAIN;                        /* refresh stack pointer         */
                                 /* pop the return value from stack */
   printf ("%d to the %dth power is %d.\n", a, b, POPi);
   PUTBACK;
   FREETMPS;                       /* free that return value        */
   LEAVE;                       /* ...and the XPUSHed "mortal" args.*/
 }
d637 3
a639 3
 int main (int argc, char **argv, char **env)
 {
   char *my_argv[] = { "", "power.pl" };
d641 3
a643 3
   PERL_SYS_INIT3(&argc,&argv,&env);
   my_perl = perl_alloc();
   perl_construct( my_perl );
d645 3
a647 3
   perl_parse(my_perl, NULL, 2, my_argv, (char **)NULL);
   PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
   perl_run(my_perl);
d649 1
a649 1
   PerlPower(3, 4);                      /*** Compute 3 ** 4 ***/
d651 4
a654 4
   perl_destruct(my_perl);
   perl_free(my_perl);
   PERL_SYS_TERM();
 }
d774 1
a774 3
 /* 1 = clean out filename's symbol table after each request,
    0 = don't
 */
d798 1
a798 2
     PL_origalen = 1; /* don't let $0 assignment update the
                         proctitle or embedding[0] */
d808 1
a808 2
            /* call the subroutine,
                     passing it the filename as an argument */
d828 1
a828 2
 % cc -o persistent persistent.c \
        `perl -MExtUtils::Embed -e ccopts -e ldopts`
d986 1
a986 2
 % cc -o multiplicity multiplicity.c \
  `perl -MExtUtils::Embed -e ccopts -e ldopts`
d994 1
a994 2
=head2 Using Perl modules, which themselves use C libraries, from your C
program
d997 2
a998 2
that I<use()>s a Perl module (such as I<Socket>) which itself uses a C or C++
library, this probably happened:
d1014 3
a1016 3
That's where the glue code can be inserted to create the initial contact
between Perl and linked C/C++ routines. Let's take a look some pieces of
I<perlmain.c> to see how Perl does this:
a1070 19

=head2 Using embedded Perl with POSIX locales

(See L<perllocale> for information about these.)
When a Perl interpreter normally starts up, it tells the system it wants
to use the system's default locale.  This is often, but not necessarily,
the "C" or "POSIX" locale.  Absent a S<C<"use locale">> within the perl
code, this mostly has no effect (but see L<perllocale/Not within the
scope of any "use locale" variant>).  Also, there is not a problem if the
locale you want to use in your embedded Perl is the same as the system
default.  However, this doesn't work if you have set up and want to use
a locale that isn't the system default one.  Starting in Perl v5.20, you
can tell the embedded Perl interpreter that the locale is already
properly set up, and to skip doing its own normal initialization.  It
skips if the environment variable C<PERL_SKIP_LOCALE_INIT> is set (even
if set to 0 or C<"">).  A Perl that has this capability will define the
C pre-processor symbol C<HAS_SKIP_LOCALE_INIT>.  This allows code that
has to work with multiple Perl versions to do some sort of work-around
when confronted with an earlier Perl.
@


1.1.1.15
log
@Import perl-5.24.2
@
text
@d1092 1
a1092 1
scope of "use locale">).  Also, there is not a problem if the
@


