head	1.2;
access;
symbols
	OPENBSD_6_0:1.1.1.7.0.8
	OPENBSD_6_0_BASE:1.1.1.7
	OPENBSD_5_9:1.1.1.7.0.2
	OPENBSD_5_9_BASE:1.1.1.7
	OPENBSD_5_8:1.1.1.7.0.4
	OPENBSD_5_8_BASE:1.1.1.7
	PERL_5_20_2:1.1.1.7
	OPENBSD_5_7:1.1.1.6.0.2
	OPENBSD_5_7_BASE:1.1.1.6
	PERL_5_20_1:1.1.1.6
	OPENBSD_5_6:1.1.1.5.0.4
	OPENBSD_5_6_BASE:1.1.1.5
	PERL_5_18_2:1.1.1.5
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.4.0.6
	OPENBSD_5_5_BASE:1.1.1.4
	OPENBSD_5_4:1.1.1.4.0.2
	OPENBSD_5_4_BASE:1.1.1.4
	PERL_5_16_3:1.1.1.4
	OPENBSD_5_3:1.1.1.3.0.10
	OPENBSD_5_3_BASE:1.1.1.3
	OPENBSD_5_2:1.1.1.3.0.8
	OPENBSD_5_2_BASE:1.1.1.3
	OPENBSD_5_1_BASE:1.1.1.3
	OPENBSD_5_1:1.1.1.3.0.6
	OPENBSD_5_0:1.1.1.3.0.4
	OPENBSD_5_0_BASE:1.1.1.3
	OPENBSD_4_9:1.1.1.3.0.2
	OPENBSD_4_9_BASE:1.1.1.3
	PERL_5_12_2:1.1.1.3
	OPENBSD_4_8:1.1.1.2.0.4
	OPENBSD_4_8_BASE:1.1.1.2
	OPENBSD_4_7:1.1.1.2.0.2
	OPENBSD_4_7_BASE:1.1.1.2
	PERL_5_10_1:1.1.1.2
	OPENBSD_4_6:1.1.1.1.0.6
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.2
	OPENBSD_4_5_BASE:1.1.1.1
	PERL_5_10_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.19;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2008.09.29.17.18.57;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.09.29.17.18.57;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2009.10.12.18.10.40;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2010.09.24.14.49.10;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.03.25.20.09.24;	author sthen;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.03.24.14.59.08;	author afresh1;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.11.17.20.53.15;	author afresh1;	state Exp;
branches;
next	1.1.1.7;
commitid	B31cAbBIXiCqnL97;

1.1.1.7
date	2015.04.25.19.10.44;	author afresh1;	state Exp;
branches;
next	;
commitid	Wpcs5S8qILgEZC7F;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@=head1 NAME
X<character class>

perlrecharclass - Perl Regular Expression Character Classes

=head1 DESCRIPTION

The top level documentation about Perl regular expressions
is found in L<perlre>.

This manual page discusses the syntax and use of character
classes in Perl regular expressions.

A character class is a way of denoting a set of characters
in such a way that one character of the set is matched.
It's important to remember that: matching a character class
consumes exactly one character in the source string. (The source
string is the string the regular expression is matched against.)

There are three types of character classes in Perl regular
expressions: the dot, backslash sequences, and the form enclosed in square
brackets.  Keep in mind, though, that often the term "character class" is used
to mean just the bracketed form.  Certainly, most Perl documentation does that.

=head2 The dot

The dot (or period), C<.> is probably the most used, and certainly
the most well-known character class. By default, a dot matches any
character, except for the newline. That default can be changed to
add matching the newline by using the I<single line> modifier: either
for the entire regular expression with the C</s> modifier, or
locally with C<(?s)>.  (The C<L</\N>> backslash sequence, described
below, matches any character except newline without regard to the
I<single line> modifier.)

Here are some examples:

 "a"  =~  /./       # Match
 "."  =~  /./       # Match
 ""   =~  /./       # No match (dot has to match a character)
 "\n" =~  /./       # No match (dot does not match a newline)
 "\n" =~  /./s      # Match (global 'single line' modifier)
 "\n" =~  /(?s:.)/  # Match (local 'single line' modifier)
 "ab" =~  /^.$/     # No match (dot matches one character)

=head2 Backslash sequences
X<\w> X<\W> X<\s> X<\S> X<\d> X<\D> X<\p> X<\P>
X<\N> X<\v> X<\V> X<\h> X<\H>
X<word> X<whitespace>

A backslash sequence is a sequence of characters, the first one of which is a
backslash.  Perl ascribes special meaning to many such sequences, and some of
these are character classes.  That is, they match a single character each,
provided that the character belongs to the specific set of characters defined
by the sequence.

Here's a list of the backslash sequences that are character classes.  They
are discussed in more detail below.  (For the backslash sequences that aren't
character classes, see L<perlrebackslash>.)

 \d             Match a decimal digit character.
 \D             Match a non-decimal-digit character.
 \w             Match a "word" character.
 \W             Match a non-"word" character.
 \s             Match a whitespace character.
 \S             Match a non-whitespace character.
 \h             Match a horizontal whitespace character.
 \H             Match a character that isn't horizontal whitespace.
 \v             Match a vertical whitespace character.
 \V             Match a character that isn't vertical whitespace.
 \N             Match a character that isn't a newline.
 \pP, \p{Prop}  Match a character that has the given Unicode property.
 \PP, \P{Prop}  Match a character that doesn't have the Unicode property

=head3 \N

C<\N>, available starting in v5.12, like the dot, matches any
character that is not a newline. The difference is that C<\N> is not influenced
by the I<single line> regular expression modifier (see L</The dot> above).  Note
that the form C<\N{...}> may mean something completely different.  When the
C<{...}> is a L<quantifier|perlre/Quantifiers>, it means to match a non-newline
character that many times.  For example, C<\N{3}> means to match 3
non-newlines; C<\N{5,}> means to match 5 or more non-newlines.  But if C<{...}>
is not a legal quantifier, it is presumed to be a named character.  See
L<charnames> for those.  For example, none of C<\N{COLON}>, C<\N{4F}>, and
C<\N{F4}> contain legal quantifiers, so Perl will try to find characters whose
names are respectively C<COLON>, C<4F>, and C<F4>.

=head3 Digits

C<\d> matches a single character considered to be a decimal I<digit>.
If the C</a> regular expression modifier is in effect, it matches [0-9].
Otherwise, it
matches anything that is matched by C<\p{Digit}>, which includes [0-9].
(An unlikely possible exception is that under locale matching rules, the
current locale might not have C<[0-9]> matched by C<\d>, and/or might match
other characters whose code point is less than 256.  The only such locale
definitions that are legal would be to match C<[0-9]> plus another set of
10 consecutive digit characters;  anything else would be in violation of
the C language standard, but Perl doesn't currently assume anything in
regard to this.)

What this means is that unless the C</a> modifier is in effect C<\d> not
only matches the digits '0' - '9', but also Arabic, Devanagari, and
digits from other languages.  This may cause some confusion, and some
security issues.

Some digits that C<\d> matches look like some of the [0-9] ones, but
have different values.  For example, BENGALI DIGIT FOUR (U+09EA) looks
very much like an ASCII DIGIT EIGHT (U+0038).  An application that
is expecting only the ASCII digits might be misled, or if the match is
C<\d+>, the matched string might contain a mixture of digits from
different writing systems that look like they signify a number different
than they actually do.  L<Unicode::UCD/num()> can
be used to safely
calculate the value, returning C<undef> if the input string contains
such a mixture.

What C<\p{Digit}> means (and hence C<\d> except under the C</a>
modifier) is C<\p{General_Category=Decimal_Number}>, or synonymously,
C<\p{General_Category=Digit}>.  Starting with Unicode version 4.1, this
is the same set of characters matched by C<\p{Numeric_Type=Decimal}>.
But Unicode also has a different property with a similar name,
C<\p{Numeric_Type=Digit}>, which matches a completely different set of
characters.  These characters are things such as C<CIRCLED DIGIT ONE>
or subscripts, or are from writing systems that lack all ten digits.

The design intent is for C<\d> to exactly match the set of characters
that can safely be used with "normal" big-endian positional decimal
syntax, where, for example 123 means one 'hundred', plus two 'tens',
plus three 'ones'.  This positional notation does not necessarily apply
to characters that match the other type of "digit",
C<\p{Numeric_Type=Digit}>, and so C<\d> doesn't match them.

The Tamil digits (U+0BE6 - U+0BEF) can also legally be
used in old-style Tamil numbers in which they would appear no more than
one in a row, separated by characters that mean "times 10", "times 100",
etc.  (See L<http://www.unicode.org/notes/tn21>.)

Any character not matched by C<\d> is matched by C<\D>.

=head3 Word characters

A C<\w> matches a single alphanumeric character (an alphabetic character, or a
decimal digit); or a connecting punctuation character, such as an
underscore ("_"); or a "mark" character (like some sort of accent) that
attaches to one of those.  It does not match a whole word.  To match a
whole word, use C<\w+>.  This isn't the same thing as matching an
English word, but in the ASCII range it is the same as a string of
Perl-identifier characters.

=over

=item If the C</a> modifier is in effect ...

C<\w> matches the 63 characters [a-zA-Z0-9_].

=item otherwise ...

=over

=item For code points above 255 ...

C<\w> matches the same as C<\p{Word}> matches in this range.  That is,
it matches Thai letters, Greek letters, etc.  This includes connector
punctuation (like the underscore) which connect two words together, or
diacritics, such as a C<COMBINING TILDE> and the modifier letters, which
are generally used to add auxiliary markings to letters.

=item For code points below 256 ...

=over

=item if locale rules are in effect ...

C<\w> matches the platform's native underscore character plus whatever
the locale considers to be alphanumeric.

=item if Unicode rules are in effect ...

C<\w> matches exactly what C<\p{Word}> matches.

=item otherwise ...

C<\w> matches [a-zA-Z0-9_].

=back

=back

=back

Which rules apply are determined as described in L<perlre/Which character set modifier is in effect?>.

There are a number of security issues with the full Unicode list of word
characters.  See L<http://unicode.org/reports/tr36>.

Also, for a somewhat finer-grained set of characters that are in programming
language identifiers beyond the ASCII range, you may wish to instead use the
more customized L</Unicode Properties>, C<\p{ID_Start}>,
C<\p{ID_Continue}>, C<\p{XID_Start}>, and C<\p{XID_Continue}>.  See
L<http://unicode.org/reports/tr31>.

Any character not matched by C<\w> is matched by C<\W>.

=head3 Whitespace

C<\s> matches any single character considered whitespace.

=over

=item If the C</a> modifier is in effect ...

In all Perl versions, C<\s> matches the 5 characters [\t\n\f\r ]; that
is, the horizontal tab,
the newline, the form feed, the carriage return, and the space.
Starting in Perl v5.18, it also matches the vertical tab, C<\cK>.
See note C<[1]> below for a discussion of this.

=item otherwise ...

=over

=item For code points above 255 ...

C<\s> matches exactly the code points above 255 shown with an "s" column
in the table below.

=item For code points below 256 ...

=over

=item if locale rules are in effect ...

C<\s> matches whatever the locale considers to be whitespace.

=item if Unicode rules are in effect ...

C<\s> matches exactly the characters shown with an "s" column in the
table below.

=item otherwise ...

C<\s> matches [\t\n\f\r ] and, starting in Perl
v5.18, the vertical tab, C<\cK>.
(See note C<[1]> below for a discussion of this.)
Note that this list doesn't include the non-breaking space.

=back

=back

=back

Which rules apply are determined as described in L<perlre/Which character set modifier is in effect?>.

Any character not matched by C<\s> is matched by C<\S>.

C<\h> matches any character considered horizontal whitespace;
this includes the platform's space and tab characters and several others
listed in the table below.  C<\H> matches any character
not considered horizontal whitespace.  They use the platform's native
character set, and do not consider any locale that may otherwise be in
use.

C<\v> matches any character considered vertical whitespace;
this includes the platform's carriage return and line feed characters (newline)
plus several other characters, all listed in the table below.
C<\V> matches any character not considered vertical whitespace.
They use the platform's native character set, and do not consider any
locale that may otherwise be in use.

C<\R> matches anything that can be considered a newline under Unicode
rules. It can match a multi-character sequence. It cannot be used inside
a bracketed character class; use C<\v> instead (vertical whitespace).
It uses the platform's
native character set, and does not consider any locale that may
otherwise be in use.
Details are discussed in L<perlrebackslash>.

Note that unlike C<\s> (and C<\d> and C<\w>), C<\h> and C<\v> always match
the same characters, without regard to other factors, such as the active
locale or whether the source string is in UTF-8 format.

One might think that C<\s> is equivalent to C<[\h\v]>. This is indeed true
starting in Perl v5.18, but prior to that, the sole difference was that the
vertical tab (C<"\cK">) was not matched by C<\s>.

The following table is a complete listing of characters matched by
C<\s>, C<\h> and C<\v> as of Unicode 6.3.

The first column gives the Unicode code point of the character (in hex format),
the second column gives the (Unicode) name. The third column indicates
by which class(es) the character is matched (assuming no locale is in
effect that changes the C<\s> matching).

 0x0009        CHARACTER TABULATION   h s
 0x000a              LINE FEED (LF)    vs
 0x000b             LINE TABULATION    vs  [1]
 0x000c              FORM FEED (FF)    vs
 0x000d        CARRIAGE RETURN (CR)    vs
 0x0020                       SPACE   h s
 0x0085             NEXT LINE (NEL)    vs  [2]
 0x00a0              NO-BREAK SPACE   h s  [2]
 0x1680            OGHAM SPACE MARK   h s
 0x2000                     EN QUAD   h s
 0x2001                     EM QUAD   h s
 0x2002                    EN SPACE   h s
 0x2003                    EM SPACE   h s
 0x2004          THREE-PER-EM SPACE   h s
 0x2005           FOUR-PER-EM SPACE   h s
 0x2006            SIX-PER-EM SPACE   h s
 0x2007                FIGURE SPACE   h s
 0x2008           PUNCTUATION SPACE   h s
 0x2009                  THIN SPACE   h s
 0x200a                  HAIR SPACE   h s
 0x2028              LINE SEPARATOR    vs
 0x2029         PARAGRAPH SEPARATOR    vs
 0x202f       NARROW NO-BREAK SPACE   h s
 0x205f   MEDIUM MATHEMATICAL SPACE   h s
 0x3000           IDEOGRAPHIC SPACE   h s

=over 4

=item [1]

Prior to Perl v5.18, C<\s> did not match the vertical tab.
C<[^\S\cK]> (obscurely) matches what C<\s> traditionally did.

=item [2]

NEXT LINE and NO-BREAK SPACE may or may not match C<\s> depending
on the rules in effect.  See
L<the beginning of this section|/Whitespace>.

=back

=head3 Unicode Properties

C<\pP> and C<\p{Prop}> are character classes to match characters that fit given
Unicode properties.  One letter property names can be used in the C<\pP> form,
with the property name following the C<\p>, otherwise, braces are required.
When using braces, there is a single form, which is just the property name
enclosed in the braces, and a compound form which looks like C<\p{name=value}>,
which means to match if the property "name" for the character has that particular
"value".
For instance, a match for a number can be written as C</\pN/> or as
C</\p{Number}/>, or as C</\p{Number=True}/>.
Lowercase letters are matched by the property I<Lowercase_Letter> which
has the short form I<Ll>. They need the braces, so are written as C</\p{Ll}/> or
C</\p{Lowercase_Letter}/>, or C</\p{General_Category=Lowercase_Letter}/>
(the underscores are optional).
C</\pLl/> is valid, but means something different.
It matches a two character string: a letter (Unicode property C<\pL>),
followed by a lowercase C<l>.

If locale rules are not in effect, the use of
a Unicode property will force the regular expression into using Unicode
rules, if it isn't already.

Note that almost all properties are immune to case-insensitive matching.
That is, adding a C</i> regular expression modifier does not change what
they match.  There are two sets that are affected.  The first set is
C<Uppercase_Letter>,
C<Lowercase_Letter>,
and C<Titlecase_Letter>,
all of which match C<Cased_Letter> under C</i> matching.
The second set is
C<Uppercase>,
C<Lowercase>,
and C<Titlecase>,
all of which match C<Cased> under C</i> matching.
(The difference between these sets is that some things, such as Roman
numerals, come in both upper and lower case, so they are C<Cased>, but
aren't considered to be letters, so they aren't C<Cased_Letter>s. They're
actually C<Letter_Number>s.)
This set also includes its subsets C<PosixUpper> and C<PosixLower>, both
of which under C</i> match C<PosixAlpha>.

For more details on Unicode properties, see L<perlunicode/Unicode
Character Properties>; for a
complete list of possible properties, see
L<perluniprops/Properties accessible through \p{} and \P{}>,
which notes all forms that have C</i> differences.
It is also possible to define your own properties. This is discussed in
L<perlunicode/User-Defined Character Properties>.

Unicode properties are defined (surprise!) only on Unicode code points.
Starting in v5.20, when matching against C<\p> and C<\P>, Perl treats
non-Unicode code points (those above the legal Unicode maximum of
0x10FFFF) as if they were typical unassigned Unicode code points.

Prior to v5.20, Perl raised a warning and made all matches fail on
non-Unicode code points.  This could be somewhat surprising:

 chr(0x110000) =~ \p{ASCII_Hex_Digit=True}     # Fails on Perls < v5.20.
 chr(0x110000) =~ \p{ASCII_Hex_Digit=False}    # Also fails on Perls
                                               # < v5.20

Even though these two matches might be thought of as complements, until
v5.20 they were so only on Unicode code points.

=head4 Examples

 "a"  =~  /\w/      # Match, "a" is a 'word' character.
 "7"  =~  /\w/      # Match, "7" is a 'word' character as well.
 "a"  =~  /\d/      # No match, "a" isn't a digit.
 "7"  =~  /\d/      # Match, "7" is a digit.
 " "  =~  /\s/      # Match, a space is whitespace.
 "a"  =~  /\D/      # Match, "a" is a non-digit.
 "7"  =~  /\D/      # No match, "7" is not a non-digit.
 " "  =~  /\S/      # No match, a space is not non-whitespace.

 " "  =~  /\h/      # Match, space is horizontal whitespace.
 " "  =~  /\v/      # No match, space is not vertical whitespace.
 "\r" =~  /\v/      # Match, a return is vertical whitespace.

 "a"  =~  /\pL/     # Match, "a" is a letter.
 "a"  =~  /\p{Lu}/  # No match, /\p{Lu}/ matches upper case letters.

 "\x{0e0b}" =~ /\p{Thai}/  # Match, \x{0e0b} is the character
                           # 'THAI CHARACTER SO SO', and that's in
                           # Thai Unicode class.
 "a"  =~  /\P{Lao}/ # Match, as "a" is not a Laotian character.

It is worth emphasizing that C<\d>, C<\w>, etc, match single characters, not
complete numbers or words. To match a number (that consists of digits),
use C<\d+>; to match a word, use C<\w+>.  But be aware of the security
considerations in doing so, as mentioned above.

=head2 Bracketed Character Classes

The third form of character class you can use in Perl regular expressions
is the bracketed character class.  In its simplest form, it lists the characters
that may be matched, surrounded by square brackets, like this: C<[aeiou]>.
This matches one of C<a>, C<e>, C<i>, C<o> or C<u>.  Like the other
character classes, exactly one character is matched.* To match
a longer string consisting of characters mentioned in the character
class, follow the character class with a L<quantifier|perlre/Quantifiers>.  For
instance, C<[aeiou]+> matches one or more lowercase English vowels.

Repeating a character in a character class has no
effect; it's considered to be in the set only once.

Examples:

 "e"  =~  /[aeiou]/        # Match, as "e" is listed in the class.
 "p"  =~  /[aeiou]/        # No match, "p" is not listed in the class.
 "ae" =~  /^[aeiou]$/      # No match, a character class only matches
                           # a single character.
 "ae" =~  /^[aeiou]+$/     # Match, due to the quantifier.

 -------

* There are two exceptions to a bracketed character class matching a
single character only.  Each requires special handling by Perl to make
things work:

=over

=item *

When the class is to match caselessly under C</i> matching rules, and a
character that is explicitly mentioned inside the class matches a
multiple-character sequence caselessly under Unicode rules, the class
will also match that sequence.  For example, Unicode says that the
letter C<LATIN SMALL LETTER SHARP S> should match the sequence C<ss>
under C</i> rules.  Thus,

 'ss' =~ /\A\N{LATIN SMALL LETTER SHARP S}\z/i             # Matches
 'ss' =~ /\A[aeioust\N{LATIN SMALL LETTER SHARP S}]\z/i    # Matches

For this to happen, the class must not be inverted (see L</Negation>)
and the character must be explicitly specified, and not be part of a
multi-character range (not even as one of its endpoints).  (L</Character
Ranges> will be explained shortly.) Therefore,

 'ss' =~ /\A[\0-\x{ff}]\z/ui       # Doesn't match
 'ss' =~ /\A[\0-\N{LATIN SMALL LETTER SHARP S}]\z/ui   # No match
 'ss' =~ /\A[\xDF-\xDF]\z/ui   # Matches on ASCII platforms, since
                               # \xDF is LATIN SMALL LETTER SHARP S,
                               # and the range is just a single
                               # element

Note that it isn't a good idea to specify these types of ranges anyway.

=item *

Some names known to C<\N{...}> refer to a sequence of multiple characters,
instead of the usual single character.  When one of these is included in
the class, the entire sequence is matched.  For example,

  "\N{TAMIL LETTER KA}\N{TAMIL VOWEL SIGN AU}"
                              =~ / ^ [\N{TAMIL SYLLABLE KAU}]  $ /x;

matches, because C<\N{TAMIL SYLLABLE KAU}> is a named sequence
consisting of the two characters matched against.  Like the other
instance where a bracketed class can match multiple characters, and for
similar reasons, the class must not be inverted, and the named sequence
may not appear in a range, even one where it is both endpoints.  If
these happen, it is a fatal error if the character class is within an
extended L<C<(?[...])>|/Extended Bracketed Character Classes>
class; and only the first code point is used (with
a C<regexp>-type warning raised) otherwise.

=back

=head3 Special Characters Inside a Bracketed Character Class

Most characters that are meta characters in regular expressions (that
is, characters that carry a special meaning like C<.>, C<*>, or C<(>) lose
their special meaning and can be used inside a character class without
the need to escape them. For instance, C<[()]> matches either an opening
parenthesis, or a closing parenthesis, and the parens inside the character
class don't group or capture.

Characters that may carry a special meaning inside a character class are:
C<\>, C<^>, C<->, C<[> and C<]>, and are discussed below. They can be
escaped with a backslash, although this is sometimes not needed, in which
case the backslash may be omitted.

The sequence C<\b> is special inside a bracketed character class. While
outside the character class, C<\b> is an assertion indicating a point
that does not have either two word characters or two non-word characters
on either side, inside a bracketed character class, C<\b> matches a
backspace character.

The sequences
C<\a>,
C<\c>,
C<\e>,
C<\f>,
C<\n>,
C<\N{I<NAME>}>,
C<\N{U+I<hex char>}>,
C<\r>,
C<\t>,
and
C<\x>
are also special and have the same meanings as they do outside a
bracketed character class.

Also, a backslash followed by two or three octal digits is considered an octal
number.

A C<[> is not special inside a character class, unless it's the start of a
POSIX character class (see L</POSIX Character Classes> below). It normally does
not need escaping.

A C<]> is normally either the end of a POSIX character class (see
L</POSIX Character Classes> below), or it signals the end of the bracketed
character class.  If you want to include a C<]> in the set of characters, you
must generally escape it.

However, if the C<]> is the I<first> (or the second if the first
character is a caret) character of a bracketed character class, it
does not denote the end of the class (as you cannot have an empty class)
and is considered part of the set of characters that can be matched without
escaping.

Examples:

 "+"   =~ /[+?*]/     #  Match, "+" in a character class is not special.
 "\cH" =~ /[\b]/      #  Match, \b inside in a character class
                      #  is equivalent to a backspace.
 "]"   =~ /[][]/      #  Match, as the character class contains
                      #  both [ and ].
 "[]"  =~ /[[]]/      #  Match, the pattern contains a character class
                      #  containing just [, and the character class is
                      #  followed by a ].

=head3 Character Ranges

It is not uncommon to want to match a range of characters. Luckily, instead
of listing all characters in the range, one may use the hyphen (C<->).
If inside a bracketed character class you have two characters separated
by a hyphen, it's treated as if all characters between the two were in
the class. For instance, C<[0-9]> matches any ASCII digit, and C<[a-m]>
matches any lowercase letter from the first half of the ASCII alphabet.

Note that the two characters on either side of the hyphen are not
necessarily both letters or both digits. Any character is possible,
although not advisable.  C<['-?]> contains a range of characters, but
most people will not know which characters that means.  Furthermore,
such ranges may lead to portability problems if the code has to run on
a platform that uses a different character set, such as EBCDIC.

If a hyphen in a character class cannot syntactically be part of a range, for
instance because it is the first or the last character of the character class,
or if it immediately follows a range, the hyphen isn't special, and so is
considered a character to be matched literally.  If you want a hyphen in
your set of characters to be matched and its position in the class is such
that it could be considered part of a range, you must escape that hyphen
with a backslash.

Examples:

 [a-z]       #  Matches a character that is a lower case ASCII letter.
 [a-fz]      #  Matches any letter between 'a' and 'f' (inclusive) or
             #  the letter 'z'.
 [-z]        #  Matches either a hyphen ('-') or the letter 'z'.
 [a-f-m]     #  Matches any letter between 'a' and 'f' (inclusive), the
             #  hyphen ('-'), or the letter 'm'.
 ['-?]       #  Matches any of the characters  '()*+,-./0123456789:;<=>?
             #  (But not on an EBCDIC platform).
 [\N{APOSTROPHE}-\N{QUESTION MARK}]
             #  Matches any of the characters  '()*+,-./0123456789:;<=>?
             #  even on an EBCDIC platform.
 [\N{U+27}-\N{U+3F}] # Same. (U+27 is "'", and U+3F is "?")

As the final two examples above show, you can achieve portablity to
non-ASCII platforms by using the C<\N{...}> form for the range
endpoints.  These indicate that the specified range is to be interpreted
using Unicode values, so C<[\N{U+27}-\N{U+3F}]> means to match
C<\N{U+27}>, C<\N{U+28}>, C<\N{U+29}>, ..., C<\N{U+3D}>, C<\N{U+3E}>,
and C<\N{U+3F}>, whatever the native code point versions for those are.
These are called "Unicode" ranges.  If either end is of the C<\N{...}>
form, the range is considered Unicode.  A C<regexp> warning is raised
under C<S<"use re 'strict'">> if the other endpoint is specified
non-portably:

 [\N{U+00}-\x09]    # Warning under re 'strict'; \x09 is non-portable
 [\N{U+00}-\t]      # No warning;

Both of the above match the characters C<\N{U+00}> C<\N{U+01}>, ...
C<\N{U+08}>, C<\N{U+09}>, but the C<\x09> looks like it could be a
mistake so the warning is raised (under C<re 'strict'>) for it.

Perl also guarantees that the ranges C<A-Z>, C<a-z>, C<0-9>, and any
subranges of these match what an English-only speaker would expect them
to match on any platform.  That is, C<[A-Z]> matches the 26 ASCII
uppercase letters;
C<[a-z]> matches the 26 lowercase letters; and C<[0-9]> matches the 10
digits.  Subranges, like C<[h-k]>, match correspondingly, in this case
just the four letters C<"h">, C<"i">, C<"j">, and C<"k">.  This is the
natural behavior on ASCII platforms where the code points (ordinal
values) for C<"h"> through C<"k"> are consecutive integers (0x68 through
0x6B).  But special handling to achieve this may be needed on platforms
with a non-ASCII native character set.  For example, on EBCDIC
platforms, the code point for C<"h"> is 0x88, C<"i"> is 0x89, C<"j"> is
0x91, and C<"k"> is 0x92.   Perl specially treats C<[h-k]> to exclude the
seven code points in the gap: 0x8A through 0x90.  This special handling is
only invoked when the range is a subrange of one of the ASCII uppercase,
lowercase, and digit ranges, AND each end of the range is expressed
either as a literal, like C<"A">, or as a named character (C<\N{...}>,
including the C<\N{U+...> form).

EBCDIC Examples:

 [i-j]               #  Matches either "i" or "j"
 [i-\N{LATIN SMALL LETTER J}]  # Same
 [i-\N{U+6A}]        #  Same
 [\N{U+69}-\N{U+6A}] #  Same
 [\x{89}-\x{91}]     #  Matches 0x89 ("i"), 0x8A .. 0x90, 0x91 ("j")
 [i-\x{91}]          #  Same
 [\x{89}-j]          #  Same
 [i-J]               #  Matches, 0x89 ("i") .. 0xC1 ("J"); special
                     #  handling doesn't apply because range is mixed
                     #  case

=head3 Negation

It is also possible to instead list the characters you do not want to
match. You can do so by using a caret (C<^>) as the first character in the
character class. For instance, C<[^a-z]> matches any character that is not a
lowercase ASCII letter, which therefore includes more than a million
Unicode code points.  The class is said to be "negated" or "inverted".

This syntax make the caret a special character inside a bracketed character
class, but only if it is the first character of the class. So if you want
the caret as one of the characters to match, either escape the caret or
else don't list it first.

In inverted bracketed character classes, Perl ignores the Unicode rules
that normally say that named sequence, and certain characters should
match a sequence of multiple characters use under caseless C</i>
matching.  Following those rules could lead to highly confusing
situations:

 "ss" =~ /^[^\xDF]+$/ui;   # Matches!

This should match any sequences of characters that aren't C<\xDF> nor
what C<\xDF> matches under C</i>.  C<"s"> isn't C<\xDF>, but Unicode
says that C<"ss"> is what C<\xDF> matches under C</i>.  So which one
"wins"? Do you fail the match because the string has C<ss> or accept it
because it has an C<s> followed by another C<s>?  Perl has chosen the
latter.  (See note in L</Bracketed Character Classes> above.)

Examples:

 "e"  =~  /[^aeiou]/   #  No match, the 'e' is listed.
 "x"  =~  /[^aeiou]/   #  Match, as 'x' isn't a lowercase vowel.
 "^"  =~  /[^^]/       #  No match, matches anything that isn't a caret.
 "^"  =~  /[x^]/       #  Match, caret is not special here.

=head3 Backslash Sequences

You can put any backslash sequence character class (with the exception of
C<\N> and C<\R>) inside a bracketed character class, and it will act just
as if you had put all characters matched by the backslash sequence inside the
character class. For instance, C<[a-f\d]> matches any decimal digit, or any
of the lowercase letters between 'a' and 'f' inclusive.

C<\N> within a bracketed character class must be of the forms C<\N{I<name>}>
or C<\N{U+I<hex char>}>, and NOT be the form that matches non-newlines,
for the same reason that a dot C<.> inside a bracketed character class loses
its special meaning: it matches nearly anything, which generally isn't what you
want to happen.


Examples:

 /[\p{Thai}\d]/     # Matches a character that is either a Thai
                    # character, or a digit.
 /[^\p{Arabic}()]/  # Matches a character that is neither an Arabic
                    # character, nor a parenthesis.

Backslash sequence character classes cannot form one of the endpoints
of a range.  Thus, you can't say:

 /[\p{Thai}-\d]/     # Wrong!

=head3 POSIX Character Classes
X<character class> X<\p> X<\p{}>
X<alpha> X<alnum> X<ascii> X<blank> X<cntrl> X<digit> X<graph>
X<lower> X<print> X<punct> X<space> X<upper> X<word> X<xdigit>

POSIX character classes have the form C<[:class:]>, where I<class> is the
name, and the C<[:> and C<:]> delimiters. POSIX character classes only appear
I<inside> bracketed character classes, and are a convenient and descriptive
way of listing a group of characters.

Be careful about the syntax,

 # Correct:
 $string =~ /[[:alpha:]]/

 # Incorrect (will warn):
 $string =~ /[:alpha:]/

The latter pattern would be a character class consisting of a colon,
and the letters C<a>, C<l>, C<p> and C<h>.

POSIX character classes can be part of a larger bracketed character class.
For example,

 [01[:alpha:]%]

is valid and matches '0', '1', any alphabetic character, and the percent sign.

Perl recognizes the following POSIX character classes:

 alpha  Any alphabetical character ("[A-Za-z]").
 alnum  Any alphanumeric character ("[A-Za-z0-9]").
 ascii  Any character in the ASCII character set.
 blank  A GNU extension, equal to a space or a horizontal tab ("\t").
 cntrl  Any control character.  See Note [2] below.
 digit  Any decimal digit ("[0-9]"), equivalent to "\d".
 graph  Any printable character, excluding a space.  See Note [3] below.
 lower  Any lowercase character ("[a-z]").
 print  Any printable character, including a space.  See Note [4] below.
 punct  Any graphical character excluding "word" characters.  Note [5].
 space  Any whitespace character. "\s" including the vertical tab
        ("\cK").
 upper  Any uppercase character ("[A-Z]").
 word   A Perl extension ("[A-Za-z0-9_]"), equivalent to "\w".
 xdigit Any hexadecimal digit ("[0-9a-fA-F]").

Like the L<Unicode properties|/Unicode Properties>, most of the POSIX
properties match the same regardless of whether case-insensitive (C</i>)
matching is in effect or not.  The two exceptions are C<[:upper:]> and
C<[:lower:]>.  Under C</i>, they each match the union of C<[:upper:]> and
C<[:lower:]>.

Most POSIX character classes have two Unicode-style C<\p> property
counterparts.  (They are not official Unicode properties, but Perl extensions
derived from official Unicode properties.)  The table below shows the relation
between POSIX character classes and these counterparts.

One counterpart, in the column labelled "ASCII-range Unicode" in
the table, matches only characters in the ASCII character set.

The other counterpart, in the column labelled "Full-range Unicode", matches any
appropriate characters in the full Unicode character set.  For example,
C<\p{Alpha}> matches not just the ASCII alphabetic characters, but any
character in the entire Unicode character set considered alphabetic.
An entry in the column labelled "backslash sequence" is a (short)
equivalent.

 [[:...:]]      ASCII-range          Full-range  backslash  Note
                 Unicode              Unicode     sequence
 -----------------------------------------------------
   alpha      \p{PosixAlpha}       \p{XPosixAlpha}
   alnum      \p{PosixAlnum}       \p{XPosixAlnum}
   ascii      \p{ASCII}
   blank      \p{PosixBlank}       \p{XPosixBlank}  \h      [1]
                                   or \p{HorizSpace}        [1]
   cntrl      \p{PosixCntrl}       \p{XPosixCntrl}          [2]
   digit      \p{PosixDigit}       \p{XPosixDigit}  \d
   graph      \p{PosixGraph}       \p{XPosixGraph}          [3]
   lower      \p{PosixLower}       \p{XPosixLower}
   print      \p{PosixPrint}       \p{XPosixPrint}          [4]
   punct      \p{PosixPunct}       \p{XPosixPunct}          [5]
              \p{PerlSpace}        \p{XPerlSpace}   \s      [6]
   space      \p{PosixSpace}       \p{XPosixSpace}          [6]
   upper      \p{PosixUpper}       \p{XPosixUpper}
   word       \p{PosixWord}        \p{XPosixWord}   \w
   xdigit     \p{PosixXDigit}      \p{XPosixXDigit}

=over 4

=item [1]

C<\p{Blank}> and C<\p{HorizSpace}> are synonyms.

=item [2]

Control characters don't produce output as such, but instead usually control
the terminal somehow: for example, newline and backspace are control characters.
On ASCII platforms, in the ASCII range, characters whose code points are
between 0 and 31 inclusive, plus 127 (C<DEL>) are control characters; on
EBCDIC platforms, their counterparts are control characters.

=item [3]

Any character that is I<graphical>, that is, visible. This class consists
of all alphanumeric characters and all punctuation characters.

=item [4]

All printable characters, which is the set of all graphical characters
plus those whitespace characters which are not also controls.

=item [5]

C<\p{PosixPunct}> and C<[[:punct:]]> in the ASCII range match all
non-controls, non-alphanumeric, non-space characters:
C<[-!"#$%&'()*+,./:;<=E<gt>?@@[\\\]^_`{|}~]> (although if a locale is in effect,
it could alter the behavior of C<[[:punct:]]>).

The similarly named property, C<\p{Punct}>, matches a somewhat different
set in the ASCII range, namely
C<[-!"#%&'()*,./:;?@@[\\\]_{}]>.  That is, it is missing the nine
characters C<[$+E<lt>=E<gt>^`|~]>.
This is because Unicode splits what POSIX considers to be punctuation into two
categories, Punctuation and Symbols.

C<\p{XPosixPunct}> and (under Unicode rules) C<[[:punct:]]>, match what
C<\p{PosixPunct}> matches in the ASCII range, plus what C<\p{Punct}>
matches.  This is different than strictly matching according to
C<\p{Punct}>.  Another way to say it is that
if Unicode rules are in effect, C<[[:punct:]]> matches all characters
that Unicode considers punctuation, plus all ASCII-range characters that
Unicode considers symbols.

=item [6]

C<\p{XPerlSpace}> and C<\p{Space}> match identically starting with Perl
v5.18.  In earlier versions, these differ only in that in non-locale
matching, C<\p{XPerlSpace}> did not match the vertical tab, C<\cK>.
Same for the two ASCII-only range forms.

=back

There are various other synonyms that can be used besides the names
listed in the table.  For example, C<\p{PosixAlpha}> can be written as
C<\p{Alpha}>.  All are listed in
L<perluniprops/Properties accessible through \p{} and \P{}>.

Both the C<\p> counterparts always assume Unicode rules are in effect.
On ASCII platforms, this means they assume that the code points from 128
to 255 are Latin-1, and that means that using them under locale rules is
unwise unless the locale is guaranteed to be Latin-1 or UTF-8.  In contrast, the
POSIX character classes are useful under locale rules.  They are
affected by the actual rules in effect, as follows:

=over

=item If the C</a> modifier, is in effect ...

Each of the POSIX classes matches exactly the same as their ASCII-range
counterparts.

=item otherwise ...

=over

=item For code points above 255 ...

The POSIX class matches the same as its Full-range counterpart.

=item For code points below 256 ...

=over

=item if locale rules are in effect ...

The POSIX class matches according to the locale, except:

=over

=item C<word>

also includes the platform's native underscore character, no matter what
the locale is.

=item C<ascii>

on platforms that don't have the POSIX C<ascii> extension, this matches
just the platform's native ASCII-range characters.

=item C<blank>

on platforms that don't have the POSIX C<blank> extension, this matches
just the platform's native tab and space characters.

=back

=item if Unicode rules are in effect ...

The POSIX class matches the same as the Full-range counterpart.

=item otherwise ...

The POSIX class matches the same as the ASCII range counterpart.

=back

=back

=back

Which rules apply are determined as described in
L<perlre/Which character set modifier is in effect?>.

It is proposed to change this behavior in a future release of Perl so that
whether or not Unicode rules are in effect would not change the
behavior:  Outside of locale, the POSIX classes
would behave like their ASCII-range counterparts.  If you wish to
comment on this proposal, send email to C<perl5-porters@@perl.org>.

=head4 Negation of POSIX character classes
X<character class, negation>

A Perl extension to the POSIX character class is the ability to
negate it. This is done by prefixing the class name with a caret (C<^>).
Some examples:

     POSIX         ASCII-range     Full-range  backslash
                    Unicode         Unicode    sequence
 -----------------------------------------------------
 [[:^digit:]]   \P{PosixDigit}  \P{XPosixDigit}   \D
 [[:^space:]]   \P{PosixSpace}  \P{XPosixSpace}
                \P{PerlSpace}   \P{XPerlSpace}    \S
 [[:^word:]]    \P{PerlWord}    \P{XPosixWord}    \W

The backslash sequence can mean either ASCII- or Full-range Unicode,
depending on various factors as described in L<perlre/Which character set modifier is in effect?>.

=head4 [= =] and [. .]

Perl recognizes the POSIX character classes C<[=class=]> and
C<[.class.]>, but does not (yet?) support them.  Any attempt to use
either construct raises an exception.

=head4 Examples

 /[[:digit:]]/            # Matches a character that is a digit.
 /[01[:lower:]]/          # Matches a character that is either a
                          # lowercase letter, or '0' or '1'.
 /[[:digit:][:^xdigit:]]/ # Matches a character that can be anything
                          # except the letters 'a' to 'f' and 'A' to
                          # 'F'.  This is because the main character
                          # class is composed of two POSIX character
                          # classes that are ORed together, one that
                          # matches any digit, and the other that
                          # matches anything that isn't a hex digit.
                          # The OR adds the digits, leaving only the
                          # letters 'a' to 'f' and 'A' to 'F' excluded.

=head3 Extended Bracketed Character Classes
X<character class>
X<set operations>

This is a fancy bracketed character class that can be used for more
readable and less error-prone classes, and to perform set operations,
such as intersection. An example is

 /(?[ \p{Thai} & \p{Digit} ])/

This will match all the digit characters that are in the Thai script.

This is an experimental feature available starting in 5.18, and is
subject to change as we gain field experience with it.  Any attempt to
use it will raise a warning, unless disabled via

 no warnings "experimental::regex_sets";

Comments on this feature are welcome; send email to
C<perl5-porters@@perl.org>.

The rules used by L<C<use re 'strict>|re/'strict' mode> apply to this
construct.

We can extend the example above:

 /(?[ ( \p{Thai} + \p{Lao} ) & \p{Digit} ])/

This matches digits that are in either the Thai or Laotian scripts.

Notice the white space in these examples.  This construct always has
the C<E<sol>x> modifier turned on within it.

The available binary operators are:

 &    intersection
 +    union
 |    another name for '+', hence means union
 -    subtraction (the result matches the set consisting of those
      code points matched by the first operand, excluding any that
      are also matched by the second operand)
 ^    symmetric difference (the union minus the intersection).  This
      is like an exclusive or, in that the result is the set of code
      points that are matched by either, but not both, of the
      operands.

There is one unary operator:

 !    complement

All the binary operators left associate; C<"&"> is higher precedence
than the others, which all have equal precedence.  The unary operator
right associates, and has highest precedence.  Thus this follows the
normal Perl precedence rules for logical operators.  Use parentheses to
override the default precedence and associativity.

The main restriction is that everything is a metacharacter.  Thus,
you cannot refer to single characters by doing something like this:

 /(?[ a + b ])/ # Syntax error!

The easiest way to specify an individual typable character is to enclose
it in brackets:

 /(?[ [a] + [b] ])/

(This is the same thing as C<[ab]>.)  You could also have said the
equivalent:

 /(?[[ a b ]])/

(You can, of course, specify single characters by using, C<\x{...}>,
C<\N{...}>, etc.)

This last example shows the use of this construct to specify an ordinary
bracketed character class without additional set operations.  Note the
white space within it; a limited version of C<E<sol>x> is turned on even
within bracketed character classes, with only the SPACE and TAB (C<\t>)
characters allowed, and no comments.  Hence,

 (?[ [#] ])

matches the literal character "#".  To specify a literal white space character,
you can escape it with a backslash, like:

 /(?[ [ a e i o u \  ] ])/

This matches the English vowels plus the SPACE character.
All the other escapes accepted by normal bracketed character classes are
accepted here as well; but unrecognized escapes that generate warnings
in normal classes are fatal errors here.

All warnings from these class elements are fatal, as well as some
practices that don't currently warn.  For example you cannot say

 /(?[ [ \xF ] ])/     # Syntax error!

You have to have two hex digits after a braceless C<\x> (use a leading
zero to make two).  These restrictions are to lower the incidence of
typos causing the class to not match what you thought it would.

If a regular bracketed character class contains a C<\p{}> or C<\P{}> and
is matched against a non-Unicode code point, a warning may be
raised, as the result is not Unicode-defined.  No such warning will come
when using this extended form.

The final difference between regular bracketed character classes and
these, is that it is not possible to get these to match a
multi-character fold.  Thus,

 /(?[ [\xDF] ])/iu

does not match the string C<ss>.

You don't have to enclose POSIX class names inside double brackets,
hence both of the following work:

 /(?[ [:word:] - [:lower:] ])/
 /(?[ [[:word:]] - [[:lower:]] ])/

Any contained POSIX character classes, including things like C<\w> and C<\D>
respect the C<E<sol>a> (and C<E<sol>aa>) modifiers.

C<< (?[ ]) >> is a regex-compile-time construct.  Any attempt to use
something which isn't knowable at the time the containing regular
expression is compiled is a fatal error.  In practice, this means
just three limitations:

=over 4

=item 1

When compiled within the scope of C<use locale> (or the C<E<sol>l> regex
modifier), this construct assumes that the execution-time locale will be
a UTF-8 one, and the generated pattern always uses Unicode rules.  What
gets matched or not thus isn't dependent on the actual runtime locale, so
tainting is not enabled.  But a C<locale> category warning is raised
if the runtime locale turns out to not be UTF-8.

=item 2

Any
L<user-defined property|perlunicode/"User-Defined Character Properties">
used must be already defined by the time the regular expression is
compiled (but note that this construct can be used instead of such
properties).

=item 3

A regular expression that otherwise would compile
using C<E<sol>d> rules, and which uses this construct will instead
use C<E<sol>u>.  Thus this construct tells Perl that you don't want
C<E<sol>d> rules for the entire regular expression containing it.

=back

Note that skipping white space applies only to the interior of this
construct.  There must not be any space between any of the characters
that form the initial C<(?[>.  Nor may there be space between the
closing C<])> characters.

Just as in all regular expressions, the pattern can be built up by
including variables that are interpolated at regex compilation time.
Care must be taken to ensure that you are getting what you expect.  For
example:

 my $thai_or_lao = '\p{Thai} + \p{Lao}';
 ...
 qr/(?[ \p{Digit} & $thai_or_lao ])/;

compiles to

 qr/(?[ \p{Digit} & \p{Thai} + \p{Lao} ])/;

But this does not have the effect that someone reading the code would
likely expect, as the intersection applies just to C<\p{Thai}>,
excluding the Laotian.  Pitfalls like this can be avoided by
parenthesizing the component pieces:

 my $thai_or_lao = '( \p{Thai} + \p{Lao} )';

But any modifiers will still apply to all the components:

 my $lower = '\p{Lower} + \p{Digit}';
 qr/(?[ \p{Greek} & $lower ])/i;

matches upper case things.  You can avoid surprises by making the
components into instances of this construct by compiling them:

 my $thai_or_lao = qr/(?[ \p{Thai} + \p{Lao} ])/;
 my $lower = qr/(?[ \p{Lower} + \p{Digit} ])/;

When these are embedded in another pattern, what they match does not
change, regardless of parenthesization or what modifiers are in effect
in that outer pattern.

Due to the way that Perl parses things, your parentheses and brackets
may need to be balanced, even including comments.  If you run into any
examples, please send them to C<perlbug@@perl.org>, so that we can have a
concrete example for this man page.

We may change it so that things that remain legal uses in normal bracketed
character classes might become illegal within this experimental
construct.  One proposal, for example, is to forbid adjacent uses of the
same character, as in C<(?[ [aa] ])>.  The motivation for such a change
is that this usage is likely a typo, as the second "a" adds nothing.
@


1.1
log
@Initial revision
@
text
@d2 1
d12 1
a12 1
classes in Perl Regular Expressions.
d14 1
a14 1
A character class is a way of denoting a set of characters,
d16 1
a16 1
It's important to remember that matching a character class
d21 3
a23 1
expressions: the dot, backslashed sequences, and the bracketed form.
d29 6
a34 4
character, except for the newline. The default can be changed to
add matching the newline with the I<single line> modifier: either
for the entire regular expression using the C</s> modifier, or
locally using C<(?s)>.
d46 14
d61 2
a62 14
=head2 Backslashed sequences

Perl regular expressions contain many backslashed sequences that
constitute a character class. That is, they will match a single
character, if that character belongs to a specific set of characters
(defined by the sequence). A backslashed sequence is a sequence of
characters starting with a backslash. Not all backslashed sequences
are character class; for a full list, see L<perlrebackslash>.

Here's a list of the backslashed sequences, which are discussed in
more detail below.

 \d             Match a digit character.
 \D             Match a non-digit character.
d65 23
a87 8
 \s             Match a white space character.
 \S             Match a non-white space character.
 \h             Match a horizontal white space character.
 \H             Match a character that isn't horizontal white space.
 \v             Match a vertical white space character.
 \V             Match a character that isn't vertical white space.
 \pP, \p{Prop}  Match a character matching a Unicode property.
 \PP, \P{Prop}  Match a character that doesn't match a Unicode property.
d91 48
a138 8
C<\d> matches a single character that is considered to be a I<digit>.
What is considered a digit depends on the internal encoding of
the source string. If the source string is in UTF-8 format, C<\d>
not only matches the digits '0' - '9', but also Arabic, Devanagari and
digits from other languages. Otherwise, if there is a locale in effect,
it will match whatever characters the locale considers digits. Without
a locale, C<\d> matches the digits '0' to '9'.
See L</Locale, Unicode and UTF-8>.
d140 1
a140 1
Any character that isn't matched by C<\d> will be matched by C<\D>.
d144 128
a271 37
C<\w> matches a single I<word> character: an alphanumeric character
(that is, an alphabetic character, or a digit), or the underscore (C<_>).
What is considered a word character depends on the internal encoding
of the string. If it's in UTF-8 format, C<\w> matches those characters
that are considered word characters in the Unicode database. That is, it
not only matches ASCII letters, but also Thai letters, Greek letters, etc.
If the source string isn't in UTF-8 format, C<\w> matches those characters
that are considered word characters by the current locale. Without
a locale in effect, C<\w> matches the ASCII letters, digits and the
underscore.

Any character that isn't matched by C<\w> will be matched by C<\W>.

=head3 White space

C<\s> matches any single character that is consider white space. In the
ASCII range, C<\s> matches the horizontal tab (C<\t>), the new line
(C<\n>), the form feed (C<\f>), the carriage return (C<\r>), and the
space (the vertical tab, C<\cK> is not matched by C<\s>).  The exact set
of characters matched by C<\s> depends on whether the source string is
in UTF-8 format. If it is, C<\s> matches what is considered white space
in the Unicode database. Otherwise, if there is a locale in effect, C<\s>
matches whatever is considered white space by the current locale. Without
a locale, C<\s> matches the five characters mentioned in the beginning
of this paragraph.  Perhaps the most notable difference is that C<\s>
matches a non-breaking space only if the non-breaking space is in a
UTF-8 encoded string.

Any character that isn't matched by C<\s> will be matched by C<\S>.

C<\h> will match any character that is considered horizontal white space;
this includes the space and the tab characters. C<\H> will match any character
that is not considered horizontal white space.

C<\v> will match any character that is considered vertical white space;
this includes the carriage return and line feed characters (newline).
C<\V> will match any character that is not considered vertical white space.
d274 14
a287 18
rules. It's not a character class, as it can match a multi-character
sequence. Therefore, it cannot be used inside a bracketed character
class. Details are discussed in L<perlrebackslash>.

C<\h>, C<\H>, C<\v>, C<\V>, and C<\R> are new in perl 5.10.0.

Note that unlike C<\s>, C<\d> and C<\w>, C<\h> and C<\v> always match
the same characters, regardless whether the source string is in UTF-8
format or not. The set of characters they match is also not influenced
by locale.

One might think that C<\s> is equivalent with C<[\h\v]>. This is not true.
The vertical tab (C<"\x0b">) is not matched by C<\s>, it is however
considered vertical white space. Furthermore, if the source string is
not in UTF-8 format, the next line (C<"\x85">) and the no-break space
(C<"\xA0">) are not matched by C<\s>, but are by C<\v> and C<\h> respectively.
If the source string is in UTF-8 format, both the next line and the
no-break space are matched by C<\s>.
d290 1
a290 1
C<\s>, C<\h> and C<\v>.
d292 1
a292 1
The first column gives the code point of the character (in hex format),
d294 2
a295 1
by which class(es) the character is matched.
d297 25
a321 26
 0x00009        CHARACTER TABULATION   h s
 0x0000a              LINE FEED (LF)    vs
 0x0000b             LINE TABULATION    v
 0x0000c              FORM FEED (FF)    vs
 0x0000d        CARRIAGE RETURN (CR)    vs
 0x00020                       SPACE   h s
 0x00085             NEXT LINE (NEL)    vs  [1]
 0x000a0              NO-BREAK SPACE   h s  [1]
 0x01680            OGHAM SPACE MARK   h s
 0x0180e   MONGOLIAN VOWEL SEPARATOR   h s
 0x02000                     EN QUAD   h s
 0x02001                     EM QUAD   h s
 0x02002                    EN SPACE   h s
 0x02003                    EM SPACE   h s
 0x02004          THREE-PER-EM SPACE   h s
 0x02005           FOUR-PER-EM SPACE   h s
 0x02006            SIX-PER-EM SPACE   h s
 0x02007                FIGURE SPACE   h s
 0x02008           PUNCTUATION SPACE   h s
 0x02009                  THIN SPACE   h s
 0x0200a                  HAIR SPACE   h s
 0x02028              LINE SEPARATOR    vs
 0x02029         PARAGRAPH SEPARATOR    vs
 0x0202f       NARROW NO-BREAK SPACE   h s
 0x0205f   MEDIUM MATHEMATICAL SPACE   h s
 0x03000           IDEOGRAPHIC SPACE   h s
d327 2
a328 2
NEXT LINE and NO-BREAK SPACE only match C<\s> if the source string is in
UTF-8 format.
d330 1
a330 1
=back
d332 3
a334 3
It is worth noting that C<\d>, C<\w>, etc, match single characters, not
complete numbers or words. To match a number (that consists of integers),
use C<\d+>; to match a word, use C<\w+>.
d336 1
d340 14
a353 8
C<\pP> and C<\p{Prop}> are character classes to match characters that
fit given Unicode classes. One letter classes can be used in the C<\pP>
form, with the class name following the C<\p>, otherwise, the property
name is enclosed in braces, and follows the C<\p>. For instance, a
match for a number can be written as C</\pN/> or as C</\p{Number}/>.
Lowercase letters are matched by the property I<LowercaseLetter> which
has as short form I<Ll>. They have to be written as C</\p{Ll}/> or
C</\p{LowercaseLetter}/>. C</\pLl/> is valid, but means something different.
d357 29
a385 3
For a list of possible properties, see
L<perlunicode/Unicode Character Properties>. It is also possible to
defined your own properties. This is discussed in
d388 14
d409 1
a409 1
 " "  =~  /\s/      # Match, a space is white space.
d412 1
a412 1
 " "  =~  /\S/      # No match, a space is not non-white space.
d414 3
a416 3
 " "  =~  /\h/      # Match, space is horizontal white space.
 " "  =~  /\v/      # No match, space is not vertical white space.
 "\r" =~  /\v/      # Match, a return is vertical white space.
d424 1
a424 1
 "a"  =~  /\P{Lao}/ # Match, as "a" is not a Laoian character.
d426 4
d434 7
a440 7
is the bracketed form. In its simplest form, it lists the characters
that may be matched inside square brackets, like this: C<[aeiou]>.
This matches one of C<a>, C<e>, C<i>, C<o> or C<u>. Just as the other
character classes, exactly one character will be matched. To match
a longer string consisting of characters mentioned in the characters
class, follow the character class with a quantifier. For instance,
C<[aeiou]+> matches a string of one or more lowercase ASCII vowels.
d453 55
d511 1
a511 1
is, characters that carry a special meaning like C<*> or C<(>) lose
d523 1
a523 1
outside the character class C<\b> is an assertion indicating a point
d528 26
a553 2
A C<[> is not special inside a character class, unless it's the start
of a POSIX character class (see below). It normally does not need escaping.
a554 3
A C<]> is either the end of a POSIX character class (see below), or it
signals the end of the bracketed character class. Normally it needs
escaping if you want to include a C<]> in the set of characters.
d565 2
a566 2
                      #  is equivalent with a backspace.
 "]"   =~ /[][]/      #  Match, as the character class contains.
d569 1
a569 1
                      #  containing just ], and the character class is
d575 1
a575 1
of listing all the characters in the range, one may use the hyphen (C<->).
d577 1
a577 1
by a hyphen, it's treated as if all the characters between the two are in
d582 1
a582 1
necessary both letters or both digits. Any character is possible,
d584 1
a584 1
most people will not know which characters that will be. Furthermore,
d588 7
a594 7
If a hyphen in a character class cannot be part of a range, for instance
because it is the first or the last character of the character class,
or if it immediately follows a range, the hyphen isn't special, and will be
considered a character that may be matched. You have to escape the hyphen
with a backslash if you want to have a hyphen in your set of characters to
be matched, and its position in the class is such that it can be considered
part of a range.
d599 2
a600 2
 [a-fz]      #  Matches any letter between 'a' and 'f' (inclusive) or the
             #  letter 'z'.
d606 54
a659 1

d665 3
a667 2
character class. For instance, C<[^a-z]> matches a character that is not a
lowercase ASCII letter.
d671 17
a687 2
to have the caret as one of the characters you want to match, you either
have to escape the caret, or not list it first.
d698 12
a709 5
You can put a backslash sequence character class inside a bracketed character
class, and it will act just as if you put all the characters matched by
the backslash sequence inside the character class. For instance,
C<[a-f\d]> will match any digit, or any of the lowercase letters between
'a' and 'f' inclusive.
d719 3
a721 1
of a range.
d723 4
a726 1
=head3 Posix Character Classes
d728 2
a729 2
Posix character classes have the form C<[:class:]>, where I<class> is
name, and the C<[:> and C<:]> delimiters. Posix character classes appear
d731 3
a733 1
way of listing a group of characters. Be careful about the syntax,
d744 7
d753 56
a808 42
 alpha  Any alphabetical character.
 alnum  Any alphanumerical character.
 ascii  Any ASCII character.
 blank  A GNU extension, equal to a space or a horizontal tab (C<\t>).
 cntrl  Any control character.
 digit  Any digit, equivalent to C<\d>.
 graph  Any printable character, excluding a space.
 lower  Any lowercase character.
 print  Any printable character, including a space.
 punct  Any punctuation character.
 space  Any white space character. C<\s> plus the vertical tab (C<\cK>).
 upper  Any uppercase character.
 word   Any "word" character, equivalent to C<\w>.
 xdigit Any hexadecimal digit, '0' - '9', 'a' - 'f', 'A' - 'F'.

The exact set of characters matched depends on whether the source string
is internally in UTF-8 format or not. See L</Locale, Unicode and UTF-8>.

Most POSIX character classes have C<\p> counterparts. The difference
is that the C<\p> classes will always match according to the Unicode
properties, regardless whether the string is in UTF-8 format or not.

The following table shows the relation between POSIX character classes
and the Unicode properties:

 [[:...:]]   \p{...}      backslash

 alpha       IsAlpha
 alnum       IsAlnum
 ascii       IsASCII
 blank
 cntrl       IsCntrl
 digit       IsDigit      \d
 graph       IsGraph
 lower       IsLower
 print       IsPrint
 punct       IsPunct
 space       IsSpace
             IsSpacePerl  \s
 upper       IsUpper
 word        IsWord
 xdigit      IsXDigit
d810 1
a810 1
Some character classes may have a non-obvious name:
d812 3
a814 1
=over 4
d816 1
a816 1
=item cntrl
d818 5
a822 6
Any control character. Usually, control characters don't produce output
as such, but instead control the terminal somehow: for example newline
and backspace are control characters. All characters with C<ord()> less
than 32 are usually classified as control characters (in ASCII, the ISO
Latin character sets, and Unicode), as is the character C<ord()> value
of 127 (C<DEL>).
d824 1
a824 1
=item graph
d827 53
a879 1
of all the alphanumerical characters and all punctuation characters.
d881 2
a882 1
=item print
d884 1
a884 2
All printable characters, which is the set of all the graphical characters
plus the space.
d886 1
a886 1
=item punct
d888 42
a929 1
Any punctuation (special) character.
d933 11
a943 1
=head4 Negation
d949 10
a958 4
 POSIX         Unicode       Backslash
 [[:^digit:]]  \P{IsDigit}   \D
 [[:^space:]]  \P{IsSpace}   \S
 [[:^word:]]   \P{IsWord}    \W
d962 3
a964 4
Perl will recognize the POSIX character classes C<[=class=]>, and
C<[.class.]>, but does not (yet?) support this construct. Use of
such a constructs will lead to an error.

d971 59
a1029 30
 /[[:digit:][:^xdigit:]]/ # Matches a character that can be anything,
                          # but the letters 'a' to 'f' in either case.
                          # This is because the character class contains
                          # all digits, and anything that isn't a
                          # hex digit, resulting in a class containing
                          # all characters, but the letters 'a' to 'f'
                          # and 'A' to 'F'.


=head2 Locale, Unicode and UTF-8

Some of the character classes have a somewhat different behaviour depending
on the internal encoding of the source string, and the locale that is
in effect.

C<\w>, C<\d>, C<\s> and the POSIX character classes (and their negations,
including C<\W>, C<\D>, C<\S>) suffer from this behaviour.

The rule is that if the source string is in UTF-8 format, the character
classes match according to the Unicode properties. If the source string
isn't, then the character classes match according to whatever locale is
in effect. If there is no locale, they match the ASCII defaults
(52 letters, 10 digits and underscore for C<\w>, 0 to 9 for C<\d>, etc).

This usually means that if you are matching against characters whose C<ord()>
values are between 128 and 255 inclusive, your character class may match
or not depending on the current locale, and whether the source string is
in UTF-8 format. The string will be in UTF-8 format if it contains
characters whose C<ord()> value exceeds 255. But a string may be in UTF-8
format without it having such characters.
d1031 5
a1035 2
For portability reasons, it may be better to not use C<\w>, C<\d>, C<\s>
or the POSIX character classes, and use the Unicode properties instead.
d1037 139
a1175 1
=head4 Examples
d1177 4
a1180 6
 $str =  "\xDF";      # $str is not in UTF-8 format.
 $str =~ /^\w/;       # No match, as $str isn't in UTF-8 format.
 $str .= "\x{0e0b}";  # Now $str is in UTF-8 format.
 $str =~ /^\w/;       # Match! $str is now in UTF-8 format.
 chop $str;
 $str =~ /^\w/;       # Still a match! $str remains in UTF-8 format.
d1182 5
a1186 1
=cut
@


1.1.1.1
log
@import perl 5.10.0 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.10.1
@
text
@d390 1
a390 1
 blank  A GNU extension, equal to a space or a horizontal tab ("\t").
d392 1
a392 1
 digit  Any digit, equivalent to "\d".
d397 1
a397 1
 space  Any white space character. "\s" plus the vertical tab ("\cK").
d399 1
a399 1
 word   Any "word" character, equivalent to "\w".
d474 1
a474 1
such a construct will lead to an error.
@


1.1.1.3
log
@Perl 5.12.2 from CPAN
@
text
@a1 1
X<character class>
d20 1
a20 3
expressions: the dot, backslashed sequences, and the form enclosed in square
brackets.  Keep in mind, though, that often the term "character class" is used
to mean just the bracketed form.  This is true in other Perl documentation.
d41 1
a42 3
X<\w> X<\W> X<\s> X<\S> X<\d> X<\D> X<\p> X<\P> 
X<\N> X<\v> X<\V> X<\h> X<\H>
X<word> X<whitespace>
d49 1
a49 1
are character classes; for a full list, see L<perlrebackslash>.
d51 2
a52 2
Here's a list of the backslashed sequences that are character classes.  They
are discussed in more detail below.
d58 6
a63 7
 \s             Match a whitespace character.
 \S             Match a non-whitespace character.
 \h             Match a horizontal whitespace character.
 \H             Match a character that isn't horizontal whitespace.
 \N             Match a character that isn't newline.  Experimental.
 \v             Match a vertical whitespace character.
 \V             Match a character that isn't vertical whitespace.
d69 8
a76 7
C<\d> matches a single character that is considered to be a I<digit>.  What is
considered a digit depends on the internal encoding of the source string and
the locale that is in effect. If the source string is in UTF-8 format, C<\d>
not only matches the digits '0' - '9', but also Arabic, Devanagari and digits
from other languages. Otherwise, if there is a locale in effect, it will match
whatever characters the locale considers digits. Without a locale, C<\d>
matches the digits '0' to '9'.  See L</Locale, EBCDIC, Unicode and UTF-8>.
d82 10
a91 12
A C<\w> matches a single alphanumeric character (an alphabetic character, or a
decimal digit) or an underscore (C<_>), not a whole word.  Use C<\w+> to match
a string of Perl-identifier characters (which isn't the same as matching an
English word).  What is considered a word character depends on the internal
encoding of the string and the locale or EBCDIC code page that is in effect. If
it's in UTF-8 format, C<\w> matches those characters that are considered word
characters in the Unicode database. That is, it not only matches ASCII letters,
but also Thai letters, Greek letters, etc.  If the source string isn't in UTF-8
format, C<\w> matches those characters that are considered word characters by
the current locale or EBCDIC code page.  Without a locale or EBCDIC code page,
C<\w> matches the ASCII letters, digits and the underscore.
See L</Locale, EBCDIC, Unicode and UTF-8>.
d95 1
a95 1
=head3 Whitespace
d97 12
a108 15
C<\s> matches any single character that is considered whitespace. In the ASCII
range, C<\s> matches the horizontal tab (C<\t>), the new line (C<\n>), the form
feed (C<\f>), the carriage return (C<\r>), and the space.  (The vertical tab,
C<\cK> is not matched by C<\s>.)  The exact set of characters matched by C<\s>
depends on whether the source string is in UTF-8 format and the locale or
EBCDIC code page that is in effect. If it's in UTF-8 format, C<\s> matches what
is considered whitespace in the Unicode database; the complete list is in the
table below. Otherwise, if there is a locale or EBCDIC code page in effect,
C<\s> matches whatever is considered whitespace by the current locale or EBCDIC
code page. Without a locale or EBCDIC code page, C<\s> matches the five
characters mentioned in the beginning of this paragraph.  Perhaps the most
notable possible surprise is that C<\s> matches a non-breaking space only if
the non-breaking space is in a UTF-8 encoded string or the locale or EBCDIC
code page that is in effect has that character.
See L</Locale, EBCDIC, Unicode and UTF-8>.
d112 7
a118 21
C<\h> will match any character that is considered horizontal whitespace;
this includes the space and the tab characters and 17 other characters that are
listed in the table below. C<\H> will match any character
that is not considered horizontal whitespace.

C<\N> is new in 5.12, and is experimental.  It, like the dot, will match any
character that is not a newline. The difference is that C<\N> will not be
influenced by the single line C</s> regular expression modifier.  Note that
there is a second meaning of C<\N> when of the form C<\N{...}>.  This form is
for named characters.  See L<charnames> for those.  If C<\N> is followed by an
opening brace and something that is not a quantifier, perl will assume that a
character name is coming, and not this meaning of C<\N>.  For example, C<\N{3}>
means to match 3 non-newlines; C<\N{5,}> means to match 5 or more non-newlines,
but C<\N{4F}> and C<\N{F4}> are not legal quantifiers, and will cause perl to
look for characters named C<4F> or C<F4>, respectively (and won't find them,
thus raising an error, unless they have been defined using custom names).

C<\v> will match any character that is considered vertical whitespace;
this includes the carriage return and line feed characters (newline) plus 5
other characters listed in the table below.
C<\V> will match any character that is not considered vertical whitespace.
d123 3
a125 2
class; use C<\v> instead (vertical whitespace).
Details are discussed in L<perlrebackslash>.
d130 1
a130 1
by locale nor EBCDIC code page.
d132 7
a138 8
One might think that C<\s> is equivalent to C<[\h\v]>. This is not true.  The
vertical tab (C<"\x0b">) is not matched by C<\s>, it is however considered
vertical whitespace. Furthermore, if the source string is not in UTF-8 format,
and any locale or EBCDIC code page that is in effect doesn't include them, the
next line (C<"\x85">) and the no-break space (C<"\xA0">) characters are not
matched by C<\s>, but are by C<\v> and C<\h> respectively.  If the source
string is in UTF-8 format, both the next line and the no-break space are
matched by C<\s>.
d141 1
a141 1
C<\s>, C<\h> and C<\v> as of Unicode 5.2.
d145 1
a145 2
by which class(es) the character is matched (assuming no locale or EBCDIC code
page is in effect that changes the C<\s> matching).
d179 1
a179 1
UTF-8 format, or the locale or EBCDIC code page that is in effect includes them.
d190 8
a197 14
C<\pP> and C<\p{Prop}> are character classes to match characters that fit given
Unicode properties.  One letter property names can be used in the C<\pP> form,
with the property name following the C<\p>, otherwise, braces are required.
When using braces, there is a single form, which is just the property name
enclosed in the braces, and a compound form which looks like C<\p{name=value}>,
which means to match if the property "name" for the character has the particular
"value".
For instance, a match for a number can be written as C</\pN/> or as
C</\p{Number}/>, or as C</\p{Number=True}/>.
Lowercase letters are matched by the property I<Lowercase_Letter> which
has as short form I<Ll>. They need the braces, so are written as C</\p{Ll}/> or
C</\p{Lowercase_Letter}/>, or C</\p{General_Category=Lowercase_Letter}/>
(the underscores are optional).
C</\pLl/> is valid, but means something different.
d201 3
a203 4
For more details, see L<perlunicode/Unicode Character Properties>; for a
complete list of possible properties, see
L<perluniprops/Properties accessible through \p{} and \P{}>.
It is also possible to define your own properties. This is discussed in
d213 1
a213 1
 " "  =~  /\s/      # Match, a space is whitespace.
d216 1
a216 1
 " "  =~  /\S/      # No match, a space is not non-whitespace.
d218 3
a220 3
 " "  =~  /\h/      # Match, space is horizontal whitespace.
 " "  =~  /\v/      # No match, space is not vertical whitespace.
 "\r" =~  /\v/      # Match, a return is vertical whitespace.
d228 1
a228 1
 "a"  =~  /\P{Lao}/ # Match, as "a" is not a Laotian character.
d235 2
a236 2
that may be matched, surrounded by square brackets, like this: C<[aeiou]>.
This matches one of C<a>, C<e>, C<i>, C<o> or C<u>.  Like the other
d238 1
a238 1
a longer string consisting of characters mentioned in the character
d256 1
a256 1
is, characters that carry a special meaning like C<.>, C<*>, or C<(>) lose
a272 18
The sequences
C<\a>,
C<\c>,
C<\e>,
C<\f>,
C<\n>,
C<\N{I<NAME>}>,
C<\N{U+I<wide hex char>}>,
C<\r>,
C<\t>,
and
C<\x>
are also special and have the same meanings as they do outside a bracketed character
class.

Also, a backslash followed by two or three octal digits is considered an octal
number.

d276 3
a278 3
A C<]> is normally either the end of a POSIX character class (see below), or it
signals the end of the bracketed character class.  If you want to include a
C<]> in the set of characters, you must generally escape it.
d289 1
a289 1
                      #  is equivalent to a backspace.
d312 2
a313 2
If a hyphen in a character class cannot syntactically be part of a range, for
instance because it is the first or the last character of the character class,
d315 4
a318 4
considered a character that may be matched literally. You have to escape the
hyphen with a backslash if you want to have a hyphen in your set of characters
to be matched, and its position in the class is such that it could be
considered part of a range.
d323 2
a324 2
 [a-fz]      #  Matches any letter between 'a' and 'f' (inclusive) or
             #  the letter 'z'.
d353 5
a357 10
You can put any backslash sequence character class (with the exception of
C<\N>) inside a bracketed character class, and it will act just
as if you put all the characters matched by the backslash sequence inside the
character class. For instance, C<[a-f\d]> will match any digit, or any of the
lowercase letters between 'a' and 'f' inclusive.

C<\N> within a bracketed character class must be of the forms C<\N{I<name>}>  or
C<\N{U+I<wide hex char>}> for the same reason that a dot C<.> inside a
bracketed character class loses its special meaning: it matches nearly
anything, which generally isn't what you want to happen.
a369 3
X<character class> X<\p> X<\p{}>
X<alpha> X<alnum> X<ascii> X<blank> X<cntrl> X<digit> X<graph>
X<lower> X<print> X<punct> X<space> X<upper> X<word> X<xdigit>
d372 1
a372 1
name, and the C<[:> and C<:]> delimiters. Posix character classes only appear
d374 1
a374 3
way of listing a group of characters, though they currently suffer from
portability issues (see below and L<Locale, EBCDIC, Unicode and UTF-8>).  Be
careful about the syntax,
a383 6
These character classes can be part of a larger bracketed character class.  For
example,

 [01[:alpha:]%]

is valid and matches '0', '1', any alphabetic character, and the percent sign.
d387 3
a389 3
 alpha  Any alphabetical character ("[A-Za-z]").
 alnum  Any alphanumerical character. ("[A-Za-z0-9]")
 ascii  Any character in the ASCII character set.
d391 40
a430 67
 cntrl  Any control character.  See Note [2] below.
 digit  Any decimal digit ("[0-9]"), equivalent to "\d".
 graph  Any printable character, excluding a space.  See Note [3] below.
 lower  Any lowercase character ("[a-z]").
 print  Any printable character, including a space.  See Note [4] below.
 punct  Any graphical character excluding "word" characters.  Note [5].
 space  Any whitespace character. "\s" plus the vertical tab ("\cK").
 upper  Any uppercase character ("[A-Z]").
 word   A Perl extension ("[A-Za-z0-9_]"), equivalent to "\w".
 xdigit Any hexadecimal digit ("[0-9a-fA-F]").

Most POSIX character classes have two Unicode-style C<\p> property
counterparts.  (They are not official Unicode properties, but Perl extensions
derived from official Unicode properties.)  The table below shows the relation
between POSIX character classes and these counterparts.

One counterpart, in the column labelled "ASCII-range Unicode" in
the table will only match characters in the ASCII range.  (On EBCDIC platforms,
they match those characters which have ASCII equivalents.)

The other counterpart, in the column labelled "Full-range Unicode", matches any
appropriate characters in the full Unicode character set.  For example,
C<\p{Alpha}> will match not just the ASCII alphabetic characters, but any
character in the entire Unicode character set that is considered to be
alphabetic.

(Each of the counterparts has various synonyms as well.
L<perluniprops/Properties accessible through \p{} and \P{}> lists all the
synonyms, plus all the characters matched by each of the ASCII-range
properties.  For example C<\p{AHex}> is a synonym for C<\p{ASCII_Hex_Digit}>,
and any C<\p> property name can be prefixed with "Is" such as C<\p{IsAlpha}>.)

Both the C<\p> forms are unaffected by any locale that is in effect, or whether
the string is in UTF-8 format or not, or whether the platform is EBCDIC or not.
In contrast, the POSIX character classes are affected.  If the source string is
in UTF-8 format, the POSIX classes (with the exception of C<[[:punct:]]>, see
Note [5]) behave like their "Full-range" Unicode counterparts.  If the source
string is not in UTF-8 format, and no locale is in effect, and the platform is
not EBCDIC, all the POSIX classes behave like their ASCII-range counterparts.
Otherwise, they behave based on the rules of the locale or EBCDIC code page.
It is proposed to change this behavior in a future release of Perl so that the
the UTF8ness of the source string will be irrelevant to the behavior of the
POSIX character classes.  This means they will always behave in strict
accordance with the official POSIX standard.  That is, if either locale or
EBCDIC code page is present, they will behave in accordance with those; if
absent, the classes will match only their ASCII-range counterparts.  If you
disagree with this proposal, send email to C<perl5-porters@@perl.org>.

 [[:...:]]      ASCII-range        Full-range  backslash  Note
                 Unicode            Unicode    sequence
 -----------------------------------------------------
   alpha      \p{PosixAlpha}       \p{Alpha}
   alnum      \p{PosixAlnum}       \p{Alnum}
   ascii      \p{ASCII}          
   blank      \p{PosixBlank}       \p{Blank} =             [1]
                                   \p{HorizSpace}  \h      [1]
   cntrl      \p{PosixCntrl}       \p{Cntrl}               [2]
   digit      \p{PosixDigit}       \p{Digit}       \d
   graph      \p{PosixGraph}       \p{Graph}               [3]
   lower      \p{PosixLower}       \p{Lower}
   print      \p{PosixPrint}       \p{Print}               [4]
   punct      \p{PosixPunct}       \p{Punct}               [5]
              \p{PerlSpace}        \p{SpacePerl}   \s      [6]
   space      \p{PosixSpace}       \p{Space}               [6]
   upper      \p{PosixUpper}       \p{Upper}
   word       \p{PerlWord}         \p{Word}        \w
   xdigit     \p{ASCII_Hex_Digit}  \p{XDigit}
d434 1
a434 5
=item [1]

C<\p{Blank}> and C<\p{HorizSpace}> are synonyms.

=item [2]
d436 6
a441 4
Control characters don't produce output as such, but instead usually control
the terminal somehow: for example newline and backspace are control characters.
In the ASCII range, characters whose ordinals are between 0 and 31 inclusive,
plus 127 (C<DEL>) are control characters.
d443 1
a443 5
On EBCDIC platforms, it is likely that the code page will define C<[[:cntrl:]]>
to be the EBCDIC equivalents of the ASCII controls, plus the controls
that in Unicode have ordinals from 128 through 139.

=item [3]
d448 1
a448 1
=item [4]
d451 1
a451 16
plus whitespace characters that are not also controls.

=item [5]

C<\p{PosixPunct}> and C<[[:punct:]]> in the ASCII range match all the
non-controls, non-alphanumeric, non-space characters:
C<[-!"#$%&'()*+,./:;<=E<gt>?@@[\\\]^_`{|}~]> (although if a locale is in effect,
it could alter the behavior of C<[[:punct:]]>).

When the matching string is in UTF-8 format, C<[[:punct:]]> matches the above
set, plus what C<\p{Punct}> matches.  This is different than strictly matching
according to C<\p{Punct}>, because the above set includes characters that aren't
considered punctuation by Unicode, but rather "symbols".  Another way to say it
is that for a UTF-8 string, C<[[:punct:]]> matches all the characters that
Unicode considers to be punctuation, plus all the ASCII-range characters that
Unicode considers to be symbols.
d453 1
a453 1
=item [6]
d455 1
a455 2
C<\p{SpacePerl}> and C<\p{Space}> differ only in that C<\p{Space}> additionally
matches the vertical tab, C<\cK>.   Same for the two ASCII-only range forms.
a459 1
X<character class, negation>
d465 4
a468 7
     POSIX         ASCII-range     Full-range  backslash
                    Unicode         Unicode    sequence
 -----------------------------------------------------
 [[:^digit:]]   \P{PosixDigit}     \P{Digit}      \D
 [[:^space:]]   \P{PosixSpace}     \P{Space}
                \P{PerlSpace}      \P{SpacePerl}  \S
 [[:^word:]]    \P{PerlWord}       \P{Word}       \W
d473 1
a473 1
C<[.class.]>, but does not (yet?) support them.  Use of
d482 7
a488 9
 /[[:digit:][:^xdigit:]]/ # Matches a character that can be anything
			  # except the letters 'a' to 'f'.  This is
			  # because the main character class is composed
			  # of two POSIX character classes that are ORed
			  # together, one that matches any digit, and
			  # the other that matches anything that isn't a
			  # hex digit.  The result matches all
			  # characters except the letters 'a' to 'f' and
			  # 'A' to 'F'.
d491 1
a491 1
=head2 Locale, EBCDIC, Unicode and UTF-8
d495 1
a495 1
in effect, and if the program is running on an EBCDIC platform.
d498 1
a498 3
including C<\W>, C<\D>, C<\S>) suffer from this behaviour.  (Since the backslash
sequences C<\b> and C<\B> are defined in terms of C<\w> and C<\W>, they also are
affected.)
d502 3
a504 4
isn't, then the character classes match according to whatever locale or EBCDIC
code page is in effect. If there is no locale nor EBCDIC, they match the ASCII
defaults (52 letters, 10 digits and underscore for C<\w>; 0 to 9 for C<\d>;
etc.).
d508 4
a511 5
or not depending on the current locale or EBCDIC code page, and whether the
source string is in UTF-8 format. The string will be in UTF-8 format if it
contains characters whose C<ord()> value exceeds 255. But a string may be in
UTF-8 format without it having such characters.  See L<perluniprops/The
"Unicode Bug">.
@


1.1.1.4
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d12 1
a12 1
classes in Perl regular expressions.
d14 1
a14 1
A character class is a way of denoting a set of characters
d16 1
a16 1
It's important to remember that: matching a character class
d21 1
a21 1
expressions: the dot, backslash sequences, and the form enclosed in square
d23 1
a23 1
to mean just the bracketed form.  Certainly, most Perl documentation does that.
d29 4
a32 6
character, except for the newline. That default can be changed to
add matching the newline by using the I<single line> modifier: either
for the entire regular expression with the C</s> modifier, or
locally with C<(?s)>.  (The experimental C<\N> backslash sequence, described
below, matches any character except newline without regard to the
I<single line> modifier.)
d44 2
a45 2
=head2 Backslash sequences
X<\w> X<\W> X<\s> X<\S> X<\d> X<\D> X<\p> X<\P>
d49 6
a54 9
A backslash sequence is a sequence of characters, the first one of which is a
backslash.  Perl ascribes special meaning to many such sequences, and some of
these are character classes.  That is, they match a single character each,
provided that the character belongs to the specific set of characters defined
by the sequence.

Here's a list of the backslash sequences that are character classes.  They
are discussed in more detail below.  (For the backslash sequences that aren't
character classes, see L<perlrebackslash>.)
d56 5
a60 2
 \d             Match a decimal digit character.
 \D             Match a non-decimal-digit character.
d67 1
d70 2
a71 17
 \N             Match a character that isn't a newline.  Experimental.
 \pP, \p{Prop}  Match a character that has the given Unicode property.
 \PP, \P{Prop}  Match a character that doesn't have the Unicode property

=head3 \N

C<\N> is new in 5.12, and is experimental.  It, like the dot, matches any
character that is not a newline. The difference is that C<\N> is not influenced
by the I<single line> regular expression modifier (see L</The dot> above).  Note
that the form C<\N{...}> may mean something completely different.  When the
C<{...}> is a L<quantifier|perlre/Quantifiers>, it means to match a non-newline
character that many times.  For example, C<\N{3}> means to match 3
non-newlines; C<\N{5,}> means to match 5 or more non-newlines.  But if C<{...}>
is not a legal quantifier, it is presumed to be a named character.  See
L<charnames> for those.  For example, none of C<\N{COLON}>, C<\N{4F}>, and
C<\N{F4}> contain legal quantifiers, so Perl will try to find characters whose
names are respectively C<COLON>, C<4F>, and C<F4>.
d75 7
a81 46
C<\d> matches a single character considered to be a decimal I<digit>.
If the C</a> regular expression modifier is in effect, it matches [0-9].
Otherwise, it
matches anything that is matched by C<\p{Digit}>, which includes [0-9].
(An unlikely possible exception is that under locale matching rules, the
current locale might not have [0-9] matched by C<\d>, and/or might match
other characters whose code point is less than 256.  Such a locale
definition would be in violation of the C language standard, but Perl
doesn't currently assume anything in regard to this.)

What this means is that unless the C</a> modifier is in effect C<\d> not
only matches the digits '0' - '9', but also Arabic, Devanagari, and
digits from other languages.  This may cause some confusion, and some
security issues.

Some digits that C<\d> matches look like some of the [0-9] ones, but
have different values.  For example, BENGALI DIGIT FOUR (U+09EA) looks
very much like an ASCII DIGIT EIGHT (U+0038).  An application that
is expecting only the ASCII digits might be misled, or if the match is
C<\d+>, the matched string might contain a mixture of digits from
different writing systems that look like they signify a number different
than they actually do.  L<Unicode::UCD/num()> can
be used to safely
calculate the value, returning C<undef> if the input string contains
such a mixture.

What C<\p{Digit}> means (and hence C<\d> except under the C</a>
modifier) is C<\p{General_Category=Decimal_Number}>, or synonymously,
C<\p{General_Category=Digit}>.  Starting with Unicode version 4.1, this
is the same set of characters matched by C<\p{Numeric_Type=Decimal}>.
But Unicode also has a different property with a similar name,
C<\p{Numeric_Type=Digit}>, which matches a completely different set of
characters.  These characters are things such as C<CIRCLED DIGIT ONE>
or subscripts, or are from writing systems that lack all ten digits.

The design intent is for C<\d> to exactly match the set of characters
that can safely be used with "normal" big-endian positional decimal
syntax, where, for example 123 means one 'hundred', plus two 'tens',
plus three 'ones'.  This positional notation does not necessarily apply
to characters that match the other type of "digit",
C<\p{Numeric_Type=Digit}>, and so C<\d> doesn't match them.

The Tamil digits (U+0BE6 - U+0BEF) can also legally be
used in old-style Tamil numbers in which they would appear no more than
one in a row, separated by characters that mean "times 10", "times 100",
etc.  (See L<http://www.unicode.org/notes/tn21>.)
d83 1
a83 1
Any character not matched by C<\d> is matched by C<\D>.
d88 11
a98 51
decimal digit) or a connecting punctuation character, such as an
underscore ("_").  It does not match a whole word.  To match a whole
word, use C<\w+>.  This isn't the same thing as matching an English word, but
in the ASCII range it is the same as a string of Perl-identifier
characters.

=over

=item If the C</a> modifier is in effect ...

C<\w> matches the 63 characters [a-zA-Z0-9_].

=item otherwise ...

=over

=item For code points above 255 ...

C<\w> matches the same as C<\p{Word}> matches in this range.  That is,
it matches Thai letters, Greek letters, etc.  This includes connector
punctuation (like the underscore) which connect two words together, or
diacritics, such as a C<COMBINING TILDE> and the modifier letters, which
are generally used to add auxiliary markings to letters.

=item For code points below 256 ...

=over

=item if locale rules are in effect ...

C<\w> matches the platform's native underscore character plus whatever
the locale considers to be alphanumeric.

=item if Unicode rules are in effect or if on an EBCDIC platform ...

C<\w> matches exactly what C<\p{Word}> matches.

=item otherwise ...

C<\w> matches [a-zA-Z0-9_].

=back

=back

=back

Which rules apply are determined as described in L<perlre/Which character set modifier is in effect?>.

There are a number of security issues with the full Unicode list of word
characters.  See L<http://unicode.org/reports/tr36>.
d100 1
a100 7
Also, for a somewhat finer-grained set of characters that are in programming
language identifiers beyond the ASCII range, you may wish to instead use the
more customized L</Unicode Properties>, C<\p{ID_Start}>,
C<\p{ID_Continue}>, C<\p{XID_Start}>, and C<\p{XID_Continue}>.  See
L<http://unicode.org/reports/tr31>.

Any character not matched by C<\w> is matched by C<\W>.
d104 39
a142 62
C<\s> matches any single character considered whitespace.

=over

=item If the C</a> modifier is in effect ...

C<\s> matches the 5 characters [\t\n\f\r ]; that is, the horizontal tab,
the newline, the form feed, the carriage return, and the space.  (Note
that it doesn't match the vertical tab, C<\cK> on ASCII platforms.)

=item otherwise ...

=over

=item For code points above 255 ...

C<\s> matches exactly the code points above 255 shown with an "s" column
in the table below.

=item For code points below 256 ...

=over

=item if locale rules are in effect ...

C<\s> matches whatever the locale considers to be whitespace.  Note that
this is likely to include the vertical space, unlike non-locale C<\s>
matching.

=item if Unicode rules are in effect or if on an EBCDIC platform ...

C<\s> matches exactly the characters shown with an "s" column in the
table below.

=item otherwise ...

C<\s> matches [\t\n\f\r ].
Note that this list doesn't include the non-breaking space.

=back

=back

=back

Which rules apply are determined as described in L<perlre/Which character set modifier is in effect?>.

Any character not matched by C<\s> is matched by C<\S>.

C<\h> matches any character considered horizontal whitespace;
this includes the platform's space and tab characters and several others
listed in the table below.  C<\H> matches any character
not considered horizontal whitespace.  They use the platform's native
character set, and do not consider any locale that may otherwise be in
use.

C<\v> matches any character considered vertical whitespace;
this includes the platform's carriage return and line feed characters (newline)
plus several other characters, all listed in the table below.
C<\V> matches any character not considered vertical whitespace.
They use the platform's native character set, and do not consider any
locale that may otherwise be in use.
d147 1
a147 3
class; use C<\v> instead (vertical whitespace).  It uses the platform's
native character set, and does not consider any locale that may
otherwise be in use.
d150 13
a162 7
Note that unlike C<\s> (and C<\d> and C<\w>), C<\h> and C<\v> always match
the same characters, without regard to other factors, such as the active
locale or whether the source string is in UTF-8 format.

One might think that C<\s> is equivalent to C<[\h\v]>. This is not true.
The difference is that the vertical tab (C<"\x0b">) is not matched by
C<\s>; it is however considered vertical whitespace.
d165 1
a165 1
C<\s>, C<\h> and C<\v> as of Unicode 6.0.
d167 1
a167 1
The first column gives the Unicode code point of the character (in hex format),
d172 26
a197 26
 0x0009        CHARACTER TABULATION   h s
 0x000a              LINE FEED (LF)    vs
 0x000b             LINE TABULATION    v
 0x000c              FORM FEED (FF)    vs
 0x000d        CARRIAGE RETURN (CR)    vs
 0x0020                       SPACE   h s
 0x0085             NEXT LINE (NEL)    vs  [1]
 0x00a0              NO-BREAK SPACE   h s  [1]
 0x1680            OGHAM SPACE MARK   h s
 0x180e   MONGOLIAN VOWEL SEPARATOR   h s
 0x2000                     EN QUAD   h s
 0x2001                     EM QUAD   h s
 0x2002                    EN SPACE   h s
 0x2003                    EM SPACE   h s
 0x2004          THREE-PER-EM SPACE   h s
 0x2005           FOUR-PER-EM SPACE   h s
 0x2006            SIX-PER-EM SPACE   h s
 0x2007                FIGURE SPACE   h s
 0x2008           PUNCTUATION SPACE   h s
 0x2009                  THIN SPACE   h s
 0x200a                  HAIR SPACE   h s
 0x2028              LINE SEPARATOR    vs
 0x2029         PARAGRAPH SEPARATOR    vs
 0x202f       NARROW NO-BREAK SPACE   h s
 0x205f   MEDIUM MATHEMATICAL SPACE   h s
 0x3000           IDEOGRAPHIC SPACE   h s
d203 2
a204 3
NEXT LINE and NO-BREAK SPACE may or may not match C<\s> depending
on the rules in effect.  See
L<the beginning of this section|/Whitespace>.
d208 5
d220 1
a220 1
which means to match if the property "name" for the character has that particular
d225 1
a225 1
has the short form I<Ll>. They need the braces, so are written as C</\p{Ll}/> or
d232 1
a232 25
If neither the C</a> modifier nor locale rules are in effect, the use of
a Unicode property will force the regular expression into using Unicode
rules.

Note that almost all properties are immune to case-insensitive matching.
That is, adding a C</i> regular expression modifier does not change what
they match.  There are two sets that are affected.  The first set is
C<Uppercase_Letter>,
C<Lowercase_Letter>,
and C<Titlecase_Letter>,
all of which match C<Cased_Letter> under C</i> matching.
The second set is
C<Uppercase>,
C<Lowercase>,
and C<Titlecase>,
all of which match C<Cased> under C</i> matching.
(The difference between these sets is that some things, such as Roman
numerals, come in both upper and lower case, so they are C<Cased>, but
aren't considered to be letters, so they aren't C<Cased_Letter>s. They're
actually C<Letter_Number>s.)
This set also includes its subsets C<PosixUpper> and C<PosixLower>, both
of which under C</i> match C<PosixAlpha>.

For more details on Unicode properties, see L<perlunicode/Unicode
Character Properties>; for a
d234 1
a234 2
L<perluniprops/Properties accessible through \p{} and \P{}>,
which notes all forms that have C</i> differences.
a237 10
Unicode properties are defined (surprise!) only on Unicode code points.
A warning is raised and all matches fail on non-Unicode code points
(those above the legal Unicode maximum of 0x10FFFF).  This can be
somewhat surprising,

 chr(0x110000) =~ \p{ASCII_Hex_Digit=True}      # Fails.
 chr(0x110000) =~ \p{ASCII_Hex_Digit=False}     # Also fails!

Even though these two matches might be thought of as complements, they
are so only on Unicode code points.
a261 4
It is worth emphasizing that C<\d>, C<\w>, etc, match single characters, not
complete numbers or words. To match a number (that consists of digits),
use C<\d+>; to match a word, use C<\w+>.  But be aware of the security
considerations in doing so, as mentioned above.
d266 1
a266 1
is the bracketed character class.  In its simplest form, it lists the characters
d269 1
a269 1
character classes, exactly one character is matched.* To match
d271 2
a272 2
class, follow the character class with a L<quantifier|perlre/Quantifiers>.  For
instance, C<[aeiou]+> matches one or more lowercase English vowels.
a284 13
 -------

* There is an exception to a bracketed character class matching a
single character only.  When the class is to match caselessly under C</i>
matching rules, and a character inside the class matches a
multiple-character sequence caselessly under Unicode rules, the class
(when not L<inverted|/Negation>) will also match that sequence.  For
example, Unicode says that the letter C<LATIN SMALL LETTER SHARP S>
should match the sequence C<ss> under C</i> rules.  Thus,

 'ss' =~ /\A\N{LATIN SMALL LETTER SHARP S}\z/i             # Matches
 'ss' =~ /\A[aeioust\N{LATIN SMALL LETTER SHARP S}]\z/i    # Matches

d300 1
a300 1
outside the character class, C<\b> is an assertion indicating a point
d312 1
a312 1
C<\N{U+I<hex char>}>,
d317 2
a318 4
are also special and have the same meanings as they do outside a
bracketed character class.  (However, inside a bracketed character
class, if C<\N{I<NAME>}> expands to a sequence of characters, only the first
one in the sequence is used, with a warning.)
d323 2
a324 8
A C<[> is not special inside a character class, unless it's the start of a
POSIX character class (see L</POSIX Character Classes> below). It normally does
not need escaping.

A C<]> is normally either the end of a POSIX character class (see
L</POSIX Character Classes> below), or it signals the end of the bracketed
character class.  If you want to include a C<]> in the set of characters, you
must generally escape it.
d326 3
d349 1
a349 1
of listing all characters in the range, one may use the hyphen (C<->).
d351 1
a351 1
by a hyphen, it's treated as if all characters between the two were in
d356 1
a356 1
necessarily both letters or both digits. Any character is possible,
d358 1
a358 1
most people will not know which characters that means.  Furthermore,
d364 5
a368 5
or if it immediately follows a range, the hyphen isn't special, and so is
considered a character to be matched literally.  If you want a hyphen in
your set of characters to be matched and its position in the class is such
that it could be considered part of a range, you must escape that hyphen
with a backslash.
d386 2
a387 3
character class. For instance, C<[^a-z]> matches any character that is not a
lowercase ASCII letter, which therefore includes more than a million
Unicode code points.  The class is said to be "negated" or "inverted".
d391 2
a392 16
the caret as one of the characters to match, either escape the caret or
else don't list it first.

In inverted bracketed character classes, Perl ignores the Unicode rules
that normally say that certain characters should match a sequence of
multiple characters under caseless C</i> matching.  Following those
rules could lead to highly confusing situations:

 "ss" =~ /^[^\xDF]+$/ui;   # Matches!

This should match any sequences of characters that aren't C<\xDF> nor
what C<\xDF> matches under C</i>.  C<"s"> isn't C<\xDF>, but Unicode
says that C<"ss"> is what C<\xDF> matches under C</i>.  So which one
"wins"? Do you fail the match because the string has C<ss> or accept it
because it has an C<s> followed by another C<s>?  Perl has chosen the
latter.
d404 9
a412 11
C<\N> and C<\R>) inside a bracketed character class, and it will act just
as if you had put all characters matched by the backslash sequence inside the
character class. For instance, C<[a-f\d]> matches any decimal digit, or any
of the lowercase letters between 'a' and 'f' inclusive.

C<\N> within a bracketed character class must be of the forms C<\N{I<name>}>
or C<\N{U+I<hex char>}>, and NOT be the form that matches non-newlines,
for the same reason that a dot C<.> inside a bracketed character class loses
its special meaning: it matches nearly anything, which generally isn't what you
want to happen.

d422 1
a422 3
of a range.  Thus, you can't say:

 /[\p{Thai}-\d]/     # Wrong!
d424 1
a424 1
=head3 POSIX Character Classes
d429 2
a430 2
POSIX character classes have the form C<[:class:]>, where I<class> is
name, and the C<[:> and C<:]> delimiters. POSIX character classes only appear
d432 3
a434 3
way of listing a group of characters.

Be careful about the syntax,
d444 2
a445 2
POSIX character classes can be part of a larger bracketed character class.
For example,
d454 1
a454 1
 alnum  Any alphanumeric character. ("[A-Za-z0-9]")
d474 2
a475 1
the table, matches only characters in the ASCII character set.
d479 25
a503 4
C<\p{Alpha}> matches not just the ASCII alphabetic characters, but any
character in the entire Unicode character set considered alphabetic.
An entry in the column labelled "backslash sequence" is a (short)
equivalent.
d505 2
a506 2
 [[:...:]]      ASCII-range          Full-range  backslash  Note
                 Unicode              Unicode     sequence
d508 16
a523 16
   alpha      \p{PosixAlpha}       \p{XPosixAlpha}
   alnum      \p{PosixAlnum}       \p{XPosixAlnum}
   ascii      \p{ASCII}
   blank      \p{PosixBlank}       \p{XPosixBlank}  \h      [1]
                                   or \p{HorizSpace}        [1]
   cntrl      \p{PosixCntrl}       \p{XPosixCntrl}          [2]
   digit      \p{PosixDigit}       \p{XPosixDigit}  \d
   graph      \p{PosixGraph}       \p{XPosixGraph}          [3]
   lower      \p{PosixLower}       \p{XPosixLower}
   print      \p{PosixPrint}       \p{XPosixPrint}          [4]
   punct      \p{PosixPunct}       \p{XPosixPunct}          [5]
              \p{PerlSpace}        \p{XPerlSpace}   \s      [6]
   space      \p{PosixSpace}       \p{XPosixSpace}          [6]
   upper      \p{PosixUpper}       \p{XPosixUpper}
   word       \p{PosixWord}        \p{XPosixWord}   \w
   xdigit     \p{PosixXDigit}      \p{XPosixXDigit}
d534 2
a535 2
the terminal somehow: for example, newline and backspace are control characters.
In the ASCII range, characters whose code points are between 0 and 31 inclusive,
d540 1
a540 1
that in Unicode have code pointss from 128 through 159.
d545 1
a545 1
of all alphanumeric characters and all punctuation characters.
d549 2
a550 2
All printable characters, which is the set of all graphical characters
plus those whitespace characters which are not also controls.
d554 1
a554 1
C<\p{PosixPunct}> and C<[[:punct:]]> in the ASCII range match all
d559 7
a565 14
The similarly named property, C<\p{Punct}>, matches a somewhat different
set in the ASCII range, namely
C<[-!"#%&'()*,./:;?@@[\\\]_{}]>.  That is, it is missing the nine
characters C<[$+E<lt>=E<gt>^`|~]>.
This is because Unicode splits what POSIX considers to be punctuation into two
categories, Punctuation and Symbols.

C<\p{XPosixPunct}> and (under Unicode rules) C<[[:punct:]]>, match what
C<\p{PosixPunct}> matches in the ASCII range, plus what C<\p{Punct}>
matches.  This is different than strictly matching according to
C<\p{Punct}>.  Another way to say it is that
if Unicode rules are in effect, C<[[:punct:]]> matches all characters
that Unicode considers punctuation, plus all ASCII-range characters that
Unicode considers symbols.
d569 1
a569 2
C<\p{SpacePerl}> and C<\p{Space}> differ only in that in non-locale
matching, C<\p{Space}> additionally
d574 1
a574 62
There are various other synonyms that can be used besides the names
listed in the table.  For example, C<\p{PosixAlpha}> can be written as
C<\p{Alpha}>.  All are listed in
L<perluniprops/Properties accessible through \p{} and \P{}>,
plus all characters matched by each ASCII-range property.

Both the C<\p> counterparts always assume Unicode rules are in effect.
On ASCII platforms, this means they assume that the code points from 128
to 255 are Latin-1, and that means that using them under locale rules is
unwise unless the locale is guaranteed to be Latin-1 or UTF-8.  In contrast, the
POSIX character classes are useful under locale rules.  They are
affected by the actual rules in effect, as follows:

=over

=item If the C</a> modifier, is in effect ...

Each of the POSIX classes matches exactly the same as their ASCII-range
counterparts.

=item otherwise ...

=over

=item For code points above 255 ...

The POSIX class matches the same as its Full-range counterpart.

=item For code points below 256 ...

=over

=item if locale rules are in effect ...

The POSIX class matches according to the locale, except that
C<word> uses the platform's native underscore character, no matter what
the locale is.

=item if Unicode rules are in effect or if on an EBCDIC platform ...

The POSIX class matches the same as the Full-range counterpart.

=item otherwise ...

The POSIX class matches the same as the ASCII range counterpart.

=back

=back

=back

Which rules apply are determined as described in
L<perlre/Which character set modifier is in effect?>.

It is proposed to change this behavior in a future release of Perl so that
whether or not Unicode rules are in effect would not change the
behavior:  Outside of locale or an EBCDIC code page, the POSIX classes
would behave like their ASCII-range counterparts.  If you wish to
comment on this proposal, send email to C<perl5-porters@@perl.org>.

=head4 Negation of POSIX character classes
d584 4
a587 4
 [[:^digit:]]   \P{PosixDigit}  \P{XPosixDigit}   \D
 [[:^space:]]   \P{PosixSpace}  \P{XPosixSpace}
                \P{PerlSpace}   \P{XPerlSpace}    \S
 [[:^word:]]    \P{PerlWord}    \P{XPosixWord}    \W
d589 1
a589 2
The backslash sequence can mean either ASCII- or Full-range Unicode,
depending on various factors as described in L<perlre/Which character set modifier is in effect?>.
d591 3
a593 1
=head4 [= =] and [. .]
a594 3
Perl recognizes the POSIX character classes C<[=class=]> and
C<[.class.]>, but does not (yet?) support them.  Any attempt to use
either construct raises an exception.
d610 41
@


1.1.1.5
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d32 1
a32 1
locally with C<(?s)>.  (The C<\N> backslash sequence, described
d71 1
a71 1
 \N             Match a character that isn't a newline.
d77 1
a77 1
C<\N>, available starting in v5.12, like the dot, matches any
d143 5
a147 6
decimal digit); or a connecting punctuation character, such as an
underscore ("_"); or a "mark" character (like some sort of accent) that
attaches to one of those.  It does not match a whole word.  To match a
whole word, use C<\w+>.  This isn't the same thing as matching an
English word, but in the ASCII range it is the same as a string of
Perl-identifier characters.
d176 1
a176 1
=item if Unicode rules are in effect ...
d211 3
a213 5
In all Perl versions, C<\s> matches the 5 characters [\t\n\f\r ]; that
is, the horizontal tab,
the newline, the form feed, the carriage return, and the space.
Starting in Perl v5.18, experimentally, it also matches the vertical tab, C<\cK>.
See note C<[1]> below for a discussion of this.
d230 3
a232 1
C<\s> matches whatever the locale considers to be whitespace.
d234 1
a234 1
=item if Unicode rules are in effect ...
d241 1
a241 3
C<\s> matches [\t\n\f\r\cK ] and, starting, experimentally in Perl
v5.18, the vertical tab, C<\cK>.
(See note C<[1]> below for a discussion of this.)
d280 3
a282 3
One might think that C<\s> is equivalent to C<[\h\v]>. This is indeed true
starting in Perl v5.18, but prior to that, the sole difference was that the
vertical tab (C<"\cK">) was not matched by C<\s>.
d289 2
a290 2
by which class(es) the character is matched (assuming no locale is in
effect that changes the C<\s> matching).
d294 1
a294 1
 0x000b             LINE TABULATION    vs  [1]
d298 2
a299 2
 0x0085             NEXT LINE (NEL)    vs  [2]
 0x00a0              NO-BREAK SPACE   h s  [2]
a322 10
Prior to Perl v5.18, C<\s> did not match the vertical tab.  The change
in v5.18 is considered an experiment, which means it could be backed out
in v5.20 or v5.22 if experience indicates that it breaks too much
existing code.  If this change adversely affects you, send email to
C<perlbug@@perl.org>; if it affects you positively, email
C<perlthanks@@perl.org>.  In the meantime, C<[^\S\cK]> (obscurely)
matches what C<\s> traditionally did.

=item [2]

d348 1
a348 1
If locale rules are not in effect, the use of
d350 1
a350 1
rules, if it isn't already.
d444 1
a444 2
matching rules, and a character that is explicitly mentioned inside the
class matches a
a452 12
For this to happen, the character must be explicitly specified, and not
be part of a multi-character range (not even as one of its endpoints).
(L</Character Ranges> will be explained shortly.)  Therefore,

 'ss' =~ /\A[\0-\x{ff}]\z/i        # Doesn't match
 'ss' =~ /\A[\0-\N{LATIN SMALL LETTER SHARP S}]\z/i    # No match
 'ss' =~ /\A[\xDF-\xDF]\z/i    # Matches on ASCII platforms, since \XDF
                               # is LATIN SMALL LETTER SHARP S, and the
                               # range is just a single element

Note that it isn't a good idea to specify these types of ranges anyway.

d511 1
a511 1
 "\cH" =~ /[\b]/      #  Match, \b inside in a character class.
d646 1
a646 1
 alnum  Any alphanumeric character ("[A-Za-z0-9]").
d655 1
a655 2
 space  Any whitespace character. "\s" including the vertical tab
        ("\cK").
d708 4
d746 3
a748 4
C<\p{SpacePerl}> and C<\p{Space}> match identically starting with Perl
v5.18.  In earlier versions, these differ only in that in non-locale
matching, C<\p{SpacePerl}> does not match the vertical tab, C<\cK>.
Same for the two ASCII-only range forms.
d790 1
a790 1
=item if Unicode rules are in effect ...
d809 1
a809 1
behavior:  Outside of locale, the POSIX classes
d843 8
a850 215
                          # except the letters 'a' to 'f' and 'A' to
                          # 'F'.  This is because the main character
                          # class is composed of two POSIX character
                          # classes that are ORed together, one that
                          # matches any digit, and the other that
                          # matches anything that isn't a hex digit.
                          # The OR adds the digits, leaving only the
                          # letters 'a' to 'f' and 'A' to 'F' excluded.

=head3 Extended Bracketed Character Classes
X<character class>
X<set operations>

This is a fancy bracketed character class that can be used for more
readable and less error-prone classes, and to perform set operations,
such as intersection. An example is

 /(?[ \p{Thai} & \p{Digit} ])/

This will match all the digit characters that are in the Thai script.

This is an experimental feature available starting in 5.18, and is
subject to change as we gain field experience with it.  Any attempt to
use it will raise a warning, unless disabled via

 no warnings "experimental::regex_sets";

Comments on this feature are welcome; send email to
C<perl5-porters@@perl.org>.

We can extend the example above:

 /(?[ ( \p{Thai} + \p{Lao} ) & \p{Digit} ])/

This matches digits that are in either the Thai or Laotian scripts.

Notice the white space in these examples.  This construct always has
the C<E<sol>x> modifier turned on.

The available binary operators are:

 &    intersection
 +    union
 |    another name for '+', hence means union
 -    subtraction (the result matches the set consisting of those
      code points matched by the first operand, excluding any that
      are also matched by the second operand)
 ^    symmetric difference (the union minus the intersection).  This
      is like an exclusive or, in that the result is the set of code
      points that are matched by either, but not both, of the
      operands.

There is one unary operator:

 !    complement

All the binary operators left associate, and are of equal precedence.
The unary operator right associates, and has higher precedence.  Use
parentheses to override the default associations.  Some feedback we've
received indicates a desire for intersection to have higher precedence
than union.  This is something that feedback from the field may cause us
to change in future releases; you may want to parenthesize copiously to
avoid such changes affecting your code, until this feature is no longer
considered experimental.

The main restriction is that everything is a metacharacter.  Thus,
you cannot refer to single characters by doing something like this:

 /(?[ a + b ])/ # Syntax error!

The easiest way to specify an individual typable character is to enclose
it in brackets:

 /(?[ [a] + [b] ])/

(This is the same thing as C<[ab]>.)  You could also have said the
equivalent:

 /(?[[ a b ]])/

(You can, of course, specify single characters by using, C<\x{ }>,
C<\N{ }>, etc.)

This last example shows the use of this construct to specify an ordinary
bracketed character class without additional set operations.  Note the
white space within it; C<E<sol>x> is turned on even within bracketed
character classes, except you can't have comments inside them.  Hence,

 (?[ [#] ])

matches the literal character "#".  To specify a literal white space character,
you can escape it with a backslash, like:

 /(?[ [ a e i o u \  ] ])/

This matches the English vowels plus the SPACE character.
All the other escapes accepted by normal bracketed character classes are
accepted here as well; but unrecognized escapes that generate warnings
in normal classes are fatal errors here.

All warnings from these class elements are fatal, as well as some
practices that don't currently warn.  For example you cannot say

 /(?[ [ \xF ] ])/     # Syntax error!

You have to have two hex digits after a braceless C<\x> (use a leading
zero to make two).  These restrictions are to lower the incidence of
typos causing the class to not match what you thought it would.

The final difference between regular bracketed character classes and
these, is that it is not possible to get these to match a
multi-character fold.  Thus,

 /(?[ [\xDF] ])/iu

does not match the string C<ss>.

You don't have to enclose POSIX class names inside double brackets,
hence both of the following work:

 /(?[ [:word:] - [:lower:] ])/
 /(?[ [[:word:]] - [[:lower:]] ])/

Any contained POSIX character classes, including things like C<\w> and C<\D>
respect the C<E<sol>a> (and C<E<sol>aa>) modifiers.

C<< (?[ ]) >> is a regex-compile-time construct.  Any attempt to use
something which isn't knowable at the time the containing regular
expression is compiled is a fatal error.  In practice, this means
just three limitiations:

=over 4

=item 1

This construct cannot be used within the scope of
C<use locale> (or the C<E<sol>l> regex modifier).

=item 2

Any
L<user-defined property|perlunicode/"User-Defined Character Properties">
used must be already defined by the time the regular expression is
compiled (but note that this construct can be used instead of such
properties).

=item 3

A regular expression that otherwise would compile
using C<E<sol>d> rules, and which uses this construct will instead
use C<E<sol>u>.  Thus this construct tells Perl that you don't want
C<E<sol>d> rules for the entire regular expression containing it.

=back

The C<E<sol>x> processing within this class is an extended form.
Besides the characters that are considered white space in normal C</x>
processing, there are 5 others, recommended by the Unicode standard:

 U+0085 NEXT LINE
 U+200E LEFT-TO-RIGHT MARK
 U+200F RIGHT-TO-LEFT MARK
 U+2028 LINE SEPARATOR
 U+2029 PARAGRAPH SEPARATOR

Note that skipping white space applies only to the interior of this
construct.  There must not be any space between any of the characters
that form the initial C<(?[>.  Nor may there be space between the
closing C<])> characters.

Just as in all regular expressions, the pattern can can be built up by
including variables that are interpolated at regex compilation time.
Care must be taken to ensure that you are getting what you expect.  For
example:

 my $thai_or_lao = '\p{Thai} + \p{Lao}';
 ...
 qr/(?[ \p{Digit} & $thai_or_lao ])/;

compiles to

 qr/(?[ \p{Digit} & \p{Thai} + \p{Lao} ])/;

But this does not have the effect that someone reading the code would
likely expect, as the intersection applies just to C<\p{Thai}>,
excluding the Laotian.  Pitfalls like this can be avoided by
parenthesizing the component pieces:

 my $thai_or_lao = '( \p{Thai} + \p{Lao} )';

But any modifiers will still apply to all the components:

 my $lower = '\p{Lower} + \p{Digit}';
 qr/(?[ \p{Greek} & $lower ])/i;

matches upper case things.  You can avoid surprises by making the
components into instances of this construct by compiling them:

 my $thai_or_lao = qr/(?[ \p{Thai} + \p{Lao} ])/;
 my $lower = qr/(?[ \p{Lower} + \p{Digit} ])/;

When these are embedded in another pattern, what they match does not
change, regardless of parenthesization or what modifiers are in effect
in that outer pattern.

Due to the way that Perl parses things, your parentheses and brackets
may need to be balanced, even including comments.  If you run into any
examples, please send them to C<perlbug@@perl.org>, so that we can have a
concrete example for this man page.

We may change it so that things that remain legal uses in normal bracketed
character classes might become illegal within this experimental
construct.  One proposal, for example, is to forbid adjacent uses of the
same character, as in C<(?[ [aa] ])>.  The motivation for such a change
is that this usage is likely a typo, as the second "a" adds nothing.
@


1.1.1.6
log
@Import perl-5.20.1
@
text
@d32 1
a32 1
locally with C<(?s)>.  (The C<L</\N>> backslash sequence, described
d96 4
a99 6
current locale might not have C<[0-9]> matched by C<\d>, and/or might match
other characters whose code point is less than 256.  The only such locale
definitions that are legal would be to match C<[0-9]> plus another set of
10 consecutive digit characters;  anything else would be in violation of
the C language standard, but Perl doesn't currently assume anything in
regard to this.)
d242 1
a242 1
C<\s> matches [\t\n\f\r ] and, starting, experimentally in Perl
d288 1
a288 1
C<\s>, C<\h> and C<\v> as of Unicode 6.3.
d304 1
d328 1
a328 1
in v5.22 if experience indicates that it breaks too much
d393 3
a395 10
Starting in v5.20, when matching against C<\p> and C<\P>, Perl treats
non-Unicode code points (those above the legal Unicode maximum of
0x10FFFF) as if they were typical unassigned Unicode code points.

Prior to v5.20, Perl raised a warning and made all matches fail on
non-Unicode code points.  This could be somewhat surprising:

 chr(0x110000) =~ \p{ASCII_Hex_Digit=True}     # Fails on Perls < v5.20.
 chr(0x110000) =~ \p{ASCII_Hex_Digit=False}    # Also fails on Perls
                                               # < v5.20
d397 5
a401 2
Even though these two matches might be thought of as complements, until
v5.20 they were so only on Unicode code points.
d647 1
a647 1
POSIX character classes have the form C<[:class:]>, where I<class> is the
a661 1

d779 2
a780 1
L<perluniprops/Properties accessible through \p{} and \P{}>.
d810 2
a811 7
The POSIX class matches according to the locale, except:

=over

=item C<word>

also includes the platform's native underscore character, no matter what
a813 12
=item C<ascii>

on platforms that don't have the POSIX C<ascii> extension, this matches
just the platform's native ASCII-range characters.

=item C<blank>

on platforms that don't have the POSIX C<blank> extension, this matches
just the platform's native tab and space characters.

=back

d904 1
a904 1
the C<E<sol>x> modifier turned on within it.
d947 2
a948 2
(You can, of course, specify single characters by using, C<\x{...}>,
C<\N{...}>, etc.)
a975 5
If a regular bracketed character class contains a C<\p{}> or C<\P{}> and
is matched against a non-Unicode code point, a warning may be
raised, as the result is not Unicode-defined.  No such warning will come
when using this extended form.

d996 1
a996 1
just three limitations:
d1037 1
a1037 1
Just as in all regular expressions, the pattern can be built up by
@


1.1.1.7
log
@Import perl-5.20.2
@
text
@d775 1
a775 1
C<\p{XPerlSpace}> and C<\p{Space}> match identically starting with Perl
d777 1
a777 1
matching, C<\p{XPerlSpace}> does not match the vertical tab, C<\cK>.
@


