head	1.13;
access;
symbols
	OPENBSD_5_3:1.12.0.10
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.8
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.6
	OPENBSD_5_0:1.12.0.4
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	PERL_5_12_2:1.1.1.12
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	PERL_5_10_1:1.1.1.11
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	PERL_5_10_0:1.1.1.10
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	PERL_5_8_8:1.1.1.9
	OPENBSD_3_9:1.8.0.8
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.6
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	PERL_5_8_6:1.1.1.8
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.13
date	2013.03.25.20.40.58;	author sthen;	state dead;
branches;
next	1.12;

1.12
date	2010.09.24.15.07.03;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.12.18.24.47;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.29.17.36.16;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.28.19.23.10;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.09.18.10.15;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2004.04.07.21.33.08;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.03.03.02.44;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.33;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.24.18.35.54;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.07.27;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.04.29.22.52.11;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.11.30.07.59.10;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.40.43;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.10.23;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.24.36;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.04;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.44.21;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.04.07.21.13.33;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.48.10;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2005.01.15.21.17.53;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2006.03.28.18.49.18;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2008.09.29.17.18.51;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2009.10.12.18.10.39;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2010.09.24.14.49.08;	author millert;	state Exp;
branches;
next	;


desc
@perl 5.004_04
@


1.13
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@=head1 NAME

perlfaq5 - Files and Formats

=head1 DESCRIPTION

This section deals with I/O and the "f" issues: filehandles, flushing,
formats, and footers.

=head2 How do I flush/unbuffer an output filehandle?  Why must I do this?
X<flush> X<buffer> X<unbuffer> X<autoflush>

(contributed by brian d foy)

You might like to read Mark Jason Dominus's "Suffering From Buffering"
at http://perl.plover.com/FAQs/Buffering.html .

Perl normally buffers output so it doesn't make a system call for every
bit of output. By saving up output, it makes fewer expensive system calls.
For instance, in this little bit of code, you want to print a dot to the
screen for every line you process to watch the progress of your program.
Instead of seeing a dot for every line, Perl buffers the output and you
have a long wait before you see a row of 50 dots all at once:

	# long wait, then row of dots all at once
	while( <> ) {
		print ".";
		print "\n" unless ++$count % 50;

		#... expensive line processing operations
		}

To get around this, you have to unbuffer the output filehandle, in this
case, C<STDOUT>. You can set the special variable C<$|> to a true value
(mnemonic: making your filehandles "piping hot"):

	$|++;

	# dot shown immediately
	while( <> ) {
		print ".";
		print "\n" unless ++$count % 50;

		#... expensive line processing operations
		}

The C<$|> is one of the per-filehandle special variables, so each
filehandle has its own copy of its value. If you want to merge
standard output and standard error for instance, you have to unbuffer
each (although STDERR might be unbuffered by default):

	{
	my $previous_default = select(STDOUT);  # save previous default
	$|++;                                   # autoflush STDOUT
	select(STDERR);
	$|++;                                   # autoflush STDERR, to be sure
	select($previous_default);              # restore previous default
	}

	# now should alternate . and +
	while( 1 )
		{
		sleep 1;
		print STDOUT ".";
		print STDERR "+";
		print STDOUT "\n" unless ++$count % 25;
		}

Besides the C<$|> special variable, you can use C<binmode> to give
your filehandle a C<:unix> layer, which is unbuffered:

	binmode( STDOUT, ":unix" );

	while( 1 ) {
		sleep 1;
		print ".";
		print "\n" unless ++$count % 50;
		}

For more information on output layers, see the entries for C<binmode>
and C<open> in L<perlfunc>, and the C<PerlIO> module documentation.

If you are using C<IO::Handle> or one of its subclasses, you can
call the C<autoflush> method to change the settings of the
filehandle:

	use IO::Handle;
	open my( $io_fh ), ">", "output.txt";
	$io_fh->autoflush(1);

The C<IO::Handle> objects also have a C<flush> method. You can flush
the buffer any time you want without auto-buffering

	$io_fh->flush;

=head2 How do I change, delete, or insert a line in a file, or append to the beginning of a file?
X<file, editing>

(contributed by brian d foy)

The basic idea of inserting, changing, or deleting a line from a text
file involves reading and printing the file to the point you want to
make the change, making the change, then reading and printing the rest
of the file. Perl doesn't provide random access to lines (especially
since the record input separator, C<$/>, is mutable), although modules
such as C<Tie::File> can fake it.

A Perl program to do these tasks takes the basic form of opening a
file, printing its lines, then closing the file:

	open my $in,  '<',  $file      or die "Can't read old file: $!";
	open my $out, '>', "$file.new" or die "Can't write new file: $!";

	while( <$in> )
		{
		print $out $_;
		}

   close $out;

Within that basic form, add the parts that you need to insert, change,
or delete lines.

To prepend lines to the beginning, print those lines before you enter
the loop that prints the existing lines.

	open my $in,  '<',  $file      or die "Can't read old file: $!";
	open my $out, '>', "$file.new" or die "Can't write new file: $!";

	print $out "# Add this line to the top\n"; # <--- HERE'S THE MAGIC

	while( <$in> )
		{
		print $out $_;
		}

   close $out;

To change existing lines, insert the code to modify the lines inside
the C<while> loop. In this case, the code finds all lowercased
versions of "perl" and uppercases them. The happens for every line, so
be sure that you're supposed to do that on every line!

	open my $in,  '<',  $file      or die "Can't read old file: $!";
	open my $out, '>', "$file.new" or die "Can't write new file: $!";

	print $out "# Add this line to the top\n";

	while( <$in> )
		{
		s/\b(perl)\b/Perl/g;
		print $out $_;
		}

   close $out;

To change only a particular line, the input line number, C<$.>, is
useful. First read and print the lines up to the one you  want to
change. Next, read the single line you want to change, change it, and
print it. After that, read the rest of the lines and print those:

	while( <$in> )   # print the lines before the change
		{
		print $out $_;
		last if $. == 4; # line number before change
		}

	my $line = <$in>;
	$line =~ s/\b(perl)\b/Perl/g;
	print $out $line;

	while( <$in> )   # print the rest of the lines
		{
		print $out $_;
		}

To skip lines, use the looping controls. The C<next> in this example
skips comment lines, and the C<last> stops all processing once it
encounters either C<__END__> or C<__DATA__>.

	while( <$in> )
		{
		next if /^\s+#/;             # skip comment lines
		last if /^__(END|DATA)__$/;  # stop at end of code marker
		print $out $_;
		}

Do the same sort of thing to delete a particular line by using C<next>
to skip the lines you don't want to show up in the output. This
example skips every fifth line:

	while( <$in> )
		{
		next unless $. % 5;
		print $out $_;
		}

If, for some odd reason, you really want to see the whole file at once
rather than processing line-by-line, you can slurp it in (as long as
you can fit the whole thing in memory!):

	open my $in,  '<',  $file      or die "Can't read old file: $!"
	open my $out, '>', "$file.new" or die "Can't write new file: $!";

	my @@lines = do { local $/; <$in> }; # slurp!

		# do your magic here

	print $out @@lines;

Modules such as C<File::Slurp> and C<Tie::File> can help with that
too. If you can, however, avoid reading the entire file at once. Perl
won't give that memory back to the operating system until the process
finishes.

You can also use Perl one-liners to modify a file in-place. The
following changes all 'Fred' to 'Barney' in F<inFile.txt>, overwriting
the file with the new contents. With the C<-p> switch, Perl wraps a
C<while> loop around the code you specify with C<-e>, and C<-i> turns
on in-place editing. The current line is in C<$_>. With C<-p>, Perl
automatically prints the value of C<$_> at the end of the loop. See
L<perlrun> for more details.

	perl -pi -e 's/Fred/Barney/' inFile.txt

To make a backup of C<inFile.txt>, give C<-i> a file extension to add:

	perl -pi.bak -e 's/Fred/Barney/' inFile.txt

To change only the fifth line, you can add a test checking C<$.>, the
input line number, then only perform the operation when the test
passes:

	perl -pi -e 's/Fred/Barney/ if $. == 5' inFile.txt

To add lines before a certain line, you can add a line (or lines!)
before Perl prints C<$_>:

	perl -pi -e 'print "Put before third line\n" if $. == 3' inFile.txt

You can even add a line to the beginning of a file, since the current
line prints at the end of the loop:

	perl -pi -e 'print "Put before first line\n" if $. == 1' inFile.txt

To insert a line after one already in the file, use the C<-n> switch.
It's just like C<-p> except that it doesn't print C<$_> at the end of
the loop, so you have to do that yourself. In this case, print C<$_>
first, then print the line that you want to add.

	perl -ni -e 'print; print "Put after fifth line\n" if $. == 5' inFile.txt

To delete lines, only print the ones that you want.

	perl -ni -e 'print unless /d/' inFile.txt

		... or ...

	perl -pi -e 'next unless /d/' inFile.txt

=head2 How do I count the number of lines in a file?
X<file, counting lines> X<lines> X<line>

(contributed by brian d foy)

Conceptually, the easiest way to count the lines in a file is to
simply read them and count them:

	my $count = 0;
	while( <$fh> ) { $count++; }

You don't really have to count them yourself, though, since Perl
already does that with the C<$.> variable, which is the current line
number from the last filehandle read:

	1 while( <$fh> );
	my $count = $.;

If you want to use C<$.>, you can reduce it to a simple one-liner,
like one of these:

	% perl -lne '} print $.; {'    file

	% perl -lne 'END { print $. }' file

Those can be rather inefficient though. If they aren't fast enough for
you, you might just read chunks of data and count the number of
newlines:

	my $lines = 0;
	open my($fh), '<:raw', $filename or die "Can't open $filename: $!";
	while( sysread $fh, $buffer, 4096 ) {
		$lines += ( $buffer =~ tr/\n// );
		}
	close FILE;

However, that doesn't work if the line ending isn't a newline. You
might change that C<tr///> to a C<s///> so you can count the number of
times the input record separator, C<$/>, shows up:

	my $lines = 0;
	open my($fh), '<:raw', $filename or die "Can't open $filename: $!";
	while( sysread $fh, $buffer, 4096 ) {
		$lines += ( $buffer =~ s|$/||g; );
		}
	close FILE;

If you don't mind shelling out, the C<wc> command is usually the
fastest, even with the extra interprocess overhead. Ensure that you
have an untainted filename though:

	#!perl -T

	$ENV{PATH} = undef;

	my $lines;
	if( $filename =~ /^([0-9a-z_.]+)\z/ ) {
		$lines = `/usr/bin/wc -l $1`
		chomp $lines;
		}

=head2 How do I delete the last N lines from a file?
X<lines> X<file>

(contributed by brian d foy)

The easiest conceptual solution is to count the lines in the
file then start at the beginning and print the number of lines
(minus the last N) to a new file.

Most often, the real question is how you can delete the last N lines
without making more than one pass over the file, or how to do it
without a lot of copying. The easy concept is the hard reality when
you might have millions of lines in your file.

One trick is to use C<File::ReadBackwards>, which starts at the end of
the file. That module provides an object that wraps the real filehandle
to make it easy for you to move around the file. Once you get to the
spot you need, you can get the actual filehandle and work with it as
normal. In this case, you get the file position at the end of the last
line you want to keep and truncate the file to that point:

	use File::ReadBackwards;

	my $filename = 'test.txt';
	my $Lines_to_truncate = 2;

	my $bw = File::ReadBackwards->new( $filename )
		or die "Could not read backwards in [$filename]: $!";

	my $lines_from_end = 0;
	until( $bw->eof or $lines_from_end == $Lines_to_truncate )
		{
		print "Got: ", $bw->readline;
		$lines_from_end++;
		}

	truncate( $filename, $bw->tell );

The C<File::ReadBackwards> module also has the advantage of setting
the input record separator to a regular expression.

You can also use the C<Tie::File> module which lets you access
the lines through a tied array. You can use normal array operations
to modify your file, including setting the last index and using
C<splice>.

=head2 How can I use Perl's C<-i> option from within a program?
X<-i> X<in-place>

C<-i> sets the value of Perl's C<$^I> variable, which in turn affects
the behavior of C<< <> >>; see L<perlrun> for more details. By
modifying the appropriate variables directly, you can get the same
behavior within a larger program. For example:

	# ...
	{
	local($^I, @@ARGV) = ('.orig', glob("*.c"));
	while (<>) {
		if ($. == 1) {
			print "This line should appear at the top of each file\n";
		}
		s/\b(p)earl\b/${1}erl/i;        # Correct typos, preserving case
		print;
		close ARGV if eof;              # Reset $.
		}
	}
	# $^I and @@ARGV return to their old values here

This block modifies all the C<.c> files in the current directory,
leaving a backup of the original data from each file in a new
C<.c.orig> file.

=head2 How can I copy a file?
X<copy> X<file, copy> X<File::Copy>

(contributed by brian d foy)

Use the C<File::Copy> module. It comes with Perl and can do a
true copy across file systems, and it does its magic in
a portable fashion.

	use File::Copy;

	copy( $original, $new_copy ) or die "Copy failed: $!";

If you can't use C<File::Copy>, you'll have to do the work yourself:
open the original file, open the destination file, then print
to the destination file as you read the original. You also have to
remember to copy the permissions, owner, and group to the new file.

=head2 How do I make a temporary file name?
X<file, temporary>

If you don't need to know the name of the file, you can use C<open()>
with C<undef> in place of the file name. In Perl 5.8 or later, the
C<open()> function creates an anonymous temporary file:

	open my $tmp, '+>', undef or die $!;

Otherwise, you can use the File::Temp module.

	use File::Temp qw/ tempfile tempdir /;

	my $dir = tempdir( CLEANUP => 1 );
	($fh, $filename) = tempfile( DIR => $dir );

	# or if you don't need to know the filename

	my $fh = tempfile( DIR => $dir );

The File::Temp has been a standard module since Perl 5.6.1. If you
don't have a modern enough Perl installed, use the C<new_tmpfile>
class method from the IO::File module to get a filehandle opened for
reading and writing. Use it if you don't need to know the file's name:

	use IO::File;
	my $fh = IO::File->new_tmpfile()
		or die "Unable to make new temporary file: $!";

If you're committed to creating a temporary file by hand, use the
process ID and/or the current time-value. If you need to have many
temporary files in one process, use a counter:

	BEGIN {
	use Fcntl;
	my $temp_dir = -d '/tmp' ? '/tmp' : $ENV{TMPDIR} || $ENV{TEMP};
	my $base_name = sprintf "%s/%d-%d-0000", $temp_dir, $$, time;

	sub temp_file {
		local *FH;
		my $count = 0;
		until( defined(fileno(FH)) || $count++ > 100 ) {
			$base_name =~ s/-(\d+)$/"-" . (1 + $1)/e;
			# O_EXCL is required for security reasons.
			sysopen my($fh), $base_name, O_WRONLY|O_EXCL|O_CREAT;
			}

		if( defined fileno($fh) ) {
			return ($fh, $base_name);
			}
		else {
			return ();
			}
		}

	}

=head2 How can I manipulate fixed-record-length files?
X<fixed-length> X<file, fixed-length records>

The most efficient way is using L<pack()|perlfunc/"pack"> and
L<unpack()|perlfunc/"unpack">. This is faster than using
L<substr()|perlfunc/"substr"> when taking many, many strings. It is
slower for just a few.

Here is a sample chunk of code to break up and put back together again
some fixed-format input lines, in this case from the output of a normal,
Berkeley-style ps:

	# sample input line:
	#   15158 p5  T      0:00 perl /home/tchrist/scripts/now-what
	my $PS_T = 'A6 A4 A7 A5 A*';
	open my $ps, '-|', 'ps';
	print scalar <$ps>;
	my @@fields = qw( pid tt stat time command );
	while (<$ps>) {
		my %process;
		@@process{@@fields} = unpack($PS_T, $_);
	for my $field ( @@fields ) {
		print "$field: <$process{$field}>\n";
	}
	print 'line=', pack($PS_T, @@process{@@fields} ), "\n";
	}

We've used a hash slice in order to easily handle the fields of each row.
Storing the keys in an array means it's easy to operate on them as a
group or loop over them with for. It also avoids polluting the program
with global variables and using symbolic references.

=head2 How can I make a filehandle local to a subroutine?  How do I pass filehandles between subroutines?  How do I make an array of filehandles?
X<filehandle, local> X<filehandle, passing> X<filehandle, reference>

As of perl5.6, open() autovivifies file and directory handles
as references if you pass it an uninitialized scalar variable.
You can then pass these references just like any other scalar,
and use them in the place of named handles.

	open my    $fh, $file_name;

	open local $fh, $file_name;

	print $fh "Hello World!\n";

	process_file( $fh );

If you like, you can store these filehandles in an array or a hash.
If you access them directly, they aren't simple scalars and you
need to give C<print> a little help by placing the filehandle
reference in braces. Perl can only figure it out on its own when
the filehandle reference is a simple scalar.

	my @@fhs = ( $fh1, $fh2, $fh3 );

	for( $i = 0; $i <= $#fhs; $i++ ) {
		print {$fhs[$i]} "just another Perl answer, \n";
		}

Before perl5.6, you had to deal with various typeglob idioms
which you may see in older code.

	open FILE, "> $filename";
	process_typeglob(   *FILE );
	process_reference( \*FILE );

	sub process_typeglob  { local *FH = shift; print FH  "Typeglob!" }
	sub process_reference { local $fh = shift; print $fh "Reference!" }

If you want to create many anonymous handles, you should
check out the Symbol or IO::Handle modules.

=head2 How can I use a filehandle indirectly?
X<filehandle, indirect>

An indirect filehandle is using something other than a symbol
in a place that a filehandle is expected. Here are ways
to get indirect filehandles:

	$fh =   SOME_FH;       # bareword is strict-subs hostile
	$fh =  "SOME_FH";      # strict-refs hostile; same package only
	$fh =  *SOME_FH;       # typeglob
	$fh = \*SOME_FH;       # ref to typeglob (bless-able)
	$fh =  *SOME_FH{IO};   # blessed IO::Handle from *SOME_FH typeglob

Or, you can use the C<new> method from one of the IO::* modules to
create an anonymous filehandle, store that in a scalar variable,
and use it as though it were a normal filehandle.

	use IO::Handle;                     # 5.004 or higher
	my $fh = IO::Handle->new();

Then use any of those as you would a normal filehandle. Anywhere that
Perl is expecting a filehandle, an indirect filehandle may be used
instead. An indirect filehandle is just a scalar variable that contains
a filehandle. Functions like C<print>, C<open>, C<seek>, or
the C<< <FH> >> diamond operator will accept either a named filehandle
or a scalar variable containing one:

	($ifh, $ofh, $efh) = (*STDIN, *STDOUT, *STDERR);
	print $ofh "Type it: ";
	my $got = <$ifh>
	print $efh "What was that: $got";

If you're passing a filehandle to a function, you can write
the function in two ways:

	sub accept_fh {
		my $fh = shift;
		print $fh "Sending to indirect filehandle\n";
	}

Or it can localize a typeglob and use the filehandle directly:

	sub accept_fh {
		local *FH = shift;
		print  FH "Sending to localized filehandle\n";
	}

Both styles work with either objects or typeglobs of real filehandles.
(They might also work with strings under some circumstances, but this
is risky.)

	accept_fh(*STDOUT);
	accept_fh($handle);

In the examples above, we assigned the filehandle to a scalar variable
before using it. That is because only simple scalar variables, not
expressions or subscripts of hashes or arrays, can be used with
built-ins like C<print>, C<printf>, or the diamond operator. Using
something other than a simple scalar variable as a filehandle is
illegal and won't even compile:

	my @@fd = (*STDIN, *STDOUT, *STDERR);
	print $fd[1] "Type it: ";                           # WRONG
	my $got = <$fd[0]>                                  # WRONG
	print $fd[2] "What was that: $got";                 # WRONG

With C<print> and C<printf>, you get around this by using a block and
an expression where you would place the filehandle:

	print  { $fd[1] } "funny stuff\n";
	printf { $fd[1] } "Pity the poor %x.\n", 3_735_928_559;
	# Pity the poor deadbeef.

That block is a proper block like any other, so you can put more
complicated code there. This sends the message out to one of two places:

	my $ok = -x "/bin/cat";
	print { $ok ? $fd[1] : $fd[2] } "cat stat $ok\n";
	print { $fd[ 1+ ($ok || 0) ]  } "cat stat $ok\n";

This approach of treating C<print> and C<printf> like object methods
calls doesn't work for the diamond operator. That's because it's a
real operator, not just a function with a comma-less argument. Assuming
you've been storing typeglobs in your structure as we did above, you
can use the built-in function named C<readline> to read a record just
as C<< <> >> does. Given the initialization shown above for @@fd, this
would work, but only because readline() requires a typeglob. It doesn't
work with objects or strings, which might be a bug we haven't fixed yet.

	$got = readline($fd[0]);

Let it be noted that the flakiness of indirect filehandles is not
related to whether they're strings, typeglobs, objects, or anything else.
It's the syntax of the fundamental operators. Playing the object
game doesn't help you at all here.

=head2 How can I set up a footer format to be used with write()?
X<footer>

There's no builtin way to do this, but L<perlform> has a couple of
techniques to make it possible for the intrepid hacker.

=head2 How can I write() into a string?
X<write, into a string>

See L<perlform/"Accessing Formatting Internals"> for an C<swrite()> function.

=head2 How can I open a filehandle to a string?
X<string> X<open> X<IO::String> X<filehandle>

(contributed by Peter J. Holzer, hjp-usenet2@@hjp.at)

Since Perl 5.8.0 a file handle referring to a string can be created by
calling open with a reference to that string instead of the filename.
This file handle can then be used to read from or write to the string:

	open(my $fh, '>', \$string) or die "Could not open string for writing";
	print $fh "foo\n";
	print $fh "bar\n";	# $string now contains "foo\nbar\n"

	open(my $fh, '<', \$string) or die "Could not open string for reading";
	my $x = <$fh>;	# $x now contains "foo\n"

With older versions of Perl, the C<IO::String> module provides similar
functionality.

=head2 How can I output my numbers with commas added?
X<number, commify>

(contributed by brian d foy and Benjamin Goldberg)

You can use L<Number::Format> to separate places in a number.
It handles locale information for those of you who want to insert
full stops instead (or anything else that they want to use,
really).

This subroutine will add commas to your number:

	sub commify {
		local $_  = shift;
		1 while s/^([-+]?\d+)(\d{3})/$1,$2/;
		return $_;
		}

This regex from Benjamin Goldberg will add commas to numbers:

	s/(^[-+]?\d+?(?=(?>(?:\d{3})+)(?!\d))|\G\d{3}(?=\d))/$1,/g;

It is easier to see with comments:

	s/(
		^[-+]?             # beginning of number.
		\d+?               # first digits before first comma
		(?=                # followed by, (but not included in the match) :
			(?>(?:\d{3})+) # some positive multiple of three digits.
			(?!\d)         # an *exact* multiple, not x * 3 + 1 or whatever.
		)
		|                  # or:
		\G\d{3}            # after the last group, get three digits
		(?=\d)             # but they have to have more digits after them.
	)/$1,/xg;

=head2 How can I translate tildes (~) in a filename?
X<tilde> X<tilde expansion>

Use the E<lt>E<gt> (C<glob()>) operator, documented in L<perlfunc>.
Versions of Perl older than 5.6 require that you have a shell
installed that groks tildes. Later versions of Perl have this feature
built in. The C<File::KGlob> module (available from CPAN) gives more
portable glob functionality.

Within Perl, you may use this directly:

	$filename =~ s{
	  ^ ~             # find a leading tilde
	  (               # save this in $1
	      [^/]        # a non-slash character
	            *     # repeated 0 or more times (0 means me)
	  )
	}{
	  $1
	      ? (getpwnam($1))[7]
	      : ( $ENV{HOME} || $ENV{LOGDIR} )
	}ex;

=head2 How come when I open a file read-write it wipes it out?
X<clobber> X<read-write> X<clobbering> X<truncate> X<truncating>

Because you're using something like this, which truncates the file and
I<then> gives you read-write access:

	open my $fh, '+>', '/path/name'; # WRONG (almost always)

Whoops. You should instead use this, which will fail if the file
doesn't exist.

	open my $fh, '+<', '/path/name'; # open for update

Using ">" always clobbers or creates. Using "<" never does
either. The "+" doesn't change this.

Here are examples of many kinds of file opens. Those using sysopen()
all assume

	use Fcntl;

To open file for reading:

	open my $fh, '<', $path                                 or die $!;
	sysopen my $fh, $path, O_RDONLY                         or die $!;

To open file for writing, create new file if needed or else truncate old file:

	open my $fh, '>', $path                                 or die $!;
	sysopen my $fh, $path, O_WRONLY|O_TRUNC|O_CREAT         or die $!;
	sysopen my $fh, $path, O_WRONLY|O_TRUNC|O_CREAT, 0666   or die $!;

To open file for writing, create new file, file must not exist:

	sysopen my $fh, $path, O_WRONLY|O_EXCL|O_CREAT          or die $!;
	sysopen my $fh, $path, O_WRONLY|O_EXCL|O_CREAT, 0666    or die $!;

To open file for appending, create if necessary:

	open my $fh, '>>' $path                                 or die $!;
	sysopen my $fh, $path, O_WRONLY|O_APPEND|O_CREAT        or die $!;
	sysopen my $fh, $path, O_WRONLY|O_APPEND|O_CREAT, 0666  or die $!;

To open file for appending, file must exist:

	sysopen my $fh, $path, O_WRONLY|O_APPEND                or die $!;

To open file for update, file must exist:

	open my $fh, '+<', $path                                or die $!;
	sysopen my $fh, $path, O_RDWR                           or die $!;

To open file for update, create file if necessary:

	sysopen my $fh, $path, O_RDWR|O_CREAT                   or die $!;
	sysopen my $fh, $path, O_RDWR|O_CREAT, 0666             or die $!;

To open file for update, file must not exist:

	sysopen my $fh, $path, O_RDWR|O_EXCL|O_CREAT            or die $!;
	sysopen my $fh, $path, O_RDWR|O_EXCL|O_CREAT, 0666      or die $!;

To open a file without blocking, creating if necessary:

	sysopen my $fh, '/foo/somefile', O_WRONLY|O_NDELAY|O_CREAT
	    or die "can't open /foo/somefile: $!":

Be warned that neither creation nor deletion of files is guaranteed to
be an atomic operation over NFS. That is, two processes might both
successfully create or unlink the same file! Therefore O_EXCL
isn't as exclusive as you might wish.

See also the new L<perlopentut>.

=head2 Why do I sometimes get an "Argument list too long" when I use E<lt>*E<gt>?
X<argument list too long>

The C<< <> >> operator performs a globbing operation (see above).
In Perl versions earlier than v5.6.0, the internal glob() operator forks
csh(1) to do the actual glob expansion, but
csh can't handle more than 127 items and so gives the error message
C<Argument list too long>. People who installed tcsh as csh won't
have this problem, but their users may be surprised by it.

To get around this, either upgrade to Perl v5.6.0 or later, do the glob
yourself with readdir() and patterns, or use a module like File::KGlob,
one that doesn't use the shell to do globbing.

=head2 Is there a leak/bug in glob()?
X<glob>

(contributed by brian d foy)

Starting with Perl 5.6.0, C<glob> is implemented internally rather
than relying on an external resource. As such, memory issues with
C<glob> aren't a problem in modern perls.

=head2 How can I open a file with a leading ">" or trailing blanks?
X<filename, special characters>

(contributed by Brian McCauley)

The special two argument form of Perl's open() function ignores
trailing blanks in filenames and infers the mode from certain leading
characters (or a trailing "|"). In older versions of Perl this was the
only version of open() and so it is prevalent in old code and books.

Unless you have a particular reason to use the two argument form you
should use the three argument form of open() which does not treat any
characters in the filename as special.

	open my $fh, "<", "  file  ";  # filename is "   file   "
	open my $fh, ">", ">file";     # filename is ">file"

=head2 How can I reliably rename a file?
X<rename> X<mv> X<move> X<file, rename>

If your operating system supports a proper mv(1) utility or its
functional equivalent, this works:

	rename($old, $new) or system("mv", $old, $new);

It may be more portable to use the C<File::Copy> module instead.
You just copy to the new file to the new name (checking return
values), then delete the old one. This isn't really the same
semantically as a C<rename()>, which preserves meta-information like
permissions, timestamps, inode info, etc.

=head2 How can I lock a file?
X<lock> X<file, lock> X<flock>

Perl's builtin flock() function (see L<perlfunc> for details) will call
flock(2) if that exists, fcntl(2) if it doesn't (on perl version 5.004 and
later), and lockf(3) if neither of the two previous system calls exists.
On some systems, it may even use a different form of native locking.
Here are some gotchas with Perl's flock():

=over 4

=item 1

Produces a fatal error if none of the three system calls (or their
close equivalent) exists.

=item 2

lockf(3) does not provide shared locking, and requires that the
filehandle be open for writing (or appending, or read/writing).

=item 3

Some versions of flock() can't lock files over a network (e.g. on NFS file
systems), so you'd need to force the use of fcntl(2) when you build Perl.
But even this is dubious at best. See the flock entry of L<perlfunc>
and the F<INSTALL> file in the source distribution for information on
building Perl to do this.

Two potentially non-obvious but traditional flock semantics are that
it waits indefinitely until the lock is granted, and that its locks are
I<merely advisory>. Such discretionary locks are more flexible, but
offer fewer guarantees. This means that files locked with flock() may
be modified by programs that do not also use flock(). Cars that stop
for red lights get on well with each other, but not with cars that don't
stop for red lights. See the perlport manpage, your port's specific
documentation, or your system-specific local manpages for details. It's
best to assume traditional behavior if you're writing portable programs.
(If you're not, you should as always feel perfectly free to write
for your own system's idiosyncrasies (sometimes called "features").
Slavish adherence to portability concerns shouldn't get in the way of
your getting your job done.)

For more information on file locking, see also
L<perlopentut/"File Locking"> if you have it (new for 5.6).

=back

=head2 Why can't I just open(FH, "E<gt>file.lock")?
X<lock, lockfile race condition>

A common bit of code B<NOT TO USE> is this:

	sleep(3) while -e 'file.lock';	# PLEASE DO NOT USE
	open my $lock, '>', 'file.lock'; # THIS BROKEN CODE

This is a classic race condition: you take two steps to do something
which must be done in one. That's why computer hardware provides an
atomic test-and-set instruction. In theory, this "ought" to work:

	sysopen my $fh, "file.lock", O_WRONLY|O_EXCL|O_CREAT
		or die "can't open  file.lock: $!";

except that lamentably, file creation (and deletion) is not atomic
over NFS, so this won't work (at least, not every time) over the net.
Various schemes involving link() have been suggested, but
these tend to involve busy-wait, which is also less than desirable.

=head2 I still don't get locking. I just want to increment the number in the file. How can I do this?
X<counter> X<file, counter>

Didn't anyone ever tell you web-page hit counters were useless?
They don't count number of hits, they're a waste of time, and they serve
only to stroke the writer's vanity. It's better to pick a random number;
they're more realistic.

Anyway, this is what you can do if you can't help yourself.

	use Fcntl qw(:DEFAULT :flock);
	sysopen my $fh, "numfile", O_RDWR|O_CREAT or die "can't open numfile: $!";
	flock $fh, LOCK_EX                        or die "can't flock numfile: $!";
	my $num = <$fh> || 0;
	seek $fh, 0, 0                            or die "can't rewind numfile: $!";
	truncate $fh, 0                           or die "can't truncate numfile: $!";
	(print $fh $num+1, "\n")                  or die "can't write numfile: $!";
	close $fh                                 or die "can't close numfile: $!";

Here's a much better web-page hit counter:

	$hits = int( (time() - 850_000_000) / rand(1_000) );

If the count doesn't impress your friends, then the code might. :-)

=head2 All I want to do is append a small amount of text to the end of a file. Do I still have to use locking?
X<append> X<file, append>

If you are on a system that correctly implements C<flock> and you use
the example appending code from "perldoc -f flock" everything will be
OK even if the OS you are on doesn't implement append mode correctly
(if such a system exists.) So if you are happy to restrict yourself to
OSs that implement C<flock> (and that's not really much of a
restriction) then that is what you should do.

If you know you are only going to use a system that does correctly
implement appending (i.e. not Win32) then you can omit the C<seek>
from the code in the previous answer.

If you know you are only writing code to run on an OS and filesystem
that does implement append mode correctly (a local filesystem on a
modern Unix for example), and you keep the file in block-buffered mode
and you write less than one buffer-full of output between each manual
flushing of the buffer then each bufferload is almost guaranteed to be
written to the end of the file in one chunk without getting
intermingled with anyone else's output. You can also use the
C<syswrite> function which is simply a wrapper around your system's
C<write(2)> system call.

There is still a small theoretical chance that a signal will interrupt
the system level C<write()> operation before completion. There is also
a possibility that some STDIO implementations may call multiple system
level C<write()>s even if the buffer was empty to start. There may be
some systems where this probability is reduced to zero, and this is
not a concern when using C<:perlio> instead of your system's STDIO.

=head2 How do I randomly update a binary file?
X<file, binary patch>

If you're just trying to patch a binary, in many cases something as
simple as this works:

	perl -i -pe 's{window manager}{window mangler}g' /usr/bin/emacs

However, if you have fixed sized records, then you might do something more
like this:

	$RECSIZE = 220; # size of record, in bytes
	$recno   = 37;  # which record to update
	open my $fh, '+<', 'somewhere' or die "can't update somewhere: $!";
	seek $fh, $recno * $RECSIZE, 0;
	read $fh, $record, $RECSIZE == $RECSIZE or die "can't read record $recno: $!";
	# munge the record
	seek $fh, -$RECSIZE, 1;
	print $fh $record;
	close $fh;

Locking and error checking are left as an exercise for the reader.
Don't forget them or you'll be quite sorry.

=head2 How do I get a file's timestamp in perl?
X<timestamp> X<file, timestamp>

If you want to retrieve the time at which the file was last read,
written, or had its meta-data (owner, etc) changed, you use the B<-A>,
B<-M>, or B<-C> file test operations as documented in L<perlfunc>.
These retrieve the age of the file (measured against the start-time of
your program) in days as a floating point number. Some platforms may
not have all of these times. See L<perlport> for details. To retrieve
the "raw" time in seconds since the epoch, you would call the stat
function, then use C<localtime()>, C<gmtime()>, or
C<POSIX::strftime()> to convert this into human-readable form.

Here's an example:

	my $write_secs = (stat($file))[9];
	printf "file %s updated at %s\n", $file,
	scalar localtime($write_secs);

If you prefer something more legible, use the File::stat module
(part of the standard distribution in version 5.004 and later):

	# error checking left as an exercise for reader.
	use File::stat;
	use Time::localtime;
	my $date_string = ctime(stat($file)->mtime);
	print "file $file updated at $date_string\n";

The POSIX::strftime() approach has the benefit of being,
in theory, independent of the current locale. See L<perllocale>
for details.

=head2 How do I set a file's timestamp in perl?
X<timestamp> X<file, timestamp>

You use the utime() function documented in L<perlfunc/utime>.
By way of example, here's a little program that copies the
read and write times from its first argument to all the rest
of them.

	if (@@ARGV < 2) {
		die "usage: cptimes timestamp_file other_files ...\n";
		}
	my $timestamp = shift;
	my($atime, $mtime) = (stat($timestamp))[8,9];
	utime $atime, $mtime, @@ARGV;

Error checking is, as usual, left as an exercise for the reader.

The perldoc for utime also has an example that has the same
effect as touch(1) on files that I<already exist>.

Certain file systems have a limited ability to store the times
on a file at the expected level of precision. For example, the
FAT and HPFS filesystem are unable to create dates on files with
a finer granularity than two seconds. This is a limitation of
the filesystems, not of utime().

=head2 How do I print to more than one file at once?
X<print, to multiple files>

To connect one filehandle to several output filehandles,
you can use the IO::Tee or Tie::FileHandle::Multiplex modules.

If you only have to do this once, you can print individually
to each filehandle.

	for my $fh (FH1, FH2, FH3) { print $fh "whatever\n" }

=head2 How can I read in an entire file all at once?
X<slurp> X<file, slurping>

Are you sure you want to read the entire file and store it in memory?
If you mmap the file, you can virtually load the entire file into a
string without actually storing it in memory:

	use File::Map qw(map_file);

	map_file my $string, $filename;

Once mapped, you can treat C<$string> as you would any other string.
Since you don't actually load the data, mmap-ing is very fast and does
not increase your memory footprint.

If you really want to load the entire file, you can use the
C<File::Slurp> module to do it in one step.

	use File::Slurp;

	my $all_of_it = read_file($filename); # entire file in scalar
	my @@all_lines = read_file($filename); # one line per element

The customary Perl approach for processing all the lines in a file is to
do so one line at a time:

	open my $input, '<', $file or die "can't open $file: $!";
	while (<$input>) {
		chomp;
		# do something with $_
		}
	close $input or die "can't close $file: $!";

This is tremendously more efficient than reading the entire file into
memory as an array of lines and then processing it one element at a time,
which is often--if not almost always--the wrong approach. Whenever
you see someone do this:

	my @@lines = <INPUT>;

You should think long and hard about why you need everything loaded at
once. It's just not a scalable solution. You might also find it more
fun to use the standard Tie::File module, or the DB_File module's
$DB_RECNO bindings, which allow you to tie an array to a file so that
accessing an element the array actually accesses the corresponding
line in the file.

You can read the entire filehandle contents into a scalar.

	{
	local $/;
	open my $fh, '<', $file or die "can't open $file: $!";
	$var = <$fh>;
	}

That temporarily undefs your record separator, and will automatically
close the file at block exit. If the file is already open, just use this:

	$var = do { local $/; <$fh> };

For ordinary files you can also use the read function.

	read( $fh, $var, -s $fh );

The third argument tests the byte size of the data on the INPUT filehandle
and reads that many bytes into the buffer $var.

=head2 How can I read in a file by paragraphs?
X<file, reading by paragraphs>

Use the C<$/> variable (see L<perlvar> for details). You can either
set it to C<""> to eliminate empty paragraphs (C<"abc\n\n\n\ndef">,
for instance, gets treated as two paragraphs and not three), or
C<"\n\n"> to accept empty paragraphs.

Note that a blank line must have no blanks in it. Thus
S<C<"fred\n \nstuff\n\n">> is one paragraph, but C<"fred\n\nstuff\n\n"> is two.

=head2 How can I read a single character from a file?  From the keyboard?
X<getc> X<file, reading one character at a time>

You can use the builtin C<getc()> function for most filehandles, but
it won't (easily) work on a terminal device. For STDIN, either use
the Term::ReadKey module from CPAN or use the sample code in
L<perlfunc/getc>.

If your system supports the portable operating system programming
interface (POSIX), you can use the following code, which you'll note
turns off echo processing as well.

	#!/usr/bin/perl -w
	use strict;
	$| = 1;
	for (1..4) {
		print "gimme: ";
		my $got = getone();
		print "--> $got\n";
		}
    exit;

	BEGIN {
	use POSIX qw(:termios_h);

	my ($term, $oterm, $echo, $noecho, $fd_stdin);

	my $fd_stdin = fileno(STDIN);

	$term     = POSIX::Termios->new();
	$term->getattr($fd_stdin);
	$oterm     = $term->getlflag();

	$echo     = ECHO | ECHOK | ICANON;
	$noecho   = $oterm & ~$echo;

	sub cbreak {
		$term->setlflag($noecho);
		$term->setcc(VTIME, 1);
		$term->setattr($fd_stdin, TCSANOW);
		}

	sub cooked {
		$term->setlflag($oterm);
		$term->setcc(VTIME, 0);
		$term->setattr($fd_stdin, TCSANOW);
		}

	sub getone {
		my $key = '';
		cbreak();
		sysread(STDIN, $key, 1);
		cooked();
		return $key;
		}

	}

	END { cooked() }

The Term::ReadKey module from CPAN may be easier to use. Recent versions
include also support for non-portable systems as well.

	use Term::ReadKey;
	open my $tty, '<', '/dev/tty';
	print "Gimme a char: ";
	ReadMode "raw";
	my $key = ReadKey 0, $tty;
	ReadMode "normal";
	printf "\nYou said %s, char number %03d\n",
		$key, ord $key;

=head2 How can I tell whether there's a character waiting on a filehandle?

The very first thing you should do is look into getting the Term::ReadKey
extension from CPAN. As we mentioned earlier, it now even has limited
support for non-portable (read: not open systems, closed, proprietary,
not POSIX, not Unix, etc.) systems.

You should also check out the Frequently Asked Questions list in
comp.unix.* for things like this: the answer is essentially the same.
It's very system dependent. Here's one solution that works on BSD
systems:

	sub key_ready {
		my($rin, $nfd);
		vec($rin, fileno(STDIN), 1) = 1;
		return $nfd = select($rin,undef,undef,0);
		}

If you want to find out how many characters are waiting, there's
also the FIONREAD ioctl call to be looked at. The I<h2ph> tool that
comes with Perl tries to convert C include files to Perl code, which
can be C<require>d. FIONREAD ends up defined as a function in the
I<sys/ioctl.ph> file:

	require 'sys/ioctl.ph';

	$size = pack("L", 0);
	ioctl(FH, FIONREAD(), $size)    or die "Couldn't call ioctl: $!\n";
	$size = unpack("L", $size);

If I<h2ph> wasn't installed or doesn't work for you, you can
I<grep> the include files by hand:

	% grep FIONREAD /usr/include/*/*
	/usr/include/asm/ioctls.h:#define FIONREAD      0x541B

Or write a small C program using the editor of champions:

	% cat > fionread.c
	#include <sys/ioctl.h>
	main() {
	    printf("%#08x\n", FIONREAD);
	}
	^D
	% cc -o fionread fionread.c
	% ./fionread
	0x4004667f

And then hard code it, leaving porting as an exercise to your successor.

	$FIONREAD = 0x4004667f;         # XXX: opsys dependent

	$size = pack("L", 0);
	ioctl(FH, $FIONREAD, $size)     or die "Couldn't call ioctl: $!\n";
	$size = unpack("L", $size);

FIONREAD requires a filehandle connected to a stream, meaning that sockets,
pipes, and tty devices work, but I<not> files.

=head2 How do I do a C<tail -f> in perl?
X<tail> X<IO::Handle> X<File::Tail> X<clearerr>

First try

	seek(GWFILE, 0, 1);

The statement C<seek(GWFILE, 0, 1)> doesn't change the current position,
but it does clear the end-of-file condition on the handle, so that the
next C<< <GWFILE> >> makes Perl try again to read something.

If that doesn't work (it relies on features of your stdio implementation),
then you need something more like this:

	for (;;) {
	  for ($curpos = tell(GWFILE); <GWFILE>; $curpos = tell(GWFILE)) {
	    # search for some stuff and put it into files
	  }
	  # sleep for a while
	  seek(GWFILE, $curpos, 0);  # seek to where we had been
	}

If this still doesn't work, look into the C<clearerr> method
from C<IO::Handle>, which resets the error and end-of-file states
on the handle.

There's also a C<File::Tail> module from CPAN.

=head2 How do I dup() a filehandle in Perl?
X<dup>

If you check L<perlfunc/open>, you'll see that several of the ways
to call open() should do the trick. For example:

	open my $log, '>>', '/foo/logfile';
	open STDERR, '>&LOG';

Or even with a literal numeric descriptor:

	my $fd = $ENV{MHCONTEXTFD};
	open $mhcontext, "<&=$fd";  # like fdopen(3S)

Note that "<&STDIN" makes a copy, but "<&=STDIN" make
an alias. That means if you close an aliased handle, all
aliases become inaccessible. This is not true with
a copied one.

Error checking, as always, has been left as an exercise for the reader.

=head2 How do I close a file descriptor by number?
X<file, closing file descriptors> X<POSIX> X<close>

If, for some reason, you have a file descriptor instead of a
filehandle (perhaps you used C<POSIX::open>), you can use the
C<close()> function from the C<POSIX> module:

	use POSIX ();

	POSIX::close( $fd );

This should rarely be necessary, as the Perl C<close()> function is to be
used for things that Perl opened itself, even if it was a dup of a
numeric descriptor as with C<MHCONTEXT> above. But if you really have
to, you may be able to do this:

	require 'sys/syscall.ph';
	my $rc = syscall(&SYS_close, $fd + 0);  # must force numeric
	die "can't sysclose $fd: $!" unless $rc == -1;

Or, just use the fdopen(3S) feature of C<open()>:

	{
	open my( $fh ), "<&=$fd" or die "Cannot reopen fd=$fd: $!";
	close $fh;
	}

=head2 Why can't I use "C:\temp\foo" in DOS paths?  Why doesn't `C:\temp\foo.exe` work?
X<filename, DOS issues>

Whoops!  You just put a tab and a formfeed into that filename!
Remember that within double quoted strings ("like\this"), the
backslash is an escape character. The full list of these is in
L<perlop/Quote and Quote-like Operators>. Unsurprisingly, you don't
have a file called "c:(tab)emp(formfeed)oo" or
"c:(tab)emp(formfeed)oo.exe" on your legacy DOS filesystem.

Either single-quote your strings, or (preferably) use forward slashes.
Since all DOS and Windows versions since something like MS-DOS 2.0 or so
have treated C</> and C<\> the same in a path, you might as well use the
one that doesn't clash with Perl--or the POSIX shell, ANSI C and C++,
awk, Tcl, Java, or Python, just to mention a few. POSIX paths
are more portable, too.

=head2 Why doesn't glob("*.*") get all the files?
X<glob>

Because even on non-Unix ports, Perl's glob function follows standard
Unix globbing semantics. You'll need C<glob("*")> to get all (non-hidden)
files. This makes glob() portable even to legacy systems. Your
port may include proprietary globbing functions as well. Check its
documentation for details.

=head2 Why does Perl let me delete read-only files?  Why does C<-i> clobber protected files?  Isn't this a bug in Perl?

This is elaborately and painstakingly described in the
F<file-dir-perms> article in the "Far More Than You Ever Wanted To
Know" collection in http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz .

The executive summary: learn how your filesystem works. The
permissions on a file say what can happen to the data in that file.
The permissions on a directory say what can happen to the list of
files in that directory. If you delete a file, you're removing its
name from the directory (so the operation depends on the permissions
of the directory, not of the file). If you try to write to the file,
the permissions of the file govern whether you're allowed to.

=head2 How do I select a random line from a file?
X<file, selecting a random line>

Short of loading the file into a database or pre-indexing the lines in
the file, there are a couple of things that you can do.

Here's a reservoir-sampling algorithm from the Camel Book:

	srand;
	rand($.) < 1 && ($line = $_) while <>;

This has a significant advantage in space over reading the whole file
in. You can find a proof of this method in I<The Art of Computer
Programming>, Volume 2, Section 3.4.2, by Donald E. Knuth.

You can use the C<File::Random> module which provides a function
for that algorithm:

	use File::Random qw/random_line/;
	my $line = random_line($filename);

Another way is to use the C<Tie::File> module, which treats the entire
file as an array. Simply access a random array element.

=head2 Why do I get weird spaces when I print an array of lines?

(contributed by brian d foy)

If you are seeing spaces between the elements of your array when
you print the array, you are probably interpolating the array in
double quotes:

	my @@animals = qw(camel llama alpaca vicuna);
	print "animals are: @@animals\n";

It's the double quotes, not the C<print>, doing this. Whenever you
interpolate an array in a double quote context, Perl joins the
elements with spaces (or whatever is in C<$">, which is a space by
default):

	animals are: camel llama alpaca vicuna

This is different than printing the array without the interpolation:

	my @@animals = qw(camel llama alpaca vicuna);
	print "animals are: ", @@animals, "\n";

Now the output doesn't have the spaces between the elements because
the elements of C<@@animals> simply become part of the list to
C<print>:

	animals are: camelllamaalpacavicuna

You might notice this when each of the elements of C<@@array> end with
a newline. You expect to print one element per line, but notice that
every line after the first is indented:

	this is a line
	 this is another line
	 this is the third line

That extra space comes from the interpolation of the array. If you
don't want to put anything between your array elements, don't use the
array in double quotes. You can send it to print without them:

	print @@lines;

=head2 How do I traverse a directory tree?

(contributed by brian d foy)

The C<File::Find> module, which comes with Perl, does all of the hard
work to traverse a directory structure. It comes with Perl. You simply
call the C<find> subroutine with a callback subroutine and the
directories you want to traverse:

	use File::Find;

	find( \&wanted, @@directories );

	sub wanted {
		# full path in $File::Find::name
		# just filename in $_
		... do whatever you want to do ...
		}

The C<File::Find::Closures>, which you can download from CPAN, provides
many ready-to-use subroutines that you can use with C<File::Find>.

The C<File::Finder>, which you can download from CPAN, can help you
create the callback subroutine using something closer to the syntax of
the C<find> command-line utility:

	use File::Find;
	use File::Finder;

	my $deep_dirs = File::Finder->depth->type('d')->ls->exec('rmdir','{}');

	find( $deep_dirs->as_options, @@places );

The C<File::Find::Rule> module, which you can download from CPAN, has
a similar interface, but does the traversal for you too:

	use File::Find::Rule;

	my @@files = File::Find::Rule->file()
							 ->name( '*.pm' )
							 ->in( @@INC );

=head2 How do I delete a directory tree?

(contributed by brian d foy)

If you have an empty directory, you can use Perl's built-in C<rmdir>.
If the directory is not empty (so, no files or subdirectories), you
either have to empty it yourself (a lot of work) or use a module to
help you.

The C<File::Path> module, which comes with Perl, has a C<remove_tree>
which can take care of all of the hard work for you:

	use File::Path qw(remove_tree);

	remove_tree( @@directories );

The C<File::Path> module also has a legacy interface to the older
C<rmtree> subroutine.

=head2 How do I copy an entire directory?

(contributed by Shlomi Fish)

To do the equivalent of C<cp -R> (i.e. copy an entire directory tree
recursively) in portable Perl, you'll either need to write something yourself
or find a good CPAN module such as  L<File::Copy::Recursive>.

=head1 AUTHOR AND COPYRIGHT

Copyright (c) 1997-2010 Tom Christiansen, Nathan Torkington, and
other authors as noted. All rights reserved.

This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.

Irrespective of its distribution, all code examples here are in the public
domain. You are permitted and encouraged to use this code and any
derivatives thereof in your own programs for fun or for profit as you
see fit. A simple comment in the code giving credit to the FAQ would
be courteous but is not required.
@


1.12
log
@merge in perl 5.12.2 plus local changes
@
text
@@


1.11
log
@Merge in perl 5.10.1
@
text
@d199 1
a199 1
rather than processing line by line, you can slurp it in (as long as
d264 41
a304 9
One fairly efficient way is to count newlines in the file. The
following program uses a feature of tr///, as documented in L<perlop>.
If your text file doesn't end with a newline, then it's not really a
proper text file, so this may report one fewer line than you expect.

	$lines = 0;
	open(FILE, $filename) or die "Can't open `$filename': $!";
	while (sysread FILE, $buffer, 4096) {
		$lines += ($buffer =~ tr/\n//);
d308 59
a366 1
This assumes no funny games with newline translations.
d372 1
a372 1
the behavior of C<< <> >>; see L<perlrun> for more details.  By
d374 1
a374 1
behavior within a larger program.  For example:
d416 1
a416 1
with C<undef> in place of the file name.  In Perl 5.8 or later, the
d425 1
a425 1
	$dir = tempdir( CLEANUP => 1 );
d430 1
a430 1
	$fh = tempfile( DIR => $dir );
d432 1
a432 1
The File::Temp has been a standard module since Perl 5.6.1.  If you
d435 1
a435 1
reading and writing.  Use it if you don't need to know the file's name:
d438 2
a439 2
	$fh = IO::File->new_tmpfile()
	or die "Unable to make new temporary file: $!";
d442 1
a442 1
process ID and/or the current time-value.  If you need to have many
d456 1
a456 1
			sysopen FH, $base_name, O_WRONLY|O_EXCL|O_CREAT;
d459 2
a460 2
		if( defined fileno(FH) ) {
			return (*FH, $base_name);
d473 2
a474 2
L<unpack()|perlfunc/"unpack">.  This is faster than using
L<substr()|perlfunc/"substr"> when taking many, many strings.  It is
d546 1
a546 1
in a place that a filehandle is expected.  Here are ways
d560 1
a560 1
	$fh = IO::Handle->new();
d562 1
a562 1
Then use any of those as you would a normal filehandle.  Anywhere that
d565 1
a565 1
a filehandle.  Functions like C<print>, C<open>, C<seek>, or
d571 1
a571 1
	$got = <$ifh>
d597 1
a597 1
before using it.  That is because only simple scalar variables, not
d599 1
a599 1
built-ins like C<print>, C<printf>, or the diamond operator.  Using
d603 1
a603 1
	@@fd = (*STDIN, *STDOUT, *STDERR);
d605 1
a605 1
	$got = <$fd[0]>                                     # WRONG
d616 1
a616 1
complicated code there.  This sends the message out to one of two places:
d618 1
a618 1
	$ok = -x "/bin/cat";
d623 2
a624 2
calls doesn't work for the diamond operator.  That's because it's a
real operator, not just a function with a comma-less argument.  Assuming
d627 2
a628 2
as C<< <> >> does.  Given the initialization shown above for @@fd, this
would work, but only because readline() requires a typeglob.  It doesn't
d635 1
a635 1
It's the syntax of the fundamental operators.  Playing the object
d709 1
a709 1
installed that groks tildes.  Later versions of Perl have this feature
d733 1
a733 1
	open(FH, "+> /path/name");		# WRONG (almost always)
d735 1
a735 1
Whoops.  You should instead use this, which will fail if the file
d738 1
a738 1
	open(FH, "+< /path/name");  	# open for update
d740 2
a741 2
Using ">" always clobbers or creates.  Using "<" never does
either.  The "+" doesn't change this.
d743 1
a743 1
Here are examples of many kinds of file opens.  Those using sysopen()
d750 2
a751 2
	open(FH, "< $path")                                 || die $!;
	sysopen(FH, $path, O_RDONLY)                        || die $!;
d755 3
a757 3
	open(FH, "> $path") || die $!;
	sysopen(FH, $path, O_WRONLY|O_TRUNC|O_CREAT)        || die $!;
	sysopen(FH, $path, O_WRONLY|O_TRUNC|O_CREAT, 0666)  || die $!;
d761 2
a762 2
	sysopen(FH, $path, O_WRONLY|O_EXCL|O_CREAT)         || die $!;
	sysopen(FH, $path, O_WRONLY|O_EXCL|O_CREAT, 0666)   || die $!;
d766 3
a768 3
	open(FH, ">> $path") || die $!;
	sysopen(FH, $path, O_WRONLY|O_APPEND|O_CREAT)       || die $!;
	sysopen(FH, $path, O_WRONLY|O_APPEND|O_CREAT, 0666) || die $!;
d772 1
a772 1
	sysopen(FH, $path, O_WRONLY|O_APPEND)               || die $!;
d776 2
a777 2
	open(FH, "+< $path")                                || die $!;
	sysopen(FH, $path, O_RDWR)                          || die $!;
d781 2
a782 2
	sysopen(FH, $path, O_RDWR|O_CREAT)                  || die $!;
	sysopen(FH, $path, O_RDWR|O_CREAT, 0666)            || die $!;
d786 2
a787 2
	sysopen(FH, $path, O_RDWR|O_EXCL|O_CREAT)           || die $!;
	sysopen(FH, $path, O_RDWR|O_EXCL|O_CREAT, 0666)     || die $!;
d791 1
a791 1
	sysopen(FH, "/foo/somefile", O_WRONLY|O_NDELAY|O_CREAT)
d795 2
a796 2
be an atomic operation over NFS.  That is, two processes might both
successfully create or unlink the same file!  Therefore O_EXCL
d799 1
a799 1
See also the new L<perlopentut> if you have it (new for 5.6).
d808 1
a808 1
C<Argument list too long>.  People who installed tcsh as csh won't
d818 5
a822 4
Due to the current implementation on some operating systems, when you
use the glob() function or its angle-bracket alias in a scalar
context, you may cause a memory leak and/or unpredictable behavior.  It's
best therefore to use glob() only in list context.
d838 2
a839 2
	open FILE, "<", "  file  ";  # filename is "   file   "
	open FILE, ">", ">file";     # filename is ">file"
d842 1
a842 1
X<rename> X<mv> X<move> X<file, rename> X<ren>
d849 1
a849 1
It may be more portable to use the File::Copy module instead.
d851 2
a852 2
values), then delete the old one.  This isn't really the same
semantically as a rename(), which preserves meta-information like
a854 2
Newer versions of File::Copy export a move() function.

d880 1
a880 1
But even this is dubious at best.  See the flock entry of L<perlfunc>
d886 3
a888 3
I<merely advisory>.  Such discretionary locks are more flexible, but
offer fewer guarantees.  This means that files locked with flock() may
be modified by programs that do not also use flock().  Cars that stop
d890 2
a891 2
stop for red lights.  See the perlport manpage, your port's specific
documentation, or your system-specific local manpages for details.  It's
d908 2
a909 2
	sleep(3) while -e "file.lock";	# PLEASE DO NOT USE
	open(LCK, "> file.lock");		# THIS BROKEN CODE
d912 2
a913 2
which must be done in one.  That's why computer hardware provides an
atomic test-and-set instruction.   In theory, this "ought" to work:
d915 1
a915 1
	sysopen(FH, "file.lock", O_WRONLY|O_EXCL|O_CREAT)
d923 1
a923 1
=head2 I still don't get locking.  I just want to increment the number in the file.  How can I do this?
d928 1
a928 1
only to stroke the writer's vanity.  It's better to pick a random number;
d934 7
a940 7
	sysopen(FH, "numfile", O_RDWR|O_CREAT) 	 or die "can't open numfile: $!";
	flock(FH, LOCK_EX) 				 or die "can't flock numfile: $!";
	$num = <FH> || 0;
	seek(FH, 0, 0) 				 or die "can't rewind numfile: $!";
	truncate(FH, 0) 				 or die "can't truncate numfile: $!";
	(print FH $num+1, "\n")			 or die "can't write numfile: $!";
	close FH 					 or die "can't close numfile: $!";
d946 1
a946 1
If the count doesn't impress your friends, then the code might.  :-)
d948 1
a948 1
=head2 All I want to do is append a small amount of text to the end of a file.  Do I still have to use locking?
d992 3
a994 3
	open(FH, "+<somewhere") || die "can't update somewhere: $!";
	seek(FH, $recno * $RECSIZE, 0);
	read(FH, $record, $RECSIZE) == $RECSIZE || die "can't read record $recno: $!";
d996 3
a998 3
	seek(FH, -$RECSIZE, 1);
	print FH $record;
	close FH;
d1006 9
a1014 11
If you want to retrieve the time at which the file was last
read, written, or had its meta-data (owner, etc) changed,
you use the B<-A>, B<-M>, or B<-C> file test operations as
documented in L<perlfunc>.  These retrieve the age of the
file (measured against the start-time of your program) in
days as a floating point number. Some platforms may not have
all of these times.  See L<perlport> for details. To
retrieve the "raw" time in seconds since the epoch, you
would call the stat function, then use localtime(),
gmtime(), or POSIX::strftime() to convert this into
human-readable form.
d1018 1
a1018 1
	$write_secs = (stat($file))[9];
d1028 1
a1028 1
	$date_string = ctime(stat($file)->mtime);
d1032 1
a1032 1
in theory, independent of the current locale.  See L<perllocale>
d1046 2
a1047 2
	$timestamp = shift;
	($atime, $mtime) = (stat($timestamp))[8,9];
d1056 1
a1056 1
on a file at the expected level of precision.  For example, the
d1058 1
a1058 1
a finer granularity than two seconds.  This is a limitation of
d1070 1
a1070 1
	for $fh (FH1, FH2, FH3) { print $fh "whatever\n" }
d1075 14
a1088 1
You can use the File::Slurp module to do it in one step.
d1092 2
a1093 2
	$all_of_it = read_file($filename); # entire file in scalar
	@@all_lines = read_file($filename); # one line per element
d1098 2
a1099 2
	open (INPUT, $file) 	|| die "can't open $file: $!";
	while (<INPUT>) {
d1103 1
a1103 1
	close(INPUT)	    	|| die "can't close $file: $!";
d1107 1
a1107 1
which is often--if not almost always--the wrong approach.  Whenever
d1110 1
a1110 1
	@@lines = <INPUT>;
d1112 2
a1113 2
you should think long and hard about why you need everything loaded at
once.  It's just not a scalable solution.  You might also find it more
d1122 3
a1124 3
	local(*INPUT, $/);
	open (INPUT, $file) 	|| die "can't open $file: $!";
	$var = <INPUT>;
d1128 1
a1128 1
close the file at block exit.  If the file is already open, just use this:
d1130 1
a1130 1
	$var = do { local $/; <INPUT> };
d1134 1
a1134 1
	read( INPUT, $var, -s INPUT );
d1142 1
a1142 1
Use the C<$/> variable (see L<perlvar> for details).  You can either
d1147 1
a1147 1
Note that a blank line must have no blanks in it.  Thus
d1154 1
a1154 1
it won't (easily) work on a terminal device.  For STDIN, either use
a1165 1
		my $got;
d1167 1
a1167 1
		$got = getone();
d1177 1
a1177 1
	$fd_stdin = fileno(STDIN);
d1210 1
a1210 1
The Term::ReadKey module from CPAN may be easier to use.  Recent versions
d1214 1
a1214 1
	open(TTY, "</dev/tty");
d1217 1
a1217 1
	$key = ReadKey 0, *TTY;
d1225 1
a1225 1
extension from CPAN.  As we mentioned earlier, it now even has limited
d1227 1
a1227 1
not POSIX, not Unix, etc) systems.
d1231 1
a1231 1
It's very system dependent.  Here's one solution that works on BSD
d1241 1
a1241 1
also the FIONREAD ioctl call to be looked at.  The I<h2ph> tool that
d1243 1
a1243 1
can be C<require>d.  FIONREAD ends up defined as a function in the
d1313 1
a1313 1
to call open() should do the trick.  For example:
d1315 2
a1316 2
	open(LOG, ">>/foo/logfile");
	open(STDERR, ">&LOG");
d1320 2
a1321 2
   $fd = $ENV{MHCONTEXTFD};
   open(MHCONTEXT, "<&=$fd");	# like fdopen(3S)
d1324 2
a1325 2
an alias.  That means if you close an aliased handle, all
aliases become inaccessible.  This is not true with
d1343 1
a1343 1
numeric descriptor as with C<MHCONTEXT> above.  But if you really have
d1347 1
a1347 1
	$rc = syscall(&SYS_close, $fd + 0);  # must force numeric
d1362 2
a1363 2
backslash is an escape character.  The full list of these is in
L<perlop/Quote and Quote-like Operators>.  Unsurprisingly, you don't
d1371 1
a1371 1
awk, Tcl, Java, or Python, just to mention a few.  POSIX paths
d1378 3
a1380 3
Unix globbing semantics.  You'll need C<glob("*")> to get all (non-hidden)
files.  This makes glob() portable even to legacy systems.  Your
port may include proprietary globbing functions as well.  Check its
d1389 1
a1389 1
The executive summary: learn how your filesystem works.  The
d1392 1
a1392 1
files in that directory.  If you delete a file, you're removing its
d1394 1
a1394 1
of the directory, not of the file).  If you try to write to the file,
d1409 1
a1409 1
in.  You can find a proof of this method in I<The Art of Computer
d1419 1
a1419 1
file as an array.  Simply access a random array element.
d1510 4
a1513 3
If you have an empty directory, you can use Perl's built-in C<rmdir>. If
the directory is not empty (so, no files or subdirectories), you either
have to empty it yourself (a lot of work) or use a module to help you.
d1515 2
a1516 2
The C<File::Path> module, which comes with Perl, has a C<rmtree> which
can take care of all of the hard work for you:
d1518 1
a1518 1
	use File::Path qw(rmtree);
d1520 1
a1520 1
	rmtree( \@@directories, 0, 0 );
d1522 2
a1523 4
The first argument to C<rmtree> is either a string representing a directory path
or an array reference. The second argument controls progress messages, and the
third argument controls the handling of files you don't have permissions to
delete. See the C<File::Path> module for the details.
a1531 7
=head1 REVISION

Revision: $Revision$

Date: $Date$

See L<perlfaq> for source control details and availability.
d1535 1
a1535 1
Copyright (c) 1997-2009 Tom Christiansen, Nathan Torkington, and
d1542 1
a1542 1
domain.  You are permitted and encouraged to use this code and any
d1544 1
a1544 1
see fit.  A simple comment in the code giving credit to the FAQ would
@


1.10
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d13 4
a16 20
Perl does not support truly unbuffered output (except insofar as you
can C<syswrite(OUT, $char, 1)>), although it does support is "command
buffering", in which a physical write is performed after every output
command.

The C standard I/O library (stdio) normally buffers characters sent to
devices so that there isn't a system call for each byte. In most stdio
implementations, the type of output buffering and the size of the
buffer varies according to the type of device. Perl's C<print()> and
C<write()> functions normally buffer output, while C<syswrite()>
bypasses buffering all together.

If you want your output to be sent immediately when you execute
C<print()> or C<write()> (for instance, for some network protocols),
you must set the handle's autoflush flag. This flag is the Perl
variable C<$|> and when it is set to a true value, Perl will flush the
handle's buffer after each C<print()> or C<write()>. Setting C<$|>
affects buffering only for the currently selected default filehandle.
You choose this handle with the one argument C<select()> call (see
L<perlvar/$E<verbar>> and L<perlfunc/select>).
d18 28
a45 2
Use C<select()> to choose the desired handle, then set its
per-filehandle variables.
d47 4
a50 3
	$old_fh = select(OUTPUT_HANDLE);
	$| = 1;
	select($old_fh);
d52 7
a58 3
Some modules offer object-oriented access to handles and their
variables, although they may be overkill if this is the only thing you
do with them.  You can use C<IO::Handle>:
d60 8
a67 3
	use IO::Handle;
	open my( $printer ), ">", "/dev/printer");   # but is this?
	$printer->autoflush(1);
d69 2
a70 1
or C<IO::Socket> (which inherits from C<IO::Handle>):
d72 1
a72 2
	use IO::Socket;		  # this one is kinda a pipe?
	my $sock = IO::Socket::INET->new( 'www.example.com:80' );
d74 5
a78 1
	$sock->autoflush();
d80 6
a85 2
You can also flush an C<IO::Handle> object without setting
C<autoflush>. Call the C<flush> method to flush the buffer yourself:
d88 7
a94 2
	open my( $printer ), ">", "/dev/printer"); 
	$printer->flush; # one time flush
a95 1
	
d130 1
a130 1
	print "# Add this line to the top\n"; # <--- HERE'S THE MAGIC
d147 1
a147 1
	print "# Add this line to the top\n";
d176 1
a176 1
		
d305 1
a305 1
X<copy> X<file, copy>
d309 1
a309 1
Use the File::Copy module. It comes with Perl and can do a
d317 1
a317 1
If you can't use File::Copy, you'll have to do the work yourself:
d319 2
a320 1
to the destination file as you read the original.
d326 2
a327 2
with C<undef> in place of the file name.  The C<open()> function
creates an anonymous temporary file.
d376 1
a376 1
		
d560 1
a560 1
X<string>, X<open>, X<IO::Scalar>, X<filehandle>
d564 3
a566 3
Since Perl 5.8.0, you can pass a reference to a scalar instead of the
filename to create a file handle which you can used to read from or write to
a string:
d577 1
a577 1
    
d617 5
a621 5
Use the <> (glob()) operator, documented in L<perlfunc>.  Older
versions of Perl require that you have a shell installed that groks
tildes.  Recent perl versions have this feature built in. The
File::KGlob module (available from CPAN) gives more portable glob
functionality.
d862 6
a867 6
If you are on a system that correctly implements flock() and you use the
example appending code from "perldoc -f flock" everything will be OK
even if the OS you are on doesn't implement append mode correctly (if
such a system exists.) So if you are happy to restrict yourself to OSs
that implement flock() (and that's not really much of a restriction)
then that is what you should do.
d870 2
a871 2
implement appending (i.e. not Win32) then you can omit the seek() from
the code in the previous answer.
d873 9
a881 8
If you know you are only writing code to run on an OS and filesystem that
does implement append mode correctly (a local filesystem on a modern
Unix for example), and you keep the file in block-buffered mode and you
write less than one buffer-full of output between each manual flushing
of the buffer then each bufferload is almost guaranteed to be written to
the end of the file in one chunk without getting intermingled with
anyone else's output. You can also use the syswrite() function which is
simply a wrapper around your systems write(2) system call.
d884 5
a888 4
the system level write() operation before completion.  There is also a
possibility that some STDIO implementations may call multiple system
level write()s even if the buffer was empty to start.  There may be some
systems where this probability is reduced to zero.
d993 1
a993 1
	@@all_lines = read_file($filename); # one line perl element
d1239 1
a1239 1
	
d1241 1
a1241 1
	
d1301 4
a1304 1
Here's an algorithm from the Camel Book:
d1313 1
a1313 1
You can use the File::Random module which provides a function
d1319 1
a1319 1
Another way is to use the Tie::File module, which treats the entire
d1324 8
a1331 1
Saying
d1333 4
a1336 1
	print "@@lines\n";
d1338 1
a1338 3
joins together the elements of C<@@lines> with a space between them.
If C<@@lines> were C<("little", "fluffy", "clouds")> then the above
statement would print
d1340 1
a1340 1
	little fluffy clouds
d1342 2
a1343 2
but if each element of C<@@lines> was a line of text, ending a newline
character C<("little\n", "fluffy\n", "clouds\n")> then it would print:
d1345 3
a1347 3
	little
	 fluffy
	 clouds
d1349 13
a1361 1
If your array contains lines, just print them:
d1365 69
d1436 1
a1436 1
Revision: $Revision: 10126 $
d1438 1
a1438 1
Date: $Date: 2007-10-27 21:29:20 +0200 (Sat, 27 Oct 2007) $
d1444 1
a1444 1
Copyright (c) 1997-2007 Tom Christiansen, Nathan Torkington, and
@


1.9
log
@merge in perl 5.8.8
@
text
@d13 19
a31 21
Perl does not support truly unbuffered output (except
insofar as you can C<syswrite(OUT, $char, 1)>), although it
does support is "command buffering", in which a physical
write is performed after every output command.

The C standard I/O library (stdio) normally buffers
characters sent to devices so that there isn't a system call
for each byte. In most stdio implementations, the type of
output buffering and the size of the buffer varies according
to the type of device. Perl's print() and write() functions
normally buffer output, while syswrite() bypasses buffering
all together.

If you want your output to be sent immediately when you
execute print() or write() (for instance, for some network
protocols), you must set the handle's autoflush flag. This
flag is the Perl variable $| and when it is set to a true
value, Perl will flush the handle's buffer after each
print() or write(). Setting $| affects buffering only for
the currently selected default file handle. You choose this
handle with the one argument select() call (see
d34 1
a34 1
Use select() to choose the desired handle, then set its
d37 3
a39 3
    $old_fh = select(OUTPUT_HANDLE);
    $| = 1;
    select($old_fh);
d41 133
a173 1
Some idioms can handle this in a single statement:
d175 1
a175 1
    select((select(OUTPUT_HANDLE), $| = 1)[0]);
d177 1
a177 1
    $| = 1, select $_ for select OUTPUT_HANDLE;
d179 34
a212 3
Some modules offer object-oriented access to handles and their
variables, although they may be overkill if this is the only
thing you do with them.  You can use IO::Handle:
d214 4
a217 3
    use IO::Handle;
    open(DEV, ">/dev/printer");   # but is this?
    DEV->autoflush(1);
d219 1
a219 1
or IO::Socket:
d221 1
a221 2
    use IO::Socket;		  # this one is kinda a pipe?
	my $sock = IO::Socket::INET->new( 'www.example.com:80' );
d223 1
a223 1
    $sock->autoflush();
d225 1
a225 2
=head2 How do I change one line in a file/delete a line in a file/insert a line in the middle of a file/append to the beginning of a file?
X<file, editing>
d227 1
a227 2
Use the Tie::File module, which is included in the standard
distribution since Perl 5.8.0.
d237 6
a242 6
    $lines = 0;
    open(FILE, $filename) or die "Can't open `$filename': $!";
    while (sysread FILE, $buffer, 4096) {
	$lines += ($buffer =~ tr/\n//);
    }
    close FILE;
d254 13
a266 13
     # ...
     {
        local($^I, @@ARGV) = ('.orig', glob("*.c"));
        while (<>) {
           if ($. == 1) {
               print "This line should appear at the top of each file\n";
           }
           s/\b(p)earl\b/${1}erl/i;        # Correct typos, preserving case
           print;
           close ARGV if eof;              # Reset $.
        }
     }
     # $^I and @@ARGV return to their old values here
d300 1
a300 1
  use File::Temp qw/ tempfile tempdir /;
d302 2
a303 2
  $dir = tempdir( CLEANUP => 1 );
  ($fh, $filename) = tempfile( DIR => $dir );
d305 1
a305 1
  # or if you don't need to know the filename
d307 1
a307 1
  $fh = tempfile( DIR => $dir );
d314 2
a315 2
    use IO::File;
    $fh = IO::File->new_tmpfile()
d322 1
a322 1
    BEGIN {
d325 2
a326 1
	my $base_name = sprintf("%s/%d-%d-0000", $temp_dir, $$, time());
d328 16
a343 12
	    local *FH;
	    my $count = 0;
	    until (defined(fileno(FH)) || $count++ > 100) {
		$base_name =~ s/-(\d+)$/"-" . (1 + $1)/e;
		# O_EXCL is required for security reasons.
		sysopen(FH, $base_name, O_WRONLY|O_EXCL|O_CREAT);
	    }
	    if (defined(fileno(FH))
		return (*FH, $base_name);
	    } else {
		return ();
	    }
a344 1
    }
d358 9
a366 9
    # sample input line:
    #   15158 p5  T      0:00 perl /home/tchrist/scripts/now-what
    my $PS_T = 'A6 A4 A7 A5 A*';
    open my $ps, '-|', 'ps';
    print scalar <$ps>;
    my @@fields = qw( pid tt stat time command );
    while (<$ps>) {
        my %process;
        @@process{@@fields} = unpack($PS_T, $_);
d368 1
a368 1
	    print "$field: <$process{$field}>\n";
d371 1
a371 1
    }
d394 12
d426 5
a430 5
    $fh =   SOME_FH;       # bareword is strict-subs hostile
    $fh =  "SOME_FH";      # strict-refs hostile; same package only
    $fh =  *SOME_FH;       # typeglob
    $fh = \*SOME_FH;       # ref to typeglob (bless-able)
    $fh =  *SOME_FH{IO};   # blessed IO::Handle from *SOME_FH typeglob
d436 2
a437 2
    use IO::Handle;                     # 5.004 or higher
    $fh = IO::Handle->new();
d446 4
a449 4
    ($ifh, $ofh, $efh) = (*STDIN, *STDOUT, *STDERR);
    print $ofh "Type it: ";
    $got = <$ifh>
    print $efh "What was that: $got";
d454 4
a457 4
    sub accept_fh {
        my $fh = shift;
        print $fh "Sending to indirect filehandle\n";
    }
d461 4
a464 4
    sub accept_fh {
        local *FH = shift;
        print  FH "Sending to localized filehandle\n";
    }
d470 2
a471 2
    accept_fh(*STDOUT);
    accept_fh($handle);
d480 4
a483 4
    @@fd = (*STDIN, *STDOUT, *STDERR);
    print $fd[1] "Type it: ";                           # WRONG
    $got = <$fd[0]>                                     # WRONG
    print $fd[2] "What was that: $got";                 # WRONG
d488 3
a490 3
    print  { $fd[1] } "funny stuff\n";
    printf { $fd[1] } "Pity the poor %x.\n", 3_735_928_559;
    # Pity the poor deadbeef.
d495 3
a497 3
    $ok = -x "/bin/cat";
    print { $ok ? $fd[1] : $fd[2] } "cat stat $ok\n";
    print { $fd[ 1+ ($ok || 0) ]  } "cat stat $ok\n";
d508 1
a508 1
    $got = readline($fd[0]);
d524 1
a524 1
See L<perlform/"Accessing Formatting Internals"> for an swrite() function.
d526 19
d558 4
a561 4
	   local $_  = shift;
	   1 while s/^([-+]?\d+)(\d{3})/$1,$2/;
	   return $_;
	   }
d565 1
a565 1
   s/(^[-+]?\d+?(?=(?>(?:\d{3})+)(?!\d))|\G\d{3}(?=\d))/$1,/g;
d569 11
a579 11
   s/(
       ^[-+]?            # beginning of number.
       \d+?              # first digits before first comma
       (?=               # followed by, (but not included in the match) :
          (?>(?:\d{3})+) # some positive multiple of three digits.
          (?!\d)         # an *exact* multiple, not x * 3 + 1 or whatever.
       )
      |                  # or:
       \G\d{3}           # after the last group, get three digits
       (?=\d)            # but they have to have more digits after them.
   )/$1,/xg;
d610 1
a610 1
    open(FH, "+> /path/name");		# WRONG (almost always)
d615 1
a615 1
    open(FH, "+< /path/name");  	# open for update
d623 1
a623 1
    use Fcntl;
d627 2
a628 2
    open(FH, "< $path")                                 || die $!;
    sysopen(FH, $path, O_RDONLY)                        || die $!;
d632 3
a634 3
    open(FH, "> $path") || die $!;
    sysopen(FH, $path, O_WRONLY|O_TRUNC|O_CREAT)        || die $!;
    sysopen(FH, $path, O_WRONLY|O_TRUNC|O_CREAT, 0666)  || die $!;
d638 2
a639 2
    sysopen(FH, $path, O_WRONLY|O_EXCL|O_CREAT)         || die $!;
    sysopen(FH, $path, O_WRONLY|O_EXCL|O_CREAT, 0666)   || die $!;
d643 3
a645 3
    open(FH, ">> $path") || die $!;
    sysopen(FH, $path, O_WRONLY|O_APPEND|O_CREAT)       || die $!;
    sysopen(FH, $path, O_WRONLY|O_APPEND|O_CREAT, 0666) || die $!;
d649 1
a649 1
    sysopen(FH, $path, O_WRONLY|O_APPEND)               || die $!;
d653 2
a654 2
    open(FH, "+< $path")                                || die $!;
    sysopen(FH, $path, O_RDWR)                          || die $!;
d658 2
a659 2
    sysopen(FH, $path, O_RDWR|O_CREAT)                  || die $!;
    sysopen(FH, $path, O_RDWR|O_CREAT, 0666)            || die $!;
d663 2
a664 2
    sysopen(FH, $path, O_RDWR|O_EXCL|O_CREAT)           || die $!;
    sysopen(FH, $path, O_RDWR|O_EXCL|O_CREAT, 0666)     || die $!;
d668 1
a668 1
    sysopen(FH, "/foo/somefile", O_WRONLY|O_NDELAY|O_CREAT)
d712 1
a712 1
charcters in the filename as special.
d723 1
a723 1
    rename($old, $new) or system("mv", $old, $new);
d786 2
a787 2
    sleep(3) while -e "file.lock";	# PLEASE DO NOT USE
    open(LCK, "> file.lock");		# THIS BROKEN CODE
d793 1
a793 1
    sysopen(FH, "file.lock", O_WRONLY|O_EXCL|O_CREAT)
d799 1
a799 1
these tend to involve busy-wait, which is also subdesirable.
d811 8
a818 8
    use Fcntl qw(:DEFAULT :flock);
    sysopen(FH, "numfile", O_RDWR|O_CREAT) 	 or die "can't open numfile: $!";
    flock(FH, LOCK_EX) 				 or die "can't flock numfile: $!";
    $num = <FH> || 0;
    seek(FH, 0, 0) 				 or die "can't rewind numfile: $!";
    truncate(FH, 0) 				 or die "can't truncate numfile: $!";
    (print FH $num+1, "\n")			 or die "can't write numfile: $!";
    close FH 					 or die "can't close numfile: $!";
d822 1
a822 1
    $hits = int( (time() - 850_000_000) / rand(1_000) );
d838 1
a838 1
the above code.
d861 1
a861 1
    perl -i -pe 's{window manager}{window mangler}g' /usr/bin/emacs
d866 9
a874 9
    $RECSIZE = 220; # size of record, in bytes
    $recno   = 37;  # which record to update
    open(FH, "+<somewhere") || die "can't update somewhere: $!";
    seek(FH, $recno * $RECSIZE, 0);
    read(FH, $record, $RECSIZE) == $RECSIZE || die "can't read record $recno: $!";
    # munge the record
    seek(FH, -$RECSIZE, 1);
    print FH $record;
    close FH;
d896 2
a897 2
    $write_secs = (stat($file))[9];
    printf "file %s updated at %s\n", $file,
d903 5
a907 5
    # error checking left as an exercise for reader.
    use File::stat;
    use Time::localtime;
    $date_string = ctime(stat($file)->mtime);
    print "file $file updated at $date_string\n";
d921 6
a926 6
    if (@@ARGV < 2) {
	die "usage: cptimes timestamp_file other_files ...\n";
    }
    $timestamp = shift;
    ($atime, $mtime) = (stat($timestamp))[8,9];
    utime $atime, $mtime, @@ARGV;
d948 1
a948 1
    for $fh (FH1, FH2, FH3) { print $fh "whatever\n" }
d958 1
a958 1
    @@all_lines = read_file($filename); # one line perl element
d963 6
a968 6
    open (INPUT, $file) 	|| die "can't open $file: $!";
    while (<INPUT>) {
	chomp;
	# do something with $_
    }
    close(INPUT)	    	|| die "can't close $file: $!";
d975 1
a975 1
    @@lines = <INPUT>;
d986 1
a986 1
    {
d990 1
a990 1
    }
d995 1
a995 1
    $var = do { local $/; <INPUT> };
d1027 9
a1035 9
    #!/usr/bin/perl -w
    use strict;
    $| = 1;
    for (1..4) {
	my $got;
	print "gimme: ";
	$got = getone();
	print "--> $got\n";
    }
d1038 1
a1038 1
    BEGIN {
d1053 4
a1056 4
	    $term->setlflag($noecho);
	    $term->setcc(VTIME, 1);
	    $term->setattr($fd_stdin, TCSANOW);
	}
d1059 4
a1062 4
	    $term->setlflag($oterm);
	    $term->setcc(VTIME, 0);
	    $term->setattr($fd_stdin, TCSANOW);
	}
d1065 7
a1071 5
	    my $key = '';
	    cbreak();
	    sysread(STDIN, $key, 1);
	    cooked();
	    return $key;
d1074 1
a1074 3
    }

    END { cooked() }
d1079 8
a1086 8
    use Term::ReadKey;
    open(TTY, "</dev/tty");
    print "Gimme a char: ";
    ReadMode "raw";
    $key = ReadKey 0, *TTY;
    ReadMode "normal";
    printf "\nYou said %s, char number %03d\n",
        $key, ord $key;
d1100 5
a1104 5
    sub key_ready {
	my($rin, $nfd);
	vec($rin, fileno(STDIN), 1) = 1;
	return $nfd = select($rin,undef,undef,0);
    }
d1112 1
a1112 1
    require 'sys/ioctl.ph';
d1114 3
a1116 3
    $size = pack("L", 0);
    ioctl(FH, FIONREAD(), $size)    or die "Couldn't call ioctl: $!\n";
    $size = unpack("L", $size);
d1121 2
a1122 2
    % grep FIONREAD /usr/include/*/*
    /usr/include/asm/ioctls.h:#define FIONREAD      0x541B
d1126 9
a1134 9
    % cat > fionread.c
    #include <sys/ioctl.h>
    main() {
        printf("%#08x\n", FIONREAD);
    }
    ^D
    % cc -o fionread fionread.c
    % ./fionread
    0x4004667f
d1138 1
a1138 1
    $FIONREAD = 0x4004667f;         # XXX: opsys dependent
d1140 3
a1142 3
    $size = pack("L", 0);
    ioctl(FH, $FIONREAD, $size)     or die "Couldn't call ioctl: $!\n";
    $size = unpack("L", $size);
d1148 1
a1148 1
X<tail>
d1152 1
a1152 1
    seek(GWFILE, 0, 1);
d1156 1
a1156 1
next <GWFILE> makes Perl try again to read something.
d1169 3
a1171 4
If this still doesn't work, look into the POSIX module.  POSIX defines
the clearerr() method, which can remove the end of file condition on a
filehandle.  The method: read until end of file, clearerr(), read some
more.  Lather, rinse, repeat.
d1173 1
a1173 1
There's also a File::Tail module from CPAN.
d1181 2
a1182 2
    open(LOG, ">>/foo/logfile");
    open(STDERR, ">&LOG");
d1197 1
a1197 1
X<file, closing file descriptors>
d1199 9
a1207 1
This should rarely be necessary, as the Perl close() function is to be
d1209 1
a1209 1
numeric descriptor as with MHCONTEXT above.  But if you really have
d1212 10
a1221 11
    require 'sys/syscall.ph';
    $rc = syscall(&SYS_close, $fd + 0);  # must force numeric
    die "can't sysclose $fd: $!" unless $rc == -1;

Or, just use the fdopen(3S) feature of open():

    {
	local *F;
	open F, "<&=$fd" or die "Cannot reopen fd=$fd: $!";
	close F;
    }
d1268 2
a1269 2
    srand;
    rand($.) < 1 && ($line = $_) while <>;
d1288 1
a1288 1
    print "@@lines\n";
d1294 1
a1294 1
    little fluffy clouds
d1299 3
a1301 3
    little
     fluffy
     clouds
d1305 9
a1313 1
    print @@lines;
d1317 1
a1317 1
Copyright (c) 1997-2006 Tom Christiansen, Nathan Torkington, and
@


1.8
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d3 1
a3 1
perlfaq5 - Files and Formats ($Revision: 1.7 $, $Date: 2004/04/07 21:33:08 $)
d11 1
d60 1
a60 1
	my $sock = IO::Socket::INET->new( 'www.example.com:80' ) ;
d65 1
d71 1
d88 1
d113 17
d131 7
d139 1
a139 1
Use the File::Temp module, see L<File::Temp> for more information.
d184 1
d216 1
d245 1
d341 1
d347 1
d352 8
d377 1
a377 1
       \d{1,3}?          # first digits before first comma
d388 1
d411 1
d485 1
d499 1
d507 1
d509 10
a518 8
Normally perl ignores trailing blanks in filenames, and interprets
certain leading characters (or a trailing "|") to mean something
special.

The three argument form of open() lets you specify the mode
separately from the filename.  The open() function treats
special mode characters and whitespace in the filename as
literals
a522 7
It may be a lot clearer to use sysopen(), though:

    use Fcntl;
    $badpath = "<<<something really wicked   ";
    sysopen (FH, $badpath, O_WRONLY | O_CREAT | O_TRUNC)
	or die "can't open $badpath: $!";

d524 1
d540 1
d588 1
d608 1
d633 1
d662 1
d686 1
d690 1
a690 1
you use the B<-M>, B<-A>, or B<-C> file test operations as
d720 1
d736 8
a743 3
Note that utime() currently doesn't work correctly with Win95/NT
ports.  A bug has been reported.  Check it carefully before using
utime() on those platforms.
d746 1
d757 1
d811 1
d822 1
d954 1
d983 1
d1004 1
d1024 1
d1041 1
d1064 1
d1109 2
a1110 2
Copyright (c) 1997-2002 Tom Christiansen and Nathan Torkington.
All rights reserved.
@


1.7
log
@merge local changes into perl-5.8.3
@
text
@d3 1
a3 1
perlfaq5 - Files and Formats ($Revision: 1.6 $, $Date: 2003/12/03 03:02:44 $)
d144 1
d431 2
a432 2
    sysopen(FH, "/tmp/somefile", O_WRONLY|O_NDELAY|O_CREAT)
	    or die "can't open /tmp/somefile: $!":
d928 1
a928 1
    open(LOG, ">>/tmp/logfile");
@


1.6
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d3 1
a3 1
perlfaq5 - Files and Formats ($Revision: 1.28 $, $Date: 2003/01/26 17:45:46 $)
d156 4
a159 2
The most efficient way is using pack() and unpack().  This is faster than
using substr() when taking many, many strings.  It is slower for just a few.
d167 9
a175 7
    $PS_T = 'A6 A4 A7 A5 A*';
    open(PS, "ps|");
    print scalar <PS>;
    while (<PS>) {
	($pid, $tt, $stat, $time, $command) = unpack($PS_T, $_);
	for $var (qw!pid tt stat time command!) {
	    print "$var: <$$var>\n";
d177 1
a177 2
	print 'line=', pack($PS_T, $pid, $tt, $stat, $time, $command),
		"\n";
d180 4
a183 4
We've used C<$$var> in a way that forbidden by C<use strict 'refs'>.
That is, we've promoted a string to a scalar variable reference using
symbolic references.  This is okay in small programs, but doesn't scale
well.   It also only works on global variables, not lexicals.
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 1
a3 1
perlfaq5 - Files and Formats ($Revision: 1.18 $, $Date: 2002/05/30 07:04:25 $)
d33 1
a33 1
L<perlvar/$|> and L<perlfunc/select>).
d84 25
d113 1
a113 1
  use File::Temp qw/ tempfile tempdir /; 
d167 1
a167 1
    print scalar <PS>; 
d285 1
a285 1
    $ok = -x "/bin/cat";                
d287 1
a287 1
    print { $fd[ 1+ ($ok || 0) ]  } "cat stat $ok\n";           
d316 9
a324 1
This one from Benjamin Goldberg will do it for you:
d328 1
a328 1
or written verbosely:
d372 1
a372 1
doesn't exist.  
d437 1
a437 1
=head2 Why do I sometimes get an "Argument list too long" when I use <*>?
d461 1
a461 1
special. 
d465 1
a465 1
special mode characters and whitespace in the filename as 
d480 2
a481 2
If your operating system supports a proper mv(1) utility or its functional
equivalent, this works:
d535 1
a535 1
For more information on file locking, see also 
d540 1
a540 1
=head2 Why can't I just open(FH, ">file.lock")?
d552 1
a552 1
		or die "can't open  file.lock: $!":
d689 5
a693 1
If you only have to do this once, you can do this:
d697 3
a699 18
To connect up to one filehandle to several output filehandles, it's
easiest to use the tee(1) program if you have it, and let it take care
of the multiplexing:

    open (FH, "| tee file1 file2 file3");

Or even:

    # make STDOUT go to three files, plus original STDOUT
    open (STDOUT, "| tee file1 file2 file3") or die "Teeing off: $!\n";
    print "whatever\n"                       or die "Writing: $!\n";
    close(STDOUT)                            or die "Closing: $!\n";

Otherwise you'll have to write your own multiplexing print
function--or your own tee program--or use Tom Christiansen's,
at http://www.cpan.org/authors/id/TOMC/scripts/tct.gz , which is
written in Perl and offers much greater functionality
than the stock version.
d701 4
a704 1
=head2 How can I read in an entire file all at once?
d713 1
a713 1
    } 
d738 1
a738 1
That temporarily undefs your record separator, and will automatically 
d757 1
a757 1
Note that a blank line must have no blanks in it.  Thus 
d934 1
a934 1
aliases become inaccessible.  This is not true with 
d952 2
a953 2
    { 
	local *F; 
d986 1
a986 1
Know" collection in http://www.cpan.org/olddoc/FMTEYEWTK.tgz .
d1003 12
a1014 3
This has a significant advantage in space over reading the whole
file in.  A simple proof by induction is available upon 
request if you doubt the algorithm's correctness.
@


1.4
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 1
a3 1
perlfaq5 - Files and Formats ($Revision: 1.38 $, $Date: 1999/05/23 16:08:30 $)
d12 25
a36 23
The C standard I/O library (stdio) normally buffers characters sent to
devices.  This is done for efficiency reasons so that there isn't a
system call for each byte.  Any time you use print() or write() in
Perl, you go though this buffering.  syswrite() circumvents stdio and
buffering.

In most stdio implementations, the type of output buffering and the size of
the buffer varies according to the type of device.  Disk files are block
buffered, often with a buffer size of more than 2k.  Pipes and sockets
are often buffered with a buffer size between 1/2 and 2k.  Serial devices
(e.g. modems, terminals) are normally line-buffered, and stdio sends
the entire line when it gets the newline.

Perl does not support truly unbuffered output (except insofar as you can
C<syswrite(OUT, $char, 1)>).  What it does instead support is "command
buffering", in which a physical write is performed after every output
command.  This isn't as hard on your system as unbuffering, but does
get the output where you want it when you want it.

If you expect characters to get to your device when you print them there,
you'll want to autoflush its handle.
Use select() and the C<$|> variable to control autoflushing
(see L<perlvar/$|> and L<perlfunc/select>):
d42 1
a42 1
Or using the traditional idiom:
d46 1
a46 6
Or if don't mind slowly loading several thousand lines of module code
just because you're afraid of the C<$|> variable:

    use FileHandle;
    open(DEV, "+</dev/tty"); 	  # ceci n'est pas une pipe
    DEV->autoflush(1);
d48 3
a50 1
or the newer IO::* modules:
d56 1
a56 1
or even this:
d59 1
a59 4
    $sock = IO::Socket::INET->new(PeerAddr => 'www.perl.com',
				  PeerPort => 'http(80)',
				  Proto    => 'tcp');
    die "$!" unless $sock;
a61 12
    print $sock "GET / HTTP/1.0" . "\015\012" x 2;
    $document = join('', <$sock>);
    print "DOC IS: $document\n";

Note the bizarrely hardcoded carriage return and newline in their octal
equivalents.  This is the ONLY way (currently) to assure a proper flush
on all platforms, including Macintosh.  That's the way things work in
network programming: you really should specify the exact bit pattern
on the network line terminator.  In practice, C<"\n\n"> often works,
but this is not portable.

See L<perlfaq9> for other examples of fetching URLs over the web.
d65 2
a66 77
Those are operations of a text editor.  Perl is not a text editor.
Perl is a programming language.  You have to decompose the problem into
low-level calls to read, write, open, close, and seek.

Although humans have an easy time thinking of a text file as being a
sequence of lines that operates much like a stack of playing cards--or
punch cards--computers usually see the text file as a sequence of bytes.
In general, there's no direct way for Perl to seek to a particular line
of a file, insert text into a file, or remove text from a file.

(There are exceptions in special circumstances.  You can add or remove
data at the very end of the file.  A sequence of bytes can be replaced
with another sequence of the same length.  The C<$DB_RECNO> array
bindings as documented in L<DB_File> also provide a direct way of
modifying a file.  Files where all lines are the same length are also
easy to alter.)

The general solution is to create a temporary copy of the text file with
the changes you want, then copy that over the original.  This assumes
no locking.

    $old = $file;
    $new = "$file.tmp.$$";
    $bak = "$file.orig";

    open(OLD, "< $old") 	or die "can't open $old: $!";
    open(NEW, "> $new") 	or die "can't open $new: $!";

    # Correct typos, preserving case
    while (<OLD>) {
	s/\b(p)earl\b/${1}erl/i;
	(print NEW $_)		or die "can't write to $new: $!";
    }

    close(OLD)			or die "can't close $old: $!";
    close(NEW) 			or die "can't close $new: $!";

    rename($old, $bak)		or die "can't rename $old to $bak: $!";
    rename($new, $old)		or die "can't rename $new to $old: $!";

Perl can do this sort of thing for you automatically with the C<-i>
command-line switch or the closely-related C<$^I> variable (see
L<perlrun> for more details).  Note that
C<-i> may require a suffix on some non-Unix systems; see the
platform-specific documentation that came with your port.

    # Renumber a series of tests from the command line
    perl -pi -e 's/(^\s+test\s+)\d+/ $1 . ++$count /e' t/op/taint.t

    # form a script
    local($^I, @@ARGV) = ('.orig', glob("*.c"));
    while (<>) {
	if ($. == 1) {
	    print "This line should appear at the top of each file\n";
	}
	s/\b(p)earl\b/${1}erl/i;        # Correct typos, preserving case
	print;
	close ARGV if eof;              # Reset $.
    }

If you need to seek to an arbitrary line of a file that changes
infrequently, you could build up an index of byte positions of where
the line ends are in the file.  If the file is large, an index of
every tenth or hundredth line end would allow you to seek and read
fairly efficiently.  If the file is sorted, try the look.pl library
(part of the standard perl distribution).

In the unique case of deleting lines at the end of a file, you
can use tell() and truncate().  The following code snippet deletes
the last line of a file without making a copy or reading the
whole file into memory:

	open (FH, "+< $file");
        while ( <FH> ) { $addr = tell(FH) unless eof(FH) }
        truncate(FH, $addr);

Error checking is left as an exercise for the reader.
d86 1
a86 3
Use the C<new_tmpfile> class method from the IO::File module to get a
filehandle opened for reading and writing.  Use it if you don't
need to know the file's name:
d88 1
a88 3
    use IO::File;
    $fh = IO::File->new_tmpfile()
	or die "Unable to make new temporary file: $!";
d90 2
a91 3
If you do need to know the file's name, you can use the C<tmpnam>
function from the POSIX module to get a filename that you then open
yourself:
d93 1
d95 1
a95 2
    use Fcntl;
    use POSIX qw(tmpnam);
d97 4
a100 8
    # try new temporary filenames until we get one that didn't already
    # exist;  the check should be unnecessary, but you can't be too careful
    do { $name = tmpnam() }
        until sysopen(FH, $name, O_RDWR|O_CREAT|O_EXCL);

    # install atexit-style handler so that when we exit or die,
    # we automatically delete this temporary file
    END { unlink($name) or die "Couldn't unlink $name : $!" }
d102 3
a104 1
    # now go on to use the file ...
d112 1
a112 1
	my $temp_dir = -d '/tmp' ? '/tmp' : $ENV{TMP} || $ENV{TEMP};
d154 1
a154 1
symbolic references.  This is ok in small programs, but doesn't scale
d159 4
a162 2
The fastest, simplest, and most direct way is to localize the typeglob
of the filehandle in question:
d164 1
a164 1
    local *TmpHandle;
d166 1
a166 14
Typeglobs are fast (especially compared with the alternatives) and
reasonably easy to use, but they also have one subtle drawback.  If you
had, for example, a function named TmpHandle(), or a variable named
%TmpHandle, you just hid it from yourself.

    sub findme {
        local *HostFile;
	open(HostFile, "</etc/hosts") or die "no /etc/hosts: $!";
	local $_;		# <- VERY IMPORTANT
        while (<HostFile>) {
	    print if /\b127\.(0\.0\.)?1\b/;
	}
	# *HostFile automatically closes/disappears here
    }
d168 1
a168 11
Here's how to use typeglobs in a loop to open and store a bunch of
filehandles.  We'll use as values of the hash an ordered
pair to make it easy to sort the hash in insertion order.

    @@names = qw(motd termcap passwd hosts);
    my $i = 0;
    foreach $filename (@@names) {
	local *FH;
	open(FH, "/etc/$filename") || die "$filename: $!";
        $file{$filename} = [ $i++, *FH ];
    }
d170 1
a170 6
    # Using the filehandles in the array
    foreach $name (sort { $file{$a}[0] <=> $file{$b}[0] } keys %file) {
        my $fh = $file{$name}[1];
        my $line = <$fh>;
        print "$name $. $line";
    }
d172 2
a173 14
For passing filehandles to functions, the easiest way is to 
preface them with a star, as in func(*STDIN).  
See L<perlfaq7/"Passing Filehandles"> for details.

If you want to create many anonymous handles, you should check out the
Symbol, FileHandle, or IO::Handle (etc.) modules.  Here's the equivalent
code with Symbol::gensym, which is reasonably light-weight:

    foreach $filename (@@names) {
	use Symbol;
	my $fh = gensym();
	open($fh, "/etc/$filename") || die "open /etc/$filename: $!";
        $file{$filename} = [ $i++, $fh ];
    }
d175 3
a177 2
Here's using the semi-object-oriented FileHandle module, which certainly
isn't light-weight:
d179 2
a180 1
    use FileHandle;
d182 2
a183 9
    foreach $filename (@@names) {
        my $fh = FileHandle->new("/etc/$filename") or die "$filename: $!";
        $file{$filename} = [ $i++, $fh ];
    }

Please understand that whether the filehandle happens to be a (probably
localized) typeglob or an anonymous handle from one of the modules
in no way affects the bizarre rules for managing indirect handles.
See the next question.
d197 1
a197 1
Or, you can use the C<new> method from the FileHandle or IO modules to
a200 3
    use FileHandle;
    $fh = FileHandle->new();

d208 1
a208 1
the C<< <FH> >> diamond operator will accept either a read filehandle
d242 1
a242 1
something other than a simple scalar varaible as a filehandle is
d268 1
a268 1
can use the built-in function named C<readline> to reads a record just
d270 1
a270 1
would work, but only because readline() require a typeglob.  It doesn't
d291 1
a291 10
This one will do it for you:

    sub commify {
	local $_  = shift;
	1 while s/^([-+]?\d+)(\d{3})/$1,$2/;
	return $_;
    }

    $n = 23659019423.2331;
    print "GOT: ", commify($n), "\n";
d293 1
a293 1
    GOT: 23,659,019,423.2331
d295 1
a295 1
You can't just:
d297 11
a307 16
    s/^([-+]?\d+)(\d{3})/$1,$2/g;

because you have to put the comma in and then recalculate your
position.

Alternatively, this code commifies all numbers in a line regardless of
whether they have decimal portions, are preceded by + or -, or
whatever:

    # from Andrew Johnson <ajohnson@@gpu.srv.ualberta.ca>
    sub commify {
       my $input = shift;
        $input = reverse $input;
        $input =~ s<(\d\d\d)(?=\d)(?!\d*\.)><$1,>g;
        return scalar reverse $input;
    }
d314 1
a314 1
Glob::KGlob module (available from CPAN) gives more portable glob
d414 1
a414 1
yourself with readdir() and patterns, or use a module like Glob::KGlob,
d428 1
a428 10
special.  To avoid this, you might want to use a routine like the one below.
It turns incomplete pathnames into explicit relative ones, and tacks a
trailing null byte on the name to make perl leave it alone:

    sub safe_filename {
	local $_  = shift;
        s#^([^./])#./$1#;
        $_ .= "\0";
	return $_;
    }
d430 4
a433 3
    $badpath = "<<<something really wicked   ";
    $fn = safe_filename($badpath");
    open(FH, "> $fn") or "couldn't open $badpath: $!";
d435 2
a436 3
This assumes that you are using POSIX (portable operating systems
interface) paths.  If you are on a closed, non-portable, proprietary
system, you may have to adjust the C<"./"> above.
d438 1
a438 1
It would be a lot clearer to use sysopen(), though:
a444 3
For more information, see also the new L<perlopentut> if you have it
(new for 5.6).

d447 1
a447 7
Well, usually you just use Perl's rename() function.  That may not
work everywhere, though, particularly when renaming files across file systems.
Some sub-Unix systems have broken ports that corrupt the semantics of
rename()--for example, WinNT does this right, but Win95 and Win98
are broken.  (The last two parts are not surprising, but the first is. :-)

If your operating system supports a proper mv(1) program or its moral
d452 4
a455 4
It may be more compelling to use the File::Copy module instead.  You
just copy to the new file to the new name (checking return values),
then delete the old one.  This isn't really the same semantically as a
real rename(), though, which preserves metainformation like
d458 1
a458 1
Newer versions of File::Copy exports a move() function.
d550 28
d603 11
a613 8
If you want to retrieve the time at which the file was last read,
written, or had its meta-data (owner, etc) changed, you use the B<-M>,
B<-A>, or B<-C> filetest operations as documented in L<perlfunc>.  These
retrieve the age of the file (measured against the start-time of your
program) in days as a floating point number.  To retrieve the "raw"
time in seconds since the epoch, you would call the stat function,
then use localtime(), gmtime(), or POSIX::strftime() to convert this
into human-readable form.
d675 1
a675 1
at http://www.perl.com/CPAN/authors/id/TOMC/scripts/tct.gz , which is
d698 8
a705 21
you should think long and hard about why you need everything loaded
at once.  It's just not a scalable solution.  You might also find it
more fun to use the standard DB_File module's $DB_RECNO bindings,
which allow you to tie an array to a file so that accessing an element
the array actually accesses the corresponding line in the file.

On very rare occasion, you may have an algorithm that demands that
the entire file be in memory at once as one scalar.  The simplest solution
to that is

    $var = `cat $file`;

Being in scalar context, you get the whole thing.  In list context,
you'd get a list of all the lines:

    @@lines = `cat $file`;

This tiny but expedient solution is neat, clean, and portable to
all systems on which decent tools have been installed.  For those
who prefer not to use the toolbox, you can of course read the file
manually, although this makes for more complicated code.
d718 7
d732 2
a733 2
Note that a blank line must have no blanks in it.  Thus C<"fred\n
\nstuff\n\n"> is one paragraph, but C<"fred\n\nstuff\n\n"> is two.
a806 46
For legacy DOS systems, Dan Carson <dbc@@tc.fluke.COM> reports the following:

To put the PC in "raw" mode, use ioctl with some magic numbers gleaned
from msdos.c (Perl source file) and Ralf Brown's interrupt list (comes
across the net every so often):

    $old_ioctl = ioctl(STDIN,0,0);     # Gets device info
    $old_ioctl &= 0xff;
    ioctl(STDIN,1,$old_ioctl | 32);    # Writes it back, setting bit 5

Then to read a single character:

    sysread(STDIN,$c,1);               # Read a single character

And to put the PC back to "cooked" mode:

    ioctl(STDIN,1,$old_ioctl);         # Sets it back to cooked mode.

So now you have $c.  If C<ord($c) == 0>, you have a two byte code, which
means you hit a special key.  Read another byte with C<sysread(STDIN,$c,1)>,
and that value tells you what combination it was according to this
table:

    # PC 2-byte keycodes = ^@@ + the following:

    # HEX     KEYS
    # ---     ----
    # 0F      SHF TAB
    # 10-19   ALT QWERTYUIOP
    # 1E-26   ALT ASDFGHJKL
    # 2C-32   ALT ZXCVBNM
    # 3B-44   F1-F10
    # 47-49   HOME,UP,PgUp
    # 4B      LEFT
    # 4D      RIGHT
    # 4F-53   END,DOWN,PgDn,Ins,Del
    # 54-5D   SHF F1-F10
    # 5E-67   CTR F1-F10
    # 68-71   ALT F1-F10
    # 73-77   CTR LEFT,RIGHT,END,PgDn,HOME
    # 78-83   ALT 1234567890-=
    # 84      CTR PgUp

This is all trial and error I did a long time ago; I hope I'm reading the
file that worked...

d855 1
a855 1
And then hard-code it, leaving porting as an exercise to your successor.
d933 1
a933 1
=head2 Why can't I use "C:\temp\foo" in DOS paths?  What doesn't `C:\temp\foo.exe` work?
d959 3
a961 3
This is elaborately and painstakingly described in the "Far More Than
You Ever Wanted To Know" in
http://www.perl.com/CPAN/doc/FMTEYEWTK/file-dir-perms .
d1007 1
a1007 1
Copyright (c) 1997-1999 Tom Christiansen and Nathan Torkington.
d1010 2
a1011 4
When included as an integrated part of the Standard Distribution
of Perl or of its documentation (printed or otherwise), this works is
covered under Perl's Artistic License.  For separate distributions of
all or part of this FAQ outside of that, see L<perlfaq>.
@


1.3
log
@perl-5.6.0 + local changes
@
text
@d13 1
a13 1
devices.  This is done for efficiency reasons, so that there isn't a
d86 2
a87 2
sequence of lines that operates much like a stack of playing cards -- or
punch cards -- computers usually see the text file as a sequence of bytes.
d91 6
a96 5
(There are exceptions in special circumstances.  You can add or remove at
the very end of the file.  Another is replacing a sequence of bytes with
another sequence of the same length.  Another is using the C<$DB_RECNO>
array bindings as documented in L<DB_File>.  Yet another is manipulating
files with all lines the same length.)
d178 2
a179 2
filehandle opened for reading and writing.  Use this if you don't
need to know the file's name.
d185 4
a188 3
Or you can use the C<tmpnam> function from the POSIX module to get a
filename that you then open yourself.  Use this if you do need to know
the file's name.
d204 3
a206 3
If you're committed to doing this by hand, use the process ID and/or
the current time-value.  If you need to have many temporary files in
one process, use a counter:
d277 1
a277 1
Here's how to use this in a loop to open and store a bunch of
d297 2
a298 2
preface them with a star, as in func(*STDIN).  See L<perlfaq7/"Passing
Filehandles"> for details.
d311 1
a311 1
Or here using the semi-object-oriented FileHandle module, which certainly
d322 1
a322 1
localized) typeglob or an anonymous handle from one of the modules,
d330 1
a330 1
to get those:
d338 1
a338 1
Or to use the C<new> method from the FileHandle or IO modules to
d383 4
a386 3
before using it.  That is because only simple scalar variables,
not expressions or subscripts into hashes or arrays, can be used with
built-ins like C<print>, C<printf>, or the diamond operator.  These are
d455 1
a455 1
Alternatively, this commifies all numbers in a line regardless of
d469 5
a473 5
Use the <> (glob()) operator, documented in L<perlfunc>.  This
requires that you have a shell installed that groks tildes, meaning
csh or tcsh or (some versions of) ksh, and thus may have portability
problems.  The Glob::KGlob module (available from CPAN) gives more
portable glob functionality.
d557 2
a558 2
successful create or unlink the same file!  Therefore O_EXCL
isn't so exclusive as you might wish.
d579 1
a579 1
context, you may cause a leak and/or unpredictable behavior.  It's
d586 2
a587 2
special.  To avoid this, you might want to use a routine like this.
It makes incomplete pathnames into explicit relative ones, and tacks a
d609 1
a609 1
    open (FH, $badpath, O_WRONLY | O_CREAT | O_TRUNC)
d617 2
a618 2
Well, usually you just use Perl's rename() function.  But that may not
work everywhere, in particular, renaming files across file systems.
d620 1
a620 1
rename() -- for example, WinNT does this right, but Win95 and Win98
d630 1
a630 1
then delete the old one.  This isn't really the same semantics as a
d634 1
a634 1
The newer version of File::Copy exports a move() function.
d660 1
a660 1
But even this is dubious at best.  See the flock entry of L<perlfunc>,
d665 1
a665 1
it waits indefinitely until the lock is granted, and that its locks
d673 1
a673 1
(But if you're not, you should as always feel perfectly free to write
d678 2
a679 2
For more information on file locking, see also L<perlopentut/"File
Locking"> if you have it (new for 5.6).
d706 2
a707 2
only to stroke the writer's vanity.  Better to pick a random number.
It's more realistic.
d711 1
a711 1
    use Fcntl ':flock';
a717 2
    # Perl as of 5.004 automatically flushes before unlocking
    flock(FH, LOCK_UN) 				 or die "can't flock numfile: $!";
d747 1
a747 1
Don't forget them, or you'll be quite sorry.
d797 1
a797 1
it on those platforms.
d819 2
a820 2
function -- or your own tee program -- or use Tom Christiansen's,
at http://www.perl.com/CPAN/authors/id/TOMC/scripts/tct.gz, which is
d838 1
a838 1
which is often -- if not almost always -- the wrong approach.  Whenever
d843 1
a843 1
You should think long and hard about why you need everything loaded
d845 1
a845 1
more fun to use the the standard DB_File module's $DB_RECNO bindings,
d851 1
a851 1
to that is:
d890 1
a890 1
the Term::ReadKey module from CPAN, or use the sample code in
d946 1
a946 1
The Term::ReadKey module from CPAN may be easier to use.  Recent version
d1001 2
a1002 2
This is all trial and error I did a long time ago, I hope I'm reading the
file that worked.
d1060 1
a1060 1
FIONREAD requires a filehandle connected to a stream, meaning sockets,
d1115 1
a1115 1
numeric descriptor, as with MHCONTEXT above.  But if you really have
d1122 1
a1122 1
Or just use the fdopen(3S) feature of open():
d1142 1
a1142 1
one that doesn't clash with Perl -- or the POSIX shell, ANSI C and C++,
d1177 1
a1177 1
request if you doubt its correctness.
d1187 1
a1187 1
statement would print:
@


1.2
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
perlfaq5 - Files and Formats ($Revision: 1.34 $, $Date: 1999/01/08 05:46:13 $)
d72 1
a72 1
on all platforms, including Macintosh.  That the way things work in
d350 1
a350 1
the C<E<lt>FHE<gt>> diamond operator will accept either a read filehandle
d410 1
a410 1
as C<E<lt>E<gt>> does.  Given the initialization shown above for @@fd, this
d466 1
a466 1
Use the E<lt>E<gt> (glob()) operator, documented in L<perlfunc>.  This
d494 6
a499 2
doesn't exist.  Using "E<gt>" always clobbers or creates. 
Using "E<lt>" never does either.  The "+" doesn't change this.
d557 1
a557 1
See also the new L<perlopentut> if you have it (new for 5.006).
d559 1
a559 1
=head2 Why do I sometimes get an "Argument list too long" when I use E<lt>*E<gt>?
d561 3
a563 2
The C<E<lt>E<gt>> operator performs a globbing operation (see above).
By default glob() forks csh(1) to do the actual glob expansion, but
d568 3
a570 3
To get around this, either do the glob yourself with readdir() and
patterns, or use a module like Glob::KGlob, one that doesn't use the
shell to do globbing.  This is expected to be fixed soon.
d579 1
a579 1
=head2 How can I open a file with a leading "E<gt>" or trailing blanks?
d610 1
a610 1
(new for 5.006).
d614 8
a621 4
Well, usually you just use Perl's rename() function.  But that may
not work everywhere, in particular, renaming files across file systems.
If your operating system supports a mv(1) program or its moral equivalent,
this works:
d655 19
a673 5
Some versions of flock() can't lock files over a network (e.g. on NFS
file systems), so you'd need to force the use of fcntl(2) when you
build Perl.  See the flock entry of L<perlfunc>, and the F<INSTALL>
file in the source distribution for information on building Perl to do
this.
d676 1
a676 1
Locking"> if you have it (new for 5.006).
d823 52
d1103 1
a1103 1
Note that "E<lt>&STDIN" makes a copy, but "E<lt>&=STDIN" make
d1121 8
d1207 2
a1208 2
of Perl or of its documentation (printed or otherwise), this work is
covered under Perl's Artistic Licence.  For separate distributions of
d1211 1
a1211 1
Irrespective of its distribution, all code examples here are public
a1215 1

@


1.1
log
@perl 5.004_04
@
text
@d3 1
a3 1
perlfaq5 - Files and Formats ($Revision: 1.22 $, $Date: 1997/04/24 22:44:02 $)
d10 1
a10 1
=head2 How do I flush/unbuffer a filehandle?  Why must I do this?
d18 1
a18 1
In most stdio implementations, the type of buffering and the size of
d32 14
a45 1
you'll want to autoflush its handle, as in the older:
d48 1
a48 1
    open(DEV, "<+/dev/tty"); 	  # ceci n'est pas une pipe
d66 2
a67 2
    $sock->print("GET /\015\012");
    $document = join('', $sock->getlines());
d70 6
a75 3
Note the hardcoded carriage return and newline in their octal
equivalents.  This is the ONLY way (currently) to assure a proper
flush on all platforms, including Macintosh.
d77 1
a77 2
You can use select() and the C<$|> variable to control autoflushing
(see L<perlvar/$|> and L<perlfunc/select>):
d79 1
a79 3
    $oldh = select(DEV);
    $| = 1;
    select($oldh);
d81 3
a83 5
You'll also see code that does this without a temporary variable, as in

    select((select(DEV), $| = 1)[0]);

=head2 How do I change one line in a file/delete a line in a file/insert a line in the middle of a file/append to the beginning of a file?
d86 10
a95 10
sequence of lines that operates much like a stack of playing cards --
or punch cards -- computers usually see the text file as a sequence of
bytes.  In general, there's no direct way for Perl to seek to a
particular line of a file, insert text into a file, or remove text
from a file.

(There are exceptions in special circumstances.  Replacing a sequence
of bytes with another sequence of the same length is one.  Another is
using the C<$DB_RECNO> array bindings as documented in L<DB_File>.
Yet another is manipulating files with all lines the same length.)
d98 2
a99 1
the changes you want, then copy that over the original.
d103 1
a103 1
    $bak = "$file.bak";
d130 1
a130 1
    local($^I, @@ARGV) = ('.bak', glob("*.c"));
d172 2
d176 29
a204 2
Use the process ID and/or the current time-value.  If you need to have
many temporary files in one process, use a counter:
a206 1
	use IO::File;
d211 1
a211 1
	    my $fh = undef;
d213 1
a213 1
	    until (defined($fh) || $count > 100) {
d215 1
a215 1
		$fh = IO::File->new($base_name, O_WRONLY|O_EXCL|O_CREAT, 0644)
d217 2
a218 2
	    if (defined($fh)) {
		return ($fh, $base_name);
d225 1
a225 1
Or you could simply use IO::Handle::new_tmpfile.
d227 2
a228 1
=head2 How can I manipulate fixed-record-length files?
d230 3
a232 4
The most efficient way is using pack() and unpack().  This is faster
than using substr().  Here is a sample chunk of code to break up and
put back together again some fixed-format input lines, in this case
from the output of a normal, Berkeley-style ps:
d238 1
a238 1
    $_ = <PS>; print;
d248 5
d255 2
a256 2
You may have some success with typeglobs, as we always had to use
in days of old:
d258 1
a258 1
    local(*FH);
d260 4
a263 4
But while still supported, that isn't the best to go about getting
local filehandles.  Typeglobs have their drawbacks.  You may well want
to use the C<FileHandle> module, which creates new filehandles for you
(see L<FileHandle>):
a264 1
    use FileHandle;
d266 4
a269 3
        my $fh = FileHandle->new();
	open($fh, "</etc/hosts") or die "no /etc/hosts: $!";
        while (<$fh>) {
d272 1
a272 1
	# $fh automatically closes/disappears here
d275 3
a277 3
Internally, Perl believes filehandles to be of class IO::Handle.  You
may use that module directly if you'd like (see L<IO::Handle>), or
one of its more specific derived classes.
d279 32
a310 3
Once you have IO::File or FileHandle objects, you can pass them
between subroutines or store them in hashes as you would any other
scalar values:
a313 1
    # Storing filehandles in a hash and array
d315 2
a316 3
        my $fh = new FileHandle($filename)		or die;
        $file{$filename} = $fh;
        push(@@files, $fh);
d319 45
a363 3
    # Using the filehandles in the array
    foreach $file (@@files) {
	print $file "Testing\n";
d366 1
a366 3
    # You have to do the { } ugliness when you're specifying the
    # filehandle by anything other than a simple scalar variable.
    print { $files[2] } "Testing\n";
d368 3
a370 4
    # Passing filehandles to subroutines
    sub debug {
	my $filehandle = shift;
	printf $filehandle "DEBUG: ", @@_;
d373 47
a419 1
    debug($fh, "Testing\n");
d428 1
a428 1
See L<perlform> for an swrite() function.
d436 1
a436 1
	1 while s/^(-?\d+)(\d{3})/$1,$2/;
d447 1
a447 1
    s/^(-?\d+)(\d{3})/$1,$2/g;
d461 1
a461 1
        return reverse $input;
d486 1
a486 1
=head2 How come when I open the file read-write it wipes it out?
d491 1
a491 1
    open(FH, "+> /path/name");	# WRONG
d494 31
a524 1
doesn't exist.
d526 1
a526 1
    open(FH, "+< /path/name");	# open for update
d528 1
a528 1
If this is an issue, try:
d530 2
a531 1
    sysopen(FH, "/path/name", O_RDWR|O_CREAT, 0644);
d533 21
a553 1
Error checking is left as an exercise for the reader.
d555 1
a555 1
=head2 Why do I sometimes get an "Argument list too long" when I use <*>?
d563 1
a563 1
To get around this, either do the glob yourself with C<Dirhandle>s and
d565 1
a565 1
shell to do globbing.
d584 3
a586 3
	return m#^/#
		? "$_\0"
		: "./$_\0";
d589 7
a595 2
    $fn = safe_filename("<<<something really wicked   ");
    open(FH, "> $fn") or "couldn't open $fn: $!";
d597 9
a605 1
You could also use the sysopen() function (see L<perlfunc/sysopen>).
d622 2
d652 3
d657 1
a657 5
The CPAN module File::Lock offers similar functionality and (if you
have dynamic loading) won't require you to rebuild perl if your
flock() can't lock network files.

=head2 What can't I just open(FH, ">file.lock")?
d668 1
a668 1
    sysopen(FH, "file.lock", O_WRONLY|O_EXCL|O_CREAT, 0644)
d673 1
a673 1
Various schemes involving involving link() have been suggested, but
d679 9
a687 6

Anyway, this is what to do:

    use Fcntl;
    sysopen(FH, "numfile", O_RDWR|O_CREAT, 0644) or die "can't open numfile: $!";
    flock(FH, 2) 				 or die "can't flock numfile: $!";
d692 2
a693 1
    # DO NOT UNLOCK THIS UNTIL YOU CLOSE
d718 1
a718 1
    seek(FH, $recno * $RECSIZE, 0);
a724 4
Don't forget to set binmode() under DOS-like platforms when operating
on files that have anything other than straight text in them.  See the
docs on open() and on binmode() for more details.

d739 2
a740 1
    print "file $file updated at ", scalar(localtime($file)), "\n";
d745 1
d751 3
a753 1
Error checking is left as an exercise for the reader.
d769 1
a769 1
Error checking is left as an exercise for the reader.
d787 1
a787 4
Otherwise you'll have to write your own multiplexing print function --
or your own tee program -- or use Tom Christiansen's, at
http://www.perl.com/CPAN/authors/id/TOMC/scripts/tct.gz, which is
written in Perl.
d789 10
a798 2
In theory a IO::Tee class could be written, but to date we haven't
seen such.
d802 1
a802 1
Use the C<$\> variable (see L<perlvar> for details).  You can either
d807 3
d817 3
a819 2
If your system supports POSIX, you can use the following code, which
you'll note turns off echo processing as well.
d870 2
a871 1
The Term::ReadKey module from CPAN may be easier to use:
d882 1
a882 1
For DOS systems, Dan Carson <dbc@@tc.fluke.COM> reports the following:
d928 6
a933 1
=head2 How can I tell if there's a character waiting on a filehandle?
d935 1
a935 1
You should check out the Frequently Asked Questions list in
d946 29
a974 6
You should look into getting the Term::ReadKey extension from CPAN.

=head2 How do I open a file without blocking?

You need to use the O_NDELAY or O_NONBLOCK flag from the Fcntl module
in conjunction with sysopen():
d976 1
a976 5
    use Fcntl;
    sysopen(FH, "/tmp/somefile", O_WRONLY|O_NDELAY|O_CREAT, 0644)
    or die "can't open /tmp/somefile: $!":

=head2 How do I create a file only if it doesn't exist?
d978 1
a978 2
You need to use the O_CREAT and O_EXCL flags from the Fcntl module in
conjunction with sysopen():
d980 3
a982 3
    use Fcntl;
    sysopen(FH, "/tmp/somefile", O_WRONLY|O_EXCL|O_CREAT, 0644)
		or die "can't open /tmp/somefile: $!":
d984 2
a985 3
Be warned that neither creation nor deletion of files is guaranteed to
be an atomic operation over NFS.  That is, two processes might both
successful create or unlink the same file!
d1013 2
d1028 6
a1033 1
Error checking has been left as an exercise for the reader.
d1053 1
a1053 1
"c:(tab)emp(formfeed)oo.exe" on your DOS filesystem.
d1059 2
a1060 1
awk, Tcl, Java, or Python, just to mention a few.
d1066 3
a1068 1
files.
d1073 1
a1073 1
You Every Wanted To Know" in
d1092 25
a1116 1
file in.
d1120 13
a1132 2
Copyright (c) 1997 Tom Christiansen and Nathan Torkington.
All rights reserved.  See L<perlfaq> for distribution information.
@


1.1.1.1
log
@perl5.005_03
@
text
@d3 1
a3 1
perlfaq5 - Files and Formats ($Revision: 1.34 $, $Date: 1999/01/08 05:46:13 $)
d10 1
a10 1
=head2 How do I flush/unbuffer an output filehandle?  Why must I do this?
d18 1
a18 1
In most stdio implementations, the type of output buffering and the size of
d32 1
a32 14
you'll want to autoflush its handle.
Use select() and the C<$|> variable to control autoflushing
(see L<perlvar/$|> and L<perlfunc/select>):

    $old_fh = select(OUTPUT_HANDLE);
    $| = 1;
    select($old_fh);

Or using the traditional idiom:

    select((select(OUTPUT_HANDLE), $| = 1)[0]);

Or if don't mind slowly loading several thousand lines of module code
just because you're afraid of the C<$|> variable:
d35 1
a35 1
    open(DEV, "+</dev/tty"); 	  # ceci n'est pas une pipe
d53 2
a54 2
    print $sock "GET / HTTP/1.0" . "\015\012" x 2;
    $document = join('', <$sock>);
d57 3
a59 6
Note the bizarrely hardcoded carriage return and newline in their octal
equivalents.  This is the ONLY way (currently) to assure a proper flush
on all platforms, including Macintosh.  That the way things work in
network programming: you really should specify the exact bit pattern
on the network line terminator.  In practice, C<"\n\n"> often works,
but this is not portable.
d61 10
a70 1
See L<perlfaq9> for other examples of fetching URLs over the web.
a73 4
Those are operations of a text editor.  Perl is not a text editor.
Perl is a programming language.  You have to decompose the problem into
low-level calls to read, write, open, close, and seek.

d75 10
a84 10
sequence of lines that operates much like a stack of playing cards -- or
punch cards -- computers usually see the text file as a sequence of bytes.
In general, there's no direct way for Perl to seek to a particular line
of a file, insert text into a file, or remove text from a file.

(There are exceptions in special circumstances.  You can add or remove at
the very end of the file.  Another is replacing a sequence of bytes with
another sequence of the same length.  Another is using the C<$DB_RECNO>
array bindings as documented in L<DB_File>.  Yet another is manipulating
files with all lines the same length.)
d87 1
a87 2
the changes you want, then copy that over the original.  This assumes
no locking.
d91 1
a91 1
    $bak = "$file.orig";
d118 1
a118 1
    local($^I, @@ARGV) = ('.orig', glob("*.c"));
a159 2
This assumes no funny games with newline translations.

d162 2
a163 29
Use the C<new_tmpfile> class method from the IO::File module to get a
filehandle opened for reading and writing.  Use this if you don't
need to know the file's name.

    use IO::File;
    $fh = IO::File->new_tmpfile()
	or die "Unable to make new temporary file: $!";

Or you can use the C<tmpnam> function from the POSIX module to get a
filename that you then open yourself.  Use this if you do need to know
the file's name.

    use Fcntl;
    use POSIX qw(tmpnam);

    # try new temporary filenames until we get one that didn't already
    # exist;  the check should be unnecessary, but you can't be too careful
    do { $name = tmpnam() }
        until sysopen(FH, $name, O_RDWR|O_CREAT|O_EXCL);

    # install atexit-style handler so that when we exit or die,
    # we automatically delete this temporary file
    END { unlink($name) or die "Couldn't unlink $name : $!" }

    # now go on to use the file ...

If you're committed to doing this by hand, use the process ID and/or
the current time-value.  If you need to have many temporary files in
one process, use a counter:
d166 1
d171 1
a171 1
	    local *FH;
d173 1
a173 1
	    until (defined(fileno(FH)) || $count++ > 100) {
d175 1
a175 1
		sysopen(FH, $base_name, O_WRONLY|O_EXCL|O_CREAT);
d177 2
a178 2
	    if (defined(fileno(FH))
		return (*FH, $base_name);
d185 2
d189 4
a192 6
The most efficient way is using pack() and unpack().  This is faster than
using substr() when taking many, many strings.  It is slower for just a few.

Here is a sample chunk of code to break up and put back together again
some fixed-format input lines, in this case from the output of a normal,
Berkeley-style ps:
d198 1
a198 1
    print scalar <PS>; 
a207 5
We've used C<$$var> in a way that forbidden by C<use strict 'refs'>.
That is, we've promoted a string to a scalar variable reference using
symbolic references.  This is ok in small programs, but doesn't scale
well.   It also only works on global variables, not lexicals.

d210 2
a211 2
The fastest, simplest, and most direct way is to localize the typeglob
of the filehandle in question:
d213 1
a213 1
    local *TmpHandle;
d215 4
a218 4
Typeglobs are fast (especially compared with the alternatives) and
reasonably easy to use, but they also have one subtle drawback.  If you
had, for example, a function named TmpHandle(), or a variable named
%TmpHandle, you just hid it from yourself.
d220 1
d222 3
a224 4
        local *HostFile;
	open(HostFile, "</etc/hosts") or die "no /etc/hosts: $!";
	local $_;		# <- VERY IMPORTANT
        while (<HostFile>) {
d227 1
a227 1
	# *HostFile automatically closes/disappears here
d230 3
a232 3
Here's how to use this in a loop to open and store a bunch of
filehandles.  We'll use as values of the hash an ordered
pair to make it easy to sort the hash in insertion order.
d234 3
a236 32
    @@names = qw(motd termcap passwd hosts);
    my $i = 0;
    foreach $filename (@@names) {
	local *FH;
	open(FH, "/etc/$filename") || die "$filename: $!";
        $file{$filename} = [ $i++, *FH ];
    }

    # Using the filehandles in the array
    foreach $name (sort { $file{$a}[0] <=> $file{$b}[0] } keys %file) {
        my $fh = $file{$name}[1];
        my $line = <$fh>;
        print "$name $. $line";
    }

For passing filehandles to functions, the easiest way is to 
preface them with a star, as in func(*STDIN).  See L<perlfaq7/"Passing
Filehandles"> for details.

If you want to create many anonymous handles, you should check out the
Symbol, FileHandle, or IO::Handle (etc.) modules.  Here's the equivalent
code with Symbol::gensym, which is reasonably light-weight:

    foreach $filename (@@names) {
	use Symbol;
	my $fh = gensym();
	open($fh, "/etc/$filename") || die "open /etc/$filename: $!";
        $file{$filename} = [ $i++, $fh ];
    }

Or here using the semi-object-oriented FileHandle module, which certainly
isn't light-weight:
d240 1
d242 3
a244 2
        my $fh = FileHandle->new("/etc/$filename") or die "$filename: $!";
        $file{$filename} = [ $i++, $fh ];
d247 3
a249 45
Please understand that whether the filehandle happens to be a (probably
localized) typeglob or an anonymous handle from one of the modules,
in no way affects the bizarre rules for managing indirect handles.
See the next question.

=head2 How can I use a filehandle indirectly?

An indirect filehandle is using something other than a symbol
in a place that a filehandle is expected.  Here are ways
to get those:

    $fh =   SOME_FH;       # bareword is strict-subs hostile
    $fh =  "SOME_FH";      # strict-refs hostile; same package only
    $fh =  *SOME_FH;       # typeglob
    $fh = \*SOME_FH;       # ref to typeglob (bless-able)
    $fh =  *SOME_FH{IO};   # blessed IO::Handle from *SOME_FH typeglob

Or to use the C<new> method from the FileHandle or IO modules to
create an anonymous filehandle, store that in a scalar variable,
and use it as though it were a normal filehandle.

    use FileHandle;
    $fh = FileHandle->new();

    use IO::Handle;                     # 5.004 or higher
    $fh = IO::Handle->new();

Then use any of those as you would a normal filehandle.  Anywhere that
Perl is expecting a filehandle, an indirect filehandle may be used
instead. An indirect filehandle is just a scalar variable that contains
a filehandle.  Functions like C<print>, C<open>, C<seek>, or
the C<E<lt>FHE<gt>> diamond operator will accept either a read filehandle
or a scalar variable containing one:

    ($ifh, $ofh, $efh) = (*STDIN, *STDOUT, *STDERR);
    print $ofh "Type it: ";
    $got = <$ifh>
    print $efh "What was that: $got";

If you're passing a filehandle to a function, you can write
the function in two ways:

    sub accept_fh {
        my $fh = shift;
        print $fh "Sending to indirect filehandle\n";
d252 3
a254 1
Or it can localize a typeglob and use the filehandle directly:
d256 4
a259 3
    sub accept_fh {
        local *FH = shift;
        print  FH "Sending to localized filehandle\n";
d262 1
a262 47
Both styles work with either objects or typeglobs of real filehandles.
(They might also work with strings under some circumstances, but this
is risky.)

    accept_fh(*STDOUT);
    accept_fh($handle);

In the examples above, we assigned the filehandle to a scalar variable
before using it.  That is because only simple scalar variables,
not expressions or subscripts into hashes or arrays, can be used with
built-ins like C<print>, C<printf>, or the diamond operator.  These are
illegal and won't even compile:

    @@fd = (*STDIN, *STDOUT, *STDERR);
    print $fd[1] "Type it: ";                           # WRONG
    $got = <$fd[0]>                                     # WRONG
    print $fd[2] "What was that: $got";                 # WRONG

With C<print> and C<printf>, you get around this by using a block and
an expression where you would place the filehandle:

    print  { $fd[1] } "funny stuff\n";
    printf { $fd[1] } "Pity the poor %x.\n", 3_735_928_559;
    # Pity the poor deadbeef.

That block is a proper block like any other, so you can put more
complicated code there.  This sends the message out to one of two places:

    $ok = -x "/bin/cat";                
    print { $ok ? $fd[1] : $fd[2] } "cat stat $ok\n";
    print { $fd[ 1+ ($ok || 0) ]  } "cat stat $ok\n";           

This approach of treating C<print> and C<printf> like object methods
calls doesn't work for the diamond operator.  That's because it's a
real operator, not just a function with a comma-less argument.  Assuming
you've been storing typeglobs in your structure as we did above, you
can use the built-in function named C<readline> to reads a record just
as C<E<lt>E<gt>> does.  Given the initialization shown above for @@fd, this
would work, but only because readline() require a typeglob.  It doesn't
work with objects or strings, which might be a bug we haven't fixed yet.

    $got = readline($fd[0]);

Let it be noted that the flakiness of indirect filehandles is not
related to whether they're strings, typeglobs, objects, or anything else.
It's the syntax of the fundamental operators.  Playing the object
game doesn't help you at all here.
d271 1
a271 1
See L<perlform/"Accessing Formatting Internals"> for an swrite() function.
d279 1
a279 1
	1 while s/^([-+]?\d+)(\d{3})/$1,$2/;
d290 1
a290 1
    s/^([-+]?\d+)(\d{3})/$1,$2/g;
d304 1
a304 1
        return scalar reverse $input;
d329 1
a329 1
=head2 How come when I open a file read-write it wipes it out?
d334 1
a334 1
    open(FH, "+> /path/name");		# WRONG (almost always)
d337 1
a337 2
doesn't exist.  Using "E<gt>" always clobbers or creates. 
Using "E<lt>" never does either.  The "+" doesn't change this.
d339 1
a339 2
Here are examples of many kinds of file opens.  Those using sysopen()
all assume
d341 1
a341 1
    use Fcntl;
d343 1
a343 1
To open file for reading:
d345 1
a345 28
    open(FH, "< $path")                                 || die $!;
    sysopen(FH, $path, O_RDONLY)                        || die $!;

To open file for writing, create new file if needed or else truncate old file:

    open(FH, "> $path") || die $!;
    sysopen(FH, $path, O_WRONLY|O_TRUNC|O_CREAT)        || die $!;
    sysopen(FH, $path, O_WRONLY|O_TRUNC|O_CREAT, 0666)  || die $!;

To open file for writing, create new file, file must not exist:

    sysopen(FH, $path, O_WRONLY|O_EXCL|O_CREAT)         || die $!;
    sysopen(FH, $path, O_WRONLY|O_EXCL|O_CREAT, 0666)   || die $!;

To open file for appending, create if necessary:

    open(FH, ">> $path") || die $!;
    sysopen(FH, $path, O_WRONLY|O_APPEND|O_CREAT)       || die $!;
    sysopen(FH, $path, O_WRONLY|O_APPEND|O_CREAT, 0666) || die $!;

To open file for appending, file must exist:

    sysopen(FH, $path, O_WRONLY|O_APPEND)               || die $!;

To open file for update, file must exist:

    open(FH, "+< $path")                                || die $!;
    sysopen(FH, $path, O_RDWR)                          || die $!;
d347 1
a347 23
To open file for update, create file if necessary:

    sysopen(FH, $path, O_RDWR|O_CREAT)                  || die $!;
    sysopen(FH, $path, O_RDWR|O_CREAT, 0666)            || die $!;

To open file for update, file must not exist:

    sysopen(FH, $path, O_RDWR|O_EXCL|O_CREAT)           || die $!;
    sysopen(FH, $path, O_RDWR|O_EXCL|O_CREAT, 0666)     || die $!;

To open a file without blocking, creating if necessary:

    sysopen(FH, "/tmp/somefile", O_WRONLY|O_NDELAY|O_CREAT)
	    or die "can't open /tmp/somefile: $!":

Be warned that neither creation nor deletion of files is guaranteed to
be an atomic operation over NFS.  That is, two processes might both
successful create or unlink the same file!  Therefore O_EXCL
isn't so exclusive as you might wish.

See also the new L<perlopentut> if you have it (new for 5.006).

=head2 Why do I sometimes get an "Argument list too long" when I use E<lt>*E<gt>?
d355 1
a355 1
To get around this, either do the glob yourself with readdir() and
d357 1
a357 1
shell to do globbing.  This is expected to be fixed soon.
d376 3
a378 3
        s#^([^./])#./$1#;
        $_ .= "\0";
	return $_;
d381 2
a382 7
    $badpath = "<<<something really wicked   ";
    $fn = safe_filename($badpath");
    open(FH, "> $fn") or "couldn't open $badpath: $!";

This assumes that you are using POSIX (portable operating systems
interface) paths.  If you are on a closed, non-portable, proprietary
system, you may have to adjust the C<"./"> above.
d384 1
a384 9
It would be a lot clearer to use sysopen(), though:

    use Fcntl;
    $badpath = "<<<something really wicked   ";
    open (FH, $badpath, O_WRONLY | O_CREAT | O_TRUNC)
	or die "can't open $badpath: $!";

For more information, see also the new L<perlopentut> if you have it
(new for 5.006).
a400 2
The newer version of File::Copy exports a move() function.

d429 1
a429 2
For more information on file locking, see also L<perlopentut/"File
Locking"> if you have it (new for 5.006).
d431 3
a433 1
=back
d435 1
a435 1
=head2 Why can't I just open(FH, ">file.lock")?
d446 1
a446 1
    sysopen(FH, "file.lock", O_WRONLY|O_EXCL|O_CREAT)
d451 1
a451 1
Various schemes involving link() have been suggested, but
d457 6
a462 9
They don't count number of hits, they're a waste of time, and they serve
only to stroke the writer's vanity.  Better to pick a random number.
It's more realistic.

Anyway, this is what you can do if you can't help yourself.

    use Fcntl ':flock';
    sysopen(FH, "numfile", O_RDWR|O_CREAT) 	 or die "can't open numfile: $!";
    flock(FH, LOCK_EX) 				 or die "can't flock numfile: $!";
d467 1
a467 2
    # Perl as of 5.004 automatically flushes before unlocking
    flock(FH, LOCK_UN) 				 or die "can't flock numfile: $!";
d492 1
a492 1
    seek(FH, -$RECSIZE, 1);
d499 4
d517 1
a517 2
    printf "file %s updated at %s\n", $file,
	scalar localtime($write_secs);
a521 1
    # error checking left as an exercise for reader.
d527 1
a527 3
The POSIX::strftime() approach has the benefit of being,
in theory, independent of the current locale.  See L<perllocale>
for details.
d543 1
a543 1
Error checking is, as usual, left as an exercise for the reader.
d561 4
a564 1
Or even:
d566 2
a567 10
    # make STDOUT go to three files, plus original STDOUT
    open (STDOUT, "| tee file1 file2 file3") or die "Teeing off: $!\n";
    print "whatever\n"                       or die "Writing: $!\n";
    close(STDOUT)                            or die "Closing: $!\n";

Otherwise you'll have to write your own multiplexing print
function -- or your own tee program -- or use Tom Christiansen's,
at http://www.perl.com/CPAN/authors/id/TOMC/scripts/tct.gz, which is
written in Perl and offers much greater functionality
than the stock version.
d571 1
a571 1
Use the C<$/> variable (see L<perlvar> for details).  You can either
a575 3
Note that a blank line must have no blanks in it.  Thus C<"fred\n
\nstuff\n\n"> is one paragraph, but C<"fred\n\nstuff\n\n"> is two.

d583 2
a584 3
If your system supports the portable operating system programming
interface (POSIX), you can use the following code, which you'll note
turns off echo processing as well.
d635 1
a635 2
The Term::ReadKey module from CPAN may be easier to use.  Recent version
include also support for non-portable systems as well.
d646 1
a646 1
For legacy DOS systems, Dan Carson <dbc@@tc.fluke.COM> reports the following:
d692 1
a692 6
=head2 How can I tell whether there's a character waiting on a filehandle?

The very first thing you should do is look into getting the Term::ReadKey
extension from CPAN.  As we mentioned earlier, it now even has limited
support for non-portable (read: not open systems, closed, proprietary,
not POSIX, not Unix, etc) systems.
d694 1
a694 1
You should also check out the Frequently Asked Questions list in
d705 10
a714 29
If you want to find out how many characters are waiting, there's
also the FIONREAD ioctl call to be looked at.  The I<h2ph> tool that
comes with Perl tries to convert C include files to Perl code, which
can be C<require>d.  FIONREAD ends up defined as a function in the
I<sys/ioctl.ph> file:

    require 'sys/ioctl.ph';

    $size = pack("L", 0);
    ioctl(FH, FIONREAD(), $size)    or die "Couldn't call ioctl: $!\n";
    $size = unpack("L", $size);

If I<h2ph> wasn't installed or doesn't work for you, you can
I<grep> the include files by hand:

    % grep FIONREAD /usr/include/*/*
    /usr/include/asm/ioctls.h:#define FIONREAD      0x541B

Or write a small C program using the editor of champions:

    % cat > fionread.c
    #include <sys/ioctl.h>
    main() {
        printf("%#08x\n", FIONREAD);
    }
    ^D
    % cc -o fionread fionread.c
    % ./fionread
    0x4004667f
d716 1
a716 1
And then hard-code it, leaving porting as an exercise to your successor.
d718 2
a719 1
    $FIONREAD = 0x4004667f;         # XXX: opsys dependent
d721 3
a723 3
    $size = pack("L", 0);
    ioctl(FH, $FIONREAD, $size)     or die "Couldn't call ioctl: $!\n";
    $size = unpack("L", $size);
d725 3
a727 2
FIONREAD requires a filehandle connected to a stream, meaning sockets,
pipes, and tty devices work, but I<not> files.
a754 2
There's also a File::Tail module from CPAN.

d768 1
a768 6
Note that "E<lt>&STDIN" makes a copy, but "E<lt>&=STDIN" make
an alias.  That means if you close an aliased handle, all
aliases become inaccessible.  This is not true with 
a copied one.

Error checking, as always, has been left as an exercise for the reader.
d788 1
a788 1
"c:(tab)emp(formfeed)oo.exe" on your legacy DOS filesystem.
d794 1
a794 2
awk, Tcl, Java, or Python, just to mention a few.  POSIX paths
are more portable, too.
d800 1
a800 3
files.  This makes glob() portable even to legacy systems.  Your
port may include proprietary globbing functions as well.  Check its
documentation for details.
d805 1
a805 1
You Ever Wanted To Know" in
d824 1
a824 25
file in.  A simple proof by induction is available upon 
request if you doubt its correctness.

=head2 Why do I get weird spaces when I print an array of lines?

Saying

    print "@@lines\n";

joins together the elements of C<@@lines> with a space between them.
If C<@@lines> were C<("little", "fluffy", "clouds")> then the above
statement would print:

    little fluffy clouds

but if each element of C<@@lines> was a line of text, ending a newline
character C<("little\n", "fluffy\n", "clouds\n")> then it would print:

    little
     fluffy
     clouds

If your array contains lines, just print them:

    print @@lines;
d828 2
a829 13
Copyright (c) 1997-1999 Tom Christiansen and Nathan Torkington.
All rights reserved.

When included as an integrated part of the Standard Distribution
of Perl or of its documentation (printed or otherwise), this work is
covered under Perl's Artistic Licence.  For separate distributions of
all or part of this FAQ outside of that, see L<perlfaq>.

Irrespective of its distribution, all code examples here are public
domain.  You are permitted and encouraged to use this code and any
derivatives thereof in your own programs for fun or for profit as you
see fit.  A simple comment in the code giving credit to the FAQ would
be courteous but is not required.
@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
perlfaq5 - Files and Formats ($Revision: 1.38 $, $Date: 1999/05/23 16:08:30 $)
d72 1
a72 1
on all platforms, including Macintosh.  That's the way things work in
d350 1
a350 1
the C<< <FH> >> diamond operator will accept either a read filehandle
d410 1
a410 1
as C<< <> >> does.  Given the initialization shown above for @@fd, this
d466 1
a466 1
Use the <> (glob()) operator, documented in L<perlfunc>.  This
d494 2
a495 6
doesn't exist.  

    open(FH, "+< /path/name");  	# open for update

Using ">" always clobbers or creates.  Using "<" never does
either.  The "+" doesn't change this.
d553 1
a553 1
See also the new L<perlopentut> if you have it (new for 5.6).
d555 1
a555 1
=head2 Why do I sometimes get an "Argument list too long" when I use <*>?
d557 2
a558 3
The C<< <> >> operator performs a globbing operation (see above).
In Perl versions earlier than v5.6.0, the internal glob() operator forks
csh(1) to do the actual glob expansion, but
d563 3
a565 3
To get around this, either upgrade to Perl v5.6.0 or later, do the glob
yourself with readdir() and patterns, or use a module like Glob::KGlob,
one that doesn't use the shell to do globbing.
d574 1
a574 1
=head2 How can I open a file with a leading ">" or trailing blanks?
d605 1
a605 1
(new for 5.6).
d609 4
a612 8
Well, usually you just use Perl's rename() function.  But that may not
work everywhere, in particular, renaming files across file systems.
Some sub-Unix systems have broken ports that corrupt the semantics of
rename() -- for example, WinNT does this right, but Win95 and Win98
are broken.  (The last two parts are not surprising, but the first is. :-)

If your operating system supports a proper mv(1) program or its moral
equivalent, this works:
d646 5
a650 19
Some versions of flock() can't lock files over a network (e.g. on NFS file
systems), so you'd need to force the use of fcntl(2) when you build Perl.
But even this is dubious at best.  See the flock entry of L<perlfunc>,
and the F<INSTALL> file in the source distribution for information on
building Perl to do this.

Two potentially non-obvious but traditional flock semantics are that
it waits indefinitely until the lock is granted, and that its locks
I<merely advisory>.  Such discretionary locks are more flexible, but
offer fewer guarantees.  This means that files locked with flock() may
be modified by programs that do not also use flock().  Cars that stop
for red lights get on well with each other, but not with cars that don't
stop for red lights.  See the perlport manpage, your port's specific
documentation, or your system-specific local manpages for details.  It's
best to assume traditional behavior if you're writing portable programs.
(But if you're not, you should as always feel perfectly free to write
for your own system's idiosyncrasies (sometimes called "features").
Slavish adherence to portability concerns shouldn't get in the way of
your getting your job done.)
d653 1
a653 1
Locking"> if you have it (new for 5.6).
a799 52
=head2 How can I read in an entire file all at once?

The customary Perl approach for processing all the lines in a file is to
do so one line at a time:

    open (INPUT, $file) 	|| die "can't open $file: $!";
    while (<INPUT>) {
	chomp;
	# do something with $_
    } 
    close(INPUT)	    	|| die "can't close $file: $!";

This is tremendously more efficient than reading the entire file into
memory as an array of lines and then processing it one element at a time,
which is often -- if not almost always -- the wrong approach.  Whenever
you see someone do this:

    @@lines = <INPUT>;

You should think long and hard about why you need everything loaded
at once.  It's just not a scalable solution.  You might also find it
more fun to use the the standard DB_File module's $DB_RECNO bindings,
which allow you to tie an array to a file so that accessing an element
the array actually accesses the corresponding line in the file.

On very rare occasion, you may have an algorithm that demands that
the entire file be in memory at once as one scalar.  The simplest solution
to that is:

    $var = `cat $file`;

Being in scalar context, you get the whole thing.  In list context,
you'd get a list of all the lines:

    @@lines = `cat $file`;

This tiny but expedient solution is neat, clean, and portable to
all systems on which decent tools have been installed.  For those
who prefer not to use the toolbox, you can of course read the file
manually, although this makes for more complicated code.

    {
	local(*INPUT, $/);
	open (INPUT, $file) 	|| die "can't open $file: $!";
	$var = <INPUT>;
    }

That temporarily undefs your record separator, and will automatically 
close the file at block exit.  If the file is already open, just use this:

    $var = do { local $/; <INPUT> };

d1028 1
a1028 1
Note that "<&STDIN" makes a copy, but "<&=STDIN" make
a1045 8
Or just use the fdopen(3S) feature of open():

    { 
	local *F; 
	open F, "<&=$fd" or die "Cannot reopen fd=$fd: $!";
	close F;
    }

d1124 2
a1125 2
of Perl or of its documentation (printed or otherwise), this works is
covered under Perl's Artistic License.  For separate distributions of
d1128 1
a1128 1
Irrespective of its distribution, all code examples here are in the public
d1133 1
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d13 1
a13 1
devices.  This is done for efficiency reasons so that there isn't a
d86 2
a87 2
sequence of lines that operates much like a stack of playing cards--or
punch cards--computers usually see the text file as a sequence of bytes.
d91 5
a95 6
(There are exceptions in special circumstances.  You can add or remove
data at the very end of the file.  A sequence of bytes can be replaced
with another sequence of the same length.  The C<$DB_RECNO> array
bindings as documented in L<DB_File> also provide a direct way of
modifying a file.  Files where all lines are the same length are also
easy to alter.)
d177 2
a178 2
filehandle opened for reading and writing.  Use it if you don't
need to know the file's name:
d184 3
a186 4
If you do need to know the file's name, you can use the C<tmpnam>
function from the POSIX module to get a filename that you then open
yourself:

d202 3
a204 3
If you're committed to creating a temporary file by hand, use the
process ID and/or the current time-value.  If you need to have many
temporary files in one process, use a counter:
d275 1
a275 1
Here's how to use typeglobs in a loop to open and store a bunch of
d295 2
a296 2
preface them with a star, as in func(*STDIN).  
See L<perlfaq7/"Passing Filehandles"> for details.
d309 1
a309 1
Here's using the semi-object-oriented FileHandle module, which certainly
d320 1
a320 1
localized) typeglob or an anonymous handle from one of the modules
d328 1
a328 1
to get indirect filehandles:
d336 1
a336 1
Or, you can use the C<new> method from the FileHandle or IO modules to
d381 3
a383 4
before using it.  That is because only simple scalar variables, not
expressions or subscripts of hashes or arrays, can be used with
built-ins like C<print>, C<printf>, or the diamond operator.  Using
something other than a simple scalar varaible as a filehandle is
d452 1
a452 1
Alternatively, this code commifies all numbers in a line regardless of
d466 5
a470 5
Use the <> (glob()) operator, documented in L<perlfunc>.  Older
versions of Perl require that you have a shell installed that groks
tildes.  Recent perl versions have this feature built in. The
Glob::KGlob module (available from CPAN) gives more portable glob
functionality.
d554 2
a555 2
successfully create or unlink the same file!  Therefore O_EXCL
isn't as exclusive as you might wish.
d576 1
a576 1
context, you may cause a memory leak and/or unpredictable behavior.  It's
d583 2
a584 2
special.  To avoid this, you might want to use a routine like the one below.
It turns incomplete pathnames into explicit relative ones, and tacks a
d606 1
a606 1
    sysopen (FH, $badpath, O_WRONLY | O_CREAT | O_TRUNC)
d614 2
a615 2
Well, usually you just use Perl's rename() function.  That may not
work everywhere, though, particularly when renaming files across file systems.
d617 1
a617 1
rename()--for example, WinNT does this right, but Win95 and Win98
d627 1
a627 1
then delete the old one.  This isn't really the same semantically as a
d631 1
a631 1
Newer versions of File::Copy exports a move() function.
d657 1
a657 1
But even this is dubious at best.  See the flock entry of L<perlfunc>
d662 1
a662 1
it waits indefinitely until the lock is granted, and that its locks are
d670 1
a670 1
(If you're not, you should as always feel perfectly free to write
d675 2
a676 2
For more information on file locking, see also 
L<perlopentut/"File Locking"> if you have it (new for 5.6).
d703 2
a704 2
only to stroke the writer's vanity.  It's better to pick a random number;
they're more realistic.
d708 1
a708 1
    use Fcntl qw(:DEFAULT :flock);
d715 2
d746 1
a746 1
Don't forget them or you'll be quite sorry.
d796 1
a796 1
utime() on those platforms.
d818 2
a819 2
function--or your own tee program--or use Tom Christiansen's,
at http://www.perl.com/CPAN/authors/id/TOMC/scripts/tct.gz , which is
d837 1
a837 1
which is often--if not almost always--the wrong approach.  Whenever
d842 1
a842 1
you should think long and hard about why you need everything loaded
d844 1
a844 1
more fun to use the standard DB_File module's $DB_RECNO bindings,
d850 1
a850 1
to that is
d889 1
a889 1
the Term::ReadKey module from CPAN or use the sample code in
d945 1
a945 1
The Term::ReadKey module from CPAN may be easier to use.  Recent versions
d1000 2
a1001 2
This is all trial and error I did a long time ago; I hope I'm reading the
file that worked...
d1059 1
a1059 1
FIONREAD requires a filehandle connected to a stream, meaning that sockets,
d1114 1
a1114 1
numeric descriptor as with MHCONTEXT above.  But if you really have
d1121 1
a1121 1
Or, just use the fdopen(3S) feature of open():
d1141 1
a1141 1
one that doesn't clash with Perl--or the POSIX shell, ANSI C and C++,
d1176 1
a1176 1
request if you doubt the algorithm's correctness.
d1186 1
a1186 1
statement would print
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
perlfaq5 - Files and Formats ($Revision: 1.18 $, $Date: 2002/05/30 07:04:25 $)
d12 23
a34 25
Perl does not support truly unbuffered output (except
insofar as you can C<syswrite(OUT, $char, 1)>), although it
does support is "command buffering", in which a physical
write is performed after every output command.

The C standard I/O library (stdio) normally buffers
characters sent to devices so that there isn't a system call
for each byte. In most stdio implementations, the type of
output buffering and the size of the buffer varies according
to the type of device. Perl's print() and write() functions
normally buffer output, while syswrite() bypasses buffering
all together.

If you want your output to be sent immediately when you
execute print() or write() (for instance, for some network
protocols), you must set the handle's autoflush flag. This
flag is the Perl variable $| and when it is set to a true
value, Perl will flush the handle's buffer after each
print() or write(). Setting $| affects buffering only for
the currently selected default file handle. You choose this
handle with the one argument select() call (see
L<perlvar/$|> and L<perlfunc/select>).

Use select() to choose the desired handle, then set its
per-filehandle variables.
d40 1
a40 1
Some idioms can handle this in a single statement:
d44 6
a49 1
    $| = 1, select $_ for select OUTPUT_HANDLE;
d51 1
a51 3
Some modules offer object-oriented access to handles and their
variables, although they may be overkill if this is the only
thing you do with them.  You can use IO::Handle:
d57 1
a57 1
or IO::Socket:
d60 4
a63 1
	my $sock = IO::Socket::INET->new( 'www.example.com:80' ) ;
d66 12
d81 77
a157 2
Use the Tie::File module, which is included in the standard
distribution since Perl 5.8.0.
d177 3
a179 1
Use the File::Temp module, see L<File::Temp> for more information.
d181 3
a183 1
  use File::Temp qw/ tempfile tempdir /; 
d185 3
a187 2
  $dir = tempdir( CLEANUP => 1 );
  ($fh, $filename) = tempfile( DIR => $dir );
a188 1
  # or if you don't need to know the filename
d190 2
a191 1
  $fh = tempfile( DIR => $dir );
d193 8
a200 4
The File::Temp has been a standard module since Perl 5.6.1.  If you
don't have a modern enough Perl installed, use the C<new_tmpfile>
class method from the IO::File module to get a filehandle opened for
reading and writing.  Use it if you don't need to know the file's name:
d202 1
a202 3
    use IO::File;
    $fh = IO::File->new_tmpfile()
	or die "Unable to make new temporary file: $!";
d210 1
a210 1
	my $temp_dir = -d '/tmp' ? '/tmp' : $ENV{TMPDIR} || $ENV{TEMP};
d252 1
a252 1
symbolic references.  This is okay in small programs, but doesn't scale
d257 2
a258 4
As of perl5.6, open() autovivifies file and directory handles
as references if you pass it an uninitialized scalar variable.
You can then pass these references just like any other scalar,
and use them in the place of named handles.
d260 1
a260 1
	open my    $fh, $file_name;
d262 14
a275 1
	open local $fh, $file_name;
d277 11
a287 1
	print $fh "Hello World!\n";
d289 6
a294 1
	process_file( $fh );
d296 14
a309 2
Before perl5.6, you had to deal with various typeglob idioms
which you may see in older code.
d311 2
a312 3
	open FILE, "> $filename";
	process_typeglob(   *FILE );
	process_reference( \*FILE );
d314 1
a314 2
	sub process_typeglob  { local *FH = shift; print FH  "Typeglob!" }
	sub process_reference { local $fh = shift; print $fh "Reference!" }
d316 9
a324 2
If you want to create many anonymous handles, you should
check out the Symbol or IO::Handle modules.
d338 1
a338 1
Or, you can use the C<new> method from one of the IO::* modules to
d342 3
d352 1
a352 1
the C<< <FH> >> diamond operator will accept either a named filehandle
d386 1
a386 1
something other than a simple scalar variable as a filehandle is
d412 1
a412 1
can use the built-in function named C<readline> to read a record just
d414 1
a414 1
would work, but only because readline() requires a typeglob.  It doesn't
d435 10
a444 1
This one from Benjamin Goldberg will do it for you:
d446 1
a446 1
   s/(^[-+]?\d+?(?=(?>(?:\d{3})+)(?!\d))|\G\d{3}(?=\d))/$1,/g;
d448 1
a448 1
or written verbosely:
d450 16
a465 11
   s/(
       ^[-+]?            # beginning of number.
       \d{1,3}?          # first digits before first comma
       (?=               # followed by, (but not included in the match) :
          (?>(?:\d{3})+) # some positive multiple of three digits.
          (?!\d)         # an *exact* multiple, not x * 3 + 1 or whatever.
       )
      |                  # or:
       \G\d{3}           # after the last group, get three digits
       (?=\d)            # but they have to have more digits after them.
   )/$1,/xg;
d472 1
a472 1
File::KGlob module (available from CPAN) gives more portable glob
d572 1
a572 1
yourself with readdir() and patterns, or use a module like File::KGlob,
d586 10
a595 1
special. 
d597 3
a599 4
The three argument form of open() lets you specify the mode
separately from the filename.  The open() function treats
special mode characters and whitespace in the filename as 
literals
d601 3
a603 2
	open FILE, "<", "  file  ";  # filename is "   file   "
	open FILE, ">", ">file";     # filename is ">file"
d605 1
a605 1
It may be a lot clearer to use sysopen(), though:
d612 3
d617 7
a623 1
If your operating system supports a proper mv(1) utility or its functional
d628 4
a631 4
It may be more portable to use the File::Copy module instead.
You just copy to the new file to the new name (checking return
values), then delete the old one.  This isn't really the same
semantically as a rename(), which preserves meta-information like
d634 1
a634 1
Newer versions of File::Copy export a move() function.
a725 28
=head2 All I want to do is append a small amount of text to the end of a file.  Do I still have to use locking?

If you are on a system that correctly implements flock() and you use the
example appending code from "perldoc -f flock" everything will be OK
even if the OS you are on doesn't implement append mode correctly (if
such a system exists.) So if you are happy to restrict yourself to OSs
that implement flock() (and that's not really much of a restriction)
then that is what you should do.

If you know you are only going to use a system that does correctly
implement appending (i.e. not Win32) then you can omit the seek() from
the above code.

If you know you are only writing code to run on an OS and filesystem that
does implement append mode correctly (a local filesystem on a modern
Unix for example), and you keep the file in block-buffered mode and you
write less than one buffer-full of output between each manual flushing
of the buffer then each bufferload is almost guaranteed to be written to
the end of the file in one chunk without getting intermingled with
anyone else's output. You can also use the syswrite() function which is
simply a wrapper around your systems write(2) system call.

There is still a small theoretical chance that a signal will interrupt
the system level write() operation before completion.  There is also a
possibility that some STDIO implementations may call multiple system
level write()s even if the buffer was empty to start.  There may be some
systems where this probability is reduced to zero.

d751 8
a758 11
If you want to retrieve the time at which the file was last
read, written, or had its meta-data (owner, etc) changed,
you use the B<-M>, B<-A>, or B<-C> file test operations as
documented in L<perlfunc>.  These retrieve the age of the
file (measured against the start-time of your program) in
days as a floating point number. Some platforms may not have
all of these times.  See L<perlport> for details. To
retrieve the "raw" time in seconds since the epoch, you
would call the stat function, then use localtime(),
gmtime(), or POSIX::strftime() to convert this into
human-readable form.
d820 1
a820 1
at http://www.cpan.org/authors/id/TOMC/scripts/tct.gz , which is
d843 21
a863 8
you should think long and hard about why you need everything loaded at
once.  It's just not a scalable solution.  You might also find it more
fun to use the standard Tie::File module, or the DB_File module's
$DB_RECNO bindings, which allow you to tie an array to a file so that
accessing an element the array actually accesses the corresponding
line in the file.

You can read the entire filehandle contents into a scalar.
a875 7
For ordinary files you can also use the read function.

	read( INPUT, $var, -s INPUT );

The third argument tests the byte size of the data on the INPUT filehandle
and reads that many bytes into the buffer $var.

d883 2
a884 2
Note that a blank line must have no blanks in it.  Thus 
S<C<"fred\n \nstuff\n\n">> is one paragraph, but C<"fred\n\nstuff\n\n"> is two.
d958 46
d1052 1
a1052 1
And then hard code it, leaving porting as an exercise to your successor.
d1130 1
a1130 1
=head2 Why can't I use "C:\temp\foo" in DOS paths?  Why doesn't `C:\temp\foo.exe` work?
d1156 3
a1158 3
This is elaborately and painstakingly described in the
F<file-dir-perms> article in the "Far More Than You Ever Wanted To
Know" collection in http://www.cpan.org/olddoc/FMTEYEWTK.tgz .
d1204 1
a1204 1
Copyright (c) 1997-2002 Tom Christiansen and Nathan Torkington.
d1207 4
a1210 2
This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 1
perlfaq5 - Files and Formats ($Revision: 1.28 $, $Date: 2003/01/26 17:45:46 $)
d33 1
a33 1
L<perlvar/$E<verbar>> and L<perlfunc/select>).
a83 25
=head2 How can I use Perl's C<-i> option from within a program?

C<-i> sets the value of Perl's C<$^I> variable, which in turn affects
the behavior of C<< <> >>; see L<perlrun> for more details.  By
modifying the appropriate variables directly, you can get the same
behavior within a larger program.  For example:

     # ...
     {
        local($^I, @@ARGV) = ('.orig', glob("*.c"));
        while (<>) {
           if ($. == 1) {
               print "This line should appear at the top of each file\n";
           }
           s/\b(p)earl\b/${1}erl/i;        # Correct typos, preserving case
           print;
           close ARGV if eof;              # Reset $.
        }
     }
     # $^I and @@ARGV return to their old values here

This block modifies all the C<.c> files in the current directory,
leaving a backup of the original data from each file in a new
C<.c.orig> file.

d88 1
a88 1
  use File::Temp qw/ tempfile tempdir /;
d142 1
a142 1
    print scalar <PS>;
d260 1
a260 1
    $ok = -x "/bin/cat";
d262 1
a262 1
    print { $fd[ 1+ ($ok || 0) ]  } "cat stat $ok\n";
d291 1
a291 9
This subroutine will add commas to your number:

	sub commify {
	   local $_  = shift;
	   1 while s/^([-+]?\d+)(\d{3})/$1,$2/;
	   return $_;
	   }

This regex from Benjamin Goldberg will add commas to numbers:
d295 1
a295 1
It is easier to see with comments:
d339 1
a339 1
doesn't exist.
d404 1
a404 1
=head2 Why do I sometimes get an "Argument list too long" when I use E<lt>*E<gt>?
d428 1
a428 1
special.
d432 1
a432 1
special mode characters and whitespace in the filename as
d447 2
a448 2
If your operating system supports a proper mv(1) utility or its
functional equivalent, this works:
d502 1
a502 1
For more information on file locking, see also
d507 1
a507 1
=head2 Why can't I just open(FH, "E<gt>file.lock")?
d519 1
a519 1
		or die "can't open  file.lock: $!";
d656 1
a656 2
To connect one filehandle to several output filehandles,
you can use the IO::Tee or Tie::FileHandle::Multiplex modules.
d658 1
a658 2
If you only have to do this once, you can print individually
to each filehandle.
d660 18
a677 1
    for $fh (FH1, FH2, FH3) { print $fh "whatever\n" }
a680 7
You can use the File::Slurp module to do it in one step.

	use File::Slurp;

	$all_of_it = read_file($filename); # entire file in scalar
    @@all_lines = read_file($filename); # one line perl element

d688 1
a688 1
    }
d713 1
a713 1
That temporarily undefs your record separator, and will automatically
d732 1
a732 1
Note that a blank line must have no blanks in it.  Thus
d909 1
a909 1
aliases become inaccessible.  This is not true with
d927 2
a928 2
    {
	local *F;
d961 1
a961 1
Know" collection in http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz .
d978 3
a980 12
This has a significant advantage in space over reading the whole file
in.  You can find a proof of this method in I<The Art of Computer
Programming>, Volume 2, Section 3.4.2, by Donald E. Knuth.

You can use the File::Random module which provides a function
for that algorithm:

	use File::Random qw/random_line/;
	my $line = random_line($filename);

Another way is to use the Tie::File module, which treats the entire
file as an array.  Simply access a random array element.
@


1.1.1.6
log
@perl 5.8.3 from CPAN
@
text
@d3 1
a3 1
perlfaq5 - Files and Formats ($Revision: 1.30 $, $Date: 2003/11/23 08:07:46 $)
d156 2
a157 4
The most efficient way is using L<pack()|perlfunc/"pack"> and
L<unpack()|perlfunc/"unpack">.  This is faster than using
L<substr()|perlfunc/"substr"> when taking many, many strings.  It is
slower for just a few.
d165 7
a171 9
    my $PS_T = 'A6 A4 A7 A5 A*';
    open my $ps, '-|', 'ps';
    print scalar <$ps>;
    my @@fields = qw( pid tt stat time command );
    while (<$ps>) {
        my %process;
        @@process{@@fields} = unpack($PS_T, $_);
	for my $field ( @@fields ) {
	    print "$field: <$process{$field}>\n";
d173 2
a174 1
	print 'line=', pack($PS_T, @@process{@@fields} ), "\n";
d177 4
a180 4
We've used a hash slice in order to easily handle the fields of each row.
Storing the keys in an array means it's easy to operate on them as a
group or loop over them with for. It also avoids polluting the program
with global variables and using symbolic references.
@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@d3 1
a3 1
perlfaq5 - Files and Formats ($Revision: 1.7 $, $Date: 2004/04/07 21:33:08 $)
a143 1
		# O_EXCL is required for security reasons.
d430 2
a431 2
    sysopen(FH, "/foo/somefile", O_WRONLY|O_NDELAY|O_CREAT)
	    or die "can't open /foo/somefile: $!":
d927 1
a927 1
    open(LOG, ">>/foo/logfile");
@


1.1.1.8
log
@perl 5.8.6 from CPAN
@
text
@d3 1
a3 1
perlfaq5 - Files and Formats ($Revision: 1.31 $, $Date: 2004/02/07 04:29:50 $)
@


1.1.1.9
log
@perl 5.8.8 import
@
text
@d3 1
a3 1
perlfaq5 - Files and Formats ($Revision: 1.42 $, $Date: 2005/12/31 00:54:37 $)
a10 1
X<flush> X<buffer> X<unbuffer> X<autoflush>
d59 1
a59 1
	my $sock = IO::Socket::INET->new( 'www.example.com:80' );
a63 1
X<file, editing>
a68 1
X<file, counting lines> X<lines> X<line>
a84 1
X<-i> X<in-place>
a108 17
=head2 How can I copy a file?
X<copy> X<file, copy>

(contributed by brian d foy)

Use the File::Copy module. It comes with Perl and can do a
true copy across file systems, and it does its magic in
a portable fashion.

	use File::Copy;

	copy( $original, $new_copy ) or die "Copy failed: $!";

If you can't use File::Copy, you'll have to do the work yourself:
open the original file, open the destination file, then print
to the destination file as you read the original.

a109 7
X<file, temporary>

If you don't need to know the name of the file, you can use C<open()>
with C<undef> in place of the file name.  The C<open()> function
creates an anonymous temporary file.

	open my $tmp, '+>', undef or die $!;
d111 1
a111 1
Otherwise, you can use the File::Temp module.
a155 1
X<fixed-length> X<file, fixed-length records>
a186 1
X<filehandle, local> X<filehandle, passing> X<filehandle, reference>
a214 1
X<filehandle, indirect>
a309 1
X<footer>
a314 1
X<write, into a string>
a318 8
X<number, commify>

(contributed by brian d foy and Benjamin Goldberg)

You can use L<Number::Format> to separate places in a number.
It handles locale information for those of you who want to insert
full stops instead (or anything else that they want to use,
really).
d336 1
a336 1
       \d+?              # first digits before first comma
a346 1
X<tilde> X<tilde expansion>
a368 1
X<clobber> X<read-write> X<clobbering> X<truncate> X<truncating>
a441 1
X<argument list too long>
a454 1
X<glob>
a461 1
X<filename, special characters>
d463 8
a470 10
(contributed by Brian McCauley)

The special two argument form of Perl's open() function ignores
trailing blanks in filenames and infers the mode from certain leading
characters (or a trailing "|"). In older versions of Perl this was the
only version of open() and so it is prevalent in old code and books.

Unless you have a particular reason to use the two argument form you
should use the three argument form of open() which does not treat any
charcters in the filename as special.
d475 7
a482 1
X<rename> X<mv> X<move> X<file, rename> X<ren>
a497 1
X<lock> X<file, lock> X<flock>
a544 1
X<lock, lockfile race condition>
a563 1
X<counter> X<file, counter>
a587 1
X<append> X<file, append>
a615 1
X<file, binary patch>
a638 1
X<timestamp> X<file, timestamp>
d642 1
a642 1
you use the B<-A>, B<-M>, or B<-C> file test operations as
a671 1
X<timestamp> X<file, timestamp>
d687 3
a689 8
The perldoc for utime also has an example that has the same
effect as touch(1) on files that I<already exist>.

Certain file systems have a limited ability to store the times
on a file at the expected level of precision.  For example, the
FAT and HPFS filesystem are unable to create dates on files with
a finer granularity than two seconds.  This is a limitation of
the filesystems, not of utime().
a691 1
X<print, to multiple files>
a701 1
X<slurp> X<file, slurping>
a754 1
X<file, reading by paragraphs>
a764 1
X<getc> X<file, reading one character at a time>
a895 1
X<tail>
a923 1
X<dup>
a943 1
X<file, closing file descriptors>
a962 1
X<filename, DOS issues>
a978 1
X<glob>
a1000 1
X<file, selecting a random line>
d1045 2
a1046 2
Copyright (c) 1997-2006 Tom Christiansen, Nathan Torkington, and
other authors as noted. All rights reserved.
@


1.1.1.10
log
@import perl 5.10.0 from CPAN
@
text
@d3 1
a3 1
perlfaq5 - Files and Formats ($Revision: 10126 $)
d13 21
a33 19
Perl does not support truly unbuffered output (except insofar as you
can C<syswrite(OUT, $char, 1)>), although it does support is "command
buffering", in which a physical write is performed after every output
command.

The C standard I/O library (stdio) normally buffers characters sent to
devices so that there isn't a system call for each byte. In most stdio
implementations, the type of output buffering and the size of the
buffer varies according to the type of device. Perl's C<print()> and
C<write()> functions normally buffer output, while C<syswrite()>
bypasses buffering all together.

If you want your output to be sent immediately when you execute
C<print()> or C<write()> (for instance, for some network protocols),
you must set the handle's autoflush flag. This flag is the Perl
variable C<$|> and when it is set to a true value, Perl will flush the
handle's buffer after each C<print()> or C<write()>. Setting C<$|>
affects buffering only for the currently selected default filehandle.
You choose this handle with the one argument C<select()> call (see
d36 1
a36 1
Use C<select()> to choose the desired handle, then set its
d39 9
a47 3
	$old_fh = select(OUTPUT_HANDLE);
	$| = 1;
	select($old_fh);
d50 2
a51 2
variables, although they may be overkill if this is the only thing you
do with them.  You can use C<IO::Handle>:
d53 3
a55 3
	use IO::Handle;
	open my( $printer ), ">", "/dev/printer");   # but is this?
	$printer->autoflush(1);
d57 1
a57 1
or C<IO::Socket> (which inherits from C<IO::Handle>):
d59 1
a59 1
	use IO::Socket;		  # this one is kinda a pipe?
d62 1
a62 8
	$sock->autoflush();

You can also flush an C<IO::Handle> object without setting
C<autoflush>. Call the C<flush> method to flush the buffer yourself:

	use IO::Handle;
	open my( $printer ), ">", "/dev/printer"); 
	$printer->flush; # one time flush
d64 1
a64 2
	
=head2 How do I change, delete, or insert a line in a file, or append to the beginning of a file?
d67 2
a68 161
(contributed by brian d foy)

The basic idea of inserting, changing, or deleting a line from a text
file involves reading and printing the file to the point you want to
make the change, making the change, then reading and printing the rest
of the file. Perl doesn't provide random access to lines (especially
since the record input separator, C<$/>, is mutable), although modules
such as C<Tie::File> can fake it.

A Perl program to do these tasks takes the basic form of opening a
file, printing its lines, then closing the file:

	open my $in,  '<',  $file      or die "Can't read old file: $!";
	open my $out, '>', "$file.new" or die "Can't write new file: $!";

	while( <$in> )
		{
		print $out $_;
		}

   close $out;

Within that basic form, add the parts that you need to insert, change,
or delete lines.

To prepend lines to the beginning, print those lines before you enter
the loop that prints the existing lines.

	open my $in,  '<',  $file      or die "Can't read old file: $!";
	open my $out, '>', "$file.new" or die "Can't write new file: $!";

	print "# Add this line to the top\n"; # <--- HERE'S THE MAGIC

	while( <$in> )
		{
		print $out $_;
		}

   close $out;

To change existing lines, insert the code to modify the lines inside
the C<while> loop. In this case, the code finds all lowercased
versions of "perl" and uppercases them. The happens for every line, so
be sure that you're supposed to do that on every line!

	open my $in,  '<',  $file      or die "Can't read old file: $!";
	open my $out, '>', "$file.new" or die "Can't write new file: $!";

	print "# Add this line to the top\n";

	while( <$in> )
		{
		s/\b(perl)\b/Perl/g;
		print $out $_;
		}

   close $out;

To change only a particular line, the input line number, C<$.>, is
useful. First read and print the lines up to the one you  want to
change. Next, read the single line you want to change, change it, and
print it. After that, read the rest of the lines and print those:

	while( <$in> )   # print the lines before the change
		{
		print $out $_;
		last if $. == 4; # line number before change
		}

	my $line = <$in>;
	$line =~ s/\b(perl)\b/Perl/g;
	print $out $line;

	while( <$in> )   # print the rest of the lines
		{
		print $out $_;
		}
		
To skip lines, use the looping controls. The C<next> in this example
skips comment lines, and the C<last> stops all processing once it
encounters either C<__END__> or C<__DATA__>.

	while( <$in> )
		{
		next if /^\s+#/;             # skip comment lines
		last if /^__(END|DATA)__$/;  # stop at end of code marker
		print $out $_;
		}

Do the same sort of thing to delete a particular line by using C<next>
to skip the lines you don't want to show up in the output. This
example skips every fifth line:

	while( <$in> )
		{
		next unless $. % 5;
		print $out $_;
		}

If, for some odd reason, you really want to see the whole file at once
rather than processing line by line, you can slurp it in (as long as
you can fit the whole thing in memory!):

	open my $in,  '<',  $file      or die "Can't read old file: $!"
	open my $out, '>', "$file.new" or die "Can't write new file: $!";

	my @@lines = do { local $/; <$in> }; # slurp!

		# do your magic here

	print $out @@lines;

Modules such as C<File::Slurp> and C<Tie::File> can help with that
too. If you can, however, avoid reading the entire file at once. Perl
won't give that memory back to the operating system until the process
finishes.

You can also use Perl one-liners to modify a file in-place. The
following changes all 'Fred' to 'Barney' in F<inFile.txt>, overwriting
the file with the new contents. With the C<-p> switch, Perl wraps a
C<while> loop around the code you specify with C<-e>, and C<-i> turns
on in-place editing. The current line is in C<$_>. With C<-p>, Perl
automatically prints the value of C<$_> at the end of the loop. See
L<perlrun> for more details.

	perl -pi -e 's/Fred/Barney/' inFile.txt

To make a backup of C<inFile.txt>, give C<-i> a file extension to add:

	perl -pi.bak -e 's/Fred/Barney/' inFile.txt

To change only the fifth line, you can add a test checking C<$.>, the
input line number, then only perform the operation when the test
passes:

	perl -pi -e 's/Fred/Barney/ if $. == 5' inFile.txt

To add lines before a certain line, you can add a line (or lines!)
before Perl prints C<$_>:

	perl -pi -e 'print "Put before third line\n" if $. == 3' inFile.txt

You can even add a line to the beginning of a file, since the current
line prints at the end of the loop:

	perl -pi -e 'print "Put before first line\n" if $. == 1' inFile.txt

To insert a line after one already in the file, use the C<-n> switch.
It's just like C<-p> except that it doesn't print C<$_> at the end of
the loop, so you have to do that yourself. In this case, print C<$_>
first, then print the line that you want to add.

	perl -ni -e 'print; print "Put after fifth line\n" if $. == 5' inFile.txt

To delete lines, only print the ones that you want.

	perl -ni -e 'print unless /d/' inFile.txt

		... or ...

	perl -pi -e 'next unless /d/' inFile.txt
d78 6
a83 6
	$lines = 0;
	open(FILE, $filename) or die "Can't open `$filename': $!";
	while (sysread FILE, $buffer, 4096) {
		$lines += ($buffer =~ tr/\n//);
		}
	close FILE;
d95 13
a107 13
	# ...
	{
	local($^I, @@ARGV) = ('.orig', glob("*.c"));
	while (<>) {
		if ($. == 1) {
			print "This line should appear at the top of each file\n";
		}
		s/\b(p)earl\b/${1}erl/i;        # Correct typos, preserving case
		print;
		close ARGV if eof;              # Reset $.
		}
	}
	# $^I and @@ARGV return to their old values here
d141 1
a141 1
	use File::Temp qw/ tempfile tempdir /;
d143 2
a144 2
	$dir = tempdir( CLEANUP => 1 );
	($fh, $filename) = tempfile( DIR => $dir );
d146 1
a146 1
	# or if you don't need to know the filename
d148 1
a148 1
	$fh = tempfile( DIR => $dir );
d155 2
a156 2
	use IO::File;
	$fh = IO::File->new_tmpfile()
d163 1
a163 1
	BEGIN {
d166 1
a166 2
	my $base_name = sprintf "%s/%d-%d-0000", $temp_dir, $$, time;

d168 12
a179 16
		local *FH;
		my $count = 0;
		until( defined(fileno(FH)) || $count++ > 100 ) {
			$base_name =~ s/-(\d+)$/"-" . (1 + $1)/e;
			# O_EXCL is required for security reasons.
			sysopen FH, $base_name, O_WRONLY|O_EXCL|O_CREAT;
			}

		if( defined fileno(FH) ) {
			return (*FH, $base_name);
			}
		else {
			return ();
			}
		}
		
d181 1
d195 9
a203 9
	# sample input line:
	#   15158 p5  T      0:00 perl /home/tchrist/scripts/now-what
	my $PS_T = 'A6 A4 A7 A5 A*';
	open my $ps, '-|', 'ps';
	print scalar <$ps>;
	my @@fields = qw( pid tt stat time command );
	while (<$ps>) {
		my %process;
		@@process{@@fields} = unpack($PS_T, $_);
d205 1
a205 1
		print "$field: <$process{$field}>\n";
d208 1
a208 1
	}
a230 12
If you like, you can store these filehandles in an array or a hash.
If you access them directly, they aren't simple scalars and you
need to give C<print> a little help by placing the filehandle
reference in braces. Perl can only figure it out on its own when
the filehandle reference is a simple scalar.

	my @@fhs = ( $fh1, $fh2, $fh3 );

	for( $i = 0; $i <= $#fhs; $i++ ) {
		print {$fhs[$i]} "just another Perl answer, \n";
		}

d251 5
a255 5
	$fh =   SOME_FH;       # bareword is strict-subs hostile
	$fh =  "SOME_FH";      # strict-refs hostile; same package only
	$fh =  *SOME_FH;       # typeglob
	$fh = \*SOME_FH;       # ref to typeglob (bless-able)
	$fh =  *SOME_FH{IO};   # blessed IO::Handle from *SOME_FH typeglob
d261 2
a262 2
	use IO::Handle;                     # 5.004 or higher
	$fh = IO::Handle->new();
d271 4
a274 4
	($ifh, $ofh, $efh) = (*STDIN, *STDOUT, *STDERR);
	print $ofh "Type it: ";
	$got = <$ifh>
	print $efh "What was that: $got";
d279 4
a282 4
	sub accept_fh {
		my $fh = shift;
		print $fh "Sending to indirect filehandle\n";
	}
d286 4
a289 4
	sub accept_fh {
		local *FH = shift;
		print  FH "Sending to localized filehandle\n";
	}
d295 2
a296 2
	accept_fh(*STDOUT);
	accept_fh($handle);
d305 4
a308 4
	@@fd = (*STDIN, *STDOUT, *STDERR);
	print $fd[1] "Type it: ";                           # WRONG
	$got = <$fd[0]>                                     # WRONG
	print $fd[2] "What was that: $got";                 # WRONG
d313 3
a315 3
	print  { $fd[1] } "funny stuff\n";
	printf { $fd[1] } "Pity the poor %x.\n", 3_735_928_559;
	# Pity the poor deadbeef.
d320 3
a322 3
	$ok = -x "/bin/cat";
	print { $ok ? $fd[1] : $fd[2] } "cat stat $ok\n";
	print { $fd[ 1+ ($ok || 0) ]  } "cat stat $ok\n";
d333 1
a333 1
	$got = readline($fd[0]);
d349 1
a349 1
See L<perlform/"Accessing Formatting Internals"> for an C<swrite()> function.
a350 19
=head2 How can I open a filehandle to a string?
X<string>, X<open>, X<IO::Scalar>, X<filehandle>

(contributed by Peter J. Holzer, hjp-usenet2@@hjp.at)

Since Perl 5.8.0, you can pass a reference to a scalar instead of the
filename to create a file handle which you can used to read from or write to
a string:

	open(my $fh, '>', \$string) or die "Could not open string for writing";
	print $fh "foo\n";
	print $fh "bar\n";	# $string now contains "foo\nbar\n"

	open(my $fh, '<', \$string) or die "Could not open string for reading";
	my $x = <$fh>;	# $x now contains "foo\n"

With older versions of Perl, the C<IO::String> module provides similar
functionality.
    
d364 4
a367 4
		local $_  = shift;
		1 while s/^([-+]?\d+)(\d{3})/$1,$2/;
		return $_;
		}
d371 1
a371 1
	s/(^[-+]?\d+?(?=(?>(?:\d{3})+)(?!\d))|\G\d{3}(?=\d))/$1,/g;
d375 11
a385 11
	s/(
		^[-+]?             # beginning of number.
		\d+?               # first digits before first comma
		(?=                # followed by, (but not included in the match) :
			(?>(?:\d{3})+) # some positive multiple of three digits.
			(?!\d)         # an *exact* multiple, not x * 3 + 1 or whatever.
		)
		|                  # or:
		\G\d{3}            # after the last group, get three digits
		(?=\d)             # but they have to have more digits after them.
	)/$1,/xg;
d416 1
a416 1
	open(FH, "+> /path/name");		# WRONG (almost always)
d421 1
a421 1
	open(FH, "+< /path/name");  	# open for update
d429 1
a429 1
	use Fcntl;
d433 2
a434 2
	open(FH, "< $path")                                 || die $!;
	sysopen(FH, $path, O_RDONLY)                        || die $!;
d438 3
a440 3
	open(FH, "> $path") || die $!;
	sysopen(FH, $path, O_WRONLY|O_TRUNC|O_CREAT)        || die $!;
	sysopen(FH, $path, O_WRONLY|O_TRUNC|O_CREAT, 0666)  || die $!;
d444 2
a445 2
	sysopen(FH, $path, O_WRONLY|O_EXCL|O_CREAT)         || die $!;
	sysopen(FH, $path, O_WRONLY|O_EXCL|O_CREAT, 0666)   || die $!;
d449 3
a451 3
	open(FH, ">> $path") || die $!;
	sysopen(FH, $path, O_WRONLY|O_APPEND|O_CREAT)       || die $!;
	sysopen(FH, $path, O_WRONLY|O_APPEND|O_CREAT, 0666) || die $!;
d455 1
a455 1
	sysopen(FH, $path, O_WRONLY|O_APPEND)               || die $!;
d459 2
a460 2
	open(FH, "+< $path")                                || die $!;
	sysopen(FH, $path, O_RDWR)                          || die $!;
d464 2
a465 2
	sysopen(FH, $path, O_RDWR|O_CREAT)                  || die $!;
	sysopen(FH, $path, O_RDWR|O_CREAT, 0666)            || die $!;
d469 2
a470 2
	sysopen(FH, $path, O_RDWR|O_EXCL|O_CREAT)           || die $!;
	sysopen(FH, $path, O_RDWR|O_EXCL|O_CREAT, 0666)     || die $!;
d474 1
a474 1
	sysopen(FH, "/foo/somefile", O_WRONLY|O_NDELAY|O_CREAT)
d518 1
a518 1
characters in the filename as special.
d529 1
a529 1
	rename($old, $new) or system("mv", $old, $new);
d592 2
a593 2
	sleep(3) while -e "file.lock";	# PLEASE DO NOT USE
	open(LCK, "> file.lock");		# THIS BROKEN CODE
d599 1
a599 1
	sysopen(FH, "file.lock", O_WRONLY|O_EXCL|O_CREAT)
d605 1
a605 1
these tend to involve busy-wait, which is also less than desirable.
d617 8
a624 8
	use Fcntl qw(:DEFAULT :flock);
	sysopen(FH, "numfile", O_RDWR|O_CREAT) 	 or die "can't open numfile: $!";
	flock(FH, LOCK_EX) 				 or die "can't flock numfile: $!";
	$num = <FH> || 0;
	seek(FH, 0, 0) 				 or die "can't rewind numfile: $!";
	truncate(FH, 0) 				 or die "can't truncate numfile: $!";
	(print FH $num+1, "\n")			 or die "can't write numfile: $!";
	close FH 					 or die "can't close numfile: $!";
d628 1
a628 1
	$hits = int( (time() - 850_000_000) / rand(1_000) );
d644 1
a644 1
the code in the previous answer.
d667 1
a667 1
	perl -i -pe 's{window manager}{window mangler}g' /usr/bin/emacs
d672 9
a680 9
	$RECSIZE = 220; # size of record, in bytes
	$recno   = 37;  # which record to update
	open(FH, "+<somewhere") || die "can't update somewhere: $!";
	seek(FH, $recno * $RECSIZE, 0);
	read(FH, $record, $RECSIZE) == $RECSIZE || die "can't read record $recno: $!";
	# munge the record
	seek(FH, -$RECSIZE, 1);
	print FH $record;
	close FH;
d702 2
a703 2
	$write_secs = (stat($file))[9];
	printf "file %s updated at %s\n", $file,
d709 5
a713 5
	# error checking left as an exercise for reader.
	use File::stat;
	use Time::localtime;
	$date_string = ctime(stat($file)->mtime);
	print "file $file updated at $date_string\n";
d727 6
a732 6
	if (@@ARGV < 2) {
		die "usage: cptimes timestamp_file other_files ...\n";
		}
	$timestamp = shift;
	($atime, $mtime) = (stat($timestamp))[8,9];
	utime $atime, $mtime, @@ARGV;
d754 1
a754 1
	for $fh (FH1, FH2, FH3) { print $fh "whatever\n" }
d764 1
a764 1
	@@all_lines = read_file($filename); # one line perl element
d769 6
a774 6
	open (INPUT, $file) 	|| die "can't open $file: $!";
	while (<INPUT>) {
		chomp;
		# do something with $_
		}
	close(INPUT)	    	|| die "can't close $file: $!";
d781 1
a781 1
	@@lines = <INPUT>;
d792 1
a792 1
	{
d796 1
a796 1
	}
d801 1
a801 1
	$var = do { local $/; <INPUT> };
d833 9
a841 9
	#!/usr/bin/perl -w
	use strict;
	$| = 1;
	for (1..4) {
		my $got;
		print "gimme: ";
		$got = getone();
		print "--> $got\n";
		}
d844 1
a844 1
	BEGIN {
d859 4
a862 4
		$term->setlflag($noecho);
		$term->setcc(VTIME, 1);
		$term->setattr($fd_stdin, TCSANOW);
		}
d865 4
a868 4
		$term->setlflag($oterm);
		$term->setcc(VTIME, 0);
		$term->setattr($fd_stdin, TCSANOW);
		}
d871 6
a876 6
		my $key = '';
		cbreak();
		sysread(STDIN, $key, 1);
		cooked();
		return $key;
		}
d878 1
a878 1
	}
d880 1
a880 1
	END { cooked() }
d885 8
a892 8
	use Term::ReadKey;
	open(TTY, "</dev/tty");
	print "Gimme a char: ";
	ReadMode "raw";
	$key = ReadKey 0, *TTY;
	ReadMode "normal";
	printf "\nYou said %s, char number %03d\n",
		$key, ord $key;
d906 5
a910 5
	sub key_ready {
		my($rin, $nfd);
		vec($rin, fileno(STDIN), 1) = 1;
		return $nfd = select($rin,undef,undef,0);
		}
d918 1
a918 1
	require 'sys/ioctl.ph';
d920 3
a922 3
	$size = pack("L", 0);
	ioctl(FH, FIONREAD(), $size)    or die "Couldn't call ioctl: $!\n";
	$size = unpack("L", $size);
d927 2
a928 2
	% grep FIONREAD /usr/include/*/*
	/usr/include/asm/ioctls.h:#define FIONREAD      0x541B
d932 9
a940 9
	% cat > fionread.c
	#include <sys/ioctl.h>
	main() {
	    printf("%#08x\n", FIONREAD);
	}
	^D
	% cc -o fionread fionread.c
	% ./fionread
	0x4004667f
d944 1
a944 1
	$FIONREAD = 0x4004667f;         # XXX: opsys dependent
d946 3
a948 3
	$size = pack("L", 0);
	ioctl(FH, $FIONREAD, $size)     or die "Couldn't call ioctl: $!\n";
	$size = unpack("L", $size);
d954 1
a954 1
X<tail> X<IO::Handle> X<File::Tail> X<clearerr>
d958 1
a958 1
	seek(GWFILE, 0, 1);
d962 1
a962 1
next C<< <GWFILE> >> makes Perl try again to read something.
d975 4
a978 3
If this still doesn't work, look into the C<clearerr> method
from C<IO::Handle>, which resets the error and end-of-file states
on the handle.
d980 1
a980 1
There's also a C<File::Tail> module from CPAN.
d988 2
a989 2
	open(LOG, ">>/foo/logfile");
	open(STDERR, ">&LOG");
d1004 1
a1004 1
X<file, closing file descriptors> X<POSIX> X<close>
d1006 1
a1006 9
If, for some reason, you have a file descriptor instead of a
filehandle (perhaps you used C<POSIX::open>), you can use the
C<close()> function from the C<POSIX> module:

	use POSIX ();
	
	POSIX::close( $fd );
	
This should rarely be necessary, as the Perl C<close()> function is to be
d1008 1
a1008 1
numeric descriptor as with C<MHCONTEXT> above.  But if you really have
d1011 11
a1021 10
	require 'sys/syscall.ph';
	$rc = syscall(&SYS_close, $fd + 0);  # must force numeric
	die "can't sysclose $fd: $!" unless $rc == -1;

Or, just use the fdopen(3S) feature of C<open()>:

	{
	open my( $fh ), "<&=$fd" or die "Cannot reopen fd=$fd: $!";
	close $fh;
	}
d1068 2
a1069 2
	srand;
	rand($.) < 1 && ($line = $_) while <>;
d1088 1
a1088 1
	print "@@lines\n";
d1094 1
a1094 1
	little fluffy clouds
d1099 3
a1101 3
	little
	 fluffy
	 clouds
d1105 1
a1105 9
	print @@lines;

=head1 REVISION

Revision: $Revision: 10126 $

Date: $Date: 2007-10-27 21:29:20 +0200 (Sat, 27 Oct 2007) $

See L<perlfaq> for source control details and availability.
d1109 1
a1109 1
Copyright (c) 1997-2007 Tom Christiansen, Nathan Torkington, and
@


1.1.1.11
log
@import perl 5.10.1
@
text
@d3 1
a3 1
perlfaq5 - Files and Formats
d13 20
a32 1
(contributed by brian d foy)
d34 2
a35 2
You might like to read Mark Jason Dominus's "Suffering From Buffering"
at http://perl.plover.com/FAQs/Buffering.html .
d37 3
a39 11
Perl normally buffers output so it doesn't make a system call for every
bit of output. By saving up output, it makes fewer expensive system calls.
For instance, in this little bit of code, you want to print a dot to the
screen for every line you process to watch the progress of your program.
Instead of seeing a dot for every line, Perl buffers the output and you
have a long wait before you see a row of 50 dots all at once:

	# long wait, then row of dots all at once
	while( <> ) {
		print ".";
		print "\n" unless ++$count % 50;
d41 3
a43 2
		#... expensive line processing operations
		}
d45 3
a47 18
To get around this, you have to unbuffer the output filehandle, in this
case, C<STDOUT>. You can set the special variable C<$|> to a true value
(mnemonic: making your filehandles "piping hot"):

	$|++;

	# dot shown immediately
	while( <> ) {
		print ".";
		print "\n" unless ++$count % 50;

		#... expensive line processing operations
		}

The C<$|> is one of the per-filehandle special variables, so each
filehandle has its own copy of its value. If you want to merge
standard output and standard error for instance, you have to unbuffer
each (although STDERR might be unbuffered by default):
d49 1
a49 7
	{
	my $previous_default = select(STDOUT);  # save previous default
	$|++;                                   # autoflush STDOUT
	select(STDERR);
	$|++;                                   # autoflush STDERR, to be sure
	select($previous_default);              # restore previous default
	}
d51 2
a52 8
	# now should alternate . and +
	while( 1 )
		{
		sleep 1;
		print STDOUT ".";
		print STDERR "+";
		print STDOUT "\n" unless ++$count % 25;
		}
d54 1
a54 10
Besides the C<$|> special variable, you can use C<binmode> to give
your filehandle a C<:unix> layer, which is unbuffered:

	binmode( STDOUT, ":unix" );

	while( 1 ) {
		sleep 1;
		print ".";
		print "\n" unless ++$count % 50;
		}
d56 2
a57 6
For more information on output layers, see the entries for C<binmode>
and C<open> in L<perlfunc>, and the C<PerlIO> module documentation.

If you are using C<IO::Handle> or one of its subclasses, you can
call the C<autoflush> method to change the settings of the
filehandle:
d60 2
a61 7
	open my( $io_fh ), ">", "output.txt";
	$io_fh->autoflush(1);

The C<IO::Handle> objects also have a C<flush> method. You can flush
the buffer any time you want without auto-buffering

	$io_fh->flush;
d63 1
d98 1
a98 1
	print $out "# Add this line to the top\n"; # <--- HERE'S THE MAGIC
d115 1
a115 1
	print $out "# Add this line to the top\n";
d144 1
a144 1

d273 1
a273 1
X<copy> X<file, copy> X<File::Copy>
d277 1
a277 1
Use the C<File::Copy> module. It comes with Perl and can do a
d285 1
a285 1
If you can't use C<File::Copy>, you'll have to do the work yourself:
d287 1
a287 2
to the destination file as you read the original. You also have to
remember to copy the permissions, owner, and group to the new file.
d293 2
a294 2
with C<undef> in place of the file name.  In Perl 5.8 or later, the
C<open()> function creates an anonymous temporary file:
d343 1
a343 1

d527 1
a527 1
X<string> X<open> X<IO::String> X<filehandle>
d531 3
a533 3
Since Perl 5.8.0 a file handle referring to a string can be created by
calling open with a reference to that string instead of the filename.
This file handle can then be used to read from or write to the string:
d544 1
a544 1

d584 5
a588 5
Use the E<lt>E<gt> (C<glob()>) operator, documented in L<perlfunc>.
Versions of Perl older than 5.6 require that you have a shell
installed that groks tildes.  Later versions of Perl have this feature
built in. The C<File::KGlob> module (available from CPAN) gives more
portable glob functionality.
d829 6
a834 6
If you are on a system that correctly implements C<flock> and you use
the example appending code from "perldoc -f flock" everything will be
OK even if the OS you are on doesn't implement append mode correctly
(if such a system exists.) So if you are happy to restrict yourself to
OSs that implement C<flock> (and that's not really much of a
restriction) then that is what you should do.
d837 2
a838 2
implement appending (i.e. not Win32) then you can omit the C<seek>
from the code in the previous answer.
d840 8
a847 9
If you know you are only writing code to run on an OS and filesystem
that does implement append mode correctly (a local filesystem on a
modern Unix for example), and you keep the file in block-buffered mode
and you write less than one buffer-full of output between each manual
flushing of the buffer then each bufferload is almost guaranteed to be
written to the end of the file in one chunk without getting
intermingled with anyone else's output. You can also use the
C<syswrite> function which is simply a wrapper around your system's
C<write(2)> system call.
d850 4
a853 5
the system level C<write()> operation before completion. There is also
a possibility that some STDIO implementations may call multiple system
level C<write()>s even if the buffer was empty to start. There may be
some systems where this probability is reduced to zero, and this is
not a concern when using C<:perlio> instead of your system's STDIO.
d958 1
a958 1
	@@all_lines = read_file($filename); # one line per element
d1204 1
a1204 1

d1206 1
a1206 1

d1266 1
a1266 4
Short of loading the file into a database or pre-indexing the lines in
the file, there are a couple of things that you can do.

Here's a reservoir-sampling algorithm from the Camel Book:
d1275 1
a1275 1
You can use the C<File::Random> module which provides a function
d1281 1
a1281 1
Another way is to use the C<Tie::File> module, which treats the entire
d1286 1
a1286 8
(contributed by brian d foy)

If you are seeing spaces between the elements of your array when
you print the array, you are probably interpolating the array in
double quotes:

	my @@animals = qw(camel llama alpaca vicuna);
	print "animals are: @@animals\n";
d1288 1
a1288 4
It's the double quotes, not the C<print>, doing this. Whenever you
interpolate an array in a double quote context, Perl joins the
elements with spaces (or whatever is in C<$">, which is a space by
default):
d1290 3
a1292 1
	animals are: camel llama alpaca vicuna
d1294 1
a1294 1
This is different than printing the array without the interpolation:
d1296 2
a1297 2
	my @@animals = qw(camel llama alpaca vicuna);
	print "animals are: ", @@animals, "\n";
d1299 3
a1301 3
Now the output doesn't have the spaces between the elements because
the elements of C<@@animals> simply become part of the list to
C<print>:
d1303 1
a1303 13
	animals are: camelllamaalpacavicuna

You might notice this when each of the elements of C<@@array> end with
a newline. You expect to print one element per line, but notice that
every line after the first is indented:

	this is a line
	 this is another line
	 this is the third line

That extra space comes from the interpolation of the array. If you
don't want to put anything between your array elements, don't use the
array in double quotes. You can send it to print without them:
a1306 69
=head2 How do I traverse a directory tree?

(contributed by brian d foy)

The C<File::Find> module, which comes with Perl, does all of the hard
work to traverse a directory structure. It comes with Perl. You simply
call the C<find> subroutine with a callback subroutine and the
directories you want to traverse:

	use File::Find;

	find( \&wanted, @@directories );

	sub wanted {
		# full path in $File::Find::name
		# just filename in $_
		... do whatever you want to do ...
		}

The C<File::Find::Closures>, which you can download from CPAN, provides
many ready-to-use subroutines that you can use with C<File::Find>.

The C<File::Finder>, which you can download from CPAN, can help you
create the callback subroutine using something closer to the syntax of
the C<find> command-line utility:

	use File::Find;
	use File::Finder;

	my $deep_dirs = File::Finder->depth->type('d')->ls->exec('rmdir','{}');

	find( $deep_dirs->as_options, @@places );

The C<File::Find::Rule> module, which you can download from CPAN, has
a similar interface, but does the traversal for you too:

	use File::Find::Rule;

	my @@files = File::Find::Rule->file()
							 ->name( '*.pm' )
							 ->in( @@INC );

=head2 How do I delete a directory tree?

(contributed by brian d foy)

If you have an empty directory, you can use Perl's built-in C<rmdir>. If
the directory is not empty (so, no files or subdirectories), you either
have to empty it yourself (a lot of work) or use a module to help you.

The C<File::Path> module, which comes with Perl, has a C<rmtree> which
can take care of all of the hard work for you:

	use File::Path qw(rmtree);

	rmtree( \@@directories, 0, 0 );

The first argument to C<rmtree> is either a string representing a directory path
or an array reference. The second argument controls progress messages, and the
third argument controls the handling of files you don't have permissions to
delete. See the C<File::Path> module for the details.

=head2 How do I copy an entire directory?

(contributed by Shlomi Fish)

To do the equivalent of C<cp -R> (i.e. copy an entire directory tree
recursively) in portable Perl, you'll either need to write something yourself
or find a good CPAN module such as  L<File::Copy::Recursive>.
d1309 1
a1309 1
Revision: $Revision$
d1311 1
a1311 1
Date: $Date$
d1317 1
a1317 1
Copyright (c) 1997-2009 Tom Christiansen, Nathan Torkington, and
@


1.1.1.12
log
@Perl 5.12.2 from CPAN
@
text
@d199 1
a199 1
rather than processing line-by-line, you can slurp it in (as long as
d264 9
a272 41
(contributed by brian d foy)

Conceptually, the easiest way to count the lines in a file is to
simply read them and count them:

	my $count = 0;
	while( <$fh> ) { $count++; }

You don't really have to count them yourself, though, since Perl
already does that with the C<$.> variable, which is the current line
number from the last filehandle read:

	1 while( <$fh> );
	my $count = $.;

If you want to use C<$.>, you can reduce it to a simple one-liner,
like one of these:

	% perl -lne '} print $.; {'    file

	% perl -lne 'END { print $. }' file

Those can be rather inefficient though. If they aren't fast enough for
you, you might just read chunks of data and count the number of
newlines:

	my $lines = 0;
	open my($fh), '<:raw', $filename or die "Can't open $filename: $!";
	while( sysread $fh, $buffer, 4096 ) {
		$lines += ( $buffer =~ tr/\n// );
		}
	close FILE;

However, that doesn't work if the line ending isn't a newline. You
might change that C<tr///> to a C<s///> so you can count the number of
times the input record separator, C<$/>, shows up:

	my $lines = 0;
	open my($fh), '<:raw', $filename or die "Can't open $filename: $!";
	while( sysread $fh, $buffer, 4096 ) {
		$lines += ( $buffer =~ s|$/||g; );
d276 1
a276 59
If you don't mind shelling out, the C<wc> command is usually the
fastest, even with the extra interprocess overhead. Ensure that you
have an untainted filename though:

	#!perl -T

	$ENV{PATH} = undef;

	my $lines;
	if( $filename =~ /^([0-9a-z_.]+)\z/ ) {
		$lines = `/usr/bin/wc -l $1`
		chomp $lines;
		}

=head2 How do I delete the last N lines from a file?
X<lines> X<file>

(contributed by brian d foy)

The easiest conceptual solution is to count the lines in the
file then start at the beginning and print the number of lines
(minus the last N) to a new file.

Most often, the real question is how you can delete the last N lines
without making more than one pass over the file, or how to do it
without a lot of copying. The easy concept is the hard reality when
you might have millions of lines in your file.

One trick is to use C<File::ReadBackwards>, which starts at the end of
the file. That module provides an object that wraps the real filehandle
to make it easy for you to move around the file. Once you get to the
spot you need, you can get the actual filehandle and work with it as
normal. In this case, you get the file position at the end of the last
line you want to keep and truncate the file to that point:

	use File::ReadBackwards;

	my $filename = 'test.txt';
	my $Lines_to_truncate = 2;

	my $bw = File::ReadBackwards->new( $filename )
		or die "Could not read backwards in [$filename]: $!";

	my $lines_from_end = 0;
	until( $bw->eof or $lines_from_end == $Lines_to_truncate )
		{
		print "Got: ", $bw->readline;
		$lines_from_end++;
		}

	truncate( $filename, $bw->tell );

The C<File::ReadBackwards> module also has the advantage of setting
the input record separator to a regular expression.

You can also use the C<Tie::File> module which lets you access
the lines through a tied array. You can use normal array operations
to modify your file, including setting the last index and using
C<splice>.
d282 1
a282 1
the behavior of C<< <> >>; see L<perlrun> for more details. By
d284 1
a284 1
behavior within a larger program. For example:
d326 1
a326 1
with C<undef> in place of the file name. In Perl 5.8 or later, the
d335 1
a335 1
	my $dir = tempdir( CLEANUP => 1 );
d340 1
a340 1
	my $fh = tempfile( DIR => $dir );
d342 1
a342 1
The File::Temp has been a standard module since Perl 5.6.1. If you
d345 1
a345 1
reading and writing. Use it if you don't need to know the file's name:
d348 2
a349 2
	my $fh = IO::File->new_tmpfile()
		or die "Unable to make new temporary file: $!";
d352 1
a352 1
process ID and/or the current time-value. If you need to have many
d366 1
a366 1
			sysopen my($fh), $base_name, O_WRONLY|O_EXCL|O_CREAT;
d369 2
a370 2
		if( defined fileno($fh) ) {
			return ($fh, $base_name);
d383 2
a384 2
L<unpack()|perlfunc/"unpack">. This is faster than using
L<substr()|perlfunc/"substr"> when taking many, many strings. It is
d456 1
a456 1
in a place that a filehandle is expected. Here are ways
d470 1
a470 1
	my $fh = IO::Handle->new();
d472 1
a472 1
Then use any of those as you would a normal filehandle. Anywhere that
d475 1
a475 1
a filehandle. Functions like C<print>, C<open>, C<seek>, or
d481 1
a481 1
	my $got = <$ifh>
d507 1
a507 1
before using it. That is because only simple scalar variables, not
d509 1
a509 1
built-ins like C<print>, C<printf>, or the diamond operator. Using
d513 1
a513 1
	my @@fd = (*STDIN, *STDOUT, *STDERR);
d515 1
a515 1
	my $got = <$fd[0]>                                  # WRONG
d526 1
a526 1
complicated code there. This sends the message out to one of two places:
d528 1
a528 1
	my $ok = -x "/bin/cat";
d533 2
a534 2
calls doesn't work for the diamond operator. That's because it's a
real operator, not just a function with a comma-less argument. Assuming
d537 2
a538 2
as C<< <> >> does. Given the initialization shown above for @@fd, this
would work, but only because readline() requires a typeglob. It doesn't
d545 1
a545 1
It's the syntax of the fundamental operators. Playing the object
d619 1
a619 1
installed that groks tildes. Later versions of Perl have this feature
d643 1
a643 1
	open my $fh, '+>', '/path/name'; # WRONG (almost always)
d645 1
a645 1
Whoops. You should instead use this, which will fail if the file
d648 1
a648 1
	open my $fh, '+<', '/path/name'; # open for update
d650 2
a651 2
Using ">" always clobbers or creates. Using "<" never does
either. The "+" doesn't change this.
d653 1
a653 1
Here are examples of many kinds of file opens. Those using sysopen()
d660 2
a661 2
	open my $fh, '<', $path                                 or die $!;
	sysopen my $fh, $path, O_RDONLY                         or die $!;
d665 3
a667 3
	open my $fh, '>', $path                                 or die $!;
	sysopen my $fh, $path, O_WRONLY|O_TRUNC|O_CREAT         or die $!;
	sysopen my $fh, $path, O_WRONLY|O_TRUNC|O_CREAT, 0666   or die $!;
d671 2
a672 2
	sysopen my $fh, $path, O_WRONLY|O_EXCL|O_CREAT          or die $!;
	sysopen my $fh, $path, O_WRONLY|O_EXCL|O_CREAT, 0666    or die $!;
d676 3
a678 3
	open my $fh, '>>' $path                                 or die $!;
	sysopen my $fh, $path, O_WRONLY|O_APPEND|O_CREAT        or die $!;
	sysopen my $fh, $path, O_WRONLY|O_APPEND|O_CREAT, 0666  or die $!;
d682 1
a682 1
	sysopen my $fh, $path, O_WRONLY|O_APPEND                or die $!;
d686 2
a687 2
	open my $fh, '+<', $path                                or die $!;
	sysopen my $fh, $path, O_RDWR                           or die $!;
d691 2
a692 2
	sysopen my $fh, $path, O_RDWR|O_CREAT                   or die $!;
	sysopen my $fh, $path, O_RDWR|O_CREAT, 0666             or die $!;
d696 2
a697 2
	sysopen my $fh, $path, O_RDWR|O_EXCL|O_CREAT            or die $!;
	sysopen my $fh, $path, O_RDWR|O_EXCL|O_CREAT, 0666      or die $!;
d701 1
a701 1
	sysopen my $fh, '/foo/somefile', O_WRONLY|O_NDELAY|O_CREAT
d705 2
a706 2
be an atomic operation over NFS. That is, two processes might both
successfully create or unlink the same file! Therefore O_EXCL
d709 1
a709 1
See also the new L<perlopentut>.
d718 1
a718 1
C<Argument list too long>. People who installed tcsh as csh won't
d728 4
a731 5
(contributed by brian d foy)

Starting with Perl 5.6.0, C<glob> is implemented internally rather
than relying on an external resource. As such, memory issues with
C<glob> aren't a problem in modern perls.
d747 2
a748 2
	open my $fh, "<", "  file  ";  # filename is "   file   "
	open my $fh, ">", ">file";     # filename is ">file"
d751 1
a751 1
X<rename> X<mv> X<move> X<file, rename>
d758 1
a758 1
It may be more portable to use the C<File::Copy> module instead.
d760 2
a761 2
values), then delete the old one. This isn't really the same
semantically as a C<rename()>, which preserves meta-information like
d764 2
d791 1
a791 1
But even this is dubious at best. See the flock entry of L<perlfunc>
d797 3
a799 3
I<merely advisory>. Such discretionary locks are more flexible, but
offer fewer guarantees. This means that files locked with flock() may
be modified by programs that do not also use flock(). Cars that stop
d801 2
a802 2
stop for red lights. See the perlport manpage, your port's specific
documentation, or your system-specific local manpages for details. It's
d819 2
a820 2
	sleep(3) while -e 'file.lock';	# PLEASE DO NOT USE
	open my $lock, '>', 'file.lock'; # THIS BROKEN CODE
d823 2
a824 2
which must be done in one. That's why computer hardware provides an
atomic test-and-set instruction. In theory, this "ought" to work:
d826 1
a826 1
	sysopen my $fh, "file.lock", O_WRONLY|O_EXCL|O_CREAT
d834 1
a834 1
=head2 I still don't get locking. I just want to increment the number in the file. How can I do this?
d839 1
a839 1
only to stroke the writer's vanity. It's better to pick a random number;
d845 7
a851 7
	sysopen my $fh, "numfile", O_RDWR|O_CREAT or die "can't open numfile: $!";
	flock $fh, LOCK_EX                        or die "can't flock numfile: $!";
	my $num = <$fh> || 0;
	seek $fh, 0, 0                            or die "can't rewind numfile: $!";
	truncate $fh, 0                           or die "can't truncate numfile: $!";
	(print $fh $num+1, "\n")                  or die "can't write numfile: $!";
	close $fh                                 or die "can't close numfile: $!";
d857 1
a857 1
If the count doesn't impress your friends, then the code might. :-)
d859 1
a859 1
=head2 All I want to do is append a small amount of text to the end of a file. Do I still have to use locking?
d903 3
a905 3
	open my $fh, '+<', 'somewhere' or die "can't update somewhere: $!";
	seek $fh, $recno * $RECSIZE, 0;
	read $fh, $record, $RECSIZE == $RECSIZE or die "can't read record $recno: $!";
d907 3
a909 3
	seek $fh, -$RECSIZE, 1;
	print $fh $record;
	close $fh;
d917 11
a927 9
If you want to retrieve the time at which the file was last read,
written, or had its meta-data (owner, etc) changed, you use the B<-A>,
B<-M>, or B<-C> file test operations as documented in L<perlfunc>.
These retrieve the age of the file (measured against the start-time of
your program) in days as a floating point number. Some platforms may
not have all of these times. See L<perlport> for details. To retrieve
the "raw" time in seconds since the epoch, you would call the stat
function, then use C<localtime()>, C<gmtime()>, or
C<POSIX::strftime()> to convert this into human-readable form.
d931 1
a931 1
	my $write_secs = (stat($file))[9];
d941 1
a941 1
	my $date_string = ctime(stat($file)->mtime);
d945 1
a945 1
in theory, independent of the current locale. See L<perllocale>
d959 2
a960 2
	my $timestamp = shift;
	my($atime, $mtime) = (stat($timestamp))[8,9];
d969 1
a969 1
on a file at the expected level of precision. For example, the
d971 1
a971 1
a finer granularity than two seconds. This is a limitation of
d983 1
a983 1
	for my $fh (FH1, FH2, FH3) { print $fh "whatever\n" }
d988 1
a988 14
Are you sure you want to read the entire file and store it in memory?
If you mmap the file, you can virtually load the entire file into a
string without actually storing it in memory:

	use File::Map qw(map_file);

	map_file my $string, $filename;

Once mapped, you can treat C<$string> as you would any other string.
Since you don't actually load the data, mmap-ing is very fast and does
not increase your memory footprint.

If you really want to load the entire file, you can use the
C<File::Slurp> module to do it in one step.
d992 2
a993 2
	my $all_of_it = read_file($filename); # entire file in scalar
	my @@all_lines = read_file($filename); # one line per element
d998 2
a999 2
	open my $input, '<', $file or die "can't open $file: $!";
	while (<$input>) {
d1003 1
a1003 1
	close $input or die "can't close $file: $!";
d1007 1
a1007 1
which is often--if not almost always--the wrong approach. Whenever
d1010 1
a1010 1
	my @@lines = <INPUT>;
d1012 2
a1013 2
You should think long and hard about why you need everything loaded at
once. It's just not a scalable solution. You might also find it more
d1022 3
a1024 3
	local $/;
	open my $fh, '<', $file or die "can't open $file: $!";
	$var = <$fh>;
d1028 1
a1028 1
close the file at block exit. If the file is already open, just use this:
d1030 1
a1030 1
	$var = do { local $/; <$fh> };
d1034 1
a1034 1
	read( $fh, $var, -s $fh );
d1042 1
a1042 1
Use the C<$/> variable (see L<perlvar> for details). You can either
d1047 1
a1047 1
Note that a blank line must have no blanks in it. Thus
d1054 1
a1054 1
it won't (easily) work on a terminal device. For STDIN, either use
d1066 1
d1068 1
a1068 1
		my $got = getone();
d1078 1
a1078 1
	my $fd_stdin = fileno(STDIN);
d1111 1
a1111 1
The Term::ReadKey module from CPAN may be easier to use. Recent versions
d1115 1
a1115 1
	open my $tty, '<', '/dev/tty';
d1118 1
a1118 1
	my $key = ReadKey 0, $tty;
d1126 1
a1126 1
extension from CPAN. As we mentioned earlier, it now even has limited
d1128 1
a1128 1
not POSIX, not Unix, etc.) systems.
d1132 1
a1132 1
It's very system dependent. Here's one solution that works on BSD
d1142 1
a1142 1
also the FIONREAD ioctl call to be looked at. The I<h2ph> tool that
d1144 1
a1144 1
can be C<require>d. FIONREAD ends up defined as a function in the
d1214 1
a1214 1
to call open() should do the trick. For example:
d1216 2
a1217 2
	open my $log, '>>', '/foo/logfile';
	open STDERR, '>&LOG';
d1221 2
a1222 2
	my $fd = $ENV{MHCONTEXTFD};
	open $mhcontext, "<&=$fd";  # like fdopen(3S)
d1225 2
a1226 2
an alias. That means if you close an aliased handle, all
aliases become inaccessible. This is not true with
d1244 1
a1244 1
numeric descriptor as with C<MHCONTEXT> above. But if you really have
d1248 1
a1248 1
	my $rc = syscall(&SYS_close, $fd + 0);  # must force numeric
d1263 2
a1264 2
backslash is an escape character. The full list of these is in
L<perlop/Quote and Quote-like Operators>. Unsurprisingly, you don't
d1272 1
a1272 1
awk, Tcl, Java, or Python, just to mention a few. POSIX paths
d1279 3
a1281 3
Unix globbing semantics. You'll need C<glob("*")> to get all (non-hidden)
files. This makes glob() portable even to legacy systems. Your
port may include proprietary globbing functions as well. Check its
d1290 1
a1290 1
The executive summary: learn how your filesystem works. The
d1293 1
a1293 1
files in that directory. If you delete a file, you're removing its
d1295 1
a1295 1
of the directory, not of the file). If you try to write to the file,
d1310 1
a1310 1
in. You can find a proof of this method in I<The Art of Computer
d1320 1
a1320 1
file as an array. Simply access a random array element.
d1411 3
a1413 4
If you have an empty directory, you can use Perl's built-in C<rmdir>.
If the directory is not empty (so, no files or subdirectories), you
either have to empty it yourself (a lot of work) or use a module to
help you.
d1415 2
a1416 2
The C<File::Path> module, which comes with Perl, has a C<remove_tree>
which can take care of all of the hard work for you:
d1418 1
a1418 1
	use File::Path qw(remove_tree);
d1420 1
a1420 1
	remove_tree( @@directories );
d1422 4
a1425 2
The C<File::Path> module also has a legacy interface to the older
C<rmtree> subroutine.
d1434 7
d1444 1
a1444 1
Copyright (c) 1997-2010 Tom Christiansen, Nathan Torkington, and
d1451 1
a1451 1
domain. You are permitted and encouraged to use this code and any
d1453 1
a1453 1
see fit. A simple comment in the code giving credit to the FAQ would
@


