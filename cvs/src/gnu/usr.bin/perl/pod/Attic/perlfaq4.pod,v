head	1.13;
access;
symbols
	OPENBSD_5_3:1.12.0.10
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.8
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.6
	OPENBSD_5_0:1.12.0.4
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	PERL_5_12_2:1.1.1.12
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	PERL_5_10_1:1.1.1.11
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	PERL_5_10_0:1.1.1.10
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	PERL_5_8_8:1.1.1.9
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	PERL_5_8_6:1.1.1.8
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.13
date	2013.03.25.20.40.58;	author sthen;	state dead;
branches;
next	1.12;

1.12
date	2010.09.24.15.07.03;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.12.18.24.47;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.29.17.36.16;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.28.19.23.10;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2005.01.15.21.30.36;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2004.04.07.21.33.08;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.03.03.02.44;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.33;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.24.18.35.54;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.07.26;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.04.29.22.52.11;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.11.30.07.59.09;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.40.42;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.10.23;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.24.35;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.04;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.44.21;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.04.07.21.13.32;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.48.08;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2005.01.15.21.17.52;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2006.03.28.18.49.18;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2008.09.29.17.18.51;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2009.10.12.18.10.38;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2010.09.24.14.49.10;	author millert;	state Exp;
branches;
next	;


desc
@perl 5.004_04
@


1.13
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@=head1 NAME

perlfaq4 - Data Manipulation

=head1 DESCRIPTION

This section of the FAQ answers questions related to manipulating
numbers, dates, strings, arrays, hashes, and miscellaneous data issues.

=head1 Data: Numbers

=head2 Why am I getting long decimals (eg, 19.9499999999999) instead of the numbers I should be getting (eg, 19.95)?

For the long explanation, see David Goldberg's "What Every Computer
Scientist Should Know About Floating-Point Arithmetic"
(http://docs.sun.com/source/806-3568/ncg_goldberg.html).

Internally, your computer represents floating-point numbers in binary.
Digital (as in powers of two) computers cannot store all numbers
exactly.  Some real numbers lose precision in the process.  This is a
problem with how computers store numbers and affects all computer
languages, not just Perl.

L<perlnumber> shows the gory details of number representations and
conversions.

To limit the number of decimal places in your numbers, you can use the
C<printf> or C<sprintf> function.  See the L<"Floating Point
Arithmetic"|perlop> for more details.

	printf "%.2f", 10/3;

	my $number = sprintf "%.2f", 10/3;

=head2 Why is int() broken?

Your C<int()> is most probably working just fine.  It's the numbers that
aren't quite what you think.

First, see the answer to "Why am I getting long decimals
(eg, 19.9499999999999) instead of the numbers I should be getting
(eg, 19.95)?".

For example, this

	print int(0.6/0.2-2), "\n";

will in most computers print 0, not 1, because even such simple
numbers as 0.6 and 0.2 cannot be presented exactly by floating-point
numbers.  What you think in the above as 'three' is really more like
2.9999999999999995559.

=head2 Why isn't my octal data interpreted correctly?

(contributed by brian d foy)

You're probably trying to convert a string to a number, which Perl only
converts as a decimal number. When Perl converts a string to a number, it
ignores leading spaces and zeroes, then assumes the rest of the digits
are in base 10:

	my $string = '0644';

	print $string + 0;  # prints 644

	print $string + 44; # prints 688, certainly not octal!

This problem usually involves one of the Perl built-ins that has the
same name a Unix command that uses octal numbers as arguments on the
command line. In this example, C<chmod> on the command line knows that
its first argument is octal because that's what it does:

	%prompt> chmod 644 file

If you want to use the same literal digits (644) in Perl, you have to tell
Perl to treat them as octal numbers either by prefixing the digits with
a C<0> or using C<oct>:

	chmod(     0644, $file);   # right, has leading zero
	chmod( oct(644), $file );  # also correct

The problem comes in when you take your numbers from something that Perl
thinks is a string, such as a command line argument in C<@@ARGV>:

	chmod( $ARGV[0],      $file);   # wrong, even if "0644"

	chmod( oct($ARGV[0]), $file );  # correct, treat string as octal

You can always check the value you're using by printing it in octal
notation to ensure it matches what you think it should be. Print it
in octal  and decimal format:

	printf "0%o %d", $number, $number;

=head2 Does Perl have a round() function?  What about ceil() and floor()?  Trig functions?

Remember that C<int()> merely truncates toward 0.  For rounding to a
certain number of digits, C<sprintf()> or C<printf()> is usually the
easiest route.

	printf("%.3f", 3.1415926535);   # prints 3.142

The C<POSIX> module (part of the standard Perl distribution)
implements C<ceil()>, C<floor()>, and a number of other mathematical
and trigonometric functions.

	use POSIX;
	$ceil   = ceil(3.5);   # 4
	$floor  = floor(3.5);  # 3

In 5.000 to 5.003 perls, trigonometry was done in the C<Math::Complex>
module.  With 5.004, the C<Math::Trig> module (part of the standard Perl
distribution) implements the trigonometric functions. Internally it
uses the C<Math::Complex> module and some functions can break out from
the real axis into the complex plane, for example the inverse sine of
2.

Rounding in financial applications can have serious implications, and
the rounding method used should be specified precisely.  In these
cases, it probably pays not to trust whichever system rounding is
being used by Perl, but to instead implement the rounding function you
need yourself.

To see why, notice how you'll still have an issue on half-way-point
alternation:

	for ($i = 0; $i < 1.01; $i += 0.05) { printf "%.1f ",$i}

	0.0 0.1 0.1 0.2 0.2 0.2 0.3 0.3 0.4 0.4 0.5 0.5 0.6 0.7 0.7
	0.8 0.8 0.9 0.9 1.0 1.0

Don't blame Perl.  It's the same as in C.  IEEE says we have to do
this. Perl numbers whose absolute values are integers under 2**31 (on
32 bit machines) will work pretty much like mathematical integers.
Other numbers are not guaranteed.

=head2 How do I convert between numeric representations/bases/radixes?

As always with Perl there is more than one way to do it.  Below are a
few examples of approaches to making common conversions between number
representations.  This is intended to be representational rather than
exhaustive.

Some of the examples later in L<perlfaq4> use the C<Bit::Vector>
module from CPAN. The reason you might choose C<Bit::Vector> over the
perl built in functions is that it works with numbers of ANY size,
that it is optimized for speed on some operations, and for at least
some programmers the notation might be familiar.

=over 4

=item How do I convert hexadecimal into decimal

Using perl's built in conversion of C<0x> notation:

	$dec = 0xDEADBEEF;

Using the C<hex> function:

	$dec = hex("DEADBEEF");

Using C<pack>:

	$dec = unpack("N", pack("H8", substr("0" x 8 . "DEADBEEF", -8)));

Using the CPAN module C<Bit::Vector>:

	use Bit::Vector;
	$vec = Bit::Vector->new_Hex(32, "DEADBEEF");
	$dec = $vec->to_Dec();

=item How do I convert from decimal to hexadecimal

Using C<sprintf>:

	$hex = sprintf("%X", 3735928559); # upper case A-F
	$hex = sprintf("%x", 3735928559); # lower case a-f

Using C<unpack>:

	$hex = unpack("H*", pack("N", 3735928559));

Using C<Bit::Vector>:

	use Bit::Vector;
	$vec = Bit::Vector->new_Dec(32, -559038737);
	$hex = $vec->to_Hex();

And C<Bit::Vector> supports odd bit counts:

	use Bit::Vector;
	$vec = Bit::Vector->new_Dec(33, 3735928559);
	$vec->Resize(32); # suppress leading 0 if unwanted
	$hex = $vec->to_Hex();

=item How do I convert from octal to decimal

Using Perl's built in conversion of numbers with leading zeros:

	$dec = 033653337357; # note the leading 0!

Using the C<oct> function:

	$dec = oct("33653337357");

Using C<Bit::Vector>:

	use Bit::Vector;
	$vec = Bit::Vector->new(32);
	$vec->Chunk_List_Store(3, split(//, reverse "33653337357"));
	$dec = $vec->to_Dec();

=item How do I convert from decimal to octal

Using C<sprintf>:

	$oct = sprintf("%o", 3735928559);

Using C<Bit::Vector>:

	use Bit::Vector;
	$vec = Bit::Vector->new_Dec(32, -559038737);
	$oct = reverse join('', $vec->Chunk_List_Read(3));

=item How do I convert from binary to decimal

Perl 5.6 lets you write binary numbers directly with
the C<0b> notation:

	$number = 0b10110110;

Using C<oct>:

	my $input = "10110110";
	$decimal = oct( "0b$input" );

Using C<pack> and C<ord>:

	$decimal = ord(pack('B8', '10110110'));

Using C<pack> and C<unpack> for larger strings:

	$int = unpack("N", pack("B32",
	substr("0" x 32 . "11110101011011011111011101111", -32)));
	$dec = sprintf("%d", $int);

	# substr() is used to left pad a 32 character string with zeros.

Using C<Bit::Vector>:

	$vec = Bit::Vector->new_Bin(32, "11011110101011011011111011101111");
	$dec = $vec->to_Dec();

=item How do I convert from decimal to binary

Using C<sprintf> (perl 5.6+):

	$bin = sprintf("%b", 3735928559);

Using C<unpack>:

	$bin = unpack("B*", pack("N", 3735928559));

Using C<Bit::Vector>:

	use Bit::Vector;
	$vec = Bit::Vector->new_Dec(32, -559038737);
	$bin = $vec->to_Bin();

The remaining transformations (e.g. hex -> oct, bin -> hex, etc.)
are left as an exercise to the inclined reader.

=back

=head2 Why doesn't & work the way I want it to?

The behavior of binary arithmetic operators depends on whether they're
used on numbers or strings.  The operators treat a string as a series
of bits and work with that (the string C<"3"> is the bit pattern
C<00110011>).  The operators work with the binary form of a number
(the number C<3> is treated as the bit pattern C<00000011>).

So, saying C<11 & 3> performs the "and" operation on numbers (yielding
C<3>).  Saying C<"11" & "3"> performs the "and" operation on strings
(yielding C<"1">).

Most problems with C<&> and C<|> arise because the programmer thinks
they have a number but really it's a string.  The rest arise because
the programmer says:

	if ("\020\020" & "\101\101") {
		# ...
		}

but a string consisting of two null bytes (the result of C<"\020\020"
& "\101\101">) is not a false value in Perl.  You need:

	if ( ("\020\020" & "\101\101") !~ /[^\000]/) {
		# ...
		}

=head2 How do I multiply matrices?

Use the C<Math::Matrix> or C<Math::MatrixReal> modules (available from CPAN)
or the C<PDL> extension (also available from CPAN).

=head2 How do I perform an operation on a series of integers?

To call a function on each element in an array, and collect the
results, use:

	@@results = map { my_func($_) } @@array;

For example:

	@@triple = map { 3 * $_ } @@single;

To call a function on each element of an array, but ignore the
results:

	foreach $iterator (@@array) {
		some_func($iterator);
		}

To call a function on each integer in a (small) range, you B<can> use:

	@@results = map { some_func($_) } (5 .. 25);

but you should be aware that the C<..> operator creates an array of
all integers in the range.  This can take a lot of memory for large
ranges.  Instead use:

	@@results = ();
	for ($i=5; $i < 500_005; $i++) {
		push(@@results, some_func($i));
		}

This situation has been fixed in Perl5.005. Use of C<..> in a C<for>
loop will iterate over the range, without creating the entire range.

	for my $i (5 .. 500_005) {
		push(@@results, some_func($i));
		}

will not create a list of 500,000 integers.

=head2 How can I output Roman numerals?

Get the L<http://www.cpan.org/modules/by-module/Roman> module.

=head2 Why aren't my random numbers random?

If you're using a version of Perl before 5.004, you must call C<srand>
once at the start of your program to seed the random number generator.

	 BEGIN { srand() if $] < 5.004 }

5.004 and later automatically call C<srand> at the beginning.  Don't
call C<srand> more than once--you make your numbers less random,
rather than more.

Computers are good at being predictable and bad at being random
(despite appearances caused by bugs in your programs :-).  see the
F<random> article in the "Far More Than You Ever Wanted To Know"
collection in L<http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz>, courtesy
of Tom Phoenix, talks more about this.  John von Neumann said, "Anyone
who attempts to generate random numbers by deterministic means is, of
course, living in a state of sin."

If you want numbers that are more random than C<rand> with C<srand>
provides, you should also check out the C<Math::TrulyRandom> module from
CPAN.  It uses the imperfections in your system's timer to generate
random numbers, but this takes quite a while.  If you want a better
pseudorandom generator than comes with your operating system, look at
"Numerical Recipes in C" at L<http://www.nr.com/>.

=head2 How do I get a random number between X and Y?

To get a random number between two values, you can use the C<rand()>
built-in to get a random number between 0 and 1. From there, you shift
that into the range that you want.

C<rand($x)> returns a number such that C<< 0 <= rand($x) < $x >>. Thus
what you want to have perl figure out is a random number in the range
from 0 to the difference between your I<X> and I<Y>.

That is, to get a number between 10 and 15, inclusive, you want a
random number between 0 and 5 that you can then add to 10.

	my $number = 10 + int rand( 15-10+1 ); # ( 10,11,12,13,14, or 15 )

Hence you derive the following simple function to abstract
that. It selects a random integer between the two given
integers (inclusive), For example: C<random_int_between(50,120)>.

	sub random_int_between {
		my($min, $max) = @@_;
		# Assumes that the two arguments are integers themselves!
		return $min if $min == $max;
		($min, $max) = ($max, $min)  if  $min > $max;
		return $min + int rand(1 + $max - $min);
		}

=head1 Data: Dates

=head2 How do I find the day or week of the year?

The C<localtime> function returns the day of the year.  Without an
argument C<localtime> uses the current time.

	$day_of_year = (localtime)[7];

The C<POSIX> module can also format a date as the day of the year or
week of the year.

	use POSIX qw/strftime/;
	my $day_of_year  = strftime "%j", localtime;
	my $week_of_year = strftime "%W", localtime;

To get the day of year for any date, use C<POSIX>'s C<mktime> to get
a time in epoch seconds for the argument to C<localtime>.

	use POSIX qw/mktime strftime/;
	my $week_of_year = strftime "%W",
		localtime( mktime( 0, 0, 0, 18, 11, 87 ) );

The C<Date::Calc> module provides two functions to calculate these.

	use Date::Calc;
	my $day_of_year  = Day_of_Year(  1987, 12, 18 );
	my $week_of_year = Week_of_Year( 1987, 12, 18 );

=head2 How do I find the current century or millennium?

Use the following simple functions:

	sub get_century    {
		return int((((localtime(shift || time))[5] + 1999))/100);
		}

	sub get_millennium {
		return 1+int((((localtime(shift || time))[5] + 1899))/1000);
		}

On some systems, the C<POSIX> module's C<strftime()> function has been
extended in a non-standard way to use a C<%C> format, which they
sometimes claim is the "century". It isn't, because on most such
systems, this is only the first two digits of the four-digit year, and
thus cannot be used to reliably determine the current century or
millennium.

=head2 How can I compare two dates and find the difference?

(contributed by brian d foy)

You could just store all your dates as a number and then subtract.
Life isn't always that simple though. If you want to work with
formatted dates, the C<Date::Manip>, C<Date::Calc>, or C<DateTime>
modules can help you.

=head2 How can I take a string and turn it into epoch seconds?

If it's a regular enough string that it always has the same format,
you can split it up and pass the parts to C<timelocal> in the standard
C<Time::Local> module.  Otherwise, you should look into the C<Date::Calc>
and C<Date::Manip> modules from CPAN.

=head2 How can I find the Julian Day?

(contributed by brian d foy and Dave Cross)

You can use the C<Time::JulianDay> module available on CPAN.  Ensure
that you really want to find a Julian day, though, as many people have
different ideas about Julian days.  See
http://www.hermetic.ch/cal_stud/jdn.htm for instance.

You can also try the C<DateTime> module, which can convert a date/time
to a Julian Day.

	$ perl -MDateTime -le'print DateTime->today->jd'
	2453401.5

Or the modified Julian Day

	$ perl -MDateTime -le'print DateTime->today->mjd'
	53401

Or even the day of the year (which is what some people think of as a
Julian day)

	$ perl -MDateTime -le'print DateTime->today->doy'
	31

=head2 How do I find yesterday's date?
X<date> X<yesterday> X<DateTime> X<Date::Calc> X<Time::Local>
X<daylight saving time> X<day> X<Today_and_Now> X<localtime>
X<timelocal>

(contributed by brian d foy)

Use one of the Date modules. The C<DateTime> module makes it simple, and
give you the same time of day, only the day before.

	use DateTime;

	my $yesterday = DateTime->now->subtract( days => 1 );

	print "Yesterday was $yesterday\n";

You can also use the C<Date::Calc> module using its C<Today_and_Now>
function.

	use Date::Calc qw( Today_and_Now Add_Delta_DHMS );

	my @@date_time = Add_Delta_DHMS( Today_and_Now(), -1, 0, 0, 0 );

	print "@@date_time\n";

Most people try to use the time rather than the calendar to figure out
dates, but that assumes that days are twenty-four hours each.  For
most people, there are two days a year when they aren't: the switch to
and from summer time throws this off. Let the modules do the work.

If you absolutely must do it yourself (or can't use one of the
modules), here's a solution using C<Time::Local>, which comes with
Perl:

	# contributed by Gunnar Hjalmarsson
	 use Time::Local;
	 my $today = timelocal 0, 0, 12, ( localtime )[3..5];
	 my ($d, $m, $y) = ( localtime $today-86400 )[3..5];
	 printf "Yesterday: %d-%02d-%02d\n", $y+1900, $m+1, $d;

In this case, you measure the day starting at noon, and subtract 24
hours. Even if the length of the calendar day is 23 or 25 hours,
you'll still end up on the previous calendar day, although not at
noon. Since you don't care about the time, the one hour difference
doesn't matter and you end up with the previous date.

=head2 Does Perl have a Year 2000 or 2038 problem? Is Perl Y2K compliant?

(contributed by brian d foy)

Perl itself never had a Y2K problem, although that never stopped people
from creating Y2K problems on their own. See the documentation for
C<localtime> for its proper use.

Starting with Perl 5.11, C<localtime> and C<gmtime> can handle dates past
03:14:08 January 19, 2038, when a 32-bit based time would overflow. You
still might get a warning on a 32-bit C<perl>:

	% perl5.11.2 -E 'say scalar localtime( 0x9FFF_FFFFFFFF )'
	Integer overflow in hexadecimal number at -e line 1.
	Wed Nov  1 19:42:39 5576711

On a 64-bit C<perl>, you can get even larger dates for those really long
running projects:

	% perl5.11.2 -E 'say scalar gmtime( 0x9FFF_FFFFFFFF )'
	Thu Nov  2 00:42:39 5576711

You're still out of luck if you need to keep tracking of decaying protons
though.

=head1 Data: Strings

=head2 How do I validate input?

(contributed by brian d foy)

There are many ways to ensure that values are what you expect or
want to accept. Besides the specific examples that we cover in the
perlfaq, you can also look at the modules with "Assert" and "Validate"
in their names, along with other modules such as C<Regexp::Common>.

Some modules have validation for particular types of input, such
as C<Business::ISBN>, C<Business::CreditCard>, C<Email::Valid>,
and C<Data::Validate::IP>.

=head2 How do I unescape a string?

It depends just what you mean by "escape".  URL escapes are dealt
with in L<perlfaq9>.  Shell escapes with the backslash (C<\>)
character are removed with

	s/\\(.)/$1/g;

This won't expand C<"\n"> or C<"\t"> or any other special escapes.

=head2 How do I remove consecutive pairs of characters?

(contributed by brian d foy)

You can use the substitution operator to find pairs of characters (or
runs of characters) and replace them with a single instance. In this
substitution, we find a character in C<(.)>. The memory parentheses
store the matched character in the back-reference C<\1> and we use
that to require that the same thing immediately follow it. We replace
that part of the string with the character in C<$1>.

	s/(.)\1/$1/g;

We can also use the transliteration operator, C<tr///>. In this
example, the search list side of our C<tr///> contains nothing, but
the C<c> option complements that so it contains everything. The
replacement list also contains nothing, so the transliteration is
almost a no-op since it won't do any replacements (or more exactly,
replace the character with itself). However, the C<s> option squashes
duplicated and consecutive characters in the string so a character
does not show up next to itself

	my $str = 'Haarlem';   # in the Netherlands
	$str =~ tr///cs;       # Now Harlem, like in New York

=head2 How do I expand function calls in a string?

(contributed by brian d foy)

This is documented in L<perlref>, and although it's not the easiest
thing to read, it does work. In each of these examples, we call the
function inside the braces used to dereference a reference. If we
have more than one return value, we can construct and dereference an
anonymous array. In this case, we call the function in list context.

	print "The time values are @@{ [localtime] }.\n";

If we want to call the function in scalar context, we have to do a bit
more work. We can really have any code we like inside the braces, so
we simply have to end with the scalar reference, although how you do
that is up to you, and you can use code inside the braces. Note that
the use of parens creates a list context, so we need C<scalar> to
force the scalar context on the function:

	print "The time is ${\(scalar localtime)}.\n"

	print "The time is ${ my $x = localtime; \$x }.\n";

If your function already returns a reference, you don't need to create
the reference yourself.

	sub timestamp { my $t = localtime; \$t }

	print "The time is ${ timestamp() }.\n";

The C<Interpolation> module can also do a lot of magic for you. You can
specify a variable name, in this case C<E>, to set up a tied hash that
does the interpolation for you. It has several other methods to do this
as well.

	use Interpolation E => 'eval';
	print "The time values are $E{localtime()}.\n";

In most cases, it is probably easier to simply use string concatenation,
which also forces scalar context.

	print "The time is " . localtime() . ".\n";

=head2 How do I find matching/nesting anything?

This isn't something that can be done in one regular expression, no
matter how complicated.  To find something between two single
characters, a pattern like C</x([^x]*)x/> will get the intervening
bits in $1. For multiple ones, then something more like
C</alpha(.*?)omega/> would be needed. But none of these deals with
nested patterns.  For balanced expressions using C<(>, C<{>, C<[> or
C<< < >> as delimiters, use the CPAN module Regexp::Common, or see
L<perlre/(??{ code })>.  For other cases, you'll have to write a
parser.

If you are serious about writing a parser, there are a number of
modules or oddities that will make your life a lot easier.  There are
the CPAN modules C<Parse::RecDescent>, C<Parse::Yapp>, and
C<Text::Balanced>; and the C<byacc> program. Starting from perl 5.8
the C<Text::Balanced> is part of the standard distribution.

One simple destructive, inside-out approach that you might try is to
pull out the smallest nesting parts one at a time:

	while (s/BEGIN((?:(?!BEGIN)(?!END).)*)END//gs) {
		# do something with $1
		}

A more complicated and sneaky approach is to make Perl's regular
expression engine do it for you.  This is courtesy Dean Inada, and
rather has the nature of an Obfuscated Perl Contest entry, but it
really does work:

	# $_ contains the string to parse
	# BEGIN and END are the opening and closing markers for the
	# nested text.

	@@( = ('(','');
	@@) = (')','');
	($re=$_)=~s/((BEGIN)|(END)|.)/$)[!$3]\Q$1\E$([!$2]/gs;
	@@$ = (eval{/$re/},$@@!~/unmatched/i);
	print join("\n",@@$[0..$#$]) if( $$[-1] );

=head2 How do I reverse a string?

Use C<reverse()> in scalar context, as documented in
L<perlfunc/reverse>.

	$reversed = reverse $string;

=head2 How do I expand tabs in a string?

You can do it yourself:

	1 while $string =~ s/\t+/' ' x (length($&) * 8 - length($`) % 8)/e;

Or you can just use the C<Text::Tabs> module (part of the standard Perl
distribution).

	use Text::Tabs;
	@@expanded_lines = expand(@@lines_with_tabs);

=head2 How do I reformat a paragraph?

Use C<Text::Wrap> (part of the standard Perl distribution):

	use Text::Wrap;
	print wrap("\t", '  ', @@paragraphs);

The paragraphs you give to C<Text::Wrap> should not contain embedded
newlines.  C<Text::Wrap> doesn't justify the lines (flush-right).

Or use the CPAN module C<Text::Autoformat>.  Formatting files can be
easily done by making a shell alias, like so:

	alias fmt="perl -i -MText::Autoformat -n0777 \
		-e 'print autoformat $_, {all=>1}' $*"

See the documentation for C<Text::Autoformat> to appreciate its many
capabilities.

=head2 How can I access or change N characters of a string?

You can access the first characters of a string with substr().
To get the first character, for example, start at position 0
and grab the string of length 1.


	$string = "Just another Perl Hacker";
	$first_char = substr( $string, 0, 1 );  #  'J'

To change part of a string, you can use the optional fourth
argument which is the replacement string.

	substr( $string, 13, 4, "Perl 5.8.0" );

You can also use substr() as an lvalue.

	substr( $string, 13, 4 ) =  "Perl 5.8.0";

=head2 How do I change the Nth occurrence of something?

You have to keep track of N yourself.  For example, let's say you want
to change the fifth occurrence of C<"whoever"> or C<"whomever"> into
C<"whosoever"> or C<"whomsoever">, case insensitively.  These
all assume that $_ contains the string to be altered.

	$count = 0;
	s{((whom?)ever)}{
	++$count == 5       # is it the 5th?
	    ? "${2}soever"  # yes, swap
	    : $1            # renege and leave it there
		}ige;

In the more general case, you can use the C</g> modifier in a C<while>
loop, keeping count of matches.

	$WANT = 3;
	$count = 0;
	$_ = "One fish two fish red fish blue fish";
	while (/(\w+)\s+fish\b/gi) {
		if (++$count == $WANT) {
			print "The third fish is a $1 one.\n";
			}
		}

That prints out: C<"The third fish is a red one.">  You can also use a
repetition count and repeated pattern like this:

	/(?:\w+\s+fish\s+){2}(\w+)\s+fish/i;

=head2 How can I count the number of occurrences of a substring within a string?

There are a number of ways, with varying efficiency.  If you want a
count of a certain single character (X) within a string, you can use the
C<tr///> function like so:

	$string = "ThisXlineXhasXsomeXx'sXinXit";
	$count = ($string =~ tr/X//);
	print "There are $count X characters in the string";

This is fine if you are just looking for a single character.  However,
if you are trying to count multiple character substrings within a
larger string, C<tr///> won't work.  What you can do is wrap a while()
loop around a global pattern match.  For example, let's count negative
integers:

	$string = "-9 55 48 -2 23 -76 4 14 -44";
	while ($string =~ /-\d+/g) { $count++ }
	print "There are $count negative numbers in the string";

Another version uses a global match in list context, then assigns the
result to a scalar, producing a count of the number of matches.

	$count = () = $string =~ /-\d+/g;

=head2 How do I capitalize all the words on one line?
X<Text::Autoformat> X<capitalize> X<case, title> X<case, sentence>

(contributed by brian d foy)

Damian Conway's L<Text::Autoformat> handles all of the thinking
for you.

	use Text::Autoformat;
	my $x = "Dr. Strangelove or: How I Learned to Stop ".
	  "Worrying and Love the Bomb";

	print $x, "\n";
	for my $style (qw( sentence title highlight )) {
		print autoformat($x, { case => $style }), "\n";
		}

How do you want to capitalize those words?

	FRED AND BARNEY'S LODGE        # all uppercase
	Fred And Barney's Lodge        # title case
	Fred and Barney's Lodge        # highlight case

It's not as easy a problem as it looks. How many words do you think
are in there? Wait for it... wait for it.... If you answered 5
you're right. Perl words are groups of C<\w+>, but that's not what
you want to capitalize. How is Perl supposed to know not to capitalize
that C<s> after the apostrophe? You could try a regular expression:

	$string =~ s/ (
				 (^\w)    #at the beginning of the line
				   |      # or
				 (\s\w)   #preceded by whitespace
				   )
				/\U$1/xg;

	$string =~ s/([\w']+)/\u\L$1/g;

Now, what if you don't want to capitalize that "and"? Just use
L<Text::Autoformat> and get on with the next problem. :)

=head2 How can I split a [character] delimited string except when inside [character]?

Several modules can handle this sort of parsing--C<Text::Balanced>,
C<Text::CSV>, C<Text::CSV_XS>, and C<Text::ParseWords>, among others.

Take the example case of trying to split a string that is
comma-separated into its different fields. You can't use C<split(/,/)>
because you shouldn't split if the comma is inside quotes.  For
example, take a data line like this:

	SAR001,"","Cimetrix, Inc","Bob Smith","CAM",N,8,1,0,7,"Error, Core Dumped"

Due to the restriction of the quotes, this is a fairly complex
problem.  Thankfully, we have Jeffrey Friedl, author of
I<Mastering Regular Expressions>, to handle these for us.  He
suggests (assuming your string is contained in C<$text>):

	 @@new = ();
	 push(@@new, $+) while $text =~ m{
		 "([^\"\\]*(?:\\.[^\"\\]*)*)",?  # groups the phrase inside the quotes
		| ([^,]+),?
		| ,
		}gx;
	 push(@@new, undef) if substr($text,-1,1) eq ',';

If you want to represent quotation marks inside a
quotation-mark-delimited field, escape them with backslashes (eg,
C<"like \"this\"">.

Alternatively, the C<Text::ParseWords> module (part of the standard
Perl distribution) lets you say:

	use Text::ParseWords;
	@@new = quotewords(",", 0, $text);

=head2 How do I strip blank space from the beginning/end of a string?

(contributed by brian d foy)

A substitution can do this for you. For a single line, you want to
replace all the leading or trailing whitespace with nothing. You
can do that with a pair of substitutions.

	s/^\s+//;
	s/\s+$//;

You can also write that as a single substitution, although it turns
out the combined statement is slower than the separate ones. That
might not matter to you, though.

	s/^\s+|\s+$//g;

In this regular expression, the alternation matches either at the
beginning or the end of the string since the anchors have a lower
precedence than the alternation. With the C</g> flag, the substitution
makes all possible matches, so it gets both. Remember, the trailing
newline matches the C<\s+>, and  the C<$> anchor can match to the
physical end of the string, so the newline disappears too. Just add
the newline to the output, which has the added benefit of preserving
"blank" (consisting entirely of whitespace) lines which the C<^\s+>
would remove all by itself.

	while( <> )
		{
		s/^\s+|\s+$//g;
		print "$_\n";
		}

For a multi-line string, you can apply the regular expression
to each logical line in the string by adding the C</m> flag (for
"multi-line"). With the C</m> flag, the C<$> matches I<before> an
embedded newline, so it doesn't remove it. It still removes the
newline at the end of the string.

	$string =~ s/^\s+|\s+$//gm;

Remember that lines consisting entirely of whitespace will disappear,
since the first part of the alternation can match the entire string
and replace it with nothing. If need to keep embedded blank lines,
you have to do a little more work. Instead of matching any whitespace
(since that includes a newline), just match the other whitespace.

	$string =~ s/^[\t\f ]+|[\t\f ]+$//mg;

=head2 How do I pad a string with blanks or pad a number with zeroes?

In the following examples, C<$pad_len> is the length to which you wish
to pad the string, C<$text> or C<$num> contains the string to be padded,
and C<$pad_char> contains the padding character. You can use a single
character string constant instead of the C<$pad_char> variable if you
know what it is in advance. And in the same way you can use an integer in
place of C<$pad_len> if you know the pad length in advance.

The simplest method uses the C<sprintf> function. It can pad on the left
or right with blanks and on the left with zeroes and it will not
truncate the result. The C<pack> function can only pad strings on the
right with blanks and it will truncate the result to a maximum length of
C<$pad_len>.

	# Left padding a string with blanks (no truncation):
	$padded = sprintf("%${pad_len}s", $text);
	$padded = sprintf("%*s", $pad_len, $text);  # same thing

	# Right padding a string with blanks (no truncation):
	$padded = sprintf("%-${pad_len}s", $text);
	$padded = sprintf("%-*s", $pad_len, $text); # same thing

	# Left padding a number with 0 (no truncation):
	$padded = sprintf("%0${pad_len}d", $num);
	$padded = sprintf("%0*d", $pad_len, $num); # same thing

	# Right padding a string with blanks using pack (will truncate):
	$padded = pack("A$pad_len",$text);

If you need to pad with a character other than blank or zero you can use
one of the following methods.  They all generate a pad string with the
C<x> operator and combine that with C<$text>. These methods do
not truncate C<$text>.

Left and right padding with any character, creating a new string:

	$padded = $pad_char x ( $pad_len - length( $text ) ) . $text;
	$padded = $text . $pad_char x ( $pad_len - length( $text ) );

Left and right padding with any character, modifying C<$text> directly:

	substr( $text, 0, 0 ) = $pad_char x ( $pad_len - length( $text ) );
	$text .= $pad_char x ( $pad_len - length( $text ) );

=head2 How do I extract selected columns from a string?

(contributed by brian d foy)

If you know the columns that contain the data, you can
use C<substr> to extract a single column.

	my $column = substr( $line, $start_column, $length );

You can use C<split> if the columns are separated by whitespace or
some other delimiter, as long as whitespace or the delimiter cannot
appear as part of the data.

	my $line    = ' fred barney   betty   ';
	my @@columns = split /\s+/, $line;
		# ( '', 'fred', 'barney', 'betty' );

	my $line    = 'fred||barney||betty';
	my @@columns = split /\|/, $line;
		# ( 'fred', '', 'barney', '', 'betty' );

If you want to work with comma-separated values, don't do this since
that format is a bit more complicated. Use one of the modules that
handle that format, such as C<Text::CSV>, C<Text::CSV_XS>, or
C<Text::CSV_PP>.

If you want to break apart an entire line of fixed columns, you can use
C<unpack> with the A (ASCII) format. By using a number after the format
specifier, you can denote the column width. See the C<pack> and C<unpack>
entries in L<perlfunc> for more details.

	my @@fields = unpack( $line, "A8 A8 A8 A16 A4" );

Note that spaces in the format argument to C<unpack> do not denote literal
spaces. If you have space separated data, you may want C<split> instead.

=head2 How do I find the soundex value of a string?

(contributed by brian d foy)

You can use the Text::Soundex module. If you want to do fuzzy or close
matching, you might also try the C<String::Approx>, and
C<Text::Metaphone>, and C<Text::DoubleMetaphone> modules.

=head2 How can I expand variables in text strings?

(contributed by brian d foy)

If you can avoid it, don't, or if you can use a templating system,
such as C<Text::Template> or C<Template> Toolkit, do that instead. You
might even be able to get the job done with C<sprintf> or C<printf>:

	my $string = sprintf 'Say hello to %s and %s', $foo, $bar;

However, for the one-off simple case where I don't want to pull out a
full templating system, I'll use a string that has two Perl scalar
variables in it. In this example, I want to expand C<$foo> and C<$bar>
to their variable's values:

	my $foo = 'Fred';
	my $bar = 'Barney';
	$string = 'Say hello to $foo and $bar';

One way I can do this involves the substitution operator and a double
C</e> flag.  The first C</e> evaluates C<$1> on the replacement side and
turns it into C<$foo>. The second /e starts with C<$foo> and replaces
it with its value. C<$foo>, then, turns into 'Fred', and that's finally
what's left in the string:

	$string =~ s/(\$\w+)/$1/eeg; # 'Say hello to Fred and Barney'

The C</e> will also silently ignore violations of strict, replacing
undefined variable names with the empty string. Since I'm using the
C</e> flag (twice even!), I have all of the same security problems I
have with C<eval> in its string form. If there's something odd in
C<$foo>, perhaps something like C<@@{[ system "rm -rf /" ]}>, then
I could get myself in trouble.

To get around the security problem, I could also pull the values from
a hash instead of evaluating variable names. Using a single C</e>, I
can check the hash to ensure the value exists, and if it doesn't, I
can replace the missing value with a marker, in this case C<???> to
signal that I missed something:

	my $string = 'This has $foo and $bar';

	my %Replacements = (
		foo  => 'Fred',
		);

	# $string =~ s/\$(\w+)/$Replacements{$1}/g;
	$string =~ s/\$(\w+)/
		exists $Replacements{$1} ? $Replacements{$1} : '???'
		/eg;

	print $string;

=head2 What's wrong with always quoting "$vars"?

The problem is that those double-quotes force
stringification--coercing numbers and references into strings--even
when you don't want them to be strings.  Think of it this way:
double-quote expansion is used to produce new strings.  If you already
have a string, why do you need more?

If you get used to writing odd things like these:

	print "$var";   	# BAD
	$new = "$old";   	# BAD
	somefunc("$var");	# BAD

You'll be in trouble.  Those should (in 99.8% of the cases) be
the simpler and more direct:

	print $var;
	$new = $old;
	somefunc($var);

Otherwise, besides slowing you down, you're going to break code when
the thing in the scalar is actually neither a string nor a number, but
a reference:

	func(\@@array);
	sub func {
		my $aref = shift;
		my $oref = "$aref";  # WRONG
		}

You can also get into subtle problems on those few operations in Perl
that actually do care about the difference between a string and a
number, such as the magical C<++> autoincrement operator or the
syscall() function.

Stringification also destroys arrays.

	@@lines = `command`;
	print "@@lines";     # WRONG - extra blanks
	print @@lines;       # right

=head2 Why don't my E<lt>E<lt>HERE documents work?

Check for these three things:

=over 4

=item There must be no space after the E<lt>E<lt> part.

=item There (probably) should be a semicolon at the end.

=item You can't (easily) have any space in front of the tag.

=back

If you want to indent the text in the here document, you
can do this:

    # all in one
    ($VAR = <<HERE_TARGET) =~ s/^\s+//gm;
        your text
        goes here
    HERE_TARGET

But the HERE_TARGET must still be flush against the margin.
If you want that indented also, you'll have to quote
in the indentation.

    ($quote = <<'    FINIS') =~ s/^\s+//gm;
            ...we will have peace, when you and all your works have
            perished--and the works of your dark master to whom you
            would deliver us. You are a liar, Saruman, and a corrupter
            of men's hearts.  --Theoden in /usr/src/perl/taint.c
        FINIS
    $quote =~ s/\s+--/\n--/;

A nice general-purpose fixer-upper function for indented here documents
follows.  It expects to be called with a here document as its argument.
It looks to see whether each line begins with a common substring, and
if so, strips that substring off.  Otherwise, it takes the amount of leading
whitespace found on the first line and removes that much off each
subsequent line.

    sub fix {
        local $_ = shift;
        my ($white, $leader);  # common whitespace and common leading string
        if (/^\s*(?:([^\w\s]+)(\s*).*\n)(?:\s*\1\2?.*\n)+$/) {
            ($white, $leader) = ($2, quotemeta($1));
        } else {
            ($white, $leader) = (/^(\s+)/, '');
        }
        s/^\s*?$leader(?:$white)?//gm;
        return $_;
    }

This works with leading special strings, dynamically determined:

	$remember_the_main = fix<<'    MAIN_INTERPRETER_LOOP';
	@@@@@@ int
	@@@@@@ runops() {
	@@@@@@     SAVEI32(runlevel);
	@@@@@@     runlevel++;
	@@@@@@     while ( op = (*op->op_ppaddr)() );
	@@@@@@     TAINT_NOT;
	@@@@@@     return 0;
	@@@@@@ }
	MAIN_INTERPRETER_LOOP

Or with a fixed amount of leading whitespace, with remaining
indentation correctly preserved:

	$poem = fix<<EVER_ON_AND_ON;
       Now far ahead the Road has gone,
	  And I must follow, if I can,
       Pursuing it with eager feet,
	  Until it joins some larger way
       Where many paths and errands meet.
	  And whither then? I cannot say.
		--Bilbo in /usr/src/perl/pp_ctl.c
	EVER_ON_AND_ON

=head1 Data: Arrays

=head2 What is the difference between a list and an array?

(contributed by brian d foy)

A list is a fixed collection of scalars. An array is a variable that
holds a variable collection of scalars. An array can supply its collection
for list operations, so list operations also work on arrays:

	# slices
	( 'dog', 'cat', 'bird' )[2,3];
	@@animals[2,3];

	# iteration
	foreach ( qw( dog cat bird ) ) { ... }
	foreach ( @@animals ) { ... }

	my @@three = grep { length == 3 } qw( dog cat bird );
	my @@three = grep { length == 3 } @@animals;

	# supply an argument list
	wash_animals( qw( dog cat bird ) );
	wash_animals( @@animals );

Array operations, which change the scalars, reaaranges them, or adds
or subtracts some scalars, only work on arrays. These can't work on a
list, which is fixed. Array operations include C<shift>, C<unshift>,
C<push>, C<pop>, and C<splice>.

An array can also change its length:

	$#animals = 1;  # truncate to two elements
	$#animals = 10000; # pre-extend to 10,001 elements

You can change an array element, but you can't change a list element:

	$animals[0] = 'Rottweiler';
	qw( dog cat bird )[0] = 'Rottweiler'; # syntax error!

	foreach ( @@animals ) {
		s/^d/fr/;  # works fine
		}

	foreach ( qw( dog cat bird ) ) {
		s/^d/fr/;  # Error! Modification of read only value!
		}

However, if the list element is itself a variable, it appears that you
can change a list element. However, the list element is the variable, not
the data. You're not changing the list element, but something the list
element refers to. The list element itself doesn't change: it's still
the same variable.

You also have to be careful about context. You can assign an array to
a scalar to get the number of elements in the array. This only works
for arrays, though:

	my $count = @@animals;  # only works with arrays

If you try to do the same thing with what you think is a list, you
get a quite different result. Although it looks like you have a list
on the righthand side, Perl actually sees a bunch of scalars separated
by a comma:

	my $scalar = ( 'dog', 'cat', 'bird' );  # $scalar gets bird

Since you're assigning to a scalar, the righthand side is in scalar
context. The comma operator (yes, it's an operator!) in scalar
context evaluates its lefthand side, throws away the result, and
evaluates it's righthand side and returns the result. In effect,
that list-lookalike assigns to C<$scalar> it's rightmost value. Many
people mess this up becuase they choose a list-lookalike whose
last element is also the count they expect:

	my $scalar = ( 1, 2, 3 );  # $scalar gets 3, accidentally

=head2 What is the difference between $array[1] and @@array[1]?

(contributed by brian d foy)

The difference is the sigil, that special character in front of the
array name. The C<$> sigil means "exactly one item", while the C<@@>
sigil means "zero or more items". The C<$> gets you a single scalar,
while the C<@@> gets you a list.

The confusion arises because people incorrectly assume that the sigil
denotes the variable type.

The C<$array[1]> is a single-element access to the array. It's going
to return the item in index 1 (or undef if there is no item there).
If you intend to get exactly one element from the array, this is the
form you should use.

The C<@@array[1]> is an array slice, although it has only one index.
You can pull out multiple elements simultaneously by specifying
additional indices as a list, like C<@@array[1,4,3,0]>.

Using a slice on the lefthand side of the assignment supplies list
context to the righthand side. This can lead to unexpected results.
For instance, if you want to read a single line from a filehandle,
assigning to a scalar value is fine:

	$array[1] = <STDIN>;

However, in list context, the line input operator returns all of the
lines as a list. The first line goes into C<@@array[1]> and the rest
of the lines mysteriously disappear:

	@@array[1] = <STDIN>;  # most likely not what you want

Either the C<use warnings> pragma or the B<-w> flag will warn you when
you use an array slice with a single index.

=head2 How can I remove duplicate elements from a list or array?

(contributed by brian d foy)

Use a hash. When you think the words "unique" or "duplicated", think
"hash keys".

If you don't care about the order of the elements, you could just
create the hash then extract the keys. It's not important how you
create that hash: just that you use C<keys> to get the unique
elements.

	my %hash   = map { $_, 1 } @@array;
	# or a hash slice: @@hash{ @@array } = ();
	# or a foreach: $hash{$_} = 1 foreach ( @@array );

	my @@unique = keys %hash;

If you want to use a module, try the C<uniq> function from
C<List::MoreUtils>. In list context it returns the unique elements,
preserving their order in the list. In scalar context, it returns the
number of unique elements.

	use List::MoreUtils qw(uniq);

	my @@unique = uniq( 1, 2, 3, 4, 4, 5, 6, 5, 7 ); # 1,2,3,4,5,6,7
	my $unique = uniq( 1, 2, 3, 4, 4, 5, 6, 5, 7 ); # 7

You can also go through each element and skip the ones you've seen
before. Use a hash to keep track. The first time the loop sees an
element, that element has no key in C<%Seen>. The C<next> statement
creates the key and immediately uses its value, which is C<undef>, so
the loop continues to the C<push> and increments the value for that
key. The next time the loop sees that same element, its key exists in
the hash I<and> the value for that key is true (since it's not 0 or
C<undef>), so the next skips that iteration and the loop goes to the
next element.

	my @@unique = ();
	my %seen   = ();

	foreach my $elem ( @@array )
		{
		next if $seen{ $elem }++;
		push @@unique, $elem;
		}

You can write this more briefly using a grep, which does the
same thing.

	my %seen = ();
	my @@unique = grep { ! $seen{ $_ }++ } @@array;

=head2 How can I tell whether a certain element is contained in a list or array?

(portions of this answer contributed by Anno Siegel and brian d foy)

Hearing the word "in" is an I<in>dication that you probably should have
used a hash, not a list or array, to store your data.  Hashes are
designed to answer this question quickly and efficiently.  Arrays aren't.

That being said, there are several ways to approach this.  In Perl 5.10
and later, you can use the smart match operator to check that an item is
contained in an array or a hash:

	use 5.010;

	if( $item ~~ @@array )
		{
		say "The array contains $item"
		}

	if( $item ~~ %hash )
		{
		say "The hash contains $item"
		}

With earlier versions of Perl, you have to do a bit more work. If you
are going to make this query many times over arbitrary string values,
the fastest way is probably to invert the original array and maintain a
hash whose keys are the first array's values:

	@@blues = qw/azure cerulean teal turquoise lapis-lazuli/;
	%is_blue = ();
	for (@@blues) { $is_blue{$_} = 1 }

Now you can check whether C<$is_blue{$some_color}>.  It might have
been a good idea to keep the blues all in a hash in the first place.

If the values are all small integers, you could use a simple indexed
array.  This kind of an array will take up less space:

	@@primes = (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31);
	@@is_tiny_prime = ();
	for (@@primes) { $is_tiny_prime[$_] = 1 }
	# or simply  @@istiny_prime[@@primes] = (1) x @@primes;

Now you check whether $is_tiny_prime[$some_number].

If the values in question are integers instead of strings, you can save
quite a lot of space by using bit strings instead:

	@@articles = ( 1..10, 150..2000, 2017 );
	undef $read;
	for (@@articles) { vec($read,$_,1) = 1 }

Now check whether C<vec($read,$n,1)> is true for some C<$n>.

These methods guarantee fast individual tests but require a re-organization
of the original list or array.  They only pay off if you have to test
multiple values against the same array.

If you are testing only once, the standard module C<List::Util> exports
the function C<first> for this purpose.  It works by stopping once it
finds the element. It's written in C for speed, and its Perl equivalent
looks like this subroutine:

	sub first (&@@) {
		my $code = shift;
		foreach (@@_) {
			return $_ if &{$code}();
		}
		undef;
	}

If speed is of little concern, the common idiom uses grep in scalar context
(which returns the number of items that passed its condition) to traverse the
entire list. This does have the benefit of telling you how many matches it
found, though.

	my $is_there = grep $_ eq $whatever, @@array;

If you want to actually extract the matching elements, simply use grep in
list context.

	my @@matches = grep $_ eq $whatever, @@array;

=head2 How do I compute the difference of two arrays?  How do I compute the intersection of two arrays?

Use a hash.  Here's code to do both and more.  It assumes that each
element is unique in a given array:

	@@union = @@intersection = @@difference = ();
	%count = ();
	foreach $element (@@array1, @@array2) { $count{$element}++ }
	foreach $element (keys %count) {
		push @@union, $element;
		push @@{ $count{$element} > 1 ? \@@intersection : \@@difference }, $element;
		}

Note that this is the I<symmetric difference>, that is, all elements
in either A or in B but not in both.  Think of it as an xor operation.

=head2 How do I test whether two arrays or hashes are equal?

With Perl 5.10 and later, the smart match operator can give you the answer
with the least amount of work:

	use 5.010;

	if( @@array1 ~~ @@array2 )
		{
		say "The arrays are the same";
		}

	if( %hash1 ~~ %hash2 ) # doesn't check values!
		{
		say "The hash keys are the same";
		}

The following code works for single-level arrays.  It uses a
stringwise comparison, and does not distinguish defined versus
undefined empty strings.  Modify if you have other needs.

	$are_equal = compare_arrays(\@@frogs, \@@toads);

	sub compare_arrays {
		my ($first, $second) = @@_;
		no warnings;  # silence spurious -w undef complaints
		return 0 unless @@$first == @@$second;
		for (my $i = 0; $i < @@$first; $i++) {
			return 0 if $first->[$i] ne $second->[$i];
			}
		return 1;
		}

For multilevel structures, you may wish to use an approach more
like this one.  It uses the CPAN module C<FreezeThaw>:

	use FreezeThaw qw(cmpStr);
	@@a = @@b = ( "this", "that", [ "more", "stuff" ] );

	printf "a and b contain %s arrays\n",
		cmpStr(\@@a, \@@b) == 0
		? "the same"
		: "different";

This approach also works for comparing hashes.  Here we'll demonstrate
two different answers:

	use FreezeThaw qw(cmpStr cmpStrHard);

	%a = %b = ( "this" => "that", "extra" => [ "more", "stuff" ] );
	$a{EXTRA} = \%b;
	$b{EXTRA} = \%a;

	printf "a and b contain %s hashes\n",
	cmpStr(\%a, \%b) == 0 ? "the same" : "different";

	printf "a and b contain %s hashes\n",
	cmpStrHard(\%a, \%b) == 0 ? "the same" : "different";


The first reports that both those the hashes contain the same data,
while the second reports that they do not.  Which you prefer is left as
an exercise to the reader.

=head2 How do I find the first array element for which a condition is true?

To find the first array element which satisfies a condition, you can
use the C<first()> function in the C<List::Util> module, which comes
with Perl 5.8. This example finds the first element that contains
"Perl".

	use List::Util qw(first);

	my $element = first { /Perl/ } @@array;

If you cannot use C<List::Util>, you can make your own loop to do the
same thing.  Once you find the element, you stop the loop with last.

	my $found;
	foreach ( @@array ) {
		if( /Perl/ ) { $found = $_; last }
		}

If you want the array index, you can iterate through the indices
and check the array element at each index until you find one
that satisfies the condition.

	my( $found, $index ) = ( undef, -1 );
	for( $i = 0; $i < @@array; $i++ ) {
		if( $array[$i] =~ /Perl/ ) {
			$found = $array[$i];
			$index = $i;
			last;
			}
		}

=head2 How do I handle linked lists?

In general, you usually don't need a linked list in Perl, since with
regular arrays, you can push and pop or shift and unshift at either
end, or you can use splice to add and/or remove arbitrary number of
elements at arbitrary points.  Both pop and shift are O(1)
operations on Perl's dynamic arrays.  In the absence of shifts and
pops, push in general needs to reallocate on the order every log(N)
times, and unshift will need to copy pointers each time.

If you really, really wanted, you could use structures as described in
L<perldsc> or L<perltoot> and do just what the algorithm book tells
you to do.  For example, imagine a list node like this:

	$node = {
		VALUE => 42,
		LINK  => undef,
		};

You could walk the list this way:

	print "List: ";
	for ($node = $head;  $node; $node = $node->{LINK}) {
		print $node->{VALUE}, " ";
		}
	print "\n";

You could add to the list this way:

	my ($head, $tail);
	$tail = append($head, 1);       # grow a new head
	for $value ( 2 .. 10 ) {
		$tail = append($tail, $value);
		}

	sub append {
		my($list, $value) = @@_;
		my $node = { VALUE => $value };
		if ($list) {
			$node->{LINK} = $list->{LINK};
			$list->{LINK} = $node;
			}
		else {
			$_[0] = $node;      # replace caller's version
			}
		return $node;
		}

But again, Perl's built-in are virtually always good enough.

=head2 How do I handle circular lists?
X<circular> X<array> X<Tie::Cycle> X<Array::Iterator::Circular>
X<cycle> X<modulus>

(contributed by brian d foy)

If you want to cycle through an array endlessly, you can increment the
index modulo the number of elements in the array:

	my @@array = qw( a b c );
	my $i = 0;

	while( 1 ) {
		print $array[ $i++ % @@array ], "\n";
		last if $i > 20;
		}

You can also use C<Tie::Cycle> to use a scalar that always has the
next element of the circular array:

	use Tie::Cycle;

	tie my $cycle, 'Tie::Cycle', [ qw( FFFFFF 000000 FFFF00 ) ];

	print $cycle; # FFFFFF
	print $cycle; # 000000
	print $cycle; # FFFF00

The C<Array::Iterator::Circular> creates an iterator object for
circular arrays:

	use Array::Iterator::Circular;

	my $color_iterator = Array::Iterator::Circular->new(
		qw(red green blue orange)
		);

	foreach ( 1 .. 20 ) {
		print $color_iterator->next, "\n";
		}

=head2 How do I shuffle an array randomly?

If you either have Perl 5.8.0 or later installed, or if you have
Scalar-List-Utils 1.03 or later installed, you can say:

	use List::Util 'shuffle';

	@@shuffled = shuffle(@@list);

If not, you can use a Fisher-Yates shuffle.

	sub fisher_yates_shuffle {
		my $deck = shift;  # $deck is a reference to an array
		return unless @@$deck; # must not be empty!

		my $i = @@$deck;
		while (--$i) {
			my $j = int rand ($i+1);
			@@$deck[$i,$j] = @@$deck[$j,$i];
			}
	}

	# shuffle my mpeg collection
	#
	my @@mpeg = <audio/*/*.mp3>;
	fisher_yates_shuffle( \@@mpeg );    # randomize @@mpeg in place
	print @@mpeg;

Note that the above implementation shuffles an array in place,
unlike the C<List::Util::shuffle()> which takes a list and returns
a new shuffled list.

You've probably seen shuffling algorithms that work using splice,
randomly picking another element to swap the current element with

	srand;
	@@new = ();
	@@old = 1 .. 10;  # just a demo
	while (@@old) {
		push(@@new, splice(@@old, rand @@old, 1));
		}

This is bad because splice is already O(N), and since you do it N
times, you just invented a quadratic algorithm; that is, O(N**2).
This does not scale, although Perl is so efficient that you probably
won't notice this until you have rather largish arrays.

=head2 How do I process/modify each element of an array?

Use C<for>/C<foreach>:

	for (@@lines) {
		s/foo/bar/;	# change that word
		tr/XZ/ZX/;	# swap those letters
		}

Here's another; let's compute spherical volumes:

	for (@@volumes = @@radii) {   # @@volumes has changed parts
		$_ **= 3;
		$_ *= (4/3) * 3.14159;  # this will be constant folded
		}

which can also be done with C<map()> which is made to transform
one list into another:

	@@volumes = map {$_ ** 3 * (4/3) * 3.14159} @@radii;

If you want to do the same thing to modify the values of the
hash, you can use the C<values> function.  As of Perl 5.6
the values are not copied, so if you modify $orbit (in this
case), you modify the value.

	for $orbit ( values %orbits ) {
		($orbit **= 3) *= (4/3) * 3.14159;
		}

Prior to perl 5.6 C<values> returned copies of the values,
so older perl code often contains constructions such as
C<@@orbits{keys %orbits}> instead of C<values %orbits> where
the hash is to be modified.

=head2 How do I select a random element from an array?

Use the C<rand()> function (see L<perlfunc/rand>):

	$index   = rand @@array;
	$element = $array[$index];

Or, simply:

	my $element = $array[ rand @@array ];

=head2 How do I permute N elements of a list?
X<List::Permuter> X<permute> X<Algorithm::Loops> X<Knuth>
X<The Art of Computer Programming> X<Fischer-Krause>

Use the C<List::Permutor> module on CPAN. If the list is actually an
array, try the C<Algorithm::Permute> module (also on CPAN). It's
written in XS code and is very efficient:

	use Algorithm::Permute;

	my @@array = 'a'..'d';
	my $p_iterator = Algorithm::Permute->new ( \@@array );

	while (my @@perm = $p_iterator->next) {
	   print "next permutation: (@@perm)\n";
		}

For even faster execution, you could do:

	use Algorithm::Permute;

	my @@array = 'a'..'d';

	Algorithm::Permute::permute {
		print "next permutation: (@@array)\n";
		} @@array;

Here's a little program that generates all permutations of all the
words on each line of input. The algorithm embodied in the
C<permute()> function is discussed in Volume 4 (still unpublished) of
Knuth's I<The Art of Computer Programming> and will work on any list:

	#!/usr/bin/perl -n
	# Fischer-Krause ordered permutation generator

	sub permute (&@@) {
		my $code = shift;
		my @@idx = 0..$#_;
		while ( $code->(@@_[@@idx]) ) {
			my $p = $#idx;
			--$p while $idx[$p-1] > $idx[$p];
			my $q = $p or return;
			push @@idx, reverse splice @@idx, $p;
			++$q while $idx[$p-1] > $idx[$q];
			@@idx[$p-1,$q]=@@idx[$q,$p-1];
		}
	}

	permute { print "@@_\n" } split;

The C<Algorithm::Loops> module also provides the C<NextPermute> and
C<NextPermuteNum> functions which efficiently find all unique permutations
of an array, even if it contains duplicate values, modifying it in-place:
if its elements are in reverse-sorted order then the array is reversed,
making it sorted, and it returns false; otherwise the next
permutation is returned.

C<NextPermute> uses string order and C<NextPermuteNum> numeric order, so
you can enumerate all the permutations of C<0..9> like this:

	use Algorithm::Loops qw(NextPermuteNum);

    my @@list= 0..9;
    do { print "@@list\n" } while NextPermuteNum @@list;

=head2 How do I sort an array by (anything)?

Supply a comparison function to sort() (described in L<perlfunc/sort>):

	@@list = sort { $a <=> $b } @@list;

The default sort function is cmp, string comparison, which would
sort C<(1, 2, 10)> into C<(1, 10, 2)>.  C<< <=> >>, used above, is
the numerical comparison operator.

If you have a complicated function needed to pull out the part you
want to sort on, then don't do it inside the sort function.  Pull it
out first, because the sort BLOCK can be called many times for the
same element.  Here's an example of how to pull out the first word
after the first number on each item, and then sort those words
case-insensitively.

	@@idx = ();
	for (@@data) {
		($item) = /\d+\s*(\S+)/;
		push @@idx, uc($item);
	    }
	@@sorted = @@data[ sort { $idx[$a] cmp $idx[$b] } 0 .. $#idx ];

which could also be written this way, using a trick
that's come to be known as the Schwartzian Transform:

	@@sorted = map  { $_->[0] }
		sort { $a->[1] cmp $b->[1] }
		map  { [ $_, uc( (/\d+\s*(\S+)/)[0]) ] } @@data;

If you need to sort on several fields, the following paradigm is useful.

	@@sorted = sort {
		field1($a) <=> field1($b) ||
		field2($a) cmp field2($b) ||
		field3($a) cmp field3($b)
		} @@data;

This can be conveniently combined with precalculation of keys as given
above.

See the F<sort> article in the "Far More Than You Ever Wanted
To Know" collection in http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz for
more about this approach.

See also the question later in L<perlfaq4> on sorting hashes.

=head2 How do I manipulate arrays of bits?

Use C<pack()> and C<unpack()>, or else C<vec()> and the bitwise
operations.

For example, you don't have to store individual bits in an array
(which would mean that you're wasting a lot of space). To convert an
array of bits to a string, use C<vec()> to set the right bits. This
sets C<$vec> to have bit N set only if C<$ints[N]> was set:

	@@ints = (...); # array of bits, e.g. ( 1, 0, 0, 1, 1, 0 ... )
	$vec = '';
	foreach( 0 .. $#ints ) {
		vec($vec,$_,1) = 1 if $ints[$_];
		}

The string C<$vec> only takes up as many bits as it needs. For
instance, if you had 16 entries in C<@@ints>, C<$vec> only needs two
bytes to store them (not counting the scalar variable overhead).

Here's how, given a vector in C<$vec>, you can get those bits into
your C<@@ints> array:

	sub bitvec_to_list {
		my $vec = shift;
		my @@ints;
		# Find null-byte density then select best algorithm
		if ($vec =~ tr/\0// / length $vec > 0.95) {
			use integer;
			my $i;

			# This method is faster with mostly null-bytes
			while($vec =~ /[^\0]/g ) {
				$i = -9 + 8 * pos $vec;
				push @@ints, $i if vec($vec, ++$i, 1);
				push @@ints, $i if vec($vec, ++$i, 1);
				push @@ints, $i if vec($vec, ++$i, 1);
				push @@ints, $i if vec($vec, ++$i, 1);
				push @@ints, $i if vec($vec, ++$i, 1);
				push @@ints, $i if vec($vec, ++$i, 1);
				push @@ints, $i if vec($vec, ++$i, 1);
				push @@ints, $i if vec($vec, ++$i, 1);
				}
			}
		else {
			# This method is a fast general algorithm
			use integer;
			my $bits = unpack "b*", $vec;
			push @@ints, 0 if $bits =~ s/^(\d)// && $1;
			push @@ints, pos $bits while($bits =~ /1/g);
			}

		return \@@ints;
		}

This method gets faster the more sparse the bit vector is.
(Courtesy of Tim Bunce and Winfried Koenig.)

You can make the while loop a lot shorter with this suggestion
from Benjamin Goldberg:

	while($vec =~ /[^\0]+/g ) {
		push @@ints, grep vec($vec, $_, 1), $-[0] * 8 .. $+[0] * 8;
		}

Or use the CPAN module C<Bit::Vector>:

	$vector = Bit::Vector->new($num_of_bits);
	$vector->Index_List_Store(@@ints);
	@@ints = $vector->Index_List_Read();

C<Bit::Vector> provides efficient methods for bit vector, sets of
small integers and "big int" math.

Here's a more extensive illustration using vec():

	# vec demo
	$vector = "\xff\x0f\xef\xfe";
	print "Ilya's string \\xff\\x0f\\xef\\xfe represents the number ",
	unpack("N", $vector), "\n";
	$is_set = vec($vector, 23, 1);
	print "Its 23rd bit is ", $is_set ? "set" : "clear", ".\n";
	pvec($vector);

	set_vec(1,1,1);
	set_vec(3,1,1);
	set_vec(23,1,1);

	set_vec(3,1,3);
	set_vec(3,2,3);
	set_vec(3,4,3);
	set_vec(3,4,7);
	set_vec(3,8,3);
	set_vec(3,8,7);

	set_vec(0,32,17);
	set_vec(1,32,17);

	sub set_vec {
		my ($offset, $width, $value) = @@_;
		my $vector = '';
		vec($vector, $offset, $width) = $value;
		print "offset=$offset width=$width value=$value\n";
		pvec($vector);
		}

	sub pvec {
		my $vector = shift;
		my $bits = unpack("b*", $vector);
		my $i = 0;
		my $BASE = 8;

		print "vector length in bytes: ", length($vector), "\n";
		@@bytes = unpack("A8" x length($vector), $bits);
		print "bits are: @@bytes\n\n";
		}

=head2 Why does defined() return true on empty arrays and hashes?

The short story is that you should probably only use defined on scalars or
functions, not on aggregates (arrays and hashes).  See L<perlfunc/defined>
in the 5.004 release or later of Perl for more detail.

=head1 Data: Hashes (Associative Arrays)

=head2 How do I process an entire hash?

(contributed by brian d foy)

There are a couple of ways that you can process an entire hash. You
can get a list of keys, then go through each key, or grab a one
key-value pair at a time.

To go through all of the keys, use the C<keys> function. This extracts
all of the keys of the hash and gives them back to you as a list. You
can then get the value through the particular key you're processing:

	foreach my $key ( keys %hash ) {
		my $value = $hash{$key}
		...
		}

Once you have the list of keys, you can process that list before you
process the hash elements. For instance, you can sort the keys so you
can process them in lexical order:

	foreach my $key ( sort keys %hash ) {
		my $value = $hash{$key}
		...
		}

Or, you might want to only process some of the items. If you only want
to deal with the keys that start with C<text:>, you can select just
those using C<grep>:

	foreach my $key ( grep /^text:/, keys %hash ) {
		my $value = $hash{$key}
		...
		}

If the hash is very large, you might not want to create a long list of
keys. To save some memory, you can grab one key-value pair at a time using
C<each()>, which returns a pair you haven't seen yet:

	while( my( $key, $value ) = each( %hash ) ) {
		...
		}

The C<each> operator returns the pairs in apparently random order, so if
ordering matters to you, you'll have to stick with the C<keys> method.

The C<each()> operator can be a bit tricky though. You can't add or
delete keys of the hash while you're using it without possibly
skipping or re-processing some pairs after Perl internally rehashes
all of the elements. Additionally, a hash has only one iterator, so if
you use C<keys>, C<values>, or C<each> on the same hash, you can reset
the iterator and mess up your processing. See the C<each> entry in
L<perlfunc> for more details.

=head2 How do I merge two hashes?
X<hash> X<merge> X<slice, hash>

(contributed by brian d foy)

Before you decide to merge two hashes, you have to decide what to do
if both hashes contain keys that are the same and if you want to leave
the original hashes as they were.

If you want to preserve the original hashes, copy one hash (C<%hash1>)
to a new hash (C<%new_hash>), then add the keys from the other hash
(C<%hash2> to the new hash. Checking that the key already exists in
C<%new_hash> gives you a chance to decide what to do with the
duplicates:

	my %new_hash = %hash1; # make a copy; leave %hash1 alone

	foreach my $key2 ( keys %hash2 )
		{
		if( exists $new_hash{$key2} )
			{
			warn "Key [$key2] is in both hashes!";
			# handle the duplicate (perhaps only warning)
			...
			next;
			}
		else
			{
			$new_hash{$key2} = $hash2{$key2};
			}
		}

If you don't want to create a new hash, you can still use this looping
technique; just change the C<%new_hash> to C<%hash1>.

	foreach my $key2 ( keys %hash2 )
		{
		if( exists $hash1{$key2} )
			{
			warn "Key [$key2] is in both hashes!";
			# handle the duplicate (perhaps only warning)
			...
			next;
			}
		else
			{
			$hash1{$key2} = $hash2{$key2};
			}
		}

If you don't care that one hash overwrites keys and values from the other, you
could just use a hash slice to add one hash to another. In this case, values
from C<%hash2> replace values from C<%hash1> when they have keys in common:

	@@hash1{ keys %hash2 } = values %hash2;

=head2 What happens if I add or remove keys from a hash while iterating over it?

(contributed by brian d foy)

The easy answer is "Don't do that!"

If you iterate through the hash with each(), you can delete the key
most recently returned without worrying about it.  If you delete or add
other keys, the iterator may skip or double up on them since perl
may rearrange the hash table.  See the
entry for C<each()> in L<perlfunc>.

=head2 How do I look up a hash element by value?

Create a reverse hash:

	%by_value = reverse %by_key;
	$key = $by_value{$value};

That's not particularly efficient.  It would be more space-efficient
to use:

	while (($key, $value) = each %by_key) {
		$by_value{$value} = $key;
	    }

If your hash could have repeated values, the methods above will only find
one of the associated keys.   This may or may not worry you.  If it does
worry you, you can always reverse the hash into a hash of arrays instead:

	while (($key, $value) = each %by_key) {
		 push @@{$key_list_by_value{$value}}, $key;
		}

=head2 How can I know how many entries are in a hash?

(contributed by brian d foy)

This is very similar to "How do I process an entire hash?", also in
L<perlfaq4>, but a bit simpler in the common cases.

You can use the C<keys()> built-in function in scalar context to find out
have many entries you have in a hash:

	my $key_count = keys %hash; # must be scalar context!

If you want to find out how many entries have a defined value, that's
a bit different. You have to check each value. A C<grep> is handy:

	my $defined_value_count = grep { defined } values %hash;

You can use that same structure to count the entries any way that
you like. If you want the count of the keys with vowels in them,
you just test for that instead:

	my $vowel_count = grep { /[aeiou]/ } keys %hash;

The C<grep> in scalar context returns the count. If you want the list
of matching items, just use it in list context instead:

	my @@defined_values = grep { defined } values %hash;

The C<keys()> function also resets the iterator, which means that you may
see strange results if you use this between uses of other hash operators
such as C<each()>.

=head2 How do I sort a hash (optionally by value instead of key)?

(contributed by brian d foy)

To sort a hash, start with the keys. In this example, we give the list of
keys to the sort function which then compares them ASCIIbetically (which
might be affected by your locale settings). The output list has the keys
in ASCIIbetical order. Once we have the keys, we can go through them to
create a report which lists the keys in ASCIIbetical order.

	my @@keys = sort { $a cmp $b } keys %hash;

	foreach my $key ( @@keys )
		{
		printf "%-20s %6d\n", $key, $hash{$key};
		}

We could get more fancy in the C<sort()> block though. Instead of
comparing the keys, we can compute a value with them and use that
value as the comparison.

For instance, to make our report order case-insensitive, we use
the C<\L> sequence in a double-quoted string to make everything
lowercase. The C<sort()> block then compares the lowercased
values to determine in which order to put the keys.

	my @@keys = sort { "\L$a" cmp "\L$b" } keys %hash;

Note: if the computation is expensive or the hash has many elements,
you may want to look at the Schwartzian Transform to cache the
computation results.

If we want to sort by the hash value instead, we use the hash key
to look it up. We still get out a list of keys, but this time they
are ordered by their value.

	my @@keys = sort { $hash{$a} <=> $hash{$b} } keys %hash;

From there we can get more complex. If the hash values are the same,
we can provide a secondary sort on the hash key.

	my @@keys = sort {
		$hash{$a} <=> $hash{$b}
			or
		"\L$a" cmp "\L$b"
		} keys %hash;

=head2 How can I always keep my hash sorted?
X<hash tie sort DB_File Tie::IxHash>

You can look into using the C<DB_File> module and C<tie()> using the
C<$DB_BTREE> hash bindings as documented in L<DB_File/"In Memory
Databases">. The C<Tie::IxHash> module from CPAN might also be
instructive. Although this does keep your hash sorted, you might not
like the slow down you suffer from the tie interface. Are you sure you
need to do this? :)

=head2 What's the difference between "delete" and "undef" with hashes?

Hashes contain pairs of scalars: the first is the key, the
second is the value.  The key will be coerced to a string,
although the value can be any kind of scalar: string,
number, or reference.  If a key C<$key> is present in
%hash, C<exists($hash{$key})> will return true.  The value
for a given key can be C<undef>, in which case
C<$hash{$key}> will be C<undef> while C<exists $hash{$key}>
will return true.  This corresponds to (C<$key>, C<undef>)
being in the hash.

Pictures help...  Here's the C<%hash> table:

	  keys  values
	+------+------+
	|  a   |  3   |
	|  x   |  7   |
	|  d   |  0   |
	|  e   |  2   |
	+------+------+

And these conditions hold

	$hash{'a'}                       is true
	$hash{'d'}                       is false
	defined $hash{'d'}               is true
	defined $hash{'a'}               is true
	exists $hash{'a'}                is true (Perl 5 only)
	grep ($_ eq 'a', keys %hash)     is true

If you now say

	undef $hash{'a'}

your table now reads:


	  keys  values
	+------+------+
	|  a   | undef|
	|  x   |  7   |
	|  d   |  0   |
	|  e   |  2   |
	+------+------+

and these conditions now hold; changes in caps:

	$hash{'a'}                       is FALSE
	$hash{'d'}                       is false
	defined $hash{'d'}               is true
	defined $hash{'a'}               is FALSE
	exists $hash{'a'}                is true (Perl 5 only)
	grep ($_ eq 'a', keys %hash)     is true

Notice the last two: you have an undef value, but a defined key!

Now, consider this:

	delete $hash{'a'}

your table now reads:

	  keys  values
	+------+------+
	|  x   |  7   |
	|  d   |  0   |
	|  e   |  2   |
	+------+------+

and these conditions now hold; changes in caps:

	$hash{'a'}                       is false
	$hash{'d'}                       is false
	defined $hash{'d'}               is true
	defined $hash{'a'}               is false
	exists $hash{'a'}                is FALSE (Perl 5 only)
	grep ($_ eq 'a', keys %hash)     is FALSE

See, the whole entry is gone!

=head2 Why don't my tied hashes make the defined/exists distinction?

This depends on the tied hash's implementation of EXISTS().
For example, there isn't the concept of undef with hashes
that are tied to DBM* files. It also means that exists() and
defined() do the same thing with a DBM* file, and what they
end up doing is not what they do with ordinary hashes.

=head2 How do I reset an each() operation part-way through?

(contributed by brian d foy)

You can use the C<keys> or C<values> functions to reset C<each>. To
simply reset the iterator used by C<each> without doing anything else,
use one of them in void context:

	keys %hash; # resets iterator, nothing else.
	values %hash; # resets iterator, nothing else.

See the documentation for C<each> in L<perlfunc>.

=head2 How can I get the unique keys from two hashes?

First you extract the keys from the hashes into lists, then solve
the "removing duplicates" problem described above.  For example:

	%seen = ();
	for $element (keys(%foo), keys(%bar)) {
		$seen{$element}++;
		}
	@@uniq = keys %seen;

Or more succinctly:

	@@uniq = keys %{{%foo,%bar}};

Or if you really want to save space:

	%seen = ();
	while (defined ($key = each %foo)) {
		$seen{$key}++;
	}
	while (defined ($key = each %bar)) {
		$seen{$key}++;
	}
	@@uniq = keys %seen;

=head2 How can I store a multidimensional array in a DBM file?

Either stringify the structure yourself (no fun), or else
get the MLDBM (which uses Data::Dumper) module from CPAN and layer
it on top of either DB_File or GDBM_File.

=head2 How can I make my hash remember the order I put elements into it?

Use the C<Tie::IxHash> from CPAN.

	use Tie::IxHash;

	tie my %myhash, 'Tie::IxHash';

	for (my $i=0; $i<20; $i++) {
		$myhash{$i} = 2*$i;
		}

	my @@keys = keys %myhash;
	# @@keys = (0,1,2,3,...)

=head2 Why does passing a subroutine an undefined element in a hash create it?

(contributed by brian d foy)

Are you using a really old version of Perl?

Normally, accessing a hash key's value for a nonexistent key will
I<not> create the key.

	my %hash  = ();
	my $value = $hash{ 'foo' };
	print "This won't print\n" if exists $hash{ 'foo' };

Passing C<$hash{ 'foo' }> to a subroutine used to be a special case, though.
Since you could assign directly to C<$_[0]>, Perl had to be ready to
make that assignment so it created the hash key ahead of time:

    my_sub( $hash{ 'foo' } );
	print "This will print before 5.004\n" if exists $hash{ 'foo' };

	sub my_sub {
		# $_[0] = 'bar'; # create hash key in case you do this
		1;
		}

Since Perl 5.004, however, this situation is a special case and Perl
creates the hash key only when you make the assignment:

    my_sub( $hash{ 'foo' } );
	print "This will print, even after 5.004\n" if exists $hash{ 'foo' };

	sub my_sub {
		$_[0] = 'bar';
		}

However, if you want the old behavior (and think carefully about that
because it's a weird side effect), you can pass a hash slice instead.
Perl 5.004 didn't make this a special case:

	my_sub( @@hash{ qw/foo/ } );

=head2 How can I make the Perl equivalent of a C structure/C++ class/hash or array of hashes or arrays?

Usually a hash ref, perhaps like this:

	$record = {
		NAME   => "Jason",
		EMPNO  => 132,
		TITLE  => "deputy peon",
		AGE    => 23,
		SALARY => 37_000,
		PALS   => [ "Norbert", "Rhys", "Phineas"],
	};

References are documented in L<perlref> and the upcoming L<perlreftut>.
Examples of complex data structures are given in L<perldsc> and
L<perllol>.  Examples of structures and object-oriented classes are
in L<perltoot>.

=head2 How can I use a reference as a hash key?

(contributed by brian d foy and Ben Morrow)

Hash keys are strings, so you can't really use a reference as the key.
When you try to do that, perl turns the reference into its stringified
form (for instance, C<HASH(0xDEADBEEF)>). From there you can't get
back the reference from the stringified form, at least without doing
some extra work on your own.

Remember that the entry in the hash will still be there even if
the referenced variable  goes out of scope, and that it is entirely
possible for Perl to subsequently allocate a different variable at
the same address. This will mean a new variable might accidentally
be associated with the value for an old.

If you have Perl 5.10 or later, and you just want to store a value
against the reference for lookup later, you can use the core
Hash::Util::Fieldhash module. This will also handle renaming the
keys if you use multiple threads (which causes all variables to be
reallocated at new addresses, changing their stringification), and
garbage-collecting the entries when the referenced variable goes out
of scope.

If you actually need to be able to get a real reference back from
each hash entry, you can use the Tie::RefHash module, which does the
required work for you.

=head1 Data: Misc

=head2 How do I handle binary data correctly?

Perl is binary clean, so it can handle binary data just fine.
On Windows or DOS, however, you have to use C<binmode> for binary
files to avoid conversions for line endings. In general, you should
use C<binmode> any time you want to work with binary data.

Also see L<perlfunc/"binmode"> or L<perlopentut>.

If you're concerned about 8-bit textual data then see L<perllocale>.
If you want to deal with multibyte characters, however, there are
some gotchas.  See the section on Regular Expressions.

=head2 How do I determine whether a scalar is a number/whole/integer/float?

Assuming that you don't care about IEEE notations like "NaN" or
"Infinity", you probably just want to use a regular expression.

	if (/\D/)            { print "has nondigits\n" }
	if (/^\d+$/)         { print "is a whole number\n" }
	if (/^-?\d+$/)       { print "is an integer\n" }
	if (/^[+-]?\d+$/)    { print "is a +/- integer\n" }
	if (/^-?\d+\.?\d*$/) { print "is a real number\n" }
	if (/^-?(?:\d+(?:\.\d*)?|\.\d+)$/) { print "is a decimal number\n" }
	if (/^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/)
			{ print "a C float\n" }

There are also some commonly used modules for the task.
L<Scalar::Util> (distributed with 5.8) provides access to perl's
internal function C<looks_like_number> for determining whether a
variable looks like a number.  L<Data::Types> exports functions that
validate data types using both the above and other regular
expressions. Thirdly, there is C<Regexp::Common> which has regular
expressions to match various types of numbers. Those three modules are
available from the CPAN.

If you're on a POSIX system, Perl supports the C<POSIX::strtod>
function.  Its semantics are somewhat cumbersome, so here's a
C<getnum> wrapper function for more convenient access.  This function
takes a string and returns the number it found, or C<undef> for input
that isn't a C float.  The C<is_numeric> function is a front end to
C<getnum> if you just want to say, "Is this a float?"

	sub getnum {
		use POSIX qw(strtod);
		my $str = shift;
		$str =~ s/^\s+//;
		$str =~ s/\s+$//;
		$! = 0;
		my($num, $unparsed) = strtod($str);
		if (($str eq '') || ($unparsed != 0) || $!) {
				return undef;
			}
		else {
			return $num;
			}
		}

	sub is_numeric { defined getnum($_[0]) }

Or you could check out the L<String::Scanf> module on the CPAN
instead. The C<POSIX> module (part of the standard Perl distribution)
provides the C<strtod> and C<strtol> for converting strings to double
and longs, respectively.

=head2 How do I keep persistent data across program calls?

For some specific applications, you can use one of the DBM modules.
See L<AnyDBM_File>.  More generically, you should consult the C<FreezeThaw>
or C<Storable> modules from CPAN.  Starting from Perl 5.8 C<Storable> is part
of the standard distribution.  Here's one example using C<Storable>'s C<store>
and C<retrieve> functions:

	use Storable;
	store(\%hash, "filename");

	# later on...
	$href = retrieve("filename");        # by ref
	%hash = %{ retrieve("filename") };   # direct to hash

=head2 How do I print out or copy a recursive data structure?

The C<Data::Dumper> module on CPAN (or the 5.005 release of Perl) is great
for printing out data structures.  The C<Storable> module on CPAN (or the
5.8 release of Perl), provides a function called C<dclone> that recursively
copies its argument.

	use Storable qw(dclone);
	$r2 = dclone($r1);

Where C<$r1> can be a reference to any kind of data structure you'd like.
It will be deeply copied.  Because C<dclone> takes and returns references,
you'd have to add extra punctuation if you had a hash of arrays that
you wanted to copy.

	%newhash = %{ dclone(\%oldhash) };

=head2 How do I define methods for every class/object?

(contributed by Ben Morrow)

You can use the C<UNIVERSAL> class (see L<UNIVERSAL>). However, please
be very careful to consider the consequences of doing this: adding
methods to every object is very likely to have unintended
consequences. If possible, it would be better to have all your object
inherit from some common base class, or to use an object system like
Moose that supports roles.

=head2 How do I verify a credit card checksum?

Get the C<Business::CreditCard> module from CPAN.

=head2 How do I pack arrays of doubles or floats for XS code?

The arrays.h/arrays.c code in the C<PGPLOT> module on CPAN does just this.
If you're doing a lot of float or double processing, consider using
the C<PDL> module from CPAN instead--it makes number-crunching easy.

See L<http://search.cpan.org/dist/PGPLOT> for the code.

=head1 AUTHOR AND COPYRIGHT

Copyright (c) 1997-2010 Tom Christiansen, Nathan Torkington, and
other authors as noted. All rights reserved.

This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.

Irrespective of its distribution, all code examples in this file
are hereby placed into the public domain.  You are permitted and
encouraged to use this code in your own programs for fun
or for profit as you see fit.  A simple comment in the code giving
credit would be courteous but is not required.
@


1.12
log
@merge in perl 5.12.2 plus local changes
@
text
@@


1.11
log
@Merge in perl 5.10.1
@
text
@d14 4
d28 1
a28 1
printf or sprintf function.  See the L<"Floating Point
d69 1
a69 1
same name a unix command that uses octal numbers as arguments on the
d304 2
a305 2
Use the Math::Matrix or Math::MatrixReal modules (available from CPAN)
or the PDL extension (also available from CPAN).
d349 1
a349 1
Get the http://www.cpan.org/modules/by-module/Roman module.
d365 1
a365 1
collection in http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz , courtesy
d375 1
a375 1
"Numerical Recipes in C" at http://www.nr.com/ .
d408 2
a409 2
The localtime function returns the day of the year.  Without an
argument localtime uses the current time.
d421 1
a421 1
a time in epoch seconds for the argument to localtime.
d540 18
a557 1
=head2 Does Perl have a Year 2000 problem? Is Perl Y2K compliant?
d559 5
a563 27
Short answer: No, Perl does not have a Year 2000 problem.  Yes, Perl is
Y2K compliant (whatever that means). The programmers you've hired to
use it, however, probably are not.

Long answer: The question belies a true understanding of the issue.
Perl is just as Y2K compliant as your pencil--no more, and no less.
Can you use your pencil to write a non-Y2K-compliant memo?  Of course
you can.  Is that the pencil's fault?  Of course it isn't.

The date and time functions supplied with Perl (gmtime and localtime)
supply adequate information to determine the year well beyond 2000
(2038 is when trouble strikes for 32-bit machines).  The year returned
by these functions when used in a list context is the year minus 1900.
For years between 1910 and 1999 this I<happens> to be a 2-digit decimal
number. To avoid the year 2000 problem simply do not treat the year as
a 2-digit number.  It isn't.

When gmtime() and localtime() are used in scalar context they return
a timestamp string that contains a fully-expanded year.  For example,
C<$timestamp = gmtime(1005613200)> sets $timestamp to "Tue Nov 13 01:00:00
2001".  There's no year 2000 problem here.

That doesn't mean that Perl can't be used to create non-Y2K compliant
programs.  It can.  But so can your pencil.  It's the fault of the user,
not the language.  At the risk of inflaming the NRA: "Perl doesn't
break Y2K, people do."  See http://www.perl.org/about/y2k.html for
a longer exposition.
a810 9
=head2 Does Perl have a Year 2038 problem?

No, all of Perl's built in date and time functions and modules will
work to about 2 billion years before and after 1970.

Many systems cannot count time past the year 2038.  Older versions of
Perl were dependent on the system to do date calculation and thus
shared their 2038 bug.

d985 1
a985 1
If you know where the columns that contain the data, you can
d1008 1
a1008 1
C<unpack> with the A (ASCII) format. by using a number after the format
d1204 32
a1235 18
An array has a changeable length.  A list does not.  An array is
something you can push or pop, while a list is a set of values.  Some
people make the distinction that a list is a value while an array is a
variable. Subroutines are passed and return lists, you put things into
list context, you initialize arrays with lists, and you C<foreach()>
across a list.  C<@@> variables are arrays, anonymous arrays are
arrays, arrays in scalar context behave like the number of elements in
them, subroutines access their arguments through the array C<@@_>, and
C<push>/C<pop>/C<shift> only work on arrays.

As a side note, there's no such thing as a list in scalar context.
When you say

	$scalar = (2, 5, 7, 9);

you're using the comma operator in scalar context, so it uses the scalar
comma operator.  There never was a list there at all! This causes the
last value to be returned: 9.
d1237 37
a1273 1
=head2 What is the difference between $array[1] and @@array[1]?
d1275 1
a1275 4
The former is a scalar value; the latter an array slice, making
it a list with one (scalar) value.  You should use $ when you want a
scalar value (most of the time) and @@ when you want a list with one
scalar value in it (very, very rarely; nearly never, in fact).
d1277 1
a1277 2
Sometimes it doesn't make a difference, but sometimes it does.
For example, compare:
d1279 1
a1279 1
	$good[0] = `some program that outputs several lines`;
d1281 27
a1307 1
with
d1309 1
a1309 1
	@@bad[0]  = `same program that outputs several lines`;
d1311 2
a1312 2
The C<use warnings> pragma and the B<-w> flag will warn you about these
matters.
d1619 1
a1619 1
If you want to cycle through an array endlessy, you can increment the
d2140 1
a2140 1
	
d2142 1
a2142 1
a bit different. You have to check each value. A C<grep> is handy: 
d2151 1
a2151 1
	
d2230 1
a2230 1
Pictures help...  here's the C<%hash> table:
a2575 8
=head1 REVISION

Revision: $Revision$

Date: $Date$

See L<perlfaq> for source control details and availability.

d2578 1
a2578 1
Copyright (c) 1997-2009 Tom Christiansen, Nathan Torkington, and
@


1.10
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d51 39
a89 29
Perl only understands octal and hex numbers as such when they occur as
literals in your program.  Octal literals in perl must start with a
leading C<0> and hexadecimal literals must start with a leading C<0x>.
If they are read in from somewhere and assigned, no automatic
conversion takes place.  You must explicitly use C<oct()> or C<hex()> if you
want the values converted to decimal.  C<oct()> interprets hexadecimal (C<0x350>),
octal (C<0350> or even without the leading C<0>, like C<377>) and binary
(C<0b1010>) numbers, while C<hex()> only converts hexadecimal ones, with
or without a leading C<0x>, such as C<0x255>, C<3A>, C<ff>, or C<deadbeef>.
The inverse mapping from decimal to octal can be done with either the
<%o> or C<%O> C<sprintf()> formats.

This problem shows up most often when people try using C<chmod()>,
C<mkdir()>, C<umask()>, or C<sysopen()>, which by widespread tradition
typically take permissions in octal.

	chmod(644,  $file);   # WRONG
	chmod(0644, $file);   # right

Note the mistake in the first line was specifying the decimal literal
C<644>, rather than the intended octal literal C<0644>.  The problem can
be seen with:

	printf("%#o",644);   # prints 01204

Surely you had not intended C<chmod(01204, $file);> - did you?  If you
want to use numeric literals as arguments to chmod() et al. then please
try to express them as octal constants, that is with a leading zero and
with the following digits restricted to the set C<0..7>.
d376 1
a376 1
builtin to get a random number between 0 and 1. From there, you shift
d386 1
a386 1
	my $number = 10 + int rand( 15-10+1 );
d491 3
d520 16
d812 9
d822 1
d824 1
a824 1
To make the first letter of each word upper case:
d826 2
a827 1
	$line =~ s/\b(\w)/\U$1/g;
d829 20
a848 3
This has the strange effect of turning "C<don't do it>" into "C<Don'T
Do It>".  Sometimes you might want this.  Other times you might need a
more thorough solution (Suggested by brian d foy):
d859 2
a860 28
To make the whole line upper case:

	$line = uc($line);

To force each word to be lower case, with the first letter upper case:

	$line =~ s/(\w+)/\u\L$1/g;

You can (and probably should) enable locale awareness of those
characters by placing a C<use locale> pragma in your program.
See L<perllocale> for endless details on locales.

This is sometimes referred to as putting something into "title
case", but that's not quite accurate.  Consider the proper
capitalization of the movie I<Dr. Strangelove or: How I Learned to
Stop Worrying and Love the Bomb>, for example.

Damian Conway's L<Text::Autoformat> module provides some smart
case transformations:

	use Text::Autoformat;
	my $x = "Dr. Strangelove or: How I Learned to Stop ".
	  "Worrying and Love the Bomb";

	print $x, "\n";
	for my $style (qw( sentence title highlight )) {
		print autoformat($x, { case => $style }), "\n";
		}
d1014 1
a1014 1
handle that fornat, such as C<Text::CSV>, C<Text::CSV_XS>, or
d1064 1
a1064 1
C</e> flag (twice even!), I have all of the same security problems I 
d1076 1
a1076 1
	
d1307 1
a1307 1
(portions of this answer contributed by Anno Siegel)
d1313 17
a1329 1
That being said, there are several ways to approach this.  If you
d1332 1
a1332 1
hash whose keys are the first array's values.
d1407 15
d1552 7
d1560 2
a1561 2
Circular lists could be handled in the traditional fashion with linked
lists, or you could just do something like this with an array:
d1563 4
a1566 2
	unshift(@@array, pop(@@array));  # the last shall be first
	push(@@array, shift(@@array));   # and vice versa
d1568 2
a1569 1
You can also use C<Tie::Cycle>:
d1579 13
d1605 2
d1746 1
a1746 1
	
d1803 4
a1806 2
For example, this sets C<$vec> to have bit N set if C<$ints[N]> was
set:
d1808 1
d1810 3
a1812 1
	foreach(@@ints) { vec($vec,$_,1) = 1 }
d1814 6
a1819 2
Here's how, given a vector in C<$vec>, you can get those bits into your
C<@@ints> array:
d1941 1
a1941 1
process the hashh elements. For instance, you can sort the keys so you
d1959 1
a1959 1
keys. To save some memory, you can grab on key-value pair at a time using
d1977 56
d2069 1
a2069 2
If you mean how many keys, then all you have to do is
use the keys() function in a scalar context:
d2071 21
a2091 1
    $num_keys = keys %hash;
d2093 3
a2095 1
The keys() function also resets the iterator, which means that you may
d2097 1
a2097 1
such as each().
d2113 1
a2113 1
		printf "%-20s %6d\n", $key, $hash{$value};
d2307 17
a2323 1
If you say something like:
d2325 7
a2331 1
	somefunc($hash{"nonesuch key here"});
d2333 6
a2338 4
Then that element "autovivifies"; that is, it springs into existence
whether you store something there or not.  That's because functions
get scalars passed in by reference.  If somefunc() modifies C<$_[0]>,
it has to be ready to write it back into the caller's version.
d2340 3
a2342 1
This has been fixed as of Perl5.004.
d2344 1
a2344 3
Normally, merely accessing a key's value for a nonexistent key does
I<not> cause that key to be forever there.  This is different than
awk's behavior.
d2366 1
a2366 1
(contributed by brian d foy)
d2372 1
a2372 3
some extra work on your own. Also remember that hash keys must be
unique, but two different variables can store the same reference (and
those variables can change later).
d2374 17
a2390 2
The C<Tie::RefHash> module, which is distributed with perl, might be
what you want. It handles that extra work.
d2493 8
a2500 1
Use the C<UNIVERSAL> class (see L<UNIVERSAL>).
d2508 1
a2508 1
The kgbpack.c code in the C<PGPLOT> module on CPAN does just this.
d2512 2
d2516 1
a2516 1
Revision: $Revision: 10394 $
d2518 1
a2518 1
Date: $Date: 2007-12-09 18:47:15 +0100 (Sun, 09 Dec 2007) $
d2524 1
a2524 1
Copyright (c) 1997-2007 Tom Christiansen, Nathan Torkington, and
@


1.9
log
@merge in perl 5.8.8
@
text
@d14 12
a25 12
Internally, your computer represents floating-point numbers
in binary. Digital (as in powers of two) computers cannot
store all numbers exactly.  Some real numbers lose precision
in the process.  This is a problem with how computers store
numbers and affects all computer languages, not just Perl.

L<perlnumber> show the gory details of number
representations and conversions.

To limit the number of decimal places in your numbers, you
can use the printf or sprintf function.  See the
L<"Floating Point Arithmetic"|perlop> for more details.
d33 1
a33 1
Your int() is most probably working just fine.  It's the numbers that
d36 1
a36 1
First, see the above item "Why am I getting long decimals
d42 1
a42 1
    print int(0.6/0.2-2), "\n";
d53 1
a53 1
leading "0" and hexadecimal literals must start with a leading "0x".
d55 5
a59 5
conversion takes place.  You must explicitly use oct() or hex() if you
want the values converted to decimal.  oct() interprets hex ("0x350"),
octal ("0350" or even without the leading "0", like "377") and binary
("0b1010") numbers, while hex() only converts hexadecimal ones, with
or without a leading "0x", like "0x255", "3A", "ff", or "deadbeef".
d61 1
a61 1
"%o" or "%O" sprintf() formats.
d63 3
a65 3
This problem shows up most often when people try using chmod(), mkdir(),
umask(), or sysopen(), which by widespread tradition typically take
permissions in octal.
d67 2
a68 2
    chmod(644,  $file);	# WRONG
    chmod(0644, $file);	# right
d71 1
a71 1
644, rather than the intended octal literal 0644.  The problem can
d74 1
a74 1
    printf("%#o",644); # prints 01204
d79 1
a79 1
with the following digits restricted to the set 0..7.
d83 13
a95 13
Remember that int() merely truncates toward 0.  For rounding to a
certain number of digits, sprintf() or printf() is usually the easiest
route.

    printf("%.3f", 3.1415926535);	# prints 3.142

The POSIX module (part of the standard Perl distribution) implements
ceil(), floor(), and a number of other mathematical and trigonometric
functions.

    use POSIX;
    $ceil   = ceil(3.5);			# 4
    $floor  = floor(3.5);			# 3
d97 2
a98 2
In 5.000 to 5.003 perls, trigonometry was done in the Math::Complex
module.  With 5.004, the Math::Trig module (part of the standard Perl
d100 1
a100 1
uses the Math::Complex module and some functions can break out from
d113 1
a113 1
    for ($i = 0; $i < 1.01; $i += 0.05) { printf "%.1f ",$i}
d115 2
a116 2
    0.0 0.1 0.1 0.2 0.2 0.2 0.3 0.3 0.4 0.4 0.5 0.5 0.6 0.7 0.7
    0.8 0.8 0.9 0.9 1.0 1.0
d118 4
a121 4
Don't blame Perl.  It's the same as in C.  IEEE says we have to do this.
Perl numbers whose absolute values are integers under 2**31 (on 32 bit
machines) will work pretty much like mathematical integers.  Other numbers
are not guaranteed.
d125 10
a134 10
As always with Perl there is more than one way to do it.  Below
are a few examples of approaches to making common conversions
between number representations.  This is intended to be representational
rather than exhaustive.

Some of the examples below use the Bit::Vector module from CPAN.
The reason you might choose Bit::Vector over the perl built in
functions is that it works with numbers of ANY size, that it is
optimized for speed on some operations, and for at least some
programmers the notation might be familiar.
d140 1
a140 1
Using perl's built in conversion of 0x notation:
d142 1
a142 1
    $dec = 0xDEADBEEF;
d144 1
a144 1
Using the hex function:
d146 1
a146 1
    $dec = hex("DEADBEEF");
d148 1
a148 1
Using pack:
d150 1
a150 1
    $dec = unpack("N", pack("H8", substr("0" x 8 . "DEADBEEF", -8)));
d152 1
a152 1
Using the CPAN module Bit::Vector:
d154 3
a156 3
    use Bit::Vector;
    $vec = Bit::Vector->new_Hex(32, "DEADBEEF");
    $dec = $vec->to_Dec();
d160 1
a160 1
Using sprintf:
d162 2
a163 2
    $hex = sprintf("%X", 3735928559); # upper case A-F
    $hex = sprintf("%x", 3735928559); # lower case a-f
d165 1
a165 1
Using unpack:
d167 1
a167 1
    $hex = unpack("H*", pack("N", 3735928559));
d169 1
a169 1
Using Bit::Vector:
d171 3
a173 3
    use Bit::Vector;
    $vec = Bit::Vector->new_Dec(32, -559038737);
    $hex = $vec->to_Hex();
d175 1
a175 1
And Bit::Vector supports odd bit counts:
d177 4
a180 4
    use Bit::Vector;
    $vec = Bit::Vector->new_Dec(33, 3735928559);
    $vec->Resize(32); # suppress leading 0 if unwanted
    $hex = $vec->to_Hex();
d186 1
a186 1
    $dec = 033653337357; # note the leading 0!
d188 1
a188 1
Using the oct function:
d190 1
a190 1
    $dec = oct("33653337357");
d192 1
a192 1
Using Bit::Vector:
d194 4
a197 4
    use Bit::Vector;
    $vec = Bit::Vector->new(32);
    $vec->Chunk_List_Store(3, split(//, reverse "33653337357"));
    $dec = $vec->to_Dec();
d201 1
a201 1
Using sprintf:
d203 1
a203 1
    $oct = sprintf("%o", 3735928559);
d205 1
a205 1
Using Bit::Vector:
d207 3
a209 3
    use Bit::Vector;
    $vec = Bit::Vector->new_Dec(32, -559038737);
    $oct = reverse join('', $vec->Chunk_List_Read(3));
d214 1
a214 1
the 0b notation:
d216 1
a216 1
    $number = 0b10110110;
d218 1
a218 1
Using oct:
d220 2
a221 2
    my $input = "10110110";
    $decimal = oct( "0b$input" );
d223 1
a223 1
Using pack and ord:
d225 1
a225 1
    $decimal = ord(pack('B8', '10110110'));
d227 1
a227 1
Using pack and unpack for larger strings:
d229 1
a229 1
    $int = unpack("N", pack("B32",
d231 1
a231 1
    $dec = sprintf("%d", $int);
d233 1
a233 1
    # substr() is used to left pad a 32 character string with zeros.
d235 1
a235 1
Using Bit::Vector:
d237 2
a238 2
    $vec = Bit::Vector->new_Bin(32, "11011110101011011011111011101111");
    $dec = $vec->to_Dec();
d242 1
a242 1
Using sprintf (perl 5.6+):
d244 1
a244 1
    $bin = sprintf("%b", 3735928559);
d246 1
a246 1
Using unpack:
d248 1
a248 1
    $bin = unpack("B*", pack("N", 3735928559));
d250 1
a250 1
Using Bit::Vector:
d252 3
a254 3
    use Bit::Vector;
    $vec = Bit::Vector->new_Dec(32, -559038737);
    $bin = $vec->to_Bin();
d277 3
a279 3
    if ("\020\020" & "\101\101") {
	# ...
    }
d284 3
a286 3
    if ( ("\020\020" & "\101\101") !~ /[^\000]/) {
	# ...
    }
d298 1
a298 1
    @@results = map { my_func($_) } @@array;
d302 1
a302 1
    @@triple = map { 3 * $_ } @@single;
d307 3
a309 3
    foreach $iterator (@@array) {
        some_func($iterator);
    }
d313 1
a313 1
    @@results = map { some_func($_) } (5 .. 25);
d319 4
a322 4
    @@results = ();
    for ($i=5; $i < 500_005; $i++) {
        push(@@results, some_func($i));
    }
d327 3
a329 3
    for my $i (5 .. 500_005) {
        push(@@results, some_func($i));
    }
d345 2
a346 2
call C<srand> more than once---you make your numbers less random, rather
than more.
d351 2
a352 2
collection in http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz , courtesy of
Tom Phoenix, talks more about this.  John von Neumann said, "Anyone
d357 1
a357 1
provides, you should also check out the Math::TrulyRandom module from
d365 7
a371 8
C<rand($x)> returns a number such that
C<< 0 <= rand($x) < $x >>. Thus what you want to have perl
figure out is a random number in the range from 0 to the
difference between your I<X> and I<Y>.

That is, to get a number between 10 and 15, inclusive, you
want a random number between 0 and 5 that you can then add
to 10.
d373 4
a376 1
    my $number = 10 + int rand( 15-10+1 );
d380 1
a380 1
integers (inclusive), For example: C<random_int_in(50,120)>.
d382 7
a388 7
   sub random_int_in ($$) {
     my($min, $max) = @@_;
      # Assumes that the two arguments are integers themselves!
     return $min if $min == $max;
     ($min, $max) = ($max, $min)  if  $min > $max;
     return $min + int rand(1 + $max - $min);
   }
d399 1
a399 1
The POSIX module can also format a date as the day of the year or
d406 1
a406 1
To get the day of year for any date, use the Time::Local module to get
d409 1
a409 2
	use POSIX qw/strftime/;
	use Time::Local;
d411 1
a411 1
		localtime( timelocal( 0, 0, 0, 18, 11, 1987 ) );
d413 1
a413 1
The Date::Calc module provides two functions to calculate these.
d423 3
a425 3
    sub get_century    {
	return int((((localtime(shift || time))[5] + 1999))/100);
    }
d427 3
a429 3
    sub get_millennium {
	return 1+int((((localtime(shift || time))[5] + 1899))/1000);
    }
d431 6
a436 6
On some systems, the POSIX module's strftime() function has
been extended in a non-standard way to use a C<%C> format,
which they sometimes claim is the "century".  It isn't,
because on most such systems, this is only the first two
digits of the four-digit year, and thus cannot be used to
reliably determine the current century or millennium.
d442 4
a445 4
You could just store all your dates as a number and then subtract. Life
isn't always that simple though. If you want to work with formatted
dates, the Date::Manip, Date::Calc, or DateTime modules can help you.

d451 2
a452 2
Time::Local module.  Otherwise, you should look into the Date::Calc
and Date::Manip modules from CPAN.
d458 2
a459 2
You can use the Time::JulianDay module available on CPAN.  Ensure that
you really want to find a Julian day, though, as many people have
d463 1
a463 1
You can also try the DateTime module, which can convert a date/time
d466 2
a467 2
  $ perl -MDateTime -le'print DateTime->today->jd'
  2453401.5
d471 2
a472 2
  $ perl -MDateTime -le'print DateTime->today->mjd'
  53401
d477 2
a478 2
  $ perl -MDateTime -le'print DateTime->today->doy'
  31
d493 1
a493 1
You can also use the C<Date::Calc> module using its Today_and_Now
d500 1
a500 1
	print "@@date\n";
d507 1
a507 1
=head2 Does Perl have a Year 2000 problem?  Is Perl Y2K compliant?
d510 1
a510 1
Y2K compliant (whatever that means).  The programmers you've hired to
d558 1
a558 1
    s/\\(.)/$1/g;
d573 1
a573 1
    s/(.)\1/$1/g;
d585 1
a585 1
    $str =~ tr///cs;       # Now Harlem, like in New York
d594 1
a594 1
have a more than one return value, we can construct and dereference an
d602 3
a604 1
that is up to you, and you can use code inside the braces.
d628 1
a628 1
	print "The time is " . localtime . ".\n";
d636 1
a636 1
C</alpha(.*?)omega/> would be needed.  But none of these deals with
d644 3
a646 3
the CPAN modules Parse::RecDescent, Parse::Yapp, and Text::Balanced;
and the byacc program.   Starting from perl 5.8 the Text::Balanced is
part of the standard distribution.
d651 3
a653 3
    while (s/BEGIN((?:(?!BEGIN)(?!END).)*)END//gs) {
	# do something with $1
    }
d660 9
a668 9
    # $_ contains the string to parse
    # BEGIN and END are the opening and closing markers for the
    # nested text.

    @@( = ('(','');
    @@) = (')','');
    ($re=$_)=~s/((BEGIN)|(END)|.)/$)[!$3]\Q$1\E$([!$2]/gs;
    @@$ = (eval{/$re/},$@@!~/unmatched/i);
    print join("\n",@@$[0..$#$]) if( $$[-1] );
d672 1
a672 1
Use reverse() in scalar context, as documented in
d675 1
a675 1
    $reversed = reverse $string;
d681 1
a681 1
    1 while $string =~ s/\t+/' ' x (length($&) * 8 - length($`) % 8)/e;
d683 1
a683 1
Or you can just use the Text::Tabs module (part of the standard Perl
d686 2
a687 2
    use Text::Tabs;
    @@expanded_lines = expand(@@lines_with_tabs);
d691 1
a691 1
Use Text::Wrap (part of the standard Perl distribution):
d693 2
a694 2
    use Text::Wrap;
    print wrap("\t", '  ', @@paragraphs);
d696 2
a697 2
The paragraphs you give to Text::Wrap should not contain embedded
newlines.  Text::Wrap doesn't justify the lines (flush-right).
d699 2
a700 2
Or use the CPAN module Text::Autoformat.  Formatting files can be easily
done by making a shell alias, like so:
d702 2
a703 2
    alias fmt="perl -i -MText::Autoformat -n0777 \
        -e 'print autoformat $_, {all=>1}' $*"
d705 1
a705 1
See the documentation for Text::Autoformat to appreciate its many
d716 1
a716 1
    $first_char = substr( $string, 0, 1 );  #  'J'
d721 1
a721 1
    substr( $string, 13, 4, "Perl 5.8.0" );
d725 1
a725 1
    substr( $string, 13, 4 ) =  "Perl 5.8.0";
d734 6
a739 6
    $count = 0;
    s{((whom?)ever)}{
	++$count == 5   	# is it the 5th?
	    ? "${2}soever"	# yes, swap
	    : $1		# renege and leave it there
    }ige;
d744 8
a751 8
    $WANT = 3;
    $count = 0;
    $_ = "One fish two fish red fish blue fish";
    while (/(\w+)\s+fish\b/gi) {
        if (++$count == $WANT) {
            print "The third fish is a $1 one.\n";
        }
    }
d756 1
a756 1
    /(?:\w+\s+fish\s+){2}(\w+)\s+fish/i;
d764 3
a766 3
    $string = "ThisXlineXhasXsomeXx'sXinXit";
    $count = ($string =~ tr/X//);
    print "There are $count X characters in the string";
d774 3
a776 3
    $string = "-9 55 48 -2 23 -76 4 14 -44";
    while ($string =~ /-\d+/g) { $count++ }
    print "There are $count negative numbers in the string";
d787 1
a787 1
        $line =~ s/\b(\w)/\U$1/g;
d793 8
a800 7
    $string =~ s/ (
                 (^\w)    #at the beginning of the line
                   |      # or
                 (\s\w)   #preceded by whitespace
                   )
                /\U$1/xg;
    $string =~ /([\w']+)/\u\L$1/g;
d804 1
a804 1
        $line = uc($line);
d808 1
a808 1
        $line =~ s/(\w+)/\u\L$1/g;
d822 8
a829 9
    use Text::Autoformat;
    my $x = "Dr. Strangelove or: How I Learned to Stop ".
      "Worrying and Love the Bomb";

    print $x, "\n";
    for my $style (qw( sentence title highlight ))
    {
        print autoformat($x, { case => $style }), "\n";
    }
d833 2
a834 2
Several modules can handle this sort of pasing---Text::Balanced,
Text::CSV, Text::CSV_XS, and Text::ParseWords, among others.
d841 1
a841 1
    SAR001,"","Cimetrix, Inc","Bob Smith","CAM",N,8,1,0,7,"Error, Core Dumped"
d846 1
a846 1
suggests (assuming your string is contained in $text):
d848 7
a854 7
     @@new = ();
     push(@@new, $+) while $text =~ m{
         "([^\"\\]*(?:\\.[^\"\\]*)*)",?  # groups the phrase inside the quotes
       | ([^,]+),?
       | ,
     }gx;
     push(@@new, undef) if substr($text,-1,1) eq ',';
d860 2
a861 5
Alternatively, the Text::ParseWords module (part of the standard Perl
distribution) lets you say:

    use Text::ParseWords;
    @@new = quotewords(",", 0, $text);
d863 2
a864 1
There's also a Text::CSV (Comma-Separated Values) module on CPAN.
d905 1
a905 1
    $string =~ s/^\s+|\s+$//gm;
d930 1
a930 1
    # Left padding a string with blanks (no truncation):
d934 1
a934 1
    # Right padding a string with blanks (no truncation):
d938 1
a938 1
    # Left padding a number with 0 (no truncation):
d942 2
a943 2
    # Right padding a string with blanks using pack (will truncate):
    $padded = pack("A$pad_len",$text);
d952 2
a953 2
    $padded = $pad_char x ( $pad_len - length( $text ) ) . $text;
    $padded = $text . $pad_char x ( $pad_len - length( $text ) );
d957 2
a958 2
    substr( $text, 0, 0 ) = $pad_char x ( $pad_len - length( $text ) );
    $text .= $pad_char x ( $pad_len - length( $text ) );
d962 33
a994 19
Use substr() or unpack(), both documented in L<perlfunc>.
If you prefer thinking in terms of columns instead of widths,
you can use this kind of thing:

    # determine the unpack format needed to split Linux ps output
    # arguments are cut columns
    my $fmt = cut2fmt(8, 14, 20, 26, 30, 34, 41, 47, 59, 63, 67, 72);

    sub cut2fmt {
	my(@@positions) = @@_;
	my $template  = '';
	my $lastpos   = 1;
	for my $place (@@positions) {
	    $template .= "A" . ($place - $lastpos) . " ";
	    $lastpos   = $place;
	}
	$template .= "A*";
	return $template;
    }
d1001 2
a1002 2
matching, you might also try the String::Approx, and Text::Metaphone,
and Text::DoubleMetaphone modules.
d1006 1
a1006 2
Let's assume that you have a string that contains placeholder
variables.
d1008 46
a1053 1
    $text = 'this has a $foo in it and a $bar';
d1055 1
a1055 17
You can use a substitution with a double evaluation.  The
first /e turns C<$1> into C<$foo>, and the second /e turns
C<$foo> into its value.  You may want to wrap this in an
C<eval>: if you try to get the value of an undeclared variable
while running under C<use strict>, you get a fatal error.

    eval { $text =~ s/(\$\w+)/$1/eeg };
    die if $@@;

It's probably better in the general case to treat those
variables as entries in some special hash.  For example:

    %user_defs = (
	foo  => 23,
	bar  => 19,
    );
    $text =~ s/\$(\w+)/$user_defs{$1}/g;
d1059 4
a1062 4
The problem is that those double-quotes force stringification--
coercing numbers and references into strings--even when you
don't want them to be strings.  Think of it this way: double-quote
expansion is used to produce new strings.  If you already
d1067 3
a1069 3
    print "$var";   	# BAD
    $new = "$old";   	# BAD
    somefunc("$var");	# BAD
d1074 3
a1076 3
    print $var;
    $new = $old;
    somefunc($var);
d1082 5
a1086 5
    func(\@@array);
    sub func {
	my $aref = shift;
	my $oref = "$aref";  # WRONG
    }
d1095 3
a1097 3
    @@lines = `command`;
    print "@@lines";		# WRONG - extra blanks
    print @@lines;		# right
d1155 1
a1155 1
    $remember_the_main = fix<<'    MAIN_INTERPRETER_LOOP';
d1164 1
a1164 1
    MAIN_INTERPRETER_LOOP
d1169 1
a1169 1
    $poem = fix<<EVER_ON_AND_ON;
d1177 1
a1177 1
    EVER_ON_AND_ON
d1183 9
a1191 9
An array has a changeable length.  A list does not.  An array is something
you can push or pop, while a list is a set of values.  Some people make
the distinction that a list is a value while an array is a variable.
Subroutines are passed and return lists, you put things into list
context, you initialize arrays with lists, and you foreach() across
a list.  C<@@> variables are arrays, anonymous arrays are arrays, arrays
in scalar context behave like the number of elements in them, subroutines
access their arguments through the array C<@@_>, and push/pop/shift only work
on arrays.
d1196 1
a1196 1
    $scalar = (2, 5, 7, 9);
d1199 1
a1199 1
comma operator.  There never was a list there at all!  This causes the
d1212 1
a1212 1
    $good[0] = `some program that outputs several lines`;
d1216 1
a1216 1
    @@bad[0]  = `same program that outputs several lines`;
d1233 10
a1242 3
   my %hash   = map { $_, 1 } @@array;
   # or a hash slice: @@hash{ @@array } = ();
   # or a foreach: $hash{$_} = 1 foreach ( @@array );
d1244 4
a1247 1
   my @@unique = keys %hash;
d1256 2
a1257 2
undef), so the next skips that iteration and the loop goes to the next
element.
d1271 2
a1272 2
   my %seen = ();
   my @@unique = grep { ! $seen{ $_ }++ } @@array;
d1287 3
a1289 3
    @@blues = qw/azure cerulean teal turquoise lapis-lazuli/;
    %is_blue = ();
    for (@@blues) { $is_blue{$_} = 1 }
d1291 2
a1292 2
Now you can check whether $is_blue{$some_color}.  It might have been a
good idea to keep the blues all in a hash in the first place.
d1297 4
a1300 4
    @@primes = (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31);
    @@is_tiny_prime = ();
    for (@@primes) { $is_tiny_prime[$_] = 1 }
    # or simply  @@istiny_prime[@@primes] = (1) x @@primes;
d1307 3
a1309 3
    @@articles = ( 1..10, 150..2000, 2017 );
    undef $read;
    for (@@articles) { vec($read,$_,1) = 1 }
d1317 1
a1317 1
If you are testing only once, the standard module List::Util exports
d1319 1
a1319 1
finds the element. It's written in C for speed, and its Perl equivalant
d1344 2
a1345 2
Use a hash.  Here's code to do both and more.  It assumes that
each element is unique in a given array:
d1347 7
a1353 7
    @@union = @@intersection = @@difference = ();
    %count = ();
    foreach $element (@@array1, @@array2) { $count{$element}++ }
    foreach $element (keys %count) {
	push @@union, $element;
	push @@{ $count{$element} > 1 ? \@@intersection : \@@difference }, $element;
    }
d1355 2
a1356 2
Note that this is the I<symmetric difference>, that is, all elements in
either A or in B but not in both.  Think of it as an xor operation.
d1360 15
a1374 15
The following code works for single-level arrays.  It uses a stringwise
comparison, and does not distinguish defined versus undefined empty
strings.  Modify if you have other needs.

    $are_equal = compare_arrays(\@@frogs, \@@toads);

    sub compare_arrays {
	my ($first, $second) = @@_;
	no warnings;  # silence spurious -w undef complaints
	return 0 unless @@$first == @@$second;
	for (my $i = 0; $i < @@$first; $i++) {
	    return 0 if $first->[$i] ne $second->[$i];
	}
	return 1;
    }
d1377 1
a1377 1
like this one.  It uses the CPAN module FreezeThaw:
d1379 2
a1380 2
    use FreezeThaw qw(cmpStr);
    @@a = @@b = ( "this", "that", [ "more", "stuff" ] );
d1382 4
a1385 4
    printf "a and b contain %s arrays\n",
        cmpStr(\@@a, \@@b) == 0
	    ? "the same"
	    : "different";
d1387 2
a1388 2
This approach also works for comparing hashes.  Here
we'll demonstrate two different answers:
d1390 1
a1390 1
    use FreezeThaw qw(cmpStr cmpStrHard);
d1392 3
a1394 3
    %a = %b = ( "this" => "that", "extra" => [ "more", "stuff" ] );
    $a{EXTRA} = \%b;
    $b{EXTRA} = \%a;
d1396 1
a1396 1
    printf "a and b contain %s hashes\n",
d1399 1
a1399 1
    printf "a and b contain %s hashes\n",
d1410 3
a1412 2
use the first() function in the List::Util module, which comes with
Perl 5.8.  This example finds the first element that contains "Perl".
d1418 1
a1418 1
If you cannot use List::Util, you can make your own loop to do the
d1422 1
a1422 2
	foreach ( @@array )
		{
d1431 2
a1432 4
	for( $i = 0; $i < @@array; $i++ )
		{
		if( $array[$i] =~ /Perl/ )
			{
d1442 6
a1447 6
regular arrays, you can push and pop or shift and unshift at either end,
or you can use splice to add and/or remove arbitrary number of elements at
arbitrary points.  Both pop and shift are both O(1) operations on Perl's
dynamic arrays.  In the absence of shifts and pops, push in general
needs to reallocate on the order every log(N) times, and unshift will
need to copy pointers each time.
d1450 2
a1451 2
L<perldsc> or L<perltoot> and do just what the algorithm book tells you
to do.  For example, imagine a list node like this:
d1453 4
a1456 4
    $node = {
        VALUE => 42,
        LINK  => undef,
    };
d1460 5
a1464 5
    print "List: ";
    for ($node = $head;  $node; $node = $node->{LINK}) {
        print $node->{VALUE}, " ";
    }
    print "\n";
d1468 5
a1472 5
    my ($head, $tail);
    $tail = append($head, 1);       # grow a new head
    for $value ( 2 .. 10 ) {
        $tail = append($tail, $value);
    }
d1474 12
a1485 11
    sub append {
        my($list, $value) = @@_;
        my $node = { VALUE => $value };
        if ($list) {
            $node->{LINK} = $list->{LINK};
            $list->{LINK} = $node;
        } else {
            $_[0] = $node;      # replace caller's version
        }
        return $node;
    }
d1494 12
a1505 2
    unshift(@@array, pop(@@array));  # the last shall be first
    push(@@array, shift(@@array));   # and vice versa
d1512 1
a1512 1
    use List::Util 'shuffle';
d1518 8
a1525 8
    sub fisher_yates_shuffle {
        my $deck = shift;  # $deck is a reference to an array
        my $i = @@$deck;
        while (--$i) {
            my $j = int rand ($i+1);
            @@$deck[$i,$j] = @@$deck[$j,$i];
        }
    }
d1527 5
a1531 5
    # shuffle my mpeg collection
    #
    my @@mpeg = <audio/*/*.mp3>;
    fisher_yates_shuffle( \@@mpeg );    # randomize @@mpeg in place
    print @@mpeg;
d1534 1
a1534 1
unlike the List::Util::shuffle() which takes a list and returns
d1540 6
a1545 6
    srand;
    @@new = ();
    @@old = 1 .. 10;  # just a demo
    while (@@old) {
	push(@@new, splice(@@old, rand @@old, 1));
    }
d1547 4
a1550 4
This is bad because splice is already O(N), and since you do it N times,
you just invented a quadratic algorithm; that is, O(N**2).  This does
not scale, although Perl is so efficient that you probably won't notice
this until you have rather largish arrays.
d1556 1
a1556 1
    for (@@lines) {
d1559 1
a1559 1
    }
d1563 1
a1563 1
    for (@@volumes = @@radii) {   # @@volumes has changed parts
d1566 1
a1566 1
    }
d1568 1
a1568 1
which can also be done with map() which is made to transform
d1578 1
a1578 1
    for $orbit ( values %orbits ) {
d1580 1
a1580 1
    }
d1589 1
a1589 1
Use the rand() function (see L<perlfunc/rand>):
d1591 2
a1592 2
    $index   = rand @@array;
    $element = $array[$index];
d1595 2
a1596 1
    my $element = $array[ rand @@array ];
d1599 2
d1602 3
a1604 3
Use the List::Permutor module on CPAN.  If the list is
actually an array, try the Algorithm::Permute module (also
on CPAN).  It's written in XS code and is very efficient.
d1607 1
d1610 1
d1613 1
a1613 1
	}
d1617 12
a1628 11
   use Algorithm::Permute;
   my @@array = 'a'..'d';
   Algorithm::Permute::permute {
      print "next permutation: (@@array)\n";
   } @@array;

Here's a little program that generates all permutations of
all the words on each line of input. The algorithm embodied
in the permute() function is discussed in Volume 4 (still
unpublished) of Knuth's I<The Art of Computer Programming>
and will work on any list:
d1631 1
a1631 1
	# Fischer-Kause ordered permutation generator
d1646 16
a1661 1
	permute {print"@@_\n"} split;
d1667 1
a1667 1
    @@list = sort { $a <=> $b } @@list;
d1680 6
a1685 6
    @@idx = ();
    for (@@data) {
	($item) = /\d+\s*(\S+)/;
	push @@idx, uc($item);
    }
    @@sorted = @@data[ sort { $idx[$a] cmp $idx[$b] } 0 .. $#idx ];
d1690 3
a1692 3
    @@sorted = map  { $_->[0] }
	      sort { $a->[1] cmp $b->[1] }
	      map  { [ $_, uc( (/\d+\s*(\S+)/)[0]) ] } @@data;
d1696 5
a1700 4
    @@sorted = sort { field1($a) <=> field1($b) ||
                     field2($a) cmp field2($b) ||
                     field3($a) cmp field3($b)
                   }     @@data;
d1709 1
a1709 1
See also the question below on sorting hashes.
d1713 2
a1714 1
Use pack() and unpack(), or else vec() and the bitwise operations.
d1716 2
a1717 1
For example, this sets $vec to have bit N set if $ints[N] was set:
d1719 2
a1720 2
    $vec = '';
    foreach(@@ints) { vec($vec,$_,1) = 1 }
d1722 34
a1755 31
Here's how, given a vector in $vec, you can
get those bits into your @@ints array:

    sub bitvec_to_list {
	my $vec = shift;
	my @@ints;
	# Find null-byte density then select best algorithm
	if ($vec =~ tr/\0// / length $vec > 0.95) {
	    use integer;
	    my $i;
	    # This method is faster with mostly null-bytes
	    while($vec =~ /[^\0]/g ) {
		$i = -9 + 8 * pos $vec;
		push @@ints, $i if vec($vec, ++$i, 1);
		push @@ints, $i if vec($vec, ++$i, 1);
		push @@ints, $i if vec($vec, ++$i, 1);
		push @@ints, $i if vec($vec, ++$i, 1);
		push @@ints, $i if vec($vec, ++$i, 1);
		push @@ints, $i if vec($vec, ++$i, 1);
		push @@ints, $i if vec($vec, ++$i, 1);
		push @@ints, $i if vec($vec, ++$i, 1);
	    }
	} else {
	    # This method is a fast general algorithm
	    use integer;
	    my $bits = unpack "b*", $vec;
	    push @@ints, 0 if $bits =~ s/^(\d)// && $1;
	    push @@ints, pos $bits while($bits =~ /1/g);
	}
	return \@@ints;
    }
d1764 2
a1765 2
	   push @@ints, grep vec($vec, $_, 1), $-[0] * 8 .. $+[0] * 8;
	}
d1767 1
a1767 1
Or use the CPAN module Bit::Vector:
d1769 3
a1771 3
    $vector = Bit::Vector->new($num_of_bits);
    $vector->Index_List_Store(@@ints);
    @@ints = $vector->Index_List_Read();
d1773 2
a1774 2
Bit::Vector provides efficient methods for bit vector, sets of small integers
and "big int" math.
d1778 3
a1780 3
    # vec demo
    $vector = "\xff\x0f\xef\xfe";
    print "Ilya's string \\xff\\x0f\\xef\\xfe represents the number ",
d1782 2
a1783 23
    $is_set = vec($vector, 23, 1);
    print "Its 23rd bit is ", $is_set ? "set" : "clear", ".\n";
    pvec($vector);

    set_vec(1,1,1);
    set_vec(3,1,1);
    set_vec(23,1,1);

    set_vec(3,1,3);
    set_vec(3,2,3);
    set_vec(3,4,3);
    set_vec(3,4,7);
    set_vec(3,8,3);
    set_vec(3,8,7);

    set_vec(0,32,17);
    set_vec(1,32,17);

    sub set_vec {
	my ($offset, $width, $value) = @@_;
	my $vector = '';
	vec($vector, $offset, $width) = $value;
	print "offset=$offset width=$width value=$value\n";
a1784 1
    }
d1786 32
a1817 10
    sub pvec {
	my $vector = shift;
	my $bits = unpack("b*", $vector);
	my $i = 0;
	my $BASE = 8;

	print "vector length in bytes: ", length($vector), "\n";
	@@bytes = unpack("A8" x length($vector), $bits);
	print "bits are: @@bytes\n\n";
    }
d1829 40
a1868 2
Use the each() function (see L<perlfunc/each>) if you don't care
whether it's sorted:
d1870 2
a1871 3
    while ( ($key, $value) = each %hash) {
	print "$key = $value\n";
    }
d1873 7
a1879 2
If you want it sorted, you'll have to use foreach() on the result of
sorting the keys as shown in an earlier question.
d1897 2
a1898 2
    %by_value = reverse %by_key;
    $key = $by_value{$value};
d1903 3
a1905 3
    while (($key, $value) = each %by_key) {
	$by_value{$value} = $key;
    }
d1911 3
a1913 3
     while (($key, $value) = each %by_key) {
	 push @@{$key_list_by_value{$value}}, $key;
     }
d1974 1
d1976 6
a1981 3
You can look into using the DB_File module and tie() using the
$DB_BTREE hash bindings as documented in L<DB_File/"In Memory Databases">.
The Tie::IxHash module from CPAN might also be instructive.
d1988 1
a1988 1
number, or reference.  If a key $key is present in
d1995 1
a1995 1
Pictures help...  here's the %hash table:
d2011 1
a2011 1
	exists $hash{'a'}                is true (Perl5 only)
d2035 1
a2035 1
	exists $hash{'a'}                is true (Perl5 only)
d2059 1
a2059 1
	exists $hash{'a'}                is FALSE (Perl5 only)
d2074 10
a2083 4
Using C<keys %hash> in scalar context returns the number of keys in
the hash I<and> resets the iterator associated with the hash.  You may
need to do this if you use C<last> to exit a loop early so that when you
re-enter it, the hash iterator has been reset.
d2090 5
a2094 5
    %seen = ();
    for $element (keys(%foo), keys(%bar)) {
	$seen{$element}++;
    }
    @@uniq = keys %seen;
d2098 1
a2098 1
    @@uniq = keys %{{%foo,%bar}};
d2102 8
a2109 8
    %seen = ();
    while (defined ($key = each %foo)) {
        $seen{$key}++;
    }
    while (defined ($key = each %bar)) {
        $seen{$key}++;
    }
    @@uniq = keys %seen;
d2119 1
a2119 1
Use the Tie::IxHash from CPAN.
d2121 10
a2130 7
    use Tie::IxHash;
    tie my %myhash, 'Tie::IxHash';
    for (my $i=0; $i<20; $i++) {
        $myhash{$i} = 2*$i;
    }
    my @@keys = keys %myhash;
    # @@keys = (0,1,2,3,...)
d2136 1
a2136 1
    somefunc($hash{"nonesuch key here"});
d2153 8
a2160 8
    $record = {
        NAME   => "Jason",
        EMPNO  => 132,
        TITLE  => "deputy peon",
        AGE    => 23,
        SALARY => 37_000,
        PALS   => [ "Norbert", "Rhys", "Phineas"],
    };
d2173 5
a2177 5
form (for instance, C<HASH(0xDEADBEEF)>). From there you can't get back
the reference from the stringified form, at least without doing some
extra work on your own. Also remember that hash keys must be unique, but
two different variables can store the same reference (and those variables
can change later).
d2179 2
a2180 2
The Tie::RefHash module, which is distributed with perl, might be what
you want. It handles that extra work.
d2186 4
a2189 2
Perl is binary clean, so this shouldn't be a problem.  For example,
this works fine (assuming the files are found):
d2191 1
a2191 9
    if (`cat /vmunix` =~ /gzip/) {
	print "Your kernel is GNU-zip enabled!\n";
    }

On less elegant (read: Byzantine) systems, however, you have
to play tedious games with "text" versus "binary" files.  See
L<perlfunc/"binmode"> or L<perlopentut>.

If you're concerned about 8-bit ASCII data, then see L<perllocale>.
d2193 1
d2202 7
a2208 7
   if (/\D/)            { print "has nondigits\n" }
   if (/^\d+$/)         { print "is a whole number\n" }
   if (/^-?\d+$/)       { print "is an integer\n" }
   if (/^[+-]?\d+$/)    { print "is a +/- integer\n" }
   if (/^-?\d+\.?\d*$/) { print "is a real number\n" }
   if (/^-?(?:\d+(?:\.\d*)?|\.\d+)$/) { print "is a decimal number\n" }
   if (/^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/)
d2213 6
a2218 7
internal function C<looks_like_number> for determining
whether a variable looks like a number.  L<Data::Types>
exports functions that validate data types using both the
above and other regular expressions. Thirdly, there is
C<Regexp::Common> which has regular expressions to match
various types of numbers. Those three modules are available
from the CPAN.
d2221 20
a2240 19
function.  Its semantics are somewhat cumbersome, so here's a C<getnum>
wrapper function for more convenient access.  This function takes
a string and returns the number it found, or C<undef> for input that
isn't a C float.  The C<is_numeric> function is a front end to C<getnum>
if you just want to say, "Is this a float?"

    sub getnum {
        use POSIX qw(strtod);
        my $str = shift;
        $str =~ s/^\s+//;
        $str =~ s/\s+$//;
        $! = 0;
        my($num, $unparsed) = strtod($str);
        if (($str eq '') || ($unparsed != 0) || $!) {
            return undef;
        } else {
            return $num;
        }
    }
d2242 1
a2242 1
    sub is_numeric { defined getnum($_[0]) }
d2245 3
a2247 3
instead. The POSIX module (part of the standard Perl distribution) provides
the C<strtod> and C<strtol> for converting strings to double and longs,
respectively.
d2252 3
a2254 3
See L<AnyDBM_File>.  More generically, you should consult the FreezeThaw
or Storable modules from CPAN.  Starting from Perl 5.8 Storable is part
of the standard distribution.  Here's one example using Storable's C<store>
d2257 2
a2258 2
    use Storable;
    store(\%hash, "filename");
d2260 3
a2262 3
    # later on...
    $href = retrieve("filename");        # by ref
    %hash = %{ retrieve("filename") };   # direct to hash
d2266 2
a2267 2
The Data::Dumper module on CPAN (or the 5.005 release of Perl) is great
for printing out data structures.  The Storable module on CPAN (or the
d2271 2
a2272 2
    use Storable qw(dclone);
    $r2 = dclone($r1);
d2274 1
a2274 1
Where $r1 can be a reference to any kind of data structure you'd like.
d2279 1
a2279 1
    %newhash = %{ dclone(\%oldhash) };
d2283 1
a2283 1
Use the UNIVERSAL class (see L<UNIVERSAL>).
d2287 1
a2287 1
Get the Business::CreditCard module from CPAN.
d2291 1
a2291 1
The kgbpack.c code in the PGPLOT module on CPAN does just this.
d2293 9
a2301 1
the PDL module from CPAN instead--it makes number-crunching easy.
d2305 1
a2305 1
Copyright (c) 1997-2006 Tom Christiansen, Nathan Torkington, and
@


1.8
log
@sync in-tree perl with 5.8.6
@
text
@d3 1
a3 1
perlfaq4 - Data Manipulation ($Revision: 1.7 $, $Date: 2004/04/07 21:33:08 $)
d352 1
a352 1
Tom Phoenix, talks more about this.  John von Neumann said, ``Anyone
d354 1
a354 1
course, living in a state of sin.''
d361 1
a361 1
``Numerical Recipes in C'' at http://www.nr.com/ .
d392 1
a392 1
The localtime function returns the day of the week.  Without an
d395 1
a395 1
    $day_of_year = (localtime)[7];
d409 1
a409 1
	my $week_of_year = strftime "%W", 
d412 1
a412 1
The Date::Calc module provides two functions for to calculate these.
d425 1
d439 6
a444 9
If you're storing your dates as epoch seconds then simply subtract one
from the other.  If you've got a structured date (distinct year, day,
month, hour, minute, seconds values), then for reasons of accessibility,
simplicity, and efficiency, merely use either timelocal or timegm (from
the Time::Local module in the standard distribution) to reduce structured
dates to epoch seconds.  However, if you don't know the precise format of
your dates, then you should probably use either of the Date::Manip and
Date::Calc modules from CPAN before you go hacking up your own parsing
routine to handle arbitrary date formats.
d455 9
a463 2
Use the Time::JulianDay module (part of the Time-modules bundle
available from CPAN.)
d465 13
a477 17
Before you immerse yourself too deeply in this, be sure to verify that
it is the I<Julian> Day you really want.  Are you interested in a way
of getting serial days so that you just can tell how many days they
are apart or so that you can do also other date arithmetic?  If you
are interested in performing date arithmetic, this can be done using
modules Date::Manip or Date::Calc.

There is too many details and much confusion on this issue to cover in
this FAQ, but the term is applied (correctly) to a calendar now
supplanted by the Gregorian Calendar, with the Julian Calendar failing
to adjust properly for leap years on centennial years (among other
annoyances).  The term is also used (incorrectly) to mean: [1] days in
the Gregorian Calendar; and [2] days since a particular starting time
or `epoch', usually 1970 in the Unix world and 1980 in the
MS-DOS/Windows world.  If you find that it is not the first meaning
that you really want, then check out the Date::Manip and Date::Calc
modules.  (Thanks to David Cassell for most of this text.)
d481 1
a481 2
If you only need to find the date (and not the same time), you
can use the Date::Calc module.
d483 2
a484 1
	use Date::Calc qw(Today Add_Delta_Days);
d486 1
a486 1
	my @@date = Add_Delta_Days( Today(), -1 );
d488 1
a488 1
	print "@@date\n";
d490 1
a490 13
Most people try to use the time rather than the calendar to
figure out dates, but that assumes that your days are
twenty-four hours each.  For most people, there are two days
a year when they aren't: the switch to and from summer time
throws this off. Russ Allbery offers this solution.

    sub yesterday {
		my $now  = defined $_[0] ? $_[0] : time;
		my $then = $now - 60 * 60 * 24;
		my $ndst = (localtime $now)[8] > 0;
		my $tdst = (localtime $then)[8] > 0;
		$then - ($tdst - $ndst) * 60 * 60;
		}
d492 2
a493 27
Should give you "this time yesterday" in seconds since epoch relative to
the first argument or the current time if no argument is given and
suitable for passing to localtime or whatever else you need to do with
it.  $ndst is whether we're currently in daylight savings time; $tdst is
whether the point 24 hours ago was in daylight savings time.  If $tdst
and $ndst are the same, a boundary wasn't crossed, and the correction
will subtract 0.  If $tdst is 1 and $ndst is 0, subtract an hour more
from yesterday's time since we gained an extra hour while going off
daylight savings time.  If $tdst is 0 and $ndst is 1, subtract a
negative hour (add an hour) to yesterday's time since we lost an hour.

All of this is because during those days when one switches off or onto
DST, a "day" isn't 24 hours long; it's either 23 or 25.

The explicit settings of $ndst and $tdst are necessary because localtime
only says it returns the system tm struct, and the system tm struct at
least on Solaris doesn't guarantee any particular positive value (like,
say, 1) for isdst, just a positive value.  And that value can
potentially be negative, if DST information isn't available (this sub
just treats those cases like no DST).

Note that between 2am and 3am on the day after the time zone switches
off daylight savings time, the exact hour of "yesterday" corresponding
to the current hour is not clearly defined.  Note also that if used
between 2am and 3am the day after the change to daylight savings time,
the result will be between 3am and 4am of the previous day; it's
arguable whether this is correct.
d495 1
a495 1
This sub does not attempt to deal with leap seconds (most things don't).
d497 1
d499 6
d532 2
a533 2
not the language.  At the risk of inflaming the NRA: ``Perl doesn't
break Y2K, people do.''  See http://www.perl.org/about/y2k.html for
d540 10
a549 3
The answer to this question is usually a regular expression, perhaps
with auxiliary logic.  See the more specific questions (numbers, mail
addresses, etc.) for details.
d553 1
a553 1
It depends just what you mean by ``escape''.  URL escapes are dealt
d563 1
a563 1
To turn C<"abbcccd"> into C<"abccd">:
d565 17
a581 1
    s/(.)\1/$1/g;	# add /s to include newlines
d583 2
a584 1
Here's a solution that turns "abbcccd" to "abcd":
d586 3
a588 1
    y///cs;	# y == tr, but shorter :-)
d590 28
a617 1
=head2 How do I expand function calls in a string?
d619 2
a620 3
This is documented in L<perlref>.  In general, this is fraught with
quoting and readability problems, but it is possible.  To interpolate
a subroutine call (in list context) into a string:
d622 2
a623 1
    print "My sub returned @@{[mysub(1,2,3)]} that time.\n";
d625 1
a625 2
See also ``How can I expand variables in text strings?'' in this
section of the FAQ.
d634 4
a637 3
nested patterns.  For balanced expressions using C<(>, C<{>, C<[>
or C<< < >> as delimiters, use the CPAN module Regexp::Common, or see
L<perlre/(??{ code })>.  For other cases, you'll have to write a parser.
d642 2
a643 2
and the byacc program.   Starting from perl 5.8 the Text::Balanced
is part of the standard distribution.
d831 1
a831 1
Text::CVS, Text::CVS_XS, and Text::ParseWords, among others.
d867 1
a867 1
Although the simplest approach would seem to be
d869 3
a871 1
    $string =~ s/^\s*(.*?)\s*$/$1/;
d873 2
a874 2
not only is this unnecessarily slow and destructive, it also fails with
embedded newlines.  It is much faster to do this operation in two steps:
d876 15
a890 2
    $string =~ s/^\s+//;
    $string =~ s/\s+$//;
d892 5
a896 1
Or more nicely written as:
d898 13
a910 4
    for ($string) {
	s/^\s+//;
	s/\s+$//;
    }
d912 1
a912 11
This idiom takes advantage of the C<foreach> loop's aliasing
behavior to factor out common code.  You can do this
on several strings at once, or arrays, or even the
values of a hash if you use a slice:

    # trim whitespace in the scalar, the array,
    # and all the values in the hash
    foreach ($scalar, @@array, @@hash{keys %hash}) {
        s/^\s+//;
        s/\s+$//;
    }
d983 5
a987 8
Use the standard Text::Soundex module distributed with Perl.
Before you do so, you may want to determine whether `soundex' is in
fact what you think it is.  Knuth's soundex algorithm compresses words
into a small space, and so it does not necessarily distinguish between
two words which you might want to appear separately.  For example, the
last names `Knuth' and `Kant' are both mapped to the soundex code K530.
If Text::Soundex does not do what you are looking for, you might want
to consider the String::Approx module available at CPAN.
d991 2
a992 1
Let's assume that you have a string like:
d996 5
a1000 2
If those were both global variables, then this would
suffice:
d1002 2
a1003 7
    $text =~ s/\$(\w+)/${$1}/g;  # no /e needed

But since they are probably lexicals, or at least, they could
be, you'd have to do this:

    $text =~ s/(\$\w+)/$1/eeg;
    die if $@@;			# needed /ee, not /e
a1013 3
See also ``How do I expand function calls in a string?'' in this section
of the FAQ.

d1180 1
a1180 4
There are several possible ways, depending on whether the array is
ordered and whether you wish to preserve the ordering.

=over 4
d1182 2
a1183 1
=item a)
d1185 20
a1204 2
If @@in is sorted, and you want @@out to be sorted:
(this assumes all true values in the array)
d1206 2
a1207 2
    $prev = "not equal to $in[0]";
    @@out = grep($_ ne $prev && ($prev = $_, 1), @@in);
d1209 5
a1213 4
This is nice in that it doesn't use much extra memory, simulating
uniq(1)'s behavior of removing only adjacent duplicates.  The ", 1"
guarantees that the expression is true (so that grep picks it up)
even if the $_ is 0, "", or undef.
d1215 2
a1216 1
=item b)
d1218 2
a1219 1
If you don't know whether @@in is sorted:
d1221 1
a1221 26
    undef %saw;
    @@out = grep(!$saw{$_}++, @@in);

=item c)

Like (b), but @@in contains only small integers:

    @@out = grep(!$saw[$_]++, @@in);

=item d)

A way to do (b) without any loops or greps:

    undef %saw;
    @@saw{@@in} = ();
    @@out = sort keys %saw;  # remove sort if undesired

=item e)

Like (d), but @@in contains only small positive integers:

    undef @@ary;
    @@ary[@@in] = @@in;
    @@out = grep {defined} @@ary;

=back
d1223 1
a1223 3
But perhaps you should have been using a hash all along, eh?

=head2 How can I tell whether a certain element is contained in a list or array?
d1260 8
a1267 1
Please do not use
d1269 7
a1275 1
    ($is_there) = grep $_ eq $whatever, @@array;
d1277 4
a1280 1
or worse yet
d1282 1
a1282 1
    ($is_there) = grep /$whatever/, @@array;
d1284 2
a1285 4
These are slow (checks every element even if the first matches),
inefficient (same reason), and potentially buggy (what if there are
regex characters in $whatever?).  If you're only testing once, then
use:
d1287 1
a1287 8
    $is_there = 0;
    foreach $elt (@@array) {
	if ($elt eq $elt_to_find) {
	    $is_there = 1;
	    last;
	}
    }
    if ($is_there) { ... }
d1368 1
a1368 1
	foreach my $element ( @@array )
d1370 1
a1370 1
		if( /Perl/ ) { $found = $element; last }
d1378 9
a1386 9
    for( $i = 0; $i < @@array; $i++ )
    	{
        if( $array[$i] =~ /Perl/ )
        	{
        	$found = $array[$i];
        	$index = $i;
        	last;
        	}
        }
d1459 1
a1459 1
        while ($i--) {
d1495 2
a1496 2
	s/foo/bar/;	# change that word
	y/XZ/ZX/;	# swap those letters
d1502 2
a1503 2
	$_ **= 3;
	$_ *= (4/3) * 3.14159;  # this will be constant folded
d1517 1
a1517 1
	($orbit **= 3) *= (4/3) * 3.14159;
d1797 44
a1840 21
Internally, hashes are stored in a way that prevents you from imposing
an order on key-value pairs.  Instead, you have to sort a list of the
keys or values:

    @@keys = sort keys %hash;	# sorted by key
    @@keys = sort {
		    $hash{$a} cmp $hash{$b}
	    } keys %hash; 	# and by value

Here we'll do a reverse numeric sort by value, and if two keys are
identical, sort by length of key, or if that fails, by straight ASCII
comparison of the keys (well, possibly modified by your locale--see
L<perllocale>).

    @@keys = sort {
		$hash{$b} <=> $hash{$a}
			  ||
		length($b) <=> length($a)
			  ||
		      $a cmp $b
    } keys %hash;
d2025 12
a2036 2
You can't do this directly, but you could use the standard Tie::RefHash
module distributed with Perl.
d2087 1
a2087 1
if you just want to say, ``Is this a float?''
d2158 2
a2159 2
Copyright (c) 1997-2002 Tom Christiansen and Nathan Torkington.
All rights reserved.
@


1.7
log
@merge local changes into perl-5.8.3
@
text
@d3 1
a3 1
perlfaq4 - Data Manipulation ($Revision: 1.6 $, $Date: 2003/12/03 03:02:44 $)
d562 1
a562 1
break Y2K, people do.''  See http://language.perl.com/news/y2k.html for
d1718 1
a1718 1
Don't do that. :-)
d1720 7
a1726 11
[lwall] In Perl 4, you were not allowed to modify a hash at all while
iterating over it.  In Perl 5 you can delete from it, but you still
can't add to it, because that might cause a doubling of the hash table,
in which half the entries get copied up to the new top half of the
table, at which point you've totally bamboozled the iterator code.
Even if the table doesn't double, there's no telling whether your new
entry will be inserted before or after the current iterator position.

Either treasure up your changes and make them after the iterator finishes
or use keys to fetch all the old keys at once, and iterate over the list
of keys.
@


1.6
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d3 1
a3 1
perlfaq4 - Data Manipulation ($Revision: 1.52 $, $Date: 2003/10/02 04:44:33 $)
d365 14
a378 3
Use the following simple function.  It selects a random integer between
(and possibly including!) the two given integers, e.g.,
C<random_int_in(50,120)>
a428 8
You can also use the POSIX strftime() function which may be a bit
slower but is easier to read and maintain.

	use POSIX qw/strftime/;

	my $week_of_the_year = strftime "%W", localtime;
	my $day_of_the_year  = strftime "%j", localtime;

a1494 4
    # at the top of the program:
    srand;			# not needed for 5.004 and later

    # then later on
d1498 2
a1499 3
Make sure you I<only call srand once per program, if then>.
If you are calling it more than once (such as before each
call to rand), you're almost certainly doing something wrong.
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 1
a3 1
perlfaq4 - Data Manipulation ($Revision: 1.25 $, $Date: 2002/05/30 07:04:25 $)
d14 34
a47 35
The infinite set that a mathematician thinks of as the real numbers can
only be approximated on a computer, since the computer only has a finite
number of bits to store an infinite number of, um, numbers.

Internally, your computer represents floating-point numbers in binary.
Floating-point numbers read in from a file or appearing as literals
in your program are converted from their decimal floating-point
representation (eg, 19.95) to an internal binary representation.

However, 19.95 can't be precisely represented as a binary
floating-point number, just like 1/3 can't be exactly represented as a
decimal floating-point number.  The computer's binary representation
of 19.95, therefore, isn't exactly 19.95.

When a floating-point number gets printed, the binary floating-point
representation is converted back to decimal.  These decimal numbers
are displayed in either the format you specify with printf(), or the
current output format for numbers.  (See L<perlvar/"$#"> if you use
print.  C<$#> has a different default value in Perl5 than it did in
Perl4.  Changing C<$#> yourself is deprecated.)

This affects B<all> computer languages that represent decimal
floating-point numbers in binary, not just Perl.  Perl provides
arbitrary-precision decimal numbers with the Math::BigFloat module
(part of the standard Perl distribution), but mathematical operations
are consequently slower.

If precision is important, such as when dealing with money, it's good
to work with integers and then divide at the last possible moment.
For example, work in pennies (1995) instead of dollars and cents
(19.95) and divide by 100 at the end.

To get rid of the superfluous digits, just use a format (eg,
C<printf("%.2f", 19.95)>) to get the required precision.
See L<perlop/"Floating-point Arithmetic">.  
d51 9
a59 9
Perl only understands octal and hex numbers as such when they occur
as literals in your program.  Octal literals in perl must start with 
a leading "0" and hexadecimal literals must start with a leading "0x".
If they are read in from somewhere and assigned, no automatic 
conversion takes place.  You must explicitly use oct() or hex() if you 
want the values converted to decimal.  oct() interprets
both hex ("0x350") numbers and octal ones ("0350" or even without the
leading "0", like "377"), while hex() only converts hexadecimal ones,
with or without a leading "0x", like "0x255", "3A", "ff", or "deadbeef".
d61 1
a61 2
"%o" or "%O" sprintf() formats.  To get from decimal to hex try either 
the "%x" or the "%X" formats to sprintf().
d64 1
a64 1
umask(), or sysopen(), which by widespread tradition typically take 
d70 1
a70 1
Note the mistake in the first line was specifying the decimal literal 
d78 1
a78 1
try to express them as octal constants, that is with a leading zero and 
d115 1
a115 1
    0.0 0.1 0.1 0.2 0.2 0.2 0.3 0.3 0.4 0.4 0.5 0.5 0.6 0.7 0.7 
d123 1
a123 1
=head2 How do I convert between numeric representations?
d142 1
a142 2
    $int = 0xDEADBEEF;
    $dec = sprintf("%d", $int);
d146 1
a146 2
    $int = hex("DEADBEEF");
    $dec = sprintf("%d", $int);
d150 1
a150 2
    $int = unpack("N", pack("H8", substr("0" x 8 . "DEADBEEF", -8)));
    $dec = sprintf("%d", $int);
d160 1
a160 1
Using sprint:
d162 2
a163 1
    $hex = sprintf("%X", 3735928559);
d165 1
a165 1
Using unpack
d169 1
a169 1
Using Bit::Vector
d186 1
a186 2
    $int = 033653337357; # note the leading 0!
    $dec = sprintf("%d", $int);
d190 1
a190 2
    $int = oct("33653337357");
    $dec = sprintf("%d", $int);
d205 1
a205 1
Using Bit::Vector
d216 1
a216 1
	$number = 0b10110110;
d218 6
a223 1
Using pack and ord
d227 1
a227 1
Using pack and unpack for larger strings
d242 5
a246 1
Using unpack;
d270 1
a270 1
C<1>).  Saying C<"11" & "3"> performs the "and" operation on strings
d341 3
d345 1
a345 1
call C<srand> more than once--you make your numbers less random, rather
d350 2
a351 2
F<random> artitcle in the "Far More Than You Ever Wanted To Know"
collection in http://www.cpan.org/olddoc/FMTEYEWTK.tgz , courtesy of
d379 9
a387 1
=head2 How do I find the week-of-the-year/day-of-the-year?
d389 3
a391 2
The day of the year is in the array returned by localtime() (see
L<perlfunc/"localtime">):
d393 13
a405 1
    $day_of_year = (localtime(time()))[7];
d411 1
a411 1
    sub get_century    { 
d413 2
a414 2
    } 
    sub get_millennium { 
d416 9
a424 1
    } 
d426 6
a431 5
On some systems, you'll find that the POSIX module's strftime() function
has been extended in a non-standard way to use a C<%C> format, which they
sometimes claim is the "century".  It isn't, because on most such systems,
this is only the first two digits of the four-digit year, and thus cannot
be used to reliably determine the current century or millennium.
d477 2
a478 2
The C<time()> function returns the current time in seconds since the
epoch.  Take twenty-four hours off that:
d480 1
a480 1
    $yesterday = time() - ( 24 * 60 * 60 );
d482 1
a482 2
Then you can pass this to C<localtime()> and get the individual year,
month, day, hour, minute, seconds values.
d484 7
a490 4
Note very carefully that the code above assumes that your days are
twenty-four hours each.  For most people, there are two days a year
when they aren't: the switch to and from summer time throws this off.
A solution to this issue is offered by Russ Allbery.
d493 38
a530 38
	my $now  = defined $_[0] ? $_[0] : time;
	my $then = $now - 60 * 60 * 24;
	my $ndst = (localtime $now)[8] > 0;
	my $tdst = (localtime $then)[8] > 0;
	$then - ($tdst - $ndst) * 60 * 60;
    }
    # Should give you "this time yesterday" in seconds since epoch relative to
    # the first argument or the current time if no argument is given and
    # suitable for passing to localtime or whatever else you need to do with
    # it.  $ndst is whether we're currently in daylight savings time; $tdst is
    # whether the point 24 hours ago was in daylight savings time.  If $tdst
    # and $ndst are the same, a boundary wasn't crossed, and the correction
    # will subtract 0.  If $tdst is 1 and $ndst is 0, subtract an hour more
    # from yesterday's time since we gained an extra hour while going off
    # daylight savings time.  If $tdst is 0 and $ndst is 1, subtract a
    # negative hour (add an hour) to yesterday's time since we lost an hour.
    #
    # All of this is because during those days when one switches off or onto
    # DST, a "day" isn't 24 hours long; it's either 23 or 25.
    #
    # The explicit settings of $ndst and $tdst are necessary because localtime
    # only says it returns the system tm struct, and the system tm struct at
    # least on Solaris doesn't guarantee any particular positive value (like,
    # say, 1) for isdst, just a positive value.  And that value can
    # potentially be negative, if DST information isn't available (this sub
    # just treats those cases like no DST).
    #
    # Note that between 2am and 3am on the day after the time zone switches
    # off daylight savings time, the exact hour of "yesterday" corresponding
    # to the current hour is not clearly defined.  Note also that if used
    # between 2am and 3am the day after the change to daylight savings time,
    # the result will be between 3am and 4am of the previous day; it's
    # arguable whether this is correct.
    #
    # This sub does not attempt to deal with leap seconds (most things don't).
    #
    # Copyright relinquished 1999 by Russ Allbery <rra@@stanford.edu>
    # This code is in the public domain
a597 8
If you prefer scalar context, similar chicanery is also useful for
arbitrary expressions:

    print "That yields ${\($n + 5)} widgets\n";

Version 5.004 of Perl had a bug that gave list context to the
expression in C<${...}>, but this is fixed in version 5.005.

d608 3
a610 2
nested patterns, nor can they.  For that you'll have to write a
parser.
d623 1
a623 1
    } 
d678 1
a678 1
=head2 How can I access/change the first N letters of a string?
d680 3
a682 2
There are many ways.  If you just want to grab a copy, use
substr():
a683 1
    $first_byte = substr($a, 0, 1);
d685 2
a686 2
If you want to modify part of a string, the simplest way is often to
use substr() as an lvalue:
d688 2
a689 1
    substr($a, 0, 3) = "Tom";
d691 1
a691 2
Although those with a pattern matching kind of thought process will
likely prefer
d693 3
a695 1
    $a =~ s/^.../Tom/;
d788 17
a804 2
=head2 How can I split a [character] delimited string except when inside
[character]? (Comma-separated files)
d806 4
a809 5
Take the example case of trying to split a string that is comma-separated
into its different fields.  (We'll pretend you said comma-separated, not
comma-delimited, which is different and almost never what you mean.) You
can't use C<split(/,/)> because you shouldn't split if the comma is inside
quotes.  For example, take a data line like this:
d814 2
a815 2
problem.  Thankfully, we have Jeffrey Friedl, author of a highly
recommended book on regular expressions, to handle these for us.  He
d828 1
a828 2
C<"like \"this\"">.  Unescaping them is a task addressed earlier in
this section.
d859 1
a859 1
on several strings at once, or arrays, or even the 
d862 1
a862 1
    # trim whitespace in the scalar, the array, 
a870 3
(This answer contributed by Uri Guttman, with kibitzing from
Bart Lateur.) 

d885 2
a886 1
    $padded = sprintf("%${pad_len}s", $text);
d889 2
a890 1
    $padded = sprintf("%-${pad_len}s", $text);
d892 3
a894 2
    # Left padding a number with 0 (no truncation): 
    $padded = sprintf("%0${pad_len}d", $num);
d917 1
a917 1
If you prefer thinking in terms of columns instead of widths, 
d924 1
a924 1
    sub cut2fmt { 
d929 1
a929 1
	    $template .= "A" . ($place - $lastpos) . " "; 
d967 1
a967 1
    %user_defs = ( 
d981 1
a981 1
expansion is used to produce new strings.  If you already 
d1012 1
a1012 1
Stringification also destroys arrays.  
d1018 1
a1018 1
=head2 Why don't my <<HERE documents work?
d1024 1
a1024 1
=item 1. There must be no space after the << part.
d1026 1
a1026 1
=item 2. There (probably) should be a semicolon at the end.
d1028 1
a1028 1
=item 3. You can't (easily) have any space in front of the tag.
d1032 1
a1032 1
If you want to indent the text in the here document, you 
d1042 1
a1042 1
If you want that indented also, you'll have to quote 
d1137 1
a1137 1
The C<use warnings> pragma and the B<-w> flag will warn you about these 
d1293 2
a1294 2
        cmpStr(\@@a, \@@b) == 0 
	    ? "the same" 
d1304 1
a1304 1
    $b{EXTRA} = \%a;                    
d1319 30
a1348 6
You can use this if you care about the index:

    for ($i= 0; $i < @@array; $i++) {
        if ($array[$i] eq "Waldo") {
	    $found_index = $i;
            last;
a1349 3
    }

Now C<$found_index> has what you want.
d1469 5
d1480 1
a1480 1
	($orbit **= 3) *= (4/3) * 3.14159; 
d1500 1
a1500 1
If you are calling it more than once (such as before each 
d1505 39
a1543 20
Here's a little program that generates all permutations
of all the words on each line of input.  The algorithm embodied
in the permute() function should work on any list:

    #!/usr/bin/perl -n
    # tsc-permute: permute each word of input
    permute([split], []);
    sub permute {
        my @@items = @@{ $_[0] };
        my @@perms = @@{ $_[1] };
        unless (@@items) {
            print "@@perms\n";
	} else {
            my(@@newitems,@@newperms,$i);
            foreach $i (0 .. $#items) {
                @@newitems = @@items;
                @@newperms = @@perms;
                unshift(@@newperms, splice(@@newitems, $i, 1));
                permute([@@newitems], [@@newperms]);
	    }
a1544 1
    }
d1546 1
a1546 5
Unfortunately, this algorithm is very inefficient. The Algorithm::Permute
module from CPAN runs at least an order of magnitude faster. If you don't
have a C compiler (or a binary distribution of Algorithm::Permute), then
you can use List::Permutor which is written in pure Perl, and is still
several times faster than the algorithm above.
d1589 2
a1590 2
See the F<sort> artitcle article in the "Far More Than You Ever Wanted
To Know" collection in http://www.cpan.org/olddoc/FMTEYEWTK.tgz for
d1653 1
a1653 1
and "big int" math. 
d1659 1
a1659 1
    print "Ilya's string \\xff\\x0f\\xef\\xfe represents the number ", 
d1679 1
a1679 1
    sub set_vec { 
d1696 1
a1696 1
    } 
d1763 2
a1764 2
The keys() function also resets the iterator, which means that you may 
see strange results if you use this between uses of other hash operators 
d1930 2
a1931 2
    tie(%myhash, Tie::IxHash);
    for ($i=0; $i<20; $i++) {
d1934 1
a1934 1
    @@keys = keys %myhash;
d1990 1
a1990 3
L<perlfunc/"binmode"> or L<perlopentut>.  Most of these ancient-thinking
systems are curses out of Microsoft, who seem to be committed to putting
the backward into backward compatibility.
d2011 9
a2019 3
You can also use the L<Data::Types|Data::Types> module on
the CPAN, which exports functions that validate data types
using these and other regular expressions.
d2021 1
a2021 1
If you're on a POSIX system, Perl's supports the C<POSIX::strtod>
d2039 2
a2040 2
        } 
    } 
d2042 1
a2042 1
    sub is_numeric { defined getnum($_[0]) } 
d2044 1
a2044 1
Or you could check out the L<String::Scanf|String::Scanf> module on the CPAN
d2057 1
a2057 1
    use Storable; 
d2060 1
a2060 1
    # later on...  
d2067 3
a2069 2
for printing out data structures.  The Storable module, found on CPAN,
provides a function called C<dclone> that recursively copies its argument.
d2071 1
a2071 1
    use Storable qw(dclone); 
@


1.4
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 1
a3 1
perlfaq4 - Data Manipulation ($Revision: 1.49 $, $Date: 1999/05/23 20:37:49 $)
d7 2
a8 3
The section of the FAQ answers questions related to the manipulation
of data as numbers, dates, strings, arrays, hashes, and miscellaneous
data issues.
d41 5
d53 5
a57 3
as literals in your program.  If they are read in from somewhere and
assigned, no automatic conversion takes place.  You must explicitly
use oct() or hex() if you want the values converted.  oct() interprets
d61 3
d66 2
a67 1
umask(), or sysopen(), which all want permissions in octal.
d69 1
a69 1
    chmod(644,  $file);	# WRONG -- perl -w catches this
d72 11
d125 45
a169 1
=head2 How do I convert bits into ints?
d171 1
a171 3
To turn a string of 1s and 0s like C<10110110> into a scalar containing
its binary value, use the pack() and unpack() functions (documented in
L<perlfunc/"pack"> and L<perlfunc/"unpack">):
d173 1
a173 1
    $decimal = unpack('c', pack('B8', '10110110'));
d175 3
a177 2
This packs the string C<10110110> into an eight bit binary structure.
This is then unpacked as a character, which returns its ordinal value.
d179 46
a224 1
This does the same thing:
d228 5
a232 1
Here's an example of going the other way:
d234 23
a256 1
    $binary_string = unpack('B*', "\x29");
d332 1
a332 1
Get the http://www.perl.com/CPAN/modules/by-module/Roman module.
d343 5
a347 4
(despite appearances caused by bugs in your programs :-).
http://www.perl.com/CPAN/doc/FMTEYEWTK/random , courtesy of Tom
Phoenix, talks more about this.  John von Neumann said, ``Anyone who
attempts to generate random numbers by deterministic means is, of
d357 14
a379 17
or more legibly (in 5.004 or higher):

    use Time::localtime;
    $day_of_year = localtime(time())->yday;

You can find the week of the year by dividing this by 7:

    $week_of_year = int($day_of_year / 7);

Of course, this believes that weeks start at zero.  The Date::Calc
module from CPAN has a lot of date calculation functions, including
day of the year, week of the year, and so on.   Note that not
all businesses consider ``week 1'' to be the same; for example,
American businesses often consider the first week with a Monday
in it to be Work Week #1, despite ISO 8601, which considers
WW1 to be the first week with a Thursday in it.

d421 4
a424 3
Before you immerse yourself too deeply in this, be sure to verify that it
is the I<Julian> Day you really want.  Are you really just interested in
a way of getting serial days so that they can do date arithmetic?  If you
d426 1
a426 1
either Date::Manip or Date::Calc, without converting to Julian Day first.
d428 10
a437 9
There is too much confusion on this issue to cover in this FAQ, but the
term is applied (correctly) to a calendar now supplanted by the Gregorian
Calendar, with the Julian Calendar failing to adjust properly for leap
years on centennial years (among other annoyances).  The term is also used
(incorrectly) to mean: [1] days in the Gregorian Calendar; and [2] days
since a particular starting time or `epoch', usually 1970 in the Unix
world and 1980 in the MS-DOS/Windows world.  If you find that it is not
the first meaning that you really want, then check out the Date::Manip
and Date::Calc modules.  (Thanks to David Cassell for most of this text.)
d584 2
a585 1
and the byacc program.
d606 1
a606 1
    @@$ = (eval{/$re/},$@@!~/unmatched/);
d638 9
d715 5
d728 1
a728 1
more thorough solution (Suggested by brian d.  foy):
d1005 1
a1005 1
    $quote =~ s/\s*--/\n--/;
d1147 1
a1147 1
=head2 How can I tell whether a list or array contains a certain element?
d1155 2
a1156 2
the fastest way is probably to invert the original array and keep an
associative array lying about whose keys are the first array's values.
d1159 1
a1159 1
    undef %is_blue;
d1169 1
a1169 1
    undef @@is_tiny_prime;
d1343 8
a1350 1
Use this:
a1351 2
    # fisher_yates_shuffle( \@@array ) : 
    # generate a random permutation of @@array in place
d1353 3
a1355 3
        my $array = shift;
        my $i;
        for ($i = @@$array; --$i; ) {
d1357 1
a1357 1
            @@$array[$i,$j] = @@$array[$j,$i];
d1361 9
a1369 1
    fisher_yates_shuffle( \@@array );    # permutes @@array in place
d1402 4
a1405 2
If you want to do the same thing to modify the values of the hash,
you may not use the C<values> function, oddly enough.  You need a slice:
d1407 1
a1407 1
    for $orbit ( @@orbits{keys %orbits} ) {
d1411 5
d1456 6
d1503 3
a1505 2
See http://www.perl.com/CPAN/doc/FMTEYEWTK/sort.html for more about
this approach.
d1518 1
a1518 1
And here's how, given a vector in $vec, you can
d1553 17
a1569 1
Here's a demo on how to use vec():
d1673 1
a1673 1
take the scalar sense of the keys() function:
d1675 1
a1675 1
    $num_keys = scalar keys %hash;
d1677 3
a1679 3
The keys() function also resets the iterator, which in void context is
faster for tied hashes than would be iterating through the whole 
hash, one key-value pair at a time.
d1713 9
a1721 7
Hashes are pairs of scalars: the first is the key, the second is the
value.  The key will be coerced to a string, although the value can be
any kind of scalar: string, number, or reference.  If a key C<$key> is
present in the array, C<exists($key)> will return true.  The value for
a given key can be C<undef>, in which case C<$array{$key}> will be
C<undef> while C<$exists{$key}> will return true.  This corresponds to
(C<$key>, C<undef>) being in the hash.
d1723 1
a1723 1
Pictures help...  here's the C<%ary> table:
d1735 6
a1740 6
	$ary{'a'}                       is true
	$ary{'d'}                       is false
	defined $ary{'d'}               is true
	defined $ary{'a'}               is true
	exists $ary{'a'}                is true (Perl5 only)
	grep ($_ eq 'a', keys %ary)     is true
d1744 1
a1744 1
	undef $ary{'a'}
d1759 6
a1764 6
	$ary{'a'}                       is FALSE
	$ary{'d'}                       is false
	defined $ary{'d'}               is true
	defined $ary{'a'}               is FALSE
	exists $ary{'a'}                is true (Perl5 only)
	grep ($_ eq 'a', keys %ary)     is true
d1770 1
a1770 1
	delete $ary{'a'}
d1783 6
a1788 6
	$ary{'a'}                       is false
	$ary{'d'}                       is false
	defined $ary{'d'}               is true
	defined $ary{'a'}               is false
	exists $ary{'a'}                is FALSE (Perl5 only)
	grep ($_ eq 'a', keys %ary)     is FALSE
d1794 5
a1798 6
They may or may not implement the EXISTS() and DEFINED() methods
differently.  For example, there isn't the concept of undef with hashes
that are tied to DBM* files. This means the true/false tables above
will give different results when used on such a hash.  It also means
that exists and defined do the same thing with a DBM* file, and what
they end up doing is not what they do with ordinary hashes.
d1888 1
a1888 1
You can't do this directly, but you could use the standard Tie::Refhash
d1923 1
a1923 1
   if (/^-?(?:\d+(?:\.\d*)?|\.\d+)$/) { print "is a decimal number" }
d1925 5
a1929 1
			{ print "a C float" }
d1954 3
a1956 3
Or you could check out the String::Scanf module on CPAN instead.  The
POSIX module (part of the standard Perl distribution) provides the
C<strtod> and C<strtol> for converting strings to double and longs,
d1962 4
a1965 3
See L<AnyDBM_File>.  More generically, you should consult the FreezeThaw,
Storable, or Class::Eroot modules from CPAN.  Here's one example using
Storable's C<store> and C<retrieve> functions:
d2006 1
a2006 1
Copyright (c) 1997-1999 Tom Christiansen and Nathan Torkington.
d2009 2
a2010 6
When included as part of the Standard Version of Perl, or as part of
its complete documentation whether printed or otherwise, this work
may be distributed only under the terms of Perl's Artistic License.
Any distribution of this file or derivatives thereof I<outside>
of that package require that special arrangements be made with
copyright holder.
@


1.3
log
@perl-5.6.0 + local changes
@
text
@d7 1
a7 1
The section of the FAQ answers question related to the manipulation
d16 1
a16 1
only be approximate on a computer, since the computer only has a finite
d22 1
a22 1
representation (eg, 19.95) to the internal binary representation.
d32 1
a32 1
current output format for numbers (see L<perlvar/"$#"> if you use
d78 1
a78 1
In 5.000 to 5.003 Perls, trigonometry was done in the Math::Complex
d209 2
a210 2
http://www.perl.com/CPAN/doc/FMTEYEWTK/random, courtesy of Tom
Phoenix, talks more about this..  John von Neumann said, ``Anyone who
d289 1
a289 1
is the I<Julian> Day you really want.  Are they really just interested in
d373 1
a373 1
by these functions when used in an array context is the year minus 1900.
d401 1
a401 1
character are removed with:
d515 1
a515 1
likely prefer:
d552 1
a552 1
There are a number of ways, with varying efficiency: If you want a
d577 2
a578 2
Do It>".  Sometimes you might want this, instead (Suggested by brian d. 
foy):
d640 1
a640 1
There's also a Text::CSV module on CPAN.
d644 1
a644 1
Although the simplest approach would seem to be:
d648 1
a648 1
Not only is this unnecessarily slow and destructive, it also fails with
d743 1
a743 1
But before you do so, you may want to determine whether `soundex' is in
d782 3
a784 3
The problem is that those double-quotes force stringification,
coercing numbers and references into strings, even when you
don't want them to be.  Think of it this way: double-quote
d860 2
a861 2
if so, strips that off.  Otherwise, it takes the amount of leading
white space found on the first line and removes that much off each
d866 1
a866 1
        my ($white, $leader);  # common white space and common leading string
d889 1
a889 1
Or with a fixed amount of leading white space, with remaining
d913 1
a913 1
access their arguments through the array C<@@_>, push/pop/shift only work
d927 1
a927 1
The former is a scalar value, the latter an array slice, which makes
d951 3
a953 1
=item a) If @@in is sorted, and you want @@out to be sorted:
d956 2
a957 2
    $prev = 'nonesuch';
    @@out = grep($_ ne $prev && ($prev = $_), @@in);
d960 5
a964 3
uniq(1)'s behavior of removing only adjacent duplicates.  It's less
nice in that it won't work with false values like undef, 0, or "";
"0 but true" is OK, though.
d966 1
a966 1
=item b) If you don't know whether @@in is sorted:
d971 3
a973 1
=item c) Like (b), but @@in contains only small integers:
d977 3
a979 1
=item d) A way to do (b) without any loops or greps:
d985 3
a987 1
=item e) Like (d), but @@in contains only small positive integers:
d1036 1
a1036 1
    $is_there = grep $_ eq $whatever, @@array;
d1040 1
a1040 1
    $is_there = grep /$whatever/, @@array;
d1070 1
a1070 1
either A or in B, but not in both.  Think of it as an xor operation.
d1161 1
a1161 1
You could grow the list this way:
a1201 1
            next if $i == $j;
d1209 1
a1209 1
randomly picking another element to swap the current element with:
d1310 1
a1310 1
Which could also be written this way, using a trick
d1451 1
a1451 1
Either treasure up your changes and make them after the iterator finishes,
d1484 1
a1484 1
In void context, the keys() function just resets the iterator, which is
d1500 2
a1501 2
identical, sort by length of key, and if that fails, by straight ASCII
comparison of the keys (well, possibly modified by your locale -- see
d1758 1
a1758 1
C<strtol> and C<strtod> for converting strings to double and longs,
@


1.2
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
perlfaq4 - Data Manipulation ($Revision: 1.40 $, $Date: 1999/01/08 04:26:39 $)
d34 1
a34 1
Perl4.  Changing C<$#> yourself is deprecated.
d70 1
a70 1
The POSIX module (part of the standard perl distribution) implements
d79 1
a79 1
module.  With 5.004, the Math::Trig module (part of the standard perl
d107 2
a108 2
its binary value, use the pack() function (documented in
L<perlfunc/"pack">):
d110 8
a117 1
    $decimal = pack('B8', '10110110');
d121 1
a121 1
    $binary_string = join('', unpack('B*', "\x29"));
d186 9
d247 17
d268 7
a274 2
month, hour, minute, seconds values) then use one of the Date::Manip
and Date::Calc modules from CPAN.
d285 2
a286 4
Neither Date::Manip nor Date::Calc deal with Julian days.  Instead,
there is an example of Julian date calculation that should help you in
Time::JulianDay (part of the Time-modules bundle) which can be found at
http://www.perl.com/CPAN/modules/by-module/Time/.
d288 15
d307 1
a307 1
epoch.  Take one day off that:
d314 46
a359 1
=head2 Does Perl have a year 2000 problem?  Is Perl Y2K compliant?
d370 1
a370 1
The date and time functions supplied with perl (gmtime and localtime)
d411 5
a415 1
    s/(.)\1/$1/g;
d447 3
a449 5
modules or oddities that will make your life a lot easier.  There is
the CPAN module Parse::RecDescent, the standard module Text::Balanced,
the byacc program, the CPAN module Parse::Yapp, and Mark-Jason
Dominus's excellent I<py> tool at http://www.plover.com/~mjd/perl/py/
.
d454 1
a454 1
    while (s//BEGIN((?:(?!BEGIN)(?!END).)*)END/gs) {
d466 1
a466 1
 
d486 1
a486 1
Or you can just use the Text::Tabs module (part of the standard perl
d494 1
a494 1
Use Text::Wrap (part of the standard perl distribution):
d523 2
a524 1
C<"whosoever"> or C<"whomsoever">, case insensitively.
d531 1
a531 1
    }igex;
d538 1
a541 1
            # Warning: don't `last' out of this loop
d558 1
a558 1
    print "There are $count X charcters in the string";
d577 2
a578 2
Do It>".  Sometimes you might want this, instead (Suggested by Brian
Foy):
d601 1
a601 1
case", but that's not quite accurate.  Consdier the proper
d634 1
a634 1
Alternatively, the Text::ParseWords module (part of the standard perl
d648 2
a649 2
This is unnecessarily slow, destructive, and fails with embedded newlines.
It is much better faster to do this in two steps:
d664 1
a664 1
values of a hash if you use a slide:
d675 2
a676 1
(This answer contributed by Uri Guttman)
d679 14
a692 7
to pad the string, C<$text> or C<$num> contains the string to be
padded, and C<$pad_char> contains the padding character. You can use a
single character string constant instead of the C<$pad_char> variable
if you know what it is in advance.

The simplest method use the C<sprintf> function. It can pad on the
left or right with blanks and on the left with zeroes.
d694 2
a695 2
    # Left padding with blank:
    $padded = sprintf( "%${pad_len}s", $text ) ;
d697 2
a698 2
    # Right padding with blank:
    $padded = sprintf( "%${pad_len}s", $text ) ;
d700 2
a701 2
    # Left padding with 0:
    $padded = sprintf( "%0${pad_len}d", $num ) ;
d704 3
a706 4
one of the following methods.

These methods generate a pad string with the C<x> operator and
concatenate that with the original text.
d708 1
a708 1
Left and right padding with any character:
d710 2
a711 2
    $padded = $pad_char x ( $pad_len - length( $text ) ) . $text ;
    $padded = $text . $pad_char x ( $pad_len - length( $text ) ) ;
d713 1
a713 1
Or you can left or right pad $text directly:
d715 2
a716 2
    $text .= $pad_char x ( $pad_len - length( $text ) ) ;
    substr( $text, 0, 0 ) = $pad_char x ( $pad_len - length( $text ) ) ;
d742 8
a749 1
Use the standard Text::Soundex module distributed with perl.
d822 1
a822 1
=head2 Why don't my E<lt>E<lt>HERE documents work?
d883 1
a883 1
	@@@@@@     while ( op = (*op->op_ppaddr)() ) ;
d921 3
a923 3
you're using the comma operator in scalar context, so it evaluates the
left hand side, then evaluates and returns the left hand side.  This
causes the last value to be returned: 9.
d941 2
a942 1
The B<-w> flag will warn you about these matters.
d944 1
a944 1
=head2 How can I extract just the unique elements of an array?
d960 1
a960 1
"0 but true" is ok, though.
d981 1
a981 1
    @@out = @@ary;
d1010 2
a1011 1
    for (@@primes) { $is_tiny_prime[$_] = 1; }
d1034 1
a1034 1
regexp characters in $whatever?).  If you're only testing once, then
d1059 3
d1072 1
a1072 1
	local $^W = 0;  # silence spurious -w undef complaints
d1129 1
a1129 1
arbitrary points.  Both pop and shift are both O(1) operations on perl's
d1199 1
a1199 1
You've probably seen shuffling algorithms that works using splice,
d1284 1
a1284 1
sort C<(1, 2, 10)> into C<(1, 10, 2)>.  C<E<lt>=E<gt>>, used above, is
d1306 1
a1306 1
	      map  { [ $_, uc((/\d+\s*(\S+)/ )[0] ] } @@data;
d1432 13
a1444 1
Don't do that.
d1460 7
a1466 2
If your hash could have repeated values, the methods above will only
find one of the associated keys.   This may or may not worry you.
d1475 3
a1477 2
In void context it just resets the iterator, which is faster
for tied hashes.
d1535 1
a1535 1
	exists $ary{'a'}                is true (perl5 only)
d1559 1
a1559 1
	exists $ary{'a'}                is true (perl5 only)
d1583 1
a1583 1
	exists $ary{'a'}                is FALSE (perl5 only)
d1606 2
a1607 2
First you extract the keys from the hashes into arrays, and then solve
the uniquifying the array problem described above.  For example:
d1659 1
a1659 1
This has been fixed as of perl5.004.
d1686 1
a1686 1
module distributed with perl.
d1699 5
a1703 3
On some legacy systems, however, you have to play tedious games with
"text" versus "binary" files.  See L<perlfunc/"binmode">, or the upcoming
L<perlopentut> manpage.
d1745 1
a1745 1
    sub is_numeric { defined &getnum } 
d1747 4
a1750 5
Or you could check out String::Scanf which can be found at
http://www.perl.com/CPAN/modules/by-module/String/.
The POSIX module (part of the standard Perl distribution) provides 
the C<strtol> and C<strtod> for converting strings to double
and longs, respectively.
d1803 1
a1803 1
may be distributed only under the terms of Perl's Artistic Licence.
a1812 1

@


1.1
log
@perl 5.004_04
@
text
@d3 1
a3 1
perlfaq4 - Data Manipulation ($Revision: 1.19 $, $Date: 1997/04/24 22:43:57 $)
d15 4
d20 2
a21 2
Floating-point numbers read in from a file, or appearing as literals
in your program, are converted from their decimal floating-point
d44 1
d62 5
a66 2
=head2 Does perl have a round function?  What about ceil() and floor()?
Trig functions?
d68 1
a68 2
For rounding to a certain number of digits, sprintf() or printf() is
usually the easiest route.
d74 4
d91 13
d106 1
a106 1
To turn a string of 1s and 0s like '10110110' into a scalar containing
d116 27
d163 1
a163 1
        &my_func($iterator);
d168 1
a168 1
    @@results = map { &my_func($_) } (5 .. 25);
d176 1
a176 1
        push(@@results, &my_func($i));
d185 8
a192 3
The short explanation is that you're getting pseudorandom numbers, not
random ones, because that's how these things work.  A longer
explanation is available on
d194 10
a203 3
Phoenix.

You should also check out the Math::TrulyRandom module from CPAN.
d223 14
a236 5
Of course, this believes that weeks start at zero.

=head2 How can I compare two date strings?

Use the Date::Manip or Date::DateCalc modules from CPAN.
d241 3
a243 3
you can split it up and pass the parts to timelocal in the standard
Time::Local module.  Otherwise, you should look into one of the
Date modules from CPAN.
d247 17
a263 14
Neither Date::Manip nor Date::DateCalc deal with Julian days.
Instead, there is an example of Julian date calculation in
http://www.perl.com/CPAN/authors/David_Muir_Sharnoff/modules/Time/JulianDay.pm.gz,
which should help.

=head2 Does Perl have a year 2000 problem?

Not unless you use Perl to create one. The date and time functions
supplied with perl (gmtime and localtime) supply adequate information
to determine the year well beyond 2000 (2038 is when trouble strikes).
The year returned by these functions when used in an array context is
the year minus 1900. For years between 1910 and 1999 this I<happens>
to be a 2-digit decimal number. To avoid the year 2000 problem simply
do not treat the year as a 2-digit number.  It isn't.
d265 18
a282 1
When gmtime() and localtime() are used in a scalar context they return
d287 6
d298 1
a298 1
with auxiliary logic.  See the more specific questions (numbers, email
d303 2
a304 2
It depends just what you mean by "escape".  URL escapes are dealt with
in L<perlfaq9>.  Shell escapes with the backslash (\)
d309 1
a309 1
Note that this won't expand \n or \t or any other special escapes.
d313 1
a313 1
To turn "abbcccd" into "abccd":
d321 1
a321 1
a subroutine call (in a list context) into a string:
d330 5
a334 2
See also "How can I expand variables in text strings?" in this section
of the FAQ.
d338 36
a373 6
This isn't something that can be tackled in one regular expression, no
matter how complicated.  To find something between two single characters,
a pattern like C</x([^x]*)x/> will get the intervening bits in $1. For
multiple ones, then something more like C</alpha(.*?)omega/> would
be needed.  But none of these deals with nested patterns, nor can they.
For that you'll have to write a parser.
d377 1
a377 1
Use reverse() in a scalar context, as documented in
d384 1
a384 1
You can do it the old-fashioned way:
d401 1
a401 1
The paragraphs you give to Text::Wrap may not contain embedded
d407 1
a407 1
substr:
d416 2
a417 1
Although those with a regexp kind of thought process will likely prefer
d423 3
a425 3
You have to keep track.  For example, let's say you want
to change the fifth occurrence of "whoever" or "whomever"
into "whosoever" or "whomsoever", case insensitively.
d434 17
d457 1
a457 1
    $string = "ThisXlineXhasXsomeXx'sXinXit":
d479 1
a479 1
Foy E<lt>comdog@@computerdog.comE<gt>):
d497 9
d541 2
d545 1
a545 1
The simplest approach, albeit not the fastest, is probably like this:
d549 2
a550 1
It would be faster to do this in two steps:
d562 50
d615 18
a642 1
    $text =~ s/\$(\w+)/${$1}/g;
d644 7
a650 2
Before version 5 of perl, this had to be done with a double-eval
substitution:
d653 4
d658 5
a662 2
Which is bizarre enough that you'll probably actually need an EEG
afterwards. :-)
d664 1
a664 1
See also "How do I expand function calls in a string?" in this section
d671 3
a673 1
don't want them to be.
d703 7
a709 1
=head2 Why don't my <<HERE documents work?
d723 66
d791 21
d838 1
d843 4
a846 3
This is nice in that it doesn't use much extra memory,
simulating uniq(1)'s behavior of removing only adjacent
duplicates.
d871 3
a873 1
=head2 How can I tell whether an array contains a certain element?
d875 7
a881 3
There are several ways to approach this.  If you are going to make
this query many times and the values are arbitrary strings, the
fastest way is probably to invert the original array and keep an
d905 1
a905 1
    grep (vec($read,$_,1) = 1, @@articles);
d919 11
a929 1
regexp characters in $whatever?).
d944 49
d997 1
a997 1
    for ($i=0; $i < @@array; $i++) {
d1010 5
a1014 2
or you can use splice to add and/or remove arbitrary number of elements
at arbitrary points.
d1018 36
a1053 1
to do.
d1065 17
a1081 1
Here's a shuffling algorithm which works its way through the list,
d1091 4
a1094 10
For large arrays, this avoids a lot of the reshuffling:

    srand;
    @@new = ();
    @@old = 1 .. 10000;  # just a demo
    for( @@old ){
        my $r = rand @@new+1;
        push(@@new,$new[$r]);
        $new[$r] = $_;
    }
d1101 2
a1102 2
	s/foo/bar/;
	tr[a-z][A-Z];
d1107 1
a1107 1
    for (@@radii) {
d1112 7
d1123 1
d1125 2
d1130 4
d1138 1
a1138 1
in the permut() function should work on any list:
d1141 7
a1147 8
    # permute - tchrist@@perl.com
    permut([split], []);
    sub permut {
	my @@head = @@{ $_[0] };
	my @@tail = @@{ $_[1] };
	unless (@@head) {
	    # stop recursing when there are no elements in the head
	    print "@@tail\n";
d1149 6
a1154 8
	    # for all elements in @@head, move one from @@head to @@tail
	    # and call permut() on the new @@head and @@tail
	    my(@@newhead,@@newtail,$i);
	    foreach $i (0 .. $#head) {
		@@newhead = @@head;
		@@newtail = @@tail;
		unshift(@@newtail, splice(@@newhead, $i, 1));
		permut([@@newhead], [@@newtail]);
d1249 43
d1294 3
a1296 1
See L<perlfunc/defined> in the 5.004 release or later of Perl.
d1305 1
a1305 1
    while (($key,$value) = each %hash) {
d1371 1
d1463 1
a1463 1
Using C<keys %hash> in a scalar context returns the number of keys in
d1531 15
a1545 3
Use references (documented in L<perlref>).  Examples of complex data
structures are given in L<perldsc> and L<perllol>.  Examples of
structures and object-oriented classes are in L<perltoot>.
d1563 3
a1565 2
On some systems, however, you have to play tedious games with "text"
versus "binary" files.  See L<perlfunc/"binmode">.
d1577 36
a1612 13
   warn "has nondigits"        if     /\D/;
   warn "not a whole number"   unless /^\d+$/;
   warn "not an integer"       unless /^-?\d+$/;  # reject +3
   warn "not an integer"       unless /^[+-]?\d+$/;
   warn "not a decimal number" unless /^-?\d+\.?\d*$/;  # rejects .2
   warn "not a decimal number" unless /^-?(?:\d+(?:\.\d*)?|\.\d+)$/;
   warn "not a C float"
       unless /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/;

Or you could check out
http://www.perl.com/CPAN/modules/by-module/String/String-Scanf-1.1.tar.gz
instead.  The POSIX module (part of the standard Perl distribution)
provides the C<strtol> and C<strtod> for converting strings to double
d1618 10
a1627 2
See L<AnyDBM_File>.  More generically, you should consult the
FreezeThaw, Storable, or Class::Eroot modules from CPAN.
d1631 11
a1641 5
The Data::Dumper module on CPAN is nice for printing out
data structures, and FreezeThaw for copying them.  For example:

    use FreezeThaw qw(freeze thaw);
    $new = thaw freeze $old;
d1643 1
a1643 2
Where $old can be (a reference to) any kind of data structure you'd like.
It will be deeply copied.
d1653 6
d1661 15
a1675 2
Copyright (c) 1997 Tom Christiansen and Nathan Torkington.
All rights reserved.  See L<perlfaq> for distribution information.
@


1.1.1.1
log
@perl5.005_03
@
text
@d3 1
a3 1
perlfaq4 - Data Manipulation ($Revision: 1.40 $, $Date: 1999/01/08 04:26:39 $)
a14 4
The infinite set that a mathematician thinks of as the real numbers can
only be approximate on a computer, since the computer only has a finite
number of bits to store an infinite number of, um, numbers.

d16 2
a17 2
Floating-point numbers read in from a file or appearing as literals
in your program are converted from their decimal floating-point
a39 1
See L<perlop/"Floating-point Arithmetic">.  
d57 2
a58 5
=head2 Does Perl have a round() function?  What about ceil() and floor()?  Trig functions?

Remember that int() merely truncates toward 0.  For rounding to a
certain number of digits, sprintf() or printf() is usually the easiest
route.
d60 2
a61 1
    printf("%.3f", 3.1415926535);	# prints 3.142
a66 4
    use POSIX;
    $ceil   = ceil(3.5);			# 4
    $floor  = floor(3.5);			# 3

a79 13
To see why, notice how you'll still have an issue on half-way-point
alternation:

    for ($i = 0; $i < 1.01; $i += 0.05) { printf "%.1f ",$i}

    0.0 0.1 0.1 0.2 0.2 0.2 0.3 0.3 0.4 0.4 0.5 0.5 0.6 0.7 0.7 
    0.8 0.8 0.9 0.9 1.0 1.0

Don't blame Perl.  It's the same as in C.  IEEE says we have to do this.
Perl numbers whose absolute values are integers under 2**31 (on 32 bit
machines) will work pretty much like mathematical integers.  Other numbers
are not guaranteed.

d82 1
a82 1
To turn a string of 1s and 0s like C<10110110> into a scalar containing
a91 27
=head2 Why doesn't & work the way I want it to?

The behavior of binary arithmetic operators depends on whether they're
used on numbers or strings.  The operators treat a string as a series
of bits and work with that (the string C<"3"> is the bit pattern
C<00110011>).  The operators work with the binary form of a number
(the number C<3> is treated as the bit pattern C<00000011>).

So, saying C<11 & 3> performs the "and" operation on numbers (yielding
C<1>).  Saying C<"11" & "3"> performs the "and" operation on strings
(yielding C<"1">).

Most problems with C<&> and C<|> arise because the programmer thinks
they have a number but really it's a string.  The rest arise because
the programmer says:

    if ("\020\020" & "\101\101") {
	# ...
    }

but a string consisting of two null bytes (the result of C<"\020\020"
& "\101\101">) is not a false value in Perl.  You need:

    if ( ("\020\020" & "\101\101") !~ /[^\000]/) {
	# ...
    }

d112 1
a112 1
        some_func($iterator);
d117 1
a117 1
    @@results = map { some_func($_) } (5 .. 25);
d125 1
a125 1
        push(@@results, some_func($i));
d134 5
a138 5
If you're using a version of Perl before 5.004, you must call C<srand>
once at the start of your program to seed the random number generator.
5.004 and later automatically call C<srand> at the beginning.  Don't
call C<srand> more than once--you make your numbers less random, rather
than more.
d140 1
a140 13
Computers are good at being predictable and bad at being random
(despite appearances caused by bugs in your programs :-).
http://www.perl.com/CPAN/doc/FMTEYEWTK/random, courtesy of Tom
Phoenix, talks more about this..  John von Neumann said, ``Anyone who
attempts to generate random numbers by deterministic means is, of
course, living in a state of sin.''

If you want numbers that are more random than C<rand> with C<srand>
provides, you should also check out the Math::TrulyRandom module from
CPAN.  It uses the imperfections in your system's timer to generate
random numbers, but this takes quite a while.  If you want a better
pseudorandom generator than comes with your operating system, look at
``Numerical Recipes in C'' at http://www.nr.com/ .
d160 5
a164 14
Of course, this believes that weeks start at zero.  The Date::Calc
module from CPAN has a lot of date calculation functions, including
day of the year, week of the year, and so on.   Note that not
all businesses consider ``week 1'' to be the same; for example,
American businesses often consider the first week with a Monday
in it to be Work Week #1, despite ISO 8601, which considers
WW1 to be the first week with a Thursday in it.

=head2 How can I compare two dates and find the difference?

If you're storing your dates as epoch seconds then simply subtract one
from the other.  If you've got a structured date (distinct year, day,
month, hour, minute, seconds values) then use one of the Date::Manip
and Date::Calc modules from CPAN.
d169 3
a171 3
you can split it up and pass the parts to C<timelocal> in the standard
Time::Local module.  Otherwise, you should look into the Date::Calc
and Date::Manip modules from CPAN.
d175 14
a188 17
Neither Date::Manip nor Date::Calc deal with Julian days.  Instead,
there is an example of Julian date calculation that should help you in
Time::JulianDay (part of the Time-modules bundle) which can be found at
http://www.perl.com/CPAN/modules/by-module/Time/.


=head2 How do I find yesterday's date?

The C<time()> function returns the current time in seconds since the
epoch.  Take one day off that:

    $yesterday = time() - ( 24 * 60 * 60 );

Then you can pass this to C<localtime()> and get the individual year,
month, day, hour, minute, seconds values.

=head2 Does Perl have a year 2000 problem?  Is Perl Y2K compliant?
d190 1
a190 18
Short answer: No, Perl does not have a Year 2000 problem.  Yes, Perl is
Y2K compliant (whatever that means).  The programmers you've hired to
use it, however, probably are not.

Long answer: The question belies a true understanding of the issue.
Perl is just as Y2K compliant as your pencil--no more, and no less.
Can you use your pencil to write a non-Y2K-compliant memo?  Of course
you can.  Is that the pencil's fault?  Of course it isn't.

The date and time functions supplied with perl (gmtime and localtime)
supply adequate information to determine the year well beyond 2000
(2038 is when trouble strikes for 32-bit machines).  The year returned
by these functions when used in an array context is the year minus 1900.
For years between 1910 and 1999 this I<happens> to be a 2-digit decimal
number. To avoid the year 2000 problem simply do not treat the year as
a 2-digit number.  It isn't.

When gmtime() and localtime() are used in scalar context they return
a194 6
That doesn't mean that Perl can't be used to create non-Y2K compliant
programs.  It can.  But so can your pencil.  It's the fault of the user,
not the language.  At the risk of inflaming the NRA: ``Perl doesn't
break Y2K, people do.''  See http://language.perl.com/news/y2k.html for
a longer exposition.

d200 1
a200 1
with auxiliary logic.  See the more specific questions (numbers, mail
d205 2
a206 2
It depends just what you mean by ``escape''.  URL escapes are dealt
with in L<perlfaq9>.  Shell escapes with the backslash (C<\>)
d211 1
a211 1
This won't expand C<"\n"> or C<"\t"> or any other special escapes.
d215 1
a215 1
To turn C<"abbcccd"> into C<"abccd">:
d223 1
a223 1
a subroutine call (in list context) into a string:
d232 2
a233 5
Version 5.004 of Perl had a bug that gave list context to the
expression in C<${...}>, but this is fixed in version 5.005.

See also ``How can I expand variables in text strings?'' in this
section of the FAQ.
d237 6
a242 36
This isn't something that can be done in one regular expression, no
matter how complicated.  To find something between two single
characters, a pattern like C</x([^x]*)x/> will get the intervening
bits in $1. For multiple ones, then something more like
C</alpha(.*?)omega/> would be needed.  But none of these deals with
nested patterns, nor can they.  For that you'll have to write a
parser.

If you are serious about writing a parser, there are a number of
modules or oddities that will make your life a lot easier.  There is
the CPAN module Parse::RecDescent, the standard module Text::Balanced,
the byacc program, the CPAN module Parse::Yapp, and Mark-Jason
Dominus's excellent I<py> tool at http://www.plover.com/~mjd/perl/py/
.

One simple destructive, inside-out approach that you might try is to
pull out the smallest nesting parts one at a time:

    while (s//BEGIN((?:(?!BEGIN)(?!END).)*)END/gs) {
	# do something with $1
    } 

A more complicated and sneaky approach is to make Perl's regular
expression engine do it for you.  This is courtesy Dean Inada, and
rather has the nature of an Obfuscated Perl Contest entry, but it
really does work:

    # $_ contains the string to parse
    # BEGIN and END are the opening and closing markers for the
    # nested text.
 
    @@( = ('(','');
    @@) = (')','');
    ($re=$_)=~s/((BEGIN)|(END)|.)/$)[!$3]\Q$1\E$([!$2]/gs;
    @@$ = (eval{/$re/},$@@!~/unmatched/);
    print join("\n",@@$[0..$#$]) if( $$[-1] );
d246 1
a246 1
Use reverse() in scalar context, as documented in
d253 1
a253 1
You can do it yourself:
d270 1
a270 1
The paragraphs you give to Text::Wrap should not contain embedded
d276 1
a276 1
substr():
d285 1
a285 2
Although those with a pattern matching kind of thought process will
likely prefer:
d291 3
a293 3
You have to keep track of N yourself.  For example, let's say you want
to change the fifth occurrence of C<"whoever"> or C<"whomever"> into
C<"whosoever"> or C<"whomsoever">, case insensitively.
a301 17
In the more general case, you can use the C</g> modifier in a C<while>
loop, keeping count of matches.

    $WANT = 3;
    $count = 0;
    while (/(\w+)\s+fish\b/gi) {
        if (++$count == $WANT) {
            print "The third fish is a $1 one.\n";
            # Warning: don't `last' out of this loop
        }
    }

That prints out: C<"The third fish is a red one.">  You can also use a
repetition count and repeated pattern like this:

    /(?:\w+\s+fish\s+){2}(\w+)\s+fish/i;

d308 1
a308 1
    $string = "ThisXlineXhasXsomeXx'sXinXit";
d330 1
a330 1
Foy):
a347 9
You can (and probably should) enable locale awareness of those
characters by placing a C<use locale> pragma in your program.
See L<perllocale> for endless details on locales.

This is sometimes referred to as putting something into "title
case", but that's not quite accurate.  Consdier the proper
capitalization of the movie I<Dr. Strangelove or: How I Learned to
Stop Worrying and Love the Bomb>, for example.

a382 2
There's also a Text::CSV module on CPAN.

d385 1
a385 1
Although the simplest approach would seem to be:
d389 1
a389 2
This is unnecessarily slow, destructive, and fails with embedded newlines.
It is much better faster to do this in two steps:
a400 50
This idiom takes advantage of the C<foreach> loop's aliasing
behavior to factor out common code.  You can do this
on several strings at once, or arrays, or even the 
values of a hash if you use a slide:

    # trim whitespace in the scalar, the array, 
    # and all the values in the hash
    foreach ($scalar, @@array, @@hash{keys %hash}) {
        s/^\s+//;
        s/\s+$//;
    }

=head2 How do I pad a string with blanks or pad a number with zeroes?

(This answer contributed by Uri Guttman)

In the following examples, C<$pad_len> is the length to which you wish
to pad the string, C<$text> or C<$num> contains the string to be
padded, and C<$pad_char> contains the padding character. You can use a
single character string constant instead of the C<$pad_char> variable
if you know what it is in advance.

The simplest method use the C<sprintf> function. It can pad on the
left or right with blanks and on the left with zeroes.

    # Left padding with blank:
    $padded = sprintf( "%${pad_len}s", $text ) ;

    # Right padding with blank:
    $padded = sprintf( "%${pad_len}s", $text ) ;

    # Left padding with 0:
    $padded = sprintf( "%0${pad_len}d", $num ) ;

If you need to pad with a character other than blank or zero you can use
one of the following methods.

These methods generate a pad string with the C<x> operator and
concatenate that with the original text.

Left and right padding with any character:

    $padded = $pad_char x ( $pad_len - length( $text ) ) . $text ;
    $padded = $text . $pad_char x ( $pad_len - length( $text ) ) ;

Or you can left or right pad $text directly:

    $text .= $pad_char x ( $pad_len - length( $text ) ) ;
    substr( $text, 0, 0 ) = $pad_char x ( $pad_len - length( $text ) ) ;

a403 18
If you prefer thinking in terms of columns instead of widths, 
you can use this kind of thing:

    # determine the unpack format needed to split Linux ps output
    # arguments are cut columns
    my $fmt = cut2fmt(8, 14, 20, 26, 30, 34, 41, 47, 59, 63, 67, 72);

    sub cut2fmt { 
	my(@@positions) = @@_;
	my $template  = '';
	my $lastpos   = 1;
	for my $place (@@positions) {
	    $template .= "A" . ($place - $lastpos) . " "; 
	    $lastpos   = $place;
	}
	$template .= "A*";
	return $template;
    }
d414 1
d416 2
a417 7
If those were both global variables, then this would
suffice:

    $text =~ s/\$(\w+)/${$1}/g;  # no /e needed

But since they are probably lexicals, or at least, they could
be, you'd have to do this:
a419 4
    die if $@@;			# needed /ee, not /e

It's probably better in the general case to treat those
variables as entries in some special hash.  For example:
d421 2
a422 5
    %user_defs = ( 
	foo  => 23,
	bar  => 19,
    );
    $text =~ s/\$(\w+)/$user_defs{$1}/g;
d424 1
a424 1
See also ``How do I expand function calls in a string?'' in this section
d431 1
a431 3
don't want them to be.  Think of it this way: double-quote
expansion is used to produce new strings.  If you already 
have a string, why do you need more?
d461 1
a461 7
Stringification also destroys arrays.  

    @@lines = `command`;
    print "@@lines";		# WRONG - extra blanks
    print @@lines;		# right

=head2 Why don't my E<lt>E<lt>HERE documents work?
a474 66
If you want to indent the text in the here document, you 
can do this:

    # all in one
    ($VAR = <<HERE_TARGET) =~ s/^\s+//gm;
        your text
        goes here
    HERE_TARGET

But the HERE_TARGET must still be flush against the margin.
If you want that indented also, you'll have to quote 
in the indentation.

    ($quote = <<'    FINIS') =~ s/^\s+//gm;
            ...we will have peace, when you and all your works have
            perished--and the works of your dark master to whom you
            would deliver us. You are a liar, Saruman, and a corrupter
            of men's hearts.  --Theoden in /usr/src/perl/taint.c
        FINIS
    $quote =~ s/\s*--/\n--/;

A nice general-purpose fixer-upper function for indented here documents
follows.  It expects to be called with a here document as its argument.
It looks to see whether each line begins with a common substring, and
if so, strips that off.  Otherwise, it takes the amount of leading
white space found on the first line and removes that much off each
subsequent line.

    sub fix {
        local $_ = shift;
        my ($white, $leader);  # common white space and common leading string
        if (/^\s*(?:([^\w\s]+)(\s*).*\n)(?:\s*\1\2?.*\n)+$/) {
            ($white, $leader) = ($2, quotemeta($1));
        } else {
            ($white, $leader) = (/^(\s+)/, '');
        }
        s/^\s*?$leader(?:$white)?//gm;
        return $_;
    }

This works with leading special strings, dynamically determined:

    $remember_the_main = fix<<'    MAIN_INTERPRETER_LOOP';
	@@@@@@ int
	@@@@@@ runops() {
	@@@@@@     SAVEI32(runlevel);
	@@@@@@     runlevel++;
	@@@@@@     while ( op = (*op->op_ppaddr)() ) ;
	@@@@@@     TAINT_NOT;
	@@@@@@     return 0;
	@@@@@@ }
    MAIN_INTERPRETER_LOOP

Or with a fixed amount of leading white space, with remaining
indentation correctly preserved:

    $poem = fix<<EVER_ON_AND_ON;
       Now far ahead the Road has gone,
	  And I must follow, if I can,
       Pursuing it with eager feet,
	  Until it joins some larger way
       Where many paths and errands meet.
	  And whither then? I cannot say.
		--Bilbo in /usr/src/perl/pp_ctl.c
    EVER_ON_AND_ON

a476 21
=head2 What is the difference between a list and an array?

An array has a changeable length.  A list does not.  An array is something
you can push or pop, while a list is a set of values.  Some people make
the distinction that a list is a value while an array is a variable.
Subroutines are passed and return lists, you put things into list
context, you initialize arrays with lists, and you foreach() across
a list.  C<@@> variables are arrays, anonymous arrays are arrays, arrays
in scalar context behave like the number of elements in them, subroutines
access their arguments through the array C<@@_>, push/pop/shift only work
on arrays.

As a side note, there's no such thing as a list in scalar context.
When you say

    $scalar = (2, 5, 7, 9);

you're using the comma operator in scalar context, so it evaluates the
left hand side, then evaluates and returns the left hand side.  This
causes the last value to be returned: 9.

a502 1
(this assumes all true values in the array)
d507 3
a509 4
This is nice in that it doesn't use much extra memory, simulating
uniq(1)'s behavior of removing only adjacent duplicates.  It's less
nice in that it won't work with false values like undef, 0, or "";
"0 but true" is ok, though.
d534 1
a534 3
But perhaps you should have been using a hash all along, eh?

=head2 How can I tell whether a list or array contains a certain element?
d536 3
a538 7
Hearing the word "in" is an I<in>dication that you probably should have
used a hash, not a list or array, to store your data.  Hashes are
designed to answer this question quickly and efficiently.  Arrays aren't.

That being said, there are several ways to approach this.  If you
are going to make this query many times over arbitrary string values,
the fastest way is probably to invert the original array and keep an
d562 1
a562 1
    for (@@articles) { vec($read,$_,1) = 1 }
d576 1
a576 11
regexp characters in $whatever?).  If you're only testing once, then
use:

    $is_there = 0;
    foreach $elt (@@array) {
	if ($elt eq $elt_to_find) {
	    $is_there = 1;
	    last;
	}
    }
    if ($is_there) { ... }
a590 49
=head2 How do I test whether two arrays or hashes are equal?

The following code works for single-level arrays.  It uses a stringwise
comparison, and does not distinguish defined versus undefined empty
strings.  Modify if you have other needs.

    $are_equal = compare_arrays(\@@frogs, \@@toads);

    sub compare_arrays {
	my ($first, $second) = @@_;
	local $^W = 0;  # silence spurious -w undef complaints
	return 0 unless @@$first == @@$second;
	for (my $i = 0; $i < @@$first; $i++) {
	    return 0 if $first->[$i] ne $second->[$i];
	}
	return 1;
    }

For multilevel structures, you may wish to use an approach more
like this one.  It uses the CPAN module FreezeThaw:

    use FreezeThaw qw(cmpStr);
    @@a = @@b = ( "this", "that", [ "more", "stuff" ] );

    printf "a and b contain %s arrays\n",
        cmpStr(\@@a, \@@b) == 0 
	    ? "the same" 
	    : "different";

This approach also works for comparing hashes.  Here
we'll demonstrate two different answers:

    use FreezeThaw qw(cmpStr cmpStrHard);

    %a = %b = ( "this" => "that", "extra" => [ "more", "stuff" ] );
    $a{EXTRA} = \%b;
    $b{EXTRA} = \%a;                    

    printf "a and b contain %s hashes\n",
	cmpStr(\%a, \%b) == 0 ? "the same" : "different";

    printf "a and b contain %s hashes\n",
	cmpStrHard(\%a, \%b) == 0 ? "the same" : "different";


The first reports that both those the hashes contain the same data,
while the second reports that they do not.  Which you prefer is left as
an exercise to the reader.

d595 1
a595 1
    for ($i= 0; $i < @@array; $i++) {
d608 2
a609 5
or you can use splice to add and/or remove arbitrary number of elements at
arbitrary points.  Both pop and shift are both O(1) operations on perl's
dynamic arrays.  In the absence of shifts and pops, push in general
needs to reallocate on the order every log(N) times, and unshift will
need to copy pointers each time.
d613 1
a613 36
to do.  For example, imagine a list node like this:

    $node = {
        VALUE => 42,
        LINK  => undef,
    };

You could walk the list this way:

    print "List: ";
    for ($node = $head;  $node; $node = $node->{LINK}) {
        print $node->{VALUE}, " ";
    }
    print "\n";

You could grow the list this way:

    my ($head, $tail);
    $tail = append($head, 1);       # grow a new head
    for $value ( 2 .. 10 ) {
        $tail = append($tail, $value);
    }

    sub append {
        my($list, $value) = @@_;
        my $node = { VALUE => $value };
        if ($list) {
            $node->{LINK} = $list->{LINK};
            $list->{LINK} = $node;
        } else {
            $_[0] = $node;      # replace caller's version
        }
        return $node;
    }

But again, Perl's built-in are virtually always good enough.
d625 1
a625 17
Use this:

    # fisher_yates_shuffle( \@@array ) : 
    # generate a random permutation of @@array in place
    sub fisher_yates_shuffle {
        my $array = shift;
        my $i;
        for ($i = @@$array; --$i; ) {
            my $j = int rand ($i+1);
            next if $i == $j;
            @@$array[$i,$j] = @@$array[$j,$i];
        }
    }

    fisher_yates_shuffle( \@@array );    # permutes @@array in place

You've probably seen shuffling algorithms that works using splice,
d635 10
a644 4
This is bad because splice is already O(N), and since you do it N times,
you just invented a quadratic algorithm; that is, O(N**2).  This does
not scale, although Perl is so efficient that you probably won't notice
this until you have rather largish arrays.
d651 2
a652 2
	s/foo/bar/;	# change that word
	y/XZ/ZX/;	# swap those letters
d657 1
a657 1
    for (@@volumes = @@radii) {   # @@volumes has changed parts
a661 7
If you want to do the same thing to modify the values of the hash,
you may not use the C<values> function, oddly enough.  You need a slice:

    for $orbit ( @@orbits{keys %orbits} ) {
	($orbit **= 3) *= (4/3) * 3.14159; 
    }

a665 1
    # at the top of the program:
a666 2

    # then later on
a669 4
Make sure you I<only call srand once per program, if then>.
If you are calling it more than once (such as before each 
call to rand), you're almost certainly doing something wrong.

d674 1
a674 1
in the permute() function should work on any list:
d677 8
a684 7
    # tsc-permute: permute each word of input
    permute([split], []);
    sub permute {
        my @@items = @@{ $_[0] };
        my @@perms = @@{ $_[1] };
        unless (@@items) {
            print "@@perms\n";
d686 8
a693 6
            my(@@newitems,@@newperms,$i);
            foreach $i (0 .. $#items) {
                @@newitems = @@items;
                @@newperms = @@perms;
                unshift(@@newperms, splice(@@newitems, $i, 1));
                permute([@@newitems], [@@newperms]);
a787 43
Here's a demo on how to use vec():

    # vec demo
    $vector = "\xff\x0f\xef\xfe";
    print "Ilya's string \\xff\\x0f\\xef\\xfe represents the number ", 
	unpack("N", $vector), "\n";
    $is_set = vec($vector, 23, 1);
    print "Its 23rd bit is ", $is_set ? "set" : "clear", ".\n";
    pvec($vector);

    set_vec(1,1,1);
    set_vec(3,1,1);
    set_vec(23,1,1);

    set_vec(3,1,3);
    set_vec(3,2,3);
    set_vec(3,4,3);
    set_vec(3,4,7);
    set_vec(3,8,3);
    set_vec(3,8,7);

    set_vec(0,32,17);
    set_vec(1,32,17);

    sub set_vec { 
	my ($offset, $width, $value) = @@_;
	my $vector = '';
	vec($vector, $offset, $width) = $value;
	print "offset=$offset width=$width value=$value\n";
	pvec($vector);
    }

    sub pvec {
	my $vector = shift;
	my $bits = unpack("b*", $vector);
	my $i = 0;
	my $BASE = 8;

	print "vector length in bytes: ", length($vector), "\n";
	@@bytes = unpack("A8" x length($vector), $bits);
	print "bits are: @@bytes\n\n";
    } 

d790 1
a790 3
The short story is that you should probably only use defined on scalars or
functions, not on aggregates (arrays and hashes).  See L<perlfunc/defined>
in the 5.004 release or later of Perl for more detail.
d799 1
a799 1
    while ( ($key, $value) = each %hash) {
a864 1
The Tie::IxHash module from CPAN might also be instructive.
d956 1
a956 1
Using C<keys %hash> in scalar context returns the number of keys in
d1024 3
a1026 15
Usually a hash ref, perhaps like this:

    $record = {
        NAME   => "Jason",
        EMPNO  => 132,
        TITLE  => "deputy peon",
        AGE    => 23,
        SALARY => 37_000,
        PALS   => [ "Norbert", "Rhys", "Phineas"],
    };

References are documented in L<perlref> and the upcoming L<perlreftut>.
Examples of complex data structures are given in L<perldsc> and
L<perllol>.  Examples of structures and object-oriented classes are
in L<perltoot>.
d1044 2
a1045 3
On some legacy systems, however, you have to play tedious games with
"text" versus "binary" files.  See L<perlfunc/"binmode">, or the upcoming
L<perlopentut> manpage.
d1057 13
a1069 36
   if (/\D/)            { print "has nondigits\n" }
   if (/^\d+$/)         { print "is a whole number\n" }
   if (/^-?\d+$/)       { print "is an integer\n" }
   if (/^[+-]?\d+$/)    { print "is a +/- integer\n" }
   if (/^-?\d+\.?\d*$/) { print "is a real number\n" }
   if (/^-?(?:\d+(?:\.\d*)?|\.\d+)$/) { print "is a decimal number" }
   if (/^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/)
			{ print "a C float" }

If you're on a POSIX system, Perl's supports the C<POSIX::strtod>
function.  Its semantics are somewhat cumbersome, so here's a C<getnum>
wrapper function for more convenient access.  This function takes
a string and returns the number it found, or C<undef> for input that
isn't a C float.  The C<is_numeric> function is a front end to C<getnum>
if you just want to say, ``Is this a float?''

    sub getnum {
        use POSIX qw(strtod);
        my $str = shift;
        $str =~ s/^\s+//;
        $str =~ s/\s+$//;
        $! = 0;
        my($num, $unparsed) = strtod($str);
        if (($str eq '') || ($unparsed != 0) || $!) {
            return undef;
        } else {
            return $num;
        } 
    } 

    sub is_numeric { defined &getnum } 

Or you could check out String::Scanf which can be found at
http://www.perl.com/CPAN/modules/by-module/String/.
The POSIX module (part of the standard Perl distribution) provides 
the C<strtol> and C<strtod> for converting strings to double
d1075 2
a1076 10
See L<AnyDBM_File>.  More generically, you should consult the FreezeThaw,
Storable, or Class::Eroot modules from CPAN.  Here's one example using
Storable's C<store> and C<retrieve> functions:

    use Storable; 
    store(\%hash, "filename");

    # later on...  
    $href = retrieve("filename");        # by ref
    %hash = %{ retrieve("filename") };   # direct to hash
d1080 5
a1084 11
The Data::Dumper module on CPAN (or the 5.005 release of Perl) is great
for printing out data structures.  The Storable module, found on CPAN,
provides a function called C<dclone> that recursively copies its argument.

    use Storable qw(dclone); 
    $r2 = dclone($r1);

Where $r1 can be a reference to any kind of data structure you'd like.
It will be deeply copied.  Because C<dclone> takes and returns references,
you'd have to add extra punctuation if you had a hash of arrays that
you wanted to copy.
d1086 2
a1087 1
    %newhash = %{ dclone(\%oldhash) };
a1096 6
=head2 How do I pack arrays of doubles or floats for XS code?

The kgbpack.c code in the PGPLOT module on CPAN does just this.
If you're doing a lot of float or double processing, consider using
the PDL module from CPAN instead--it makes number-crunching easy.

d1099 2
a1100 15
Copyright (c) 1997-1999 Tom Christiansen and Nathan Torkington.
All rights reserved.

When included as part of the Standard Version of Perl, or as part of
its complete documentation whether printed or otherwise, this work
may be distributed only under the terms of Perl's Artistic Licence.
Any distribution of this file or derivatives thereof I<outside>
of that package require that special arrangements be made with
copyright holder.

Irrespective of its distribution, all code examples in this file
are hereby placed into the public domain.  You are permitted and
encouraged to use this code in your own programs for fun
or for profit as you see fit.  A simple comment in the code giving
credit would be courteous but is not required.
@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
perlfaq4 - Data Manipulation ($Revision: 1.49 $, $Date: 1999/05/23 20:37:49 $)
d34 1
a34 1
Perl4.  Changing C<$#> yourself is deprecated.)
d70 1
a70 1
The POSIX module (part of the standard Perl distribution) implements
d79 1
a79 1
module.  With 5.004, the Math::Trig module (part of the standard Perl
d107 2
a108 2
its binary value, use the pack() and unpack() functions (documented in
L<perlfunc/"pack"> and L<perlfunc/"unpack">):
d110 1
a110 8
    $decimal = unpack('c', pack('B8', '10110110'));

This packs the string C<10110110> into an eight bit binary structure.
This is then unpacked as a character, which returns its ordinal value.

This does the same thing:

    $decimal = ord(pack('B8', '10110110'));
d114 1
a114 1
    $binary_string = unpack('B*', "\x29");
a178 9
This situation has been fixed in Perl5.005. Use of C<..> in a C<for>
loop will iterate over the range, without creating the entire range.

    for my $i (5 .. 500_005) {
        push(@@results, some_func($i));
    }

will not create a list of 500,000 integers.

a230 17
=head2 How do I find the current century or millennium?

Use the following simple functions:

    sub get_century    { 
	return int((((localtime(shift || time))[5] + 1999))/100);
    } 
    sub get_millennium { 
	return 1+int((((localtime(shift || time))[5] + 1899))/1000);
    } 

On some systems, you'll find that the POSIX module's strftime() function
has been extended in a non-standard way to use a C<%C> format, which they
sometimes claim is the "century".  It isn't, because on most such systems,
this is only the first two digits of the four-digit year, and thus cannot
be used to reliably determine the current century or millennium.

d235 2
a236 7
month, hour, minute, seconds values), then for reasons of accessibility,
simplicity, and efficiency, merely use either timelocal or timegm (from
the Time::Local module in the standard distribution) to reduce structured
dates to epoch seconds.  However, if you don't know the precise format of
your dates, then you should probably use either of the Date::Manip and
Date::Calc modules from CPAN before you go hacking up your own parsing
routine to handle arbitrary date formats.
d247 4
a250 2
Use the Time::JulianDay module (part of the Time-modules bundle
available from CPAN.)
a251 15
Before you immerse yourself too deeply in this, be sure to verify that it
is the I<Julian> Day you really want.  Are they really just interested in
a way of getting serial days so that they can do date arithmetic?  If you
are interested in performing date arithmetic, this can be done using
either Date::Manip or Date::Calc, without converting to Julian Day first.

There is too much confusion on this issue to cover in this FAQ, but the
term is applied (correctly) to a calendar now supplanted by the Gregorian
Calendar, with the Julian Calendar failing to adjust properly for leap
years on centennial years (among other annoyances).  The term is also used
(incorrectly) to mean: [1] days in the Gregorian Calendar; and [2] days
since a particular starting time or `epoch', usually 1970 in the Unix
world and 1980 in the MS-DOS/Windows world.  If you find that it is not
the first meaning that you really want, then check out the Date::Manip
and Date::Calc modules.  (Thanks to David Cassell for most of this text.)
d256 1
a256 1
epoch.  Take twenty-four hours off that:
d263 1
a263 46
Note very carefully that the code above assumes that your days are
twenty-four hours each.  For most people, there are two days a year
when they aren't: the switch to and from summer time throws this off.
A solution to this issue is offered by Russ Allbery.

    sub yesterday {
	my $now  = defined $_[0] ? $_[0] : time;
	my $then = $now - 60 * 60 * 24;
	my $ndst = (localtime $now)[8] > 0;
	my $tdst = (localtime $then)[8] > 0;
	$then - ($tdst - $ndst) * 60 * 60;
    }
    # Should give you "this time yesterday" in seconds since epoch relative to
    # the first argument or the current time if no argument is given and
    # suitable for passing to localtime or whatever else you need to do with
    # it.  $ndst is whether we're currently in daylight savings time; $tdst is
    # whether the point 24 hours ago was in daylight savings time.  If $tdst
    # and $ndst are the same, a boundary wasn't crossed, and the correction
    # will subtract 0.  If $tdst is 1 and $ndst is 0, subtract an hour more
    # from yesterday's time since we gained an extra hour while going off
    # daylight savings time.  If $tdst is 0 and $ndst is 1, subtract a
    # negative hour (add an hour) to yesterday's time since we lost an hour.
    #
    # All of this is because during those days when one switches off or onto
    # DST, a "day" isn't 24 hours long; it's either 23 or 25.
    #
    # The explicit settings of $ndst and $tdst are necessary because localtime
    # only says it returns the system tm struct, and the system tm struct at
    # least on Solaris doesn't guarantee any particular positive value (like,
    # say, 1) for isdst, just a positive value.  And that value can
    # potentially be negative, if DST information isn't available (this sub
    # just treats those cases like no DST).
    #
    # Note that between 2am and 3am on the day after the time zone switches
    # off daylight savings time, the exact hour of "yesterday" corresponding
    # to the current hour is not clearly defined.  Note also that if used
    # between 2am and 3am the day after the change to daylight savings time,
    # the result will be between 3am and 4am of the previous day; it's
    # arguable whether this is correct.
    #
    # This sub does not attempt to deal with leap seconds (most things don't).
    #
    # Copyright relinquished 1999 by Russ Allbery <rra@@stanford.edu>
    # This code is in the public domain

=head2 Does Perl have a Year 2000 problem?  Is Perl Y2K compliant?
d274 1
a274 1
The date and time functions supplied with Perl (gmtime and localtime)
d315 1
a315 5
    s/(.)\1/$1/g;	# add /s to include newlines

Here's a solution that turns "abbcccd" to "abcd":

    y///cs;	# y == tr, but shorter :-)
d347 5
a351 3
modules or oddities that will make your life a lot easier.  There are
the CPAN modules Parse::RecDescent, Parse::Yapp, and Text::Balanced;
and the byacc program.
d356 1
a356 1
    while (s/BEGIN((?:(?!BEGIN)(?!END).)*)END//gs) {
d368 1
a368 1

d388 1
a388 1
Or you can just use the Text::Tabs module (part of the standard Perl
d396 1
a396 1
Use Text::Wrap (part of the standard Perl distribution):
d425 1
a425 2
C<"whosoever"> or C<"whomsoever">, case insensitively.  These
all assume that $_ contains the string to be altered.
d432 1
a432 1
    }ige;
a438 1
    $_ = "One fish two fish red fish blue fish";
d442 1
d459 1
a459 1
    print "There are $count X characters in the string";
d478 2
a479 2
Do It>".  Sometimes you might want this, instead (Suggested by brian d. 
foy):
d502 1
a502 1
case", but that's not quite accurate.  Consider the proper
d535 1
a535 1
Alternatively, the Text::ParseWords module (part of the standard Perl
d549 2
a550 2
Not only is this unnecessarily slow and destructive, it also fails with
embedded newlines.  It is much faster to do this operation in two steps:
d565 1
a565 1
values of a hash if you use a slice:
d576 1
a576 2
(This answer contributed by Uri Guttman, with kibitzing from
Bart Lateur.) 
d579 7
a585 14
to pad the string, C<$text> or C<$num> contains the string to be padded,
and C<$pad_char> contains the padding character. You can use a single
character string constant instead of the C<$pad_char> variable if you
know what it is in advance. And in the same way you can use an integer in
place of C<$pad_len> if you know the pad length in advance.

The simplest method uses the C<sprintf> function. It can pad on the left
or right with blanks and on the left with zeroes and it will not
truncate the result. The C<pack> function can only pad strings on the
right with blanks and it will truncate the result to a maximum length of
C<$pad_len>.

    # Left padding a string with blanks (no truncation):
    $padded = sprintf("%${pad_len}s", $text);
d587 2
a588 2
    # Right padding a string with blanks (no truncation):
    $padded = sprintf("%-${pad_len}s", $text);
d590 2
a591 2
    # Left padding a number with 0 (no truncation): 
    $padded = sprintf("%0${pad_len}d", $num);
d593 2
a594 2
    # Right padding a string with blanks using pack (will truncate):
    $padded = pack("A$pad_len",$text);
d597 4
a600 3
one of the following methods.  They all generate a pad string with the
C<x> operator and combine that with C<$text>. These methods do
not truncate C<$text>.
d602 1
a602 1
Left and right padding with any character, creating a new string:
d604 2
a605 2
    $padded = $pad_char x ( $pad_len - length( $text ) ) . $text;
    $padded = $text . $pad_char x ( $pad_len - length( $text ) );
d607 1
a607 1
Left and right padding with any character, modifying C<$text> directly:
d609 2
a610 2
    substr( $text, 0, 0 ) = $pad_char x ( $pad_len - length( $text ) );
    $text .= $pad_char x ( $pad_len - length( $text ) );
d636 1
a636 8
Use the standard Text::Soundex module distributed with Perl.
But before you do so, you may want to determine whether `soundex' is in
fact what you think it is.  Knuth's soundex algorithm compresses words
into a small space, and so it does not necessarily distinguish between
two words which you might want to appear separately.  For example, the
last names `Knuth' and `Kant' are both mapped to the soundex code K530.
If Text::Soundex does not do what you are looking for, you might want
to consider the String::Approx module available at CPAN.
d709 1
a709 1
=head2 Why don't my <<HERE documents work?
d770 1
a770 1
	@@@@@@     while ( op = (*op->op_ppaddr)() );
d808 3
a810 3
you're using the comma operator in scalar context, so it uses the scalar
comma operator.  There never was a list there at all!  This causes the
last value to be returned: 9.
d828 1
a828 2
The C<use warnings> pragma and the B<-w> flag will warn you about these 
matters.
d830 1
a830 1
=head2 How can I remove duplicate elements from a list or array?
d846 1
a846 1
"0 but true" is OK, though.
d867 1
a867 1
    @@out = grep {defined} @@ary;
d896 1
a896 2
    for (@@primes) { $is_tiny_prime[$_] = 1 }
    # or simply  @@istiny_prime[@@primes] = (1) x @@primes;
d919 1
a919 1
regex characters in $whatever?).  If you're only testing once, then
a943 3
Note that this is the I<symmetric difference>, that is, all elements in
either A or in B, but not in both.  Think of it as an xor operation.

d954 1
a954 1
	no warnings;  # silence spurious -w undef complaints
d1011 1
a1011 1
arbitrary points.  Both pop and shift are both O(1) operations on Perl's
d1081 1
a1081 1
You've probably seen shuffling algorithms that work using splice,
d1166 1
a1166 1
sort C<(1, 2, 10)> into C<(1, 10, 2)>.  C<< <=> >>, used above, is
d1188 1
a1188 1
	      map  { [ $_, uc( (/\d+\s*(\S+)/)[0]) ] } @@data;
d1314 1
a1314 13
Don't do that. :-)

[lwall] In Perl 4, you were not allowed to modify a hash at all while
iterating over it.  In Perl 5 you can delete from it, but you still
can't add to it, because that might cause a doubling of the hash table,
in which half the entries get copied up to the new top half of the
table, at which point you've totally bamboozled the iterator code.
Even if the table doesn't double, there's no telling whether your new
entry will be inserted before or after the current iterator position.

Either treasure up your changes and make them after the iterator finishes,
or use keys to fetch all the old keys at once, and iterate over the list
of keys.
d1330 2
a1331 7
If your hash could have repeated values, the methods above will only find
one of the associated keys.   This may or may not worry you.  If it does
worry you, you can always reverse the hash into a hash of arrays instead:

     while (($key, $value) = each %by_key) {
	 push @@{$key_list_by_value{$value}}, $key;
     }
d1340 2
a1341 3
In void context, the keys() function just resets the iterator, which is
faster for tied hashes than would be iterating through the whole 
hash, one key-value pair at a time.
d1399 1
a1399 1
	exists $ary{'a'}                is true (Perl5 only)
d1423 1
a1423 1
	exists $ary{'a'}                is true (Perl5 only)
d1447 1
a1447 1
	exists $ary{'a'}                is FALSE (Perl5 only)
d1470 2
a1471 2
First you extract the keys from the hashes into lists, then solve
the "removing duplicates" problem described above.  For example:
d1523 1
a1523 1
This has been fixed as of Perl5.004.
d1550 1
a1550 1
module distributed with Perl.
d1563 3
a1565 5
On less elegant (read: Byzantine) systems, however, you have
to play tedious games with "text" versus "binary" files.  See
L<perlfunc/"binmode"> or L<perlopentut>.  Most of these ancient-thinking
systems are curses out of Microsoft, who seem to be committed to putting
the backward into backward compatibility.
d1607 1
a1607 1
    sub is_numeric { defined getnum($_[0]) } 
d1609 5
a1613 4
Or you could check out the String::Scanf module on CPAN instead.  The
POSIX module (part of the standard Perl distribution) provides the
C<strtol> and C<strtod> for converting strings to double and longs,
respectively.
d1666 1
a1666 1
may be distributed only under the terms of Perl's Artistic License.
d1676 1
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d7 1
a7 1
The section of the FAQ answers questions related to the manipulation
d16 1
a16 1
only be approximated on a computer, since the computer only has a finite
d22 1
a22 1
representation (eg, 19.95) to an internal binary representation.
d32 1
a32 1
current output format for numbers.  (See L<perlvar/"$#"> if you use
d78 1
a78 1
In 5.000 to 5.003 perls, trigonometry was done in the Math::Complex
d209 2
a210 2
http://www.perl.com/CPAN/doc/FMTEYEWTK/random , courtesy of Tom
Phoenix, talks more about this.  John von Neumann said, ``Anyone who
d289 1
a289 1
is the I<Julian> Day you really want.  Are you really just interested in
d373 1
a373 1
by these functions when used in a list context is the year minus 1900.
d401 1
a401 1
character are removed with
d515 1
a515 1
likely prefer
d552 1
a552 1
There are a number of ways, with varying efficiency.  If you want a
d577 2
a578 2
Do It>".  Sometimes you might want this.  Other times you might need a
more thorough solution (Suggested by brian d.  foy):
d640 1
a640 1
There's also a Text::CSV (Comma-Separated Values) module on CPAN.
d644 1
a644 1
Although the simplest approach would seem to be
d648 1
a648 1
not only is this unnecessarily slow and destructive, it also fails with
d743 1
a743 1
Before you do so, you may want to determine whether `soundex' is in
d782 3
a784 3
The problem is that those double-quotes force stringification--
coercing numbers and references into strings--even when you
don't want them to be strings.  Think of it this way: double-quote
d860 2
a861 2
if so, strips that substring off.  Otherwise, it takes the amount of leading
whitespace found on the first line and removes that much off each
d866 1
a866 1
        my ($white, $leader);  # common whitespace and common leading string
d889 1
a889 1
Or with a fixed amount of leading whitespace, with remaining
d913 1
a913 1
access their arguments through the array C<@@_>, and push/pop/shift only work
d927 1
a927 1
The former is a scalar value; the latter an array slice, making
d951 1
a951 3
=item a)

If @@in is sorted, and you want @@out to be sorted:
d954 2
a955 2
    $prev = "not equal to $in[0]";
    @@out = grep($_ ne $prev && ($prev = $_, 1), @@in);
d958 3
a960 5
uniq(1)'s behavior of removing only adjacent duplicates.  The ", 1"
guarantees that the expression is true (so that grep picks it up)
even if the $_ is 0, "", or undef.

=item b)
d962 1
a962 1
If you don't know whether @@in is sorted:
d967 1
a967 3
=item c)

Like (b), but @@in contains only small integers:
d971 1
a971 3
=item d)

A way to do (b) without any loops or greps:
d977 1
a977 3
=item e)

Like (d), but @@in contains only small positive integers:
d1026 1
a1026 1
    ($is_there) = grep $_ eq $whatever, @@array;
d1030 1
a1030 1
    ($is_there) = grep /$whatever/, @@array;
d1060 1
a1060 1
either A or in B but not in both.  Think of it as an xor operation.
d1151 1
a1151 1
You could add to the list this way:
d1192 1
d1200 1
a1200 1
randomly picking another element to swap the current element with
d1301 1
a1301 1
which could also be written this way, using a trick
d1442 1
a1442 1
Either treasure up your changes and make them after the iterator finishes
d1475 1
a1475 1
The keys() function also resets the iterator, which in void context is
d1491 2
a1492 2
identical, sort by length of key, or if that fails, by straight ASCII
comparison of the keys (well, possibly modified by your locale--see
d1749 1
a1749 1
C<strtod> and C<strtol> for converting strings to double and longs,
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
perlfaq4 - Data Manipulation ($Revision: 1.25 $, $Date: 2002/05/30 07:04:25 $)
d7 3
a9 2
This section of the FAQ answers questions related to manipulating
numbers, dates, strings, arrays, hashes, and miscellaneous data issues.
a41 5
If precision is important, such as when dealing with money, it's good
to work with integers and then divide at the last possible moment.
For example, work in pennies (1995) instead of dollars and cents
(19.95) and divide by 100 at the end.

d49 3
a51 5
as literals in your program.  Octal literals in perl must start with 
a leading "0" and hexadecimal literals must start with a leading "0x".
If they are read in from somewhere and assigned, no automatic 
conversion takes place.  You must explicitly use oct() or hex() if you 
want the values converted to decimal.  oct() interprets
a54 3
The inverse mapping from decimal to octal can be done with either the
"%o" or "%O" sprintf() formats.  To get from decimal to hex try either 
the "%x" or the "%X" formats to sprintf().
d57 1
a57 2
umask(), or sysopen(), which by widespread tradition typically take 
permissions in octal.
d59 1
a59 1
    chmod(644,  $file);	# WRONG
a61 11
Note the mistake in the first line was specifying the decimal literal 
644, rather than the intended octal literal 0644.  The problem can
be seen with:

    printf("%#o",644); # prints 01204

Surely you had not intended C<chmod(01204, $file);> - did you?  If you
want to use numeric literals as arguments to chmod() et al. then please
try to express them as octal constants, that is with a leading zero and 
with the following digits restricted to the set 0..7.

d104 1
a104 45
=head2 How do I convert between numeric representations?

As always with Perl there is more than one way to do it.  Below
are a few examples of approaches to making common conversions
between number representations.  This is intended to be representational
rather than exhaustive.

Some of the examples below use the Bit::Vector module from CPAN.
The reason you might choose Bit::Vector over the perl built in
functions is that it works with numbers of ANY size, that it is
optimized for speed on some operations, and for at least some
programmers the notation might be familiar.

=over 4

=item How do I convert hexadecimal into decimal

Using perl's built in conversion of 0x notation:

    $int = 0xDEADBEEF;
    $dec = sprintf("%d", $int);

Using the hex function:

    $int = hex("DEADBEEF");
    $dec = sprintf("%d", $int);

Using pack:

    $int = unpack("N", pack("H8", substr("0" x 8 . "DEADBEEF", -8)));
    $dec = sprintf("%d", $int);

Using the CPAN module Bit::Vector:

    use Bit::Vector;
    $vec = Bit::Vector->new_Hex(32, "DEADBEEF");
    $dec = $vec->to_Dec();

=item How do I convert from decimal to hexadecimal

Using sprint:

    $hex = sprintf("%X", 3735928559);

Using unpack
d106 3
a108 1
    $hex = unpack("H*", pack("N", 3735928559));
d110 1
a110 1
Using Bit::Vector
d112 2
a113 3
    use Bit::Vector;
    $vec = Bit::Vector->new_Dec(32, -559038737);
    $hex = $vec->to_Hex();
d115 1
a115 46
And Bit::Vector supports odd bit counts:

    use Bit::Vector;
    $vec = Bit::Vector->new_Dec(33, 3735928559);
    $vec->Resize(32); # suppress leading 0 if unwanted
    $hex = $vec->to_Hex();

=item How do I convert from octal to decimal

Using Perl's built in conversion of numbers with leading zeros:

    $int = 033653337357; # note the leading 0!
    $dec = sprintf("%d", $int);

Using the oct function:

    $int = oct("33653337357");
    $dec = sprintf("%d", $int);

Using Bit::Vector:

    use Bit::Vector;
    $vec = Bit::Vector->new(32);
    $vec->Chunk_List_Store(3, split(//, reverse "33653337357"));
    $dec = $vec->to_Dec();

=item How do I convert from decimal to octal

Using sprintf:

    $oct = sprintf("%o", 3735928559);

Using Bit::Vector

    use Bit::Vector;
    $vec = Bit::Vector->new_Dec(32, -559038737);
    $oct = reverse join('', $vec->Chunk_List_Read(3));

=item How do I convert from binary to decimal

Perl 5.6 lets you write binary numbers directly with
the 0b notation:

	$number = 0b10110110;

Using pack and ord
d119 1
a119 5
Using pack and unpack for larger strings

    $int = unpack("N", pack("B32",
	substr("0" x 32 . "11110101011011011111011101111", -32)));
    $dec = sprintf("%d", $int);
d121 1
a121 23
    # substr() is used to left pad a 32 character string with zeros.

Using Bit::Vector:

    $vec = Bit::Vector->new_Bin(32, "11011110101011011011111011101111");
    $dec = $vec->to_Dec();

=item How do I convert from decimal to binary

Using unpack;

    $bin = unpack("B*", pack("N", 3735928559));

Using Bit::Vector:

    use Bit::Vector;
    $vec = Bit::Vector->new_Dec(32, -559038737);
    $bin = $vec->to_Bin();

The remaining transformations (e.g. hex -> oct, bin -> hex, etc.)
are left as an exercise to the inclined reader.

=back
d197 1
a197 1
Get the http://www.cpan.org/modules/by-module/Roman module.
d208 4
a211 5
(despite appearances caused by bugs in your programs :-).  see the
F<random> artitcle in the "Far More Than You Ever Wanted To Know"
collection in http://www.cpan.org/olddoc/FMTEYEWTK.tgz , courtesy of
Tom Phoenix, talks more about this.  John von Neumann said, ``Anyone
who attempts to generate random numbers by deterministic means is, of
a220 14
=head2 How do I get a random number between X and Y?

Use the following simple function.  It selects a random integer between
(and possibly including!) the two given integers, e.g.,
C<random_int_in(50,120)>

   sub random_int_in ($$) {
     my($min, $max) = @@_;
      # Assumes that the two arguments are integers themselves!
     return $min if $min == $max;
     ($min, $max) = ($max, $min)  if  $min > $max;
     return $min + int rand(1 + $max - $min);
   }

d230 17
d288 3
a290 4
Before you immerse yourself too deeply in this, be sure to verify that
it is the I<Julian> Day you really want.  Are you interested in a way
of getting serial days so that you just can tell how many days they
are apart or so that you can do also other date arithmetic?  If you
d292 1
a292 1
modules Date::Manip or Date::Calc.
d294 9
a302 10
There is too many details and much confusion on this issue to cover in
this FAQ, but the term is applied (correctly) to a calendar now
supplanted by the Gregorian Calendar, with the Julian Calendar failing
to adjust properly for leap years on centennial years (among other
annoyances).  The term is also used (incorrectly) to mean: [1] days in
the Gregorian Calendar; and [2] days since a particular starting time
or `epoch', usually 1970 in the Unix world and 1980 in the
MS-DOS/Windows world.  If you find that it is not the first meaning
that you really want, then check out the Date::Manip and Date::Calc
modules.  (Thanks to David Cassell for most of this text.)
d449 1
a449 2
and the byacc program.   Starting from perl 5.8 the Text::Balanced
is part of the standard distribution.
d470 1
a470 1
    @@$ = (eval{/$re/},$@@!~/unmatched/i);
a501 9
Or use the CPAN module Text::Autoformat.  Formatting files can be easily
done by making a shell alias, like so:

    alias fmt="perl -i -MText::Autoformat -n0777 \
        -e 'print autoformat $_, {all=>1}' $*"

See the documentation for Text::Autoformat to appreciate its many
capabilities.

a569 5
Another version uses a global match in list context, then assigns the
result to a scalar, producing a count of the number of matches.

	$count = () = $string =~ /-\d+/g;

d578 1
a578 1
more thorough solution (Suggested by brian d foy):
d855 1
a855 1
    $quote =~ s/\s+--/\n--/;
d997 1
a997 1
=head2 How can I tell whether a certain element is contained in a list or array?
d1005 2
a1006 2
the fastest way is probably to invert the original array and maintain a
hash whose keys are the first array's values.
d1009 1
a1009 1
    %is_blue = ();
d1019 1
a1019 1
    @@is_tiny_prime = ();
d1193 1
a1193 8
If you either have Perl 5.8.0 or later installed, or if you have
Scalar-List-Utils 1.03 or later installed, you can say:

    use List::Util 'shuffle';

	@@shuffled = shuffle(@@list);

If not, you can use a Fisher-Yates shuffle.
d1195 2
d1198 3
a1200 3
        my $deck = shift;  # $deck is a reference to an array
        my $i = @@$deck;
        while ($i--) {
d1202 1
a1202 1
            @@$deck[$i,$j] = @@$deck[$j,$i];
d1206 1
a1206 9
    # shuffle my mpeg collection
    #
    my @@mpeg = <audio/*/*.mp3>;
    fisher_yates_shuffle( \@@mpeg );    # randomize @@mpeg in place
    print @@mpeg;

Note that the above implementation shuffles an array in place,
unlike the List::Util::shuffle() which takes a list and returns
a new shuffled list.
d1239 2
a1240 4
If you want to do the same thing to modify the values of the
hash, you can use the C<values> function.  As of Perl 5.6
the values are not copied, so if you modify $orbit (in this
case), you modify the value.
d1242 1
a1242 1
    for $orbit ( values %orbits ) {
a1245 5
Prior to perl 5.6 C<values> returned copies of the values,
so older perl code often contains constructions such as
C<@@orbits{keys %orbits}> instead of C<values %orbits> where
the hash is to be modified.

a1285 6
Unfortunately, this algorithm is very inefficient. The Algorithm::Permute
module from CPAN runs at least an order of magnitude faster. If you don't
have a C compiler (or a binary distribution of Algorithm::Permute), then
you can use List::Permutor which is written in pure Perl, and is still
several times faster than the algorithm above.

d1327 2
a1328 3
See the F<sort> artitcle article in the "Far More Than You Ever Wanted
To Know" collection in http://www.cpan.org/olddoc/FMTEYEWTK.tgz for
more about this approach.
d1341 1
a1341 1
Here's how, given a vector in $vec, you can
d1376 1
a1376 17
You can make the while loop a lot shorter with this suggestion
from Benjamin Goldberg:

	while($vec =~ /[^\0]+/g ) {
	   push @@ints, grep vec($vec, $_, 1), $-[0] * 8 .. $+[0] * 8;
	}

Or use the CPAN module Bit::Vector:

    $vector = Bit::Vector->new($num_of_bits);
    $vector->Index_List_Store(@@ints);
    @@ints = $vector->Index_List_Read();

Bit::Vector provides efficient methods for bit vector, sets of small integers
and "big int" math. 

Here's a more extensive illustration using vec():
d1480 1
a1480 1
use the keys() function in a scalar context:
d1482 1
a1482 1
    $num_keys = keys %hash;
d1484 3
a1486 3
The keys() function also resets the iterator, which means that you may 
see strange results if you use this between uses of other hash operators 
such as each().
d1520 7
a1526 9
Hashes contain pairs of scalars: the first is the key, the
second is the value.  The key will be coerced to a string,
although the value can be any kind of scalar: string,
number, or reference.  If a key $key is present in
%hash, C<exists($hash{$key})> will return true.  The value
for a given key can be C<undef>, in which case
C<$hash{$key}> will be C<undef> while C<exists $hash{$key}>
will return true.  This corresponds to (C<$key>, C<undef>)
being in the hash.
d1528 1
a1528 1
Pictures help...  here's the %hash table:
d1540 6
a1545 6
	$hash{'a'}                       is true
	$hash{'d'}                       is false
	defined $hash{'d'}               is true
	defined $hash{'a'}               is true
	exists $hash{'a'}                is true (Perl5 only)
	grep ($_ eq 'a', keys %hash)     is true
d1549 1
a1549 1
	undef $hash{'a'}
d1564 6
a1569 6
	$hash{'a'}                       is FALSE
	$hash{'d'}                       is false
	defined $hash{'d'}               is true
	defined $hash{'a'}               is FALSE
	exists $hash{'a'}                is true (Perl5 only)
	grep ($_ eq 'a', keys %hash)     is true
d1575 1
a1575 1
	delete $hash{'a'}
d1588 6
a1593 6
	$hash{'a'}                       is false
	$hash{'d'}                       is false
	defined $hash{'d'}               is true
	defined $hash{'a'}               is false
	exists $hash{'a'}                is FALSE (Perl5 only)
	grep ($_ eq 'a', keys %hash)     is FALSE
d1599 6
a1604 5
This depends on the tied hash's implementation of EXISTS().
For example, there isn't the concept of undef with hashes
that are tied to DBM* files. It also means that exists() and
defined() do the same thing with a DBM* file, and what they
end up doing is not what they do with ordinary hashes.
d1694 1
a1694 1
You can't do this directly, but you could use the standard Tie::RefHash
d1729 1
a1729 1
   if (/^-?(?:\d+(?:\.\d*)?|\.\d+)$/) { print "is a decimal number\n" }
d1731 1
a1731 5
			{ print "a C float\n" }

You can also use the L<Data::Types|Data::Types> module on
the CPAN, which exports functions that validate data types
using these and other regular expressions.
d1756 3
a1758 3
Or you could check out the L<String::Scanf|String::Scanf> module on the CPAN
instead. The POSIX module (part of the standard Perl distribution) provides
the C<strtod> and C<strtol> for converting strings to double and longs,
d1764 3
a1766 4
See L<AnyDBM_File>.  More generically, you should consult the FreezeThaw
or Storable modules from CPAN.  Starting from Perl 5.8 Storable is part
of the standard distribution.  Here's one example using Storable's C<store>
and C<retrieve> functions:
d1807 1
a1807 1
Copyright (c) 1997-2002 Tom Christiansen and Nathan Torkington.
d1810 6
a1815 2
This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 1
perlfaq4 - Data Manipulation ($Revision: 1.52 $, $Date: 2003/10/02 04:44:33 $)
d14 35
a48 34
Internally, your computer represents floating-point numbers
in binary. Digital (as in powers of two) computers cannot
store all numbers exactly.  Some real numbers lose precision
in the process.  This is a problem with how computers store
numbers and affects all computer languages, not just Perl.

L<perlnumber> show the gory details of number
representations and conversions.

To limit the number of decimal places in your numbers, you
can use the printf or sprintf function.  See the
L<"Floating Point Arithmetic"|perlop> for more details.

	printf "%.2f", 10/3;

	my $number = sprintf "%.2f", 10/3;

=head2 Why is int() broken?

Your int() is most probably working just fine.  It's the numbers that
aren't quite what you think.

First, see the above item "Why am I getting long decimals
(eg, 19.9499999999999) instead of the numbers I should be getting
(eg, 19.95)?".

For example, this

    print int(0.6/0.2-2), "\n";

will in most computers print 0, not 1, because even such simple
numbers as 0.6 and 0.2 cannot be presented exactly by floating-point
numbers.  What you think in the above as 'three' is really more like
2.9999999999999995559.
d52 9
a60 9
Perl only understands octal and hex numbers as such when they occur as
literals in your program.  Octal literals in perl must start with a
leading "0" and hexadecimal literals must start with a leading "0x".
If they are read in from somewhere and assigned, no automatic
conversion takes place.  You must explicitly use oct() or hex() if you
want the values converted to decimal.  oct() interprets hex ("0x350"),
octal ("0350" or even without the leading "0", like "377") and binary
("0b1010") numbers, while hex() only converts hexadecimal ones, with
or without a leading "0x", like "0x255", "3A", "ff", or "deadbeef".
d62 2
a63 1
"%o" or "%O" sprintf() formats.
d66 1
a66 1
umask(), or sysopen(), which by widespread tradition typically take
d72 1
a72 1
Note the mistake in the first line was specifying the decimal literal
d80 1
a80 1
try to express them as octal constants, that is with a leading zero and
d117 1
a117 1
    0.0 0.1 0.1 0.2 0.2 0.2 0.3 0.3 0.4 0.4 0.5 0.5 0.6 0.7 0.7
d125 1
a125 1
=head2 How do I convert between numeric representations/bases/radixes?
d144 2
a145 1
    $dec = 0xDEADBEEF;
d149 2
a150 1
    $dec = hex("DEADBEEF");
d154 2
a155 1
    $dec = unpack("N", pack("H8", substr("0" x 8 . "DEADBEEF", -8)));
d165 1
a165 1
Using sprintf:
d167 1
a167 2
    $hex = sprintf("%X", 3735928559); # upper case A-F
    $hex = sprintf("%x", 3735928559); # lower case a-f
d169 1
a169 1
Using unpack:
d173 1
a173 1
Using Bit::Vector:
d190 2
a191 1
    $dec = 033653337357; # note the leading 0!
d195 2
a196 1
    $dec = oct("33653337357");
d211 1
a211 1
Using Bit::Vector:
d222 1
a222 1
    $number = 0b10110110;
d224 1
a224 6
Using oct:

    my $input = "10110110";
    $decimal = oct( "0b$input" );

Using pack and ord:
d228 1
a228 1
Using pack and unpack for larger strings:
d243 1
a243 5
Using sprintf (perl 5.6+):

    $bin = sprintf("%b", 3735928559);

Using unpack:
d267 1
a267 1
C<3>).  Saying C<"11" & "3"> performs the "and" operation on strings
a337 3

	 BEGIN { srand() if $] < 5.004 }

d339 1
a339 1
call C<srand> more than once---you make your numbers less random, rather
d344 2
a345 2
F<random> article in the "Far More Than You Ever Wanted To Know"
collection in http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz , courtesy of
d373 1
a373 9
=head2 How do I find the day or week of the year?

The localtime function returns the day of the week.  Without an
argument localtime uses the current time.

    $day_of_year = (localtime)[7];

The POSIX module can also format a date as the day of the year or
week of the year.
d375 2
a376 3
	use POSIX qw/strftime/;
	my $day_of_year  = strftime "%j", localtime;
	my $week_of_year = strftime "%W", localtime;
d378 1
a378 13
To get the day of year for any date, use the Time::Local module to get
a time in epoch seconds for the argument to localtime.

	use POSIX qw/strftime/;
	use Time::Local;
	my $week_of_year = strftime "%W", 
		localtime( timelocal( 0, 0, 0, 18, 11, 1987 ) );

The Date::Calc module provides two functions for to calculate these.

	use Date::Calc;
	my $day_of_year  = Day_of_Year(  1987, 12, 18 );
	my $week_of_year = Week_of_Year( 1987, 12, 18 );
d384 1
a384 1
    sub get_century    {
d386 2
a387 2
    }
    sub get_millennium {
d389 1
a389 9
    }

You can also use the POSIX strftime() function which may be a bit
slower but is easier to read and maintain.

	use POSIX qw/strftime/;

	my $week_of_the_year = strftime "%W", localtime;
	my $day_of_the_year  = strftime "%j", localtime;
d391 5
a395 6
On some systems, the POSIX module's strftime() function has
been extended in a non-standard way to use a C<%C> format,
which they sometimes claim is the "century".  It isn't,
because on most such systems, this is only the first two
digits of the four-digit year, and thus cannot be used to
reliably determine the current century or millennium.
d441 2
a442 2
If you only need to find the date (and not the same time), you
can use the Date::Calc module.
d444 1
a444 1
	use Date::Calc qw(Today Add_Delta_Days);
d446 2
a447 1
	my @@date = Add_Delta_Days( Today(), -1 );
d449 4
a452 7
	print "@@date\n";

Most people try to use the time rather than the calendar to
figure out dates, but that assumes that your days are
twenty-four hours each.  For most people, there are two days
a year when they aren't: the switch to and from summer time
throws this off. Russ Allbery offers this solution.
d455 38
a492 38
		my $now  = defined $_[0] ? $_[0] : time;
		my $then = $now - 60 * 60 * 24;
		my $ndst = (localtime $now)[8] > 0;
		my $tdst = (localtime $then)[8] > 0;
		$then - ($tdst - $ndst) * 60 * 60;
		}

Should give you "this time yesterday" in seconds since epoch relative to
the first argument or the current time if no argument is given and
suitable for passing to localtime or whatever else you need to do with
it.  $ndst is whether we're currently in daylight savings time; $tdst is
whether the point 24 hours ago was in daylight savings time.  If $tdst
and $ndst are the same, a boundary wasn't crossed, and the correction
will subtract 0.  If $tdst is 1 and $ndst is 0, subtract an hour more
from yesterday's time since we gained an extra hour while going off
daylight savings time.  If $tdst is 0 and $ndst is 1, subtract a
negative hour (add an hour) to yesterday's time since we lost an hour.

All of this is because during those days when one switches off or onto
DST, a "day" isn't 24 hours long; it's either 23 or 25.

The explicit settings of $ndst and $tdst are necessary because localtime
only says it returns the system tm struct, and the system tm struct at
least on Solaris doesn't guarantee any particular positive value (like,
say, 1) for isdst, just a positive value.  And that value can
potentially be negative, if DST information isn't available (this sub
just treats those cases like no DST).

Note that between 2am and 3am on the day after the time zone switches
off daylight savings time, the exact hour of "yesterday" corresponding
to the current hour is not clearly defined.  Note also that if used
between 2am and 3am the day after the change to daylight savings time,
the result will be between 3am and 4am of the previous day; it's
arguable whether this is correct.

This sub does not attempt to deal with leap seconds (most things don't).


d560 8
d578 2
a579 3
nested patterns.  For balanced expressions using C<(>, C<{>, C<[>
or C<< < >> as delimiters, use the CPAN module Regexp::Common, or see
L<perlre/(??{ code })>.  For other cases, you'll have to write a parser.
d592 1
a592 1
    }
d647 1
a647 1
=head2 How can I access or change N characters of a string?
d649 2
a650 3
You can access the first characters of a string with substr().
To get the first character, for example, start at position 0
and grab the string of length 1.
d652 1
d654 2
a655 2
	$string = "Just another Perl Hacker";
    $first_char = substr( $string, 0, 1 );  #  'J'
d657 1
a657 2
To change part of a string, you can use the optional fourth
argument which is the replacement string.
d659 2
a660 1
    substr( $string, 13, 4, "Perl 5.8.0" );
d662 1
a662 3
You can also use substr() as an lvalue.

    substr( $string, 13, 4 ) =  "Perl 5.8.0";
d755 2
a756 17
Damian Conway's L<Text::Autoformat> module provides some smart
case transformations:

    use Text::Autoformat;
    my $x = "Dr. Strangelove or: How I Learned to Stop ".
      "Worrying and Love the Bomb";

    print $x, "\n";
    for my $style (qw( sentence title highlight ))
    {
        print autoformat($x, { case => $style }), "\n";
    }

=head2 How can I split a [character] delimited string except when inside [character]?

Several modules can handle this sort of pasing---Text::Balanced,
Text::CVS, Text::CVS_XS, and Text::ParseWords, among others.
d758 5
a762 4
Take the example case of trying to split a string that is
comma-separated into its different fields. You can't use C<split(/,/)>
because you shouldn't split if the comma is inside quotes.  For
example, take a data line like this:
d767 2
a768 2
problem.  Thankfully, we have Jeffrey Friedl, author of
I<Mastering Regular Expressions>, to handle these for us.  He
d781 2
a782 1
C<"like \"this\"">.
d813 1
a813 1
on several strings at once, or arrays, or even the
d816 1
a816 1
    # trim whitespace in the scalar, the array,
d825 3
d842 1
a842 2
	$padded = sprintf("%${pad_len}s", $text);
	$padded = sprintf("%*s", $pad_len, $text);  # same thing
d845 1
a845 2
	$padded = sprintf("%-${pad_len}s", $text);
	$padded = sprintf("%-*s", $pad_len, $text); # same thing
d847 2
a848 3
    # Left padding a number with 0 (no truncation):
	$padded = sprintf("%0${pad_len}d", $num);
	$padded = sprintf("%0*d", $pad_len, $num); # same thing
d871 1
a871 1
If you prefer thinking in terms of columns instead of widths,
d878 1
a878 1
    sub cut2fmt {
d883 1
a883 1
	    $template .= "A" . ($place - $lastpos) . " ";
d921 1
a921 1
    %user_defs = (
d935 1
a935 1
expansion is used to produce new strings.  If you already
d966 1
a966 1
Stringification also destroys arrays.
d972 1
a972 1
=head2 Why don't my E<lt>E<lt>HERE documents work?
d978 1
a978 1
=item There must be no space after the E<lt>E<lt> part.
d980 1
a980 1
=item There (probably) should be a semicolon at the end.
d982 1
a982 1
=item You can't (easily) have any space in front of the tag.
d986 1
a986 1
If you want to indent the text in the here document, you
d996 1
a996 1
If you want that indented also, you'll have to quote
d1091 1
a1091 1
The C<use warnings> pragma and the B<-w> flag will warn you about these
d1247 2
a1248 2
        cmpStr(\@@a, \@@b) == 0
	    ? "the same"
d1258 1
a1258 1
    $b{EXTRA} = \%a;
d1273 6
a1278 30
To find the first array element which satisfies a condition, you can
use the first() function in the List::Util module, which comes with
Perl 5.8.  This example finds the first element that contains "Perl".

	use List::Util qw(first);

	my $element = first { /Perl/ } @@array;

If you cannot use List::Util, you can make your own loop to do the
same thing.  Once you find the element, you stop the loop with last.

	my $found;
	foreach my $element ( @@array )
		{
		if( /Perl/ ) { $found = $element; last }
		}

If you want the array index, you can iterate through the indices
and check the array element at each index until you find one
that satisfies the condition.

	my( $found, $index ) = ( undef, -1 );
    for( $i = 0; $i < @@array; $i++ )
    	{
        if( $array[$i] =~ /Perl/ )
        	{
        	$found = $array[$i];
        	$index = $i;
        	last;
        	}
d1280 3
a1401 5
which can also be done with map() which is made to transform
one list into another:

	@@volumes = map {$_ ** 3 * (4/3) * 3.14159} @@radii;

d1408 1
a1408 1
	($orbit **= 3) *= (4/3) * 3.14159;
d1428 1
a1428 1
If you are calling it more than once (such as before each
d1433 20
a1452 39
Use the List::Permutor module on CPAN.  If the list is
actually an array, try the Algorithm::Permute module (also
on CPAN).  It's written in XS code and is very efficient.

	use Algorithm::Permute;
	my @@array = 'a'..'d';
	my $p_iterator = Algorithm::Permute->new ( \@@array );
	while (my @@perm = $p_iterator->next) {
	   print "next permutation: (@@perm)\n";
	}

For even faster execution, you could do:

   use Algorithm::Permute;
   my @@array = 'a'..'d';
   Algorithm::Permute::permute {
      print "next permutation: (@@array)\n";
   } @@array;

Here's a little program that generates all permutations of
all the words on each line of input. The algorithm embodied
in the permute() function is discussed in Volume 4 (still
unpublished) of Knuth's I<The Art of Computer Programming>
and will work on any list:

	#!/usr/bin/perl -n
	# Fischer-Kause ordered permutation generator

	sub permute (&@@) {
		my $code = shift;
		my @@idx = 0..$#_;
		while ( $code->(@@_[@@idx]) ) {
			my $p = $#idx;
			--$p while $idx[$p-1] > $idx[$p];
			my $q = $p or return;
			push @@idx, reverse splice @@idx, $p;
			++$q while $idx[$p-1] > $idx[$q];
			@@idx[$p-1,$q]=@@idx[$q,$p-1];
		}
d1454 1
d1456 5
a1460 1
	permute {print"@@_\n"} split;
d1503 2
a1504 2
See the F<sort> article in the "Far More Than You Ever Wanted
To Know" collection in http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz for
d1567 1
a1567 1
and "big int" math.
d1573 1
a1573 1
    print "Ilya's string \\xff\\x0f\\xef\\xfe represents the number ",
d1593 1
a1593 1
    sub set_vec {
d1610 1
a1610 1
    }
d1677 2
a1678 2
The keys() function also resets the iterator, which means that you may
see strange results if you use this between uses of other hash operators
d1844 2
a1845 2
    tie my %myhash, 'Tie::IxHash';
    for (my $i=0; $i<20; $i++) {
d1848 1
a1848 1
    my @@keys = keys %myhash;
d1904 3
a1906 1
L<perlfunc/"binmode"> or L<perlopentut>.
d1927 3
a1929 9
There are also some commonly used modules for the task.
L<Scalar::Util> (distributed with 5.8) provides access to perl's
internal function C<looks_like_number> for determining
whether a variable looks like a number.  L<Data::Types>
exports functions that validate data types using both the
above and other regular expressions. Thirdly, there is
C<Regexp::Common> which has regular expressions to match
various types of numbers. Those three modules are available
from the CPAN.
d1931 1
a1931 1
If you're on a POSIX system, Perl supports the C<POSIX::strtod>
d1949 2
a1950 2
        }
    }
d1952 1
a1952 1
    sub is_numeric { defined getnum($_[0]) }
d1954 1
a1954 1
Or you could check out the L<String::Scanf> module on the CPAN
d1967 1
a1967 1
    use Storable;
d1970 1
a1970 1
    # later on...
d1977 2
a1978 3
for printing out data structures.  The Storable module on CPAN (or the
5.8 release of Perl), provides a function called C<dclone> that recursively
copies its argument.
d1980 1
a1980 1
    use Storable qw(dclone);
@


1.1.1.6
log
@perl 5.8.3 from CPAN
@
text
@d3 1
a3 1
perlfaq4 - Data Manipulation ($Revision: 1.54 $, $Date: 2003/11/30 00:50:08 $)
d365 3
a367 14
C<rand($x)> returns a number such that
C<< 0 <= rand($x) < $x >>. Thus what you want to have perl
figure out is a random number in the range from 0 to the
difference between your I<X> and I<Y>.

That is, to get a number between 10 and 15, inclusive, you
want a random number between 0 and 5 that you can then add
to 10.

    my $number = 10 + int rand( 15-10+1 );

Hence you derive the following simple function to abstract
that. It selects a random integer between the two given
integers (inclusive), For example: C<random_int_in(50,120)>.
d418 8
d1492 4
d1499 3
a1501 2
Or, simply:
    my $element = $array[ rand @@array ];
@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@d3 1
a3 1
perlfaq4 - Data Manipulation ($Revision: 1.7 $, $Date: 2004/04/07 21:33:08 $)
@


1.1.1.8
log
@perl 5.8.6 from CPAN
@
text
@d3 1
a3 1
perlfaq4 - Data Manipulation ($Revision: 1.56 $, $Date: 2004/11/03 22:47:56 $)
d562 1
a562 1
break Y2K, people do.''  See http://www.perl.org/about/y2k.html for
d1718 1
a1718 1
(contributed by brian d foy)
d1720 11
a1730 7
The easy answer is "Don't do that!"

If you iterate through the hash with each(), you can delete the key
most recently returned without worrying about it.  If you delete or add
other keys, the iterator may skip or double up on them since perl
may rearrange the hash table.  See the
entry for C<each()> in L<perlfunc>.
@


1.1.1.9
log
@perl 5.8.8 import
@
text
@d3 1
a3 1
perlfaq4 - Data Manipulation ($Revision: 1.73 $, $Date: 2005/12/31 00:54:37 $)
d352 1
a352 1
Tom Phoenix, talks more about this.  John von Neumann said, "Anyone
d354 1
a354 1
course, living in a state of sin."
d361 1
a361 1
"Numerical Recipes in C" at http://www.nr.com/ .
d392 1
a392 1
The localtime function returns the day of the year.  Without an
d395 1
a395 1
	$day_of_year = (localtime)[7];
d409 1
a409 1
	my $week_of_year = strftime "%W",
d412 1
a412 1
The Date::Calc module provides two functions to calculate these.
a424 1

d438 9
a446 6
(contributed by brian d foy)

You could just store all your dates as a number and then subtract. Life
isn't always that simple though. If you want to work with formatted
dates, the Date::Manip, Date::Calc, or DateTime modules can help you.

d457 2
a458 9
(contributed by brian d foy and Dave Cross)

You can use the Time::JulianDay module available on CPAN.  Ensure that
you really want to find a Julian day, though, as many people have
different ideas about Julian days.  See
http://www.hermetic.ch/cal_stud/jdn.htm for instance.

You can also try the DateTime module, which can convert a date/time
to a Julian Day.
d460 17
a476 13
  $ perl -MDateTime -le'print DateTime->today->jd'
  2453401.5

Or the modified Julian Day

  $ perl -MDateTime -le'print DateTime->today->mjd'
  53401

Or even the day of the year (which is what some people think of as a
Julian day)

  $ perl -MDateTime -le'print DateTime->today->doy'
  31
d480 2
a481 1
(contributed by brian d foy)
d483 1
a483 2
Use one of the Date modules. The C<DateTime> module makes it simple, and
give you the same time of day, only the day before.
d485 1
a485 1
	use DateTime;
d487 1
a487 1
	my $yesterday = DateTime->now->subtract( days => 1 );
d489 13
a501 1
	print "Yesterday was $yesterday\n";
d503 27
a529 2
You can also use the C<Date::Calc> module using its Today_and_Now
function.
d531 1
a531 1
	use Date::Calc qw( Today_and_Now Add_Delta_DHMS );
a532 1
	my @@date_time = Add_Delta_DHMS( Today_and_Now(), -1, 0, 0, 0 );
a533 6
	print "@@date\n";

Most people try to use the time rather than the calendar to figure out
dates, but that assumes that days are twenty-four hours each.  For
most people, there are two days a year when they aren't: the switch to
and from summer time throws this off. Let the modules do the work.
d561 2
a562 2
not the language.  At the risk of inflaming the NRA: "Perl doesn't
break Y2K, people do."  See http://www.perl.org/about/y2k.html for
d569 3
a571 10
(contributed by brian d foy)

There are many ways to ensure that values are what you expect or
want to accept. Besides the specific examples that we cover in the
perlfaq, you can also look at the modules with "Assert" and "Validate"
in their names, along with other modules such as C<Regexp::Common>.

Some modules have validation for particular types of input, such
as C<Business::ISBN>, C<Business::CreditCard>, C<Email::Valid>,
and C<Data::Validate::IP>.
d575 1
a575 1
It depends just what you mean by "escape".  URL escapes are dealt
d585 3
a587 1
(contributed by brian d foy)
d589 1
a589 17
You can use the substitution operator to find pairs of characters (or
runs of characters) and replace them with a single instance. In this
substitution, we find a character in C<(.)>. The memory parentheses
store the matched character in the back-reference C<\1> and we use
that to require that the same thing immediately follow it. We replace
that part of the string with the character in C<$1>.

    s/(.)\1/$1/g;

We can also use the transliteration operator, C<tr///>. In this
example, the search list side of our C<tr///> contains nothing, but
the C<c> option complements that so it contains everything. The
replacement list also contains nothing, so the transliteration is
almost a no-op since it won't do any replacements (or more exactly,
replace the character with itself). However, the C<s> option squashes
duplicated and consecutive characters in the string so a character
does not show up next to itself
d591 1
a591 2
	my $str = 'Haarlem';   # in the Netherlands
    $str =~ tr///cs;       # Now Harlem, like in New York
d595 3
a597 7
(contributed by brian d foy)

This is documented in L<perlref>, and although it's not the easiest
thing to read, it does work. In each of these examples, we call the
function inside the braces used to dereference a reference. If we
have a more than one return value, we can construct and dereference an
anonymous array. In this case, we call the function in list context.
d599 1
a599 1
	print "The time values are @@{ [localtime] }.\n";
d601 2
a602 28
If we want to call the function in scalar context, we have to do a bit
more work. We can really have any code we like inside the braces, so
we simply have to end with the scalar reference, although how you do
that is up to you, and you can use code inside the braces.

	print "The time is ${\(scalar localtime)}.\n"

	print "The time is ${ my $x = localtime; \$x }.\n";

If your function already returns a reference, you don't need to create
the reference yourself.

	sub timestamp { my $t = localtime; \$t }

	print "The time is ${ timestamp() }.\n";

The C<Interpolation> module can also do a lot of magic for you. You can
specify a variable name, in this case C<E>, to set up a tied hash that
does the interpolation for you. It has several other methods to do this
as well.

	use Interpolation E => 'eval';
	print "The time values are $E{localtime()}.\n";

In most cases, it is probably easier to simply use string concatenation,
which also forces scalar context.

	print "The time is " . localtime . ".\n";
d611 3
a613 4
nested patterns.  For balanced expressions using C<(>, C<{>, C<[> or
C<< < >> as delimiters, use the CPAN module Regexp::Common, or see
L<perlre/(??{ code })>.  For other cases, you'll have to write a
parser.
d618 2
a619 2
and the byacc program.   Starting from perl 5.8 the Text::Balanced is
part of the standard distribution.
d807 1
a807 1
Text::CSV, Text::CSV_XS, and Text::ParseWords, among others.
d843 1
a843 1
(contributed by brian d foy)
d845 1
a845 3
A substitution can do this for you. For a single line, you want to
replace all the leading or trailing whitespace with nothing. You
can do that with a pair of substitutions.
d847 2
a848 2
	s/^\s+//;
	s/\s+$//;
d850 2
a851 15
You can also write that as a single substitution, although it turns
out the combined statement is slower than the separate ones. That
might not matter to you, though.

	s/^\s+|\s+$//g;

In this regular expression, the alternation matches either at the
beginning or the end of the string since the anchors have a lower
precedence than the alternation. With the C</g> flag, the substitution
makes all possible matches, so it gets both. Remember, the trailing
newline matches the C<\s+>, and  the C<$> anchor can match to the
physical end of the string, so the newline disappears too. Just add
the newline to the output, which has the added benefit of preserving
"blank" (consisting entirely of whitespace) lines which the C<^\s+>
would remove all by itself.
d853 1
a853 5
	while( <> )
		{
		s/^\s+|\s+$//g;
		print "$_\n";
		}
d855 4
a858 13
For a multi-line string, you can apply the regular expression
to each logical line in the string by adding the C</m> flag (for
"multi-line"). With the C</m> flag, the C<$> matches I<before> an
embedded newline, so it doesn't remove it. It still removes the
newline at the end of the string.

    $string =~ s/^\s+|\s+$//gm;

Remember that lines consisting entirely of whitespace will disappear,
since the first part of the alternation can match the entire string
and replace it with nothing. If need to keep embedded blank lines,
you have to do a little more work. Instead of matching any whitespace
(since that includes a newline), just match the other whitespace.
d860 11
a870 1
	$string =~ s/^[\t\f ]+|[\t\f ]+$//mg;
d941 8
a948 5
(contributed by brian d foy)

You can use the Text::Soundex module. If you want to do fuzzy or close
matching, you might also try the String::Approx, and Text::Metaphone,
and Text::DoubleMetaphone modules.
d952 1
a952 2
Let's assume that you have a string that contains placeholder
variables.
d956 2
a957 5
You can use a substitution with a double evaluation.  The
first /e turns C<$1> into C<$foo>, and the second /e turns
C<$foo> into its value.  You may want to wrap this in an
C<eval>: if you try to get the value of an undeclared variable
while running under C<use strict>, you get a fatal error.
d959 7
a965 2
    eval { $text =~ s/(\$\w+)/$1/eeg };
    die if $@@;
d976 3
d1145 34
a1178 1
(contributed by brian d foy)
d1180 3
a1182 2
Use a hash. When you think the words "unique" or "duplicated", think
"hash keys".
d1184 1
a1184 20
If you don't care about the order of the elements, you could just
create the hash then extract the keys. It's not important how you
create that hash: just that you use C<keys> to get the unique
elements.

   my %hash   = map { $_, 1 } @@array;
   # or a hash slice: @@hash{ @@array } = ();
   # or a foreach: $hash{$_} = 1 foreach ( @@array );

   my @@unique = keys %hash;

You can also go through each element and skip the ones you've seen
before. Use a hash to keep track. The first time the loop sees an
element, that element has no key in C<%Seen>. The C<next> statement
creates the key and immediately uses its value, which is C<undef>, so
the loop continues to the C<push> and increments the value for that
key. The next time the loop sees that same element, its key exists in
the hash I<and> the value for that key is true (since it's not 0 or
undef), so the next skips that iteration and the loop goes to the next
element.
d1186 1
a1186 2
	my @@unique = ();
	my %seen   = ();
d1188 3
a1190 5
	foreach my $elem ( @@array )
		{
		next if $seen{ $elem }++;
		push @@unique, $elem;
		}
d1192 1
a1192 2
You can write this more briefly using a grep, which does the
same thing.
d1194 1
a1194 2
   my %seen = ();
   my @@unique = grep { ! $seen{ $_ }++ } @@array;
a1197 2
(portions of this answer contributed by Anno Siegel)

d1233 1
a1233 8
These methods guarantee fast individual tests but require a re-organization
of the original list or array.  They only pay off if you have to test
multiple values against the same array.

If you are testing only once, the standard module List::Util exports
the function C<first> for this purpose.  It works by stopping once it
finds the element. It's written in C for speed, and its Perl equivalant
looks like this subroutine:
d1235 1
a1235 7
	sub first (&@@) {
		my $code = shift;
		foreach (@@_) {
			return $_ if &{$code}();
		}
		undef;
	}
d1237 1
a1237 4
If speed is of little concern, the common idiom uses grep in scalar context
(which returns the number of items that passed its condition) to traverse the
entire list. This does have the benefit of telling you how many matches it
found, though.
d1239 1
a1239 1
	my $is_there = grep $_ eq $whatever, @@array;
d1241 4
a1244 2
If you want to actually extract the matching elements, simply use grep in
list context.
d1246 8
a1253 1
	my @@matches = grep $_ eq $whatever, @@array;
d1334 1
a1334 1
	foreach ( @@array )
d1336 1
a1336 1
		if( /Perl/ ) { $found = $_; last }
d1344 9
a1352 9
	for( $i = 0; $i < @@array; $i++ )
		{
		if( $array[$i] =~ /Perl/ )
			{
			$found = $array[$i];
			$index = $i;
			last;
			}
		}
d1425 1
a1425 1
        while (--$i) {
d1461 2
a1462 2
		s/foo/bar/;	# change that word
		tr/XZ/ZX/;	# swap those letters
d1468 2
a1469 2
		$_ **= 3;
		$_ *= (4/3) * 3.14159;  # this will be constant folded
d1483 1
a1483 1
		($orbit **= 3) *= (4/3) * 3.14159;
d1763 21
a1783 44
(contributed by brian d foy)

To sort a hash, start with the keys. In this example, we give the list of
keys to the sort function which then compares them ASCIIbetically (which
might be affected by your locale settings). The output list has the keys
in ASCIIbetical order. Once we have the keys, we can go through them to
create a report which lists the keys in ASCIIbetical order.

	my @@keys = sort { $a cmp $b } keys %hash;

	foreach my $key ( @@keys )
		{
		printf "%-20s %6d\n", $key, $hash{$value};
		}

We could get more fancy in the C<sort()> block though. Instead of
comparing the keys, we can compute a value with them and use that
value as the comparison.

For instance, to make our report order case-insensitive, we use
the C<\L> sequence in a double-quoted string to make everything
lowercase. The C<sort()> block then compares the lowercased
values to determine in which order to put the keys.

	my @@keys = sort { "\L$a" cmp "\L$b" } keys %hash;

Note: if the computation is expensive or the hash has many elements,
you may want to look at the Schwartzian Transform to cache the
computation results.

If we want to sort by the hash value instead, we use the hash key
to look it up. We still get out a list of keys, but this time they
are ordered by their value.

	my @@keys = sort { $hash{$a} <=> $hash{$b} } keys %hash;

From there we can get more complex. If the hash values are the same,
we can provide a secondary sort on the hash key.

	my @@keys = sort {
		$hash{$a} <=> $hash{$b}
			or
		"\L$a" cmp "\L$b"
		} keys %hash;
d1968 2
a1969 12
(contributed by brian d foy)

Hash keys are strings, so you can't really use a reference as the key.
When you try to do that, perl turns the reference into its stringified
form (for instance, C<HASH(0xDEADBEEF)>). From there you can't get back
the reference from the stringified form, at least without doing some
extra work on your own. Also remember that hash keys must be unique, but
two different variables can store the same reference (and those variables
can change later).

The Tie::RefHash module, which is distributed with perl, might be what
you want. It handles that extra work.
d2020 1
a2020 1
if you just want to say, "Is this a float?"
d2091 2
a2092 2
Copyright (c) 1997-2006 Tom Christiansen, Nathan Torkington, and
other authors as noted. All rights reserved.
@


1.1.1.10
log
@import perl 5.10.0 from CPAN
@
text
@d3 1
a3 1
perlfaq4 - Data Manipulation ($Revision: 10394 $)
d14 12
a25 12
Internally, your computer represents floating-point numbers in binary.
Digital (as in powers of two) computers cannot store all numbers
exactly.  Some real numbers lose precision in the process.  This is a
problem with how computers store numbers and affects all computer
languages, not just Perl.

L<perlnumber> shows the gory details of number representations and
conversions.

To limit the number of decimal places in your numbers, you can use the
printf or sprintf function.  See the L<"Floating Point
Arithmetic"|perlop> for more details.
d33 1
a33 1
Your C<int()> is most probably working just fine.  It's the numbers that
d36 1
a36 1
First, see the answer to "Why am I getting long decimals
d42 1
a42 1
	print int(0.6/0.2-2), "\n";
d53 1
a53 1
leading C<0> and hexadecimal literals must start with a leading C<0x>.
d55 5
a59 5
conversion takes place.  You must explicitly use C<oct()> or C<hex()> if you
want the values converted to decimal.  C<oct()> interprets hexadecimal (C<0x350>),
octal (C<0350> or even without the leading C<0>, like C<377>) and binary
(C<0b1010>) numbers, while C<hex()> only converts hexadecimal ones, with
or without a leading C<0x>, such as C<0x255>, C<3A>, C<ff>, or C<deadbeef>.
d61 1
a61 1
<%o> or C<%O> C<sprintf()> formats.
d63 3
a65 3
This problem shows up most often when people try using C<chmod()>,
C<mkdir()>, C<umask()>, or C<sysopen()>, which by widespread tradition
typically take permissions in octal.
d67 2
a68 2
	chmod(644,  $file);   # WRONG
	chmod(0644, $file);   # right
d71 1
a71 1
C<644>, rather than the intended octal literal C<0644>.  The problem can
d74 1
a74 1
	printf("%#o",644);   # prints 01204
d79 1
a79 1
with the following digits restricted to the set C<0..7>.
d83 13
a95 13
Remember that C<int()> merely truncates toward 0.  For rounding to a
certain number of digits, C<sprintf()> or C<printf()> is usually the
easiest route.

	printf("%.3f", 3.1415926535);   # prints 3.142

The C<POSIX> module (part of the standard Perl distribution)
implements C<ceil()>, C<floor()>, and a number of other mathematical
and trigonometric functions.

	use POSIX;
	$ceil   = ceil(3.5);   # 4
	$floor  = floor(3.5);  # 3
d97 2
a98 2
In 5.000 to 5.003 perls, trigonometry was done in the C<Math::Complex>
module.  With 5.004, the C<Math::Trig> module (part of the standard Perl
d100 1
a100 1
uses the C<Math::Complex> module and some functions can break out from
d113 1
a113 1
	for ($i = 0; $i < 1.01; $i += 0.05) { printf "%.1f ",$i}
d115 2
a116 2
	0.0 0.1 0.1 0.2 0.2 0.2 0.3 0.3 0.4 0.4 0.5 0.5 0.6 0.7 0.7
	0.8 0.8 0.9 0.9 1.0 1.0
d118 4
a121 4
Don't blame Perl.  It's the same as in C.  IEEE says we have to do
this. Perl numbers whose absolute values are integers under 2**31 (on
32 bit machines) will work pretty much like mathematical integers.
Other numbers are not guaranteed.
d125 10
a134 10
As always with Perl there is more than one way to do it.  Below are a
few examples of approaches to making common conversions between number
representations.  This is intended to be representational rather than
exhaustive.

Some of the examples later in L<perlfaq4> use the C<Bit::Vector>
module from CPAN. The reason you might choose C<Bit::Vector> over the
perl built in functions is that it works with numbers of ANY size,
that it is optimized for speed on some operations, and for at least
some programmers the notation might be familiar.
d140 1
a140 1
Using perl's built in conversion of C<0x> notation:
d142 1
a142 1
	$dec = 0xDEADBEEF;
d144 1
a144 1
Using the C<hex> function:
d146 1
a146 1
	$dec = hex("DEADBEEF");
d148 1
a148 1
Using C<pack>:
d150 1
a150 1
	$dec = unpack("N", pack("H8", substr("0" x 8 . "DEADBEEF", -8)));
d152 1
a152 1
Using the CPAN module C<Bit::Vector>:
d154 3
a156 3
	use Bit::Vector;
	$vec = Bit::Vector->new_Hex(32, "DEADBEEF");
	$dec = $vec->to_Dec();
d160 1
a160 1
Using C<sprintf>:
d162 2
a163 2
	$hex = sprintf("%X", 3735928559); # upper case A-F
	$hex = sprintf("%x", 3735928559); # lower case a-f
d165 1
a165 1
Using C<unpack>:
d167 1
a167 1
	$hex = unpack("H*", pack("N", 3735928559));
d169 1
a169 1
Using C<Bit::Vector>:
d171 3
a173 3
	use Bit::Vector;
	$vec = Bit::Vector->new_Dec(32, -559038737);
	$hex = $vec->to_Hex();
d175 1
a175 1
And C<Bit::Vector> supports odd bit counts:
d177 4
a180 4
	use Bit::Vector;
	$vec = Bit::Vector->new_Dec(33, 3735928559);
	$vec->Resize(32); # suppress leading 0 if unwanted
	$hex = $vec->to_Hex();
d186 1
a186 1
	$dec = 033653337357; # note the leading 0!
d188 1
a188 1
Using the C<oct> function:
d190 1
a190 1
	$dec = oct("33653337357");
d192 1
a192 1
Using C<Bit::Vector>:
d194 4
a197 4
	use Bit::Vector;
	$vec = Bit::Vector->new(32);
	$vec->Chunk_List_Store(3, split(//, reverse "33653337357"));
	$dec = $vec->to_Dec();
d201 1
a201 1
Using C<sprintf>:
d203 1
a203 1
	$oct = sprintf("%o", 3735928559);
d205 1
a205 1
Using C<Bit::Vector>:
d207 3
a209 3
	use Bit::Vector;
	$vec = Bit::Vector->new_Dec(32, -559038737);
	$oct = reverse join('', $vec->Chunk_List_Read(3));
d214 1
a214 1
the C<0b> notation:
d216 1
a216 1
	$number = 0b10110110;
d218 1
a218 1
Using C<oct>:
d220 2
a221 2
	my $input = "10110110";
	$decimal = oct( "0b$input" );
d223 1
a223 1
Using C<pack> and C<ord>:
d225 1
a225 1
	$decimal = ord(pack('B8', '10110110'));
d227 1
a227 1
Using C<pack> and C<unpack> for larger strings:
d229 1
a229 1
	$int = unpack("N", pack("B32",
d231 1
a231 1
	$dec = sprintf("%d", $int);
d233 1
a233 1
	# substr() is used to left pad a 32 character string with zeros.
d235 1
a235 1
Using C<Bit::Vector>:
d237 2
a238 2
	$vec = Bit::Vector->new_Bin(32, "11011110101011011011111011101111");
	$dec = $vec->to_Dec();
d242 1
a242 1
Using C<sprintf> (perl 5.6+):
d244 1
a244 1
	$bin = sprintf("%b", 3735928559);
d246 1
a246 1
Using C<unpack>:
d248 1
a248 1
	$bin = unpack("B*", pack("N", 3735928559));
d250 1
a250 1
Using C<Bit::Vector>:
d252 3
a254 3
	use Bit::Vector;
	$vec = Bit::Vector->new_Dec(32, -559038737);
	$bin = $vec->to_Bin();
d277 3
a279 3
	if ("\020\020" & "\101\101") {
		# ...
		}
d284 3
a286 3
	if ( ("\020\020" & "\101\101") !~ /[^\000]/) {
		# ...
		}
d298 1
a298 1
	@@results = map { my_func($_) } @@array;
d302 1
a302 1
	@@triple = map { 3 * $_ } @@single;
d307 3
a309 3
	foreach $iterator (@@array) {
		some_func($iterator);
		}
d313 1
a313 1
	@@results = map { some_func($_) } (5 .. 25);
d319 4
a322 4
	@@results = ();
	for ($i=5; $i < 500_005; $i++) {
		push(@@results, some_func($i));
		}
d327 3
a329 3
	for my $i (5 .. 500_005) {
		push(@@results, some_func($i));
		}
d345 2
a346 2
call C<srand> more than once--you make your numbers less random,
rather than more.
d351 2
a352 2
collection in http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz , courtesy
of Tom Phoenix, talks more about this.  John von Neumann said, "Anyone
d357 1
a357 1
provides, you should also check out the C<Math::TrulyRandom> module from
d365 8
a372 7
To get a random number between two values, you can use the C<rand()>
builtin to get a random number between 0 and 1. From there, you shift
that into the range that you want.

C<rand($x)> returns a number such that C<< 0 <= rand($x) < $x >>. Thus
what you want to have perl figure out is a random number in the range
from 0 to the difference between your I<X> and I<Y>.
d374 1
a374 4
That is, to get a number between 10 and 15, inclusive, you want a
random number between 0 and 5 that you can then add to 10.

	my $number = 10 + int rand( 15-10+1 );
d378 1
a378 1
integers (inclusive), For example: C<random_int_between(50,120)>.
d380 7
a386 7
	sub random_int_between {
		my($min, $max) = @@_;
		# Assumes that the two arguments are integers themselves!
		return $min if $min == $max;
		($min, $max) = ($max, $min)  if  $min > $max;
		return $min + int rand(1 + $max - $min);
		}
d397 1
a397 1
The C<POSIX> module can also format a date as the day of the year or
d404 1
a404 1
To get the day of year for any date, use C<POSIX>'s C<mktime> to get
d407 2
a408 1
	use POSIX qw/mktime strftime/;
d410 1
a410 1
		localtime( mktime( 0, 0, 0, 18, 11, 87 ) );
d412 1
a412 1
The C<Date::Calc> module provides two functions to calculate these.
d422 3
a424 3
	sub get_century    {
		return int((((localtime(shift || time))[5] + 1999))/100);
		}
d426 3
a428 3
	sub get_millennium {
		return 1+int((((localtime(shift || time))[5] + 1899))/1000);
		}
d430 6
a435 6
On some systems, the C<POSIX> module's C<strftime()> function has been
extended in a non-standard way to use a C<%C> format, which they
sometimes claim is the "century". It isn't, because on most such
systems, this is only the first two digits of the four-digit year, and
thus cannot be used to reliably determine the current century or
millennium.
d441 4
a444 4
You could just store all your dates as a number and then subtract.
Life isn't always that simple though. If you want to work with
formatted dates, the C<Date::Manip>, C<Date::Calc>, or C<DateTime>
modules can help you.
d450 2
a451 2
C<Time::Local> module.  Otherwise, you should look into the C<Date::Calc>
and C<Date::Manip> modules from CPAN.
d457 2
a458 2
You can use the C<Time::JulianDay> module available on CPAN.  Ensure
that you really want to find a Julian day, though, as many people have
d462 1
a462 1
You can also try the C<DateTime> module, which can convert a date/time
d465 2
a466 2
	$ perl -MDateTime -le'print DateTime->today->jd'
	2453401.5
d470 2
a471 2
	$ perl -MDateTime -le'print DateTime->today->mjd'
	53401
d476 2
a477 2
	$ perl -MDateTime -le'print DateTime->today->doy'
	31
d492 1
a492 1
You can also use the C<Date::Calc> module using its C<Today_and_Now>
d499 1
a499 1
	print "@@date_time\n";
d506 1
a506 1
=head2 Does Perl have a Year 2000 problem? Is Perl Y2K compliant?
d509 1
a509 1
Y2K compliant (whatever that means). The programmers you've hired to
d557 1
a557 1
	s/\\(.)/$1/g;
d572 1
a572 1
	s/(.)\1/$1/g;
d584 1
a584 1
	$str =~ tr///cs;       # Now Harlem, like in New York
d593 1
a593 1
have more than one return value, we can construct and dereference an
d601 1
a601 3
that is up to you, and you can use code inside the braces. Note that
the use of parens creates a list context, so we need C<scalar> to
force the scalar context on the function:
d625 1
a625 1
	print "The time is " . localtime() . ".\n";
d633 1
a633 1
C</alpha(.*?)omega/> would be needed. But none of these deals with
d641 3
a643 3
the CPAN modules C<Parse::RecDescent>, C<Parse::Yapp>, and
C<Text::Balanced>; and the C<byacc> program. Starting from perl 5.8
the C<Text::Balanced> is part of the standard distribution.
d648 3
a650 3
	while (s/BEGIN((?:(?!BEGIN)(?!END).)*)END//gs) {
		# do something with $1
		}
d657 9
a665 9
	# $_ contains the string to parse
	# BEGIN and END are the opening and closing markers for the
	# nested text.

	@@( = ('(','');
	@@) = (')','');
	($re=$_)=~s/((BEGIN)|(END)|.)/$)[!$3]\Q$1\E$([!$2]/gs;
	@@$ = (eval{/$re/},$@@!~/unmatched/i);
	print join("\n",@@$[0..$#$]) if( $$[-1] );
d669 1
a669 1
Use C<reverse()> in scalar context, as documented in
d672 1
a672 1
	$reversed = reverse $string;
d678 1
a678 1
	1 while $string =~ s/\t+/' ' x (length($&) * 8 - length($`) % 8)/e;
d680 1
a680 1
Or you can just use the C<Text::Tabs> module (part of the standard Perl
d683 2
a684 2
	use Text::Tabs;
	@@expanded_lines = expand(@@lines_with_tabs);
d688 1
a688 1
Use C<Text::Wrap> (part of the standard Perl distribution):
d690 2
a691 2
	use Text::Wrap;
	print wrap("\t", '  ', @@paragraphs);
d693 2
a694 2
The paragraphs you give to C<Text::Wrap> should not contain embedded
newlines.  C<Text::Wrap> doesn't justify the lines (flush-right).
d696 2
a697 2
Or use the CPAN module C<Text::Autoformat>.  Formatting files can be
easily done by making a shell alias, like so:
d699 2
a700 2
	alias fmt="perl -i -MText::Autoformat -n0777 \
		-e 'print autoformat $_, {all=>1}' $*"
d702 1
a702 1
See the documentation for C<Text::Autoformat> to appreciate its many
d713 1
a713 1
	$first_char = substr( $string, 0, 1 );  #  'J'
d718 1
a718 1
	substr( $string, 13, 4, "Perl 5.8.0" );
d722 1
a722 1
	substr( $string, 13, 4 ) =  "Perl 5.8.0";
d731 6
a736 6
	$count = 0;
	s{((whom?)ever)}{
	++$count == 5       # is it the 5th?
	    ? "${2}soever"  # yes, swap
	    : $1            # renege and leave it there
		}ige;
d741 8
a748 8
	$WANT = 3;
	$count = 0;
	$_ = "One fish two fish red fish blue fish";
	while (/(\w+)\s+fish\b/gi) {
		if (++$count == $WANT) {
			print "The third fish is a $1 one.\n";
			}
		}
d753 1
a753 1
	/(?:\w+\s+fish\s+){2}(\w+)\s+fish/i;
d761 3
a763 3
	$string = "ThisXlineXhasXsomeXx'sXinXit";
	$count = ($string =~ tr/X//);
	print "There are $count X characters in the string";
d771 3
a773 3
	$string = "-9 55 48 -2 23 -76 4 14 -44";
	while ($string =~ /-\d+/g) { $count++ }
	print "There are $count negative numbers in the string";
d784 1
a784 1
	$line =~ s/\b(\w)/\U$1/g;
d790 7
a796 8
	$string =~ s/ (
				 (^\w)    #at the beginning of the line
				   |      # or
				 (\s\w)   #preceded by whitespace
				   )
				/\U$1/xg;

	$string =~ s/([\w']+)/\u\L$1/g;
d800 1
a800 1
	$line = uc($line);
d804 1
a804 1
	$line =~ s/(\w+)/\u\L$1/g;
d818 9
a826 8
	use Text::Autoformat;
	my $x = "Dr. Strangelove or: How I Learned to Stop ".
	  "Worrying and Love the Bomb";

	print $x, "\n";
	for my $style (qw( sentence title highlight )) {
		print autoformat($x, { case => $style }), "\n";
		}
d830 2
a831 2
Several modules can handle this sort of parsing--C<Text::Balanced>,
C<Text::CSV>, C<Text::CSV_XS>, and C<Text::ParseWords>, among others.
d838 1
a838 1
	SAR001,"","Cimetrix, Inc","Bob Smith","CAM",N,8,1,0,7,"Error, Core Dumped"
d843 1
a843 1
suggests (assuming your string is contained in C<$text>):
d845 7
a851 7
	 @@new = ();
	 push(@@new, $+) while $text =~ m{
		 "([^\"\\]*(?:\\.[^\"\\]*)*)",?  # groups the phrase inside the quotes
		| ([^,]+),?
		| ,
		}gx;
	 push(@@new, undef) if substr($text,-1,1) eq ',';
d857 5
a861 2
Alternatively, the C<Text::ParseWords> module (part of the standard
Perl distribution) lets you say:
d863 1
a863 2
	use Text::ParseWords;
	@@new = quotewords(",", 0, $text);
d904 1
a904 1
	$string =~ s/^\s+|\s+$//gm;
d929 1
a929 1
	# Left padding a string with blanks (no truncation):
d933 1
a933 1
	# Right padding a string with blanks (no truncation):
d937 1
a937 1
	# Left padding a number with 0 (no truncation):
d941 2
a942 2
	# Right padding a string with blanks using pack (will truncate):
	$padded = pack("A$pad_len",$text);
d951 2
a952 2
	$padded = $pad_char x ( $pad_len - length( $text ) ) . $text;
	$padded = $text . $pad_char x ( $pad_len - length( $text ) );
d956 2
a957 2
	substr( $text, 0, 0 ) = $pad_char x ( $pad_len - length( $text ) );
	$text .= $pad_char x ( $pad_len - length( $text ) );
d961 19
a979 33
(contributed by brian d foy)

If you know where the columns that contain the data, you can
use C<substr> to extract a single column.

	my $column = substr( $line, $start_column, $length );

You can use C<split> if the columns are separated by whitespace or
some other delimiter, as long as whitespace or the delimiter cannot
appear as part of the data.

	my $line    = ' fred barney   betty   ';
	my @@columns = split /\s+/, $line;
		# ( '', 'fred', 'barney', 'betty' );

	my $line    = 'fred||barney||betty';
	my @@columns = split /\|/, $line;
		# ( 'fred', '', 'barney', '', 'betty' );

If you want to work with comma-separated values, don't do this since
that format is a bit more complicated. Use one of the modules that
handle that fornat, such as C<Text::CSV>, C<Text::CSV_XS>, or
C<Text::CSV_PP>.

If you want to break apart an entire line of fixed columns, you can use
C<unpack> with the A (ASCII) format. by using a number after the format
specifier, you can denote the column width. See the C<pack> and C<unpack>
entries in L<perlfunc> for more details.

	my @@fields = unpack( $line, "A8 A8 A8 A16 A4" );

Note that spaces in the format argument to C<unpack> do not denote literal
spaces. If you have space separated data, you may want C<split> instead.
d986 2
a987 2
matching, you might also try the C<String::Approx>, and
C<Text::Metaphone>, and C<Text::DoubleMetaphone> modules.
d991 2
a992 1
(contributed by brian d foy)
d994 1
a994 46
If you can avoid it, don't, or if you can use a templating system,
such as C<Text::Template> or C<Template> Toolkit, do that instead. You
might even be able to get the job done with C<sprintf> or C<printf>:

	my $string = sprintf 'Say hello to %s and %s', $foo, $bar;

However, for the one-off simple case where I don't want to pull out a
full templating system, I'll use a string that has two Perl scalar
variables in it. In this example, I want to expand C<$foo> and C<$bar>
to their variable's values:

	my $foo = 'Fred';
	my $bar = 'Barney';
	$string = 'Say hello to $foo and $bar';

One way I can do this involves the substitution operator and a double
C</e> flag.  The first C</e> evaluates C<$1> on the replacement side and
turns it into C<$foo>. The second /e starts with C<$foo> and replaces
it with its value. C<$foo>, then, turns into 'Fred', and that's finally
what's left in the string:

	$string =~ s/(\$\w+)/$1/eeg; # 'Say hello to Fred and Barney'

The C</e> will also silently ignore violations of strict, replacing
undefined variable names with the empty string. Since I'm using the
C</e> flag (twice even!), I have all of the same security problems I 
have with C<eval> in its string form. If there's something odd in
C<$foo>, perhaps something like C<@@{[ system "rm -rf /" ]}>, then
I could get myself in trouble.

To get around the security problem, I could also pull the values from
a hash instead of evaluating variable names. Using a single C</e>, I
can check the hash to ensure the value exists, and if it doesn't, I
can replace the missing value with a marker, in this case C<???> to
signal that I missed something:

	my $string = 'This has $foo and $bar';
	
	my %Replacements = (
		foo  => 'Fred',
		);

	# $string =~ s/\$(\w+)/$Replacements{$1}/g;
	$string =~ s/\$(\w+)/
		exists $Replacements{$1} ? $Replacements{$1} : '???'
		/eg;
d996 17
a1012 1
	print $string;
d1016 4
a1019 4
The problem is that those double-quotes force
stringification--coercing numbers and references into strings--even
when you don't want them to be strings.  Think of it this way:
double-quote expansion is used to produce new strings.  If you already
d1024 3
a1026 3
	print "$var";   	# BAD
	$new = "$old";   	# BAD
	somefunc("$var");	# BAD
d1031 3
a1033 3
	print $var;
	$new = $old;
	somefunc($var);
d1039 5
a1043 5
	func(\@@array);
	sub func {
		my $aref = shift;
		my $oref = "$aref";  # WRONG
		}
d1052 3
a1054 3
	@@lines = `command`;
	print "@@lines";     # WRONG - extra blanks
	print @@lines;       # right
d1112 1
a1112 1
	$remember_the_main = fix<<'    MAIN_INTERPRETER_LOOP';
d1121 1
a1121 1
	MAIN_INTERPRETER_LOOP
d1126 1
a1126 1
	$poem = fix<<EVER_ON_AND_ON;
d1134 1
a1134 1
	EVER_ON_AND_ON
d1140 9
a1148 9
An array has a changeable length.  A list does not.  An array is
something you can push or pop, while a list is a set of values.  Some
people make the distinction that a list is a value while an array is a
variable. Subroutines are passed and return lists, you put things into
list context, you initialize arrays with lists, and you C<foreach()>
across a list.  C<@@> variables are arrays, anonymous arrays are
arrays, arrays in scalar context behave like the number of elements in
them, subroutines access their arguments through the array C<@@_>, and
C<push>/C<pop>/C<shift> only work on arrays.
d1153 1
a1153 1
	$scalar = (2, 5, 7, 9);
d1156 1
a1156 1
comma operator.  There never was a list there at all! This causes the
d1169 1
a1169 1
	$good[0] = `some program that outputs several lines`;
d1173 1
a1173 1
	@@bad[0]  = `same program that outputs several lines`;
d1190 3
a1192 10
	my %hash   = map { $_, 1 } @@array;
	# or a hash slice: @@hash{ @@array } = ();
	# or a foreach: $hash{$_} = 1 foreach ( @@array );

	my @@unique = keys %hash;

If you want to use a module, try the C<uniq> function from
C<List::MoreUtils>. In list context it returns the unique elements,
preserving their order in the list. In scalar context, it returns the
number of unique elements.
d1194 1
a1194 4
	use List::MoreUtils qw(uniq);

	my @@unique = uniq( 1, 2, 3, 4, 4, 5, 6, 5, 7 ); # 1,2,3,4,5,6,7
	my $unique = uniq( 1, 2, 3, 4, 4, 5, 6, 5, 7 ); # 7
d1203 2
a1204 2
C<undef>), so the next skips that iteration and the loop goes to the
next element.
d1218 2
a1219 2
	my %seen = ();
	my @@unique = grep { ! $seen{ $_ }++ } @@array;
d1234 3
a1236 3
	@@blues = qw/azure cerulean teal turquoise lapis-lazuli/;
	%is_blue = ();
	for (@@blues) { $is_blue{$_} = 1 }
d1238 2
a1239 2
Now you can check whether C<$is_blue{$some_color}>.  It might have
been a good idea to keep the blues all in a hash in the first place.
d1244 4
a1247 4
	@@primes = (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31);
	@@is_tiny_prime = ();
	for (@@primes) { $is_tiny_prime[$_] = 1 }
	# or simply  @@istiny_prime[@@primes] = (1) x @@primes;
d1254 3
a1256 3
	@@articles = ( 1..10, 150..2000, 2017 );
	undef $read;
	for (@@articles) { vec($read,$_,1) = 1 }
d1264 1
a1264 1
If you are testing only once, the standard module C<List::Util> exports
d1266 1
a1266 1
finds the element. It's written in C for speed, and its Perl equivalent
d1291 2
a1292 2
Use a hash.  Here's code to do both and more.  It assumes that each
element is unique in a given array:
d1294 7
a1300 7
	@@union = @@intersection = @@difference = ();
	%count = ();
	foreach $element (@@array1, @@array2) { $count{$element}++ }
	foreach $element (keys %count) {
		push @@union, $element;
		push @@{ $count{$element} > 1 ? \@@intersection : \@@difference }, $element;
		}
d1302 2
a1303 2
Note that this is the I<symmetric difference>, that is, all elements
in either A or in B but not in both.  Think of it as an xor operation.
d1307 15
a1321 15
The following code works for single-level arrays.  It uses a
stringwise comparison, and does not distinguish defined versus
undefined empty strings.  Modify if you have other needs.

	$are_equal = compare_arrays(\@@frogs, \@@toads);

	sub compare_arrays {
		my ($first, $second) = @@_;
		no warnings;  # silence spurious -w undef complaints
		return 0 unless @@$first == @@$second;
		for (my $i = 0; $i < @@$first; $i++) {
			return 0 if $first->[$i] ne $second->[$i];
			}
		return 1;
		}
d1324 1
a1324 1
like this one.  It uses the CPAN module C<FreezeThaw>:
d1326 2
a1327 2
	use FreezeThaw qw(cmpStr);
	@@a = @@b = ( "this", "that", [ "more", "stuff" ] );
d1329 4
a1332 4
	printf "a and b contain %s arrays\n",
		cmpStr(\@@a, \@@b) == 0
		? "the same"
		: "different";
d1334 2
a1335 2
This approach also works for comparing hashes.  Here we'll demonstrate
two different answers:
d1337 1
a1337 1
	use FreezeThaw qw(cmpStr cmpStrHard);
d1339 3
a1341 3
	%a = %b = ( "this" => "that", "extra" => [ "more", "stuff" ] );
	$a{EXTRA} = \%b;
	$b{EXTRA} = \%a;
d1343 1
a1343 1
	printf "a and b contain %s hashes\n",
d1346 1
a1346 1
	printf "a and b contain %s hashes\n",
d1357 2
a1358 3
use the C<first()> function in the C<List::Util> module, which comes
with Perl 5.8. This example finds the first element that contains
"Perl".
d1364 1
a1364 1
If you cannot use C<List::Util>, you can make your own loop to do the
d1368 2
a1369 1
	foreach ( @@array ) {
d1378 4
a1381 2
	for( $i = 0; $i < @@array; $i++ ) {
		if( $array[$i] =~ /Perl/ ) {
d1391 6
a1396 6
regular arrays, you can push and pop or shift and unshift at either
end, or you can use splice to add and/or remove arbitrary number of
elements at arbitrary points.  Both pop and shift are O(1)
operations on Perl's dynamic arrays.  In the absence of shifts and
pops, push in general needs to reallocate on the order every log(N)
times, and unshift will need to copy pointers each time.
d1399 2
a1400 2
L<perldsc> or L<perltoot> and do just what the algorithm book tells
you to do.  For example, imagine a list node like this:
d1402 4
a1405 4
	$node = {
		VALUE => 42,
		LINK  => undef,
		};
d1409 5
a1413 5
	print "List: ";
	for ($node = $head;  $node; $node = $node->{LINK}) {
		print $node->{VALUE}, " ";
		}
	print "\n";
d1417 5
a1421 5
	my ($head, $tail);
	$tail = append($head, 1);       # grow a new head
	for $value ( 2 .. 10 ) {
		$tail = append($tail, $value);
		}
d1423 11
a1433 12
	sub append {
		my($list, $value) = @@_;
		my $node = { VALUE => $value };
		if ($list) {
			$node->{LINK} = $list->{LINK};
			$list->{LINK} = $node;
			}
		else {
			$_[0] = $node;      # replace caller's version
			}
		return $node;
		}
d1442 2
a1443 12
	unshift(@@array, pop(@@array));  # the last shall be first
	push(@@array, shift(@@array));   # and vice versa

You can also use C<Tie::Cycle>:

	use Tie::Cycle;

	tie my $cycle, 'Tie::Cycle', [ qw( FFFFFF 000000 FFFF00 ) ];

	print $cycle; # FFFFFF
	print $cycle; # 000000
	print $cycle; # FFFF00
d1450 1
a1450 1
	use List::Util 'shuffle';
d1456 8
a1463 8
	sub fisher_yates_shuffle {
		my $deck = shift;  # $deck is a reference to an array
		my $i = @@$deck;
		while (--$i) {
			my $j = int rand ($i+1);
			@@$deck[$i,$j] = @@$deck[$j,$i];
			}
	}
d1465 5
a1469 5
	# shuffle my mpeg collection
	#
	my @@mpeg = <audio/*/*.mp3>;
	fisher_yates_shuffle( \@@mpeg );    # randomize @@mpeg in place
	print @@mpeg;
d1472 1
a1472 1
unlike the C<List::Util::shuffle()> which takes a list and returns
d1478 6
a1483 6
	srand;
	@@new = ();
	@@old = 1 .. 10;  # just a demo
	while (@@old) {
		push(@@new, splice(@@old, rand @@old, 1));
		}
d1485 4
a1488 4
This is bad because splice is already O(N), and since you do it N
times, you just invented a quadratic algorithm; that is, O(N**2).
This does not scale, although Perl is so efficient that you probably
won't notice this until you have rather largish arrays.
d1494 1
a1494 1
	for (@@lines) {
d1497 1
a1497 1
		}
d1501 1
a1501 1
	for (@@volumes = @@radii) {   # @@volumes has changed parts
d1504 1
a1504 1
		}
d1506 1
a1506 1
which can also be done with C<map()> which is made to transform
d1516 1
a1516 1
	for $orbit ( values %orbits ) {
d1518 1
a1518 1
		}
d1527 1
a1527 1
Use the C<rand()> function (see L<perlfunc/rand>):
d1529 2
a1530 2
	$index   = rand @@array;
	$element = $array[$index];
d1533 1
a1533 2

	my $element = $array[ rand @@array ];
a1535 2
X<List::Permuter> X<permute> X<Algorithm::Loops> X<Knuth>
X<The Art of Computer Programming> X<Fischer-Krause>
d1537 3
a1539 3
Use the C<List::Permutor> module on CPAN. If the list is actually an
array, try the C<Algorithm::Permute> module (also on CPAN). It's
written in XS code and is very efficient:
a1541 1

a1543 1

d1546 1
a1546 1
		}
d1550 11
a1560 12
	use Algorithm::Permute;

	my @@array = 'a'..'d';

	Algorithm::Permute::permute {
		print "next permutation: (@@array)\n";
		} @@array;

Here's a little program that generates all permutations of all the
words on each line of input. The algorithm embodied in the
C<permute()> function is discussed in Volume 4 (still unpublished) of
Knuth's I<The Art of Computer Programming> and will work on any list:
d1563 1
a1563 1
	# Fischer-Krause ordered permutation generator
d1578 1
a1578 16
	permute { print "@@_\n" } split;

The C<Algorithm::Loops> module also provides the C<NextPermute> and
C<NextPermuteNum> functions which efficiently find all unique permutations
of an array, even if it contains duplicate values, modifying it in-place:
if its elements are in reverse-sorted order then the array is reversed,
making it sorted, and it returns false; otherwise the next
permutation is returned.

C<NextPermute> uses string order and C<NextPermuteNum> numeric order, so
you can enumerate all the permutations of C<0..9> like this:

	use Algorithm::Loops qw(NextPermuteNum);
	
    my @@list= 0..9;
    do { print "@@list\n" } while NextPermuteNum @@list;
d1584 1
a1584 1
	@@list = sort { $a <=> $b } @@list;
d1597 6
a1602 6
	@@idx = ();
	for (@@data) {
		($item) = /\d+\s*(\S+)/;
		push @@idx, uc($item);
	    }
	@@sorted = @@data[ sort { $idx[$a] cmp $idx[$b] } 0 .. $#idx ];
d1607 3
a1609 3
	@@sorted = map  { $_->[0] }
		sort { $a->[1] cmp $b->[1] }
		map  { [ $_, uc( (/\d+\s*(\S+)/)[0]) ] } @@data;
d1613 4
a1616 5
	@@sorted = sort {
		field1($a) <=> field1($b) ||
		field2($a) cmp field2($b) ||
		field3($a) cmp field3($b)
		} @@data;
d1625 1
a1625 1
See also the question later in L<perlfaq4> on sorting hashes.
d1629 1
a1629 2
Use C<pack()> and C<unpack()>, or else C<vec()> and the bitwise
operations.
d1631 1
a1631 2
For example, this sets C<$vec> to have bit N set if C<$ints[N]> was
set:
d1633 2
a1634 2
	$vec = '';
	foreach(@@ints) { vec($vec,$_,1) = 1 }
d1636 31
a1666 34
Here's how, given a vector in C<$vec>, you can get those bits into your
C<@@ints> array:

	sub bitvec_to_list {
		my $vec = shift;
		my @@ints;
		# Find null-byte density then select best algorithm
		if ($vec =~ tr/\0// / length $vec > 0.95) {
			use integer;
			my $i;

			# This method is faster with mostly null-bytes
			while($vec =~ /[^\0]/g ) {
				$i = -9 + 8 * pos $vec;
				push @@ints, $i if vec($vec, ++$i, 1);
				push @@ints, $i if vec($vec, ++$i, 1);
				push @@ints, $i if vec($vec, ++$i, 1);
				push @@ints, $i if vec($vec, ++$i, 1);
				push @@ints, $i if vec($vec, ++$i, 1);
				push @@ints, $i if vec($vec, ++$i, 1);
				push @@ints, $i if vec($vec, ++$i, 1);
				push @@ints, $i if vec($vec, ++$i, 1);
				}
			}
		else {
			# This method is a fast general algorithm
			use integer;
			my $bits = unpack "b*", $vec;
			push @@ints, 0 if $bits =~ s/^(\d)// && $1;
			push @@ints, pos $bits while($bits =~ /1/g);
			}

		return \@@ints;
		}
d1675 2
a1676 2
		push @@ints, grep vec($vec, $_, 1), $-[0] * 8 .. $+[0] * 8;
		}
d1678 1
a1678 1
Or use the CPAN module C<Bit::Vector>:
d1680 3
a1682 3
	$vector = Bit::Vector->new($num_of_bits);
	$vector->Index_List_Store(@@ints);
	@@ints = $vector->Index_List_Read();
d1684 2
a1685 2
C<Bit::Vector> provides efficient methods for bit vector, sets of
small integers and "big int" math.
d1689 3
a1691 3
	# vec demo
	$vector = "\xff\x0f\xef\xfe";
	print "Ilya's string \\xff\\x0f\\xef\\xfe represents the number ",
d1693 23
a1715 2
	$is_set = vec($vector, 23, 1);
	print "Its 23rd bit is ", $is_set ? "set" : "clear", ".\n";
d1717 1
d1719 10
a1728 32
	set_vec(1,1,1);
	set_vec(3,1,1);
	set_vec(23,1,1);

	set_vec(3,1,3);
	set_vec(3,2,3);
	set_vec(3,4,3);
	set_vec(3,4,7);
	set_vec(3,8,3);
	set_vec(3,8,7);

	set_vec(0,32,17);
	set_vec(1,32,17);

	sub set_vec {
		my ($offset, $width, $value) = @@_;
		my $vector = '';
		vec($vector, $offset, $width) = $value;
		print "offset=$offset width=$width value=$value\n";
		pvec($vector);
		}

	sub pvec {
		my $vector = shift;
		my $bits = unpack("b*", $vector);
		my $i = 0;
		my $BASE = 8;

		print "vector length in bytes: ", length($vector), "\n";
		@@bytes = unpack("A8" x length($vector), $bits);
		print "bits are: @@bytes\n\n";
		}
d1740 2
a1741 1
(contributed by brian d foy)
d1743 3
a1745 21
There are a couple of ways that you can process an entire hash. You
can get a list of keys, then go through each key, or grab a one
key-value pair at a time.

To go through all of the keys, use the C<keys> function. This extracts
all of the keys of the hash and gives them back to you as a list. You
can then get the value through the particular key you're processing:

	foreach my $key ( keys %hash ) {
		my $value = $hash{$key}
		...
		}

Once you have the list of keys, you can process that list before you
process the hashh elements. For instance, you can sort the keys so you
can process them in lexical order:

	foreach my $key ( sort keys %hash ) {
		my $value = $hash{$key}
		...
		}
d1747 2
a1748 27
Or, you might want to only process some of the items. If you only want
to deal with the keys that start with C<text:>, you can select just
those using C<grep>:

	foreach my $key ( grep /^text:/, keys %hash ) {
		my $value = $hash{$key}
		...
		}

If the hash is very large, you might not want to create a long list of
keys. To save some memory, you can grab on key-value pair at a time using
C<each()>, which returns a pair you haven't seen yet:

	while( my( $key, $value ) = each( %hash ) ) {
		...
		}

The C<each> operator returns the pairs in apparently random order, so if
ordering matters to you, you'll have to stick with the C<keys> method.

The C<each()> operator can be a bit tricky though. You can't add or
delete keys of the hash while you're using it without possibly
skipping or re-processing some pairs after Perl internally rehashes
all of the elements. Additionally, a hash has only one iterator, so if
you use C<keys>, C<values>, or C<each> on the same hash, you can reset
the iterator and mess up your processing. See the C<each> entry in
L<perlfunc> for more details.
d1766 2
a1767 2
	%by_value = reverse %by_key;
	$key = $by_value{$value};
d1772 3
a1774 3
	while (($key, $value) = each %by_key) {
		$by_value{$value} = $key;
	    }
d1780 3
a1782 3
	while (($key, $value) = each %by_key) {
		 push @@{$key_list_by_value{$value}}, $key;
		}
a1842 1
X<hash tie sort DB_File Tie::IxHash>
d1844 3
a1846 6
You can look into using the C<DB_File> module and C<tie()> using the
C<$DB_BTREE> hash bindings as documented in L<DB_File/"In Memory
Databases">. The C<Tie::IxHash> module from CPAN might also be
instructive. Although this does keep your hash sorted, you might not
like the slow down you suffer from the tie interface. Are you sure you
need to do this? :)
d1853 1
a1853 1
number, or reference.  If a key C<$key> is present in
d1860 1
a1860 1
Pictures help...  here's the C<%hash> table:
d1876 1
a1876 1
	exists $hash{'a'}                is true (Perl 5 only)
d1900 1
a1900 1
	exists $hash{'a'}                is true (Perl 5 only)
d1924 1
a1924 1
	exists $hash{'a'}                is FALSE (Perl 5 only)
d1939 4
a1942 10
(contributed by brian d foy)

You can use the C<keys> or C<values> functions to reset C<each>. To
simply reset the iterator used by C<each> without doing anything else,
use one of them in void context:

	keys %hash; # resets iterator, nothing else.
	values %hash; # resets iterator, nothing else.

See the documentation for C<each> in L<perlfunc>.
d1949 5
a1953 5
	%seen = ();
	for $element (keys(%foo), keys(%bar)) {
		$seen{$element}++;
		}
	@@uniq = keys %seen;
d1957 1
a1957 1
	@@uniq = keys %{{%foo,%bar}};
d1961 8
a1968 8
	%seen = ();
	while (defined ($key = each %foo)) {
		$seen{$key}++;
	}
	while (defined ($key = each %bar)) {
		$seen{$key}++;
	}
	@@uniq = keys %seen;
d1978 1
a1978 1
Use the C<Tie::IxHash> from CPAN.
d1980 7
a1986 10
	use Tie::IxHash;

	tie my %myhash, 'Tie::IxHash';

	for (my $i=0; $i<20; $i++) {
		$myhash{$i} = 2*$i;
		}

	my @@keys = keys %myhash;
	# @@keys = (0,1,2,3,...)
d1992 1
a1992 1
	somefunc($hash{"nonesuch key here"});
d2009 8
a2016 8
	$record = {
		NAME   => "Jason",
		EMPNO  => 132,
		TITLE  => "deputy peon",
		AGE    => 23,
		SALARY => 37_000,
		PALS   => [ "Norbert", "Rhys", "Phineas"],
	};
d2029 5
a2033 5
form (for instance, C<HASH(0xDEADBEEF)>). From there you can't get
back the reference from the stringified form, at least without doing
some extra work on your own. Also remember that hash keys must be
unique, but two different variables can store the same reference (and
those variables can change later).
d2035 2
a2036 2
The C<Tie::RefHash> module, which is distributed with perl, might be
what you want. It handles that extra work.
d2042 2
a2043 4
Perl is binary clean, so it can handle binary data just fine.
On Windows or DOS, however, you have to use C<binmode> for binary
files to avoid conversions for line endings. In general, you should
use C<binmode> any time you want to work with binary data.
d2045 9
a2053 1
Also see L<perlfunc/"binmode"> or L<perlopentut>.
a2054 1
If you're concerned about 8-bit textual data then see L<perllocale>.
d2063 7
a2069 7
	if (/\D/)            { print "has nondigits\n" }
	if (/^\d+$/)         { print "is a whole number\n" }
	if (/^-?\d+$/)       { print "is an integer\n" }
	if (/^[+-]?\d+$/)    { print "is a +/- integer\n" }
	if (/^-?\d+\.?\d*$/) { print "is a real number\n" }
	if (/^-?(?:\d+(?:\.\d*)?|\.\d+)$/) { print "is a decimal number\n" }
	if (/^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/)
d2074 7
a2080 6
internal function C<looks_like_number> for determining whether a
variable looks like a number.  L<Data::Types> exports functions that
validate data types using both the above and other regular
expressions. Thirdly, there is C<Regexp::Common> which has regular
expressions to match various types of numbers. Those three modules are
available from the CPAN.
d2083 19
a2101 20
function.  Its semantics are somewhat cumbersome, so here's a
C<getnum> wrapper function for more convenient access.  This function
takes a string and returns the number it found, or C<undef> for input
that isn't a C float.  The C<is_numeric> function is a front end to
C<getnum> if you just want to say, "Is this a float?"

	sub getnum {
		use POSIX qw(strtod);
		my $str = shift;
		$str =~ s/^\s+//;
		$str =~ s/\s+$//;
		$! = 0;
		my($num, $unparsed) = strtod($str);
		if (($str eq '') || ($unparsed != 0) || $!) {
				return undef;
			}
		else {
			return $num;
			}
		}
d2103 1
a2103 1
	sub is_numeric { defined getnum($_[0]) }
d2106 3
a2108 3
instead. The C<POSIX> module (part of the standard Perl distribution)
provides the C<strtod> and C<strtol> for converting strings to double
and longs, respectively.
d2113 3
a2115 3
See L<AnyDBM_File>.  More generically, you should consult the C<FreezeThaw>
or C<Storable> modules from CPAN.  Starting from Perl 5.8 C<Storable> is part
of the standard distribution.  Here's one example using C<Storable>'s C<store>
d2118 2
a2119 2
	use Storable;
	store(\%hash, "filename");
d2121 3
a2123 3
	# later on...
	$href = retrieve("filename");        # by ref
	%hash = %{ retrieve("filename") };   # direct to hash
d2127 2
a2128 2
The C<Data::Dumper> module on CPAN (or the 5.005 release of Perl) is great
for printing out data structures.  The C<Storable> module on CPAN (or the
d2132 2
a2133 2
	use Storable qw(dclone);
	$r2 = dclone($r1);
d2135 1
a2135 1
Where C<$r1> can be a reference to any kind of data structure you'd like.
d2140 1
a2140 1
	%newhash = %{ dclone(\%oldhash) };
d2144 1
a2144 1
Use the C<UNIVERSAL> class (see L<UNIVERSAL>).
d2148 1
a2148 1
Get the C<Business::CreditCard> module from CPAN.
d2152 1
a2152 1
The kgbpack.c code in the C<PGPLOT> module on CPAN does just this.
d2154 1
a2154 9
the C<PDL> module from CPAN instead--it makes number-crunching easy.

=head1 REVISION

Revision: $Revision: 10394 $

Date: $Date: 2007-12-09 18:47:15 +0100 (Sun, 09 Dec 2007) $

See L<perlfaq> for source control details and availability.
d2158 1
a2158 1
Copyright (c) 1997-2007 Tom Christiansen, Nathan Torkington, and
@


1.1.1.11
log
@import perl 5.10.1
@
text
@d3 1
a3 1
perlfaq4 - Data Manipulation
d51 29
a79 39
(contributed by brian d foy)

You're probably trying to convert a string to a number, which Perl only
converts as a decimal number. When Perl converts a string to a number, it
ignores leading spaces and zeroes, then assumes the rest of the digits
are in base 10:

	my $string = '0644';

	print $string + 0;  # prints 644

	print $string + 44; # prints 688, certainly not octal!

This problem usually involves one of the Perl built-ins that has the
same name a unix command that uses octal numbers as arguments on the
command line. In this example, C<chmod> on the command line knows that
its first argument is octal because that's what it does:

	%prompt> chmod 644 file

If you want to use the same literal digits (644) in Perl, you have to tell
Perl to treat them as octal numbers either by prefixing the digits with
a C<0> or using C<oct>:

	chmod(     0644, $file);   # right, has leading zero
	chmod( oct(644), $file );  # also correct

The problem comes in when you take your numbers from something that Perl
thinks is a string, such as a command line argument in C<@@ARGV>:

	chmod( $ARGV[0],      $file);   # wrong, even if "0644"

	chmod( oct($ARGV[0]), $file );  # correct, treat string as octal

You can always check the value you're using by printing it in octal
notation to ensure it matches what you think it should be. Print it
in octal  and decimal format:

	printf "0%o %d", $number, $number;
d366 1
a366 1
built-in to get a random number between 0 and 1. From there, you shift
d376 1
a376 1
	my $number = 10 + int rand( 15-10+1 ); # ( 10,11,12,13,14, or 15 )
a480 3
X<date> X<yesterday> X<DateTime> X<Date::Calc> X<Time::Local>
X<daylight saving time> X<day> X<Today_and_Now> X<localtime>
X<timelocal>
a506 16
If you absolutely must do it yourself (or can't use one of the
modules), here's a solution using C<Time::Local>, which comes with
Perl:

	# contributed by Gunnar Hjalmarsson
	 use Time::Local;
	 my $today = timelocal 0, 0, 12, ( localtime )[3..5];
	 my ($d, $m, $y) = ( localtime $today-86400 )[3..5];
	 printf "Yesterday: %d-%02d-%02d\n", $y+1900, $m+1, $d;

In this case, you measure the day starting at noon, and subtract 24
hours. Even if the length of the calendar day is 23 or 25 hours,
you'll still end up on the previous calendar day, although not at
noon. Since you don't care about the time, the one hour difference
doesn't matter and you end up with the previous date.

d783 22
a804 1
=head2 Does Perl have a Year 2038 problem?
d806 1
a806 2
No, all of Perl's built in date and time functions and modules will
work to about 2 billion years before and after 1970.
d808 1
a808 3
Many systems cannot count time past the year 2038.  Older versions of
Perl were dependent on the system to do date calculation and thus
shared their 2038 bug.
d810 3
a812 2
=head2 How do I capitalize all the words on one line?
X<Text::Autoformat> X<capitalize> X<case, title> X<case, sentence>
d814 4
a817 1
(contributed by brian d foy)
d819 2
a820 2
Damian Conway's L<Text::Autoformat> handles all of the thinking
for you.
a830 24
How do you want to capitalize those words?

	FRED AND BARNEY'S LODGE        # all uppercase
	Fred And Barney's Lodge        # title case
	Fred and Barney's Lodge        # highlight case

It's not as easy a problem as it looks. How many words do you think
are in there? Wait for it... wait for it.... If you answered 5
you're right. Perl words are groups of C<\w+>, but that's not what
you want to capitalize. How is Perl supposed to know not to capitalize
that C<s> after the apostrophe? You could try a regular expression:

	$string =~ s/ (
				 (^\w)    #at the beginning of the line
				   |      # or
				 (\s\w)   #preceded by whitespace
				   )
				/\U$1/xg;

	$string =~ s/([\w']+)/\u\L$1/g;

Now, what if you don't want to capitalize that "and"? Just use
L<Text::Autoformat> and get on with the next problem. :)

d983 1
a983 1
handle that format, such as C<Text::CSV>, C<Text::CSV_XS>, or
d1033 1
a1033 1
C</e> flag (twice even!), I have all of the same security problems I
d1045 1
a1045 1

d1276 1
a1276 1
(portions of this answer contributed by Anno Siegel and brian d foy)
d1282 1
a1282 17
That being said, there are several ways to approach this.  In Perl 5.10
and later, you can use the smart match operator to check that an item is
contained in an array or a hash:

	use 5.010;

	if( $item ~~ @@array )
		{
		say "The array contains $item"
		}

	if( $item ~~ %hash )
		{
		say "The hash contains $item"
		}

With earlier versions of Perl, you have to do a bit more work. If you
d1285 1
a1285 1
hash whose keys are the first array's values:
a1359 15
With Perl 5.10 and later, the smart match operator can give you the answer
with the least amount of work:

	use 5.010;

	if( @@array1 ~~ @@array2 )
		{
		say "The arrays are the same";
		}

	if( %hash1 ~~ %hash2 ) # doesn't check values!
		{
		say "The hash keys are the same";
		}

a1489 7
X<circular> X<array> X<Tie::Cycle> X<Array::Iterator::Circular>
X<cycle> X<modulus>

(contributed by brian d foy)

If you want to cycle through an array endlessy, you can increment the
index modulo the number of elements in the array:
d1491 2
a1492 2
	my @@array = qw( a b c );
	my $i = 0;
d1494 2
a1495 4
	while( 1 ) {
		print $array[ $i++ % @@array ], "\n";
		last if $i > 20;
		}
d1497 1
a1497 2
You can also use C<Tie::Cycle> to use a scalar that always has the
next element of the circular array:
a1506 13
The C<Array::Iterator::Circular> creates an iterator object for
circular arrays:

	use Array::Iterator::Circular;

	my $color_iterator = Array::Iterator::Circular->new(
		qw(red green blue orange)
		);

	foreach ( 1 .. 20 ) {
		print $color_iterator->next, "\n";
		}

a1519 2
		return unless @@$deck; # must not be empty!

d1659 1
a1659 1

d1716 2
a1717 4
For example, you don't have to store individual bits in an array
(which would mean that you're wasting a lot of space). To convert an
array of bits to a string, use C<vec()> to set the right bits. This
sets C<$vec> to have bit N set only if C<$ints[N]> was set:
a1718 1
	@@ints = (...); # array of bits, e.g. ( 1, 0, 0, 1, 1, 0 ... )
d1720 1
a1720 3
	foreach( 0 .. $#ints ) {
		vec($vec,$_,1) = 1 if $ints[$_];
		}
d1722 2
a1723 6
The string C<$vec> only takes up as many bits as it needs. For
instance, if you had 16 entries in C<@@ints>, C<$vec> only needs two
bytes to store them (not counting the scalar variable overhead).

Here's how, given a vector in C<$vec>, you can get those bits into
your C<@@ints> array:
d1845 1
a1845 1
process the hash elements. For instance, you can sort the keys so you
d1863 1
a1863 1
keys. To save some memory, you can grab one key-value pair at a time using
a1880 56
=head2 How do I merge two hashes?
X<hash> X<merge> X<slice, hash>

(contributed by brian d foy)

Before you decide to merge two hashes, you have to decide what to do
if both hashes contain keys that are the same and if you want to leave
the original hashes as they were.

If you want to preserve the original hashes, copy one hash (C<%hash1>)
to a new hash (C<%new_hash>), then add the keys from the other hash
(C<%hash2> to the new hash. Checking that the key already exists in
C<%new_hash> gives you a chance to decide what to do with the
duplicates:

	my %new_hash = %hash1; # make a copy; leave %hash1 alone

	foreach my $key2 ( keys %hash2 )
		{
		if( exists $new_hash{$key2} )
			{
			warn "Key [$key2] is in both hashes!";
			# handle the duplicate (perhaps only warning)
			...
			next;
			}
		else
			{
			$new_hash{$key2} = $hash2{$key2};
			}
		}

If you don't want to create a new hash, you can still use this looping
technique; just change the C<%new_hash> to C<%hash1>.

	foreach my $key2 ( keys %hash2 )
		{
		if( exists $hash1{$key2} )
			{
			warn "Key [$key2] is in both hashes!";
			# handle the duplicate (perhaps only warning)
			...
			next;
			}
		else
			{
			$hash1{$key2} = $hash2{$key2};
			}
		}

If you don't care that one hash overwrites keys and values from the other, you
could just use a hash slice to add one hash to another. In this case, values
from C<%hash2> replace values from C<%hash1> when they have keys in common:

	@@hash1{ keys %hash2 } = values %hash2;

d1917 2
a1918 1
(contributed by brian d foy)
d1920 1
a1920 21
This is very similar to "How do I process an entire hash?", also in
L<perlfaq4>, but a bit simpler in the common cases.

You can use the C<keys()> built-in function in scalar context to find out
have many entries you have in a hash:

	my $key_count = keys %hash; # must be scalar context!
	
If you want to find out how many entries have a defined value, that's
a bit different. You have to check each value. A C<grep> is handy: 

	my $defined_value_count = grep { defined } values %hash;

You can use that same structure to count the entries any way that
you like. If you want the count of the keys with vowels in them,
you just test for that instead:

	my $vowel_count = grep { /[aeiou]/ } keys %hash;
	
The C<grep> in scalar context returns the count. If you want the list
of matching items, just use it in list context instead:
d1922 1
a1922 3
	my @@defined_values = grep { defined } values %hash;

The C<keys()> function also resets the iterator, which means that you may
d1924 1
a1924 1
such as C<each()>.
d1940 1
a1940 1
		printf "%-20s %6d\n", $key, $hash{$key};
d2134 1
a2134 17
(contributed by brian d foy)

Are you using a really old version of Perl?

Normally, accessing a hash key's value for a nonexistent key will
I<not> create the key.

	my %hash  = ();
	my $value = $hash{ 'foo' };
	print "This won't print\n" if exists $hash{ 'foo' };

Passing C<$hash{ 'foo' }> to a subroutine used to be a special case, though.
Since you could assign directly to C<$_[0]>, Perl had to be ready to
make that assignment so it created the hash key ahead of time:

    my_sub( $hash{ 'foo' } );
	print "This will print before 5.004\n" if exists $hash{ 'foo' };
d2136 1
a2136 7
	sub my_sub {
		# $_[0] = 'bar'; # create hash key in case you do this
		1;
		}

Since Perl 5.004, however, this situation is a special case and Perl
creates the hash key only when you make the assignment:
d2138 4
a2141 6
    my_sub( $hash{ 'foo' } );
	print "This will print, even after 5.004\n" if exists $hash{ 'foo' };

	sub my_sub {
		$_[0] = 'bar';
		}
d2143 1
a2143 3
However, if you want the old behavior (and think carefully about that
because it's a weird side effect), you can pass a hash slice instead.
Perl 5.004 didn't make this a special case:
d2145 3
a2147 1
	my_sub( @@hash{ qw/foo/ } );
d2169 1
a2169 1
(contributed by brian d foy and Ben Morrow)
d2175 3
a2177 1
some extra work on your own.
d2179 2
a2180 17
Remember that the entry in the hash will still be there even if
the referenced variable  goes out of scope, and that it is entirely
possible for Perl to subsequently allocate a different variable at
the same address. This will mean a new variable might accidentally
be associated with the value for an old.

If you have Perl 5.10 or later, and you just want to store a value
against the reference for lookup later, you can use the core
Hash::Util::Fieldhash module. This will also handle renaming the
keys if you use multiple threads (which causes all variables to be
reallocated at new addresses, changing their stringification), and
garbage-collecting the entries when the referenced variable goes out
of scope.

If you actually need to be able to get a real reference back from
each hash entry, you can use the Tie::RefHash module, which does the
required work for you.
d2283 1
a2283 8
(contributed by Ben Morrow)

You can use the C<UNIVERSAL> class (see L<UNIVERSAL>). However, please
be very careful to consider the consequences of doing this: adding
methods to every object is very likely to have unintended
consequences. If possible, it would be better to have all your object
inherit from some common base class, or to use an object system like
Moose that supports roles.
d2291 1
a2291 1
The arrays.h/arrays.c code in the C<PGPLOT> module on CPAN does just this.
a2294 2
See L<http://search.cpan.org/dist/PGPLOT> for the code.

d2297 1
a2297 1
Revision: $Revision$
d2299 1
a2299 1
Date: $Date$
d2305 1
a2305 1
Copyright (c) 1997-2009 Tom Christiansen, Nathan Torkington, and
@


1.1.1.12
log
@Perl 5.12.2 from CPAN
@
text
@a13 4
For the long explanation, see David Goldberg's "What Every Computer
Scientist Should Know About Floating-Point Arithmetic"
(http://docs.sun.com/source/806-3568/ncg_goldberg.html).

d24 1
a24 1
C<printf> or C<sprintf> function.  See the L<"Floating Point
d65 1
a65 1
same name a Unix command that uses octal numbers as arguments on the
d300 2
a301 2
Use the C<Math::Matrix> or C<Math::MatrixReal> modules (available from CPAN)
or the C<PDL> extension (also available from CPAN).
d345 1
a345 1
Get the L<http://www.cpan.org/modules/by-module/Roman> module.
d361 1
a361 1
collection in L<http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz>, courtesy
d371 1
a371 1
"Numerical Recipes in C" at L<http://www.nr.com/>.
d404 2
a405 2
The C<localtime> function returns the day of the year.  Without an
argument C<localtime> uses the current time.
d417 1
a417 1
a time in epoch seconds for the argument to C<localtime>.
d536 1
a536 18
=head2 Does Perl have a Year 2000 or 2038 problem? Is Perl Y2K compliant?

(contributed by brian d foy)

Perl itself never had a Y2K problem, although that never stopped people
from creating Y2K problems on their own. See the documentation for
C<localtime> for its proper use.

Starting with Perl 5.11, C<localtime> and C<gmtime> can handle dates past
03:14:08 January 19, 2038, when a 32-bit based time would overflow. You
still might get a warning on a 32-bit C<perl>:

	% perl5.11.2 -E 'say scalar localtime( 0x9FFF_FFFFFFFF )'
	Integer overflow in hexadecimal number at -e line 1.
	Wed Nov  1 19:42:39 5576711

On a 64-bit C<perl>, you can get even larger dates for those really long
running projects:
d538 27
a564 5
	% perl5.11.2 -E 'say scalar gmtime( 0x9FFF_FFFFFFFF )'
	Thu Nov  2 00:42:39 5576711

You're still out of luck if you need to keep tracking of decaying protons
though.
d812 9
d995 1
a995 1
If you know the columns that contain the data, you can
d1018 1
a1018 1
C<unpack> with the A (ASCII) format. By using a number after the format
d1214 18
a1231 1
(contributed by brian d foy)
d1233 1
a1233 30
A list is a fixed collection of scalars. An array is a variable that
holds a variable collection of scalars. An array can supply its collection
for list operations, so list operations also work on arrays:

	# slices
	( 'dog', 'cat', 'bird' )[2,3];
	@@animals[2,3];

	# iteration
	foreach ( qw( dog cat bird ) ) { ... }
	foreach ( @@animals ) { ... }

	my @@three = grep { length == 3 } qw( dog cat bird );
	my @@three = grep { length == 3 } @@animals;

	# supply an argument list
	wash_animals( qw( dog cat bird ) );
	wash_animals( @@animals );

Array operations, which change the scalars, reaaranges them, or adds
or subtracts some scalars, only work on arrays. These can't work on a
list, which is fixed. Array operations include C<shift>, C<unshift>,
C<push>, C<pop>, and C<splice>.

An array can also change its length:

	$#animals = 1;  # truncate to two elements
	$#animals = 10000; # pre-extend to 10,001 elements

You can change an array element, but you can't change a list element:
d1235 4
a1238 2
	$animals[0] = 'Rottweiler';
	qw( dog cat bird )[0] = 'Rottweiler'; # syntax error!
d1240 2
a1241 17
	foreach ( @@animals ) {
		s/^d/fr/;  # works fine
		}

	foreach ( qw( dog cat bird ) ) {
		s/^d/fr/;  # Error! Modification of read only value!
		}

However, if the list element is itself a variable, it appears that you
can change a list element. However, the list element is the variable, not
the data. You're not changing the list element, but something the list
element refers to. The list element itself doesn't change: it's still
the same variable.

You also have to be careful about context. You can assign an array to
a scalar to get the number of elements in the array. This only works
for arrays, though:
d1243 1
a1243 1
	my $count = @@animals;  # only works with arrays
d1245 1
a1245 4
If you try to do the same thing with what you think is a list, you
get a quite different result. Although it looks like you have a list
on the righthand side, Perl actually sees a bunch of scalars separated
by a comma:
d1247 1
a1247 1
	my $scalar = ( 'dog', 'cat', 'bird' );  # $scalar gets bird
d1249 2
a1250 46
Since you're assigning to a scalar, the righthand side is in scalar
context. The comma operator (yes, it's an operator!) in scalar
context evaluates its lefthand side, throws away the result, and
evaluates it's righthand side and returns the result. In effect,
that list-lookalike assigns to C<$scalar> it's rightmost value. Many
people mess this up becuase they choose a list-lookalike whose
last element is also the count they expect:

	my $scalar = ( 1, 2, 3 );  # $scalar gets 3, accidentally

=head2 What is the difference between $array[1] and @@array[1]?

(contributed by brian d foy)

The difference is the sigil, that special character in front of the
array name. The C<$> sigil means "exactly one item", while the C<@@>
sigil means "zero or more items". The C<$> gets you a single scalar,
while the C<@@> gets you a list.

The confusion arises because people incorrectly assume that the sigil
denotes the variable type.

The C<$array[1]> is a single-element access to the array. It's going
to return the item in index 1 (or undef if there is no item there).
If you intend to get exactly one element from the array, this is the
form you should use.

The C<@@array[1]> is an array slice, although it has only one index.
You can pull out multiple elements simultaneously by specifying
additional indices as a list, like C<@@array[1,4,3,0]>.

Using a slice on the lefthand side of the assignment supplies list
context to the righthand side. This can lead to unexpected results.
For instance, if you want to read a single line from a filehandle,
assigning to a scalar value is fine:

	$array[1] = <STDIN>;

However, in list context, the line input operator returns all of the
lines as a list. The first line goes into C<@@array[1]> and the rest
of the lines mysteriously disappear:

	@@array[1] = <STDIN>;  # most likely not what you want

Either the C<use warnings> pragma or the B<-w> flag will warn you when
you use an array slice with a single index.
d1557 1
a1557 1
If you want to cycle through an array endlessly, you can increment the
d2078 1
a2078 1

d2080 1
a2080 1
a bit different. You have to check each value. A C<grep> is handy:
d2089 1
a2089 1

d2168 1
a2168 1
Pictures help...  Here's the C<%hash> table:
d2514 8
d2524 1
a2524 1
Copyright (c) 1997-2010 Tom Christiansen, Nathan Torkington, and
@


