head	1.12;
access;
symbols
	OPENBSD_5_3:1.11.0.10
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.8
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.6
	OPENBSD_5_0:1.11.0.4
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	PERL_5_12_2:1.1.1.11
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	PERL_5_10_1:1.1.1.10
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	PERL_5_10_0:1.1.1.9
	OPENBSD_4_4:1.8.0.10
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	PERL_5_8_8:1.1.1.8
	OPENBSD_3_9:1.7.0.6
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	PERL_5_8_6:1.1.1.7
	OPENBSD_3_6:1.6.0.4
	OPENBSD_3_6_BASE:1.6
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.12
date	2013.03.25.20.40.58;	author sthen;	state dead;
branches;
next	1.11;

1.11
date	2010.09.24.15.07.03;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.12.18.24.47;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.29.17.36.16;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.28.19.23.10;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2005.01.15.21.30.36;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.03.03.02.44;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.33;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.24.18.35.54;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.07.27;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.04.29.22.52.11;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.11.30.07.59.10;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.40.43;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.10.24;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.24.36;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.04;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.44.21;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.08.09.17.48.11;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2005.01.15.21.17.53;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2006.03.28.18.49.18;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2008.09.29.17.18.51;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2009.10.12.18.10.40;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2010.09.24.14.49.06;	author millert;	state Exp;
branches;
next	;


desc
@perl 5.004_04
@


1.12
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@=head1 NAME

perlfaq6 - Regular Expressions

=head1 DESCRIPTION

This section is surprisingly small because the rest of the FAQ is
littered with answers involving regular expressions.  For example,
decoding a URL and checking whether something is a number are handled
with regular expressions, but those answers are found elsewhere in
this document (in L<perlfaq9>: "How do I decode or create those %-encodings
on the web" and L<perlfaq4>: "How do I determine whether a scalar is
a number/whole/integer/float", to be precise).

=head2 How can I hope to use regular expressions without creating illegible and unmaintainable code?
X<regex, legibility> X<regexp, legibility>
X<regular expression, legibility> X</x>

Three techniques can make regular expressions maintainable and
understandable.

=over 4

=item Comments Outside the Regex

Describe what you're doing and how you're doing it, using normal Perl
comments.

	# turn the line into the first word, a colon, and the
	# number of characters on the rest of the line
	s/^(\w+)(.*)/ lc($1) . ":" . length($2) /meg;

=item Comments Inside the Regex

The C</x> modifier causes whitespace to be ignored in a regex pattern
(except in a character class and a few other places), and also allows you to
use normal comments there, too.  As you can imagine, whitespace and comments
help a lot.

C</x> lets you turn this:

	s{<(?:[^>'"]*|".*?"|'.*?')+>}{}gs;

into this:

	s{ <                    # opening angle bracket
		(?:                 # Non-backreffing grouping paren
			[^>'"] *        # 0 or more things that are neither > nor ' nor "
				|           #    or else
			".*?"           # a section between double quotes (stingy match)
				|           #    or else
			'.*?'           # a section between single quotes (stingy match)
		) +                 #   all occurring one or more times
		>                   # closing angle bracket
	}{}gsx;                 # replace with nothing, i.e. delete

It's still not quite so clear as prose, but it is very useful for
describing the meaning of each part of the pattern.

=item Different Delimiters

While we normally think of patterns as being delimited with C</>
characters, they can be delimited by almost any character.  L<perlre>
describes this.  For example, the C<s///> above uses braces as
delimiters.  Selecting another delimiter can avoid quoting the
delimiter within the pattern:

	s/\/usr\/local/\/usr\/share/g;	# bad delimiter choice
	s#/usr/local#/usr/share#g;		# better

=back

=head2 I'm having trouble matching over more than one line.  What's wrong?
X<regex, multiline> X<regexp, multiline> X<regular expression, multiline>

Either you don't have more than one line in the string you're looking
at (probably), or else you aren't using the correct modifier(s) on
your pattern (possibly).

There are many ways to get multiline data into a string.  If you want
it to happen automatically while reading input, you'll want to set $/
(probably to '' for paragraphs or C<undef> for the whole file) to
allow you to read more than one line at a time.

Read L<perlre> to help you decide which of C</s> and C</m> (or both)
you might want to use: C</s> allows dot to include newline, and C</m>
allows caret and dollar to match next to a newline, not just at the
end of the string.  You do need to make sure that you've actually
got a multiline string in there.

For example, this program detects duplicate words, even when they span
line breaks (but not paragraph ones).  For this example, we don't need
C</s> because we aren't using dot in a regular expression that we want
to cross line boundaries.  Neither do we need C</m> because we aren't
wanting caret or dollar to match at any point inside the record next
to newlines.  But it's imperative that $/ be set to something other
than the default, or else we won't actually ever have a multiline
record read in.

	$/ = '';  		# read in whole paragraph, not just one line
	while ( <> ) {
		while ( /\b([\w'-]+)(\s+\1)+\b/gi ) {  	# word starts alpha
			print "Duplicate $1 at paragraph $.\n";
		}
	}

Here's code that finds sentences that begin with "From " (which would
be mangled by many mailers):

	$/ = '';  		# read in whole paragraph, not just one line
	while ( <> ) {
		while ( /^From /gm ) { # /m makes ^ match next to \n
		print "leading from in paragraph $.\n";
		}
	}

Here's code that finds everything between START and END in a paragraph:

	undef $/;  		# read in whole file, not just one line or paragraph
	while ( <> ) {
		while ( /START(.*?)END/sgm ) { # /s makes . cross line boundaries
		    print "$1\n";
		}
	}

=head2 How can I pull out lines between two patterns that are themselves on different lines?
X<..>

You can use Perl's somewhat exotic C<..> operator (documented in
L<perlop>):

	perl -ne 'print if /START/ .. /END/' file1 file2 ...

If you wanted text and not lines, you would use

	perl -0777 -ne 'print "$1\n" while /START(.*?)END/gs' file1 file2 ...

But if you want nested occurrences of C<START> through C<END>, you'll
run up against the problem described in the question in this section
on matching balanced text.

Here's another example of using C<..>:

	while (<>) {
		$in_header =   1  .. /^$/;
		$in_body   = /^$/ .. eof;
	# now choose between them
	} continue {
		$. = 0 if eof;	# fix $.
	}

=head2 How do I match XML, HTML, or other nasty, ugly things with a regex?
X<regex, XML> X<regex, HTML> X<XML> X<HTML> X<pain> X<frustration>
X<sucking out, will to live>

(contributed by brian d foy)

If you just want to get work done, use a module and forget about the
regular expressions. The C<XML::Parser> and C<HTML::Parser> modules
are good starts, although each namespace has other parsing modules
specialized for certain tasks and different ways of doing it. Start at
CPAN Search ( http://search.cpan.org ) and wonder at all the work people
have done for you already! :)

The problem with things such as XML is that they have balanced text
containing multiple levels of balanced text, but sometimes it isn't
balanced text, as in an empty tag (C<< <br/> >>, for instance). Even then,
things can occur out-of-order. Just when you think you've got a
pattern that matches your input, someone throws you a curveball.

If you'd like to do it the hard way, scratching and clawing your way
toward a right answer but constantly being disappointed, besieged by
bug reports, and weary from the inordinate amount of time you have to
spend reinventing a triangular wheel, then there are several things
you can try before you give up in frustration:

=over 4

=item * Solve the balanced text problem from another question in L<perlfaq6>

=item * Try the recursive regex features in Perl 5.10 and later. See L<perlre>

=item * Try defining a grammar using Perl 5.10's C<(?DEFINE)> feature.

=item * Break the problem down into sub-problems instead of trying to use a single regex

=item * Convince everyone not to use XML or HTML in the first place

=back

Good luck!

=head2 I put a regular expression into $/ but it didn't work. What's wrong?
X<$/, regexes in> X<$INPUT_RECORD_SEPARATOR, regexes in>
X<$RS, regexes in>

$/ has to be a string.  You can use these examples if you really need to
do this.

If you have File::Stream, this is easy.

	use File::Stream;

	my $stream = File::Stream->new(
		$filehandle,
		separator => qr/\s*,\s*/,
		);

	print "$_\n" while <$stream>;

If you don't have File::Stream, you have to do a little more work.

You can use the four-argument form of sysread to continually add to
a buffer.  After you add to the buffer, you check if you have a
complete line (using your regular expression).

	local $_ = "";
	while( sysread FH, $_, 8192, length ) {
		while( s/^((?s).*?)your_pattern// ) {
			my $record = $1;
			# do stuff here.
		}
	}

You can do the same thing with foreach and a match using the
c flag and the \G anchor, if you do not mind your entire file
being in memory at the end.

	local $_ = "";
	while( sysread FH, $_, 8192, length ) {
		foreach my $record ( m/\G((?s).*?)your_pattern/gc ) {
			# do stuff here.
		}
	substr( $_, 0, pos ) = "" if pos;
	}


=head2 How do I substitute case insensitively on the LHS while preserving case on the RHS?
X<replace, case preserving> X<substitute, case preserving>
X<substitution, case preserving> X<s, case preserving>

Here's a lovely Perlish solution by Larry Rosler.  It exploits
properties of bitwise xor on ASCII strings.

	$_= "this is a TEsT case";

	$old = 'test';
	$new = 'success';

	s{(\Q$old\E)}
	{ uc $new | (uc $1 ^ $1) .
		(uc(substr $1, -1) ^ substr $1, -1) x
		(length($new) - length $1)
	}egi;

	print;

And here it is as a subroutine, modeled after the above:

	sub preserve_case($$) {
		my ($old, $new) = @@_;
		my $mask = uc $old ^ $old;

		uc $new | $mask .
			substr($mask, -1) x (length($new) - length($old))
    }

	$string = "this is a TEsT case";
	$string =~ s/(test)/preserve_case($1, "success")/egi;
	print "$string\n";

This prints:

	this is a SUcCESS case

As an alternative, to keep the case of the replacement word if it is
longer than the original, you can use this code, by Jeff Pinyan:

	sub preserve_case {
		my ($from, $to) = @@_;
		my ($lf, $lt) = map length, @@_;

		if ($lt < $lf) { $from = substr $from, 0, $lt }
		else { $from .= substr $to, $lf }

		return uc $to | ($from ^ uc $from);
		}

This changes the sentence to "this is a SUcCess case."

Just to show that C programmers can write C in any programming language,
if you prefer a more C-like solution, the following script makes the
substitution have the same case, letter by letter, as the original.
(It also happens to run about 240% slower than the Perlish solution runs.)
If the substitution has more characters than the string being substituted,
the case of the last character is used for the rest of the substitution.

	# Original by Nathan Torkington, massaged by Jeffrey Friedl
	#
	sub preserve_case($$)
	{
		my ($old, $new) = @@_;
		my ($state) = 0; # 0 = no change; 1 = lc; 2 = uc
		my ($i, $oldlen, $newlen, $c) = (0, length($old), length($new));
		my ($len) = $oldlen < $newlen ? $oldlen : $newlen;

		for ($i = 0; $i < $len; $i++) {
			if ($c = substr($old, $i, 1), $c =~ /[\W\d_]/) {
				$state = 0;
			} elsif (lc $c eq $c) {
				substr($new, $i, 1) = lc(substr($new, $i, 1));
				$state = 1;
			} else {
				substr($new, $i, 1) = uc(substr($new, $i, 1));
				$state = 2;
			}
		}
		# finish up with any remaining new (for when new is longer than old)
		if ($newlen > $oldlen) {
			if ($state == 1) {
				substr($new, $oldlen) = lc(substr($new, $oldlen));
			} elsif ($state == 2) {
				substr($new, $oldlen) = uc(substr($new, $oldlen));
			}
		}
		return $new;
	}

=head2 How can I make C<\w> match national character sets?
X<\w>

Put C<use locale;> in your script.  The \w character class is taken
from the current locale.

See L<perllocale> for details.

=head2 How can I match a locale-smart version of C</[a-zA-Z]/>?
X<alpha>

You can use the POSIX character class syntax C</[[:alpha:]]/>
documented in L<perlre>.

No matter which locale you are in, the alphabetic characters are
the characters in \w without the digits and the underscore.
As a regex, that looks like C</[^\W\d_]/>.  Its complement,
the non-alphabetics, is then everything in \W along with
the digits and the underscore, or C</[\W\d_]/>.

=head2 How can I quote a variable to use in a regex?
X<regex, escaping> X<regexp, escaping> X<regular expression, escaping>

The Perl parser will expand $variable and @@variable references in
regular expressions unless the delimiter is a single quote.  Remember,
too, that the right-hand side of a C<s///> substitution is considered
a double-quoted string (see L<perlop> for more details).  Remember
also that any regex special characters will be acted on unless you
precede the substitution with \Q.  Here's an example:

	$string = "Placido P. Octopus";
	$regex  = "P.";

	$string =~ s/$regex/Polyp/;
	# $string is now "Polypacido P. Octopus"

Because C<.> is special in regular expressions, and can match any
single character, the regex C<P.> here has matched the <Pl> in the
original string.

To escape the special meaning of C<.>, we use C<\Q>:

	$string = "Placido P. Octopus";
	$regex  = "P.";

	$string =~ s/\Q$regex/Polyp/;
	# $string is now "Placido Polyp Octopus"

The use of C<\Q> causes the <.> in the regex to be treated as a
regular character, so that C<P.> matches a C<P> followed by a dot.

=head2 What is C</o> really for?
X</o, regular expressions> X<compile, regular expressions>

(contributed by brian d foy)

The C</o> option for regular expressions (documented in L<perlop> and
L<perlreref>) tells Perl to compile the regular expression only once.
This is only useful when the pattern contains a variable. Perls 5.6
and later handle this automatically if the pattern does not change.

Since the match operator C<m//>, the substitution operator C<s///>,
and the regular expression quoting operator C<qr//> are double-quotish
constructs, you can interpolate variables into the pattern. See the
answer to "How can I quote a variable to use in a regex?" for more
details.

This example takes a regular expression from the argument list and
prints the lines of input that match it:

	my $pattern = shift @@ARGV;

	while( <> ) {
		print if m/$pattern/;
		}

Versions of Perl prior to 5.6 would recompile the regular expression
for each iteration, even if C<$pattern> had not changed. The C</o>
would prevent this by telling Perl to compile the pattern the first
time, then reuse that for subsequent iterations:

	my $pattern = shift @@ARGV;

	while( <> ) {
		print if m/$pattern/o; # useful for Perl < 5.6
		}

In versions 5.6 and later, Perl won't recompile the regular expression
if the variable hasn't changed, so you probably don't need the C</o>
option. It doesn't hurt, but it doesn't help either. If you want any
version of Perl to compile the regular expression only once even if
the variable changes (thus, only using its initial value), you still
need the C</o>.

You can watch Perl's regular expression engine at work to verify for
yourself if Perl is recompiling a regular expression. The C<use re
'debug'> pragma (comes with Perl 5.005 and later) shows the details.
With Perls before 5.6, you should see C<re> reporting that its
compiling the regular expression on each iteration. With Perl 5.6 or
later, you should only see C<re> report that for the first iteration.

	use re 'debug';

	$regex = 'Perl';
	foreach ( qw(Perl Java Ruby Python) ) {
		print STDERR "-" x 73, "\n";
		print STDERR "Trying $_...\n";
		print STDERR "\t$_ is good!\n" if m/$regex/;
		}

=head2 How do I use a regular expression to strip C style comments from a file?

While this actually can be done, it's much harder than you'd think.
For example, this one-liner

	perl -0777 -pe 's{/\*.*?\*/}{}gs' foo.c

will work in many but not all cases.  You see, it's too simple-minded for
certain kinds of C programs, in particular, those with what appear to be
comments in quoted strings.  For that, you'd need something like this,
created by Jeffrey Friedl and later modified by Fred Curtis.

	$/ = undef;
	$_ = <>;
	s#/\*[^*]*\*+([^/*][^*]*\*+)*/|("(\\.|[^"\\])*"|'(\\.|[^'\\])*'|.[^/"'\\]*)#defined $2 ? $2 : ""#gse;
	print;

This could, of course, be more legibly written with the C</x> modifier, adding
whitespace and comments.  Here it is expanded, courtesy of Fred Curtis.

    s{
       /\*         ##  Start of /* ... */ comment
       [^*]*\*+    ##  Non-* followed by 1-or-more *'s
       (
         [^/*][^*]*\*+
       )*          ##  0-or-more things which don't start with /
                   ##    but do end with '*'
       /           ##  End of /* ... */ comment

     |         ##     OR  various things which aren't comments:

       (
         "           ##  Start of " ... " string
         (
           \\.           ##  Escaped char
         |               ##    OR
           [^"\\]        ##  Non "\
         )*
         "           ##  End of " ... " string

       |         ##     OR

         '           ##  Start of ' ... ' string
         (
           \\.           ##  Escaped char
         |               ##    OR
           [^'\\]        ##  Non '\
         )*
         '           ##  End of ' ... ' string

       |         ##     OR

         .           ##  Anything other char
         [^/"'\\]*   ##  Chars which doesn't start a comment, string or escape
       )
     }{defined $2 ? $2 : ""}gxse;

A slight modification also removes C++ comments, possibly spanning multiple lines
using a continuation character:

 s#/\*[^*]*\*+([^/*][^*]*\*+)*/|//([^\\]|[^\n][\n]?)*?\n|("(\\.|[^"\\])*"|'(\\.|[^'\\])*'|.[^/"'\\]*)#defined $3 ? $3 : ""#gse;

=head2 Can I use Perl regular expressions to match balanced text?
X<regex, matching balanced test> X<regexp, matching balanced test>
X<regular expression, matching balanced test> X<possessive> X<PARNO>
X<Text::Balanced> X<Regexp::Common> X<backtracking> X<recursion>

(contributed by brian d foy)

Your first try should probably be the C<Text::Balanced> module, which
is in the Perl standard library since Perl 5.8. It has a variety of
functions to deal with tricky text. The C<Regexp::Common> module can
also help by providing canned patterns you can use.

As of Perl 5.10, you can match balanced text with regular expressions
using recursive patterns. Before Perl 5.10, you had to resort to
various tricks such as using Perl code in C<(??{})> sequences.

Here's an example using a recursive regular expression. The goal is to
capture all of the text within angle brackets, including the text in
nested angle brackets. This sample text has two "major" groups: a
group with one level of nesting and a group with two levels of
nesting. There are five total groups in angle brackets:

	I have some <brackets in <nested brackets> > and
	<another group <nested once <nested twice> > >
	and that's it.

The regular expression to match the balanced text  uses two new (to
Perl 5.10) regular expression features. These are covered in L<perlre>
and this example is a modified version of one in that documentation.

First, adding the new possessive C<+> to any quantifier finds the
longest match and does not backtrack. That's important since you want
to handle any angle brackets through the recursion, not backtracking.
The group C<< [^<>]++ >> finds one or more non-angle brackets without
backtracking.

Second, the new C<(?PARNO)> refers to the sub-pattern in the
particular capture buffer given by C<PARNO>. In the following regex,
the first capture buffer finds (and remembers) the balanced text, and
you  need that same pattern within the first buffer to get past the
nested text. That's the recursive part. The C<(?1)> uses the pattern
in the outer capture buffer as an independent part of the regex.

Putting it all together, you have:

	#!/usr/local/bin/perl5.10.0

	my $string =<<"HERE";
	I have some <brackets in <nested brackets> > and
	<another group <nested once <nested twice> > >
	and that's it.
	HERE

	my @@groups = $string =~ m/
			(                   # start of capture buffer 1
			<                   # match an opening angle bracket
				(?:
					[^<>]++     # one or more non angle brackets, non backtracking
					  |
					(?1)        # found < or >, so recurse to capture buffer 1
				)*
			>                   # match a closing angle bracket
			)                   # end of capture buffer 1
			/xg;

	$" = "\n\t";
	print "Found:\n\t@@groups\n";

The output shows that Perl found the two major groups:

	Found:
		<brackets in <nested brackets> >
		<another group <nested once <nested twice> > >

With a little extra work, you can get the all of the groups in angle
brackets even if they are in other angle brackets too. Each time you
get a balanced match, remove its outer delimiter (that's the one you
just matched so don't match it again) and add it to a queue of strings
to process. Keep doing that until you get no matches:

	#!/usr/local/bin/perl5.10.0

	my @@queue =<<"HERE";
	I have some <brackets in <nested brackets> > and
	<another group <nested once <nested twice> > >
	and that's it.
	HERE

	my $regex = qr/
			(                   # start of bracket 1
			<                   # match an opening angle bracket
				(?:
					[^<>]++     # one or more non angle brackets, non backtracking
					  |
					(?1)        # recurse to bracket 1
				)*
			>                   # match a closing angle bracket
			)                   # end of bracket 1
			/x;

	$" = "\n\t";

	while( @@queue )
		{
		my $string = shift @@queue;

		my @@groups = $string =~ m/$regex/g;
		print "Found:\n\t@@groups\n\n" if @@groups;

		unshift @@queue, map { s/^<//; s/>$//; $_ } @@groups;
		}

The output shows all of the groups. The outermost matches show up
first and the nested matches so up later:

	Found:
		<brackets in <nested brackets> >
		<another group <nested once <nested twice> > >

	Found:
		<nested brackets>

	Found:
		<nested once <nested twice> >

	Found:
		<nested twice>

=head2 What does it mean that regexes are greedy?  How can I get around it?
X<greedy> X<greediness>

Most people mean that greedy regexes match as much as they can.
Technically speaking, it's actually the quantifiers (C<?>, C<*>, C<+>,
C<{}>) that are greedy rather than the whole pattern; Perl prefers local
greed and immediate gratification to overall greed.  To get non-greedy
versions of the same quantifiers, use (C<??>, C<*?>, C<+?>, C<{}?>).

An example:

	$s1 = $s2 = "I am very very cold";
	$s1 =~ s/ve.*y //;      # I am cold
	$s2 =~ s/ve.*?y //;     # I am very cold

Notice how the second substitution stopped matching as soon as it
encountered "y ".  The C<*?> quantifier effectively tells the regular
expression engine to find a match as quickly as possible and pass
control on to whatever is next in line, like you would if you were
playing hot potato.

=head2 How do I process each word on each line?
X<word>

Use the split function:

	while (<>) {
		foreach $word ( split ) {
			# do something with $word here
		}
	}

Note that this isn't really a word in the English sense; it's just
chunks of consecutive non-whitespace characters.

To work with only alphanumeric sequences (including underscores), you
might consider

	while (<>) {
		foreach $word (m/(\w+)/g) {
			# do something with $word here
		}
	}

=head2 How can I print out a word-frequency or line-frequency summary?

To do this, you have to parse out each word in the input stream.  We'll
pretend that by word you mean chunk of alphabetics, hyphens, or
apostrophes, rather than the non-whitespace chunk idea of a word given
in the previous question:

	while (<>) {
		while ( /(\b[^\W_\d][\w'-]+\b)/g ) {   # misses "`sheep'"
			$seen{$1}++;
		}
	}

	while ( ($word, $count) = each %seen ) {
		print "$count $word\n";
		}

If you wanted to do the same thing for lines, you wouldn't need a
regular expression:

	while (<>) {
		$seen{$_}++;
		}

	while ( ($line, $count) = each %seen ) {
		print "$count $line";
	}

If you want these output in a sorted order, see L<perlfaq4>: "How do I
sort a hash (optionally by value instead of key)?".

=head2 How can I do approximate matching?
X<match, approximate> X<matching, approximate>

See the module String::Approx available from CPAN.

=head2 How do I efficiently match many regular expressions at once?
X<regex, efficiency> X<regexp, efficiency>
X<regular expression, efficiency>

( contributed by brian d foy )

Avoid asking Perl to compile a regular expression every time
you want to match it. In this example, perl must recompile
the regular expression for every iteration of the C<foreach>
loop since it has no way to know what $pattern will be.

	@@patterns = qw( foo bar baz );

	LINE: while( <DATA> )
		{
		foreach $pattern ( @@patterns )
			{
			if( /\b$pattern\b/i )
				{
				print;
				next LINE;
				}
			}
		}

The C<qr//> operator showed up in perl 5.005.  It compiles a
regular expression, but doesn't apply it.  When you use the
pre-compiled version of the regex, perl does less work. In
this example, I inserted a C<map> to turn each pattern into
its pre-compiled form. The rest of the script is the same,
but faster.

	@@patterns = map { qr/\b$_\b/i } qw( foo bar baz );

	LINE: while( <> )
		{
		foreach $pattern ( @@patterns )
			{
			if( /$pattern/ )
				{
				print;
				next LINE;
				}
			}
		}

In some cases, you may be able to make several patterns into
a single regular expression. Beware of situations that require
backtracking though.

	$regex = join '|', qw( foo bar baz );

	LINE: while( <> )
		{
		print if /\b(?:$regex)\b/i;
		}

For more details on regular expression efficiency, see I<Mastering
Regular Expressions> by Jeffrey Freidl.  He explains how regular
expressions engine work and why some patterns are surprisingly
inefficient.  Once you understand how perl applies regular
expressions, you can tune them for individual situations.

=head2 Why don't word-boundary searches with C<\b> work for me?
X<\b>

(contributed by brian d foy)

Ensure that you know what \b really does: it's the boundary between a
word character, \w, and something that isn't a word character. That
thing that isn't a word character might be \W, but it can also be the
start or end of the string.

It's not (not!) the boundary between whitespace and non-whitespace,
and it's not the stuff between words we use to create sentences.

In regex speak, a word boundary (\b) is a "zero width assertion",
meaning that it doesn't represent a character in the string, but a
condition at a certain position.

For the regular expression, /\bPerl\b/, there has to be a word
boundary before the "P" and after the "l".  As long as something other
than a word character precedes the "P" and succeeds the "l", the
pattern will match. These strings match /\bPerl\b/.

	"Perl"    # no word char before P or after l
	"Perl "   # same as previous (space is not a word char)
	"'Perl'"  # the ' char is not a word char
	"Perl's"  # no word char before P, non-word char after "l"

These strings do not match /\bPerl\b/.

	"Perl_"   # _ is a word char!
	"Perler"  # no word char before P, but one after l

You don't have to use \b to match words though.  You can look for
non-word characters surrounded by word characters.  These strings
match the pattern /\b'\b/.

	"don't"   # the ' char is surrounded by "n" and "t"
	"qep'a'"  # the ' char is surrounded by "p" and "a"

These strings do not match /\b'\b/.

	"foo'"    # there is no word char after non-word '

You can also use the complement of \b, \B, to specify that there
should not be a word boundary.

In the pattern /\Bam\B/, there must be a word character before the "a"
and after the "m". These patterns match /\Bam\B/:

	"llama"   # "am" surrounded by word chars
	"Samuel"  # same

These strings do not match /\Bam\B/

	"Sam"      # no word boundary before "a", but one after "m"
	"I am Sam" # "am" surrounded by non-word chars


=head2 Why does using $&, $`, or $' slow my program down?
X<$MATCH> X<$&> X<$POSTMATCH> X<$'> X<$PREMATCH> X<$`>

(contributed by Anno Siegel)

Once Perl sees that you need one of these variables anywhere in the
program, it provides them on each and every pattern match. That means
that on every pattern match the entire string will be copied, part of it
to $`, part to $&, and part to $'. Thus the penalty is most severe with
long strings and patterns that match often. Avoid $&, $', and $` if you
can, but if you can't, once you've used them at all, use them at will
because you've already paid the price. Remember that some algorithms
really appreciate them. As of the 5.005 release, the $& variable is no
longer "expensive" the way the other two are.

Since Perl 5.6.1 the special variables @@- and @@+ can functionally replace
$`, $& and $'.  These arrays contain pointers to the beginning and end
of each match (see perlvar for the full story), so they give you
essentially the same information, but without the risk of excessive
string copying.

Perl 5.10 added three specials, C<${^MATCH}>, C<${^PREMATCH}>, and
C<${^POSTMATCH}> to do the same job but without the global performance
penalty. Perl 5.10 only sets these variables if you compile or execute the
regular expression with the C</p> modifier.

=head2 What good is C<\G> in a regular expression?
X<\G>

You use the C<\G> anchor to start the next match on the same
string where the last match left off.  The regular
expression engine cannot skip over any characters to find
the next match with this anchor, so C<\G> is similar to the
beginning of string anchor, C<^>.  The C<\G> anchor is typically
used with the C<g> flag.  It uses the value of C<pos()>
as the position to start the next match.  As the match
operator makes successive matches, it updates C<pos()> with the
position of the next character past the last match (or the
first character of the next match, depending on how you like
to look at it). Each string has its own C<pos()> value.

Suppose you want to match all of consecutive pairs of digits
in a string like "1122a44" and stop matching when you
encounter non-digits.  You want to match C<11> and C<22> but
the letter <a> shows up between C<22> and C<44> and you want
to stop at C<a>. Simply matching pairs of digits skips over
the C<a> and still matches C<44>.

	$_ = "1122a44";
	my @@pairs = m/(\d\d)/g;   # qw( 11 22 44 )

If you use the C<\G> anchor, you force the match after C<22> to
start with the C<a>.  The regular expression cannot match
there since it does not find a digit, so the next match
fails and the match operator returns the pairs it already
found.

	$_ = "1122a44";
	my @@pairs = m/\G(\d\d)/g; # qw( 11 22 )

You can also use the C<\G> anchor in scalar context. You
still need the C<g> flag.

	$_ = "1122a44";
	while( m/\G(\d\d)/g )
		{
		print "Found $1\n";
		}

After the match fails at the letter C<a>, perl resets C<pos()>
and the next match on the same string starts at the beginning.

	$_ = "1122a44";
	while( m/\G(\d\d)/g )
		{
		print "Found $1\n";
		}

	print "Found $1 after while" if m/(\d\d)/g; # finds "11"

You can disable C<pos()> resets on fail with the C<c> flag, documented
in L<perlop> and L<perlreref>. Subsequent matches start where the last
successful match ended (the value of C<pos()>) even if a match on the
same string has failed in the meantime. In this case, the match after
the C<while()> loop starts at the C<a> (where the last match stopped),
and since it does not use any anchor it can skip over the C<a> to find
C<44>.

	$_ = "1122a44";
	while( m/\G(\d\d)/gc )
		{
		print "Found $1\n";
		}

	print "Found $1 after while" if m/(\d\d)/g; # finds "44"

Typically you use the C<\G> anchor with the C<c> flag
when you want to try a different match if one fails,
such as in a tokenizer. Jeffrey Friedl offers this example
which works in 5.004 or later.

	while (<>) {
		chomp;
		PARSER: {
			m/ \G( \d+\b    )/gcx   && do { print "number: $1\n";  redo; };
			m/ \G( \w+      )/gcx   && do { print "word:   $1\n";  redo; };
			m/ \G( \s+      )/gcx   && do { print "space:  $1\n";  redo; };
			m/ \G( [^\w\d]+ )/gcx   && do { print "other:  $1\n";  redo; };
		}
	}

For each line, the C<PARSER> loop first tries to match a series
of digits followed by a word boundary.  This match has to
start at the place the last match left off (or the beginning
of the string on the first match). Since C<m/ \G( \d+\b
)/gcx> uses the C<c> flag, if the string does not match that
regular expression, perl does not reset pos() and the next
match starts at the same position to try a different
pattern.

=head2 Are Perl regexes DFAs or NFAs?  Are they POSIX compliant?
X<DFA> X<NFA> X<POSIX>

While it's true that Perl's regular expressions resemble the DFAs
(deterministic finite automata) of the egrep(1) program, they are in
fact implemented as NFAs (non-deterministic finite automata) to allow
backtracking and backreferencing.  And they aren't POSIX-style either,
because those guarantee worst-case behavior for all cases.  (It seems
that some people prefer guarantees of consistency, even when what's
guaranteed is slowness.)  See the book "Mastering Regular Expressions"
(from O'Reilly) by Jeffrey Friedl for all the details you could ever
hope to know on these matters (a full citation appears in
L<perlfaq2>).

=head2 What's wrong with using grep in a void context?
X<grep>

The problem is that grep builds a return list, regardless of the context.
This means you're making Perl go to the trouble of building a list that
you then just throw away. If the list is large, you waste both time and space.
If your intent is to iterate over the list, then use a for loop for this
purpose.

In perls older than 5.8.1, map suffers from this problem as well.
But since 5.8.1, this has been fixed, and map is context aware - in void
context, no lists are constructed.

=head2 How can I match strings with multibyte characters?
X<regex, and multibyte characters> X<regexp, and multibyte characters>
X<regular expression, and multibyte characters> X<martian> X<encoding, Martian>

Starting from Perl 5.6 Perl has had some level of multibyte character
support.  Perl 5.8 or later is recommended.  Supported multibyte
character repertoires include Unicode, and legacy encodings
through the Encode module.  See L<perluniintro>, L<perlunicode>,
and L<Encode>.

If you are stuck with older Perls, you can do Unicode with the
C<Unicode::String> module, and character conversions using the
C<Unicode::Map8> and C<Unicode::Map> modules.  If you are using
Japanese encodings, you might try using the jperl 5.005_03.

Finally, the following set of approaches was offered by Jeffrey
Friedl, whose article in issue #5 of The Perl Journal talks about
this very matter.

Let's suppose you have some weird Martian encoding where pairs of
ASCII uppercase letters encode single Martian letters (i.e. the two
bytes "CV" make a single Martian letter, as do the two bytes "SG",
"VS", "XX", etc.). Other bytes represent single characters, just like
ASCII.

So, the string of Martian "I am CVSGXX!" uses 12 bytes to encode the
nine characters 'I', ' ', 'a', 'm', ' ', 'CV', 'SG', 'XX', '!'.

Now, say you want to search for the single character C</GX/>. Perl
doesn't know about Martian, so it'll find the two bytes "GX" in the "I
am CVSGXX!"  string, even though that character isn't there: it just
looks like it is because "SG" is next to "XX", but there's no real
"GX".  This is a big problem.

Here are a few ways, all painful, to deal with it:

	# Make sure adjacent "martian" bytes are no longer adjacent.
	$martian =~ s/([A-Z][A-Z])/ $1 /g;

	print "found GX!\n" if $martian =~ /GX/;

Or like this:

	@@chars = $martian =~ m/([A-Z][A-Z]|[^A-Z])/g;
	# above is conceptually similar to:     @@chars = $text =~ m/(.)/g;
	#
	foreach $char (@@chars) {
	print "found GX!\n", last if $char eq 'GX';
	}

Or like this:

	while ($martian =~ m/\G([A-Z][A-Z]|.)/gs) {  # \G probably unneeded
		print "found GX!\n", last if $1 eq 'GX';
		}

Here's another, slightly less painful, way to do it from Benjamin
Goldberg, who uses a zero-width negative look-behind assertion.

	print "found GX!\n" if	$martian =~ m/
		(?<![A-Z])
		(?:[A-Z][A-Z])*?
		GX
		/x;

This succeeds if the "martian" character GX is in the string, and fails
otherwise.  If you don't like using (?<!), a zero-width negative
look-behind assertion, you can replace (?<![A-Z]) with (?:^|[^A-Z]).

It does have the drawback of putting the wrong thing in $-[0] and $+[0],
but this usually can be worked around.

=head2 How do I match a regular expression that's in a variable?
X<regex, in variable> X<eval> X<regex> X<quotemeta> X<\Q, regex>
X<\E, regex>, X<qr//>

(contributed by brian d foy)

We don't have to hard-code patterns into the match operator (or
anything else that works with regular expressions). We can put the
pattern in a variable for later use.

The match operator is a double quote context, so you can interpolate
your variable just like a double quoted string. In this case, you
read the regular expression as user input and store it in C<$regex>.
Once you have the pattern in C<$regex>, you use that variable in the
match operator.

	chomp( my $regex = <STDIN> );

	if( $string =~ m/$regex/ ) { ... }

Any regular expression special characters in C<$regex> are still
special, and the pattern still has to be valid or Perl will complain.
For instance, in this pattern there is an unpaired parenthesis.

	my $regex = "Unmatched ( paren";

	"Two parens to bind them all" =~ m/$regex/;

When Perl compiles the regular expression, it treats the parenthesis
as the start of a memory match. When it doesn't find the closing
parenthesis, it complains:

	Unmatched ( in regex; marked by <-- HERE in m/Unmatched ( <-- HERE  paren/ at script line 3.

You can get around this in several ways depending on our situation.
First, if you don't want any of the characters in the string to be
special, you can escape them with C<quotemeta> before you use the string.

	chomp( my $regex = <STDIN> );
	$regex = quotemeta( $regex );

	if( $string =~ m/$regex/ ) { ... }

You can also do this directly in the match operator using the C<\Q>
and C<\E> sequences. The C<\Q> tells Perl where to start escaping
special characters, and the C<\E> tells it where to stop (see L<perlop>
for more details).

	chomp( my $regex = <STDIN> );

	if( $string =~ m/\Q$regex\E/ ) { ... }

Alternately, you can use C<qr//>, the regular expression quote operator (see
L<perlop> for more details).  It quotes and perhaps compiles the pattern,
and you can apply regular expression flags to the pattern.

	chomp( my $input = <STDIN> );

	my $regex = qr/$input/is;

	$string =~ m/$regex/  # same as m/$input/is;

You might also want to trap any errors by wrapping an C<eval> block
around the whole thing.

	chomp( my $input = <STDIN> );

	eval {
		if( $string =~ m/\Q$input\E/ ) { ... }
		};
	warn $@@ if $@@;

Or...

	my $regex = eval { qr/$input/is };
	if( defined $regex ) {
		$string =~ m/$regex/;
		}
	else {
		warn $@@;
		}

=head1 AUTHOR AND COPYRIGHT

Copyright (c) 1997-2010 Tom Christiansen, Nathan Torkington, and
other authors as noted. All rights reserved.

This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.

Irrespective of its distribution, all code examples in this file
are hereby placed into the public domain.  You are permitted and
encouraged to use this code in your own programs for fun
or for profit as you see fit.  A simple comment in the code giving
credit would be courteous but is not required.
@


1.11
log
@merge in perl 5.12.2 plus local changes
@
text
@@


1.10
log
@Merge in perl 5.10.1
@
text
@d36 3
a38 3
(except in a character class), and also allows you to use normal
comments there, too.  As you can imagine, whitespace and comments help
a lot.
d172 1
a172 1
toward a right answer but constantly being disappointed, beseiged by
d531 1
a531 1
First, adding the new possesive C<+> to any quantifier finds the
d716 1
a716 1
you want to match it.  In this example, perl must recompile
d738 1
a738 1
its pre-compiled form.  The rest of the script is the same,
d756 1
a756 1
a single regular expression.  Beware of situations that require
a1130 8
=head1 REVISION

Revision: $Revision$

Date: $Date$

See L<perlfaq> for source control details and availability.

d1133 1
a1133 1
Copyright (c) 1997-2009 Tom Christiansen, Nathan Torkington, and
@


1.9
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d100 1
a100 1
	$/ = '';  		# read in more whole paragraph, not just one line
d110 1
a110 1
	$/ = '';  		# read in more whole paragraph, not just one line
d152 41
d197 1
a197 1
$/ has to be a string.  You can use these examples if you really need to 
d213 1
a213 1
You can use the four argument form of sysread to continually add to
d219 1
a219 1
		while( s/^((?s).*?)your_pattern/ ) {
d225 3
a227 3
 You can do the same thing with foreach and a match using the
 c flag and the \G anchor, if you do not mind your entire file
 being in memory at the end.
d268 3
a270 3
	$a = "this is a TEsT case";
	$a =~ s/(test)/preserve_case($1, "success")/egi;
	print "$a\n";
d400 1
a400 1
	
d411 1
a411 1
	
d431 1
a431 1
	
d496 2
a497 2
A slight modification also removes C++ comments, as long as they are not
spread over multiple lines using a continuation character):
d499 1
a499 1
	s#/\*[^*]*\*+([^/*][^*]*\*+)*/|//[^\n]*|("(\\.|[^"\\])*"|'(\\.|[^'\\])*'|.[^/"'\\]*)#defined $2 ? $2 : ""#gse;
d503 2
a504 1
X<regular expression, matching balanced test>
d506 109
a614 22
Historically, Perl regular expressions were not capable of matching
balanced text.  As of more recent versions of perl including 5.6.1
experimental features have been added that make it possible to do this.
Look at the documentation for the (??{ }) construct in recent perlre manual
pages to see an example of matching balanced parentheses.  Be sure to take
special notice of the  warnings present in the manual before making use
of this feature.

CPAN contains many modules that can be useful for matching text
depending on the context.  Damian Conway provides some useful
patterns in Regexp::Common.  The module Text::Balanced provides a
general solution to this problem.

One of the common applications of balanced text matching is working
with XML and HTML.  There are many modules available that support
these needs.  Two examples are HTML::Parser and XML::Parser. There
are many others.

An elaborate subroutine (for 7-bit ASCII only) to pull out balanced
and possibly nested single chars, like C<`> and C<'>, C<{> and C<}>,
or C<(> and C<)> can be found in
http://www.cpan.org/authors/id/TOMC/scripts/pull_quotes.gz .
d616 12
a627 2
The C::Scan module from CPAN also contains such subs for internal use,
but they are undocumented.
d717 1
a717 1
the regular expression for every iteration of the foreach()
d734 1
a734 1
The qr// operator showed up in perl 5.005.  It compiles a
d737 1
a737 1
this example, I inserted a map() to turn each pattern into
d747 5
a751 2
			print if /$pattern/i;
			next LINE;
d766 2
a767 2
For more details on regular expression efficiency, see Mastering
Regular Expressions by Jeffrey Freidl.  He explains how regular
d851 5
d1133 1
a1133 1
Revision: $Revision: 10126 $
d1135 1
a1135 1
Date: $Date: 2007-10-27 21:29:20 +0200 (Sat, 27 Oct 2007) $
d1141 1
a1141 1
Copyright (c) 1997-2007 Tom Christiansen, Nathan Torkington, and
@


1.8
log
@merge in perl 5.8.8
@
text
@d29 3
a31 3
    # turn the line into the first word, a colon, and the
    # number of characters on the rest of the line
    s/^(\w+)(.*)/ lc($1) . ":" . length($2) /meg;
d42 1
a42 1
    s{<(?:[^>'"]*|".*?"|'.*?')+>}{}gs;
d46 10
a55 10
    s{ <                    # opening angle bracket
        (?:                 # Non-backreffing grouping paren
             [^>'"] *       # 0 or more things that are neither > nor ' nor "
                |           #    or else
             ".*?"          # a section between double quotes (stingy match)
                |           #    or else
             '.*?'          # a section between single quotes (stingy match)
        ) +                 #   all occurring one or more times
       >                    # closing angle bracket
    }{}gsx;                 # replace with nothing, i.e. delete
d68 2
a69 2
    s/\/usr\/local/\/usr\/share/g;	# bad delimiter choice
    s#/usr/local#/usr/share#g;		# better
d100 5
a104 4
    $/ = '';  		# read in more whole paragraph, not just one line
    while ( <> ) {
	while ( /\b([\w'-]+)(\s+\1)+\b/gi ) {  	# word starts alpha
	    print "Duplicate $1 at paragraph $.\n";
a105 1
    }
d110 5
a114 4
    $/ = '';  		# read in more whole paragraph, not just one line
    while ( <> ) {
	while ( /^From /gm ) { # /m makes ^ match next to \n
	    print "leading from in paragraph $.\n";
a115 1
    }
d119 5
a123 4
    undef $/;  		# read in whole file, not just one line or paragraph
    while ( <> ) {
	while ( /START(.*?)END/sgm ) { # /s makes . cross line boundaries
	    print "$1\n";
a124 1
    }
d132 1
a132 1
    perl -ne 'print if /START/ .. /END/' file1 file2 ...
d136 1
a136 1
    perl -0777 -ne 'print "$1\n" while /START(.*?)END/gs' file1 file2 ...
d144 3
a146 3
    while (<>) {
        $in_header =   1  .. /^$/;
        $in_body   = /^$/ .. eof();
d148 3
a150 3
    } continue {
	reset if eof();		# fix $.
    }
d156 2
a157 3
Up to Perl 5.8.0, $/ has to be a string.  This may change in 5.10,
but don't get your hopes up. Until then, you can use these examples
if you really need to do this.
d161 1
a161 5
			 use File::Stream;
             my $stream = File::Stream->new(
                  $filehandle,
                  separator => qr/\s*,\s*/,
                  );
d163 6
a168 1
			 print "$_\n" while <$stream>;
d176 7
a182 7
       local $_ = "";
       while( sysread FH, $_, 8192, length ) {
          while( s/^((?s).*?)your_pattern/ ) {
             my $record = $1;
             # do stuff here.
          }
       }
d188 7
a194 7
       local $_ = "";
       while( sysread FH, $_, 8192, length ) {
          foreach my $record ( m/\G((?s).*?)your_pattern/gc ) {
             # do stuff here.
          }
          substr( $_, 0, pos ) = "" if pos;
       }
d204 1
a204 1
    $_= "this is a TEsT case";
d206 2
a207 2
    $old = 'test';
    $new = 'success';
d209 5
a213 5
    s{(\Q$old\E)}
     { uc $new | (uc $1 ^ $1) .
	(uc(substr $1, -1) ^ substr $1, -1) x
	    (length($new) - length $1)
     }egi;
d215 1
a215 1
    print;
d219 3
a221 3
    sub preserve_case($$) {
	my ($old, $new) = @@_;
	my $mask = uc $old ^ $old;
d223 2
a224 2
	uc $new | $mask .
	    substr($mask, -1) x (length($new) - length($old))
d227 3
a229 3
    $a = "this is a TEsT case";
    $a =~ s/(test)/preserve_case($1, "success")/egi;
    print "$a\n";
d233 1
a233 1
    this is a SUcCESS case
d238 3
a240 3
  sub preserve_case {
    my ($from, $to) = @@_;
    my ($lf, $lt) = map length, @@_;
d242 2
a243 2
    if ($lt < $lf) { $from = substr $from, 0, $lt }
    else { $from .= substr $to, $lf }
d245 2
a246 2
    return uc $to | ($from ^ uc $from);
  }
d257 30
a286 30
    # Original by Nathan Torkington, massaged by Jeffrey Friedl
    #
    sub preserve_case($$)
    {
        my ($old, $new) = @@_;
        my ($state) = 0; # 0 = no change; 1 = lc; 2 = uc
        my ($i, $oldlen, $newlen, $c) = (0, length($old), length($new));
        my ($len) = $oldlen < $newlen ? $oldlen : $newlen;

        for ($i = 0; $i < $len; $i++) {
            if ($c = substr($old, $i, 1), $c =~ /[\W\d_]/) {
                $state = 0;
            } elsif (lc $c eq $c) {
                substr($new, $i, 1) = lc(substr($new, $i, 1));
                $state = 1;
            } else {
                substr($new, $i, 1) = uc(substr($new, $i, 1));
                $state = 2;
            }
        }
        # finish up with any remaining new (for when new is longer than old)
        if ($newlen > $oldlen) {
            if ($state == 1) {
                substr($new, $oldlen) = lc(substr($new, $oldlen));
            } elsif ($state == 2) {
                substr($new, $oldlen) = uc(substr($new, $oldlen));
            }
        }
        return $new;
    }
d318 2
a319 2
    $string = "Placido P. Octopus";
    $regex  = "P.";
d321 2
a322 2
    $string =~ s/$regex/Polyp/;
    # $string is now "Polypacido P. Octopus"
d330 2
a331 2
    $string = "Placido P. Octopus";
    $regex  = "P.";
d333 2
a334 2
    $string =~ s/\Q$regex/Polyp/;
    # $string is now "Placido Polyp Octopus"
d340 34
a373 1
X</o>
d375 22
a396 24
Using a variable in a regular expression match forces a re-evaluation
(and perhaps recompilation) each time the regular expression is
encountered.  The C</o> modifier locks in the regex the first time
it's used.  This always happens in a constant regular expression, and
in fact, the pattern was compiled into the internal format at the same
time your entire program was.

Use of C</o> is irrelevant unless variable interpolation is used in
the pattern, and if so, the regex engine will neither know nor care
whether the variables change after the pattern is evaluated the I<very
first> time.

C</o> is often used to gain an extra measure of efficiency by not
performing subsequent evaluations when you know it won't matter
(because you know the variables won't change), or more rarely, when
you don't want the regex to notice if they do.

For example, here's a "paragrep" program:

    $/ = '';  # paragraph mode
    $pat = shift;
    while (<>) {
        print if /$pat/o;
    }
d403 1
a403 1
    perl -0777 -pe 's{/\*.*?\*/}{}gs' foo.c
d410 4
a413 4
    $/ = undef;
    $_ = <>;
    s#/\*[^*]*\*+([^/*][^*]*\*+)*/|("(\\.|[^"\\])*"|'(\\.|[^'\\])*'|.[^/"'\\]*)#defined $2 ? $2 : ""#gse;
    print;
d455 2
a456 1
A slight modification also removes C++ comments:
d458 1
a458 1
    s#/\*[^*]*\*+([^/*][^*]*\*+)*/|//[^\n]*|("(\\.|[^"\\])*"|'(\\.|[^'\\])*'|.[^/"'\\]*)#defined $2 ? $2 : ""#gse;
d501 3
a503 3
        $s1 = $s2 = "I am very very cold";
        $s1 =~ s/ve.*y //;      # I am cold
        $s2 =~ s/ve.*?y //;     # I am very cold
d516 4
a519 3
    while (<>) {
	foreach $word ( split ) {
	    # do something with $word here
a520 1
    }
d528 4
a531 3
    while (<>) {
	foreach $word (m/(\w+)/g) {
	    # do something with $word here
a532 1
    }
d541 4
a544 3
    while (<>) {
	while ( /(\b[^\W_\d][\w'-]+\b)/g ) {   # misses "`sheep'"
	    $seen{$1}++;
d546 4
a549 4
    }
    while ( ($word, $count) = each %seen ) {
	print "$count $word\n";
    }
d554 7
a560 6
    while (<>) {
	$seen{$_}++;
    }
    while ( ($line, $count) = each %seen ) {
	print "$count $line";
    }
d581 1
a581 1
    @@patterns = qw( foo bar baz );
d583 2
a584 2
    LINE: while( <> )
    	{
d587 6
a592 3
	    	print if /\b$pattern\b/i;
	    	next LINE;
	   		}
d602 1
a602 1
    @@patterns = map { qr/\b$_\b/i } qw( foo bar baz );
d604 2
a605 2
    LINE: while( <> )
    	{
d608 3
a610 3
	    	print if /\b$pattern\b/i;
	    	next LINE;
	   		}
d619 2
a620 2
    LINE: while( <> )
    	{
d717 1
a717 1
used with the C<g> flag.  It uses the value of pos()
d719 1
a719 1
operator makes successive matches, it updates pos() with the
d722 1
a722 1
to look at it). Each string has its own pos() value.
d724 1
a724 1
Suppose you want to match all of consective pairs of digits
d734 1
a734 1
If you use the \G anchor, you force the match after C<22> to
d752 1
a752 1
After the match fails at the letter C<a>, perl resets pos()
d763 7
a769 7
You can disable pos() resets on fail with the C<c> flag.
Subsequent matches start where the last successful match
ended (the value of pos()) even if a match on the same
string as failed in the meantime. In this case, the match
after the while() loop starts at the C<a> (where the last
match stopped), and since it does not use any anchor it can
skip over the C<a> to find "44".
d784 9
a792 9
    while (<>) {
      chomp;
      PARSER: {
           m/ \G( \d+\b    )/gcx   && do { print "number: $1\n";  redo; };
           m/ \G( \w+      )/gcx   && do { print "word:   $1\n";  redo; };
           m/ \G( \s+      )/gcx   && do { print "space:  $1\n";  redo; };
           m/ \G( [^\w\d]+ )/gcx   && do { print "other:  $1\n";  redo; };
      }
    }
d794 1
a794 1
For each line, the PARSER loop first tries to match a series
d832 1
a832 1
X<regular expression, and multibyte characters>
d866 4
a869 3
   $martian =~ s/([A-Z][A-Z])/ $1 /g; # Make sure adjacent "martian"
                                      # bytes are no longer adjacent.
   print "found GX!\n" if $martian =~ /GX/;
d873 6
a878 6
   @@chars = $martian =~ m/([A-Z][A-Z]|[^A-Z])/g;
   # above is conceptually similar to:     @@chars = $text =~ m/(.)/g;
   #
   foreach $char (@@chars) {
       print "found GX!\n", last if $char eq 'GX';
   }
d882 3
a884 3
   while ($martian =~ m/\G([A-Z][A-Z]|.)/gs) {  # \G probably unneeded
       print "found GX!\n", last if $1 eq 'GX';
   }
d890 3
a892 3
		   (?<![A-Z])
		   (?:[A-Z][A-Z])*?
		   GX
d902 25
a926 1
=head2 How do I match a pattern that is supplied by the user?
d928 1
a928 1
Well, if it's really a pattern, then just use
d930 3
a932 2
    chomp($pattern = <STDIN>);
    if ($line =~ /$pattern/) { }
d934 1
a934 2
Alternatively, since you have no guarantee that your user entered
a valid regular expression, trap the exception this way:
d936 3
a938 1
    if (eval { $line =~ /$pattern/ }) { }
d940 2
a941 5
If all you really want is to search for a string, not a pattern,
then you should either use the index() function, which is made for
string searching, or, if you can't be disabused of using a pattern
match on a non-pattern, then be sure to use C<\Q>...C<\E>, documented
in L<perlre>.
d943 1
a943 1
    $pattern = <STDIN>;
d945 46
a990 5
    open (FILE, $input) or die "Couldn't open input $input: $!; aborting";
    while (<FILE>) {
	print if /\Q$pattern\E/;
    }
    close FILE;
d994 1
a994 1
Copyright (c) 1997-2006 Tom Christiansen, Nathan Torkington, and
@


1.7
log
@sync in-tree perl with 5.8.6
@
text
@d3 1
a3 1
perlfaq6 - Regular Expressions ($Revision: 1.6 $, $Date: 2003/12/03 03:02:44 $)
d11 3
a13 3
this document (in L<perlfaq9>: ``How do I decode or create those %-encodings
on the web'' and L<perlfaq4>: ``How do I determine whether a scalar is
a number/whole/integer/float'', to be precise).
d16 2
d74 1
d127 1
d153 2
d198 2
d289 1
d297 1
d309 1
d340 1
d429 2
d459 1
d480 1
d528 2
a529 2
If you want these output in a sorted order, see L<perlfaq4>: ``How do I
sort a hash (optionally by value instead of key)?''.
d532 1
d537 2
d540 1
a540 1
The following is extremely inefficient:
d542 44
a585 10
    # slow but obvious way
    @@popstates = qw(CO ON MI WI MN);
    while (defined($line = <>)) {
	for $state (@@popstates) {
	    if ($line =~ /\b$state\b/i) {
		print $line;
		last;
	    }
	}
    }
d587 5
a591 13
That's because Perl has to recompile all those patterns for each of
the lines of the file.  As of the 5.005 release, there's a much better
approach, one which makes use of the new C<qr//> operator:

    # use spiffy new qr// operator, with /i flag even
    use 5.005;
    @@popstates = qw(CO ON MI WI MN);
    @@poppats   = map { qr/\b$_\b/i } @@popstates;
    while (defined($line = <>)) {
	for $patobj (@@poppats) {
	    print $line if $line =~ /$patobj/;
	}
    }
d594 55
a649 24
Two common misconceptions are that C<\b> is a synonym for C<\s+> and
that it's the edge between whitespace characters and non-whitespace
characters.  Neither is correct.  C<\b> is the place between a C<\w>
character and a C<\W> character (that is, C<\b> is the edge of a
"word").  It's a zero-width assertion, just like C<^>, C<$>, and all
the other anchors, so it doesn't consume any characters.  L<perlre>
describes the behavior of all the regex metacharacters.

Here are examples of the incorrect application of C<\b>, with fixes:

    "two words" =~ /(\w+)\b(\w+)/;	    # WRONG
    "two words" =~ /(\w+)\s+(\w+)/;	    # right

    " =matchless= text" =~ /\b=(\w+)=\b/;   # WRONG
    " =matchless= text" =~ /=(\w+)=/;       # right

Although they may not do what you thought they did, C<\b> and C<\B>
can still be quite useful.  For an example of the correct use of
C<\b>, see the example of matching duplicate words over multiple
lines.

An example of using C<\B> is the pattern C<\Bis\B>.  This will find
occurrences of "is" on the insides of words only, as in "thistle", but
not "this" or "island".
d652 3
d656 15
a670 10
Once Perl sees that you need one of these variables anywhere in
the program, it provides them on each and every pattern match.
The same mechanism that handles these provides for the use of $1, $2,
etc., so you pay the same price for each regex that contains capturing
parentheses.  If you never use $&, etc., in your script, then regexes
I<without> capturing parentheses won't be penalized. So avoid $&, $',
and $` if you can, but if you can't, once you've used them at all, use
them at will because you've already paid the price.  Remember that some
algorithms really appreciate them.  As of the 5.005 release.  the $&
variable is no longer "expensive" the way the other two are.
d673 1
d767 1
d781 1
d794 2
d829 1
a829 1
   $martian =~ s/([A-Z][A-Z])/ $1 /g; # Make sure adjacent ``martian''
d876 1
a876 1
If all you really want to search for a string, not a pattern,
d878 1
a878 1
string searching, or if you can't be disabused of using a pattern
d892 2
a893 2
Copyright (c) 1997-2002 Tom Christiansen and Nathan Torkington.
All rights reserved.
@


1.6
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d3 1
a3 1
perlfaq6 - Regular Expressions ($Revision: 1.20 $, $Date: 2003/01/03 20:05:28 $)
d154 13
a166 1
Use the four argument form of sysread to continually add to
d369 1
a369 1
    s#/\*[^*]*\*+([^/*][^*]*\*+)*/|("(\\.|[^"\\])*"|'(\\.|[^'\\])*'|.[^/"'\\]*)#$2#gs
d410 1
a410 1
     }{$2}gxs;
d414 1
a414 1
    s#/\*[^*]*\*+([^/*][^*]*\*+)*/|//[^\n]*|("(\\.|[^"\\])*"|'(\\.|[^'\\])*'|.[^/"'\\]*)#$2#gs;
d760 1
a760 1
Goldberg:
d762 5
a766 5
	$martian =~ m/
	   (?!<[A-Z])
	   (?:[A-Z][A-Z])*?
	   GX
	/x;
d769 2
a770 2
otherwise.  If you don't like using (?!<), you can replace (?!<[A-Z])
with (?:^|[^A-Z]).
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 1
a3 1
perlfaq6 - Regular Expressions ($Revision: 1.12 $, $Date: 2002/06/01 22:31:09 $)
d11 1
a11 1
this document (in L<perlfaq9>: ``How do I decode or create those %-encodings 
d146 1
a146 1
    } 
d150 27
a176 8
$/ must be a string, not a regular expression.  Awk has to be better
for something. :-)

Actually, you could do this if you don't mind reading the whole file
into memory:

    undef $/;
    @@records = split /your_pattern/, <FH>;
a177 19
The Net::Telnet module (available from CPAN) has the capability to
wait for a pattern in the input stream, or timeout if it doesn't
appear within a certain time.

    ## Create a file with three lines.
    open FH, ">file";
    print FH "The first line\nThe second line\nThe third line\n";
    close FH;

    ## Get a read/write filehandle to it.
    $fh = new IO::File "+<file";

    ## Attach it to a "stream" object.
    use Net::Telnet;
    $file = new Net::Telnet (-fhopen => $fh);

    ## Search for the second line and print out the third.
    $file->waitfor('/second line\n/');
    print $file->getline;
d204 1
a204 1
	    substr($mask, -1) x (length($new) - length($old))        
d270 4
a273 1
See L<perllocale>.
d277 8
a284 3
One alphabetic character would be C</[^\W\d_]/>, no matter what locale
you're in.  Non-alphabetics would be C</[\W\d_]/> (assuming you don't
consider an underscore a letter).
d295 5
a299 3
    $string = "to die?";
    $lhs = "die?";
    $rhs = "sleep, no more";
d301 3
a303 2
    $string =~ s/\Q$lhs/$rhs/;
    # $string is now "to sleep no more"
d305 10
a314 1
Without the \Q, the regex would also spuriously match "di".
d457 1
a457 1
	foreach $word ( split ) { 
d459 1
a459 1
	} 
d493 1
a493 1
    while (<>) { 
d515 1
a515 1
	    if ($line =~ /\b$state\b/i) {  
d520 1
a520 1
    }                                        
d578 71
a648 39
The notation C<\G> is used in a match or substitution in conjunction with
the C</g> modifier to anchor the regular expression to the point just past
where the last match occurred, i.e. the pos() point.  A failed match resets
the position of C<\G> unless the C</c> modifier is in effect. C<\G> can be
used in a match without the C</g> modifier; it acts the same (i.e. still
anchors at the pos() point) but of course only matches once and does not
update pos(), as non-C</g> expressions never do. C<\G> in an expression
applied to a target string that has never been matched against a C</g>
expression before or has had its pos() reset is functionally equivalent to
C<\A>, which matches at the beginning of the string.

For example, suppose you had a line of text quoted in standard mail
and Usenet notation, (that is, with leading C<< > >> characters), and
you want change each leading C<< > >> into a corresponding C<:>.  You
could do so in this way:

     s/^(>+)/':' x length($1)/gem;

Or, using C<\G>, the much simpler (and faster):

    s/\G>/:/g;

A more sophisticated use might involve a tokenizer.  The following
lex-like example is courtesy of Jeffrey Friedl.  It did not work in
5.003 due to bugs in that release, but does work in 5.004 or better.
(Note the use of C</c>, which prevents a failed match with C</g> from
resetting the search position back to the beginning of the string.)

    while (<>) {
      chomp;
      PARSER: {
           m/ \G( \d+\b    )/gcx    && do { print "number: $1\n";  redo; };
           m/ \G( \w+      )/gcx    && do { print "word:   $1\n";  redo; };
           m/ \G( \s+      )/gcx    && do { print "space:  $1\n";  redo; };
           m/ \G( [^\w\d]+ )/gcx    && do { print "other:  $1\n";  redo; };
      }
    }

Of course, that could have been written as
d653 4
a656 16
	   if ( /\G( \d+\b    )/gcx  {
		print "number: $1\n";
		redo PARSER;
	   }
	   if ( /\G( \w+      )/gcx  {
		print "word: $1\n";
		redo PARSER;
	   }
	   if ( /\G( \s+      )/gcx  {
		print "space: $1\n";
		redo PARSER;
	   }
	   if ( /\G( [^\w\d]+ )/gcx  {
		print "other: $1\n";
		redo PARSER;
	   }
d660 8
a667 1
but then you lose the vertical alignment of the regular expressions.
d682 1
a682 1
=head2 What's wrong with using grep or map in a void context?
d684 4
a687 5
The problem is that both grep and map build a return list,
regardless of the context.  This means you're making Perl go
to the trouble of building a list that you then just throw away.
If the list is large, you waste both time and space.  If your
intent is to iterate over the list then use a for loop for this
d690 4
d728 2
a729 2
   $martian =~ s/([A-Z][A-Z])/ $1 /g; # Make sure adjacent ``martian'' bytes
                                      # are no longer adjacent.
d747 2
a748 1
Or like this:
d750 9
a758 1
    die "sorry, Perl doesn't (yet) have Martian support )-:\n";
d760 2
a761 3
There are many double- (and multi-) byte encodings commonly used these
days.  Some versions of these have 1-, 2-, 3-, and 4-byte characters,
all mixed.
@


1.4
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 1
a3 1
perlfaq6 - Regexes ($Revision: 1.27 $, $Date: 1999/05/23 16:08:30 $)
d12 1
a12 1
on the web'' and L<perfaq4>: ``How do I determine whether a scalar is
d73 3
a75 3
Either you don't have more than one line in the string you're looking at
(probably), or else you aren't using the correct modifier(s) on your
pattern (possibly).
d118 1
a118 1
	while ( /START(.*?)END/sm ) { # /s makes . cross line boundaries
d169 1
a169 1
    $fh = new FileHandle "+<file";
d197 1
a197 1
And here it is as a subroutine, modelled after the above:
d215 15
d386 17
a402 7
Although Perl regular expressions are more powerful than "mathematical"
regular expressions because they feature conveniences like backreferences
(C<\1> and its ilk), they still aren't powerful enough--with
the possible exception of bizarre and experimental features in the
development-track releases of Perl.  You still need to use non-regex
techniques to parse balanced text, such as the text enclosed between
matching parentheses or braces, for example.
d407 1
a407 1
http://www.perl.com/CPAN/authors/id/TOMC/scripts/pull_quotes.gz .
d409 1
a409 1
The C::Scan module from CPAN contains such subs for internal use,
d637 6
a642 4
Both grep and map build a return list, regardless of their context.
This means you're making Perl go to the trouble of building up a
return list that you then just ignore.  That's no way to treat a
programming language, you insensitive scoundrel!
d646 14
a659 5
This is hard, and there's no good way.  Perl does not directly support
wide characters.  It pretends that a byte and a character are
synonymous.  The following set of approaches was offered by Jeffrey
Friedl, whose article in issue #5 of The Perl Journal talks about this
very matter.
d733 1
a733 1
Copyright (c) 1997-1999 Tom Christiansen and Nathan Torkington.
d736 2
a737 6
When included as part of the Standard Version of Perl, or as part of
its complete documentation whether printed or otherwise, this work
may be distributed only under the terms of Perl's Artistic License.
Any distribution of this file or derivatives thereof I<outside>
of that package require that special arrangements be made with
copyright holder.
@


1.3
log
@perl-5.6.0 + local changes
@
text
@d11 3
a13 2
this document (in the section on Data and the Networking one on
networking, to be precise).
d179 1
a179 1
=head2 How do I substitute case insensitively on the LHS, but preserving case on the RHS?
d189 1
a189 1
    s{(\Q$old\E}
d284 5
a288 4
(and perhaps recompilation) each time through.  The C</o> modifier
locks in the regex the first time it's used.  This always happens in a
constant regular expression, and in fact, the pattern was compiled
into the internal format at the same time your entire program was.
d372 2
a373 2
regular expressions, because they feature conveniences like backreferences
(C<\1> and its ilk), they still aren't powerful enough -- with
d384 1
a384 1
The C::Scan module from CPAN contains such subs for internal usage,
d407 1
a407 1
=head2  How do I process each word on each line?
d420 2
a421 1
To work with only alphanumeric sequences, you might consider
d455 2
a456 1
If you want these output in a sorted order, see the section on Hashes.
d493 1
a493 1
Two common misconceptions are that C<\b> is a synonym for C<\s+>, and
d520 2
a521 2
Because once Perl sees that you need one of these variables anywhere in
the program, it has to provide them on each and every pattern match.
d524 1
a524 1
parentheses. But if you never use $&, etc., in your script, then regexes
d533 10
a542 5
The notation C<\G> is used in a match or substitution in conjunction the
C</g> modifier (and ignored if there's no C</g>) to anchor the regular
expression to the point just past where the last match occurred, i.e. the
pos() point.  A failed match resets the position of C<\G> unless the
C</c> modifier is in effect.
d595 1
a595 1
But then you lose the vertical alignment of the regular expressions.
d676 1
a676 1
Or, since you have no guarantee that your user entered
d681 1
a681 1
But if all you really want to search for a string, not a pattern,
@


1.2
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
perlfaq6 - Regexps ($Revision: 1.25 $, $Date: 1999/01/08 04:50:47 $)
d21 1
a21 1
=item Comments Outside the Regexp
d30 1
a30 1
=item Comments Inside the Regexp
d32 1
a32 1
The C</x> modifier causes whitespace to be ignored in a regexp pattern
d180 40
a219 5
It depends on what you mean by "preserving case".  The following
script makes the substitution have the same case, letter by letter, as
the original.  If the substitution has more characters than the string
being substituted, the case of the last character is used for the rest
of the substitution.
a251 8
    $a = "this is a TEsT case";
    $a =~ s/(test)/preserve_case($1, "success")/gie;
    print "$a\n";

This prints:

    this is a SUcCESS case

d262 1
a262 1
=head2 How can I quote a variable to use in a regexp?
d268 1
a268 1
also that any regexp special characters will be acted on unless you
d273 1
a273 1
    $rhs = "sleep no more";
d278 1
a278 1
Without the \Q, the regexp would also spuriously match "di".
d284 1
a284 1
locks in the regexp the first time it's used.  This always happens in a
d289 1
a289 1
the pattern, and if so, the regexp engine will neither know nor care
d296 1
a296 1
you don't want the regexp to notice if they do.
d316 1
a316 1
created by Jeffrey Friedl:
d320 1
a320 1
    s#/\*[^*]*\*+([^/*][^*]*\*+)*/|("(\\.|[^"\\])*"|'(\\.|[^'\\])*'|\n+|.[^/"'\\]*)#$2#g;
d324 42
a365 1
whitespace and comments.
d371 5
a375 3
(C<\1> and its ilk), they still aren't powerful enough. You still need
to use non-regexp techniques to parse balanced text, such as the text
enclosed between matching parentheses or braces, for example.
d385 1
a385 1
=head2 What does it mean that regexps are greedy?  How can I get around it?
d387 1
a387 1
Most people mean that greedy regexps match as much as they can.
d495 1
a495 1
describes the behaviour of all the regexp metacharacters.
d519 2
a520 2
etc., so you pay the same price for each regexp that contains capturing
parentheses. But if you never use $&, etc., in your script, then regexps
d536 2
a537 2
and Usenet notation, (that is, with leading C<E<gt>> characters), and
you want change each leading C<E<gt>> into a corresponding C<:>.  You
d588 1
a588 1
=head2 Are Perl regexps DFAs or NFAs?  Are they POSIX compliant?
d693 1
a693 1
may be distributed only under the terms of Perl's Artistic Licence.
a702 1

@


1.1
log
@perl 5.004_04
@
text
@d3 1
a3 1
perlfaq6 - Regexps ($Revision: 1.17 $, $Date: 1997/04/24 22:44:10 $)
d28 1
a28 1
    s/^(\w+)(.*)/ lc($1) . ":" . length($2) /ge;
d72 3
a74 2
Either you don't have newlines in your string, or you aren't using the
correct modifier(s) on your pattern.
d98 1
a98 1
	while ( /\b(\w\S+)(\s+\1)+\b/gi ) {
d131 1
a131 1
    perl -0777 -pe 'print "$1\n" while /START(.*?)END/gs' file1 file2 ...
d137 10
d225 1
a225 1
=head2 How can I make C<\w> match accented characters?
d390 1
a390 1
The following is super-inefficient:
d392 10
a401 7
    while (<FH>) {
        foreach $pat (@@patterns) {
            if ( /$pat/ ) {
                # do something
            }
        }
    }
d403 12
a414 32
Instead, you either need to use one of the experimental Regexp extension
modules from CPAN (which might well be overkill for your purposes),
or else put together something like this, inspired from a routine
in Jeffrey Friedl's book:

    sub _bm_build {
        my $condition = shift;
        my @@regexp = @@_;  # this MUST not be local(); need my()
        my $expr = join $condition => map { "m/\$regexp[$_]/o" } (0..$#regexp);
        my $match_func = eval "sub { $expr }";
        die if $@@;  # propagate $@@; this shouldn't happen!
        return $match_func;
    }

    sub bm_and { _bm_build('&&', @@_) }
    sub bm_or  { _bm_build('||', @@_) }

    $f1 = bm_and qw{
            xterm
            (?i)window
    };

    $f2 = bm_or qw{
            \b[Ff]ree\b
            \bBSD\B
            (?i)sys(tem)?\s*[V5]\b
    };

    # feed me /etc/termcap, prolly
    while ( <> ) {
        print "1: $_" if &$f1;
        print "2: $_" if &$f2;
d446 10
a455 9
Because once Perl sees that you need one of these variables anywhere
in the program, it has to provide them on each and every pattern
match.  The same mechanism that handles these provides for the use of
$1, $2, etc., so you pay the same price for each regexp that contains
capturing parentheses. But if you never use $&, etc., in your script,
then regexps I<without> capturing parentheses won't be penalized. So
avoid $&, $', and $` if you can, but if you can't (and some algorithms
really appreciate them), once you've used them once, use them at will,
because you've already paid the price.
d462 2
a463 1
pos() point.
d533 4
a536 6
Strictly speaking, nothing.  Stylistically speaking, it's not a good
way to write maintainable code.  That's because you're using these
constructs not for their return values but rather for their
side-effects, and side-effects can be mystifying.  There's no void
grep() that's not better written as a C<for> (well, C<foreach>,
technically) loop.
d584 1
a584 6
   die "sorry, Perl doesn't (yet) have Martian support )-:\n";

In addition, a sample program which converts half-width to full-width
katakana (in Shift-JIS or EUC encoding) is available from CPAN as

=for Tom make it so
d590 26
d618 15
a632 2
Copyright (c) 1997 Tom Christiansen and Nathan Torkington.
All rights reserved.  See L<perlfaq> for distribution information.
@


1.1.1.1
log
@perl5.005_03
@
text
@d3 1
a3 1
perlfaq6 - Regexps ($Revision: 1.25 $, $Date: 1999/01/08 04:50:47 $)
d28 1
a28 1
    s/^(\w+)(.*)/ lc($1) . ":" . length($2) /meg;
d72 2
a73 3
Either you don't have more than one line in the string you're looking at
(probably), or else you aren't using the correct modifier(s) on your
pattern (possibly).
d97 1
a97 1
	while ( /\b([\w'-]+)(\s+\1)+\b/gi ) {  	# word starts alpha
d130 1
a130 1
    perl -0777 -ne 'print "$1\n" while /START(.*?)END/gs' file1 file2 ...
a135 10
Here's another example of using C<..>:

    while (<>) {
        $in_header =   1  .. /^$/;
        $in_body   = /^$/ .. eof();
	# now choose between them
    } continue {
	reset if eof();		# fix $.
    } 

d214 1
a214 1
=head2 How can I make C<\w> match national character sets?
d379 1
a379 1
The following is extremely inefficient:
d381 35
a415 10
    # slow but obvious way
    @@popstates = qw(CO ON MI WI MN);
    while (defined($line = <>)) {
	for $state (@@popstates) {
	    if ($line =~ /\b$state\b/i) {  
		print $line;
		last;
	    }
	}
    }                                        
d417 4
a420 12
That's because Perl has to recompile all those patterns for each of
the lines of the file.  As of the 5.005 release, there's a much better
approach, one which makes use of the new C<qr//> operator:

    # use spiffy new qr// operator, with /i flag even
    use 5.005;
    @@popstates = qw(CO ON MI WI MN);
    @@poppats   = map { qr/\b$_\b/i } @@popstates;
    while (defined($line = <>)) {
	for $patobj (@@poppats) {
	    print $line if $line =~ /$patobj/;
	}
d452 9
a460 10
Because once Perl sees that you need one of these variables anywhere in
the program, it has to provide them on each and every pattern match.
The same mechanism that handles these provides for the use of $1, $2,
etc., so you pay the same price for each regexp that contains capturing
parentheses. But if you never use $&, etc., in your script, then regexps
I<without> capturing parentheses won't be penalized. So avoid $&, $',
and $` if you can, but if you can't, once you've used them at all, use
them at will because you've already paid the price.  Remember that some
algorithms really appreciate them.  As of the 5.005 release.  the $&
variable is no longer "expensive" the way the other two are.
d467 1
a467 2
pos() point.  A failed match resets the position of C<\G> unless the
C</c> modifier is in effect.
d537 6
a542 4
Both grep and map build a return list, regardless of their context.
This means you're making Perl go to the trouble of building up a
return list that you then just ignore.  That's no way to treat a
programming language, you insensitive scoundrel!
d590 6
a595 1
    die "sorry, Perl doesn't (yet) have Martian support )-:\n";
a600 26
=head2 How do I match a pattern that is supplied by the user?

Well, if it's really a pattern, then just use

    chomp($pattern = <STDIN>);
    if ($line =~ /$pattern/) { }

Or, since you have no guarantee that your user entered
a valid regular expression, trap the exception this way:

    if (eval { $line =~ /$pattern/ }) { }

But if all you really want to search for a string, not a pattern,
then you should either use the index() function, which is made for
string searching, or if you can't be disabused of using a pattern
match on a non-pattern, then be sure to use C<\Q>...C<\E>, documented
in L<perlre>.

    $pattern = <STDIN>;

    open (FILE, $input) or die "Couldn't open input $input: $!; aborting";
    while (<FILE>) {
	print if /\Q$pattern\E/;
    }
    close FILE;

d603 2
a604 15
Copyright (c) 1997-1999 Tom Christiansen and Nathan Torkington.
All rights reserved.

When included as part of the Standard Version of Perl, or as part of
its complete documentation whether printed or otherwise, this work
may be distributed only under the terms of Perl's Artistic Licence.
Any distribution of this file or derivatives thereof I<outside>
of that package require that special arrangements be made with
copyright holder.

Irrespective of its distribution, all code examples in this file
are hereby placed into the public domain.  You are permitted and
encouraged to use this code in your own programs for fun
or for profit as you see fit.  A simple comment in the code giving
credit would be courteous but is not required.
@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
perlfaq6 - Regexes ($Revision: 1.27 $, $Date: 1999/05/23 16:08:30 $)
d21 1
a21 1
=item Comments Outside the Regex
d30 1
a30 1
=item Comments Inside the Regex
d32 1
a32 1
The C</x> modifier causes whitespace to be ignored in a regex pattern
d180 5
a184 40
Here's a lovely Perlish solution by Larry Rosler.  It exploits
properties of bitwise xor on ASCII strings.

    $_= "this is a TEsT case";

    $old = 'test';
    $new = 'success';

    s{(\Q$old\E}
     { uc $new | (uc $1 ^ $1) .
	(uc(substr $1, -1) ^ substr $1, -1) x
	    (length($new) - length $1)
     }egi;

    print;

And here it is as a subroutine, modelled after the above:

    sub preserve_case($$) {
	my ($old, $new) = @@_;
	my $mask = uc $old ^ $old;

	uc $new | $mask .
	    substr($mask, -1) x (length($new) - length($old))        
    }

    $a = "this is a TEsT case";
    $a =~ s/(test)/preserve_case($1, "success")/egi;
    print "$a\n";

This prints:

    this is a SUcCESS case

Just to show that C programmers can write C in any programming language,
if you prefer a more C-like solution, the following script makes the
substitution have the same case, letter by letter, as the original.
(It also happens to run about 240% slower than the Perlish solution runs.)
If the substitution has more characters than the string being substituted,
the case of the last character is used for the rest of the substitution.
d217 8
d235 1
a235 1
=head2 How can I quote a variable to use in a regex?
d241 1
a241 1
also that any regex special characters will be acted on unless you
d246 1
a246 1
    $rhs = "sleep, no more";
d251 1
a251 1
Without the \Q, the regex would also spuriously match "di".
d257 1
a257 1
locks in the regex the first time it's used.  This always happens in a
d262 1
a262 1
the pattern, and if so, the regex engine will neither know nor care
d269 1
a269 1
you don't want the regex to notice if they do.
d289 1
a289 1
created by Jeffrey Friedl and later modified by Fred Curtis.
d293 1
a293 1
    s#/\*[^*]*\*+([^/*][^*]*\*+)*/|("(\\.|[^"\\])*"|'(\\.|[^'\\])*'|.[^/"'\\]*)#$2#gs
d297 1
a297 42
whitespace and comments.  Here it is expanded, courtesy of Fred Curtis.

    s{
       /\*         ##  Start of /* ... */ comment
       [^*]*\*+    ##  Non-* followed by 1-or-more *'s
       (
         [^/*][^*]*\*+
       )*          ##  0-or-more things which don't start with /
                   ##    but do end with '*'
       /           ##  End of /* ... */ comment

     |         ##     OR  various things which aren't comments:

       (
         "           ##  Start of " ... " string
         (
           \\.           ##  Escaped char
         |               ##    OR
           [^"\\]        ##  Non "\
         )*
         "           ##  End of " ... " string

       |         ##     OR

         '           ##  Start of ' ... ' string
         (
           \\.           ##  Escaped char
         |               ##    OR
           [^'\\]        ##  Non '\
         )*
         '           ##  End of ' ... ' string

       |         ##     OR

         .           ##  Anything other char
         [^/"'\\]*   ##  Chars which doesn't start a comment, string or escape
       )
     }{$2}gxs;

A slight modification also removes C++ comments:

    s#/\*[^*]*\*+([^/*][^*]*\*+)*/|//[^\n]*|("(\\.|[^"\\])*"|'(\\.|[^'\\])*'|.[^/"'\\]*)#$2#gs;
d303 3
a305 5
(C<\1> and its ilk), they still aren't powerful enough -- with
the possible exception of bizarre and experimental features in the
development-track releases of Perl.  You still need to use non-regex
techniques to parse balanced text, such as the text enclosed between
matching parentheses or braces, for example.
d315 1
a315 1
=head2 What does it mean that regexes are greedy?  How can I get around it?
d317 1
a317 1
Most people mean that greedy regexes match as much as they can.
d425 1
a425 1
describes the behavior of all the regex metacharacters.
d449 2
a450 2
etc., so you pay the same price for each regex that contains capturing
parentheses. But if you never use $&, etc., in your script, then regexes
d466 2
a467 2
and Usenet notation, (that is, with leading C<< > >> characters), and
you want change each leading C<< > >> into a corresponding C<:>.  You
d518 1
a518 1
=head2 Are Perl regexes DFAs or NFAs?  Are they POSIX compliant?
d623 1
a623 1
may be distributed only under the terms of Perl's Artistic License.
d633 1
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d11 2
a12 3
this document (in L<perlfaq9>: ``How do I decode or create those %-encodings 
on the web'' and L<perfaq4>: ``How do I determine whether a scalar is
a number/whole/integer/float'', to be precise).
d178 1
a178 1
=head2 How do I substitute case insensitively on the LHS while preserving case on the RHS?
d188 1
a188 1
    s{(\Q$old\E)}
d283 4
a286 5
(and perhaps recompilation) each time the regular expression is
encountered.  The C</o> modifier locks in the regex the first time
it's used.  This always happens in a constant regular expression, and
in fact, the pattern was compiled into the internal format at the same
time your entire program was.
d370 2
a371 2
regular expressions because they feature conveniences like backreferences
(C<\1> and its ilk), they still aren't powerful enough--with
d382 1
a382 1
The C::Scan module from CPAN contains such subs for internal use,
d405 1
a405 1
=head2 How do I process each word on each line?
d418 1
a418 2
To work with only alphanumeric sequences (including underscores), you
might consider
d452 1
a452 2
If you want these output in a sorted order, see L<perlfaq4>: ``How do I
sort a hash (optionally by value instead of key)?''.
d489 1
a489 1
Two common misconceptions are that C<\b> is a synonym for C<\s+> and
d516 2
a517 2
Once Perl sees that you need one of these variables anywhere in
the program, it provides them on each and every pattern match.
d520 1
a520 1
parentheses.  If you never use $&, etc., in your script, then regexes
d529 5
a533 10
The notation C<\G> is used in a match or substitution in conjunction with
the C</g> modifier to anchor the regular expression to the point just past
where the last match occurred, i.e. the pos() point.  A failed match resets
the position of C<\G> unless the C</c> modifier is in effect. C<\G> can be
used in a match without the C</g> modifier; it acts the same (i.e. still
anchors at the pos() point) but of course only matches once and does not
update pos(), as non-C</g> expressions never do. C<\G> in an expression
applied to a target string that has never been matched against a C</g>
expression before or has had its pos() reset is functionally equivalent to
C<\A>, which matches at the beginning of the string.
d586 1
a586 1
but then you lose the vertical alignment of the regular expressions.
d667 1
a667 1
Alternatively, since you have no guarantee that your user entered
d672 1
a672 1
If all you really want to search for a string, not a pattern,
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
perlfaq6 - Regular Expressions ($Revision: 1.12 $, $Date: 2002/06/01 22:31:09 $)
d12 1
a12 1
on the web'' and L<perlfaq4>: ``How do I determine whether a scalar is
d73 3
a75 3
Either you don't have more than one line in the string you're looking
at (probably), or else you aren't using the correct modifier(s) on
your pattern (possibly).
d118 1
a118 1
	while ( /START(.*?)END/sgm ) { # /s makes . cross line boundaries
d169 1
a169 1
    $fh = new IO::File "+<file";
d197 1
a197 1
And here it is as a subroutine, modeled after the above:
a214 15
As an alternative, to keep the case of the replacement word if it is
longer than the original, you can use this code, by Jeff Pinyan:

  sub preserve_case {
    my ($from, $to) = @@_;
    my ($lf, $lt) = map length, @@_;

    if ($lt < $lf) { $from = substr $from, 0, $lt }
    else { $from .= substr $to, $lf }

    return uc $to | ($from ^ uc $from);
  }

This changes the sentence to "this is a SUcCess case."

d371 7
a377 17
Historically, Perl regular expressions were not capable of matching
balanced text.  As of more recent versions of perl including 5.6.1
experimental features have been added that make it possible to do this.
Look at the documentation for the (??{ }) construct in recent perlre manual
pages to see an example of matching balanced parentheses.  Be sure to take
special notice of the  warnings present in the manual before making use
of this feature.

CPAN contains many modules that can be useful for matching text
depending on the context.  Damian Conway provides some useful
patterns in Regexp::Common.  The module Text::Balanced provides a
general solution to this problem.

One of the common applications of balanced text matching is working
with XML and HTML.  There are many modules available that support
these needs.  Two examples are HTML::Parser and XML::Parser. There
are many others.
d382 1
a382 1
http://www.cpan.org/authors/id/TOMC/scripts/pull_quotes.gz .
d384 1
a384 1
The C::Scan module from CPAN also contains such subs for internal use,
d612 4
a615 6
The problem is that both grep and map build a return list,
regardless of the context.  This means you're making Perl go
to the trouble of building a list that you then just throw away.
If the list is large, you waste both time and space.  If your
intent is to iterate over the list then use a for loop for this
purpose.
d619 5
a623 14
Starting from Perl 5.6 Perl has had some level of multibyte character
support.  Perl 5.8 or later is recommended.  Supported multibyte
character repertoires include Unicode, and legacy encodings
through the Encode module.  See L<perluniintro>, L<perlunicode>,
and L<Encode>.

If you are stuck with older Perls, you can do Unicode with the
C<Unicode::String> module, and character conversions using the
C<Unicode::Map8> and C<Unicode::Map> modules.  If you are using
Japanese encodings, you might try using the jperl 5.005_03.

Finally, the following set of approaches was offered by Jeffrey
Friedl, whose article in issue #5 of The Perl Journal talks about
this very matter.
d697 1
a697 1
Copyright (c) 1997-2002 Tom Christiansen and Nathan Torkington.
d700 6
a705 2
This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 1
perlfaq6 - Regular Expressions ($Revision: 1.20 $, $Date: 2003/01/03 20:05:28 $)
d11 1
a11 1
this document (in L<perlfaq9>: ``How do I decode or create those %-encodings
d146 1
a146 1
    }
d150 8
a157 27
Up to Perl 5.8.0, $/ has to be a string.  This may change in 5.10,
but don't get your hopes up. Until then, you can use these examples
if you really need to do this.

Use the four argument form of sysread to continually add to
a buffer.  After you add to the buffer, you check if you have a
complete line (using your regular expression).

       local $_ = "";
       while( sysread FH, $_, 8192, length ) {
          while( s/^((?s).*?)your_pattern/ ) {
             my $record = $1;
             # do stuff here.
          }
       }

 You can do the same thing with foreach and a match using the
 c flag and the \G anchor, if you do not mind your entire file
 being in memory at the end.

       local $_ = "";
       while( sysread FH, $_, 8192, length ) {
          foreach my $record ( m/\G((?s).*?)your_pattern/gc ) {
             # do stuff here.
          }
          substr( $_, 0, pos ) = "" if pos;
       }
d159 19
d204 1
a204 1
	    substr($mask, -1) x (length($new) - length($old))
d270 1
a270 4
Put C<use locale;> in your script.  The \w character class is taken
from the current locale.

See L<perllocale> for details.
d274 3
a276 8
You can use the POSIX character class syntax C</[[:alpha:]]/>
documented in L<perlre>.

No matter which locale you are in, the alphabetic characters are
the characters in \w without the digits and the underscore.
As a regex, that looks like C</[^\W\d_]/>.  Its complement,
the non-alphabetics, is then everything in \W along with
the digits and the underscore, or C</[\W\d_]/>.
d287 3
a289 5
    $string = "Placido P. Octopus";
    $regex  = "P.";

    $string =~ s/$regex/Polyp/;
    # $string is now "Polypacido P. Octopus"
d291 2
a292 3
Because C<.> is special in regular expressions, and can match any
single character, the regex C<P.> here has matched the <Pl> in the
original string.
d294 1
a294 10
To escape the special meaning of C<.>, we use C<\Q>:

    $string = "Placido P. Octopus";
    $regex  = "P.";

    $string =~ s/\Q$regex/Polyp/;
    # $string is now "Placido Polyp Octopus"

The use of C<\Q> causes the <.> in the regex to be treated as a
regular character, so that C<P.> matches a C<P> followed by a dot.
d437 1
a437 1
	foreach $word ( split ) {
d439 1
a439 1
	}
d473 1
a473 1
    while (<>) {
d495 1
a495 1
	    if ($line =~ /\b$state\b/i) {
d500 1
a500 1
    }
d558 39
a596 71
You use the C<\G> anchor to start the next match on the same
string where the last match left off.  The regular
expression engine cannot skip over any characters to find
the next match with this anchor, so C<\G> is similar to the
beginning of string anchor, C<^>.  The C<\G> anchor is typically
used with the C<g> flag.  It uses the value of pos()
as the position to start the next match.  As the match
operator makes successive matches, it updates pos() with the
position of the next character past the last match (or the
first character of the next match, depending on how you like
to look at it). Each string has its own pos() value.

Suppose you want to match all of consective pairs of digits
in a string like "1122a44" and stop matching when you
encounter non-digits.  You want to match C<11> and C<22> but
the letter <a> shows up between C<22> and C<44> and you want
to stop at C<a>. Simply matching pairs of digits skips over
the C<a> and still matches C<44>.

	$_ = "1122a44";
	my @@pairs = m/(\d\d)/g;   # qw( 11 22 44 )

If you use the \G anchor, you force the match after C<22> to
start with the C<a>.  The regular expression cannot match
there since it does not find a digit, so the next match
fails and the match operator returns the pairs it already
found.

	$_ = "1122a44";
	my @@pairs = m/\G(\d\d)/g; # qw( 11 22 )

You can also use the C<\G> anchor in scalar context. You
still need the C<g> flag.

	$_ = "1122a44";
	while( m/\G(\d\d)/g )
		{
		print "Found $1\n";
		}

After the match fails at the letter C<a>, perl resets pos()
and the next match on the same string starts at the beginning.

	$_ = "1122a44";
	while( m/\G(\d\d)/g )
		{
		print "Found $1\n";
		}

	print "Found $1 after while" if m/(\d\d)/g; # finds "11"

You can disable pos() resets on fail with the C<c> flag.
Subsequent matches start where the last successful match
ended (the value of pos()) even if a match on the same
string as failed in the meantime. In this case, the match
after the while() loop starts at the C<a> (where the last
match stopped), and since it does not use any anchor it can
skip over the C<a> to find "44".

	$_ = "1122a44";
	while( m/\G(\d\d)/gc )
		{
		print "Found $1\n";
		}

	print "Found $1 after while" if m/(\d\d)/g; # finds "44"

Typically you use the C<\G> anchor with the C<c> flag
when you want to try a different match if one fails,
such as in a tokenizer. Jeffrey Friedl offers this example
which works in 5.004 or later.
d601 16
a616 4
           m/ \G( \d+\b    )/gcx   && do { print "number: $1\n";  redo; };
           m/ \G( \w+      )/gcx   && do { print "word:   $1\n";  redo; };
           m/ \G( \s+      )/gcx   && do { print "space:  $1\n";  redo; };
           m/ \G( [^\w\d]+ )/gcx   && do { print "other:  $1\n";  redo; };
d620 1
a620 8
For each line, the PARSER loop first tries to match a series
of digits followed by a word boundary.  This match has to
start at the place the last match left off (or the beginning
of the string on the first match). Since C<m/ \G( \d+\b
)/gcx> uses the C<c> flag, if the string does not match that
regular expression, perl does not reset pos() and the next
match starts at the same position to try a different
pattern.
d635 1
a635 1
=head2 What's wrong with using grep in a void context?
d637 5
a641 4
The problem is that grep builds a return list, regardless of the context.
This means you're making Perl go to the trouble of building a list that
you then just throw away. If the list is large, you waste both time and space.
If your intent is to iterate over the list, then use a for loop for this
a643 4
In perls older than 5.8.1, map suffers from this problem as well.
But since 5.8.1, this has been fixed, and map is context aware - in void
context, no lists are constructed.

d678 2
a679 2
   $martian =~ s/([A-Z][A-Z])/ $1 /g; # Make sure adjacent ``martian''
                                      # bytes are no longer adjacent.
d697 1
a697 2
Here's another, slightly less painful, way to do it from Benjamin
Goldberg:
d699 1
a699 9
	$martian =~ m/
	   (?!<[A-Z])
	   (?:[A-Z][A-Z])*?
	   GX
	/x;

This succeeds if the "martian" character GX is in the string, and fails
otherwise.  If you don't like using (?!<), you can replace (?!<[A-Z])
with (?:^|[^A-Z]).
d701 3
a703 2
It does have the drawback of putting the wrong thing in $-[0] and $+[0],
but this usually can be worked around.
@


1.1.1.6
log
@Import of stock perl 5.8.5
@
text
@d3 1
a3 1
perlfaq6 - Regular Expressions ($Revision: 1.6 $, $Date: 2003/12/03 03:02:44 $)
@


1.1.1.7
log
@perl 5.8.6 from CPAN
@
text
@d3 1
a3 1
perlfaq6 - Regular Expressions ($Revision: 1.27 $, $Date: 2004/11/03 22:52:16 $)
d154 1
a154 13
If you have File::Stream, this is easy.

			 use File::Stream;
             my $stream = File::Stream->new(
                  $filehandle,
                  separator => qr/\s*,\s*/,
                  );

			 print "$_\n" while <$stream>;

If you don't have File::Stream, you have to do a little more work.

You can use the four argument form of sysread to continually add to
d357 1
a357 1
    s#/\*[^*]*\*+([^/*][^*]*\*+)*/|("(\\.|[^"\\])*"|'(\\.|[^'\\])*'|.[^/"'\\]*)#defined $2 ? $2 : ""#gse;
d398 1
a398 1
     }{defined $2 ? $2 : ""}gxse;
d402 1
a402 1
    s#/\*[^*]*\*+([^/*][^*]*\*+)*/|//[^\n]*|("(\\.|[^"\\])*"|'(\\.|[^'\\])*'|.[^/"'\\]*)#defined $2 ? $2 : ""#gse;
d748 1
a748 1
Goldberg, who uses a zero-width negative look-behind assertion.
d750 5
a754 5
	print "found GX!\n" if	$martian =~ m/
		   (?<![A-Z])
		   (?:[A-Z][A-Z])*?
		   GX
		/x;
d757 2
a758 2
otherwise.  If you don't like using (?<!), a zero-width negative
look-behind assertion, you can replace (?<![A-Z]) with (?:^|[^A-Z]).
@


1.1.1.8
log
@perl 5.8.8 import
@
text
@d3 1
a3 1
perlfaq6 - Regular Expressions ($Revision: 1.38 $, $Date: 2005/12/31 00:54:37 $)
d11 3
a13 3
this document (in L<perlfaq9>: "How do I decode or create those %-encodings
on the web" and L<perlfaq4>: "How do I determine whether a scalar is
a number/whole/integer/float", to be precise).
a15 2
X<regex, legibility> X<regexp, legibility>
X<regular expression, legibility> X</x>
a71 1
X<regex, multiline> X<regexp, multiline> X<regular expression, multiline>
a123 1
X<..>
a148 2
X<$/, regexes in> X<$INPUT_RECORD_SEPARATOR, regexes in>
X<$RS, regexes in>
a191 2
X<replace, case preserving> X<substitute, case preserving>
X<substitution, case preserving> X<s, case preserving>
a280 1
X<\w>
a287 1
X<alpha>
a298 1
X<regex, escaping> X<regexp, escaping> X<regular expression, escaping>
a328 1
X</o>
a416 2
X<regex, matching balanced test> X<regexp, matching balanced test>
X<regular expression, matching balanced test>
a444 1
X<greedy> X<greediness>
a464 1
X<word>
d512 2
a513 2
If you want these output in a sorted order, see L<perlfaq4>: "How do I
sort a hash (optionally by value instead of key)?".
a515 1
X<match, approximate> X<matching, approximate>
a519 2
X<regex, efficiency> X<regexp, efficiency>
X<regular expression, efficiency>
d521 1
a521 1
( contributed by brian d foy )
d523 10
a532 15
Avoid asking Perl to compile a regular expression every time
you want to match it.  In this example, perl must recompile
the regular expression for every iteration of the foreach()
loop since it has no way to know what $pattern will be.

    @@patterns = qw( foo bar baz );

    LINE: while( <> )
    	{
		foreach $pattern ( @@patterns )
			{
	    	print if /\b$pattern\b/i;
	    	next LINE;
	   		}
		}
d534 13
a546 34
The qr// operator showed up in perl 5.005.  It compiles a
regular expression, but doesn't apply it.  When you use the
pre-compiled version of the regex, perl does less work. In
this example, I inserted a map() to turn each pattern into
its pre-compiled form.  The rest of the script is the same,
but faster.

    @@patterns = map { qr/\b$_\b/i } qw( foo bar baz );

    LINE: while( <> )
    	{
		foreach $pattern ( @@patterns )
			{
	    	print if /\b$pattern\b/i;
	    	next LINE;
	   		}
		}

In some cases, you may be able to make several patterns into
a single regular expression.  Beware of situations that require
backtracking though.

	$regex = join '|', qw( foo bar baz );

    LINE: while( <> )
    	{
		print if /\b(?:$regex)\b/i;
		}

For more details on regular expression efficiency, see Mastering
Regular Expressions by Jeffrey Freidl.  He explains how regular
expressions engine work and why some patterns are surprisingly
inefficient.  Once you understand how perl applies regular
expressions, you can tune them for individual situations.
a548 55
X<\b>

(contributed by brian d foy)

Ensure that you know what \b really does: it's the boundary between a
word character, \w, and something that isn't a word character. That
thing that isn't a word character might be \W, but it can also be the
start or end of the string.

It's not (not!) the boundary between whitespace and non-whitespace,
and it's not the stuff between words we use to create sentences.

In regex speak, a word boundary (\b) is a "zero width assertion",
meaning that it doesn't represent a character in the string, but a
condition at a certain position.

For the regular expression, /\bPerl\b/, there has to be a word
boundary before the "P" and after the "l".  As long as something other
than a word character precedes the "P" and succeeds the "l", the
pattern will match. These strings match /\bPerl\b/.

	"Perl"    # no word char before P or after l
	"Perl "   # same as previous (space is not a word char)
	"'Perl'"  # the ' char is not a word char
	"Perl's"  # no word char before P, non-word char after "l"

These strings do not match /\bPerl\b/.

	"Perl_"   # _ is a word char!
	"Perler"  # no word char before P, but one after l

You don't have to use \b to match words though.  You can look for
non-word characters surrounded by word characters.  These strings
match the pattern /\b'\b/.

	"don't"   # the ' char is surrounded by "n" and "t"
	"qep'a'"  # the ' char is surrounded by "p" and "a"

These strings do not match /\b'\b/.

	"foo'"    # there is no word char after non-word '

You can also use the complement of \b, \B, to specify that there
should not be a word boundary.

In the pattern /\Bam\B/, there must be a word character before the "a"
and after the "m". These patterns match /\Bam\B/:

	"llama"   # "am" surrounded by word chars
	"Samuel"  # same

These strings do not match /\Bam\B/

	"Sam"      # no word boundary before "a", but one after "m"
	"I am Sam" # "am" surrounded by non-word chars
d550 24
a575 3
X<$MATCH> X<$&> X<$POSTMATCH> X<$'> X<$PREMATCH> X<$`>

(contributed by Anno Siegel)
d577 10
a586 15
Once Perl sees that you need one of these variables anywhere in the
program, it provides them on each and every pattern match. That means
that on every pattern match the entire string will be copied, part of it
to $`, part to $&, and part to $'. Thus the penalty is most severe with
long strings and patterns that match often. Avoid $&, $', and $` if you
can, but if you can't, once you've used them at all, use them at will
because you've already paid the price. Remember that some algorithms
really appreciate them. As of the 5.005 release, the $& variable is no
longer "expensive" the way the other two are.

Since Perl 5.6.1 the special variables @@- and @@+ can functionally replace
$`, $& and $'.  These arrays contain pointers to the beginning and end
of each match (see perlvar for the full story), so they give you
essentially the same information, but without the risk of excessive
string copying.
a588 1
X<\G>
a681 1
X<DFA> X<NFA> X<POSIX>
a694 1
X<grep>
a706 2
X<regex, and multibyte characters> X<regexp, and multibyte characters>
X<regular expression, and multibyte characters>
d740 1
a740 1
   $martian =~ s/([A-Z][A-Z])/ $1 /g; # Make sure adjacent "martian"
d787 1
a787 1
If all you really want is to search for a string, not a pattern,
d789 1
a789 1
string searching, or, if you can't be disabused of using a pattern
d803 2
a804 2
Copyright (c) 1997-2006 Tom Christiansen, Nathan Torkington, and
other authors as noted. All rights reserved.
@


1.1.1.9
log
@import perl 5.10.0 from CPAN
@
text
@d3 1
a3 1
perlfaq6 - Regular Expressions ($Revision: 10126 $)
d29 3
a31 3
	# turn the line into the first word, a colon, and the
	# number of characters on the rest of the line
	s/^(\w+)(.*)/ lc($1) . ":" . length($2) /meg;
d42 1
a42 1
	s{<(?:[^>'"]*|".*?"|'.*?')+>}{}gs;
d46 10
a55 10
	s{ <                    # opening angle bracket
		(?:                 # Non-backreffing grouping paren
			[^>'"] *        # 0 or more things that are neither > nor ' nor "
				|           #    or else
			".*?"           # a section between double quotes (stingy match)
				|           #    or else
			'.*?'           # a section between single quotes (stingy match)
		) +                 #   all occurring one or more times
		>                   # closing angle bracket
	}{}gsx;                 # replace with nothing, i.e. delete
d68 2
a69 2
	s/\/usr\/local/\/usr\/share/g;	# bad delimiter choice
	s#/usr/local#/usr/share#g;		# better
d100 4
a103 5
	$/ = '';  		# read in more whole paragraph, not just one line
	while ( <> ) {
		while ( /\b([\w'-]+)(\s+\1)+\b/gi ) {  	# word starts alpha
			print "Duplicate $1 at paragraph $.\n";
		}
d105 1
d110 4
a113 5
	$/ = '';  		# read in more whole paragraph, not just one line
	while ( <> ) {
		while ( /^From /gm ) { # /m makes ^ match next to \n
		print "leading from in paragraph $.\n";
		}
d115 1
d119 4
a122 5
	undef $/;  		# read in whole file, not just one line or paragraph
	while ( <> ) {
		while ( /START(.*?)END/sgm ) { # /s makes . cross line boundaries
		    print "$1\n";
		}
d124 1
d132 1
a132 1
	perl -ne 'print if /START/ .. /END/' file1 file2 ...
d136 1
a136 1
	perl -0777 -ne 'print "$1\n" while /START(.*?)END/gs' file1 file2 ...
d144 3
a146 3
	while (<>) {
		$in_header =   1  .. /^$/;
		$in_body   = /^$/ .. eof;
d148 3
a150 3
	} continue {
		$. = 0 if eof;	# fix $.
	}
d156 3
a158 2
$/ has to be a string.  You can use these examples if you really need to 
do this.
d162 5
a166 1
	use File::Stream;
d168 1
a168 6
	my $stream = File::Stream->new(
		$filehandle,
		separator => qr/\s*,\s*/,
		);

	print "$_\n" while <$stream>;
d176 7
a182 7
	local $_ = "";
	while( sysread FH, $_, 8192, length ) {
		while( s/^((?s).*?)your_pattern/ ) {
			my $record = $1;
			# do stuff here.
		}
	}
d188 7
a194 7
	local $_ = "";
	while( sysread FH, $_, 8192, length ) {
		foreach my $record ( m/\G((?s).*?)your_pattern/gc ) {
			# do stuff here.
		}
	substr( $_, 0, pos ) = "" if pos;
	}
d204 1
a204 1
	$_= "this is a TEsT case";
d206 2
a207 2
	$old = 'test';
	$new = 'success';
d209 5
a213 5
	s{(\Q$old\E)}
	{ uc $new | (uc $1 ^ $1) .
		(uc(substr $1, -1) ^ substr $1, -1) x
		(length($new) - length $1)
	}egi;
d215 1
a215 1
	print;
d219 3
a221 3
	sub preserve_case($$) {
		my ($old, $new) = @@_;
		my $mask = uc $old ^ $old;
d223 2
a224 2
		uc $new | $mask .
			substr($mask, -1) x (length($new) - length($old))
d227 3
a229 3
	$a = "this is a TEsT case";
	$a =~ s/(test)/preserve_case($1, "success")/egi;
	print "$a\n";
d233 1
a233 1
	this is a SUcCESS case
d238 3
a240 3
	sub preserve_case {
		my ($from, $to) = @@_;
		my ($lf, $lt) = map length, @@_;
d242 2
a243 2
		if ($lt < $lf) { $from = substr $from, 0, $lt }
		else { $from .= substr $to, $lf }
d245 2
a246 2
		return uc $to | ($from ^ uc $from);
		}
d257 30
a286 30
	# Original by Nathan Torkington, massaged by Jeffrey Friedl
	#
	sub preserve_case($$)
	{
		my ($old, $new) = @@_;
		my ($state) = 0; # 0 = no change; 1 = lc; 2 = uc
		my ($i, $oldlen, $newlen, $c) = (0, length($old), length($new));
		my ($len) = $oldlen < $newlen ? $oldlen : $newlen;

		for ($i = 0; $i < $len; $i++) {
			if ($c = substr($old, $i, 1), $c =~ /[\W\d_]/) {
				$state = 0;
			} elsif (lc $c eq $c) {
				substr($new, $i, 1) = lc(substr($new, $i, 1));
				$state = 1;
			} else {
				substr($new, $i, 1) = uc(substr($new, $i, 1));
				$state = 2;
			}
		}
		# finish up with any remaining new (for when new is longer than old)
		if ($newlen > $oldlen) {
			if ($state == 1) {
				substr($new, $oldlen) = lc(substr($new, $oldlen));
			} elsif ($state == 2) {
				substr($new, $oldlen) = uc(substr($new, $oldlen));
			}
		}
		return $new;
	}
d318 2
a319 2
	$string = "Placido P. Octopus";
	$regex  = "P.";
d321 2
a322 2
	$string =~ s/$regex/Polyp/;
	# $string is now "Polypacido P. Octopus"
d330 2
a331 2
	$string = "Placido P. Octopus";
	$regex  = "P.";
d333 2
a334 2
	$string =~ s/\Q$regex/Polyp/;
	# $string is now "Placido Polyp Octopus"
d340 1
a340 1
X</o, regular expressions> X<compile, regular expressions>
d342 24
a365 55
(contributed by brian d foy)

The C</o> option for regular expressions (documented in L<perlop> and
L<perlreref>) tells Perl to compile the regular expression only once.
This is only useful when the pattern contains a variable. Perls 5.6
and later handle this automatically if the pattern does not change.

Since the match operator C<m//>, the substitution operator C<s///>,
and the regular expression quoting operator C<qr//> are double-quotish
constructs, you can interpolate variables into the pattern. See the
answer to "How can I quote a variable to use in a regex?" for more
details.

This example takes a regular expression from the argument list and
prints the lines of input that match it:

	my $pattern = shift @@ARGV;
	
	while( <> ) {
		print if m/$pattern/;
		}

Versions of Perl prior to 5.6 would recompile the regular expression
for each iteration, even if C<$pattern> had not changed. The C</o>
would prevent this by telling Perl to compile the pattern the first
time, then reuse that for subsequent iterations:

	my $pattern = shift @@ARGV;
	
	while( <> ) {
		print if m/$pattern/o; # useful for Perl < 5.6
		}

In versions 5.6 and later, Perl won't recompile the regular expression
if the variable hasn't changed, so you probably don't need the C</o>
option. It doesn't hurt, but it doesn't help either. If you want any
version of Perl to compile the regular expression only once even if
the variable changes (thus, only using its initial value), you still
need the C</o>.

You can watch Perl's regular expression engine at work to verify for
yourself if Perl is recompiling a regular expression. The C<use re
'debug'> pragma (comes with Perl 5.005 and later) shows the details.
With Perls before 5.6, you should see C<re> reporting that its
compiling the regular expression on each iteration. With Perl 5.6 or
later, you should only see C<re> report that for the first iteration.

	use re 'debug';
	
	$regex = 'Perl';
	foreach ( qw(Perl Java Ruby Python) ) {
		print STDERR "-" x 73, "\n";
		print STDERR "Trying $_...\n";
		print STDERR "\t$_ is good!\n" if m/$regex/;
		}
d372 1
a372 1
	perl -0777 -pe 's{/\*.*?\*/}{}gs' foo.c
d379 4
a382 4
	$/ = undef;
	$_ = <>;
	s#/\*[^*]*\*+([^/*][^*]*\*+)*/|("(\\.|[^"\\])*"|'(\\.|[^'\\])*'|.[^/"'\\]*)#defined $2 ? $2 : ""#gse;
	print;
d424 1
a424 2
A slight modification also removes C++ comments, as long as they are not
spread over multiple lines using a continuation character):
d426 1
a426 1
	s#/\*[^*]*\*+([^/*][^*]*\*+)*/|//[^\n]*|("(\\.|[^"\\])*"|'(\\.|[^'\\])*'|.[^/"'\\]*)#defined $2 ? $2 : ""#gse;
d469 3
a471 3
	$s1 = $s2 = "I am very very cold";
	$s1 =~ s/ve.*y //;      # I am cold
	$s2 =~ s/ve.*?y //;     # I am very cold
d484 3
a486 4
	while (<>) {
		foreach $word ( split ) {
			# do something with $word here
		}
d488 1
d496 3
a498 4
	while (<>) {
		foreach $word (m/(\w+)/g) {
			# do something with $word here
		}
d500 1
d509 3
a511 4
	while (<>) {
		while ( /(\b[^\W_\d][\w'-]+\b)/g ) {   # misses "`sheep'"
			$seen{$1}++;
		}
d513 4
a516 4

	while ( ($word, $count) = each %seen ) {
		print "$count $word\n";
		}
d521 6
a526 7
	while (<>) {
		$seen{$_}++;
		}

	while ( ($line, $count) = each %seen ) {
		print "$count $line";
	}
d547 1
a547 1
	@@patterns = qw( foo bar baz );
d549 2
a550 2
	LINE: while( <DATA> )
		{
d553 3
a555 6
			if( /\b$pattern\b/i )
				{
				print;
				next LINE;
				}
			}
d565 1
a565 1
	@@patterns = map { qr/\b$_\b/i } qw( foo bar baz );
d567 2
a568 2
	LINE: while( <> )
		{
d571 3
a573 3
			print if /$pattern/i;
			next LINE;
			}
d582 2
a583 2
	LINE: while( <> )
		{
d680 1
a680 1
used with the C<g> flag.  It uses the value of C<pos()>
d682 1
a682 1
operator makes successive matches, it updates C<pos()> with the
d685 1
a685 1
to look at it). Each string has its own C<pos()> value.
d687 1
a687 1
Suppose you want to match all of consecutive pairs of digits
d697 1
a697 1
If you use the C<\G> anchor, you force the match after C<22> to
d715 1
a715 1
After the match fails at the letter C<a>, perl resets C<pos()>
d726 7
a732 7
You can disable C<pos()> resets on fail with the C<c> flag, documented
in L<perlop> and L<perlreref>. Subsequent matches start where the last
successful match ended (the value of C<pos()>) even if a match on the
same string has failed in the meantime. In this case, the match after
the C<while()> loop starts at the C<a> (where the last match stopped),
and since it does not use any anchor it can skip over the C<a> to find
C<44>.
d747 9
a755 9
	while (<>) {
		chomp;
		PARSER: {
			m/ \G( \d+\b    )/gcx   && do { print "number: $1\n";  redo; };
			m/ \G( \w+      )/gcx   && do { print "word:   $1\n";  redo; };
			m/ \G( \s+      )/gcx   && do { print "space:  $1\n";  redo; };
			m/ \G( [^\w\d]+ )/gcx   && do { print "other:  $1\n";  redo; };
		}
	}
d757 1
a757 1
For each line, the C<PARSER> loop first tries to match a series
d795 1
a795 1
X<regular expression, and multibyte characters> X<martian> X<encoding, Martian>
d829 3
a831 4
	# Make sure adjacent "martian" bytes are no longer adjacent.
	$martian =~ s/([A-Z][A-Z])/ $1 /g;

	print "found GX!\n" if $martian =~ /GX/;
d835 6
a840 6
	@@chars = $martian =~ m/([A-Z][A-Z]|[^A-Z])/g;
	# above is conceptually similar to:     @@chars = $text =~ m/(.)/g;
	#
	foreach $char (@@chars) {
	print "found GX!\n", last if $char eq 'GX';
	}
d844 3
a846 3
	while ($martian =~ m/\G([A-Z][A-Z]|.)/gs) {  # \G probably unneeded
		print "found GX!\n", last if $1 eq 'GX';
		}
d852 3
a854 3
		(?<![A-Z])
		(?:[A-Z][A-Z])*?
		GX
d864 1
a864 3
=head2 How do I match a regular expression that's in a variable?
X<regex, in variable> X<eval> X<regex> X<quotemeta> X<\Q, regex>
X<\E, regex>, X<qr//>
d866 1
a866 1
(contributed by brian d foy)
d868 2
a869 3
We don't have to hard-code patterns into the match operator (or
anything else that works with regular expressions). We can put the
pattern in a variable for later use.
d871 2
a872 5
The match operator is a double quote context, so you can interpolate
your variable just like a double quoted string. In this case, you
read the regular expression as user input and store it in C<$regex>.
Once you have the pattern in C<$regex>, you use that variable in the
match operator.
d874 1
a874 1
	chomp( my $regex = <STDIN> );
d876 5
a880 1
	if( $string =~ m/$regex/ ) { ... }
d882 1
a882 3
Any regular expression special characters in C<$regex> are still
special, and the pattern still has to be valid or Perl will complain.
For instance, in this pattern there is an unpaired parenthesis.
d884 5
a888 65
	my $regex = "Unmatched ( paren";

	"Two parens to bind them all" =~ m/$regex/;

When Perl compiles the regular expression, it treats the parenthesis
as the start of a memory match. When it doesn't find the closing
parenthesis, it complains:

	Unmatched ( in regex; marked by <-- HERE in m/Unmatched ( <-- HERE  paren/ at script line 3.

You can get around this in several ways depending on our situation.
First, if you don't want any of the characters in the string to be
special, you can escape them with C<quotemeta> before you use the string.

	chomp( my $regex = <STDIN> );
	$regex = quotemeta( $regex );

	if( $string =~ m/$regex/ ) { ... }

You can also do this directly in the match operator using the C<\Q>
and C<\E> sequences. The C<\Q> tells Perl where to start escaping
special characters, and the C<\E> tells it where to stop (see L<perlop>
for more details).

	chomp( my $regex = <STDIN> );

	if( $string =~ m/\Q$regex\E/ ) { ... }

Alternately, you can use C<qr//>, the regular expression quote operator (see
L<perlop> for more details).  It quotes and perhaps compiles the pattern,
and you can apply regular expression flags to the pattern.

	chomp( my $input = <STDIN> );

	my $regex = qr/$input/is;

	$string =~ m/$regex/  # same as m/$input/is;

You might also want to trap any errors by wrapping an C<eval> block
around the whole thing.

	chomp( my $input = <STDIN> );

	eval {
		if( $string =~ m/\Q$input\E/ ) { ... }
		};
	warn $@@ if $@@;

Or...

	my $regex = eval { qr/$input/is };
	if( defined $regex ) {
		$string =~ m/$regex/;
		}
	else {
		warn $@@;
		}

=head1 REVISION

Revision: $Revision: 10126 $

Date: $Date: 2007-10-27 21:29:20 +0200 (Sat, 27 Oct 2007) $

See L<perlfaq> for source control details and availability.
d892 1
a892 1
Copyright (c) 1997-2007 Tom Christiansen, Nathan Torkington, and
@


1.1.1.10
log
@import perl 5.10.1
@
text
@d3 1
a3 1
perlfaq6 - Regular Expressions
d100 1
a100 1
	$/ = '';  		# read in whole paragraph, not just one line
d110 1
a110 1
	$/ = '';  		# read in whole paragraph, not just one line
a151 41
=head2 How do I match XML, HTML, or other nasty, ugly things with a regex?
X<regex, XML> X<regex, HTML> X<XML> X<HTML> X<pain> X<frustration>
X<sucking out, will to live>

(contributed by brian d foy)

If you just want to get work done, use a module and forget about the
regular expressions. The C<XML::Parser> and C<HTML::Parser> modules
are good starts, although each namespace has other parsing modules
specialized for certain tasks and different ways of doing it. Start at
CPAN Search ( http://search.cpan.org ) and wonder at all the work people
have done for you already! :)

The problem with things such as XML is that they have balanced text
containing multiple levels of balanced text, but sometimes it isn't
balanced text, as in an empty tag (C<< <br/> >>, for instance). Even then,
things can occur out-of-order. Just when you think you've got a
pattern that matches your input, someone throws you a curveball.

If you'd like to do it the hard way, scratching and clawing your way
toward a right answer but constantly being disappointed, beseiged by
bug reports, and weary from the inordinate amount of time you have to
spend reinventing a triangular wheel, then there are several things
you can try before you give up in frustration:

=over 4

=item * Solve the balanced text problem from another question in L<perlfaq6>

=item * Try the recursive regex features in Perl 5.10 and later. See L<perlre>

=item * Try defining a grammar using Perl 5.10's C<(?DEFINE)> feature.

=item * Break the problem down into sub-problems instead of trying to use a single regex

=item * Convince everyone not to use XML or HTML in the first place

=back

Good luck!

d156 1
a156 1
$/ has to be a string.  You can use these examples if you really need to
d172 1
a172 1
You can use the four-argument form of sysread to continually add to
d178 1
a178 1
		while( s/^((?s).*?)your_pattern// ) {
d184 3
a186 3
You can do the same thing with foreach and a match using the
c flag and the \G anchor, if you do not mind your entire file
being in memory at the end.
d227 3
a229 3
	$string = "this is a TEsT case";
	$string =~ s/(test)/preserve_case($1, "success")/egi;
	print "$string\n";
d359 1
a359 1

d370 1
a370 1

d390 1
a390 1

d455 2
a456 2
A slight modification also removes C++ comments, possibly spanning multiple lines
using a continuation character:
d458 1
a458 1
 s#/\*[^*]*\*+([^/*][^*]*\*+)*/|//([^\\]|[^\n][\n]?)*?\n|("(\\.|[^"\\])*"|'(\\.|[^'\\])*'|.[^/"'\\]*)#defined $3 ? $3 : ""#gse;
d462 1
a462 2
X<regular expression, matching balanced test> X<possessive> X<PARNO>
X<Text::Balanced> X<Regexp::Common> X<backtracking> X<recursion>
d464 22
a485 109
(contributed by brian d foy)

Your first try should probably be the C<Text::Balanced> module, which
is in the Perl standard library since Perl 5.8. It has a variety of
functions to deal with tricky text. The C<Regexp::Common> module can
also help by providing canned patterns you can use.

As of Perl 5.10, you can match balanced text with regular expressions
using recursive patterns. Before Perl 5.10, you had to resort to
various tricks such as using Perl code in C<(??{})> sequences.

Here's an example using a recursive regular expression. The goal is to
capture all of the text within angle brackets, including the text in
nested angle brackets. This sample text has two "major" groups: a
group with one level of nesting and a group with two levels of
nesting. There are five total groups in angle brackets:

	I have some <brackets in <nested brackets> > and
	<another group <nested once <nested twice> > >
	and that's it.

The regular expression to match the balanced text  uses two new (to
Perl 5.10) regular expression features. These are covered in L<perlre>
and this example is a modified version of one in that documentation.

First, adding the new possesive C<+> to any quantifier finds the
longest match and does not backtrack. That's important since you want
to handle any angle brackets through the recursion, not backtracking.
The group C<< [^<>]++ >> finds one or more non-angle brackets without
backtracking.

Second, the new C<(?PARNO)> refers to the sub-pattern in the
particular capture buffer given by C<PARNO>. In the following regex,
the first capture buffer finds (and remembers) the balanced text, and
you  need that same pattern within the first buffer to get past the
nested text. That's the recursive part. The C<(?1)> uses the pattern
in the outer capture buffer as an independent part of the regex.

Putting it all together, you have:

	#!/usr/local/bin/perl5.10.0

	my $string =<<"HERE";
	I have some <brackets in <nested brackets> > and
	<another group <nested once <nested twice> > >
	and that's it.
	HERE

	my @@groups = $string =~ m/
			(                   # start of capture buffer 1
			<                   # match an opening angle bracket
				(?:
					[^<>]++     # one or more non angle brackets, non backtracking
					  |
					(?1)        # found < or >, so recurse to capture buffer 1
				)*
			>                   # match a closing angle bracket
			)                   # end of capture buffer 1
			/xg;

	$" = "\n\t";
	print "Found:\n\t@@groups\n";

The output shows that Perl found the two major groups:

	Found:
		<brackets in <nested brackets> >
		<another group <nested once <nested twice> > >

With a little extra work, you can get the all of the groups in angle
brackets even if they are in other angle brackets too. Each time you
get a balanced match, remove its outer delimiter (that's the one you
just matched so don't match it again) and add it to a queue of strings
to process. Keep doing that until you get no matches:

	#!/usr/local/bin/perl5.10.0

	my @@queue =<<"HERE";
	I have some <brackets in <nested brackets> > and
	<another group <nested once <nested twice> > >
	and that's it.
	HERE

	my $regex = qr/
			(                   # start of bracket 1
			<                   # match an opening angle bracket
				(?:
					[^<>]++     # one or more non angle brackets, non backtracking
					  |
					(?1)        # recurse to bracket 1
				)*
			>                   # match a closing angle bracket
			)                   # end of bracket 1
			/x;

	$" = "\n\t";

	while( @@queue )
		{
		my $string = shift @@queue;

		my @@groups = $string =~ m/$regex/g;
		print "Found:\n\t@@groups\n\n" if @@groups;

		unshift @@queue, map { s/^<//; s/>$//; $_ } @@groups;
		}

The output shows all of the groups. The outermost matches show up
first and the nested matches so up later:
d487 2
a488 12
	Found:
		<brackets in <nested brackets> >
		<another group <nested once <nested twice> > >

	Found:
		<nested brackets>

	Found:
		<nested once <nested twice> >

	Found:
		<nested twice>
d578 1
a578 1
the regular expression for every iteration of the C<foreach>
d595 1
a595 1
The C<qr//> operator showed up in perl 5.005.  It compiles a
d598 1
a598 1
this example, I inserted a C<map> to turn each pattern into
d608 2
a609 5
			if( /$pattern/ )
				{
				print;
				next LINE;
				}
d624 2
a625 2
For more details on regular expression efficiency, see I<Mastering
Regular Expressions> by Jeffrey Freidl.  He explains how regular
a708 5
Perl 5.10 added three specials, C<${^MATCH}>, C<${^PREMATCH}>, and
C<${^POSTMATCH}> to do the same job but without the global performance
penalty. Perl 5.10 only sets these variables if you compile or execute the
regular expression with the C</p> modifier.

d986 1
a986 1
Revision: $Revision$
d988 1
a988 1
Date: $Date$
d994 1
a994 1
Copyright (c) 1997-2009 Tom Christiansen, Nathan Torkington, and
@


1.1.1.11
log
@Perl 5.12.2 from CPAN
@
text
@d36 3
a38 3
(except in a character class and a few other places), and also allows you to
use normal comments there, too.  As you can imagine, whitespace and comments
help a lot.
d172 1
a172 1
toward a right answer but constantly being disappointed, besieged by
d531 1
a531 1
First, adding the new possessive C<+> to any quantifier finds the
d716 1
a716 1
you want to match it. In this example, perl must recompile
d738 1
a738 1
its pre-compiled form. The rest of the script is the same,
d756 1
a756 1
a single regular expression. Beware of situations that require
d1131 8
d1141 1
a1141 1
Copyright (c) 1997-2010 Tom Christiansen, Nathan Torkington, and
@


