head	1.15;
access;
symbols
	OPENBSD_5_3:1.14.0.10
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.8
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.6
	OPENBSD_5_0:1.14.0.4
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	PERL_5_12_2:1.1.1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	PERL_5_10_1:1.1.1.10
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	PERL_5_10_0:1.1.1.9
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	PERL_5_8_8:1.1.1.8
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	PERL_5_8_6:1.1.1.7
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.15
date	2013.03.25.20.40.58;	author sthen;	state dead;
branches;
next	1.14;

1.14
date	2010.10.02.20.58.35;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2010.10.02.19.48.12;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2010.09.24.15.07.04;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.12.18.24.47;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.29.17.36.16;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.28.19.23.10;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2005.01.15.21.30.36;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2004.08.09.18.10.15;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.03.03.02.45;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.33;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.24.18.35.54;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.07.28;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.04.29.22.52.12;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.11.30.07.59.12;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.40.44;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.10.24;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.24.37;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.04;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.44.21;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.08.09.17.48.13;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2005.01.15.21.17.54;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2006.03.28.18.49.18;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2008.09.29.17.18.51;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2009.10.12.18.10.38;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2010.09.24.14.49.11;	author millert;	state Exp;
branches;
next	;


desc
@perl 5.004_04
@


1.15
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@=head1 NAME

perlfaq8 - System Interaction

=head1 DESCRIPTION

This section of the Perl FAQ covers questions involving operating
system interaction.  Topics include interprocess communication (IPC),
control over the user-interface (keyboard, screen and pointing
devices), and most anything else not related to data manipulation.

Read the FAQs and documentation specific to the port of perl to your
operating system (eg, L<perlvms>, L<perlplan9>, ...).  These should
contain more detailed information on the vagaries of your perl.

=head2 How do I find out which operating system I'm running under?

The C<$^O> variable (C<$OSNAME> if you use C<English>) contains an
indication of the name of the operating system (not its release
number) that your perl binary was built for.

=head2 How come exec() doesn't return?
X<exec> X<system> X<fork> X<open> X<pipe>

(contributed by brian d foy)

The C<exec> function's job is to turn your process into another
command and never to return. If that's not what you want to do, don't
use C<exec>. :)

If you want to run an external command and still keep your Perl process
going, look at a piped C<open>, C<fork>, or C<system>.

=head2 How do I do fancy stuff with the keyboard/screen/mouse?

How you access/control keyboards, screens, and pointing devices
("mice") is system-dependent.  Try the following modules:

=over 4

=item Keyboard

	Term::Cap               Standard perl distribution
	Term::ReadKey           CPAN
	Term::ReadLine::Gnu     CPAN
	Term::ReadLine::Perl    CPAN
	Term::Screen            CPAN

=item Screen

	Term::Cap               Standard perl distribution
	Curses                  CPAN
	Term::ANSIColor         CPAN

=item Mouse

	Tk                      CPAN

=back

Some of these specific cases are shown as examples in other answers
in this section of the perlfaq.

=head2 How do I print something out in color?

In general, you don't, because you don't know whether
the recipient has a color-aware display device.  If you
know that they have an ANSI terminal that understands
color, you can use the C<Term::ANSIColor> module from CPAN:

	use Term::ANSIColor;
	print color("red"), "Stop!\n", color("reset");
	print color("green"), "Go!\n", color("reset");

Or like this:

	use Term::ANSIColor qw(:constants);
	print RED, "Stop!\n", RESET;
	print GREEN, "Go!\n", RESET;

=head2 How do I read just one key without waiting for a return key?

Controlling input buffering is a remarkably system-dependent matter.
On many systems, you can just use the B<stty> command as shown in
L<perlfunc/getc>, but as you see, that's already getting you into
portability snags.

	open(TTY, "+</dev/tty") or die "no tty: $!";
	system "stty  cbreak </dev/tty >/dev/tty 2>&1";
	$key = getc(TTY);		# perhaps this works
	# OR ELSE
	sysread(TTY, $key, 1);	# probably this does
	system "stty -cbreak </dev/tty >/dev/tty 2>&1";

The C<Term::ReadKey> module from CPAN offers an easy-to-use interface that
should be more efficient than shelling out to B<stty> for each key.
It even includes limited support for Windows.

	use Term::ReadKey;
	ReadMode('cbreak');
	$key = ReadKey(0);
	ReadMode('normal');

However, using the code requires that you have a working C compiler
and can use it to build and install a CPAN module.  Here's a solution
using the standard C<POSIX> module, which is already on your system
(assuming your system supports POSIX).

	use HotKey;
	$key = readkey();

And here's the C<HotKey> module, which hides the somewhat mystifying calls
to manipulate the POSIX termios structures.

	# HotKey.pm
	package HotKey;

	@@ISA = qw(Exporter);
	@@EXPORT = qw(cbreak cooked readkey);

	use strict;
	use POSIX qw(:termios_h);
	my ($term, $oterm, $echo, $noecho, $fd_stdin);

	$fd_stdin = fileno(STDIN);
	$term     = POSIX::Termios->new();
	$term->getattr($fd_stdin);
	$oterm     = $term->getlflag();

	$echo     = ECHO | ECHOK | ICANON;
	$noecho   = $oterm & ~$echo;

	sub cbreak {
		$term->setlflag($noecho);  # ok, so i don't want echo either
		$term->setcc(VTIME, 1);
		$term->setattr($fd_stdin, TCSANOW);
	}

	sub cooked {
		$term->setlflag($oterm);
		$term->setcc(VTIME, 0);
		$term->setattr($fd_stdin, TCSANOW);
	}

	sub readkey {
		my $key = '';
		cbreak();
		sysread(STDIN, $key, 1);
		cooked();
		return $key;
	}

	END { cooked() }

	1;

=head2 How do I check whether input is ready on the keyboard?

The easiest way to do this is to read a key in nonblocking mode with the
C<Term::ReadKey> module from CPAN, passing it an argument of -1 to indicate
not to block:

	use Term::ReadKey;

	ReadMode('cbreak');

	if (defined ($char = ReadKey(-1)) ) {
		# input was waiting and it was $char
	} else {
		# no input was waiting
	}

	ReadMode('normal');                  # restore normal tty settings

=head2 How do I clear the screen?

(contributed by brian d foy)

To clear the screen, you just have to print the special sequence
that tells the terminal to clear the screen. Once you have that
sequence, output it when you want to clear the screen.

You can use the C<Term::ANSIScreen> module to get the special
sequence. Import the C<cls> function (or the C<:screen> tag):

	use Term::ANSIScreen qw(cls);
	my $clear_screen = cls();

	print $clear_screen;

The C<Term::Cap> module can also get the special sequence if you want
to deal with the low-level details of terminal control. The C<Tputs>
method returns the string for the given capability:

	use Term::Cap;

	$terminal = Term::Cap->Tgetent( { OSPEED => 9600 } );
	$clear_string = $terminal->Tputs('cl');

	print $clear_screen;

On Windows, you can use the C<Win32::Console> module. After creating
an object for the output filehandle you want to affect, call the
C<Cls> method:

	Win32::Console;

	$OUT = Win32::Console->new(STD_OUTPUT_HANDLE);
	my $clear_string = $OUT->Cls;

	print $clear_screen;

If you have a command-line program that does the job, you can call
it in backticks to capture whatever it outputs so you can use it
later:

	$clear_string = `clear`;

	print $clear_string;

=head2 How do I get the screen size?

If you have C<Term::ReadKey> module installed from CPAN,
you can use it to fetch the width and height in characters
and in pixels:

	use Term::ReadKey;
	($wchar, $hchar, $wpixels, $hpixels) = GetTerminalSize();

This is more portable than the raw C<ioctl>, but not as
illustrative:

	require 'sys/ioctl.ph';
	die "no TIOCGWINSZ " unless defined &TIOCGWINSZ;
	open(TTY, "+</dev/tty")                     or die "No tty: $!";
	unless (ioctl(TTY, &TIOCGWINSZ, $winsize='')) {
		die sprintf "$0: ioctl TIOCGWINSZ (%08x: $!)\n", &TIOCGWINSZ;
	}
	($row, $col, $xpixel, $ypixel) = unpack('S4', $winsize);
	print "(row,col) = ($row,$col)";
	print "  (xpixel,ypixel) = ($xpixel,$ypixel)" if $xpixel || $ypixel;
	print "\n";

=head2 How do I ask the user for a password?

(This question has nothing to do with the web.  See a different
FAQ for that.)

There's an example of this in L<perlfunc/crypt>).  First, you put the
terminal into "no echo" mode, then just read the password normally.
You may do this with an old-style C<ioctl()> function, POSIX terminal
control (see L<POSIX> or its documentation the Camel Book), or a call
to the B<stty> program, with varying degrees of portability.

You can also do this for most systems using the C<Term::ReadKey> module
from CPAN, which is easier to use and in theory more portable.

	use Term::ReadKey;

	ReadMode('noecho');
	$password = ReadLine(0);

=head2 How do I read and write the serial port?

This depends on which operating system your program is running on.  In
the case of Unix, the serial ports will be accessible through files in
/dev; on other systems, device names will doubtless differ.
Several problem areas common to all device interaction are the
following:

=over 4

=item lockfiles

Your system may use lockfiles to control multiple access.  Make sure
you follow the correct protocol.  Unpredictable behavior can result
from multiple processes reading from one device.

=item open mode

If you expect to use both read and write operations on the device,
you'll have to open it for update (see L<perlfunc/"open"> for
details).  You may wish to open it without running the risk of
blocking by using C<sysopen()> and C<O_RDWR|O_NDELAY|O_NOCTTY> from the
C<Fcntl> module (part of the standard perl distribution).  See
L<perlfunc/"sysopen"> for more on this approach.

=item end of line

Some devices will be expecting a "\r" at the end of each line rather
than a "\n".  In some ports of perl, "\r" and "\n" are different from
their usual (Unix) ASCII values of "\012" and "\015".  You may have to
give the numeric values you want directly, using octal ("\015"), hex
("0x0D"), or as a control-character specification ("\cM").

	print DEV "atv1\012";	# wrong, for some devices
	print DEV "atv1\015";	# right, for some devices

Even though with normal text files a "\n" will do the trick, there is
still no unified scheme for terminating a line that is portable
between Unix, DOS/Win, and Macintosh, except to terminate I<ALL> line
ends with "\015\012", and strip what you don't need from the output.
This applies especially to socket I/O and autoflushing, discussed
next.

=item flushing output

If you expect characters to get to your device when you C<print()> them,
you'll want to autoflush that filehandle.  You can use C<select()>
and the C<$|> variable to control autoflushing (see L<perlvar/$E<verbar>>
and L<perlfunc/select>, or L<perlfaq5>, "How do I flush/unbuffer an
output filehandle?  Why must I do this?"):

	$oldh = select(DEV);
	$| = 1;
	select($oldh);

You'll also see code that does this without a temporary variable, as in

	select((select(DEV), $| = 1)[0]);

Or if you don't mind pulling in a few thousand lines
of code just because you're afraid of a little C<$|> variable:

	use IO::Handle;
	DEV->autoflush(1);

As mentioned in the previous item, this still doesn't work when using
socket I/O between Unix and Macintosh.  You'll need to hard code your
line terminators, in that case.

=item non-blocking input

If you are doing a blocking C<read()> or C<sysread()>, you'll have to
arrange for an alarm handler to provide a timeout (see
L<perlfunc/alarm>).  If you have a non-blocking open, you'll likely
have a non-blocking read, which means you may have to use a 4-arg
C<select()> to determine whether I/O is ready on that device (see
L<perlfunc/"select">.

=back

While trying to read from his caller-id box, the notorious Jamie
Zawinski C<< <jwz@@netscape.com> >>, after much gnashing of teeth and
fighting with C<sysread>, C<sysopen>, POSIX's C<tcgetattr> business,
and various other functions that go bump in the night, finally came up
with this:

	sub open_modem {
		use IPC::Open2;
		my $stty = `/bin/stty -g`;
		open2( \*MODEM_IN, \*MODEM_OUT, "cu -l$modem_device -s2400 2>&1");
		# starting cu hoses /dev/tty's stty settings, even when it has
		# been opened on a pipe...
		system("/bin/stty $stty");
		$_ = <MODEM_IN>;
		chomp;
		if ( !m/^Connected/ ) {
			print STDERR "$0: cu printed `$_' instead of `Connected'\n";
		}
	}

=head2 How do I decode encrypted password files?

You spend lots and lots of money on dedicated hardware, but this is
bound to get you talked about.

Seriously, you can't if they are Unix password files--the Unix
password system employs one-way encryption.  It's more like hashing
than encryption.  The best you can do is check whether something else
hashes to the same string.  You can't turn a hash back into the
original string. Programs like Crack can forcibly (and intelligently)
try to guess passwords, but don't (can't) guarantee quick success.

If you're worried about users selecting bad passwords, you should
proactively check when they try to change their password (by modifying
passwd(1), for example).

=head2 How do I start a process in the background?

(contributed by brian d foy)

There's not a single way to run code in the background so you don't
have to wait for it to finish before your program moves on to other
tasks. Process management depends on your particular operating system,
and many of the techniques are in L<perlipc>.

Several CPAN modules may be able to help, including C<IPC::Open2> or
C<IPC::Open3>, C<IPC::Run>, C<Parallel::Jobs>,
C<Parallel::ForkManager>, C<POE>, C<Proc::Background>, and
C<Win32::Process>. There are many other modules you might use, so
check those namespaces for other options too.

If you are on a Unix-like system, you might be able to get away with a
system call where you put an C<&> on the end of the command:

	system("cmd &")

You can also try using C<fork>, as described in L<perlfunc> (although
this is the same thing that many of the modules will do for you).

=over 4

=item STDIN, STDOUT, and STDERR are shared

Both the main process and the backgrounded one (the "child" process)
share the same STDIN, STDOUT and STDERR filehandles.  If both try to
access them at once, strange things can happen.  You may want to close
or reopen these for the child.  You can get around this with
C<open>ing a pipe (see L<perlfunc/"open">) but on some systems this
means that the child process cannot outlive the parent.

=item Signals

You'll have to catch the SIGCHLD signal, and possibly SIGPIPE too.
SIGCHLD is sent when the backgrounded process finishes.  SIGPIPE is
sent when you write to a filehandle whose child process has closed (an
untrapped SIGPIPE can cause your program to silently die).  This is
not an issue with C<system("cmd&")>.

=item Zombies

You have to be prepared to "reap" the child process when it finishes.

	$SIG{CHLD} = sub { wait };

	$SIG{CHLD} = 'IGNORE';

You can also use a double fork. You immediately C<wait()> for your
first child, and the init daemon will C<wait()> for your grandchild once
it exits.

	unless ($pid = fork) {
	    unless (fork) {
		exec "what you really wanna do";
		die "exec failed!";
	    }
	    exit 0;
	}
	waitpid($pid, 0);

See L<perlipc/"Signals"> for other examples of code to do this.
Zombies are not an issue with C<system("prog &")>.

=back

=head2 How do I trap control characters/signals?

You don't actually "trap" a control character.  Instead, that character
generates a signal which is sent to your terminal's currently
foregrounded process group, which you then trap in your process.
Signals are documented in L<perlipc/"Signals"> and the
section on "Signals" in the Camel.

You can set the values of the C<%SIG> hash to be the functions you want
to handle the signal.  After perl catches the signal, it looks in C<%SIG>
for a key with the same name as the signal, then calls the subroutine
value for that key.

	# as an anonymous subroutine

	$SIG{INT} = sub { syswrite(STDERR, "ouch\n", 5 ) };

	# or a reference to a function

	$SIG{INT} = \&ouch;

	# or the name of the function as a string

	$SIG{INT} = "ouch";

Perl versions before 5.8 had in its C source code signal handlers which
would catch the signal and possibly run a Perl function that you had set
in C<%SIG>.  This violated the rules of signal handling at that level
causing perl to dump core. Since version 5.8.0, perl looks at C<%SIG>
B<after> the signal has been caught, rather than while it is being caught.
Previous versions of this answer were incorrect.

=head2 How do I modify the shadow password file on a Unix system?

If perl was installed correctly and your shadow library was written
properly, the C<getpw*()> functions described in L<perlfunc> should in
theory provide (read-only) access to entries in the shadow password
file.  To change the file, make a new shadow password file (the format
varies from system to system--see L<passwd> for specifics) and use
C<pwd_mkdb(8)> to install it (see L<pwd_mkdb> for more details).

=head2 How do I set the time and date?

Assuming you're running under sufficient permissions, you should be
able to set the system-wide date and time by running the C<date(1)>
program.  (There is no way to set the time and date on a per-process
basis.)  This mechanism will work for Unix, MS-DOS, Windows, and NT;
the VMS equivalent is C<set time>.

However, if all you want to do is change your time zone, you can
probably get away with setting an environment variable:

	$ENV{TZ} = "MST7MDT";		   # Unixish
	$ENV{'SYS$TIMEZONE_DIFFERENTIAL'}="-5" # vms
	system "trn comp.lang.perl.misc";

=head2 How can I sleep() or alarm() for under a second?
X<Time::HiRes> X<BSD::Itimer> X<sleep> X<select>

If you want finer granularity than the 1 second that the C<sleep()>
function provides, the easiest way is to use the C<select()> function as
documented in L<perlfunc/"select">.  Try the C<Time::HiRes> and
the C<BSD::Itimer> modules (available from CPAN, and starting from
Perl 5.8 C<Time::HiRes> is part of the standard distribution).

=head2 How can I measure time under a second?
X<Time::HiRes> X<BSD::Itimer> X<sleep> X<select>

(contributed by brian d foy)

The C<Time::HiRes> module (part of the standard distribution as of
Perl 5.8) measures time with the C<gettimeofday()> system call, which
returns the time in microseconds since the epoch. If you can't install
C<Time::HiRes> for older Perls and you are on a Unixish system, you
may be able to call C<gettimeofday(2)> directly. See
L<perlfunc/syscall>.

=head2 How can I do an atexit() or setjmp()/longjmp()? (Exception handling)

You can use the C<END> block to simulate C<atexit()>. Each package's
C<END> block is called when the program or thread ends See L<perlmod>
manpage for more details about C<END> blocks.

For example, you can use this to make sure your filter program managed
to finish its output without filling up the disk:

	END {
		close(STDOUT) || die "stdout close failed: $!";
	}

The C<END> block isn't called when untrapped signals kill the program,
though, so if you use C<END> blocks you should also use

	use sigtrap qw(die normal-signals);

Perl's exception-handling mechanism is its C<eval()> operator.  You
can use C<eval()> as C<setjmp> and C<die()> as C<longjmp>. For
details of this, see the section on signals, especially the time-out
handler for a blocking C<flock()> in L<perlipc/"Signals"> or the
section on "Signals" in I<Programming Perl>.

If exception handling is all you're interested in, use one of the 
many CPAN modules that handle exceptions, such as C<Try::Tiny>.

If you want the C<atexit()> syntax (and an C<rmexit()> as well), try the
C<AtExit> module available from CPAN.

=head2 Why doesn't my sockets program work under System V (Solaris)?  What does the error message "Protocol not supported" mean?

Some Sys-V based systems, notably Solaris 2.X, redefined some of the
standard socket constants.  Since these were constant across all
architectures, they were often hardwired into perl code.  The proper
way to deal with this is to "use Socket" to get the correct values.

Note that even though SunOS and Solaris are binary compatible, these
values are different.  Go figure.

=head2 How can I call my system's unique C functions from Perl?

In most cases, you write an external module to do it--see the answer
to "Where can I learn about linking C with Perl? [h2xs, xsubpp]".
However, if the function is a system call, and your system supports
C<syscall()>, you can use the C<syscall> function (documented in
L<perlfunc>).

Remember to check the modules that came with your distribution, and
CPAN as well--someone may already have written a module to do it. On
Windows, try C<Win32::API>.  On Macs, try C<Mac::Carbon>.  If no module
has an interface to the C function, you can inline a bit of C in your
Perl source with C<Inline::C>.

=head2 Where do I get the include files to do ioctl() or syscall()?

Historically, these would be generated by the C<h2ph> tool, part of the
standard perl distribution.  This program converts C<cpp(1)> directives
in C header files to files containing subroutine definitions, like
C<&SYS_getitimer>, which you can use as arguments to your functions.
It doesn't work perfectly, but it usually gets most of the job done.
Simple files like F<errno.h>, F<syscall.h>, and F<socket.h> were fine,
but the hard ones like F<ioctl.h> nearly always need to be hand-edited.
Here's how to install the *.ph files:

	1.  become super-user
	2.  cd /usr/include
	3.  h2ph *.h */*.h

If your system supports dynamic loading, for reasons of portability and
sanity you probably ought to use C<h2xs> (also part of the standard perl
distribution).  This tool converts C header files to Perl extensions.
See L<perlxstut> for how to get started with C<h2xs>.

If your system doesn't support dynamic loading, you still probably
ought to use C<h2xs>.  See L<perlxstut> and L<ExtUtils::MakeMaker> for
more information (in brief, just use B<make perl> instead of a plain
B<make> to rebuild perl with a new static extension).

=head2 Why do setuid perl scripts complain about kernel problems?

Some operating systems have bugs in the kernel that make setuid
scripts inherently insecure.  Perl gives you a number of options
(described in L<perlsec>) to work around such systems.

=head2 How can I open a pipe both to and from a command?

The C<IPC::Open2> module (part of the standard perl distribution) is
an easy-to-use approach that internally uses C<pipe()>, C<fork()>, and
C<exec()> to do the job.  Make sure you read the deadlock warnings in
its documentation, though (see L<IPC::Open2>).  See
L<perlipc/"Bidirectional Communication with Another Process"> and
L<perlipc/"Bidirectional Communication with Yourself">

You may also use the C<IPC::Open3> module (part of the standard perl
distribution), but be warned that it has a different order of
arguments from C<IPC::Open2> (see L<IPC::Open3>).

=head2 Why can't I get the output of a command with system()?

You're confusing the purpose of C<system()> and backticks (``).  C<system()>
runs a command and returns exit status information (as a 16 bit value:
the low 7 bits are the signal the process died from, if any, and
the high 8 bits are the actual exit value).  Backticks (``) run a
command and return what it sent to STDOUT.

	$exit_status   = system("mail-users");
	$output_string = `ls`;

=head2 How can I capture STDERR from an external command?

There are three basic ways of running external commands:

	system $cmd;		# using system()
	$output = `$cmd`;		# using backticks (``)
	open (PIPE, "cmd |");	# using open()

With C<system()>, both STDOUT and STDERR will go the same place as the
script's STDOUT and STDERR, unless the C<system()> command redirects them.
Backticks and C<open()> read B<only> the STDOUT of your command.

You can also use the C<open3()> function from C<IPC::Open3>.  Benjamin
Goldberg provides some sample code:

To capture a program's STDOUT, but discard its STDERR:

	use IPC::Open3;
	use File::Spec;
	use Symbol qw(gensym);
	open(NULL, ">", File::Spec->devnull);
	my $pid = open3(gensym, \*PH, ">&NULL", "cmd");
	while( <PH> ) { }
	waitpid($pid, 0);

To capture a program's STDERR, but discard its STDOUT:

	use IPC::Open3;
	use File::Spec;
	use Symbol qw(gensym);
	open(NULL, ">", File::Spec->devnull);
	my $pid = open3(gensym, ">&NULL", \*PH, "cmd");
	while( <PH> ) { }
	waitpid($pid, 0);

To capture a program's STDERR, and let its STDOUT go to our own STDERR:

	use IPC::Open3;
	use Symbol qw(gensym);
	my $pid = open3(gensym, ">&STDERR", \*PH, "cmd");
	while( <PH> ) { }
	waitpid($pid, 0);

To read both a command's STDOUT and its STDERR separately, you can
redirect them to temp files, let the command run, then read the temp
files:

	use IPC::Open3;
	use Symbol qw(gensym);
	use IO::File;
	local *CATCHOUT = IO::File->new_tmpfile;
	local *CATCHERR = IO::File->new_tmpfile;
	my $pid = open3(gensym, ">&CATCHOUT", ">&CATCHERR", "cmd");
	waitpid($pid, 0);
	seek $_, 0, 0 for \*CATCHOUT, \*CATCHERR;
	while( <CATCHOUT> ) {}
	while( <CATCHERR> ) {}

But there's no real need for B<both> to be tempfiles... the following
should work just as well, without deadlocking:

	use IPC::Open3;
	use Symbol qw(gensym);
	use IO::File;
	local *CATCHERR = IO::File->new_tmpfile;
	my $pid = open3(gensym, \*CATCHOUT, ">&CATCHERR", "cmd");
	while( <CATCHOUT> ) {}
	waitpid($pid, 0);
	seek CATCHERR, 0, 0;
	while( <CATCHERR> ) {}

And it'll be faster, too, since we can begin processing the program's
stdout immediately, rather than waiting for the program to finish.

With any of these, you can change file descriptors before the call:

	open(STDOUT, ">logfile");
	system("ls");

or you can use Bourne shell file-descriptor redirection:

	$output = `$cmd 2>some_file`;
	open (PIPE, "cmd 2>some_file |");

You can also use file-descriptor redirection to make STDERR a
duplicate of STDOUT:

	$output = `$cmd 2>&1`;
	open (PIPE, "cmd 2>&1 |");

Note that you I<cannot> simply open STDERR to be a dup of STDOUT
in your Perl program and avoid calling the shell to do the redirection.
This doesn't work:

	open(STDERR, ">&STDOUT");
	$alloutput = `cmd args`;  # stderr still escapes

This fails because the C<open()> makes STDERR go to where STDOUT was
going at the time of the C<open()>.  The backticks then make STDOUT go to
a string, but don't change STDERR (which still goes to the old
STDOUT).

Note that you I<must> use Bourne shell (C<sh(1)>) redirection syntax in
backticks, not C<csh(1)>!  Details on why Perl's C<system()> and backtick
and pipe opens all use the Bourne shell are in the
F<versus/csh.whynot> article in the "Far More Than You Ever Wanted To
Know" collection in http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz .  To
capture a command's STDERR and STDOUT together:

	$output = `cmd 2>&1`;                       # either with backticks
	$pid = open(PH, "cmd 2>&1 |");              # or with an open pipe
	while (<PH>) { }                            #    plus a read

To capture a command's STDOUT but discard its STDERR:

	$output = `cmd 2>/dev/null`;                # either with backticks
	$pid = open(PH, "cmd 2>/dev/null |");       # or with an open pipe
	while (<PH>) { }                            #    plus a read

To capture a command's STDERR but discard its STDOUT:

	$output = `cmd 2>&1 1>/dev/null`;           # either with backticks
	$pid = open(PH, "cmd 2>&1 1>/dev/null |");  # or with an open pipe
	while (<PH>) { }                            #    plus a read

To exchange a command's STDOUT and STDERR in order to capture the STDERR
but leave its STDOUT to come out our old STDERR:

	$output = `cmd 3>&1 1>&2 2>&3 3>&-`;        # either with backticks
	$pid = open(PH, "cmd 3>&1 1>&2 2>&3 3>&-|");# or with an open pipe
	while (<PH>) { }                            #    plus a read

To read both a command's STDOUT and its STDERR separately, it's easiest
to redirect them separately to files, and then read from those files
when the program is done:

	system("program args 1>program.stdout 2>program.stderr");

Ordering is important in all these examples.  That's because the shell
processes file descriptor redirections in strictly left to right order.

	system("prog args 1>tmpfile 2>&1");
	system("prog args 2>&1 1>tmpfile");

The first command sends both standard out and standard error to the
temporary file.  The second command sends only the old standard output
there, and the old standard error shows up on the old standard out.

=head2 Why doesn't open() return an error when a pipe open fails?

If the second argument to a piped C<open()> contains shell
metacharacters, perl C<fork()>s, then C<exec()>s a shell to decode the
metacharacters and eventually run the desired program.  If the program
couldn't be run, it's the shell that gets the message, not Perl. All
your Perl program can find out is whether the shell itself could be
successfully started.  You can still capture the shell's STDERR and
check it for error messages.  See L<"How can I capture STDERR from an
external command?"> elsewhere in this document, or use the
C<IPC::Open3> module.

If there are no shell metacharacters in the argument of C<open()>, Perl
runs the command directly, without using the shell, and can correctly
report whether the command started.

=head2 What's wrong with using backticks in a void context?

Strictly speaking, nothing.  Stylistically speaking, it's not a good
way to write maintainable code.  Perl has several operators for
running external commands.  Backticks are one; they collect the output
from the command for use in your program.  The C<system> function is
another; it doesn't do this.

Writing backticks in your program sends a clear message to the readers
of your code that you wanted to collect the output of the command.
Why send a clear message that isn't true?

Consider this line:

	`cat /etc/termcap`;

You forgot to check C<$?> to see whether the program even ran
correctly.  Even if you wrote

	print `cat /etc/termcap`;

this code could and probably should be written as

	system("cat /etc/termcap") == 0
	or die "cat program failed!";

which will echo the cat command's output as it is generated, instead
of waiting until the program has completed to print it out. It also
checks the return value.

C<system> also provides direct control over whether shell wildcard
processing may take place, whereas backticks do not.

=head2 How can I call backticks without shell processing?

This is a bit tricky.  You can't simply write the command
like this:

	@@ok = `grep @@opts '$search_string' @@filenames`;

As of Perl 5.8.0, you can use C<open()> with multiple arguments.
Just like the list forms of C<system()> and C<exec()>, no shell
escapes happen.

	open( GREP, "-|", 'grep', @@opts, $search_string, @@filenames );
	chomp(@@ok = <GREP>);
	close GREP;

You can also:

	my @@ok = ();
	if (open(GREP, "-|")) {
		while (<GREP>) {
			chomp;
			push(@@ok, $_);
		}
		close GREP;
	} else {
		exec 'grep', @@opts, $search_string, @@filenames;
	}

Just as with C<system()>, no shell escapes happen when you C<exec()> a
list. Further examples of this can be found in L<perlipc/"Safe Pipe
Opens">.

Note that if you're using Windows, no solution to this vexing issue is
even possible.  Even if Perl were to emulate C<fork()>, you'd still be
stuck, because Windows does not have an argc/argv-style API.

=head2 Why can't my script read from STDIN after I gave it EOF (^D on Unix, ^Z on MS-DOS)?

This happens only if your perl is compiled to use stdio instead of
perlio, which is the default. Some (maybe all?) stdios set error and
eof flags that you may need to clear. The C<POSIX> module defines
C<clearerr()> that you can use.  That is the technically correct way to
do it.  Here are some less reliable workarounds:

=over 4

=item 1

Try keeping around the seekpointer and go there, like this:

	$where = tell(LOG);
	seek(LOG, $where, 0);

=item 2

If that doesn't work, try seeking to a different part of the file and
then back.

=item 3

If that doesn't work, try seeking to a different part of
the file, reading something, and then seeking back.

=item 4

If that doesn't work, give up on your stdio package and use sysread.

=back

=head2 How can I convert my shell script to perl?

Learn Perl and rewrite it.  Seriously, there's no simple converter.
Things that are awkward to do in the shell are easy to do in Perl, and
this very awkwardness is what would make a shell->perl converter
nigh-on impossible to write.  By rewriting it, you'll think about what
you're really trying to do, and hopefully will escape the shell's
pipeline datastream paradigm, which while convenient for some matters,
causes many inefficiencies.

=head2 Can I use perl to run a telnet or ftp session?

Try the C<Net::FTP>, C<TCP::Client>, and C<Net::Telnet> modules
(available from CPAN).
http://www.cpan.org/scripts/netstuff/telnet.emul.shar will also help
for emulating the telnet protocol, but C<Net::Telnet> is quite
probably easier to use.

If all you want to do is pretend to be telnet but don't need
the initial telnet handshaking, then the standard dual-process
approach will suffice:

	use IO::Socket;             # new in 5.004
	$handle = IO::Socket::INET->new('www.perl.com:80')
	    or die "can't connect to port 80 on www.perl.com: $!";
	$handle->autoflush(1);
	if (fork()) {               # XXX: undef means failure
	    select($handle);
	    print while <STDIN>;    # everything from stdin to socket
	} else {
	    print while <$handle>;  # everything from socket to stdout
	}
	close $handle;
	exit;

=head2 How can I write expect in Perl?

Once upon a time, there was a library called L<chat2.pl> (part of the
standard perl distribution), which never really got finished.  If you
find it somewhere, I<don't use it>.  These days, your best bet is to
look at the Expect module available from CPAN, which also requires two
other modules from CPAN, C<IO::Pty> and C<IO::Stty>.

=head2 Is there a way to hide perl's command line from programs such as "ps"?

First of all note that if you're doing this for security reasons (to
avoid people seeing passwords, for example) then you should rewrite
your program so that critical information is never given as an
argument.  Hiding the arguments won't make your program completely
secure.

To actually alter the visible command line, you can assign to the
variable $0 as documented in L<perlvar>.  This won't work on all
operating systems, though.  Daemon programs like sendmail place their
state there, as in:

	$0 = "orcus [accepting connections]";

=head2 I {changed directory, modified my environment} in a perl script.  How come the change disappeared when I exited the script?  How do I get my changes to be visible?

=over 4

=item Unix

In the strictest sense, it can't be done--the script executes as a
different process from the shell it was started from.  Changes to a
process are not reflected in its parent--only in any children
created after the change.  There is shell magic that may allow you to
fake it by C<eval()>ing the script's output in your shell; check out the
comp.unix.questions FAQ for details.

=back

=head2 How do I close a process's filehandle without waiting for it to complete?

Assuming your system supports such things, just send an appropriate signal
to the process (see L<perlfunc/"kill">).  It's common to first send a TERM
signal, wait a little bit, and then send a KILL signal to finish it off.

=head2 How do I fork a daemon process?

If by daemon process you mean one that's detached (disassociated from
its tty), then the following process is reported to work on most
Unixish systems.  Non-Unix users should check their Your_OS::Process
module for other solutions.

=over 4

=item *

Open /dev/tty and use the TIOCNOTTY ioctl on it.  See L<tty>
for details.  Or better yet, you can just use the C<POSIX::setsid()>
function, so you don't have to worry about process groups.

=item *

Change directory to /

=item *

Reopen STDIN, STDOUT, and STDERR so they're not connected to the old
tty.

=item *

Background yourself like this:

	fork && exit;

=back

The C<Proc::Daemon> module, available from CPAN, provides a function to
perform these actions for you.

=head2 How do I find out if I'm running interactively or not?

(contributed by brian d foy)

This is a difficult question to answer, and the best answer is
only a guess.

What do you really want to know? If you merely want to know if one of
your filehandles is connected to a terminal, you can try the C<-t>
file test:

	if( -t STDOUT ) {
		print "I'm connected to a terminal!\n";
		}

However, you might be out of luck if you expect that means there is a
real person on the other side. With the C<Expect> module, another
program can pretend to be a person. The program might even come close
to passing the Turing test.

The C<IO::Interactive> module does the best it can to give you an
answer. Its C<is_interactive> function returns an output filehandle;
that filehandle points to standard output if the module thinks the
session is interactive. Otherwise, the filehandle is a null handle
that simply discards the output:

	use IO::Interactive;

	print { is_interactive } "I might go to standard output!\n";

This still doesn't guarantee that a real person is answering your
prompts or reading your output.

If you want to know how to handle automated testing for your
distribution, you can check the environment. The CPAN
Testers, for instance, set the value of C<AUTOMATED_TESTING>:

	unless( $ENV{AUTOMATED_TESTING} ) {
		print "Hello interactive tester!\n";
		}

=head2 How do I timeout a slow event?

Use the C<alarm()> function, probably in conjunction with a signal
handler, as documented in L<perlipc/"Signals"> and the section on
"Signals" in the Camel.  You may instead use the more flexible
C<Sys::AlarmCall> module available from CPAN.

The C<alarm()> function is not implemented on all versions of Windows.
Check the documentation for your specific version of Perl.

=head2 How do I set CPU limits?
X<BSD::Resource> X<limit> X<CPU>

(contributed by Xho)

Use the C<BSD::Resource> module from CPAN. As an example:

	use BSD::Resource;
	setrlimit(RLIMIT_CPU,10,20) or die $!;

This sets the soft and hard limits to 10 and 20 seconds, respectively.
After 10 seconds of time spent running on the CPU (not "wall" time),
the process will be sent a signal (XCPU on some systems) which, if not
trapped, will cause the process to terminate.  If that signal is
trapped, then after 10 more seconds (20 seconds in total) the process
will be killed with a non-trappable signal.

See the C<BSD::Resource> and your systems documentation for the gory
details.

=head2 How do I avoid zombies on a Unix system?

Use the reaper code from L<perlipc/"Signals"> to call C<wait()> when a
SIGCHLD is received, or else use the double-fork technique described
in L<perlfaq8/"How do I start a process in the background?">.

=head2 How do I use an SQL database?

The C<DBI> module provides an abstract interface to most database
servers and types, including Oracle, DB2, Sybase, mysql, Postgresql,
ODBC, and flat files.  The DBI module accesses each database type
through a database driver, or DBD.  You can see a complete list of
available drivers on CPAN: http://www.cpan.org/modules/by-module/DBD/ .
You can read more about DBI on http://dbi.perl.org .

Other modules provide more specific access: C<Win32::ODBC>, C<Alzabo>,
C<iodbc>, and others found on CPAN Search: http://search.cpan.org .

=head2 How do I make a system() exit on control-C?

You can't.  You need to imitate the C<system()> call (see L<perlipc> for
sample code) and then have a signal handler for the INT signal that
passes the signal on to the subprocess.  Or you can check for it:

	$rc = system($cmd);
	if ($rc & 127) { die "signal death" }

=head2 How do I open a file without blocking?

If you're lucky enough to be using a system that supports
non-blocking reads (most Unixish systems do), you need only to use the
C<O_NDELAY> or C<O_NONBLOCK> flag from the C<Fcntl> module in conjunction with
C<sysopen()>:

	use Fcntl;
	sysopen(FH, "/foo/somefile", O_WRONLY|O_NDELAY|O_CREAT, 0644)
		or die "can't open /foo/somefile: $!":

=head2 How do I tell the difference between errors from the shell and perl?

(answer contributed by brian d foy)

When you run a Perl script, something else is running the script for you,
and that something else may output error messages.  The script might
emit its own warnings and error messages.  Most of the time you cannot
tell who said what.

You probably cannot fix the thing that runs perl, but you can change how
perl outputs its warnings by defining a custom warning and die functions.

Consider this script, which has an error you may not notice immediately.

	#!/usr/locl/bin/perl

	print "Hello World\n";

I get an error when I run this from my shell (which happens to be
bash).  That may look like perl forgot it has a C<print()> function,
but my shebang line is not the path to perl, so the shell runs the
script, and I get the error.

	$ ./test
	./test: line 3: print: command not found

A quick and dirty fix involves a little bit of code, but this may be all
you need to figure out the problem.

	#!/usr/bin/perl -w

	BEGIN {
	$SIG{__WARN__} = sub{ print STDERR "Perl: ", @@_; };
	$SIG{__DIE__}  = sub{ print STDERR "Perl: ", @@_; exit 1};
	}

	$a = 1 + undef;
	$x / 0;
	__END__

The perl message comes out with "Perl" in front.  The C<BEGIN> block
works at compile time so all of the compilation errors and warnings
get the "Perl:" prefix too.

	Perl: Useless use of division (/) in void context at ./test line 9.
	Perl: Name "main::a" used only once: possible typo at ./test line 8.
	Perl: Name "main::x" used only once: possible typo at ./test line 9.
	Perl: Use of uninitialized value in addition (+) at ./test line 8.
	Perl: Use of uninitialized value in division (/) at ./test line 9.
	Perl: Illegal division by zero at ./test line 9.
	Perl: Illegal division by zero at -e line 3.

If I don't see that "Perl:", it's not from perl.

You could also just know all the perl errors, and although there are
some people who may know all of them, you probably don't.  However, they
all should be in the L<perldiag> manpage. If you don't find the error in
there, it probably isn't a perl error.

Looking up every message is not the easiest way, so let perl to do it
for you.  Use the diagnostics pragma with turns perl's normal messages
into longer discussions on the topic.

	use diagnostics;

If you don't get a paragraph or two of expanded discussion, it
might not be perl's message.

=head2 How do I install a module from CPAN?

(contributed by brian d foy)

The easiest way is to have a module also named CPAN do it for you by using
the C<cpan> command the comes with Perl. You can give it a list of modules
to install:

	$ cpan IO::Interactive Getopt::Whatever

If you prefer C<CPANPLUS>, it's just as easy:

	$ cpanp i IO::Interactive Getopt::Whatever

If you want to install a distribution from the current directory, you can
tell C<CPAN.pm> to install C<.> (the full stop):

	$ cpan .

See the documentation for either of those commands to see what else
you can do.

If you want to try to install a distribution by yourself, resolving
all dependencies on your own, you follow one of two possible build
paths.

For distributions that use I<Makefile.PL>:

	$ perl Makefile.PL
	$ make test install

For distributions that use I<Build.PL>:

	$ perl Build.PL
	$ ./Build test
	$ ./Build install

Some distributions may need to link to libraries or other third-party
code and their build and installation sequences may be more complicated.
Check any I<README> or I<INSTALL> files that you may find.

=head2 What's the difference between require and use?

(contributed by brian d foy)

Perl runs C<require> statement at run-time. Once Perl loads, compiles,
and runs the file, it doesn't do anything else. The C<use> statement
is the same as a C<require> run at compile-time, but Perl also calls the
C<import> method for the loaded package. These two are the same:

	use MODULE qw(import list);

	BEGIN {
		require MODULE;
		MODULE->import(import list);
		}

However, you can suppress the C<import> by using an explicit, empty
import list. Both of these still happen at compile-time:

	use MODULE ();

	BEGIN {
		require MODULE;
		}

Since C<use> will also call the C<import> method, the actual value
for C<MODULE> must be a bareword. That is, C<use> cannot load files
by name, although C<require> can:

	require "$ENV{HOME}/lib/Foo.pm"; # no @@INC searching!

See the entry for C<use> in L<perlfunc> for more details.

=head2 How do I keep my own module/library directory?

When you build modules, tell Perl where to install the modules. 

If you want to install modules for your own use, the easiest way might
be C<local::lib>, which you can download from CPAN. It sets various
installation settings for you, and uses those same settings within
your programs.

If you want more flexibility, you need to configure your CPAN client
for your particular situation.

For C<Makefile.PL>-based distributions, use the INSTALL_BASE option
when generating Makefiles:

	perl Makefile.PL INSTALL_BASE=/mydir/perl

You can set this in your C<CPAN.pm> configuration so modules
automatically install in your private library directory when you use
the CPAN.pm shell:

	% cpan
	cpan> o conf makepl_arg INSTALL_BASE=/mydir/perl
	cpan> o conf commit

For C<Build.PL>-based distributions, use the --install_base option:

	perl Build.PL --install_base /mydir/perl

You can configure C<CPAN.pm> to automatically use this option too:

	% cpan
	cpan> o conf mbuild_arg "--install_base /mydir/perl"
	cpan> o conf commit

INSTALL_BASE tells these tools to put your modules into
F</mydir/perl/lib/perl5>.  See L<How do I add a directory to my
include path (@@INC) at runtime?> for details on how to run your newly
installed modules.

There is one caveat with INSTALL_BASE, though, since it acts
differently than the PREFIX and LIB settings that older versions of
C<ExtUtils::MakeMaker> advocated. INSTALL_BASE does not support
installing modules for multiple versions of Perl or different
architectures under the same directory. You should consider if you
really want that , and if you do, use the older PREFIX and LIB
settings. See the C<ExtUtils::Makemaker> documentation for more details.

=head2 How do I add the directory my program lives in to the module/library search path?

(contributed by brian d foy)

If you know the directory already, you can add it to C<@@INC> as you would
for any other directory. You might <use lib> if you know the directory
at compile time:

	use lib $directory;

The trick in this task is to find the directory. Before your script does
anything else (such as a C<chdir>), you can get the current working
directory with the C<Cwd> module, which comes with Perl:

	BEGIN {
		use Cwd;
		our $directory = cwd;
		}

	use lib $directory;

You can do a similar thing with the value of C<$0>, which holds the
script name. That might hold a relative path, but C<rel2abs> can turn
it into an absolute path. Once you have the

	BEGIN {
		use File::Spec::Functions qw(rel2abs);
		use File::Basename qw(dirname);

		my $path   = rel2abs( $0 );
		our $directory = dirname( $path );
		}

	use lib $directory;

The C<FindBin> module, which comes with Perl, might work. It finds the
directory of the currently running script and puts it in C<$Bin>, which
you can then use to construct the right library path:

	use FindBin qw($Bin);
	
You can also use C<local::lib> to do much of the same thing. Install
modules using C<local::lib>'s settings then use the module in your 
program:

	 use local::lib; # sets up a local lib at ~/perl5

See the C<local::lib> documentation for more details.

=head2 How do I add a directory to my include path (@@INC) at runtime?

Here are the suggested ways of modifying your include path, including
environment variables, run-time switches, and in-code statements:

=over 4

=item the C<PERLLIB> environment variable

	$ export PERLLIB=/path/to/my/dir
	$ perl program.pl

=item the C<PERL5LIB> environment variable

	$ export PERL5LIB=/path/to/my/dir
	$ perl program.pl

=item the C<perl -Idir> command line flag

	$ perl -I/path/to/my/dir program.pl

=item the C<lib> pragma:

	use lib "$ENV{HOME}/myown_perllib";

=item the C<local::lib> module:

	use local::lib;
	
	use local::lib "~/myown_perllib";
	
=back

The last is particularly useful because it knows about machine
dependent architectures.  The C<lib.pm> pragmatic module was first
included with the 5.002 release of Perl.

=head2 What is socket.ph and where do I get it?

It's a Perl 4 style file defining values for system networking
constants.  Sometimes it is built using C<h2ph> when Perl is installed,
but other times it is not.  Modern programs C<use Socket;> instead.

=head1 AUTHOR AND COPYRIGHT

Copyright (c) 1997-2010 Tom Christiansen, Nathan Torkington, and
other authors as noted. All rights reserved.

This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.

Irrespective of its distribution, all code examples in this file
are hereby placed into the public domain.  You are permitted and
encouraged to use this code in your own programs for fun
or for profit as you see fit.  A simple comment in the code giving
credit would be courteous but is not required.
@


1.14
log
@Revert rev 1.13, TIOCGSIZE is actually older that TIOCGWINSZ.
@
text
@@


1.13
log
@Suggest modern TIOCGSIZE, not the old sgtty TIOCGWINSZ.
On OpenBSD they are identical but new code should use the new name.
@
text
@d234 1
a234 1
	die "no TIOCGSIZE " unless defined &TIOCGSIZE;
d236 2
a237 2
	unless (ioctl(TTY, &TIOCGSIZE, $winsize='')) {
		die sprintf "$0: ioctl TIOCGSIZE (%08x: $!)\n", &TIOCGSIZE;
@


1.12
log
@merge in perl 5.12.2 plus local changes
@
text
@d234 1
a234 1
	die "no TIOCGWINSZ " unless defined &TIOCGWINSZ;
d236 2
a237 2
	unless (ioctl(TTY, &TIOCGWINSZ, $winsize='')) {
		die sprintf "$0: ioctl TIOCGWINSZ (%08x: $!)\n", &TIOCGWINSZ;
@


1.11
log
@Merge in perl 5.10.1
@
text
@d18 3
a20 3
The $^O variable ($OSNAME if you use English) contains an indication of
the name of the operating system (not its release number) that your perl
binary was built for.
d69 1
a69 1
color, you can use the Term::ANSIColor module from CPAN:
d95 1
a95 1
The Term::ReadKey module from CPAN offers an easy-to-use interface that
d106 1
a106 1
using the standard POSIX module, which is already on your systems
d112 1
a112 1
And here's the HotKey module, which hides the somewhat mystifying calls
d160 1
a160 1
Term::ReadKey module from CPAN, passing it an argument of -1 to indicate
d223 1
a223 1
If you have Term::ReadKey module installed from CPAN,
d251 1
a251 1
You may do this with an old-style ioctl() function, POSIX terminal
d255 1
a255 1
You can also do this for most systems using the Term::ReadKey module
d284 2
a285 2
blocking by using sysopen() and C<O_RDWR|O_NDELAY|O_NOCTTY> from the
Fcntl module (part of the standard perl distribution).  See
d308 2
a309 2
If you expect characters to get to your device when you print() them,
you'll want to autoflush that filehandle.  You can use select()
d323 1
a323 1
of code just because you're afraid of a little $| variable:
d334 1
a334 1
If you are doing a blocking read() or sysread(), you'll have to
d338 1
a338 1
select() to determine whether I/O is ready on that device (see
d343 5
a347 4
While trying to read from his caller-id box, the notorious Jamie Zawinski
C<< <jwz@@netscape.com> >>, after much gnashing of teeth and fighting with sysread,
sysopen, POSIX's tcgetattr business, and various other functions that
go bump in the night, finally came up with this:
d388 5
a392 4
Several CPAN modules may be able to help, including IPC::Open2 or
IPC::Open3, IPC::Run, Parallel::Jobs, Parallel::ForkManager, POE,
Proc::Background, and Win32::Process. There are many other modules you
might use, so check those namespaces for other options too.
d394 1
a394 1
If you are on a unix-like system, you might be able to get away with a
d429 2
a430 2
You can also use a double fork. You immediately wait() for your
first child, and the init daemon will wait() for your grandchild once
d455 2
a456 2
You can set the values of the %SIG hash to be the functions you want
to handle the signal.  After perl catches the signal, it looks in %SIG
d474 3
a476 3
in %SIG.  This violated the rules of signal handling at that level
causing perl to dump core. Since version 5.8.0, perl looks at %SIG
*after* the signal has been caught, rather than while it is being caught.
d482 1
a482 1
properly, the getpw*() functions described in L<perlfunc> should in
d486 1
a486 1
pwd_mkdb(8) to install it (see L<pwd_mkdb> for more details).
d491 1
a491 1
able to set the system-wide date and time by running the date(1)
d499 1
a499 1
	$ENV{TZ} = "MST7MDT";		   # unixish
d526 3
a528 3
Release 5 of Perl added the END block, which can be used to simulate
atexit().  Each package's END block is called when the program or
thread ends (see L<perlmod> manpage for more details).
d530 2
a531 2
For example, you can use this to make sure your filter program
managed to finish its output without filling up the disk:
d537 2
a538 2
The END block isn't called when untrapped signals kill the program,
though, so if you use END blocks you should also use
d542 5
a546 5
Perl's exception-handling mechanism is its eval() operator.  You can
use eval() as setjmp and die() as longjmp.  For details of this, see
the section on signals, especially the time-out handler for a blocking
flock() in L<perlipc/"Signals"> or the section on "Signals" in
the Camel Book.
d548 2
a549 2
If exception handling is all you're interested in, try the
exceptions.pl library (part of the standard perl distribution).
d551 2
a552 2
If you want the atexit() syntax (and an rmexit() as well), try the
AtExit module available from CPAN.
d569 1
a569 1
syscall(), you can use the syscall function (documented in
d574 1
a574 1
Windows, try Win32::API.  On Macs, try Mac::Carbon.  If no module
d576 1
a576 1
Perl source with Inline::C.
d580 2
a581 2
Historically, these would be generated by the h2ph tool, part of the
standard perl distribution.  This program converts cpp(1) directives
d583 1
a583 1
&SYS_getitimer, which you can use as arguments to your functions.
d586 1
a586 1
but the hard ones like F<ioctl.h> nearly always need to hand-edited.
d594 1
a594 1
sanity you probably ought to use h2xs (also part of the standard perl
d596 1
a596 1
See L<perlxstut> for how to get started with h2xs.
d599 1
a599 1
ought to use h2xs.  See L<perlxstut> and L<ExtUtils::MakeMaker> for
d611 4
a614 4
The IPC::Open2 module (part of the standard perl distribution) is an
easy-to-use approach that internally uses pipe(), fork(), and exec() to do
the job.  Make sure you read the deadlock warnings in its documentation,
though (see L<IPC::Open2>).  See
d618 1
a618 1
You may also use the IPC::Open3 module (part of the standard perl
d620 1
a620 1
arguments from IPC::Open2 (see L<IPC::Open3>).
d624 1
a624 1
You're confusing the purpose of system() and backticks (``).  system()
d641 3
a643 3
With system(), both STDOUT and STDERR will go the same place as the
script's STDOUT and STDERR, unless the system() command redirects them.
Backticks and open() read B<only> the STDOUT of your command.
d645 1
a645 1
You can also use the open3() function from IPC::Open3.  Benjamin
d691 1
a691 1
But there's no real need for *both* to be tempfiles... the following
d730 2
a731 2
This fails because the open() makes STDERR go to where STDOUT was
going at the time of the open().  The backticks then make STDOUT go to
d735 2
a736 2
Note that you I<must> use Bourne shell (sh(1)) redirection syntax in
backticks, not csh(1)!  Details on why Perl's system() and backtick
d783 2
a784 2
If the second argument to a piped open() contains shell
metacharacters, perl fork()s, then exec()s a shell to decode the
d791 1
a791 1
IPC::Open3 module.
d793 1
a793 1
If there are no shell metacharacters in the argument of open(), Perl
d868 5
a872 4
Some stdio's set error and eof flags that need clearing.  The
POSIX module defines clearerr() that you can use.  That is the
technically correct way to do it.  Here are some less reliable
workarounds:
d911 5
a915 4
Try the Net::FTP, TCP::Client, and Net::Telnet modules (available from
CPAN).  http://www.cpan.org/scripts/netstuff/telnet.emul.shar
will also help for emulating the telnet protocol, but Net::Telnet is
quite probably easier to use..
d936 1
a936 1
Once upon a time, there was a library called chat2.pl (part of the
d940 1
a940 1
other modules from CPAN, IO::Pty and IO::Stty.
d967 1
a967 1
fake it by eval()ing the script's output in your shell; check out the
d990 1
a990 1
for details.  Or better yet, you can just use the POSIX::setsid()
d1010 1
a1010 1
The Proc::Daemon module, available from CPAN, provides a function to
d1015 4
a1018 2
Good question. Sometimes C<-t STDIN> and C<-t STDOUT> can give clues,
sometimes not.
d1020 6
a1025 2
	if (-t STDIN && -t STDOUT) {
		print "Now what? ";
d1028 21
a1048 4
On POSIX systems, you can test whether your own process group matches
the current process group of your controlling terminal as follows:

	use POSIX qw/getpgrp tcgetpgrp/;
d1050 2
a1051 11
	# Some POSIX systems, such as Linux, can be
	# without a /dev/tty at boot time.
	if (!open(TTY, "/dev/tty")) {
		print "no tty\n";
	} else {
		$tpgrp = tcgetpgrp(fileno(*TTY));
		$pgrp = getpgrp();
		if ($tpgrp == $pgrp) {
			print "foreground\n";
		} else {
			print "background\n";
a1052 1
	}
d1056 1
a1056 1
Use the alarm() function, probably in conjunction with a signal
d1059 1
a1059 1
Sys::AlarmCall module available from CPAN.
d1061 1
a1061 1
The alarm() function is not implemented on all versions of Windows.
d1086 1
a1086 1
Use the reaper code from L<perlipc/"Signals"> to call wait() when a
d1092 1
a1092 1
The DBI module provides an abstract interface to most database
d1099 2
a1100 2
Other modules provide more specific access: Win32::ODBC, Alzabo, iodbc,
and others found on CPAN Search: http://search.cpan.org .
d1104 1
a1104 1
You can't.  You need to imitate the system() call (see L<perlipc> for
d1115 2
a1116 2
O_NDELAY or O_NONBLOCK flag from the Fcntl module in conjunction with
sysopen():
d1141 1
a1141 1
bash).  That may look like perl forgot it has a print() function,
d1162 1
a1162 1
The perl message comes out with "Perl" in front.  The BEGIN block
d1178 1
a1178 1
all should be in the perldiag manpage. If you don't find the error in
d1192 1
a1192 2
The easiest way is to have a module also named CPAN do it for you.
This module comes with perl version 5.004 and later.
d1194 3
a1196 1
	$ perl -MCPAN -e shell
d1198 1
a1198 11
	cpan shell -- CPAN exploration and modules installation (v1.59_54)
	ReadLine support enabled

	cpan> install Some::Module

To manually install the CPAN module, or any well-behaved CPAN module
for that matter, follow these steps:

=over 4

=item 1
d1200 1
a1200 1
Unpack the source into a temporary area.
d1202 1
a1202 1
=item 2
d1204 2
a1205 1
	perl Makefile.PL
d1207 1
a1207 1
=item 3
d1209 2
a1210 1
	make
d1212 3
a1214 1
=item 4
d1216 1
a1216 1
	make test
d1218 2
a1219 1
=item 5
d1221 1
a1221 1
	make install
d1223 3
a1225 1
=back
d1227 3
a1229 7
If your version of perl is compiled without dynamic loading, then you
just need to replace step 3 (B<make>) with B<make perl> and you will
get a new F<perl> binary with your extension linked in.

See L<ExtUtils::MakeMaker> for more details on building extensions.
See also the next question, "What's the difference between require
and use?".
d1266 9
a1274 1
When you build modules, tell Perl where to install the modules.
d1281 3
a1283 2
You can set this in your CPAN.pm configuration so modules automatically install
in your private library directory when you use the CPAN.pm shell:
d1293 1
a1293 1
You can configure CPAN.pm to automatically use this option too:
d1296 1
a1296 1
	cpan> o conf mbuild_arg --install_base /mydir/perl
d1302 1
a1302 1
installed moudles.
d1306 1
a1306 1
ExtUtils::MakeMaker advocated. INSTALL_BASE does not support
d1310 1
a1310 1
settings. See the ExtUtils::Makemaker documentation for more details.
d1352 8
d1368 1
a1368 1
=item the PERLLIB environment variable
d1373 1
a1373 1
=item the PERL5LIB environment variable
d1378 1
a1378 1
=item the perl -Idir command line flag
d1382 1
a1382 1
=item the use lib pragma:
d1386 6
d1395 1
a1395 1
dependent architectures.  The lib.pm pragmatic module was first
d1401 1
a1401 1
constants.  Sometimes it is built using h2ph when Perl is installed,
a1403 8
=head1 REVISION

Revision: $Revision$

Date: $Date$

See L<perlfaq> for source control details and availability.

d1406 1
a1406 1
Copyright (c) 1997-2009 Tom Christiansen, Nathan Torkington, and
@


1.10
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d23 1
d25 8
a32 4
Because that's what it does: it replaces your currently running
program with a different one.  If you want to keep going (as is
probably the case if you're asking this question) use system()
instead.
d177 5
a181 1
If you only have do so infrequently, use C<system>:
d183 2
a184 1
	system("clear");
d186 2
a187 3
If you have to do this a lot, save the clear string
so you can print it 100 times without calling a program
100 times:
d189 1
a189 2
	$clear_string = `clear`;
	print $clear_string;
d191 3
a193 2
If you're planning on doing other screen manipulations, like cursor
positions, etc, you might wish to use Term::Cap module:
d196 2
a197 1
	$terminal = Term::Cap->Tgetent( {OSPEED => 9600} );
d200 21
d380 11
a390 4
Several modules can start other processes that do not block
your Perl program.  You can use IPC::Open3, Parallel::Jobs,
IPC::Run, and some of the POE modules.  See CPAN for more
details.
d392 2
a393 1
You could also use
d397 2
a398 3
or you could use fork as documented in L<perlfunc/"fork">, with
further examples in L<perlipc>.  Some things to be aware of, if you're
on a Unix-like system:
d1222 26
a1247 2
Perl offers several different ways to include code from one file into
another.  Here are the deltas between the various inclusion constructs:
d1249 1
a1249 15
	1)  do $file is like eval `cat $file`, except the former
	1.1: searches @@INC and updates %INC.
	1.2: bequeaths an *unrelated* lexical scope on the eval'ed code.

	2)  require $file is like do $file, except the former
	2.1: checks for redundant loading, skipping already loaded files.
	2.2: raises an exception on failure to find, compile, or execute $file.

	3)  require Module is like require "Module.pm", except the former
	3.1: translates each "::" into your system's directory separator.
	3.2: primes the parser to disambiguate class Module as an indirect object.

	4)  use Module is like require Module, except the former
	4.1: loads the module at compile time, not run-time.
	4.2: imports symbols and semantics from that package to the current one.
d1251 1
a1251 1
In general, you usually want C<use> and a proper Perl module.
d1257 1
a1257 1
For C<Makefile.PL>-based distributions, use the PREFIX and LIB options
d1260 1
a1260 1
	perl Makefile.PL PREFIX=/mydir/perl LIB=/mydir/perl/lib
d1266 1
a1266 1
	cpan> o conf makepl_arg PREFIX=/mydir/perl,LIB=/mydir/perl/lib
d1271 1
a1271 1
	perl Build.PL --install_base /mydir/perl 
d1279 13
d1301 1
a1301 1
	
d1310 1
a1310 1
	
d1312 1
a1312 1
	
d1315 1
a1315 1
it into an absolute path. Once you have the 
d1317 1
a1317 1
	BEGIN {	
d1320 1
a1320 1
		
d1324 1
a1324 1
		
d1327 3
a1329 4
The C<FindBin> module, which comes with Perl, might work. It searches
through C<$ENV{PATH}> (so your script has to be in one of those
directories). You can then use that directory (in C<$FindBin::Bin>)
to locate nearby directories you want to add:
d1331 1
a1331 2
	use FindBin;
	use lib "$FindBin::Bin/../lib";
d1372 1
a1372 1
Revision: $Revision: 10183 $
d1374 1
a1374 1
Date: $Date: 2007-11-07 09:35:12 +0100 (Wed, 07 Nov 2007) $
d1380 1
a1380 1
Copyright (c) 1997-2007 Tom Christiansen, Nathan Torkington, and
@


1.9
log
@merge in perl 5.8.8
@
text
@d66 3
a68 3
    use Term::ANSIColor;
    print color("red"), "Stop!\n", color("reset");
    print color("green"), "Go!\n", color("reset");
d72 3
a74 3
    use Term::ANSIColor qw(:constants);
    print RED, "Stop!\n", RESET;
    print GREEN, "Go!\n", RESET;
d83 6
a88 6
    open(TTY, "+</dev/tty") or die "no tty: $!";
    system "stty  cbreak </dev/tty >/dev/tty 2>&1";
    $key = getc(TTY);		# perhaps this works
    # OR ELSE
    sysread(TTY, $key, 1);	# probably this does
    system "stty -cbreak </dev/tty >/dev/tty 2>&1";
d94 4
a97 4
    use Term::ReadKey;
    ReadMode('cbreak');
    $key = ReadKey(0);
    ReadMode('normal');
d104 2
a105 2
    use HotKey;
    $key = readkey();
d110 2
a111 2
    # HotKey.pm
    package HotKey;
d113 2
a114 2
    @@ISA = qw(Exporter);
    @@EXPORT = qw(cbreak cooked readkey);
d116 23
a138 31
    use strict;
    use POSIX qw(:termios_h);
    my ($term, $oterm, $echo, $noecho, $fd_stdin);

    $fd_stdin = fileno(STDIN);
    $term     = POSIX::Termios->new();
    $term->getattr($fd_stdin);
    $oterm     = $term->getlflag();

    $echo     = ECHO | ECHOK | ICANON;
    $noecho   = $oterm & ~$echo;

    sub cbreak {
        $term->setlflag($noecho);  # ok, so i don't want echo either
        $term->setcc(VTIME, 1);
        $term->setattr($fd_stdin, TCSANOW);
    }

    sub cooked {
        $term->setlflag($oterm);
        $term->setcc(VTIME, 0);
        $term->setattr($fd_stdin, TCSANOW);
    }

    sub readkey {
        my $key = '';
        cbreak();
        sysread(STDIN, $key, 1);
        cooked();
        return $key;
    }
d140 7
a146 1
    END { cooked() }
d148 3
a150 1
    1;
d158 1
a158 1
    use Term::ReadKey;
d160 1
a160 1
    ReadMode('cbreak');
d162 5
a166 5
    if (defined ($char = ReadKey(-1)) ) {
        # input was waiting and it was $char
    } else {
        # no input was waiting
    }
d168 1
a168 1
    ReadMode('normal');                  # restore normal tty settings
d174 1
a174 1
    system("clear");
d180 2
a181 2
    $clear_string = `clear`;
    print $clear_string;
d186 3
a188 3
    use Term::Cap;
    $terminal = Term::Cap->Tgetent( {OSPEED => 9600} );
    $clear_string = $terminal->Tputs('cl');
d196 2
a197 2
    use Term::ReadKey;
    ($wchar, $hchar, $wpixels, $hpixels) = GetTerminalSize();
d202 10
a211 10
    require 'sys/ioctl.ph';
    die "no TIOCGWINSZ " unless defined &TIOCGWINSZ;
    open(TTY, "+</dev/tty")                     or die "No tty: $!";
    unless (ioctl(TTY, &TIOCGWINSZ, $winsize='')) {
        die sprintf "$0: ioctl TIOCGWINSZ (%08x: $!)\n", &TIOCGWINSZ;
    }
    ($row, $col, $xpixel, $ypixel) = unpack('S4', $winsize);
    print "(row,col) = ($row,$col)";
    print "  (xpixel,ypixel) = ($xpixel,$ypixel)" if $xpixel || $ypixel;
    print "\n";
d227 1
a227 1
    use Term::ReadKey;
d229 2
a230 2
    ReadMode('noecho');
    $password = ReadLine(0);
d265 2
a266 2
    print DEV "atv1\012";	# wrong, for some devices
    print DEV "atv1\015";	# right, for some devices
d283 3
a285 3
    $oldh = select(DEV);
    $| = 1;
    select($oldh);
d289 1
a289 1
    select((select(DEV), $| = 1)[0]);
d294 2
a295 2
    use IO::Handle;
    DEV->autoflush(1);
d313 1
a313 1
<jwz@@netscape.com>, after much gnashing of teeth and fighting with sysread,
d317 12
a328 11
    sub open_modem {
	use IPC::Open2;
	my $stty = `/bin/stty -g`;
	open2( \*MODEM_IN, \*MODEM_OUT, "cu -l$modem_device -s2400 2>&1");
	# starting cu hoses /dev/tty's stty settings, even when it has
	# been opened on a pipe...
	system("/bin/stty $stty");
	$_ = <MODEM_IN>;
	chomp;
	if ( !m/^Connected/ ) {
	    print STDERR "$0: cu printed `$_' instead of `Connected'\n";
a329 1
    }
d337 5
a341 6
password system employs one-way encryption.  It's more like hashing than
encryption.  The best you can check is whether something else hashes to
the same string.  You can't turn a hash back into the original string.
Programs like Crack
can forcibly (and intelligently) try to guess passwords, but don't
(can't) guarantee quick success.
d356 1
a356 1
    system("cmd &")
d385 1
a385 1
    $SIG{CHLD} = sub { wait };
d387 1
a387 1
    $SIG{CHLD} = 'IGNORE';
d394 7
a400 8
		unless (fork) {
            exec "what you really wanna do";
            die "exec failed!";
        	}
        exit 0;
    	}
    waitpid($pid,0);

a438 1

d459 3
a461 3
    $ENV{TZ} = "MST7MDT";		   # unixish
    $ENV{'SYS$TIMEZONE_DIFFERENTIAL'}="-5" # vms
    system "trn comp.lang.perl.misc";
d464 1
d466 5
a470 5
If you want finer granularity than the 1 second that the sleep()
function provides, the easiest way is to use the select() function as
documented in L<perlfunc/"select">.  Try the Time::HiRes and
the BSD::Itimer modules (available from CPAN, and starting from
Perl 5.8 Time::HiRes is part of the standard distribution).
d473 1
d475 1
a475 13
In general, you may not be able to.  The Time::HiRes module (available
from CPAN, and starting from Perl 5.8 part of the standard distribution)
provides this functionality for some systems.

If your system supports both the syscall() function in Perl as well as
a system call like gettimeofday(2), then you may be able to do
something like this:

    require 'sys/syscall.ph';

    $TIMEVAL_T = "LL";

    $done = $start = pack($TIMEVAL_T, ());
d477 6
a482 19
    syscall(&SYS_gettimeofday, $start, 0) != -1
               or die "gettimeofday: $!";

       ##########################
       # DO YOUR OPERATION HERE #
       ##########################

    syscall( &SYS_gettimeofday, $done, 0) != -1
           or die "gettimeofday: $!";

    @@start = unpack($TIMEVAL_T, $start);
    @@done  = unpack($TIMEVAL_T, $done);

    # fix microseconds
    for ($done[1], $start[1]) { $_ /= 1_000_000 }

    $delta_time = sprintf "%.4f", ($done[0]  + $done[1]  )
                                            -
                                 ($start[0] + $start[1] );
d493 3
a495 3
    END {
	close(STDOUT) || die "stdout close failed: $!";
    }
d533 1
a533 1
CPAN as well---someone may already have written a module to do it. On
d549 3
a551 3
    1.  become super-user
    2.  cd /usr/include
    3.  h2ph *.h */*.h
d590 2
a591 2
    $exit_status   = system("mail-users");
    $output_string = `ls`;
d597 3
a599 3
    system $cmd;		# using system()
    $output = `$cmd`;		# using backticks (``)
    open (PIPE, "cmd |");	# using open()
d610 7
a616 7
    use IPC::Open3;
    use File::Spec;
    use Symbol qw(gensym);
    open(NULL, ">", File::Spec->devnull);
    my $pid = open3(gensym, \*PH, ">&NULL", "cmd");
    while( <PH> ) { }
    waitpid($pid, 0);
d620 7
a626 7
    use IPC::Open3;
    use File::Spec;
    use Symbol qw(gensym);
    open(NULL, ">", File::Spec->devnull);
    my $pid = open3(gensym, ">&NULL", \*PH, "cmd");
    while( <PH> ) { }
    waitpid($pid, 0);
d630 5
a634 5
    use IPC::Open3;
    use Symbol qw(gensym);
    my $pid = open3(gensym, ">&STDERR", \*PH, "cmd");
    while( <PH> ) { }
    waitpid($pid, 0);
d640 10
a649 10
    use IPC::Open3;
    use Symbol qw(gensym);
    use IO::File;
    local *CATCHOUT = IO::File->new_tmpfile;
    local *CATCHERR = IO::File->new_tmpfile;
    my $pid = open3(gensym, ">&CATCHOUT", ">&CATCHERR", "cmd");
    waitpid($pid, 0);
    seek $_, 0, 0 for \*CATCHOUT, \*CATCHERR;
    while( <CATCHOUT> ) {}
    while( <CATCHERR> ) {}
d654 9
a662 9
    use IPC::Open3;
    use Symbol qw(gensym);
    use IO::File;
    local *CATCHERR = IO::File->new_tmpfile;
    my $pid = open3(gensym, \*CATCHOUT, ">&CATCHERR", "cmd");
    while( <CATCHOUT> ) {}
    waitpid($pid, 0);
    seek CATCHERR, 0, 0;
    while( <CATCHERR> ) {}
d669 2
a670 2
    open(STDOUT, ">logfile");
    system("ls");
d674 2
a675 2
    $output = `$cmd 2>some_file`;
    open (PIPE, "cmd 2>some_file |");
d680 2
a681 2
    $output = `$cmd 2>&1`;
    open (PIPE, "cmd 2>&1 |");
d687 2
a688 2
    open(STDERR, ">&STDOUT");
    $alloutput = `cmd args`;  # stderr still escapes
d702 3
a704 3
    $output = `cmd 2>&1`;                       # either with backticks
    $pid = open(PH, "cmd 2>&1 |");              # or with an open pipe
    while (<PH>) { }                            #    plus a read
d708 3
a710 3
    $output = `cmd 2>/dev/null`;                # either with backticks
    $pid = open(PH, "cmd 2>/dev/null |");       # or with an open pipe
    while (<PH>) { }                            #    plus a read
d714 3
a716 3
    $output = `cmd 2>&1 1>/dev/null`;           # either with backticks
    $pid = open(PH, "cmd 2>&1 1>/dev/null |");  # or with an open pipe
    while (<PH>) { }                            #    plus a read
d721 3
a723 3
    $output = `cmd 3>&1 1>&2 2>&3 3>&-`;        # either with backticks
    $pid = open(PH, "cmd 3>&1 1>&2 2>&3 3>&-|");# or with an open pipe
    while (<PH>) { }                            #    plus a read
d729 1
a729 1
    system("program args 1>program.stdout 2>program.stderr");
d734 2
a735 2
    system("prog args 1>tmpfile 2>&1");
    system("prog args 2>&1 1>tmpfile");
d771 1
a771 1
    `cat /etc/termcap`;
d776 1
a776 1
    print `cat /etc/termcap`;
d780 1
a780 1
    system("cat /etc/termcap") == 0
d783 3
a785 2
which will get the output quickly (as it is generated, instead of only
at the end) and also check the return value.
d787 1
a787 1
system() also provides direct control over whether shell wildcard
d795 1
a795 1
    @@ok = `grep @@opts '$search_string' @@filenames`;
d797 2
a798 2
As of Perl 5.8.0, you can use open() with multiple arguments.
Just like the list forms of system() and exec(), no shell
d801 3
a803 3
   open( GREP, "-|", 'grep', @@opts, $search_string, @@filenames );
   chomp(@@ok = <GREP>);
   close GREP;
d807 18
a824 17
    my @@ok = ();
    if (open(GREP, "-|")) {
        while (<GREP>) {
	    chomp;
            push(@@ok, $_);
        }
	close GREP;
    } else {
        exec 'grep', @@opts, $search_string, @@filenames;
    }

Just as with system(), no shell escapes happen when you exec() a list.
Further examples of this can be found in L<perlipc/"Safe Pipe Opens">.

Note that if you're use Microsoft, no solution to this vexing issue
is even possible.  Even if Perl were to emulate fork(), you'd still
be stuck, because Microsoft does not have a argc/argv-style API.
d839 2
a840 2
    $where = tell(LOG);
    seek(LOG, $where, 0);
d879 12
a890 12
    use IO::Socket; 	    	# new in 5.004
    $handle = IO::Socket::INET->new('www.perl.com:80')
	    || die "can't connect to port 80 on www.perl.com: $!";
    $handle->autoflush(1);
    if (fork()) { 	    	# XXX: undef means failure
	select($handle);
	print while <STDIN>;    # everything from stdin to socket
    } else {
	print while <$handle>;  # everything from socket to stdout
    }
    close $handle;
    exit;
d913 1
a913 1
    $0 = "orcus [accepting connections]";
d964 1
a964 1
    fork && exit;
d973 1
a973 1
Good question.  Sometimes C<-t STDIN> and C<-t STDOUT> can give clues,
d976 3
a978 3
    if (-t STDIN && -t STDOUT) {
	print "Now what? ";
    }
d983 15
a997 9
    use POSIX qw/getpgrp tcgetpgrp/;
    open(TTY, "/dev/tty") or die $!;
    $tpgrp = tcgetpgrp(fileno(*TTY));
    $pgrp = getpgrp();
    if ($tpgrp == $pgrp) {
        print "foreground\n";
    } else {
        print "background\n";
    }
d1010 1
d1012 16
a1027 1
Use the BSD::Resource module from CPAN.
d1053 2
a1054 2
    $rc = system($cmd);
    if ($rc & 127) { die "signal death" }
d1063 3
a1065 3
    use Fcntl;
    sysopen(FH, "/foo/somefile", O_WRONLY|O_NDELAY|O_CREAT, 0644)
        or die "can't open /foo/somefile: $!":
d1069 1
a1069 1
(answer contributed by brian d foy, C<< <bdfoy@@cpan.org> >>
d1140 1
a1140 1
    $ perl -MCPAN -e shell
d1142 2
a1143 2
    cpan shell -- CPAN exploration and modules installation (v1.59_54)
    ReadLine support enabled
d1145 1
a1145 1
    cpan> install Some::Module
d1158 1
a1158 1
    perl Makefile.PL
d1162 1
a1162 1
    make
d1166 1
a1166 1
    make test
d1170 1
a1170 1
    make install
d1187 1
a1187 1
    1)  do $file is like eval `cat $file`, except the former
d1191 1
a1191 1
    2)  require $file is like do $file, except the former
d1195 1
a1195 1
    3)  require Module is like require "Module.pm", except the former
d1199 1
a1199 1
    4)  use Module is like require Module, except the former
d1207 6
a1212 2
When you build modules, use the PREFIX and LIB options when generating
Makefiles:
d1214 2
a1215 1
    perl Makefile.PL PREFIX=/mydir/perl LIB=/mydir/perl/lib
d1217 3
a1219 2
then either set the PERL5LIB environment variable before you run
scripts that use the modules/libraries (see L<perlrun>) or say
d1221 1
a1221 1
    use lib '/mydir/perl/lib';
d1223 1
a1223 1
This is almost the same as
d1225 1
a1225 3
    BEGIN {
	unshift(@@INC, '/mydir/perl/lib');
    }
d1227 3
a1229 2
except that the lib module checks for machine-dependent subdirectories.
See Perl's L<lib> for more information.
d1233 40
a1272 3
    use FindBin;
    use lib "$FindBin::Bin";
    use your_own_modules;
d1276 20
a1295 1
Here are the suggested ways of modifying your include path:
d1297 1
a1297 5
    the PERLLIB environment variable
    the PERL5LIB environment variable
    the perl -Idir command line flag
    the use lib pragma, as in
        use lib "$ENV{HOME}/myown_perllib";
d1299 3
a1301 1
The latter is particularly useful because it knows about machine
d1307 1
a1307 1
It's a perl4-style file defining values for system networking
d1311 8
d1321 1
a1321 1
Copyright (c) 1997-2006 Tom Christiansen, Nathan Torkington, and
@


1.8
log
@sync in-tree perl with 5.8.6
@
text
@d3 1
a3 1
perlfaq8 - System Interaction ($Revision: 1.7 $, $Date: 2004/08/09 18:10:15 $)
d38 5
a42 5
    Term::Cap			Standard perl distribution
    Term::ReadKey		CPAN
    Term::ReadLine::Gnu		CPAN
    Term::ReadLine::Perl	CPAN
    Term::Screen		CPAN
d46 3
a48 3
    Term::Cap			Standard perl distribution
    Curses			CPAN
    Term::ANSIColor		CPAN
d52 1
a52 1
    Tk				CPAN
d56 2
a57 1
Some of these specific cases are shown below.
d280 2
a281 2
and L<perlfunc/select>, or L<perlfaq5>, ``How do I flush/unbuffer an
output filehandle?  Why must I do this?''):
d415 1
a415 1
section on ``Signals'' in the Camel.
d417 1
a417 1
You can set the values of the %SIG hash to be the functions you want 
d423 1
a423 1
	
d425 1
a425 1
	
d427 1
a427 1
	
d429 1
a429 1
	
d431 2
a432 2
	
	$SIG{INT} = "ouch"; 
d531 1
a531 1
flock() in L<perlipc/"Signals"> or the section on ``Signals'' in
d669 2
a670 2
    local *CATCHOUT = IO::File->new_tempfile;
    local *CATCHERR = IO::File->new_tempfile;
d683 1
a683 1
    local *CATCHERR = IO::File->new_tempfile;
d1021 1
a1021 1
``Signals'' in the Camel.  You may instead use the more flexible
d1099 1
a1099 1
	
d1104 1
a1104 1
	
d1181 2
a1182 2
See also the next question, ``What's the difference between require
and use?''.
d1256 2
a1257 2
Copyright (c) 1997-2003 Tom Christiansen and Nathan Torkington.
All rights reserved.
@


1.7
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d3 1
a3 1
perlfaq8 - System Interaction ($Revision: 1.6 $, $Date: 2003/12/03 03:02:45 $)
d416 23
a438 18
Be warned that very few C libraries are re-entrant.  Therefore, if you
attempt to print() in a handler that got invoked during another stdio
operation your internal structures will likely be in an
inconsistent state, and your program will dump core.  You can
sometimes avoid this by using syswrite() instead of print().

Unless you're exceedingly careful, the only safe things to do inside a
signal handler are (1) set a variable and (2) exit.  In the first case,
you should only set a variable in such a way that malloc() is not
called (eg, by setting a variable that already has a value).

For example:

    $Interrupted = 0;	# to ensure it has a value
    $SIG{INT} = sub {
        $Interrupted++;
	syswrite(STDERR, "ouch\n", 5);
    }
a439 6
However, because syscalls restart by default, you'll find that if
you're in a "slow" call, such as <FH>, read(), connect(), or
wait(), that the only way to terminate them is by "longjumping" out;
that is, by raising an exception.  See the time-out handler for a
blocking flock() in L<perlipc/"Signals"> or the section on ``Signals''
in the Camel book.
d1067 68
@


1.6
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d3 1
a3 1
perlfaq8 - System Interaction ($Revision: 1.17 $, $Date: 2003/01/26 17:44:04 $)
d752 2
a753 2
and safest to redirect them separately to files, and then read from those
files when the program is done:
d755 1
a755 1
    system("program args 1>/tmp/program.stdout 2>/tmp/program.stderr");
d1066 2
a1067 2
    sysopen(FH, "/tmp/somefile", O_WRONLY|O_NDELAY|O_CREAT, 0644)
        or die "can't open /tmp/somefile: $!":
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 1
a3 1
perlfaq8 - System Interaction ($Revision: 1.8 $, $Date: 2002/05/16 12:41:42 $)
d80 1
a80 1
portability snags.  
d191 1
a191 1
If you have Term::ReadKey module installed from CPAN, 
d198 1
a198 1
This is more portable than the raw C<ioctl>, but not as 
d278 1
a278 1
and the C<$|> variable to control autoflushing (see L<perlvar/$|>
d349 6
a354 1
You could use
d383 1
a383 1
You have to be prepared to "reap" the child process when it finishes
d387 16
d448 2
a449 2
varies from system to system--see L<passwd(5)> for specifics) and use
pwd_mkdb(8) to install it (see L<pwd_mkdb(8)> for more details).
d514 1
a514 1
thread ends (see L<perlmod> manpage for more details).  
d521 1
a521 1
    } 
d559 4
a562 1
CPAN as well--someone may already have written a module to do it.
d600 2
a601 2
though (see L<IPC::Open2>).  See 
L<perlipc/"Bidirectional Communication with Another Process"> and 
d631 62
d725 1
a725 1
Know" collection in http://www.cpan.org/olddoc/FMTEYEWTK.tgz .  To
d769 1
a769 1
If the second argument to a piped C<open> contains shell
d777 1
a777 1
L<IPC::Open3> module.
d779 1
a779 1
If there are no shell metacharacters in the argument of C<open>, Perl
d789 1
a789 1
another; it doesn't do this.  
d817 2
a818 1
This is a bit tricky.  Instead of writing
d822 9
a830 1
You have to do this:
d846 1
a846 1
Note that if you're stuck on Microsoft, no solution to this vexing issue
d848 1
a848 4
be hosed, because Microsoft gives no argc/argv-style API.  Their API
always reparses from a single string, which is fundamentally wrong,
but you're not likely to get the Gods of Redmond to acknowledge this
and fix it for you.
d950 1
a950 1
comp.unix.questions FAQ for details.  
d971 1
a971 1
Open /dev/tty and use the TIOCNOTTY ioctl on it.  See L<tty(4)>
d1024 3
d1035 1
a1035 1
in L<perlfunc/fork>.
d1039 9
a1047 3
There are a number of excellent interfaces to SQL databases.  See the
DBD::* modules available from http://www.cpan.org/modules/DBD .
A lot of information on this can be found at http://dbi.perl.org/
d1056 1
a1056 1
    if ($rc & 127) { die "signal death" } 
d1072 1
a1072 1
This module comes with perl version 5.004 and later.  
d1079 1
a1079 1
    cpan> install Some::Module 
d1081 1
a1081 1
To manually install the CPAN module, or any well-behaved CPAN module 
d1141 1
a1141 1
When you build modules, use the PREFIX option when generating
d1144 1
a1144 1
    perl Makefile.PL PREFIX=/u/mydir/perl
d1149 1
a1149 1
    use lib '/u/mydir/perl';
d1154 1
a1154 1
	unshift(@@INC, '/u/mydir/perl');
d1166 1
a1166 1
=head2 How do I add a directory to my include path at runtime?
d1188 1
a1188 1
Copyright (c) 1997-2002 Tom Christiansen and Nathan Torkington.
@


1.4
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 1
a3 1
perlfaq8 - System Interaction ($Revision: 1.39 $, $Date: 1999/05/23 18:37:57 $)
d297 1
a297 1
socket I/O between Unix and Macintosh.  You'll need to hardcode your
d438 1
a438 1
However, if all you want to do is change your timezone, you can
d450 2
a451 1
the BSD::Itimer modules (available from CPAN).
d456 2
a457 1
from CPAN) provides this functionality for some systems.
d637 4
a640 3
and pipe opens all use the Bourne shell are in
http://www.perl.com/CPAN/doc/FMTEYEWTK/versus/csh.whynot .
To capture a command's STDERR and STDOUT together:
d683 13
a695 21
Because the pipe open takes place in two steps: first Perl calls
fork() to start a new process, then this new process calls exec() to
run the program you really wanted to open.  The first step reports
success or failure to your process, so open() can only tell you
whether the fork() succeeded or not.

To find out if the exec() step succeeded, you have to catch SIGCHLD
and wait() to get the exit status.  You should also catch SIGPIPE if
you're writing to the child--you may not have found out the exec()
failed by the time you write.  This is documented in L<perlipc>.

In some cases, even this won't work.  If the second argument to a
piped open() contains shell metacharacters, perl fork()s, then exec()s
a shell to decode the metacharacters and eventually run the desired
program.  Now when you call wait(), you only learn whether or not the
I<shell> could be successfully started...it's best to avoid shell
metacharacters.

On systems that follow the spawn() paradigm, open() I<might> do what
you expect--unless perl uses a shell to start your command. In this
case the fork()/exec() description still applies.
d700 8
a707 11
way to write maintainable code because backticks have a (potentially
humongous) return value, and you're ignoring it.  It's may also not be very
efficient, because you have to read in all the lines of output, allocate
memory for them, and then throw it away.  Too often people are lulled
to writing:

    `cp file file.bak`;

And now they think "Hey, I'll just always use backticks to run programs."
Bad idea: backticks are for capturing a program's output; the system()
function is for running programs.
d713 2
a714 3
You haven't assigned the output anywhere, so it just wastes memory
(for a little while).  You forgot to check C<$?> to see whether
the program even ran correctly, too.  Even if you wrote
d803 1
a803 1
CPAN).  http://www.perl.com/CPAN/scripts/netstuff/telnet.emul.shar
d945 2
a946 3
DBD::* modules available from http://www.perl.com/CPAN/modules/DBD .
A lot of information on this can be found at 
http://www.symbolstone.org/technology/perl/DBI/
d971 11
a981 3
This module comes with perl version 5.004 and later.  To manually install
the CPAN module, or any well-behaved CPAN module for that matter, follow
these steps:
d1087 1
a1087 1
Copyright (c) 1997-1999 Tom Christiansen and Nathan Torkington.
d1090 2
a1091 6
When included as part of the Standard Version of Perl, or as part of
its complete documentation whether printed or otherwise, this work
may be distributed only under the terms of Perl's Artistic License.
Any distribution of this file or derivatives thereof I<outside>
of that package require that special arrangements be made with
copyright holder.
@


1.3
log
@perl-5.6.0 + local changes
@
text
@d8 1
a8 1
system interaction.  This involves interprocess communication (IPC),
d98 4
a101 4
However, that requires that you have a working C compiler and can use it
to build and install a CPAN module.  Here's a solution using
the standard POSIX module, which is already on your systems (assuming
your system supports POSIX).
d217 4
a220 4
There's an example of this in L<perlfunc/crypt>).  First, you put
the terminal into "no echo" mode, then just read the password
normally.  You may do this with an old-style ioctl() function, POSIX
terminal control (see L<POSIX>, and Chapter 7 of the Camel), or a call
d235 1
a235 1
/dev; on other systems, the devices names will doubtless differ.
d237 1
a237 1
following
d244 1
a244 1
you follow the correct protocol.  Unpredictable behaviour can result
d267 1
a267 1
Even though with normal text files, a "\n" will do the trick, there is
d279 2
a280 1
and L<perlfunc/select>):
d324 1
a324 1
	chop;
d335 1
a335 1
Seriously, you can't if they are Unix password files - the Unix
d392 2
a393 1
Signals are documented in L<perlipc/"Signals"> and chapter 6 of the Camel.
d402 1
a402 1
signal handler are: set a variable and exit.  And in the first case,
d418 2
a419 1
blocking flock() in L<perlipc/"Signals"> or chapter 6 of the Camel.
d423 1
a423 1
If perl was installed correctly, and your shadow library was written
d427 1
a427 1
varies from system to system - see L<passwd(5)> for specifics) and use
d449 2
a450 3
documented in L<perlfunc/"select">.  If your system has itimers and
syscall() support, you can check out the old example in
http://www.perl.com/CPAN/doc/misc/ancient/tutorial/eg/itimers.pl .
d500 2
a501 2
The END block isn't called when untrapped signals kill the program, though, so if
you use END blocks you should also use
d508 2
a509 1
flock() in L<perlipc/"Signals"> and chapter 6 of the Camel.
d517 1
a517 1
=head2 Why doesn't my sockets program work under System V (Solaris)? What does the error message "Protocol not supported" mean?
d529 1
a529 1
In most cases, you write an external module to do it - see the answer
d536 1
a536 1
CPAN as well - someone may already have written a module to do it.
d574 3
a576 3
though (see L<IPC::Open2>).  See L<perlipc/"Bidirectional Communication
with Another Process"> and L<perlipc/"Bidirectional Communication with
Yourself">
d602 1
a602 1
script's versions of these, unless the command redirects them.
d695 1
a695 1
I<shell> could be successfully started.  Best to avoid shell
d722 2
a723 2
(for a little while).  Plus you forgot to check C<$?> to see whether
the program even ran correctly.  Even if you wrote
d727 1
a727 1
In most cases, this could and probably should be written as
d732 1
a732 1
Which will get the output quickly (as it is generated, instead of only
d769 1
a769 1
Because some stdio's set error and eof flags that need clearing.  The
d862 1
a862 1
In the strictest sense, it can't be done -- the script executes as a
d864 1
a864 1
process are not reflected in its parent, only in its own children
d874 1
a874 1
to the process (see L<perlfunc/"kill">.  It's common to first send a TERM
a911 4
=head2 How do I make my program run with sh and csh?

See the F<eg/nih> script (part of the perl source distribution).

d937 3
a939 3
handler, as documented in L<perlipc/"Signals"> and chapter 6 of the
Camel.  You may instead use the more flexible Sys::AlarmCall module
available from CPAN.
a977 3



d1014 2
a1015 1
See also the next question.
d1022 1
a1022 1
    1)  do $file is like eval `cat $file`, except the former:
d1026 1
a1026 1
    2)  require $file is like do $file, except the former:
d1030 1
a1030 1
    3)  require Module is like require "Module.pm", except the former:
d1034 1
a1034 1
    4)  use Module is like require Module, except the former:
d1052 1
a1052 1
This is almost the same as:
@


1.2
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
perlfaq8 - System Interaction ($Revision: 1.36 $, $Date: 1999/01/08 05:36:34 $)
d18 3
a20 2
The $^O variable ($OSNAME if you use English) contains the operating
system that your perl binary was built for.
d78 1
a78 1
If most systems, you can just use the B<stty> command as shown in
d171 1
a171 1
If you only have to so infrequently, use C<system>:
d413 1
a413 1
you're in a "slow" call, such as E<lt>FHE<gt>, read(), connect(), or
d425 1
a425 1
pwd_mkdb(8) to install it (see L<pwd_mkdb(5)> for more details).
d465 1
a465 1
    syscall( &SYS_gettimeofday, $start, 0) != -1
d703 1
a703 1
humungous) return value, and you're ignoring it.  It's may also not be very
d729 1
a729 1
Which will get the output quickly (as its generated, instead of only
d755 1
d757 6
a762 1
There are more examples of this L<perlipc/"Safe Pipe Opens">.
d938 1
a938 1
handler, as documented L<perlipc/"Signals"> and chapter 6 of the
d955 1
a955 2
DBD::* modules available from
http://www.perl.com/CPAN/modules/dbperl/DBD .
d957 1
a957 1
http://www.hermetica.com/technologia/perl/DBI/index.html .
a978 1
=head2 How do I install a CPAN module?
d980 8
a987 4
The easiest way is to have the CPAN module do it for you.  This module
comes with perl version 5.004 and later.  To manually install the CPAN
module, or any well-behaved CPAN module for that matter, follow these
steps:
d1097 1
a1097 1
may be distributed only under the terms of Perl's Artistic Licence.
a1106 1

@


1.1
log
@perl 5.004_04
@
text
@d3 1
a3 1
perlfaq8 - System Interaction ($Revision: 1.21 $, $Date: 1997/04/24 22:44:19 $)
d18 1
a18 1
The $^O variable ($OSTYPE if you use English) contains the operating
d55 156
d225 5
d276 3
a278 12
you'll want to autoflush that filehandle, as in the older

    use FileHandle;
    DEV->autoflush(1);

and the newer

    use IO::Handle;
    DEV->autoflush(1);

You can use select() and the C<$|> variable to control autoflushing
(see L<perlvar/$|> and L<perlfunc/select>):
d288 6
d309 19
d334 6
a339 3
password system employs one-way encryption.  Programs like Crack can
forcibly (and intelligently) try to guess passwords, but don't (can't)
guarantee quick success.
d357 1
a357 1
=item STDIN, STDOUT and STDERR are shared
d387 4
a390 3
You don't actually "trap" a control character.  Instead, that
character generates a signal, which you then trap.  Signals are
documented in L<perlipc/"Signals"> and chapter 6 of the Camel.
d419 5
a423 4
If perl was installed correctly, the getpw*() functions described in
L<perlfunc> provide (read-only) access to the shadow password file.
To change the file, make a new shadow password file (the format varies
from system to system - see L<passwd(5)> for specifics) and use
d439 1
a439 1
    system "trn comp.lang.perl";
d454 3
a456 3
In general, you may not be able to.  But if you system supports both the
syscall() function in Perl as well as a system call like gettimeofday(2),
then you may be able to do something like this:
d464 1
a464 1
    syscall( &SYS_gettimeofday, $start, 0)) != -1
d488 11
a498 3
thread ends (see L<perlmod> manpage for more details).  It isn't
called when untrapped signals kill the program, though, so if you use
END blocks you should also use
d568 9
a576 3
easy-to-use approach that internally uses pipe(), fork(), and exec()
to do the job.  Make sure you read the deadlock warnings in its
documentation, though (see L<IPC::Open2>).
d582 1
a582 1
the low 8 bits are the signal the process died from, if any, and
d633 17
d651 22
a672 3
You may also use the IPC::Open3 module (part of the standard perl
distribution), but be warned that it has a different order of
arguments from IPC::Open2 (see L<IPC::Open3>).
d676 9
a684 9
It does, but probably not how you expect it to.  On systems that
follow the standard fork()/exec() paradigm (eg, Unix), it works like
this: open() causes a fork().  In the parent, open() returns with the
process ID of the child.  The child exec()s the command to be piped
to/from.  The parent can't know whether the exec() was successful or
not - all it can return is whether the fork() succeeded or not.  To
find out if the command succeeded, you have to catch SIGCHLD and
wait() to get the exit status.  You should also catch SIGPIPE if
you're writing to the child -- you may not have found out the exec()
d687 7
d695 1
a695 1
you expect - unless perl uses a shell to start your command. In this
d729 1
a729 1
at the end ) and also check the return value.
d755 2
d826 4
a829 3
standard perl distribution), which never really got finished.  These
days, your best bet is to look at the Comm.pl library available from
CPAN.
d857 1
a857 5
comp.unix.questions FAQ for details.

=item VMS

Change to %ENV persist after Perl exits, but directory changes do not.
d878 3
a880 2
Open /dev/tty and use the the TIOCNOTTY ioctl on it.  See L<tty(4)>
for details.
d899 3
d920 1
a920 1
    $tpgrp = tcgetpgrp(TTY);
d950 2
d957 4
a960 1
passes the signal on to the subprocess.
d1008 25
a1032 2
See L<ExtUtils::MakeMaker> for more details on building extensions,
the question "How do I keep my own module/library directory?"
d1046 7
d1058 1
a1058 1
    use lib "$FindBin:Bin";
d1067 1
a1067 1
    the perl -Idir commpand line flag
d1075 1
a1075 15
=head1 How do I get one key from the terminal at a time, under POSIX?

    #!/usr/bin/perl -w
    use strict;
    $| = 1;
    for (1..4) {
        my $got;
        print "gimme: ";
        $got = getone();
        print "--> $got\n";
    }
    exit;

    BEGIN {
        use POSIX qw(:termios_h);
d1077 3
a1079 1
        my ($term, $oterm, $echo, $noecho, $fd_stdin);
d1081 1
a1081 1
        $fd_stdin = fileno(STDIN);
d1083 2
a1084 3
        $term     = POSIX::Termios->new();
        $term->getattr($fd_stdin);
        $oterm     = $term->getlflag();
d1086 12
a1097 27
        $echo     = ECHO | ECHOK | ICANON;
        $noecho   = $oterm & ~$echo;

        sub cbreak {
            $term->setlflag($noecho);
            $term->setcc(VTIME, 1);
            $term->setattr($fd_stdin, TCSANOW);
        }

        sub cooked {
            $term->setlflag($oterm);
            $term->setcc(VTIME, 0);
            $term->setattr($fd_stdin, TCSANOW);
        }

        sub getone {
            my $key = '';
            cbreak();
            sysread(STDIN, $key, 1);
            cooked();
            return $key;
        }

    }
    END { cooked() }

=head1 AUTHOR AND COPYRIGHT
a1098 2
Copyright (c) 1997 Tom Christiansen and Nathan Torkington.
All rights reserved.  See L<perlfaq> for distribution information.
@


1.1.1.1
log
@perl5.005_03
@
text
@d3 1
a3 1
perlfaq8 - System Interaction ($Revision: 1.36 $, $Date: 1999/01/08 05:36:34 $)
d18 1
a18 1
The $^O variable ($OSNAME if you use English) contains the operating
a54 156
Some of these specific cases are shown below.

=head2 How do I print something out in color?

In general, you don't, because you don't know whether
the recipient has a color-aware display device.  If you
know that they have an ANSI terminal that understands
color, you can use the Term::ANSIColor module from CPAN:

    use Term::ANSIColor;
    print color("red"), "Stop!\n", color("reset");
    print color("green"), "Go!\n", color("reset");

Or like this:

    use Term::ANSIColor qw(:constants);
    print RED, "Stop!\n", RESET;
    print GREEN, "Go!\n", RESET;

=head2 How do I read just one key without waiting for a return key?

Controlling input buffering is a remarkably system-dependent matter.
If most systems, you can just use the B<stty> command as shown in
L<perlfunc/getc>, but as you see, that's already getting you into
portability snags.  

    open(TTY, "+</dev/tty") or die "no tty: $!";
    system "stty  cbreak </dev/tty >/dev/tty 2>&1";
    $key = getc(TTY);		# perhaps this works
    # OR ELSE
    sysread(TTY, $key, 1);	# probably this does
    system "stty -cbreak </dev/tty >/dev/tty 2>&1";

The Term::ReadKey module from CPAN offers an easy-to-use interface that
should be more efficient than shelling out to B<stty> for each key.
It even includes limited support for Windows.

    use Term::ReadKey;
    ReadMode('cbreak');
    $key = ReadKey(0);
    ReadMode('normal');

However, that requires that you have a working C compiler and can use it
to build and install a CPAN module.  Here's a solution using
the standard POSIX module, which is already on your systems (assuming
your system supports POSIX).

    use HotKey;
    $key = readkey();

And here's the HotKey module, which hides the somewhat mystifying calls
to manipulate the POSIX termios structures.

    # HotKey.pm
    package HotKey;

    @@ISA = qw(Exporter);
    @@EXPORT = qw(cbreak cooked readkey);

    use strict;
    use POSIX qw(:termios_h);
    my ($term, $oterm, $echo, $noecho, $fd_stdin);

    $fd_stdin = fileno(STDIN);
    $term     = POSIX::Termios->new();
    $term->getattr($fd_stdin);
    $oterm     = $term->getlflag();

    $echo     = ECHO | ECHOK | ICANON;
    $noecho   = $oterm & ~$echo;

    sub cbreak {
        $term->setlflag($noecho);  # ok, so i don't want echo either
        $term->setcc(VTIME, 1);
        $term->setattr($fd_stdin, TCSANOW);
    }

    sub cooked {
        $term->setlflag($oterm);
        $term->setcc(VTIME, 0);
        $term->setattr($fd_stdin, TCSANOW);
    }

    sub readkey {
        my $key = '';
        cbreak();
        sysread(STDIN, $key, 1);
        cooked();
        return $key;
    }

    END { cooked() }

    1;

=head2 How do I check whether input is ready on the keyboard?

The easiest way to do this is to read a key in nonblocking mode with the
Term::ReadKey module from CPAN, passing it an argument of -1 to indicate
not to block:

    use Term::ReadKey;

    ReadMode('cbreak');

    if (defined ($char = ReadKey(-1)) ) {
        # input was waiting and it was $char
    } else {
        # no input was waiting
    }

    ReadMode('normal');                  # restore normal tty settings

=head2 How do I clear the screen?

If you only have to so infrequently, use C<system>:

    system("clear");

If you have to do this a lot, save the clear string
so you can print it 100 times without calling a program
100 times:

    $clear_string = `clear`;
    print $clear_string;

If you're planning on doing other screen manipulations, like cursor
positions, etc, you might wish to use Term::Cap module:

    use Term::Cap;
    $terminal = Term::Cap->Tgetent( {OSPEED => 9600} );
    $clear_string = $terminal->Tputs('cl');

=head2 How do I get the screen size?

If you have Term::ReadKey module installed from CPAN, 
you can use it to fetch the width and height in characters
and in pixels:

    use Term::ReadKey;
    ($wchar, $hchar, $wpixels, $hpixels) = GetTerminalSize();

This is more portable than the raw C<ioctl>, but not as 
illustrative:

    require 'sys/ioctl.ph';
    die "no TIOCGWINSZ " unless defined &TIOCGWINSZ;
    open(TTY, "+</dev/tty")                     or die "No tty: $!";
    unless (ioctl(TTY, &TIOCGWINSZ, $winsize='')) {
        die sprintf "$0: ioctl TIOCGWINSZ (%08x: $!)\n", &TIOCGWINSZ;
    }
    ($row, $col, $xpixel, $ypixel) = unpack('S4', $winsize);
    print "(row,col) = ($row,$col)";
    print "  (xpixel,ypixel) = ($xpixel,$ypixel)" if $xpixel || $ypixel;
    print "\n";

a68 5
    use Term::ReadKey;

    ReadMode('noecho');
    $password = ReadLine(0);

d115 12
a126 3
you'll want to autoflush that filehandle.  You can use select()
and the C<$|> variable to control autoflushing (see L<perlvar/$|>
and L<perlfunc/select>):
a135 6
Or if you don't mind pulling in a few thousand lines
of code just because you're afraid of a little $| variable:

    use IO::Handle;
    DEV->autoflush(1);

a150 19
While trying to read from his caller-id box, the notorious Jamie Zawinski
<jwz@@netscape.com>, after much gnashing of teeth and fighting with sysread,
sysopen, POSIX's tcgetattr business, and various other functions that
go bump in the night, finally came up with this:

    sub open_modem {
	use IPC::Open2;
	my $stty = `/bin/stty -g`;
	open2( \*MODEM_IN, \*MODEM_OUT, "cu -l$modem_device -s2400 2>&1");
	# starting cu hoses /dev/tty's stty settings, even when it has
	# been opened on a pipe...
	system("/bin/stty $stty");
	$_ = <MODEM_IN>;
	chop;
	if ( !m/^Connected/ ) {
	    print STDERR "$0: cu printed `$_' instead of `Connected'\n";
	}
    }

d157 3
a159 6
password system employs one-way encryption.  It's more like hashing than
encryption.  The best you can check is whether something else hashes to
the same string.  You can't turn a hash back into the original string.
Programs like Crack
can forcibly (and intelligently) try to guess passwords, but don't
(can't) guarantee quick success.
d177 1
a177 1
=item STDIN, STDOUT, and STDERR are shared
d207 3
a209 4
You don't actually "trap" a control character.  Instead, that character
generates a signal which is sent to your terminal's currently
foregrounded process group, which you then trap in your process.
Signals are documented in L<perlipc/"Signals"> and chapter 6 of the Camel.
d238 4
a241 5
If perl was installed correctly, and your shadow library was written
properly, the getpw*() functions described in L<perlfunc> should in
theory provide (read-only) access to entries in the shadow password
file.  To change the file, make a new shadow password file (the format
varies from system to system - see L<passwd(5)> for specifics) and use
d257 1
a257 1
    system "trn comp.lang.perl.misc";
d272 3
a274 3
If your system supports both the syscall() function in Perl as well as
a system call like gettimeofday(2), then you may be able to do
something like this:
d282 1
a282 1
    syscall( &SYS_gettimeofday, $start, 0) != -1
d306 3
a308 11
thread ends (see L<perlmod> manpage for more details).  

For example, you can use this to make sure your filter program
managed to finish its output without filling up the disk:

    END {
	close(STDOUT) || die "stdout close failed: $!";
    } 

The END block isn't called when untrapped signals kill the program, though, so if
you use END blocks you should also use
d378 3
a380 9
easy-to-use approach that internally uses pipe(), fork(), and exec() to do
the job.  Make sure you read the deadlock warnings in its documentation,
though (see L<IPC::Open2>).  See L<perlipc/"Bidirectional Communication
with Another Process"> and L<perlipc/"Bidirectional Communication with
Yourself">

You may also use the IPC::Open3 module (part of the standard perl
distribution), but be warned that it has a different order of
arguments from IPC::Open2 (see L<IPC::Open3>).
d386 1
a386 1
the low 7 bits are the signal the process died from, if any, and
a436 1
To capture a command's STDERR and STDOUT together:
d438 3
a440 38
    $output = `cmd 2>&1`;                       # either with backticks
    $pid = open(PH, "cmd 2>&1 |");              # or with an open pipe
    while (<PH>) { }                            #    plus a read

To capture a command's STDOUT but discard its STDERR:

    $output = `cmd 2>/dev/null`;                # either with backticks
    $pid = open(PH, "cmd 2>/dev/null |");       # or with an open pipe
    while (<PH>) { }                            #    plus a read

To capture a command's STDERR but discard its STDOUT:

    $output = `cmd 2>&1 1>/dev/null`;           # either with backticks
    $pid = open(PH, "cmd 2>&1 1>/dev/null |");  # or with an open pipe
    while (<PH>) { }                            #    plus a read

To exchange a command's STDOUT and STDERR in order to capture the STDERR
but leave its STDOUT to come out our old STDERR:

    $output = `cmd 3>&1 1>&2 2>&3 3>&-`;        # either with backticks
    $pid = open(PH, "cmd 3>&1 1>&2 2>&3 3>&-|");# or with an open pipe
    while (<PH>) { }                            #    plus a read

To read both a command's STDOUT and its STDERR separately, it's easiest
and safest to redirect them separately to files, and then read from those
files when the program is done:

    system("program args 1>/tmp/program.stdout 2>/tmp/program.stderr");

Ordering is important in all these examples.  That's because the shell
processes file descriptor redirections in strictly left to right order.

    system("prog args 1>tmpfile 2>&1");
    system("prog args 2>&1 1>tmpfile");

The first command sends both standard out and standard error to the
temporary file.  The second command sends only the old standard output
there, and the old standard error shows up on the old standard out.
d444 9
a452 9
Because the pipe open takes place in two steps: first Perl calls
fork() to start a new process, then this new process calls exec() to
run the program you really wanted to open.  The first step reports
success or failure to your process, so open() can only tell you
whether the fork() succeeded or not.

To find out if the exec() step succeeded, you have to catch SIGCHLD
and wait() to get the exit status.  You should also catch SIGPIPE if
you're writing to the child--you may not have found out the exec()
a454 7
In some cases, even this won't work.  If the second argument to a
piped open() contains shell metacharacters, perl fork()s, then exec()s
a shell to decode the metacharacters and eventually run the desired
program.  Now when you call wait(), you only learn whether or not the
I<shell> could be successfully started.  Best to avoid shell
metacharacters.

d456 1
a456 1
you expect--unless perl uses a shell to start your command. In this
d490 1
a490 1
at the end) and also check the return value.
a515 2
There are more examples of this L<perlipc/"Safe Pipe Opens">.

d585 3
a587 4
standard perl distribution), which never really got finished.  If you
find it somewhere, I<don't use it>.  These days, your best bet is to
look at the Expect module available from CPAN, which also requires two
other modules from CPAN, IO::Pty and IO::Stty.
d615 5
a619 1
comp.unix.questions FAQ for details.  
d640 2
a641 3
Open /dev/tty and use the TIOCNOTTY ioctl on it.  See L<tty(4)>
for details.  Or better yet, you can just use the POSIX::setsid()
function, so you don't have to worry about process groups.
a659 3
The Proc::Daemon module, available from CPAN, provides a function to
perform these actions for you.

d678 1
a678 1
    $tpgrp = tcgetpgrp(fileno(*TTY));
a707 2
A lot of information on this can be found at 
http://www.hermetica.com/technologia/perl/DBI/index.html .
d713 1
a713 4
passes the signal on to the subprocess.  Or you can check for it:

    $rc = system($cmd);
    if ($rc & 127) { die "signal death" } 
d761 2
a762 25
See L<ExtUtils::MakeMaker> for more details on building extensions.
See also the next question.

=head2 What's the difference between require and use?

Perl offers several different ways to include code from one file into
another.  Here are the deltas between the various inclusion constructs:

    1)  do $file is like eval `cat $file`, except the former:
	1.1: searches @@INC and updates %INC.
	1.2: bequeaths an *unrelated* lexical scope on the eval'ed code.

    2)  require $file is like do $file, except the former:
	2.1: checks for redundant loading, skipping already loaded files.
	2.2: raises an exception on failure to find, compile, or execute $file.

    3)  require Module is like require "Module.pm", except the former:
	3.1: translates each "::" into your system's directory separator.
	3.2: primes the parser to disambiguate class Module as an indirect object.

    4)  use Module is like require Module, except the former:
	4.1: loads the module at compile time, not run-time.
	4.2: imports symbols and semantics from that package to the current one.

In general, you usually want C<use> and a proper Perl module.
a775 7
This is almost the same as:

    BEGIN {
	unshift(@@INC, '/u/mydir/perl');
    }

except that the lib module checks for machine-dependent subdirectories.
d781 1
a781 1
    use lib "$FindBin::Bin";
d790 1
a790 1
    the perl -Idir command line flag
d798 17
a814 1
=head2 What is socket.ph and where do I get it?
d816 14
a829 3
It's a perl4-style file defining values for system networking
constants.  Sometimes it is built using h2ph when Perl is installed,
but other times it is not.  Modern programs C<use Socket;> instead.
d831 5
a835 1
=head1 AUTHOR AND COPYRIGHT
d837 7
a843 2
Copyright (c) 1997-1999 Tom Christiansen and Nathan Torkington.
All rights reserved.
d845 4
a848 12
When included as part of the Standard Version of Perl, or as part of
its complete documentation whether printed or otherwise, this work
may be distributed only under the terms of Perl's Artistic Licence.
Any distribution of this file or derivatives thereof I<outside>
of that package require that special arrangements be made with
copyright holder.

Irrespective of its distribution, all code examples in this file
are hereby placed into the public domain.  You are permitted and
encouraged to use this code in your own programs for fun
or for profit as you see fit.  A simple comment in the code giving
credit would be courteous but is not required.
d850 2
@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
perlfaq8 - System Interaction ($Revision: 1.39 $, $Date: 1999/05/23 18:37:57 $)
d18 2
a19 3
The $^O variable ($OSNAME if you use English) contains an indication of
the name of the operating system (not its release number) that your perl
binary was built for.
d77 1
a77 1
On many systems, you can just use the B<stty> command as shown in
d170 1
a170 1
If you only have do so infrequently, use C<system>:
d412 1
a412 1
you're in a "slow" call, such as <FH>, read(), connect(), or
d424 1
a424 1
pwd_mkdb(8) to install it (see L<pwd_mkdb(8)> for more details).
d464 1
a464 1
    syscall(&SYS_gettimeofday, $start, 0) != -1
d702 1
a702 1
humongous) return value, and you're ignoring it.  It's may also not be very
d728 1
a728 1
Which will get the output quickly (as it is generated, instead of only
a753 1
Further examples of this can be found in L<perlipc/"Safe Pipe Opens">.
d755 1
a755 6
Note that if you're stuck on Microsoft, no solution to this vexing issue
is even possible.  Even if Perl were to emulate fork(), you'd still
be hosed, because Microsoft gives no argc/argv-style API.  Their API
always reparses from a single string, which is fundamentally wrong,
but you're not likely to get the Gods of Redmond to acknowledge this
and fix it for you.
d931 1
a931 1
handler, as documented in L<perlipc/"Signals"> and chapter 6 of the
d948 2
a949 1
DBD::* modules available from http://www.perl.com/CPAN/modules/DBD .
d951 1
a951 1
http://www.symbolstone.org/technology/perl/DBI/
d973 1
d975 4
a978 8


=head2 How do I install a module from CPAN?

The easiest way is to have a module also named CPAN do it for you.
This module comes with perl version 5.004 and later.  To manually install
the CPAN module, or any well-behaved CPAN module for that matter, follow
these steps:
d1088 1
a1088 1
may be distributed only under the terms of Perl's Artistic License.
d1098 1
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d8 1
a8 1
system interaction.  Topics include interprocess communication (IPC),
d98 4
a101 4
However, using the code requires that you have a working C compiler
and can use it to build and install a CPAN module.  Here's a solution
using the standard POSIX module, which is already on your systems
(assuming your system supports POSIX).
d217 4
a220 4
There's an example of this in L<perlfunc/crypt>).  First, you put the
terminal into "no echo" mode, then just read the password normally.
You may do this with an old-style ioctl() function, POSIX terminal
control (see L<POSIX> or its documentation the Camel Book), or a call
d235 1
a235 1
/dev; on other systems, device names will doubtless differ.
d237 1
a237 1
following:
d244 1
a244 1
you follow the correct protocol.  Unpredictable behavior can result
d267 1
a267 1
Even though with normal text files a "\n" will do the trick, there is
d279 1
a279 2
and L<perlfunc/select>, or L<perlfaq5>, ``How do I flush/unbuffer an
output filehandle?  Why must I do this?''):
d323 1
a323 1
	chomp;
d334 1
a334 1
Seriously, you can't if they are Unix password files--the Unix
d391 1
a391 2
Signals are documented in L<perlipc/"Signals"> and the
section on ``Signals'' in the Camel.
d400 1
a400 1
signal handler are (1) set a variable and (2) exit.  In the first case,
d416 1
a416 2
blocking flock() in L<perlipc/"Signals"> or the section on ``Signals''
in the Camel book.
d420 1
a420 1
If perl was installed correctly and your shadow library was written
d424 1
a424 1
varies from system to system--see L<passwd(5)> for specifics) and use
d446 3
a448 2
documented in L<perlfunc/"select">.  Try the Time::HiRes and
the BSD::Itimer modules (available from CPAN).
d498 2
a499 2
The END block isn't called when untrapped signals kill the program,
though, so if you use END blocks you should also use
d506 1
a506 2
flock() in L<perlipc/"Signals"> or the section on ``Signals'' in
the Camel Book.
d514 1
a514 1
=head2 Why doesn't my sockets program work under System V (Solaris)?  What does the error message "Protocol not supported" mean?
d526 1
a526 1
In most cases, you write an external module to do it--see the answer
d533 1
a533 1
CPAN as well--someone may already have written a module to do it.
d571 3
a573 3
though (see L<IPC::Open2>).  See 
L<perlipc/"Bidirectional Communication with Another Process"> and 
L<perlipc/"Bidirectional Communication with Yourself">
d599 1
a599 1
script's STDOUT and STDERR, unless the system() command redirects them.
d692 1
a692 1
I<shell> could be successfully started...it's best to avoid shell
d719 2
a720 2
(for a little while).  You forgot to check C<$?> to see whether
the program even ran correctly, too.  Even if you wrote
d724 1
a724 1
this code could and probably should be written as
d729 1
a729 1
which will get the output quickly (as it is generated, instead of only
d766 1
a766 1
Some stdio's set error and eof flags that need clearing.  The
d859 1
a859 1
In the strictest sense, it can't be done--the script executes as a
d861 1
a861 1
process are not reflected in its parent--only in any children
d871 1
a871 1
to the process (see L<perlfunc/"kill">).  It's common to first send a TERM
d909 4
d938 3
a940 3
handler, as documented in L<perlipc/"Signals"> and the section on
``Signals'' in the Camel.  You may instead use the more flexible
Sys::AlarmCall module available from CPAN.
d979 3
d1018 1
a1018 2
See also the next question, ``What's the difference between require
and use?''.
d1025 1
a1025 1
    1)  do $file is like eval `cat $file`, except the former
d1029 1
a1029 1
    2)  require $file is like do $file, except the former
d1033 1
a1033 1
    3)  require Module is like require "Module.pm", except the former
d1037 1
a1037 1
    4)  use Module is like require Module, except the former
d1055 1
a1055 1
This is almost the same as
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
perlfaq8 - System Interaction ($Revision: 1.8 $, $Date: 2002/05/16 12:41:42 $)
d297 1
a297 1
socket I/O between Unix and Macintosh.  You'll need to hard code your
d438 1
a438 1
However, if all you want to do is change your time zone, you can
d450 1
a450 2
the BSD::Itimer modules (available from CPAN, and starting from
Perl 5.8 Time::HiRes is part of the standard distribution).
d455 1
a455 2
from CPAN, and starting from Perl 5.8 part of the standard distribution)
provides this functionality for some systems.
d635 3
a637 4
and pipe opens all use the Bourne shell are in the
F<versus/csh.whynot> article in the "Far More Than You Ever Wanted To
Know" collection in http://www.cpan.org/olddoc/FMTEYEWTK.tgz .  To
capture a command's STDERR and STDOUT together:
d680 21
a700 13
If the second argument to a piped C<open> contains shell
metacharacters, perl fork()s, then exec()s a shell to decode the
metacharacters and eventually run the desired program.  If the program
couldn't be run, it's the shell that gets the message, not Perl. All
your Perl program can find out is whether the shell itself could be
successfully started.  You can still capture the shell's STDERR and
check it for error messages.  See L<"How can I capture STDERR from an
external command?"> elsewhere in this document, or use the
L<IPC::Open3> module.

If there are no shell metacharacters in the argument of C<open>, Perl
runs the command directly, without using the shell, and can correctly
report whether the command started.
d705 11
a715 8
way to write maintainable code.  Perl has several operators for
running external commands.  Backticks are one; they collect the output
from the command for use in your program.  The C<system> function is
another; it doesn't do this.  

Writing backticks in your program sends a clear message to the readers
of your code that you wanted to collect the output of the command.
Why send a clear message that isn't true?
d721 3
a723 2
You forgot to check C<$?> to see whether the program even ran
correctly.  Even if you wrote
d812 1
a812 1
CPAN).  http://www.cpan.org/scripts/netstuff/telnet.emul.shar
d954 3
a956 2
DBD::* modules available from http://www.cpan.org/modules/DBD .
A lot of information on this can be found at http://dbi.perl.org/
d981 3
a983 11
This module comes with perl version 5.004 and later.  

    $ perl -MCPAN -e shell

    cpan shell -- CPAN exploration and modules installation (v1.59_54)
    ReadLine support enabled

    cpan> install Some::Module 

To manually install the CPAN module, or any well-behaved CPAN module 
for that matter, follow these steps:
d1089 1
a1089 1
Copyright (c) 1997-2002 Tom Christiansen and Nathan Torkington.
d1092 6
a1097 2
This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 1
perlfaq8 - System Interaction ($Revision: 1.17 $, $Date: 2003/01/26 17:44:04 $)
d80 1
a80 1
portability snags.
d191 1
a191 1
If you have Term::ReadKey module installed from CPAN,
d198 1
a198 1
This is more portable than the raw C<ioctl>, but not as
d278 1
a278 1
and the C<$|> variable to control autoflushing (see L<perlvar/$E<verbar>>
d349 1
a349 6
Several modules can start other processes that do not block
your Perl program.  You can use IPC::Open3, Parallel::Jobs,
IPC::Run, and some of the POE modules.  See CPAN for more
details.

You could also use
d378 1
a378 1
You have to be prepared to "reap" the child process when it finishes.
a381 16
    $SIG{CHLD} = 'IGNORE';

You can also use a double fork. You immediately wait() for your
first child, and the init daemon will wait() for your grandchild once
it exits.

	unless ($pid = fork) {
		unless (fork) {
            exec "what you really wanna do";
            die "exec failed!";
        	}
        exit 0;
    	}
    waitpid($pid,0);


d427 2
a428 2
varies from system to system--see L<passwd> for specifics) and use
pwd_mkdb(8) to install it (see L<pwd_mkdb> for more details).
d493 1
a493 1
thread ends (see L<perlmod> manpage for more details).
d500 1
a500 1
    }
d538 1
a538 4
CPAN as well---someone may already have written a module to do it. On
Windows, try Win32::API.  On Macs, try Mac::Carbon.  If no module
has an interface to the C function, you can inline a bit of C in your
Perl source with Inline::C.
d576 2
a577 2
though (see L<IPC::Open2>).  See
L<perlipc/"Bidirectional Communication with Another Process"> and
a606 62
You can also use the open3() function from IPC::Open3.  Benjamin
Goldberg provides some sample code:

To capture a program's STDOUT, but discard its STDERR:

    use IPC::Open3;
    use File::Spec;
    use Symbol qw(gensym);
    open(NULL, ">", File::Spec->devnull);
    my $pid = open3(gensym, \*PH, ">&NULL", "cmd");
    while( <PH> ) { }
    waitpid($pid, 0);

To capture a program's STDERR, but discard its STDOUT:

    use IPC::Open3;
    use File::Spec;
    use Symbol qw(gensym);
    open(NULL, ">", File::Spec->devnull);
    my $pid = open3(gensym, ">&NULL", \*PH, "cmd");
    while( <PH> ) { }
    waitpid($pid, 0);

To capture a program's STDERR, and let its STDOUT go to our own STDERR:

    use IPC::Open3;
    use Symbol qw(gensym);
    my $pid = open3(gensym, ">&STDERR", \*PH, "cmd");
    while( <PH> ) { }
    waitpid($pid, 0);

To read both a command's STDOUT and its STDERR separately, you can
redirect them to temp files, let the command run, then read the temp
files:

    use IPC::Open3;
    use Symbol qw(gensym);
    use IO::File;
    local *CATCHOUT = IO::File->new_tempfile;
    local *CATCHERR = IO::File->new_tempfile;
    my $pid = open3(gensym, ">&CATCHOUT", ">&CATCHERR", "cmd");
    waitpid($pid, 0);
    seek $_, 0, 0 for \*CATCHOUT, \*CATCHERR;
    while( <CATCHOUT> ) {}
    while( <CATCHERR> ) {}

But there's no real need for *both* to be tempfiles... the following
should work just as well, without deadlocking:

    use IPC::Open3;
    use Symbol qw(gensym);
    use IO::File;
    local *CATCHERR = IO::File->new_tempfile;
    my $pid = open3(gensym, \*CATCHOUT, ">&CATCHERR", "cmd");
    while( <CATCHOUT> ) {}
    waitpid($pid, 0);
    seek CATCHERR, 0, 0;
    while( <CATCHERR> ) {}

And it'll be faster, too, since we can begin processing the program's
stdout immediately, rather than waiting for the program to finish.

d639 1
a639 1
Know" collection in http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz .  To
d683 1
a683 1
If the second argument to a piped open() contains shell
d691 1
a691 1
IPC::Open3 module.
d693 1
a693 1
If there are no shell metacharacters in the argument of open(), Perl
d703 1
a703 1
another; it doesn't do this.
d731 1
a731 2
This is a bit tricky.  You can't simply write the command
like this:
d735 1
a735 9
As of Perl 5.8.0, you can use open() with multiple arguments.
Just like the list forms of system() and exec(), no shell
escapes happen.

   open( GREP, "-|", 'grep', @@opts, $search_string, @@filenames );
   chomp(@@ok = <GREP>);
   close GREP;

You can also:
d751 1
a751 1
Note that if you're use Microsoft, no solution to this vexing issue
d753 4
a756 1
be stuck, because Microsoft does not have a argc/argv-style API.
d858 1
a858 1
comp.unix.questions FAQ for details.
d879 1
a879 1
Open /dev/tty and use the TIOCNOTTY ioctl on it.  See L<tty>
a931 3
The alarm() function is not implemented on all versions of Windows.
Check the documentation for your specific version of Perl.

d940 1
a940 1
in L<perlfaq8/"How do I start a process in the background?">.
d944 3
a946 9
The DBI module provides an abstract interface to most database
servers and types, including Oracle, DB2, Sybase, mysql, Postgresql,
ODBC, and flat files.  The DBI module accesses each database type
through a database driver, or DBD.  You can see a complete list of
available drivers on CPAN: http://www.cpan.org/modules/by-module/DBD/ .
You can read more about DBI on http://dbi.perl.org .

Other modules provide more specific access: Win32::ODBC, Alzabo, iodbc,
and others found on CPAN Search: http://search.cpan.org .
d955 1
a955 1
    if ($rc & 127) { die "signal death" }
d971 1
a971 1
This module comes with perl version 5.004 and later.
d978 1
a978 1
    cpan> install Some::Module
d980 1
a980 1
To manually install the CPAN module, or any well-behaved CPAN module
d1040 1
a1040 1
When you build modules, use the PREFIX and LIB options when generating
d1043 1
a1043 1
    perl Makefile.PL PREFIX=/mydir/perl LIB=/mydir/perl/lib
d1048 1
a1048 1
    use lib '/mydir/perl/lib';
d1053 1
a1053 1
	unshift(@@INC, '/mydir/perl/lib');
d1065 1
a1065 1
=head2 How do I add a directory to my include path (@@INC) at runtime?
d1087 1
a1087 1
Copyright (c) 1997-2003 Tom Christiansen and Nathan Torkington.
@


1.1.1.6
log
@Import of stock perl 5.8.5
@
text
@d3 1
a3 1
perlfaq8 - System Interaction ($Revision: 1.6 $, $Date: 2003/12/03 03:02:45 $)
d752 2
a753 2
to redirect them separately to files, and then read from those files
when the program is done:
d755 1
a755 1
    system("program args 1>program.stdout 2>program.stderr");
d1066 2
a1067 2
    sysopen(FH, "/foo/somefile", O_WRONLY|O_NDELAY|O_CREAT, 0644)
        or die "can't open /foo/somefile: $!":
@


1.1.1.7
log
@perl 5.8.6 from CPAN
@
text
@d3 1
a3 1
perlfaq8 - System Interaction ($Revision: 1.22 $, $Date: 2004/10/05 22:13:49 $)
d416 18
a433 23
You can set the values of the %SIG hash to be the functions you want 
to handle the signal.  After perl catches the signal, it looks in %SIG
for a key with the same name as the signal, then calls the subroutine
value for that key.

	# as an anonymous subroutine
	
	$SIG{INT} = sub { syswrite(STDERR, "ouch\n", 5 ) };
	
	# or a reference to a function
	
	$SIG{INT} = \&ouch;
	
	# or the name of the function as a string
	
	$SIG{INT} = "ouch"; 

Perl versions before 5.8 had in its C source code signal handlers which
would catch the signal and possibly run a Perl function that you had set
in %SIG.  This violated the rules of signal handling at that level
causing perl to dump core. Since version 5.8.0, perl looks at %SIG
*after* the signal has been caught, rather than while it is being caught.
Previous versions of this answer were incorrect.
d435 6
a1067 68

=head2 How do I tell the difference between errors from the shell and perl?

(answer contributed by brian d foy, C<< <bdfoy@@cpan.org> >>

When you run a Perl script, something else is running the script for you,
and that something else may output error messages.  The script might
emit its own warnings and error messages.  Most of the time you cannot
tell who said what.

You probably cannot fix the thing that runs perl, but you can change how
perl outputs its warnings by defining a custom warning and die functions.

Consider this script, which has an error you may not notice immediately.

	#!/usr/locl/bin/perl

	print "Hello World\n";

I get an error when I run this from my shell (which happens to be
bash).  That may look like perl forgot it has a print() function,
but my shebang line is not the path to perl, so the shell runs the
script, and I get the error.

	$ ./test
	./test: line 3: print: command not found

A quick and dirty fix involves a little bit of code, but this may be all
you need to figure out the problem.

	#!/usr/bin/perl -w
	
	BEGIN {
	$SIG{__WARN__} = sub{ print STDERR "Perl: ", @@_; };
	$SIG{__DIE__}  = sub{ print STDERR "Perl: ", @@_; exit 1};
	}
	
	$a = 1 + undef;
	$x / 0;
	__END__

The perl message comes out with "Perl" in front.  The BEGIN block
works at compile time so all of the compilation errors and warnings
get the "Perl:" prefix too.

	Perl: Useless use of division (/) in void context at ./test line 9.
	Perl: Name "main::a" used only once: possible typo at ./test line 8.
	Perl: Name "main::x" used only once: possible typo at ./test line 9.
	Perl: Use of uninitialized value in addition (+) at ./test line 8.
	Perl: Use of uninitialized value in division (/) at ./test line 9.
	Perl: Illegal division by zero at ./test line 9.
	Perl: Illegal division by zero at -e line 3.

If I don't see that "Perl:", it's not from perl.

You could also just know all the perl errors, and although there are
some people who may know all of them, you probably don't.  However, they
all should be in the perldiag manpage. If you don't find the error in
there, it probably isn't a perl error.

Looking up every message is not the easiest way, so let perl to do it
for you.  Use the diagnostics pragma with turns perl's normal messages
into longer discussions on the topic.

	use diagnostics;

If you don't get a paragraph or two of expanded discussion, it
might not be perl's message.
@


1.1.1.8
log
@perl 5.8.8 import
@
text
@d3 1
a3 1
perlfaq8 - System Interaction ($Revision: 1.27 $, $Date: 2005/12/31 00:54:37 $)
d38 5
a42 5
	Term::Cap               Standard perl distribution
	Term::ReadKey           CPAN
	Term::ReadLine::Gnu     CPAN
	Term::ReadLine::Perl    CPAN
	Term::Screen            CPAN
d46 3
a48 3
	Term::Cap               Standard perl distribution
	Curses                  CPAN
	Term::ANSIColor         CPAN
d52 1
a52 1
	Tk                      CPAN
d56 1
a56 2
Some of these specific cases are shown as examples in other answers
in this section of the perlfaq.
d279 2
a280 2
and L<perlfunc/select>, or L<perlfaq5>, "How do I flush/unbuffer an
output filehandle?  Why must I do this?"):
d414 1
a414 1
section on "Signals" in the Camel.
d416 1
a416 1
You can set the values of the %SIG hash to be the functions you want
d422 1
a422 1

d424 1
a424 1

d426 1
a426 1

d428 1
a428 1

d430 2
a431 2

	$SIG{INT} = "ouch";
d530 1
a530 1
flock() in L<perlipc/"Signals"> or the section on "Signals" in
d668 2
a669 2
    local *CATCHOUT = IO::File->new_tmpfile;
    local *CATCHERR = IO::File->new_tmpfile;
d682 1
a682 1
    local *CATCHERR = IO::File->new_tmpfile;
d1020 1
a1020 1
"Signals" in the Camel.  You may instead use the more flexible
d1098 1
a1098 1

d1103 1
a1103 1

d1180 2
a1181 2
See also the next question, "What's the difference between require
and use?".
d1255 2
a1256 2
Copyright (c) 1997-2006 Tom Christiansen, Nathan Torkington, and
other authors as noted. All rights reserved.
@


1.1.1.9
log
@import perl 5.10.0 from CPAN
@
text
@d3 1
a3 1
perlfaq8 - System Interaction ($Revision: 10183 $)
d66 3
a68 3
	use Term::ANSIColor;
	print color("red"), "Stop!\n", color("reset");
	print color("green"), "Go!\n", color("reset");
d72 3
a74 3
	use Term::ANSIColor qw(:constants);
	print RED, "Stop!\n", RESET;
	print GREEN, "Go!\n", RESET;
d83 6
a88 6
	open(TTY, "+</dev/tty") or die "no tty: $!";
	system "stty  cbreak </dev/tty >/dev/tty 2>&1";
	$key = getc(TTY);		# perhaps this works
	# OR ELSE
	sysread(TTY, $key, 1);	# probably this does
	system "stty -cbreak </dev/tty >/dev/tty 2>&1";
d94 4
a97 4
	use Term::ReadKey;
	ReadMode('cbreak');
	$key = ReadKey(0);
	ReadMode('normal');
d104 2
a105 2
	use HotKey;
	$key = readkey();
d110 2
a111 2
	# HotKey.pm
	package HotKey;
d113 2
a114 2
	@@ISA = qw(Exporter);
	@@EXPORT = qw(cbreak cooked readkey);
d116 31
a146 23
	use strict;
	use POSIX qw(:termios_h);
	my ($term, $oterm, $echo, $noecho, $fd_stdin);

	$fd_stdin = fileno(STDIN);
	$term     = POSIX::Termios->new();
	$term->getattr($fd_stdin);
	$oterm     = $term->getlflag();

	$echo     = ECHO | ECHOK | ICANON;
	$noecho   = $oterm & ~$echo;

	sub cbreak {
		$term->setlflag($noecho);  # ok, so i don't want echo either
		$term->setcc(VTIME, 1);
		$term->setattr($fd_stdin, TCSANOW);
	}

	sub cooked {
		$term->setlflag($oterm);
		$term->setcc(VTIME, 0);
		$term->setattr($fd_stdin, TCSANOW);
	}
d148 1
a148 7
	sub readkey {
		my $key = '';
		cbreak();
		sysread(STDIN, $key, 1);
		cooked();
		return $key;
	}
d150 1
a150 3
	END { cooked() }

	1;
d158 1
a158 1
	use Term::ReadKey;
d160 1
a160 1
	ReadMode('cbreak');
d162 5
a166 5
	if (defined ($char = ReadKey(-1)) ) {
		# input was waiting and it was $char
	} else {
		# no input was waiting
	}
d168 1
a168 1
	ReadMode('normal');                  # restore normal tty settings
d174 1
a174 1
	system("clear");
d180 2
a181 2
	$clear_string = `clear`;
	print $clear_string;
d186 3
a188 3
	use Term::Cap;
	$terminal = Term::Cap->Tgetent( {OSPEED => 9600} );
	$clear_string = $terminal->Tputs('cl');
d196 2
a197 2
	use Term::ReadKey;
	($wchar, $hchar, $wpixels, $hpixels) = GetTerminalSize();
d202 10
a211 10
	require 'sys/ioctl.ph';
	die "no TIOCGWINSZ " unless defined &TIOCGWINSZ;
	open(TTY, "+</dev/tty")                     or die "No tty: $!";
	unless (ioctl(TTY, &TIOCGWINSZ, $winsize='')) {
		die sprintf "$0: ioctl TIOCGWINSZ (%08x: $!)\n", &TIOCGWINSZ;
	}
	($row, $col, $xpixel, $ypixel) = unpack('S4', $winsize);
	print "(row,col) = ($row,$col)";
	print "  (xpixel,ypixel) = ($xpixel,$ypixel)" if $xpixel || $ypixel;
	print "\n";
d227 1
a227 1
	use Term::ReadKey;
d229 2
a230 2
	ReadMode('noecho');
	$password = ReadLine(0);
d265 2
a266 2
	print DEV "atv1\012";	# wrong, for some devices
	print DEV "atv1\015";	# right, for some devices
d283 3
a285 3
	$oldh = select(DEV);
	$| = 1;
	select($oldh);
d289 1
a289 1
	select((select(DEV), $| = 1)[0]);
d294 2
a295 2
	use IO::Handle;
	DEV->autoflush(1);
d313 1
a313 1
C<< <jwz@@netscape.com> >>, after much gnashing of teeth and fighting with sysread,
d317 11
a327 12
	sub open_modem {
		use IPC::Open2;
		my $stty = `/bin/stty -g`;
		open2( \*MODEM_IN, \*MODEM_OUT, "cu -l$modem_device -s2400 2>&1");
		# starting cu hoses /dev/tty's stty settings, even when it has
		# been opened on a pipe...
		system("/bin/stty $stty");
		$_ = <MODEM_IN>;
		chomp;
		if ( !m/^Connected/ ) {
			print STDERR "$0: cu printed `$_' instead of `Connected'\n";
		}
d329 1
d337 6
a342 5
password system employs one-way encryption.  It's more like hashing
than encryption.  The best you can do is check whether something else
hashes to the same string.  You can't turn a hash back into the
original string. Programs like Crack can forcibly (and intelligently)
try to guess passwords, but don't (can't) guarantee quick success.
d357 1
a357 1
	system("cmd &")
d386 1
a386 1
	$SIG{CHLD} = sub { wait };
d388 1
a388 1
	$SIG{CHLD} = 'IGNORE';
d395 8
a402 7
	    unless (fork) {
		exec "what you really wanna do";
		die "exec failed!";
	    }
	    exit 0;
	}
	waitpid($pid, 0);
d441 1
d462 3
a464 3
	$ENV{TZ} = "MST7MDT";		   # unixish
	$ENV{'SYS$TIMEZONE_DIFFERENTIAL'}="-5" # vms
	system "trn comp.lang.perl.misc";
a466 1
X<Time::HiRes> X<BSD::Itimer> X<sleep> X<select>
d468 5
a472 5
If you want finer granularity than the 1 second that the C<sleep()>
function provides, the easiest way is to use the C<select()> function as
documented in L<perlfunc/"select">.  Try the C<Time::HiRes> and
the C<BSD::Itimer> modules (available from CPAN, and starting from
Perl 5.8 C<Time::HiRes> is part of the standard distribution).
a474 1
X<Time::HiRes> X<BSD::Itimer> X<sleep> X<select>
d476 13
a488 1
(contributed by brian d foy)
d490 19
a508 6
The C<Time::HiRes> module (part of the standard distribution as of
Perl 5.8) measures time with the C<gettimeofday()> system call, which
returns the time in microseconds since the epoch. If you can't install
C<Time::HiRes> for older Perls and you are on a Unixish system, you
may be able to call C<gettimeofday(2)> directly. See
L<perlfunc/syscall>.
d519 3
a521 3
	END {
		close(STDOUT) || die "stdout close failed: $!";
	}
d559 1
a559 1
CPAN as well--someone may already have written a module to do it. On
d575 3
a577 3
	1.  become super-user
	2.  cd /usr/include
	3.  h2ph *.h */*.h
d616 2
a617 2
	$exit_status   = system("mail-users");
	$output_string = `ls`;
d623 3
a625 3
	system $cmd;		# using system()
	$output = `$cmd`;		# using backticks (``)
	open (PIPE, "cmd |");	# using open()
d636 7
a642 7
	use IPC::Open3;
	use File::Spec;
	use Symbol qw(gensym);
	open(NULL, ">", File::Spec->devnull);
	my $pid = open3(gensym, \*PH, ">&NULL", "cmd");
	while( <PH> ) { }
	waitpid($pid, 0);
d646 7
a652 7
	use IPC::Open3;
	use File::Spec;
	use Symbol qw(gensym);
	open(NULL, ">", File::Spec->devnull);
	my $pid = open3(gensym, ">&NULL", \*PH, "cmd");
	while( <PH> ) { }
	waitpid($pid, 0);
d656 5
a660 5
	use IPC::Open3;
	use Symbol qw(gensym);
	my $pid = open3(gensym, ">&STDERR", \*PH, "cmd");
	while( <PH> ) { }
	waitpid($pid, 0);
d666 10
a675 10
	use IPC::Open3;
	use Symbol qw(gensym);
	use IO::File;
	local *CATCHOUT = IO::File->new_tmpfile;
	local *CATCHERR = IO::File->new_tmpfile;
	my $pid = open3(gensym, ">&CATCHOUT", ">&CATCHERR", "cmd");
	waitpid($pid, 0);
	seek $_, 0, 0 for \*CATCHOUT, \*CATCHERR;
	while( <CATCHOUT> ) {}
	while( <CATCHERR> ) {}
d680 9
a688 9
	use IPC::Open3;
	use Symbol qw(gensym);
	use IO::File;
	local *CATCHERR = IO::File->new_tmpfile;
	my $pid = open3(gensym, \*CATCHOUT, ">&CATCHERR", "cmd");
	while( <CATCHOUT> ) {}
	waitpid($pid, 0);
	seek CATCHERR, 0, 0;
	while( <CATCHERR> ) {}
d695 2
a696 2
	open(STDOUT, ">logfile");
	system("ls");
d700 2
a701 2
	$output = `$cmd 2>some_file`;
	open (PIPE, "cmd 2>some_file |");
d706 2
a707 2
	$output = `$cmd 2>&1`;
	open (PIPE, "cmd 2>&1 |");
d713 2
a714 2
	open(STDERR, ">&STDOUT");
	$alloutput = `cmd args`;  # stderr still escapes
d728 3
a730 3
	$output = `cmd 2>&1`;                       # either with backticks
	$pid = open(PH, "cmd 2>&1 |");              # or with an open pipe
	while (<PH>) { }                            #    plus a read
d734 3
a736 3
	$output = `cmd 2>/dev/null`;                # either with backticks
	$pid = open(PH, "cmd 2>/dev/null |");       # or with an open pipe
	while (<PH>) { }                            #    plus a read
d740 3
a742 3
	$output = `cmd 2>&1 1>/dev/null`;           # either with backticks
	$pid = open(PH, "cmd 2>&1 1>/dev/null |");  # or with an open pipe
	while (<PH>) { }                            #    plus a read
d747 3
a749 3
	$output = `cmd 3>&1 1>&2 2>&3 3>&-`;        # either with backticks
	$pid = open(PH, "cmd 3>&1 1>&2 2>&3 3>&-|");# or with an open pipe
	while (<PH>) { }                            #    plus a read
d755 1
a755 1
	system("program args 1>program.stdout 2>program.stderr");
d760 2
a761 2
	system("prog args 1>tmpfile 2>&1");
	system("prog args 2>&1 1>tmpfile");
d797 1
a797 1
	`cat /etc/termcap`;
d802 1
a802 1
	print `cat /etc/termcap`;
d806 1
a806 1
	system("cat /etc/termcap") == 0
d809 2
a810 3
which will echo the cat command's output as it is generated, instead
of waiting until the program has completed to print it out. It also
checks the return value.
d812 1
a812 1
C<system> also provides direct control over whether shell wildcard
d820 1
a820 1
	@@ok = `grep @@opts '$search_string' @@filenames`;
d822 2
a823 2
As of Perl 5.8.0, you can use C<open()> with multiple arguments.
Just like the list forms of C<system()> and C<exec()>, no shell
d826 3
a828 3
	open( GREP, "-|", 'grep', @@opts, $search_string, @@filenames );
	chomp(@@ok = <GREP>);
	close GREP;
d832 17
a848 18
	my @@ok = ();
	if (open(GREP, "-|")) {
		while (<GREP>) {
			chomp;
			push(@@ok, $_);
		}
		close GREP;
	} else {
		exec 'grep', @@opts, $search_string, @@filenames;
	}

Just as with C<system()>, no shell escapes happen when you C<exec()> a
list. Further examples of this can be found in L<perlipc/"Safe Pipe
Opens">.

Note that if you're using Windows, no solution to this vexing issue is
even possible.  Even if Perl were to emulate C<fork()>, you'd still be
stuck, because Windows does not have an argc/argv-style API.
d863 2
a864 2
	$where = tell(LOG);
	seek(LOG, $where, 0);
d903 12
a914 12
	use IO::Socket;             # new in 5.004
	$handle = IO::Socket::INET->new('www.perl.com:80')
	    or die "can't connect to port 80 on www.perl.com: $!";
	$handle->autoflush(1);
	if (fork()) {               # XXX: undef means failure
	    select($handle);
	    print while <STDIN>;    # everything from stdin to socket
	} else {
	    print while <$handle>;  # everything from socket to stdout
	}
	close $handle;
	exit;
d937 1
a937 1
	$0 = "orcus [accepting connections]";
d988 1
a988 1
	fork && exit;
d997 1
a997 1
Good question. Sometimes C<-t STDIN> and C<-t STDOUT> can give clues,
d1000 3
a1002 3
	if (-t STDIN && -t STDOUT) {
		print "Now what? ";
		}
d1007 9
a1015 15
	use POSIX qw/getpgrp tcgetpgrp/;

	# Some POSIX systems, such as Linux, can be
	# without a /dev/tty at boot time.
	if (!open(TTY, "/dev/tty")) {
		print "no tty\n";
	} else {
		$tpgrp = tcgetpgrp(fileno(*TTY));
		$pgrp = getpgrp();
		if ($tpgrp == $pgrp) {
			print "foreground\n";
		} else {
			print "background\n";
		}
	}
a1027 1
X<BSD::Resource> X<limit> X<CPU>
d1029 1
a1029 16
(contributed by Xho)

Use the C<BSD::Resource> module from CPAN. As an example:

	use BSD::Resource;
	setrlimit(RLIMIT_CPU,10,20) or die $!;

This sets the soft and hard limits to 10 and 20 seconds, respectively.
After 10 seconds of time spent running on the CPU (not "wall" time),
the process will be sent a signal (XCPU on some systems) which, if not
trapped, will cause the process to terminate.  If that signal is
trapped, then after 10 more seconds (20 seconds in total) the process
will be killed with a non-trappable signal.

See the C<BSD::Resource> and your systems documentation for the gory
details.
d1055 2
a1056 2
	$rc = system($cmd);
	if ($rc & 127) { die "signal death" }
d1065 3
a1067 3
	use Fcntl;
	sysopen(FH, "/foo/somefile", O_WRONLY|O_NDELAY|O_CREAT, 0644)
		or die "can't open /foo/somefile: $!":
d1071 1
a1071 1
(answer contributed by brian d foy)
d1142 1
a1142 1
	$ perl -MCPAN -e shell
d1144 2
a1145 2
	cpan shell -- CPAN exploration and modules installation (v1.59_54)
	ReadLine support enabled
d1147 1
a1147 1
	cpan> install Some::Module
d1160 1
a1160 1
	perl Makefile.PL
d1164 1
a1164 1
	make
d1168 1
a1168 1
	make test
d1172 1
a1172 1
	make install
d1189 1
a1189 1
	1)  do $file is like eval `cat $file`, except the former
d1193 1
a1193 1
	2)  require $file is like do $file, except the former
d1197 1
a1197 1
	3)  require Module is like require "Module.pm", except the former
d1201 1
a1201 1
	4)  use Module is like require Module, except the former
d1209 2
a1210 6
When you build modules, tell Perl where to install the modules.

For C<Makefile.PL>-based distributions, use the PREFIX and LIB options
when generating Makefiles:

	perl Makefile.PL PREFIX=/mydir/perl LIB=/mydir/perl/lib
d1212 1
a1212 2
You can set this in your CPAN.pm configuration so modules automatically install
in your private library directory when you use the CPAN.pm shell:
d1214 2
a1215 3
	% cpan
	cpan> o conf makepl_arg PREFIX=/mydir/perl,LIB=/mydir/perl/lib
	cpan> o conf commit
d1217 1
a1217 1
For C<Build.PL>-based distributions, use the --install_base option:
d1219 1
a1219 1
	perl Build.PL --install_base /mydir/perl 
d1221 3
a1223 1
You can configure CPAN.pm to automatically use this option too:
d1225 2
a1226 3
	% cpan
	cpan> o conf mbuild_arg --install_base /mydir/perl
	cpan> o conf commit
d1230 3
a1232 40
(contributed by brian d foy)

If you know the directory already, you can add it to C<@@INC> as you would
for any other directory. You might <use lib> if you know the directory
at compile time:

	use lib $directory;
	
The trick in this task is to find the directory. Before your script does
anything else (such as a C<chdir>), you can get the current working
directory with the C<Cwd> module, which comes with Perl:

	BEGIN {
		use Cwd;
		our $directory = cwd;
		}
	
	use lib $directory;
	
You can do a similar thing with the value of C<$0>, which holds the
script name. That might hold a relative path, but C<rel2abs> can turn
it into an absolute path. Once you have the 

	BEGIN {	
		use File::Spec::Functions qw(rel2abs);
		use File::Basename qw(dirname);
		
		my $path   = rel2abs( $0 );
		our $directory = dirname( $path );
		}
		
	use lib $directory;

The C<FindBin> module, which comes with Perl, might work. It searches
through C<$ENV{PATH}> (so your script has to be in one of those
directories). You can then use that directory (in C<$FindBin::Bin>)
to locate nearby directories you want to add:

	use FindBin;
	use lib "$FindBin::Bin/../lib";
d1236 1
a1236 20
Here are the suggested ways of modifying your include path, including
environment variables, run-time switches, and in-code statements:

=over 4

=item the PERLLIB environment variable

	$ export PERLLIB=/path/to/my/dir
	$ perl program.pl

=item the PERL5LIB environment variable

	$ export PERL5LIB=/path/to/my/dir
	$ perl program.pl

=item the perl -Idir command line flag

	$ perl -I/path/to/my/dir program.pl

=item the use lib pragma:
d1238 5
a1242 1
	use lib "$ENV{HOME}/myown_perllib";
d1244 1
a1244 3
=back

The last is particularly useful because it knows about machine
d1250 1
a1250 1
It's a Perl 4 style file defining values for system networking
a1253 8
=head1 REVISION

Revision: $Revision: 10183 $

Date: $Date: 2007-11-07 09:35:12 +0100 (Wed, 07 Nov 2007) $

See L<perlfaq> for source control details and availability.

d1256 1
a1256 1
Copyright (c) 1997-2007 Tom Christiansen, Nathan Torkington, and
@


1.1.1.10
log
@import perl 5.10.1
@
text
@d3 1
a3 1
perlfaq8 - System Interaction
a22 1
X<exec> X<system> X<fork> X<open> X<pipe>
d24 4
a27 8
(contributed by brian d foy)

The C<exec> function's job is to turn your process into another
command and never to return. If that's not what you want to do, don't
use C<exec>. :)

If you want to run an external command and still keep your Perl process
going, look at a piped C<open>, C<fork>, or C<system>.
d172 1
a172 1
(contributed by brian d foy)
d174 1
a174 3
To clear the screen, you just have to print the special sequence
that tells the terminal to clear the screen. Once you have that
sequence, output it when you want to clear the screen.
d176 3
a178 2
You can use the C<Term::ANSIScreen> module to get the special
sequence. Import the C<cls> function (or the C<:screen> tag):
d180 2
a181 4
	use Term::ANSIScreen qw(cls);
	my $clear_screen = cls();

	print $clear_screen;
d183 2
a184 3
The C<Term::Cap> module can also get the special sequence if you want
to deal with the low-level details of terminal control. The C<Tputs>
method returns the string for the given capability:
d187 1
a187 2

	$terminal = Term::Cap->Tgetent( { OSPEED => 9600 } );
a189 21
	print $clear_screen;

On Windows, you can use the C<Win32::Console> module. After creating
an object for the output filehandle you want to affect, call the
C<Cls> method:

	Win32::Console;

	$OUT = Win32::Console->new(STD_OUTPUT_HANDLE);
	my $clear_string = $OUT->Cls;

	print $clear_screen;

If you have a command-line program that does the job, you can call
it in backticks to capture whatever it outputs so you can use it
later:

	$clear_string = `clear`;

	print $clear_string;

d349 4
a352 1
(contributed by brian d foy)
d354 1
a354 12
There's not a single way to run code in the background so you don't
have to wait for it to finish before your program moves on to other
tasks. Process management depends on your particular operating system,
and many of the techniques are in L<perlipc>.

Several CPAN modules may be able to help, including IPC::Open2 or
IPC::Open3, IPC::Run, Parallel::Jobs, Parallel::ForkManager, POE,
Proc::Background, and Win32::Process. There are many other modules you
might use, so check those namespaces for other options too.

If you are on a unix-like system, you might be able to get away with a
system call where you put an C<&> on the end of the command:
d358 3
a360 2
You can also try using C<fork>, as described in L<perlfunc> (although
this is the same thing that many of the modules will do for you).
d1184 2
a1185 26
(contributed by brian d foy)

Perl runs C<require> statement at run-time. Once Perl loads, compiles,
and runs the file, it doesn't do anything else. The C<use> statement
is the same as a C<require> run at compile-time, but Perl also calls the
C<import> method for the loaded package. These two are the same:

	use MODULE qw(import list);

	BEGIN {
		require MODULE;
		MODULE->import(import list);
		}

However, you can suppress the C<import> by using an explicit, empty
import list. Both of these still happen at compile-time:

	use MODULE ();

	BEGIN {
		require MODULE;
		}

Since C<use> will also call the C<import> method, the actual value
for C<MODULE> must be a bareword. That is, C<use> cannot load files
by name, although C<require> can:
d1187 15
a1201 1
	require "$ENV{HOME}/lib/Foo.pm"; # no @@INC searching!
d1203 1
a1203 1
See the entry for C<use> in L<perlfunc> for more details.
d1209 1
a1209 1
For C<Makefile.PL>-based distributions, use the INSTALL_BASE option
d1212 1
a1212 1
	perl Makefile.PL INSTALL_BASE=/mydir/perl
d1218 1
a1218 1
	cpan> o conf makepl_arg INSTALL_BASE=/mydir/perl
d1223 1
a1223 1
	perl Build.PL --install_base /mydir/perl
a1230 13
INSTALL_BASE tells these tools to put your modules into
F</mydir/perl/lib/perl5>.  See L<How do I add a directory to my
include path (@@INC) at runtime?> for details on how to run your newly
installed moudles.

There is one caveat with INSTALL_BASE, though, since it acts
differently than the PREFIX and LIB settings that older versions of
ExtUtils::MakeMaker advocated. INSTALL_BASE does not support
installing modules for multiple versions of Perl or different
architectures under the same directory. You should consider if you
really want that , and if you do, use the older PREFIX and LIB
settings. See the ExtUtils::Makemaker documentation for more details.

d1240 1
a1240 1

d1249 1
a1249 1

d1251 1
a1251 1

d1254 1
a1254 1
it into an absolute path. Once you have the
d1256 1
a1256 1
	BEGIN {
d1259 1
a1259 1

d1263 1
a1263 1

d1266 4
a1269 3
The C<FindBin> module, which comes with Perl, might work. It finds the
directory of the currently running script and puts it in C<$Bin>, which
you can then use to construct the right library path:
d1271 2
a1272 1
	use FindBin qw($Bin);
d1313 1
a1313 1
Revision: $Revision$
d1315 1
a1315 1
Date: $Date$
d1321 1
a1321 1
Copyright (c) 1997-2009 Tom Christiansen, Nathan Torkington, and
@


1.1.1.11
log
@Perl 5.12.2 from CPAN
@
text
@d18 3
a20 3
The C<$^O> variable (C<$OSNAME> if you use C<English>) contains an
indication of the name of the operating system (not its release
number) that your perl binary was built for.
d69 1
a69 1
color, you can use the C<Term::ANSIColor> module from CPAN:
d95 1
a95 1
The C<Term::ReadKey> module from CPAN offers an easy-to-use interface that
d106 1
a106 1
using the standard C<POSIX> module, which is already on your system
d112 1
a112 1
And here's the C<HotKey> module, which hides the somewhat mystifying calls
d160 1
a160 1
C<Term::ReadKey> module from CPAN, passing it an argument of -1 to indicate
d223 1
a223 1
If you have C<Term::ReadKey> module installed from CPAN,
d251 1
a251 1
You may do this with an old-style C<ioctl()> function, POSIX terminal
d255 1
a255 1
You can also do this for most systems using the C<Term::ReadKey> module
d284 2
a285 2
blocking by using C<sysopen()> and C<O_RDWR|O_NDELAY|O_NOCTTY> from the
C<Fcntl> module (part of the standard perl distribution).  See
d308 2
a309 2
If you expect characters to get to your device when you C<print()> them,
you'll want to autoflush that filehandle.  You can use C<select()>
d323 1
a323 1
of code just because you're afraid of a little C<$|> variable:
d334 1
a334 1
If you are doing a blocking C<read()> or C<sysread()>, you'll have to
d338 1
a338 1
C<select()> to determine whether I/O is ready on that device (see
d343 4
a346 5
While trying to read from his caller-id box, the notorious Jamie
Zawinski C<< <jwz@@netscape.com> >>, after much gnashing of teeth and
fighting with C<sysread>, C<sysopen>, POSIX's C<tcgetattr> business,
and various other functions that go bump in the night, finally came up
with this:
d387 4
a390 5
Several CPAN modules may be able to help, including C<IPC::Open2> or
C<IPC::Open3>, C<IPC::Run>, C<Parallel::Jobs>,
C<Parallel::ForkManager>, C<POE>, C<Proc::Background>, and
C<Win32::Process>. There are many other modules you might use, so
check those namespaces for other options too.
d392 1
a392 1
If you are on a Unix-like system, you might be able to get away with a
d427 2
a428 2
You can also use a double fork. You immediately C<wait()> for your
first child, and the init daemon will C<wait()> for your grandchild once
d453 2
a454 2
You can set the values of the C<%SIG> hash to be the functions you want
to handle the signal.  After perl catches the signal, it looks in C<%SIG>
d472 3
a474 3
in C<%SIG>.  This violated the rules of signal handling at that level
causing perl to dump core. Since version 5.8.0, perl looks at C<%SIG>
B<after> the signal has been caught, rather than while it is being caught.
d480 1
a480 1
properly, the C<getpw*()> functions described in L<perlfunc> should in
d484 1
a484 1
C<pwd_mkdb(8)> to install it (see L<pwd_mkdb> for more details).
d489 1
a489 1
able to set the system-wide date and time by running the C<date(1)>
d497 1
a497 1
	$ENV{TZ} = "MST7MDT";		   # Unixish
d524 3
a526 3
You can use the C<END> block to simulate C<atexit()>. Each package's
C<END> block is called when the program or thread ends See L<perlmod>
manpage for more details about C<END> blocks.
d528 2
a529 2
For example, you can use this to make sure your filter program managed
to finish its output without filling up the disk:
d535 2
a536 2
The C<END> block isn't called when untrapped signals kill the program,
though, so if you use C<END> blocks you should also use
d540 5
a544 5
Perl's exception-handling mechanism is its C<eval()> operator.  You
can use C<eval()> as C<setjmp> and C<die()> as C<longjmp>. For
details of this, see the section on signals, especially the time-out
handler for a blocking C<flock()> in L<perlipc/"Signals"> or the
section on "Signals" in I<Programming Perl>.
d546 2
a547 2
If exception handling is all you're interested in, use one of the 
many CPAN modules that handle exceptions, such as C<Try::Tiny>.
d549 2
a550 2
If you want the C<atexit()> syntax (and an C<rmexit()> as well), try the
C<AtExit> module available from CPAN.
d567 1
a567 1
C<syscall()>, you can use the C<syscall> function (documented in
d572 1
a572 1
Windows, try C<Win32::API>.  On Macs, try C<Mac::Carbon>.  If no module
d574 1
a574 1
Perl source with C<Inline::C>.
d578 2
a579 2
Historically, these would be generated by the C<h2ph> tool, part of the
standard perl distribution.  This program converts C<cpp(1)> directives
d581 1
a581 1
C<&SYS_getitimer>, which you can use as arguments to your functions.
d584 1
a584 1
but the hard ones like F<ioctl.h> nearly always need to be hand-edited.
d592 1
a592 1
sanity you probably ought to use C<h2xs> (also part of the standard perl
d594 1
a594 1
See L<perlxstut> for how to get started with C<h2xs>.
d597 1
a597 1
ought to use C<h2xs>.  See L<perlxstut> and L<ExtUtils::MakeMaker> for
d609 4
a612 4
The C<IPC::Open2> module (part of the standard perl distribution) is
an easy-to-use approach that internally uses C<pipe()>, C<fork()>, and
C<exec()> to do the job.  Make sure you read the deadlock warnings in
its documentation, though (see L<IPC::Open2>).  See
d616 1
a616 1
You may also use the C<IPC::Open3> module (part of the standard perl
d618 1
a618 1
arguments from C<IPC::Open2> (see L<IPC::Open3>).
d622 1
a622 1
You're confusing the purpose of C<system()> and backticks (``).  C<system()>
d639 3
a641 3
With C<system()>, both STDOUT and STDERR will go the same place as the
script's STDOUT and STDERR, unless the C<system()> command redirects them.
Backticks and C<open()> read B<only> the STDOUT of your command.
d643 1
a643 1
You can also use the C<open3()> function from C<IPC::Open3>.  Benjamin
d689 1
a689 1
But there's no real need for B<both> to be tempfiles... the following
d728 2
a729 2
This fails because the C<open()> makes STDERR go to where STDOUT was
going at the time of the C<open()>.  The backticks then make STDOUT go to
d733 2
a734 2
Note that you I<must> use Bourne shell (C<sh(1)>) redirection syntax in
backticks, not C<csh(1)>!  Details on why Perl's C<system()> and backtick
d781 2
a782 2
If the second argument to a piped C<open()> contains shell
metacharacters, perl C<fork()>s, then C<exec()>s a shell to decode the
d789 1
a789 1
C<IPC::Open3> module.
d791 1
a791 1
If there are no shell metacharacters in the argument of C<open()>, Perl
d866 4
a869 5
This happens only if your perl is compiled to use stdio instead of
perlio, which is the default. Some (maybe all?) stdios set error and
eof flags that you may need to clear. The C<POSIX> module defines
C<clearerr()> that you can use.  That is the technically correct way to
do it.  Here are some less reliable workarounds:
d908 4
a911 5
Try the C<Net::FTP>, C<TCP::Client>, and C<Net::Telnet> modules
(available from CPAN).
http://www.cpan.org/scripts/netstuff/telnet.emul.shar will also help
for emulating the telnet protocol, but C<Net::Telnet> is quite
probably easier to use.
d932 1
a932 1
Once upon a time, there was a library called L<chat2.pl> (part of the
d936 1
a936 1
other modules from CPAN, C<IO::Pty> and C<IO::Stty>.
d963 1
a963 1
fake it by C<eval()>ing the script's output in your shell; check out the
d986 1
a986 1
for details.  Or better yet, you can just use the C<POSIX::setsid()>
d1006 1
a1006 1
The C<Proc::Daemon> module, available from CPAN, provides a function to
d1011 2
a1012 1
(contributed by brian d foy)
d1014 3
a1016 2
This is a difficult question to answer, and the best answer is
only a guess.
d1018 2
a1019 3
What do you really want to know? If you merely want to know if one of
your filehandles is connected to a terminal, you can try the C<-t>
file test:
d1021 1
a1021 3
	if( -t STDOUT ) {
		print "I'm connected to a terminal!\n";
		}
d1023 11
a1033 24
However, you might be out of luck if you expect that means there is a
real person on the other side. With the C<Expect> module, another
program can pretend to be a person. The program might even come close
to passing the Turing test.

The C<IO::Interactive> module does the best it can to give you an
answer. Its C<is_interactive> function returns an output filehandle;
that filehandle points to standard output if the module thinks the
session is interactive. Otherwise, the filehandle is a null handle
that simply discards the output:

	use IO::Interactive;

	print { is_interactive } "I might go to standard output!\n";

This still doesn't guarantee that a real person is answering your
prompts or reading your output.

If you want to know how to handle automated testing for your
distribution, you can check the environment. The CPAN
Testers, for instance, set the value of C<AUTOMATED_TESTING>:

	unless( $ENV{AUTOMATED_TESTING} ) {
		print "Hello interactive tester!\n";
d1035 1
d1039 1
a1039 1
Use the C<alarm()> function, probably in conjunction with a signal
d1042 1
a1042 1
C<Sys::AlarmCall> module available from CPAN.
d1044 1
a1044 1
The C<alarm()> function is not implemented on all versions of Windows.
d1069 1
a1069 1
Use the reaper code from L<perlipc/"Signals"> to call C<wait()> when a
d1075 1
a1075 1
The C<DBI> module provides an abstract interface to most database
d1082 2
a1083 2
Other modules provide more specific access: C<Win32::ODBC>, C<Alzabo>,
C<iodbc>, and others found on CPAN Search: http://search.cpan.org .
d1087 1
a1087 1
You can't.  You need to imitate the C<system()> call (see L<perlipc> for
d1098 2
a1099 2
C<O_NDELAY> or C<O_NONBLOCK> flag from the C<Fcntl> module in conjunction with
C<sysopen()>:
d1124 1
a1124 1
bash).  That may look like perl forgot it has a C<print()> function,
d1145 1
a1145 1
The perl message comes out with "Perl" in front.  The C<BEGIN> block
d1161 1
a1161 1
all should be in the L<perldiag> manpage. If you don't find the error in
d1175 12
a1186 1
(contributed by brian d foy)
d1188 1
a1188 3
The easiest way is to have a module also named CPAN do it for you by using
the C<cpan> command the comes with Perl. You can give it a list of modules
to install:
d1190 1
a1190 1
	$ cpan IO::Interactive Getopt::Whatever
d1192 1
a1192 1
If you prefer C<CPANPLUS>, it's just as easy:
d1194 1
a1194 1
	$ cpanp i IO::Interactive Getopt::Whatever
d1196 1
a1196 2
If you want to install a distribution from the current directory, you can
tell C<CPAN.pm> to install C<.> (the full stop):
d1198 1
a1198 1
	$ cpan .
d1200 1
a1200 2
See the documentation for either of those commands to see what else
you can do.
d1202 1
a1202 3
If you want to try to install a distribution by yourself, resolving
all dependencies on your own, you follow one of two possible build
paths.
d1204 1
a1204 1
For distributions that use I<Makefile.PL>:
d1206 1
a1206 2
	$ perl Makefile.PL
	$ make test install
d1208 1
a1208 1
For distributions that use I<Build.PL>:
d1210 1
a1210 3
	$ perl Build.PL
	$ ./Build test
	$ ./Build install
d1212 7
a1218 3
Some distributions may need to link to libraries or other third-party
code and their build and installation sequences may be more complicated.
Check any I<README> or I<INSTALL> files that you may find.
d1255 1
a1255 9
When you build modules, tell Perl where to install the modules. 

If you want to install modules for your own use, the easiest way might
be C<local::lib>, which you can download from CPAN. It sets various
installation settings for you, and uses those same settings within
your programs.

If you want more flexibility, you need to configure your CPAN client
for your particular situation.
d1262 2
a1263 3
You can set this in your C<CPAN.pm> configuration so modules
automatically install in your private library directory when you use
the CPAN.pm shell:
d1273 1
a1273 1
You can configure C<CPAN.pm> to automatically use this option too:
d1276 1
a1276 1
	cpan> o conf mbuild_arg "--install_base /mydir/perl"
d1282 1
a1282 1
installed modules.
d1286 1
a1286 1
C<ExtUtils::MakeMaker> advocated. INSTALL_BASE does not support
d1290 1
a1290 1
settings. See the C<ExtUtils::Makemaker> documentation for more details.
a1331 8
	
You can also use C<local::lib> to do much of the same thing. Install
modules using C<local::lib>'s settings then use the module in your 
program:

	 use local::lib; # sets up a local lib at ~/perl5

See the C<local::lib> documentation for more details.
d1340 1
a1340 1
=item the C<PERLLIB> environment variable
d1345 1
a1345 1
=item the C<PERL5LIB> environment variable
d1350 1
a1350 1
=item the C<perl -Idir> command line flag
d1354 1
a1354 1
=item the C<lib> pragma:
a1357 6
=item the C<local::lib> module:

	use local::lib;
	
	use local::lib "~/myown_perllib";
	
d1361 1
a1361 1
dependent architectures.  The C<lib.pm> pragmatic module was first
d1367 1
a1367 1
constants.  Sometimes it is built using C<h2ph> when Perl is installed,
d1370 8
d1380 1
a1380 1
Copyright (c) 1997-2010 Tom Christiansen, Nathan Torkington, and
@


