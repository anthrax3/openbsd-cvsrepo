head	1.10;
access;
symbols
	OPENBSD_5_3:1.9.0.36
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.34
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.32
	OPENBSD_5_0:1.9.0.30
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.28
	OPENBSD_4_9_BASE:1.9
	PERL_5_12_2:1.1.1.7
	OPENBSD_4_8:1.9.0.26
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.22
	OPENBSD_4_7_BASE:1.9
	PERL_5_10_1:1.1.1.7
	OPENBSD_4_6:1.9.0.24
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.20
	OPENBSD_4_5_BASE:1.9
	PERL_5_10_0:1.1.1.7
	OPENBSD_4_4:1.9.0.18
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.16
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.14
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.12
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.10
	OPENBSD_4_0_BASE:1.9
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.9.0.8
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.6
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.4
	OPENBSD_3_7_BASE:1.9
	PERL_5_8_6:1.1.1.7
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.7.0.4
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.10
date	2013.03.25.20.40.59;	author sthen;	state dead;
branches;
next	1.9;

1.9
date	2004.08.09.18.10.17;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.12.03.03.02.47;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.10.27.22.25.34;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.24.10.23.53;	author dhartmei;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.36.02;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.07.46;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.23;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.59.39;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.06;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.06;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.41.07;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.34;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.24.55;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.08;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.28;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.48.30;	author millert;	state Exp;
branches;
next	;


desc
@@


1.10
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@#!/usr/local/bin/perl

use Config;
use File::Basename qw(&basename &dirname);
use Cwd;

# List explicitly here the variables you want Configure to
# generate.  Metaconfig only looks for shell variables, so you
# have to mention them as if they were shell variables, not
# %Config entries.  Thus you write
#  $startperl
# to ensure Configure will look for $Config{startperl}.

# This forces PL files to create target in same directory as PL file.
# This is so that make depend always knows where to find PL derivatives.
$origdir = cwd;
chdir dirname($0);
$file = basename($0, '.PL');
$file .= '.com' if $^O eq 'VMS';

open OUT,">$file" or die "Can't create $file: $!";

print "Extracting $file (with variable substitutions)\n";

# In this section, perl variables will be expanded during extraction.
# You can use $Config{...} to use Configure variables.

print OUT <<"!GROK!THIS!";
$Config{startperl}
    eval 'exec $Config{perlpath} -S \$0 \${1+"\$@@"}'
	if \$running_under_some_shell;
!GROK!THIS!

# In the following, perl variables are not expanded during extraction.

print OUT <<'!NO!SUBS!';

# pod2latex conversion program

use strict;
use Pod::LaTeX;
use Pod::Find qw/ pod_find /;
use Pod::Usage;
use Getopt::Long;
use File::Basename;
use Symbol;

my $VERSION = "1.01";

# return the entire contents of a text file
# whose name is given as argument
sub _get {
    my $fn = shift;
    my $infh = gensym;
    open $infh, $fn
        or die "Could not open file $fn: $!\n";
    local $/;
    return <$infh>;
}

# Read command line arguments

my %options = (
	       "help"   => 0,
	       "man"    => 0,
	       "sections" => [],
	       "full"   => 0,
	       "out"    => undef,
	       "verbose" => 0,
	       "modify" => 0,
	       "h1level" => 1,  # section is equivalent to H1
	       "preamble" => [],
	       "postamble" => [],
	      );
# "prefile" is just like "preamble", but the argument 
# comes from the file named by the argument
$options{"prefile"} = sub { shift; push @@{$options{"preamble"}}, _get(shift) };
# the same between "postfile" and "postamble"
$options{"postfile"} = sub { shift; push @@{$options{"postamble"}}, _get(shift) };

GetOptions(\%options, 
	   "help",
	   "man",
	   "verbose",
	   "full",
	   "sections=s@@",
	   "out=s",
	   "modify",
	   "h1level=i",
	   "preamble=s@@",
	   "postamble=s@@",
	   "prefile=s", 
	   "postfile=s"
	  ) || pod2usage(2);

pod2usage(1)  if ($options{help});
pod2usage(-verbose => 2)  if ($options{man});


# Read all the files from the command line
my @@files = @@ARGV;

# Now find which ones are real pods and convert 
# directories to their contents.

# Extract the pods from each arg since some of them might
# be directories
# This is not as efficient as using pod_find to search through
# everything at once but it allows us to preserve the order 
# supplied by the user

my @@pods;
foreach my $arg (@@files) {
  my %pods = pod_find($arg);
  push(@@pods, sort keys %pods);
}

# Abort if nothing to do
if ($#pods == -1) {
  warn "None of the supplied Pod files actually exist\n";
  exit;
}

# Only want to override the preamble and postamble if we have
# been given values.
my %User;
$User{UserPreamble} = join("\n", @@{$options{'preamble'}})
  if ($options{preamble} && @@{$options{preamble}});
$User{UserPostamble} = join("\n", @@{$options{'postamble'}})
  if ($options{postamble} && @@{$options{postamble}});



# If $options{'out'} is set we are processing to a single output file
my $multi_documents;
if (exists $options{'out'} && defined $options{'out'}) {
  $multi_documents = 0;
} else {
  $multi_documents = 1;
}

# If the output file is not specified it is assumed that
# a single output file is required per input file using
# a .tex extension rather than any exisiting extension

if ($multi_documents) {

  # Case where we just generate one input per output

  foreach my $pod (@@pods) {

    if (-f $pod) {

      my $output = $pod;
      $output = basename($output, '.pm', '.pod','.pl') . '.tex';

      # Create a new parser object
      my $parser = new Pod::LaTeX(
				  AddPreamble => $options{'full'},
				  AddPostamble => $options{'full'},
				  MakeIndex => $options{'full'},
				  TableOfContents => $options{'full'},
				  ReplaceNAMEwithSection => $options{'modify'},
				  UniqueLabels => $options{'modify'},
				  Head1Level => $options{'h1level'},
				  LevelNoNum => $options{'h1level'} + 1,
                                  %User,
				 );

      # Select sections if supplied
      $parser->select(@@{ $options{'sections'}})
	if @@{$options{'sections'}};

      # Derive the input file from the output file
      $parser->parse_from_file($pod, $output);

      print "Written output to $output\n" if $options{'verbose'};

    } else {
      warn "File $pod not found\n";
    }

  }
} else {

  # Case where we want everything to be in a single document

  # Need to open the output file ourselves
  my $output = $options{'out'};
  $output .= '.tex' unless $output =~ /\.tex$/;

  # Use auto-vivified file handle in perl 5.6
  my $outfh = gensym;
  open ($outfh, ">$output") || die "Could not open output file: $!\n";

  # Flag to indicate whether we have converted at least one file
  # indicates how many files have been converted
  my $converted = 0;

  # Loop over the input files
  foreach my $pod (@@pods) {

    if (-f $pod) {

      warn "Converting $pod\n" if $options{'verbose'};

      # Open the file (need the handle)
      # Use auto-vivified handle in perl 5.6
      my $podfh = gensym;
      open ($podfh, "<$pod") || die "Could not open pod file $pod: $!\n";

      # if this is the first file to be converted we may want to add
      # a preamble (controlled by command line option)
      my $preamble = 0;
      $preamble = 1 if ($converted == 0 && $options{'full'});

      # if this is the last file to be converted may want to add
      # a postamble (controlled by command line option)
      # relies on a previous pass to check existence of all pods we
      # are converting.
      my $postamble = ( ($converted == $#pods && $options{'full'}) ? 1 : 0 );

      # Open parser object
      # May want to start with a preamble for the first one and
      # end with an index for the last
      my $parser = new Pod::LaTeX(
				  MakeIndex => $options{'full'},
				  TableOfContents => $preamble,
				  ReplaceNAMEwithSection => $options{'modify'},
				  UniqueLabels => $options{'modify'},
				  StartWithNewPage => $options{'full'},
				  AddPreamble => $preamble,
				  AddPostamble => $postamble,
				  Head1Level => $options{'h1level'},
				  LevelNoNum => $options{'h1level'} + 1,
                                  %User
				 );

      # Store the file name for error messages
      # This is a kluge that breaks the data hiding of the object
      $parser->{_INFILE} = $pod;

      # Select sections if supplied
      $parser->select(@@{ $options{'sections'}})
	if @@{$options{'sections'}};

      # Parse it
      $parser->parse_from_filehandle($podfh, $outfh);

      # We have converted at least one file
      $converted++;

    } else {
      warn "File $pod not found\n";
    }

  }

  # Should unlink the file if we didn't convert anything!
  # dont check for return status of unlink
  # since there is not a lot to be done if the unlink failed
  # and the program does not rely upon it.
  unlink "$output" unless $converted;

  # If verbose
  warn "Converted $converted files\n" if $options{'verbose'};

}

exit;

__END__

=head1 NAME

pod2latex - convert pod documentation to latex format

=head1 SYNOPSIS

  pod2latex *.pm

  pod2latex -out mytex.tex *.pod

  pod2latex -full -sections 'DESCRIPTION|NAME' SomeDir

  pod2latex -prefile h.tex -postfile t.tex my.pod

=head1 DESCRIPTION

C<pod2latex> is a program to convert POD format documentation
(L<perlpod>) into latex. It can process multiple input documents at a
time and either generate a latex file per input document or a single
combined output file.

=head1 OPTIONS AND ARGUMENTS

This section describes the supported command line options. Minimum
matching is supported.

=over 4

=item B<-out>

Name of the output file to be used. If there are multiple input pods
it is assumed that the intention is to write all translated output
into a single file. C<.tex> is appended if not present.  If the
argument is not supplied, a single document will be created for each
input file.

=item B<-full>

Creates a complete C<latex> file that can be processed immediately
(unless C<=for/=begin> directives are used that rely on extra packages).
Table of contents and index generation commands are included in the
wrapper C<latex> code.

=item B<-sections>

Specify pod sections to include (or remove if negated) in the
translation.  See L<Pod::Select/"SECTION SPECIFICATIONS"> for the
format to use for I<section-spec>. This option may be given multiple
times on the command line.This is identical to the similar option in
the C<podselect()> command.

=item B<-modify>

This option causes the output C<latex> to be slightly
modified from the input pod such that when a C<=head1 NAME>
is encountered a section is created containing the actual
pod name (rather than B<NAME>) and all subsequent C<=head1>
directives are treated as subsections. This has the advantage
that the description of a module will be in its own section
which is helpful for including module descriptions in documentation.
Also forces C<latex> label and index entries to be prefixed by the
name of the module.

=item B<-h1level>

Specifies the C<latex> section that is equivalent to a C<H1> pod
directive. This is an integer between 0 and 5 with 0 equivalent to a
C<latex> chapter, 1 equivalent to a C<latex> section etc. The default
is 1 (C<H1> equivalent to a latex section).

=item B<-help>

Print a brief help message and exit.

=item B<-man>

Print the manual page and exit.

=item B<-verbose>

Print information messages as each document is processed.

=item B<-preamble>

A user-supplied preamble for the LaTeX code. Multiple values
are supported and appended in order separated by "\n".
See B<-prefile> for reading the preamble from a file.

=item B<-postamble>

A user supplied postamble for the LaTeX code. Multiple values
are supported and appended in order separated by "\n".
See B<-postfile> for reading the postamble from a file.

=item B<-prefile>

A user-supplied preamble for the LaTeX code to be read from the
named file. Multiple values are supported and appended in
order. See B<-preamble>.

=item B<-postfile>

A user-supplied postamble for the LaTeX code to be read from the
named file. Multiple values are supported and appended in
order. See B<-postamble>.

=back

=head1 BUGS

Known bugs are:

=over 4

=item *

Cross references between documents are not resolved when multiple
pod documents are converted into a single output C<latex> file.

=item *

Functions and variables are not automatically recognized
and they will therefore not be marked up in any special way
unless instructed by an explicit pod command.

=back

=head1 SEE ALSO

L<Pod::LaTeX>

=head1 AUTHOR

Tim Jenness E<lt>tjenness@@cpan.orgE<gt>

This program is free software; you can redistribute it
and/or modify it under the same terms as Perl itself.

Copyright (C) 2000, 2003, 2004 Tim Jenness. All Rights Reserved.

=cut

!NO!SUBS!

close OUT or die "Can't close $file: $!";
chmod 0755, $file or die "Can't reset permissions for $file: $!\n";
exec("$Config{'eunicefix'} $file") if $Config{'eunicefix'} ne ':';
chdir $origdir;
@


1.9
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@@


1.8
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d46 1
d48 12
a59 1
my $VERSION = "1.00";
d72 2
d75 5
d90 4
d124 8
d167 1
d185 1
a185 1
  
a192 1
  use Symbol;
d236 1
d286 2
d356 24
d388 1
a388 1
=item * 
d393 1
a393 1
=item * 
d395 1
a395 1
Functions and variables are not automatically recognized 
d407 1
a407 1
Tim Jenness E<lt>t.jenness@@jach.hawaii.eduE<gt>
d412 1
a412 1
Copyright (C) 2000, 2003 Tim Jenness. All Rights Reserved.
@


1.7
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d354 1
a354 1
Copyright (C) 2000 Tim Jenness.
@


1.6
log
@"minium" -> "minimum", ok deraadt@@
@
text
@d40 1
d47 2
d59 1
d70 1
d134 2
d183 2
a184 5
      if ($converted == 0 && $options{'full'}) {
	$preamble = 1;
      } else {
	$preamble = 0;
      }
d203 2
d302 7
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d257 1
a257 1
This section describes the supported command line options. Minium
@


1.4
log
@perl-5.6.0 + local changes
@
text
@a36 110
#
# pod2latex, version 1.1
# by Taro Kawagish (kawagish@@imslab.co.jp),  Jan 11, 1995.
#
# pod2latex filters Perl pod documents to LaTeX documents.
#
# What pod2latex does:
# 1. Pod file 'perl_doc_entry.pod' is filtered to 'perl_doc_entry.tex'.
# 2. Indented paragraphs are translated into
#    '\begin{verbatim} ... \end{verbatim}'.
# 3. '=head1 heading' command is translated into '\section{heading}'
# 4. '=head2 heading' command is translated into '\subsection*{heading}'
# 5. '=over N' command is translated into
#        '\begin{itemize}'	if following =item starts with *,
#        '\begin{enumerate}'	if following =item starts with 1.,
#        '\begin{description}'	if else.
#      (indentation level N is ignored.)
# 6. '=item * heading' command is translated into '\item heading',
#    '=item 1. heading' command is translated into '\item heading',
#    '=item heading' command(other) is translated into '\item[heading]'.
# 7. '=back' command is translated into
#        '\end{itemize}'	if started with '\begin{itemize}',
#        '\end{enumerate}'	if started with '\begin{enumerate}',
#        '\end{description}'	if started with '\begin{description}'.
# 8. other paragraphs are translated into strings with TeX special characters
#    escaped.
# 9. In heading text, and other paragraphs, the following translation of pod
#    quotes are done, and then TeX special characters are escaped after that.
#      I<text> to {\em text\/},
#      B<text> to {\bf text},
#      S<text> to text1,
#        where text1 is a string with blank characters replaced with ~,
#      C<text> to {\tt text2},
#        where text2 is a string with TeX special characters escaped to
#        obtain a literal printout,
#      E<text> (HTML escape) to TeX escaped string,
#      L<text> to referencing string as is done by pod2man,
#      F<file> to {\em file\/},
#      Z<> to a null string,
# 10. those headings are indexed:
#       '=head1 heading'   =>  \section{heading}\index{heading}
#       '=head2 heading'   =>  \subsection*{heading}\index{heading}
#                 only when heading does not match frequent patterns such as
#                 DESCRIPTION, DIAGNOSTICS,...
#       '=item heading'   =>  \item{heading}\index{heading}
#
# Usage:
#     pod2latex perl_doc_entry.pod
# this will write to a file 'perl_doc_entry.tex'.
#
# To LaTeX:
# The following commands need to be defined in the preamble of the LaTeX
# document:
# \def\C++{{\rm C\kern-.05em\raise.3ex\hbox{\footnotesize ++}}}
# \def\underscore{\leavevmode\kern.04em\vbox{\hrule width 0.4em height 0.3pt}}
# and \parindent should be set zero:
# \setlength{\parindent}{0pt}
#
# Note:
# This script was written modifing pod2man.
#
# Bug:
# If HTML escapes E<text> other than E<amp>,E<lt>,E<gt>,E<quot> are used
# in C<>, translation will produce wrong character strings.
# Translation of HTML escapes of various European accents might be wrong.


# TeX special characters.
##$tt_ables = "!@@*()-=+|;:'\"`,./?<>";
$backslash_escapables = "#\$%&{}_";
$backslash_escapables2 = "#\$%&{}";	# except _
##$nonverbables = "^\\~";
##$bracketesc = "[]";
##@@tex_verb_fences = unpack("aaaaaaaaa","|#@@!*+?:;");

@@head1_freq_patterns		# =head1 patterns which need not be index'ed
    = ("AUTHOR","Author","BUGS","DATE","DESCRIPTION","DIAGNOSTICS",
       "ENVIRONMENT","EXAMPLES","FILES","INTRODUCTION","NAME","NOTE",
       "SEE ALSO","SYNOPSIS","WARNING");

$indent = 0;

# parse the pods, produce LaTeX.

use Pod::Plainer;
open(POD,"-|") or Pod::Plainer -> new() -> parse_from_file($ARGV[0]), exit;

($pod=$ARGV[0]) =~ s/\.pod$//;
open(LATEX,">$pod.tex");
&do_hdr();

$cutting = 1;
$begun = "";
$/ = "";			# record separator is blank lines
while (<POD>) {
    if ($cutting) {
	next unless /^=/;
	$cutting = 0;
    }
    if ($begun) {
       if (/^=end\s+$begun/) {
           $begun = "";
       }
       elsif ($begun =~ /^(tex|latex)$/) {
           print LATEX $_;
       }
       next;
    }
    chop;
    length || (print LATEX  "\n") && next;
d38 1
a38 13
    # translate indented lines as a verabatim paragraph
    if (/^\s/) {
	@@lines = split(/\n/);
	print LATEX  "\\begin{verbatim}\n";
	for (@@lines) {
	    1 while s
		{^( [^\t]* ) \t ( \t* ) }
		{ $1 . ' ' x (8 - (length($1)%8) + 8*(length($2))) }ex;
	    print LATEX  $_,"\n";
	}
	print LATEX  "\\end{verbatim}\n";
	next;
    }
d40 5
a44 15
    if (/^=for\s+(\S+)\s*/s) {
	if ($1 eq "tex" or $1 eq "latex") {
	    print LATEX $',"\n";
	} else {
	    # ignore unknown for
	}
	next;
    }
    elsif (/^=begin\s+(\S+)\s*/s) {
	$begun = $1;
	if ($1 eq "tex" or $1 eq "latex") {
	    print LATEX $'."\n";
	}
	next;
    }
d46 1
a46 4
    # preserve '=item' line with pod quotes as they are.
    if (/^=item/) {
	($bareitem = $_) =~ s/^=item\s*//;
    }
d48 9
a56 2
    # check for things that'll hosed our noremap scheme; affects $_
    &init_noremap();
d58 9
a66 22
    # expand strings "func()" as pod quotes.
    if (!/^=item/) {
	# first hide pod escapes.
	# escaped strings are mapped into the ones with the MSB's on.
	s/([A-Z]<[^<>]*>)/noremap($1)/ge;

	# func() is a reference to a perl function
	s{\b([:\w]+\(\))}{I<$1>}g;
	# func(n) is a reference to a man page
	s{(\w+)(\([^\s,\051]+\))}{I<$1>$2}g;
	# convert simple variable references
#	s/([\$\@@%][\w:]+)/C<$1>/g;
#	s/\$[\w:]+\[[0-9]+\]/C<$&>/g;

	if (m{ ([\-\w]+\([^\051]*?[\@@\$,][^\051]*?\))
	       }x && $` !~ /([LCI]<[^<>]*|-)$/ && !/^=\w/)
	{
	    warn "``$1'' should be a [LCI]<$1> ref";
	}
	while (/(-[a-zA-Z])\b/g && $` !~ /[\w\-]$/) {
	    warn "``$1'' should be [CB]<$1> ref";
	}
d68 2
a69 3
	# put back pod quotes so we get the inside of <> processed;
	$_ = &clear_noremap($_);
    }
d72 2
a73 1
    # process TeX special characters
d75 2
a76 2
    # First hide HTML quotes E<> since they can be included in C<>.
    s/(E<[^<>]+>)/noremap($1)/ge;
d78 5
a82 134
    # Then hide C<> type literal quotes.
    # String inside of C<> will later be expanded into {\tt ..} strings
    # with TeX special characters escaped as needed.
    s/(C<[^<>]*>)/&noremap($1)/ge;

    # Next escape TeX special characters including other pod quotes B< >,...
    #
    # NOTE: s/re/&func($str)/e evaluates $str just once in perl5.
    # (in perl4 evaluation takes place twice before getting passed to func().)

    # - hyphen => ---
    s/(\S+)(\s+)-+(\s+)(\S+)/"$1".&noremap(" --- ")."$4"/ge;
    # '-', '--', "-"  =>  '{\tt -}', '{\tt --}', "{\tt -}"
##    s/("|')(\s*)(-+)(\s*)\1/&noremap("$1$2\{\\tt $3\}$4$1")/ge;
## changed Wed Jan 25 15:26:39 JST 1995
    # '-', '--', "-"  =>  '$-$', '$--$', "$-$"
    s/(\s+)(['"])(-+)([^'"\-]*)\2(\s+|[,.])/"$1$2".&noremap("\$$3\$")."$4$2$5"/ge;
    s/(\s+)(['"])([^'"\-]*)(-+)(\s*)\2(\s+|[,.])/"$1$2$3".&noremap("\$$4\$")."$5$2$6"/ge;
    # (--|-)  =>  ($--$|$-$)
    s/(\s+)\((-+)([=@@%\$\+\\\|\w]*)(-*)([=@@%\$\+\\\|\w]*)\)(\s+|[,.])/"$1\(".&noremap("\$$2\$")."$3".&noremap("\$$4\$")."$5\)$6"/ge;
    # numeral -  =>  $-$
    s/(\(|[0-9]+|\s+)-(\s*\(?\s*[0-9]+)/&noremap("$1\$-\$$2")/ge;
    # -- in quotes  =>  two separate -
    s/B<([^<>]*)--([^<>]*)>/&noremap("B<$1\{\\tt --\}$2>")/ge;

    # backslash escapable characters except _.
    s/([$backslash_escapables2])/&noremap("\\$1")/ge;
    s/_/&noremap("\\underscore{}")/ge;		# a litle thicker than \_.
    # quote TeX special characters |, ^, ~, \.
    s/\|/&noremap("\$|\$")/ge;
    s/\^/&noremap("\$\\hat{\\hspace{0.4em}}\$")/ge;
    s/\~/&noremap("\$\\tilde{\\hspace{0.4em}}\$")/ge;
    s/\\/&noremap("\$\\backslash{}\$")/ge;
    # quote [ and ] to be used in \item[]
    s/([\[\]])/&noremap("{\\tt $1}")/ge;
    # characters need to be treated differently in TeX
    # keep * if an item heading
    s/^(=item[ \t]+)[*]((.|\n)*)/"$1" . &noremap("*") . "$2"/ge;
    s/[*]/&noremap("\$\\ast\$")/ge;	# other *

    # hide other pod quotes.
    s/([ABD-Z]<[^<>]*>)/&noremap($1)/ge;

    # escape < and > as math strings,
    # now that we are done with hiding pod <> quotes.
    s/</&noremap("\$<\$")/ge;
    s/>/&noremap("\$>\$")/ge;

    # put it back so we get the <> processed again;
    $_ = &clear_noremap($_);


    # Expand pod quotes recursively:
    # (1) type face directives [BIFS]<[^<>]*> to appropriate TeX commands,
    # (2) L<[^<>]*> to reference strings,
    # (3) C<[^<>]*> to TeX literal quotes,
    # (4) HTML quotes E<> inside of C<> quotes.

    # Hide E<> again since they can be included in C<>.
    s/(E<[^<>]+>)/noremap($1)/ge;

    $maxnest = 10;
    while ($maxnest-- && /[A-Z]</) {

	# bold and italic quotes
	s/B<([^<>]*)>/"{\\bf $1}"/eg;
	s#I<([^<>]*)>#"{\\em $1\\/}"#eg;

	# files and filelike refs in italics
	s#F<([^<>]*)>#"{\\em $1\\/}"#eg;

	# no break quote -- usually we want C<> for this
	s/S<([^<>]*)>/&nobreak($1)/eg;

	# LREF: a manpage(3f)
	s:L<([a-zA-Z][^\s\/]+)(\([^\)]+\))?>:the {\\em $1\\/}$2 manpage:g;

	# LREF: an =item on another manpage
	s{
	    L<([^/]+)/([:\w]+(\(\))?)>
	} {the C<$2> entry in the I<$1> manpage}gx;

	# LREF: an =item on this manpage
	s{
	   ((?:L</([:\w]+(\(\))?)>
	    (,?\s+(and\s+)?)?)+)
	} { &internal_lrefs($1) }gex;

	# LREF: a =head2 (head1?), maybe on a manpage, maybe right here
	# the "func" can disambiguate
	s{
	    L<(?:([a-zA-Z]\S+?) /)?"?(.*?)"?>
	}{
	    do {
		$1 	# if no $1, assume it means on this page.
		    ?  "the section on I<$2> in the I<$1> manpage"
		    :  "the section on I<$2>"
	    } 
	}gex;

	s/X<([^<>]*)>/\\index{$1}/g;

	s/Z<>/\\&/g;		# the "don't format me" thing

	# comes last because not subject to reprocessing
	s{
	    C<([^<>]*)>
	}{
	    do {
		($str = $1) =~ tr/\200-\377/\000-\177/; #normalize hidden stuff
		# expand HTML escapes if any;
		# WARNING: if HTML escapes other than E<amp>,E<lt>,E<gt>,
		# E<quot> are in C<>, they will not be printed correctly.
		$str = &expand_HTML_escapes($str);
		$strverb = &alltt($str);    # Tex verbatim escape of a string.
		&noremap("$strverb");
	    }
	}gex;

#	if ( /C<([^<>]*)/ ) {
#	    $str = $1;
#	    if ($str !~ /\|/) {		# if includes |
#		s/C<([^<>]*)>/&noremap("\\verb|$str|")/eg;
#	    } else {
#		print STDERR "found \| in C<.*> at paragraph $.\n";
#		# find a character not contained in $str to use it as a
#		# separator of the \verb
#		($chars = $str) =~ s/(\W)/\\$1/g;
#		## ($chars = $str) =~ s/([\$<>,\|"'\-^{}()*+?\\])/\\$1/g;
#		@@fence = grep(!/[ $chars]/,@@tex_verb_fences);
#		s/C<([^<>]*)>/&noremap("\\verb$fence[0]$str$fence[0]")/eg;
#	    }
#	}
    }
d84 5
d90 4
a93 150
    # process each pod command
    if (s/^=//) {				# if a command
	s/\n/ /g;
	($cmd, $rest) = split(' ', $_, 2);
	$rest =~ s/^\s*//;
	$rest =~ s/\s*$//;

	if (defined $rest) {
	    &escapes;
	}

	$rest = &clear_noremap($rest);
	$rest = &expand_HTML_escapes($rest);

	if ($cmd eq 'cut') {
	    $cutting = 1;
	    $lastcmd = 'cut';
	}
	elsif ($cmd eq 'head1') {	# heading type 1
	    $rest =~ s/^\s*//; $rest =~ s/\s*$//;
	    print LATEX  "\n\\subsection*{$rest}";
	    # put index entry
	    ($index = $rest) =~ s/^(An?\s+|The\s+)//i;	# remove 'A' and 'The'
	    # index only those heads not matching the frequent patterns.
	    foreach $pat (@@head1_freq_patterns) {
		if ($index =~ /^$pat/) {
		    goto freqpatt;
		}
	    }
	    print LATEX  "%\n\\index{$index}\n" if ($index);
	  freqpatt:
	    $lastcmd = 'head1';
	}
	elsif ($cmd eq 'head2') {	# heading type 2
	    $rest =~ s/^\s*//; $rest =~ s/\s*$//;
	    print LATEX  "\n\\subsubsection*{$rest}";
	    # put index entry
	    ($index = $rest) =~ s/^(An?\s+|The\s+)//i;	# remove 'A' and 'The'
	    $index =~ s/^Example\s*[1-9][0-9]*\s*:\s*//; # remove 'Example :'
	    print LATEX  "%\n\\index{$index}\n"  if ($index);
	    $lastcmd = 'head2';
	}
	elsif ($cmd eq 'over') {	# 1 level within a listing environment
	    push(@@indent,$indent);
	    $indent = $rest + 0;
	    $lastcmd = 'over';
	}
	elsif ($cmd eq 'back') {	# 1 level out of a listing environment
	    $indent = pop(@@indent);
	    warn "Unmatched =back\n" unless defined $indent;
	    $listingcmd = pop(@@listingcmd);
	    print LATEX  "\n\\end{$listingcmd}\n"  if ($listingcmd);
	    $lastcmd = 'back';
	}
	elsif ($cmd eq 'item') {	# an item paragraph starts
	    if ($lastcmd eq 'over') {	# if we have just entered listing env
		# see what type of list environment we are in.
		if ($rest =~ /^[0-9]\.?/) {	# if numeral heading
		    $listingcmd = 'enumerate';
		} elsif ($rest =~ /^\*\s*/) {	# if * heading
		    $listingcmd = 'itemize';
		} elsif ($rest =~ /^[^*]/) {	# if other headings
		    $listingcmd = 'description';
		} else {
		    warn "unknown list type for item $rest";
		}
		print LATEX  "\n\\begin{$listingcmd}\n";
		push(@@listingcmd,$listingcmd);
	    } elsif ( !@@listingcmd ) { 
		warn "Illegal '=item' command without preceding 'over':";
		warn "=item $bareitem";
	    }

	    if ($listingcmd eq 'enumerate') {
		$rest =~ s/^[0-9]+\.?\s*//;	# remove numeral heading
		print LATEX  "\n\\item";
		print LATEX  "{\\bf $rest}" if $rest;
	    } elsif ($listingcmd eq 'itemize') {
		$rest =~ s/^\*\s*//;		# remove * heading
		print LATEX  "\n\\item";
		print LATEX  "{\\bf $rest}" if $rest;
	    } else {				# description item
		print LATEX  "\n\\item[$rest]";
	    }
	    $lastcmd = 'item';
	    $rightafter_item = 'yes';

	    # check if the item heading is short or long.
	    ($itemhead = $rest) =~ s/{\\bf (\S*)}/$1/g;
	    if (length($itemhead) < 4) {
		$itemshort = "yes";
	    } else {
		$itemshort = "no";
	    }
	    # write index entry
	    if ($pod =~ "perldiag") {			# skip 'perldiag.pod'
		goto noindex;
	    }
	    # strip out the item of pod quotes and get a plain text entry
	    $bareitem =~ s/\n/ /g;			# remove newlines
	    $bareitem =~ s/\s*$//;			# remove trailing space
	    $bareitem =~ s/[A-Z]<([^<>]*)>/$1/g;	# remove <> quotes
	    ($index = $bareitem) =~ s/^\*\s+//;		# remove leading '*'
	    $index =~ s/^(An?\s+|The\s+)//i;		# remove 'A' and 'The'
	    $index =~ s/^\s*[1-9][0-9]*\s*[.]\s*$//; # remove numeral only
	    $index =~ s/^\s*\w\s*$//;			# remove 1 char only's
		# quote ", @@ and ! with " to be used in makeindex.
	    $index =~ s/"/""/g;				# quote "
	    $index =~ s/@@/"@@/g;				# quote @@
	    $index =~ s/!/"!/g;				# quote !
	    ($rest2=$rest) =~ s/^\*\s+//;	# remove *
	    $rest2 =~ s/"/""/g;				# quote "
	    $rest2 =~ s/@@/"@@/g;				# quote @@
	    $rest2 =~ s/!/"!/g;				# quote !
	    if ($pod =~ "(perlfunc|perlvar)") {	# when doc is perlfunc,perlvar
		# take only the 1st word of item heading
		$index =~ s/^([^{}\s]*)({.*})?([^{}\s]*)\s+.*/\1\2\3/;
		$rest2 =~ s/^([^{}\s]*)({.*})?([^{}\s]*)\s+.*/\1\2\3/;
	    }
	    if ($index =~ /[A-Za-z\$@@%]/) {
		    #  write  \index{plain_text_entry@@TeX_string_entry}
		print LATEX  "%\n\\index{$index\@@$rest2}%\n";
	    }
	  noindex:
	    ;
	}
	elsif ($cmd eq 'pod') {
	    ;	# recognise the pod directive, as no op (hs)
	}
 	elsif ($cmd eq 'pod') {
 	    ;    # recognise the pod directive, as no op (hs)
 	}
	else {
	    warn "Unrecognized directive: $cmd\n";
	}
    }
    else {					# if not command
	&escapes;
	$_ = &clear_noremap($_);
	$_ = &expand_HTML_escapes($_);

	# if the present paragraphs follows an =item declaration,
	# put a line break.
	if ($lastcmd eq 'item' &&
	    $rightafter_item eq 'yes' && $itemshort eq "no") {
	    print LATEX  "\\hfil\\\\";
	    $rightafter_item = 'no';
	}
	print LATEX  "\n",$_;
    }
d96 8
a103 18
print LATEX  "\n";
close(POD);
close(LATEX);


#########################################################################

sub do_hdr {
    print LATEX "% LaTeX document produced by pod2latex from \"$pod.pod\".\n";
    print LATEX "% The followings need be defined in the preamble of this document:\n";
    print LATEX "%\\def\\C++{{\\rm C\\kern-.05em\\raise.3ex\\hbox{\\footnotesize ++}}}\n";
    print LATEX "%\\def\\underscore{\\leavevmode\\kern.04em\\vbox{\\hrule width 0.4em height 0.3pt}}\n";
    print LATEX "%\\setlength{\\parindent}{0pt}\n";
    print LATEX "\n";
    $podq = &escape_tex_specials("\U$pod\E");
    print LATEX "\\section{$podq}%\n";
    print LATEX "\\index{$podq}";
    print LATEX "\n";
d106 62
a167 5
sub nobreak {
    my $string = shift;
    $string =~ s/ +/~/g;		# TeX no line break
    $string;
}
d169 4
a172 5
sub noremap {
    local($thing_to_hide) = shift;
    $thing_to_hide =~ tr/\000-\177/\200-\377/;
    return $thing_to_hide;
}
d174 7
a180 4
sub init_noremap {
	# escape high bit characters in input stream
	s/([\200-\377])/"E<".ord($1).">"/ge;
}
d182 5
a186 5
sub clear_noremap {
    local($tmp) = shift;
    $tmp =~ tr/\200-\377/\000-\177/;
    return $tmp;
}
d188 12
a199 18
sub expand_HTML_escapes {
    local($s) = $_[0];
    $s =~ s { E<((\d+)|([A-Za-z]+))> }
    {
	do {
		defined($2) 
		? do { chr($2) }
		: 
	    exists $HTML_Escapes{$3}
	    ? do { $HTML_Escapes{$3} }
	    : do {
		warn "Unknown escape: $& in $_";
		"E<$1>";
	    }
	}
    }egx;
    return $s;
}
d201 3
a203 5
sub escapes {
    # make C++ into \C++, which is to be defined as
    # \def\C++{{\rm C\kern-.05em\raise.3ex\hbox{\footnotesize ++}}}
    s/\bC\+\+/\\C++{}/g;
}
d205 3
a207 20
# Translate a string into a TeX \tt string to obtain a verbatim print out.
# TeX special characters are escaped by \.
# This can be used inside of LaTeX command arguments.
# We don't use LaTeX \verb since it doesn't work inside of command arguments.
sub alltt {
    local($str) = shift;
	# other chars than #,\,$,%,&,{,},_,\,^,~ ([ and ] included).
    $str =~ s/([^${backslash_escapables}\\\^\~]+)/&noremap("$&")/eg;
	# chars #,\,$,%,&,{,}  =>  \# , ...
    $str =~ s/([$backslash_escapables2])/&noremap("\\$&")/eg;
	# chars _,\,^,~  =>  \char`\_ , ...
    $str =~ s/_/&noremap("\\char`\\_")/eg;
    $str =~ s/\\/&noremap("\\char`\\\\")/ge;
    $str =~ s/\^/\\char`\\^/g;
    $str =~ s/\~/\\char`\\~/g;

    $str =~ tr/\200-\377/\000-\177/;		# put back
    $str = "{\\tt ".$str."}";			# make it a \tt string
    return $str;
}
d209 2
a210 20
sub escape_tex_specials {
    local($str) = shift;
	# other chars than #,\,$,%,&,{,},  _,\,^,~ ([ and ] included).
    # backslash escapable characters #,\,$,%,&,{,} except _.
    $str =~ s/([$backslash_escapables2])/&noremap("\\$1")/ge;
    $str =~ s/_/&noremap("\\underscore{}")/ge;	# \_ is too thin.
    # quote TeX special characters |, ^, ~, \.
    $str =~ s/\|/&noremap("\$|\$")/ge;
    $str =~ s/\^/&noremap("\$\\hat{\\hspace{0.4em}}\$")/ge;
    $str =~ s/\~/&noremap("\$\\tilde{\\hspace{0.4em}}\$")/ge;
    $str =~ s/\\/&noremap("\$\\backslash{}\$")/ge;
    # characters need to be treated differently in TeX
    # *
    $str =~ s/[*]/&noremap("\$\\ast\$")/ge;
    # escape < and > as math string,
    $str =~ s/</&noremap("\$<\$")/ge;
    $str =~ s/>/&noremap("\$>\$")/ge;
    $str =~ tr/\200-\377/\000-\177/;		# put back
    return $str;
}
d212 2
a213 2
sub internal_lrefs {
    local($_) = shift;
d215 2
a216 8
    s{L</([^>]+)>}{$1}g;
    my(@@items) = split( /(?:,?\s+(?:and\s+)?)/ );
    my $retstr = "the ";
    my $i;
    for ($i = 0; $i <= $#items; $i++) {
	$retstr .= "C<$items[$i]>";
	$retstr .= ", " if @@items > 2 && $i != $#items;
	$retstr .= " and " if $i+2 == @@items;
a217 2
    $retstr .= " entr" . ( @@items > 1  ? "ies" : "y" )
	    .  " elsewhere in this document";
d219 11
a229 1
    return $retstr;
d232 113
a344 72
# map of HTML escapes to TeX escapes.
BEGIN {
%HTML_Escapes = (
    'amp'	=>	'&',	#   ampersand
    'lt'	=>	'<',	#   left chevron, less-than
    'gt'	=>	'>',	#   right chevron, greater-than
    'quot'	=>	'"',	#   double quote

    "Aacute"	=>	"\\'{A}",	#   capital A, acute accent
    "aacute"	=>	"\\'{a}",	#   small a, acute accent
    "Acirc"	=>	"\\^{A}",	#   capital A, circumflex accent
    "acirc"	=>	"\\^{a}",	#   small a, circumflex accent
    "AElig"	=>	'\\AE',		#   capital AE diphthong (ligature)
    "aelig"	=>	'\\ae',		#   small ae diphthong (ligature)
    "Agrave"	=>	"\\`{A}",	#   capital A, grave accent
    "agrave"	=>	"\\`{a}",	#   small a, grave accent
    "Aring"	=>	'\\u{A}',	#   capital A, ring
    "aring"	=>	'\\u{a}',	#   small a, ring
    "Atilde"	=>	'\\~{A}',	#   capital A, tilde
    "atilde"	=>	'\\~{a}',	#   small a, tilde
    "Auml"	=>	'\\"{A}',	#   capital A, dieresis or umlaut mark
    "auml"	=>	'\\"{a}',	#   small a, dieresis or umlaut mark
    "Ccedil"	=>	'\\c{C}',	#   capital C, cedilla
    "ccedil"	=>	'\\c{c}',	#   small c, cedilla
    "Eacute"	=>	"\\'{E}",	#   capital E, acute accent
    "eacute"	=>	"\\'{e}",	#   small e, acute accent
    "Ecirc"	=>	"\\^{E}",	#   capital E, circumflex accent
    "ecirc"	=>	"\\^{e}",	#   small e, circumflex accent
    "Egrave"	=>	"\\`{E}",	#   capital E, grave accent
    "egrave"	=>	"\\`{e}",	#   small e, grave accent
    "ETH"	=>	'\\OE',		#   capital Eth, Icelandic
    "eth"	=>	'\\oe',		#   small eth, Icelandic
    "Euml"	=>	'\\"{E}',	#   capital E, dieresis or umlaut mark
    "euml"	=>	'\\"{e}',	#   small e, dieresis or umlaut mark
    "Iacute"	=>	"\\'{I}",	#   capital I, acute accent
    "iacute"	=>	"\\'{i}",	#   small i, acute accent
    "Icirc"	=>	"\\^{I}",	#   capital I, circumflex accent
    "icirc"	=>	"\\^{i}",	#   small i, circumflex accent
    "Igrave"	=>	"\\`{I}",	#   capital I, grave accent
    "igrave"	=>	"\\`{i}",	#   small i, grave accent
    "Iuml"	=>	'\\"{I}',	#   capital I, dieresis or umlaut mark
    "iuml"	=>	'\\"{i}',	#   small i, dieresis or umlaut mark
    "Ntilde"	=>	'\\~{N}',	#   capital N, tilde
    "ntilde"	=>	'\\~{n}',	#   small n, tilde
    "Oacute"	=>	"\\'{O}",	#   capital O, acute accent
    "oacute"	=>	"\\'{o}",	#   small o, acute accent
    "Ocirc"	=>	"\\^{O}",	#   capital O, circumflex accent
    "ocirc"	=>	"\\^{o}",	#   small o, circumflex accent
    "Ograve"	=>	"\\`{O}",	#   capital O, grave accent
    "ograve"	=>	"\\`{o}",	#   small o, grave accent
    "Oslash"	=>	"\\O",		#   capital O, slash
    "oslash"	=>	"\\o",		#   small o, slash
    "Otilde"	=>	"\\~{O}",	#   capital O, tilde
    "otilde"	=>	"\\~{o}",	#   small o, tilde
    "Ouml"	=>	'\\"{O}',	#   capital O, dieresis or umlaut mark
    "ouml"	=>	'\\"{o}',	#   small o, dieresis or umlaut mark
    "szlig"	=>	'\\ss{}',	#   small sharp s, German (sz ligature)
    "THORN"	=>	'\\L',		#   capital THORN, Icelandic
    "thorn"	=>	'\\l',,		#   small thorn, Icelandic
    "Uacute"	=>	"\\'{U}",	#   capital U, acute accent
    "uacute"	=>	"\\'{u}",	#   small u, acute accent
    "Ucirc"	=>	"\\^{U}",	#   capital U, circumflex accent
    "ucirc"	=>	"\\^{u}",	#   small u, circumflex accent
    "Ugrave"	=>	"\\`{U}",	#   capital U, grave accent
    "ugrave"	=>	"\\`{u}",	#   small u, grave accent
    "Uuml"	=>	'\\"{U}',	#   capital U, dieresis or umlaut mark
    "uuml"	=>	'\\"{u}',	#   small u, dieresis or umlaut mark
    "Yacute"	=>	"\\'{Y}",	#   capital Y, acute accent
    "yacute"	=>	"\\'{y}",	#   small y, acute accent
    "yuml"	=>	'\\"{y}',	#   small y, dieresis or umlaut mark
);
}
@


1.3
log
@perl5.005_03 (stock)
@
text
@a103 1
$/ = "";			# record separator is blank lines
d121 3
a123 1
open(POD,"<$ARGV[0]") || die "cant open $ARGV[0]";
d130 1
d319 2
d423 1
a423 1
	    } elsif ($lastcmd ne 'item') {
@


1.2
log
@perl 5.004_04
@
text
@d5 1
d16 1
d477 6
d687 1
a687 1
    "szlig"	=>	'\\ss',		#   small sharp s, German (sz ligature)
d708 1
@


1.1
log
@Initial revision
@
text
@d15 3
a17 4
chdir(dirname($0));
($file = basename($0)) =~ s/\.PL$//;
$file =~ s/\.pl$//
	if ($^O eq 'VMS' or $^O eq 'os2');  # "case-forgiving"
d27 3
a29 3
$Config{'startperl'}
    eval 'exec perl -S \$0 "\$@@"'
	if 0;
d126 1
d132 9
d158 16
d528 2
a529 3
    if ( /[\200-\377]/ ) {
	warn "hit bit char in input stream";
    }
d540 1
a540 1
    $s =~ s { E<([A-Za-z]+)> }
d543 5
a547 2
	    exists $HTML_Escapes{$1}
	    ? do { $HTML_Escapes{$1} }
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@a4 1
use Cwd;
d15 4
a18 4
$origdir = cwd;
chdir dirname($0);
$file = basename($0, '.PL');
$file .= '.com' if $^O eq 'VMS';
d28 3
a30 3
$Config{startperl}
    eval 'exec $Config{perlpath} -S \$0 \${1+"\$@@"}'
	if \$running_under_some_shell;
a126 1
$begun = "";
a131 9
    if ($begun) {
       if (/^=end\s+$begun/) {
           $begun = "";
       }
       elsif ($begun =~ /^(tex|latex)$/) {
           print LATEX $_;
       }
       next;
    }
a148 16
    if (/^=for\s+(\S+)\s*/s) {
	if ($1 eq "tex" or $1 eq "latex") {
	    print LATEX $',"\n";
	} else {
	    # ignore unknown for
	}
	next;
    }
    elsif (/^=begin\s+(\S+)\s*/s) {
	$begun = $1;
	if ($1 eq "tex" or $1 eq "latex") {
	    print LATEX $'."\n";
	}
	next;
    }

a449 6
	elsif ($cmd eq 'pod') {
	    ;	# recognise the pod directive, as no op (hs)
	}
 	elsif ($cmd eq 'pod') {
 	    ;    # recognise the pod directive, as no op (hs)
 	}
d503 3
a505 2
	# escape high bit characters in input stream
	s/([\200-\377])/"E<".ord($1).">"/ge;
d516 1
a516 1
    $s =~ s { E<((\d+)|([A-Za-z]+))> }
d519 2
a520 5
		defined($2) 
		? do { chr($2) }
		: 
	    exists $HTML_Escapes{$3}
	    ? do { $HTML_Escapes{$3} }
d652 1
a652 1
    "szlig"	=>	'\\ss{}',	#   small sharp s, German (sz ligature)
a672 1
chdir $origdir;
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d104 1
d122 1
a122 3
use Pod::Plainer;
open(POD,"-|") or Pod::Plainer -> new() -> parse_from_file($ARGV[0]), exit;

a128 1
$/ = "";			# record separator is blank lines
a316 2
	s/X<([^<>]*)>/\\index{$1}/g;

d419 1
a419 1
	    } elsif ( !@@listingcmd ) { 
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d37 110
d148 13
a160 1
# pod2latex conversion program
d162 15
a176 5
use Pod::LaTeX;
use Pod::Find qw/ pod_find /;
use Pod::Usage;
use Getopt::Long;
use File::Basename;
d178 4
a181 1
# Read command line arguments
d183 2
a184 9
my %options = (
	       "help"   => 0,
	       "man"    => 0,
	       "sections" => [],
	       "full"   => 0,
	       "out"    => undef,
	       "verbose" => 0,
	       "modify" => 0,
	      );
d186 26
a211 9
GetOptions(\%options, 
	   "help",
	   "man",
	   "verbose",
	   "full",
	   "sections=s@@",
	   "out=s",
	   "modify",
	  ) || pod2usage(2);
a212 2
pod2usage(1)  if ($options{help});
pod2usage(-verbose => 2)  if ($options{man});
d214 1
d216 2
a217 2
# Read all the files from the command line
my @@files = @@ARGV;
d219 134
a352 2
# Now find which ones are real pods and convert 
# directories to their contents.
a353 5
# Extract the pods from each arg since some of them might
# be directories
# This is not as efficient as using pod_find to search through
# everything at once but it allows us to preserve the order 
# supplied by the user
d355 150
a504 4
my @@pods;
foreach my $arg (@@files) {
  my %pods = pod_find($arg);
  push(@@pods, sort keys %pods);
d507 18
a524 4
# Abort if nothing to do
if ($#pods == -1) {
  warn "None of the supplied Pod files actually exist\n";
  exit;
d527 5
d533 5
d539 3
a541 6
# If $options{'out'} is set we are processing to a single output file
my $multi_documents;
if (exists $options{'out'} && defined $options{'out'}) {
  $multi_documents = 0;
} else {
  $multi_documents = 1;
d544 5
a548 3
# If the output file is not specified it is assumed that
# a single output file is required per input file using
# a .tex extension rather than any exisiting extension
d550 18
a567 1
if ($multi_documents) {
d569 5
a573 1
  # Case where we just generate one input per output
d575 20
a594 1
  foreach my $pod (@@pods) {
d596 20
a615 21
    if (-f $pod) {

      my $output = $pod;
      $output = basename($output, '.pm', '.pod','.pl') . '.tex';

      # Create a new parser object
      my $parser = new Pod::LaTeX(
				  AddPreamble => $options{'full'},
				  AddPostamble => $options{'full'},
				  MakeIndex => $options{'full'},
				  TableOfContents => $options{'full'},
				  ReplaceNAMEwithSection => $options{'modify'},
				  UniqueLabels => $options{'modify'},
				 );

      # Select sections if supplied
      $parser->select(@@{ $options{'sections'}})
	if @@{$options{'sections'}};

      # Derive the input file from the output file
      $parser->parse_from_file($pod, $output);
d617 2
a618 1
      print "Written output to $output\n" if $options{'verbose'};
d620 8
a627 2
    } else {
      warn "File $pod not found\n";
d629 2
d632 2
a633 85
  }
} else {
  
  # Case where we want everything to be in a single document

  # Need to open the output file ourselves
  my $output = $options{'out'};
  $output .= '.tex' unless $output =~ /\.tex$/;

  # Use auto-vivified file handle in perl 5.6
  use Symbol;
  my $outfh = gensym;
  open ($outfh, ">$output") || die "Could not open output file: $!\n";

  # Flag to indicate whether we have converted at least one file
  # indicates how many files have been converted
  my $converted = 0;

  # Loop over the input files
  foreach my $pod (@@pods) {

    if (-f $pod) {

      warn "Converting $pod\n" if $options{'verbose'};

      # Open the file (need the handle)
      # Use auto-vivified handle in perl 5.6
      my $podfh = gensym;
      open ($podfh, "<$pod") || die "Could not open pod file $pod: $!\n";

      # if this is the first file to be converted we may want to add
      # a preamble (controlled by command line option)
      if ($converted == 0 && $options{'full'}) {
	$preamble = 1;
      } else {
	$preamble = 0;
      }

      # if this is the last file to be converted may want to add
      # a postamble (controlled by command line option)
      # relies on a previous pass to check existence of all pods we
      # are converting.
      my $postamble = ( ($converted == $#pods && $options{'full'}) ? 1 : 0 );

      # Open parser object
      # May want to start with a preamble for the first one and
      # end with an index for the last
      my $parser = new Pod::LaTeX(
				  MakeIndex => $options{'full'},
				  TableOfContents => $preamble,
				  ReplaceNAMEwithSection => $options{'modify'},
				  UniqueLabels => $options{'modify'},
				  StartWithNewPage => $options{'full'},
				  AddPreamble => $preamble,
				  AddPostamble => $postamble,
				 );

      # Store the file name for error messages
      # This is a kluge that breaks the data hiding of the object
      $parser->{_INFILE} = $pod;

      # Select sections if supplied
      $parser->select(@@{ $options{'sections'}})
	if @@{$options{'sections'}};

      # Parse it
      $parser->parse_from_filehandle($podfh, $outfh);

      # We have converted at least one file
      $converted++;

    } else {
      warn "File $pod not found\n";
    }

  }

  # Should unlink the file if we didn't convert anything!
  # dont check for return status of unlink
  # since there is not a lot to be done if the unlink failed
  # and the program does not rely upon it.
  unlink "$output" unless $converted;

  # If verbose
  warn "Converted $converted files\n" if $options{'verbose'};
d635 71
a706 114

exit;

__END__

=head1 NAME

pod2latex - convert pod documentation to latex format

=head1 SYNOPSIS

  pod2latex *.pm

  pod2latex -out mytex.tex *.pod

  pod2latex -full -sections 'DESCRIPTION|NAME' SomeDir

=head1 DESCRIPTION

C<pod2latex> is a program to convert POD format documentation
(L<perlpod>) into latex. It can process multiple input documents at a
time and either generate a latex file per input document or a single
combined output file.

=head1 OPTIONS AND ARGUMENTS

This section describes the supported command line options. Minium
matching is supported.

=over 4

=item B<-out>

Name of the output file to be used. If there are multiple input pods
it is assumed that the intention is to write all translated output
into a single file. C<.tex> is appended if not present.  If the
argument is not supplied, a single document will be created for each
input file.

=item B<-full>

Creates a complete C<latex> file that can be processed immediately
(unless C<=for/=begin> directives are used that rely on extra packages).
Table of contents and index generation commands are included in the
wrapper C<latex> code.

=item B<-sections>

Specify pod sections to include (or remove if negated) in the
translation.  See L<Pod::Select/"SECTION SPECIFICATIONS"> for the
format to use for I<section-spec>. This option may be given multiple
times on the command line.This is identical to the similar option in
the C<podselect()> command.

=item B<-modify>

This option causes the output C<latex> to be slightly
modified from the input pod such that when a C<=head1 NAME>
is encountered a section is created containing the actual
pod name (rather than B<NAME>) and all subsequent C<=head1>
directives are treated as subsections. This has the advantage
that the description of a module will be in its own section
which is helpful for including module descriptions in documentation.
Also forces C<latex> label and index entries to be prefixed by the
name of the module.

=item B<-help>

Print a brief help message and exit.

=item B<-man>

Print the manual page and exit.

=item B<-verbose>

Print information messages as each document is processed.

=back

=head1 BUGS

Known bugs are:

=over 4

=item * 

Cross references between documents are not resolved when multiple
pod documents are converted into a single output C<latex> file.

=item * 

Functions and variables are not automatically recognized 
and they will therefore not be marked up in any special way
unless instructed by an explicit pod command.

=back

=head1 SEE ALSO

L<Pod::LaTeX>

=head1 AUTHOR

Tim Jenness E<lt>t.jenness@@jach.hawaii.eduE<gt>

This program is free software; you can redistribute it
and/or modify it under the same terms as Perl itself.

Copyright (C) 2000 Tim Jenness.

=cut

@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@a39 1
use strict;
a45 2
my $VERSION = "1.00";

a55 1
	       "h1level" => 1,  # section is equivalent to H1
a65 1
	   "h1level=i",
a128 2
				  Head1Level => $options{'h1level'},
				  LevelNoNum => $options{'h1level'} + 1,
d176 5
a180 2
      my $preamble = 0;
      $preamble = 1 if ($converted == 0 && $options{'full'});
a198 2
				  Head1Level => $options{'h1level'},
				  LevelNoNum => $options{'h1level'} + 1,
a295 7

=item B<-h1level>

Specifies the C<latex> section that is equivalent to a C<H1> pod
directive. This is an integer between 0 and 5 with 0 equivalent to a
C<latex> chapter, 1 equivalent to a C<latex> section etc. The default
is 1 (C<H1> equivalent to a latex section).
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d263 1
a263 1
This section describes the supported command line options. Minimum
d354 1
a354 1
Copyright (C) 2000, 2003 Tim Jenness. All Rights Reserved.
@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@a45 1
use Symbol;
d47 1
a47 12
my $VERSION = "1.01";

# return the entire contents of a text file
# whose name is given as argument
sub _get {
    my $fn = shift;
    my $infh = gensym;
    open $infh, $fn
        or die "Could not open file $fn: $!\n";
    local $/;
    return <$infh>;
}
a59 2
	       "preamble" => [],
	       "postamble" => [],
a60 5
# "prefile" is just like "preamble", but the argument 
# comes from the file named by the argument
$options{"prefile"} = sub { shift; push @@{$options{"preamble"}}, _get(shift) };
# the same between "postfile" and "postamble"
$options{"postfile"} = sub { shift; push @@{$options{"postamble"}}, _get(shift) };
a70 4
	   "preamble=s@@",
	   "postamble=s@@",
	   "prefile=s", 
	   "postfile=s"
a100 8
# Only want to override the preamble and postamble if we have
# been given values.
my %User;
$User{UserPreamble} = join("\n", @@{$options{'preamble'}})
  if ($options{preamble} && @@{$options{preamble}});
$User{UserPostamble} = join("\n", @@{$options{'postamble'}})
  if ($options{postamble} && @@{$options{postamble}});

a135 1
                                  %User,
d153 1
a153 1

d161 1
a204 1
                                  %User
a253 2
  pod2latex -prefile h.tex -postfile t.tex my.pod

a321 24
=item B<-preamble>

A user-supplied preamble for the LaTeX code. Multiple values
are supported and appended in order separated by "\n".
See B<-prefile> for reading the preamble from a file.

=item B<-postamble>

A user supplied postamble for the LaTeX code. Multiple values
are supported and appended in order separated by "\n".
See B<-postfile> for reading the postamble from a file.

=item B<-prefile>

A user-supplied preamble for the LaTeX code to be read from the
named file. Multiple values are supported and appended in
order. See B<-preamble>.

=item B<-postfile>

A user-supplied postamble for the LaTeX code to be read from the
named file. Multiple values are supported and appended in
order. See B<-postamble>.

d330 1
a330 1
=item *
d335 1
a335 1
=item *
d337 1
a337 1
Functions and variables are not automatically recognized
d349 1
a349 1
Tim Jenness E<lt>tjenness@@cpan.orgE<gt>
d354 1
a354 1
Copyright (C) 2000, 2003, 2004 Tim Jenness. All Rights Reserved.
@


