head	1.15;
access;
symbols
	OPENBSD_5_3:1.14.0.10
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.8
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.6
	OPENBSD_5_0:1.14.0.4
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	PERL_5_12_2:1.1.1.10
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	PERL_5_10_1:1.1.1.9
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.9.0.8
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.6
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.4
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.2
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.7.0.10
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.8
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.6
	OPENBSD_3_7_BASE:1.7
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.15
date	2013.03.25.20.40.59;	author sthen;	state dead;
branches;
next	1.14;

1.14
date	2010.09.24.15.07.04;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2009.10.13.01.25.48;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.12.18.24.48;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.30.12.21.41;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.29.17.36.18;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2007.02.04.19.32.49;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.28.19.23.12;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.46;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.34;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.36.02;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.07.45;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.22;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.59.37;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.06;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.06;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.41.06;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.34;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.24.54;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.08;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.28;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.03.28.18.49.37;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.29.17.18.57;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.10.12.18.10.40;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2010.09.24.14.49.08;	author millert;	state Exp;
branches;
next	;


desc
@@


1.15
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@=head1 NAME

perlxstut - Tutorial for writing XSUBs

=head1 DESCRIPTION

This tutorial will educate the reader on the steps involved in creating
a Perl extension.  The reader is assumed to have access to L<perlguts>,
L<perlapi> and L<perlxs>.

This tutorial starts with very simple examples and becomes more complex,
with each new example adding new features.  Certain concepts may not be
completely explained until later in the tutorial in order to slowly ease
the reader into building extensions.

This tutorial was written from a Unix point of view.  Where I know them
to be otherwise different for other platforms (e.g. Win32), I will list
them.  If you find something that was missed, please let me know.

=head1 SPECIAL NOTES

=head2 make

This tutorial assumes that the make program that Perl is configured to
use is called C<make>.  Instead of running "make" in the examples that
follow, you may have to substitute whatever make program Perl has been
configured to use.  Running B<perl -V:make> should tell you what it is.

=head2 Version caveat

When writing a Perl extension for general consumption, one should expect that
the extension will be used with versions of Perl different from the
version available on your machine.  Since you are reading this document,
the version of Perl on your machine is probably 5.005 or later, but the users
of your extension may have more ancient versions.

To understand what kinds of incompatibilities one may expect, and in the rare
case that the version of Perl on your machine is older than this document,
see the section on "Troubleshooting these Examples" for more information.

If your extension uses some features of Perl which are not available on older
releases of Perl, your users would appreciate an early meaningful warning.
You would probably put this information into the F<README> file, but nowadays
installation of extensions may be performed automatically, guided by F<CPAN.pm>
module or other tools.

In MakeMaker-based installations, F<Makefile.PL> provides the earliest
opportunity to perform version checks.  One can put something like this
in F<Makefile.PL> for this purpose:

    eval { require 5.007 }
        or die <<EOD;
    ############
    ### This module uses frobnication framework which is not available before
    ### version 5.007 of Perl.  Upgrade your Perl before installing Kara::Mba.
    ############
    EOD

=head2 Dynamic Loading versus Static Loading

It is commonly thought that if a system does not have the capability to
dynamically load a library, you cannot build XSUBs.  This is incorrect.
You I<can> build them, but you must link the XSUBs subroutines with the
rest of Perl, creating a new executable.  This situation is similar to
Perl 4.

This tutorial can still be used on such a system.  The XSUB build mechanism
will check the system and build a dynamically-loadable library if possible,
or else a static library and then, optionally, a new statically-linked
executable with that static library linked in.

Should you wish to build a statically-linked executable on a system which
can dynamically load libraries, you may, in all the following examples,
where the command "C<make>" with no arguments is executed, run the command
"C<make perl>" instead.

If you have generated such a statically-linked executable by choice, then
instead of saying "C<make test>", you should say "C<make test_static>".
On systems that cannot build dynamically-loadable libraries at all, simply
saying "C<make test>" is sufficient.

=head1 TUTORIAL

Now let's go on with the show!

=head2 EXAMPLE 1

Our first extension will be very simple.  When we call the routine in the
extension, it will print out a well-known message and return.

Run "C<h2xs -A -n Mytest>".  This creates a directory named Mytest,
possibly under ext/ if that directory exists in the current working
directory.  Several files will be created under the Mytest dir, including
MANIFEST, Makefile.PL, lib/Mytest.pm, Mytest.xs, t/Mytest.t, and Changes.

The MANIFEST file contains the names of all the files just created in the
Mytest directory.

The file Makefile.PL should look something like this:

    use ExtUtils::MakeMaker;
    # See lib/ExtUtils/MakeMaker.pm for details of how to influence
    # the contents of the Makefile that is written.
    WriteMakefile(
	NAME         => 'Mytest',
	VERSION_FROM => 'Mytest.pm', # finds $VERSION
	LIBS         => [''],   # e.g., '-lm'
	DEFINE       => '',     # e.g., '-DHAVE_SOMETHING'
	INC          => '',     # e.g., '-I/usr/include/other'
    );

The file Mytest.pm should start with something like this:

    package Mytest;

    use 5.008008;
    use strict;
    use warnings;

    require Exporter;

    our @@ISA = qw(Exporter);
    our %EXPORT_TAGS = ( 'all' => [ qw(

    ) ] );

    our @@EXPORT_OK = ( @@{ $EXPORT_TAGS{'all'} } );

    our @@EXPORT = qw(

    );

    our $VERSION = '0.01';

    require XSLoader;
    XSLoader::load('Mytest', $VERSION);

    # Preloaded methods go here.

    1;
    __END__
    # Below is the stub of documentation for your module. You better edit it!

The rest of the .pm file contains sample code for providing documentation for
the extension.

Finally, the Mytest.xs file should look something like this:

    #include "EXTERN.h"
    #include "perl.h"
    #include "XSUB.h"

    #include "ppport.h"

    MODULE = Mytest		PACKAGE = Mytest

Let's edit the .xs file by adding this to the end of the file:

    void
    hello()
	CODE:
	    printf("Hello, world!\n");

It is okay for the lines starting at the "CODE:" line to not be indented.
However, for readability purposes, it is suggested that you indent CODE:
one level and the lines following one more level.

Now we'll run "C<perl Makefile.PL>".  This will create a real Makefile,
which make needs.  Its output looks something like:

    % perl Makefile.PL
    Checking if your kit is complete...
    Looks good
    Writing Makefile for Mytest
    %

Now, running make will produce output that looks something like this (some
long lines have been shortened for clarity and some extraneous lines have
been deleted):

    % make
    cp lib/Mytest.pm blib/lib/Mytest.pm
    perl xsubpp  -typemap typemap  Mytest.xs > Mytest.xsc && mv Mytest.xsc Mytest.c
    Please specify prototyping behavior for Mytest.xs (see perlxs manual)
    cc -c     Mytest.c
    Running Mkbootstrap for Mytest ()
    chmod 644 Mytest.bs
    rm -f blib/arch/auto/Mytest/Mytest.so
    cc  -shared -L/usr/local/lib Mytest.o  -o blib/arch/auto/Mytest/Mytest.so   \
                \

    chmod 755 blib/arch/auto/Mytest/Mytest.so
    cp Mytest.bs blib/arch/auto/Mytest/Mytest.bs
    chmod 644 blib/arch/auto/Mytest/Mytest.bs
    Manifying blib/man3/Mytest.3pm
    %

You can safely ignore the line about "prototyping behavior" - it is
explained in L<perlxs/"The PROTOTYPES: Keyword">.

If you are on a Win32 system, and the build process fails with linker
errors for functions in the C library, check if your Perl is configured
to use PerlCRT (running B<perl -V:libc> should show you if this is the
case).  If Perl is configured to use PerlCRT, you have to make sure
PerlCRT.lib is copied to the same location that msvcrt.lib lives in,
so that the compiler can find it on its own.  msvcrt.lib is usually
found in the Visual C compiler's lib directory (e.g. C:/DevStudio/VC/lib).

Perl has its own special way of easily writing test scripts, but for this
example only, we'll create our own test script.  Create a file called hello
that looks like this:

    #! /opt/perl5/bin/perl

    use ExtUtils::testlib;

    use Mytest;

    Mytest::hello();

Now we make the script executable (C<chmod +x hello>), run the script
and we should see the following output:

    % ./hello
    Hello, world!
    %

=head2 EXAMPLE 2

Now let's add to our extension a subroutine that will take a single numeric
argument as input and return 0 if the number is even or 1 if the number
is odd.

Add the following to the end of Mytest.xs:

    int
    is_even(input)
	    int input
	CODE:
	    RETVAL = (input % 2 == 0);
	OUTPUT:
	    RETVAL

There does not need to be whitespace at the start of the "C<int input>"
line, but it is useful for improving readability.  Placing a semi-colon at
the end of that line is also optional.  Any amount and kind of whitespace
may be placed between the "C<int>" and "C<input>".

Now re-run make to rebuild our new shared library.

Now perform the same steps as before, generating a Makefile from the
Makefile.PL file, and running make.

In order to test that our extension works, we now need to look at the
file t/Mytest.t.  This file is set up to imitate the same kind of testing
structure that Perl itself has.  Within the test script, you perform a
number of tests to confirm the behavior of the extension, printing "ok"
when the test is correct, "not ok" when it is not.

    use Test::More tests => 4;
    BEGIN { use_ok('Mytest') };

    #########################

    # Insert your test code below, the Test::More module is use()ed here so read
    # its man page ( perldoc Test::More ) for help writing this test script.

    is(&Mytest::is_even(0), 1);
    is(&Mytest::is_even(1), 0);
    is(&Mytest::is_even(2), 1);

We will be calling the test script through the command "C<make test>".  You
should see output that looks something like this:

    %make test
    PERL_DL_NONLAZY=1 /usr/bin/perl "-MExtUtils::Command::MM" "-e" "test_harness(0, 'blib/lib', 'blib/arch')" t/*.t
    t/Mytest....ok
    All tests successful.
    Files=1, Tests=4,  0 wallclock secs ( 0.03 cusr +  0.00 csys =  0.03 CPU)
    %

=head2 What has gone on?

The program h2xs is the starting point for creating extensions.  In later
examples we'll see how we can use h2xs to read header files and generate
templates to connect to C routines.

h2xs creates a number of files in the extension directory.  The file
Makefile.PL is a perl script which will generate a true Makefile to build
the extension.  We'll take a closer look at it later.

The .pm and .xs files contain the meat of the extension.  The .xs file holds
the C routines that make up the extension.  The .pm file contains routines
that tell Perl how to load your extension.

Generating the Makefile and running C<make> created a directory called blib
(which stands for "build library") in the current working directory.  This
directory will contain the shared library that we will build.  Once we have
tested it, we can install it into its final location.

Invoking the test script via "C<make test>" did something very important.
It invoked perl with all those C<-I> arguments so that it could find the
various files that are part of the extension.  It is I<very> important that
while you are still testing extensions that you use "C<make test>".  If you
try to run the test script all by itself, you will get a fatal error.
Another reason it is important to use "C<make test>" to run your test
script is that if you are testing an upgrade to an already-existing version,
using "C<make test>" ensures that you will test your new extension, not the
already-existing version.

When Perl sees a C<use extension;>, it searches for a file with the same name
as the C<use>'d extension that has a .pm suffix.  If that file cannot be found,
Perl dies with a fatal error.  The default search path is contained in the
C<@@INC> array.

In our case, Mytest.pm tells perl that it will need the Exporter and Dynamic
Loader extensions.  It then sets the C<@@ISA> and C<@@EXPORT> arrays and the
C<$VERSION> scalar; finally it tells perl to bootstrap the module.  Perl
will call its dynamic loader routine (if there is one) and load the shared
library.

The two arrays C<@@ISA> and C<@@EXPORT> are very important.  The C<@@ISA>
array contains a list of other packages in which to search for methods (or
subroutines) that do not exist in the current package.  This is usually
only important for object-oriented extensions (which we will talk about
much later), and so usually doesn't need to be modified.

The C<@@EXPORT> array tells Perl which of the extension's variables and
subroutines should be placed into the calling package's namespace.  Because
you don't know if the user has already used your variable and subroutine
names, it's vitally important to carefully select what to export.  Do I<not>
export method or variable names I<by default> without a good reason.

As a general rule, if the module is trying to be object-oriented then don't
export anything.  If it's just a collection of functions and variables, then
you can export them via another array, called C<@@EXPORT_OK>.  This array
does not automatically place its subroutine and variable names into the
namespace unless the user specifically requests that this be done.

See L<perlmod> for more information.

The C<$VERSION> variable is used to ensure that the .pm file and the shared
library are "in sync" with each other.  Any time you make changes to
the .pm or .xs files, you should increment the value of this variable.

=head2 Writing good test scripts

The importance of writing good test scripts cannot be over-emphasized.  You
should closely follow the "ok/not ok" style that Perl itself uses, so that
it is very easy and unambiguous to determine the outcome of each test case.
When you find and fix a bug, make sure you add a test case for it.

By running "C<make test>", you ensure that your Mytest.t script runs and uses
the correct version of your extension.  If you have many test cases,
save your test files in the "t" directory and use the suffix ".t".
When you run "C<make test>", all of these test files will be executed.

=head2 EXAMPLE 3

Our third extension will take one argument as its input, round off that
value, and set the I<argument> to the rounded value.

Add the following to the end of Mytest.xs:

	void
	round(arg)
		double  arg
	    CODE:
		if (arg > 0.0) {
			arg = floor(arg + 0.5);
		} else if (arg < 0.0) {
			arg = ceil(arg - 0.5);
		} else {
			arg = 0.0;
		}
	    OUTPUT:
		arg

Edit the Makefile.PL file so that the corresponding line looks like this:

	'LIBS'      => ['-lm'],   # e.g., '-lm'

Generate the Makefile and run make.  Change the test number in Mytest.t to
"9" and add the following tests:

	$i = -1.5; &Mytest::round($i); is( $i, -2.0 );
	$i = -1.1; &Mytest::round($i); is( $i, -1.0 );
	$i = 0.0; &Mytest::round($i);  is( $i,  0.0 );
	$i = 0.5; &Mytest::round($i);  is( $i,  1.0 );
	$i = 1.2; &Mytest::round($i);  is( $i,  1.0 );

Running "C<make test>" should now print out that all nine tests are okay.

Notice that in these new test cases, the argument passed to round was a
scalar variable.  You might be wondering if you can round a constant or
literal.  To see what happens, temporarily add the following line to Mytest.t:

	&Mytest::round(3);

Run "C<make test>" and notice that Perl dies with a fatal error.  Perl won't
let you change the value of constants!

=head2 What's new here?

=over 4

=item *

We've made some changes to Makefile.PL.  In this case, we've specified an
extra library to be linked into the extension's shared library, the math
library libm in this case.  We'll talk later about how to write XSUBs that
can call every routine in a library.

=item *

The value of the function is not being passed back as the function's return
value, but by changing the value of the variable that was passed into the
function.  You might have guessed that when you saw that the return value
of round is of type "void".

=back

=head2 Input and Output Parameters

You specify the parameters that will be passed into the XSUB on the line(s)
after you declare the function's return value and name.  Each input parameter
line starts with optional whitespace, and may have an optional terminating
semicolon.

The list of output parameters occurs at the very end of the function, just
after the OUTPUT: directive.  The use of RETVAL tells Perl that you
wish to send this value back as the return value of the XSUB function.  In
Example 3, we wanted the "return value" placed in the original variable
which we passed in, so we listed it (and not RETVAL) in the OUTPUT: section.

=head2 The XSUBPP Program

The B<xsubpp> program takes the XS code in the .xs file and translates it into
C code, placing it in a file whose suffix is .c.  The C code created makes
heavy use of the C functions within Perl.

=head2 The TYPEMAP file

The B<xsubpp> program uses rules to convert from Perl's data types (scalar,
array, etc.) to C's data types (int, char, etc.).  These rules are stored
in the typemap file ($PERLLIB/ExtUtils/typemap).  This file is split into
three parts.

The first section maps various C data types to a name, which corresponds
somewhat with the various Perl types.  The second section contains C code
which B<xsubpp> uses to handle input parameters.  The third section contains
C code which B<xsubpp> uses to handle output parameters.

Let's take a look at a portion of the .c file created for our extension.
The file name is Mytest.c:

	XS(XS_Mytest_round)
	{
	    dXSARGS;
	    if (items != 1)
		Perl_croak(aTHX_ "Usage: Mytest::round(arg)");
        PERL_UNUSED_VAR(cv); /* -W */
	    {
		double  arg = (double)SvNV(ST(0));	/* XXXXX */
		if (arg > 0.0) {
			arg = floor(arg + 0.5);
		} else if (arg < 0.0) {
			arg = ceil(arg - 0.5);
		} else {
			arg = 0.0;
		}
		sv_setnv(ST(0), (double)arg);	/* XXXXX */
        SvSETMAGIC(ST(0));
	    }
	    XSRETURN_EMPTY;
	}

Notice the two lines commented with "XXXXX".  If you check the first section
of the typemap file, you'll see that doubles are of type T_DOUBLE.  In the
INPUT section, an argument that is T_DOUBLE is assigned to the variable
arg by calling the routine SvNV on something, then casting it to double,
then assigned to the variable arg.  Similarly, in the OUTPUT section,
once arg has its final value, it is passed to the sv_setnv function to
be passed back to the calling subroutine.  These two functions are explained
in L<perlguts>; we'll talk more later about what that "ST(0)" means in the
section on the argument stack.

=head2 Warning about Output Arguments

In general, it's not a good idea to write extensions that modify their input
parameters, as in Example 3.  Instead, you should probably return multiple
values in an array and let the caller handle them (we'll do this in a later
example).  However, in order to better accommodate calling pre-existing C
routines, which often do modify their input parameters, this behavior is
tolerated.

=head2 EXAMPLE 4

In this example, we'll now begin to write XSUBs that will interact with
pre-defined C libraries.  To begin with, we will build a small library of
our own, then let h2xs write our .pm and .xs files for us.

Create a new directory called Mytest2 at the same level as the directory
Mytest.  In the Mytest2 directory, create another directory called mylib,
and cd into that directory.

Here we'll create some files that will generate a test library.  These will
include a C source file and a header file.  We'll also create a Makefile.PL
in this directory.  Then we'll make sure that running make at the Mytest2
level will automatically run this Makefile.PL file and the resulting Makefile.

In the mylib directory, create a file mylib.h that looks like this:

	#define TESTVAL	4

	extern double	foo(int, long, const char*);

Also create a file mylib.c that looks like this:

	#include <stdlib.h>
	#include "./mylib.h"

	double
	foo(int a, long b, const char *c)
	{
		return (a + b + atof(c) + TESTVAL);
	}

And finally create a file Makefile.PL that looks like this:

	use ExtUtils::MakeMaker;
	$Verbose = 1;
	WriteMakefile(
	    NAME   => 'Mytest2::mylib',
	    SKIP   => [qw(all static static_lib dynamic dynamic_lib)],
	    clean  => {'FILES' => 'libmylib$(LIB_EXT)'},
	);


	sub MY::top_targets {
		'
	all :: static

	pure_all :: static

	static ::       libmylib$(LIB_EXT)

	libmylib$(LIB_EXT): $(O_FILES)
		$(AR) cr libmylib$(LIB_EXT) $(O_FILES)
		$(RANLIB) libmylib$(LIB_EXT)

	';
	}

Make sure you use a tab and not spaces on the lines beginning with "$(AR)"
and "$(RANLIB)".  Make will not function properly if you use spaces.
It has also been reported that the "cr" argument to $(AR) is unnecessary
on Win32 systems.

We will now create the main top-level Mytest2 files.  Change to the directory
above Mytest2 and run the following command:

	% h2xs -O -n Mytest2 ./Mytest2/mylib/mylib.h

This will print out a warning about overwriting Mytest2, but that's okay.
Our files are stored in Mytest2/mylib, and will be untouched.

The normal Makefile.PL that h2xs generates doesn't know about the mylib
directory.  We need to tell it that there is a subdirectory and that we
will be generating a library in it.  Let's add the argument MYEXTLIB to
the WriteMakefile call so that it looks like this:

	WriteMakefile(
	    'NAME'      => 'Mytest2',
	    'VERSION_FROM' => 'Mytest2.pm', # finds $VERSION
	    'LIBS'      => [''],   # e.g., '-lm'
	    'DEFINE'    => '',     # e.g., '-DHAVE_SOMETHING'
	    'INC'       => '',     # e.g., '-I/usr/include/other'
	    'MYEXTLIB' => 'mylib/libmylib$(LIB_EXT)',
	);

and then at the end add a subroutine (which will override the pre-existing
subroutine).  Remember to use a tab character to indent the line beginning
with "cd"!

	sub MY::postamble {
	'
	$(MYEXTLIB): mylib/Makefile
		cd mylib && $(MAKE) $(PASSTHRU)
	';
	}

Let's also fix the MANIFEST file so that it accurately reflects the contents
of our extension.  The single line that says "mylib" should be replaced by
the following three lines:

	mylib/Makefile.PL
	mylib/mylib.c
	mylib/mylib.h

To keep our namespace nice and unpolluted, edit the .pm file and change
the variable C<@@EXPORT> to C<@@EXPORT_OK>.  Finally, in the
.xs file, edit the #include line to read:

	#include "mylib/mylib.h"

And also add the following function definition to the end of the .xs file:

	double
	foo(a,b,c)
		int             a
		long            b
		const char *    c
	    OUTPUT:
		RETVAL

Now we also need to create a typemap file because the default Perl doesn't
currently support the const char * type.  Create a file called typemap in
the Mytest2 directory and place the following in it:

	const char *	T_PV

Now run perl on the top-level Makefile.PL.  Notice that it also created a
Makefile in the mylib directory.  Run make and watch that it does cd into
the mylib directory and run make in there as well.

Now edit the Mytest2.t script and change the number of tests to "4",
and add the following lines to the end of the script:

	is( &Mytest2::foo(1, 2, "Hello, world!"), 7 );
	is( &Mytest2::foo(1, 2, "0.0"), 7 );
	ok( abs(&Mytest2::foo(0, 0, "-3.4") - 0.6) <= 0.01 );

(When dealing with floating-point comparisons, it is best to not check for
equality, but rather that the difference between the expected and actual
result is below a certain amount (called epsilon) which is 0.01 in this case)

Run "C<make test>" and all should be well. There are some warnings on missing tests
for the Mytest2::mylib extension, but you can ignore them.

=head2 What has happened here?

Unlike previous examples, we've now run h2xs on a real include file.  This
has caused some extra goodies to appear in both the .pm and .xs files.

=over 4

=item *

In the .xs file, there's now a #include directive with the absolute path to
the mylib.h header file.  We changed this to a relative path so that we
could move the extension directory if we wanted to.

=item *

There's now some new C code that's been added to the .xs file.  The purpose
of the C<constant> routine is to make the values that are #define'd in the
header file accessible by the Perl script (by calling either C<TESTVAL> or
C<&Mytest2::TESTVAL>).  There's also some XS code to allow calls to the
C<constant> routine.

=item *

The .pm file originally exported the name C<TESTVAL> in the C<@@EXPORT> array.
This could lead to name clashes.  A good rule of thumb is that if the #define
is only going to be used by the C routines themselves, and not by the user,
they should be removed from the C<@@EXPORT> array.  Alternately, if you don't
mind using the "fully qualified name" of a variable, you could move most
or all of the items from the C<@@EXPORT> array into the C<@@EXPORT_OK> array.

=item *

If our include file had contained #include directives, these would not have
been processed by h2xs.  There is no good solution to this right now.

=item *

We've also told Perl about the library that we built in the mylib
subdirectory.  That required only the addition of the C<MYEXTLIB> variable
to the WriteMakefile call and the replacement of the postamble subroutine
to cd into the subdirectory and run make.  The Makefile.PL for the
library is a bit more complicated, but not excessively so.  Again we
replaced the postamble subroutine to insert our own code.  This code
simply specified that the library to be created here was a static archive
library (as opposed to a dynamically loadable library) and provided the
commands to build it.

=back

=head2 Anatomy of .xs file

The .xs file of L<"EXAMPLE 4"> contained some new elements.  To understand
the meaning of these elements, pay attention to the line which reads

	MODULE = Mytest2		PACKAGE = Mytest2

Anything before this line is plain C code which describes which headers
to include, and defines some convenience functions.  No translations are
performed on this part, apart from having embedded POD documentation
skipped over (see L<perlpod>) it goes into the generated output C file as is.

Anything after this line is the description of XSUB functions.
These descriptions are translated by B<xsubpp> into C code which
implements these functions using Perl calling conventions, and which
makes these functions visible from Perl interpreter.

Pay a special attention to the function C<constant>.  This name appears
twice in the generated .xs file: once in the first part, as a static C
function, then another time in the second part, when an XSUB interface to
this static C function is defined.

This is quite typical for .xs files: usually the .xs file provides
an interface to an existing C function.  Then this C function is defined
somewhere (either in an external library, or in the first part of .xs file),
and a Perl interface to this function (i.e. "Perl glue") is described in the
second part of .xs file.  The situation in L<"EXAMPLE 1">, L<"EXAMPLE 2">,
and L<"EXAMPLE 3">, when all the work is done inside the "Perl glue", is
somewhat of an exception rather than the rule.

=head2 Getting the fat out of XSUBs

In L<"EXAMPLE 4"> the second part of .xs file contained the following
description of an XSUB:

	double
	foo(a,b,c)
		int             a
		long            b
		const char *    c
	    OUTPUT:
		RETVAL

Note that in contrast with L<"EXAMPLE 1">, L<"EXAMPLE 2"> and L<"EXAMPLE 3">,
this description does not contain the actual I<code> for what is done
is done during a call to Perl function foo().  To understand what is going
on here, one can add a CODE section to this XSUB:

	double
	foo(a,b,c)
		int             a
		long            b
		const char *    c
	    CODE:
		RETVAL = foo(a,b,c);
	    OUTPUT:
		RETVAL

However, these two XSUBs provide almost identical generated C code: B<xsubpp>
compiler is smart enough to figure out the C<CODE:> section from the first
two lines of the description of XSUB.  What about C<OUTPUT:> section?  In
fact, that is absolutely the same!  The C<OUTPUT:> section can be removed
as well, I<as far as C<CODE:> section or C<PPCODE:> section> is not
specified: B<xsubpp> can see that it needs to generate a function call
section, and will autogenerate the OUTPUT section too.  Thus one can
shortcut the XSUB to become:

	double
	foo(a,b,c)
		int             a
		long            b
		const char *    c

Can we do the same with an XSUB

	int
	is_even(input)
		int	input
	    CODE:
		RETVAL = (input % 2 == 0);
	    OUTPUT:
		RETVAL

of L<"EXAMPLE 2">?  To do this, one needs to define a C function C<int
is_even(int input)>.  As we saw in L<Anatomy of .xs file>, a proper place
for this definition is in the first part of .xs file.  In fact a C function

	int
	is_even(int arg)
	{
		return (arg % 2 == 0);
	}

is probably overkill for this.  Something as simple as a C<#define> will
do too:

	#define is_even(arg)	((arg) % 2 == 0)

After having this in the first part of .xs file, the "Perl glue" part becomes
as simple as

	int
	is_even(input)
		int	input

This technique of separation of the glue part from the workhorse part has
obvious tradeoffs: if you want to change a Perl interface, you need to
change two places in your code.  However, it removes a lot of clutter,
and makes the workhorse part independent from idiosyncrasies of Perl calling
convention.  (In fact, there is nothing Perl-specific in the above description,
a different version of B<xsubpp> might have translated this to TCL glue or
Python glue as well.)

=head2 More about XSUB arguments

With the completion of Example 4, we now have an easy way to simulate some
real-life libraries whose interfaces may not be the cleanest in the world.
We shall now continue with a discussion of the arguments passed to the
B<xsubpp> compiler.

When you specify arguments to routines in the .xs file, you are really
passing three pieces of information for each argument listed.  The first
piece is the order of that argument relative to the others (first, second,
etc).  The second is the type of argument, and consists of the type
declaration of the argument (e.g., int, char*, etc).  The third piece is
the calling convention for the argument in the call to the library function.

While Perl passes arguments to functions by reference,
C passes arguments by value; to implement a C function which modifies data
of one of the "arguments", the actual argument of this C function would be
a pointer to the data.  Thus two C functions with declarations

	int string_length(char *s);
	int upper_case_char(char *cp);

may have completely different semantics: the first one may inspect an array
of chars pointed by s, and the second one may immediately dereference C<cp>
and manipulate C<*cp> only (using the return value as, say, a success
indicator).  From Perl one would use these functions in
a completely different manner.

One conveys this info to B<xsubpp> by replacing C<*> before the
argument by C<&>.  C<&> means that the argument should be passed to a library
function by its address.  The above two function may be XSUB-ified as

	int
	string_length(s)
		char *	s

	int
	upper_case_char(cp)
		char	&cp

For example, consider:

	int
	foo(a,b)
		char	&a
		char *	b

The first Perl argument to this function would be treated as a char and assigned
to the variable a, and its address would be passed into the function foo.
The second Perl argument would be treated as a string pointer and assigned to the
variable b.  The I<value> of b would be passed into the function foo.  The
actual call to the function foo that B<xsubpp> generates would look like this:

	foo(&a, b);

B<xsubpp> will parse the following function argument lists identically:

	char	&a
	char&a
	char	& a

However, to help ease understanding, it is suggested that you place a "&"
next to the variable name and away from the variable type), and place a
"*" near the variable type, but away from the variable name (as in the
call to foo above).  By doing so, it is easy to understand exactly what
will be passed to the C function; it will be whatever is in the "last
column".

You should take great pains to try to pass the function the type of variable
it wants, when possible.  It will save you a lot of trouble in the long run.

=head2 The Argument Stack

If we look at any of the C code generated by any of the examples except
example 1, you will notice a number of references to ST(n), where n is
usually 0.  "ST" is actually a macro that points to the n'th argument
on the argument stack.  ST(0) is thus the first argument on the stack and
therefore the first argument passed to the XSUB, ST(1) is the second
argument, and so on.

When you list the arguments to the XSUB in the .xs file, that tells B<xsubpp>
which argument corresponds to which of the argument stack (i.e., the first
one listed is the first argument, and so on).  You invite disaster if you
do not list them in the same order as the function expects them.

The actual values on the argument stack are pointers to the values passed
in.  When an argument is listed as being an OUTPUT value, its corresponding
value on the stack (i.e., ST(0) if it was the first argument) is changed.
You can verify this by looking at the C code generated for Example 3.
The code for the round() XSUB routine contains lines that look like this:

	double  arg = (double)SvNV(ST(0));
	/* Round the contents of the variable arg */
	sv_setnv(ST(0), (double)arg);

The arg variable is initially set by taking the value from ST(0), then is
stored back into ST(0) at the end of the routine.

XSUBs are also allowed to return lists, not just scalars.  This must be
done by manipulating stack values ST(0), ST(1), etc, in a subtly
different way.  See L<perlxs> for details.

XSUBs are also allowed to avoid automatic conversion of Perl function arguments
to C function arguments.  See L<perlxs> for details.  Some people prefer
manual conversion by inspecting C<ST(i)> even in the cases when automatic
conversion will do, arguing that this makes the logic of an XSUB call clearer.
Compare with L<"Getting the fat out of XSUBs"> for a similar tradeoff of
a complete separation of "Perl glue" and "workhorse" parts of an XSUB.

While experts may argue about these idioms, a novice to Perl guts may
prefer a way which is as little Perl-guts-specific as possible, meaning
automatic conversion and automatic call generation, as in
L<"Getting the fat out of XSUBs">.  This approach has the additional
benefit of protecting the XSUB writer from future changes to the Perl API.

=head2 Extending your Extension

Sometimes you might want to provide some extra methods or subroutines
to assist in making the interface between Perl and your extension simpler
or easier to understand.  These routines should live in the .pm file.
Whether they are automatically loaded when the extension itself is loaded
or only loaded when called depends on where in the .pm file the subroutine
definition is placed.  You can also consult L<AutoLoader> for an alternate
way to store and load your extra subroutines.

=head2 Documenting your Extension

There is absolutely no excuse for not documenting your extension.
Documentation belongs in the .pm file.  This file will be fed to pod2man,
and the embedded documentation will be converted to the manpage format,
then placed in the blib directory.  It will be copied to Perl's
manpage directory when the extension is installed.

You may intersperse documentation and Perl code within the .pm file.
In fact, if you want to use method autoloading, you must do this,
as the comment inside the .pm file explains.

See L<perlpod> for more information about the pod format.

=head2 Installing your Extension

Once your extension is complete and passes all its tests, installing it
is quite simple: you simply run "make install".  You will either need
to have write permission into the directories where Perl is installed,
or ask your system administrator to run the make for you.

Alternately, you can specify the exact directory to place the extension's
files by placing a "PREFIX=/destination/directory" after the make install.
(or in between the make and install if you have a brain-dead version of make).
This can be very useful if you are building an extension that will eventually
be distributed to multiple systems.  You can then just archive the files in
the destination directory and distribute them to your destination systems.

=head2 EXAMPLE 5

In this example, we'll do some more work with the argument stack.  The
previous examples have all returned only a single value.  We'll now
create an extension that returns an array.

This extension is very Unix-oriented (struct statfs and the statfs system
call).  If you are not running on a Unix system, you can substitute for
statfs any other function that returns multiple values, you can hard-code
values to be returned to the caller (although this will be a bit harder
to test the error case), or you can simply not do this example.  If you
change the XSUB, be sure to fix the test cases to match the changes.

Return to the Mytest directory and add the following code to the end of
Mytest.xs:

	void
	statfs(path)
		char *  path
	    INIT:
		int i;
		struct statfs buf;

	    PPCODE:
		i = statfs(path, &buf);
		if (i == 0) {
			XPUSHs(sv_2mortal(newSVnv(buf.f_bavail)));
			XPUSHs(sv_2mortal(newSVnv(buf.f_bfree)));
			XPUSHs(sv_2mortal(newSVnv(buf.f_blocks)));
			XPUSHs(sv_2mortal(newSVnv(buf.f_bsize)));
			XPUSHs(sv_2mortal(newSVnv(buf.f_ffree)));
			XPUSHs(sv_2mortal(newSVnv(buf.f_files)));
			XPUSHs(sv_2mortal(newSVnv(buf.f_type)));
		} else {
			XPUSHs(sv_2mortal(newSVnv(errno)));
		}

You'll also need to add the following code to the top of the .xs file, just
after the include of "XSUB.h":

	#include <sys/vfs.h>

Also add the following code segment to Mytest.t while incrementing the "9"
tests to "11":

	@@a = &Mytest::statfs("/blech");
	ok( scalar(@@a) == 1 && $a[0] == 2 );
	@@a = &Mytest::statfs("/");
	is( scalar(@@a), 7 );

=head2 New Things in this Example

This example added quite a few new concepts.  We'll take them one at a time.

=over 4

=item *

The INIT: directive contains code that will be placed immediately after
the argument stack is decoded.  C does not allow variable declarations at
arbitrary locations inside a function,
so this is usually the best way to declare local variables needed by the XSUB.
(Alternatively, one could put the whole C<PPCODE:> section into braces, and
put these declarations on top.)

=item *

This routine also returns a different number of arguments depending on the
success or failure of the call to statfs.  If there is an error, the error
number is returned as a single-element array.  If the call is successful,
then a 9-element array is returned.  Since only one argument is passed into
this function, we need room on the stack to hold the 9 values which may be
returned.

We do this by using the PPCODE: directive, rather than the CODE: directive.
This tells B<xsubpp> that we will be managing the return values that will be
put on the argument stack by ourselves.

=item *

When we want to place values to be returned to the caller onto the stack,
we use the series of macros that begin with "XPUSH".  There are five
different versions, for placing integers, unsigned integers, doubles,
strings, and Perl scalars on the stack.  In our example, we placed a
Perl scalar onto the stack.  (In fact this is the only macro which
can be used to return multiple values.)

The XPUSH* macros will automatically extend the return stack to prevent
it from being overrun.  You push values onto the stack in the order you
want them seen by the calling program.

=item *

The values pushed onto the return stack of the XSUB are actually mortal SV's.
They are made mortal so that once the values are copied by the calling
program, the SV's that held the returned values can be deallocated.
If they were not mortal, then they would continue to exist after the XSUB
routine returned, but would not be accessible.  This is a memory leak.

=item *

If we were interested in performance, not in code compactness, in the success
branch we would not use C<XPUSHs> macros, but C<PUSHs> macros, and would
pre-extend the stack before pushing the return values:

	EXTEND(SP, 7);

The tradeoff is that one needs to calculate the number of return values
in advance (though overextending the stack will not typically hurt
anything but memory consumption).

Similarly, in the failure branch we could use C<PUSHs> I<without> extending
the stack: the Perl function reference comes to an XSUB on the stack, thus
the stack is I<always> large enough to take one return value.

=back

=head2 EXAMPLE 6

In this example, we will accept a reference to an array as an input
parameter, and return a reference to an array of hashes.  This will
demonstrate manipulation of complex Perl data types from an XSUB.

This extension is somewhat contrived.  It is based on the code in
the previous example.  It calls the statfs function multiple times,
accepting a reference to an array of filenames as input, and returning
a reference to an array of hashes containing the data for each of the
filesystems.

Return to the Mytest directory and add the following code to the end of
Mytest.xs:

    SV *
    multi_statfs(paths)
	    SV * paths
	INIT:
	    AV * results;
	    I32 numpaths = 0;
	    int i, n;
	    struct statfs buf;

	    if ((!SvROK(paths))
		|| (SvTYPE(SvRV(paths)) != SVt_PVAV)
		|| ((numpaths = av_len((AV *)SvRV(paths))) < 0))
	    {
		XSRETURN_UNDEF;
	    }
	    results = (AV *)sv_2mortal((SV *)newAV());
	CODE:
	    for (n = 0; n <= numpaths; n++) {
		HV * rh;
		STRLEN l;
		char * fn = SvPV(*av_fetch((AV *)SvRV(paths), n, 0), l);

		i = statfs(fn, &buf);
		if (i != 0) {
		    av_push(results, newSVnv(errno));
		    continue;
		}

		rh = (HV *)sv_2mortal((SV *)newHV());

		hv_store(rh, "f_bavail", 8, newSVnv(buf.f_bavail), 0);
		hv_store(rh, "f_bfree",  7, newSVnv(buf.f_bfree),  0);
		hv_store(rh, "f_blocks", 8, newSVnv(buf.f_blocks), 0);
		hv_store(rh, "f_bsize",  7, newSVnv(buf.f_bsize),  0);
		hv_store(rh, "f_ffree",  7, newSVnv(buf.f_ffree),  0);
		hv_store(rh, "f_files",  7, newSVnv(buf.f_files),  0);
		hv_store(rh, "f_type",   6, newSVnv(buf.f_type),   0);

		av_push(results, newRV((SV *)rh));
	    }
	    RETVAL = newRV((SV *)results);
	OUTPUT:
	    RETVAL

And add the following code to Mytest.t, while incrementing the "11"
tests to "13":

	$results = Mytest::multi_statfs([ '/', '/blech' ]);
	ok( ref $results->[0]) );
	ok( ! ref $results->[1] );

=head2 New Things in this Example

There are a number of new concepts introduced here, described below:

=over 4

=item *

This function does not use a typemap.  Instead, we declare it as accepting
one SV* (scalar) parameter, and returning an SV* value, and we take care of
populating these scalars within the code.  Because we are only returning
one value, we don't need a C<PPCODE:> directive - instead, we use C<CODE:>
and C<OUTPUT:> directives.

=item *

When dealing with references, it is important to handle them with caution.
The C<INIT:> block first checks that
C<SvROK> returns true, which indicates that paths is a valid reference.  It
then verifies that the object referenced by paths is an array, using C<SvRV>
to dereference paths, and C<SvTYPE> to discover its type.  As an added test,
it checks that the array referenced by paths is non-empty, using the C<av_len>
function (which returns -1 if the array is empty).  The XSRETURN_UNDEF macro
is used to abort the XSUB and return the undefined value whenever all three of
these conditions are not met.

=item *

We manipulate several arrays in this XSUB.  Note that an array is represented
internally by an AV* pointer.  The functions and macros for manipulating
arrays are similar to the functions in Perl: C<av_len> returns the highest
index in an AV*, much like $#array; C<av_fetch> fetches a single scalar value
from an array, given its index; C<av_push> pushes a scalar value onto the
end of the array, automatically extending the array as necessary.

Specifically, we read pathnames one at a time from the input array, and
store the results in an output array (results) in the same order.  If
statfs fails, the element pushed onto the return array is the value of
errno after the failure.  If statfs succeeds, though, the value pushed
onto the return array is a reference to a hash containing some of the
information in the statfs structure.

As with the return stack, it would be possible (and a small performance win)
to pre-extend the return array before pushing data into it, since we know
how many elements we will return:

	av_extend(results, numpaths);

=item *

We are performing only one hash operation in this function, which is storing
a new scalar under a key using C<hv_store>.  A hash is represented by an HV*
pointer.  Like arrays, the functions for manipulating hashes from an XSUB
mirror the functionality available from Perl.  See L<perlguts> and L<perlapi>
for details.

=item *

To create a reference, we use the C<newRV> function.  Note that you can
cast an AV* or an HV* to type SV* in this case (and many others).  This
allows you to take references to arrays, hashes and scalars with the same
function.  Conversely, the C<SvRV> function always returns an SV*, which may
need to be cast to the appropriate type if it is something other than a
scalar (check with C<SvTYPE>).

=item *

At this point, xsubpp is doing very little work - the differences between
Mytest.xs and Mytest.c are minimal.

=back

=head2 EXAMPLE 7 (Coming Soon)

XPUSH args AND set RETVAL AND assign return value to array

=head2 EXAMPLE 8 (Coming Soon)

Setting $!

=head2 EXAMPLE 9 Passing open files to XSes

You would think passing files to an XS is difficult, with all the
typeglobs and stuff. Well, it isn't.

Suppose that for some strange reason we need a wrapper around the
standard C library function C<fputs()>. This is all we need:

	#define PERLIO_NOT_STDIO 0
	#include "EXTERN.h"
	#include "perl.h"
	#include "XSUB.h"

	#include <stdio.h>

	int
	fputs(s, stream)
		char *          s
		FILE *	        stream

The real work is done in the standard typemap.

B<But> you loose all the fine stuff done by the perlio layers. This
calls the stdio function C<fputs()>, which knows nothing about them.

The standard typemap offers three variants of PerlIO *:
C<InputStream> (T_IN), C<InOutStream> (T_INOUT) and C<OutputStream>
(T_OUT). A bare C<PerlIO *> is considered a T_INOUT. If it matters
in your code (see below for why it might) #define or typedef
one of the specific names and use that as the argument or result
type in your XS file.

The standard typemap does not contain PerlIO * before perl 5.7,
but it has the three stream variants. Using a PerlIO * directly
is not backwards compatible unless you provide your own typemap.

For streams coming I<from> perl the main difference is that
C<OutputStream> will get the output PerlIO * - which may make
a difference on a socket. Like in our example...

For streams being handed I<to> perl a new file handle is created
(i.e. a reference to a new glob) and associated with the PerlIO *
provided. If the read/write state of the PerlIO * is not correct then you
may get errors or warnings from when the file handle is used.
So if you opened the PerlIO * as "w" it should really be an
C<OutputStream> if open as "r" it should be an C<InputStream>.

Now, suppose you want to use perlio layers in your XS. We'll use the
perlio C<PerlIO_puts()> function as an example.

In the C part of the XS file (above the first MODULE line) you
have

	#define OutputStream	PerlIO *
    or
	typedef PerlIO *	OutputStream;


And this is the XS code:

	int
	perlioputs(s, stream)
		char *          s
		OutputStream	stream
	CODE:
		RETVAL = PerlIO_puts(stream, s);
	OUTPUT:
		RETVAL

We have to use a C<CODE> section because C<PerlIO_puts()> has the arguments
reversed compared to C<fputs()>, and we want to keep the arguments the same.

Wanting to explore this thoroughly, we want to use the stdio C<fputs()>
on a PerlIO *. This means we have to ask the perlio system for a stdio
C<FILE *>:

	int
	perliofputs(s, stream)
		char *          s
		OutputStream	stream
	PREINIT:
		FILE *fp = PerlIO_findFILE(stream);
	CODE:
		if (fp != (FILE*) 0) {
			RETVAL = fputs(s, fp);
		} else {
			RETVAL = -1;
		}
	OUTPUT:
		RETVAL

Note: C<PerlIO_findFILE()> will search the layers for a stdio
layer. If it can't find one, it will call C<PerlIO_exportFILE()> to
generate a new stdio C<FILE>. Please only call C<PerlIO_exportFILE()> if
you want a I<new> C<FILE>. It will generate one on each call and push a
new stdio layer. So don't call it repeatedly on the same
file. C<PerlIO()>_findFILE will retrieve the stdio layer once it has been
generated by C<PerlIO_exportFILE()>.

This applies to the perlio system only. For versions before 5.7,
C<PerlIO_exportFILE()> is equivalent to C<PerlIO_findFILE()>.

=head2 Troubleshooting these Examples

As mentioned at the top of this document, if you are having problems with
these example extensions, you might see if any of these help you.

=over 4

=item *

In versions of 5.002 prior to the gamma version, the test script in Example
1 will not function properly.  You need to change the "use lib" line to
read:

	use lib './blib';

=item *

In versions of 5.002 prior to version 5.002b1h, the test.pl file was not
automatically created by h2xs.  This means that you cannot say "make test"
to run the test script.  You will need to add the following line before the
"use extension" statement:

	use lib './blib';

=item *

In versions 5.000 and 5.001, instead of using the above line, you will need
to use the following line:

	BEGIN { unshift(@@INC, "./blib") }

=item *

This document assumes that the executable named "perl" is Perl version 5.
Some systems may have installed Perl version 5 as "perl5".

=back

=head1 See also

For more information, consult L<perlguts>, L<perlapi>, L<perlxs>, L<perlmod>,
and L<perlpod>.

=head1 Author

Jeff Okamoto <F<okamoto@@corp.hp.com>>

Reviewed and assisted by Dean Roehrich, Ilya Zakharevich, Andreas Koenig,
and Tim Bunce.

PerlIO material contributed by Lupe Christoph, with some clarification
by Nick Ing-Simmons.

Changes for h2xs as of Perl 5.8.x by Renee Baecker

=head2 Last Changed

2007/10/11
@


1.14
log
@merge in perl 5.12.2 plus local changes
@
text
@@


1.13
log
@Merge in some local changes that got lost.
@
text
@d868 1
a868 1
will be passed to the C function -- it will be whatever is in the "last
@


1.12
log
@Merge in perl 5.10.1
@
text
@d3 1
a3 1
perlXStut - Tutorial for writing XSUBs
d255 1
a255 1
file Mytest.t.  This file is set up to imitate the same kind of testing
@


1.11
log
@Remove a couple more bogus man pages and add missing MLINKs.  The
makewhatis info for the perl man pages now matches the pages themselves.
@
text
@d3 1
a3 1
perlxstut - Tutorial for writing XSUBs
d93 2
a94 2
directory.  Several files will be created in the Mytest dir, including
MANIFEST, Makefile.PL, Mytest.pm, Mytest.xs, Mytest.t, and Changes.
d199 1
a199 1
explained in the section "The PROTOTYPES: Keyword" in L<perlxs>.
d255 1
a255 1
file t/Mytest.t.  This file is set up to imitate the same kind of testing
d431 1
a431 1
before after the OUTPUT: directive.  The use of RETVAL tells Perl that you
@


1.10
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d3 1
a3 1
perlXStut - Tutorial for writing XSUBs
@


1.9
log
@upgrade documentation so it reflects the way MakeMaker currently fills
the test framework.

okay millert@@
@
text
@d94 1
a94 1
MANIFEST, Makefile.PL, Mytest.pm, Mytest.xs, test.pl, and Changes.
d101 10
a110 10
	use ExtUtils::MakeMaker;
	# See lib/ExtUtils/MakeMaker.pm for details of how to influence
	# the contents of the Makefile that is written.
	WriteMakefile(
	    NAME         => 'Mytest',
	    VERSION_FROM => 'Mytest.pm', # finds $VERSION
	    LIBS         => [''],   # e.g., '-lm'
	    DEFINE       => '',     # e.g., '-DHAVE_SOMETHING'
	    INC          => '',     # e.g., '-I/usr/include/other'
	);
d114 7
a120 1
	package Mytest;
d122 2
a123 2
	use strict;
        use warnings;
d125 1
a125 2
	require Exporter;
	require DynaLoader;
d127 1
a127 5
	our @@ISA = qw(Exporter DynaLoader);
	# Items to export into callers namespace by default. Note: do not export
	# names by default without a very good reason. Use EXPORT_OK instead.
	# Do not simply export all your public functions/methods/constants.
	our @@EXPORT = qw(
d129 3
a131 2
	);
	our $VERSION = '0.01';
d133 1
a133 1
	bootstrap Mytest $VERSION;
d135 2
a136 1
	# Preloaded methods go here.
d138 1
a138 1
	# Autoload methods go after __END__, and are processed by the autosplit program.
d140 3
a142 3
	1;
	__END__
	# Below is the stub of documentation for your module. You better edit it!
d149 5
a153 3
	#include "EXTERN.h"
	#include "perl.h"
	#include "XSUB.h"
d155 1
a155 1
	MODULE = Mytest		PACKAGE = Mytest
d159 4
a162 4
	void
	hello()
	    CODE:
		printf("Hello, world!\n");
d171 5
a175 5
	% perl Makefile.PL
	Checking if your kit is complete...
	Looks good
	Writing Makefile for Mytest
	%
d181 16
a196 13
	% make
	umask 0 && cp Mytest.pm ./blib/Mytest.pm
	perl xsubpp -typemap typemap Mytest.xs >Mytest.tc && mv Mytest.tc Mytest.c
	Please specify prototyping behavior for Mytest.xs (see perlxs manual)
	cc -c Mytest.c
	Running Mkbootstrap for Mytest ()
	chmod 644 Mytest.bs
	LD_RUN_PATH="" ld -o ./blib/PA-RISC1.1/auto/Mytest/Mytest.sl -b Mytest.o
	chmod 755 ./blib/PA-RISC1.1/auto/Mytest/Mytest.sl
	cp Mytest.bs ./blib/PA-RISC1.1/auto/Mytest/Mytest.bs
	chmod 644 ./blib/PA-RISC1.1/auto/Mytest/Mytest.bs
	Manifying ./blib/man3/Mytest.3
	%
d213 1
a213 1
	#! /opt/perl5/bin/perl
d215 1
a215 1
	use ExtUtils::testlib;
d217 1
a217 1
	use Mytest;
d219 1
a219 1
	Mytest::hello();
d224 3
a226 3
	% ./hello
	Hello, world!
	%
d236 7
a242 7
	int
	is_even(input)
		int	input
	    CODE:
		RETVAL = (input % 2 == 0);
	    OUTPUT:
		RETVAL
d255 1
a255 1
file t/MyTest.t.  This file is set up to imitate the same kind of testing
d258 13
a270 9
when the test is correct, "not ok" when it is not.  Change the plan
statement for Test::More to read 
use Test::More tests => 4;
and add the following code
to the end of the file:

	ok(&Mytest::is_even(0) == 1);
	ok(&Mytest::is_even(1) == 0);
	ok(&Mytest::is_even(2) == 1);
d275 6
a280 6
	% make test
	PERL_DL_NONLAZY=1 /opt/perl5.004/bin/perl (lots of -I arguments) test.pl
	t/MyTest....ok
	All tests successful.
	Files=1, Tests=4,  0 wallclock secs ( 0.07 cusr +  0.03 csys =  0.10 CPU)
	%
d308 1
a308 1
using "C<make test>" insures that you will test your new extension, not the
d348 1
a348 1
The importance of writing good test scripts cannot be overemphasized.  You
d353 4
a356 5
By running "C<make test>", you ensure that your test.pl script runs and uses
the correct version of your extension.  If you have many test cases, you
might want to copy Perl's test style.  Create a directory named "t" in the
extension's directory and append the suffix ".t" to the names of your test
files.  When you run "C<make test>", all of these test files will be executed.
d383 2
a384 2
Generate the Makefile and run make.  Change the BEGIN block to print
"1..9" and add the following to test.pl:
d386 5
a390 5
	$i = -1.5; &Mytest::round($i); print $i == -2.0 ? "ok 5" : "not ok 5", "\n";
	$i = -1.1; &Mytest::round($i); print $i == -1.0 ? "ok 6" : "not ok 6", "\n";
	$i = 0.0; &Mytest::round($i); print $i == 0.0 ? "ok 7" : "not ok 7", "\n";
	$i = 0.5; &Mytest::round($i); print $i == 1.0 ? "ok 8" : "not ok 8", "\n";
	$i = 1.2; &Mytest::round($i); print $i == 1.0 ? "ok 9" : "not ok 9", "\n";
d396 1
a396 1
literal.  To see what happens, temporarily add the following line to test.pl:
d461 2
a462 1
		croak("Usage: Mytest::round(arg)");
d473 1
d475 1
a475 1
	    XSRETURN(1);
d627 1
a627 1
Now edit the test.pl script and change the BEGIN block to print "1..4",
d630 3
a632 3
	print &Mytest2::foo(1, 2, "Hello, world!") == 7 ? "ok 2\n" : "not ok 2\n";
	print &Mytest2::foo(1, 2, "0.0") == 7 ? "ok 3\n" : "not ok 3\n";
	print abs(&Mytest2::foo(0, 0, "-3.4") - 0.6) <= 0.01 ? "ok 4\n" : "not ok 4\n";
d638 2
a639 1
Run "C<make test>" and all should be well.
d695 1
a695 1
	MODULE = Mytest2		PACKAGE = Mytest2		
a988 2
			XPUSHs(sv_2mortal(newSVnv(buf.f_fsid[0])));
			XPUSHs(sv_2mortal(newSVnv(buf.f_fsid[1])));
d998 2
a999 2
Also add the following code segment to test.pl while incrementing the "1..9"
string in the BEGIN block to "1..11":
d1002 1
a1002 1
	print ((scalar(@@a) == 1 && $a[0] == 2) ? "ok 10\n" : "not ok 10\n");
d1004 1
a1004 1
	print scalar(@@a) == 9 ? "ok 11\n" : "not ok 11\n";
d1061 1
a1061 1
	EXTEND(SP, 9);
d1088 43
a1130 43
	SV *
	multi_statfs(paths)
		SV * paths
	    INIT:
        	AV * results;
        	I32 numpaths = 0;
        	int i, n;
        	struct statfs buf;

        	if ((!SvROK(paths))
		    || (SvTYPE(SvRV(paths)) != SVt_PVAV)
		    || ((numpaths = av_len((AV *)SvRV(paths))) < 0))
		{
		    XSRETURN_UNDEF;
        	}
        	results = (AV *)sv_2mortal((SV *)newAV());
	    CODE:
        	for (n = 0; n <= numpaths; n++) {
		    HV * rh;
            	    STRLEN l;
            	    char * fn = SvPV(*av_fetch((AV *)SvRV(paths), n, 0), l);

            	    i = statfs(fn, &buf);
            	    if (i != 0) {
		        av_push(results, newSVnv(errno));
		        continue;
            	    }

            	    rh = (HV *)sv_2mortal((SV *)newHV());

            	    hv_store(rh, "f_bavail", 8, newSVnv(buf.f_bavail), 0);
            	    hv_store(rh, "f_bfree",  7, newSVnv(buf.f_bfree),  0);
            	    hv_store(rh, "f_blocks", 8, newSVnv(buf.f_blocks), 0);
            	    hv_store(rh, "f_bsize",  7, newSVnv(buf.f_bsize),  0);
            	    hv_store(rh, "f_ffree",  7, newSVnv(buf.f_ffree),  0);
            	    hv_store(rh, "f_files",  7, newSVnv(buf.f_files),  0);
            	    hv_store(rh, "f_type",   6, newSVnv(buf.f_type),   0);

            	    av_push(results, newRV((SV *)rh));
        	}
        	RETVAL = newRV((SV *)results);
	    OUTPUT:
        	RETVAL
d1132 2
a1133 2
And add the following code to test.pl, while incrementing the "1..11"
string in the BEGIN block to "1..13":
d1136 2
a1137 2
	print ((ref $results->[0]) ? "ok 12\n" : "not ok 12\n");
	print ((! ref $results->[1]) ? "ok 13\n" : "not ok 13\n");
d1374 2
d1378 1
a1378 1
2002/05/08
@


1.8
log
@merge in perl 5.8.8
@
text
@d247 1
a247 1
file test.pl.  This file is set up to imitate the same kind of testing
d250 4
a253 2
when the test is correct, "not ok" when it is not.  Change the print
statement in the BEGIN block to print "1..4", and add the following code
d256 3
a258 3
	print &Mytest::is_even(0) == 1 ? "ok 2" : "not ok 2", "\n";
	print &Mytest::is_even(1) == 0 ? "ok 3" : "not ok 3", "\n";
	print &Mytest::is_even(2) == 1 ? "ok 4" : "not ok 4", "\n";
d265 3
a267 5
	1..4
	ok 1
	ok 2
	ok 3
	ok 4
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d236 1
a236 1
There does not need to be white space at the start of the "C<int input>"
d238 1
a238 1
the end of that line is also optional.  Any amount and kind of white space
d416 1
a416 1
line starts with optional white space, and may have an optional terminating
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d213 1
a213 1
Now we make the script executable (C<chmod -x hello>), run the script
d695 1
a695 1
function, the another time in the second part, when an XSUB interface to
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d523 1
a523 1
	    clean  => {'FILES' => 'libmylib$(LIBEEXT)'},
d801 1
a801 1
the calling convention for the argument in the call to the library function.  
d918 3
a920 3
and the embedded documentation will be converted to the man page format,
then placed in the blib directory.  It will be copied to Perl's man
page directory when the extension is installed.
d931 1
a931 1
is quite simple: you simply run "make install".  You will either need 
d1120 1
a1120 1
And add the following code to test.pl, while incrementing the "1..11" 
d1189 1
a1189 1
need to be be cast to the appropriate type if it is something other than a
d1207 1
a1207 1
=head2 EXAMPLE 9 (Coming Soon)
d1209 99
a1307 1
Getting fd's from filehandles
d1342 1
a1342 1
This document assumes that the executable named "perl" is Perl version 5.  
d1359 3
d1364 1
a1364 1
1999/11/30
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d8 2
a9 2
a Perl extension.  The reader is assumed to have access to L<perlguts> and
L<perlxs>.
d190 2
a191 1
You can safely ignore the line about "prototyping behavior".
d480 1
a480 1
example).  However, in order to better accomodate calling pre-existing C
d685 2
a686 1
performed on this part, it goes into the generated output C file as is.
d1061 1
a1061 1
=head2 EXAMPLE 6 (Coming Soon)
d1063 135
a1197 1
Passing in and returning references to arrays and/or hashes
d1251 1
a1251 1
For more information, consult L<perlguts>, L<perlxs>, L<perlmod>,
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
perlXStut - Tutorial for XSUBs
d13 2
a14 2
completely explained until later in the tutorial to ease the
reader slowly into building extensions.
d16 42
a57 1
=head2 VERSION CAVEAT
d59 1
a59 46
This tutorial tries hard to keep up with the latest development versions
of Perl.  This often means that it is sometimes in advance of the latest
released version of Perl, and that certain features described here might
not work on earlier versions.  This section will keep track of when various
features were added to Perl 5.

=over 4

=item *

In versions of Perl 5.002 prior to the gamma version, the test script
in Example 1 will not function properly.  You need to change the "use
lib" line to read:

	use lib './blib';

=item *

In versions of Perl 5.002 prior to version beta 3, the line in the .xs file
about "PROTOTYPES: DISABLE" will cause a compiler error.  Simply remove that
line from the file.

=item *

In versions of Perl 5.002 prior to version 5.002b1h, the test.pl file was not
automatically created by h2xs.  This means that you cannot say "make test"
to run the test script.  You will need to add the following line before the
"use extension" statement:

	use lib './blib';

=item *

In versions 5.000 and 5.001, instead of using the above line, you will need
to use the following line:

	BEGIN { unshift(@@INC, "./blib") }

=item *

This document assumes that the executable named "perl" is Perl version 5.
Some systems may have installed Perl version 5 as "perl5".

=back

=head2 DYNAMIC VERSUS STATIC
d62 2
a63 2
load a library dynamically, you cannot build XSUBs.  This is incorrect.
You I<can> build them, but you must link the XSUB's subroutines with the
d74 2
a75 2
where the command "make" with no arguments is executed, run the command
"make perl" instead.
d78 7
a84 3
instead of saying "make test", you should say "make test_static".  On systems
that cannot build dynamically-loadable libraries at all, simply saying "make
test" is sufficient.
d91 4
a94 4
Run C<h2xs -A -n Mytest>.  This creates a directory named Mytest, possibly under
ext/ if that directory exists in the current working directory.  Several files
will be created in the Mytest dir, including MANIFEST, Makefile.PL, Mytest.pm,
Mytest.xs, test.pl, and Changes.
d96 2
a97 1
The MANIFEST file contains the names of all the files created.
d105 5
a109 5
	    'NAME'      => 'Mytest',
	    'VERSION_FROM' => 'Mytest.pm', # finds $VERSION
	    'LIBS'      => [''],   # e.g., '-lm'
	    'DEFINE'    => '',     # e.g., '-DHAVE_SOMETHING'
	    'INC'       => '',     # e.g., '-I/usr/include/other'
d116 3
d122 1
a122 1
	@@ISA = qw(Exporter DynaLoader);
d126 1
a126 1
	@@EXPORT = qw(
d129 1
a129 1
	$VERSION = '0.01';
d141 4
a144 1
And the Mytest.xs file should look something like this:
a145 3
	#ifdef __cplusplus
	extern "C" {
	#endif
a148 5
	#ifdef __cplusplus
	}
	#endif

	PROTOTYPES: DISABLE
d156 1
a156 1
		CODE:
d159 5
a163 1
Now we'll run "perl Makefile.PL".  This will create a real Makefile,
d172 3
a174 2
Now, running make will produce output that looks something like this
(some long lines shortened for clarity):
d179 1
d187 12
d200 2
a201 2
Now, although there is already a test.pl template ready for us, for this
example only, we'll create a special test script.  Create a file called hello
d212 2
a213 1
Now we run the script and we should see the following output:
d215 1
a215 1
	% perl hello
d221 3
a223 2
Now let's add to our extension a subroutine that will take a single argument
and return 1 if the argument is even, 0 if the argument is odd.
d230 1
a230 1
		CODE:
d232 1
a232 1
		OUTPUT:
d235 4
a238 8
There does not need to be white space at the start of the "int input" line,
but it is useful for improving readability.  The semi-colon at the end of
that line is also optional.

Any white space may be between the "int" and "input".  It is also okay for
the four lines starting at the "CODE:" line to not be indented.  However,
for readability purposes, it is suggested that you indent them 8 spaces
(or one normal tab stop).
d240 1
a240 1
Now rerun make to rebuild our new shared library.
d245 1
a245 1
To test that our extension works, we now need to look at the
d257 1
a257 1
We will be calling the test script through the command "make test".  You
d261 1
a261 1
	PERL_DL_NONLAZY=1 /opt/perl5.002b2/bin/perl (lots of -I arguments) test.pl
d269 1
a269 1
=head2 WHAT HAS GONE ON?
d279 18
a296 22
The files E<lt>extensionE<gt>.pm and E<lt>extensionE<gt>.xs contain the meat
of the extension.
The .xs file holds the C routines that make up the extension.  The .pm file
contains routines that tell Perl how to load your extension.

Generating and invoking the Makefile created a directory blib (which stands
for "build library") in the current working directory.  This directory will
contain the shared library that we will build.  Once we have tested it, we
can install it into its final location.

Invoking the test script via "make test" did something very important.  It
invoked perl with all those C<-I> arguments so that it could find the various
files that are part of the extension.

It is I<very> important that while you are still testing extensions that
you use "make test".  If you try to run the test script all by itself, you
will get a fatal error.

Another reason it is important to use "make test" to run your test script
is that if you are testing an upgrade to an already-existing version, using
"make test" insures that you use your new extension, not the already-existing
version.
d299 1
a299 1
as the use'd extension that has a .pm suffix.  If that file cannot be found,
d301 1
a301 1
@@INC array.
d304 4
a307 3
Loader extensions.  It then sets the @@ISA and @@EXPORT arrays and the $VERSION
scalar; finally it tells perl to bootstrap the module.  Perl will call its
dynamic loader routine (if there is one) and load the shared library.
d309 1
a309 1
The two arrays that are set in the .pm file are very important.  The @@ISA
d311 9
a319 6
subroutines) that do not exist in the current package.  The @@EXPORT array
tells Perl which of the extension's routines should be placed into the
calling package's namespace.

It's important to select what to export carefully.  Do NOT export method names
and do NOT export anything else I<by default> without a good reason.
d322 4
a325 2
export anything.  If it's just a collection of functions then you can export
any of the functions via another array, called @@EXPORT_OK.
d329 1
a329 1
The $VERSION variable is used to ensure that the .pm file and the shared
d333 1
a333 1
=head2 WRITING GOOD TEST SCRIPTS
d340 1
a340 1
By running "make test", you ensure that your test.pl script runs and uses
d342 3
a344 4
might want to copy Perl's test style.  Create a directory named "t", and
ensure all your test files end with the suffix ".t".  The Makefile will
properly run all these test files.

d356 1
a356 1
		CODE:
d364 1
a364 1
		OUTPUT:
d371 1
a371 1
Generate the Makefile and run make.  Change the BEGIN block to print out
d380 1
a380 1
Running "make test" should now print out that all nine tests are okay.
d382 3
a384 2
You might be wondering if you can round a constant.  To see what happens, add
the following line to test.pl temporarily:
d388 2
a389 2
Run "make test" and notice that Perl dies with a fatal error.  Perl won't let
you change the value of constants!
d391 1
a391 1
=head2 WHAT'S NEW HERE?
d393 10
a402 4
Two things are new here.  First, we've made some changes to Makefile.PL.
In this case, we've specified an extra library to link in, the math library
libm.  We'll talk later about how to write XSUBs that can call every routine
in a library.
d404 4
a407 2
Second, the value of the function is being passed back not as the function's
return value, but through the same variable that was passed into the function.
d409 1
a409 1
=head2 INPUT AND OUTPUT PARAMETERS
d411 1
a411 3
You specify the parameters that will be passed into the XSUB just after you
declare the function return value and name.  Each parameter line starts with
optional white space, and may have an optional terminating semicolon.
d413 10
a422 5
The list of output parameters occurs after the OUTPUT: directive.  The use
of RETVAL tells Perl that you wish to send this value back as the return
value of the XSUB function.  In Example 3, the value we wanted returned was
contained in the same variable we passed in, so we listed it (and not RETVAL)
in the OUTPUT: section.
d424 1
a424 1
=head2 THE XSUBPP COMPILER
d426 1
a426 1
The compiler xsubpp takes the XS code in the .xs file and converts it into
d430 1
a430 1
=head2 THE TYPEMAP FILE
d432 2
a433 2
The xsubpp compiler uses rules to convert from Perl's data types (scalar,
array, etc.) to C's data types (int, char *, etc.).  These rules are stored
d437 4
a440 5
The first part attempts to map various C data types to a coded flag, which
has some correspondence with the various Perl types.  The second part contains
C code which xsubpp uses for input parameters.  The third part contains C
code which xsubpp uses for output parameters.  We'll talk more about the
C code later.
d442 2
a443 1
Let's now take a look at a portion of the .c file created for our extension.
d459 1
a459 1
		sv_setnv(ST(0), (double)arg);		/* XXXXX */
d464 2
a465 2
Notice the two lines marked with "XXXXX".  If you check the first section of
the typemap file, you'll see that doubles are of type T_DOUBLE.  In the
d474 1
a474 1
=head2 WARNING
d477 5
a481 3
parameters, as in Example 3.  However, to accommodate better calling
pre-existing C routines, which often do modify their input parameters,
this behavior is tolerated.  The next example will show how to do this.
d486 1
a486 1
predefined C libraries.  To begin with, we will build a small library of
d510 1
a510 4
	foo(a, b, c)
	int		a;
	long		b;
	const char *	c;
d520 3
a522 3
	    NAME      => 'Mytest2::mylib',
	    SKIP      => [qw(all static static_lib dynamic dynamic_lib)],
	    clean     => {'FILES' => 'libmylib$(LIB_EXT)'},
d530 2
d541 5
d556 2
a557 2
will be generating a library in it.  Let's add the following key-value
pair to the WriteMakefile call:
d559 8
a566 1
	'MYEXTLIB' => 'mylib/libmylib$(LIB_EXT)',
d568 3
a570 1
and a new replacement subroutine too:
d575 1
a575 1
		cd mylib && $(MAKE) $(PASTHRU)
a578 4
(Note: Most makes will require that there be a tab character that indents
the line C<cd mylib && $(MAKE) $(PASTHRU)>, similarly for the Makefile in the
subdirectory.)

d588 1
a588 2
the lines setting @@EXPORT to @@EXPORT_OK (there are two: one in the line
beginning "use vars" and one setting the array itself).  Finally, in the
d600 1
a600 1
		OUTPUT:
d604 2
a605 2
currently support the const char * type.  Create a file called typemap and
place the following in it:
d610 1
a610 1
Makefile in the mylib directory.  Run make and see that it does cd into
d620 3
a622 3
(When dealing with floating-point comparisons, it is often useful not to check
for equality, but rather the difference being below a certain epsilon factor,
0.01 in this case)
d624 1
a624 1
Run "make test" and all should be well.
d626 1
a626 1
=head2 WHAT HAS HAPPENED HERE?
d635 3
a637 2
In the .xs file, there's now a #include declaration with the full path to
the mylib.h header file.
d643 2
a644 2
header file available to the Perl script (in this case, by calling
C<&main::TESTVAL>).  There's also some XS code to allow calls to the
d649 6
a654 6
The .pm file has exported the name TESTVAL in the @@EXPORT array.  This
could lead to name clashes.  A good rule of thumb is that if the #define
is going to be used by only the C routines themselves, and not by the user,
they should be removed from the @@EXPORT array.  Alternately, if you don't
mind using the "fully qualified name" of a variable, you could remove most
or all of the items in the @@EXPORT array.
d658 2
a659 2
If our include file contained #include directives, these would not be
processed at all by h2xs.  There is no good solution to this right now.
d661 1
a661 1
=back
d664 1
a664 1
subdirectory.  That required the addition of only the MYEXTLIB variable
d669 2
a670 2
specified simply that the library to be created here was a static
archive (as opposed to a dynamically loadable library) and provided the
d673 115
a787 1
=head2 SPECIFYING ARGUMENTS TO XSUBPP
d792 26
a817 1
xsubpp compiler.
d819 7
a825 9
When you specify arguments in the .xs file, you are really passing three
pieces of information for each one listed.  The first piece is the order
of that argument relative to the others (first, second, etc).  The second
is the type of argument, and consists of the type declaration of the
argument (e.g., int, char*, etc).  The third piece is the exact way in
which the argument should be used in the call to the library function
from this XSUB.  This would mean whether or not to place a "&" before
the argument or not, meaning the argument expects to be passed the address
of the specified data type.
d827 1
a827 1
There is a difference between the two arguments in this hypothetical function:
d834 1
a834 1
The first argument to this function would be treated as a char and assigned
d836 1
a836 1
The second argument would be treated as a string pointer and assigned to the
d838 1
a838 1
actual call to the function foo that xsubpp generates would look like this:
d842 1
a842 1
Xsubpp will identically parse the following function argument lists:
d851 3
a853 3
complete example above).  By doing so, it is easy to understand exactly
what will be passed to the C function -- it will be whatever is in the
"last column".
d858 1
a858 1
=head2 THE ARGUMENT STACK
d862 4
a865 3
usually 0.  The "ST" is actually a macro that points to the n'th argument
on the argument stack.  ST(0) is thus the first argument passed to the
XSUB, ST(1) is the second argument, and so on.
d867 1
a867 1
When you list the arguments to the XSUB in the .xs file, that tells xsubpp
d872 31
a902 1
=head2 EXTENDING YOUR EXTENSION
d908 3
a910 2
or loaded only when called depends on where in the .pm file the subroutine
definition is placed.
d912 1
a912 1
=head2 DOCUMENTING YOUR EXTENSION
d916 1
a916 1
and the embedded documentation will be converted to the manpage format,
d926 1
a926 1
=head2 INSTALLING YOUR EXTENSION
d929 1
a929 1
is quite simple: you simply run "make install".  You will either need
d933 181
a1113 1
=head2 SEE ALSO
d1118 1
a1118 1
=head2 Author
d1127 1
a1127 1
1996/7/10
@


1.2
log
@perl 5.004_04
@
text
@d431 1
a431 1
		sv_setnv(ST(0), (double)arg);	/* XXXXX */
d468 1
a468 1
In the testlib directory, create a file mylib.h that looks like this:
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
perlXStut - Tutorial for XSUB's
d13 2
a14 2
completely explained until later in the tutorial in order to slowly ease
the reader into building extensions.
d28 9
a36 1
In versions of 5.002 prior to version beta 3, then the line in the .xs file
d42 1
a42 1
In versions of 5.002 prior to version 5.002b1h, the test.pl file was not
d58 1
a58 1
This document assumes that the executable named "perl" is Perl version 5.  
d66 1
a66 1
dynamically load a library, you cannot build XSUB's.  This is incorrect.
d91 1
a91 1
Run "h2xs -A -n Mytest".  This creates a directory named Mytest, possibly under
d148 1
a148 1
	
d161 1
a161 1
which make needs.  It's output looks something like:
d188 3
a190 3
	
	use lib './blib';
	
d192 1
a192 1
	
d204 1
a204 1
and return 0 if the argument is even, 1 if the argument is odd.
d225 1
a225 1
Now re-run make to rebuild our new shared library.
d230 1
a230 1
In order to test that our extension works, we now need to look at the
d234 3
a236 5
when the test is correct, "not ok" when it is not.

Remove the line that starts with "use lib", change the print statement in
the BEGIN block to print "1..4", and add the following code to the end of
the file:
d264 2
a265 1
The files <extension>.pm and <extension>.xs contain the meat of the extension.
d275 1
a275 1
invoked perl with all those -I arguments so that it could find the various
d377 3
a379 3
In this case, we've specified an extra library to link in, in this case the
math library, libm.  We'll talk later about how to write XSUBs that can call
every routine in a library.
d449 1
a449 1
parameters, as in Example 3.  However, in order to better accomodate calling
d451 1
a451 1
this behavior is tolerated.
d455 2
a456 2
In this example, we'll now begin to write XSUB's that will interact with
pre-defined C libraries.  To begin with, we will build a small library of
d478 1
a478 1
	
d493 3
a495 2
	    'NAME' => 'Mytest2::mylib',
	    'clean'     => {'FILES' => 'libmylib.a'},
d499 1
a499 1
	sub MY::postamble {
d515 1
a515 1
	% h2xs -O -n Mytest2 < ./Mytest2/mylib/mylib.h
d532 1
a532 1
		cd mylib && $(MAKE)
d537 2
a538 1
the line "cd mylib && $(MAKE)".)
d549 3
a551 2
the line setting @@EXPORT to @@EXPORT_OK.  And finally, in the .xs file,
edit the #include line to read:
d582 1
a582 1
(When dealing with floating-point comparisons, it is often useful to not check
d588 1
a588 1
=head 2 WHAT HAS HAPPENED HERE?
d593 2
d612 1
a612 1
is only going to be used by the C routines themselves, and not by the user,
d617 5
d625 1
a625 1
subdirectory.  That required only the addition of the MYEXTLIB variable
d630 1
a630 1
simply specified that the library to be created here was a static
d690 1
a690 1
When you list the arguments to the XSUB in the .xs file, that tell xsubpp
d701 1
a701 1
or only loaded when called depends on where in the .pm file the subroutine
d708 1
a708 1
and the embedded documentation will be converted to the man page format,
d721 1
a721 1
is quite simple: you simply run "make install".  You will either need 
d732 1
a732 1
Jeff Okamoto <okamoto@@corp.hp.com>
d739 1
a739 1
1996/2/9
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 1
perlXStut - Tutorial for XSUBs
d13 2
a14 2
completely explained until later in the tutorial to ease the
reader slowly into building extensions.
d28 1
a28 9
In versions of Perl 5.002 prior to the gamma version, the test script
in Example 1 will not function properly.  You need to change the "use
lib" line to read:

	use lib './blib';

=item *

In versions of Perl 5.002 prior to version beta 3, the line in the .xs file
d34 1
a34 1
In versions of Perl 5.002 prior to version 5.002b1h, the test.pl file was not
d50 1
a50 1
This document assumes that the executable named "perl" is Perl version 5.
d58 1
a58 1
load a library dynamically, you cannot build XSUBs.  This is incorrect.
d83 1
a83 1
Run C<h2xs -A -n Mytest>.  This creates a directory named Mytest, possibly under
d140 1
a140 1

d153 1
a153 1
which make needs.  Its output looks something like:
d180 3
a182 3

	use ExtUtils::testlib;

d184 1
a184 1

d196 1
a196 1
and return 1 if the argument is even, 0 if the argument is odd.
d217 1
a217 1
Now rerun make to rebuild our new shared library.
d222 1
a222 1
To test that our extension works, we now need to look at the
d226 5
a230 3
when the test is correct, "not ok" when it is not.  Change the print
statement in the BEGIN block to print "1..4", and add the following code
to the end of the file:
d258 1
a258 2
The files E<lt>extensionE<gt>.pm and E<lt>extensionE<gt>.xs contain the meat
of the extension.
d268 1
a268 1
invoked perl with all those C<-I> arguments so that it could find the various
d370 3
a372 3
In this case, we've specified an extra library to link in, the math library
libm.  We'll talk later about how to write XSUBs that can call every routine
in a library.
d424 1
a424 1
		sv_setnv(ST(0), (double)arg);		/* XXXXX */
d442 1
a442 1
parameters, as in Example 3.  However, to accommodate better calling
d444 1
a444 1
this behavior is tolerated.  The next example will show how to do this.
d448 2
a449 2
In this example, we'll now begin to write XSUBs that will interact with
predefined C libraries.  To begin with, we will build a small library of
d461 1
a461 1
In the mylib directory, create a file mylib.h that looks like this:
d471 1
a471 1

d486 2
a487 3
	    NAME      => 'Mytest2::mylib',
	    SKIP      => [qw(all static static_lib dynamic dynamic_lib)],
	    clean     => {'FILES' => 'libmylib$(LIB_EXT)'},
d491 1
a491 1
	sub MY::top_targets {
d507 1
a507 1
	% h2xs -O -n Mytest2 ./Mytest2/mylib/mylib.h
d524 1
a524 1
		cd mylib && $(MAKE) $(PASTHRU)
d529 1
a529 2
the line C<cd mylib && $(MAKE) $(PASTHRU)>, similarly for the Makefile in the
subdirectory.)
d540 2
a541 3
the lines setting @@EXPORT to @@EXPORT_OK (there are two: one in the line
beginning "use vars" and one setting the array itself).  Finally, in the
.xs file, edit the #include line to read:
d572 1
a572 1
(When dealing with floating-point comparisons, it is often useful not to check
d578 1
a578 1
=head2 WHAT HAS HAPPENED HERE?
a582 2
=over 4

d600 1
a600 1
is going to be used by only the C routines themselves, and not by the user,
a604 5
=item *

If our include file contained #include directives, these would not be
processed at all by h2xs.  There is no good solution to this right now.

d608 1
a608 1
subdirectory.  That required the addition of only the MYEXTLIB variable
d613 1
a613 1
specified simply that the library to be created here was a static
d673 1
a673 1
When you list the arguments to the XSUB in the .xs file, that tells xsubpp
d684 1
a684 1
or loaded only when called depends on where in the .pm file the subroutine
d691 1
a691 1
and the embedded documentation will be converted to the manpage format,
d704 1
a704 1
is quite simple: you simply run "make install".  You will either need
d715 1
a715 1
Jeff Okamoto <F<okamoto@@corp.hp.com>>
d722 1
a722 1
1996/7/10
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
perlXStut - Tutorial for writing XSUBs
d13 2
a14 2
completely explained until later in the tutorial in order to slowly ease
the reader into building extensions.
d16 1
a16 42
This tutorial was written from a Unix point of view.  Where I know them
to be otherwise different for other platforms (e.g. Win32), I will list
them.  If you find something that was missed, please let me know.

=head1 SPECIAL NOTES

=head2 make

This tutorial assumes that the make program that Perl is configured to
use is called C<make>.  Instead of running "make" in the examples that
follow, you may have to substitute whatever make program Perl has been
configured to use.  Running B<perl -V:make> should tell you what it is.

=head2 Version caveat

When writing a Perl extension for general consumption, one should expect that
the extension will be used with versions of Perl different from the
version available on your machine.  Since you are reading this document,
the version of Perl on your machine is probably 5.005 or later, but the users
of your extension may have more ancient versions.

To understand what kinds of incompatibilities one may expect, and in the rare
case that the version of Perl on your machine is older than this document,
see the section on "Troubleshooting these Examples" for more information.

If your extension uses some features of Perl which are not available on older
releases of Perl, your users would appreciate an early meaningful warning.
You would probably put this information into the F<README> file, but nowadays
installation of extensions may be performed automatically, guided by F<CPAN.pm>
module or other tools.

In MakeMaker-based installations, F<Makefile.PL> provides the earliest
opportunity to perform version checks.  One can put something like this
in F<Makefile.PL> for this purpose:

    eval { require 5.007 }
        or die <<EOD;
    ############
    ### This module uses frobnication framework which is not available before
    ### version 5.007 of Perl.  Upgrade your Perl before installing Kara::Mba.
    ############
    EOD
d18 46
a63 1
=head2 Dynamic Loading versus Static Loading
d66 2
a67 2
dynamically load a library, you cannot build XSUBs.  This is incorrect.
You I<can> build them, but you must link the XSUBs subroutines with the
d78 2
a79 2
where the command "C<make>" with no arguments is executed, run the command
"C<make perl>" instead.
d82 3
a84 7
instead of saying "C<make test>", you should say "C<make test_static>".
On systems that cannot build dynamically-loadable libraries at all, simply
saying "C<make test>" is sufficient.

=head1 TUTORIAL

Now let's go on with the show!
d91 4
a94 4
Run "C<h2xs -A -n Mytest>".  This creates a directory named Mytest,
possibly under ext/ if that directory exists in the current working
directory.  Several files will be created in the Mytest dir, including
MANIFEST, Makefile.PL, Mytest.pm, Mytest.xs, test.pl, and Changes.
d96 1
a96 2
The MANIFEST file contains the names of all the files just created in the
Mytest directory.
d104 5
a108 5
	    NAME         => 'Mytest',
	    VERSION_FROM => 'Mytest.pm', # finds $VERSION
	    LIBS         => [''],   # e.g., '-lm'
	    DEFINE       => '',     # e.g., '-DHAVE_SOMETHING'
	    INC          => '',     # e.g., '-I/usr/include/other'
a114 3
	use strict;
        use warnings;

d118 1
a118 1
	our @@ISA = qw(Exporter DynaLoader);
d122 1
a122 1
	our @@EXPORT = qw(
d125 1
a125 1
	our $VERSION = '0.01';
d137 1
a137 4
The rest of the .pm file contains sample code for providing documentation for
the extension.

Finally, the Mytest.xs file should look something like this:
d139 3
d145 5
d157 1
a157 1
	    CODE:
d160 1
a160 5
It is okay for the lines starting at the "CODE:" line to not be indented.
However, for readability purposes, it is suggested that you indent CODE:
one level and the lines following one more level.

Now we'll run "C<perl Makefile.PL>".  This will create a real Makefile,
d169 2
a170 3
Now, running make will produce output that looks something like this (some
long lines have been shortened for clarity and some extraneous lines have
been deleted):
a174 1
	Please specify prototyping behavior for Mytest.xs (see perlxs manual)
a181 12
	Manifying ./blib/man3/Mytest.3
	%

You can safely ignore the line about "prototyping behavior".

If you are on a Win32 system, and the build process fails with linker
errors for functions in the C library, check if your Perl is configured
to use PerlCRT (running B<perl -V:libc> should show you if this is the
case).  If Perl is configured to use PerlCRT, you have to make sure
PerlCRT.lib is copied to the same location that msvcrt.lib lives in,
so that the compiler can find it on its own.  msvcrt.lib is usually
found in the Visual C compiler's lib directory (e.g. C:/DevStudio/VC/lib).
d183 2
a184 2
Perl has its own special way of easily writing test scripts, but for this
example only, we'll create our own test script.  Create a file called hello
d195 1
a195 2
Now we make the script executable (C<chmod -x hello>), run the script
and we should see the following output:
d197 1
a197 1
	% ./hello
d203 2
a204 3
Now let's add to our extension a subroutine that will take a single numeric
argument as input and return 0 if the number is even or 1 if the number
is odd.
d211 1
a211 1
	    CODE:
d213 1
a213 1
	    OUTPUT:
d216 8
a223 4
There does not need to be white space at the start of the "C<int input>"
line, but it is useful for improving readability.  Placing a semi-colon at
the end of that line is also optional.  Any amount and kind of white space
may be placed between the "C<int>" and "C<input>".
d225 1
a225 1
Now re-run make to rebuild our new shared library.
d230 1
a230 1
In order to test that our extension works, we now need to look at the
d242 1
a242 1
We will be calling the test script through the command "C<make test>".  You
d246 1
a246 1
	PERL_DL_NONLAZY=1 /opt/perl5.004/bin/perl (lots of -I arguments) test.pl
d254 1
a254 1
=head2 What has gone on?
d264 22
a285 18
The .pm and .xs files contain the meat of the extension.  The .xs file holds
the C routines that make up the extension.  The .pm file contains routines
that tell Perl how to load your extension.

Generating the Makefile and running C<make> created a directory called blib
(which stands for "build library") in the current working directory.  This
directory will contain the shared library that we will build.  Once we have
tested it, we can install it into its final location.

Invoking the test script via "C<make test>" did something very important.
It invoked perl with all those C<-I> arguments so that it could find the
various files that are part of the extension.  It is I<very> important that
while you are still testing extensions that you use "C<make test>".  If you
try to run the test script all by itself, you will get a fatal error.
Another reason it is important to use "C<make test>" to run your test
script is that if you are testing an upgrade to an already-existing version,
using "C<make test>" insures that you will test your new extension, not the
already-existing version.
d288 1
a288 1
as the C<use>'d extension that has a .pm suffix.  If that file cannot be found,
d290 1
a290 1
C<@@INC> array.
d293 3
a295 4
Loader extensions.  It then sets the C<@@ISA> and C<@@EXPORT> arrays and the
C<$VERSION> scalar; finally it tells perl to bootstrap the module.  Perl
will call its dynamic loader routine (if there is one) and load the shared
library.
d297 1
a297 1
The two arrays C<@@ISA> and C<@@EXPORT> are very important.  The C<@@ISA>
d299 6
a304 9
subroutines) that do not exist in the current package.  This is usually
only important for object-oriented extensions (which we will talk about
much later), and so usually doesn't need to be modified.

The C<@@EXPORT> array tells Perl which of the extension's variables and
subroutines should be placed into the calling package's namespace.  Because
you don't know if the user has already used your variable and subroutine
names, it's vitally important to carefully select what to export.  Do I<not>
export method or variable names I<by default> without a good reason.
d307 2
a308 4
export anything.  If it's just a collection of functions and variables, then
you can export them via another array, called C<@@EXPORT_OK>.  This array
does not automatically place its subroutine and variable names into the
namespace unless the user specifically requests that this be done.
d312 1
a312 1
The C<$VERSION> variable is used to ensure that the .pm file and the shared
d316 1
a316 1
=head2 Writing good test scripts
d323 1
a323 1
By running "C<make test>", you ensure that your test.pl script runs and uses
d325 4
a328 3
might want to copy Perl's test style.  Create a directory named "t" in the
extension's directory and append the suffix ".t" to the names of your test
files.  When you run "C<make test>", all of these test files will be executed.
d340 1
a340 1
	    CODE:
d348 1
a348 1
	    OUTPUT:
d355 1
a355 1
Generate the Makefile and run make.  Change the BEGIN block to print
d364 1
a364 1
Running "C<make test>" should now print out that all nine tests are okay.
d366 2
a367 3
Notice that in these new test cases, the argument passed to round was a
scalar variable.  You might be wondering if you can round a constant or
literal.  To see what happens, temporarily add the following line to test.pl:
d371 2
a372 2
Run "C<make test>" and notice that Perl dies with a fatal error.  Perl won't
let you change the value of constants!
d374 1
a374 1
=head2 What's new here?
d376 4
a379 10
=over 4

=item *

We've made some changes to Makefile.PL.  In this case, we've specified an
extra library to be linked into the extension's shared library, the math
library libm in this case.  We'll talk later about how to write XSUBs that
can call every routine in a library.

=item *
d381 2
a382 4
The value of the function is not being passed back as the function's return
value, but by changing the value of the variable that was passed into the
function.  You might have guessed that when you saw that the return value
of round is of type "void".
d384 1
a384 1
=back
d386 3
a388 1
=head2 Input and Output Parameters
d390 5
a394 10
You specify the parameters that will be passed into the XSUB on the line(s)
after you declare the function's return value and name.  Each input parameter
line starts with optional white space, and may have an optional terminating
semicolon.

The list of output parameters occurs at the very end of the function, just
before after the OUTPUT: directive.  The use of RETVAL tells Perl that you
wish to send this value back as the return value of the XSUB function.  In
Example 3, we wanted the "return value" placed in the original variable
which we passed in, so we listed it (and not RETVAL) in the OUTPUT: section.
d396 1
a396 1
=head2 The XSUBPP Program
d398 1
a398 1
The B<xsubpp> program takes the XS code in the .xs file and translates it into
d402 1
a402 1
=head2 The TYPEMAP file
d404 2
a405 2
The B<xsubpp> program uses rules to convert from Perl's data types (scalar,
array, etc.) to C's data types (int, char, etc.).  These rules are stored
d409 5
a413 4
The first section maps various C data types to a name, which corresponds
somewhat with the various Perl types.  The second section contains C code
which B<xsubpp> uses to handle input parameters.  The third section contains
C code which B<xsubpp> uses to handle output parameters.
d415 1
a415 2
Let's take a look at a portion of the .c file created for our extension.
The file name is Mytest.c:
d431 1
a431 1
		sv_setnv(ST(0), (double)arg);	/* XXXXX */
d436 2
a437 2
Notice the two lines commented with "XXXXX".  If you check the first section
of the typemap file, you'll see that doubles are of type T_DOUBLE.  In the
d446 1
a446 1
=head2 Warning about Output Arguments
d449 3
a451 5
parameters, as in Example 3.  Instead, you should probably return multiple
values in an array and let the caller handle them (we'll do this in a later
example).  However, in order to better accomodate calling pre-existing C
routines, which often do modify their input parameters, this behavior is
tolerated.
d456 1
a456 1
pre-defined C libraries.  To begin with, we will build a small library of
d480 4
a483 1
	foo(int a, long b, const char *c)
d493 3
a495 3
	    NAME   => 'Mytest2::mylib',
	    SKIP   => [qw(all static static_lib dynamic dynamic_lib)],
	    clean  => {'FILES' => 'libmylib$(LIBEEXT)'},
a502 2
	pure_all :: static

a511 5
Make sure you use a tab and not spaces on the lines beginning with "$(AR)"
and "$(RANLIB)".  Make will not function properly if you use spaces.
It has also been reported that the "cr" argument to $(AR) is unnecessary
on Win32 systems.

d522 2
a523 2
will be generating a library in it.  Let's add the argument MYEXTLIB to
the WriteMakefile call so that it looks like this:
d525 1
a525 8
	WriteMakefile(
	    'NAME'      => 'Mytest2',
	    'VERSION_FROM' => 'Mytest2.pm', # finds $VERSION
	    'LIBS'      => [''],   # e.g., '-lm'
	    'DEFINE'    => '',     # e.g., '-DHAVE_SOMETHING'
	    'INC'       => '',     # e.g., '-I/usr/include/other'
	    'MYEXTLIB' => 'mylib/libmylib$(LIB_EXT)',
	);
d527 1
a527 3
and then at the end add a subroutine (which will override the pre-existing
subroutine).  Remember to use a tab character to indent the line beginning
with "cd"!
d532 1
a532 1
		cd mylib && $(MAKE) $(PASSTHRU)
d536 4
d549 2
a550 1
the variable C<@@EXPORT> to C<@@EXPORT_OK>.  Finally, in the
d562 1
a562 1
	    OUTPUT:
d566 2
a567 2
currently support the const char * type.  Create a file called typemap in
the Mytest2 directory and place the following in it:
d572 1
a572 1
Makefile in the mylib directory.  Run make and watch that it does cd into
d582 3
a584 3
(When dealing with floating-point comparisons, it is best to not check for
equality, but rather that the difference between the expected and actual
result is below a certain amount (called epsilon) which is 0.01 in this case)
d586 1
a586 1
Run "C<make test>" and all should be well.
d588 1
a588 1
=head2 What has happened here?
d597 2
a598 3
In the .xs file, there's now a #include directive with the absolute path to
the mylib.h header file.  We changed this to a relative path so that we
could move the extension directory if we wanted to.
d604 2
a605 2
header file accessible by the Perl script (by calling either C<TESTVAL> or
C<&Mytest2::TESTVAL>).  There's also some XS code to allow calls to the
d610 6
a615 6
The .pm file originally exported the name C<TESTVAL> in the C<@@EXPORT> array.
This could lead to name clashes.  A good rule of thumb is that if the #define
is only going to be used by the C routines themselves, and not by the user,
they should be removed from the C<@@EXPORT> array.  Alternately, if you don't
mind using the "fully qualified name" of a variable, you could move most
or all of the items from the C<@@EXPORT> array into the C<@@EXPORT_OK> array.
d619 2
a620 2
If our include file had contained #include directives, these would not have
been processed by h2xs.  There is no good solution to this right now.
d622 1
a622 1
=item *
d625 1
a625 1
subdirectory.  That required only the addition of the C<MYEXTLIB> variable
d630 2
a631 2
simply specified that the library to be created here was a static archive
library (as opposed to a dynamically loadable library) and provided the
d634 1
a634 115
=back

=head2 Anatomy of .xs file

The .xs file of L<"EXAMPLE 4"> contained some new elements.  To understand
the meaning of these elements, pay attention to the line which reads

	MODULE = Mytest2		PACKAGE = Mytest2		

Anything before this line is plain C code which describes which headers
to include, and defines some convenience functions.  No translations are
performed on this part, it goes into the generated output C file as is.

Anything after this line is the description of XSUB functions.
These descriptions are translated by B<xsubpp> into C code which
implements these functions using Perl calling conventions, and which
makes these functions visible from Perl interpreter.

Pay a special attention to the function C<constant>.  This name appears
twice in the generated .xs file: once in the first part, as a static C
function, the another time in the second part, when an XSUB interface to
this static C function is defined.

This is quite typical for .xs files: usually the .xs file provides
an interface to an existing C function.  Then this C function is defined
somewhere (either in an external library, or in the first part of .xs file),
and a Perl interface to this function (i.e. "Perl glue") is described in the
second part of .xs file.  The situation in L<"EXAMPLE 1">, L<"EXAMPLE 2">,
and L<"EXAMPLE 3">, when all the work is done inside the "Perl glue", is
somewhat of an exception rather than the rule.

=head2 Getting the fat out of XSUBs

In L<"EXAMPLE 4"> the second part of .xs file contained the following
description of an XSUB:

	double
	foo(a,b,c)
		int             a
		long            b
		const char *    c
	    OUTPUT:
		RETVAL

Note that in contrast with L<"EXAMPLE 1">, L<"EXAMPLE 2"> and L<"EXAMPLE 3">,
this description does not contain the actual I<code> for what is done
is done during a call to Perl function foo().  To understand what is going
on here, one can add a CODE section to this XSUB:

	double
	foo(a,b,c)
		int             a
		long            b
		const char *    c
	    CODE:
		RETVAL = foo(a,b,c);
	    OUTPUT:
		RETVAL

However, these two XSUBs provide almost identical generated C code: B<xsubpp>
compiler is smart enough to figure out the C<CODE:> section from the first
two lines of the description of XSUB.  What about C<OUTPUT:> section?  In
fact, that is absolutely the same!  The C<OUTPUT:> section can be removed
as well, I<as far as C<CODE:> section or C<PPCODE:> section> is not
specified: B<xsubpp> can see that it needs to generate a function call
section, and will autogenerate the OUTPUT section too.  Thus one can
shortcut the XSUB to become:

	double
	foo(a,b,c)
		int             a
		long            b
		const char *    c

Can we do the same with an XSUB

	int
	is_even(input)
		int	input
	    CODE:
		RETVAL = (input % 2 == 0);
	    OUTPUT:
		RETVAL

of L<"EXAMPLE 2">?  To do this, one needs to define a C function C<int
is_even(int input)>.  As we saw in L<Anatomy of .xs file>, a proper place
for this definition is in the first part of .xs file.  In fact a C function

	int
	is_even(int arg)
	{
		return (arg % 2 == 0);
	}

is probably overkill for this.  Something as simple as a C<#define> will
do too:

	#define is_even(arg)	((arg) % 2 == 0)

After having this in the first part of .xs file, the "Perl glue" part becomes
as simple as

	int
	is_even(input)
		int	input

This technique of separation of the glue part from the workhorse part has
obvious tradeoffs: if you want to change a Perl interface, you need to
change two places in your code.  However, it removes a lot of clutter,
and makes the workhorse part independent from idiosyncrasies of Perl calling
convention.  (In fact, there is nothing Perl-specific in the above description,
a different version of B<xsubpp> might have translated this to TCL glue or
Python glue as well.)

=head2 More about XSUB arguments
d639 1
a639 26
B<xsubpp> compiler.

When you specify arguments to routines in the .xs file, you are really
passing three pieces of information for each argument listed.  The first
piece is the order of that argument relative to the others (first, second,
etc).  The second is the type of argument, and consists of the type
declaration of the argument (e.g., int, char*, etc).  The third piece is
the calling convention for the argument in the call to the library function.  

While Perl passes arguments to functions by reference,
C passes arguments by value; to implement a C function which modifies data
of one of the "arguments", the actual argument of this C function would be
a pointer to the data.  Thus two C functions with declarations

	int string_length(char *s);
	int upper_case_char(char *cp);

may have completely different semantics: the first one may inspect an array
of chars pointed by s, and the second one may immediately dereference C<cp>
and manipulate C<*cp> only (using the return value as, say, a success
indicator).  From Perl one would use these functions in
a completely different manner.

One conveys this info to B<xsubpp> by replacing C<*> before the
argument by C<&>.  C<&> means that the argument should be passed to a library
function by its address.  The above two function may be XSUB-ified as
d641 9
a649 7
	int
	string_length(s)
		char *	s

	int
	upper_case_char(cp)
		char	&cp
d651 1
a651 1
For example, consider:
d658 1
a658 1
The first Perl argument to this function would be treated as a char and assigned
d660 1
a660 1
The second Perl argument would be treated as a string pointer and assigned to the
d662 1
a662 1
actual call to the function foo that B<xsubpp> generates would look like this:
d666 1
a666 1
B<xsubpp> will parse the following function argument lists identically:
d675 3
a677 3
call to foo above).  By doing so, it is easy to understand exactly what
will be passed to the C function -- it will be whatever is in the "last
column".
d682 1
a682 1
=head2 The Argument Stack
d686 3
a688 4
usually 0.  "ST" is actually a macro that points to the n'th argument
on the argument stack.  ST(0) is thus the first argument on the stack and
therefore the first argument passed to the XSUB, ST(1) is the second
argument, and so on.
d690 1
a690 1
When you list the arguments to the XSUB in the .xs file, that tells B<xsubpp>
d695 1
a695 31
The actual values on the argument stack are pointers to the values passed
in.  When an argument is listed as being an OUTPUT value, its corresponding
value on the stack (i.e., ST(0) if it was the first argument) is changed.
You can verify this by looking at the C code generated for Example 3.
The code for the round() XSUB routine contains lines that look like this:

	double  arg = (double)SvNV(ST(0));
	/* Round the contents of the variable arg */
	sv_setnv(ST(0), (double)arg);

The arg variable is initially set by taking the value from ST(0), then is
stored back into ST(0) at the end of the routine.

XSUBs are also allowed to return lists, not just scalars.  This must be
done by manipulating stack values ST(0), ST(1), etc, in a subtly
different way.  See L<perlxs> for details.

XSUBs are also allowed to avoid automatic conversion of Perl function arguments
to C function arguments.  See L<perlxs> for details.  Some people prefer
manual conversion by inspecting C<ST(i)> even in the cases when automatic
conversion will do, arguing that this makes the logic of an XSUB call clearer.
Compare with L<"Getting the fat out of XSUBs"> for a similar tradeoff of
a complete separation of "Perl glue" and "workhorse" parts of an XSUB.

While experts may argue about these idioms, a novice to Perl guts may
prefer a way which is as little Perl-guts-specific as possible, meaning
automatic conversion and automatic call generation, as in
L<"Getting the fat out of XSUBs">.  This approach has the additional
benefit of protecting the XSUB writer from future changes to the Perl API.

=head2 Extending your Extension
d701 2
a702 3
or only loaded when called depends on where in the .pm file the subroutine
definition is placed.  You can also consult L<AutoLoader> for an alternate
way to store and load your extra subroutines.
d704 1
a704 1
=head2 Documenting your Extension
d708 1
a708 1
and the embedded documentation will be converted to the man page format,
d718 1
a718 1
=head2 Installing your Extension
d721 1
a721 1
is quite simple: you simply run "make install".  You will either need 
d725 1
a725 181
Alternately, you can specify the exact directory to place the extension's
files by placing a "PREFIX=/destination/directory" after the make install.
(or in between the make and install if you have a brain-dead version of make).
This can be very useful if you are building an extension that will eventually
be distributed to multiple systems.  You can then just archive the files in
the destination directory and distribute them to your destination systems.

=head2 EXAMPLE 5

In this example, we'll do some more work with the argument stack.  The
previous examples have all returned only a single value.  We'll now
create an extension that returns an array.

This extension is very Unix-oriented (struct statfs and the statfs system
call).  If you are not running on a Unix system, you can substitute for
statfs any other function that returns multiple values, you can hard-code
values to be returned to the caller (although this will be a bit harder
to test the error case), or you can simply not do this example.  If you
change the XSUB, be sure to fix the test cases to match the changes.

Return to the Mytest directory and add the following code to the end of
Mytest.xs:

	void
	statfs(path)
		char *  path
	    INIT:
		int i;
		struct statfs buf;

	    PPCODE:
		i = statfs(path, &buf);
		if (i == 0) {
			XPUSHs(sv_2mortal(newSVnv(buf.f_bavail)));
			XPUSHs(sv_2mortal(newSVnv(buf.f_bfree)));
			XPUSHs(sv_2mortal(newSVnv(buf.f_blocks)));
			XPUSHs(sv_2mortal(newSVnv(buf.f_bsize)));
			XPUSHs(sv_2mortal(newSVnv(buf.f_ffree)));
			XPUSHs(sv_2mortal(newSVnv(buf.f_files)));
			XPUSHs(sv_2mortal(newSVnv(buf.f_type)));
			XPUSHs(sv_2mortal(newSVnv(buf.f_fsid[0])));
			XPUSHs(sv_2mortal(newSVnv(buf.f_fsid[1])));
		} else {
			XPUSHs(sv_2mortal(newSVnv(errno)));
		}

You'll also need to add the following code to the top of the .xs file, just
after the include of "XSUB.h":

	#include <sys/vfs.h>

Also add the following code segment to test.pl while incrementing the "1..9"
string in the BEGIN block to "1..11":

	@@a = &Mytest::statfs("/blech");
	print ((scalar(@@a) == 1 && $a[0] == 2) ? "ok 10\n" : "not ok 10\n");
	@@a = &Mytest::statfs("/");
	print scalar(@@a) == 9 ? "ok 11\n" : "not ok 11\n";

=head2 New Things in this Example

This example added quite a few new concepts.  We'll take them one at a time.

=over 4

=item *

The INIT: directive contains code that will be placed immediately after
the argument stack is decoded.  C does not allow variable declarations at
arbitrary locations inside a function,
so this is usually the best way to declare local variables needed by the XSUB.
(Alternatively, one could put the whole C<PPCODE:> section into braces, and
put these declarations on top.)

=item *

This routine also returns a different number of arguments depending on the
success or failure of the call to statfs.  If there is an error, the error
number is returned as a single-element array.  If the call is successful,
then a 9-element array is returned.  Since only one argument is passed into
this function, we need room on the stack to hold the 9 values which may be
returned.

We do this by using the PPCODE: directive, rather than the CODE: directive.
This tells B<xsubpp> that we will be managing the return values that will be
put on the argument stack by ourselves.

=item *

When we want to place values to be returned to the caller onto the stack,
we use the series of macros that begin with "XPUSH".  There are five
different versions, for placing integers, unsigned integers, doubles,
strings, and Perl scalars on the stack.  In our example, we placed a
Perl scalar onto the stack.  (In fact this is the only macro which
can be used to return multiple values.)

The XPUSH* macros will automatically extend the return stack to prevent
it from being overrun.  You push values onto the stack in the order you
want them seen by the calling program.

=item *

The values pushed onto the return stack of the XSUB are actually mortal SV's.
They are made mortal so that once the values are copied by the calling
program, the SV's that held the returned values can be deallocated.
If they were not mortal, then they would continue to exist after the XSUB
routine returned, but would not be accessible.  This is a memory leak.

=item *

If we were interested in performance, not in code compactness, in the success
branch we would not use C<XPUSHs> macros, but C<PUSHs> macros, and would
pre-extend the stack before pushing the return values:

	EXTEND(SP, 9);

The tradeoff is that one needs to calculate the number of return values
in advance (though overextending the stack will not typically hurt
anything but memory consumption).

Similarly, in the failure branch we could use C<PUSHs> I<without> extending
the stack: the Perl function reference comes to an XSUB on the stack, thus
the stack is I<always> large enough to take one return value.

=back

=head2 EXAMPLE 6 (Coming Soon)

Passing in and returning references to arrays and/or hashes

=head2 EXAMPLE 7 (Coming Soon)

XPUSH args AND set RETVAL AND assign return value to array

=head2 EXAMPLE 8 (Coming Soon)

Setting $!

=head2 EXAMPLE 9 (Coming Soon)

Getting fd's from filehandles

=head2 Troubleshooting these Examples

As mentioned at the top of this document, if you are having problems with
these example extensions, you might see if any of these help you.

=over 4

=item *

In versions of 5.002 prior to the gamma version, the test script in Example
1 will not function properly.  You need to change the "use lib" line to
read:

	use lib './blib';

=item *

In versions of 5.002 prior to version 5.002b1h, the test.pl file was not
automatically created by h2xs.  This means that you cannot say "make test"
to run the test script.  You will need to add the following line before the
"use extension" statement:

	use lib './blib';

=item *

In versions 5.000 and 5.001, instead of using the above line, you will need
to use the following line:

	BEGIN { unshift(@@INC, "./blib") }

=item *

This document assumes that the executable named "perl" is Perl version 5.  
Some systems may have installed Perl version 5 as "perl5".

=back

=head1 See also
d730 1
a730 1
=head1 Author
d739 1
a739 1
1999/11/30
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d8 2
a9 2
a Perl extension.  The reader is assumed to have access to L<perlguts>,
L<perlapi> and L<perlxs>.
d190 1
a190 2
You can safely ignore the line about "prototyping behavior" - it is
explained in the section "The PROTOTYPES: Keyword" in L<perlxs>.
d479 1
a479 1
example).  However, in order to better accommodate calling pre-existing C
d684 1
a684 2
performed on this part, apart from having embedded POD documentation
skipped over (see L<perlpod>) it goes into the generated output C file as is.
d1059 1
a1059 1
=head2 EXAMPLE 6
d1061 1
a1061 135
In this example, we will accept a reference to an array as an input
parameter, and return a reference to an array of hashes.  This will
demonstrate manipulation of complex Perl data types from an XSUB.

This extension is somewhat contrived.  It is based on the code in
the previous example.  It calls the statfs function multiple times,
accepting a reference to an array of filenames as input, and returning
a reference to an array of hashes containing the data for each of the
filesystems.

Return to the Mytest directory and add the following code to the end of
Mytest.xs:

	SV *
	multi_statfs(paths)
		SV * paths
	    INIT:
        	AV * results;
        	I32 numpaths = 0;
        	int i, n;
        	struct statfs buf;

        	if ((!SvROK(paths))
		    || (SvTYPE(SvRV(paths)) != SVt_PVAV)
		    || ((numpaths = av_len((AV *)SvRV(paths))) < 0))
		{
		    XSRETURN_UNDEF;
        	}
        	results = (AV *)sv_2mortal((SV *)newAV());
	    CODE:
        	for (n = 0; n <= numpaths; n++) {
		    HV * rh;
            	    STRLEN l;
            	    char * fn = SvPV(*av_fetch((AV *)SvRV(paths), n, 0), l);

            	    i = statfs(fn, &buf);
            	    if (i != 0) {
		        av_push(results, newSVnv(errno));
		        continue;
            	    }

            	    rh = (HV *)sv_2mortal((SV *)newHV());

            	    hv_store(rh, "f_bavail", 8, newSVnv(buf.f_bavail), 0);
            	    hv_store(rh, "f_bfree",  7, newSVnv(buf.f_bfree),  0);
            	    hv_store(rh, "f_blocks", 8, newSVnv(buf.f_blocks), 0);
            	    hv_store(rh, "f_bsize",  7, newSVnv(buf.f_bsize),  0);
            	    hv_store(rh, "f_ffree",  7, newSVnv(buf.f_ffree),  0);
            	    hv_store(rh, "f_files",  7, newSVnv(buf.f_files),  0);
            	    hv_store(rh, "f_type",   6, newSVnv(buf.f_type),   0);

            	    av_push(results, newRV((SV *)rh));
        	}
        	RETVAL = newRV((SV *)results);
	    OUTPUT:
        	RETVAL

And add the following code to test.pl, while incrementing the "1..11" 
string in the BEGIN block to "1..13":

	$results = Mytest::multi_statfs([ '/', '/blech' ]);
	print ((ref $results->[0]) ? "ok 12\n" : "not ok 12\n");
	print ((! ref $results->[1]) ? "ok 13\n" : "not ok 13\n");

=head2 New Things in this Example

There are a number of new concepts introduced here, described below:

=over 4

=item *

This function does not use a typemap.  Instead, we declare it as accepting
one SV* (scalar) parameter, and returning an SV* value, and we take care of
populating these scalars within the code.  Because we are only returning
one value, we don't need a C<PPCODE:> directive - instead, we use C<CODE:>
and C<OUTPUT:> directives.

=item *

When dealing with references, it is important to handle them with caution.
The C<INIT:> block first checks that
C<SvROK> returns true, which indicates that paths is a valid reference.  It
then verifies that the object referenced by paths is an array, using C<SvRV>
to dereference paths, and C<SvTYPE> to discover its type.  As an added test,
it checks that the array referenced by paths is non-empty, using the C<av_len>
function (which returns -1 if the array is empty).  The XSRETURN_UNDEF macro
is used to abort the XSUB and return the undefined value whenever all three of
these conditions are not met.

=item *

We manipulate several arrays in this XSUB.  Note that an array is represented
internally by an AV* pointer.  The functions and macros for manipulating
arrays are similar to the functions in Perl: C<av_len> returns the highest
index in an AV*, much like $#array; C<av_fetch> fetches a single scalar value
from an array, given its index; C<av_push> pushes a scalar value onto the
end of the array, automatically extending the array as necessary.

Specifically, we read pathnames one at a time from the input array, and
store the results in an output array (results) in the same order.  If
statfs fails, the element pushed onto the return array is the value of
errno after the failure.  If statfs succeeds, though, the value pushed
onto the return array is a reference to a hash containing some of the
information in the statfs structure.

As with the return stack, it would be possible (and a small performance win)
to pre-extend the return array before pushing data into it, since we know
how many elements we will return:

	av_extend(results, numpaths);

=item *

We are performing only one hash operation in this function, which is storing
a new scalar under a key using C<hv_store>.  A hash is represented by an HV*
pointer.  Like arrays, the functions for manipulating hashes from an XSUB
mirror the functionality available from Perl.  See L<perlguts> and L<perlapi>
for details.

=item *

To create a reference, we use the C<newRV> function.  Note that you can
cast an AV* or an HV* to type SV* in this case (and many others).  This
allows you to take references to arrays, hashes and scalars with the same
function.  Conversely, the C<SvRV> function always returns an SV*, which may
need to be be cast to the appropriate type if it is something other than a
scalar (check with C<SvTYPE>).

=item *

At this point, xsubpp is doing very little work - the differences between
Mytest.xs and Mytest.c are minimal.

=back
d1115 1
a1115 1
For more information, consult L<perlguts>, L<perlapi>, L<perlxs>, L<perlmod>,
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d523 1
a523 1
	    clean  => {'FILES' => 'libmylib$(LIB_EXT)'},
d801 1
a801 1
the calling convention for the argument in the call to the library function.
d918 3
a920 3
and the embedded documentation will be converted to the manpage format,
then placed in the blib directory.  It will be copied to Perl's
manpage directory when the extension is installed.
d931 1
a931 1
is quite simple: you simply run "make install".  You will either need
d1120 1
a1120 1
And add the following code to test.pl, while incrementing the "1..11"
d1189 1
a1189 1
need to be cast to the appropriate type if it is something other than a
d1207 1
a1207 1
=head2 EXAMPLE 9 Passing open files to XSes
d1209 1
a1209 99
You would think passing files to an XS is difficult, with all the
typeglobs and stuff. Well, it isn't.

Suppose that for some strange reason we need a wrapper around the
standard C library function C<fputs()>. This is all we need:

	#define PERLIO_NOT_STDIO 0
	#include "EXTERN.h"
	#include "perl.h"
	#include "XSUB.h"

	#include <stdio.h>

	int
	fputs(s, stream)
		char *          s
		FILE *	        stream

The real work is done in the standard typemap.

B<But> you loose all the fine stuff done by the perlio layers. This
calls the stdio function C<fputs()>, which knows nothing about them.

The standard typemap offers three variants of PerlIO *:
C<InputStream> (T_IN), C<InOutStream> (T_INOUT) and C<OutputStream>
(T_OUT). A bare C<PerlIO *> is considered a T_INOUT. If it matters
in your code (see below for why it might) #define or typedef
one of the specific names and use that as the argument or result
type in your XS file.

The standard typemap does not contain PerlIO * before perl 5.7,
but it has the three stream variants. Using a PerlIO * directly
is not backwards compatible unless you provide your own typemap.

For streams coming I<from> perl the main difference is that
C<OutputStream> will get the output PerlIO * - which may make
a difference on a socket. Like in our example...

For streams being handed I<to> perl a new file handle is created
(i.e. a reference to a new glob) and associated with the PerlIO *
provided. If the read/write state of the PerlIO * is not correct then you
may get errors or warnings from when the file handle is used.
So if you opened the PerlIO * as "w" it should really be an
C<OutputStream> if open as "r" it should be an C<InputStream>.

Now, suppose you want to use perlio layers in your XS. We'll use the
perlio C<PerlIO_puts()> function as an example.

In the C part of the XS file (above the first MODULE line) you
have

	#define OutputStream	PerlIO *
    or
	typedef PerlIO *	OutputStream;


And this is the XS code:

	int
	perlioputs(s, stream)
		char *          s
		OutputStream	stream
	CODE:
		RETVAL = PerlIO_puts(stream, s);
	OUTPUT:
		RETVAL

We have to use a C<CODE> section because C<PerlIO_puts()> has the arguments
reversed compared to C<fputs()>, and we want to keep the arguments the same.

Wanting to explore this thoroughly, we want to use the stdio C<fputs()>
on a PerlIO *. This means we have to ask the perlio system for a stdio
C<FILE *>:

	int
	perliofputs(s, stream)
		char *          s
		OutputStream	stream
	PREINIT:
		FILE *fp = PerlIO_findFILE(stream);
	CODE:
		if (fp != (FILE*) 0) {
			RETVAL = fputs(s, fp);
		} else {
			RETVAL = -1;
		}
	OUTPUT:
		RETVAL

Note: C<PerlIO_findFILE()> will search the layers for a stdio
layer. If it can't find one, it will call C<PerlIO_exportFILE()> to
generate a new stdio C<FILE>. Please only call C<PerlIO_exportFILE()> if
you want a I<new> C<FILE>. It will generate one on each call and push a
new stdio layer. So don't call it repeatedly on the same
file. C<PerlIO()>_findFILE will retrieve the stdio layer once it has been
generated by C<PerlIO_exportFILE()>.

This applies to the perlio system only. For versions before 5.7,
C<PerlIO_exportFILE()> is equivalent to C<PerlIO_findFILE()>.
d1244 1
a1244 1
This document assumes that the executable named "perl" is Perl version 5.
a1260 3
PerlIO material contributed by Lupe Christoph, with some clarification
by Nick Ing-Simmons.

d1263 1
a1263 1
2002/05/08
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d213 1
a213 1
Now we make the script executable (C<chmod +x hello>), run the script
d695 1
a695 1
function, then another time in the second part, when an XSUB interface to
@


1.1.1.7
log
@perl 5.8.8 import
@
text
@d236 1
a236 1
There does not need to be whitespace at the start of the "C<int input>"
d238 1
a238 1
the end of that line is also optional.  Any amount and kind of whitespace
d416 1
a416 1
line starts with optional whitespace, and may have an optional terminating
@


1.1.1.8
log
@import perl 5.10.0 from CPAN
@
text
@d94 1
a94 1
MANIFEST, Makefile.PL, Mytest.pm, Mytest.xs, Mytest.t, and Changes.
d101 10
a110 10
    use ExtUtils::MakeMaker;
    # See lib/ExtUtils/MakeMaker.pm for details of how to influence
    # the contents of the Makefile that is written.
    WriteMakefile(
	NAME         => 'Mytest',
	VERSION_FROM => 'Mytest.pm', # finds $VERSION
	LIBS         => [''],   # e.g., '-lm'
	DEFINE       => '',     # e.g., '-DHAVE_SOMETHING'
	INC          => '',     # e.g., '-I/usr/include/other'
    );
d114 1
a114 1
    package Mytest;
d116 2
a117 3
    use 5.008008;
    use strict;
    use warnings;
d119 2
a120 1
    require Exporter;
d122 5
a126 2
    our @@ISA = qw(Exporter);
    our %EXPORT_TAGS = ( 'all' => [ qw(
d128 2
a129 3
    ) ] );

    our @@EXPORT_OK = ( @@{ $EXPORT_TAGS{'all'} } );
d131 1
a131 1
    our @@EXPORT = qw(
d133 1
a133 1
    );
d135 1
a135 1
    our $VERSION = '0.01';
d137 3
a139 8
    require XSLoader;
    XSLoader::load('Mytest', $VERSION);

    # Preloaded methods go here.

    1;
    __END__
    # Below is the stub of documentation for your module. You better edit it!
d146 3
a148 3
    #include "EXTERN.h"
    #include "perl.h"
    #include "XSUB.h"
d150 1
a150 3
    #include "ppport.h"

    MODULE = Mytest		PACKAGE = Mytest
d154 4
a157 4
    void
    hello()
	CODE:
	    printf("Hello, world!\n");
d166 5
a170 5
    % perl Makefile.PL
    Checking if your kit is complete...
    Looks good
    Writing Makefile for Mytest
    %
d176 13
a188 16
    % make
    cp lib/Mytest.pm blib/lib/Mytest.pm
    perl xsubpp  -typemap typemap  Mytest.xs > Mytest.xsc && mv Mytest.xsc Mytest.c
    Please specify prototyping behavior for Mytest.xs (see perlxs manual)
    cc -c     Mytest.c
    Running Mkbootstrap for Mytest ()
    chmod 644 Mytest.bs
    rm -f blib/arch/auto/Mytest/Mytest.so
    cc  -shared -L/usr/local/lib Mytest.o  -o blib/arch/auto/Mytest/Mytest.so   \
                \

    chmod 755 blib/arch/auto/Mytest/Mytest.so
    cp Mytest.bs blib/arch/auto/Mytest/Mytest.bs
    chmod 644 blib/arch/auto/Mytest/Mytest.bs
    Manifying blib/man3/Mytest.3pm
    %
d205 1
a205 1
    #! /opt/perl5/bin/perl
d207 1
a207 1
    use ExtUtils::testlib;
d209 1
a209 1
    use Mytest;
d211 1
a211 1
    Mytest::hello();
d216 3
a218 3
    % ./hello
    Hello, world!
    %
d228 7
a234 7
    int
    is_even(input)
	    int input
	CODE:
	    RETVAL = (input % 2 == 0);
	OUTPUT:
	    RETVAL
d247 1
a247 1
file Mytest.t.  This file is set up to imitate the same kind of testing
d250 7
a256 13
when the test is correct, "not ok" when it is not.

    use Test::More tests => 4;
    BEGIN { use_ok('Mytest') };

    #########################

    # Insert your test code below, the Test::More module is use()ed here so read
    # its man page ( perldoc Test::More ) for help writing this test script.

    is(&Mytest::is_even(0), 1);
    is(&Mytest::is_even(1), 0);
    is(&Mytest::is_even(2), 1);
d261 8
a268 6
    %make test
    PERL_DL_NONLAZY=1 /usr/bin/perl "-MExtUtils::Command::MM" "-e" "test_harness(0, 'blib/lib', 'blib/arch')" t/*.t
    t/Mytest....ok
    All tests successful.
    Files=1, Tests=4,  0 wallclock secs ( 0.03 cusr +  0.00 csys =  0.03 CPU)
    %
d296 1
a296 1
using "C<make test>" ensures that you will test your new extension, not the
d336 1
a336 1
The importance of writing good test scripts cannot be over-emphasized.  You
d341 5
a345 4
By running "C<make test>", you ensure that your Mytest.t script runs and uses
the correct version of your extension.  If you have many test cases,
save your test files in the "t" directory and use the suffix ".t".
When you run "C<make test>", all of these test files will be executed.
d372 2
a373 2
Generate the Makefile and run make.  Change the test number in Mytest.t to
"9" and add the following tests:
d375 5
a379 5
	$i = -1.5; &Mytest::round($i); is( $i, -2.0 );
	$i = -1.1; &Mytest::round($i); is( $i, -1.0 );
	$i = 0.0; &Mytest::round($i);  is( $i,  0.0 );
	$i = 0.5; &Mytest::round($i);  is( $i,  1.0 );
	$i = 1.2; &Mytest::round($i);  is( $i,  1.0 );
d385 1
a385 1
literal.  To see what happens, temporarily add the following line to Mytest.t:
d450 1
a450 2
		Perl_croak(aTHX_ "Usage: Mytest::round(arg)");
        PERL_UNUSED_VAR(cv); /* -W */
a460 1
        SvSETMAGIC(ST(0));
d462 1
a462 1
	    XSRETURN_EMPTY;
d614 1
a614 1
Now edit the Mytest2.t script and change the number of tests to "4",
d617 3
a619 3
	is( &Mytest2::foo(1, 2, "Hello, world!"), 7 );
	is( &Mytest2::foo(1, 2, "0.0"), 7 );
	ok( abs(&Mytest2::foo(0, 0, "-3.4") - 0.6) <= 0.01 );
d625 1
a625 2
Run "C<make test>" and all should be well. There are some warnings on missing tests
for the Mytest2::mylib extension, but you can ignore them.
d681 1
a681 1
	MODULE = Mytest2		PACKAGE = Mytest2
d975 2
d986 2
a987 2
Also add the following code segment to Mytest.t while incrementing the "9"
tests to "11":
d990 1
a990 1
	ok( scalar(@@a) == 1 && $a[0] == 2 );
d992 1
a992 1
	is( scalar(@@a), 7 );
d1049 1
a1049 1
	EXTEND(SP, 7);
d1076 43
a1118 29
    SV *
    multi_statfs(paths)
	    SV * paths
	INIT:
	    AV * results;
	    I32 numpaths = 0;
	    int i, n;
	    struct statfs buf;

	    if ((!SvROK(paths))
		|| (SvTYPE(SvRV(paths)) != SVt_PVAV)
		|| ((numpaths = av_len((AV *)SvRV(paths))) < 0))
	    {
		XSRETURN_UNDEF;
	    }
	    results = (AV *)sv_2mortal((SV *)newAV());
	CODE:
	    for (n = 0; n <= numpaths; n++) {
		HV * rh;
		STRLEN l;
		char * fn = SvPV(*av_fetch((AV *)SvRV(paths), n, 0), l);

		i = statfs(fn, &buf);
		if (i != 0) {
		    av_push(results, newSVnv(errno));
		    continue;
		}

		rh = (HV *)sv_2mortal((SV *)newHV());
d1120 2
a1121 16
		hv_store(rh, "f_bavail", 8, newSVnv(buf.f_bavail), 0);
		hv_store(rh, "f_bfree",  7, newSVnv(buf.f_bfree),  0);
		hv_store(rh, "f_blocks", 8, newSVnv(buf.f_blocks), 0);
		hv_store(rh, "f_bsize",  7, newSVnv(buf.f_bsize),  0);
		hv_store(rh, "f_ffree",  7, newSVnv(buf.f_ffree),  0);
		hv_store(rh, "f_files",  7, newSVnv(buf.f_files),  0);
		hv_store(rh, "f_type",   6, newSVnv(buf.f_type),   0);

		av_push(results, newRV((SV *)rh));
	    }
	    RETVAL = newRV((SV *)results);
	OUTPUT:
	    RETVAL

And add the following code to Mytest.t, while incrementing the "11"
tests to "13":
d1124 2
a1125 2
	ok( ref $results->[0]) );
	ok( ! ref $results->[1] );
a1361 2
Changes for h2xs as of Perl 5.8.x by Renee Baecker

d1364 1
a1364 1
2007/10/11
@


1.1.1.9
log
@import perl 5.10.1
@
text
@d93 2
a94 2
directory.  Several files will be created under the Mytest dir, including
MANIFEST, Makefile.PL, lib/Mytest.pm, Mytest.xs, t/Mytest.t, and Changes.
d199 1
a199 1
explained in L<perlxs/"The PROTOTYPES: Keyword">.
d431 1
a431 1
after the OUTPUT: directive.  The use of RETVAL tells Perl that you
@


1.1.1.10
log
@Perl 5.12.2 from CPAN
@
text
@d868 1
a868 1
will be passed to the C function; it will be whatever is in the "last
@


